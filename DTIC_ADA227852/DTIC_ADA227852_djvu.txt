DM FILE COPY - 

AD-A227 852 ' 




CECOM 


Vu A 

\*\<\ r ^ /«■/' 


\*vrv /a/*/ 


CENTER FOR SOFTWARE ENGINEERING 
ADVANCED SOFTWARE TECHNOLOGY 


Subject: Final Report - Distributed Issues for Ada 

Real-Time Systems 


CIN: C02 092LA 0013 00 


23 July 1990 


DTIC 

^electe*^ 

Vcmiwl I 

% B v 


DfsTTuBUTION STATEMENT A 

Approved tor pubtte rwfcasff- 
Dietrtbutlon Unlimited 





REPORT DOCUMENTATION PAGE 

Form Approved 

OPMNo. 0704-0 m 

Htk mpmrwq tuakan lor Mi ahm Wwi—i k hMM ■ k «nai 1 heur pknomk raudng t» km» to Fkkw^ ravuckora ■ ■ ■ c»k «aan( tai )■ mg are 

nimii k i m -nmn ms m*m*ngu» mlirrnr tt nontmon. hand wiwm WMrtie lha kiMMnkamirk* mtma O *>• OPkacf a Monraken. xaaw iimanun 
•w iMitM tw human. (o WaalangiBn HakBouanaq tiwc. Dnoaw tor nomanon Opmem and hapoa. 121* Jakaaon Dam H^a, (wta law, Artnjaon. VA 2220* -Out. and a 

Via Orica 3 kaomauor and hapu>—r Man. Okioa a Manapaman are kuopaL Ikka Myron, DC 20601 

1. AGENCY USE ONLY (Lmv* Bun*) 2. REPORT DATE 

23 July 1990 

S. REPORT TYPE AND DATES COVERED 

Final Report 

4. TITLE AND SUBTfTLE 

Distributed Issues for Ada Real-Time Systems 

5. FUNDING NUMBERS 

MDA 903-87- C- 0056 

e.AUTHOR(S) 

Thomas E. Griest 

7. PERFORMING ORGANIZATION NAAt(S) AND ADDRESSES) 

Lab Tek Corporation 

8 Lunar Drive 

Woodbridge, CT 06525 

e performing organization 

REPORT NUMBER 

8. SPONSORINC^MONITORING AGENCY NAME(S) AND ADDRESSEES; 

U. S. Army HQ CEC0M 

Center for Software Engineering 

Fort Monmouth, NJ 07703-5000 

10. SPONSORING'MONrTORlNG AGENCY 
REPORT NUMBER 

11. SUPPLEMENTARY NOTES 

12a. DISTRIBUTION/AVAILABILrrY STATEMENT 

STATEMENT A UNLIMITED 

12b. DISTRIBUTION CODE 

12. ABSTRACT (MaximjmZOO worCs) 

This work addresses an approach to reduce the complexity of distributed systems by 
extending the standard Ada tasking model to handle the distributed processing and by introducing 
a failure model for reliability issues. It uses software developed in a previous CECOM research 
project, the Border Defense System (BDS) distributed demonstration application, that addressed 
the performance benefits that could be gained by the distribution of real-time Ada systems. To 
achieve increased performance, a new approach to improving parallel execution was studied. The 
approach was to create a data structure consisting of an array of tasks and distribute the elements 
of the array across a set of processors. Performance benefits are then achieved as a function of the 
available processors. A simple failure model appropriate for a class of /applications which can 
tolerate interruptions in service for up to one second was introduced. /• 

' . ' - ' , • • 

i<. SUBJECT TERMS ‘ - 

ADA, REAL-TIME, DISTRIBUTED SYSTEMS, FAULT TOLERANCE , ■ 

IS. NUMBER cf PAGES 

309 

it. PRlOc CODE 

*7. security classification it security classification ii. security Classification 

O REPOFTT <y THIS PAGE Of ABSTRACT 

UNCLASSIFIED UNCLASSIFIED UNCLASSIFIED 

22. LIMITATION Of ABSTRACT 

UL 


btanoarc fonr. ?9t <*-*ev Jr-fit*/ 




NSN 7640-01-280-5500 





















DISTRIBUTED ISSUES PROJECT 
FINAL REPORT 


PREPARED FOR: 

U.S. Army HQ CECOM 
Center for Software Engineering 
Advanced Software Technology 
Fort Monmouth, NJ 07703-5000 


PREPARED BY: 

LabTek Corporation 
8 Lunar Drive 
Woodbridge, CT 06525 


DATE: 

13 Julyl990 


The views, opinions, and/or findings contained in this report are those of the 
author and should not be construed as an official Department of the Army 
position, policy, or decision, unless so designated by other documentation. 







EXECUTIVE SUMMARY 


The use of distributed systems to obtain gains in system throughput and reliability is 
expected to continue for the foreseeable future. These systems provide substantial benefits 
in performance and fault tolerance at the expense of significantly increased complexity. 
This work addresses an approach to reduce the complexity of these systems by extending the 
standard Ada tasking model to handle the distributed processor and reliability issues. It 
uses software developed in a previous CECOM research project that addressed the 
performance benefits that could be gained by the distribution of real-time Ada systems. 

The Ada tasking model is already reasonably well understood from a uniprocessor point of 
view but it is currently not defined to support characteristics of distributed systems. 
However, by taking advantage of the same model for distributed systems, fewer new 
concepts need to be introduced. This reduction in concepts results in a less complex and 
more flexible system. To achieve increased performance, a new approach to improving 
parallel execution was studied. The approach was to create a data structure consisting of an 
array of tasks and distribute the elements of the array across a set of processors. This task 
array provides the ability to achieve performance benefits as a function of the available 
processors. 

The Ada tasking model is currently silent on failure semantics. This study introduces a 
simple failure recovery mechanism appropriate for a class of applications which can tolerate 
interruptions in service for up to one second. Enhanced fault detection and recovery logic 
have been added to demonstrate the ability to continue operation in the presence of some 
hardware failures. To improve the flexibility of the system configuration, a new runtime 
interface has been established to allow dynamic reconfiguration at runtime. 





Table of Contents 


1. Introduction.1 

2. Complexity of Distributed Systems.2 

3. Use of the Ada Tasking Model for Distributed Systems.4 

4. Responding to Failures in a Distributed System.6 

5. Demonstration Application.8 

5.1 Enhancements to the Demonstration Application Software.9 

5.2 Improvements to the Distributed Runtime .10 

5.2.1 Distribution Control Details.12 

6. Performance Characteristics .15 

6.1 Benchmark Results.17 

6.2 Performance Gains .22 

7. Design of Systems Using Distributed Ada.25 

7.1 Hardware Considerations.25 

7.2 Software Considerations.26 

7.3 Differences Between Distributed and Uniprocessor Implementations.28 

8. Limitations of the Distribution Support .31 

8.1 Task Identification .31 

8.2 Code Replication.32 

8.3 Network Error Recovery .32 

9. Compiler and Runtime Problems .34 

10. Summary .36 

11. References .38 

12. Appendix A - Border Defense System Ada Source Code.39 

13. Appendix B - Distributed Runtime Source Code.199 


-i- 





























Table of Contents 


Figure 1. Software Subsystems . 
Figure 2. Top Level BDS Design 


Accession For 

NTIS GRA&I 
DTIC TAB 
Unannounced 
Just If teat Ion 


By- 

Distribution/ 


Availability Codes 



Avail and/or 

Dlst 

Speolal 









Distributed Issues Final Report 


1. Introduction 

This paper describes the results of a project to investigate issues in distributed Ada 
programs. It is based on an earlier demonstration project done by the U.S. Army, Center for 
Software Engineering at Fort Monmouth, NJ[1]. It goes beyond that initial work in two 
important areas: using task arrays to expand parallelism; and improving the benefits of 
program distribution beyond performance gains by providing support for fault tolerance. 

The earlier project had statically allocated tasks to a processor, and each task was unique, 
based on a uniprocessor design. The new approach of using task arrays supports the 
capability to spread the execution of independent iterative operations across a distributed 
system. « The distributed runtime was re-implemented to provide much more flexible 
reconfiguration capabilities. This made it possible to measure performance gains over a 
wider set of configurations. The increased flexibility also made it possible for the system to 
reconfigure under fault conditions and continue operation in a degraded mode. 

This paper briefly outlines the application and its key performance characteristics used to 
demonstrate use of the distributed Ada techniques. Improvements to the application are 
mentioned, as well as enhancements to the distributed runtime system. Performance 
benchmarks were done to assess the benefits obtained by distribution of a single Ada 
program over a network of three Intel 80386 processors connected by an Ethernet. The 
results of the benchmarks were analyzed to explain how the system reacted under various 
processing loads and system configurations. These findings were further analyzed to identify 
design considerations which can be used to improve performance for other distributed 
applications. 


-1- 




Distributed Issues Final Report 


2. Complexity of Distributed Systems 

Systems which are distributed tend to be much more difficult to develop than a single 
processor implementation of the same problem. This is due to several contributing factors. 
True parallelism creates new scheduling problems and new ways in which resource 
contention can occur within systems. Distribution introduces the significant new 
requirement of communication. This inter-processor communication is often at a much 
higher data rate and less predictable than typical communication with external devices. For 
this reason, buffering and synchronization become critical design considerations. 

Adding to the problem of distributed real-time systems is the issue of maintaining a common 
sense of time among all of the processors. Application software often becomes involved in 
the process of keeping track of time and adjusting for time differences among processors. 
This burden generally does not exist in uniprocessor applications. 

Finally, distributed systems generally are constructed in an ad-hoc manner, creating a vast 
number of dissimilar architectures. This effectively eliminates the mass market necessary to 
encourage tool developers to support distributed systems. The result is that tools for 
developing distributed systems are usually custom made and frequently lacking in capability. 
Horror stories of developers using dozens of separate in-circuit emulators, each with their 
own console to test distributed systems, are common. Thus the nature of distributed systems 
simply adds to the difficulties of understanding and solving the complex problems which 
arise during development. 

The benefits of distributed systems are found in essentially three fundamental 
characteristics: performance, physical separation, and fault tolerance. It is nearly always the 
case that the price/performance ratio of computer hardware favors many lower cost 


-2- 




Distributed Issues Final Report 


processors over a single higher performance processor. Furthermore, the ability to handle 
interrupts by distributed processors reduces the number of context switches (and associated 
overhead) required. This often results in better response time and overall performance by 
having several lower cost processors concentrate on a single task rather than having one high 
cost processor switching among many tasks. 

The physical separation of processors provides the ability to have processing resources in 
close proximity to isolated system hardware. This is often necessary to reduce the wiring and 
provide a degree of autonomy between subsystems. This can be extremely important in 
situations which may suffer from localized damage. Similarly, the additional processors 
make it possible for continued operation in the presence of processor failures. Eliminating 
all situations where a single component failure will result in system failure is a common 
axiom of fault tolerant systems. 

The growing number of distributed systems in use is evidence to the fact that the benefits of 
these systems are significant even though there is additional complexity. Techniques that 
reduce the complexity of these systems would further enhance their attractiveness and are 
likely to lead to more cost-effective systems and widespread use of fault tolerant computing. 


-3- 






Distributed Issues Final Report 


3. Use of the Ada Tasking Model for Distributed Systems 

Several approaches are used to support cooperative processing on distributed systems. Most 
frequently, a message-based mechanism of communication is defined to allow a program on 
one processor to interface with programs on other processors. These messages are generally 
developed in an application-specific way with a wide variety of characteristics and 
requirements. Other techniques include some type of formalized remote procedure call 
approach with surrogate tasks to execute the procedures that are remotely invoked. 

The approach used on this demonstration was to utilize the Ada tasking model of 
concurrency for all local and remote communication between parallel threads of execution. 
This approach to concurrency is often referred to as "Distributed Ada" and has a number of 
advantages to other approaches. Among them are: 

1) The ability of the compiler to check interfaces between physical processors. 

2) A consistent approach to parallelism - all concurrent activities are expressly stated 
with a consistent formal mechanism making the system less complex. 

3) Re-configuration is facilitated, since the interface between communicating tasks on 
a processor is the same as that among separate processors, thus allowing tasks to be 
migrated more easily. 

4) Consistency helps to make distributed testing and debugging more easily supported 
by compiler implementers. Ad hoc approaches make debugging tools prohibitively 
expensive and generally not as complete. 


-4- 





Distributed Issues Final Report 


By utilizing the Ada tasking model, the underlying details for remote communication and 
maintaining a consistent sense of time are hidden. Since there is a stable model to support, 
this also creates the possibility for system vendors to provide hardware that is optimized to 
support distribution of Ada tasks. 

The benefits of providing a well understood, uniform approach to concurrent programming 
should not be underestimated. The ability for developers to have a clear understanding of 
how their distributed system interacts is essential in lowering the costs and improving the 
reliability of these systems. From this point of view, using the Ada tasking model for 
distributed communication and synchronization provides the best opportunity for 
consistency when programming in the Ada language. 


-J- 





Distributed Issues Final Report 


4. Responding to Failures in a Distributed System 

The potential to tolerate processor failures is a side-effect of having a distributed system. 
Frequently this potential is not realized due to the complexity of supporting the detection, 
isolation, and recovery mechanisms required for fault-tolerant processing. However, safety 
or mission-critical applications require fault-tolerance and therefore must accept the 
additional complexity. 

The requirements for fault-tolerance can vary from system to system, and the corresponding 
implementation to support those requirements is substantially different. One of the critical 
factors is the time in which operations are allowed to be interrupted. Systems that cannot 
tolerate any interruption in service must perform calculations redundantly and decide which 
results to accept. More typically, systems are allowed to fail for a few seconds providing that 
they can come back in service correctly. For these systems, migration of services from failed 
processors to operational ones is often sufficient to maintain acceptable performance. 

The degree to which information is lost (and/or corrupted) during failures also impacts the 
architecture of the system. Hie use of stable storage techniques to prevent loss of data is a 
common approach to continue in the presence of processor failures. This approach 
checkpoints data to a stable storage area (usually made from redundant memory modules) 
which is accessible from other processors. If one of the processors fails, another processor 
can generally carry on from the last checkpoint made by the failing processor. Obviously the 
amount of time lost due to a failure has a direct relationship on how frequently checkpoints 
must be made. On the other hand, preventing corruption of data depends on detecting the 
faults early and preventing the errors from propagating into other portions of the system. 
This technique is often referred to as establishing "fire walls". 


-6- 





Distributed Issues Final Report 


Most failures can be detected by comparing the results of redundant operations, the use of 
check codes in data, or by using timers to insure that operations complete in their required 
times. Depending on the type of fault and its detection scheme, the recovery may be as 
simple as selecting the most likely value based on a majority vote of redundant 
computations; or it may be a complex process of retries and judgments made on confidence 
levels in components associated with the failure. The diversity in fault-tolerance 
requirements and the associated techniques to support them precludes a standard approach 
to fault-tolerant applications. Instead, flexibility for designers is necessary to allow the 
method of support to closely match the requirements. For this reason, the demonstration 
system includes the ability to have application software interface to the configuration control 
software. (More information on how faults are detected and handled in the demonstration 
system is provided at the end of section 5.2.) It is clear that many applications will require 
the ability to have the logic to support fault-tolerance shared between application-specific 
software and general fault-tolerance software in the runtime. 


-7- 




Distributed Issues Final Report 


5. Demonstration Application 

To adequately demonstrate the effective use of distributed processing, a real-time 
application was required to provide a test case program. A „/nthetic application titled the 
"Border Defense System (BDS)" which combines target tracking, rocket guidance, and 
graphics was developed to provide a suitable real-time test. A simulator was included to 
provide rocket and target motion. 

The main characteristics of the BDS are summarized below: 

- Hard Deadline Driven application: failure to meet timing requirements will result in 
mission failure. 

- "Processor in the Loop" flight control with dynamic target tracking. 

- Complex problem, with interac . among several different functional areas: 

Message Reception (from Sensor Interface and Airborne Rockets) 

Multiple Target Tracking and Prediction 
Multiple Rocket Tracking and Guidance 
Real-Time Graphics Updates 

Real-Time Operator Interface (peak data rate of 500Hz) 

- Using current technology: 32-bit Microprocessors (80386-16MHz) 

- Initially a separate program was designated for the simulator, however it was 
temporarily incorporated into the system as additional tas,.s and placed on a separate 
processor using the distribution technique. 

- All application concurrency is expressed using the Ada Tasking Model (Rendezvous) 
exclusively. 

- The program consists of approximately 6700 Ada LOC contained within 51 
compilation units. A copy of the BDS source code is provided in Appendix A. 

- The distributed runtime is implemented with 5242 assembly language statements (for 
compatibility with the vendor runtime) contained in 10 modules. A copy of the 
distributed runtime source code is provided in Appendix B. 


-8- 





Distributed Issues Final Report 


All calculations for both the rockets and targets are done in three dimensional space, 
however the target simulator currently maintains a constant altitude (Z = 0) for the target 
motions. Each of the aimpoint calculations are computed every 100ms for all of the rockets 
in flight. On the 16MHz Intel 386 processor the computations currently require 
approximately 6ms per rocket. 

5.1 Enhancements to the Demonstration Application Software 

In addition to the fault tolerance and distributed processing capabilities, the demonstration 
software was enhanced in two ways. First, the rocket simulation algorithms were made 
much more realistic (and therefore complex). Second, the flight control system was 
redesigned to be oriented towards a realistic feedback system, that is, the software adjusts 
the rocket flight based on the effect of previous flight control commands. Previously, the 
rocket simulator made instantaneous flight corrections rather than corrections based on 
normal accelerations. This allowed a guidance routine that simply aimed the rocket at the 
target. A side effect of the feedback approach is an increased sensitivity to (ie. lack of 
tolerance for) incorrect tracking of the rocket motion. Errors can occur during overload 
situations where rocket reports can be lost. When this does happen, the rockets become 
unstable and their flight paths become very erratic. 

Accuracy was improved by utilizing 32-bit fixed point types throughout most of the trajectory 
calculations rather than 16-bit fixed point. Custom fixed point routines were developed that 
provided substantially better performance than those in the native runtime system which 
were designed for a 16-bit machine. The rocket guidance equations now utilize 3rd-order 
processing, which is required to provide the desired accuracy. To provide some insight into 
what processing is done for rocket guidance, the following computations are performed for 
each rocket update: 





Distributed Issues Final Report 


1) The relative (closing) velocities and accelerations of the rocket/target pairings are 
computed and an estimated impact point is predicted. 

2) The rocket’s desired velocity vector is then computed and compared to the current 
velocity vector. 

3) Based on the velocity differentials, the desired acceleration is compared to the 
current rocket acceleration. This provides a desired change in acceleration which is 
then used to determine the adjustment required in the rocket’s attitude. 

4) The flight profile is smoothed by integrating the attitude adjustment over a period, 
which is computed as a function of estimated "time-to-impact". This reduces 
"overshoot" of the glide slope and had a major beneficial effect on the rocket accuracy. 

5.2 Improvements to the Distributed Runtime 

Several major changes were made to the underlying distributed runtime. In general, the 
changes can be classified as enhancements to the configuration flexibility of the system. In 
particular, the system now is capable of dynamically altering the configuration during system 
execution. Figure 1 (on the following page) shows the subsystems that make up the entire 
program which is replicated on each processor. It is shown as being layered from the top 
application code down through successive levels of abstraction. Conversely, control is 
passed up through the levels towards the application. Upon initialization, control is given to 
the System Configuration Setup & Control module which passes control to the distributed 
runtime. It in-turn transfers control to the vendor runtime which elaborates and activates 
the application software. 


-10- 




Distributed Issues Final Report 


ware Subsystem 



Figure 1. Software Subsystems 











Distributed Issues Final Report 


Application subprograms request service from the vendor runtime which passes the service 
request to the distributed runtime. Using a task directory built by the System Configuration 
Setup & Control module, the distributed runtime determines if the service involves 
distributed resources. If not, control is returned to the vendor runtime. If the service does 
involve distributed resources, the distributed runtime carries out the service using its own 
tasking primitives and the Network Services module. 

The Network & Failure Detection module is capable of detecting communication errors or 
the apparent loss of a processor by using timers with acknowledgement messages and a 
"heartbeat" mechanism. This mechanism monitors activity from each of the processors. If 
no activity occurs within a specified period or an acknowledgement is not returned in time, a 
failure condition exists and failure recovery is initiated. Failure recovery essentially stops 
application processing and returns control to the System Configuration Setup & Control 
module. 

5.2.1 Distribution Control Details 

Each processor initializes the underlying hardware based on what is available in the 
machine. The Ethernet hardware contains a unique network station address (in Read-Only 
Memory) which is then used in a table look-up to determine the logical processor ID. The 
processor ID is then used to determine which processor is the Master (controlling) CPU and 
which arc the Slaves. The Master is distinguished from the Slaves in that it is responsible for 
the distributed system Configuration Interface and the system-wide synchronization during 
start up. 

The Master processor prompts the user through a menu system which allows configuration 
of system parameters. These parameters include: 


-12- 




Distributed Issues Final Report 


the maximum number of rockets; 

the maximum number targets; 

which (of four possible) configurations to use; and 

enabling automatic reconfiguration. 

If automatic reconfiguration is enabled, a delay may be selected to allow a user to see the 
error condition for five seconds. 

Most of this information is made available to the application via a distributed runtime 
interface package. For example, it is possible for an application routine to determine if it is 
running on the Master CPU by testing a boolean variable in the interface. This information 
can be used by the main program which is activated on all processors to perform machine 
specific operations. In the case of the BDS it is used to control initialization of the operator 
interface which only runs on the Master CPU. In addition, the number of Rockets and 
Targets, and the size of the configuration specific task array is made available. In some 
sense, these variables can be thought of as parameters to the main program, similar to many 
host-based Ada program invocations where the command line is provided to the application 
program as a parameter to the main subprogram. One important distinction from main 
program parameters is that the runtime package interface is available during the elaboration 
of other application packages. This allows the size of non-static objects, such as the 
constraints of the task array, to be based on configuration information. 

The configuration selected during setup determines two important aspects of the distributed 
system: where the tasks are to be resident and how many tasks are to be allocated in 
application task arrays. Since the same code is present on all processors, a directory is used 
to determine where they are to be located. The tasks are effectively made remote by 
suspending them during their normal activation process. A future enhancement could be to 


-13- 





Distributed Issues Final Report 


add a "self-sizing" mode that would have the master processor search for available 
processors on start up and after failures and utilize as many as are available. 


-14- 





Distributed Issues Final Report 


6. Performance Characteristics 

The BDS system has been tested to execute on one, two, and three processor configurations. 
When distributed onto two processors, the simulation tasks run on the second processor. 
When the third processor is added, the size of an unconstrained task array is increased from 
one to two, and the second task element of the array is located on the third processor. These 
tasks in the array divide up the work load of computing the rocket guidance equations. 

The performance of the system under different processing loads was studied by collecting 
timings which reveal the ability of the system to meet the 100ms deadline for computing the 
next rocket guidance command. A significant portion of this computation is the time it takes 
to compute the individual aimpoints. This was measured to be approximately 6ms, but 
varies based on the actual values of the variables in the equations. The variation is due to 
the algorithm used for square-root which is iterative and will terminate when the current 
value is known to be within an error bound; and because the multiply and divide machine 
instructions vary in execution time. 

Two important aspects of the timing analysis are the relationships among tasks and the 
ability to achieve performance gains even with these inter-dependencies. To illustrate this 
point, a brief description of the sequence of activities for rocket control must be presented: 

1) Each rocket control cycle starts with the reception of new rocket flight information. 
This arrives during a rendezvous with a report buffer task which relays the information 
from the simulator. Normally, the control task is suspended while waiting for the 
buffer task to rendezvous, indicating the presence of a new rocket report. When the 
report arrives, it is provided to the control task and it begins the cycle of computation. 


-15- 




Distributed Issues Final Report 


2) The first part of the computation is a correlation step where the current report is 
correlated to previous reports to create a tracking history. New rocket launches are 
detected and their histories are initialized. Also, rocket detonations are detected and 
they are marked as destroyed. Current counts of active and destroyed rockets are 
maintained and passed on to a status task which updates the screen statistic values. 
During the correlation processes, a "move" list is generated for updating the rocket 
symbol positions on the display. 

3) Once the correlation has completed, the guidance tasks are given the rocket and 
target histories which are used to generate the new trajectory data. The guidance 
tasks are then allowed to run through the trajectory calculations to produce a new 
aimpoint for each rocket. 

4) The control task continues to run in parallel with the guidance tasks after providing 
them with the information they need. It takes the "move" list generated during the 
correlation and provides it to the display task. 

5) The control task then searches the target list to select the next ideal target if the 
automatic firing mode is selected and there is an available rocket. (The automatic 
firing mode indicates that the BDS is to select the next target rather than having the 
operator select the next target.) 

6) The control task then awaits completion of all guidance computations. When the 
new aimpoints are provided to the control task, it then rendezvous with a guide buffer 
task which relays the guidance message to the rocket simulator. This completes the 
timed cycle of interest. 


-16- 





Distributed Issues Final Report 


Note that the guidance tasks form a task array which is only one element in size for the one 
and two processor configurations, but expands to two tasks in the three processor 
configuration. This distributes the work load of aimpoint computations among two 
processors and allows the system to support additional simultaneous rocket flights without 
missing the measured 100ms deadline. 

6.1 Benchmark Results 

All measurements were taken with 40 active targets. During normal conditions, rocket 
accuracy was observed to be nearly 99 percent; that is, around one (1) target missed for 
every 100 rockets expended. In overload conditions where the deadline was missed, rocket 
accuracy dropped to nearly 0 percent resulting in every rocket missing. The BDS consisted 
of 11 conventional tasks, an unconstrained array of guidance tasks, and the main program. 
The entry calls made between the tasks are shown in Figure 2. For specific details of system 
operation, refer to documentation included in the application source code which is provided 
in Appendix A. A general description of the tasks are provided below (in decreasing priority 
order). 

In_Char task Accepts input from the mouse device (mouse interrupt task). 

Save task Buffers mouse data for controlling reticle updates. 

Display task Performs all graphics display updates. 

Track_Data task Buffers target position information between the target tracker and 

the rocket control task. 


-17- 






Distributed Issues Final Report 


Report_Buf task 


Guide_Buf task 


Rock_Sup task 


Targ_Sup task 


Control task 


Guidance task 


Track task 


Update task 


Bds procedure 


Buffers rocket position reports from the simulator to the rocket 
control task (part of the simulator). 

Buffers rocket guidance commands from the rocket control task to 
the simulator (part of the simulator). 

Implements the rocket flight simulation (part of the simulator). 

Generates and moves simulated targets (part of the simulator). 

Provides overall control for rocket monitoring and flight updates. 

Called by the rocket control task to compute flight guidance 
aimpoints (this is an array of tasks). 

Produces target tracking information for the display and rocket 
control tasks. 

Updates the statistical status information on the screen. 

Main program used to initialize system operation. 


-18- 






Distributed Issues Final Report 


BB 


op Level Design 


*1ath 

Tan 

Arc Tan 
Sqr-t 


Rocket 

Control 


Rocket. 

Guide 


Statu; 



Mouse _ 

Interrup t Buf Per 

/ 7 7 / 


Graphics 

Display 


MiSC, 


Traject 

uUtd e 

Engage 

Grid_to_P.;<el 

Machine 

Shapes 

Config 


arqet 


Track. Da to 


Simula te 


Dotted Line 
Indicates Entry Call 



Figure 2. Top Level BDS Design 









Distributed Issues Final Report 


The measured time is the period that begins when the rocket report becomes available to 
the control task and ends when the guidance message is provided to the simulator. The 
allowable time for this has been established as 100ms based on the rocket update 
characteristics. Successive measurements were taken increasing the number of rockets until 
either the deadline was missed, or until the number of rockets reached 20. The tested 
configurations are as follows: 


1 Processor 

2 Processors 

3 Processors 


: all tasks are resident 

: the simulator tasks are on the 2nd CPU 

: the simulator is on the 2nd CPU, the second 
guidance task is on the 3rd CPU 


Processors 

# of Rockets 

Time to complete 100ms Cyc 

1 

5 

ms 

1 

IP 

105 ms 

2 

5 

38 ms 

2 

10 

77 ms 

2 

15 

118 ms 

3 

5 

41 ms 

3 

10 

73 ms 

3 

15 

79 ms 

3 

20 

90 ms 


Extrapolated Saturation Points for Each Configuration: 

# Processors # Rockets 

1 9 

2 13 

3 22 

Several observations on the benchmark results can be made. Because the simulator does 
not participate in the rocket control calculations, and the system is lightly loaded during the 
control of up to 5 rockets, there is no performance benefit in increasing from 1 to 2 CPUs 


- 20 - 






Distributed Issues Final Report 


with only 5 rockets to control. When the number of rockets rises to 10, the dual-CPU system 
shows a substantial benefit over the single-CPU configuration because both the control 
computations and simulator computations increase as a function of the number of rockets. 

The dual-CPU configuration misses its deadlines when more than 13 rockets become 
airborne. This is roughly a 44% gain in the number of rockets supported with the 
single-CPU configuration. The three-CPU configuration is expected to miss its deadlines 
when more than 22 rockets become airborne. This is roughly a 144% gain over a 
single-CPU and a 69% gain over the two-CPU configurations. The performance benefits 
are not linear because only segments of the application are being distributed, and because 
precedence relationships among the tasks restrict full processor utilization. 

Not measured in the benchmarks is the performance of lower priority tasks which are much 
more substantially impacted during increased processing load. The low priority tasks are the 
first to relinquish the processor and therefore will suffer first in overload conditions. For 
example, the task responsible for updating the display statistics begins to starve when only 3 
rockets are launched on the single-CPU configuration. In comparison, it continues to run 
(although at lower frequency) even during overload conditions on the dual and triple 
processor configurations. The extended life of the lower priority tasks is primarily due to the 
additional "background" cycles available on the multiple CPU configurations. 

It is also due to the I/O blocking time during network communications. That is, while the 
high priority task waits for access to the network resource, it is blocked from execution which 
allows lower priority tasks to run. This is one interesting aspect of a distributed system that 
is not present in shared-memory multiprocessors or single processors. This I/O blocking 
time has the effect of transferring some execution time directly from high-priority tasks 
(performing network communications) to other tasks on the system. To the extent that the 


- 21 - 



Distributed Issues Final Report 


I/O blocking time exceeds the processing time required by middle priority tasks, or if the 
middle and high priority tasks block in contention for the network, then very low priority 
tasks can be allowed to run. This phenomenon is observed in the demonstration project by 
the low priority task updating the status display even while high priority tasks miss their 
deadlines in the multiple processor configurations. The I/O blocking time during rocket 
"get_report" and "put_guidance" communications is estimated at under 2ms per 100ms cycle. 
This 2% CPU time is sufficient to prevent starvation in the low priority tasks. 

6.2 Performance Gains 

A common objective discussed for parallel systems is to achieve "scalable" increases in 
performance. This term implies that when processing resources are added, the "useful 
processing increases by a constant factor of the number of processors. For example, for a 
scale factor of 0.9, then if five times the processors are used, this will result in 4.5 times the 
useful processing that will be accomplished. This type of measurement is typically applied to 
computations where the time the computation takes place is only relevant because omeone 
is waiting for the final output of a very large set of computations. However in real-time 
systems, consistent meeting of short-term deadlines is the measure of performance. For this 
reason, the conventional sense of "scalable" performance is not totally appropriate. 

A real-time system that always meets its deadlines with one processor will not perform 
better when adding additional processors. It is much more typical that a basic accuracy 
specification must be met and no benefit is gained by exceeding it. In these cases just 
meeting the deadline is as good as meeting the deadline in half the required time. The only 
benefit is the excess capacity which allows future expansion. However, there is a class of 
algorithms that increase their accuracy based on the amount of time available to execute 
which might benefit from additional processing resources. So except for reliability concerns 


- 22 - 




Distributed Issues Final Report 


and special purpose algorithms, performance can and often does get worse because of 
communication overhead. 

On the other hand, when processing demands limit the capacities of an embedded system, 
there is potential for substantial benefits to be gained by using additional processors. This is 
because there are often fixed and variable components to the processing required for system 
operation. In the BDS, fixed components include the status update, rocket control and 
report message formatting and transmission, sensor message reception, graphics reticle 
motion, and runtime overhead (primarily context switching). All of these operations did not 
vary with the number of targets 01 rockets supported. Since the additional processing is 
applied to the variable portion, the increase in system capacity can greatly exceed the 
increase in processing resources. We refer to this increase in performance as "leveraged 
performance". In particular, if a system is 70% utilized due to fixed processing 
requirements, only 30% remains to perform the functions identified as the principal system 
mission. This 30% can be highly leveraged by adding an additional processor to achieve a 
nearly 300% increase in system capacity. This characteristic is not clearly evident in the 
demonstration benchmarks because the tests were taken without the user interface being 
active and because tire target support processing is quite low. The user interface includes 
moving the reticle which can increase system load by up to 20%, but without a mouse 
simulator to provide constant simulated motion, it was decided to test the system without the 
effects of the user interface. The result is that the fixed processing for the demonstration 
benchmarks was rather low. 

The benchmark results are also somewhat biased by a decision to locate only the simulator 
tasks on the second processor. This resulted in considerable idle time on the second 
processor which could have been used to do additional rocket calculations. The reason for 


- 23 - 





Distributed Issues Final Report 


the decision was to insure the accuracy of the simulation by making sure that nothing 
interfered with the simulator’s processing. A similar effect was created on the three-CPU 
configuration by choosing a processing balance between the two guidance tasks that was not 
optimal. Ideally, the two distributed computations would complete at roughly the same 
time, but the balance selected caused one to finish earlier than the other. The incorrect 
balance was made because of uncertainties in all of the timing factors that make up the 
processor loading. Further work is necessary to facilitate an automatic method of 
determining the optimal configuration for performance. 

Thus this study identified two major beneficial factors when considering the use of 
additional processing resources: 

1) When there is a large processing requirement for fixed overhead operations and the 
addition of processing resources can be applied to the mission-specific processing, 
which is otherwise limited by the available resources, there can be a leveraged benefit 
to the system capabilities. 

2) When there is the potential for several independent sets of calculations to be 
performed, the performance increase can be effectively spread over a moderate 
number of CPUs, limited by the capacity of the network. 

The ability to scale-up to a very large set of processors was not investigated by this project. 
It is believed that the current network architecture would severely restrict such a scale-up 
due to network contention. 








Distributed Issues Final Report 


7. Design of Systems Using Distributed Ada 
7.1 Hardware Considerations 

There are several aspects of system design that impact the utility of the system. Experience 
has shown that the implementation of distributed systems must be done with the expectation 
that the hardware will provide reasonable support for fundamental services. These services 
include: 

1) The ability to transmit urgent information in a timely fashion. This requirement 
usually implies that messages can be prioritized and that the priority is observed in any 
situation where the potential delay exceeds the allowable allocated time. 

2) The ability to broadcast, and later determine that all recipients obtained the 
message. 

3) Sufficient hardware buffering support so that incoming messages will not overrun, 
resulting in the need for re-transmission. 

4) Error detection (or correction) to provide indication of successful message transfer 
immediately (i.e. within 10 us) by the hardware. 

5) The ability to synchronize among the processors. 

To a large extent, the network topology has an influence on the real-time response and 
priority of services provided. The most common network topologies include: Rings, 
N-dimensional Hypercubes, and Buses. This demonstration project utilized a standard bus 
topology network - Ethernet, because of its availability and cost. As discussed in a prior 
report [1], Ethernet is not ideal for real-time use since there is no provision for hardware 


- 25 - 




Distributed Issues Final Report 


generated acknowledgements and because access to the bus is granted on a contention basis. 
The contention-based access method is a poor choice for real-time because no provision is 
explicitly provided for priority, and two nodes trying to access the medium simultaneously 
result in a collision. When this occurs, they both wait a random period and retry later. The 
effect of this on congested networks is a queuing order that is often first-in, last-out. This 
results in very high worst-case response times which makes meeting fixed deadlines difficult. 
However, in the demonstration project contention was low since bus utilization was kept 
below 2%. A more appropriate network for real-time would be either a point-to-point 
interconnect or a star topology that provided guaranteed response time to all network nodes. 

7.2 Software Considerations 

The ability to use distributed Ada depends on being able to separate program execution into 
tasks that can execute in parallel. For embedded applications, usually a small set of 
independent tasks are naturally present due to their interaction with external objects. These 
objects (like a video display, operator keyboard, or rocket) are independent and operate 
concurrently in the real-world. Their control or monitoring therefore naturally maps to 
separate tasks. The order of execution for these tasks is often asynchronous and is dictated 
by external events. This type of concurrency is referred to as "natural parallelism". Parallel 
execution can also be performed on any independent set of operations that are not ordered. 
Typically these are done as sequential or iterative processes because treating each operation 
as a separate task would result in additional context switches. However, applying multiple 
processors to the computations can more than compensate for the small overhead of the 
additional context switches. This forced parallelism can help to increase the amount of 
processors which can be effectively used. 


- 26 - 




Distributed Issues Final Report 


As a design goal, system designers should attempt to reduce interdependency of tasks as 
much as possible. Usually this requires detailed knowledge of the application and implies 
being able to partition system functions into tasks that have a high degree of autonomy. 
Tasks (other than monitors for shared access control) should not be used for activities that 
cannot be done in parallel. 

Secondly, avoid serialization in the order of task synchronization if possible. For example, if 
task A must wait for both task B and task C to provide data, it should not enforce the order 
of which task it must rendezvous with first unless they are always guaranteed to arrive in a 
particular order. Instead, a conditional rendezvous should be used to prevent unnecessary 
serialization of events. 

Third, tasks which must reside on a particular processor because of required access to 
hardware interfaces should provide the minimum service necessary to support efficient use 
of that hardware. This approach provides additional design freedom to locate a greater 
percentage of the required processing demands according to communication demands rather 
than specific hardware dependencies. 

Finally, the software should be designed to operate correctly during overload conditions. 
This requires the ability to detect the overload condition, maintain consistency of data, and 
(ideally) to support the dynamic load shedding necessary to make good use of the available 
processing resources. This last provision is absolutely necessary to continue operation in the 
presence of hardware failures, since the loss of processing resources will almost certainly 
increase the likelihood of overload conditions. 


- 27 - 




Distributed Issues Final Report 


7.3 Differences Between Distributed and Uniprocessor Implementations 

There were two major unexpected differences identified between execution on a distributed 
system and a uniprocessor system. The first was mentioned in the performance section and 
involves the impact of I/O blocking on high priority tasks. This prevents starvation in low 
priority tasks and allows the status display and target tracker tasks to continue to run even 
under conditions of very high utilization. This effect was due to the desire to run tasks as 
often as possible during non-overload conditions and yet allow the more critical tasks to 
obtain the CPU during overload. This may have been avoidable using a more complex 
algorithm to schedule the status and target tracker tasks based on the available time for 
them to run. 

The second difference was due to a design assumption that made the program erroneous. 
During a prototype enhancement of the application, a change was made in the program to 
use message sequence numbers in order to detect the loss of successive reports (due to 
buffer overwrite during overload conditions). Although the code was made obsolete by 
another function and was essentially removed prior to system integration, a seemingly 
harmless portion remained which examined the rocket report message. This message was a 
task entry "out" parameter from the simulator’s report buffer task and it was examined to 
detect sequence numbers that changed from report to report. By convention, only the first 
"N" items in the message are considered valid, where "N" is provided at the beginning of the 
message. However the sequence monitoring code did not examine this count before testing 
the sequence numbers and assumed that the first rocket position was always valid. In the 
single-CPU configuration, the entry call "out" parameter was passed "by address", and the 
buffer task only updated those records that were active. In distributed configurations, entry 
call parameter passing must be done as "copy-in, copy-out" so the data can travel over a 


- 28 - 





Distributed Issues Final Report 


network and it operates without regard to the contents of the objects being copied. The 
result is that all of the records are updated during each entry call. This had the effect that 
the sequence software became confused and rejected messages due to apparent bad 
sequence numbers. The root of the problem was due to a dependence on the parameter 
passing mechanism used for entry parameters. RM 9.5(6) states that: 


"The parameter modes for parameters of the formal part of an entry declaration are the 
same as for a subprogram declaration and have the same meaning (see 6.2)." 

RM 6.2(5) defines out mode parameters as: 

The formal parameter is a variable and permits updating of the value of the associated 
actual parameter. 

The value of a scalar parameter that is not updated by the call is undefined upon return; 
the same holds for the value of a scalar subcomponent, other than a discriminant. 
Reading the bounds and discriminants of the formal parameter and of its subcomponents 
is allowed, but no other reading. 

RM 6.2(7) continues: 

"For a parameter whose type is an array, record, or task type, an implementation may 
likewise achieve the above effects by copy, as for scalar types. In addition, if copy is used 
for a parameter of mode out , then copy-in is required at least for the bounds and 
discriminants of the actual parameter and of its subcomponents, and also for each 
subcomponent whose type is an access type. Alternatively, an implementation may 
achieve these effects by reference, that is, by arranging that every use of the formal 
parameter (to read or to update its value) treated as a use of the associated actual 
parameter, throughout the execution of the subprogram call. The language does not 
define which of these two mechanisms is to be adopted for parameter passing, nor 
whether different calls to the same subprogram are to use the same mechanism. The 
execution of a program is erroneous if its effect depends on which mechanism is selected 
by the implementation." 

The essential difference in implementation approach is that when call by reference is used, 
only those records that are explicitly assigned a value are altered by the entry call. When 
call by copy-in/copy-out, all of the values are altered. In either case it is considered 
erroneous to reference a value that is not updated, but in fact the single-CPU application 
was doing this. There was no effect in the call by reference implementation, but when the 
task became distributed and call by copy was used, the latent error in the software was 


- 29 - 




Distributed Issues Final Report 


activated. The lesson is that erroneous programs are more likely to operate incorrectly on 
distributed systems because a different parameter passing mechanism is likely to be used for 
composite objects. 


- 30 - 




Distributed Issues Final Report 


8. Limitations of the Distribution Support 
8.1 Task Identification 

The current mechanism for identifying tasks is the task’s base priority. This was a 
convenient mechanism to use for a number of reasons. First, it is stored in the vendor’s 
runtime task control block and is therefore available during any runtime call. It can be set 
via a pragma in the source code and therefore a unique ID can be associated with each task 
type. This approach was selected because it provided an expedient solution to identifying 
application tasks to the distributed runtime without modification to either the compiler or 
the vendor runtime. 

Future versions would obviously use some other field in the control block because this 
technique is very limited. One complication is with the handling of task arrays. Since they 
are of the same task type, all tasks in an array have the same priority. This problem was 
circumvented by leaving sufficient space between adjacent priorities to change the priority of 
each task in the array during activation if necessary to make them unique. 

Another approach was considered, but rejected because of development time. This 
approach was to use an intermediate file produced for a debugger to correlate the actual 
name of each task with the execution addresses where the task type is created and the task 
object is activated. This information would be combined with the designer’s distributed 
configuration specification and loaded with the runtime. Since this specification would use 
the actual expanded name of each task, the limitation of having only as many tasks as there 
are priorities would be removed. During task type creation and task activation, the return 
address on the stack during the runtime call provides the execution address and could be 
used to identify the task type and object in the configuration specification. This approach 


- 31 - 






Distributed Issues Final Report 


requires the development of a tool to process the compiler intermediate files, linker maps, 
and the distributed specification file. There may be other problems that are not obvious but 
the method appears suitable for some applications. 

8.2 Code Replication 

Currently all of the code for each task must be resident on each processor. In some 
applications this is unacceptable since there will not be sufficient memory to support the 
entire application on every processor. One approach to reducing this overhead may be to 
use subunits for all task bodies and then create a sublibrary with dummy bodies appropriate 
for each processor configuration. Linking the program with respect to each sublibrary will 
then produce a load image for that processor configuration. However, some compilation 
systems do not allow subunits to appear in any library other than the library in which the 
parent unit was compiled. In any case, it would probably be advisable to have a tool which 
automatically created the necessary sublibaries and subunit bodies and therefore reduce the 
chance of error in generating the individual load images. 

8.3 Network Error Recovery 

Each network message is acknowledged which allows transmission errors to be detected, 
however there is no provision for re-transmission. The system will simply shutdown and 
reconfigure on the first error. This is somewhat severe since re-transmission can usually be 
done without loosing real-time if the acknowledgements are prompt. (Measurements on the 
BDS indicated typical acknowledgement times of 400 to 800 microseconds.) The only 
complication is saving the data for re-transmission. Currently, transmissions transfer 
application variables directly to a single hardware transmit buffer. Once the message is sent, 
the buffer is reused and the application task is allowed to continue. There is no provision to 


- 32 - 






Distributed Issues Final Report 


save the data for later re-transmission. This could be done with very little overhead by 
allocating additional space in the hardware buffer for transmissions, however the hardware 
in use is configured with only 8KB (kilobytes) of memory and therefore this is not practical. 
By expanding the memory to 32KB, or by using system memory and performing an 
additional copy, the data can be retained until the acknowledgment is received and the 
buffer can be freed. 





Distributed Issues Final Report 


9. Compiler and Runtime Problems 

Considerable effort was spent isolating problems associated with the Ada implementation. 
The implementation was an upgrade from the version used on the previous demonstration 
project and was far more reliable than that earlier version. Nevertheless because code 
generator errors continued to appear, a decision was made to not use optimization for 
compilation of many of the units and to greatly restrict use of pragma inline. This noticeably 
improved the reliability of the generated code. 

Even with these restrictions, two problems were identified during final integration testing. 
In one unit where inline was still used, the compiler failed to generate the same (correct) 
addresses for variables which were initialized during package elaboration. These variables 
happened to be pointers within a circular queue, and the error would generally go unnoticed 
if the values of the memory locations happened to be the same. This was typically the case 
during testing since the system memory initialization routine would zero all of memory to 
prevent parity errors. However, depending on the contents of memory when the program 
was loaded the system could crash if the two values were very large or not equal to each 
other. While single stepping through the program it was noticed that the pointers were 
being initialized properly which was the obvious expected source of the problem. However, 
during program execution the system would still crash, and the pointers would have invalid 
'ata. Use of the processor’s special debug registers to halt on references to data, much like 
an in-circuit emulator, helped to track down the problem and realize that two different 
locations were being used for the same variable. 

The second problem was related to computation of 32-bit fixed point values. When a small 
value is divided by a large value resulting in zero, and exactly one of the operands is 
negative, the runtime would incorrectly assume that an overflow had occurred because the 


- 34 - 






Distributed Issues Final Report 


result was not negative. Instead it was zero, which was also a legal value. This problem was 
fairly quickly resolved since it has been noticed in the earlier release of the runtime. It was 
fixed by changing the conditional branch instruction to allow for zero results. 


- 35 - 





Distributed Issues Final Report 


10. Summary 

This project demonstrated that the use of distributed Ada can provide increased 
performance benefits and fault tolerance for a reasonably complex real-time application. 
These benefits can take the form of simply using the parallelism natural in the application or 
by expanding the parallelism using task arrays to compute multiple independent 
calculations. In particular, the ability to distribute elements of a single Ada object was 
demonstrated by distributing an array of tasks to divide up the workload among several 
processors. 

Task precedence relationships create considerable design difficulties when trying to analyze 
a system for optimal parallel operation. New tools and scheduling paradigms are required 
to assist designers in resolving these difficulties. However, techniques do exist to provide 
marginal improvements in parallel operation by reducing dependencies and encouraging the 
judicious use of synchronization primitives. An example of such a technique is the use of 
buffering schemes and control variables to de-couple ta~ks. This technique may require 
detailed knowledge of the application to insure proper execution with the buffering scheme. 

The concept of "scalable performance" was discussed, and a more appropriate term for 
real-time embedded systems: "leveraged performance" was introduced. This concept 
recognizes the limiting factors in real-time systems, and emphasizes the potential of capacity 
increase factors greater than one (1) for applications with a substantial portion of processing 
dedicated to execution requirements of fixed duration. 

A very important potential gain of distributed systems is the ability to utilize the natural 
redundancy in the hardware to achieve increased fault tolerance. Typical embedded systems 
have had, and will continue to have multiple processors. The problem of reconfiguring the 


- 36 - 



Distributed Issues Final Report 


system during failure conditions has prevented widespread use of fault tolerance techniques. 
Distributed Ada appears to be a good candidate for reducing this problem to a manageable 
level for applications which should operate in the presence of failures. 

Fault tolerance concerns were examined and a clear need arose to provide an interface 
between the fault tolerant runtime and the application. The application must be able to 
have some sense of the available processing resources in order to adapt to the configuration. 

An example was shown of an erroneous program which failed on the distributed 
implementation when it had previously run correctly in a uniprocessor configuration. A 
conclusion was drawn that since distributed systems are likely to use both "pass by copy" and 
"pass by reference" mechanisms for parameters of composite types, programs which 
erroneously depend on the parameter passing mechanism are more likely to fail on 
distributed systems. 

Finally, compiler reliability still poses a serious problem when trying to obtain the highest 
performance possible using complex optimizations and language features such as pragma 
inline. Mission and safety critical applications should consider the impact of having to 
operate without the use of these performance enhancements. 


- 37 - 






Distributed Issues Final Report 


11. References 

[1] CECOM Center for Software Engineering, "Real-Time Ada Demonstration Project", 
CIN # C02 092LA 000900, Final Report, delivered by LabTek Corp., May 31, 1989. 


[2] Reference Manual for the Ada Programming Language, ANSI/MIL Standard 1815A-1983. 


- 38 - 





Distributed Issues Final Report 


12 Appendix A - Border Defense System Ada Source Code 


The source code for the BDS system follows in alphabetical order of the unit names 
(specifications precede bodies). 


- 39 - 



Distributed Issues Final Report 


--% UNIT: Aim_Data package spec. 

■■X Effects: Holds Rocket/Target history information for Guide. 
--X Modifies: Rocket_info is global data and is modified by Guide. 

Requires: Initialization is required and performed by Guide. 
-■X Raises: No explicitly raised exceptions are propagated. 

--% Engineer: L. Griest. 


--| PACKAGE SPEC : Aim_Data 

"I 

--| Aim_0ata contains the information for Guide necessary to control the 
--| rockets in flight. The data is initialized by Guide when the rocket 
--| is taking off from a launch position. Note that curr_nnnn signifies the 
-| most current postion of an object and that last_nnnn signifies the position 
--| the object had immediately prior to this interval (assuming no overload 
--| condition). The prevnnnn field exists only for rockets and represents 
--| the position the rocket had two intervals prior to this one. This field 
--| is used to calculate the velocity of the rocket last interval in all three 
-*| axis. This information is not needed for targets. 

--| RATE_REC_TYPE is necessary to provide the accuracy necessary when 
--| calculating accelerations and velocities, particularly at launch times. 


- Modifications Log 

- 89-11-09 : LJG => Original created. 


with Types; use Types; 

package Aim_Data is 

type RATE_REC_TYPE is record 
X : Types.RATE_TYPE; 

Y : Types.RATE_TYPE; 

Z : Types.RATE_TYPE; 
end record; 


type ROCKET_INFO_TYPE 
LAST_TARG 
CURR_TARG 
PREV_R0CK 
LAST_ROCK 
CURR_R0CK 
OlD_AIMPOINT 
BOOST PHASE 


is record 

: Types.P0SITI0t'_TYPE; 

: Types.P0SITI0N_TYPE; 

: Types.P0SITI0N_TYPE; 

: Types.POSITIONTYPE; 

: Types.POSITI0N_TYPE; 

: Types.AIMPOINT_TYPE; 

: BOOLEAN; -- rocket currently in boost phase? 


end record; 


- 40 - 














Distributed Issues Final Report 


type ROCKET_INFO_ARRAY is array(Types.ROCKET_IND£X_TYPE) of ROCKET_INFO_TYPE; 

ROCKET_INFO : ROCKET_INFO_ARRAY; 
end AimOata; 


- 41 - 






Distributed Issues Final Report 


-■% UNIT: Aimpoint function spec. 

Effects: Compute new aimpoint based on acceleration requirements. 
--% Modifies: No global data is modified. 

Requires: No initialization is required. 

--% Raises: No explicitly raised exceptions are propagated. 

--% Engineer: T. Griest. 


--| FUNCTION SPEC : Aimpoint 
--1 

--| Aimpoint is responsible for returning a new elevation and azimuth to 
--I the caller based on the acceleration adjustment. 


-- Modifications Log 

-- 89-11-6 : TEG => Original Created. 

with Types; use Types; -- for operators on types only! 
with Aim_Data; use AimData; 

function Aimpoint(OLD_AIMPOINT : Types.AIMPOINT_TYPE; 

ACCELADJUST : Aim_Data.RATE_REC_TYPE) 

return Types.AIMPOINT_TYPE; 


- 42 - 










Distributed Issues Final Report 


--% UNIT: Aimpoint function body. 

--X Effects: Compute new aimpoint based on acceleration requirements. -- 
--% Modifies: No global data is modified. 

--% Requires: No initialization is required. 

--% Raises: No explicitly raised exceptions are propagated. 

Engineer: T. Griest. 


FUNCTION BOOT : Ainpoint 

The selected aimpoint is a function of the desired change in acceleration 
for each of three axis and the current aimpoint. The following rules are 
used: 

TO INCREASE Z ACCELERATION adjust elevation towards 16384 (straight up) 

TO INCREASE X ACCELERATION adjust azimuth towards 0 (straight right) 

Obviously there is some interaction among these components. Z 
is the controlling axis since its acceleration is not dependent on azimuth 
and the accelerations in X and Y are dependent on elevation. Once the 
change in elevation has been established, the impact on X and Y 
accelerations are computed, then a proper azimuth is selected based 
on the above rules. 

To implement the friendly fire suppressor only generate and process 
elevations between -16384 (straight down) and 16384 (straight up), 
and azimuths between 0 (straight right) and 32767 (straight 
left). 

When adjusting elevation, reduce negative impact since gravity will 
have a compensating effect. 


-- Modifications Log 

-- 89-11-03 : TEG -> Original Created. 


function Aimpoint(OLD_AIMPOINT : Types.AIMPOINT_TYPE; 

ACCEL_ADJUST : Aim_Data.RATE_REC_TYPE) 

return Types.AIMPOINT_TYPE is 


max_climb 

: constant 

: = 

16384 

max_descend 

: constant 

: = 

-16384 

left 

: constant 

: = 

32767 

right 

: constant 

: = 

0 

elev_factor 

: constant 

: = 

10000 

az factor 

: constant 

: = 

10000, 


-- full left while going forward 
-- full right while going forward 
-- controls flexibility in turning rocket 
-- controls flexibility in turning rocket 


NEW_AIMPOINT: Types.AIMPOINT_TYPE; 

ADJUST_ELEV : Types.EXTEN0E0_BAM; -- use 32-bit values for intermediate 


- 43 - 











Distributed Issues Final Report 


ADJUST_AZ : Types.EXTENDED_BAM; 

TEMP : Types.EXTENDED_BAM; 

begin 

-- PutO'In Aimpoint: ADJUST_ELEVATION: •'); 

-- Change elevation to effect Z acceleration first. 

ADJUST_ELEV := Types.EXTENDED_BAM(ACCEL_ADJUST.Z * elev_factor); 
if ACCEL_ADJUST.Z <0.0 then 

AOJUST_ELEV := ADJUST_ELEV / 2; -- reduce descend angle because of gravity 

end if; 

TEMP := Types.EXTENDED_BAM(0LD_A1MP0INT.ELEVATION) + A0JUST_ELEV; 

-- Must perform limit check on climb/descend. 

if TEMP > max_climb then 
NEW_AIMPOINT.ELEVATION := max_climb; 
elsif TEMP < max_descend then 

NEUAIMPOINT.ELEVATION := max_descend; 
else 

NEW_AIMPOINT.ELEVATION := Types.BAM(TEMP); 
end if; 


-- NOW PROCESS AZIMUTH (Using only X, let Y take care of itself!) 

ADJUST_AZ := Types.EXTENDED_BAM(-ACCEL_ADJUST.X * aZ_factor); 

-- Do limit checks to make sure ue don't start turning back towards FLOT 

TEMP := Types.EXTENDED_BAM(OLD_AIMPOINT.AZIMUTH) + ADJUST_AZ; 
if TEMP > left then 
NEW_AIMPOINT.AZIMUTH := left; 
elsif TEMP < right then 

NEU_AIMPOINT.AZIMUTH := right; 
else 

NEU_AIMPOINT.AZIMUTH := Types.BAM(TEMP); 
end if; 

return NEUAIMPOINT; 
end AIMPOINT; 


- 44 - 





Distributed Issues Final Report 


--% UNIT: 80S Spec & Body. 

--X Effects: Initiates main processing, loops recording idle time. 
--% Modifies: No global data is modified. 

Requires: Status.Initialize be called before Mouse.Initialize. 
Raises: No explicitly raised exceptions are propagated. 

--X Engineer: T. Griest 


. Distribution and Copyright . 

-- Derivation : LabTek Border Defense System V2.0 

-- This Border Defense System Software inherits the LabTek copyright. 
-- The following copyright must be included in all software utilizing 
-- this application program. 

-- Copyright (C) 1989, 1990 by LabTek Corporation, Uoodbridge, CT, USA 

-- Permission to use, copy, modify, and distribute this 
-- software and its documentation for any purpose and without 
-- fee is hereby granted, provided that the above copyright 
-- notice appear in all copies and that both that copyright 
-• notice and this permission notice appear in supporting 
-- documentation, and that the name of LabTek not be used in 
-- advertising or publicity pertaining to distribution of the 
-- software without specific, written prior permission. 

-- LabTek makes no representations about the suitability of 
-- this software for any purpose. It is provided "as is" 

-- without express or implied warranty. 

. Disclaimer . 

-- This software and its documentation are provided "AS IS" and 
-- without any expressed or implied warranties whatsoever. 

-- No warranties as to performance, merchantability, or fitness 
-- for a particular purpose exist. 

-- In no event shall any person or organization of people be 
-- held responsible for any direct, indirect, consequential 
-- or inconsequential damages or lost profits. 

.END-PROLOGUE. 


--| TASK BODY : BOS main procedure 

--| The BDS main procedure is used to synchronize the start of events within 
--| the entire system. During elaboration until the start of the procedure, 
--| the system will settle to a known state. Then when the call to Status 
is performed, the statistics titles will be printed on the screen. After 
this is performed the Mouse initialization is completed. Then two 


- 45 - 

















Distributed Issues Final Report 


--| successive entry calls are done. The first starts the Rocket.Control task 
--| going. The second signals the Track task to begin processing target 
-*| information. 

--| The "--STP(NNNN) ..." signifies a Time Point stamp location. There is a 
--| tool built by LabTek which transforms these comments to Ada code which 
--| performs a call to a Timestamp procedure. In order to keep from filling 
--| memory too fast, a loop is used to force the main procedure to loop slower 
--| than it normally would. This time stamp routine will enable approximations 
--| of the amount of free time the processor has, since this procedure has the 
--| lowest priority. 


-- Modifications Log 

-- 88-09-30 : TEG => Original created. 


with Config; 
with Status; 
with Types; 
with Mouse; 
with Rocket; 
with Target; 

with Interrupt_Control; -- 
with MachineDependent; -- 
with Time_Stamp; 
with Oistrib; 

procedure BOS is 

-- This is the main program for the Border Defense System. It has only 
-- two calls which are of any importance, i.e., the other code is for 
-- timing purposes only. The first call performs initialization of the screen 
-- statistics descriptions and their initial values. The second call starts 
- - the mouse. 


global configuration parameters 

updates statistics used 

global types definitions 

mouse movement and rocket launching 

rocket attitude and aimpoint calculations 

generation of various targets 

enabling and disabling of (all) interrupts 

individual pixel plotting for EGA 

run time profiler 


use Types; 

pragma PRIORITYCConfig.bds_priority); 

COUNT : Types.WORD; 

SLOW : Types.UORO; 

begin 

if Oistrib.MASTER then 
Status.Initialize; 

Mouse.Initialize, 

Rocket.Control.Start; 

Target .Track. St art.- 
end i f ; 
loop 


-- for visibility to 


-- these two variables are for 
-- slowing the time stamps 


-- print screen statistics 

-- must be done after status signal 


-- done with initialization 


- 46 - 









Distributed Issues Final Report 


Time_Stamp.Log(0001); --$TP(0001) BDS main time stamp 

SLOW := 1; 

for COUNT in 1..2000 loop 
SLOW := SLOW + 1; 
end loop; 
end loop; 
end BDS; 


- 47 - 






Distributed Issues Final Report 


■-X UNIT: Config Spec. 

--% Effects: Provides system-wide configuration constants. 
Modifies: No global data is modified. 

-X Requires: No initialization is required. 

--% Raises: No explicitly raised exceptions are propagated. 
Engineer: T. Griest. 


--| PACKAGE SPEC : Config 

--| The Config package (which currently has no body associated with it) can 
-*| be contrasted to the Types package. Uhile the Types package is responsible 
--| for declaring the various global types used throughout the BDS, the Config 
--| package is used to declare global constants. The rocket launch trajectory 
--| is used to determine the azimuth and elevation of the rocket before takeoff 
--| The kill radius is used to determine the explosive power of the rocket as 
--| it hits near a target. If the target is within the radius determined below 

-*| then it is considered to have been close enough to the rockets explosion to 

--| have caused damage severe enough to render it immobile and harmless. Note 
--| that the BDS does not take into account the case of a rocket doing "some" 
--| damage on the target; every target is considered to be totally missed or 
--| fully hit. There are two battle areas that can be considered in the BDS. 
--| The first is the battlefield area which is the "real" area of conflict and 
--| the other is the screen battlefield which is shown to the user. The "real" 
--| battlefield is used by the Target Tracker, the Rocket Controller, and their 
-*| respective data links to their sensors. In order to provide a proportional 

--| view of the "real" battlefield area, the number of pixels in X and Y was 

--| calculated. The screen battlefield does not take up the entire screen; 

--[ some is left for the display of statistics. The calculations done in the 
--| "real" battlefield are three dimensional, those on the battlefield screen 
--| two dimensional. 

--| The bytes per storage unit is used for transportability reasons. A count 
of bytes required for each tasks' stack (including nested procedures) was 
--| included so that the application could be less implementation dependant. 

--| To leave defaults in place would require that the largest stack frame 
--| be used for all tasks stacks regardless of the actual space needed. By 

--| specifying the amount of stack needed on a per task basis, less memory 

- -1 is used. 

The interval constant declared below is the basic unit on which timing 
-| in the BOS is performed. It specifies that an entire iteration (which 

-| includes a rocket update, a target update, and a possible mouse or 

--| statistics update) all be performed in 100 millisecs. The delays specified 
in the timed tasks (Target.Track, Rocket.Control, Simulate.RDL.Rock_Sup and 
--| Simulate.Sensor.TargSup are the timed tasks currently) are calculated 
-| so that they will wakeup once every interval (100 ms). The rest of the 
-| system derives its timing from these drivers. 

--| The priorities are grouped together here because priorities specified 
--| individually in each task declaration does not help anyone looking to 
--| determine priorities which are relative to each other. The Mouse_Buffer 


- 48 - 









Distributed Issues Final Report 


--| task is not the highest priority task. Since there is a mouse associated 
--| with the system, which uses an interrupt entry call and is treated as a 
--| task, it uses the hardware interrupts to determine its priority. Since 
--| a task must always be sitting at the accept to receive the interrjpt tasks' 
--| entry call, the Mouse_8uffer task (which is responsible for translating 
--| the X-Y motion of the mouse (and any buttons pushed) into motion of the 
--| reticle) is defined at the highest software priority level. For the same 
--| reason, as well as to be able to keep the screen in real time, the Graphics 
--| task is declared with the next available priority. In order to increase 
-*| throughput from the simulator to the BOS the buffers which route rocket 
--| and target data are declared with the next highest available priority. 

--| Because the simulator contains the two tasks which are scheduled according 
--| to a deadline (RockSup and TargSup) these tasks are next in the priority 
**| line. Then the rocket controller for the BOS and the target controller 
--| for the BOS are (respectively) assigned their priorities. Below these 
**| tasks is the statistics task priority. It is allowed to be low because 
--| of the liberal timing requirements placed on it by the requirements 
--| documentation. Obviously, since the main program performs no function 
--| which is of use to the BOS, it is assigned the lowest priority. 


-- Modifications Log 

-- 88-10-11 : TEG => Original created. 

-- 89-11-16 : MPS => Added launch attitudes and locations. 


with System; use System; 
package Config is 


-- The following two constants allow the space needed for the various tasks to 
-- be declared in bytes. 

byte : constant := 8; -- 8 bits 

bytes_per_storage_unit : constant := byte / System.STORAGE_UNIT; 

-- Now define battlefield area perimeters 


meters_in_battle_area : constant := 4_000.0; -- in X and Y direction 


meters_per_X_pixel 
meters_per_Y_pixel 
max_pixels_in_battle_area 


: constant := 9.625; -- rounded up to nearest 

: constant := 11.875; -- Types.METER. 

: constant := meters_in_battle_area 

/ meters_per_X_pixel; 


-- Task priorities in order of decreasing urgency. 


-- NOTE: MOUSE IN_CHAR has no priority because it runs 
completely at the hardware interrupt level. 

-- The idea implemented here is that all the Simulator information is 
of higher priority than the actual Border Defense System code. 


- 49 - 





Distributed Issues Final Report 


save_priority : constant PRIORITY 
display_priority : constant PRIORITY 
track_data_priority : constant PRIORITY 
report_buf_priority : constant PRIORITY 
guide_buf_priority : constant PRIORITY 
rock_sup_priority : constant PRIORITY 
targ_sup_priority : constant PRIORITY 
control_priority : constant PRIORITY 
guidance_priority : constant PRIORITY 
track_priority : constant PRIORITY 
updatejoriority : constant PRIORITY 
bds_priority : constant PRIORITY 


= PRIORITY'last; -- Mouse_Buffer 

= save_priority-1; -- mapf, ics 

= display_priority-1; -- Target 
= track_data_priority-1;-- Sim.RDL 
= report_buf_priority-1;-- Sim.RDL 
= guide_buf_priority-1; -- Sim.RDL 
= rock_sup_priority-1; -- Sim.Sensor 
= targ_sup_priority-1; -- Rocket 
= control_priority-1; -- Rocket 

= guidance_priority-2; -- Target 
= track_priority-1; -- Status 
= update_priority-1; -- Main 


-- define entire hi-res screen display borders. The screen is divided into 
-- two main sections. There is the battlefield area where the targets, rockets, 
-- and reticle are allowed to move, and there is the statistics area where our 
-- current statistics will be displayed. The maximum number of digits allowed 
-- in any statistics displayed is statistics_lengtb. Between the statistics and 
-- the battlefield there is a border. 

-- define entire screen constants 

entire_screen_left : constant := 0; 

entire_screen_right ; constant := 639; 

entire_screen_top : constant := 0; 

entire_screen_bottom : constant := 349; 

-- define battlefield display borders and center. 


battlefield_screen_left 

: constant 

: = 

222; 


starting (left) 

battlefield_screen_right 

: constant 

: = 

638; 

-- 

ending (in pixels) 

battlefield_screen_top 

: constant 

: = 

i; 

-- 

starting (top) 

battlefield_screen_bottom 

; constant 

: = 

338; 

-- 

ending (in pixels) 

battlefield_center_x 

: constant 

: = 

430; 

-- 


battlefield_center_y 

: constant 

: = 

169; 

-- 


-- define border between 

battlefield 

and statistics 


border_left 

; constant 

: = 

221; 

-- 

starting (left) 

border_right 

: constant 

: = 

639; 

-- 

ending (in pixels) 

border_top 

: constant 

: = 

0; 

*- 

starting (top) 

border_bottom 

: constant 

: = 

339; 


ending (in pixels) 


- define statistics display borders. 


status_left 

: constant 

:= 0; 

-- starting (left) 

status_right 

: constant 

:= 220; 

- - ending (in pixels) 

status_top 

: constant 

:= 0; 

-- starting (top) 

status_bottom 

: constant 

:= 349; 

- - ending (in pixels) 


- 50 - 







Distributed Issues Final Report 


-- statistics_length is 

the number of 

digits allowed in any status field, and 

-- stats_title_max_length is the max 
-- statistics title may contain. 

number of 

letters any particular 

statistics_length 

: constant 

:= 4; 


stats_title_max_length 

: constant 

:= 11; 


number_of_titles 

: constant 

:= 12; 


max_targets 

: constant 

:= 50; 

-- total targets 

max_rockets 

: constant 

:= 20; 

-- total rockets 

interval 

: constant 

:= 0.100; 

-- basic interval is 100ms 

gravity 

: constant 

:= 9.80665 

; -- meters/sec**2 

launch attitude 

launch_azimuth 

: constant 

:= 16384; 

-- straight ahead in BAMS 

launch_elevation 

: constant 

:= 15000; 

-- 7.6 degrees off straight l 

launch_x 

: constant 

:= 2000.0; 


laurtch_y 

: constant 

:= 60.0; 


launch_z 

: constant 

:= 10.0; 


kill_radius 

: constant 

:= 10.0; 

-- 10 meters x 10 meters 


end Config; 


- 51 - 




Distributed Issues Final Report 


UNIT: Control task subunit. 

--% Effects: Provides overall control for rocket flight and display. 
--% Modifies: Updates rocket data base in Rocket body. 

--% Requires: No initialization is required. 

--% Raises: No explicitly raised exceptions are propagated. 

--% Engineer: T. Griest. 


--| TASK BODY : Rocket.Control 

--| The Rocket.Control task controls the information coming in from the rocket 
--| support task and the target support task. With this information it 
--| develops a list for the guidance task to work on (the guidance task being 
--| in charge of developing new aimpoints for each rocket), updates the 
--| statistics, launches a new rocket if necessary, sends the new positions of 
--| the rockets to graphics for displaying, receives from guidance the new 
--| aimpoints, and delivers those to the Rocket Support task in the simulator. 
--| The purpose of the disengaged pointers, the engage flag, and the rocket 
--| launch flag is to support the specification that only one target can be 
-*| marked destroyed each interval and that only one rocket can be launched 
--| per interval. Also going along with this is that targets can only be 
--| created one per interval. This helps to maintain a better average 
-*| response time, thus predictibility of the amount of time this routine will 
--| take is enhanced. If a graph was drawn of CPU utilization versus time, and 
--| the targets ana rockets were all allowed to be created and destroyed in 
-*| one interval as necessary, then several destroyed rockets and consequently 
--| several created targets (the next interval) would appear on the graph as 
--| spikes. It is necessary to eliminate "spikes" from the BDS because it is 
a deadline driven mission. For this reason, the Simulate.RDL ,Rock_Sup task 
--| and the Simulate.Sensor.Targ_Sup task have timing loops surrojnding their 
--| executable code. This technique allows for better fault tolerance; if one 
--| of the buffer tasks or even one of the four main tasks mentioned above were 
--| to be disabled because of an error, the rest of the system would still be 
--| able to function properly. 

--| The rendezvous mechanism with the guidance task is done as if there were 
--| an array of guidance tasks. Although there is only one guidance task at 
--| present, if more were added and they were on separate processors, this 
--| design would facilitate the distribution of those tasks. 


-- Modifications Log 

-- 88-11-10 : TEG => Original Created. 

-- 89-11-22 : MPS => History information moved from rocket package body 
to rocket.control task body. 


with Interrupt_Control; 
with Grid_to_Pixel; 


- 52 - 









Distributed Issues Final Report 


with Simulate; 
with Target; 
with Sync; 
with Calendar; 
with Engage; 
with Time_Stamp; 

pragma ELABORATE(Interrupt_Control, Grid_to_Pixel, Sync, 

Simulate, Target, Calendar, Engage, Time_Stamp); 

separateeRocket) 

task body Control_Type is 

use Calendar; -- for operators 

use Types; -- for operators 

use Sync; -- for operators 

package RDL renames Simulate.RDL; -- make simulator transparent 

dis_list_size : constant := Config.max_rockets; 

type HISTORY_REC_TYPE is record 
ROCKETJDLD : Types.POSITIONTYPE; 

TARGET_OLD : Types.POSITION_TYPE; 

TARCET_AIMED_AT : Types.UORDJNDEX; 
end record; 

type HI ST ORY_LIST_TYPE is arrayf T ypes.ROCKET J NDEXJ YPE) of HISTORY_REC_TYPE; 

POS_HISTORY : H1STORY_LIST_TYPE; -- olds old rocket/target positions 

MOVE_NUMBER : Types.UORDJNDEX; -- to update display 

NEXT_ROCKET_MSG : ROCKET_MSG_TYPE; -- local copy of input msg 

NEXT JARGET_LIST : Target.TARGET DATAJIST TYPE; -- local copy of input data 
GUIDE_MSG : ROCKET JjUIOE_MSG_TYPE; -- local copy of output msg 

AIHPOINTJI ST : AIMPOINTJ.ISTJYPE(Types.ROCKETJNDEXJYPE); 

-- local copy 

MOVE_ROCKETS : Graphics.MOVE_lISTJYPE(Types.ROCKETJNDEXJYPE); 

MOVE_INDEX : Types.WORD_INOEX; 

PIXEL_POINT : Shapes.PIXEL; 

MSGJNDEX : Types.WOROJNOEX; 

OLD_SEO_TAG : Sync.SEQ_TYPE; 

ANY_ACTIVE_ROCKETS : BOOLEAN; 

ACTIVE_ROCKETS_ID : Types.ROCKET_INDEX_TYPE; 

NEXT_ENGAGED : Target.TARGET_ID_TYPE; 

NEXT_DISENGAGED : Target.TARGET_ID_TYPE; -- keep track of all disengagements 
DISENGAGEDJ.IST : array(Types.ROCKET_INDEX_TYPE) of Target.TARGET_ID_TYPE; 


-- used to index incoming report 
-- to filter stale reports out 
-- used to update OLD_SEQ_TAG 
-- holds an active rockets ID 


- 53 - 




Distributed Issues Final Report 


DISENGAGED_ON_PTR : Types.UORDJNDEX; 

01SENGAGED_OFF_PTR : Types.WORDJNDEX; 

DISENCAG£D_ACK_PTR : Types.WORDJNDEX; 

AVAILABLE JIOCKET : Types.UORD_INDEX; -- possible rocket to launch 

LAUNCH_PENOING : BOOLEAN := FALSE; 

LAUNCH_TARGET : Target.TARGET JDJYPE; 

LAUNCH JIOCKET : Types.ROCKETJNDEXJYPE; 

ROCKETDESTROYED : BOOLEAN; 

ROCKET J.AUNCHED : BOOLEAN; 


begin 

accept Start; 

for I in AIMPOINT INFO'range loop -- initialize track data 
AIMPOINTJNFO(I).ACTIVE := FALSE; 

DISENGAGED_LIST(I) := 0; 
end loop; 

NEXTENGAGED := 0; 


DISENGAGED_ON_PTR := 1 
DISENGAGED_OFF_PTR := 1 
D1SENGAGE0_ACK_PTR := 1 


initialize disengage circle queue 


OLO_SEQ_TAG := 0; 


loop -■ Main processing loop 

begin -- exception block 

Time_Stamp.Log(0002); --$TP<0002) Control task start time 
ROCKET_DESTROYED := FALSE; 

ROCKET_LAUNCHED := FALSE; 

ANY_ACTIVE_ROCKETS := FALSE; 


-- Rendezvous uith buffer task to get next rocket message from sensor 


Time_Stamp.Log(0003); --$TP(0003) Control rendezvous with Report_Buf start 
RDL-Report_Buf.Get_Report(NEXT_ROCKET_MSG); 

Time_Stamp.Log(000A); --$TP(0004) Control rendezvous with ReportBuf end 

If there are more on circular disengage queue, send another to tracker 

if 01SENGAGED_OFF_PTR /= OISENGAGED_ON_PTR and then 
not NEXT_TARGET_LIST(0ISENGAGED_LIST(OISENGAGED_OFF_PTR)).STATUS.ENGAGED 
then 

DISENGAGED_OFF_PTR := DISENGAGED_OFF PTR rem dis_list_size ♦ 1; 
end if; 

if 01SENGAGED_OFF_PTR = 0lSENGAGEO_ON_PTR then 
NEXT_0lSENGAGEO := 0; 
else 

NEXT DISENGAGED := DISENGAGED_LI ST(DISENGAGEO_OFF_PTR); 


- 54 - 










Distributed Issues Final Report 


end if; 

Rendezvous to Get target list from target tracker, and provide it 
uith information on which targets have been engaged and disengaged. 

Time_Stamp.Log(0005); --*TP(0005) Control rendezvous with Track_Dat start 
Target.Track J)ata.Get(NEXTJARGET JI ST, NEXT_ENGAG£D, NEXT J)1SENGAGED); 
Time_Stamp.Log(0006); --*TP(0006) Control rendezvous with Track_Dat end 

Check if Track task has recognized the engage request, if so then 
it is safe to clear it, and possibly engage another. 

if NEXT_ENGAGED /= 0 and then 

NEXT JARGET JIST(NEXT_ENGAGEO).STATUS.ENGAGED 
then 

NEXT_ENGAGED := 0; 
end if; 

Check to see if last disengage request was acknowledged 

if DISENGAGED_ACK_PTR /= 01SENGAGED_OFF_PTR and then 
not NEXT_TARGET_LIST(DISENGAGED_LI ST(DISENGAGED_ACK_PTR)).STATUS.ENGAGED 
then 

DISENGAGEOACKPTR := DISENGAGEDACKPTR rem dis_list_size + 1; 
end if; 


determine which rockets have been expended, and delete them from screen 
(previously active, but no longer in report list) 

MOVEJNDEX := 0; 

MSGJNDEX := 1; 

for ROCKETJD in Types.ROCKET_INDEX_TYPE loop 

if AIMPOINTJNFO(ROCKETJD).ACTIVE then 

if NEXT_ROCKET_MSG.ROCKET_LIST(MSG_INDEX).SYNC_TAG = OLD_SEQ_TAG then 
ANY_ACTIVE_ROCKETS := TRUE; -- need an active rockets time tag 
ACT I VE_ROCKETS_ID := ROCKETJD; 

exit; -- old rocket report 

end if; 


look at most recent rocket report message to make sure rocket is still alive 


if MSGJNDEX <= NEXT_ROCKET_MSG.NUM_ROCKETS and then 

ROCKETJD = NEXT_ROCKET_MSG.ROCKETJI ST (MSG_INDEX). ROCKETJD 
then 

P0S_HlST0RY(R0CKET_I0).R0CKET_0LD := 

AIMPOINT_INFO(ROCKET ID).ROCKET_POS; 
AIMPOINT_INFO(ROCKET_ID).ROCKET_P0S : = 


- 55 - 





Distributed Issues Final Report 


NEXT_ROCKET_MSG.ROCKET_l1 ST(MSG_INDEX). POSlTI ON; 
POS_HISTORY(ROCKET_ID).TARGETOLD := 

AIMPOINTJNFO(ROCKET_ID).TARGET_POS; 
A1MP01NT_1NF0(R0CKET_ID).TARGET_P0S := 
NEXT_TARGET_LIST(POS_HISTORY(ROCKET_ID).TARGET_AIMED_AT).POSITION_NEU; 
MOVE_INDEX := MOVEJNDEX + 1; 

MOVE_ROCKETS(MOVE_INDEX) := 

(XY_OLD => Gr id_to_Pixel(POS_HI STORY(R0CKET_ID).ROCKET_OLD), 
XY_NEW => Grid_tO_Pixel(AlMP0INT_lNF0(R0CKET_!D).R0CKET_P0S), 
OBJECT => Shapes.ROCKET, 

COLOR => Graphics.ROCKET_COLOR); 

MSG_INDEX := MSG_INDEX + 1; 
else 


the rocket has deceased, put it in the list for erasure. 


PIXEL_POINT := Grid_to_Pixel( -- get last point in pixel value 
AIMPOINT_INF0(R0CKET_ID).ROCKET_POS); 
AIMPOINT_INFO(ROCKET_ID).ACTIVE := FALSE; -- mark as inactive 
M0V£_1NDEX := MOVE_INDEX + 1; 

MOVE_ROCKET S(MOVE_INDEX) : = 

(PIXELPOINT, 

PIXEL_POINT, 

Shapes.ROCKET, 

Graphics.background_color); 

AVAILABLE_ROCKET := ROCKET_ID; -- save if decide to launch 

DISENGAGEDJ. I ST(01SENGAGED_ON_PTR): = 

POS_HI STORY(ROCKET_ID). TARGET JWMED_AT; 

DISENGAGED_ON_PTR := 01SENGAGED_ON_PTR rem dis_list size + 1; 
Interrupt_Control.Disable; 

Status.STATUS_CONTROL(Status.AIRBORNE).DATA := 

Status.STATUS_C0NTR0L(Status.AIRBORNE).DATA - 1; 

Status.STATUS_CONTROL(Status.EXPENDED).DATA := 

Status.STATUS_CONTROL(Status.EXPENDED).DATA + 1; 
Interrupt_Control.Enable; 

ROCKET_DESTROYED := TRUE; 
end if; -- found 
else 


rocket slot previously inactive, see if rocket has launched 

if MSGJNDEX <= NEXT_ROCKET_MSG.NUM_ROCKETS and then 
NEXT_ROCKET_MSG. ROCKE T_L I ST(MSG_I NDEX) .ROCKETJD = 

R0CKET_ID 

then 


ROCKET HAS BEEN LAUNCHED, UPDATE DATA BASES 

AIMPOINTJNFO(ROCKETJD) : = 

( TRUE, -- ACTIVE 

NEXT_ROCKET_MSG.ROCKET_L 1ST V 'MSG_INDEX) .POSITION, -- NEW 


- 56 - 





Distributed Issues Final Report 


NEXT_T ARGET_LI ST(LAUNCH_TARGET).POS1T1ON_NEW); -- NEU 

POS_HI STORY(ROCKET_10) : = 

(NEXT_R0CKET_MSG.R0CKET_LIST(MSGJNDEX).POSITION, -- OLD 
NEXT_T ARGET_LI ST(LAUNCH_TARGET).POS1T1ON_NEU, -- OLD 

LAUNCH_TARGET); -- TARGET AIMED AT 

LAUNCH_PENDING := FALSE; -- alt accounted for 

MSGJNDEX := MSG_INDEX + 1; 

Interrupt_Control.Disable; 

Status.STATUS_CONTROL(Status.AIRBORNE).DATA := 

Status.STATUS_CONTROL(Status.AIRBORNE).DATA + 1; 
Interrupt_Control.Enable; 

ROCKET_LAUNCHED := TRUE; 
else 

AVAILABLE_ROCKET := ROCKETJD; 
end if; -- new rocket test 

end if; -- active test 

end loop; -- rocket-id loop (scan of all rockets) 


Update Time tag for next message. 


if ANY_ACTIVE_ROCKETS then 

OLD_SEQ_TAG := NEXT ROCKET MSG.ROCKET LI ST(ACT IVE_ROCKETS_ID).SYNC_TAG; 
end if; -- if no active rockets, don't change OLD_SEQ_TAG. 


Get guidance task(s) working on finding new aimpoint for guidance msg 

for I in Types.UORD_INDEX range 1. ,Distrib.nLin_guide_tasks loop 
Time_Stamp.Log(0007); --$TP(0007) Control rendezvous with Guidance(l) start 
Rocket_Guide(I).History( 

AIMPOINT_INFO(Distrib.guide_low(I).,Distrib.guide_high(I))); 
Time_Stamp.Log(0008); --STP(0008) Control rendezvous with Guidance(l) end 
end loop; 

update status information 

Interrupt_Control.Disable; 
if ROCKET_LAUNCHED then 

Status.STATUS_CONTROL(Status.AIRBORNE).DISPLAYED := FALSE; 
end if; 

if ROCKET_LAUNCHED or ROCKET_DESTROYED then 
Status.STATUS_CONTROL(Status.AIRBORNE).DISPLAYED := FALSE; 

Status.STATUS_CONTROL(Status.EXPENDED).DISPLAYED := FALSE; 

Status.REO_COUNT ;= Status.REQ_COUNT + 1; 
if Status.REO_COUNT = 1 then 

Time_Stamp.Log(0009); --STP(0009) Control rendezvous with Status start 
Status.Update.Signal; 

Time_Stamp.Log(0010); --STP(OOIO) Control rendezvous with Status end 
end if; 
end if; 

Interrupt_Control.Enable; 







Distributed Issues Final Report 


MSGJNDEX := 0; -- zero index for creating guidance message 

Now, check if we should try to create a new ROCKET. Note that 
if a rocket has just been destroyed, don't try to fire a new one 
before the rocket tracker knows that it has been disengaged. Otherwse 
it is likely to choose a target other than one that is closest. 

if not LAUNCH_PENDING and 

DISENGAGED_ACK_PTR 01SENGAGED_ON_PTR and 
NEXT_ENGAGED = 0 
then 

NEXT_ENGAGED := EngagelNEXT JARGET_L1ST); 
if NEXT_ENGAGED > 0 then 
LAUNCH_ROCKET := AVA1LA8LE_R0CKET; 

LAUNCH_TARGET := NEXTENGAGED; 

LAUNCH_PEN0ING := TRUE; 

°nd if; -- ready to launch 
ena if; -- not pending check 

get graphics task working on displaying rockets 

Time_Stamp.log(0011); --$TP(0011) Control rendezvous with Graphics start 
Graphics.Display.Move(Graphics.LOW, MOVE_ROCKETS( 1.-MOVE JNDEX)); 
Time_Stamp.Log(0012); --$TP(0012) Control rendezvous with Graphics end 

now get results of guidance information 

for I in Types.UORD_INDEX range 1..Distrib.num_guide_tasks loop 

Time_Stamp.Log(0013); --$TP(0013) Control rendezvous with Guidance(2) start 
Rocket _Guide(I).Next_Guidance( 

AIMPOINT_LIST(Distrib.guide_low(I).,Distrib.guide_high(I)) ); 
Time_Stamp.Log(0014); --$TP(0014) Control rendezvous with Guidance(2) end 
end loop; 


-- all have been ack'ed 
-- engage has been ack'ed 


Now generate new guidance message and send to Guide_Buf 


for ROCKETJD in AIMP01NT JNFO'range loop 
if AIMPOINTJNFO(ROCKETJD).ACTIVE then 
MSGJNDEX := MSGJNDEX + 1; 

GUIDE_HSG.ROCKET_GUIOE_L1ST(HSG_INDEX> : = 

(ROCKETJD, A1MP0INTJ. I SPROCKET _ID)); 

elsif LAUNCH_PENOING and then 

ROCKETJD = LAUNCHROCKET then 
MSGJNDEX := MSGJNDEX + 1; 
initiate launch 

GUIDE_MSG.ROCKET J5UIDE JIST(MSG JNDEX) := (ROCKETJD, 

(Config.launch_azimuth, 

Config.launch_elevation)); 


- 58 - 




Distributed Issues Final Report 


end if; 
end loop; 

GU10E_MSG.NUM_ROCKETS := MSG_1NDEX; 

Time_Stamp.Log(0015); --$TP(0015) Control rendezvous with Guide_Buf start 
RDL.Guide_Buf.Put_Guide<GUIDE_MSG); -- send new guidance message 

Time_Stamp.log(0016); --$TP(0016) Control rendezvous with Guide_Buf end 

exception 
when others => 

Debug_10.Put_Line("Exception in Control task"); 
end; -- exception block 

end loop; -- main processing loop 

end Control_Type; -- Rocket.Control task body 


- 59 - 




Distributed Issues Final Report 


--% UNIT: Debug_lO Spec. 

--% Effects: Provides non-intrusive trace output to secondary port. 
--% Modifies: No global data is modified. 

Requires: No initialization is required. 

--% Raises: No explicitly raised exceptions are propagated. 
Engineer: T. Griest. 


--| PACKAGE SPEC : DebugJO 

--| This package is used to provide visibility to the character (and string) 
-*| input and output procedures. Currently, because the screen memory is 
--| written directly to, all text input and output is done via a serial port. 
--| These routines are needed to signal to the user (via the serial port) that 
--| an exception has occurred. 


-- Modifications Log 

-- 88-09-01 : TEG => Original created. 


package DebuglO is 

procedure Put(CHAR : CHARACTER); 
procedure Get(CHAR : out CHARACTER); 
procedure PutCSTR : STRING); 
procedure Get(STR : out STRING); 
procedure Put_line(STR : STRING); 

procedure Get_line(STR : out STRING; LENGTH : out INTEGER); 
procedure Skip_Line; 

end Debug_IO; 


- 60 - 








Distributed Issues Final Report 


UNIT: DebugJO body. 

Effects: Provides non-intrusive trace output to secondary port. 
Modifies: No global data is modified. 

--X Requires: No initialization is required. 

--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: T. Griest. 


--| PACKAGE BOOT : DebugJO 

--| The DebugJO package is used to provide a means of communication from 
--| the BDS to the user. Since the terminal (the EGA screen in this case) is 
--| being written to directly, output cannot take place there, and therefore 
--| TextJO cannot be used. See the hardware configuration file for more 
--| details on the input and output modes. 


-- Modifications Log 

-- 88-09-01 : TEG => Original created. 


with Terminal JJriver; 

pragma ELABORATE ( Termi na l _D ri ve r ); 

package body DebugJO is 

pragma SUPPRESS(storage_check); 

procedure PutCCHAR : CHARACTER) is 
begin 

Terminal J>river.Put_Character(CHAR); 
end Put; -- character 

procedure Get(CHAR : out CHARACTER) is 
begin 

Terminal Jlriver.Get_Character(CHAR); 
end Get; -- character 

procedure Put(STR : STRING) is 
begin 

for I in STR'range loop 

Terminal_Driver.Put_Character(STR(I)); 
end loop; 

end Put; -- String 

procedure Get(STR : out STRING) is 
begin 

for I in STR'range loop 


- 61 - 







Distributed Issues Final Report 


Terminal_Oriver.Get_Character(STR(I)); 
end loop; 

end Get; -- String 

procedure Put_Line(STR : STRING) is 
begin 

for I in STR'range loop 
Terminal_Oriver.Put_Character(STR(I)); 
end loop; 

Terminal_Oriver.Put_Character(ASCII.CR); 
Terminal_Oriver.Put_Character(ASCII. LF); 
end Put_Line; 

procedure Get_Line(STR : out STRING; LENGTH : out INTEGER) is 
CHAR : CHARACTER := ASCII.NUL; 

LEN : INTEGER := STR'first; 
begin 

while CHAR /= ASCII.CR and LEN <= STR'last loop 
Terminal_Oriver.Get_Character(CHAR); 

STR(LEN) := CHAR; 

LEN := LEN + 1; 
end loop; 
end Get_Line; 

procedure Skip_Line is 

CHAR : CHARACTER := ASCII.NUL; 
begin 

while CHAR /= ASCII.CR loop 

Terminal J)river.Get_Character(CHAR); 
end loop; 
end Skip_Line; 


end Debug_IO; 


- 62 - 





Distributed Issues Final Report 


--% UNIT: Distrib Package Spec. 

--X Effects: Provides parameters to control task arrays and work lists.-- 
--X Modifies: No global data is modified other than in this spec. 

■•X Requires: Depends on presence of Distrbuted Runtime for # of tasks. -- 
--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: T. Griest. 


--| PACKAGE SPEC : Distrib 
--| OPERATION : 

--| This package controls the parameters for automatically performing a 
--| division of the guidance workload. In this case, a large array can be 
-| broken down so that two or more tasks can perform their operations on the 
--| array at the same time (if true multi-processing is in effect). 


-- Modifications Log 

-- 88-12-05 : TEG => Original Created. 

-- 89-12-06 : TEG => Enhanced to support dynamic configuration/reconfiguration 


with Types; 


DISTRIBUTION CONTROL PARAMETERS 


package Distrib is 

Configuration Setting for number of Rockets and Targets 
These are set during package body elaboration. 

NUM_TARGETS : Types.WORDJNDEX; 

NUM_ROCKETS : Types.WORDJNDEX; 


Maxjium guide tasks is used to determine the maximum number of guide 
tasks which could be created. It is used simply to define the size of 
the index arrays. 

Max_guide_tasks : constant := 2; 

NUM_GUIOE_TASKS contains the ACTUAL number of guide tasks in the current 
configuration. It is initialized by a call to the distributed runtime 
during package elaboration. 

NUM_GU!DE_TASKS : Types. WORDJNDEX; 


- 63 - 










Distributed Issues Final Report 


-- MASTER is TRUE iff this processor has been configured as the master 
-- processor. 

MASTER : BOOLEAN; 

-- The following two "index" arrays are used by the Congrol task to 
-- divide work among the possible guidance tasks, these values are 
-- also intialized according to the configuration control tables in 
in the Distrib package body during elaboration. 

GUIDE_LOU : array(Types.UORO_INOEX range 1..Max_guide_tasks) 

of Types.WORDJNDEX; 

GUIDE_HIGH ; array(Types.WORD_INOEX range 1..Max_guide_tasks) 

of Types.UORDINDEX; 

-- RESTART is used to slop operation of the BDS and allow the operator 
setup a different configuration. It is only called when the MOOE 
button is pressed while the RESET button is held down on the mouse. 

procedure Restart; -- DOES NOT RETURN TO CALLER! 
pragma INTERFACE(ASM86, Restart); 

pragma INTEREACE_SPELLING(Restart, "D1DRTE7RESTART"); 
end Distrib; 


- 64 - 






Distributed Issues Final Report 


--X UNIT: Engage Procedure Spec. 

--X Effects: Determines if Rocket is to be launched, and at what target.- 
--X Modifies: No global data is modified. 

--X Requires: Status package must set mode and airborne counts. 

--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: M. Sperry. 


- -1 SUBPROGRAM SPEC : Engage 

--| This function determines which target will be selected when it is 
**| determined that a rocket needs a target to aim at. 

-- Modifications Log 

-- 88-11-10 : MPS => Original Created. 


with Target; 

function Engage(TARGET_INFO : in Target.TARGET_DATA_LIST_TYPE) return 
Target.TARGET_1D_TYPE; 


- 65 - 








Distributed Issues Final Report 


--% UNIT: Engage Procedure Body. 

--% Effects: Determines if Rocket is to be launched, and at what target.- 
Modifies: No global data is modified. 

--X Requires: Status package must set mode and airborne counts. 

--% Raises: No explicitly raised exceptions are propagated. 

--X Engineer: M. Sperry. 


--| S'JBROGRAM BOOT : Engage 

**| The Engage procedures performs two functions based on the MODE. The 
--| MOOE is either MANUAL or AUTOMATIC. In MANUAL mode the engage procedure 
-*| first determines if a rocket can be launched and not exceed the maximum 
-*| allowable rockets. It then reads the shared variables of the reticle's 
--| position and the LAUNCH button on the mouse and determines if the reticle 
--| is in proximity to a target. If so, that target is chosen unless there is 
--| one closer. In AUTOMATIC mode, if there are not too many active rockets, 

--| then the target closest to the bottom of the screen is chosen. This routine 
--| is called during every rocket control task iteration. The returned 
--| parameter TARGET is zero if no target should be engaged, otherwise it 
--| indicates the selected targets id. 

-- Modifications Log 

-- 88-11-20 : MPS => Original Created. 


with Interrupt_Control; 
with Status,- 
with MouseBuffer; 
with Types; 
with Config; 
with Shapes; 
with Time_Stamp; 
with Distrib; 

pragma ELABORATE!Interrupt_Control, Status, MouseBuffer, Distrib); 


function Engage(TARGET_INFO : in Target.TARGET_DATA_LIST_TYPE) return 
Target.TARGET_ID_TYPE is 


use Types; 
use Status; 

RET ICLE_X_PIXEL 
RETICLE_Y_PIXEL 
RETICLE_X_GRI0 
RE TICLE_Y_GR10 
PREV DISTANCE 


-- for operators 
-- for operators 

: Types.WORD; 

: Types.WORD; 

: Types.METERS; 

: Types.METERS; 

: Types.METERS; 


-- reticle in PIXEL coordinates 
-- reticle in PIXEL coordinates 
-- reticle in GRID coordinates 
-- reticle in GRID coordinates 


- 66 - 









Distributed Issues Final Report 


DISTANCE_X 
DISTANCED 
T0TAL_01STANCE 
TARGET ID 


: Types.METERS; 

: Types.METERS := Conf ig.meters_in_battle_area; 
: Types.METERS; 

: Target.TARGET_ID_TYPE; 


begin 

Time_Stamp.Log(0018); --$TP(0018) Engage start 
TARGET_ID := 0; -- default 

if Status.STATUS_CONTROL(Status.AIRBORNE).DATA < 

Types.WORD(Dist rib.NUM_ROCKET S) 
then 

if Status.MOOE = Status.MANUAL then 
if Mouse_Buffer.LAUNCH then 

-- read A8S_X and ABS_Y in Mouse_Buffer, then convert to METERS types. 
-- Then, find closest target in list to reticle, and give it back. 
Interrupt_Control.Disable; -- go atomic while reading 

R£TICLE_X_PIXEL := Mouse_Buffer.NEW_ABS_X; 

RETICLE_Y_PIXEL := Mouse_Buffer.NEU_ABS_Y; 

Mouse_Buffer.LAUNCH := FALSE; 

Interrupt_Control.Enable; 

RETICLE_X_GRID := 

Types.METERSCTypes.METERS(RETICLE_X_PIXEL - 

Config.battlefield_screen_left) * 

Types.METERS(Config.meters_per_X_pixet)); 

RETICLE_Y_GRID := 

Types.METERSCTypes.METERS(Config.battlefield_screen_bottom - 
RETICLE_Y_PIXEL) * 

Types.METERS(Config.meters_per_Y_pixel)); 

-- This loop locates the closest target to the reticle center 
for ID in Types.TARGET_INDEX_TYPE loop 
if TARGETJNFO(ID).STATUS.ACTIVE and then 
not TARGETJNFO(ID).STATUS.ENGAGED then 
DISTANCE_X := abs(RET ICLE_X_GRID - Types.METERSf 
TARGET_INFO(ID).POSITI0N_NEW.X>); 

DISTANCE_Y := abs(RET ICLE_Y_GRID - Types.METERS( 

TARGET_INF0(ID).POSlTI0N_NEW.Y)); 
if DISTANCE_X <= Shapes.reticle_X_error and 
DISTANCE_Y <= Shapes.reticle_Y_error 
then 


T0TAL_DI STANCE := Types.METERS(OISTANCE_X * DISTANCE_X) + 

Types.METERS(DISTANCE_Y * DISTANCE_Y); 
if TARGET_ID = 0 or else T0TAL_DI STANCE < PREV_DI STANCE then 
PREV_DI STANCE := TOTAL_01 STANCE; 

TARGETJD := ID; 

end if; -- distance/target check 

end if; -- x and y reticle distance check 

end if; -- active/not engaged check 


end loop; 

end if; -- launch check 

else -- automatic mode, search for closest Y value 

for ID in Types.TARGET_INDEX_TYPE loop 


- 67 - 




Distributed Issues Final Report 


if TARGETJNFO(ID).STATUS.ACTIVE and then 
(not TARGETJNFO(ID).STATUS. ENGAGED and 

Types.METERS(TARGET_INF0(ID).P0S1TI0N_NEW.Y) <= DISTANCEJO 
then 

DISTANCE_Y := Types.METERS(TARGET_INFO(ID).POSITION_NEU.Y); 
TARGET_ID := ID; 

end if; -- active/not engaged/closest y check 

end loop; 

end if; -- mode check 

end if; -- nunber of rockets check 

Time_Stamp.log(0019); --$TP(0019) Engage end 
return TARGET_ID; 
end Engage; 


- 68 - 





Distributed Issues Final Report 


--X UNIT: Graphics Package Spec. 

--X Effects: Performs all updates to graphics display. 

--X Modifies: No global data is modified. 

--X Requires: Screen must be put in graphics mode by runtime initialize. 
--X Raises: QUEU£_ERROR is raised if no room for move list. 

--X Engineer: T. Griest / M. Sperry. 


--1 PACKAGE SPEC : Graphics 

--| The Graphics package provides the interface for all screen display 
--| operations. All activity is performed by the Display task which insures 
--| that the display is updated in a consistent and timely fashion. The shapes 
--| that the graphics displays are all defined in the Shapes package. The 
--| MOVE_RECORD is defined as all the elements needed in order to perform a 
--| draw or erase of an image. A MOVE_LIST is an array of MOVE_RECORDs and 
--| it is used as a parameter when one of the routines responsible for moving 
-*| an image across the screen needs to rendezvous with Graphics.Display. An 
--| entire list is enqueued onto one of the priority queues and each element 
--| is dequeued separately in order to continuously check for more arrivals. 

--| The high priority queue is currently reserved for the reticle motion. 

-I 

-- Modifications Log 

-- 88-08-25 : TEG => Original created. 


with Types; 
with Config; 
with Shapes; 

package Graphics is 

stack_size : constant := 8192; -- in bytes 

-- define screen and graphics constants 


subtype COLORTYPE 

is Types.WORD; 

- - range 

0 

.63; -- 64 colors on EGA 

background_color : 

constant 

COLOR 

.TYPE 

= 

0 

-- black 

reticle_color : 

constant 

COLOR. 

TYPE 

= 

14 

-- bright yellow 

border_color : 

constant 

COLOR. 

_T V PE 

= 

9 

-- bright blue 

status_color : 

constant 

COLOR. 

.TYPE 

= 

15 

-- bright white 

status_box_color : 

constant 

COLOR. 

.TYPE 

= 

9 

-- bright blue 

rocxet_color : 

constant 

COLOR. 

TYPE 

= 

12 

-- bright red 

target_color : 

constant 

arraylTypes 

TARGET_CLASS_TYPE, BOOLEAN) of 


- 69 - 









Distributed Issues Final Report 


COLOR_TYPE := ((6, 14), (3, 11), (2, 10), (5, 13)); 

-- different color for engage = false/true and target type 
no_process : constant COLOR_TYPE := 16; -- don't process object color 


-- define graphics data structures 


type MOVE_RECORD is record 
XY_0LD : Shapes.PIXEL; 

XY_NEW : Shapes.PIXEL; 

OBJECT : Shapes.SYMBOL_TYPE; 

COLOR : COLOR_TYPE; 

end record; 


-- previous position object held 
- - new position 
-- list of relative offsets 
-- color for that object 


type MOVE_LIST_TYPE is array (Types.WORDJNDEX range <>) of M0VE_REC0RD; 
type PRIORITY_TYPE is (HIGH, LOW); 


QUEUE_ERROR : exception; 


if queue over/underflow 


task type Display_Type is 

entry Print_Titles(X,Y : Types.WORD; 

TITLE ; STRING; 

COLOR : COLORTYPE); 

entry Hove(PRIORITY : PRIORITY_TYPE; W0RK_LIST : M0VEJ.1ST_TYPE); 
pragma PRIORITY(Config.display jariority); 
end Display_Type; 

for Display_Type'STORAGE_SIZE use INTEGER(Config.bytes_per_storage_unit * 

stack_size); 

Display : Oisplay_Type; 

end Graphics; 


- 70 - 





Distributed Issues Final Report 


--% UNIT: Graphics Package Body 

--% Effects: Performs all updates to graphics display. 

--% Modifies: No global data is modified. 

--% Requires: A method of access to the EGA BIOS calls. 

--X Raises: QUEUE_ERROR is raised if no room for move list. 
--% Engineer: T. Griest / M. Sperry. 


-| PACKAGE BOOT : Graphics 

-I 

-| The purpose of the graphics package body is the implementation of the 
-| display task. 


--| TASK BODY : Graphics.Display 

--| The display task is responsible for buffering the various tasks that want 
--| to draw their particular symbol on the screen. The task begins by placing 
--| the screen (via BIOS calls) into high resolution mode lOh. When this 
--| is done, the screen will be in write mode 0 - the BIOS default. In this 
--| mode it is possible to print characters easily by calling the appropriate 
--| BIOS routine. After the statistics have been printed, a change to write 
--) mode 2 is accomplished. This mode permits quick drawing of pixels in the 
•*| color needed, and the battlefield border is drawn this way. The rest of 
--| the graphics are also done in this mode. The display task then waits 
--| for a work request to draw a symbol. When a request comes in, it is put 
--| on a prioritized queue. The queue used is a function of the callers' 

*-| priority. Now, since there is work to do, the task processes one symbol 
--| at a time, checks to see if other tasks are waiting to queue any requests, 
--| and continues processing until no requests are left in any of the queues. 
-*| When a request is processed, it's old position is erased, and it's new 
--| position is drawn. No attempt is made to synchronize with the vertical 
--| retrace since it would slow down the task too much. The penalty associated 
**| with this is a slight flicker of some of the images (especially when the 
--| reticle is being slowly dragged across the screen). When checking if there 
--| is more work to do, using 'count instead of a select statement was used 
-*| because the code generated for 'count was significantly smaller. 


-- Modifications Log 

-- 88-08-25 : MPS => Original Created 


with Machine_Dependent; 
with Interrupt_Control; 
with Debug_IO; 
with Time_Stamp; 

pragma ELABORATE(Machine_Oeper»dent, Interrupt_Control, Debug_IO, T ime_Stamp); 


- 71 - 








Distributed Issues Final Report 


package body Graphics is 


task body Oisplay_Type is 





use Types; 




-- needed for visibility 

to ,, +" operator 

buffer_size : 

constant 

: = 

256; 



initialize_screen : 

constant 

: = 

0; 

-- for Int 10 BIOS call, 

fnctn 0 

dummy_1 : 

constant 

: = 

0; 

-- dummy parameter 


durmr/_2 : 

constant 

: = 

0; 

-- dummy parameter 


position_cursor : 

constant 

: = 

2; 

-- position function is 

int 10, fnct 2 

write : 

constant 

: = 

U; 

-- write char is int 10, 

fnct 16#0E# 


type CIRCULAR_BUFFER is array(Types.WORD_INDEX range 0 .. buffer_size - 1) of 

MOVE_RECORD; 


type BUFFER_TYPE is record 
ON : Types.UORD_INDEX := 0; 

OFF : Types.UOROJNDEX := 0; 
DATA : CIRCULAR_BUF FER; 
end record; 


SET_PRIORITY 

BUFFER 

NOWORK 

UORK_REQUEST 

OBJECT 

TEXT_HOOE 

CHAR 

COUNTER 


PRIORITY_TYPE := PRI0R1TY_TYPE'FIRST; 

array(PR10RITY_TYPE<FIRST..PRI0R1TY_TYPE'IAST) of BUFFER_TYPE; 
BOOLEAN; -- all queues empty? 

MOVE_RECORD; -- for individual processing 

Shapes.OBJECT_PTR; -- current object to move 

BOOLEAN; -- printing stats titles? 

Types.WORD; -- temp for holding string slices 

Types.WORD; -- index into TITLE string 


set up queues 


procedure Erase_Image(BASE : Shapes.PIXEL; 

ITEM : Shapes.0BJECT_PTR) is 


--| SUBPROGRAM BODY : Graphics.Display.Erase_Image 

-*| A procedure designed to calculate absolute coordinates for the routine 
--| Machine_Dependant.Put_Pixel given a shape(OBJECT_PTR) and an absolute 
-*| reference point where the object is to be placed. No color is specified 
--| because the intent of this procedure is to erase, which is actually 
-*| drawing over the old image in the background color. 

begin 

Time_Stamp.Log{0020); --STPC0020) Graphics.Erase_I mage start 
for I in ITEM.all'range loop 

Machine_0ependent.Put_Pixel(8ASE.X ♦ ITEM.all(I).X_OFFSET, 

BASE.Y ♦ ITEM.all(I).Y_OFFSET, 
background_color); 

end loop; 


- 72 - 











Distributed Issues Final Report 


Time_Stamp.Log(0021); --$TP(0021) Graphics.Erase_Image end 

end Erase_Image; 
pragma INLINE(ERASEJMAGE); 


procedure Oraw_Image(BASE : Shapes.PIXEL; 

ITEM : Shapes.OBJECT_PTR; 
COLOR ; COLOR TYPE) is 


--| SUBPROGRAM BOOT : Graphics.Display.Draw_Image 

-I 

-*| This procedure is functionally the same as Erase_Image except that a 
•*| color is passed to it so that the object can be drawn in that color. 


begin 

Time_Stamp.Log(0022); --$TP(0022) Graphics.Draw_Image start 

for I in ITEM.all'range loop 

Machine_Dependent.Put_Pixel(BASE.X ♦ ITEM.all<I).X_OFFSET, 

BASE.Y + ITEM.all<I).Y_0FFSET, 
COLOR); 

end loop; 

Time_Stamp.Log(0023); -*$TP<0023) Graphics.Draw_Image end 

end Orawlmage; 
pragma 1NLINE(DRAW_IMAGE); 


procedure Initialize_Border is 


SUBPROGRAM BODY : Graphics.!)isplay.Initialize_Border 

--| A procedure which utilizes the Shapes package to place a color border 
--| around the screen thus defining the battlefield area. The reticle never 
-*| leaves the battlefield area and statistics are never displayed inside 
--I the battlefield area. 


BORDER : MOVE_RECORD; 
begin 

BORDER.OBJECT := Shapes.DOT; 

OBJECT := Shapes.OBJECT_PTR_TABLE(BORDER.OBJECT); 

BORDER.COLOR := border_color; 

-- draw top and bottom border 

for I in Config.border_left..Config.border_right loop 
BORDER.XY_NEU := (Types.COORD I NATE!I),Config.border_top); 
Oraw_Image(BORDER.XY_NEU,OBJECT,BORDER.COLOR); 


- 73 - 








Distributed Issues Final Report 


BORDER.XYJiEW := (Types.COORDlNATE(l),Config.border_bottom); 

Draw_Image(BORDER.XY_NEW,OBJECT,80RDER.COLOR >; 
end loop; 

-- draw left side and right side border 

for J in Config.border_top..Config.border_bottom loop 

BORDER.XY_NEU := (Config.border_left,Types.COORDINATE(J)); 
Draw_Image(BORDER.XY_NEW,OBJECT,BORDER.COLOR); 

BORDER.XYJJEU := (Config.border_right,Types.COORD I NATE C J > >; 
Draw_lmage(BORDER.XYJIEW,OBJECT,BORDER.COLOR); 
end loop; 
exception 

when others => Debug JO.Put JineC'Except ion raised in Graphics.Initialize 11 ); 
end lnitializeJJorder; 


procedure Enqueue(PRIORITY : PRIORITY_TYPE; HOVE_REQUEST : MOVE_RECORD) is 


SUBPROGRAM BOOY : Graphics.Display.Enqueue 

A procedure which enqueues a MOVERECORD (a record containing all the 
information needed to draw a symbol) onto the proper priority queue for 
later processing. May raise QUEU£_ERROR. 


ONJJEW : Types.UORDJNDEX; 
begin 

Time_Stamp.Log(0024); --$TP(0024) Graphics.Enqueue start 

ON_NEU := (BUFFER(PRIORITY).ON + 1) rem bufferjize; 
if ON_NEW = BUFFER(PRIORITY).OFF then 
raise QUEUE_ERROR; 
end if; 

Interrupt_Control.Disable; -- compiler bug 

BUFFER(PRIORITY).DATA(ON_NEW) := MOVE_REQUEST; 
Interrupt_Control.Enable; 

BUFFER(PRIORITY).ON := ON_NEW; 

Time_Stamp.Log(0025); -*$TP(0025) Graphics.Enqueue end 

end Enqueue; 
pragma INLINE(Enqueue); 


procedure Dequeue(PRIORITY : PRIORITY_TYPE; MOVt_REC'JEST : out MOVE_RECORD) is 


--| SUBPROGRAM BOOY : Graphics.Display.Dequeue 

--I 

--| A procedure which is given the priority of the queue it needs to access 
-*| in order to pop the MOVE_RECORD (a record containing drawing information) 


- 74 - 










Distributed Issues Final Report 


--| off that queue. If there are no items on that queue, QUEUE_ERROR is raised. 


OFF_NEW : Types.WORDJNDEX; 
begin 

Time_Stamp.Log(0026); --STP{0026) Graphics.Dequeue start 

if BUFFERfPRIORITY).OFF = BUFFER(PRIORITY).ON then 
raise QUEUE_ERROR; 
end if; 

OFFJIEW := (BUFFER(PRIORITY).OFF + 1) rem buffer_size; 
Interrupt_Control.Disable; -- compiler bug 

MOVE_REQUEST := BUFFER(PRIORITY),DATA(OFF_NEW); 
Interrupt_Control.Enable; 

BUFFER(PRIORITY).OFF := OFF_NEW; 

Time_Stamp.Log(0027); --$TP(0027) Graphics.Dequeue end 

end Dequeue; 
pragma INLINE(Dequeue); 


- Body of DISPLAY TASK 


begin 

NO_WORK := TRUE; 

TEXT_MOOE := TRUE; 

Machine_Dependent.Int10<initialize_screen, 

dLnmy_1, -- dummy variables are unused 

dummy_2); -- hi-res graphics mode 

Machine_Dependent.write_Mode_0; 
while TEXT_MOOE loop 

accept Print_Titles(X,Y : Types.WORD; 

TITLE : STRING; 

COLOR : COLOR_TYPE) do 
if TITLE'length > 0 then 
Machi f ie_Oependent.Int10(position_cursor, X, Y); 

COUNTER := 1; 

while COUNTER <= TITLE'length loop 

CHAR := Types.WORD(CHARACTER'pos(TITLE(INTEGER(COUNTER)))); 
Machine_Dependent.Int10(write, 

CHAR, 

COLOR); 

COUNTER := COUNTER ♦ 1; 
end loop; 
else 

TEXT_MOOE := FALSE; 
end if; 

end Print_Tities; 
end loop; 

Machine_Oependent.write_Mode_2; -- go to write mode 2 

Initialize_Border; -- draw battlefield border 


- 75 - 






Distributed Issues Final Report 


loop 

begin -- exception block 

Time_Stamp.Log(0028); --$TP(0028) Graphics task start 
if NO_WORK or Move'COUNT > 0 then 
Time_Stamp.log(0112); - -STP<0112) Graphics accept Move start 
accept Move(PRIORl T Y : PRIORITY_TYPE; WORK_LIST : MOVE_LIST_TYPE) do 
for I in WORK_LIST'range loop 
EnqueuetPRIORITY, UORK_LIST(I)); 
end loop; 
end Move; 

Time_Stamp.Log(0113); --$TP(0113) Graphics accept Move end 
NO_WORK := FALSE; 
end if; 

Now there is some work to do, see if any left on highest priority 

SET_PRIORITY := PR I OR ITY_TYPE'FIRST; 
loop 

if BUFFERCSETPR IORITY).ON /= BUFFER(SET_PRI0R1TY).OFF then 
Dequeue(SET_PRIORITY,UORK_RE9UEST); -- at this point, requests real 
OBJECT := Shapes.OBJECT_PTR_TABLE(WORK_REQUEST.OBJECT); 
Erase_Image(WORK_REQUEST.XY_OLO, OBJECT); 

Draw_Image (WORK REQUEST .XY_RcW, OBJECT, WORIC_REQUEST .COLOR); 

NO_UORK := FALSE; 

exit; •• leave loop if we processed a request 

else 

NOUORK := TRUE; -- default 

exit when SET_PRIORITY = PRIORITY_TYPE'LAST; 

SET_PRIGRITY := PRIORITYTYPE'SUCC(SETPRIORtTY); 
end if; 
end loop; 

exception 

when OUEUE_ERROR => null; -• since error is propagated to calicr 

when others => 

0ebug_I0.Put_Line("Error in Display Task"); 

end; -- exception block 

Time_Stamp.Log(0029); -*$TP(0029) Graphics task end 

end loop; 
end Display_Type; 


end Graphics; 


- 76 - 







Distributed Issues Final Report 


--% UNIT: 

--% Effects: 
--% Modifies: 
--% Requires: 
--% Raises: 
Engineer: 


Grid_to_Pixel Function Spec. 

Converts battlefield meters X-Y to graphics Pixel 
No global data is modified. 

No initialization is required. 

No explicitly raised exceptions are propagated. 

T. Griest. 


X-Y. 


--| SUBPROGRAM SPEC : Grid_To_Pixel 

--| This function provides a translation to go from the "real* 1 battlefield 
--| to the screen battlefield. Note that the screen battlefield has the Y 
--| component at 0 at the top of the screen and increasing positively down 
--| the screen. A diagram in hwconfig.as shows the complete screen. 

-- Modifications Log 

-- 88-U9-26 : TEG => Original created. 


with Shapes; 
with Types; 

function Grid_to_Pixel(GRID : in Types.POSITION_TYPE) return Shapes.Pixel; 
pragma INLINE(Grid_to_Pixel); 


- 77 - 













Distributed Issues Final Repoit 


--XUNIT: Grid_to_Pixel Function Spec. 

--X Effects: Converts battlefield meters X-Y to graphics Pixel 
--X Modifies: No global data is modified. 

--X Requires: No initialization is required. 

Raises: No explicitly raised exceptions are propagated. 

--X Engineer: T. Griest. 


X-Y. 


--| SUBPROGRAM BOOY : Grid_To_Pixel 

--| Translate from Battlefield Grid coordinates in meters to pixels 
--| on the screen. This means applying scale factors for x/y and 
--| providing offsets to battlefield area on screen. NOTE: since 
--| battlefield coordinates have 0,0 in lower left; and graphics 
--| coordinates have 0,0 in upper left, this involves a transpose of 
--I the Y axis (thus the 


-- Modifications Log 

-- 88-10-20 : TEG => Original created. 

-- 89-01-04 : MPS => Changed Time_Stamp to properly time the routine. 


with Config; 
with Time_Stamp; 
with Math; 

pragma ELABORATE(Time_Stamp, Math); 

function Grid_to_Pixel(GRID : in Types.POSITION_TYPE) return Shapes.Pixel is 
use Types; 
use Math; 

TEMP : Types.LONGFIXED; 

PIX : Shapes.PIXEL; 
begin 

Time_Stamp.Log(0030); --$TP(0030) Grid_To_Pixel start 

TEMP := GRI0.X / Types.LONG_FIXED(Config.meters_per_x_pixel); 

PIX.X := Config.battlefield_screen_left + Types.COORDINATE(TEMP); 

TEMP := GRIO.Y / Types.LONG_F[XED(Conf>^.meters_per_y_pixel); 
h i i := Conf ig.battlef ielc'_sr.reen_left + Types.COORDINATE(TEMP); 
Time_Stamp.Log(0031); --$TP(0031) Grid_To_Pixel end 

return PIX; 
end Grid_to_Pi*ei; 


- 78 - 









Distributed Issues Final Report 


••% UNIT: Guidance Task Subunit 

■■X Effects: Calls "Guide" to compute next rocket aimpoint for every 
--X active rocket in the input list. 

--X Modifies: No global data is modified. 

--% Requires: No initialization is required. 

-•X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: T. Griest. 


--| TASK BOOT : Rocket.Guidance 
”1 

--| Task Guidance is used as a template for an array of tasks which compute 
-*| guidance information for a specified number of rockets. The first thing 
-*| it does is it gets the history information for the rocket/target list 
--| and makes a local copy. The index of the history array (containing previous 
--| positions and which rockets were previously active) is ROCKET_ID. The 
--| entire guide_list array is passed, even though many of the entries may be 
--| inactive. Only active rockets (those that are in the air or taking off) 

--| are given guidance. The entire array however is again passed back to the 
--| caller, the rocket control task. 


Modifications Log 

88- 10-12 : TEG => Original created. 

89- 11-22 : MPS => Adjusted to work with new Guide procedure. 


with Guide; 

with Time_Stamp; 

with Interrupt_Control; 

pragma ELABORATE(Guide, Time_Stamp, Interrupt_Control); 
separate(Rocket) 


task body Guidance_Type is 


use Types; 
NEXT_GUIDE_LIST 
NEXT_HISTORY_LI ST 
FIRST_ROCKET_IO 
LAST ROCKET 10 


-- for operator visibility 
AIMPOINT_LIST_TYPE(1..Config.max_rockets); 
P0SITI0N_LIST_TYPE(1..Config.max_rockets); 
Types. WORDJNOEX; 

Types. UORDJNOEX; 


begin 

loop 

begin 

Time_Stanp.Log(0032); 

Time_Stamp.Log(0033); 
accept History(AIM_OATA 


- main processing loop 
-- exception block 
--tTP(0032) Guidance task start 
--$TP(0033) Guidance accept History start 
: in POSITION LIST TYPE) do 


- 79 - 










Distributed Issues Final Report 


FlRST_ROCKET_ID := AIM_DATA'first; 

LAST_R0CKET_1D := A1M_DATA'last; 

lnterrupt_Control.Disable; --BUGFIX for compiler bug (direction flag) 
NEXT_HISTORY_L1 ST(FIRST_ROCKET_ID..LAST_ROCKET_ID) := AIM_DAT A; 
Interrupt_Control.Enable; --BUGFIX for compiler bug 
end History; 

Time_Stamp.Log(0034); --$TP(0034) Guidance accept History end 

process list to create guidance information 

for ROCKET JD in F IRST_ROCKET_ID.. LAST_ROCKET_ID loop 
if NEXT_HISTORY_LIST(ROCKET_IO).ACTIVE then 
Guide(ROCKET_ID,NEXT_HiSTORY_lIST(ROCKET_ID).ROCKET_POS, 

NEXT_HISTORYJ. IST(ROCKET_ID).TARGET_POS, 

NEXT_GUIDE_LIST(ROCKET_ID)); 

end if; 
end loop; 


Time_Stamp.Log(0035); --$TP(0035) Guidance accept Next_Guidance start 
accept Next_Guidance(AIMPOINT_LIST : out AIMPOINT_LIST_TYPE) do 

if AIHPOINT_LIST'first /= FIRST_ROCKET_ID or -- make sure list hasn't 
AIMPOINT_LIST'last /= LAST_ROCKET_ID -- changed from History 

then 

raise GUIDANCE_LIST_ERROR; 
else 

Interrupt_Control.Disable; --BUGFIX for compiler bug (direction flag) 

AIMPOINT_LIST := NEXT_GUI0E_LI ST(FIRST_ROCKET_ID..LAST_ROCKET_ID); 

Interrupt_Control.Enable; --BUGFIX for compiler bug (direction flag) 
end if; 

end Next_Guidance; 

Time_Stamp.Log(0036); --$TP(0036) Guidance accept Next_Guidance end 


exception 

when others => 

Oebug_IO.Put_line("Error in GUIDANCE TASK"); 


end; 

Time_Stamp.Log(0037); 
end loop; 

end Guidance_Type; 


-- exception block 
-$TP(0037) Guidance task end 
-- main processing loop 


- 80 - 




Distributed Issues Final Report 


--X UNIT: Guide Function Spec. 

--X Effects: Computes a new aimpoint based on rocket/target positions. -- 
--% Modifies: No global data is modified. 

--X Requires: No initialization is required. 

--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: T. Griest. 


--| SUBPROGRAM SPEC : Guide 

--| The Guide function is used to find an aimpoint for the rocket to fly at 
-*| when it is in flight. This includes guidance for the rocket during it's 
--| launch phase. It takes as parameters the rocket_index, the latest positions 
--| of both the rocket and target and returns two Binary Angle Measuements, 

--| one Azimuth and one Elevation per cal . 


-- Modifications Log 

-- 88-12-05 : TEG => Original created. 

-- 89-11-07 : TEG => Changed from a function to a procedure call. 


with Types; 


procedure Guide(ROCICET_ID 
ROCKET_POS 
TARGET_POS 
NEW AIMPOINT 


Types .ROCKETJ NOEXTYPE ; 
Types.POSITIONTYPE; 
Types.POSITION_TYPE; 
out Types.AIMPOINT_TYPE); 


pragma INLINE(Guide); 


- 81 - 









Distributed Issues Final Report 


--X UNIT: Guide Function Body. 

--X Effects: Computes a new aimpoint based on rocket/target positions. -- 
--X Modifies: Aim_Data Rocket Info is modified. 

--X Requires: No initialization is required. 

--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: T. Griest. 


--| SUBPROGRAM BOOY : Guide 

--| The Guide function takes the most recent two postions of a rocket/target 
--| pair, and computes an aimpoint for the rocket to intercept. 

--| Because the target is assumed to be moving, a process which 
--| extrapolates the target's position forward is used. However, this section 
--| is only called upon when the rocket is close to the target (T1ME_T0_TARGET). 
--| The basic theory of operation is to control the rocket attitude by changing 
-| the previous aimpoint incrementally according to the amount of change 
--I desired in the acceleration from the last interval. 


- Modifications Log 

- 88-11-09 : TEG => Original created. 

- 89-11-14 : TEG => Equations were improved upon to be more realistic. 


with Config; 

with Types; 

with Math; 

with Rocket; 

with A ; m_0ata; 

with Aimpoint; -- function 

pragma ELA80RATE(Math,Aimpoint); 


procedure Guide(ROCKET_ID 
ROCKET_POS 
TARGET_P0S 
NEW AIMPOINT 


Types .ROCKET_l NDEX_TYPE ; 
Types.POSIT!ON_TYPE; 

Types.POSITION_TYPE; 

out Types.AIMPOINT_TYPE) is 


use Types; 
use Aim_Data; 
use Math; 


-- for operators 

-- for enumeration types AXIS (x,y,z) 


accuracy 

height_factor 

integration_interval 

i ntegrat i on_i nt_sq 

furthest_extrapolate 

max_change 


speedy fixed 

point 

math 

constant 

: = 

1.0; • 

- resolution on TIME_TO_TARGET 

constant 

: = 

6; 

-- boost done when z >= 1/6 (dist x_y) 

constant 


4.0; ■ 

•- periods to integration acceleration 

constant 

: = 

(integration_interval-1.0) ** 2; 

constant 

: = 

300.0; 

-- don't bother going beyond 

constant 

: = 

3.0; 

■■ maximum change to acceleration 


- 82 - 










Distributed Issues Final Report 


limit_rock_extrap : constant Types.LONG_FIXED := Types.LONG_FIXED( 

(Config.meters_in_battle_area + Types.LONG_F1XED(1000.0))) 


R0CKET_VEL0C_1 

ROCKE T_VE LOC_2 

TARGET_VEL0C_1 

ROCKET_ACCEl 

ROCK_TARG_DELTA 

800STJ.IMIT 

ROCK_TARG_DSQ_X 

ROCK_TARG_DSQ_Y 

ROCK_TARG_DSQ_Z 

ROCK_TARG_DlST 

ROCK_TARG_XY_DI ST 

ROCK_SQ_X 

ROCK_SQ_Y 

ROCK_SQ_Z 

ROCK_VELOC_VECT 

ROCK_XY_VELOC_VECT 

TIME_TO_TARGET 

EXTRAP_TARG 

EXTRAP_ROCK 

DESIRED_VELOC 

DESIRED_ACCEL 

CHANGE_ACCEL 

SUH 

SUM_VELOCITY 
AZIMUTH 
ELEVATION 
INTEGRATION_PER100 
INTEGRATION_SQ 
begin 


Aim_Data.RATE_REC_TYPE; 

Aim_0ata.RATE_REC_TYPE; 

Aim_Data.RATE_REC_TYPE; 

Aim_Data.RATE_REC_TYPE; 

T ypes.POSIT10N_T YPE; 

Types.LONG_FIXED; 

Types.LONG_FIXEO; 

T ypes.L0NG_F!XED; 
Types.LONG_FIXEO; 

T ypes.L0NG_FIXED; 

T ypes.L0NG_FIXED; 

Types.RATE_T YPE; 

Types.RATE_TYPE; 

Types.RATE_TYPE; 

T ypes.RATE_TYPE; 

Types.RATE_TYPE; 

T ypes.LONG_FIXED; 

Types.POSITIONTYPE; 
Types.POSITION_TYPE; 

Aim_0ata.RATE_REC_TYPE; 
Aim_Data.RATE_REC_TYPE; 
A imData. RATE_REC_TYPE ; 
Types.LONG_FIXEO; 

T ypes.L0NG_FIXED; 

Types.BAM; 

Types.BAM; 

Types.LONG_FIXED; 

Types.LONG_FIXED; 


-- If a new launch is taking place, initialize the Aim_Data data base. 


if R0CKET_P0S.Y = Config.Iaunch_y and R0CKET_P0S.X = Config.launch_x then 
Aim_Data.ROCKET_INFO(ROCKET_ID).LAST_TARG := TARGET_POS; 
Aim_Data.ROCKET_INFO(ROCKET_ID).CURR_TARG := TARGET_POS; 
Aim_Data.ROCKET_INFO , ROCXET_ID).PREV_ROCK := R0CKET_P0S; 
Aim_Data.ROCKET_INFO(ROCKET_ID).LAST_ROCK := R0CKET_P0S; 
Aim_Oata.ROCKET_INFO(ROCKET_ID).CURR_ROCK := R0CKET_P0S; 
Aim_Data.ROCKET_INFO(ROCKET_ID).0LD_AIMP0INT := 

(Config.Iaunch_elevation,Config.Iaunch_ezimuth); 
Aim_Data.ROCKET_INFO(ROCXET_ID).BOOST_PHASE := TRUE; 
end if; 

-- First update history of data. 

Ai«_Deta.ROCKETJNFO<ROCKET_ID).lAST_TARG : = 

Aim_Oata.ROCKET_INFO(ROCkET_ID).CURR_TARG; 
Ai«i_Data.ROCKET_INFO(ROCKETJO).CURR_TARG := TARGET_POS; 


- 83 - 









Distributed Issues Final Report 


Aim_Oata.ROCKET_INFO(ROCKET_ID).PREV_ROCK := 

Aim_Data.ROCKET_INFO(ROCKETJD).LAST_ROCK; 
Aim_Data.ROCKET_INFO(ROCKET_lD).LAST_ROCK : = 

Aim_Data.ROCKET_INFO(ROCKET_ID).CURR_ROCK; 
Aim_Data.ROCKET_INFO(ROCKET_IO).CURR_ROCK := ROCKET_POS; 

- First check Target's Y coordinate to avoid friendly fire. 

- IF ROCKET IS GOING OVER TARGET, SIMPLY SET AIMPOINT STRAIGHT DOWN. 

if TARGET_POS.Y < ROCKET_POS.Y then 
Aim_Data.ROCKET_INFO(ROCKET_ID).OLD_AIMPOINT := (ELEVATION => -16384, 

AZIMUTH => Aim_Data.ROCKETJNFO(ROCKET_IO).OLD_AIMPO!NT.AZIMUTH); 
NEU_AIMPOINT := Aim_Oata.ROCKETJNFO(ROCKET_lD).OLD_A!MPOINT; 
return; 
end if; 

- Compute Rocket Velocity in all three axes. 

ROCKET_VELOC_1.X := Types.RATE_TYPE(ROCKET_POS.X - 

Aim_Oata.ROCKET_lNFO(ROCKET_ID).LAST_ROCK.X); -- rocket change X 
ROCKET_VELOC_1.Y := Types.RATE_TYPE(ROCKET_POS.Y - 

AimJ)ata.ROCKETJNFO(ROCKETJD).LAST_ROCK.Y>; -- rocket change Y 
ROCKETVELOCJ.Z := Types.RATE_TYPE(ROCKET_POS.Z - 

Aim_Data.ROCKET_INFO(ROCKET_lD).LAST_ROCK.Z); -- rocket change Z 

ROCKET_VELOC_2.X := Types.RATE_TYPE( 

Aim_Data.ROCKET_INFO(ROCKETJD).LAST_ROCK.X - 

Aim_Data.ROCKET_INFO<ROCKET_lD).PREV_ROCK.X); -- rocket change X 
ROCKET_VELOC_2.Y := Types.RATE_TYPE( 

Aim_Data.ROCKET_INFO(ROCKET_IO),LAST_ROCK.Y - 

Aim_Data.ROCKET_INFO(ROCKET_ID).PREV_ROCK.Y); -- rocket change Y 
ROCKET_VELOC_2.Z := Types.RATE_TYPE( 

Aim_Data.ROCKET_INFO(ROCKET_ID).LAST_ROCK.Z - 

Aim_Data.ROCKE'_INFO(ROCKET_ID).PREV_ROCK.Z); -- rocket change Z 

- Compute Target Velocity in all three axes. 

TARGET_VELOC_1.X := Types.RATE_TYPE(TARGET_POS.X - 

Aim_Data.ROCKET_INFO(ROCKET_ID).LAST_TARG.X); -- target change X 
TARGET_VELOC_1.Y := Types.RATE_TYPE(TARGET_POS.Y - 

Aim_Data.ROCKET_INFO(ROCKET_IO).LAST_TARG.Y); -- target change Y 
TARGET_VELOCJ.Z := Types.RATE_TYPE(TARGET_POS.Z - 

AimJ)ata.ROCKETJNFO<ROCKETJD).LAST_TARG.Z); -- target change Z 

- Compute Acceleration for Rocket in all three axes. 

ROCKET ACCEL.X := ROCKET_VELOC_1.X - ROCKET_VELOC_2.X; 

ROCKET_ACCEL.Y := ROCKET_VELOC_1.Y - ROCKET_VEL0C_2.Y; 

ROCKET_ACCEL.Z := R0CKET_VEL0C_1.Z - ROCKET_VELOC_2.Z; 

- Compute velocity vector *ur rocket using the formula 


- 84 - 





Distributed Issues Final Report 


v = sqrt(curr_rock.X**2 + curr_rock.y**2 + curr_rock.z**2) 


ROCK_SQ_X := R0CKET_VEL0C_1.X * R0CKET_VEL0C_1-X; 

ROCK_SQ_Y := R0CKET_VEL0C_1.Y * R0CKET_VEL0C_1.Y; 

ROCK_SQ_Z := R0CKET_VEL0C_1.Z * R0CKET_VE10C_1.Z; 

SUMVELOCITY := Types.LONG_FIXED(ROCk_SQ_X) + Types.LONG_FIXED(ROCK_SQ_Y>; 
ROCK_XY_VELOC_VECT := Types.RATE_TYPE(Math.Sqrt(SUH_VELOCITY)); 
ROCK_VELOC_VECT := Types.RATE_TYPE<Math.Sqrt(SUM_VELOCITY + 

Types.LONG_FIXED <ROCK_SO_Z))); 

- Compute distance between rocket and target using the formula 

d = sqrt(d(X)**2 + d.Y**2 + d.Z**2) 
where d(i) = curr_rock(i) - curr_targ(i) 

ROCK_TARG_DELTA.X := TARGETPOS.X - ROCKETPOS.X; 

ROCK_TARG_DELTA.Y := TARGET_POS.Y - ROCKETPOS.Y; 

ROCK_TARG_DELTA.Z := TARGET_POS.Z - ROCKET_POS.Z; 

ROCK_TARG_DSQ_X := ROCK_TARG_DELTA.X * ROCK_TARG_DELTA.X; 

ROCX_TARG_DSO_Y := ROCK_TARG_DELTA.Y * ROCK_TARG_DELTA.Y; 

ROCK_TARG_DSO_Z := ROCk TARG DELTA.Z * ROCK_TARG_DELTA.Z; 

SUH := ROCK_TARG_DSQ_X + ROCK_TARG_D'5_Y + ROCK_TARG_DSQ_Z; 

ROCK_TARG_DIST := Math.Sqrt(SUM); 

- Compute rocket time to target, ITERATION TAKES INTO ACCOUNT 

- changes in rocket velocity and target motion (NOTE: change in 

- rocket acceleration is NOT included) 

if ROCK_VELOC_VECT > 0.01 then 
TIME_TO_TARGET := ROCK_TARG_OIST / R0CK_VE10C_VECT; 

- Extrapolate target position based on TIME_TO_TARGET. 

- Since TIME_TO_TARGET does not take into account rocket acceleration, 

- it tends to be way off during low rocket velocities. To reduce the 

- effect of this, limit the extrapolation to a reasonable period. 

if TIME_TO_TARGET > furthest_extrapolate then 
TIHE_TO_TARGET := furthest_extrepolate; 
end if; 

EXTRAP_TAPG.X := TARGET_POS.X ♦ 1 ARGET_VEL0C_1.X * TIME_TO_TARGET; 
EXTRAP_TARG.Y := TARGET_POS.Y ♦ TARGET_VELOC_1-Y * T!ME_T0_TARGET; 


-- prevent from extrapolating the target behind the rocket 


if EXTRAPTARG.Y < R0CKET_P0S.Y then 
EXTRAP_TARG.Y := R0CKET_P0S.Y; 
end if; 

EXTRAP_TARG.Z := TARGET_P0S.Z + TARGET_VE10C_1.Z * TIME_TO_TARGET; 


- 85 - 










Distributed Issues Final Report 


else 

TIME_TO_TARGET := 
EXTRAP_TARG.X := 
EXTRAP_TARG.Y := 
EXTRAP_TARG.Z := 
end if; 


integration_interval + 1.0; 
TARGET_POS.X; 

TARGET_POS.Y; 

TARGET_POS.Z; 


if TIME_TO_TARGET < integration_interval then 

INTEGRATI0N_PERI00 := TIME_T0_TARGET / Types.UORD(2); 
if INTEGRATI0N_PERI00 < 1.0 then 
INTEGRATI0N_PERI00 := 1.0; 
end if; 

INTEGRATION_SQ := (INTEGRATION_PER100-1.0) * (INTEGRATI0N_PERI00-1.0); 
else 

INTEGRATION_PERIOO := integration_interval; 

INTEGRATI0N_SQ := integration_int_sq; 
end if; 


- Compute where the ROCKET will be at the end of the INTEGRATION period. 

- All velocities will be calculated for that point to target. Limit the 

- extrapolations to reasonable values. 

FXTRAP_ROCK.X := R0CKET_P0».X + R0CKET_VEL0C_1.X * (INTEGRATI0N_PER100-1.0) + 
(ROCKET_ACCEL.X / Types.UORO(2)) * INTEGRATI0N_SQ; 
if EXTRAP_ROCK.X > limit_rock_extrap then 
EXTRAP_ROCK.X := limit_rock_excrap; 
end if; 

EXTRAPROCK.Y := R0CKET_P0S.Y + R0CKET_VE10C_1.Y * (INTEGRATI0N_PERI00-1.0) + 
(ROCKETACCEl.X / Types.W0RD(2)) * INTEGRATI0N_SQ; 
if EXTRAP_R0CK.Y limit_rock_extrap then 
EXTRAPROCK.Y := limit_rock_extrap; 
end if; 

EXTRAP_ROCK.Z := ROCKET_POS.Z + R0CKET_VEL0C_1.Z * (INTEGRAT!0N_PERI00-1.0) + 
(ROCKET_ACCEL.X / Types.UORD(2)) * INTEGRATI0N_S0; 
if EXTRAP_ROCK.Z > limit_rock_extrap then 
EXTRAP_R0CK.Z := limit_rock_extrap; 
end if; 


ROCK_TARG_DELTA.X := EXTRAP_TARG.X - EXTRAP_ROCK.X; 
RoCK_TARG_DELTA.Y := EXTKAP_TARG.Y - EXTRAP_ROCK.Y; 
ROCK_TARG_DELTA.Z := EXTRAP_TARG.Z - EXTRAP_ROCK.Z; 

R0CK_TARG_DS0_X := ROCK_TARG_0ELTA.X * ROCK_TARG_0ELTA.X; 
ROCK_TARG_OSO_Y := ROCK_TARG_0ELTA.Y * °OCK_TARG_0ELTA.Y; 
ROCK_TARG_DSQ_Z := ROCK_TARG_OELTA.Z * ROCK_TARG_DELTA.Z; 

SUM := ROCK_TARG_OSO_X + ROCK_TARG_DSQ_Y ♦ ROCK_TARG_OSQ_Z; 
ROCK_TARG_0IST := Math.Sqrt(SUM); 

R0CK_T ARG_XY_01 ST := Math.Sqrt(ROCK_T AR G_0 S0_X ♦ ROCK_TARG_DSQ_Y); 


- 86 - 








Distributed Issues Final Report 


-- Compute Desired Velocities in each axis for the end of INTEGRATION period. 
If distance to target is too small to measure, then don't bother to find a 
new desired velocity or acceleration because the rocket has already hit 
-- the target by now! 

if ROCX_TARG_XY_DI ST /= 0.0 then 
DESIRED_VELOC.X := ROCK_XY_VELOC_VECT * 

(R0CK_TARG_DELTA.X / ROCK_TARG_XY_01ST>; 

DESIRED_VELOC.Y := ROCK_XY_VELOC_VECT * 

(ROCK_TARG_DELTA.Y / ROCK_TARG_XY_D1ST); 
DESIRED_VELOC.Z := ROCK_VELOC_VECT * (ROCK_TARG_DELTA.Z / R0CK_TARG_D1ST); 


-- Compute Desired Accelerations 


DESIRED_ACCEL.X := (DESIRED_VELOC.X - R0CKET_VEL0C_1.X) / INTEGRATION_PERIOO; 

DESIREO_ACCEL.Y := (OESIREDJ/ELOC.Y - R0CKET_VEL0C_1.Y) / INTEGRATI0N_PERI00; 

DESIRED_ACCEL.Z := (DESIRED_VELOC.Z - R0CKET_VE10C_1.Z) / INTEGRATI0N_PER100; 

-- Compare Current Rocket Acceleration to Desired Rocket Acceleration 

-- to produce Change in Acceleration 

end if; 

CHANGE_ACCEl.X := DESIRED_ACCEL.X - ROCKET_ACCEL.X * 

Hath.SIN(Aim_Data.ROCKET_INFO(ROCKET_ID).OLD_A[HPOINT.AZIMUTH); 

-- LIMIT THE CHANGE IN ACCELERATION 

if abs CHANGE_ACCEL.X > max_change then 
if CHANGE_ACCEL.X < 0.0 then 
CHANGE_ACCEL.X := -maxchange; 
else 

CHANGE_ACCEL.X := max_change; 
end if; 
end if; 

CHANGE_ACCEL.Z := DESIRED_ACCEL.Z - ROCKET_ACCEL.Z; 
if abs CHANGE_ACCEL.Z > max_change then 
if CHANGE_ACCEL.Z < 0.0 then 
CHANGE_ACCEL.Z := -max_change; 
else 

CHANGE_ACCEL.Z := max_change; 
end if; 
end if; 

-- Now translate from acceleration change requests to new aimpoint 
Aim_Data.ROCXET_lNFO(ROCKET_!D).OLD_AIMPOINT := 


- 87 - 





Distributed Issues Final Report 


AIMP0IHT(Aim_Data.R0CKET_INF0(R0CKET_ID).0LD_AlMP01NT,CHANGE_ACCEL); 

-- Now check if BOOST PHASE, if so go UP by adjusting ELEVATION. Do not adjust 
-- AZIMUTH because it is already pointing in the correct direction. 

if Aim_Data.ROCKET_INFO(ROCKET_ID).BOOST_PHASE then 
BOOSTJ.IMIT := ROCK_TARG_XY_DI ST / Types.WORO(height_factor); 
if ROCKET_POS.Z > BOOST_LIMIT then 
Aim_Data.ROCKET INFO(ROCKET_ID).BOOST_PHASE := FALSE; 
end if; 

Aim_Data.ROCKET_INFO(ROCKET_ID).OLD_AlMPOINT.ELEVATION := 

Config.Iaunch_elevation; 

end if; -- boost_phase check 

NEW_AIMPOINT := Aim_Data.ROCKET_INFO(ROCKET_ID).OLD_AIMPOINT; 
end Guide; 


- 88 - 






Distributed Issues Final Report 


--X UNIT: Guide_Buf Task Subunit 

Effects: Provides asynchronous comm, between simulator and Control.-- 
-■X Modifies: No global data is modified. 

Requires: No initialization is required. 

--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: T. Griest. 


--| TASK BODY : Simulate.ROL.Guide_Buf 

--| The Guide_Buf task acts as a buffer between the rocket data link 
*-| support task Rock_Sup and the Rocket.Control task which processes 
--| the rocket data. The direction flow is from Rocket.Control to the 
--| Pock_Sup task, even though there are only accept statements here. This is 
-| to ease timing constraints. The purpose of MSGCOUNT is to allow Rockiup 
--| to use previous guidance messages if Rocket.Control is late sending it's 
--| new guidance message. However, it is set to zero at the start so 
--| that before the main procedure gets a chance to run, Rock_Sup will 
--| wait at the accept for at least one current guidance message, the 
--| first one. After the first guidance message is received, because 
-*| timing of the system is derived from Rock_Sup, Rock_Sup no longer will 
-*| need to wait for a new guidance message from Control. This operation 
--| reflects the fact that the rockets will continue to travel through space 
-*| regardless of whether there is guidance for them or not. 


Modifications Log 

88-10-20 : TEG => Original created. 


with 0ebug_10; 
with Time_Stamp; 

separate (Simulate.ROD 

task body Guide_Buf_Type is 

use Types; 

start : constant Types.WORDJNDEX := 1; -- start of arrays 

GUI0E_MSG : Rocket.ROCKET_GUIDE_MSG_TYPE; 

MSG_C0UNT : Types.WORD := 0; -- if a message has been buffered 

begin 
loop 

Time_Stamp.log(0040); --STP(OOAO) Guidebuf task start 
select 

accept Put_Guide(OATA : in Rocket.ROCKET_GUI0E_MSG_TYPE) do 
Time_Stamp.Log(0041); --STP(0041) Guidebuf accept Put_Guide start 

GU10E_MSG.NUM_ROCKETS := DATA.NUM_ROCKFTS; -- copy data 


- 89 - 












Distributed Issues Final Report 


GUID£_MSG.ROCKET_GUlDE_LIST(start..DATA.NUH_ROCKETS) := 

DATA.ROCKET_GUIDE_LIST(start..DATA.NUM_ROCKETS); 
MSG_COUNT := 1; -- onty meaningful that it is > 0 

Time_Stamp.Log(0042); --$TP(0042) Guidebuf accept Put_Guide end 
end Put_Guide; 
or 

when MSG_COUNT > 0 => 

accept Get_Guide(DATA : out Rocket.ROCKET_GUIDE_HSG_TYPE) do 

Time_Stamp.Log(0043); --$TP(0043) Guidebuf accept Get_Guide start 

DATA.NUM_ROCKETS := GlUDE_MSG.NUM_ROCKETS; 
D/-.TA.ROCKET_GUIDE_LIST(start..GUIDE_HSG.NUM_ROCKETS) : = 

GUIDE_MSG.ROCKET_GUIDE_LlST(start..GU1DE_MSG.NUM_R0CKETS); 
MSG_COUNT := 1; -- do keep multiple copies 

Time_Stamp.Log(0044); --$TP(0044) Guidebuf accept Get_Guide end 
end Get_Guide; 
end select; 

Time_Stamp.Log(0045); --$TP(0045) Guidebuf task end 
end loop; 
exception 

when others => 

Debug_IO.Put_Line(‘ , GU!OE_BUF termination due to exception. 11 ); 
end Guide_Buf_Type; 


- 90 - 




Distributed Issues Final Report 


- -X UNIT 
--X Effects 
--X Modifies 
--X Requires 
--X Raises 
--X Engineer 


: Hardware Configuration Spec. 
: None. 

: Nothing. 

: The hardware defined below. 

: No exceptions. 

: M. Sperry. 


--| PACKAGE SPEC : HW_Config 

-*| This package is designed to familiarize the user with the hardware that 
--| the BOS was originally implemented upon. It is implemented on a TANDY 4000 
-*| with an EGA screen, utilizing a Logitech C7 Serial Mouse on serial port COM2 
-*| as a pointing device. The timer chip addresses and values are defined. 

--| Note : Some machine addresses (for the EGA especially) are in the package 
-*| Machine_Oependent. 


- Modifications Log 

- 89-08-08 : MPS => Original created. 

- 89-11-19 : MPS => Added timer chip addresses and constants 


with Types; 
with Low_Level_I0; 


package HW_Config is 


- The following addresses are used for this machine. 


COM2_data 

C0M2_int_enable 

C0M2_int_ident 

C0M2_control 

C0M2_modem_cont rol 

C0M2_status 


constant Low_Level_IO.PORT_ADDRESS 
constant Low_Level_!O.PORT_ADDRESS 
constant Low_Level_IO.PORT_ADDRESS 
constant Low_Level_IO.PORT_ADDRESS 
constant Low_Level_!O.PORT_ADDRESS 
constant Low Level 10.PORT ADDRESS 


16#2F8# 

1642F9# 

16#2FA# 

16#2FB# 

16#2FC# 

1642FD# 


pic_8259 
pic_8259_mr 


: constant Low_Level_IO.PORT_ADDRESS := 16#20#; 
: constant Low_Level_I0.PORT_ADDRESS := 16421#; 


counter_two_addr : constant := 16442#; 
timer_control_addr : constant := 16443#; 













Distributed Issues Final Report 


--X UNIT: Interrupt_Control Package Spec, and Body. 

--X Effects: Provides control over interrupt flags. 

--% Modifies: No global data is modified. 

--X Requires: No initialization is required. 

Raises: No explicitly raised exceptions are propagated. 

--% Engineer: M. Sperry. 


•*| PACKAGE SPEC : lnterrupt_Control 

--| The purpose of the Interrupt_Control package is to provide Ada level 
--| semantics for disabling and enabling interrupts on the 80X86 family of 
•*| processors. Also for clearing the direction flag because of an RTE bug 
-*| which does not always clear it. 


-- Modifications Log 

-- 88-11-20 : MPS => Original created. 


with Machine_Code; 

use Machine_Code; 

pragma ELABORATE(Machine_Code); 

package Interrupt_Control is 

pragma SUPPRESS(Elaboration_Check); 

procedure Disable; 
pragma 1NLINE(Disable); 
procedure Enable; 
pragma INLINE(Enable); 

procedure Clear_Oirection_Flag; 
pragma INLINE(Clear_Oirection_Flag); 

end Interrupt_Control; 


-*| PACKAGE BOOT : Interrupt_Control 

"I 

•*| Interrupt_Control is implemented with machine code statments. The 
--| suppression of the elaboration check is used to make the inlining of 
•*| these machine instructions as short as possible. 


package body Interrupt_Control is 


- 92 - 









Distributed Issues Final Report 


procedure Disable is 
begin 

MACHINEJ NSTRUCT ION' (none, ir,_CLl); 
end Disable; 

procedure Enable is 
begin 

MACH INE_lNSTRUCTI ON' (none.m_STI); 
end Enable; 

procedure Clear_Direction_Flag is 
begin 

MACH INEJ NSTRUCTlON'(none,m_CLD); 
end Clear_Direction_Flag; 

end lnterrupt_Control; 


- 93 - 





Distributed Issues Final Report 


--XUNIT: Machine_Dependent Package Spec. 

--X Effects: Provides machine dependent operations for enhanced speed. -- 
--X Modifies: No global data is modified. 

--X Requires: Graphics mode, and initialization of timer channel two. 

--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: M. Sperry. 


--| PACKAGE SPEC : Machine_Dependent 

--| Package Machine_Dependent contains machine code statements to perform 
--| low level graphics functions, including an interface to the BIOS routines 
**| found on the EGA (for text processing). Note that these instructions 
--| are inlined to enhance speed. 

--| Also implemented are routines which perform fixed point multiplications 
*-| and divisions in machine code for speed enhancements. 

--| And, a procedure which returns the value in the channel two counter. 


-- Modifications Log 

-- 88-11-04 : MPS => Original created. 

-- 89-08-24 : MPS *> Specifications for fixed math routines incorporated. 
-- 89-11-21 : MPS => Next Random created. 


with Machine_Code; 
with Graphics; 
with Types; 
use Machine_Code; 
pragma ELABORATE(Machine_Code); 

package Machine_Dependent is 

start_countdown : constant := 16#82#; 
max_timer_value : constant := 256; 

procedure Put_Pixel(ABS_X, ABS_Y : Types.COORD I NATE; 

COLOR : Graphics.C0L0R_TYPE); 

pragma lNLINE(Put_Pixel); 

procedure Write_Mode_0; 
pragma lNLINE(Urite_Mode_0); 


-- mode 2, channel 2 
-- channel 2 LSB divisor 


-- Provide a mechanism to call ROM located routine to initialize screen 
procedure lnt10(BIOS_FUNCTION : Types.WORD;-- spec to 81 Or. graphics call 


- 94 - 






Distributed Issues Final Report 


PARAM_1 : Types.WORD; 

PARAM2 : Types.WORD); 

pragma 1NTERFACE(ASM86, IntIO); 

pragma 1NTERFACE_SPELLING<IntIO, "0181OS7GRAPHICSCALL"); 

procedure Urite_Mode_2; 
pragma INLINE(Write_Mode_2); 

procedure Long_Long_Mul(LEFT,RIGHT : Types.LONG_FIXED; 

RESULT : out Types.LONG_FIXED); 
pragma INLINE(Long_Lortg_Mul); 

procedure Long_LongJDiv(LEFT,RIGHT : Types.L0NG_F1XED; 

RESULT : out Types.LONG_FIXED); 
pragma INLINE(Long_Long_Di v); 

procedure Long_Word_Div(LEFT : Types.L0NG_FIXED; 

RIGHT : Types.WORD; 

RESULT : out Types.LONG_FIXED>; 
pragma INLINE(Long_Uord_Div); 

procedure Meters_Heters_Div(LEFT,RIGHT : Types.METERS; 

RESULT : out Types.METERS); 
pragma INLINE(Meters_Meters_0i v); 

procedure Meters_Uord_Div(LEFT : Types.METERS; 

RIGHT : Types.UORO; 

RESULT : out Types.METERS); 
pragma INLINE(Meters_Uord_Oiv); 

procedure Meters_Meters_Mul(LEFT,RIGHT : Types.METERS; 

RESULT : out Types.METERS); 
pragma INLINE(Meters_Meters_Mul); 

procedure Rate_Rate_Mul(LEFT,RIGHT : Types.RATE_TYPE; 

RESULT : out Types.RATE_TYPE); 
pragma INLINE(Rate_Rate_Mul); 

procedure Rate_Rate_Oiv<LEFT,RIGHT : Types.RATE_TYPE; 

RESULT : out Types.RATE_TYPE); 
pragma INLINE(Rate_Rate_Div); 

procedure Rate_Uord_Oiv(LEFT : Types.RATE_TYPE; 

RIGHT : Types.WORD; 

RESULT : out Types.RATE_TYPE); 
pragma INLINE(Rate_Word_Div); 

procedure Long_Rate_Div(LEFT : Types.L0NG_FIXED; 

RIGHT : Types.RATE_TYPE; 

RESULT : out Types.LONG_FIXED); 
pragma INLINE(Long_Rate_Oiv); 


- 95 - 






Distributed Issues Final Report 


procedure Rate_Long_Div(LE FT 
RIGHT 
RESULT 

pragma INLINE(Rate_Long_Div); 


: Types.RATE_TTPE; 

: Types.LONG_FIXED; 

: out Types.RATE_TYPE); 


procedure Rate_Long_Long_Mul(LEFT 

RIGHT 

RESULT 

pragma INLINE(Rate_Long_Long_Mut); 


Types.RATE_TYPE; 

T ypes.LONG_FIXED; 
out Types.L0NG_FIXED); 


procedure Rate_Long_Rate_Mul(LEFT 

RIGHT 

RESULT 

pragma INLINE(Rate_Long_Rate_Hul); 


Types.RATE_TYPE ; 

T ypes.L0NG_FIXED; 
out Types.RATE_TYPE); 


procedure Next_Random(CHANNEL_TWO_VALUE : out Types.WORDJNDEX); 
pragma INLINEfNext_Random); 

end Machine_Oependent; 


- 96 - 







Distributed Issues Final Report 


■■X UNIT: Machine_Dependent Package Body. 

--X Effects: Provides graphics machine dependencies. 

--X Modifies: No global data is modified. 

--X Requires: No initialization is required <other than graphics mode). -- 
--% Raises: No explicitly raised exceptions are propagated. 

-•X Engineer: M. Sperry. 


•-| PACKAGE BODY : Machine_Oependent 

--| A package which makes use of the functionality of the BIOS routines 
--| found in an EGA card to perform some graphics processing. Note that 
--| some register level EGA programming is performed. 

**| Also, the timer chip channel two functions are utilized to generate 
pseudo random nunbers. 


-- Modifications Log 

-- 88*08-25 : MPS => Original created. 

-- 89-08-24 : MPS => Incorporated fixed math routine bodies for speed. 
-- 89-11-28 : MPS => developed Next_Rar>dom procedure. 


with HU_Config; 

package body Machine_Deper>dent is 


hi_res_graphics 

constant 

: = 

16#10#; 

-- graphics mode 

set_cursor 

constant 

: = 

16#0200#; 

-- set cursor function 

page_zero 

constant 

: = 

16#00#; 

-- set cursor to active page 

write_function 

constant 

: = 

16#0E#; 


index_register 

constant 

: = 

16#3CE0; 

-- port address 

access_register 

constant 

: = 

16#3CF#; 

-- port address 

mode_register 

constant 

: = 

5; 

-- index register 5 

write_mode_2_val 

constant 

: = 

2; 


write mode 0 val 

constant 

: = 

0; 



procedure Put_Pixel(A8S_X, ABS_Y : Types.COORD I NATE; 

COLOR : Graphics.C0L0R_TYPE) is 


-| SUBPROGRAM BOOT : Machine_Dependent.Put_Pixel 

-| An assembly level procedure (for enhanced speed) to place a dot on the EGA 
-j screen. Write mode two is used here (again, for enhanced speed). It is 
-j important to note that this routine could be called up to 1235 times per 


- 97 - 











Distributed Issues Final Report 


*-| interval. 


begin 

-- The first thing to do is find out which bit must be turned on. This is 

-- done by taking $HR( 80h, ABS_X mod 8 ). The bit ordering goes from 7 -> 0. 

MACHINE_IMSTRUCTION'(register_register, m_MOV, CX, CX); -- defeat compiler bug 

MACHINE_INSTRUCT10N'(register_immediate, m_MOV, OX, 16#3CE#); -- select bit 

MACHlNE_INSTRUCTION'(register_immediate, m_MOV, AL, 8); -- mask register 

MACH INE_INSTRUCTION'(register_register, m_OUT, DX, AL); -- in graphics chip 

-- Determine which bit must be turned on. This is 

-- done by taking SHR< 80h, ABS_X rem 8 ), reversing the bit ordering. 

MACHINE_INSTRUCTION'(register_system_address. m_MOV, CX, ABS_X'address); --X 
MACHIN£_lNSTRUCTION'(register_register, m_MOV, BX, CX); -- make copy of X 

MACHINE_INSTRUCTION'(register_immediate, m_AN0, CL, 7); -- mask for bit # 

MACHINE_INSTRUCTION'(register_immediate, m_MOV, AL, 16#80#); -- most significant bit is 

MACHINE_INSTRUCTIOM'(register_register, m_SHR, AL, CL); -- bit zero, do bit reversal. 

-- AL now holds the bit mask. Now give it to the bit mask register located 
-- at 16#3CF#. 

MACH INE_INSTRUCTION'(register, m_INC, DX); -- increment port address to 3CF 
MACH INE_!NSTRUCTION'(register_register, m_OUT, DX, AL); 


-- Now, latch the byte of graphics memory. The byte to latch 

-- is defined as (ABS_T * 80) ♦ (ABS_X / 8). Then, when giving 

-- it back, place the color in AL. Note that only four bits of the color are 

-- significant and that the color placed in AL is not actually a color, but a 

-- palette register selection (from 0 to 15). The color in the palette 

-- register is the color displayed.-16#6000# is loaded (= A000H) 

-- to point to the EGA graphics page zero memory address. 

MACH INE_!NSTRUCTION'(register_sys tem_address, m_MOV, AX, ABS_T'address);--Y 
MACHINE_INSTRUCTION'(register_immediate, m_MOV, CX, 80); -- bytes/line 
MACH INE_INSTRUCTION'(regiSter, m_MUL, CX); -- ABSJT * 80 in AX 
MACH 1NE_INSTRUCTION'(register_immediate, m_MOV, CL, 3); -- Shift Count 

MACHINE_INSTRUCTION'(register_register, m_SHR, BX, CL); -- ABS_X / 8 in BX 
MACHINE_INSTRUCTION'(register_register. m_ADD, BX, AX); -- BX is offset 
MACHINE_INSTRUCTION'(register_irmiedi »te, m_MOV, AX, -16#6000#); -- base of RAM 
MACH INE_!NSTRUCTION'(register_register, m_MOV, ES, AX); 

-- Latch the palette selection. Note that the contents of AL upon return are 
-- meaningless, and that the color is latched internally to the EGA's four bit 
-- planes. 


- 98 - 









Distributed Issues Final Report 


-- mov AL,ES:[BX] 

MACHINE_1NSTRUCTION'(register_address, m_MOV, AL, ES, BX, nil, SCALE_1, 0); 
MACHINE_INSTRUCTION'(register_system_address, m_MOV, AX, COLOR'address); 

-- Finally, give the palette selection (color) to the four bit planes. 

-- mov £S:(BX1,AL 

MACHINE_INSTRUCTION'(address_register, m_MOV, ES, BX, nil, SCAtEJ, 0, AL); 
end Put_Pixel; 
procedure Write_Mode_0 is 


-| SUBPROGRAM BODY : Machine_Dependent.Urite_Mode_0 

-I 

-| A procedure used to change the write mode of the screen to mode 0, 
-| for text writing. This procedure is called before writing any ttxt. 


begin 

MACHINE_INSTRUCTION'(register_immediate, m_MOV, OX, index_register); 
MACHINE_INSTRUCTION'(register_immediate, m_M0V, AL, mode_register); 
MACHlNE_lNSTRUCTION'(register_register, m_OUT, OX, AL); 
MACHINE_INSTRUCTION'(register_immediate, m_MOV, OX, access_register); 
MACHINE_INSTRUCTION'(register_immediate, m_M0V, AL, write_mode_0_val); 
MACH INE_INSTRUCTION'(register_register, m_OUT, OX, AL); 
end Write_Mode_0; 

procedure Write_Mode_2 is 


-*| SUBPRf'RAM BOOT : Machine_Oependent.write_Mode_2 

--| A procedure used to change the write mode of the screen to mode 2, which 
facilitates the process of pixel plotting. This routine is called after 
--| writing the necessary statistics titles, etc. 


begin 

MACHINE_INSTRUCTION'(register_inwediate, m_MOV, OX, index_register); 

MACHlNE_INSTRUCTlON'(register_immediate, m_MOV, AL, mode_register); 

MACH INE_INSTRUCTION'(register_register, mjXIT, OX, AL); 
MACHINE_INSTRUCTION'(register_immediate, m_MOV, OX, access_register); 

HACHINE_INSTRUCTION'(register_immediate, m_MOV, AL, write_mode_2_val); 

MACH INE_INSTRUCTION'(register_register, m_OUT, OX, AL); 
end Urite_Mode_2; 


-*| SUBPROGRAM BOOT : Machine_Dependent.Fixed_Math routines 


- 99 - 








Distributed Issues Final Report 


--| These routines are written in 80386 32-bit code optimized for the 
--| types on which they operate for maximum speed. They are treated as a 
--| resource. 


procedure Long_Long_Mul(LEFT,RIGHT : Types.LONG_FIXED; 

RESULT : out Types.LONG_FIXED) is 


begin 


MACH1NE_INSTRUCTION'(none,m_CLI); 

MACH INE_INSTRUCTION'(register_system_address, m_LEA,BX,LEFT'address); 
MACHlNE_INSTRUCTION'(ininediate,m_OATAB,16#66#); 

MACHIn£_INSTRUCTION'(register_address,m_MOV,AX,SS,BX,nil,scale_1,0); 
MACHINEJNSTRUCTlON'(irmiediate,m_DATAB,16#66#); -- 32 bit override 
MACH INE_INSTRUCTION'(system_address, mj MUL, RIGHT' address >; 

MACH INE_INSTRUCTION'(register_immediate,m_MOV,CX,6); 

MACH INE_INSTRUCTUN'(immediate,mJJATAB, 16#66#); -- 32 bit override 
MACHINE_INSTRUCTION'(immediate,m_DATAB,16#66#>; 

MACHINE_INSTRUCTION'(immediate,m_0ATAB,16#0F#); -- SHRO EAX,EDX,CL 
MACHINE_INSTRUCTION'(immediate,m_0ATAB,16#A0#); 

MACH I NE_I NSTRUCT ION' ( irunedi ate,m_0ATAB, 16#00#); 

MACHINE_INSTRUCTION'(immediate,m_OATAB,16#66#); -- 32 bit override 
MACH1NE_INSTRUCTION'(systemaddressregis ter,m_MOV,RESULT'address,AX); 
MACH INE_IN STRUCT ION'(none,m_STI); 
end Long_Long_Mul; 


procedure Long_Long_Oiv(LEFT,RIGHT : Types.L0NG_FIXED; 

RESULT : out Types.LONG_FIXEO) is 

begin 

MACHINE_INSTRUCTION'(none,m_CLI); 

MACHINE_INSTRUCTION'(register_system_address,m_LEA,8X,LEFT'address); 
MACHINE_INSTRUCTION'(i(nnediate,m_OATA8,16#66#); 

MACHINE_INSTRUCTION'(register_address,m_MOV,AX,SS,BX,nil,scale_1,0); 
MACH INE_INSTRUCTION'(i nmediate,m_0ATAB,16#66#); 

MACHINE_INSTRUCTION'(none,m_CUD); -- COO 

MACHINE_INSTRUCTION'(register_immediate,m_MOV,CX,6); 

MACH INE_INSTRUCTION'(immediate,m_DATAB,16#66#); -- 32 bit override 
MACHINE_INSTRUCTION'(immediate,m_0ATAB,16#0F#>; -- SHLD EDX,EAX,CL 
MACH INE_INSTRUCTION'(immediate,m_0ATAB,16#A5#); 

MACH INE_INSTRUCTION'(immediate,m_0ATAB,16#C2#); 

MACH INE_INSTRUCTION'(immediate,m_0ATAB,16#66#); 

MACHINE_INSTRUCTION'(register_register,m_SHL,AX,CL); 
MACHINE_INSTRUCTI0N'(immediate,m_0ATAB,16#66#); -- 32 bit override 
MACH INE_INSTRUCTION'(system_address,m_10IV,RIGHT'address); 
MACHINE_INSTRUCT!ON'(immediate,m_0ATAB,16#66#); -- 32 bit override 
MACH INE_INSTRUCTION'(system_address_register,m_MOV,RESULT'address,AX); 
MACHINE_INSTRUCTION'(none,m_S TI); 
end Long_Long_Oiv; 


- 100 - 








Distributed Issues Final Report 


procedure Long_Word_0iv(LEFT : Types.LONG_FIXED; 

RIGHT : Types.WORD; 

RESULT : out Types.L0NG_FIXED) is 

begin 

MACHINE_INSTRUCTION'(none,m_CLI); 

MACHINE_I NSTRUCTI ON' (reg ister_system_iddress,m_LEA,BX,RIGHT'address); 

MACH1NE_t NSTRUCTION'< register_address,m_MOV,AX,SS,BX,nil,seale_1,0); 

MACH I NE_I NSTRUCT I ON' (i itmedi ate, m_D AT AB, 16#66#) ; 

MACHIN£_INSTRUCTlON'(none,m_CBU); -- this instruction performs a CWDE 
MACHINE_INSTRUCTION'(immediate,m_DATA8,16#66#); 

MACHINE_INSTRUCTION'(register_register,m_MOV,3X,AX); 

MACH INE_tNSTRUCTION'(register_system_address,m_LEA,SI,LEFT'address); 

MACH INE_INSTRUCTION'Ci mnediate,m_OATAB,16#66#); 

MACH 1NE_INSTRUCTION'(register_address,m_MOV,AX,SS,S1,nil,seale_1,0) ; 

MACH I NE_I NSTRUCT ION'( i timed i ate, m DATAB, 16 #66#) ; 

MACH INE_INSTRUCTION'(none,m_CWO); -- this instruction performs a CDO 
MACHINE_INSTRUCTION'(immediate,mDATAB,16#66#); 
MACHINE_INSTRUCTION'(register,mJDtV,8X); 

MACHINE_INSTRUCTION'(immedia t e,mDATAB,16#66#); 

MACH1NE_INSTRUCTION'(system_address_register,m_MOV,RESULT'address,AX); 

MACH INEJ NSTRUCTION'(none,m_STI); 
end Long_Uord_Div; 

procedure Meters_Meters_Mul(LEfT.RIGHT : Types.METERS; 

RESULT : out Types.METERS) is 

begin 

MACHINE_INSTRUCTION'(register_register, m_MOV, CX, CX); *• defeat compiler bug 
MACH INE_INSTRUCTION'(register_system_address,m_MOV,AX,LEFT'address); 

MACH INE_INSTRUCTION'(system address,m_IMUL,RIGHT'address); 

MACH I NE_I NSTRUCT I ON' (reg i st er_i rimed i a t e, m_MOV ,CX,3); 

MACHINE_INSTRUCTION'(immediate.mOATAB,16#0F#); -- SHRO AX,OX,CL 
MACH INE_INSTRUCTION'(immediate,m_0ATAB,16#A0#); 
MACHINE_INSTRUCTION'(immediate,m_0ATA8,16#O0#); 

MACH INE_INSTRUCTION'(system_address_register,m_MOV,RESULT'address,AX); 
end Meters_Meters_Mul; 

procedure Meters_Meters_Div(LEFT,RIGHT : Types.METERS; 

RESULT : out Types.METERS) is 

begin 

MACH INE_INSTRUCTION'(register_register, m_MOV, CX, CX); -- defeat compiler bug 
MACHINE_I HSTRUCTION'<register_system_address,m_MOV,AX,LEFT'address); 

MACHINFJ NSTRUCTION'(none,m_CUD); 
MACHINE_INSTRUCTION'(register_inmediate,m_MOV,CX,3); 

MACHINE_INSTRUCTION'(register_register,m_SHL,AX,CL); 
MACHINE_INSTRUCTION'(system_address,m_IDIV,RIGHT'address); 

MACH INE_INSTRUCTION'(system_address_register,m_MOV,RESULT'address,AX); 
end Meters_Meters_0iv; 

procedure Meters_Word_Div(LE c T : Types.METERS; 

RIGHT : Types.WORD; 

RESULT : out Types.METERS) is 


- 101 - 





Distributed Issues Final Report 


begin 

MACH INE_INSTRUCTION'(register_register, m_MOV, CX, CX); -- defeat compiler bug 
MACHINE_INSTRUCTION *(register_system_address,m_MOV,AX,LEFT'address); 

MACH INE_INSTRUCTION'(none,m_CUD); 

MACH INE_INSTRUCTION'(register_system_address,m_MOV,BX,RIGHT'address); 
MACHlNE_INSTRUCTION'(register,m_IDIV,BX); 

MACHINE_INSTRUCTION'(system_address_register,m_MOV,RESULT'address,AX); 
end Meters_Word_Div; 

procedure Rate_Rate_Mul(LEFT,RIGHT : Types.RATE_TYPE; 

RESULT : out Types.RATE_TYPE) is 

begin 


MACH INE_INSTRUCTION'(none,m_CLI); 

MACHINE_INSTRUCTION'(register_system_address,m_LEA,BX,LEFT'address); 
MACHINE_INSTRUCTION'(immediate,m_DATAB,16#66#); 

MACHINE_INSTRUCTION'(register_address,m_MOV,AX,SS,BX,nil,scale_1,0); 
MACH INE_INSTRUCTION'(immediate,m_OATAB,16#66#); -- 32 bit override 
MACH INE_INSTRUCTION'(system_address,m_IMUL.RIGHT'address); 
MACHINE_INSTRUCTI0N'(registerJmmediate,m_M0V,CX,16); 

MACH I NE_I NSTRUCT I ON' ( immediate, mDATAB, 16#66#) ; 

MACHINE_INSTRUCTION'(i mmedi ate,m_DATAB, 16#0F#),' -- SHRO EAX,EDX,CL 
MACHINE_INSTRUCTION'(immediate,m_0ATA8,16#AD#); 
MACHINE_INSTRUCTION'(inmediate,m_DATAB,16#00#); 

MACH I NE_I NSTRUCT ION' (i ntnedi ate,m_OATAB, 16#66#); -- 32 bit override 
MACH INE_INSTRUCTION'(system_address_register,m_MOV,RESULT'address,AX); 
MACH INE_INSTRUCTION'(none,m_STI); 
end Rate_Rate_Mul; 


procedure Rate_Rate_0iv(LEFT,RIGHT : Types.RATE_TYPE; 

RESULT : out Types.RATE_TYPE) is 

begin 

MACH INE_INSTRUCTI ON'(none,m_CLI); 

MACHINEJ NSTRUCTION'(register_system_address,m_LEA,BX,LEFT'address); 
MACH INE_INSTRUCTION'(immediate,m_0ATAB,16#66#); 

MACHINE_INSTRUCTION'(register_address,m_MOV,AX,SS,BX,nil,scale_1,0); 
MACHINE_INSTRUCTION'(immediate,m_DATAB,16#66#); -- 32 bit override 
MACHINE_INSTRUCTION'(none,m_CUD); -- performs a CDO 

MACHINE_INSTRUCTI0N'(register_immediate,m_M0V,CX,16); 

MACH INE_INSTRUCTION'(immediate,m_OATAB,16#66#); -- 32 bit override 
MACHINE_INSTRUCTION'(immediate,m_DATAB,16#0F#); -- SHLD EDX,EAX,CL 
MACHINE_INSTRUCTION'(immediate,m_DATAB,16#A5#); 

MACH INE_INSTRUCTION'(imnediate,m_DATAB,16#C2#); 

MACHINE_INSTRUCTION'(immediate,m_DATAB,16#66#); 

MACHINE_INSTRUCTION'(register_register,m_SHL,AX,CL); 
MACHINE_INSTRUCTION'(immediate,m_OATAB,16#66#); 

MACHINE_INSTRUCTION'(system_address,m_I01V,RIGHT'address); 
MACHINE_INSTRUCTION'(immediate,m_OATAB,16#66#); -- 32 bit override 
MACHINE_INSTRUCTION'(system_address_register,m_MOV,RESULT'address,AX); 
MACH INE_INSTRUCTION'(none,m_STI); 
end Rate_Rate_Oiv; 


- 102 - 








Distributed Issues Final Report 


procedure Rate_Uord_Oiv(LEFT : T ypes.RATE JYPE; 

RIGHT : Types.WORD; 

RESULT : out Types.RATE_TYPE) is 

begin 

MACHINEJNSTRUCT10N'(none,m_CLI); 

MACHINEJNSTRUCTION'(register_system_address,mJ.EA,8X,RIGHT'address); 
MACHINEJNSTRUCTION'(register_address,m_MOV,AX,SS,BX,ni l,scaleJ.O); 

MACH INE_INSTRUCTION'(i mnediate,m_0ATAB,16#66#); 

MACHINE_INSTRUCT10N'(none,m_CBW); -- this instruction performs a CWDE 

MACHINEJNSTRUCTION'(imnediate,m_DATAB,16#66#); 

MACHINEJNSTRUCTION'(register_register,m_MOV,BX,AX); 

MACHINEJNSTRUCTION'(register_system_address,m_LEA,SI,LEFT'address); 
MACHINEJNSTRUCTION'( immediate,mJ)ATAB,16#66#); 

MACH INE_INSTRUCTION'(register address,m_MOV,AX,SS,SI,ni l,scalej,0); 

MACH INE_INSTRUCTION'(i mnediate,m_0ATAB,16#66#); 

MACHINE_INSTRUCTION'(none,m_CUD); -- this instruction performs a CDQ 
MACHINE_INSTRUCTION'(i mnediate,rnOATAB,16#66#); 

MACH I NEJNSTRUCTION'(register,mJ DlV,BX); 

MACH I NE_I NSTRUCT I ON' ( i mnediate,mJJATAB,16#66#); 

MACH INEJNSTRUCTION'(system_address_register,m_MOV,RESULT'address,AX); 
MACH I NEJNSTRUCTION'(none,m_STI); 
end Rate_Uord_Oiv; 

procedure Rate LongJ.ong_Mul(LEFT : Types.RATE_TYPE; 

RIGHT : Types.LONG_FIXED; 

RESULT : out Types.LQNG_FIXED) is 

begin 

MACHINE_INSTRUCTION'(none,m_CLI); 

MACHINE INSTRUCT ION'(register_system_address,m_LEA,BX,LEFT'address); 

MACH INE_INSTRUCTION'(i mnediate,m OATAB,16#66#); 

MACH INE_INSTRUCTION'(registeraddress,m_MOV,AX,SS,8X,nil,scale_1,0); 

MACH INE_INSTRUCTION'(imnediate,m_DATAB,16#66#); -- 32 bit override 
MACHINE_INSTRUCTION'(system_address,m_IMUL,RIGHT'address); 

MACH INE_INSTRUCTION'(register_i mnediate,m_HOV,CX,16); 

MACH INEJ NSTRUCT I ON'(i mnedi ate, m_DATAB, 16#66#) ; 

MACHINE_INSTRUCTION'(immediate,m_DATAB,16#0F#); -- SHRD EAX,EDX,CL 
MACHINE_INSTRUCTION'(imnediate,m_DATAB,16#AD<0; 

MACHINE_INSTRUCTION'(immediate,m_0ATAB,16#O0#); 

MACHINE_INSTRUCTION'(imnediate,m_DATAB,16#66#); -- 32 bit override 
MACHINE_INSTRUCTION'(system_address_register,m_MOV,RESULT'address,AX); 
MACHINE_INSTRUCTION'(none,m_STI); 
end Rate_Long_Long_Mul; 

procedure Rate_Long_Rate_Mul(LEFT : Types.RATE_TYPE; 

RIGHT : Types.LONG_FIXED; 

RESULT : out Types.RATE_TYPE) is 

begin 

MACHI NEJ NSTRUCT I ON' (none, m_CL I) ; 


- 103 - 





Distributed Issues Final Report 


MACHINEJNSTRUCTION'(register_system_address,m_LEA,BX,LEFT'address); 
MACH I NEJ NSTRUCT ION'(immediate,m_DATA8,16#66#); 

MACHINEJNSTRUCTION'(register_address,m_MOV,AX,SS,BX,nil,scale_1,0); 
MACHINEJNSTRUCTI0N'(inroediate,mJ)ATA8,16#66#); -- 32 bit override 
MACH INE_INSTRUCTIOH'(system_address,mj MUL,RIGHT'address); 
MACH1NE_INSTRUCTI0N'(registerJmmediate,m_MOV,CX,6); 

MACHINE_!NSTRUCTION'(i nrnediate,m_0ATAB,16#66#); 

MACH INEJ NSTRUCT I ON'(immediate,m_DATAB,16#0F#); -- SHRD EAX,EDX,CL 
MACH INE_INSTRUCTION'(i nmediat e,m_0ATAB,16#AD#); 

MACHINE JNSTRUCT ION'(immediate, mJ)ATAB,16#O0#); 

MACHINE_INSTRUCTION'(immedi ate,mJJATAB,16#66#); -- 32 bit override 
MACHINE JNSTRUCTION' (system_address_regi ster,m_MOV,RESULT 'address, AX); 
MACH INE_INSTRUCTION'(none,m_STI); 
end Rate_Long_Rate_Mul; 

procedure Long_Rate_Oiv(LEFT : Types.LONG_FIXED; 

RIGHT : Types.RATEJYPE; 

RESULT : out Types.LONG_FIXED> is 

begin 

MACH INE_INSTRUCTION'(none,m_CLI); 

MACH INE_INSTRUCTION'(register_system_address,m_LEA,8X,LEFT'address); 
MACH INEJ NSTRUCT I ON' (i mmedi a t e, m_DATAB, 16#66#) ; 

MACHINEJNSTRUCTION'(register_address,m_MOV,AX,SS,BX,nil,scaleJ,0); 
MACHINEJNSTRUCTI0N'(immediate,m_DATAB,16#66#); -- 32 bit override 
MACH INE_INSTRUCTION'(none,m_CWD); -- performs a CDQ 

MACH INE_I NSTRUCT I ON'( regi ster_i mmedi ate, m_MOV ,CX,16); 

MACHINE_INSTRUCTION'(immediate,m_0ATAB,16#66#); -- 32 bit override 
MACHINE_INSTRUCTION'(immediate,m_OATAB,16«OF#); -- SHLD EDX,EAX,CL 
MACH I NEJ NSTRUCT I ON' ( immediate, mOATAB, 16#A5#); 
h.*CH I NE_I NSTRUCT ION' (immediate,m_DATAB, 16#C2#); 

MACH INE_INSTRUCTI ON'(immediate,m OATAB,16#66#); 
MACHINE_INSTRUCTION'(register_register,m_SHL,AX,CL); 
MACHINE_INSTRUCTION'(immediate,m_DATAB,16#66#); 

MACH INE_I NSTRUCTION'(system_address,m_IDIV,RIGHT'address); 
MACHINE_INSTRUCTION'(immediate,m_0ATAB,16#66#); -- 32 bit override 
MACH INE_INSTRUCTION'(system_address_register,m_MOV,RESULT'address,AX); 
MACH I NEJ NSTRUCT I ON' ( none, m_ST I ) ; 
end Long_Rate_Oiv; 

procedure Rate_Long_Div(LEFT : Types.RATE_TYPE; 

RIGHT : Types.LONG_FIXED; 

RESULT : out Types.RATE_TYPE) is 

begin 

MACH!NE_INSTRUCTION'(none,m_CLI); 

MACHINE_INSTRUCTION'(register_system_address,m_LEA,BX,LEFT'address); 
MACHINE_INSTRUCT!ON'(immedia t e,m_0ATAB,16#66#); 

MACH INEJ NSTRUCTION'(register_address,m_MOV,AX,SS,BX,nil,scale_1,0); 
MACHINEJNSTRUCTION'(immediate,m_DATAB,16#66#); -- 32 bit override 
MACH I NEJ NSTRUCT ION' (none, m_CWD); -- performs a CDQ 

MACHINE JNSTRUCTION't register Jmmedi ate,m_MOV,CX,6); 

MACHINEJNSTRUCTION'(immediate,m_DATAB,16#66#); -- 32 bit override 


- 104 - 







Distributed Issues Final Report 


MACH INE_INSTRUCTION'(immediate,m_DATAB,16#0F#J; -- SHLD EDX,EAX,CL 
HACK INE _1NSTRUCTION'(i nrnediate,m_DATAB,16#A5#); 

MACH INE_INSTRUCTION'(immediate,m_DATAB,16#C2#); 

HACK INE_INSTRUCT1ON'(immediate,m_DATAB,16#66#); 

MACHINE_INSTRUCTION'(register_register,m_SHL,AX,CL); 

MACH INE_INSTRUCTION'(immediate,m_DATAB,16#66#); 

MACHINE_INSTRUCTION'(system_address,m_IDIV,RIGHT'address); 
MACHINE_INSTRUCTI0N'(immediate,m_DATA8,16#66#); -- 32 bit override 
MACHINE_INSTRUCTION'(system_address_register,m_MOV,RESULT'address,AX); 
MACHINE_INSTRUCTION'(none,m_STI); 
end Rate_Long_0iv; 

procedure Next_Random(CHANNEL_TUO_VALUE : out Types.WORD_INDEX) is 


--| SUBPROGRAM BOOT : Machine_Dependent.Next_Random 

--| This function returns the value of the number at the address of the 
--| channel two counter. It is assumed that the initialization of that channel 
--| is previously performed. Therfore it returns a value between 0 and 255. 


begin 

MACHINE_INSTRUCTION'(register_register, m_MOV, CX, CX); -- defeat compiler bug 

MACHINE_INSTRUCTION'(register_immediate,m_MOV,DX,HU_Config.counter_two_addr); 

MACHINE_INSTRUCT10N'(register_register,m_IN,AL,DX); 

MACH INE_INSTRUCTION'(register register,m_XOR,AH,AH); 

MACH INE_INSTRUCTION'(system address register,m_MOV,CHANNEL_TWO_VALUE'address, 
AX); 

end Next_Random; 

procedure Initialize_Timer_Two is 


•*| SUBPROGRAM BOOT : Machine_Oependent.Initialize_Timer_Two 

--I 

*-| A procedure used to start the channel 2 counter counting down from 
-*| max_timer_value to zero over and over to generate numbers. 


begin 

MACHINE_INSTRUCTION'(register_immediate,m_MOV,OX, 

HW_Config.timer_control_addr); 

MACHINE_INSTRUCTION'(register_immediate,m_MOV,AX,start_countdown); 
MACHINE_INSTRUCTION'(register_register, m_OUT, OX, AL); 

MACHINE_INSTRUCTION'(register_inmediate,m_MOV,DX,HW_Config.counter_two_addr); 
MACHINE_INSTRUCTION'(register_immediate,m_MOV,AX,max_timer_value); 
MACHINE_INSTRUCTION'(register_register, m_OUT, DX, AL); 

-- The first out byte was the LSB. Now take care of MSB. 


- 105 - 







Distributed Issues Final Report 


MACHlNE_INSTRUCTION'(register_innediate,m_MOV,OX ( HU_Config.counter_two_acldr); 

MACHINE_INSTRUCTION'(register_inmediate,m_MOV,AX,max_timer_vaiue); 

MACHINE_INSTRUCTION'(register_register, m_OUT, OX, AL); 
end Initialize_Timer_Two; 
pragma INLINE!Initialize_Timer_Two); 

begin 

Initialize_Timer_T wo; 
end Machine_Oependent; 


- 106 - 




Distributed Issues Final Report 


--X UNIT: Math Package Spec. 

--X Effects: Compute various functions: Tan, Arc Tan, and Sqrt. 
--X Modifies: No global data is modified. 

--X Requires: No initialization is required. 

--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: Various. 


-| PACKAGE SPEC : Math 

-| Math is responsible for implementing the necessary math functions of 
-| the BDS. Some of the transcedental functions are approximations using 
-| table look-ups. The fixed point routines which perform basic multiply 
-| and divide operations are made visible to replace the runtime supplied 
-| routines which are too general (and thus too slow5 for the BOS's needs. 
-) The Get_Random_Num function uses the channel two timer to return a 
-| nurber from 0 to the limit specified. 


- Modifications Log 

- 88-10-09 : TEG => Original created. 

- 89-08-24 : MPS => Fixed point routines were made visible. 

- 89-09-11 : MPS => Sin,Cos added from intern code. 

- 89-11-08 : MPS => General Power routine added. 

- 89-11-08 : MPS => Arcsin routine added. 

- 89-11-08 : LJG => Arctan routine was made more precise. 

- 89-11-20 : MPS => Get_Random_Num routine moved from Targ_Sup to Math. 


with Types; 
package Math is 

function "*"(LEFT,RIGHT : Types.LONG_FIXED) return Types.10NG_FIXED; 
--pragma INLINEC*"); 

function “/"(LEFT,RIGHT : Types.LONG_FIXE0) return Types.LONG_FIXED; 
--pragma INLINEC/"); 

function "/"(LEFT : Types.LONG_FIXE0; 

RIGHT : Types.WORD) return Types.L0NG_FIXED; 

--pragma INLINEC/"); 

function "*"(LEFT,RIGHT : Types.METERS) return Types.METERS; 

--pragma INLINEC*"); 

function "/"(LEFT,RIGHT : Types.METERS) return Types.METERS; 


- 107 - 








Distributed Issues Final Report 


-pragma 

function 

--pragma 

function 

--pragma 

function 

--pragma 

function 

--pragma 

function 

--pragma 

function 

--pragma 

function 

--pragma 

function 

--pragma 

function 

function 

function 

function 

function 

function 

function 

function 

function 

function 


INLINEO'/"); 

"/"(LEFT : Types.METERS; 

RIGHT : Types.WORD) return Types.METERS; 

INLINEO'/"); 

"•"(LEFT,RIGHT : Types.RATE_TYPE) return Types.RATE_TYPE; 
INLINEO'*"); 

"/"(LEFT,RIGHT : Types.RATE_TYPE) return Types.RATE_TYPE; 
INLINEO'/"); 

"/"(LEFT : Types.RATE_TYPE; 

RIGHT : Types.WORD) return Types.RATE_TYPE; 
INLINEO'/"); 

"•"(LEFT : Types.RATEJYPE; 

RIGHT : Types.LONG_FI XED) return Types.RATE_TYPE; 
INLINEO'*"); 

"•"(LEFT : Types.RATE_TYPE; 

RIGHT : Types.LONG^FIXED) return Types.LONG_FI XED; 
INLINEO'*"); 


"/"(LEFT : Types.LONGJ'IXED; 

RIGHT : Types.RATE_TYPE) return Types.LONG_FTXED; 

INLINEO'/"); 

"/"(LEFT : Types.RATE_TYPE; 

RIGHT : Types.LONG^FIXEO) return Types.RATE_TYPE; 

INLINEO'/"); 

Power (BASE, RAISED_TO : Types.LONG_FIXEO) return Types.LONG_FIXED; 

Sin (ANGLE : Types.BAM) return Types.LONG_F1XED; 

Cos (ANGLE : Types.BAM) return Types.LONG_FIXED; 

Tan (ANGLE : Types.BAM) return Types.LONG_FIXED; 

Arcsin (THETA : Types.LONG_FIXED) return Types.LONG_FIXED;-- in degrees 
Arctan (Z_INPUT : Types.LONG_FIXED) return Types.BAM; 

Sqrt (X : in Types.METERS) return Types.METERS; 

Sqrt (X : in Types.LONG_FIXEO) return Types.LONG_FIXED; 

Sqrt (X : in Types.RATE_TYPE) return Types.RATE_TYPE; 

Get_Random_Nun (LIMIT : Types.WORD_INDEX) return Types.WORD_INDEX; 


- 108 - 





Distributed Issues Final Report 


function Get_Random_Nun (LIMIT : Types.METERS) return Types.METERS; 
function Get_Random_Nun (LIMIT : Types.LONG_FIXED) return Types.LONG_FIXED; 
end Math; 


- 109 - 






Distributed Issues Final Report 


--% UNIT: Hath Package Body. 

Effects: Compute various functions: Tan, Arc Tan, and Sqrt. 
--X Modifies: No global data is modified. 

Requires: No initialization is required. 

■■X Raises: No explicitly raised exceptions are propagated. 

-•X Engineer: L. Griest. 


PACKAGE BODY : Math 

The math package contains the various math routines needed by the BOS. 

Some of these routines contain simplifications to increase performance. 

The routines (provided to do fixed point math) are all functions which allow 
for overloading. Since machine code statements can only be procedures, a 
call to the appropriate procedure is contained within each function. Since 
each function and procedure is inlined, the end result should not generate 
any overhead. 

Modifications Log 


88 - 10-10 

89-08-24 

89-11-08 

89-11-09 

89-11-20 


TEG => Original created. 

MPS => Bodies of fixed point functions created. 
MPS => Arcs in and Power functions added. 

LJG => Arctan function was given greater accuracy. 
MPS => Get_Random_Num function created. 


with Machine_Dependent; 
with Time_Stamp; 

pragma ElABORATE(Time_Stamp, Machine_Deper>dent); 


package body Math is 
use Types; 

type FUNC_NAME is ( SINE, COSINE); 

subtype FUNC_RANGE is Types.WORD range 0..100; 

type FUNC_TABIE is array (FUNC_RANGE,FUNC_NAME) of Types.10NG_FIXED; 
TR1G_FUNC : FUNC_TABLE := ((0.000000,1.000000),(0.015625,1.000000), 

(0.031250,1.000000),(0.046875,1.000000), 
(0.062500,1.000000),(0.078125,1.000000), 
(0.093750,1.000000),(0.109375,1.000000), 
(0.125000,1.000000),(0.140625,1.000000), 
(0.156250,1.000000 5,(0.171875,1.000000), 
(0.187500,0.984375),(0.203125,0.984375), 
(0.218750,0.984375), (0.234375,0.984375), 
(0.250000,0.9687505,(0.265625,0.968750), 
(0.281250,0.9687505,(0.296875,0.968750), 
(0.312500,0.9531255,(0.328125,0.9531255, 


- 110 - 











Distributed Issues Finai Report 


(0.343750,0.953125),(0.359375,0.937500), 
(0.375000,0.937500),(0.390625,0.937500), 
(0.406250,0.921875),(0.421875,0.921875), 
(0.437500,0.906250),(0.453125,0.906250), 
(0.453125,0.890625),(0.468750,0.890625), 
(0.484375,0.875000),(0.500000,0.875000), 
(0.515625,0.859375),(0.531250,0.859375), 
(0.546875,0.843750),(0.546875,0.843750), 
(0.562500,0.828125),(0.578125,0.828125), 
(0.593750,0.812500),(0.609375,0.796875), 
(0.625000,0.796875),(0.625000,0.781250), 
(0.640625,0.765625),(0.656250,0.765625), 
(0.671875,0.750000),(0.671875,0.734375), 
(0.687500,0.718750),(0.703125,0.718750), 
(0.703125,0.703125),(0.718750,0.703125), 
(0.734375,0.687500),(0.750000,0.687500), 
(0.750000,0.671875),(0.765625,0.656250), 
(0.765625,0.640625),(0.781250,0.625000), 
(0.796875,0.609375),(0.796875,0.593750), 
(0.812500,0.593750),(0.812500,0.578125), 
(0.828125,0.562500),(0.828125,0.546875), 
(0.843750,0.531250),(0.843750,0.515625), 
(0.859375,0.515625),(0.859375,0.500000), 
(0.875000,0.484375),(0.875000,0.468750), 
(0.890625,0.453125),(0.890625,0.437500), 
(0.890625,0.437500),(0.906250,0.421875). 
(0.921875,0.406250),(0.937500,0.390625), 
(0.937500,0.375000),(0.937500,0.359375), 
(0.937500,0.343750),(0.953125,0.343750), 
(0.953125,0.312500),(0.953125,0.296875), 
(0.953125,0.296875),(0.953125,0.281250), 
(0.968750,0.250000),(0.984375,0.250000), 
(0.984375,0.234375),(0.984375,0.218750), 
(0.984375,0.203125),(0.984375,0.187500), 
(0.984375,0.171875),(1.000000,0.156250), 
(1.000000,0.140625),(1.000000,0.125000), 
(1.000000,0.109375),(1.000000,0.093750), 
(1.000000,0.078125),(1.000000,0.062500), 
(1.000000,0.031250),(1.000000,0.015625), 
(1.000000,0.000000)); 


TAM_TABLE : array(Types.WORD range 0..90) of Types.L0NG_FIXE0 := 

( 


0.00000, 

0.01746, 

0.03492, 

0.05241, 

0.06993, 

0.08749, 

0.10510, 

0.12278, 

0.14054, 

0.15838, 

0.17633, 

0.19438, 

0.21256, 

0.23087, 

0.24933, 

0.26795, 

0.28675, 

0.30573, 

0.32492, 

0.34433, 

0.36397, 

0.38386, 

0.40403, 

0.42447, 

0.44523, 

0.46631, 

0.48773, 

0.50953, 

0.53171, 

0.55431, 

0.57735, 

0.60086, 

0.62487, 

0.64941, 

0.67451, 

0.70021, 

0.72654, 

0.75356, 

0.78129, 

0.80978, 

0.83910, 

0.86929, 

0.90040, 

0.93252, 

0.96569, 

1.00000, 

1.03553, 

1.07237, 

1.11061, 

1.15037, 

1.19175, 

1.23490, 

1.27994, 

1.32704, 

1.37638, 

1.42815, 

1.48256, 

1.53986, 

1.60033, 

1.66428, 

1.73205, 

1.80405, 

1.88073, 

1.96261, 


- 111 - 




Distributed Issues Final Report 


2.05030, 2.14451, 2.24604, 2.35585, 2.47509, 2.60509, 2.74748, 2.90421, 

3.07768, 3.27085, 3.48741, 3.73205, 4.01078, 4.33148, 4.70463, 5.14455, 

5.67128, 6.31375, 7.11536, 8.14434, 9.51436, 11.43005, 14.30067, 19.08114, 

28.63625, 57.28996, Types.sqrt_large_r>umber); 

function '“"(LEFT,RIGHT : Types.LONG_FIXED) return Types.LONG_FIXED is 
RESULT : Types.LONG_FIXED; 

MULTIPLICAND^ : T ypes. LONG_F I XED := LEFT; 

MULTIPLICAND_2 : Types.LONG_FIXED := RIGHT; 
begin 

Machine_Dependent.Long_Long_Mu l (MULTIPLICAND^,MULT I PLICAND_2,RESULT); 
return RESULT; 
end M * 1 '; 

function "/"(LEFT,RIGHT : Types.LONG_FIXED) return Types.LONG_FIXED is 
QUOTIENT : Types.LONG_FIXED; 

DIVIDEND : Types.LONG FIXED := LEFT; 

DIVISOR : Types.LONG_FIXED := RIGHT; 
begin 

MachineDependent.Long_Long_0iv(01VIDEND,DIVISOR,QUOTI ENT); 
return QUOTIENT; 
end 

function "/"(LEFT : Types.LONG_FIXED; 

RIGHT ; Types.WORD) return Types.LONG_FIXED is 
QUOTIENT : Types.LONG_FIXED; 

DIVIDEND : Types.LONG_FIXED := LEFT; 

DIVISOR : Types.WORD := RIGHT; 

begin 

MachineDependent.Long_Uord_Div(DIVIDEND,DIVISOR,QUOTIENT); 
return QUOTIENT; 
end "/“; 

function """(LEFT,RIGHT : Types.METERS) return Types.METERS is 
RESULT : Types.METERS; 

MULTIPLICAND^ : Types.METERS := LEFT; 

MULT I PL ICAND_2 : Types.METERS := RIGHT; 
begin 

Machine_Dependent.Meters_Meters_Mul(MULT I PL ICANDJ,MUL TI PL ICAND_2.RESULT); 
return RESULT; 
end 

function "/"(LEFT,RIGHT : Types.METERS) return Types.METERS is 
QUOTIENT : Types.METERS; 

DIVIDEND : Types.METERS := LEFT; 

DIVISOR : Types.METERS := RIGHT; 
begin 

Machine_0ependent.Meters_Meters_0iv(01VIDEND,DIVISOR,QUOTI ENT); 
return QUOTIENT; 
end "/"; 


- 112 - 





Distributed Issues Final Report 


function “/"(LEFT : Types.METERS; 

RIGHT : Types.WORD) return Types.METERS is 
QUOTIENT : Types.METERS; 

DIVIDEND : Types METERS := LEFT; 

DIVISOR : Types.WORD := RIGHT; 
begin 

Machine_Dependent.Meters_Word_Div(DIVIDEND,DIVISOR,QUOTI ENT); 
return QUOTIENT; 
end "/"; 

function "•"(LEFT,RIGHT : Types.RATE_TYPE) return Types.RATE_TYPE is 
RESULT : Types.RATE_TYPE; 

MULTIPLICAND^ : Types.RATE_TYPE := LEFT; 

MULTIPLICAND_2 : Types.RATE_TYPE := RIGHT; 
begin 

MachineOependent.Rate_Rate_Mul(MULTIPLICANDJ,MULTIPLICAND_2,RESULT); 
return RESULT; 
end »*»; 

function "/"(LEFT.RIGHT : Types.RATE_TYPE) return Types.RATE_TYPE is 
OUOTIENT : Types.RATE_TYPE; 

DIVIDEND : Types.RATE_TYPE := LEFT; 

OIVISOR : Types.RATE_TYPE := RIGHT; 
begin 

MachineDependent.Rate_Rate_Div(DIVIDEND,01VISOR,QUOTIENT); 
return QUOTIENT; 
end "/"; 

function "/"(LEFT : Types.RATE_TYPE; 

RIGHT : Types.WORD) return Types.RATE_TYPE is 
QUOTIENT : Types.RATE_TYPE; 

DIVIDEND : Types.RATE_TYPE := LEFT; 

DIVISOR : Types.WORD := RIGHT; 

begin 

Machine_Oependent.Rate_Word_Div(DIVIDEND,DIVISOR,QUOTI ENT); 
return QUOTIENT; 
end "/"; 

function “/"(LEFT : Types.LONG_FIXED; 

RIGHT : Types.RATE_TYPE) return Types.LONG_FIXED is 
QUOTIENT : Types.LONG_FIXED; 

DIVIDEND : Types.LONG_FIXED := LEFT; 

DIVISOR : Types.RATE_TYPE := RIGHT; 
begin 

Machine_Oependent.Long_Rate_Div(DIVIDEND,DIVISOR,QUOTI ENT); 
return QUOTIENT; 
end "/"; 

function "/"(LEFT : Types.RATE_TYPE; 

RIGHT : Types,LONG_FIXED) return Types.RATE_TYPE is 
QUOTIENT : Types.RATE_TYPE; 


- 113 - 




Distributed Issues Final Report 


DIVIDEND : Types.RATE_TYPE := LEFT; 

DIVISOR : Types.LONG_FIXED := RIGHT; 
begin 

Machine_Dependent.RateJ.ong_Div(DIVID£NO,DIVISOR,QUOTIENT); 
return QUOTIENT; 
end 

function "“"(LEFT : Types.RATE_TYPE; 

RIGHT : Types.LONG_FIXED) return Types.LONG_F1XED is 
RESULT : Types.LQNG_FIXED; 

MULTIPLICAND^ : Types.RATE_TYPE := LEFT; 

MULT IPL ICAND_2 : Types.LONG_FIXED := RIGHT; 
begin 

Mach ine_Deper>dent.Rate_Long_Long_Mu l (MULTIPLICAND^ ,MULTIPLICAND_2,RESULT); 
return RESULT; 
nd "*"; 

function "“"(LEFT : Types.RATEJTYPE; 

RIGHT : Types.LONG_FIXED) return Types.RATE_TYPE is 
RESULT : Types.RAT E_TY PE; 

MULTIPLICANDJ : Types.RATE_TYPE := LEFT; 

MULTIPLICAND_2 : Types.LONG_FIXED := RIGHT; 
begin 

Machine_Dependent.RateLongRateMul(MULT I PL ICAN0_1,MULT I PL ICAND_2,RESULT); 
return RESULT; 
end 


function Power(BASE, RAISED_TO : Types.L0NG_FIXED) return Types.LONG_FIXED is 
RESULT : Types.LONG_FIXED := 1.0; 

OLO_RESULT : Types.LONG_FIXED; 
begin 

for I in 1..Types.UORD(RAISED_TO) loop 
OL0_RESULT := RESULT; 

RESULT := RESULT * BASE; 

if RESULT = OLO_RESULT then -- if no change, don't waste time 

exi t; 
end if; 
end loop; 
return RESULT; 
end Power; 

function Sin (ANGLE : Types.BAM) return Types.LONG_FlXED is 


--| SUBPROGRAM BOOT : Math.Sin 

--| Sin is a function which takes an angle in Binary Angte 

--| Measurements and uses a table lookup to find the corresponding result. 

•*| It returns the sin of the ANGLE in the Types.LONG_FIXED type. 


- 114 - 








Distributed Issues Final Report 


NEGAT : Types.WORD := 1; 

ANGLE2 : Types.WORD := Types.WORD(ANGLE); 

TEMP : Types.L0NG_FIXED; 

begin 

if ANGLE2 < 0 then 

ANGLE2 : = abs(ANGLE2); 

NEGAT := - 1; 
end if; 

if ANGLE2 > 16384 then 

TEMP := TR1G_FUNC(Types.WORD((32767 - ANGLE2)/163),S1NE); 
return TEMP * Types.LONG_FIXED(NEGAT); 
else 

TEMP := TRIG_FUNC(Types.WORD(ANGLE2/163),SINE); 
return TEMP • Types.LONG_FIXED(NEGAT); 
end if; 
end Sin; 


function Cos (ANGLE : Types.RAM) return Types.LONG_FIXED is 


SUBPROGRAM BOOT : Math.Cos 

Cos is a function which takes an angle in Binary Angle 
Measurements and uses a table lookup to find the corresponding result. 
The result is returned in the Types.LONG_FIXED type. 


ANGLE2 : Types.WORD := Types.WORD(ANGLE); 
begin 

ANGLE2 := abs(ANGLE2); 
if ANGLE2 > 16384 then 

return (-1) * TRIG .UNC(Types.WORD((32767-ANGIE2)/163),COSINE); 
else 

return TRIG_FUNC(Types.WORD(Angle2/163),COS INE); 
end if; 
end Cos; 

function Tan (ANGLE : Types.BAM) return Types.LONG_FIXED is 


-| SUBPROGRAM BOOT : Math.Tan 

■I 

-| Tan is the tangent function which takes an angle in Binary Angle 
-| Measurements and uses a table lookup to find the corresponding result. 


TANGENT : Types.LONG_FIXED; 

THETA : Types.WORD; 


- 115 - 















Distributed Issues Final Report 


begin 

Time_Stamp.Log(0048); --$TP(0048) Math.Tan start 
THETA := Types.WORD(ANGLE/182); -- approx. 182 bams per degree 

if THETA >= -90 and THETA <= 90 then 
if THETA >= 0 then 
TANGENT := TAN_TABL£(THETA); 
else 

TANGENT := -TAN_TABLE(-THETA); 
end if; 

elsif THETA < -90 then 

TANGENT := TAN_TA8LE(THETA + 180); 
else 

TANGENT := -TAN_TA8LE(180-THETA); 
end if; 

Time_Stamp.log(0049); --STPC0049) Math.Tan end 

return TANGENT; 
end Tan; 


function SqrtCX : in Types.METERS) return Types.METERS is 


SUBPROGRAM BOOT ; Math.Sqrt 

Sqrt returns the square root of a number. This routine will exit when 
the approximation of the square is close to the previous result. This 
prevents unneeded looping for accuracy. 


use Types; -- inport operators 
F : Types.METERS := X; 
r : Types.METERS := 1.0; 

OLD_Y : Types.METERS := Y; 
begin 

Time_Stamp.Log(0050); --$TP(0050) Math.Sqrt start (METERS) 
if X ■ 0.0 then 
return F; 
end if; 

for I in 1..15 loop 
exit when Y = 0.0; 

Y := ( Y ♦ F/Y ) / Types.WOR0(2); 
if Y = OLD_Y then 
ex i t ; 
end if; 

OlD_Y := Y; 
end loop; 

Time_Stanp.log(0051); -$TP(0051) Math.Sqrt end (METERS) 

return Y; 

°nd Sqrt; 

function Sqrt(X : in Types.LONG_FIXED) return Types.LONG_FIXED is 


- 116 - 








Distributed Issues Final Report 


use Types; -- import operators 
f : Types.L0NG_F1XED := X; 

Y : Types.L0NG_FIXEO := 1.0; 

OLD_Y : Types.L0MG_FIXED := Y; 
begin 

Time_Stamp.Log(0052); --$TP(0052) Math.Sqrt start (LONG_FIXED) 
if X = 0.0 then 
return F; 
end if; 

for 1 in 1..15 loop 
exit uhen Y = 0.0; 

Y :« ( Y ♦ F/T > / Types.WORD (2); 
if Y = 0LD_Y then 
exit; 
end if; 

0LD_Y := Y; 
end loop; 

Time_Stamp.Log(0053); --ITP(0053) Math.Sqrt end (LOMGFIXED) 
return Y; 
exception 

when NUMERIC_ERROR => Y := OLD_Y; 

return Y; 

end Sqrt; 


-- for RATE TYPE 

function Sqrt(X : in Types.RATE_TYPE) return Types.RATE_TYPE is 
use Types; -- import operators 
F : Types.RATE_TYPE := X; 

Y : Types.RATE_TYPE := 1.0; 

0LD_Y : Types.RATE_TYPE := Y; 
begin 

Time_Stamp.Log<0116); --$TP(0116) Math.Sqrt start (RATE_TYPE) 
if X = 0.0 then 
return F; 
end if; 

for l in 1..15 loop 
exit when Y = 0.0; 

Y := ( Y ♦ F/Y ) / Types.WOR0C2); 
if Y = oiD_Y then 
ex i t ; 
end if; 

OLO_Y := Y; 
end loop; 

Time_Stamp.Log<0117); --$TP(0117) Math.Sqrt end <RATE_TYPE) 
return Y; 
exception 

when NUMERIC_ERROR => Y := OlD_Y; 

return Y; 

end Sqrt; 


- 117 - 




Distributed Issues Final Report 


--| SUBPROGRAM BOOT : Math.Arcsin 

--| Arcsin uses an appoximation method of series expansion in order to achieve 
--| it's results. Simple constants are named to improve readability. The 
--| constants are not fully divided out beforehand to increase accuracy, but 
to improve speed, the constants could be divided beforehand and constants 
--| used to multiply the TERMS. 


function Arcsin(THETA : Types.LONG_FIXED) return Types.L0NG_F1XED is 
rad to_deg : constant Types.L0NG_F1XE0 := 57.296875; -- 180 / pi 

three : constant Types.LONG_F!XED := 3.0; 

six : constant Types.LONG_FIXED := 6.0; 

five : constant Types.LONG_FIXED := 5.0; 

seven : constant Types.LONGFIXEO := 7.0; 

fifteen : constant Types.l0NG_F!XE0 := 15.0; 

forty ; constant Types.L0NG_F1XED := 40.0; 

three_thirty_six : constant Types.L0NG_F!XED := 336.0; 

TERM1 : Types.LONG_FIXED; 

TERM2 : Types.LONG_FIXED; 

TERM3 : Types.L0NG_FIXED; 

TERM4 : Types.LONG_FlXED; 

RESULT : Types.LONG_FIXEO; 

begin 

TERM1 := THETA; 

TERM2 := Power(THETA,three); 

TERM2 := TERM2 / six; 

TERM3 := three * PowertTHETA,five); 

TERM3 := TERM3 / forty; 

TERM4 := fifteen * Power(THETA,seven); 

TERM4 := TERM4 / three_thirty_six; 

RESULT := (TERM1 + TERM2 + TERM3 ♦ TERM4) * rad_to_deg; 
return RESULT; 
end Arcsin; 

function Arctan(Z_INPUT : Types.LONG_FIXED) return Types.BAM is 


--| SUBPROGRAM BOOT : Math.Arctan 

-I 

--| a function used to return an approximation of the arctangent function. 

--| Using the Taylor series expansion: 

--| arctan z = z ■ <z**3/3) + <z**5/5) - (z**7/7) + ... (|z|<= 1 and z**2 /= -1) 
--I carried out for two terms (initially). 


Z_CUBED : Types.LONG_FIXED; 


- 118 - 









Distributed Issues Final Report 


QUOTIENT 

ARCTAN_Z 

CONV_FACTOR 

TEMP 

ARCTAN Z BAMS 


Types. LONGJIXED; 

T ypes.LONG_FIXED; 
constant Types.LONG_FIXED 
T ypes.LONGJIXED; 

Types.BAH; 


:= 10430.38; --Radians to BAMS 


begin 

Z_CUBED := Z_INPUT * Z_INPUT; --actually z**2 
Z_CUBED := Z_CUBED * ZJNPUT; -- z**3 
QUOTIENT := Z_CUBED / Types.WORD(3); 

ARCTAN_Z := ZJNPUT - QUOTIENT; 

TEHP := ARCTAN_Z * CONV FACTOR; 

ARCTAN_Z_BAMS := Types.BAH(TEMP); 
return ARCTAN_Z_BAMS; 
end Arctan; 


function Get_Random_Nun(LIMIT : Types.METERS) return Types.METERS is 


SUBPROGRAM BOOT : Math. Get JandomJlum 

This function returns a psuedo random number to the caller. It has 
three forms returning three different types for the convenience of 
Simulate.Sensor. The random number is received from the channel two 
counter. Therefore the number returned from the 

Machinej)ependent.Next JJandom call is between 0 and Machine_Dependent 
max_timer_value. This number is then multiplied by the parameter 
LIMIT, and, returned in the type of LIMIT, is a random number from 
0 to LIMIT. 


VALUE : Types.RATEJTPE; 

TEMP : Types.WORDJNDEX; 
begin 

Machine_Dependent.Next_Random(TEMP); 

VALUE := Types.RATEJYPE(TEMP) / Types.UORD( 

Machine_Dependent.maxJimer_value); 

VALUE := VALUE * Types.RATEJYPE(LIMIT); 
return Types.METERSfVALUE); 
end Get_Random_Num; 

function Get_Random_Num(LIMIT : Types.L0NG_FIXED) return Types.LONG_FIXED is 
VALUE : Types.RATEJTPE; 

TEMP : Types.WORDJNDEX; 
begin 

Machine_0ependent.Next_Random<T EMP); 

VALUE := Types.RATE JYPE(TEMP) / Types.UORDl 

Machine_0ependent.max_timer_value); 

VALUE := VALUE * LIMIT; 
return Types.LONG_FIXED(VALUE); 
end Get_Random_Num; 


- 119 - 







Distributed Issues Final Report 


function Get_Random_Num(LIMIT : Types.UORD_INDEX) return Types.WORD_INDEX is 
VALUE : Types.RATE_TYPE; 

TEMP : Types.WORDJNDEX; 
begin 

Machine_Dependent.Next_Random(TEMP); 

VALUE := Types.RAT£_TYPE(TEMP) / Types.WORD( 

MachineOependent .maxt iiner_vatue) ; 

VALUE := VALUE * Types.RATE_TYPE(LIMIT); 
return Types.WORDJNDEX(VALUE); 
end Get_Random_Num; 

end Math; 


- 120 - 




Distributed Issues Final Report 


--X UNIT: Mouse Package Spec. 

--X Effects: Provides graphics pointing device interrupt handling. 

--X Modifies: Status Mode, and Mouse_8uffer X-Y positions are updated. -- 
--X Requires: Runtime initialization of interrupt vector. 

--X Raises: Task will terminate on MCXJSE_ERROR. 

--X Engineer: M. Sperry. 


PACKAGE SPEC : Mouse 

In addition to establishing communications with the mouse, a task is 
provided which handles the receive interrupt generated by the mouse at 
COM2. This task has the pragma INTERRUPT_HANDLER and special restrictions 
apply to it's communication facilities in order to guarantee a good response 
time. 


-- Modifications Log 

-- 83-09-30 : MPS => Original created. 


with System; 
package Mouse is 


procedure Initialize; 

task Char_In is 
pragma INTERRUPT_HAN01ER; 
entry REPORT; 

for REPORT use at (16#83#,0); -- COM2 8250 serial port vector 

end Char_In; 

end Mouse; 


- 121 - 







Distributed Issues Final Report 


■■X UNIT: Mouse Package Body. 

--X Effects: Provides graphics pointing device interrupt handLing. 

--% Modifies: Status Mode, and Mouse_8uffer X-Y positions are updated. 

Requires: Runtime initialization of interrupt vector. 

-•X Raises: Task will terminate on MOUSEERROR. 

--X Engineer: M. Sperry. 


--| PACKAGE BOOT : Mouse 

The Mouse package implements the routines needed for control of a 
mouse. There is an initialization procedure which sets up the mouse 
--| for 4800 baud, no parity, 7 data bits, and two stop bits. There is 
--| also an interrupt entry task which takes data from the mouse and 
--| if a complete report is generated, gives that data to the Mouse_8uffer 
--I task. 


-- Modifications Log 

-- 88-09-30 : MPS =» Original created. 

-- 89-08-08 : MPS -> Made all references to hardware in one package. 

-- 89-12-06 : TEG => Shut off mouse interrupts during init. Added support 

for Restarting the system using RESE7&MOOE buttons. 

with Types; 
with Low_Level_IO; 
with Debug_IO; 
with Mouse_Buffer; 

with Mouse_0ata; -- provides constants and data structures 

with Status; 

with Interrupt_Control; 

with Time_Stamp; 

with HU_Config; 

with Oistrib; 

use Low_Level_I0; 

use Mouse_Data; -- visibility to "and" function 

pragma ELABORATE<low_Level_IO, Debug_IO, MouseBuffer. Status, Time_Stamp); 

package body Mouse is 

0ATA : tow_level_IO.BYTE; -- char from mouse 

BUTTON_PUSHED : Mouse_Data.BIT_FIELD; -- array representing keys 

STATUS_BYTE : Mouse_Data.BIT_FIELD; -- represents status errors 

PREV_8UTT0N_PUSH : Mouse_0ata.8!T_F!EL0 := (others =» FALSE); --previous buttons 
MOUSE_INPUT : Mouse_Data.RAW_MOUSE_UORD := (0,0,0);-- transform to 12-bit 


- 122 - 








Distributed Issues Final Report 


MOUSE JIEPORT 
REPORTCOUNT 
CHANGE_REQUESTED 
MOUSE ERROR 


Mouse J)ata.SIGNED_MOUSE JJORO; 
Types.WORD range 0..5 := 0; 
BOOLEAN : = FALSE; 

EXCEPTION; 


transformation to signed 
counts* byte in report 
rendezvous with status? 


T EMP_X 
TEMP Y 


: Types.WORD; 
: Types.WORD; 


-- local copy of X motion 
-- local copy of Y motion 


procedure Initialize is 


-| SUBPROGRAM BOOY : Mouse.Initialize 

-I 

-| Initialize sets up the mouse at 4800 baud, no parity, 7 data bits, and 
-| two stop bits. The number of stop bits is insignificant. There should 
-| only be two formats that the mouse can be in, either relative bit pad one 
-| or Micrsoft Mouse. The default on power up for the mouse is MM at 4800. 

-| The mouse must be commanded in the following order: BAUD (which is set to 
-| default to 4800 so it is not necessary to reprogram it), U of reports/sec., 
-| and then format of the reports. The mouse used is a Logitech Serial Mouse 
-| as described in hwconfig.as. The mouse is programmed with Relative Bit 
-| Pad One format which has five bytes of data associated with it. 


INTERRUPTS : Low_Level JO.BYTE; -- for Input of 8259 ints 

RESPONSE : LowJ.evel_IO.BYTE; -- for mouse responses 

TIME_OUT : INTEGER := 30000; -- time out for mouse response 

begin 

-- Disable receive interrupts 

Send_Control(HW_Config.C0M2_int_enable,Mouse_0ata.specific_int_disable); 

Receive_Control(HW_Config.COM2_status,RESPONSE); -- clean out junk in status 
Receive_Control(HW_Config.C0M2_data,RESPONSE); -- cleanout junk in data 

Send_Control(HW_Config.COM2_control,Mouse_Data.access_baud); 
Send_Control(HW_Config.C0M2_data,Mouse_Data.host_baud); -- set BAU0 = 4800 
-- set COM2 serial parameters 

Send_Cont rol(HU_Config.C0M2_control,Mous e_D a t a. h os t _f o rma t); 
Send_Control(HU_Config.C0M2_data,Mouse_Data.acknowledge); -- wakeup mouse 
loop 

Receive_Cootrol(HW_Config.C0M2_status,RESPONSE); -- wait for response 

if RESPONSE * Mouse_Data.data_new then 
Receive_Control(HW_Config.C0M2_data,RESPONSE); -- clear out byte 

ex i t ; 
else 

TIMEJXJT := TIMEJXJT - 1; 
end if; 

if TIMEJXJT = 0 then 
exit; 
end if; 
end loop; 

if TIMEJXJT = 0 then 

Oebug_IO.Put_Line("Unable to establish communications with mouse."); 


- 123 - 








Distributed Issues Final Report 


end if; 

Send_Controi(HW_Config.C0M2_data,Mouse_Data.mouse_char_speed) ; 

delay 0.01; -- stow for mouse input buffer 

Send_Control(HW_Config.COM2_data,Mouse_Data.mouse_format); 

Send_Control(HU_Config.COM2_modem_control,Mouse_Data.general_int_enable); 

Send_Control(HW_Config.C0M2_int_enable,Mouse_Data.specific_int_enable); 

Receive_Control(HU_Config.pic_8259_mr,INTERRUPTS); 

-- enable COM2 in PIC in line below 
INTERRUPTS := Mouse_0ata.8its_to_8yte 

(Mouse_Data.8yte_to_Bits(INTERRUPTS) and Mouse_Data.pic_and_mask); 
Send_Control(HW_Config.pic_8259_mr,INTERRUPTS); 
end Initialize; 


task body Char_In is 

--| TASK BOOT : Mouse.Charln 

--| One of the main tasks used to move the reticle around the battlefield 
--| screen. The task rendezvous with the graphics task reporting positions 
--| every 28 milliseconds, unless the middle button is pressed (MODE) changing 
-*| the mode to AUTOMATIC. In this event, the mouse simply waits for a change 
-*| to MANUAL, since automatic mode is controlled by the rocket task. The mouse 
task will not rendezvous with the graphics task until set to MANUAL. When 
--| in MANUAL mode, the task (upon completion of one report) will rendezvous 
with the graphics task at high priority to report it's position. It will 
--| then change the status task's shared variables if any need to be changed. 

--| If one does, and the status task has completed it's previous work and gone 
--| to an accept state, then the mouse task wakes it up. Because the mouse 
--| is programmed with Relative Bit Pad One format and needs five bytes of data 
--| in order to complete its report, after the first byte has come in, it is 
--| only 2 milliseconds until the next byte comes in until five bytes have been 
-*| received. Then there is a gap of 18 milliseconds until the next byte will 
-*| be seen (assuning constant motion of the mouse). This is why there is 
-•| ' ery little processing of data until the fifth byte. It is entirely possible 
--| because the mouse is an asychronous device that up to three reports may be 
-*| generated and handled in one interval. This worst case must be accounted 
--| for in timing considerations. 

use Status; 
use Types; 

begin 
loop 

accept Report do 

--*TP(0056) Mouse task start 

Receive_Control(HU_Config.COM2_status,DATA); -- receive status 
STATUS_8YTE := Mouse_0ata.Byte_to_8its(DATA);--check statusbyte for errors 
if STATUS_BYTE(Mouse_Oata.overflow) or 


-- for visibility to “=" 
- - for visibility to 


- 124 - 









Distributed Issues Final Report 


STATUS JiYTE(Mouse_Data.framing) then 
REPORT_COUNT := 0; -- start a new report 

Receive_Control(HW_Config.C0M2_data,DATA); -- clear out data port 
else 

Receivejontrol (HWJonf ig.C0M2_data,DATA); -- get valid data 
if DATA > Mouse_Oata.sync_byte then -- check for new report 

REPORT_COUNT := 1; -- start of new report 

end if; 
end if; 

case REPORT_COUNT is -- convert data to mouse X,Y 

when 1 => -- or buttons. 

8UTT0N_PUSHED := Mouse_Data.Byte_to_Bits(DATA); 

REPORT_COUNT := REP0RT_C0UNT + 1; 
when 2 -* 

MOUSEJNPUT.LOW := Mouse J)ata.Bytejo_8it6(DATA); 

REPORT JIOUNT := REPORT JOUNT + 1; 
when 3 =» 

MOUSEJ NPUT. HIGH := Mouse J)ata.Bytejo_Bi t6(0ATA); 

M0USE_REP0RT := Mouse Data.Raw to_Signed(MOUSEJNPUT); 

TEMP_X := MOUSE_REPORT.LOU12; 

REPORT CCXJNT := REPORT COUNT ♦ 1; 
when 4 => 

MOUSEJNPUT.LOW := House_Oata.Byte_to_Bit6(DATA); 

REPORTCOUNT ;= REPORT_COUNT + 1; 
when 5 => 

-- don't move mouse if any buttons pushed. 

if (not BUTTON_PUSHED(Mouse_Data.reset)) and -- guarantee only one - 
(not BUTTON_PUSHEO(Mouse_Oata.mode)) and-- rendezvous per report 
(not BUTTON_PUSHED(Mouse_Data.launch)) then -- (RTE bug) - 
PREV_BUTTON_PUSH(Mouse_Data.reset) := FALSE; 

PREV_BUT T0N_PUS H(Mouse_Da ta.mode) := FALSE; 
PREV_BUTTON_PUSH(House_Qata.launch) FALSE; 

MOUSEJNPUT.HIGH := Mouse_Qata.8yte_to_Bit6(DATA); 

MOUSE_REPORT := Mouse_Data.Raw_to_Signed(MOUSE_INPUT); 

TEMP_Y := MOUSE_REPORT.L0U12; 
if Status.MODE = Status.MANUAL then 
MOUSE_BUFFER.MOUSE_X := TEMP_X; 

MOUSE_BUFFER.MOUSEJ := TEMPJ; 

--STP(0057) Mouse rendezvous with Save start 
select -- must be conditional to work in INTERRUPTJANDLER 
Mouse JJuffer.Save.Reticle_Motion; 

--STP(0058) Mouse rendezvous with Save end 
else 
null; 

end select; 
end if; 
else 

A BUTTON IS DEPRESSED. FIRST LOOK AT "RESET" BUTTON 
if BUTTON_PUSHED(Mouse_Data.reset) and 


- 125 - 







Distributed Issues Final Report 


not PREV_BUTTON_PUSH(Mouse_Data.reset) then 
for I in Status.RESET_STATUS_TYPE loop 
Status.STATUS_CONTROL(I).DATA := 0; 
status.STATUS_CONTROL(I).01 SPLAYED := FALSE; 
end loop; 

Status.REQ_C0UNT := Status.REQ_COUNT + 1; 

CHANGE_REQUESTED := TRUE; 

PREV_BUTTON_PUSH(Mouse_Data.reset> := TRUE; 
else 

PREV_8UTT0N_PUSH(Mouse_Data.reset) := FALSE; 
end if; 

NOW LOOK AT MOOE BUTTON... 

When the MOOE button is pushed, check to see if the RESET button is 
currently active. If so, then do a system reset! 

if BUTTON_PUSHED(Mouse_Data.mode) then 
if BUTTON_PUSHED(Mouse_Oata.reset) then 
Distrib.Restart; -- perform system shutdown 

elsif not PREV_BUTTON_PUSH(Mouse_Data.mode) then 
if Status.MOOE = Status.MANUAL then -- Change mode 
Status.MOOE := Status.AUTOMATIC; 
else 

Status.MOOE := Status.MANUAL; 
end if; 

Status.MOOE_DISPLATEO := FALSE; 

Status.REO_COUNT := Status.REQ_C0UNT + 1; 

CHANGE_REQUESTED := TRUE; 

PREV_BUTTON_PUSH(Mouse_0ata.mode) := TRUE; 
end if; 
else 

PREV_BUTTON_PUSH(Mouse_Data.mode) := FALSE; 
end if; 

FINALLY, LOOK AT LAUNCH BUTTON 

if BUTTON_PUSHED(Mouse_Oata.launch) and 

not PREV_BUTTON_PUSH(Mouse_Data.launch) then 
if Status.MOOE = Status.MANUAL then 
Mouse_Buffer.LAUNCH := TRUE; 

MouseJJuffer.NEW_ABS_X := Mouse_8uffer.0L0_A8S_X; 

Mouse_Buffer.NEW_ABS_Y := Mouse_8uffer.0LD_A8S_Y; 
end if; 

PREV_BUTTON_PUSH(Mouse_Data.launch) := TRUE; 
else 

if not BUTTON_PUSHED(Mouse_Data.launch) then 
PREV_BUTTON_PUSH(Mouse_Data.launch) := FALSE; 
end if; 
end if; 

if CHANGE_REOUESTEO and then Status.REQ_COUNT = 1 then 
--$TP(0059) Mouse rendezvous with Status start 


- 126 - 






Distributed Issues Final Report 


select 

Status.Update.Signal; 

--STP(0060) Mouse rendezvous with Status end 
else 
null; 

end select; 
end if; 
end if; 

CHANGEJIEQUESTED := FALSE; 

REPORTCOUNT := 0; 
when others => null; 
end case; 

Ser>d_Control<HW_Conf ig.pic_8259,Mouse_0ata.spec_eoi); -- specific Eol 
--$TP(0061) Mouse task end 
end Report; 
end toop; 
end Char_ln; 

end Mouse; 


- 127 - 







Distributed Issues Final Report 


--% UNIT: MouseJJuffer Package Spec. 

Effects: Buffers mouse data input, translates it to pixel system. 
--% Modifies: No global data is modified (other than in oun spec). 

Requires: No initialization is required. 

--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: M. Sperry. 


--| PACKAGE SPEC : Mouse_Buffer 

--| Package Mouse_Buffer contains a task called Save which is responsible 
for saving reports of mouse movement via a rendezvous with an interrupt 
--| task. The task then rendezvous with the display task to relocate the 
--| reticle. The shared variables of the X and Y positions as well as the 
--| launch flag are contained here. The mode flag is contained in the 
--| status package specification. 


-- Modifications Log 

-- 88-10-24 : MPS => Original created. 


with Types; 
with Config; 

package Mouse_Buffer is 


stack_size : 

: constant := 

118; 

-- in bytes 

M0USE_X 

T ypes.WORD; 

-- 

for use with the Save task in Mouse Buffer 

MOUSE_Y 

Types.WORD; 

-- 

for use with the Save task in Mouse Buffer 

LAUNCH 

BOOLEAN := 

FALSE; 


0L0_A8S_X 

Types.WORD; 

-- 

absolute X position of Reticle on Screen 

0LD_ABS_Y 

Types.WORD; 

-- 

ii y it m n 

NEW_ABS_X 

Types.WORD; 

-- 

for use by ENGAGE (latched values by Mouse pkg) 

NEW_ABS_Y 

Types.WORD; 




task type Save_Type is 
entry Reticle_Motion; 
pragma PR IOR ITY(Config.save_priority); 
end Save_Type; 

for Save_Type'STORAGE_SIZE use 1NTEGER(Config.bytes_per_storage_unit * 

stack_size); 

Save : Save_Type; -- for saving motion of mouse to display 

end Mouse_Buffer; 


- 128 - 








Distributed Issues Final Report 


--X UNIT: Mouse_Buffer Package Body. 

--X Effects: Buffers mouse data input, translates it to pixel system. 
--X Modifies: No global data is modified (other than in own spec). 

-•X Requires: No initialization is required. 

--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: M. Sperry. 


--| PACKAGE BODY : Mouse_Buffer 

--| Package body Mouse_Buffer is responsible for the implementation of the 
--| buffering between the mouse interrupt routine and the screen. Note that 
--| checks are performed to be sure that the reticle is within the screen 
-•| defined by Config. Also, note that the Y coordinate is reversed because 
--| the screen on the EGA runs (in the Y direction) from 0 to 349 starting 
--| from the upper left and moving down, i.e., the mouse has Y direction as 
--| positive moving up, and the EGA has Y positive moving down. 


-- Modifications Log 

-- 88-10-24 : MPS => Original created. 


with Shapes; 

with Graphics; 

with Config; 

with Oebug_IO; 

with Interrupt_Control; 

with Time_Stamp; 

pragma ELABORATE(Debug_IO, Graphics, Interrupt_Control, Time_Stamp); 
package body Mouse_Buffer is 

use Types; -- neeued for visibility to 


task body Save_lype is 


list len 


: constant := 1; 


left_limit 
right_limit 
top_limit 
bottom limit 


constant 

constant 

constant 

constant 


Config.battlefield_screen_left; 
Config.battlefield_screen_right; 
Config.battlefield_screen_top; 
Config.battlefield_screen_bottom; 


PRIORITY 
WORK LIST 


: Graphics.PRIORITY_TYPE := Graphics.HIGH; 

: Graphics.MOVE_LIST_TYPE(list_len .. list_ten);-- 1 item (reticle) 


TEMP_X 


: Types.UORO; 


- 129 - 





Distributed Issues Final Report 


TEMP_Y : Types.WORD; 

begin 

- Initial display of reticle 

UORKJ.lST(list_len).XY_OLD := (Config.battlefield_center_x, Config.battlefieldcentery); 
WORK_LIST(list_len).XY_NEW := (Config.battlefield_center_x, Config.battlefieldcentery); 
WORK_LIST(list_len).08JECT := Shapes.RETICLE; 

WORK_LIST(list_len).COLOR := Graphics.reticle_color; 

Graphics.Display.Move(PRIORITY, WORK_LlST); 

loop 
begin 

Time_Stamp.Log(0062); 
accept Reticle_Motion; 

-- Get new positions of reticle (mouse) 

Interrupt_Control.Disable; 

TEMP_X := WORK_LIST(list_len).XY_OLD.X + MOUSE_X; 

TEMP_Y := WORK_LIST(list_len),XY_OLD.Y - MOUSE_Y; 

Interrupt_Control.Enable; 

Check bounds of reticle; don't let it go past edge of battlefied screen. 

if (TEMP_X + Shapes.RETICLE_LEFT) < left_limit then 
TEMP_X left_limit - Shapes.RETICLE_LEFT; 

elsif (TEMP_X + Shapes.RET ICLE_RIGHT) > right_limit then 
TEHP_X := right_limit - Shapes.«ETICLE_RIGHT; 
end if; 

if (TEHP_Y + Shapes.RETICLE_TOP) < top_limit then 
TEMP_Y := top_limit - shapes.reticle_top; 
elsif (TEMP_Y ♦ Shapes.RET ICLE_B0TT0H) > bottom_limit then 
TEMP_Y := bottom_limit - Shapes.RET!CLE_SOTTQM; 
end if; 

UORK_LIST(list_len).XY_NEW.X := TEMP_X; 

WORK_LIST(list_len).XY_NEW.Y := TEMP_Y; 


-• exception block 

--$TP(0062) Mouse Buffer task and accept 


update global accessable values 

lnterrupt_Control.Disable; 

0L0_A8S_X := TEMP_X; 

0LD_ABS_Y := TEMP_Y; 

Interrupt_Control.Enable; 

iime_Stamp.Log(0063); --STP(0063) Mouse_8uffer rendezvous with Graphics stait 
Graphics.Oisplay.Move(PRIORITY, UORX_LIST); 


- 130 - 





Distributed Issues Final Report 


Time_St3mp.Log<0064); --$TP(0064) Mousejiuffer rendezvous with Graphics end 

U0RIC_LIST(list_len).XY_0lD := UORKL1ST(list_len),XY_NEU; 
exception 
when others => 

Debug_lO.Put_Line("Error in Save"); 
end; -- exception block 

Time_Stamp.Log(0065); --$TP(0065) House_Buffer task end 
end loop; 

end Save_Type; 

end Mouse_Buffer; 


- 131 - 






Distributed Issues Final Report 


--XUN1T: Mouse_0ata Specification. 

■■X Effects: Provides relevant data structures and constants. 
■•X Modifies: Nothing. 

Requires: Nothing. 

--% Raises: Nothing. 

--% Engineer: M. Sperry. 


--| PACKAGE SPEC : Mouse_Data 

--| Package Mouse_Data provides the data structures and constants necessary 
--| to intialize and run a Logitech C7 serial mouse at <*800 baud, no parity, 7 
--| data bits, and tuo stop bits. The Logitech mouse is capable of 8 different 
formats. Relative Bit Pad One is chosen here because it allows twelve 
--| bits of motion data for each repo t. Although this creates more work in 
--| the processing of each byte of data (there are five bytes of data in each 
--| report) there is more accuracy in the pointing device. 

--| The mouse controls the movement of the reticle (defined in the Graphics 
**| package) by receiving a report, generating the motion in X and Y 
--| coordinates, and sending these values to package Mouse_Buffer for 
--| processing (task Save). 

-| The reports come in 28 msecs apart with a 2 msec interval between each 
byte of the report. A report consists of the following in Relative Bit Pad 
--I One: 


-1 

p 

6 

5 

4 

3 

2 

1 

0 

= bit number 

' 1 
-1 

np 

1 

0 

L 

M 

R 

0 

0 

8yte 1 (minimum value = 64) 

-1 

np 

0 

X5 

X4 

X3 

X2 

XI 

X0 

Byte 2 

-1 

np 

0 

XII 

X10 

X9 

X8 

X7 

X6 

Byte 3 

-1 

np 

0 

Y5 

Y4 

Y3 

Y2 

Y1 

Y0 

Byte 4 

-1 

np 

0 

Y11 

Y10 

Y9 

Y8 

Y7 

Y6 

Byte 5 

-1 

\- 

no 

parity 








L,M,R above stands for Left, Middle, and Right buttons; 1 = key pressed. 
The mouse is located at COM2 on an AT which is base address 2F8 (hex). 


- Modifications Log 

- 89-04-15 : MPS => Original created. 

- 89-08-08 : MPS => Defined COM2 addresses in HU_Config. 


with Types; 

with Low_Levet_IO; 

with Unchecked_Conversion; 

with HW_Config; 

use Low_Level_IO; 


- 132 - 










Distributed Issues Final Report 


package Mouse_Data is 

spec_eoi : constant Low_Level_IO.BYTE := 16#63#;--specific end int 

sync_byte : constant Low_Level_IO.BYTE := 63; -- used to sync reports 

-- The following constants are bit masks to be used with the BIT_FI ELD type. 


reset 

: constant 

:= 4; 

-- left button (reset statistics) 

mode 

: constant 

:= 3; 

-- middle button (change mode) 

launch 

: constant 

:= 2; 

-- right button (fire rocket) 


-- These constants are declared to aid in detecting serial errors during 
-- transmision. 

overflow : constant := 1; -- position from status (2FD) 

framing : constant := 2; -- position from status (2FD) 

-- Because the data bits are received six bits at a time, the following record 
-- representation clauses are used to convert two bytes of data (a least and 
-- most significant) to a single signed twelve bit number. 

type BIT6TYPE is range 0 .. 63; 
type GAP_TYPE is range 0 .. 15; 

type RAU_MOUSE_UORD is 
record 

LOU ; BIT6_TYPE; 

HIGH ; BIT6_TYPE; 

GAP : GAP_TYPE; 
end record; 

for RAU_MOUSE_UORD use 
record 

LOU at 0 range 0 .. 5; 

HIGH at 0 range 6 .. 11; 

GAP at 0 range 12 .. 15; 
end record; 

least_low12 : constant := -2048; 

type SIGNED_MOUSE_UORO is 
record 

LOU12 ; Types.UORD range least_low)2 .. 2047; 

GAP : Types.UORD range 0 .. 15; 
end record; 

for SIGNED_MOUSE_UORD use 
record 

L0U12 at 0 range 0 .. 11; 

GAP at 0 range 12 .. 15; 


- 133 - 





Distributed Issues Final Report 


end record; 

-- Most significant bit for the following type definition on TANDY 4000 : 15 

type BIT_FI ELD is array(0..15) of 800LEAN; 
pragma pack(BIT_FIELD); 
for BITFIELD'size use 16; 

function Raw_to_Signed is new Unchecked_Conversion<RAW_MOUSE_UORD, 

SlGNED_MOUSE_UORD); 

function Byte_to_8it6 is new Unchecked_Conversion(Low_level_I0.BYTE,BIT6_TYPE); 
function Bits_to_Byte is new Unchecked_Conversion(BIT_FIELD,Low_Level_IO.BYTE); 
function Byte_to_Bits is new Unchecked_Conversion(Low_level_IO.BYTE,BIT_FIELD); 

pic_and_mask : constant BIT_FI ELD : = 

(TRUE,TRUE,TRUE,FALSE,TRUE,TRUE,TRUE,TRUE,TRUE, 

TRUE,TRUE,TRUE,TRUE.TRUE,TRUE,TRUE); -- will enable level 03 (COM2) 

-- The following constants are used in the initialization procedure of mouse. 

-- They are used to access the serial port COM2 on a TANDY PC (386). 

access_baud : constant low_Level_IO.BYTE := 16#80#; 

-- access baud rate rgtrs. 

host_baud : constant Low_Level_IO.BYTE := 16#1B#; 

-- 4800 baud (30h = 2400) 

host_format : constant Low_level_(O.BYTE := 16#T£#; 

-- 4800,e,7,1 

acknowledge : constant low_Level_IO.BYTE := 16#20#; 

-- mouse responds w/06h when 

ack_response : constant LowJ.evel_I0.8YTE := 16806#; 

-- sent a space (20h) 

data_new : constant Low_Level I0.8YTE := 168618; 

-- char received 

mouse_format : constant Low_Level_!0.BYTE := 168428; 

-- Relative Bit Pad One 

mouse_char_speed : constant low_LevelJO.BYTE := 1684C8; 

-- 35 reports/sec when moving 

general jnt_enable : constant Low_Level_!0.BYTE := 168088; 

-- for modem control register 

specific_int_disable : constant Low_Level_I0.BYTE := 16#00#; 

-- disable receive interrupt 

specific_int_enable : constant Low_Level_I0.BYTE := 16#C1#; 

-- enable receive interrupt 

pic_8259_mr : constant Low_Level_IO.PORT_ADDRESS := 16#21#; 

end Mouse_Data; 


- 134 - 








Distributed Issues Final Report 


--% UNIT: Parameter Oata Base Spec. 

--% Effects: Provides rocket data types and initial values. 
••X Modifies: No global data is modified. 

--X Requires: No initialization is required. 

--X Raises: No exceptions. 

--% Engineer: R. Chevier 


--| PACKAGE SPEC : Parameter_0ata_8ase 

**| This package defines the necessary default values for the rocket and 
**| the targets. There are four different target types described in 
--| Simulate.Sensor.Targ_Sup. The type of rocket used to attack these targets 
-*| is described by the values below. 


with Types; 

package Parameter_Data_Base is 


ROCKET VALUES 


type OEGREES_TYPE is digits 6 range 0.0..360.0; 
type RATE_TYPE is digits 5; 

subtype MAX_ROCKET_RANGE is Types.WORD range 1..100; 


MAX_DEGRADED_ROCKETS : MAX_ROCKET_RANGE := 1; 

type MASS_TYPE is digits 5 range 10.0..100.0, 

type THRUST_TYPE is digits 6 range 100.0..100000.0; 

type BURN_RATE_TYPE is digits 5 range 0.001..10.0; 

type RESISTANCE_TYPE is digits 5 range 0.001..100.0; 

type OR IFT_VELOCITY_TYPE is digits 5 range 0.0..0.5; 

subtype ROCKET_TURN_ACCEl_TYPE is RATE_TYPE range 0.01..1000.0; 


cjnass 

: constant 

; = 

40.0; 

c_fuel 

: constant 

: = 

300.0; 

c_thrust 

: constant 

: = 

6000.0; 

c_burn_rate 

: constant 

: = 

5.0; 

c_turn_burn_rate 

: constant 

: = 

0.05; 

c_forward_drag 

: constant 

: = 

0.1875; 

c_side_drag 

: constant 

: = 

0.203125 

c_drift 

: constant 

: = 

0.0; 

c_turn_rate 

: constant 

: = 

200.0; 


kgs 

Vgs 

Newtons 

kgs/sec 

kgs/degree 

Newton-secs/meter (was 0.09375) 
Newton-secs/meter 
meters/sec 
degrees/sec 


type ROCKET_PARAMETER_TYPE is record 
MASS : Types.LONG_FIXE0 := c_mass; 

FUEL : Types.L0NG_FIXED := c fuel; 


- 135 - 












Distributed Issues Final Report 


THRUST 
BURN_RATE 
TURN_BURN_RATE 
FORWARD_0RAG 
SIDE_0RAG 
DRIFT 
TURN_RATE 
end record; 


Types.LONG_FIXED : = 
Types.LONG_FIXED := 
T ypes.L0NG_FIXED : = 
Types.LONG_FIXED := 
Types.LONG_F!XED := 
Types.LONG_FIXED : = 
Types.LONG_FIXED 


c_thrust; 

c_burn_rate; 

c_turn_burn_rate; 

c_forward_drag; 

c_side_drag; 

c_drift; 

c_turn_rate; 


TARGET VALUES 


type TARGET_PARAMETER_TYPE is record 
MAX_VELOCITY_Y : Types.METERS; -- maximum velocity in Y per interval 

MAX_VELOCITY_X : Types.METERS; -- maximum velocity in x per interval 

DELTA_VELOCITY_X : Types.METERS; -- maximum change in x per interval 

CHANGE_DIR_FREQ : Types.UORD INDEX; •• r'req tnat x dtr changes in intrvls 

end record; 

type TARGET_PARAMS_ARRAY is array(Types.TARGET_CLASS_TYPE) of 

TARGET_PARAMETER_TYPE; 

TARGET_PARAMS ; TARGETPARAMSARRAY := 

( Types.UNKNOWN =» 


( MAXVELOCITY_Y 

S> 

2.000 

MAX_VEL0CIT Y_X 

= > 

1.500 

DELTA_VELOCITY_X 

= > 

0.125 

CHANGE_0IR_FREO 

= > 

25), 

Types.T80 => 

( MAX_VE LOCIT Y_Y 

= > 

1.750 

MAX_VEL0CITY_X 

= > 

1.250 

OELTA_VELOCITY_X 

= > 

0.125 

CHANGE_0IR_FREQ 

= > 

21), 

Types.SA9 => 

( MAX_VELOCITY_Y 

= > 

1.875 

MAX_VELOCITY_X 

= > 

1.375 

DELTA_VELOCITY_X 

= > 

0.125 

CHANGE_DIR_FREO 

= > 

23), 

Types.BMP2 => 

( MAX_VELOCITY_Y 

= > 

1.250 

MAX_VELOCITY_X 

= > 

0.875 

DELTA_VE10CITY_X 

= > 

0.125 

CHANGE_0IR_FREQ 

= > 

15)); 


-- To simplify, all target types currently have the same DELTA_VE10CITY_X 
-- (meaning the same acceleration) and the same pixel size representation. 
-- Therefore, they all have the same right and left border limits, and 
-• consequently are all created within these borders. 

right_border_limit : constant := 3940.0; 


- 136 - 









Distributed Issues Final Report 


left_border_limit : constant 

x_start_limit : constant 

target_start_y : constant 

target_start_z : constant 

end Parameter Data_Base; 


60.0; 

right_border_limit - teft_border_limit; 
3960.0; 

0 . 0 ; 


- 137 - 





Distributed Issues Final Report 


UNIT: RDL Package Body Subunit. 

Effects: Supports all Rocket Data Link functions of Simulator. 
■■X Modifies: No global data is modified. 

--X Requires: No initialization is required. 

Raises: No explicitly raised exceptions are propagated 

--X Engineer: T. Griest. 


--| PACKAGE BOOT : Simulate.RDL (Rocket Data Link) 

--| The RDL package provides tasks to interface to the Rocket Data Link 
--| issuing messages for new rocket positions and receiving messages 
--| commanding new rocket attitudes. 


- - Modifications Log 

-- 88-10-30 : TEG => Original created. 


separate(Simulate) 

package bodv rdl is -- Rocket Data Link Simulator 

stacksize : constant := 348; 

task type Rock_Sup_Type is 

pragma PRIORITY(Config.rock_sup_priority); 
end Rock_Sup_Type; 

for Rock_Sup_T ype'STORAGES IZE use INTEGERCConfig.byt es_per_storage_unit * 

stack_size); 

Rock_Sup : Rock_Sup_Type; 
task body Rock_Sup_Type is separate; 
task body Report_Buf_Type is separate; 
task body Guide_Buf Type is separate; 
end ROL; 


- 138 - 









Distributed Issues Final Report 


UNIT: Report_Buf Task Body Subunit. 

Effects: Buffers Rocket report data between simulator and Control. -- 
Modifies: No global data is modified. 

--X Requires: No initialization is required. 

Raises: No explicitly raised exceptions are propagated. 

Engineer: T. Griest. 


-•| TASK BOOT : Simulate.RDL.Report_8uf 

--| The Report_Buf task acts as a buffer between the rocket data link 
--| support task RockSup and the Rocket.Control task which processes 
--| the rocket data. The task contains only accept statements for 
--| rendezvous purposes to allow for schedule slippage from both sides. 

--| The data is a list of the rockets new positions as they fly across 
--| the battlefield. Rocket.Control is the receiver of this list and 
--| Rock_sup is the supplier. This routine should be contrasted to Guidebuf. 
-*| Note that if for some reason the Rock_Sup fails to deliver new rocket 
--| positions. Rocket.Control will still display the old positions (but only 
--| for one interval, after which if they are still missing are considered 
--| to have destroyed themselves). Note also that even if there are no rockets 
--| active, that a list is still passed with a length of zero. 


Modifications Log 

88-11-30 : TEG => Original created. 


with Debug_I0; 
with Time_Stamp; 

separate (Simulate.ROL) 

task body Report_Buf_Type is 
use Types; 

MSG_C0UNT : Types.WORD := 1; 

ROCKET_MSG : Rocket.ROCKET_MSG_TYPE; 

begin 

ROCKET_MSG.NUM_ROCKETS := 0; -- default 

loop 
select 

accept Put_Report(DATA : in Rocket.ROCKET_MSG_TYPE) do 
Time_Stamp.log(0066); --$TP(0066) Report_8uf accept Put_Report start 
ROCKET_MSG.NUH_ROCKETS := DATA.NUM_ROCKETS; -- copy data 

ROCKET_MSG.ROCKET_ltST(Types.WORD_IN0EX(1)..DATA.NUM_ROCKETS> := 

OATA.ROCK£T_lIST(Types.WORD_INOEX(1)..DATA.NUM_ROCKETS); 
MSG_C0UNT := 1; 

Time_Stamp.Log(0067); --$TP(0067) Report_Buf accept Put_Report end 


-139 









Distributed Issues Final Report 


end Put_Report; 
or 

when MSG_C0UNT = 1 => 

accept Get_Report(DATA : out Rocket.ROCKET_MSG_TYPE) do 

Time_Stamp.log(0068); --STPC0068) Report_Buf accept Get_Report start 
DATA.NUM_ROCKETS := ROCKET_MSG.NUM_ROCKETS; 

DATA.ROCKET_L!ST(Types.WORD_INDEX(1). .ROCKET_MSG.NUM_ROCKETS) : = 

ROCKET_MSG.ROCKET_L!ST(Types.UORD_INDEX(1). .ROCKET_MSG.NUM_ROCKETS); 
MSG_COUNT := 0; 

Time_Stamp.Log(0069); --$TP(0069) Report_Buf accept Get_Report end 

end Get_Report; 
end select; 
end loop; 
exception 

when others => 

Debug_IO.Put_Line("REPORT_BUP termination due to exception."); 
end Report_Buf_Type; 


- 140 - 






Distributed Issues Final Report 


•X UNIT: Rocket Package Spec. 

-X Effects: Provides structure for Rocket managment within BDS. 
-X Modifies: No global data is modified. 

-X Requires: No initialization is required. 

-X Raises: No explicitly raised exceptions are propagated. 

-X Engineer: T. Griest. 


--| PACKAGE SPEC : Rocket 

--| This package contains the declaration to the control task which is 
-*| the main rocket processing task. It also declares the two main types 
--| used for processing rocket information. 


- Modifications Log 

- 88-11-05 : TEG => Original created. 


with Types; 
with Config; 
with Sync; 

package Rocket is 

stack_size : constant := 1936; -- in bytes 


REPORT INFORMATION 


type ROCKET_ITEM_TYPE is record -- provides essentials on a rocket 

SYNC_TAG : Sync.SEQ_TYPE; 

ROCKETJD : Types.WORDJNDEX; 

POSITION : Types.POSITIONJYPE; 

end record; 

type ROCKET_LIST_TYPE is -- list of all rocket data 

array(Types.UORD_INOEX range <>) of ROCKET J TEMJYPE; 

type ROCKET_MSG_TYPE is record 

NUM_ROCKETS : Types.WORDJNDEX; 

ROCKETJIST : ROCKET JI ST JYPE< 1..Config.maxjockets); 

end record; 


GUIOANCE INFORMATION 


type ROCKET_GUIDE_TYPE is record 


- 141 - 










Distributed Issues Final Report 


ROCKETJD : Types.WOROJNDEX; 

AIMPOINT : Types. AIMPOINT JYPE; 

end record; 

type ROCKET_GUIDE_LIST_TYPE is -- list of all guidance data 
ar ray (Types. WORD JIIOEX range <>) of ROCKET_GUIDE JYPE; 

type ROCKET JiU IDE JiSG JYPE is record 
NUM_ROCKETS : Types.WOROJNDEX; 

ROCKETGUIDE LIST : ROCKET GUIDE JIST TYPEOI. .Conf ig.max rockets); 
end record; 

task type ControlJype is -- for overall engagement control 

entry Start; 

entry Get_Next_Report(ROCKET_REPORT_MSG : in ROCKET_MSGJYPE); 
pragma PRIORITY(Config.control_priority); 
end Control_Type; 

for ControlJyoe'STORAGE_SIZE use INTEGERIConfig.bytesj3er_storage_unit * 

stack_size); 

Control : Controljype; 


end Rocket; -- package specification 


- 142 - 





Distributed Issues Final Report 


--X UNIT: 

- -X Effects: 
--X Modifies: 
--X Requires: 
--X Raises: 

-■X Engineer: 


Rocket Package Body. 

Provides structure for Rocket managment within BDS. 
No global data is modified. 

No initialization is required. 

No explicitly raised exceptions are propagated. 

T. Griest. 


--| PACKAGE BOOT : Rocket 

--| The Rocket package provides all processing to maintain the rockets 
--| in flight. 

--| The rocket guidance activity is given overall control by the Control task. 
--| "Control" is used to accept rocket reports, and is responsible for engagino 
--| the targets, providing updates to the Graphics.Display task, and generating 
--| the guidance nessages for the Rocket Data Link. It achieves much of this 
--| with the assistance of one (or more) Guidance task(s). The Guidance task 
--| is responsible for taking a set of the rockets and producing a new 
-*| aimpoint for each rocket/target in that set. The activities of the 
*-| guidance task(s), as well as the Control task can be overlapped 
--| considerably, and therefore may benefit from the addition of processors. 


-- Modifications Log 
-- 88-11-25 : TEG => Original created. 

-- 89-11-22 : MPS => Aimpoint_Info type created to allow less traffic on the 
net. 

with Debug_IO; 
with Status; 
with Shapes; 
with Graphics; 
with Distrib; 

package body Rocket is 

guidance_stack_size : constant := 660; 

GUIDANCE_LIST_ERR0R : exception; -- if guidance list does not match history 

-- This history data is provided to a guidance task, which in turn processes 
it and returns the next guidance information needed for each rocket. 

type P0S!TI0N_0ATA_TYPE is record -- containing rocket/target information 
ACTIVE : BOOLEAN; -- if rocket was previously active 

R0CK£T_P0S : Types.P0SITI0N_TYPE; -- latest rocket position 

TARGET_POS : Types.P0SITI0N_TYPE; -- latest target position 

end record; 


-- maintains number Rockets Active 

-- for rocket shapes 
-- for graphics operations/colors 


- 143 - 








Distributed Issues Final Report 


type POSIT 10N_L1ST_TYPE is 

array(Tvpes.WORD_INDEX -ange <>) of POSITION_DATA_TYPE; 
type A1MP0INT_IIST_TYPE is 

array(Types.UORD_INDEX range <>> of Types.A1MP0INT_TYPE; 

AIMPOINTJNFO : POSITION_LIST_TYPE<1..Config.maxrockets); 

NEXT_GUIDE_MSG : R0CKET_GU1DE_MSG_TYPE; 

task type Guidance_Type is 
entry History(AIM_DATA : in POSITION_LIST_TYPE); 
entry Next_Guidance<AIHPOINT_L 1ST : out AIMPOlNT_UST_TYPE>; 
pragma PR IOR ITY(Config.guidance_priority); 
end Guidance_Type; 

for Guidance_Type'STORAGE_SIZE use INTEGERCConfig.bytes_per_storage_unit * 

guidance_stack_si 2 e); 

Rocket_Guide : array(Types.WORD_INDEX range 1..Distrib.ntm_guide_tasks) 

of Guidance_Type; 

task body Guidance_Type is separate; 
task body Control_Type is separate; 
end Rocket; -- package body 


- 144 - 






Distributed Issues Final Report 


--X UNIT: Rock_Sup Task Body Subunit. 

--X Effects: Provides all Rocket Support for Simulator, including 
--X target intercept detection. 

--X Modifies: Updates state of rockets and targets in Simulator DBase. 
--X Requires: No initialization is required. 

--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: T. Griest. 


-- Copyright(C) 1988, LabTek Corporation. Permission is granted to copy 
-- and/or use this software provided that this copyright notice is included 
-- and all liability for its use is accepted by the user. 


TASK BODY : Simulate.RDL.Rock_Sup 

The rocket support task provides the necessary rocket motion, based 
on previous position and the application of a new guidance aimpoint. 

It generates a new report "ROCKET_MSG" for a buffer task (Report_Buf) 
to forward to the BDS Rocket.Control task. Likewise, the Rocket.Control 
task issues guidance messages to the buffer task (Guide_Buf) which are 
made available to the Rock_Sup task. ROCKET/TARGET intercepts are 
checked in the shared data base within the simulator. In such cases, 
both the rocket and target are destroyed (marked inactive). 


- Modifications Log 

- 88-12-05 : TEG => Original created. 

- 89-09-12 : MPS => Changed call to Traject to reflect new flight dynamics. 


with Traject; -- trajectory planner 

with Calendar; 

with Interrupt_Control; 

with Time_Stamp; 

with Sync; 

pragma ELABORATE(Traject, Calendar, Interrupt_Control, Time_Stamp); 
separate (Simulate.ROD 


task body Rock_Sup_Type is 


use Calendar; 
use Types; 
use Sync; 
start_position 


-- for - operator 
-- for operators 
-- for sequence operations 
: constant Types.POSITION_TYPE := 

(Config.launch_x,Config.launch_y,Config.launch_z); 


- 145 - 











Distributed Issues Final Report 


ROCKET_MSG 

GUIOEJtSG 

GUIDE_MSG_!NDEX 

REPORT_MSG_INDEX 

POSITION 

SEQUENCE_TAG 

STARTJTIME 

DELAY PERIOD 


Rocket-ROCKET_MSG_TYPE; 
Rocket.R0CKET_GU1DE_MSG_TYPE; 
Types.UORDJNDEX; 

Types.WORDJNDEX; 

Types.POSITION_TYPE; -- temp 
Sync.SEQ_TYPE := 0; 

Calendar.TIME; 

DURATION; 


-- MAKEREPORT: process current rocket ID 

procedure Make_Report(ID : Types.WORD_INDEX; POS : Types.POSITION_TYPE) is 

-- checks if rocket has collided with 
-- any targets or ground. If so, delete 
-- target(s) and rocket. 

DEITA_X : Types.LONG_FI XED; 

DELTAJT : Types.LONG_FI XED; 

DELTA_Z : Types.LONG_FIX£D; 

DELTA_T : Types.LONG_F1XED; 

ROCKET_POS ; Types.P0SIT10N_TYPE; 

begin --of Make_Report 

--STPC0070) Rock_Sup.Make_Report start 
if POS.Z < 0.0 then 
ROCKETS(ID).ACTIVE := FALSE; 

-- compute time it took to get to zero 


-- time for rocket to reach ground 


destroy rocket 


DELTA_X ;= POS.X - ROCKETSCID).POSITION.X; 

DELTA_Y := POS.Y - ROCKETSC ID) .POSITIONS; 

DELTA_Z := POS.Z - ROCKETSCID).POSITION.Z; 

if DELTA_Z = 0.0 then 
DELTA_T := 0.0; 
else 

DELTA_T := Types.LONG_FIXED(ROCKETS(ID).POSITION.Z/abs(DELTA_Z)); 
end if; 


-- find terminal position of Rocket 

ROCKET_POS.X := ROCKETSCID).POSITION.X + DELTA_T*DELTA_X; 

ROCKET_POS.Y := ROCKETSCID).POSITION.Y + DELTA_T*DELTA_Y; 

- -TBD since targets are always at Z=0, collision point is always 0 

ROCKET_POS.Z := ROCKETSCID).POSITION.Z + Types. HETERSCDELTA_T*DELTA_Z); 

-- Now search target list to see if any targets within "kill_radius" 
perimeter of rocket 


for TARGET_ID in TARGETS'range loop 

Interrupt_Control.Disable; -- access to shared data 

if TARGETSCTARGETJD).ACTIVE then 
DELTA X := ROCKET POS.X - TARGETSCTARGET ID).POSITION.X; 


- 146 - 





Distributed Issues Final Report 


DEITA_Y := R0CKET_P0S.Y - TARGETS(TARGET_ID).POSITION.Y; 

--TBD should use distance OISTANCE := Math.Sqrt( Types.METERS(DELTA_X*DELTA_X) ♦ 
--TBD Types.METERS(CELTA_Y*DELTA_Y) + 

--TBD Types.METERS(DELTA_Z*DELTA_Z))); 

if abs DELTA_X < Config.kill_radius and -- this makes square box 
abs DELTA_Y < Config.kill_radius -- around each target 
then 

TARGETS(TARGETJD).ACTIVE := FALSE; -- destroy target 
end if; 
end if; 

Interrupt_Control-Enable; 
end loop; 

else -- Rocket did not hit ground or target 

REPORT_MSG_INDEX := REPORT_MSG_INDEX + 1; 

ROCKET_MSG.ROCKET_LIST(REPORT_MSG_lNDEX) := < SEQUENCER AG, ID, POS); 
end if; 

--$TP(0071) Rock_Sup.Make_Report end 
end Make_Report; 


ROCKET SUPPORT TASK BODY 


begin 

for ID in ROCKETS'range loop -- initialize to all inactive 

ROCKETS(ID).ACTIVE := FALSE; 
end loop; 

START_TIME := Calendar.CLOCK; -- find out when xeq begins 

loop 

--$TP(0072) Rock_Sup task start 
START_TIME := START_TIME + Config.interval; 
if SEQUENCE_TAG = Sync.SEQTYPE'last then 
SEQUENCER AG := 0; 
else 

SEOUENCE_TAG := SEQUENCE_TAG + 1; 
end if; 

--STP(0073) Rock_Sup rendezvous with Guide_Buf start 

RDL.Guide_Buf,Get_Guide(GUIOE_MSG); -- fetch latest guidance message 

--$TP(0074) Rock_Sup rendezvous with Guide_Buf end 

-- Go through each rocket, and if active, apply trajectory to 
-- current position for 1 interval. 

GU1DE_HSG_INDEX := 1; -- pointer msg.rocket_guide_list 

REPORT_MSG_!NDEX := 0; 

for R0CKET_ID in ROCKETS'range loop 

if GUIDE_MSG_INDEX <= GUIDE_MSG.NUM_ROCKETS and then 

ROCKETJD = GUIDE_MSG.ROCKET_GUIDE_LIST(GUIDE_MSG INDEX).R0CKET_1D 
then 


-- update TIME_TAG to be able 
-- to differentiate between 
-- stale and new reports 


- 147 - 








Distributed Issues Final Report 


This rocket is in the list, see if it was previously active 

if not ROCKETS(ROCKET_ID).ACTIVE then 

filter out guidance messages for rockets that have recently been 
destroyed (but BOS doesn't know it yet) 

if GUIDE_MSG.ROCKET_GUIOE_LIST(GUIDE_MSG_INDEX).AIMPOINT.ELEVATION = 
Config.launch_elevation 
then -- a new launch 

ROCKETS(ROCKETJD).ACTIVE := TRUE; -- launch 
ROCKETS(ROCKETJD).POSITION := start_position; 
Make_Report(ROCKET_ID,start_position); -- start at launcher 
end if; 
else 

Now compute new X,Y,Z position. 

T ra j ect.Get_New_Position(ROCKET_ID, 

GUIDE_MSG.ROCKET_GU!DE_LIST(GUIDE_MSG_INOEX).AIMPOINT, 
POSITION); 

Make_Report(ROCKET ID,POSITION); 

ROCKETS(ROCKET_IO).POSITION := POSITION; 
end if; -- rocket active check 
GUIDE_MSG_INDEX := GUIDE_HSG_INDEX ♦ 1; 
else -- no guidance for this rocket 

if ROCKETS(ROCKETJD).ACTIVE then 

no guidance information for active rocket, simply don't move it 

POSITION := ROCKETS(ROCKETJD).POSITION; 

Make_Report(ROCKET_ID,POSITION); 
end if; -- rocket active check 

end if; -- guide entry exists check 

end loop; 

New report list has been generated. Send it to buffer task. 

ROCKET_MSG.NUH_ROCKETS := REPORT_MSG_lNDEX; 

--$TP(0075) Rock_Sup rendezvous with Report_Buf start 
RDl.Report_8uf.Put_Report(ROCKET_MSG); -- issue next rocket report 
--STP(0076) Rock_Sup rendezvous with Report_Buf end 

Delay to make rocket motion reports periodic 

DELAY_PERIOO := START_TIME - Calendar.CLOCK; 
if DELAY_PERIOO < 0.0 then 
START_TIME := CLOCK; 
end if; 

--STP(0077) Rock_Sup task end 
delay DELAY_PERIOO; 


- 148 - 





Distributed Issues Final Report 


end loop; 

end Rock_Sup_Type; 


- 149 - 









Distributed Issues Final Report 


UNIT: Sensor Package Body Subunit. 

--X Effects: Provides structure for all simulator Target motion. 

--X Modifies: Simulator target data is updated. 

--% Requires: Initialization is performed by Sensor.Initialize. 

--X Raises: TARGET_CREATE_ERROR is raised if no room for more targets.-- 

--X Engineer: M. Sperry. 


--| PACKAGE BOOT : Simulate.Sensor 

--| The sensor package supports the targ_sup task by keeping a history 
--| of the old target position, the current X velocity of the target, a 
--| desired X velocity of the target, how long to stay at that desired velocity 
--| and finally the attributes of the class of the target. The Y velocity 
--| is constant with respect to the class of the target, as is the turning 
--| frequency of the X direction. 


Modifications Log 

88- 10-22 : TEG =» Original created. 

89- 11-27 : MPS => Get_New_ID, Get_New_Position, and Activate_Target created. 


with Interrupt_Control; 
with Math; 

with Parameter_Data_Base; 
with Time_Stamp; 
with 0ebug_10; 

pragma ELABORATECMath, Debug_IO, Interrupt_Control); 
separatetSimulate) 

package body Sensor is -- Target Sensor Simulator 

use Types; 

type HISTORY_REC is record 
OLO_POS : Types.POSITION_TYPE; 

CURRENT_VEL_X : Types.METERS; 

0ESIRED_VEl_X : Types.METERS; -- generated randomly every CHANGE_DIR_FREQ 

CHANGED_VE L_T I ME : Types. UORDJNDEX; -- intervals since DESIRED was changed 
ATTRIBUTES : Parameter_0ata_Base.TARGET_PARAMETER_TYPE; 

end record; 

type HISTORY_TYPE is array(Types.TARGET_INDEX_TYPE) of HISTORY_REC; 

TARGET_HISTORY : HISTORY_TYPE; 

LAST_USED_TARGET_ID : Types.TARGET_INOEX_TYPE; 


- 150 - 









Distributed Issues Final Report 


procedure Initialize is 


--| SUBPROGRAM BODY : Simulate.Sensor.Initialize 

--| Initialize is responsible for setting the LAST_USED_TARGET_ID to the first 
-*| allowable value of that type. Also, it sets all targets to an inactive 
--| (FALSE) state. 


begin 

LAST_USED_TARGETJD := Types. TARGET JNDEXJYPE'first; 
for ID in Types.TARGET JNDEXJYPE loop 
TARGETS(ID).ACTIVE := FALSE; 
end loop; 
end Initialize; 

function GetJiewJD return Types.TARGET JNDEXJYPE is 


-| SUBPROGRAM BOOY : Simulate.Sensor.GetJIewJD 

-| To simplify the code in Targ_Sup, this function keeps track of the last 
-| target id used (a package level variable in Sensor.ab) and returns a new 
-| target id that is not currently being used. The target id's rollover at 
-| Config.max_targets. 


TARGETJD : Types. TARGETJNOEX TYPE; 

TARGET_CREATE_ERROR : EXCEPTION; 

begin 

TARGET_ID := LAST JJSED TARGET JO; 

loop -- loop through each targeted starting from IAST_USED_TARGET_ID 

if not TARGETSfTARGET_ID).ACTIVE then 
LAST_USED_TARGET_ID := TARGETJD; 

if LAST_USED_TARGET_ID = Types.TARGET_INDEX_TYPE'last then 
LAST_USED_TARGET_ID := Types. TARGET J NDEXJYPE'first; 
end if; 
exit; 
else 

if TARGET_ID = Config.max_targets then 
TARGETJD := Types.TARGETJNDEXJYPE'first; 
else 

TARGET_I0 := TARGET_ID + 1; 
end if; 

if TARGET_ID = LASTJJSEDJARGETJO then - no more room for targets, 
raise TARGET_CREATE_ERROR; -- but told to create one 

end if; 
end if; 
end loop; 


- 151 - 








Distributed Issues Final Report 


return TARGET JD; 
exception 

when TARGET JREATE_ERROR => 

Oebug_IO.Put("TARGET_CREATE_ERROR raised in Simulate.Sensor.Get JlewJD"); 
end Get_New_I0; 

procedure Activate_Target(TARGET_lD : Types.TARGETJNDEXJYPE) is 


--| SUBPROGRAM BODY : Simulate.Sensor.Activate_Target 

--| Activatejarget initializes the record which controls the target's 
•*| history. It also assigns a random new starting position (in X only, 

-*| the starting Y and Z positions are fixed) and a new class. The class 
--| is chosen randomly via the package Math. 

NUM_OF_CLASSES : Types.WORD INDEX; 

CLASS : Types.TARGET_CLASS_TYPE; 

POS_X : Types.METERS; 

MAX_X_VEL : Types.METERS; 

begin 

-- Limit the access to the shared data base in Simulate. 

Interrupt_Control.Disable; 

-- Initialize Simulate.TARGETS data base. 

TARGETS(TARGET_ID).ACTIVE := TRUE; 

TARGETS(TARGETJD).POSITION.Y := Types.LONG FIXED( 

Parameter_Data_Base.target_start_y); 
TARGETS(TARGETJD). POSITION. Z := Types. LONGF I XED< 

Parameter_Data_Base.target_start_z); 
POS_X := Math.Get_Random_Num(Types.METERS( 

Parameter_Data_Base.x_start_limit)); 
POS_X := POS_X ♦ Parameter_Data_Base.left_border_limit; 

TARGETS(TARGET_ID).POSITION.X := Types.LONGFIXED(POSX); 

NUM_OF_CLASSES := Types.UOROJNDEX(Types.TARGET_CLASS_TYPE'pos( 

Types.TARGET_CLASS_TYPE'last)); 

CLASS := Types.TARGET_CLASS_TYPE'val(Math.Get_Random_Num(NUM_OF_CLASSES*1)); 
TARGETS(TARGET_ID).TARGET_CLASC := CLASS; 

-- Enable the interrupts again. 

Interrupt_Control.Enable; 

-- Initialize Sensor.TARGET_HISTORY data base. 

TARGET_HISTORY( TARGET JO ).OLD_POS := TARGETS( TARGET_ID) .POSITION; 


- 152 - 





Distributed Issues Final Report 


TARGET_HISTORY(TARGETJD).ATTRIBUTES : = 

Parameter_Data_Base.TARGET_PARAMS(CLASS); 
MAX_X_VEL := TARGET_HISTORY(TARGET_ID).ATTRIBUTES.MAX_VELOCITY_X; 

T ARGETJUSTORYf TARGET JO) .CURRENT_VEL_X := Math.Get_Random_Mum( 

Types.METERS(2 * MAX_X_VEL)); 
TARGET_HISTORY(TARGET_ID).CURRENT_VEL_X := MAX_X_VEL - 

TARGET Ji l STORY (TARGET JO). CURREHT_VELJ<; 
TARGET_HIST0RY(TARGET_ID).CHANGED_VEL_T1ME := 0; 
TARGET_HIST0RY(TARGET_ID).DES1RED_VEL_X := Math.Get J!andomJlum( 

Types.METERS(2 * MAX_X_VEL>); 
TARGET_HISTORY(TARGET_IO).DESIRED_VEL_X := MAX_X_VEL - 

TARGET_HISTORYCTARGET_IO).DESIRED_VEL_X; 

end Activatejarget; 


procedure Get_Neu_Position(TARGET_ID : Types.TARGETJNDEXJYPE) is 


SUBPROGRAM BOOY : Sensor.GetJJewPosition 

Get_New_Position is responsible for updating the history of the targets 
and more importantly to return to TARGETS a new target position in the 
Types.POSITIONJYPE, which is made up of Types.LONG_F!XED. The target 
is not allowed to leave the battlefield border area, therefore it changes 
directions before bouncing against the side of the border. 


D1R_FREQ 
MAX_X_VE L 
MAX_Y_VEL 
DEITA_X 
CLASS 

INTERVALSJEFT 
X POS EST 


Types.UORD JNDEX; 

Types.METERS; 

Types.METERS; 

Types.METERS; 

Types.TARGET_CLASS_TYPE; 
Types.METERS; 

Types.METERS; 


begin 

Time_Stamp.Log(0122); --*TP<0122J Sensor.Get_New_Position start 


-- Place often used but complex address calculation type variables in 
-- local space. 

CLASS := TARGETS(TARGET_ID).TARGET_CLASS; 

0IR_FREQ := TARGET_HlSTORY(TARGETJO).ATTRIBUTES.CHANGE_DIR_FREQ; 
MAX_X_VEL := TARGETJiISTORY(TARGET_IO).ATTRIBUTES.MAX VELOCITY_X; 
MAX_Y_VEL := TARGET_HI STORY(TARGET_ID).AT TRIBUTES.MAX_VELOCITY_Y; 
0ELTA_X := TARGET_HISTORY(TARGET_IO) .ATTRIBUTES.OELTA VELOcHY X; 

-- Check to see if it is time to change dir. 

if TARGET JiISTORY(TARGET JD) .CHANGE0_VELJ I ME = DIRJREQ then 


-- Time to change the X direction. The DESIRED_VEL_X is a random nunber of 


- 153 - 









Distributed Issues Final Report 


- Types.METERS between +MAX_X_VEL and -MAX_X_VEL. 

TARGET_HISTORY(TARGET_!D).DESIRED_VEL_X := Math.Get_Random_Num( 

Types.METERS(2 * MAX_X_VEL>); 
TARGET_HISTORY(TARGETJD).DESIRED_VEL_X := MAX_X_VEL - 

TARGET_H1STORY(TARGET_ID).DESIRED_VEL_X; 
TARGET_HISTORY(TARGET_ID).CHANGED_VEL_TIME := 0; 
end if; 


Increment the counter that keeps track of when it is time to change direction 

TARGET_HIST0RY(TARGETJ D).CHANGED_VEL_TI ME : = 

.ARGET_HI STORY(TARGET_I0).CHANGED_VEL_TI ME + 1; 


- Avoid hitting the battlefield border area. 

if TARGET_HISTORY(TARGET_ID).CURRENT_VEL_X > 0.0 then 

if TARGETS(TARGET_ID).POSITION.X < Parameter_Data_Base.left_border_limit 
and TARGET_HISTORY(TARGET_ID).DESIRED_VEL_X > 0.0 then -- going left 
TARGET_HISTORY(TARGET_ID).DESIRED_V£L_X := 

-TARGET_HISTORY(TARGET_ID).DESIRED_VEL_X; 

end if; 
else 

if TARGETS(TARGET_ID).POSITION.X > Parameter_Data_8ase.right_border_limit 
and TARGET_HISTORY(TARGETJO).DESIREO_VEL_X < 0.0 then -- going right 
TARGET_HISTORY(TARGETID).DtSIRED_VEl_X := 

- TARGET_HI STORY(TARGET_ID).DESIRED_VEL_X; 

end if; 
end if; 

- Adjust the CURRENT_VEl_X by DEITA_X if need be. 

if TARGET_HISTORY(TARGET_ID).CURRENT_VEL_X < 

TARGET_HISTORY(TARGET_ID).DESIRED_VEL_X 
then 

TARGET_HISTORY(TARGET_ID).CURRENT_VEL_X := 

TARGET_HISTORY(TARGET_ID),CURRENT_VEL_X + DELTA_X; 
elsif TARGET_HISTORY(TARGET_ID).CURRENT_VEl_X > 
TARGET_HISTORY(TARGET_ID).DESIRED_VEl_X 

then 

TARGET_HISTORY(TARGET_IO).CURRENT_VEL_X := 

TARGET_HISTORY(TARGET_!D).CURRENT_VEL_X - DELTA_X; 

end if; 

- Ysccrtain the new position based on the velocities of the class, saving 

- the old position first, and guarantee mutally exclusive access. 

TARGET_HISTORY(TARGET_ID).OLD_POS := TARGETS(TARGET_ID).POSIT ION; 

Interrupt_Control.Disable; 
if TARGETSCTARGET ID).ACTIVE then 


- 154 - 





Distributed Issues Final Report 


TARGETS(TARGETJO).POSITION.X := TARGETS(TARGET_ID).POSITION.X - 

Types. LONG_F IXED(TARGET_H 1ST0RY( TARGET JD).CURRENT_VEL_X); 
TARGETS(TARGETJD).POSITION.Y : = 

TARGETS(TARGETJD).POSITION.Y - Types. LONG_F!XED(HAX_Y_VEL); 

-- The Z direction is not currently implemented for targets. 

TARGETS(TARGETJO).POSITION.Z := Types.LONG_FIXED<0.0>; 
end if; 

Interrupt_Control.Enable; 

Time_Stamp.Log(0123); --$TP<0123) Sensor.Get_New_Position end 
end Get_New_Position; 


task body Targ_Sup_Type is separate; 
end Sensor; -- body 


- 155 - 




Distributed Issues Final Report 


UNIT: Shapes Package Spec. 

--% Effects: Provides ail graphics symbology. 

--% Modifies: No global data is modified. 

--% Requires: No initialization is required. 

-•% Raises: No explicitly raised exceptions are propagated. 
--X Engineer: T. Griest / M. Sperry. 


- -1 PACKAGE SPEC : Shapes 

--| Package Shapes is responsible for determining the relative offsets 
--| which define the shapes of all the possible symbols that can be drawn. 

--| The reticle is the pointing box that is controlled by the mouse. Note 
--| that where the coordinate (0,0) is defined in terms of the shapes of 
--| the object. For example the nose of the rocket is considered to be 
--| explosive in our case. Therefore the nose of the rocket has the coordinates 
--| (0,0). Likewise, the center of the target has the (0,0) coordinate. The 
--| objects are all manipulated by their absolute coordinates or rather, 

--| the coordinate (0,0). 


-• Modifications Log 

-- 88-10-12 : MPS => Original created. 

-- 89-08-08 : MPS => Adjusted to work with new DOC compiler 


with Types; 
with Config; 

package Shapes is 

type SYMBOL_TYPE is (ROCKET, TARGET, RETICLE, DOT, ZERO, ONE, TWO, THREE, FOUR, 
FIVE, SIX, SEVEN, EIGHT, NINE, HORIZONTAL, VERTICAL); 


type PIXEL is record 

a.T ypes.COORD I NATE range Config.entire_screen_lef t..Config.entire_screen_right; 
Y:Types.COORD I NATE range Config.entire_screen_top..Config.entirescreenbottom; 
end record; 

type REL_P1XEL is record 

X_0FFSET : Types.REL_COORDINATE; 

Y_0FFSET : Types.REL_C00RDINATE; 
end record; 

type P!XEL_LI ST is array(Types.WORD_INDEX range <>) of RE L _PIXEL; 
type OBJECT_PTR is access PIXEL_LI ST; 


-- offset from base of pixel 
-- positive goes right 
-- positive goes down 


- 156 - 





Distributed Issues Final Report 


reticle_left : constant 
reticle_right : constant 
reticle_top : constant 
reticle bottom : constant 


-5 

5 

-5 

5 


-- constants used to check if 
-- reticle going past screen 
-- boundaries. 


The following two constants determine how far the target center can 
-- be in meters from the indicated reticle center and still allow 
-- acquisition of the target for launching a rocket. They are not the 
same in X and Y, since the reticle is slightly rectangular. 


reticle_x_error: constant := 40.25; -- METERS to allow target aquisition 

reticle_y_error: constant := 49.50; -- METERS to allow target aquisition 


NUMERIC : array(0..9) of SYMBOL_TYPE := (ZERO, ONE, TWO, THREE, FOUR, 

FIVE, SIX, SEVEN, EIGHT, NINE); 


nunber. 

,width : 

constant 

; - 

8; -- widest number 

ml 


constant 

: = 

-1 ; 

m2 


constant 

:= 

-2; 

m3 


constant 

: = 

-3; 

m4 


constant 

: = 

-4; 

m5 


constant 

: = 

-5; 

m6 


constant 

: = 

-6; 

m7 


constant 

: = 

-7; 

m8 


constant 

: = 

-8; 

OBJECT. 

_PTR_TABLE 

: array(SYMBOLTYPE) of OBJECT_PTR := 


(TARGET => new PIXEl_UST'( 

(0,m2), 

(ml,ml), (1,m1), 

(m2,0), (0,0), (2,0), 

(ml,1), (1,1), 

( 0 , 2 ) ), 

ROCKET => new PIXEl_LIST'( 

( 0 , 0 ), 

( 0 , 1 ), 

( 0 , 2 ), 

(0,3), 

(ml,4), (1,4) ), 

RETICLE => new PIXEl_LIST'( 

(m5,m5),(m4,m5),(m3,m5), 

(m5,m4), 

(m5,m3), (0,m3), 

(0,m2), 

(0,m1), 

(m3,0), (m2,0), (m1,0), (0,0), (1,0), 

( 0 , 1 ), 

( 0 , 2 ), 


(3,m5),(4,m5),(5,m5), 
(5,m4), 
(5,m3), 


(2,0), (3,0), 


- 157 - 






Distributed Issues Final Report 


(m5,3), (0,3), 

(m5,4), 

(m5,5),(m4,5),(m3,5). 


(5.3) , 

(5.4) , 

(3,5),(4,5),(5,5)), 


DOT => new PIXEL_LIST'( (0,0),(0,0) ), 

ZERO => new PIXEL LI ST '( ( 1 ,m8),(2,m8),(3,m8),(4,m8),(5,m8), 


(0,m7), 

(0,m6), 

(0,m5), (4,m5) 

(0,m4), (3,m4>, 

(0,m3), (2,m3), 

(0,m2),(1,m2), 

(0,m1), 


(6,m7), 
(5,m6),(6,m6), 
(6,m5), 
(6,m4), 
(6,m3), 
(6,m2), 
(6,ml), 


(1,0), (2,0), (3,0), (4,0), (5,0)), 


ONE => new PIXEL_LIST'( (4,m8), 

(3,m7),(4,m7), 

(4,m6), 

(4,m5), 

(4,m4), 

(4,m3), 

(4,m2), 

(4,ml), 

(3,0), (4,0), (5,0)), 


TWO => new PIXEL_LIST'( (1,m8),(2,m8),(3,m8),(4,m8), 

(0,m7), (5,m7), 

(5,m6), 

(4,m5), 

(3,m4), 

(2,m3), 

(1,m2), 

(0,m1), 

(0,0), (1,0), (2,0), (3,0), (4,0), (5,0)), 

THREE => new PIXEL_LIST'( (1,m8),(2,m8),(3,m8), 

(0,m7), (4,,n7), 

(4,m6), 

(4,m5), 

(2,m4),(3,m4), 

(4,m3), 

(4,m2), 

(0,m1), (4,ml), 

(1,0), (2,0), (3,0)), 


FOUR => new PIXEt_lIST'( (4,m8), 

(3,m7),(4,m7), 

(2,m6), (4,m6), 

(1,m5), (4,m3), 

(0,m4),(1,m4),(2,m4),(3,m4>,(4,m4),(5,m4), 


- 158 - 







Distributed Issues Final Report 


(4,m3), 

(4,m2), 

<4,ml), 

(3,0), (4,0), (5,0)), 


FIVE => new PIXEL_LIST'( (1,m8),(2,m8),(3,m8),(4,m8),(5,m8), 

(0,m7), 

(0,m6), 

(0,m5>, 

(1,m4),(2,m4),(3,m4),(4,m4), 

(5,m3), 
(5,m2), 
(5,ml), 

(0,0), (1,0), (2,0), (3,0), (4,0), (5,0)), 


SIX => new PIXEL_LI ST'( (3,m8),(4,m8), 

(2,m7), 

(1,m7), 

(0,m6), 

(0,m5), (1,m5),(2,m5),(3,m5), 

(0,m4), (4,m4), 

(0,m3), (4,m3), 

(0,m2), (4,m2), 

(0,m1), (4,ml), 

(1,0), (2,0), (3,0)), 


SEVEN => new PIXEL_LIST'( (1,m8),(2,m8),(3,m8),(4,m8),(5,m8), 

(0,m7), (5,m7), 

(4,m6), 

(3,m5), 

(2,m4), 

(1 ,m3), 

(0,m2), 

(0,m1), 

( 0 , 0 )), 


EIGHT => new PIXEL_LI ST'( 

(0,m7), 
(0,m6), 
(0,m5), 

(0,m3), 
(0,m2), 
(0,m1), 


(1,m8),(2,m8),(3,m8),(4,m8), 

(5,m7), 

(5,m6), 

(5,m5), 

(1,m4),(2,m4),(3,m4),(4,m4), 

(5,m3), 
(5,m2), 
(5,ml), 

(1,0), (2,0), (3,0), (4,0)), 


NINE => new PIXEL_L1ST'( 

(0,m7), 
(0,m6), 
(0,m5), 


(1,m8),(2,m8),(3,m8),(4,m8), 

(5,m7), 

(5,m6), 

(5,m5), 


(1,m4),(2,m4),(3,m4),(4,m4),(5,m4), 


- 159 - 




Distributed Issues Final Report 


HORIZONTAL = 


VERTICAL => 


end Shapes; 


(5,m3), 

(A,m2), 

(3,ml), 

( 1 , 0 ), ( 2 , 0 )), 

> new PIXEL_LI ST'((0, 0),(1, 0),(2, 0),(3, 0),(4, 0>,(5, 0), 
(6, 0),(7, 0),(8, 0),(9, 0),(10,0),(11,0), 
(12,0),(13,0),(14,0),(15,0),(16,0),(17,0), 
(18,0),(19,0),(20,0),(21,0),(22,0),(23,0), 
(24,0),(25,0),(26,0),(27,0),(28,0),(29,0), 
(30,0),(31,0),(32,0),(33,0),(34,0),(35,0), 
(36,0),(37,0),(38,0),(39,0),(40,0),(41,0), 
(42,0),(43,0),(44,0),(45,0),(46,0),(47,0), 
(48,0),(49,0),(50,0),(51,0),(52,0),(53,0), 
(54,0),(55,0),(56,0),(57,0),(58,0),(59,0), 
(60,0),(61,0),(62,0),(63,0),(64,0),(65,0), 
(66,0),(67,0),(68,0),(69,0),(70,0),(71,0), 
(72,0),(73,0),(74,0),(75,0),(76,0),(77,0), 
(78,0)), 

new PIXEL_LI ST'((0, 0),(0, 1), (0, 2),(0, 3),(0, 4),(0, 5), 
(0, 6),(0, 7),(0, 8),(0, 9),(0,10),(0,11), 
(0,12),(0,13),(0,14),(0,15))); 


- 160 - 






Distributed Issues Final Report 


--X UNIT: Simulate Package Spec. 

-•% Effects: Provides shared data base for Simulator. 

••X Modifies: No global data is modified. 

--X Requires: Individual tasks are responsible for init. of global data.-- 
--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: T. Griest. 


--| PACKAGE SPEC : Simulate 
"1 

--| The Simulate package is used to provide input and output to the 
--| BOS system. It provides rocket flight paths and target generation. 


-- Modificiations Log 

-- 88-10-15 : TEG => Original created. 


with Target; 
with Rocket; 
with Sync; 
with Config; 

package Simulate is -- Overall simulation package 

package Sensor is -- Target Sensor Simulator 

stack_size : constant := 114; -- in bytes 

task type Targ_Sup_Type is 
pragma PRIORITYlConfig.targ_sup_priority); 
entry Next_Target_Msg(Data : out Target.TARGET_MSG_TYPE); 
end Targ_Sup_Type; 

for Targ_Sup_Type'STORAGE_SIZE use INTEGERIConfig.bytes_per_storage_uni t * 

stack_size); 

Targ_Sup : Targ_Sup_Type; 
end Sensor; 

package RDL is -- Rocket Data Link Simulator 

report_buf_stack_size : constant := 302; -- in bytes 

guide_buf_stack_size : constant := 744; -- in bytes 


The Report_8uf task buffers Rocket Reports from the Rock_Sup task 
and provides them to the Rocket.Control task 

task type Report_Buf_Type is 
pragma PRIORITYlConfig.report_buf_priority); 
entry Put_Report(0ATA : in Rocket.ROCKET_MSG_TYPE); 


- 161 - 








Distributed Issues Final Report 


entry Get_Report(DATA : out Rocket.ROCKET_MSG_TYPE>; 
end Report_Buf_Type; 

for Report_Buf_Type'STORAGE_SIZE use INTEGER(Config.bytes_per_storage_unit 

* report_buf_stack_size); 

Report_Buf : Report_Buf_Type; 


- The Guide_Buf task buffers new Guidance messages from the Rocket.Control 

- task for delivery to the Rock_Sup task. 

task type Guide_Buf_Type is 
pragma PRIORITYCConfig.guide_buf_priority); 
entry Put_Guide(DATA : in Rocket.R0CKET_GU1DE_MSG_TYPE); 
entry Get_Guide(OATA : out Rocket.ROCKET_GUIOE_MSG_TYPE); 
end Guide_Buf_Type; 

for Guide_Buf _T ype'STORAGE_SIZE use lNTEGER(Conf ig.bytes_per_storage_unit 

* guide_buf_stack_size>; 

Guide_Buf : Guide_Buf_Type; 








Distributed Issues Final Report 


UNIT: Simulate Package Body. 

Effects: Provides shared data base for Simulator. 

--% Modifies: No global data is modified. 

--X Requires: Individual tasks are responsible for init. of gtobat data.-- 
--% Raises: No explicitly raised exceptions are propagated. 

--% Engineer: T. Griest. 


--| PACKAGE BOOY : Simulate 

--| This package is responsible for implementation of the "driver 11 
--| for the BDS. The simulator provides random target generation (subject 
--| to a limit maximum), rocket trajectories, and target motion. 


Modifications Log 

88-10-29 : TEG => Original created. 


with Types; 


-- Simulator package to provide testing of BOS system 

package body Simulate is -- Overall simulation package 


TARGET DATA 


type TARGET_SIM_TYPE is record -- provides individual target information 
ACTIVE : BOOLEAN; 

POSITION : Types.P0SIT10NTYPE; 

TARGET_CLASS : Types.TARGET_CLASS_TYPE; 

end record; 

type TARGETS_TYPE is 

array(Types.WORO_INDEX range 1..Config.max_targets) of TARGET_SIM_TYPE; 
TARGETS : TARGETS_TYPE; 


ROCKET DATA 


type ROCKET_SIM_TYPE is record -- provides individual rocket information 
ACTIVE : BOOLEAN; 

POSITION : Types.P0SITI0N_TYPE; 

end record; 


- 163 - 











Distributed Issues Final Report 


type ROCKETS_TYPE is 

array(Types.WORD_INDEX range 1..Config.maxrockets) of ROCKET_SIM_TYPE; 
ROCKETS : ROCKETS_TYPE; 

package body Sensor is separate; -- Target Sensor Simulator 

package body RDl is separate; -- Rocket Data Link Simulator 

end Simulate; -- body 


- 164 - 





Distributed Issues Final Report 


--X UNIT: 

Effects: 

--X Modifies: 
--X Requires: 
--X Raises: 
--X Engineer: 


Status Package Spec. 

Maintains indicators and statistics on graphics display. 
Flags are cleared in spec, when values are displayed. 
Initialization must be signaled by main for first display.-- 
No explicitly raised exceptions are propagated. 

M. Sperry. 


- -| PACKAGE SPEC : Status 

--| The purpose of the Status specification package is to provide visibility 
--| to the data base which holds the requests from the mouse, et. al. The 
--| requests are entered into a data table (called STATUS_CONTROL> and then 
--| the table is checked to see if any updating of the statistics needs to be 
-*| done. The checking of the table is done at an atomic level to prevent 
--| the shared data from being corrupted at critical times. The commands are 
--| processed from the mouse interrupt as mode first, then reset if there are 
--| two commands to perform. 


-- Modifications Log 

-- 88-11-08 : MPS => Original created. 


with Types; 
with Config; 

package Status is 

stack_size : constant := 252; 

type M00E_TYPE is (AUTOMATIC,MANUAL); 

type STATUS_TYPE is (AIRBORNE, TRACKED, EXPENDED, DESTROYED); 
subtype R£SET_STATUS_TYPE is STATUS_TYPE range EXPENDED..DESTROYED; 
type STATUS_RECORD is record 

DATA : Types.WORD := 0; -- new statistic 

DISPLAYED : BOOLEAN := FALSE; -- need to display 

end record; 


type STATUS_TYPE_ARRAY is array(STATUS_TYPE'FIRST .. STATUS_TYPE'LAST) of 

STATUSRECORD; 


-- define shared variables 


- 165 - 









Distributed Issues Final Report 


MODE 

MOOE_D!SPLAYED 
STATUS_CONTROL 
REO COUNT 


MOOE_TYPE := MANUAL; 
800LEAN := FALSE; 
STATUS_TYPE_ARRAY; 
Types.WORD := 0; 


STATUS_ERROR : EXCEPTION; 


-- if data negative 


-- define subprograms and tasks 


procedure Initialize; -- initialization of screen 

task type Update_Type is 
entry Signal; 

pragma PRIORITYCConfig.updatepriority); 
end Update_Type; 

for Update_Type'STORAGE_SIZE use INTEGERCConfig.bytes_per_storage_unit * 

stack_size); 

Update : Update_Type; 

end Status; 


- 166 - 









Distributed Issues Final Report 


--X UNIT: Status Package Body. 

--X Effects: Maintains indicators and statistics on graphics display. 
--X Modifies: Flags are cleared in spec, when values are displayed. 

-•% Requires: Initialization must be signaled for first display. 

--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: M. Sperry. 


--| PACKAGE BODY : Status 

**| The purpose of the status package body is the implementation of the status 
•*| update task. Although operating at a low priority, the update task updates 
--| the various statistics by a rendezvous with the graphics task. 


-- Modifications Log 

-- 88-11-08 : MPS => Original created. 


with Graphics; 

with Interrupt_Control; 

with Shapes; 

with Hachine_Dependent; 

with Interrupt_Control; 

with Debug_I0; 

with Time_Stamp; 

pragma ELABORATECGraphics, Interrupt Control, Debug_IO, Time_Stamp); 
package body Status is 

use Types; -- for visibility to '+'; 

procedure Initialize is 


--| SUBPROGRAM BOOY : Status.Initialize 

--| This procedure is responsible for performing a rendezvous with graphics 
--| for the purpose of printing the statistics titles. After this has been 
•*| done, this procedure signals the Status.Update task causing the initial 
--| values of all the statistics to appear as well. 


type TITLE_REC_TYPE is record 
X,Y : Types.WORO; 

TEXT : STRINGd . .Conf ig.stats_ti tle_max_length); 
COLOR : Graphics.C0L0R_TYPE; 
end record; 


- 167 - 











Distributed Issues Final Report 


EMPTY : constant STRING := ""; 

TITLES : array(1..Config.nunber_of_titles) of T!TLE_REC_TYPE : = 

((0,0, "Airborne ",Graphics.status_color), 

(0,1, " Rockets: ".Graphics.status_color), 

(0,3, "Tracked ", Graphics.status_co(or), 

(0,4, " Targets: ",Graphics.status_color), 

(0,8, "Totals ",Graphics.status_color), 

(0,10,"Expended ",Graphics.status_color), 

(0,11," Rockets: ",Graphics.status_color), 

(0,13,"Destroyed ",Graphics.status_color), 

(0,14," Targets: ", Graphics.status_color), 

(0,18,"Mode: ", Graphics.status_color), 

(0,20," Manual ",Graphics.status_color), 

(0,22," Automatic",Graphics.status_color)); 

begin 

for I in 1..Config.nLmber_of_titles loop 

Graphics.Display.Print_Titles(TITLES(I).X,TITLES(I ).Y, 

TITLES(I).TEXT, 

TITLES(I).COLOR); 

end loop; 

Graph ics.Displ ay.Print_Titles(0,0,EMPTY,Graphics.status_color); 

Interrupt_Control.Disable; -- go atomic 

Status.REQ_COUNT := Status.REQ_COUNT + 1; -- signal a request (print zeroes) 

Interrupt_Control.Enable; 

Status.Update.Signal; -- display statistics values 

end Initialize; 

task body Update_Type is 

TASK BOOY : Status.Update 

--| This task is used as a low priority task which ensures that updates to 
--| the statistics are performed. Only those stats which have changed since 
--| the last update are written to the screen. 


use Types; 




-- for visibility to "+" 

x_start 

: constant 

: = 

11; 

-- column that status_box starts 

x_end 

: constant 

: = 

90; 

-- end column of status_box 

y_top_start_A 

: constant 

: = 

307; 

-- status_box top AUTOMATIC 

y_bo11 om_start_A 

: constant 

: = 

322; 

-- status_box bottom AUTOMATIC 

y_top_start_M 

: constant 

: = 

278; 

-- status_box top MANUAL 

y_bottom_start_M 

: constant 

: = 

293; 

-- statusbox bottom MANUAL 

manual_offset 

: constant 

: = 

29; 

-- offset to draw status_box 

box_start 

: constant 

: = 

i; 

-- range of components that 

box_end 

: constant 

: = 

4; 

-- make up statusbox. 

base_x 

: constant 

Types.COORDINATE 

:= 120;-- x end of all statistics 


- 168 - 





Distributed Issues Final Report 


airborne_y 
tracked_y 
expended_y 
destroyed_y 


: constant Types.COORD I NATE 
: constant Types.COORDINATE 
: constant Types.COORD I NATE 
: constant Types.COORDINATE 


=25; -- y location of stat 
= 67; -- y location of stat 
= 165; -- y location of stat 
= 207; -- y location of stat 


y_statisties : constant array(STATUS_TYPE'first .. STATUS_TYPE'last) of 
Types.COORD I NATE := (airborne_y, tracked_y, expended_y, destroyed_y); 


type STATUS_OLD is array(STATUS_TYPE'first .. STATUS_TYPE'last, 

1 .. Config.statistics_length) of Graphics.MOVE_RECORD; 


NEXT_MOOE 
DISPLAY_REQUI RED 
NEXT_DATA 
BOX_LI ST 
DATA_OLD 
UORK_LI ST 
MOVE PRIORITY 


: MOOE_TYP£; 

: BOOLEAN; 

: Types.WORD; 

; Graphics.MOVE_LIST_TYPE(Types.WORD_INDEX range box_start..box_end); 
: STATUS_OLD; 

: Graphics.MOVE_LIST_TYPE(1 .. Config.statistics_length); 

: Graphics.PRIORITY_TYPE := Graphics.LOW; 


procedure Initialize is 
- - 1 

-*| SUBPROGRAM BOOT : Status.Update.Initialize 

--I 

-*| A procedure which intializes the DATA_OLD data base. This procedure does 
-*| NOT cause the digits to be drawn. Then, it initializes the statusbox 
-*| around 'manual'. Again, it does not cause the status_box to be drawn. A 
--| wakeup call from the main task will cause it to be drawn. 


begin 

for I in STATUS_TYPE'first .. STATUS_TYPE'last loop 
for J in 1 .. Config.statistics_length loop 
DATA_OLD(I,J).XY_OLD := <Types.COORD I NATE(base_x),Types.COORD INATE(y_statistics(I))); 
DATA_OLD(I,J).XY_NEU := (Types.COORD INATE(base_x),Types.COORD INATECy_statistics(I))); 
DATA_OLD(I,J).OBJECT := Shapes.ZERO; 

DATA_OLD(I,J).COLOR := Graphics.status_color; 
end loop; 
end loop; 

-- Now initialize top of status_box 
BOX_LIST(1).XY_OLO := 

(Types.COORDINATE(x_start),Types.COORDINATE(y_top_start_A)); 

BOX_L1 ST(1).XY_NEW : = 

(Types.COOROINATE(x_start),Types.COORDINATE(y_top_start_A)); 

BOX_LIST<1).OBJECT := Shapes.HORIZONTAL; 

BOX_LI ST(1).COLOR := Graphics.status_box_color; 

-- define bottom of status box 


- 169 - 










Distributed Issues Final Report 


80X_LIST(2).XY_0LD := 

(Types.COORD I NATE(x_start), Types.COORD 1 NATE(y_bottom_start_A)); 
BOX_UST(2).XY_NEW : = 

(Types.COORD!NATE(x_start), Types.COORDINATE(y_bottom_start_A)); 
BOX_LIST(2).OBJECT := Shapes.HORIZONTAL; 

BOX_LIST(2).COLOR := Graphics.status_box_color; 

-- define left side of status_box 

B0X_LIST(3).XY_0LD := 

(Types.COORD INATE(x_start), Types.COORDINATE(y_top_start_A)); 
BOX_LI ST(3).XY_NEW : = 

(Types.COORD INATE(x_start). Types.COORD INATE(y_top_start_A)); 
BOX_LIST(3).OBJECT := Shapes.VERT I CAL; 

BOX_LIST(3).COLOR := Graphics.status_box_color; 

-- define right side of status_box 

BOX_L1 ST(4).XY_OLD : = 

(Types.COORD I NATE(x_end), Types.COORDlNATE(y_top_start_A)); 

BOX_LI ST(4).XY_NEW : = 

(Types.COORD I NATE(x_end). Types.COORDINATE(y_top_start_A)); 
B0X_L1ST(4).OBJECT := Shapes.VERTICAL; 

B0X_LIST(4).COLOR := Graphics.status_box_col^r; 
exception 

when others => Debug_IO.Put_Line("Exception raised in Status.Initialize"); 
end Initialize; 


procedure Update_Box(NEXT_MOOE : MOOE_TYPE) is 


SUBPROGRAM BODY : Status.Update.Update_Box 

A procedure which updates the four objects which represent the status_box 
surrounding one of the modes. 


OFFSET : Types.WORD; 


begin 

Time_Stamp.Log(0078); --$TP(0078) Status.Update_Box start 
if NEXT MOOE = AUTOMATIC then -- draw status box at 


BOX_LIST(1),XY_NEW.Y 
80X_LI ST(2).XY_NEW.Y 
B0X_LIST(3).XY_NEU.Y 
B0X_LIST(4),XY_NEW.Y 
else 


= Types.COORD I NATE(y_top_start_A); 

- Types.COORD I NATE(y_bottom_start_A); 

= Types.COORD I NATE(y_top_start_A); 

= Types.COORD I NATE(y_top_start_A); 

-- draw status box at 


'automatic' 


'manual' 


80X_LI ST(1).XY_NEW.Y := Types.COORD I NATE(y_top_start_M ); 
BOX_LIST(2).XY_NEW.Y := Types.COORDINATE(y_bottom_start_M); 


- 170 - 







Distributed Issues Final Report 


B0X_LIST(3).XY_NEW.Y := Types.COORDlNATE(y_top_start_M>; 

BOX_LI ST(4).XY_NEW.Y := Types.COORD I NATE(y_top_start_M>; 
end if; 

-- Rendezvous with Graphics to draw new status_box 

Time_Stamp.Log(0079); --$TP(0079) Status.Update_Box rendezvous with Graphics start 
Graphics.Display.Move(MOVE_PRIORITY, BOX_LIST(Types.WORD_lNDEX range box_start..box_end)); 
Time_Stamp.Log(008. --STP(0080) Status.Update_Box rendezvous with Graphics end 

-- Update status_box lists 

for I in Types.WORD_INDEX range box_start .. box_end loop 
80X_lI ST(I).XY_OLD := BOX_LIST(I).XY_NEW; 
end loop; 

Time_Stamp.Log(0081); --$TP(0081) Status.Update_Box end 

end Update_Box; 


procedure Display_0igits<NEXT_DATA : in out Types.WORD; 

STAT : STATUS_TYPE) is 


--| SUBPROGRAM BOOY : Status.Update.Display_Digits 

•*| A procedure which takes the DATA_OLD numbers, divides by 10 to get a 
*-| single digit. That digit is used as an index into Shapes.NUMERIC, whii_h 
--| holds values to draw that number for Graphics. It updates DATA_01D ; n the 
- -1 process. 


DIGIT : Types.WORD; 

STAT_X_L0C : Types.COORD I NATE; 

begin 

Time_Stamp.Log(0082); --$TP(0082) Status.0isplayDigits start 

-- Erase previous data 

for I in 1 .. Config.statistics_length loop 
OATA_OLD(STAT,I).COLOR := Graphics.background_color; 

UORX_LI ST(Types.WORD_INDEX(I)) : = DATA_OLD(STAT,I); 
end loop; 

Time_Stamp.Log(0083); --STP(0083) Status.Display_Digits rendezvous with Graphics(l) start 
Graphics.Display.Move(MOVE_PR!ORITY,WORX_L1ST); 

Time_Stamp.Log(0084); - ;TP(0084) Status.Oisplay_Digits rendezvous with Graphics(l) end 
-- Move new into old, then display 
STAT_X_LOC := base_x; 

for I in reverse 1 .. Config.statistics_length loop 


- 171 - 






Distributed Issues Final Report 


DIGIT := NEXT_D4TA mod 10; -- get rightmost digit 

DATA_OLD(STAT,I).OBJECT:= Shapes.NUMERIC(INTEGERIDIGIT)); 

DATA_OLD(STAT,I).COLOR := Graphics.status_color; 

DATA_OLO(STAT,I).XY_NEW.X := STAT_X_LOC; 

STAT_X_L0C := STAT_X_L0C - Shapes.number_width; -- moving teft 
UORK_LIST(Types.UORD_INDEX(I)) := DATA_OLD(STAT,I); 

NEXT_DATA := NEXTJ3ATA / 10; -- get next digit 

end loop; 

Time_Stamp.Log(0085); --$TP(0085) Status.Oisplay_Digits rendezvous with Graphics(2) start 
Graphics.Displav.MOVE(MOVE_PRI OR ITY,WORK_LI ST); 

Time_Stamp.Log(0086); --$TP(0086) Status.Display_Digits rendezvous with Graphics(2) end 
Time_Stamp.Log(0087); --$T:>(0087) Status.Display_Digits end 
exception 
when others => 

Debug_IO.Put_Line(“Exception raised in Status.Display_Digits"); 
end Display_Digits; 


-- body of UPDATE task 
Begin 

Initialize; -- inside task body call to initialize data structures, et. al. 
loop 

Time_Stamp.Log(0114); --STP(OIK) Status task start 

Time_Stamp.Log(0115); --STP(OIIS) Status accept Signal start 

accept Signal; 

Time_Stamp.l_cg(0088); --$TP(0088) Status accept Signal end 

Interrupt_Control.Enable; 

begin -- exception block 

loop 

Interrupt_Control.Disable; 

DISPLAY_REQUIRED := not MOOE_DI SPLAYED; 

NEXTHOOE := MOOE; 

MOOE_DI SPLAYED := TRUE; 

Interrupt_Control.Enable; 

if DISPLAY_REQUI RED then -- update new statusbox 

Update_Box(NEXT_MOOE); 
end if; 

for I in STATUS_TYPE'first .. STATUS_TYPE'last loop 
Interrupt_Control.Disable; 

DISPLAY_REQUIRED := not STATUS_CONTROL(I).DISPLAYED; 

NEXT_DATA := STATUS_CONTROL(I).DATA; 

STATUS_CONTROL(I).01 SPLAYED := TRUE; 

Interrupt_Control.Enable; 
if DISPLAY_REQUIRED then 
Display_Oigits(NEXT_DATA,: 
end i f ; 
end loop; 

Interrupt_Control.Disable; 

REQ_COUNT := REQ_C0UNT - 1; 


- 172 - 






Distributed Issues Final Report 


exit when REQ_COUMT = 0; 

Interrupt_Control.Enable; 
end loop; 

Time_Stamp.Log(0089); --$TP(0089) Status task end 
exception 

when others => Oebug_iO.Put_line("Exception raised in Status task"); 
end; 

end loop; 
end Update_Type; 

end Status; 


- 173 - 






Distributed Issues Final Report 


UNIT: Sync Package Spec. 

Effects: No current use. Will provide greater synchronize in futr.-- 
--% Modifies: No global data is modified. 

Requires: No initialization is required. 

Raises: No explicitly raised exceptions are propagated. 

--X Engineer: T. Griest. 


- -1 PACKAGE SPEC : Sync 

"I 

--| Package Sync contains a time type for use in synchronizing message 
-*| reception and transferring. 


-- Modifications Log 

-- 88-11-25 : TEG => Original created. 

-- 89-11-22 : MPS -> Created the SEQTYPE to keep track of messages across 
the net synchronized with respect to time. 


with Types; 
package Sync is 

type SEQ_TYPE is new Types.UORDJNDEX; 
end Sync; 


- 174 - 









Distributed Issues Final Report 


--X UNIT: Target Package Spec. 

--X Effects: Provides structure for BOS Target management. 
--X Modifies: No global data is modified. 

--X Requires: No initialization is required. 

--X Raises: No explicitly raised exceptions are propagated. 
--X Engineer: T. Griest. 


--| PACKAGE SPEC : Target 

"I 

--| Package Target provides target tracking and display management. In 
--| addition, it provides the data structures necessary to keep a list 
-*| of targets alive. These data bases are accessed in a guaranteed mutually 
--| exclusive way, since more than one task accesses the data structures 
-*| declared here. The TARGET_DATA_TYPE uses a record representation clause 
--| because the number of allowed targets is a relatively large number. This 
--| number is defined in the constant Config.max_targets. The clause reduces 
--| the number of words necessary from three to one. Although pragma PACK 
--| may have also been used to limit the amount of traffic through the 

rendezvous, it would not have been standard (i.e., the bit ordering may 
--| have been different from implementation to implementation). 


-- Modifications Log 

-- 88-11-12 : TEG => Original created. 


with Types; 
with Config; 

package Target is 

track_stack_size : constant := 3928; 
track_data_stack_size : constant := 1506; 

subtype TARGET_ID_TYPE is Types.WORD_INOEX range 0..Config.max_targets; 

type TARGET_ITEM_TYPE is record -- provides individual target information 
TARGETJD : TARGET_ID_TYPE; 

POSITION : Types.POSITION_TYPE; 

TARGET_CLASS : Types.TARGET_CLASS_TYPE; 

end record; 

type TARGET_LIST_TYPE is -- list of all available targets items 

array(Types.WORD_INOEX range <>) of TARGET_ITEM_TYPE; 

type TARGET_MSG_TYPE is record -- incoming message from Sensor 

NUM_TARGETS : Types.WORDJNDEX; 


- 175 - 







Distributed Issues Final Report 


TARGET_UST : TARGET_LIST_TYPE(Types.TARG£T_INDEX_TYPE); 

end record; 

type TARGET_STATUS_TYPE is record 
ACTIVE : BOOLEAN; 

ENGAGED : BOOLEAN; 

CLASS : Types.TARGET_CLASS_TYPE; 

end record; 

for TARGET_STATUS_TYPE use record 
ACTIVE at 0 range 0..0; 

ENGAGED at 0 range 1..1; 

CLASS at 0 range 2..3; 
end record; 

type TARGET_DATA_TYPE is record 

STATUS : TARGET_STATUS_TYPE; 

POSITION_N£W : Types.POSITIONJTYPE; 

POSITION_OLD : Types.POSITION_TYPE; 

end record; 

type TARGET_DATA_LIST_TYPE is -- used to communicate with Rocket.Control 
array(Types.TARGET_INDEX^TYPE) of TARGET_DATA_TYPE; 

task type Track_Type is 
entry Start; 

pragma PR IOR ITY(Config.tr ack_priority >; 
end Track_Type; 

for Track_Type'STORAGE_SIZE use INTEGERCConfig.bytes__per_storage_unit * 

track_stack_size); 

Track : Track_Type; 

task type Track_Oata_Type is 

entry Put(DATA : in TARGET_DATA_LIST_TYPE; -- put new list 

NEXT_ENGAGE : out TARGET_!0_TYPE; -- get new engagement 

NEXT_OISENGAGE : out TARGET_I0_TYPE); -- and disengagement 

entry GettOATA : out TARGET_DATA_LIST_TYPE; -- get new list 

NEXT_ENGAGE : in TARGET_ID_TYPE; -- put new engagement 

NEXT_DISENGAGE : in TARGET_!0_TYPE); -- and disengagement 

pragma PRIORITYCConfig.track_data_priority); 
end Track_Data_Type; 

for Track_Data_Type'STORAGE_SIZE use INTEGER(Config.bytes_per_storage_unit * 

track_data_stack_size); 

Track_Data : Track_Data_Type; 


end Target; -- package specification 







Distributed Issues Final Report 


--% UNIT: Target Package Body. 

Effects: Provides structure for BOS Target management. 
-■% Modifies: No global data is modified. 

--% Requires: No initialization is required. 

Raises: No explicitly raised exceptions are propagated. 

-•X Engineer: T. Griest. 


--| PACKAGE BODY : Target 

-'I Package Target provides target tracking and display management. 

-- Modifications Log 

-* 88-12-03 : TEG => Original created. 

package body Target is 

task body Track_Type is separate; 
task body Track_Data_Type is separate; 
end Target; -- package body 


- 177 - 










Distributed Issues Final Report 


--% UNIT: Targ_Sup Task Body Subunit. 

--X Effects: Provides Simulator motion control for all targets. 

--X Modifies: Modifies TARGETS and TARGETJUSTORY global data. 

-•X Requires: No initialization is required. 

--X Raises: TARGET_CREATE_ERROR if told to create when max exceeded. 

--X Engineer: M. Sperry. 


--| TASK BOOY : Simulate.Sensor.Targ_Sup 

--I 

-*| A task which sends a list to the caller describing new targets and 
-*| targets which have made it past the bottom border of the BDS and thus are 
--| considered to have been destroyed since these targets are no longer the 
--| concern of the BDS. These targets are described by not being on 
--| the list. Note that new targets are created first and then those 
--| that need to be destroyed are processed. This task is timed so that 
--| the list is ready only during 100 millisecond intervals. In an attempt 
--| to generate random numbers, channel two on the timer chip is used. 


- Modifications Log 

- 88-10-25 : MPS => Original created. 

- 89-08-08 : MPS =» All references to hardware were made to point to HWJTonfig. 

- 89-11-29 : MPS => Re-structured Targ_Sup to use calls in body of Sensor. 


with Calendar; 
with Oebug_IO; 
with Time_Stamp; 
with HU_Config; 
with Distrib; 

pragma ELABORATE(Calendar, Debug_IO, TimeStamp, Distrib); 
separate (Simulate.Sensor) 


task body Targ_Sup_Type is 


use Calendar; 
use Types; 

CURRENT_NUM_OF_TARGETS : 

TARGETCOUNTER 

TEMP 

STARTTIME 
DELAY_PER100 
NEW TARGET ID 


Types.WORD JNDEX; 

Types. WORDJNDEX; 

Types.POSITION_TYPE; 
Calendar.TIME; 

DURATION; 

Types. TARGETJNDEX TYPE; 


for visibility to 

for visibility to "/" etc. 

-- local count of targets 
-• Target index for array 
•- for fixed compiler bug 


- 178 - 











Distributed Issues Final Report 


-- Targ_Sup task body 


begin 

CURRENT_NUM_OF_TARGETS := 0; -- no targets - yet. 

Initialize; 

-- Take the time. 

START_TIME := Calendar.Clock; 
loop 

Time_Stamp.Log(0092); --$TP{0092) Targ_Sup task start 
START_TIME := START_TIME ♦ Config.interval; 

-- Check nunber of Targets; if less than maximum, then add a new 
-- Target to the list. 

if CURRENT_NUM_OF_TARGETS < DiStrib.NUMTARGETS then 
NEW_TARGET_ID := Get_Neu_lD; 

Activate_Target(NEW_TARGET_lD); -- initializes TARGETS and TARGETHISTDRY 
end if; 

-- Move each target. 

for 10 in Types.TARGET_INOEX_TYPE loop 
if TARGETStID).ACTIVE then 

Get_New_Position(ID); -- updates TARGETSCID).POSITION 
end if; 
end loop; 

-- See if any targets made it to the enemy line. 

-- These targets are no longer the concern of the 80S. They 
-- are deleted from the list. 

for ID in Types.TARGET_INDEX_TYPE loop 
Interrupt_Control.Disable; 
if TARGETS(ID).ACTIVE then 

if TARGETS(ID).POSITION.Y < Config.launch_y then 
CURRENT_NUM_OF_TARGETS := CURRENT_NUM_OF_TARGETS - 1; 

TARGETS(ID).ACTIVE := FALSE; 
end if; 
end if; 

Interrupt_Control.Enable; 
end loop; 

-- Move the list into the target list kept by the target spec. 

Time_Stamp.Log(0093); --STP(0093) Targ_Sup accept NextlargetMsg start 
accept Next_Target_Msg(DATA : out Target.TARGET_MSG_TYPE) do 
TARGET_C0UNTER := 0; 
for ID in Types.TARGETJNDEXJYPE loop 


- 179 - 





Distributed Issues Final Report 


Interrupt_Control.Disable; 
if TARGETS(ID).ACTIVE then 
TARGET_COUNTER := TARGET_COUNTER + 1; 

TEMP := TARGETSUO).POSITION; -- fixed compiler code bug 
OATA.TARGET_L!ST(TARGET_COUNTER).POSITION := TEMP; 

DATA.TARGET_LI ST(TARGET_COUNTER).TARGET_CLASS : = 

TARGETSCID).TARGET_CLASS; 
DATA.TARGET_LIST<TARGET_C0UNTER).TARGET_1D := ID; 
end if; 

Interrupt_Control.Enable; 
end loop; 

-- Update number of active targets in the BDS. 

CURR£NT_NUM_OF_TARGEIS := TARGET_C0UNTER; 

DATA.NUMTARGETS := TARGET_COUNTER; 
end Next_Target_Msg; 

Time_Stamp.Log(0094); --$TP(0094) Targ_Sup accept Next_Target_Msg end 

-- Schedule next list out. 

DELAYPERIOO := START_TIME - Calendar.Clock; 
if DELAY_PERIOD < 0.0 then 
START_TIME := Calender.Clock; 
end if; 

Time_Stamp.log(0095); --$TP<0095) Targ_Sup end 

delay DELAYPERIOO; 
end loop; 

accept Clock(Time : in Sync.TIME_TYPE); --T80 
end Targ_Sup_Type; 


- 180 - 





Distributed Issues Final Report 


--% UNIT: Track Task Body Subunit. 

--% Effects: Provides ail target tracking and display for BDS. 
--X Modifies: No global data is modified. 

--X Requires: No initialization is required. 

--X Raises: No explicitly raised exceptions are propagated. 
--X Engineer: T. Griest. 


--| TASK BODY : Target.Track 

"| The TRACK task is used to control all of the target display information. 
--| It accepts data from the Sensor and maintains it for the Rocket.Control 
--| task. It is responsible for accepting the information on the targets 
-*| and giving that information <in the form of a Graphics.UORK_LIST) to 
--| the Graphics task. This routine can be contrasted to Rocket.Control which 
*-| performs many similiar functions for the rockets. 

--| Unlike the Rocket.Control task however, there is no intermediate buffer 
--| task which will allow for schedule slippage like the one between the 
**| Rocket.Control and the Simulate.RDL.Rock_Sup task. 

-*| There is a timing loop done in this task since the rest of the system 
**| derives its timing from this task and the Rocket.Control task. It contains 
--| its own timing mechanism so that if one of the tasks (or possibly another 
-*| processor) goes down, the entire BDS won't be locked up. 


-- Modifications Log 

-- 88-10-04 : TEG => Orignal created. 


with Graphics; 

with Shapes; 

with Interrupt_Control; 

with Grid_to_Pixel; 

with Simulate; 

with 0ebug_!O; 

with Status; 

with Time_Stamp; 

pragma ELABORATE(Graphics,Shapes, Interrupt_Control,Grid_to_Pixel, 
Simulate, 0ebug_10, Status, Time_Stamp); 


separate (Target) 
task body Track_Type is 
use Types; 


package Sensor renames Simulate.Sensor; -- make simulation transparent 


use Types; 
TARGETMSG 
MOVE_TARGETS 
MOVE INOEX 


-- for operators only 
: TARGET_MSG_TYPE; 

: Graphics.MOVE_l!ST_TYPE(Types.TARGET_!NDEX_TYPE); 
: Types.WORDJNDEX; 


- 181 - 






Distributed Issues Final Report 


DESTROYED 
CREATED 
PIXEL_POINT 
TARGETS 
MSGJNDEX 
NEXT_ENGAGED 
NEXT J)ISENGAGED 
COLOR 

ENGAGE_FLAG 
CLASS 
POSITION 
ESCAPED_TARGETS 
begin 

accept Start; 

-- INITIALIZATION 

for I in TARGETS'range loop 

TARGETSfI).STATUS := (FALSE,FALSE,UNKNOWN); -- init to default 
end loop; 

loop 

Time_Stamp.Log(0096); --$TP(0096) Track task start 

TimeJ>tamp.Log(0097); --$TP(0097) Track rendezvous with Targ_Sup start 
Sensor.T a rgSup.Next_T arget_Msg(TARGE T_MSG); 

Time_Stamp.Log(0098); --$TP(0098) Track rendezvous with Targ_Sup end 

-- Zero out counters 

CREATED := 0; 

DESTROYED := 0; 

ESCAPED_TARGETS := 0; 

-- Maintain history information. 

Go through each target to examine its new status 

MSGJNDEX := 1; 

MOVEJNDEX := 0; 

for TARGETJD in TARGETS'RANGE loop 

if TARGETS(TARGETJD).STATUS.ACTIVE then 

if MSGJNDEX > TARGET_MSG.NUM_TARGETS or else 
TARGET_MSG. TARGET LI ST(MSG_I NDEX). TARGET JD 

/= TARGETJO then -- target destroyed 

-- Target has been destroyed, keep local accumulation of destroyed 
-- targets, and add to list for Display task to erase target. 

DESTROYED := DESTROYED ♦ 1; 

If this target has escaped the BDS, count it in the targets which escaped. 


T ypes.WORD; 

Types.WORD; 

Shapes.PIXEL; 

TARGET_DATA_L I ST JYPE ; 

Types.WORDJNDEX; 

Types.WORDJNDEX; -- 0 if no new engagement 
Target.TARGETJDJYPE;-- keep track of disengagements 
Graph ics. COLOR JYPE ; 

BOOLEAN; 

Types. TARGET JLASSJYPE; 

Types. POSIT ION JYPE; -- temp for making changes 
Types.WORD; -- targets which made it past the BDS border 


- 182 - 






Distributed Issues Final Report 


if TARGETS(TARGETJD) .POSITION JIEW.Y <= Config.launch_y then 
ESCAPED_TARGETS := ESCAPED_TARGETS + 1; 
end if; 


To mark as inactive : (ACTIVE => FALSE, ENGAGED => FALSE, CLASS => UNKNOWN) 

TARGETS(TARGETJD).STATUS := (FALSE, FALSE, Types.UNKNOWN); 
MOVEJNDEX := MOVEJNDEX + 1; 

PIXEL_POINT := Grid_To_Pixel(TARGETS(TARGET_IO).POSITION_NEW); 

COLOR := Graphics.background_color; 

HOVE_TARGETS(MOVEJ NDEX) := (PIXEL_P01NT, 

PIXEL_POINT, 

Shapes.TARGET, 

COLOR); 

else -- move the target 

Found a current existing target in the latest sensor report, 
update target information and add it to move list. 

POSITION := TARGET_MSG.TARGET_LIST(MSG_INDEX).POSITION; 

MOVEJNDEX := MOVEJNDEX + 1; 

CLASS := TARGETS(TARGETJD).STATUS.CLASS; 

ENGAGE_FLAG : = TARGETS(TARGETJD) .STATUS.ENGAGED; 

COLOR := Graphics.target_color(CLASS, ENGAGEJL.AG); 

MOVEJARGETS(MOVE_INDEX) : = 

(XY_OLD => Grid_to_Pixel(TARGETS(TARGET_ID).POSITION_NEW), 
XY_NEW => Grid_t o_Pixel(POSITI ON), 

OBJECT => Shapes.TARGET, 

COLOR => COLOR 

); 

TARGETS(TARGETJD). POSIT ION OLD := T ARGETS( TARGET JD).POSIT ION JEW; 
TARGETS(TARGET_ID).POSITION_NEW := POSITION; 

MSG_INDEX := MSGJNOEX ♦ 1; 
end if; -- new/old target check 

else -- this target wasn't previously active 

if MSGJNDEX <= TARGETJiSG.NUMJARGETS and then 
TARGET_MSG.TARGETJIST(MSG_INDEX).TARGETJ 0 

= TARGET_ID then -- new target 


New Target has been created, set status and put it on display 

CREATED := CREATED + 1; 

- mark as active 

TARGETS(TARGETJO).STATUS : = 

(TRUE, -• ACTIVE 

FALSE, -- Engaged 

TARGETJiSG.TARGETJIST(MSG_INDEX).TARGETJILASS); -- class 
TARGETS(TARGETJD).POSITION_OLD := -- set both old and new 

TARGET JiSG. TARGET JI ST (MSGJNDEX). POSIT ION; 
TARGETS(TARGET_ID).POSITION_NEW := 


- 183 - 




Distributed Issues Final Report 


TARGET_MSG.TARGET_LI ST (MSG_INDEX).POSiTI ON; 
HOVE_INDEX := MOVEJNDEX + 1; 

CLASS := TARGETS(TARGETJD).STATUS.CLASS; 

ENGAGE_FLAG := TARGETS!TARGE1 ID).STATUS.ENGAGED; 

COLOR := Graphics.target_color(CLASS, £NGAGE_FLAG); 

MOVE_TARGETS(MOVE_INDEX) : = 

(XY_OLD => Grid_to_Pixel(TARGETS!TARGET_ID).POSITION_OLD), 
XY_NEW => Grid_to_Pixel(TARGETS!TARGET_ID).POSITION_NEW), 
OBJECT => Shapes.TARGET, 

COLOR => COLOR 

); 

MSG_INDEX := MSG_INDEX ♦ 1; 

end if; -- end of new target check 

end if; -- active check 

end loop; 


Now update status if any created or destroyed 

if CREATED /= DESTROYED or DESTROYED > 0 then 
Interrupt_Control.Disable; 

Status.STATUS_CONTROL(Status.TRACKED).DATA := 

Status.STATUS_CONTROL(Status.TRACKED).OATA + (CREATED - DESTROYED); 
Status.STATUS_C.‘:TROL(Status.TRACKED).DISPLAYED := FALSE; 

Status.STATUS_CONTROL(Status.DESTROYED).DATA := 

Status.STATUS_CONTROL(Status.DESTROYED).DATA + 
DESTROYED - E$CAPEO_TARGETS; 

Status.STATUS_CONTROL(Status.DESTROYED).DISPLAYED := FALSE; 

Status.REQ_C(XJNT := Status.REQ COUNT + 1; 
if Status.REQ_COUNT = 1 then 

Time_Stamp.Log(0099); --$TP(0099) Track rendezvous with Status start 
Status.Update.Signal; 

Time_Stamp.Log(0100); --$TP(0100) Track rendezvous with Status end 
end if; 

Interrupt_Control.Enable; 
end if; 

Time_Stamp.Log(0101); --STP(OIOI) Track rendezvous with Track_Data start 
Target.Track_Data.Put!TARGETS,NEXT_ENGAGED,NEXT_DISENGAGED); 

-- send copy to Rocket.Control 
Time_Stamp.Log(0102); --STP(0102) Track rendezvous with Track_Data end 

if NEXT_ENGAGEO > 0 then 

TARGETS(NEXT_ENGAGED).STATUS.ENGAGED := TRUE; -- set engaged 
end if; 

if NEXT_DISENGAGED > 0 then 
TARGETS(NEXT_DISENGAGEO).STATU..ENGAGED := FALSE; 
end if; 

Time_Stanp.Log(0103); --$TP(0103) Track rendezvous with Graphics start 
Graphics.Display.Move!Graphics.LOW, MOVE_TARGETS( 1. .MOVEJNDEX)); 
Time_Stamp.Log(0104); --STP(0104) Track rendezvous with Graphics end 
Time_Stamp.Log(0105); -*STP(0105) Track task end 


- 184 - 








Distributed Issues Final Report 


end loop; 
exception 
when others => 

Debug_IO.Put_Line("TRACK termination due to exception."); 
end Track_Type; 


- 185 - 






Distributed Issues Final Report 


--X UNIT: Track_Data Task Subunit. 

--% Effects: Provides buffering of target tracking data between the 
■•X Track task and the Control task for rocket engagement. 

--X Modifies: No global data is modified. 

--X Requires: No initialization is required. 

-•X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: T. Griest. 


--| TASK Beer : Target.Track_Oata 

-*| The Track_Oata task is used to buffer the most recent target list 
-•| from the Target.Track task and provide it to the Rocket.Control 
--| task. It also buffers new engagements or disengagements from the 
--| Rocket.Control task to notify the Target.Track task that a new target 
--| has been engaged or an old target destroyed. 

--| Note that only one new target can be engaged every update interval. 
--| If the NEXT_ENGAGE parameter is 0, this is an invalid TARGETED, and 
--| implies that no new target is engaged. 

--| Although there is a guard used here, it is only used for the first 
--| rendezvous from Rocket.Control. This helps the BOS system to achieve a 
--| known initial state and asynchronous timing. 


-- Modifications Log 

-- 88-10-11 : TEG => Original created. 


with Time_Stamp; 
with Interrupt_Control; 

pragma ELABORATEDime_Stamp, Interrupt_Control); 

separate (Target) 

task body TrackJ)ata_Type is 
use Types; 

BUFFERED_DATA : Target.TARGET_DATA_LIST_TYPE; 

BUFFERED_ENGAGE : Target.TARGET_ID_TYPE; 

BUFFERED_DISENGAGE : Target.TARGET_ID_TYPE; 

DATA_COUNT : Types.WORD := 0; 

begin 

Initialize local copy of data 
initialize all target status to: 

(ACTIVE => FALSE, ENGAGED => FALSE, CLASS => UNKNOWN) 

BUFFERED_ENGAGE := 0; -- default is no new engagement 


- 186 - 











Distributed Issues Final Report 


for I in BUFFER£D_DATA'range loop 
BUFFERED_DATA(I).STATUS := (FALSE, FALSE, Types.UNKNOWN); 
end loop; 
loop 
select 

accept Put(DATA : in TARGET_DATA_LIST_TYPE; 

NEXT_ENGAGE : out TARGET_ID_TYPE; 

NEXT_01SENGAGE : out TARGET_IO_TYPE) do 

Time_Stamp.Log(0106); --$TP(0106) Trackdat accept Put start 

Interrupt_Control.Disable; -- BUGFIX for RTE 
BUFFERED_DATA := DATA; 

Interrupt_Cont rol.Enable; 

NEXT_ENGAGE := BUFFERED_ENGAGE; 

NEXT_DISENGAGE := BUFFEREDJHSENGAGE; 

DATA_CCXJNT := 1; 

Time_Stamp.Log(0107); --$TP(0107) Trackdat accept Put end 
end Put; 
or 

when DATA_COUNT > 0 => 

accept Get(DATA : out TARGET_DATA_LIST_TYPE; 

NEXT_ENGAGE : in TARGET_ID_TYPE; 

NEXTDISENGAGE : in TARGET_ID_TYPE) do 

Time_Stamp.Log(0108); --$TP(0108) Trackdat accept Get start 

InterruptControl.Disable; -- BUGFIX for RTE 
DATA := BUFFERED_DATA; 

Interrupt_Control.Enable; 

BUFFEREDENGAGE := NEXT_ENGAGE; 

BUFFERED_DISENGAGE := NEXTDISENGAGE; 

DATA_COUNT := 1; 

Time_Stamp.Log(0109); *-$TP(0109) Trackdat accept Get end 
end Get; 
end select; 
end loop; 

end Track_Data_Type; 


- 187 - 






Distributed Issues Final Report 


--% UNIT: Traject Function Spec. 

-■% Effects: Computes rocket motion based on previous motion and 
--X aimpoints received in guidance messages. 

--X Modifies: No global data is modified. 

--X Requires: No initialization is required. 

•-X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: R. Chevier. 


--| SUBPROGRAM SPEC : Traject 

**| Function Traject takes the current rocket information including the 
--| direction it is headed in and determines the new absolute position 
--| of the rocket. This work is done in a three dimensional system. 

-- Modifications Log 

-- 88-10-29 : TEG => Original created. 

-- 89-08-29 : MPS => Original replaced by R. Chevier's version. 

with Types; 
package Traject is 

procedure Get_New_Position(ROCKET_ID : Types.WORD_INDEX; 

AIMPOINT : Types.AIMP01NT_TYPE; 

POS : out Types.POSITION_TYPE); 

end Traject; 


- 188 - 











Distributed Issues Final Report 


--XUNIT: Traject Function Body. 

--X Effects: Computes rocket motion based on previous motion and 
--X aimpoints received in guidance messages. 

--X Modifies: No global data is modified. 

-•% Requires: No initialization is required. 

--X Raises: No explicitly raised exceptions are propagated. 

--X Engineer: R. Chevier 


--| SUBPROGRAM BODY : Traject 

--| Function Traject: Is the trajectory planner for rockets and takes an 
--| Azimuth, Elevation X,Y,Z position and constant velocity and returns a new 
-*| rocket position. 

-- Modifications Log 

-- 88-12-01 : TEG => Original created. 

-- 89-08-29 : MPS => Replaced original with R. Chevier's version. 

-- 89-09-07 : MPS => Added the Get_New_Position function 

with Config; 

with Parameter_Data_Base; 
with Rocket; 
with Math; 
with Time_Stamp; 

pragma ELABORATE(Math); 

package body Traject is 

use Types; -- fo r operators 

use Math; -- for faster fixed math 

bam_converter : constant Types.LONG_FIXED := 182.03125; 

type DRIFT_RECORD_TYPE is record 
SIN_A2IMUTH : Types.LONG_FIXE0 := 0.0; 

SIN_ELEVATION : Types.LONG_FIXED := 0.0; 

COS_AZIMUTH : Types.L0NG_FIXED := 0.0; 

COS_ELEVATION : Types.LONG_FIXED := 0.0; 
end record; 

type VELOCITY_RECORD_TYPE is record 
X : Types.LONG_FIXED := 0.0; 

Y : Types.L0NG_F1XED := 0.0; 

Z : Types.10NG_FIXED := 0.0; 
end record; 


- 189 - 









Distributed Issues Final Report 


type 10CAI_R0CKET_REC is record 
ACTIVE : BOOLEAN : = FALSE; 

POSITION : Types.POSITION_TYPE; 

VELOCITY : VELOCITY_RECORD_TYPE; 

ANGLE : Types.AlMPOINT_TYPE; 

FUEL : Types.LONG_FIXED; 

end record; 

type ROCKET_HISTORY_REC is record 
LOCAL_ROCKET : LOCAL_ROCKET_REC; 

GUIDANCE : Rocket.ROCKET_GUIOE_TYPE; 

ROCKET_DEFAULTS ; Parameter_Data_Base.ROCKET_PARAMETER_TYPE; 

DRIFT : DRIFT_RECORD_TYPE; 

DELTA_T : Types.RATE_TYPE := Types.RATE_TYPE(Config.interval); 

end record ; 

type ROCKET_H ISTOR Y_ARRAY is array(Types.ROCKET_IND£X_TYPE) of 
ROCKET_HISTORY_R EC; 

ROCKET_HISTORY : ROCKET_HISTORY_ARRAY; 

procedure Initialize(INDIVIDUAL_ROCKET_HISTORY : in out ROCKET_HISTORY_REC) is 
begin 

INDIVIDUAL_ROCKET_HI STORY.LOCAL_ROCKET.ACTIVE := TRUE; 

I ND IVIDUAL_ROCKET_H I STORY. LOCAL_ROCKET .VELOCITY ; = (0.0,0.0,0.0); 

INDIVIDUAL_ROCKET_HI STORY.LOCAL_ROCKET.ANGLE := C Config.Iaunch_az imuth, 

Config.Iaunch_elevation); 
INOIVIDUAL_ROCKET_HISTORY.LOCAL_ROCKET.FUEL := Parameter_Data_Base.c_fuel; 

INDIVIDUAL_ROCKET_HI STORY.LOCAL_ROCKET.POSITION := (Config.Iaunch_x, 

Config.launch_y,Config.launch_z) 

end Initialize; 

procedure Turn_Rocket 

(FUEL : in out Types.LONG_FIXED; 

ROCKET_ANGLE : in out Types.BAM; 

BDS_ANGLE : Types.BAM; 

DELTA_T : Types.RATE_TYPE; 

TURN_RATE : Types.LONG_FIXED; 

TURN_BURN_RATE : Types.LONG_FIXED) is 

MAX_TURN : Types.LONG_FIXED; 

DELTA_ANGLE : Types.LONG_FIXED; 

FUEL_USED : Types.LONG_FIXED; 

BURN_TIME : T ypes.LONG_FIXED; 

BAMS_TURNED : Types.LONG_FIXED; 

DEGREES_TO_TURN : Types.LONG_FIXED; 

begin --Turn_Rocket 

Time_Stamp.Log(0118); --$TP(0118) Traject.Turn_Rocket start 
DELTA_ANGLE := Types.LONG_FIXED(BDS_ANGLE) - Types.LONG_FIXED(ROCKET_ANGLE); 


- 190 - 






Distributed Issues Final Report 


if DELTA_ANGLE /- 0.0 and FUEL > 0.0 then -- don't turn it if told not to 
HAX_TURN := DELTA_T * TURNJJATE; 

-- If the rotation in this iteration turns the rocket too far 
-- then calculate only the fuel needed to rotate the rocket 
-- the required amount. 

DEGREES_TO_TURN := abs DELTA_ANGLE / bam_converter; 
if DEGREES_TO_TURN < MAX_TURN then 
BURN_TIME := abs DEGREES_TO_TURN / TURN_RATE; 

FUELJJSED := TURN_BURN_RATE * abs DEGREES_T0_TURN; 

ROCKET_ANGLE := B0S_ANGLE; 

- -PutCBDS Angle :••); Int_IO.Put(BDS_ANGLE); New_Line; 

--PutCRocket Angle Int_IO.Put(ROCKET_ANGLE); New_Line; 

--PutCOelta Angle Long_Fxd_10.Put(DELTA_ANGLE); New_Line; 

--PutCTurn Rate Long_Fxd_IO.Put(TU?N_RATE); New_Line; 

--PutO'Turn Burn Rate Long_Fxd_I0.Put(TURN_BURM_RATE);New_Line; 

--PutO'Burn Time Long_Fxd_10.Put(BURN_TIHE); New_Line; 

--PutO'Completed Turn Fuel: 11 ); Long_Fxd_IO.Put(FUEL_USED); Mew_Line; 

else 

-- Or if the time step was not large enough for rotation 
-- completion then calculate FUEL used and new ANGLE based on 
-- rotation completed during this step. 

FUEL_USED := TURNBURNRATE * MAX_TURN; 

if DELTA_ANGLE < 0.0 then -- subtract from current direction 

BAMS_TURNED := MAX_TURN * bamconverter; 

ROCKET_ANGLE := ROCKET_ANGLE - Types.BAM(BAMS_TURNED); 
else -- add to current direction 

BAMS_TURNED := MAX_TURN * bam_converter; 

ROCKET_ANGLE := ROCKET_ANGLE + Types.BAM(BAMS_TURNED); 
end if; 
end if; 

FUEL := FUEL - FUELJJSED; 
if FUEL < 0.0 then 
FUEL := 0.0; 
end if; 
end if; 

Time_Stamp.Log(0119); --$TP(0119) Traject.Turn_Roeket end 
end Turn_Rocket; 

procedure Calc_Trajectory 

(LOCAL_ROCKET : in out LOCAL_ROCXET_REC; 

GUIDANCE : Rocket.ROCKET_GUIDEJTPE; 

ROCXET_0EFAULTS : Parameter_Data_Base.ROCKET_PARAMETER_TYPE; 

OR I FT : DRIFT_REC0R0_TYPE; 

DELTA_T : Types.RATE_TYPE) is 


- 191 - 







Distributed Issues Final Report 


drag 


gravity 

VX 

VY 

VZ 

X 

Y 

Z 

ELEVATION 

AZIMUTH 

FUEL 

FORWARO_VELOCITY 

THRUST 

TOTAL_MASS 

DRAG_FORCE 

AY,AX,AZ 

SIN_ELEVATION 

COS_ELEVATION 

COS_AZIMUTH 

SIN_AZIMUTH 

TEMP VAL 


constant Types.LONG_FIXED := 0.984375; 
-- roughly 2% of velocity per iteration 
constant Types.LONG_FIXED := 9.80665; 


T ypes.LONG_FIXED 
T ypes.LONG_FIXEO 
T ypes.LONG_FIXED 
T ypes.LONG_FIXED 
T ypes.L0NG_FIXEO 
Types.LONG_FIXED 
Types.BAM 
Types.BAM 
T ypes.LONG_FIXED 
T ypes.LONG_FIXED 
T ypes.LONG_FIXED 
T ypes.LONG_FIXED 
Types.LONG_FIXED 
T ypes.LONG_FIXED 
T ypes.LONG_FIXED 
T ypes.LONG_FIXED 
T ypes.LONG_F IXED 
T ypes.LONG_FIXED 
Types.LONG_FIXED 


:= (LOCAL_ROCKET.VELOCITY.X); 

:= (LOCAL_ROCKET.VELOCITY.Y); 

:= (LOCAL_ROCKET.VELOCITY.Z); 

:=Types.LONG_FIXED{LOCAL_ROCKET.POSITION.X); 
:=T ypes.LONG_FIXED(LOCA L_ROCKE T.POSlTION.Y); 
:=Types.LONG_FIXED(LOCAL_ROCKET.POSITlON.Z); 
:= Types.BAM(LOCAL_ROCKET.ANGLE.E LEVATION); 

:= Types.BAM(LOCAL_ROCKET.ANGLE.AZIMUTH); 

:= LOCAL_ROCKET.FUEL; 


begin -- Calc_Trajectory 

Time_Stamp.Log(0120); --STP(0120) Traject-Catc_Position start 
SIN_ELEVATION := Math.Sin<ELEVATION); 

SINJIZIMUTH := Math.Sin(AZIMUTH); 

COS_ELEVATION : = Math.Cos(ELEVATION); 

COS_AZIMUTH := Math.Cos(AZIMUTH); 

TEMPVAL := VX*VX + VY*VY ♦ VZ*VZ; 

FORUARD_VELOCITY := Math.Sqrt(TEMPVAL); 


-- Check amounc of fuel left. 


if FUEL <=0.0 then 
THRUST := 0.0; 
else 

THRUST := ROCKET_DEFAULTS.THRUST; 
end if; 

TOTAL_MASS := ROCKET_DEFAULTS.MASS ♦ FUEL; 

--PutO'Thrust :••); Long_Fxd_IO.Put(THRUST); New_Line; 
--Put(“Drag_Force :"); Long_Fxd_IO.PUT(DRAG_FORCE); New_Line; 
--Put("Cos_Elev :»); Long_Fxd_IO.Put(COS_ELEVATION); New_Line; 
--Put("Sin_Az :'■); Long_Fxd_IO.Put(SIN_AZIMUTH); New_Line; 
--Put("Total_Mass :"); Long_Fxd_IO.Put(TOTAL_MASS); New_Line; 

COMPUTE ACCELERATION IN EACH AXIS 


0RAG_FORCE := 0.0; -- for now, null out drag acceleration 

AY := ((THRUST - DRAG_FORCE) * COS_ELEVATION) * SIN_AZIMUTH; 

AY := AY / TOTAL_MASS; 


- 192 - 







Distributed Issues Final Report 


AX := ((THRUST - DRAG_FORCE) * COS_ELEVATION) * COS_AZIMUTH; 
AX := AX / TOTAL_MASS; 

AZ := (THRUST - ORAG_FORCE) * S1N_ELEVATI0N; 

AZ := AZ - TOTAL_MASS * gravity; 

AZ := AZ / TOT*L_MASS; 

lose X of velocity per/iteration due to drag 

LOCAL_ROCKET.VELOCITY.X := DELTA_T * AX + VX * drag; 

LOCAL_ROCKET.VELOCITY.Y := DELTA_T * AY + VY * drag; 

LOCAL_ROCKET.VELOCITY.Z := DELTA_T * AZ ♦ VZ * drag; 


- Update position of rocket 

X := X DELTA_T * LOCALROCKET.VELOCITY.X; 
LOCAL_ROCKET.POSITION.X := X; 

Y := Y + DELTA_T * LOCAL_ROCKET.VELOCITY.Y; 
LOCAL_ROCKET.POSITION.Y := Y; 

Z := Z + 0ELTA_T * LOCAL_ROCKET.VELOCITY.Z; 
LOCAL_ROCKET.POSITION.Z := Z; 


New_Line; 

Put_Line(" Velocity Acceleration"); 

Long_Fxd_IO.Put(LOCAL_ROCKET.VELOCITY.X,6,2,0); 

Long_Fxd_IO.Put(AX,6,2,0); 

Put_Line(" X»); 

Long_Fxd_IO.Put(LOCALROCKET.VELOCITY.Y,6,2,0); 

LongFxd_IO.Put(AY,6,2,0); 

Put_Line(" Y"); 

Long_Fxd_I0.Put(LOCAL_ROCKET-VELOCITY.Z,6,2,0); 
Long_Fxd_I0.Put(AZ,6,2,0); 

Put_Line(" Z»); 

New_Line; 

Check for impacts to speed up code 
if Z > 0.0 then 

When finished with the calculation update the current mass. 

LOCAL_ROCKET.FUEL := FUEL - DELTA_T * ROCKET_DEFAULTS.BURN_RATE; 
if LOCAL_ROCKET.FUEL <0.0 then 
LOCAL_ROCKET.FUEL := 0.0; 
end if; 


-- Calculate rocket turns. 

Turn_Rocket (LOCAL_ROCKET.FUEL, 

LOCAL_ROCKET.ANGLE.ELEVATION, 
GUIDANCE.AIMPOINT.ELEVATION, 
DELTA_T, ROCKET_DEFAULTS.TURN_RATE, 


- 193 - 







Distributed Issues Final Report 


ROCKET_DEFAULTS.TURN_BURN_RATE); 

Turn_Rocket (LOCAL_ROCKET.FUEL, 

LOCAL _ROCKET.ANGLE.AZIMUTH, 

GUIDANCE.AIMPOINT.AZIMUTH, 

DELTA_T, ROCKET_DEFAULTS.TURN_RATE, 
ROCKET_DEFAULTS.TURN_BURN_RATE); 

end if; 

Time_Stamp.Log(0121); --$TP(0121) Tra]ect.Calc_Position end 
end Calc_Trajectory; 


procedure Get_New_Position(ROCKET_!D : Types.WORD_INDEX; 

AIMPOINT : Types.AIMPOINT_TYPE; 

POS : out Types.P0SITION_TYPE> is 


begin 

Time_Stamp.Log<0110); --STP(OIIO) Traject Start 
if not ROCKET_HISTORY(ROCKET_ID).LOCAL_ROCKET.ACTIVE then 
Initialize(ROCKET_HISTORY(ROCKET_ID)); 
end if; 

ROCKET_HlSTORY(ROCKET_ID).GUIDANCE.AIMPOINT := AIMPOINT; 

Calc_T ra j ectory(ROCKET_HI STORY(ROCKETJ D).LOCAL_ROCKET, 

ROCKETHISTORY(ROCKET_ID).GUIDANCE, 

ROCKETJiI STORY(ROCKET_ID).ROCKET_DEFAULTS, 
ROCKET_HISTORY(ROCKET_I0).DRIFT, 

ROCKET_HI STORY(ROCKET_IO).DELTA_T); 

POS := ROCKET_HISTORY(ROCKET_IO).LOCAL_ROCKET.POSITION; 
if ROCKET_HISTORY(ROCKET_ID).LOCAL_ROCKET.POSITION.? <= 0.0 then 
ROCKET_HISTORY(ROCKET_ID).LOCAL_ROCKET.ACTIVE := FALSE; -- kill the rocket 
end if; 

Time_Stamp.Log(0111); --$TP(0111) Traject end 
end Get_New_Position; 

end Traject; 


- 194 - 





Distributed Issues Final Report 


--X UNIT: Types Package Spec. 

--X Effects: Provides general purpose data types. 

--X Modifies: No global data is modified. 

--X Requires: No initialization is required. 

--X Raises: No explicitly raised exceptions are propagated. 
--X Engineer: T. Griest. 


PACKAGE SPEC : Types 

This package contains all the global types needed for the BOS and the 
simulator. The type WORD and its derivatives replace the type INTEGER 
to increase portability. The type BAM is an acronym for a Binary Angle 
Measurement and the transformation from degrees to BAMs is performed by 
BAMs = 32767/180 * degrees. The BDS and the simulator use three 
dimensional components and the screen (obviously) display of the event 
shows it in two dimensions only. 


Modifications Log 

88- 10-10 : TEG => Original created. 

89- 08-29 : MPS => Added definitions for new rocket flight path equations. 


with Config; 
package Types is 

type WORD is range -32768 .. 32767; 
for WORD'size use 16; 

type WORD_INDEX is range 0 .. 32767; 
for WORDJNDEX'size use 16; 

subtype ROCKET_INDEX_TYPE is WORO_INDEX range 1..Config.max_rockets; 
subtype TARGET_INDEX_TYPE is WORDJNDEX range 1. .Config.max_targets; 

subtype COORDINATE is Types.WORD; 
subtype REl_COORD!NATE is Types.WORD; 


type METERS is delta 0.125 range -Config.meters_in_battle_area .. 

Config.meters_in_battle_area; 

type LONG_FIXED is delta 0.015625 range -33_554 432.0..33_554_431.0; 
for LONGJUXED'size use 32; 

-- RATE_TYPE is used to compute velocities and accel accurately (2**-16) 


- 195 - 














Distributed Issues Final Report 


type RATE_TYPE is delta 1.525879E-5 range -32_768.0..32_767.0; 
for RATE_TYPE'size use 32; 


sqrt_large_nurber : constant := 2508.0; 

type POSITI0N_TYPE is record 
X : LONG_FIXED; 

Y : LONG_FIXED; 

Z : LONG_FIXED; 

end record; 

type BAM is range -32768 .. 32767; 

type EXTENDEDBAM is new LONGJNTEGER; 

type AIMPOIHT_TYPE is record 
AZIMUTH : BAM; 

ELEVATION : BAM; 

end record; 


-- approx sqrt(LONG_FIXED'last)/4 

-- for absolute position 
-- assume battlefield oriented ENU 


-- binary angle measurement 32768/180 
-- East North Up origins (0) 

-- for large calculations 


-- T80 - Main Battle Tank 

-- SA9 - GASKIN surface to air missle launcher 

-- BMP2 - Infantry Combat Vehicle 

type TARGET_CLASS_TYPE is (UNKNOWN, T80, SA9, BMP2); 

end Types; 


- 196 - 




Distributed Issues Final Report 


--% UNIT: Distrib Package Body. 


--( PACKAGE 800Y : Distrib 

--I 

--| OPERATION : 

--| This package body makes calls to the runtime in order to obtain 
--| configuration values which are based on the number of available 
- -1 processors. 


-- Modifications Log 

-- 88-12-05 : TEG => Original Created. 

-- 89-12-06 : TEG => Enhanced to support dynamic comiguration/reconfiguration 


DISTRIBUTION CONTROL PARAMETERS 


package body Distrib is 

type BOUND_TYPE is (LOW,HIGH); 

subtype GUIDE_RANGE is Types.WORD_INDEX range 1..Distrib.max_guide_tasks; 
ROCKET_CONFIG : array (GUIDE_RANGE,GUIDE_RANGE,B0UND_TYPE) 
of Types.UORDINDEX := 

-- if 1 task, all rockets on #1 

(1 => (1 => (LOU => 1, HIGH => 20), 2 => (LOU => 1, HIGH => 1)), 

-- if 2 tasks, 5 rockets on #1, 15 on #2 

2 => (1 => (LOU => 1, HIGH => 5), 2 => (LOU => 6, HIGH =» 20))); 


-- The folluing four functions provide configuration information based 
on operator entered information and system configuration operations. 
They are provided by the Distributed RunTime Environment 

function Get_Num_Rockets return Types.WORDINDEX; 

function Get_Num_Targets return Types.W0RD_INDEX; 

function Get_Nun_Guide_Tasks return Types.UORD_IHDEX; 

function Get_Master_Status return BOOLEAN; 


LATER DECLARATIVE ITEMS (B001ES) 


-- RESTART is used to stop operation 
-- setup a different configuration. 

button is pressed while the RESET 
-- The Ada body version simply locks 


of the BDS and allow the operator 
It is only called whpn the MOOE 
button is held down on the mouse, 
up the machine with interrupts disabled. 


- 197 - 















Distributed Issues Final Report 


pragma INTERFACECASM86, Get_Num_Guide_Tasks); 

pragma lNTERFACE_SPELLtNG(Get_Num_Guide Tasks, "01DRTE7GETTASKS"); 
pragma 1NTERFACE(ASM86, Get_Num_Taraets); 

pr agma INTERFACE_SPELLING(Get_Num_Targets, "D1DRTE7GETTARGETS"); 
pragma INTERFACE(ASM86, Get_Num_Rockets); 

pragma INTERFACE_SPELLING(Get_Num_Rockets, "D1DRTE7GETR0CKETS"); 
pragma INTERFAC£(ASM86, Get_Master_Status); 

pragma INTERFACE_SPEllING(Ge , ’_Master_Status, "D1DRTE7GETMASTER"); 
begin 

NUM_ROCKETS := Get_Num_Rockets; 

NUH_TARGETS := Get_Num_7argets; 

NUM_GUIDE_TASKS := Get_Num_Guide_Tasks; 

MASTER := Get_Master_Status; 

for I in Types.UORDJNDEX range 1. .NUM_GUIDE_TASKS loop 
Guide_Low (I) := ROCKET_CONF IG(NUM_GUIDE_TASKS,1,LOW); 
Guide_High(I) := ROCKET_CONFIG(NUM_GUIOE_TASKS,I.HIGH); 
end loop; 
end Distrib; 


- 198 - 














Distributed Issues Final Report 


12 Appendix B - Distributed Runtime Source Code 

The source code for the distributed runtime uses an 8086 family assembly language code. It 
is divided into modules which implement the major functional areas. These include: 
Initialization and system configuration, interprocessor synchronization, runtime routines, 
network setup, network I/O, distributed task control blocks, and the vendor runtime 
interface. Two include files: DA_HW.ASM and DAJ3EF.ASM are used to define system 
constants and data structures. 


- 199 - 





Distributed Issues Final Report 


■XLIST 


FILE: DA_DEF.ASM 

Distributed Ada - Definitions 

Definitions for system values 

Copyright (C) 1989, LabTek Corporation 


DEF_VRTIF_ADDR equ 4000H 

DEF_addr_size equ 3 ; # of WORDS in Ethernet Address 


NETWORK MESSAGE CONTROL FIELD VALUES 

The first 6 fields are constant for ALL network traffic 


1 

packet 

struc 




DEF_pkt_dest 

dw 

3 dup (? 

) 


DEF_pkt_souree 

dw 

3 dup (? 

) 


DEF_pkt_length 

dw 

? 



DEF_pkt_sequence 

dw 

? 



DEF_pkt_cmd 

dw 

? 

i 

designate type of message 

DEF_pkt_TID 

dw 

? 

destinat' 

task id 

DEF_pkt_entry_ID 

dw 

? 



DEF_pkt_my_PID 

dw 

? 

source processor ID 

DEF_pkt_my_TID 

dw 

? 

source task 

ID 

DEF_pkt_data 

dw 

? 

data always 

starts here 

packet 

ends 




# 

; Offset from list 

pointer to 

next node 

pointers 



DEF_next_ptr 


equ 2 

; offset to next pointer in buffer 

DIR_entry 

struc 



DTCB_dir_local 

dw 

? 

; local/distrib runtime flag 

DTCB_dir_pid 

dw 

? 

; PID for this task 

DTCB_dir_TCB 

dw 

? 

; pointer to distrib TCB 

DTCB_dir_COUNT 

dw 

? 

; Counter for task type 

DIR_entry 

ends 



DTCB_dir_size 

equ 

size DIR_ENTRY 

; size of each entry 


TCB Offsets 


DEF_tcb_reply 

equ 

6 

DEF_return_addr 

equ 

8 

DE F_num_ent ries 

equ 

12 

DEF_entry_table 

equ 

14 


Within each TCB is an entry table 

The table contains a record for each entry with the following fields: 


- 200 - 











Distributed Issues Final Report 


DEF_entry_rec 

struc 


DEF_entry_profile_ptr 

dw 


0EF_entry_wait 

dw 

7 

DE F_ent ry_queue 

dw 

7 


dw 

7 

DEF_entry_rec 

ends 



CPU Designations 


t 

DEF_max_cpus 

equ 

3 

; maximum number of CPUs 

0EF_alpha 

equ 

0 


DEF_bravo 

equ 

1 


DEF_charlie 

equ 

2 


DEF_NA 

equ 

-1 

; not applicable (no CPU 


PROCESSOR / TASK / ENTRY IDs 
Note: PIDs increment by 6, 
TIDs and EIDs by 2. 
TASK IDs are unique. 


; COMMANDS received 

via messages 


DEF_sync_start 

1 M < » M 

equ 

0 


DEF_sync_ready 

equ 

1 


DE F_sync_continue 

equ 

2 


OEF_request_entry 

equ 

3 


DE F_rendezvous_end 

equ 

A 


DEF_local_catl 

equ 

5 


0EF_ACK 

equ 

-1 


DEF_cold_start 

equ 

6 


» 

; SYNC PHASE packet 

retry/delay values 


DEF_retry_times 

equ 

5 


DEF_sync_delay 

equ 

10 

; some delay between retries 

DE F_UATCH_DOG_LIMIT 

equ 

100 

; 10ms per count 


- 201 - 















Distributed Issues Final Report 


Parameter Passing convention to runtime network msg routines. 

Standard Call Frame for lO_Xmit (This is reverse order of being pushed) 
Therefore these values can be used relative to the BP 


xmit 

st rue 




dw 

2 dup(?) 

reserve space for near return and bp 

DEF_PID 

dw 

? 

destination processor ID 

DEF_CHD 

dw 

? 

command for this packet 

DEF_TID 

dw 

? 

Task for which the conmand operates 

DEF_ENTRY 

dw 

? 

entry ID for the command (if applicable) 

DEF_MY_Tl[) 

dw 

? 

originating Task ID 

DEF_PROFILE 

dw 

? 

profile pointer (in CS) for entry parameters 

DEF_HOOE 

dw 

? 

current calling mode (in or out) 

DEF_PARM_LIST 

dd 

? 

pointer (seg/offset) for parameter list 

xmi t 

ends 



DEF_xmit_frame 

equ 

size xmit ; size of parameter frame 


; Parameter 

Constraint 

Layout 


t 

constraint 

st rue 



DEF_low_desc 

dw 

? 


0EF_high_desc 

dw 

7 


DEF_size_desc 

dw 

? 


constraint 

ends 



DEFjn 

equ 

1 


DEF_out 

equ 

2 


DEF_in_out 

equ 

3 

; bit-wise “or" of "in" 


Parameter Profile Layout 


* Number of Parameters * 


* PARM1 : Mode * ; in, out, or in_out 


PARM1 : Type/Length * ; negative if unconstrained, otherwise 

. thls j s a word count 


Task Control Block Layout 

TASK_ID: each block is pointed to by an entry in the 

TASK_DI RECTORY which is indexed by the TID. The TID 


- 202 - 



















Distributed Issues Final Report 


is essentially the task's priority (with a provision 
for tasks of the same type to have sequentially lower 
priority as they are created. 

Sync_Semaphore: The sync semaphore is used to suspend (or resume) 
execution of the associated task for rendezvous. 

Reply Pointer: Contains the buffer descriptor of the reply msg. 

Number of Entries: provides the number of entries for this task. 

Entry_Table: The Entry table provides a record for each of the 
entries defined in the task. The record contains: 

PROFllE_PTR: pointer to the parameter profile 
described above. 

WAITING : flag indicating that the accepting 
task is waiting for an entry call 
for this entry. 

Queue : Head of buffer descriptor linked to 
this entry. 


• LIST 


- 203 - 









Distributed Issues Final Report 


■XLIST 


FILE: DA_HW.ASM 

Distributed Ada - Hardware Definition Include File 
Copyright(C) 1989, LabTek Corporation, Woodbridge, CT USA 


Ethernet Board Hardware Configuration 


f 

base 

equ 

310H 

1 

; base address of board 

vector_number 

equ 

5H 

; vector nunber for board 

net_memory_seg 

equ 

0DC00H 

; address of ethernet memory 

net_memory_size 

equ 

2000H 

; 8k bytes 


LAN Controller Page 0 registers 


NIC_cr 

equ 

base 

♦ 

0; 

NIC_pstart 

equ 

base 

♦ 

1; 

NIC_pstop 

equ 

base 

♦ 

2; 

NIC_bndy 

equ 

base 

♦ 

3; 

NIC_tpsr 

equ 

base 

♦ 

4; 

NIC_tbcrO 

equ 

base 

+ 

5; 

NIC_tbcr1 

equ 

base 

♦ 

6; 

NIC_isr 

equ 

base 

+ 

7; 

NIC_rsarO 

equ 

base 

♦ 

8; 

NIC_rsar1 

equ 

base 

♦ 

9; 

NIC_rbcrO 

equ 

base 

♦ 

10 

NIC_rbcr1 

equ 

base 

♦ 

11 

NIC_rcr 

equ 

base 

♦ 

12 

NIC_tcr 

equ 

base 

♦ 

13 

NIC_dcr 

equ 

base 

♦ 

U 

NIC_imr 

equ 

base 

■f 

15 


-- control register of NIC 
-- page start register 
-- page stop register 
-- boundary register 
-- transmit page start register 
-- transmit byte count rgtr hi 
-• transmit byte count rgtr lo 
-- interrupt status register 
-- remote start address rgtr lo 
-- remote start address rgtr hi 
-- remote byte count rgtr lo 
-- remote byte count rgtr hi 
-- receive configuration rgtr 
-- transmit configuration rgtr 
-- data configuration register 
-- interrrupt mask register 


controller page 1 registers - NIC address setup registers 
These registers are written to establish what the actual 
physical address will be. 


phys_address_0 equ base + 1 
phys_address_1 equ base ♦ 2 
phys_address_2 equ base ♦ 3 
phys_address_3 equ base + 4 
phys_address_4 equ base + 5 
phys_address_5 equ base ♦ 6 
NIC_curr equ base + 7 


physical address registers. 
These registers are accessed 
via N!C_cr bits 7,6 = 0,1. 

LAN registers are accessed 
via cntrl bits 3,2 = 0,0. 

only written once during init 


Controller Page 2 - Ethernet PROM ADDRESS memory 

These locations contain the "preferred" address as contained 


- 204 - 



















Distributed Issues Final Report 


in PROM. These will typically be copied to the physical 
address registers above (page 1). 


prom_address_0 

equ 

base 

+ 0; 

-- station address 0 

prom_address_1 

equ 

base 

+ i; 

-- station address 1 

prom_address_2 

equ 

base 

+ 2; 

-- station address 2 

prom_address_3 

equ 

base 

♦ 3; 

-- station address 3 

prom_address_4 

equ 

base 

+ 4; 

-- station address 4 

prom_address_5 

equ 

base 

♦ 5; 

-- station address 5 

t 

; Gate Array 

f 

registers 

(note: 

offset of 400H) 

pstr 

equ 

base 

+ 400H 

-- page start register 

pspr 

equ 

base 

♦ 401H 

-- page stop register 

dqtr 

equ 

base 

+ 402H 

-- drq timer register 

bcf r 

equ 

base 

♦ 403H 

-- base configuration register 

pcfr 

equ 

base 

♦ 404H 

-- prom configuration register 

gacfr 

equ 

base 

+ 405H 

-- ga configuration register 

cntrl 

equ 

base 

♦ 406H 

-- gate array (ga) control rgtr 

streg 

equ 

base 

♦ 407H 

-• ga status register 

idcfr 

equ 

base 

♦ 408H 

-- interrupt/DMA cnfgrtn rgtr 

damsb 

equ 

base 

♦ 409H 

-- DMA address register hi 

dalsb 

equ 

base 

♦ 40AH 

-- DMA address register lo 

vptr2 

equ 

base 

+ 40BH 

-- vector pointer rgtr H2 

vptrl 

equ 

base 

+ 40CH 

-- vector pointer rgtr Hi 

vptrO 

equ 

base 

♦ 40DH 

-- vector pointer rgtr #0 

rfmsb 

equ 

base 

♦ 40EH 

-- register file access hi 

rf Isb 

equ 

base 

+ 40FH 

-- register file access lo 


* Ethernet (3com) Initialization Values * 


eth_enable_reset 

equ 

03h 

eth_disable_reset 

equ 

OOh 

eth_access _prom 

equ 

04h 

eth_recv_select 

equ 

OOh 

eth_lan_config 

equ 

49h 

eth_rew_OMA_burst 

equ 

08h 

eth_irq_line 

equ 

80h 

eth_rem_DMA_conf i g 

equ 

20h 

eth_xmit_buf_start 

equ 

20h 

eth_recv_buf_start 

equ 

26h 

eth_recv_buf_end 

equ 

40h 

eth_offset 

equ 

2000h 

eth_recv_begin 

equ 

600h 

eth_recv_end 

equ 

2000h 

eth_start_nic 

equ 

02h 

eth_nic_stop 

equ 

Olh 


enable reset 

disable reset 

access prom bytes 

select external Xceiver 

8k of mew-map I/O, w/interrupts 

# of bytes to transfer on DMA burst 

interrupts occur on IRQ5 

8k configuration for remote DMA 

begin of transmission buffer (OH) 

receive queue (0600H) 

20 pages, 256 bytes/page (2000H) 
difference between page & address 
actual offset in RAM seg for begin 
actual offset in RAM seg for end 
start NIC 
stop the NIC 


- 205 - 















Distributed Issues Final Report 


eth_nic_DMA_config 

equ 

-8h 

local DMA operations, 8 byte bursts 

eth_remote_DMA_lo 

equ 

OOh 

DMA remote unused (lo) 

eth_remote_DMA_hi 

equ 

OOh 

DMA remote unused (hi) 

eth_packet_types 

equ 

OOh 

receive only good packets 

eth_nic_mode 

equ 

02h 

internal loopback mode 

eth_bndy_start 

equ 

OOh 

FOR NOU, DO NOT USE BOUNDRY REG! 

eth_int_status 

equ 

Of fh 

clear status of all ints at start 

eth_ints_disabled 

equ 

OOh 

enable no interrupts 

eth_access_page_0 

equ 

OOh 

access page 0 again (for cmd reg) 

e t h_ac c es s_pa ge_ 1 

equ 

40H 

access NIC page 1 registers 

eth_exit_mode 

equ 

OOh 

exit internal loopback mode 

nic_prx 

equ 

1 

mask for packet receive interrupt 

nic_ptx 

equ 

2 

mask for packet transmit interrupt 

send 

equ 

4 

command byte to start transmission 


; Interrupt Controller Commands 

I 

NET_EOI equ 60H + vectornumber ; -- End Of Interrupt (specific) 

TIMER_E0I equ 60H + 0 ; timer is interrupt channel 0 

; Ethernet controller routine specifications 

; Ethnet_Init initializes a 3com Etherlink II board to transmit and receive 
; packets via a memory mapped interface with the board located at DCOOrOOOO. 
; The base address from which the registers are located is 31 Oh. The init 
; routine intializes the memory to zeroes before it completes. Although no 
; DMA is used to transfer the data from main memory to the board's memory 
; (which is referred as remote DMA operations), there is no choice but to 
; use the local DMA operations (transferring bytes or words from the board's 
; memory to the board's output fifo's). 

.LIST 


- 206 - 










Distributed Issues Final Report 


page 55,132 

TITLE RTE - Distribted Ada Runtime Module 


FILE: DA_RTE.ASM 

RTE - DISTRIBUTED Ada RUNTIME MODULE 

Copyright(C) 1989, LabTek Corporation, Uoodbridge, CT USA 


Runtime Code to implement prototype Distributed Ada Services 

This module implements the remote rendezvous operations to 
support distributed Ada. 

Currently provided are: 

Remote_Entry, Remote_Select, Remote_Accept, Remote_End_Accept, 
Remote_Elab_Start, Remote_Elab_Uait, Remote_Elab_Continue. 
Local_End_Accept 

Ver Date Description 

0.1 Nov-88 : Initial prototype 

0.2 Dec-89 : Version 2 - Flexible task distribution Added 


.model large 
public Initialize 

These are entry points called by the vendor runtime interface to 
invoke the runtime by generated code 

public Request_Entry, Activate_Complete, Accept, Rendezvous_Complete 
public Select, Create_Task 

The 10 module invokes the runtime services when messages are received 
via the NET_RECEIVE call 

public NET_Receive ; called by 10 


; Vendor Runtime Services 


extrn 

VRTlf_Init:near 




extrn 

VRTIF_Wait:far 

; Vendor 

Supplied P Semaphore operation 

extrn 

VRTIF_Signal_I:far 

; Vendor 

Supplied V 

operation/interrupt 

extrn 

VRTIF_Signal:far 

; Vendor 

Supplied V 

operation 


After or instead of using the distributed runtime, control may be 
passed bact to the vendor runtime through this interface 















Distributed Issues Finai Report 


extrn VRTIF_Create_Task:near 

extrn VRTIF_Activate_Complete:near 

extrn VRTIF_Entry:near 

extrn VRTIF_Rendezvous_Comptete:near 

extrn VRTIF_Accept:near 

extrn VRTlF_Select:near 

extrn VRTIF_Lower_Priority:near 

Vendor task control block information and runtime data segment address 


extrn 

VRTIF_tcbtid:abs 

extrn 

VRTIF_t ask_pt r:word 

extrn 

VRTIF_DS:word 

extrn 

VRTIF_SELECT_REC:abs 

extrn 

Sync:near 

extrn 

Shut_Down:near 

extrn 

TASK_DI RECTORY:word 

Network 10 Services 

extrn 

TX_READY:near 

extrn 

IO_XMIT:near 

extrn 

I0_Network_Init:near 

extrn 

IO_ALLOCATE:near 

extrn 

IO_DEALLOCATE:near 

extrn 

PID:word 

extrn 

SYNCHRO_SEMAPHORE:word 

extrn 

CONTINUE_SEMAPHORE:word 

extrn 

Outchr:near 


include DA DEF.ASM 


offset to priority within vendor TCB 
offset to current TCB with runtime DS 
offset within user DS to runtime DS 
number of bytes per "select record" 

call synchronize 

restart system on "COLD_START" 


Transmit ready semaphore 
Start transmission routine 

allocate a buffer 
deallocate a buffer 
THIS processor ID 


for debugging only 
system definitions 


cseg segment coranon 

assume cs:cseg,ds:cseg.es:cseg 
org 1400H 


; Initialize -- no parameters 
Initialize: 

call IO_Network_Init 

call VRTIFJnit 

ret 


Prior to each Create Task, synchronize all CPU's to keep elaboration 
going sequentially 


- 208 - 












Distributed Issues Final Report 


ds 

ax 

al ,'c' 

Outchr ; 33 

ax,cs 
ds,ax 

Syr>c ; do synchronization 

ax 

ds 

VRTIF_Create_Task ; return to vendor runtime 


; A task has completed activation and called "ACTIVATED". Since there 
; are no parameters, simply nest the call to the vendor runtime so it 
; will return here when done. First, provide a unique ID based on 
; priority for each task. Then we see if the task should remain 
; alive. If not, suspend it on a dummy semaphore 

f 

Activate_Complete: 

push bp 

mov bp.sp 

push ax 

push bx 

push cx 

push dx 

push si 

push di 

push ds 

push es 

mov ds,[VRT1F_DS] 

mov si,[VRTIF_TASK_PTR] 

mov cx,tsi+VRTIF_TCBTID] ; get priority (of this task type) 

I 

; During Activation all tasks have the priority of their task type, however 
; since the priority is used to identify tasks, and possibly serveral tasks 
; will be of the same task type, count the tasks of each task type and 
; assign them a unique priority, (note the initial priorities must be 
; assigned with sufficient space so that this has no effect on scheduling). 
; Decreasing Ada priorities have increasing VRT priority (by two). 

$ 

mov di,cx 

add di,di ; mult by four to make index 

add di,di 

l 

; Modifying count for base task is atomic action 

t 

pushf 

cli 


Create_Task: 

push 

push 

; mov 

; call 

mov 
mov 
call 
pop 
pop 
jmp 


- 209 - 









Distributed Issues Final Report 


idov ax,cs:TASK_DIRECTORY.DTC8_dir_Count[di]; get # of tasks for type 
add word ptr cs:TASK DIRECTORY.DTCB dir Count[di],2 ; adjust it for next 


popf 

or ax,ax 

jz ACT_COHPLETE10 

add cx,ax 

push cx 

call VRT1F_Lower_Priority 

pop di 

add di,di 

add di,di 

ACT_COMPLETE10: 

mov ax,cs 

mov ds,ax 

mov bx,TASK_DI RECTORY.DTCB 

lea bx,OEF_return_addr[bx] 

mov di, [bp*-2] 

mov [bx],di 

mov di,[bp+4] 

mov [bx+2],di 

pop es 

pop ds 

pop di 

pop si 

pop dx 

pop cx 

pop bx 

pop ax 

pop bp 

add sp,4 

push cs 

call VRTIF_Activate_complete 

sub sp,4 

push bp 

mov bp,sp 

push ax 

push bx 

push cx 

push dx 

push si 

push di 

push ds 

push es 

mov ds,tVRT!F_DS] 


; see if delta on this priority 
; if so skip changing of pririty 
; compute new priority 
; save priority 

; setpriority lower cx=priority si=V-TCB 


; set DRT data segment 

ir_TCB Cdi3 ; get DRT TCB 

; point to return addr 

; get return address offset 
; save in TCB 

; get return address segment 


; trash return address (saved in TCB) 
; simulate a FAR cal l 

; make room for return address 


; "mul" affects this 


; get Vendor runtime data segment 


- 210 - 





Distributed Issues Final Report 


mov 

Si,[VRTIF_TASK_PTR] 

; fetch Current Task TCB 

mov 

bx,[si+VRTIF_TC8TID] 

; get priority (our task type) 

mov 

ax,cs 

; load DRT data segment 

mov 

ds,ax 


acid 

bx,bx 

; mult by four to make index 

add 

bx,bx 


mov 

ax,TASK_D1RECTORY.DTCB_ 

_di r_pid(bx]; fetch PID for this task 

cmp 

ax,[PID] 

; see if this is the processor 

jz 

Keep_alive 


; If here, this task should not continue to run... suspend it. 

1 

pushf 


; this must be atomic 

cl i 



xor 

ax, ax 

; init a dummy semaphore 

mov 

[DUMMY_SEM],ax 


mov 

[DUMMY_SEM+2],ax 


mov 

[DUMMYSEM+4],ax 


push 

CS 


lea 

ax,OUMMY_SEM 


push 

ax 


call 

VRTIF_Wait 

; go to sleep forever 

popf 



int 

3 

; if here... ERROR! 

; This task 

should be allowed to live, 

, let it continue 

i 

Keep_alive: 



mov 

si,TASK_01 RECTORY.DTCB 

_dir_TCB[bx] ; fetch TCB 

lea 

si,DEF_return_addr[si] 


mov 

ax, [si] 

; fetch offset 

mov 

[bp+2],ax 

; put on stack 

mov 

ax,[si+2] 

; fetch segment 

mov 

[bp+4],ax 


pop 

es 


pop 

ds 


pop 

di 


pop 

si 


pop 

dx 


pop 

cx 


pop 

bx 


pop 

ax 


pop 

bp 



retf 


Programs wilt come here when they want to do an entry call. If 
the call is to a task with remote callers, we must go through the 
distributed runtime, otherwise go to local runtime. 


- 211 - 










Distributed Issues Final Report 


Input parameters: 

ES:DX points to Parameter List 
BX task id to call 

CX entry id to call 


Request_Entry: 

push 

mov 

mov 

mov 

mov 

mov 

pop 

add 

add 

test 

jnz 


ds ; save for vendor runtime 

ds,[VRTIF_DS] ; fetch local runtime data segment 

si,[bx+VRTIF_tcbtid] ; get distributed task id (priority) 

ax,si ; save task id 

di, [VRTIF_TASK_PTR] ; get vendor TCti of current task 

di,[di+VRTIF_tcbtid] ; fetch distrib. tid of current task 

ds ; restore ds 

si,si ; mult by four to make index 

s i, s i 

cs:TASK_DIRECTORY(si).OFFFFH ; see if local or remote 
Dist_Entry ; if entry must be done by distributed runtime 


This entry is strickly local, let vendor runtime handle it 
imp VRT!F_Entry ; go to vendor runtime 


This entry must be handled by the distributed run Me, erecx to see if 
the called task is on this processor. 


Dist_Entry: 

; push 

; mov 

; call 

; pop 

mov 
cmp 
jnz 
jmp 


ax 

al,'r' 

Outchr 

ax 

si,cs:TASX_DIRECTORY.DTC8_dir_pid[si] ; fetch PID of called task 
si,cs:[PID] ; compare against my PID 

Remote_Entry 

Local_Entry ; do local if the same 


Remote_Entry 

Send "Request_Entry" message with copied parameters and profile 
Wait on Entry_Wait_Semaphore 
Copy OUT parameters 
Release 8uffer 

IN PARAMETERS: 

AX distributed task id to call 

CX entry id to call 

DI distributed task ID of this caller task 

ES:DX points to Parameter List 


- 212 - 














Distributed Issues Final Report 


NOTE: Stack Parameters are removed by caller 


RE 

_Parm_List 

equ -4 

dword 

RE 

Profile 

equ -6 

parameter profile ptr 

RE 

Count 

equ -8 

parameter count 

RE 

_TCB 

equ -10 

dist. TCB of server 

RE 

_TID 

equ -12 

Distrib. Task 10 of caller 

RE 

_BUFF_DESC 

equ -14 

descriptor of reply buffer 

RE 

_BUFF_PTR 

equ -16 

address to packet data 

Remote_Entry: 




push 

ax 



mov 

al,'R' 



cal l 

Outchr 



pop 

ax 



push 

bp 



mov 

bp,sp 



add 

sp,RE_BUFF_PTR 

; local parameters to save 


push 

ds 

; save caller's DS 


push 

cs 



pop 

ds 

; load DRT data segment 


mov 

[bp+RETID],di 

; save task id of caller 


mov 

[bp*RE_Parm_list+2],es ; save segment of parameter list 


mov 

[bp*RE_Parm_.ist 

,dx ; save offset of parameter list 


Bui Id call 

frame to transmit ertry call to designated task 


PARM_lI ST 




push 

es 

push segment of parameter list 


push 

dx 

push offset of parameter list 


mov 

dx,DEF_in 

calling Xmit for IN mode 

1 

MOOE 




push 

dx 



mov 

bx,cx 

get entry id 


add 

bx,bx 

mult by two 


add 

bx,bx 

mult by four 


add 

bx,bx 

mult by eight (8 bytes per entry descriptor) 


mov 

s i, ax 

get destination TID in SI 


add 

s i, s i 

mult by four to make index 


add 

s i, s i 



mov 

si,Task_0irectory.DTCBdir_TCB[si] ; fetch dist. TCB 


mov 

[bp*RE_TCB],si 

save for later 


mov 

dx,DEF_Entry_Table+DEF_entry_profile_ptr[si+bx] ;profile offset 


mov 

[bp+RE_Profile],dx ; save for later 

1 

PROFILE 




push 

dx 

push as parameter 

; 

TIO of Source 



push 

di 


• 

ENTRY 




push 

cx 

push entry id 


- 213 - 











Distributed Issues Final Report 


; TID of Destination 

push ax ; push (DA) task id 

; CMD for remote entry call 

mov di,DEF_request_entry 

push di 

; PID of Destination 

mov di,ax ; get back TID of dest. 

add di,di ; mult by four to make index 

add di,di 

mov di,Task_Directory.DTCB_dir_PID[di] ; fetch PID 


push 

di 

; push PID 


call 

IOJOnit 

; parameters 

are copied by xmit 

Now wait 

for rendezvous Complete to wake 

up 


mov si,[bp+RE_TID] ; get my dist TID 

add si,si 

add si,si 

mov si,Task_Directory.DTCBdir_TCB[si] ; fetch my dist. TCB 

push cs 

push si ; base of DA TCB is semaphc e 

call VRTIF_Uait ; go to sleep waiting for end rendezvous 


Copy out parameters back. Use the TCB definitions 

to determine how many parameters, their size, and what type (ie. must 
allow for unconstrained arrays). 


First get address of buffer and stick it in local 

mov si,[bp+RE_TID] ; get my dist TID 

add si,si 

add si, si 

mov si,Task Directory.DTCB dir TCB[si] ; fetch dist. TCB 


mov si,DEF_TC8_Reply[si] 

mov [bp+RE_BUFF_OESC],si 

mov si.lsi] 

lea si,DEF_pkt_data[si] 

mov [bp+RE_BUFF_PTR],si 

mcv si,[bp+RE_Profile] 

cld 

lodsw 

R_Entry_10: 

or ax,ax 

jnz R_Entry_12 

jmp R_Entry_30 

R_Entry_12: 

mov [bp*RE_COUNT],ax 


; get reply buffer descriptor 
; save it for later deallocation 
; get actual buffer address 
; point directly to data 
; save pointer 

; get parameter profile ptr 
; make sure auto increment 
; get number of parameters 

; see if done 
; continue if not done 
; if done 

; update parameter count 


- 214 - 





Distributed Issues Final Report 


lodsw 


get parameter Mode 

mov 

cx, [si] 

fetch parameter type/length 

add 

si ,2 

skip over type/length 

mov 

[bp+RE_PROFILE] ,si 

update profile pointer for next 

Ids 

si,[bp+RE_parm_list] 

point to parameter list 

note: vendor puts segment/offset in reverse of normal order 

push 

data_seg[si] 

segment of data 

push 

data_off[si] 

offset of data 

or 

cx,cx 

see if unconstrained type 

jge 

R_Entry_15 


process an 

unconstrained object as a parameter. Note, the 

descriptor 

is always copied, so we must skip 3 words in buffer 

and over two in the parameter list 


push 

[si+4] 

descriptor segment 

push 

[si+6] 

offset of descriptor 

add 

si ,8 


mov 

word ptr [bp+RE_parm_list],si ; update parameter list index 

mov 

si,[bp+RE_BUFF_PTR] 

adjust buffer pointer over constra 

add 

si,6 

skip over constraint 

mov 

[bp+RE_BUFF_PTR] ,si 

update 

pop 

si 

get offset of descriptor 

pop 

ds 

get segment of descriptor 

push 

ax 

save MOOE of parameter 

mov 

cx, [si+DEF_Low_descJ 

get low bound of constraint 

mov 

ax, [si+DEF_high_desc] 

get high bound of constraint 

mov 

dx, [si+DEF_size_desc] 

get size of object 

Copy the parameter data iff MOOE is correct and array is not null 

mov 

bx,cs 

reload CRT data segment 

mov 

ds,bx 


pop 

bx 

get mode of parameter 

pop 

di 

get offset of data 

pop 

es 

get segment of data 

and 

bx,0EF_out 

see if we should copy data 

jz 

R_Entry_20 

if not, go on 

sub 

ax,cx 

compute difference in range 

inc 

ax 

adjust to include end points 

mu' 

dx 

compute size in words 

jle 

R_Entry_20 

if array is empty go to next parm 

mov 

cx,ax 

put in count register 

mov 

si,[bp+RE_BUFF_PTR] 


rep 

movsw 

transfer from packet buffer 

mov 

[bp4-RE_BUFF_PTR] ,si 

update pointer 

jmp 

R_Entry_20 

go on to next parameter 


Constrained parameter, CX is length in bytes, copy it into packet buffer 


- 215 - 










Distributed Issues Final Report 


R_Entry_15: 

add 

si ,4 

; move to next object address 

mov 

word ptr [bp+DEF_parm_ 

list],si ; update parameter list index 

pop 

di 

; get data offset 

pop 

es 

; get parameter data segment 

and 

ax,DEF_out 

; see if mode is right to copy out 

mov 

ax,cs 

; restore distrib. data segment 

mov 

ds,ax 


jz 

R_Entry_20 

; skip copy of data if not out mode 

mov 

Si,[bp+RE_8UFF_PTR] 

; get buffer pointer in DS:SI 

inc 

cx 

; round odd bytes up when convert 

shr 

cx,1 

; to words 

rep 

movsw 


mov 

[bp+RE_BUFF_PTR],si 

; update current packet buffer ptr 

R_Entry_20: 

mov 

si,[bp+RE_Profile] 

; get next parameter profile 

mov 

ax,[bp+RE_Count] 

; get the counter back in ax 

dec 

ax 

; count down 

jmp 

R_Entry_10 



Free buffer, restore stack, and return to entry caller 
(it restores DS and any any stack frame it may have built) 


R_Entry_30: 

mcv 

bx,[bp*RE_BUFF_DESC] 

; get reply buffer descriptor back 

cal l 

I0_Deallocate 

; return used buffer 

pop 

ds 

; restore caller's data segment 

mov 

s P,bp 

; dal locate locals 

POP 

bp 


retf 




Local_Entry : This routine is called for an entry of a task 

which is local (same processor) as the caller 


Inputs: 

AX : TID of called task 

BX : Vendor TCB of called task 

CX : Entry 10 

DX : offset to parmeter list 
ES : segment of parameter list 
si : PID of called task 
di : MY TIO 


Although the task is local to the caller, an 10 buffer is allocated 
to store the necessary pointers required by accepting tasks. This 
is later deallocated as part of the local_end_accept routine. The 
calling task is always suspended, and if the accepting task is "waiting" 
it is signaled to wake up. 


- 216 - 









Distributed Issues Final Report 


Only the TIO EID and MY_TID fields within the buffer are valid during 
local rendezvous. Also, the data fields have the address of the 
various objects/desciptors rather than the data itself. 

NOTE: There is no need to deallocate the buffer allocated here because 
it is deallocated by the server task. (There is only one 
buffer used by local tasks, rather than two as for remote tasks.) 


LE 

_ENTRY_PTR 

equ 

-2 

; word: bp offset 

to 

current 

entry table 

LE 

_TCB_PTR 

equ 

-4 

; word: bp offset 

to 

target 

TCB base 

LE 

_MY_TCB 

equ 

-6 

; word: bp offset 

to 

my TCB 

base 


Local_Entry: 



push 

ax 


mov 

al,'L' 


call 

Outchr 


pop 

ax 


push 

bp 


mov 

bp,sp 


add 

sp,LE_MY_TCB 

; allocate space for locals 

push 

ds 

; save caller's data segment 

push 

cs 

; load DRT data segment 

pop 

ds 


push 

ax 

; save TID 

cal l 

IO_Allocate 

; get a buffer descriptor ptr in BX 

pop 

ax 


mov 

si,[BX] 

; fetch buffer address 

1 

; currently only one parameter is used (either in or out). Take advantage 

; of this to 

simplify interface to accepting task. The address of the 

; data area 

is provided in the first 

part of the buffer. NOTE: this address 

; is backwards (segment 3 low address. 

offset=high address). 

push 

ax 


push 

di 


mov 

di ,dx 


mov 

ax,es:Cdi] 

; transfer parm list to buffer 

mov 

tsi],ax 

; buffer so as to point to the 

mov 

ax,es:Cdi+2] 

; data and descriptors actually 

mov 

(si+2] ,ax 

; processor 

mov 

ax,es:Cdi+4] 


mov 

Csi*4],ax 


mov 

ax,es:[di+6] 


mov 

Csi+61,ax 


pop 

di 


pop 

ax 


mov 

OEF_pkt_tid(si] ,ax 

; put in called task TID 

mov 

DEF_pkt_my_tid(si] ,di 

; and put in calling task id there 


- 217 - 







Distributed Issues Final Report 


mov 

DEF_pkt_cmdCsi],DEF_local_call ; indicate this is a local 

add 

di ,di 

; mult by four 

add 

di ,di 



mov 

di,TASK_0!RECTORY.DTCB. 

_d i r 

_TC8[di] ; get my TCB addr 

mov 

[bp+L£_MY_TC8],di 


save it 

mov 

Csi+DEF_pkt_Entry_ID],CX 

save entry id 

mov 

si ,ax 


get TID of called task into si 

add 

si ,si 


mult by four 

add 

s i, s i 



mov 

ax # TASK_DIRECTORY.DTCrf_ 

di r 

_TC8(si] ; fetch dist. TCB addr 

mov 

[bp*LE_TCB_PTR] ,ax 


save base of TCB 

mov 

si ,cx 


compute entry table address 

add 

si ,si 


* 2 

add 

s i, s i 


* 4 

add 

s i, s i 


* 8 

add 

si,ax 


add base uf (DA) TCB 

add 

si # Def_Entry_table 



mov 

lbp+LE_Entry_PTR],si 


save 

lea 

si,DEF_Entry_Queue[si] 


fetch entry queue head 


ATOMIC action follows_ Queue entry, if waiting signal acceptor 


pushf 

cli 

call INSERT 

mov si,[bp+LE_Entry_PTR] ; 

test DEF_Entry_Waitlsi].OFFFFH 

jz le020 ; 

; server is waiting on accept, signal it 

mov si,[bp*LE_TCB_PTR] 

mov cx,DEF_nijn_entries[si] ; 

lea si,DEF_entry_tablelsi] ; 

leO10: 

mov DEF_Entry_Uait[si] ,0 

add si ,si ze OEF_Entry_Rec ; 

loop leOlO 

push cs ; 

mov ax,[bp+LE_TCB_PTR] ; 

push ax 

call VRTIF_Signal ; 


place buffer descriptor on entry c 
fetch entry table address again 
; see if WAITING 
go on if not 


get task Control Block 
get number of entries 
point to base of table 

clear (all) waiting flags 
go to next entry record 

segment of semaphore 
offset of semaphore 

wake up server (may preempt ourselves) 


; NOTE: This is the end of the atomic region (above Vendor runtime call 
; reenables interrupts! 

Ie020: 

popf ; restore interrupt level 

push cs ; now try to suspend ourselves 


- 218 - 









Distributed Issues Final Report 


mov ax,[bp+LE_MY_TCB] ; semaphore is first thing in TCB 

push ax 

call VRTIF_Uait ; may not suspend if server is higher 

; priority and has already signaled us 


pop ds 

mov sp,bp 

pop bp 

retf 


; restore DS 
; remove locals 


; Accept - is invoked by the generated code to wait for arrival of 
; a caller. 

; INPUTS: 

; AX is entry to accept 

; OUTPUTS: 

; ES:8X is parameter list pointer 

Accept: 


push 

ds 


mov 

ds,[VRTIF_DS] 

; get runtime data segment 

mov 

si, [VRTIF_TASKJ>TR] 


mov 

si ,VRTIF_tcbtidCsi] 

; fetch my TIO 

pop 

ds 


add 

si ,si 

; mult by four to make index 

add 

si ,si 



test cs:TASK_DI RECTORY,DTCB_dir_LOCAL[siJ,OFFFFH ; distributed? 

jnz Dist_Accept ; must to a distributed accept 

jmp VRTIF_Accept ; otherwise, return to vendor runtime 


; Distributed Accept (TASK_ID, ENTRY_ID) return ES:BX_Param_Pointer 

; NOTE: THIS HANDIES BOTH ACCEPTANCE FOR LOCAL AND REMOTE CALLS 
; THROUGH THE DISTRIBUTED RUNTIME. 

; Simple Accept, see if someone on entry queue, if so 
; return with pointer to buffer in ES:BX, otherwise set 
; "Waiting" Flag and go to sleep on semaphore. 

; Inputs: TASK_ID, ENTRY_ID 

; Outputs: Returns ES:8X pointing to Parameter Data List 
; Also, Buffer descriptor is placed in "Reply" pointer. 

RA_TCB equ -2 ; word: my TCB 

RA_ENTRY equ -A ; word: this entry 


- 219 - 













Distributed Issues Final Report 


Dist_Accept: 

; push 

; mov 

; call 

; pop 

push 

mov 

sub 

push 

push 

pop 

mov 

mov 

mov 

add 

add 

add 

lea 

mov 

pushf 

cl i 

test 

jnz 


ax 

al,'a' 

Outchr ; S3 

ax 

bp 

bp.sp 

sp,4 

ds ; save old data segment 

cs ; load data segment 

ds 

si,TASK_DI RECTORY,DTCB_dir_TCB[si] ; fetch TCB ptr 

[bp*RA_TCB],si ; save it 

bx,ax ; compute entry index 

bx,bx ; * 2 

bx,bx ; * 4 

bx,bx ; * 8 (eight bytes per entry) 

bx,DEF_entry_tabletsi+bx] ; point to my entry of interest 

[bp+RA_ENTRY] ,bx ; save it too 

; save interrupt status 
; go atomic 

DEF_entry_Queue+2[bx].OFFFFH ; if Zero, then queue is empty 
RA010 ; if caller is there, take it! 


No caller on entry queue. Set waiting flag and go to sleep 


mov [bx+OEF_entry_wait],1 ; set flag 

push cs ; push segment of my task semaphore 

push si ; address of my tcb 

call VRTIF_WAIT ; go to sleep waiting for caller 


NOTE after vendor runtime call - interrupts are enabled! 

Now Something is on the queue, provide address of parameter list in 
ES:BX and return to caller. 


RA010: 

popf ; restore interrupt status 

mov si,Cbp+RA_TCB] ; get TCB pointer back 

mov bx,[bp+RA_ENTRY] ; get the entry address back 

; note: the wait flag is cleared by the caller 


mov bx,0EF_entry_queue+2[bx] ; get buffer descriptor from queue 
mov DEF_tcb_reply[si],bx ; save descriptor for end rendezvous 

mov bx,tbx] ; fetch buffer address into BX (return) 

mov ax,cs ; get segment into ES, making ES:BX pair 

mov es,ax ; parameter list is in buffer 

; It has been put there by either the 
; local or remote entry call mechanisms 
pop ds ; restore data segment 

mov sp,bp ; remove locals 


pop bp 


- 220 - 











Distributed Issues Final Report 


retf 


; Select - 




INPUTS: 





STACK frame has open alternatives. As best as we can 
tell, it looks like this: 



[ flags ] 

[ entry # ] 

[ unknown ] 




Each alternative appears to have three words with the 



"flags" word being not 

the end of the list. 

-zero. If it is zero, this indicates 


OUTPUTS 





All input parameters are removed from the stack and replaced 



the parameter list poi 

nter and a selector which indicates 



which alternative was 

selected. 

SELECT 

_L I ST 

equ 6 

; offset from bp to open alternatives 

FLAGS 


equ 0 

; offset to flags withing list record 

ENTRY_ 

ID 

equ 2 

; offset to ID# within list record 

Select 

push 

ds 



mov 

ds,[VRTIF_DS] 

; get runtime data segment 


mov 

si, [VRTIF_TASK_PTRJ 



mov 

si,VRTIF_tcbtidCsi] 

; fetch my TID 


pop 

ds 



add 

s i, s i 

; mult by four to make index 


add 

s i, s i 



test 

cs:TASK_DI RECTORY.DTCB 

_dir_local[si].OFFFFH ; distributed? 


jnz 

Dist_Select 

; must to a distributed select 


jmp 

VRTIF_Select 

; otherwise, return to vendor runtime 


Dist Select 


Check to see if any of the entries have callers. If not, 
set the "Waiting" Flag in each of them, and go to sleep. 

If one entry has a queued request, accept it and return 
offset for "Case" table and parameter list pointer on the stack 
The offset for the case table is the entry id + 1. 

INPUTS: Index into TASK DIRECTORY is in SI 


DS_TCB 

equ 

-2 

; word: my TCB 

0S_ENTRY 

equ 

-4 

; word: this entry 

DS_ALTER 

equ 

-6 


Dist Select: 





- 221 - 












Distributed Issues Final Report 


mov 

call 

push 

mov 

add 

push 

mov 

mov 

mov 

mov 


al,'s' 

Outchr ; 33 


bp 

bp,sp 

sp,DS_ALTER ; allocate local storage 

ds ; save DS 

ax,cs 

ds,ax ; set to Distr. runtime data segment 

si,TASK_DI RECTORY,DTCB_dir_TCB[si] ; fetch TCB ptr 

[bp+DS_TCB],si ; save it 


ENTER CRITICAL REGION (cannot allow task to go on an entry queue 
after we have checked it, but before setting waiting flag. 

pushf 
cl i 


First check each entry to see if any has 
Go through all open alternatives 


Rem_SelOO: 

lea ax, [bp*'' . ‘ _LIST] 

mov [bp*-ns # „R],ax 

Rem_Sel10: 

mov 
test 

jz 

inov 
mov 
add 
add 
add 
lea 
test 
jnz 
add 
imp 


a caller... 

will come back here after resune 
get address of entry list 
save in local variable 

get pointer 

test if end of the list 
did not find it 
get entry ID 
compute entry index 
* 2 
* A 


bx,[bp+DS_ALTER] 

SS:FLAGSIbx].OffffH 
Rem_Sel15 
ax,SS:ENTRY_ID[bx] 
bx,ax 
bx,bx 
bx,bx 

bx,bx ; * 8 (eight bytes per entry) 

bx,DEF_entry_table(si+bx] ; point to entry of interest 
DEF_entry_queue+2tbx],OFFFFH ; if Zero, then queue is empty 
Rem_Sel50 ; if caller is there, take it! 

word ptr [bp+DS_ALTER],VRTIF_SELECT_REC ; bytes per record 
Rem_Sel10 ; loop till end of list 


all of the Entry Queues are Empty, mark each Waiting flag 
and go to sleep. 


Rem_Sel15: 

lea ax,(bp+SELECT_LIST) 

mov (bp+DS_ALTER),ax 

Rem_Sel20: 

mov bx,[bp+DS_ALTER] 

test SS:FLAGStbx].OffffH 

jz Rem_Sel30 

mov ax,SS:ENTRY_ID tbx) 

mov bx,ax 

add bx, bx 


; get address of entry list 
; save in local variable 

; get pointer 
; test if end of the list 
; done 

; get entry ID 
; compute entry index 
; * 2 


- 222 - 










Distributed Issues Final Report 



add 

bx,bx 

; * 4 


add 

bx,bx 

; * 8 (eight bytes per entry) 


lea 

bx,DEF_entry_table[si+bx] 

; point to entry of interest 


mov 

DEF_entry_wait(bx], 1 

; set waiting 


add 

word ptr tbp+DS_ALTER],VRTlF_SELECT_REC 


jmp 

Rem_Sel20 

; loop till end of list 


The following runtime call will suspend this task, when it 
resumes, the interrupt flag will be set again, and presumably. 


one of the 

entries will have a caller queued. 

Rem_ 

Sel30: 




push 

cs ; 

push segment of wait_semaphore 


push 

[bp*DS_TCB] 

push offset of wait_semaphore taskid 


call 

VRTIF_Uait 

do wait on semaphore 


Now clear 

all the waiting flags 



cl i 




lea 

ax,[bp+S£LECT_LIST] 

; get address of entry list 


mov 

[bp+DS_ALTER],ax 

; save in local variable 

Rem 

Sel40: 




mov 

bx,[bp+DS_ALTER] 

, get pointer 


test 

SS:FLAGS[bx],OffffH 

; test if end of the list 


iz 

Rem_Sel45 

; done 


mov 

ax,SS:ENTRY_ID[bx] 

; get entry ID 


mov 

bx,ax 

; compute entry index 


add 

bx,bx 

; * 2 


add 

bx,bx 

; * 4 


add 

bx,bx 

; * 8 (eight bytes per entry) 


lea 

bx,DEF_entry_table[si+bx] 

; point to entry of interest 


mov 

DEF_entry_waitCbx],0 

; clear waiting 


add 

word ptr [bp»DS_ALTER],VRTIF_SELECT_REC 


jmp 

Rem_Sel40 

; loop till end of list 

Rem_Sel45: 




jmp 

Rem_Sel00 ; 

go back and find caller 


There is 

caller on this entry queue, do start accept 


fetch the 

Caller's buffer, which has 

a (backward) pointer to 


the parameter data 


Rem 

_Sel50: 




popf 

t 

no longer critical 


mov 

si ,DEF_entry_queue+2[bx] 

; fetch buffer descriptor 


mov 

di,tbp»DS_TCBJ 

get base of my TCB back 


mov 

DEF_tcb_reply[di],si ; 

put buff descriptor into reply ptr 


mov 

si, [si] 

get actual buffer (which is parm list) 


inc 

ax ; 

make entry id U compatible with VRTIF 


- 223 - 









Distributed Issues Final Report 


Now pull parameters off of stack, and replace with parm_list ptr and 
case selector 


pop 

ds 

get OS back 

mov 

s P,bp 

start with all locals 

pop 

bp 

get back saved bp 

pop 

bx 

get return offset 

pop 

cx 

get return segment 

1 

; Go thru open alternative list, remov 

ng three words per entry 

Rem_Sel60: 



pop 

dx 

get ENTRY flag ?? 

or 

dx,dx 

zero? 

jz 

Rem_Sel70 

if zero, this is end of list 

pop 

dx 

remove this alternative 

pop 

dx 


jmp 

Rem_Sel60 


Rem_Sel70: 



push 

cs 

segment of parm list ptr 

push 

si 

offset of parm list (buffer) 

push 

ax 

selector for case 

push 

cx 

put return segment back on 

push 

bx 

and return offset 

retf 


and leave 

lilllltltltt 


tllltitlllllllttltttltltiittt 


; This is called by the generated code to indicate end of an accept body. 

; Uhen the rendezvous complete call is made, determine if the caller was 
; on my processor. If not, use the Remote end accept, otherwise use the 
; local end accept 
; Inputs: 

; No user inputs, only the REPLY pointer 

; provides information regarding the responding task. 

/ 

Rendezvous_Complete: 
push ds 

mov ds,[VRTIF_DS] ; get runtime data segment 

mov si,[VRTIF_TASK_PTR] 

mov si,VRTIF_tcbtid[si) ; fetch my TID 

pop ds 

add si,si ; mult b> four to make index 

add si,si 

test cs:TASK_DI RECTORY.DTCBdir_LOCAL CsiJ.OFFFFH ; distributed? 

jnz Dist_End_Accept ; must to a distributed accept 

jmp VRTIF_Rendezvous_Complete ; otherwise, return to vendor runtime 


- 224 - 













Distributed Issues Final Report 


Distributed_End_Accept - 

Reply ptr has got the buffer descriptor, use it to determine 
if call was local or remote 


DEA_ENTRY equ -2 ; local word for entry pointer 

Dist_End_Accept: 

; mov al,'e' 

; call Outchr ; 33 

push bp 

mov bp,sp 

sub sp,2 ; local data 

push ds ; save previous DS 

push cs ; load data segment 

pop ds 

mov si,TASK_DI RECTORY.OTCB_dir_TCB[si] ; fetch TCB of my task 

mov di,OEF_tcb_reply[si] ; fetch buffer descriptor 

mov di,[di] 


mov ax,DEE _pkt_entry_id[di] 

mov bx,ax 

add bx,bx 

add bx, bx 

add bx,bx 

lea bx,DEF_entry_table[si +bx] 

mov [bp+DEA_ENTRYJ,bx 

lea bx,DEF_entry_queue[bx] 

call REMOVE 


; fetch Entry id 

; mult by 2 
; * 4 

; * a 

; point to entry 
; save entry record ptr 
; point to entry queue 
ll entry off queue BX now 3 buffer 


cmp DEF_pkt_cmd[di],DEF_local_call ; see if this is local 

jz local_End_Accept 


; Send output parameters to caller. 

; Release buffer used to hold input (and output for now) parameters. 
; INPUT: SI is my TCB address 

; 01 points to buffer used for this rendezvous 

; BX points to buffer descriptor 

; NOTE: Stack frame is already build for local parameters 

Remote_End_Accept: 

; mov al,'R' 

; call Outchr 

push bx ; save buffer descriptor 

; Build stack for XMIT 
; PARM LIST PTR 


- 225 - 












Distributed Issues Final Report 


push 

cs 

segment of buffer 

push 

di 

first part of buffer is parm list 

MODE 



mov 

ax,DEF_out 

out mode 

push 

ax 


PROFILE 



mov 

bx,[bp+DEA_ENTRY] 

get base of this entry 

mov 

bx,D£F_entry_profile_ptrtbx] ; fetch profile 

push 

bx 


MYJTID 



mov 

ax,[di+DEF_pkt_TID] ; 

This task was the orignial TID 

push 

ax 


ENTRY 



mov 

ax,(di+DEF_pkt_entry_ID) 


push 

ax 


TID 



mov 

di,[di+DEF_pkt_MY_TID] ; 

get caller's task ID 

push 

di 


CHD 



mov 

ax,DE F_rendezvous_end 


push 

ax 


PID 



add 

di,di ; 

mult TID by four to make index 

add 

di ,di 


mov 

ax,TASK_DIRECTORY,DTCB_dirpid[di] ; fetch PID 

push 

ax 


call 

IO_Xmit ; 

transmit reply 

Now we are 

done with the received buffer, release it 

pop 

bx 

get descriptor ptr back 

call 

I0_Deallocate ; 

release buffer, descriptor in BX 

pop 

ds ; 

restore DS 

mov 

sp,bp 


pop 

bp 


retf 



local_End_Accept 

Allow caller to continue (Note: this 

is for entry calls with parameters 

that are 

all passed by reference. No 

copy-back is required). 

All entries whether remote or local 

use a buffer, therefore deallocate 

it when 

complete. 


INPUT 

: SI is this task's TCB address 


01 points to buffer used for this rendezvous 
BX points to buffer descriptor 

NOTE: Stack frame is already build for local parameters 


- 226 - 











Distributed Issues Final Report 


local_End_Accept: 

I 

; Now wake up caller 


; mov 

at, 'L' 



; call 

Outchr 



mov 

si,DEF_pkt_my_tid[di] 

; get TID of caller 

call 

IO_Deallocate 

; done with buffer deallocate a BX 

add 

s i, s i 

; mult by four to make index 

add 

s i, s i 



mov 

si,TASK_DIRECTORY.DTCB 

_dir_TCB[si] 

get TCB of caller 

push 

cs 

; push segment of semaphore 

push 

si 

; push calling Task's TCB (SEMAPHORE) 

cal l 

VRTIF_Signal 

; signal task to 

continue 

pop 

ds 

; restore DS 


mov 

sp,bp 



pop 

bp 



retf 




; Net_Receive 

processes an incoming 

message 


; This routine 

is called by the interrupt handler (in 


; the 10 Module) to initiate action based on the 


; receipt of a 

packet. When the service handler is 


; called, BX contains the address of 

the buffer 


; descriptor. 








Net_Receive: 




mov 

si, [bx] 

; get address of 

actual buffer 

mov 

di, [si+DEF_pkt_cmd] 

; fetch command 


or 

di ,di 

; do range check 


is 

Net_Rer eiveError 



cmp 

di,command_limit 



jg 

Net_ReceiveError 



shl 

di ,1 

; m 2 ke command into word index 

jmp 

vector[di] 



Net_Receive_Error: 



mov 

al, '$' 



cal l 

Outchr 



cal l 

!0_deallocate 

; trash message 


ret 





The following vector table implements the 'case' statement 
on the message ACTION Field 


vector label 
dw 
dw 


word 

offset Sync_Start 
offset Sync_Ready 


- 227 - 








Distributed Issues Final Report 


du 

offset 

Sync_Continue 

du 

offset 

Entry_Call 

dw 

offset 

Rendezvous_End 

du 

offset 

Shut_Down ; COLD START 

vector_end 

label 

word 

comnand_L imi t 

equ 

(vector_end - vector) / 2 • 1 


Future versions of the vector table wilt include 
B eg i n_R emo ve_E n t ry 
End_Remove_Entry 
BeginAbort 
End_Abort 
Begin_Terminate 
End_Terminate 
Shared_Variable_Request 
etc. 


; This code section is executed upon receipt of a message initiating 
a 8egin_Elaborate request. 8X points to buffer descriptor. 

; NOTE: THIS IS ONLY RECIEVED BY SLAVES! 

Sync_Start: 


cal ( 

I0_0eallocate 

; no need for buffer 

push 

cs 

; wait up slave 

lea 

ax,SYNCHRO SEMAPHORE 


push 

ax 


call 

VRTIF_Signal_I 

; signal task to continue 

ret 




; This code section is executed upon receipt of a message initiating 
; an End_Elaborate. This message implies that the specified elaboration has 
; been completed on the remote processor and elaboration can continue 
; on the primary processor. 

; INPUTS: BX points to buffer descriptor. 

; NOTE: THIS IS ONLY RECEIVED BY THE MASTER 
Sync_Ready: 


cal l 

IO_Deallocate 

; no need for buffer 

push 

cs 

; wait up slave 

lea 

ax,SYNCHRO_SEMAPHORE 


push 

ax 


call 

VRTIF_Signal_I 

; signal task to continue 

ret 




- 228 - 




















Distributed Issues Final Report 


; Sync_Continue: Executed when a "sync_continue" message arrives.. 

; NOTE: ONLY RECEIVED BY SLAVES, half way through syncrhonization 

Sync_Continue: 


cal l 

I0_Deallocate 

; no need for buffer 

push 

cs 

; wait up slave 

lea 

ax,CONTINUE_SEMAPHORE 


push 

ax 


call 

ret 

VRTIF_Signal_I 

; signal task to continue 


This code section is executed upon receipt of a message initiating 
an entry call 

Place buffer on Entry queue. If "Waiting" for that entry is TRUE, 
then clear all Waiting Flags and signal Wait Semaphore. 

INPUTS: 

BX = Buffer descriptor pointer 
SI = Buffer pointer 


This code assumes only a single parameter (simplification for prototype) 
NOTE: pointers to data and descriptors are stored backward 
from normal Intel OFFSET,SEGMENT format 


type_len 

equ 

A 

offset to type/len field in profile 

data_seg 

equ 

0 

position wi*hin buffer for ptr to data 

data_off 

equ 

2 


desc_seg 

equ 

A 

position within buffer for ptr to desc 

desc_off 

equ 

6 


true_data 

equ 

6 

offset for data (after descriptor) 

Entry_Call: 




mov 

dx,bx 


save buffer descriptor 

mov 

bx,[si+DEF_pkt_tid] 

get task id 

add 

bx,bx 


mult by four to make index 

add 

bx,bx 



mov 

bx.TASK 

DIRECTORY.DTCB_dir_TCB(bx) ; get task control block 

mov 

ax,(si+OEF_pkt_Entry_IDI 

fetch entry id 

mov 

di ,ax 


compute entry offset 

add 

di ,di 


mult times 2 

add 

di ,di 


times A 

add 

di ,di 


times 8 

lea 

di,DEF_ 

entry_table[di+bx 

; point to current entry 

push 

di 




currently only one parameter is used (either in or out). Take advantage 


- 229 - 









Distributed Issues Final Report 


of this to sinplify interface to accepting task. The address of the 
data area is provided in the first part of the buffer. NOTE: this address 
is backwards (segment=low address, offset=high address). 


mov 

di,DEF_entry_Profile_ 

PtrCdi] ; point to parameter profile 

test 

[di+type_len].OFFFFH 

; see if constrained 

pop 

di 

; restore entry pointer 

jns 

Entry_010 

; go on if constrained 


Parameter is unconstrained, first pointer is to data, second to descriptor 
The data will actually be offset by six (6) bytes to leave room for a 
descriptor in front of the packet data. 


mov 

data_seg[si],cs ; 

stuff cs of buffer 

lea 

ax.DEF_pkt_data+true_data[si] ; address of true data 

mov 

data_off[si],ax ; 

put in packet 

mov 

desc_seg[si],cs 

; segment of descriptor 

lea 

ax,DEF_pkt_data[si] ; 

offset of descriptor 

mov 

desc_off[si],ax 


jmp 

Entry_020 


; Handle simple case of constrained array 

• 

Entry_010: 

mov 

data_seg[si],cs 

stuff cs of buffer 

lea 

ax,OEF_pkt_data[si] 

address of data 

mov 

data_off[si] ,ax 


$ 

; ATOMIC action follows... Queue entry, 

if waiting signal acceptor 

1 

Entry_020: 

xchg 

bx,dx ; 

bx := buffer; dx := TCB_base 

lea 

si,DEF_entry_queue[di] ; 

si points to entry queue 

pushf 
cl i 

call 

INSERT 

place buffer descriptor on entry Q 

mov 

cx,DEF_entry_wait[di] 

get entry WAITING flag 

or 

cx,cx ; 

test waiting flag 

jz 

Entry_040 ; 

go on if not 

i 

; server is 

waiting on accept, clear all 

waiting flags and signal it 

t 

mov 

si,dx ; 

get TCB 

mov 

cx,OEF_num_entries[si] 


Entry_030: 

mov 

DEF_entry_t able+OE F_ent ry 

_wait[si),0 ; clear wait flag 

add 

si.size 0EF_entry_rec ; 

go to next entry 

loop 

Entry_030 


push 

cs ; 

segment of semaphore 

push 

dx ■' 

offset of semaphore (first in TCB) 


- 230 - 










Distributed Issues Final Report 


call VRTlF_Signal_I 

$ 

Entry_040: 

popf 

ret 


; wake up server 

; restore interrupt level 
; return to interrupt handler 


Rendezvous_End - 

This code section is executed upon receipt of a message completing 
an accept body (end rendezvous) 

Post buffer containing Out Parameters and signal task to wake up 
INPUTS: 

BX = Buffer descriptor pointer 
SI = Buffer Pointer 


Rendezvous_End: 

mov 
add 
add 
mov 
mov 
push 
push 
call 
ret 


si,[si+DEF_pkt_tid] ; fetch task id of caller 
si,si ; mult by four to make index 

si ,si 

si,TASK_DI RECTORY.DTC8_dir_TCB[si] ; fetch task control block 
Csi+OEF_TCB_REPLY],bx ; provide caller with reply buffer 
cs ; push segment of caller semaphore 

si ; push offset of same (TCB) 

VRTIF_Signal_I ; wake up caller 

; to finish interrupt 


REMOVE - Remove Entry that is on entry queue 
Inputs: BX points to entry Q 

Output: BX points to buffer descriptor that was dequeued 
All other registers are preserved 


REMOVE: 

push ax 

push si 

# 

; do list operation as atomic action 

i 

pushf 
cl i 

mov si,tBX+DEF_NEXT_PTR] ; fetch buffer descriptor 

mov ax,[si+OEF_NEXT_PTR] ; get next buffer 


- 231 - 














Distributed Issues Final Report 


mov 

[BX+DEF__NEXT_PTR] ,ax 

; update queue head 

popf 



mov 

bx, s i 

; return pointer in BX 

pop 

si 


pop 

ax 


ret 




INSERT - INSERT Entry onto the end of an entry queue 

Inputs: SI points to entry Q 

BX points to buffer descriptor 

Outputs: SI points to last entry on 0 

All other registers are preserved 


INSERT: 

push ax 


do list operation as atomic action 


t 

pushf 





cl i 





INSERT 10: 





mov 

ax,[si*DEF_next_ptr] ; 

get 

next buffer on entry queue 

or 

ax,ax ; 

see 

if 

end of list 

jz 

INSERT20 

end 

of 

list, go insert it 

this is not 

end of list, keep searching 



mov 

si ,ax 




jmp 

INSERT10 




found spot 

on list, insert it 




INSERT20: 





mov 

[si+DEF_next_ptr],bx ; 

put 

on 

end of list 


popf ; restore interrupt flag 

pop ax 

ret 

align 4 

DUMMY_SEM dw 3 dup (?) ; dummy semaphore for making zombie tasks 

cseg ends 
end 


- 232 - 


















Distributed Issues Final Report 


THIS PAGE INTENTIONALLY LEFT BLANK. 


- 233 - 


Distributed Issues Final Report 


page 55,132 

TITLE 10 - Distributed Ada Network 10 


FILE: DAJO.ASM 

10 MODULE - Low Level Network Functions 

Copyright(C) 1989, LabTek Corporation, Woodbridge, CT USA 


The 10 module provides the low_level interface to the network 
hardware and receive message buffering. 

This code is loaded into all processors, and adapts to the 
the network hardware in its host. Which routines are used is 
determined solely by the calls made from the application code 
and the messages received. 

The 10 interface is implemented as four separate functions: 
Initialize 
T ransmit 
Receive 

Interrupt Procesing 

The initialize function obviously must be called prior to any 
other, and establishes the interrupt vector and enables, as 
well as prepares the hardware for use. It is also responsible 
for initilizing data structures used to buffer incoming packets. 

The Transmit function is used by one task at a time, and is 
guarded by a semaphore to provide mutual exclusion. Once the 
transmit resource is granted, the data is copied into the on-card 
buffer and sent out via hardware commands. (Normally, hardware 
packet acknowledge should be provided, however Ethernet does not 
support this, so we have implemented an acknowledge with time-out 
protocol that provides network error detection. Note that 
acknowledement packets take priority over regular traffic. 
Currently, no re-try is supported, however it would be a rather 
simple matter of keeping a transmit buffer queue and retransmit 
on errors. The more serious problem is how to insure real-time 
performance in the presence of multiple retries. Obviously the 
retry count would have to be programmable (and possibly time 
sensitive. If an acknowledgment times-out, a reconfiguration 
operation is executed to recover the system in a reduced state. 

The Receive function is provided to assist in transferring the 
data to the requested destination. It clears the outstanding 
acknowledgement request. 

The Interrupt Processing handles both transmit complete and 
reception interrupts. For transmit complete, the resource is 
simply made available again by performing a V operation on the 


- 234 - 











Distributed Issues Final Report 


trasmit semaphore. For Receive interrupts, a buffer is allocated 
from a linked list of fixed sized buffers. Then the incoming 
data is copied to the buffer and the distributed runtime is 
invoked to process the request. It may simply post the fact the 
message has arrived (and queue to an entry), or it may cause a 
task to resume which involves signalling (V - operation) the 
suspended task. 

Refer to individual procedure headers for parameter information 
and calling requirements. 


Ver Date Description 

0.1 Nov-88 : Initial prototype 

0.2 Dec-89 : Added Packet Acknowledge/Error Detection, and 

allowed for system restart (compiler initialized 
data is restricted to a UARM_START flag.) 

0.3 Feb-90 : Greatly improved multi-packet processing and 
interrupt handling. 




t I I 0 t / / « 




.model 

large 


include 

DA_DEF.ASM 

contains software definitions 

include 

DA_HU.ASM 

contains hardware specifics 

public 

IO_Network_Init, IOXmit 


public 

TX_READY 

semaphore 

public 

IO_ALLOCATE, IODEALLOCATE 

public 

Ack_Check 


public 

outchr 

for debug 

public 

RECEIVE_FLAG 

for syncphase 10 

extrn 

VRTIF_Signal_I:far 

signal semaphore 

extrn 

VRTIF_Uait:f?r 

wait on semaphore "P" 

extrn 

VRTIF_I8259:abs 

address of 8259 

extrn 

VRTIF_vector_base:abs 

base of vector table 

extrn 

VRTlF_timestamp:far 

time stamping routine 

extrn 

Setuprnear 

Initialize Network I/F 

extrn 

NET_Receive:near 

part of runtime code 

extrn 

Shut_Down:near 

if network ack failure 

extrn 

COLD_START:word 

NZ if this is first pass thru 

extrn 

SYNC_PHASE:word 

determines operational phase 

extrn 

NET_TABLE:byte 

provides network addresses 

extrn 

PID:word 

THIS processor's ID # 

extrn 

TASK_DI RECTORY:word 

(DTCB) table of tasks 

extrn 

WATCH_DOG:word 

(DTCB) table of watch dog timers 

extrn 

UATCH_LIST:word 

(DTCB) list of processors to watch 


- 235 - 










Distributed Issues Final Report 


software support buffers 


buff_size 

equ 

2048 

; bytes in local buffer 

nun_buff 

equ 

20 

; number of buffers 

min_packet 

equ 

64 

; minimun number of bytes in a packet 


cseg segment common 

org 2800H ; makes listings eaiser to use! 

assume cs:cseg,ds:cseg,es:cseg ; ,ss:sseg 


; N£TU0RK_IN1T : load Interrupt Vector and clear pointers ; 


IO_Network_Init: 

push ax 

push bx 

push cx 

push dx 

push ds 

; Do low level Network Interface Card Initialization 
call Setup 

; init network variables 

mov [SEQUENCE],0 ; zero out sequnce counter 

mov ax,cs 

mov ds,ax 

mov [RECEIVE_PTR],eth_recv_begin ; receive pointer 

mov [TX_READY],1 ; init semaphore 

mov [TX_READY+2],0 

mov [TX_READY+4],0 

mov [RECEIVE_FLAG],0 ; init flag 

; Initialize Receive buffer list 

lea ax,RX_BUFF_Q 

mov [RX_BUFF_HEAD],ax 

lea ax,RX_SUFFER ; points to actual buffers 

mov cx,num_buff ; nutber to link 

lea bx,RX_BUFF_Q ; points to buffer descriptors 

Init30: 

mov tbx],ax ; put in current buffer pointer 

lea dx,[bx+4] ; OX is address of next descriptor 

mov [bx+2],dx ; put it in as next pointer 


- 236 - 












Distributed Issues Final Report 


add 

ax,buff_size 

; point AX at next buffer 

mov 

bx,dx 

: change descriptor pointer to next 

loop 

Init30 



now fix up last pointer 

mov word ptr [bx-2],0 ; terminate list 


Initialize Outstanding Acknowledgements lists 


xor 

ax, ax 

; indicate none outstanding 

mov 

t«CIC_PENDING] , ax 


mov 

[ACK_HOLD1NG],ax 

; or waiting to be xmitted 

lea 

si,ACK_RECORDS 

; all acks are free 

mov 

[ACK_FREE],si 


mov 

cx,nun_buf f -1 ; 

number to link (same as number of buffers) 

lea 

dx,[si+ack_size]; 

DX is address of next descriptor 

mov 

[si],dx ; 

put it in as next pointer 

mov 

si,dx 

change descriptor pointer to next 

loop 

Init40 


up last 

pointer 


mov 

word ptr [si],0 

; terminate list 


load interrupt vector if this is a cold start 


test 

word ptr [COLOSTART],0FFFFH 

jz 

Uarm_Start 


mov 

ax,0 


mov 

ds,ax 


mov 

bx,VR TIF_vec t o r_ba se+(vec t o r_numbe r *4) 

mov 

ax,offset Interrupt_Handler 

mov 

[ox],ax 


mov 

ax,cs 


mov 

[bx+2],ax 


i 

; Note: Preliminary board initialization 

was done in SETUP code, now 

; just 

enable interrupts 


Warm_Start: 



mov 

dx,VRTIF_I8259+1 


in 

al,dx ; 

get interrupt mask 

mov 

ah.OFEH 

mask to clear zero bit 

mov 

cl,vector_number ; 

load shift count register 

rol 

ah, cl 


and 

al,ah ; 

enable level 

out 

dx,al ; 

update controller chip 


- 237 - 








Distributed Issues Final Report 


mov 

dx,nic_cr 

; command register 

mov 

al,eth_access_page_0 

; access NIC page 0 registers 

out 

dx,al 


mov 

dx,nic_imr 

; interrupt mask register 

mov 

al,nic_prx+nic_ptx 

; enable xmit/recv interrupts 

out 

dx,ai 


pop 

ds 


pop 

dx 


pop 

cx 


pop 

bx 


pop 

ax 


ret 




; routine for debugging only - all registers preserved 
; Prints character in AL 

outchr: 

push dx 

push ax 

mov dx,3fdh 

outIO: 

in al,dx 

and al,20h 

jz outIO 

pop ax 

mov dx,3f8h 

out dx,al 

pop dx 

ret 


header_size equ 10 ;words:dst=3,src=3,RCP=1.priority=1,seq=1,length=1 

rcp_offset equ 12 ; bytes to receive control pointer 


XMIT - transmit the message specified by parameter list 
starting at address is at SS:bp+DEF_PARM_LIST 
NO GENERAL REGISTERS ARE PRESEVED 
NOTE: During system synchonization this routine works 

differently so as to avoid use to the vendor runtime and 
provide more control to the appplication (no ack timeout) 
This is designated by the boolean "SYNC_PHASE” 


INPUTS: 

PID ; destination processor ID 

CMD ; command for this packet 

TID ; Task for which the command operates 


- 238 - 














Distributed Issues Final Report 



ENTRY 

entry ID for the command (if applicable) 


MY_TID 

originating Task ID 


PROFILE 

profile pointer (in CS) for entry parameters 


MODE 

current calling mode (in or out) 


PARM_LIST 

pointer (seg/offset) for parameter list 

Xmi t: 



push 

bp 


mov 

bp,sp 

mark stack 

test 

[SYNC_PHASE],0FFFFH ; see if in sync phase, if so, don't use rts 

jnz 

Xmit_05 


Normally, 

we use vendor runtime to lock xmitter 

push 

cs 

; push segment of transmit Ctrl semaphore 

lea 

ax,TX_READY 


push 

3X 

; push offset of semaphore 

call 

VRTIF_Uait 

; do p semaphore operation 


; Now get acknowledge request buffer 

I 

call Ack_Allocate ; returns ack buffer ptr in BX ;AAA 

jmp Xmit_08 

I 

; But During SYNCPHASE we simply lock with a clear 
Xmit_05: 

mov [TX_READY],0 ; set it not busy, set by Interrupt rtn 

Xmit_08: 

$ 

; put header in packet buffer 


cld 


; set auto increment 

les 

di,[CARD_RAM] 

; point to hardware buffer area 

mov 

si,(bp+DEF_PID) 

; fetch Destination Task PID 

mov 

Cl,3 

; mult by 8 (bytes/address entry) 

shl 

si ,cl 

; index into address table 

Lea 

si,NET_TA8LE[si] 

; fetch address of dest. 

mov 

cx,DEF_addr_size 

; in words 

rep 

movsw 

; copy in dest address 

mov 

si,(PID) 

; get our processor id 

mov 

cl,3 

; mult by 8 (bytes/address entry) 

shl 

s i, c l 

; index into address table 

lea 

si,NET_TABLE[si] 

; fetch our address 

mov 

cx,DEF_addr_size 


rep 

movsw 

; copy in source addr 


; skip over length field for now 
add di ,2 

f 

; Update Sequence Ntmber and put it in packet and acknowledge entry 


- 239 - 











Distributed Issues Final Report 


mov 

inc 

stosw 

ax,[SEQUENCE] 

ax 

; get sequence number 

; put in packet 


mov 

[SEQUENCE],ax 

; update 


test 

jnz 

[SYNC_PHASE],0FFFFH 
Xmit_09 

; see if in sync phase 


mov 

[bx+ACK_SEQ] ,ax 

; put it in outstanding 

requests ;AAA 

call 

Ack_Add 

; add this ack entry to 

the pending list 

mov 

stosw 

ax,[bp+DEF_CMD] 

; get packet command 
; put in buffer 


mov 

stosw 

ax,[bp+DEF_TID] 

; get Destination TID 


mov 

stosw 

ax,[bp+DEF_ENTRY] 

; if entry applies 


mov 

stosw 

ax,[PID] 

; fetch my processor 

■ ID 

mov 

stosw 

ax,[bp+DEF_MY_TID] 

; get my task ID 



copy the parameters into the packet buffer. Use the TCB definitions 
to determine how many parameters, their size, and what type (ie. must 
allow for unconstrained arrays). 


mov 

si,[bp+DEF_Profile] 

get parameter profile ptr 

lodsw 


get number of parameters 

tJO: 



or 

ax,ax 

see if done 

jz 

Xmit_30 

if done 

mov 

[XPARMCOUNT],ax 

update parameter count 

mov 

ax,[si] 

get parameter Mode 

mov 

cx,[si+2] 

fetch parameter type/length 

add 

si ,4 


mov 

[PROF ILEPTR],si 

save profile pointer 

Ids 

si,[bp*DEF_parm_list] 

point to parameter list 

push 

[si] 

segment of data 

push 

[si+2] 

offset of data 

or 

cx,cx 

see if unconstrained type 

jge 

Xmit_15 


process an 

unconstrained object as a parameter, always copy descriptor 

push 

tsi+4] 

descriptor segment 

push 

[si+6] 

offset of descriptor 

add 

si ,8 


mov 

word ptr [bp+DEF_parm_list],si ; update parameter list index 

pop 

si 

get offset of descriptor 


- 240 - 









Distributed Issues Final Report 


pop 

ds 

get segment of descriptor 

push 

ax 

save MOOE of parameter 

mov 

cx, [si+DEF_low_desc] 

get low bound of constraint 

mov 

es:tdi],cx 

put in packet 

add 

di ,2 


mov 

ax, [si+DEF_high_desc] 

get high bound of constraint 

stosw 


put in packet 

mov 

dx, [si+DEF_size_desc] 

get size of object 

mov 

es:[di],dx 

put in packet 

add 

di ,2 


Copy the parameter data iff MOOE is correct and array is not null 

pop 

bx 

get mode of parameter 

pop 

si 

get offset of data 

pop 

ds 

get segment of data 

and 

bx,[bp+DEF_MOOE] 

see if we should copy data 

jz 

Xmit_20 

if not, go on 

sub 

ax,cx 

compute difference in range 

i nc 

ax 

adjust to include end points 

jle 

Xmit_20 

if array is empty go to next parm 

mul 

dx 

compute size in words (descriptor) 

mov 

cx,ax 

put in count register 

rep 

movsw 

transfer to packet buffer 

jmp 

Xmit_20 

go on to next parameter 

Constrained 

parameter, CX is length 

n words, copy it into packet buffer 

t_15: 



add 

si ,4 

move to next object address 

mov 

word ptr [bp+DEF_parm_list],si ; update parameter list index 

pop 

si 

get data offset 

pop 

ds 

get data segment 

and 

ax,[bp+DEF_MOOE] 

see if mode is right 

jz 

Xmit_20 

skip copy of data if not 

inc 

CX 

round up to nearest word count 

shr 

cx, 1 

by adding one and divide by two 

rep 

movsw 


o 

r\j 

1 

*> 



mov 

ax,cs 

restore data segment 

mov 

ds,ax 


mov 

si, [PROFILE_PTR] 

get next parameter profile 

mov 

ax, [XPARM_COUNT] 

get the counter back in ax 

dec 

ax 

count down 

jmp 

Xmit_10 


Setup NIC registers to begin transmission ; 

Must prevent 

a RECEIVE interrupt from 

arriving, which would interfere 

with the registers being updated for Transmission. ; 


- 241 - 













Distributed Issues Final Report 


load start 

address of packet 


Xmit_30: 



pushf 


; save interrupt status 

cl i 


; disable any interrupts 

mov 

dx,nic_cr 

; select Page_0 

mov 

al,eth_access_Page_0 

out 

dx,al 


mov 

dx,nic_tpsr 

; page start register 

mov 

al,eth_xmit_buf_start ; transmit page at DC00:0Q00 

out 

dx,al 


; load length of packet 


mov 

ax,di 

; save current packet pointer 

les 

di, ICARD_RAM] 

; point to hardware buffer area 

sub 

ax,di 

; subtract base to get size in bytes 

add 

di,DEF_pkt_length 

; add offset to data length field 

stosw 


; stick in PACKET length 

cmp 

ax,min_packet 

; make sure it is at least minimum 

jge 

Xmit_40 


mov 

ax,min_packet 


Xmit_40: 



mov 

dx,nic_tbcrO 

; load nixiber to transfer into H/U 

out 

dx,al 


mov 

dx,nic_tbcr1 


mov 

al ,ah 


out 

dx,al 


; start transmit 


mov 

dx,nic_cr 


mov 

a l,send ; 

command to initiate transmission 

out 

dx,al 


popf 

/ 

restore interrupt status 

pop 

bp 

restore bp 

ret 

18 

return and remove stack frame 

; INTERRUPT 

SERVICE ROUTINE 



; Currently, this must have a stack frame similar to other vendor 
; interrupt routines so that the interrupt-mode Signal routine will 
; be able to find the interrupt return address and status 

Interrupt_Handler label far 

push bp 

mov bp,sp 

push ax 


- 242 - 















Distributed Issues Final Report 


push bx 

push cx 

push dx 

push si 

push di 

push ds 

push es 

; First keep interrupt request line from triggering during processing 
; of interrupts (and clearing interrupt bits) 

cld ; for all string operations 

mov dx,nic_cr ; select Page_0 

mov al,eth_access_Page_0 

out dx,al 

mov dx,nic_imr ; interrupt mask register 

mov al,eth_ints_disabled ; disable all interrupt requests 

out dx, a l 

; Process any packet receptions 

; NOTE: since this is done inside the interrupt routine, interrupts 
; are disabled, and therefore there is no interference from other 
; interrupts is expected (especially clock interrupts). 

; Careful attention to race conditions is necessary to prevent a received 
; buffer from not getting processed and interrupts getting lost 

Receive: 

; point DS:SI to packet in hardware buffer 


Ids 

si ,cs:[CARD_RAM] 

; source is ethernet RAM 

add 

si ,cs:CRECEIVE_PTR]; add current receive buffer page address 

mov 

ax.Csi] 

fetch status into AL, NEXT PTR into AH 


t 

since we only receive good packets ignore 

or 

al.al 

see if any packet arrived (if not zero!) 

jnz 

RECV100 ; 

go on if data is there 

jmp 

End_Receive ; 

otherwise, leave the receive section 

f 

; No data 

left, go ahead and 

clear receive interrupt 

; RACE 

CONDITION HERE... 


mov 

dx,nic_isr 

; clear any pending receive interrupts 

mov 

al,nic_prx 

; receive interrupt bit 

out 

dx,al 

; clear receive interrupt (if present) 

t 

; put in 

little delay, then 

make sure nothing just arrived.. 

* 

mov 

ax,10 


RECV020: 



dec 

ax 



- 243 - 













Distributed Issues Final Report 


$$$ 

jnz 

RECV020 


$$$ 

mov 

al,[si] 

; see if something has arrived 

ttt 

or 

al ,al 


sts 

jz 

RECV030 

; if nothing, good... no worries 

$$$; 

something 

did just arrive. 

see if we will see the interrupt 

SSS 

in 

al ,dx 

; fetch interrupt status now 

$$$ 

and 

al,nic_prx 

; see if a receive interrupt was shut off 

$$$ 

jz 

RECV040 

; if we lost the interrupt go sound alarm 

;$$$RECV030: 



SSS 

jmp 

Check_Xmit 


SSS; 




SSS; 

We shut off a receive interrupt by accident 

SSS; 




;S$$RECV040: 



;$$$ 

mov 

al ,7 

; 33a print bell 

;$$$ 

cal l 

outcf.r 


;$$$ 

mov 

al, 

; visible evidence 

;$$$ 

jmp 

CheckXmit 


;S$S 




RECV100: 

; 

aaa check for non recieve ok ptr 


emp 

al.l 

is it a one? 


J'z 

RECV101 



mov 

al ,7 

aaa print bell 


call 

outchr 



mov 

al,'?' 

if non-zero print something special 


call 

outchr 


RECV101: 




xor 

a l, a l ; 

zero low byte, leaving a new pointer 


sub 

ax,eth_offset ; 

correct for memory vs page offset 


mov 

cs:[RECEIVE_PTR],ax ; get ready for next reception 


add 

s i, 4 ; 

skip over receive header (status/page, count 

; SI 

now points 

to first part of 

transmitted packet 


First check to see if it is an ACK message 

mov ax,[si+DEF_pkt_cmd] ; check message type 
or ax,ax ; command is negative for Acks 

jns RECV105 ; if regular packet, go on 

It is an ACK message. Clear it from pending list and free up buffer 


mov 

byte ptr [si-4],0 

; clear 

status flag for next time 

cal l 

ACK_REMOVE 

check off 

the 

ack 

jmp 

END_RECEIVE 

all done 

wi th 

one packet 


; Received a real message, first reload watchdog timer for the source PIO 
RECV105: 

mov di,[si+DEF_pkt_my_pid] ; get source processor ID 

add di,di 


- 244 - 












Distributed Issues Final Report 


mov 

cs:UATCH_DOGCdi] 

,DE F_UAT CH_OOG_LIHIT 

Allocate a 

buffer, and transfer data to the buffer 

after the 

following call, the 

buffer descriptor is in BX. DO NOT DESTROY BX 

rnov 

ax,cs 

; destination segment is CS 

mov 

es,ax 


call 

I0_Allocate 

; destination offset is buffer header in BX 

mov 

di,cs:Cbx] 

; get address of buffer in Dl 

mov 

ax,tsi+D£F_pkt_length] ; get size of valid packet in bytes 

inc 

ax 

; make sure we get odd packets 

shr 

ax r 1 

; convert to words 

i 

; Now transfer memory from hardware buffer pages to software buffer. 

; Note that 

the buffer will wrap around at 4000H back to 2600. 

; Also, the 

first word of each 

page is cleared after the data is removed 

; so that received packets can 

easily be detected. (Since the header bytes 

; are the last thing written, you are guaranteed that the whole packet has 

; been received.) 


1 

mov 

dx,80H-2 

; page size in words (reduced to get aligned) 

RECV110: 



cmp 

ax,dx 

; see if more than a page 

jge 

RECV120 


mov 

dx,ax 

; otherwize only move the remaining words 

RECV120: 



mov 

cx,dx 


rep 

movsw 

; do the transfer 

push 

si 


dec 

si 

; make sure we are in page just processed 

and 

si.OFFOOH 

; backup to its beginning 

mov 

byte ptr [si] ,0 

; and clear status byte for next time 

pop 

si 


cmp 

si,eth_recv_end 

; see if at end of hardware buffer 

jnz 

RECV130 


mov 

si,eth_recv_begin; reset pointer to begin 

RECV130: 



sub 

ax,dx 

; reduce total count by those moved 

jz 

RECV140 

; finished if so 

mov 

dx,80H 

; keep page alignment 

jmp 

RECVIIO 


RECV140: 



mov 

ax,cs 

; restore data segment 

mov 

ds,ax 


; Check what phase we are in. 

If Sync_Phase, do not ack the message or 

; invoke the 

distributed runtime. 

test 

CSYNC_PHASE],OffffH ; NZ means true (sync phase) 

jz 

RECV150 



- 245 - 







Distributed Issues Final Report 


System is still in synchronization phase, simply log that the message 
arrived by setting the RECEIVE FLAG with the buffer descriptor 
During sync phase, only one message can be recieved, so no concern 
for overwriting the REC£IVE_FLAG exists. 

mov IRECE1VE_FLAG],bx 


jmp 

End_Receive 

; done receiving 

; Queue an ACK 

for the sendor then... 

; Call Receive portion of Distributed Runtime code to determine 

; what should be done with the 

newly arrived packet. 

1 

RECV150: 



mov 

si,[bx] 

; get beginning of buffer back 

call 

Ack_Hold 

; first queue an Ack message to go out ;AAA 

cal l 

NETReceive 


END RECEIVE: 

do check on buffer, if no packet there, clear interrupts 

Ertd_Recei ve: 



Ids 

si,cs:[CAR0_RAM] 

; source is ethernet RAM 

add 

si,cs:[RECEIVEPTR]; add current receive buffer page address 

mov 

ax, [si] 

; fetch status into AL, NEXT PTR into AH 



; since we only receive good packets ignore 

or 

al ,al 

; see if any packet arrived (if not zero!) 

jz 

Clear_[nterrupt 

; go on if no data is there 

jmp 

Check_Xmit 


$ 

; No data left, 

, go ahead and cl 

ear receive interrupt 

; RACE CONDITION HERE... 


Clear_Interrupt: 



mov 

dx,nic_isr 

; clear any pending receive interrupts 

mov 

al,nic_prx 

; receive interrupt bit 

out 

dx,al 

; clear receive interrupt (if present) 

i 

; Check if we 

won the race... 


$ 

mov 

ax,10 


C110: 



dec 

ax 


jnz 

CI10 


test 

byte ptr [si],0FFH ; see if something just arrived 

jz 

Check_Xmit 


t 

; Something just arrived, see 

if we can see the interrupt 

i n 

al ,dx 

; get interrupt status 

and 

al,nic_prx 


jnz 

Check_Xmit 

; ok, we still see the interrupt 

mov 

al ,7 

; print bell! 


- 246 - 











Distributed Issues Final Report 


call 

outchr 

; interrupt has been lost! due to race 

mov 

al,'x' 


cal l 

outchr 



; Now check for transmit complete interrupt 

Check_Xmit: 

mov ax,cs 

mov ds,ax 

mov dx,nic_isr 

in al,dx 

and ax,nic_ptx 

jnz Transmit 

/ 

; No xmit complete interrupts, see if there is a ACK to go out 


test 

[ACK_HOLDINGJ, 

,0FFFFH ; see if any acks are waiting to go out 

jz 

EOI 

; nothing to go out 

mov 

ax,[TX_READY] 

; check if transmitter is busy 

or 

ax, ax 


jle 

EOI 

; still busy, just exit 

cal l 

ACK_Send 

; otherwise send out one of the holding acks 

jmp 

EOI 



; Transmit complete, see if an ACK is waiting to go out. Jf so, 
; send it. Otherwise signal READY semaphore. 

Transmit: 


out 

dx,al 

; clear the transmit 

interrupt 

test 

[ACK_HOLDING],OFFFFH 

; see if any acks are 

waiting to go out 

jz 

transmit10 



inc 

word ptr [TX_READY] 

; give credit for transmit complete 

cal l 

ACK_SEND 

; go issue the ack 


jmp 

EOI 




; Only free up transmitter if no acks waiting to go 
; (and out of sync phase. Note: Acks never occur during sync phase) 

transmitIO: 

test CSYNC_PHASE),0FFFFH; if sync phase, indicate free xmitter 

jz transmit20 

mov [TX_READY],1 ; by setting it ready 

jmp EOI 

transmit20: 

push cs ; segment of semaphore 

lea ax,TX_REAOY ; offset of semaphore 

push ax 

call VRTIF_Signal_l ; signal ready for next 10 


; insure data segment is for DRT 
; get interrupt status 
; check for packet transmitted 


- 247 - 









Distributed Issues Final Report 


; Interrupt processing has been completed. Any new interrupts that have 
; come in since clearing the status bit will be recorded by the 8259 
; when we enable the 3Com card interrupt mask. This creates the edge 
; trigger necessary for the 8259 

EOI: 

I 

; Clear the 8259 Interrupt Request 


cl i 

1 

make absolutely sure we don't nest 

mov 

dx,nic_imr ; 

point to mask register 

mov 

al,nic_ptx+nic_prx 

; ; enable transmit (tx) and receive (rx) 

out 

dx,al 


mov 

al,NET_EOI 

issue EOI to interrupt controller 

mov 

dx,VRTIF_I8259 


out 

dx,al 


pop 

es 

restore registers and flags (interrupt) 

pop 

ds 


pop 

di 


pop 

si 


pop 

dx 


pop 

cx 


pop 

bx 


pop 

ax 


pop 

i ret 

bp 



IO_ALLOCATE - Allocates next buffer from Avail list 
Return BX pointing to buffer queue index. 

By design, the buffer should queue should never be empty. 


; Destroys AX 

, BX has new descriptor 

pointer ; 

IO_ALLOCATE: 

pushf 
cl i 



mov 

bx,CS:[RX_BUFF_HEAD] 

; fetch head pointer 

or 

bx,bx 

; see if empty 

jnz 

IO_AILOC10 

; go on if not 


Normally, might raise storage error here, but design prevents 
exceeding buffer capacity unless there is some code flaw. 


popf 

mov 

al,'M' 

; print message 

call 

outchr 


mov 

al.'T' 

; and 

call 

outchr 


int 

3 

; trap 


- 248 - 











Distributed Issues Final Report 


; Remove buffer descriptor from free list 
/ 

IO_ALLOC10: 

mov ax,CS:tbx+DEF_NEXT_PTIO ; fetch next pointer 

mov CS:[RX_BUFF_HEAD],ax ; pull buffer off list, replace head 

xor ax,ax ; null next pointer in buffer 

mov CS:[bx+DEF_NEXT_PTR],ax 

popf 

ret 


IO_DEALLOCATE - Deallocates buffer into Avail list 
Takes BX pointing to buffer descriptor. 


; By des i gn 

; Destroys AX 

, the buffer should queue 

should never be full. ; 

lO_OEALLOCATE: 

pushf 

cli 



mov 

ax,[RX_BUFF_HEAD] 

get head of list 

mov 

[bx+DEF_NEXT_PTR],ax 

put behind this entry 

mov 

popf 

ret 

[RX_BUFF_HEAD],bx 

make this entry new head 


ACIC_ALLOCATE - Allocates next buffer from Free list 
Return BX pointing to Ack entry. 

By design, the free list should never be empty. 


; Destroys AX , BX has new descriptor pointer ; 

; Interrupts are disabled to maintain list consistency ; 

ACK_AlLOCATE: 

pushf 

cli 



mov 

bx,[ACK_FREE] 

; fetch head pointer 

or 

bx,bx 

; see if empty 

jz 

ACK_ALLOC10 

; if failure 


Remove buffer descriptor from free list 


mov 

ax,lbx+ACK_NEXTl 

; fetch next pointer 

mov 

[ACK_FREE] ,ax 

; pull buffer off list, replace head 

xor 

ax, ax 

; null next pointer in buffer 

mov 

Cbx+ACKJIEXT],ax 


popf 


; restore interrupts 

ret 



Normally. 

might raise storage error 

here, but design prevents 


- 249 - 


























Distributed Issues Final Report 


; exceeding buffer capacity unless there is some code flaw. 

I 

ACK ALL0C10: 


popf 



mov 

al.'M' 

; print message 

call 

outchr 


mov 

al,'T' 

; and 

call 

outchr 


int 

3 

; trap 

; ACIC_OEALLOCATE - Deallocates buffer 

into Free list ; 

; Takes BX pointing to buffer descriptor. ; 

; By design, the ack list should never be full prior to call. ; 

; Destroys AX 


t 

AOCJ3EALLOCATE 



pushf 



cl 



mov 

ax,[ACK_FREE] 

• get head of list 

mov 

[bx+ACK_NEXT] ,ax 

; put behind this entry 

mov 

[ACKFREE] ,bx 

; make this entry new head 

popf 



ret 





i n h h m u h n i i n i n n m n n n 

; ACKADD - 

Add another ack entry to 
Input: BX is ack entry 
ax is destroyed 

the pending list 

Ack_Add: 



push 

si 


push 

di 


push 

ax 

;&&& save regs 

push 

cx 


push 

di 


and 

ax,OfffH 

; only use 0-4095 

push 

ax 

; push sequence U &&& 

call 

VRTlF_Timestamp 

; time-stamp it &&& 

pop 

di 


pop 

cx 


pop 

ax 

; &&& restore regs 

pushf 



cl i 



mov 

ax,cs: [ACKJIMER] 


add 

ax,ack_delay 

; number of ticks 

mov 

cs:tbx+ACK_COUNT],ax 



; Find the end of the ack list 


- 250 - 











Distributed Issues Final Report 


lea si,ACK_PEND!NG ; point to header 

ack_add10: 

mov di,cs:[si] ; fetch next pointer 

or di,di ; see if at end 

jz ack_add20 ; jump if so 

mov si,di ; go down the list 

jtnp ack_add10 

ack_add20: 

mov cs:[si),bx ; put behind this entry 

popf 

pop di 

pop si 

ret 


; ACK_REMOVE - Remove ack entry from the pending list. 

; THIS IS ONLY CALLED DURING RECEIVE INTERRUPT ROUTINE 
; SI : points to ACKNOWLEDGE PACKET BUFFER IN HARDWARE 

; relative to the OS segment which points to the 

; hardware packet buffer (NOTE: ACK'S are never 

; unloaded from the hardware buffer). 

; ax,bx,si,cx destroyed 

; NOTE: ACK's have the SEQUENCE they are acking in the normal 
; sequence field. 

Ack_Remove: 

mov cx, [si+DEF_pkt_sequence] ; get SEQUENCE value 

push ax ;&&& save regs 

push cx 

push di 

and cx.OfffH ; only use 0-4095 

push cx ; &&& push for timestamp 

call VRTIF_timestamp ; &&& 

pop di 

pop cx 

pop ax ; &&& restore regs 


lea bx,ACK_PENDING 

Ack_remove10: 

mov si,cs:(bx) 

or si,si 

jz ack_remove30 

cmp cx,cs:tsi*ack_seq] 

jz ack_remove25 

ack_remove20: 

mov bx,si 


• get next pointer 
; exit if at end of list 
; all done (not there!!) 

; check for matched sequence 

; bx is always the previous pointer 


- 251 - 









Distributed Issues Final Report 


jmp ack_remove10 

; Found the entry, remove from pending, and place it on FREE list 
ack_remove25: 

mov ax,cs:[si] ; get next in list 

mov cs:[bx],ax ; link over removed entry 

; put removed node into free list 

mov ax,cs:[ACK_FREE] ; get head of list 

mov cs:[si],ax ; put behind this entry 

mov cs:[ACK_FREE],si ; make this entry new head 

ack_remove30: 
ret 


; ACKHOLO - Add another ack message to the holding list 
; Input: SI points to received message 

Ack HOLO: 



push 

bx 

save message descript-- 


call 

ACK_ALLOCATE 

fetch a free ack entry 


mov 

ax,[si+DEF_pkt_my_pid] 

get pid of sender 


mov 

[bx+ack_pid],ax 

put in record 


mov 

ax,[si+DEF_pkt_sequence] 

fetch received Sequence # 


mov 

[bx+ack_seq],ax 

stick in record 


put at end 

of HOLDING list 



push 

si 



push 

di 



lea 

si,ACK_HOLDING 


ack 

holdIO: 




mov 

di, [si] 

fetch ptr 


or 

di ,di 

see if at end 


jz 

ack_hold20 

jump if so 


mov 

si ,di 

go down the list 


jmp 

ack_hold10 


ack 

_hold20: 




mov 

[si] ,bx 

put behind this entry 


pop 

di 



pop 

si 

restore received message pointer 


pop 

bx 

restore message descriptor 


ret 




ACK_SEND ■ Transmit next acknowledge message on the HOLDING list 


- 252 - 












Distributed Issues Final Report 


; NOTE: This is ONLY called during interrupt servicing when the 
; transmitter is available. This prevents interference with the 
; IO_XMIT routine above. (They both access the H/U) 

; INPUTS: 

; The PID and SEQUENCE number to acknowledge is at the head of 

; the "HOLD" queue. 

; Acknowledgements simply have: OST, SRC, length, ACK_SEQ, ACK_CMD 
ACK Send: 


push 

ax 

; save all registers 

push 

bx 


push 

cx 


push 

dx 


push 

si 


push 

di 


push 

ds 


push 

es 


dec 

word ptr 

[TX_READY] ; mark transmitter as busy 


Get entry off of HOLDING list 


mov 

bx,[ACKHOLDING] 


mov 

ax,[bx] 

get next pointer 

mov 

[ACK_HOLDING],ax 

remove tnis ACK from holding list 

mov 

si,[bx+ack_pidl 

get processor id of originator 

mov 

dx,[bx+ack_seqj 

and sequence # 

cal l 

ACK_DEALLOCATE 

put on free list 

d acknowledge packet 


cld 


set auto increment 

les 

di,[CARDRAM] 

point to hardware buffer area 

mov 

cl,3 

8 bytes per net table index 

shl 

si ,cl 

convert PID to net table index 

lea 

si,NET_TA8LE[si] 

fetch address of dest. 

mov 

cx,DEF_addr_size 

in words 

reo 

movsw 

copy in dest address 

mov 

si,[PID] 

get our processor id 

mov 

cl,3 

mult by 8 (bytes/address entry) 

shl 

si ,cl 

index into address table 

lea 

si,NET_TABLE[si] 

fetch our address 

mov 

cx,DEF_addr_size 


rep 

movsw 

copy in source addr 


length field is fixed to include up to conmand only 

mov ax,DEF_pkt_cmd+2 

stosw ; put in buffer 


- 253 - 











Distributed Issues Final Report 


Put ACKING Sequence Number in packet 


mov 

ax,dx 

; get acking seq number 

stosu 


; put in buffer 

mov 

ax,DEF_ACK 

; set command to ACK 

stosw 


; stuff in buffer 


I 

That's it 

for loading the packet buffer, now kick off transmission ; 


Setup NIC 

registers to begin transmissi 

on ; 


mov 

dx,nic_cr ; 

select Page_0 


mov 

al,eth_access_Page_0 



out 

dx,al 



mov 

dx,nic_tpsr 

page start register 


mov 

al,eth_xmit_buf_start ; 

transmit page at DC00:0000 


out 

dx,al 


; 

load length of packet 



mov 

ax,min_packet ; 

make it is the minimum 


mov 

dx,nic_tbcrO ; 

load number to transfer into H/W 


out 

dx,al 



mov 

dx.nictbcrl 



mov 

al ,ah 



out 

dx,al 


; 

start transmit 



mov 

dx,nic_cr 



mov 

al,send ; command 

to initiate transmission 


out 

dx,al 



pop 

es 



pop 

ds 



pop 

di 



pop 

si 



pop 

dx 



pop 

cx 



pop 

bx 



pop 

ax 



ret 




ACKCHECK 

- Check to see if any acknowledgment requests are over 



ACK_LIMIT clock interrupts 

old. Cause shutdown if so. 

/ # 

I N T 

ERRUPT SERVIC 

E ROUTINE 


This routine is invoked by the runtime timer interrupt routine to 
allow the network 10 funtions to be checked. As a result, 

ALL REGISTERS except AX and OS MUST BE PRESERVED!!! 


Note: because this routine is run every 5 milliseconds, it has 


- 254 - 

















Distributed Issues Final Report 


been optimized to take up little time in the typical case. For 
this reason, there are three exit points which are executed in 
straight line code. 


ACK CHECK: 



mov 

ax,cs 



mov 

ds f ax 


; For 

each conwunieating processor, check watch dog timer 


push 

si 



push 

di 



push 

cx 



mov 

si,[WATCH_LIST: 



mov 

cx.lsi] 

get number of processor to wa";h 


jcxz 

ACK08 



add 

si ,2 


ACK05: 





mov 

di.Csi] ; 

get processor ID of next to watch 


add 

di ,di 



dec 

word ptr WATCHDOG[di] ; 

check watch_dog 


jz 

ACK20 

FAILURE 


add 

si ,2 



loop 

ACK05 


ACK08: 





pop 

cx 



pop 

di 



pop 

si 


; Now 

see if 

any outstanding messages 



mov 

ax, [ACK PENDING] 

get pending list 


or 

ax, ax 



jnz 

ACK10 

if message on list, must check 


retf 



ACK10: 





push 

si 



mov 

si ,ax 



mov 

ax,[ACK_TIMER] 

get current TIME 


inc 

ax 



mov 

[ACK_TIMER],ax 

update 


emp 

ax, [si+ack_count] ; 

see if our TIME is UP 


jz 

ACK20 



pop 

si 



retf 

; 

return, still time before error 

ACK20: 





mov 

al,TIMER_EOi 

clear timer channel interrupt 


mov 

dx,VRTIF _18259 



out 

dx.al 



mov 

al.OfdH 

shut off everything but keyboard 


- 255 - 







Distributed Issues Final Report 


inc 

dx 


point to mask reg 

out 

dx,al 



xor 

ax, ax 



push 

ax 



call 

VRTIF 

_T imestamp 


jmp 

Shut_0own 

Acknowledgment timed out! 

; Data AREA 


align 

4 


ISR 

dw 

? 

interrupt status register 

PACKET_SIZE 

dw 

? 

packet size 

CARD_RAM 

dd 

OdcOOOOOOh 

address of ram buffer on enet card 

RECEIVEPTR 

dw 

7 

points to current next page to rev 

XPARM_COUNT 

dw 

? 

number of xmit params left to copy 

PROFILE_PTR 

dw 

? 

current ptr to parameter profile 

SEQUENCE 

dw 

? 

this processor's packet sequencer 

NULL_LI ST 

dw 

0 

zero parameters 

t 

; The following semaphore is used to provide mutual exclusion to the 

; transmit 

side of the Ethernet card. 


t 

TX_READY 

dw 

? 

semaphore count 


dw 

? 

task value 


dw 

? 

task value 

RECEIVEFLAG 

dw 

? 

contains buffer desc in SYNC_PHASE 


BUFFER QUEUE STRUCTURE 
record 

BUFFER_OFFSET 
NEXT_PTR 
end record; 


RX_BUFF_HEAD dw 
RXBUFFER db 
RX BUFF Q dw 


(?) 

num_buff dup (buff_size duo (?)) 

num_buff dup (2 dup(?)) ; <BUFFER_PTR, NEXT_DESC_PTR) 


The outstanding packet acknowledgement queue contains the 
Task id and the sequence number used when transmitting 
each (non-acknowledgement) message. Uhen an acknowlegement message 
is received, this list is checked and if the ids are found, 


- 256 - 
















Distributed Issues Final Report 


they are removed. If they are not found, the acknowledgement is 
trashed (this should not occur unless the master CPU restarts while 
a slave is still transmitting an acknowledge. However, in future 
versions with retry implemented, multiple acknowledgements may be 
possible. 

Queue structure: 

************************* 

* NEXT QUEUE PTR * 


* TASK ID 


* SEQUENCE NUMBER * 

************************* 

* TIMER COUNTER * 
************************* 


t 

ack_delay 

equ 

20 

; interrupts = 5 ms each 

ACK_TIMER 

dw 

? 


ACK_FREE 

dw 

? 

; list of unused acks 

ACK_PENDING 

dw 

? 

; list of acks we are waiting for 

ACK_HOLDING 

dw 

? 

; list of acks waiting to go out 

ack_size 

equ 

8 

; bytes per entry 

; list structure 



ack_next 

equ 

0 

; point to next in ack list 

ack_pid 

equ 

2 

; processor ID of packet to be acked 

ack_seq 

equ 

U 

; sequence number 

ack_count 

equ 

6 

; counter (used to time-out ack) 

ACK_RECORDS 

dw 

nim_buf f dup 

(ack_size dup(?)> ; NEXT, SEQ#, COUNT 

cseg 

ends 




end 




- 257 - 







Distributed Issues Final Report 


page 55,132 

TITLE VRTIF - Vendor Runtime Interface Module 


FILE: DA_VRTIF 

Distributed Ada - Vendor Runtime Interface 

This module provides the addresses within the 

Vendor supplied runtime for required tasking primatives. 

Copyright(C) 1989, LabTek Corporation 


include DA_0EF.ASM 

public VRTIFJ8259, VRTI F_vector_base 

public VRTIF_Wait, VRTIF_Signal, VRTIF_Signal_I 

public VRTIF_Lower_Priority 

public VRTIF_Create_Task 

public VRTIF_Activate_Complete 

public VRTIF_Entry 

public VRTlF_Rendezvous_Complete 

public VRTIF_Accept 

public VRTIF_Select 

public VRTIF_PutCh 

public VRTIF_Timestamp 

public VRTIFTCBTID 

public VRTIF_APPLICAT ION 

public VRTIF_Init 

public VRTIF_task_ptr 

public VRTIF_DS 

public VRTIF_SELECT_REC 

extrn Create_Task:near 
extrn Activate_Complete:near 
extrn Request_Entry:near 
extrn Rendezvous_complete:near 
extrn Select:near 
extrn Accept:near 

extrn PID:word 


VRTIF_I8259 equ 20H 
VRTIF_TCBTID equ 22 
VRTIF_$ELECT_REC equ 6 


address of interrupt controller chip 
offset in TC8 to priority (identifies task) 
bytes per stack record for each open 
alternative in a select statement 


far_jmp_instruction 

equ 

000EAH 

jmp intersegment 

retf2_instruction 

equ 

0CA02H 

return intersegment pop two bytes 

retf_instruction 

equ 

000CBH 

return far 

short_call_instruction 

equ 

0C0E8H 

short call 



- 258 - 










Distributed Issues Final Report 


NOTE: During start up (COLD START) the vector base is that of DOS. After 
runtime intitialization has completed it is moved to 200H. However, this 
occurs after the network initialization, and the vectors in plai » at 20H 


; are moved to 

200H. 

Subsequent restarts are "WARM" and do not effect any 

; of the interrupt vector tables. 


VRTlF_vector_base 

equ 20H 

; Initial base of vector table (DOS) 

VRTIF 

segment at DEF_VRTIF 

_ADDR 


org 

0 

; this is just for convience 

VRTIF_DS 

Label 

word 

; actually indifferent segment 


org 

970H 

; offset in RT OS 

VRTIF_TASK_PTR 

label 

word 

; offset in DS for current task 

/ 

; RUNTIME TASKING CALLS ADDRESSES 

TO ALLOU VECTORING TO THE DISTRIBUTED 

; Ada RUNTIME 




' 

org 

110AH 


R1Accept 

label 

far 

■ simple accept 


org 

12C1H 


RlEntry 

label 

far 

; simplecallentry uncond 


org 

13F3H 


RlRendezvousComplete 

label far 

; rendezvouscomplete 


org 

K76H 


RIActivated 

label 

far 

; activated 


org 

161CH 


RICreateTask 

label 

far 

; createtask 


org 

1D28H 


RlSelect 

label 

far 

; select 


org 

2608H 


VRTIF_SETPRIORITYLOUER label far 



org 

39BBH 


VRTIF_PutCh 

label 

far 

; put_character 


org 

3CCEH 

; timestamp 

VRTIF_Timestamp 

label 

far 



org 

AOFOH 

; patch for short calls to set prior 

PATCH_AOFO 

label 

far 



org 

5198H 



- 259 - 








Distributed Issues Final Report 


VRTIF_Signal_I 

label 

far 

; R1TESI7VI V semaphore operation 

(interrupt) 


org 

51D0H 



VRT!F_Wait 

label 

far 

; R1TESS7P P semaphore operation 

(non interrupt) 


org 

51E6H 



VRTIF_Signal 

label 

far 

; R1TESS7V V semaphore operation 

(non-interrupt) 

VRT IF 

ends 





; APPLICATION ENTRY ADDRESS 

f 

vrtif2 segment at 537411 

org 6 

VRTIF_APPLI CATION label far 
vrtif2 ends 


cseg segment common 

assure cs:cseg,ds:cseg.es:cseg 
org 1100H 

; ch in calls to distributed runtime to allow runtime checking 
; o* distribution. 

VRTIr Init: 

mov ax,DEF_VRTIFADDR ; segment for Vendor Runtime 

mov es,ax 


Create Task 

lea di.Rlcreatetask 

mov byte ptr es:(di], 1 ar_jmp_instruction 
inc di 

lea ax,Create_Task 

mov es:ldi],ax 

add di,2 

mov ax,cs 

mov es:[di],ax 

Activate Complete 

lea di.RIActivated 

mov byte ptr es:[di],far_jmp_instruction 
inc di 

lea ax.Activate_Complete 

mov es:Cdi],ax 

add di,2 

mov ax,cs 

mov es:[di],ax 


- 260 - 







Distributed Issues Final Report 


; entry calls 

lea di.Rlentry 

mov byte ptr es:[di],far_jmp_instruction 

inc di 

lea ax,Request_Entry 

mov es:[di],ax 

add di,2 

mov ax,cs 

mov es:[di],ax 

; end rendezvous 

lea di.RIrendezvouscomplete 

mov byte ptr es:[di],far_jmp_instruction 

inc di 

lea ax,Rendezvous_Complete 

mov es:[di],ax 

add di,2 

mov ax f cs 

mov es:[di],ax 

; Select 

lea di.RISelect 

mov byte ptr es:[di],far_jmp_instruction 

inc di 

lea ax,Select 

mov es:[di],ax 

add di,2 

mov ax,cs 

mov es:[di],ax 

; Accept 

lea di,R1Accept 

mov byte ptr es:[di],far_jmp_instruction 

inc di 

lea ax,Accept 

mov es:[di],ax 

add di,2 

mov ax,cs 

mov es:[di],ax 

I 

; SETUP special short call transfer area at end of patch for setting 
; the priority 

t 

lea di,PATCH_40F0 

mov byte ptr es:[di],short_call_instruction 

mov word ptr es:[di+1].offset VRTIF_SETPRIORITYLOWER-(PATCHA0F0+3) 

mov byte ptr es:[di+3],retf_instruction 

: If this is not the master, do not use PutChar... must patch 


- 261 - 





Distributed Issues Final Report 


; it out. 

i 

test CS:[PID],0FFFFh ; master is always zero 

jz Init_10 

lea di,VRTIF_PutCh 

mov word ptr es:[di],retf2_instruction 

mov byte ptr es:[di+2],0 ; high half of count 

Init_10: 

mov ax,cs ; restore data segment 

mov ds,ax 

ret 


assume ds:VRT!F 

VRTIF_Accept: 

mov ds,[VRTIF_DS] 

mov si,[VRTlF_TASK_PTR] 

jmp R1Accept+8 

VRTIF_Entry: 

mov ds,[VRTIFDS] 

mov si,[VRTIFTASKPTR] 

jmp R1Entry+8 

VRTlF_Rendezvous_Complete: 

mov ds,[VRTIFDS] 

mov si,[VRTIF_TASK_PTR] 

jmp Rlrendezvouscomplete+8 

VRTIF_Activate_Complete: 

mov ds,[VRTIF_DS] 

mov si,[VRTIF_TASK_PTR] 

jmp Rlactivated+8 

VRTIF_Create_Task: 

push bp 

mov bp.sp 

mov ds,[VRTIF_DS] 

jmp R1createtask+7 

VRTIF_Select: 

push bp 

mov bp.sp 

mov ds,[VRTIF_DS] 

jmp Rlselect+7 

VRTIF_Lower_Priority: 

call Patch_40F0 

ret 


- 262 - 







Distributed Issues Final Report 


cseg ends 
end 


- 263 - 




Distributed Issues Final Report 


page 55,132 

TITLE DiCB - Distributed Task Control Block Module 
FILE: DA_DTC8.ASM 

DA - Distributed Task Control Block Module 

Copyright(C) 1989, LabTek Corporation, Uoodbridge, CT USA 

Ver Date Description 

0.2 Dec-89 : Enhanced to support error detection and dynamic 
configuration 


include 

DA_0EF.ASM 

.model 

large 

public 

DTCBJNIT 

public 

SYNCHROSEMAPHORE 

public 

CONTINUE_SEMAPHORE 

public 

TASK_DIRECTORY 

public 

proc_table_size 

public 

REMOTE_CPU_TA8LE 

public 

NAMETABLE 

public 

WATCH_LI ST 

public 

UATCHDOG 

extrn 

MOOE_SELECT:word 

extrn 

PID:word 

segment 

common 

assume 

cs:cseg,ds:cseg,es 

org 

0A00H 


Task Control Blocks 

Semaphore 3 words 

Reply Pointer 1 word 

Return Address 2 words 

Nun Entries 1 word 

Entry Table N * 3 words (where N is the number of entries) 
Profile Ptr 1 word 

Wait Flag 1 word 

Entry Queue 2 words 


- 264 - 

















Distributed Issues Final Report 


Prof ile List: 

Number of Parameters 1 word 

Mode 1 word ("in", "out", “in out") 

Type/Length 1 word (negative means unconstrained) 


The TCB contains a synchronize semaphore which is used to 
suspend itself and wait for a signal from another task. 

This is followed by a reply pointer used to hold the buffer 
descriptor of the message to which a reply is due. Then 
the entry information is provided. This begins with the nunber 
of entries for this task, followed by a record for each entry. 
Each entry record contains: 

- A profile pointer which provides the offset within the CS for 
information on the parameter profile for this entry. 

- A waiting flag used by the acceping task to indicate that it 
has suspended waiting for a call on this entry (and possibly 
others). 

- A buffer List Pointer, This points to the buffer descriptor 
for the first caller to this entry. The buffer descriptor 
provides the actual buffer address and a link to the next 


; descriptor. This provides the FIFO queue for each entry 

semaphore 

st rue 


du 3 dup (?) 

semaphore 

ends 


; TC8_INIT - Initialize Distributed Task Control Blocks 
» 

DTCB Init: 


xor 

ax,ax 


mov 

[SYNCHRO_SEMAPHORE] ,ax 


mov 

[SYNCHR0SEMAPH0RE+2] ,ax 


mov 

[SYNCHR0_SEMAPH0RE+4],ax 


mov 

[CONTINUE_SEMAPH0RE3,ax 


mov 

[CONTINUE_SEMAPH0RE+2] ,ax 


mov 

[CONTINUE_SEMAPH0RE+4] ,ax 


; Initialize 

Distributed Task Directory 

Based on Current Operating Mode 

; This cal Is 

the Init_TCB for each task 

to initialize its structures. 

INIT_DI RECTORY 



mov 

si, [MOOE_SELECT] 

; fetch mode 

dec 

si 

; model => offset 0 

add 

s i, s i 

; make word index 

mov 

si,MOOE_TABLE[si] 

; fetch address of mode values 


- 265 - 













Distributed Issues Final Report 


mov 

cx,total_tasks 


lea 

di,TASK_01 RECTORY 


mov 

ax,ds 


mov 

es.ax 


xor 

ax, ax 


cld 



INIT_DIR_LOOP: 



movsw 


; transfer local/distrib flag 

movsw 


; transfer PID 

mov 

bx,[di] 

; get TCB pointer 

cal l 

Init_TCB 


acid 

di ,2 

; skip the distrib TCB pointer 

stosw 


; zero counter for tasks of this type 

loop 

INIT_DIR_LOOP 


f 

; Initialize 

Watch Dog Timer Information based on configuration and 

; this processor's ID 


mov 

ax, [PID] 


mov 

bx,DEF_max_cpus*2 

; bytes per cpu entry 

mul 

bx 


mov 

bx,ax 

; BX = cpu offset 

mov 

ax,[MOOE_SELECT] 


dec 

ax 

; adjust by one to make zero origin 

mov 

dx,(DEF_max_cpus*DEF_max 

;_cpus) * 2 ; bytes per mode table 

mul 

dx 


mov 

si ,ax 


lea 

si,UATCH_TABIE [si+bx] 

; get address of watch list entry 

mov 

[UATCH_LIST],si 

; set value for other's use 

mov 

cx, [si] 

; fetch number of timers to init 

jcxz 

Uatch_init_done 


add 

si ,2 


Watch_Imt: 



mov 

bx,[si] 

; fetch PID of processor to watch 

add 

bx,bx 


mov 

UATCH_DOG[bx],DEF_WATCH_ 

DOG_LIMIT ; init timer for this pid 

add 

si ,2 


loop 

Uatch_init 



Uatch_init_done: 

ret 


; Init_TCB : zero all semaphore words and entry table values tor the TC8 
; pointed to by: 

• INPUT: BX points to TCB of interest 

; AX contains zero 

Init_TCB: 

or bx,bx ; does this task have a TCB? 


- 266 - 










Distributed Issues Final Report 


jz 

mov 

mov 

ITK3V 

push 

mov 

lea 

jcxz 

Init_TCB_10: 
mov 
mov 
mov 
add 
loop 

Init_TCB_20: 
pop 

Init_TCB_30: 
ret 

align 


!nit_TCB_30 ; exit if not applicable 

[bx],ax ; clear semaphore 

tbx+2],ax 
[bx+4],ax 
cx 

cx,[bx+DEF_num_entries] 
bx,OE F_entry_tabl e[bx] 

I nit TCB 20 


; fetch number of entries 
; if no entries 


DEF_entry_wait[bx],ax 
DEF_entry_queue[bx] ,ax 
DEF_entry_queue+2[bx],ax 
bx.size DEF_entry_rec 
Init TCB 10 


; zero wait flag 
; zero buffer descriptor 
; zero next pointer 
; go to next record 


cx 


4 


Configuration Hode Control 

THESE TABLES WOULD NORMALLY BE PROOUCED BY A CONFIGURATION CONTROL 
TOOL, BUT FOR PROTOTYPE PURPOSES THEY ARE GENERATED BY HAND. 

The current configuration control allows for four different 
operating modes and three processors (alpha, bravo, and Charlie): 

MOOE 1 : All tasks are on the alpha processor 

MODE 2 : All BDS tasks are on alpha, all simulator tasks are on bravo. 

MOOE 3 : All BDS tasks are on alpha, all simulator tasks are on Charlie. 

MOOE 4 : All BDS tasks except one of the guidance tasks is on alpha, 

the simulator is on bravo, and one guidance task is on Charlie 

The mode (below) is initialized during system startup. The master 
processor asks the operator which mode to use. If a system failure 
occurs, the master shuts down the system and brings it back up as 
a single processor version. Note that a system function: 

Configuration Table - for each task, the location is defined in terms 
of current operating mode. 


t 

M00E_TABLE 

label 

word 

dw 

offset 

M00E1 

dw 

offset 

MCOE2 

dw 

of'set 

M00E3 

dw 

offset 

MOOE4 


- 267 - 









Distributed Issues Final Report 


TASK LOCATION DIRECTORY because of lack of compiler 

support, very little information is available to uniquely correlate 

tasks during runtime calls. As a workaround, unique priorities 

are used for each task type, and counters are supplied for multiple 

tasks within the type which modify the identification with respect 

to the task priority. In this way, each task can be quickly correlated 

to its distributed characteristics at runtime. 

The following directory contains entries for each task and is indexed 
by task priority. The entries are: 

<LOCAL/DISTR16UTFD FLAG> <PID> <01ST_TC8_PTR> and <spare> 

The LOCAL/DISTRIBUTED FLAG indicates if all entry calls are local. If 
one is distributed, they must all go through the distributed runtime, 
even if the call being made is local. <P!D> is the processor that the 
task is resident on. For calls being made through the distributed 
runtime, additional task control information is located by the pointer 
DIST_TC8_PTR. 

This directory is initialized during configuration time based on 
operator or automatic mode selection. The first two values are 
set according to mode, the last two are statically defined. 


A********************************-**********************#**-********************* 


RECTORY 

label 

word 




dw 

4 dup 

(0) 


; dunny to offset 

32 

dw 

7 

SAVE_TCB, 

7 

;(12)save 

31 

dw 

7,7 t 

DISPLAYTCB, 

7 

;(11)display 

30 

dw 

?,?, 

TRACK_DAT_TCB, 

7 

;(10)track_data 

29 

dw 

7,7 g 

REPORTBUF_TCB, 

7 

;(09)report_buf 

28 

dw 

7 f 7 # 

GUI0EBUF_TCB, 

7 

;(08)guide_buf 

27 

dw 

7, 

R0CKSUP_TC8, 

7 

;(07)rock_sup 

26 

dw 

7 # 7 

TARGSUP_TCB, 

7 

;(06)targ_sup 

25 

dw 

7 g 7 g 

CONTROLTCB, 

7 

;(05)control 

24 

dw 

7,7, 

GUIDANCE1_TCB, 

7 

;(04)guidance( 1) 

23 

dw 

7 g"? t 

GUIDANCE2_TCB, 

7 

;(03)guidance(2) 

22 

dw 

7,7 

TRACK,TCB, 

7 

;(02)track 

21 

dw 

7 7 

UPDATE_TCB, 

7 

;(01)update 

20 

dw 

7,7 1 

MAIN_TCB, 

7 

;(00)bds 

19 


total_tasks equ ($-TASK_DlRECT0RY)/8 ; must follow definitions above 

. ******************************************************************************* 


local_ent-ies equ 0 

dist_entries equ 1 


For each mode (of four) the local/distrib flag must be set and the pid 
must be set. 


- 268 - 










Distributed Issues Final Report 


M00E1 


M00E2 


M00E3 


label word 

DISTRIBUTED , 


dw 

2 dup (0) 

dw 

local_entries 

dw 

local_entries 

dw 

local_entries 

dw 

local_entries 

dw 

local_entries 

dw 

local_entries 

dw 

local_entries 

dw 

local_entries 

dw 

local_entries 

dw 

0 

dw 

local entries 

dw 

local entries 

dw 

local_entries 

label 

word 


DISTRIBUTED 

dw 

2 dup (0) 

dw 

local_entries 

dw 

local_entries 

dw 

local_entries 

dw 

dist_entries, 

dw 

dist_entries. 

dw 

'ocal_entries 

dw 

distentries. 

dw 

local_entries 

dw 

l oca gentries 

dw 

0 

dw 

iocal_entries 

dw 

local_entries 

dw 

local_entries, 

label 

word 


DISTRIBUTED 

dw 

2 dup (0) 

dw 

local_entries, 

dw 

local_entries, 

dw 

local_entries, 

dw 

distentries. 

dw 

dist_entries. 

dw 

local_entries. 

dw 

dist_entries, 

dw 

local_entries, 

dw 

local entries, 


PID 


; dummy to 

DEF_alpha 

DEF_alpha 

DEF_alpba 

0EF_alpha 

DEF_alpha 

DEF_alpha 

DEF_alpha 

DEF_alpha 

DEF_alpha 

DEF_NA 

DEF_alpha 

DEF_alpha 

DEF_alpha 


PID 


; dunmy to 

DEF_alpha 
DEF_alpha 
DEF_alpha 
DEF_bravo 
DEF_brs/o 
DEF_bravo 
DEF_bravo 
DEf_alpha 
DEF_alpha 
DEF_NA 
DEF_alpba 
DEF_alpha 
LEF_alpha 


PID 


; durniy to 

DEF_alptia 
0EF_alpba 
DEF_alpba 
DEF_charlie 
0EF_charl ie 
DEF_charlie 
DEF_charl ie 
DEF_alpha 
DEF_alpha 


offset priority by one 

;(12)save 

;(11)display 

;(10)track_data 

;(09)report_buf 

;(08)guide_buf 

;(07)rock_sup 

;<06)targ_sup 

;(05)control 

;(04)gui danced) 

;(03)guidance(2) 

;(02)track 
;(01Jupdate 
;(00)bds 


offset priority by one 
;(12)save 
;(11)display 
;(10>track_data 
;(09)report_buf 
;(08)guide_buf 
;(07)rock_sup 
;(06)targ_sup 
;<05)control 
;(04>guidance(1) 
;(03)guidance(2) 

;(02)track 
;(01Jupdate 
;(00)bds 


offset priority by one 
;(12)save 
;(11)display 
;(10)track_data 
;(09)report_buf 
;(08)guide_buf 
;(07)rock_sup 
;(06)targ_sup 
;(05)control 
;(04>guidar»ce(1) 


- 269 - 












Distributed Issues Final Report 


du 

0, 

DEF_NA 

;(03)guidance(2) 

dw 

local_entries, 

DEF_alpha 

;(02)track 

du 

local_entries. 

DEF_alpha 

;(01)update 

dw 

l oca gentries. 

DEF_alpha 

; (00)bds 

M00E4 label 

1 

word 

DISTRIBUTED , 

PID 


1 

du 

2 dup (0) 

• 

dummy to offset priority by one 

dw 

local_entries, 

DEF_alpha 

; (12)save 

du 

local_entries, 

DEF_alpha 

;(11)display 

du 

local_entries. 

DEF_alpha 

;(10)track_data 

dw 

dist_entries. 

DEF_bravo 

; (09)report_buf 

dw 

dist_entries, 

DEF_bravo 

;(08)guide_buf 

dw 

local_entries, 

DEF_bravo 

;(07)rock_sup 

dw 

dist_entries, 

DEF_bravo 

;(06)targ_sup 

dw 

local_entries, 

DEF_alpha 

;<05)control 

dw 

dist_entries, 

DEF_charlie 

; (04)guidance( 1) 

dw 

local_entries, 

0EF_alpha 

;(03)guidance(2) 

dw 

local_entries, 

DEF_alpha 

;(02)track 

dw 

local_entries, 

DEF_alpha 

; (01)update 

dw 

local_entries. 

DEF_alpha 

;(00)bds 


MMMfIfffffff///////FffMfM 

; Task Control Blocks 

t i « t i i t§ t $tt$r$t $t ii tti tti i t i it i titt i 




ft f/ffff KM 

Main_TCB semaphore 

<> 


dw ? 

; Reply Pointer 


dw 2 dup (?) ; Return Address 


dw 0 

; Number of Entries 


1 

Targsup_TCB SEMAPHORE 

<> 


dw ? 

; reply 


dw 2 dup 

(?) ; Return Address 


dw 1 

; nun of distributed entries 


DEF_entry_rec 

<offset Next_Target_Msg,?,?,?> 


Next_Target_Msg dw 

1 ; 1 parameter = TARGET_MSG_ 

TYPE 

dw 

DEF_0UT ; mode = out 


dw 

802 ; only allow 50 targets for 

nowl 

Rocksup_TCB SEMAPHORE 

<> 


dw ? 

; reply 


dw 2 dup 

(?) ; Return Address 


dw 0 

; nun of distributed entries 



- 270 - 
















Distributed Issues Final Report 


Guidebuf_TCB 

SEMAPHORE 

<> 



du ? 

; reply 



dw 2 dup 

(?) ; Return Address 


dw 2 

; nun of 

distributed entries 


OEF_entry_rec 

<offset Put_Guide,?,?,?> 


DEF_entry_rec 

<offset Get_Guide,?,?,?> 

Put_Guide 

dw 

1 

1 parameter 


dw 

0EF_1N 

in mode 


dw 

122 

U bytes 

Get_Guide 

dw 

1 

1 parameter 


dw 

DEFJXJT 

out mode 


dw 

122 

# bytes 

1 

Reportbuf_TCB 

SEMAPHORE 

<> 



dw ? 

; reply 



du 2 dup 

(?) ; Return Address 


du 2 

; nun of 

distributed entries 


DEF_entry_rec 

<offset Put_Report,?,?,?> 


DEF_entry_rec 

<offset Get_Report,?,?,?> 

Put_Report 

dw 

1 

1 parameter 


dw 

DEFIN 

in mode 


dw 

322 

# bytes 

Get_Report 

dw 

1 

1 parameter 


dw 

DEF_OUT 

out mode 


dw 

322 

# bytes 


Track_TCB 

SEMAPHORE 

<> 


dw 

? 

; reply 


dw 

2 dup (?) ; Return Address 


dw 

0 

; nun of distributed entries 

Control_TCB 

SEMAPHORE 

<> 


dw 

? 

; reply 


dw 

2 dup (?) ; Return Address 


dw 

0 

; nun of distributed entries 

1 

Guidance1_TC8 

SEMAPHORE 

<> 


dw 

? 

; reply 


dw 

2 dup (?) ; Return Address 


dw 

2 

; nun of distributed entries 


OEF 

_entry_rec 

<offset History,?,?,?> 


OEF. 

_entry_rec 

<offset Next_Guidance,?,?,?> 

History 


dw 

1 ; 1 parameter 


- 271 - 









Distributed Issues Final Report 


Next Guidance 


dw DEF_IN 

dw -1 

dw 1 

dw DEFJXJT 

dw -1 


mode is in 
unconstrained 
1 parameter 
mode is out 
unconstrained 


1 

Guidance2_TCB 

SEMAPHORE 

dw ? 

dw 2 dup 

dw 2 

DEF_entry_rec 

DEF_entry_rec 

<> 

; reply 

(?) ; Return Address 

; nun of distributed entries 
<offset History,?,?,?> 

<offset Next_Guidance,?,?,?> 

SAVE TCB 

SEMAPHORE 

<> 


dw 

? 

; reply 


dw 

2 dup (?) ; Return Address 


dw 

0 

; nun of distributed entries 


DISPLAY_TCB 

SEMAPHORE <> 


dw 

? 

* 

reply 


dw 

2 dup (?) 

; Return Address 


dw 

o 

nun of distributed entries 


TRACK_DAT_TCB SEMAPHORE 

<> 

dw 

7 

; reply 

dw 

2 dup 

(?) ; Return Address 

dw 

0 

; nun of distributed entries 


UPDATEJXB SEMAPHORE 

<> 


dw 

? 

; reply 


dw 

2 dup (?) ; Return Address 


dw 

0 

; nun of distributed 

l entries 

; These semaphores 

are used 

for synchronization of 

tasks among all 

; processors during 

program 

startup. 


SYNCHRO_SEMAPHORE 

dw 

3 dup (?) 


CONTINUE_SEMAPHORE 

dw 

3 dup (?) 


; PROCESSOR TABLE: 

Given the Mode, the number and pids are provided ; 

; fields: 

# of 

remote CPU's, CPU1-ID, 

CPU2-ID 


proc_table_size equ 6 ; bytes per entry 

REMOTE CPU TABLE label word 


- 272 - 











Distributed Issues Final Report 



dw 

0, DEF_NA, 

DEF_NA 


dw 

1, DEF_bravo, 

DEFJJA 


dw 

1, DEF_charlie, DEF_NA 


dw 

2, DEF_bravo, 

DEF_charlie 

NAME_TA8LE 

label 

word 


dw 

offset 

ALPHA_NAME 


dw 

offset 

BRAVO_NAME 


dw 

offset 

CHARLIE_NAHE 


ALPHA_NAME 

db 

'Alpha',0 


BRAVO_NAME 

db 

'Bravo',0 


CHARLIEJJAME 

db 

'Charlie' ,0 






; Watch Dog Timer Data 

: These Structures determine which processors ; 

; to monitor 

for activity as a function of processor ID and mode. 





align 

2 



; The following table 

contains a block 'or each mode, which contains 

; an entry for each processor. Each 

entry contains a count, followed 

; by the PIDs 

to watch 

This table defines which processors communicate 

; with each other duri 

ng the various 

modes. 

1 

Watch_table_entry_size 

equ 8 


WATCH_TABLE 

label 

word 



;MOOE1 


;M00E2 


;M00E3 


;M00E4 



--no processors 

to 

watch 

dw 

0,0EF_NA 

0EF_NA 


; PIO 0 

dw 

0,DEF_NA 

0EF_NA 


; PIO 1 

dw 

0,DEF_NA 

DEF_NA 


; PIO 2 

dw 

1,DEF_bravo,DEF_NA 


; PIO 0 

dw 

1,DEF_alpha,DEF_NA 


; PIO 1 

dw 

0,DEF_NA 

DEF_NA 


; PIO 2 

dw 

1,0EF_charlie, 0EF_ 

HA 

; PIO 0 

dw 

0,DEF_NA 

OEF. 

_NA 

; PIO 1 


1, DEF_alpha, DEF_NA ; PIO 2 

2, DEF_bravo, DEF_charlie 

1,DEF_alpha, DEF_NA 
1,DEF_alpha, DEFJJA 


; PIO 0 
; PIO 1 
; PIO 2 


WATCHJ.IST 
WATCH OOG 


? ; points to list for current config 

DEF_max_cpus dup (?) ; table of timers 


ends 

end 


- 273 - 











Distributed Issues Final Report 


THIS PAGE INTENTIONALLY LEFT BLANK. 


- 274 - 


Distributed Issues Final Report 


page 55,132 

TITLE Setup - Distributed Ada Network Initialization 


FILE: DA_SETUP.ASM 
Distributed Ada - Setup 

This module initilizes the network to prepare for distributed 
processing. 

Copyright(C) 1989, LabTek Corporation, Uoodbridge, CT. USA 


.model large 
public Setup 
public PIO 
public NET_TABLE 

include DA_HU.ASM 

cseg segment common 

assume cs:cseg,ds:cseg,es:cseg 
org 1C00H 


; processor 10 

; addresses indexed 8 per PID 


Setup: 


GET ADDRESS: 


dx.cntrl ; Gate array controller 

al,eth_enable_reset 

dx,al 

al,eth_disable_reset 
dx,al 

al,eth_access_prom 

dx,al 

cx,6 

ax,cs 

es,ax ; set es:di to receive board 

di,offset BOARD_ADORESS ; address from prom 
dx,prom_address_0 


mov 
mov 
out 
mov 
out 
mov 
out 
mov 
mov 
mov 
mov 
mov 
cld 

in al.dx 
stosb 
inc dx 

loop GET_AD0RESS 

mov dx.cntrl 

mov al,eth_recv_select 

out dx,al 

mov dx.gacfr 

mov al,eth_lan_config 

out dx,al 

mov dx.dqtr 

mov al,eth_rem_OMA_burst 


; select no-sharing adapter, 
; and external transceiver 

; 8K of memory mapped space, 
; with interrupts enabled 

; # of bytes to transfer on 
; a remote DMA burst (n/a) 


- 275 - 








Distributed Issues Final Report 


out 

dx,al 



mov 

dx,idcfr 

f 

interrupt IRQ and DMA 

mov 

at,eth_irq_tine 

0 

channel selection (DMA n/a) 

out 

dx,al 



mov 

dx,damsb 

1 

8k configuration for remote 

mov 

a t,eth_rem_OMA_conf i g 

1 

DMA. Mot used, but minimum 

out 

dx,al 

1 

value needed 

mov 

dx.pstr 

t 

start of receive buffer. 

mov 

at,eth_recv_buf_start 

1 

Value MUST match that in 

out 

dx,al 

t 

MIC jostart 

mov 

dx.pspr 

f 

end of receive buffer. 

mov 

at,eth_recv_buf_end 

l 

Vaiue MUST match that in 

out 

dx,at 

1 

MICjostop 

mov 

dx,NIC_cr 

* 

stop NIC activity 

mov 

at ,eth_nic_stop 



out 

dx,al 



mov 

dx,NIC_dcr 

1 

local DMA transfers as 

mov 

at ,eth_nic_DMA_conf ig 

1 

8 byte bursts 

out 

dx,at 



mov 

dx,NlC_rbcrO 

l 

remote DMA setup (remote 

mov 

al,eth_remote_DMA_lo 

0 

DMA not used, only local 

out 

dx,al 

0 

used) 

mov 

dx,NIC_rbcr1 

0 

hi byte of # of bytes to 

mov 

a t,eth_remote_OMA_hi 

0 

transfer during a remote 

out 

dx,at 

0 

DMA operation 

mov 

dx,NIC_rcr 

0 

accept only good packets 

mov 

at ,eth_packet_types 

0 


out 

dx,at 



mov 

dx,NIC_tcr 

0 

go into internal loopback 

mov 

al,eth_nic_mode 

0 

mode to finish programming 

out 

dx,al 

0 

(see anomalies - p. 52) 

mov 

dx,NIC_body 

0 

overwrite protection rgtr. 

mov 

at,eth_bndy_start 

0 

(protects unread packets) 

out 

dx,at 



mov 

dx,NIC_pstart 

' 

start of receive queue 

mov 

al,eth_recv_buf_start 



out 

dx,at 



mov 

d y .,HIC_pstop 

0 

end of receive queue 


- 276 - 







Distributed Issues Final Report 


mov 

al,eth_recv_buf_end 


out 

dx.al 


mov 

dx,NIC_isr 

; clear interrupt status 

mov 

al,eth_int_status 


out 

dx.al 


mov 

dx,NlC_imr 

; disable interrupts 

mov 

al,eth_ints_disabled 

; for receive and xmit 

out 

dx.al 

$ 

mov 

dx,NIC_cr 

; access page 1 registers 

mov 

al ,eth_access __page_1 


out 

dx.al 


mov 

dx,phys_address_0 

; let NIC know its address 

mov 

ax.cs 


mov 

ds.ax 


mov 

cld 

si,offset BOARO_ADORESS 

; from the prom 

mov 

cx,6 

; number of addresses to give 


GIVE_ADDRESS: 

lodsb 

out dx,al 
inc dx 


loop 

GIVE_ADDRESS 

; load all addresses 

mov 

dx,NIC_curr 

; load current receive pointer 

mov 

al,eth_recv_buf_start 

; with pstart 

out 

dx.al 


mov 

dx,NIC_cr 

; access page 0 registers 

mov 

al,eth_access_page_0 


out 

dx.al 


mov 

dx,NIC_cr 

; start NIC chip 

mov 

al,eth_start_nic 


out 

dx.al 


mov 

dx,NIC_tcr 

; exit internal loopback mode 

mov 

al,eth_exit_mode 


out 

dx.al 



Note: The RAM initialization is necessary for the multi-packet processing 
done in the receive interrupt routine 


mov 

ax, net_n>omory_seg 

; initialize LAN 

memory to 

mov 

es.ax 

; zeroes 


mov 

cx,net_memory_size/2 

; in words 


xor 

cld 

di ,di 

; start at begin 

of segment 


- 277 - 




Distributed Issues Final Report 


mov ax,0000 ; initialization value 

FILL: 

stosw 
loop FILL 


Now check our address against the known Ethernet addresses to determine 
our processor ID 


Search: 


If not found, 


mov 

ax,cs 



mov 

es,ax 

1 

ds already = cs 

mov 

bx,0 

; 

init processor ID 

mov 

di.offset 

NET_TABL£ 


old 



search direction = increment 

push 

di 

1 

save start of current net addr 

mov 

cx,3 

1 

three words per address 

mov 

si.offset 

BOARD^ADDRESS 


repe 

cmpsw 



pop 

di 

; 

restore current table index 

jz 

Found 



add 

di ,P 

* 

go to next index 

inc 

bx 

i 

count processor id 

cmp 

bx.NETCOUNT 

see if all searched 

Jnz 

Search 

; 

loop back if more 


it will return processor id = NET_C0UNT 


Found: 


mov [PID],BX 
ret 


; record Processor ID 
; done with Setup 


align 2 


VALID PROCESSOR ID's Determined by Ethernet ADDRESS 


; 0 - 

ALPHA 



; i - 

BRAVO 



; 2 - 

CHARLIE 



# 

PID 

dw 

7 

; Processor ID 

BOARDADDRESS 

db 

6 dup (?) 

; holds board address 


; PROCESSOR STATION ADDRESS TABLE 

NET_COUNT equ 6 ; nunber of processor on net 

NET_TA8LE label byte 

db 02H, 60H, 8CH, 47H, 61H, 82H,0,0 ; processor Alpha 0 EARTH 

db 02H, 60H, 8CH, 47H, 63H, 55H,0,0 ; processor Bravo 1 VENUS 


- 278 - 









Distributed Issues Final Report 


db 

02H, 60H, 8CH, 48H, 

51H, 

60H,0,0 

; processor Charlie 

2 

db 

02H, 60H, 8CH, 58H, 

35H, 

68H,0,0 

; processor Delta 

3 

db 

02H, 60H, 8CH, 02H, 

00H, 

58H,0,0 

; processor Echo 

4 

db 

02H, 60H, 8CH, 44H, 

52H, 

09H,0,0 

; processor Foxtrot 

5 


cseg ends 

END 


- 279 - 




Distributed Issues Final Report 


page 55,132 

TITLE Sync - Distributed Ada Network Synchronization 


FILE: DA_SYNC.ASM 
Distributed Ada - Setup 

This procedure varies depending on the processor type (master/slave) 
and the operational phase (Sync_Phase vs. normal). Durint 
SYNC_PHASE, the vendor runtime is not used at all (ie. no tasking) 
and a wait loop is used to detect incoming packets. Since it is 
likely that messages will be lost during SYNC_PHASE, a different 
protocol is used which does not specifically utilize ACK messages. 
Instead, resend and long time-outs are used to synchronize. A 
"Cold_Start" command is used here to definitively restart the system. 

During normal operation, the master sends a "sync_start" and waits 
for a "sync_ready‘' from each slave. Then it sends a "synC-Continue" 
to continue with processing (all processors have syncrhonized). 

Copyright(C) 1989, LabTek Corporation, Woodbridge, CT. USA 


.model 

large 


include DA_DEF.ASM 


public 

Sync 




MODULE 

extrn 

MASTER:word 

(da) 

extrn 

SYNC_PHASE:word 

(da) 

extrn 

NUM_ROCKE T S:word 

(da) 

extrn 

NUM_TARGET$:word 

(da) 

extrn 

M00E_SELECT :word 

(da) 

extrn 

Print:near 

(da) 

extrn 

Shut_down:near 

(da) 

extrn 

SYNCHRO_SEMAPHORE:word ;<dtcb) 

extrn 

CONTINUF_SEMAPHORE:word ;<dtcb) 

extrn 

RECEIVE_FLAG:word 

;(io) 

extrn 

TX_READY:word 

;(io) 

extrn 

I0_Deallocate:near 

;(io) 

extrn 

IO_Xmit:near 

; (i o) 

extrn 

VRTIF_WAIT:far 

;(vrtif) 

extrn 

proc_table_size:abs 


extrn 

REMOTE_CPU_TABLE:word 


extrn 

NAME_TABLE:word 


segment 

common 


assune 

cs:cseg,ds:cseg,es:cseg 


- 280 - 










Distributed Issues Final Report 


org 2100H 


Sync: 


push 

ax 


push 

bx 


push 

cx 


push 

dx 


push 

si 


push 

di 


push 

ds 


push 

es 


test 

[MASTER],0FFFFH 

are we a master? 

jnz 

SyncIO 

jmp if master 

jmp 

slave 

no, go act like a slave 

SyncIO: 



test 

lSYNC_PHASE].OFFFFH 

are we in sync phase 

jnz 

Master_Sync 


jmp 

Master_Normal 


MASTER SYNC 

PHASE: 

1 • • • l • • 

synchronize 

information 

with slave processors and 

send them configuration 

Master_Sync: 



mov 

[MASTER_SYNC_OATA_PTR],cs ; first setu- Parameter Data Pointer 

mov 

ax,[NUM_ROCKETS] 

load Configui .io.. Record 

mov 

[CONFIG.ROCKETS] ,8a 


mov 

t-X, [NUM_TARGETS] 


mov 

[CONFIG.TARGETS] ,ax 


mov 

ax, [MOOE_SELECT] 


mov 

[CONFIG.SELECT],ax 


dec 

ax 

adjust model => 0 

mov 

[RETRY_COUNT],DEF_retry_times ; initialize retry counter 

mov 

dx,proc_table_size 

number of bytes per entry (ax=mode) 

mul 

dx 

compute address 

lea 

Si,REMOTE_CPU_TABLE 


add 

s i, ax 

index to proper selected mode 

mov 

[REMOTE_INOEX] ,si 

save index into table 

mov 

cx,[si] 

fetch number of processors 

mov 

[CPU_COUNT] .rx 

remaining CPUS to process 

add 

si ,2 

skip of number 

mov 

[CPU_PTR],si 

save pointer to current CPU 

or 

cx,cx 


jnz 

MSP10 

if there are some remote CPUs 

jmp 

Sync90 

if none 


MSP10: 


- 281 - 







Distributed Issues Final Report 


lea 

si ,crlf 


cal l 

Print 


jmp 

Shut_down 


Sync occured 

, print notification and 

Go on to next processor in list 

MSP30: 



mov 

bx, [RECEIVERLAG] 

; get buffer pointer 

call 

!0_Deallocate 

; return buffer 

lea 

si(Success 


call 

Print 


lea 

si ,crlf 


cal l 

Print 


mov 

si, [CPUPTR] 

; get CPU pointer 

add 

si ,2 


mov 

[CPU_PTR],si 

; update 

dec 

[CPUCOUNT] 

; count down 

jz 

MSP35 

; continue if done with loop 

jmp 

MSP 10 

; otherwise loop back 

f 

; Now All processors have "checked in" 

Send them each a "continue" 

1 

KSP35: 



lea 

si,Sync_Complete 


cal l 

Print 


mov 

si, CREMOTEJNOEX] 

; get index into table back 

mov 

cx,[si] 

; fetch number of processors 

mov 

[CPU_COUNT] ,CX 

; remaining CPUS to process 

add 

si ,2 

; skip of number 

mov 

[CPUPTR],si 

; save as current CPU pointer 

MSP40: 



test 

[TX_READY].OFFFFH 

; make sure the transmitter is free 

jle 

MSP40 

; wait if not 

sub 

sp,6 

; skip parameter stuff 

tea 

ax,MASTER_CONTINUE_PR0FILE ; profile 

push 

ax 


sub 

sp,6 

; skip MY_TID, ENTRY, and TID 

mov 

ax,DEF_sync_continue 

; command 

push 

ax 


push 

[si] 

; processor 10 of destination 

cal l 

I0_Xmit 

; send message 

mov 

si,[CPU_PTR] 

; get CPU pointer 

add 

si ,2 


mov 

[CPU_PTR],si 

; update 

dec 

[CPU_C0UNT] 

; count down 

jnz 

MSP40 



- 283 - 






Distributed Issues Final Report 


Wait for last transmit complete interrupt 


1 

MSP50: 


test 

CTX_READY].OFFFFH 

jle 

MSP50 

jmp 

Sync90 


; make sure the transmitter is free 
; wait if not 
; done 


MASTER NORMAL PHASE : runtime synchronization after configuration setup 


just synchronize with slave processors 


Master_Normal: 

mov ax,[MOOE_SELECT] 

dec ax 

mov dx,proc_table_size 

mul dx 

lea si,REMOTE_CPU_TABLE 

add si,ax 

mov [REMOTE_INDEX],si 

mov cx,[si] 

mov [CPU_COUNT],cx 

add si,2 

mov [CPUPTRj.si 

or cx,cx 

jnz MNP10 

jmp Sync90 

MNP10: 

sub sp,6 

lea ax,MASTER_CONTINUE_PROF 

push ax 

sub sp,6 

mov ax,DEF_sync_start 

push ax 

mov si,CCPU_PTR] 

push Cs i J 

call 10 Xmit 


; model => 0 

; number of bytes per entry (ax=mode) 
; compute address 

; index to proper selected mode 
; save index into table 
; fetch nunber of processors 
; remaining CPUS to process 
; skip of number 
; save pointer to current CPU 

; if there are some remote CPUs 
; if none 

; skip parameter stuff 
IE ; no parameters 

; My TID 

; skip ENTRY, and TID 
; command 

; get cpu pointer back 
; processor ID of destination 
; send message 


Now wait for a reply 

push cs 

lea ax,SYNCHRO_SEMAPHORE 

push ax 

call VRTIF_Wait ; do a wait 


; Sync occured, Go on to next processor in list 

I 

MNP30: 

mov si,CCPU_PTR] ; get CPU pointer 


- 284 - 















Distributed Issues Final Report 


add 

si ,2 


mov 

[CPU_PTR],si 

; update 

dec 

[CPU_COUNT] 

; count down 

jz 

MNP35 

; continue if done with 

jmp 

MNP 10 

; otherwise loop back 


; Now All processors have "checked in". Send them each a "continue" 

f 

MNP35: 

mov si,[REMOTE_INDEX] 

mov cx,Csi] 

mov [CPU_C0UNT],cx 

add si,2 

mov [CPU_PTR],si 

MNP40: 


sub 

sp,6 

skip parameter stuff 

lea 

ax,MASTER_CONTINUE_PROFlLE ; profile 

push 

ax 


sub 

sp»6 ; 

skip MY_TID, ENTRY, and TID 

mov 

ax,DEF_sync_continue ; 

command 

push 

ax 


push 

[si] 

processor ID of destination 

call 

IOXmit 

send message 

mov 

si,[CPU_PTR] ; 

get CPU pointer 

add 

si ,2 


mov 

[CPU_PTR],si 

update 

dec 

[CPUCCXJNT] 

count down 

jnz 

MNP40 


jmp 

Sync90 ; 

DONE 


Slave: 

test [SYNC_PHASE],0FFFFH ; see if initial sync phase 

jnz SlaveOS 

jmp Slave_Normal 

Slave05: 

lea si,Slave_sync 

call Print 


; SLAVE SYNC HOOE 

; Wait for configuration information 

SlavelO: 

test tRECEIVE_FLAG],OFFFFH ; see if incoming data 

jz SlavelO 

; We got a message, check the command for "start" 
mov bx,[RECEIVE_FLAG] 


; get index into table back 
; fetch number of processors 
; remaining CPUS to process 
; skip of number 
; save as current CPU pointer 


- 285 - 









Distributed Issues Final Report 


mov 

[RECEIVE_FLAG},0 

; zero for next time 

mov 

si,Cbx] 

; fetch buffer ptr 

cmp 

word ptr lsi+DEF_pkt_cmd],0EF_cold_start ; is this a START 

J 2 

Slave2Q 


; Must be some other traffic, ignore 

it! 

cal l 

IO_Deallocate 

; free up buffer 

imp 

SlavelO 


; Got a valid Cold Start... respond! 


I 

SlaveZO: 

lea 

si,tsi+Def jjkt_data] 

; point to data area of packet buffer 

mov 

ax,[si+ROCKETS] 

; unload Configuration Information 

mov 

[NUM_ROCK£TS] ,ax 


mov 

ax,tsi+TARGETS] 


mov 

[NUMTARGETS],ax 


mov 

ax,[si+SELECT] 


mov 

CMOOG_SELECT],ax 


cal l 

IO_Deallocate 


Slave30: 

test 

[TX_READY],0FFFFH 

; make sure the transmitter is free 

jle 

Slave30 

; wait if not 

sub 

sp,6 

; skip parameter stuff 

lea 

ax,SLAVEREADYPROFILE 

; profile 

push 

ax 


sub 

sp,6 

; skip MY_TID, ENTRY, and TID 

mov 

ax,DEF_sync_ready 

; command 

push 

ax 


xor 

ax, ax 

; P10 of master is always zero 

push 

ax 


call 

IO_Xmit 

; send message 

lea 

si.Success 


call 

Print 


» 

; Now wait 

for Continue 


1 

Slave40: 

test 

[RECEIVE_FLAG],0FFFFH 

; see if incoming data 

jz 

Slave40 


t 

; Ue got a 

message, make sure it is 

continue 

1 

mov 

bx,CRECEIVE_FLAG] 


mov 

[RECE1VE_FIAG],0 

; clear for next time 

mov 

si,[bxj 

; get buffer pointer 

cmp 

word ptr [si+0EF_pkt_cmd],OEF_sync_continue ; is this a CONT 


- 286 - 












Distributed Issues Final Report 


jz Slave50 

; Must be some other traffic, deallocate buffer, and check for another cold 
; start. 

call I0_0eallocate ; free up buffer 

cmp word ptr tsi+DEF_pkt_cmd],DEF_cold_start ; COLD START? 

jnz SlaveAO ; if not, simply ignore it 

jmp SlavelO ; if so, start all over 

; Slave synchronization has completed, deallocate buffer and exit 

SlaveSO: 

call IO_Deallocate ; free up buffer 

jmp Sync90 


SLAVE NORMAL MOOE 

Uait for •'Start'' semaphore, issue "ready" then wait for "continue" 


Slave Normal: 


push 

cs ; push address of Semaphore 

lea 

ax,SYNCHROSEMAPHORE 


push 

ax 


call 

VRTIF_Uait ; do a 

wai t 

I 

; issue a " 

ready" message 


sub 

sp,6 

; skip parameter stuff 

tea 

ax,SLAVE_READY_PROFILE 

; profile 

push 

ax 


sub 

sp,6 

; skip MY_TID, ENTRY, and 

mov 

ax,DEF_sync_ready 

; command 

push 

ax 


xor 

ax, ax 

; PID of master is always 

push 

ax 


cal l 

IOJCmit 

; send message 

push 

cs 


lea 

ax,CON TINUE_SEMAP HOR E 


push 

ax ; wait 

for the "go ahead" 

cal l 

VRTIF_Uait 



; all , 

done 

Sync90: 



mov 

[SYNC_PHASE],0 ; NO longer in Sync Phase! 

pop 

es 


pop 

ds 


pop 

di 


pop 

si 


pop 

dx 



- 287 - 












Distributed Issues Final Report 


pop 

cx 

pop 

bx 

pop 

ax 

ret 


align 

4 


MASTER_SYNC_PROFILE dw 1 

dw DEF_IN 

dw 6 

MASTER_SYNC_DATA_PTR dw ? 

dw offset 

MASTER_CONTINUE_PROFILE dw 0 

SLAVE READY PROFILE dw 0 


; provide t param: config record 
; mode in 

; nanber of bytes in record 
; segment address 

CONFIG 

; no parameters 
; no parameters 


CONFIG_RECORO struc 

ROCKETS dw 

TARGETS dw 

SELECT dw 

CONFIG RECORD ends 


CONFIG CONFIG_RECORO <> 


NUM_ROCKETS 
NUM_TARGETS 
MODE SELECT 


RETRY_COUNT 

dw 

? 

CPU_COUNT 

dw 

? 

CPU_PTR 

dw 

? 

REMOTE_INDEX 

dw 

? 

Attempt 

db 

13,10,'Trying To Sync With: ',0 

Failure 

db 

' : Synchronization Failed',0 

Success 

db 

' : Synchronization Succeeded',0 

Sync_Complete 

db 

13,10,'SYNCHRONIZATION COMPLETED',13,10,0 

crlf 

db 

13,10,0 

Period 

db 

' . ',0 

Slave_sync 

db 

'Slave Mode, Trying to Synchonize..,0 

cseg ends 




END 


- 288 - 




Distributed Issues Final Report 


page 55,132 

TITLE Setup - Distributed Ada Network Initialization 


FILE: DA_S£TUP.ASM 
Distributed Ada - Setup 

This module initilizes the network to prepare for distributed 
processing. 

Copyrighted 1989, Labiek Corporation, Woodbridge, CT. USA 


.model large 
public Setup 

public PID ; processor ID 

public NET_TA8LE ; addresses indexed 8 per PID 

include DA_HW.ASM 

cseg segment common 

assume cs:cseg,ds:cseg,es:cseg 
org 1C00H 


Setup: 


GET ADDRESS: 


mov 

dx,cntrl ; Gate 

array controller 

mov 

al,eth_enable_reset 


out 

dx,al 


mov 

al,eth_disable_reset 


out 

dx,al 


mov 

al,eth_access_prom 


out 

dx,al 


mov 

cx,6 


mov 

ax,cs 


mov 

es,ax 

; set es:di to receive board 

mov 

di,offset BOARD_ADDRESS 

; address from prom 

mov 

dx,prom_address_0 


cld 



in 

al ,dx 


stosb 



inc 

dx 


loop 

GET_ADDRESS 


mov 

dx.cntrl 

; select no-sharing adapter. 

mov 

al,eth_recv_select 

; and external transceiver 

out 

dx,al 


mov 

dx.gacfr 

; 8K of memory mapped space, 

mov 

al,eth_lan_config 

; with interrupts enabled 

out 

dx,al 


mov 

dx,dqtr 

; # of bytes to transfer on 

mov 

al,eth_rem_DMA_burst 

; a remote DMA burst (n/a) 


- 289 - 









Distributed Issues Final Report 


out dx,al 

mo« dx.idcfr 

rnov a l ,eth_i rq_l ine 

out dx,al 

mov dx.damsb 

mov al,eth_rem_DMA_config 

out dx,al 

mov dx.pstr 

mov al,eth_recv_buf_start 
out dx.al 

mov dx.pspr 

mov al,eth_recv_buf_end 

out dx,al 

mov dx,NIC_cr 
mov al ,eth_nic_stop 
out dx,al 

mov dx,NlC_dcr 

mov al,eth_nic_OMA_config 

out dx,al 

mov dx,NIC_rbcrO 

mov al,eth_remote_OMA_lo 

out dx,al 

mov dx,NIC_rbcr1 

mov al,eth_remote_OMA_hi 

out dx,al 

mov dx,NIC_rcr 

mov al,eth_packet_types 

out dx,al 

mov dx,N!C_tcr 
mov al,eth_nic_mode 
out dx,al 

mov dx, N l C__bndy 

mov at,eth_bndy_start 
out dx,al 

mov dx,NIC_pstart 

mov al,eth_recv_buf_start 

out dx,al 

mov dx,NIC_pstop 


; interrupt IRQ and DMA 
; channel selection (DMA n/a) 

; 8k configuration for remote 
; DMA. Mot used, but minimum 
; value needed 

; start of receive buffer. 

; Value MUST match that in 
; MIC_pstart 

; end of receive buffer. 

; Value MUST match that in 
; NIC_pstop 

; stop NIC activity 


; local DMA transfers as 
; 8 byte bursts 


; remote DMA setup (remote 
; DMA not used, only local 
; used) 

; hi byte of # of bytes to 
; transfer during a remote 
; DMA operation 

; accept only good packets 


; go into internal loopback 
; mode to finish programming 
; (see anomalies - p. 52) 

; overwrite protection rgtr. 
; (protects unread packets) 

; start of receive queue 


; end of receive queue 


- 290 - 









Distributed Issues Final Report 


GIVE ADDRESS: 


FILL: 


mov 

al,eth_recv_buf_end 

out 

dx,al 

mov 

dx,NIC_isr 

mov 

al,eth_int_status 

out 

dx.al 

mov 

dx,NIC_imr 

mov 

al,eth_ints_disabled 

out 

dx.al 

mov 

dx,NIC_cr 

mov 

al ,eth_access_page_1 

out 

dx.al 

mov 

dx,phys_address_0 

mov 

ax.cs 

mov 

ds.ax 

mov 

si,offset BOARD_ADDRESS 

cld 


mov 

cx,6 

lodsb 


out 

dx.al 

inc 

dx 

loop 

GIVE_A00RESS 

mov 

dx,NIC_curr 

mov 

al,eth_recv_buf_start 

out 

dx.al 

mov 

dx,NIC_cr 

mov 

al,eth_access_page_0 

out 

dx.al 

mov 

dx,NIC_cr 

mov 

al,eth_start_nic 

out 

dx.al 

mov 

dx,NIC_tcr 

mov 

al,eth_exit_mode 

out 

dx.al 

mov 

ax,net_memory_seg 

mov 

es.ax 

mov 

cx.net memory_size/2 

xor 

di ,di 

cld 


mov 

ax,0000 

stosw 



; clear interrupt status 

; keep interrupts off 

; access page 1 registers 

; let NIC know its address 

; from the prom 
; number of addresses to give 

; load all addresses 

; load current receive pointer 
; with pstart 

; access page 0 registers 

; start NIC chip 

; exit internal loopback mode 

; initialize LAN memory to 
; zeroes 
; in words 

; start at begin of segment 
; initialization value 


- 291 - 





Distributed Issues Final Report 


loop FILL 

; Now check our address against the known Ethernet addresses to determine 
; our processor ID 

mov ax,cs 
mov es,ax 
mov bx,0 

mov di,offset NET_TABLE 
cld 

Search: 

push di ; save start of current net addr 

mov cx,3 ; three words per address 

mov si.offset BOARD_ADDRESS 
repe cmpsw 

pop di ; restore current table index 

jz Found 

add di,8 ; go to next index 

inc bx ; count processor id 

cmp bx,NET_C0UNT ; see if all searched 

jnz Search ; loop back if more 

I 

; If not found, it will return processor id = NET_COUNT 
» 

Found: 

mov [PIDl.BX 
ret 

align 2 

$ 

; VALID PROCESSOR ID'S Determined by Ethernet ADDRESS 
; 0 - ALPHA 

; 1 - BRAVO 


; 2 - 

CHARLIE 



i 

PID 

dw 

? 

; Processor ID 

BOARD_ADDRESS 

db 

6 dup (?) 

; holds board address 


PROCESSOR STATION ADDRESS TABLE 


NET_COUNT 

equ 

6 




; nLinber of processor 

on net 

NET_TABLE 

label 

byte 







db 

02H, 60H, 

8CH, 

47H, 

63H, 

55H.0.0 

; processor Bravo 

1 

VENUS 

db 

02H, 

60H, 

8CH, 

47H, 

61H, 

82H.0.0 

; processor Alpha 

0 

EARTH 

db 

02H, 

60H, 

8CH, 

48H, 

51H, 

60H.0.0 

; processor Charlie 

2 


db 

02H, 

60H, 

8CH, 

58H, 

35H, 

68H.0.0 

; processor Delta 

3 


db 

02H, 

60H, 

8CH, 

02H, 

00H, 

58H.0.0 

; processor Echo 

4 



; record Processor ID 
; done with Setup 


; ds already = cs 
; init processor ID 

; search direction = increment 


- 292 - 











Distributed Issues Final Report 


cseg 


db 02H, 60H, 8CH, 44H, 52H, 09H,0,0 ; processor Foxtrot 5 

ends 

END 


- 293 - 






Distributed Issues Final Report 


page 55,132 

TITLE DA - Distributed Ada Module 


FILE: DA.ASM 

DA - Distributed Ada Module 

Copyright(C) 1989, LabTek Corporation, Woodbridge, CT USA 


This code is code that would be part of the runtime system, but 
must be linked in to replace some part of the regular runtime 
routines. It is Linked to the runtime via (hand) editing. 

Since the compiler does not supply information ; 
on the parameters in the code (it is implicitly maintained by 
the compiler amoung entry call/accept pairs), tables are placed 
here to provide the information. 

Each packet header is statically formed and placed in this 
module to be reference by the TRANSMIT CONTROL PTR (TCP) used in 
the runtime call parameter list. This reduces the overhead 
associated with packetizing the data. These packet headers 
could be generated by the compiler/linker/distributor and 
optimally would be placed in the controller card memory at 
elaboration time so that loading of header data would be 
necessary. 

Ver Date Description 
0.1 Nov-88 : Initial prototype 

0.2 Dec-89 : Enhanced to support error detection and dynamic 
configuration 


include 

DA_DEF.ASM 

.model 

large 

public 

Shut_down 

public 

COLD_START 

public 

MOOE_SELECT 

public 

SYNC_PHASE 

public 

Print 

public 

MASTER 

public 

NUM_TARGETS 

public 

NUM_ROCKETS 

extrn 

Initialize:near 


; prints out msg, and restarts 
; NZ if this i. cold start 
; Selected Operating Mode 
; During startup to synchronize CPUs 
; for sync printout 
; for sync 

; for sync Config set 
; for sync Config set 

; (rte) 


- 294 - 

















Distributed Issues Final Report 


extrn 

Ack_Check:near 


; (io) 

extrn 

Sync-.near 


; synchronize procedure 

extrn 

VRTIF_APPLI CATION:far 

; (vrtif) 

extrn 

VRTIF_I8259:abs 


; (vrtif) 

extrn 

0TC8_1NIT:near 


; (dtcb) 

extrn 

PI0:word 


; processor id (Setup) 

cseg segment 

common 



; BIOS Vectors 




intIO 


equ 

40H 

int16 


equ 

58H 

initial_imask 


equ 

0FOH ; mask off all but keyboard 

dabase 


equ 

30Q0H ; segment for da runtime 

uppercase 


equ 

00FH ; mask for upper case characters 

EGA_ROM_SEGMENT 


equ 

0C000H 

ROM_PRESENT 


equ 

0AA55H 

ST ACKS1ZE 


equ 

200 ; bytes in local stack 

MAXROOCETS 


equ 

20 ; BOS maximum # rockets 

MAX_TARGETS 


equ 

50 ; BDS maximum # targets 

MAXMOOE 


equ 

it ; BDS maximun mode value 

ERROR_0ELAY 


equ 

70H ; delay roughly 5 seconds 

FlOPPY_STOP 


equ 

0CH ; Shuts off motors 

FLOPPYDIG1TAL 


equ 

3F2H ; address of digital Ctrl reg. 


assune cs:cseg,ds:cseg,es:cseg 


The following jump table provides (static) control transfers from the 
Ada application code to the respective support code located here 


align 

8 

jmp 

Restart 

align 

8 

jmp 

Ack_Check 

align 

8 

jmp 

Get_Master 

align 

8 

jmp 

Get_Rockets 

align 

8 

jmp 

Get_Targets 

align 

8 

jmp 

Get_Tasks 

align 

8 

test 

word ptr cs: 

iz 

No_EGA 

jmp 

dword ptr cs 


No EGA: iret 


00 

prior to elaboration 
08 

Check on Acknolwedgment of Messages 
10 

Returns a boolean if this is the master 
18 

Returns the number of Rockets Configured 
20 

returns the number of Targets Configured 
28 

returns the number of Guide Tasks Configured 
30 


_VIDE0] ; vector to current EGA location 
simply skip any EGA activity 


- 295 - 









Distributed Issues Final Report 


l 


; Restart to initialize the network hardware and configure the system 
Restart: 


mov 

cs:[AUTO],0 

; clear auto configure mode 

Error_Restart: 



cl i 



mov 

dx.VRTIF_I8259+1 

; address of interrupt mask register 

mov 

al,:nitial_imask 

; initial interrupt mask 

out 

dx,al 

; set mask 

; SETUP TEMPORARY STACK 


mov 

ax,seg sseg 


mov 

ss,ax 


mov 

ax,STACK_SIZE 


mov 

sp,ax 


cal l 

clear 

; aa this is fix for compiler bug 

; SETUP DATA 

SEGMENT 


mov 

ax,cs 


mov 

ds,ax 


; CHECK COLD_ 

START FLAG 


test 

[COLOSTART],0FFFH 


jz 

Uarm_start 




1 1 « 1 ( f ( ( ( ( f M 1 1 1 « 1 M « 1 1 1 f M 1 > » 1 f f f M 1 1 ( > M I 

; COLD START 

... FIRST RELOCATE 

TO SEGMENT 3000 

mov 

ax.dabase ; 

first move stack segment 

mov 

es,ax ; 

save for later relocation of code/data 

mov 

cx,cs 


sub 

ax,cx ; 

compute diff between load and base addr 

mov 

cx,ss ; 

now adjust stack segment 

add 

ax # cx 


mov 

ss,ax 


mov 

cx,8000H 


mov 

si.OFFFEH 


mov 

di.OFFFEH 


std 

; 

auto decrement 

rep 

movsw 


cld 



mov 

ax,da_base 


mov 

ds,ax 


push 

ax 


lea 

ax,continue 

















Distributed Issues Final Report 


retf ; switch to 3000: segment 


Shut off floppy motor 


continue: 


mov 

al,FLOPPY_STOP 


mov 

dx,FLOPPY_OIGITAL 


out 

dx,al 


i 

; Get BIOS Vectors 


1 

mov 

ax,0 


mov 

es,ax ; 

point to zero page 

mov 

ax,es:tint 10] 


mov 

word ptr [BIOS_VIDEO],ax 

mov 

ax,es:[intlO+2] 


mov 

word ptr [BIOS_VIDEO+2],ax 

mov 

ax,es:[int16] 


mov 

word ptr [BIOS_KB],ax 

mov 

ax,es:[int16+2] 


mov 

word ptr [BIOSJCB+2] ,ax 

mov 

ax,EGA_ROM_SEGMENT 

mov 

es,ax 


cmp 

word ptr es: [0].ROM PRESEMT 

jni 

warm_start 

; if not present leave flag zero 

mov 

[EGA_PRESENT],1 

; otherwise set flag 

Warm_itart: 



call 

Initialize 

; Initialize Ethernet Board 

mov 

[SYNC_PHASE],1 

; set synchronization phase 

cmp 

CPID] ,0 

; see if we are the master 

jz 

Master_CPU 

; go on if master 

imp 

Slave 


; if here, 

this is the master processor with a console 

Master_CPU: 



mov 

[MASTER],1 

; indicate this is the master 

test 

[FAILURE].0FFFFH 

; see if display already setup 

jnz 

skip_display 


call 

Set_Display 


skip_display 



mov 

[FAILURE],0 

default is no failure (for next time) 

sti 

t 

enable interrupts now for master mode 

test 

[AUTO],0FFFFH 

; see if in auto reconfiguration mode 

jnz 

Automatic 


cal l 

Configure ; 

perform Configuration 

jmp 

TCB_setup 


Automatic: 



cal l 

Auto_Configure 



- 297 - 












Distributed Issues Final Report 


jmp TC8_Setup ; go on and setup tasks 

; if slave mode, do not attempt to configure, this is 

; done during the SYNC_PHASE sync procedure 

Slave: 

mov 
sti 

TCB_Setup: 

I 

; Determine number of Guidance Tasks 

f 

call Sync ; perform a synchronize 

mov si,[MOOE_SELECT] ; get selected mode 
dec si ; model => offset 0 

add si,si ; double for word index 

mov ax,GUIDE_TABLE[si] 

mov [NUMTASKS],ax ; set number of tasks 


[MASTER],0 ; indicate THIS is not a master 

; enable interrupts for slave mode 


call DTCB_Init ; Initialize Task/Processor Directory 

Go execute Application Code 

mov [COLD_START],0 ; FINISHED WITH INITIALIZATION! 

jmp VRTIF_APPLICATION 




; CONFIGURE - This routine sets the distributed system configuration 
/ 

Configure: 

mov si,offset ANNOUNCE 

call Print 

call Get_Char 

and a l, uppercase 

call Put_Char ; Echo Response 

cmp al,'Y' 

jnz Configure 

rockOO: 

mov si,offset ROCKET_QUES 

call Print 

call Get_Nun 

or ax,ax 

jle rock_error 

cmp ax,MAX_ROCKETS 

jle rock20 

rock_error: 

mov si,offset 8AD_ROCKETS 

call Print 

jmp rockOO 

rock20: 


- 298 - 












Distributed Issues Final Report 


mov {NUM_ROCKETS],ax 

targOO: 

mov si,offset TARGET_QUES 

call Print 

call GetJJun 

or ax,ax 

jle targ_error 

cmp ax,MAX_TARGETS 

jle targ20 

targ_error: 

mov si,offset BAD_TARGETS 

call Print 

jmp targOO 

targ20: 

mov {NUM_TARGETS],ax 

modeOO: 

mov si,offset MOOE_QUES 

call Print 

call Get_Num 

or ax,ax 

jle mode_error 

cmp ax,MAX_MOOE 

jle mode20 

mode_error: 

mov si,offset BAD_HOOE 

call Print 

jmp modeOO 

mode20: 

mov [MOOE_SELECT],ax ; establish mode 

mov si,offset AUTO_QUES ; see if auto reconfiguration desired 

call Print 

call Get_Char 

and a l, uppercase 

call Put_Char 

cmp a l,'Y' 

jnz auto_no 

mov {AUTO],1 

mov si,offset DEIAY_QUES ; if auto, check if delay desired 

call Print 

call Get_Char 

and al,uppercase 

call Put_Char 

cmp al,'Y' 

jnz delay_no 

mov {DELAY], 1 

jmp config_done 

auto no: 


- 299 - 





Distributed Issues Final Report 


mov tAUTO],0 ; shut off automatic mode 

delay_no: 

mov [DELAY], 0 

config_done: 
ret 


; AUTO_CONFIGURE - This routine sets the distributed system configuration 

; using an automatic allocation algorithm. 

I 

Auto_Configure: 

mov [MODE_SELECT],1 ; for now, default to uniprocessor 

test [DELAY] ,0FFFFH ; see if we should delay 

jz autolO ; if fast reconfigure requested 

lea si,DELAY_MSG 

call Print 

mov ax,ERROR J5ELAY 

call DELAYJ.OOP 

autolO: 

ret 


Oelay_Loop: 

xor 

delay_loop10: 

loop 

dec 

jnz 

ret 


cx,cx 

delay_loop10 

ax 

delay_loop10 


SHUT_DOWN - Causes a message to be displayed indicating a network 
error, and then jumps to Restart 

This routine is entered only by the ACKCHECK service, therefore all 
interrupts are currently disabled. 


Shut_0own: 

cl i 

mov dx,VRTIF_l8259+1 

mov al,initial_imask 

out dx,al 

mov ax,cs 

mov ds,ax 

mov [FAILURE],1 

mov dx,03CEH 

mov a(,5 

out dx,al 

mov dx,03CFH 


address of interrupt mask register 
initial interrupt mask 
set mask 


indicate we have a failure 
aaa straighten out display 


300 - 













Distributed Issues Final Report 


mov 

al,0 

out 

dx,al 

call 

Set_Display 

lea 

si,NET_ERR0R 

cal l 

Print 

jmp 

Error_Restart 


; make sure display of all bits 


; GetMaster 



Get_Haster: 



push 

ds 


mov 

ax,cs 


mov 

ds,ax 


mov 

ax,[MASTER] 


pop 

ds 


retf 



; Get_Rockets 



Get_Rockets: 



push 

ds 


mov 

ax.cs 


mov 

ds, ax 


mov 

ax, [NUM ROCICETS] 


pop 

ds 


retf 






; Get_Targots 



Get_Targets: 



push 

ds 


mov 

ax r cs 


mov 

ds,ax 


mov 

ax,[NUM_TARGETS] 


pop 

ds 


retf 



; Get_Tasks 



Get_Tasks: 



push 

ds 


mov 

ax,cs 


mov 

ds,ax 


mov 

ax,(NUM_TASKS) 


pop 

ds 


retf 



; PRINT - print 

string pointed to by SI until null 



- 301 - 

















Distributed Issues Final Report 


8tos_wRire 

PAGE_SELECT 

COLOR 

UINDOW_TOP 
UI NDOW_BOT T OM 
SCROLL 

CLEAR_OISPLAY 

GETCURSOR 

SETCURSOR 

cr 

If 

bs 

index_reg 

display_select 

modeO 

mask_select 
mask_bits 
sequence_reg 
map_mask 


Set_Oisplay 


Set_0isplay: 

test 

jnz 

ret 

Set_0isplay10: 

mov 

pushf 

call 

mov 

mov 

mov 

mov 

pushf 

cal l 

ret 

; mov 

; mov 

; out 

; inc 

; mov 

; out 


equ 

09h 

; write color/attribute 

equ 

0 


equ 

1 f H 

; background blue, forground red 

equ 

OOOOH 

; row=0 col=0 

equ 

184fH 

; row=24 col=79 

equ 

0601H 

; scroll up 1 row 

equ 

0600H 

; scroll 0 = clear screen 

equ 

0300H 


equ 

0200H 


equ 

OOOdH 


equ 

OOOaH 


equ 

0008H 


equ 

03ceH 

; EGA index control register 

equ 

5 


equ 

0 


equ 

8 

; select mask register 

equ 

Of f H 

; turn all bits on 

equ 

03C4H 


equ 

2 



insures that the display bit mask has all bits turned on. 
This is only necessary when switching from bit grahics 
modes where typically only one bit is enabled. 


word ptr [EGAPRESENT],OFFFFH 
Set_Display10 


ax, 2 

dword ptr [BIOS_VIOEO] 

ax,CLEAR_01 SPLAY 
cx,UlNDOW_TOP 
dx,UINDOW_BOT T OM 
bh,COLOR 

; push flags (simulate INT 10H) 

dword ptr tB!OS_VlDEO] 


dx,index_reg 
al,display_select 
dx,al 

dx ; point to data register 

al,modeO 
dx,al 


- 302 - 








Distributed Issues Final Report 


mov 

dx,index_reg 


mov 

al,mask_select 


out 

dx,al 


inc 

dx 

; point to data register 

mov 

al,mask_bits 

; set mask 

out 

dx,al 


mov 

dx,sequence_reg 


mov 

al,map_mask 


out 

dx,al 


?nc 

dx 


mov 

al,mask_bits 


out 

dx,al 


i 

ret 

i 

; Print - write text pointed at by SI 

I 

Print: 

cld 

print 10: 

lodsb 

until null (0) is encountered 

or 

al ,al 

; end of string? 

jz 

print_end 


cal l 

Put_Char 

; BIOS all preserves direction flag 

jmp 

PrintIO 



print_end: 

ret 


; Put_Char- writes character in AL on screen 

I 

Put_Char: 

test word ptr [EGA_PRESENT],OFFFFH ; see if screen 

jnz Put_char10 

ret 


Put CharlO: 


push 

ax 

cmp 

al,cr 

jz 

put_char_cr 

cmp 

al, If 

jz 

put_char_lf 

cmp 

al,bs 

jz 

put_char_bs 

mov 

ah,BIOS_WRlTE 

mov 

bh,PAGE_SELECT 

mov 

bl,COLOR 

mov 

cx,1 

pushf 



; Carriage return? 
; line feed 
; back space 


select page 
set color 
1 character 

push flags (simulate INT 10H) 


- 303 - 









Distributed Issues Final Report 


cal l 

dword ptr [BI0S_V!DE0] 


mov 

ax.GETCURSOR 


mov 

bh,PAGE_SELECT 


pushf 

call 

duord ptr (BI0S_VIDE01 


mov 

ax.SETCURSOR 


mov 

bh,PAGE_SELECT 


inc 

dl 

; move cursor over 

pushf 

call 

dword ptr 18I0S_VIDE0] 


jmp 

Put_Char_end 


put_char_cr: 

mov 

ax.GETCURSOR 


mov 

bh,PAGE_SELECT 


pushf 

call 

dword ptr IBIOSVIDEO] 


mov 

ax.SETCURSOR 


mov 

bh,PAGE_SELECT 


mov 

dl ,0 

; reset colum 

pushf 

call 

dword ptr IBIOSVIDEO] 


jmp 

Put_char_end 


put_char_lf: 

mov 

ax.GETCURSOR 

; see if at bottom of screen 

mov 

bh,PAGE_SElECT 


pushf 

call 

dword ptr [BI0S_VIDE0] 


cmp 

dh,24 

; at bottom? 

jz 

put_char_lf10 


inc 

dh 

; if not at bottom of screen. 

mov 

ax.SETCURSOR 

; down 1 more line 

mov 

bh,PAGE_SELECT 


pushf 

cal l 

dword ptr [BI0SJ/IDE0] 


jmp 

Put_char_end 


put_char_lf10: 

mov 

ax,SCROLL 

; if at bottom, then scroll 

mov 

cx,WIND0W_T0P 


mov 

dx,WINDOW_BOTTOM 


mov 

bh,COLOR 


pushf 


; push flags (simulate INT 

call 

dword ptr [BI0S_VIDE0] 


jmp 

Put_char_end 



put_char_bs: 


go 


- 304 - 





Distributed Issues Final Report 


mov 

ax.GETCURSOR 


mov 

bh,PAGE_SELECT 


pushf 

call 

dword ptr [BIOS 

_VIDEO] 

mov 

ax.SETCURSOR 


mov 

bh,PAGE_SEL£CT 


or 

dl.dl 

; see if already at left marg 

jz 

put_char_bs2 


dec 

dl 

; adjust colum 

pushf 



call 

dword ptr IB IOS 

VIDEO] 

put_char_bs2: 



iP 

Put_char_end 


put_char_end: 



pop 

ax 


ret 



GETJCB 

equ 0 

; read character (synchronous 

Get_Char: 



mov 

ax.GETKB 


pushf 

call 

dword ptr [BIOS 

_KB] 

ret 



• 

; Accepts a number from console 

; Returns 

with AX having 

value (0 if blank line entered) 

Get_Num: 



cal l 

Get_line 


mov 

si,offset UNE_ 

BUFF 

mov 

ax,0 

; init value 

mov 

bx, 10 

; decimal numbers 

mov 

ch,0 

; high byte 

Get_num10: 



mov 

cl,[si] 


inc 

si 


cmp 

cl ,cr 

; see if end of line 

jz 

Get_nun20 


cmp 

cl,' ' 

; also terminate on space 

jz 

Get_num2Q 


cmp 

cl,'0' 


jt 

get_num_error 


cmp 

cl,'9' 


jg 

get_nun_error 


mul 

bx 


and 

cl.OfH 


add 

ax,cx 



- 305 - 





Distributed Issues Final Report 


jmp 

Get_num10 


Get_num_error: 

mov 

si.offset Input_Error 


call 

Print 


jmp 

Get_Num 


Get_num2Q: 

ret 

; Get_Line - 

fetches line from keyboard 

until <CR> is entered 

; returns 

with line in LINE_BUFF terminated by <CR> 

f 

Get_line: 

mov 

si,offset LINE_BUFF 


get_linelO: 

cmp 

si,offset ENO_OF_L1NE 


jz 

get_line_cr ; 

force a <CR> 

call 

Get_Char 


cmp 

al,bs 

backspace? 

jz 

get_line_bs 


cmp 

al ,cr 


jz 

get_line_cr 


mov 

Csi],al 


inc 

si 


call 

Put_Char 


jmp 

get_linelO 


get_line_bs: 

cmp 

si,offset LINEBUFF 


jz 

get_linelO ; 

do nothing if at begin 

call 

Put_Char 


mov 

al,' ' 


cal l 

Put_Char 


mov 

al ,bs 


cal l 

Put_Char 


dec 

si 

back up buffer pointer 

jmp 

get_linelO 


get_line_cr: 

mov 

al ,cr 


mov 

Csi3,a l 


cat l 

Put_Char 


mov 

at,If 


call 

Put_Char 


ret 

i 

; CLEAR - routine to zero some of memory 

to compensate for code 

; generator error. 


Clear: 


- 306 - 











Distributed Issues Finai Report 



- 307 - 



















Distributed Issues Final Report 



db 

' 

THE BORDER DEFENSE 


db 

cr,If,If 



db 

' 0 I S 

TRIBUTED Ada ' 


db 

'COIF 

IGURATION MEN U',cr,lf,lf, l f 


db 

'Type "Y 

'' to continue: ' ,0 

ROCKET_QUES 

db 

cr,If,If, 

'Enter Number Of Rockets=> ',0 

TARGET_QUES 

db 

cr,If,If, 

'Enter Number of Targets 1 ' ',0 

MOOE_QUES 

db 

cr,If,If, 

'SELECT MOOE:',cr,If 


db 

1 

1 = Single Processor',cr,If 


db 

1 

2 = Dual (AB) Processor',cr,If 


db 

t 

3 = Dual (AC) Processor',cr,If 


db 

# 

4 = Triple Processor',cr,If 


db 

'MOOE => 

'.0 

AUT0_QUES 

db 

cr,If,If, 

'Automatic Reconfiguration? (Y) : ',0 

DEIAY_QUES 

db 

cr,If,If, 

'Delay before Reconfiguration? (Y) : ',0 

BAD_ROCKETS 

db 

cr,lf,'Out Of Range!, Rockets must be between 1 and 20' 


db 

cr,If, If, 

'Reenter: ',0 

BAD_TARGETS 

db 

cr,lf,'Out Of Range!, Targets must be between 1 and 50' 


db 

cr,If, If, 

'Reenter: ',0 

BAD_HCX)E 

db 

cr,lf,'0ut Of Range!, Mode must be between 1 and 4' 


db 

cr,If,If, 

'Reenter: ',0 

INPUT_ERROR 

db 

cr,lf,'Invalid Number' 


db 

cr,If,'Reenter: ',0 

NET_ERROR 

db 

If.If.' 

NETWORK TRANSMISSION ' 


db 

'E R R 0 

R DETECTED •',cr,If,If,0 

DELAYMSG 

db 

'SYSTEM WILL RESTART IN FIVE SECONOS...',cr,tf,lf,0 

cseg ends 





sseg 

segment 

STACK 


db 

STACK_SI2E dup (0) 

sseg 

ends 



end 



- 308 - 








Distributed Issues Final Report 


- 309 - 





