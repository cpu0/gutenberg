DTIC FILE COPY 




Fom ,. 

0PM Mb. 0704^188 




1. WE P0HT TYPE AND owes OOWEHED 

Final 28 Nov 89 to 28 Nov 90 


4.7iaEANDMTniE Ada Compiler Validation Summary ^portrApoHo 
Computer Inc., Domain MA, Version 3.0 MBX, DN 4000 (Host; to 

MVME 133A-20 (Target), 891128S1.10234 


•.AUTHGfKS) 

National Institute of Standards and Technology 

Gaithersburg, MD 

USA 


7. PEIVOmM OfnAMZnVN NAItCtq ANOAtXMESS(ES) 

National Institute of Standards and Technology 
National Computer Systems Laboratory 
Bldg. 255, Rm. A266 

Gaithersburg, MD 20899 
USA 


«. SPONSORMOMONnORMQ AOENCY NAME(S) AND A00nESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Washington, D.C. 20301-3081 




lat. OBTRaUTKNirAVMLABUTY STATEMENT 

Approved for public release; di’stfibution unlimited. 


l2k.0BTmBamN000E 


IS. ACSnUCT (MWtiuniOO Non*; 

Apollo Computer Inc., Domain ADA, Version 3.0 MBX, Gaithersburg MD, DN 4000 under Domain 
/OS SR 10.2 (Host) to MVE 133A-20 under N/A (Target), ACVC 1.10. 


DTIC 

S ELECTED 
JUN 27 . 1990 I I 

B 


M.SUUECTTEIMB Ada programming language, Ada Compiler Validation 
Summary Report, Ada Compiler Validation Capability, Validation 
Testing, Ada Validation Office, Ada Validation Facility, ANSI/MIL- 
STD-1815A. Ada Joint Program Office _ 


II. 




UNCLASSIFIED 





!• j.'' iiir 


UNCLASSIFIED 


is.NUMKnaFmaES 


1 I.PMCE 0 a 0 E 


so. UMfTATOHOF A88TNACT 




























AVF Control Number; NIST89AP0585_1.10 
23 January 1990 

DATE VSR MODIFIED PER AVO OCMMENTS: 04-30-90 


Ada CCMPIIER 
VAIilDATiai SUMMARY REPORT: 
Certificate Number: 891128S1.10234 
^xsllo Ccnpuber Inc 
Dcanain ADA, Ver 3.0.MBX 
CN 4000 Ifost and MVME 133A-20 Target 


Completion of On-Site Testing: 
28 Novertiaer 1989 


Pr^jared By: 

Software Standards Validation Group 
National Ccnpxter Systems laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


Pr^ared For; 

Ada Joint Progran Office 
United States Department of Defense 
Washington DC 20301-3081 




Ada Compiler Validation Summary Report: 

Compiler Name: Domain/ADA 
Certificate Number: 891128S1.10234 


Host: DN 4000 under Domain/OS SR 10.2 

Target: MVE 133A-20 under N/A 


Testing Completed 28 Novendjer 1989 Using ACVC 1.10 


This report has been reviewed and is approved. 



/alidation 
Dr. David K. JeJ 
Chief, Information Systems 
Engineering Division 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 



Ada 
Dr. J< 

Instii 
Alexandria VA 


rganlzation 
amer 

Defense Analyses 
22311 



Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 




Ada Validation Fac/lil 
Mr. L. Arnold Jol 
Manager, Software Standards 
Validation Group 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 



Aeoesslon For 

■TIS GRAii 
DTIC TAB 



Unannounced 

Justification 


By- 

Distribution/ 


Availability Codes 



Avail and/or 
Special 


□ □ 




TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 PURPOSE OF THIS VALIDATION SIMMARY REPORT .... 1-2 

1.2 USE OF THIS VALIDATION SlMtARY REPORT.1-2 

1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-3 

1.5 ACVC TEST CLASSES.1-4 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED . 2-1 

2.2 IMPLEMENTATION CHARACTERISTICS . 2-1 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.3-1 

3.2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 WITHDRAWN TESTS.3-2 

3.5 INAPPLICABLE TESTS.3-2 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . .3-6 

3.7 ADDITIONAL TESTING INFORMATION . 3-6 

3.7.1 Prevalidation.3-6 

3.7.2 Test Method.3-6 

3.7.3 Test Site.3-7 

APPENDIX A CONFORMANCE STATEMENT 

APPENDIX B APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 

APPENDIX E COMPILER OPTIONS AS SUPPLIED BY 

Apollo Computer Inc. 


















CHAPTER 1 


INTRODUCTION 



This Validation Summary Report (VSR) describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1^15A. 
This report explains all technical terms used within it and thoroughly 
reports the results o f testing this compiler using the Ada Compiler 
Validation Capability^ACVC)7^An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that 
is not in the Standard. 

Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between 
implementations. The Ada Standard permits some implementation 
dependencies--for example, the maximixm length of identifiers or the 
maximum values of Integer types. Other differences between compilers 
result from the characteristics of particular operating systems, 
hardware, or implementation strategies. All the dependencies obseirved 
during the process of testing this compiler are given in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an .»da compiler and 
evaluating the results. AThe purpose of validating is to ensure 
conformity of the compileJr to the Ada Standard by testing that the 
compiler properly implements legal language constructs and chat it 
identifies and rejects iljlegal language constructs. The testing also 
identifies behavior that ;is implementation dependent, but is permitted 
by Che Ada Standard. Six classes of tests are used. These tests are 
designed to perform checKs at compile time, at link time, and during 
execution. / 



l-I 





1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 


This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 

. To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

. To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

. To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by Gemma Corp under the direction 
of the AVF according to procedures established by the Ada Joint Program 
Office and administered by the Ada Validation Organization (AVO). 

On-site testing was completed 28 November 1989 at Apollo. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO 
may make full and free public disclosure of this report. In the United 
States, this is provided in accordance with the "Freedom of Information 
Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do 
not represent or warrant that all statements set forth in this report 
are accurate and complete, or that the subject compiler has no 
nonconformities to the Ada Standard other than those presented. Copies 
of this report are available to the public from; 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 


Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


1-2 




Questions regarding this report or the validation test results should be 

directed to the AVF listed above or to; 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.3 REFERENCES 

1. Reference Manual for the Ada Programming Language, 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1936. 

4. Ada Compiler Validation Capability User's Guide, December 1986. 

1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to 
the Ada programming language. 

Ada An Ada Commentary contains all Information relevant to 

the Commentary point addressed by a comment on the .“vda 
Standard. These comments are given a unique 
identification number having the form Al-ddddd. 

Ada Standard ANSI/MIL-STD-1815A. February 1983 and ISO 8652-1987. 

Applicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines . 


AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and 
technical support for Ada validations to ensure 


1-3 





consistent practices. 

Compiler A processor for the Ada language. In the context of 

this report, a compiler is any language processor, 
Including cross-compilers, translators, and 
interpreters. 

Failed test An ACVC test for which the compiler generates a result 
that demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 

Inapplicable An ACVC test that uses features of the language that a 

test compiler is not required to support or may legitimately 

support in a way other than the one expected by the 
test. 

Passed test An ACVC test for which a compiler generates the expected 
result. 

Target The computer which executes the code generated by the 

compiler. 

Test A program that checks a compiler's conformity regarding 

a particular feature or a combination of features to the 
Ada Standard. In the context of this report, the term 
is used to designate a single test, which may comprise 
one or more files. 

Withdrawn An ACVC test found to be incorrect and not used to check 

test conformity to the Ada Standard. A test may be 
incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains illegal or 
erroneous use of the ‘anguage. 

1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and Illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name 
identifies the class to which it belongs. Class A, C, D, and E tests 
are executable, and special program units are used to report their 
results during execution. Class B tests are expected to produce 
compilation errors. Class L tests are expected to produce errors 
because of the way in which a program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal 
Ada programs with certain language constructs which cannot be verified 
at run time. There are no explicit program components in a Class A test 
to check semantics. For example, a Class A test checks that reserved 


1-4 





words of another language (other than those already reserved in the Ada 
language) are not treated as reserved words by an Ada .compiler. A Class 
A test is passed if no errors are detected at compile time and the 
program executes to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 

Class B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that every 
syntax or semantic error in the test is detected. A Class B test is 
passed if every illegal construct that it contains is detected by the 
compiler. 

Class C tests check the run time system to ensure that legal Ada 
programs can be correctly compiled and executed. Each Class C test is 
self-checking and produces a PASSED, FAILED, or NOT APPLICABLE message 
indicating the result when it is executed. 

Class D tests check the compilation and execution capacities of a 
compiler. Since there are no capacity requirements placed on a compiler 
by the Ada Standard for some parameters--for example, the number of 
identifiers permitted in a compilation or the number of units in a 
library--a compiler may refuse to compile a Class D test and still be a 
conforming compiler. Therefore, if a Class D test fails to compile 
because the capacity of the compiler Is exceeded, the test is classified 
as Inapplicable. If a Class D test compiles successfully, it is 
self-checking and produces a PASSED or FAILED message during execution. 


Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the 
•Ada Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is 
rejected by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is 
attempted. A Class L test passes if It is rejected at link time--that 
is, an attempt to execute the main program must generate an error 
message before any declarations in the main program or any units 
referenced by the main program are elaborated. In some cases, an 
implementation may legitimately detect errors during compilation of the 
test. 

Two library units, the package REPORT and the procedure CHECK_FILE, 
support the self-checking features of the executable tests. The package 
REPORT provides the mechanism by which executable tests report PASSED, 
FAILED, or NOT APPLICABLE results. It also provides a set of identity 


1-5 






functions used to defeat some compiler optimizations allowed by the Ada 
Standard that would circtimvent a test objective. The procedure 
CHECK_FILE is used to check the contents of text files written by some 
of the Class C tests for Chapter 14 of the Ada Standard. The operation 
of REPORT and CHECK_FILE is checked by a set of executable tests. These 
tests produce messages that are examined to verify that the units are 
operating correctly. If these units are not operating correctly, then 
the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended 
to ensure that the tests are reasonably portable without modification. 
For example, the tests make use of only the basic set of 55 characters, 
contain lines with a maximvun length of 72 characters, use small numeric 
values, and place features that may not be supported by all 
implementations in separate tests. However, some tests contain values 
that require the test to be customized according to 

implementation-specific values--for example, an illegal file name. A 
list of the values used for this validation is provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable 
to the implementation. The applicability of a test to an 
implementation is considered each time the implementation is validated. 

A test that is inapplicable for one validation is not necessarily 
inapplicable for a subsequent validation. Any test that was determined 
to contain an illegal language construct or an erroneous language 
construct is withdrawn from the ACVC and, therefore, is not used in 
testing a compiler. The tests withdrawn at the time of this validation 
are given in Appendix D. 


1-6 


CHAPTER 2 


CONFIGURATION INFORMATION 


2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under 
the following configuration: 


Compiler: 

ACVC Version: 
Certificate Number: 
Host Computer: 

Machine: 
Operating Sy 
Memory Size: 


Domain/ADA, Ver 3.0.MBX 

1.10 

891128S1.10234 

DN 4000 

item: Domain/OS SR 10.2 
12 MB 


Target Computer: 

Machine: MVME 133A-20 

Operating System: N/A 
Memoiry Size: 1 MB 


2.2 IMPLEMENTATION CHARACTERISTICS 

One of the purposes of validating compilers is to determine the behavior 
of a compiler in those areas of the Ada Standard that permit 
implementations to differ. Class D and E tests specifically check for 
such implementation differences. However, tests In other classes also 
characterize an implementation. The tests demonstrate the following 
characteristics: 


2-1 




a. Capacities. 

(1) The compiler correctly processes a compilation containing 
723 variables in the same declarative part. (See test 
D29002K.) 

(2) The compiler correctly processes tests containing loop 
statements nested to 65 levels. (See tests D55A03A..H (8 
tests).) 

(3) The compiler correctly processes tests containing block 
statements nested to 65 levels. (See test D56001B.) 

(4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tests D64005E..G (3 tests).) 


b. Predefined types. 

(1) rhls implementation supports the additional predefined 

types SHORT_INTEGER, TINY_INTEGER, and SHORT_FLOAT in the 
package STANDARD. (See tests B86001T..Z (7 tests).) 


c. Expression evaluation. 

The order in which expressions are evaluated and the time at 

which constraints are checked are not defined by the language. 

While the ACVC tests do not specifically attempt to determine 

the order of evaluation of expressions, test results indicate 

the following: 

(1) None of the default initialization expressions for record 
components are evaluated before any value is checked for 
membership in a component's subtype. (See test C32117A.) 

(2) Assignments for subtypes are performed with the same 
precision as the base type. (See test C35712B.) 

(3) This implementation uses no extra bits for extra precision 
and uses all extra bits for extra range. (See test 
C35903A.) 

(4) No exception is raised when an integer literal operand in a 
comparison or membership test is outside the range of the 
base type. (See test C45232A.) 

(5) C0NSTRAINT_ERR0R is raised when a literal operand in a 
fixed-point comparison or membership test is outside the 


2-2 



range of the base type. (See test C45252A.) 

(6) Underflow is gradual. (See tests C45524A..Z (26 

tests).) 


d. Rounding. 


The method by which values are rounded in type conversions is 
not defined by the language. While the ACVC tests do not 
specifically attempt to determine the method of rounding, the 
test results indicate the following: 


(1) The method used for rounding to integer is round to even. 
(See tests C46012A..Z (26 tests).) 

(2) The method used for rounding to longest integer is round to 
even. (See tests C46012A..Z (26 tests).) 

(3) The method used for rounding to integer in static universal 
real expressions is round to even. (See test C4A014A.) 


e. Array types. 

An implementation is allowed to raise NUMERIC_ERROR or 
CONSTRAINT_ERROR for an array having a 'LENGTH that exceeds 
STANDARD.INTEGER'LAST and/or SYSTEM.MAX_INT. For this 
implementation: 

(1) Declaration of an array type or subtype declaration with 
more than SYSTEM.MAX_INT components raises no exception. 
(See test C36003A.) 


(2) NL'MERIC_ERROR is raised when 'LENGTH is applied to an array 
type with INTEGER'LAST 2 components. (See test C36202A.) 

(3) NUMERIC_ERROR is raised when 'LENGTH is applied to an array 
type with SYSTEM.MAX_INT + 2 components. (See test 
C36202B.) 

(4) A packed BOOLEAN array having a 'LENGTH exceeding 
INTEGER'LAST raises NUMERIC_ERROR when the array type is 
declared. (See test C52103X.) 

(5) A packed two-dimensional BOOLEAN array with more chan 
INTEGER'LAST components raises NUMERIC_ERROR when the array 
objects are declared. (See test C52104Y.) 

(6) A null array with one dimension of length greater than 
INTEGER'LAST may raise NUMERIC_ERROR or CONSTRArNT_ERROR 


2-3 







either vhen declared or cissigned. Alternatively, an 
inplementation may accept the declaration. However, 
lengths must match in array slice assignments. Ihis 
inplementatiOTi raises NUMERIC_ERRDR vhen the array type is 
declared. (See test E52103Y.) 

(7) In assigning one-dimensional array types, the expression is 
evaluated in its entirety before a»JSTRAINr_ERRDR is raised 
vhen checking vhether the expressicxi's subtype is 
cxnpatible with the target's subtype. (See test C52013A.) 

(8) In assigning two-dimensional array types, the ei 5 >ression is 
evaluated in its entirety before CC»ISTRAINr_ERRDR is raised 
vhen checking vhether the e:q)ression's subtype is 
ccnpatible with the target's subtype. (See test CS2013A.) 

f. Discnriminated types. 

(1) In assigning record types with discnriminants, the 
e}q)ression is evaluated in its entirety before 
a»lSTRAINr_ERE»R is raised vhen checdcing vhether the 
expression's subtype is ccrpatible with the target's 
subtype. (See test C52013A.) 


g. Aggregates. 

(1) In the evaluation of a multi-dimensional aggregate, the 
test results indicate that all choices are evalviated before 
checddng against the index type. (See tests C43207A and 
C43207B.) 

(2) In the evaluation of an aggregate cxxrtaining subaggregates, 
all choices are evaluated before being checdced for 
identical bounds. (See test E43212B.) 

(3) OC»JSTRAINr_ERROR is raised after all choices are evaluated 
vhen a bcxind in a non-null range of a non-null aggregate 
cloes not belong to an index subtype. (See test E43211B.) 


h. Pragmas. 


(1) Ihe pragma INURE is si:f:ported for functions or procedures. 
(See tests IA3004A. .B (2 tests), EA3004C. .0 (2 tests), and 
CA3004E..F (2 tests).) 

i. Generics. 

(1) Generic specifications and bodies can be conpiled in 
s^arate ocnpilations. (See tests CA1012A, CA2009C, 
C3^009F, BC3204C, and BC3205D.) 


2-4 





(2) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 

(3) Generic subprogram declarations and bodies can be compiled 
in separate compilations. (See tests CA1012A and CA2009F.) 


(4) Generic library subprogram specifications and bodies can 
be compiled in separate compilations. (See test C.41012A.) 

(5) Generic non-library subprogram bodies can be compiled in 
separate compilations from their stubs. (See test 
CA2009F.) 

(6) Generic package declarations and bodies can be compiled in 
separate compilations. (See tests CA2009C, BC3204C, and 
BC3205D.) 

(7) Generic library package specifications and bodies can be 
compiled in separate compilations. (See tests BC3204C and 
BC3205D.) 

(8) Generic non-library package bodies as subunits can be 
compiled in separate compilations. (See test CA2009C.) 

j. Input and output. 

(1) The package SEQUENTIAL_IO can be instantiated with 
unconstrained array types and record types with 
discriminants without defaults. (See tests AE2101C, 
EE2201D, and EE2201E.) 

(2) The package DIRECT_IO can be instantiated with 
unconstrained array types and record types with 
discriminants without defaults. (See tests AE2101H, 
EE2401D, and EE2401G.) 

(3) Modes IN_FILE and OUT_FILE are supported for SEQUENTIAL_IO. 
(See tests CE2102D..E, CE2102N, and CE2102P.) 

(4) Modes IN_FILE, OUT_FILE, and 1N0UT_FILE are supported for 
DIRECT_IO. (See tests CE2102F, CE2102I..J (2 tests), 
CE2102R, CE2102T, and CE2102V.) 

(5) Modes IN FILE and OUT_FILE are supported for text files. 
(See tests CE3102E and CE3102I..K (3 tests).) 

(6) RESET and DELETE operations are not supported for 
SEQUENTIAL_IO. (See tests CE2102G and CE2102X.) 


2-5 






(7) RESET and DELETE operations are not si;?ported for 
DIRECT_IO. (See tests CE2102K and CE2102Y.) 

(8) RESET and DELETE c^jerations are not supported for text 
files. (See tests CE3102F. .G (2 tests), CE3104C, CE3110A, 
and CE3114A.) 

(9) Overwriting to a sequential file truncates to the last 
element written. (See test CE2208B.) 

(10) Tenporary sequentieil files are given names and deleted vAien 
closed. (See test CE2108A.) 

(11) Tenporary direct files are given names and deleted vAien 
closed. (See test CE2108C.) 

(12) Teirporary text files are given names and deleted viien 
closed. (See test CE3112A.) 


(13) More than one internal file can be associated with each 
external file for sequential files ViAien writing or reading. 
(See tests CE2107A. .E (5 tests), CE2102L, CE2110B, and 
CE2111D.) 

(14) More than one internal file can be associated with each 
external file for direct files vhen writing or reading. 

(See tests CE2107F..H (3 tests), CE2110D and CE2111H.) 

(15) More than one internal file can be associated with each 
external file for text files vhen vnriting or reading. (See 
tests CE3111A..B, (2 tests), CE3111D..E (2 tests), and 
CE3114B.) 


2-6 






CHAPTER 3 


TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 326 tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing except for 
201 executable tests that use floating-point precision exceeding that 
supported by the implementation. Modifications to the code, processing, 
or grading for 10 tests were required to successfully demonstrate the 
test objective. (See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 

A 

B 

TEST 

C. 

CLASS 

D 

? 

L 

TOTAL 

Passed 

129 

1133 

1994 

17 

28 

46 

3347 

Inapplicable 

0 

5 

321 

0 

0 

0 

326 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


3-1 




3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 

z 

_1 

4 

_1 

_i 

__L 

CHAPTER 
8 9 

n 

U TA 

TOTAL 

Passed 

198 

577 

545 

245 

172 

99 

162 

331 

137 

36 

252 

294 

299 

3347 

Inapplicable 

14 

72 

135 

3 

0 

0 

4 

1 

0 

0 

0 

75 

22 

326 

Wdrn 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 

The following 44 tests were withdrawn from ACVC Version 1.10 at the time 
of this validation; 


A39005G 

B97102E 

C97116A 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A84M 

CD2A84N 

CD2B15C 

CD2D11B 

CD5007B 

CD50110 

CD7105A 

CD7203B 

CD7204B 

CD7205C 

CD7205D 

CE2107I 

CE3111C 

CE3301A 

CE3411B 

E28005C 

ED7004B 

ED7005C 

ED7005D 

ED7006C 

ED7006D 






See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of 
features that a compiler is not required by the Ada Standard to support. 
Others may depend on the result of another test that is either 
inapplicable or withdrawn. The applicability of a test to an 
Implementation is considered each time a validation is attempted. A 
test that is inapplicable for one validation attempt is not necessarily 
inapplicable for a subsequent attempt. For this validation attempt, 326 
tests were inapplicable for the reasons indicated; 


a. The following 201 tests are not applicable because they 
have floating-point type declarations requiring more 
digits than SYSTEM.MAX_DIGITS: 


3-2 





C241131. .Y 

(U 

tests) 

C357051. 

■ Y 

(lA 

tests) 

C357061..Y 

(14 

tests) 

C357071. 

.Y 

(14 

tests) 

C357081..Y 

(U 

tests) 

C358021. 

.Z 

(15 

tests) 

C452411..Y 

(1^ 

tests) 

C453211. 

.Y 

(14 

tests) 

C454211..Y 

(U 

tests) 

C455211. 

.Z 

(15 

tests) 

C455241..Z 

(15 

tests) 

C456211. 

.Z 

(15 

tests) 

C456411. .Y 

(U 

tests) 

C460121. 

• Z 

(15 

tests) 


b. C35702B and B86001U are not applicable because this 
implementation supports no predefined type LONG_FLOAT. 

c. The following 16 tests are not applicable because this 


implementation 

does not 

support a 

predefined 

type LONG_INTEGER 

C45231C 

C45304C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001W 


CD7101F 

d. C45531M, C45531N. C45532M, and C45532N are not applicable 

because the fixed point type definitions 

DELTA 2.0**-48 RANGE -0.5 .. 0.5 -2.0**-48 

DELTA 2.0**-47 RANGE -1.0 .. 1.0 -2.0**-47 

DELTA 2.0**-46 RANGE -2.0 .. 2.0 -2.0**-46 

are not supported. 

e. C455310, C45531P, C455320, and C45532P are not applicable 
because the fixed point type definitions 

DELTA 0.5 RANGE -2.0**46 .. 2.0**46 -0.5 
DELTA 1.0 RANGE -2.0**47 .. 2.0**47 -1.0 
DELTA 2.0**46 RANGE -2.0**93 .. 2.0**93 -2.0**46 

are not supported. 

f. B86001Z is not applicable because this implementation supports 
no predefined floating-point type with a name other than FLOAT, 
L0NG_FL0AT, or SHORT_FL0AT. 

g. C86001F is not applicable because, for this implementation, the 
package TEXT_I0 is dependent upon package SYSTEM. These tests 
recompile package SYSTEM, making package TEXT_I0, and hence 
package REPORT, obsolete. 

h. C96005B is not applicable because there are no values of type 
DURATION'BASE that are outside the range of DURATION. 

i. The following tests are not applicable because 'SIZE 
representation clauses for floating-point types are not 
supported: 


3-3 




CD1009C CD2A41A CD2A41B CD2A41E 
CD2A42A..J (8 tests) 

J. The following tests are not applicable because 'SIZE 
representation clauses for derived array types are not 
supported: 

CD2A61I CD2A61J 


k. The following tests are not applicable because 'SIZE 
representation clauses for access types are not 
supported: 

CD2A84B..CD2A84I (8 tests) 

CD2A84K CD2A84L 


1. The following tests are not applicable because 'SIZE 
representation clauses for task types are not supported: 

CD2A91A..CD2A91E (5 tests) 


m. The following tests are not applicable because 'ADDRESS clauses 
for variables of type SYSTEM.ADDRESS are limited in that an 
address clause with a dynamic address Is applied to a variable 
requiring Initialization. In addition, address clauses are not 
supported for tasks. 


CD5003B..CD5003H (7 tests) 
CD5011E CD5011G CD5011M 

CD5012B CD5012E CD5012F 

CD5013S CD5014S CD5014T 


CD5011A CD5011C 
CD5011Q CD5012A 
CD5012I CD5012J 
CD5014V CD5014X 


n. The following tests are not applicable because 'ADDRESS clauses 
for constant types of type SYSTEM.ADDRESS are limited in chat an 
address clause with a dynamic address is applied to a constant 
requiring initialization. 


CD5011B 

CD5011N 

CD5012H 

CD5013H 

CD5014W 


CD5011D 

CD5011R 

CD5012L 

CD5013L 


CD5011F 

CD5012C 

CD5013B 

CD5013N 


CD5011H 

CD5012D 

CD5013D 

CD5013R 


CD5011I 

CD501.1G 

CD5013F 

CD5014U 


o. CE2102D is inapplicable because this Implementation supports 
CREATE with IN_FILE mode for SEQUENTIAL_IO. 

p. CE2102E is inapplicable because this implementation supports 
CREATE with 0UT_F1LE mode for SEQUENTIALIO. 

q. CE2102F is Inapplicable because this implementation supports 
CREATE with INOUT FILE mode for DIRECT 10. 


3-4 





r. CE2102I is inapplicable because this implementation supports 
CREATE with IN_FILE mode for DIRECT_IO. 

s. CE2102J is inapplicable because this implementation supports 
CREATE with OUT_FILE mode for DIRECT_IO. 

t. CE2102N is inapplicable because this implementation supports 
OPEN with IN_FILE mode for SEQUENTIAL_I0. 

u. CE21020 is inapplicable because this implementation supports 
RESET with IN_FILE mode for SEQUENTIAL_IO. 

V. CE2102P is inapplicable because this implementation supports 
OPEN with OUT_FILE mode for SEQUENTIAL_IO. 

w. CE2102Q is inapplicable because this implementation supports 
RESET with OUT_FILE mode for SEQUENTIAL_IO. 

X. CE2102R is inapplicable because this implementation supports 
OPEN with INOUT_FILE mode for D1RECT_I0. 

y. CE2102S is inapplicable because this implementation supports 
RESET with IN0UT_F1LE mode for DIRECT_IO. 

z. CE2102T is inapplicable because this implementation supports 
OPEN with IN_FILE mode for DIRECT_IO. 

aa. CE2102U is inapplicable because this implementation supports 
RESET with IN_FILE mode for DIRECT_IO. 

ab. CE2102V is inapplicable because this implementation supports 
OPEN with OUT_FILE mode for DIRECT_IO. 

ac. CE2102W is inapplicable because this implementation supports 
RESET with OUT_FILE mode for DIRECT_IO. 

ad. CE3102E is inapplicable because text file CREATE with IN_FTLE 
mode is supported by this implementation. 

ae. CE3102F is inapplicable because text file RESET is supported by 
this implementation. 

af. CE3102G is inapplicable because text file deletion of an 
external file is supported by this implementation. 

ag. CE3102I is inapplicable because text file CREATE with OUT_FIT.E 
mode is supported by this implementation. 

ah. CE3102J is inapplicable because text file OPEN with IN_FILE mode 
is supported by this implementation. 


3-5 







ai. CE3102K is inapplicable because text file OPEN with OOT_FTLE 
mode is not si;?:ported by this inplementation. 

aj. CE3115A is ine^licable because this inplementation does not 
si 5 ]port RESET to mode CXrr_FIlE vrtien another internal file is 
associated with the same extemed. file which is (^jened to mode 
IN FII£. 


3.6 TEST, FROCESSING, AND EVAIIIATKai MDDIFICATI(»IS 

It is expected that seme tests will require modifications of code, 
processing, or evaluation in order to cenpensate for legitimate 
iirplementation behavior. Modificatiois are made by the AVF in cases 
where legitimate inplementation bdiavior prevents the successful 
ccaipleticai of an (otherwise) applicable test. Examples of such 
modifications include: adding a length clause to alter the default size 
of a collection; splitting a Class B test into siibtests so that all 
errors are detected; and confirming that messages produced by an 
executable test demonstrate conforming behavior that was not anticipated 
by the test (such as raising one exception instead of another). 

Itodifications were required for 10 tests. 

The follofcdng tests were ^lit beeaxase syntax errors at one point 
resulted in the ocnpiler not detecting other errors in the test; 

B24009A B33301B B38003A B38003B B38009A 
B38009B B41202A B91001H BC1303F BC3005B 

3.7 ADOrnaiAL testing inpopmaticw 
3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 
produced by the Dcroaiiv^ADA, Ver 3.0.MBX cenpiler was submitted to the 
AVF by the applicant for review. Analysis of these results demonstrated 
that the ocnpiler successfully passed all explicable tests, and the 
cenpiler exhibited the eaqaected b^vior on all inapplicable tests. 


3.7.2 Test Method 

Testing of the Donaiiv'ADA, Ver 3.0.MBX ocnpiler using ACVC Version 1.10 
was conducted on-site by a validaticsi team from the AVF. The 
configipation in vhich the testing was performed is described by the 
following designations of hardware and software oonponents: 


Host oenputer: CN 4000 

Host operating system: DcmaiiVOS SR 10.2 


3—6 





Target cxattputer: MVME 133A-20 

Target cperating system: N/A 


A tc^ contadning all tests except for withdrawn tests and tests 
requiring unsupported floating-point precision was taken on-site by the 
validation team for processing. Tests that make use of 
Irplementation-^jecific values were not customized before being written 
to the tape. Tests requiring modifications during the prevalidation 
testing were not included in their modified form on the tape. 


TEST INPOFMAnCN 

Ihe contents of the tape were loaded directly onto the host ccnoputer. 
After the test files were loaded to disk, the full set of tests was 
compiled , linked, and edl executable tests were run on the [K 4000. 

Ihe oonpiler was tested using command scripts provided by ipollo and 
reviewed by the vadidation team. See appendix E for a complete listing 
of the compiler options for this inpleroentation. Ihe compiler options 
invoked during this test were: 

ADA-M (Test File Name) for single file tests 

ADA (Test File Name) and A. ID (Main Test Name) for multiple paurt tests 

Tests were compiled, linked, and executed (as appropriate) using a two 
idattical DN 4000 computers. Test output, compilation listings, and job 
logs were captured on tape and archived at the AVF. Ihe listings 
examined on-site by the validaticai team were also archived. 


3.7.3 itest Site 

Testing was conducted at ipollo Ocmputer Inc. and was completed on 28 
November 1989. 


3-7 






APPENDIX A 


DECLARATION OF CONFORMANCE 


Apollo has submitted the following Declaration of Conformance 
concerning the DN 4000. 


A-1 


APPENDIX A 


Declaration of Conformance 

Customer: 

Ada Validation Facility: 

ACVC Version: 


Apollo Computer, Inc. 


National Institute of Standar ds & Technology 
1.10 


Ada Implementation 
Ada Compiler Name: 
Version: 

Host Computer System: 
Target Computer System: 

Customer’s Declaration 


Domaln/ADA 


V3.0.mbx 


DNAOOO (Operating System * Domaln/OS SR10.2 
MVME 133A-20 (with no Operating System) 



1. the undersigned, representing that ^§»«W3«x>^Kaf no knowledze of 

deuoerate deviations from the Ada Language Standard ANSI/MTL-STD-lSlSA in’' the 
impiemehtauon(s) listed in this declaration. 


Signamre 


> Jc; V 7 ■ ^ Cf 

Date 


.A-1 




APPENDIX B 


APPENDIX F OF THE Ada STANDARD 


The only allowed Implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of the Domain, ADA, Ver 3.0.HBX 
compiler, as described in this Appendix, are provided by Apollo Computer 
Inc. Unless specifically noted otherwise, references in this appendix 
are to compiler documentation and not to this report. 

Implementation-specific portions of the package ST.AND.ARD, which are not 
a part of Appendix F, are; 


package STANDARD is 


type INTEGER is range -2_147 483_648 ..2_147_483_647; 
type SHORT_INTEGER is range ~32_768 .. 32_767; 
type TINY_INTEGER is range -128 ., 127; 

type FLOAT is digits 15 range -1.79769313486232E+308 .. 
1.79769313486232E+308; 

type SHORT_FLOAT is digits 6 range -3.40282E+38 .. 3.40282E+38; 

type DURATION is delta 1.OOOOOOOOOOOOOOE-03 range -2147483.647 

2147483.647; 


end STANDARD; 


B-1 




Apollo Prollmlnary and Confidantlal 


Attachment I 


Appendix F 

Implementation-Dependent Characteristics 


This appendix summarizes the implementation-dependent characteristics of the Domain/ 
Ada Cross-Development System as required by Appendix F of the Ada Reference Manual 
(RM). In particular, this appendix 



Lists the Domain/Ada pragmas and attributes 
Gives the specification for the package SYSTEM 

Lists the restrictions on representation clauses and unchecked type conversions 

Gives the naming conventions for denoting implementation-dependent components 
in record representation clauses 

Gives the interpretations of expressions in address clauses 

Presents the implementation-dependent characteristics of I/O packages 

Presents any additional implementation-dependent features 


The following sections summarize each of these topics. 


F.l Implementation-Dependent Pragmas and Attributes 

This section details the implementation-dependent pragmas and attributes of Domain/Ada. 


Implementation-Dependent Characteristics F-1 






Apollo Prollmlnary and Confidantlal 


F.1.1 Implementation-Dependent Pragmas 

Domain/Ada provides the following pragmas. Some of the entries in this list refer you to 
the chapter or section in this document where you can Hnd additional information about 
the pragma. 

a pragma BUILT_IN may be used in some parts of the code for TEXT_IO, MA- 
CHINE_CODE.~UNCHECKED_CONVERSION, UNCHECKED_DEALLOCA- 
TION, and lower level support packages in STANDARD. It is reserved for use by 
Apollo and is not directly accessible to the user. 

a pragma lMPLICIT_CODE specifies that implicit code generated by the compiler 
is allowed (ON) or disallowed (OFF). You can use this pragma only within the 
declarative part of a machine code procedure. (Refer to Sections 9.9.3 and 11.8 
for more information.) 

a pragma INLINE_ONLY. when used in the same way as pragma INLINE, indi¬ 
cates to the compiler that the subprogram must always be inlined. (This is very 
important for some code procedures.) This pragma also suppresses the generation 
of a callable version of the routine, which saves code space. 

a pragma NO_IMAGE suppresses the generation of the image array used for the 
IMAGE attribute of enumeration types. This eliminates the overhead required to 
store the array in the executable image. 

a pragma NON_REENTRANT takes one argument which can be the name of a 
library subprogram or a subprogram declared immediately within a library package 
spec or body. This pragma indicates to the compiler that the subprogram will not 
be called recursively allowing the compiler to perform specific optimizations. The 
pragma can be applied to a subprogram or a set of overloaded subprograms within 
a package spec or package body. 

• pragma NOT_ELABORATED. which is allowed only within a package specifica¬ 
tion, suppresses elaboration checks for all entities defined within a package, in¬ 
cluding the package specification itself. In addition, this pragma suppresses the 
generation of elaboration code. When using pragma NOT_ELABORATED, you 
must ensure that there are no entities defined in your program that require elabo¬ 
ration. 


F-2 ImpUmtntation-Dtpendent Characttristlcs 




Apollo Prollminary and Confidontial 


a pragma PASSIVE has three forms: 

pragma PASSIVE 

pragma PASSIVE (SEMAPHORE): 

pragma PASSIVE(INTERRUFT. NUMBER): 

This pragma can be applied to a task or task type declared immediately within a 
library package spec or body. It directs the compiler to optimize certain tasking 
operations. It is possible that the statements in the task body will prevent the in¬ 
tended optimization, in these cases a warning will be generated at compile time 
and will raise TASKING_ERROR at run time. 

• pragma SHARE_CODE provides for the sharing of object code between multiple 
instantiations of the same generic procedure or package body. A “parent” ins¬ 
tantiation is created and subsequent instantiations of the same types can share the 
parent's objea code, reducing program size and compilation times. You can use 
the luime pragma SHARE_BODY instead of SHARE_CODE with the same effect. 
(Refer to Section 11.1 for more information.) 

In addition to the pragmas mentioned in the previous list. Domain/Ada expands upon the 
functionality of the following predeHned language pragmas: 

• pragma INLINE is implemented as described in Appendix B of the RM with the 
addition that you can expand recursive calls up to the maximum depth of 8. The 
compiler produces warnings for nestings that are too deep or for bodies that are 
not available for inline expansion. 

• pragma PACK causes the compiler to minimize gaps between components in the 
represenution of composite types. For arrays, the compiler packs components to 
bit sizes corresponding to powers of 2 (if the field is smaller than STOR- 
AGE_UNIT bits). The compiler packs objects larger than a single STOR- 
AGE^UNIT to the nearest STORAGE_UNIT. 

• pragma SUPPRESS is supported in the single parameter form. The pragma ap¬ 
plies from the point of occurrence to the end of the innermost enclosing block. 
You cannot suppress DIVISION^CHECK. The double parameter form of the 
pragma with a name of an object, type, or subtype is recognized, but has no effea 
in the current release. (Refer to Section 9.9.2 for more information.) You can 
use this pragma to suppress elaboration checks on any compilation unit except a 
package specification. 

This implemenution recognizes the following pragmas, but they have no effect in the cur¬ 
rent release: 

• pragma CONTROLLED 

• pragma MEMORY.SIZE 


Implementation-Dependent Characteristics F-3 






Apollo Prollmlnary and Confidantial 


• pragma OPTIMIZE (Refer to the ada -O option for code optimization in Chap¬ 
ter 4.) 

• pragma SHARED 

• pragma STORAGE_UNIT (This implementation does not allow you to modify 
package SYSTEM-by means of pragmas. However, you can achieve the same 
effect by recompiling package SYSTEM with altered values.) 

• pragma SYSTEM_NAME (This implementation does not allow you to modify 
package SYSTEM by means of pragmas. However, you can copy the file sys- 
tem.a from the STANDARD library to a local Domain/Ada library and recompile 
the hie there with the new values.) 

The following pragmas are implemented as described in Appendix B of the RM: 

• pragma ELABORATE 

• pragma LIST 

• pragma PAGE 

• pragma PRIORITY 

F.1.2 Implementation-Defined Attribute: *R£F 

Domain/Ada provides one implementation-deHned attribute, 'REF. You can use this at¬ 
tribute in one of two ways: X’REF and SYSTEM.ADDRESS’REF(AO. You can use 
ATREF only in machine code procedures while you can use SYSTEM.ADDRESS’REF(AO 
anywhere that you want to convert an integer expression to an address. 


F.1.2.1 rREF 

The X’REF attribute generates a reference to the entity to which it is applied. 

In ^TREF, X must be either a constant, variable, procedure, function, or label. The attrib¬ 
ute returns a value of the type MACHINE_CODE.OPERAND, which you can use only to 
designate an operand within a machine code-statement. 

You can precede the instruction generated by the code-sutement in which the attribute 
occurs by additional instructions needed to facilitate the reference (for example, loading a 
base register). If the declarative section of the procedure contains pragma IMPLICIT_ 
CODE (OFF), the compiler will generate a warning if additional code is required. 

References can also cause the generation of run-time checks. You can use pragma SUP¬ 
PRESS to eliminate these checks. 


F-4 Impltmentation-Dependent Characteristics 


Apollo Prollminary and Confidontlal 


C0DE_1' (JS*. PEOC'KF) ; 

CODE_a'(IK)VE_L. X.AU.(2)'1EP. DO): 

For more information on machine code insertions, refer to Chapter 9. 


F. 1.2.2 SYSTEM. ADDRESS'REF(N) 

The effect of SYSTEM.ADDRESS*REF(AO is similar to the effect of an unchecked con¬ 
version from integer to address. However, you should use this attribute instead of an un¬ 
checked conversion in the foilowing circumstances (in these circumstances, N must be 
static): 

• Within any of the run-time configuration packages: 

Use of unchecked conversion within an address clause would require the genera¬ 
tion of elaboration code, but the configuration packages are not elaborated- 

• In any instance where N is greater than INTEGER’LAST: 

Such values are required in address clauses that reference the upper portion of 
memory. To use unchecked conversion in these instances would require that the 
expression be given as a negative integer. 

• To place an objea at an address, use the 'REF attribute: 

The integerj/alue, in the following example, is converted to an address for use in 
the address clause representation specification. The form avoids UNCHECKED_ 
CONVERSION and is also useful for 32-bit unsigned addresses. 

—place an object at an addreaa 

for objtet use at AOOKESS'ltEP (inugtrjralut) 

—to uaa unsifned addreeaee 

for VECTOE use at SYSTEM. ADDRESS'llEr (larsoaooodo#): 

TOP or.MEHORY; SYSTEM.ADDRESS:- SYSTEM.ADDRESS'RXP(16«Prppprrp«); 


In SYSTEM.ADDRESS'REFCAO, SYSTEM.ADDRESS must be the type SYSTEM.AD- 
DRESS. N must be an expression of type UNrVERSAL_INTEGER. The attribute returns a 
value of type SYSTEM.ADDRESS, which represents the address designated by N. 


Implementation-Dependent Characteristics F-S 





Apollo Prollmlnary and Confidantlal 


F.2 Specification of the Package SYSTEM 

vith unsign*d_t]rp«a; paekaf* sySTZM i* 

prapia tuppr*tt(ALL_CHECKS); 
prafi* •uppr*aa(UCEPTlON_TABLCS): 
prafM not_alaboratad; 

typa NAME ia ( APOLLO_CXOSS_BBOOO ); 

SYSTEM.NAUE : conatant NAME :> APOLLO_CROSS_B8000; 

STORACE_UNIT : conatant :> B; 

HEMORY_SIZE : conatant :■ 1B_T7T_218; 

— Syataa-Dapandant Naaad Nuabara 

M1N_INT : conatant :« -2_147_48S_B48; 

MAE_INT : conatant :« 2_147_48S_B47; 

HAX_OICITS : conatant :> IS; 

MAZ.MANTISSA : conatant Si; 

PINE_DELTA : conatant :> 2.0*«(-Sl); 

TICK : conatant ;■ o.oi; 

— Other Syataa-dapandant Daclaratlona 

aubtjrpa PRIORITY ia INTEGER ranfo 0 .. »B; 

MAX_REC_SIZE ; intacar ;> 1024; 

tppa ADDRESS ia priTata: 

function *>* (A: ADDRESS; B; ADDRESS) ratum BOOLEAN; 

function *<* (A; ADDRESS: B: ADDRESS) return BOOLEAN; 

function *>-*(4: ADDRESS; B; ADDRESS) ratum BOOLEAN; 

function ■<-*(A: ADDRESS; B: ADDRESS) return BOOLEAN; 

function *-* (A; ADDRESS: B: ADDRESS) ratum INTEGER; 

function (A; ADDRESS; I: INTEGER) ratum ADDRESS; 

function *-* (A: ADDRESS: I: INTEGER) return ADDRESS; 

function (I; UNSIGNZD_TYPES.UNSIGNED.INTEGER) ratum ADDRESS; 

function HEIfORY.ADDRZSB 

(I; UNSiaNED_TYPES.UNSI<aiED_INTEGER) ratum ADDRESS 
NO_ADDR : constant ADDRESS; 

prirata 


F-d ImpUmentation-Dtptndtnt Characterlsllcs 




Apollo Proliminary and Confidantlal 


trp« ADDRESS it riM UNSICKED_TY?ZS.UNSICNED_INTECER; 

MO.ADDR : conttant ADDRESS :■ 0; 

praCM BUILT_INC>«): 
praSM BUILT_IN(*<*); 
prafaa BUILT.INO-*); 
prafaa BUILT.INCo*); 
prafaa B0H,T_1H(*-’): 
prasaa BUILT_INC>*); 


and SYSTEM: 


F.3 Restrictions on Representation Clauses and Unchecked Type 
Conversions 

This section summarizes the restrictions on representation clauses and unchecked type con¬ 
versions for Domain/Ada. 

We describe the representation clauses that Domain/Ada supports in Chapter 11. 

F.3.1 Representation Clauses 

Domain/Ada supports bit level, length, enumeration, size, and record representation 
clauses. Size clauses are not supported for usks. floating-point types, access types, or 
array types. This implementation supports address clauses for objects except for task ob¬ 
jects and for initialized objects given dynamic addresses. Address clauses for task entries 
are supponed; the specifled value is a UNIX signal value. 

The only restrictiorts on record representation clauses are the following: 

• If a component does not start and end on a storage unit boundary, it must be 
possible to get the component into a register with one move instruction. On an 
MC68000 machine, where longwords surt on even bytes, the component must fit 
into 4 bytes starting on a word boundary. 

• A component that is itself a record must occupy a power of 2 bits. Components 
that are of a discrete type or packed array can occupy an arbitrary number of bits 
subject to the previously mentioned restrictions. 

F.3.2 Unchecked Type Conversions 

This implementation supports the generic function UNCHECKED_CONVERSION with the 
following restriction: 


ImpUmtntation-Dependent Characteristics F-7 


Apollo Prollmlnory and Confidantlal 


a You cannot instantiate the predefined generic function UNCHECKED_CONVER- 
SION with a target type that is an unconstrained array type or an unconstrained 
record type with discriminants. 


F.4 Naming Conventions for Denoting Implementation-Dependent 
Components in Record Representation Clauses 

Record representation clauses are based on the target machine’s word, byte, and bit order 
numbering so that Domain/Ada is consistent with various machine architecture manuals. 
Bits within a STORAGE^UNIT are also numbered according to the target machine manu¬ 
als. This implementation of does not support the allocation of implementation-dependent 
components in records. 


F.5 Interpretations of Expressions in Address Clauses 

This implementation supports the SYSTEM.ADDRESS’REF(A/) summarized in Section 
F.1.2.2. 


F.6 Implementation-Dependent Characteristics of 170 Packages 

Although not required for validation, Domain/Ada implements all of TEXT_IO, SEQUEN- 
TIAL^IO, and DIRECT_IO, allowing programs using a target processor access to the host 
nie system. This support allows transparent access to host Hie system features and permits 
easy debugging of embedded system code. The cross I/O system is implemented by having 
a program on the host computer that receives and executes file system requests issued by 
the urget, and also by having low-level code on the target that sends file system requests 
to the host when the I/O subprograms listed above are called. Both a.run and a.db sup¬ 
port cross I/O from the urget. 

To use any of the cross I/O packages you must add the library CROSS^IO to the library 
search list. 

F.6.1 Instantiations of DIRECT_IO 

Insundations of DIRECT.IO use the value MAX_REC_SIZE as the record size (expressed 
in STORAOE_UNrrs) when the size of ELEMENT_TYPE exceeds that value. For exam¬ 
ple. for unconstrained arrays such as a string where ELEMENT^TYPE’SIZE is very large, 
MAX_REC_SIZE is used instead. You can change MAX_REC_SIZE (deflned in package 
SYSTEM) before instantiating DIRECT_IO to provide an upper limit on the record size. 
The maximum size supported is 1024 * 1024 * STORAOE_UNTT bits. DIRECT_IO will 
raise USE_ERROR if MAX_REC_SIZE exceeds this absolute limit. 


F-8 


ImpUmentcaion-Dtptndtnt Characterisiles 


Apollo Prollmlnory and Confidontlal 


F.6.2 Instantiations of SEQUENTIAL_IO 

Instantiations of SEQUENnAL_IO use the value MAX_REC_SIZE as the record size (ex¬ 
pressed in STORAGE_UNITs) when the size of ELEMENT_TYPE exceeds that value. 

For example, for unconstrained arrays such as STRING where ELEMENT_TYPE'SIZE is 
very large, MAX_REC_SIZE is used instead. You can change MAX_REC_SIZE (defined 
in package SYSTEM) before instantiating INTEGER_IO to provide an upper limit on the 
record size. SEQUENTIAL_IO imposes no limit on MAX_REC_SIZE. 


F.7 Additional Implementation-Dependent Features 

This section details any other features that are specific to this implementation. 

F.7.1 Restrictions on ‘Main’ Programs 

Domain/Ada requires that a ‘main* program must be a non-generic subprogram that is 
either a procedure or a function returning an Ada STANDARD. INTEGER (the predefined 
type). In addition, a ‘main’ program cannot be an instantiation of a generic subprogram. 

F.7.2 Generic Declarations 

Dor^rin/Ada does not require that a generic declaration and the corresponding body be 
pan of the same compilation, and they are not required to exist in the same Domain/Ada 
Ubrary. The compiler generates an error if a single compilation contains two versions of 
the same unit. 

F.7.3 Implementation-Dependent Portions of Predefined Ada Packages 

Domain/Ada supplies the following predefined Ada packages given by the Ada RM C(22) 
in the standard and cross_io libraries: 

a package STANDARD 
a package CALENDAR 
a package SYSTEM 

a generic procedure UNCHECKED.DEALLOCATION 
a generic function UNCHECKED_CONVERSION 
a generic package SEQUENTIAL_IO 
a generic package DIRECT_IO 


Impltmtntation-Deptndent Characteristics F-9 







Apollo Prollmlnary and Confidontlal 


• package TEXT_IO 

• package lO.EXCEPTIONS 

• package LOW_LEVEL_IO 

• package MACHINE_CODE 

F.7.4 Values of Integer Attributes 

Domain/Ada provides three integer types in addition to universaljnteger-. INTEGER, 
SHORT_INTEGER. and TINY_INTEGER. Table F-1 lists the ranges for these integer 
types. 


Table F-1. Domain/Ada Integer Types 


Name of 
Attribute 

Attribute Value 
of INTEGER 

Attribute Value of 
SHORTJNTEGER 

Attribute Value of 
TINYJNTEGER 

SIZE 

32 

16 

8 

FIRST 

-2_147_483_648 

-32.768 

-128 

LAST 

2_147_483_647 

32_767 

127 


F-10 Implementation-Dependent Characteristics 


















Apollo Prollminary and Confidantlal 


F.7.5 Values of Floating-Point Attributes 

Table F-2 lists the attributes of floating-point types. 


Table F-2. Domain/Ada Floating-Point Types 


Name of 

Attribute Value 

Attribute Value 

Attribute 

of FLOAT 

of SHORT_FLOAT 

SIZE 

64 

32 

FIRST 

-1.79769313486232E+308 

-3.40282E+38 

LAST 

1.79769313486232E+308 

3.40282E+38 

DIGITS 

15 

6 

MANTISSA 

51 

21 

EPSILON 

8.88178419700125E-16 

9.53674316406250E-07 

EMAX 

204 

84 

SMALL 

1.94469227433161E-62 

2.58493941422g21E-26 

LARGE 

2.57110087081438E4-61 

1.93428038904620E-t-25 

SAFE_EMAX 

1022 

126 

SAFE SMALL 

1.11253692925360E-308 

5.87747175411144E-39 

SAFE_LARGE 

4.49423283715579E+307 

8.5075511654154E+37 

MACHINE_RADIX 

2 

2 

MACHINE.MANTISSA 

53 

24 

MACHINE_EMAX 

1024 

128 

MACHINE_EMIN 

-1022 

-126 

MACHINE_ROUNDS 

TRUE 

TRUE 

MACHINE OVERFLOWS 

TRUE 

TRUE 


Implementation-Dependent Characteristics F-11 























Apollo Prollminary and Confidontlal 


F.7.6 Attributes of Type DURATION 

Table F-3 lists the attributes for the flxed-point type DURATION. 


Table F-3. Attributes for the Fixed-Point Type DURATION 


Name of 

Attribute Value 

Attribute 

for DURATION 

SIZE 

32 

FIRST 

-2147483.648 

LAST 

2147483.647 

DELTA 

l.OOOOOOOOOOOOOOE-03 

MANTISSA 

31 

SMALL 

l.OOOOOOOOOOOOOOE-03 

LARGE 

2.14748364700000E-I-06 

FORE 

8 

AFT 

3 

SAFE SMALL 

l.OOOOOOOOOOOOOOE-03 

SAFE_LARGE 

2.14748364700000E+06 

MACHINE_ROUNbS 

TRUE 

MACHINE^OVERFLOWS 

TRUE 


F.7.7 Implementation Limits 

Character Set: Domain/Ada provides the full graphicj:haracter textual representation for 
programs. The character set for source files and internal character representations is AS¬ 
CII. 

Lexical Elements, Separators, and Delimiters: Domain/Ada uses normal Domain/OS I/O 
text files as input. Each line is terminated by a newline character (ASCII.LF). 

Source File Limits: Domain/Ada imposes the following limitations on source files: 

a 499 characters per source line 
a 1296 Ada units per source file 
a 32767 lines per source file 


F-12 Implementation-Dependent Characteristics 





Apollo Praliminaiy and Confidantlal 


Compiler/Tool Limits: Domain/Ada imposes the following limits on the use of the 
Domain/Ada compiler: 

a 499 characters in identifiers and literals 

• 4,000.000 STORAGE UNITS in a statically sized record or array 

a 10,240 bytes as the storage size default for a task (if tasks need larger or smaller 
stack sizes, the ’STORAGE_SIZE attribute may be used with the task type decla¬ 
ration) 

a 400 bytes as the STORAGE_SIZE default collection size for access type 
a No limit on the number of declared objects (except virtual space) 
a 800 characters in a rooted name (full pathname of an object) 
a 8 recursive inlines 
a 8 nested inlines 
a 400 nested constructs 

a 2048 characters in ADAPATH (library search list) 
a 2048 characters in a WITH or INFO directive 

a 16M of memory use [>er compilation (other Domain/OS limits may apply) 
a 50 lexical errors before the front end exits 
a 100 syntax errors before the front end exits 
a 10 attempts to lock GVAS_.table 
a 10 attempts to lock ada.Iib 
a 20 attempts to lock gnrx.lib 
a 64 debugger breakpoints 
a 32 debugger array dimensions in a p command 
a 9 debugger ‘call parameters’ 
a 256 debugger ‘run parameters’ 

-S- 


ImpUmeniation-Dependent Characteristics F-13 






APPENDIX C 


TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, 
such as the maximum length of an input line and invalid file names. A 
test that makes use of such values is identified by the extension .TST 
in its file name. Actual values to be substituted are represented by 
names that begin with a dollar sign. A value must be substituted for 
each of these names before the test is run. The values used for this 
validation are given below. 


C-1 




- MACRO.DFS 


— THIS FILE CONTAINS THE MACRO DEFINITIONS USED IN THE ACVC TESTS. 

— THESE DEFINITIONS ARE USED BY THE ACVC TEST PRE-PROCESSOR, 

— MACROSUB. MACROSUB WILL CALCULATE VALUES FOR THOSE MACRO SYMBOLS 

— WHOSE DEFINITIONS DEFEND ON THE VALUE OF MAX_IH LEN (NAMELY, THE 

— VALUES OF THE MACRO SYMBOLS BIG IDl, BIG_ID2, BIG ID3, BIG_ID4, 

— BIG_STRING1, BIG STRING2, MAX_SfRING_LITERAL, BIG“iNT_LIT, 

— BIG_REAL_LIT, MAX_LEM_INT BASED_LITERAL, MAX LEN_RBAL_BASED_LITERAL, 

— AND BLANKS). THEREFORE, ANY VALUES GIVEN IN"tHIS FILE FOR THOSE 

— MACRO SYMBOLS WILL BE IGNORED BY MACROSUB. 

— NOTE: THE MACROSUB PROGRAM EXPECTS THE FIRST MACRO IN THIS FILE TO 

BE MAX_IN_LEH. 

— EACH DEFINITION IS ACCORDING TO THE FOLLOWING FORMAT: 

— A. A NUMBER OF LINES PRECEDED BY THE ADA COMMENT DELIMITER, —. 

THE FIRST OF THESE LINES CONTAINS THE MACRO SYMBOL AS IT APPEARS 
IN THE TEST FILES (WITH THE DOLLAR SIGN). THE NEXT FEW "COMMENT" 

LINES CONTAIN A DESCRIPTION OF THE VALUE TO BE SUBSTITXJTED. 

THE REMAINING "COMMENT" LINES, THE FIRST OF WHICH BEGINS WITH THE 
WORDS "USED IN: ■ (NO QUOTES), CONTAIN A LIST OF THE TEST FILES 
(WITHOUT THE .TST EXTENSION) IN WHICH THE MACRO SYMBOL APPEARS. 

EACH TEST FILE NAME IS PRECEDED BY ONE OR MORE BLANKS. 

— B. THE IDENTIFIER (WITHOUT THE DOLLAR SIGN) OF THE MACRO SYMBOL, 

FOLLOWED BY A SPACE OR TAB, FOLLOWED BY THE VALUE TO BE 
SUBSTITUTED. IN THE DISTRIBUTION FILE, A SAMPLE VALUE IS 
PROVIDED; THIS VALUE MUST BE REPLACED BY A VALUE APPROPRIATE TO 
THE IMPLEMENTATION. 

— DEFINITIONS ARE SEPARATED BY ONE OR MORE EMPTY LINES. 

— THE LIST OF DEFINITIONS BEGINS AFTER THE FOLLOWING EMPTY LINE. 

— $MAX IN_LEN 

— AN INTEGER LITERAL GIVING THE MAXIMUM LENGTH PERMITTED BY THE 

~ COMPILER FOR A LINE OF ADA SOURCE CODE (NOT INCLUDING AN END-OF-LINE 

— CHARACTER). 

— USED IN: A26007A 
MAX_IN_LEN 499 

— $BIG IDl 

— AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS $MAX IN LEN. 

— USED IN: C23003A C23003B C23003C B23003D B23003E C23iy03G 

C23003H C23003I C23003J C35502D C35502F 

BIG IDl 

aaaXaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAl 

— $BIG_ID2 

— AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS $MAX_IN_LEN, 

— DIFFERING FROM $BI6 IDl ONLY IN THE LAST CHARACTER. 

— USED IN: C23003A 723003B C23003C B23003F C23003G C23003H 

C23003I C23003J 

BIG ID2 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2 

— $BIG ID3 

— AN TDEHTTFIER IN WHICH THE NUMBER OF CHARACTERS IS $MAX IN LEN. 

— USED IN: C23003A C23003B C23003C C23003G C23003H C23ty03l 

C23003J 

BIG_ID3 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3AAAAAAAAAAAAAAAAAAAAA.V 

aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 





^UUUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 


— $BIG ID4 

— AN IDENTIFXER IN WHICH THE NUMBER OF CHARACTERS IS $MAX_IN_LEN, 

— DIFFERING FROM $BIG_I03 ONLY IN THE MIDDLE CHARACTER. 

— USED IN: C23003A C23003B C23003C C23003G C23003H C23003I 

C23003J 


BIG_ID4 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAA^ 


AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAl 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 


— $BIG_STRING1 

— A STRING LITERAL (WITH QUOTES) WHOSE CATENATION WITH $BIG_STRING2 

— ($BIG_STRING1 & $BIG STRIMG2) PRODUCES THE IMAGE OF $BIG_ID1. 

“ USED IN: C35502D Cl5502F 

BIG_STRING1 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj 
AAAAAAAAAAAAAAAAAAAAAAAAA" 

— $BIG_STRING2 

— A STRING LITERAL (WITH QUOTES) WHOSE CATENATION WITH $BIG_STRING1 

— ($BIG_STRING1 fi $BXG STRING2) PRODUCES THE IMAGE OF $BIG_ID1. 

— USED IN: C35502D CT5502F 

BIG STRING2 

aaaXaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaJ 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA^ 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAl" 

~ $MAX STRIN6_LITERAL 

— A STRING LITERAL CONSISTING OF $MAX IN LEN CHARACTERS (INCLUDING THE 

— QUOTE CHARACTERS). ” “ 

.. USED IN: A26QQ7A 
MAX STRING LITERAL 


AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" 


— $NEG_BASEO INT 

— A BASED INTEGER LITERAL (PREFERABLY BASE 8 OR 16) WHOSE HIGHEST ORDER 
NON'ZERO BIT WOULD FALL IN THE SIGN BIT POSITION OF THE 

— REPRESENTATION FOR SYSTEM.MAX INT, I.E., AN ATTEMPT TO WRITE A 

— NEGATIVE VALUED LITERAL SUCH AS -2 BY TAKING ADVANTAGE OF THE 

— BIT REPRESENTATION. 

— USED IN: E24201A 
NBG_BASED_INT 16«FFFFFFFD« 

$BZG INT LIT 

— AN INnGER LITERAL WHOSE VALUE IS 298, BUT WHICH HAS 

— ($MAX IN LEM - 3) LEADING ZEROES. 

— USED TM;" C24003A 
BIG INT LIT 

0007000700000000000000000000000000000000000000000000000000000000000000000000000000000000000( 

oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooc 

oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooc 

OOOOOOOOOOOOOOOOOOOOOOOOOOOOOQOOOQOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOC 

000000000000000000000000000000000000298 

$BIG REAL LIT 

— A~UNIVERSAL real literal WHOSE VALUE IS 690.0, BUT WHICH HAS 

— ($MAX IN LEM - 5) LEADING ZEROES. 

— USED 7n:~ C24003B C24003C 

BIG REAL LIT 

oooVoooo7ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooc 

oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooc 

oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooc 

oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooc 































,000000000000000000000000000000000069.OEl 


— $MAX LEN INT_BASED_LITERAL 

— A BASED INTEGER LITERAL (USING COLONS) WHOSE VALUE IS 2:11:, HAVING. 

— ($MAX_IN LEN - 5) ZEROES BETWEEN THE FIRST COLON AND THE FIRST 1. 

— USED IN:” C2A009A 

MAX LEN INT BASED LITERAL 

ooo7ooo7ooo?ooooo7ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo( 

oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooc 

oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooc 

oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo 

0000000000000000000000000000000000000000000000000011: 

— $MAX LEN R£AL_BASED LITERAL 

— A BASED REAL LITERAL (USING COLONS) WHOSE VALUE IS 16:F.E:, HAVING 

— ($MAX_IN LEN - 7) ZEROES BETWEEN THE FIRST COLON AND THE F. 

~ USED IN:" C2A009A 

MAX LEN REAL BASED LITERAL 

ooo?ooo7oooo7oooooT^ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo 
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 
ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooj 

OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOF.E: 

— SBLANKS 

— A SEQUENCE OF (SMAX IN LEN - 20) BLANKS. 

— USED IN: B22001A B22701B B22001C B22001D B22001E 

B22001G B22001I B22001J B22001X B22001L 
B22001N 

< LIMITS OF SAMPLE SHOWN BY ANGLE BRACKETS 

BLANKS 


— $MAX DIGITS 

— AN INTEGER LITERAL WHOSE VALUE IS SYSTm.MAX_OIGITS. 

— USED IN: B35701A CD7102B 
MAX_DIGITS 15 

— $NAME 

— THE NAME OF A PREDEFINED INTEGER TYPE OTHER THAN INTEGER, 

— SHORT_INTEGER, OR LONG_INTEGER. 

— (IMPLEMENTATIONS WHICH HAVE NO SUCH TYPES SHOULD USE AN UNDEFINED 

— IDENTIFIER SUCH AS NO SUCH TYPE AVAILABLE.) 

— USED IN: AVAT007 C452?1D B8600Tx 
NAME TINY_IMTEGER 

— $FLOAT_NAME 

— THE NAME OF A PREDEFINED FLOATING POINT TYPE OTHER THAN FLOAT, 

— SHORT FLOAT, OR LONG FLOAT. (IMPLEMENTATIONS WHICH HAVE NO SUCH 

— TYPES~8HOULD USE AH UNDEFINED IDENTIFIER SUCH AS NO SUCH TYPE.) 

— USED IN; AVAT013 B86001Y " ” 

FLOAT_NAME HO_SDCH_FIXED__TYPE 

“ SFIXED_NAME 

— THE NAME OF A PREDEFINED FIXED POINT TYPE OTHER THAN DURATION. 

— (IMPLEMENTATIONS WHICH HAVE NO SUCH TYPES SHOULD USE AN UNDEFINED 

— IDENTIFIER SUCH AS NO SUCH_TYPE.) 

USED IN: AVAT030 B87001Z 

FIXED_NAME NO_SUCH_TYPE 

— SINTEOER FIRST 

— AM INTEGER LITERAL, WITH SIGN, WHOSE VALUE IS INTEGER'FIRST. 

— USED IN: C35503F B54B01B 

INTEGBR_FIRST -2147483648 

— IINTEGER LAST 

— AH INTEGER LITERAL WHOSE VALUE IS INTEGER'LAST. 

— USED IN: C35503F B45232A B45B01B 


B22001F 

B22001M 

> 







JNTEGER_LAST 2147483647 

— $INTEGER_LAST_PLUS_1 

— AN INTEGER LITERAL WHOSE VALUE IS INTEGER'LAST 1. 

— USED IN: C45232A 
INTEGER_LAST_PLUS_1 2_147_483_648 

— SMIN INT 

— AN INTEGER LITERAL, WITH SIGN, WHOSE VALUE IS SYSTEM.MIN INT. 

— THE LITERAL MUST NOT CONTAIN UNDERSCORES OR LEADING OR TRAILING 

— BLANKS. 

— USED IN: C35503D C35503r CD7101B 

MIN_INT -2147483648 

— $MAX INT 

— AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX_INT. 

— THE LITERAL MUST NOT INCLUDE UNDERSCORES OR LEADING OR TRAILING 

— BLANKS. 

— USED IN: C3S503D C35503P C4A007A CD7101B 

MAX_INT 2147483647 

— $MAX_1NT PLUS_1 

— AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX INT + 1. 

— USED IN: C45232A 
MAX_INT_PLUS_1 2_147_483_648 

— SLESSJTHAN DURATION 

— A REAL LITERAL (WITH SIGN) WHOSE VALUE (NOT SUBJECT TO 

— ROUND-OFF ERROR IF POSSIBLE) LIES BETWEEN DURATION'BASE'FIRST AND 

— DURATION'FIRST. IF NO SUCH VALUES EXIST, USE A VALUE IN 

— DURATION'RANGE. 

— USED IN: C96005B 
LESS_THAN_DURATION -100^000.0 

— SGREATER THAN DURATION 

~ A REAL LITERAL WHOSE VALUE (NOT SUBJECT TO ROUND-OFF ERROR 
~ IF POSSIBLE) LIES BETWEEN DURATION'BASE'LAST AND DURATION'LAST. IF 

— NO SUCH VALUES EXIST, USE A VALUE IN DURATION'RANGE. 

— USED IN: C96005B 
GREATER__THAN_DDRATION 10 0_000.0 

— $LESS_THAN_DURATION_BASE_FIRST 

— A REAL LITERAL (WITH SIGN) WHOSE VALUE IS LESS THAN 

— DURATION'BASE'FIRST. 

— USED IN: C96005C 

LESS_THAN_DURATIOM_BASB_FIRST -10_000_000.0 

— SGREATER TRAN OURATION_BASE LAST 

— A REAL LITERAL WHOSE VALUE IS GREATER THAN DURATION'BASE'LAST. 

— USED IN; C96005C 

GREATER_THAN^DURAT10N__BASE_LAST 10_000_000.0 

— SCOUNT LAST 

— AN INTEGER LITERAL WHOSE VALUE IS TEXT lO.COUNT'LAST. 

— USED IN; CE3002B ~ 

COUNT__LAST 2_147_483_647 

— SFXELD LAST 

— AN INTEGER LITERAL WHOSE VALUE IS TEXT lO.FIELD'LAST. 

~ USED IN; CE3002C 

FIELD_LAST 2_147_483_647 

— $ILLEGAL_EXTERMAL_FILE_NAME1 

— AM ILLEGAL EXTERNAL FILE NAME (E.G., TOO LONG, CONTAINING INVALID 

— CHARACTERS, CONTAIMIMQ WILD-CARD CHARACTERS, OR SPECIFYING A 

— NONEXISTENT DIRECTORY). 

— USED IN: CE2103A CE2102C CE2102H CE2103B CE3102B CE3107A 
ILLEaAL_EXTERllAL_riLE_HAMEl /illegal/fil#_n«n«/2(]S%2102C.DAT 

— <ILLEGAL_EXTERMAL FILE NAME2 

— AN ILLE<^ EXTERN^ FIU NAME, DIFFERENT FROM ^EXTERNAL FILE NAMEl. 

~ USED IN: CE2102C CE2102H CE2103A CE2103B “ ~ 





,ILLEGAI._EXTBRNAL_riLE_NAME2 /illegal/file_name/CE2102C* .DAT 

— $ACC_S1ZE 

— AN INTEGER LITERAL WHOSE VALUE IS THE MINIMUM NUMBER OF BITS 

— SUFFICIENT TO HOLD ANT VALUE OF AN ACCESS TYPE. 

— USED IN: CO1C03C C02A81A CD2A81B CD2A81C CD2A81D CD2A81E 

C02A81F C02A81G CD2A83A C02A83B CD2A83C C02A83E 

CD2A83F CD2A83G ED2A86A C02A87A 

ACC_SIZE 32 

~ $TASK_SIZB 

— AN INTEGER LITERAL WHOSE VALUE IS THE NTBIBER OF BITS REQUIRED TO 

— HOLD A TASK OBJECT WHICH HAS A SINGLE ENTRY WITH ONE INOUT PARAMETER. 

— USED IN: CD2A91A CD2A91B CD2A91C C02A91D CD2A91E 

TASK_SIZE 32 

— $MIN_TASK SIZE 

— AN INTEGER LITERAL WHOSE VALUE IS THE NUMBER OF BITS REQUIRED TO 

— HOLD A TASK OBJECT WHICH HAS NO ENTRIES, NO DECLARATIONS, AND "NULL;" 

— AS THE ONLY STATEMENT IN ITS BODY. 

— USED IN: C02A95A 
MIN_TASK_SIZB 32 

— $NAMB_LIST 

— A LIST OF THE ENUMERATION LITERALS IN THE TYPE SYSTEM.NAME, SEPARATED 

— BY COMMAS. 

— USED IN: CD7003A 

— .XXXX change to your system name 

NAME_LIST APOLLO_CROSS_6800T^ 

~ $DEFAULT_SYS_NAME 

THE VALUE OF THE CONSTANT SYSTEM.SYSTEM NAME. 

— USED IN: CD7004A CD7004C CD7004D ” 

.XXXX change to your system name 

DEFAULT_SYS_NAME APOLLO_CROlS_68000 

— SNBW SYS NAME 

A VATUE 5F the type system.name, other THAN SDEFAULT SYS NAME. IF 

— THERE IS ONLY ONE VALUE OF THE TYPE, THEN USE THAT V^UET 

— NOTE: IF THERE ARE MORE THAN TWO VALUES OF THE TYPE, THEM THE 

— PERTINENT TESTS ARE TO BE RUN ONCE FOR EACH ALTERNATIVE. 

— USED IN: ED7004B1 

.XXXX change to your system name 

HEW_SYS_NAME APOLLO_CBOSS_6lOOO 

— SDEFAULT STOR UNIT 

AN INTEGER LIBERAL WHOSE VALUE IS SYSTEM.STORAGE UNIT. 

USED IN: CD7005B EO7005D3M CD7005E " 

DEFAULT_STOR_UNIT 8 

— 8MEW_STOR UNIT 

— AM INnGER LITERAL WHOSE VALUE IS A PERMITTED ARGUMENT FOR 

— PRAGMA STORAGE UNIT, OTHER THAN SDEFAULT STOR UNIT. IF THERE 

— IS NO OTHER PERMITTED VALUE, THEN USE Tl£ VAL% OF 

» 8SYSTEM.STORAGE UNIT. IF THERE IS MORE THAN ONE ALTERNATIVE, 

— THEN THE PERTIM&IT TESTS SHOULD BE RUM ONCE FOR EACH ALTERNATIVE. 

— USED IN: BD7005C1 BD700SD1 CD7005E 
HEW__STOR_UNIT 8 

— 8DEFAULT MEM SIZE 

AM INTEGER LTtERAL WHOSE VALUE IS SYSTEM.MEMORY SIZE. 

— USED IN: CD7006B ED7006D3M CD7006E 

— .XXXX insert your system.memory size 

DBFAULT_MEM_SIZE 16_777_216 

— IMEW^MBM SIZE 

— AN INTEOiR LITERAL WHOSE VALUE IS A PERMITTED ARGUMENT FOR 

-*• PRAGMA MEMORY SIZE, OTHER THAN SDEFAULT MEM SIZE. IF THERE IS NO 

— OTHER VALUE, THEN USB SDEFAULT MEM SIZE? IF THERE IS MORS THAN 

— «IX ALTERNATIVE, THEN THE PBRTlNBMf TESTS SHOULD BE RUM ONCE FOR 

— BACH ALTERNATIVE. IF THE NUMBER OF PERMITTED VALUES IS LARGE, THEM 

— SEVERAL VALUES SHOULD BE USED, COVERING A WIDE RANGE OF 


~ POSSIBILITIES-. 

— USED in: ED7006C1 ED700601 C07006E 

NEN_MBM_SIZE 16_777_216 

— SLOW PRIORITY 

— AN INTEGER LITERAL WHOSE VALUE IS THE LOWER BOUND OF THE RANGE 
~ FOR THE SUBTYPE SYSTEM.PRIORITY. 

— USED in: CD7007C 

low_priority 0 

— $HIGH_PRIORITY 

— AN INTEGER LITERAL WHOSE VALUE IS THE UPPER BOUND OF THE RANGE 

— FOR THE SUBTYPE SYSTEM.PRIORITY. 

— USED IN: CD7007C 
HIGH_PRIORITY 99 

— $MANTISSA_DOC 

— AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX_MANTISSA AS SPECIFIED 

— IN THE IMPLEMENTOR'S DOCUMENTATION. 

— USED IN; CD7013B 

MANTISSA_DOC 31 

— $DELTA_DOC 

— A REAL LITERAL WHOSE VALUE IS SYSTEM. FINE DELTA AS SPECIFIED IN THE 

— IMPLEMENTOR'S DOCUMENTATION. " 

— USED IN; CD7013D 

DELTA_DOC 0.0000000004656612873077392578125 

— STICK 

— A REAL LITERAL WHOSE VALUE IS SYSTEM.TICK AS SPECIFIED IN THE 

— IMPLEMENTOR'S DOCUMENTATION. 

— USED IN; CD7104B 
TICK 0.01 





APPENDIX D 


WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to 
the Ada Standard. The following 44 tests had been withdrawn at the time 
of validation testing for the reasons indicated. A reference of the 
form Al-ddddd is to an .Ada Commentary. 

A39005G 

This test unreasonably expects a component clause to pack an array 
component into a minimum size (line 30). 

B97102E 

This test contains an unintended illegality; a select statement 
contains a null statement at the place of a selective wait alternative 
(line 31). 

C97116A 

This test contains race conditions, and it assumes that guards are 
evaluated indivisibly. A conforming implementation may use interleaved 
execution in such a way that the evaluation of the guards at lines 50 & 
54 and the execution of task CHANGING_OF_THE_GUARD results in a call to 
REPORT.FAILED at one of lines 52 or 56. 

BC3009B 

This test wrongly expects that circular instantiations will be detected 
in several compilation units even though none of the units is illegal 
with respect to the units it depends on; by AI-00256, the illegality 
need not be detected until execution is attempted (line 95). 

CD2A62D 

This test wrongly requires that an array object's size be no greater 
than 10 although its subtype's size was specified to be 40 (line 137). 

CD2.A63A..D, CD2A66A. .D, CD2A73A. .D, CD2A76A..D [16 tests] 

These tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them to a 
derived subprogram (which Implicitly converts them to the parent type 
(Ada standard 3.4:14)). Additionally, they use the 'SIZE length clause 
and attribute, whose interpretation is considered problematic by the WG9 
ARG. 

CD2A81G, CD2A83G, CD2A84M & N, & CD50110 

These tests assume that dependent tasks will terminate while the main 
program executes a loop that simply tests for task termination; this is 
not the case, and the main program may loop indefinitely (lines 74, 85, 
86 & 96, 86 & 96, and 58, resp.). 


D-1 



CD2B15C & CD7205C 

These tests expect that a 'ST0RAGE_SI2E length clause provides precise 
control over the number of designated objects in a collection; the Ada 
standard 13.2:15 allows that such control must not be expected. 

CD2D11B 

This test gives a SMALL representation clause for a derived fixed-point 
type (at line 30) that defines a set of model numbers that are not 
necessarily represented in the parent type; by Commentary AI-00099, all 
model numbers of a derived fixed-point type must be representable values 
of the parent type. 

CD5007B 

This test wrongly expects an implicitly declared subprogram to be at the 
address that is specified for an unrelated subprogram (line 303). 

ED7004B. ED7005C & D, ED7006C & D [5 tests] 

These tests check various aspects of the use of the three SYSTEM 
pragmas; the AVO withdraws these tests as being inappropriate for 
validation, 

CD7105A 

This test requires that successive calls to CALENDAR.CLOCK change by at 
least SYSTEM.TICK; however, by Commentary Al-00201, it is only the 
expected frequency of change that must be at least SYSTEM.TICK -- 
particular Instances of change may be less (line 29). 

CD7203B, & CD7204B 

These tests use the 'SIZE length clause and attribute, whose 
interpretation is considered problematic by the WG9 ARG. 

CD7205D 

This test checks an invalid test objective: it treats the specification 
of storage to be reserved for a task's activation as though it were like 
the specification of storage for a collection. 

CE2107I 

This test requires that objects of two similar scalar types be 
distinguished when read from a file--DATA_ERR0R is expected to be raised 
by an attempt to read one object as of the other type. However, it is 
not clear exactly how the Ada standard 14.2.4:4 is to be interpreted; 
thus, this test objective is not considered valid. (line 90) 

CE3111C 

This test requires certain behavior, when two files are associated with 
the same external file, that is not required by the Ada standard. 

CE3301A 

This test contains several calls to END_OF_LINE & END_OF_PAGE that have 
no parameter: these calls were intended to specify a file, not to refer 
to STANDARD_INPUT (lines 103, 107, 118, 132, & 136). 


D-2 





CE3A11B 

This test requires that a text file's column number be set to COUNT'LAST 
in order to check that LAYOUT_ERROR is raised by a subsequent PUT 
operation. But the former operation will generally raise an exception 
due to a lack of available disk space, and the test would thus encumber 
validation testing. 

E28005C 

This test expects that the string TOP OF PAGE. --63" of line 204 

will appear at the top of the listing page due to a pragma PAGE in line 
203; but line 203 contains text that follows the pragma, and it is this 
that must appear at the top of the page. 


D-3 


APPENDIX E 


Compiler: 
ACVC Version; 


COMPILER OPTIONS AS SUPPLIED BY 
Apollo Computer Inc. 


Domain/.ADA, Ver 3.0. MBX 
1.10 




Attachment II 


Invoking the Domain/Ada Compilen Syntax and Options 


SYNTAX 

ada [options] [source_file] . .. [linkerjtptions] [object _/7/e.o) . . . 


OPTIONS 


-a file_name 

treat file as an ar library. 

-d 

analyze for dependencies only. 

-« 

process compilation error messages using a.error and direct the output to 
stdout. Only source lines containing errors are listed. Use only one -e or -E 
option. 

-E 

-E file 

-E directory 

• 

without a file or directory argument, ada processes error messages using a.er> 
ror and directs a brief output to stdout; the raw error messages are left in 
adajsource.err. If a file pathname is given, the raw error messages are placed 
in that file. If a directory argument is supplied, the raw error output is placed 
in dir/source.err. The file of raw error messages can be used as input to a. er¬ 
ror. Use only one -e or -E option. 

-el 

intersperse error messages among source lines and direct to stdout. 

-El 


-El file 


-El directory 

same as the -E option, except that a source listing file interspersed wiih errors 
is produced. 

-ev 

process raw error messages using a.error and call the environment editor, 
EDITOR on the source file. If EDITOR is undefined, invoke vi. 

-K 

keep the intermediate language (IL) file produced by the compiler front end. 

-\file jibbreviation 

link this library file (no space after -1). 

-M unitjtame 


-M adajsource.a 

produce an executable program using the named unit or source root name as 
the main program. 

-o executableJile 

set output to executableJ’ile; default is a.vox. 

-0(0-9) 

invoke the code optimizer (no space before the digit); an optional digit limits 
the number of passes by the optimizer; without the -0 option, one pass is 


Invoking the Domain/Ada Compiler: Syntax and Options 


1 






Apollo Proliminary and Confidantial 


-R library 

-S 

-sh 

-T 

-V 

-w 


made (default); -OO prevents optimization; -O with no digit specifies maxi¬ 
mum optimization. 

force analysis of all generic instantiations, causing reinstantiation of any that 
are out of date. 

apply pragma SUPPRESS to the compilation. 

display the name of the tool executable but do not execute it. 

print timing information for the compilation. 

print additional information about the compilation. 

suppress warning diagnostics. 


Invoking the DomainlAda Compiler: Syntax and Options 






