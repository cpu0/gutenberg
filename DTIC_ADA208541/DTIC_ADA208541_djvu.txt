AD- 


y 


\ if . 


Lf) 

00 

O 

CM 

< 


; : 

\ -v •- 


UNCLASSIFIED 


SiCUE!''» CLASSIf lO’IOK Of THIS PACt (V^hmD*i* Intereifl 



REPORT DOCUMENTATION PAGE 

■xo iksthl-ctjons 

•tfru : FOP-‘' 

1. RtPORI MUMBfR tZ. tOVl ACCtSSlOA NO. 

3 RECIPIENTS catalog NUMdER 

4. TIHC (trtdSobtitif) 

Ada Compiler Validation Sumrr.ary Report: 

SYSTEAM Ada Compiler VA.Y./VMS Version l.Sl, VA'’ E35n (Vest 
and Tareet), 89013111.100,35 

S. type of report t PERIOD COVERED 

'■<1. .Tan. to ■’1 Van. i'7°^' 

6. performing' t>RG . REPORT NUMBER 

7. AUTHORu; 

lABG, 

Ottobrunn, Federal Republic of Germany. 

e. contract or GRA^T NuMEERdI 

9. PERFORMING ORGANIZATION AND ADDRESS 

lABG, 

Ottobrunn, Federal Republic of Germany. 

K program element, project, task 
AREA ( worn unit numbers 

11. controlling office name and address 

Ada Joint Program Office 

United States Department of Defense 

Washington, DC 20301-3081 

12. REPORT DATE 

13. HJVdIR'DT PAulS 

14. MONITORING AGENCY NAME & AOORESSpf d<FTrrrnt From Conlro»/ng OFTicrl 

lABG, 

Ottobrunn, Federal Republic of Germany. 

IS. security Class (of thif rtponj 
UNCLASSIFIED 

iSe. g^C^ASS^FlCATION.-DOWNGRADING 

K/A 

16. DISTRIBUTION STATEMENT (of tF)(J Rfporti 

Approved for public release; distribution unlimited. 

17. DISTRIBUTION S'A'EmlsT (of trif f nter, pm B/oci rC if aHerenr from Rtportj 

UNCLASSIFIED 

#b FLECTE {» 

IE. supp.ememabi notes wAYiib lyyy J 1 

^(clD ^ 

19 . keywords (Contmuf on rr^frsf ntJf if ntcemry tryb ibrnlity by blO(k rtumbrr) 

Ada Program.T.ing language, Ada Compiler Validation Sumjr.ary Report, Ada 
Compiler Validation Capability, ACVC, Validation Testing, Ada 

Validation Office, AVO, Ada Validation Facility, AVF, AKSI/KIL-STD- 
1815A, Ada Joint Program Office, AJPO 

20. ABSTRACT (Confmti, on rr^rrtf jid, if nrcnury »nO ,0rntify by block number) 

.SYSTEA.M K'f', F'.’F TEA.’^ Ada Compiler ''A'WVF Version l.Bl, IAFFT^ i^ttobrunn, under 

\^.8 Version 4.6 (Vest and Target), ACV . l.in. 





DISCLAIMER NOTICE 


THIS DOCUMENT IS BEST QUALITY 
PRACTICABLE. THE COPY FURNISHED 
TO DTIC CONTAINED A SIGNIFICANT 
NUMBER OF PAGES WHICH DO NOT 
REPRODUCE LEGIBLY. 






AVF Control Nuiiber: AVF-VSR-025 

SZT-AVF-02S 


Aaa COMPILE-? 

VALIOATIQii SUMMARY REPORT: 
CtrtiTicate Number: 89Q131I1. 10025 
STS7EAH KG 

SYSTEAN Ada Compiler VAX/VMS version 1.31 
VAX 8250 Host and Target 


Coraolstion or On-Site Testing: 
21st January 1989 


0’'eparea 3y: 
lABG mbH, Abt SIT 
Einsteinstr 20 
D8012 Ottoorunn 
•est Germany 


^''•oarea For: 

Aaa Joint Program OFF ice 
United States Deoartaent or Defense 
Uastiington DC 20301-2081 



Accesion for 

_ t 

IVTIS CRA&/ 

~~xr 

DTlC TAB 

[] 

U.'iannoiinry^j 

a 

JtJ■ tiCd 



Oi^t 


Akjriciuility Codt; 

Ay.il,• 

Specul 




I 






Ill 


* s 


Ada Compiler Validation Summary Report: 

Compiler Name: SYSTEAM Ada Compiler VAX/VMS version 1.31 
Certificate Number: 89012 1I10035 

Host: VAX 3350 under VKj version 4.6 

Target: VAX 8350 under VMS version 4.6 

Testing Completed 31st January 19B9 Using ACVC 1.10 

This report has bee.n reviewed and is approved. 



Dr. S. Heilbrunner 
insteinstr 20 
8012 Ottobrunn 
Vest Germany 


7 ^ 



rtca ValiOot'on Orgariitaticn 
^ J Q p n r 2 yy\ e p 


Alexandria V A 


■ es e Analyses 



Ada Joint Program Office 
Dr. John Solomcnd 
Director 

Washington D.C. 20301 










s 


Ada Compiler Validation Summary Report: 

Compiler Name: SYSTEAM Ada Compiler VAX/VKS version 1.81 
Certificate Number; 89013111.10035 


Host: VAX 8350 under VMS version 4.6 

Target; VAX 8350 under VMS version 4.6 


Testing Completed 31st January 1969 Using ACVC 1.10 


This report has been reviewed and is approved. 



Einsteinstr 20 
D8012 Ottobrunn 
West Germany 



Ada Joint Program Office 
Dr. John Solomond 
Director 

Washington D.C. 20301 








CONTEI^TS 


CHAPTER 1 INTRODUCTION 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1-1 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.1-2 

1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-3 

1.5 ACVC TEST CLASSES.1-4 


CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED . 2-1 

2.2 IMPLEMENTATION CHARACTERISTICS . 2-2 


CHAPTER 3 TEST INFORMATION 


3.1 TEST RESULTS.3-1 

3.2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 yiTHDRAyN TESTS.3-2 

3 5 INAPPLICABLE TESTS 3-2 

S'.o TEST, PROCESSING, AND'EVALUATION MODIHCATIONS ! ! 3-d 

2,7 ADDITIONAL TESTING INFORMATION . 3-6 

3.7.1 Prevalidation.3-6 

3.7.2 Test Method.3-6 

3.7.2 Test Site.3-7 


APOENDIX A DECLARATION OF CONFORMANCE 

APPENDIX 3 APPENDIX F OF THE Aoa STANDARD 

APDENDIX C TEST PARAMETERS 

APPENDIX D UITHDRAUN TESTS 


APPENDIX E 


COMPILER AND LINKER OPTIONS 





















1 


CHAPTcR 1 
INTRODUCTION 



This Validation Summary Report oescribes the extent to which a 
speci'fic Ada compiler conforms to the Ada Standard, ANSI/HIL-STD-1815A. 
This report explains all tecnnical terms used within it and thoroughly 
reports the results o£. testing this compiler using the Ada Compiler 
Validation Capability. (ACVClr> An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that is 
not in the Standard. 

^Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between implementations. 
The Ada Standard permits some implementation deoendencies--for example, the 
maximum length of identifiers or the maximum values of integer types. 
Other differences between compilers result from the characteristics of 
particular operating systems, hardware, or implementation strategies. All 
the dependencies opserved during the process of testing this compiler are 
given in this report. - 

The information in this report is der’ves from the test results produced 
during validation testing. The va'.ication orocess includes submitting a 
suite of standardiied tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. Tne aurpose of validating is to ensure conformity 
of the compiler to the Ada 5tanaard by testing tnat the compiler properly 
implements legal language constructs and t.hat it identifies and rejects 
illegal language constructs. The testing also identifies behavior tnat is 
implementation dependent, out is permitted oy the Ada Standard. Six 
classes of tests are used. These tests are designed to perform checits at 
compile time, at link time, and during execution. 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 

This VSR documents the results of the validation testing performed on .^n 
Ada compiler. Testing was carried out for the following purposes-' 


1-1 










INT.RCOuC' 


To atteapt to identify any language constructs suDoortsa bv the 
coapiler that do not conform to the Aaa Stanaard 

To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

To determine that the implementation-depenaent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by lABG abH under the direction of 
the AVF according to procedures established by the Ada Joint Program Office 
and administered by the Ada Validation Organization (AVO). On-site testing 
was completed 31st January 1939 at lABG, Ottobrunn, 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO may 
make full and free public disclosure of this report. In the United States, 
this is provided in accordance with the “Freedom of Information Act" 
(5 U.S.C. 4552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject compiler has no nonconformities 
to the Aaa Standard other than those presentee. Copies of this report are 
available to the public from: 

Ada Information Clearinghouse 
Ado Joint Program Office 
OUSDRE 

The Pentagon, Rn 3D-139 (Fern Street! 

Washington DC 20301-3081 

or from: 

lABG mbH, Abt SIT 
£inste i nstr 20 
D8012 Ottobrunn 

Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1-2 






t 


INTRODUCTION 


1.3 REFERENCES 


S£i£csii£fi !!9anual £fic llifi Bcsansisins Ldnauflas. 

ANSI/MIL-S7D-181SA, February 19B3 and ISO 8652-1987. 

Ada QdiDEilfii: vaiidaiian Ensifiducss and Suidfillnas. Ada Joint 

Program OHice, 1 January 1987. 

Ada laiDElIni: vaiidalian CaEadiilix ISBlaifinlecsl fiuide. SofTech, 
Inc., Decemoer 1986. 

Ada CfiffiEilsn yaiidallsn CaEadiili^ ilisrla Saida « December i986. 


1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to the 
Ada programming language. 

Ada An Ada Commentary contains all information relevant to the 

Commentary point addressed by a comment on the Ada Standard. These 

comments are given a unique iaentification number having the 
form Al-ddddd. 

Aoa Stanoara ANSI,mIL-STD-ISISA, February 1983 and ISO 8652-1987. 

Apolicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada ComEligr Vaiidgtion Procgaurgg and 
SiiiafiilDfii. 

AVC The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 

compilers. The AVO provides administrative ana technical 
support for Ada validations to ensure consistent practices. 

Compiler A processor for the Ada language. In the context of this 

report, a compiler is any language processor, including 
cross-compilers, translators, and interpreters. 

Failed test An ACVC test for which the compiler generates a result that 

demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 


1-3 







int.soducti:n 


Inapplicable An ACVC test that uses features of the language that a 
test coipiler is not rsouirsa to support or may leg i t ieiate 1 v 

support in a way other than the one expected oy the test. 


Passed test An ACVC test for wnich 
result. 


compiler generates the expected 


Target 


Test 


U i thorawn 
test 


The computer which executes the code generated the 
compi1er. 

A program that cnecxs a compiler’s conformity regarding a 
particular feature or a combination of features to the Ada 
Standard. In the context of this report, the term is used to 
designate a single test, wnicn may comprise one or more 
files. 

An ACVC test found to be incorrect and not used to check 
conformity to the Ada Standard. A test may be incorrect 
because it has an invalid test objective, fails to meet its 
test objective, or contains illegal or erroneous use of the 
Ianguage. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Aaa programs structured into six test 
classes: A, 8, C, 0, E, and L. The first letter of a test name identifies 
the class to which it belongs. Class A, C, D, and E tests are executable, 
and special program units are usea to report their results during 
execution. Class 0 tests are expected to produce compilation errors. 
Class L tests are expected to proauce errors because of the way in which a 
program librarv is used at link time. 

Class A tests ensure the successful .amoilatinn ana execution of legal Ada 
programs with certain language constructs wnich cannot be verified at run 
time. There are no explicit program components in a Class A test to checx 
semantics. For example, a Class A test checks '.nat reserved woras of 
another language (other than those already reservea in the Aaa language: 
are not treated as reserved words by an Ada compiler. A Class A test is 
passeo if no errors are detected at compile time and the program executes 
to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 
Class 3 tests are not executable. Each test in this class is compiled and 
the resulting compilation listing is examined to verify that every syntax 
or semantic error in the test is detected. A Class B test is passed if 
every illegal construct that it contains is detected by the compiler. 


1-4 








:N:;?CDiic::cN 


Class C tests check the run ti*e system to ensure that legal Ada programs 
can be correctly comoiled and executed. Each Class C test is self-checking 
and produces a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when it is executed. 

Class D tests check the compilation and execution capacities of a compiler. 
Since there are no capacity requirements placed on a compiler fay the Ada 
Standard for some parameters"for example, the number of identifiers 
permitted in a compilation or the number of units in a library-a compiler 
may refuse to compile a Class D test and still be a conforming compiler. 
Therefore, if a Class D test fails to compile because the capacity of the 
compiler is exceeded, the test is classified as inapplicable. If a Class D 
test compiles successfully, it is self-checking and produces a PASSED or 
FAILED message during execution. 

Class £ tests are expected to execute successfully and cnecx 
implementation-dependent options and resolutions of ambiguities in the Ada 
Standard. Each Class E test is self-checking and proouces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class c tests during compilation. 
Therefore, a Class £ test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is rejected 
by the compiler for an allowable reason. 

Class L tests cneck that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not aiiowed to 
execute. Class L tests are compiled separately and execution is attempted. 
A Class L test passes if it is rejected at link time—that is, an attempt 
to execute the main program must generate an error message before any 
declarations in the main program or any units referenced by the main 
program are elaborated. In some cases, an implementation mav legitimately 
detect errors during compilation of the test. 

Two library units, the package REPORT and the procedure C'HECK.FILE, suooor: 
the self-checking features of the executable tests. The package REPORT 
provides the mechanism by which executable tests report PASSED. 'PILED, or 
NOT APPLICABLE 'esults. It also provides a set of identity 'unctions uses 
to defeat some compiler optimizations allowed oy the Aoa Stanoara that 
would circumvent a test objective. The proceaurs CHECK.FILE is usee to 
cneck the contents of text files written by some of the Class C tests for 
Chapter 14 of the Ada Standard. The operation of REPORT and CHECX_FIL: is 
checked by a set of executable tests. These tests produce messages that 
are examined to verify that the units are operating correctly. If these 
units are not operating correctly, then the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended to 
ensure that the tests are reasonably portable without modification. For 
example, the tests make use of only the basic set of 55 characters, contain 
lines with a maximum length of 72 characters, use small numeric values, and 
place features that may not be supported by all implementations in separate 
tests. However, some tests contain values that require the test to be 


1-5 









customized according to implementat i on-soec i t': c volues--*or example, an 
illegal file name. A list 0 / the values used for this validation is 
provipea in Appenpix C. 

A compiler must correctly process each the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given tor the test or by showing that the test is inapplicable to 
the implementation. The applicability of a test to an implementation is 
consiaereo each time the implementation is validated. A test that is 
inapplicable for one validation is not necessarily inapplicable for a 
subseauent validation. Any test that was determined to contain an illegal 
language construct or an erroneous language construct is withdrawn from the 
ACVC and, therefore, is not used in testing a compiler. The tests 
withdrawn at the time of this validation are given in Appendix D. 


1-6 










CHAPTER 2 

CONFIGURATION INFQRMA"ION 

2.1 CONFIGURATION TESTED 

The candidate compilation system For this validation was tested under the 
following configuration: 

Compiler: SYSTEAM Ada Compiler VAX/VMS version 1.31 
ACVC Version: 1.10 
Certificate Numoer; 89013111.10025 
Host Computer: 

Nac.hine: VAX 3350 

Operating System: VMS Version 

Memory Si:®: 12 Mb 

Targe: Computer: 

Macnine: VAX 3350 

Operating System: VMS Version O-.j 

Memory Size: 12 Mb 


2-1 






, coni;:gura7::n :,nfgrmat:cn 


2.2 IMPLEMENTATION CHARACTESISTICS 

One o-f the purposes of validating compilers is to determine the behavior of 
a compiler in those areas of the Ada Standard that permit implementations 
to differ. Class D and E tests specifically check for such implementation 
differences. However, tests in other classes also characterize an 
implementation. The tests demonstrate the following characteristics: 


a. Capacities. 

(1) The compiler correctly processes a compilation containing 723 
variables in the same declarative part. (See test D29002K.) 

(2) The compiler correctly processes tests containing loop 

statements nested to 65 levels. (See tests D55A03A..H (8 

tests).) 

(3) The compiler correctly processes tests containing block 

statements nested to 65 levels. (See test D56001B.) 

(4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels, (See tests 064005E..G (3 tests).) 


a. Predefined types. 

(1) This implementation supports the additional oredefined tvpes 
SHORT.INTESER, SHOP', .SHORT.INTE3E3, SHORT.FuOAT, LONG.FLOAT 
and LONG LONG fLOAT in the package STANDARD. (See tests 
386001T..Z (7 tests).) 


Expression evaluation. 

The order in wnich expressions are evaluated ana the time at wn;:n 
constraints are cneckea are net defined ov the language. While 
the ACVC tests do not specifically attempt to determine the orcer 
of evaluation of expressions, test results indicate the following: 

(1) None of the default in it ia 1 izat ion expressions for record 
components are evaluated before any value is checked for 
itiemoership in a component's subtype. (See test C32117A.) 

(2) Assignments for subtypes are performed with tne same precision 
as the base type. (See test C35712B.) 


2-2 










.:cNf:.3 jr.a'::n infcrj^ation 


(3) This imp]enentation uses no extra bits for extra precision and 
uses all extra bits for extra range. (See test C35903A.) 

(4) No exception is raised when an integer literal operand in a 
comparison or memoership test is outside the range of the base 
type. (See test C45232A.) 

(5) No exception is raised when a literal operand in a fixed-point 
comparison or membership test is outside the range of the base 
type. (See test C452d2A.) 

(6) Underflow is not gradual. (See tests C45524A..2 (26 tests).1 


Round)ng. 

The method by which values are rounded in type conversions is not 
defined by the language. While the ACVC tests do not specifically 

attempt to determine the method of rounding, the test results 

indicate the following: 

(1) The method used for rounding to integer is round away from 

:ero. (See tests C46012A..Z (26 tests).) 

(2) The method usea for rounaing to longest integer is round away 
from zero. (See tests C46012A..Z (26 tests).) 

(3) The method used for rounding to integer in static universal 

real expressions is round away from zero. (See test C4A014A.) 


Ar"3v types. 

An implementation is allowed to raise NUMESIC_ERROR or 
CGNSTRAINT_£RRCR -or an array having a ’LENGTH that exceeds 
standard . INTEGER’LAST and/or S'fSTEr4..'1AX_INT. 

This implementation evaluates the 'LENGTH of each constrained 
array subtype during elaporation of the type declaration. This 
causes the declaration of a constrained array suptvpe with more 
than INTEGER’LAST (which is eoual to SYSTE.M.MAX.INT for this 
implementation) components to raise CONSTRAINT_ERROR. However the 
optimisation mechanism of this implementation suppresses the 
evaluation of ’LENGTH if no object of the array type is declared 
depending on whether the bounds of the array are static, the 
visibility of the array type, and the presence of local 
subprograms. These general remarks apply to points (1) to (6). 


2-3 








\ CJl’MF.IGiiRATION INFORMATION 


(1) Declaration of an array type or subtype declaration with »ore 
than SYSTEM.MAX_INT components raises no axceotion if the 
bounds of the array are static. (See test C26003A.I 

(2) CONSTRAINT_ERROR is raised when 'LENGTH is applied to an array 
type with INTEGER’LAST + 2 components if the bounds of the 
array are not static and if the subprogram declaring the array 
type contains no local subprograms. (See test C26202A.) 

(3) CONSTRAINT_ERROR is raised wren 'LENGTH is applied to an a^ray 
type with INTEGER’LAST ♦ 2 components if the bounds O'f the 
array are not static and if the subprogram declaring the array 
type contains a local subprogram. (See test C36202B.) 

(4) A packed BOOLEAN array hawing a 'LENGTH exceeding INTEGE.R'LAST 
raises CQNSTRAINT_£RRQR when the array type is declared if the 
bounds of the array are not static and if there are objects of 
the array type. (See test C52102X.) 

(5) A packed two-dimensional BOOLEAN array with more than 

INTEGER’LAST components raises CONSTRAINT.ERROR when the array 
type is declared if the bounds of the array are not static and 
if there are objects of the array type. (See test CS2104Y.) 

(6) A null array with one dimension of length greater than 
INTEGER’LAST may raise NUMERIC.ERROR or CONSTRAINT.ERROR 
either when declared or assigned. Alternatively, an 
implementation may accept the declaration. However, lengths 
must match in array slice assignments. This implementation 
raises CONSTRAINT.ERROR when the array type is declared if the 
Bounds of the array are not static and if there are objects of 
the array type. (See test E52i03Y). 


Discriminates tyoes. 

(1) In assigning record types with discriminants, the expression 
'S not evaluates in its entirety before CONSTRAINT.ERROR is 
raised when checking wnether the expression’s subtype is 
compatible with the target’s suptype. (See test C52013A.) 


g. Aggregates. 

(1) In the evaluation of a multi-dimensional aggregate, the test 
results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 


2-4 










CONFIGURATION INFORMATION 


(2) In the evaluation oF an aggregate containing subaggregates, 
all choices are evaluated bc'fore being checked For identical 
bounds. (See test E43212B.] 

(31 CONSTRAINT.ERROR is raised aFter all choices are evaluated 
when a bound in a non-null range oF a non-null aggregate does 
not belong to an index subtype. (See test E43211B.} 


h. Pragmas. 

(1) The pragma INLINE is supported For Functions and procedures 
(See tests LA3004A..B (2 tests), EA2004C..D (2 tests), and 

CA3004E..F (2 tests).) 


Generics. 

(1) Generic speciFications and bodies can be compiled in separate 
compilations. (See tests CA1012A, CA2009C, CA2009F, BC3204C, 
and BC32DSD.) 

(2) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA30UA.} 

(3) Generic subprogram declarations and bodies can be compiled in 
separate compilations. (See tests CA1012A and CA2009F.) 

(4) Generic library subprogram specifications ana bodies can be 
compiled in separate compilations. (See test CA1012A.) 

(5) Generic non-iibrary subprogram bodies can be compilea in 

separate compilations From their stubs. ;See test CA2009F.) 

(b) Generic package declarations and bodies can be compilea in 

separate compilations. (See tests CAZOO'^C, BC3204C, ana 
BC3205D.) 

C7) Generic library package speciFicat ions and bodies can be 
compiled in separate compilations. (See tests 3C3204C and 
BC320SD.) 

(8) Generic non-library package bodies as subunits can be compilea 
in separate compilations. (See test CA2009C.) 

(?) Generic unit bodies and their subunits can be compiled in 

separate compilations. (See test CA3011A.) 


2-5 









CCNCIGURAriCN INfuRMATIGN 


j. Input and output. 

(1) The package SEQU£NTIAL_IO can be instantiated with 

unconstraineo array types and record types with discriminants 
without oeTaults. (See tests AE2101C, EE2201D, and EE2201E.) 

(2) The package OIRECT_IO can be instantiated with unconstrained 
array types or record types with discriminants without 
de+autts. However, an attempt to create a tile with an 
unconstrained array tvpe raises USE ERROR, (See tests 
AE2101H, EE2401D and EE2401G.) 

(3) Modes IN FILE and OUT FILE are supported tor SEQUENTIAL 10. 
(See tests CE21020..E. CE2102N, ano CE2102P.) 

(4! Modes IN FILE, OUT FILE, and INOUT FILE are supported for 
DIRECT 10. (See tests CE2102F, CE2102I..J (2 tests), CE2102R, 
CE2102T, and CE21Q2V.) 

(5) Modes IN FILE and OUT FILE are supported for text files. (See 
tests CE2102E and C£3l02I..X (3 tests).) 

(b) RESET and DELETE operations are supported for SEQUENTIAL 10. 
(See tests CE2102G and CE2102X.) 

(7) RESET and DELETE operations are supported for DIRECT 10. (See 
tests C£2102X and CEZlOiT.) 

(3) RESET and DELETE operations are supported for text files. 
(See tests C53102F..G (2 tests), CE2104C, CE3110A, ano 

CE3114A.} 

(?i Overwriting to a sequential file truncates to the last element 
written. (See test CE22083.) 



Temporary 

:s:i08A.! 

sequentia 1 

files are not 

given 

names. (See 

test 

Cl; 

Temporary 

CE2108C.) 

d i re 

ct f i 

lies are not 

g i ven 

names. (See 

test 

{ * ? ] 

Temporary 

text 

files 

are net given 

names. 

(See test CE21 

12A.) 

(13) 

More than 
external 

one 

file 

internal file can be associated with 
for sequential files when reading only. 

eacn 

(See 


tests CE2107A..E (5 tests), CE2102L, CE2110B, and CE2111D.) 

(14) More than one internal file can be associated with each 
external file for direct files when reading only. (See tests 
CE2107F..H (3 tests), CE21100 and CE2U1H.) 


2-6 








■: c.\ 


(15) Hore than one internal file can be associated 
external file for text files when '•eading only. 
CE3111A..B, CE3111D..E, CE31148, and CE3115A.) 


. r 1 . CN 

with each 
(See tests 


2-7 






CHAPTER 3 


TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comiirises 3717 tests. When this conpiler was 
tested, 36 tests had been withdrawn because of test errors, and were not 
processed during validation testing. A further 7 tests were withdrawn 
after validation testing. The AVF determined that 113 tests were 
inapplicable to this implementation. All inapplicable tests were processed 
during validation testing. Modifications to the code, processing, or 
grading for 16 tests were required to successfully aemonstrate the test 
objective. (See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptaole 
conformity to the Ada Stanoara. 


3.2 SUMMARY OF TEST RESULTS 3Y CLASS 


RESUL' 


’ESI CLAES 

..T_ 2 ... 


■QTAL 


°assea 

Inapp 1 i cao i e 

Withdrawn 

TOTAL 


12? 113^ 2204 
0 4 112 

1 2 24 

120 1140 2250 


a 

34 


46 3557 

0 11 : 
0 43 

46 3717 


3-1 







TtSJ INFORMATIuN 




3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 

2 

—_3. 

4 

_5. 

_fi.. 

CHAPTER 
7 _ 3 

9 



—12. 

-13- 

.AL 

TOTAL 

Passed 

209 

64 7 

65? 

245 

172 

99 

163 

C 9 

137 

36 

252 

326 

280 

OCC? 
w w w f 

N/A 

3 

9 

? 1 


0 

0 

3 

1 

0 

0 

0 

43 

41 

117 

Udrn 

1 

1 

0 

0 

0 

0 

0 

1 

A 

0 

0 

1 

35 

4 

43 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

371? 


3.4 yiTHDRAUN TESTS 

TLc following 3£, tests were withdrawn from ACVC Version 1.10 at the time of 
this vaiidation: 


A39005e 

B97102E 

3C30093 

CD2A62D 

CD2A63A 

C32A63B 

CD2A83C 

CD2A620 

C32A66A 

CD2A662 

C32A66C 

C02A66D 

C02A73A 

CD2A723 

CD2A73C 

C02A73D 

C32A76A 

C02A76B 

CD2A76C 

C02A76D 

CD2A81G 

CD2A83G 

CD2A34N 

■:32Aa4M 

CD50110 

COCBISC 

C D j <. 0 5 V. 

w U M W W / ^ 

C37105A 

CD7203B 

CDTZOAB 

CD7205D 

CE2107I 

r c 9 1 - • 

V C J 1 • • u 

CE3301A 

CE3411B 

The following 7 

test: were 

wi t.icrawn 

from ACVC 

Version 1.1 

0 after 

vaiid a t i 0 n : 






E-SOOSC 

co:dii3 

ED70043 

' V S.> w ^ 

E37C05D 

ED7006C 

ED7006D 






See Accencix 3 

•or :ne 'sas 

C " t M a *- 5 5 

C 9 3 - 

tests was wi 

t h a r 3 w n . 


2.5 INAPPLICABLE TESTS 

Some tests do not sooiy to ai; compilers because t.hev make use of features 
that a compiler 's not reouireo by the Aaa Stanoard to support. Others may 
depend on the result of another test tnat is either inapplicable or 
withdrawn. The applicability of a test to an imoiementation is considered 
each time a validation is attempted. A test that is inapplicaole for one 
validation attempt is not necessarily inapplicable for a subsequent 
attempt. For this validation attempt, 113 tests were inapplicable for the 
reasons indicated-' 


2-2 










% 


:NrCR:iA:::,N 


a. C241I2U..Y (3 tests) contain lines o-f length greater than 255 
characters, which are not supported by this implementation. 


b. C34007P, C34007S are expected to raise CONSTRAINT.ERROR. This 
implementation optimizes the code at compile time on lines 205 and 
221 respectively, thus avoiding the operation which would raise 
CONSTRAINT.ERROR and so no exception is raised. 


C41401A is expected to raise CONSTRAINT.ERROR for tne evaluation 
of certain attributes, however this implementation derives the 
values from the subtypes of the prefix at compile time, as allowea 
by 11.6(7) LRM. Therefore elaboration of the prefix is not 
involved and CONSTRAINT.ERROR is not raised. 


The following 16 tests are inapplicable because this 


imp1ementat ’or 

does not 

support a preaef 

ined type 

LONG.INTEGER: 

C45231C 

C4S204C 

C4S5fl2C 

C45503C 

C45504C 

C45504F 

C45611C 

C456I3C 

CJ56I4C 

C4S631C 

C4S632C 

C07101f 

B52004D 

CS5B07A 

B55B09C 

BBBOOIW 

C4S531M..P (4 

tests), 

C45532M..P (4 

tests) 

are inapplica 


because 
than 48. 


this implementation has a value of MAX.NANTISSA of less 


C47004A is expectea to raise CONSTRAINT.ERROR whilst evaluating 
the comparison on line 51, but this compiler evaluates the result 
without invoking tne basic operation oua I ificat i on (as allowea by 
11.6(71 L.R.M) which would raise CONSTRAINT.ERROR and so no 
excaotion is raisea. 

386001Y is inacoiicable oecause this imolesentation supports no 
preaefineo fixea-ooint type otner tnan DURATION. 

C36001: is inapoiicsble bscausa. for this implementation, the 
package TEKT.IO is asoencent uDon ooCkaoe 3TSTEH.. These tests 
recompile package SYST-m, maK’ng package TEX’.IO, and hence 
package REPORT, oosoiete. 

C96005H is inaoolicapie necause t.nere are no values of type 
DURATION’SASc that are outsioe the range of DURATION. 

C01009C, CD2A41A,3,E, CD2A42A..J (10 tests) are inapciicafale 
because this implementation imposes restrictions on ’SIZE length 
clauses for floating point types. 


'<. CD2A61I,J are inapplicable because this implementation imposes 
restrictions on ’SIZE length clauses for array types. 


3-3 





TEST- INFORMATION 


l. CD2A71A.,D (4 tests!, C02A72A..D (4 tests), CD2A74A..D (4 tests) 
and CD2A75A..D (4 tests) are inappiicaDie because this 
implementation imposes restrictions on 'SIZE length clauses for 
record types. 

m. CD2A84B..I (6 tests), CD2A64K and CD2Ae4L are inapplicable because 
this inplementation imposes restrictions on 'SIZE length clauses 
for access types. 

n. CE21OZ0 is inapplicable because this implementation supports 

CREATE with IN.FILE mode for SEOUENTIAL.IO. 

0 . CE2102E is inapplicable because this implementation supports 

CREATE with OUT.FILE mode for SEQUENTIAL.IO. 

0 . CE2102F is inapplicable because this implementation supports 

CREATE with INOUT.FILE mode for DIRECT.10. 

q. CE2102I is inapplicable because this implementation supports 

CREATE with IN.FILE mode for OIRECT.IO. 

r. CE2102J is inapplicable because this implementation supports 

CREATE with OUT.FILE mode for DIRECT.IQ. 

s. CEZI02N is inaooMcable because this implementation supports OPEN 
with IN.FILE mode for SEOUENTIAL.IO. 

t. CE210Z0 is inapplicable because this implementation supports RESET 
with IN.-ILE mode for SEOUENTIAL.IO. 

■j. CE2I0ZP ’S inapplicable because this implementation supports OPEN 
with OUT.'ILE mooe for SEQUENTIAL.IQ. 

1 . CE2102Q 'S inapplicable because this implementation supoorts R£:E' 

with OUT.-ILE moae *or SEQUENTIAL.10. 

w. CE2I0ZR is inapplicable because this implementation supports OPEN 
with INCUT.-ILE moae for DIRECT.IQ. 

<■ CE2102S is inaPDiicaple because this implementation supports RESET 

with INOUT.FILE moae for DIRECT.IQ. 

y. CE210Z’’ is inaoDiicabie because this implementation supports OPEN 
with IN.FILE moae ’or DIRECT.IQ. 

z. CEZIOZ'J is inapplicable because this implementation supports RESET 
with IN.FILE moae for DIRECT.IQ. 

aa. CE2I0ZV is inapplicable because this implementation supports OPEN 
with OUT.FILE mode for OIRECT.IO. 


3-4 











TEST INFORMATION 


ab. CE2102V is inapplicable because this i»pIementation supports RESET 
with OUT.FILE BOde for DIRECT_!0. 

ac. CE2107B..E (4 tests), CE2107L, CE2110B and CE2111D are 

inapplicable because multiple internal Files cannot be associated 
with the same external File when one or more Files is writing For 
•sequential Files. The proper exception is raised when multiple 
access is attempted. 


3Q. CE2107G...4 (2 tests), CE211O0. and CEZillH are inapplicable 

because multiple internal tiles cannot be associated with tne same 
external File when one or more Files is writing For direct Files. 
The proper exception is raised when multiple access is attempted. 


ae. 

CEZ106B is inapplicable because. For 

temporary sequential Files have no name. 

this 

implementation, 

aF. 

CE21080 is inapplicable because, 
temporary direct Files have no name. 

For 

this 

implementation, 

sg. 

CE3102E is inapplicable because text 
is supported by this implementation. 

File 

CREATE wi 

th IN.FILE moae 

an. 

CE31Q2F is inapplicable because text 
this implementation. 

File 

RESET is 

supported by 

3 i . 

CE310ZS is inapplicable because text 
File is supported by this imp 1ementat 

File 
i on. 

deletion 

oF an external 

3: . 

CE3102I is inaoolicabie because text File 
moae is supported oy this implementation. 

CREATE 

■wit.n OUT.FILE 

3X . 

3E3102J is inaDoIicable because t:xt 
is supported bv th'S 'mpi ementat ion . 

rile 

OPEN with 

IN.'ILE mode 

5 . . 

353tOZK is inaDclicacie because text 
is not supoortec bv this imolsmentati 

r ' 1 e 

on. 

OPEN with 

OlJT.r ILE moae 


1 nape 1!canie because 
with tne same externa 
text files. The ? r 
is attempted. 


^2 tests), CESlliB. ana Cc3H5A are 
multiple iriternal ^'iles cannot be associates 
File wnen one or more Files is writing f'or 
oper exception is raised wnen multiple access 


an. CE311ZB is inapplicable because, For this implementation, 
temporary text Files have no name. 

30. EE2A01D uses instantiations oF package DIRECT_IO with 
unconstrained array types. This implementation raises USE.ERROR 
upon creation oF such a File. 


3-5 







INFORMATION 


3.6 TEST, PROCESSING. AND EVALUATION MC3IFICATICNS 

It is expected that sone tests will reouire modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases where 
legitimate implementation behavior prevents the successful completion of an 
(otherwise) applicable test. Examples of such modifications include: 
adding a length clause to alter the default size of a collection: splitting 
a Class H test into subtssts so that all errors are detected; and 
confirming that messages produced by an executable test demonstrate 
conforming benavior that was not anticipated by the test (such as raising 
one exception instead of another). 

Modifications were required for 16 tests: 


The following tests were 

spl 

it because 

syntax er-ors 

at one po 

resulted in tne 

compiler 

not 

detect ing 

other errors 

in the test 

B2:003A 

B24009A 


B2’001A 

338003A 

B38009A 

S38009B 

SSIOOIA 


391001H 

BAIIOIE 

BC2001D 

3c:qoie 

3C22C43 


BC3205B 

BC3205DC 

BC3205D1M 


3C3205DC 


Test 3050053 contains an illegal reference to a oacxage. PAKGl, on line 34 
that snouid oe PK31. But the test recognises ail errors and so was 
cansioerea passed. 


3.7 ADDITIONAL TESTING INFORMATION 
3.7.1 Prevai'dation 

°r'or to yaiiaaticn. a set of test "esults ‘or ACVC 7e''s:cn i.iQ proauced 
oy tne SYSTEAM Aaa Compiler VAX/VMS version 1.31 -as sucmittea to the AVF 
by the applicant -or review. Analysis o* these "esults oemonstratea tnai 
the compi1er successfully passed a i! apo 1:cac i e tests. and the c onpi i er 
exhibited the expected be-tavior on all inapciicacie tests. 


3.7.2 Test .Method 

Testing of the SYSTEAM Ada Compiler VAX/VMS version 1.81 using ACVC Version 
1.10 was conducted on-site by a validation team from the AVF, The 
configuration in which the testing was performed is described by the 
following designations of hardware and software components: 


3-6 








% 


. .'ir CRr^AT IC'J 



Host computer: 

Host operating system: 
Target computer: 

Target operating system: 
Compiler: 


VAX 8350 
VMS Version 4.6 
VAX 8350 
VMS Version 4.6 

SYSTEAH Ada Compiler VAX/VMS version 1.81 


A magnetic tape containing all tests except Tor withdrawn tests and tests 
requiring unsupported •? 1 oat i ng-po i nt precisions was taken on-site by tne 
validation team for processing. Tests that make use of 
implementation-specific values were customized before being written to tne 
magnetic tape. Tests requiring modifications during the preva1idation 
testing were included in their modified form on the magnetic tape. 

The contents of the magnetic tape were loaded directly onto the host 
computer. 


After the test files were loaaed to disk, the full set of tests was 
compiled , linked, and all executable tests were run on the VAX 3250. 
Results were printed from the host computer. 


The compiler was tested using command scripts provided by SYSTEAM XS ano 
reviewed by the validation team. The compiler was invoked using the 
u oinn)3 n d 


aADA:CaMPILE <test_name; 

-or all tests except those requiring a listing, wnich were compiled using 
the commana 

iA0A:C0MPILE <test.narae> 0PTI0 N£=l:STOCN 
’ests were linked using the command 

aADA:LINK Xtest.name) <test_name> 

-ience. all tests were compiled and linxso with the default octions 'excest 
•‘or the listing option), as listed in appencix E. 

Tests were compiled, linked, and executed las appropriate) using a singie 
computer. Test output, compilation listings, ana job logs were cacturec on 
magnetic tape and archived at the AVF. The listings examined on-s;te ov 
the validation team were also archived. 


3.7.2 Test Site 

Testing was conducted at lABG, Qttobrunn and was completed on 21st January 
1989. 


3-7 








APPENDIX A 

DECLARATION OF CONFORMANCE 


SYSTEAN KG has subrittsd the Following Declaration of 
ConFoPwance concerning the SYSTEAM Aaa Compiler VAX/VMS 
version 1.81. 


A-1 


DECLARATION OF CONFORMANCE 


DECLARATION OF CONFORMANCE 


Compiler Implementor: SYSTEAM KG 

Ada Validation Facility: lABG m. b. H,, Abt. SZT 
Ada Compiler Validation Capability (ACVC) Version 1.10 

BASE CONFIGURATION 

Base Compiler Name: SYSTEAM Ada Compiler VAX/VMS version VI.81 

Host Architecture: VAX 8350 

Host OS and Version: VMS 4.6 

Target Architecture: VAX 8350 

Target OS and Version: VMS 4.6 

Implementor's Declaration 

I, the undersigned, representing SYSTEAM KG Karlsruhe, have 
implemented no deliberate extensions to the Ada Language Standard 
ANSI/MIL-STD-1815A in the compiler (s) listed in t.his declaration. 

I declare that SYSTEAM KG Karlsruhe is the owner of record 
of t.he Ada language compiler (s) listed above and, as such, 
is responsible for maintaining said compiler(s) in conformance 
to ANSI/MIL-STD-1815A. All certificates and registrations for 
Ada language compiler(s) listed in t.his declaration shall be 
made only in the owner's corporate name. 


. , ^ Februarv 27 , 1989 

_ 'C, _ Date:_ * _ 

SYSTEAM KG Dr. Winterstei.n 

Dr. Georg Winterstein, Preside.nt 

Owner's Declaration 

I, the undersigned, represe.nting SYSTEAM KG Karlsrune, take 
full responsibility for implementation a.nd .mai.tte.ta.nce of the 
Ada compiler(s) listed above, and agree to the public disclosure 
of the final Validation Summary Report. I declare that all 
of the Ada language compilers listed, and their hcst/target 
performance, are in compliance with the Ada Language Standard 
ANSI/MIL-STD-1815A. 



SYSTEAM KG Karlsruhe 
Dr. Winterstein 


Date: 


February 27, 1989 







s 


APPENDIX B 

APPENDIX F OF THE Ada STANDARD 


The only allowed imo1eaentation dependencies correspond to 
implementation-depenaent pragmas, to certain macninc-dependent conventions 
as mentioned in chapter 13 oF the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics oF the SYSTEAM Ada Compiler VAX/VMS version l.Bl as 
described in this Appendix, are provided by SYSTEAM KG. Unless 
specifically noted otherwise, references in this appendix are to compiler 
documentation and not to this report. Implementation-specific portions of 
the package STANDARD, which are not a part of Appendix F, are: 


package STANDARD is 


type INTEGc.R is range - 2.147.A83.643 .. :.l-i7_Aa3_b47; 

type SHOST.INTEGER is range - 32.768 .. 32.767; 

tyoe SflORT_SHORT_lNTEGcR is range - 12S .. 127; 

type FLOAT is digits ? 

range - 1640.'FFF FFFF FFFF FF88E-22 .. 

16S0.7FFF jFFFlFFFF'FF3#E-32: 

type SHORT FLOAT is digit" 6 

range - 16«0.7FrF FF8«E*32 .. 

16»0.7FFF_FF8«E+32; 

type LONG FLOAT is digits 15 

range - 1680.7FFF FFFF FFFF FC8E*256 .. 

1680.7FFF_FFFF_FFFF_FC8E^256; 

type LONG LONG FLOAT is digits 33 

range - 1680.7FFF FFFF FFFF FFFF FFFF FFFF FFFF CSE+4096 .. 

1680.7FFF FFFF FFFF FFFF FFFF FFFF FFFF CaE*-i096: 


B-1 








d-£ND:x r OF the Aaa STANDARD 


type DURATION is delta 2»1.0<tE-14 
range - 131^072.0 .. 

131_071.999.938_964.843 


end STANDARD; 






Appendix F 


Chapter 7 


7 Appendix F 

This chapter, together with the Chapters S and 9, is the Appendix F required in [Adai, 
in which all implementation-dependent characteristics of an Ada implementation are 
described. 


7.1 Implementation-Dependent Pragmas 

The form, allowed places, and effect of every implementation-dependent pragma is 
stated in this section. 


7.1.1 Predefined Language Pragmas 

The form and allowed places of the following pragmas are defined by the language; 
their effect is (at least partly) implementation-dependent and stated here. All the 
other pragmas listed in Appendix B of [Adal are implemented and have the effect 
described there. 


CONTROLLED 
has no effect. 


INLINE 

Inline expansion of subprograms is supported with following restrictions: 
the subprogram must not contain declarations of other subprograms, tasks, generic 
units or body stubs. If the subprogram is called recursively only the outer call of 
this subprogram will be expauided. 





Chapter 7 


Appendix F 


INTERFACE 

is supported for all languages which obey the calling conventions of the VAX 
procedure calling standard. 

For each Ada subprogram for which 

PRAGMA interface (VMS, <ada_naoe>); 

is specified, a routine implementing the body of the subprogram <ada_name> must 
be providf d, written in any language which conforms to the VMS calling stamdard. 
VMS system routines are allowed too. If the subprogram is implemented by an 
assembly language program the 

PRAGMA interface (assesbler. <ada_name>); 

can be used. 

The pragma ensures the VMS calling standaird, in particulaur: 

- Saving registers 

- Ordering of parameters 

- Number of parameters 

- Calling mechanism. 

The following parameter types with the respective calling mechanism are sup¬ 
ported: 

VMS Data Type Ada Type Calling Mechamism 

longword standard.integer by value 

address systea.address by value 

The type address may also serve to implement all kinds of call by references: the user 
may build all kinds of objects, e.g. descriptors, and peas their addresses to the system 
routine. 

The name of the routine which implements the subprograun <ada_name> should be 
specified using the pragma extemal-naae (see §7.1.2), otherwise the Compiler will 
generate an internal name that leads to an unsolved reference during linking. These 
generated names are prefixed with an underscore; therefore the iiser should not use 
names beginning with an underscore. 

The subprogram <ada_name> specified in the pragma interface may be a function 
or a procedure. If the Ada subprogram is a function, the returned result is the result 
delivered by the called routine (in the case the routine is a function); it is the completion 
status of the routine otherwise. If results are to be returned by a procedure this must 








s 


Appendix F 


Chapter 7 


be done through an IN parameter of type address, which passes the storage location 
at which the result is to be delivered. 

The first parameter of the subprogram specified in the pragma interface must be 
of type integer and is interpreted in the VTwiS calling standard as the number of the 
remaining parameters. The subprogram specification should provide a default for it, 
so that the caller must not worry about it. 

The SYSTEAM Ada Compiler does not check the observance of the VAX procedure 
calling standard. If it is violated the call of the system routine will be erroneous. 

The following example shows the intended usage of the pragma interface (voe) to 
call a VMS system routine. First some types with representation specifications and 
objects of those typea are declared. Then the Ada specification of ays_qio appears and 
is related through appropriate pragmas to the system service SYSSQIO. The function 
is called in the body of the main program. 


WITH systen. text.io; 
PROCEDURE v=a.routine IS 


readpronpt 

mmoecho 

null.address 


CONSTANT ;= 55; 

CONSTANT := 64; 

CONSTANT systen.address := systen.address.zero; 


TYPE iosb.type IS 

prrnDn 

condition-value 
transfer.count 


dev.spec.info 
END RECORD; 


short-integer; 
short.integer; 
integer; 


FOR iosb.type USE 
RECORD 

condition-value AT 0 RANGE 0 .. 15 

transfer-count AT 0 RANGE 16 .. 31 

dev.spec.info AT 4 RANGE 0 .. 31 

END RECORD: 


channel nuaber 
return code 

io.buffer : string (1 .. 80); 

PRAGMA resident (io.buffer); 


chan : integer; 

res : integer; 





Chapter 7 


Appendix F 


prompt.buffer : string (1 ..2) := "* 

PRAGMA resident (proBpt_buffer); 

iosb ; iosb_type; 

PRAGMA resident (iosb); 

FUNCTION sys.qio (n : integer :* 12; -- number of parameters 

efn : integer :* 0; — event flag number 

chem : integer; — chimnel 

func : integer; -- function code 

iosb : system.address := null-address; 

-- 10 status block 

astadr : system.address null_address; 

-- AST routine 

astprm ; integer :* 0; 

pi : system.addresa; -- 10 buffer 

p2 ; integer := 0; -- 10 buffer length 

p3 : integer ;= 0; -- timeout 

p4 ; integer := 0; -- read terminator 

p5 ; system.addresa :* null-address; 

-- prompt buffer 

p6 : integer :* 0) -- prompt buffer length 

RETURN integer; 

PRAGMA interface (vas. sys-qio); 

-- and additionally 

PRAGMA external-name ("SYS$5I0". sys-qio); 

vector-number ; CONSTANT := 0; 

ast-parameter : CONSTANT := 123-456-789; 

TASK buffer-handler IS 
PRAGMA priority (15); 

ENTRY buffer-read (param : integer); 

FOR buffer-read USE AT system.interrupt-vector (vector-n\imber) : 
Ein buffer-handler; 

TASK BODY buffer-handler IS 
BEGIN 

ACCEPT buffer-read (param : integer) DO 
text-io.put-line (io-buffer); 

END buffer-read; 

END buffer-handler; 

BEGIN 






s 


Appendix F 


Chapter 7 


after an appropriate ASSIGN channel call: 


res :» 

sys-qio (chan => chan. 

func => readprompt ♦ a_noecho. 
iosb iosb'address. 

astadr ■> system.ast_aervice (vector_nuaber), 

astprm *> ast_paraaeter. 

pi ■> io-buffer'address, 

p2 *> io.buffer'length. 

p3 -> 0. 

p4 ■> 0. 

p5 ■> prompt.buffer'address. 
p6 »> prompt_buffer'length); 

END vaa_routine: 


MEMORY-SIZE 
has no effect. 


OPTLMIZE 

has no effect. 


PACK 

see §8.1. 


PRIORITY 

There are two implementation-defined aspects of this pragma: First, the range 
of the subtype priority, and second, the effect on scheduling (§6) of not giving 
this pragma for a task or main program. The range of subtype priority is 0 .. 
15, as declared in the predefined library package system (see §7.3); and the effect 
on scheduling of leaving the priority of a task or main program undefined by not 
giving pragma priority for it is the same as if the pragma priority 0 had been 
given (i.e. the task has the lowest priority). Moreover, in this implementation 
the package system must be named by a with clause of a compilation unit if the 
predefined pragma priority is used within that unit. 





Chapter 7 


Appendix F 


SHARED 

is supported. 


STORAGE_UNIT 
has no effect. 


SUPPRESS 

has no effect, but see 27.1.2 for the implementation-defined pragma suppress, 
all. 


SYSTEM-NAME 
has no effect. 


7.1.2 Implementation-Defined Pragmas 

SQUEEZE 
see §8.1. 


SUPPRESS_ALL 

causes all the run-time checks described in jAda,§11.7j to be suppressed; this 
pragma is only allowed at the start of a compilation before the first compilation 
unit; it applies to the whole compilation. 


EXTERNAL-NAME (<string>, <ada-name>) 

<ada-n 2 Lme> specifies the name of a subprogram, <string> must be a string literal. 
It defi.nes the external name of the specified subprogram. The Compiler uses a 
symbol with this name in the call instruction for the subprogram. The suprogram 
declztration of <ada-name> must precede this pragma, it several subprograms with 
the same name satisfy this requirement the pragma refers to that subprogram 
which preceds immediately. 

This pragma will be used in connection with the pragmas interface (vns) or 
interface (assembler) (see §7.1.1). 







Appendix F 


Chapter 7 


RESIDENT (<ada_name>) 

this pragma prevents assigments of a value to the object <ada_name> from being 
eliminated by the optimizer (see §3.2) of the SYSTEAM Ada Compiler. The 
following code sequence demonstrates the intended usage of the pragma: 


X : integer: 
a : SYSTEM. address; 

PROCEDURE do_flomething (a : SYSTEM. address) : 

BEGIN 

X 6: 

a :» X* ADDRESS: 

do_8omething (a): — a. ALL will be read in the body 

-- of do-Something 

X ;* 6: 


If this code sequence is compiled by the SYSTEAM Ada Compiler with the option 
0PTIMI2ER=>QN 

the statement x := 5: will be eliminated because from the point of view of the 
optimizer the value of x is not used before the next assignment to x. Therefore 

PRAGMA resident (x): 

should be inserted after the declaration of x. 

This pragma caJi be applied to all those kinds of objects for which the address 
clause is supported (cf. §8.5). 

It will often be used in connection with the pragma interface (vas. . . . ) (see 
§7.1.1). 





Chapter 7 


Appendix F 


7.2 Implementation-Dependent Attributes 

The name, type and implementation-dependent aspects of every implementation-de¬ 
pendent attribute is stated in this chapter. 


7.2.1 Language-Defined Attributes 


The name and type of all the language-defined attributes are as given in [Ada]. We 
note here only the implementation-dependent aspects. 

ADDRESS 

The value delivered by this attribute applied to an object 's the address of the 
storage unit where this object starts. 

For any other entity this attribute is not supported and will return the value 
systes.address_ 2 ero. 


MACHINE-OVERFLOWS 

Yields true for each real type or subtype. 


MACHINE-ROUNDS 

Yields true for each real type or subtype. 


STORAGE-SIZE 

The value delivered by this attribute applied to an access type is as follows: 

If a length specification (STORAGE-SIZE, see §8.2) has been given for that type 
(static collection), the attribute delivers that specified value. 

In case of a dynamic collection, i.e. no length specification by STORAGE-SIZE given 
for the access type, the attribute delivers the number of storage units currently 
allocated for the collection. Note that dynamic collections are extended if needed. 
If the collection mamager (cf. §5.3.1) is used for a dynamic collection the attribute 
delivers the number of storage units currently allocated for the collection. Note 
that in this case the number of storage units currently allocated may be decreased 
by release operations. 


The value delivered by this attribute applied to a task type or task object is as 
follows: 



Appendix F 


Chapter 7 


If a length specification (STORAGE-SIZE, see §8.2) has been given for the task type, 
the attribute delivers that specified value; otherwise, the default value is returned. 


7.2.2 Implementation-Dtfined Attributes 
There are no implementation-defined attributes. 


7.3 Specification of the Package SYSTEM 


The package system required in [Ada,§13.7] is reprinted here with all implementation 
dependent characteristics and extensions filled in. 


PACKAGE system IS 

TYPE designated-by-address IS LIMITED PRIVATE: 

TYPE address IS ACCESS designated-bv-addresa; 
FOR address‘storage-size USE C; 


addresS-zero : 

CONSTANT address ;= NULL; 

TYPE name IS (vax-vms); 


system-name 

CONSTANT name := vax_vms; 

storage-unit 

CONSTANT 

= 8: 

memory-size 

CONSTANT 

- 2 ** 31; 

min_int 

CONSTANT 

» - 2 •• 31; 

mzoc-int 

CONSTANT 

= 2 31 - 1; 

max-digits 

CONSTANT 

» 33; 

max-mantissa 

CONSTANT 

« 31: 

fine-delta 

CONSTANT 

* 2.0 ♦* (-31); 

tick 

CONSTANT 

- 0.01; 


SUBTYPE priority IS integer RANGE 0 .. 15; 

FUNCTION (left : address; right : integer) RETURN address: 

FUNCTION (left : integer: right : address) RETURN address: 








Chapter 7 


Appendix F 


FUNCTION (left : address; right : integer) RETURN address; 

FUNCTION (left : address; right : address) RETURN integer; 

SUBTYPE extemal_addres8 IS STRING; 

-- External addresses use hexadecimal notation with characters 

— ’a’..’f and ’A‘..'F*. For instance: 

"7FFFFFFF" 

"80000000" 

"8" represents the same address as "00000008" 

FUNCTION convert_addres8 (addr : extemal_addres8) RETURN address; 

-- CONSTRAINT_£RROR is raised if the external address ADDR 
-- is the empty string, contains characters other than 
-- '0'..'9', 'a*..'f*. 'A’..*F’ or if the resulting address 
-- value cannot be represented with 32 bits. 

FUNCTION convert_address (addr : address) RETURN external-address; 

-- The resulting external address consists of exactly 8 
-- characters ■0'..'9*, 'A’..‘F’. 

TYPE interrupt-nincber IS RANGE 0 .. 31; 

TYPE interrupt-addresses IS ARR.AY (interrupt-number) OF address: 
ast-service. 

interrupt-vector ; interrupt-addresses; 

-- The initialisation of these arrays is performed during the 

— elaboration of the package body. 

non-ada_error : EXCEPTION; 

non-ada-error is raised, if some event occurs which does not 
-- correspond to any situation covered by Ada, e.g.: 
illegal instruction encountered 
error during address translation 
illegal address 

TYPE exception-id IS NEW integer; 
no-exception-id : CONSTANT exception-id := 0; 








Appendix F 


Chapter 


Coding of the predefined exceptions: 


constraint-error_id 

CONSTANT exception-id 

= . . . ; 

numeric_error_id 

CONSTANT exception-id 

= . . . : 

program-error_id 

CONSTANT exception-id 

= ... : 

storage-error-id 

CONSTANT exception-id 

= ... : 

tasking_error-id 

CONSTANT exception-id 

= .. • : 

non_ada_error-id 

CONSTANT exception-id 

• « ' * 

status_error-id 

CONSTANT exception-id 

s 

mode-error_id 

CONSTANT exception-id 

= 

name-error-id 

CONSTANT exception-id 

= ... 

use-error-id 

CONSTANT exception-id 

s 

device-error_id 

CONSTANT exception-id 

= ... 

end_error_id 

CONSTANT exception-id 


data-error_id 

CONSTANT exception-id 

= ... 

layout_error_id 

CONSTANT exception-id 

3 


tiae_error_id : CONSTANT exception-id := ... : 

TYPE argument-array IS ARP.AY (1 . . 4) OF integer: 
no-conditicn_naae : CONSTANT := 1. 


TYPE exception_infomation IS 

orrnpn 

excp-id : exception-id; 

-- Identification exception. The codings of 

-- the predefined exceptions are given above. 

code_addr : address; 

-- Code address where the exception occured. Depending 

-- on the kind of the exception it nay be be address of 
-- the instruction which caused the exception, or it 
-- may be the address of the instruction which would 
-- have been executed if the exception had not occured. 

condition-nane : integer; 

— If /■ no_condition_naffle, the exception was caused 

— by a condition. In this case, the condition name 

— and other following inf omation made available. 

nr-of-arguments : integer; — in the range 1 ..4. 











Chapter 7 


Appendix F 


arguaents ; arguaent_array; 

-- Only argmentB (1 .. nr_of-arguments) are valid. 

-- It contains a copy of the optional information 
-- supplied by VMS in the argument array when the 
-- condition occured. If there are more than 4 optional 
-- entries in the argument array, only the first 4 
-- are copied. 


psl ; integer; 

-- The processor status longword. 

END RECORD; 

PROCEDURE get_exception_infornation 

(excp-info : OUT exception-information); 

-- The subprogram g€t_exception_information must only be called 

— from within an exception handler BEFORE ANY OTHER EXCEPTION 
-- IS RAISED. It then returns the information record about the 
-- actually hzmdled exception. 

-- Otherwise, its result is undefined. 

TYPE exit-code IS NEW integer; 

error ; CONSTANT exit-code := 2; 

information : CONSTANT exit_code := 2; 

success : CONSTANT exit-code := 1; 

severe_error : CONSTANT exit-code := 4; 

warning : CONSTANT exit-code := 0; 

PROCEDURE set-exit-Code (val : exit-code); 

— Specifies the exit code which is returned to the 

— operating system if the Ada progrzoa terminates normally. 

-- The default exit code is 'success*. If the program is 

-- abandoned because of eui exception, the exit code is 
-- 'error'. 


PRIVATE 

— private declarations 
END system; 






Appendix F 


Chapter 7 


7.4 Restrictions on Representation Clauses 
See Chapter 8 of this manual. 


7.5 Conventions for Implementation-Generated Names 

There are implementation generated components but these have no names, (cf. §8.4 
of this manual). 


7.6 Expressions in Address Clauses 
See §8.5 of this manual. 


7.7 Restrictions on Unchecked Conversions 

The implementation supports unchecked type conversions for all kind of source and 
target types with the restriction that the target type must not be an unconstrained 
array type. The result value of the unchecked conversion is unpredictable, if 

target_type'SIZE > source-type’SIZE 


7.8 Characteristics of the Input-Output Packages 


The implementation-dependent characteristics of the input-output packages as defined 
in Chapter 14 of [Adaj are reported in Chapter 9 of this manual. 


7.9 Requirements for a Main Program 

A main program must be a parameterless library procedure. This procedure may be 
a generic instantiation; the generic procedure need not be a library unit. 





Chapter 7 


Appendix F 


7.10 Unchecked Storage Deallocation 

The generic procedure unchecked-deallocation is provided, but the only effect of 
cajling an instantiation of this procedure with an object X as actual parameter is 

X :» NULL: 

i.e. no storage is reclaimed. 

However, the implementation does provide an implementation-defined package col¬ 
lection-manager to support unchecked storage deallocation (cf. §5.3.1). 

7.11 Machine Code Insertions 

A package machine .code is not provided and machine code insertions are not sup¬ 
ported. 


7.12 Numeric Er-or 


The predefined exception numeric-error is never raised implicitly by any predefined 
operation; instead the predefined exception constraint-error is raised. 





Appendix F: Representation Clauses 


Chapter 8 


8 Appendix F: Representation Clauses 

In this chapter we follow the section numbering of Chapter 13 of l Adai and provide 
notes for the use of the features described in each section. 


8.1 Pragmas 
PACK 

As stipulated in |Ada,§13.l), this pragma may be given for a record or array type. 
It causes the Compiler to select a representation for this type such that gaps 
between the storage eireas allocated to consecutive components are minimized. 
For components whose type is an array or record type the pragma pack has no 
affect on the mapping of the component type. For all other component types the 
Compiler will try to choose a more compact representation for the component type. 
All components of a packed data structure will stairt at storage unit boundau’ies 
and the size of the components will be a multiple of system, storage-unit. Thus, 
the pragma pack does not effect packing down to the bit level (for this see pragma 
squeeze). 


SQUEEZE 

This is an implementation-defined pragma which takes the same argument as the 
predefined language pragma pack and is allowed at the same positions. It causes 
the Compiler to select a representation for the argument ty^pe that needs minimal 
storage space (packing down to the bit level). For components whose type is an 
aurray or record type the pragma squeeze has no effect on the mapping of the 
component type. For all other component types the Compiler will try to choose 
a more compact representation for the component type. The components of a 
squeezed data structure will not in general start at storage unit boundaries. 




Chapter 8 


Appendix F: Representation Clauses 


8.2 Length Clauses 


SIZE 

for all integer, fixed point and enumeration types the value must be <= 22; 
for 8hort_float types the value must be = 32 (this is the amount of storage 
which is associated with these tj^pes anyway); 

for float and long-float types the value must be = 64 (this is the amount of 
storage which is associated with these types anyway). 

for long-long-float types the value must be = 128 (this is the zunount of storage 
which is associated with these tjmes anyway); 

for access types the value must be = 32 (this is the amount of storage which is 
associated with these tjpjes anyway). 

If any of the above restrictions are violated, the Compiler responds with a RE¬ 
STRICTION error message in the Compiler listing. 

STORAGE-SIZE 

Collection size: If no length clause is given, the storage space needed to contain 
objects designated by \’alues of the access type and by values of other types derived 
from it is extended dynamically at runtime as needed. If, on the other hand, a 
length clause is given, the number of storage units stipulated in the length clause 
is reserved, and no djmamic extension at runtime occurs. 

Storage for tasks: The memory space reserved for a task is lOK bytes if no length 
claiise is given (cf. Chapter 6). If the task is to be allotted either more or less 
space, a length clause must be given for its task type, and then all tasks of this 
tjrpe will be allotted the amount of space stipulated in the length clause (the 
activation of a small task requires about 1.4K bjaes). Whether a length clause is 
given or not, the space allotted is not extended dynamically at runtime. 


SMALL 

there is no implementation-dependent restriction. Any specification for SMALL 
that is allowed by the LRM can be given. In particular those values for SMALL are 
also supported which are not a power of two. 


8.3 Enumeration Representation Clauses 


The integer codes specified for the enumeration type have to lie inside the range of the 
largest integer type which is supported; this is the type integer defined in pztckage 
standard. 



Appendix F: Representation Clauses 


Chapter 8 


8.4 Record Representation Clauses 

Record representation clauses are supported. The \’alue of the expression given in an 
alignment clause must be 0, 1, 2 or 4. If this restriction is violated, the Compiler 
responds with a RESTRICTION error message in the Compiler listing. If the value is 
0 the objects of the corresponding record type will not be aligned, if it is 1, 2 or 4 the 
starting address of an object will be a multiple of the specified alignment. 

The number of bits specified by the range of a component clause must not be greater 
than the amount of storage occupied by this component. (Gaps between components 
can be forced by leaving some bits unused but not by specifying a bigger range than 
needed.) Violation of this restriction will produce a RESTRICTION error message. 

There are implementation-dependent components of record types generated in the 
following cases ; 

• If the record type includes variant parts and if it has either more than one dis¬ 
criminant or else the only discriminant may hold more than 256 different values, 
the generated component holds the size of the record object. 

• If the record type includes array or record components whose sizes depend on dis¬ 
criminants, the generated components hold the offsets of these record components 
(relative to the corresponding generated component) in the record object. 

But there are no implementation-generated names (cf. .\da,§13.4(8)j) denoting these 
components. So the mapping of these components cannot be influenced by a represen¬ 
tation clause. 


8.5 Address Clauses 

Address clauses are supported for objects declared by an object declaration and for 
single task entries. If an address claxise is given for a subprogram, package or a task 
unit, the Compiler responds with a RESTRICTION error message in the Compiler 
listing. 

If an address clause is given for an object, the storage occupied by the object starts at 
the given address. Address clauses for single entries are described in §8.5.1. 





Chapter 8 


Appendix F; Representation Clauses 


8.5.1 Intcrr 

On VAX/VMS, all hardware interrupts are handled by VMS. It is not possible to handle 
the hardware interrupts directly. However, some system services allow a process to be 
interrupted when a particular event occurs. Since the interrupt occurs asynchronously, 
the interrupt mechanism is called an asynchronous system trap (AST) (cf. {VAX/VMS, 
System Services)). The trap transfers control to a user-specified service routine that 
handles the event. 

VMS delivers an AST when requested to do so, for instance by calls of system services 
like SDCLAST, SENQ, SGETDVI, SGETJPI, SGETSYI, $QIO, SSETIMR or by calls 
of RMS services. As parameters to a call of a system service the address of the AST 
service routine (usually the parameter astadr) and an AST parameter value (usually 
the pa”ameter astpra) can be specified. The specified AST parameter value is passed 
to the AST service routine as argument when it is called. In this way one AST service 
routine can be used to handle several ASTs. 

For example, the SSETIMR service can be used to request an AST after 10 seconds or 
at 12:00:00. After calling the SSETIMR service the program continues in its normal 
control flow. If the time event occurs, VMS causes the normal control flow to be 
interrupted and executes the AST service routine. Upon completion of the AST service 
routine the execution of the program is continued where it was interrupted. 

An address clause for an entry associates the entry with an AST. When an AST occurs, 
the AST service routine initiates the entry call; the calling task and the called task 
continue their execution in parallel. 

By this mechanism, an interrupt acts as an entry call to that task; such an entry is 
called an interrupt entry. An interrupt causes the ACCEPT statement corresponding to 
the entry to be executed. 

The AST is mapped to an ordinary entry call. The entry may also be called by an 
Ada entry call statement. However, it is assumed that when an interrupt occurs there 
is no entry call waiting in the entry queue. Otherwise, the program is erroneous and 
behaves in the following way: 

• If an entry call stemming from an interrupt is already queued, this previous entry 
call is lost. 

• The entry call stemming from the interrupt is inserted into the front of the entry 
queue, so that it is handled before any entry call stemming from an Ada entry 
call statement. 






Appendix F: Representation Clauses 


Chapter 8 


8.5.1.1 Association between Entry and Interrupt 


The association between an entry and an interrupt is achieved via an interrupt number 
(type ay 8 ten. interrupt-number) the rajige of interrupt numbers being 0 .. 31 (this 
means that 32 single entries can act 2 is interrupt entries). A single entry of a task 
which has one IH parameter of type integer or system.address can be associated 
with an interrupt number by an address clause (the Compiler does not check these 
conventions). Since an address value must be given in the address clause, the interrupt 
number has to be converted into type system.address. The array system, interrupt- 
vector is provided for this purpose; it is indexed by an interrupt number to to get the 
corresponding address. 

The following example associates the entries timer.l. timer_2. io_f ailure and io_ 
success with the interrupt numbers 10, 11, 12 and 13, respectively. 


TASK handler IS 

ENTRY tiaer_l (x : IN integer): 

ENTRY tiaar_2 (x : IN integer); 

ENTRY io-failure (x : IN system.address): 

ENTRY io-success (x : IN system.address); 

FOR tiaer_l USE AT system.interrupt.vector (10) 

FOR tiaer-2 USE AT systea.interrupt.vector (11) 

FOR io.iailure USE AT system.interrupt.vector (12) 
FOR io.success USE AT system.interrupt.vector (13) 
END; 


The task body contains ordinary accept statements for the entries. 


8.5.1.2 Association between Interrupt and AST 5erwce Routine 


When a system service is called and an entry is to be called via interrupt, the address 
value system.ast-service (nr) must be specified as AST service routine, where nr 
indicates the interrupt number. 

The effect of the execution of the AST service routine given by system.ast.service 
(nr) depends on whether there is a task currently waiting at an ACCEPT or selective 
wait statement for an entry which is associated with the interrupt number nr. 








Chapter 8 


Appendix F; Representation Clauses 


If there is a taisk waiting, a rendezvous with that task is performed immediately. If 
several tasks axe waiting for the same interrupt, the program is erroneous (cf. [Ada, 
§13.5(8)j) auid a rendezvous is performed with any of these tasks. 

Otherwise, the information that the interrupt nr occurred and the corresponding AST 
parameter value are stored by the Ada rur.time system. If later on a task performs an 
ACCEPT or selective wait statement for the entry associated with the interrupt nr the 
rendezvous is performed. 

Therefore zin interrupt is never treated as a conditional entry call. If the interrupt nr 
occurs again before the previous one has been handled, the previous one is lost. 

A detailed example for aji interrupt entry is given in Chapter 7, in the procedure vms_ 
routine. 


8.5.1.S Calling an Asynchronous VMS System Service 

The following example shows how to call an entry from an AST delivered by a VMS 
system service, here the SSETIMR. service. 


PROCEDURE vas-setiar ( ... ): 

PRAGMA extemal_naae (tas-setiar. "SYS$SETIMR") : 

PRAGMA interface (vas. vas.setiar); 

taa_setinr -- (1) 

(daytiae => ... . -- e.g. 12:00:00.00 

astadr => systea.ast.service (10)); 

vBs.setiar -- (2) 

(daytiae =>.... -- e.g. in 10 sec from now on 

astadr => systea.ast-service (11), 
reqidt => 1234567); 


The effect of the call (1) of vas-setiar is that at the speciSed time am AST is delivered 
which is mapped to a call of the entry tiaer_l of the task specified above. No AST- 
parameter specified; VMS inserts the default 0, which is passed as argument x to the 
accept body of tiner_l. 

The effect of the call (2) of vas-seticr is similar. Here the AST-paxameter is specified. 
It is passed as argument x to the accept body of tiaer_2. 





Appendix F: Representation Clauses 


Chapter 8 


8.5.1.^ Calling an Asynchronous RMS Service 

The RMS routines are a little bit different from the VMS system services. When calling 
a RMS service the addresses of two completion routines (one for success, one for failure) 
can be given as parameters. If this is done, the service is performed asynchronously 
and upon completion one of the two completion routines is called as AST routine. The 
address of the FAB or RAB which was passed as operand to the RMS service is passed 
as AST parameter to the completion routine. Example: 


PROCEDURE ras-open ( ... ) ; 

PRAGMA axtamal_nama (raa.opan, "SYSSOPEN") ; 
PRAGMA intarfaca (vina . ra8_opan) ; 

ay_fab : leb type ; 

ras-opan (fab »> my_fab'addraas, 

arr => syatem.aat.aarvice (12). 
sue => ayatao.aat-servica (13)); 


Upon successful completion of the open operation an AST is delivered which results in 
calling the entry io-succaaa with parameter x = ay.fab’ADDRESS. If an error occurs, 
io_f allure is called instead. 


8,6 Change of Representation 

The implementation places no additional restrictions on changes of representation. 





Chapter 9 


Appendix F: Input-Output 


9 Appendix F: Input-Output 

In this chapter we follow the section numbering of Chapter 14 of [Ada] and provide 
notes for the use of the features described in each section. 


9.1 External Files and File Objects 

The total number of open files (including the two standard files) must not exceed 18. 
Any attempt to exceed this limit raises the exception use-error. 

The only form of file sharing which is allowed is shared reading. If two or more files 
are associated with the same external file at one time (regardless of whether these files 
are declared in the same program or task), all of these (internal) files must be opened 
with the mode in_f ile. An attempt to open one of these files with a mode other than 
will raise the exception use .error. 

Files associated with teiminal devices (which is only legal for text files) are excepted 
from this restriction. Such files may be opened with an arbitrary mode at the same 
time and associated with the same terminal device. 

The following restrictions apply to the generic actual parameter for element-type; 

• input/output of access tj'pes is not defined. 

• input/output of unconstrained array types is only possible with a variable record 
format. 

• for RMS sequential [relative or indexed] files the size of an object to be input or 
output must not be greater than 32767 [16383] storage units. 

• input/output is not possible for an object whose (sub)type has a size which is not 
a multiple of system, storage .unit. Such objects can only exist for types for 
which a representation clause or the pragma squeeze is given. Use.error will be 
raised by any attempt to read or write such zm object or to open or create a file 
for such a {sub)tjpe. 


9.2 Sequential and Direct Files 

Sequential and direct files atre represented by RMS sequential, relative or indexed files 
with fixed-length or variable-length records. Each element of the file is stored in one 
record. 



Appendix F: Input-Output 


Chapter 9 


9.2.1 File Management 


Since there is a lot to say about this section, we shall introGJce subsection numbers 
which do not exist in [Ada]. 


9.2.1.1 The NAME and FORM Parameters 


The name parameter string must be a VMS file specification string and must not contain 
wild cards, even if that would specify a unique file. The function nane will return a 
file specification string (including version number) which is the file name of the file 
opened or created. 

The syntax of the fora parameter string is defined by; 


fora_parzutteter :;= [ fora_specification { . fora.specification } ] 
fora-specifIcation ::= keyword [ => value ] 
keyword ::= identifier 

value identifier i string-literal 1 nuaeric-literal 

For identifier, numeric-literal, string-literal see ;.\da.Appendlx El. Only an integer 
literal is allowed as numeric-literal (see .Ada,s2.4j). 

In the following, the form specifications which are allowed for all files are described. 


ALLOCATION *> numeric-literal 

This value specifies the number of blocks which are allocated initially; it is only used 
in a create operation and ignored in an open operation. The value of ALLOCATION 
in the form string returned by the function fora specifies the initial allocation size for 
existing files too. 


EXTENSION »> numeric-literal 





Chapter 9 


Appendix F: Input-Output 


This value specifies the number of blocks by which a file is extended if necessary; the 
value 0 means that the RMS default v'alue is taken. For existing files, this value only 
applies to extensions of the file between open and close operations in the Ada program. 

For details see T ie lVAX/\TvlS, Record Management Services;. 


MAX_RECORD_SIZE => numeric-literal 


This value specifies the maximum record size in bytes. The value 0 indicates that 
there is no limit; for direct files, this value is only allowed for indexed files, whereas 
for sequential files there is no such restriction. This form specification is only allowed 
for files with vziriable record format. If the value is specified for an existing file it must 
agree with the value of the external file. 


For files with fixed-length records, the maximum record size equals 
eleoent-type'SIZE / system, storage .unit. If a fixed record format is used, all 
objects written to a file which are shorter than the maximum record size are filled up 
with zeros (ASCII.NUL). 


RECORD-FORMAT => VARIABLE I FIXED 


This form specification is used to specif)' the record format. If the format is specified 
for an existing file it must agree with the format of the external file. 






Appendix F: Input-Output 


Chapter 9 


9.2.1.2 Sequential Files 


A sequential file is represented by a RMS sequential file with either fixed-length or 
variable-length records (this may be specified by the form parameter). 

If a fixed record format is used, all objects written to a file which are shorter than the 
maximum record size are filled up with zeros (ASCII.NUL). 


END_OF_FILE 


If the keyword END_OF_FILE is specified for an existing file in an open for an output 
file, then the file is opened at the end of the file; i.e. the existing file is extended and 
not rewritten. This keyword is only allowed for an output file; it only has an effect in 
an open operation and is ignored in a create. 

The default form string for a sequential file is : 


"ALLOCATION => 0. EXTENSION => 0. " k 

".RECORD-FORMAT => VARIABLE. MAX_RECORD_SIZE => 0 " 

The default form may be used for all types (except for those excluded in §9.1). 


9.2.1.3 Direct Files 

The implementation dependent type count defined in the package specification of 
direct_io has an upper bound of : 


COUNT'LAST - 2_147_483_647 (= INTEGER’LAST) 


Direct files are represented by RMS sequential files with fixed-length records or by 
relative or indexed files with either fixed-length or variable-length records. For indexed 
files, the record index is stored as unsigned four bytes bineiry value in the first four bytes 
of each record. If not explicitly specified, the maximum record size equals eleaent- 
type'SIZE / system.storage_unit. 







Chapter 9 


Appendix F: Input-Output 


BUC?IET_SI2£ => nuffleric_literal 


This value specifies the number of blocks (one block is 512 bytes) for one bucket; the 
value 0 means that the value is evaluated by RMS to the minimal number of blocks 
which is necessary to contain one record. The value must be in the range from 0 up 
to 32. This form specification is only allowed for relative or indexed files. If the value 
is specified for zm existing file it must agree with the value of the external file. 


ORGANIZATION => INDEXED I RELATIVE I SEQUENTIAL 


This form specification is used to specify the file organization. If the organization is 
specified for an existing file it must agree with the organization of the external file. 


The default form string for a direct file is : 


"ALLOCATION => 0. EXTENSION => 0. " t 

"ORGANIZATION => SEQUENTIAL. RECORD.FORMAT => FIXED" 


Indexed files with variable-length records and a maximum record size of 0 may be used 
for all types (except for those excluded in §9.1). Relative files with variable-length 
records may also be used for all tj'pes, but in this case a maximum record size must be 
specified explicitly. Sequential, relative or indexed files with fixed-length records may 
not be used for unconstrained array types. 





Appendix F: Input-Output 


Chapter 9 


9.3 Text Input-Output 


Text files are represented as sequential files with variable record format. One line is 
represented as a sequence of one or more records; all records except for the last one have 
a length of exactly MAX_RECORD_SIZE and a continuation marker (ASCII.LF) at 
the last position. A line of length MAX-RECORD-SIZE is represented by one record 
of this length. A line terminator is not represented explicitly in the external file; 
the end of a record which is shorter than MAX-RECORD-SIZE or which has length 
exactly MAX_RECORD_SIZE and does not have a continuation marker as its last 
character is taken as a line terminator. 

The value MAX-RECORD-SIZE may be specified by the form string for am output file 
and it is taJcen from the external file for an input file; for an input file, the value 0 stands 
for the default of 512. For all files which aure created, the value MAX-RECORD-SIZE 
is used for the file attribute MRS (maximum record size). 

A page terminator is represented as a record consisting of a single .\3CI!.FF. A record 
of length zero is assumed to precede a page terminator if the record before the page 
terminator is another page terminator or a record of length M.\X-RECORD_SIZE 
with a continuation marker at the last position; this implies that a page terminator is 
preceded by a line terminator in all cases. 

A file terminator is not represented explicitly in the external file: the end of the file is 
taken as a file terminator. A page terminator is assumed to precede the end of the file 
if there is not explicitly one as the last record of the file. For input from a terminal, a 
file terminator is represented as ASCII.SUB (= CTRL/Zl. 



Chapter 9 


Appendix F; Input-Output 


9.S.1 File Management 


In the following, the form specifications which are only allowed for text files or have a 
special meaning for text files are described. 


CHARACTER-ID 

The predefined package text-io was designed for sequential text files; moreover, this 
implementation always uses sequential files with a record structure, even for terminal 
devices. It therefore offers no language-defined facilities for modifying data previously 
written to the terminal (e.g. changing characters in a text which is already on the ter¬ 
minal screen) or for outputting characters to the terminal without following them by a 
line terminator. It also has no language-defined provision for input of single characters 
from the terminal (as opposed to lines, which must end with a line terminator, so that 
in order to input one character the user must type in that character and then a line 
terminator) or for suppressing the echo on the terminal of characters typed in at the 
keyboard. 

For these reasons, in addition to the input/output facilities with record structured 
external files, another form of input/output is provided for text files: It is possible 
to transfer single characters from/to a terminal device. This form of input/output is 
specified by the keyword CHARACTER_IO in the form string. If CHARACTER_IO 
is specified, no other form specification is allowed and the file name must denote a 
terminal device. 

For an infile, the external file (associated with a terminal) is considered to contain 
a single line. An ASCII.SUB (= CTRL/Z) character represents an line terminator 
followed by a page terminator followed by a file terminator. Arbitrary characters 
(including all control characters except for ASCII.SUB) may be read; a character read 
is not echoed to the terminal. 

For an outfile, arbitrary characters (including all control characters and escape se¬ 
quences) may be written on the external file (terminal). A line terminator is rep¬ 
resented as ASCII.CR followed by ASCII.LF, a page terminator is represented as 
ASCII.FF and a file terminator is not represented on the external file. 





Appendix F: Input-Output 


Chapter 9 


Only for input files : 


PROMPTING ®> string-literal 

This string is output on the terminal before an input record is read if the input file is 
associated with a terminal; otherwise this form specification is ignored. 


Only for output files ; 


MAX_RECQBD_SI2E *> nuoeric-literal 


This value specifies the maximum length of a record in the external file. Each record 
which is not the last record of a line has exactly this maximum record size, with a 
continuation marker (ASCII.LF) at the last position. The value must be in the range 
2 .. 512. If a file is created, the specified value (or the default of 512) is used for the 
file attribute MRS (maximum record size) of the external file. If the value is specified 
for an existing file it must be identical to the value of the external file. 


The default form string for an input text file is : 


"ALLOCATION -> 0. EXTENSION => 0. PROMPTING => """" 


The default form string for an output text file is ; 


"ALLOCATION *> 0. EXTENSION => 0. MAX-RECORD-SIZE *> 512" 


Chapter 9 


Appendix F: Input-Output 


9.S.2 Default Input and Output Files 

The standard input (resp. output) file is associated with the system default logical 
names SYSSINPUT (resp. SYSSOUTPUT) of VIvIS. If a program reads from the 
standard input file, the logical name SYSSINPUT must denote an existing file. If a 
program writes to the standard output file, a file with the logical name SYSSOUTPUT 
is created if no such file exists; otherwise the existing file is extended. 

The qualifiers /INPUT and /OUTPUT may be \ised for the VMS RUN command to 
associate VMS files with the standard files of text_io. 

The name and form strings for the standard files are : 


8tandard_input : NAME *> "SYSSINPUT;" 

FORM *> "PROMPTING «=> " 

standard.output ; NAME *> "SYSSOUTPUT:" 

FORM => "MAX_REC0RD_SI2E => 512" 


9.S.S Implementation-Defined Types 

The implementation-dependent tj'pes count and field defined in the package specifi¬ 
cation of text_io have the following upper bounds : 


COUNT’LAST « 2_147_483_647 (= INTEGER'LAST) 
FIELD'LAST = 612 



Appendix F: Input-Output 


Chapter 9 


9.4 Exceptions in Input-Output 


For each of naffle_error, use_error, device_error and data_error we list the condi¬ 
tions under which that exception can be raised. The conditions under which the other 
exceptions declared in the package io.exceptions can be raised are as described in 
(Ada,§14.4j. 

NAME-ERROR 

• in an open operation, if the specified file does not exist; 

• in a create operation, if the nase string contains an explicit version number and 
the specified file already exists; 

• if the neime parameter in a call of the create or open procedure is not a legal 
VMS file specification string; for example, if it contains illegal characters, is too 
long or is syntactically incorrect; and also if it contains wild cards, even if that 
would specify a unique file. 


USE-ERROR 

• if an attempt is made to increase the total number of open files (Including the two 
standard files) to more than 18; 

• whenever an error occurred during an operation of the underlying RMS system. 
This may happen if an internal error was detected, an operation is not possible for 
reasons depending on the file or device characteristics, a size restriction is violated, 
a capacity limit is exceeded or for similar reasons; 

• if the function naae is applied to a temporary file; 

• if the characteristics of the external file are not appropriate for the file type; for 
example, if the record size of a file with fixed-length records does not correspond to 
the size of the element type of a direct-io or aequential-io file. In general it is 
only guaranteed that a file which is created by an Ada program may be reopened 
by another program if the file types and the form strings are the same; 

• if two or more (internal) files are associated with the szume external file at one 
time (regardless of whether these files are declared in the same program or task), 
and an attempt is made to open one of these files with mode other than in-f lie. 
However, files associated with terminal devices (which is only legal for text files) 
are excepted from this restriction. Such files may be opened with an arbitrary 
mode at the same time and associated with the same terminal device; 

• if a given fora parameter string does not have the correct syntax or if a condition 
on an individual form specification described in §§9.2-3 is not fulfilled; 

• if an attempt is made to open or create a sequential or direct file for an element 
type whose size is not a multiple of system, storage-unit; or if an attempt is 
made to read or write an object whose (sub)type has a size which is not a multiple 
of system, storage-unit (such situations can only arise for types for which a 
representation claxise or the pragma squeeze is given); 





Chapter 9 


Appendix F: Input-Output 


DEVICE-ERROR 

is never raised. Instead of this exception the exception use-error is raised when 
ever an error occurred during an operation of the underlying RMS sysiem. 


DATA-ERROR 

• the conditions under which data-error is raised by text_io are laid down in 
[Ada]; the following notes apply to the packages sequential-io and direct_io: 

• by the procedure read if the size of a variable-length record in the external file to 
be read exceeds the storage size of the given variable or else the size of a fixed- 
length record in the external file to be read exceeds the storage size of the given 
variable which has exactly the size element, type‘SIZE. 

• In general, the exception data_error is not raised by the procedure read if the 
element read is not a legal value of the element type. 

• by the procedure read if an element with the specified position in a direct file 
does not exist; this is only possible if the file is associated with a relative or an 
indexed file. 


9.5 Low Level Input-Output 

We give here the specification of the package low-level-io: 


PACKAGE low_level_io IS 

TYPE device-type IS (null-device); 

TYPE data_type IS 
RECORD 
NULL; 

END RECORD: 

PROCEDURE eend-control (device : device-type; 

data : IN OUT data_type); 

PROCEDURE receive-control (device : device-type; 

data : IN OUT data-type): 


END low-level-io: 



Appendix F: Input-Output 


Chapter 9 


Note that the enumeration type device-type has only one enumeration value, null- 
device; thus the procedures send-control and receive-control can be called, but 
eend-control will have no effect on any physical device and the value of the au:tuai 
parameter data after a call of receive_control will have no physical significance. 






Chapter 10 


References 


10 References 


[Ada] 

[STl6/85] 

IST16/87] 

[ST19/84| 

[ST21/84] 

[ST27/84] 

IST30/84j 

iST33/84i 

[ST37/88j 

[ST4/84] 

[ST9/85] 

[VAX/VMS] 


The Programming Language Ada Reference Manual, 

American National Standards Institute, Inc. 
ANSI/MIL-STD-1815A-1983, 

Springer Lecture Notes in Computer Science 155, 1983 
J. Schauer 

SYSTEAM Ada System. Cross Reference Generator User Manual for 
VAX/VMS, 

SYSTEAM Document No. 16/85, 1986 
P. Dencker 

SYSTEAM Ada System, Debugger User Manual for V'AX/VMS, 
SYSTEAM Document No. 16/87, 1987 
W. Herzog, R. Kollner 

SYSTEAM Ada System, Installation Manual for VAX/VMS, 
SYSTEAM Document No. 19/84, 1984 
W.-D. Lindenmeyer 

SYSTEAM .Ada System, Source Generator User Manual for 
VAX/\"MS, 

SYSTEAM Document No. 21/84, 1986 
W.-D. Lindenmeyer 

SYSTEAM Ada System, Pretty Printer User Manual for VAX/VMS, 
SYSTEAM Document No. 27/84, 1986 
W.-D. Lindenmeyer 

SYSTEAM .Ada System. Sjmtax Checker User Manual for VAX/ATvlS, 
SYSTEAM Document No. 30/84, 1986 
W.-D. Lindenmeyer, 

SYSTEAM Ada System, Nonlnit User Manual for VAX/VMS, 
SYSTEAM Document No. 33/84, 1986 
M. Schoch 

SYSTEAM Ada System, Execution Time Profiler User Manual for 
VAX/VTvIS 

SYSTEAM Document No. 37/88, 1988 

W.-D. Lindenmeyer, D. Schmidt, M. Dausmann 

SYSTEAM Ada System, Library User System User Manual for 

VAX/VMS, 

SYSTEAM Document No. 4/84, 1988 
W. Herzog 

SYSTEAM Ada System, Name-Expander User Manual for VAX/VMS, 
SYSTEAM Document No. 9/85, 1986 
VAX/VMS Document Set, 

Digital Equipment Corporation, Maynard, Massachusetts 



APPENDIX C 


TEST PARAMETERS 


Certain tests in the ACVC make use implementation-dependent values, such 
as the maximum length oi an input line ana invalid -file names. A test that 
makes use ot such values is identified by the extension .TST in its file 
name. Actual values to be substituteo are represented by names that begin 
with a dollar sign. A value must be substituted for each of these names 
before the test is run. The values used for this validation are given 
below. The use of the operator signifies a multiplication of the 
following character. The use of the 'S’ character signifies concatenation 
of the preceeding and following strings. The values within single or 
double quotation marks are to highlight characters or string values: 


ilaisfi and Ssaning 


Value 


lACC.SIZE 22 

An integer literal whose value 
is the numper of bits sufficient 
to hold any value of an access 
type. 


*BIQ_ID1 ZS-i » 'A- i 

An identifier the size the 
maximum input line length which 
is ioentical to *BIG_IDZ except 
for t.he last c.naracter. 


«8IG.ID2 Z54 

An identifier the size of the 
maximum input line length which 
is identical to $BIS_ID1 except 
for the last character. 


S 


1 n 1 


$BIG_ID3 127 » ’A’ S ’3’ & 127 » ’A’ 

An identifier the size of the 
maximum input line length which 
is identical to *BIG_ID4 except 
for a character near the middle. 


C-1 








TEST PARAMETERS 


fiiaofi and Saaolns 

IBIG.IDA 

An identifier the si 2 e of the 
naximum input line length which 
is identical to IBIG.IDS except 
for a character near the middle. 

IBIG.INT.LIT 

An integer literal of value 298 
with enough leading zeroes so 
that it is the size of the 
maximum Iine length. 

IBIG.REAL.LIT 

A universal real literal of 
value 690.0 with enough leading 
zeroes to be the size of the 
maximum line length. 

$BIG.STRING1 

A string literal which when 
catenated with BIG_STRIN62 

yields the image of 3IG.ID1. 

*aIG.S7RING2 

A String literal which when 

catenated to the end of 
3IG S7RJNG1 yields the image of 
aib.iDi. 

JBLANKS 

A seauence of blanks twenty 
cnaracters less tnan the size 
of the maximum line length. 

5C0UN7_LAS7 

A universal integer 

literal wnose value is 

7EXT_I0.C0UNT’LAST. 

1DEFAULT_MEN_SI2£ 

An integer literal whose value 
is SYSTEM.MEHORY.SIZE. 

♦OErAULT.STOR.UNIT 

An integer literal whose value 
is SYSTEM.STORAGE.UNIT. 


Uilii 

127 * ’A’ i M' I 127 * ’A’ 


252 * ’0’ a "298" 


200 * ’0’ S "690.0" 


I 127 * ’A’ 31 

31 127 » ’A’ 31 3 ’ 


♦ * 1 
4. « * 

21*17483647 

2.147_482_648 

8 


C-2 


dm and d&iQlna 

<OEFAULT_SYS.NAME 

The value oF the constant 
SYSTEM.SYSTEM.NAME. 

$DELTA_D0C 

A real literal whose value is 
SYSTEM.FINE.DELTA. 

AFIELD.LAST 

A universal integer 

1 i tera i whose value i s 
TEn.IQ.rlELD’LAST. 

AFIXED.NAME 

The name o-f a predefined 
Fixed-point type other than 
DURATION. 

AFLOAT.NAHE 

The name oF a predefined 
floating-point type other than 
FLOAT, SHORT FLOAT, or 

LONG.FLOAT. 

IGREATER.THAN.DURATION 

A universal real literal that 
lies between DURATION’3ASE’LAST 
and DURATION’LAST or any value 
in the range of DURATION. 

‘GREATER.THAN.DUBATTON^gASE.LAST 

A universal reai literal that is 
greater than DURATION’BASE’LAST . 

JHIGH.PRIORITY 

An integer literal wnose value 
is the upoer bound of the range 
for the suptype SYSTEM.PRlOR ITY . 

*ILL£GAL.EXTERNAL_FILE_NAME1 

An external file name which 
contains invalid characters. 

A ILLEGAL.EXTERnal_bILE.NAME2 

An externa! file name which 
is too long. 

♦INTEGER.FIRST 

A universal integer literal 
whose value is INTEGER'FIRST. 


'z:* p.^rame: 

liim 

VAX.VMS 

2n.0«E-21 

512 

NO.S'JCH.nXED.TYPE 

LONG.LONG.FLOAT 

0.0 

200 . 000.0 

‘ C 

• «j 

abc!9def.cat 

abctdef.dat 

-2147483648 


C-3 







(jm ind !!£jiilQs 

$INTEGER.LAST 

A universal integer literal 
whose value is INTEGER’LAST. 

$INTEGER.LAST_PLUS.l 

A universal integer literal 
whose value is INTESER’LAST + 1. 

$LESS_THAN_DURATION 

A universal real literal that 
lies between DURATION’BASE’FIRST 
and DURATION’FIRST or any value 
in the range of DURATION. 

»LESS_THAN_DURATION_BASE_FIRST 

A universal real literal that is 
less than DURATION’BASE’FIRST. 

ILOU.PRIORITY 

An integer literal whose value 
is the lower bound o-f the range 
for the subtype STSTE.N.PRIORITY. 

SMANTISSA.DQC 

An integer literal whose value 
is SYSTEM.MAX.NANTISSA. 

»MAX.DIGITS 

Maximum digits supported for 
floating-point types. 

$HAX_IN_LEN 

Maximum input line length 
permitted by the implementation. 

IHAX.INT 

A universal integer literal 
whose value is SYSTEM.MAX_!NT . 

$HAX.INT_PLUS_1 

A universal integer literal 
whose value is SYSTEM.MAX_INT»1. 

$MAX_LEN_INT_BAS£D_LiTERAL 

A universal integer based 
literal whose value is Zttlltt 
with enough leading zeroes in 
the mantissa to be HAX_IN_LEN 
long. 


ValUfi 

2147482647 

2147483648 

- 0.0 

-:oo_ooo.c 

0 

31 

w w 

"'C S 

:'A74826-' 

21A74336-C 

"2:" S 250 * ’0’ i 


C-4 








Nm and SsfloiQa 

$NAX.LEN_REAL.BASED.LITERAL 

A universal real based literal 
whose value is 16:F.E: with 
enough leading zeroes in the 
rantissa to be MAX.IN.LEN long. 

JMAX.STRING.LITERAL 

A string 1iteraI of size 
NAX.IN.LEN, including the quote 
characters. 

SMIN.INT 

A universal integer literal 
wnose value is SYSTEM.MIN.INT. 

ININ.TASK.SIZE 

An integer literal whose value 
is the number a-f bits required 
to hold a task object which has 
no entries, no declarations, and 
"NULL;" as the only statement in 
its body. 

INAME 

A name of a predeTined numeric 
type other than FLOAT, INTEGER, 
SHORT FLOAT, SHORT INTEGER, 

LONG.FLOAT, or LONG,INTEGER. 

INAME.LIS: 

A list oF enumeration literals 
in the type SYSTEM.NAME, 
separated by commas. 

JNEG.EASED.INT 

A based integer literal wnose 
hignest oraer nonzero bit 

falls in the sign bit 
position ot the representation 

for SYSTEM.MAX.INT, 

SNE'J.MEM.SIZE 

An integer literal whose value 
is a permitted argument For 

pragma MEMORY SIZE, other than 
»D£FAULT.MEM_SIZE. IF there is 
no other value, then use 
ADEFAULT MEM SIZE. 


Vilug 

"16:" i 248 * '0' & 


i 253 * ’A’ S 

-2147A83648 


SHORT.SHORT.INTEGER 


VAX.VMS 


2,147.-183.648 








TEST PARAMETEaS 


$NEU_STOR.UNIT 

An integer literal whose value 
is a permitted argument Tor 
pragma STORAGE UNIT, other than 
♦DEFAULT.ST0R_UNIT. H there is 
no other permitted value, then 
use value oF SYSTEM.STORAGE.UMT. 

♦NEU.SYS.NAME 

A value of the type SYSTEM.NAME, 
other than ♦DEFAULT.SYS.NAHE. If 
there is only one value of that 
type, then use that value. 

♦TASK.SIZE 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
a single entry with one 'IN OUT’ 
parameter. 

♦ TICK 

Areal literal whose value is 
SYSTEM.TICK. 


Ul'li 

8 


VAX VMS 


0.01 


C-6 



APPENDIX D 


UITHORAUN TESTS 


Some tests are withdrawn ^rom the ACVC because they do not conform to the 
Ada Standard. The following 43 tests had bee.n withdrawn at the time of 
validation testing for the reasons indicated. A reference of the form 
Al-ddddd is to an Ada Commentary. 


a. E28005C This test expects that the string TOP OF PAGE. --63" 
of line 204 will appear at the too of the listing oage due to a 
pragma PAGE in line 202; but line 203 contains text that follows 
the pragma, and it is this that must aopear at the top of the 
page. 

b. A390053 This test unreasonably expects a component clause to pacx 
an array component into a minimum site '.line 301, 

3?7t02E This test contains an unitenoed illegality: a select 
statement contains a nuil statement at the olace of a selective 
wait alternative (I me 31). 

c. 3C2009S This test wrongiy e:^aects that circular instantiations 
will be detected in several conpilaimn units even tnougn none of 
the units is illegal with re- soect to the units it deoencs on; ov 
Al-00256. the illegality need not be detected until execution is 
attempted lline 951. 

e. CD2A62D This test wrongly reauires that an ar-av ooject’s sice be 
no greater than ID althoug.n its suctype’s sice was specified to be 
40 (line 13 <). 

f. C02A63A..D, CD:A66A..D, C02A73A..0, CO2A75A..0 l 16 tests] These 

tests wrongly attempt to check the size o- objects of a derived 
type (for which a 'SIZE length clause is given) by passing them to 
a derived sub- program (which implicitly converts them to the 
parent type (Ada standard 3.4:14)j. Aoa i t i onal ly, they use the 
'SIZE length clause and attribute, whose interpretation is 
considered problematic by the UG9 ARG. 


D-1 








5 


g. CD2A81S, CD2A83G, CD2A84N I M, I CD50110 C5 tests: These tests 
assume that dependent tasks will terminate while the main pro¬ 
gram executes a loop that simply tests tor task termination; this 
is not the case, and the main program may loop inoe-finitely (lines 
74, 85, 86 S 96, 86 & 96, and 58, resp.). 

h. CD2B15C i CD7205C These tests expect that a ’ST0RA6E_SIZE length 
clause proviaes precise con- trol over the number O'f designated 
objects in a collection; the Ada stanoard 13.2:15 allows that such 
control must not be expected. 

1. CD2D113 This test gives a SHALL representation clause for a 

derived Tixed-point type (at line 30) that de-fines a set of model 
numbers that are not necessarily represented in the parent type; 
by Commentary AI-00099, all model numbers of a derived fixed-point 
type must be representable values of tne parent type. 

j. CD5007B This test wrongly expects an implicitly declared 
subprogram to be at the the address that is specified for an 
unrelated subprogram (line 303). 

k. ED7004B, ED7005C & 0, ED7006C i 0 C5 tests! These tests check 
various aspects of the use of the three SYSTEM pragmas; the AVO 
withdraws these tests as being inappropriate for validation. 

l. C07105A This test requires that successive calls to CALENDAR,CLOCK 
Change by ax least SYSTEM.TIC.k; however, by Commentary AI-00201, 
!t is only the expected freauency of Change that must be at least 
SYSTEH.TIc;<--oarticular instances of change may be less (line 29). 

■h. CD72C3B, i CD7204B These tests use the 'SIZE length clause and 
attrioute. wnose interoretat ion is considered problematic bv the 
JG? ARG. 

n. CD7205D *n:s test cnecks an invalio test objective: it treats tne 
specification of storage to be reserves •''or a task’s activation as 
chougn i: were like the soec i-^‘i cat; on of storage for a collection. 

0 . CEZ107I This test reaui^es that Objects of two similar scalar 
tvoes be aistinguisneo when read fnom a fi1e--DATA_ERROR is 
expected to be raisea bv an attempt to read ore object as of the 
other type. However, it is not clear exactly now the Aaa standard 
14.2.4:4 is to be interpreted; thus, this test objective is not 
cons ioerea valid, (line 90) 

p. CESlllC This test requires certain behavior, wnen two files are 
associated with the same external file, that is not required by 
the Ada standard. 

q. CE3301A This test contains several calls to END_0F_LIN£ S 

END_0F_PAG£ that have no parameter: these calls were intended to 
specify a file, not to refer to STANOARD.INPUT (lines 103, 107, 


0-2 










-I'HDRA'JN 'EE'E 

118, 13:, i 126) . 

p. CE34113 This test -eauir'es tJiat s text - le’s column numcer be set 
to COUNT’LAS" in or:er to cnecx tnat ERROR :s raises oy a 

subsequent PUT ooe-ation. 9ut tie fcr-ne'" ooeration generally 

raise an excection aue to a locx oV ava’lacls disK soace, and tbe 
test woulo thus encumcer vaiiaat'on tect ng. 


D-3 






(V 


*. 


A = = :ND:'< £ 

■:3mp:lz.^ a,n£ .:nke^ :?':cm£ 


j c s e ni 


< ; :r 

■3 < ' 


■j ■' T a *. ' 'j 

.^^irucri^ iC 
;::imanci j 


; jnca-'i 


■= ::nD 


:ec. 


■3 J 









Compiling, Linking and Executing a Program 


Chapter 3 


3 Compiling, Linking and Executing a Program 


3.1 Overview 


After a program library has been created, one or more compilation units can be com¬ 
piled in the context of this library. The compilation units can be placed on different 
source files or they cam all be on the same file. One unit, a parameterless procedure, 
acts as main program. If all units needed by the main program and the main program 
itself have been compiled successfully, they can be linked. The resulting code can then 
be executed by giving a RUN command. 

§3.2 and §3.4 describe in detail how to call the Compiler and the Linker. Further on 
in §3.3 the Completer, which is called to generate code for instances of generic units, 
is described. 

§3.5 explains the information which is given if the execution of a program is abandoned 
due to an unhandled exception. 

The information the Compiler produces and outputs in the Compiler listing is explained 
in §3.6. 

Finally, the log of a sample session is given in §3.7. 


3.2 Starting the Compiler 


To start the SYSTEAM Ada Compiler, call the command 


$ (flADA:COMPILE <8ourc9> [LIBRARY=<director 7 >] - 

[0PTI0NS=<8tring>] 

[LIST»<file8pec>] 


The input file for the Compiler is <source>. If the file type of <source> is not specified, 
< 80 urce>.ADA is assumed. The maximum length of lines in <source> is 255; longer 
lines are cut and an error Is reported. 

<directory> is the name of the program library; t. ADALIB] is assumed if this parameter 
is not specified. The library must exist (see §2.2 for information on program library 
management). 




Chapter 3 


Compiling, Linking and Executing a Program 


The listing file is created in the default directory with the file name of <source> and the 
file type .LIS if no file specification <filespec> is given by the parameter LIST. Oth¬ 
erwise, the directory and file name are determined by the file specification <filespec>. 
If no full file specification is given, missing components are determined as described 
above (i.e. the default directory is used if no directory is specified, the file name of 
<souxce> if no file name is specified and the file type .LIS if the file type is missing). 
See §3.6 for information about the listing. 

Options for the Compiler can be specified by using the parameter OPTIONS; they 
have an effect only for the current compilation. <string> must have the syntaa 


"[option {. option}]" 

where blanks are allowed following and preceding lexical elements within the string. 
The Compiler accepts the following options: 


LIST => ON/OFF 

(default is OFF) 

OPTIMIZER => ON/OFF 

(default b ON) 

INLINE => ON/OFF 

(default is ON) 

COPY-SOURCE => ON/OFF 

(default is OFF) 

SUPPRESS-ALL 


SYMBOLIC-CODE 



The options LIST and SUPPRESS_ALL have the same effect as the corresponding 
pragmas would have at the beginning of the source (see [Ada,Appendix Bj and §7.1.2 
of this manual). 

No optimizations like constant folding, dead code elimination or structural simplifica¬ 
tions Me done if OPTIMIZER => OFF is specified. 

Inline expansion of subprograms which are specified by a pragma inline (cf. §7.1.1) 
in the Ada source can be suppressed generally by giving the option INLINE => OFF. 
The value ON will cause inline expansion of the respective subprograms. 

<^OPY_SOURCE —> ON causes the Compiler to copy the source file <source> into the 
program library. The Debugger of the SYSTEAM Ada System (cf. [ST16/87]) can 
then work on this copy (cf. §2.2.7) instead of on the original file. 

A symbolic code listing can be produced by specifying the option SYMBOLIC-CODE 
when calling the Compiler. The code listing is written on a file with file type .SYM 
whose file name and directory are identical with those of the listing file. 

The source file may contain a sequence of compilation units, cf. §10.1 of [Ada]. All com¬ 
pilation units in the source file are compiled individually. When a compilation unit is 






Compiling, Linking and Executing a Program 


Chapter 3 


» , 


compiled successfully, the program library is updated and the Compiler continues with 
the compilation of the next unit on the source Ele. If the compilation unit contained 
errors, they are reported (see §3.6). In this case, no update operation is performed on 
the program library and all subsequent compilation units in the compilation are only 
analyzed without generating code. 

The Compiler delivers the status code WARNING on termination (see [VAX/VMS, 
DCL Dictionary, command EXIT]) if one of the compilation units contained errors. 
A message corresponding to this code has not been defined; hence %NONAME-W- 
NOMSG is printed upon notification of a batch job terminated with this status. 


3.3 The Completer 

The Compiler does not generate code for instances of generic bodies. Since this must 
be done before a prograim using such instances can be executed, the COMPLETER 
tool must be used to complete such units. This is done implicitly when LINK is called. 

It is also possible to call the Completer explicitly by 


$ CADA;COMPLETE <ada_.naae> CLI3RARY=<directcry>] - 

[0PTI0NS=<3tring>j 
[LIST=<filespec>' 


<ada_name> must be the name of a library unit. .A.11 library units that are needed by 
that unit (cf. [Ada,§10.5|) are completed, if possible, and so are their subunits, the 
subunits of those subunits aind so on. The meaning of the parameters LIBRARY and 
LIST corresponds to that of the COMPILE command (cf. §3.2). Options apply to all 
units that are completed; the following ones are accepted (cf. §3.2): 


OPTIMIZER => ON/OFF 
INLINE => ON/OFF 
SUPPRESS_ALL 
SYMBOLIC-CODE 


The Completer delivers the status code WARNING on termination (see [VAX/VMS, 
DCL Dictionary, command EXIT]) if it detected some error. A message corresponding 
to this code has not been defined; hence %NONAME-W-NOMSG is printed upon 
notification of a batch job terminated with this status. 





Chapter 3 


Compiling, Linking and Executing a ProgrzLm 


In this case a listing file containing the error messages (cf. §3.6] is created. If no file 
specification <filespec> is given by the puameter LIST, the listing file is created in 
the default directory with file name COMPLETE and the file type .LIS; otherwise, the 
directory and file name are determined by the file specification <filespec>. If no full 
file specification is given, missing components are determined as described above (i.e. 
the default directory is used if no directory is specified, the file name COMPLETE if no 
file name is specified and the file type .LIS if the file type is missing). 


3.4 The Linker 

An Ada program is a collection of units used by a main program which controls the 
execution. The main program mxist be a parameterless library procedure; any param¬ 
eterless library procedure within a prog^ram library can be tised as a main program. 

The VAX/VMS system linker is used by the SYSTEAM Ada System Linker. 


To link a program, call the co mman d 


5 fiADA;LINK <ada_naiae> <filename> [LIBRARY=<directory>] - 

[0PTI0NS=<8tring>] - 
[LIST»<file8pec>] - 
[C0MPLETE»0N/0FF] - 
[DEBUG-ON/OFF] - 
[MAP«<file8pec>] - 
[SELECT-ON/OFF] - 
[EXTERNAL-<8tring>] - 
[LINK_0PT-<8tring>] 

<ada_name> is the name of the library procedure which acts as the main program. 

<filename> is the name of the file which is to contain the executable code after linking. 

If no filetype is specified, . EXE is assumed. 

<directory> is the name of the program library which contains the main program; 

[.ADALIB] is assumed if this parameter is not specified. 

The COMPLETE parameter specifies whether the program is to be completed before 

it is linked; default is ON. If the Completer is called, the parameters LIBRARY, 

OPTIONS and LIST are passed to it (cf. §3.3). 




Compiling, Linking and Executing a Program 


Chapter 3 


The DEBUG parameter specifies whether information for the SYSTEAM Debugger is 
to be generated; default is ON. 

If the MAP parameter is given, the map listing of the VAX/VMS linker is preserved 
in the specified file. If no directory or file name is specified within <filespec>, the same 
directory resp. file name is used as for the file that contains the executable code; the 
default filetype is .MAP. 

SELECT=ON causes the object code of subprogram bodies to be included in the 
executable program only if this subprogram may be called during program execution. 
In the case of OFF the code of all compilation units mentioned in a context clatise (in 
a transitive manner) is linked together; the default is OFF. 

The EXTERNAL parameter specifies object files or libraries which contain object 
modules of those program units which are not written in Ada (e.g. object modules of 
subprograms written in assembly language). For those program units the pragmas 

PRAGMA interface (VMS. ... ) -- (cf. §7.1.1) 

(or Interface (assembler, ... ) ) and 

PRAGMA external-name (...) — (cf. §7.1.1) 

must be given in the Ada source. 

<string>, specified by the parameter EXTERNAL, is a string literal that denotes the 
names of the external object files. It will be passed to the V.A.X VMS linker (cf. 
[VAX/VMS, Linker') without examining its correctness and for that reason it must 
have the VMS format; 


file_spec [/file-qualifier] {. file-spec [/file_quaiifier]} 


file_spec specifies one input file. An input file can be an object file or an object 
library if the file-qualifier /LIBRARY or /INCLUDE is given. Multiple input files can 
be specified, separating the file specifications by co mm as. 

Example: 

EXTERNAL="A.OBJ.B.OLB/LIB" 

A denotes an object file, B an object library file 


The pau’ameter LINK-OPT can be used to specify qualifiers for the VAX/VMS linker. 
Note that the starting character ’/’ m\ist be given for each qualifier. 


The following steps are performed during linking. First the Completer is called, unless 
suppressed by COMPLETE=OFF, to complete the bodies of instances. Then the 








I 

l>- »• 

Chapter 3 Compiling, Linking and Executing a Program 


Pre-Linker is executed; it determines the compilation units that have to be linked 
together zmd a valid elaboration order. A code sequence to perform the elaboration is 
generated. Finally, the VAX/VMS linker is invoked to link all the object f.les including 
those specified by the EXTERNAL parameter. The command qualifiers passed to the 
VAX/VMS linker (cf. (VAX/VMS, Linker)) are those specified by the LINK-OPT 
parameter; the file specification names, in this order, two object files containing Ada 
object code, an object library which contains the runtime system, and the files specified 
by the EXTERNAL parameter. 

The Linker of the SYSTEAM Ada System delivers the stat\is code WARNING on 
termination (see [VAX/VMS, DCL Dictionary, command EXIT]) if one of the above 
mentioned steps failed (e.g. if one of the completed units contained errors, if any 
compilation unit cannot be found in the program library or if no valid eleboration order 
cam be determined because of incorrect usage of the pragma elaborate). A message 
corresponding to this code has not been defined; hence %NONAME-W-NOMSG is 
printed upon notification of a batch job terminated with this status. 


3.5 Executing a Program 

After linking, the program can be executed by giving the command 


$ RUN <filenane> 


REST 


DELETED 







