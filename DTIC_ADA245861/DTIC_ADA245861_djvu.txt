1 


AD-A245 861 tationpage 


Form Approved 
OPM No. 0704 018S 


X p«f racponu, Including dm* tor reviewing instructions, searcMng existing data sources gathering and maintaining the data N 
urden estimate or any other aspect ot Ihle coUeclbn ol Mormatba Including suggestions for reducing ihle burden, to Washingkin 
tereon Oavie Highway, Sula 1204, Arlinglon, VA 22202-4302, and to die Office ot Information and R^ulalory Alfain, Office of 


1. AGENCY USE ONLY (Leave Blank) 


4 . TITLE AND SUBTITLE 


2, REPORT DATE 


3. REPORT TYPE AND DATES COVERED 

Final: 16 Nov 1990 to 01 Jun 1993 


Rational. M68020/Unix Cross-Development Facility, Version 7, RIOOO Series 300 
(Host) to Hewlett Packard HP9000 Model 370MH (Target). 901116w1.11082 


6. AUTHOR(S) 

Wright-Patterson AFB, Dayton, OH 
USA 


. PERFORMING ORGANIZATION NAME(S) AND A00RESS(ES) 

Ada Validation Facility, Language Control Facility ASD/SCEL 
Bldg. 676. Rm 135 

Wright-Patterson AFB, Dayton. OH 45433 



8. PERFORMING ORGANIZATION 
REPORT NUMBER 

AVF-VSR-425-1290 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm 3E114 
Washington. D.C. 20301-3081 


11. SUPPLEMENTARY NOTES 


12a. DISTRIBUTION/AVAILABILITY STATEMENT 

Approved for public release: distribution unlimited. 


10. SP0NS0RINGA40NIT0RING AGENCY 
REPORT NUMBER 


0 % ELECTS 
FEB 10 1992 



13. ABSTRACT (Maximum 200 words) 

Rational, M68020/Unix Cross-Development Facility, Version 7, Wright-Patterson AFB, RIOOO Series 300 (Host) to Hewlett 
Packard HP9000 Model 370MH (Target), ACVC 1.11. 


92-03165 



14 SUBJECT TERMS 


Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17. SECURITY CLASSIFICATION 
OF REPORT 

UNCLASSIFIED 


NSN 7540-01-280-550 


18. SECURITY CLASSIFICATION 


UNCLASSIFED 


19. SECURITY CLASSIFICATION 
OF ABSTRACT 

UNCLASSIFIED 


15. NUMBER OF PAGES 


16. PRICE CODE 


20. LIMITATION OF ABSTRACT 


Standard Form 298, (Rev. 2-89) 
Prescribed by ANSI Std. 239-128 























J 


Certificate Information 


The following Ada inplementation was tested and determined to pass ACVC 
1.11. Testing was conpleted on 16 November 1990. 

Conpiler Name and Version: M68020/Unix Cross-Development Facility, 

Version 7 


Host Computer System: RIOOO Series 300, 

Rational Environment Version D_12_24_0 

Target Conpjter System: Hewlett Packard HP9000 Model 370MH, 

HP Unix Version 7 


Customer Agreement Number: 90-07-20-RAT 


See Section 3.1 for any additional information about the testing 
envi ronment. 

As a result of this validation effort. Validation Certificate 

901116W1.11082 is awarded to Rational. This certificate expires on 1 Ji:ine 

1993. 

This report has been reviewed and is approved. 



Ada Validation Facility 
Steven P. Wilson 
Technical Director 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 



)rganization 

iter & Software Engineering Division 
5r Defense Analyses 
Alexandria VA 22311 


Ma Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 



AVF Control Number: AVF-VSR-425-1290 

19 November 1991 
90-07-20-RAT 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 901116W1.11082 
Rational 

M68020Afftix Cross-Development Facility, Version 7 
RIOOO Series 300 »> Hewlett Packard HP9000 Model 370MH 


Prepared By: 

Ada Validation Facility 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 




Certificate Information 


The following Ada inplementation was tested and determined to pass ACVC 
1.11. Testing was completed on 16 November 1990. 

Conpiler Name and Version: M68020/Uhix Cross-Developnent Facility, 

Version 7 

Host Conpater System: RIOOO Series 300, 

Rational Environment Version D_12_24_0 

Target Conpater System: Hewlett Packard HP9000 Model 370MH, 

HP Ikaix Version 7 


Customer Agreement Number: 90-07-20-RAT 


See Section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 

901116W1.11082 is awarded to Rational. This certificate expires on 1 Joone 

1993. 

This report has been reviewed and is approved. 



Ada Validation Facility” 
Steven P. Wilson 
Technical Director 


ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 



Ada 

Dire(^or, 
Institute 
Alexcindria VA 


n/Ofganization 

ter & Software Engineering Division 
Defense Analyses 
22311 


Ada Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 





DECLARATION OF CONFORMANCE 


Customer: Rational 

Ada Validation Facility: ASD/SCEL, Wright-Patterson AFB OH 45433-6503 

ACVC Version: 1.11 


Ada Implementation 


Compiler Name: M68020AJnix Cross-Development Facility, Version 7 

Host Architecture: RIOOO Series 300 

Host Operating System: Rational Environment Version D_12_24_0 


Target Architecture: Hewlett Packard HP9000 Model 370MH 

Target Operating System: HP_Unix Version 7 


Customer's Declaration 


r, the undersigned, representing Rational, declare that Rational has no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STD-1815A in the implementation 
listed in this declaration. I declare that Rational is the owner of the above implementation and 
the certificates s^all be awarded in the name of the owners corporate name. 

/J _ Date: _ 

David H. Bernstein 

Vice President, Products Group 


Rational 

3320 Scott Blvd 

Santa Clara, CA 95054 



Acer's 

For 


r:TiS 

CRASl 


DSC 

1 mH 


ijin:;: 

)r.ii ■ 

1 



.. 


I By . 







TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPEIIDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORTIATICM 

3.1 TESTING ENVIRONMEIxIT .3-1 

3.2 SUMMARY OF TEST RESULTS .3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX F OF THE 


STANDARD 















CHAPTER 1 


INTRODUCTICW 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro90] against the Ada Standard [Ada83] using the 
current Ada Conpiler Validation Capaibility (ACVC). This Validation Summary 
Report (VSR) gives an accoxont of the testing of this Ada inplementation. 

For any technical terms used in this report, the reader is referred to 
[Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make fxill and free public disclosure of this report. 
In the United States, this is provided in accordance with the "Freedom of 
Inrormation Act" (5 U.S.C. #552). The results of this validation apply 
only to the computers, operating systems, and con5)iler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and con^lete, or that the subject implementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 


Questions regarding this report or the validation test results should be 
directed to the AVF v^ich performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1-1 




INTRODUCTICW 


1,2 REFERENCES 


(Ada83] Reference Manual for the Ada Proqrairaning Language, 

ANSI/MIL-STI>-1815A, February 1983 and ISO 8652-1987. 


[Pro90] Ada Compiler Validation Procedures, Version 2.1, Ada Joint Program 
Office, August 1990. 


[UG89] Ada Coirpiler Validation Capability User's Guide, 21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes; 

A, B, C, D, E, and L. The first letter of a test name identifies the class 
to which it belongs. Class A, C, D, and E tests are executable. Class B 
and class L tests are expected to produce errors at compile time and link 
time, respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library unios, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are user. :or this purpose. The package REPORT 
also provides a set of Identity funoT:ons used to defeat some compiler 
optimizations allowed by the Ada Star, .ard that would circumvent a test 
objective. The package SPPRT13 is us?a by many tests for Chapter 13 of the 
Ada Standard. The procedure CHEC;<_‘:iT is used to check the contents of 
text files written by some of the 'Ir.ss S tests for Chapter 14 of the Ada 
Standard. The operation of REPORi .inr JHECK_FILE is checked by a set of 
executable tests. If these units rr-t act operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler recects illegal language usage. Class 
B tests are not executable. Each tes: la this class is conpiled and the 
resulting compilation listing is co verify that all violations of 

the Ada Standard are detected. Sc-,- -t rne class 2 tests contain legal Ada 
code which must not be flagged ill;r.-_ r. the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple , .separately compiled units. Errors 
are expected at link time, and execucicn is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — fci example, the largest integer. A list 
of the values used for this implemer.tacion is provided in Appendix A. In 
addition to these anticipated tesc -reifications, additional changes may be 
required to remove unforeseen confliccs between the tests and 
implementation-dependent charactericcirs. The modifications required for 
this implementation are described :.c :-ection 2.3. 








INTRODUCTION 


For each Ada implementation, a customised test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragraph, removing withdrawn tests (see section 2.1) and, 
possibly some inapplicable tests (see Section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler 


Ada Compiler 
Validation 
Capability 
(ACVC) 

Ada 

Implementation 

Ada Joint 
Program 
Office (AJPO) 

Ada 

Validation 
Facility (AVF) 

Ada 

Validation 

Organization 

(AVO) 

Compliance of 
an Ada 

Implementation 

Computer 

System 


The software and any needed hardware that have to be added 
to a given host and target computer system to allow. 
transformation of Ada programs into executable form and 
execution thereof. 

The means for testing :cmpliance of Ada implementations, 
consisting of the test suite, the support programs, the ACVC 
user's guide and the template for the validation summary 
report. 

An Ada compiler with its host computer system and its 
target computer system. 

The part of the certification body vdiich provides policy and 
guidance for the Ada certification system. 


The part of the certification body which carries out the 
procedures required cc establish the compliance of an Ada 
implementation. 

The part of the certification body that provides technical 
guidance for operaticr.s of the Ada certification system. 


The ability of the iracismentation to pass an ACVC version. 


A functional unit, ccncisting of one or more computers and 
associated software, -Cat uses common storage for all or 
part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or cscr-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and Icgic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may :e a stand-alone unit or may consist of 
several inter-ccnnectof mits. 








INTROWJCTI(»I 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inappliccible 

test 

ISO 

LRM 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


Fulfillment by a product, process or service of all 
requirements specified. 

An individual or corporate entity who enters into an 
agreement with an AVF vdiich specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A conputer system where Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives foiand to be ' 
irrelevant for the given Ada implementation. 

International Organization for Standardization. 

The Ada standard, or Lauiguage Reference Manual, published as 
ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRM take the form "<section>.<siabsection>:<paragraph>." 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
conplete hardware inplementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AW testing or by registration [Pro90]. 

The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 




CHAPTER 2 

IMPLEMENTATION DEPENDENCIES 


2-1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of v/ithdrawn tests is 12 October 1990- 


E28005C 

B28006C 

C34006D 

B41308B 

C43004A 

C45114A 

C45346A 

C4 5612b 

C4565LA 

C46022A 

B49008a 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

B85001L 

C83026A 

C8304LA 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B05A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A4Lk 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4031D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD70C6E 

AD7201A 

AD7201E 

CD7204B 

BD8002A 

BD8004C 

CD9003A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3118A 

CE3411B 

CE34i:3 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE39023 





2-2 INAPPLICABLE TESTS 

A test is inapplicable if it contains lest objectives which are irrelevant 
for a given Ada implementation, hsasrns for a test's inapplicability may 
be supported by documents issued oy 130 and the AJPO known as Ada 
Commentaries and commonly references in che format Al-ddddd. For this 
implementation, the following teste -ere determined to be inapplicable for 
the reasons indicated; references lo Ada Commentaries are included as 
appropriate. 







IMPLEMENTATICW DEPENDENCIES 


The following 201 tests have floating-point type declarations requiring 
more digits than SYSTEM.MAX_DIGITS: 

C24113L..y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 

C35708L..Y (14 tests) C35802L..Z (15 tests) 

C45241L..Y (14 tests) C45321L..Y (14 tests) 

C45421L..Y (14 tests) C45521L..Z (15 tests) 

C45524L..Z (15 tests) C45621L..Z (15 tests) 

C45641L..Y (14 tests) C46012L..Z (15 tests) 

The following 21 tests check for the predefined type LONG_INTEGER: 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45612C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001W 

C86006C 


CD7101F 

C35702A, C35713B, C45423B, B86001T, and C86006H check for the predefined 
type SHORT_FLClAT. 

C35713D cind B86001Z check for a predefined floating-point type with a 
name other than FLOAT, LONG_FLOAT, or SHORT_FLQAT. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations for 
types that require a SYSTEM.MAX_f1ANTISSA of 47 or greater; for this 
implementation, MAX_MANTISSA is less than 47. 

C45624A checks that the proper exception is raised if MACHINE_OVERFLCWS 
is FALSE for floating point types with digits 5. For this 
implementation, MACIINE_OVERFLCWS is TRUE. 

C45624B checks that the proper exception is raised if MACHINE_OVERFLCWS 
is FALSE for floating point types with digits 6. For this 
implementation, MACHINE_OVEIRFLOWS is TRUE. 

B86001Y checks for a predefined fixed-point type other than DURATION. 

C96005B checks for values of type DURATION'BASE that are outside the 
range of DURATION. There are no such values for this implementation. 

CD1009C uses a representation clause specifying a non-default size for a 
floating-point type. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use representation 
clauses specifying non-default sizes for access types. 


2-2 




IMPLEMENTATION DEPENDENCIES 


CD2B15B checks that STORAGE ERROR is raised ^en the storage size 
specified for a collection Ts too small to hold a single value of the 
designated type; this implementation allocates more space than was 
specified by the length clause, as allowed by AI-00558. 

BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code 
insertions. 

AE2101d, EE2401D, and EE2401G use instantiations of package DIRECT_IO 
with unconstrained array types and record types with discriminants 
without defaults. These instantiations are rejected by this compiler. 

The tests listed in the following table are not applicable because the 
given file operations are supported for the given combination of mode 
and file access method. 


Test 

File Operat 

ion .'lode 

File Access Method 

CE2102D 

CREATE 

IM FILE 

SEQUENTIAL 10 

CE2102E 

CREATE 

CUT FILE 

SEQUENTIAL 10 

CE2102F 

CREATE 

IMOlir FILE 

DIRECT 10 

CE2102I 

CREATE 

IN FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE2102O 

BESET 

i:: FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

CUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INCUT FILE 

DIRECT 10 

CE2102S 

RESET 

INGUT~FILE 

DIRECT 10 

CE2102T 

OPEN 

file 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

CUT FILE 

DIRECT 10 

CE2102W 

RESET 

CUT FILE 

DIRECT 10 

CE3102E 

CREATE 

IN FILE 

TEXT 10 

C23102F 

RESET 

.Tny Node 

TEXT 10 

CE3102G 

DELETE 

— 

TEXT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT 10 

CE3102J 

OPEN 

IN FILE 

TEXT 10 

CE3102K 

OPEN 

CUT FILE 

TEXT 10 


CE2203A checks that WRITE raises uSE_ERROR if the capacity of the 
external file is exceeded for 3ECUEin:iAL_I0. This implementation does 
not restrict file capacity. 

CE2403A checks that WRITE raises USE_ERF.OR if the capacity of the 
external file is exceeded for DI~ECT_I0. This implementation does not 
restrict file capacity. 

CE3111B, CE3111D..E (2 tests), CEilliB, and CE3115A attempt to associate 
multiple internal files with the s^Lme external file when one or more 
files is writing for text files. The proper exception is raised when 
multiple access is attempted. 


_-3 






implemeotation dependencies 


CE3304A checks that USE_ERROR is raised if a call to SET LINE LENGTH or 
SET_PAGE LENGTH specifies a value that is inappropriate Tor tHe external 
file. tEIs in^)lementation does not have inappropriate values for either 
line length or pag“ length. 

CE3413B checks that PAGE raises LAYOUT_ERROR v^en the value of the page 
number exceeds COUNT'LAST. For this implementation, the value of 
COUNT'LAST is greater than 150000 making the checking of this objective 
inpractical. 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 99 tests. 


The following tests were split into two or more tests because this 
iitplementation did not report the violations of the Ada Stcindard in the way 
expected by the original tests. 


B22003A 

B22003B 

B22004A 

B22004B 

B22004C 

B23002A 

B23004A 

B23004B 

B24001A 

B24001B 

B24001C 

B24005A 

B24005B 

B24007A 

B24009A 

B24204B 

B24204C 

B24204D 

B25002B 

B26001A 

B26002A 

B26005A 

B28003A 

B28003C 

B29001A 

B2A003B 

B2A003C 

B2A003D 

B2A007A 

B32103A 

B33201B 

B33202B 

B33203B 

B33301A 

B33301B 

B35101A 

B36002A 

B37106A 

B37205A 

B37307B 

B38003A 

B38003B 

B38009A 

B38009B 

B41201A 

B44001A 

B44004A 

B44004B 

B44004C 

B44004D 

B44004E 

B45205A 

B48002A 

B48002D 

B53003A 

B55A01A 

B56001A 

B63001A 

B63001B 

B64001B 

B64006A 

B67001A 

B67001B 

B67001C 

B67001D 

B67001H 

B71001A 

B71001G 

B71001M 

B74003A 

B74307B 

B83E01C 

B83E01D 

B83E01E 

B91001F 

B91001H 

B91003E 

B95001D 

B95003A 

B95004A 

B95006A 

B95007B 

B95079A 

BAIOOIB 

BB3005A 

BC1109A 

BC1109B 

BC1109C 

BC1109D 

BC1303F 

BC2001D 

BC2001E 

BC3003A 

BC3003B 

BC3005B 

BC3013A 

BE2210A 

BE2413A 

asiooiA 





2-4 



CHAPTER 3 


PROCESSING IMFORIIATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact for technical information about this Ada 
implementation system, see; 

David H. Bernstein 
3320 Scott 3lvd. 

Santa Clara CA 95054 

For a point of contact for sales information about this Ada implementation 
system, see: 


David H. Bernstein 
3320 Scott Bivd. 
Santa Clara CA 95054 


Testing of this Ada implementation --/as conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given AC/C version if it processes each test 
of the customized test suite in acocrfanoo ■:ith the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pio90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


a) Total Number of Applicable Tests 

b) Total Number of Withdra^m Tests 


3803 

81 






PROCESSING INFORMATIOJ 


c) 

Processed Inapplicable Tests 

85 


d) 

Non-Processed I/O Tests 

0 


e) 

Non-Processed Floating-Point 




Precision Tests 

201 


f) 

Total Number of Inapplicable Tests 

286 

(c+d+e) 

g) 

Total Number of Tests for ACVC 1.11 

4170 

(a+b+f) 


All I/O tests of the test suite were processed because this implementation 
supports a file system. The cibove number of floating-point tests were not 
processed because they used floating-point precision exceeding that 
supported by the implementation. When this compiler was tested, the tests 
listed in section 2.1 had been withdrawn because of test errors. 


3.3 TEST EXECUTION 

Version 1.11 of the ACVC comprises 4170 tests. When this compiler was 
tested, the tests listed in section 2.1 had been withdrawn because of test 
errors. The AVF determined that 286 tests were inappliceible to this 
implementation. All inapplicable tests were processed during validation 
testing except for 201 executable tests that use floating-point precision 
exceeding that supported by the implementation. In addition, the modified 
tests mentioned in section 2.3 were also processed. 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the validation team for processing. The contents of the 
magnetic tape were loaded directly onto the host conputer. 


After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada implementation. 


The tests were compiled and partially linked on the host computer system, 
as appropriate. The executable images were transferred to the target 
computer system via FTP, vrtiere the final link step was performed. The 
executable images were then cun. The results were captured on the host 
computer system. 


Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a complete listing of 
the processing options for this implementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were; 


3-2 




PROCESSING INFORMATION 


Option I Switch Effect 

Create_Subprograin_Specs = False when a library unit subprogram body is added 

to the progreim library, do not automatically 
create a corresponding subprogram 
specification. 

Linker_Coinmand_File = '' 1VALIDATION..ACVC_1_11.MC68020_HP_UNIX.MISCELLANY. 

MODIFIED_LINKER_COMMANDS" 

Overrides the default linker command file 
with one that specifies inclusion of 
assembly language modules needed for pragma 
interface tests. 

Remote directory = "/usr/local/test/validation" 

specifies directory on HP Unix machine where 
executable image will be placed. 

Remote machine = "pip" specifies name of HP Unix machine used 

for execution. 


Test output, compiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 






APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string aggregates, where "V" represents the maximum input-line 
length. 


Macro Parameter 


Macro Value 


$BIG_ID1 

(1..V-1 -> 'A', V -> '1') 

$BIG_ID2 

(1..V-I -> 'A', V => '2') 

$BIG_ID3 

(1..V/2 -> 'A') & '3' & 
(1..V-1-V/2 =»> 'A') 

$BIG_ID4 

(1..V/2 => 'A') & '4' & 
{1..V-1-V/2 -> 'A') 

$BIG_INT_LIT 

(1..V-3 »> '0') & "298” 

$BIG_REAL_LIT 

(1..V-5 »> '0') & "690.0" 

$BIG_STRING1 

& {1..V/2 »> 'A') & 

$BIG_STRING2 

& (1..V-1-V/2 =■> 'A') & 

$BLANKS 

(1..V-20 => ' ') 


$MAX_LEN_INT_BASED_LITERAL 

"2:" & (1..V-5 => '0') & "11:" 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => '0') & "F.E:" 

$MAX_STRING_LITERAL & (1..V-2 -> 'A') & 


A-1 



MACRO PARAMETERS 


The following table lists all of the other macro parameters and their 
respective values. 


Macro Parameter 

Macro Value 


$MAX_IN_LEN 

254 


$ACC_SI2E 

32 


$ALI®IMENT 

1 


$COUNT_LAST 

1000000000 


$DEFAULT_MEM_SIZE 

2147433647 


$DEFAULT_STOR_UNIT 

8 


$DEFAULT_SYSJSIAME 

[1063020 HP_UNIX 


$DELTA_DOC 

0.0000000004656612873077392578125 

$ENTRY_ADDRESS 

SYSTEM.TO_ADDRESS 

(16) 

$ENTRY_ADDRESS1 

SYSTEM . TO_ADDRESS 

(17) 

$ENTRY_ADDRESS2 

SYSTEM . TO_ADDRESS 

(21) 

$FIELD_LAST 

21-7 ;33647 


$FILE_TERMINATOR 

f • 


$FIXED_NAME 

::0_£UCH_TYPE 


$FLCIAT_NAME 

MC_3UCH_TYPE 


$FORM_STRING 

It It 


$F0RM_STRING2 

"CEINOT RESTRICT_FILE CAPACITY" 

$GREATER THAN DURATION 

1.0 


SGREATER THAN DUHATIO.M LAST 

101073.0 


$GREATER_THAN_FLOAT_ 

BASE EAST 

2.:e308 


$GREATER THAN FLOAT 

SAFE LARGE 



:=iiiiiiiiiiiiiiiii.iiiiiiiitEiii 






MACRO PARAMETERS 


$GREATER THAN SHORT FLQAT_SAFE_LARGE 

1.0E30a 

$HIGH_PRIORITY 255 

$ILLEGAL_EXTERNAL_FILE_NAMEl _ 

BAD/_CHARACTERS 

$ILLEGAL EXTERNAL FILE_NAME2 _ 

~ CONTAINS/_ILLEGAL_CHARACTER 

$INAPPROPRIATE LINE LENGTH 

~ -1 

$INAPPROPRIATE PAGE LENGTH 

~ -1 

$INCLUDE_PRAaiAl PRAC^ INCLUDE ( "A28006D1 .TST") 

$INCLUDE_PRAGMA2 PRAGMA INCLUDE (’’B28006F1 .TST" ) 

$INTEGER_FIRST -2147483648 

$INTEGER_LAST 2147483647 

$INTEGER_LAST_PLUS_1 2147483648 

$INTERFACE_LANGUAGE ASM 

$LESS_THAN_DURATia4 -1.0 

$LESS THAN DURATION BASE FIRST 
~ ~ ~ -111073.0 

$LINE_TERMINATOR ASCII.LF 

SLOWPRIORITY 0 

$MACHINE CODE_STATEMENT 

NULL; 

$MACHINE_CODE_TYPE NULL 

$MANTISSA_DOC 31 

$MAX_DIGITS 15 

$MAX_INT 2147483647 

$MAX_INT_PLUS_1 2147483648 

$MIN INT -2147483648 

A-3 




macho parameters 


$NAME 

SHORT SHORT_INTEGER 

$NAME_LIST 

MC68020_HP_UNIX 


$NAME_SPECIFICATIONl 

X2120A 


$NAME_SPECIFICATION2 

X2120B 


$NAME_SPECIFICATION3 

X3119A 


$NEG_BASED_INT 

16#FFFFFFFE# 


$NEW_MEM_SI2E 

2147483647 


$NEW_STOR_UNIT 

8 


$NEW_SYS_NAME 

HC68020_HP_UNIX 


$PAGE_TERMINATOR 

ASCII.FF 


$RECORD_DEFINITION 

MB'! INTEGER 


$RECORD_NAME 

NO SUCH MACHINE_CODE_TYPE 

$TASK_SI2E 

32 


$TASK_STORAGE_SI2E 

16584 


STICK 

2.0E-02 


$VARIABLE_ADDRESS 

SY5T31.TO_ADDRESS 

<J\ 

O 

O 

$VARIABLE_ADDRESS1 

SYSTEM.TO_ADDRESS 

(16#012C#) 

SVARIABLE ADDRESS2 

SYSTEM.TO_ADDRESS 

(16#01BC#) 


$YOUR PRAGMA 


NICKNAME 




APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler and linker options of this Ada inplementation, as described in - 
this Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 

PROCESSOR SWITCH TYPE VALUE 

Cross_Cg . Asm_Source : Boolean :» False 

— Controls retention of assembly source code generated by the compiler. 

Cross_Cg . Auto Download : Boolean :» True 

— Controls whetHer the result of partially linking a main program is 

— automatically downloaded to the target machine, using FTP switches to 

— determine the destination, ^plies only to targets that have a final 

— link step on the target machine. 

Directory . Create_lnternal Links ; Boolean :* True 

— Controls whether internaT links are created automatically when the 

— visible parts of library units are created. Internal links for library 

— units are created in the set of links for the nearest enclosing world. 

— The default is True. The full switch name is 

— Directory.Create_Internal_Links. (For further information on links, see 

— the Key Concepts section of the Library Management (LM) Reference 

— Manual.) . 

* Directory . Create_Subprogram_Specs ; Boolean := False 

— Controls whether specifications for library-unit siobprograms are created 

— automatically. The contents of these specifications are created the 

— first time the body is successfully installed. The "with" clause for 

— the specification is derived from the "with" clauses in the body. Only 

— those "with" clauses required to promote the specification are included. 

— The default is True. The full switch name is 

— Directory.Create_Subprogram_Specs. 

Cross_Cg . Debugging_Level : Debug_Level := Full 

— Cross_Cg.Debugging Level controls the amount of debugging assistance put 

— into the object itmule when coding an Ada unit. 


B-1 



COMPILATION SYSTEM OPTIONS 


— The possible values are: 

— None : (Default) No debugging information produced. 

— Partial : Debugging tables produced but optimizations are not 

— inhibited. 

— Full : Debugging tables produced, and optimizations inhibited. 

— "Optimizations inhibited" means that code motion across statement 

— boundaries will not occur, and the lifetimes of variables will not be 

— reduced. 

Cross_Cg . Enable_Code Pooling ; Boolean False 

— When true, optimizations which would prevent link time code pooling are 

— inhibited. Link time code pooling is only attempted on units that were 

— compiled with this switch set to True. 

Cross_Cg . Inlining_Level : Inlining_Level :=■ Inter_Uni 

— Cross_Cg.lnlining_Level determines how the compiler treats Pragma 

— Inline. 

— The possible values are: 

— None ; Ignore pragma Inline. 

— Intra_Unit : Honor pragma Inline within a compilation unit, but ignore 

— pragma Inline applied to subprograms in other conpilation units (thus 

— avoiding introduction of additional compilation dependencies). 

— InterJJnit : (Default) Honor all Inline pragmas. 

— Full : Honor all Inline pragmas, and additionally perform 

— automatic inlining of small subprograms within a conpilation unit. 

Cross_Cg . Linker_Command File : String :* 

"!VALIDATION. ACVC_1_11.MC^8020_HP_UNIX.MISCELLANY.MODIFIED_LINKER_COMMANDS" 

— Cross Cg.Linker Coramcind File overrides the default file name for the 

— linker command Tile. TEe name of the linker command file is resolved in 

— the context of the current switch file. 

Cross_Cg . Linker_Cross_Reference : Boolean :» False 

— Cross_Cg.Linker_Cross_Reference controls whether a cross-reference of 

— external symbols to modules being linked is produced in the link map. 

Cross_Cg . Linker_Eliminate_Dead_Code : Boolean := True 

— Cross Cg.Linker_Eliminate_Dead_Code controls whether the linker removes 

— unreacheUjle subprograms from the executable program image. 

Cross_Cg . Linker_Pool_Code : Boolean := False 

— Controls whether the linker eliminates redundant subprograms from the 

— executaible program image. Redundant subprograms are those that are 

— reachable from the main program but whose code is identical to that of 

— some other subprogram in the progreun. Only corap units that were 
compiled with the switch Enable_Code_Pooling set to True are eligible 

— for code pooling at link time, 

Cross_Cg . Linker_Pool_Literals : Boolean := True 

— Controls whether the linker eliminates redundant literals from the 

— executable program image. 


B-2 






COMPILATION SYSTEM OPTIONS 


Cross_Cg . Listing : Boolean := False 

— Controls generation of machine code listing file. 

Cross_Cg . Optimization_Level : Integer range 0 .. 3 := 3 

— Cross_Cg.Optimization_Level controls the amount of optimization 

— performed during code generation. 

— The possible values are: 

— 0 : Minimal Optimization 

— 1 ; Unimplemented 

— 2 : Unimplemented 

— 3 : Maximal Optimization. 

Directory . Require_Internal_Links : Boolean := True 

— Controls whether failure to create internal links (as controlled by the. 

— Directory.Create_Internal Links switch) generates ein error. The default 

— (True) is to treat the faTlure to generate links as an error and to 

— discontinue the operation. If the Directory.Create_Internal_Links 

— switch is set to False, this switch has no effect. The full switch name 

— is Directory.Require_Internal_Links. 

Cross_Cg . Suppress_All Checks : Booleein := False 

— When true, this switcH has the same effect as a pragma Suppress_All at 

— the beginning of the each Ada unit in the library. 

Cross_Cg . Target_Linker_Script : String :* "" 

— Cross_Cg.Target_Linker Script overrides the default file name for the 

— target linker script file. This name of this file is resolved in the 

— context of the current switch file. This switch applies only to targets 

— having a final link step on the target machine. 


B-3 





APPD-IDIX C 

APPEM)IX F OF TI?E Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, eind to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this ^pendix are to compiler documentation and not to this 
report. Inplementation-specific portions of the package STANDARD, which 
are not a part of i^pendix F, are: 


package STANDARD is 


type Integer is range -2147-83648 .. 2147483647; 
type Short_Short_Integer is range -128 .. 127; 
type Short_Integer is range -32768 .. 32767; 

type Float is digits 6 rancre -16#1.FFFF_FE# * 2.0 ** 127 .. 

16#1.FFFF_FE# * 2.0 ** 127; 

type Long_Float is digits 15 range 

-16#1.FFFF_FFFF_FFFF_F# * 2.0 ** 1023 .. 
16#1.FFFF_FFFF_FFFF_F# * 2.0 ** 1023; 

type Duration is delta 16?1.0» * 2.0 ** (-14) 

range -1641.0# * 2.0 **17 .. 

i6#l.FFFF FFFC# * 2.0 ** 16; 


end STANDARD; 


I 





Appendix IV: Appendix F to the LRM 

for the M68020/HP-UX Target 


Appendix F describes the implementation-dependent features of the Ada language, as it-is 
implemented for the M68020/HP-UX target. If you are using a CDF to compile programs for 
other targets, refer to the Appendix F that is provided with the documentation for that CDF, If 
you are compiling programs for an RIOOO target, refer to the Appendix F for the RIOOO target. 

Appendix F is a recpjired part of the Reference Manual for the Ada Programming Language (LRM) 
and is divided into the seaions listed below: 

• “Implementation-Dependent Pragmas" describes the form, allowed places, and effea of every 
implementation-dependent pragma. 

• "Implementation-Dependent Attributes" describes the name and type of every 

implementation-dependent attribute. 

• “Packages Standard and System” presents the specifications of packages Standard and System. 

• “Support for Representation Causes" lists all of the restrictions on representation clauses. 

• “Implementation-Generated Names” describes the conventions used for any 

implementation-generated name denoting implementation-dependent components of reconii. 

• “Address Clauses" describes the interpretation of expressions that appear in address clauses, 
including those for signals. 

• “Unchecked Programming" describes any restrictions on unchecked conversions and 
deallocations. 

• “Input/Output Packages” describes implementation-dependent characteristics of the 
input/output packages. 

• “Other Implementation-Dependent Features" describes implementation-dependent features not 
covered in the previous sections. 


RATIONAL 


9 / 28/90 


3 




Appendix F 


IMPLEMENTATION-DEPENDENT PRAGMAS 

The CDF accepts the pragmas defined in Annex B of the LRM, as well as a number of additional 
pragmas to be used in application software development. The first of the following subsections 
lists clarifications and restrictions for the pragmas defined in Annex B. 

For each of the pragmas defined for the M68020 Family CDF, the following subsections describe 
the extent to which it is supported for the M68020/HP-UX target. Support for these pragmas may 
differ for other targets. Information about the pragmas that are supported for each target is given 
in the CDF manual for that target. 

Pragmas Defined In Annex B 

For each of the pragmas defined in Annex B of the LRM, Table IV-1 describes the extent to whfch 
it is supported for the M68020 family target. Support for these pragmas may differ for other 
targets. 


Table IV-1 Predefined Pragmas 


Pragma 

Effect 

Controlled 

Always implicity in effect because the implementation does not 
support automatic garbage collection. 

Elaborate 

As given in Annex B of the LRM. 

Inline 

As given in Annex B of the LRM, iuoiect to the setting of the 
switch Inlining_Level 

Interface 

Used in coniuncuon with pragmas Import_Procedure, 
Import_Valued_Procedure, and Import_Function. 

List 

As given in Armex B iDi d.c LRM v..ident only when the Compile 
command is used. 

Memory_Size 

The pragma has no e.'Toct. 

Optimize 

Has no effect 

Pack 

Removes gaps in storage, minimizing space with possible increase 
in access time. See the Size of Objects’ subsection in the 
“Support for Representation Clauses’ section. 

Page 

As given in Annex B of the LRM; evident only when the Compile 
command is used. 

Priority 

As given in Annex B of the LRM. 

Shared 

As given in Annex B of the LR.'-!; has an effect only for integer, 
enumeration, access, and fixed types. 

Storage_Unit 

Has no effect 

Suppress 

As given in Annex B of the LRM. 

System_Name 

Has no effect (There :s only one enumeration literal in the type 
System.System_Namc.) 


4 


9/28/90 


RATIONAL 





Appendix IV: Appendix F for the M68020/HP-UX Target 


Pragma Collection_PoUcy 

The pragma Collection_Policy describes the octensibility of access collections. Access collections 
and pragma Collection_Policy are discussed in the “Storage Management" section of Chapter 5, 
“Runtime Organization." 

Pragma Export_Elaboration_Procediire 

Makes the elaboration procedure for a given compilation unit available to external code by 
defining a global symbolic name. 

Format 

Pragma Sxpcrt_Blaboratlon_Proceduxe ( Kxtemal_Nax&e »> "extemal_naaa " ); ^ 
Description 

The elaboration procedure is otherwise unnameable by the user. Its use is confined to the 
exceptional circumstances where an Ada module is not elaborated because it is not in the closure 
of the main program or the main program is not an Ada program. This pragma is not 
recommended for use in application programs unless the user has a thorough understanding of 
elaboration, runtime, and storage-model considerations. 

Pragma Expoft_Elaboration_Procedure must appear immediately following the compilation unit. 
The external name is a string literal. 

Pragmas Export_Object and Import_Object 

Imports or exports objects from an Ada unit. 

Format 

pragma objactjpragma_^typa 

{ Internal »> lntamal_iclentirier, 
external "external name" } ; 


Description 

The Import_Object pragma causes an Ada name to reference storage declared and allocated in 
some external (non-Ada) object module. The Export_Object pragma provides an objea declared 
within an Ada unit with an external symbolic name that the linker can use to allow another 
program to access the object. It is the responsibility of the programmer to ensure that the internal 
structure of the object and the assumptions made by the importing code and data structures 
correspond. The cross-compiler cannot check for such correspondence. 

Note: The object to be imported or exported must be a variable declared at the outermost level of a 
library-package Reification or body. The pragmas must be in the same declarative part as 
the variable. 

The size of the object must be static. Thus, the type of the object must be one of: 


RATIONAL 


9 / 28/90 


5 





Appendix F 


• A scalar type (or subtype) 

• An array subtype with static index constraints whose component size is static 

• A nondiscriminated record type or subtype 

Objects of a private or limited private type can be imported or exported only into the package 
that declares the type. 

An imported object cannot have an initial value and thus cannot be: 

• Declared with the keyword constant 

• An access type 

• A record type with discriminants 

• A record type whose components have default initial expressions 

• A record or array whose components contain access types or task types 

In addition, the objea must not be in a generic unit. The external name specified must be 
suitable as an identifier in the assembler. 

Parameters 

• objectjpragm*_type: Valid values are either Import_Object or Export_Object. 

• Intarnal »> intemal__lcientifier: Specifies the Ada (internal) name of the object This 
parameter is required. 

• Extaxnal ■> ’’axternal__nama": Specifies the external symbolic name of the object. This 
parameter is optional; if not specified, the internal name is used. 

Pragmas to Import and Export Functions and Procedures 

Allows Ada subprograms to be used by non-Ada routines, and vice-versa. 

Format 

pragma i/]tarrace_type 

( Internal => ijjternal_najBe, 

External => extemal_naa>e, 

• Paraineter_Types *> paTaiaeter_typa_llst, 

Result_Type => type_mark, 

Nickname => "nicknama'’, 

Mechanism => ioecbanism_list, 

Language => langvage_naae ) ; 

Parameters 

• inteiface_type: Valid values are; 

— Import_Procedure 

— Import_Function 


6 


9 / 28/90 


RATIONAL 




Appendix IV: ^pendix F for the M68020/HP-UX Target 


— Iinport_Valued_Proceciure 

— ExpOft_Procedure 

— Export_Function 

• intaxnal «> latmm»l_aaiae: Designates the Ada name of the subprogram being 
interfaced. The internal name can be either an identifier or a string literal. If more than one 
subprogram is in the declarative region preceding the exporting pragma, the correct 
subprogram must be Identified by either using the Parameter_Types (and Result_Type, if a 
function) or specify ing the nickname with pragma Nickname and the Nickname argument or 
both. 

• Bztexnal »> •xtmm*l_name: Specifies the name to be used by the assembler. This is a 
character string that is an identifier suitable for the M68020/HP-UX assembler. If the external 
designator is not specified, the internal name is used. For Unix external names, the narpe 
starts with an underscore and is all lowercase. 

• Parameter__Typas »> p*Taiaeter_typa_J.lstt Distinguishes among two or more 
overloaded subprograms having the same internal name. The value of the Parameter_Types 
argument is a list of type or subtype names separated by commas and enclosed in parentheses. 
Each name correspond positionally to a formal parameter in the subprogram’s declaration. If 
the subprogram has no parameters, the list consists of the single word Null. 

• iiaault_Typ« »> typm_jaark: Specifies the type returned by the function. The Result_Type 
argument serves the same purpose for the return values of ftanctions as the Parameter_Type 
argument serves for the parameter list. 

• NlcknasM «> -nicknMnm’’: See pragma Nickname. 

• Machazilsm «> macbrnnism^list: Specifies, in a parenthesized list, the passing mechanism 
for each parameter to be passed. The Mechanism argument is required if an imported 
subprogram has any parameters; it cannot be used for an exp>orted subprogram. A mechanism 
must be specified for each parameter listed in para 2 neter_typ «8 and they must correspond 
positionally. The types of mechanism are as follows: 

— Value: Specifies that the parameter is passed on the stack by value. 

— Reference: Specifies that the address of the parameter is passed on the stack. 

For functions, it is not possible to specify the passing mechanism of the function result; the 
standard Ada mechanism for the given type of the function result must be used by the 
interfaced subprogram. If there are parameters, and if they all use the same passing 
mechanism, an alternate form for the Mechanism argument can be used: instead of a 
parenthesized list with an element for each parameter, the single mechanism name (not 
parenthesized) can be used. 

• Languag* «> lmnguMga_namm: Specifies the name of the language to which the subprogram 
is being exported for the sole purpose of controlling the manner in which parameters are 
popped from the stack. The Language argument is optional for exporting routines and cannot 
be used for importing routines. Any language identifier other than C is ignored. If the language 
is C, or if the subprogram has copy-back parameters Un-out and out scalars and access types), 
then the exported subprogram will not pop its parameters; otherwise it will. 


RATIONAL 


9 / 28/90 


7 





Appendix F 


Exporting Subprograms 

A subprogram written in Ada can be made accessible to code written in another language by 
using an exporting pragma defined by the M68020 family cross-compiler. The effect of such a 
pragma is to give the subprogram a global symbolic name that the linker can use when resolving 
references between object modules. 

Exporting pragmas can be applied only to nongeneric procediores and functions. 

An exporting pragma can be given only for a subprogram that is a library unit or that is declared 
in the specification of a library package. An exporting pragma can be placed after a subprogram 
body only if the subprogram does not have a sep>arate specification; if it has a separate 
specification, the pragma must go there. 

Importing Subprograms 

A subprogram written in another language (typically, assembly language) can be called from an 
Ada program if it is declared with a pragma Interface. Every interfaced subprogram must have an 
importing pragma that is recognized by the M68020 family cross-compiler— either 
Import_Procedure, Import_Valued_Procedure, or Import_Function. These pragmas are used to 
declare the external name of the subprogram and the parameter-passing mechanism for the 
subprogram call. If an interfaced subprogram does not have an importing pragma, or if the 
importing pragma is incorrea, pragma Interface is ignored. 

Importing pragmas can be applied only to nongeneric procedures and functions. 

Import_Procedure calls a non-Ada procedure; Import_Function, a non-Ada function; and 
Import_Valued_Procedure, a non-Ada function containing the equivalent of out or in out 
parameters. 

Each import pragma must be preceded by a pragma Interface; otherwise, the placement rules for 
these pragmas are identical to those of the pragma Interface given in Section 13.9 of the LRM. 

Importing Functions with In-Out Parameters 

The third pragma is provided because the Ada language allows functions to have only in 
parameters. A non-Ada funaion containing parameters whose values can be altered by the 
function must be associated with an Ada procedure using Import_Valued_Procedure. The first 
parameter in the Ada procedure corresponds to the non-Ada function result; it must be of mode 
out and of a discrete type. 

C-Language Routines 

If the language C is specified in pragma Interface for an imported subprogram, the compiler 
assumes that the imported subprogram will not pop its parameters. If any other language is given, 
the compiler assumes that the imported subprogram will pop its parameters if it has no copy-back 
parameters (.in-out and out scalars and access types), and that it won’t pop its parameters 
otherwise. 


8 


9 / 28^90 


RATIONAL 





Appendix IV; Appendix F for the M68020/HP-UX Target 


Effect of Exporting and Importing on Elaboration Checks 

Exporting a subprogram does not export the mechanism used by the compiler to perform 
elaboration checks; calls from other languages to an exported subprogram whose body is not 
elaborated may have unpredictable results when the subprogram body references objects that are 
not yet elaborated. Elaboration checks within the Ada program are not affected by the exporting 
pragma. 

Use of the Import_Procedure pragma for a subprogram guarantees that no elaboration check is 
performed on the imported procedure. Hence, no explicit suppress of elaboration check is 
needed. 

Examples 

procedura Matrix_Multlply (A, B: in Matrix; C: out Matrix); 

pragma Bxport^Procedure (Matrix_Multiply}; 

— Extamal name is the string "Matrix_Multiply” 

function Sin (R: Radians) return Float; 
pragma Bxport^Function 

(Internal »> Sin, 

External *> "SIN_RADIANS"); 

— External name is the string "SIN__RADIANS" 

procedure Locate (Source : in String; 

Target : in string; 

Index : out Natural); 

pragma Interface (Assembler, Locate); 
pragma Iscport^Procedure 

(Internal => Locate, 

Extamal => "STRSLoCATE", 

Parameter_Types => (String, String, Natural), 

Mechmism => (Reference, Reference, Value)) ; 


function Pwr (I: Integer; N: Integer) return Float; 
function Pwr (F: Float; N: Integer) return Float; 

pragma Interface (Assembler, Pwr); 

pragma Import_Function 
(Internal 
Parameter_Types 
Result_Type 
Mechanism 
External 

pragma Tiiyort_Function 

(Internal => Pwr, 

Parameter_Types => (Float, Integer), 


=> Pwr, 

=> (Integer, Integer), 

=> Float, 

=> Value, 

=> "MATHSpWR of INTEGER"); 


RATIONAL 


9 / 28/90 


9 




Appendix F 


Rasult__Typ« »> Float, 

Hsc h a n ia m «> Valua, 

Extarnal •> "MATH$PWR_Orjri/>AT") ; 

Pragma Intemipt.Handler 

Provides a method for signal-catching. 

Format 

See examples below. 

Description 

Three different mechanisms are available to support interrupt catching: address clauses on task 
entries, subprograms identified with pragma Interrupt_Handler, and interrupt-catching queues that 
employ both subprograms and task entries. 

• Simple interrupt catching can be accomplished with address clauses attached to task entries, as 
described in the LRM (Section 13-5.1). Note that the task entry must always be available, 
discusses this method in more detail. 

• As one alternative, interrupt-catching procedures can be called on a nonspecific, 
target-dependent thread. In this method, the Interrupt_Handler pragma associates a 
signal-catching procedure with a corresponding interrupt . The syntax for the pragma is as 
follows: 

procedur* HandlurJProcedux* 

(Slgnal_In£o : Unix_JB«8«_JPyp«8. Sign*l_InfoJPointer); 

pragma Zntarrupt_Handl«r (Handlar »> Bandler_Procedure, 

Vector «> [addresa-expreaalon]}; 

• The third alternative for interrupt catching is the queued signal catcher, a combination of the 
first two approaches. In this method, a procedure, a task entry, and an interrupt are associated 
with each other through an Interrupt_Handler pragma as shown in this example of a task 
specification: 

task type Driver la 

entry Handler (Target_JDependent^Parafflater : Integer); 
end Driver; 

T : Driver; 

procedure l^_Znterrupt_Handler 

(Slgnal_Znfo : Dnlx_Baae_Type8. Slgnal_Znf oJPolnter) ; 

pragma Znterrupt_Handler (Handler «> l^__Znterrupt_Handler, 

Vector »> [addresa-expreaalon], 

TaakJEntry => T.Handler); 

Note that an address clause must not be included on the entry in the task specification. 


10 


9 / 28/90 


RATIONAL 



Appendix IV: Appendix F for the M68020/HP-UX Target 


Chapter 9 discusses the development of signal catchers. 

More than one Interrupt_Handler pragma can be associated with a given subprogram and/or task 
entry if that subprogram and/or task entry are to serve as handlers for more than one interrupt . 
The elaboration of the Intemjpt_Handler pragma has the effect of associating either a task entry 
or a subprogram with an interrupt This may result in the propagation of the 
Standard.Program_Error exception if the signal already has an associated catcher. 

The cross-compiler verifies that all associated handlers and named task objects are declared at the 
outermost scope. The pragma must appear in the same declarative region or package 
specification as, and following, the definitions of the task entry and the subprogram. 

The interrupt-catching procedure must have a single formal parameter of type 
Unix_Base_Types.Signal_Info_Pointer. The actual value of this parameter and interpretation of it 
during execution of the handler is target-dependent. The Vector parameter is interpreted by the 
runtime system. 

When a signal occurs, the associated procedure is called directly by the runtime system on an 
interrupt stack. No elaboration check is performed, even if elaboration checks are enabled. The 
context at the time of the call is the context at the time of the signal, not the context of the 
associated task, if there is one. 

The procedure—and ail subprograms called from this procedure—must conform to a set of 
restrictions that include the following: 

• Must not raise exceptions (ever!) 

• Must not perform any tasking-related operations, including but not limited to; 

— Entry calls 

— Task creation 

— Abort statements 

— Delay statements 

• Must not pop its parameters from the stack. 

failure to comply with these rules makes the program erroneous. The procedure may make use 
of the Runtime_Interface package to control various aspects of certain tasks. The predefined 
package Calendar can be used and dynamic memory allocation/deallocation is allowed. No 
checks are performed to ensure that restrictions are not violated, and such violations may have 
unpredictable results. 

When the interrupt-catching subprogram returns, the runtime system checks whether the signal 
has an associated task entry. If so, the runtime .system queues a call to the associated task entry in 
such a way that it takes precedence over any nonsignal-driven calls to the same task entry. The 
task object must be activated before receiving the first signal; no check is performed at run time 
to ensure that this has been done. The signals are fully buffered and the called task accepts one 
entry call for each signal regardless of the rate at which signals are received. For example, if ten 
signals are received before the task acccpLs the first, then the ’Count of the associated entry is 10, 
and ten accept statements for that entry arc required to reduce the 'Count to 0. In other words, 
when an accept statement is encountered, one of the following occurs: 


RATIONAL 


9/2a/90 


11 




Appendix F 


• If the 'Count of pending signal-driven calls to the appropriate entry is nonzero, 'Count is 
decremented and execution is continued as if an accept has occurred. 

• If 'Count is 0 and there are pending calls to the appropriate entry from nonsignal-driven tasks, 
the first one in the queue is accepted. 

• If 'Count is 0 and there are no other pending entry calls, execution is suspended, awaiting one 
of the above to occur. 

In the situation shown in Figure IV-l, three tasks CTl, T2, and T3) have issued normal entry calls 
to task Ts Entry 1, two 0*4 and T5) have issued calls to Entry2, and one 0*6) has issued a call to 
Entry3. In addition, three signals have issued calls to Entryl and one signal has issued a call to 
Entry3. 


Figure tV-l Queued signals 

If T’Body contains the following code: 

b«gin loop 

accept Bntxyl; 

accept Sntxy2; 


12 


9/28/90 


RATIONAL 



Appendix IV: Appendix F for the M68020/HP-UX Target 


accapt Entry3; 

•nd loop; 

then the first time through the loop, accept Entryl decrements ’Count Oeaving it at 2) and 
continues, accept Entxy2 accepts the call from task T4, and accept EntryS decrements its 
’Count Oeaving it at 0) and continues. The second time through, accept Entryl again 
decrements ’Count, accept Entry 2 accepts the call from task T5, and accept Entry 3 accepts 
the call from task T6. 

The priority of the task during the rendezvous is higher than Standard.System.Priority’Last. 
discusses the development of signal catchers. 

Pragma Main 

Designates an Ada main unit. 

Format 

pragma Main ( Target => ainple_naiae, 

Stack^Slze ’*> atatic__integer_exprassion, 

Heap_Size => atatic_integar_axpraaaion ); 


Parameters 

Pragma Main has three optional parameters: 

• Target •> aiaplm_ttaiam: Specifies the target key as a string. If this parameter appears and 
does not match the current target key, pragma Main is ignored. If the Target parameter 
matches the current target key or does not appear, pragma Main is honored. A single source 
copy of a main program can be used for different targets by putting in multiple Main pragmas 
with different Target parameters and different stack sizes and/or different heap sizes. 

• Stack_Slz« »> atatlc_integer_expression: Specifies the maximum size in bytes of the 
main task stack as an expression. If not specified, the default maximum is 4 Kb. The stack will 
expand dynamically up to this maximum size. 

• a«ap__siz« »> atatic__iiJteger_axpresaion: Specifies the size in bytes of the heap as an 
expression. If not specified, the default value is 64 Kb. 

Description 

A parameterless library-unit procedure without subunits can be designated as a main program by 
including a pragma Main at the end of the unit specification or body. This pragma causes the 
linker to run and create an executable program when the body of this subprogram is coded. 
Before a unit having a pragma Main can be coded, all units in the witb closure of the unit must 
be coded. 

Multiple Main pragmas can be placed in the specification, the body, or both. If more than one 
pragma Main is specified with the same target parameter, only the first pragma Main in the 


RATIONAL 


9/28/90 


13 



Appendix F 


specification (if there is one) has any effect; otherwise, only the first one in the body is used. 

Using the Target parameter forces the pragma to be ignored for all targets but the one specified. 
This enables joined views of a procedure to have different effects according to the target. One 
use is to avoid the effects of declaring a pragma Main when the target is the RIOOO: 

pragma Main (Target -> Mc£8020_Rp_Uxilx); 

Another use is to specify different stack or heap sizes for different targets. For example: 

procedure Show_Pragma_Maln la 
begin 

Do^Somathlng; 
exxd Show_Pragma_Maln; 

pragma Main (Target >> Mc£8020_Hpjtmlz, Baap_Slze ■> 10*1024); 
pragma Main (Target -> <another target key>, Heap_Siza «> 20*1024); 

The program Show_Pragma_Main will be a main program in both an Mc68020_Hp_Unix view 
and a view for the other target. The heap sizes for the two targets will be as specified by the 
different Main pragmas. 

Pragma Nickname 

Gives a unique string name ' a procedure or function in addition to its normal Ada name. 

Format 

pragma NlcJcnama ( "string"); 

Description 

This unique name can be used to distinguish among over- loaded procedures or functions in the 
importing and exporting pragmas defined in preceding subsections. 

Pragma Nickname must appear immediately following the declaration for which it is to provide a 
nickname. It has a single argument, the nickname, which must be a string constant. 

For example: 

function Cat (L: Integer; R: String) return String; 
pragma Nickname ("Xnt-Str-Cat"); 

function Cat (L: String; R: Integer) return String; 
pragma Nickname ("Str-lnt-Cat"); 

pragma Interface (Assembly, Cat); 

pragma Import_Functlon (Internal => Cat, 

Nickname => "Int-Str-Cat", 

External => "CAT$1NT_STR_C0NCAT", 

Mechanism => (Value, Reference)); 


14 


9/28/90 


RATIONAL 





Appendix IV; Appendix F for the M68020/HP-UX Target 


pragma Import_Punction (Internal => Cat, 

Hlckname => "Str-Int-Cat", 
External => ••CAT$STR_INT_CONCAT", 
Mechanism => (Reference, Value)); 

Pragma Suppress_All 

Duplicates the effea of several Suppress pragmas. 

Format 


pragma Suppreas_All; 

Oesciiptioa 

Pragma Suppress_All is equivalent to the following sequence of Suppress pragmas. It has no 
effect in a package specification. See the LRAl, section 11.7.3. 


pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 


(Access_Check); 
(Discriminant_Check) ; 
(Division_Check); 
(Elaboration_Check); 
(Index__Check) ; 
(LengthjCheck); 
(Ov’erflow_Check) ; 
(RangejCheck) ; 
(StoragejCheck) ; 


Note that, like pragma Suppress, pragma Suppress_AJl does not prevent the raising of certain 
exceptions. For example, numeric overflow or dividing by zero is deteaed by the hardware, 
which results in the predefined exception .\umeric_Error. Refer to , “Runtime Organization," for 
more information. 


Pragma Suppress_All must appear immediately within a declarative part. 


IMPLEMENTATTON-DEPENDENT ATTRffiUTES 

There are no implementation-dependent attributes. 


RATIONAL 


9/28/90 


15 



Appendix F 


PACKAGES SYSTEM AND STANDARD 
Package Standard (LRM Annex C) 

Package Standard defines all the predefined identifiers in the language. 

packag* Standacd is 

typ* *Unlvarsal_Inte 9 er* is ... 

typ« *t7ai7ersal_Reai* is ... 

typ« *nniversal_rixed* is ... 

typ« Boolean is (Falsa, True); 

typa Integer is range -2147483648 .. 2147483647; 

type Sbort__Short_Xnteger is range -128 .. 127; 
type Short__Integer is range -32768 .. 32767; 

type Float is digits 6 range -16#1.FFFF_FE# * 2.0 ** 127 .. 

16#l.FrFF_FE# * 2.0 ** 127; 

type Long_Float is digits 15 range -16#l7FFFF_FrFF_FFFF_F# * 2.0 ** 1023 

.. 16#1.FFFF_FFFF_FFFF_F# * 2.0 ** 1023; 

type Duration is delta 16#1.0# * 2.0 ** (-’14) 

range -16#1.0# * 2.0 **17 .. 

16#l.FFFF_FFFCi * 2.0 ** 16; 

subtype Natural is Integer range 0 .. 2147483647; 

subtype Positive is Integer range 1 .. 2147483647; 

type Character is ... 

type String is array (Positive range <>) of Character; 
pragma Pack (String); 

package Ascii is ... 

Constraint_Error : exception; 

Numaric_Error : exception; 

Storage__Error : exception; 

Tasking^Error : exception; 

Program_Error : exception; 

end Standard; 


16 


9/28/90 


RATIONAL 




Appendix IV: Appendix F for the M68020/HP-UX Target 


Table rV-2 shows the default integer and floating-point types: 

Table IV-2 Supported Integer and Floating-Point Types 


Ada Type Name 

Size 

Short_Shoft_lnteger 

8 bits 

Shoft_Integer 

l6 bits 

Integer 

32 bits 

Float 

32 bits 

Long_Float 

64 bits 


Fixed-point types are implemented using the smallest discrete type possible; it may be 8, 16, or 
32 bits. 

Standard-Duration is 32 bits. 


Package System (LRM 13.7) 

package System Is 

type Address is private; 
type Name is (Mc68020_Hp_Uni3c) ; 

System_Nania : constant Name Mc68020_Hp_Unix; 

Storage_Unit : constant 8; 

Mamozy_Size : constant := +(2 ** 31) - 1; 

Min_Int : constant := -(2 ** 31); 

Max_Int : constant := +(2 ** 31) - 1; 

Max_Digits : constant := 15; 

HazJMantissa : constant 31; 

Fine_Delta : constant := 1.0 / (2.0 ** 31); 

Tick : constant 2.0 / 100.0; 

subtype Priority is Integer range 0 .. 255; 

fxinction To_Address (Value ; Integer) return Address; 
function To_Integer (Value : Address) return Integer; 
function "-F'' (Left : Address; Right : Integer) return Address; 

function ”■¥” (Left : Integer; Right : Address) return Address; 

function (Left : Address; Right ; Address) return Integer; 

function (Left : Address; Right ; Integer) return Address; 

function "<" (Left, Right : Address) return Boolean; 

function "<=" (Left, Right : Address) return Boolean; 

function ”>" (Left, Right : Address) return Boolean; 


RATIONAL 


9/28/90 


17 








Appendix F 


function ">e:" (ZiQft, Right : Address) return Boolean; 

— The functions above are unsigned in nature. Neither Numeric_Error 
nor Constraint_Brror will ever be propagated by these functions. 

— Note that this inplies: 


and that: 


To_Address (Integer'rirat) > To_Addres8 (Integer'Last) 


To^Address (0) < To_Address (-1) 


Also, the unsigned range of Address Includes values that are 
— larger than those inf>lied by Heiaory_Size. 


Address Zero : constant Address; 


private 


end System; 


18 


9/28/90 


RATIONAL 




Appendix IV; Appendix F for the M68020/HP-IJX Target 


SUPPORT FOR REPRESENTATION CLAUSES 

The M68020/HP-UX CDF support for representation clauses is described in this section with 
references to relevant sections of the LRM. Use of a clause that is unsupported as specified in this 
section or use contrary to LRM specification will cause a semantic error unless specifically noted. 
Further details on the effects on specific types of objects are given in the “Size of Objects" 
subsection. 

Length Clauses (LRM 13.2) 

Length clauses are supported by the M68020 Family CDF as follows: 

• The value of a ’Size attribute must be a positive static integer expression. ’Size attributes are 
supported for all scalar and composite types with the following restrictions: 

— For all types, the value of the ’Size attribute must be greater than or equal to the minimum 
size necessary to store the largest possible value of the type. 

— For discrete types, the value of the Size attribute must be less than or equal to 32. 

— For fixed types, the value of the ’Size attribute must be less than or equal to 32. 

— For float types, the ’Size attribute can specify only the size the type would have if there 
were no clause. The only possible legal values therefore are 32 and 64. 

— For access and task types, the value of the ’Size attribute must be 32. 

— For composite types, a size specification must not imply compression of composite 
components. Such compression must have been explicitly requested using a length dause 
or pragma Pack on the component type. 

• ’Storage_Size attributes are supported for access and task types. The value given by a 
’Storage_Size attribute can be any integer expression, and it is not required to be static. 

• ’Small attributes are supported for fixed point types. The value given by a ’Small attribute must 
be a positive static real number that cabnot be greater than the delta of the base type. It need 
not be a power of 2. 

Enumeration Representation Clauses (LRM 13.3) 

Enumeration representation clauses are supported with the following restrictions: 

• The allowable values for an enumeration clause range from (Integer’First + 1) to Integer’Last. 

Record Representation Clauses (LRM 13.4) 

Both full and partial representation clauses are supported for both discriminated and 
undiscriminated records. Record component clauses are not allowed on: 

• Array or record fields whose constraint involves a discriminant of the enclosing record 

• array or record fields whose constraint is not static 


RATIONAL 


9/28/90 


19 






Appendix F 


The static simple expression in the alignment ciaitse part of a record representation clause—^see 
LRM 13.4 (4)—must be a power of 2 with the following limits: 

1 <« statlc__sii^ple_ezpresslon <a 16 
The size specified for a discrete field in a componertt clause should not exceed 32 bits. 

Change of Representation (LRM 13.6) 

change of representation is supported wherever it is implied by support for representation 
specifications. 

Size Of Objects 

This section describes the size of both scalar and composite objects. The first two subsections 
cover concepts of size that apply to all object types. The remaining subsections cover individual 
types. The size concepts are most important for the composite types. 

Minimum, Default, Packed, and Unpacked Sizes 

The following terms are used to describe the size of an object: 

• Storage unit; Smallest addressable memory unit. The size of the storage unit in bits is given by 
the named number System.Storage_Unit. Since the MC68020 is byte-addressable, the size of the 
storage unit is 8. 

• Minimum size for a type: The minimum number of bits required to store the largest value of 
the type. For example, the minimum size of a Boolean is 1. 

• Maximum size for a type; The largest allowable size for a discrete type. For the MC68020, the 
maximum size is 32. 

• Packed size for a type: The size of a component used in an array or record when a pragma 
Pack is in effea. This is the same as the minimum size unless modified by a ’Size clause (see 
“Determination of Storage Size,” below). 

• Unpacked size for a type: The size of a component used in an array or record when no 
pragma Pack is in effect. This is the same as the default size unless modified by a ’Size clause 
(see “Determination of Storage Size," below). 

• Default size for a type; 'The smallest number of bits required to store the largest value of the 
type when stored in whole storage units. For composite types, the default sizes are multiples of 
8. The F>ossible default sizes for scalar, access and task types are given in Table rV-3. 


20 


9/28/90 


RATIONAL 





Appendix IV: Appendix F for the M68020/HP-UX Target 


Table IV-3 Default Sixes for Scalar, Access, and Task Types 


Type 

Sizes In Bits 

Discrete 

8. 16 , 32 

Fixed 

8, 16. 32 

Float 

32, 64 

Access 

32 

Task 

32 


Determination of Storage Size 

Top-level scalar and access objects are stored using their unpacked size (a top-level object is an 
object that is not a component of any array or record). Components of composite objects having 
neither pragma Pack nor a record representation clause are also stored using the unpacked size. 
Components of composite objects having pragma Pack are stored using the packed size. Fields of 
records having record representation clauses can be stored in any number of bits ranging from 
the minimum size to the default size of the field type. If a scalar or composite type component 
field is specified to be smaller than the default size, a fillerfield is introduced, and the data is left 
justified. For further information, see the “Array Types” and “Record Types" subsections. 

Discrete Types 

'Size clauses on discrete types affea sizes by changing the packed and unpacked sizes. When 
there is no 'Size clause, the packed and unpacked sizes are the minimum and default sizes, 
respeaively. 'Size clauses with values outside the minimum and maximum sizes cause a semantic 
error. Within that range, there are two cases depending on the value specified by the clause; 

• Value <• default size: The packed size is set equal to Value. The unpacked size is not affeaed. 

• Value > default size. The packed size is set equal to Value and the unpacked size is set to the 
number of bits in the smallest number of storage units that will hold the packed size. 

Examples are provided in Table IV-4. 


RATIONAL 


9/28/90 


21 






Appendix F 


Table IV~4 Size Examples for M68020/HP-UX Target 


Example Type Declaration 

Minimum 

Size 

Default 

Size 

Maximum 

Size 

Integer 

32 

32 

32 

Boolean 

1 

8 

32 

Float 

32 

32 

32 

type Byte is range 0 .. 255 

8 

16 

32 

type Primary is (Red, Blue, Yellow) 

2 

8 

32 

type X is (Normal, Read_Error, 

Write_EiTor) 

for X use (7, 15, 31) 

5 

8 

32 

type Ary is array (1 .. 100) of Boolean 

100 

800 

n/a 


Integer Tyrpes 

A first-named integer subtyp>e has a default size the same as that of the smallest integer type 
defined in package Standard that will hold the range chosen. For example, consider the following 
type declaration: 

type Byte Is rang* 0..255; 

Type Byte will have a minimum size of 8 and a default size of 16. It has a default size of 16 
because the smallest type from which Byte can be derived is Short_Integer. (Short_Short_Integer, 
which has a size of 8, does not include values greater than 127.) 

The 'Size clause is supported for nonderived and derived integer types. The effea of a ’Size 
clause on minimum size is shown in the following example. Consider: 

typ« Byt« Is rang* 0 .. 255; 
for Byta'Siza us« n; 

where n is a static integer expression. Table IV-5 shows the effect of n on the packed and 
unpacked sizes. 


Table IV-5 Example of Effect of 'Size Clauses 


22 


9/28/90 


RATIONAL 





Appendix IV: Appendix F for the M68020/HP-LIX Target 


’Size clause 

Packed 

Size 

Unpacked 

Size 

No 'Size clause 

8 

16 

Uses 

8 

8 

Use 12 

12 

16 

Use 16 

16 

16 


Enumeration Types 

For an enumeration type with n elements, the default internal integer representation ranges from 
0 .. n - 1. The maximum number of elements that can be declared for any one enumeration type 
depends on the total number of characters in the images of the enumeration literals. Let L be the 
total number of characters of the n elements. Then L and n must satisfy the following inequality: 
2*n + 4 + Z <- 2J6 

Enumeration and 'Size clauses are permitted on derived types. However, this may generate 
additional code when parent/derived types are converted to each other. 

For predefined type Character, the value returned by the 'Size attribute is 8 and the minimum size 
is 8. User-defined charaaer types behave like ordinary enumeration types and may have a 
minimum size that is less than 8. 

The 'Size clause is supported for both nonderived and derived enumeration types. The effect of a 
'Size clause on representation is shown in the following example. Consider: 

typ« Rasponsa is (No, Mayba, Yes); 
fox Rasponsa'Slza usa n; 

where n is a static integer expression. Table IV-6 lists the packed and unpacked sizes for different 
values of n. 


Table IV-6 Example of Enumeration Type Sixes 


’Size clause 

Packed 

Size 

Unpacked 

Size 

No 'Size clause 

2 

8 

Use 4 

4 

8 

Use 12 

12 

16 

Use 16 

16 

16 

Use 20 

20 

32 

Use 32 

32 

32 


RATIONAL 


9/28/90 


23 





Appendix F 


Floating-Point Types 

The internal representations for floating-point types are the 32-bit and 64-bit floating-point 
representations as defined by the MC68020 architecture. 

Fixed-Point Types 

Fixed-point types are represented internally as integers. The integer representation is computed 
by scaling (dividing) the fixed-point number by the actual small implied by the fixed-point type 
declaration. Actual small is defined to be the nearest multiple of 2 that will represent the smallest 
possible value of the fixed-pioint type. The values that are exactly representable are those that are 
precise multiples of the actual small; numbers between those values are represented by the 
closest exact multiple. For example, in the declaration: 

typ« fix la dalta 0.01 xanga -10.0 ..10.0; 

the integer value used to represent the lower bound of the type is -10.0 / (1/128), or -1280, since 
the actual small, representing 0.01, is 1/128. In the example: 

typa fix la dalta 0.01 ranga -10.6 .. 10.6; 

the integer value used to represent the lower bound of the type is -1357, which is the closest 
exact multiple of the actual small. (This is -10.6/(1/128) » -1356.8; the nearest integer 
representation is -1357.) 

The size of the representation is 32, 16, or 8 bits; the compiler chooses the smallest of these that 
can represent all of the safe numbers of the fixed-point type. 

'Size and ’Small are supported for both nonderived and derived types. The value given in a ’Small 
clause for a fixed type must be a positive static real number. The value need not be a p)ower of 2. 
By Ada rules, it may not be greater than the delta of the base type. 

Access Types And Task Types 

Access and task objects have a size of 32 bits. The ’Storage_Size length clause is allowed for 
access and task types. The value given in a Storage_Size clause can be any integer expression, 
and it is not required to be static. Static expressions larger than Integer’Last will generate 
compilation warnings; however, a Numeric_Error exception will be raised at run time. For access 
types, the ’Storage_Size clause is used to specify the size of the access type’s coUeaion. If a 
’Storage.Size clause has been applied to an access type, the collection is nonextensible. For task 
typ>es, the clause determines the stack size. 

A value (either static or noO of 0 is allowed; in this case, no collection or task stack space will be 
allocated, and a Storage_Error exception will be raised at run time if any aaempt is made to 
allocate or deallocate from the collection or activate the task. Negative values are also allowed by 
the CDF; however, this will generate a Storage_Error exception when the type is elaborated even 
if no attempt is made to allocate or deallocate objects belonging to the colleaion. 


24 


9/28/90 


RATIONAL 




Appendix IV; Appendix F for the M68020/HP-UX Target 


Array Types 

For a given array type, the CDF is capable of using one of two representations, known as the 
unpacked and packed representations. 

In the unpacked representation, each array component starts on a storage-unit boundary, and 
filler (of up to three storage units) may be introduced between components to cause them to be 
aligned properly. This alignment filler is sometimes needed when the component is a record type 
or contains record types. 

The packed representation for an array type differs from the unpacked representation if the type 
satisfies one of the following mutually exclusive requirements: 

• The minimum size of the component type is less than 32 bits. In the packed representation, 
each component will occupy exactly the number of bits in its minimum size; this means that 
components might not start on storage-unit boundaries. If the last storage unit of a packed 
array of this type contains unused bits, the CDF will cause these bits, which are called tail 
filler, to be zeroed. This permits comparison and copy operations on the array to be 
performed efficiently using block operations. 

• Alignment filler is used in the unpacked representation. In the packed representation, the 
alignment filler will be omitted; each component will still start on a storage unit-boundary. 

If neither of the two situations above holds, the packed representation is the same as the 
unpacked representation. 

If an array type has neither pragma Pack nor a length clause, the CDF uses the unpacked 
representation. If pragma Pack is applied to the array type, the CDF uses the packed 
representation. If a length clause is applied to the array type, the unpacked representation is used 
if it would result in a size less than or equal to that specified in the length clause; otherwise the 
packed representation is used. If the packed representation is also too large for the length clause, 
the length clause is rejected. If both pragma Pack and length clause are specified, the packed 
representation is used; an error will result if this representation is too large for the length clause. 

Note that the length clause specifies an upper bound for the size of the array; a length that is less 
than the size of the unpacked representation will result in the use of the packed representation, 
even it if is smaller than the size given in the length clause. 

Change of represeniation is supported for arrays. Hence, pragma Pack on a derived array type is 
honored, and length clauses on derived array types are permitted. 

Record Types 

In the absence of a record representation clause, a record type also has two basic representations; 
unpacked and packed 

In the unpacked representation, each record component starts on a storage-unit boundary, and 
alignment filler may be introduced between components to cause the components to be aligned 
properly. For example, an integer component will be aligned so that it starts on a longword 
boundary. 


PATIONAL 


9/28/90 


25 




Appendix F 


In the packed representation, a component whose size is less than 32 bits will occupy exactly the 
niimber of bits in its minimum size; such components might not start on storage unit boundaries. 
At present, alignment filler is not eliminated in the packed representation. 

The criteria for seleaing which representation to use are the same as described above for array 
types. 

In either case, the CDF may lay out the record fields in a different order than that used in the 
type declaration for the record. This is done in an attempt to satisfy alignment requirements 
without introducing unnecessary alignment filler. 

If a record representation clause is present, it may mention some or all of the fields in the record. 
Those fields that are mentioned in the clause will be laid out according to its rules; the remaining 
fields are then laid out according to the default algorithms, starting at the first storage unit past 
the last field mentioned in the clause. This is the case even if the clause leaves “holes" that are 
big enough to contain some of the fields not mentioned. In a discriminated record, this rule has 
an important consequence: if one of the discriminants is not mentioned in the clause, it will be 
placed after all of the fields in the largest variant part (as specified by the clause). Even though 
some of the variant parts may be smaller than others, constrained copies of the record selecting 
those v 2 U’iants will be as large as copies of the record with the largest variant. 

A record representation clause cannot mention a field whose size is not known at compile time 
(this includes fields whose size depends on a discriminant). 


IMPLEMENTATION-GENERATED NAMES 
Implementation-Dependent Components 

The LRM allows for the generation of names denoting implementation-dependent components in 
records. No such names are visible to the user for the M68020 Family CDF. 


ADDRESS CLAUSES (LRM 13.5) 

Address clauses can be applied to any object. Note that the address must be determinable at 
compile time, but it does not need to be Ada static (as defined in the LRM, Section 4.9). The 
’Address attribute does not produce a compile-time static value. Addresses must be specified 
using constants and operators from package System. 

Address clauses can be attached to a task entry even when the task entry is used for signal 
catching; however, in this case, the task entry must be available at the time of the signal. See the 
discussion on pragma Interrupt_Handler for additional information. 


UNCHECKED PROGRAMMING 


26 


9/28/90 


RATIONAL 




Appendix IV: Appendix F for the M68020/HP-UX Target 


Unchecked Storage Deallocation (LRM 13.10.1) 

Unchecked storage deallocation is implemented by the generic function Unchecked_Deallocation 
defined by the LRM. This procedure can be instantiated with an object type and its access type, 
resulting in a procedure that deallocates the object’s storage. Objects of any type can be 
deallocated. 

The storage reserved for the entire collection associated with an access type is reclaimed when 
the program exits the scope in which the access type is declared. Placing an access-type 
declaration within a block can be a useful implementation strategy when conservation of memory 
is necessary. Space on the free list is coalesced when objects are deallocated. 

Erroneous use of dangling references may be detected in certain cases. When detected, the 
Storage_Error exception is raised. Deallocation of objects that were not created through allocation 
(that is, through Unchecked_Conversion) may also be detected in certain cases, also raising 
Storage_Error. 

Unchecked Type Conversion (LRM 13.10.2) 

Unchecked conversion is implemented by the generic function Unchecked_Conversion defined 
by the LRM. This function can be instantiated with source and target types, resulting in a function 
that converts source data values into target data values. 

Unchecked conversion moves storage units from the source objea to the target objea 
sequentially, starting with the lowest address. Transfer continues until the source object is 
exhausted or the target object runs out of room. If the target is larger than the source, the 
remaining bits are undefined. Depending on the target-computer architecture, the result of 
conversions may be right- or left-aligned. 

Restrictions on Unchecked Type Conversion 

• The target type of an unchecked conversion cannot be an unconstrained array type or an 
unconstrained discriminated type without defauit discriminants. 

• Internal consistency among components of the target type is not guaranteed. Discriminant 
components may contain illegal values or be inconsistent with the use of those discriminants 
elsewhere in the type representation. 


INPUT/OUTPUT PACKAGES 

The Ada language defines specifications for four I/O packages: Sequentialjo, Direa_Io, Text_Io, 
and Low_Level_Io. The following paragraphs explain the implementation-dependent 
characteristics of those four packages provided with the M68020/HP-UX CDF. 

Sequential_Io. (LRM 14.2.2 and 14.2.3) 

For the Read procedure of Sequential_Io, the Data_Error exception is raised only when the size of 
the data read from the file is greater than the size of the ouf parameter Item. 


RATIONAL 


9/28/90 


27 





Appendix F 


Directjo. (LRM 14.2.4) 

Package Direct_Io may not be instantiated with any type that is either an unconstrained array 
type or a discriminated record type without default discriminants. A semantic error is reported 
when attempting to install any unit that contains an instantiation in which the actual type is such 
a forbidden type. 

For the Read procedure of Direct_Io, there is no check performed to ensure that the data read 
from the file can be interpreted as a value of the Element_Type. 

Specification of Package Dlrect_Io (LRM 14.2.5) 

The declaration of the type Count in package Directjo is: 

typ« Count is new Integer range 0 .. Integer'Last / Bleaient_Type'Size; 
where Element_Type is the generic formal type parameter. 

Low_Level_Io. (LRM 14.6) 

Package Low_Level_Io is not provided for the Mc68020_Hp_Unix target. 

Textjo. (LRM 14.3) 

The Textjo default input and output files are associated with the HP-UX standard input and 
standard output paths, respectively. 

Specification of Package Text.Io (LRM 14.3.10) 

The declaration of the type Count in Text_Io is: 

typ« Count is rang* 0 .. 1_000_000_000; 

The declaration of the subtype Field in Text_Io is: 

subtyp* Field is Integer range 0 .. Integer'Last; 

Console.Io 

Text_Io and Console_Io use different low-level op>efations to read and write. Use of both 
packages in the same program could result in buffering problems. 

File Management Operations 

Get and Put. The operation of Get and Put is as described in the LRM. Data written using Put 
and Put_Line is not interpreted in any fashion. Data written using Put_Line is followed by the line 
terminator Ascii.Lf. Data read using Get and Get_Line is not interpreted except that the line 
terminator, Ascii.Lf, and the page terminator, Ascii.Ff, are removed from the input stream. 


28 


9/28/90 


RATIONAL 




Appendix IV: Appendix F for the M68020/HP-UX Target 


OTHER IMPLEMENTATION-DEPENDENT FEATURES 
Machine Code (LRM 13.8) 

Machine-ccxle insertions are not supported at this time. 


RATIONAL 


9 / 28/90 


29 





