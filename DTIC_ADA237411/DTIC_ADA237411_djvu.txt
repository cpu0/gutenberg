AD-A237 411 

_... ait mu HIM Mil Hill 111! 111! 


MENTATION PAGE 


Form Approved 
OPM No. 0704-0188 


iverage 1 how par response, including the tin* lor reviewing instructions, searching Misting data sources gathering and maintaining the data 
rprdinn in* burden estimate or any other aspect ol this collection o< intormation. including suggestions tor reducrig the burden, to WashmgBn 
is. 1215 Jefferson Davis Highway. Suite 1204, Arlington. VA 22202-4302. and to the Oil ice of information and Regulatory Affairs. Office of 


| , mueNCY USE ONLY (Leave Blank) 

2. REPORT DATE 

3. REPORT TYPE AND DATES COVERED 

Final; 15 Aug 1990 to 01 Mar 1993 

4. TITLE AND SUBTITLE 

Alsys Limited, Alsycomp_017, Version 5.2, Micro VAX II under MICRO VMS V5.3 
(Host) to INMOS T425 transputer implemented on a B403 TRAM (Target), 

901118N1.11064 

5. FUNDING NUMBERS 

6 AUTHOR(S) 

National Computing Centre Limited V‘ < 

Manchester, UNITED KINGDOM > 

7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

National Computing Centre Limited 

Oxford Road 

Manchester Ml 7ED 

UNITED KINGDOM 

8. PERFORMING ORGANIZATION 

REPORT NUMBER 

AVF_VSR_90502/74-910402 

9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Washington, D.C. 20301-3081 

10. SPONSORING/MONITORING AGENCY 
REPORT NUMBER 


11 SUPPLEMENTARY NOTES 


12a DISTRIBUTION/A VAILABIUTY STATEMENT 

Approved for public release; distribution unlimited. 


12b. DISTRIBUTION CODE 


13. ABSTRACT (Maximum 200 words) 


Alsys Limited, Alsycomp_017, Version 5.2, Manchester England,MICRO VAX II under MICRO VMS V5.3 (Host) to INMOS 
T425 transputer implemented on a B403 TRAM using the host running INMOS Iserver VI .3 for fil-server support via a 
CAPLIN OTO board link (bare machine), ACVC 1.11. 


14 SUBJECT TERMS 

Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 

Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 

15, NUMBER OF PAGES 

16 PRICE CODE 

17 SECURITY CLASSIFICATION 

OF REPORT 

UNCLASSIFIED 

18 SECURITY CLASSIFICATION 

UNCLASSIFED 

19 SECURITY CLASSIFICATION 

OF ABSTRACT 

UNCLASSIFIED 

20 LIMITATION OF ABSTRACT 

r^Aij Cl 



Stand-"* Form 298, (Rev 2 89) 


Prescribed by ANSI Std 239 128 










CHAPTER 1 


INTRODUCTION 




c 


c 


This Validation Summary Report' (2SR^ describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results of r _jte£ting this compiler using the Ada Compiler 
Validation Capability An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that is 
not in the Standard.^ 

Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between implementations. 
The Ada Standard permits some implementation dependencies—for example, the 
maximum length of identifiers or the maximum values of integer types. 
Other differences between compilers result from the characteristics of 
particular operating systems, hardware, or implementation strategies. All 
the dependencies observed during the process of testing this compiler are 
gixen-jiu&is report. 


The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. *\The purpose of validating is to ensure conformity 
of the compiler to the Ada Standard by testing that the compiler properly 
implements legal language constructs and that it identifies and rejects 
illegal language constructs. The testing also identifies behavior that is 
implementation-dependent blit is permitted by the Ada Standard. Six classes 
of tests are used. These\tests are designed to perform checks at compile 
time, at link time, and during execution. 







Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 1.11. Testing was 
completed on 901118. 

Compiler Name and Version: Alsycomp_017 Version 5.2 

Host Computer System: MICRO VAX II under MICRO VMS V53 

Target Computer System: INMOS T425 transputer implemented on a B403 TRAM 

using the host running INMOS Iserver V13 for 
file-server support via a CAPLIN QTO board link (bare 
machine) 

A more detailed description of this Ada implementation is found in section 3.1 of this report. 

As a result of this validation effort, Validation Certificate #901118N1.11064 is awarded to Alsys 
Limited. This certificate expires on 01 JUNE 1992. 


This report has been reviewed and is approved. 


U e T- PtnVl 

Jane Pink 

Testing Services Manager 

The National Computing Centre Limited 

Oxford Road 

Manchester 

Ml 7ED 

England 


I Ada Vafid^t/orr Organization 
Director, Computer & Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria 
VA 22311 


Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington 
DC 20301 


Validation Summary 


AVF_VSR_90S0Z/74 


Ahyi Limited 


Page ii of iii 


Ateycomp_017 Venioo 5.2 




AVF Control Number. AVF_VSR_90502/74-910402 


Ada COMPILER 

VALIDATION SUMMARY REPORT: 

Certificate Number #901118N1.11064 
Alsys Limited 
Alsycomp_017 Version 5.2 

MICRO VAX n under MICRO VMS V53 

INMOS T425 transputer implemented on a B403 TRAM 
using the host running INMOS Iserver VI3 for 
file-server support via a CAPLIN QTO board link (bare machine) 


Prepared by 
Testing Services 

The National Computing Centre Limited 
Oxford Road 
Manchester 
Ml 7ED 
England 


VSR Version 90-08-15 

91 5 24 003 


91-00482 

• mu Mil llll 



Validation Summary Report 


AVFVSR 90502/74 


Alsyi Limited 


Page i of iii 


Abycomp_017 Versioo 52 




DECLARATION OF CONFORMANCE 


The following declaration of conformance was supplied by the customer. 

DECLARATION OF CONFORMANCE 
Customer Alsys Limited 

Ada Validation Facility: The National Computing Centre Limited 

Oxford Road 
Manchester 
Ml 7ED 
United Kingdom 


ACVC Version: 1.11 

Ada Implementation: 

Ada Compiler Name: Alsycomp_017 

Version: Version 52 

Host Computer System: MICRO VAX II under MICRO VMS V53 

Target Computer System: INMOS T425 transputer implemented on a B403 TRAM 

using the hast r unning INMOS Iserver V13 for 

file-server support via a CAPLIN QTO board link (bare machine) 

Customer’s Declaration 

I, the undersigned, representing Alsys Iimited, declare that Alsys Limited has no knowledge of 
deliberate deviations from the Ada Language Standard ANSI/MIL-STD-1815A in the 
implementation(s) listed in this declaration. 





Signature 

Date 


Validation Summary Report 


AVF_VSR -90502/74 

Alsyt Limited 

Page iii of iii 

Alsycotnp_017 Version 5.2 


TABLE OF CONTENTS 


TABLE OF CONTENTS 

CHAPTER 1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT. 1 

1.2 REFERENCES . 1 

1.3 ACVC TEST CLASSES . 2 

1.4 DEFINITION OF TERMS . 3 

CHAPTER 2 

2.1 WITHDRAWN TESTS. 1 

2.2 INAPPLICABLE TESTS . 1 

2.3 TEST MODIFICATIONS . 4 

CHAPITER 3 

3.1 TESTING ENVIRONMENT . 1 

3.2 SUMMARY OF TEST RESULTS. 1 

3.3 TEST EXECUTION. 2 

APPENDIX A 
APPENDIX B 
APPENDIX C 


Validation Summary Report AVFVSR 90502/74 

Afayi Limited Table of Contents - Page i of i Abycomp Ol 7 Veroioo 5.2 














INTRODUCTION 


CHAPTER 1 
INTRODUCTION 


The Ada implementation described above was tested according to the Ada Validation Procedures 
[Pro90] against the Ada Standard [Ada83] using the current Ada Compiler Validation Capability 
(ACVC). This Validation Summary Report (VSR) gives an account of the testing of this Ada 
implementation. For any technical terms used in this report, the reader is referred to [Pro90]. A 
detailed description of the ACVC may be found in the current ACVC User’s Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada Certification Body may make 
full and free public disclosure of this report. In the United States, this is provided in accordance with 
the "Freedom of Information Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this report. 

The organizations represented on the signature page of this report do not represent or warrant that 
all statements set forth in this report are accurate and complete, or that the subject implementation 
has no nonconformities to the Ada Standard other than those presented. Copies of this report are 
available to the public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield 
VA 22161 

Questions regarding this report or the validation test results should be directed to the AVF which 
performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria 
VA 22311 


1.2 REFERENCES 

[Ada83] Reference Manual for the Ada Programming Language. 

ANSI/M1L-STD-1815A, February 1983 and ISO 8652-1987 

[Pro90] Ada Compiler Validation Procedures . 

Version 2.1, Ada Joint Program Office, August 1990. 


Validation Summary Report 


AVF_VSR_90502/74 


Alsys limited 


Chapter 1 - Page 1 of 4 


AbycompOl 7 Version 52 





INTRODUCTION 


[UG89J Ada Compiler Validation Capability User’s Guide. 

21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC contains a 
collection of test programs structured into six test classes: A, B, C, D, E, and L. The first letter of 
a test name identifies the class to which it belongs. Class A, C, D, and E tests are executable. Class 
B and class L tests are expected to produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and produce a PASSED, FAILED, or 
NOT APPLICABLE message indicating the result when they are executed. Three Ada library units, 
the packages REPORT and SPPRT13, and the procedure CHECKFILE are used for this purpose. 
The package REPORT also provides a set of identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test objective. The package 
SPPRT13 is used by many tests for Chapter 13 of the Ada Standard. The procedure CHECK FILE 
is used to check the contents of text files written by some of the Class C tests for Chapter 14 of the 
Ada Standard. The operation of REPORT and CHECK_FTLE is checked by a set of executable tests. 
If these units are not operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class B tests are not executable. 
Each test in this class is compiled and the resulting compilation listing is examined to verify that all 
violations of the Ada Standard are detected. Some of the class B tests contain legal Ada code which 
must not be flagged illegal by the compiler. This behaviour is also verified. 

Class L tests check that an Ada implementation correctly detects violation of the Ada Standard 
involving multiple, separately compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by implementation-specific 
values - for example, the largest integer. A list of the values used for this implementation is 
provided in Appendix A. In addition to these anticipated test modifications, additional changes may 
be required to remove unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this implementation are described in section 2.3. 
For each Ada implementation, a customized test suite is produced by the AVF. This customisation 
consists of making the modifications described in the preceding paragraph, removing withdrawn tests 
(see section 2.1) and, possibly some inapplicable tests (see Section 3.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of the customized test suite 
according to the Ada Standard. 


AVFVSR 90502/74 


Validation Summary Report 
Alsys Limited 


Chapter 1 - Page 2 of 4 


Alsycomp Ol 7 Version 52 



INTRODUCTION 


1.4 DEFINITION OF TERMS 


Ada Compiler 


Ada Compiler 
Validation 
Capability (ACVC) 

Ada Implementation 


Ada Validation Facility 
(AVF) 

Ada Validation 
Organization (AVO) 

Compliance of an Ada 
Implementation 

Computer System 


Conformity 


Customer 


Declaration of 
Conformance 


The software and any needed hardware that have to be added to a 
given host and target computer system to allow transformation of 
Ada programs into executable form and execution thereof. 

The means for testing compliance of Ada implementations, consisting 
of the test suite, the support programs, the ACVC user’s guide and 
the template for the validation summary report. 

An Ada compiler with its host computer system and its target 
computer system 

The part of the certification body which carries out the procedures 
required to establish the compliance of an Ada implementation. 

The part of the certification body that provides technical guidance for 
operations of the Ada Certification system. 

The ability of the implementation to pass an ACVC version. 


A functional unit, consisting of one or more computers and 
associated software, that uses common storage for all or part of a 
program and also for all or part of the data necessary for the 
execution of the program; executes user-written or user-designated 
programs; performs user-designated data manipulation, including 
arithmetic operations and logic operations; and that can execute 
programs that modify themselves during execution. A computer 
system may be a stand-alone unit or may consist of several inter¬ 
connected units. 

Fulfilment by a product, process or service of all requirements 
specified. 

An individual or corporate entity who enters into an agreement with 
an AVF which specifies the terms and conditions for AVF services 
(of any kind) to be performed. 

A formal statement from a customer assuring that conformity is 
realized or attainable on the Ada implementation for which 
validation status is realized. 


Host Computer System A computer system where Ada source programs are transformed into 

executable form. 


Validation S ummar y Report 


AVF_VSR_90502/74 


Afayi Limited 


Chapter 1 - Page 3 of 4 


Ahycomp_017 Version 52 








INTRODUCTION 


Inapplicable test 
Operating System 

Target Computer 
System 

Validated Ada Compiler 

Validated Ada 
Implementation 

Validation 

Withdrawn test 


Validation Summary Report 


A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

Software that controls the execution of programs and that provides 
services such as resource allocation, scheduling, input/output control, 
and data management. Usually, operating systems are predominantly 
software, but partial or complete hardware implementations are 
possible. 

A computer system where the executable form of Ada programs are 
executed. 

The compiler of a validated Ada implementation. 

An Ada implementation that has been validated successfully either 
by AVF testing or by registration [Pro90], 

The process of checking the conformity of an Ada compiler to the 
Ada programming language and of issuing a certificate for this 
implementation. 

A test found to be incorrect and not used in conformity testing. A 
test may be incorrect because it has an invalid test objective, fails to 
meet its test objective, or contains erroneous or illegal use of the 
Ada programming language. 


AVK_VSR_90502/74 


Alxys limited 


Chapter 1 - Page 4 of 4 


Alsyoomp Ol 7 Vctxkxi 52 







IMPLEMENTATION DEPENDENCIES 


CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 
2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for this list of withdrawn tests is 
90-10-12. 


E28005C 

B28006C 

C34006D 

B41308B 

C43004A 

C45114A 

C45346A 

C45612B 

C45651A 

C46022A 

B49O08A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

B85001L 

C83026A 

C83041A 

C97 16A 

C9S003B 

BA20UA 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC122CB 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 





2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant for a given Ada 
implementation. The inapplicability criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Issues and commonly referenced in the format Al-dddd. For this 
implementation, the following tests were inapplicable for the reasons indicated; references to Ada 
Issues are included as appropriate. 


The following 201 tests have floating-point type declarations requiring more digits than 
SY STEM.M AXDIG ITS: 


C24113L..Y (14 tests) 
C35706L .Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


Validation Summary Report 


AVF_VSR 90502/74 


Alsyi Limited 


Chapter 2 - Page 1 of 5 


Alsycomp Ol 7 Version 52 






IMPLEMENTATION DEPENDENCIES 


The following 21 tests check for the predefined type LONG_INTEGER: 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45612C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001W 

C86006C 


CD7101F 

C35404D, C45231D, B86001X, C86006E, and CD7101G check for a predefined integer type with a 
name other than INTEGEP. LONGJNTEGER, or SHORTJNTEGER. 

C35702/V C35713B, C45423B, B86001T. and C86006H check for the predefined type 
SHORTFLOAT. 

C35713D and B86001Z check for a predefined floating-point type with a name other than FLOAT, 
LONG_FLOAT, or SHORT_FLOAT. 

C45531M..P (4 tests) and C45532M..P (4 tests) check fixed-point operati j.ms for types that require a 
SYSTEM.MAX_MANTISSA of 47 or greatei. 

C45536A C46013B, C46031B, C46033B and C46034B contain ’SMALL representation clauses which 
are not powers of two or ten. 

C45624A checks that the proper exception is raised if MACHINE_OVERFLOWS is FALSE for 
floating point types with digits 5, For this implementation, MACHINE_OVERFLOWS is TRUE. 

C45624B checks that the proper exception is raised if MACHlNE_OVERFLOWS is FALSE for 
floatin 0 point types with digits 6. For this implementation, ’MACHINE_OVERFLOWS is TRUE. 

C86001F recompiles package SYSTEM making package fEXT_IO, and hence package REPORT, 
obsolete. For this ; mplementation, the package TEXT_IO is dependent upon package SYSTEM. 

B86001Y checks for a predefined fixed-point type other than DURATION. 

C96005B checks for values of type DURATION’BASE that are outside the range of DURATION. 
There arc no such values for this implementation. 

CD1009C uses a representation clause specifying a non-default size for a floating-point type. 

CD2A53A checks operations of a fixed-point type for which a length clause specifies a power-of-ten 
typc’small. (See 2.3). 

CD2A84A, CD2A84E, CD2A841..J (2 tests), and CD2A840 use representation clauses specifying 
non-default sizes for access types. 

BDS001A, BD8003A, BD8004A..B (2 tests), and /Q8011A use machine code insertions. 


.'alidatioa Summary Report 


AV1VSR 905O2/74 


Alsys limited 


Chapter 2 - Page 2 of 5 


Abycomp_017 Version 5.2 




IMPLEMENTATION DEPENDENCIES 


The tests listed in the following table are not applicable because the given file operations are 
supported for the given combination of mode and file access method. 


Test 

File Operation 

Mode 

File Access Method 

CE2102D 

CREATE 

IN FILE 

SEQUENTIAL IO 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL IO 

CE2102F 

CREATE 

INOUT FILE 

DIRECT IO 

CE2102I 

CREATE 

IN FILE 

DIRECT IO 

CE2102J 

CREATE 

OUT FILE 

DIRECT IO 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL IO 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL IO 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL IO 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL IO 

CE2102R 

OPEN 

INOUT FILE 

DIRECT IO 

CE2102S 

RESET 

INOUT FILE 

DIRECT IO 

CE2102T 

OPEN 

IN FILE 

DIRECT IO 

CE2102U 

RESET 

IN FILE 

DIRECT IO 

CE2102V 

OPEN 

OUT FILE 

DIRECT IO 

CE2102W 

RESET 

OUT FILE 

DIRECT IO 

CE3102E 

CREATE 

IN FILE 

TEXT IO 

CE3102F 

RESET 

Any Mode 

TEXT IO 

CE3102G 

DELETE 


TEXT IO 

CE3102I 

CREATE 

OUT FILE 

TEXT IO 

CE3102J 

OPEN 

IN FILE 

TEXT IO 

CE3102K 

OPEN 

OUT FILE 

TEXT IO 


CE2107B..E (4 tests), CE2107L, CE2110B and CE2111D attempt to associate multiple internal 
sequential files with the same external file when one or more files is open for writing. The proper 
exception is raised when this association is attempted. 

CE2107G..H (2 tests), CE2110D, and CE2111H attempt to associate multiple internal direct files with 
the same external file when one or more files is open for writing. The proper exception is raised 
when this association is attempted. 

CE2203A checks that WRITE raises USEERROR if the capacity of the external file is exceeded for 
SEQUENTIAL_IO. This implementation can not restrict file capacity. 

CE2401H, EE2401D and EE2401G use instantiations of DIRECT_IO with unconstrained array and 
record types; this implementation raises USE ERROR on the attempt to create a file. 

CE2403A checks that WRITE raises USE-ERROR if the capacity of the external file is exceeded for 
DIRECT IO. This implementation does not restrict file capacity. 


Validation S ummar y Report AVF_VSR_90502/74 


Abyt IJmited 


Chapter 2 • Page 3 of 5 


Alsycoo>p_017 Vcnioo 52 








IMPLEMENTATION DEPENDENCIES 


CE3111B, CE3111D..E (2 tests), CE3114B, and CE3115A attempt to associate multiple internal text 
files with the same external file when one or more files is open for writing. The proper exception 
is raised when this association is attempted. 

CE3202A expects that function NAME can be applied to the standard input and output files; in this 
implementation these files have no names, and USE_ERROR is raised. [See 2.3]. 

CE3304A checks that USE_ERROR is raised if a call to SET_LINE_LENGTH or 
SET_PAGE_LENGTH specifies a value that is inappropriate for the external file. This 
implementation does not have inappropriate values for either line length or page length. 

CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the page number exceeds 
COUNT’LAST. For this implementation, the value of COUNT’LAST is greater than 150000 making 
the checking of this objective impractical. 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 26 tests. 


The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the way 
expected by the original tests. 


B23004A 

B32202A 

B45012A 

B74401R 

B97103E 

BC3Q09C 


B24007A 

B32202B 

B61012A 

B91004A 

BAU01B2 

BC3204D 


B24009A 

B32202C 

B74304A 

B95069A 

BA1101B4 


B28003A 

B37004A 

B74401F 

B95069B 

BC2001D 


CD2A53A was graded inapplicable by Evaluation Modification as directed by the AVO. The test 
contains a specification of a power-of-10 value as small for a fixed-point type. The AVO ruled that, 
under ACVC1.11, support of decimal smalls may be omitted. 

CE3202A was graded inapplicable by Evaluation Modification as directed by the AVO. The test will 
abort with an unhandled exception (USE_ERROR) when function NAME is invoked for the standard 
input file. The AVO ruled that this behaviour is acceptable pending a resolution of the issue by the 
ISO WG-9 Ada Rapporteur Group. 

CE3605A was graded passed by Test Modification as directed by the AVO. This test attempts to 
write a line with 516 characters; this exceeds the implementation’s default limit of 503, and 
USE_ERROR is raised. This behaviour is allowed by Al-00534, and so the test was modified as 
follows: 


On line 74, ‘86’ was changed to ‘83’ 


Validation Summary Report 


AVT-VSR9O502/74 


Alsyi Limited 


Chapter 2 - Page 4 of 5 


Abyoomp On Version 5 2 



IMPLEMENTATION DEPENDENCIES 


On line 81, ‘517’ was changed to ‘499’ 

The modified test was processed and passed. 

EA3004D was graded passed by Evaluation and Processing Modification as directed by the AVO. The 
test requires that either pragma INLINE is obeyed for the invocation of a function in each of three 
contexts and that thus three library units are made obsolete by the re-complication of the inlined 
function’s body, or else the pragma is ignored completely. This implementation obeys the pragma 
except when the invocation is within a package specification. When the test’s files are processed in 
the given order, only two units are made obsolete; thus, the expected error ai line 27 of file 
EA3004D6M is not valid and is not flagged. To confirm that indeed the pragma is not obeyed in this 
one case, the test was also processed with the files re-ordered so that the re-compilation follows only 
the package declaration (and thus the other library units will not be made obsolete, as they are 
compiled later); a "NOT APPLICABLE” result was produced, as expected. The revised order of files 
was 0-1-4-5-2-3-6. 


Validation Summary Report AVFVSR 90502/74 

Abyi Limited Chapter 2 - Page 5 of 5 Abycomp_017 Venice 5.2 






PROCESSING INFORMATION 


CHAPTER 3 

PROCESSING INFORMATION 
3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is described adequately by the information 
given in the initial pages of this report. 

For a point of contact for technical information about this Ada implementation system, see: 

Jon Frosdick 
Alsys Limited 
Partridge House 
Newtown Road 
Henley-on-Thames 
Oxfordshire 
RG9 1EN 

For a point of contact for sales information about this Ada implementation system, see: 

John Stewart 
Alsys Limited 
Partridge House 
Newtown Road 
Henley-on-Thames 
Oxfordshire 
RG91EN 

Testing of this Ada implementation was conducted at the customer’s site by a validation team from 
the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test of the customized test 
suite in accordance with the Ada Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC [Pro90], 

For all processed tests (inapplicable and applicable), a result was obtained that conforms to the Ada 
Programming Language Standard. 


a) 

Total Number of Applicable Tests 

3780 

b) 

Total Number of Withdrawn Tests 

81 

c) 

Processed Inapplicable Tests 

309 


Validation Summary Report 


AVF_VSR_90S0y74 


Alxyi I imiicd 


Chapter 3 - Page 1 of 3 


At*ycomp_017 Venkm 5 2 





PROCESSING INFORMATION 


d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point Precision Tests 0 

f) Total Number of Inapplicable Tests 309 (c+d+e) 

g) TotalNumberofTestsforACVCl.il 4170 (a+b+f) 

All I/O tests of the test suite were processed because this implementation supports a file system. All 
floating-point precision tests were processed because this implementation supports floating-point 
precision to the extent that was tested. When this compiler was tested, the tests listed in section 2.1 
had been withdrawn because of test errors. 


3.3 TEST EXECUTION 

Version 1.11 of the ACVC comprises 4170 tests. When this compiler was tested, the tests listed in 
section 2.1 had been withdrawn because of test errors. The AVF determined that 309 tests were 
inapplicable to this implementation. All inapplicable tests were processed during validation testing. 
In addition, the modified tests mentioned in section 2.3 were also processed. 

A Magnetic tape containing the customized test suite (see section 1.3) was taken on-site by the 
validation team for processing. 

The contents of the magnetic tape were loaded onto a SUN 3/160. These were then transferred to 
the MicroVax II host using File Transfer Protocol on an Ethernet link. 

After the test files were loaded onto the host computer, the full set of tests was processed by the Ada 
implementation. 

The tests were compiled and linked on the host computer system, as appropriate. The executable 
images were transferred to the target computer system by the communications link described above, 
and run. The results were captured on the host computer system. 

Testing was performed using command scripts provided by the customer and reviewed by the 
validation team. See Appendix B for a complete listing of the processing options for this 
implementation. It also indicates the default options. The options invoked explicitly for validation 
testing during this test were: 

CALLS=INLINED 

R EDUCTION=EXTENSIVE 

EXPRESSIONS=EXTENSIVE 


OBJECT=PEEPHOLE 


Allows inline insertion of code for subprograms. 

Perform extensive high level optimisations. 

Perform extensive common sub-expression elimination 
optimisations. 

Perform peephole optimisations. 


Validation Summary Report 


AVFVSK 90502/74 


Alsys Limited 


Chapter 3 - Page 2 of 3 


Atsycomp_017 Vcntoo 5.2 






PROCESSING INFORMATION 


MEMORY=1000 

OUTPUT = <file> 


Reserve 1000 Kbytes of memory for all the date manipulated 
in the libraries. 

<file> specifies the name of the compilation listing 
generated. 


WARNING = NO 
DETAIL=NO 
SHOW = NONE 

ERROR=999 

FILEWIDTH=79 
FILELENGTH=999 


Do not include warning messages. 

Do not add extra detail to the error messages. 

Do not print a header and do not include an error summary 
in the compilation listing. 

Set the maximum number of compilation errors permitted 
before compilation is terminated to 999. 

Set width for listing file to 79 columns. 

Disable insertion of form feeds in the output. 


In addition, the following options were used to produce full compiler listings: 

TEXT Print a compilation listing including full source text. 

The default options were used for the Binder 

Test output, compiler and linker listings, and job logs were captured on Magnetic tape and archived 
at the AVF. The listings examined on-site by the validation team were also archived. 


Validation Summary Report 


AVF_VSR_9O502/74 


Abyi 1 imited 


Chapter 3 - Page 3 of 3 


Abycomp_017 Venkm 52 





MACRO PARAMETERS 


APPENDIX A 
MACRO PARAMETERS 

This appendix contains the macro parameters used for customizing the ACVC. The meaning and 
purpose of these parameters are explained in [UG89]. The parameter values are presented in two 
tables. The first table lists the valued that are defined in terms of the maximum input-line length, 
which is the value for $MAX_IN-LEN~also listed here. These values are expressed here as Ada 
string aggregates, where "V" represents the maximum input-line length. 


Macro Parameter Macro Value 


$MAX_IN_LEN 

$BIG_ID1 

$BIG_ID2 

$BIG_ID3 

$BIG_ID4 

$BIG_INT_LIT 

$BIG_REAL_LIT 

$BIG_STRING1 

$BIG_STRING2 

SBLANKS 

$MAX_LEN_INT_BASED_LITERAL 

$MAX_LEN_REAL_BASED_LITERAL 

$MAX_STRING_LITERAL 


255 

(1..V-1 => ’A’, V => T’) 

(1..V-1 => ’A’, V => ’2’) 

(1..V/2 => ’A’) & ’3’ & (1..V-1-V/2 => ’A’) 
(1..V/2 => ’A’) & ’4’ & (1..V-1-V/2 => ’A’) 
(1..V-3 => ’O’) & "298” 

(1..V-5 => ’O’) & "690.0" 

”” & (1..V/2 => ’A’) & ”” 

& (1..V-1-V/2 => ’A’) & T & 

(1..V-20 => ”) 

"2:" & (1..V-5 => ’O’) & "11:" 

"16:" & (1..V-7 => ’O’) & "F.E:" 

’"’ & (1..V-2 => ’A’) & ’"’ 


Validation Summary Report AVFV5R 90502/74 

AJsyi 1 imitwt Appendix A - Page 1 ot 4 Ataycomp_017 Venkn S2 







MACRO PARAMETERS 


MACRO PARAMETERS 

The following table lists all of the other macro parameters and their respective values. 


Macro Parameter 

$ACC_SIZE 

SALIGNMENT 

$COUNT_LAST 

$DEFAULT_MEM_SIZE 

$DEFAULT_STOR_UNIT 

$DEFAULT_SYS_NAME 

$DELTA_DOC 

$ENTRY_ADDRESS 

SENTRYADDRESSl 

$ENTRY_ADDRESS2 

$FIELD_LAST 

$FILE_TERMINATOR 

$FIXED_NAME 

$FLOAT_NAME 

$FORM_STRING 

$FORM_STRING2 

SGREATER THAN DURATION 


Macro Value 

32 

4 

2147483647 

4294967296 

8 

TRANSPUTER 

2#1.0#E-31 

ADDRESS_OF_MEM_BLOCK3 

ADDRESS_OF_MEM_BLOCKl 

ADDRESS_OF_MEM_BLOCK2 

255 
* * 

NO_SUCH_TYPE 

NO_SUCH_TYPE 

tt M 

"CANNOT_RESTRICT_FILE_CAPACrrT 

100000.0 


$GREATER_THAN_DURATION_BASE_LAST 

10000000.0 

$GREATER_THAN_FLOAT_BASE_LAST 1.0E40 
SGREATER THAN FLOAT SAFE LARGE 1.0E38 


Validation Summary Report AVF VSR 90502/74 

Alsys Limited Appendix A - Page 2 of 4 Abycomp_017 Verxion 52 







MACRO PARAMETERS 


^GREATER THAN SHORT FLOAT SAFE LARGE 


SHIGHPRIORITY 

$ILLEGAL_EXTERNAL_FILE_NAME1 

$ILLEGAL_EXTERNAL_FILE_NAME2 

$INAPPROPRIATE_LINE_LENGTH 

$INAPPROPRIATE_PAGE_LENGTH 

$INCLUDE_PRAGMA1 

$INCLUDE_PRAGMA2 

$INTEGER_FIRST 

$INTEGER_LAST 

$INTEGFR_LAST_PLUS_1 

$INTERFACE_LANGUAGE 

$LESS_THAN_DURATION 

$LESS_THAN_DURATION_BASE_FIRST 

$LINE_TERMINATOR 

$LOW_PRIORITY 

$MACHINE_CODE_STATEMENT 

$MACHINE_CODE_TYPE 

$MANTISSA_DOC 

$MAX_DIGITS 

$MAX_INT 

$MAX INT PLUS 1 


SHORT_FLOAT_NOT_SUPPORTED 

10 

[{}] + =?#~@’ 

-1 

-1 

PRAGMA INCLUDE ("A28006D1.TST") 
PRAGMA INCLUDE ("B28006D1.TST") 
-2147483648 
2147483647 
2147483648 
OCCAM 
- 100000.0 
- 10000000.0 
ASCII.LF 
1 

NULL; 

NO_SUCH_TYPE 

31 

15 

2147483647 

2147483648 


Validation S ummar y Report 


AVFVSR 90502/74 


Abya 1 imitcd 


Appendix A - Page 3 of 4 


Abycomp_017 Venkn 5 2 






MACRO PARAMETERS 


$MIN_INT 

$NAME 

$NAME_LIST 

$NAME_SPECIFICATION 1 

$NAME_SPECIFICATION2 

$NAME_SPECIFICATION3 

$NEGJBASED_INT 

$NEW_MEM_SIZE 

SNEWSTORUNIT 

$NEW_SYS_NAME 

$PAGE_TERMINATOR 

SRECORDDEFINITION 

SRECORDNAME 

$TASK_SIZE 

$TASK_STORAGE_SIZE 

STICK 

$VARIABLE_ADDRESS 

$VARIABLE_ADDRESS1 

$VARIABLE_ADDRESS2 

SYOURPRAGMA 


-2147483648 

NO_SUCH_TYPE 

180X86,I80386,MC680X0,S370,TRANSPLTTER,VAX 

X2120A 

X2120B 

X3119A 

16#FFFFFFFF# 

RELEV ANT_TESTS_WITHDRAWN 
RELEV ANTTESTSWITHDRAWN 
RELEVANT_TESTS_ WITHDRAWN 

» y 

NEW INTEGER 

NO_SUCH_MACHINE_CODE_TYPE 

32 

2048 

64.0E-6 

ADDRESS_OF_MEM_BLOCK3 

ADDRESS_OF_MEM_BLOCKl 

ADDRESS_OF_MEM_BLOCK2 

NO_SUCH_PRAGMA 


Validation Summary Report 


AVFVSR 90502/74 


Ateys limited 


Appendix A - Page 4 of 4 


Abyoomp_017 Venioo 52 






COMPILATION SYSTEM OPTIONS 


Compiler Options 
SOURCE -filejiame 
LIBRARY =library_name 
ANNOTATE^" 

LEVEL=UPDATE 

ERRORS=999 

CHECKS=ALL 

GENERICS=INLINE 

MEMORY=500 OR 1000 

CODE=4 

DATA=1 

INTERFACE=4 

OUTPUT -file jxarne 
TEXT=YES or NO 


Validation Summary Report 


APPENDIX B 

COMPILATION SYSTEM OPTIONS 


The name of the source file. 

The name of the Ada program library. 

User specified character string annotating compilation unit 
as stored in library. 

Compilation level - complete compilation of source code into 
object code and update of program library. 

Number of errors permitted before compilation is 
terminated. 

All run time checks to be performed, except those explicitly 
suppressed by use of pragma SUPPRESS. 

Place code of generics instantiations inline in the same unit 
as the instantiation rather than in separate units. 

Number of Kbytes reserved in memory for compiler data 
(before swapping commences). Set to 500 for the 
AlsyCOMP_037 validation and 1000 for the AlsyCOMP_017 
validation due to different host memory availability. 

Number of transputer prefix instructions used to construct 
Ada code addresses. 

Number of transputer prefix instructions used to construct 
Ada data addresses. 

Number of transputer prefix instructions used to construct 
interface code addresses. 

Compilation listing file name. 

Controls inclusion of full source test in the compilation 
listing. Set to YES for tests requiring compilation listings (ie 
B tests). Set to NO for tests not requiring compilation 
listings (ie non-B tests). 


AVFVSR 90502/74 


AUys limited 


Appendix B - Page 1 of 3 


Abycorop_017 Vernon 52 






COMPILATION SYSTEM OPTIONS 


WARNING=NO 
SHOW=NONE 

DETAIL=NO 

ASSEMBLY=NONE 

STACK=8 

CALLS=INLINED 
REDUCTION=EXTENSIVE 
EXPRESSIONS=EXTENSIVE 
OBJECT=PEEPHOLE 
COPY=NO 

DEBUG-NO 
TREE=NO 
FILE_WIDTH=79 
FILE_LENGTH=9999 

Binder Options 
PROGRAM -umtjiame 
LIBRARY =library_name 
LEVEL=LINK 


Do not include warning messages in the compilation listing. 

Do not print a header on compilation listing pages, nor an 
error summary at the end. 

Do not print extra detail in error messages in the 
compilation listing. 

Do not include an assembly listing of generated code in the 
compilation listing. 

Maximum size in bytes for objects allocated in the main 
execution stack. Objects bigger than this limit are allocated 
on an auxiliary stack. 

Allow inline insertion of code for subprograms. 

Optimise run-time checks and remove dead code. 

Optimise expression evaluation. 

Optimise locally the object code as it is generated. 

Do not save a representation of the source code in the 
program library. 

Do not save information for debugging. 

Do not save information for cross referencing. 

Width of compilation listing page in columns. 

Length of compilation listing page in lines (effectively 
unpaginated). 


The name of the main unit of the Ada program. 

The name of the Ada program library. 

Binding level - complete bind to produce an object module, 
followed by invocation of the INMOS ilink and iboot tools to 
produce a bootable load module. 


AVFVSR_90S02/74 


Validation Summary Report 
Afay* Limited 


Appendix B - Page 2 of 3 


Abycoop_017 Venioo 52 






COMPILATION SYSTEM OPTIONS 


OBJECT=AUTOMATIC 

UNCALLED=REMO VE 

SLICE=NO 

HISTORY=MAIN 

ENTRYJPOINY=AUTOMATIC 

SIZE_MAIN = 160 
RATIO_MAJN=20 
FAST_MAIN = NO 

SIZE_TASK=16 

RATIO_ rASK=50 
FASTT AS K=NO 

TARGET=DEFAULT 

DIRECTIVES="" 

MODULES^" 

SEARCH="" 


OUTPUT =file_name 
DATA=NONE 

WARNING = NO 
DEBUG=NO 


Load module name derived automatically from PROGRAM 
name. 

Remove the code for uncalled subprograms from the 'oau 
module. 

Invoke the task scheduler onlv at synchronization points. 

Trace the propagation of exceptions unhandled in the main 
program. 

Entry point name derived automatically from PROGRAM 
name. 

Number of Kbytes allocated to the main program stacks. 

Percentage of SIZE_MAIN allocated to the prin.ary stack. 

Allocated the stacks of the main program in external memory 
(as opposed to on-chip memory). 

Default number of Kbytes allocated to task stacks (in 
absence of explicit length clause). 

Percentage of SIZE_TASK allocated to the prima- stack. 

Allocated task stacks in external memory (as opposed to on- 
chip memory). 

Use the defauL OCCAM harness code for the target 
processor. 

User specified directives for the INMOS linker tool. 

Use specified object modules to be included in tho INMOS 
link step. 

User specified object libraries to be included in the INMOS 
link step. 

Binder listing file name. 

Do not print additional mapping information in the binder 
listing. 

Do not print warning messages in the binder listing. 

Do not save information for debugging. 


Validation Summary Report 


AVFVSR 90502/74 


/Jays I .united 


Appendix B ■ Page 3 of 3 


Ateycomp_017 Version 52 






APPENDIX F OF THE Ada STANDARD 


APPENDIX C 

APPENDEX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to implementation-dependent pragmas, 
10 certain machine-dependent conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions or representation clauses. The implementation-dependent characteristics 
of this Ada implementation, as described in this Appendix, are p ovided by the customer. Unless 
specifically noted othetwise, references in this Appendix are to compiler documentation and not to 
ibis report. Implementation-specific portions of the package STANDARD, which are not a part of 
Appendix F, are: 


package STANDARD is 

type INTEGER is range -2**31 .. 2**31-1; 
type SHORT INTEGER is range -2**7 .. 2**7-l; 

type FLOAT is digits 6 range -(2.0-2.0**127 .. (2.0-2.0**(-23))*2.0**127; 
type LONG FLOAT is digits 15 range -(2.0-2.0**(-51))*2.0**102: .. 

(2.0-2.0**(51))*2.0**1023; 

type DURATION is delta 2.0**-14 range -131_072.0..131_071.0 


end STANDARD; 


Validation Summary Report 


AVF_VSR 90502/74 


Alsys I jmitci' 


Appendix C - Page 1 


Abycomp_017 Version 5.2 





Alsys Ada Compilation System 
for the Transputer 
APPENDIX F 

Implementation - Dependent Characteristics 
Version 5 


Alsys S_4. 

29, Avenue Luciett-Rcne Duschesne 
78170 La Celle Si Cloud, France 


Als\ f s Inc. 

67 South Bedford Srrcer 
Burlington, KiA 01803-5152, U S-A 


Alsys GmbH 
Am Ruppurrer Schlofl 7 
D- 7500 Karlsruhe 51,Germany 


Alsys Ltd 

Partridge House, Newtown Road 
Henley-on-Thames 
Oxon, RG9 JEN, U K. 


Alsys AB 

Patron Pehr Vdg 10 
Box 1085 

141 22 Huddingc, Stockholm, Sweden 


Alsys KKE 

223-1 Yamashita-oho 
Naka-ku, Yokohama, 231, Japan 


Copyright 1990 by Alsys 


All rights reserved. No part of this document may be reproduced in any form or by any 
means without permission in writing from Alsys. 

Printed: August 1990 

Alsys reserves the right to make changes in specifications and other information 
contained in this publication without prior notice, and the reader should in all cases 
consult Alsys to determine whether such changes have been made. 


PREFACE 


This Appehdix F is for programmers, software engineers, project managers, educators and 
students who want to develop an Ada program for the 1NMOS transputer. 

This appendix is a required part of the Reference Manual for the Ada Programming 
Language , ANSI/MIL-STD 1815A, January 1983 (throughout this appendix, citations in 
square brackets refer to this manual). 

This document assumes that the reader has some knowledge of the architecture of the 
transputer. Access to the document Occam2 Toolset User Manual [Ref. 3} which 
describes the program development environment for occam as supplied by INMOS 
would also be advantageous. 


Preface 


i 


Alsys Ada for the Transputer, Appendix F, i'5 







TABLE OF CONTENTS 


INTRODUCTION 1 

1 Implementation-Dependent Pragmas 3 

1.1 INLINE 3 

1.2 INTERFACE 3 

1.2.1 Calling Conventions 4 

1.2.2 Parameter-Passing Conventions 4 

1.2.3 Parameter Representations 5 

1.2.4 Restrictions on Interfaced Subprograms 8 

1.3 INTERFACE_NAME 9 

1.4 INDENT 10 

1.5 Other Pragmas 10 

2 Implementation-Dependent Attributes 11 

3 Specification of the Package SYSTEM 13 

4 Restrictions on Representation Clauses 17 

4.1 Enumeration Types 18 

4.2 Integer Types 21 

4.3 Floating Point Types 24 

4.4 Fixed Point Types 26 

4.5 Access Types 29 

4.6 Task Types 30 

4.7 Array Types 32 

4.8 Record Types 36 


Table of Contents 


5 

Conventions for Implementation-Generated Names 

47 

6 

Address Clauses 

49 

6.1 

Address Clauses for Objects 

49 

6.2 

Address Clauses for Program Units 

49 

6.3 

Address Clauses for Entries 

49 

7 

Restrictions on Unchecked Conversions 

51 

8 

Input-Output Packages 

53 

8.1 

NAME Parameter 

53 

8.2 

FORM Parameter 

53 

8.2.1 

File Sharing 

54 

8.2.2 

Binary Files 

55 

8.2.3 

Buffering 

56 

8.2.4 

Appending 

57 

8.3 

USEERROR 

57 

9 

Characteristics of Numeric Types 

59 

9.1 

Integer Types 

59 

9.2 

Boating Point Type Attributes 

60 

9.3 

Attributes of Type DURATION 

61 


REFERENCES 

63 


INDEX 

65 


AlsysAda for the Transputer, Appendix F, \'5 


INTRODUCTION 


Implementation-Dependent Characteristics 


This appendix summarizes the implementation-dependent characteristics of the Alsys 
Ada Compilers for the INMOS transputer. This document should be considered as the 
Appendix F to the Reference Manual for the Ada Programming Language ANSI/MIL- 
STD 1815A, January 1983, as appropriate to the Alsys Ada implementation for the 
transputer. 

Sections 1 to 8 of this appendix correspond to the various items of information required 
in Appendix F (FJ*; sections 9 and 10 provide other information relevant to the Alsys 
implementation. The contents of these sections is described below: 

1. The form, allowed places, and effect of every implementation-dependent pragma. 

2. The name and type of every implementation-dependent attribute. 

3. The specification of the package SYSTEM {13.7). 

4. The list of all restrictions on representation clauses [13.1]. 

5. The conventions used for any implementation-generated names denoting 
implementation-dependent components (13.4). 

6. The interpretation of expressions that appear in address clauses. 

7. Any restrictions on unchecked conversions [13.10.2]. 

8. Any implementation-dependent characteristics of the input-output packages [14], 

9. Characteristics of numeric types. 


* Throughout this manual, citations in square brackets refer to the Reference Manual 
for the Ada Programming Language, ANS1/M1L-STD-1815A, January 1983. 


Implementation-Dependent Characteristics 


1 


Throughout this appendix, the name Ada Run-Time Executive refers to the run-time 
library routines provided for all Ada programs. These routines implement the Ada heap, 
exceptions, tasking control, I/O, and other utility functions. 


2 


Alsys Ada for the Transputer, Appendix F, v5 


CHAPTER 1 


Implementation-Dependent Pragmas 

1.1 INLINE 

Pragma INLINE is fully supported, except for the fact that it is not possible to inline a 
function call in a declarative part. 

1.2 INTERFACE 

Ada programs can interface to subprograms written in occam through the use of the 
predefined pragma INTERFACE [13.9J and the implementation-defined pragma 
INTERFACE_NAME. 

Pragma INTERFACE specifies the name of an interfaced subprogram and the name of 
the programming language for which calling and parameter passing conventions will be 
generated. Pragma INTERFACE takes the form specified in the Reference Manual: 

pragma INTERFACE (language jtame, subprogramjiame)', 

where: 

■ language name is the name of the other language whose calling and parameter 
passing conventions are to be used. 

■ subprogram jiame is the name used within the Ada program to refer to the 
interfaced subprogram. 

The only language name currently accepted by pragma INTERFACE is Occam. 

The language name used in the pragma INTERFACE does not necessarily correspond to 
the language used to write the interfaced subprogram. It is used only to tell the 
Compiler how to generate subprogram calls, that is, which calling conventions and 
parameter passing techniques to use. 


Implementation-Dependen t Pragmas 


3 


The language name occam is used to refer to the standard occam calling and parameter 
passing conventions for the transputer [Ref. 4, Section 5.10J. The programmer can use 
the language name occam to interface Ada subprograms to subroutines written in any 
language that follows the standard occam calling conventions. 


1.2.1 Calling Conventions 

The following calling conventions are required for code to be called from Ada by use of 
the pragma interface to occam. 

On entry to the subprogram, the registers A, B and C are undefined. For the T8 only, the 
floating point registers FA, FB and FC are similarly undefined. The return address and 
any parameters are accessed relative to the workspace pointer, W, by the subprogram. 

There are no assumptions concerning the contents of the register stacks (A, B, C and FA, 
FB, FC) upon return from the interfaced subprogram, other than for interfaced 
subprograms which are functions (see below). However, the workspace pointer, W, 
should contain the same address upon return from the interfaced subprogram as it 
contained before the call. 

The setting of the error flag is ignored on return. 


1.2.2 Parameter-Passing Conventions 

On entry to the subprogram, the first word above the transputer workspace pointer 
contains the return address of the called subprogram. Subsequent workspace locations 
(from W+l to W+n, where n is the number of parameters) contain the subprogram 
parameters, which are all one word in length. 

There is always an implicit vector space parameter passed as the last parameter to all 
interfaced subprograms. This points to an area of free memory which can be used by the 
occam compiler to allocate arrays declared in the interfaced subprogram. 

Actual parameters of mode in which are access values or scalars of one machine word or 
less in size are passed by copy. If such a parameter is less that one machine word in 
length it is sign extended to a full word. For all other parameters the value passed is the 
address of the actual parameter itself. 


4 


Als)'s Ada for the Transputer, Appendix F, v5 


Since all large scalar, non-scalar and non-access parameters to interfaced subprograms 
are passed by address, they cannot be protected from modification by the called 
subprogram even though they may be formally declared to be of mode in. It is the 
programmer's responsioility to ensure that the semantics of the Ada parameter modes 
are honoured in these cases. 

If the subprogram is a function whose result is at most one machine word in length, 
register A is used to return the result. All other results are returned by address in 
register A 

No consistency checking is performed between the subprogram parameters declared in 
Ada and the corresponding parameters of the interfaced subprogram. It is the 
programmer’s responsibility to ensure correct access to the parameters. 


1.23 Parameter Representations 

This section describes the representation of values of the types that can be passed as 
parameters to an interfaced subprogram. The discussion assumes no representation 
clauses have been used to alter the default representations of the types involved. 

Chapter 4 describes the effect of representation clauses on the representation of values. 

Integer Types 13-5-41 

Ada integer types are represented in two’s complement form and occupy a byte 
(SHORTJNTEGER) or a word (INTEGER). 

Parameters to interfaced subprograms of type SHORTJNTEGER are passed by copy 
with the value sign extended to a full machine word. Values of type INTEGER are 
always passed by copy. The predefined type LONG_lN 1EGER is not available. 

Enumeration Types 13.5.1] 

Values of an Ada enumeration type are represented internally as unsigned values 
representing their position in the list of enumeration literals defining the type. The first 
literal in the list corresponds to a value of zero. 

Enumeration types with 256 elements or fewer are represented in 8 bits. All other 
enumeration types are represented in 32 bits. 


Implementation-Dependent Pragmas 


5 


Consequently, the Ada predefined type CHARACTER [3.5.2] is represented in 8 bits, 
using the standard ASCII codes [C] and the Ada predefined type BOOLEAN [3.5.3] is 
represented in 8 bits, with FALSE represented by the value 0 and TRUE represented by 
the value 1. 

As the representation of enumeration types is basically the same as that of integers, the 
same parameter passing conventions apply. 

Floating Point Types [3.5.7, 3.5.8] 

Ada floating-point values occupy 32 (FLOAT) or 64 (LONG_FLOaT) bits, and are held 
in ANSI/IEEE 754 floating point format. 

Parameters to interfaced subprograms of type FLOAT are always passed by copy. 
Parameters of type LONG_FLOAT are passed by address. 

Fixed Point Types [3.5.9, 3.5.10] 

Ada fixed-point types are managed by the Compiler as the product of a signed mantissa 
and a constant small. The mantissa is implemented as an 8 or 32 b>t integer value. 

Small is a compile-time quantity which is the power of two equal or immediately inferior 
to the delta specified in the declaration of the type. 

The representation of an actual parameter of a fixed point type is the value of its 
mantissa. This is passed using the same rules as for integer types. 

The attribute MANTISSA is defined as the smallest number such that: 

2 ** MANTISSA >= max (abs (upper_bound), abs (lower_bound)) I small 

The size of a fixed point type is: 

MANTISSA Size 

1.. 7 8 bits 

8.. 31 32bits 

Fixed point types requiring a MANTISSA greater than 31 are not supported. 


6 


Alsys Ada for the Transputer, Appendix F, v5 



Access Types [3.8] 


Values of access types are represented internally by the address of the designated object 
held in single word. The value MIN_INT (the smallest integer that can be represented in 
a machine word) is used to represent null. 

Array Types [3.6] 

Ada arrays are passed by address; the value pass' i is the address of the first element of 
the first dimension of the array. The elements ot the array are allocated by row. When 
an array is passed as a parameter to an interfaced subprogram, the usual consistency 
checking between the array bounds declared in the calling and the called subprogram is 
not enforced. It is the programmer's responsibility to ensure that the subprogram does 
not violate the bounds of the array. 

When passing arrays to occam, it may be the case that some of its bounds arc undefined 
in the source of the interfaced subprogram. If this is true, the missing bounds should be 
passed as extra integer value parameters to the subprogram. These parameters should be 
placed immediately following the array parameter itself and in the same order as the 
missing strides appear in the occam source. 

Values of the predefined type STRING [3.6.3] are arrays, and are passed in the same way: 
the address of the first character in the string is passed. Elements of a string are 
represented in 8 bits, using the standard ASCII codes. The elements are packed into one 
or more words and occupy consecutive locations in memory. 

Record Types [3.7] 

Ada records are passed by address; the value passed is the address of the first component 
of the record. Components of a recoru are aligned on their natural boundaries (e.g. 
INTEGER on a word boundary) and the components may be re-ordered by the Compiler 
so as to minimize the total size of objects of »he record type. If a record contains 
discriminants or components having a dynamic size, implicit components may be added 
to the record. Thus the default layout of the internal structure of the record may not be 
interred directly from its Ada declaration. The use of a representation clause control 
the layo it of any record type whose values are to be passed to intei faced subprograms is 
recommended. 


Implementation-Dependent Pragmas 


7 




1.2.4 Restrictions on Interfaced Subprograms 

interfaced occam subprograms must be compiled using the UNIVERSAL erro; mode 
(X). In this mode, thete is no error checking and any run-time errors in the occam code 
are ignored This ensures that processes do not execute a STOPP or STOPERR 
instruction and avoids the unpredictable t esuits which may occur if this is allowed to 
happen. 

Par imeters which are of a task or pri> ne type, or are access values not of mode in, 
should not be passed to interfaced subprograms. 

It is not possible t^ interface to occam functions which return floating point values, nor 
to those which have more that one return value. Also, records and arrays cannot be 
returned from interfaced subprograms. 


8 


Alsys Ada for the Transputer, Appendix F, \’5 



1.3 1NTERFACE_NAME 

Pragma INTERFACE_N AME associates the name of an interfaced subprogram, as 
declared in Ada, with its name in the language of origin. If pragma INTERFACE_NAME 
is not used, then the two names are assumed to be identical. 

This pragma takes the form: 

pragma INTERFACE_NAME (subprogram jiamc , string Jitcral)\ 
where: 

• subprogram name is the name used within the Ada program to refer to the 
interfaced subprogram. 

• string literal is ihe name by which the interfaced subprogram is referred to at link¬ 
time. 

The use of INTERFACE N AME is optional and is not needed if a subprogram has the 
same name in Ada as in the language of origin. It is necessary, for example, if the name 
of the subprogram in its original language contains characters that are not permitted in 
Ada identifiers. Ada identifiers can contain only letters, digits and underscores, whereas 
the 1NMOS linker allows external names to contain other characters, for example full 
stops. These characters can be specified in the stringliteral argument of the pragma 
INTERFACENAME. 

The pragma INTERFACE_NAME is allowed at the same places of an Ada program as the 
pragma INTERFACE [13.9J. However, the pragma 1NTERFACE_NAME must always 
occur after the pragma INTERFACE declaration for the interfaced subprogram. 


Example 

package SAMPLE DATA is 

function SAMPLE DEVICE (X . INTEGER) return INTEGER; 
function PROCESS_SAMPLE (X : INTEGER) return INTEGER; 
private 

pragma INTERFACE (OCCAM, SAMPLEDEVICE); 
pragma INTERFACE (OCCAM, PROCESS_SAMPLE); 
pragma INTERFACE_NAME (PROCESS_SAMPLE, ’process.sample’); 
end SAMPLEDATA; 


Implementation-Dependent Pragmas 


9 



1.4 INDENT 


This pragma is only used with the Alsys Reformatter (AdaReformat)-, this tool offers the 
functionalities of a source reformatter in an Ada environment. 

The pragma is placed in the source file and interpreted by the Reformatter. 

pragma INDENT(OFF) 

The Reformatter does not modify the source lines after the OFF pragma INDENT, 
pragma INDENT(ON) 

The Reformatter resumes its action after the ON pragma INDENT. Therefore any source 
lines that are bracketed by the OFF and ON pragma INDENTS are not modified by the 
Alsys Reformatter. 


1.5 Other Pragmas 

Pragmas IMPROVE and PACK are discussed in detail in the section on representation 
clauses (Chapter 4). 

Pragmas STORAGE_SIZE_RATIO and FASTP RI MARY which are applicable only 
to task types are discussed in detail in section 4.6. 

Pragma PRIORITY is accepted with the range of priorities running from 1 to 10 (see the 
definition of the predefined package SYSTEM in Chapter 3). The undefined priority (no 
pragma PRIORITY) is treated as though it were less than any defined priority value. 

In addition to pragma SUPPRESS, it is possible to suppress checks in a given compilation 
by the use of the Compiler option CHECKS. 

The following language defined pragmas have no effect. 

CONTROLLED 

MF.MORY_SIZE 

OPTIMIZE 

STORAGE_UNIT 

SYSTEM_NAME 

Note that all access types are implemented by default as controlled collections as 
described in (4.8). 


10 


Alsys Ada for the Transputer, Appendix F, v5 





CHAPTER 2 


Implementation-Dependent Attributes 

In addition to the Representation Attributes of [13.7.2] and [13.7.3], the four attributes 
listed in section 5 (Conventions for Implementation-Generated Names), for use in 
record representation clauses, and the attributes described below are provided: 

TDESCRIPTOR_SIZE For a prefix T that denotes a type or subtype, this 

attribute yields the size (in bits) required to hold a 
descriptor for an object of the type T, allocated on 
the heap or written to a file. If T is constrained, 
TDESCRlPTOR_SlZE will yield the value 0. 

T1S ARRAY For a prefix T that denotes a type or subtype, this 

attribute yields the value TRUE if T denotes an 
array type or an array subtype; otherwise, it yields 
the value FALSE. 


Limitations on the use of the attribute ADDRESS 

The attribute ADDRESS is implemented for all prefixes that have meaningful addresses. 
The following entities do not have meaningful addresses. The attribute ADDRESS will 
deliver the value SYSTEM.NULL_ADDRESS if applied to such prefixes and a compilation 
warning will be issued. 

■ A constant or named number that is implemented as an immediate value (i.e. does 
not have any space allocated for it). 

a A package specification that is not a library unit. 

a A package body that is not a library unit or subunit. 

If the attribute ADDRESS is applied to a named number, a compilation error will be 
produced. 


Implementation-Dependent Attributes 


)) 






CHAPTER 3 


Specification of the Package SYSTEM 


package SYSTEM is 

type NAME is (180X86, 

I80386, 

MC680XO, 

S370, 

transputer, 

VAX); 

SYSTEM_NAME : constant NAME := TRANSPUTER; 

STORAGE UNIT ;■ constant := 8; 

MAX INT - : constant := 2**31 - 1; 

MIN'iNT : constant := - (2**31); 

MAX _ MANTISSA : constant : = 31; 

FINE DELTA : constant := 2#1.ORE-31; 

MAXOIGITS : constant := 15; 

MEMORYSIZE : constant := 2**32; 

TICK : constant := 64.Oe - 6; 

subtype PRIORITY is INTEGER range 1 .. 10; 

type ADDRESS is private; 

NULl_ADORESS : constant ADDRESS; 


function VALUE (LEFT : in STRING) return ADDRESS; 

subtype ADDRESS_STR!NG is STRING(1..8); 

function IMAGE (LEFT : in ADDRESS) return ADDRESS_STRING; 


type OFFSET is range -(2**31) .. 2**31-1; 

-• This type is used to measure a nutber of storage inits (bytes), 
function SAME_SEGHENT (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 
ADDRESS_ERR0R : exception; 


function «♦" (LEFT : in ADDRESS; RIGHT : in OFFSET) return ADORESS 
function (LEFT : in OFFSET; RIGHT : in ADDRESS) return ADDRESS 


Specification of the Package SYSTEM 


function (LEFT : in ADDRESS; RIGHT : in OFFSET) return ADDRESS; 

function (LEFT : in ADDRESS; RIGHT : in ADDRESS) return OFFSET; 


function "«=•' (LEFT, RIGHT : in ADDRESS) 
function "<•• (LEFT, RIGHT : in ADDRESS) 
function ••>=■• (LEFT, RIGHT : in ADDRESS) 
function "»» (LEFT, RIGHT : in ADDRESS) 


return BOOLEAN, 
return BOOLEAN 
return BOOLEAN 
return BOOLEAN 


function "mod" (LEFT : in ADDRESS; RIGHT : in POSITIVE) return NATURAL; 


type ROUNDED IRECTION is (DOWN, UP); 

function ROUND (VALUE : in ADDRESS; 

DIRECTION : in ROUND DIRECTION; 

HOOULUS : in POSITIVE) return ADDRESS; 


generic 

type TARGET is private; 

function FETCH_FROM_ADDRESS (A : in ADDRESS) return TARGET; 
generic 

type TARGET is private; 

procedure ASSIGN_TO_ADDR£S$ (A : in ADDRESS; T : in TARGET); 

-- These routines are provided to perform READ/WRITE operations in memory. 


type OBJECTJ.ENGTH is range 0 .. 2**31 -1; 

-- This type is used to designate the size of an object in storage units. 

procedure HOVE (TO : in ADORESS; 

FROM : in ADDRESS; 

LENGTH : in OBJECT_LENGTH); 


end SYSTEM; 


The function VALUE may be used to convert a string into an address. The string is a 
sequence of up to eight hexadecimal characters (digits or letters in upper or lower case in 
the range A..F) representing the address. The exception CONSTRAINT_ERROR is raised 
if the string does not have the proper syntax. 

The function IMAGE may be used to convert an address to a string which is a sequence of 
exactly eight hexadecimal digits. 

The function SAME_SEGMENT always returns TRUE and the exception 
ADDRESS ERROR is never raised as the transputer is a non segmented architecture. 


14 


Alsys Ada for the Transputer, Appendix F, v5 



The functions ”+’ and with an ADDRESS and an OFFSET parameter provide support 
to perform address computations. The OFFSET parameter is added to, or subtracted 
from the address. The exception CONSTRAINT_ERROR can be raised by these 
functions. 

The function with the two ADDRESS parameters may be used to return the distance 
between the specified addresses. 

The functions " > =" and ’ > ’ may be used to perform a comparison on the 

specified addresses. The comparison is unsigned. 

The function "mod" may be used to return the offset of LEFT address relative to the 
memory block immediately below it starting at a multiple of RIGHT storage units. 

The function ROUND may be used to return the specified address rounded to a specific 
value in a particular direction. 

The generic function FETCH _FROM_aDDRESS may be used to read data objects from 
given addresses in store. The generic function ASSlGN_TO_ADDRESS may be used to 
write data objects to give 1 addtjsses in store. These routines may not be instantiated 
with unconstrained types. 

The procedure MOVE may be used to copy LENGTH storage units starting at the address 
FROM to the address TO. The source and destination locations may overlap. 


Specification of the Package SYSTEM 


15 



CHAPTER 4 


Restrictions on Representation Clauses 


This section explains how objects are represented and allocated by the Alsys Ada 
Compiler for the Transputer and how it is possible to control this using representation 
clauses. 

The representation of an object is closely connected with its type. For this reason this 
section addresses successively the representation of enumeration, integer, floating point, 
fixed point, access, task, array and record types. For each class of type the representation 
of the corresponding objects is described. 

The transputer supports operations on the data types byte, word and double-word, so 
these data types are used to form the basis of the representation of Ada types. The word 
length is 32 bits. Currently, the compiler does not support operations on double 32 bit 
word quantities. This affects the representation of integer, fixed point and enumeration 
types. 

Except in the case of array and record types, the description of each class of type is 
independent of the others. To understand the representation of an array type it is 
necessary to understand first the representation of its components. The same rule 
applies to a record type. 

Apart from implementation defined pragmas, Ada provides three means to control the 
size of objects: 

■ a (predefined) pragma PACK, when the object is an array, an array component, a 
record or a record component 

■ a record representation clause, when the object is a record or a record component 

■ a size specification, in any case. 

For each class of types the effect of a size specification is described. Interaction between 
size specifications, packing and record representation clauses is described under array 
and record types. 


Restrictions on Representation Clauses 


17 


Size representation clauses on types derived from private types are not supported when 
the derived type is declared outside the private part of the defining package. 


4.1 Enumeration Types 

Internal codes of enumeration literals 

When no enumeration representation clause applies to an enumeration type, the 
internal code associated with an enumeration literal is the position number of the 
enumeration literal. Then, for an enumeration type with n elements, the internal codes 
are the integers 0,1,2,..., n-1. 

An enumeration representation clause can be provided to specify the value of each 
internal code as described in (13.3]. The AJsys Compiler fully implements enumeration 
representation clauses. 

As internal codes must be machine integers the internal codes provided by an 
enumeration representation clause must be in the range -2 3 '.. 2 31 -1. 


Encoding of enumeration values 

An enumeration value is always represented by its internal code in the program 
generated by the Compiler. 


Enumeration subtypes 

Minimum size: The minimum size of an enumeration subtype is the minimum number 
of bits that is necessary for representing the internal codes of the subtype values in 
normal binary form. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M are 
the values of the internal codes associated with the first and last enumeration values of 
the subtype, then its minimum size L is determined as follows. For m > = 0, L is the 
smallest positive integer such that M < = 2 L -1. For m < 0, L is the smallest positive 
integer such that -2‘~ 1 < = m and M < = 2 L1 -1. 


18 


Alsys Ada for the Transputer, Appendix F, v5 


For example: 

type COLOR is (GREEN, BLACK, WHITE, RED, BLUE, YELLOW); 

— The minimum size of COLOR is 3 bits. 

subtype BLACK_AND_WHITE is COLOR range BLACK .. WHITE; 

— The minimum size of BLACK_AND_WHITE is 2 bits. 

subtype BLACK_OR_WHITE is BLACK_AND_WHITE range X .. X; 

- Assuming that X is not static, the minimum size of BLACK_OR_WHITE is 
-- 2 bits (the same as the minimum size of the static type mark 

- BLACK_AND_WHITE). 

Size: When no size specification is applied to an enumeration type or first named 
subtype, the objects of that type or first named subtype are represented as either 
unsigned bytes or signed words. The Compiler selects automatically the smallest such 
object which can hold each of the internal codes of the enumeration type (or subtype). 
The size of the enumeration type and of any of its subtypes is thus 8 bits in the case of an 
unsigned byte, or the machine word size (32 bits) in the case of a signed word. 

When a size specification is applied to an enumeration type, this enumeration type and 
each of its subtypes has the size specified by the length clause. The same rule applies to a 
first named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies. 

For example: 

type EXTENDED is 

( - The usual American ASCII characters. 


NUL, 

SOH, 

STX, 

ETX, 

EOT, 

ENQ, 

ACK, 

BEL, 

BS, 

HT, 

LF, 

VT, 

FF, 

CR, 

SO, 

SI, 

DLE, 

DC1, 

DC2, 

DC3, 

DC4, 

NAK, 

SYN, 

ETB, 

CAN, 

EM, 

SUB, 

ESC, 

FS, 

GS, 

RS, 

US, 

• \ 

M* 

• t 


•#’, 



•&\ 

if* 


7. 

»•* 


V, 



r. 

’O', 

T, 

’2’, 

'3', 

’4’, 

’5'. 

’6’, 

T, 

’8’, 

•9’, 

V, 

;, 




* * 

’@\ 

’A’, 

•B\ 

•c. 

•D\ 

’E\ 

’F, 

•G’, 


T, 

’S’, 

’K', 

’L’, 

’M’, 

’N’, 

’O', 

•P’, 

•O’, 

’R\ 

’S’, 

T, 

'U\ 

V, 

’W-, 

’X‘, 

’Y\ 

•z\ 

T. 

Y, 

T. 

» A 1 

^ y 

»** 

’a’, 

'b\ 

’c'. 

'd’, 

'e'. 

T, 

’g’. 


Restrictions on Representation Clauses 


19 




h\ 

V, 

T> 

V, '1 

\ *m\ 

'n\ 

’o’, 

P\ 

'q'. 

f r\ 

'S', '! 

\ V, 

V, 

V, 

x', 

y. 

*z\ 

T, 

r. 


DEL, 


- Extended characters 
LEFT_ARROW, 

RIGHT_ARROW, 

UPPER_ ARROW, 

LOWER_ ARROW, 

UPPER_LEFT_CORNER, 

UPPER~RIGHT_CORNER, 

LOWER_RlGHT_CORNER, 

LOWER J.EFT_CORN ER, 

...); 

for EXTENDED'SIZE use 8; 

- The size of type EXTENDED will be one byte. Its objects will be represented 

- as unsigned 8 bit integers. 

The Alsys Compiler fully implements size specifications. Nevertheless, as enumeration 
values are coded using integers, the specified length cannot be greater than 32 bits. 

Object size: Provided its size is not constrained by a record component clause or a 
pragma PACK, an object of an enumeration subtype has the same size as its subtype. 

Alignment: An enumeration subtype is byte aligned if the size of the subtype is less than 
or equal to 8 bits, word aligned otherwise. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of an enumeration subtype is a 
multiple of the alignment of the corresponding subtype. 


20 


Alsys Ada for the Transputer, Appendix F, i 5 



4.2 Integer Types 

Predefined integer types 


In the Alsys Ada implementation for the transputer the following predefined integer 
types are available: 

type SHORTJNTEGER is range -2**07 .. 2**07-l; 

type INTEGER is range -2**Tl .. 2**31-1; 


Selection of the parent of an integer type 
An integer type declared by a declaration of the form: 
type T is range L .. R; 

is implicitly derived from one of the predefined integer types. The compiler 
automatically selects the predefined integer type whose range is the shortest that 
contains the values L to R inclusive. 


Encoding of integer values 

Binary code is used to represent integer values, using a conventional two’s complement 
representation. 


Integer subtypes 

Minimum size: The minimum size of an integer subtype is the minimum number of bits 
that is necessary for representing the internal codes of the subtype values in normal 
binary form (that is to say, in an unbiased form which includes a sign bit only if the range 
of the subtype includes negative values). 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M are 
the lower and upper bounds of the subtype, then its minimum size L is determined as 
follows. For m > = 0, L is the smallest positive integer such that M < = 2 L -1. For m < 
0, L is the smallest positive integer such that -2 L i < = m and M < = 2 L , -1. 


Restrictions on Representation Clauses 


21 






For example: 

subtype S is INTEGER range 0 .. 7; 

- The minimum size of S is 3 bits. 

subtype D is S range X .. Y; 

— Assuming that X and Y are not static, the minimum size of 

- D is 3 bits (the same as the minimum size of the static type mark S). 

Size: The sizes of the predefined integer types SHORT_INTEGER and INTEGER are 
respectively 8 and 32 bits. 

When no size specification is applied to an integ r type or to its first named subtype (if 
any), its size and the size of any of its subtypes is the size of the predefined type from 
which it derives, directly or indirectly. 

For example: 

type S is range 80 .. 100, 

- S is derived from SHoPTJNTEGER, its size is 8 bits. 

type J is range 0 .. 65535; 

- J is derived from INTEGER, its size is 32 bits. 

type N is new J range 80.. 100; 

— N is indirectly derived from INTEGER, its size is 32 bits. 

When a size specification is applied to an integer type, this integer type and each of its 
subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype tc which it applies. 


22 


Alsys Ada for the Transputer, Appendix F, v5 



For example: 


type S is range 80 .. 100; 
for S’SIZE use 3/; 

- S is derived from SHORT_INTEGER, but its size is 32 bits 

- because of the size specification. 

type J is range 0.. 255; 
for J'SIZE use 8; 

- J is derived from INTEGER, but its size is 8 bits because 

- of the size specification. 

type N is new J range 80 .. 100; 

— N is indirectly derived from INTEGER, but its size is 8 bits 

- because N inherits the size specification of J. 

The Alsys Compiler implements size specifications. Nevertheless, as integers are 
implemented using machine integers, the specified length cannot be greater than 32 bits. 

Object size: Provided its size is not constrained by a record component clause or a 
pragma PACK, an object of an integer subtype has the same size as its subtype. 

Alignment: An integer subtype is byte aligned if the size of the subtype is less than or 
equal to 8 bits, word aligned otherwise. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of an integer subtype is a multiple of 
the alignment of the corresponding subtype. 


Restrictions on Representation Clauses 


23 



4.3 Floating Point Types 

Predefined floating point types 

There are two predefined floating point types in the Alsys implementation for 
transputers: 

type FLOAT is 

digits 6 range -(2.0 - 2.0**(-23))*2.0**127 .. (2.0 - 2.0**(-23))*2.0**127; 


type LONGFLOAT is 

digits 15 range -(2.0 - 2.0**(-5l)) , 2.0**1023 .. (2.0 - 2.0**(-51))*2.0**1023; 


Selection of the parent of a floating point type 
A floating point type declared by a declaration of the form: 
type T is digits D [range L .. R); 

is implicitly derived from a predefined floating point type. The Compiler automatically 
selects the smallest predefined floating point type whose number of digits is greater than 
or equal to D and which contains the values L and R. 


Encoding of floating point values 

In the program generated by the Compiler, floating point values are represented using 
the ANSI/IEEE 754 standard 32-bit and 64-bit floating point formats as appropriate. 

Values of the predefined type FLOAT are represented using the 32-bit floating point 
formal and values of the predefined type LONG_FLOAT are represented using the 64- 
bit floating point format as defined by the standard. The values of any other floating 
point type are represented in the same way as the values of the predefined type from 
which it derives, directly or indirectly. 


24 


Alss's Ada for ihe Transputer, Appendix F ,»5 


Floating point subtypes 


Minimum size: The minimum size of a floating point subtype is 32 bits if its base type is 
FLOAT or a type derived from FLOAT and 64 bits if its base type is LONG_FLOAT or 
a type derived from LONG_FLOAT. 

Size: The sizes of the predefined floating point types FLOAT and LONG_FLOAT are 
respectively 32 and 64 bits. 

The size of a floating point type and the size of any of its subtypes is the size of the 
predefined type from which it derives directly or indirectly. 

The only size that can be specified for a floating point type or first named subtype using a 
size specification is its usual size (32, or 64 bits). 

Object size: An object of a floating point subtype has the same size as its subtype. 
Alignment: A floating point subtype is always word aligned. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of a floating point subtype is a 
multiple of the alignment of the corresponding subtype. 


Restrictions on Representation Clauses 


25 


4.4 Fixed Point T^pes 

Small of a fixed point type 

If no specification of small applies to a fixed point type, then the value of small is 
determined by the value of delta as defined by [3.5.9). 

A specification of small can be used to impose a value of small. The value of small is 
required to be a power of two. 

Predefined fixed point types 

To implement fixed point types, the Alsys Compiler for the transputer uses a set of 
anonymous predefined types. These are: 

type SHORTFIXED is delta D range -2**7*S.. (2**7-l)*S; 
for SHORTFIXED’SMALL use S; 

type FIXED is delta D range -2‘*31*S .. (z**31-l)‘S, 
for FIXED'SMALL use S; 

where D is any real value and S any power of two less than or equal to D. 

Selection of the parent of a fixed point type 
A fixed point type declared by a declaration of the form: 

type T is delta D range L.. R, 
possibly with a small specification: 
for TSMALL use S; 

is implicitly derived from a predefined fixed point type. The Compiler automatically 
selects the predefined fixed point type whose small and delta are the same as the small 
and delta of T and whose range is the shortest that includes the values L and R. 

Encoding of fixed point values 

In the program generated by the Compiler, a safe value V of a fixed point subtype F is 
represented as the integer: 

V / FBASE’SMALL 


26 


Alsys Ada for the Transputer, Appendix F, \'5 


Fixed point subtypes 


Minimum size: The minimum size of a fixed point subtype is the minimum number of 
binary digits that is necessary for representing the values of the range of the subtype 
using the small of the base type (that is to say, in an unbiased form which includes a sign 
bit only if the range of the subtype includes negative values). 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, s and S being 
the bounds of the subtype, if i and I are the integer representations of m and M, the 
smallest and the greatest model numbers of the base type such that s < m and M < S, 
then the minimum size L is determined as follows. For i > = 0, L is the smallest positive 
integer such that I < = 2 L -1. For i < 0, L is the smallest positive integer such that - 
2 L1 < = i and 1 < = 2 L 'M. 

For example: 

type F is delta 2.0 range 0.0.. 500.0; 

- The minimum size of F is 8 bits. 

subtype S is F delta 16.0 range 0.0.. 250.0; 

- The minimum size of S is 7 bits. 

subtype D is S range X .. Y; 

-- Assuming that X and Y are not static, the minimum size of D is 7 bits 

- (the same as the minimum size of its type mark S). 

Size: The sizes of the sets of predefined fixed point types SHORT_FlXED, and FIXED are 
8 and 32 bits respectively. 

When no size specification is applied to a fixed point type or to its first named subtype, 
its size and the size of any of its subtypes is the size of the predefined type from which it 
derives directly or indirectly. 

For example: 

type F is delta 0.01 range 0.0.. 1.0; 

- F is derived from a 8 bit predefined fixed type, its size is 8 bits, 
type L is delta 0.01 range 0.0.. 300 0; 

~ L is derived from a 32 bit predefined fixed type, its size is 32 bits, 
type N is new L range 0.0.. 2.0; 

- N is indirectly derived from a 32 bit predefined fixed type, its size is 32 bits. 


Restrictions on Representation Clauses 


27 


When a size specification is applied to a fixed point type, this fixed point type and each of 
its subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies. 

For example: 

type F is delta 0.01 range 0.0 .. 1.0; 
for PS1ZE use 32; 

~ F is derived from a 8 bit predefined fixed type, but its size is 32 bits 

- because of the size specification. 

type L is delta 0.01 range 0.0.. 300.0; 
for FS1ZE use 16; 

- F is derived from a 32 bit predefined fixed type, but its size is 16 bits 

- because of the size specification. 

- The size specification is legal since the range contains no negative values 

- and therefore no sign bit is required. 

type N is new F range 0.8.. 1.0; 

- N is indirectly derived from a 16 bit predefined fixed type, but its size is 

- 32 bits because N inherits the size specification of F. 

The Alsys Compiler implements size specifications. Nevertheless, as fixed point objects 
are represented using machine integers, the specified length cannot be greater than 32 
bits. 

Object size: Provided its size is not constrained by a record component clause or a 
pragma PACK, an object of a fixed point type has the same size as its subtype. 

Alignment: A fixed point subtype is byte aligned if its size is less than or equal to 8 bits, 
word aligned otherwise. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of a fixed point subtype is a multiple 
of the alignment of the corresponding subtype. 


28 


Alsys Ada for the Transputer, Appendix F, v5 


4.5 Access Types 

Collection Size 

When no specification of collection size applies to an access type, no storage space is 
reserved for its collection, and the value of the attribute STORAGE_SlZE is then 0. 

As described in [13.2], a specification of collection size can be provided in order to 
reserve storage space for the collection of an access type. The Alsys Compiler fully 
implements this kind of specification. 


Encoding of access values 

Access values are machine addresses represented as machine word - sized values (i.e. 32 
bits). 


Access subtypes 

Minimum size: The minimum size of an access subtype is that of the word size of the 
target transputer. 

Size: The size of an access subtype is the same as its minimum size. 

The only size that can be specified for an access type using a size specification is its usual 
size. 

Object size: An object of an access subtype has the same size as its subtype, thus an 
object of an access subtype is always one machine word long. 

Alignment: An access subtype is always word aligned. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of an access subtype is always on a 
word boundary, since its subtype is word aligned. 


Restrictions on Representation Clauses 


29 


4.6 Task 'types 

Storage for a task activation 

When no length clause is used to specify the storage space to be reserved for a task 
activation, the storage space indicated at bind time is used for this activation. 

As described in |13.2], a length clause can be used to specify the storage space for the 
activation of each of the tasks of a given type. In this case the value indicated at bind time 
is ignored for this task type, and the length clause is obeyed. 

Both the length clause and the bind time parameter specify the combined size of the 
task's primary and auxiliary stacks. Further bind time parameters specify the percentage 
of this storage size to be allocated to the primary stack and indicate whether or not to 
attempt to allocate the primary stack in fast internal memory. These bind time 
parameters indicate the default action and can be overridden using the implementation 
defined pragmas STORAGE_SIZE_RATIO and FAST PRIMARY. 

pragma STORAGE_SIZE_RATIO (task name , integer literal ); 

pragma FAST_PRIMARY ( taskjiamc , YES ( NO ); 

These two pragmas are not allowed for derived types. They apply to the task type 
taskname. For each pragma, the pragma and the declaration of the task type to which it 
applies must both occur within the same declarative part or package specification, 
although the declaration of the task type must precede the pragma. 

Pragma STORAGE_SIZE_RATIO specifies the percentage of the total storage size 
reserved for the activation of the task to be used as the task’s primary stack. Any 
remaining storage space will be used as the task's auxiliary stack. In the absence of the 
pragma tho default i«.k> spctif.^d at bind time is useu tor the activation. 

Pragma FAST_PR1MARY specifies whether or not an attempt should be made to 
allocate the task’s primary stack in fast internal memory. In the absence of the pragma 
the default indication specified at bind time is used for the activation. 


30 


Alsys Ada for the Transputer, Appendix F, v5 


Encoding of task values 

Task values are represented as machine word sized values. 


Task subtypes 

Minimum size: The minimum size of a task subtype is 32 bits. 

Size: The size of a task subtype is the same as its minimum size. 

The only size that can be specified for a task type using a size specification is its usual 
size. 

Object size: An object of a task subtype has the same size as its subtype. Thus an object 
of a task subtype is always 32 bits long. 

Alignment: A task subtype is always word aligned. 

Object address: Provided its alignment is not constrained by a record representation 
clause, the address of an object of a task subtype is always on a word boundary, since its 
subtype is word aligned. 


{ 

! 

I 

r 

! 


Restrictions on Representation Clauses 


31 




4.7 Array Types 

Layout of an array 

Each array is allocated in a contiguous area of storage units. All the components have 
the same size. A gap may exist between two consecutive components (and after the last 
one). All the gaps have the same size. 


Component Gap Component Gap Component Gap 


Components 

If the array is not packed, the size of the components is the size of the subtype of the 
components. 

For example: 

type A is array (1 ..8) of BOOLEAN; 

- The size of the components of A is the size of the type BOOLEAN: 8 bits. 

type DECIMAL_DIGIT is range 0.. 9; 
for DECIMAL DIGITSIZE use 4; 
type BINARY_CODED_DEClMAL is 

array (INTEGER range < >) of DECIMAL_D1GIT; 

- The size of the type DECIMAL_D1GJT is 8 bits. Thus in an array of 

- type BINARY_CODED_DECIMAL each component will be represented in 

- 4 bits as in the usual BCD representation. 

If the array is packed and its components are neither records nor arrays, the size of the 
components is the minimum size of the subtype of the components. 


32 


Alsys Ada for the Transputer, Appendix F, v5 



For example: 


type A is array (1 .. S) of BOOLEAN; 
pragma PACK(A); 

- The size of the components of A is the minimum size of the type BOOLEAN: 

--1 bit. 

type DEC1MAL_DIGIT is range 0.. 9; 
type BINARY_CODED_DECIMAL is 

array (INTEGER range < >) of DECIMALJD1GIT; 
pragma PACK(BINARY_CODED_DECIMAL); 

-- The size of the type DECIMAL_DIGIT is 8 bits, but, as 

- BINARY_CODED_DECIMAL is packed, each component of an array of this 

- type will be represented in 4 bits as in the usual BCD representation. 

Packing the array has no effect on the size of the components when the components are 
records or arrays. 


Gaps 

If the components are records or arrays, no size specification applies to the subtype of 
the components and the array is not packed, then the Compiler may choose a 
representation with a gap after each component; the aim of the insertion of such gaps is 
to optimize access to the array components and to their subcomponents. The size of the 
gap is chosen so that the relative displacement of consecutive components is a multiple 
of the alignment of the subtype of the components. This strategy allows each component 
and subcomponent to have an address consistent with the alignment of its subtype 

For example: 

type R is 
record 

K: INTEGER; - INTEGER is word aligned. 

B : BOOLEAN; - BOOLEAN is byte aligned. 

end record; 

- Record type R is word aligned. Its size is 40 bits, 
type A Is array (1.. 10) of R; 

- A gap of three bytes is inserted after each component in order to respect the 

- alignment of type R. The size of an array of type A will be 640 bits. 


Restrictions on Representation Clauses 


33 


Component 


Gap Component 


Gap Component 


Gap 


Array of type A: each subcomponent K has a word offset. 


If a size specification applies to the subtype of the components or if the array is packed, 
no gaps are inserted. 

For example: 

type R is 
record 

K : INTEGER; 

B : BOOLEAN; 

end record; 

type A is array (1.. 10) of R; 
pragma PACKfA); 

- There is no gap in an array of type A because A is packed. 

- The size of an object of type A will be 400 bits. 

type NR is new R; 
for NR’SIZE use 40; 

type B is array (1.. 10) of NR; 

-- There is no gap in an array of type B because NR has a size specification. 

- The size of an object of type B will be 400 bits. 



Component Component Component 

Array of type A or B: a subcomponent K can have any byte offset. 


34 


Alsys Ada for the Transputer. Appendix F, v5 








Array subtypes 


Size: The size of an array subtype is obtained bv multiplying the number of its 
components by the sum of the size of the components and the size of the gaps (if any). If 
the subtype is unconstrained, the maximum number <~f components is cons; ,»d. 

The size of an array subtype cannot be computed at compile time 

■ if it •'as non-static constraints or is an unconstrained array type with non-static 
index subtypes (because the "'umber of components can then only be determined at 
run time). 

■ if the components are records or arrays and their constraints or the constraints of 
their subcomponents (if any) are not static (because the size of the components and 
the size of the gaps can then only be determined at run time) 

As has been indicated above, the effect of a pragma PACK on an array type is to suppress 
the gaps and to reduce the size of the components. The consequence of packing an array 
type is thus to reduce its size. 

If the components of an array are records or arrays and their constraints or the 
constraints of their subcomponents (if any) are not static, the Compiler ignore* 
pragma PACK applied to the array type but issues a warning message. Apart from this 
limitation, array packing is fully implemented by the Alsys Compiler. 

The only size that can be specified for an array type or first named subtype using a size 
specification is its usual size. Nevertheless, such a length clause can be useful to verify 
that the layout of an array is as expected by the application. 

Object size: 1 he size of an object of an array subtype is always equal to the size of the 
subtype of the object. 

Alignment: If no pragma PACK applies to an array subtype and no size specification 
applies to its components, the array subtype has the same alignment as the subtype of its 
component. 

If a pragma PACK applies to an array subtype or if a size specification applies to its 
components (so that there are no gaps), the alignment of the array subtype the lesser 
of the alignment of the subtype of its components and the relative displacement of th>. 
components. 


Restrictions on Representation Clauses 


35 




Object address: Provided its alignment is noi constrained by a record representation 
clause, the address of an object of an array subtype is a multiple of the alignment of the 
corresponding subtype. 


4.8 Record Types 

Layout of a record 

Each record is alloca.cd in a contiguous area of storage units. The size of a record 
component depends on its type. Gaps may exist between some components. 

The positions and the sizes of the components of a record type object can be controlled 
using a record representation clause as described in [13.4J. In the Alsys implementation 
for transputer targets there is no restriction on the position that can be specified for a 
component of a .ecord. If a component is not a record or an array, its size can be any size 
from the minimum size to the size of its subtype. If a component is a record or an array, 
its size must be the size of its subtype. 

In a record representation clause, the first storage unit (that is, a byte) and the first bit 
position within a storage unit are numbered zero. Bits are ordered, and thus numbered, 
least significant bit first within a storage unit. Storage units are numbered such that 
lower numbers have the least significance in a machine word. 

A compo ’nt clause may be specified such th?. the component overlaps a storage unit 
boundaiy. In this case, the bits are numbered in sequence from the least significant bit of 
the first storage unit tu the most significant bit of the last storage unit occupied by the 
component. For example: 

type BIT 3 is range 0 .. 7; 
for BITJ’SIZE use 3; 

type BIT 5 is range 0 .. 31; 
for BIT_5’SIZE use 5; 

type B1T_8 is range 0 .. 255; 
for BITS'SIZE use 8; 


36 


Alsys Ada for the Transputer, Appendix F, v5 




type R is 
record 

FIRST: BIT_3; 

SECOND : BIT 8; 

THIRD : BIT_57 
end record; 
for R use 
record 

FIRST at 0 range 0 .. 2; 

SECOND at 0 range 3.. 10; 

— Component SECOND overlaps a storage unit boundary. 

THIRD at 1 range 3 .. 7; 
end record; 
for R’SIZE use 16; 


Most Significant 
Bit (MSB) 


1 0 Storage unit number 


least Significant 
Bit (LSB) 


7 3207 320 Bit number within 

storage unit 



Reservation of a Record of type R 


A record representation clause need not specify the position and the size for every 
component. 

If no component clause applies to a component ol a record, its size is the size of its 
subtype. Its position is chosen by the Compiler so as to optimize access to the 
components of the record: the offset of the component is chosen as a multiple of the 
alignment of the component subtype. Moreover, the Compiler chooses the position of 
the component so as to reduce the number of gaps and thus the size of the record 
objects. 

Because of these optimisations, there is no connection between the order of the 
components in a record type declaration and the positions chosen by the Compiler for 
the components in a record object. 


Restrictions on Representation Clauses 


37 




Pragma PACK has no furt ler effect on records. The Alsys Compiler always optimizes the 
layout of records as described above. 


Indirect components 

If the offset of a component cannot be computed at compile time, this offset is stored in 
the record objects at run time and used to access the component. Such a component is 
said to be indirect while other components are said to be direct: 



Beginning of the record 
Conpi le time offset 


Compile time offset 


Run time offset 


A direct and an indirect component 


If a record component is a record or an array, the size of its subtype may be evaluated at 
run time and may even depend on the discriminants of the record. We will call these 
components dynamic components. 


38 


Alsys Ada for the Transputer, Appendix F, v5 







For example: 

type DEVICE is (SCREEN, PRINTER); 
type COLOR is (GREEN, RED, BLUE); 
type SERIES is array (POSITIVE range < >) of INTEGER; 

type GRAPH (L : NATURAL) is 

record 

X : SER1ES(1.. L); - The size of X depends on L 
Y : SERIES(1.. L); -- The size of Y depends on L 

end record; 

Q: POSITIVE; 

type PICTURE (N : NATURAL; D : DEVICE) is 

record 

F: GRAPH(N); - The size of F depends on N 
S : GRAPH(Q); -- The size of S depends on Q 
case D is 

when SCREEN = > 

C: COLOR; 
when PRINTER = > 

null; 

end case; 
end record; 

Any component placed after a dynamic component has an offset which cannot be 
evaluated at compile lime and is thus indirect. In order to minimize the number of 
indirect components, the Compiler groups the dynamic components together and places 
them at the end of the record: 


Restrictions on Representation Clauses 


39 


D = SCREEN 
N = 2 


0 = PRINTER 
N = 1 


S OFFSET 


F OFFSET 


Beginning of the record 
- Compile time offsets — 


Run time offsets 


-[ 


S OFFSET 


F OFFSET 


The record type PICTURE: F and S are placed at the end of the record 


Thanks to this strategy, the only indirect components are dynamic components. But not 
all dynamic components are necessarily indirect: if there are dynamic components in a 
component list which is not followed by a variant part, then exactly one dynamic 
component of this list is a direct component because its offset can be computed at 
compilation time 


40 


Alsys Ada for the Transputer, Appendix F, \ 5 


For example: 


— 

- Y OFFSET 

1 

L 




X 


Y 


Beginnir>g of the record 
Ccmpile time offset 


— —. . Compile time offset 

Size dependent on discriminant L 
— 1 — Run time offset 

Size dependent on discriminant l 


The record type GRAPH: the dynamic component X is a direct component. 


The offset of an indirect component is always expressed in storage units. 

The space reserved for the offset of an indirect component must be large enough to store 
the size of any value of the record type (the maximum potential offset). The Compiler 
evaluates an upper bound MS of this size and treats an offset as a component having an 
anonymous integer type whose range is 0.. MS. 

If C is the name of an indirect component, then the offset of this component can be 
denoted in a component clause by the implementation generated name C'OFFSET. 


Implicit components 

In some circumstances, access to an object of a record type or to its components involves 
computing information which only depends on the discriminant values. To avoid 
unnecessary recomputation, the Compiler stores this information in the record objects, 
updates it when the values of the discriminants are modified and uses it when the objects 
or their components are accessed. This information is stored in special components 
called implicit components. 


Restrictions on Representation Clauses 


41 


An implicit component may contain information which is used when the record object or 
several of its components are accessed. In this case the component will be included in any 
record object (the implicit component is considered to be declared before any variant 
part in the record type declaration). There can be two components of this kind; one is 
called RECORD_SIZE and the other VaRIANTJNDEX. 

On the other hand an implicit component may be used to access a given record 
component. In this case the implicit component exists whenever the record component 
exists (the implicit component is considered to be declared at the same place as the 
record component). Components of this kind are called ARRAY_DESCRlPTORs or 
RECORD JDESCRIPTORs. 

RECORDS1ZE 

This implicit component is created by the Compiler when the record type has a variant 
part and its discriminants are defaulted. It contains the size of the storage space 
necessary to store the current value of the record object (note that the storage effectively 
allocated for the record object may be more than this). 

The value of a RECORD_SlZE component may denote a number of bits or a number of 
storage units. In general it denotes a number of storage units, but if any component 
clause specifies that a component of the record type has an offset or a size which cannot 
be expressed using storage units, then the value designates a number of bits. 

The implicit component RECORD_SIZE must be large enough to store the maximum 
size of any value of the record type. The Compiler evaluates an upper bound MS of this 
size and then considers the implicit component as having an anonymous integer type 
whose range is 0.. MS. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R'RECORD_SlZE. 

VARIANTJNDEX 

This implicit component is created by the Compiler when the record type has a variant 
part. It indicates the set of components that are present in a record value. It is used when 
a discriminant check is to be done. 

Component lists that do not contain a variant part are numbered. These numbers are the 
possible values of the implicit component VARIANTJNDEX. 


42 


Alsys Ada for the Transputer, Appendix F, v5 


For example: 

type VEHICLE is (AIRCRAFT, ROCKET, BOAT. CAR); 

type DESCRIPTION (KIND : VEHICLE := CAR) is 
record 

SPEED: INTEGER; 
case KIND is 

when AIRCRAFT | CAR = > 

WHEELS: INTEGER; 
case KIND is 

when AIRCRAFT = > — 1 

WINGSPAN : INTEGER; 
when others = > — 2 

null; 
end case; 

when BOAT = > — 3 

STEAM ; BOOLEAN; 
when ROCKET = > -4 

STAGES: INTEGER; 
end case; 
end record; 

The value of the variant index indicates the set of components that are present in a 
record value: 


Variant Index 

Set 

1 

(KINO, SPEED, WHEELS, WINGSPAN) 

2 

(KINO, SPEED, WHEELS) 

3 

(KIND, SPEED, STEAM) 

4 

(KIND, SPEED, STAGES) 


A comparison between the variant index of a record value and the bounds of an interval 
is enough to check that a given component is present in the value: 


Restrictions on Representation Clauses 


43 



Component 

Interval 

KIND 

-- 

SPEED 

-- 

WHEELS 

1 .. 2 

WINGSPAN 

1 .. 1 

STEAM 


STAGES 



The implicit component VaRIaNT_INDEX must be large enough to store the number V 
of component lists that don’t contain variant parts. The Compiler treats this implicit 
component as having an anonymous integer type whose range is 1 .. V. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R’Variantindex. 

ARRA Y DESCRIPTOR 

An implicit component of this kind is associated by the Compiler with each record 
component whose subtype is an anonymous array subtype that depends on a discriminant 
of the record. It contains information about the component subtype. 

The structure of an implicit component of kind ARRAYDESCRIPTOR is not described 
in this documentation. Nevertheless, if a programmer is interested in specifying the 
location of a component of this kind using a component clause, he can obtain the size of 
the component using the ASSEMBLY parameter in the COMPILE command. 

The Compiler treats an implicit component of the kind ARRAYDESCRIPTOR as having 
an anonymous record type. If C is the name of the record component whose subtype is 
described by the array descriptor, then this implicit component can be denoted in a 
component clause by the implementation generated name C'ARRAY_DESCRIPTOR. 

RECORD DESCRIPTOR 

An implicit component of this kind is associated by the Compiler with each record 
component whose subtype is an anonymous record subtype that depends on a 
discriminant of the record. It contains information about the component subtype. 

The structure of an implicit component of kind RECORD_DESCRIPTOR is not described 
in this documentation. Nevertheless, if a programmer is interested in specifying the 
location of a component of this kind using a component clause, he can obtain the size of 
the component using the ASSEMBLY parameter in the COMPILE command. 


44 


Alsys Ada for the Transputer, Appendix F, " t > 





The Compiler treats an implicit component of the kind RECORD_DESCRIPTOR as 
having an anonymous record type. If C is the name of the record component whose 
subtype is described by the record descriptor, then this implicit component can be 
denoted in a component clause by the implementation generated name 
C’RECORD DESCRIPTOR. 


Suppression of implicit components 

The Alsys implementation provides the capability of suppressing the implicit 
components RECORD_SIZE and/or VaRIANT_INDEX from a record type. This can be 
done using an implementation defined pragma called IMPROVE. The syntax of this 
pragma is as follows: 

pragma IMPROVE (TIME | SPACE, (ON = >] simplejiame ); 

The first argument specifies whether TIME or SPACE is the primary criterion for the 
choice of the representation of the record type that is denoted by the second argument. 

If TIME is specified, the Compiler inserts implicit components as described above. If on 
the other hand SPACE is specified, the Compiler only inserts a VARLANTJNDEX or a 
RECORD S1ZE component if this component appears in a record representation clause 
that applies to the record type. A record representation clause can thus be used to keep 
one implicit component while suppressing the other. 

A pragma IMPROVE that applies to a given record type can occur anywhere that a 
representation clause is allowed for this type. 


Record subtypes 

Size: Unless a component clause specifies that a component of a record type has an 
offset or a size which cannot be expressed using storage units, the size of a record subtype 
is rounded up to a whole number of storage units. 

The size of a constrained record subtype is obtained by adding the sizes of its 
components and the sizes of its gaps (if any). This size is not computed at compile time 

■ when the record subtype has non-static constraints, 

■ when a component is an array or a record and its size is not computed at compile 
time. 


Restrictions on Representation Clauses 


45 


The size of an unconstrained record subtyp e is obtained by adding the sizes of the 
components and the sizes of the gaps (if any) of its largest variant. If the size of a 
component or of a gap cannot be evaluated exactly at compile time, an upper bound of 
this size is used by the Compiler to compute the subtype size. 

The only size that can be specified for a record type or first named subtype using a size 
specification is its usual size. Nevertheless, such a length clause can be useful to verify 
that the layout of a record is as expected by the application. 

Object size: An object of a constrained record subtype has the same size as its subtype. 

An object of an unconstrained record subtype has the same size as its subtype if this size 
is less than or equal to 4 Kbyte. If the size of the subtype is greater than this, the object 
has the size necessary to store its current value; storage space is allocated and released as 
the discriminants of the record change. 

Alignment: When no record representation clause applies to its base type, a record 
subtype has the same alignment as the component with the highest alignment 
requirement. 

When a record representation clause that does not contain an alignment clause applies 
to its base type, a record subtype has the same alignment as the component with the 
highest alignment requirement which has not been overridden by its component clause. 

When a record representation clause that contains an alignment clause applies to its base 
type, a record subtype has an alignment that obeys the alignment clause. 

Object address: Provided its alignment is not constrained by a representation clause, the 
address of an object of a record subtype is a multiple of the alignment of the 
corresponding subtype. 


46 


Alsys Ada for the Transputer, Appendix F, v5 


CHAPTER 5 


Conventions for Implementation-Generated Names 


Special record components are introduced by the Compiler for certain record type 
definitions. Such record components are implementation-dependent; they are used by 
the Compiler to improve the quality of the generated code for certain operations on the 
record types. The existence of these components is established by the Compiler 
depending on implementation-dependent criteria. Attributes are defined for referring to 
them in record representation clauses. An error message is issued by the Compiler if the 
user refers to an implementation-dependent component that does not exist. If the 
implementation-dependent component exists, the Compiler checks that the storage 
location specified in the component clause is compatible with the treatment of this 
component and the storage locations of other components. An error message is issued if 
this check fails. 

There are four such attributes: 

TRECORD_SIZE For a prefix T that denotes a record type. This attribute 

refers to the record component introduced by the Compiler 
in a record to store the size of the record object. This 
component exists for objects of a record type with 
defaulted discriminants when the sizes of the record objects 
depend on the values of the discriminants. 

TVAR1ANTJNDEX For a prefix T that denotes a record type. This attribute 

refers to the record component introduced by the Compiler 
in a record to assist in the efficient implementation of 
discriminant checks. This component exists for objects of a 
record type with variant type. 

C’ARRAY DESCRIPTOR For a prefix C that denotes a record component of an array 

type whose component subtype definition depends on 
discriminants. This attribute refers to the record 
component introduced by the Compiler in a record to store 
information on subtypes of components that depend on 
discriminants. 


Conventions for Implementation Generated Names 


47 


C’RECORD_DESCRIPTOR For a prefix C that denoies a record component of a record 

type whose component subtype definition depends on 
discriminants. This attribute refers to the record 
component introduced by the Compiler in a record to store 
information on subtypes of components that depend on 
discriminants. 


48 


Alsys Ada for the Transputer, Appendix F, > 5 


CHAPTER 6 


Address Clauses 

6.1 Address Clauses for Objects 

An address clause can be used 10 specify an address for an object as described in {13.5]. 
When such a clause applies to an object no storage is allocated for it in the program 
generated by the Compiler. The program accesses the object using the address specified 
in the clause. 

An address clause is not allowed for task objects, nor tor unconstrained records whose 
maximum possible size is greater than 4 Kbytes. 


6.2 Address Clauses for Program Units 

Address clauses for program units are not implemented. 


6.3 Address Clauses for Entries 

Address clauses for entries are not implemented. 


Address Clauses 


49 


Alsys Ada for the Transputer, Appendix F, v5 







CHAPTER 7 


Restrictions on Unchecked Conversions 


Unconstrained arrays are not allowed as target types. 

Unconstrained record types without defaulted discriminants are not allowed as target 
types. 

If the source and the target types are each scalar or access types, the sizes of the objects 
of the source and target types must be equal If a composite type is used either as the 
source type or as the target type this restriction on the size does not apply. 

If the source and the target types are each of scalar or access type or if they are both of 
composite type, the effect of the function is to return the operand 

In other cases the effect of unchecked conversion can be considered as a copy: 

■ if an unchecked conversion is achieved of a scalar or access source type to a 
composite target type, the result of the function is a copy of the source operand: the 
result has the size of the source. 

■ if an unchecked conversion is achieved of a composite source type to a scalar or 
access target type, the result of the function is a copy of the source operand: the 
result has the size of the target 


Restrictions on Unchecked Conversions 


51 




CHAPTER 8 


Input-Output Packages 


The predefined input-output packages SEQUENT1AL_10 [14.2.3), DIRECT_10 [14.2.5], 
TEXTJO [14.3.10] and I0_EXCEPT10NS [14.5] are implemented as described in the 
Language Reference Manual. 

It should be noted that, in order to generate output, calls to PUT procedures should be 
followed by a call to either PUT L1NE or NEW LINE. 

The package LOWLEVELJO [14.6], which is concerned with low-level machine- 
dependent input-output, is not implemented. 

All access to the services of the host system are provided through the INMOS supplied 
iservcr tool [Ref.3], so much of Ada input - output is host independent. 


8.1 NAME Parameter 

No special treatment is applied to the NAME parameter supplied to the Ada procedures 
CREATE or OPEN [14.2.1]. This parameter is passed immediately on to the INMOS 
server and from there to the host operating system. The file name can thus be in any 
format acceptable to the host system. 


8.2 FORM Parameter 

The FORM parameter comprises a set of attributes formulated according to the lexical 
rules of [2], separated by commas. The FORM parameter may be given as a null string 
except when D1RECTJO is instantiated with an unconstrained type; in this case the 
record size attribute must be provided. Attributes are comma-separated; blanks may be 
inserted between lexical elements as desired. In the descriptions below the meanings of 
natural,positive, etc., are as in Ada; attribute keywords (represented in upper case) are 
identifiers [2.3] and as such may be specified without regard to case. 

USE ERROR is raised if the FORM parameter does not conform to these rules. 


Input-Output Packages 


53 



The attributes are as follows: 

8.2.1 File Sharing 

This attribute allows control over the sharing of one external file between several 
internal files within a single program. In effect it establishes rules for subsequent OPEN 
and CREATE calls which specify the same external file. If such rules are violated or if a 
different file sharing attribute is specified in a later OPEN or CREATE call, 

USE ERROR will be raised. The syntax is as follows: 

NOT_SHARED | 

SHARED = > access mode 


where 

access_mode :: = READERS j S1NGLE_ WRITER | ANY: 

A file sharing attribute of: 

NOT SHARED implies only one internal file may access the 

external file. 

SHARED = > READERS imposes no restrictions on internal files of 

mode IN FILE, but prevents any internal files 
of mode OUT_FILE or INOUTF1LE being 
associated with the external file. 

SHARED = > SINGLE_WR!TER is as SHARED = > READERS, but in 

addition allows a single internal file of mode 
OUT FILE or !NOUT_FlLE. 

SHARED = > ANY places no restriction on external file string. 

If a file of the same name has previously been opened or created, the default is taken 

from that file's sharing attribute, otherwise the default depends on the mode of the file: 

for mode IN FILE the default is SHARED = > READERS, for modes lNOUT_FILE 

and OUTjFLE the default is NOT_SHARED. 


54 


Alsys Ado for the Transputer, Appendix F, v5 


8.2.2 Binary Files 


Two FORM attributes, RECORD_SIZE and RECORD_UNIT, control the structure of 
binary files. 

A binary file can be viewed as a sequence (sequential access) or a set (direct access) of 
consecutive RECORDS. 

The structure of such a record is: 

[ HEADER ) OBJECT ( UNUSED_PART ) 

and it is formed from up to three items: 

■ an OBJECT with the exact binary representation of the Ada object in the executable 
program, possibly including an object descriptor 

■ a HEADER consisting of two word sized fields: 

- the length of the object in bytes 

- the length of the descriptor in bytes 

■ an UNUSED_PART of variable size to permit full control of the record’s size 

The HEADER is implemented only if the actual parameter of the instantiation of the lO 
package is unconstrained. 

The file structure attributes take the form: 

RECORD_SlZE = > size_in_bytes 
RECORDUNIT = > size_in_bytes 

Their meaning depends on the object’s type (constrained or not) and the file access mode 
(sequential or direct access): 

a) If the object’s type is constrained: 

- The RECORDJJNIT attribute is illegal 

- If the RECORD_SlZE attribute is omitted, no UNUSED PART will be 
implemented: the default RECORD^SIZE is the object’s size 


Input-Output Packages 


55 




- " present, the RECORD_SIZE attribute must specify a record size greater than 
o: equal to the object’s size, otherwise the exception USE_ERROR will be 
raised 

b) If the object's type is unconstrained and the file access mode is direct: 

- The RECORD_UNIT attribute is illegal 

- The RECORD_SIZE attribute has no default value, and if it is not specified, a 
USEJERROR will be raised 

- An attempt to input or output an object larger than the given RFCORD_SIZE 
will raise the exception DATA_ERROR 

c) If the object’s type is unconstrained and the file access mode is sequential: 

- The RECORD_SIZE attribute is illegal 

• The default value of the RECORD_UNIT attribute is 1 (byte) 

- The record size will be the smallest multiple of the specified (or default) 
RECORDJJNIT that holds the object and its header. This is the only case 
where records of a file may have different sizes. 

In all cases the value given must not be smaller than a minimum size. For constrained 
types, this minimum size is ELEMENT_TYPE’SIZE / SYSTEM.STORAGE_UNIT; 
USE_ERROR will be raised if this rule is violated. For unconstrained types, the 
minimum size is ELEMENT_TYPE’DESCRIPTOR_SIZE / 

SYSTEM.STORAGE_UNIT plus the size of the largest record which is to be read or 
written. If a larger record is processed, DATA_ERROR will be raised by the READ or 
WRITE. 


8.2.3 Buffering 

This attribute con'rols the size of 'he buffer used as a cache for input-output operations: 
BUFFER_SIZE = > size_in_bytes 

The default value for BUFFER_SIZE is 0, which means no buffering. 


56 


Alsys Ada for the Transputer, Appendix F, > 5 


8.2.4 Appending 

"This attribute may only be used in the FORM parameter of the OPEN command. If 
used in the FORM parameter of the CREATE command, USE_ERROR will be raised. 

The affect of this attribute is to cause writing to commence at the end of the existing file. 

The syntax of the APPEND attribute is simply: 

APPEND 

The default is APPEND = > FALSE, but this is overridden if this attribute is specified. 

In normal circumstances, when an external file is opened, an index is set which points to 
the beginning of the file. If the APPEND attribute is present for a sequential or for a text 
file, then data transfer will commence at the end of the file. For a direct access file, the 
value of the index is set to one more than the number of records in the external file. 

This attribute is not applicable to terminal devices. 


8.3 USE_ERROR 

The following conditions will cause USE_ERROR to be raised: 

■ Specifying a FORM parameter whose syntax does not conform to the rules given 
above. 

• Specifying the RECORD_SIZE FORM parameter attribute to have a value of zero, or 
failing to specify RECORD_SlZE for instantiations of D1RECTJO for unconstrained 
types. 

■ Specifying a RECORD_SIZE FORM parameter attribute to have a value less than 
that required to hold the element for instantiations of DIRECTJO and 
SEQUENTIAL JO for constrained types. 

■ Violating the file sharing rules stated above. 

■ Attempting to perform an input - output operation which is not supported by the 
INMOS iserver due to restrictions of the host operating system. 

. Errors detected whilst reading or writing (e g. writing to a file on a read-only disk). 


Input-Output Packages 


5 


Alsys Ada for the Transputer, Appendix F, v 5 


58 








CHAPTER 9 


Characteristics of Numeric Types 
9.1 Integer Types 

The ranges of values for integer types declared in package STANDARD are as follows: 
SHORTJNTEGER -128.. 127 - 2**7 - 1 

INTEGER -2147483648 .. 2147483647 - 2**31 - 1 

Other Integer Types 

For the packages DIRECT IO and TEXT lO, the ranges of values for types COUNT 
and POSlTIVE_COUNT are as follows. 

COUNT 0.. 2147483647 - 2**31 - 1 

POSJTlVE_COUNT 1 .. 2147483647 - 2**31 - 1 

For the package TEXT_IO, the range of values for the type FIELD is as follows: 
FIELD 0.. 255 -2**8-1 


Characteristics of Numeric Types 


59 






9.2 Floating Point T^pe Attributes 


FLOAT 


DIGITS 

MANTISSA 

EMAX 

EPSILON 

SMALL 

LARGE 

SAFE_EMAX 

safe small 
safejlarge 
FIRST 
LAST 

MACHINE_RADIX 

MACHINEMANT1SSA 

MACHINEEMaX 

MACHINEEMIN 

MACHINEROUNDS 

MACHINE_OVERFLOWS 

SIZE 


6 

21 

84 

2.0 ** -20 
2.0 ** -85 

2.0 ** 84 * (1.0 - 2.0 ** -21) 
125 

2.0 ** -126 

2.0 ** 125 * (1.0 - 2.0 ** -21) 
-2.0 ** 127 ♦ (2.0 - 2.0 ** -23) 
2.0 ** 127 * (2.0 - 2.0 ** -23) 

2 

24 

128 

-125 

TRUE 

TRUE 

32 


Approximate 

value 


9.54E-7 
2.58E-26 
1 93E+25 

1.18E-38 

4.25E+37 

-3.40E+38 

3.40E+38 


60 


Alsys Ada for the Transputer, Appendix F, i 5 


LONG FLOAT 


Approximate 


DIGITS 

15 


value 

MANTISSA 

51 



EMAX 

204 



EPSILON 

SMALL 

LARGE 

SAFE EMAX 

2.0 “ -50 

2.0 “ -205 

2.0 “ 204 * (1.0- 2.0 •• - 
1021 

51) 

8.88E-16 

1.94E-62 

2.57E+61 

SAFE_SMALL 

SAFE LARGE 

FIRST 

LAST 

machine_radix 

2.0 *• -1022 

2.0** 1021 * (1.0-2.0*» 

-51) 

2.22E-308 

2.25E+307 

-2.0“ 1023 *(2.0 - 2.0“-51) 

-1.79E+30S 

2.0“ 1023 * (2.0 - 2 0 “ 
2 

-51) 

1.79E + 308 

MACHINE MANTISSA 

53 



machine“emax 

1024 



MACHINEEMIN 

-1021 



MACHINE ROUNDS 

TRUE 



MACHINE _ OVERFLOWS 

TRUE 



SIZE 

64 




9.3 Attributes of T>pe DURATION 


DURATION’DELTA 2.0** -14 

DURATION’SMALL 2.0 ** -14 

DURATION'LARGE 131072.0 

DURATION-FIRST -86400.0 

DURATION'LAST 86400.0 


Characteristics of Numeric Types 


61 






Alsys Ada for the Transputer, Appendix F, v5 





REFERENCES 


[1] Reference Manual for the Ada Programming Language 
(ANS1/M1L-STD-1815A-1983). 

[2] Occam2 Reference Manual. 

INMOS Limited 
Prentice Hall, 1988. 

[3] Occam2 Toolset User Manual. 

INMOS Limited, 1989. 

INMOS document number 72 TDS 184 00. 

[4] Transputer Instruction Set - A Compiler Writer’s Guide 
INMOS Limited 

Prentice Hall, 1988 


References 


63 




INDEX 


ADDRESS attribute 11 
restrictions 11 
Append attribute 57 
ARRAY_DESCRIPTOR attribute 47 
ASCII 6, 7 
Attributes 11 

ARRAY DESCRIPTOR 47 
DESCR1PTORSIZE 11 
ISARRAY 11~ 

RECORD DESCRIPTOR 48 
RECORD S IZE 47,53 
representation attributes 11 
VARIANTJNDEX 47 

BOOLEAN 6 

CHARACTER 6 
COUNT 59 

DESCRIPTORSIZE attribute 11 56 
DIRECTJO 53,59 
DURATION 
attributes 61 

Enumeration types 5 
BOOLEAN 6 
CHARACTER 6 

FAST PRIMARY 10,30 
FIELD 59 

File sharing attribute 54 
Fixed point types 6 
DURATION 61 
FLOAT 6,60 
Floating point types 6 
FLOAT 6,60 
LONG FLOAT 6,61 


FORM parameter 53 
FORM parameter attributes 
append 57 

file sharing attribute 54 
record_size attribute 57 

Implementation-dependent attributes 
11 

Implementation-dependent pragma 3 
Implementation-generated names 47 
IMPROVE 10 
INDENT 10 
INLINE 3 

Input-Output packages 53 
DIRECT IO 53 
IOEXCEPTIONS 53 
LOW LEVELIO 53 
SEQUENTIAL IO 53 
TEXTJO 53 
INTEGER 5,59 
Integer types 5,59 
COUNT 59 
FIELD 59 
INTEGER 5,59 
POSITIVE COUNT 59 
SHORT INTEGER 5, 59 
INTERFACE 3 
INTERFACE_NAME 3,9 
Interfaced subprograms 
Restrictions 8 
IO EXCEPTIONS 53 
IS_ARRAY attribute 11 

Language name 3 
LONG FlOAT 6,61 
LOW LEVEL IO 53 


Index 


65 



NOT_SHARED 54 
Numeric types 
integer types 59 

Occam 4 

PACK 10 

Parameter representations 5 
Access types 7 
Array types 7 
Enumeration types 5 
Fixed point types 6 
Floating point types 6 
Integer types 5 
Record types 7 

Parameter-passing conventions 4 
POSITIVE COUNT 59 
Pragma INLINE 3 
Pragma INTERFACE 3 
language name 3 
Occam 4 

subprogram name 3 
Pragma INTERFACE_NAME 3 
stringjiteral 9 
subprogram_name 9 
Pragmas 

FAST PRIMARY 10 30 
IMPROVE 10 
INDENT 10 
INTERFACE 3 
INTERFACE NAME 9 
PACK 10 " 

PRIORITY 10 

storage_size ratio 10 30 

SUPPRESS 10 " 

PRIORITY 10 


characteristics 59 
Fixed point types 61 

RECORD DESCRIPTOR attribute 
48 

RECORD SIZE attribute 47,53,57 

Representation attributes 11 
Representation clauses 17 
restrictions 17 

SEQUENTIAL IO 53 
SHARED 54 
SHORTJNTEGER 5 59 

s™n A 0 G 7- S,ZE - RA ’ T, ° 10 - 30 
String literal 9 
Subprogram name 3,9 
SUPPRESS 10 
SYSTEM package 1 ? 

TEXT_IO 53,59 

Unchecked conversions 51 
restrictions 51 
USE_ERROR 53,57 

VARIANTJNDEX attribute 47 


66 


A,S) 'S Ada for the Transputer, Appendix F, v5 




