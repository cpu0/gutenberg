AD-A226 898 


MTATION PAGE 


Fommpptwwa 
OPMNo.07044188 


O— 


i mr WW&TTWBOft OpnOBW M 

9u<3«.*M >4 l01 DC 30803. 


1. AGENCY USE ONLY (1«M Man*/ 


-3RTQATE 


3l REPORT TYPE AND DATES OOVEHED 

Final 18 Dec. 1989 to 18 Dec. 1990 


4. TITLE AND SUBTITLE Ada Compiler Validation Summary Report: Proprie¬ 
tary Software Systems, Inc., PSS VAX.1750A Ada Compiler, VAX 
8350 (Host) to MIL-STD-1750A/PSS AdaRAID (Target), 
89121811.10259 


«. AUTHORS) 

IABG-AVF 

Ottobrunn, FEDERAL REPUBLIC OF GERMANY 


7. PERFORMING ORGANIZATION NAkE(S) AND AD0HE5S<ES) 

IABG-AVF, Industrieanlagen-Betriebsgeselschaft 

Dept. SZT 
Einsteinstrasse 20 
D-8012 Ottobrunn 
FEDERAL REPUBLIC OF’GERMANY 


9. SPONSOR MGIMONITORNG AGENCY NANE(S) AND AOORESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Washington, D.C. 20301-3081 



9. PERFORMNG ORGANIZATION 
REPORT NUMBER 


AVF-IABG-046 


10. SPONSORMG/MONTTORMG AGENCY 
REPORT NUMBER 



12a. DCSTRBLT ION/AVALABUTY STATEMENT 

Approved for public release; distribution unlimited. 


IS. ABSTRACT (i4u*run200 worOt) 


12b. DtSTRBLTTION COOE 


Proprietary Software Systems, Inc., PSS VAX/1750A Ada Compiler, Ottobrunn, West Germany, 
VAX 8350 under VMS Version 5.1 (Host) to MIL-STD-1750A/PSS AdaRAID Version MD-08.011 
(Bare Machine Simulation under VAX/VMS Version 5.1)(Target), ACVC 1.10. 


E \ "r 3 r* 
* ? ( * 


, fc . ' ~ 

fc, SEP 25 1030* $ 




14. SUBJECT TERMS Ada programming language, Ada Compiler Validation 
Summary Report, Ada Compiler Validation Capability, Validation 
Testing, Ada Validation Office, Ada Validation Facility, ANSI/MIL- 
-1815A, Ada Joint Program Office 





mmwf 


IJVU. ’| 


OF ABSTRACT 

UNCLASSIFIED 


IS. NUK8ER OF RM3ES 


If. PRICE COOE 


20. UMfT» T CN OF ABSTRACT 




















AVF Control Number: AVF-IABG-046 


Ada COMPILER 
VALIDATION SUMMARY REPORT 
Certificate Number: #89121811.10259 
Proprietary Software Systems, Inc. 
PSS VAX/1750A Ada Compiler 
VAX 8350 to MIL-STD-1750A/PSS AdaRAID 


Completion of Testing: 
18th December 1989 


Prepared By: 
IABG mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 
Vest Germany 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 



AcC»:S'0--i 

NfIS C;l 
n;,.- u:-; 

U'i "■ .. ■ . .-J 

J ! . !■ . . 

B> 

Cl ' ' / 


A- 


j :A \ 

DiSt | 




Ada Compiler Validation Summary Report: 


Compiler Name: PSS VAX/1750 Ada Compiler, Version TX-01.000 
Certificate Number: 189121811.10259 

Host: VAX 8350 under VMS Version 5.1 

Target: MIL-STD-1750A/PSS AdaRAID Version MD-08.011 

(Bare Machine Simulation under VAX/VMS Version 5.1) 


Testing Completed 18th December 1989 Using ACVC 1.10 


This report has been reviewed and is approved. 

ILU- 

Dr. S. Heilbrunner 
IAB6 mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 
Vest Germany 



r Ada Validation Organization 
Dr. John F.-ltratoer 
J Institute for-Defense Analyses 
Alexandria VA 22311 



Director 

Department of Defense 
Washington DC 20301 


TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION . 1 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1 

1.2 USE OF THIS VALIDATION SUMMARY REPORT. 2 

1.3 REFERENCES.3 

1.4 DEFINITION OF TERMS . 3 

1.5 ACVC TEST CLASSES.4 

CHAPTER 2 CONFIGURATION INFORMATION . 7 

2.1 CONFIGURATION TESTED . 7 

2.2 IMPLEMENTATION CHARACTERISTICS . 8 

CHAPTER 3 TEST INFORMATION. 13 

3.1 TEST RESULTS.13 

3.2 SUMMARY OF TEST RESULTS BY CLASS.13 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.14 

3.4 WITHDRAWN TESTS.14 

3.5 INAPPLICABLE TESTS . 14 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . 18 

3.7 ADDITIONAL TESTING INFORMATION . 19 

3.7.1 Prevalidation.19 

3.7.2 Test Method.19 

3.7.3 Test Site.20 

APPENDIX A DECLARATION OF CONFORMANCE 

APPENDIX B APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 

APPENDIX D COMPILER AND LINKER OPTIONS 


























INTRODUCTION 


CHAPTER 1 
INTRODUCTION 


This Validation Summary Report A v S R 4- describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results of--testing this compiler using the Ada Compiler 
Validation Capability / (ACVC)c> An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that is 
not in the Standard. - 


Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between implementations. 
The Ada Standard permits some implementation dependencies—for example, the 
maximum length of identifiers or the maximum values of integer types. 
Other differences between compilers result from the characteristics of 
particular operating systems, hardware, or implementation strategies. All 
the dependencies observed during the process of testing this compiler are 
given i n thisj report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. The purpose of validating is to ensure conformity 
of the compiler to the Ada Standard by testing that the compiler properly 
implements legal language constructs and that it identifies and rejects 
illegal language constructs. The testing also identifies behavior that is 
implementation dependent, but is permitted by the Ada Standard. Six 
classes of tests are used. These tests are designed to perform checks at 
compile time, at link time, and during execution. 



1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 


This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 










INTRODUCTION 


. To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

. To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

. To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by IABG mbH, Abt SZT according to 
procedures established by the Ada Joint Program Office and administered by 
the Ada Validation Organization (AVO). On-site testing was completed 18th 
December 1989 at IABG mbH, Ottobrunn. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO may 
make full and free public disclosure of this report. In the United States, 
this is provided in accordance with the "Freedom of Information Act" 
(5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject compiler has no nonconformities 
to the Ada Standard other than those presented. Copies of this report are 
available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 

or from: 


IABG mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 

Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


2 








INTRODUCTION 


1.3 REFERENCES 


1. Reference Manual for the Ada Programming Language, 
ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide, December 1986. 


1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to the 
Ada programming language. 

Ada An Ada Commentary contains all information relevant to the 

Commentary point addressed by a comment on the Ada Standard. These 

comments are given a unique identification number having the 
form Al-ddddd. 

Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

Applicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines. 

AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and technical 
support for Ada validations to ensure consistent practices. 

Compiler A processor for the Ada language. In the context of this 

report, a compiler is any language processor, including 
cross-compilers, translators, and interpreters. 

Failed test An ACVC test for which the compiler generates a result that 

demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 


3 









INTRODUCTION 


Inapplicable An ACVC test that uses features of the language that a 
test compiler is not required to support or may legitimately 

support in a way other than the one expected by the test. 


Passed test An ACVC test for which a compiler generates the expected 

result. 

Target The computer which executes the code generated by the 

compiler. 

Test A program that checks a compiler's conformity regarding a 

particular feature or a combination of features to the Ada 
Standard. In the context of this report, the term is used to 
designate a single test, which may comprise one or more 
files. 


Withdrawn An ACVC test found to be incorrect and not used to check 

test conformity to the Ada Standard. A test may be incorrect 

because it has an invalid test objective, fails to meet its 
test objective, or contains illegal or erroneous use of the 
language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name identifies 
the class to which it belongs. Class A, C, D, and E tests are executable, 
and special program units are used to report their results during 
execution. Class B tests are expected to produce compilation errors. 
Class L tests are expected to produce errors because of the way in which a 
program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal Ada 
programs with certain language constructs which cannot be verified at run 
time. There are no explicit program components in a Class A test to check 
semantics. For example, a Class A test checks that reserved words of 
another language (other than those already reserved in the Ada language) 
are not treated as reserved words by an Ada compiler. A Class A test is 
passed if no errors are detected at compile time and the program executes 
to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is compiled and 
the resulting compilation listing is examined to verify that every syntax 
or semantic *»rror in the test is detected. A Class B test is passed if 
every illegal construct that it contains is detected by the compiler. 


4 








INTRODUCTION 


Class C tests check the run time system to ensure that legal Ada programs 
can be correctly compiled and executed. Each Class C test is self-checking 
and produces a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when it is executed. 

Class D tests check the compilation and execution capacities of a compiler. 
Since there are no capacity requirements placed on a compiler by the Ada 
Standard for some parameters—for example, the number of identifiers 
permitted in a compilation or the number of units in a library—a compiler 
may refuse to compile a Class D test and still be a conforming compiler. 
Therefore, if a Class D test fails to compile because the capacity of the 
compiler is exceeded, the test is classified as inapplicable. If a Class D 
test compiles successfully, it is self-checking and produces a PASSED or 
FAILED message during execution. 

Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the Ada 
Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is rejected 
by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is attempted. 
A Class L test passes if it is rejected at link time—that is, an attempt 
to execute the main program must generate an error message before any 
declarations in the main program or any units referenced by the main 
program are elaborated. In some cases, an implementation may legitimately 
detect errors during compilation of the test. 

Two library units, the package REPORT and the procedure CHECK_FILE, support 
the self-checking features of the executable tests. The package REPORT 
provides the mechanism by which executable tests report PASSED, FAILED, or 
NOT APPLICABLE results. It also provides a set of identity functions used 
to defeat some compiler optimizations allowed by the Ada Standard that 
would circumvent a test objective. The procedure CHECK_FILE is used to 
check the contents of text files written by some of the Class C tests for 
Chapter 14 of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. These tests produce messages that 
are examined to verify that the units are operating correctly. If these 
units are not operating correctly, then the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended to 
ensure that the tests are reasonably portable without modification. For 
example, the tests make use of only the basic set of 55 characters, contain 
lines with a maximum length of 72 characters, use small numeric values, and 
tests. However, some tests contain values that require the test to be 


5 








INTRODUCTION 


customized according to implementation-specific values—for example, an 
illegal file name. A list of the values used for this validation is 
provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable to 
the implementation. The applicability of a test to an implementation is 
considered each time the implementation is validated. A test that is 
inapplicable for one validation is not necessarily inapplicable for a 
subsequent validation. Any test that was determined to contain an illegal 
language construct or an erroneous language construct is withdrawn from the 
ACVC and, therefore, is not used in testing a compiler. The tests 
withdrawn at the time of this validation are given in Appendix D. 


6 








CONFIGURATION INFORMATION 


TABLE OF CONTENTS 

CHAPTER 2 

CONFIGURATION INFORMATION 


2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under the 
following configuration: 


Compiler: PSS VAX/175GA Ada Compiler, Version TX-01.000 

ACVC Version: 1.10 

Certificate Number: #89121811.10259 

Host Computer: 

Machine: VAX 8350 

Operating System: VMS Version 5.1 

Memory Site: 12 Megabytes 


Target Computer: 

Machine: 

Operating System: 
Memory Size: 


MIL-STD-1750A/PSS AdaRAID 

Bare Machine Simulation 
under VAX/VMS Version 5.1 

64 Kilobytes 


7 







CONFIGURATION INFORMATION 


2.2 IMPLEMENTATION CHARACTERISTICS 

One of the purposes of validating compilers is to determine the behavior of 
a compiler in those areas of the Ada Standard that permit implementations 
to differ. Class D and E tests specifically check for such implementation 
differences. However, tests in other classes also characterize an 
implementation. The tests demonstrate the following characteristics: 


a. Capacities. 

1) The compiler correctly processes a compilation containing 
723 variables in the same declarative part. (See test 
D29002K.) 

2) The compiler correctly processes tests containing loop 

statements nested to 65 levels. (See tests D55A03A..H (8 

tests).) 

3) The compiler correctly processes tests containing block 

statements nested to 65 levels. (See test D56001B.) 

4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 5 levels 
but not to 10 or 17 levels. (See tests D64005E..G (3 tests).) 


b. Predefined types. 

1) This implementation supports the additional predefined types 
SHORT INTEGER, LONG_FLOAT and LONG_INTEGER in the package 
STANDARD. (See tests B86001T..Z (7 tests).) 


c. Expression evaluation. 

The order in which expressions are evaluated and the time at which 
constraints are checked are not defined by the language. While 
the ACVC tests do not specifically attempt to determine the orde* 
of evaluation of expressions, test results indicate the following: 

1) None of the default initialization expressions for record 
components are evaluated before any value is 
checked for membership in a component's subtype. (See test 
C32117A.) 

2) Assignments for subtypes are performed with the same precision 
as the base type. (See test C35712B.) 


8 







CONFIGURATION INFORMATION 


3) This implementation uses no extra bits for extra precision 
and uses all extra bits for extra range. (See test C35903A.) 

4) NUMERIC_ERROR is raised for largest integer and no exception 
is raised for predefined and smallest integer when an 
integer literal operand in a comparison or membership test is 
outside the range of the base type. (See test C45232A.) 

5) No exception is raised when a literal operand in a fixed- 
point comparison or membership test is outside the range of 
the base type. (See test C45252A.) 

6) Underflow is not gradual. (See tests C45524A..Z (26 tests).) 


d. Rounding. 

The method by which values are rounded in type conversions is not 
defined by the language. While the ACVC tests do not specifically 
attempt to determine the method of rounding, the test results 
indicate the following: 

1) The method used for rounding to integer is round away from 
zero. (See tests C46012A..Z (26 tests).) 

2) The method used for rounding to longest integer is round 
away from zero. (See tests C46012A..Z (26 tests).) 

3) The method used for rounding to integer in static universal 
real expressions is round away from zero. (See test C4A014A.) 


e. Array types. 

An implementation is allowed to raise NUMERIC_ERROR or 
CONSTRAINT ERROR for an array having a 'LENGTH that exceeds 
STANDARD.INTEGER'LAST and/or SYSTEM.MAX_INT. For this 
implementation: 

1) Declaration of an array type or subtype declaration with more 
than SYSTEM.MAX_INT components raises NUMERIC_ERROR for 
one dimensional array and two dimensional array types and no 
exception for one dimensional array and two dimensional array 
subtypes. (See test C36003A.) 

2) NUMERIC_ERROR is raised when an array type with 

INTEGER'LAST + 2 components is declared. (See test 

C36202A.) 


9 








CONFIGURATION INFORMATION 


3) NUMERIC_ERROR is raised when an array type with 

SYSTEM.MAX_INT + 2 components is declared. (See test 

C36202B.) 

4) A packed BOOLEAN array having a 'LENGTH exceeding INTEGER'LAST 

raises NUM£RIC_ERROR when the array type is declared. (See 

test C52103X.) 

5) A packed two-dimensional BOOLEAN array with more than 

INTEGER'LAST components raises NUMERIC_ERROR when the array 

type is declared and exceeds INTEGER'LAST. (See test 

C52104Y.) 

6) In assigning one-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

7) In assigning two-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINTJERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 


8) A null array with one dimension of length greater 
than INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAINT_ERROR 
either when declared or assigned. Alternatively, an implemen¬ 
tation may accept the declaration. However, lengths must 
match in array slice assignments. This implementation raises 
NUMERIC ERROR when the array type is declared. (See 
test E52103Y.) 


Discriminated types. 

1) In assigning record types with discriminants, the expression 
is evaluated in its entirety before CONSTRAINT_ERROR is raised 
when checking whether the expression's subtype is compatible 
with the target's subtype. (See test C52013A.) 


Aggregates. 

1) In the evaluation of a multi-dimensional aggregate, the test 
results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 

2) In the evaluation of an aggregate containing subaggregates, 
not all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 








CONFIGURATION INFORMATION 


3) CONSTRAINT_ERROR is raised after all choices are 
evaluated when a bound in a non-null range of a non-null 
aggregate does not belong to an index subtype. (See test 

E43211B.) 


h. Pragmas. 

1) The pragma INLINE is supported for functions and procedures 
but not when applied across compilation units. (See tests 
LA3004A..B (2 tests), EA3004C..D (2 tests), and CA3004E..F 

(2 tests) .) 


i. Generics. 

This compiler enforces the following two rules concerning 
declarations and proper bodies which are individual compilation 
units: 

o generic bodies must be compiled and completed before their 
instantiation. 

o recompilation of a generic body or any of its transitive 
subunits makes all units obsolete which instantiate that 
generic body. 

These rules are enforced whether the compilation units are in 
separate compilation files or not. AI408 and AI506 allow this 
behaviour. 

1) Generic specifications and bodies can be compiled 

in separate compilations. (See tests CA1012A, CA2009C, 

CA2009F, BC3204C, and BC3205D.) 

2) Generic subprogram declarations and bodies can be 

compiled in separate compilations. (See tests CA1012A and 
CA2009F.) 

3) Generic library subprogram specifications and bodies can be 
compiled in separate compilations. (See test CA1012A.) 

4) Generic non-library package bodies as subunits can 

be compiled in separate compilations. (See test CA2009C.) 

5) Generic non-library subprogram bodies can be 
compiled in separate compilations from their stubs. (See test 
CA2009F.) 

6) Generic unit bodies and their subunits can be 
compiled in separate compilations. (See test CA3011A.) 


11 








CONFIGURATION INFORMATION 


7) 

Generic 

package declarations and 

bodies 

can be 


compiled 

in separate compilations. 

(See 

tests 

CA2009C, 


BC3204C, 

and BC3205D.) 




8) 

Generic 

library package specifications 

and 

bodies 

can be 


compiled 

in separate compilations. 

(See 

tests 


BC3204C 

and BC3205D.) 




9) 

Generic 

unit bodies and their 

subunits 

can be 


compiled 

in separate compilations. (See 

test 

CA3011A 

.) 


j. Input and output. 

1) The package SEQUENTIAL_IO can be instantiated with 

unconstrained array types or record types with 
discriminants without defaults. However, this implementation 
raises USE_ERROR upon creation of a file for unconstrained 
array types. (See tests AE2101C, EE2201D, and EE2201E.) 

2) The package DIRECT_I0 can be instantiated with unconstrained 

array types or record types with discriminants without 
defaults. However, this implementation raises USEJ5RROR upon 
creation of a file for unconstrained array types. (See tests 
AE2101H, EE2401D, and EE2401G.) 

3) The director, AJPO, has determined (AI-00332) that every call 
to OPEN and CREATE must raise USE_ERROR or NAME_ERROR if file 
input/output is not supported. This implementation exhibits 
this behaviour for SEQUENTIALJ[0, DIRECT_IO, and TEXT_IO. 


12 







TEST INFORMATION 


CHAPTER 3 
TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 670 tests were inapplicable to this implementation. 
All inapplicable tests were processed during validation testing except for 
285 executable tests that use floating-point precision exceeding 
that supported by the implementation. Modifications to the code, 
processing, or grading for 85 tests were required to successfully demon¬ 
strate the test objective. (See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 

A 

B 

TEST 

C 

CLASS 

D 

E 

L 

TOTAL 

Passed 

129 

1134 

1667 

15 

14 

44 

3003 

Inapplicable 

0 

4 

648 

2 

14 

2 

670 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


13 






TEST INFORMATION 


3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 

2 

3 

4 

5 

6 

CHAPTER 
7 8 

9 

10 

11 

12 

13 

14 

TOTAL 

Passed 

192 

547 

507 

248 

170 

99 

161 

332 

127 

36 

252 

256 

76 

3003 

N/A 

20 

102 

173 

0 

2 

0 

5 

0 

10 

0 

0 

113 

245 

670 

Wdrn 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 

The following' 44 tests were withdrawn from ACVC Version 1.10 
at the time of this validation: 


E28005C 

A39005G 

B97102E 

C97116A 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B. 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A84N 

CD2A84M 

CD5011O 

CD2B15C 

CD7205C 

CD2D11B 

CD5007B 

ED7004B 

ED7005C 

ED7005D 

ED7006C 

ED7006D 

CD7105A 

CE3301A 

CD7203B 

CE3411B 

CD7204B 

CD7205D 

CE2107I 

CE3111C 


See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of features 
that a compiler is not required by the Ada Standard to support. Others may 
depend on the result of another test that is either inapplicable or 
withdrawn. The applicability of a test to an implementation is considered 
each time a validation is attempted. A test that is inapplicable for one 
validation attempt is not necessarily inapplicable for a subsequent 
attempt. For this validation attempt, 670 tests were inapplicable for 
the reasons indicated: 


a. The following 285 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAX DIGITS: 


C24113F..Y (20 tests) 
C35706F..Y (20 tests) 
C35708F..Y (20 tests) 
C45241F..Y (20 tests) 


C35705F..Y (20 tests) 
C35707F..Y (20 tests) 
C35802F..Z (21 tests) 
C45321F..Y (20 tests) 









TEST INFORMATION 


C45421F..Y (20 tests) C45521F..Z (21 tests) 

C45524F..Z (21 tests) C45621F..Z (21 tests) 

C45641F..Y (20 tests) C46012F..Z (21 tests) 

C35702A and B86001T are not applicable because this implementation 
supports no predefined type SHORT_FLOAT. 

C45531M..P (4 tests) and C45532M..P (4 tests) are not applicable 
because they require a value of MAX_MANTISSA greater than 32. 

E64005F and D64005G are not applicable because these tests have 
excessive memory requirements which cause STORAGEJERROR to be 
raised: D64005F during execution; D64005G during elaboration of 
library units. 

C86001F is not applicable because, for this implementation, the 
package TEXT_IO is dependent upon package SYSTEM. These tests 
recompile package SYSTEM, making package TEXT_IO, and 
hence package REPORT, obsolete. 

B86001X, C45231D, and CD7101G are not applicable because this 
implementation does not support any predefined integer type with a 
name other than INTEGER, LONG_INTEGER, or SHORT_INTEGER. 

B86001Y is not applicable because this implementation supports no 
predefined fixed-point type other than DURATION. 

B86001Z is not applicable because this implementation supports no 
predefined floating-point type with a name other than FLOAT, 
LONG_FLOAT , or SHORT_FLOAT. 

CA2009A, CA2009C, CA2009F and CA2009D are not applicable because 
this compiler creates dependencies between generic bodies, and 
units that instantiate them (see section 2.2i for rules and 
restrictions concerning generics). 

LA3004A, LA3004B, EA3004C, EA3004D, CA3004E, and CA3004F are not 
applicable because this implementation does not support pragma 
INLINE when applied across compilation units (See Appendix F of 
the Ada Standard in Appendix B of this report, and Section 2.2.h 
(D). 

CD1009C, CD2A41A..E (5 tests) and CD2A42A..J (10 tests) are not 
applicable because this implementation imposes restrictions on 
'SIZE length clauses for floating point types. 

CD2A61E, CD2A61G and CD2A61I are not applicable because this 
implementation imposes restrictions on 'SIZE length clauses for 
array types. 

CD2A84B..1 (8 tests) and CD2A84K..L (2 tests) are not applicable 


15 









TEST INfUKMATION 


because this implementation imposes restrictions on 'SIZE length 
clauses for access types. 

CD2A91A..E (5 tests) are not applicable because 'SIZE length 
clauses for task types are not supported. 

CD2B11G is not applicable because 'STORAGE_SIZE representation 
clauses are not supported for access types where the designated 
type is a task type. 

CD2B15B is not applicable because a collection size larger than 
the size specified was allocated. 

The following 76 tests are not applicable because, for this 
implementation, address clauses are not implemented: 


CD5003B..I 

(8 tests) 

CD5011A 

CD5011B 

CD5011C 

CD5011D 

CD5001E 

CD5011F 

CD5011G 

CD5011H 

CD5011I 

CD5011K 

CD5011L 

CD5011M 

CD5011N 

CD5011Q 

CD5011R 

CD5011S 

CD5012A 

CD5012B 

CD5012C 

CD5012D 

CD5012E 

CD5012F 

CD5012G 

CD5012H 

CD5012I 

CD5012J 

CD5012L 

CD5012M 

CD5013A 

CD5013B 

CD5013C 

CD5013D 

CD5013E 

CD5013F 

CD5013G 

CD5013H 

CD5013I 

CD5013K 

CO5013L 

CD5013M 

CD5013N 

CD5013O 

CD5013R 

CD5013S 

CD5014A 

CDS014B 

CD5014C 

CD5014D 

CD5014E 

CD5014F 

CD5014G 

CD5014H 

CD5014I 

CD5014J 

CD5014K 

CD5014L 

CD5014M 

CD5014N 

CD5014O 

CD5014R 

CD5014S 

CD5014T 

CD5014U 

CD5014V 

CD5014W 

CD5014X 

CD5014Y 

CD5014Z 


The following 238 tests are inapplicable because sequential, text, 
and direct access files are not supported: 


CE2102A..C 

(3 

tests) 

CE2102G..H 

(2 

tests) 

CE2102R 



CE2102N..Y 

(12 

! tests) 

CE2103C..0 

(2 

tests) 

CE2104A..D 

(4 

tests) 

CE2105A..B 

(2 

tests) 

CE2106A..B 

(2 

tests) 

CE2107A..H 

(8 

tests) 

CE2107L 



CE2108A..B 

(2 

tests) 

CE2108C..H 

(6 

tests) 

CE2109A..C 

(3 

tests) 

CE2110A..D 

(4 

tests) 

CE2111A..I 

(9 

tests) 

CE2115A..B 

(2 

tests) 

CE2201A..C 

(3 

tests) 

CE2201F..N 

(9 

tests) 

CE2204A..D 

(4 

tests) 

CE2205A 



CE2208B 



CE2401A..C 

(3 

tests) 

CE2401E..F 

(2 

tests) 

CE2401R..L 

(5 

tests) 

CE2404A..B 

(2 

tests) 

CE2405B 



CE2406A 



CE2407A..B 

(2 

tests) 

CE2408A..B 

(2 

tests) 

CE2409A..B 

(2 

tests) 

CE2410A..B 

(2 

tests) 

CE2411A 



CE3102A..B 

(2 

tests) 

EE3102C 




16 







i ijrrvnnn i ± vi* 


CE3102F..H (3 tests) 

CE3103A 

CE3107B 

CE3109A 

CE3111A..B (2 tests) 

CE3112A..D (4 tests) 

CE3115A 

CE3208A 

CE3302A 

CE3402A 

CE3402C..D (2 tests) 
CE3403E..F (2 tests) 
CE3405A 

CE3405C..D (2 tests) 
CE3407A..C (3 tests) 
CE3409A 
EE3409F 

CE3410C..E (3 tests) 

CE3411A 

CE3412A 

CE3413A 

CE3602A..D (4 tests) 
CE3604A..B (2 tests) 
CE3606A..B (2 tests) 
CE3704M..O (3 tests) 
CE3706F..G (2 tests) 
CE3805A..B (2 tests) 
CE3806D..E (2 tests) 
CE3905A..C (3 tests) 
CE3906A..C {3 tests) 


CE3102J..K (2 tests) 
CE3104A..C (3 tests) 
CE3108A..B (2 tests) 
CE3110A 

CE3111D..E (2 tests) 

CE3114A..B (2 tests) 

EE3203A 

EE3301B 

CE3305A 

EE3402B 

CE3403A..C (3 tests) 
CE3404B..D (3 tests) 
EE3405B 

CE3406A..0 (4 tests) 

CE3408A..C (3 tests) 

CE3409C..E (3 tests) 

CE3410A 

EE3410F 

CE3411C 

EE3412C 

CE3413C 

CE3603A 

CE3605A..E (5 tests) 
CE3704A..F (6 tests) 
CE3706D 

CE3804A..P (16 tests) 
CE3806A..B (2 tests) 
CE3806G..H (2 tests) 
CE3905L 

CE3906E..F (2 tests) 


These tests were not processed because their inapplicability can 
be deduced from the result of other tests. 


Tests CE2103A, CE2103B and CE3107A raise USE_ERROR upon create for 
Sequential, Direct and Text 10. 

Tests EE2201D, EE2201E, EE2401D and EE2401G raise USE_ERROR upon 
create. 


17 


TEST INFORMATION 


3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases where 
legitimate implementation behavior prevents the successful completion of an 
(otherwise) applicable test. Examples of such modifications include: 
adding a length clause to alter the default size of a collection; splitting 
a Class B test into subtests so that all errors are detected; and 
confirming that messages produced by an executable test demonstrate 
conforming behavior that was not anticipated by the test (such as raising 
one exception instead of another). 

Modifications were required for 85 tests. 

a. The following tests were split because syntax errors at one point 
resulted in the compiler not detecting other errors in the test: 


B22003A 

B24007A 

B24009A 

B25002B 

B32201A 

B34005N 

B34005T 

B34007H 

B35701A 

B36171A 

B36201A 

B37101A 

B37102A 

B37201A 

B37202A 

B37203A 

B37302A 

B38003A 

B38003B 

B38008A 

B38008B 

B38009A 

B38009B 

B38103A 

B38103B 

B38103C 

B38103D 

B38103E 

B41202A 

B43202C 

B44002A 

B48002A 

B48002B 

B48002D 

B48002E 

B48002G 

B48003E 

B49003A 

B49005A 

B49006A 

B49007A 

B49009A 

B4A010C 

B54A20A 

B54A25A 

B58002A 

B58002B 

B59001A 

B59001C 

B59001I 

B62006C 

B67001A 

B67001B 

B67001C 

B67001D 

B74103E 

B74104A 

B85007C 

B91005A 

B95003A 

B95007B 

B95031A 

B95032A 

B95074E 

BC1002A 

BC1109A 

BC1109C 

BD5005B 

BC1202E 

BC1206A 

BC2001E 

BC3005B 

BC3009C 


b. For the two tests BC3204C and BC3205D, the compilation order was 
changed to 

BC3204C0, Cl, C2, C3M, C4, C5, C6, C3M 

and 

BC3205D0, D2, DIM 

respectively. This change was necessary because of the compiler's 
rules for separately compiled generic units (see section 2.2i for 
rules and restrictions concerning generics). When processed in 
this order the expected error messages were produced for BC3204C3M 
and BC3205D1M. 

c The two tests BC3204D and BC3205C consist of several compilation 
units each. The compilation units for the main procedures are 
near the beginning of the files. When processing these files 
unchanged, a link error is reported instead of the expected 
compilation of the generic units. Therefore, the compilation 


1 ' 







TEST INFORMATION 


files were modified by appending copies of the main procedures to 
the end of these files. When processed, the expected error 
messages were generated by the compiler. 

d. Tests C39005A, CD7004C, CD7005E and CD7006E wrongly presume an 

order of elaboration of the library unit bodies. These tests were 
modified to include a PRAGMA ELABORATE (REPORT); 

e. Test E28002B checks that predefined or unrecognized pragmas may 

have arguments involving overloaded identifiers without enough 
contextual imformation to resolve the overloading. It also checks 
the correct processing of pragma LIST. For this implementation, 
pragma LIST is only recognised if the compilation file is compiled 
without errors or warnings. Hence, the test was modified to 

demonstrate the correct processing of pragma LIST. 

f. Test CD1C04E checks that a derived type can have a different 

physical representation than its parent type. The component 
specifications in the test use 'size clauses that cause word 
boundaries to be crossed. Since this implementation does not 

allow a component to cross a word boundary, this test generates a 
compile time error message. Therefore, the expressions 
character'size and boolean'size were changed to character’size/2 
and boolean’size/2 so that components stay within a word. 

g. Tests C45524A and C45524B contain a check at line 136 that may 

legitimately fail as repeated division may produce a quotient that 
lies within the smallest safe interval. This check was modified 
to include, after line 138, the text: 

ELSIF VAL <= F'SAFE_SMALL THEN COMMENT ("UNDERFLOW SEEMS GRADUAL")? 


For this implementation, the required support package specification, 
SPPRT13SP, was rewritten to provide constant values for the function names. 

3.7 ADDITIONAL TESTING INFORMATION 

3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 produced 
by the PSS VAX/1750A Ada Compiler, Version TX-01.000 was submitted to the 
AVF by the applicant for review. Analysis of these results demonstrated 
that the compiler successfully passed all applicable tests, and the 
compiler exhibited the expected behavior on all inapplicable tests. 

3.7.2 Test Method 

Testing of the PSS VAX/1750A Ada Compiler, Version TX-01.000 using ACVC 
Version 1.10 was conducted by IABG on the premises of IABG. The 
configuration in which the testing was performed is described by the 







TEST INFORMATION 


following designations of hardware and software components: 

VAX 8350 
VMS Version 5.1 
MIL-STD-1750A/PSS AdaRAID 
Bare Machine Simulation 
under VAX/VMS Version 5.1 
PSS VAX/1750A Ada Compiler, 

Version TX-01.000 

The original ACVC distribution tape was loaded to the host machine, where 
it was customized to remove all withdrawn tests and tests requiring unsup¬ 
ported floating point precisions. Tests that make use of implementation 
specific values were also customized. Tests requiring modifications during 
the prevalidation testing were modified accordingly. 

After the test files were loaded to disk, the full set of tests was 
compiled linked, and all executable tests were run on the 
MIL-STD-1750A/PSS AdaRAID Version MD-08.011 Simulator. Results were 
evaluated and printed on the host machine. 

The compiler was tested using command scripts provided by Proprietary 
Software Systems and reviewed by the validation team. The compiler was 
tested using no option qualifiers. All chapter B tests were compiled with 
the /LIST=S qualifier. 

Tests were compiled using the command 

MADA (test name> 

This implementation has no linker options. Tests were linked using the 
command 

MALIB (test name) 

A full list of compiler options is given in Appendix E. 

Tests were compiled, linked, and executed (as appropriate) using a single 
computer. Test output, compilation listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by the 
validation team were also archived. 

3.7.3 Test Site 

Testing was conducted at IABG mbH, Ottobrunn and was completed on 18th 
December 1989. 


Host computer: 

Host operating system: 
Target computer: 

Target operating system: 

Compiler: 






DECLARATION OF CONFORMANCE 


APPENDIX A 

DECLARATION OF CONFORMANCE 


Proprietary Software Systems has submitted the following 
Declaration of Conformance concerning the PSS VAX/1750A Ada 
Compiler, Version TX-01.000. 










PROPRIETARY SOFTWARE SYSTEMS 


DECLARATION OF CONFORMANCE 

L003-0127 


Customer: 

Ada Validation Facility: 
ACVC Version: 


PSS, Inc. 
IABG mbH 
1.10 


Ada Implementation 

Ada Compiler Name: 
Version: 

Host Computer System: 
Target Computer System: 


PSS VAX/1750A Ada Compiler 

TX-01.000 

VAX 8350/VMS 5.1 

MIL-STD-1750A/PSS AdaRAID Version 
MD-08. Oil (bare machine simulation 
under VAX/VMS Version 5.1) 


Customer's Declaration 

I, the undersigned, representing PSS, Inc., declare that PSS, Inc., 
has no knowledge of deliberate deviations from the Ada Language 
Standard ANSI/MIL-STD-1815A in the implementation listed in this 
declaration. 



16 January 1990 
Date 


429 Santa Monica Blvd. • Suite 430 • Santa Monica, California 90401 • (213)394-5233 • FAX (2'H'> 393 22 







APPENDIX F OF THE Ada STANDARD 


APPENDIX B 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of the PSS VAX/1750A Ada 
Compiler, Version TX-01.000, as described in this Appendix, are 
provided by Proprietary Software Systems. Unless specifically 
noted otherwise, references in this appendix are to compiler 
documentation and not to this report. Implementation-specific 
portions of the package STANDARD are given below. 


package STANDARD is 
• • • • 

type SHORT_INTEGER is range -128..127; 

type INTEGER is range -32768..32767; 

type LONG_INTEGER is range -2147483648 .. 2147483647; 

type FLOAT is digits 6 range 

-16#0.7FFF_FF#E+32 .. 16#0.7FFF_FF#E+32; 
type LONG_FLOAT is digits 9 range 

-16#0.7FFF_FFFF_FFFF FFSE+32 .. 

1610.7FFF_FFFF_FFFF_FF#E+32; 

type DURATION is delta 0.0001 range -86400.0..86400.0; 


end STANDARD; 






PSS, Inc. 


PSS ADA COMPILER USER'S GUIDE 


1 November 1989 


Supported Pragmas 
ELABORATE 


PRIORITY 


MIL-STD-1815A APPENDIX F 

This section discusses how the PSS Ada Compiler handles MIL- 
SI D-1815 A issues that are left up to the implementor. Terms 
that may be unfamiliar are given in the Glossary at the end of 

this manual. 

The PSS Ada Compiler supports the following pragmas: 

This pragma controls elaboration order. It specifies that the 
named library unit must be elaborated before the following 
compilation unit The pragma is allowed only immediately after 
the context clause of a compilation unit (before the subsequent 
library unit or secondary unit). Each argument to the pragma 
must be the simple name of a library unit mentioned by the 
context clause. 

An elaboration order that meets the rules of Ada may not 
satisfy the needs of some applications. In such cases, the user 
will specify the elaboration order via the pragma ELABORATE. 
In particular, a statement such as 

PRAGMA ELABORATE (INITIALIZE); 

may be used to cause an initialization package or procedure to 
be elaborated before all other units. 

This pragma specifies the priority of a task or the priority of a 
main program. It specifies the priority as a static expression of 
the predefined integer subtype PRIORITY which has a range 
of 10 to 200. The pragma is allowed within the specification of 
a task unit or imm ediately within the outermost declarative part 
of a main progr am. 

Priority affects the order of task execution. The scheduler 
selects the task with the highest priority for execution. New 
tasks that are ready to execute are placed in a priority-ordered 
queue with tasks of equal priority being placed in time-arrival 
order within the same priority level. The following statement 
in a task sets its priority to 64. 


-48- 

DTX-3000 


MIL-STD-1815A APPENDIX F 





PSS, Inc. 


LINKAGE NAME 


FOREIGN BODY 


PSS ADA COMPILER USER'S GUIDE 

1 November 1989 


PRAGMA PRIORITY (10); 

The scheduler will select another waiting task to start execution 
if the executing task becomes blocked or when a higher priority 
task becomes ready. In other words, a higher priority task will 
preempt a lower priority task. All tasks which do not have a 
specified priority have a default priority of 10. 

This pragma effects a link-time binding between an Ada entity 
and an externally meaningful name. The format is: 


PRAGMA LINKAGE_NAME (Ada-simple-name, 

string-constant); 

where the Ada-simple-name is the name of a subprogram, 
exception, or object. The Ada-simple-name must be declared 
in a package specification and the pragma must appear in the 
same package specification, after the declaration. The string- 
constant is a name that is not defined within a compilation unit 
in the user’s library, but rather is an external name to be 
supplied to the link editor. 

The effect of pragma UNKAGE_NAME is to provide a 
specified external name for an Ada entity, allowing the PSS 
Memory Allocation Processor to associate the entity with a 
symbol (string-constant) that is known to the PSS Memory 
Allocation Processor but not to the user’s library units. The PSS 
Ada Compiler will not check the string-constant supplied by the 
user as the external name; it is the user’s responsibility to ensure 
that the string-constant is acceptable to the PSS Memory 
Allocation Processor and meaningful to the program. 


This pragma informs the PSS Ada Compiler that the body of 
a package, including all subprograms, objects, and exceptions, 
is implemented in an externally compiled or assembled module. 
The external module may be written in Ada (and compiled into 
another library) or in another language. 


-49- 

DTX-3000 


MIL-STD-1815A APPENDIX F 







PSS, Inc. 




Unsupported Pragmas 


PSS ADA COMPILER USER'S GUIDE 

1 November 1989 


The package containing pragma FOREIGNJBODY must be a 
non-generic top-level package specification. It may contain only 
the following: subprogram declarations, object declarations, 
number declarations, and pragmas. Object declarations must 
use an unconstrained type mark that is not a task type, and 
cannot use an initial value expression. The foreign body itself 
is responsible for initialization of all objects declared in the 
package, including objects that are normally initialized implicitly 
(such as access types and certain record types, as described in 
[LRM 32.1]). The FOREIGN_BODY pragma must appear 
before any declarations. The format is: 

PRAGMA FOREIGNJBODY (languagejiame, 

elaboration_routine_name); 

where language jiame could be any language that conforms to 
the PSS Memory Allocation Processor object module format 
The PSS JOVIAL compiler or 1750A Macro Assembler object 
modules may be used in this manner. The language jiame 
informs the PSS Ada Compiler which subroutine linkage will be 
used by the foreign module. The foreign module may include 
a routine for initialization, which is identified by the optional 
parameter elaboration_routine_name. It is the user’s 
responsibility to ensure that "foreign modules use data 
representations, calling conventions, and (optionally) 
initialization routines that are compatible with the PSS Ada 
Compiler and with the Ada language itself. 

When using pr agma FOREIGN_BODY, the user should include 
a I2NKAGE_NAME pragma” for each declaration in the 
package, inducing declarations in nested package specifications. 
This will give the user positive control over external names used 
by the foreign module and ensure that no naming conflicts occur 
at link time. 

Appendix B gives a complete example of a program that uses 
the pragmas LINKAGE_NAME and FOREIGNJBODY. 

The other predefined pragmas in the language currently have 
no effect. However the same functionality is provided for some 
pragmas by other means. These pragmas are the following: 


-50- 

DTX-3000 


MIL-STD-1815A APPENDIX F 





PSS, Inc. 


PSS ADA COMPILER USER’S GUIDE 


1 November 1989 


CONTROLLED 

INUNE 

INTERFACE 

LIST 

MEMORY_SIZE 

OPTIMIZE 

PACK 

PAGE 

SHARED 

STORAGEUNIT 

SUPPRESS 

SYSTEM NAME 


There is no automatic storage deallocation of access collections. 
If you want to deallocate storage, use 
UNCHECKED_DEALLOCATION, a standard generic function 
for deallocation! 

The INLINE pragma is not supported in this version. It will be 
supported in subsequent versions. 

Instead of the INTERFACE pragma, the PSS Ada Compiler 
uses the combination of the LINKAGE_NAME and 
FOREIGN_BODY pragmas that are implementation defined. 

The LIST option is used to control listings rather than the LIST 
pragma. 

The MEMORY_SIZE pragma is not supported for the 1750A 
target. 

The OPTIMIZE option is used to control optimization rather 
than the OPTIMIZE pra gm a. 

The PACK pragma is not supported. The optimizer decides on 
the most efficient form of packing. You can achieve the effect 
of the PACK pragma with representation specifications. 

To provide a new page, include a form-feed character in the 
source code file. 

The SHARED pragma is not supported for the 1750A target 

The STORAGE_UNIT pragma is not supported for the 1750A 
target 

The SUPPRESS option is used to control suppression of 
exceptions rather than the SUPPRESS pragma. 

The SYSTEM_NAME pragma is not supported for the 1750A 
target 


-51- 

DTX-3000 

MIL-STD-1815A APPENDIX F 




PSS, Inc. 


PSS ADA COMPILER USER'S GUIDE 


1 November 1989 


Attributes 

Package "SYSTEM" 


Restrictions 


Aside from restrictions on certain representation specifications 
(see the Restrictions section that follows), the PSS Ada 
Compiler supports no implementation-dependent attributes. 

The predefined package called SYSTEM contains the definitions 
of certain implementation dependent characteristics. In 
accordance with Section 13.7 of the Ada Language Reference 
Manual , the package is defined as follows: 

package SYSTEM is 
-Required definitions: 

type ADDRESS is new integer, 
type NAME is (MIL STD 1750A); 

SYSTEM NAME : constant NAME := MIL_STD_1750A; 
STORAGE_UNIT : constant :* 16; 

MEMORY "SIZE : constant :* 65536; 

MIN INT " : constant := -2""31; - -2,147,483,648 
MAXJNT : constant := 2""31-1; - 2,147,483,647 
MAX”DIGITS : constant:» 9; 

MAXjMANTISSA : constant :* 31; 

FINE~DELTA : constant :* 2#1.0#e-31; 

TICK” : constant :* 0.0001; 
subtype PRIORITY is INTEGER range 10.200; 
end SYSTEM; 

Representation clauses are used to map Ada types onto the 
target machin e. The PSS Ada Compiler implements all 
representation clauses defined in Chapter 13 of the LRM, 
including length clauses [LRM 132], enumeration representation 
clauses [LRM 133], record representation clauses [LRM 13.4], 
and address clauses [LRM 133], with the following restrictions: 

• Length clauses for size specifications (TS1ZE) are restricted 
to types and subtypes whose sizes are known at compile time. 

• Length clauses cannot be used for composite types to force 
a smaller size on components than is established by length 
clauses for the component types or by the default types of 
the components. 


-52- 

DTX-3000 


MIL-STD-1815A APPENDIX F 









PSS AOA COMPILER USER’S GUIDE 

1 November 1989 


Length clauses for the attributes T STORAGE SIZE and 
TSMALL are restricted only as specified in the [£RM 13-2]. 
Note that the PSS Ada Compiler will include a small amount 
of extra storage for administrative purposes in storage sizes 
for tasks and access types. 

For enumeration representation clauses, the integer codes 
given in the aggregate must be in the range 
INTEGER’FIRST.JNTEGER’LAST. 

Record representation clauses may be used only on types 
whose components’ sizes are known at compile time. 

Record representation clauses may not force components to 
cross word boundaries. 

If representation clauses are given for some (but not all) 
components of a record, the PSS Ada Compiler will allocate 
the unspecified components in its normal manner. 

Address clauses are permitted only for objects declared in 
a top-level library package or in a task. 

Address clauses are not permitted for local packages. 

Each address clause used for an entry will result in a call to 
a runtime support routine to effect the binding of the entry 
to an interrupt. 

The PSS Ada Compiler represents integer and fixed point 
types and subtypes in 1750A native form; that is, as two’s 
complement numbers. As a consequence, it is an error to 
specify a length clause of 1 bit for the integer range KXL101. 
Even though 1 bit is sufficient to represent these two values, 
the PSS Ada Compiler will allocate 7 bits because 2**6 < 
101 < 2* *7 and reject a length clause which specifies fewer 
than 7 bits for such a range. 


-53- 

DTX-3000 


MIL-STD-1815A APPENDIX F 





PSS ADA COMPILER USER'S GUIDE 

1 November 1989 


The PSS Ada Compiler generates implementation-dependent 
components for arrays with bounds dependent on record 
discriminants. These names, which are used for book-keeping 
by the PSS Ada Compiler cannot be accessed by the user. 

Ada semantics of address clauses allow for the association of 
numbered interrupts with task entries. The PSS Ada Compiler 
implements this association by interpreting the simple expression 
in the clause as the vector number of a 1750A exception or 
interrupt 

Unchecked Conversions The generic function UNCHECKED_CONVERSION can be 

instantiated to effect an unchecked type conversion. The only 
restriction imposed by the PSS Ada Compiler is that the sizes 
of the source and target types must be known at compile time. 
Unchecked conversions between types of unequal sizes will 
result in truncation or zero-padding, as appropriate. 
Unconstrained arrays and unconstrained record types without 
defaulted discriminants are not allowed as target types of 
unchecked conversions. 

Input/Output Packages Predefined packages for input and output are provided with the 

PSS Ada Compiler. These packages include SEQUENTIAL IO, 
DIRECTJO, TEXT_IO, IO_EXCEPTIONS, and 
LOW_LEVEL IO, as described in~Chapter 14 of die Ada 
Language Reference Manual. Use of the packages for 
SEQUENTIAL_IO and DIRECT^IO raise USE ERROR for 
the MTL-STD-1750A computer since neither sequential nor 
direct access files are available on these computers. 


PSS. Inc. 

Component Names 


Address Clauses 


Additional Information 

Generics The PSS Ada Compiler allows a generic declaration to be 

compiled separately from its corresponding proper body. It also 
permits separate compilation of subunits of a generic unit [LRM 
103]. The PSS Ada Compiler enforces the requirement that a 
generic body must be compiled prior to an instantiation of the 
generic unit When recompiling the body of a generic unit the 
PSS Ada Librarian will mark as obsolete all units that 
instantiated the generic. 


-54- 

DTX-3000 


MIL-STD-1815A APPENDIX F 







PSS, Inc. 


PSS ADA COMPILER USER'S GUIDE 


Main Programs 


Predefined Types 


Every instantiation of a user-defined generic will result in the 
generation of in-line code for the generic unit. Thus, multiple 
instantiations of a given generic will produce duplications of 
code. Instantiations of the predefined generics 
U N C H E C K E D _ C O N V E R S I O N and 
UNCHECKEDJDEALLOCATION are implemented as calls 
to runtime support routines. 

When linking an Ada program, one of the library units must be 
designated as the main program . The main program must be 
a subprogram library unit with no parameters [LRM 10.1]. 

The PSS Ada/1750A Compiler implements in package 
STANDARD the following predefined numeric types: 

SHORT INTEGER 

INTEGER 

LONG INTEGER 

FLOAT 

LONG FLOAT 

DURATION 

and the following predefined numeric subtypes: 

NATURAL 

POSITIVE 

The attributes for each of the types and subtypes predefined in 
package STANDARD are given in the following table. 


-55- 

DTX-3000 


MIL-STD-1815A APPENDIX F 







PSS, Inc. 


PSS ADA COMPILER USER'S GUIDE 


Attributes of Predefined Types 


TYPE 

ATTRIBUTE 

VALUE 

SHORT INTEGER FIRST 

-128 

SHORT"INTEGER LAST 

127 

INTEGER 

FIRST 

-32768 

INTEGER 

LAST 

32767 

NATURAL 

FIRST 

0 

NATURAL 

LAST 

32767 

POSITIVE 

FIRST 

1 

POSITIVE 

LAST 

32767 

LONG INTEGER 

FIRST 

-2“ *31 

LONG INTEGER 

LAST 

2**31-1 

FLOAT 

DIGITS 

6 

FLOAT 

MANTISSA 

24 

FLOAT 

EMAX 

127 

FLOAT 

EPSILON 

16#0.1000 00#E-4 


approximately 

29^3674E^)7 

FLOAT 

SMALL 

16#0.8000 000#E-21 


approximately 

2J4894E-26 

FLOAT 

LARGE 

16#0.FFFF F80#E+21 


approximately 

1.93428E+25 

FLOAT 

FIRST 

•16#0.7FFF FF#E+32 


approximately 

-1.70141E+J8 

FLOAT 

LAST 

16#0.7FFF FF#E+32 


approximately 

1.70141E+38 

FLOAT 

SAFE EMAX 

127 

FLOAT 

SAFE_SMALL 

16#0.1000 000#E-31 


approximately 

2.93874E-39 

FLOAT 

SAFE_LARGE 

16#0.7FFF FC0#E+32 


approximately 

1.70141E^38 

FLOAT 

MACHINE RADIX 

2 

FLOAT 

MACHINE"MANTISSA 

24 

. FLOAT 

MACHINE~E MAX 

127 

FLOAT 

MACHINE”EMIN 

-127 

FLOAT 

machine”rounds 

TRUE 

FLOAT 

MACHINE'OVERFLOWS 

TRUE 


-56- 

DTX-3000 


MIL-STD-1815A APPENDIX F 



PSS, Inc. 


PSS ADA COMPILER USER'S GUIDE 


Attributes of Predefined Types 


TYPE 

ATTRIBUTE 

VALUE 

LONG FLOAT 

DIGITS 

9 

LONG"FLOAT 

MANTISSA 

40 

LONG"FLOAT 

EMAX 

127 


LONGJFLOAT 

EPSILON 

16#0.4000 0000 0000 000#E-7 


approximately 

93132257461548E-31 ” 

LONG FLOAT 

SMALL 

16#0.8000 0000 0000 000#E-31 

“ 

approximately 

23509887416446E-38 “ 

LONG_FLOAT 

LARGE 

16#0J 7 FFF FFFF 0000 000#E+31 


approximately 

Z1267647922655E+37 ~ 

LONG_FLOAT 

FIRST 

-16#0.7FFF FFFF FF#E+32 


approximately 

-1.7014US346047E+38 

LONG_FLOAT 

LAST 

16#0.7FFF FFFF FF#E+32 


approximately 

1.7014118346047E+38 

LONG FLOAT 

SAFE EMAX 

127 

LONG_FLOAT 

safeTsmall 

16#0.1000 0000 0000 000#E-31 


approximately 

Z9387358770557E-39" 

LONG_FLOAT 

SAFE_LARGE 

16#0.7FFF FFFF 0000 000#E+32 


approximately 

1.7014118338124E"+ 38 ~ 

LONG FLOAT 

MACHINE RADIX 

2 

LONG'FLOAT 

MACHINE"MANTISSA 

40 

LONGJFLOAT 

MACMNE~EMAX 

127 

LONG~FLOAT 

MACHINE“EMIN 

-127 

LONG FLOAT 

MACHINE"ROUNDS 

TRUE 

LONG'FLOAT 

MACHINE”OVERFLOWS 

TRUE 

DURATION 

DELTA 

0.0001 

DURATION 

SMALL 

0.0001 

DURATION 

FIRST 

-86400.0 

DURATION 

LAST 

86400.0 


-57- 

DTX-3000 


MIL-STD-1815A APPENDIX F 





TEST PARAMETERS 


APPENDIX C 
TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, such 
as the maximum length of an input line and invalid file names. A test that 
makes use of such values is identified by the extension .TST in its file 
name. Actual values to be substituted are represented by names that begin 
with a dollar sign. A value must be substituted for each of these names 
before the test is run. The values used for this validation are given 
below. The use of the operator signifies a multiplication of the 
following character, and the use of the '&* character signifies 
concatenation of the preceeding and following strings. The values within 
single or double quotation marks are to highlight character or string 
values: 


Name and Meaning Value 

$ACC_SIZE 16 

An integer literal whose value 
is the number of bits sufficient 
to hold any value of an access 
type. 


$BIG_ID1 239 * 'A' & ’1' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID2 except 
for the last character. 


$BIG_ID2 239 * 'A' & '2' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID1 except 
for the last character. 

$BIG_ID3 120 * ’A’ & '3' & 119 * ’A’ 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID4 except 
for a character near the middle. 






TEST PARAMETERS 


Name and Meaning Value 

$BIG_ID4 120 * 'A' 4 '4* 4 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID3 except 
for a character near the middle. 


$BIG_INT_LIT 237 * 'O' 4 "298" 

An integer literal of value 298 
with enough leading zeroes so 
that it is the size of the 
maximum line length. 

$BIG_REAL_LIT 235 * 'O’ 4 "690. 

A universal real literal of 
value 690.0 with enough leading 
zeroes to be the size of the 
maximum line length. 


$BIG_STRING1 "" 4 120 * 'A' 4 

A string literal which when 

catenated with BIG_STRING2 
yields the image of 8IG_ID1. 

$BIG_STRING2 ’"' 4 119 * ’A' 

A string literal which when 
catenated to the end of 
BIG STRING1 yields the image of 
BIG ID1. 


SBLANKS 220 * ’ ' 

A sequence of blanks twenty 
characters less than the size 
of the maximum line length. 


$COUNT_LAST 

A universal integer 

literal whose value is 
TEXT_I0.COUNT'LAST. 

S DEFAULT_MEM_SIZE 

An integer literal whose value 
is SYSTEM.MEMORY_SIZE. 

$DEFAULT_STOR_UNIT 

An integer literal whose value 
is SYSTEM.STORAGE UNIT. 


32766 


65536 


16 


119 * ’A 1 


0 " 


' 1 ’ 4 "" 





TEST PARAMETERS 


Name and Meaning 

$def:.ult_sys_nams 

The value of the constant 
SYSTEM.SYSTEM NAME. 


$DELTA_DOC 

A real literal whose value is 
SYSTEM.FINE DELTA. 


SFIELDJLAST 

A universal integer 
literal whose value is 
TEXT 10.FIELD*LAST. 


$FIXED_NAME 

The name of a predefined 
fixed-point type other than 
DURATION. 

$FLOAT_NAME 

The name of a predefined 
floating-point type other than 
FLOAT, SH0RT_FL0AT, or 
LONG FLOAT. 


$GREATER_THANJDURATION 

A universal real literal that 
lies between DURATION * BASE * LAST 
and DURATION'LAST or any value 
in the range of DURATION. 

$GREATER_THAN_DURATION_BASE_LAST 

A universal real literal that is 
greater than DURATION*BASE'LAST. 

$HIGH_PRIORITY 

An integer literal whose value 
is the upper bound of the range 
for the subtype SYSTEM.PRIORITY. 

$ILLEGAL_EXTERNAL_FILE_NAME1 

An external file name which 
contains invalid characters. 


$ILLEGAL_EXTERNAL_FILE_NAME2 

An external file name which 
is too long. 


Value 

MIL_STD_1750A 

2§1.0#E-31 

20 

NO_SUCH_FIXED_TYPE 

N0_SUCH_FL0AT_TYPE 

90_000.0 

33 554_433.0 

200 

BAD.BAD.BAD 

ANOTHER.BAD.BAD 







Value 


Name and Meaning 
$INTEGER_FIRST 

A universal integer literal 

whose value is INTEGER'FIRST. 

$INTEGER_LAST 

A universal integer literal 

whose value is INTEGER'LAST. 

$INTEGER_LAST_PLUS_1 

A universal integer literal 

whose value is INTEGER'LAST + 1. 

$LESS_THAN_DURATION 

A universal real literal that 
lies between DURATION'BASE'FIRST 
and DURATION'FIRST or any value 
in the range of DURATION. 

$LESS_THANJDURATION_BASE_FIRST 

A universal real literal that is 
less than DURATION'BASE'FIRST. 

$LOW_PRIORITY 

An integer literal whose value 
is the lower bound of the range 
for the subtype SYSTEM.PRIORITY. 

$MANTIS SA_DOC 

An integer literal whose value 
is SYSTEM.MAX_MANTISSA. 

$MAX_DIGITS 

Maximum digits supported for 
floating-point types. 

$MAX_IN_LEN 

Maximum input line length 
permitted by the implementation. 

$MAX_INT 

A universal integer literal 
whose value is SYSTEM.MAX_INT. 

$MAX_INT_PLUS_1 

A universal integer literal 
whose value is SYSTEM.MAX INT+1. 


-32768 

32767 

32768 

-90_000.0 

—33_554_433.0 

10 

31 

9 

240 

2147483647 

2 147 483 648 





TEST PARAMETERS 


Name and Meaning Value 

$MAX_LEN_INT_BASED_LITERAL "2:" & 235 * 'O’ & "11:" 

A universal integer based 
literal whose value is 2#11# 
with enough leading zeroes in 
the mantissa to be MAX_IN_LEN 
long. 

$MAX_LEN_REAL_BASED_LITERAL "16:" & 233 * ’O’ & "F.E:" 

A universal real based literal 
whose value is 16:F.E: with 
enough leading zeroes in the 
mantissa to be MAX_IN_LEN long. 

$MAX_STRING_LITERAL "" & 238 * 'A' & "" 

A string literal of size 
MAX_IN_LEN, including the quote 
characters. 

$MIN_INT -2147483648 

A universal integer literal 
whose value is SYSTEM.MIN_INT. 

$MIN_TASK_SIZE 16 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
no entries, no declarations, and 
"NULL;" as the only statement in 
its body. 

$NAME NO_SUCH_INTEGER_TYPE 

A name of a predefined numeric 
type other than FLOAT, INTEGER, 

SHORT_FLOAT, SHORT_INTEGER, 

LONG_FLOAT, or LONG_INTEGER. 

$NAME_LIST MIL_STD_1750A 

A list of enumeration literals 
in the type SYSTEM.NAME, 

separated by commas. 

$NEG_BASED_INT 16#FFFFFFFE# 

A based integer literal whose 
highest order nonzero bit 

falls in the sign bit 
position of the representation 

for SYSTEM.MAX INT. 










TEST PARAMETERS 


Name and Meaning Value 

$NEW_MEM_SIZE 65536 

An integer literal whose value 
is a permitted argument for 
pragma MEMORY SIZE, other than 
$DEFAULT_MEM_SIZE. If there is 
no other value, then use 
$DEFAULT_MEM_SIZE. 

$NEV_STOR_UNIT 16 

An integer literal whose value 
is a permitted argument for 
pragma STORAGE_UNIT, other than 
$DEFAULT_STOR_UNIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGEJJNIT. 

$NEW_SYS_NAME MIL_STD_1750A 

A value of the type SYSTEM.NAME, 
other than $DEFAULT_SYS_NAME. If 
there is only one value of that 
type, then use that value. 

$TASK_SIZE 16 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
a single entry with one 'IN OUT' 
parameter. 

STICK 0.0001 

A real literal whose value is 
SYSTEM.TICK. 







WITHDRAWN TESTS 


APPENDIX D 
WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to the 
Ada Standard. The following 44 tests had been withdrawn at the time of 
validation testing for the reasons indicated. A reference of the form 
Al-ddddd is to an Ada Commentary. 


a. E28005C This test expects that the string "— TOP OF PAGE. 

63" of line 204 will appear at the top of the listing page due 
to a pragma PAGE in line 203; but line 203 contains text that 

follows the pragma, and it is this that must appear at the top 
of the page. 

b. A39005G This test unreasonably expects a component clause to 

pack an array component into a minimum size (line 30). 

c. B97102E This test contains an unitended illegality: a select 

statement contains a null statement at the place of a selective 
wait alternative (line 31). 

d. C97116A This test contains race conditions, and it assumes that 
guards are evaluated indivisibly. A conforming implementation 
may use interleaved execution in such a way that the evaluation 
of the guards at lines 50 & 54 and the execution of task CHANGING- 
_OF_THEjGUARD results in a call to REPORT.FAILED at one of 
lines 52 or 56. 

e. BC3009B This test wrongly expects that circular instantiations 
will be detected in several compilation units even though none of 
the units is illegal .with respect to the units it depends on; by 
AI-00256, the illegality need not be detected until execution is 
attempted (line 95). 

f. CD2A62D This test wrongly requires that an array object's size 
be no greater than 10 although its subtype's size was specified 
to be 40 (line 137). 






WITHDRAWN TESTS 


g. CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] These 
tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them 
to a derived subprogram (which implicitly converts them to the 
parent type (Ada standard 3.4:14)). Additionally, they use the 
'SIZE length clause and attribute, whose interpretation is 
considered problematic by the WG9 ARG. 

h. CD2A81G, CD2A83G, CD2A84N & M, & CD5011O [5 tests] These tests 

assume that dependent tasks will terminate while the main pro¬ 
gram executes a loop that simply tests for task termination; this 
is not the case, and the main program may loop indefinitely 
(lines 74, 85, 86 & 96, 86 & 96, and 58, resp.). 

i. CD2B15C & CD7205C These tests expect that a 'STORAGE_SIZE 
length clause provides precise control over the number of 
designated objects in a collection; the Ada standard 13.2:15 
allows that such control must not be expected. 

j. CD2D11B This test gives a SMALL representation clause for a 

derived fixed-point type (at line 30) that defines a set of 
model numbers that are not necessarily represented in the 
parent type; by Commentary AI-00099, all model numbers of a 
derived fixed-point type must be representable values of the 
parent type. 

k. CD5007B This test wrongly expects an implicitly declared sub¬ 

program to be at the the address that is specified for an un¬ 
related subprogram (line 303). 

l. ED7004B, ED7005C & D, ED7006C S D [5 tests] These tests check 

various aspects of the use of the three SYSTEM pragmas; the AVO 
withdraws these tests as being inappropriate for validation. 

m. CD7105A This test requires that successive calls to CALENDAR.- 

CLOCK change by at least SYSTEM.TICK; however, by Commentary 

AI-00201, it is only the expected frequency of change that must 
be at least SYSTEM.TICK—particular instances of change may be 
less (line 29). 

n. CD7203B, & CD7204B These tests use the 'SIZE length clause and 
attribute, whose interpretation is considered problematic by 
the WG9 ARG. 

o. CD7205D This test checks an invalid test objective: it treats 

the specification of storage to be reserved for a task's 
activation as though it were like the specification of storage 
for a collection. 









WITHDRAWN TESTS 


p. CE2107I This test requires that objects of two similar scalar 

types be distinguished when read from a file—DATAJERROR is 
expected to be raised by an attempt to read one object as of 
the other type. However, it is not clear exactly how the Ada 
standard 14.2.4:4 is to be interpreted; thus, this test objective 
is not considered valid, (line 90) 

q. CE3111C This test requires certain behavior, when two files are 

associated with the same external file, that is not required by 
the Ada standard. 

r. CE3301A This test contains several calls to END_OF_LINE & 

END_OF_PAGE that have no parameter: these calls were intended 
to specify a file, not to refer to STANDARD INPUT (lines 103, 
107, 118, 132, & 136). 

s. CE3411B This test requires that a text file's column number be 

set to COUNT'LAST in order to check that LAYOUT_ERROR is raised 
by a subsequent PUT operation. But the former operation will 

generally raise an exception due to a lack of available disk 

space, and the test would thus encumber validation testing. 







COMPILER AND LINKER OPTIONS 


APPENDIX E 

COMPILER AND LINKER OPTIONS 


No linker options exist for this implementation. This appendix 
contains information of the compiler options used in this 
validation. 








PSS, Inc. 


Ada Compiler Files 


PSS ADA COMPILER USER'S GUIDE 

1 November 1989 


The PSS Ada Compiler 

The PSS Ada Compiler translates a single source file and places 
the results of the compilation (object modules, date and tiW 
stamps, symbol information) in the Ada program library. 
Invocation of the PSS Ada Compiler must be from the directory 
where the PSS Ada library resides. However, the source file 
that is used as input to the PSS Ada Compiler may reside in a 
different directory. 


The PSS Ada Compiler creates and uses several files during 
the course of developing and maintaining Ada programs. F-a ch 
of these files has the name of the compilation unit with an 
extension indicating the purpose of the file. The PSS Ada 
Compiler generates files with the following extensions: 

.BOD Contains the representation of the body of a generic 
and the visibility information available to subunits. The 
PSS Ada Compiler reads this file when compiling a unit 
that instantiates a generic or is a subunit of another unit. 

X)I Contains the representation of a unit specification. The 
PSS Ada Compiler reads this file when compiling a unit 
that has a "with" clause. 

XIS Contains the listing of the source interspersed with any 
error and warning messages produced by the PSS Ada 
Compiler. 

.MLS Contains the machine language listing of the generated 
code. 

.OBJ Contains the object code for an Ada unit body. 

.SOBJ Contains object code for an Ada unit specification. 

The PSS Ada Librarian controls all of these files except the 
.LIS. and .MLS files. The user should not use these extensions 
for any other purpose, nor should any of these files be deleted 
by the user while the corresponding unit is still active in the 


-41- 

DTX-3000 


The PSS Ada Compiler 






PSS, Inc. 


PSS ADA COMPILER USER’S GUIDE 


1 November 1989 


Invoking the Compiler 


Program Library. To avoid unpredictable and erroneous results, 
do not delete, edit, rename or otherwise modify these files via 
VMS commands. Instead use the PSS Ada Librarian commands 
as described in the PSS Ada Library section to perform 
operations on library files. 

Several temporary files are created during compilation. Some 
of these files have unique names composed of hexadecimal 
numbers concatenated with the extensions listed above. Other 
temporary files have extensions .TER, .TEB, .TSB, and .TSE. 
Any of these temporary files that appear in the user’s directory 
as a result of an abnormally terminated compilation (or a system 
failure) should be deleted by the user. 

The PSS Ada Compiler is an executable program under VMS. 
To use the PSS Ada Compiler you give an invocation co mman d 
that specifies the name of an Ada source code file. Normally 
the PSS Ada Compiler invocation command is available system¬ 
wide. This is done at installation time by the System Manager, 
in the same manner that commonly used commands are usually 
defined in a VAX development environment. The syntax of the 
PSS Ada Compiler invocation command is: 

$ ADA1750/qualifier(s) flle_specificatIon/qualifler(s) 

where 

/qualifier(s) specifies the compilation options to be used 

file_specification specifies the name of the file containing the 
Ada source code to be compiled. This may be 
any legal VMS file specification, including a 
logical name. 

The Ada command is not order or column dependent You 
may use spaces between any of the parts of the command and 
you may place the qualifiers after the Ada command or after 
the file name. Following are examples of equivalent invocation 
commands to compile a module named "source_file" with 
options to suppress constraint checks and to produced machine 
code listing: 


-42- 

DTX-3000 


The PSS Ada Compiler 







PSS, Inc. 


PSS ADA COMPILER USER’S GUIDE 

1 November 1989 


$ ADA1750/SUPPRESS=CONSTRAlNT_CHECKS/LIST = MACHINE sourceJlle 

$ ADA1750 sourceJile/SUPPRESS=CONSTRAINT_CHECKS/LIST=MACHINE 

$ ADA1750 source_Gle /SUPPRESS=CONSTRAINT_CHECKS/UST=MACHINE 

$ ADA1750/SUPPRESS=CONSTRAINT_CHECKS source_fUe/UST*MACHINE 

$ ADA1750 /SUPPRESS=CONSTRAINTCHECKS sourceJile /UST=MACHINE 

You may also omit much of the text in commands. As long 
as a command option is unique it can be truncated. For 
example, the above commands could be simplified to: 

$ ADA1750 /SUP=C/LIS=M sourcejOle 

Note that if you use the qualifier ADA for our Ada source file 
name, this qualifier may be omitted when entering the source 
file name. For example, to compile the source file 
WARN AD A, one specifies: 


$ ADA1750/SUP=C/LIS=M WARN 


The PSS Ada Compiler accepts a maximum command string 
length of 240 characters. Command strings may continue on 
multiple lines by using the continuation character, the hyphen 
(-), as the last element on each line that is to be continued. 
Command line continuation can be useful when entering a very 
long command line, or when placing an Ada compilation 
command in a command procedure file. 

Compilation Options The PSS Ada Compiler has a variety of options that may be 

chosen by using q ualifi ers in the compiler command line. The 
text that follows describes each qualifier in detail All qualifiers 
but the /LINES q ualifi er make use of the prefix "NO” to effect 
the negative form of the option. For example, 
/NOCONSTRAlNT_CHECKS suppresses the generation of 
constraint checks. 


-43- 

DTX-3000 


The PSS Ada Compiler 



PSS, Inc. 


PSS ADA COMPILER USER’S GUIDE 

1 November 1989 


Some qualifiers are incompatible with certain other qualifiers. 
For example, /LINES=20 is incompatible with /NOUST. The 
PSS Ada Compiler will handle incompatible qualifiers by 
accepting the first valid qualifier and ignoring later, inconsistent 
qualifiers. 

Since the compilation command line is limited to 240 characters, 
abbreviation of qualifiers can help fit a compilation command 
onto one line. When command length is not a factor, it is better 
to spell out the qualifier names in full to yield more readable 
commands, particularly in command procedures. However, even 
if the command is abbreviated, the full nam e of the option will 
appear in any listings that are generated. 

The following table summarizes the PSS Ada Compiler 
command qualifiers, including applicable qualifier values, 
defaults, and incompatible qu alifi ers. 


ADA Command Une Qualifiers 


Qualifer <qualifer values> 

Default Incompatible 

Qualifiers Qualifiers 

/<NO>LIST»(SOURCE j ERRORS | ASSEMBLY | 
MACHINE | ALL) 

/LIST-ERRORS/NOLIST when 
/LIST 

/TARGET-(IEEE J MIL_STD) 

/TARGET—MI L_STD 

/<NO>OPTIMIZATION 

/OPTIMIZATION 

/<NO>SUPPRESS«(CONSTRAINT CHECKS ] /NOSUPPRESS 

STACK CHECKS! 

ELABORATION CHECKS j ALL) 


DTX-3000 


The PSS Ada Compiler 











PSS, Inc. 


PSS AOA COMPILER USER’S GUIDE 


1 November 1989 


The following paragraphs show the positive and negative forms 
of each qualifier for the PSS Ada Compiler command. The 
default forms are indicated by "(D)". 

/LIST* SOURCE 
/LIST* ERRORS (D) 

/LIST=ASSEMBLY 
/LIST=MACHINE 
/USTsALL 


/LIST= SOURCE produces a listing of the source text with line 
numbers prefixed to each source line. The list file produced has 
the same name as the source file but with a file type of .LIS. 


/LIST®ERRORS produces a listing of the source text as 
described for /LIST=SOURCE but only in the event that some 
error is detected by the PSS Ada Compiler. Since 
/LIST= ERRORS is the default condition, a compilation that 
has errors will generate a listing, but an error-free compilation 
will not generate a listing unless a listing has been specifically 
requested. 


/LIST=ASSEMBLY produces an assembly language source file 
in a format that can be input to the PSS 1750A Macro 
Assembler. This listing file has the same name as the source 
file but with a file type .MAR. This file is normally not 
produced as the PSS aide generator automatically generates 
machin e code without going through an assembler. 

/LIST» MACHINE produces a source file of the machine code 
generated by the PSS Ada Compiler in a format similar to the 
lis ting output of the PSS 1750A Macro Assembler including both 
the generated assembly code and the hexadecimal 
representation. The listing file that is produced has the same 
nam e as the source file but with a file type .MLS. Two options 
are available with respect to the type of listings that are 
produced. The co mman d /TARGET * IEEE will result in the 
operation codes that are known as the IEEE standard codes. 
The command /TARGET * MIL_STD will result in a listing that 
presents the MIL-STD-1750A operation codes. 


-45- 

DTX-3000 


The PSS Ada Compiler 







PSS, Inc. 


PSS ADA COMPILER USER'S GUIDE 


1 November 1969 


/LIST=ALL is the same as: 

/LIST= (SOURCEyASSEMBLY,MACHINE4£RRORS). 

Listing options may be combined. Examples of some listing 
options are: 

/LIST 

/LIST = SOURCE 

/LIST = ERRORS 

/LIST=MACHINE 

/LIST® (SOURCE>MACHINE) 

/UST= (ERRORS^SSEMBLY) 

/NOLIST 


/TARGET * IEEE 
/TARGET=MILSTD (D) 


/TARGET*IEEE will result in listings that use the IEFF. 
standard mnemonics for operation codes. 

/TAR GET * MIL STD will result in listings that use the MIL¬ 
STD- 1750A mnemonics for operation codes. Note that the 
generated machine code is the same whether the target is the 
I E EE or the MEL_STD option. It is simply a matter of user 
preference with respect to listings and assemblers. 

/OPTIMIZE (D) 

/NOOPTIMIZE 

/OPTIMIZE causes the PSS Ada Compiler to produce 
optimized code. This takes the place of the pragma for 
optimization. The PSS Ada Compiler produces code that has 
been optimized for both time and space. 


-46- 

DTX-3000 


The PSS Ada Compiler 






PSS, Inc. 


PSS ADA COMPILER USER'S GUIDE 

1 November 1989 


/SUPPRESS=CONSTRAINT CHECKS 
/SUPPRESS=ELABORATION CHECKS 
/SUPPRESS a STACK CHECKS 
/SUPPRESS*ALL 
/NOSUPPRESS (D) 

/SUPPRESS=CONSTRAINT CHECKS causes the PSS Ada 
Compiler to eliminate all checks performed to test for constraint 
errors. This compiler option is used where higher execution 
performance is necessary. 

/SUPPRESS=ELABORATION CHECKS causes the PSS Ada 
Compiler to eliminate all checks”performed during elaboration. 
This compiler option is used where elaboration order is 
specified by the user. 

/SUPPRESS a STACKCHECKS causes the PSS Ada Compiler 
to eliminate all checks* on the run-time stack. This compiler 
option is used where higher execution performance is necessary. 

/SUPPRESS ~ ALL has the same effect as combining every 
suppress option. It has the same effect as the expression: 

/SUPPRESS = (CONSTRAINT CHECKS, ELABORATION CHECKS, 
STACKCHECKS) 


-47- 

DTX-3000 


The PSS Ada Compiler 






