^n-A245 770 station page 


Form Approved 
OPMNo. 0704 0188 




lOur pw tMponM, including Ih* dm* lot roulowing Iratiuctlont, Marching aticllng dau iourcM galharing and mainaining iha data 
I burdan aatitnala or any Mhat aapad of thia colactlon of Motmatlon, including auggaaliona lor raducing diia burdan. to Waahingaxi 
aDanon Oavla Highway. Sulla 12M. Aringlon. VA iZStt-*X2. and to Iha Ollica cl imonnalion and RaguMory Aftaln. Offica d 


. winlt (Leave Blank) 


12. REPORT DATE 


3. REPORT TYPE AND DATES COVERED 

Final: 16 Nov 1991 to 01 June 1993 


4. TITLE AND SUBTITLE 

Rational, M68020/6are Cross-Development Facility. Version 7, RIOOO Series 300 
(Host) to Motorola 68020 in MVME 135 135 Board (Target). 901116W1.11083 


AUTHOR(S) 

Wright-Patterson AFB, Dayton, OH 
USA 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS<ES) 

Ada Validation Facility, Language Control Facility ASD/SCEL 
BkJg. 676. Rm 135 

Wright-Patterson AFB, Dayton, OH 45433 



e. PERFORMING ORGANIZATION 
REPORT NUMBER 

AVF-VSR-426-1290 


9. SPONSORING/MONITORING AGENCY NAME{S) AND ADDRESS(ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm 3E114 
Washington. D.C. 20301-3081 


10. SPONSORING/MONITORING AGENCY 
REPORT NUMBER 



13. ABSTRACT (Maximum 200 words) 

Rational, M68020/Bare Cross-Development Facility. Version 7, Wright-Patterson AFB. RIOOO Series 300 (Host) to 
Motorola 68020 in MVME 135 135 Board (Target). ACVC 1.11. 


92-03163 




14 SUBJECT TERMS 


Ada programming language, Ada Compiler Val. Summary Report. Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17 SECURITY CLASSIFICATION 
OF REPORT 

UNCLASSIFIED 


18. SECURITY CLASSIFICATION 

UNCLASSIFED 


19 SECURITY CLASSIFICATION 
OF ABSTRACT 
UNCLASSIFIED 


15. NUMBER OF PAGES 


16. PRICE CODE 


20. LIMITATION OF ABSTRACT 


NSN 7540-01-280-550 


Standard Form 298, (Rav. 2-89) 
Proscribed by ANSI Std. 239-128 















Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was conpleted on 16 November 1991. 

Compiler Name aind Version: M68020/Bare Cross-Development Facility, 

Version 7 

Host Computer System: RlOOO Series 300, 

Rational Environment Version D_12_24_0 

Target Computer System: Motorola 68020 in MVME 135 Board, Bare Machine 

Customer Agreement Number: 90-07-20-RAT 


See Section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 

901116W1.11083 is awarded to Rational. This certificate expires on 1 June 

1993. 

This report has been reviewed and is approved. 





Ada Validation Faci 
Steven P. Wilson 
Technical Director 



ity 


ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 



ilidaf^in''Organization 

Dire<qtor, C^imputer & Software Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 



la Joint Progr^ Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 







AVF Control Number; AVF-VSR-426-1290 

19 November 1991 
90-07-20-RAT 


Ada COMPILER 
VALIDATiai SUMMARY REPORT: 

Certificate Number: 901116W1.11083 
Rational 

M68020/Bare Cross-Development Facility, Version 7 
RlOOO Series 300 »> Motorola 68020 in MVME 135 Board 


Prepared By: 

Ada Validation Facility 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 



ey 










Certificate Information 


Hie following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on 16 November 1991. 


Compiler Name amd Version: 

Host Conputer System; 

Target Conputer System; 
Customer Agreement Number: 


M68020/Bare Cross-Development Facility, 

Version 7 

RlOOO Series 300, 

Rational Environment Version D_12_24_0 
Motorola 68720 in MVME 135 Board, Bare Machine 
90-07-20-RAT 


See Section 3.1 for einy additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 

901116W1.11083 is awarded to Rational. This certificate expires on 1 June 

1993. 

This report has been reviewed and is approved. 



la ValidatiOT Facility 
Steven P. Wilson 
Technical Director 


ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 



Direc 

InstitVite fc 
Alexcindria VA 


,- 

)rganization 

ter & Software Engineering Division 
fense Analyses 
22311 


Ada Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 




DECLARATION OF CONFORMANCE 


Customer: Rational 

Ada Validation Facility: ASD/SCEL, Wright-Patterson AFB OH 45433-6503 

ACVC Version: 1.11 


Ada Implementation 

Compiler Name: M68020/ Bare Cross-Development Facility, Version 7 

Host Architecture: RIOOO Series 300 

Host Operating System: Rational Environment Version D_12_24_0 

Target Architecture: Motorola 68020 in MVME 135 Board 

Target Operating System: Bare Machine 


Customer's Declaration 

I, the undersigned, representing Rational, declare that Rational has no knowledge of deliberate 
deviations from the Ada Language Standard .\NSI/MIL-STD-1815A in the implementation 
listed in this declaration. I declare that Rational is the owner of the above implementation and 
the certificates sh^l be awarded in the name of the owners corporate name. 



David H. Bernstein 

Vice President, Products Group 


Rational 

3320 Scott Blvd. 

Santa Clara, CA 95054 









TABLE OF CWTENTS 


CHAPTER 1 INTRODUCTION 

1.1 USE OF THIS VALIDATIC»J SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATICW DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIC»lS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 















CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro90] against the Ada Standard [Ada83] using the 
current Ada Compiler Validation Capability (ACVC). This Validation Summary 
Report (VSR) gives aui account of the testing of this Ada implementation. 

For any technical terms used in this report, the reader is referred to 
[Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide (UG891. 


1.1 USE OF THIS VALIDATION SUIDIARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the computers, operating systems, and compiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and conplete, or that the subject implementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF v^ich performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield '/A 22161 


Questions regarding this report or the validation test results should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


: -1 







INTRODUCTION 


1.2 REFERENCES 


[Ada83] Reference Manual for the Ada Programming Language, 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 


[Pro90] Ada Coitpiler Validation Procedures, Version 2.1, Ada Joint Program 
Office, August 1990. 


[UG89] Ada Compiler Validation Capeibility User's Guide, 21 Jxme 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: 

A, B, C, D, E, and L. The first letter of a test name identifies the class 
to which it belongs. Class A, C, D, and E tests are executable. Class B 
euid class L tests are expected to produce errors at compile time and link 
time, respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Tdentity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circxmivent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is conpiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 


1-2 





INTRODUCTION 


For each Ada inplementation, a customized test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragraph, removing withdrawn tests (see section 2.1) and, 
possibly some inapplicable tests (see Section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1..4 DEFINITION OF TERMS 


Ada Compiler The software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compiler The means for testing complieuice of Ada implementations. 
Validation consisting of the test suite, the support programs, the ACVC 
Capability user's guide and the tenplate for the validation summary 

(ACVC) report. 

Ada An Ada compiler with its host coitpater system and its 

Implementation target computer system. 

Ada Joint The part of the certification body ;diich provides policy and 
Program guidance for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification body vdiich carries out the 

Validation procedures required to establish the conpliance of an Ada 
Facility (AVF) implementation. 

Ada The part of the certification body that provides technical 

Validation guidance for operations of the Ada certification system. 

Organization 
(AVO) 

Compliance of The ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer A functional unit, consisting of one or more computers and 

System associated software, that uses common storage for all or 

part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 







INTRODUCTION 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 

ISO 

LRM 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


Fiilfillment by a product, process or service of all 
requirements specified. 

An individual or corporate entity who enters into an 
agreement with an AVF which specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

International Organization for Standardization. 

The Ada standard, or Language Reference Manual, published as 
ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRM take the form "<section>.<subsection>:<paragraph>." 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro90]. 

The process of checking the conformity of eui Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 







CHAPTER 2 

IMPLEMENTATICttJ DEPENDENCIES 


2.1 WITHDRii^ TESTS 

The following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is availcible from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 12 October 1990. 


E28005C 

B28006C 

C34006D 

B41308B 

C43004A 

C45114A 

C45346A 

C45612B 

C45651A 

C46022A 

B49008A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

B85001L 

C83026A 

C83041A 

C97116A 

C98003E 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CnA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119E 

CE2205B 

CE2405A 

CE3111C 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 





2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant 
for a given Ada inplementation. Reasons for a test's inapplicability may 
be supported by documents issued by ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 





IMPLEMENTATION DEPENDENCIES 


The following 201 tests have floating-point type declarations requiring 
more digits than SYSTEM.MAX_DIGITS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C'i5521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


The following 21 tests checic for the predefined type LONG_INTEGER; 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45612C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001W 

C86006C 


CD7101F 


C35702A, C35713B, C45423B, B86001T, and C86006H check for the predefined 
type SHORT_FLOAT. 

C35713D and B86001Z check for a oredefined floating-point type with a 
name other than FLOAT, LONG FLOAT, or SHORT FLOAT. 


C45531M..P and C45532M..? (8 tests) check fixed-point operations for 
types that requi.'e a SYSTEM.r'^AX_:1A^msSA of 47 or greater; for this 
implementation, MAX_MANTISSA is less than 47. 

C45624A checks that the proper exception is raised if f'ACHINE_OVERFLOWS 
is FALSE for floating point types with digits 5. For this 
implementation, MACHINE_OVERFLCNS is TRUE. 

C45624B checks that the proper exception is raised if MACHINE_OVERFLOWS 
is FALSE for floating point types with digits 6. For this 
implementation, MACHINE_OVERFLCTvS is TRUE. 

B86001Y checks for a predefined fixed-point type other than DURATION. 

C96005B checks for values of type DURATION'BASE that are outside the 
range of DURATION. There are no such values for this implementation. 


CD1009C uses a representation clause spoolf'/ing a non-default size for a 
floating-point type. 


CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use representation 
clauses specifying non-default sizes for access types. 










IMPLEMENTATION DEPENDENCIES 


CD2B15B checks that STORAGE ERROR is raised when the storage size 
specified for a collection Ts too small to hold a single value of the 
designated type; this implementation allocates more space than was 
specified by the length clause, as allowed by AI-00558. 

BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code 
insertions. 


AE2101H, EE2401D, and EE2401G use instantiations of package DIRECT_IO 
with unconstrained array types and record types with discriminants 
without defaults. These instantiations are rejected by this compiler. 


The following 

265 tests check for 

sequential, 

text 

, and direct access 

files: 








CE2102A..C 

(3) 

CE2102G..H 

(2) 

CE2102K 


CE2102N..Y 

(12) 

CE2103C..D 

(2) 

CE2104A..D 

(4) 

CE2105A..B 

(2) 

CE2106A..B 

(2) 

CE2107A..H 

(8) 

CE2107L 


CE2108A..H 

(8) 

CE2109A..C 

(3) 

CE2110A..D 

(4) 

CE2111A..1 

(9) 

CE2115A..B 

(2) 

CE2120A. .B 

(2) 

CE2201A..C 

(3) 

EE2201D..E 

(2) 

C:E2201F. .N 

(9) 

CE2203A 


CE2204A..D 

(4) 

CE2205A 


CE2206A 


CE2208B 


CE2401A..C 

(3) 

EE2401D 


CE2401E..F 

(2) 

EE2401G 


CE2401H..L 

(5) 

CE2403A 


CE2404A..B 

(2) 

CE2405B 


CE2406A 


CE2407A..B 

(2) 

CE2408A. .B 

(2) 

CE2409A..B 

(2) 

CE2410A. .B 

(2) 

CE2411A 


CE3102A..C 

(3) 

C:E3102F. .H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A. .C 

(3) 

C:E3106A. .B 

(2) 

CE3107B 


CE3108A..B 

(2) 

CE3109A 


CE3110A 


CE3111A. .B 

(2) 

CE3111D..E 

(2) 

CE3112A..D 

(4) 

CE3114A..B 

(2) 

CE3115A 


CE3116A 


CE3119A 


EE3203A 


EE3204A 


CE3207A 


CE3208A 


CE3301A 


EE3301B 


CE3302A 


CE3304A 


CE3305A 


CE3401A 


C:E3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A. .C 

(3) 

CE3403E..F 

(2) 

CE3404B..D 

(3) 

CE3405A 


EE3405B 


CE3405C..D 

(2) 

CE3406A..D 

(4) 

CE3407A..C 

(3) 

CE3408A. .C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE3410C..E 

(3) 

EE3410F 


c::e3411a 


CE3411C 


CE3412A 


EE3412C 


CE3413A..C 

(3) 

CE3414A 


CE3602A..D 

(4) 

CE3603A 


CE3604A..B 

(2) 

CE3605A. .E 

(5) 

CE3606A. .B 

(2) 

CE3704A..F 

(6) 

CE3704M..0 

(3) 

CE3705A. .E 

(5) 

CE3706D 


CE3706F..G 

(2) 

CE3804A..P 

(16) 

CE3805A. .B 

(2) 

CE3806A. .B 

(2) 

CE3806D..E 

(2) 

CE3806G..H 

(2) 

CE3904A. .B 

(2) 

CE3905A..C 

(3) 

CE3905L 


c:e3906a. .C 

(3) 


CE3906E..F (2) 

CE2103A, CE2103B, and CE3107A use an illegal file name in an attempt to 
create a file and expect NAME_ERROR to be raised; this implementation 
does not support external files and so raises USE_ERROR. (See section 
2.3.) 


2-3 







implementation dependencies 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 102 tests. 


The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the way 
expected by the original tests. 


B22003A 

B22003B 

B22004A 

B22004B 

B22004C 

B23002A 

B23004A 

B23004B 

B24001A 

B24001B 

B24001C 

B24005A 

B24005B 

B24007A 

B24009A 

B24204B 

B24204C 

B24204D 

B25002B 

B26001A 

B26002A 

B26005A 

B28003A 

B28003C 

B29001A 

B2A003B 

B2A003C 

B2A003D 

B2A007A 

B32103A 

B33201B 

B33202B 

B33203B 

B33301A 

B33301B 

B35101A 

B36002A 

B37106A 

B37205A 

B37307B 

B38003A 

B38003B 

B38009A 

B38009B 

B41201A 

B44C01A 

B44004A 

B44004B 

B44004C 

B44004D 

B44004E 

B45205A 

B48002A 

B48002D 

B53003A 

B55A01A 

B56001A 

B6300LA 

B630C^B 

B64001B 

B64006A 

B67001A 

B67001B 

B67001C 

B67001D 

B67001H 

B71001A 

B71001G 

B7100lri 

B74003A 

B74307B 

B83E01C 

B83E01D 

B83E01E 

B91001F 

B91001H 

B91003E 

B95001D 

B95003A 

B95004A 

B95006A 

B95007B 

B95079A 

BAIOOIB 

BB3005A 

BC1109A 

BC1109B 

BC1109C 

BC1109D 

BC1303F 

BC2001D 

BC2001E 

BC3003A 

BC3003B 

BC3005B 

BC3013A 

BE2210A 

BE2413A 

B51001A 





CE2103A, CE2103B, cind CE3107A were graded inapplicable by Evaluation 
Modification as directed by the AVO. The tests abort with an 
unhandled exception vrtien USE_ERROR is raised on the attempt to create 
an external file. This is acceptable behavior because this 
implementation does not support external files (cf. AI-00332). 


2-4 




CHAPTER 3 


PRCXTESSING INFORMATION 


3,1 TESTING ENVIRONMENT 

The Ada inplementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact for technical information about this Ada 
implementation system, see: 

David H. Bernstein 
3320 Scott Blvd. 

Santa Clara CA 95054 

For a point of contact for sales information about this Ada implementation 
system, see: 


David H. Bernstein 
3320 Scott Blvd. 
Santa Clara CA 95054 


Testing of this Ada implementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


a) Total Number of Appliceible Tests 3565 

b) Total Number of Withdrawn Tests 81 


3-1 




PROCESSING INFORMATION 


c) 

Processed Inapplicable Tests 

58 


d) 

Non-Processed I/O Tests 

265 


e) 

Non-Processed Floating-Point 




Precision Tests 

201 


f) 

Total Number of Inapplicable Tests 

524 

(c+d+e) 

g) 

Total Number of Tests for ACVC 1.11 

4170 

(a+b+f) 


The above number of I/O tests were not processed because this 
implementation does not support a file system. The above number of 
floating-point tests were not processed because they used floating-point 
precision exceeding that supported by the implementation. When this 
compiler was tested, the tests listed in section 2.1 had been withdrawn 
because of test errors. 


3.3 TEST EXECUTION 

Version 1.11 of the ACVC comprises 4170 tests. When this compiler was 
tested, the tests listed in section 2.1 had been withdrawn because of test 
errors. The AVF determined that 524 tests were inapplicable to this 
implementation. All inapplicable tests were processed during validation 
testing except for 201 executable tests that use floating-point precision 
exceeding that supported by the implementation and 265 executable tests 
that use file operations not supported by the implementation. In addition, 
the modified tests mentioned in section 2.3 were also processed. 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the validation team for processing. The contents of the 
magnetic tape were loaded directly onto the host computer. 


After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada implementation. 


The tests were compiled and linked on the host computer system, as 
appropriate. The executable images were transferred to the target computer 
system via FTP, and run. The results were captured on the host computer 
system. 


Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a complete listing of 
the processing options for this implementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were: 




PROCESSING INFORMATICS 


Option I Switch Effect 

Create_Subprogram_Specs - False When a library unit subprogram body is added 

to the program library, do not automatically 
create a corresponding subprogram 
specification. 

Linker_Command_File = " !VALIDATION.A(::VC_1_11.MC68020_BARE.MISCELLANY. 

MODIFIED_LINKER_COMMANDS" 

Overrides the default linker command file 
with one that specifies inclusion of 
assembly language modules needed for pragma 
interface tests. 


Test output, compiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 


3-3 



APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string aggregates, where "V" represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$BIG_ID1 (1..V-1 => 'A', V => '1') 

$BIG_ID2 (1..V-1 => 'A', V => '2') 

$BIG_ID3 (1..V/2 => 'A') & '3' & 

(1..V-1-V/2 => 'A') 

$BIG_ID4 (1..V/2 => 'A') & '4' & 

(1..V-1-V/2 => 'A') 

$BIG_INT_LIT (1..V-3 => '0') & "298" 

$BIG_REAL_LIT (1..V-5 => '0') & "690.0" 

$BIG_STRING1 & (1..V/2 => 'A') & 

$BIG_STRING2 & (1..V-1-V/2 => 'A') & '1' & 

$BLANKS (1..V-20 => ' ’) 

$MAX_LEN_INT_BASED_LITERAL 

"2:” & (1..V-5 => '0') & "11:" 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => '0') & "F.E:" 

$MAX STRING LITERAL & (1..V-2 => 'A') & 


A-1 







MACRO PARAMETERS 


The following table lists all of the other macro parameters and their 
respective values. 

Macro Parameter Macro Value 


$MAX_IN_LEN 

254 


$ACC_SIZE 

32 


SALIQJMENT 

1 


$COUNT_LAST 

1000000000 


$DEFAULT MEM_SIZE 

2147483647 


$DEFAULT_STOR_UNIT 

8 


$DEFAULT_SyS_NAME 

MC68020_BARE 


$DELTA_DOC 

0.0000000004656612873077392578125 

$ENTRY_ADDRESS 

SYSTEM.TO_ADDRESS 

(16#200#) 

$ENTRY_ADDRESS1 

SYSTEM.TO_ADDRESS 

(16#201#) 

$ENTRY_ADDRESS2 

SYSTEM.TO_ADDRESS 

(16#202#) 

$FIELD_LAST 

2147483647 


$FILE TERMINATOR 

9 9 


$FIXED_NAME 

NO_SUCH_TYPE 


$FLOAT_NAME 

rro_SUCH_TYPE 


$FORM_STRING 

fl M 


$FORM_STRING2 

"CANNOT_RESTRICT_ 

FILE_CAPACITY" 

SGREATER THAN DURATION 



1.0 

$GREATER THAN DURATION BASE LAST 

T31071.0 

SGREATER THAN FLOAT_BASE_LAST 

2.0E308 

$GREATER THAN FLOAT SAFE LARGE 

2#11111111111111111.1111111#E111 


A-2 





MACRO PARAMETERS 


$GREATER_THAN_SHORT_FLClAT_SAFE_LARGE 

1.0E308 

$HIGH_PRIORITY 255 

$ILLEGAL_EXTERNAL_FILE_NAME1 

BAD_CHARACTERS& <>- 

$iLLEGAL_EXTERNAL_FILE_NAME2 

CONTAINSJWILDCARDS* 

$INAPPROPRIATE_LINE_LEMGTH 

-1 

$INAPPROPRLATE_PAGE_LENGTH 

-1 

$INCLUDE_PRAGMA1 PRAG’IA INCLUDE ( "A28006D1 .TST" ) 

$INCLUDE_PRAGMA2 PRAGTIA INCLUDE ("B28006F1.TST") 

$INTEGER_FIRST -2147483648 

$INTEGER_LAST 2147483647 

$INTEGER_LAST_PLUS_1 2147483648 

SINTERFACE_LANGUAGE ASM 

$LESS_THAN_DURATION -1.0 

$LESS THAN DURATION_BASE_FIRST 

-131073.0 

$LINE_TERMINATOR ASCII.CR 

$LOW_PRIORITY 0 

$MACHINE_CODE_STATEMENT 

NULL; 

$MACHINE_CODE_TYPE NULL 

$MANTISSA_DOC 31 

$MAX_DIGITS 15 

$MAX_INT 2147483647 

$MAX_INT_PLUS_1 2147483648 


$MIN INT 


-2147483648 



macro parameters 


$NAME 

SHORT_SHORT_INTEGER 


$NAME_LIST 

MC68020_BARE 


$NAME_SPECIFICATIONl 

X2120A 


$NAME_SPECIFICATiaJ2 

X2120B 


$NAME_5PECIFICATION3 

X3119A 


$NEG_aASED_INT 

16#FFFFFFFE# 


$NEW_MEM_SIZE 

2147483647 


$NEW_STOR_UNIT 

8 


$NEW_SYS_NAME 

MC68020_BARE 


$PAGE_TERMINATOR 

ASCII.FF 


$RECORD_DEFINITION 

NEW INTEGER 


$RECORD_NAME 

NO SUCH_MACHINE_CODE_TYPE 


$TASK_SI2E 

32 


$TASK_STORAGE_SI2E 

4096 


$TICK 

l.OOOOOOOOOOOOOOE-03 


$VARIABLE_ADDRESS 

SYSTEM.TO_ADDRESS (16#00DC#) 


$VARIABLE_ADDRESS1 

SYSTEM.TO_ADDRESS (16#011C#) 


$VARIABLE_ADDRESS2 

SYSTEM.TO_ADDRESS (16 # 0IBC#) 


$YOUR_PRAGMA 

NICKNAME 



A-4 








APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler eind linker options of this Ada implementation, as described in - 
this Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 

PROCESSOR SWITCH TYPE VALUE 

Cross_Cg . Asm_Source : Boolean := False 

— Controls retention of assembly source code generated by the compiler. 

Cross_Cg . Auto Download : Boolean := True 

— Controls whetEer the result of partially linking a main program is 

— automatically downloaded to the target machine, using FTP switches to 

— determine the destination. Applies only to targets that have a final 

— link step on the target machine. 

Directory . Create_Internal Links : Boolean := True 

— Controls whether internal links are created automatically when the 

— visible parts of library units are created. Internal links for library 

— units are created in the set of links for the nearest enclosing world. 

— The default is True. The full switch name is 

— Directory.Create_Internal_Links. (For further information on links, see 

— the Key Concepts section of the Library Management (LM) Reference 

— Manual.) . 

* Directory . Create_Subprogram_Specs ; Boolean := False 

— Controls vdiether specifications for library-unit subprograms are created 

— automatically. The contents of these specifications are created the 

— first time the body is successfully installed. The "with" clause for 

— the specification is derived from the "with" clauses in the body. Only 

— those "with" clauses required to promote the specification are included. 

— The default is True. The full switch name is 

— Directory.Create_Subprogram_Spec3. 

Cross_Cg . Debugging_Level : Debug_Level := Full 

— Cross_Cg.Debugging Level controls the amount of debugging assistance put 

— into the object mo3ule when coding an Ada unit. 

— The possible values are: 


B-1 








COMPILATION SYSTEM OPTIONS 


— None : (Default) No debugging infonnation produced. 

— Partial : Debugging tables produced but optimizations are not 

— inhibited. 

— Full : Debugging tables produced, and optimizations inhibited. 

— "Optimizations inhibited" means that code motion across statement 

— boundaries will not occur, eind the lifetimes of variables will not be 

— reduced. 

Cross_Cg . Enable_Code Pooling : Boolean ;= False 

— When true, optimizatTons vdiich woxild prevent link time code pooling are 

— inhibited. Link time code pooling is only attempted on units that were 

— compiled with this switch set to True. 

Cross_Cg . Inlining_Level : Inlining_Level := Inter__Uni 

— Cross_Cg.Inlining_Level determines how the compiler treats Pragma 

— Inline. 

— The possible values are: 

— None : Ignore pragma Inline. 

— Intra_Unit ; Honor pragma Inline within a compilation unit, but ignore 

— pragma Inline applied to subprograms in other conpilation units (thus 

— avoiding introduction of additional compilation dependencies). 

— Inter_Unit : (Default) Honor all Inline pragmas. 

— Full : Honor all Inline pragmas, and additionally perform 

— automatic inlining of small subprograms within a compilation unit. 

Cross_Cg . Linker_Command_File : String := 

"(VALIDATION.ACVC_1_11.MC68020_BARE.MISCELLANY.MODIFIED_LINKER COMMANDS" 

— Cross_Cg.Linker Command File overrides the default file name Tot the 

— linker command Tile. THe name of the linker command file is resolved in 

— the context of the current switch file. 

Cross_Cg . Linker_Cross_Reference : Boolean := False 

— Cross_Cg.Linker_Cross_Reference controls whether a cross-reference of 

— external symbols to modules being linked is produced in the link map. 

Cross_Cg . Linker_Eliminate_Dead_Code : Boolean := True 

— Cross_Cg.Linker_Eliminate_Dead Code controls whether the linker removes 

— unreachable subprograms from tEe executable program image. 

Cross_Cg . Linker_Pool_Code : Boolean := False 

— Controls whether the linker eliminates redundant subprograms from the 

— executable prograim image. Rediindant subprograms are those that are 

— reachable from the main program but whose code is identical to that of 

— some other subprogram in the program. Only comp units that were 

— compiled with the switch Enable_Code_Pooling set to True are eligible 

— for code pooling at link time. 

Cross_Cg . Linker_Pool_Literals : Boolecin := True 

— Controls whether the linker eliminates redundant literals from the 

— executable program image. 


B-2 




COMPILATION SYSTEM OPTIONS 


Cross_Cg . Listing : Boolean False 

— Controls generation of machine code listing file. 

Cross_Cg . Optimization_Level : Integer range 0 .. 3 := 3 

— Cross_Cg.Optimization_Level controls the amoxant of optimization 

— performed during code generation. 

— The possible values are: 

— 0 : Minimal Optimization 

— 1 : Uninplemented 

— 2 : Unimplemehted 

— 3 : Maximal Optimization. 

Directory . Require_Internal_Links : Boolean := True 

— Controls whether failure to create internal links (as controlled by the - 

— Directory.Create_Internal Links switch) generates an error. The default 

— (True) is to treat the failure to generate links as an error and to 

— discontinue the operation. If the Directory.Create_Internal_Links 

— switch is set to False, this switch has no effect. The full switch name 

— is Directory.Require_lnternal_Links. 

Cross_Cg . Suppress_All Checks : Boolean := False 

— When true, this switcH has the same effect as a pragma Suppress_All at 

— the beginning of the each Ada unit in the library. 

Cross_Cg . Target_Linker_Script : String :* "" 

— Cross_Cg.Target_Linker Script overrides the default file name for the 

— target linker script file. This name of this file is resolved in the 

— context of the current switch file. This switch applies only to targets 

— having a final link step on the target machine. 


B-3 








APPENDIX C 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-de^naent 
characteristics of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this Appendix are to conpiler documentation and not to mis 
report, implementation-specific portions of the package STANDARD, which 
are not a part of Appendix F, are; 


package STANDARD is 


type Integer is range -2147483648 .. 2147483647; 
type Short_Short_Integer is range -128 .. 127; 
type Short_Integer is range -32768 .. 32767; 


type 


Float is digits 6 


range -16#1.FFFF_FE# * 2.0 ** 127 .. 

16#1.FFFF FE# * 2.0 ** 127; 


type Long Float is digits 15 range 

~ -16#1.FFFF_FFFF_FFFF_F# * 2.0 ** 1023 .. 
16#1.FFFF FFFF FFFF_F# * 2.0 ** 1023; 


type 


Duration is delta 16#1.0# * 2.0 ** (-14) 
range -16#1.0# * 2.0 ** 17 
16#1.FFFF FFFC# * 


2^0 


it-k 


16; 


end STANDARD; 


C-1 





Appendix IV; Appendix F to the LRM 

for the M68020/Bare Target 


Appendix F describes the implementation-dependent features of the Ada language, as id is 
implemented for the M68020/Bare target. If you are using a CDF to compile programs for other 
targets, refer to the Appendix F that is provided with the documentation for that CDF. If you are 
compiling programs for an RIOOO target, refer to the Appendix F for the RIOOO target. 

Appendix F is a required part of the Reference Manual for the Ada Programming Language (LRM) 
and is divided into the sections listed below; 

• “Implementation-Dependent Pragmas" describes the form, allowed places, and effect of every 
implementation-dependent pragma. 

• “Implementation-Dependent Attributes" describes the name and type of every 

implementation-dependent attribute. 

• “Packages Standard and System" presents the specifications of packages Standard and System. 

• “Support for Representation Clauses" lists all of the restrictions on representation clauses. 

• “Implementation-Generated Names" describes the conventions used for any 

implementation-generated name denoting implementation-dependent components of records. 

• “Address Clauses" describes the interpretation of expressions that appear in address clauses, 
including those for interrupts. 

• “Unchecked Programming" describes any restrictions on unchecked conversions and 

deallocations. 

• “Input/Output Packages" describes implementation-dependent characteristics of the 

inpuUoutput packages. 

• “Other Implementation-Dependent Features" describes implementation-dependent features not 
covered in the previous sections. 


RATIONAL 


9 / 28/90 


3 







Appendix F 


IMPLEMENTATION-DEPENDENT PRAGMAS 

The CDF accepts the pragmas defined in Annex B of the LRM, as well as a number of additional 
pragmas to be used in application software development. The first of the following subsections 
lists clarifications and restrictions for the pragmas defined in Annex B. 

For each of the pragmas defined for the M68020 Family CDF, the following subsections describe 
the extent to which it is supported for the M6S020/Bare target. Support for these pragmas may 
differ for other targets. Information about the pragmas that are supported for each target is given 
in the CDF manual for that target. 

Pragmas Defined in Annex B 

For each of the pragmas defined in Annex 3 of the LRM, Table IV-1 describes the extent to which 
it is supported for the M68020 family target. Support for these pragmas may differ for other 
targets. 


Table IV-1 Predefined Pragmas 


Pragma 

Effect 

Controlled 

Always implicity in effect because the implementation does not 
support automatic ga.-bsge collection. 

-- 

Elaborate 

As given in Annex B .4 the LRM. 

Inline 

As given in Annex 3 o f the LRM, subject to the setting of the 
switch Inlining_Leve!. 

Interface 

Used in conjunction 'viih pragmas Import_Procedure, 
Import_Valued_Proe: ;-re, and Import_Function. 

List 

As given in Annex 3 ■ e 'he LRM; evident only when the Compile 
command is used. 

Memory_Size 

The pragma has no oo'cct. 

Optimize 

Has no effect. 

Pack 

Removes gaps in .storage, minimizing space with possible increase 
in access time. See tr .e Size of Objects’ subsection in the 
“Support for Representation Clauses” section. 

Page 

As given in Annex 3 'f the LRM; evident only when the Compile 
command is used. 

Priority 

As given in Annex 3 f the LRM. 

Shared 

As given in Annex 3 tf the LRM; has an effea only for integer, 
enumeration, access, ind fixed types. 

Storage_Unit 

Has no effect. 

Suppress 

As given in Annex 3 f the LRM. 

System_Name 

Has no effect. (There :s only one enumeration literal in the type 
System. Systcm_Name 


4 


9/28/90 


RATIONAL 




Appendix IV: Appendix F for the M68020/Bare Target 


Pragma Export_Elaboration_Procedure 

Makes the elaboration procedure for a given compilation unit available to external code by 
defining a global symbolic name. 

Format 

Pragma Export_Blaboration_Procedure ( Extemal_ilama *> "exteriial_naine" ); 
Description 

The elaboration procedure is otherwise unnameable by the user. Its use is confined to the 
exceptional circumstances where an Ada module is not elaborated because it is not in the closure 
of the main program or the main program is not an Ada program. This pragma is rjot 
recommended for use in application programs unless the user has a thorough understanding of 
elaboration, runtime, and storage-model considerations. 

Pragma Export_Elaboration_Procedure must appear immediately following the compilation unit. 
The external name is a string literal. 

Pragmas Export_Object and Import_Object 

Imports or exports objects from an Ada unit. 

Format 

pragma object_j>ragma__type 

( Internal => intemel_identifier, 

External => "external naae" ) 


Description 

The Import_Object pragma causes an Ada name to reference storage declared and allocated in 
some external (non-Ada) object module. The Export_Objea pragma provides an object declared 
within an Ada unit with an external symbolic name that the linker can use to allow another 
program to access the object. It is the responsibility of the programmer to ensure that the internal 
structure of the object and the assumptions made by the importing code and data structures 
correspond. The cross-compiler cannot check for such correspondence. 

Note: The object to be imported or exported must be a variable declared at the outermost level of a 
librarypackage pecification or body. We pragmas must be in the same declarative part as 
the variable. 

The size of the object must be static. Thus, the type of the object must be one of: 

• A scalar type (or subtype) 

• An array subtype with static index constraints whose component size is static 

• A nondiscriminated record type or subtype 


RATIONAL 


9/28/90 


5 







Appendix F 


Objects of a private or limited private type can be imported or exported only into the package 
that declares the type. 

An imported object cannot have an initial value and thus cannot be: 

• Declared with the keyword constant 

• An access type 

• A record type with discriminants 

• A record type whose components have default initial expressions 

• A record or array whose components contain access types or task types 

In addition, the object must not be in a generic uniL The external name specified mtjst be 
suitable as an identifier in the assembler. 

Parameters 

• object__pragma_type: Valid values are either Import_Object or Export_Object. 

• Internal => intBrnal_identifier: Specifies the Ada Gntemal) name of the object This 
parameter is required. 

• External => "extarnal_naine Specifies the external symbolic name of the objea. This 
parameter is optional; if not specified, die internal name is used. 

Pragmas to Import and Export Funciions and Procedures 

Allows Ada subprograms to be used by non- \oa routines, and vice-versa. 

Format 

pragma interface_type 

( Internal => interaal_nanie, 

External => external_name, 

Paramec 2 r_rypes => paranieter_type_li3t, 
Result_T’'pe => type_jnarJt, 

Nic)tnair.a => "nicJuiaae”, 

Mechanism =:> mecbanism_list, 

Language => language__naae ); 

Parameters 

• interfaceJype: Valid values are: 

— Import_Procedure 

— Import_Function 

— lmport_Valued_Procedure 

— Export_Procedure 

— Export_Function 

6 


9/28/90 


RATIONAL 



Appendix IV: Appendix F for the M68020/Bare Target 


• Internal => intBm»l_aaiam’. Designate the Ada name of the subprogram being 
interfaced. The internal name can be either an identifier or a string literal. If more than one 
subprogram is in the declarative region preceding the exporting pragma, the correct 
subprogram must be identified by either using the Parameter_Types (and Result_Type, if a 
function) or specifying the nickname with pragma Nickname and the Nickr.ame argument or 
both. 

• External *> mxtamMl_naiaa: Specifies the name to be used by the assembler. This is a 
character string that is an identifier suitable for the M68020/Bare assembler. If the external 
designator is not specified, the internal name is used. 

• parainatar_Types *> par*aatBr_typa_liat'. Distinguishes among two or more 
overloaded subprograms having the same internal name. The value of the Parameter_Types 
argument is a list of type or subtype names separated by commas and enclosed in parentheses. 
Each name corresp>on^ positionally to a formal parameter in the subprogram’s declarationi If 
the subprogram has no parameters, the list consists of the single word Null. 

• Rasult_Type => typajaark-. Specifies the type returned by the function. The Result_Type 
argument serves the same purpose for the return values of functions as the Parameter_Type 
argument serves for the parameter list. 

• Nicknama -> "nlduiaina": See pragma Nickname. 

• Machanism => ioachanlsm__liat: Specifies, in a parenthesized list, the passing mechanism 
for each parameter to be passed. The Mechanism argument is required if an imported 
subprogram has any parameters; it cannot be used for an exported subprogram. A mechanism 
must be specified for each parameter listed in parainater__typa8 and they must correspond 
positionally. The types of mechanism are as follows: 

— Value: Specifies that the parameter is passed on the stack by value. 

— Reference: Specifies that the address of the parameter is passed on the stack. 

For functions, it is not possible to specify the passing mechanism of the function result; the 
standard Ada mechanism for the given type of the function result must be used by the 
interfaced subprogram. If there are parameters, and if they all use the same passing 
mechanism, an alternate form for the Mechanism argument can be used: instead of a 
parenthesized list with an element for each parameter, the single mechanism name (not 
parenthesized) can be used. 

• Languaga *> langxjage_name: Specifies the name of the language to which the subprogram 
is being exported for the sole purpose of controlling the manner in which parameters are 
popped from the stack. The Language argument is optional for exporting routines and cannot 
be used for importing routines. Any language identifier other than C is ignored. If the language 
is C, or if the subprogram has copy-back parameters Cin-out and out scalars and access types), 
then the exported subprogram will not pop its parameters; otherwise it will. 

Exporting Subprograms 

A subprogram written in Ada can be made accessible to code written in another language by 

using an exporting pragma defined by the M68020 family cross-compiler. The effect of such a 

pragma is to give the subprogram a global symbolic name that the linker can use when resolving 

references between object modules. 

Exporting pragmas can be applied only to nongeneric procedures and funaions. 

RATIONAL 9/28/90 7 






Appendix F 


An exporting pragma can be given only for a subprogram that is a library unit or that is declared 
in the specification of a library package. An exporting pragma can be placed after a subprogram 
body only if the subprogram does not have a separate specification; if it has a separate 
specification, the pragma must go there. 

Importing Subprograms 

A .subprogram written in another language (typically, assembly language) can be called from an 
Ada program if it is declared with a pragma Interface. Every interfaced subprogram must have an 
importing pragma that is recognized by the M68020 family cross-compiler— either 
Import_Procedure, Impoft_Valued_Procedure, or Import_Function. These pragmas are used to 
declare the external name of the subprogram and the parameter-passing mechanism for the 
subprogram call. If an interfaced subprogram does not have an importing pragma, or if the 
importing pragma is incorrect, pragma Interface is ignored. 

Importing pragmas can be applied only to nongeneric procedures and functions. 

Import_Procedure calls a non-Ada procedure; lmport_Function, a non-Ada function; and 
Import_Valued_Procedure, a non-Ada function containing the equivalent of out or in out 
parameters. 

Each import pragma must be preceded by a pragma Interface; otherwise, the placement rules for 
these pragmas are identical to those of the pragma Interface given in Section 13-9 of the LRM. 

Importing Functions with In-Out Parameters 

The third pragma is provided because tne .\da language allows functions to have only in 
parameters. A non-Ada function containi.ng ■:'arameters whose values can be altered by the 
function must be associated with an Ada procedure using Import_Valued_Procedure. The first 
parameter in the Ada procedure corresponus :o the non-Ada function result; it must be of mode 
out and of a discrete type. 

C-Languagc Routines 

If the language C is specified in pragma Interface for an imported subprogram, the compiler 
assumes that the imported subprogram will r.oi pop its parameters. If any other language is given, 
the compiler assumes that the imported subprogram will pop its parameters if it has no copy-back 
parameters (pinout and out scalars and acce.s.s r\pes), and that it won’t pop its parameters 
otherwise. 

Effect of Exporting and Importing on Elaboration Checks 

Exporting a subprogram does not export ;ne mechanism used by the compiler to perform 
elaboration checks; calls from other languages to an exported subprogram whose body is not 
elaborated may have unpredictable results wnen the subprogram body references objects that are 
not yet elaborated. Elaboration checks wiuhin inc .\da program are not affected by the exporting 
pragma. 

Use of the Import_Procedure pragma for a subprogram guarantees that no elaboration check is 
performed on the imported procedure. Hcr.ee. no explicit suppress of elaboration check is 
needed. 


8 


9 / 28/90 


RATIONAL 



Appendix IV: App>endix F for the M68020/Bare Target 


Examples 

procedure Matrix_Multiply (A, B: in Matrix; C: out Matrix); 

pragma KacportJProcedure (Matrix_Multlply); 

>- External name is the string "Matrix_Multlply" 

function Sin (R: Radians) return rloat; 
pragma Export_runction 

(Internal »> sin. 

External •> "SXN_RADIANS”); 

— External name is the string "SIM_RADXAMS" 

procedure Locate (Source : in String; 

Target : in String; 

Index : out Natural); 

pragma Interface (Assembler, Locate); 
pragma Ia^ort_Procedure 

(Internal »> Locate, 

External »> "STR$LOCATE", 

Parameter_Types »> (String, String, Natural), 

Mechanism »> (Reference, Reference, Value)); 


function Pwr (I: Integer; N: Intciger) return Float; 

function Pwr (F: Float; N: Integer) return Float; 

pragma Interface (Assembler, Pwr); 

pragma Iiqport_Functlon 
(Internal 
Parameter_Types 
Result_Type 
Mechanism 
External 

pragma ljB^rt_Function 
(Internal 
Paramater_Types 
Result_Type 
Mechanism 
External 

Pragma Iiitemipt_Handler 

Provides a method for interrupt-handling. 

Format 

See examples below. 

Description 


=> Pwr, 

=> (Integer, Integer), 
ss> Float, 

=> Value, 

=i> "MATH$PWR_OF_INTEGER") ; 


»> Pwr, 

»> (Float, Integer), 

=> Float, 
s> Value, 

»> "MATH$Pim_OF_FLOAT") ; 


RATIONAL 


9/28/90 


9 






Appendix F 


Three different mechanisms are available to support interrupt handling; address clauses on task 
entries, subprograms identified with pragma lnterrupt_Handler, and interrupt-handling queues 
that employ both subprograms and task entries. 

• Simple interrupt handling can be accomplished with address clauses attached to task entries, 
as described in the LRM (Section 13.5.1). .\'ote that the task entry must always be available, 
discusses this method in more detail. 

• As one alternative, interrupt-handling procedures can be called on a nonspecific, 
target-dependent thread. In this method, the Interrupt_Handler pragma associates an 

'■ interrupt-handling procedure with a corresponding interrupt vector. The syntax for the pragma 
is as follows; 

procadure Randler_Procedure (Target_Dependant_Paraineter ; Integer); 

pragma Interrupt_Handler (Handler => Handler__Procedure, 

Vector => [address-expression]); 

• The third alternative for interrupt handling is the queued interrupt handler, a combination of 
the first two approaches. In this method, u procedure, a task entry, and an interrupt vector are 
associated with each other through an Inicrrupt_Handler pragma as shown in this example of 
a task specification; 

task type Driver is 

entry Handler (Target_Dependeno_?arameter ; integer); 
end Driver; 

T ; Driver; 

procedure >ty_Interrupt_Hanciler (Torget_Dependant_ParaxQeter ; Integer); 

pragma Znterrupt_Handler (Handlar => My_Znterrupt_Handler, 

Vector => [address-expression], 

Ta3k_£ntry => T.Handler); 

Note that an address clause must not be included on the entry in the task specification. 

Chapter 9 discusses the development of interrupt handlers. 

More than one Interrupt_I-Iandler pragma can be associated with a given subprogram and/or task 
entry if that subprogram and/or task entry are to serve as handlers for more than one interrupt 
vector. The elaboration of the Interrupt_Hanu!er pragma has the effect of associating either a task 
entry' or a subprogram with an interrupt vector. This may result in the propagation of the 
Standard.Program_Error exception if the vector already has an associated handler. 

The cross-compiler verifies that all associated Itandlcrs and named task objects are declared at the 
outermost scope. The pragma mu.st appear in the same declarative region or package 

specification as, and following, the definitions i;f tiie task entry and the subprogram. 

The interrupt-handling procedure must have i single formal parameter of type Standard.Integer. 
The actual value of this parameter and interpretation of it during execution of the handler is 


10 


9/28/90 


RATIONAL 







Appendix IV: Appendix F for the M68020/Bare Target 


target-dependent The Vector parameter is interpreted by the runtime system. 

When an interrupt occurs, the associated procedure is called directly by the runtime system at 
interrupt level on an interrupt stack. No elaboration check is performed, even if elaboration 
checks are enabled. The context at the time of the call is the context at the time of the interrupt, 
not the context of the associated task, if there is one. 

The interrupt-handling subprogram is responsible for clearing the interrupt and performing any 
device-specific actions required. The 

The procedure—and all subprograms called from this procedure—must conform to a set of 
restrictions that include the following: 

• No stack checks—use pragma Suppress (Storage_Check) 

• Must not raise exceptions (ever!) 

• Must not perform any tasking-related operations, including but not limited to: 

— Entry calls 

— Task creation 

— Abort statements 

— Delay statements 

• Must not pop its parameters from the stack. 

Failure to comply with these rules makes the program erroneous. The procedure may make use 
of the Runtime_Interface package to control various aspects of certain tasks. The predefined 
package Calendar can be used and dynamic memory allocation/deallocation is allowed. No 
checks are performed to ensure that restrictions are not violated, and such violations may have 
unpredictable results. 

When the interrupt-handling subprogram returns, the runtime system checks whether the 
interrupt has an associated task entry. If so, the runtime system queues a call to the associated 
task entry in such a way that it takes precedence over any noninterrupt-driven calls to the same 
task entry. The task object must be activated before receiving the first interrupt; no check is 
performed at run time to ensure that this has been done. The interrupts are fully buffered and the 
called task accepts one entry call for each interrupt regardless of the rate at which interrupts are 
received. For example, if ten interrupts are received before the task accepts the first, then the 
Count of the associated entry is 10, and ten accept statements for that entry are required to 
reduce the 'Count to 0. In other words, when an accept statement is encountered, one of the 
following occurs: 

• If the 'Count of pending interrupt-driven calls to the appropriate entry is nonzero, 'Count is 
decremented and execution is continued as if an accept has occurred. 

• If Count is 0 and there are pending calls to the appropriate entry from noninterrupt-driven 
tasks, the first one in the queue is accepted. 

• If 'Count is 0 and there are no other pending entry calls, execution is suspended, awaiting one 
of the above to occur. 


RATIONAL 


9/28/90 


11 






Appendix F 


In the situation shown in Figure IV-1, three tasks (Tl, T2, and T3) have issued normal entry calls 
to task T’s Entry 1, two (T4 and T5) have issued calls to EntryZ, and one (T6) has issued a call to 
Entry3. In addition, three interrupts have issued calls to Entry 1 and one interrupt has issued a call 
to Entry3. 


Figure A '-1 Queued Interrupts 

If T'Body contains the following code: 


begin loop 

accept Entryl; 

accept Entry2; 

accept Entry3; 

end loop; 

then the first time through the loop, accept Entryl decrements ’Count Oeaving it at 2) and 
continues, accept Entry2 accepts the oui! :rom task T4, and accept Entry3 decrements its 
Count Geaving it at 0) and continues i’ne second time through, accept Entryl again 


12 


9/28/90 


RATIONAL 



Appendix IV: Appendix F for the M68020/Bare Target 


decrements ’Count, accept Entxy2 accepts the call from task T5, and accept EntryS accepts 
the call from task T6. 

The priority of the task during the rendezvous is prop)Ottional to the priority of the interrupt and 
higher than Standard.System.Priority'Last. 

discusses the development of interrupt handlers. 

Pragma Main 

Designates an Ada main unit. 

Format 


pragma Main ( Target *> siaiplm_naaa, 

Stack_Slze => st»tic_intagar_axpre3sion, 
Heap_Slze => static_integer_expressioxi ); 


Parameters 

Pragma Main has three optional parameters; 

• Target -> aiaplm_nainB: Specifies the target key as a string. If this parameter appears and 
does not match the current target key, pragma Main is ignored. If the Target parameter 
matches the current target key or does not appear, pragma Main is honored. A single source 
copy of a main program can be used for different targets by putting in multiple Main pragmas 
with different Target parameters and different stack sizes and/or different heap sizes. 

• Stack_Slz« ■> statia_intmgar_mxpr 0 asion: Specifies the size in bytes of the main task 
stack as an expression. If not sp>ecifred, the default value is 4 Kb. 

• R«ap_Slz« => st*tic_intBgar_axpras3ion: Specifies the size in bytes of the heap as an 
expression. If not specified, the default value is 64 Kb. 

Description 

A parameterless library-unit procedure without subunits can be designated as a main program by 
including a pragma Main at the end of the unit specification or body. This pragma causes the 
linker to run and create an executable program when the body of this subprogram is coded. 
Before a unit having a pragma Main can be coded, all units in the ii4tb closure of the unit must 
be coded. 

Multiple Main pragmas can be placed in the specification, the body, or both. If more than one 
pragma Main is specified with the same target parameter, only the first pragma Main in the 
specification (if there is one) has any effect; otherwise, only the first one in the body is used. 

Using the Target parameter forces the pragma to be ignored for all targets but the one specified. 
This enables joined views of a procedure to have different effects according to the target. One 
use is to avoid the effects of declaring a pragma Main when the target is the RIOOO: 

pragma Main (Target »> Mc68020_Bare); 


RATIONAL 


9/28/90 


13 




Appendix F 


Another use is to specify different stack or heap sizes for different targets. For example: 

procedur* Show_Pragina_Maln is 
begin 

Do_Soxiiet hing; 
end Show_Pragma_Kain; 

pragma Main (Target => Hc68020_Bare, Heap_Slze => 10*1024); 
pragma Main (Target »> <another target )cey>, Heap_Slze => 20*1024); 

The program Show_Pragma_Main will be a main program in both an Mc68020_Bare view and a 
view for the other target. The heap sizes for the two targets will be as specified by the different 
Main pragmas. 


Pragma Nickname 

Gives a unique string name to a procedure or function in addition to its normal Ada name. 

Format 


pragma Mlckname ( "striiig"); 

Description 

This unique name can be used to distingui.sh among over- loaded procedures or functions in the 
importing and exporting pragmas defined in preceding subsections. 

Pragma Nickname must appear immediateiv following the declaration for which it is to provide a 
nickname. It has a single argument, the nickname, which must be a string constant. 

For example: 

function Cat (L: Integer; R: String) return String; 
pragma Nickname ("Int-Str-Cat”); 


function Cat (L: String; R: Integer) return String; 
pragma Nlclcname ("Str-Int-Cat”) ; 


pragma Interface (Assembly, Cat) ; 


pragma Inyort_FunctIon 


(Internal 

Nicknaine 

External 

Mechanism 


=> Cat, 

=> "Int-Str-Cat", 

=> "CAT$INT_STR_CONCAT", 
=> (Value, Reference)); 


pragma Inyort_Functlon 


(Internal => 
Nickname => 
External => 
Mechanism => 


Cat, 

"Str-Int-Cat", 

"CATSSTR_INT_CONCAT", 
(Reference, Value)); 


9/28/90 


RATIONAL 




Appendix IV; Appendix F for the M68020/Bare Target 


Pragma Suppress_All 

Duplicates the efFert of several Suppress pragmas. 

Format 


pragma Suppress_All; 

Description 

Pragma Suppress_All is equivalent to the following sequence of Suppress pragmas. It has no 
effect in a package specification. See the LRM, section 11.7.3. 


pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 
pragma Suppress 


(Access_Check); 
(Dlscrlmlnant_Chec)c); 
(DlvlslonjCheck); 
(Elaboratlon_Chec]c) ; 
(Index_Check) ; 
(LengthjCheck); 
(07er£loir_Check) ; 
(Range_Check); 
(Storage_Check); 


Note that, like pragma Suppress, pragma Suppress_All does not prevent the raising of certain 
exceptions. For example, numeric overflow or dividing by zero is deteaed by the hardware, 
which results in the predefined exception Numeric_Error. Refer to , “Runtime Organization," for 
more information. 


Pragma Suppress_All must appear immediately within a declarative part. 


IMPLEMENTATION-DEPENDENT ATTRIBUTES 

There are no implementation-dependent attributes. 


PATIONAL 


9/28/90 


15 





Appendix F 


PACKAGES SYSTEM AND STANDARD 
Package Standard (LRM Annex C) 

Package Standard defines all the predefined identifiers in the language. 

package Standard Is 

type *Oniversal_Int6ger* is ... 

type *U!niversal_Real* is ... 

type *Universal_Fixed* is ... 

type Boolean is (False, True); 

type Integer is range -2147483648 .. 2147483647; 

type Short_Short_lnteger is range -128 .. 127; 
type Short_Integer is range -32768 .. 32767; 

type Float is digits 6 range -16#1.FFFF_FE# * 2.0 ** 127 .. 

16#1.FFFF_FE# * 2.0 ** 127; 

type Long_Float is digits 15 range -16#1.FFFF_FFFF_FFFF_F# * 2.0 ** 1023 

.. 16#1.FFFF_FFFF_FFFF_F# * 2.0 ** 1023; 

type Duration is delta 16#1.0# * 2.0 ** (-14) 

range -16#1.01f * 2.0 ** 17 .. 

16#1.?FFF_FFFC# * 2.0 ** 16; 

subtype Natural is Integer range 0 .. 2147483647; 

subtype Positive is Integer range 1 .. 2147483647; 

type Character is ... 

type String is array (Positive range <>) of Character; 
pragma Pack (String); 

package Ascii is ... 

Constraint_Error : exception; 

Numeric_Error : exception; 

Storage_Brror : exception; 

Tasking_Error : exception; 

Program_Error : exception; 

end Standard; 


16 


9/28/90 


RATIONAL 








Appendix IV: Appendix F for the M68020/Bare Target 


Table IV-2 shows the default integer and floating-point types; 

Table IV-2 Supported Integer and Floating-Point Types 


Ada Type Name 

Size 

Shori_Short_Integer 

8 bits 

Short_Integer 

16 bits 

Integer 

32 bits 

Float 

32 bits 

Long_Float 

64 bits 


Fixed-point types are implemented using the smallest discrete type possible; it may be 8, l6, or 
32 bits. 

Standard. Duration is 32 bits. 

Package System (LRM 13.7) 

package System is 

type Address is private; 
type Name is (Mc68020_Bare); 

System_Naiaa : constant Name Mc68020_Bare; 

Storage_Unit : constant :=» 8; 

Memory__Size : constant ;= +(2 ** 31) - 1; 

Min_Int : constant := -(2 ** 31); 

Max_Int : constant +(2 ** 31) - 1; 

Majc_pigits ; constant 15; 

MaxJMantissa : constant ;= 31; 

Fine_Oelta : constant := 1.0 / (2.0 ** 31); 

Tick : constant 1.0 / 1000.0; 

svibtype Priority is Integer range 0 . . 255; 

function To_Address (Value : Integer) return Address; 
function To_Integer (Value : Address) return Integer; 
function "t” (Left . Address; Right : Integer) return Address; 

function (Left * Integer; Right : Address) return Address; 

function (Left ; Address; Right : Address) return Integer; 

function (Left : Address; Right ; Integer) return Address; 

function "K” (Left, Right ; Address) return Boolean; 

function "<=" (Left, Right ; Address) return Boolean; 

function ">" (Left, Right : Address) return Boolean; 


PATIONAL 


9/28/90 


17 








Appendix F 


function ">=" (Left, Right ; Addxeaa) return Boolean; 

-- The functions above are unsigned in nature. Neither Nuxneric_Error 
-- nor Conatraint__Error will ever be propagated by these functions. 

— Note that this isplies: 

To Address (Integer'First) > To__Address (Integer'Last) 


and that: 


To_Address (0) < To_Addreas (-1) 

Also, the unsigned range of Address includes values that are 
larger than those iitylied by Meinory_Size. 


Addresa_Zero : constant Address; 
private 


end System; 


18 


9/28/90 


PATIONAL 








Appendix IV: Appendix F for the M68020/Bare Target 


SUPPORT FOR REPRESENTATION CLAUSES 

The M68020/Bare CDF support for representation clauses is described in this section with 
references to relevant sections of the LRM. Use of a clause that is unsupported as specified in this 
section or use contrary to LRM specification will cause a semantic error unless specifically noted. 
Further details on the effects on specific types of objects are given in the “Size of Objects” 
subsection. 

Length Clauses (LRM 13.2) 

Length clauses are supported by the M68020 Family CDF as follows: 

• The value of a ’Size attribute must be a positive static integer expression. 'Size attributes are 
supported for all scalar and composite types with the following restri^Mons: 

— For all types, the value of the 'Size attribute must be greater than or equal to the minimum 
size necessary to store the largest possible value of the type. 

— For discrete types, the value of the 'Size attribute must be less than or equal to 32. 

— For fixed types, the value of the 'Size attribute must be less than or equal to 32. 

— For float types, the 'Size attribute can specify only the size the type would have if there 
were no clause. The only possible legal values therefore are 32 and 64. 

— For access and task types, the value of the 'Size attribute must be 32. 

— For composite types, a size specification must not imply compression of comp>osite 
components. Such compression must have been explicitly requested using a length clause 
or pragma Pack on the component type. 

• ’Storage_Size attributes are supported for access and task types. The value given by a 
’Storage_Size attribute can be any integer expression, and it is not required to be static. 

• Small attributes are supported for fixed point types. The value given by a 'Small attribute must 
be a positive static real number that cabnot be greater than the delta of the base type. It need 
not be a power of 2. 

Enumeration Representation Clauses (LRM 13.3) 

Enumeration representation clauses are supported with the following restrictions: 

• The allowable values for an enumeration clause range from (IntegeTFirst + 1) to Integer'Last. 

Record Representation Clauses (LRM 13.4) 

Both full and partial representation clauses are supported for both discriminated and 
undiscriminated records. Record component clauses are not allowed on: 

• Array or record fields whose constraint involves a discriminant of the enclosing record 

• array or record fields whose constraint is not static 


RATIONAL 


9/28/90 


19 




Appendix F 


The static simple expression in the alignment clause part of a record representation clause—see 
LRiM 13.4 (4)—must be a power of 2 with the following limits; 

1 <= statlc_siiiple__expxession <= 16 

The size specified for a discrete field in a component clause should not exceed 32 bits. 

Change of Representation (LRM 13.6) 

Change of representation is supported wherever it is implied by support for representation 
specifications. 

Size Of Objects 

This section describes the size of both scalar and composite objects. The first two subsections 
cover concepts of size that apply to all object types. The remaining subsections cover individual 
types. The size concepts are most important for the composite types. 

Minimum, Default, Packed, and Unpacked Sizes 

The following terms are used to describe the size of an object; 

• Storage unit; Smallest addressable memory unit. The size of the storage unit in bits is given by 
the named number System.Storage_L’nit. Since the MC68020 is byte-addressable, the size of the 
storage unit is 8. 

• Minimum size for a type; The minimum number of bits required to store the largest value of 
the type. For example, the minimum size of a Boolean is 1. 

• Maximum size for a type; The largest allowable size for a discrete type. For the MC68020, the 
maximum size is 32. 

• Packed size for a type; The size of a component used in an array or record when a pragma 
Pack is in effect. This is the same as the minimum size unless modified by a ’Size clause (see 
"Determination of Storage Size,” below-). 

• Unpacked size for a type; The size of a component used in an array or record when no 
pragma Pack is in effea. This is the same as the default size unless modified by a ’Size clause 
(see "Determination of Storage Size,” below). 

• Default size for a type; The smallest number of bits required to store the largest value of the 
type when stored in whole storage units. For composite types, the default sizes are multiples of 
8. The possible default sizes for scalar, access and task types are given in Table IV-3. 


20 


9/28/90 


RATIONAL 




Appendix FV: Appendix F for the M68020/Bare Target 


Table TVS Default Sizes for Scalar, Access, and Task Types 


Type 

Sizes In Bits 

Discrete 

8,16, 32 

Fixed 

8, 16. 32 

Float 

32,64 

Access 

32 

Task 

32 


Determination of Stonge Size 

Top-level scalar and access objects are stored using their unpacked size (a top-level object is an 
objea that is not a component of any array or record). Components of composite objects having 
neither pragma Pack nor a record representation clause are also stored using the unpacked size. 
Components of composite objects having pragma Pack are stored using the packed size. Fields of 
records having record representation clauses can be stored in any number of bits ranging from 
the minimum size to the default size of the field type. If a scalar or composite type component 
field is specified to be smaller than the default size, a filler field is introduced, and the data is left 
justified. For further information, see the “Array Types" and “Record Types" subsections. 

Discrete Types 

'Size clauses on discrete types affect sizes by changing the packed and unpacked sizes. When 
there is no 'Size clause, the packed and unpacked sizes are the minimum and default sizes, 
respectively. 'Size clauses with values outside the minimum and maximum sizes cause a semantic 
error. Within that range, there are two cases depending on the value specified by the clause: 

• Value <= default size: The packed size is set equal to Value. The unpacked size is not affected. 

• Value > default size. The packed size is set equal to Value and the unpacked size is set to the 
number of bits in the smallest number of storage units that will hold the packed size. 

Examples are provided in Table IV-4. 


RATIONAL 


9/28/90 


21 







Appendix F 


Table lV-4 Size Examples for M68O20/Bare Target 


Example Type Declaradon 

Minimum 

Size 

Default 

Size 

Maximum 

Size 

Integer 

32 

32 

32 

Boolean 

1 

8 

32 

Float 

32 

32 

32 

type Byte is range 0 .. 255 

8 

16 

32 

type Primary is (Red, Blue, Yellow) 

2 

8 

32 

type X is (Normal, Read_Error, 

Write_Error) 

for X use (7, 15, 31) 

5 

8 

32 

type Ary is array (1 .. 100) of Boolean 

100 

800 

n/a 


Integer Types 

A first-named integer subtype has a default size the same as that of the smallest integer type 
defined in package Standard that will hold the range chosen. For example, consider the following 
type declaration: 

typ« Byte Is range 0..255; 

Type Byte will have a minimum size of 8 and a default size of 16. It has a default size of 16 
because the smallest type from which Byte can be derived is Short_Integer. (Short_Short_Integer, 
which has a size of 8, does not include values greater than 127.) 

The Size clause is supported for nonderivcd and derived integer types. The effect of a ’Size 
clause on minimum size is shown in the follow ing example. Consider: 

typa Byte Is range 0 .. 255; 
for Byte'Size use no¬ 
where n is a static integer expression. Table IV-5 shows the effert of n on the packed and 
unpacked sizes. 


Table IV-5 Example of Effect of Size Clauses 


22 


9/28/90 


RATIONAL 





Appendix rV: Appendix F for the M68020/Bare Target 


'Size clause 

Packed 

Size 

Unpacked 

Size 

No 'Size clause 

8 

16 

Uses 

8 

8 

Use 12 

12 

16 

Use l6 

16 

16 


Enumeratloa Types 

For an enumeration type with n elements, the default internal integer representation ranges from 
0 .. n- 1. The maximum number of elements that can be declared for any one enumeration type 
depends on the total number of characters in the images of the enumeration literals. Let L be the 
total number of characters of the n elements. Then L and n must satisfy the following inequality; 
L<~ 2>« 

Enumeration and 'Size clauses are permitted on derived types. However, this may generate 
additional code when parent/derived types are converted to each other. 

For predefined type Charaaer, the value returned by the 'Size attribute is 8 and the minimum size 
is 8. User-defined character types behave like ordinary enumeration types and may have a 
minimum size that is less than 8. 

The 'Size clause is supported for both nonderived and derived enumeration types. The effect of a 
Size clause on representation is shown in the following example. Consider: 

typ« Raspons* is (No, Maybe, Yes); 
for Response'Size use n; 

where n is a static integer expression. Table IV-6 lists the packed and unpacked sizes for different 
values of n. 


Table IV-6 Example of Enumeration Type Sixes 


’Size clause 

Packed 

Size 

Unpacked 

Size 

No 'Size clause 

2 

8 

Use 4 

4 

8 

Use 12 

12 

16 

Use 16 

16 

16 

Use 20 

20 

32 

Use 32 

32 

32 


RATIONAL 


9/28/90 


23 







Appendix F 


Floating-Point Types 

The internal representations for floating-point types are the 32-bit and 64-bit floating-point 
representations as defined by the MC68020 architecture. 

Fixed-Point Types 

Fixed-point types are represented internally as integers. The integer representation is computed 
by scaling (dividing) the fixed-point number by the actual small implied by the fixed-point type 
declaration. Actual small is defined to be the nearest multiple of 2 that will represent the smallest 
possible value of the fixed-point type. The values that are exacdy representable are those that are 
precise multiples of the actual small; numbers between those values are represented by the 
closest exact multiple. For example, in the declaration: 

typ« fix is dalta 0.01 range -10.0 ..10.0; 

the integer value used to represent the lower bound of the type is -10.0 / (1/128), or -1280, since 
the actual small, representing 0.01, is 1/128. In the example: 

type fix la delta 0.01 range -10.6 .. 10.6; 

the integer value used to represent the lower bound of the type is -1357, which is the closest 
exact multiple of the actual small. (This is -10.6/(1/128) = -1356.8; the nearest integer 
representation is -1357.) 

The size of the representation is 32, l6, or 8 bits; the compiler chooses the smallest of these that 
can represent all of the safe numbers of the fixed-point type. 

’Size and 'Small are supported for both nonderived and derived types. The value given in a 'Small 
clause for a fixed type must be a positive static real number. The value need not be a power of 2. 
By Ada rules, it may not be greater than the delta of the base type. 

Access Types And Task Types 

Access and task objects have a size of 32 bits. The ’Storage_Size length clause is allowed for 
access and task types. The value given in a Storage_Size clause can be any integer expression, 
and it is not required to be static. Static expressions larger than Integer’Last will generate 
compilation warnings; however, a Numeric_Error exception will be raised at run time. For access 
types, the ’Storage_Size clause is used to specify the size of the access type’s collection. If a 
’Storage_Size clause has been applied to an access type, the collection is nonextensible. For task 
types, the clause determines the stack size. 

A value (either static or not) of 0 is allowed; in this case, no collection or task stack space will be 
allocated, and a Storage_Error exception will be raised at run time if any attempt is made to 
allocate or deallocate from the collection or activate the task. Negative values are also allowed by 
the CDF; however, this will generate a Storage.Error exception when the typ>e is elaborated even 
if no attempt is made to allocate or deallocate objects belonging to the collection. 


24 


9/28/90 


RATIONAL 




Appendix FV: Appendix F for the M68020/Bare Target 


Array Types 

For a given array type, the CDF is capable of using one of two representations, known as the 
unpacked and packed representaLions. 

In the unpacked representation, each array component starts on a storage-unit boundary; and 
filler (of up to three storage units) may be introduced between components to cause them to be 
aligned properly. This alignment filler is sometimes needed when the component is a record type 
or contains record types. 

The packed representation for an array typ>e differs from the unpacked representation if the type 
satisfies one of the following mutually exclusive requirements: 

• The minimum size of the component type is less than 32 bits. In the packed representation, 
each component will occupy exactly the number of bits in its minimum size; this means that 
components might not start on storage-unit boundaries. If the last storage unit of a packed 
array of this type contains unused bits, the CDF will cause these bits, which are called tail 
filler, to be zeroed. This permits comparison and copy operations on the array to be 
performed efficiently using block operations. 

• Alignment filler is used in the unpacked representation. In the packed representation, the 
alignment filler will be omitted; each component will still start on a storage unit-boundary. 

If neither of the two situations above holds, the packed representation is the same as the 
unpacked representation. 

If an array type has neither pragma Pack nor a length clause, the CDF uses the unpacked 
representation. If pragma Pack is applied to the array type, the CDF uses the packed 
representation. If a length clause is applied to the array type, the unpacked representation is used 
if it would result in a size less than or equal to that specified in the length clause; otherwise the 
packed representation is used. If the packed representation is also too large for the length clause, 
the length clause is rejected. If both pragma Pack and length clause are specified, the packed 
representation is used; an error will result if this representation is too large for the length clause. 

Note that the length clause specifies an upper bound for the size of the array; a length that is less 
than the size of the unpacked representation will result in the use of the packed representation, 
even it if is smaller than the size given in the length clatjse. 

Change of representation is supported for arrays. Hence, pragma Pack on a derived array type is 
honored, and length clauses on derived array types are permitted. 

Record Types 

In the absence of a record representation clause, a record type also has two basic representations: 
unpacked and paclxd 

In the unpacked representation, each record component starts on a storage-unit boundary, and 
alignment filler may be introduced between components to cause the components to be aligned 
properly. For example, an integer component will be aligned so that it starts on a longword 
boundary. 


RATIONAL 


9/28/90 


25 






Appendix F 


In the packed representation, a component whose size is less than 32 bits will occupy exactly the 
number of bits in its minimum size; such components might not start on storage unit boundaries. 
At present, alignment filler is not eliminated in the packed representation. 

The criteria for seleaing which representation to use are the same as described above for array 
types. 

In either case, the CDF may lay out the record fields in a different order than that used in the 
type declaration for the record. This is done in an attempt to satisfy alignment requirements 
without introducing unnecessary alignment filler. 

If a record representation clause is present, it may mention some or all of the fields in the record. 
Those fields that are mentioned in the clause will be laid out according to its rules; the remaining 
fields are then laid out according to the default algorithms, starting at the first storage unit past 
the last field mentioned in the clause. This is the case even if the clause leaves “holes” that are 
big enough to contain some of the fields not mentioned. In a discriminated record, this rule has 
an important consequence: if one of the discriminants is not mentioned in the clause, it will be 
placed after all of the fields in the largest variant part (as specified by the clause). Even though 
some of the variant parts may be smaller than others, constrained copies of the record selecting 
those variants will be as large as copies of the record with the largest variant. 

A record representation clause cannot mention a field whose size is not known at compile time 
(this includes fields whose size depends on a discriminant). 


IMPLEMENTATION-GENERATED NAT.IES 
Implementation-Dependent Com ponents 

The LRM allows for the generation of namc.s denoting implementation-dependent components in 
records. No such names are visible to the user for the M68020 Family CDF. 


ADDRESS CLAUSES (LRM 13.5) 

Aduress clauses can be applied to any object. Note that the address must be determinable at 
compile time, but it does not need to be .\da static (as defined in the LRM, Section 4.9). The 
’Address attribute does not produce a compile time static value. Addresses must be specified 
using constants and operators from package System. 

Address clauses can be attached to a task entry even when the task entry is used for interrupt 
handling; however, in this case, the task eni.'^. must be available at the time of the interrupt. See 
the discussion on pragma Interrupt_Handlcr for additional information. 


UNCHECKED PROGRAMMING 


26 


9/28/90 


RATIONAL 




App>endix IV: Appendix F for the M68020/Bare Target 


Unchecked Storage Deallocation (LRM 13.10.1) 

Unchecked storage deallocation is implemented by the generic function Unchecked_Deallocation 
defined by the LRM. This procedure can be instantiated with an objea type and its access type, 
resulting in a procedure that deallocates the object's storage. Objects of any type can be 
deallocated. 

The storage reserved for the entire collection associated with an access type is reclaimed when 
the program exits the scope in which the access type is declared. Placing an access-type 
declaration within a block can be a useful implementation strategy when conservation of memory 
is necessary. Space on the free list is coalesced when objects are deallocated. 

Erroneous use of dangling references may be detected in certain cases. When detected, the 
Storage_Error exception is raised. Deallocation of objects that were not created through allocation 
(that is, through Unchecked_G3nversion) may also be detected in certain cases, also raising 
Storage_Error. 

Unchecked Type Conversion (LRM 13.10.2) 

Unchecked conversion is implemented by the generic function Unchecked_Conversion defined 
by the LRM. This funaion can be instantiated with source and target types, resulting in a function 
that converts source data values into target data values. 

Unchecked conversion moves storage units from the source objea to the target objea 
sequentially, starting with the lowest address. Transfer continues until the source objea is 
exhausted or the target objea runs out of room. If the target is larger than the source, the 
remaining bits are undefined. Depending on the target-computer architecture, the result of 
conversions may be right- or left-aligned. 

Restrictions on Unchecked Type Conversion 

• The target type of an unchecked conversion cannot be an unconstrained array type or an 
unconstrained discriminated type without default discriminants. 

• Internal consistency among comp>onents of the target type is not guaranteed. Discriminant 
components may contain illegal values or be inconsistent with the use of those discriminants 
elsewhere in the type representation. 


INPUT/OUTPUT PACKAGES 

The Ada language defines specifications for four I/O packages: Sequential_Io, Direa_Io, Text_Io, 
and Low_LeveLlo. The following paragraphs explain the implementation-dependent 
charaaeristics of those four packages provided with the M68020/Bare CDF. 

Sequential_Io. (LRM 14.2.2 and 14.2.3) 

Because the M68020/Bare CDF does not support a file system, the implementation of 
SequentiaLlo is quite simple. The Sequential_Io.Create and SequentialJo.Open raise 
Io_Exception.Use_Error procedures unconditionally. The Sequential_Io.Is_Open funaion 


RATIONAL 


9/28/90 


27 






Appendix F 


unconditionally returns False. All other procedures and functions exported by instantiations of 
Sequential_Io unconditionally raise Io_Exceptions.Status_Error. 

Directjo. (LRM 14.2.4) 

Because the M68020/Bare CDF does not support a file system, the implementation of Direct_Io is 
quite simple. The Dirert_Io.Create and Direct_Io.Open procedures raise Io_Exception.Use_Error 
unconditionally. The Direct_Io.Is_Open function unconditionally returns False. All other 
procedures and functions exported by instantiations of Direct_Io unconditionally raise 
ro_Exceptions.Status_Error. 

Low_Level_Io. (LRM 14.6) 

Package Low_LeveLlo can be used to obtain byte-oriented access to the address space of the 
MC68020 processor. The implementation-defined declarations for the package are: 

type 0evlca_Addres3 is new System.Address; 

type Slgned_Byte is new Integer range -128..127; 

type l7nsigned_Byte is new Integer range 0..255; 

The Send_Control and Receive_Control procedures are implemented so as to cause MC68020 bus 
cycles to user data space with the address specified. In the event of a Bus_Error during the bus 
cycle incurred by the call to either Send_Control or Receive_Control, the call returns with no 
indication. Data returned by Receive_Controi in the face of a Bus_Error is not defined. 
Low_Level_Io is implemented using the Read_.\lemory and Write_Memory procedures found in 
package Runtime_Interface.Target_Depender.t. 

Textjo. (LRM 14.3) 

Speciflcatioa of Package Textjo (LRM 14.3.10) 

The declaration of the type Count in Te.xt_lo is: 

typ« Count is range 0 .. 1_000_000_000; 

The declaration of the subtype Field in Text_Io is: 

subtype Field is Integer range 0 .. Integer'Last; 

Unlike Directjo and SequentiaLIo, the package Textjo provides mechanisms for performing 
I/O to the Standard I/O device. The Mc68020_Bare CDF routines Standard_Input and 
Standard_Output to the system console via the Console_Io package. The implementation-defined 
aspects of Text_Io and the operation of several subprograms exported from Textjo are described 
below. 

Implementatioa-Dependent Characteristics. 

The two implementation dependent types exported from Textjo have the following 
implementation with the Mc68020_Bare CDF: 


28 


9/28/90 


RATIONAL 






Ap(>endix IV: Appendix F for the M68020/Bare Target 


typ« Count Is range 0 .. 1__000_000_000; 
subtype Field is Integer range 0 . . Integer'Last 

The implementation-dependent line terminator is Asdi.Cr during input operations and the 

sequence Ascii.Cr, Ascii.Lf during output operations. The implementation dependent page 

terminator is Ascii.Ff. 

File Management Operations 

• Create/Open. If the file variable provided is either Standard_Input or Standard_Output, the 

exception Io_Exception.Status_Error is raised. Any other attempt results in 

Io_Exceptions.Use_Error. 

• Close. If the file variable provided is either Standard_Input or Standard_Output, the Qose is 
performed. Any other attempt results in Io_Exceptions.Status_EiTor. 

• Delete/Reset. If the file variable provided is either Standard_Input or Standard_Output then 
Io_Exceptions.Use_Error is raised. Any other attempt results in Io_Exceptions.Status_Error. 

• iWame/Form. If the file variable provided is either Standard_Input or Standard_Output, the null 
string is returned. Any other attempt results in Io_Exception.Status_Error. 

• Get and Put. The operation of Get and Put is as described in the LRM. Data written using Put 
and Put_Line is not interpreted in any fashion. Data written using Put_Line is followed by the 
line terminator sequence Ascii.Cr, Ascii.Lf. Data read using Get and Get_Line is not interpreted 
except that the line terminator, Ascii.Cr, and the page terminator, Ascii.Ff, are removed from 
the input stream. Data read from Standardjnput is echoed to Standard_Output except that the 
line terminator Ascii.Cr is echoed as the sequence Ascii.Cr, Ascii.Lf and the remaining control 
characters Ascii.Nul .. Ascii.Ff, Ascii.So .. Ascii.Us, and Ascii.Del are not echoed. 

• Other properties o/Text_Io. Text_Io output operations are synchronized by the implementation 
of Text_Io with respect to Console_Io. This typically ensures that the entire Item passed to any 
of the overloaded Put procedures reaches the terminal atomically. If, however, the Item cannot 
be placed on a single line because of bounded line lengths then only those portions of the 
Item that fit on a single line will reach the terminal atomically. The line terminator sequence 
(output for calls to Put_Line) is not necessarily synchronous with the corresponding Item. 


RATIONAL 


9 / 28/90 


29 





Appendix F 


OTHER IMPIXMENTATION-DEPENDENT FEATURES 

Machine Code (LRM 13.8) 

Machine-code insertions are not supported at this time. 


30 


9 / 28/90 


RATIONAL 



