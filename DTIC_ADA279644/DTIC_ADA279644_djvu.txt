AD-A279 644 


■STATION PAGE 


FormAflfimv»a 

OPMNo. 



houfUfi tp en—.mdudinQlftiiwlBf f wiiiincinMturticn*. p itching d1« »og»o» gMhww^ 
n. Bint mmtnini no a fif i np thii timfi- gf^r~ ** "T **r*'^ —«—.i— y inrtulim) 

. OifHtanta lor Monnatien Oparalioni and naawM, 1 jit JaHman Dawa Higl«a^r, BuIm 1304. Ada^gtan. VA 
a) tAwapaiwa w and Sudgal. Waahinglan, DC 30609. 


9A0325S1.11349 , AVF: 94ddc500_3A I 

DDC-I, DACS Sun SPARC/Solaris to 80386 PM Bare Ada Cross Compiler 
System with Rate Monotonic Scheduling, Version 4.6.4 I 


National Institute of Standards and Technology 
Gaithersburg, Maryland 



7. KAPORMIMG GAGANIZATiON MAME(S) AND 

JSIV'SSSS Technology 

Gaithersburg, Maryland 20899 
USA 

^I^A6AiNG'MONITC>A1NG agency NAME(S} and 
Ada Joint Program Office 
The Pentagon. Rm 3E118 
Washington. DC 20301-3080 




ORGANIZATION 


W^O; 


94-15734 

iiiiiiiiiiniiii 



imumgOO 


Host: Sun SPARCclassic (under Solaris, Release 2.1) 
Target: Intel iSBC 386/116 (bare machine) 


DTIC 

S ELECTE 

mY2S1994B I 





17, 

CLASSriCATION 

UNCLASSIFED 


18. SECURITY 

UNCLASSIFED 


19. SECURITY 
CLASSFICATION 

UNCLASSIFED 


94 5 25 028 ^ 


C QUAUi y IIT.S.PECIED 1 


20, UMITA 

UNCLASSIFED 


P rt ic rtesd by ANSI Sm. 


















AVF Control Number: NIST94DDC500_3A_1.11 
DATE COMPLETED 

BEFORE ON-SITE: 94-03-18 
AFTER ON-SITE: 94-03-28 
REVISIONS: 94-04-11 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 940325S1.11349 
DDC-I 

DACS Sun SPARC/Solaris to 80386 PM Bare Ada 
Cross Compiler System with Rate Monotonic Scheduling, 

Version 4.6.4 

Sun SPARCclassic => Intel iSBC 386/116 (Bare Machine) 


Prepared By: 

Software Standards Validation Group 
Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 


Accesion For 


NTIS CRA&I 
OTIC TAB 

Justification 


By.. 

Distribution / 




□ 

□ 


Availability Codes 


Dist 


Avail ar.d/or 
Special 




AVF Control Nuabor: NIST94DDC500_3A 1.11 


Cortificato Information 


Tha following Ada implementation was tested and detezmined to pass ACVC 
1.11. Testing was completed on March 25 , 1994. 

Compiler Name and Version: DACS Sun SPARC/Solaris to 80386 PM Bare 

Ada Cross Coiqpiler System with Rate 
Monotonic Scheduling, Version 4.6.4 

Host Cooqputer System: Sun SPARCclassic running under Solaris, 

Release 2.1 

Target Computer System: Intel iSBC 386/116 (Bare Machine) 

See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
940325S1.11349 is a%rarded to OOC-I. This certificate expires 2 years 
after ANSI/MIL-STD-181SB is approved by ANSI. 

This report has been reviewed and is approved. 


Ada Validation IFadility Ada Validation Pa^lity 

Or. David K. ^fferson Nr. L. Arnold ABhMon 

Chief, Information ^sterns Manager, Software Standards 

Engineering Division (ISED) Validation Group 

Computer Systras Laboratory (CSL) 

National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 


Ada Va^dj^ibn Organization 
Directs ,^-^^mputer & Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 



U.S.A. 


Ada Joint Program Office 
David R. Basel 
Deputy Director, 

Ada Joint Program Office 
Defense Information Systems Agency, 
Center for Information Management 
Washington DC 20301 






NIST94DDC500_3A_1.11 
DECLARATION OF CONFORMANCE 

The following declaration of conformance was supplied by the customer. 
Customer: DOC-I 

Certificate Awardee: DDC-1 

Ada Validation Facility: National Institute of Standards and 

Technology 

Conputer Systems Laboratory (CSL) 

Software Standards Validation Group 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 

ACVC Version: 1.11 


Ada Inf>leinentation: 

Con^iler Name and Version: DACS Sun SPARC/Solaris to 80386 PM Bare Ada Cross 

Con^iler System with Rate Monotonic Scheduling, 
Version 4.6.4 

Host CoR^uter System: Sun SPARCclassic running under Solaris, Release 2.1 

Target Conputer System: Intel iSBC 386/116 (Bare Machine) 

Declaration: 

I the undersigned, declare that I have no knowledge of deliberate deviations from the 
Ada Language Standard ANSI/MIL-STD-181SA ISO 8652-1987 in the implementation listed 
above. 



Title 


Date 












TABLE OF CONTENTS 


CHAPTER 1.1-1 

INTRODUCTION.1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES.2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST MODIFICATIONS.2-3 

CHAPTER 3.3-1 

PROCESSING INFORMATION.3-1 

3.1 TESTING ENVIRONMENT...3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 


APPENDIX A.A-1 

MACRO PARAMETERS.A-1 

APPENDIX B.B-1 

COMPILATION SYSTEM OPTIONS.B-1 

LINKER OPTIONS.B-2 

APPENDIX C.C-1 

APPENDIX F OF THE Ada STANDARD.C-1 






























CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro92] against the Ada Standard [Adas3] 
using the current Ada Compiler Validation Capability (ACVC) . This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to (Pro92]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552). The results 
of this validation apply only tc the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield, Virginia 22161 
U.S.A. 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 


Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria, Virginia 22311-1772 

U.S.A. 


1-1 






1.2 REFERENCES 


[Ada83] R?f^rgng^_Wanyal_ £sl _ the Ada Proararomina_Language. 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro92] Ada Compiler Validation Procedures . Version 3.1, Ada Joint 
Program Office, August 1992. 

[UG89] Ada Compiler Validation Ca pability User's Guide. 21 June 
1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
name Identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK_PILE are used 
for this purpose. The package REPORT also provides a set of 
Identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is 
compiled and the resulting compilation listing is examined to 
verify that all violations of the Ada Standard are detected. Some 
of the class B tests contain legal Ada code which must not be 
flagged illegal by the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values—for example, the 


1-2 





largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 
the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [UG89]). 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler 


Ada Compiler 
Validation 
Capability (ACVC) 


Ada Implementation 


Ada Joint Program 
Office (AJPO) 


Ada Validation 
Facility (AVF) 


Ada Validation 
Organization (AVO) 

Compliance of an 
Ada Implementation 


The software and any needed hardware that 
have to be added to a given host and target 
computer system to allow transformation of 
Ada programs into executable form and 
execution thereof. 

The means for testing compliance of Ada 
implementations. Validation consisting of 
the test suite, the support programs, the 
ACVC Capability User's Guide and the 
template for the validation summary (ACVC) 
report. 

An Ada compiler with its host computer 
system and its target computer system. 

The part of the certification body which 
provides policy and guidance for the Ada 
certification Office system. 

The part of the certification body which 
carries out the procedures required to 
establish the compliance of an Ada 
implementation. 

The part of the certification body that 
provides technical guidance for operations 
of the Ada certification system. 

The ability of the implementation to pass an 
ACVC version. 


1-3 










Computer System 


Conformity 

Customer 

Declaration of 
Conformance 

Host Computer 
System 

Inapplicable Test 

ISO 

LRM 

Operating System 

Target Computer 
System 


A functional unit, consisting of one or more 
computers and associated software, that uses 
common storage for all or part of a program 
and also for all or pairt of the data 
necessary for the execution of the program; 
executes user- written or user-designated 
programs; performs user-designated data 
manipulation, including arithmetic 
operations and logic operations; and that 
can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 

Fulfillment by a product, process, or 
service of all requirements specified. 

An individual or corporate entity who enters 
into an agreement with an AVF which 
specifies the terms and conditions for AVF 
services (of any kind) to be performed. 

A formal statement from a customer assuring 
that conformity is realized or attainable on 
the Ada implementation for which validation 
status is realized. 

A computer system where Ada source programs 
are transformed into executable form. 

A test that contains one or more test 
objectives found to be irrelevant for the 
given Ada implementation. 

International Organization for 
Standardization. 

The Ada standard, or Language Reference 
Manual, published as ANSI/MIL-STD-1815A 
-1983 and ISO 8652-1987. Citations from the 
LRM take the form ”<section>.<subsection>; 
<paragraph>." 

Software that controls the execution of 
programs and that provides services such as 
resource allocation, scheduling, 
input/output control, and data management. 
Usually, operating systems are predominantly 
software, but partial or complete hardware 
implementations are possible. 

A computer system where the executable form 
of Ada programs are executed. 


1-4 









Validated Ada The compiler of a validated Ada 

Compiler implementation. 

Validated Ada An Ada implementation that has been 

Implementation validated successfully either by AVF testing 

or by registration [Pro92]. 

Validation The process of checking the conformity of an 

Ada compiler to the Ada programming language 
and of issuing a certificate for this 
implementation. 

Withdrawn Test A test found to be incorrect and not used in 

conformity testing. A test may be incorrect 
because it has an invalid test objective, 
fails to meet its test objective, or 
contains erroneous or illegal use of the Ada 
programming language. 


1-5 






CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 104 tests had been 
withdra%m by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The piiblication date for 
this list of withdrawn tests is 93~ll-22. 


B27005A 

E28005C 

B28006C 

C32203A 

C34006D 

C35507K 

C35507L 

C35507N 

C355070 

C35507P 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

C37310A 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A54B02A 

C55B06A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

C02A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 






2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Commentaries and commonly referenced in 
the format Al-ddddd. For this implementation, the following tests 
were determined to be inapplicable for the reasons indicated; 
references to Ada Commentaries are included as appropriate. 

The following 201 tests have floating-point type declarations 
reguiring more digits than SYSTEM.MAX_DIGITS: 

C24113L..Y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 


2-1 








which 


C35708L..Y 

(14 

tests) 

C35802L..Z 

(15 

tests) 

C45241L. . Y 

(14 

tests) 

C45321L..Y 

(14 

tests) 

C45421L..Y 

(14 

tests) 

C45521L..Z 

(15 

tests) 

C45524L..Z 

(15 

tests) 

C45621L..Z 

(15 

tests) 

C45641L..Y 

(14 

tests) 

C46012L..Z 

(15 

tests) 


C24113I..K (3 tests) use a line length in the input file 
exceeds 126 characters. 

C35404D, C45231D, B86001X, C86006E, and CD7101G check for a 
predefined integer type with a name other than INTEGER, 
LONG_INTEGER, or SHORT_INTEGER; for this implementation, there is 
no such type. 

C35713B, C45423B, B86001T, and C86006H check for the predefined 
type SHORT_FLOAT; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with 
a name other than FLOAT, LONG_FLOAT, or SHORT_FLOAT; for this 
implementation, there is no such type. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for 
this implementation, MAX_MANT1SSA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLOWS is FALSE for floating point types and the results 
of various floating-point operations lie outside the range of the 
base type; for this implementation, MACHINE_OVERFLOWS is TRUE. 

C4A013B contains a static universal real expression that exceeds 
the range of this implementation's largest floating-point type; 
this expression is rejected by the compiler. 

D56001B uses 65 levels of block nesting; this level of block 
nesting exceeds the capacity of the compiler. 

B86001Y uses the name of a predefined fixed-point type other than 
type DURATION; for this implementation, there is no such type. 

C96005B uses values of type DURATION'S base type that are outside 
the range of type DURATION; for this implementation, the ranges are 
the same. 

CA2009C and CA2009F check whether a generic unit can be 
instantiated before its body (and any of its subunits) is compiled; 
this implementation creates a dependence on generic units as 
allowed by AI-00408 and AI-00506 such that the compilation of the 
generic unit bodies makes the instantiating units obsolete. (See 
section 2.3.) 


2-2 











CD1009C checks whether a length clause can specify a non-default 
uize for a floating-point type; this implementation does not 
support such sizes. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length 
clauses to specify non-default sizes for access types; this 
implementation does not support such sizes. 

The following 264 tests check operations on sequential, text, and 
direct access files; this Implementation does not support external 
files: 


CE2102A..C 

(3) 

CE2102G..H 

(2) 

CE2102K 


CE2102N..Y 1 

(12) 

CE2103C..D 

(2) 

CE2104A..D 

(4) 

CE2105A..B 

(2) 

CE2106A..B 

(2) 

CE2107A..H 

(8) 

CE2107L 


CE2108A..H 

(8) 

CE2109A..C 

(3) 

CE2110A..D 

(4) 

CE2111A..1 

(9) 

CE2115A..B 

(2) 

CE2120A..B 

(2) 

CE2201A..C 

(3) 

EE2201D..E 

(2) 

CE2201F..N 

(9) 

CE2203A 


CE2204A..D 

(4) 

CE2205A 


CE2206A 


CE2208B 


CE2401A..C 

(3) 

EE2401D 


CE2401E..F 

(2) 

EE2401G 


CE2401H..L 

(5) 

CE2403A 


CE2404A..B 

(2) 

CE2405B 


CE2406A 


CE2407A..B 

(2) 

CE2408A..B 

(2) 

CE2409A..B 

(2) 

CE2410A..B 

(2) 

CE2411A 


CE3102A..C 

(3) 

CE3102F..H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A..C 

(3) 

CE3106A..B 

(2) 

CE3107B 


CE3108A..B 

(2) 

CE3109A 


CE3110A 


CE3111A..B 

(2) 

CE3111D,.E 

(2) 

CE3112A..D 

(4) 

CE3114A..B 

(2) 

CE3115A 


CE3119A 


EE3203A 


EE3204A 


CE3207A 


CE3208A 


CE3301A 


EE3301B 


CE3302A 


CE3304A 


CE3305A 


CE3401A 


CE3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A..C 

(3) 

CE3403E..F 

(2) 

CE3404B..D 

(3) 

CE3405A 


EE3405B 


CE3405C..D 

(2) 

CE3406A..D 

(4) 

CE3407A..C 

(3) 

CE3408A..C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE3410C..E 

(3) 

EE3410F 


CE3411A 


CE3411C 


CE3412A 


EE3412C 


CE3413A..C 

(3) 

CE3414A 


CE3602A..D 

(4) 

CE3603A 


CE3604A..B 

(2) 

CE3605A..E 

(5) 

CE3606A..B 

(2) 

CE3704A..F 

(6) 

CE3704M..0 

(3) 

CE3705A..E 

(5) 

CE3706D 


CE3706F..G 

(2) 

CE3804A..P 

(16) 

CE3805A..B 

(2) 

CE3806A..B 

(2) 

CE3806D..E 

(2) 

CE3806G..H 

(2) 

CE3904A..B 

(2) 

CE3905A..C 

(3) 

CE3905L 


CE3906A..C 

(3) 

CE3906E..F 

(2) 


CE2103A, CE2103B, and CE3107A use an illegal file name in an 

attempt to create a file and expect NAME_ERROR to be raised; this 
implementation does not support external files and so raises 
USE_ERROR. (See section 2.3.) 

2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 71 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada standard in 


2-3 







the way expected by the original tests. 


B22003A 

B35101A 

B38009B 

B61001R 

B83E01D 

B91002C 

B91002J 

B95077A 

BC1109D 


B26001A 

B37106A 

B55A01A 

B61001W 

B83E01E 

B91002D 

B91002K 

B97103E 

BC1202A 


B26002A 

B37301B 

B61001C 

B67001H 

B85001D 

B91002E 

B91002L 

B97104G 

BC1202F 


B26005A 

B37302A 

B61001F 

B83A07A 

B85008D 

B91002F 

B95030A 

BAIOOIA 

BC1202G 


B28003A 

B38003A 

B61001H 

B83A07B 

B91001A 

B91002G 

B95061A 

BAllOlB 

BE2210A 


B29001A 

B38003B 

B61001I 

B83A07C 

B91002A 

B91002H 

B95061F 

BC1109A 

BE2413A 


B33301B 

B38009A 

B61001M 

B83E01C 

B91002B 

B91002I 

B95061G 

BC1109C 


C83030C and C86007A were graded passed by Test Modification as 
directed by the AVO. These tests were modified by inserting 
"PRAGMA ELABORATE (REPORT )}" before the package declarations at 
lines 13 and 11, respectively, without the pragma, the packages 
may be elaborated prior to package Report's body, and thus the 
packages' calls to function REPORT.IDENT_INT at lines 14 and 13, 
respectively, will raise PROGRAM_ERROR. 

CA2009C and CA2009F were graded inapplicable by Evaluation 
Modification as directed by the AVO. These tests contain 
instantiations of a generic unit prior to the compilation of that 
unit's body; as allowed by AI-00408 and AI-00506, the compilation 
of the generic unit bodies makes the compilation unit that contains 
the instantiations obsolete. 

BC3204C and BC3205D were graded passed by Processing Modification 
as directed by the AVO. These tests check that instantiations of 
generic units with unconstrained types as generic actual parameters 
are illegal if the generic bodies contain uses of the types that 
require a constraint. However, the generic bodies are compiled 
after the units that contain the instantiations, and this 
implementation creates a dependence of the instantiating units on 
the generic units as allowed by AI-00408 and AI-00506 such that the 
compilation of the generic bodies makes the instantiating units 
obsolete—no errors are detected. The processing of these tests 
was modified by re-compiling the obsolete units; all intended 
errors were then detected by the compiler. 

CE2103A, CE2103B, and CE3107A were graded inapplicable by 
Evaluation Modification a& directed by the AVO. The tests abort 
with an unhandled exception when USE_ERROR is raised on the attempt 
to create an external file. This is acceptable behavior because 
this implementation does not support external files (cf. AI-00332). 


2-4 









CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is 
described adequately by the information given in the initial pages 
of this report. 

For technical information about this Ada implementation, contact: 

Forrest Holemon 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 

Telefax: 602-275-7502 

For sales information about this Ada implementation, contact: 

Mike HaIpin 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 
Telefax: 602-275-7502 

Testing of this Ada implementation was conducted at the customer's 
site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro92]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the nximber of ACVC tests in various 
categories. All tests were processed, except those that were 
withdrawn because of test errors (item b; see section 2.1), those 
that require a floating-point precision that exceeds the 
implementation's maximum precision (item e; see section 2.2), and 
those that depend on the support of a file system—if none Is 
supported (item d). All tests passed, except those that are listed 
in sections 2.1 and 2.2 (counted in items b and f, below). 


3-1 










a) Total Number of Applicable Tests 3562 

b) Total Number of Withdravm Tests 104 

c) Processed Inapplicable Tests 504 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 0 


f) Total Number of Inapplicable Tests 504 (c+d+e) 

g) Total Number of Tests for ACVC 1.11 4170 (a+b+f) 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 
1.3) was taken on-site by the validation team for processing. The 
contents of the magnetic tape were loaded directly onto the host 
computer. 

After the test files were loaded onto the host computer, the full 
set of tests was processed by the Ada Implementation. The DDC-I 
Ada downloader runs on the Sun SPARCclassic and is used for 
downloading the executable Images to the target Intel iSBC 3B6/116 
(Bare Machine) . The DOC-I Debug Monitor runs on the targc-t. Intel 
iSBC 386/116 (Bare Machine) and provides communication interface 
between the host downloader and the executing target Intel iSBC 
386/116 (Bare Machine). The two processes communicate via 
ethernet. 

The tests were compiled and linked on the host computer system, as 
appropriate. The executable images were transferred to the target 
computer system by the communications link described above, and 
run. The results were captured on the host computer system. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B for 
a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this test 
were: 

-list 

Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. The listings 
examined on-site by the validation team were also archived. 


3-2 











APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing 
the ACVC. The meaning and purpose of these parameters are 
explained in [UG89]. The parameter values are presented in two 
tables. The first table lists the values that are defined in terms 
of the maximum input-line length, which is the value for 
$MAX_IM LEN—also listed here. These values are expressed here as 
Ada strrng aggregates, where "V represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 126 — Value of V 

$BIG_ID1 (1..V-1 *> 'A', V *> '1') 

$BIG_ID2 (1..V-1 => 'A', V => '2') 

$BIG_ID3 (1..V/2 *> 'A') & *3' ft (1..V-1-V/2 -> 'A') 

$BIG_ID4 (1..V/2 => 'A') & *4' & (1..V-1-V/2 «=> 'A') 

$BIG_INT_LIT (1..V-3 => '0') & ••298" 

$BIG_REAL_LIT (1..V-5 => •O^) & "690.0" 

$BIG_STRING1 ’""• & (1..V/2 => •A^) & •""• 

$BIG_STRING2 '""» & (1..V-1-V/2 •=> 'A^) & '1' & •""• 

$BLANKS (1..V-20 => • •) 

$MAX_LEN_INT_BASED_LITERAL 

"2:" & (1..V-5 => •O^) & "11;" 

$MAX_LEN_REAL_BASED_LITERAL 

"16;" & (1..V-7 => 'O') & "F.E;" 

$MAX_STRING_LITERAL '"•" & (1..V-2 *> 'A') & •""• 


A-1 










The following table contains the values for the remaining 
macro parameters. 

Macro Parameter Macro Value 


ACC_SIZE 

ALIGNMENT 

COUNT_LAST 

DEFAULT_MEM_SIZE 

DEFAULT_STOR_UNIT 

DEFAULT_SYS_NAME 

DELTA_DOC 

ENTRY_ADDRESS 

ENTRY_ADDRESS1 

ENTRY_ADDRESS2 

FIELD_LAST 

FILE_TERMINATOR 

FIXED_NAME 

FLOAT_MAME 

FORM_STRING 

FORM STRING2 


48 

2 

2_147_483_647 

16#1_0000_0000# 

16 

IAPX386_PM 

2#1.0#E-31 

(140,0) 

(141,0) 

(142,0) 

35 

ASCII.SUB 

NO_SUCH_FIXED_TYPE 

SHORT_SHORT_FLOAT 

Nil 


"CANNOT RESTRICT_FILE_CAPACITY" 
GREATER_THAN_DURATION : 75“000.0 

GREATER_THAN_DURATION_BASE_LAST : 131_073.0 

GREATER__THAN_FLOAT_BASE_LAST ; 16#1.0#E+32 

GREATER_THAN_FLOAT_SAFE_LARGE : 16#5.FFFF_F0#E+31 

GREATER_THAN_SHORT_FLOAT_SAFE_LARGE: 1.0E3 08 
HIGH_PRIORITY : 31 

ILLEGAL_EXTERNAL_FILE_NAME1 : \NODIRECTORY\FILENAME 

ILLEGAL_EXTERNAL_FILE_NAME2 ; 

THIS-FILE-NAME-IS-TOO-LONG-FOR-MY-SYSTEM 
INAPPROPRIATE_LINE_LENGTH : -1 

INAPPROPRIATE_PAGE_LENGTH ; -1 

INCLUDE PRAGMAl : 


PRAGMA INCLUDE (’'A28006D1.ADA") 


INCLUDE_PRAGMA2 

INTEGER_FIRST 

INTEGER_LAST 

INTEGER_LAST_PLUS_1 

INTERFACE_LANGUAGE 

LESS_THAN_DURATION 

LESS_THAN_DURATION_BASE_FIRST 

LINE_TERMINATOR 

LOW_PRIORITY 

MACHINE_CODE_STATEMENT 

MACHINE_CODE_TYPE 
MANTISSA DOC 


PRAGMA INCLUDE ("B28006E1.ADA") 

: -2147483648 
: 2147483647 

; 2_147_483_648 
: ASM86 
: -75_000.0 
: -131_073.0 
: ASCII.CR 

: 0 

• 

MACHINE_INSTRUCTION'(NONE,m_NOP) 
; REGISTER_TYPE 
: 31 


A-2 









MAX_DIGITS 
MAX_INT 
MAX_INT PLUS_1 
MIN_INT“ 

NAME 

NAME_LIST 

NAME_SPECIFICATI0N1 
DISK$AWC 
NAME_SPECIFICATI0N2 
DISK$AWC 
NAME_SPECIFICATI0N3 
DISX$AWC 
NEG_BASED__INT 
NEW_MEM_SIZE 
NEW_STOR__UNIT 
NEW_SYS_NAME 
PAGE_TERMINATOR 
RECORD__DEFINITION 
RECORO__NAME 
TASK_SIZE 
TASK STORAGE SIZE 


9223372036854775807 
9223372036854775808 
-9223372036854775808 
SHORT_SHORT_INTEGER 
IAPX386 PM 


:_2: [CROCKETTL. ACVCl 1. DEVELOPMENT] X212OA 

:_2: [CROCKETTL.ACVCll.DEVELOPMENT]X212OB 

• 

:_2:[CROCKETTL.ACVCll.DEVELOPMENT]X3119A 

: 16#FFFP_FFFF_FFFF_FFFF# 

: 16#1_0000_0000# 

: 16 

: IAPX386_PM 
: ASCII.FF 

: RECORD NULL;END RECORD; 

: NO_SUCH_MACHINE_CODE__TYPE 
: 32 
: 1024 


TICK 

VARIABLE_ADDRESS 
VARIABLE ADDRESSl 
VARIABLE]^ADDRESS 2 
YOUR PRAGMA 


0.000_000_062_5 
(16#0#,16#44#) 
(16«4«,16«44«) 
(16#8#,16#44#) 
EXPORT OBJECT 


A-3 








APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler dociunentation and 
not to this report. 


B-1 







5 THE ADA COMPILER 


The Ada Compiler compiles all program units within the specified source file and insens the 
generated objera into die currem program library. Compiler options are provided to allow the 
user control of optimizatitm, run>time checks, and comiMler input and output options such as list 
files, configuration files, the program library used. etc. 

Hie input to the compiler ctmsists of the source file, the configuration file (which controls the 
format of the list file), and the compiler options. Section S.l provides a list of aU compiler 
options, and Section S.2 describes the source and configuration files. 

If any diagnostic messages are produced during the compilation, they are output on the diagnostic 
file ^ on the current output file. The diagnostic file and the diagnostic messages are described 
in Section S.3.2. 

Output consists of an objea placed in the program library, diagnostic messages, and optional 
listings. Hie configuration file and the compiler options specify the format and coments of the 
list information. Output is described in Section S.3. 

The compiler uses a piog^ library during the compilation. The compilation unit may refer to 
units from the program library, and an iruemal repieseruation of the compilation unit will be 
included in the program library as a result of a successful compilation. The program library is 
described in Chapter 3. Section S.4 briefly describes how the Ada compiler uses the library. 


5.1 Invoking the Ada Compiler 

Invoke the Ada compiler with the foUowit^ conunand to the SunOS shell: 

S ada (<option>} <source>fUe*iume> 
where the options and parameters are: 


35 






DACS-80x86 User's Cutde 
Ada Compiler 


OPTION DESCRIPTION 


REFERENCE 


•[twlautojnline 

Specifies whether local subprograms should be 
inline expanded. 

5.1.1 

•CMCK 

Controls nm-time checks. 

5.12 

•coiiflgiiratkNi_flIe 

Specifies the configuration file used by the 
compiler. 

5.1.3 

•(no]debuf 

Ineiudes symbolic debugging mfonnation in 
program Library. Does not include symbolic 
information. 

5.1.4 

•[iM]fixpoint_rounding 

Generates fixed point rounding code. Avoids fixed 
poim rounding code. 

5.1.5 

•(nolfloat. allowed 

Flags generation of float instructkxis as 
error if selected. 

5.1.6 

•[no]library 

Specifies program lilzary used. 

5.1.7 

•[noPist 

Writes a source listing on the list file. 

5.1.8 

•[noloptiniize 

Specifies compiler optimization. 

5.1.9 

•(rwjprogess 

Displays compiler progress. 

5.1.10 

•(twbtref 

Creates a cross tefermce listing. 

5.1.11 

•Inolsavc^smuxe 

Copies source to program library. 

5.1.12 

•(twitarget_dcbug 

Includes Intel debug information. Does not include 
Intel debug information. 

5.1.13 

•unit 

Assigns a specific unit number to the compilation 
(must be free and in a sutdibrary). 

5.1.14 

•recompile 

Interpret the file name as a compilation unit body 



that must be recompiled from library. 

5.1.15 

•specification 

With •recompile interpret file name as a 



ccmipilation unit specification rather than body. 

5.1.16 


Examples: 

$ ada -Hat taatpxog 

This examine compiles the source file testprog^da and geneiaies a list fik with the name 
tcstprogJis. 

$ ada -liJbzaxy ^_llbzazy tast 

This exam|de compiles the source flle testada into the library nqrjibrary. 

Default values exist for most options as indicated in the following sections. Option names may 
be abbreviated (characters omitted from the ligitt) as long as no ambiguity arises. 


36 










DACS-SOkl.: User's Guide 
Ada Compiler 


<aottrce>fllc>naino 

The Ada compiler has one mandatory parameter that should specify the Ada source file. 

This parameter specifies the text file containing the source text to be cmnpiled. If the file type 
is omitted in the source file specification, the file type ".ada” is assumed by default 

The allowed fbnnat of the source text is described in Section S2.\. 


Below follows a description of each of the avail^^ options to the invocation of the Ada 
compiler. 


S.1.1 •(no]auto_iiiline 

•auto^inline local | global 
•noauto^inline (default) 

This option specifies whether subprograms should be inline expanded. The inline expansion only 
occurs if the subprogram has less than 4 objea declarations and less than 6 statements, and if the 
subprogram fiilf^ the requirements defined for pragma INLINE (see Section C2.2). LOCAL 
specifies that only inline expansion of locally defined subprcgrams should be done, while 
GLOBAL will cause inline expansion of all sub^grams. including subprograms from other units. 


S.U -check 


•check ( <keyword> s ON | OFF { ,<keywordi> « ON | OFF } } 
•check ALL^N (default) 


•check specifies which run-time checks should be performed. Setting a run-time check to ON 
enables the check, while setting it to OFF disables the check. All nm-time checks are enabled by 
default The following explicit checks will be disabled/enabied by using the name as <keyword>; 


ACCESS 

ALL 

discriminant 

ELABORA'nON 

INDEX 

LENGTH 

OVERFLOW 

RANGE 

STORAGE 


Check for access values being non NULL. 
All checks. 

Checks for discriminated fields. 

(Hiecks for subprograms being elaborated. 
Irxlex check. 

Array length check. 

Explicit overflow checks. 

Checks for values being in range. 

Checks for sufficient storage availaUe. 


37 




DACS>80x86 User's Guide 
Ada Compiler 


5.U <onngiiraUon_flle 


•configuratlon_Jllc <fIle*spco 
•configuration-file config (default) 

This option specifies the configuration file to be used by the compiler in the current compilation. 
The c^guiation file allows the user to format cmnpiler listings, set error limits, etc. If the 
option is omitted the configuration file config located in the same directory as the Ada compiler 
is used by default Section 52.2 contains a description of the configuration file. 


5.1.4 -[noldcbug 


•debug 

•nodebug (default) 

Generate debug information for the compilation and store the information in the program library. 
This is necessary if the unit is to be debugged with the DDC-I Ada Symbolic Cross Debugger. 
Note that the program must also be linked with the -debug option, if the program is to be 
debugged with the DDC-I Ada Symbolic Cross Debug^r. See S^on 6.5.11. 


5.U •(no]fixpoint_rounding 

•fixpoint^raunding (default) 

•rwfixpoint^rounding 

Normally all inline generated code for fixed point MULTIPLY and DIVIDE is rounded, but this 
may be avoided with -nofixpoint^rounding. Inline code is generated for all 16 bit fixed point 
types and for 32 bit fixed poim types, when the target is 80386PM or 80486PM. 


5.141 •lno]fioat_allowcd 

•fio8t_alIowed (default) 

•nofi(»t_allowed 

Float instruction generation may be flagged as errors, if -iMfioat is selected. This is for use in 
systems, where no flowing poim processor (nor emulator) is available. Notice that TEXTJO uses 
floats in connection with FLOAT JO and FIXED JO. 


38 



DACS-80x86 User's Guide 
Ada Compiler 


5.1.7 •library 

•library <fHc>spco 

•library Sada-library ((tefault) 

This opdon specifies the current subiibrary that will be used in the compilation and will receive 
the objea when the compilation is complete. By specifying a cunem subiibrary. the current 
program library (current subiibrary and anoeston up to root) is also implicitly specified. 

If tlds option is omitted, the rablibiaiy designated by the environmental variable ada-library is 
used as the currem sutdibrary. Section S.4 describes how the Ada compiler uses the library. 


5.1.8 •(nollist 


•Ust 

•nolist (default) 

•list specifies that a source listing will be produced. The source listing is written to the list file, 
which has the name of the source file with the extension Jis. Section 5.3.1.1 contains a description 
of the source listing. 

If •iwiist is active, no source listing is produced, regardless of LIST pragmas in the program or 
diagnostic messages produced. 


5,1.9 •optimim 

•optimixe ( <keyworti> s on | off { ,<iteywortl> s on | off} ] 

•optimize allsoff 

This option specifies which optimizations will be performed during code generation. The possible 
keywords are: (casing is irrelevant) 


aU 

All possible optimizations are invoked. 

check 

Eliminaies superfluous checks. 

cse 

Performs coimnon subexpression elimination including common 
address expressions. 

fct2proc 

Change Ainction calls returning objects of constrained array types 
or objects of record qrpes to procedure calls. 

reordering 

Transforms named aggregates to positional aggregates and named 
parameter associations to positional associations. 

staduJiei^t 

Performs stack height reductions (also called Aho Ullman 
reonlering). 

block 

Optimize block and call frames. 


Setting an optimization to on enables the optimization, while setting an optimization to offdisaUes 
the optimization. All optimizations are disabled by defiuilL In addition to the optional 
optimizations, the compiler always performs the following optimizations: constam folding, dead 
code elimination, and selection of optimal jumps. 







DACS>80x86 User’s Guide 
Ada Compaer 


5.1.10 •(nolprogress 


•progress 

•noprogrcss (default) 

When this option is given, the compiler wiU output dau about which pass the compiler is 
cunemly nmning. 


5.1.11 •(nolxref 
-xref 

•noxref (default) 

A cross*reference listing can be requested by the user by means of the option -xTef. If the 'XTef 
option is given and no severe or fatal errors are found durirtg the compilation, the cross-reference 
listing is written to the list file. The cross-reference listing is described in Section ?. 


5.1.12 -[nolsave-source 

•save^source (default) 

•nosave.source 

When •save.source is specified, a copy of thr compiled source code is placed in the program 
library. If •nosavc_$ource is used, source codr will not be retained in the program library. 

Using -nosave-source, while helping to keep library sizes smaller, does affea the operation of 
the recompiler, see Chapter 7 for mote details. Also, it will not be possible to do symbolic 
debugging at the Ada source code level with the DACS-80x86 Symbolic Ada Deiwgger, if the 
source code is not saved in the library. 


5.1.13 •[noltarget.debug 

•tiu^_dcbug 
•notarget_debug (default) 

Specifies whether symbolic debug information on standard OMF is included in the objea file. 
Currently the linker does not support the OMF debug information. 

This option may be used when debi^ging with sUB<dard OMF tools (i.e., PJCE). 


40 






DACS*80x86 User’s Guide 
Ada Compiler 


5.U4 Minit 

•unit s <unit_nuniber> 

The specified unit number will be assigned to the compilation unit if it is free and it is a legal 
unit number for the library. 


5.1.15 -recompile 
•recompile 

The file name (source) is inieipreted as a compilation unit name which has its source saved from 
a previous compilation. If -spedflcation is not specified, it is assumed to be body which must be 
recompiled. 


5.1.1iS -spedfication 
•specification 

Woiics only together with -recompile, see Section 5.1.15. 

5.2 Compiler Input 

Input to the compiler consists of the command line options, a source text fue and, optionally, a 
configuration file. 


5.2.1 Source Text 

The user submits one file containing a source text in each compilation. The source text may 
consist of one or more compilation units (see ARM Section 10.1). 

The format of the source text must be in ISO-FORMAT ASCII. This format requires that the 
source text is a sequence of ISO characters GSO standard 646). where each line is terminated by 
either one of the following termination sequences (CR means carriage renim, VT means vertical 
tabulation, LF means line feed, and FF means form feed): 

• A sequence of one or more CRs, where the sequence is neither immediately preceded nor 
inuncdiately followed by any of iIk characters VT. LP. or FF. 

• Any of the charaaets VT, LP, or FF, immediately preceded and followed by a sequence of zero 
or more CRs. 

In general. ISO control characters are not permitted in the source text with the following 
exceptions: 




41 




DACS*80x86 User’s Guide 
Ada Compiler 


• The horizontal tabulation (HT) character may be used as a separator between lexical units. 

• LF, VT. FF, and CR may be used to terminate lir^. as described above. 

The maximum number of characters in an input liite is determined by the conterus of 
configuration file (see section S.1.3). The control charaaers CR, VT, LF, and FF ate 
considered a pan of the line. Lines containing more than the maximum number of characters 
truncated and an error message is issued. 


5^,2 Configuration File 

Certain processing charaaeristics of the compiler, such as format of input and output, and error 
limit, may be modified by the user. These characteristics are passed to the compiler means 
of a configuration file, which is a standard SPAROSunOS text file. The contents of the 
configuration file must be an Ada positional aggregate, written on one line, of the type 
C0NFIGURAT10N_R£C0RD, which is described below. 

The configuration file (config) is not accepted by the compiler in the following cases: 

• The syntax does not conform with the syntax for positional Ada aggregates. 

• A value is outside the ranges specified. 

• A value is not specified as a literal. 

• LINES_PER_PAGE is not greater than TOP_MARGIN + BOTTOM.MARGIN. 

• The aggregate occupies mote than one line. 

If the compiler is unable to accept the configuration 6k, an error message is written on the 
current output 61e and the compilation is terminated. 

This is the record whose values must appear in ^gtegate fonn within the con6guiation 61e. The 
record declaration makes use of some other types (given below) for the sake of clarity. 


42 










DACS-80x86 User’s Guide 
Ada Compiler 


type C0NFZ6UBATX0N_REC0R0 is 
record 

IN FORMAT: ZNFORMATTZNG; 

OUT FORMAT: OUTFORMATTZNG; 

ERROR_LZMZT: INTEGER; 
end record: 

type INPUT_FORMATS is (ASCII); 

type INFORMATTING is 
record 

INPOT_FORMAT: INPUT FORMATS; 

INPUT_LINELENGTH: INTEGER range 70..250; 
end record; 

type OUTFORMATTING is 
record 

LINES PER PAGE : INTEGER range 30..100; 

TOP_t£RGZN : INTEGER range 4.. 90; 

BOTTOM MARGIN : INTEGER range 0.. 90; 

OUT LZNELENGTH : INTEGER range 80..132; 

SUPPRESS_ERRORNO : BOOLEAN; 
end record: 

The outformaoing parameters have the following meaning: 

1) UNES.PER.PAGE: specifies the maximum number of lines wrin^ on each page 
(including top and bottom margin). 

2) TOP_MARGIN: specifies the number of lines on top of each page y.iStd for a standard 
heading and blank lines. The heading is placed in the middle lines of the top margin. 

3) BOTTOM.MARGIN: specifies the minimum number of lines left blank in the bottom of 
the page. The number of lines available fm* the listing of the program is LINES 
PER_PAGE - TOP_MARGIN - BOTTOM.MARGIN. 

4) OUT.UNELENGTH: specifies the maximum number of characters written on each line. 
Lines longer than OUT_LINELENGTH are separated into two lines. 

5) SUPPRESS.ERRORNO: specifies the format of error messages (see Section S.3.5.1). 

The name of a user-supplied configuration file can be passed to the comi^er through the 
conriguration_file option. DDC-I supplies a default configuration file (config) with the following 
coraem: 


43 










DACS*80x86 User’s Guide 
Ada CMitf^er 


((ASCn. 126). (48.5J.100J'ALSE). 200) 


Top 

Mrgln 




Linaa 

p««* 


lottoa 

Mrpln 





Outjinejength 


Figure 5-1. Page Layout 


5J Compiler Output 


The ctunpiler may produce output in the list Ole. the diagnostic fde, and the current output file. 
It also urates the program library if the compilation is successful The presem section describes 
the text output in the three files mentioned above. The updating of the program library is 
described in Section 5.4. 


The compiler may produce the following text output: 

1) A listing of the source text with embedded diagnostic messages is wrioen on the list fUe. 
if the option -list is active. 

2) A compilation summary is written on the list file, if -Ust is active. 

3) A cross-reference listing is written on the list file, if -xref is active and no severe or fatal 
enors have been detected during the compilation. 

4) If there are any diagnostic messages, a diagnostic file containing the diagnostic messages 
is written. 

5) Diagnostic messages other than warnings are written on the currem output file. 


44 









DACS*80x86 User’s Guide 
Ada Gmipiler 


5J.1 The List Fnc 

The name of the list file is identical to the name of the source file except that it has the file type 
".lis". The file is located in the current (default) directory. If any such file exists prior to the 
compilation, the newest version of the file is deleted. If the user requests any listings by 
specifying the options ‘list or 'XTef, a new list file is created. 

The list file may include one or more of the foUowing parts; a source listing, a cross-reference 
listing, and a cmnpiladon summary. 

The parts of the list file are separated by page ejects. The contents of each part are described in 
the following sections. 

The format of the output on the list file is controUed by the configuration file (see Section 5.2.2) 
and may therefore be controlled by the user. 


5J.1.1 Source Listing 

A source listing is an unmodified copy of the source texL The listing is divided into pages and 
each line is supplied with a line rtumber. 

The number of lines output in the source listing is governed by the occurrence of LIST pragmas 
and the number of obje^onable lines. 

• Pans of the listing can be suppressed by the use of the LIST pragma. 

• A line containing a constnia that caused a diagnostic message to be produced is printed even 
if it occurs at a poim where listing has been suppressed by a LIST pragma. 

SJ.1.2 Compilation Summary 

At the end of a compilation, the compiler produces a summary that is output on the list file if the 
option -list is active. 

The summary contains infonnation about: 

1) The type and name of the compilation unit, and whether it has been compiled successfully 
or not. 

2) The number of diagnostic messages produced for each class of severity (see Section 
5.32.1). 

3) Which options were active. 

4) The foil name of the source file. 

5) The full name of the current sublibrary. 

6) The number of source text lines. 


45 




DACS-80X86 User's Guide 
Ada compiler 


7) The size of the code produced (specified in bytes). 

8) Elapsed real time and elapsed CPU time. 

9) A "Compilation terminated" message if the compilation unit was the last in the compilation 
or "Compilation of next unit initialed" otherwise. 


5J.1J Cross-RefSercnce LisUnf 

A cross-reference listing is an alphabetically sorted list of the identifiers, operators, and character 
literals of a compilation uniL The list has an entry for each entity declared andArr used in the 
unit, with a few exceptions stated below Overloading is evidenced by the occurrence of multiple 
entries for the same identifier. 

For instantiations of generic units, the visible declarations of the generic unit are included in the 
cross-reference listing as declared immediately after the instantiation. The visiUe declarations are 
the subprogram parameters for a genetic subprogram and the declarations of the visible part of the 
package declaration for a generic package. 

For type declarations, all implicitly declared operations are included in the cross-reference listing. 

Cross-reference information will be produced for every constinient dtaracter literal for string 
literals. 

The following are rwt included in the cross reference listing: 

• Pragma identifiers and i»agma argument identifiers. 

• Numeric literals. 

• Record component identifiers and discriminant identifiers. For a selected name whose selector 
demtes a record componem or a discriminant, only the prefix generates cross-reference 
informatioa 

• A parem unit name (following the keyword SEPARATE). 


Each entry in the cross-reference listing contains; 

• The identifier with, at most, IS characters. If the identifier exceeds IS characters, a bar Cl") 
is written in the 16ih position and the rest of the characters are not printed. 

• The place of the definition, i.e.. a line number if the entity is dedared in the cunem 
compilation unit, otherwise the name of the compilation unit in which the entity is declared 
and the line number of the declaration. 

• The numbers of the lines in which the entity is used. An asterisk ("*") after a line number 
indicates an assignment to a variable, initialization of a constant, assignments to functions, or 
user-ttefined operators by means of RETURN statements. Please refer to >^]pendix B.3 for 
examples. 


46 




DAC5>80x86 User's Guide 
Ada Compiler 


5 JJ The Diagnostic FDc 

The name of the diagnostic flk is kkndcal to the name of the source file except that it has the 
fite type ".err”. It is located in the cunem (default) directory. If any such file exi^ prior to the 
compilation, the newest version of the file is deleted. If any diagnostic messages are produced 
during the compilation a new diagnostic flk is created. 

The diagnostic lUe is a text flk containing a list of diagnostic messages, each followed by a line 
showing the number of the line in the source text causing the message, and a blank line. There 
is no sepaticion into pages and no headings. The fik may be used by an interactive editor to 
show the diagnostic messages together with the erroneous source text 


5J J.1 Diagnostic Messages 

The Ada compiler issues diagnostic messages on the diagnostic flk. Diagnostics other than 
warnings also appear on the current output flk. If a source text listing is required, the diagnostics 
are also found embedded in the list flk (see Section S.3.1). 

In a source listing, a diagnostic message is placed immediately afkr the source line causing the 
message. Messages not related to any particular line are plac^ at the top of the listing. Every 
diagnostic message in the diagnostic flk is followed by a line stating the line number of the 
objectional line. The lines are ordered by increasing source line numbeis. Urte number 0 is 
assigned to messages not related to any particular line. On the currem ouqxu file the messages 
appear in the order in wMch they are generated by the cmnpikr. 

The diagnostic messages are classifled according to their severity and the compikr action taken: 


Warning: Reports a quesdonabk constraa or an error that does not influence the meaning of the 
progisn. Warnings do not hinder the generation of object code. 

Exampk; A warning will be issued for constructs for which the compikr detects will 
raise CONSTRAlNT_ERROR at run time. 


Error Reports an illegal ^mstruct in the source program. Compilation continues, but no object 
co^ will be generated. 

Examines: roost syntax errors; most static semantic errors. 


Severe Rqmns an error which causes the coropilttion to be terminated immediately, 
error. No ofajea code is generated. 

Example: A severe error message will be issued if a library unit mentioned by a 
WITH clause is not presem in the currem program litoary. 


47 




DACS-80x86 User’s Guide 
Ada Compiler 


Fatal Repons an enor in the compiler system itself. Compilation is terminated immediately 
error and no objea code is produced. Tlie user may be to circumvem a fatal error by 
correcting the program or by replacing program constructs with alternatives. Please 
infonn DOC-I about the occunence of fatal errors. 


The detection of more eirors than allowed by the number specified by the ERROR.UMIT 
parameter of the configuration file (see section 522) is considered a severe error. 


5JFormat and Content of Dia^iostic Messages 

For certain syntactically incotrea constructs, the diagnostic message consists of a pointer line and 
a text line. In other cases a diagnostic message consists of a text line only. 

The pointer line contains a pointer (a carat symbol to the offending symbol or to an illegal 
character. 

The text line contains the following information: 

• the diagnostic message identification "• * ***" 

• the message code XY>Z where 

X is the message number 

Y is the severity code, a letter showing the severity of the error 

W: warning 
E: error 
S: severe error 
F: fatal error 

Z is an integer udiidi, together with the message mimber X, uniquely identifies the compiler 
location that generated the diagnostic message; Z is of importance mainly to the compiler 
maintenarKe team - it does not contain information of interest to the compiler user. 

The mess^ code (with the exception of the severity code) will be suppressed if the 
parameter SUPPRESS_ERROR_NO in the configuration file has the value TRUE (see 
section 522). 

• the message text: the text may include one context dependent field that contains the name of 
the offending symbol: if the name of the offending symbol is longer dian 16 characters only 
the first 16 characters are shown. 

Examples of diagnostic messages: 

*** ISN'B: Naming: Exception CWSTItAZNT_ERnOR will be raised here 
320e-2: Name OBJ does not denote a type 
*** S35E-0: Expression in return statemnt missing 


48 







DACS-80x86 User's Guide 
Ada Compiler 


*** ISOSS-O: Specification foe this package body not present in the library 


5.4 The Program Library 

This section briefly describes how the Ada compiler changes the program libraiy. For a more 
general description of the program library, the user is referred to Chapter 3. 

The compiler is allowed to read ftom all sublibiaries constituting the current program library, but 
only the currem sublibtaty may be changed. 


5.4.1 Correct Compilations 

In the following examples it is assumed that the com{»lation units are correctly compiled, i.e.. that 
no errors are detected by the compiler. 


Compilation of a library unit which is a declaration 

If a declaration unit of the same name exists in the currera sublibtary, it is deleted together with 
its body unit and possible subunits. A new declaration unit is insetted in the sublibtary, together 
with an empty body unit 

Compilation of a library unit which is a subprogram body 

A subprogram body in a compilation unit is treated as a secondary unit if the current sublibrary 
contains a subprogram declaration or a generic sut^gram declaration of the same name and this 
declaration unit is not invalid. In aU other cases it will be treated as a library unit, i.e.: 

• when there is ix) library unit of that name 

• when there is an invalid declaration unit of that name 

• when there is a package dedaration, generic package declaration, an instantiated package, cr 
subprogram of that name 


Compilation of a library unit which is an instantiation 

A possiUe existing declaration unit of that name in the currem suUibrary is deleted together with 
its body unit and possiUe subunits. A new declaration unit is inserted. 


Compilation of a secondary unit whkb is a library unit body 

The existing body is tteleied from the suUibrary together with its possible subunits. A new body 
unit is inserted. 


49 








DACS-80x86 User's Guide 
Ada Compiler 


ConiiifaithNi of a secondary unit which b a subunit 

If the subunit exists in the sublibiary it b deleted together with its possible subunits. A new 
subunit is insetted. 


S.4J Incorrect Compilations 

If the compiler detects an error in a compilation unit, the program libiary will remain unchanged. 

Note that if a file consists of several compilation units and an error is detected in any of these 
compilation units, the program libraiy will not be updated for any of the compilation units. 


5J Instantiation of Generic Units 

This section describes the rules after which generic instantiation is perfonned. 


5.5.1 Order of Compilation 

When instantiatirv a generic unit, it is required that the entire unit, including body and possible 
subunits, be compiled before the first instantiation. This b in accoidaiKe with the ARM Chapter 
10.3 (1). 


5JJ Generic Formal Private Types 

The present section describes the treaimem of a generic unit with a generic fonnal private type, 
where there b some construa in the generic unit that requires that the corresponding actual type 
must be constiairKd if it b an array type or a type with d'-criminants, and there exists 
instantiations with such an unconstrained type (see ARM, Section 12.3.2(4)). Thb b considered 
an illegal combination. In some cases the error b detected when the instaniation b compiled, in 
other cases when a constraitu-requiring construa of the generic unit b compiled: 

1) If the instantiaiion appean in a later ctmipilation unit than the first constraint-requiring 
construa of the generic unit, ti e error b associaied with the instantiation which is rejected 
by the compiler. 

2) If the instantiation appears in the same compilation unit as the first constraitu-requiring 
construction of the genetic unit, there are two possibilities: 

a) If there is a con s tr ain t-requiring construction of the generic unit after the instaruiation, 
an error message appean with the instantiation. 

b) If the instantiation appem after aU constraint requiring construos of the generic unit 
in that compilation unit, an error message appean with the constraint-requiring 
construct, but will refer to the iQegal instantiation. 


SO 







DACS-80x86 User’s Guide 
Ada Compiler 


3) The instmiation appean in an earlier compiiation unit than the fiist constraint-requiiing 
consmicijon of the generic unit, which in that case will appear in the genetic body or a 
subunit. If the in^amiaiian has been accepted, the instantiation will correspond to the 
generic declaration only, and not include the body. Nevertheless, if the generic unit and 
the instantiation are located in the same subtibraiy. then the compiler will consider it an 
error. An error message will be issued with the constraint*requiring construct and will refer 
to the illegal instandatian. The unit containing the instantiation is not changed, however, 
and will not be marked as invalid. 


5.6 Uninitialiaed Variables 

Use of uninitiaiized variables is not flagged by the compiler. The effect of a program that refeis 
to the value of an uninitialized variable is undefined. A cross-reference listing may help to And 
uninitialized variables. 


5.7 Program Structure and Compilation Issues 

The following limitations apply to the DACS-80x86 Ada Compiler Systems for the Real Address 

Mode and 286 protected mode only: 

• The Ada compiler supports a "mod.tiea large” memory model for data references. The 
"modified large" memory model associates <me data segment for each hierarchical sublibrary in 
the Ada program library. All package data declared within a suUibrary is efficiently referenced 
from Ada code compiM into the same sublibrary. A slight increase in code size results from 
referencing package data compiled into a different hierarchical level. Intel’s medium memory 
model can thus be obtained by utilizing only one level of Ada inogram library, the root 
sublibrary. 

• The Ada compiler supports a large memory model for executable code. Although the size of 
a single cortqrilation unit is restricted to 32K words, the total size of the code portion of a 
program is not restricted. 

• The space available for the static dau of a compilation unit is 64K - 20 bytes. 

• The space available for the code generated for a compilation unit is limited to 32K words. 

• Any single objea cannot exceed 64K • 20 bytes. 

The following limiutions apply to all DACS-80x86 products: 

• Each source file can contain, at most, 32,767 lines of code. 

• The name of cmnpilatitm units and identiflets may not exceed the munber of characters given 
in the INPUT_L1NELENGTH parameter of the coniiguraiion file. 

• An integer literal may not exceed the range of LONG.INTEGER, a real literal may not exceed 
the range of LONGJFLOAT. 


51 



DACS>80xS6 User's Guide 
Ada Compiler 


• The munber of foimal parameters permitted in a procedure is limited to 127 per parameter 
specificatioa There is no limit tm the number of procedure specifications. For example, the 
declaration: 

procadux* OVER_LZMXT (INTEGEROl, 

” INTEGER02, 

1NTEGER166: in INTEGER); 

exceeds the limit, but the [Nocedure can be acemnplished with the following: 

proeadura UNDER LIMIT (INTEGEROl : in INTEGER; 

~ INTEGER02 : in INTEGER; 

ZNTEGER166 : in INTEGER); 

The above limitations are diagnosed by the compiler. In practice these limitations are seldom 
restrictive and may easily be circumvent^ by using subunits, separate compilation, or creating new 
sublibraries. 


5.8 Compiler Code Optimizations 

DDC'I’s Ada compiler for the iAPX 80x86 microprocessor funily generates compact, efheient 
code. This efficiency is achieved, in pan. by the cmnpiler's global optimizer. Optimizations 
pcrfomied include: 

• Common subexpression elimination 

• Elimination of redundam constraint checks 

• Elimination of redundant elaboration checks 

• Constant folding 

• Dead code elimination 

• Optimal register allocation 

• Selection of optimal jumps 

• Optional nin*time check suppression 


52 










LINKER OPTIONS 


The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation and 
not to this report. 


B-2 




6 THE ADA LINKER 


The DACS linker must be executed to create an executable program in the target environment. 
Linking is a two stage process that includes an Ada link using the compilation units in the Ada 
program library, and a target link to integrate the application code, nin-time code, and any 
additional configuration code developed by the user. The linker performs these two suges with a 
single command, providing options for controlling both the Ada and target linit processes. 

This chapter describes the link process, except for those options that configure the Run-Time 
System, which is described in detail in Chapter 7. 


6.1 Invoking the Linker 

Enter the following command at the shell to invoke the linker. 

$ ada-link {<option>} <unU-naine> 
where the optitms and parameters aie: 

Ada Linker Options 


OPTION 

DESCRIPTION 

REFERENCE 

*[no]debug 

Links an application for use with the 

DACS-80x86 Symbolic Cross Debugger. 

6.5.11 

•enable_task_trace 

EnaUes trace when a task terminates in 
unhandled excqjtion. 

6.528 

•exception_space 

Defines area for exception handling in task suck. 

6.529 

•[no]extra^ 

Extracts Ada Objea modules 

6.5.14 

•intefTupt_entry_table 

Range of interrupt entries. 

6.5.27 

•library ” 

The library used in the link. 

6.5.7 

-[no]log 

Specifies creation of a log file. 

6.5.9 

•lt_segment_sae 

Library task default seirmem size. 

6.523 

•It'stack^size 

Library task default stack size. 

6.522 

•iiip_segnmt_sixe 

Main program segmem size. 

6.525 

-mp~stack_size 

Main program stack size. 

6J24 

•[noTnpx 

Use of the 80x87 tuunetic coprocessor. 

6J.16 

•options 

Specifies target link options. 

6.5.6 

•priority 

Default task priority. 

6.5.18 

•reserve_stack 

Size of reserve sta^ 

6J21 

•nns 

Select Rate Monotonic Scheduling Run^Tune 

Kernel (optional). 

6.5.13 

•[nojroot.extract 

Using non^DDC-I units in the root library. 

6.5.10 


53 






DACS-80X86 User’s Guide 
The Ada Linker 


•(no]rts 

Includes or excludes the nm-time system. 

6.5.12 

•searchiib 

Target libraries or object modules to include 
in target link. 

6.5.4 

•selective-link 

Removes uncalled code from final program. 

6.5.8 

•sign_on 

Produce sign on and sign off messages. 

6.5.30 

•stop-before-link 

Performs Ada link only. 

6.5J 

•tasks 

Maximum number of tasks or non-tasking 
api^cation. 

6.5.17 

•task_storage_si 2 e 

Tasks default storage size. 

6.5.26 

•template 

Specifies template file. 

6.5.15 

•timer 

Tuner resolution. 

6.5.20 

•time_siice 

Task time slicing. 

6.5.19 


All options may be abbreviated (characters omitted from the right) as long as no ambiguity arises. 
Casing is significant for options but not for options keywords. 

Note: Seveial simultaneous links of the same program should not be performed in the same 
directory. 


6.1.1 Diagnostic Messages 

Diagnostic messages from the Ada Lit&er are output on the cunera output file and on the optional 
log file. The messages are output in the order they are generated by the linker. 

The linker may issue two kinds of diagnostic messages: warnings and severe errors. 

A warning reports something which does not prevent a successful linking, but which might be an 
error. A warning is issued if there is something wrong with the body unit of a program unit 
which formally does not need a body unit. e.g. if the body unit is invalid or if there is no objea 
code container for the body unit. Warnings ate only output on the log Hie. not on the current 
output file. The linking summary on the log file will contain the total number of warnings issued, 
even if the issued warnings have not been output. 

A severe error message reports an error which pievems a successful linking. Any inconsistency 
detected by the linker wiU, for instance, cause a severe error message, e.g. if some required unit 
does not exist in the library or if some time stamps do not agree. If the linker is used for 
consequence examination, all inconsistencies introduced by the hypothetical recompilations are 
reported as errors. 

A unit not marked as invalid in the program library may be reported as being invalid by the 
linker if there is something wrong with the unit itself or with some of the units it deperxls on. 


6.2 The Linking Process 

The linking process can be viewed as two consecutive processes. Both are automatically carried 
out when issuing the link command adaJink. 


54 






DACS-80X86 User’s Guide 
The Ada Linker 


The fiist process consdnites the Ada link process and the second constitutes the target link 
process. 

The Ada link process 

• retrieves the required Ada objea modules from the program library, 

• detennines an elaboration order for all Ada units, 

• creates a module containing the User Configurable Data (UCD) from the specified configuration 
options to the linker and 

• creates a shell script that carries out the target link process (i.e.. dlrtkbldx86). The locate/build 
phase is an integral pan of the target link. 


If the option •stop-bcfore-link is NOT specified (default), the above script is executed 
automatically. Otherwise the linking process is halted at this point. 

When •stop-before-Unk is specified, all temporary files are retrieved for inspection or 
modification. The target linker is invoked by executing the shell script. 


6,1.1 Temporary Files 

The following temporary files are in use during the link phase: 

<main^rogram>.link.com The shell script which invokes the target linker. 

<main_program>.elabcode.o The objea code for the calling sequence of the elaboration 

code. 


<main_program>.ucd.o The objea code generated from the RTS configuration 

options (see Seoion 12). 

<main_program>.uxxxxx.o The Ada objea modules which have been extracted from the 

program library, xxxxx is the unit number of the Ada unit 


55 







DACS-80x86 User's Guide 
The Ada Linker 



Figure 6>3. The Linking Process 


The following components make up the run-time system: 

1) User configurable portion of the RTS 

a) User configurable data (UCD) and 

b) User configurable code (UCQ 

2) Peimanent part of the RTS 

a) Non-tadting RTS (rl 1 Jib) or 

b) Tasking RTS (rl2Jib) 

c) RMS Tasking RTS (r 13 Jib) 

The User CbnfiguraUe G)de defined by the environmental variable ada_uccjib is included in the 
link. If no tasking has been specified, then the RTS non-tasking library~(rllJib) will be included. 
If tasking has been specified, then support for tasking will be included (rl2Jib or, when -rms, 
rl3.1ib). 


56 











DACS*80x86 User’s Guide 
The Ada Linker 


'The output of the linker step is an absolute executable object file with the extension ".dat" and 
a map file with the extension ".mpS". 


6JL2 Environmental Variables 

When a link is executed, a number of files are referred to and most are accessed through 
environmental variables. The locate/build phase uses the control file Sada.ucc_dir/config.bld_ddci, 
the remaining variables are: 


VARUBLE 

PURPOSE 

ada_system_library 

Identifies the toot library where the system compilation units reside. 

ada.library 

Identifies the default library used by all DACS-80x86 tools. It is the 
lowest level sublibtary in cte program library hierarchy. 

ada.rootjib 

Identifies the OMF library where the system library units have been 
extracted horn the system library. By having a separate Library for the 
root compilation units, the link process is much faster than otherwise 
having to extract each unit from the system library for each link. 

ada.rl 1 Jib 

Identifies the OMF library for the Permanent Part of the non-tasking 
version of the Run-Ttme System. 

ada_rl2Jib 

Identifies the OMF library for the Permanent Part of the tasking version 
of the Run-Tune System. 

ada_rl3Jib 

Identifies the OMF library for the Permanent Part of the optional Rate 
Monotonic scheduling Run-Tune System. 

ada_ucc_Iib 

Identifies the OMF library for the User Configurable Code portion of 
the Run-Time System. 

ada-iemplate 

Identifies the template file for the Linker. 

ada_ucc-dir 

Identifies the directory of the currem UCC. 


With each of these environmental variables, the name will differ depending on how the system 
was installed (ada86, adal86 etc). 'Throughout this document ada is assumed. For example, the 
environmental variables for the toot library for the 80186 version of the compiler would be 
adal86_root_lib, and the RTS UCC library envinmmental variables for the 8086 version would 
be ada86_iiGC_Ub. 


57 









DACS>80x86 User's Guide 
The Ada Linker 


6J Run-Time System Overview 

The Run-Tune System for DACS-80x86 is defined as all code and data, other than the code and 
data produced by the code generator, required to make an embedded system application operate 
properly on a specific hardware system. 

In general, there are two major compements that make up the Run-Tune System. 

1) Code and dau assumed to exist by the code generator. This is hardware independent and 
known as the RTS Permanem Pan. 

2) Code and dau tailoring the application with respect to the characteristics of the hardware 
and other requirements of the embedded systems developer. This code is called the RTS 
User Configurable Part 

Both of the above components consist of modular OMF libraries. The modules are only included 
in the user program if they are needed. i.e.. if a call or reference is made to the module. This 
ensures a compact RTS (typical applications are 4 KB to 10 KB). 

The RTS Permanem Pan does not make any assumptions about the hardware other than an 80x86 
and some amoum of memory available. 

There are several versions of the RTS User Configurm)le Pan available for differem development 
targets. Also, the source code is provided to allow the modification of the User Configurable 
Code (UCQ to operate on other targets. Refer to the RTS Configuration Guide for complete 
information on modifying the UCC. 

DDC-I has carefully analy^ and selected the pans of the Run-Time System that must be 
configurable for hardware independence. Seeing the user from major rewrites whenever the 
Run-Tune System is retaigeted while, still allowing for almost unlimited adaptability. 

Four importam features of the run-time system are: 

• It is small 

• It is completely ROMable 

• It is configurable 

• It is efneiem 


Conceptually, an Ada nui-time system can be viewed as consisting of the following components: 

• Executive. Le., the start-up mechanism 

• Storage Maru^emem 

• Tasking Managetnem 

• Iigait/Output 

• Exception Handling 


58 









OACS-80x86 User’s Guide 
The Ada Linker 


• Run*Time Library Routines 

• Package CALENDAR support routines 


The nin-time system (RTS) can be configured by the user through Ada Linker command options. 
The Ada Linker will generate appropriate data structures to represem the configured charact^tics 
(UCD). 

Two versions of the RTS are supplied, one including tasking and one excluding tasking. The 
linker selects the RTS version including tasking only if the option 'tasks is presem or 'tasks n 
is presem and n > 0. Otherwise, the linker selects the RTS version excluding tasking. 


6.4 Linker Elaboration Order 

The elaboration order is primarily given by the unit dependencies, but this leaves some freedom 
here and there to arbitrarily choose between two or more alternatives. This arbitrary is in the 
DACS'80x86 linker controlled by the spelling of the involved library units, in order for "free" 
units to become alphabetically sorted. 

Recompiling from scratch, an entire system may thus affea the allocation of unit numbers, but the 
elaboration order remains the same. 

It is also attempted to elaborate "body after body", so that a body having a with to a specification, 
will be attempted elaborated <^rer the body of this specification. 

Also elaboration of units from differem library levels is attempted to complete elaboration of a 
fatheT'level prior to the son'leveL 

This strategy should in many cases reduce the need for resetting pragma ELABORATE. 


6.5 Ada Linker Options 

This section describes in detail the Ada linker option and parameters. 


6J.1 The Parameter <unit'natne> 

<unit'naine> 

The <unit_name> must be a library unit in the cunem program library, but not necessarily of the 
currera suUibrary. 

Note that a main program must be a procedure withom parameten, and that <unit'name> is the 
identifier of the procedure, not a file specificatxm. The main procedure is not checked for 
parameten, but the execution of a program with a main procedure with parameten is undefined. 


59 







DACS-80>i86 User's Guide 
The Ada Linker 


The Parameter crccorapilatioiMpeo 
The syntax of <recoiiipUation-speo is: 

<iinit_speo[<body|>spedflcatkm]I,^] 

This panmeter tells the linker to perform a consistency check of the endit program using the 
hypodietical lecompOatioa of aU units designated in the <recompiIation-spec>. The link process 
in this instance is not actually p e r fo r med. 

The <unit_speo is a list of unit-names (wildcards are allowed), separated by comma (.) or plus 
(<f). Each unit-name should include an option to ittdicate if the body or ^edlicatirm is to be 
hypodtetically compiled (-spec is the default). 


6J3 Required Recompilations 

If the consistency check found that recompilations ate required, a list of required recompilations 
is written to the cunem output file or to a text file if the -log option is specified (the name of 
the text file is indicated in the log file, line 8). The list will include any inconsistencies detected 
in the library and recompilations required by the hypodietical recompilations specified with the 
opdons -dcdaratioa and -body. 


The entries in the list contain: 


1) The unit name. 

2) Indication of what type of unit (declaration imit. body uniL or subunit). 

3) If the unit is specified as recompiled with the -declaration or -body option, it is marked 
with "-R-". 

4) The environmetaal variable of the sublibrary containing the unit. 

In the recompilation list the units ate listed in a recommended recompilation order, consistem with 
the dependerides among the units. 


6J.4 -scarchlib 

-aeardilib <flle_name> {,<fUeJiamo} 

The -scarchlib option directs the Ada Linker to serueb the specified 80x86 target libraries for 
otgea modules in order to resolve symbol references. The 80x86 target libraries for object files 
will be searched before the DAGS Run-Time System (RTS) library normaOy se ar c h e s for nm-iime 
routines; in this way one can replace the sundard DACS RTS routines with custom touthies. 

The -scar chlib option is also intended to spediy Ubrarws of modules referenced fiom Ada via 
pragma INTERFACE 


60 









DACS-SOxM User’s Guide 
Hie Ada Linker 


Examples: 

S adaJink •scardilib imcrfSKe_Iib p 

Links the subprogram p. resolving referenced symbols firs with the target library iruerface.lib 
and then with the standard RTS target library. 


•slopJiefcrcJink 

•stop_bclbrc_link 


The •stop_bc(breJink option allows the user to introduce assemblers and linkers from third 
parties orlo ochvwise ranfigure the link to suit the application. The link is halted with the 
following conditions: 

• The configurable dau file. <main>.ucd.o. is produced with the default or user specified 
lirtk. Jon values included. 

• The daboration code is contained in the <main>-elabcode.o file. 

• The shell script file that contains the link command is present and has not been executed. The 
file's name is <main> Jink.com. 

• The temporary Ada object file(s) used by the target linker ate produced. These objects are 
linked and deleted when <main> Jink.com is executed. 

• With •seiectivc^iink the objea files comprise all Ada units including those fiom the root 
libtary. At this poiru it is possible to disassemble the "cut” object files using -objea with the 
disassembler. 

To complete the link, the <main> Jink.com script must be executed. To use third party tools, this 
file may have to be modified. 


-options 

•options <paraineter> 

•options allow the user to pass options onto the targa linker. 


61 







OACS-80x86 User's Guide 
Run-Time System 


<J.7 -library 

•library <flle-aarae> 

•library SedaJIbrary (defuiit) 

The -library option specifies the cunem sublibrary, firoin which the linking of the main unit will 
take place. If this option is not specified, the suWbtary specified by the environmental variable 
adaJibrary is used. 


-selectivc^liak 

•aelectlvc_link 


This extracts all required objea modules from the Ada library (including the root library) and cuts 
out exactly those paru that are actually called, in order to nuke the resulting target program 
considerably smallm. If a program uses e.g. PUT.UNE as the only routine from TEXTJO. the 
coniribMtian from the TEXT JO objea module will only contain PUT.L1NE (and udutever that 
needs). Note that disassemblies of units used in a selective link normally will not match what is 
linked, because of the cutting. Such disassemblies may though be obtained by disassembling 
directly those units that made up the selective link, by stopping the linking before the target link 
phase (•stop_bcforcJink). making disassemblies using -objea and then resuming the link. 

Note also that unused constants and permanem variabtes are not removed. 

Only "level 1" subprograms may be removed. Nested subpr o gr a ms (that are not called) ate to be 
removed during compilation using the •optimixe option. Nested subprograms are only removed, 
if the routine in which the nesting occur is removed. 


6JS -[nollog 

•log [<fIle-speo] 

•nolog (default) 

The option qrecifies if a log file will be produced from the front end linker. As default, no Ir^ 
file is (mxtaiced. If <file-spec> is not entoed with -log the default file name for the log file will 
be link.Iog in the cunem directory. 

The log file contains extensive inforauuion on the results of the link. The file includes: 

• An elabwaiion order list with an entry for each unit included, showing the order in which the 
units will be elaborated. For each unit, the unit Qrpe. the time stamp, and the dependencies ate 
shown. Funhermore. any elaboration inconsistencies wiD be reported. 

• A linking summary with the following inlbtmation: 

• Parameters and active options. 

• The full name of the program library (the cunem sutdibrary and its ancestor sublibraries). 


62 






DACS-80k 86 User’s Guide 
^ TIk Ade Linker 


• The number of each type of diagnoshc message. 

• A tenninaiian message, sudng if the linking was mnninaied successfully or unsuccessfully or 
if a consequence examination was lenninaied. 

• Diagnostic messages and wamii^ are written on the log file. 


If recompilations are required (as a result of the consistency check) a text file is p^uced 
containing excerpts of the log file. The name of this text file is written in the log (He. line 8. 


The log file consists of: 

• Header consisting of the linker name, the linker version number, and the link time. 

• The elaboration order of the ounpilation units. The units are displayed in the order elaborated 
with the unit number, compilation time, unit type, dependencies, and any linking errors. 

• If recompilations are required, the units that must be recompiled are listed altmg with its unit 
type and sublibrary level 

• The linking summary that includes the main unit name, the program library, any recompilations 
that are required, arid if any errors or warnings occurred. 


6J.10 •(no]root_extract 
•root^extntct 

•iMroot^extract (default) 

The units contained in the Ada system library supplied by DDC-I have been extracted arxl inserted 
into the Sada.rootjib OMF Library, thus eliminating extractions from the system library at link 
time and improving link performance. 

The user should nonnaUy not modify or compile into the Ada system library supplied by ODC-L 
If however, a unit is compiled ituo the Ada system library, the $ada_toot_lib will no longer 
match the Ada system library and •root_extract must be specified in order to link from the Ada 
system library. 


•[no]debug 

•debug 

•nodebug (default) 

The •debug option specifies that debug information is generated. The debug information is 
rerpiired to enable symbolic debugging. If onodebug is specified, the Ada linker will skip the 
generation of debug information, thus saving link time, and will not insert the debug information 


63 






DACS-80x86 User’s Guide 
The Ada Linker 


into (he chosen sublibniy. thus saving disk space. Note that any unit which should be 
symbolically debugged with the DDC-I Ada Symbolic Cross Debugger must also be compiled with 
the 'debug option. 


6J.12 '{nolrts 

•Its (default) 

•norts 

The 'Its option directs the Ada Linker to include the appropriate Run-Tune System (RTS) in the 
link, •norts directs the Ada Linker to exclude the RTS in the link. 

The ability to exclude the Run-Tune System fiom the link allows the user to do an additional link 
with a private copy of a custom RTS. The Ada Linker may repon unresolved references to RTS 
routines, but will still produce a relocatable object file. 


6J.13 'nns 


•rms 

This option selects the Rate Monotonic Scheduling Tasking Kernel (if tasking is selected). The 
default is to use the Standard Tasking Kernel. This feature is supplied as an option. 


(.5.14 '[nolextract 

-extract (default) 

•nocxtract 

This option to the linker allows the user to specify that program unit objects should not be 
extract^ from the Ada program library. This option would be used if the user knows that many 
objects have not changed siiKe the last link and does not want the linker to waste time extracting 
them. 

To use this feature, the user should modify the template to not delete unit objea files after a 
target link is performed. This way the objea files remain in the currem directory (or whereever 
the user decides to put them). On subsequent links the user can extraa objea modules of 
modified units from the Ada library usii^ the standalone DACS extraa tool. A new targa link 
can then be perfonned using a combination of newly extracted objects and the objea fUa fmn 
previous links that have gone unchanged. This could significantly improve linker speed when 
linking programs that share conunon and rarely modified libraries and when relinking programs 
that have had oily a few units modified. 


64 



DACS-80xg6 User's Guide 
The Ada Linker 


6JJ5 ottoiplale 

•lemplate <file-naine> 

•template $ada.template (default) 

The template file is known to the linker via the environmental variable adajemplate. DDC-I 
supf^ies a default lemplaie file as pan of the standard release system. Please refer to appendix H 
for detailed information. 


6J.16 -niK 


•n|»( (default) 

•nonpx 

The 'npx option specifies that the 80x87 (8087, 80287, or 80387) numeric coproce^r is used 
by the Ada program. When -npx is qjedfied, the 80x^ is initialized by the task initialization 
routine, the floating point stack is reset during exception conditions, atxl the 80x87 cotuext is 
saved during a task switch. 


Configurable Data 

A 16 bit boolean constant is generated by the Ada Linker. 


« 0 
» 1 


CO NPX USED 


boolean 


• 80x87 is not used 

• 80x87 is used 


6J.17 •tasks 
•tasks [n] 

(defnilt is no tasking) 

This option specifies the maximum number of tasks allowed by the RTS. If specified, n must be 
greater than zero. If 'tasks is specified without a value for n. n defaults to 10. If •tasks is not 
specified, the RTS used will not include support for tasking. If •tasks is specified, the RTS used 
will include support for tasking. 

Ada Interrupt tasks identified with inagma INTERRUFT_HANDLER need not be included in the 
count of maximum number of tasks. The main ptogiw must be counted in the maximum number 
of tasks. Note that the main program, which may implicitly be considered a task, will not run 
under control of the tasking kernel when •notasks is specified. See also 'nns option. 


Configurable Data 

For •tasks, the linker generates the following configurable data: 

6S 







DACS>80x86 User's Guide 
The Ada Linker 


_COJOX_TMIO 


niTtaaa ■ n 


CO teas 


N TMk 

Ceacrel 

■leeka 

(TCaS) 

If •tv> la 
activa, ■ 
nwaarie eo> 
proeaaaac 


Example: 

$ ada-link 'tasks 3 p 

• Link the ptogram P, which has at most 3 tasks, including the main program. 


6J.18 'priority 
'Priority n 

'priority IS (default) 

The 'priority option specifies the default priority for task execution. The main program will nin 
at this priority, as well as tasks which have had no priority level defined via pragma PRIORITY. 
The range of priorities is from 0 to 31. 

Priorities can be set on a per task basis dynamically at nm time. See section E.1 (Package 
RTS.EntryPoims) for more details. 


Configurable Data 

The Ada Linker generates the following constam data: 

_co_paioaxTy 

Example: 

$ ada_link 'tasks 'priority 8 p 

• Link the subprogr am P wtudi has the main program and tasks tunning at 
default priority i. 


66 







DACS*80x 86 User’s Guide 
Hie Ada Linker 


<LS.i9 •time-sUcc 

•lime^slke [r] (default no dme slicing is active) 

The -Ume^slice options specifies whether or not time slicing will be used for tasks. If specified, 
R is a dedmal number of seconds repfesenting the default time slice to be used. If R is not 
specified, the default time slice will be 1/32 of a second. R must be in the range Duration’Smali 
iS R ^ 2.0 and must be greater than or equal to the •timer linker option value. Time slicing only 
api^ies to tasks ninning at equal priority. Because the RTS is a preemptive priority scheduler, the 
highest priority task will always run before any lower priority task. Only when two or more tasks 
are nimiing at the same priority is time slicing applied to each task. 

Tune slicing can be specified <m a per task basis dynamically at run-time. See Section E.I 
(Package RTS.EntiyPoints) for more details. 

Time slicing is not applicable unless tasking is being used. This means that the -tasks option 
must be used for -time^slice to be effective. 


Configurable Data 

The Ada Linker generates the following data: 


.CD_TIME_StlCE_OSID 

0 - Me tlae •lleln^ 

t - rUM tlielng 


_'o_tn«_stice 


■OOT.rJM 


abaolute Integer 


• representing the number Y that satisfies Y * DURATION'SMALL » R 


Example: 

$ adaJink -time^slice 0.125 -tasks p 

• Specifies tasks of equal priority to be time sliced each eighth of a second. 


6JJ0 -timer 
-timer R 

-timer 0.001 (default) 

The -timer option specifies the resolution of calls to the Run-Tune System routine TIMER (see 
the Run-Time System Configuration Guide for DACS-80x86 for more infoimaiion). The number, 
R, specifies a decimai number of seconds which have elapsed for every call to TIMER. The 
default TIMER resolution is one millisecond. R must be in the range DURATION*SMALL< R 
< 2 . 


67 







DACS-80X86 User’s Guide 
The Ada Linker 


Confifurable Data 

The Ada Linker generates the following 16 bit constant: 


CS TZMSa 


Ab»olut> Infar 


• representing the number Y that satisfies Y * DURATION'SMALLsR 


•reserve-stack 
•reserve_stack [n] 


The •reservc_stack option designates how many words are reserved on each task stack. This 
space is leseived for use by the RTS. which does no checking for stack overflow. This reserved 
space also allows the RTS to function in situadons such as handling a storage error exception 
arising from stack overflow. 

The •reserve_stack option also reserves pan of the main program stack size, specified by the 
linker option •mp_stack_size. 


Configurable Data 


The Ada Linker generates the following integer constant: 


CQ XUnVE 3»CK 


iMTgaro 


Examples: 

S ada-Iink •reserve_stack 200 -tasks p 

• Reserve 200 words from each stack for use by the RTS. 


6JJ2 -It-stack-size 

-It_stack_si 2 e n 
-It-stacklsize 500(dehuilt) 

The •lt_stack_size option designates the library task default size in words. A library task is 
formed ~when*a task objea is declared at the outermost level of a package. Library tasks are 
created and activated during the initial main program elaboration. (See the Ada Reference Manual 
for more details). 


68 










DACS-80x86 User's Guide 
The Ada Linker 


For each library task, the repieseniadon spec: 

FOR Task^object’STORAGE_SIZE USE N; 

can be used to specify the library task stack size. However, if the representation spec is not used, 
the default library task size specified by •lt_stack_size wiU be used. 

FOr efficiency reasons, all tasks created within library tasks will have stacks allocated within the 
same segmetu as the library task stack. Nonnally. tire segment which contains the library task 
stack is allocated just large enough to hold the default Uteary task stack. Therefore, one must use 
the option •It-stack.option or the pragma LT_SEGMENT_SIZE to reserve more space within the 
segmem that may be used for nested tasks’ stacks. (See the implementation dependent pragma 
LT_SEGMENT_SI2 in Section F.l for more information). 

The range of this parameter is limited by physical memory size, task stack size allocated during 
the build phase of the link, and the maximum segmem size (64K for all except the 386/486 
protected mode, which is 4 GB). 

Conflgurable Data 

The Ada Linker generates the following integer constant: 


CD L7 STACK SIZX 


IMTtCEK 


Example: 

S ada-link *lt_stack_size 2048 ‘tasks p 

• Link the subprogram P using a 2K words default library stack size. 


6J.23 ‘It-stack-size 
•lt_seginent_size n 

•lt_segment_size (It- s tack-size •«' 20 exception_stack_space) (default) 

This parameter defines in words the size of a library task segment. The library task segment 
contains the task stack and the stacks of all its nested tasks. 

The default value is only large enough to hold one default task stack. If •lt_stack_size is used and 
specifies a value other than the default value, -U_segment_size should also be specified to be the 
size of <task.stadc_size> + 

<total_of.nested_tasks_sizes> 

<20_words_overhead> + 
exception_stack_space. 

Note that the task stack size specified by the 'STORAGE.size can be representation spec or by 
the option •It-stack.size. 

Dynamically allocated tasks receive their own segmem equal in size to the mp_segmem_size. 


69 









DACS-80)c86 User’s Guide 
The Ada Linker 


The range of this parameter ts limited by physical memory size, task stack size allocated during 
the build phase, md the maximum segmem size (64K for all except the 386/486 protected mode, 
which is 4 GB). 

Configurable Data 

The Ada Linker generates the foUowing data smicturt: 


CO IT 


ISZX 



Example: 

$ ada-Unk •h.segment^size 2048 -tasks p 

• Link the program P using a library tadc segmem size of 2K words. 


6JJ4 -mp-stack-size 


•mp_stack_stze n 
•mpistackisizc 8000 (default) 


The -mp^stack^size option specifies the main program stack size in words. 

The range of this parameter is limited by physical memory size, task stack size allocated during 
the build phase (in tasking programs only), the maximum segmem size (64K for all except the 
386/486 protected mode, which is 4 GB). and the size of mp.segmem.size. 


Configurable Data 

The Ada Linker generates the following dau structures for nomasking programs: 


CD Mf STACK Size 


mregER 


CD M» STACK 


Mr_STACK SXZS 
weed* ot~ 
wtatmam 


CO MS STACK_START 


HSclMst «ddr. 
ot tw »t«eX 


For tasking programs, the Ada Linker generates the same structures but limits the size to 1024 
words. This stack is only used for the execution of the system sartup code and elaboration. 
At main program activation, a segmem for the main program equal to the size specified by • 
•trq>_segment_size will be allocated from the dynamic memory pool and a stack for the main 
program equaT to the size specified by -mpjstack^alK wifi be allocated from the memory 
pool. 


70 








DACS-80x86 User’s Guide 
The Ada Linker 


Example: 

$ ada-Iink •mp_suck_size 1000 p 

• Link the subprogram P with a stack of 1000 words. 


6JJS -mp-segment-size 


•inp_segnient_size n 
•mplsegmentlaize 8100 (Default) 

The •iiq>_s^nient_size option specifies the size, in words, of the segmem in which the main 
program sack is aUocaied. The ^fault setting can be calculated from the fonnuia: 

mp_segment_size « mp_stack_size + 

overhead (tasks • 1) * 

(overhead <«• task_storage_size) 

Normally, the main program segmem size can be set to the size of the main program su 
However, when the main program contains nested tasks, the stacks for the nested tasks will 
allocated from the data segmem which comains the main program stack. Therefore, when 
main program contains nested tasks, the main program stack segmem must be extended via 
•mp_^seginent_size option. 

The range of this parameter is limited by physical memory size, task stack size allocated during 
the build phase (in tasking programs only), and the maximum segmem size (64K for all except 
the 386/486 protected mode, which is 4 GB). 

Note: Dynamically allocated tasks receive their own segment equal in size to mp_segmem.size. 


Configurable Data 

The Ada Linker allocates the _CD_MP_STACK (see the •nip_stack_size option) within a dau 
segment called _CD_MP_STACK_SEGMENT: 


CO lO STXCX SZOCRT 


W STACK 


HP SZXeX START 


t* STACK SZZZ 


W SZOONT Size 


Example: 

$ ada-link 'tasks •mp_segnient_size 32000 program_a 

Links the sul^gram PR(X3RAM_A, which ctmtains tasks nested in die main program 
allocating 32,000 words for the main program stack segment 


71 









DACS-80X86 User’s Guide 
The Ada Linker 


6JJ6 ♦taak-atonige-aiae 


•task_storafe.suc n 
•taskistoragelaiac 1024 (default) 

This option sets the default storage size in words for stacks of tasks that are not library tasks. 
This value can be overridden with a re p r ese n t a tion clause. 

The range is limited by the size of the lt_segment_size Of it is a subtask to a library task), or by 
mp_segmem_size Of it is a subtask to the main program). 


Configurable Datt 


The Ada Linker generates the following dan structure: 


CO TASK STaUME SZU 


IKTESEK 


6JJ7 •intemipt-entry_tabie 
•intefTupt_entry_table L4I 

The •intemipt^entry^tablc option specifies the range of intemipt vector numbers used by the 
Ada program in mteriupt tasks. 

The number. L. specifies the lowest numbered interrupt harxller. The number. H. specifies the 
highest numbered iiuenupc handler. The range for low and high mtenupis is 0 to 255. 


Configurable Data 

If •inteiTupt_entry_Ubic is specified, the Ada Linker will generate the following dau structure: 


CO U3H imZKMVT 


COWSTAMT 


(X.) 


CO aZSH IM I EKR OPT 


CONSTAHT 


(■) 


CD IMTSIWOPT VKCTOR 


(■-l.+U*S 
words sososTod 
for Intorsupt 
Voetor_ 


If the user ever detects unrestdved references to the symbols: 

_CD_LOW_INTERRUPT 

_CD_HIGH_INTERRUPT 

_CD_INTERRUPT_VECrOR 


72 






DACS-80X86 User's Guide 
The Ada Linker 


the Ada p r ogr a m contains standard intemipt tasks for which the RTS requires the above data 
structure. You must relink the Ada program specifying the •intctTupt_ciUry_table option. 

Example: 

S ada-Iink -tasks •intetTupt_entry_tablc 5,20 p 

• Links the subprogram P, which has standard Ada interrupt entries numbered S 
through 20. 


•{nolenabie-task.Jrace 

•«nable_task_trace 
•noetubie_taisk_trace (default) 

This option instructs the exception handler id produce a stack trace when a task terminates because 
of an unharxUed exception. 


Configurable Data 


CB TRACe EMABLEO 


lOOtEAH 


> 0 - t*ak trme* dia«bl«d 

■ X • tAak ttAC* muiblMi 


6JJ9 -cxccption^space 

•cxception_space n 
•exceptioiu.space OaOh (default) 

Each stack will have set its top area aside for exception space. When an exceptitm occurs, the 
exception handler iruy switch stack to this area to avoid accidetual overwrite below the stack 
bottom (which may 1^ to protection exceptions) if the size of the remaining part of the stack 
is smaller than the N value. Specifying a value «0 will never cause stack switching. Otherwise an 
N value below the default value is not recommended. 


Configurable Data 

CD EXCEmOM SSACX STACE SSSE 


niTEait 


Note that this value is added to all requests for t^rH stack space, thus requiting an increase in the 
requitemems of the ^rptopriate segmm's size 


73 











DACS*80x86 User's Guide 
Hie Ada Linker 


65J0 •iign_oa 
•ligBjNi [<string>] 

When this option is specified the linker will generate code to ouipu a sign cm message, before 
the Ada elaboration is initiated and a sign off message when the target program has terminated 
successfiiUy. If the program tetminates with an imctttghi exception, the sign off message is not 
printed. 

The sign on message consists of: 

START [<sning>] <pR>giam name> 
and the sign off messi^ 

STOP (<strin^] <piogrBm name> 

The <stiing> may contain spaces. e.g. 

•signlam Test 3” (remember the quotes). 

Hiis facility is very usefiil to separate output from several target programs nm alter each other, 
and to verify that a program that produces little or no output has actually been loaded and tun 
successfully. 


74 









APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type SHORT_INTEGER is range -32_768 .. 32_767; 

type INTEGER is range -2_147_483_648 .. 2_147_483_647; 

type LONG_INTEGER is 

range -16#8000_0000_0000_0000# .. 16#7FFF_FFFF_FFFF_FFFF#; 

type FliOAT is digits 6 

range -16#0.FFFF_FF#E32 .. 16#0.FFFF_FF#E32; 

type LONG_FLOAT is digits 15 

range -16#0.FFFF_FFFF_FFFF_F8#E256 .. 16#0.FFFF_FFFF_FFFF_F8#E256; 
type DURATION is delta 2#1.0#E-14 range -131_072.0 .. 131_07l.Gr¬ 
and STANDARD; 


C-1 










APPENDIX F - IMPLEMENTATION-DEPENDENT CHABAC > ERISTICS 


This appendix describes the implementation-dependent characteristics of OACS-80X86^ as required 
in App^ix F of the Ada Reference Manual (ANSI/MIL-STD-181SA). 


F.1 Impiementation-Dependent Pragmas 

This section describes all implementation defined pragmas. 


F.1.1 Pragma INTERFACE-SPELLING 

This pragma allows an Ada program to call a non-Ada program whose name contains characters 
that are i nvalid in Ada subprogram idetuiners. This pragma must be used in conjunction with 
pragma INTERFACE, i.e., pragma INTERFACE must be specified for the Ada subprogram name 
prior to using pragma INTERFACE.SPELLING. 

The pragma has the format: 

pragma INTERF.^CE.SPELUNG (subprogram name, string literal); 

where the subprogram name is that of one previously given in pragma INTERFACE and the string 
literal is the exam spelling of the interfaced subprogram in its native language. This pragma is 
only required when the subprogram name contains invalid characters for Ada identifiers. 

Example: 

function RTS_GetOataSeginent return Integer; 
pragma INTERFACE (ASMS6, RTS_GctDataSegment) ; 

pragma INTERFACE_S?ELI.ING (Rfs_GetOataSegment, ’’RlSMGSTGetOataSegment”) ; 

The string literal may be appended ’NEAR (or ’FAR) to specify a particular method of call. The 
default is ’FAR. This suffix should only be used, wlren the called routines require a near call 
(writing ’FAR is however harmless). If ’NEAR is added, the routine must be in the same segmem 
as the caller. 


¥.12 Pragma LT-SEGMENT-SIZE 

This pragma sets the size of a library task stack segment. 

The pragma has the format: 

pragma LT_SEGMENT_SIZE CT, N); 

where T denotes either a task objea or task type and N designates the size of the library task 


193 







DACS-80x86 User's Guide 
Imp l c m en mion-Dependem Characteristics 


stack segment in words. 


The library task's stack segment defaults to the size of the library task stack. The size of the 
library task stack is normally specified via the repiesentation clause (note that T must be a task 
type) 


for T'STORAGE.SIZE use N; 

The size of the library task stack segment determines how many tasks can be created which are 
nested within the library task. All tasks cteaied within a library task will have their stacks 
allocated from the same segment as the library task stack. Thus, pragma LT.SEGMENT.SIZE 
must be specified to reserve space within the library task stack segmem so that nested tasks' 
stacks may be allocated (see section 7.1). 

The following restrictions ate places on the use of LT.SEGMENT.SIS: 

1) It must be used only for library tasks 

2) It must be placed immediately after the task object or type name declaration. 

3) The library task stack segment size (N) must be greater than or equal to the library task 
stack size. 


F.IJ Pragma EXTERNALJ^AME 


F.lJ.l Function 

The pragma EXTERNAL_NAME is designed to make permanent Ada objects and subprograms 
externally available using names supplied by the user. 


F.IJJ Format 

The format of the pragma is: 

pragma EXTERNAL_NAME(<ada_emity>,<extemal natne>) 
wdKte <ada.entity> should be the name of: 

• a petmaneru object, i.e. an objea placed in the permanent pool of the compilation unit • such 
objects originate from package specifications and bodies only, 

• a constant object. i.e. an objea placed in the constant pool of the compilation unit • (riease 
note that scalar constants are embedded in the code, and composite constants are not always 
{rtaced in the constant pool, because the constant is not considered constant by the compiler. 


194 



DACS-80x86 User’s Guide 
Implememation-Dependent ChiracterisUcs 


• a s ub pr o gr am name, i.e. a name of a subprogram defliwd in this compilation unit • please 
notice that separate subprogram specifications cannot be used, the code for the subprogr^ 
must be ptesimt in the compilation unit code, and where the <extemal name> is a string 
specifying the external name associated the <ada_eiuiQr>. The <extemal names> should be 
unique. Specifying identical spellings for differem <ada_entities> will generate errors at compile 
and/or link time, and the responsibility for this is left to the user. Also the user should avoid 
spellings similar to the spellings generated by the compiler, e.g. E_xxxxx_yyyyy. P.xxxxx, 
C.XXXXX and other internal identifications. The target debug type information associated with 
such external names is the null type. 


F.IJJ Restrictions 

Objects that are local variables to subprograms or blocks cannot have external names associated. 
The entity being made external ("public") must be defined in the compilation unit itself. Attempts 
to name entities from other compilation units will be rejected with a warning. 

When an entity is an objea the value associated with the symbol will be the relocauble address 
of the first byte assigned to the object 


F.l J.4 Example 

Consider the following package body fragment 

paclcago body cxanpl* is 

subtypo striitglO is string (1. .10); 

typo s is 
soeosd 

l«n : intoges; 
val : stringlO; 
end record; 

global_s : s; 

const^s : constant stringlO :« ’’1234567890''; 

pragma EXTERNAL NAME(global s, "GLOBAL^S OBJECT"); 
pragma EXTERNAL'naME( const_s, "C0NST_S"T; 

procedure handle (...) is 

end handle; 

pragma EXTERNAL^KAKE(handle, "KANDLE^PROC"); 


end example; 

The objects GLOBAL.S and CONST.S will have associated the names "GLOBAL_S_OBJECT" 
and "CONST.S". The procedure HANDLE is now also known as "HANDLE.PROC. It is 


195 



DACS-80x86 User’s Guide 
Implemenuiion-Dependent Characteristics 


allowable to assign more than one external name to an Ada entity. 


F.IJJ Object Layouts 

Scalar objects are laid out as described in Chapter 9. For amys the object is described by the 
address of the fim element; the array constraint(s) are NOT passed, uid therefore it is 
recommended cmly to use arrays with known constraints. Non* discrimiiuued records take a 
consecutive number of bytes, wheieas discriminated records may comain pointers to the heap. Such 
complex objects should be made externally visible, only if the user has thorough knowledge about 
the layout 


F.l J.6 Parameter Passing 

The following section describes briefly the fundamentals regarding parameter passing in connection 
with Ada subprograms. For mote deuil, refer to Chapter 9. 

Scalar objects ate always passed by value. For OUT or IN OUT scalars, code is generated to 
move the modified scalar to its destinatiott In this case the stack space for parameters is not 
removed by the procedure itself, but by the caller. 

Composite objects are passed by reference. Records are passed via the address of the first byte 
of the record. Constrained arrays are passed via the address of the first byte (plus a bitoffset when 
a packed array). Unconstrained amys are passed as constrained amys plus a pointer to the 
constraints for each index in the amy. These constraints consist of lower and upper bounds, plus 
the size in words or bits of each element depending if the value is positive or negative 
respectively. The user should study an appropriate disassembler listing to thoroughly understand 
the compiler calling conventions. 

A function (which can only have IN parameters) returns its result in iegister(s). Scalar results ate 
registers/float registers only; composite results leave an address in some registers and the rest, if 
any, ate placed on the stack top. The stack still contains the parameters in this case (since the 
function result is likely to be on the stack), so the caller must restore the stack pointer to a 
suitable value, when the function call is dealt with. Again, disassemblies may guide the user to 
see how a pardcular function call is to be handled. 


F.1.4 Pragma INTERRUPT-HANDLER 

This pragma will cause the compiler to generate fast iruenupt handler entries instead of the normal 
task calls for the entries in the task in which it is spedfled. It has the format: 

pragma INTERRUPT.HANDLER; 

The pragma must appear as the first thing in the spedficaiion of the task object The task must 
be specified in a package and not a procedure. See ^don F.6.2.3 for more details and restrictions 
on specifying address clauses for task entries. 


196 




DACS-80x86 User’s Guide 
bnplemenution-Oq)endent Characterisucs 


F.IJ Pra«iia MONTTOR^TASK 


F.U.l Function 

The prapna MONTTORJTASK is used to specify that a task with a certain structure can be 
handled in a special way by the Run-Tune System, enabling a very efficient context switch 
operation. 


F.IJJ Format 
The format of the pragma is 
pragma MONTTORJTASK; 

The pragma must be given in a task specification before any entry declarations. 


F.UJ Restrictions 

The following restrictions apply on tasks containing a pragma MONTTORJTASK ; 

• Only single anonymous tasks can be "monitor tasks". 

• Entries in "monitor tasks" must be single entries (i.e. not family entries). 

• The task and entry attributes are not allowed for "monitor tasks” and "monitor task" entries. 

• The <declarative paro shouTld only conuin declaration of objects; no types or nested sturcnires 
must be used. 

• The structure of the task body must be one of the following: 

1 . 

task body MOR_TASX Is 
<doel«racivo patt> 
b«9ln 

<scat«Mnc liao 
loop 
solace 

aecope ZSTKi l<paraaMCac_llse> (do 
and]; ~ 

oe 

aecope XiiTiiY_2<pasaMeoe_llae> (do 
<aeaeaaMne"llse> ~ 

and]; " 

ot 

eozminaeo 
and solace; 
and loop; 
and; 


where each entry declared in the specification must be accepted unconditionally exactly once. 


197 





DACS-80x86 User’s Guide 
Iinpleineniaiion*Depenclem Qiaracteiistics 


2 . 

cask body MOH_T&ax la 
<doelaracivo part> 
bodln 

<atacaaMnt llst> 
loop 

•ecopt HOM_Etmy<p«raaMCor_llat>(do 
<acacoMnt_lisc> ~ 

andl; ~ 

and loop; 
ond; 

where the task only has one entry. 

In both cases the declarative pans, tiic statemem lists and the parameter lists may be empty. 
The statement list can be arbitrarily complex, lait no nested selea or accept statements are 
allowed. 

No exception handler in the monitor task body can be given. 

The user must guarantee that no exceptions are propagated out of the accepts. 


F.1,5.4 Example 

The following tasks can be defined 

task LIST UHDLOt la 

praqiM MONITOR tXSK; 

•ntry INSERT (eUM:£LXM TYPE) ; 

•ntty REMOVE(ELIM:out CLEM TYPE); 

•ntry IS_PRESENT(EIJm:ElEM“TYPE; 

RESULT: out~BOOLEMtl ; 

•nd LIST_EMIDLER: 

tnsk body LIST^ERNDLER la 
*d«illn« list* 

bopln 

*lnitl«llz« Hat* 

aalaet 

aceopt INSERT(ELEN:ELEM_TYPEIdo 
*lna«ct In Hat* ~ 

•ad INSERT; 
or 

aeeapt REMOVE(ELEM:out ELEM_TYPE)do 
‘find In Hat and taawvo froa Hat* 
•nd REMOVE 
or 

aeeapt IS_PRESENT(ELEM;ELEM TYPE 

RES: out ioOLEAMIdo 

*scan Hat* 

•nd IS_PRESENT: 
or ~ 
toraanato, 

•nd aalaet 
•nd MON TASK; 


The task can be used 

task typ« L1ST_DSER la 

•nd LIST_OSER; 

task body L2ST_OSER la 


198 






DACS-80x86 User's Guide 
ImpleinenuUon-Dependem Characteristics 


b««tn 

s«X«et 

LIST_aMISLU. IMSCRT (F»ST_EIXM) ; 
~ 

r«ls« niSERT_ElWOR; 

•nd ~ 

loop 

LIST.HAHCIXR ■ INSERT (NEXT_ELBI) : 
•nd loop; ~ 

•nd LIST OSER; 


F.l^ Pragma TASK_ST0RAGE_SIZE (T. N) 

This pragma may be used as an alternative to the attribute 'TASK.STORAGE.SIZE to designate 
the storage size (N) of a particular task object (T) (see section 7.1). 


Impleinentation*Dependent Attributes 
No implementation-dependent attributes are defmed. 


FJ Package SYSTEM 

The specifications of package SYSTEM for all DACS-80x86 in Real Address Mode and 
DACS-80286PM systems are idendcai except that type Name and constant System.Name vary; 




System Name 


DACS-8086 iAPX86 

DACS-80186 iAPX186 

DACS-80286 Real Mode iAPX286 

DACS-80286 Ptoteaed Mode iAPX286,PM 


Below is package system for DACS-8086. 

packapo Syscam Is 

typo Word is now Intofor; 

eypo OWord is now Lon 9 _incopoc; 

typo Onsl^nodNord is ranqo 0..CSS3S; 

for OnsignodMord'SIZE uso 1(; 

typo byto is ran^o 0. .255; 

toe byto'SIZE uso 8; 

subtypo Sogaontid is UnsignodNord; 

typo Addrosa is 

roeord 

offoot : UnsignodNord; 
sognont : SogsMntld; 
ond roeord; 

subtypo Priority is Intogor rango 0..31; 


199 





DACS-80x86 User’s Guide 
bnplenientation-Dependem Charaaeiistics 


typ« MUM la (lAPXSO; 

SYSm MMC ; cenataoc tUaM ;• lAPXSC; 

STOWUS OMZT : constant :• IS; 

MtHORY SIZE : constant :• I 04t_5‘?S; 

tOM IXT ; constant :• -2 147 4S3 447-1; 

: constant 2_l47jrs3 447; 

HAX~OIOITS : constant IS; 

MRX'hMITISSA : constant 31; 

FIlli_OeLTA : constant 241.04E-31; 

TICX~ : constant :• 0.000_,000_12S; 

typo Intorfaco languaga la 

(ASMSS, puas, Ct4. CM REVERSE. 

ASM ACT, RLM ACT, C ACT, C REVERSE ACT. 
ASMJiOAer, PLM~IIOACr, C~NOACr, c'rEVERSE^HOACF) 

typo Excaptlonld la coeecd 

unlt_nua[bor : onslsnodMotd; 

unlqu*_<>uaiUoc : QnslgnodNecd; 

and coeord; 

typo TasXValuo Is now Intogoc; 

typo AeeTaskValuo Is aeeoss TaakValuo; 
typo Ssoaphocovaluo Is now Intovoc; 

typo SoBuphoro Is roeocd 

countoc : Int 040 c; 

flcst : TaakValuo; 

last : TaakValuo; 

SQMoxt : SoosphoroValuo; 

— only usod In BBS. 

and cococd; 

InltSooaphoco : constant Sooaphora :• s«oiaphoxa'(1.0.O.OI ; 
and Systoai; 


The package SYSTEM specification for DACS-80386PM package system is: 

packavo Systoai Is 

typo Word Is now short_IntO 70 c; 

typo OHoed Is now Intodoc; 

typo QNord Is now Lang_Into 9 oc; 

typo CnslgnodNocd is tango 0..4SS3S; 

fee OnslgnodHocd'SIZE usa 14; 

typo OnalgnodDHocd Is tango 0. .144mT_mT4; 

foc OnalgnodONocd'SIZE uao 32; 

typo Byta Is tango 0..2SS; 

for Byto'SZZE uso 8; 

subtypo Sogaontid Is OnslgnodNotd; 

typo Addroaa Is 

cocotd 

oCfsot : OnslgnodDHotd; 
sogsMnt : SogsMntld; 
and taeecd; 


£oc Addrosa uso 
coeord 

offsot at 0 tango 0..31; 
aogaont at 2 tango 0..15; 
and coeoed; 


subtypo Ptloclty la Intogor tango 0..31; 


200 







DACS*80x86 User's Guide 
Implementation-Dependent Characteristics 


typ« Mm la (lASXSSC.rM) : 

SYSTCNJUMB : eoMtant Mm :• lAPX3S<_m; 

STOWUS OMIT : cenatant :• IC; 

MEMOKY SIZE : conataAt :• 1C*1 0000 0000*; 

MZH IKT : eonatanc :• -l««(000 0000 0000 0000*; 

tucTim : eonatanc i«#7rrrJmT_frrT_rnT»; 

MWC~DIOITS : eonatanc 13; 

tttXjiMiTZSSA : eonatanc :• 31; 

TVKtjatLZK : eonatant :• 2*1.0*C-31; 

TZCX~ : eonatanc :• 0.000 000 0C2_S; 


typo lncarfaea_lan 9 ua 9 o la 

(ASMSt, pimc, CSC, ca< rcvzme. 

MM ACT, PIM ACT, C ACT, C_MVEllSE_ACr, 

ASM~ilOACr, PlM~HOACr, CJIOACF, C.REVERSE.MOACT) ; 

typo ExeaptlenZd la raeocd 

unlt_nuabor : OnalfnadSMocd; 
unlquo.nuaiboe : OnalgnodDMord; 
and raeocd; 

cypa TaakValua la now Intagar; 

type AeeTaakValua la aeeaaa TaakValua; 

cypa SOMphoraValua la na« InCagac; 

eypa Saaaphoca la cacorc 

eouncac 
flcac, laac 
SOMaxc 

and caeord; 

InlcSataaphora ; eonatanc SaMphoca :> SaMphora'(l.O.O.O); 
and Syata«; 


F.4 Representation Clauses 

The DACS-80x86'~ fully supports the 'SIS representation for derived types. The representation 
clauses that are accepted for non-derived types are described in the following subsections. 


F.4.1 Length Clause 

Some remarks on implementation dependent behavior of length clauses are necessary: 

• When using the SIS attribute for discrete types, the maximum value that can be specified is 
16 bits. For DACS-80386PM/80486PM the maximum is 32 bits. 

• SIS is only obeyed for discrete types when the type is a part of a composite object, e.g. 
arrays or tecord>. for example: 

type byte is range 0..2S5; 
for byte'size use 8; 

sixteen_bits_allocated : byte; one word allocated 


: inengae; 

; TaakValua; 

: SaMphocaValua; 

— only usad In HOS. 


201 







DACS*80x 86 User's Guide 
Imptemenouion-Dependeni Characteristics 


•i9ht_bit_p*t_«l«ment : array(0..7) of byte; — four words allocated 
type rec is 
record 

cl,c2 : byte; — eight bits per con^onent 

end record; 


• Using the STORAGE.SIZE attribute for a collection will set an upper limit on the total size 
of objects allocated in this collection. If further allocation is anempted, the exception 
STORACE.ERROR is raised. 

• When STORAGE.SIZE is specified in a length clause for a task type, the process stack area 
will be of the specified size. The process stack area will be allocated inside the "standard" suck 
segment Note that STORAGE.SIZE may not be specified for a task object 


F.4J Enumeration Representation Clauses 

Enumeration representation clauses may specify representations in the range of -32767..-4>32766 (or 
.16#7FFF..16#7FFE). 


F.4J Record Representation Clauses 

When representation clauses are applied to records the following restrictions are imposed: 

• if the componem is a record or an unpacked array, it must start on a storage unit boundary 
(16 biu) 

• a record occupies an integral number of storage units (words) (even though a record may have 
fields that only define an odd number of bytes) 

• a record tnay take up a maximum of 32K bits 

• a component must be specified with its proper size (in ^i'5), regardless of whether the 
componem is an amy or not (Please note that record and unpacked array components take up 
a number of biu divisible by 16 (sword size)) 

• if a non-array componem has a size which equals or exceeds one storage unit (16 biu) the 
component must start on a storage unit boundary, i.e. the componem must be specified as: 

componem at N range 0..16 * M • 1; 

where N specifies the relative storage unit number (0.1,...) from the beginning of the record, and 

M the required number of storage uniu (12....) 

• the elemenu in an array componem should always be wholly contained in one storage unit 

• if a componem has a size which is less than one storage unit, it must be wholly contained 
within a single storage unit: 






DACS-80X86 User's Guide 
Impkmenudon-Dependeiu Characteristics 


component at N range X .. Y; 

whete N is as in previous paragraph, and O <s X <s y <> IS. Note that for this restriction 
a component is not required to stan in an integral number of storage units from the beginning 
of the record. 

If the record type contains components which are not covered by a component clause, they are 
allocated consecutively after the componem with the value. Allocation of a record component 
without a componem clause is always aligned on a storage unit boundary. Holes created because 
of componem clauses are not otherwise utilized by the compiler. 

Pragma pack on a record type will attempt to pack the componetus not already covered by a 
reptesemation clause (perhaps none). This packing will b^n with the smaU scalar components and 
larger components will follow in the order specified in the record. The packing begins at the first 
storage unit after the componetus with representation clauses. 


F.4J.1 Alignment Clauses 

Alignment clauses for records are implemented with the following characteristics: 

• If the declaration of the record type is done at the outennost level in a library package, any 
alignmem is accepted. 

• If the record declaration is done at a given static level higher than the outermost library level. 
i.e., the permanent area), only word alignments are accepted. 

• Any record object declared at the outermost level in a library package will be aligned according 
to the alignment clause specified for the type. Record objects declared elsewhere can only be 
aligned on a word boundary. If the record type is associated with a different alignment, an 
error message will be issued. 

• If a record type with an associated alignment clause is used in a composite type, the alignmem 
is required to be one word; an error message is issued if this is not the case. 


F.5 Impieinentation>Dependent Names for Implementation Dependent Components 
None defined by the compiler. 


F.6 Address Clauses 

This section describes the implementation of address clauses and what types of entities may have 
their address specified by the user. 


203 





DACS*80x86 User’s Guide 
Implemenudon-Dependeiu Qiaracieiistics 


F^l Objects 

Address clauses are supponed for scalar and composite objects whose size can be determined at 
compile time. The address clause may denote a dynamic value. 


F.6J Task Entries 

The implementation supports two methods to equate a task entry to a hardware interrupt through 
an addr^ clause: 

1) Direa transfer of control to a task accept statenrem when an interrupt occurs. This form 
requires the use of pragma INTERRUPT.HANDLER. 

2) Mapping of an interrupt onto a normal conditional exury call. This form allows the interrupt 
enc^ to be called from other tasks (without special actions), as well as being called when 
an interrupt occurs. 


F.6J.1 Fast Interrupt Tasks 

Directly transferring control to an accept statement when an interrupt occurs requires the 
implementation dependent pragma INTERRUPT.HANDLER to tell the compiler that the task is 
an interrupt handler. 


F.6,2J Features 

Fast iruerrupt tasks provide the following features: 

• Provide the fastest possible respe-e time to an intenupt 

• Allow entry calls to other tasks during iruerrupt servicing. 

• Allow procedure and function calls during interrupt servicing. 

• Does not require its own stack to be allocated. 

• Can be coded in packages with other declarations so that desired visiblity to appropriate pans 
of the program can be achieved. 

• May have multiple accept statements in a single fast interrupt task, each mapped to a dilTerem 
ituerrupL If more than one interrupt is to be serviced by a single fast iruerrupt task, the accejx 
statements should simply be coded consecutively. See example 2 how tliis is done. Note that 
no code outside the accept statements will ever be executed. 


204 







DACS-80x 86 User’s Guide 
Impiemeiuation-Oependeiu Giaracterisiics 


F.6^ Limitatiofis 

By using the fast iniemipt feature, the user is agreeing to place certain restrictions on the task in 

order to speed up the software response to the intemipL Consequently, use of this method to 

capture interrupts is much faster than the normal method. 

The following limitations are placed on a fast interrupt task: 

• It must be a task object, not a task type. 

• The pragma must appear first in the specific^on of the task objea. 

• All entries of the task objea must be single eturies (no families) with no parameters. 

• The entries must not be called from any task. 

• The body of the task must not contain any statements outside the accept statement(s). A loop 
statement may be used m enclose the acce^(s). but this is meaningless because no code outside 
0e accept statements will be executed. 

• The task may make one entry call to arwther task for every handled interrupt, but the call must 
be single and parameterless and must be made to a normal tasks, not another fast interrupt 
task. 

• The task may only reference global variaUes: no dau local to the task may be defined. 

• The task must be declared in a library package. i.e.. at the outermost level of some package. 

• Explicit saving of NPX state must be performed by the user within the accept sutement if such 
state saving is required. 


F.6J.4 Making Entry Calls to Other Tasks 

Fast interrupt tasks can make entry calls to other normal tasks vi !ong as the entries are single (no 
indexes) and parameterless. 

If such an entry call is made and there is a possibility of the xirmal task not being ready to 
accept the call, the entry call can be queued to the normal task’s entry queue. This can be forced 
by using the normal Ada conditional entry call construct shown below: 

accept E do 
selea 
T.E; 
else 

null; 

end select; 
end E; 

Normally, this code sequence means make the call and if the task is not waiting to accept it 
immediately, caiKei the call and continue. In the context of a fast interrupt task, however, the 
semantics of this construct are modified slightly to force the queuing of the entry call. 


205 





DACS*80x86 User’s Guide 
Implememaiion-Dependeiu Chancterisdcs 


If an unconditional entry call is made aid the called task is not waiting a the conesponding 
accept statement, then the mteinipt task will wait a the entry caU. Altemadvely, if a tim^ entry 
call is made and the called task does not accept the call before the delay ex|nies. then the cai 
will be dropped. The conditional empr call is the preferred method of making task entry calls 
from fast intenupt handlers because it allows the internipt service routine to complete straight 
through and it guarantees queueing of the entry call if the called task is not wadng. 

When using this method, make sure that the interrupt is included in the -intcfTupt_entry_table 
specified at link time. See Section 7.2.1S for mote details. 


F.6JL5 Implemcnution of Fast Interrupts 

Fast interrupt tasks are t»t actually implemented as true Ada tasks. Rather, they can be viewed 
as ;m>cedutes that consist of code simply waiting to be executed when an interrupt occurs. They 
do not have a state, priority, or a task control block associated with them, and ate not scheduled 
to "run" by the run-time system. 

Since a fast interrupt handler is not really a task, to code it in a loop of somekind is meaningless 
because the task will never loop; it will simply execute the body of the accept statemem whenever 
the interrupt occurs. However, a loop construa could make the source code more easily understood 
and has no side effects except for the generation of the execuuble code to implement to loop 
construcL 


F.6J,6 Flow of Control 

When an interrupt occurs, control of the CPU is transferred directly to the accept statemem of the 
task. This means that the appropriate slot in the iruerrupt vector table is modified to contain the 
address of the corresponding fast interrupt accept statement. 

Associated with the code for the accept sutemem is 

at the very beginning: 

code that saves registers and sets (E)BP to look like a frame where the interrupt return 
address works as return address. 

at the very end: 

code that restores registen followed by an IRET instruction. 

Note that if the iruerrupt handler makes an entry call to another task, the interrupt handler is 
completed through the IRET before the rendezvous is actually completed. After the rendezvous 
completes, normal Ada task priority rules will be obeyed, and a task coiuext switch may occur. 

Normally, the interrupting device must be reenabled by receiving ErxM>f-Interrupt messages. These 
can be sent from machine code insertion statements as demonstrated in Exam^e 7. 


206 








DACS*80x86 User’s Guide 
Implememaiion-Dependem Chancteiistics 


F^7 Saving NPX Sute 

If ibe iniemipt handler will perfonn floating point calculations and the state of the NPX must be 
saved because other tasks also use the numeric coprocessor, calls to the appropriate save/restote 
routines mua be made in the statemem list of the accept statemem. These routines art located 
in package RTS.EntryPoints aixi are called RTS_Store_NPX_Statc and RTS_Restore_NPX_Statc. 
See example 6 for more infonnatiotL 


FiklS SUMvge Used 

This section details the storage requirements of fast interrupt handlers. 


F,6JL9 Stadt Space 

A intemipt handler executes off the stack of the task executing at the time of the interrupt. 
Since a fast interrupt handler is not a task it does not have its own stack. 

Since no local dau or parameters are permitted, use of stack space is limited to procedure and 
ftmcdon calls from within the interrupt handler. 


F.6,2.10 Run«Tinic System Data 

No task control Mock (TCB) is created for a fast interrupt handler. 

If the fast interrupt handler makes a task entry call, an erttiy in the .CD^INTERRUPT.VECTOR 
must be made to allocate storage for the queuing mechanism. This table is a nm-time system data 
structure used for queuing interrupts to normal tasks. Each e^ is only 10 words for 8C086/80486 
protected mode compilers and S words for all other compiler systems. This table is created by 
the linker and is constrained by the user through the linker option -inteiTupt^cntry^table. For 
mote information, see Secdon F.6.2.I on linking an plication with Cut interrupts. 

If the state of the NPX is saved by user code (see Secucn F.62.7), it is done so in the NPX save 
area of the TCB of the task executing at the time of the interrupt This is appropriate because it 
is that task whose NPX state is being saved. 


F.6J Building an Application with Fast Interrupt Tasks 

This section describes certain steps that must be followed to build an application using one or 
mote fast interrupt harxUets. 


207 






DACS>80x86 User’s Guide 
Implememation-Dependem Characteristics 


F.6J.1 Source Code 

The pragma INTERRUFT.HANDLER which indicates that the intemipt handler is the fast form 
of intemipt handling and not the noimal type, must be placed in the task specification as the first 
statement. 

When specifying an address clause for a fast intemipt handler, the offset should be the interrupt 
number, not the offset of the intemipt in the intemipt vector. The segment is not applicable 
(although a zero value must be specified) as it is not u sed by the compiler for intemipt addresses. 
The compiler will place the interrapt vector ituo the INTERRUFTVECTORTABLE segment For 
real address mode programs, the intemipt vector must always be in segmem 0 at execution time. 
For protected mode programs, the user specifies the intemipt vector locadtm at build time. 

Calls to RTS_Store_NPX_State and RTS.Restore.NPX.State must be included if the state of the 
numeric coprocessor must be saved when the fast intemipt occms. These routines are located in 
package RTS_EntryPoints in the root library. See example 6 for more information. 


F.6JJ Compiling the Program 
No special compilation options are required. 


F.6JJ Linking the Program 

Since fast imerrupt tasks are not real tasks, they do not have to be accounted for when using the 
•tasks option at link time. In fact, if there are no normal tasks in the application, the program 
can be linked without •tasks. 

This also means that the linker options -It^stack^sizc. 'It_segment_^size, •mp_segment_size. and 
•task_storage_size do not apply to fast intmnipt tasks, ex(^ to note that a fast intemipT task will 
executt off the stack of the task ninning at the time of the imemipL 

If an entry call is made by a fast interrupt handler the interrupt number must be included in the 
•interrupt^entryjable option at link time. This optitm builds a table in the run-time system data 
segment uTharulle entry calls of interrupt handlers. The table is indexed by the interrupt number, 
which is bounded by the low and high interrupt numbers specified at link time. 


F.6J.4 Locating/Building the Program 

For real-address mode programs, no special actions need be perfonned at link time: the compiler 
creates the appropriate enoy in the INTERRUFTVECTORTABLE segmem. This segmem must be 
at segment 0 before the first interrupt can occur. 

For protected mode programs no special actions need be performed. The Ada Link auumiatically 
recognizes Ada interrupt handlers and adds them to the IDT. 


208 









OACS-80x86 User's Guide 
ImpkmentaiioQ-Dependeiu Characteristics 


FA4 Examples 

These examples illustnie how to write fast iiuenupt tasks and then how to build the application 
using the fast interrupt tasks. 


F.6.4.1 Example 1 

This example shows how to code a fast interrupt handler Um does not make any task entry calls, 
but simply performs some interrupt handling code in the accept body. 

Ada source: 

with System; 
package P is 

<potentially other declaraijons> 

task FastJnterrupt.Handler is 
pragma INTERRUPT.HANDLER; 
entry E; 

for E use at (segment s> 0. offset » 10); 

end; 


<potentially other declarations> 


end P; 

package body P is 

<potentially other declarations> 

task body Fast_IruerTupt_Handler is 
begin 

accept E do 

<handle inierrupi> 
end E; 
end; 


<potentially other declarations> 


end P. 


with P, 

procedure Example.! is 
begin 

<main piDgram> 
end Examfde.l; 


Compilation and Linking: 


209 










DACS-80x86 User's Guide 
Iiiiplenienutioii>Dependem Chanctehstics 


S ada Exampie^l 

$ ada-link Exaii^e_l ! Note: no other tasks in the system in this example. 


F.6.4J Example 2 

This example shows how to write a fast interrupt handler that services more than one iiueirupt. 


Ada source: 

with System: 
package P is 

task Fast.Int errupt .Handler is 
pragma INTERRUPT.HANDLER; 

entry El: 
entry E2: 
entry E3: 

for El use at (segment »> o. offset «> 5): 

for E2 use at (segment » 0. offset a> 9): 

for E3 use at (segment »> 0. offset s> 11 ); 

end: 

end P: 

package body P is 

task body Fast.Interrupt.Handler is 
begin 

accept El do 

<service imemipt 5> 
end El: 

accept E2 do 

<service interrupt 9> 
end E2: 

accept E3 do 

<service interrupt ll> 
erxl E3: 
end; 


end P. 


Compilation and Linking: 


210 






OACS-80x86 User's Guide 
Impleuieniarion-Dependem Characterisucs 


$ ada Exaiiiple.Z 

$ adaJink 'tasks • Exainple_2 « assumes applicatimi also has notmal tasks (not shown) 


F.6.43 Example 3 

This example shows how to access global data and make a procedure call from within a fast 
interrupt handler. 


Ada source: 

with System: 
package P is 

A : Integer, 

task Fast_Int errupt _Handler is 

pragma INTERRUPT_HANDLER; 
entry E; 

for E use at (segment s> 0. offset s> I6#127#): 

end; 
end P; 

package body P is 
B : Integer 

procedure P (X : in out Integer) is 
begin 

X :» X + 1; 
end; 

task body Fast_InterTupt_Handler is 
begin 

accept E do 
A := A + B; 

P (A); 
end E; 
end; 

end P; 


Compilation and Linking: 

$ ada Example_3 
S ada-link Exani^e_3 


211 






DACS'80x86 User’s Guide 
Implememation-Depenclem Chanctetistics 


F.6.4.4 Example 4 

'This example shows how to make a task entry call and force it to be queued if the called task 
is not waiting at the accept at the time of the call. 

Note that the application is linked with •tasks32. where the tasks are T and the main program. 
Since the fast intemipt handler is making an entry call to T. the techniques used guarantee that 
it will be queued, if necessary. This is accomplished by using the conditional call construa in 
the accept body of the fast iruenupt handler and by including the intemipt in the - 
iitteiTupt_cntry_table at link time. 


Ada source: 

with System; 
package P is 

task Fast.Intemipt.Handk'r is 
pragma INTERRUPT_HANDLEF 
entry E; 

for E use at (segment >> o. offset s> g); 
er.d; 

task T is 
entry E; 
end; 

end P; 

package body P is 

task body Fast.Imemipt.Handler is 
begin 

accept E do 
selea 
T.E; 
else 

null; 

end selea; 
end E; 
end; 

task body T is 
begin 
loop 
selea 
accept E; 
or 

delay 3.0; 
end select; 
end loop ; 
end; 

end P; 


212 





DACS-80x86 User's Guide 
Implememaiion-Dependem Characteristics 


Compilation and Unking: 

S ada Exaniple_4 

S ada-iink 'taslu 2 •interrupt_entry_table 83 Example_4 


F.6.43 Example 5 

This examfde shows how to build an application for 80386/80486 protened mode programs using 
fast interrupt handlers. 


Ada source: 

with System: 
package P is 

task Fast.Interrupt.Handler is 

pragma INTERRUPT_HANDLER; 
entry E; 

for E use at (segment => 0. offset => 17); 
end; 

end P. 

package body P is 

task body Fast_InterTupt_Handler is 
begin 

accept E do 
null; 
end E; 
end; 

end P; 


Compilation and Unking: 

S ada Example_5 
S adaJink -tasks - Exampie_5 


213 






OACS-80x86 User's Guide 
Implemeniadon-Dependem Characteristics 


F.6.4.6 Example 6 

This example shows how to save and restore the state of the numeric coprocessor from within a 
fast interrupt handler. This would be required if other tasks are using the coprocessor to perform 
floating poim calculations and the fast interrupt handler also will use the coprocessor. 

Note that the state of the NPX is saved in the task control block of the task executing at the time 
of the intetrupL 

Ada source: 

with System; 
package P is 

task FastJnterrupt.Handler is 

pragma INTERRUPT.HANDIJER; 
entry E; 

for E use at (segment »> 0, offset 25): 
end; 

end P; 

with RTS.EntryPoints; 
package body P is 

task body Fast.Interrupt.Handler is 
begin 

accept E do 

RTS.EntryPoints.Store_NPX_State; 

<user code> 

RTS_EntryPoints.Rcstore_NPX_State; 
end E; 
end; 

end P; 

Compilation and Linking: 

$ ada Example_6 

$ ada-link -npx ‘tasks • Example_6 


F.6.4.7 Example 7 

This examfrie shows how to send an End-Of-Intemipt message as the last step in servicing the 
interrupt. 


Ada source: 


214 






DACS-80x86 User's Guide 
Implemeiuadon-Dependem Chancteristics 


with System: 
package P is 

task Fast_lntemipt_HaiuUer is 

pragma INTERRUPT.HANDLER: 
entry E; 

for E use at (segment «> 0, offset » S): 
end; 

end P: 

with Machine.Code; use Machine.Code: 
package body P is 

procedure Send.EOI is 
begin 

machinejnstniction’ 

(registerjmmediate. m_MOV. AL. 16#66#); 
machine Jnstiuction’ 

(.mmediate.iegistcr, m_OUT. 16#0e0#, AL): 
end; 

pragma inline (Send.EOI); 

task body Fast.Intenupt.Handler is 
begin 

accept E do 
<user code> 

Send.EOI; 
end E; 
end; 

end P; 

Compilation and Linking: 

S ada Example_7 
$ adaJink 'tasks - Example^? 


F.63 Normal Interrupt Tasks 

"Notmal" intemipt tasks are the standard method of servicing intemipts. In this case the imemipt 
causes a conditional entry call to be made to a notmal task. 


F.6.5.1 Features 

Normal imerrupt tasks provide the following features: 

1) Local data may be defined and used by the interrupt task. 


215 



OACS-80x86 User's Guide 
Implementaiion'Dqxndeiu Characteristics 


2) May be called by other tasks with no restrictions. 

3) Can call other nonnal tasks with no restrictions. 

4) May be declared anywhere in the Ada prograin where a normal task declaration is allowed. 


F.6JJ Limitations 

Mapping of an interrupt onto a normal conditional entry call puts the following constraints on the 
involved entries and tasks: 

1) The affected entries must be defined in a task objea only, not a task type. 

2) The entries must be single and parameterless. 


F.6JJ Implementation of Nonnal Interrupt Tasks 

Normal interrupt tasks are standard Ada tasks. The task is given a priority and nins as any other 
task, obeying the normal priority rules and any time-slice as configured by the user. 


F.6J5.4 Flow of Control 

When an imerrupt occurs, control of the CPU is transferred to an interrupt service routine 
generated by the specificadon of the imerrupt task. This roudne preserves the registers and calls 
the tun-dme system, where the appropriate interrupt task and entry are determined from the 
infotmadon in the _CD_INTERRUFT_VECTOR table and a condidonal entry call is made. 

If the interrupt task is waidng at the accept statement that corresponds to the interrupt, then the 
interrupt task is scheduled for execudon upon return from the interrupt service routitK and the caU 
to the tun-dme system is completed. The interrupt xrvice roudne will execute an IRET. which 
reenables interrupts, and execudon will condnue with the imerrupt task. 

If the interrupt task is not waidng at the accept statement that corresponds to the interrupt, and 
the interrupt task is not in the body of the accept statemem that corresponds to the interrupt, then 
the entry call is automadcally queued to the task, and the call to the tun-dme system is 
completed. 

If the interrupt task is not waidng at the accept statemem that corresponds to the iruerrupt, and 
the iruerrupt task is execudng in the body of the accept statemem that corresponds to the interrupt, 
then the interruiu service roudne will NOT complete until the interrupt task has exited the body 
of the accept statement. During this period, the imerrupt will not be serviced, and execudon in 
the accept body will condnue with interrupts disabled. Users are caudoned that if fiom within 
the body of the accept statemem corresponding to an interrupt, an uncondidonal entry call is made, 
a delay statement is executed, or some other tion-detetminisdc acdon is invoked, the result will 
be erradc and will cause non-detetminisdc interrupt response. 

Example 4 shows how End-Of-Interrupt messages may be sem to the intemqxing device. 


216 








DACS-80x86 User's Guide 
Implemenution-Dependem Characteristics 


F.6JJ Saving NPX State 

Because normal interrupt tasks are standard tasks, the state of the NPX numeric coprocessor is 
saved automatically by the nin-time system when the task executes. Therefore, no special actions 
are necessary by the user to save the state. 


F.6J.6 Storage Used 

This section describes the storage requirements of standard interrupt tasks. 

F.6J.7 Stack Space 

A normal interrupt task is allocated its own stack and executes off that stack while servicing an 
interrupt. See the appropriate sections of this User’s Guide on how to set task stack sizes. 


F.6J,8 Run>Time System Data 

A task control block is allocated for each normal interrupt task via the 'tasks option at link time. 

During task elaboration, an entry is made in the run<time system .Q> JNTERRUPT.VECTOR 
table to "define" the standard interrupt This mechanism is used by the nm-time system to make 
the conditional entry call when the interrupt occurs. This means that the user is responsible to 
include all interrupts serviced by interrupt tasks in the •interrupt_entry_table option at link time. 


F.6.6 Building an Application with Normal Interrupt Tasks 

This section describes how to build an application that uses standard Ada tasks to service 
interrupts. 


F.6.^.1 Source Code 

No special pragmas or other such directives are required to specify that a task is a normal interrupt 
task. If it contains iruerrupt entries, then it is a normal iiuerrupt task by default 

When specifying an address clause for a normal inrerrupt handler, the offiset should be the 
interrupt number, not the offset of the interrupt in t\e interrupt vector. The segmeru is not 
applicable (although some value must be specified) because it is not used by die compiler for 
in terrup t addresses. The compiler will place the interrupt vector into the 
INTERRUPTVECTORTABLE segment Fbr teal address mode programs, the interrupt vector 
must always be in segmem 0 at execution time. This placemem can be accomplished by specifying 


217 






DACS-80X86 User's Guide 
Iroplementaiion-Dependem Characteristics 


the address to locate the INTERRUFTVECTORTABLE segment with the loc86 command, or at 
run time, by having the startup code routine of the UCC copy down the 
INTERRUPTVECTORTABLE segment to segmeiu 0 and the compiler will put it there 
automatically. For protected mode programs, the user specifies the interrupt vector location at 
build time. 


F.6.6J Compiling the Program 
No special compilation options are required. 


F.6.6J Linking the Program 

The interrupt task must be included in the 'tasks option. The link options •lt_stack_size, — 
lt_segment_size. 'mp^segment^size. and 'task^storage^size apply to normal interrupt tasks and 
must be sef to appropriate values for your appOication. ~ 

Every interrupt task must be accounted for in the •interrupt_entry_table option. This option 
causes a table to be built in the run-time system data segment to handle interrupt entries. In the 
case of standard interrupt tasks, this table is used to map the interrupt onto a normal conditional 
entry call to another task. 


F.6.7 Examples 

These examples illustrate how to write normal inietTU{k tasks and then how to build the af^lication 
using them. 


F.6.7.1 Example 1 

This example shows how to code a simple normal imerrupt haruUer. 

Ada source: 

with System: 
package P is 

task Normal_Ituerrupt_Handler is 
entry E; 

for E use at (segment » 0, offiset «> 10); 

end: 
end P; 

package body P is 

task body Normal_Imerrupt.Handler is 


218 







DACS-80x86 User's Guide 
Imidemeittation-Dependetu Characteristics 


begin 

accept E do 

<handle imerrupo 
end E; 
end; 


end P; 
with P; 

procedure Example.l is 
begin 

<main prograin> 
end Example.l; 


Completion and Linking: 

$ ada Exampie^l 

$ adaJink •usks 2 •inteiTupt_entry_tablc 10,10 Example_l 


F.6.7J Example 2 

This example shows how to write a normal intemipt handler that services more than one interrupt 
and has other standard task entries. 

Ada source: 

with System; 

package P is « 

task Notmal.Task is 
entry El; 

entry E2; - standard entry 

entry E3; 

for El use at (segment »> 0, offset «> 7); 
for E3 use at (segment «> 0, offxt »> 9T. 

end; 

end P; 

package body P is 

task body NotmaiJTask is 
begin 
loop 
selea 

accept El do 

<service inienupt 7> 


219 






OAC:S-80x86 User's Guide 
Implemenmion-Dependem Characteristics 


end El; 
or 

accept E2 do 

<standatd fendezvous> 
end E2; 
or 

accept E3 do 

<service iiuemipt 9> 
end E3: 
end select; 
end loop; 

end Notinal.Task; 
end P; 

Compilation and Linking: 

S ada Example_2 

$ ada-link ‘tasks •interrupt_enti 7 _table 7^ Exampie_2 


F.6.7J Exampie 3 

This example shows how to build an application for 80386 protected mode programs using normal 
interrupt handlers. 


Ada source: 

with System; 
package P is 

task Noimal.Interrupt.Handler is 
entry E; 

for E use at (segmera »> 0. offset s> 20); 
end; 

end P; 

package body P is 

task body Noimal_InterTupt_Handler is 
begin 

accept E do 
n^; 
end E; 
end; 

end P; 


220 



DACS'80x86 User’s Guide 
Implememaiion-Dependem Quiacteiistics 


Compilation and Linking: 

S ada Exaniple_3 

$ adaJink -tasks •intemipt_entry_Table 203 Exanipie_3 


F.6.7.4 Example 4 

This example shows how an End-Of-Intemipt message may be sent to the intemipting device. 

Ada source: 

with System; 
package P is 

task Normal_Interrupt_Handlcr is 
entry E; 

for E use at (segment >> 0, offset » 7); 

end; 


end P; 

with Machine_Code; use Machine_^Code; 
package body P is 

procedure Send_EOZ is 
begin 

machine^instruction' 

(regiscer_immediate, m^MOV, AL, 16*66#); 
fflachine__inatruction' *** 

'”(imniediate_register, m^OUT, 16#0e0#, Al) ; 
end; ” ” 

pragma inline (Send_EOI); 

task body Normal__Znterrupt_Handler is 
begin 

accept E do 
<user code> 

Send^EOI; 
end E; 

end; 


end P; 


Compiiation and Linking: 

S ada Exanq)le_4 

$ ada-Iink -tasks -internipt_entry_tabic 7,7 Example_4 




221 







DACS-80x86 User’s Guide 
Implemenution'Dependeru Chancierisucs 


F.&J Interrupt Queuing 

DDC-I provides a useful feature that allows task entry calls made by internipt handlers (fast and 
normal variam) to be queued if the called task is not waiting to accept the call, enabling the 
interrupt handler to complete to the IRET. What may not be clear is that the same interrupt may 
be queued only once at any given time in DDC-I's implementation. We have made this choice 
for two reasons: 

a) Cluing does not come for free, and queuing an iruerrupt more than once is considerably 
more expensive than queuing just one. ODC-I feels that most customeis prefer their 
interrupt handlers to be as fast as possible and that we have chosen an implemetuatitm that 
balances performance with functionality. 

b) In most applications, if the servicing of an interrupt is not perfomied in a relatively shon 
period of time, there is an unacceptable and potentially dangerous situation. (Queuing the 
same interrupt more than once represents this simadon. 

Note that this note refers to queuii^ of the sairw interrupt more than once at the same bme. 
Different interrupts may be queued at the same time as well as the same interrupt may be queued 
in a sequential maimer as long as there is never a situation where the queuing overlaps in bme. 

If it is acceptable for your application to queue the same interrupt more than once, it is a 
relatively simple procedure to implement the mechanism yourself. Simply implement a high 
priority agent task that is called from the interrupt handler. The agent task accepts calls from the 
iruerrupt task and makes the call on behalf of the iruerrupt handler to the originally called task. 
By careful design, the agem task can be made to accept all calls from the interrupt task when they 
are made, but at the very least, must guarantee that at most one will be queued at a time. 


F.6.9 Recurrence of Interrupts 

DDC*I recommends the following techniques to etBure that an iruerrupt is completely handled 
before the same interrupt recure. There are two cases to consider, i.e. the case of fast interrupt 
handlers and the case of normal interrupt handlers. 


F.6,9.1 Fast Interrupt Handler 

If the fast interrupt handler makes an entry call to a normal usk. then place the code that 
reenaUes the iruerrupt at the end of the accept body of the called task. When this is done, the 
interrupt will not be reenabled before the rendezvous is actually completed between the fast 
interrupt handler and the called task even if the call was queued. Note that the interrupt task 
executes all the way through the IRET before the rendezvous is completed if the entiy call was 
queued. 

Normally, endof-iiuerrupt code using Low_LevelJO will be presem in the accept body of the fbst 
interrupt handler. 'This implies that the end-of-iiuerrupt code will be executed before the 
rendezvous is comideted, possibly allowing the iruerrupt to come in again before the application 
is ready to handle it 

If the fast internipt handler does not make an emiy call to another task, then placing the 


222 











DACS-80x86 User's Guide 
Imtdementaiion-Dependent Chancterisucs 


end-of'tmenupt code in the accept body of the fast intemipt task will guarantee that the intenupt 
is completely serviced before another interrupt happens. 


F.tk9J Normal Interrupt Handler 

Place the code that reenables the intemipt at the end of the accept body of the normal intemipt 
task. When this is done, the intenupt will not be reenabled before the rendeivous is actually 
completed between the nonnal intenupt handler and the called task even if the call was queued. 
Even though the intenupt "completes" in the sense that the IRET is executed, the interrupt is not 
yet reenabled because the rendezvous with the normal task’s interrupt entry has not been made. 

If these techniques are used for either vailam of interrupt handlers, caution must be taken that 
other tasks do not call the task entry whidi reenables interrupts if this can cause adverse side 
effects. 


FJ Unchecked Conversion 

Unchecked conversion is only allowed between objects of the same "size". However, if scalar type 
has different sizes (packed and unpacked), unchecked conversion between such a type and another 
type is accepted if either the packed or the unpacked size fits the other type. 


F.8 Input/Output Packages 

In many embedded systems, there is no need for a traditional I/O system, but in order to suppon 
testing and validation, DOC-I has developed a small tenninai oriented I/O system. This I/O system 
consists essentially of TEXT JO adapted with tespea to handling only a terminal and not file I/O 
(file I/O will cause a USE eiror to be raised) and a low level package called 
TERMINAL.DRIVER. A BASICJO package has bem provided for convenience purposes, 
forming an interface between TEXT JO and TERMINAL.DRIVER as illustrated in the following 
figure. 



The TERMINAL.DRIVER package is the only package that is target dependent. i.e.. it is the only 


223 






DACS>80x86 User’s Guide 
Implememation-Dependeiu Characteristics 


pack age that need be changed when changing communications controllers. The actual body of the 
TER>^AL_DRIVER is written in assembly languai^ and is part of the UCC modules DlIPUT 
and DIIGET. The user can also call the tenninal driver routines directly, i.e. from an assembly 
language routine. TEXT.IO and BASICJO are written completely in Ada and need not be 
changed. 

BASICJO provides a mapping between TEXT JO control characteis and ASCI as follows: 
TEXT.IO ASCI Character 


LINE_TERMINATOR 

ASCLCR 

PAGE_TERMINATOR 

ASCIEF 

FILE_TERMINATOR 

ASCLSUB (CTRUZ) 

NEW.UNE 

ASCIXF 


The services piovided by the tenninal driver are: 

1) Reading a character from the communications port. Get.Character. 

2) Writing a character to the communications port. Put.Character. 


F.8.1 Package TEXT JO 

The specification of package TEXT JO: 

pra^M p«9«; 
with BASIC_XO; 

with IO_EXCmiaNS; 
p«ek«9«~lSXT_IO la 

typ« riU_TTPe is liatltaU ptlvata; 

typ« riujaoDe is (iN_riLE. ooT.ntx); 

cyp* COUNT is ran«« 0 .. INTSGER' lAST; 

subtypa POSXTZVE_COOHT is COONT tang* 1 .. COOMT’LAST; 

UMBOONDEO: constant COONT:• 0; — lln* and pag* length 

" nax. sis* of an int*g*c output field 2*-* 

subtyp* rXXLO is XHTECCR rang* 0 .. 3S; 

subtyp* HOHaCR.BASe is XNTS6» rang* 2 .. IC; 

typ* TTVe.SCT is (X,ONn_CASE, OPPBR_CASE); 

pragaa PACE; 

— File ManagasMnt 


proeedur* CNEATE 

(FXLE 

a 

0 

c 

FXLE TTPE; 


MODE 

: in 

FXLE~HOOE 


NAME 

: in 

STRSM 


fOPM 

); 

: in 

snuiKi 

ptoeadur* OPEN 

(FXLE 

: in out 

FXLE TTPE; 


MODE 

: in 

FXLE~NaOE; 


NAME 

: in 

smriis; 


224 







DACS*80x86 User's Guide 
Implementation-Dqjendeni Characteristics 


ram : tn sniziw 

); 


ptocaeun CLOSt (FILE 
preeadut* OCIXTE (riu 
precaUur* RESET (Flix 
HOOE 

pree*dur« RESET (FILE 

function NODE (FILE 
function HRMB (FILE 
function FORM (FILE 

function IS_OFE»(FILE 

pcnpM tKStt 

— eonteoi of SofouXt 


: in out FILE TTFE); 

: in out FILeIttFE); 

; in out FILE'tTFE; 

; in FILE MOOC); 

: in out FILE_TT»E); 

: in FILE TYFE) rotucn FILE MODE; 
; in FILE~TTFE) rotutn STRIMG; 

; in FILE~TTFE) rotttxn STRUK; 

: in FILE TTFE totutn ROOLERH; 


input «nd output filoa 


psocoduco SET INFOT (FILE : in FILE.TTFE): 
procoduro SET~OOTFOT (FILE : in FILE'rTFE); 


function STAMBARD IRFOT cotucn FILE TTFE; 
function STA1I0AR0~'00TF(>T rotum riLE~TTFE; 


function CURREin_IMFOT rotucn FILE.TTFE; 
function CDRREMT~ Omvt rotucn FILE'ttFE. 


pragma PAGE; 

— apoeifieotlon of lino and pogo longtha 


procoduro SET_LIME_LEtiSTB 
procoduro SET_LIME_LE11CTB 


(FILE : in FILE TTFE; 

TO ; in COOHT); 

(TO : in COONTt; 


procoduro SET^FAiSE^LEMQTfl 
procoduro SET^FASE.LEtKTB 


(FILE : in FILE TTFE; 

TO : in COONT); 

(TO : in COOMT); 


function Lme.LoiaTR 
function LIKE LEN<»S 


(FILE : in FILE_TTFE) 
rotum COONT; 
rotum COONT ; 


function FAse_LEN(RH 
function tAOt LENGTB 


(FILE ! in FILE_TTFE) 
rotum COONT; 
rotum COONT; 


pragma tASE; 

— column. Lino, and Fago Control 

procoduro HEN LINE (FILE : in FILE TTFE; 

~ SFACING : in POSITIVE COONT :• 1); 

procoduro NEN_LINE (SPACING : in POSITIVE~COONT :• 1); 

procoduro SKIP LINE (FILE : in FILE TTFE; 

SPACING : in POSITIVE COONT :<• 1); 
prceoduro SXIP.LINE (SPACING : in POSITIVE~COONT :•> 1); 

function END OF LINE (FILE : in FILE TTFE) rotum BOOLEAN; 
function EN0J3F~LINE ~ rotum BOOLEAN; 

proeoduro NEN^FAGE (FILE : in nLE_TTFE); 
procoduro NEH~FA6E; ~ 

procoduro SKIP PAGE (FILE : in FILE TTFE); 
procoduro SXIF'pACE; 

function END OF_PAGE (FILE : in FILE_TTFE) rotum BOOLEAN; 

function EHO~OF~FAGE ~ rotum BOOLEAN; 

function END OF FILE (FILE : in FILE TTFE) rotum BOOLEAN; 
function END~OF~FILE ~ rotum BOOLEAN; 


225 







DACS-80x86 User’s Guide 
Implemeiuation*Dependent Characterisucs 


ptoeaduro 

SET_COI. 

(FILE : 

In FILE TYPE. 



TO 

in POSITIVE COOMT) 

pceeaduta 

SET_COL 

(to ; In POSITIVE_COONT); 

pfoeaduca 

SET_LDIE 

(FILE : 

in FILE TYPE; 



TO : In POSITIVE COONTI: 

proeadura 

SET_LniE 

(TO ; In POSITIVE'cOOMT); 

function 

COL 

<riLE : 

: in FILE TYPE) 



return 

POSITIVE“cO0MT; 

function 

COL 

r«tum 

POSITIVe'cOOKT; 

function 

LIME 

(rZLS : 

: in FILE TYPE) 



return 

POSITIVE~COOMT; 

function 

LIME 

return 

POSITIVe'cOOHT; 

function 

PAGE 

(FILC 

: in FILE TYPE) 



return 

POSITIVE~COOMT; 

function 

PACE 

return 

POSITIVe“C00NT; 


ptaqM PASE; 

— Charaetat Input-Output 


procaduta GET (FILE 

; in FILE TYPE; 

ITEM ; 

out 

CBARACTER); 

proeadura GET ( 



ITEM : 

out 

CEARACTER); 

proeadura POT (FILE 

: In FILE TYPE; 

ITEM : 

in 

CHARACTER) ; 

proeadura POT ( 



ITEM : 

in 

CHARACTER) ; 

— String Input-Output 





proeadura (XT (FILE 

: In FILE TYPE; 

ITEM 

out 

CHARACTER) ; 

proeadura GET ( 



ITEM 

out 

CHARACTER) ; 

proeadura POT (FILE 

; In FILE TYPE; 

ITEM 

in 

CHARACTER) ; 

proeadura POT ( 



ITEM 

in 

CHARACTER) ; 

proeadura GET_LIME 

(FILE 

In FILE TYPE; 




ITEM 

out sntniG; 




LAST 

out NATOMAL); 



proeadura GET_LZNE 

(ITEM 

out STMIMG; 




LAST 

out MATOMAL); 



proeadura POT_LIME 

(FILE 

in FILE 

TYPE; 




ITEM 

in STRING); 



proeadura POT.LIME 

(ITEM 

in STRING); 




prapM PAGE; 

— Sanacle Paekavn tor Input-Output of Inta^ac Typaa 
gonorle 

typo ROM la rang# o; 


pae)cago INTE(XR_IO 

la 


OEFAOLT_WIOTH ; 

FIELD 

NOM'WIDTH; 

DEFAOLT_BASE 

NOMBER_HASE :• 10; 

proeadura GET 

(FILE 

ITEM 

NIOTB 

In FILE_TYPE; 
out nomT 

In FIELD :• 0); 

proeadura GET 

(ITEM 

nioth 

out MOM; 

In FIELD :• 0); 

proeadura P(R 

(FILE : 
ITEM 
WIDTH 
BASE 

In FILE TYPE; 

in nomT 

In FIELD :> DErJUXT WIDTH; 
in MDMBER base :• DEFAOLT_BASE) ; 

proeadura POT 

(ITEM 

WIDTH 

BASE 

In NOM; 

In FIELD :> DEFAOLT NIDTB: 

In MOMBER_BASE D&AOLT_BASE) ; 

proeadura GET 

(FROM 

ITEM 

: In STRING; 

: out ROM; 


226 







DACS-80x86 User's Guide 
Implemenution>Dependent Characteristics 


UUtT ; out rOSITXVC); 

pr:=«eur« POT (TO : e«t STRIMG; 

ITIM In mm; 

B&n : tn IIOHBeR_B»3E OErM>LT_BASS) ; 

•nd niTKSn 10; 


prnqM PJUiE; 

" 6«n«rle Packaona ter Input-Output of Raal Typaa 
oanarlc 

typa mm la dlglta O; 
paekaga rLOllT_IO ta 

OXTAOtT FORE : FIELD ;• 2; 

OEFAin.T'*Arr : FIELD MOM'DISITS • 1; 

OEFAOLT'eXP : FIELD ;• 3; 

proeaduta SET (FILE : In FILE TTPE; 

iTEM : out mmT 

WIDTH : in FIELD :• 0); 
proeadura (XT (ITEM : out MOM; 

WIDTH : In FIELD 0); 

pcocadura POT (FILE : in FILE TYPE; 

ITEM : In mm;~ 

FORE ; in FIELD :> DEFAOLT FORE; 
AFT ; in FIELD DEFAOLT'AFT; 

EXP : in FIELD ;• OEFAOLT^EXP) ; 
proeadura POT (ITEM : in MOM; ~ 

FORE ; in FIELD :• UFAOLT FORE; 
AFT ; tn FIELD ;« DEFAOLT*AFT; 
EXP ; in FIELD ;<• DErAOLT~EXP) ; 

proeadura GET (FROM : in STRIMS; 

ITBt ; out MOM; 

LAST ; out POSITIVE); 
proeadura POT (TO : out STRIMS; 

ITEM : in MOM; 

AFT : in FIELD DEFAOLT AFT; 

EXP in FIELD DEFAOLT'exP); 

and FLOAT^IO; 


pragHM PAGE; 
ganarle 

typa MOM ia dalta o; 
paekaga FIXED 10 ia 


DEFAOLT FORE : 

FIELD 

• MOM'FORE; 


DEFAOLT~AFT : 

FIELD 

- MOM'AFT; 


DEFAOLT~EXP 

FIELD 

- 0; 


proeadura GET 

(FILE 

; in FILE TYPE; 


ITEM 

: out MOM; 



WIDTH 

: in FIEID 

0); 

proeadura (XT 

(ITEM 

: out MOM; 



WIDTH 

: in FIELD 

0); 

proeadura POT 

(FILE : 

: in FILE TYPE; 


ITEM 

: ia MOM; 



FORE 

; in FIELD i 

> DEFAULT FOTEi 


AFT 

: in FIELD : 

- D0AOLT~AFT; 


EXP 

; la FIELD : 

> OEFAOLTJBXPK 

proeadura POT 

(ITEM 

: in MOM; 



FORE 

: in FIELD ! 

DEFAOLT FORE. 


AFT 

: in FIELD : 

OEFAOLT*AFT; 


227 


















DACS*80x86 User’s Guide 
Iiiipleraeiuaiion>DepeiKlent Characteristics 


s» : In rxsLo 0Erjun.T_exa) ; 

proewlur* «T (laoH ; in sTazMO; 

IXCM ; out MCH; 

LAST ; out POSITIVE): 

ptocoUuto POT (TO : out SraZHO: 

ITEM : in MOM: 

AFT : In PIELO :• OErAOlT ATT: 

EXP In FIELD :> OEFAOLT'eXP): 

•nd FIXES 10: 


ptnOM PASE; 

— Sonosle Poc)u 9 « for Input-Output of BnuMtotlon Typoa 


gonorle 

typo EMON la (<» : 
paelug# EMOMEPATIOH 10 la 


DEFAULT NIDTE 

: FIELD 

:• 0; 


DEFAULZ^SETTIMa 

: TyPE_ 

SET UPPERj 

CASE; 

procaduro SET 

(FILE ; 

in F1LE_TTPE; 

ITEM : out ENOM); 

preeadura SET 

( 


ITEM ; out ENOM); 

procaduro PUT 

(FILE 

FILE TYPE: 



ITEM 

In nUM; 



NIDT8 

: In FIELD 

DEFAULT WZDTB; 


SET 

: In TYPE SET 

.— DEFAOLT^SETTZNG) ; 

procaduro PUT 

(ITEM 

In enumT 



NIDTB 

In FIELD 

:• DCFAULT^WIOTB: 


SET 

; In TYPE_3ET 

OEFAULt'sETTING); 

procaduro SET 

(FROM ; 

In STRING: 



ITEM : 

out EMUM; 



LAST ; 

out POSITIVE) 

<• 

procaduro PUT 

(TO 

out STRING; 



IT» : 

in EMON; 



SET : 

In TYPE SET 

OEFAOLT_SETTINS); 

and ENUNBRATION.IO; 




pragaa PACE: 


" Exeoptlona 

STATOS EMOA : oxcaptlon ranaaMa 10 EXCEPTIONS.STATUS EMIOR: 

NOOEJEMIOR : oxcaptlon tonaawa IO~EXCEPTZOHS.NOOE_EiwOR: 

HAME~EiaiOR : oxcaptlon ronoaos I0~EXCEPTIONS.ilAHE'‘EMIOR; 

OSEjDOmt : oxcaptlon ranaaMa IO~EXCEPTiaNS.DSE_EIU«OR; 

DEVICE Emm : oxcaptlon ranaaMa IO'eXCEPTIONS . DEVICE ERROA; 

END.ERim : oxcaptlon ranaaaa I0'*EXCEPTiaNS.END_ERmR: 

DATA ERROR : oxcaptlon ranaaMa Io'eXCEPTIONS.DATA ERROR; 

LAYOOT^ERROR : oxcaptlon ranaaaa lOJEXCEPTlONS.tATOOTJERROR; 

praqaa pa«a; 
prlvata 

typo FILEjntE la 
roeord ~ 

FT : INTESER :> -1: 
and roeord; 

and TEXT_IO; 


228 









DACS-80x86 User’s Guide 
Implemeiuation-Dependent Characteristics 


FA2 Package IO_£XCEPnONS 

The specification of the package lO.EXCEFTIONS: 


paek««« to.cxecrrxoMS is 

STATOS XMOR : •xcaptien; 
NOOE_imOA : •xeaptlen; 
HAMTCAAOK : •xeaptlen; 
OSt.SKnOR ; wceaptlon; 
oevfea error : Mieaptiea: 
END ERROR : •xeaptlen; 
OAU ERROR ; wceaptlon; 
LATOOT.ERROR : •xeaptlen; 

•nd 10 EXCSRTZONS; 


Package BASIC-IO 
The ^ciflcation of package BASICJO: 


with IO_EXCEPTIGMS; 
paekapa aASIC_IO la 

typa eeunt la ranpa 0 .. Intapar'last; 

aubtypa pealtlva^eeunt la eeunt eanpa 1 .. eeunt'last; 


funetlen 9 at_lnta 9 ac catucn atrlnp; 

Skips any laadlnp Alanka, line taaalnatera oc papa 
-- taamlnatets. Than raada a plus es a alnua slpn 1C 

— prasant, than taads aeeerdlnp te tha syntax of an 

— Intapar lltaral, whieh any ba basad. steras In Item 
•• a sttlnp eentalnlnp an eptlenal slpn and an intapar 

— lltaral. 

" tha axeaptlen OATA_ERROR la ralsad 1C tha sapuanea 

— eC eharaetars daas~net eerraspend te tha syntax 
—> daserlbad above. 

— Tha axeaptlen aiD_ERROR is ralsad 1C tha Clla taxaUnater 
" IS read. This swans that tha startlnp saquanea eC an 

-- Intapar has not boon aat. 

— Meta that tha eharaetar tanUnatlnp tha eparatlen wist 

— ba available Cos tha next pat eparatlen. 

Cunetlen pat_raal ratum strlnp; 

— Cerrasponds to pat_lntapae oxeapt that It raada aeeerdlnp 
" to tha syntax oC a~raal lltaral, whieh aay ba basad. 


Cunetlen pat_aauswratlen ratum strlnp; 

— Cerrasponds te pat_lntapar oxeapt that It roads aeeerdlnp 
te tha syntax eC an idantlClar, whora upper and lewor 

~ ease letters are equivalent te a eharaetar literal 

— ineludlnp tha apestrephas. 


229 










DACS-80x86 User's Guide 
Implemenuiion-Dependeitt Quracteiistics 


ruaetlen (iM^th : in lnea 9 «» nturn string; 

—> SMds • string fraai thn eucrnnt linn snd stems it in 
'» ItsB. If the rsautlalag niMber et eberaeters en the 
—' current line is lass than length then enly these 

— characters are returned. The line teoslnater is net 

— skipped. 

precedure pttt_ltaai (Itaa : In string): 

— If the length ef the string is greater than the current 

— ■artsans line (Xlaelaagth). the emaptlen lATOOT OUtOR 

— is raised. 

— XS the string dees net fit en the current line a line 
taasinater la eutput, then the Itaa Is eutput. 

— Line and page lengths - ARK 14.1.3. 

procedure set_llae_langth (te : in count): 

procedure aet_^age_length (to : in count): 

function llne_length return count: 
function page_length return count: 

— Operations en celuauis, lines and pages - ARM 14.3.4. 

procedure naw_llne; 

procedure s)ilp^llne: 

function end_ef_llne return boolean; 

precedure ne«’_page; 

procedure slclp^^ge: 

function and_ef_page return boolean: 

functien ead_ef_fllo return beeloan; 

precedure set_cel (to : In pealtlve_eeunt); 

preeedum set_llne (te ; In pesltlve_eount); 

function col return pesltlve^eeunt: 

function line return pesltlvg_eeunt; 

function page return pcsltlve^ceunt; 

— Character and string preeeduma. 

— Cerreapends to the pteeedurea defined In ARM 14.3.C. 

preeedum get_ehacaetac (itaa ; out charaetor); 

preeedum get_strlag (Itaa : out string); 

preeedum get_llae (Itaa : out string; 

~ last ; out natural); 

preeedum put^eliaraetar (Itaa : in eharaeter); 

preeedum put_atrlng (Itaa : in atrlng); 


230 






DACS*80x86 User's Guide 
Iinptementnioo-Dependeot Characteiistics 


pceeadur* pue_Xti>« (Itw : In attiiiffl; 


— axeaptlona: 

OSS EMIOR : •xcapClOn CMMBMa XO DCCSTTIOMS. OSS CMOR; 
OCvfcS CMm : axeaptlon raMawa XO~BCCKmOHS.omcs BmOR; 
mo niOR ; •xeapclen canaaMa XO~CXCX»TSOIIS. on ERROR; 
OROi ERROR : axeaptloa ranaMa Xo'EXCEPTXailS.ORn ERROR; 
LRYOOt_ERROR : axcapCloa EMaMa XO^EXCERTXONS.LRTOn^ERROR; 

and RMXC XO; 


FJ.4 Package TERMINAL.DRIVER 

The specification of package TERKQNAL.DRTVER: 


paeaaga TBRMIVALJ9RXVER la 

proeadura put_ehaxaetar (eh : in eharaetar); 
proeadura gat_eharaetat (eh : out eharaetar); 
privaea 

praqaM intarfaea (XSMC, p«c_eharaeear>; 

praqaia lncar£aea_apalliap (put_eharaetar, *DlXPt]T?pat_eharaetar*) ; 
pragaM Intartaea (RSMC, gac^eharaetar) ; 

pragaia intarfaea^apaltlnd (gacjeharaetar, 'OIXCErTpatjeharaetar*) ; 
and TCRMZRRL.DRXVBR; 


Packages SEQUENTIAL-IO and DIRECT-IO 

The specifications of SEQUENTIALJO and DIRECT JO are specified in the ARM: 

Since files are not supponed the subprogruns in these units reaise USE_ERROR or 
STATUS_ERROR. 


231 








DACS>80x86 User’s Guide 
Inplcnienution-Dependetu Chancterisdcs 


FA6 Picksfc LOW_LEVEL-IO 

The specification of LOW^lEVEL.IO (16 bits) is: 


wich Sy*t«(; 


(taeka«« UH UEVU. XO is 


Sttbtyp* port_«ddrMs is SystMs.Onslfnsaierd; 


latsfar cany* -12i..l27; 
typ* Il.to.lS is iMM laea««r; 

pcoeadnra a«ad_eentEol(4avle« : la pect^addMaa; 

data : la SystM.aytal; 

— uaslynad • bit antlty 

preeadusa sandjeancrel(daviea : la poct.addsass: 

data : la SystM.oaslgnadNetd); 

— uasipnad 1< bit aatlty 

pseeadura saad^eentrol(daviea : la pert address; 

data : la U lo •»; 

~ slffaad • bit aatlty ~ “ 


preeadura sand_eentrol(daviea : la pert address; 

data : la 11 le 1C); 

— slgaed IS bit entity ~ ~ 


preeadura raealva_eentrol(daviea 

data 

— unalgnad • bit aatlty 


la pert_addraaa; 
eut Systaa.byta); 


preeadura raealva_eentrei(daviea 

data 

•• uaalcnad IS bit antlty 


ir pert_addraas; 

eut Systaa.OaslpnadMerd); 


preeadura racalva_eeBtrel(device ; la pert address; 

data : eut 11 Te •); 

— signed C bit aatlty “ " 


preeadura reealva_eeatrel(daviea 

data 

— signed IS bit antlty 


la pert address; 
eut ll_ie IS); 


private 


pragaa laline(send_eentrel, raealva_eentrel); 
and LOW Itm. XO; 


the spaeiXleatlen of lOH_LEVtl_XO (32 bits) la: 
with SYSTCM; 


pae)caga umjLEVSL XO is 


subtype pert_addrass Is Systaa.OasignadNord; 

*yP* i* "dw short integer range -12g..X27; 

*yPd 1» nau sboct~latagar; 

type ll.le_32 is new Intagar; 


preeadura sand_eeatrol(daviea 

data 

—' unsigned • bit entity 


In pect_addrass; 
la Systaa.lyte); 


preeadura sand_eentrel(daviea : in pert_addsnss; 

data : In SyatM.OnalgaadHerd); 


232 






DACS-80x 86 User’s Guide 
Impicmenuiion-Dependent Characteristics 


— ttMlgnad 1< bit MClty 

pcoMduc* MnU_eeiitrel(d«vie« : in porc_nddrasa; 

~ dnen : in SynCM.OnalgnndfiWaitd) ; 

— unaifnnd 32 bit nntlty 

proendttxa annd^eoncreKdnvlen : in p«rt_nddr*aa; 

” data : In H_io_d) ; 

— alpnad • bit anttcy “ ” 

praeadttta aand eantzal(davlea : in part addraaa; 

daca : in H_le_l«) ; 

— algnad 1C bit antity ~ ~ 

pracadura aaad_eontxel(davtea : in part_addraaa: 

~ data : in ll_ia^32); 

—> aipnad 32 bit antity ~ ** 

pracadura racaiva^eantral(davica : in part_addraaa: 

' data : aut Syataa.Byta); 

— unaignad • bit antity 

pracadura racaiva^eantral(daviea ; in part_addraaa: 

~ data : aut Syataai.OnaignadHard) : 

•• unaignad IS bit antity 

praca^ra racaiva_cantral (davica : in part_addraaa; 

~ data : aut Syataa.OnaignadDMerd); 

" unaignad 32 bit antity 

pracadura racalva_eantral (daviea in part_addraaa; 

~ data : aut ll_Ta_C); 

— aignad • bit antity “ 

pracadura racaiva^cantral(davica ; in part_addraaa; 

" data : aut ll_Ta_lS); 

— aignad IS bit antity ~ “ 

pracadura racaiva^cantral(davica : in part_addraaa; 

" data : aut Xljra_32); 

— aignad 32 bit antity 


private 

pragaw inlina(aand_eentral< raeaiva_eantroi); 
and LON LEVEL ZO; 


F.9 Machine Code Insertions 

The reader should be familiar with the code generatkm strategy and the 80E86 instruction set to 
fully benefit from this section. 

As described in dtapter 13.8 0 / the ARM [DoD 83] it is possible 10 write procedures containing 
only code statements using the predefined package MACHINE.CODE The package 
MACHINE.CODE defines the type MACHINE.lNSTRUCnON which, used as a record aggregate, 
defines a machine code insertion. The following sections list the type MACHlNE_INSTRUCnON 
and types on which it depends, give the restrictions, and show an example of how to use the 
package MACHINE.CODE. 


233 





DACS-80x86 User’s Guide 
Implemenuiion-DepeiKlent Quracteristics 


F.9.1 Predefined Types for Machine Code Insertions 

The following types are defined for use when making machine code insenions (their type 
declarations are given on the following pages): 

type opcode.type 
type qrerand.t^ 
type register.type 
type segniem_register 
^pe machine.instniction 

The type REGISTER.TYPE defines regisrers. The registers STi describe registers on the floating 
stack. (ST is the top of the floating suck). 

The type MACHINEJNSTRUCTION is a discriminant record type with which every kind of 
instruction can be described. Symbolic names may be used in the form 

name’ADDRESS 

Restrictions as to symbolic names can be found in section F.9.2. 

It should be mentioned that addresses are specified as 80386/80486 addresses. In case of other 
targets, the scale factor should be set to "seke.r. 


typ* opeod«_typ« la ( 

— toac iMtruetlona: 


a AM, 

a_AAD, a_AAM. 

a_AAS, a.ADC, a_AD0, 

a_AMD, 

a.CALL, 


a CaIuI, 






a CBM, 
a~OAS, 

a CLC, a CLO, 
a-OEC, a-orv. 

a CLZ, a CMC, a CMP, 
a^BLt, a^lOZV, a“lMBt, 

a CMPS, 
a~lM, 

a CMD, 
a^ZMC, 

aOR 

a~lMTO, 

a"ll«T, a~JA. 
a ,70B, a ,7L, 

a~JA£, a^JB, a'jBS, 

a JU, a'JHA, a JMAE, 

a~JC, 

a~JMB, 

a~JCX2, 

a^JMBK, 

aX, 

aJC 

aTjm, 

a"jO, 

a^JKO, a~JM6B, 
a^JP, a.JPt, 

a ML, ^MIL. a MO, 
a JPO, tTn, a n, 

a“jMP, 

a”JMP, 

a JMS, 

a^uure. 

apK 

aim 

a~US, 

a~LtA. a.LOCX, 

a.LOOS, a.LOOP, a.LOOPB, 



a lOOtME, a_UOfNS. 





a LOOPS, a HOV, a_HOV3, 

a MOL, a MK, a MOP, 

a.MOT, 

a.OM, 

aOB 

a POP, 

a POPr, a POSB. 

a posap, a~MCL, a RCX, 


a_ROL, a^BOR, 


b'mP, 

a~aEPB, a BCPME, 

a~l«T, a“netP, a~MT», 


a retmp. 

a^X 

a~SAL, 

a~SAK, a^SBL, 

a~SBK, a SBB, a SCAS, 

a STC, 

•JXTD, 

aSL 

a“sTOS, 

a.SOB, a_TE3T, 

a^HAZT, aTxCMe, mJOMX, 

a~XOR, 



— S0a7/aaiS7/a02a7 rioatlng Point 

Precoooor Inatnietlona: 




a PABS, 

a FADO. a PADOO, 

a PAODP,a PBLO, a PBSTP, 

a peas. 


m~ncux. 

a'pCOH, a'pcOW, 

a~Peow, a~Pca0D, a FCCMPP, 

a'rOBCSTP, 


a'roiv. 

a”rOIVB, a-poiVP, 

a"POZVB, a~FDZvns, a~FeZVRP, 

a'pPWE, 


a~rZADO, 

a~rZADOO, a'PICOM, 

a PZCONB, a PZCOMP, 

a PZCOHPD, a PZOZV, 

a~rSDIVD. 

a~rZBZVB, a"PIOIVIO. 

a mo. a PZU»,a PZLOL, 

a PZMDL, 


a~riMDLO, 

wTraesn. m'rmaT, 

a”PZST, a-pZSIO.a'pzSTP, 

a~PZSTPO, 


a'rZSTPL, 

a~FZSOB, a'^PISOBO, 

a FZSOBIt, a FZSOBBO, 

a FLO, 

a~PU», 


a^FLOCN, 

a'pLomv, aTnoia. 

a~ PLOLM2, a~PLOL2K. 

a PLOL2T, a FLOPZ, 

wTrtBt, 

a^rpan. 

a~FLOX. a PMDL, 

a~PPTAM, a PBMDZn. 

a PMOLO. a PMOLP. a FUOP. 

a'sHSTOM.'' a PSAVB,a~PSCALB, 

a rPATAM, 
a''pSBTPM, 


a“rs»tt. 

a~PST, a PSTD. 

a'psten. a PmMV, a'pstp, 

a”PSZPO, 


a rSTSH, 

m~rSTaMX, a^FSOB, 

a"PBOBO, a"PSOBP, a~rSOBB, 

a'psOBIID, 


tTraam. 

a~PTST, a^PMAZT. 

a.PXAM. a_PXCB, 

a FXZIttCX, a PTL2X, 

wTmixgi 

a'PEXMl, 






— aoiac/aoasc/aosas inatnietlona: 

— Meeie* eiiat aoM liartlaf v«ral«aa af e)i« soac 

— inatnietlona only oxlat on thoao taceota 

— (ahlfta.rototoa.poah.lMl,...) 

ai aOOMD, a CLTS, a BRXR, a.ZMS, a LM, a_LEKVB, a_L6DT, 

a"tZBT. a^tSL, a'oOTS. mjnnA,mJKOt. a_SIDT, 


234 




DACS-80x86 User's Guide 
Iinpiemenuttion>Oependent Characteristics 


rnjMl.. 

mJJin. 

0_U«H, 

o_lTIl, 


If bit alwaya... 




«_SUT. n.SNSN, ■_ 

STK, 

aJTElW, o.VEIUI, 


<— tho lOJSC apoeirie 

Inatnictlona: 



M SETA, 

m SETAE, 

n SETS, 

a SCT8E, a SETC, 

a SETC, 

■~ssTa. 

m SETSE, 

a'sETL, 

a~SETLE, a~SETHA, 

a'sETMAE, 

■"ssm. 

a'‘SEIMBE, 

■~SETIIC, 

a"SETHE, a~SETHG, 


•^SRIME, 

a'sETML, 

a~SETMU, 

a'sETUO, a~SETII*, 

a SETMS, 

sT SSXRZ, 

aTsETO, 

a'sETS, 

a SETfE,a SETSO, 

a~SETS, 

r'sETt. 

■ Bsr, 

■~SSR, 

a“BT, “ a ETC, 

a BT*, 

r”3TS. 

a'Lrs, 

■~I,3S, 

a~us, ajevsx. 

a HGwix, 

x“!«OWC». 

a'NOVDS, 

a~M0VT1t, 

a~SBU, a~SHED, 


-- tbo toss? apoclfle laatruetloaa: 



■^FQCQH, 

n^roeaHt, 

ajruCOWE, a_mEMl, a_rszii, 


~ byto/w 

ord/dword varloata (to 

bo uaod, whoa 


— not dodttctlblo frea 

eontoxt): 



a ABCB, 

a ADCH, 

a ACCO, 

a ASDB, 

a AODH, a ACDD, 

a~MIDB, 

aJUIDN, 

a~AMDO, 

a_BTW, 

a~BTB, a-BTCW, 

'a“BTCn, 

a'BTBN, 

a~BTRD, 

a BTSM, 

a~BTSD, a'CRNH, 

a'CNOE, 

a'CMOw, 

a'cOQ, 

a~CWB, 

a~QOW, a^CWD, 

a~CMBSB, 

a'cMBSN, 

a CMBSO, 

a~OECB, 

a~OECM, a~DECB, 

a“0IVB, 

tTomi, 

a~OZVD, 

a_lBlVB, 

a IDIVW, a XOIW, 

a~XMOU, 

a'ZMOLH, 

a IMOU, 

a~lBCB, 

~ a raCN, ~ a IMCD, 

a~IMSB, 

a~SSH, 

a~IM30, 

a_ICSSB, 

a_LMSN, a LOOSO, 

a~MOVB, 

a**HOVN, 

a~HOVO, 

a'MC/SB, 

a~MOVSM, a~MOVSO, 

a~MaVSXB, 

aJtOVSXN, 

a~NOVZXB, 

a~MCVZXH 

, ~ a KOLB, ~ a HDUt, 

a~MDLO, 

a'MECB, 

a~tlEaM, 

a~NEa>, 

a~HOTB, a~MOT1f, 

a'^MOTO, 

a ORB, 

a*ORW, 

ajORB. 

a~OOTSB,a OOTSM, 

a^OOTSO, 

a lOBN, 

a~MBO, 

a rosRN, 

a Boias, a~RCX4i, 

a'sCLN, 

a ROO, 

a*RaiB, 

aJICRM, 

a RCRB, ~ a Mt4l, 

a'llOLN, 

a MU), 

a RORB, 

a RORM, 

a RORD, a SAAB, 

a'SAM, 

a.SAU), 

a SARB, 

a.SARN, 

a SARD, a saUB, 

a~SBbW, 

a SBION, 

a SERB, 

a saiw. 

a SBRDN,a SBBB, 

a~SBBW, 

a SBBO, 

a^SCASB, 

a_SCASM, 

a SCASO, a'sTOSB, 

a“sTOSII, 

a.STOso, 

a**StnB, 

a^SOBN, 

a SOBO, ~ a TESTB 

a“TESTt», 

a_TESTO. 

a3)(ORa, 

a_X0RW, 

a.XORO, a_DATAB 

a^OATAM, 

a_DATAD, 




" spoelal 

'laatmetlona': 

a^labol 

a_roaot. 


— S0S7 tMp TMl load/stor«_andjep: ■_IXDT. a_rsTtT); 


praqM pa«*; 

Cyp« ap«r«nd_eyp* is < non«, 

tn —i ll if, 
tmqiatmt, 

•ddzMa, 

•yatMi_«ddrMa, 

iiaaM,~ 

raglatar^laMdiata. 


ra«latar_c*glac*r, 
raglaear^addraaa, 


no oporaada 

— eno t—artlato oporand 

— oao rogtatoc oporand 
~ oao addroaa oporand 

— ono 'addroaa oporand 

— cau aaoM 

— two oporanda : 

— doatiaacloa la 
~ roglacor 

aeorco la laaadlato 

— too roglatar oporanda 

— coo oporaada : 

” doatlnatloa la 
~ roglator 

— aoureo la addroaa 
-• two oporaada : 


addroaa_roglator, 





DACS*80x86 User’s Guide 
ImplemenuiiOT-Dependem Chancteristics 


ca«tae«r_ay«t«ai_«ddrMa. 

ayataa_addraaa_r««tatar, 

addr«aa^lJBMdl.ata, 

ayataai_addzaaa_iaBadlac«, 

l iM adiaf^taqlatat, 

ta—dlata_l^adlata, 
gaglaea r_raglaf r_l —aflAata. 
t««tatar_addr*aa_iaMdlata, 

raflataf^ayacaaija^'***-^^"**^*^** 

addraaa_raqiata^l—iill«a, 

ayacaB_acldr*aa_r«9tatar_taMdlat8 

) ; 


— daatlMtlen ta 
.. addraaa 

— aoutea la caqlatar 
" two apatanUa : 

-• daatlnacion la 

— caplacar 

— aourea la 'addraaa 
-> two eparanda : 

— daatlnatlon la 

— ‘addcaaa 

— aottxea la ta^latar 
~ two oparanda : 

— daatlaatlen la 

— aiddraaa 

— aourea la laawdlata 
-> two oparanda : 

~ daatlnatlon la 

— ‘addraaa 

— aourea la 1—artlata 
•• only allowad for OOT 
» pert la Iwadlata 

— aourea la raglatar 
only allowad for 

— enn 

*— allowed for XMOLlaai, 

— SBSOljaa, SlUlaa 
allowad for XMDLlnai 
— allowad for XMOllaai 

•• allowed for SSKDlaB, 

— SSlSlaB 

-- allowad for STOlnB, 

" SlLOlnm 


type rapiatar type la (AX, CX, OX, ax, SP, BP, si, 01, — word ra«a 
AL, CL, OL, BL, AB, CB. OB, BB, — byta raffa 
EAx,cex,EDx,ax,up,CBP,csi,esi.— *ierd ra«a 
BS, cs, ss, OS. rs, ss, — aalaetora 

BX_SI, BX.OZ, BP_SI, BP_DI, — BOaC/BOlBB/BOZBS eoablnatlona 

St7 STl, STS, *'st3, — fleatlnB ra«latars lataek) 

ST4, STS, STS, ST7, 

nil) ; 

— the axtandad raylatara (tAX .. EDI) plua rs and 6S ara only 

— allowed la B038C tarpata 

type aeala_typa la (aeala_l, aeala_2, aeala_4, aeala_B); 
aubtypa awehlna^atrlnq la atrlnpd. .100); 
praqaM page; 

type ■ae>)lna_lnatruetlon (oparand_)ilnd ; eparand_typa) la 
raeord ” ~ ” 

opeeda : opeeda_typa; 

eaaa epax;ind_)(lad la 
whan l — a d lata » 

lanadiatal : Intayar; — laadlata 


whan raolatar •> 

r_ra 9 latar : ra«l8tar_typa; ~ aourea and/or daatlnatlon 
whan addraaa >> 

a_aaqaMnt : ra 9 latar_typa; — aourea and/or daatlnatlon 
a_addiraaa_baaa : ra«Tatar_typa; 

a~addraaa3lndax : roglatar^yP*' 

a~addraaa~aeala : aeala_ey^; 

a3addraaa~offaat ; Intoqar; 


witan 8 yataai_addraaa •> 

aa^addraaa : ayataai.addraaa; 


deatlaatlea 


236 




OACS*)iUx 80 User's Guide 
bn(dementsiion*Dependent Characterisacs 


WiMA a«M ■> 

n_«trtii« 


BbltM^aerlng; -• CAU. d*atla«cloii 


whan rael«cat_ta—dlata 
r*‘l~ljndtaea 


r* 9 lac«r_eyp«; 

lncagar:~ 


Mhaii raqlacar^raqlacat •> 

r_t_tafllatat_to : ra«latar_typa; 

r_r_ra9tatar_{caa ; raglatar'typa; 

whan ca9laeac_addraaa •> 

r_a_ca9tatar_te : raqlatar^cypa; 

r^a.aa^Mat ~ ; raylatar^typa; 

E_a_addraaajbaaa : ra«latar~typa; 

t~a^ad 4 Eaaa_iaeax : raglatae~typa; 

r 3 a_addraaa_acala : aeala_ty^; 

r~a~a«ldxaaa~offaat : lata^ar; 

whan addraaa_ta«lacar •> 

a_r_aa«Mflt : r%qiat»tjtyp»: 

a_r_addtaaa_baaa ; ra«laeat~typa; 

a_r_aedraaa_lndax : Ea 9 latar~typa; 

a~t_addraaa_aeala ; acala_ty^; 

a 3 r_a<idraaa~offaaC : lata^ar; 

a“t_raglatar_fto« : ta9latar_typa; 

whan ra9iatar_ayataai_^addraaa •> 

r_aa_ta9latar_to : ra^latar^typa; 

E_aa_addraaa ; ayacaa.addraaa; 

whan ayataBi_addraaa_ra9tatar •> 

aa_r_addraaj ~ ; ayaeaa.addraaa; 

aa^r_ta9_troa : ra9latar_typa; 

whan addraaa^^liaaadlata -> 

a_l_aa9Rant : ra^iaeac^typa; 

a_l_addraaa_baaa : ragiacar'cypa; 

a_l_adidtaaa_ladax : raviatat^eypa; 

a_l_addxaaa_aeala : acala^ty^; 

a_l_a<l«lraaa_o£taae ; iaca«ac; 

a_l_ 1 a aadiata : lnta9ac; 

whan ayatAai_addraaa_laaMdlata «> 

aa_i_addraaa ~ : ayacaai.addraaa; 

aa^l_laniadi.nta : tataqar; 

whan laawdlata_ca9latar » 

l_r_ 1 r i w i d lata : intagar; 

l_c_ca9lacaE : raqlatar_typa; 

whan l wi adlata_ 1 iia ia d laea 

l_i_ tiiw adlacal ; Xata^mt! 

l_l_laaMdlaca 2 : lnta9ar; 

whan raylatar^cagiatac^lnaMdlata » 

r_r_l~ra9iatarl : ra9latar_typa; 

t~E_i_ra«laeac 2 : Ea 9 iacaE~eypa; 

rJr^l_laBMdlaca : Incadar; ~ 

whan ra9latar_addraaa_lfii11ata •> 

E_a_l_ragtatar ” : Ea 9 latnc_typa; 

r_a_l_aa«aant : taglaCM.typa; 

r_a_ljKldraaa^baaa : ca9latM_cypa; 
r_a_t_addxaaa_ladan : caqiacar^typa; 

! 2 *.^_*^^***.*m 1 * = aenla_cy^; 

r~a_l_addraaa_o££aae: lnea9ac; 
c_a_l_tanMdlata : intagar; 

whan ragtatat_ayata»_addraaa _1 awadlata •> 

r_aa_l_ca9iatar T ragiatar_typa; 

addrlO~ ; ayataa.addraaa; 

g_aa_l_tiwia» 11 ata : tatagar; 


daatlnatlon 

aeurea 


daaclnatlon 

aourea 


— daatlaatlon 


» daatlaatlen 


-- daatlnacton 
aeurea 


daaeiaatien 


daatlnatlon 


•• aeurea 


daatlaatlen 

aeurea 


daatlaatlen 

aeurea 


laaadlatal 

laaMdlaea2 


• daatlaatlen 

• aeurral 
aeurea2 


daatlnatlon 

aeureal 


— aeorea2 


~ daatlaatlen 
aeereel 
■ aeurea2 


23 ‘ 






DACS>80x86 User's Guide 
Implementation-Dependem Chancteiistics 


whan adctr—J «—rtiata *> 

B t ~ : raglBCar^typa; 

^r,i^«dclr«ss_b*a« ; raglata^typa; 
•“t^llBUUtaBt^lndax : c««lac«r~cyp«; 
•20Z*^^***Z*^*^* ■ •eal*_ty^; 
•~r~l~Bddr«as~o(fs«t: laca^ar: 
a~t~i~r#9latar : t««latar_typ«; 

aJtJlJlaMdlata : inca9«c; ** 


" daatliiatloA 


-- aourcal 
-> aoureaZ 


whan 


ayata«_addraaa_ca«taear_taBMdlaca 


aa_r_l_addxaa a 
aar,r^i^raglatat 
aa3 *1 Iw aadtata 


ayatam.addraaa; 

ra9latar_typa; 

Incagar: 


" daatlnatlon 
-- aaureal 
— aeurcal 


whan othara ••> 
null; 

and eaaa; 

and racord; 


and awehlna coda; 


F.9J Restrictions 

Only procedures, and not functions, may contain machim code insertions. 

Symbolic names in the forni x'ADDRESS can only be used in the following cases; 

1) X is an objea of scalar type or access type declared as an object, a formal parameter, or 
by static renaming. 

2) X is an array with static constraints declared as an objea (not as a formal parameter or by 
renaming). 

3) X is a record declared as an objea (not a formal parameter or by renaming). 


The m.CALL can be used with "name" to call (for) a routine. 

Two opcodes to handle labels have been defined: 

mjabel: defines a label The label number must be in the range i <s x <s 999 and is put 

in the offxt field in the first opetaixl of the MACHINE^INSTRUCTION. 

m.ieset: used to enable use of more than 999 labels. The label number after a m.R£SET 

must be in the range !<» x <s 999. To avoid errors you must make sure that ail 
used labels have been defined before a reset, since the reset operation clears all used 
labels. 

All floating instmctions have at most one operand which can be any of the following: 

• a memory address 

• a register or an immediate value 

• an entry in the floating stack 


238 






OACS*80x86 User’s Guide 
Iiiq)ieiDemation-Dependera Characterisucs 


F5J Examples 

The following section contains examples of how to use the machine code insenions and lists the 
generated code. 


F.9.4 Example Using Labels 

The following assembler code can be described by machine code insenions as shown: 

NOV AX.T 
NOV CX,4 

am AX.cx 

JG 1 

n 2 

NOV CX.AX 
1: ADO AX.CX 
2: NOV SS: tBP'fDI]. AX 

p«ekA«« axMplAjlC Is 

preeadur* t«st_lsb«ls; 
prsfgas lalln* TtMC_lab«ls) ; 

•nd •xsapl*_HC; 

with HAiCXX)a_COOE; usa MACaZHE_CODC; 
paekava body~axai 9 la_HC is ~ 


pteeaduta cast_labals la 
bapln 


HAOIINX XMSZROCTXOM' 
MAaiiNt''msnu>eTzaH‘ 
HAOZNc'ntSTKICrZON' 
NACXZn'ZMRTOCZZOII' 
NACXZNE ZMSntOCrZOM' 
HACHZNE.ZlISnUjeTZaH' 
NACIZME ZNSTROerZON' 
HACaZm* ZVSTKOCTZON' 
HACaZNE~ZllSTROCTZOI)' 
MACaZHE~ZllSTAOC7ZON' 


(savlaeac^isBMdlaea, 
(tavlstag~tii>a(1.1 aea, 
(savlatat^nvlatar. 
(iMNdlata, 
(ISMdlata, 

(ra«lstar_ta 9 latar, 

(I ww a d lata, 

(cavlstac_ra 9 lstar, 
(losMdlata. ■_labal, 
(addtass^ravlatar, 


ai NOV. AX. 7) ; 
■"nOV. at. 4); 

■ CHP, AX. at); 
•• 

■_je. 2»; 

■JCV. at, AX); 

labaZ. 1); 
■~AD0, AX. at); 

27; 

a_NOV. SS. BP. 
OX. seala_l. 0. 


AX); 


and taat labals; 


and axaB 9 la_NC; 


F.9.5 Advanced Topics 

This section describes som- of the more intricate details of the workings of the machine 
code insertion facility. Special attention is paid to the way the Ada objects ate referenced in 
the machine code body, and various alternatives ate shown. 


239 






DACS>80x86 User's Guide 
Im^dementation-Dependent Characteristics 


F.9J.1 Address Spedfleations 

Package MACHINE.CODE provides two altetiutive ways of specifying an address for an 
instruction. The way is lefeiied to as SYSTEM.AODRESS and the parameter associated 
this one must be specified via OBJECT’ADDRESS in the actual MACHINE.CODE insenion. The 
second way closely relates to the addressing which the 80x86 machines employ: an address has 
the general foim 

segment:[base't'index*scale-K>fFsetl 

The ADDRESS type expects the machine insertion to contain values for ALL these fields. The 
default valire NIL for segment, base, and index may be selected (however, if base is NIL. so 
should index be). Scale MUST always be speciOed as scale.l. scale_2. scale_4. or scale_8. For 
16 bit targets, scale.l is the only legal scale choice. The offset value must be in the range of 
-32768 .. 32767. 


F.9JJI Referencing Procedure Parameters 

The parameters of the procedure that consists of machine code insertions may be 
referenced by the machine insertions using the SYSTEM.ADDRESS or ADDRESS formats 
explained above. However, there is a great difference in the way in which they may be specified; 
whether the procedure is specified as INLINE or not. 

INLINE machine insertions can deal with the parameters (and other visible variables) using the 
SYSIEM.ADDRESS form. This will be dealt with correctly even if the actual values are 
constants. Using the ADDRESS form in this context will be the user’s responsibility since the 
user obviously attempts to address using register values obtained via other machine insertions. It 
is in general not possible to load the address of a parameter because an 'address' is a two 
componem structure (selector and offset), and the only instruction to load an immediate address 
is the LEA. which will only give the offset If coding requites access to addresses like this, one 
cannot INLINE expand the machine insertions. Care should be taken with references to objects 
outside the current block since the code generator in order to calculate the proper frame value 
(using the display in each frame) will apply extra registers. The parameter addresses will, 
however, be c^culated at the entry to the INLINE exparxied routine to minimize this problem. 
INLINE expanded routines should NOT employ any RET instructions. 

Pure procedure machine insertions need to know the layout of the parameters presented to. in this 
case, the caUed procedure. In particular, careful knowledge about the way parametere are passed 
is required to achieve a succesfiil machine procedure. When not INLINE a block is created around 
the caU which allows addressing of parameters, and code for exiting the procedure jg also 
automatic. 

The user takes over the responsibility for conea parameter addressing. The niles of Ada 
procedure calls must be followed. The callit^ conventions are summarized below. 


240 







OACS*80x86 User's Guide 
Implementadon-Dependem Characteristics 


F.9JJ Parameter Transfer 

It may be a problem to figure out the correct number of words which the parameter take up on 
the stack (the x value). The following is a short description of the transfer method; 

INTEGER types take up at least 1 storage unit 32 bit integer types take up 2 words, and 64 bit 
integer types take up 4 words. In 32 bit targets, 16 bit integer types take up 2 words the low 
word being the value and the high word being an alignmem word. TASKs are transferred as 
INTEGER. 

ENUMERATION types take up as 16 bit INTEGER types (see above). 

FLOAT types take up 2 words for 32 bit floats and 4 words for 64 bit floats. 

ACCESS types are considered scalar values and consist of a 16 bit segment value and a 16 or 
32 bit offset value. When 32 bit offset value, the segment value takes up 2 words the high word 
being the aligment word. The offset word(s) are the lowest, and the segmem wotd(s) are the 
highest 

RECORD types are always transferred by address. A record is never a scalar value (so no 
post-procedure action is carried out when the record parameter is OUT or IN OUT). The 
representation is as for ACCESS types. 

ARRAY values are transferred as one or two ACCESS values. If the array is constrained, only 
the array data address is transferred in the same manner as an ACCTESS value. If the array is 
unconstrained below, the dau address will be pushed by the address of the constraint. In this 
case, the two ACCESS values will NOT have any alignmem words in 32 bit targets. 

Packed ARRAY values (e.g. STRING types) are transferred as ARRAY values with the addition 
of an INTEGER bit offset as the highest wotd(s): 

+H: BIT.OFFSET 
+L: DATA_ADDRESS 

+0; CONSTRAINT.ADDRESS - may be missing 

The values L and H depend on the presence/absence of the constraim address and the sizes of 
constraint and dau addresses. 

In the two latter cases, the form parameter’address will always yield the address of the data. If 
access is required to constraim or bit offset, the instructions must use the ADDRESS form. 


F.93.4 Examine 

A small example is shown below (16 bit target): 

procedure unsigned.add 

(opl ; in integer; 

op2 : in integer, 

res : out integer); 


241 




DACS-gOx86 User's Guide 
Implemenunon-Dependem Characteristics 


Notice that machine subprograms cannot be Ainctimts. 
The parameters take up: 


opl ; integer 1 word 

op2 : integer 1 word 

res : integer I word 


Total 3 words 


The body of the procedure mi^ then be the following assuming that the procedure is 
defined at outermost package level: 


preeaduE* uaslfiMdjtdd 

(e^ : la Intaqar; 

op2 : la letagaE: 

cas out latadaci la 

bagln 

pcagaa abstraet_aeoda_inaartlona(trua); 
aa_lnacr' (aa_CEaacaJilocit,3,1.0,0,0); ~ x • 3. y • 1 
aa~lnatr' <aa~Bnd_of~daelpart, 0,0,0,0.0): 
pragM abattaet_aeoda_laaactlona < falaa) ; 


■aehina_lnatruetlon'(raglatac^syaeaa^addraas. 

~ Juc7 opl'aiddxasai; 

Mehina_laatruetlan' (raglatar.syataa^addtaaa. 

~ AxT opS'addEaaa); 

Mchlna^laattuetlen* (laBadlata< 
■aehlna^lnaCEUctlon' (laMdlata, 
■aehlna^laatEuetlon' (t—arllata. 
■aehina^laatruetloa' (ayataai_addtaaa_raglataE, 
' raa'addtaaa, MC); 


■_HOV, 

a_ADO, 

■ JMC, 1>; 
■“nft. 5); 
a labal.l); 
a MOV, 


ptagaa abatEaet^a«o<la_laaartlena <tcua> ; 
aa.lnatr' (aa_^Bxlt_aubpr9ta,0,0,0,nll_ac9,ail_aEg);— (2) 
aa.lnatE' (aa.sat^block_laval,0,0.0,0,0); " — y-l - 0 

pragaa abatraet^aea4a_lnaartlens(falaa); 
aad unalgnad_add; ** " 


A routine of this complexity is a candidate for INLINE expansion. In this case, no changes to the 
above 'machinejnstrucdon' statements are required. Please notice that there is a difference between 
addressing record fields when the routine is INLINE and when it is not: 


type tec is 


record 


low 

: integer. 

high 

end record: 

: ineger. 

procedure add_32 is 


(opl 

: in integer; 

op2 

: in imeger. 

res 

: out tec): 


The parameters take up 1 <*■ 1 2 words « 4 words. The RES parameter will be 

addreased directly when INLINE expanded, i.e. it is possiUe to write: 


242 










DACS*80x86 User’s Guide 
Implemenution-Dependent Characteristics 


machtne_instiuctioit’(sysiein_address.register. m_MOV. 

res'address. AX): 

This would, in the not INUNED version, be the same as updating that place on the stack where 
the address of RES is friaced. In this case, the insenion must read: 

machineJnstniction’(register_system_addiess. m.LES. 

SI. res'address): 

~ LES Sl.(BP+...] 

machineJnstiuction’(addiess_regisier. m.MOV. 

ES. SI. nil. scale.l. 0. AX): 

- MOV ES:[SI+01.AX 


As may be seen, great care must be taken to ensure correa machine code insertions. A help 
could be to first write the reutine in Ada. then disassemble to see the involved addressings, and 
finally write the machine procedure using the collected knowledge. 

Please notice that INLINED machine insertions also ^neraie code for the procedure itself. This 
code will be removed when the •nocheck option is applied to the compilation. Also not 
INLINED procedures using the AA.INSTR insertion, which is explained above, will automatically 
get a storage.check call (as do all Ada subpro g ra m s). On top of that. 8 bytes are set aside in the 
created frame, which may freely be used by the routine as temporary space. The 8 bytes are 
located just below the display vector of the frame (from SP and up). The storage.check call will 
not be generated when the compiler is invoked with -nochcck. 

The user also has the option NOT to create any blocks u all but then he should be certain that 
the return from the routine is made in the prtrper way (use the RETP instruction (return and pop) 
or the RET). Again it will help first to do an Ada version and see what the compiler expects to 
be done. 

Symbolic fixups are possible in cenain instructions. With these you may build 'symbolic' 
instructions byte for b^. The instructions involved all require the operand type NAME Qike used 
with CALL), arxl the interpretation is the following: 

(name. m.DATAD. "MYNAME") a full virtual address (offset and selector) of the 

symbol MYNAME (no additional oflset is possilHe). 

(name. m_DATAW. "MYNAME") the offset part of the symbol MYNAME (no additional 

offset is possible). 

(name. m.DATAB. "MYNAME") the selector value of symbol MYNAME 

In inlined machine instructions it may be a problem to obtain the address of a parameter (rather 
than the value). The LEA instruction may be used to get the off^ part, but now the following 
fonn allows a way to load a selector value as well: 

(system^addiess. LES. param’addiess) ES is loaded with the sdector of PARAM. If this 

selector was e.g. SS. it would be pushed and popped 
into ES. LES may be substituted for LJFS and LGS 
for 80386. 


243 





DACS-80x86 User's Guide 
Impiemenution-Dependem Giaracteristics 


F.IO Paclufe Tuktypcs 

The Ta^Types pledges defines the TaskComroiBlock type. This dau stnicnire could be useful 
in debuggi^ a tasking ptogrun. The following package Tasktypes is for all DACS-80x86 except 
for DACS-80386PM/DACS-80486PM. 

with Systaa; 
p«eka«« TuktypM !• 

•ubeyp* Offaat la Syataat.OnalenadMord; 
aiibtypa aioekZU la Syataa.Oaal«n«dMerd; 

tn*« TaakBatry la naw Syacaai.OaalfaadMocU; 

typa latrylitdax la naw syaeaa.OaalfnadHexU; 

eypa Xltacnatlvald la na« Syataa. Onalg n adMortt; 

typa Tleka la naw Srataa.ONoctf; 

typa aoal la naa ■oelaaa: 

fer Bael'alsa «aa •: 

typa OZatg la naw Syataa.OnalgnadMotd,- 

typa TaakStata la (Initial, 

— Tba taak la eraatad, but activation 

— haa not atartod yat. 

Engaged, 

•• Tho taak haa eallad an ontcy, and tha 

— call la now aeeoptad, la. tha candatveua 

— la In pcogcaaa. 

Running, 

~ Covara all other atataa. 

Delayed, 

— Tha taak awalta a tlaMout to axplra. 

EntryCalllngTlaod, 

— Tha taak haa eallad an entry which 

— la not yat aee^tod. 

BateyCalllagOneondltlonal, 

— Tha taak haa eallad an entry unconditionally, 

— which la not yat aeeoptad. 

SalaetlngTlaMd, 

— Tha taak la waiting in a aalaet atataawnt 

— with an opan delay altamatlva. 

SalaetlagOncendltlonal, 

— Tha taak walta In a aalaet atataaant 

— antlroly with accept atataawnta. 

SaleetlngTenalnabla, 

— The taak walta In a aalaet a tat te n t 

— with an open tenalnace altecaatlve. 

Reeaptlag, 

— The taak walta la an accept atataaMat. 

Syaebeonlxlng, 

The taak walta In an accept atataaent 

— with no atatenaat Hat. 

Coapleted, 

The taak haa ecaipleted the eMcutlen ot 

— lea atateaone Hat, but net all depe n da n t 
•• taaka are teralaeted. 

Teoalaated ); 

The taak and all ita deacendaata 

— am tomlnated. 


244 







DaCS-80]i 86 User’s Guide 
Imptemenutton-Dependeiu Characteristics 


for TMleSeoeo uso (Xnteiol •» i<«00« . 

Ciig«««d •> KlOat , 

Ruantnv •> , 

Doloyod •> 1«41S« , 

SattyColltAgTlaod -> 1C«20« , 
CacrycoIlittfOneoiidlcioiMl ■> , 

SoloettnaflMd » . 

SoloetiaaOneoadltiofiol -> 1C*3»« , 
soloettngToniifubl* •> ictai* , 
Aeeaptiaq » 1C44A* , 
synehronisiaf ■> l(«S3* , 
coaplocod » ts«sci , 

Tomueod » 1««<44); 
for toskStoco'alxo uso •; 


eypo TukTypoOMcripcor la 
raeocU 
pcloctty 
antty^eouat 
bleek~ld 

flrae^aiM^addraaa ; 
■odala^auaibar 
aatzy_aii«b«r 
eoda_«ddroaa 
. ataek_alao 
duswy” 

ataek^aa9Baat_alxa: 
aad taeard; " 


Syaeaa.trlocity 
OXaty; 

SloekXd: 

Syaeaa.Addraaa; 

Qlaea; 

OZatd; 

Syitaai.Addxaaa; 

Syataa.OMord; 

Iata«ar; 

OXaCd; 


typa AceTaakTypaOaaetlpeor la aeeaaa taakTypaOaaerlptac; 

cypa HTXSavaAraa la array(1..4«) of syataai.OaalpnadMerd; 

cypa riapatypa la 
raeord 

nrma« tool; 

XatarnipcTlap Seol; 

and raeord; 

prapoa pack(riapafypal; 


typa StataaTypa la 
raeord 
ataea 

la_abaorMl 
la_actlvatad 
failura 
and raeord; 


: Taakscata; 
: Bool; 

: fool; 

: Bool; 


prapoa pack(StataaTypaI; 


typa Aer_typa la 
raeord 

bp : Offaat; 

addr : Syataa.Addroaa; 

ond record; 

pcapoa paek(«er_typa); 


typo TaakConerolBXoek 
raeord 

aaa 

laNealeor 


la 

: Syatao. 
latapar; 


-■* Delay pnoiia handllnp 


Unokt ; syacaa.raakvalua ; 
epnv : Byataai.TaakValoa ; 
Malay : tleka ; 


~ Saved roplatara 


SS 


: Syataai.QnalpnodNerd ; 


245 





DACS-80k86 User's Guide 
bnplememaiian-Dependent Chsncienstics 


a : Ott—t ; 

IlMUy 41 MIM iMndllnq 

next : Systaa.tMkVaXu* ; 

Saaaphar* hMdllnq 

••■itMt : SysCM.TaakVxltt* ; 

fcleclty ftald* 

priority : Syacaa.priority; 

Mvo4_prlorlty : Syatoa.Priority; 

Mlaeollooiiatta fiolda 

tlaM^aXleo : Syataai.OiuipnadMord; 

floga : riopaTypo; 

RoadyCount : Syataat.Mord; 

Stock Spoeifieotieii 

atoek_atort : Offaot; 

atoek~ond ; Offact; 

Stoto tiolda 

atatoa : StataaTypo: 

Activation handlinp fialda 

activator : Syatac.taakValua; 

aet_ehain : syatac.TaakValuo; 

noxt^chain : Syatac.TaakValuo; 

RO_^nct_aet syacaa.Herd; 

actjaloek : SloekZd; 

Accept quouo fialda 

partner : Syacaa.Taakvalue; 

nextjMrtner : Syacaa.raakvaloe; 

• entry queue fields 

next_ealler : Syatea.TaakValue; 

- Rendasveua fields 

eallad_task : Syatea.TaakValue; 

iaAajfncir : inteqer; 

caak^encry : TaskCatry; 

eRCry_ladex Batrylndax; 

eacry~assee : Syacaa.Address; 

call,^raas ; Systaa.Address; 

alt_ld : AltamacivoSd; 

ex^_ld : Syacaa.excepcioald; 

- Dependency fields 

parenc_cask : Syacaa.TasKValue; 

paranc~bleek : Sleekld; 

ehild_taak : syacaa.TaskVeiue; 

next ^lld : Systaa.TaskVeiue; 

firsc_ebild : systaa.TaakValue; 

prev child : Systaa.TaskVeiue; 

child act : Syscaa.uetd; 

blcck'act ; Systaa. Herd; 

CecaiMCed_task: Systaa.TaskVeiue; 

- AberClen haadllaq fields 

busy : Systaa.Word; 


246 





OACS-80x86 User's Guide 
Impiemettadon-Dependem Charactenstics 


AiwiXlacy fl«lda 


ttd : AeeTMkTyp« 0 «acrtptec; 

rixstc«ll«r : SystaB.TukValiM: 


~ ltun>TlM SystM tialda 


ACT : Aar_typ«; 

sorirac : Xatagac; 

Satfirtt : Xatagac; 

nioeklavTMk : Syataa.TMkValu*; 

tBlocklapTaak : syatM.TaakValiM! 

eeXlaetlea : Syataat.Addraaa; 

paxtltiea : Xacaqar; 


ef. Oaar'a «ulda S.4.2 
Oaly ttaad la IMS 
Oaly aaad la ms 

Only uaad la RMS 
— Oaly uaad la RMS 


TaakCkaekLlMlt : OCSaat; — to aaausa lallaa ateraya ehaek 

taatescapcioa : SyacaB.OMesd; — 2 * IS blta 

SavadMaAdds ; Offaat; — to la^tova raadaavotta'a 


~ WX aaaa asaa 

— Mian tha applleatloa la llakad with -apK, a apaelal 

— aava asaa for tha IVX la alloeatad at tha vazy aad 
a{ avary TCB. 

— la: 

" eaaa iiyx_rtaaaat la 

— ahaa liibc >> Htxaava ; RtXSavaAsaa; 

— Mhaa rAX>SX •> aull; 

— aad eaaa; 

aad eaeosd; 

— Tha followlns la to aaausa that tha TCR haa tha ai^aetad alia: 

TCB_alsa : eaaataat xmxsBR TaakCoatsolBloek* alsa / R; 

autotypa TCR^ak.aalua la XUTEOKR saapa 13S .. X3S; 

TCB.ek : eaaataat TCB^akjralaa :■ TaakCoatseiaieek'alia / •; 

aad TaakTypaa; 


F.11 RMS Taikiiif (OPTIONAL) 

The DACS*80x86 systems may nm tasking applications by means of Rate Monotonic Scheduling 
(RMS). RMS capability is purchased optio^y, and is thus not included by default Please comaa 
DDC-I for mote infoimaiion regarding RMS and your system. RMS aUows the programmer to 
guamtee properties of a tasking system, le. that tasks will meet their hard deadlines. The RMS 
tasking is selected by specifying 'tm to the Ada link command. 






248 





