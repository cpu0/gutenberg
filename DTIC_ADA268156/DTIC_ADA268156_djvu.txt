
USAISEC 


AD-A268 156 




US Army Information Systems Engineering Command 
Fort Huachuca, AZ 85613-5300 


U.S. ARMY INSTITUTE FOR RESEARCH 
IN MANAGEMENT INFORMATION. 
COMMUNICATIONS, AND COMPUTER SCIENCES 



DTIC 

ELECTE 
AUGl 6 1993 

c 



SAMeDL: 

Technical Report Appendix D - 
Language Reference Manual 


ASQB-GI-92-017 
September 1992 


igtiarjrrcN. sr.^^rziigNT a 

Appi3t*4 m csiaasai 

tmakCMom v'aajui«d 


^ 1 C 0 

AIRMICS 

115 O’Keefe Building 
Georgia Institute of Technology 
Atlanta, GA 30332-0800 


I 






SECURITY CLASSIFICATION OF THIS PAGE 


REPORT DOCUMENTATION PAGE 


Form Approved 
0MB No. 0704-0188 
Exp. Date: Jun 30, 1986 



CLASSIFICATION AUTHORITY 


WNQRADING SCHEOUL 


4. PERFORMING ORGANIZATION REPO 



6a. NAME OF PERFORMING ORGANIZATION 


6c. ADDRESS (City. State, and Zip Code) 



. DISTRIBUTION/AVAILABILITY 
N/A 


ONITORING ORGANIZATION REPORT NUMBER(S) 
N/A 


7a. NAME OF MONITORING ORGANIZATION 
N/A 


7b. ADDRESS (City, State, and ZIP Coda) 


8b. NAME OF FU 
ORGANIZATION 


JIiTT7reW5T^iT7T5T5TfTIJIel 






N/A 


OCUREMENT INSTRUMENT IDENTIFICATION NUMBER 


10. SOURCE OF FUNDING NUMBERS 




Software Technology Branch, ARL 


8c. ADDRESS (City, State, and ZIP Code) 

115 O'Keefe Bldg. 

Georgia Institute of Technology 
Atlanta. GA 30332-0800 


11. TITLE (Include Security Classification) 

SAMeDL; Technical Report Appendix O - Language Reference Manual 



IT 


PROJECT 

TASK 

NO. 

NO. 


12. PERSONAL AUTHOR(S) 
MS. Deb Waterman 


13a. TYPE OF REPORT 
Technical Paper 


16. SUPPLEMENTARY NOTATION 


WORK UNIT 
ACCESSION NO. 


13b. TIME COVERED 
FROM Apr 91 TO Sept 92 


14. DATE OF REPORT (Year, Month, Dayi 15. PAGE COUNT 
Sept 15, 1992 I 125 


COSATI CODES 


GROUP SUBGROUP 


18. SUBJECT TERMS (Continue on reverse If necessary and Identify by block number) 

Ada Database Access, SAMeDL, Ada extension mod¬ 
ule , SQL 


19. ABSTRACT (Continue on reverse If necessary and Identify by block number) 

This report details the research efforts into the SQL Ada Module Data¬ 
base Description Language (SAMeDL). Four compilers are presented 
(Oracle, Informix, XDB, and Sybase) that allow Ada application programs 
to access database using a standard SQL query language. Copies of the 
compiler can be obtained from the DoD Ada Joint Program Office 
703/614-0209. 


20. OISTRIBUTION/AVAILABILITY OF ABSTRACT 
B UNCLASSIFIED/UNLIMITEP P SAME AS RPT. □ DTIC USERS 




21. ABSTRACT SECURITY CLASSIFICATION 
UNCLASSIFIED 


HONE (Include Area Code 






LTC David S. Stevens 


DO FORM 1473, 84 MAR 


(404) 894-3110 


83 APR edition may bo used until oxi^susted 

All other editions are obsoiate. SECURIT 


AMSRL-CI-CD 












































This research was performed by Statistica Inc., contract number DAKFll-91- 
C-0035, for the Army Institute for Research in Management Information, 
Communications, and Computer Sciences (AIRMICS), the RDTE organization of 
the U. S. Army Information Systems Engineering Command (USAISEC). This final 
report discusses a set of SAMeDL compilers and work enviomment that were devel¬ 
oped during the contract. Request for copies of the compiler can be obtained fi'om 
the DoD Ada Joint Program Office, 703/614/0209. This research report is not to 
construed as an official Army or DoD Position, unless so designated by other 
authorized documents. Material included herein is approved for public release, 
distribution unlimited. Not protected by copyright laws. 


TfflS REPORT HAS BEEN REVIEWED AND IS APPROVED 



Glenn E. Racine, Chief 
Computer and Information 
Systems Division 


jQ/mXo 




lames D. Gantt, Ph.D. 
'Director 

AIRMICS DTICQUAiJrr 


ACCOSIO'’ 


NTIS CRA&I 
OTIC TAB □ 

U idUMOi f’cecS Q 

JiibtlflCdllO'"' 


t Vo 


s-i_ - 

OisVibution/ 


Awdiiiibtlity Codes 


Oist 




A\/c)ll i)n<J / or 

Soecm 






SMleDL.TR.10.15 Sep 92 


appendix D 

SAMeDL Language Reference Manual 


D-1 



SAMeDL Language Reference Manual 


Intermetrics, Inc. 


Document IR-VA-011-1 
Date 07-July-1992 




Published by 
Inteimetrics, Inc. 

733 Concord Avenue, Cambridge, Massachusetts 02138 
Copyright (c) 1992 by Intermetrics, Inc. 


This material may be reproduced by or for the U.S. Government pursuant to the copyright license 
undei tlic clause at DFARS 252.227-7013 (Oct 1988). 




Table of Contents 


Chapter 1 


Chapter 2 


Chapter 3 


Chapter 4 


Introduction ••■•••••••••••«*««««*«******ft*«***»«**«»9««M*«»«»«*««*M***«****»**«*«***««**«**««««*»**««*«*«»**«** 1 


1.1 Scope.1 

1.2 Notation.1 

1.3 Forward References.2 

1.4 References.2 

1.5 Design Goals And Language Summary.3 

1.5.1 Design Goals.3 

1.5.2 Language Summary.3 

1-.5.2.1 Overview.3 

1.5.2.2 Compilation Units.4 

1.5.2.3 Modules.4 

1.5.2.4 Procedures and Cursors.4 

1.5.2.5 Domain and Base Domain Declarations.5 

1.5.2.6 Other Declarations.5 

1.5.2.7 Value Expressions and Typing.5 

1.5.2.8 Standard Post Processing.5 

1.5.2.9 Extensions.5 

1.5.2.10 Default Values in Grammar.6 


Lexical Elements ****•••••*«•*•••«•••••»*••••••••••••••••••••••••••••••••••••••••••••••••••••••»•••••••••••»•••7 

2.1 Character Set.7 

2.2 Lexical Elements, Separators, And Delimiters.7 

2.3 Identifiers.8 

2.4 Literals And Data Gasses. 8 

2.5 Comments.9 

2.6 Reserved Words.10 


Common Elements 




.11 


3.1 Compilation Units.11 

3.2 Context Causes.11 

3.3 Table N^es and the From Cause.12 

3.4 References. 12 

3.5 Assignment Contexts and Expression Conformance.16 

3.6 Standard Post Processing.17 

3.7 Extensions.17 


Data Description Language and Data Semantics --19 


4.1 Definitional Modules.19 

4.1.1 Base Domain Declarations.20 

4.1.1.1 Base Domain Parameters.20 

4.1.1.2 Base Domain Patterns.21 

4.1.1.3 Base Domain Options.22 

4.1.2 The SAME Standard Base Domains.24 

4.1.3 Domain and Subdomain Declarations.24 

4.1.4 Constant Declarations.28 

4.1.5 Record Declarations.30 

4.1.6 Enumeration Declarations.32 

4.1.7 Exception Declarations.33 

4.1.8 Status Map Declarations.33 

4.2 Schema Modules.34 





















































Chapter 5 


Appendix A 
Appendix B 
Appendix C 


Appendix D 
Appendix E 
Appendix F 


4.2.1 Table Definitions.35 

4.2.2 View Definitions.36 

4.3 Data Conversions.38 

Abstract Module Description Language.......^........................^............._41 

5.1 Abstract Modules.41 

5.2 Procedures.41 

5.3 Statements.46 

5.4 Cursor Declarations.49 

5.5 Cursor Procedures.53 

5.6 Input Parameter Lists.57 

5.7 Select Parameter Lists.58 

5.8 Value Lists And Column Lists.61 

5.9 Into_Clause And Insert_From_aause.63 

5.10 Value Expressions.66 

5.11 Search Conditions.72 

5.11.1 Comparison Predicate.74 

5.11.2 Between Predicate.74 

5.11.3 In Predicate.74 

5.11.4 Like Predicate.74 

5.11.5 Null Predicate.74 

5.11.6 Quantified Predicate.74 

5.11.7 Exists Predicate.75 

5.12 Subqueries.75 

5.13 Status Clauses.75 


SAMeDL_Standard 


.77 


SAMeDL__Systeni... 


.83 


Standard Support Operations and Specifications_........._.85 


C. 1 Standard Base Domain Operations.85 

C. 1.1 All Domains.^.85 

C. 1.2 Numeric Domains.86 

C. 1.3 Int and Smallint Domains.86 

C. 1.4 Character Domains.86 

C. 1.5 Enumeration Domains.87 

C. 1.6 Boolean Functions.88 

C.1.7 Operations Available to the Application.88 

C.2 Standard Support Package Specifications.89 

C.2.1 SQL_Standard.89 

C.2.3 SQL_Boolcan_Pkg.90 

C.2.4 SQL_Int_Pkg.90 

C.2.5 SQL_SmalIint_Pkg.92 

C.2.6 SQL_Real_Pkg.94 

C.2.1 SQL_Double_Precision_Pkg.96 

C.2.8 SQLjChar_Pkg.96 

C.2.9 SQL_Enumcration_Pkg.98 

Transform Chart ....... ..^......................^.................^............^.....lOl 


Glossary 




Syntax Summary................ 


••••••••••••••••••••• 


>••••••••*•« 


*******••••••••••••••••••••••••••••••••••••••••••••••••••••••••••• 


105 

107 





















































Index 






121 







Chapter 1 - Introduction 


Chapter 1 Introduction 

1.1 Scope 

This manual defines the SQL Ada Module Extensions Description Language (SAMeDL). 
The language described herein is strongly based on the draft language outlin^ by Marc Graham 
in [SAME]. 

The description in this manual assumes an underlying working knowledge, on the part of the 
reader, of the SAME methodology [SAMEGuide], the SQL standard [SQL], and the Ada 
standard [Ada]. 

1.2 Notation 

The notation used in this manual to specify language constructs is based on the Backus-Naur 
Form (BNF), which uses grammar rules to specify the syntax of a language. The syntax of a 
language defines what sequences of symbols are legal in that language. 

A BNF grammar consists of a set of terminal symbols^ a set of non-terminal symbols, and a set of 
productions (or rewrite rules). 

Non-terminal symbols are expanded by rewrite rules. They represent program constructs such as 
statements and expressions. 

Terminal symbols are not expanded by rewrite rules. They represent program symbols such as 
reserved words and punctuation marks. 

A production is a rewrite rule that allows a non-terminal symbol to be replaced by a (possible 
empty) sequence of terminal and non-terminal symbols. 

The following naming conventions are used within the grammar rules: 

• Lower case names (abstract_module, constant_declaration, etc.) represent non-terminal 
symbols. 

• Lower case names that are bold-faced (abi tract, record, etc.) and bold-faced strings 
(=, <>, etc.) represent terminal symbols. 

• The italicized prefixes Ada and SQL, when appearing in the names of syntactic 
categories, indicate that an Ada or SQL syntactic category has been incorporated into 
this document. For example, the category Ada_identifier is identical to the category 
identifier as described in section 2.3 of [Ada]; whereas the category SQL.identifier is 
identical to the category identifier as described in section 5.3 of [SQL]. 

• Numerical suffixes attached to the names of syntactic categories are used to distinguish 
appearances of the category within a rule or set of rules. 

The rules of productions are applied as follows: 

1. There is a special non-terminal symbol, called the start symbol, from which all legal 
sequences are generated." For example, the start symbol for the SAMeDL grammar is 
compilationunit. 


Intermetrics. Inc. 


1 






SAMeDL Language R^erence Manual 


2. Each production is of the form 

<non-terminal symbol> <sequence of symbols> 

and is interpreted as "the non-terminal on the left hand side may be replaced by the 
sequence of symbols on the right hand side." For example 

a b c 

means that "a" may be replaced by "b c". 

3. The symbol T may be used on the right hand side of a production to indicate a choice of 
replacements. For example 

a b I c 

means that "a" may be replaced by either "b" or "c". 

4. The symbols'[' and ’]' signify that the enclosed sequence is optional. For example 

a b [ c ] 

means that "c" is optional, and therefore "a" may be replaced by either "b" or "b c". 

5. The symbols '{' and signify the repetition (possibly 0 times) of the enclosed 
sequence. For example 

a :> b {b} 

means that "a" may be replaced by one or more "b" symbols. 

1.3 Forward References 

In order that a given section give thorough coverage of its subject, it is often necessary to employ 
terms, or to refer to grammatical productions, which have not yet appeared in the text. Generally 
references to the appropriate chapter or section will appear. For convenience, an alphabetic 
summary of the entire grammar of the language appears in Appendix F. 

1.4 References 

1. [Ada] Reference Manual for the Ada Programming Language, Ada Joint Program Office, 
1983. 


2. [ESQL] Database language - Embedded SQL, American National Standards Institute, 
X3.168-1989,1989. 

3. [SAME] The SQL Ada Module Description Language, Intermediate Version 3, Software 
Engineering Institute/Camegie Mellon University, 21 November 1991. 

4. [SAMEGuide] Guidelines for the Use of the SAME, Marc H. Graham: Software 
Engineering Institute/Camegie Mellon University, Technical Report CMU/SEI-89-TR-16, 
May 1989. 


2 


Intermetrics, Inc. 





Chapter 1 - Introduction 


5. [SQL] Database Language - SQL, American National Standards Institute, X3.135-1989, 
1989. 

6. [User] SAMeDL Development Environment User Manual, Intermetrics, Inc., IR-VA-012, 28 
February 1992. 

1.5 Design Goals And Language Summary 

1.5.1 Design Goals 

The SQL Ada Module Description Language (SAMeDL) is a Database Programming Language 
designed to automate the construction of software conforming to the SQL Ada Module 
Extensions (SAME) application architecture (see [SAMEGuide]). 

The SAME is a modular architecture. It uses the concept of a Module as defined in [SQL] and 
[ESQL]. As a consequence, a SAME-conforming Ada application does not contain embedded 
SQL statements and is not an embedded SQL Ada program as defined in [ESQL]. Such a 
SAME-conforming application treats SQL in the manner in which Ada treats all other languages: 
it imports complete functional modules, not language fragments. 

Modular architectures treat the interaction of the application program and the database as a 
design object. This results in a further isolation of the application program from details of the 
database design and implementation and improves the potential for increased specialization of 
software development staff. 

Ada and SQL are vastly different languages: Ada is a Programming Language designed to 
express algorithms, which SQL is a Datab^ase Language designed to describe desired results. 
Text containing both Ada and SQL is therefore confusing and difficult to maintain. SAMeDL is 
a Database Programming Language designed to support the goals and exploit the capabilities of 
Ada with a language whose syntax and semantics is based firmly in SQL. Beyond modularity, 
the SAMeDL provides the application programmer the following services: 

- An abstract treatment of null values. Using Ada typing facilities, a safe treatment of 
missing information based on SQL is introduced into Ada database programming. The 
treatment is safe in that it prevents an application from mistaking missing information 
(null values) for present information (non-null values). 

- Robust status code processing. SAMeDL’s Standard Post Processing provides a 
structured mechanism for the processing of SQL status parameters. 

- Strong typing. SAMeDL’s typing rules are based on the strong typing of Ada, not the 
permissive typing of SQL. 

- Extensibility. The SAMeDL supports a class of user extensions. Further, it controls, 
but does not restrict, implementation defrned extensions. 

1.5.2 Language Summary 

1.5.2.1 Overview 

The SAMeDL is designed to facilitate the construction of Ada database applications that 
conform to the SAME architecture as described in [SAMEGuide]. The SAME method involves 
the use of an abstract interface, an abstract module, a concrete interface, and a concrete module. 


Intermetrics, Inc. 


3 




SAMeDL Lanauafie Reference Manual 


The abstract interface is a set of Ada package specifications containing the type and procedure 
declarations to be used by the Ada application program. The abstract module is a set of bodies 
for the abstract interface. These bodies are responsible for invoking the routines of the concrete 
interface, and converting between the Ada and the SQL data and error representations. The 
concrete interface is a set of Ada specifications that defined the SQL procedures needed by the 
abstract module. The concrete module is a set of SQL procedures that implement the concrete 
interface. 

Within this document, the concrete module of [SAMEGuide] is called an SQL module and its 
contents are given under the headings SQL Semantics. The abstract modules of [SAMEGuide] 
are given under the heading Ada Semantics. 

L5.2.2 Compilation Units 

A compilation unit consists of one or more modules. A module may be either a definitional 
module containing shared definitions, a schema module containing table, view, and privilege 
definitions, or an abstract module containing local definitions and procedure and cursor 
declarations. 

L5.2.3 Modules 

A definitional module contains the definitions of base domains, domains, constants, records, 
enumerations, exceptions, and status maps. Definitions in definitional modules may be seen by 
other modules. 

A schema module contains the definitions of tables, views, and privileges. 

An abstract module defines (a portion oO an application’s interface to the database: it defines 
SQL services needed by an Ad? application program. An abstract module may contain 
procedure declarations, cursor declarations, and definitions such as those that may appear in a 
definitional module. Definitions in an abstract module, however, may not be seen by other 
modules. 

L5.2.4 Procedures and Cursors 

A procedure declaration defines a basic database operation. The declaration defines an Ada 
procedure declaration and a corresponding SQL proc^ure. A SAMeDL procedure consists of a 
single statement along with an option input parameter list and an optional status clause. The 
input parameter list provides the mechanism for passing information to the database at runtime. 
A statement in a SAMeDL procedure may be a commit statement, rollback statement, insert 
statement query, insert statement values, update statement, select statement or an 
implementation-defined extended statement. The semantics of a SAMeDL statement directly 
parallel that of its corresponding SQL statement. 

SAMeDL cursor declarations directly parallel SQL cursor declarations. In contrast to the 
language in [SQL], the procedures that operate on cursors, procedures containing either an open, 
fetch, close, update positioned or delete positioned statement, are packaged with the declaration 
of the cursor upon which they operate, thereby improving readability. Further, if no procedure 
containing an open, fetch or close statement is explicitly given in a cursor declaration, the 
language provides such procedures implicitly, thereby improving ease of use. 


4 


Intermetrics. Inc. 





Chapter 1 - Introduction 


1£.2S Domain and Base Domain Declarations 

Objects in the language have an associated domain, which characterizes the set of values and 
applicable operations for that object In this sense, a domain is similar to an Ada type. 

A base domain is a template for defining domains. A base domain declaration consists of a set 
of parameters, a set of patterns and a set of options. The parameters are used to supply 
information needed to declare a domain or subdomain derived from the base domain. Patterns 
contain templates for the generation of Ada code to support the domain in Ada applications. 
This code generally contains type declarations and package instantiations. Options contain 
information needed by the compiler. Parameters may be used in the patterns and options and 
their values may be referenced in other statements. 

Base domains are classified according to their associated data class. A data class is either 
integer, fixed float, enumeration, or character. A numeric base domain has a data class of 
enumeration, and defines both an ordered set of distinct enumeration literals and a bijection 
between the enumeration literals and their associated database values. A character base domain 
has a data class of character. 

1,5.2.6 Other Declarations 

Certain S AMeDL declarations are provided as a convenience for the user. For example, constant 
declarations name and associate a-domain with a static expression. Record declarations allow 
distinct procedures to share types. An exception declaration derines an Ada exception 
declaration with the same name. 

IS.2.1 Value Expressions and Typing 

Value expressions are formed and evaluated according to the rules of SQL, with the exception 
that the strong typing rules are based on those of Ada. In the typing rules of the SAMeDL, the 
domain acts as an Ada type in a system without user defined operations. Strong typing 
necessitates the introduction of domain conversions. These conversions are modeled ^er Ada 
type conversions; the operational semantics of the SAMeDL domain conversion is the null 
operation or identity mapping. The language rules specify that an informational message be 
displayed under circumstances in which this departure riom the Ada model has visible effect. 

1.5.2.8 Standard Post Processing 

Standard post processing is performed after the execution of an SQL procedure but before 
control is returned to the calling application procedure. The status clause from a SAMeDL 
procedure declaration attaches a status mapping to the application procedure. That status 
mapping is used to process SQL status data in a uniform way for all procedures and to present 
SQL status codes to the application in an application-defln^ manner, either as a value of an 
enumerated type, or as a user defined exception. SQL status codes not specified by the status 
map result in a call to a standard, database error processing procedure and the raising of the 
predefined SAMeDL exception, SQL_Database_Error. This prevents a database error from 
being ignored by the application. 

1.5.2.9 Extensions 

The data semantics of the SAMeDL may be extended without modification to the language by 
the addition of user-defined base domains. For example, a user-defined base domain of DATE 
may be included without modification to the SAMeDL. 


Intermetrics, Inc. 


5 





SAMeDL Language R^erence Manual 


DBMS specific (i.e., non-standaid) operations and features that require compiler modifications 
(e.g., dynamic SQL) may also be included into the SAMeDL. Such additions to the SAMeDL 
are referred to as extensions. Schema elements, table elements, statements, query expressions, 
query speciHcations, and cursor statements may be extended. The modules, tables, views, 
cursors, and procedures that contain these extensions are marked (with the keyword extended) to 
indicate that they go outside the standard. 

1.5,2.10 Default Values in Grammar 

Obvious but over-ridable defaults are provided in the grammar. For example, open, close, and 
fetch statements are essential for a cursor, but their form may be deduced from the cursor 
declaration. The SAMeDL will therefore supply the needed open, close, and fetch procedure 
declarations if they are not supplied by the user. 


6 


Intermetrics, Inc. 






Chapter 2 - Lexical Elements 


Chapter 2 Lexical Elements 

SAMeDL compilation units are sequences of lexical elements, which represent operators, 
delimiters, reserved words, identifiers, and numbers. These lexical elements correspond to the 
terminal symbols that appear in the grammar rules that define the syntax of SAMeDL. 

2.1 Character Set 

The only characters allowed in the text of a compilation are the basic characters and the 
characters that make up character literals (described in Section 2.4). Each character in the basic 
character set is represented by a graphical symbol. 

basjc_character :> letter | 

digit I 

special_character j 
space_character 


The characters included in each of the above categories or the basic characters are defined as 
follows: 

1. letter 

ABCDEFGHIJKLMNOPQRSTUVWXYZ 

abcdefghijklmnopqrstuvwxyz 

2. digit 

0123456789 

3. special character 

4. space_character 


2.2 Lexical Elements, Separators, And Delimiters 

The text of a SAMeDL compilation unit is a sequence of lexical elements. Each lexical element 
is either a delimiter, an identifier (which may be a reserved word), a literal, or a comment. 

Blanks, tabs, newlines, and comments are considered to be separators provided they do not 
appear within other lexical elements (i.e., a comment or a literal). One or more separators are 
allowed between adjacent lexical elements; explicit separators are required between adjacent 
lexical elements when they could bfe interpreted as a single lexical element without separation. 

A delimiter is either one of the following special characters 

or one of the following compound delimiters each composed of two adjacent special characters 
=> .. :=<>>=<= 


Intermetrics, Inc. 


7 







SAMeDL Language Reference Manual 


Each of the special characters listed for single character delimiters is a single delimiter except if 
this character is used as a character of a compound delimiter, or as a character of a comment or 
literal. 

The remaining lexical element forms are described in the foUowing sections of this chapter. 

2.3 Identifiers 

Identifiers are used as names and also as reserved words. In general, they take the form of Ada 
identifiers (see [Ada] Section 2.3). The exception is the use of 5j2L_identifiers as the names of 
schemas, tables, views, and columns. The major difference between Sj2^_identifiers and 
A da .identifiers is that Sj2^'_identifiers are limited to 18 characters in length, whereas 
Ada.identifiers are essentially unlimited in length. An SQL reserved word shall not appear at a 
point where the grammar specifies an 5j2L_identifieT, and an Ada reserved word shall not appear 
at a point where the grammar specifies an Add.identifier. 

identifier letter {[ underline ] letter.or.digit} 

underline ;;= _ 

letter_or_digit letter | digit 


The function SQLname that appears in this language is an approximation of an injection (one- 
to-one function) from the set of Add.identifiers to the set of SQL.identifiers, in the sense that, if 
II and I 2 are distinct Ada.identifiers within a SAMeDL compilation unit, then SQLname(Ii) is 
distinct from SQLNAME(f2)- 

2.4 Literals And Data Classes 

SAMeDL literals follow the SQL literal syntax and are categorized into five data type classes: 
character, integer, fixed, float, and enumeration. 

literal ::= databaseJHeral | enumerationjiteral 

databasejiteralcharacterjiteral | 

integerjiteral | 

fixedjiteral | 

floatjiteral 

character.literal' {character}' 

character ::= inplementation defined 

integerjiteral digit {digit} 

fixedjiteral integerjiteral. integerjiteral | 

. integerjiteral | 

integerjiteral. 

float.literal ::= fixedjiteral exp [ +1 - ] integerjiteral 
exp e I E 

enumerationjiteral Ada.identifier 


8 


Intermetrics, Inc. 






Chapter 2 - Lexical Elements 


1. Each literal L has an associated data class, denoted throughout this manual as 
DATACLASS(L). In particular, if L is a character, integer, fixed, float, or enumeration 
literal, the associated data class for L is character, integer, fixed, float, or enumeration 
respectively. 

2. Every character_literal CL has an associated length LENGTH(CL) in the sense of [SQL], 
section 5.2, rule 2. For any non-character literal, L, LENGTH(L) = NO_LENGTH. 

3. Integer, fixed, and float literals are collectively known as numeric literals; furthermore, 
integer and fixed literals are known as exact numeric literals while float literals are known 
as approximate numeric literals. Every numeric literal NL has a scale, SCALE(NL). An 
integer literal has scale 0. The scale of a fixed literal is the number of digits appearing to 
the right of the decimal point within the literal. The scale of a float literal is equal to the 
scale of any other float literal and is larger than the scale of any non-float numeric literal. 
Any non-numeric literal L, has SCALE(L) = NO_SCALE. See section 3.4 for the 
interpretation of enumeration_literals. 

4. The single quote or "tic" character can be included in a character_literal by duplicating the 
tic. For example, the string 'tic represents a character string literal of length 5 containing 
the characters: t, i, c, space, and dc. 

Examples: 


'a character string’ 

012 12 
0.5 .5 1. 

1.0E-5 .5e10 .5E+8 


•• the null character string 
“ character string of length 1 containing "tic" 
~ character string of length 18 
" integer literals having the value 12 
•- fixed literals 
- float literals 


2.5 Comments 

Comments are used to document the program for purposes of readability and maintainability. 
They do not affect the meaning of the program, and are present solely for the enlightenment of 
the human reader. 

A comment starts with two adjacent hyphens and extends up to the end of the line. A comment 
can appear on any line of a SAMeDL compUadon unit 


Intermetrics, Inc. 


9 


SAMeDL Language Reference Manual 


2.6 Reserved Words 

The identifiers listed below are reserved words and are reserved for special significance in the 
language. For readability of this manual, reserved words will appear “boldfaced”. 


abstract 

fetch 

pattern 

all 

for 

pos 

and 

foreign 

primary 

any 

from 

privileges 

as 

function 

procedure 

asc 


public 

authorization 

grant 


avg 

group 

raise 

record 

base 

having 

references 

between 

rollback 

body 

image 


boolean 

in 

scale 

by 

insert 

schema 


into 

select 

check 

is 

set 

class 


some 

close 

key 

status 

commit 

subdomain 

connect 

length 

sum 

constant 

like 


conversion 


table 

count 

map 

to 

current 

mark 

type 

cursor 

max 



min 

union 

data 

module 

unique 

dblength 


update 

dbms 

name 

use 

declare 

named 

user 

default 

new 

uses 

definition 

not 


delete 

null 

values 

derived 


view 

desc 

of 


distinct 

on 

where 

domain 

open 

vrith 


option 

work 

end 

or 


enumeration 

order 


escape 

exception 

exists 

extended 

out 



10 


Intermetrics, Inc. 








Chapter 3 - Common Elements 


Chapter 3 Common Elements 

3.1 Compilation Units 

A compilation unit is the smallest syntactic object that can be successfully processed by the 
SAMeDL compiler. It consists of a sequence of one or more modules. 

compilation_unit module {module} 

module definitionaLmodule | schema_module | abstract.module 


3.2 Context Clauses 

The context clauseis the means by which a SAMeDL module gains visibility to names defined in 
other modules. The syntax and semantics of SAMeDL context clauses are similar to the syntax 
and semantics of Ada context clauses (see [Ada] 8.4,10.1.1). 

contextcontext_clause {context_clause} 

context_clause with_clause | with_schema_clause | use.dause 

with_clause ::= with module.name [ as_phrase ] 

{, module.name [ as.phrase ]}; 

use.ciause :.= use module.name {, module.name} ; 

with_schema_ciause with schema schema.name [ asj>hrase ] 

{, schema.name [ asjphrase ]}; 

module.name ;:= Ada.identifier 

schema.name ;:= SQL.identifier 

asjshrase ::= as Adajdentifier 


1. Consider the following with.clause and with_schema_clause: 

with M [ as Ni ]; 
with schema S [ as N2 ]: 


In these clauses, M shall be the name of a definitional module and S the name of a schema 
module. The name M of the definitional module is said to be exposed if the as_phrase is 
not present in the context.clause; otherwise the name M is hidden and the name N 1 is the 
exposed name of M. Similar comments apply to S and N 2 . The name of a module (see 
Sections 4.1, 4.2, and 5.1) is its exposed name within the text of that module. Within the 
text of any module, no two exposed module names shall be the same. 

2. A module.name in a use.clause shall be the exposed name of a definitional.module that is 
an operand of a prior with.clause. 


Intermetrics, Inc. 


11 





SAMeDL Language Reference Manual 


3. The scope of a with_clause or use_clause in the context of a module is the text of that 
module. 

4. Only an abstract or schema module context may contain a with_schema_clause. 

Note: As a consequence of these definitions, abstract modules cannot be brought into the context 
of (withed by) another module. 

3.3 Table Names and the From Clause 

The table names in insert, update, and delete statements and the from clauses of select 
statements, cursor declarations, and subqueries (see Sections 5.3, 5.4, and 8.12) also make 
names, in particular column names, visible. The from_clause differs from an SQL_ffom_clause 
([SQL] 5.20) only in the optional appearance of the as keyword, which is inserted for uniformity 
with the remainder of the language. 

from_clause Irom table_ref {, table_ref) 

table_ref ;> table_name [ [ as j correlation_name ] 

table_name [ schema_ref. ] SOL_identifier 

schema_ref schema_name | Ada_identtfier 

correlation_name ::= SOL_identifier 


1. If present, schema_ref shall be either the schema_name in the authorization clause of the 
abstract module in which the table_name appears (see Section 5.1) or the exposed name of 
a schema module in the context of the module in which table_name appears (see Section 
3.2). In either case, the S0L_identifier shall be the name of a table within that schema 
module. If the schema_ref is absent from the table_name, then the SGL_identifier shall be 
the name of a table within the schema module named in the authorization clause of the 
module in which the table name appears. 

2. If the correlation name is not present in a table_ref, then the table name in the table_ref is 
exposed; otherwise the table_name is hidden and the correlation_name is exposed. No two 
exposed names within a from_clause shall be the same. 

3. For the scope of table_names see [SQL] section 5.20, syntax rule 4; section 8.5, syntax rule 
3; and section 8.12, syntax rule 5. 

3.4 References 

The rules concerning the meaning of references are modeled on those of Ada and those of SQL. 
As neither module nesting nor program name overloading occurs, these rules are fairly simple, 
and are therefore listed. For the purposes of this clause, an item is either: 

• A definitional, schema, or abstract module (Sections 4.1,4.2, 5.1) 

• A procedure, a cursor, or a procedure within a cursor (Sections 5.2, 5.4, 5.5) 

• Anything in the syntactic category definition (Section 4.1) 


12 


Intermetrics, Inc. 




Chapter 3 - Common Elements 


• A domain parameter (Section 4.1.1.1) 

• An enumeration literal within an enun^ration (Sections 2.4,4.1.6) 

• An exception (Section 4.1.7) 

• An input parameter of a procedure or cursor declaration (Sections 5.2,5.4, and 5.6) 

• A table defined within a schema module (Section 4.2) 

• A column defined within a table (Section 4.2) 

A location within the text of a module is said to be a defining location if it is the place of: 

• The name of an item with the item's declaration (Note: this includes enumeration 
literals within the declaration of an enumeration and domain parameters within the 
declaration of a domain) 

• The name of a table in a ffom_clause 

• The name of the target table of an insert, update, or delete statement 

• A schema_name or module_name in a context_clause 

Text locations not within comments that are not defining locations are reference locations. An 
identifier that appears at a reference location is a reference to an item. The meaning of that 
reference in that location, that is, the identity of the item referenced, is defined by the rules of 
this clause. When these rules determine more than one meaning for an identifier, then all items 
referenced shall be enumeration literals. 

module.reference ::= iAda.identjfier 

schema_reference ::= schema_name | >4cfajdentjfier 

base_domain_reference ::= [ module_reference. ] Ada_identifier 

domain_reference ::= (module_reference. ] i4da_identifier 

clomain_parameter_reference ;:= domain_reference.>\da_identifier 

subdomain_reference (nx)dule_reference. ] >tdajdentifier 

enumeration_reference (module_reference. J 4da_identifier 

enumerationJiteraLreference ::= [ module.reference. ] >Ada_identifier 

exception_reference [ module_reference. J 4dajdentifier 

constant_reference ::= [ module_referenc8. ] AdaJderHil'm 

record_referenc8 ;;= [ module.reference. 1 /^da_identifier 

procedure_reference ::= [ module_reference. ] AdaJdernWter 

cursor_re1erence .;= [ module_reference. ] >Wa_identifier 


Intermetrics, Inc. 


13 





SAMeDL Language Reference Manual 


cursor _proc_reference (cursor_rBference. J y4da_identifier 

input_reference :> [ procedure.reference. ] ^da_identifter | 

[ cursor_proc_reference.) ^dajdentifier 

status_refererx;e [ module_reference. ] AdaJtievAWm 

table_reference ::= [ schema_reference . ] SQL_identifier 

column_name::= SQi,_identifier 

column.reference [ table_reference . ] column_name 


A reference is a simple name (an identifier) optionally preceded by a prefix : a sequence of as 
many as three identifiers, separated by dots. Unlike Ada (see [Ada] sections 8.2, 8.3), it is 
necessary to treat the prefix as a whole, not component by component 

For the purposes of this clause, the text of a cursor does not include the text of the procedures, if 
any, contained within the cursor. A dereferencing rule is said to determine a denotation for a 
reference if it either (i) specifies an item to which the reference refers, or (ii) determines that the 
reference is not valid. 

Prefix Denotations 

The prefix of a reference shall denote one of the following: 

• An abstract module, procedure, cursor or cursor procedure, but only from within the 
text of the abstract module, procedure, cursor, or cursor procedure. 

• A table, if the table is in scope at the location in which the reference appears. 

• A domain. 

• A definitional or schema module. 

Note: As a consequence of the rule given earlier, that aU meanings of an identifier with multiple 
meanings must be enumeration literals, a prefix may have at most one denotation or meaning, as 
it may not denote an enumeration literal. 

LetL be the reference location of prefix P. LetX,Y. andZ be simple names. Then: 

1. If L is within the text of a cursor procedure U, then P denotes 
a. The cursor procedure U if either 

i. P is of the formX and X is the simple name of U; or 

ii. P is of the form X.Y; X is the name of the cursor containing L (and 
therefore also (/ ); in which case T shall be the simple name of U else 
the prefix is not valid; 

iii. P is of the form X.YZ: X is the name of the module containing L; Y is 
the name of the cursor continuing L (and therefore also f/ ); in which 
case Z shall be the simple name of U else the prefix is not valid; 


14 


Intermetrics, Inc. 





Chapter 3 - Common Elements 


b. The table T being updated in a cursor_update_statement, if the statement wi thin 
the cursor procedure containing L is a cursor_update_statement and either 

i. P is of the form X andX is the simple name of 7; or 

ii. P is of the form X.Y; ^ is an exposed name for the schema module S 
containing the declaration of T and Y is the simple name of T. 

2. If rule 1 does not determine a denotation for P, then P denotes 

a. The cursor or procedure R, if L is within the text of R and either 

i. P is of the formX and X is the simple name of/?; or 

ii. P is of the form X.Y; X is the name of the module containing L (and 
therefore also R)\Y is the simple name of R ; 

b. The table T, if L is in the scope of table name T (see Section 3.3) and either 

i. P is of the formX and X is the simple name exposed for T; or 

ii. P is of the form X.Y; X is the exposed name of the schema module 
containing*the table T andT is a simple name of T. 

3. If rules 1 and 2 do not determine a denotation for P, then P denotes the domain R, 

a. If /* is of the form X and X is the simple name of R and the declaration of R 
appears in the module containing L and precedes L within that module; or 

b. P is of the form X.Y\ X is the exposed name of the module containing the 
declaration of R and Y is the simple name of R. 

4. If none of the above rules determines a denotation for P, then /* is a simple name that 
denotes the 

a. Definitional module M if either 

\. L is in the scope of a with_clause exposing P as the name of M\ or 
ii. L is in the deHnitional module M and P is the name of M. 

b. Schema module S if either 

i. L is in the scope of a with_schema_clause exposing 7 as the name of S; 
or 

ii. L is in an abstract module whose authorization clause identifies S and P 
is the name of S; 

c. Abstract module M if L is within the text of M and P is the name of Af; 

d. Domain D, if D is declared within a module N such that there is a use clause 
for N in the module containing L, and P is the name of D. 


Intermetrics, Inc. 


15 





SAMeDL Lanfjuage Rrference Manual 


Denotations of Full Names 

Let L be the location of a reference Id. Then Id is a reference to the item Im if Im is not a 
module, procedure, cursor or cursor procedure, or table and 

1. Id is of the formwhere X is the name of/w and P is a prefix denoting 

a. A definitional module containing the declaration of Im; 

b. The abstract module, M, in which L appears, and Im is declared in M at a text 
location that precedes L; 

c. The procedure, cursor, or cursor procedure that contains L, and Im is an input 
parameter to that procedure, cursor, or cursor procedure; 

d. A table, in which case Im is a column within that table; 

e. A schema module, in which case Im is & table within that module. 

f. A domain, in which case Im is a parameter in that domain. 

2. Id is of the form X and X is the name of Im. Then 

a. L appears in a cursor, procedure, or cursor procedure and 

i. Im is an input parameter to that cursor, procedure, or cursor procedure; 

ii. Im is a column of one of the tables in scope of L; 

b. If rule (a) does not determine a denotation for Id, then Im is declared in the 
module containing L at ^ location preceding L; 

c. If neither rule (a) nor (b) determines a denotation for Id, then Im is declared 
within a module M such that the module containing L has a use clause for M. 

Note: An item Im is visible at location L if there exists a name Id (either simple or preceded by 
a prefix) such that if id were at location L, then Id would be a reference to Im. 

3.5 Assignment Contexts and Expression Conformance 

A value expression (see Section 5.10) is said to appear in an assignment context if it is either: 

1. The static expression in a constant declaration (see Section 4.1.2); 

2. A select parameter (see Section 5.7); 

3. A value in an insert_value_list (see Section 5.8); or 

4. The right hand side of a set_item within an update_statement (see Section 5.3). 

A value expression VE is said to conform to a domain D under the following conditions: 


16 


Intermetrics, Inc. 



Chapter 3 - Common Elements 


1. If DOMAIN(V£) NO.DOMAIN. then DOMAIN(V£) = D. 

2. If DATACLASS(D) is integer or fixed, then DATACLASS(V£) is integer or fixed. 

3. If DATACLASS(D) is float, then DATACLASSCKE) is integer, fixed, or float. 

4. If DATACLASS(D) is character, then DATACLASS(VE) is character. 

5. If DATACLASS(D) is enumeration, then if DOMAIN(V£) = NO.DOMAIN, then V£ 
is an enumeration literal in D. 

3.6 Standard Post Processing 

Standard post processing is the processing that is done after execution of an SQL procedure, but 
before control is returned to the catling application. That processing is described as follows: 

1. If a status map is attached to the procedure (see Section 5.13), then if that n;ap contains 
an sqlcode_assignment whose left-hand side is equal to the value of the SQLCODE 
parameter, then the Ada procedure's status parameter is set to the value of the right hand 
side of the sqlcode_assignment, if that right hand side is an Add_enumeration_iiteral; if 
that right hand side is a raise statement, then the named Ada exception is raised. This 
is not considered an error condition in the sense of the next paragraph. In particular, 
SQL_Database_Error_Pkg.Process_Database_Error is not called. 

2. If the value of the SQLCODE parameter is not matched by the left hand side of any 
sqlcode_assignment in the map attached to the procedure or there is no status map 
attached to the procedure and the value of the SQLCODE parameter is other than zero, 
then an error condition exists. In this case the parameterless procedure 
SQL_Database_Error_Pkg.Process_Database_Error is called. The exception 
SAMeDL_Standard.SQL_Database_Error is raised. 

3.7 Extensions 

Extended tables, views, modules, procedures, and cursors allow for the inclusion into the 
SAMeDL of DBMS-specific, that is, non-standard, operations and features, while preserving the 
benefits of standardization. These DBMS-specific extensions may be verbs, such as connect and 
disconnect, that signal the beginning and end of program execution, ot functions, such as date 
manipulation routines, that extract the month from a date. The use of extensions, particularly the 
extended keyword, serves to mark those modules, tables, views, cursors, and procedures that go 
outside the standard and may require effort should the underlying DBMS be changed. 

extended_schema_element ::= implementation defined 

extended_table_element ::= implementation defined 

extended_statement ::= implementation defined 

extended_query_expression implementation defined 

extended_query_specification ::= implementation defined 

extended_cursor_statement implementation defined 


Intermetrics, Inc. 


17 





SAMeDL Language Reference Manual _ 

Details concerning implementation defined extended features can be found in [User], 


18 


Intermetrics, Inc. 





Chapter 4 - Data Description Language and Data Semantics 


Chapter 4 Data Description Language and Data Semantics 

4.1 Deflnitional Modules 

Definitional modules contain declarations of one or more declarations of elements such as 
domains, constants, records, enumeration types, and status maps. An Ada library unit package 
declaration is defined for each definitional module. 

definitional_module ;;= [ context ] 

[ extended ] 

definition module iAda_identifier_1 is 
{definition} 

end (i4da_identifier_2 ]; 

definition :;= base_domain_declaration | 

domain_declaration { 

subdomain_declaration | 

constant_declaration j 

record_declaration j 

enumeration_declaration j 

exception_declaration | 

status_map_declaration 


When present, Add_identifier_2 shall equal A<fa_identifier_l. 

Notes: 

• No with_schema_clause shall appear in the context of a definitional module (see 
Section 3.2). 

• No two declarations within a definitional module shall have the same name, except for 
enumeration literals (see Section 4.1.6). 

Ada Semantics 


For each definitional module within a compilation unit there is a corresponding Ada library unit 
package generated which has the same name as the definitional module. For each definition 
within the definitional module, an Ada construct which provides the appropriate Ada semantics 
for the definition will be generated and placed within the specification of that package. 


Intermetrics, Inc. 


19 






SAMeDL Language Rrference Manual 


4.1.1 Base Domain Declarations 

Base domains are the basis on which domains are detined. A base domain declaration has three 
parts; a sequence of parameters, used in domain declarations to supply information to the other 
two parts; a sequence of patterns, used to produce Ada source code in support of a domain; and a 
sequence of options, used by the compiler in implementation-defined ways. 

base_domain_declaration [ extended ] base domain ^da_identifier_1 

[ {base_domainjparameterjist) ] 

Is 

patterns 

options 

end [ Adajdentr(ier_2 ]; 

base_domain_parameter_list ::= base_domain_parameter {; base_domain_parameter} 


1. If present, A(ia_identifier_2 shall equal Ada_identifier_l. Ada_identifier_l is the name of 
the base domain. 

2. The keyword extended may appear in a base_domain_declaration only if it also appears in 
the enclosing module declaration. 

4.1.1.1 Base Domain Parameters 

base_domain_parameter ::= Adajdentifier: data_class [ := static_expression ] | 

map :s pos I 

map :s Image 


data.class integer | 
character j 
fixed i 

float 1 

enumeration 


1. The Ada identifiers within the list of base_domain_parameters of a 
base_domain_declaration are the names of the parameters that may appear in a 
parameter_association_list within a domain_declaration based on this base domain (see 
section 4.1.3). The static_expression within a base_domain_parameter, when present, 
specifies a default value for the parameter. This default value shall be of the correct 
data.class; that is, in the parameter declaration 

Id : del := expr; 


where del is a data.class, DATACLASS(expr) shall be del. Further, DATACLASS(Id) is 
del, whether or not the initializing expression expr is present, and DOMAIN(Id) is 
NO.DOMAIN. 

2. A base domain is classiHed by its data.class. That is, an enumeration base domain is a 
base domain whose data_class is enumeration, a fixed base domain is a base domain 
whose data_class is fixed, etc. 

3. Every enumeration base domain has two predefined parameters: enumeration and map. 
These parameters are special in that the values that are assigned to them by a domain 


20 


Intermetries, Ine. 





Chapter 4 - Data Description Language and Data Semantics 


declaration (see section 4.1.3) are not of any of the data classes listed above. The value of 
an enumeration parameter is an enumeration_reference (see section 3.4); the value of map 
is a database_mapping (see section 4.1.3). A base domain declaration may explicitly 
declare a map parameter for the purpose of assigning a default mapping. An enumeration 
base domain shall not redefine the predefined base_domain_parameter enumeration. 

There are two possible default mappings; pos and image. The value pos specifies that the 
Ada predefined attribute function 'POS of the Ada type corresponding to the 
enumeration_reference, which is the enumeration parameter value in the domain 
declaration, shall be used to translate enumeration literals to their database encodings. 
Similarly for image and the 'IMAGE attribute. See annex A of [Ada] and sections 4.1.3 
and 4.3 of this document. 

4. Every fixed base domain has a predefined parameter scale whose value is an integer of an 
implementation defined range (see [SQL], section 5.5). A fixed base domain shall not 
redefine the predefined base_domain_parameter scale. 

5. Every character base domain has a predefined parameter length whose value is an integer 
of an implementation defined range (see [SQL], section 5.5). A character base domain 
shall not redefine the predefined base_domain_parameter length. 

4.1.1,2 Base Domain Patterns 

The patterns portion of a base domain declaration forms a template for the generation of Ada 
text, which forms the Ada semantics of domains based on the given base domain. 

patterns ::= {pattern} 

pattern domain_pattem | 
subdomain_pattem j 
derived_clomain_pattem 

domainjsattem ;;= domain pattern is pattemjist 
end pattern; 

subdomainjDattem ::= subdomain pattern is pattemjist 

end pattern; 

derived_domain_pattem ;:= derived domain pattern is pattemjist 

end pattern; 

pattemjist ;:= pattem_element { pattem_element} 
pattem_element ::= characterjiteral 


Patterns are used to create the Ada constructs that implement the Ada semantics of a domain, 
subdomain, or derived domain declaration (sec sect 4.1.3). Patterns are considered templates; 
parameters within a pattern are replaced by the values assigned to them either in the domain 
declaration, by inheritance, or by default. 

For a parameter to be recognized as such in a pattern, it is enclosed in square brackets ([, ]). For 
the purpose of pattern substitution, a base domain may use a parameter self. When a pattern is 
instantiated, self is the name of the domain or subdomain being declared. A base domain may 
use a parameter parent for the purpose of pattern substitution in a subdomain_pattem or a 


Intermetrics, Inc. 


21 




SAMeDL Language Reference Manual 


derived_domain_pattem. When such a pattern is instantiated, parent is the name of the parent 
domain (see section 4.1.3). 

Within a given character_literal of a pattern, a substring contained in matching curly brackets ({, 
1) is an optional phrase. Optional phrases may be nested. An optional phrase appears in the 
instantiated template if all parameters within the phrase have values assigned by a domain 
declaration; the phrase does not appear when none of the parameters within the phrase has an 
assigned value. If some but not all parameters within an optional phrase have values assigned by 
a given domain declaration, the declaration is in error. 

4.1.1.3 Base Domain Options 

options ::= {options} 

option fundamental | 

for wordjist use pattemjist; | 
for wordjist use predefined ; 

fundamental for not null type rtame use pattemjist; | 

for null type name use pattemjist; j 

for data class use datajclass ; | 

for dbms type use dbmsjype [ pattemjist ]; j 
for conversion from type to type use converter ; 

dbms_type ::= Int | 

integer j 

smaliint | 

real j 

double precision j 
char i 

character j 

implementation defined 

type ;;= dbms | not null | null 

converter ;:= function pattemjist | 
procedure pattemjist j 
type mark 

wordjist ::= context clause | 

null value | 

null_bearing assign j 
not_null_bearing assign 


Options are used to define aspects of base domains that are essential to the declaration of 
domains within the SAMeDL. The fundamental options are required. Implementations may add 
options beyond those given above. The meanings of the fundamental options are given by the 
following Ust. 

1. The null and not null type names are the targets of the function AdaTYPE. They are the 
names of the types of parameters and parameter components in Ada procedures. See 
sections 5.6 and 5.7. 

2. The data class option specifies the data class (sec section 4.1.1.1) of all objects of any 
domain based on this base domain. If BD is a base domain to which the data class dc is 


22 


Intermetrics, Inc. 








Chapter 4 - Data Description Language and Data Semantics 


assigned by an option in its definition, and if D is a domain based directly or indirectly 
(see section 4.1.3) on BD, then DATACLASS(D) = dc. The data class governs the use of 
literals with such objects (see sections S.8 and S.IO). 

3. The dbms type of a base domain is the 5QL_data_type (see [SQL] section 5.5) to be used 
when declaring parameters of the concrete interface (SQL module) for all objects of 
domains based directly or indirectly on the base domain. See sections 5.6, 5.7, and 5.8 of 
this document. If the dbms type of a base domain is implementation denned, the keyword 
extended shall appear in the declaration of the base domain. 

4. An operand of the conversion option is a means of converting non-null data between 
objects of the not null-bearing type, the null-bearing type (see section 4.1.3) and dbms type 
associated with a domain. A method shall be a function, a procedure, an attribute of a t]^, 
or a type conversion. A means of determining the identity of these methods shall appear in 
the options of a base domain. The identity of a method may be given as a pattern 
containing parameters. 

However, enumeration domains do not have converters between the dbms type and the not 
null-bearing type, as the map-parameter predefined for all enumeration domains describes a 
conversion method between enumeration and database representations of non-null data. 
The method is the application, as appropriate of the function described by the 
database_mapping that is the operand of the map parameter association (see sections 
4.1.1.1 and 4.1.3). 

Additional, implementation-defined options are used to provide information to the SAMeDL 

Compiler that is not provided via the fundamental options. The Intermetrics SAMeDL Compiler 

makes use of 4 additional options, described by the wordjist grammar. These options are all 

required. The meanings of these options are given by the following list. 

1. The context clause option specifies the WITH and/or USE clauses required by packages 
that declaredomains using the base domain. Each base domain must rely on at least one of 
the SAMeDL standard packages (SQL_Char, SQL_Int, etc.), so this option is required. 
The context clauses are specitied as patterns, and the patterns must not include references 
to [self], [parent], or any of the base domain parameters. This option must appear once and 
only once for each base domain declaration. 

2. The null value option provides the SAMeDL compiler with a pattern that can be used as a 
null value for all domain declarations based on the base domain declaration. 

3. The null_bearing assign option designates a function for assigning an object of the base 
domain'sliull-bearing type tg another object of the null-bearing type. Either a pattern or 
the word predefined may be used to express the conversion function. Use of the word 
predefined indicates that the standard operator := should be used to perform the 
conversion. 

4. The not_null_t>earing assign option designates a function for assigning an object of the 
base domain's not-null type to another object of the not-null type. Either a pattern or the 
word predefined may be used to express the conversion function. Use of the word 
predefined indicates that the standard operator := should be used to perform the 
conversion. 


Intermetrics, Inc. 


23 





SAMeDL Language R^erence Manual 


4.U The SAME Standard Base Domains 

The predefined definitional module, SAMeDL_Standard, contains the declarations of the 
predefined SAME Standard Base Domains: SQL_Int, SQL_Smallint, SQL_Char, SQL_Real, 
SQL_Double_Precision, SQL_Enumeration_as_Char, and SQL_Enumeration_as_Int. The text 
of SAMeDL_Standard appears in Appendix A. 

4.1 J Domain and Subdomain Declarations 

domain_declaration domain >4da_identifter is new bas_dom_ref [ not nuii] 

((parameter_associationJist) ]; 

subdomain_declaration subdomain A/a_identifier is dom.ref [ not nuii] 

[ (parameter_associationJist) ]; 

dom_ref ::= domain_reference | subdomain_reference 

bas_dom_ref ::= dom_ref | base_domain_reference 

parameter_associationJist parameter_association {, parameter_association} 

parameter_assocjation /dajdentifier s> static_expression | 

map => database_fnapping j 

enumeration a> enumeration_reference j 
scaie s> static.expression j 

length => static.expression 

database.mapping enumeration.associatjonjist | pos | Image 
enumeration.associationjist(enumeration_association {, enumeration_association}) 
enumeration association enumeration literal => database literal 


1. Consider the domain declaration: 

domain DO is new EE_ 

a. If EE is a base_domain_reference, then EE is said to be the base domain of DD. 

b. Otherwise, EE is a domain_reference or subdomain_reference, the base domain of DD 
is defined to be the base domain of EE, DD is said to be derived from EE, and EE is 
said to be the parent of DD. 

2. Similarly, in the subdomain declaration 

subdomain FF Is GG 

the base domain of FF is defined as the base domain of GG, FF is said to be a subdomain of 
GG, and GG is said to be the parent of FF. 

3. The database type of a domain D, denoted as DBMS_TYPE(D), is the value, appropriately 
parameterized, of the for dbms type option from the base domain of D. See section 
4.1.1.3. 


24 


Intermetrics, Inc. 




Chapter 4 - Data Description Language and Data Semantics 


4. The data class of a domain D, denoted DATACLASS(£)), is the data class of its base 
domain, the value of the for data class option. A domain is numeric if its data class is 
numeric. 

5. Except for scale, enumeration, length, and map, an Ada.identifler within a 
parameter_association shall be the name of a base_domain_parameter in the declaration of 
the base domain of the domain or subdomain being declared. See section 4.1.1.1. 

6. A domain or subdomain D is said to assign the expression E to the parameter P, if 

a. the parameter_association P => E appears in the declaration of D\ or 

b. (a) does not hold, D is a subdomain or a derived domain, and the parent domain assigns 
the expression £ to the parameter/*; or 

c. (a) and (b) do not hold and in the base_domain_declaration for the base domain of D, 
the base_domain_parameter 

P : class := E 

appears. 

In all cases, DATACLASS(£) shall be DATACLASS(/*) as defined by the declaration of 
the base domain. See section 4.1.1.1. 

7. If a domain/) assigns the expression £ to a parameter/*, then 

• DOMAIN(D.P) = NO_DOMAIN 

• DATACLASS(D.P) = DATACLASS(E) 

• LENGTH(D.P) = LENGTH(E) 

• SCALE(D.P) = SCALE(E) 

8. A domain_declaration shall assign an expression to each base_domain_parameter that 
appears in any non-optional phrase 

• of the base domain's domain_pattern, if the declaration is not declaring a derived 
domain; 

• of the base domain's deriyed_domain_pattem, if the declaration is the declaration of a 
derived domain. 

Similar rules govern subdomain_declarations and subdomain.pattems. See section 4.1.1.2. 

9. The scale of a domain D, denoted SCALE(D), is defined by 

• if Z) is not a numeric domain, SCALE(D) = NO_SCALE; 

• if D is an integer domain, SCALE(£>) = 0; 

• if D is a float domain, SCALE(Z)) = a value greater than the scale of any non-float 
domain or object; 


Intermetrics, Inc. 


25 





SAMeDL Language Reference Manual 


• if D is a fixed domain, SCALE(D) = the value assigned by D to the scale 
base_domain_parameter. 

The value assigned to the scale parameter in the declaration of a fixed domain shall be an 
integer from an implementation defined range. 

10. The length of a domain D, denoted LENGTH(D), is defined by 

• if D is not a character domain, LENGTH(D) = NO_LENGTH; 

• if D is a character domain, LENGTH(D) = the value assigned by D to the length 
base_domain_parameter. 

The value assigned to the length parameter in the declaration of a character domain shall be 
an integer from an implementation defined range. 

11. Any domain_declaration or subdomain_declaration of an enumeration domain shall assign 
an enumeration_reference to the base_domain_parameter enumeration and a 
database_mapping to the base_domain_parameter map. If the map parameter is assigned 
an enumeration_association_list, then 

• Each cnumeration_literal within the enumeration referenced by the 
enumeration.reference given by the enumeration parameter shall appear as the 
enumeration_literal of exactly one enumeration_association. 

• No database.literal shall appear in more than one enumeration.association. 

Note: These constraints ensure that the database.mapping is an invertible (i.e., one-to-one) 
function. That function is used for both compile time and runtime data conversions. See 
sections 4.1.1.3 and 4.3. 

12. Let D be an enumeration domain or subdomain declaration and let En be the name of the 
enumeration referenced by the value assigned by D to the enumeration 
base_domain_parameter. D is said to assign the expression E to the enumeration literal 
El, if D assigns the database.mapping M as the value of the map base_domain_parameter 
andM 

• is pos, and E = En'Pos(El), or 

• is image, and E = En'Image(El), or 

• is an enumeration_association_list containing an enumeration_association of the form 
El=>E 

See section 4.1.6. 

13. The database_mapping of an enumeration domain or subdomain declaration D should 
preserve the ordering implied by that domain’s enumeration_reference ER. That is, if L/ 
and L 2 are enumeration literals of ER such that Ly occurs before L 2 in ER's 
enumeration_literal_list, then the value assigned to Ly by D should be less than the value 

assigned to L 2 byD. 


26 


Intermetrics, Inc. 


Chapter 4 - Data Description Language and Data Semantics 


14. A domain or subdomain is said to be not null only if it or any of its parent domains is 
declared with the not null phrase. In that case no object of the domain can contain the null 
value. 

Ada Semantics 

An instantiation of a pattern deHned for the base domain of the domain being declared, as 
described in section 4.1.1.2, shall appear within the Ada package specification corresponding to 
the module within which the domain_declaration appears. If in the domain declaration: 

domain DD Is new EE ... 


EE is a base_domain_reference, then the domain_pattem is instantiated; if EE is a 
domain_reference, the derived_domain_pattem is instantiated; for the subdomain declaration 

subdomain FF is GG ... 


the subdomain_pattem is used. 

Examples: 

The following examples illustrate the declaration of domains and have been annotated with 
references to Ae appropriate clauses of the language definition. The base domains used in these 
examples exist in the predefined definitional module SAMeDL.Standard, which appears in 
Appendix A. The constant Max_SQL_Int is declared in the predefined definitional module 
SAMeDL_System (see Appendix B). Both SAMeDL_Standard and SAMeDL_System are 
assumed to be visible, as is the enumeration declaration Colors (sec section 4.1.6). 


domain Weight_Domain Is new SQL Int ( -4.1.3: #1a 

Rrst => 0, ~ -4.1.3: #5 and #8 

Last => Max_SQLJnt): -4.1.3: #5 and #8 

domain City_Domain is new SQL_Char ( -4.1.3: #1a 

Length => 15); -4.1.3: #5 and #10 

domain Color_Domajn is now SQL_Enumeration_As_Char { -4.1.3: #1a 
enumeration » Colors, -4.1.3: #11 

map => image); -4.1.3: #11 and #12 


domain Auto_Weight is new Wejght.Domain ( 
Last => 10000); 


-4.1.3: #1b 
- 4.1.3: #5 


subdomain Auto_Part_Weight is Auto_Weight ( 
Last »> 2000); 


-4.1.3: #2 
-4.1.3: #5 and #8 


The declarations produce the following Ada code: 

-the Ada code below is the instantiation of the domain pattern 
from the base domain SQLJnt 

type Weight_Domain_Not_Null is new SQLJnt_Not_Null 
range 0 .. implementation_defined; 
type Weight_Domain_Type is now SQLJnt; 


Intermetrics, Inc. 


27 




SAMeDL Language Reference Manual 


package Weight_Domain_Ops is new SQLJnt.Ops ( 

Weight_Domain_Type, Weight_Domain_Not_Null): 

"the Ada code below is the instantiation of the domain pattern 
from the base domain SQL_Char 

type City_DomainNN_Base is new SQL_Char_Not_Null: 
subtype City_Domain_Not_Null is City_DomainNN_Base (1.. 15); 
type City_Domain_Base is new SQL_Char; 

subtype City_Domain_Type is City_Domain_Base(City_Domain_Not_Null’Length): 
package City_Domain_Ops is new SQL_Char_Ops 
(City_D6main_Base, City_C)omainNN_Base); 


"the Ada code below is the instantiation of the domain pattern 
from the base domain SQL_Enumeration_As_Char 

type Color_C)omain_not_null is new Colors; 

lockage Color_Domain_Pkg is now SQL_Enumeration_Pkg {Color_Domain_not_null): 
type Color_C)omain_Type is new Color_Domain_Pkg.SQL_Enumeration: 


"the Ada code below is the instantiation of the derived domain pattern 
from the base domain SQLJnt 

type Auto_Weight_Not_Null Is new Weight_Domain_Not_Null 
range Weight_Domain_Not_NuirFirst .. 10000; 
type Auto_Weight_Type is new Weight_Domain_Type; 
package Auto_Weight_Ops is new SQLJnt.Ops ( 

Auto_Weight_Type, Auto_Welght_Not_Null); 


"the Ada code below is the instantiation of the subdomain pattern 
from the base domain SQLJnt 

subtype Auto_Part_Weight_Not_Null is Auto_Weight_Not_Null 
range Auto_Weight_Not_NuirFirst .. 2000; 
type Auto_Part_Weight_Type Is new Auto_Weight_Type; 
package Auto_Part_Weight_Ops is new SQLJnt_Ops ( 
Auto_Part_Weight_Type, Auto_Part_Weight_Not_Null); 


4.1.4 Constant Declarations 

constant_declaration constant Ada.identifier [: domain_reference ] 

is static_expressjon; 

static_expressionvalue_expression 


A static expression is a value expression (see section 5.10) whose value can be calculated at 
compile time; i.e., whose leaves are all either literals or constants. 

Let K denote the constant declaration 

constant C [: 0 ] Is E; 


28 


Intermetrics, Inc. 







Chapter 4 - Data Description Language and Data Semantics 


1. DATACLASS(K) is DATACLASS(E), the data class of the static expression E. 

2. If DATACLASS(K) is enumeration, then D shall be present in the constant declaration 
and shall name an enumeration domain of which the static expression E is an enumeration 
literal. 

3. If DATACLASS(K) is character, then D shall be present 

4. If the domain_reference D is not present then 

a. C is a universal constant of type DATACLASS (K). 

b. AdaTYPE(K) is an anonymous type, universal^, where T is DATACLASS(K). 

c. if DATACLASS(K) is numeric, then SCALE(K) = SCALE(E). 

d. DOMAIN(K) = NO_DOMAIN. 

5. If the domain_reference D is present then 

a. DOMAIN(K) = D and E shall conform to D. 

b. If DATACLASS(K) is numeric, then SCALE(K) = SCALE(D), and SCALE(E) shall 
not exceed SCALE(D). 

c. If DATACLASS(K) is character, then LENGTH(K) = LENGTH(D) and LENGTH(E) 
shall not exceed LENGTH(D). 

d. AdaTYPE(K) is defined as the type name within D designated as not null bearing. 

Ada Semantics 

Let VALUE represent the function which calculates the value of a static_expression. Let SE be 
a static_expression. VALUE(SE) is given recursively as foUows: 

1. If SE contains no operators, then 

a. If SE is a database_literal, then VALUE(SE) = SE. 

b. If SE is an enumeration_literal of domain D, and D assigns expression E to that 
enumeration literal, then VALUE(SE) = E. 

c. If SE is a reference to the constant whose declaration is given by 

constant C [:*D ] is E; 

.hen VALUE(SE) = VALUE(E). 

d. If SE is a reference to a parameter P from domain D, and D assigns the 
expression E to P, then VALUE(SE) = VALUE(E). 

2. If SE is D(SEi), where D is a domain name, then VALUE(D(SEi)) = VALUE(SEi). 

3. If SE is +SEi (or -SEi), then VALUE(SE) = +VALUE(SEi) (or -VALUE(SEi)) 


Intermetrics, Inc. 


29 




SAMeDL Language R^erence Manual 


4. If SE is SEi op SE 2 where op is an arithmetic operator, then VALUE(SE) = 
VALL)E(SEi) op VALUE(SE 2 ) where op is evaluated according to the rules of SQL. 

5. If SE is (SEi) then VALUE(SE) = (VALUE(SEi)). 

Again, let K denote the constant declaration 

constant C [: D ] Is E ; 

Let Q be the Ada representation of VALIJE(E). Then the Ada library package specification 
corresponding to the module in which the constant declaration K above appears shall have an 
Ada constant declaration of the form 

C ; constant [AdaTYPE (K)] := Q; 

The type designator AdaTYPE(K) is omitted from this declaration if it is an anonymous type. 
Examples: 

The following SAMeDL constant declarations 

constant Zero Is 0; - a named number of type universaijnt 

constant Val : ValDomain is 1; •• a constant value of ValDomain type 


will produce the following Ada code: 

Zero : constant 0; 

Val : constant ValOomain_not_null 1; 

4.U Record Declarations 

record_declaration record ^da_identifier_1 [ named_phrase ] Is 

component_deciarations 
end [ Acfa_identifier_2 J; 

named_phrasenamed ^da.kfenttfier 

component_declarations component_declaration {component.declaration} 
component_declaration component {, component}: domain_reference {not null ]; 
component ::3 component.name [ dblength [ namedjphrase ] ] 
component_name ::=» ^da.identifier 


If present, Ad!fl_identifier_2 shall be equal to Ad£7_identifier_l. Adlfl_identifier_l is the name of 
the record. 

Let /? be a record declaration. Define AdaNAME(R) to be 


30 


1. The alias N, if the named.phrase named N appears in the declaration. 

2. Row, otherwise. 


Intermetrics, Inc. 






Chapter 4 - Data Description Language and Data Semantics 


Note: AdaNAME(R) is the default for the name of the row record formal parameter in the 
parameter profile of any procedure which uses the declaration R. See Sections 5.2, 5.5 and 5.9. 

Ada Semantics 

The Ada library unit package specification corresponding to the module within which the 
record_declaration R appears shall have an Ada record type declaration (called RAda) defined as 
follows: 

1. The name of the record type RAda shall be i4d<2_identifier_l. 

2. For some integer k, let the component_declarations of /? be given by the sequence 

componentSj ; Dj (not nullj ] 


for 1 < I <k, where componentsi is given by the sequence 
Cjj [dblengthjj [ named Njj]] 

where 1 ^ y ^ m/ for some integer m/. RAda shall be equivalent, in the sense of [Ada] 
sections 3.2.10 and 3.7.2, to a record type whose components are given by the sequence 

COMPi| [ DBIengij ] 

where i and j are bound as before and COMPjj is given by 

Cij : Ti ; 

where Ti is an Ada type name determined to be: 

a. The not null-bearing type name within the domain Dj, if either Dj is a not null 
only domain or not nulli is present in R; 

b. Otherwise the null-bearing type name within the domain Di. 

If the optional Jblengthij phrase is specified, then DBIengij appears and takes the form 
DBLngNAME^ : Ada_lndicator_Type; 

where DBLngNAMEij is Nij if Nij appears and is Cij_DbLength, otherwise; 
Ada_Indicator_Type is the type SQL_Standard.Indicator_Type (see [ESQL] 8.a,3). 

Examples: 

The following SAMeDL record declaration 

record Parts_Row_Record_Type named Parts_Row_Record Is 
Part_Number : Pno_Domain not null; 


Intermetrics, Inc. 


31 





SAMeDL Language Reference Manual 


Part_Name : Pname_Domain; 

Color : Color_Domain; 

WeightJn_Ounce : W 0 ight_Pomain; 

City : Crty_Dorr)ain: 

end Parts_Row_Record_Type: 


will produce the following Ada code: 

type Parts_Row_Record_Type Is record ~ Ada Semantics #1 
Part_Number : Pno_Domain_not_nuil: - Ada Semantics #2 
Part_Name : Pname_Domain_Type; 

Color : Color_Domain_Type: 

Weight : Weight_Domain_Type: 

City : City_Domain_Type: 

end record; 


4.1.6 Enumeration Declarations 

Enumerations are used to declare sets of enumeration literals for use in enumeration domains and 
status maps (see sections 4.1.3 and 4.1.8). 

enumeration_deciaration enumeration Adajdentifier_1 is (enumerationjiteraijist); 

enumerationjiteraijist::- enumerationjiteral {, enumerationjiteral} 


1. Ada_identifier_l is the name of the enumeration. 

2. Each identifier within an enumeration_literal_list is said to be an enumeration literal of the 
enumeration. The enumeration.declaration is considered to declare each of its 
enumeration_literals. An enumerationjiteral may appear in multiple enumeration 
declarations. 

Ada Semantics 

There shall be, within the Ada package specification corresponding to the module within which 
an enumeration appears, an Ada enumeration type declaration of the form 

type Ada_identifier_1 is ( enumerationjiteraijist ) ; 


Note: Ada character literals shall not be used in enumerations. 

Examples: 

The following are examples of SAMeDL enumeration declarations. 

enumeration Sizes is (small, medium, large, xjarge); 

enumeration Sex Is (M, F); 

enumeration Operation_Status is (Disk_Error, 

Data_Conversion_Error, lnvalid_SQL_Statement, Not_Found): 
enumeration Colors Is (Purple, Blue, Green, Yellow, Orange, Red. Black, White); 


32 


Intermetrics. Inc. 








Chapter 4 - Data Description Language and Data Semantics 


For the declarations above, the following Ada code would be produced: 

type Sizes Is (small, medium, large, xjarge); 

type Sex Is (M, F); 

type Operation_Status Is (Disk_Error, 

Data_Conversion_Error, lnvaljd_SQL_Statement, Not_Found): 
type Colors is (Purple, Blue, Green. Yellow, Orange, Red, Black, White); 


4.1.7 Exception Declarations 

exception_declaration exception ^a.identifier; 


Adajdentiner is the name of the exception. 

Ada Semantics 

There shall be, within the Ada package specification corresponding to the module within which 
an exception declaration appears, an exception declaration of the form 

>tc/a_identifier_1 : exception; 


Examples: 

The following are examples of exception declarations. 

exception Data_Deflnitlon_Does_Not_Exist; 
exception lnsuffjcient_Privilege; 


The above declarations produce the following Ada code: 

Data_Definition_Does_Not_Exist : exception; 
lnsufficient_Privllege ; exception; 


4.1.8 Status Map Declarations 

The execution of any procedure (see sections 3.7, 5.2, and 5.5) causes the execution of an SQL 
procedure. That execution causes a special parameter, called the SQLCODE parameter, to be set 
to a status code that either indicates that a call of the procedure completed successfully or that an 
exception condition occurred during execution of the procedure. Status maps are used within 
abstract modules to process the status data in a uniform way. Each map defines a partial function 
from the set of all possible SQLCODE values onto (1) enumeration literals of an enumeration 
and (2) raise statements. Note: The function is DBMS specific in that SQLCODE values are not 
specified by standard SQL, whereas the enumeration type and exceptions are not specific to any 
DBMS. 

status_map_declarationstatus 4da_ldentifier_1 

[named.phrase] 

[ uses target.enumeration ] 

Is (sqlcode_assignmem (, sqlcode.asslgnmem); 

target.enumeratlon enumeratlon.reference | boolean 


Intermetrics, Inc. 


33 






SAMeDL Language R^erence Manual 


sqlcode.assignmentstatic_expressionJist s> enumerationjiteral | 

static_expressionJist s> raise exception_reference 

static_expressionJist static_expression {, static_expression} | 

static.expression „ static_expression 

1. i4dfl_identificr_l is the name of the status map. 

2. A target enumeration of boolean is a reference to the predefined Ada enumeration type 
Standard.Boolean. 

3. If the optional uses clause is not present, then only sqlcode_assignments that contain raise 
shall be present in the status.map.declaration. 

4. Every Ada_enumeration_literal within an sqlcode_assignment shall be an 
Adlfl_enumeration_literal within the enumeration referenced by the target_enumeration. 

5. If E => L (or E => raise X) is an sqlcode_assignment then 

• DATACLASS(E) = Integer . 

• If E’ => L' (or E' => raise X') is any other sqlcode.assignment within the 
status_map_declaration, then E and E* shall not evaluate to the same integer. 

Note: An sqlcode.assignment takes the form of a list of alternatives as found in Ada case 
statements, aggregates, and representation clauses. The others choice is not valid for 
sqlcode.assignments, however. 

Note: SAMeDL.Standard contains the definition of a status map Standard.Map, defined as 
follows: 

status Standard_Map named ls_Found uses boolean Is 
(0 ■> True, 100 => False); 


Standard.Map is the status map for those fetch statements that appear in cursor declarations by 
default (see section S.S). It signals end of table by returning false. 

Examples: 


status Operation_Map named Result.Of.Operation 
uses Operation_Status is ( 


-600 .. -699 
-500 .. -599 
-300 .. -499 
-101,-110, -113 
-25 
100 


«> Di$k_Error, 

■> Data_Convorsion_Error, 

» lnvalid_SQL_Statement, 

»> raise Data_Deflnition_Does_Not_Exist, 
» raise lnsufficient_Privtlege, 

■> Not_Found); 


4.2 Schema Modules 

Schema modules contain the database description. 


34 


Intermetrics. Inc. 




Chapter 4 - Data Description Language and Data Semantics 


schema.module :> [ context ] 

[ extended ] 

schema module SC3L_identifier_1 Is 
{schema.element} 
end [ SOL_identifier_2]; 

schema_element :> table.definition | 

view_definition j 

SOL_piivilege_definition j 
extended_schema_eiement 

SQL_privilege_definition: > (see ^QLJ 6.10) 


1. If present, 5QL_identifier_2 shall be equal to SQL_identifier_l. 5QL_identifier_l is the 
name of the schema.module. 

2. 52L_identifieT_l shall be different from any other schema module name. 

3. An extended_schema_element may appear in a schema.module only if the keyword 
extended appears in the associated schema module declaration. 

42.1 Table Definitions 

Table definitions are analogous to SQL table declarations in that they provide information 
concerning the underlying stmcture of a database table within a schema. 

table.definitjon ;> [ extended ] table SOL_identifier_l Is 

table.element {, t£d3ie_element} 
end [ SQL_identifier_2 ]; 

table_eiement column_definition | 

table.constraintjdefinrtion j 
extended_table_element 

column_definition :> SOL_column_name [ SQL_data_type ] 

[ 5QlI_default_ciause ] 

[ column_constraint ]: domain_reference 

SOL_default_clause :> (see [SQL] 6.4) 

column_constraint not null SOL_unique_specification | 

SOL_reference_specificatjon | 

check (searchjcondition) 

SOL_unic|ue_specification :> (see [SQL] 6.6) 

SOL_reference_specificatk>n (see[SOU.]6.7) 

table_constraint_definition :> SQL_unique_constraint_definition | 

SQL_referentiaLconstraint_definition j 
check_constrairTt_definition 

SOL_unique_constraint_definition (see [SQL] 6.6) 

SOt._referentfaLconstraint_definition: (see[SQLJ6.7) 


Intermetrics, Inc. 


35 





SAMeDL Language Reference Manual 


check_constrairTt_definition check (search_condition) 


1. If present, S(2f'_i<lentifier_2 shall be equal to Sj2L_identifier_l. SQL_identifier_l is the 
name of the table and the table_definition. 

2. The name of the table_definition must be different from the name of any other 
table_definition or view_definition within the enclosing schema_module. 

3. A table_definition shall contain at least one column_definition. 

4. Every 5QL_column_name shall be distinct from every other 5QL_colunui_name within the 
enclosing table_definition. 

5. If the column_constraint is absent from a column_defmition, then the domain_reference 
shall not be to a not null only domain. 

6. For the semantics of not null, see [SQL], sections 6.3 and 6.6; for the semantics of check, 
see [SQL], sections 6.3 and 6.8. 

7. Suppose that column_definition CD is of the form 

CN [DT] (DC] (CCl : D; 

a. The domain of CD, denoted DOMAIN(CD), is D. If DT is present, then conversion 
between DBMS_TYPE(D) (see section 4.1.3) and DT shall be legal in both directions 
by the rules of SQL ([SQL], section 8.6, syntax rule 3; section 8.7, syntax rule 6; etc.) 
unless DBMS_TYPE^) is aaimplemenution defined dbms_tyF« (see section 4.1.1.3), 
in which case both conversions must be legal by the implementation defined rules. 

b. Define DATACLASS(CD) as DATACLASS(D). 

c. Define LENGTH(CD) as LENGTH(D) 

d. Define SCALE(CD) as SCALE(D). 

8. If extended appears in a table_definition then extended shall also appear in the associated 
schema_module declaration. 

9. If an extendcd_table_element appears in a table_definition, then the keyword extended 
shall appear in that table_definition. 

4.2,2 View Definitions 

view_definjtion :> (extended | view SOt.Jclentifier_1 as c|uery_spec 

[ with check option ] 
end [ SOLJdentifier_2 ]; 

query_spec query_specification | extended_query_speciricatk>n 


36 


Intermetrics, Inc. 





1. If present, S(2f'_identifier_2 shall be equal to SQL_identifier_l. SQL_identifier_l is the 
name of the view and the view_definition. 

2. The name of the view_definition shall be different from the name of any other 
table_definition or view_definition in the enclosing schema module. 

3. A query_spec may be an extended_query_specification only if the keyword extended 
appears in Ae associated view_definition. 

Examples: 

wtth Def_Mod; use Def_Mocl; 
schema module Parts_Suppliers_Database is 
-the Parts table 

table P Is -4.2.1: #1 and #2 

Pno not null : Part.Domain, -4.2.1: #3 and #4 
Pname : Pname.Domain, -4.2.1: #5 

Color : Color_Oomain, 

Weight : Weight_Domain, 

City : City_Domain, 

unique (Pno) 

end P; 

-the Suppliers table 

table S is -4.2.1: #1 and #2 

Sno not null : Sno.Domain, -4.2.1: #3 and #4 

Sname : Sname_Domain, -4.2.1: #5 

Sstatus : Sstatus.Oomain, -'Status’is a reserved word 

City : City_Domain, 

unique (Sno) 

end S; 


-the Orders table 

table SP is -4.2.1: #1 and #2 

Sno character(5) not null : Sno_Domain, -4.2.1: #3 and #4 

Pno character(6) not null : Pno.Domain, 

Qty integer : Quantity_Domain, -4.2.1: #5 

unique (Sno, Pno) 

end SP; 

-the Part_Number_City view 

view Pno_City as -4.2.2: #1 and #2 

select distinct Pno, City 
from SP, S 

where SP.Sno » S.Sno 
end Pno_Clty: 

end Parts_Suppliers_Database; 


Intermetrics. Inc. 


37 






SAMeDL Language Reference Manual 


4.3 Data Conversions 

The procedures that are described in an abstract module (see Chapter S) transmit data between an 
Ada application and a DBMS. Those data undergo a conversion during the execution of those 
procedures. Constants and enumeration literals u^ in statements are replaced by their database 
representation in the form of the statement in the concrete module. This process occurs at 
module compile time. Both processes are described in this section. 

Execution Time Conversions 

The execution time conversions check for and appropriately translate null values; for not null 
values, the conversion method identified by the appropriate base domain declaration (see section 
4.1.1.3). 

Input parameter conversion rule. If the type of an input parameter is null-bearing, then in the 
corresponding SQL procedure there is an associated SG^_parameter_specification to which an 
SQL_indicator_parameter has been assigned (see sections 5.6 and 5.8). If, for any execution of 
the procedure, the value of the input parameter is null, then the indicator parameter is assigned a 
negative value (see [SQL], subsection 4.10.2 and section 5.6, general rule 1). Otherwise, the 
indicator parameter shall be non-negative and the SQL parameter shall be set from the input 
parameter by the conversion process identified for the base domain. If the type of an input 
parameter is not null-bearing, the SQL parameter shall be set from the input parameter by the 
conversion process identified for the base domain (see section 4.1.1.3). 

Output parameter conversion rule. For output parameters of procedures containing either 
fetch or select statements, this process is run in reverse. Let SP be a select parameter. TTien the 
corresponding SQL procedure has a data parameter and an indicator parameter parameter 
corresponding to SP (see sections 5.2,5.5, and 5.7). For any execution of the procedure: 

• If the indicator parameter is negative, then 

~ If the type of the Ada record component COMPAda(SP) (see section 5.2 and 
5.5) is null-bearing, then COMPAda(SP) is set to the null value; ^Ise 

- If the type of COMPAda(SP) is not null-bearing, the exception 
SAMeDL_Standard.Null_Vtilue_Error is raised. 

• If the indicator parameter is non-negative, then the value of COMPAda(SP) is set fi'om 
the value of the SQL data parameter by the conversion process identified for the base 
domain (see section 4.1.1.3). If the record component DBLengAda(SP) is present (see 
section 5.2 and 5.4), then it is set to the value of the indicator parameter. 

Compile Time Conversions 

The SQL semantics of constants, domain parameters, and enumeration literals (and constants that 
evaluate to enumeration literals) used in value lists of insert statements (see section 5.8) and 
value expressions (see section 5.10) require that they be replaced in the generated SQL code by 
representations known to the DBMS. For enumeration literals, the enumeration mapping is used 
(see sections 4.1.1.1,4.1.1.3, and 4.1.3). 

Let V be an identifier. If V is not a reference to a constant or an enumeration literal, then V is 
not static and undergoes no compile time conversion. 


38 


Intermetrics, Inc. 



Chapter 4 - Data Description Language and Data Semantics 


IfV is a reference to 

• a constant declared by 

constant C [: D ] Is E; 

• a domain parameter parom of domain D, and D assigns the expression E to porom (see 
section 4.1.3) 

• or an enumeration literal El from enunreration domain D (see sections 5.3, 5.8, 5.10, 
and 5.11), and D assigns the expression E to V, 

then V is replaced by the static expression SQLve(E) (see section 5.10). 


Intermetrics, Inc. 


39 



Chapter 5 - Abstract Module Description Language 


Chapter 5 Abstract Module Description Language 

5.1 Abstract Modules 

abstract_module ;> [ context ] 

[ extended ] 

abstract module >tda_identifier_1 is 
authorization schema.reference 
{definition} 

{procedure_or_cursor} 
end [ A:lajdentifier_2 ]; 

procedure_or_cur5or :> cursor_declaration | procedure.dedaration 


1. If present, i4da_identifier_2 shall be equal to i4dfl_identifier_l. i4da_identifier_l is the 
name of the abstract module. 

2. No two of the items (that is, procedures, cursors, and definitions) declared within an 
abstract module shall have the same name. 

3. For the meaning of "authorization schema_reference", see [SQL]. 

4. A procedure_or_cursor may be an extended procedure or an extended cursor only if the 
keyword extended appears in the abstract module declaration. 

Ada Semantics 

For each abstract module within a compilation unit there is a corresponding Ada library unit 
package the name of which is the name of the abstract module, that is Ada_identifier_l. The 
Ada construct giving the Ada semantics of each procedure, cursor, or deHnition within an 
abstract module is included within the specification of that library unit package. 

SQL Semantics 

There is an SQL module associated with each abstract module that gives the SQL semantics of 
the abstract module. The name of the SQL module is implementation defined. The language 
clause of the SQL module shall specify Ada. The module authorization clause is implementation 
defined. 

5.2 Procedures 

This section discusses procedures which are not associated with a cursor. Cursor procedures are 
discussed in Section 5.5. 

For every procedure declared within an abstract module there is an Ada procedure declared 
within the library unit package specification corresponding to that abstraa module and an SQL 
procedure declared within the corresponding SQL module (see Section 5.1). A call to the Ada 
procedure results in the execution of the SQL procedure. 

procedure_declaration[ extended ] 

proc^ure 4da_identifier_1 
[input_param 0 terjist ] 


Intermetrics, Inc. 


41 




SAMeDL Language Reference Manual 


statement 
[ status.dause ] 


statement commit.statement 
delete.statement 
insert_statement_va(ues 
insert_statement_query 
roUback_statement 
select_statement 
update_statement 
extended statement 


1. i4d!a_identifier_l is the name of the procedure. 

2. An input_parameter_list may appear only in conjunction with statements which take input 
parameters or with extended statements. In particular, such lists may not appear in 
procedures containing a commit, rollback, or insert values statement 

3. A statement may be an extended.statement only if the keyword extended appears in the 
procedure declaration. 

Ada Semantics 

Each procedure declaration P shall be assigned an Ada procedure declaration PAda in a manner 

which satisfies the following constraints: 

• If P is declared within the declaration of an abstract module M, then PAda is declared 
directly within the library unit package specification M. 

• The simple name of PAda is the name of P. 

The parameter profile of the Ada procedure is defined as follows: 

1. If the statement within the procedure is either a delete, insert_statement_query, select or 
update statement, then let there be k input parameters (for some k > 0) in the input 
parameter list given by INPj, INP 2 , ..., INPk- Then the i*h parameter in the 
Ada_formal_part of PAda denoted PARMAda(iNPi) for i<=k, takes the following form 
(see Section 5.6); 

AdaNAME(iNPi): In AdaTYPE (INPj) 


2. If the statement within the procedure is a select_statement, then the (k+l)st parameter in 
the Ada formal part of PAda is a row record. The mode of the row record parameter 
shall be in out. 

Let IC be the into.clause appearing (possibly by assumption, see section 5.3) in the 
select.statement Then the name of the row record parameter is PARMrow(IC); the 
name of the type of that parameter is TYPErow(IC) (see Section 5.9). If IC contains 
the keyword new, then the declarative region containing the declaration of PAda shall 
also contain the declaration of TYPErow(IC). 


42 


Intermetrics, Inc. 





Chapter 5 - Abstract Module Description.Language 


The names, types and order of the components of the row record parameter are 
determined from the select.list within the select_statement Let that list be given by 
SPi, SP 2 ,SPm- (If the select_list takes the form then assume the transformation 
described in Section 5.7 has been applied). Then the row record type is equivalent in 
the sense of [Ada], section 3.2.10 and 3.7.2, to a record whose sequence of components 
is given by the sequence 

• COMPAda(SPi) [ DBIengAdalSPi) ] 


where COMPAda(SPi) is given by 
AdaNAME(SPi) : AdaTYPE{SPi) 

provided that AdaNAME(SPi) and AdaTYPE(SPi) are defined (see Section 5.7). The 
record component COMPAda(SPi) is otherwise undefined. The record component 
DBLengAda(SPi) is given-by 

DBLngNAME(SPi) : AdaJndicatorJType 


where Ada_Indicator_Type is the type SQL_Standard.Indicator_Type (see [ESQL] 
section 8.3.a), provided that DBLngNAME(SPi) is defined; otherwise this component 
is not present. 

Note: COMPAda(SPi) is undefined only if the i* select parameter is improperly 
written; whereas DBLengAda(SPi) is undefined only if the i* select parameter does not 
have a dblength phrase (see section 5.7). 

3. If the statement within the procedure is an insert_statement_values and it is not the 
case that the insert_value_list is present and consists solely of literals and constants, 
then the first parameter is a row record. The mode of the record parameter is in. 

Let IC be the insert_fTom_clause appearing (possibly by assumption, see section 5.3) 
in the statement. Then the name of the row record parameter is PARMrow(IC); the 
name of the type of that parameter is TYPErow(IC) (see Section 5.9). If IC contains 
the keyword new, then the declarative region containing the declaration of PAda shall 
also contain the declaration of TYPErow(IC). 

The names, types and order of the components of the record type are determined from 
the insert_column_list and insert_value_list. Let Ci, C 2 ..., Cm be the result of insert 
columns appearing in an inseit_column_list such that the corresponding element of the 
insert_value_list is not a literal or constant reference. Then the row record type is 
equivalent in the sense of [Ada], section 3.2.10 and 3.7.2, to the record whose ith record 
component COMPAda(Ci) for 1 ^ m, is given by 

AdaNAME(Ci): AdaTYPE(Ci) 


(see Section 5.8). 

4. If the statement within the procedure is an extended_statement, see section 3.7; for 
extended parameter lists, see section 5.6. 


Intermetrics, Inc. 


43 





SAMeDL Language R^erence Manual 


5. For all procedures, regardless of statement type, if a status.clause appears in the 
procedure declaration, then the final parameter is a status parameter of mode out. For 
the name and type of ^s parameter see Sections 4.1.8 and 5.13. 

SQL Semantics 

Each procedure declaration P shall be assigned an SQL procedure Psql within the SQL module 
for the abstract module in which the procedure appears. Psql has three parts: 

1. An S2L_procedure_name. This is implementation defined. 

2. A list of SQL_parameter_declarations. An SQLCODE parameter is declared for every 
SQL procedure. Other parameters depend on the type of the statement within the 
procedure P. 

a. If the statement is a delete, insert_statement_query, select or update statement, 
then the SQL parameters derived from the input_parameter_list of the 
procedure, as described in Section S.6, appear in the parameter declarations of 
Psql 

b. If the statement is an insert_statement_values, then the SQL parameters are 
determined by the subsequence of insert_column_specifications in the 
insert_column_list whose corresponding entry in the insert_value_list is a 
column_name (thus not a literal or constant reference). See Section 5.8. 

c. If the statement is a select.statemenL then the SQL parameter declarations for 
Psql arc determined by tiie selea_list of the select_statcment, as described in 
Section 5.7. 

d. If the statement is an extended.statement, see section 3.7. 

3. An SQL_SQL_Statcment (see’ [SQL], section 7.3). This is derived from the statement 
in the procedure declaration. See Section 5.3. 

Interface Semantics 

A call to the Ada procedure PAda shall have effects which can not be distinguished from the 
following. 

1. The procedure Psql is executed in an environment in which the values of parameters 
PARMsql(INP) and INDICsql(INP) (see Section 5.6) arc set from the value of 
PARMAda(INP) (see Ada Semantics above) according to the rule for input parameters 
of section 4.3. This holds for every input parameter tflP in the input_parameter_list of 
Ae procedure or for every column parameter INP in the insert_column_list of an 
inscrt_statement_values whose corresponding entry in the insert_column_list is an 
Sj2L_column_name (thus not a literal or constant_rcferencc). See Section 5.8. 

2. Standard post processing, as described in section 3.6, is performed. 

3. If the value of the SQLCODE parameter is zero or an implementation defrned value 
which permits the transmission of data (and which is handled by an 
sqlcode_assignment, see section 3.6), and the statement within the procedure is a 
select_statement, then the value of the component of the row record parameter 
COMPAda(SPi) and DBLcngAda(SPi) arc set from the values of the actual parameters 


44 


Intermetrics, Inc. 







Chapter 5 - Abstract Module Description Langu a ge 


associated with the SQL fomial parameters PARMsQL(SPi) and INDICsQL(SPi) (see 
Section 5.7), according to the rule for output parameters of section 4.3.. 

Examples: 

The following are examples of procedure declarations. The first is a declaration of a procedure 
with no input parameters. 

procedure Parts_Suppliers_Commit Is 
commit work; 


The above declaration produces the following Ada procedure declaration in the abstract 
interface. 

procedure Parts_Suppliers_Commit; 


The next procedure declaration contains an input parameter and a status clause. 

procedure Delete_Parts ( 

Input.Pname named Part_Name : Pname.Domain) 

Is 

delete from P 

where Pname > Input.Pname 

status Operation.Map named Delete.Status 


The above declaration produces the following Ada procedure specification in the abstract 
interface: 

procedure Deiete_Parts ( 

Part_Name : In Pname_Domain_Type; 

Delete_Status : out Operation.Status); 


In a somewhat more complex example, involving a row record, the following SAMeDL 
procedure 

procedure Insert.Rec^arts is 
insert imo P ( 

Pno named Part_Number, 

Pname named Part_Name, 

Color, 

City) 

from Red_Pafts 
values ( 

Pno, 

Pname, 

'Red*, 

City): 


Intermetrics, Inc. 


45 







SAMeDL Language Reference Manual 


produces the following Ada declarations: 

typo lnsert_Redparts_Row_Type -5.2, Ada semantics #3. 8.9 

Is record 

Part_Number : Pname_Domain_Type; -4.2.1 

Part_Name : Pname_Domain_Type: 

City : CHy_C)omain_Type; 

end record; 

procedure lnsert_Redparts (Red_Parts : In lnsert_Redparts_Row_Type): 


The color of all parts inserted using the Insert_Redparts procedure will be red. The weight of all 
such parts will be null. See the examples in section 4.2.2. The number, name and city of those 
parts are specified at run time. 

5.3 Statements 

This section describes the concrete syntax of statements other th?~ cursor oriented statements, 
and defines the text of the SQL statement derived from the text of a s AMeDL statement 

commit.statement ;;= commit work 

rollback_statement rollback work 

delete.statementdelete from table.name 

[ where search_condition ] 

insert_statement_query Insert Into table_name [ (SQtJnsert.columnJist) ] 

query.specificatton 

insett_statement_values Insert Into table_name [ (insert_columnJist) ] 

I insert_from_clause J values [ (insert_valuejist) ] 

update.statement update table_name 

set set_item {, set_item) 

[ where search_condjtion ] 

set_item column_reff;>ence s update_value 

update_value null | value_expression 

select_statement select [ distinct | all ] seiect_iist 

(into.dause ] 
from.dause 

[ where searchjcondition ] 

[ SQt_group_by_dause 1 
[ having search.condition ] 

SQZ.Jnsert_columnJist column_name {, column_name} 

SOL_group_by_clause group bycolumn_reference {, column_reference} 


In the following discussion, let ProcName be the name of the procedure in which the statement 
appears. 


46 


Intermetrics, Inc. 






Chapter 5 - Abstract Module Description Language 


Ada Semantics 

1. If no insert_firom_clausc appears within an inscrt_statement_values, then the following 
clause is assumed: 

from Row : new Pn>cA/am 0 _Row_Type 


If an insert_from_clause which does not contain a record_id appears in an 
insert_statement_values, the recorded 

: rtew P/ocWame_Row_Type 


is assumed. See Section 5.9. 

2. If no into_clause appears within a select_statement, then the following clause is 
assumed: 

Into Row : new PmcNameJRowJType 

If an into_clause which does not contain a record_id appears in a select.statement, the 
recorded 

; new ProcA/am 0 _Row_Type 


is assumed. See Section 5.9. 

3. The following rule applies to both forms of insert statements. If an insert_column_list 
is not present in such a statement, then a column list consisting of all colunuis defined 
for the table denoted by 5QL_table_name is assumed, in the order in which the colunuis 
were declared ([SQL] 8.7.3). 

Note: Use of the empty insert_coIumn_list is considered poor programming practice. 
The interpretation of the empty insert_column_list is subject to change with time, as the 
database design changes. - Ptograms which use an empty insert_coIumn_list may cease 
functioning where a program supplying an insert_column_list would continue to 
operate correctly. 

4. If the statement is an insert_statement_values, then 

a. If the insert_value_list is not present, then a list consisting of the sequence of 
column names in the insert_column_list is assumed. 

b. The insert_column_list and insert_values_list must conform, as described in 
Section 5.8. 

5. If the statement is an insert_statemeni_query, then let Ci, C 2 Cm be the columns 
appearing in an SQL_insert_column_list, and for each 1 < i ^ m, let Dj be 
DBMS_TYPE(Ci) (see section 4.2). The select_parameters in the select_list of the 
query_specification shall not specify a named_phrase or a not null phrase; that is, the 
select_list shall have the form VEi, VE 2 ,..., VEn, for value_expressions, VEi. Then 


Intermetrics, Inc. 


47 






SAMeDL Language Reference Manual _ _ 

• m = n, that is, the lists have the same length; and 

• For each 1 ^ i ^ n, VEi shall conform to Di (see section 3.5) and if 
DATACLASS(Di) is character, then LENGTH(VEi) shall not exceed 
LENGTH(Di). 

6. The following applies to update statements. Let 
C » V 


be a set .item within an update_statement Let D be DOMAIN(Q. Then 

a. If V is the null literal, then D shall not be defined as a non-null bearing domain. 

b. Otherwise, v is a value_expression. v shall conform to D (see section 3.5) and if 
DATACLASS(D) is character, LENGTH(v) shall not exceed LENGTH(D). 

SQL Semantics 

The text of an SQL statement corresponding to a SAMeDL statement within a procedure is 
described below. 

1. The SAMeDL and SQL commit and rollback statements are textually identical. 

2. The SAMeDL delete_statement is transformed into an SGL_delete_statement_searched 
by applying the transformatioi) SQLsc described in Section 5.11 to the search condition 
of the where clause, if present The remainder of the statement is unchanged. 

3. The SAMeDL insert_statement_query is transformed into an Sj2L_insert_statement by 

a. Applying the transformation SQLve defined in Section 5.10 to the 
value_expression in each select_parameter of the select_list in the 
query_specification. 

b. Removing any as keywords, if present, from the from_clause in the 
query_speciflcation. 

c. Applying the transformation SQLsc described in Section 5.11 to the 
search_conditions, if any, in the query_specification. 

The remainder of the statement is unchanged. 

4. The SAMeDL insert_statement_values is transformed into an SQL_insert_statement by 
transforming the insert_values_list and insert_colunui_list as described in Section 5.8, 
and dropping the insert_from_clause, if present The remainder of the statement is 
unchanged. 

5. The SAMeDL update.statement is transformed into an 
Sj2L_update_statement_searched by applying the transformation SQLve to the value 
expressions in the set_itcms of the statement and by applying the transformation SQLsc 
to the search condition, if present. The remainder of the statement is unchanged. 

6. The SAMeDL select_statement is transformed into an S(2L_select_statement by 


48 


Intermetrics, Inc. 





Chapter 5 - Abstract Module Description Language 


a. Replacing the select.list with the 5QL_select_list described in Section 5.7; 

b. Inserting an SQL into clause with a target list as specified in Section 5.7, and 
removing the into.clause in the statement, if any; 

c. Removing any as keywords, if present, from the from_clause. 

d. Applying the transformation SQLsc described in Section 5.11 to the search 
conditions, if any, in the where and having clauses. 

The remainder of the statement is unchanged. 

5.4 Cursor Declarations 

cursor.deciaration :> [ extended ] cursor Ad!ajdentifier_1 

[ input_parameterjist ] 
for 

query 

[ SOZ._ofder_by_clause ] 

[ is cursor_procedur8s 
end [ Ada_identifier_2 ]; ] 

query ;> quety_expression | extended_query_expression 

query_expression queryjerm | 

query_expression union [ aii ] queryjerm 

queryjerm ::= query_specification | 

(query.expression) 

query.specification seiect [ distinct | aii ] selectJist 

from_clause 

[ where searchjcondition ] 

[ SOL_grDup_by_clause ] 

I having search_condition ] 

SQL_order_by_clause :> order by SOt_sort_specification {, SQL_sort_specjfication} 

SO/._sort_specification :> UnsignedJntegerJiteral [ asc | desc ] | 

column_reterence [ asc | desc ] 

1. Ada_identifier_l is the name of the cursor. If present, Add_identifier_2 shall equal 
Ada_identifier_l 

2. No two procedures within a cursor_declaration shall have the same name. 

3. A query may be an extended_query_expression only if the keyword extended appears in 
the cursor declaration. If the keyword extended appears in the cursor declaration, then the 
keyword extended shall appear in the declaration of the module in which the cursor is 
declared. 

Ada Semantics 

If a cursor named C is declared within an abstract module named M, then there exists within the 
Ada package M (see Section 5.1) a subpackage named C. That subpackage shall contain the 


Intermetrics, Inc. 


49 





SAMeDL Language Reference Manual 


declarations of the procedures declared in the sequence cursor_procedures. {Note: Some of 
those procedures may appear by assumption. See Section 5.5). The text of the procedure 
declarations is describe in Section 5.5. 

If there is no union operator in the query_expression in the cursor_declaration, then the names, 
types, and order of the components of any record ty^e used as a row record formal parameter 
type in any fetch procedure for this cursor are determined from the select_list as specified for the 
select.statement in Sections 5.2 and 5.7. Otherwise, if union is present, the select.lists of all the 
query_expressions in the cursor_declaration shall have the same length. The name and type of 
the i* component of the record type is determined by the set of select_parameters in the i*** 
location of the select_lists. Let there be m such select_lists and let the set of select_parameters 
appearing in the i^ location of these lists be denoted by 

{SPii} = {VElj [ named Idi] ] [ not nullJi ] [ dbiengthii ] [ named dbldii ] } l^j^. 


Then 

1. These parameters have the same Ada type; that is, AdaTYPE(SPji) = AdaTYPE(SP*^i) 
for all pairs l^j, (see Section 5.7). The Ada type of the i* parameter, AdaTYPEj, 
is that type; in other words, AdaTYPEi = AdaTYPE(SPji) for any l^j^. {Note: This 
is equivalent to the restriction that DOMAIN(VEii) is the same domain, say DOMAINj, 
for all values of j (see Section 5.10) and that either (i) DOMAINi is a not null only 
domain, or (u).not null is specifred for either all or none of the parameters). 

2. For all pairs j, k such that a named_phrase appears in SPJi and SP^^i, Idij shall equal Id*^i. 
Then that name, AdaNAMEi, satisfies AdaNAMEi = Idii for any such j. If there are no 
such pairs (that is, if a named phrase appears in none of the select_parameters), then 
AdaNAME(VDi) shall equal AdaNAME(VE^i) for all pairs l^j, k^ and shall not 
^ual NO_NAME (see Section 5.10). Then AdaNAMEj = AdaNAME(VEji) for any 

3. For all pairs j, k such that a dblength phrase appears in SPii or SP^i, then a dbiength 
phrase shall appear in both SPii and SP*^i. Furthermore, DBLngNAME(SPji) shall equal 
DBLngNAME(SP^i). Then DBLngNAMEi shall be that name. If the dblength phrase 
appears in no SPJi for any j, then DBLngNAMEi is said to be null; otherwise, 
DBLngNAMEi is undefined. 

The type of the row record parameter is equivalent in the sense [Ada] 3.2.10 and 3.7.2, to a 
record type whose sequence of components is given by the sequence 

• • • COMPAda(SPi) I DBIengAda(SPi) ] 


where COMPAda(SPi) is given by 
AdaNAME{SPi) : AdaTYPE(SPi) 

provided that AdaNAME(SPi) and AdaTYPE(SPi) are defined (see Section 5.7). The record 
component COMPAda(SPj) is otherwise undefined. The record component DBLengAda(SPi) is 
given by 


50 


Intermetrics, Inc. 






Chapter 5 - Abstract Module Description Language 


OBLngNAME(SPi) : AdaJnclicator_Type 


where Ada_Indicator_Type is the type SQL_Standard.Indicator_Type (see [ESQL] section 
8.3.a), provided that DBLngNAME(SPi) is defined; otherwise this component is not present 

SQL Semantics 

A SAMeDL cursor_declaration is transformed into an SQL_cursor_declaration as follows. 

1. The string “declare” is prepended to the cursor declaration. 

2. The input_parameter_list and cursor_procedures are discarded, as is the keyword 
cursor and the is end bracket The cursor name Ada_identifier_l is transformed 
into SQLNAME(A<3tfl_identifier_l). 

3. The string “cursor” is inserted immediately after the transformed cursor name, but 
before the keyword for. 

4. The select_list is transformed into an SQL_se\ect_hst as described in Section 5.7. 

5. Any as keywords present are removed from the from.clause. 

6. The search conditions are transformed using the transform SQLsc of Section 5.11. 

The remainder of the declaration is unchanged. 

Examples: 

Shown below are two examples of cursor declarations: the first contains a simple cursor 
declaration, while the second contains a more complex declaration which exercises many of the 
features of the syntax. In both cases, the generated Ada code is shown. 

The example below is a simple SAMeDL cursor declaration. 

cursor Select.Suppliers 
for 

select Sno, Sname, Sstatus, City dblength 
from S 


This declaration produces the following Ada code: 

package Select_Suppliers is -5.4: Ada Semantics 

type RowJType Is record - 5.5, #5 and #8 

Sno : Sno_Domain_Type; -5.5, #3 and #8 

Sname : Sname_Domain_Type; 

Sstatus : Sstatus_Domain_Type; 

City : City_Domain_Type; 

City_Dblength : SQL_Standard.lndk;ator_Type: 
end record; 

procedure Open; -5.5, #3 


Intermetrics, Inc. 


51 







SAMeDL Language Reference Manual 


procedure Fetch ( 

Row : In out Row_Type; 
ls_Found ; out boolean); 

procedure Close; 

end Select_Suppliers; 


-5.5. #5 

-5.5, #8 and Ada Seniantics #3 
-5.5, #5 and Ada Semantics #6 

- 5.5, #4 


The following is an example of a more complex cursor declaration, 
cursor Supplier_Operations ( 

lnput_City named Supplier_Cjty : City_Domain not null; 

Adjustment named Status_Adjustment : Sstatus.Domain not null) 


for 

select Sno named Supplier_Number. 

Sname named Supplier_Name, 

Sstatus + Adjustment named Adjusted_Status, 
City named Suppiier_City 

from S 

where City = lnput_City 


is 

procedure Open_Supplier_Operations is 
open Supplier_Operation$; 

procedure Fetch_Supplier_Tuple is 
fetch Supplier_Operations 

Into &pplier_Row_Record : new Supplier_Row_Record_Type 
status My_Map named Fetch_Status; 

procedure Close_Supplier_Operations is 
close; - optional 'cursor name' omitted 

procedure Update_Supplier_Status ( 

lnput_Status named Updated_Status ; Sstatus.Domain not null; 
Input.Adjustment named Adjustment : Sstatus.Domain) 

Is 

update S 

set Sstatus => lnput_Status lnput_Adjustment 
where currem of Supplier_Operations; 

procedure Oelete_Supplier Is 
delete from S; 

- optional 'Where current of 'cursor name'” omitted 
end Supplier_Operations; 


This declaration produces the following Ada code. 

package Supplier_Operations Is 

type Supplier_Row_Recoid_Type is record 
Supplier_Number : Sno_Domain_Type; 
Supplier_Name : Sname_Domain_Type; 


“5.4, Ada Semantics 

-5.5, Ada Semantics #5 and #8 

-5.5, Ada Semantics #3 and #8 


52 


Intermetrics, Inc. 








Chapter 5 - Abstract Module Description Language 


Adjusted_Status : Sstatus_Domain_Type; 

Supplier_City : City_Domain_Type; 

end record; 

procedure Open_Supplier_Operations ( 

Supplier_Clty : In City_Dofnain_not_null: -5.5, Ada Semantics 

Status.Adjustment : in Sstatus_Domain_not_null); ~ #1, #3, Modes 

procedure Fetch_Supplier_Tuple ( 

Supplier_Row_Reoord : in out Supplier_Row_Record_Type: -5.5 

Fetch_Status : out Operation_Status); -5.5 

procedure Close_Supplier_Operations; 

procedure Update_Supplier_Status ( 

Updated_Status : in Sstatus_Domain_not_null; -5.5, Ada Semantics #2 

Adjustment : in Sstatus_Domain_Type): -5.5, Ada Semantics 

procedure Delete_Supplier; 

end Supplier_Operations; 


5.5 Cursor Procedures 

cursor_procedures cursor_procedure {cursor_procedure} 

cursorjsrocedure [ extended ] procedure Ada.kJentifier.l 

[ inputjaarameterjist ] ~ . ~ 

is 

cursor.statement 
[ status^clause ] 


cursor_statementopen_statement | 

fetch_statement | 

close_statement j 

cursor_update_statement j 

cursor_delete_statement j 

extended_cursor_statement 

open_statement open [ Ada.identifier J 

fetch_statement fetch (Adajdentifiert J (into_clause J 

close_statementclose [ Ada.identifier ] 

cur5or_update_statementupdate tab|e_name 

set set_item {, set_item ] 

[ where current of Ada_identifier ] 

cursor_delete_statement delete from table_name 

[ where current of Ada_identifier ] 


1. i4dd_identificr_l is the name of the procedure. 


Intermetrics, Inc. 


53 





SAMeDL Language Reference Manual 


2. An input_parameter_list may only appear in conjunction with statements that take input 
parameters. In particular, such lists may not appear in conjunction with open, close, fetch 
and cursor delete statements. Of the cursor procedures, only a cursor_update_statement 
may take an input_parameter_list. 

3. If no open_statement appears in a list of cursor_procedures, the declaration "procedure 
open is open;" is assumed. 

4. If no close.statement appears in a list of cursor_procedures, the declaration "procedure 
close is close;" is assumed. 

5. If no fetch.statement appears in a list of cursor.procedures, the declaration "procedure 
fetch is fetch status Standard.Map;" is assumed. See Section 4.1.8. 

6. If A da_ identifier is present in an open, fetch, close, cursor_update or 
cursor_delete_statement, then it must be equal to the name of the cursor within which the 
procedure declaration appears. The meaning of a ctirsor statement is not affected by the 
presence or absence of these identifiers. 

7. The restrictions which apply to the set_items of a non-cursor update.statement (see Section 
5.3), also apply to the set items of a cursor_update_statement 

8. If no into_clause appears within a fetch.statement, then the following clause is assumed: 

into Row ; new Row_Type 

If an into_clause which does not contain a recordjd appears in a fetch_statemeni, the 
recorded 

: new Row_Type 

is assumed. See Section 5.9. 

9. A cursor_statement may be an extended_cursor_statement only if the keyword extended 
appears in the cursor.procedure declaration. If the keyword extended appears in the 
cursor_procedure declaration, then the keyword extended shall appear within the 
declaration of the cursor in which'the cursor_procedure is declared. 

Ada Semantics 

Each procedure declaration P which appears in or is assumed to appear in a cursor_procedures 
list shall be assigned an Ada procedure declaration PAda which satisfies the following 
constraints. 

• If P is declared within the declaration of a cursor named C, then PAda shall be declared 
within the specification of an Ada subpackage named C. 

• The simple name of PAda is the name of P. 

The parameter profiles (Ada formal parts) of the Ada procedures depend in part on the statement 
within the procedure, as follows: 


54 


Intermetrics, Inc. 




Chapter 5 - Abstract Module Description Language 


1. For opcn_statements; Let INPi, INP 2 ,INI^ be the list of input parameters in 
the input_parameter_list of the cursor_declaration within which the procedure appears. 
Then PARMAda(INPO. the i*** parameter of the i4da_formal_part, is of the form 

AdaNAME(lNPi): in AdaTYPE(INPi) 

for l<i^k (see Section 5.6). 

2. For cursor_update_statements: Let INPi, INP 2 , .... INP^ k>0 be the list of input 
parameters in the input_parameter_list of the statement Then PARMAda(INPi). the ith 
parameter of the Adfl_formal_part, is of the form 

AdaNAME(lNPi); in AdaTYPE(INPi) 

for l^i^k (see Section 5.6). 

3. For fetch_statements: The first parameter is a row record parameter of mode in out. 
The names, order and types of the components of the type of this parameter are 
described in Sections 5.2 and 5.4. Let IC be the into_clause of the fetch_statemenL 
Then the name of the row record formal parameter is PARMrow(IQ> the name of 
the type of that parameter is TYPErow(IC). See Section 5.9. If IC contains the 
keyword new, then the declarative region containing the declaration of PAda shall 
contain the declaration of TYPErow(IQ- 

4. For close and cursor_delete_statements: There are no parameters to these procedures 
(except possibly for the status parameter, see below). 

5. For all statement types: if a status.clause referencing a status map that contains a uses 
appears in the procedure declaration, then the final parameter is a status parameter of 
mode out. For the name wd type of this parameter see Sections 4.1.8 and 5.13. 

SQL Semantics 

Each procedure P which appears in or is assumed to appear in a cursor_procedtires list shall be 
assigned an SQL procedure Psql within the SQL module for the abstract module within which 
the cursor_procedures list appears. Psql has three parts: 

1. An SQL_procedure_name. This is implementation defined. 

2. A list of SCL_parameter_declarations. An SQLCODE parameter is declared for every 
SQL procedure. Other parameters depend on the type of the statement within the 
procedure P. 

a. If the statement is an open_statement, then the SQL parameters derived from the 
input_parameter_list of the cursor.declaration as described in Section 5.6 
appear in the parameter declarations of Psql- 

b. If the statement is a cursor_update_statement, then the SQL parameters derived 
from the input_parameter_list of the cursor_update_statement as described in 
Section 5.6 appear in the parameter declarations of Psql- 


Intermetrics, Inc 


55 



SAMeDL Language Reference Manual 


c. If the statement is a fetch.statement, then the SQL parameters determined by 
the select_list of the cursor.declaradon as describe in Section 5.7 appear in the 
parameter declarations of Psql- 

The order of the parameters within the list is implementation defined. 

3. An Sj2L_SQL_statement. This is derived from the statement in the procedure 
declaration, as follows. 

a. If the statement is an open.statement, then the 5QL_open_statement is "open 
SQLname(C)". where C is the cursor name. 

b. If the statement is a close.statement, then the SQL close statement is "close 
SQLname(Q". where C is the cursor name. 

c. If the statement is the cursor_delete_statement 

delete from id [where current of C] 

then the 5j2L_delete_statement_positioned is identical, up to the addition of the 
where phrase: "where current of SQLname(C)", replacing the where phrase 
of the cursor_delete_statement, if present 

d. If the statement is the cursor_update_statement 

update id 
set setjtems 
[where current of C] 

then the SQL_updatc_statemcnt_positioncd is formed by applying the 
transformation SQLv^ defined in Section 5.10 to the value expressions in the 
set_items of the statement and appending or r^lacing the where phrase so as to 
read "where current of SQLname(Q"- 

e. If the statement is a fetch_statement, then the SQL_fetch_statement is "fetch 
SQLname(C) into targetJist" where C is the cursor name and target list is 
described in Section 5.7. 

Interface Semantics 

A call to the Ada procedure PAda shall have effects which can not be distinguished from the 
following. 

1. The procedure Psql is executed in an environment in which the values of parameters 
PARXIsql(INP) and INDICsql(INP) (see Section 5.6) arc set from the value of 
PARMAda(INP) (see Ada semantics above) for every input parameter, INP; in either the 
input_parametcr_list of the cursor_declaration, for open procedures, or the 
input_parameter_list of the procedure itself, for update procedures. 

2. Standard post processing, as described in section 3.6 is performed. 

3. If the value of the SQLCODE parameter is zero or an implementation defined value 
which perrnits the transmission of data (and which is handled by an 
sqIcode_assignment, see section 3.6)„ and the statement within the procedure is a 


56 


Intermetrics, Inc. 





Chapter 5 - Abstract Module Description Language 


fetch_statemcnt, then the value of the row record components COMPAda(SPi) and 
DBLengAda(SPi), are set from the values of the actual parameters associated with the 
SQL formal parameters PARMsqlCSPO and INDICsQL(SPi) (see Section 5.7). 

5.6 Input Parameter Lists 

Input parameter lists declare the input parameters of the procedure or cursor declaration in which 
they appear. The list consists of input parameter declarations which are separated with semi¬ 
colons, in the manner of Ada formal parameter declarations. 

Each parameter declaration of a procedure P is represented as an A£{a_parameter_specification 
within the Ada_formal_part of the procedure PAda*. each parameter declaration wit)^ a cursor 
declaration is represented as an A</a_parameter_specification within the Add_formal_part of the 
Ada open procedure. The parameter is also represented as either one or two 
•5(2L_parameter_declarations within the 5QL_procedure PsQL- The second SQL parameter 
declaration, if present, declares the indicator variable for the parameter ([SQL] 4.10^.2). 

The order of parameter specification within the Adfl_formal_part is given by the order within the 
input_parameter_list. The order of the 5GL_parameter_declarations within the list of 
declarations in the SQL procedure is implementation defined. 

inputjsarameterjist(parameter {; parameter}) 

input_parameteri4c/ajdentifier_1 [ named_phrase ]: 

[ In ] I out ] domain_reference [ not null ] 


Ada Semantics 

Let INP be a parameter the textual representation of which is given by 

jd_1 [named id_2] : [ In ] (out ] (id_3.] id_4 [not null] 

Then id_l is the name of the parameter. 

The domain associated with INP, denoted DOMAIN(INP), is the domain referenced by 
[id_3.]id_4. Let DOMAIN(INP) = D. Then 

• LENGTH(INP) = LENGTH(D) 

• SCALEONP) = SCALE(D) 

• DATACLASS(INP) = DATACLASS(D) 

The functions AdaNAME and AdaTYPE are defined on parameters as follows: 

1. If id_2 is present in the-definition of INP, then AdaNAME(INP) = id_2 otherwise, 
AdaNAME(INP) = id_l. For no two parameters, INPi and INP 2 , in an input parameter 
list shall AdaNAME(INPi) = AdaNAME(INP 2 ). 

2. AdaTYPE(INP) shall be the name of a type within the domain identified by the 
domain_reference [id_3.]id_4. If not null appears within the textual representation of 
INP, or the domain identified by the domain_reference does not null only, then 
AdaTYPE(INP) shall be the name of the not null-bearing type within the identified 


Intermetrics, Inc. 


57 





SAMeDL Language Reference Manual 


domain; otherwise it shall be the name of the null-bearing type within that domain (see 
Section 4.1.3). 

The optional out may occur only in a parameter that is associated with a procedure or cursor that 
is extended. The optional in, however, may be included in any parameter declaration. 

Given IMP as defined above, define MODE(INP) to be 

• in, if IMP either contains (1) the optional in, but not the optional out, or (2) neither in 
nor out. 

• out, if INP contains out but not in. 

• in out, if INP contains both in and out. 

Then the generated parameter, PARMAda(INP), in the v4d^_formal_part is of the form 
AdaNAMEONP): MODE(INP) AdaTYPE(INP); 

SQL Semantics 

Let INP be as given above and let D be the domain referenced by [id_3.]id_4.. The 
5!2L_parameter_declaration PARMsql(INP) is declared by the following 

: SQLNAME(id_l) DBMS_TYPE(D) 

where DBMS_TYPE(D) is as given in Section 4.1.3. If not null does not appear within the 
textual representation of INP, and [id_3.]id_4 does not identify a not null only domain, then the 
parameter INDICsql(INP) is defined and has a textual representation given by the 
5GL_parameter_declaration 

: INDICname(INP) indicator type 

where indicator type is the implementation defined type of indicator parameters ([SQL] 5.6.2). 
The name INDICname(INP) shall not appear as the name of any other parameter of the 
enclosing procedure. 

5.7 Select Parameter Lists 

Select parameter lists serve to inform the DBMS what data are to be retrieved by a select or fetch 
statement. They also specify the names and types of the components of a record type - the so 
called row record type - which appears as the type of a formal parameter of Ada procedure 
declarations for select and fetch statements. Further they specify the column names of viewed 
tables (see section 4.2.2). 

select_list ::= * | select_parameter {, select_parameter) 

select_parameter value_expressidn [ named_phrase ] [ not null ] 

[ dblength [ named^hrase ] ] 


1. The select list star ("*") is equivalent to a sequence of select parameters described as 
follows; Let Ti, T 2 ,..., Tk be the list of exposed table names in the table expression from 
clause for the query specification in which the select list appears (see [SQL] Section 5.25). 


58 


Intermetrics, Inc. 









Chapter 5 - Abstract Module Description Language 


Let Ui, for 1 < i < k be deHned as Si_Vi if Tj is of the form Si.Vi (i.e., Sj is a schema_name, 
and Vj is a table name); otherwise, Ui is Ti. In other words, Ui is Ti with every replaced 
by an underscore Let Ai,i, Ai^,. . . , Ai,iiii, be the names of the columns of the table 
named Ti. Then the select list is given by the sequence Ti.Aij named Ui_Ai,i, Ti.Ai^ 
named Ui_Ai 2 , Ti.Aij named Ui_Aij,..., Tk.Ak m named Uk_Ak,in That is, the 
columns are listed in the order in which they were denned (see Section 4.2) within the 
order in which the tables were named in the from clause. 

Note: This definition differs from that given in [SQL] Section 5.25 (4) in specifying that 

the column references are qualified by table name or correlation name. The record type 
being described must have well defined component names. 

Note: Use of as a select list in an abstract module is considered poor programming 

practice. The interpretation of is subject to change with time, as the database design 
changes. Programs which use a may cease functioning where a program using a nam^ 
select list would continue to operate correctly. 

In the following discussion, assume that a select list has been replaced by its equivalent 
list, as described above. 

2. If the keyword dblength is present, then value_expression shall have the data class 
character. 

3. Let VE be the value_expression appearing in a select_parameter. DOMAIN(VE) shall not 
be NO_DOMAIN and VE shall conform to DOMAIN(VE). 

Ada Semantics 

Let SP be a select parameter written as 

VE [named id_l] [not null] [ dblength [ named id_2 ] ] 

SP is assigned the Ada type name AdaTYPE(SP), the Ada name AdaNAME(SP) and the 
dblength name DBLngNAME(SP) as follows: 

• Let DOMAIN(VE) = D (see Sectio. 5.10) where D ^ NO_DOMAIN. If not null 
appears in SP or D is a not null only domain, then AdaTYPE(SP) is the name of the not 
null-bearing type name within the domain D; else AdaTYPE(SP) is the name of the 
null-bearing t^e within the domain D. 

• If DOMAIN(VE) = NO_DOMAIN then AdaTYPE(SP) is undefined. 

• If idj appears in SP, then AdaNAME(SP) = id 1; else AdaNAME(SP) = 
AdaNAME(VE) (see Section 5.10). 

• If the dblength phrase appears in SP, then 

- If id_2 is present then DBLngNAME(SP) = id_2 

- else, DBLngNAME(SP) = AdaNAME(SP)_DbUngth 
Otherwise. DBLngNAME(SP) is undefined. 


Intermetrics, Inc. 


59 






SAMeDL Laitfiuage R^erence Manual 


• DBLngNAME(SP) and AdaNAME(SP) shall not appear as either DBLngNAME(SPi) 
or as AdaNAME(SPi) for any other select_parameter SPj within the select_list that 
contains SP. 

SQL Semantics 

From a select_list, three SQL fragments must be derived: 

1. An SQL_select_list, within the select statement or cursor declaration 

2. A list of Sj2L_parameter_dcclarations. 

3. An SQL_target_list, within a select statement or fetch statement 
An SCL_select_list is derived from a select_list as follows: 

• The select_list * becomes the SQL_select_list *. 

• Otherwise, suppose SPi, SP 2 ,..SPn is a select_list where SPi is given by: 

VEi [ named idji ] [ not null ]i [ dblengthj [ named id_2/ ] ] 

The SQL_select_list SP'i, SP' 2 ,..SP'n is formed by setting SP’i to SQLvE(VEi). 

For the purpose of defining the SCL_parameter_declarations and target list generated from a 
select_list let SPi, SP 2 ,..SPn be the select_list supplied or the select_list that replaced the 
selectjist ♦ as described above. Let each SPi be be as given above. Then 

• There are two SQL parameters associated with each sclect_parameter, SPi. They are 
PARMsQL(SPi) and INDICsQL(SPi), where the SQL_parameter_declaration declaring 
PARMsQL(SPi) is 

: SQLNAME(SPi) DBMS_TYPE(DOMAIN(VEi)) 
and the 5C^L_parameter_declaration declaring INDICsQL(SPi) is 
: IND1 Csql(SP0 indicator type 

where SQLnameCSPO and INDICsqlCSPO are SQL identifiers not appearing else 
where. 

• The target list generated from a select.list is a comma-separated list of 
SQL_target_specifications ([SQL], section 5.6). The i*** SQL_target_specification in 
the SQL target list is 

SQLname (SPi) INDICATOR : INDICNAME(SPi) 

Note: All derived target specifications contain indicator parameters, irrespective of the 
presence or absence of a not null phrase in the select parameter declaration. 


60 


Intermetrics, Inc. 





Chapter 5 - Abstract Module Description Language 


5.8 Value Lists And Column Lists 

insert_column_list ::= insert_column_specification {, insert_column_specification } 

inser1_column_specification ::= column_name [ natned_phrase ] [ not null ] 

insert_value_list ::= insert_value {, insert_value} 

insert.value :;= null | 

constant_reference j 
literal j 

column_name j 

domain_parameter_reference 


Each column_name within a insert_coIumn_list shall specify the name of a column within the 
table into which insenions are to be made by the enclosing insert_statement_values. (See 
Section 5.3. See also [SQL], 8.7(3).) 

Let C be the insert_colunin_specification 

Col [named id] [not null] ■ 

Then AdaNAME(C) is defined to be id, if id is present; otherwise it is Col. Let DOMAIN(C) 
= DOMAIN(Col) = D be the domain assigned to the column named Col. If not null appears in 
C, or D is a not null only domain, then AdaTYPE(C) is the name of the not null-bearing type 
within the domain D; otherwise, AdaTYPE(C) is the null-bearing type within the domain D. 

Let CL be the insert_column_list Ci,..., Cm ; let IL be the insert_value_list Vi,..., Vn. CL and 
IL are said to conform if; 

1. m=n, that is, the length of the two lists is the same; 

2. For each 1^^, if Vi is 

a. The literal null, then DOMAIN(Ci) shall not be a not null only domain.. 

b. A literal or reference to either a constant or a domain parameter, then Vj shall 
conform to DOMAIN(Ci) (see section 3.5) and if DATACLASS(DOMAIN(Ci)) 
is character, then LENGTH(Vi) shall not exceed LENGTH(DOMAIN(Ci)). 

c. A column_name, then Vi shall be identical to the column_name in Ci. 


Ada Semantics 

The insert_column_list and insert_value_list of an insert_statement_values together define the 
components of an Ada record type declaration. The names, types and order of those components 
are defined in Section 5.2 on the basis of the functions AdaNAME and AdaTYPE described 
above. For the name of the record type and its place of declaration, see Section 5.9. 

Note: If the insert_values_list contains no column_names, then the Ada procedure 
corresponding to the procedure containing the insert_statement_values statement of which these 
lists form a part does not have a row record parameter. See Section 5.2. 


Intermetrics, Inc. 


61 



SAMeDL Language R^erence Manual 


SQL Semantics 

A set of SQL parameter declarations is defined from the pair of insert_column_list and 
insert_value_list. So again let Ci,Ck be the subsequence of the insert_column_list such that 
the insert_value_list item corresponding to each Q is a column_name (and therefore neither a 
literal nor a constant reference nor a domain parameter reference). Further, let Q be represented 
by the text string 

COLj I named kti ] [ not nulli ] 

Then the SQL parameter declarations PARMsql(Q) for l<i^ given by 
SQLNAME(Coli) DBMS_TYPE(DOMAIN(Coli)) 
appear in the list of SQL parameter declarations, where 

1. SQLname(Co 1|) is an implementation-defined SQL_identifier which appears nowhere 
else. 

2. DBMS_TYPE(DOMAIN(Coli)) is as defined in section 4.1.3. 

If not null does not appear in Ci and the domain DOMAIN(Coli) is not not null only, then the 
parameter INDICnameCQ) is defrned and the parameter declaration 

INDICNAME(Ci) irKlicatorjtype 

also appears in the list of SQL parameter declarations, where 

1. INDICname(Q) is an implementation-defined S^Z,^identifier that appears nowhere 
else. 

2. indicator type is the implementation-defined type of indicator parameters ([SQL] 
5.6.2). 

An insert_column_list and insert_value_list pair are transformed into an SQL_insert_column_list 
and Sj2L_insert_value list pair as follows: 

1. An insert_column_list is transformed into an S0L_insert_column_list by the removal of 
all named_phrase and not null phrases that appear in it 

Note: This implies that the empty insert_colunui_list is transformed into the empty 
S(2L_insert_column_list 

2. An insert_value_list is transformed into an SQL_insert_value list by replacing each list 
element as follows: 

a. a literal (including the literal null but excluding any enumeration literal) is 
replaced by itself; i.e., it is unchanged; 

b. a constant_reference, enumeration_literal, or domain_parameter_reference k is 
replaced by a textual representation of its database value SQLvE(k) (see Section 
5.10). 

c. a column_name Coli is replaced by 


62 ^ 


Intermetrics, Inc. 







Chapter 5 - Abstract Module Description Language 


SQLNAME{Coli) IINDICATOR : INDICNAME{Ci)l 

where the INDICATOR phrase appears whenever the indicator parameter, 
INDICsqlCQ), is defined (see above). 

enclosing the resulting list in parentheses and preceding it with the keyword values. 

5.9 Into_Clause And Insert_From_CIaiise 

An into_clause is used within a select_statement or a fetch_statement, and an insert_from_clause 
is used within an insert_statement_values, to explicitly name the row record parameter of those 
statements and/or the type of that parameter. 

into.dause Into 6 

insertJrom_clausefrom into_from_body 

into_from_body ;;= Ad!a_identifier_1 : record_id | 

Ada_identifier_1 j 

: record_icl 

record_id :> new Ada_identifier_2 | 
record reference 


Ada Semantics 

Define the string PARMrow(IQ as follows, where IC is an into_clause or insert_from_clause. 

1. If Ada_identifier_l appears in IC, then PARMrow(IC) = A(to_identifier_l. 

2. Otherwise, if the record_id takes the form of a record_reference referencing the record 
declaration R, then PARMrow(IC) = AdaNAME(R) (see Section 4.1.3). 

3. Otherwise, PARMrow(IQ = Row. 

Define TYPErow(IC) as follows: 

1. If record_id has the form "n e w Ada_identifier_2", then TYPErow(IC) = 
Acto_identifier_2. 

2. Otherwise, TYPErowGQ. is the record type referenced by the record_reference. 

Note: The assumptions made about into_clause and insert_from_clause in sections 5.3 and 5.5 
are sufficient to ensure that every such clause contains a record_id, possibly by assumption. 
Therefore, the case of a missing record_id need not be considered in the definition of 
TYPErow(IC) If the recordjd is a record_reference, then the names, types, and order of the 
components of the record type declaration that would have been generated had the record_id 
been "new Ada identifier" (see sections 5.2,5.4, and 5.7). 


Intermetrics, Inc. 


63 






SAMeDL Language Peference Manual 


Examples: 

The following is a set of examples which illustrate various uses of into and from clauses. It is 
assumed that each of these procedures is declared within an abstract module, and that any 
enumeration, record, and status map declarations used are visible at the point at which each 
procedure is declared. In addition, it is assumed that the abstract modules in which these 
procedures are declared have direct visibility to the contents of the Parts Supplier Database 
schema module shown in Section 4.2.2. 

The two examples below illustrate the use of a previously declared record object in the into 
clauses of select statements. I^ese examples illustrate a possible scenario where an SQL module 
contains two select statements for the-same object, namely a part The first select statement 
below exists in a cursor declaration because it has the potential to return more than one record. 
The second select statement exists in a procedure, because it can return at most one record from 
the table. Since both select statements retrieve the same type of object from the database, they 
may share a row record. The row record contains the definition of the part abstraction. To share 
a record object, declare the record first, and then reference it in the into clauses of both select 
statements. 

cursor Parts_By_City ( 

Input.City named Part_Location ; City_Domain not null) 
for 

select Pno named Part_Number not null, 

Pname named Part_Name, 

Color, 

Weight * 16 named WeightJn_CXjnces, 

City 

Into Parts_By_City_Row : Pafts_Row_Record_Type 

from P 

where City = lnput_City 


procedure Parts_By_Number ( 

lnput_Pno named Part_Number : Pno_Domain not null) 
Is 

select Pno named Part.Number not null, 

Pname named Part_Name, 

Color, 

Weight * 16 named WeightJn_Ounces, 

City 

Into Parts_By_Number_Row : Parts_Row_Record_Type 
from P 

where Pno = lnput_Pno 

status Operation_Map named Parts_By_Number_Status 


The above declarations produce the following Ada declarations in the abstract interface, 
package Parts_By_City Is 

procedure Open (Part_Location ; In City_Domain_not_null); 
procedure Fetch ( 

Parts_By_City_Row ; In out Parts_Row_Record_Type; 

ls_Found ; out boolean); 

procedure Close; 


64 


Intermetrics, Inc. 





Chapter 5 - Abstract Module Description Language 


end Parts_By_City: 


procedure Parts_By_Number ( 
Part_Number 
Parts_By_Number_Row 
Parts_By_Number_Status 


: In Pno_Domain_not_null; 

: In out Parts_Row_Record_Type; 
: out Operation_Status); 


The select procedure below illustrates the use of an into clause to specify the parametors, types, 
and names of the generated row record parameter. 

procedure Patt_Name_By_Number ( 

lnput_Pno named Paft_Number : Pno_Domaln not null) 

Is 

select Pname named Part.Name 

Into Part_Name_By_Number_Row : new Paft_Name_Row_Recorcl_Type 
from P 

where Pno = lnput_Pno 

status Operation_Map named Parts_By_Number_Status 


The above declaration produces the following Ada record type and procedure declarations at the 
in the abstract interface. 

type Pait_Name_Row_Record_Tvpe Is record 
Part_Name : Pname_Domain_Type: 
end record; 

procedure Part_Name_By_Number ( 

Part_Number : In Pno_Domain_not_null: 

Part_Name_By_Number_Row : In out Part_Name_Row_Record_Type: 
Parts_By_Number_Status : out Operation_Status); 


The example declaration below uses the default from clause, which produces a record 
declaration in the abstract interface. 

procedure Add_To_Suppljers Is 

Insert imo S (Sno, Sname, Sstatus, City) 
values 

status Opera'ion_Map named lnsert_Status 


The above procedure declaration produces the following Ada code in the abstract interface. 

type Add_To_Suppliers_Row_Type Is record 
Sno : Sno_Domain_Type; 

Sname : Sname_Domain_Type; 

Sstatus : Sstatus_Domain_Type; 

City : City_Domain_Type; 

end record; 

procedure Add_To_Suppliers ( 

Row : in Add_To_Suppliers_Row_Type; 


Intermetrics, Inc. 


65 







SAMeDL Language Rtfe r ence Manual 


lnsert_Status : out Operation_Status); 


This last example illustrates an insert values procedure declaration where all of the values are 
literals, meaning that no row record parameter is needed for the procedure declaration at the 
interface. 

procedure Acld_To_Parts is 

insert into P (Pno, Pname, Color, Weight, City) 

vaiues (’P02367, ’RIGHT FENDER: TOYOTA’, LT_RED, 25, ’PITTSBURGH’) 
status Operation_Map named Insert.Status 


The above declaration produces the following Ada procedure declaration in the abstract 
interface. 

procedure Add_To_Parts (lnsert_Status : out Operatton_Status); 


5.10 Value Expressions 

The concrete syntax of SAMeDL value expressions differs from the concrete syntax of SQL 
value expressions in the following ways: 

1. An operand of a SAMeDL value expression may be a reference to a constant, domain 
parameter, or enumeration literal defined cither in a detinitional module or in the 
enclosing abstract module. 

2. Value expressions arc strongly typed; therefore, a domain conversion operation must be 
introduced. 

value_expression ::= term | 

value_expression term j 
vaiue_expression - term 

term ::= factor | 

term * factor j 

term / factor 

factor ::= [ + 1*1 primary 

primary ::= literal | 

constant_reference j 

clomain_parameter_reference j 
column_reference j 

input_reference j 

set_function_specificafion j 
domain_conversion j 

(value_expression) 

set_function_specification ::= count (*) | 

distinct_set_function j 
all_set_function 

distinct_set_function ::= (avg | max | min | sum | coum ] (distinct column_reference) 


66 


Intermetrics, Inc. 








Chapter 5 - Abstract Module Description Language 


alLsetJunction ;> [ avg | max | min | sum ] ([ all ] value_expression) 
domainjcoiwersion do(nam_re1erence (value_expression) 


Five mappings are defined on value_expressions: AdaNAME, DOMAIN, DATACLASS, 
LENGTH, and SCALE. 

The mapping AdaNAME calculates the default names of row record components when value 
expressions appear in select parameter lists. The range of AdaNAME is augmented by the 
special value NO__NAME, the value of AdaNAME for literals and non-simple names. 

The mapping DOMAIN assigns a domain to each well-formed value expression. {Note: If 
DOMAIN is not defined on a value expression, then the value expression is not well-formed). 
The class of domains is augmented by the special value NO_DOMAIN, the domain of literals 
and universal constants. 

The mapping DATACLASS assigns a data class to each well-formed value expression. If the 
expression is a literal or universal constant (or composed solely of literals and universal 
constants), that is if DOMAIN(VE)= NO_DOMAIN, then the mapping returns the data class of 
the literal or universal constant (see section 2.4). 

The mapping LENGTH returns the number of characters in a character string. LENGTH returns 
the special value NO^LENGTH on operands whose data class is not character. 

The mapping SCALE returns the scale of the result of a numeric expression as determined by 
SQL. SCALE returns the special value NO_SCALE on operands whose data class is not 
numeric. ” 

The mappings AdaNAME, DOMAIN, DATACLASS, LENGTH and SCALE are defined 
recursively as follows: 

Base Cases: 

1. Literals. Let L be a literal. Then AdaNAME(L) = NO.NAME, DOMAIN(L) = 
NO_DOMAIN. DATACLASS(L), LENGTH(L), and SCALE(L) are as defined in 
Section 2.4. 

2. References. Let F be an input_reference, a constant_reference, a 
domain_parameter_reference, or a column_reference; let G be the object to which F 
makes reference. Then • 

• AdaNAME(F) = F if F is the simple name of G; otherwise, AdaNAME(F) = 
NO.NAME. 

• DOMAIN(F) = DOMAIN(G), 

• DATACLASS(F) = DATACLASS(G), 

• LENGTH(F) = LENGTH(G), and 

• SCALE(F) = SCALE(G). 


Intermetrics, Inc. 


67 











SAMeDL Language Reference Manual 


See sections 5.6,4.1.4,4.1.3, and 4.2.1. 

Recursive Cases: 

1. Set functions. Let SF be a set function and let VE be a value expression. 

- AdaNAME(SF(VE)) = NO_NAME. 

-- If SF is MIN or MAX, then 

- DOMAIN(SF(VE))=DOMAIN(VE), 

- DATACLASS(SF(VE)) = DATACLASS(VE) 

~ LENGTH(SF(VE)) = LENGTH(VE), 

- SCALE(SF(VE)) = SCALE(VE) 

- If SF is COUNT, then 

- DOMAIN(COUNT(VE)) = DOMAIN(COUNT(*)) = NO.DOMAIN 

- DATACLASS(COUNT(VE)) = DATACLASS(COUNT(*)) = Integer, 

- LENGTH(COUNT(VE)) = LENGTH(COUNT(*)) = NO_LENGTH 

- SCALE(COUNT(VE)) = SCALE(COUNT(*)) = 0 (see Section 2.4). 

- If SF is SUM, then 

- DOMAIN(SUM(VE)) = NO_DOMAIN 

~ DATACLASS(SUM(VE)) = DATACLASS(VE) and shall be a numeric 
data class 

~ LENGTH(SUM(VE)) = NO_LENGTH 

- SCALE(SUM(VE)) = SCALE(VE) 

- IfSFisAVG,then 

- DOMAIN(AVG(VE)) = NO_DOMAIN 
-- LENGTH(AVG(VE)) = NO.LENGTH 

- DATACLASS(VE) shall be numeric and DATACLASS(AVG(VE)) and 
SCALE(AVG(VE)) are implementation defined. 

2. Domain Conversions. Let D be a domain reference, VE a value expression. Then 

- AdaNAME(D(VE)) = NO_NAME. 

- DOMAIN(D(VE)) = D provided 


68 


Intermetrics, Inc. 







Chapter 5 - Abstract Module Description Language 


a. DATACLASS(D) and DATACLASS(VE) are both numeric. In this 
case SCALE(D(VE)) = SCALE(VE), and if SCALE(D) < SCALE(VE) 
then a warning message must be generated which will state, in effect, 
that the loss of scale implied by diis conversion will not occur in the 
query execution. The warning message need not be generated if the 
value expression is in an assignment context (see section 3.5). 
LENGTH(D(VE)) = NO_LENGTH in this case. 

b. DATACLASS(D) and DATACLASS(VE) are both character. In this 
case, LENGTH(D(VE)) = LENGTH(VE), and if LENGTH(D) < 
LENGTH(VE) then a warning message must be generated which will 
state, in effect, that the loss of length implied by this conversion will not 
occur in the query execution. The warning message need not be 
generated if the value expression is in an assignment context (see section 
3.5). SCALE(D(VE)) = NO.SCALE in this case. 

c. DATACLASS(D) and DATACLASS(VE) are both enumeration, 
provided that 

i. if DOMAIN(VE) * NO_DOMAIN. then DOMAIN(VE) = D; 

ii. if DOMAIN(VE) = NO.DOMAm, then the value of VE is an 
enumeration literal in the domain D {Note: Thus domain 
conversion may play the role played by type qualification in Ada, 
[Ada] 4.7). 

LENGTH(D(VE)) = NO.LENGTH and SCALE(D(VE)) = NO_SCALE 
in this case. 

- DATACLASS(D(VE)) = DATACLASS(VE). 

Note: These rules imply that the equalities 

- DATACLASS(DOMAIN(VE)) = DATACLASS(VE) 

- LENGTH(DOMAIN(VE)) = LENGTH(VE) 

- SCALE(DOMAIN(VE)) = SCALE(VE) 
do not necessarily hold. 

3. Arithmetic Operators. Let VEi, VE 2 be value expressions. Let 

DOMAINCVEi) = Di; 

D0MAIN(VE2) = D 2 ; 

DATACLASS(VEi) = Ti; 

DATACLASS(VE2) = T 2 ; 

SCALE(VEi) = Si; 

SCALE(VE 2 ) = S 2 ; 

Then Ti and T 2 shall be numeric classes and 

a. For unary operators (+, -) 


Intermetrics, Inc. 


69 







SAMeDL LannuaRe Reference Manual 


- AdaNAME(I+l-]VEi)=NO_NAME. 

~ LENGTH([+l-]VEi) = NO_LENGTH. 

- DOMAIN([+l-]VEi)=Di. 

- DATACLASS([+l-]VEi) = Ti. 

- SCALE([+l-]VEi) = Si. 

b. Let op be any binary arithmetic operator. Then AdaNAME(VEi op VE 2 ) = 
NO.NAME. LENGTH(VEi op VE 2 ) = NO.LENGTH. 

c. DATACLASS(VEi op VE 2 ) = max(Ti, T 2 ) where float > fixed > integer. 

d. Recall that the DOMAIN mapping is defined for a value expression just in case 
that value expression is legal. The value expression VEi op VE 2 is a legal 
value expression if: 

-- Di ^ NO_DOMAIN and D 2 * NO_DOMAIN and either 

> Ti = T 2 = fixed and op is either multiplication or division; or 

- Di = D2 

- or Di = NO_DpMAIN or D 2 = NO_DOMAIN, and 

- Ti = T 2 * integer, or else 

- Ti integer and then T 2 ^ integer, or else 

- T I = fixed and D 2 = NO_DOMAIN and op is either 
multiplication or division, or else 

- T 2 = fixed and Di = NO_DOMAIN and op is multiplication 
“ otherwise, VEi op VE 2 is not a legal value expression. 

e. if VEi op VE 2 is a legal value expression, then DOMAIN(VEi op VE 2 ) = 

-- NO_DOM AIN provided that either 

- Di = D 2 = NO_DOMAIN 

- or Di 9ft NO.DOMAIN and 02 NO_DOMAIN and Ti = T 2 = 
fixed and op is either multiplication or division. 

~ Di provided that Di ^ NO_DOMAIN 

- D 2 otherwise 

f. SCALE(VEi op VE 2 ) is given by 

" if op is an additive operator ([+!-]), then the larger of Si and S 2 


70 


Intermetrics, Inc. 





Chapter 5 - Abstract Module Description Language 


— if op is multiplication, then the sum of Si and S 2 

- if op is division, then it is implementation defined. 

Note: The following are consequences of the definitions above. 

— AdaNAME(VE) has a value other than NO_NAME only in the case where VE is a 
simple identifier. 

- The product and quotient of any two fixed quantities is always defined as a fixed 
quantity with no domain, much like the Ada <universal_fixed>. However, whereas in 
Ada no operations other than conversion are defined for such quantities, they may be 
used anywhere that a literal with fixed data class may be used. 

- The result of a COUNT set function is treated as though it were an integer literal (see 
[SQL] 5.8). 

" The result of a SUM set function on a value expression VE is treated as though it were 
a literal of the data class DATACLASS(VE) (see [SQL] 5.8). 

- The result of a AVG set function is treated as though it were a literal of an 
implementation defined data class and scale (see [SQL] 5.8). 

SQL Semantics 

The SQL value expression derived from a SAMeDL value e .pression VE is formed by removing 
all domain conversions, replacing all constants and domain parameters with their values and all 
enumeration literals with their database representations (see section 4.3). 

Let SQLve represent the function transforming SAMeDL value_expressions into 
SQL_value_expressions. Let VE be a SAMeDL value_expression. SQLve(VE) is given 
recursively as follows: 

1. If VE contains no operators, then 

a. If VE is a column reference or a database literal, then SQLve(VE) is VE. 

b. If VE is an enumeration literal of domain D, and D assigns expression E to that 
enumeration literal (see rule 12 of section 4.1.3), then SQLve(VE) = 
SQLve(H). 

c. If VE is a reference to the constant whose declaration is given by 

constant C [: 0 ] is E ; 
then SQLve(VE) = SQLve(E)- 

d. If VE is a reference to a domain parameter P of domain D, and D assigns 
expression E to P (see rule 6 of section 4.1.3), then SQLve(VE) = SQLve(E). 

e. If VE is a reference to the input parameter, INP, and PARMsql(INP) is C T" 
(for C an SQL identifier and T a data type, see section 5.6), then SQLve(VE) is 

:C [INDICATOR : INDICnameCNP) ] 


Intermetrics, Inc 


71 



SAMeDL Language R^erence Manual 


where INDICATOR INDICname(INP) appears precisely when 
INDICsql(INP) is defined. See Section 5.6. 

2. If VE is SF(VEl) where SF is a set function, then SQLve(SF(VEi)) is 
SF(SQLve(VEi)). 

3. If VE is D(VEi), where D is a domain name, then SQLveOD(VEi)) is SQLve(VEi). 

4. If VE is +VEi (or -VEi) then SQLve(VE) is +SQLve(VEi) (or -SQLve(VEi)). 

5. If VE is VEi op VE 2 where op is an arithmetic operator, then SQLve(VE) is 
SQLve(VEi) op SQLve(VE 2 ). 

6. If VE is (VEi) then SQLve(VE) is (SQLve(VEi)). 

Note: As a consequence of these definitions, particularly item 3, a domain conversion should be 
considered an instruction to a SAMeDL processor that a given expression is well-formed and 
should not be considered a data conversion. Although SAMeDL enforces a strict typing 
discipline, data conversions are carried out under the rules of SQL, not those of Ada. It is for this 
reason that warning messages are given for conversions which lose scale. 

5.11 Search Conditions 

search_condition booleanjerm | seaFCh_condition or boolean_term 

booleanjerm :> booleanjactor | booleanjerm and booleanjactor 

booieanjactor ( not ] booleanj3rimary 

boolean_primary ;> predicate | (search_condition) 

predicate comparison_predicate | 

betweenjjredicate j 

injpredicate | 

like_predicate . j 

nulijsredicate j 

quantifiedjpredicate j 

existsjaredicate 


The concrete syntax of search conditions differs firom that of SQL only in that SAMeDL value 
expression (Section 5.10) replaces SQL value expression in the definition of the atomic 
pr^icates [SQL] 5.11 through 5.17. In addition, the SAMeDL enforces a strict typing discipline 
on the atomic pr^icates, not enforced by SQL. 

For convenience, the following subsections present the syntax for each of the search predicates. 
Semantics are defined below in conjunction with [SQL]. 

The atomic predicates of SQL take a varying number of operands; the comparison predicate 
takes two, the between predicate takes three, and the in predicate takes any number. So let {OPi, 
OP 2 ,.... OPm ) be the set of operands of any atomic predicate. Each of the OPi is of the form of a 
value expression. Therefore, the functions DOMAIN and DATACLASS may be applied to them 
(Section 5.10). For an atomic predicate to be well formed, then for any pair of distinct i and j, 
1 ^, 


72 


Intermetrics, Inc. 







Chapter 5 - Abstract Module Description Lanauane 


1. If DOMAIN(OPi) * NO.DOMAIN and DOMAIN(OPj) * NO_DOMAIN, then 
DOMAIN(OPi) = DOMAIN(OPj), and 

2. Exactly one of the following holds: 

a. DATACLASS(OPi) = DATACLASS(OPj) = integer; 

b. DATACLASS(OPi) = DATACLASS(OPj) = character; 

c. Both DATACLASS(OPi) and DATACLASS(OPj) are elements of the set 
{fixed, float) 

d. DATACLASS(OPi) = DATACLASS(OPj) = enumeration, and there exists 
some k, l<k^ such that 

i. DOMAIN(OPk) NO_DOMAIN, and 

ii. For all 1,1^1^, either 

1. DOMAIN(OP0 = NO_DOMAIN, and OPi is an enumeration 
literal of the domain DOMAIN(OPic), or 

2. DOMAIN(OPi) = DOMAIN(OPk). 


SQL Semantics 

A S AMeDL search condition is transformed into an SCL_search_condition by application of the 
transformation SQLsc which operates by executing the transformation SQLvE. defined in 
Section 5.10, to the value expressions appearing within the search condition and the 
transformation SQLsq, defined in Section 5.12, to the subqueries in the search condition. In 
other words, let P, Pi, and P 2 be search conditions, VE, VEi, VE 2 ,be value expressions, 
and SQ be a subquery. Then SQLsc(P) is given by 

1. If P is of the form: Pi op P 2 , where op is one of "and" or "or", then SQLsc(P) is 
SQLsc(Pl)opSQLsc(P 2 )([SQL] 5.18). 

2. If P is of the form: "not Pi", then SQLsc(P) is not SQLscfPl) ([SQL] 5.18). 

3. If P is of the form: "VEi op VE 2 ", where op is an SQL comparison operator ([SQL] 
5.11), then SQLsc(P) = SQLve(VEi) op SQLve(VE 2 ). If P = VE op SQ, then 
SQLsc(P) = SQLve(VE) op SQLsq(SQ) ([SQL] 5.11). 

4. If P is of the form: "VE [not] between VEi and VE 2 " then SQLsc(P) = SQLve(VE) 
[not] between SQLve(VEi) and SQLve(VE 2 ) ([SQL] 5.12). 

5. If P is of the form: "VE [not] in SQ", then SQLsc(P) = SQLve(VE) [not] in 
SQLsq(SQ). If P is of the form: "VE [not] in (VEi, VE 2 ,..., VEj,...)" then SQLsc(P) 
= SQLve(VE) [not] in (SQLve(VEi), SQL^^(VE 2 ),..., SQLvE(VEi),...) 

6. If P is of the form: "VEi [not] like VE 2 escape c" where c is a character, then 
SQLsc(P) = SQLve(VEI') [not] like SQLve(VE 2 ) escape c ([SQL] 5.14). 


Intermetrics, Inc. 


73 










SAMeDL Language Reference Manual 


7. If P is of the form: "C is [not] null” where C is a column reference, then SQLsc(P) .= 
C is [not] null ([SQL] 5.15). Note: SQLsc is the identity mapping on 
SQL_null_predicates. 

8. If P is of the form: "VE op quant SQ" where op is an 5QL_comp_op, quant is an 
5j2L_qualifier (i.e., one of SOME, ANY or ALL), then SQLsc(P) = SQLve(VE) op 
quant SQLsq(S(3) ([SQL] 5.16). 

9. If P is of the form: "exists SQ", then SQLsc(P) = exists SQLsq(S(3) ([SQL] 5.17). 
5.11.1 Comparison Predicate 

comparisonjpredicate ::= value_expression comp_op vaLor_subquery 
val_or_subquery ;;= value_expression | subquery 
comp_op ::= = I <> I < I > I <= I >s 

5.1U Between Predicate 

between_predicate value_expression [ not ] between value_expression and value_expression 
5.113 In Predicate 

in_predicate ::= vaiue.expression [ not ] in subquery_or_value_specJist 

subquery_or_value_specJist :;= subquery | (value_specjist) 

value_specjist ::* value_spec {, value_spec) 

value_spec ::= inpirt_reference | 

static_expression | 

user 

5.11.4 Like Predicate 

like_predicate eolumn_reference [ not ] like pattem_string [ escape_clause ] 
pattem_string ::= value.spec 
escape_clauseescape value_spec 

5.113 Null Predicate 

null_predicate ::= column_reference Is [ not ] null 
5.11.6 Quantified Predicate 

quantified_predicate :> value_expression comp_op quantifier subquery 
quantifier ;:= all | some | any 


74 


Intermetrics, Inc. 







Chapter 5 - Abstract Mo.dule Description Language 


5.11.7 Exists Predicate 

exists_predicate exists subquery 


5.12 Subqueries 

The concrete syntax of a subquery ([SQL] 5.24) differs from that of query specifications in that 
the select list is limited to at most one parameter. Further, that parameter, when present, takes the 
form of a value expression (Section 5.10), not that of a select parameter (Section 5.7), as it is not 
visible to the user of the abstract module. 

subquery :> (select [ distinct | all ] result_expression 
from_clause 

[ where search_condition ] 

(SQZ.jgroup_by_clause ] 

[ having search_condition ]} 

result_expressionvalue_expression | * 

Ada Semantics 

If, within a subquery, SQ, the result_expression takes the form of a value_expression, VE, then 
D0MAIN(SCD - DOMAIN(VE) and DATACLASS(S(3) = DATACLASS(VE). DOMAIN(SQ) 
and DATACLASS(SQ) are undefined when the result_expression takes the form of *. 

Note: The fact that DOMAIN(*) is undefined means that such a result_expression can be used 
only if the subquery appears within an exists_predicate. 

SQL Semantics 

The SQL_subquery formed from a SAMeDL subquery, SQ, denoted SQLsq(SQ), is produced by 
removing any as keywords, if present, from the from_clause and applying the transformation 
SQLsc to the search_conditions in the where and having clauses, if present. 

5.13 Status Clauses 

A status clause serves to attach a status map to a procedure and optionally rename the status 
parameter. 

status_dause status status_reference [ namedjshrase ] 

Ada Semantics 

If a procedure P has a status_clause of the form 
status M [named Id_l] 

and the definition of M was given by (see Section 4.1.5): 

enumeration T is (Li,..., Ln); 

status M [named ld_2] 
uses T 


Intermetrics, Inc. 


75 









SAMeDL Language R^erence Manual 


is (..., n=>L,...); 

(see section 4.1.8), then: 

1. The procedure PAda (Sections 5.3 and 5.5) shall have a status parameter of type T. 

2. The name of the status parameter of PAda is determined by: 

a. If id_l is present in the status_clause, than the name of the status parameter 
shall be id_L 

b. If rule(a) does not apply, then if id_2 is present in the definition of the status 
map M, the name of the status parameter shall be id_2 (see section 4.1.8). 

c. If neither rule (a) nor rule (b) apply, then the name of the status parameter shall 
be Status. 


76 


Intermetrics, Inc. 





Appendix A - SAMeDL Standard 


Appendix A SAMeDL_Standard 

The predefined SAMeDL definitional module SAMeDL_Standard provides a common location 
for declarations that are standard for all implementations of the SAMeDL. This definitional 
module includes the SAMeDL declarations for the status map Standard_Map and for the 
standard base domains. 

definition module SAMeDL_Standard is 

exception SQL_Database_Error; 
exception Null_Value_EiTor; 

- standard status map 

status Standard_Map named ls_Found uses boolean is 
(0 => True, 100 => False); 

-- SQLJnt is based on the Ada type SQL_Standard.lnt 
base domain SQL_lnt 
(first : integer: 
last : integer) 
is 

domain pattern is 

type (selfL.Not_Null is new SQLJnt_Not_Null* 

'{range [first].. [last]};’ 
type [self]_Type is new SQLJnt:’ 

'package [self]_Ops is new SQLJnt_C)ps (’ 

'[selfLType. [seHLNot.Null):’ . 
end pattern; 

derived domain pattern is 

type [self]_Not_Null is new [parentLNot_Nuir 
’{range [first].. [last]);’ 
type [selfLType is new [parentLType;' 

'package (self]_Ops is new SQLJnt_Ops (’ 

’[selfLType. [selfLNot_Null);' 
end pattern; 

subdomain pattern is 

'subtype [selfLNot_Null is [parentLNot_Nuir 
'{range [first].. [last]);' 
type [selfLType is new [parentLType;’ 

'package [selfLOps is new SQLJnt_Ops (’ 

’[selfLType, [selfLNot_Null):' 
end pattern; 

for not null type name use '[seHLNoLNuH’; 
for null type name use '[sel4_Type’: 
for data class use integer; 
for dbms type use integer; 
for conversion from dbms to not null use type mark; 
for conversion from not null to null use function 
’[selfL9PsWith_Nuir; 

for conversion from null to not null use function 
’[selfLOps.Without_Null'; 

for conversion from not null to dbms use type mark- 


IntermeP’ics, Inc. 


77 





SAMeDL Language Reference Manual 


for context clause use 'with sqljntjpkg; use sqljnt_pkg;'; 
for nulLbearing assign use ‘[seif]_ops.assign'; 
for not.nulLbearing assign use predefined; 
for nuil_vafue use 'nuiLsqiJnt'; 

end SQLJnt; 

~ SQL.Smallint is based on the Ada type SQL_Standard.Smaliint 
base domain SQL.Smallint 
(first : integer; 
last : integer) 
is 

domain pattern is 

type [seHLNot.Nuil is new SQL_Smallint_Not_Nuir 
'{range [first].. [iast] },*' 
type [sei^Type is new SQL_Smaliint;' 

'package [seHLOps is new SQL_Smallint_Ops (' 
IselfLType, [sellLNot_Nuii);' 
end pattern; 

derived domain pattern is 

type [seifl_Not_Nuil is new [parentLNot_Nuir 
'{range [first].. [last]};' 
type [selfLType is new [paren^Type;* 

'pack^ [seifLOps is new SQL_Smallint_Ops (' 
'[seifLType. [sellLNot_Null);' 
end pattern; 

subdomain pattern is 

'subtype [selfLNot Null is b>arentLNot Nuir 
•{ range [first].. [last]};' 
type [seiq_Type is new [^rentLType;* 

'package [seHLOps is new SCa._Smailint_Ops (’ 
•[seHLType, [seHL]Not_Null);' 
end pattern; 

for not null type name use IseHLNot.NulT; 
for null type name use '[sel^Type'; ~ 
for data class use integer; 
for dbms type use integer; 
for conversion from dbms to not null use type mark; 
for conversion from not null to null use function 
'[selfL9ps.With_Null'; 

for conversion from null to not nun use function 
'[selfL9ps.Without_Nuir; 

for conversion from not null to dbms use type mark; 
tor context clause use 

•with sql_smallint_pkg; use sql_smallint_pkg;'; 
for nulLbearing assign use '[seHLops.assign’; 
for not_nulLbearing assign use predefined; 
for nulLvalue use 'null_sqLsmallint'; 

end SQL.Smallint; 

- SQL_Real is based on the Ada type SQL.Standard.Real 
base domain SQL_Real 
(first ; float; 


78 


Intermetrics, Inc. 








Appendix A - SAM^L Standard 


last : float) 
is 

domain pattern is 

type [sein_Not_Null is new SQL_ReaLNot_Nuir 
'{range [first].. [last] 
type [seiq_Type is new SQL_Reai:' 

'package [seifLops is new SQL_Real_Ops (' 

'[selfLType, [seifLNot_Null):’ 
end pattern; 

derived domain pattern is 

lype [selfLNot_Nuil is new ft>arentLNot_Nuir 
'{range [first].. [iast] 
type [selfLType is new [parentLType;* 

'package [selfLOps is new SQL_ReaLOps (' 

'[selfLType, [selfLNot_Null):' 
end pattern; 

sutxlomain pattern is 

'subtype [selfLNot_Null is [parentLNot_Null' 

'{range [first].. [iast] };* 
type [selfLType is new [parentLType;' 

'package [selfLOps is new SQL_ReaLOps (' 

'[seKLType, [seifLNot_Null);* 
end pattern; 

for not nuil type name use '[seifLNot_Nuir; 
for null type name use '[sel^Type'; 
for data class use float; 
for dbms type use real; 

for conversion from dbms to not mjll use type mark; 
for conversion from not null to nuil use function 
lselfLOps.With_Nuir; 

for conversion from null to not nuil use function 
'[selfLOps. Wrttwut.Nuir; 

for conversion from not null to dbms use type mark; 

for context clause use 

'with sqLrealjakg; use sqLreal_pkg;'; 
for null_bearing assign use '[seifLops.assign'; 
for not_nuil_bearing assign use predefined; 
for null_vaiue use 'nuil_sqLreal'; 

end SQL_Reai; 

~ SQL_Double_Precision is based on the Ada type SQL_Standard.Double_Precision 
base domain SQL_Doubie_Precision 
(first ; float; 
last : float) 
is 

domain pattern is 

type [selfLNot_Null is new SQL_Double_Precision_Not_NuiP 
'{range [first].. [last]};' 

type [selfLType is new SQL_Double_Precision;' 

'package [selfLOps is new SQL_Double_Precision_Ops (' 


Intermetrics, Inc. 


79 










SAMeDL Language Reference Manual 


IselfLType, [selfLNot_Null);' 
end pattern; 

derived donrain pattern is 

type Iself|_Not_Null is new [parentLNot_Nuir 
'{range [first].. [last] 
type [sel^Type is new [parentLType;' 

'(^ckage [seffLOps is new SQL_Double_Precision_Ops (' 
'[seilLType, [self]_Not_Null):‘ 
end pattern; 

subdoniain pattern is 

'subtype [self]_Not_Null is [parentLNot_Nuir 
’{range [first].. [last] 
type [sel^Type is new [parentLType;' 

'(^ckage [selfLOps is new SQL_0<^ble_Predsion_Ops (' 
'[selfLType. [se!fLNot_Null);' 
end pattern; 

for not null type name use '[selfLNot_Nuir; 
for null type name use '[sel^Type'; 
for data class use float; 
for dbms type use double precision; 
for conversion from dbms to not null use type mark; 
for conversion from not null to null use function 
'[selfL9ps.With_Null'; 

for conversion from null to not null use function 
'[selfLOps.Wlthout_Nuir; 

for conversion from not rtull to dbms use type mark; 
for context clause use 

'with sqLdoubie_precision_pkg; use sqLdouble_precisionj)kg;'; 
for nulLbearing assign use '[selfLops.assign'; 
for not_null_bearing assign use predefined; 
for nulLvalue use 'null_sql_doublej3recision'; 

end SQL_Double_Precision; 

-- SQL_Char is based on the Ada type SQL_Standard.Char 
base domain SQL_Char 
is 

domain pattern is 

type [self]NN_Base is new SQL_Char_Not_Null;' 

'subt)^ [selfLNot_Null is [self]NN_Base (1.. [length]);' 
type [sel^Base is new SQL_Char;' 

'subtype [selfLType is [selfLBase {' 

'[selfL.NoLNuiriength);' 

'package [selfLOps is new SQL_Char_Ops {' 

IselfLBase, [self]NN_Base);' 
end pattern; 

derived domain pattern is 

type [self]NN_Base is new [parent]NN_Base;' 


80 


Intermetrics, Inc. 





Appendix A - SAMeDL ^Standard 


i. 


'subtype [sein_Not_Null is [self]NN_Base (1.. [length]);' 
type [self]_Base is new [parent]_Base;' 

'subtype [selfLType is [seifl_Base (' 

1self]_Not_Nuinength);' 

'package [selfLOps is new SQL_Char_Ops {’ 

IselfLBase, [self]NN_Base):' 
end pattern; 

subdomain pattern is 

'subtype [seH]NN_Base is [parent]NN_Base;' 

'subtype [selfLNoLNull is [parent]NN_Base (1 .. [length]);' 
type [self]_Base is new [parentLBase;' 

'subtype [selfLType is [selfLBase (' 

'[selfl_Not_Nuiriength);' 

'package [selfLOps is new SQL_Char_Ops (' 

IselfLBase, [self]NN_Base);' 
end pattern; 

for not null type name use '[selfLNot_Nuir; 
for null type name use '[selfLType'; 
for data class use character; 
for dbms type use character '([length])'; 
for conversion from dbms to not ruiil use type mark; 
for conversion from not null to null use function 
'[selfLOps. With_Nuir;. 

for conversion from null to not null use function 
'[selfL9PsWrthout_Null'; 

for conversion from not null to dbms use type mark; 

for context clause use 'with sql_char_pkg; use sql_char_pkg;'; 
for nulLbearing assign use predefined; 
for null value use 'nulLsqLchar*; 

end SQL_Char; 

- SQL_Enumeratlon_AsJnt is based on the Ada type SQL_Standard.lnt 
base domain SQL_Enumeration_AsJnt 
(map pos) 
is 

domain pattern is 

type [selfLNot_Null is new [enumeration];' 

'package [selfLPkg is new SQL_Enumeration_Pkg (' 
'[selfLnot_null)' 

type [selfLType is new [selfLPkg.SQL_Enumeration;' 
end pattern; 

derived domain pattern is 

type [selfLNot_Null is new [parentLNot_Null;' 
type [selfLType is new [parentLType;' 
end pattern; 

subdomain pattern is 

'subtype [selfLNot_NuII is [parentLNot_Null;' 

'subtype [selfLType is [parentLType;' 
end pattern; 

for not null type name use '[selfLNoLNull'; 


Intermetrics, Inc. 


81 







SAMeDL Languafie R^erence Manual 


for null type name use *[selfLType'; 
for data class use enumeration; 
for dbms type use integer; 
for conversion from not null to null use function 
'With_Nuir; 

for conversion from null to not null use function 
'Wlthout_Nuir; 

for context clause use Vrith sqLenumeration_pkg;'; 
for not_nulLbearjng assign use predefined; 
for nulLbearing assign use 'Assign'; 
for null value use 'nulLsqLenumeration'; 

end SQL_Enumeration_AsJnti 

~ SQL_Enumeration_As_Char is based on the Ada type SQL_Standard.Char 
base domain SQL_Enumeration_As_Char 
(width: integer; 
map > image) 
is 

domain pattern is 

type [selfl_Not_Nuii is new [enumeration];' 

'package [selfl_Pkg is new SQL_Enumeration_Pkg (' 

1selfLnot_null)' 

type [selfLI^ype is new [sein_Pkg.SQL_Enumeration;' 
end pattern; 

derived domain pattern is 

type [seif]_Not_Null is new [parent]_Not_Nuii;' 
type [selfLType is new [parentLType;' 
end f»ttem; 

subdomain pattern is 

'subtype {selll_Not_Null is [parentLNot_Nuli;’ 

'subtype [selfLType is [parentLType;' 
end pattern; 

for not null type name use JselfLNoLNuir; 
for null type name use '[sel^Type'; ~ 
for data class use enumeration; 
for dbms type use character '([width])'; 
for conversion from not nuii to nuli use function 
'With_Nuir; 

for conversion from null to not null use function 
'Without_Nuir; 

for context clause use 'with sqLenumeration_pkg;'; 
for not_nuli_bearing assign use predefined; 
for nulLbearing assign use 'Assign'; 
for null value use 'nulLsqLenumeration'; 

end SQL_Enumeration_As_Char; 

end SAMeOL_Standard; 


82 


Intermetrics, Inc. 



Appendix B - SAMeDL Syste m 


Appendix B SAMeDTL_System 

The predefined SAMeDL definitional module SAMeDL_System provides a common location 
for the declaration of implementation-defined constants that are specitic to a particular 
DBMS/Ada compiler platform. 

definition module SAMeDL_System is 

" Smaiiest (most negative) vaiue of any integer type 
constant Minjnt is implementation defined: 

" Largest (most positive) vaiue of any integer type 
constant Maxjnt is implementation defined; 

~ Smaiiest value of any SQLJnt type 
constant Min.SQLJnt is inplementation defined: 

- Largest value of any SQLJnt type 

constant Max_SQLJnt is implementation defined; 

- Smaiiest vaiue of any SQL_Smaliint type 
constant Min_SQL_Smallint is implementation defined; 

- Largest value of any SQL_Smallint type 

constant Max_SQL_Smallint is implementation defined; 

~ Largest vaiue allowed for the number of significant decimai 
~ digits in any floating point constraint 
constant Max_Digits is implementation defined; 

- Largest value allowed for the number of significant decimal 
•• digits in any SQL.Reai floating point constraint 
constant Max_SQL_ReaLDigits is implementation defined; 

" Largest value allowed for the number of significant decimal 
" digits in any SQL_Doubie_Precision floating point constraint 
constant Max_SQL_Double_Precision_Digits is implementation defined; 

~ Largest vaiue allowed for the number of characters in a 

- character string constraint 

constant Max_SQL_Char_Length is implementation defined; 

- SQL Standard value for successful executbn of an SQL DML statement 
constant Success is 0; 

" SQL Standard value for data not found 
constant Not_Found is 100; 

end SAMeDL_System: 


Intermetrics, Inc. 


83 






Appendix C - Standard Support Operations and Specifications 


Appendix C Standard Support Operations and 
Specifications 

The following two sections discuss the SAME standard support packages. The first section 
describes how they support the standard base domains, and the second section lists their Ada 
package specifications. 

C.l Standard Base Domain Operations 

The SAME standard support packages encapsulate the Ada type definitions of the standard base 
domains, as well as the operations that provide the data semantics for domains declared using 
these base domains. This section describes the nature of the support packages, namely the Ada 
data types and the operations on objects of these types. 

The SQL standard package SQL_Standard contains the type definitions for a DBMS platform 
that define the Ada representations of the concrete SQL data types. A standard base domain 
exists in the SAMeDL for each type in SQL_Standard (except for SQLCode_Type), and these 
base domains are each supported by one of the SAME standard support packages. In addition to 
the above base domains, two standard base domains exist that provide data semantics for Ada 
enumeration types. 

Each support package defines a not null-bearing and a null-bearing type for the base domain. 
The not null-bearing type is a visible Ada type derived from the corresponding type in 
SQL_Standard with no added constraints. This t>T)e provides the Ada application progranmier 
with Ada data semantics for data in the database. The null-bearing tj^e is an Ada limited private 
type used to support data semantics of the SQL null value. In particular, the null-bearing type 
may contain the null value; the not null-bearing type may not. 

Domains are derived from base domains by the declaration of two Ada data tj^es, derived from 
the types in the support packages, and the instantiation of the generic operations package with 
these types. The type derivations and the package instantiation provide the domain with the 
complete set of operations that define the data semantics for that domain. These operations are 
described below, grouped by data class. 

C.1.1 All Domains 

All domains derived from the standard base domains make an Assign procedure available to the 
application because the type that supports the SQL data semantics is an Ada limited private type. 
For the numeric domains, this procedure enforces the range constraints that are specified for the 
domain when it is declared. The Ada Constraint Error exception is raised by these procedures 
if the value to be assigned falls outside of the specified range. 

A parameterless function named Null_SQL_<type> is available for all domains as well. This 
function returns an object of the null-bearing type of the appropriate domain whose value is the 
SQL null value. 

Every domain has a set of conversion functions available for converting between the not null¬ 
bearing type and the null-bearing type. The function With Null converts an object of the not 
null-bearing type and the null-bearing type. The function Without Null converts converts an 
object of the null-bearing type to an object of the no null-bearing type. Without Null will raise 


Intermetrics, Inc. 


85 





SAMeDL Language R^erence Manual 


the Null Value Error exception if the value of the object that it is converting is the SQL null 
value, since an object of the not null-bearing type can never be null. 

Two testing functions are available for each domain as well. The boolean functions Is Null and 
Not_Null test objects of the null-bearing type, returning the appropriate boolean value indicating 
whether or not an object contains the SQL null value. 

Additionally, all domains provide two sets of comparison operators that operate on objects of the 
null-bearing type. The first set of operators returns boolean values, and the second set of 
operators returns objects of the type Boolean_With_Unknown, defined in the support package 
SQL_Boolean_Pkg (see Section C.2.3), which implements three-valued logic. The boolean 
comparison operators are =, /=, <, >, <=, and >=, and return the value False if either of the 
objects contains the SQL null value. Otherwise, these operators perform the comparison, and 
return the appropriate boolean result. The Boolean_With Unknown comparison operators are 
Equals and , <, >, <=, and >=, and return the value Unknown if either of the objects contains 
the SQL null value. Otherwise, the.se operators perform the comparison, and return the 
Boolean_With_Unknown values True or False. 

C.1.2 Numeric Domains 

In addition to the operations mentioned above, all numeric domains provide unary and binary 
arithmetics operations for the null-bearing type of the domain. The subprograms that implement 
these operations provide the data semantics of the SQL null value with respect to these arithmetic 
operations. Specirically, any arithmetic operation applied to a null value results in the null value. 
Otherwise, the operation is defined to be the same as the Ada operation. The unary operations 
that are provided are -, and Abs. The binary operations include +, -, *, and /. Finally, all 
numeric domains provide the exponentiation operation (**). 

C.U Int and Smallint Domains 

Int and Smallint domains provide the application progranuner with the Ada functions Mod and 
Rem that operate on objects of the null-bearing type. Again, the subprograms that implement 
these operations provide the data semantics of the SQL null value with respect to these arithmetic 
operations. As with the other arithmetic operation. Mod and Rem return the null value when 
applied to an object containing the null value. Otherwise, they are defined to be the same as the 
Ada operation. 

These domains also make Image and Value functions available to the application programmer. 
Both of these functions are overloaded,' meaning that there are Image and Value functions that 
operate on objects of both the not null-bearing and the null-bearing types of the domain. The 
Image function converts an object of an Int or Smallint domain to a character representation of 
the integer value. The Value function converts a character representation of an integer value to 
an object of an Int or Smallint domain. These functions perform the same operation as the Ada 
attribute functions of the same name, except that the character set of the character inputs and 
outputs is that of the underlying SQL_Standard.Char character set If the Image and Value 
functions are applied to objects of the null-bearing type containing the null value, a null character 
object and a null integer object are returned respectively. 

C.1.4 Character Domains 

In addition to the operations provided by all domains, character domains provide the application 
programmer with some string manipulation and string conversion operations. 


86 


Intermetrics. Inc. 


Appendix C - Standard Support Operations and Specifications 


Character domains provide two string manipulation functions that operate on objects of the null¬ 
bearing type. The first one is the concatenation function (&). If either of the input character 
objects contains the null value, then the object returned contains the null value. Otherwise this 
operation is the same as the Ada concatenation operation. The other function is the Substring 
function, which is patterned after the substring function of SQL2. This function returns the 
portion of the input character object specified by the Start and Length index inputs. An Ada 
Constraint_Error is raised if the substring specification is not contained entirely within the input 
string. 

The remaining operations provided by the character domains are conversion functions. A 
ToJString and a To_Unpadded_String function exist for both the not null-bearing and the null¬ 
bearing types of the domain. The To String function converts its input, which exists as an 
object whose value is comprised of characters from the underlying character set of the platform, 
to an object of the Ada predefined type StandardString. If conversion of a null-bearing object 
containing the null value is attempted, the Null_Value_Error exception is raised. The 
ToJUnpadded String functions are identical in every way to the To String functions except 
that trailing blanks are stripped from the value. 

The Without Null Unpadded function is identical to the Without Null function, described in 
section C.1.1 above, except that trailing blanks are stripped from the value. 

Two functions exist that convert objects of the Ada predefined type StandardString to objects 
of the not null-bearing and null-bearing types of the domain. The To_SQL_Char_Not_Null 
function converts an object of type StandardString to the not null-bearing type of the domain. 
The To_SQL_Char function converts an object of type StandardString to an object of the null¬ 
bearing type." 

Finally, character domains provide the function Unpadded Length, which returns the length of 
the character string representation "without trailing blanks. This function operates on objects of 
the null-bearing type, and raises the Null_Value Error exception if the input object contains the 
null value. 

CJ.5 Enumeration Domains 

Enumeration domains provide functions for the null-bearing type that are normally available as 
Ada attribute functions for the not null-bearing type. The Image and Value functions have the 
same semantics as described for Int and Smcdlint domains in Section C.1.3 above, except that 
they operate on enumeration values rather than integers. 

The Pred and Succ functions operate on objects of the null-bearing type, and return the previous 
and next enumeration literals of the underlying enumeration type, respectively. If these functions 
are applied to objects containing the null value, an object containing the null value is returned. 

The last two functions are the Pos and Val functions. These functions also operate on objects of 
the null-bearing type. Pos returns a value of the Ada predefined type Standard.Integer 
representing the position (relative to zero) of the enumeration literal that is the value of the input 
object. If the input object contains the null value, then the Null Value Error exception is 
raised. The Val function accepts a value of the predefined type Standard Jnteger and returns the 
enumeration literal whose position in the underlying enumeration type is specified by that value. 
If the input integer value falls outside the range of available enumeration literals, the Ada 
Constraint Error is raised. 


Intermetrics, Inc. 


87 





SAMeDL Language R^erence Manual 


C.1.6 Boolean Functions 

The SAME standard support package SQL_Boolean_Pkg defines a number of boolean functions, 
namely not, and, or, and xor, which implement three-valued logic as defined in [SQL]. All of 
these Unctions operate on two input parameters of the type Boolean_With_Unknown, and return 
a value of that type. 

This support package also provides a conversion function, which converts the input of the type 
Boolean With Unknown to a value of the Ada predefined type boolean. If the input object has 
the value Unknown, then the Null Value Error exception is raised. 

Finally, the package provides three testing functions that return boolean values. These functions, 
IsJTrue, Is False, and IsJJnknown, return the value true if the input passes the test; otherwise 
functions return the value false. 


C.1.7 Operations Available to the Application 

Operand Type Exceptions 



Left 

Right 

Result 


All Domains 





Null SQL <type> 



-Type 


With_Null 


Not Null 

-Type 


Without Null 


_Type’ 

Not NulF 

Null Value Error 

ls_Null, Not.Null 


Type 

Boolean 


Assign® 

-Type 

-Type 


Constraint_Error 

.Equals, Not Equals 

-Type 

-Type 

B W 


<, >, <=, >= 

-Type 

-Type 

B W U 


=, /=. >, <, >=, <= 

-Type 

-Type 

Boolean 


Numeric Domains 





unary+/-, Abs 


-Type 

-Type 


+. /. * 

-Type 

-Type 

-Type 



-Type 

Integer 

-Type 


Int and Smallint Domains 




Mod, Rem 

-Type 

-Type 

-Type 


Image 

-Type 


SQL Char 


Image 

Not Null 

- 

SQL ChrNN® 


Value 

SQL Char 


Type 


Value 

SQL_ChrNN 


_Not_Null 


Character Domains 





Without_Null_Unpadded 


-Type 

Not Null 

Null Value Error 

To_String 


Not Null 

String 


To_String 


-Type 

String 

Null Value Error 

To_U npadded_String 


Not Null 

String 


To Unpadded String 


-Type 

String 

Null Value Error 

To_SQL_Char_Not Null 


String 

Not Null 


To_SQL_Char 


String 

-Type 


Unpadded_Length 


-Type 

SQL U L® 

Null Value Error 

Substring’® 


-Type 

-Type 

Constraint Error 

& 

-Type 

-Type 

-Type 



88 


Intermetrics, Inc. 







Appendix C - Standard Support Operations and Specifications 


Enumeration Domains 



Pred, Succ 


-Type 

-Type 

Image 


-Type 

SQL Char 

Image 


_Not_Null 

SQL_ChrNN 

Pos 


-Type 

Integer 

Val 


Integer 

-Type 

Value 


SQL Char 

-Type 

Value 


SQL ChrNN 

_Not_Null 

Boolean Functions 

not 


B W U 

Boolean 

and, or, xor 

B_W_U 

B W U 

Boolean 

To_Boolean 


B W U 

Boolean 

ls_True 

B W U 

B W U 

Boolean 

ls_False 

B W U 

B W U 

Boolean 

ls_Unknown 

B W U 

B W U 

Boolean 


Null Value Error 


Null Value Error 


1. "_Type" represents the type in the abstract domain of which objects that may be null are 
declared. 

2. "_Not_NuH" represents the type in the abstract domain of which objects that are not null 
may be declared. 

3. "Assign" is a procedure. The result is returned in object "Left". 

4. "B_W_U" is an abbreviation for Boolean_With_Unknown. 

5. "SQL_ChrNN" is an abbreviation for SQL_Char_Not_Null. 

9. "SQL_U_L" is an abbreviation for SQL_Char_Pkg subtype SQL_Unpadded_Length. 

10. Substring has two additional parameters: Start and Length, which are both of the 
SQL_Char_Pkg subtype SQL_Char_Length. 

C.2 Standard Support Package Specifications 

C.2.1 SQL_Standard 

The package SQL_Standard is defined in [ESQL] and is reproduced here for information only. 

package Sql_Standard is 

package Character_Set renames esp; 
subtype Character_Type is Character_Set.csf; 
type Char is array (positive range o) 
of Character_Type: 
type Smallint is range bs.. ts; 
type Int is range bi.. ti; 
t^e Real is digits dr; 
type Double_Precision is digits dd; 
type Sqlcode_Type is range bsc.. tsc; 

subtype Sql_Error is Sqlcode_Type range Sqlcode_Type'FIRST .. -1; 
subtle Not_Found is ^lcode_Type range 100..100; 
subtype lndicator_Type is t; 


Intermetrics, Inc. 


89 





SAMeDL Language Reference Manual 


- csp is an implementator-defined package and csf is an 

- implementor-defined character type, bs, tw. bi, ti, dr, dd, bsc, 

- and tsc are implementor-defined integral values, t is int or 

" smallint corresponding to an implementor-defined <exact_numeric_type> 
~ of indicator parameters. 

end SqLStandard; 


C.23 SQL_Boolean_Pkg 

package SQL_Boolean_Pkg is 


type Boolean_with_Unknown is (FALSE, UNKNOWN, TRUE): 


-I Three valued Logic operations 
-I three-val X three-val s> three-vai 


-I A B A and B 

HT T T 

-IT F F 

-IFF F 

-ITU U 

-I F U F 

-|U U U 


A or B A xor B not A 


T F F 
T T F 
F F T 
T U F 
U U T 
U U U 


function "not" (Left: Boolean_with_Unknown) return Boolean_with_Unknown; 
function "and" (Left, Right: Boolean_with_Unknown) return Boolean_with_Unknown; 
function "or" (Left. Right: Boolean_wlth_Unknown) return Boolean_^h_Unknown: 
function "xor (Left. Right; Boolean_with_Unknown) return Boolean_with_Unknown: 


— three-val s> bool or exception- 

function To_Boolean (Left; Boolean_with_Unknown) return Boolean; 


— three-val s> bool- 

function ls_True (Left: Boolean_with_Unknown) return Boolean; 
function ls_False (Left: Boolean_with_Unknown) return Boolean; 
function ls_Unknown (Left: Boolean_with_Unknown) return Boolean; 

end SQL_Boolean_Pkg; 


C.2.4 SQL_Int_Pkg 
with SQL_Standard; 

with SQL_Boolean_Pkg; use SQL_Boolean_Pkg; 
with SQL_Char_Pkg; use SQL_Char_Pkg; 
package SQLJnt_Pkg is 

type SQLJnt_not_null is new SQL_Standard.lnt; 

— Possibly Null Integer— 
type SQLJnt is limited private; 

function Null_SQL_lnt return SQLJnt; 


90 


Intermetrics, Inc. 






Appendix C - Standard Support Operations and Specifications 


-I This pair of functions convert between the null-bearing and non-nuil-bearing types. 

function Without_NulLBase(Value ; SQLJnt) return SQLJnt_Not_Null: 
function Wfth_Null_Base(Value ; SQLJnt_Not_Null) return SQLJnt; 

-I With_Null_Base raises Nuli_Vaiue_Error if the input value is null 


-I This procedure Implements range checking. Note: It is not meant to be used directly 
-I by application programmers. See the generic package SQL_lnt_Ops. 

~| Raises constraim_error if not (First <s Right <= Last) 

procedure Assign_with_check { 

Left: in out SQLJnt: Right: SQLJnt; 

First, Last. SQLJrrt_Not_Null); 


~| The following functions Implement three valued arithmetic. If either input to any of 
-I these functions is null, the function returns the null value; otherwise they perform 
-I the Indicated operation. These functions raise no exceptions. 

function "+"{Right; SQLJnt) return SQLJnt; 
function "-"(Right: SQL_lnt) return SQLJnt; 
function "abs"(Right; SQL_lnt) return SQLJnt; 
function "+"(Left, Right: SQLJnt) return SQLJnt; 
function """(Left, Right: SQLJnt) return SQLJnt; 
function "-"(Left, Right: SQLJnt) return SQL_lnt; 
function "/"(Left, Right: SQL_lnt) return SQLJnt; 
function "mod" (Left, Right: SQL_lnt) return SQLJnt; 
function "rem" (Left, Right; SQLJnt) return SQLJnt: 
function (Left: SQL_lnt; Right; Integer) return SQL_lnt: 


-I simulation of 'IMAGE and 'VALUE that retumAake SQL_Char[_Not_Null] instead 
-I of string 

function IMAGE (Left: SQLJnt_Not_Null) return SQL_Char_Not_Null; 
function IMAGE (Left; SQL_lnt) return SQL_Char; 
function VALUE (Left: SQL_Char_Not_NUII) return SQLJnt_Not_Null: 
function VALUE (Left: SQL_Char) return SQL_lnt: 


Logical Operations 

type X type => Booleanjwith_unknown 


These functions implement three valued logic. If either Input is the null value, 
the functions return the truth value UNKNOWN; otherwise they perform the 
indicated comparison. These functions raise no exceptions. 


function Equals (Left, Right; SQL_lnt) return Boolean_with_Unknown; 
functton Not_Equals (Left, Right; SQLJrrt) return Boolean_with_Unknown: 
function "<" (Left, Right: SQL_lnt) return Boolean_with_Unknown: 
function ">" (Left, Right: SQLJnt) return Boolean_with_Unknown: 
function "<=" (Left, Right: SQL_lnt) return Boolean_with_Unknown: 
function ">=" (Left, Right: SQL_lnt) return Boolean_with_Unknown; 


-I type =;> boolean 

function ls_Null(Value : SQL_lnt) return Boolean; 


Intermetrics, Inc. 


91 








SAMeDL Language Reference Manual 


function Not_Null(Value : SQLJnt) return Boolean; 

-I These functions of class type => boolean Equate UNKNOWN with FALSE. That Is, 
-I they return TRUE only when the function returns TRUE. UNKNOWN and FALSE 
-I are mapped to FALSE. 

function "=" (Left, Right: SQLJnt) return Boolean; 
function "<" (Left, Right: SQLJnt) return Boolean; 
function ">" (Left, Right: SQLJnt) return Boolean; 
function "<=" (Left, Right: SQL_lnt) return Boolean; 
function ">=" (Left, Right; SQL_lnt) return Boolean; 


-I This generic Is Instantiated once for every abstract domain based on the SQL type 
-I Int. The three subprogram formal parameters are meant to default to the programs 
-I declared above. That is, the package should be Instantiated in the scope of a use 
-I ciause for SQLJnt_Pkg. The two actuai types together foim the abstract domain. 

-I The purpose of the generic Is to create functions which convert between the two 
-I actual types and a procedure which implements a range constrained assignment for 
-I the null-bearing type. The bodies of these subprograms are calls to subprograms 
-I declared above and passed as defaults to the generic. 

generic 

type With_NullJype is limited private; 
type Wtthout_nulljypa is range o; 

with function With_NulLBase(Value : SQLJnt_Not_Null) return With_Null_Type is <>; 
with function Without_Null_Base(Value : With_Null_Type) return SQLJnt_Not_Null is o; 
with procedure Assign_with_check ( 

Left; in out With_NulLType; 

Right: With_Null_Type; 

First. Last: SQLJnt_Not_Null) is o; 

package SQL_lnt_Ops is 

function With_Null (Value : Without_NullJype) return With_NullJype; 
function Without_Null (Value : With_Null_Type) return Without_NulLtype; 
procedure Assign (Left: in out With_null_Type; Right: in With_null_t^); 
end SQL_lnt_Ops; 

private 


-I not shown 

end SQLJnt_Pkg; 


C.2.5 SQL_Smallint_Pkg 
with SQL_Standard; 

with SQL_Boolean_Pkg; use SQL_Boolean_Pkg; 
with SQL_Char_Pkg; use SQL_Char_Pkg; 
package SQL_Smallint_Pkg is 

type SQL_Smallint_not_null is new SQL_Standard.Smallint; 

— Possibly Null Integer— 
type SQL_Smallint is limited private; 

function Null_SQL_Smallint return 3QL_Smallint; 


92 


Intermetrics, Inc. 





Appendix C - Standard Support Operations and Specifications 


-I this pair of functions converts between the null*bearlng and tran-null-bearing types 

function Without_Null_Base(Value : SQL_Smallint) return SQL_Smallint_Not_Null: 
function With_Null_Base{Value : SQL_Smallint_Not_Null) return SQL_Smallint: 

-I Wlth_Null_Base raises Nuli_Value_Error if the input value Is null 


-I This procedure implements range checking. Note: it is not meant to be used directly 
-I by application programmers. See the generic package SQL_Smallim_Ops. 

-I Raises constraint_error If not (First <= Right <= Last) 

procedure Assign_with_check ( 

Left: in out SQL_Smallint; 

Right: SQL_Smallint; 

First, Last: SQL_Smallint_Not_Null); 


-I The following functions Implement three valued arithmetic. If either input to any of 
-I these functions is null, the function returns the null value; otherwise they perform 
-I the indicated operation. These functions raise no exceptions. 

function "+"{Right: SQL_Smallint) return SQL_Smallint; 
function "-"(Right: SQL_Smallint) return SQL_Smallint; 
function "abs"(Right: SQL_Smaltint) return SQL_Smallint: 
function "-t-"(Left, Right: SQL_Smallint) return SQL_Smallint; 
function -"{Left, Right: SQL.Smallint) return SQL_Smallint: 
function "-"(Left, Right: SQL_Smallint) return SQL_Smallint: 
function "r(Left, Right: SQL_Smallint) return SQL_Smallint; 
function "mod" (Left, Right: SQL_Smailint) return SQL_Smallint: 
function "rem" (Left, Right: SQL.Smallint) return SQL_Smallint: 
function (Left: SQL_Smallint; Right: Integer) return SQL_S'Tiall'nt: 


-I simulation of 'IMAGE arKf 'VALUE that retum/take SQL_Chait_Not_Null] instead 
Hof string 

function IMAGE (Left: SQL_Smallint_Not_Null) return SQL_Char_Not_Null: 
function IMAGE (Left: SQL_SmaHint) return SQL_Char: 
function VALUE (Left: SQL_Char_Not_Null) return SQL_Snfiallint_Not_Null: 
function VALUE (Left: SQL_Char) return SQL_Smallint: 


Logical Operations 

type X type => Booleanjwithjunknown 


These functions Implement three valued logic. If either Input is the null value, 
the functions return the truth value UNKNOWN; otherwise they perform the 
indicated comparison. These functions raise no exceptions. 


function Equals (Left, Right: SQL_Smallint) return Boolean_with_Unknown; 
function Not_Equals (Left, Right: SQL_Smallint) return Boolean_with_Unknown; 
function "<" (Left, Right: SQL_Smallint) return Boolean_with_Unknown: 
function ">" (Left, Right: SQL_Smallint) return Boolean_with_Unknown: 
function "<=" (Left, Right: SQL_Smallint) return Boolean_with_Unknown: 
function ">=" (Left, Right: SQL_Smalllnt) return Boolean_with_Unknown; 


-I type => boolean 


Intermetrics, Inc. 


93 







SAMeDL Language Reference Manual 


function ls_Null(Value ; SQL_SmaHint) return Boolean; 
function Not_Null(Value: SQL^Smallint) return Boolean; 

-I These functions of class type s> boolean. Equate UNKNOWN with FALSE. That Is, 

-I they return TRUE only when the function returns TRUE. UNKNOWN and FALSE 

function (Left. Right: SQL_Smallint) return Boolean; 
function "<" (Left, Right: SQL_Smallint) return Boolean; 
function ">" (Left, Right: SQL_Smallint) return Boolean; 
function "<=" (Left, Right: SQL_Smallint) return Boolean; 
function ">=" (Left, Right: SQL_Smallint) return Boolean; 

-I This generic Is instantiated once for every abstract domain based on the SQL type 
-I Smallint. The three subprogram formal parameters are meant to default to the 
-I programs declared above. That is, the package should be instamiated in the scope 
-I of a use clause for SQL_Smalllnt_Pkg. The two actual types together form the 
-I abstract domain. The purpose of the generic is to create functions which convert 
-I between the two actual types and a procedure which implements a range 
-I constrained assignment for the null-bearing type. The bodies of these subprograms 
-I are calls to subprograms declared above and passed as defaults to the generic. 


generic 

type With_Null_type is limited private; 
type Without_null_type is range o; 

with function With_Null_Base(Value : SQL_Smallint_Not_Null) return With_Null_Type is <>; 
with function Without_Null_Base(Value : Wlth_Null_Type) 
return SQL_Smailint_Not_Null is <>; 
with procedure Assign_with_check ( 

Left: in out With_Null_Type; 

Right: Wrth_Null_Type; 

First. Last; SQL_Smallint_Not_Null) is o; 

package SQL_Smallint_OPs is 

function With_Nuli (Value : Without_Null_type) return With_Null_type; 
function Without_Null (Value : With_Null_Type) return Without_Null_type; 
procedure Assign (Left; in out With_null_Type; Right: in With_null_type); 
end SQL_Smallint_ops; 

private 


~| not shown 
end SQL_Smallint_Pkg; 


C.2.6 SQL_Real_Pkg 
with SQL_Standard; 

with SQL_Boolean_Pkg; use SQL_Boolean_Pkg; 
package SQL_Real_Pkg is 

type SQL_Real_Not_Null is new SQL_Standard.Real; 

— Possibly Null Real— 
type SQL_Real is limited private; 

function Null_SQL_Real return SQL_Real; 


94 


Intermetrics, Inc. 









Appendix C - Standard Support Operations and Specifications 


-I this pair of functions converts between the null-bearing and non-null-bearing types 

function Without_Null_Base(Value: SQL_Real) return SQL_ReaLNot_Null: 
function With_Null_Base(Value : SQL_Real_Not_Null) return SQL_Real: 

-I With_Null_Base raises Null_Vaiue_Error If the Input value is null 


-I This procedure Implements range checking. Note: It is not meant to be used directly 
-I by application programmers. See the generic package SQL_Real_Ops. 

-I Raises constraim_error If not (First <= Right <= Last) 

procedure Assign_with_Check ( 

Left: in out SQL_Real: 

Right: SQL_Real; 

First, Last: SQL_Real_Not_Null): 

-I The following functions implement three valued arithmetic. If either input to any of 
-I these functions is null, the function returns the null value; othenwlse they perform 
-I the indicated operation. These functions raise no exceptions. 

function "+"(Right: SQL_Real) return SQL_Real: 
function "-"(Right: SQL_Real) return SQL_Real: 
function "abs"(Right: SQL_Real) return SQL_Real: 
function "+"(Left, Right: SQL_Real) return SQL_Real: 
function """(Left, Right: SQL_Real) return SQL_Real: 
function "-"(Left, Right: SQL_Real) return SQL_Real; 
function "r(Left, Right: SQL_Real) return SQL_Real: 
function """"(Left: SQL_Real: Right: Integer) return SQL_Real: 

-I Logical Operations 

-I type X type s> Boolean_wlth_unknown 

-I These functions Irnplernem three valued logic, if either Input is the null value, 
-I the functions return the truth value UNKNOWN; otherwise they perform the 
-I indicated comparison. These functions raise no exceptions. 

function Equals (Left, Rigljt: SQL_Real) return Boolean_with_Unknown; 
function Not_Equals (Left, Right; SQL_Real) return Boolean_with_Unknown: 
function "<" (Left, Right: SQL_Real) return Boolean_with_Unknown: 
function ">" (Left, Right; SQL_Real) return Boolean_with_Unknown; 
function ”<=" (Left, Right: SQL_Real) return Boolean_with_Unknown; 
function ">=” (Left, Right: SQL_Real) return Boolean_with_Unknown; 

-I type => boolean 

function ls_Null(Value : SQL_Real) return Boolean; 
function Not_Null(Value : SQL_Real) return Boolean; 


-I These functions of class type => boolean 

-I Equate UNKNOWN with FALSE. That Is, they return TRUE only when the function 
-I returns TRUE. UNKNOWN and FALSE are mapped to FALSE. 

function "=" (Left, Right; SQL_Real) return Boolean; 
function "<" (Left, Right: SQL_Real) return Boolean; 
function ">" (Left, Right: SQL_Real) return Boolean; 
function "<=" (Left, Right: SQL_Real) return Boolean; 
function ">=” (Left, Right: SQL_Real) return Boolean; 


Intermetrics, Inc. 


95 









SAMeDL Language Reference Manual 


-\ This generic Is instantiated once for every abstract domain based on the SQL type 
-I Real. The three subprogram formal parameters are meant to default to the programs 
-I declared above. That is, the package should be Instantiated in the scope of a use 
-I clause for SQL_ReaLPkg. The two actual types together form the abstract domain. 
-I The purpose of the generic is to create functions which convert between the two 
-I actual types and a procedure which implements a range constrained assignment for 
-I the null-bearing type. The bodies of these subprograms are calls to subprograms 
-I declared above and passed as defaults to the generic. 

generic 

type With_Null_type is limited private: 
type Without_nulLtype is digits <>; 

with function With_Null_Base(Value ; SQL_Real_Not_Null) return With_Null_Type is <>; 
with function Without_Null_Base(Value : With_NuM_Type) return SQL_Real_Not_Null is <>: 
with procedure Assign_with_check ( 

Left; in out With_NulLType; 

Right: With_Null_Type: 

First. Last: SQL_ReaLNot_Null) is o; 

package SQL_Real_Ops is 

function With_Null (Value : Without_Null_type) return With_NulLtype; 
function Without_Null (Value : With_NulLType) return Withouf_Null_type: 
procedure Assign (Left: in out With_Null_Type: Right: in With_Null_type): 
end SQL_Real_Ops; 

private 

-I not shown 

end SQL_Real_Pkg: 


C.2.7 SQL_Double_Precision_Pkg 


C.2.8 SQL_Char_Pkg 

with SQL_System; use SQL_System; 

with SQL_Boolean_Pkg; use SQL_Boolean_Pkg; 

with SQL_Standard; 

package SQL_Char_Pkg is 

subtype SQL_Char_Length is natural range 1 .. MAXCHRLEN; 
subtype SQL_Unpadded_Length is natural range 0 .. MAXCHRLEN; 

type SQL_Char_Not_Null is new SQL_Standard.Char: 
type SQL_Char(Length : SQL_Char_Length) is limited private; 

function Null_SQL_Char return SQL_Char; 

-I The next three functions convert between null-bearing and non nuil-bearing-types. 
-I Without_Null_Base and Wlth_Null_Base are inverses (mod. null values). 

-I See also SQL_Char_Ops generic package below 

function With_Null_Base(Value : SQL_Char_Not_Null) return SQL_Char: 
function Without_Null_Base(Value : SQL_Char) return SQL_Char_Not_Null: 


96 


Intermetrics, Inc. 








Appendix C - Standard Support Operations and Specifications 


function Without_Null_Unpaclded_Base(Value : SQL_Char) return SQL_Char_Not_Null: 

-I Without_NulLUnpadded_Base removes trailing blanks from the Input 
-I Axiom: unpadded_Length(x) = Without_Null_Unpadded_Base(x)'Length 
-I Both Wlthout_Null_Base and Without_Null_Unpadded_Base raise 
-I nulLvalue.error If x Is null 

function Unpadded_Length (Value ; SQL_Char) return SQL_Unpadded_Length; 

-I The next six functions convert between Standard-Strlng 
-I types and the SQL_Char and SQL_Char_Not_Null types 

function To_String (Value : SQL_Char_Not_Null) return String; 

function To_String (Value : SQL_Char) return String; 

function To_Unpadded_String (Value ; SQL_Char_Not_Null) return String; 

function To_Unpadded_String (Value : SQL_Char) return String; 

function To_SQL_Char_Not_Null (Value: String) return SQL_Char_Not_Null; 

function To_SQL_Char (Value : String) return SQL_Char; 

-I Assignment operator for "null-bearing'* type 

procedure Assign (Left: out SQL_Char; Right; SQL_Char); 

-I Substring(x,k,m) returns the substring of x starting at position k (relative to 1) with 
-I length m. Returns null value If x Is null 

-I Raises constralnt_error If Start < 1 or Length < 1 or Start -i- Length -1 > x.Length 

function Substring (Value : SQL_Char; Start, Length; SQL_Char_Length) return SQL_Char; 

-I returns null If either parameter is null; otherwise performs concatenation In the 
-I usual way, preserving all blanks. May raise constralnt„error Implicitly If result Is too 
-I large (i.e., greater than SQL_Char_Length'Last 

function (Left, Right: SQL_Char) return SQL_Char; 

-I Logical Operations 

-I type X type => Boolean_with_unknowiv- 

-1 The comparison operators return the boolean value UNKNOWN if either 
-I parameter is null; otherwise, the comparison is done In accordance with 
-I ANSI X3.135-1986 para 5.11 general rule 5; that Is, the shorter of the two string 

-I parameters Is effectively padded with blanks to be the length of the longer 

-I string and a standard Ada comparison is then made 

function Equals (Left, Right: SQL_Char) return BooIean_with_Unknown; 
function Not_Equals (Left, Right: SQL_Char) return Boolean_with_Unknown; 
function "<" (Left, Right: SQL_Char) return Boolean_with_Unknown; 
function ">" (Left, Right; SQL_Char) return Boolean_with_Unknown; 
function "<=" (Left, Right: SQL_Char) return Boolean_with_Unknown; 
function ">=" (Left, Right: SQL_Char) return Boolean_with_Unknown; 

-I type s> boolean- 

function ls_Null(Value : SQL_Char) return Boolean; 
function Not_Nuii(Value : SQL_Char) return Boolean; 

-I These functions of class type => boolean equate UNKNOWN with FALSE. That Is, 

-I they return TRUE only when the function returns TRUE. UNKNOWN and FALSE 
-I are mapped to FALSE. 


Intermetrics, Inc. 


97 






SAMeDL Language Reference Manual 


function(Left, Right: SQL_Char) return Booiean; 
function "<" (Left, Right: SQL_Char) rp* 'm Boolean; 
function ">" (Left, Right: SQL_Char) rtijm Boolean; 
function "<»" (Left, Right: SQL_Char) return Boolean; 
function ">=" (Left, Right: SQLi.Char) return Boolean; 


-I The puipose of the following generic is to generate conversion functions between a 
-I type derived from SQL_Char_Not_Null, vrhich are effectively Ada strings and a type 
-I derived from SQL.Char, which mimic the behavior of SQL strings. The subprogram 
formals are rneam to default; that Is, this generic should be Instamiated in the scope 
-I of an use clause for SQL_Char_Pkg. 


generic 

type With_Null_Type is limited private; 

type Without_Null_Type is array (positive range o) of sql_standard.Character_type; 
with function With_Null_Base (Value: SQL_Char_Not_Null) return With_Null_Type is <>; 
with function Without_NulLBase (Value: With_Null_Type) return SQL_Char_Not_Null is <>; 
with function Without_Null_Unpadded_Base (Value: With_Null_Type) 
return SQL_Char_Not_Null is o; 

package SQL_Char_Ops is 

function With_Null (Value : Without_Null_Type) return With_Null_Type: 
function Without_Null (Value: With_Null_Type) return Without_Null_Type; 
function Without_Null_Unpadded (Value : With_Null_Type) return Wlthout_Null_Type: 
end SQL_Char_Ops; 

private 


-I not shown 
end SQL_Char_Pkg; 


C.2.9 SQL_Enumeration_Pkg 

with SQL_Boolean_Pkg- use SQL_Boolean_Pkg: 
with SQL_Char_Pkg; use SQL_Char_Pkg; 
generic 

type SQL_Enumeration_Not_Null is (<>); 

package SQL_Enumeration_Pkg is 

-I — Possibly Null Enumeration— 
type SQL_Enumeration is limited private; 

function Null_SQL_Enumeration return SQL_Enumeration; 

-I This pair of functions convert between the null-bearing and non-mill-bearing types. 

function Without_Null(Value : in SQL_Enumeration) return SQL_Enumeration_Not_Null; 
function With_Null(Value : in SQL_Enumeration_Not_Null) return SQL_Enumeration; 

-I With_Null raises Null_yalue_Error if the Input value is null 


-I Assignment operator for "null-bearing'* type 


98 


Intemi'':rics, Inc. 




Appendix C - Standard Support Operations and Specifications 


procedure Assign (Left ; in out SQL_Enufneration: Right: in SQL_Enumeration): 

-I Logical Operations 

-I type X type => Boolean_with_unknown 

-I These functions Implement three valued logic. If either Input Is the null value, 
-I the functions return the truth value UNKNOWN; otherwise they perform the 
-I Indicated comparison. These functions raise no exceptions 

function Equals (Left, Right: SQL_Enumeration) return Boolean_with_Unknown; 
function Not_Equals (Left. Right; SQL_Enumeration) return Boolean_with_Unknown: 
function "<" (Left, Right: SQL_Enumeration) return Boolean_with_Unknown: 
function ">" (Left, Right; SQL_Enumeration) return Boolean_with_Unl<rH)wn; 
function "<=■• (Left, Right; SQL_Enumeration) return Boolean_with_Unknown: 
function ">=" (Left, Right: SQL_Enumeration) return Boolean_with_Unknown; 


~| type => boolean 

function ls_Null (Value : SQL_Enumeration) return Boolean; 
function Not_Null (Value : SQL_Enumeratipn) return Boolean; 
function “=" (Left. Right: SQL_Enumeration) return Boolean; 
function (Left, Right; SQL_Enumeration) return Boolean; 
function (Left, Right; SQL_Enumeration) return Boolean; 
function "<=" (Left. Right: SQL_Enumeration) return Boolean; 
function ”>»” (Left, Right; SQL_Enumeration) return Boolean; 


-I 'Pred, 'Succ, ‘Image, ‘Pos, ‘Val, and 'Value attributes of the 
-I SQL_Enumeration_Not_Null t^e, passed In, for the associated SQL_Enumeration 
-I (null) type. They all raise the Nuil_Vaiue_Error exception if a null value is passed in. 


Pred raises the Constraint_Error exception If the value passed In Is equal to 
SQL_Enumeratlon_N^_NuirLast. 

Succ raises the Constr^nt.Error exception if the value passed in is equal to 
SQL_Enumeration_Not_Nuli'Rrst. 

Val raises the Constraint.Error exception If the value passed In is not in the range 
P'POS(P*FIRST)..P'POS(P'LAST) for type P. 

Value raises the Constraint_Error exception if the sequence of characters passed in 
does not have the syntax of an enumeration literal for the Instantiated 
enumeration type. 


function Pred (Value : in SQL_Enumeratlon) return SQL_Enumeration; 

function Succ (Value : in SQL_Enumeration) return SQL_Enumeration; 

function Pos (Value ; in SQL_Enumeratk>n) return Integer; 

function Image (Value ; in SQL_Enumeration) return SQL_Char; 

function Image (Value ; in SQL_Enumeration_Not_Null) return SQL_Char_Not_Null; 

function Val (Value : in Integer) return SQL_Enumeration; 

function Value (Value : in SQL_Char) return SQL_Enumeration; 

function Value (Value : in SQL_Char_Not_Null) return SQL_Enumeration_Not_Null; 

private 

-I not shown 

end SQL_Enumeration_Pkg; 


Intermetrics, Inc. 


99 








Appendix D - Transform Chart 


Appendix D Transform Chart 


Function Section Input _ Output _ Output Is 


AdaNAME 

4.1.5 

Record Declaration 

Ada Identifier 

Default name of the row record formal 
parameter 


5.6 

Parameter 

Ada Identifier 

Name of the parameter in the Ada procedure 
declaration 


5.7 

Select Parameter 

Ada Identifier 

Name of the component in the Ada row 
record type 


5.8 

Insert Column 
Specification 

Ada Identifier 

Name of the component in the Ada row 
record type 


5.10 

Value Expression 

Ada Identifier 

Default name for record component if the 
expression appears as a sel^t parameter 

AdaType 

4.1.4 

Constant Declaration 

Ada Identifier 

Name of the type in Ada declaration of 
constant 


5.6 

Parameter 

Ada Identifier 

Name of the type of the parameter in the 

Ada procedure declaration 


5.7 

Select Parameter 

Ada Identifier 

Name of the type of the component in the 
Ada row rec^ type 


5.8 

Insert Column 
Specification 

Ada Identifier 

Name of the type of the component in the 
Ada row lec^ type 

COMP^d. 

5.2 

Select Parameter 

Insert Column 
Specification 

Ada Record 
Component 

Used in declaration of the Ada row record 
type 


5.4 

Select Parameter 

Ada Record 
Component 

Used in declaralion of the Ada row record 
type 

DATACLASS 

2.4 

Literal 

Data Class 

Data class of the literal 


4.1.1 

Base Domain 

Data Class 

Data class of the base domain 


4.1.3 

Domain 

Domain Parameter 

Data Class 

Data class of the domain or domain 
parameter 


4.1.4 

Constant 

Data Class 

Data class of the constant 


4.2 

Column 

Data Class 

Data class of the column 


5.6 

Parameter 

Data Class 

Data class of the parameter 


5.10 

Value Expression 

Data Class 

Data class of the expression 

DBLngNAME 

5.7 

4.1.5 

Dblength Phrase 

Ada identifier 

Name of dblength parameter 
undefined if no dblength phrase 

DBLeiigAd. 

5.2 

5.4 

Select Parameter 

Ada Record 
Component 

Row record component used for dblength 
data 

DBMS_TYPE 

4.1.3 

Domain 

SQL Data Type 

SQL data type to be used at the database 
interface with an object of the specified 


domain 


Intermetrics, Inc. 101 





SAMeDL LanRuage Reference Manual 


Function 

Section 


Output 

Output is 

DOMAIN 

4.1.3 

Domain Parameter 

NO.DOMAIN 

NO_DOMAIN is the domain of a domain 
parameter 


4.1.4 

Constant 

Domain 

Domain of the constant (NO_DOMAIN for 
universal constants) 


4.2.1 

Column 

Domain 

Domain of the column 


5.6 

Parameter 

Eiomain 

Domain of the parameter 


5.10 

Value Expression 

Domain 

Domain of the expression G'lO-DOMAIN 
for universal constants) 

rNDrv,?,i;,*4E 

5.6 

Parameter 

SQL Identifier 

Name of an SQL indicates parameter 


5.7 

Select Parameter 

SQL Identifier 

Name of an SQL indicator parameter 


5.8 

Insert Column 
Specification 

SQL Identifier 

Name of an SQL indicator parameter 

INDICsql 

5.6 

Parameter 

SQL Indicator Param 

Name of an SQL indicauv parameter 

5.7 

Select Parameter 

SQL Indicator I*aram 

Name of an SQL indicator parameter 


5.8 

Insert Column 
Specification 

SQL Indicator Param 

Name of an SQL indicator parameter 

LENGTH 

2.4 

Literal 

Natural Number 

Length of the literal (NO_LENGTH if not 
char literal) 


4.1.3 

Domain 

Domain Parameter 

Natural Number 

Length of objects in domain or domain 
parameter value (NO_LENGTH if not 
char domain or parameter) 


4.1.4 

Constant 

Natural Number 

Length of the constant (NO_LENGTH if not 
char literal) 


4.2.1 

Column 

Natural Number 

Length of domain of column 


5.6 

Parameter 

Natural Number 

Length of domain of parameter 


5.10 

Value Expression 

Natural Number 

Length of expression (NO_LENGTH if not 
char literal) 

MODE 

5.6 

Parameter 

Ada Mode 

Mode of the parameter in the Ada procedure 
declaration 

PARM^d. 

5.6 

Parameter 

Ada Parameter 
Declaration 

Ada parameter declaration in the Ada 
procedure declaration 

PARMro, 

5.9 

Into Clause 

Insert From Clause 

Ada Identifier 

Name of row record parameter 

PARMsql 

5.6 

Parameter 

SQL Parameter 

An SQL parameter declaration 


5.7 

Select Parameter 

SQL Parameter 

An SQL parameter declaration 


5.8 

Insert Column 
Specification 

SQL Parameter 

An SQL parameter declaration 


102 


Intermetrics, Inc. 








Appendix D - Transform Chart 


Function 

Section 


Output 

Output Is 

SCALE 

2.4 

Literal 

Natural Number 

Scale of the literal (NO_SCALE if not a 
numeric literal) 


4.1.3 

Domain 

E>omain Parameter 

Natural Number 

Scale of objects in domain or domain 
parameter value (NO_SCALE if not a 
numeric domain or parameter) 


4.1.4 

Constant 

Natural Number 

Scale of the constant (NO_SCALE if not a 
numeric literal) 


4.2.1 

Column 

Natural Number 

Scale of domain of column 


5.6 

I*arameter 

Natural Number 

Scale of domain of parameter 


5.10 

Value Expression 

Natural Number 

Scale of expression using SQL rules 
(NO_SCALE if not a numeric literal) 

SQLname 

2.3 

Ada Identifier 

SQL Identifier 

Unique SQL identifier 


5.4 

Cursor Name 

SQL Identifier 

Unique SQL cursor name 


5.6 

Parameter Name 

SQL Identifier 

Unique SQL parameter name 


5.7 

Select Parameter 

SQL Identifier 

Unique name of SQL parameter 


5.8 

Column Name 

SQL Identifier 

Unique name of SQL parameter 

SQLsc 

5.11 

Search Condition 

SQL Search 
Condition 

An SQL search condition 

SQLsq 

5.12 

Subquery 

SQL Subquery 

An SQL subquery 

SQLve 

5.10 

Value Expression 

SQL Value 
Expression 

An SQL value expression 

TYPEr,,, 

5.9 

Into Clause 

Insert From Clause 

Adaldei ifter 

Name of the type of the row record 
parameter 

VALUE 

4.1.4 

Static Expression 

Ada Literal 

Value assigned to the expression by the 


rules of SQL 


Intermetrics, Inc. 


103 







Appendix E - Glossary 


Appendix E Glossary 

Abstract Interface. A set of Ada package specifications containing the type and procedure 
declarations to be used by an Ada application program to access the database. 

Abstract Module. A module that specifies the database routines needed by an Ada application. 

Assignment context. A value expression appears in an assignment context if the value of that 
value expression is to be implif'itly or explicitly assigned to an object. The assignment contexts 
are: select parameters, constant declarations, values in a VALUES list of an insert statement, set 
items in an update statement. 

Base domain. A template for defining domains. 

Conform. A value expression in an assignment context conforms to a target domain if the rules 
of SQL allow the assignment of a value of the data class of the expression to an object of the data 
class of the domain. 

Conversion method. A method of converting non-null data between objects of the not null- 
bearing type, the null-bearing type, and the database type associated with the domain. 

Correlation name. See [SQL], Section 5.7. 

Cursor. See [SQL], Section 8.3. 

Data class. The data class of a value is either character, integer, fixed, float, or enumeration. 
The data class of a domain determines which values may be converted, implicitly or explicitly, to 
the domain. 

Database type. The SQL data type to be used with an object of that domain when it appears in 
an SQL parameter declaration. This need not be the same as the type of the data as is stored in 
the database. 

Definitional module. A module that contains shared definitions: that is, declarations of base 
domains, domains, subdomains, constants, records, exceptions, enumerations, and status maps 
that are used by other modules. 

Domain. The set of values and applicable operations for objects associated with a domain. A 
domain is similar to Ada type. 

Exposed. The exposed name of a module (table) that appears in a context clause (table reO 
containing an as phrase (correlation name) is the identifier in the associated as phrase (correlation 
name); the module name (table name) is hidden. If the as phrase (correlation name) is not 
present, the exposed name is that module's (table’s) name. The exposed name of a table or 
module is the name by which that table or module is referenced. 

Extended. A table, view, module, procedure, cursor, or cursor procedure that includes some 
nonstandard operation or feature. 

Hidden. See exposed. 

Module. A definitional module, a schema module, or an abstract module. 


Intermetrics, Inc. 


105 







SAMeDL Language Reference Manual 


Not null type. The Ada type associated with objects of a domain that may not take a null value. 

Null type. The Ada type associated with objects of a domain that may take a null value. 

Null value. SQL's means of recording missing information. A null value in a column indicates 
that nothing is known about the value that should occupy the colunm. 

Options. The aspects of the base domain that are essential to the declaration of domains based 
upon the base domain. In particular they define the base domain's null- and not null-bearing type 
name, data class, database type, and conversion methods. 

Patterns. A template used to create the Ada constructs that implement the Ada semantics of a 
domain, subdomain, or derived domain declaration. 

Row record. The Ada record associated with procedures that contain either a fetch, select, or 
insert statement It is used to transmit the database data to or from the client program. 

Row record type. The Ada type of the row record. 

SAME. SQL Ada Module Extensions. 

SAMeDL. SQL Ada Module Description Language. 

Schema module. The SAMeDL notion that corresponds to the SQL SCHEMA. 

SQL. Structured Query Language. 

SQLCODE. See [SQL], Section 7.3. 

Standard Map. The Standard Map is a status map defined in SAMeDL_Standard that has the 
form "status Standard_Map named Is_Found uses boolean is (0 => true, 100 => false);". 
Standard_Map is the status map for fetcli statements that appear in cursor declarations by default. 

Standard post processing. The processing that occurs after the execution of an SQL procedure 
but before control is returned to the calling application. 

Static expression. A value expression that can be evaluated at compile time (i.e., all the 
associated leaves consist solely of literals, constants, or domain parameter references). 

Status map. A partial function that associates an enumeration literal or a raise statement with 
each specified list or range of SQLCODE values. Status maps are used within the abstract 
module to uniformly process the status data for all procedures. 

Target domain. The domain of the object to which an assignment is being made in an 
assignment context. 

Universal constant. A constant whose declaration does not contain a domain reference. 

Value expression. A value expression differs from an SQL value expression in that (1) an 
operand may be a reference to a constant or a domain parameter, and (2) SAMeDL value 
expressions are strongly typed. 


106 


Intermetrics, Inc. 





Appendix F Syntax Summary 

This appendix provides a summary of the syntax for SAMeDL, Productions are ordered 
alphabetically by left-hand nonterminal name. The section number indicates the section where 
the production is given. 

[5.1] 

abstract_module [ context ] 

[ extended ] 

abstract module iAdaJdentifieM is 
authorlxation schema_reference 
{definition} 

{procedure_or_cursor} 
end [ >tdajdentifier_2 ]; 

[5.10] 

alLsetJunction [avg |max| min |sum]((all]value_expression) 

[3.2] 

asjjhrase as i4da_identifier 
[4.1.3] 

bas_dom_ref dom_ref | base_domain_reference 

[4.1.1] 

base_domain_declaration [ extended ] base domain 4dajdentifier_1 

[ (base_domainjparameterjist)) 
is 

patterns 

options 

end [ >Ada_identifier_2 ]; 

[4.1.1.1] 

base_domain_parameter ::= >4da_identifier: datajclass [ := static_expression ] 1 

map :s pos I 

map := image 

[4.1.1] 

base_doniain_parameterJist :;= base_domain_parameter {; base_domain_parameter) 

[3.4] 

base_domain_reference :;= [ module_reference . J Adajdentifier 

[5.11.2] 

between_predicate value_expressibn [ not ] between value_expression and value_expression 

[5.11] 

booleanjactor ;> [ not ] booleanjDrimary 

[5.11] 

boolean_primary :> predicate | (search_condition) 

[5.11] 

booleanjerm :;= booleanjactor | booleanJerm and booleanjactor 


Intermetrics, Inc. 


107 







SAMeDL Language Reference Manual 


[ 4.2.1 J 

check_constraint_definitioncheck (search_condition) 

[5.51 

close.statement close [ ^da_identifier] 

[4.2.11 

column_constraint :> not null 50L_unique_specification | 

SQL_reference_S|}ecification | 

check (search_co‘ndition) 

[4.2.1] 

column_clefinition SQL_column_name [ SQL_data_type ] 

[ SQL_default_clause ] 

I column_constraint ]: domain_reference 

[3.4] 

column_name ::= SOL_identHier 

[3.4] 

coiumn_reference [ table_reference. ] column_name 
[5.3] 

commit_statement :> commit work 
[5.11.1 ] 

comp_op ::> = I o I < I > I <= I >a 
[5.11.1 ] 

comparison_predicate value.expression cofnp_op val_or_subquety 

[3.1] 

compilation.unit :> module { module} 

[4.1.5] 

component ;;= component_name (dblength [ namedjjhrase ] ] 

[4.1.5] 

component.declaration ::= component {, component): domain_reference [ not null ]; 

[4.1.5] 

component_declarations component_declaration {component.dedaration} 

[4.1.5] 

component_name ::= >4da_identifier 

[4.1.4] 

constant.declaration constant 4c/a_identifier (: domain_reference ] 

Is static_expression; 


[3.4] 

constant.reference [ module_reference. ] >tdajdentifier 

[3.2] 

context context_clause {context_clause} 


108 


Intermetrics, Inc. 






r 


Appendix F - Syntax Summary 


I3.2J 

context_clause :> with_clause | with_schema_clause 1 use_clause 

[4.1.1.3] 

converter :> function pattemjist ( 
procedure pattemjist j 
type mark 

[3.3] 

correlation_name ;:= SQL_identifier 

[5.4] 

cursor_declaration [ extended ] cursor 4dajdentifier_1 

[ input_parameterjist ] 

for 

query 

[ SQL_ofder_by_clause ] 

s 

[ Is cursor_procedures 
end [ Afa_identifier_2 ]; ] 


[5.5] 

cursor_delete_statementdelete from table.name 

[ where current of >4da_identifier ] 

[3.4] 

cursor_proc_reference :;= [ cursor_reference. ] Ada_identifier 

[5.5] 

cursor_procedure [ extended ] procedure Ada_identirier_1 

(inputjparameterjist ] 
is 

cursor_statement 
[ status_clause ] 


[5.5] 

cursor_procedures ::= cursor_procedure {cursor_procedure) 

[3.4] 

cursor_reference [ rTX)dule_reference. ] >tdajdentifier 

[5.5] 

cursor_statement open_statement | 

fetch_statement I 

close_statement j 

cursor_update_statement j 
cursor_delete_statement j 
extended_cursor_statement 

[5.5] 

cursor_update_statementupdate table_name 

set sel_item {, set_itenfi ] 

[ where current of 4da_identifier ] 


Intermetrics, Inc. 


109 










SAMeDL Language Rrference Manual 


[4.1.1.11 

data_class integer | 
character j 
fixed I 

fioat I 

enumeration 

[4.1.3] 

database_mapping :> enumeration_associationJist | pos | image 

[4.1.1.3] 

dbmsjyi^ ::= int I 

imeger j 

smaiiint j 

reai j 

doubie precision j 
char j 

character j 

implementation defined 

[4.1] 

definition ::= base_domain_declaration | 

domain_declaration j 

subdomain_declaration j 

constant_declaration j 

record.declaration j 

enumeration_declaration j 

exception.declaration j 

status_map_declaration 

[4.1] 

definitionaLnwdule :> (context ] 

[ extended ] 

definition moduie 4da_identifier_l is 
{definition} . 
end [ 4c/a_identifier_2 ]; 

[5.3] 

delete_statement ::= deiete from table.name 

[ where search_condition ] 


[4.1.1.2] 

derived.domainjpattem derived domain pattern is pattemjist 

end pattern; 


[5.10] 

distinct_set_function [ avg | max | min | sum | count ] (distinct column_reference) 

[4.1.3] 

dom_ref domain_reference | subdomain_reference 
[5.10] 

domain_conversion :> domain_reference (value_expression) 

[4.1.3] 

donnain_declaration domain 4dajdentifier is new bas_dom_ref [ not nuli] 

[ (parameter_associationJist) ]; 


110 


Intermetrics, Inc. 








Appendix F - Syntax Summary 


[3.4] 

domain_parameter_reference clomain_reference.A#a_identifier 
[4.1.1.2] 

domain_pattem domain panem is pattemjist 
end pattern; 

[3.4] 

domain_reference ;:= [ module_reference. ] >4da_identifier 
[4.1.3] 

enumeration association enumerationjiterai s> databasejiteral 
[4.1.3] 

enumeration_associationJist(enumeration_association {, enumeratk>n_association}) 

[4.1.6] 

enumeration_declarationenumeration y4d!a_identifier_1 is (enumerationjiteraijist); 

[4.1.6] 

enumerationJiteralJist::= enumerationjiterai {, enumerationjiterai} 

[3.4] 

enumerationJiteral_reference ::= [ module_reference. ] >4da_identifier 

[3.4] 

enumeration_reference (module_reference. ] ^da_identifier 

[5.11.4] 

escape_claujse escape value_spec 

[4.1.7] 

exception_declaration ::= exception AdaJdertlH'm ; 

[3.4] 

exception_reference (module.reference. J Adajdenfif'm 

[5.11.7] 

exists_predicate :;= exists subquery ' 

[3.7] 

extended_cursor_statement ;:= irrplementation defined 

[3.7] 

extended_query_expression implementation defined 

[3.7] 

extended_query_specification ::= implementation defined 

[3.7] 

extended_schema_element implementation defined 

[3.7] 

extended_statement implementation defined 

[3.7] 

extended Jable_element implementation defined 


Intermetrics, Inc. 


Ill 






SAMeDL Language Reference Ma nual 


[5.10] 

factor [ +1 • ] primary 

[5.5] 

fetch_statement :> fetch [ /Ada_identifier t ] [ into_clause ] 

[3.3] 

from_clause ::= from table_ref {, table_ref} 

[4.1.1.3] 

fundamental :> for not null type name use pattemjist; | 

for null type name use pattemjist; j 

for data class use data_class ; I 

for dbms type use dbmsJype [ pattemjist ]; j 
for conversion from type to type use converter; 

[5.11.3] 

in_predicate ::= value_expression [ not ] in subquery_or_value_specJist 

[5.6] 

input_parameter ::= ^dajdentifier_1 [ named_phrase ]: 

[ In I [ out ] domain_reference [ not null ] 

[5.6] 

inputjDarameterJist ::= (parameter {; parameter}) 

[3.4] 

input_reference ::= [ procedurejeference. ] ^da_identifier | 

[ cursorjproc_reference. ] ^cfajdentifier 

[5.8] 

insert_columnJist ::= insert_column_spectfication {, insert_column_specification} 

[5.8] 

insert_column_specification :> column_name [ named_phrase ] | not null ] 

[5.9] 

insertJrom_clause ::= from intoJrom_body 

[5.3] 

insert_statement_query ::= insert into table_name [ (SQL_insert_columnJist) ] 

query_specification 

[5.3] 

insert_statement_values Insert Irrto table_name ((insert_columnJist) ] 

[ insert Jrom_clause J values [ (insert_valuejist) j 

[5.8] 

insert_value null | 

constant_reference j 

literal j 

column_name j 

domain_parameter_reference 

[5.8] 

insert_valuejist ;;= insert_value {, insert_value } 


112 


Intermetrics, Inc. 






Appendix F - Syntax Summary 


[5.9] 

into_clause Into 6 
[5.91 

into_from_bocly ;:= /Ada_identifier_1 : record_id 1 
iAc/a_identifier_1 I 

: record_icl 

[5.11.4] 

like_predicate :> column_reference [ not ] like pattern {escape_clause ] 

[3.1] 

module ::= definitional_module | schema_module 1 abstract_module 

[3.2] 

module_name ::= ^dajdentifier 

[3.4] 

module_reference ::= 4da_identifier 

[4.1.5] 

namedjphrase :;= named yAdaJdentifier 

[5.11.5] 

null_predicate column_reference ls[ not ] null 

[5.5] 

open_statement ::= open [ 4dajdentifier ] 

[4.1.1.3] 

option :> fundamental | 

for wordjist use pattemjist; | 
for wordjist use predefined ; 


[4.1.1.3] 

options {options} 

[4.1.3] 

parameter_association :;= 4da_iderTtifier => static_expression | 

map => database.mapping | 

enumeration => enumeration_reference j 
scale => static_expression j 

length s> static_expression 


[4.1.3] 

parameter_associationJist ::= parameter_association {, parameter_association} 

[4.1.1.2] 

pattern domain_pattem | 

subdomain_pattem j 
derived_domain_pattem 


[4.1.1.2] 

pattem_element ::= characterJiteral 

[4.1.1.2] 

pattemjist :> pattem_element {pattem_elemerTt} 


Intermetrics, Inc. 


113 






SAMeDL Language Reference Manual 


[5.11.4] 

pattem_stringvalue.spec 

[4.1.1.21 

patterns ;> {pattern} 

[5.11] 

predicate comparison_predicate | 
betweenjsredicate j 

jn_predicate j 

like_predicate j 

nulijsredicate j 

quantified_predicate \ 

exists_predicate 

[5.10] 

primary literal | 

constant_reference j 

domain_parameter_reference j 
column_reference j 

input_reference j 

setJunction_specification j 

domain_conversion | 

(value_expression) 

[5.2] 

procedure_declaration [ extended ] 

procedure ^da_identifier_1 
[ inputjparameterJIst ] 
is 

statement 
[ status.clause ] 


[5.1] 

procedure_or_cursor ::= cur5or_declaration | procedure_declaration 

[3.4] 

procedure_reference ::= [ module_reference . ] A^iajdentifier 
[5.11.6] 

quantified_predicate ::= value_expression comp_op quantifier subquery 
[5.11.6] 

quantifierall | some | any 

[5.4] 

query queiy_expression | extended_query_expression 

[5.4] 

query_expression ::= query_term | 

query_expression union (all j queryjerm 


[4.2.2] 

query_spec query_specification | extended_query_specification 


114 


Intermetrics, Inc. 








Appendix F - Syntax Summary 


[5.41 

query_specification ::= select [ distinct | all ] selectjist 

trom_clause 

[ where search_condttion ] 

[ SQi._group_by_clause ] 

[ having search_condition ] 

[5.41 

queryjerm query_specification | 

(query_expression) 

[4.1.51 

record_declaration record ^da_identifier_1 [ named_phrase 1 Is 

component.declarations 
end [ ^da_identifier_2 ]; 

[5.91 

record_id ::= new >AdaJdentifier_2 | 
record_reference 

[3.41 

record_reference ;:= (module_reference. ] ^da_identifier 
[5.121 

result_expression ::= value_expression | * 

[5.31 

rollback_statement :> rollback work 
[4.21 

schema_element table.definition | 

view_definition I 

SQi._privilege_definition j 
extended_schema_element 

[4.21 

schema_module :;= [ context 1 

[ extended 1 

schema module SOL_identifier_1 Is 
{schema_element} 
end [ SQL_identitier_21; 

[3.21 

schema_name ::= SQL_identifier 
[3.31 

schema_ref ::= schema_name | ^cfajdentifier 
[3.41 

schema_reference ::= schema_name | AdajtierAWm 
[5.11] 

search_condition booleanjerm | search_condition or boolean_term 
[5.71 

selectjist ::= * | select_parameter {, select_parameter} 


Intermetrics, Inc. 


115 



SAMeDL Language Reference Manual 


[5.7] 

select_parameter :> vaiue_expression [ named_phrase ] [ not null ] 

[ dblength [ namecl_phrase ] ] 


[5.3] 

select_statement select [ distinct | all ] selectjist 

[ into_clause ] 
from_dause 

[ where search_condition ] 

[ SQL_jgroup_by_dause ] 

I having search_condition ] 


[5.10] 

set_fundion_specificatjon count (*) | 

distinct_set_fundion j 
all set fundion 


[5.3] 

set_rtem :> column_reference = update_value 

[4.2.1] 

SOL_defauK_clause :> (see [SQL] 6.4) 

[5.3] 

SOiL_group_by_dause ;> group by column_reference {, column_reference} 

[5.3] 

SOLJnsert_columnJist ::= column_name [, oolumn_name} 

[5.4] 

SOL_order_by_dause :;= order by SQL_sort_speciflcation {, SQL_sorl_specification} 
[4.2] 

SOL_privilege_definition ::= (see [SQL] 6.10) 

[4.2.1] 

SO/._reference_specification :;= (see[SQL]6.7) 

[4.2.1] 

SQL_referential_constrainl_definition (see[SQL]6.7) 

[5.4] 

SOL_soit_spedfication ;> Unsignedjntegerjfteral (asc | desc ] | 

column_reference [ asc | desc ] 

[4.2.1] 

SO/._unique_constrajnt_definition ;> (see [SQL] 6.6) 

[4.2.1] 

SOL_unique_specification :> (see [SQL] 6.6) 

[4.1.8] 

sqlcode.assignment static_expresslonJjst s> erHjmerationJiteral | 

static_expression_ljst => raise exception_reference 


116 


Intermetrics, Inc. 





Appendix F - Syntax Summary 


[5.2] 

statement commit_statement | 

delete_statement I 

insert_statement_values j 

insert_statement_query j 

rollback_statement j 

select_statement j 

update_statement I 

extended_statement 

[4.1.4] 

static_expression value_expression 

[4.1.8] 

static_expressionJist ::= static_expression {, static_expression} | 

static_expression.. static, exoression 


[5.13] 

status_clause status status_reference [ named_phrase ] 

[4.1.8] 

status_map_declaration ::= status ^da_identifier_1 

(named_phrase ] 

[ uses target.enumeration ] 

Is (sqlcode_assignment {, sqlcode_assignment); 


[3.4] 

status_reference ::= (module_reference. ] ^da_identifier 
[4.1.3] 

subdomain_declaration :> subdomain ^dajdentrfier Is dom_ref [ not null] 

((parameter_associationJist) ]; 

[4.1.1.2] 

subdomain_pattem ;;= subdomain pattern is pattemjist 

end pattern; 


[3.4] 

subdomain_reference ::= [ module_reference . J ^<^a_fdentifier 
[5.12] 

subquery ;;= (select [ distinct | all ] resuR_expression 
from_clause 

[ where search_condition ] 

[ SOLjgroup_by_clause ] 

[ having search_condition ]) 


[5.11.3] 

subquery_or_value_specJist subquery | (value_spec_list) 

[4.2.1] 

table_constraint_definitjon SQL_unique_constraint_definition | 

SQL_referential_constraint_definition j 
check_constrairTt_definition 


Intermetrics, Inc. 


117 







SAMeDL Language Reference Manual 


14 ^. 1 ] 

table.definition :> [ extended ] table S0Z._iderTtifier_1 Is 

table_element {, table_element} 
end [ SQL_identifier_2 ]; 

14.2.11 

table_elementcolumn_definition | 

table_constraint_definition | 
extended_table_element 


[3.3] 

table_name [ schema_ref. ] SQL_identifier 

[3.3] 

table_ref :> table_name [ [ as ] correlalion_name 1 

[3.4] 

table_reference :> [ schema_reference . ] SOL_identifier 
[4.1.8] 

target_enumeration :> enumeration_reference | boolean 
[5.10] 

termfactor | 

term * factor \ 
term / factor 

[4.1.1.3] 

type ;> dbms | not null | null 

[5.3] 

update.statement "s update table.name 

set set_item {, set_item) 

[ where search_condition} 


[5.3] 

update_value ;> null | value_expression 
[3.2] 

use_clause :> use module_name {, module_name} ; 
[5.11.1 ] 

val_or_subquery value.expression | subquery 
[5.10] 

value.expression ;> term | 

value_expression + term j 
value_expression - term 


[5.11.3] 

value_spec :> input_reference | 

static.expression | 

user 


[5.11.3] 

value_specjist value_spec {, value_spec) 


118 


Intermetrics, Inc. 







Appendix F - Syntax Summary 


[4.2.2] 

view.definition [ extended ] view SOOdentifieM as query_spec 

[ with check option ] 
end [ SQL_identifier_2 ]; 


[3.2] 

with_clause with module_name [ as_phrase ] 

{, module_name [ as_phrase ]}; 


[3.2] 

with_schema_clause with schema schema_name {as_phrase ] 

{, schema_name [ asjphrase ]}; 


[4.1.1.3] 

wordjist :> context clause | 

null value j 

null_bearing assign j 
not_nuil_bearing assign 


Intermetrics, Inc. 


119 










Index 


Index 


A 

Abstract interface 4,45,46,51,52,64,65, 
66 

Abstract module 4,41 
Ada identifier 8 
Ada indicator type 31,43, 51 
AdaNAME 30-31, 50,57-58,59-60,61,67- 
71 

AdaTYPE 29,30,50, 57-58,59-60,61 
Anonymous type 29 
As phrase 11 
Assignment context 16 
Authorization clause 41 

B 

Base domain declaration 5,20-23 
Base domain option 5,20,22-23 
Base domain parameter 5,20,21,22,25 
Base domain pattern 5, 20, 21-22,25,27 
Between predicate 74 

c 

Character set 7 
Close statement 6, 53-57 
Column definition 35-36 
Comment 9 

Commit statement 46-49 
COMPada 38,43,44, 50-51,57 
Comparison predicate 74 
Compilation unit 4,7,11 
Component declaration 30-32 
Concrete interface 4 
Concrete module 4 
Conform 16-17,61 
Constant declaration 5, 28-30 
Context clause 11-12 
Correlation name 12 
Cursor declaration 4,6,49-53 
Cursor delete statement 53-57 
Cursor update statement 53-57 

D 

Data class 5, 8-9,20, 22,25 
Data conversion 23 
Data conversions 38-39 
Database mapping 21, 24,26 
DATACLASS 9, 23, 25, 28, 36, 57, 67-71, 
73, 75 


DBLengAda 38,43,44, 50-51, 57 
DBLngNAME 31, 50, 59-60 
DBMS type 23, 24 
DBMS_TYPE 24, 36, 62 
Default mapping 21 
Default value 20 
Defining location 13 
Definitional module 4, 19 
Delete statement 46-49 
Delimiter 7-8 

DOMAIN 25,29, 36, 57, 61, 67-71,73,75 
Domain conversion 5,67,72 
Domain declaration 5,24-28 

E 

Enumeration association 24,26 
Enumeration declaration 5, 32-33 
Enumeration mapping 38 
Enumeration parameter 20, 26 
Exception 5, 17 
Exception declaration 5, 33 
Exists predicate 75 
Expos^ name 11,12 
Expression assignment 25, 26 
Extension 3, 5-6,17,23,35, 36, 37,41,42, 
49,54 

F 

Fetch statement 6, 53-57 
From clause 12 
Full name 16 
Fundamental option 22 

H 

Hidden name 11,12 

I 

Identifier 8 

Image default mapping 21 
In predicate 74 
Indicator type 62 
INDICname 62 

INDICsql 44,45, 56,57, 58,60 
Input parameter 45,57-58 
Insert column list 47,61-63 
Insert from clause 47, 63-66 
Insert statement 46-49 
Insert value list 47,61-63 
Into clause 47, 54,63-66 
Item 12-13 


Intermetrics, Inc. 


121 






SAMeDL Language Reference Manual 


L 

LENGTH 9,25,26,29, 36,57,67-71 
Length parameter 21,26 
Lexical element 7-9 
Like predicate 74 
Literal 8-9 

M 

Map parameter 20,23,26 
MODE 42,43,44,55, 58 
Module 4,11 

N 

Name prefix 14-15 
Named phrase 30 
NO.DOMAIN 67 
NO_LENGTH 67 
NO_NAME 67 
NO.SCALE 67 
Not null type 22,27 

Not-nuU bearing type not null type names 
are the targets of the function 
AAAdaTYPE 
Null predicate 74 
Null type 3 
Null_VaIue_EiTor 38 

O 

Open statement 6, 53-57 
Optional pattern phrase 22 

P 

Pada 42-44, 54-55 
Parameter association 20,24 
Parameter profile 42-44, 54-55 
Parent parameter 21 
PARMada 42,44, 55, 56, 58 
PARMrow 63 

PARMsql 44,45, 56, 57,58,60,62 
Pos default mapping 21 
Predicate 72-74 
Procedure 4 
Cursor 53-57 
Non-cursor 41-46 
Psql 44, 55-56 

Q 

Quantified predicate 74 
Query specification 49 


R 

Rada 31 

Record declaration 5, 32 
Record declaration. 30 
Reference 12-16 
Reference location 13 
Reserved word 8, 10 
Rollback statement 46-49 
Row record type 45,50, 58, 61, 63 

s 

SAMeDL_Standard 24 
SCALE 9,25,29, 36, 57,67-71 
Scale parameter 21, 26 
Schema module 4, 34-35 
Schema ref 12 
Scope 12 

Search condition 72-74 
Select parameter 47-48, 58-60 
Select statement 46-49 
Select target list 60 
Self parameter 21 
Separator 7 
Set function 66 
Set item 48 
Simple name 8, 14 
SQL identifier 8 
SQL.Char 24 
SQL_Database_Error 5, 17 
SQL_Double_Precision 24 
SQL_Enumeration_As_Char 24 
SQL_Enumeration_As_Int 24 
SQL.Int 24 

SQL_privilege_definition 35 
SQL.Real 24 
SQL_Smallint 24 
SQLCODE 5, 17, 33,44, 55, 56 
Sqlcode assignment 33-34 
SQLNAME 8,62 
SQLsc 73-74 
SQLsq 75 
SQLve 71-72 
Standard base domain 24 
Standard post processing 5, 17 
Standard.Map 34 
Statements 
Cursor 53-57 
Non-cursor 46-49 


122 


Intermetrics, Inc. 




Index 


Static expression 28-30 
Status clause 5,17,45,75-76 
Status map 32 

Status map declaration 17,33-34 
Status mapping 5 
Status parameter 3,17,44,55,76 
Subdomain declaration 24-28 
Subquery 75 

T 

Table definition 35-36 
Table name 12 
Table ref 12 
TYPErow 63 

U 

Universal constant 29 
Update statement 46-49 
Use clause 11 

V 

VALUE 29-30 

Value expression 5,28,66-72 
View de&iition 36-37 
Visible item 12, 16 

W 

With clause 11 
With schema clause 11 


A 

i . 


Intermetrics, Inc. 


123 










