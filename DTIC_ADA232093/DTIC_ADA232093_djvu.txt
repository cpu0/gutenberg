AD-A232 093 



Technical Document 1944 

December 1990 

User’s Guide to an 
Event-Activation Record 
Approach to Simulation 
Modeling in Ada 


H. Mumm 
R. Ollerton 



DTIC"! 

ELECTEf%* 
FEB 2113911 1 

8 " 


Approved for public release; distribution Is unlimited. 


91 2 19 241 




NAVAL OCEAN SYSTEMS CENTER 

San Diego, California 92152-5000 


J. D. FONTANA, CAPT, USN H. R. TALKINGTON, Acting 

Commander Technical Director 


ADMINISTRATIVE INFORMATION 

This report was completed under funding from the Naval Ocean Systems Center for the 
Shared Adaptive Internetworking Project (SAINT) as part of the Communication Block Program. 


The need for an affordable and understandable discrete-event simulation system became 
apparent during earlier work. The current work demonstrated that Ada was not only adequate, but 
was in many ways superior to currently available commercial simulation languages. 


Released by 

M. B. Vineberg, Head 

System Design and Architecture 

Branch 


Under authority of 
K. R. Casey, Head 
Battleforce and Theater 
Communications Division 








CONTENTS 


1.0 INTRODUCTION. 1 

2.0 INSTALLATION . 2 

2.1 Creating the GARS Program Library . 2 

2.2 Creating the GEN Program Library. 3 

3.0 BUILDING AND RUNNING AN EARS SIMULATION . 4 

3.1 Writing a Procedure to Instantiate Package Ev_Gen . 4 

3.2 Compiling and Executing a Procedure That Instantiates Ev_Gen. 7 

3.3 Gas Station Example . 8 

3.3.1 Statement of Problem . 8 

3.3.2 Determining the Events . 8 

3.3.3 Writing the Procedure to Instantiate Package Ev_Gen. 9 

3.3.4 Compiling and Executing the Instantiation Procedure . 9 

3.3.5 Code That Is Generated Automatically . 9 

3.3.6 New Program Units Added by Hand . 16 

3.3.7 Compilation Order. 21 

4.0 USING PACKAGE EV . 22 

4.1 EV Package Specification . 22 

4.1.1 EVENT.REC. 27 

4.1.2 Event Processing Subprograms . 28 

4.1.3 Package Simulation . 28 

4.1.4 General Debugging Subprograms. 28 

4.1.5 Debugger Subprograms. 30 

5.0 LINKED LISTS . 32 

5.1 Lnk . 32 

5.1.1 Lnk Specification. 32 

5.1.2 Lnk Example . 36 

5.2 Lnk_Ai. 40 

5.3 LnkTi. 40 

5.4 link . 40 

5.4.1 link Specification. 40 

5.4.2 link Example. 44 

5.5 link_Ai . 49 

5.6 Link_Ti . 49 

6.0 STATISTICAL PACKAGES . 50 

6.1 Package Rand Specification . 50 

6.2 Package Random_Distribution Specification. 50 

6.3 Package Random Specification . 51 

6.4 Package Rand and Random.Distribution Example . 52 

6.5 Package Ti Specification. 53 

6.6 Package Tf Specification. 54 

6.7 Package Ai Specification. 56 

6.8 Package Af Specification. 58 

iii 













































6.9 Package Ti, Tf, Ai, Af Example. 60 

7.0 HASH TABLES. 65 

7.1 Package Hsh . 65 

7.2 Package Hash. 67 

8.0 BIBLIOGRAPHY. 70 


iv 







1.0 INTRODUCTION 


This document explains how to install and use the Event-Activation Record Approach to 
Simulation Modeling in Ada (EARS) simulation libraries. Version 1.0, that have been developed 
by the Naval Ocean Systems Center (NOSC), Code 854. EARS, Version 1.0, resides on a NOSC 
VAX 8600 named "Otter" and executes using the VAX Ada, Version 2.0, compiler. EARS is a 
discrete-event simulation system that uses an event-activation record approach and has capabilities 
similar to those provided by SIMSCRIPT. All simulations that can be modeled in SIMSCRIPT 
can be modeled using EARS. 

From a set of user-defined event types, EARS automatically generates much of the source 
code for many Ada packages and subprograms that are needed for simulation development. This 
allows a user to quickly start writing an EARS simulation. The user tailors the simulation to his 
or her application by adding Ada source code to the generated program units and by writing 
additional ones. 

EARS packages contain subprograms for scheduling events, manipulating queues, 
calculating statistics, writing reports, debugging, and performing other necessary simulation 
functions. 

This document includes an example of actual EARS simulation as well as examples of 
how to use EARS packages and subprograms. 

Major differences between SIMSCRIPT and EARS include the following: 

1. EARS does not implement processes; rather, events are used for synchronization. 

2. Many constructs built by the SIMSCRIPT compiler must be constructed in EARS by using Ada 
statements. Advantages to using the Ada language rather than SIMSCRIPT include the following: 

a. Ada supports software engineering features (e.g., strong typing, visibility, and generics). 

b. Ada is the DoD standard programming language. 

c. Ada symbolic debuggers greatly reduce debugging times. 

d. Ada compilers are widely available (for many computers from many vendors). 

This document assumes that the EARS user is already familiar with discrete-event 
simulation and knows how to use SIMSCRIPT. The EARS user must be an experienced Ada 
programmer. 


1 


f COP* ) 


Accession For / \ 

NTIS 

DTIfcl 

Unaunt 

Justll 

GRAAI IST 

AB □ 

(unced Q 



Distribution/ 

Availability CvftM 

But 

Avail ant/w 
Speaifcl 






2.0 INSTALLATION 


2.1 CREATING THE EARS PROGRAM LIBRARY 

EARS software is installed on a VAX Ada environment by creating an Ada library and 
then compiling the EARS files into the library. This may be done by executing the command file 
listed below. The EARS program library name, given below, was arbitrarily chosen. 


9aat verify 
$tci craata 


lib [320036.1V] 


• ADA 
TlJ.ADA 
GIT N .ADA 


$aca Mt lib [320036.1V] 
$ada/liat/noopt SZM_.ADA 


$ada/liat/noopt RUAXIONAL . ADA 
$ada/liat/noopt RELATIONAL.ADA 
$ada/liat/noopt FLT_. ADA 
$ada/liat/noopt D2_.ADA 
$ada/llat/noopt DATK_.ADA 
$ada/liat/noopt STAT_.ADA 
$ada/liat/noopt AF_.ADA 
$ada/liat/noopt AI_.ADA 
$ada/liat/noopt " 
$ada/liat/noopt 

$ada/liat/noopt _ 

$ada/liat/noopt BIT_.ADA 
$ada/liat/noopt BIT.ADA 
$ada/liat/noopt HBX_.ADA 
$ada/list/noopt BIX.ADA 
$ada/Hat/noopt I_KAX_.ADA 
$ada/liat/noopt I_HAX. ADA 
$ada/liat/noopt X_MXN_.ADA 
$ada/liat/noopt X KIN.ADA 
Sada/liat/noopt 
$ada/liat/noopt 
9ada/liat/noopt 
$ada/list/noopt 
$ada/liat/noopt 
$ada/liat/noopt 
«ada/liat/noopt LNX_.ADA 
9ada/liat/noopt UK.ADA 
$ada/liat/noopt 
$ada/liat/noopt _ 

$ada/liat/noopt BASH .ADA 
$ada/liat/noopt HASH.ADA 
$ada/liat/noopt HAT_UK. a da 
$ada/list/noopt HSH_.ADA 
9ada/liat/noopt HSH.ADA 
$ada/liat/noopt PROTO_.ADA 
9ada/liat/noopt PROTO.ADA 
$ada/list/noopt EV_. ADA 
Jada/liat/noopt 8V_Q.ADA 
$ada/li^t/noopt SQ_.ADA 
9ada/llat/noopt SQ.ADA 
9ada/liat/noopt DND_.ADA 
Sada/liat/noopt DHD.ADA 
$ada/liat/noopt NTH RANDOM .ADA 
Sada/liat/noopt RAND_.ADA ~ 
$ada/liat/noopt RIAL PARAM .ADA 


1 boa co—aanda to monitor. 

Craataa ada program library 
[320036.1V]. 

Sat to ada program library 
[320036.1V]. 

Coapilaa fila aim_.ada, coapilad coda 
goaa into snt_.LXS fila, and Ada 
idantifiara not optlmiiad away. 


LINK .ADA 
LINK.ADA 
LXNK_AX_.ADA 
LXNK_AX.ADA 
LINK_TI_.ADA 
LINK TX.ADA 


LNX_AI_.ADA 
UK AX.ADA 


continued 







*«<U/liat/noopt XNT VARAN .ASA 
$mda/liat/noopt RANDOM DISTRIBUTION .ADA 
$*da/liat/noopt RANDOM"DISTRIBUTION.ADA 
$ada/liat/noopt RANDOM.ADA 
$ada/liat/noopt RAND.ADA 
$«da/liat/aoopt SIM.ADA 
$ada/liat/noopt SV.ADA 
Sada/liat/noopt AT.ADA 
iada/liit/noept AI.ADA 
$ada/liat/noopt DATS.ADA 
$ada/liat/noopt CRT H.ADA 
Sada/liat/noopt INTJPARAM.ADA 
Sada/liat/noopt RXALPARAM.ADA 
$ada/Ilat/noopt RL_AI.ADA 
Sada/liat/noopt STAX.ADA 
(ada/li*t/oo«pt IT.ADA 
$ada/llat/noopt TI.ADA 
$ada/liat/noopt TLX.ADA 

$aat novarify I Turn off acho to aonitor. 


22 CREATING THE GEN PROGRAM LIBRARY 

The program library GEN, which contains the automatic source code generation software 
for both the EARS and the Simulated Network Architecture Protocol Layer (SNARPL) systems, is 
installed on a VAX Ada environment by executing the command file listed below. The program 
library name, GEN, was arbitrarily chosen. 









3.0 BUILDING AND RUNNING AN EARS SIMULATION 


This chapter describes in detail how to write an EARS simulation. A complete simulation 
example is given. Included is an explanation of (1) how to generate the packages and 
subprograms automatically, (2) the code that is added by hand, and (3) the required inputs and 
outputs. 

3.1 WRITING A PROCEDURE TO INSTANTIATE PACKAGE EV GEN 

The initial step of an EARS simulation is to instantiate the package Ev_Gen, which is in 
the GEN library. The Ev_Gen package specification is listed below. 


with Taxt_IO, AdaJNama, Mama, Vtaa_A am. Data; 
uaa Ta.rt._IO ; 

ganaric 

Sim Mama 
: STRING; 

__| - 

— I Tha flrat part of all flla and coog>ilation unit naaaa 
— j will ba " S IM_NAME" . 

„| - 

typa EVENTS la 

( <> ); 

__|- 

—| Namaa of tha dlffarant typaa of avanta Initially In tha 
— I alnulation. 

„| - 

with procadura Slmplajrila Kama 
( Unit : STRING; ” 

Spacification ; BOOLEAN; 

Fn : out Ada_Hama.Nama_String; 

Spao_Ext : STRING Uaa_Aca.Spac_Bxt; 

BodyJBxt : STRING :» Waa_Aca.BodyJBxt; 

Format : Nama.Strlng_Format :« Nama.Dafault_Caaa) 
la Vtaa_Aca. Sinpla_Fila_Nama; 

— | - 

— I Form a flla nama for a unit apacification or body. 

__| - 

with procadura Fila_Haadar 
( Flla : FilaTypa; 

DaarJNama : STRING; 

Nag : STRING ) la Data.Baadar; 

„| - 

—| If OSERJRAME la not a null atrlng, thla routina la oallad 

— j for aach flla craatad. 

--I - 

procadura Gan 

( Oaar_Nama : STRING 
SpaoJBxt : STRING :- Vms_Aca.Spaojtxt; 

Body_Ext ; STRING Vma_Acs.Body_Ext; 

Format : Nama.String_Format Nama .Dafault_Caaa); 


The use of Ev_Gen will first be discussed in general terms. Ev_Gen is a generic package 
that may be instantiated with four parameters. The first two are required, while the last two can 
accept defaults. The first parameter, Sim_Name, is a string that becomes the first part of the file 


4 







names and program unit names for the source code that is generated automatically. The second 
parameter, EVENTS, is an enumerated type that defines event types required for a specific 
simulation. Note, that the source code for a stop simulation event type will be generated 
automatically. It need not be specified in the enumerated type. 

If Ev_Gen is not instantiated with the two user-provided procedures, Simple_File_Name 
and File.Header, then the default procedures are used. The default procedure Simple_File_Name 
creates VAX/VMS files and should be used when running EARS cm VAX/VMS. The default 
procedure FileJHeader creates a file header. 

An example of a default file header (supplied by package Date) that is created during 
code generation is given below. The user name, date, time, and a brief program unit description 
appear in the header. 


—I - 

—! Alan, MONDAY 19-MAR-1990 14:56.48 
—»Pkg body for Simulation Job Definitions 
--I - 


Two examples of procedures that instantiate Ev_Gen will now be described. The first, 
which is shown below, uses the default Simple_File_Name and File_Header procedures. This 
simulation defines four events: Message_Generation, Start_Slot, Transmit, and Receive (in addition 
to the stop simulation event). The first two characters of the file names and program unit names 
will start with the character string "MV." 


with 

prooadura Gan_Souroa_MV is 

typo Evant_Typa is (Massaga_Ganaration, Start_Slot, 
Transmit, Raoaiva); 

prooadura BV is naw EvjGan (Sia Hama «>"MV”, 

EVENTS »> Evant Typa); 

bag in 

EV(Dsar_Nama -> "Alan"); 
and Gan Sourca MV; 


For the second example, the user first writes the header procedure, SAICJH, which is 
given below. 


— SAIC_H will add standard haadars to all filas. 

with TEXT 10; 
usa TEXT~ZO; 

prooadura SAZC_B (F : fila_typa; 

continued 


5 














bag in 


USERNAME : string; 

MSS : atring) ia 


put_lina (t, "- 

put”lina(£,«— xxxxx 

put~Hna {£, " - 

put_lina (£, " ”) ; 

put~1lna(£,"- 

put_lina(£,"— aimul 

put“lina(£, *— modul 

put_l ina (£, "- 

put_lina it, " "); 

put_lina(f, "- 

put_lina it, "— "); 

put_lina it," - 

put~lln« it, "— aimul 

put_lina it, "— modul 

put_lina (£,"- 

put_lina(f," "); 

put lina it, "- 

put_lina(f,"— "); 
put~lina(£,"— Author: 
put_lina it," — Data: 
put_lina(£,"— Organisation: 


aouun B 7 


aimulation: 
laodul a: 


C DSBR NAME); 
C MSG) 7 


aimulation: 
modula: 


S USER NAME); 
C MSG)7 


put_lina(f,"— "); 
put~lina(£, ”— "); 

putlina(f,”— Daacription: Daar sup 

put lina(£,"— ”); 

put_lina (f, »— NONE") ; 

put~lina (£, "— "); 

put_lina (£, "— ") ; 

put_lina(£,"— Aaaunptiona:"); 

putlina(£,"— 

put_lina(£,"— NONE") ; 

put_lina (f, "— ") ; 

put”lina(£, "— "); 

put_llna(£,"- 

put_llna it," "); 

put_lina it," - 

put_lina(£, "— Ravision Hiatory:"); 
put lina(£,"— Data Author, Org. 

parformed"); 

put_llna (£, "—-- 

put_lina {t ,"— 
put_1 lna {£, " — ") ; 

put_lina(£,"- 

put_lina(£," "); 

and~SAIC H; 


S. Back"); 

3/19/90"); 

SAIC, Bnginaaring Syatama Group, San Diago, CA"), 


Daar atippliad.”); 


Raviaion summary and validation 


The second example of a procedure that instantiated Ev_Gen is given below. In this 
example procedure, Gen_LH instantiates EV_Gen so that (1) file and program unit names created 
will begin with string "LH," (2) there will be code generated for 15 events, and (3) the procedure 
SAIC_H will be used to create the file header. 


















— Kvada file ftniritor for HT Long Haul model. 


with XV_Gen, ada_nase, ni—, vms_acs, data, SAIC H; 
procedure GW LH la 
typa mi TXPt la 

~ (DSS_BCV, DSS_XMZT, DS COONTER, DS RCV, 

DSJOCT, CKHJBDCST, GKH_P2P, RESKtT START_SLOT, 
ihhoui, TONS 1, SOUHD, TUHS 2, HIT call, 
LQAJCCHHG, NKT_ACK, TUHE_3, SIARTJUJJ) ; 
prooadura HV is new IV Can (SlmJHAMB ~ «> "LH", 

IVHHTS -> KVWT_nPE, 

rlla_Haadar -> SAIC_H>; 

bag in 

HV("HT Long Haul"); 
and CW LH; 


The header that is generated in example two is shown below. 



siaailation; Hr Long Haul 

nodule: Fkg Spaa for Siaulation Job Dafinitiona 


__ 


— Author: 

1. Bock 

— Data: 

3/21/90 

— Organisation: 

SAZC, Engineering Systerna Group, San Diago, CA 

— Description: 

Lists constants connecting event typos (jobs) 

— 

a>vt numbers. 

— 

A few widely used data typos are listed. 

— Assumptions: 


HOKE 


— 



Raviaion History: 

Data Author, Org. Raviaion 


ary and validation performed 



3.2 COMPILING AND EXECUTING A PROCEDURE THAT INSTANTIATES Ev Gen 

The commands listed below, which are in a command file, are used to compile, link, and 


7 













execute the procedure GEN_SOURCE_MV. (Refer to the first example above.) 


! S«t program library bo [320032.BV.GEN]. 

$aca sat lib [320032.BV.GEN] 

1 Coopila instantiation procadura. 

$ada/list Gan_Sourca_MV. acia 

$acs link Gan_Sourca_MV < Gan_Sourca_MV is tha nama of 

! procadura that instantiatas 
! packaga XV_Gan. 

$run Gan Sourca MV 


Upon execution, the following files are generated: 


packaga spac MV 
packaga body MV 
procadura apac MV 
procadura body MV 
procadura apac MV 
procadura body MV 
procadura spac MV~ 
procadura body MV 
procadura apac HV~ 
procadura body MV 
procadura spac MV 
procadura body MV 
procadura apac MV~ 
procadura body MV 
procadura apac MV~ 
procadura body MV 


Bp_Stop_Simulation 

Ep_St op_S imu lat i on 

EP_MBSSAGE_GENERATION 

EP_MESSAGE_GENBRATION 

BP STARTSLOT 

EP~START_SLOT 

KPTRANSMIT 

KP_TRANSMIT 

KP_RECBXVB 

EPRECEIVK 

Ep_STOP_SERVICB 

Ep_S TOPSERVICE 

DISPATCHER 

DISPATCHER 


3.3 GAS STATION EXAMPLE 

The use of EARS can best be illustrated by describing in detail a simulation example. The 
example given is the classic gas station model. This example requires the use of EARS packages, 
including EV, RANDOM, statistical packages, and linked list packages. The example illustrates 
the use of the packages and their subprograms. A more detailed explanation of these packages is 
found in subsequent chapters. 

3.3.1 Statement of Problem 

The problem is to develop a gas station simulation where the customers arrive randomly. 
Their interarrival rate is exponentially distributed. The customers queue up to be serviced by 
attendants, receive service, and then leave. The service times are randomly selected from an 
exponential distribution. The purpose of the simulation is to examine the effect of adding 
attendants and changing the mean interarrival time and the mean service time for simulations of 
varying duration. 

3.3.2 Determining the Events 

Before instantiating Ev_Gen, the user must determine the EARS events required for the 
simulation to be developed. These events are defined in the enumerated type Event_Type in the 








package that instantiates EV_Gen. An EARS event is an occurrence that takes place at some point 
in time. An EARS event may be scheduled to occur after a delta time or at a specific time. 

For the gas station problem, only three things are scheduled: the arrival of a customer, the 
time required for service, and the end of the simulation. The names chosen for the event types are 
Customer_Arrival, Stop_Service, and Stop_Simulation. Remember, the Stop_Simulation procedure 
is generated automatically without defining it in Event_Type. 

333 Writing the Procedure to Instantiate Package Ev Gen 

This procedure is given below. EV_Gen is oily instantiated with the two required 
parameters, Sim_Name and Events. The string name for files and program units begins with 
"Hans." Only a Customer_Arrival and Stop_Service event are defined. 


with Kv_&sn; 

procedure C«n_Sourca_GS is 

type CventJType is - (Customar_Arrival, Stop_Service ); 
procedure KV is new Bv Gen (Sin Hasn »>"GS", 

EVENTS -> Bvent_Type); 

begin 

EV(T3ser_Bane »> ’Hens”); 
end Gen Source CS; 


3.3.4 Compiling and Executing the Instantiation Procedure 

A command file that contains the code required to compile, link, and execute the above 
procedure using VAX/VMS is given below. 


t Set program library to [320032.XV.GIN]. 

Sacs set lib [320032.EV.CEN] 
t Create sublibrary [320032.XV.GXN.SUBLZB]. 

t Set to sublibrary 

$ada/liat Gen_Souroe_GS.ada I Compile instantiation procedure 

$ae* link Cen_Souroe~GS ! Gen_Souroe_GS is the name of 

! procedure that instantiates 
! package XV_Gen. 

$run Gen_Souree_GS 

! Upon successful execution of Gen_Source_GS the 
Sacs delete aublib (320032.XV.GXN.sublib] 


33.5 Code That Is Generated Automatically 

The ten program units listed in this section are generated at the completion of the above 
commands. An explanation of each program unit will follow its source code. Each line of code 
that is generated automatically will, for the sake of clarity, have A" added to the right-hand 
side. 


9 






package spec GS 
ptokijs body GS 

prooadura spaa GS_Kp_STOP SIMULATION 
prooadura body CS Kp STOP_SIMULATION 
prooedure spec GS_Kp_CUSTOMKR ARRIVAL 
procedure body CS_Kp~CUSTOMBR~ARRIVAL 
prooadura spaa GS~Kp_STQP_SKRVICK 
procadura body GS_Bp_STOP_S8KVICB 
prooadura spec CS_DISPATCHKR 
prooadura body GS_DISPATCHKR 


3.3.5.1. Automatically Generated Package Specifications 

The only package specification that is generated automatically is Gs. This procedure is 
given below. In this example, only the comments and two lines of Ada code are added by hand. 
The first line added by hand "withs in" package Gs_Dispatcher. The second instantiates the 
generic package Ev.Simulation with Ev.Max_Priority => 1 and Ev.Dispatcher => GS.Dispatcher. 
This means that for the gas station simulation all the events have the same scheduling priority 
and the dispatcher used will be GS.Dispatcher, which is generated automatically. 

The next line of code assigns a value of 1 to Group. Group is a number that is associated 
with a specific simulation. Simulations that may potentially be integrated are assigned consecutive 
group numbers. 

In the next three lines of code, the parameters Stop_Simulation, Customer_Arrival, and 
Stop_Service are defined as constants 0, 1, and 2, respectively. EV.Sim_Job is a unique integer 
that is associated with each type of event. It will be used in the dispatcher body. 

Function Nu returns an event, given an input parameter of type Ev.Sim_Job. The event 
has two discriminants. Function Nu sets the first to the value of Job and the second to the value 
of Group. Section 4 will discuss type Ev.Event in more detail. 


— I -A 

—| Hans, MONDAY 12-MAR-1990 09:16.14 — A 

—»Pkg Spac for Simulation Job Definitions — A 

— I -A 

— A 

with Bv; — A 

with I s_Diapatchar; 

package Gs is — A 

— A 


— KV.Simulation is called with tha following two parameters: 

— 1 represents the number of priorities in the simulation 

— CS_Dispatchar is the name of the dispatcher procedure that is generated 

— automatically by EV_Gen 
package Gs_Simuletion is 

new Xv.Simulation (Max_Priority -> 1, Dispatcher -> Cs_Dispatchar); 

Group — A 

: constant Kv.Sim_Group :• 1; — A 

— Numbers assigned below are values of discriminant KV.Bvent_Rac, which 

— are used in dispatcher. 

continued 


10 







Stop Simulation 

— J 

: constant Zv.Sia Job :• 0; 

— i 

Customer Arrival 

— 1 

: constant Bv.Sia_Job :*■ 1; 

— 1 

Stop Service 

— J 

: constant Sv.Sia_Job :■ 2; 

— 1 

function Nu 

— 1 

( Jab : Zv.Sia Job ) 

— 1 

return Iv.Svent; 

— J 

—| Creates Events for this Event Group 

— 1 

end Os; 

— 1 


3.3.5.2. Automatically Generated Package Bodies 

The only package body generated automatically is Gs. It contains the function body Nu, 
which was described above. The package body Gs appears below. 



3.3.5.3. Automatically Generated Procedure Specifications 

The gas station example has four procedure specifications that are generated automatically. 
Three procedures created are associated with event types. The fourth is the dispatcher. The event 
procedures created are GS_Ep_Customer_Arrival, GS_Ep_Stop_Service, and GS_Ep_Stop- 
Simulation. Each of the three event procedures has one input, Var, that is of type EV.Event. 
Procedure GS_Ep_Customer_Arrival is given below. 


with tv; — A 

procedure OS lp Customer Arrival (Var: lv.Event); — A 

— I - r ~ r ---A 

—I Bans, MONDAY 12-MAR-1990 09:16.16 — A 

—»lvent Procedure for Ivent Type 0 — A 

— I -A 


11 










Procedure GS_Ep_Stop_Service is given below. 


with Ev; 

procedure GS_Ep_Stop_Service (B: Ev.Event); 

— A 

— A 


—| Hans, MONDAY 12-MAR-1990 09:16.17 
—»Event Procedure for Event Type 1 

— A 

— A 





Procedure GS_Ep_Stop_Simulation is given below. 

with Ev; 

procedure GS_Kp_Stop_Simu 1 at i on (Evnt : Ev.Event); 

_ 

A 

A 

i 

—| Bane, MONDAY 12-MAR-1990 09:16.15 

—»Event Procedure to Stop the Simulation at a Specific time — 

A 

A 





The fourth specification, for procedure GS_Dispatcher, also has one input, Evnt, that is of 
type EV.Event. This procedure is given below. 


__| --A 

Hans, MONDAY 19-MAR-1990 14:02.07 — A 

—»Kv*nt Procedure Dispatcher — A 

"I --A 

— A 

with It; -- A 

procedure GS_Dlspatcher (Evnt: Ev.Event); — A 


3.3.5.4. Automatically Generated Procedure Bodies 

The bodies for the four procedures, GS_Ep_CUSTOMER_ ARRIVAL, 
GS_Ep_STOP_SERVICE, GS_Ep_Stop_Simulation, and GS_Dispatcher, are also generated 
automatically. 

First, the event procedures will be discussed. At the top of each procedure the string. 
Name, is defined to contain the name of the procedure. Name is printed in the exception handler 
when an error occurs. 

Each procedure body will now be discussed individually. 

1. Procedure Gs_Ep_Cus to mer_Arrival 

The procedure GS_Ep_Customer_ Arrival is given below. Variables 
Customer_Service_Time, Next_Arrival, and Gs_Xp.Mean_Service_Time are of type SintReal. 
SimReal is the EARS definition of type "float," with 9 decimal digits of accuracy. Following the 
"begin" statement, function Random.Exponential is called with two inputs, the random number 
stream selected, which is 1, and the mean service time, which is the value of 


12 














GS_Xp.Mean_Service_Time. A stream is a source of random numbers. There is a random number 
seed associated with each stream. GS_Xp.Mean_Service_Time is a user input to the package 
specification Gs_Xp. Procedure Random.Exponential returns a random number from an exponential 
distribution whose mean is the value of GS_Xp.Mean_Service_Time. 

The procedure Tf.Assign is used to maintain tallied floating point statistics on 
Service_Time. TF.Assign assigns the value of Customer_Service_Time to the statistical variable 
GS_Xp.St 

Next, there is a "for loop" in which each attendant is checked to see if he is busy. When 
he is not busy, he is set to busy. The start work time for die attendant is set equal to the value 
of the simulation clock, Ev.Clock. Initially it is zero. The procedure Ev.Delta_Schedule has two 
inputs: Customer_Service_Time and an attendant event. When all the attendants are busy, then the 
customer is put into the customer queue, GS_Xp.Customer_Queue. This is accomplished by the 
call to Rl_Ai.Append. Rl_Ai is a package that is an instantiation of linked list package Lnk_Ai 
with type SiraReaL Lnk_Ai appends the member Customer_Service_Time to the end-of-link list 
Gs_Xp.Customer_Queue. Package Lnk_Ai is an EARS linked list package that automatically 
maintains time-dependent statistics on queue length, hi this case, it is the Gs_Xp.Customer_Queue. 

Next, the exponentially distributed random variable Next_Arrival time is selected by 
calling procedure Random.Exponential with the first stream and a mean of 
Gs_Xp.Mean_Interarrival_lime. Finally, Ev.DeltaJSchedule is called to schedule the next arrival. 
TV next arrival is scheduled to occur at time EV. Clock plus Next_Arrival time. 


elth a la; — x 

with Rl_Ai, Rtodoa, Gs_Xp, Ga_Ev, Tf; 

proowkm Cs Bp Customer_Arrival — A 

( Var : EvTxvent ) la “ —A 

: aonatant STRING "GS_Kp_COSTOWKR_AKRIVAL"; — A 


Cuatoaar_Sarvioa_Tlaa 
: Sin.Real; 

■ext_Arr lnl 
: Sia.Real; 

begin — Gs_Bp_Cuatoaar_Arrlval — A 

—| Dataralna Cuatoaar Service tlaa. 

Cuatoner_Service_Tlna :« Random. Fxp orient ial (1, Ga_Xp. Maan_Sarvioa_Tiaa) ; 

Tf.Assign(Gs_Xp. St, Cuatoaar_Sarvloa_Tiaa); 

— I Try to find an idle Attendant 
for This in Ga_Xp.Attendants loop 

If not Gs_Xp.Attendant(Thla).Busy than 
Ga Xp.Attendant(This).Buay :« TRUE; 

Gs~Xp.Attendant(This).Start Jfork Ev.Clock; 

— Tor EV.Delta_Scbedula if - no event and priority are passed 
— as parameters then default is current event and priority. 

■v.Delta_Sohedule( 

Time ■> Custoawr_Serviee_Tima, 

Evnt «> Gs_Ev.Stop_Servioe(This)); 
exit; 

elsif This « Gs_Xp.Attendants'Last then 
— I All Attendants are busy, so customer goes in queue 

Rl_Ai. Append (Gs_Xp.Curtomar_Queue, Customar_Servioe_Time); 

continued 


13 







2. Procedure GsJEp_Stop_Service 


The procedure GS_Ep_Stop_Service is shown below. The first statement following "begin" 
updates the time worked for an attendant. The value of E.Var(0), by convention, is used as an 
identification number. In this example, it represents the attendant ID. (For communications 
network modeling it might represents Node ID.) 

The next statement updates the number of customers served by the attendant. Then the 
function Rl_Ai.Nl checks to see if the number of items in the customer queue is greater than 
zero. When it is, then the Stait_Work variable for the attendant is set equal to current simulati on 
time, Ev.Clock. Procedure Rl_Ai.Pop pulls Customer_Service_Time off the front of the 
Customer_Queue. Next, the procedure Ev.Delta_Schedule schedules the time for service 
completion. When the number of items in the customer queue is zero, the attendant is set to not 
busy. 



14 






Ca_Xp.Attendant(X.Var(O)) .StartJXork Sv.Cloak; 
Rl~Ai.Pop(Gs_Xp.Cuatoaar_Qoeue, Custoe»r_Servloe_Tia», round); 
—T Sobodulo tervlot Ceapletioa 

XT. Pelta_Soh e dule (11 m “> Custoa»r_Serviae Xian, Xvnt “> X); 
•1m ” 

— | Mo outoani, ao not busy 

Ga Xp.Attendant(K.Vax(O)) .Busy :■ False; 

•nd If; 

— Xext lino la rtanwd for alaulatlon 

— ralM Sla.Motjrapleannted; 
exception 

when other* «> 

Kv.Krr_IO("craabod in "Cnaaw); 
ralM;~ 

•nd Ga_Xp_Stop_Servioe; 


3. Procedure GS_Ep_Stop_Simulation 

This procedure, shown below, sets the boolean value Ev.Simulating to "False," which 
causes the simulation to end. 



procedure Ga Xp Stop Slanlatioo 

— A 

( Xvnt : Xv.Event } la 

— A 

Him 

— A 

: ooaaUnt STRING :■ "Ga Xp Stop Siaulation"; 

— A 

U)in — Ga Xp Stop Siaulation 

— A 

Xv.Siaulating rdn; 

— A 

exception — Ga Xp Stop Siaulation 

— A 

when others ■> 

— A 

Xv.Xrr 10("Crashed in " S Rasa); 

— A 

rain; 

— A 

end Gs_Xp_Stop_8iaulation; 

— A 


4. Procedure GS_Dispatcher 

This procedure, given below, is called by procedure Ev.Start with an input parameter that 
is an EV.Event. GS_Dispatcher looks at the value of die discriminant EvntJob and calls the 
appropriate event procedure GS_Ep_Customer_Arrival, GS_Ep_Stop_Service, or 
GSJBpjStopJSimulation. An exception is raised and an error message is printed for invalid values 
of EvntJob. 


with 08; — A 

IN 08: -- A 

with GS_Xp_Cuxtc*nr_Arr lval; — A 

with ; — A 

with et~lp~(t«pjljNlltlw; — A 

procedure GX Dispatcher (Xvnt: iT.lTtut) la — A 

■o_Such_JoE : exception; — A 


continued 


15 











bag in 

ohm ivnt.Job la — A 

•ban CuatoaMr_Aj rival «■> GS_Kp_Cuatooar_Arrival (Bvnt); — A 

vban Stop_Sarvlca ■> GS_Bp_Stop_Sarvloa (Bvnt); — A 

whan Stop_Simulatioo »>~CS~lp_Stop_Simu 1 atioo (Bvnt); — A 

vban othara «> raisa Ho_3uch_Job; ~ — A 

and oasa; — A 

axcaption — A 

•ban Bo Snob Job “> — A 

Bv.Brr_XO ” --A 

("*o_Suoh_Job as”tBV.Sim_Job'image(Bvnt.Job)*" in — A 

GS_Diapatohar“); — A 

~ raisa; — A 

whan otbara »> — A 

raisa; — A 

and CS_Dispatchar; — A 


33.6 New Program Units Added by Hand 
1. Package Gs_Xp Specification and Body 

The package specification Gs_Xp, given below, reads in simulation input data at 
"elaboration" and defines an array of records containing attendant information. 

Function Int_Param is called to get the values for Number Of Attendants, 
Mean_Interarrival_Time, Mean_Service_Time, and Run_Time. Customer Queue is a Lnk_Ai 
linked list whose item is of type Sim.Real. St is a statistical variable for tallied fixed point 
statistics. Attendant is an array of records containing attendant information. The procedure Report 
is called from procedure Gs Station to print out results of the simulation. 


with Sim, IntJParam, RaalJParam, Rl_Ai, Tf; 

package Gm_Xp la 

Huaber_Of_Attandants 
: constant POSITIVE 

:■ Int_Param("ATTENDANTS:"); 

aubtypa ATTENDANTS la 

POSITIVE ranga 1 .. Numbar_Of_Attandanta; 

Mean_Interarrival_Time 

: constant Slm.Raal :■ Raal_Param("KEAN INTERARRXVAL TIME (min):"); 
MaanjServicaJTima 

: constant Slm.Raal :« Raal_Paraa("MEAN SERVICE TIME (min):"); 

Run_Tiaa 
: Slm.Raal 

:- Sim."*"(60.0, Raal_Param("RON_TIMB (hrs):")); 

Custoasr Queue 


continued 










The package body, given below, defines and initializes die Customer_Queue. The 
procedure Report prints out the simulation input parameters and the results. The results include the 
simulation time and customer queue statistics, which are printed from procedure ALReport and 
service time statistics, which are printed from procedure Tf.Report. Next, the percentage of time 
worked and the number of customers served by each attendant are printed. 


with Intagar_Taxt_IO, Taxt_XO, Ai; 
with Bw; 

use Intogwr_Tsxt_I0, Text_IO; 
ptokiga body Om_Xp ia 

CUSTOMER_QUEUE — XHXX is flxaoutad upon elaboration 

: Rl_Ai.List :■ Rl_Ai.Init; 

procedure Report ia 
uaa Sin, Sia.Xo; 

Dalia 

: oonstant STRING :■ 


Tit la 

: constant STRING :■ 

" GAS STATION SIMULATION REPORT"; 


Xndant 


; 

oonatant 

Poaitiva_ 

Count :» 

4; 

Col 

ooostaat 

Positive 

1 

i 

20; 

Ifw 

oonatant 

POSITIVE 

10; 


D£w 

oonatant 

POSITIVE 

3; 


Rfw 

constant 

POSITIVE 

Ifw - 

Dfw - 


continued 


17 










nminmnmminnmnmmnimmnm 


— Report 
Col(Indent); 

“Lino (Dolls); 

Col(Indent); 

"Line (Title); 
jCol(Indent); 

Lino (Dolls); 

Col(Indent); 

"Lino ("INPUT PARAMETERS") ; 

_Col (Indent) ; 

("Attendants"); 

_Col (Col); 

(Number_0£_Attendants, I£w) ; 

_Llno; 

Col(Indent); 

("Keen Interarrival Time"); 

_Col (Col); 

(Mean_Interarrival_Tiae, Rfw, Dfw, 0); 

Line ; 

Col(Indent); 

("Mean Service Time"); 

_Col(Col) ; 

(Mean_Service_Tlme, Rfv, Dfw, 0) ; 

Line ; 

~Col (Indent) ; 

("Son Time"); 

Col(Col ); 

(Run_Time, Rfw, Dfw, 0) ; 

Line; 

_Col(Indent); 

"Line(Delis); 

Col(Indent); 

"Line{"RESULTS"); 

~Col(Indent); 

_ Col(Indent) ; 

("SIMULATION TIME"); 

_Col (Col) ; 

Tbv.C lock, Rfw, Dfw, 0) ; 

_Line; 

Col(Indent); 

"Line("CUSTOMER QUEUE"); 

_Col(Indent); 

Report (Rl_Ai. Var (Cuatomer_Queue)) ; 

Col(Indent); 

“Line("SERVICE TIME"); 

_Col(Indent); 

Report(St); 

Col(Indent); 

"Line(Dells) ; 
for This in Attendants loop 
Set_Col(Indent); 

Put_Llne("Attendant" t INTEGER'Image(This) c ” "); 

8et~Col(Indent); 

Put("Time Worked"); 

Set_Col(Col); 

Put((Attendant(This).Tise_Worked / iv.Clock) * 100.0, Rfw, 2, 
Put("%") ; 

New_Line; 

Set_Col(Indent); 

Put ("CustoeMrs Served") ; 

Set_Col(Col); 

Put(Attendant(This).Customers_Served, Ifw); 

Hew_Line; 
end loop; 

Put_Line(Delis); 

New_Line; 
and Report; 
end 6s_Xp; 


0 ) 


18 







2. Package Gs_Ev Specification and Body 


The package specification GsJEv, given below, defines Stop_Service as an array of events. 
Customer_Arrival and Stop_Simulation are defined as events. 



The package body, below, loops on the number of attendants. Within the loop, 
STOPJSERVICE, indexed for each attendant, is assigned an event The next statement uses the 
procedure EV.Set_Priority to set the scheduling priority of the event record to 1. In this 
simulation, all events have a priority of 1. 

The next statement sets the size of die array of integers pointed to by Stop_Service.VAR 
to 1. The following statement initializes the value of this array to index ID for die attendant. In 
this simulation, only one ID number is needed: the attendant ID. In other simulations, larger 
arrays may be needed to store other ID numbers. 

Following the loop, events are created for Customer_Arrival and Stop_Simulation. Then 
the scheduling priorities for each are set to 1. 


with GS; 

ptolug* body C8 KV ia 
bog in 

for ZD in GS_XP.ATTENDANTS loop 

STOP_SKRVZCB(ZD) GS.NO(GS.STOP_SKRVlcx); — Croat*! eventi 

— for Stop Sorvio*. 

■V.aotjpriority (STOP_SKKVZCK (ID), 1 ) ; — Aaaigne priority 

— of 1 to atop aorvio*. 

8top_8orvioo(ID).VAR now «V.Array_of_int*g*r(0..0); — Sot 

— rang* of VAR. 

Stop Sorvioo(ZD) .Var(0) :«■ ZD; — Aaaign attendant ID to index 
-- ID. 

end loop; — Attendant ID nunbor ia tho 

— only ID have in gaa atation 

— aiaulation. 

Cuatoaar_Arriwal :■ GS.HU(GS.Cuatoawr_Arrival); — Croat*a 
— event! for Cuatoaer_Arrival. 

continued 


19 









Stop_Sinulation :» GS.NU(GS.Stop_Sinulation); — Craataa 

— tvanti for Stop_Slmulation. 

EV.aat_priority (Cuatoaiar_Ar rival,1); — Aaaigna priority of 

— 1 to cuatonar_arrival. 

IV.aat_priority (Stop_al illation, 1); — Aaaigna priority of 

— 1 to atop_aiaulation 

and GS EV; 


3. Procedure GS_Station 

The driver procedure, GS_Station, defines Customer_Generator and Stop_Sim to be events, 
while Arrival is of type SintReal. This procedure is shown below. The procedure begins by 
randomly selecting an exponentially distributed arrival time when using the first stream of random 
numbers and a user-specified mean interarrival time. The next two lines make Customer_Generator 
an event whose discriminants. Job and Group, both have a value of 1. The next two statements 
do the same thing for Stop_Sim. 

Then a customer arrival is scheduled to occur after the delta time Arrival, and simulation 
is scheduled to stop after the delta time Gs_Xp.Run_Time. The next statement starts the 
simulation. Gs.Gs_Simulation.Start is a call to the generic package Ev.Simulation, which contains 
procedure Start. Finally, procedure Gs_Xp.Report prints the simulation inputs and results. 


with Ev; 

with Sin, Randan, Ga, Ga_Kv, Ga_Xp; 

procadura Gs_Station ia 
Cu*tonar_Ganarator 
: Ev.Evant; 

Stop_Sln 

: Kv.Kvant; 

Arrival 

: Sia.Raal; 

bagin — Ca_Station 

Arrival :■ Random.Bxponantial(1, Ga_Xp.Maan_Intararrival_Tima); 

Cuatouar_Ganarator :• Ga.Hu(Ga.Custouar_Arrival); 

Ev.Sat_Priority(Cuatomar_Ganarator, 1); — 

StopSin :■ Ga.Nu(Ga.Stop_Siaulation); 

Ev.SatJPriority(Stop_Sia, 1); 

Ev.Dalta_Schadula(Tian -> Arrival, Evnt -> Cuatooar_Ganarator); 
lv.Dalta_Sohadula(Tlaa *> Ga_Xp.Run_Timn, Evnt “> Stop_Sia); 

Ga .Ga_81aulation. Start; 

Ca_Xp.Raport; 
and Ga Station; 


20 








33.7 Compilation Order 


The compilation order for the gas station problem is given below. 


•da/list 

ada/liat 

ada/liat 

ada/liat 

ada/liat 

ada/liat 

ada/liat 

ada/liat 

ada/liat 

ada/liat 

ada/liat 

ada/liat 

ada/liat 

ada/liat 


ga_diapatohar_.ada 

ga~.ada 

ga.ada 

ga_xp_. ada 

ga_xp.ada 

ga_av_.ada 

ga~av.ada 

gaap_atop__aiaulation_. ada 
gaap~atop~almulation.ada 
ga_ap_ouatoMr_azr lval_. ada 
ga_ap_ouatoawr_arrivalTada 
ga~ap~atop_aarvioa_.ada 
ga_diapatehar.ada 
ga_ap_atop_aarvioa.ada 
ga_atation.ada 


21 







4.0 USING PACKAGE EV 


This section, contains a description of package EV. Ail EARS simulations use data 
structures and subprograms that are defined in package EV. First, the package specification will 
be discussed and shown. Then specific examples will be given that illustrate a use of the more 
complex subprograms. 

4.1 EV PACKAGE SPECIFICATION 

The user should refer to the EV package specification given below when reading this 
section. This specification has been heavily commented. Many details not discussed in the text of 
this section are provided in the comments. The most relevant aspects of this package will be 
described in the sections that follow. 


with Sim, Text_IO, Hex; 
use Sim, Text_IO; 
package Kv ia 

— Tha simulation clock ia initialized to 0. 

Clock 

: Baal :«■ 0.0; 

— Stop_Immadiataly ia an exception that may 

— be usad by tha modalar. It ia not uaad in 

— package KV. Stop_Immediataly and Simulating 

— provide a capability for graceful simulation 

— termination. 

Stop_Immediataly 

; exception; 

Simulating 

: BOOLEAN FALSE; 

— Immediately represents tha "earliest possible" time. 
Immediately 

; constant Baal :<■ Real'First; 

— No_Priorlty_Changa is used in procedures 

— XV.Delta_Schedula and BV.Abs_Schedula to indicate 

— that tha priority does not change. 

No_Priority_Change 

: constant INTEGER :” 0; 

-- The lowest usable priority is 1. 

Lowest_Priorlty 

: constant INTEGER :« INTEGER'Succ(No_Priority_Cbange); 

— The highest priority that a user can specify is 31. 
Highest_Priority 

: constant INTEGER :“ 31; 

— Defines range of scheduling priorities that 

— are used internally in EVADA. 
subtype *VENT_PRIORITY_RANGB is 

NATURAL range No_Priority_Changa .. Highest_Priority; 

— Defines range of scheduling priorities 

— available to the user, 
subtype RVBNT_PRIORITY is 

NATURAL range Lowest_Priority .. Highest Priority; 


continued 







— Definea typa for array of intagera that ia uaad for 

— ZSa in Event Rac. 
typa AmtAX_Or_IKTBCXR ia 

array {HAXDRAXi ranga <>) 
of IHTXGXR; 

— XVXMT_PARAM point* to array of intagera where ID 

— nuabara ara atorad. 
typa EVENT FARAM ia 

aaoaaa ARRAY_Or_INTEGKR; 

— Kvada ia uaad to rapraaant avanta that ara intamal 

— to KVADA. 

Ivada 

: conatant :«* 0; 

— Laat_Group ia tha largaat Group number that a uaar 

— uy uaa. 

Laat_Group 

: a on at ant :■ 31; 

— GROUP_TYPK ia ranga of Group nuabara uaad intarnally 

— in KVADA. 

typa GROUPJTXPK ia 

new INTEGER ranga Kvada .. Laat_Croup; 

— Firat_Oaabla_Group rapraaant# tha firat Croup numbar 

— that a uaar aay uaa. 

I ir st_TJaabla_Cr oup 

: conatant CROUP_TYPK GR00P_TTPK'Suec(Kvada); 

— Sim_Croup ia tha ranga of Group numbara that tha uaar 

— may uaa. 
aubtypa SIM_GRODP ia 

GRQOP_TYPE ranga Firat_Uaable_Group .. GROOPTYPE'Laat; 

— Firat_Job and Laat_Job ara tha minimum and 

— job numbara that a uaar aay uaa. 

Firat_Job 

: conatant :« 0; 

Laat_Job 

: conatant :• 127; 

— SIM JOB ia a typa that apana tha ranga job nuabara. 
typa SIMJOB ia 

nav INTEGER ranga Flrat_Job .. Laat_Job; 

— Control containa avant control information which tha 

— uaar naad not know, 
typa CONTROL ia 

llmitad private; 

— KVKHT_RXC ia tha KVADA avant racord. 

— Tha diacrimlnant Group ia a numbar that allowa tha 

— oorraat diapatchar to ba aalactad for an avant. It ia 

— only uaad for intagrating aimulationa. 

— Tha diaariminant Job ia a numbar that corraaponda to 

— an Xvant typa that tha uaar dafinaa in tha procadura 

— that inatantiataa KV_Gan. Job ia naadad whan aimulationa 

— ara integrated. 

— Var point* to tha array of intagara that ia uaad for 

— atoring ID numbara. 


continued 


23 






— Ctrl ia event control Information that tha uaar naad 
-- not know about, 
typo EVEHT_REC 

( Group : GROUP TYPE; 

Job : SXM_JOB ) la 
racord 

Var : EVENT PARAM; 

Ctrl : CONTROL; 
and racord; 


typa EVENT la 
accaaa EVENT_REC; 


— Bnt la tha eurrantly axacutlng avant. 

— It can ba uaad by procaduraa BV.Dalta_Schedule and 

— EV.Aba Schadula. 

Ent 

: EVENT; 


— Procadura Dalta Schadula acbadulaa an avant to bacoma activa 

— at a aisulatad tlma of currant tlma plua "Tima". Parameter PRI 

— allows tha uaar to change tha priority, 
procadura Dalta Schadula 

( Tlma : Sim.Real; 

Bvnt ; EVENT :« Bnt; 

Pri ; EVENT_PRIORITY_RANGE No_Priority Change ); 


— Procadura Abs_Schedule achadulaa an avant to bacoma activa 

— at an abaolute simulated tlma of "time”. 
procadura Abs_Schedule 

( Time : Sim.Real; 

Bvnt : EVENT Ent; 

Pri : EVBNT_PRI0RITY_RANGE No_Priority_Changa ); 


— Procadura SatJPriorlty changes the priority in Evnt to 
-- Pri. 

procedure Sat Priority 
( Evnt : EVENT; 

Pri : EVENT_PRIORITY_RANCE ); 


— Procadura Remove removes an avant from the ready queue. 

— Dispose ■ true means tha event racord is destroyed. 
procadura Remove 

( Evnt : in out EVENT; 

Dispose : BOOLEAN :■ FALSE ); 


— Function Activation_Time returns tha activation time 

— that an avant is scheduled to occur, 
function Activation Tima 

( Evnt : EVENT ) 
return Real; 


— Function Priority returns tha priority of an event, 
function Priority 
( Evnt : EVENT ) 
return EVBNT_PRIORITY; 


— Package Simulation is called with a maximum number of 

— priorities that the user needs and with tha dispatcher 

— procadura that is generated automatically for tha 

— users simulation, 
generic 


Max_Priority 

: EVENT_PRIORITY; — Tha highest priority required by 
— simulation. 

continued 


24 








with procedure Dispatcher — The diapatohar procedure 

( Ivnt : IVXNT ); — generated by tha uaar instantiation 

— and execution of SVjSan. 

paokaga Simulation ia 

prooadura Start; — Starts tha simulation, 
and Simulation; 

Fora 

: NATURAL 2; 

Aft 

: NATURAL 6; 

*xp 

: NATURAL 0; 

— Function Str, Tima, and Id ara usad for 

— debugging purposas. 

— Function Str raturns tha hex raprasantation of an 

— avant. It is usad for dabugging purposas. 
function str is 

naw Bax (SVKNT); 

— Function Tima convarts tin* from typa Sim.Baal 

— to string, 
function flats 

( f : Sim.Baal ) 
ratura STRING; 

— Function Id convarts Croup and Job to 

— string "[Croup,Job]■. 
function Id 

return STRING; 

—| "[Group,Job]" 

— Procedures Switch_SIO, SIO, Switch_FIO, Create, 

— Close, Flo, and Xrr_I0 below ara also intended 

— for dabugging purposas. Thay may be called with 

— or without tha debugger. A modeler may wish 

— to use tha debugger to change tha valuas 

— of the next four flags by using the "deposit” 

— feature of the VAX debugger. 

— Sio_On a TRUK means output to monitor. 

— Sio_On is examined in prooadura Sio. 

Sio_0n 

: BOO ULAN ;■ FALSE; 

— SloJDalta a TRUK means scheduling occurs in 

— delta time. 

— Sio_Delta a false means scheduling is in 

— absolute time. 

Sio Delta 

: BOOLEAN TRUK; 

— Sio_Time is scheduling time for procedure Switch_Sio. 

Sio_Zime 

: Sim.Baal; 

— The scheduling priority for Switch Sio is sat to 1. 

Sio Pri 

: KVKMT_PRIORITY 

KVKWT_PRIORITY'First; 

— Prooadura Switch_Sio specifies tha time at which 


continued 


25 





procedure SZO is effective or ineffective. 
procadura Switch_Sio 

( Tine : Sim.Real Sio Tins; 

Pri : EVENT PRIORITY Slo_Pri; 

DaIts Sio : BOOLEAN Sio_Dalta; 

On : BOOLEAN :« sio_On ); 

— Hhan Sio_On is trua procadura Sio print out 

— Clock, Croup, Job, and string to monitor, 
procadura Sio 

( Str : STRING; 

Sol : BOOLEAN TROK ); 

— Fio_On - TROK nans output to fila. 

PiojOn 

: BOOLEAN :« FALSE; 

— FioJDalts > TROK nans scheduling occurs in 

— daIts tins. 

— Fio_Delta a FALSE moans scheduling is in 

— absolute time. 

Fio Delta 

: BOOLEAN ;a TRUE; 

— Pio_Tima is sceduling time for procedure Switch FIO. 

Fio_Tima 

: Sin.Real; 

— Scheduling priority for Switeh_FIO is set to 1. 

Fio_Pri 

: EVSNT PRIORITY 

: • EVKNT_PRIORITY'First; 

— Procedure Switch_Fio works like Switeh_Sio, 

— except that output is to a file. 

-- (The file is nasnd in a string that is input 

— to procedure Create below.) 
procedure SwitchJFio 

( Tima : Sim.Real :« Fio Tima; 

Pri : KVENTPRIORITY FioJPri; 

Delta_FIO ; BOOLEAN ;a FioJDelta; 

On : BOOLEAN Fio_On ); 

F 

: File_Type; 

— Procedure Create uses Text_IO.Create 

— to create F with fila_name ■ Fn, 

— mode out_file. 
procedure Create 

( Fn : STRING ); 

— Procedure Close uses Text_IO.Close 

— to close F. 
procedure Close; 

— Nhan PiojOn is true procedure Fio writes 

— out Clock, Croup, and string to Fn, which is 
-- is input to procedure Create. 

procedure Fio 
( Str : STRING; 

Eol : BOOLEAN TRUE; 

File : Flle_Type F ); 

continued 


26 








— Prooedur* Err_XO writ** Data and Tima, 

— Str (Sot), ID, Clock, and Massage. 

— 9b* input, Mag, la any ua*r defined string, 

— auch aa "Crashing in procadur* «m*. 
prooaduxa lrr_IO 

( Mag : STRING "" ); 

— Bayood tbia point ar* Implementation dataila 

— that ar* not of eoooarn to tha uaar. 

— Private portion of spacification dalatad in 

— thia dooumentation. 

typ* CONTROL ia 
record 

Activation Tin* : Real; 

Priority : SVSNT PRIORITY; 

Quauad : BOOLEAN FALSE; 

Next : Event :■ null; 

Prav : Event :■ null; 
and record; 

Bk_Tlme — Sea D*lta_Bk and Aba_Bk below. 

: Sin.Real; 

BkJPri — Saa DaltaJBk and Aba_Bk below. 

7 Ev*nt_Priority :■ 1; 

— Tha naxt tbraa procaduraa are uaad with a debugger. 

— Procedure Breakpoint ia a null procedure that ia 

— intended to be uaad to get to command nod* in a 

— ayebolic debugger, 
procedure Breakpoint; 

— Procadur* DaltaJBk call* EV.D*lta_Scb*dula uaing 

— tha parameters BK_Tina, Break JBv, and Bk_Pri 

— which are defined above. The value* for thea* 

— parsanter* are defined using the debugger, 
procedure D*lta_Bk; 

-- Considers Bk_Tin* a Delta tine and schedules procedure 

— "Breakpoint” to occur when Clock " How + Bk_Tian, at 

— priority » Bk_Pri. 

— Procedure AbsJBk calls EV.Aba_Sehedul* and is 

— used in the a ass* manner aa Delta_Bk. 
procedure Abs_Bk; 

end Ev; 


4.1.1 EVENTREC 

The EARS event record, EVENT_REC, contains scheduling and other information that is 
associated with an event. EVENT_REC contains the discriminants Group and Job. The intent of 
the discriminants is to allow different simulations to be integrated. Group is a number that is 
associated with a simulation. Simulations that may potentially be integrated should be assigned 
different Group numbers. A user may assign a Group number from 1 to 127. The Job number is 
associated with the event types that are defined in the EV_Gen instantiation procedure. Job 
numbers range from 1 to 31. Section 3.3.S illustrates the assignment of Job and Group. 


The parameter Var points to an array of integers that contains identification numbers. For 


27 






example, in the gas station simulation, there was an array of (me number that contained an 
attendant ID. Whereas, for a communication network simulation, the array may contain node IDs. 
The Ctrl parameter contains information, such as scheduling activation time, that the user need not 
be concerned about. 

4.1.2 Event Processing Subprograms 

The subprograms that relate to the processing of events are listed below. The package 
specification provides the details needed for calling them. Procedures Delta_Schedule and 
Abs_Schedule allow events to be scheduled to occur in a delta time and at an absolute time. The 
scheduling priority may be set in the calls to Procedure Delta_Schedule, Abs_Schedule, and 
Set_Priority. Procedure Remove is used to remove an event from the event queue and to 
optionally destroy it. Function Activation_Time and Priority return the event activation time and 
priority. 



In EARS, priorities are used to break ties when more than one event is scheduled at the 
same time. The event with the highest priority is scheduled first. 

4.1.3 Package Simulation 

The user must instantiate the generic package Simulation with Max_Priority, the maximum 
number of scheduling priorities needed in a simulation (permissible values are 1 to 31), and the 
dispatcher procedure that was generated automatically. The example below illustrates how to 
instantiate this package with 18 scheduling priorities and the dispatcher procedure LH_Dispatcher. 


package LH_Simulation ia 

new Kv.Simulation (MaxJPriority “> 18, 

Dispatcher »> LH_Dispatchar); 


4.1.4 General Debugging Subprograms 

The subprograms listed below are intended for debugging purposes either with or without 
a debugger. The comments in the EV package specification explain their use. 


28 











1. SwitchjSio, Sio Example 

The example below illustrates the use of Switch_Sio and Sio. These procedures are used 
to examine a sequence of events. The call to Switch_SIO schedules an event to occur in a delta 
simulation time 20 with a priority of 1. The On flag is set to "true" when this event occurs. This 
tells procedure Sio to print. 


XV.Switch SIO(Tim* -> 20, Pri -> 1, On -> fcrua); 


The Sio call, below, is placed in an event procedure whose timing is being examined. The 
statement prints the user defined string followed by Clock, Group, and Job. The printing only 
happens when the On flag is set to "true." 


XV.Sio(Str ■> "Transmit for Hoda xx"); 


2. Switch_Fio, Fio Example 

The following set of statements illustrates the use of Create, Switch_Fio, Fio, Create, and 
Close. This set of statements is provided to examine a sequence of events and to print relevant 
information to a file. First, the output file must be created with the statement 


XV. Croat* (Pn -> «LB_*o*t_Fllo"); 


The call to Switch_FIO schedules an event to occur in absolute simulation time 3 with a 
priority of 2. The On flag is set to true when this event occurs. This tells Fio to print. 


KV.Switoh_Pio(TiM -> 3, Pri «> 2, DoltaJTio -> falao. 
On "> truo); 


29 















The statement below is placed in the relevant event procedure. The user-defined string, 
followed by Clock, Group, and Job, is printed to the output file. Printing only begins when the 
Switch_Fio On flag is set to "true." 


IV.Flo(Str *> "Transmit for Nod* yy"); 


The next statement causes the printing to be disabled at absolute simulation time 1. 


KV.Switch_FIO(Xla* -> 1, Delta Flo -> falsa. On -> false); 


Finally the file is closed with 


KV.Close; 


4.1.5 Debugger Subprograms 

The procedures and declarations listed below are designed for use with a debugger. 


Bk_Tiatt : Sla.Real; 

Bk Prl : leantJPrlority; 
procedure Breakpoint; 
procedure Dalta_Bk; 
procedure AbaJBk; 
Break_le : leant; 

Break Job : 81a Job; 


These procedures allow a user to reduce execution time when running a simulation with 
the debugger. Sometimes a simulation may run for 8 or 10 hours before a breakpoint is reached. 
Using these routines can substantially reduce this time. 

Their use can best be illustrated with an example. Consider the following scenario: 
Assume that something unexpected occurred at 150.0 seconds into the simulation after procedure 
X has executed more than 1000 times. 

Without the aforementioned procedures, the user typically decides to track down the 
problem by setting a breakpoint to occur at procedure X at time 150.0. This means that every 
time procedure X is called, the debugger stops and the value of the simulation clock is checked 
Doing this increases the execution time by orders of magnitude over the time needed to reach that 
point in the simulation when not using the debugger. 

The user takes advantage of the breakpoint capability (in VAX/VMS) by executing the 
following commands inside the debugger: 


30 













DBC> Mt aodula >v 
DBC> dapoait Ir.lk Tiaa ■ 149.999 
— Sat tXaa to braak 
DBC> oat braak Iv.Braakpoint 

— Toll daboggar to braak bara 
DBC> oall AbaBk 

— Sobadulaa Kv.Braakpoint at 
— abaoluta tiaa - 149.999 

DB6> go 


The debugger does no checking at all until procedure Ev.Breakpoint occurs at a simulation 
time of 149.999. When it is reached, the debug prompt is displayed and the user then enters the 
following: 


DB6> sat braak X 
DBC> go 


Again, the debugger does no checking until procedure X is called. The debugger then 
stops and gives the debug prompt Execution speed under this scenario is not noticeably slower 
than running the same program in the debugger with no breakpoints set 

The user who wishes to take advantage of this capability using a compiler other than 
VAX Ada should be aware that the compiler must provide adequate support for run-time symbolic 
debugging. This includes support for the equivalent of the VMS debugger "call," "deposit," and 
"set break" commands. 


31 









5.0 LINKED LISTS 


EARS contains six linked list packages: Lnk, Lnk_AI, Lnk_TT, Link, Link_Ai, and 
Link_Ti. The linked list packages whose name begins with "Lnk” allow a user to store a copy of 
an object in a linked list or to retrieve a copy of an object from a linked list These packages are 
instantiated with one generic parameter, that is of type ITEM. These packages do not support 
generic parameters that are of a limited private type. 

The packages whose names begin with "Link" use an access type. This allows a user to 
manipulate objects in a linked list by pointing at them. These packages are instantiated with two 
parameters. One is of type REC, which is the designated type of the access type ITEM, and the 
other is of the access type ITEM. Rec can be a limited private type. 

The linked list package names ending in "Ti" are used when the user wants to keep 
statistics on queue length that are not related to time. "Ti" refers to the SIMCRIPT tallied integer 
type.* Package names ending in "Ai" are used for maintaining time-dependent statistics on queue 
length, such as average buffer length. "Ai" refers to the SIMSCRIPT accumulated integer type.* 

The specifications for Lnk and Link will be given with examples showing how to use 
them. The specifications for the remaining linked list packages are very similar to Lnk and Link 
and so is their use. Each linked list package will be described. 

5.1 Lnk 

Lnk provides subprograms that allow a user to store and retrieve copies of objects in a 
linked list. 

5.1.1 Lnk Specification 

The Lnk package specification is given below with detailed comments that explain how to 
use the subprograms. The user should review this specification. 


— I Instantiate "LNK" with an object of type "ITEM". 

—j UK defines an ordered linked list of type "LIST". 

—| The ordering of the list is determined by the type of 
—| operation used to insert Members into the list: 


ORDERING 

FIFO 

LIFO 

BIFO 


OPERATION 

Append 

Push 

Instantiation of "Incl" 


with Sim; 

generic 

type ITEM is 
private; 

package Lnk is 


continued 


*CACI, Inc. 1983. SIMSCRIPT II _5 Programming Language. Los Angeles, CA. 


32 










type LIST is 
print*; 

function Hi 

( Lat : LIST ) 
return NATURAL; 

"I - 

— | Ratumi th* number of items In the list. 

— I - 

function Init 
return LIST; 

__| - 

—| Returns an initialized list. 

— I This create a new linked list that contains 0 items. 

— I - 

procedure Duqp 

( Let : in out LIST ); 

— I - 

— I Dump removes all Items from a list. 

— I - 

procedure Dispose 

( Lat : in out LIST ); 

— I - 

— | Dtag> and Deallocate resources. 

"I - 

procedure Traverse 
( Lat : in out LIST; 

Kbr : out ITEM; 
round : out BOOLKAH; 

Dr : Sim.Dir :■ Sim.Normal ); 

— I - 

—| Initialises a list traversal according to the DR 

— j parameter. Tor nonempty lists, if "DR-Normal" then 
—| the front element of "Let" is returned in "Mbr" and 

— I successive calls to "Next" and "Delete" return 

—| elements successively closer to the back of "Lat”. 

—j If "DR-opposite", then the back element of "Lat" is 
—| returned in "Mbr" and successive calls to "Next" and 
—j "Delete" return elements successively aloser to the 
—| front of "Lst". 

--I 

— I If "Lst" is empty then the value returned in Mbr is 
—j "null" and the value of "Found" is false. 

— I - 

procedure Next 

( Lst : in out LIST; 

Mbr : out ITEM; 
round ; out BOOLEAN ); 


—| "Next" may only be called after "Traverse”, "Next" 

—j or "Delete". A call to "Next" after a call to any 

— I other list operation is considered erroneous and may 
—j cause unanticipated results. For nonempty lists, 

— I "Next" returns a member, but does not remove it from 
--I the "Lst". 


procedure Delete 

( Lst : in out LIST; 

Mbr : out ITSM; 

round : out BOOLKAH >,- continued 


33 



















— I "Delate" uy only be callad after "Travaraa", "Next" 
—j or "Delete". A call to "Delate" aftar a call to any 
—i othar Hat operation ia considered arronaoua and nay 

— I causa unanticipated reaulta. Tor nonempty lists, 

—j 'Delete” returns a member "Mbr", and deletes from 

— I the list the neaber returned in the previous call to 
—I 'Traverse', 'Next' or "Delete”. For example, 

—j consider the following sequence: 

—j Traverse (L,H,F, Normal); 

— | Next (L,M, F) ; 

— I Delete (L,M,F); 

—j The Call to 'Delete' would have deleted the member 

—j returned from the call to "Next”. 


procedure Insert 

( Let : in out LIST; 
Mbr : ITEM ); 


— I 'Insert' operates relative to "Traverse", "Next”, 

— I and 'Delete'. If the direction is Normal, then 
—j "Insert" inserts "Mbr" just before (i.e., toward 

— I the front) the member returned from the last call 
—j to "Traverse", "Next", or "Delete". If the 

— I direction is Opposite than'Insert" inserts "Mbr" 
—j just after (i.e., toward the back) the member 

— I returned from the last call to "Traverse", "Next”, 
—j or "Delete". 


procedure Push 

( Let : in out LIST; 
Mbr : ITEM ); 


— I LIFO Queueing Discipline 


—| Procedure 'Push' inserts a member at the front of 

— I a list. It is equivalent to 'Traverse, Insert' 

— I with a direction of "Normal". 


procedure Append 

( Lat : in out LIST; 
Mbr : ITEM ); 


— I FIFO Queueing Discipline 


—| Procedure "Append" Inserts a member at the Back of 

— I a List. It is equivalent to "Traverse, Insert" 

— I with a direction of "Opposite". 


procedure Pop 

( Let : in out LIST; 

Mbr : out ITEM; 

Found : out BOOLEAN ); 


— I For nonespty lists. Pop deletes and returns the 
—| front member of a list. If empty, it returns false 
—j in "found". 


procedure Remove 

( Let : in out LIST; 
Mbr : ITEM ); 


— I Procedure Remove searches for Mbr in the list. If 


continued 


















— I it la found, it delataa it from tha Xiat. 


generia 

typa ONKNONN ia 
privata; 


— I Paakaga aaaroh uaaa a uaar providad function that 

— I dafinaa tha aatoh. for axaa^la, tha atteh nay 
—| ba on ona alamant in a racord. 


with function Match 
( Onk : ONKNONN; 
Mar : ITEM ) 
return BOOLEAN; 
paakaga Search ia 


— I Procedure Find begina at tha atart of Lat to 

—j aaaroh for Mbr that natchaa Onk. On a hit, Mbr ia 
—t returned and Found ia aat to true. Oaar providad 

— I natch function doe tha matching. Procedure Find 

— I alwaya returns firat Mbr found. 


procedure Find 

( Lat : in out LIST; 

Onk : ONKNONN; 

Mbr : out ITEM; 

Found : out BOOLEAN ); 


—I Procedure Find_Haxt worka like Find hut ia uaad 

— I for aubaaguant calla to return next occurrences of 

— | ONK. 


procedure Flnd_Naxt 
( Lat : in out LIST; 

Onk : ONKNONN; 

Mbr : out ITEM; 

Found : out BOOLEAN ); 


—| Procedure Remove starts at front of Lat and 

— I raaovas lat occurrence of Onk for which there is a 

— I natch, aa defined in uses, provided natch function. 


procedure Remove 

( Lat : in out LIST; 

Onk : ONKNONN; 

Mar : out ITEM; 

Removed ; out BOOLEAN ); 
end Search; 

generic 

with function "O" 

( Xtm, Mar : ITEM ) 
return BOOUAN is O; 
procedure Inal 

( Lat : in out LIST; 

Xtm : ITEM ); 

__| - 

— I Searches from back to front. Mbr when Its O Mbr, Xtm 


continued 

















— I ia Inaartad on the Rva aid* of Nbr. 


P a a a ad_Knd_0 f_Liat, Uninitialized_Liat 
: ax caption; 

— Privata portion of apacification delated in thia 

— documentation. 

end Lnk; 


5.1.2 Lnk Example 

The use of all subprograms that are defined in package Lnk is illustrated in the example 

below. 


with Sim; 
with Lnk; 
with Text_IO; 
procedure Teat_Lnk ia 

type TBST_NUMBER_TYPE ia 
( ONE, TWO ) ; 

package Bnum_IO ia 

new Text_IO.Er.umaration_IO (TEST_NUMBKR_TYPE) ; 

type VALARRAY ia 
array (1 .. 10) 

of INTEGER; 

type T_RBC ia 
record 

Received : BOOLEAN; 

Triea : NATURAL; 

Del : FLOAT; 
end record; 

package T_Pack ia 
new Lnk (TJBEC); 

package I_Pack ia 
new Lnk (INTEGER); 

T_Llat 

: T_Pack.Liat; 

Mbr 

: T_RKC; 

— Initialize membera that are of type 
— T_Rec. 

Hbrl 

: T_RBC :■ (Falae, 1, 1.0); 

Mbr2 

: T_RKC (TRUE, 2, 2.0); 

continued 


36 










Mbr3 


; T 

REC 

(False, 

3, 

3.0) 

Mbr4 

: TJREC 

(TRUE, 

4, 

4.0); 

Mbr5 
: T 

REC 

(TRUE, 

5, 

5.0); 

MbrS 
: T 

REC 

(TRUE, 

6 , 

fi.O); 

Mbr7 
: T 

REC :» 

(TRUE, 

7, 

7.0); 

KbrS 
; T 

REC :» 

(TRUE, 

8, 

8.0); 


IJList 

: I Pack.List; 


L 

: INTEGER; 

— Initialise members that ara of type 
— integer. 


LI 

: INTEGER 1; 
L2 

: INTEGER :■ 2; 


L3 

: INTEGER 3; 

L4 

: INTEGER :« 4; 


End 

: BOOLEAN; 

Removed 

: BOOLEAN; 


Test Numb 

: TEST NUMBER TYPE; 


No_Of_Items 
: NATURAL; 


Unk 

: INTEGER; 


— Function below used for generic function MATCH in 

— package SEARCH. 

— Khan N and M match function A returns true. 

function A 

( N : INTEGER; 

M : INTEGER ) 
return BOOLEAN is 
begin — A 

if N - M than 


continued 


37 









ritum TRUE; 

•1m 

return Falaa; 

•nd if; 

•od A; 

package S_Pack la 

new I_Pack.Search (INTEGER, A); 

— Function below la imported for ganaric 

— function "<■” which la uaad with procedure INC. 

function Leaa_Important 
( L ; INTEGER; 

R : INTEGER ) 
return BOOLEAN ia 
begin — Laaa Important 
if L > R than 
return TRUE; 

•laa 

return Falaa; 
and if; 

and Leaa_Important ; 

procedure Include ia 

naw I_Pack.Incl (Laaa_Important); 


begin — TaatLnk 

Taxt_IO.Put("Enter teat number >"); 

KnumlO.Get(Teat_Numb); 
caae Taat_Numb ia 
whan ONE -> 

— Znit initialize* the linked Hat whoaa mambara 
-- are T_Raca. 

T_Liat T_Pack.Init; 

— Next line poaitiona to front 

— of T_Liat. It ia an empty 

— linked liat ao Mbr ia null and 
— Fnd ia falaa. 

T_Paek.Travaraa(T_Liat, Mbr, Fnd); 

— Next line inaarta Kbrl in 

— in T_Liat. 

TJPack.Inaart(T_Llat, Mbr1); 

— Next two linaa inaart Mbr2 

— in front of Mbrl and then 
— Mbr3 in front of Mbr2. 

TJPack.Inaart(T_Liat, Mbr2); 

TJPack.Inaart(T_Liat, Mbr3); 

— Next two linaa inaart Mbr4 

— at and of liat and than 
— Mbr5 after Mbr4. 

T_Pack.Appand(T_Liat, Mbr4); 

TJPack.Append(T~Liat, Mbr5); 

— Next line remove* Mbrl from liat. 

T_Pack.Remove(T_Liat, Mbrl); 

— Number of item* in liat ia 4. 

Ho_Of_Itama :“ T_Pack.Nl(T_Liat); 

— The order of T Liat now ia: 

Mbr 3 
Mbr2 
Mbr4 
Mbr5 


continued 


38 





— Duap claara all nanbara from Hat. 

T_Pack.Dunp(T List); 

-- Numbar of Ttaau in Hat la 0. 

■o_Of_Xtaaa T_Pack.Hl(*_Liat); 

— Hast four atatamanta lnaart nanbara ao In 

— aaquantial ordar in llat. 

X_Pack.Puah{T_Liat, Hbr2); 

T_Paek.Puah(T_Liat, Mbrl); 

T_Pack.Appand(T_Llat, Mbr3); 
T_Pack.Appand(T_Liat, Mbr4); 

— Hart atatanant poaltlona to and of Hat. 
T_Pack.Travaraa(S_Liat, Mbr, Fnd, Sia.Oppoaita); 
— Mova to aacond~naabar from and, Mbr3. 

T_Pack.Mart(Z_Llat, Mbr, Fnd); 

— Da lata Mbr3 from Hat. 

T_Pack.Dalata(T_Liat, Mbr, Fnd); 

— Ramova front mambar from Hat. 

— Front aambar la Mbrl. 

T_Pack.Pop(T_Liat, Mbr, Fnd); 

— Ho_of_Itama balow la two. 

No_Of_Xtama :» T_Pack.Hl(T_Liat); 

— Diapoaa claara Hat and daallocataa 

— raaourcaa. 

T_Pack.Diapoaa(T_Liat); 
whan TWO <•> 

— Xnit initialisaa tha linkad Hat whoaa mambara 
— ara of typa intagar. 

I_Liat l_Pack.Init; 

-- Ho_of_Ztama in Hat la 0. 

No_Of_Itama I_Pack.Nl(I_Liat); 

I_Pack.Puah(I_Llat, L4) ; 

I Pack.Puah(I Llat, L3); 

IJPack.Puah(I~Llat, LI); 

— Mart atatanant atarta at and of I_Liet and 

— lnaarta L2 in front of firat aaabar of 
— Hat that it ia laaa than. 

Xncluda(X_Liat, L2); 

— Aftar IHCLUDK tha Hat ia or da rad; 

LI 

L2 

L3 

L4 

— Find aaarchaa I_Liat from front for firat 
— Mbr that matchaa ONK. Match ia daflnad in 

— uaar providad function A abova. 

Onk :■> 3; 

S_Pack .Find(I_Liat, Onk, L, Fnd) ; 

-- Tha valua raturaad abova for L ia 3 and 
— Fnd ia trua. 

— Mart atatanant aaarchaa for naxt natch. 

— In thia caaa thara ara non* and Fnd la falaa. 
S_Paak.Find_Naxt(X_Liat, Dnk, L, Fnd); 

-- Mart atatanant ranovaa nanbar 

— that matchaa DNK. Again natch ia dafinad in 

— uaar providad function A. 

— Valuaa raturnad in L and raaovad ara 3 and 

— trua raapactivaly. 

SJPack.Raaova(X_Liat, Dnk, L, Raaovad); 

and caaa; 
and Taat Lnk; 


39 









5.2 Lnk Ai 


Package Lnk_Ai closely resembles package Lnk. In addition to containing the same 
subprograms as Lnk, package Lnk_A offers several additional capabilities. For example, Lnk_A 
maintains accumulated integer statistics on queue length and provides a method for identifying 
variables that may be graphed. The graphing capability has not yet been implemented. The 
accumulated integer statistics on queue length are maintained automatically. To examine the 
variable of statistics associated with a list, LIST, the user calls the function Var. The specification 
for Var is 


function Var 
(Lat : LIST ) 
raturn M. Variable; 


The statistics variable, Ai.Variable, is explained in Section 6.7. 

The discriminant in the type statement, shown below, is a sequence number that identifies 
the variable that might be graphed. The sequence number is incremented when the variable is 
declared. 


typa LIST 

(Saq :NATURAL Stat.Saq(Stat.Ai) ia 

private; 


53 Lnk Ti 

Package Lnk_Ti provides a capability for (1) storing and retrieving a copy of an object in 
a linked list and (2) maintaining integer statistics on queue length. 

5.4 Link 

Package Link provides a capability for storing and retrieving objects in a linked list when 
using an access type. 

5.4.1 Link Specification 

The package specification for Link is given, with comments, below. 


— I Instantiate "LINK" with an object "Roc" and ita access 

— j type "ITKM". LINK defines "LIST", an ordered linked 

— I list. The ordering of the list is determined by the 
—| type of operation used to insert Heabers into the 

continued 


40 














continued 



















— I "null” and the value of "Found" la falaa. 


procedure Next 

( Let : In out LIST; 

Mbr : out ITEM; 

Found : out BOOLEAN ); 


— I "Next" may be called after "Traversal", "Next" or 

— I "Delete". A call to "Next" after a call to any other 

— I list operation la considered erroneous and may cause 

— I unanticipated results. For nonempty lists, "Next" 

— I returns a member, but does not remove it from the 

— I "Let”. 


procedure Delete 

( Lst : in out LIST; 

Mbr : out ITBM; 

Found : out BOOLEAN ); 


— I "Delete" may only be called after "Traverse", "Next" 
—j or "Delete". A call to "Delate" after a call to any 

— I other list operation is considered erroneous and may 
—j cause unanticipated results. For nonempty lists, 

—| "Delete" returns a member "Mbr", and deletes from 

— I the list the member returned in the previous call to 

— I "Traverse", "Next" or "Delete". For example, consider 

— I the following sequence: 

—| Traverse (L,M,F, Normal); 

— | Next (L,M,F) ; 

— I Delete (L, M, F); 

— I The Call to "Delate" would have deleted tha member 

— I returned from the call to "Next". 


procedure Insert 

( Lst : in out LIST; 
Mbr : ITEM ); 


— I "Insert" operates relative to "Traverse", "Next”, end 

— I "Delete”. If the direction is Normal, then "Insert" 

— I insert "Mbr" just before (i.e., toward tha front) the 
—| member returned from the last call to "Traverse", 

—| "Next", or "Delete". If the direction is Opposite 

— I then "Insert" inserts "Mbr" just after (i.e., toward 
—| the back) the member returned from the last call to 
—| "Traverse", "Next", or "Delete”. 


procedure Push 

( Lst : in out LIST; 
Mbr : ITEM ); 


— I LIFO Queueing Discipline 


— I Procedure "Push" inserts a member at the front of a 
—| list. It is equivalent to "Traverse, Insert" with a 
--j direction of "Normal". 


procedure Append 

( Lst : in out LIST; 

Mbr : ITEM ); 

continued 


42 

















— I FZFO Quauaing Oiacipllna 


— I Prooadura "Appand" Znaarta a maahar at tba Back of a 
—j Liat. Zt la aquivalant to "Travaraa, Znaart" with a 
—j direction of "Oppoaita". 


prooadura Pop 

( tat : in out LIST; 

Mbr : out ITEM; 

Pound : out BOOLEAN ); 


— I For no n aa pt .y liata. Pop da lataa and raturna tha front 
—j aaaba r of a liat. Zf aapty, it raturna falaa in 

— I "found". 


prooadura Banova 

( Lot : in out LIST; 
Nbr : ITEM ); 


— 1 Prooadura Banova aaarchaa for Mbr in tha liat. Zf it 

— I ia found, it dalataa it fron tha liat. 


ganario 

typa UNKNOWN ia 
privata; 


— I Paakaga aaarch uaaa a uaar providad function that 

— I da f ion a tha natah. Por axanpla, tha natch nay 
—| ba on ona alana nt in a racord. 


with function Match 
( Unk : UNKNOWN; 
M>r : ITEM ) 
return BOOLEAN; 
paakaga Saaroh ia 


— I Prooadura Find begina at tba atart of tat to aaarch 

— I for M>r that antobaa Onk. On a hit, Mbr ia roturnad 

— I and Pound ia aet to trua. Uaar providad natch 

— I function ia providad for matching. Prooadura Find 

— I alwaya raturna firat Mbr found. 


prooadura Find 

( tot : in out LZST; 

Onk : UNKNOWN; 

Mbr : out ITEM; 

Found ; out BOOLEAN ); 


— I Prooadura Find Maxt worka lika Find but ia uaad for 
—j aubaaquant calTa to raturn naxt oocurronooa of OMK. 


prooadura Find Maxt 
( Lat : in out LZST; 

Onk : UNKNOWN; 

Mbr : out ZTIM; 

Found ; out BOOLEAN ); 


continued 




















— | Prooadura Raaova start.* at front of Lst and raaovaa 
—| 1st occurranca of Onk for which thara ia a match, 

— I aa dafinad in usar provida match function. 


prooadura Raaova 

( Lst : in out LIST; 

Onk : UNKNOWN; 

Mbr : out ITEM; 

Ramovad : out BOOLEAN ); 
and Saarch; 

ganaric 

with function "<«" 

( Itm, Mbr : ITEM ) 
raturn BOOLEAN is <>; 
prooadura Incl 

( Lst : in out LIST; 

Ita: ITEM ) ; 

— I - 

—| Saarchas from back to front. Mbr whan Ita <» Mbr, Ita 

— I is Insartad on tha Rvs sida of Mbr. 

- 

ganaric 

with prooadura Fraa 

( Mbr : in out ITEM ); 
prooadura Oastroy 

( Lst : in out LIST ); 

_.| - 

—| This routina Dumps and FREEs avary alaaant in tha list, 
—| than "uninitialiras" tha list. 

„| - 

Null_Itaa, Paaaad_Bnd_Of_List, Oninitialisad_List 
: axcaption; 

— Privata portion of specification dalatad in this 

— docuaant. 

and Link; 


5.4.2 Link Example 

The example below illustrates the use of the subprograms contained in the package 
specification Link. This example closely resembles the example given in Section 5.1.2. 


with Onchackad_Daallocation; 

with 8im; 

with Link; 

with Taxt_IO; 

prooadura Tast_Link ia 


typa TEST_NDMBER TYPE is 

continued 


44 













< on, WO ); 


paekago Smsa_XO is 

naw Taxt_IO.*nuMratioo_IO (TBSTJROMBXR_TIPS) ; 


typa VAL ASSAY Is 
array Tl.. 10) 
of INTEGER; 


typo TJRSC is 
rooord 

Raoaivad : BOOLEAN; 

Trios : NATURAL; 

Dal : FLOAT; 
and rooord; 

typa T_PTR is 
aooass T_RBC; 

paekago T Pack is 

MW Link (T_RJtC, TJPTR); 

typa IP is 

aooass INTBGRR; 

packsga I Pack is 

MW Lint (INTEGER, IP) ; 

T_Llst 

: T_Pack.List; 

— Dafina sMmbars that ara of aceass typo. 


Mbr 

: TPTR; 

Mbrl 

: TPTR; 

Kbr2 

; TPTR; 

Nbr3 

; T_PTR; 

Mbr4 

: TPTR; 

MbrS 

: TJPTR; 

Mbr 6 

: TJPTR; 

Mbr7 

: TJPTR; 

MbrS 

: T_PTR; 

Unk2 

: T_PTR; 

I List 


continued 






: Z Pack.List; 


— Define oubari that ara of type 

— integer. 

LI 

: IP; 

L2 

: IP; 

L3 

; IP; 

L4 

: IP; 

L 

: IP; 

Fad 

: BOOLEAN; 

Removed 

: BOOLEAN; 

Test_Nuab 

: TEST_NOHBER_TYPE; 

No Of_Itama 
: NATURAL; 

Oak 

: INTEGER; 

— Procadura Fraa ia input to generic pcocadura Daatroy. 

— Daatroy dumps and fraaa ovary alamant in a liat and 

— than "unitialises" tha list. 

procadura Daallocata ia 

nav Onchackad_Daallocation (T_REC, T_PTR); 

procadura Fraa 

( P : in out TJPTR ) 
ranamas Daallocata; 

procadura Daatroyar is 

naw T_Pack.Daatroy (Fraa); 

— Function A is usad for ganaric function HATCH in 

— packaga SEARCH. Whan N and M match, function A 

— returns trua. 

function A 

( N : INTEGER; 

H : IP ) 

return BOOLEAN is 
begin — A 

return N ■ M.all; 
and A; 

— Function B is used for ganaric function HATCH in 
-- packaga SEARCH. Whan N and H match, function A 

continued 


46 







— return • true, 
function B 
( ■ : T_PTR; 

M : T PTR ) 
return BOOLEAN la 
begin — B 

if N.Del ■ M.Del then 
return TROE; 

else 

return False; 
end if; 
end B; 

package S_Pack is 

new Z_Paok.Search (INTEGER, A); 

package 0 _Pack ia 

new T_Pack.Search (T PTR, B); 


— Function below is imported for generic 

— function "<*■" which is used with procedure INC. 

function Less_Important 
( L : IP; 

R : IP ) 

return BOOLEAN is 
begin — Less_Important 
return L.all > R.all; 
end Leaa_Important; 

procedure Include is 

new I_Pack. Incl (Leae_Iraportant) ; 


begin — Test_Link 

— Initialise members. 

Mbr :« new S_RBC; 

Mbrl new TJOC' (False, 1, 1.0); 

Mbr2 :■> new T_RKC' (TROE, 2, 2.0); 

Mbr3 new T_RBC' (False, 3, 3.0); 

Mbr4 new T_RKC'(TRUE, 4, 4.0); 

MbrS :■ new T_RBC'(TRUE, 5, 5.0); 

MbrS new T_KEC'(TROE, 6, 6.0); 

Hbr7 new TJRBC'(TROE, 7, 7.0); 

Mbr8 :■ new TJRBC'(TROB, 1, 8.0); 

Onk2 :» new T_REC'(TROE, 1, 1.0); 

LI new INTBCBR'(1); 

L2 new I NTE GE R'(2); 

L3 new INTBCBR'(3); 

L4 :■» new INTBCBR'(4); 

L new INTBCBR; 

Text_IO.Put("Enter test number >"); 
lnun_I0. Get (Test_Numb) ; 

case Test_Numb is 
when ONE -> 

— Init initializes the linked list whose members 
— are T_Reca. 

T_Liet~:- T_Pack.Init; 

— Next line positions to front 
-- of T_Liat. It is an empty 

continued 


47 









— linked list so Mbr is null and 

— Fnd is false. 

T_Pack.Traverse(T_List, Mbr, Fnd); 

— Hext line inserts Mbrl in 

— in T_List. 

T_Pack.Insert(T_List, Mbrl); 

-- Hext two lines insert Mbr2 

— in front of Mbrl and then 

— Mbr3 in front of Mbr2. 

TJPack.Insert(T_List, Mbr 2) ; 

T_Pack.Insert(TJList, Mbr3); 

— Hext two lines insert Mbr4 

— at end of list and than 

— Mbr5 after Mbr4. 

TJPack .Append (T_Li»t, Mbr4); 

TJPack.Append(T_List, Mbr 5) ; 

— Hext line removes Mbrl from list. 

T_Pack.Remove(T_List, Mbrl); 

— Humber of items in list is 4. 

Ho_Of_Items :« T_Pack.Nl(T_List); 

— The order of T_List now is: 

— Mbr3 
Mbr2 
Mbr4 
Mbr5 

— Dump clears all members from list. 

TJPack.Dump(T_List) ; 

-- Humber of items in list is 0. 

Ho_Of_Items :« TJPack.Hi(T_List); 

— Hext four statements insert members so in 

— sequential order in list. 

T_Pack.Push(T_Liat, Mbr2); 

T_Pack.Push(T_Liat, Mbrl); 

T_Pack.Append(T_Liat, Mbr 3) ; 

T_Pack.Append(T_List, Mbr 4) ; 

— Hext statement positions to end of list. 
T_Pack.Traverse(TJList, Mbr, Fnd, Sim.Opp->site); 

— Move to second member from end, Mbr3. 
T_Pack.Hext(T_List, Mbr, Fnd); 

— Delete Mbr3 from list. 

TJPack.Delete(T_List, Mbr, Fnd); 

— Remove front member from list. 

— Front member is Mbrl. 

TJPack.Pop(T_List, Mbr, Fnd); 

— Ho of Items below is two. 

Ho_0f~Itema T_Pack.Hl<T_List); 

— Get first member in list. 

Mbr T_Pack.First(T_List); 

— See if next member~matches ONK2; 

D_Pack.Find(T_List, Unk2, Mbr, Fnd); 

— Dump and free elements in T_List. 

— Then "uninitialize" T_List. 

Destroyer(T_List); 

when THO -> 

— Init initialises the linked list whose members 

— are of type integer. 

I_List I_Pack.Init; 

— Ho_of Items in list is 0. 

Ho_Of_Itema I Pack.Hl(IList); 

I_Pack.Push(I List, L4); 

I_Pack.Push<I~List, L3); 

IJPack.Push(I_List, LI); 

— Hext statement starts at end of I_List and 

— inserts L2 in front of first member of 


continued 


48 





— list that it ia laaa than. 

Include (I_Li»t, L2); 

— Aftar XNCLODB tha list ia ordarad: 

LI 

L2 

L3 

L4 

— Bind saarchas X_Liat from front for first 

— tfcr that aatchaa ONK. Match ia dafinad in 

— mar providad function A abova. 

Onk :» 3; 

S_Pack,Find(X_List, Onk, L, Fnd); 

— Tha valua ratumad abova for L ia 3 and 
— Fnd is trua. 

— Naxt stataraant saarchas for naxt match. 

— In this case thara ara nona and Fnd ia falsa. 
S_Pack.Find_Haxt(I_List, Onk, L, Fnd); 

— Naxt statamant ramovaa meabar 

— that aatchaa ONK. Again match is dafinad in 

— usar providad function A. 

— Valuas raturnad in L and ramovad ara 3 and 

— trua raspactivaly. 

S_Pack.Kamova(I_Liat, Onk, L, Ramovad); 

and casa; 

and Tast Link; 


5.5 Link Ai 

Package Link_Ai is similar to package Link. Link_Ai provides the additional capability of 
maintaining accumulated integer statistics on queue length and a means for identifying variables 
that might, in the future, be graphed. 

The function below (as in package Lnk_Ai, Section 5.2) allows the user to get the 
variable that contains the statistics on queue length. 


function Var 
(Lat : LIST ) 
raturn Ai.Variable; 


The discriminant for the type statement for the list (also as in package Lnk_Ai) is a 
sequence number that identifies a variable that might be graphed. 

5.6 LinkTi 

Package Link_Ti is also similar to package Link. Link_Ti provides the additional 
capability of maintaining tallied integer statistics on queue length. The sequence number for 
graphing is also kept as a discriminant in the "type LIST" statement. 


49 







6.0 STATISTICAL PACKAGES 


EARS contains seven primary statistical packages. The first three that will be discussed, 
package Rand, Random_Distribution, and Random, are used for random number generation. The 
remaining, packages, Ti, Tf, Ai, and Af, are used for maintaining and reporting tallied integer, 
tallied floating point, accumulated integer, and accumulated floating point statistics. The terms 
"tallied" and "accumulated" are defined in the C.A.C.I. publication.* The equations used to 
calculate the tallied and accumulated mean and variance are given in the package specifications 
for Ti, Tf, Ai, and Af. 

EARS also contains package Stat. When writing a simulation the user does not need to 
write any code that uses anything in this package. Therefore this package specification will not be 
included in this guide. 

6.1 PACKAGE Rand SPECIFICATION 

The package Rand specification, shown below, contains three subprograms. The first, 
function Number, returns a pseudorandom number between 0.0 and 1.0. The next two, procedure 
Save_Streams and Restore_Streams, save and restore the values in the random number streams. 


with Sim; 


package Rand ia 


subtype STREAM RANGE ia 

INTEGER rang* 1 .. 100; 


— Number return* a random number uaing a seed found in the 

stream. 

function Number 

( Stream : STREAMJRANCB ) 
return Sim.Real; 

-- designated 

— Save_Streams writes the stream of seeds to the disk 

— file FileJName. 
procedure Save Streams 

( File_Name T STRING ); 


— Restore Streams reads in the streams from disk file 

— FileJName. 
procedure Restore Streams 

( File_Name : STRING ); 


end Rand; 



6.2 PACKAGE Random_Distribution SPECIFICATION 

Package Random_Distribution, given below, contains functions that allow a user to 
generate random numbers from uniform, exponential, normal, and poisson distributions, as well as 
from a step function. In EARS, package Random_Distribution is instantiated in the package 
Random specification, which is given in the next section. 


* CACI, Inc. 1983. SIMSCRJPT115 Programming Language. Los Angeles, CA. 


50 





63 PACKAGE Random SPECIFICATION 

This specification, shown below, contains the instantiation of Random_Distribution that is 
used for EARS simulations. The stream range is from 1 to 100 for the VAX/VMS random 
number generator. A user may supply his or her own random number generator that has a 
different stream range. The function Number in package Rand is used to provide the seed. 


with Rand, Randoo_Diatribution: 
packaga Random is 

naw RandomJDlatribution (Straam_Ranga ■»> Rand.StraamJRanga, 
Produca_Random ■> Rand.Rumba rj; 


51 











6.4 PACKAGE Rand and Random Distribution EXAMPLE 


The example below illustrates how these random distribution packages are used. 


with Randan; 
with Sis; 
with Rand; 

prooadura Kxample_Random is 

Timel : Sim.Raal; 

Tima2 : Sim.Raal; 

Tima3 : Sim.Raal; 

Tima4 ; Sim.Raal; 

Tima5 : integer; 

begin 

— Tha naxt 5 executable statamants illustrata how random 

— numbars from diffarant distributions ara obtained whan 

— Rand.Number is tha procedure that provides tha random 

— number. Remember, this is true because in packaga 

— Random tha generic packaga Random_Distribution is 

— instantiated such that function Rand.Number returns 

— tha seed. 

— Gat a random variable from a uniform distribution that 

— ranges from 0.0 to 5.0. 

— A seed from stream 1 is provided by function 

— Rand.Dunbar 

Tlmal :* Random.Uniform(l,0.0,5.0); 

— Timel - 1.73500448465347 

— Gat a random variable from a uniform distribution that 

— ranges from 0.0 to 1.0. 

— A saad from stream 1 is provided by function 
-- Rand.Number 

Tima2 :■ Random.Onlform(l); 

— Tima2 a 7.555246353149414E-003 

— Gat a random variable from an exponential 

— distribution whose mean is 0.5. 

— A saad from stream 1 is provided by function 

— Rand.Dumber 

Time3 :■ Random.Exponential(1, 0.5); 

— Time3 - 8.937345308823633E-002 

— Gat a random variable from a normal distribution 

— whose mean is 10.0 and standard deviation is 1.0. 

— Same seed as above. 

Tlme4 :« Random.Normal{l,10.0,1.0); 

-- Time4 - 10.5573352087283 

-- Gat a random variable from a uniform distribution that 

— ranges from 0 to 99. The random variable is an integer. 

— Same saad as above. 

TlmaS :« Random.Step (1,0, 99); 

— Tima5 m 0 

— The next stateamnt illustrate the use of procedure 

— Rand.Save_Streams which saves the current stream of 

— random number seeds that is defined in package body 

— Rand. They are saved in file Stream_Filel. 

Rand.Save_Streams("Stream_Filel"); 

— Tha next statement reads this stream from file 

— Straan_Filal, back into package body Rand. 
Rand.Restore_Streams("Stream_Filel"); 

end KxampleJRandom; 


52 








6.5 PACKAGE Ti SPECIFICATION 


The specification for package Ti is given below with comments. This specification defines 
a variable type for maintaining statistical information and provides procedures required for 
maintaining and reporting tallied integer statistics. The procedure Reset is used to reinitialize the 
values in the user’s parameter that is of type VARIABLE. This is only done to reinitialize the 
values. The initialization of these values is automatic to the user. Procedure Assign is used to 
continuously update the statistical information. Procedures Mean, Variance, and Std_Dev calculate 
and return these statistics. Procedure Report writes out these statistics and additional information 
to either the user’s monitor or to a file. Procedure Brief writes out statistics and additional 
information that is needed for graphing to a file. Procedure Report writes descriptive words (in 
strings) next to the data, so that the file is easy to read. Procedure Brief only writes out the data. 

When using procedures Mean, Variance, Std_Dev, and Report, the user has the option of 
either having exceptions raised within the procedure or having an Error_Type returned to the 
calling procedure. 


with Sia, Text_IO, Stat; 
use Sia, Text_IO; 

package Ti ia 

— Error_Typa contains typas of arrora that Bay ba 

— propagated from tha subprograms in this 

— packaga. 

typa ERROR_TYPE ia 

( DONE, CONSTRAINT, NODATA, OTHER ) ; 

— Variabla ia tha typa dafinition for racorda 

— whara atatiatical information is stored. 

— Tha discriminant. Sag, contains an ZD number 
-- that is intended to ba used for graphing 

— purposes. It aay, for exaaple, ba used as a 

— noda ID. Procedure Brief, below, writes 

— statistics to a file which later aay be graphed, 
type VARIABLE 

( Sag : NATURAL :« Stat.Seq(Stat.Ti) ) ia 
record 

N : NATURAL :« 0; 

SuaJC : NATURAL :« 0; 

Sn : Real :« 0.0; 

Max_X : INTEGER INTEGER'First; 

Mini : INTEGER INTEGER'Last; 

X : INTEGER; 
end record; 

procedure Reset 

( Var : in out VARIABLE ); 

— I Resets Stats; 

procedure Assign 

( Var : in out VARIABLE; 

Value : INTEGER ); 

— I Assign a naw value to the variable. 

continued 


53 








— Tha squation below la used to calculata tha Man. 

— mu(n) “ sum of n valuaa/n 

— where n rapraaanta tha number of obaarvationa and 

what ia inaIda paranthaaaa ia a subscript 

— Tha aquation balow ia uaad to calculata tha varianca. 

— S (n+1) - S(n) + [n/ [n+1] ] * £x(n+l) - mu(n)]**2 

— V(n+1) - [1/n] * S(n+1) 

procadura Maan 

( Var : VARIABLE; 

Raault : out Raal; 

Error : out ERROR TYPE; 

Propagata : BOOLEAN TRUE ) ; 

— I Raturn tha avaraga valua of tha variabla. 

— I Excaptions may or may not ba propagatad. 

procadura Varianca 
( Var : VARIABLE; 

Raault ; out Raal; 

Error : out KRRORTYPK; 

Propagata ; BOOLEAN :» TRUK ); 

—1 Raturn tha varianca of tha variabla valuaa. 

—j Excaptions may or may not ba propagatad. 

procadura Std_Dav 
( Var : VARIABLE; 

Raault : out Raal; 

Error : out KRRORTYPK; 

Propagata ; BOOLEAN :« TRUE ); 

—| Raturn tha standard daviation of tha variabla valuaa. 
—j Excaptions may or may not ba propagatad. 

procadura Raport 
( Var : VARIABLE; 

Propagata : BOOLEAN Falsa ); 

— I Prints statistics, in human raadabla form, to monitor. 

— I Exemptions may or may not ba propagatad. 

procadura Raport 
( F : Fila_Typa; 

Var : VARIABLE; 

Propagata : BOOLEAN :» Falsa ); 

— I Prints statistics, in human raadabla form, to a fila. 

— I Exemptions My or My not ba propagatad. 

procadura Briaf 
( F ; Fila_Typa; 

Typ : Stat.Id; 

Var : VARIABLE ); 

— I Writaa Briaf raport to a fila according to forMt 

— I specifications defined in package Stat. Fila contains 

— I statistics and is intended for graphing purposes. 

— I Typ is a 4 character string ID provided by tha user 
and Ti; 


6.6 PACKAGE Tf SPECIFICATION 


This specification, shown below, defines a variable type for maintaining statistical 
information and provides procedures required for maintaining and reporting tallied floating point 
statistics. The package Tf specification, which is given below, is similar to the package Ti 
specification. The comments explain the relevant aspects of this specification. 


54 








with Si*, Text_IO, St*t; 
um Si*, Text_IO; 

package Tf ia 

— Error_Type contain* type* of errora that say ba 

— propagated up fro* tha aubprograma in thia 

— package. 

type ERROR TYPE ia 

( HOKE, CONSTRAINT, NODATA, OTHER ); 

— Variable ia tha type definition for record* 

— where atatiatioal information ia atorad. 

— Tha diacriminant Sag ia a aequence number that ia 

— an ID nuabar that ia needed for graphing purpoaea. 

— Procedure Brief writer atatiatica to a file 

— which later may be graphed, 
type VARIABLE 

( Sag : NATURAL :■ Stat.Seq(Stat.Tf) ) ia 
record 

H : INTEGER 0; 

SumJC : Real 0.0; 

Sn T Real :• 0.0; 

Max_X : Real Real'Flrat; 

Hin_X : Real :■ Real'Laat; 

X : Real; 
end record; 

procedure Raaet 

( Var : in out VARIABLE ); 

—| Raaeta State; 

procedure Aaaign 

( Var : in out VARIABLE; 

Value : Real ); 

— I Aaaign a new value to the variable. 

— turn equation below ia uaed to calculate the mean. 

— *u(n) - aum of n valuea/n 

where n repreaenta tha nuabar of obaar ..dona and 
what ia inaida parentheaaa la a aubacript 

— Tha equation below ia uaed to calculate the variance. 

— S (n+1) - S(n) + ln/tn+1]] * [*(n+l> - *u(n)]**2 

— V(n+1) - [1/n] * S (n+1) 


procedure Mean 

( Var : VARIABLE; 

Reault : out Real; 

Error : out ERROR TYPE; 

Propagate : BOOLEAN TRUE ); 

—| Return the average value of the variable. 

—| Exceptiona may or may not be propagated. 

procedure Variance 
( Var : VARIABLE; 

Reault : out Real; 

Error : out ERROR_TYPB; 

Propagate : BOOLEAN :* TRUE ); 

— I Return the variance of the variable valuea. 

continued 


55 






— | Excoptiona uy or uy not bo propagated. 

proooduro Std Dev 
( Var : VARIABLE; 

Reault : out Roal; 

Error ; out ERROR_TYPE; 

Propagato : BOOLEAN TROE ) ; 

—| Raturn tho atandard doviation of tho variablo valuoa. 
— j Excoptiona may or may not bo propagatod. 

proooduro Roport 
( Var : VARIABLE; 

Propagato : BOOLEAN :» Palao ); 

—| Prlnta atatiatioa, in human raadablo form, to monitor. 
—j Excoptiona may or may not bo propagatod. 

proooduro Report 
( F : File_Type; 

Var : VARIABLE; 

Propagato : BOOLEAN :« Falaa ); 

—| Printa atatiatioa, in human roadabla form, to a filo. 
— j Excoptiona may or may not bo propagatod. 

proooduro Brief 
( F : File_Type; 

Typ : Stat. Id; 

Var : VARIABLE ); 

—| Writoa Briof roport to a filo according to format 

— j apocificationa defined in packago Stat. Filo containa 
—| atatiatioa and ia intondad for graphing purpoaea. 

— I Typ ia a 4 character atring ID provided by tho uaor. 
end Tf; 


6.7 PACKAGE Ai SPECIFICATION 

This specification defines a variable type used for maintaining statistical information and 
provides the procedures required for maintaining and reporting accumulated integer statistics. This 
specification is analogous to the package Ti specification. The specification with comments is 
given below. 


with Text_IO, Stat; 
uao Toxt_IO; 
with Sim; 
uao Sim; 


package Ai ia 


— Error_Typo containa typea of orrora that may bo 

— propagated from tho aubprograma in thia packago 
typo ERROR TYPE ia 

( NONE, CONSTRAINT, NODATA, OTHER ); 

continued 


56 











— Variable ia tba type definition for reoorda 

— where atatiatioal information ia atored. 

— The dlaoriminant Seq ia a sequence number 

— that ia in an ZD number uaed for gracing 

— purpoaea. Procedure Brief writes atatiatica 

— for a file which later may be graphed, 
type VARIABU 

( Seq : NATURAL :» Stat.Seq(Stat.Ai) ) ia 
record 

Initialised : boolean :■ false; 

T_0 : Real :« 0.0; 

T_Laat : Real :« 0.0; 

SumJK : Real :» 0.0; 

Sum_Squares_X : Real :■ 0.0; 

Max~X : INTEGER INTEGER'First; 

Min_X : INTEGER INTEGER'Last; 

X : INTEGER; 
end record; 

prooedure Reset 

( Var : in out VARIABLE ); 

— Reset Stats. 

procedure Assign 

( Var : in out VARIABLE; 

Value ; INTEGER ); 

— Assign a new value to this variable. 

— The equations below, which asms from the text, 

— "SIKSCRXPT II.5 Programming Language", C.A.C.I., 

— (pg 390), are uaed to calculate the mean 

— and variance. 

— SUM summation of x * [TXMt.V - TL] 

— SUM.ON.SQUARES summation of [x**2] * [TZME.V -TL] 

— MUM SUM/[TIME.V - TO] 

-- MEAN.SQUARE SUM.OP.SQUARES/[TIME.V - TO] 

— VARIANCE MEAN.SQUARE - MSAN**2 

— where THK.V ia simulation clock time, 

TL is the simulated time at which an 
an accumulated variable was sat to 
its current value, and 
TO is the simulated time at which 
accumulation starts 

procedure Mean 

( Var : VARIABLE; 

Result : out Real; 

Error : out ERROR TYPE, 

Propagate : BOOLEAN TRUE ); 

— Return the mean value of the variable. 

— Exceptions may or may not be propagated. 

prooedure Varianoe 
( Var : VARIABLE; 

Result : out Real; 

Error : out ERROR TYPE; 

Propagate : BOOLEAN TRUE }; 

— Return the variance of the variable values; 

— Exceptions may or may not be propagated. 

procedure Std_Dev 
( Var : VARIABLE; 

continued 


57 








Result : out Rami; 

Error : out ERROR_TYRX; 

Propagate : BOOLEAH TROK ); 

— Rmturn tbo atmndmrd davimtion of tho valuos. 

— Excaptions may or may not be propagated. 

procedure Raport 
( Vax : VARIABLE; 

Propagate : BOOLEAN :« Paisa ); 

— Prints statistics, in human raadabla form, to monitor. 

— Excaptions may or may not ba propagatad. 

prooadura Raport 
( P : FileJType; 

Var : VARIABLE; 

Propagata : BOOLEAN Palaa ); 

— Prints statistics, in human raadabla form, to a film. 

— Exemptions may or may not bo propagatad. 
prooadura Briof 

( P : PilaJTypa; 

Typ : Stat. Id; 

Var : VARIABLE ); 

— Hritss Briaf raport to a film according to format 

— specifications defined in package Stat. Pile contains 

— statistics and is intended for graphing purposes. 

— Type is a 4 character string ID provided by the user. 

and Ai; 


6.8 PACKAGE Af SPECIFICATION 

This specification, given below, defines a variable type for maintaining statistical 
information and provides the procedures required for maintaining and reporting accumulated 
floating point statistics. 


with Sin; 
use Sim; 
with Text_IO; 
use Text_IO; 
with Stat; 


package Af is 


— Variable is the type definition for records 

— where statistical information is stored. 

— The discriminant Sag is a sequence number that 

-- is intended as an ID number for graphing purposes. 

— Prooadura Brief writes statistics to a file 
-- which later may be graphed. 

type VARIABLE 

( Seq : NATURAL Stat.Seq(Stat.Af) ) is 

record 

Initialised ; boolean :» false; 

T_0 : Real 0.0; 

T_Last : Real 0.0; 

Sue X : Real 0.0; 


continued 


58 











SiM_Squtr*t_X : Real 0.0; 

Max X : Baal :■ Real'First; 

Min~X : Baal Real'Last; 

X : Baal; 
and racord; 

— Krror_Iypa contains typaa of arror that may bo 
-- propagated up fro* tha subprograms in this 

— paokage. 

typa ERROR_TYPE la 

( BOMB, CONSTRAINT, NODATA, OTHER ); 

prooaduro Baaat 

( Var : In out VARIABLE ); 

— Rasat Stats. 

prooaduza Assign 

( Var : in out VARIABLE; 

Valua : Baal ); 

— Assign a now valua to this variabla. 

— Tha aquations balow, which cams from tha text, 

— "SIMSCRIPT XI.5 Programing Language", C.A.C.X., 

— (pg 390), ara uaad to calculate tha moan and 

— variance. 

SUM 

SUM.Or .SQUARES 

MEAN 

MEAN.SQUARE 
VARIANCE 

where TIME.V is simulation clock time, 

TL is tha sissilatad time at which an 

— accumulated variable was sat to its 
currant value, and 

TO is tha simulated time at which 
accusulation starts 


summation of x * [TIMS.V - TL] 
summation of [x**2] * [TIME.V - TL] 
SOM/(TIME.V - TO] 

SOM.OF.SQUARES/(TIME.V - TO] 

MEAN.SQUARE - MKAN**2 


procedure Mean 

( Var : VARIABLE; 

Result : out Raal; 

Error : out ERROR TYPE; 

Propagate : BOOLEAN TRUE ); 

— Return tha average of tha variabla. 

— Exceptions nay or aay not be propagated. 

procedure Variance 
( Var : VARIABLE; 

Result : out Real; 

Error : out ERROR TYPE; 

Propagate : BOOLEAN TRUE ); 

— Return tha variance of the variable values. 

— Exceptions aay of stay not be propagated 

procedure Std Dev 
( Var : VARIABLE; 

Result : out Real; 

Error : out ERROR TYPE; 

Propagate : BOOLEAN TRUE ); 

— Return standard deviation of variable values. 

— Exceptions nay or aay not be propagated 

procedure Report 


continued 


59 






( Var : VARIABLE; 

Propagate : BOOLEAN Palaa ); 

— Prints statistics, in human readable form, to monitor. 

— Exceptions may or may not be propagated. 

procedure Report 
( F : File_Type; 

Var : VARIABLE; 

Propagate : BOOLEAN False ); 

— Prints statistics, in human readable form, to a file. 

— exceptions may or may not be propagated. 

procedure Brief 
( F : FileJType; 

Typ : Stat.Id; 

Var : VARIABLE ); 

— Writes Brief report to a file according to format 

— specifications defined in package Stat. File contains 

— statistics and is intended for graphing purposes. 

— Typ is a 4 character string ID provided by the user, 
end Af; 


6.9 PACKAGE Ti, Tf, Ai, Af EXAMPLE 


The example below shows how the subprograms in these four packages are called. 


— This procedure illustrates the use of the visible 

— subprograms contained in packages Ti, Tf, Ai, and Af. 


with Stet; 
with EV; 
with SIM; 
with TF; 
with TI; 
with AF; 
with AI; 
with Text_I0; 

use SIM; — Type Real is used from package SIM. 

— Bv.Clock is of type SIM.Real 
procedure StatJExaaple is 


Type Test_Type is (TF_Test,TI_Test,AF_Test, AIJTest); 
package Enum_I0 is new Text_IO.Enumaration_IO(Test_Type); 

— Define parameters of variable type for the four 
-- packages. 

Tallied Var Tf : TF.VARIABLE; 

Tallied Var~Ti : TI.VARIABLE; 

Accua Var AF : AF.VARIABLE; 

Accum_Var_AI : AI.VARIABLE; 


— The result and error variables, which are defined 

— below, return the results and error_type, respectively, 

— from the Mean, Variance, and Std_Dev procedures. 

Result_Tf : Real; 

Error_Tf : TF.Error_Type; 

Result_Tl : Real; 

Error_Ti : TI.Error_Type; 

continued 


60 










Ra»ult_Af : Real; 

Krror_Af : AT.Xrror_Type; 

Raault_Al : Real; 

Xrror_Ai : AI.Xrror_Type; 

— Teet_T la a paraattir that lndlcataa which package 

— will - ha taatad. Taat_T will ba input below. 

Teat_T : Test_Type; 

— Prop m trua indicates that exceptions that occur in 

— procedure Mean, Variance, StdJDev, and Report will be 

— propagated up. 

Prop : boolean :■ true; 

— Otf and Otf2 are used when statistics are written to 

— a file using procedure Report and Brief 
Otf : Text_IO.File_Type; 

Otf2 ; Text_IO.Fila_Typa; 

— She IDs below are used in procedure Brief. They 

— are used for graphing purposes to identify which 

— call to Brief the statistics are associated with. 

ID : Stat.ID "0001"; 

ID2 : Stat.ID "ND02"; 

ID3 : Stat.ID "ND03"; 

ID4 : Stat.ID "ND04"; 

begin 

Text_I0.Create(Otf2,Text_IO.Out_File,"Test_Output"); 

Text_IO.put ” 

("enter SP_TKST, TI_TKST, AF_TEST, or AI_TEST >"); 

Enum_I0. get (Teet_T) ; 
case Teet_T la 
when TF_TBST »> 

— Result Tf, which is returned from Mean, Variance, 

— and St3_Dev below contains 0.0 and [no data] is 

— printed to the users monitor from Report. This is 

— true since no value has been assigned to 

— Tallled_Var_Tf. These procedures are normally 

— called only after a value has been assigned. If 

— an error occurs, then it is propagated up. 

TP.Mean(Tallied_Var_Tf,ResultJTf,lrror_Tf,Prop); 

TF.Variance(Tallled_Var_Tf, Reeult_Tf,Krror_Tf,Prop); 

TF.8td_Dev(Tallled_Var_Tf,Reault_Tf,Error_Tf,Prop); 

TF.Report(Tallled_Var_Tf,Prop); 

— The values 0.0 and 1.0 are assigned. This means 

— that statistics for these values are being 

— maintained. 

TF.Assign(Tallled_Var_Tf,0.0); 

TF.Assign(Tallied_Var_Tf,1.0); 

— The variance returned below in Result_Tf is 0.25 
-- If an error occurs, it is not propagated up. 

TF.Variance(Tallied_Var_Tf,Reault_Tf,Error_Tf); 

Ev.Clock :■ 3.0; 

TF.Assign(Tallied_Var_Tf, 2.0); 

— Create file, TF Test, that will contain statistics. 

Text 10.Create(0tf7*ext_I0.0DT_FIlE,"TF_TEST"); 

— The file, TF Test, contains - statistics. 

TF.Brief(Otf,ID3,Tallied Var_Tf); 

— Report prints the following information to the 

— user's amnitor: 

— X:2.000 Mean: 1.000 Std: 0.816 Van 0.667 
— Obs: 3 Sum:3.000 Min:0.000 Max:2.000 
TF.Report(Tallied var TF); 

EV.Clock XV.Clock + 1.0; 

TF.Assign(Tallied Var_Tf,3.0); 

XV.Clock XV.Clock 1.0; 

continued 


61 






IF.Brief(Otf,ID3,Tallied_Var_Tf); 

-- Report prints the following information to 

— the user's monitor: 

— X:4.00 Mean:2.000 Std: 1.414 Var: 2.000 

— Obs: S Sum:10.000 Min:0.000 Max:4.000 
ZF.Report(Zallied_Var Zf); 

TF.Assign (Zallied_Var~Zf,4.0); 

ZF.Mean(Zallied_Var_Tf,Result_Zf,Rrror_Zf); 

ZF.Variance(Tallied~Var_Tf,Raault_Zf,Brror_Zf); 

ZF.StdJDev(Zallied_Var_Zf,Result_Tf,Brror_Zf); 

TF.Report(Zallied_Var_Zf); 

— Do report to file. If an error occurs do not 

— propagate it up. 

Prop :> false; 

ZF.Report(Otf2,Zallied_Var_Tf,Prop); 

ZF.Reset(Tallied_Var_Zf); 
when TITKST •> 

ZI.Mean(Zallied_Var_TI,Result_TI,Brror_TI,Prop); 

ZZ.Variance(TalliedJVar_ZI,Result_TI,Error_TI,Prop); 

ZI.Std_Dev(Tallied_Var_TI,Result_ZI, Brror_TI, Prop); 

— The following information is printed to the user's 

— monitor from report: 

— [no data] 

ZI.Report(Zallied_Varjri,Prop,; 

ZI.Assign(Zallied_Var_Zi,0); 

ZI.Assign(TalliadVarTi, 1); 

ZI.Variance(Zallied_Var_Zi,Reault_Zi,Brror_Zi); 

ZI.Assign(Tallied Var_Ti,2); 

BV.Clock :» 3.0; “ 

— Test ZI.Brief 

Text IO.Create(Otf,Text IO.OutJPile,"ZI Zest”); 

ZI.Brief(Otf,ID4.Tallied_Var_ZI); 

— The following information is printed out 

— from Report: 

— X: 2 Mean: 1.000 Std: 0.816 Var 0.667 

— Obs: 3 Sum 3 Min: 0 Max: 2 
ZI.Report(Zallied_Var_ZI); 

BV.Clock :> BV.Clock -I- 1.0; 

ZI.Assign(Tallied Var Ti, 3); 

XV.Clock :- BV.Clock + 1.0; 

ZI.Brief(Otf,ID4,Zallied_Var_TI); 

— The following information is printed out 

— from Report: 

— X: 3 Mean: 1.500 Std: 1.118 Var: 1.250 

— Obs: 4 Sum: 6 Max: 3 
ZI.Report(Tallied_Var_ZI); 

ZI.Assign(Zallied_Var_Zi,4); 

ZI.Mean(Zallied_Var_Zi, Reault_Zi,Brror_Ti); 

ZI.Variance(Tallied~Var_Ti, Result_Zi,Brror_Ti); 

ZI.StdJDev(Zallied_Var_Ti,Result_Zi,Error_Zi); 

— The following information is printed out 

— from Report: 

— X: 4 Mean: 2.000 Std: 1.414 Var: 2.000 

— Obs: 5 Sum: 10 Min: 0 Max: 4 
ZZ.Report(Tallied Var_Zi); 

— Do report to fTle. 

Prop :« false; 

— Seam information as above is written to 

— file test_output. 

continued 


62 






TZ.Report(Otf2,TalliedVarTi, Prop); 

— Resat raaata tha statistics, aa though no 
-- valuaa have bean collected. 

SI.React(Tallied_Var_Xi); 
when AF_T*ST »> ~ 

AF.Mean(Aocue_Var_AF,Raault_AF,Brror_AF,Prop); 

AT.Variance(Accua~Var_AF,Rasult_AF,KrrorAF,Prop); 
AF.Std_Dav(Accua_Var_AF,Reault_AF,KrrorAF,Prop); 

— Report printe to the uaera Monitor: [no data] 
AT.Report(Accu»_Var_AT,Prop); 

RV.Clock :» 1.0; 

AF.Aaalgn(Accu»_Var_AF, 0.0); 

■▼.Cloak ■▼.Clock + 1.0; 

AF.Aaalgn(Accua_Var_AF,1.0); 

AF.Varlance(Accua Var_AP,Raault Af,Error_Af); 

■V.Clock :» ■▼.Clock + 1.0; 

AF.Assign (Accus^_Var_AF,2.0); 

— Teat AF.Brief 

Text_XO.Create<0tf,Text 10.out file,"AF Teat"); 

AF.Brief(Otf,ID2,Accue_Var_AF); 

— Report prints the following to the uaar'a 

— Monitor: 

— X:000 Mean: 0.500 Std: 0.500 Var: 0.250 

— Sum: 1.000 Min: 0.000 Max: 2.000 
AF.Report(Accum_var_AF); 

■V.Cloak :- ■▼.Clock + 1.0; 

AT.Aaalgn(Accum_Var_AT,3.0) ; 

■V.Clock :■ ■▼.Clock + 1.0; 

AF.Brief(Otf,ID2,Accun_Var_AF); 

AF .Report (Aacua_var_AF); 

AF.Aaalgn(Aacue_Var_AF,4.0); 

AF-Mean(Accue_Var_AF, Reault_Af,Krror_Af); 

AF .Variance (Aoctua_Var_AF, Reault_Af, Krror_Af); 

AF.Std_Dav(Aocu«_Var_AF,Reault_Af, Brror_Af ) ; 

— Report writes out the following: 

— X:3.00 Mean: 1.500 Std: 1.118 Var: 1.250 

— Sue : 3.000 Min: 0.000 Max 3.000 
AF .Report (Accun_Var_AF); 

Prop :■ falsa; 

AF.Report(Otf2,Aacuat_Var_Af,Prop); 

— Do report to file. 

AF. Reset(Accu»_Var_AF); 

when AZ_Teat •>> 

AI.Mean(Accun_Var_AI, Rasult_AI,Krror_AI,Prop); 

AX .Variance(AccuaTvar_AI,Raault_AI,Xrror_AX,Prop); 
AX.Std_Dew(Accue_Var_AX,Result_AX,Hrror_AI,Prop); 

— Report prints out : [no data] 

AX .Report (Accuat_Var_AX, Prop) ; 

■V.Clock :« 1.0; 

AX.Reset(Accua_Var_AX); 

AX.Aaalgn(Aocua_Var_AX, 0); 

■▼.Clock ■▼.Clock * 1.0; 

AX.Aaalgn(Accua_Var_AX,1); 

AX .Variance (Accu*_Var_AI, Result_AX, Krror_AI); 

XV.Clock ■▼.Clock -f 1.0; 

AX.Assign(Accua_Var_AI,2); 


continued 





— Try AX.Briaf 


Taxt I0.Craata(0tf,Twxt_IO.Out_Fila,"AI_T*at"); 
SV.CLOCK :■ KV.CLOCK + 1.0; 

AI.Briaf(Otf,ID,Accu*_V*r_AI); 

— Raport print* out tha following: 

— x: 2 Haan 1.000 Std: 0.816 Var: 0.667 
— Sua: 1.000 Min: 0 Max: 2 

U.Raport(Aceu«_var_AI); 

KV.Clock :« Kv.Clock + 1.0; 

AI.Assign(Acaum Var_AI, 3) ; 

KV.Clock :- Kv.Clock + 1.0; 

AI.Briaf(Otf,ID,Accum_Var_AI); 

— Raport print* out tha following: 

— x: 3 Maan: 1.600 Std: 1.020 Var: 1.040 
— Sum: 5.000 Min: 0 Max: 3 

AI .Raport(Accum_var_AI); 

AI.Assign(Accum_Var_AI, 4) ; 

AI.Maan(Accua_Var_AJ,Rasult_AI,Rrror_AI); 

AI.Varianca(Accum_Var_AI,Raault_AI,Error_AI); 
AI. Std_D*v (Accum_Var_AI, Ra»ult_AI, Error_AI) ; 

— AI.Raport(Accum_Var_AI); 

— Do raport to fila. 

Prop :» falsa; 

AI .Raport (Otf2, Accum_V*r_AI, Prop) ; 

AI.Rasat(Accum_Var_AI); 

and casa; 

and StatKxampla; 


64 





7.0 HASH TABLES 


Evada contains two hash table packages. Hash tables provide a capability for quickly 
inserting, accessing, and deleting numbers in an array. The use of hash tables is appropriate when 
(1) these numbers have a wide range of values, and (2) there are relatively few numbers. A detailed 
explanation of hash tables is found in a book by Tennenbaum and Augenstein.* In an EARS 
simulation, hash tables may be used, for example, in duplicate message detection. 

7.1 PACKAGE Hsh 

Package Hsh, whose specification is given below, contains subprograms for creating, 
accessing, and deleting hash tables. The comments within the specification explain what these 
subprograms do. 


with Nat_Lnk, OncheclcedJDeallocation; 
us* Nat_Lnk; 


package Bah is 


Undef_M*m_Loc, Pass*d_End_Of_Table, Corrupted Hash Tabl* 

: exception; 


R*dundant_Incluaion 
: exception; 


type TABLE is 
private; 


— Init creates a tabl* whose sis* is the smallest 

— prime number greater than Sis*, 
function Init 

( Sis* : POSITIVE ) 
return TABLE; 


— Include inserts the value Hat into table Bt. 
procedure Include 
( Bt : TABLE; 

Hat : NATURAL ); 


— Included tells whether or not Hat is a member 
— of tabl* Bt. 
function Included 
( Ht : TABLE; 

< Hat : NATURAL ) 

return BOOLEAN; 


— Members returns the number of members in table 

— Bt. 

function Members 
( Bt : TABLE ) 
return NATURAL; 


— Remove removes a member Hat from tabl* Ht. 
procedure Remove 
( Ht ; TABLE; 

Hat : NATURAL; 

Pound ; in out BOOLEAN ); 

continued 


♦Tennenbaum, A. and M. Augenstein. 1981. Data Structures Using Pascal. Prentice-Hall, 
Englewood Cliffs, NJ. 


65 









— Travaraa ratuma tha firat member of tha 

— tabla Ht in Mat. Nhan tha tabla haa 

— no anmbera than Found ia falaa. 
procadura Travaraa 

( Ht : TABLE; 

Mat : in out NATURAL; 

Found : in out BOOLEAN ) ; 

— Maxt may only ba callad aftar Travaraa Naxt, 

— or dalata. For non-empty tablaa ratuma 

— member Mat. For empty tablaa ratuma Found 

— aat to falaa. 
procadura Maxt 

( Ht : TABLE; 

Hat : in out NATURAL; 

Found : in out BOOLEAN ); 

— Dalata aiay only ba callad aftar Travaraa Maxt, 

— or dalata. For non-ampty tablaa ratuma 

— member Mat and dalataa it from tabla Ht. 
procadura Dalata 

( Ht : TABLE; 

Mat ; in out NATURAL; 

Found : in out BOOLEAN ); 

— Dump removea all mambara from tha tabla. 
procadura Dump 

( Ht : in out TABLE ); 

— Daatroy raaovaa all anmbera from tha 

— tabla and daallocataa tha memory. 
procadura Daatroy 

( Ht : in out TABLE ); 

— Package Sort aorta tha tabla into a 
-- linkad liat according to tha critaria 

— dafinad in tha uaar apacifiad function, 
ganaric 

with function ">" 

( m, M2 : NATURAL ) 
raturn BOOLEAN; 
packaga Sort ia 

typa NATURAL_STRDCTURK ia 
array (NATURAL ranga <>) 
of NATURAL; 

typa NATURAL_ARRAY ia 

accaaa NATURAL_STRUGTURE; 

— Produce produce* a aorted array of alemanta. 
function Produce 
( Ht ; TABLE ) 
return NATURAL_ARRAY; 

— Free daallocataa memory uaad by array, 
procadura Free ia 

new Unchecked_Deallocation 
(NATURAL STRUCTURE, 

NATURAL_AKRAY); 

and Sort; 

— Private portion of apacification delated in 

— thia documentation 

and Hah; 


66 







12 PACKAGE Hash 

Package Hash, whose specification appears below, provides capabilities that are similar to 
those provided by Hsh. Package Hash is a generic package that is instantiated with the type REC, 
its access type, MEMBER, and two user-provided functions. The first function. Same, compares 
two members, while the second. Key, calculates a unique integer key for a member. 

The package specification for Hash, with comments describing what the subprograms do, 
is given below. 


with Onchscksd_Desllocation, Link; 


generic 


typ* BSC 1* 
private; 


type MEMBER la 
access REC; 


— The ua«r writes a function Sama that compares two 

— awturt and raturna true whan thay match, 
with function Sama 

( Ml. M2 : MEMBER ) 
return BOOLEAN; 


— The uaar writes a function that returns an integer 

— key that is unique to tha member. 

— The key is used by the Bash subprograms to access 

— the member. 

— An explanation of the use of keys is found in 

— data structures texts, such as, "Data Structures 

— Using Pascal", by Tenenbaum and Augenstein. 
with function Kay 

( Mbr : MEMBER ) 
return INTEGER; 


package Bash is 


Undaf_Kem_Loc, Passed_End_Of_Table, Corrupted_Bash_Table 
: exception; 


Radundant_Inclusion 
: exception; 


package Lnk is 

new Link (REC, MEMBER); 


use Lnk; 


type TABLE is 
private; 


— Init creates a table whose Size is tha smallest 

— prims number greater than size, 
function Init 

( Size ; NATURAL ) 
return TABLE; 


— Include inserts the value Nat into table Bt. 
procedure Include 

continued 


67 





( Bt : TABLE; 


Kbr : MEMBER ); 

— Included tails whether or not Met is e member 

— of table Bt. 
function Included 

< Bt : TABLE; 

Kbr : MEMBER ) 
return BOOLEAN; 

— Members returns the number of members in table 

— Bt. 

function Members 
( Bt : TABLE ) 
return NATURAL; 

— Find searches the list to find a list member 

— such that Same(Match,Kbr) is true, 
procedure Find 

( Bt : TABLE; 

Match : MEMBER; 

Kbr ; out MEMBER; 

Found ; in out BOOLEAN ) ; 

— Remove removes a member Mat from table Bt. 
procedure Remove 

( Bt : TABLE; 

Match : MEMBER; 

Mbr : out MEMBER; 

Found : in out BOOLEAN ); 

— Traverse returns the first member of the 
-- table Bt in Mbr. When the table has no 

— members, then Found is false, 
procedure Traverse 

( Bt : TABLE; 

Mbr : in out MEMBER; 

Found : in out BOOLEAN ); 

— Next may only be called after Traverse, Next 

— or delete. For non-empty tables it returns 

— member Nat. For empty tables it returns Found 

— set to false, 
procedure Next 

( Bt : TABLE; 

Mbr : in out MEMBER; 

Found : in out BOOLEAN ); 

— Delete may only be called after Traverse, 

— Next, or Delete. For non-eopty tables it 

— returns member Mbr and deletes it from 

— table Bt. 
procedure Delete 

( Bt : TABLE; 

Mbr : in out MEMBER; 

Found : in out BOOLEAN ) ; 

— Dump removes all members from the table, 
procedure Dump 

( Bt : in out TABLE ); 

— Destroy removes all members from the 

continued 


68 






— tabla and daallooataa tha aanory. 
prooadura SMtroy 

( Ht : in out TABLX ); 

ganarlo 

with function ">" 

( Ml, M2 : MEMBER ) 
raturn BOOLEAN; 

— Produoa produoaa a aortad array of 

— alaaanta. 
packaga Sort la 

typa MEMBERSTRUCTURK ia 
array (HATORAL ranga O) 
of MEMBER; 

typa MKMBERARRAY ia 

accaaa MEMBER_STROCTOTE; 

— Produoa produeaa a aortad array of alaaanta. 
function Produoa 
( Ht : TABLE ) 

raturn MKMBERARRAY; 

— Etna daallooataa aaaory uaad by array, 
prooadura Praa ia 

naw OnchackadJDaallooation 
(MEMBERJSTROCTURE, MKMBERARRAY) ; 

and Sort; 

privata -- Haah 

typa Lat ia 
accaaa Liat; 

typa VAR ia 
racord 

Chainad : BOOLEAN :» Falaa; 

Chaln : Lat :« null; 

Mbr : MEMBER :■ null; 
and racord; 

typa HASHARRAY ia 

array (NATURAL ranga <>) 
of VAR; 

typa CTRL_RXC ia 
racord 

Currant : HATORAL :■ 0; 

Inliat : BOOLEAN Falaa; 

Kot ; BOOLEAN :» TRUE; 
and racord; 

typa TABLE_ARRAY 

( Sisa : HATORAL ) ia 
racord 

8tora : HASH ARRAY (0 .. Sica); 

Ctrl : CTRL REC; 

Naabara : HATORAL 0; 
and racord; 

typa TABLE ia 

acaaaa TABLE_ARRAY; 

and Baah; 


69 









8.0 BIBLIOGRAPHY 


Booch, G. 1987. Software Engineering with Ada. Benjamin/Cumniings Publishing Company, Menlo 
Park, CA. 

Russell, E. 1983. Building Simulation Models. C.A.C.I., Inc., Los Angeles, CA. 

Graybeal, W., and U. Pooch. 1980. Simulation Principles and Methods. Winthrop Publishers, 
Cambridge, MA. 


70 







REPORT DOCUMENTATION PAGE 


Form Approved 
OMB No. 0704-0188 


Public raponing Bunton for mi» collection ol Information t> estimated to average 1 hour per response. Including the time ter reviewing Instructions. searching existing dale sources, gathering and 
maintaining mo date needed, and completing and reviewing me cdteetton o* Wormation. Sand comments regarding Otis burden estimate or any other aspect of this collecttonof Intormatlon.lncludtng 
suggestions tor reducing this burden, to Washington Headquarters Services. Dkectorala tor tototmation Operations and Reports. 1215 JeTTenon Davis Highway, Suae 1204. Artngton.VA 22202-4302. 
and to tho onto* or Management and Budget Paperwork Reduction Protect (070^-0188), Washington, DC 20503. 


1. AGENCY USE ONLY (Leave Nanto I 2 REPORT DATE 


2 REPORT DATE 

December 1990 


4 TITLE AND SUBTITLE 


USER’S GUIDE TO AN EVENT-ACTIVATION RECORD APPROACH TO 
SIMULATION MODELING IN ADA 


8AUTHOR<S) 

H. Mumm and R. Ollerton 


3. REPORT TYPE AND DATES COVERED 

November 1989 - July 1990 


5. FUNDING NUMBERS 

PE: 0602232N 
PRQJ: RC32A13 
WU: DN309082 


7. PERFORMING ORGANIZATION NAME(S) AND ADORESS|ES) 

Naval Ocean Systems Center 
San Diego, CA 92152-5000 


8. PERFORMING ORGANIZATION 
REPORT NUMBER 


NOSC TD 1944 


a SPONSORING/MONTTORING AGENCY NAME(S) AND ADDRESSES) 

Naval Ocean Systems Center 

Block Programs 

San Diego, CA 92152-5000 


10. STONSORING/MONITORING 
AGENCY REPORT NUMBER 



12a. DISTRtBUTION/AVAILABIUTY STATEMENT 



Approved for public release; distribution is unlimited. 


13 ABSTRACT (Maximum 200 wends) 

This document explains how to install and use the Event-Activation Record Approach to Simulation Modeling in 
Ada (EARS) simulation libraries. Version 1.0, that were developed by the Naval Ocean Systems Center, Code 854. This 
software was designed to compile and execute using the Vax Ada compiler. EARS is a discrete-event simulation system that 
uses an event-activation record approach. It has capabilities similar to those provided by SIMSCRIPT. All simulations that 
can be modeled in SIMSCRIPT can be modeled using EARS. 

From a set of user-defined event types, EARS automatically generates much of the source code for many Ada 
packages and subprograms that are needed for simulation development. This allows a user to quickly start writing an EARS 
simulation. The user tailors the simulation to a particular application by adding Ada source code to the generated program 
units and by writing additional ones. 

This document contains an actual simulation example using EARS. The document also includes the Ada source 
code for linked list packages, statistical packages, and hash table packages, as well as examples of how they are used. 


14 SUBJECT TERMS 

Ada 

instantiation 

elaboration 


17 SECURITY CLASSIFICATION 
OF RETORT 

UNCLASSIFIED 


EARS 
linked list 

discrete-event simulation 
hash tables 


18. SECURITY CLASSIFICATION 
OF THIS PAGE 

UNCLASSIFIED 


18 SECURITY CLASSIFICATION 
OF ABSTRACT 

UNCLASSIFIED 


15. NUMBER OF PAGES 

77 


18 . PRICE CODE 


20. LIMITATION OF ABSTRACT 


SAME AS REPORT 


MSN 754001-280-6800 


Standard term 288 






























INITIAL DISTRIBUTION 


CODE 0012 

Patent Counsel 

(1) 

CODE 0144 

R. November 

(1) 

CODE 171 

Dr. M. Vineberg 

(1) 

CODE 40 

Dr. R. C» Kolb 

(1) 

CODE 41 

A. Justice 

(1) 

CODE 411 

D. Hayward 

(1) 

CODE 411 

B. Ollerton 

(1) 

CODE 411 

H. Mumm 

(8) 

CODE 85 

R. Casey 

(1) 

CODE 8503 

Dr. C. Warner 

(1) 

CODE 854 

R. Merk 

(1) 

CODE 854 

Dr. N. Dave' 

(1) 

CODE 921 

J. Puleo 

(1) 

CODE 961 

Archive/Stock 

(6) 

CODE 964 

Library 

(3) 


Defense Technical Information Center 
Alexandria, VA 22304-6145 (4) 

NOSC Liaison Office 

Washington, DC 20363-5100 (1) 


Center for Naval Analyses 
Alexandria, VA 22302-0268 


( 1 ) 




