REPORT DOCUMENTATION PAGE 

A A OEZ^ •rnwonw.kicMIngMtliwtariwitMrini 

I Do 


Form Approved 
OPM No. 0704-0188 



•r mponw, kidudkig ft* tinw tor f wdwHn g Mndioni, Matching axWng data iouicm gMhacing and maWalning tia data 
Ian aadnuM or any olhar aipacl o( Mi ooltcllon of Homutlon. kidudkig tuggMilona lor radudng Mi budan. to Waihington 
Dn0a«faHlgfMray.SiJto1204. ArInglon.VA 22202-4X2. and to tiaOdioa of Motmadon and nagulatoryAKiln.Oinca of 


3. REPORT TYPE AND DATES COVERED 


Final: 30 Nov 1990 to 01 Jun 1993 


AND SUBTITLE 


Validation Summary Report: CoiXHjrrent Computer Corporation. C3 Ada Version 
R03-00V, Concurrent Computer Corporation 3280MP under OS/32 Version R08-03.2 
(Host & Target). 901130W1.11108 




Wright-Patterson AFB, Dayton. OH 
USA 


7. PERFORMING ORGANIZATION NAME(S) AND A00RESS(ES) 

Ada Validation Facility. Language Control ^clCil^ty ASO/SCEL 
Bldg. 676. Rm 135 

Wright-Patterson AFB. Dayton. OH 45433 



e. PERFORMING ORGANIZATION 
REPORT NUMBER 

AVF-VSR-415.0891 


INGAHONITORING AGENCY NAME(S) AND AODRESS(ES) 
Ada Joint Program Office 
United States Department of Defense 
Pentagon. Rm 3E114 
Washington, D.C. 20301-3081 


AVAILABIU 


ATEMENT 


12a. DISTRIB 

Approved for public release; distribution unlimited. 


10. SP0NS0RINGA40NIT0RING AGENCY 
REPORT NUMBER 



12b. DISTRIBUTION CODE 


13. ABSTRACT (Maximum 200 words) 

Concurrent Computer Corporation, C3 /Vda Version R03-00V, Wright-Patterson, AFB, Concurrent Computer Corporation 
3280MP under OS/32 Version R08-03.2 (Host & Target), ACVC 1.11. 


92 4 29 075 


92-11777 


14. SUBJECT TERMS 

Ma programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17. SECURPTY CLASSIFICATION 
OF REPORT 
UNCLASSIFIED 


18. SECURITY CLASSIFICATION 

UNCLASSIFED 


19. SECURITY CLASSIFICATION 
OF ABSTRACT 

UNCLASSIFIED 


l». NUMOCn \jr 


16. PRICE CODE 


20. UMITATION OF ABSTRACT 


NSN 7540-01-280-550 


Standard Form 298, (Rev 2-89) 
Prescribed by ANSI Sid 239 128 































AVF Control Number: AVF-VSR-415.0891 

1 August 1991 
90-10-08-CCC 


Ada CC»!PILER 
VALIDATICXI SOraiARY REPORT: 

Certificate Number: 901130W1.11108 
Concurrent Conputer Corporation 
C3 Ada Version R03-00V 

Concurrent Computer Corporation 3280MPS under OS/32 Version R08-03.2 

(self-targeted) 


Prepared By: 

Ada Validation Facility 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 








DECLARATION OF CONFORMANCE 


Customer: Concurrent Computer Corporation 

Ada Validation Faeiiity: Wright Patterson Air Force Base, Ohio. 
ACVC Version: 1.11 


Ada Implementation: 

C ®Ada Version: R03-00V 

Concurrent Computer Corporation 3280 MPS 
under OS/32 Version R08-03.2 

Same as Host 


Customer’s Declaration 

I, the undersigned, representing Concurrent Computer Corporation, declare that Concurrent 
Computer Corporation has no knowledge of deliberate deviations from the Ada Language 
Standard ANSI/MIL-STD>1815A in the implementation listed in this declaration. I declare that 
Conctirrent Computer Corporation is the Implementor of the above implementation and the 
certificates shall be awarded in the name of Concurrent Computer Corporation’s corporate 
name. 

II y4.f/ fc' 

Seetharama Shastry (date) 

Senior Manager, System Software Development 


Compiler Name and Version: 
Host Computer System: 

Target Computer System: 





TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 


1.1 USE OF THIS VALIDATION SUMMARY REPORT.l-l 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 


CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 


CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT . 3_1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3_2 


APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 


















CHAPTER 1 


INTRODUCTICXa 


The Ada inplementation described above was tested according to the Ada 
Validation Procedures [Pro90} against the Ada Standard [Ada83] using the 
current Ada CcMr 5 )iler Validation Capability (ACVC). This Validation Summary 
Report (VSR) gives an account of the testing of this Ada inplementation. 

For any technical terms tised in this report, the reader is referred to 
[Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide (UG891. 


1.1 USE OF THIS VALinATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the conpaters, operating systems, and conpiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and conplete, or that the subject implementation has no 
nonconformities to the Ada standard other than those presented. Copies of 
this report are available to the public from the AVF vdiich performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 


Questions regarding this report or the validation test results should be 
directed to the AVF \dtich performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1-1 





INTRCaXJCnON 


1.2 REFERENCES 

[Adla83] Reference Manual for the Ada Programming Language, 

ANSI/MIL-STD-1615A, FeEruary 1983 and ISO 8652-1987. 

[Pro90] Ada Compiler Validation Procedures , Version 2.1, Ada Joint Program 
office, August 1990. 

(UG89] Ada Compiler Validation Capability User's Guide , 21 Jxane 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada inplementations is tested by means of the ACVC. Ihe ACVC 
contains a collection of test programs structured into six test classes: 

A, B, C, D, E, and L. The first letter of a test name identifies the class 
to v^ich it belongs. Class A, C, D, and E tests are executable. Class B 
and class L tests are expected to produce errors at conpile time and link 
time, respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result \ihen they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat some coirpiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. Ihe procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a conpiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code \^ich maist not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled imits. Errors 
are expected at link time, and execution is attempted. 

In S(xne tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to reimave unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 


1-2 








INTRODUCTION 


For each Ada inplementation, a customized test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragra^^, removing withdravm tests (see section 2.1) and, 
possibly some inacqplicable tests (see Section 2.2 and [UG89]). 

In order to pass an ACVC an Ada inqplementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Con?)iler Hie software and any needed hardware that have to be added 
to a given host and target computer system to allow 
tremsformation of Ada programs into executeible form and 
execution thereof. 

Ada Conpiler The means for testing compliance of Ada implementations, 
Validation consisting of the test suite, the support programs, the ACVC 
Capability user's guide and the template for the validation summary 

(ACVC) report. 

Ada An Ada compiler with its host computer system and its 

Implementation target computer system. 

Ada Joint The part of the certification body which provides policy and 
Program guidance for the Ada certification system. 

Office (AJPO) 

Ada Hie part of the certification body which carries out the 

Validation procedures required to establish the compliance of an Ada 
Facility (AVF) implementation. 

Ada The part of the certification body that provides technical 

Validation guidWice for operations of the Ada certification system. 

Organization 
(AVO) 

Compliance of The ediility of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer A functional unit, consisting of one or more computers and 

System associated software, that uses common storage for all or 

part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programis; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
ccmputer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 







INTKMXXn’ION 


Conformity 


Customer 


Declaration of 
Conformance 


Host Con^juter 
System 

Inapplicable 

test 

ISO 

LRM 


Operating 

System 


Target 

Coopjter 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


Fulfillment by a product, process or service of all 
requirements specified. 

An individual or corporate entity vrtio enters into an 
agreement with an AVF \diich specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

A fomal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A conputer system v^ere Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada inplementation. 

International Organization for Standardization. 

The Ada standard, or Language Reference Manual, published as 
ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRM take the form "<section>.<subsection>:<paragraph>." 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
conplete hardware implementations are possible. 

A computer system vdiere the executable form of Ada programs 
are executed. 


Ihe compiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro90]. 

The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada prograramiing 
language. 


1-4 











CHAPTER 2 

IMPLEMENTATICN DEPENDENCIES 


2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 12 October 1990. 


E28005C 

B28006C 

C34006D 

B41308B 

C43004A 

C45114A 

C45346A 

C45612B 

C45651A 

C46022A 

B49008A 

A74006A 

C7430aA 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

B85001L 

C83026A 

C83041A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 





2.2 INAPPLICABLE TESTS 

A test is inaj^licable if it contains test objectives which are irrelevant 
for a given Ada implementation. Reasons for a test's inapplicability may 
be supported by documents issued by ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
isplementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 






IHPLEMENIATIGM uEPEIlDE2«:iES 


The following 201 tests have floating-point type declarations requiring 
more digits than SYSTEM.MAX_DIGITS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


Hie following 21 tests check for the predefined type LONG_INTEGER; 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45612C 

C45613C 

C45614C 

0456310 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001W 

C86006C 


CD7101F 

C35702A, C35713B, C45423B, B86001T, and C86006H check for the predefined 
type SHORT_FLCAT. 


C35713D and B86001Z check for a predefined floating-point type with a 
name other than FLOAT, LONG FLOAT, or SHORT FLOAT. 


C41401A checks that CX3NSTRAINT ERROR is raised upon the evaluation of 
various attribute prefixes; this iinpl«nentation derives the attribute 
values from the subtype of the prefix at coopilation time, and thus does 
not evaluate the prefix or raise the exception. (See Section 2.3.) 

C45531H..P (4 tests) and C45532H..P (4 tests) check fixed-point 
operations for types that require a SYSTEM.MAX_MANTISSA of 47 or 
greater. 

C45624A checks that the proper exception is raised if MACHINE_OVERFLOWS 
is FALSE for floating point types with digits 5. For this 
implementation, MACHINEjOVERFLOHS is TRUE. 

C45624B checks that the proper exception is raised if MACHINEjOVERFLOWS 
is FALSE for floating point types with digits 6. For this 
implementation, MACHINEjOVERFLOMS is TRUE. 

B86001Y checks for a predefined fixed-point type other than DURATION. 


C86001F reconciles package SYSTEM, making package TEXT_IO, and hence 
package REPORT, obsolete. For this incleraentation, the package TEXT_lO 
is dependent icon package SYSTEM. 


C96005B checks for values of type DURATION'BASE that are outside the 
range of DURATION. Ihere are no such values for this ioclementation. 


2-2 







IMPLETENTATICW DEPENDENCIES 


CD1009C vises a representation clause specifying a non-default size for a 
floating-point type. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use representation 
clauses specifying non-default sizes for access types. 

BD8001A, BD8003A, BD8004A..B (2 tests), and ADSOll^ use machine code 
insertions. 

The tests listed in the following tedble are not applicable because the 
given file operations are not supported for the given combination of 
mode and file access method. 


Test 

File Operation Mode 

File Access Method 

CE2102D 

CREATE 

IN FILE 

SEQUENTIAL 10 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL 10 

CE2102F 

CREATE 

INOUT FILE 

DIRECT 10 

CE2102I 

CREATE 

IN FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAI 10 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

ItKXJT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT'lO 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

OUT FILE 

D1RECT_I0 

CE3102E 

CREATE 

IN_FILE 

TEXT_IO 

CE3102F 

RESET 

Any Mode 

TEXT_IO 

CE3102G 

DELETE 


TE3CT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT_IO 

CE3102J 

OPEN 

IN FILE 

TEXT_IO 

CE3102K 

OPEN 

OUT FILE 

TE3CT 10 


CE2107C..D (2 tests), CE2107H, and CE2107L apply fvinction NAME to 
temporary sequential, direct, and text files in an attempt to associate 
multiple internal files with the same external file; USE_ERROR is raised 
because temporary files have no name. 

CE2108B, CE2108D, and CE3112B use the neunes of tenporary sequential, 
direct, amd text files that were created in other tests in order to 
check that the temporary files are not accessible after the completion 
of those tests; for this implementation, temporary files have no name. 

CE2203A checks that WRITE raises USE_ERROR if the capacity of the 
external file is exceeded for SEQUENTIAL_I0. This implementation does 
not restrict file capacity. 








IHPLENENIATION DEPENDENCIES 


EE2401D checks v^ether DIRECT_IO can be instantiated for an element type 
that is an iinconstrained array type; this inplementation raises 
USE_ERROR on the attenpt to create a file, because the maximum potential 
element size exceeds the inplementation limit of 2**31 - 1 bits. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of the 
external file is exceeded for DIRECT_IO. This implementation does not 
restrict file capacity. 

CE3111B and CE3115A associate multiple internal text files with the same 
external file emd attenqpt to read from one file vdiat was written to the 
other, vdiich is assumed to be immediately available; this in^^lementation 
buffers output. (See section 2.3.) 

CE3202A expects that function NAME can be applied to the standard input 
and output files; in this inplementation these files have no names, and 
USE_ERROR is raised. (See section 2.3.) 

CE3304A checks that USE_ERROR is raised if a call to SET LINE LENGTH or 
SET_PAGE LENGTH specifies a value that is inappropriate Tor tEe external 
file. iKis inplementation does not have inappropriate values for either 
line length or page length. 

CE3413B checks that PAGE raises LAYOUT_ERROR vdien the value of the page 
number exceeds COUNT'LAST. For this inplementation, the value of 
COUNT'LAST is greater than 150000 making the checking of this objective 
inpractical. 


2.3 TEST MODIFICATIOJS 

Modifications (see section 1.3) were required for 12 tests. 

Ihe following six tests were split into two or more tests because this 
inplementation did not report the violations of the Ada Steuidard in the way 
expected by the original tests; 

B29001A BC2001D BC2001E BC3204B BC3205B BC3205D 

C34007P and C34007S were graded passed by Evaluation Modification as 
directed by the AVO. These tests include a check that the evaluation of 
the selector "all" raises CC»ISTRAINT_ERROR v^en the value of the object is 
null. This inplementation determines the result of the equality tests at 
lines 207 and 223, respectively, based on the subtype of the object; thus, 
the selector is not evaluated and no exception is raised, as allowed by LRM 
11.6(7). The tests were graded passed given that their only output from 
Report.Failed was the message "NO EXCEPTION FOR NULL.ALL - 2". 

C41401A was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test checks that the evaluation of attribute prefixes that 
denote variables of an access type raises CONSTRAINT_ERROR v^en the value 


2-4 







IMPLEMENTATIC»I DEPENDENCIES 


of the variable is null and the attribute is appropriate for an array or 
task type. This inplementation derives the array attribute values from the 
subtype; thus, the prefix is not evaluated and no exception is raised as 
allowed by LRM 11.6(7), for the checks at lines 77, 87, 106, 121, 131, 141, 
152, 165, and 175. 

CE3111B and CE3115A were graded inapplicable by Evaluation Modification as 
directed by the AVO. The tests assume that output from one internal file 
is unbuffered and may be immediately read by another file that shares the 
same external file. This inplementation raises END_ERROR on the attenpts 
to read at lines 87 and 101, respectively. 

CE3202A was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test applies function NAME to the standard input file, vhich 
in this implementation has no name; USE_ERROR is raised but not handled, so 
the test is aborted. The AVO ruled that this behavior is acceptable 
pending any resolution of the issue by the ARC. 


2-5 










CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada in^lementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact for technical information about this Ada 
inplementation system, see: 

Michael Devlin 
106 ^}ple Street 
Tinton Falls NJ 07724 
(201) 758-7531 

For a point of contact for sales information about this Ada inplementation 
system, see: 


Michael Devlin 
106 i^le Street 
Tinton Falls NJ 07724 
(201) 758-7531 


Testing of this Ada inplementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Inplementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
Language Standard, vrfiether the test is applicable or inapplicable; 
otherwise, the Ada Inplementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable and applicable), a resijlt was 
obtained that conforms to the Ada Programming Language Standard. 


3-1 








PROCESSING INFORMATION 


Total Number of ^plicable Tests 3799 

Total Number of Withdrawn Tests 81 

Processed Inapplicable Tests 89 

Non-Processed I/O Tests 0 

Non-Processed Floating-Point 

Precision Tests 201 

Total Number of Inapplicable Tests 290 


Total Number of Tests for ACVC 1.11 4170 


All I/O tests of the test suite were processed because this inplementation 
supports a file system. The above number of floating-point tests were not 
processed because they used floating-point precision exceeding that 
supported by the inplementation. 


3.3 TEST EXECUTKX} 

Version 1.11 of the ACVC comprises 4170 tests. When this coitpiler was 
tested, the tests listed in section 2.1 had been withdrawn because of test 
errors. Ihe AVF determined that 290 tests were inapplicable to this 
inplementation. All inapplicable tests were processed during validation 
testing except for 201 executable tests that use floating-point precision 
exceeding that supported by the implementation. In addition, the modified 
tests mentioned in section 2.3 were also processed. 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the vali^tion team for processing. The contents of the 
magnetic tape were transferred directly to the host machine. 


After the test files were loaded onto the host conputer, the full set of 
tests was processed by the Ada inplementation. 


The tests were conpiled and linked on the host conputer system, as 
appropriate. The executable images were transferred to the target conputer 
system by the communications link described above, and run. The results 
were captured on the host conputer system. 


Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a conplete listing of 
the processing options for this inplementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were: 


3-2 






PROCESSING INFORMATiraa 


Option 


Effect 


INFORM 


All the infonnation messages (if 
applicable) appear in the listing 
file. 


INLINE 

LIST 

OPTIMIZE 


PAGE SIZE 


SEGMENTED 


STACK CHECK 


SUMMARY 


WARN 


All the pragma Inline requests are 
honored (vdien applicable). 

A listing file is produced. 

The conpiler performs some 
optimizations to inprove 
nan-time efficiency of the 
program. 

Specifies that there will be X 
lines per page in the listing file. 
(Set at 60). 

The object code will contain both 
PURE (read only) and IMPURE (read 
and write) segments. 

The compiler generates extra code 
to check if there is enough stack 
space. 

Hie compiler generates a summary 
file v^en adaconp is used with 
$f ile_list_name. 

All the warning messages appear in 
the listing file. 


Hie listings were printed on a remote system via a remote shell call. Test 
output, compiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. Hie listings examined on-site by 
the validation team were also archived. 


3-3 







APPENDIX A 


macro parameters 


This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, v^ich is 
the value for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string aggregates, vdiere "V" represents the maximum input-line 
length. 


Macro Parameter 


Macro Value 


$MAX_IN_LEN 

$BIG_ID1 

$BIG_ID2 

$BIG_ID3 


255 

(1..V-1 -> 'A', V -> '1') 

(1..V-1 => 'A', V => '2 ') 
(1..V/2 -> 'A') & '3' & 
(1..V-1-V/2 => 'A') 


$BIG_ID4 

$BIG_INT_LIT 

$BIG_REAL_LIT 

$BIG_STRING1 

$BIG_STRING2 

$BLANKS 


(1..V/2 »> 'A') & '4' & 
(1..V-1-V/2 -> 'A') 

(1..V-3 -> '0') & "298" 

(1..V-5 -> ")') & "690.0" 

& (1..V/2 => 'A') & 

& (1..V-1-V/2 => 'A') & '1' & 

(1..V-20 => ' ') 


$MAX LEN_INT BASED_LITERAL 

"2:" & (1..V-5 -> '0') & "11;" 


$MAX_LEN_REAL_BASED_LITERAL 

"16;" & (1..V-7 -> '0') & "F.E;" 


A-1 







MACRO PARAMETERS 


$MAX_STRING_LITERAL & (1..V-2 -> 'A') & 

The following table lists all of the other macro parameters and their 
respective values: 

Macro Parameter Macro Value 


$ACC_SIZE 

32 

$ALIGNHENT 

4 

$COUNT_LAST 

(2**31)-l 

$DEFAULT_MEM_SIZE 

(2**24) 

$DEFAULT_STORJUNIT 

8 

$DEFAULT_SYS_NAME 

CCUR_3200 

$DELTA_DOC 

2#1.0#E-31 

$ENTRY_ADDRESS 

16#40# 

$ENTRY_ADDRESS1 

16#80# 

$ENTRY_ADDRESS2 

16#100# 

$FIELD_LAST 

255 

$FILE_TERMINATOR 

f r 

$FIXED_NAME 

NO_SUCH_FIXED_TYPE 

$FLQAT_NAME 

NO_SUCH_TyPE 

$FORM_STRING 

"RS->80" 

$PC3fRM_STRING2 

"CANI«7T_RESTRICT_FILE_CAPACITY' 


$GREATER_THAN DURATIC»I 

100000.0 

$GREATER THAN DURATIW BASE LAST 

T3107I.0 

$GREATER_THAN FLQAT_BASE LAST 

l.lE+63 

$GREATER_THAN_FLQAT_SAFE LARGE 

16fO.FFFFFA#E63 










MAC310 PARAMETERS 


$GREATER_THAN SHORT FLOAT SAFE LARGE 

0.0 

$HIGH_PRIORI'IY 255 

$ILLEGAL_EXTERNAL_FILE_NAME1 

\jNODIRECTORY\FILENAME 

$ILLEGAL_EXTERNAL_FILE_NAME2 

THIS_FILE_NAME_IS_TOO_LONG_FOR_My_SYSTEM 

$INAPPROPRIATE LINE LENGTH 

-1 

$INAPPROPRIATE PAGE LENGTH 

-1 

$INCLUDE_PRA(31A1 PRACMA INCLUDE ( "A28006D1 .TST" ) 

$INCLUDE_PRAGMA2 PRAGMA INCLUDE ("B28006D1.TST") 

$INTEGER_FIRST -2147483648 

$INTEGER_LAST 2147483647 

$INTEGER_LAST_PLUS_1 2147483648 

$INTERFACE_LANGUAGE PORTRAtT 

$LESS_'raAN_DURATIGN -75000.0 

$LESS_THAN_DURATIC»J BASE FIRST 

-131073.0 

$LINE_TERMINATOR ' ' 

$LOW_PRIORITY 0 

$MACHINE_CODE_STATEMENT 

NULL; 

$MACHINE_CCDE_TYPE NO_SUCH_TYPE 

$MANTISSA_DOC 31 

$MAX_DIGITS 15 

$MAX_INT 2147483647 

$MAX_INT_PLUS_1 2147483648 

$MIN INT 


-2147483648 






MACRO PARAMETERS 


$NAME 

TINY_1NTEGER 

$NAME_LIST 

CCUR_3200 

$NAME_SPECIFICATI0N1 

ACVC:X2120A./P 

$NAME_SPEC1FICATI0N2 

ACVC:X2120B./P 

$NAME_SPECIFICATION3 

ACVC:X3119A./P 

$NBG_BASED_INT 

16#FOOOOOOE# 

$NEW_MEM_SIZE 

(2**24) 

$NEW_STORJCJNIT 

8 

$NEW_SYS_NAME 

CCUR_3200 

$PAGEjrERMINATOR 

f r 

$RECORD_DEFINITIGN 

NE>7 INTEGER 

$RECORD_NAME 

NO_SUCH_MACHINE_CODEjrYPE 

$TASK_SIZE 

32 

$TASK_STORAGE_SIZE 

1024 

$TICK 

0.01 

$VARIABLE_ADDRESS 

16#0020« 

$VARIABLE_ADDRESS1 

16#0024# 

$VARIABLE_ADDRESS2 

16#0028# 

$YOUR_PRAGMA 

INLINE 


A-4 









APPENDIX B 


CC»1PIIATIC»« SYSTEM OPTIC»IS 


The compiler and linker options of this Ada inplementation, as described in 
this i^jpendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to conpiler and linker 
documentation and not to this report. 


Option 


Effect 


ABORT 

ALIST 

INFORM 

INLINE 

LIST 

OPTIMIZED 

PAGE_SIZE 

SEGMENTED 


If set, the conpiler stops compiling 
\dien an error is encountered in a unit 
and will not coitpile any subsequent 
units in the source file. 

If set, a symbolic assembly listing 
will be appended to the listing file. 

If set, all the information messages 
(if applicable) will appear in the 
listing file. 

If set, all the pragma Inline requests 
will be honored (when applicable). 

If set, a listing file will be produced. 

If set, the conpiler performs some 
optimizations to iitprove run-time 
efficiency of the program. 

The default specifies that there will 
be X lines per page in the listing 
file. 

If set, the object code will contain 
both PURE (read only) and IMPURE (read 
and write) segments. 


B-1 







CXXlPIIATiaj SYSTEM OPTICXJS 


Option Effect 


STACK_CHECK If set, the compiler generates extra 
code to check if there is enough 
stack space. 

SUMMARY If set, the conpiler generates a 

summary file when adaconp is used with 
a $file_list_name. 

SUPPRESS_ALL If set, the con 5 >iler will not generate 
any run-time checking code for all 
types and objects in the compilation; 
Access check, Discriminant_check, 
Index_check, Length_check, Overfiow_check, 
and Range_check. 

SUPPRESS_OVERFLOW 

If set, the Overflow checking code will 
not be generated by the compiler- 

WARN If set, all the warning messages will 

appear in the listing file. 


B-2 



APPENDIX C 

APPENDIX F OF THE Ada STANDARD 


The only allowed inplementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Qiapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses- The implementation-dependent 
characteristics of this Ada isplementation, as described in this ^pendix, 
are provided by the custcmer. Unless specifically noted otherwise, 
references in this ^ipendix are to compiler documentation and not to this 
report. Implementation-specific portions of the package STANDARD, which 
are not a part of ^pendix F, are: 


package STANDARD is 

• • • 

type INTEGER is range -2147483648 .. 2147483647; 
type TINy_INTBGER is range -128 .. 127; 
type SHORT_INrEGER is range -32768 .. 32767; 

type FLOAT is digits 6 range -16#0.FFFF_F8#E63 .. 16#0.FFFF_F8#E63; 
type LONG_FLQAT is digits 15 

range -16#0.FFFF_FFFF_FFFF_FE#E63 .. 16#0.FFFF_FFFF_FFFF_FE#E63; 

type DURATION is delta 0.00006103515625 

range -131072.00 .. 131071.99993896484375; 

end STANDARD; 


C-1 







APPENDIX F 

IMPLEMENTATION-DEPENDENT CHARACTERISTICS 


F.1 INTRODUCTION 

The following sections provide all implementation-dependent characteristics of the C^Ada 
compiler. 

F^ IMPLEMENTATION-DEPENDENT PRAGMAS 

The following is the syntax representation of a pragma: 

pragaa identifier [ (argument {, argument )) ]; 


Where; 

Identifier is the name of the pragma. 

argument defines a parameter of the pragma. For example, the LIST pragma 
expects the arguments on or off. 


PRAGMA 

IMPLEMENTED 

COMMENTS 

B1T_PACK 

Yes 

This pragma allows packing of composite 
objects to the bit level, thereby achieving 
greater data compaction. 

BYTE^PACK 

Yes 

The elements of an array or record are 
packed down to a minimal number of 
bytes. 

CONTROLLED 

No 

Not applicable because no automatic 
storage reclamation of unreferenced 
access objects is performed. 

ELABORATE 

Yes 

Is handled as defined by the Ada 
language. 

EXTERNAL_NAME 

Yes 

Defines the link-time name of a statically 
allocated object or subprogram. 

INLINE 

Yes 

Is handled as defined by the Ada 
language, with the following restrictions; 
T^e subprogram to be expanded inline 
must not contain declarations of other 
subprograms, task bodies, generic units, 
or body stubs. If the subprogram is called 
recursivelv. only the outer call is 
expanded. The subprogram must be 
previously compiled, and if it is a generic 
instance, it must be previously 
completed. 


48-424 FOO R03 


F-1 








PRAGMA 

IMPLEMENTED 

COMMENTS 

INTERFACE 

Yes 

Is implemented for ASSEMBLER and 
FORTRAN. 

LIST 

Yes 

Is handled as defined by the Ada 
language. 

MEMORy_SI2E 

No 

You cannot specify the number of 
available storage units m the machine 
configuration, which is defined in package 
SYSTEM. 

OPTIMIZE 

No 

You cannot specify either time or space 
as the primary optimization criterion. 
However, optimize is accepted as a 
compile-time option. 

PACK 

Yes 

The elements of an array or record are 
packed down to a minimal number of 
bits. 

PAGE 

Yes 

Is handled as defined by the Ada 
language. 

PARTIAL_IMAGE 

Yes 

This pragma informs the compiler that 
the named package may be used to build 
a partial image and causes the compiler 
to verify that the package meets all 
requirements for such use. 

PRIORITY 

Yes 

Is implemented as defined by the Ada 
language. 

REENTRANT_L1BRARY 

Yes 

This pragma informs the compiler that 
the unit may be used in a re-entrant 
library, sharing code but not data; the 
compiler checks that the unit meets all 
requirements for such use. 

SHARED 

Yes 

Is implemented as defined by the Ada 
language. 

STACK_CHECK 

Yes 

When specified with off, this pragma 
indicates to the compiler that there is 
enough space in the initial stack chunk 
for the activation record of the 
subprograms. Therefore, no code is 
generated to check for the need to 
provide additional space for the run-time 
stack of that subprogram. 

STORAGE_UNIT 

No 

You cannot specify the number of bits 
per storage unit, which is defined in 
package SYSTEM. 

SUPPRESS 

No 

Different types of checks cannot be 
switched on or off for specific objects; 
however, see suppress_all. 

SUPPRESS_ALL 

Yes 

This pragma allows the compiler to omit 
the generation of code to check for errors 
that may raise constraint_error or 
PROGRAM_ERROR that may be raised due to 
an elaboration order problem. 


48-424 FOO R03 




































PRAGMA 

IMPLEMENTED 

COMMENTS 

SYSTEM_NAME 

No 

You cannot alter the target system name, 
which is defined in package SYSTEM. 

VOLATILE 

Yes 

Specifies that every read and update of a 
variable causes a reference to the actual 
memory location of the variable. That is, 
a local copy of the variable is never made. 
This is similar to the pragma shared, 
except that any variable may be specified 
and that it does not cause 
synchronization of tasks. This pragma 
suppresses all optimizations on the 
specified variable. 


F.2.1 Pragma INLINE Restrictions 

Inline expansion of a subprogram call occurs if the foilowing conditions are satisfied: 


• If the subprogram body is not contained in the same compilation unit as the call, then 
the compilation unit containing the body must be successfully compiled before the unit 
containing the call. 

• The subprogram body and any enclosed declare blocks do not contain 

— declarations of subprograms. 

— declarations of task types or single tasks. 

— body stubs, or 

— generic instantiations. 

Note that if a call is ex’^anded inline in one compilation unit and the subprogram body is 
in another compilation •> it, then the former unit will be made obsolete if the latter unit is 
recompiled. 

For every call of a subprogram for which pragma INLINE is given, a warning message is 
reported if the above set of conditions is not satisfied; the message indicates that inline 
expansion is not done for the particular call. 

Inline expansion occurs when the expanded code contains a valid subprogram call. 
However, inline expansion is not carried out for a subprogram cali if inline expansion for 
the same subprogram is already in progress. e.g. for a recursive call. A warning message is 
generated informing the user of such a situation. 

Finally, when you specify pragma INLINE for procedures and/or functions in generic units, 
the compiler inlines calls to instances of them only if the bodies of the instances are 
already completed using the Completer. 

F.3 LENGTH CLAUSES 

A length clause specifies the amount of storage associated with a given type. The 
following is a list of the implementation-dependent attributes. 

TSIZE must be 32 for a type derived from FLOAT and 64 for a type derived 

from LONGJFLOAT. For array and record types, only the size chosen 
by the compiler may be specified. 

TST0RAGE_S1ZE is fully supported for collection size specification. 


48-424 FOO R03 


F-3 














TST0RAGE_S1ZE is not supported for task activation. Task memory is limited by the 
work space for the program. 

Size representation only applies to types - not to subtypes. In the following example, the 
size of T is 32. but the size of T1 is not necessarily 32. 

type T is range 0..100; 
subtype H is T range 0. .10; 
for T'SIZE use 32; 

In the following example, the size of the subtype is the same as the size of the type (size 
of the type is applied to the subtype). 

type T is range 0..100; 
for T'SIZE use 32; 
subtype T2 is T range 0..10; 


F.4 REPRESENTATION ATTRIBUTES 

The Representation attributes listed below are as described in the Refen ice Manual for 
the Ada® Programming Language, Section 13.7.2. 


X’ADDRESS 

X’SIZE 

R.C’POSmON 

R.C*FIRST_B1T 

R.C*LAST_BIT 

rSTORAGE_SIZE 


rSTORAGE_SIZE 


is not supported for labels and packages, 
is handled as defined by the Ada Language, 
is handled as defined by the Ada Language, 
is handled as defined by the Ada Language, 
is handled as defined by the Ada Language. 

for access types, returns the current amount of storage reserved for 
the type. If a TST0RAGE_S1ZE representation clause is specified, 
then the amount specified is returned; otherwise, the current amount 
allocated is returned. 

f 

for task types or objects is not implemented. It returns 0. 


F.4.1 Representation Attributes of Real Types 


P’DIGITS yields the number of decimal digits for the subtype P. This value is 6 

for type FLOAT and 15 for type LONG_FLOAT. 

P’MANTISSA yields the number of binary digits in the mantissa of P. The value is 21 

for type FLOAT and 51 for type LONG_JLOAT. 


DIGITS 

MANTISSA 

DIGITS 

MANTISSA 

DIGITS 

MANTISSA 

1 

5 

6 

21 

11 

38 

2 

8 

7 

25 

12 

41 

3 

11 

8 

28 

13 

45 

4 

15 

9 

31 

14 

48 

5 

18 

10 

35 

15 

51 


F-4 


48*424 FOO R03 







P’EMAX yields the largest exponent value of model numbers for the subtype P. 

The value is 84 for type FLOAT and 204 for type LONG_FLOAT. 


DIGITS 

EMAX 

DIGITS 

EMAX 

DIGITS 

EMAX 

1 

20' 

6 

84 

11 

152 

2 

32 

7 

100 

12 

164 

3 

44 

8 

112 

13 

180 

4 

60 

9 

124 

14 

192 

5 

72 

10 

140 

15 

204 


P’EPSILON yields the absolute value of the difference between the model number 

1.0 and the next model number above for the subtype P. The value is 
16#0.0000_1# for type FLOAT and 16#0.0000_0000_0000_4# for type 
LONG_FLOAT. 


DIGITS 

EPSILON 

DIGITS 

EPSILON 

DIGITS 

_EPSILON 

1 ' 

16#0.1#EO0 

6 

16#0.1#E-4 

11 

16#0.8#E-9 

2 

16#0.2#E-1 

7 

16#0.1#E-5 

12 

I6#0.1#E-9 

3 

16#0.4#E-2 

8 

16#0.2#E-6 

13 

16#0.1#E-10 

4 

16#0.4#E-3 

9 

16#0.4#E-7 

14 

16#0.2#E-11 

5 

16#0.8#E-4 

10 

16#0.4#E-8 

15 

16#0.4#E-12 


P’SMALL yields the smallest positive model number of the subtype P. The value 

is 16#0.8#E-21 for type FLOAT and 16#0.8#E-51 for type LONG_FLOAT. 


VALUES 

SMALL 

VALUES 

SMALL 

VALUES 

SMALL 

1 

16#0.8#E-5 

6 

16#0.8#E-21 

11 

16#0.8#E-38 

2 

16#0.8#E-8 

7 

16#0.8#E-25 

12 

16#0.8#E-41 

3 

16#0.8#E-11 

8 

16#0.8#E*28 

13 

16#0.8#E-45 

4 

16#0.8#E-15 

9 

16#0.8#E-31 

14 

16#0.8#E-48 

5 

16#0.8#E-18 

10 

16#0.8#E-35 

15 

16#0.8#E-51 


P’LARGE yields the largest positive model number of the subtype P. The value is 

16#0.FFFF^F8#E21 for type FLOAT and 16#0.FFFF_FFFF_FFFF_E#E51 for 
type LONG_FLOAT. 


VALUES 

LARGE 

1 

16#0.F8#E5 

2 

16#0.FF#E8 

3 

16#0.FFE#E11 

4 

16#0.FFFE#E15 

5 

16#0.FFFF_C#E18 

6 

16#0.FFFF_F8#E21 

7 

16#0.FFFF_FF8#E25 

8 

16#0.FFFF_FFF#E28 

9 

16#0.FFFF.FFFE#E31 

10 

16#0.FFFFJ'FFF_E#E35 

11 

16#0.FFFFJ'FFFJ^C#E38 

12 

16#0.FFFF_FFFFJ"F8#E41 

13 

16#0.FFFF«FFFFJ^FF8#E45 

14 

16#0.FFFF_FFFFJ'FFF#E48 

15 

16#0.FFFF_FFFFJ'FFF_E#E51 


48-424 FOO R03 


F-5 








P’SAFE_EMAX yields the largest exponent value of safe numbers of type P, The value 
is 252 for types FLOAT and LONG_FLOAT. 

P’SAFE-SMALL yields the smallest positive safe number of type P. The value is 
16#0.8#E-63 for types FLOAT and LONG_FLOAT. 

P'SAFE-LARGE yields the largest positive safe number of the type P. The value is 
16#0.FFFF_F8#E63 for type FLOAT and 16#0.FFFF_FFFF_FFFF_FE#E63 
for type LONG_FLOAT. 

P'MACHINE_ROUNDS is true. 

FMACHINE_OVERFLOWS is true. 

P'MACHINE.RADIX is 16. 

P’MACHINE-MANTISSA is six for types derived from FLOAT; else 14. 

P’MACH1NE.EMAX is 63. 

P’MACH1NE_EM1N is -64. 

F.4.2 Representation Attributes of Fixed Point Types 
For any fixed point type T, the representation attributes are; 

rMACHINE_ROUNDS true 

TMACHINE-OVERFLOWS true 
TMANTISSA 1..31 

rSlZE 2..32 

FAS Enumeration Representation Ciauses 

The maximum number of elements in an enumeration type is limited by the maximum size 
of the enumeration image table which cannot be greater than 65535 bytes. The 
enumeration table size is determined by the following function: 

generic 

type ENUMERATION_TYPE is (<>); 
fiinction ENUM£;RATI0N_TABL£_SIZE return NATURAL is 
RESULT : NATURAL :-0; 
begin 

for I in ENUMERATION_TYPE 'FIRST..ENUMERATION_TYPE' LAST loop 
RESULT -.-RESULT + 2 I'WIDTH ; 
end loop; 
return RESULT; 
end ENUMERATION_TABLE_SIZE; 

FA4 Record Representation Ciauses 

The Reference Manual for the Ada9 Programming Language states that an implementation 
may generate names that denote implementation-dependent components. This is not 
present in this release of the C^Ada compiler, implementation-dependent offset 
components are created for record components whose size is dynamic or dependent on 
discriminants. These offset components have no names. 

Record components of a private type cannot be included in a record representation 
specification. 

Record clause alignment can only be 1.2. or 4. 

Component representations for access types must allow for at least 24 bits. 


F«6 


48-424 FOO R03 



Component representations for scalar types other than for types derived from 
LONG^FLOAT must not specify more than 32 bits. 

FAS Type DURATION 

DURATION’SMALL equals 61.035/iS or 2 '^ seconds. This number is the smallest power of 
two which can still represent the number of seconds in a day in a fullword fixed point 
number. 

System.tick equals 10ms. The actual computer clock-tick is 1.0/120.0 seconds (or about 
8.33333ms) in 60Hz areas and 1.0/100.0 seconds (or 10ms) in 50Hz areas. System.tick 
represents the greater of the actual clock-tick from both areas. 

DURATION’SMALL is significantly smaller than the actual computer clock-tick. Therefore, 
the least amount of delay possible is limited by the actual clock-tick. The delay of 
DURATION’SMALL follows this formula: 


<actual-clock-tlck> ± <actual-clock-tick> + 1.3fis 

The 1.3/iS represents the overhead or the minimum delay possible on a 3280MPS. For 60Hz 
areas, the range of delay is approximately from 1.3ms to 17.97ms. For 50Hz areas, the range 
of delay is approximately from 1.3ms to 21.3ms. However, on the average, the delay is 
slightly greater than the actual clock-tick. 

In general, the formula for finding the range of a delay value, x, is: 

ncflrest_mu/ffp/e(x,<actual-clock-tick>) ± <actual-clock-tlck> + 1.3ms 
where nearesL.multiple rounds x up to the nearest multiple of the actual clock-tick. 

TABLE F-1. TYPE DURATION 


ATTRIBUTE 

VALUE 

APPROXIMATE 

VALUE 

DURATION’DELTA 

2#1.0#E-14 

s: 61 mS 

DURATION’SMALL 

2#1.0#E-14 

61 ms 

DURATION’FIRST 

-131072.00 

~ 36 hrs 

DURATION’LAST 

131071.99993896484375 

36 hrs 

DURATION’SIZE 

32 



F.5 ADDRESS CLAUSES 

Address clauses are Implemented for objects. No storage is allocated for objects with 
address clauses by the compiler. The user must guarantee the storage for these by some 
other means (e.g., through the use of the absolute Instruction found In the Common 
Assembly Language/32 (CAL/32) Reference Manual). The exception PROGRAM_ERROR is 
raised upon reference to the object if the specified address is not in the program’s address 
space or is not properly aligned. 

Address clauses are supported for task entries. If an address clause is specified for 
subprograms, packages, task objects, or task units, the compiler will generate a restriction 
error. I 

An address clause applied to a task entry enables an operating system trap to initiate an I 
entry call to that entry. The address specified is an address clause for a task entry can be I 
done via a function call interrupt_address with oueue_event as its argument. Function I 


48-424 FOO R03 


F-7 






INTERRUPT_ADDRESS is Specified in package 0S_32_REAL_T1ME_SERVICES. 

Initialization of an object that has an address clause specified Is not supported. Objects 
with address clauses may also be used to map objects into task common (TCOM) areas. 
See Chapter 4 for more information regarding task common. 

F.6 THE PACKAGE SYSTEM 

The package SYSTEM, provided with the C’Ada system, permits access to machine- 
dependent features. TTie specification of the package SYSTEM declares constant values 
dependent on the Series 3200 Processors. The following is a listing of the visible section 
of the package SYSTEM specification. 

package SYSTEM is 

type DESIGNATED_BY_ADDRESS is private; 

type ADDRESS is access DESIGNAT£D_BY_ADDRESS; 

ADDRESS_ZERO : constant ADDRESS NULL; 

ADDRESsInULL : constant ADDRESS NULL; 

fiUiction "+" (LEFT : ADDRESS; RIGHT : INTEGER) return ADDRESS; 

function "+" (LEFT : INTEGER; RIGHT : ADDRESS) return ADDRESS; 

function (LEFT : ADDRESS; RIGHT : INTEGER) return ADDRESS; 

function {LEFT : ADDRESS; RIGHT : ADDRESS) return INTEGER; 

type NAME is (CCUR_3200); 

SYSTEM_NAME : constant NAME CCUR_3200; 

STORAGE_UNIT : constant :■ 8; 

MEMORy_SIZE ; constant 2 ** 24; 

MIN_INT : constant :• - 2_147_483_648; 

MAX~INT : COnstMt :• 2_147_483_647 ; 

MAX_DIGITS : constant :■ 15; 

MAxImANTISSA ? constant ;« 31; 

FINE_DELTA s constant :• 2.0 (-31); 

TICK : constant 0.01; 

typo UNSIGNED_SHORT_INTEGER is range 0 .. ’65_535; 

typo UNSIGNED_TINY_nra'EGER is range 0 .. 255; 

for UNSlGNED_SHORT_INTEGER'size use 16; 

for UNSIGNEDlTINY_INTEGER'size use 8; 

subtype BYTE is UNS1GNED_TINY_INTEGER; 

subtype ADDRESS_RANGE is'lNTEGER range 0 .. 2**24-l; 

subtype PRIORITY is INTEGER range 0 .. 255; 

type SEMAPHORE_MODE is (NOT_EXECUTED, EXECUTED); 

type SEMAPHORE is private; 

—These functions are for conpatibility with previous versions of 
—C3Ada, and should be replaced with calls to unchecked_conversion. 
function COPY_DOUBLEWORD (FROM: LONG_FLOAT) return LONG_FLOAT; 

pragma INLINE (COPY_DOUBLEWORD); 
function COPY_FULLWORD (FROM: INTEGER) return ADDRESS; 

pragma INLINE (COPY_FULLWORD); 
function COPY_FULLWORD (FROM: ADDRESS) return INTEGER; 
pragma INLINE (COPY_FULLWORD) ; 

function COPY^HALFWORD (FROM: SHORT_INTEGER) return SHORT^INTEGER; 
pragma INLINE (C0PY_HALFW0RD); 

function COPY_BYTE (FROM : TINY_INTEGER) return TINY_INTEGER; 

pragma INLINE (C0PY_BYTE); 
function MEMORY_USED return NATURAL; 

pragma INTERFACE (ASSEMBLER, MEMORY_USED); 
function HEAP USED return NATURAL; 


F-8 


48*424 FOO R03 









pragma INTERFACE (ASSEMBLER, HEAP_USED); 

—Address conversion routines 

function INTEGER_TO_ADDRESS (ADDR : ADDRESS_RANGE) return ADDRESS 
renames COPY_FULLNORD; 

function ADDRESS_TO_INTEGER (ADDR : ADDRESS) return ADDRESS_RANGE 
renames COPY_FULLWORD; 

procedure EXECUTE_OR_WAIT (S: in out SEMAPHORE; S_MODE: out SEMAPHORE); 
procedure COMPLETiD_EXECUTION (S: in out SEMAPHORE); 
procedure RESET_SEMAPHORE (S: in out SEMAPHORE); 

type EXCEPTION_ID IS new INTEGER; 

NO_EXCEPTION_ID : constant EXCEPTION_ID 0; 

type EXIT_CODE is new INTEGER range 0..235; 

ERROR : constant EXIT_CODE :■ 254; 

SUCCESS : constant EXIT_C0DE 0; 

function LAST_EXCEPTION_ID return EXCEPTI0N_1D; 


CONSTRAINT_ERROR_ID : constant EXCEPTION_ID 
implementation defined 

NUMERIC_ERROR_ID : constant EXCEPTION_ID 

implementation defined 

PROGRAM_ERROR_ID : constant EXCEPTION_ID 

i- implementation defined 

STORAGE_ERROR_ID ; constant EXCEPTION_ID 

•m implementation defined 

TASKING_ERR0R_1D ! constant EXCEPTION^ID 

■m implementation defined 

STATUS_ERROR_ID : constant EXCEPTION_ID 

•a implementation defined 

M0DE_ERR0R_ID : constant EXCEPTION_ID 

;a implementation defined 

NAME_ERROR_ID : constant EXCEPTION_ID 

:■> implementation defined 

USE_ERROR_ID : constant EXCEPTION_ID 

;m implementation defined 

DEVICE_ERROR_ID : constant EXCEPTION_ID 

;a implementation defined 

END_ERROR_ID : constant EXCEPTION_ID 

:•> implementation defined 

DATA_ERROR_ID : constant EXCEPTION_ID 

;a implementation defined 

LAYOUT_ERROR_ID : constant EXCEPTION_ID 

;a implementation defined 


48-424 FOO R03 


F-9 








T1ME_ERR0R_ID : constant EXCEPTION_ID 

implementation defined 

function MEMORY_USED return NATURAL; 
function HEAP_USED return NATURAL; 

private 

— Implementation defined 

type SEMAPHORE is 
record 

SEMA_OBJ : INTEGER 0; 
end record; 

pragma INTERFACE (ASSEMBLER, EXECUTE_OR_WAIT); 
pragma INTERFACE (ASSEMBLER, COMPLETED_EXECUTION); 
pragma INTERFACE (ASSEMBLER, RESET_SEMAPHORE); 

end SYSTEM; 

F.7 INTERFACE TO OTHER LANGUAGES 

Pragma INTERFACE is implemented for two languages. Assembly and FORTRAN. The 
pragma can take one of three forms: 

• For any Assembly language procedure or function: 

pragma INTERFACE (ASSEMBLER, ROUTINE_NAME); 


• For FORTRAN functions with only in parameters or procedures: 

pragma INTERFACE (FORTRAN, ROUTINE_NAME); 


• For FORTRAN functions that have in out or out parameters: 

pragma INTERFACE (FORTRAN, ROUTINE_NAME, IS_FUNCTION); 


In the C^Ada system, functions cannot have in out or out parameters so the Ada 
specification for the function is written as a procedure with the first argument being the 
function return result. Then, the parameter lS_FUNCnON is specified to inform the 
compiler that it is. in reality, a FORTRAN function. Interface routine_names are truncated 
to an 8 character maximum length. 

F.8 INPUT/OUTPUT (I/O) PACKAGES 

The following two system-dependent parameters are used for the control of external files: 

• NAME parameter 

• FORM parameter 

The NAME parameter must be an OS/32 filename string. Figure F-1 illustrates the four 
fields in an OS/32 file descriptor. 


F-10 


48*424 FOO R03 






424 - 3-1 


I voln : 

filename . 

, ext t 

' acct 









ONE- TO nVE-DIGIT DECIMAL ACCOUNT 
OR CLASS P. G, OR S 


SLASH 


ONE- TO THREE-ALPHANUMERIC 
CHARACTER EXTENSION 


‘ - - - m period 

- ONE- TO EIGHT-ALPHANUMERIC CHARACTER RLENAME 
RRST CHARACTER MUST BE ALPHABETIC 

-- COLON 

ONE- TO FOUR-CHARACTER ALPHANUMERIC VOLUME NAME 
FIRST CHARACTER MUST BE ALPHABETIC 


Figure F-1. OS/32 RIe Descriptor 


The implementation-dependent values used for keywords in the FORM parameter are 
discussed below. The FORM parameter is a string that contains further system-dependent 
characteristics and attributes of an external file. The FORM parameter conveys to the file 
system Information on the intended use of the associated external file. This parameter is 
used as one of the specifications for the CREATE procedure and the OPEN procedure. It 
specifies a number of system-dependent characteristics such as lu, file format, etc. It is 
returned by the FORM function. 

The syntax of the FORM string, in our implementation, uses Ada syntax conventions and is 
as follows: 


foxm_parasi 

form_spec 


lu^spec 

fo__spec 

rs_spec 

dbf_spec 

ibf_spec 

al_spec 

pr^spec 

keys_spec 

pad_^spec 

dc_spec 

da_spec 

ds^spec 

ps_spec 

ch__spec 


Ifonn_spec [, form_spec)] 

: :- lu_spec 1 fo_spec | 
rs_spec I dbf_spec | 
ib£_spec | al_spec j 
pr_spec I keys_spec | 
pad_spec 1 dc_spec | 
da_spec | ds_spec | 
ps^spec I ch_spec 
LU~-> lu 

FILE_ORGANIZATION -> fo 
RECORD_SIZE -> KS 
DATA_BLOCKING_FACTOR -> dbf 
INDEX_BLOCKING_FACTOR -> Ibf 
: ALLOCATION -> Ol 

PRIVILEGE -> pr 
: KEYS -> keys 

: PAD -> pud 

DEVICE_CODE •> dc 
DEVICE_ATTRIBUTE -> do 
DEVICE_STATUS ds 
: : - PROMPTiNG_STRING -> pS 
: :- CHARACTER 10 


48-<424 FOO R03 


F-11 











TTie exception USE.ERROR is raised if a given FORM parameter string does not have the 
correct syntax or if certain conditions concerning the OPEN or CREATE statements are not 
fulfilled. Keywords that are listed above in upper-case letters are also recognized by the 
compiler in lower-case. 


lu is an integer in the range 0-254 specifying the lu number. 

fo specifies legal OS/32 file formats (file organization). They are: 

INDEX I IN 

CONTIGUOUS 1 CO 

NON_BUFFERED | NB 

EXTiNDABLE_CONTIGUOUS 1 EC 

LONG_RECORD 1 LR 

ITAM 

DEVICE 

rs is an integer in the range 1-65535 specifying the physical record size. 

• For INDEX, ITAM, and. NON_BUFFERED files, this specifies the 
physical record size. 

• The physical record size for CONTIGUOUS and 
EXTENDABLE_CONTIGUOUS files is determined by rounding the 
element size up to the nearest 256-byte boundary. For such files, rs 
is ignored. 

• The physical record size for LONG_RECORD files is specified by the 
data blocking factor multiplied by 256 and rs is ignored. 

• For a DEVICE, the physical record size always equals the element 
size and rs is ignored. 


dbf specifies the data blocking factor. An integer in the range 0-255 

(maximum set up at OS/32 system generation (sysgen) time) that 
specifies the number of contiguous disk sectors (256 bytes) in a data 
block. It applies only to INDEX, NONJUFFERED. 
EXTENDABLE_CONTIGUOUS. and LONG_RECORD files. For other file 
organizations (see fo above), it is ignored. The default is 0. which 
causes the data blocking factor to be set to the current OS/32 default. 

ibf specifies the index blocking factor. An integer in the range 0-255 

(maximum set up at OS/32 sysgen time) specifying the number of 
contiguous disk sectors (256 bytes) in an index block of an INDEX, 
NONJUFFERED, EXTENDABLE_CONTIGUOUS. or LONGJIECORD file. 
The default is 0, which causes the index blocking factor to be set the 
current OS/32 default. For other file organizations (see fo). it is 
ignored. 

al specifies an integer in the range 1-2«147«483_647. For CONTIGUOUS 

files, it specifies the number of 256-byte sectors to be allocated. For 
ITAM files, it specifies the physical block size in bytes associated with 
the buffered terminal. For other file organizations (see fo), it is 
ignored. 

pr specifies OS/32 access privileges, i.e., SRO, ERO, SWO. EWO, SRW, SREW, 

ERSW, and ERW. 

keys is a decimal or hexadecimal integer specifying the OS/32 READ/WRITE 

keys, in range 16#0000# - 16#FFFF# (0-65535). The left two 
hexadecimal digits signify the write protection key and the right two 
hexadecimal digits signify the read protection key. 


F-12 


48-424 FOO R03 






pad specifies the padding character used for READ and WRITE operations; 

the pad character is either NONE, BLANK, or NUL The default is NONE 

If the pad characters are- NONE, the records are not padded. If NUL, 
records are padded with ASCll.NULL If BLANK, records au'e padded 
with blank and OS/32 ASCII I/O operations are used. 

dc is an integer in the range 0..255 specifying the OS/32 device code of 

the external file. See the System Ceneration/32 (Sysgen/32) Reference 
Manual for a list of all devices and their respective codes. A device 
code specifier is ignored for OPEN or CREATE requests. See function 
FORM in Section 12.5.9. 

da Is an Integer in the range 0..65535 specifying the OS/32 device 

attributes of the external file. See the OS/32 Supervisor Call (SVC) 
Reference Manual (the table on description and mask values of the 
device attributes field). A device attribute specifier is ignored for OPEN 
or CREATE requests. See function FORM in Section 12.5.9. 

ds is an integer in the range 0^65535 specifying the status of the external 

file. A status of 0 means that the access to the file terminated with no 
errors; otherwise, a device error occurred. For errors occurring during 
READ and WRITE operations, the status values and their meanings are 
found in Chapter 2 of the OS/32 Supervisor Call (SVC) Reference 
Manual (the tables on device-independent and device-dependent status 
codes). A device status specifier is ignored for OPEN or CREATE 
requests. See function FORM in Section 12.5.9. 

ps is a string of up to 80 characters, enclosed in quotation marks (“ ”), 

that specifies the prompting string. Embedded quotation marks must 
be doubled. (See Section 12.6.1 on CREATE and OPEN for TEXTJO for 
more information.) For example: 


form •> "prompting_stxing ->"*’Pxocess 1"”’ 


F.8.1 Text Input/Output (I/O) 

There are two implementation-dependent types for TEXTJO: COUNT and FIELD. Their 
declarations implemented for the C^Ada compiler are as follows: 

type COUNT is range 0 ..INTEGER'LAST; 
subtype FIELD is INTEGER range 0 ..512; 


F.8.1.1 End of File Markers 

In this implementation, the line terminator, page terminator and file terminator are not I 
represented as a sequence of ASCII control characters. 

F.8.2 Restrictions on ELEMENTJTYPE 

The following are the restrictions concerning ELEMENT_TYPE 

• I/O of access types is undefined, although allowable; i.e., the fundamental association 
between the access variable and its accessed type is ignored. 

• The maximum size of a variant data type is always used. 

• If the size of the element type is exceeded by the physical record length, then during a 
READ operation the extra data on the physical record is lost. The exception 
DATAJERROR is not raised. 


48-424 FOO R03 


F-13 





• If the size of the element type exceeds the physical record length during a WRITE 
operation, the extra data in the element is not transferred to the external file and 
DATA^ERROR is not raised. 

• SEQUENTIALJO and DIRECTJO can be instantiated with unconstrained types. However, 
this causes the file to have a record length that is the maximum size of the 
unconstrained type. If this record length is larger than what is supported for the type 
of file involved, the exception USE^ERROR is raised. 

• I/O operations on composite types containing dynamic array components will not 
transfer these components because they are not physically contained within the record 
itself. 

F.a3 TEXT Input/Output (I/O) on a Terminal 

A line terminator is detected when an ASCII.CR is input or output or the operating system 
detects a full buffer. No spanned records with ASCII.NUL are output. 

A line terminator followed by a page terminator may be represented as; 

ASCII.CR 

ASCII.FF ASCII.CR 

if they are issued separately by the user. e.g.. NEW_L1NE followed by a NEW_PAGE. The 
same reasoning applies for a line terminator followed by a page terminator, which is then 
followed by a file terminator. 

All text I/O operations are buffered unless form CHARACTER_10 is specified. This means 
that physical I/O operations are performed on a line by line basis, as opposed to a 
character by character basis. For example: 

put ("Enter Data") / 
get^iine (data, len): 

will not output the string "Enter Data" until the next PUT_LINE or NEW_L1NE operation is 
performed. 

F.9 MACHINE CODE INSERTIONS 
Code statements are not supported. 

F.10 UNCHECKED PROGRAMMING 

Unchecked programming gives the programmer the ability to circumvent some of the 
strong typing and elaboration rules of the Ada language. As such, it is the programmer's 
responsibility to ensure that the guidelines provided in the following sections are 
followed. 

F.10.1 Unchecked Storage Deallocation 

The unchecked storage deallocation generic procedure explicitly deallocates the space for 
a dynamically acquired object. 

Restrictions; 

This procedure frees storage only if; 

• the object being deallocated was the last one allocated of ail objects in a given 
declarative part; or 


F-14 


48-424 FOO R03 







• all objects In a single chunk of the collection belonging to all access types declared in 
the same declarative part are deallocated. 

F.10^ Unchecked Type Conversions 

The unchecked type conversion generic function permits the user to convert, without type 
checking, from one type to another. It is the user’s responsibility to guarantee that such a 
conversion preserves the properties of the target type. 

Restrictions: 

The object used as the parameter in the function may not have components which contain 
dynamic or unconstrained array types. 

If the TARGETSIZE is greater than the SOURCE'SIZE, the resulting conversion is 
unpredictable. If the TARGETSIZE is less than the SOURCE’SIZE. the result is that the left¬ 
most bits of the source are placed in the target. 

Since UNCHECKED_C0NVERS10N is implemented as an arbitrary block move, no alignment 
constraints are necessary on the source or the target operands. 

F.11 IMPLEMENTATION-DEPENDENT RESTRICTIONS 

• The main procedure must be parameterless. 

• The source line length must be less than or equal to 255 characters. I 

• Due to the source line length, the largest identifier is 255 characters. 

• No more than 65534 lines per compilation unit. 

• The maximum number of library units is 16380. I 

• The maximum number of bits in an object is 2’’ -1. 

• The maximum static nesting level is 63. 

• The maximum number of directly imported units of a single compilation unit must not I 
exceed 1024. 

• Recompilation of SYSTEM or CALENDAR specification is prohibited. 

• ENTRY’ADDRESS. PACKAGE’ADDRESS. and LABEL'ADDRESS are not supported. 

• The maximum number of nested SEPARATES is 511. 1 

• The maximum length of a filename is 80 characters. 

• The maximum length of a program library name is 64 characters. 

• The maximum length of a listing line is 132 characters. I 

• The maximum number of errors handled is 1000. 

• The maximum subprogram nesting level is 64. 

• The maximum number of calls to pragma ELABORATE per compilation unit is 1024. I 

• The total size for text of unique symbols (including imported symbols) per compilation I 
is 300000. 

• The maximum parser stack depth is 10000. 

• The maximum depth of packages is 511. I 

• The static aggregate nesting limit is 256. 

F.12 UNCONSTRAINED RECORD REPRESENTATIONS 

Objects of an unconstrained record type with array components based on the discriminant 
are allocated using the discriminant value supplied in the object declaration. If the size of 


48-424 FOO R03 


F-15 








an unconstrained component has the potential of exceeding 2Gb. the exception 
NUMERICLERROR is raised. Assignment of a default maximum discriminant value does not 
occur. For example: 

type DYNAMIC_STRING( LENGTH : NATURAL 10 ) 
is record 

STR : STRING( 1 .. LENGTH ); 
end record; 

DSTR : DYNAMIC_STRING; 

For this record, the compiler attempts to allocate NATURAL’LAST bytes for the record. 
Because this is greater than 2Gb, the exception NUMER1C_ERR0R is raised. However, the 
declaration 

D : DYNAM1C_STRING{80); 

raises no exception and creates a record containing an 80-byte string. 

F.13 TASKING IMPLEMENTATION 

The C*Ada system implements fully pre-emptive and priority-driven tasking. Pre-emptive 
means that task switches may take place even when the currently running task does not 
voluntarily give up processor control. This may happen when a task with a high priority is 
waiting on an external event (the time period specified in a delay statement expires). 
When this event occurs, processor control is passed to the waiting task immediately if it 
has the highest priority of the tasks ready to run. 

The C^Ada run-time system keeps track of ail tasks In two categories: tasks which are 
ready to run and those that are suspended because they are waiting for something (e.g.. a 
rendezvous to occur or waiting in a delay statement). The tasks ready to run are sorted in 
a queue by priority (high priorities first). Within one priority, they are sorted in the order 
in which they entered the "ready" state (tasks waiting longer are served first). Whenever 
the run-time system needs a task to schedule, the first task In the queue is selected and 
run. 

The accuracy of delay statements is governed by the resolution of the operating system 
clock which is 1.0/100.00 seconds (or 10ms) in 50 Hz areas and 1.0/120.0 in 60 Hz 
(SYSTEM.tick). Although the resolution of the type duration is much higher (2*'^ 
seconds), task switches caused by the expiration of a delay can only take place on a clock 
tick. A task waiting in a delay enters the "ready” state when the next clock tick after its 
delay period has expired. 

There is only one OS/32 task for all Ada tasks in this model. 

Tasks that depend on library packages continue to execute when the main program 
terminates. However, when the main program terminates due to an unhandled exception, 
the tasks will be terminated thereafter. 

F.14 NUMERIC ERROR I 

The predefined exception NUMERlC_ERROR is never raised implicitly by any predefined I 
operation; Instead, the predefined exception CONSTRAINT_ERROR is raised. 


F-16 


48-424 FOO R03 









