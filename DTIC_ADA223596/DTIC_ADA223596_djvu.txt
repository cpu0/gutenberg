DTIC FILE m • . 

NTATION PAGE 

AD-A223 596 

M mm IiIdV. PC aBMl 




FomAppnvd 
OPMNo: 0704^188 


r REPORT DATE 


tmmmammmrn 


«■ R EP ORT TYPE AlC OWES COVERED 

Final 15 June 1989 to 15 June 1990 


4.7Tll£AM)MTrTLE Ada Compiler Validation Summary Report: Data 
General, ADE, Revision 3.01, MV 15000 (Host) to MV 15000 (Target 
890615S1.10126 


•.AllTH0R(S) 

National Institute of Standards and Technology 

Gaithersburg, MD 

USA 


7. PERF0RMM6 ORQAMZKnON NMilE(S) AND ACX)RESS(ES) 

National Institute of Standards and Technology 
National Computer Systems Laboratory 
Bldg. 255, Rm. A266 
Gaithersburg, MD 20899 

USA 


a. SPONSORtlGAeNTTORaiQ AOENCY NAItC(S) AND A00flESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Washington, D.C. 20301-3081 



a. PERFORMNG ORQANI2ATCN 
REPORT NUMBER 


10. SPONSORMGMONTTORaiG AGENCY 
REPORT NUMBER 



12a. OCSTRBUTONrAVALABUTY STATEICNT 


120. nSTRBUTION COOE 


Approved for public release; distfibution unlimited. 


IS. ABSTRACT (IAirtiun200 wortO; 

Data General, ADE, Revision 3.01, Gaithersburg, MD, MV 15000 under AOS/VS 7.60, MV 10000 
under AOS/VS II 1.00 (Host) to MV 15000 under AOS/VS 7.60, MV 10000 under AOS/VS II 1.00 
MV 15000 under A0S/RT32 5.00 (Target), 890615S1.10126, ACVC 1.10. 


DTIC 

S ELECTED 
JUN27.l99a| I 

fcB W 


14. MJECT TERMS ' Ada programming language, Ada Compiler Validation' 
Summary Report, Ada Compiler Validation Capability, Validation 
Testing, Ada Validation Office, Ada Validation Facility, AN61-/MIL- 
IfrlSA, Ada Joint Program Office _ 



IS. NUMBER OF RkOES 


IS. PRICE OOOE 


20. UMITATON OF ABSTTUa 



















AVF Control Number: NIST89DGC525_1.10 

DftTE WEHTTEN: 15 June 1989 

DATE VSR MDDIFIED PER AVO CCMMENTS: 04-30-90 


Ada OCMPILER 
VALTDAnON SUMMARY REPORT: 
Certificate Number: 890615S1.10126 
Data General 
ADE, Revision 3.01 
m 15000 Host and MV 15000 Target 
MV 10000 Host and MV lOOOO Target 


Completion of On-Site Testing: 
15 June 1989 


Prepared By: 

Software Standards Validation Grot?) 
National Qaiputer Systems laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


Pr^ared For: 

Ada Joint Program Office 
United States Depeurtment of Defense 
Washington DC 20301-3081 







AVF Control Number; NIST89DGC525_1.10 
Ada Compiler Validation Summary Report: 

Compiler Name: ADE Revision 3.01 
Certificate Number: 890615S1.10126 

Host: MV 15000 under AOS/VS 7.60 

MV 10000 under AOS/VS II 1.00 

Target: MV 15000 under A0S/A7S 7.60 

MV 10000 under AOS/VS II 1.00 
MV 15000 under AOS/RT32 5.00 

Testing Completed 15 June 1989 Using ACVC 1.10 


This report has been reviewed and is approved. 



Dr. David K. Jeffersor 
Chief, Information Systems 
Engineering Division 

National Computer Systems Laboratory (NCSL) 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


Ada Validation Organization 
,-7 Dr. John F.HCram/^r 

Institute for Defense Analyses 
Alexandria VA 22311 



Ada Joint Program Office 
M r . William S - : Riteh ftt- 
Acting Director 
Department of Defense 
Washington DC 20301 







Accession For 

NTTS GRAil 
DTIC TAM 
Unuruiouiioed 
Juotiricailon 




By_.___ 

IDI 

atrihullon/ 


_AvaU«bUlty Codes 
lAvali and/or 


Dlat 




Special 


□ □ 








TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1-2 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.1-2 

1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-3 

1.5 ACVC TEST CLASSES.1-4 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED . 2-1 

2.2 IMPLEMENTATION CHARACTERISTICS . 2-2 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.3-1 

3.2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 WITHDRAWN TESTS.3-2 

3.5 INAPPLICABLE TESTS . 3-2 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . .3-7 

3.7 ADDITIONAL TESTING INFORMATION . 3-7 

3.7.1 Prevalidation.3-7 

3.7.2 Test Method.3-7 

3.7.3 Test Site.3-8 


APPENDIX A CONFORMANCE STATEMENT 

APPENDIX B APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 


APPENDIX E 


COMPILER OPTIONS AS SUPPLIED BY 
Data General 






















CHAPTER 1 


INTRODUCTION 

This Validation Summary Report (VSR) describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results of testing this compiler using the Ada Compiler 
Validation Capability (ACVC). An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that 
is not in the Standard. 

Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between 
implementations. The Ada Standard permits some implementation 
dependencies--for example, the maximum length of identifiers or the 
maximum values of integer types. Other differences between compilers 
result from the characteristics of particular operating systems, 
hardware, or implementation strategies. All the dependencies observed 
during the process of testing this compiler are given in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. The purpose of validating is to ensure 
conformity of the compiler to the Ada Standard by testing that the 
compiler properly implements legal language constructs and that it 
identifies and rejects illegal language constructs. The testing also 
identifies behavior that is implementation dependent, but is permitted 
by the Ada Standard. Six classes of tests are used. These tests are 
designed to perform checks at compile time, at link time, and during 
execution. 


1-1 







1.1 PURPOSE OF THI 5 VALIDATION SUMMARY REPORT 

This VSR dociiments the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 

To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 

Testing of this compiler was conducted by GEMMA Corp under the direction 
of the AVF according to procedures established by the Ada Joint Program 
Office and administered by the Ada Validation Organization (AVO) . 
On-site testing was completed 15 June 1989 at Data General. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO 
may make full and free public disclosure of this report. In the United 
States, this is provided in accordance with the "Freedom of Information 
Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do 
not represent or warrant that all statements set forth in this report 
are accurate and complete, or that the subject compiler has no 
nonconformities to the Ada Standard other than those presented. Copies 
of this report are available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 


Software Standards Validation Group 
National Computer Systems Labortoiry 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 

Questions regarding this report or the validation test results should be 
■ directed to the AVF listed above or to: 


1-2 









Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.3 REFERENCES 

1. Reference Manual for the Ada Programming Language, 
ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide, December 1986. 


1.4 DEFINITION OF TERMS 

ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to 
the Ada programming language. 

Ada An Ada Commentary contains all information relevant to 

the Commentary point addressed by a comment on the Ada 
Standard. These comments are given a unique 
identification number having the form Al-ddddd. 

Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

Applicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 



AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and 

technical support for Ada validations to ensure 
consistent practices. 

Compiler A processor for the Ada language. In the context of 

this report, a compiler is any language processor, 
including cross-compilers, translators, and 
interpreters. 

Failed test An ACVC test for which the compiler generates a result 


1-3 






that demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 

Inapplicable An ACVC test that uses features of the language that 
testa compiler is not required to support or may 
legitimately support in a way other than the one 
expected by the test. 


Passed test 


An ACVC test for which a compiler generates the expected 
result. 


Target 


The computer which executes the code generated by the 
compiler. 


Test 


Withdrawn 


A program that checks a compiler's conformity regarding 
a particular feature or a combination of features to the 
Ada Standard. In the context of this report, the term 
is used to designate a single test, which may comprise 
one or more files. 

An ACVC test found to be incorrect and not used to check 
test conformity to the Ada Standard. A test may be 
incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains illegal or 
erroneous use of the language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name 
identifies the class to which it belongs. Class A, C, D, and E tests 
are executable, and special program units are used to report their 
results during execution. Class B tests are expected to produce 
compilation errors. Class L tests are expected to produce errors 
because of the way in which a program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal 
Ada programs with certain language constructs which cannot be verified 
at run time. There are no explicit program components in a Class A test 
to check semantics. For example, a Class A test checks that reserved 
words of another language (other than those already reserved in the Ada 
language) are not treated as reserved words by an Ada compiler. A Class 
A test is passed if no errors are detected at compile time and the 
program executes to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that every 
syntax or semantic error in the test is detected. A Class B test is 
passed if every illegal construct that it contains is detected by the 


1-4 







compiler. 


Class C tests check the run time system to ensure that legal Ada 
programs can be correctly compiled and executed. Each Class C test is 
self-checking and produces a PASSED, FAILED, or NOT APPLICABLE message 
indicating the result when it is executed. 

Class D tests check the compilation and execution capacities of a 
compiler. Since there are no capacity requirements placed on a compiler 
by the Ada Standard for some parameters--for example, the number of 
identifiers permitted in a compilation or the number of units in a 
library--a compiler may refuse to compile a Class D test and still be a 
conforming compiler. Therefore, if a Class D test fails to compile 
because the capacity of the compiler is exceeded, the test is classified 
as inapplicable. If a Class D test compiles successfully, it is 
self-checking and produces a PASSED or FAILED message during execution. 


Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the 
Ada Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is 
rejected by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is 
attempted. A Class L test passes if it is rejected at link time--that 
is, an attempt to execute the main program must generate an error 
message before any declarations in the main program or any units 
referenced by the main program are elaborated. In some cases, an 
implementation may legitimately detect errors during compilation of the 
test. 

Two library units, the package REPORT and the procedure CHECK_FILE, 
support the self-checking features of the executable tests. The package 
REPORT provides the mechanism by which executable tests report PASSED, 
FAILED, or NOT APPLICABLE results. It also provides a set of identity 
functions used to defeat some compiler optimizations allowed by the Ada 
Standard that would circumvent a test objective. The procedure 
CHECK_FILE is used to check the contents of text files written by some 
of the Class C tests for Chapter 14 of the Ada Standard. The operation 
of REPORT and CHECK_FILE is checked by a set of executable tests. These 
tests produce messages that are examined to verify that the units are 
operating correctly. If these units are not operating correctly, then 
the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended 


1-5 











to ensure that the tests are reasonably portable without modification. 
For example, the tests make use of only the basic set of 55 characters, 
contain lines with a maximum length of 72 characters, use small numeric 
values, and place features that may not be supported by all 
implementations in separate tests. However, some tests contain values 
that require the test to be customized according to 
implementation-specific values--for example, an illegal file name. A 
list of the values used for this validation is provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable 
to the implementation. The applicability of a test to an 
implementation is considered each time the implementation is validated. 

A test that is inapplicable for one validation is not necessarily 
inapplicable for a subsequent validation. Any test that was determined 
to contain an illegal language construct or an erroneous language 
construct is withdrawn from the ACVC and, therefore, is not used in 
testing a compiler. The tests withdrawn at the time of this validation 
are given in Appendix D. 


1-6 






CHAPTER 2 


CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under 
the following configuration: 

Compiler: ADE Revision 3.01 

ACVC Version: 1.10 

Certificate Number: 890615S1.10126 

Host Computer: 

Machine: MV 15000 

Operating System: AOS/VS 7.60 

Memory Size: 24 MB 

Target Computer: 

Machine: MV 15000 MV 10000 

Operating System: AOS/VS 7.60 AOS/VS II 1.00 

AOS/RT32 5.00 

Memory Size: 24 MB 16 MB 

32 MB 


MV 10000 
AOS/VS II 1.00 
16 MB 


2-1 




2.2 IMPLEMENTATION CHARACTERISTICS 


One of the purposes of validating compilers is to determine the behavior 
of a compiler in those areas of the Ada Standard that permit 
implementations to differ. Class D and E tests specifically check for 
such implementation differences. However, tests in other classes also 
characterize an implementation. The tests demonstrate the following 
characteristics: 

Capacities. 

(1) The compiler correctly processes a compilation 
containing 723 variables in the same declarative part. 
(See test D29002K.) 

(2) The compiler correctly processes tests containing loop 
statements nested to 65 levels. (See tests D55A03A..H 
(8 tests).) 

(3) The compiler correctly processes tests containing block 
statements nested to 65 levels. (See test D56001B.) 

(4) The compiler correctly processes tests containing 
recursive procedures separately compiled as subunits 
nested to 17 levels. (See tests D64005E..G (3 tests).) 

Predefined types. 

(1) This implementation supports the additional predefined 
types SHORT_INTEGER (B86001V) and LONG_FLOAT (B86001U) 
in the package STANDARD. (See tests B86001T..Z (7 

tests).) 


Expression evaluation. 

The order in which expressions are evaluated and the 
time at which constraints are checked are not defined by 
the language. While the ACVC tests do not specifically 
attempt to determine the order of evaluation of 
expressions, test results indicate the following: 

(1) None of the default initialization expressions for 
record components are evaluated before any value is 
checked for membership in a component's subtype. (See 
test C32117A.) 

(2) Assignments for subtypes are performed with the same 
precision as the base type. (See test C35712B.) 

(3) This implementation uses no extra bits for extra 
precision and uses all extra bits for extra range. (See 
test C35903A.) 


2-2 






(4) NUMERIC_ERROR is raised when an integer literal operand 
in a comparison or membership test is outside the range 
of the base type. (See test C45232A.) 

(5) No exception is raised when a literal operand in a 
fixed-point comparison or membership test is outside the 
range of the base type. (See test C45252A.) 

(6) Underflow is not gradual. (See tests C45524A..Z (26 

tests).) 

Rounding. 

The method by which values are rounded in type 
conversions is not defined by the language. While the 
ACVC tests do not specifically attempt to determine the 
method of rounding, the test results indicate the 
following; 

(1) The method used for rounding to integer is round away 
from zero. (See tests C46012A..Z (26 tests).) 

(2) The method used for rounding to longest integer is 
round away from zero. (See tests C46012A..Z (26 tests).) 


(3) The method used for rounding to integer in static 
universal real expressions is round away from zero. (See 
test C4A014A.) 

Array types. 

An implementation is allowed to raise NUMERIC_ERROR or 
CONSTRAINT_ERROR for an array having a 'LENGTH that 
exceeds STANDARD.INTEGER’LAST and/or SYSTEM.MAX_INT. 
For this implementation: 

(1) Declaration of an array type or subtype declaration with 
more than SYSTEM.MAX_INT components raises no exception. 
(See test C36003A.) 

(2) NUMERIC_ERROR is raised when 'LENGTH is applied to an 
array type with INTEGER'LAST + 2 components. (See test 
C36202A.) 

(3) NUMERIC_ERROR is raised when 'LENGTH is applied to an 
array type with SYSTEM.MAX_INT + 2 components. (See test 
C36202B.) 

(4) A packed BOOLEAN array having a 'LENGTH exceeding 
INTEGER'LAST raises STORAGE_ERROR) when the array 
objects are declared. (See test C52103X.) 


2-3 









(5) A packed two-dimensional BOOLEAN array with more than 
INTEGER'LAST components raises STORAGE_ERROR when the 
array objects are declared. (See test C52104Y.) 

(6) In assigning one-dimensional array types, the expression 
is evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test 
C52013A.) 

(7) In assigning two-dimensional array types, the expression 
is not evaluated in its entirety before CONSTRAINT_ERROR 
is raised when checking whether the expression's subtype 
is compatible with the target's subtype. (See test 
C52013A.) 

A null array with one dimension of length greater than 
INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAINT_ERROR either 
when declared or assigned. Alternatively, an implementation may 
accept the declaration. However, lengths must match in array 
slice assignments. This implementation raises no exception. (See 
test E52103Y.) 

Discriminated types. 

(1) In assigning record types with discriminants, the 
expression is evaluated in its entirety before 
CONSTRAINT_ERROR is raised when checking whether the 
expression's subtype is compatible with the target's 
subtype. (See test C52013A.) 

Aggregates. 

(1) In the evaluation of a multi-dimensional aggregate, the 
test results indicate that all choices are evaluated 
before checking against the index type. (See tests 
C43207A and C43207B.) 

(2) In the evaluation of an aggregate containing 
subaggregates, not all choices are evaluated before 
being checked for identical bounds. (See test E43212B.) 

(3) CONSTRAINT_ERROR is raised after all choices are 
evaluated when a bound in a non-null range of a non-null 
aggregate does not belong to an index -abtype. (See 
test E43211B.) 

Pragmas. 


2-4 









(1) {The pragma INLINE is supported for functions or 
procedures. (See tests LA3004A..B (2 tests), EA3004C..D 
(2 tests), and CA3004E..F (2 tests).) 


Generics. 

(1) Generic specifications and bodies cannot be compiled in 

separate compilations. (See tests CA1012A, CA2009C, 

CA2009F, BC3204C. and BC3205D.) 

(2) Generic subprogram declarations and bodies cannot be 
compiled in separate compilations. (See tests CA1012A 
and CA2009F.) 

(3) Generic library subprogram specifications and bodies 
cannot be compiled in separate compilations. (See test 
CA1012A.) 

(4) Generic non-library package bodies as subunits cannot be 
compiled in separate compilations. (See test CA2009C.) 

(5) Generic non-library subprogram bodies cannot be compiled 
in separate compilations from their stubs. (See test 
CA2009F.) 

(6) Generic unit bodies and their subunits cannot be 

compiled in separate compilations. (See test CA3011A.) 

(7) Generic package declarations and bodies cannot be 
compiled in separate compilations. (See tests CA2009C, 
BC3204C, and BC3205D.) 

(8) Generic library package specifications and bodies cannot 
be compiled in separate compilations. (See tests 
BC3204C and BC3205D.) 

(9) Generic unit bodies and their subunits cannot be 

compiled in separate compilations. (See test CA3011A.) 

Input and output. 

(1) The package SEQUENTIAL_IO cannot be instantiated with 

unconstrained array types and record types with 

discriminants without defaults. (See tests AE2101C, 

EE2201D, and EE2201E.) 

(2) The package DIRECT_IO cannot be instantiated with 

unconstrained array types and record types with 

discriminants without defaults. (See tests AE2101H, 

EE2401D, and EE2401G.) 

(3) Modes IN_FILE and OUT_FILE are supported for 


2-5 








SEQUENTIAL_IO. (See tests CE2102D..E, CE2102N, and 
CE2102P.) 

(4) Modes IN_FILE, OUT_FILE, and INOUT_FILE are supported 

for DIRECT_IO. (See tests CE2102F, CE2102I..J (2 

tests). CE2102R, CE2102T, and CE2102V.) 

(5) Modes IN_FILE and OUT_FILE are supported for text files. 
(See tests CE3102E and CE3102I..K (3 tests).) 

(6) RESET and DELETE operations are supported for 
SEQUENTIAL_IO. (See tests CE2102G and CE2102X.) 

(7) RESET and DELETE operations are supported for DIRECT_IO. 
(See tests CE2102K and CE2102Y.) 

(8) RESET and DELETE operations are supported for text 

files. (See tests CE3102F..G (2 tests), CE3104C, 

CE3110A, and CE3114A.) 

(9) Overwriting to a sequential file does not truncate the 
file. (See test CE2208B.) 

(10) Temporary sequential files are given names and deleted 
when closed. (See test CE2108A.) 

(11) Temporary direct files are given names and deleted when 
closed. (See test CE2108C.) 

(12) Temporary text files are given names and deleted when 
closed. (See test CE3112A.) 

(13) More than one internal file can be associated with each 

external file for sequential files when writing or 
reading. (See tests CE2107A..E (5 tests), CE2102L, 

CE2110B, and CE2111D.) 

(14) More than one internal file can be associated with each 
external file for direct files when writing or reading. 
(See tests CE2107 and CE2110D) 

(15) More than one internal file can be associated with each 
external file for text files when writing or reading. 
(See tests CE3111A..E (5 tests) and CE3114B) 


2-6 






CHAPTER 3 


TEST INPQFMAnC»J 

3.1 TEST REsunrs 

Version 1.10 of the ACVC cxarprises 3717 tests. When this conpiler was 
tested, 44 tests had been withdrawn becavise of test errors. The AVF 
determined that 560 tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing except for 
201 executable tests that use floating-point precision exceeding that 
sipported by the inplementation. Modifications to the code, processing, 
or grading for 2 tests was required to successfully demonstrate the test 
objective. (See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESUIITS BY CIASS 


RESUIT 

A 

B 

TEST CLASS 
C D 

E 

L 

TOTAL 

Passed 

124 

1129 

1780 

15 

21 

44 

3107 

Inapplicable 

5 

9 

535 

2 

7 

2 

560 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


3-1 





3.3 


SUMMARY OF TEST RESULTS BY OlAPIER 


RESULT 

2 

3 

4 

5 

_6 

7 

CHAPTER 
8 9 

10 , 

11 

12 

13 

14 

TOTAL 

Passed 

194 

573 

541 

245 

172 

99 

158 

331 

131 

36 

250 

94 

289 

3113 

Inapplicable 

18 

76 

139 

3 

0 

0 

8 

1 

6 

0 

2 

275 

32 

560 

Wdm 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WTIHERAWN TESTS 

The following 44 tests were withdrawn from ACVC Version 1.10 at the time 
of this validation: 

A39005G B97102E C97116A BC3009B CD2A62D CD2A63A CD2A63B 

CD2A63C CD2A63D CD2A66A a)2A66B CD2A66C CD2A66D CD2A73A 

CD2A73B CD2A73C a)2A73D CD2A76A CD2A76B CD2A76C a)2A76D 

CD2A81G CD2A83G a)2A84M CD2A84N CD2B15C CD2D11B 0)50076 

CD50110 CD7105A CD7203B CD7204B CD7205C CD7205D CE2107I 

CE3111C CE3301A CE3411B E28005C ED7004B ED7004D ED7005C 

ED7006C ED7006D 


See ^^pendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABIZ TESTS 

Some tests do not apply to edl carpilers because they make use of 
features that a compiler is not required by the Ada Standard to svpport. 
Others may d^jend on the result of another test that is either 
inapplicable or withdrawn. The applicability of a test to an 
iitplementation is considered each time a validation is attempted. A 
test that is inapplicable for one validation attempt is not necessarily 
inapplicable for a subsequent attempt. For this v 2 d.idation attempt, 560 
tests were inapplicable for the re^lsons indicated: 


3-2 





Hie following 201 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAX DIGITS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C4 5241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


The following 4 tests are not applicable because the tests 
require a source line of chciracters which is greater than the 120 
character source line viiich this inplementation does support: 


C24113H..K ( 4 tests) 


The following 170 tests are not applicable because 'SIZE 
r^resentation clauses are not si^jported: 


A39005B 

CD10090. 

CD2A21A, 

CD2A23A. 

CD2A31A. 

CD2A41A. 

CD2A51A. 

CD2A52G. 

CD2A54A. 

CD2A61A. 

CD2A64A. 

aD2A71A. 

CD2A74A. 

CD2A81A. 

CD2A83A. 

CD2A84B. 

CD2A87A 

ED2A26A 


• Q 
.E 
.E 
.D 
.E 
.E 
.J 
.D 

• L 
.D 
.D 

• D 
.E 

• C 

.1 


C87B62A 
(3 tests) 
(5 tests) 
(5 tests) 
(4 tests) 
(5 tests) 
(5 tests) 
(4 tests) 
(4 tests) 
(12 tests) 
(4 tests) 
(4 tests) 
(4 tests) 
(5 tests) 
tests) 


(3 

(8 tests) 


ED2A56A 


CD1009A. 

CD1C03A 

CD2A22A. 

CD2A24A. 

CD2A32A. 

CD2A42A. 

CD2A52A. 

a)2A53A. 

CD2A54G. 

CD2A62A. 

CD2A65A. 

CD2A72A. 

CD2A75A. 

a32A81G 

CD2A83E. 

CD2A84K. 

CD2A91A. 

ED2A86A 


.1 (9 tests) 
CD1C04A 
.J (10 tests) 
.J (10 tests) 
.J (10 tests) 
.J (10 tests) 
.D (4 tests) 
.E (5tests) 

.J (4 tests) 
.C (3 tests) 
.D (4 tests) 
.D (4 tests) 
.D (4 tests) 

.F (2 tests) 
.L (2 tests) 
.E (5 tests) 


The following 14 tests cure not applicable because the 
'ST0RAGE_SIZE is not supported for access types: 

A39005C C87B62B CD1009J CD1009R CD1009S 

CD1C03C CD2B11B CD2B11C CD2B11D CD2B1IE 

CD2B11F CD2B11G CD2B15B CD2B16A 

Ihe following 7 tests eire not supported because ' SMALL 
r^resentation clauses are not supported: 


3-3 










A39005E C87B62C CDIOOSL CD1C03F CD1C04C CD2D11A 

CD2D13A 

Hie following 12 tests are not applicable because of restrictions 
on the use of enumeration types for vAiich an enumeration 
representation clause has been given: 

CD3014A CD3014B CD3014D CD3014E CD3015A 

CD3015B CD3015D CD3015E CD3015G CD3015I 

CD3015J CD3015L 

CD4031A, CD4051C, and CD4051D are not applicable because record 
representation clauses are not supported for record types with 
discriminant pcirts. 

C34006D yields a failed result due to checks on the 'SIZE 
attribute; the AVO ruled that the test be counted as passed. 

C35702A and B86001T are not applicable because this 
inplementation si:?^rts no predefined type SHORr_FIDAT. 

Ihe following 16 tests are not ^plicable because this 
inplementation does not si?port a predefined type LC»JG_INTEGER: 

C45231C C45304C C45502C C45503C C45504C 

C45504F C45611C C45613C C45614C C45631C 

C45632C B52004D CS5B07A B55B09C B86001W 

CD7101F 

C45531M. .P (4 tests) and C45532M. .P (4 tests) are not applicable 
because the value of SYSTEM.MAX_MaNTISSA is less than 47 (31). 

C4A013B is not applicable because the evaluation of an expression 
involving 'MACHINE_RADIX applied to the most precise 
floating-point type would raise an exception; since the expression 
must be static, it is rejected at compile time. 

D4A002B and D4A004B use 64-bit integer calculations which are not 
sufported by this compiler. 

B86001X, C45231D, and 0371010 are not applicable becaiase this 
inplementation does not support any predefined integer type with a 
name other them INTEGER, lj:»IG_INrBGER, or SHORr_INTBGER. 

B86001Y is not applicable because this implementation sujports no 
predefined fixed-point type other them DURATTW. 

B86001Z is not applicable because this implementation sipports no 
predefined floating-point type with a name other than FLOAT, 
KM3_FIDAT, or SHORr_FlJDAT. 

C96005B is not applicable because there are no values of type 


3-4 







DQRATIC^I'BASE that are outside the range of DURATIC^I. 

CA1012A, C3^009C, Ca2009F, CA3011A, BC3204C, BC3205D, IA5008M and 
IA5008N are not applicable because this inplementation does not 
permit corrpilation in separate files of generic specifications 
and bodies or of specifications and bodies of subunits of generic 
units. 


Ihe following 77 tests are not applicable because, for this 
inplementation, type SYSTEM.ADDRESS is a limited private type: 


CD5003B..1 (8 tests) 
CD5011Q..S (3 tests) 
CD5012L..M (2 tests) 
CD5013K..0 (5 tests) 
CD5014A. .0 (15 tests) 

AE2101C, EE2201D, and EE2201E 

SBQUENriAL_IO with lanconstrained 
discriminants without defaults, 
by this conpiler. 


CD5011A. .N (14 tests) 
CD5012A. .J (10 tests) 
CD5013A..1 (9 tests) 
CD5013R..S (2 tests) 
CD5014R..Z (9 tests) 

use instantiations of package 
array types and record types with 
Ihese instantiations are rejected 


AE210IH, EE2401D, and EE2401G use instantiations of package 
DIRECr_I0 with unconstrained array types and record types with 
discriminants without defaults. These instantiations are rejected 
by this ccsnpiler. 


CE2102D is inapplicable because this iitpleroentation stpports 

CREATE with IN_FH:£ mode for SEQUENTTAL_IO. 

CE2102E is inafplicable because this inplementation supports 

CREATE with 0OT_FHZ mode for SEQOENTTAL_IO. 

CE2102F is inapplicable because this inplementation supports 

CREATE with INCiur_FII£ mode for DIRECr_I0. 

CE2102I is inajplicable because this implementation supports 

CREATE with IN_FII£ mode for DIRECr_I0. 

CE2102J is inapplicable because this implementation supports 

CREATE with OUT FILE mode for DIRECT 10. 


CE2102N is inapplicable because this implementation supports OPEN 
with IN_FIIE mode for SEQUENnAL_IO. 

CE21020 is inapplicable because this implementation supports RESET 
with IN_FII£ mode for SBQUENTTAL_IO. 

CE2102P is inapplicable because this implementation supports OPEN 
with 0UT_FIIZ mode for SEQUENTTAL_IO. 

CE2102Q is inapplicable because this implementation supports RESET 


3-5 





with OUT_FH£ mode for SEQUENTIAL_IO. 

CE2102R is inapplicable because this inplementation supports OPEN 
with IN0OT_FIIE mode for DIRECr_IO. 

CE2102S is inapplicable because this inplementation sipports RESET 
with IN0OT_FIIE mode for DIRECr_IO. 

CE2102T is inapplicable because this inplementation suppoirts OPEN 
with IN_FIIE mode for DIRECr_IO. 

CE2102U is inapplicable because this inplementation sipports RESET 
with IN_FH£ mode for DIRECr_IO. 

CE2102V is inapplicable because this inplementation supports OPEN 
with OUT_FH£ mode for DIRECr_IO. 

CE2102W is inapplicable because this inplementation supports RESET 
with OOT JFTIE mode for DIRECr_IO. 

CE2107G, CE2107H, CE211IH, CE3111B, and CE3115A are not supported 
because use of the cperating system buffer causes unexpected 
results. 

CE3102E is inapplicable because text file CI^EATE with IN_FILE mode 
is supported by this inplementation. 

CE3102F is inapplicable because text file RESET is supported by 
this inplementation. 

CE3102G is inajplicable because text file deletion of an external 
file is sipported by this inplementation. 

CE3102I is inafplicable because text filaufie text file CREATE with 
CUT_FHE mode is sipported by this inplementation. 

CE3102J is inafplicable because text file OPEN with IN_FHJE mode 
is sipported by this inplementation. 

CE3102K is inapplicable because text file OPEN with OUT_FILE mode 
is not sipported by this inplementation. 


3.6 TEST, TROCESSING, AND EVAIDAnat MDOIFICATiaiS 

It is expected that seme tests will require modifications of code, 
processing, or evaluation in order to cempensate for legitimate 
inplementation behavior. Modifications are made by the AVF in cases 
vhere legitimate inplementation behavior prevents the successful 
conpletion of ein (otherwise) applicable test. Exanples of such 
modifications include: adding a length clause to alter the default size 
of a collection; splitting a Class B test into subtests so that all 


3-6 







errors are detected; and confirming that messages produced by an 
executable test demonstrate conforming behavior that was not anticipated 
by the test (such as raising one exc^jtion instead of another). 

Modifications were required for 2 tests. 

The following 1 test was split because syntax errors at one point 
resulted in the ccnpiler not detecting other errors in the test: 

mioic 

Ifodifications were required for one test CC1223A. CC1223A was modified 

according to AVO instructions to replace the expression 
"2**T'MftNnsSA-l" at line 262 with •'2**(T'MANnsSA-l)-l)"; the original 
expression raised am exception because 2**T'MANTISSA exceeds 
SYSTEM.MAX INT. 


3.7 ACOmCNAL TESTING INPOEMAnC»I 

3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 
produced by the ADE Revision 3.01 ccnpiler was sutmiitted to the AVF by 
the afplicant for review. Analysis of these results demonstrated that 
the ccatpiler successfully passed all ajplicable tests, and the cotpiler 
exhibited the e>pected behavior on all inapplicable tests. 

3.7.2 Test Method 

Testing of the ADE Revision 3.01 ccaipiler using ACVC Version 1.10 was 
conducted on-site by a validation team frctn the AVF. The configuration 
in vhich the testing was performed is described by the following 
designations of hardware and softvrare ccnponents: 


Host ccmputer: 

MV 10000 

MV 15000 

MV15000 

Host operating system: 
AOS/VS II 1.00 

AOS/VS 7.60 

AOS/VS 7.60 

Target coiputer: 

MV 10000 

MV 15000 

MV15000 

Target operating system: 
ADS/VS II 1.00 

ADS/VS 7.60 

AOS/RT32 5.00 

A tape containing eill tests 

except for withdrawn 

tests and tests 


requiring unsipported floating-point precisions was taJcen on-site by the 
validation team for processing. 

The contents of the tape were loaded directly onto the host ccmputer. 
After the test files were loaded to disk, the full set of tests Wcis 
corpiled, linked, and all executable tests were run on the MV 15000/MV 
10000. Results were printed from the MV 15000/MV 10000 computer. 


3-7 








The ccarpiler was tested using command scripts provided by Data General 
and reviewed by the validation team. See Appendix E for a conplete 
listing of the available cotpiler cptions for this inplementation. The 
only cption invoked during this validation was MAIN_PRCX3?AM. 

Tests were ccupiled, linked, and executed (as apprcpriate) using two 
host cottpubers and three target conputers. Test output, coirpilation 
listings, and jc4) logs were captured on tape and archived at the AVF. 

3.7.3 Test Site 

Testing was conducted at IData General and was ccstpleted on 15 Jun 1989. 


3-8 









APPENDIX A 


DECLARATION OF CONFORJIANCE 


Data General has submitted the following Declaration 
Conformance concerning the MV 15000/MV 10000. 


of 


A-1 










Appendix A 

DECLARATION OF CONFORMANCE 


Compiler Implementer; Data General Corporation 

Ada Validation Facility: The Software Standards Validation Group 

Ada Compiler Validation Capability (ACVC) Version: 1.10 

Base Configuration 


Base Compiler Name: 
Host Architecture 

Target Architecture - 


ADE 

ISA: MV 15000 
MV 10000 
ISA: MV 15000 
MV 10000 
MV 15000 


Revision: 3.01 
OS&VER #: AOS/VS 7.60 
OS$VER #: AOS/VS II 1.00 
OSfiVER #: AOS/VS 7.60 
OSSVER #: AOS/VS II 1.00 
OS&VER #: AOS/RT32 5.00 


Derived Compiler Registration 


Derived Compiler Name: ADE 


Host Architecture 
Target Architecture - 


ISA: MV Family 
ISA: MV Family 
ISA: MV Family 
ISA: MV Family 
ISA: MV Family 


Revision: 3.00 
OS&VER #: AOS/VS 7.60 
OSfiVER #t AOS/VS II 1.00 
OSfiVER «: AOS/VS 7.60 
OSfiVER #» AOS/VS II 1.00 
OSfiVER #t AOS/RT32 5.00 


Implementer's Declaration 

1 , the undersigned, representing Data General Corporation have 
implemented no deliberate extensions to the Ada Language Standard 
ANSI/MIL>STD«181SA in the compiler listed in this declaration. I 
declare that Data General Corporation is the owner of record of the Ada 
language compiler listed above and, as such, is responsible for 
maintaining said compiler in conformance to AMSI/MIL>STD<-1815A. All 
certificates and registrations for the Ada language compiler listed in 
this declaration shall^be made the owner's corporate name. 


Signature 


the owner's corporate name. 

/Date 


Owner's Declaration 


I, the undersigned, representing Data General Corporation take 
full reponsibility for implementation and maintenance of the Ada 
compiler listed above, and agree to the pxiblic disclosure of the final 
Validation Summary Report. I declare that all of the Ada language 
compilers listed, and their host/teirget performance are in compliance 
with the Ada Language Stand^d ANSI/MIL-STD-1815A. 


ignatuj 


Date 



APPENDIX B 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of the MV 15000/MV 10000 
compiler, as described in this Appendix, are provided by Data General. 
Unless specifically noted otherwise, references in this appendix are to 
compiler documentation and not to this report. Implementation-specific 
portions of the package STANDARD, which are not a part of Appendix F, 
are: 


package STANDARD is 


type INTEGER is range -2147483648 .. 2147483647 ; 

type SH0RT_INTEGER is range -32768 .. 32767; 

type FLOAT is digits 6 range -7.23700E+75 . 7.23700E+75: 

type L0NG_FL0AT is digits 15 ran-o -732700557733226E+75 
+732700557733226E+75; 

type DURATION is delta 2**-9 range .. ''** 22 ; 


end STANDARD; 


B-1 










Addendum to 

the ANSI Reference Manual for 
the Ada® Programming Language 

086-000070-02 


This addendum updates manual 069-000073-00. 
See updating instructions inside. 


Ordering No.086-000070 
Rev. 02, December 1988 

Copyright O Semantic Software. Inc.. 1984. 1988 
Copyright 6 Dau General Corporation. 1984. 1988 
All Rights Reserved 

Printed in the United States of America 



069 > 000073-00 





Notice 


DATA GENERAL CORPORATION (DGC) HAS PREPARED THIS DOCUMENT FOR USE BY DGC PER¬ 
SONNEL. CUSTOMERS. AND PROSPECTIVE CUSTOMERS. THE INFORMATION CONTAINED 
HEREIN SHALL NOT BE REPRODUCED IN WHOLE OR IN PART WITHOUT DGC'S PRIOR WRITTEN 
APPROVAL. 

DGC reserves the right to make changes in specifications and other information contained in 
this document without prior notice, and the reader should in all cases consult DGC to deter¬ 
mine whether any such changes have been made. 

THE TERMS AND CONDITIONS GOVERNING THE SALE OF DGC HARDWARE 
PRODUCTS AND THE LICENSING OF DGC SOFTWARE CONSIST SOLELY OF 
THOSE SET FORTH IN THE WRITTEN CONTRACTS BETWEEN DGC AND ITS CUS¬ 
TOMERS. NO REPRESENTATION OR OTHER AFFIRMATION OF FACT CON¬ 
TAINED IN THIS DOCUMENT INCLUDING BUT NOT LIMITED TO STATEMENTS 
REGARDING CAPACITY. RESPONSE-TIME PERFORMANCE. SUITABILITY FOR 
USE OR PERFORMANCE OF PRODUCTS DESCRIBED HEREIN SHALL BE DEEMED 
TO BE A WARRANTY BY DGC FOR ANY PURPOSE. OR GIVE RISE TO ANY LI¬ 
ABILITY OF DGC WHATSOEVER. 

IN NO EVENT SHALL DGC BE LIABLE FOR ANY INCIDENTAL. INDIRECT. SPECIAL 
OR CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING BUT NOT LIMITED TO 
LOST PROFITS) ARISING OUT OF OR RELATED TO THIS DOCUMENT OR THE IN¬ 
FORMATION CONTAINED IN IT. EVEN IF DGC HAS BEExN ADVISED. KNEW OR 
SHOULD HAVE KNOWN OF THE POSSIBILITY OF SUCH DAMAGES. 


CEO. DASHER. DATAPREP. DESKTOP GENERATION, ECLIPSE, ECLIPSE MV/4000. 
ECLIPSE MV/6000. ECLIPSE MV/8000. GENAP, INFOS. microNOVA. NOVA. 
PRESENT, dPROXI. SWAT, and TRENDVIEW are U.S. registered trademarks of Data 
General Corporation; and AOSMAUIC. AOS/VSMAGIC, AROSE/PC, ArrayPlus, 

BusiGEN, BusiPEN. BusiTEXT. CEO Connection, CEO Drawing Board. CEO DXA. 

CEO Light. CEO MAILI, CEO PXA. CEO Wordview, CEOwrite, COBOL/SMART. 
COMPUCALC, CSMAGIC. DASHER/One, DASHER/286, DASHER/386. DASHER/LN. 
DATA GENERAL/One. DESKTOP/UX. DG/SOO. DG/AROSE, DGConnect, DG/DBUS. 
DG/Fontstyles. DG/GATE. DG/GEO. DG/L, DG/LIBRARY, DG/UX. DG/XAP, 
ECLIPSE. MV/1400. ECLIPSE MV/2000. ECLIPSE MV/2500. ECLIPSE MV/7800. 
ECLIPSE MV/10000. ECLIPSE MV/15000, ECLIPSE MV/20000. ECLIPSE MV/40000. 
FORMA-TEXT. GATEKEEPER. GDC/1000. GDa2400. microECLIPSE. microMV, 
MV/UX. PC Liaison. RASS. REV-UP. SLATE. SP.\RE MAIL. TEO. TEO/3D. 
TEO/EIectronics, TURBO/4, UNITE, and XODIAC are trademarks of Data General 
Corporation. 

Ada is a registered trademark of the U. S. Government (AJPO). ROLM is a registered trade¬ 
mark and ADE is a trademark of ROLM Corporation. 


Addendum to the ANSI Reference Manual for the Ada® Programming Language 

086-000070-02 

Effective with: AOS/VS ADE, Rev. 3.00 


Please insen Appendix F in your copy of the ANSI Reference Manual for the Ada 
Programming Language. _ 






ANSI/MIL-STD-1815A Ada Bafarenca Manual 


Appendix F: 

Implementation-Dependent 

Characteristics 


The DGC Ada compiler is distributed as part of the Ada Development Environment (ADE). 
DGC Ada is a validated implementation of Ada that conforms to the full ANSI/MIL-STD-18ISA 
standard. The ANSI standard allows individual implementations to set or deSne certain language 
characteristics, such as pragmas, restrictions on representation clauses, and capacity limits. 

This appendix describes the language characteristics defined by the DGC implementation, version 
3.00 or higher. In this appendix, the>4N5/ Reference Manual for the Ada Prc^gramming Language is 
referred'to as the LRM. 

This appendix contains the following inform^on: 


ADE-Defined Pragmas___ 

Pragmas That Have No Effect_ 

Pragmas Implemented in the ADE_ 

ELABORATE- 

ENTRY POINT.. 

inline”. 

INTERFACE.. 

UST... 

LOAD. 

MAIN. 

MAX TASKS_ 






...F.2 

,..F-4 

...F-4 

,..F-5 

..F-6 

F-LO 

F-15 

F-16 

,F-17 

,F-19 


MV ECS__ 

PAGE__ 

PRIORITY__ 

SUPPRESS..—__ 

TASK STORAGE SIZE_ 

Package SYSTEM_ . 7 ._ 

Representation Clauses- 

Length Clauses-- 

Enumeration Representations... 

Record Representation.. 

Unchecked Programming-- 

Procedure UNCHECKED DEALLOCATION, 

Function UNCHECKED_CONVERSION. 

Characteristics of ADE Input-Output Packages. 


Maximum Sizes Limits in the ADE 


Summary of the ADE Real Type Attributes 


Type Definitions in the ADE 


.F-20 

.F-21 

,F-22 

F-23 

F-26 

,F-2S 

,F-30 

,F-30 

.F-31 

.F-32 

.F-33 

,F.34 

.F-35 

.F-36 

.F-37 

F-38 

F-41 


08e<XX)07(X» 

upeatMoe»oooo73^ 


F-l 































ANSI/MIL-STO-1815A Ada Rateranca Manual 


ADE-Defined Pragmas 

Pragmas tell the compiler how to process your program at compile time. They do oot affect the 
semantics of a program, but they ^ow you to exercise some control over how the compiler 
processes your programs. 

The ANSI Reference Manual for the Ada Propamming Language (LRM) describes the standard 
pragmas and their use. Other pragmas are defined by the various implementations of the 
language. This section provides additional information on those standard pragmas and defines the 
pragmas that are unique to DGC Ada. 

This section contains two parts. The first part lists pragmas that are not implemented in the 
current version of the ADE. The second part lists the implemented pragmas in alphabetical order, 
describes them, and provides examples of their use. 


F-2 


oa»oooo70<» 

upoatM 08M00073.00 












ANSI/MIL-ST 0 - 181 SA Ada Rataranca Manual 


Pragmas That Have No Effect 

The following Ada pragmas are not implemented in the current version of the ADE: 


Pragma 

Explanation 

CONTROLLED 

This pragma is nnr needed because the compiler does not 
reclaim unused storage automatically. To deallocate storage 
explidtly, use the generic procedure 
UNCHECKED_DEALLOCATION. Refer to the LRM, 

Section 13.10, and the ADE User's Manual for more information 
about this procedure. 

MEMORYJIZE 

The package SYSTEM deSnes the MEMORY^S121E constant 
as 2 •• 29 words. Use the /MTOP switch on the ADALINK 
command to adjust the maximum virtual memory size. Refer to 
the ADE User's Manual for more information about the 

ADALINK command. 

OPTIMIZE 

The compiler does not currently use time or space optimization 
criteria. 

PACK 

This pragma has no effect in the current version. 

SHARED 

The compiler does not implement indivisible direct read and 
update operations for any object; therefore, there are no objects 
to which you can apply this pragma. Refer to the LRM, Section 

9.1L 

STORAGE_UNrr 

The package SYSTEM currently defines the storage unit as a 

16-bit word. You can not redefine it. 

SYSTEM_NAME 

The package SYSTEM defines this as an object of enumeration 
type NAME, for which only one literal is allowed. 


OaMOOOTOCZ 

updat0tOe»OOOO73^ 


F-3 









ANSI/MIU-STD-1815A Ada Baferenc* Manual 


Pragmas Implemented in the ADE 

The following pages describe, in alphabetical order, the ADE-spedfic pragmas. 


pragma ELABORATE 

Specifies which library unit bodies (secondary units) to elaborate 
before the current compilation unit. 


Format 

pragma ELABORATE (library_unit (,llbrary_unitl): 


where: 

library unit Specifies the simple name of the library unit whose body you 

~ want elaborated before the current compilation unit. 


Description 

Pragma ELABORATE tells the compiler to elaborate the body of the specified library unit or 
units before elaborating the current compilation unit. If the current compilation unit is a subunit, 
the compiler elaborates the body of the specified library unit before elaborating the unit that is the 
ancestor of the current compilation subunit. 

Pragma ELABORATE must appear after the contes clause for the current compilation unit, and 
it must specify a library unit named in that context clause. The specified library unit must have a 
body. 

For more information, refer to the LRM, Section 10.5. 

Example 

with EARTH^DATA; 

pragma ELABORATE (EARTH_DATA); 

procedure SOLAR_SYSTEM is 

EARTH_DATA.TRACK_ORBIT; 

erid SOLAR_SYSTEM: 


F-4 


oeeoooortvoa 

updatM oe»00007J<X) 




ANSI/MIL-STD-t 8 l 5 A Ada Referance Manual 


pragma ENTRY_POINT 

Associates an Ada subprogram name with a specific entry point label 
so foreign language routines can call or be called by Ada 
subprograms. 


Format 


pragma ENTRY_POINT (subprogram_name, ■9ntry_point_name”): 

where: 


subprogram_nam8 


antry_point__name 


Specifies the unique name of an Ada subprogram defined in the 
declarative part of the current compilation unit. Do not use dot 
notadon to spedly subprogram_name. 

Specifies the STRING literal denoting the actual external label, 
l/se uppercase letters enclosed in quotes, for example, 
•FRTN_LIBNAME*. 


Description 

You can use this pragma in either of two ways: 

• A subprogram written in another language can refer to an Ada subprogram using the entry 
point defined by this pragma. 

• An Ada subprogram can call a library routine written in another language by giving the name 
of the routine as an entry point. In this case, you must also use pragma INliERFACE to 
specify the language of the library routine. 

Pragma ENTRY^POINT must appear in the declarative part of a block, in a package specification, 

or after a compilation unit. You must specify both arguments. 


Example 

procedure MAIN is 

function FRTN OP p(: INTEGER) return BOOLEAN; 

pragma INTERFACE (F77. FRTN OP); 

pragma ENTRY_POINT (FRTN^OP. TRTN_UBNAME*); 

begin 

end MAIN; 


oaeoooo7oc2 
updatn oeeooooTsco 


F-5 





ANSI/MIL-STO-ISISA Ada Raforanca Manual 


pragma INLINE 

Specifies the subprograms and generic units that you want expanded 
inline at each call whenever possible. 


Format 

pragma INUNE (name [, name]); 


where: 

name Specifies the subprogram or generic unit you want inlined at 

each calL The subprogram or generic unit must be defined 
before pragma INUNE in the declarative part of the program. 


Description 

Pragma INUNE tells the compiler to insert code for the body of the subprogram each time the 
subprogram is called. If the named subprogram is a ^neric unit, the compiler inserts code for the 
bodies of all subprograms that are instantiations of that generic unit 

The following restrictions apply to pragma INUNE: 

• The nesting level of inlined procedures cannot exceed 100. 

• A program that inlines a function that returns an unconstrained objea will not work correctly. 
The ADE will not inline the following: 

• Recursive subprograms 

• Subprograms containing exception handlers 

• Any unit that declares a task, task type, or access to a task type. 




08M0007tM2 

updatM0e»OQ00734Q 




ANSI/MIL-STO- 1815 A Adt B«ferenc« Manual 


pragma INLINE (continued) 


Example 

This example shows two assembly (.SR) files for the following source code. The first assembly file 
shows the source code compiled with pragma INUNE. The second example shows the assembly 
file without the pragma. 

Source Code 

In the following example, pragma INUNE applies to all the calls to SQUARE in wrrH_INLINE. 

procedure WITH INUNE is 
RRST, SECOND; INTEGER; 
function SQUARE (S : INTEGER) return INTEGER; 
pragma INUNE (SQUARE); 

function SQUARE (S : INTEGER) return INTEGER is 
begin 

return S * S; 
end SQUARE; 
begin 

RRST SQUARE (2); 

SECOND :• SQUARE (SQUARE (RRST)); 
end WITH INUNE 


oeecoooro^ 
updatn oeecoooT^co 


F-7 






ANSI/MIL-ST0-tai5A Ada Rartranc* Manual 


pragma INLINE (continued) 


Assembly File witb Pragma INLINE 

Each time SQUARE ia called, the compiler ioserta code for that function. In the following 
example, SQUARE ia called three timea. The laat eight lines are the inlined subprogram. 

;; begin 

:: RRST;=. SQUARE (2): 

:: S : constant INTEGER ;» 2; 

;; return S * S - first inline expansion 

NLDAI 4.0 

XWSTA 0.12..3 :: RRST 

:: SECOND SQUARE (SQUARE (RRST)); 

S : constant INTEGER :» SQUARE (RRST); 

;; S : constant INTEGER FIRST; 

;; return S * S - second Inline expansion 

XWMUL 0.19..3 ;; S 

XWSTA 0.17..3 ::S 

;; return S * S - third inline expansion 

XWMUL 0,17..3 ;:S 

XWSTA 0.14..3 SECOND 

WRTN 
;; end 

:: function SQUARE (S ; 'NTFGER) return INTEGER is 
begin 

return S * S; 

XWLDA 0.@-12..3 

XWMUL 0.@-12.,3 

XWSTA 0,-8..3 

WRTN 
end 


F-a 


08»<XX»7t>02 

updataaOe»<XX307SOO 









ANSI/MIL-STD-1815A Ad* Raferanc* Manual 


pragma INLINE (continued) 


Assembly File Without Pragma INLINE 

begin 

RRST:- SQUARE (2); 


LPEF 

L3 

- push effective address [L3] > 2 

LCALL 

L2.1.1 

- first call to SQUARE 

XWSTA 

0.12..3 


:: SECOND :» SQUARE (SQUARE (RRST)); 

XWSTA 

0.17..3 


XPEF 

17.,3 

- push effective address [17] =4 

LCALL 

L2,1.1 

- second caii to SQUARE 

XWSTA 

0.19..3 


XPEF 

19..3 

- push effective address (19| = 16 

LCALL 

U1. 

- third call to SQUARE 

XWSTA 

0.14..3 


WRTN. 

end 

;; function SQUARE (S : 

; INTEGER) 

return INTEGER Is 

:: begin 
:: return S * S; 

L2: 


- beginning of the called function 

XWLOA 

0.@-12..3 


XWMUL 

0.0-12..3 


XWSTA 

0.-8..3 


WRTN 

;; end 


- end of the called function 


L3: 2 

.END 


F-» 


08e<XXX17O<}2 
updatas 0e»<XX»73O0 






ANSI/MIL-STO-iaiSA Ada Rafaranca Manual 


pragma INTERFACE 

Specifies another language (and calling conventions) for interfacing 
with an Ada program. 


Format 

pragma INTERFACE (languag0_name. subprogram_name); 

where: 

language_name SpedGes the language of the called subprogram. 

siJbprogram_name Specifies the name of the called subprogram. The subprogram 

must be declared earlier in the program. 

Description 

Pragma INTERFACE allows you to call program units written in other languages (foreign 
subprograms). A specification for the named subprogram must be written in Ada. The body of 
the subprogram can be written in another language. 

Pragma INTERFACE must be in the declarative part or package specification of the Ada unit that 
calls the subprogram. The subprogram you spcdfy as an argument must be declared earlier in the 
same declarative part or package spedficacion. 

Your program must indude the following pragma LOAD statements m the order shown: 

pragma LOAD ("ADE ROOT?:RUNTIMES:INTERFACE LRT TRIGGGER"); 
pragma LOAD ("LANG_RTXB’); 

You must be able to access LANG_RT.LB through one of the file access methods provided by the 
system, such as search lists or links. The IMPORT command links LANG RT.LB automaticidly. 
Use it to import routines written in F77, C, or PASCAL. 

Ada supports the calling of subprograms written in F77, PASCAL, C MASM, and ASSEMBLY. 

In addition, you can call any language that obeys the common calling conventions of DGC 
languages, but you will receive a compiler warning that the language is not explidtly supported. 

The Ada mntime interface traps any runtime errors in the called routine and raises the 
PROGRAM^ERROR exception in the calling program. The interface also suspends Ada tasking 
during the call to the non-Ada subroutine. 


F-IO 


08000007002 
updatM 08000007000 





ANSI/MIL-STD-181SA Ada Raferanca Manual 


pragma INTERFACE (continued) 

General Notes 

• Giaracters within constructs are packed according to DGC alignment requirements for the 
called language. 

• Booleans, arrays, and records are not packed. Booleans are passed one per word. 

• Return values are not checked for validity. 

• Procedure and function calls to other languages do not support type conversions. You must 
do type conversions explicitly. 

• You can pass ACCESS types, but exercise caution when changing Ada data structures. Data 
Genera' may change data formats in a future revision. After receiving any revisions of the 
ADE, test thoroughly all programs that depend on specific data formats. 

• LANG_RT performs the exception hanrfKng for foreign subprograms. If a foreign 
subprogram has an error, that error is propagated to the «>lli"g Ada program as a 
PR0GRAM_ERR0R. 

• Foreign subprograms must be in the same ring as the tilling Ada program. 

• Foreign subprograms can perform I/O operations, but it is the user's responsibility to use 
pragma LOAD to load all the necessary runtime objects. Alternately, you can use the 
template facility provided by ADALINK. 

• The foreign code interface does not support Ada unconstrained types for any languages. 

• Aii appropriate LB and OB files must be loaded into Ada programs that call foreign 
programs. The IMPORT function only ensures that the OB containing your function and 
LANG_RT are loaded with pragma LOAD. If the foreign code requires additional r untim e 
support^ such as MULTTTASKING.OB, you should add the names of all necessary OB and 
LB files to interfacejrackageJB file. This file is created by IMPORT or by ADALINK 
templates. 


08»<XXX70<I2 
updatM Oes-OOOOTMO 


F-n 







ANS1/MIL-STD-1815A Ada Referanca Manual 


pragma INTERFACE (continued) 


Foreign Language Calling Conventions and Data Types 


The following sections describe the calling conventions and/or the data types used by DGC Ada to 
call subprograms written in foreign languages. 

MASM or ASSEMBLY 

The MASM and ASSEMBLY options provide the standard Ada calling conventions. If either is 
specified, the called program (which may or may not be MASM or ASSEMBLY) is expected to 
follow Ada calling conventions and to know how Ada data structures are formatted. 

F77 

F77 is supported as follows: 


F77 Data Type Ada Data Type 


INTEGER*4 

INTEGER-2 

REAL-4 

REAL-8 

CHARACTER-1 

CHARACTER-N 

ARRAY 


INTEGER 
SHORT INTEGER 

float' 

LONG FLOAT 
CHARACTER 
STRING(1..N) 
ARRAY 


Notes: 

• Array elements must be of a supported scalar type. 

• Scalar parameters are passed copy*in copy-out. 

• One-dimensional arrays are passed by reference for copy-in copy-out. 

• Multidimensional arrays obey copy-in copy-out rules. 


F-12 


08e^XXX>7002 
upeant oe»oooo73^ 







ANSI/MII.-ST0-181SA Ada Paterance Manual 


pragma INTERFACE (continued) 

C 

C is supported as follows: 


C Data Type 

Ada Data Type 

SHORT INT 

SHORT INTEGER 

LONG INT 

LONG ii^GER 

SHORT FLOAT 

FLOAf 

LONG FLOAT 

LONG FLOAT 

CHARACTER 

CHARACTER 

POINTER 

ACCESS 

ENUMERATION 

ENUMERATION 

ARRAY OF CHARACTER 

STRING 

ARRAY 

ARRAY 

STRUCmRE 

RECORD 


Note: C calling conventions specify pass by value. Therefore, only copy*m mode is allowed for 
scalar parameters and structures. The call interface enforces pass by value for arrays. 


PASCAL 

Pascal is supported as follows: 


PASCAL Data Type 

Ada Data Type 

SHORT INTEGER 

SHORT INTEGER 

LONG n^GER 

INTEGER 

real' 

FLOAT 

DOUBLE RE.AL 

LONG FLOAT 

BOOLEAN 

BOOLEAN 

CHAR 

CHARACTER 

ENUMERATION 

enumeration 

POINTER 

ACCESS 

ARRAY 

ARRAY 

PACKED ARRAY OF CHAR 

STRING 

RECORD 

RECORD 


Notes: 

• Not supported: RECORD VARIANTS, SET, FILE, 
a One-dimensional arrays are passed by reference for copy-in copy-out. 
a Multidimensional arrays obey copy-in copy-out rules. 


086-00007002 
updatM 060-00007000 


F-13 









ANSI/MIL-ST0-181SA Ad« Ratarane* Manual 


pragma INTERFACE (continued) 

PL/1 

PL/l is supported as follows: 


PL/l Data Type 

Ada Datal)rpe 

FIXED BINARY (If) 

SHORT INTEGER 

FIXED BINARY (31) 

INTEGER 

FLOAT BINARY (21) 

FLOAT 

FLOAT BINARY (53) 

LONG FLOAT 

POINTER 

ACCESS 

ARRAY 

ARRAY 

RECORD 

RECORD 


Notes: 

a PL/l is not explicitly supported; however, the data types listed above can be used if ail dau 
follows standard LANG^RT alignment and space characteristics. Specifying PL/l produces 
warning messages when you compile the program. 

a Otte*dimensional arrays are passed by reference for copy>in copy>out 

a Multidimensional array obey copy*in copy*out rules. 


F-14 


oaeooooro^ 

updatao 08»400Q73.00 







ANSI/UIL-STD- 181 SA Ada Raferanca Manual 


pragma LIST 

Suspends or resumes the compiler listing file output. 


Format 

pragma LIST (ON [ OFF); 

Description 

The compiler always produces a listing (XST) Sle unless you do one of the following: 

• Include the /ERRORS switch with the ADA command (and the compilation units contain no 
errors) 

a Include pragma LIST (OFF); in the compilation nnir 

Pragma LIST (OFF); suspends the output in the XST 61e during compilation. 

Pragma LIST (ON); resumes .LST output. 

Example 

In the following example, the code for MEMBERS is not printed in the listing Sle. 

procedure MAIN is 
type MEMBERS is private; 
procedure SORT (LIST: in out MEMBERS); 
function HEAD (L UST) return MEMBERS; 

pragma LIST (OFF); 
type MEMBERS is 

end MEMBERS; 
pragma LIST (ON); 
begin 

end MAIN; 


oeedoooTooa 

updatMOe»<X)0073-00 


F-15 







ANSI/MIU-STO-iaiSA Ada Rafarenca Manual 


pragma LOAD 

Includes non>Ada object flies in the linked program file. 


Format 

pragma LOAD (*object_file_pathname*): 


where: 

objectjile^pathname Specifies the STRING literal (in quotes) that denotes the full 

pathname of the non-Ada olqect file you want to load. You do 
not need to include the .OB Rename extension. 


Description 

Pragma LOAD allows you to include foreign (non-Ada) object files in your program. You can use 
it with pragmas INTERFACE and ENTRY^POINT to allow Ada procedures to call non-Ada 
subprograms. The Ada Linker includes the named object file when it builds the Ada program 
(.PR) file. 

Pragma LOAD must appear at the head of a compilation for a body. When using pragma LOAD 
with compilation subunits, always spedfy the /READ_SUBUNrrS switch on the ADALINK 
command line. If you omit that switch, you may receive this error message Grom the Linker 

"Can’t get [body] tree for <program^unit^oame>* 

Note: Pragma LOAD does not guarantee the order of the loaded files. If order is important, use 
the /TEMPLATE switch with the ADALINK command. 

Example 

In the following example, the file SEVEN^UP.OB must be in the current directory. 

pragma LOAD (■SEVEN_UP"); 
with TEXTJO; use TEXf^lO; 
procedure'"ADA_CALLSjPL1 is 
procedure SEVEN Ul^p(: out INTEGER); 
pragma INTERFACE (PL1. SEVEN UP); 
pragma ENTRY POINT (SEVEN UP. "SEVEN UP^; 

N: INTEGER; 
begin 

SEVEN UP (N); 

PUT (Njl 

end ADA CALLS PL1; 


F-1« 


0Se^XXX>7t>O2 

updMMoeeoQooTMO 





ANSI/MIL'ST0-1815A Ada Rafaranca Manual 


pragma MAIN 

indicates that a subprogram unit is a main program. 

Format 

pragma MAIN; 

Description 

Pragma MAIN designates the main subprogram unit. Place pragma MAIN immediately after the 
subprogram you want to be the main subprogram. 

Exampie 

The following code designates TEST as the main procedure, 
procedure TEST is 
procedure RRST is 
end RRST; 

procedure SECOND is 

end SECOND; 
begin 

end TEST; 
pragma MAIN; 


08M0007002 

updMMoeacooorMo 


F-17 






ANSI/MIL-STO-1815A Ada flafaranca Manual 


pragma MAIN (continued) 

Another way to <<Kting iiwh the main subprogram in a compilation unit is to use the 
/MAIN PROGRAM switch on the ADE command line. For example, you can compile the 
procedure TEST, located in the source Sle TEST ADA, as a main program with this command: 

-) ADA/MAIN_PROGRAM-TEST TEST 

You must use the /MAlN_PROGRAM switch in each of the following cases: 

a The source Ole that you are compiling contains more than one library unit 

a You specify more than one source Sle with the same ADA command. The compiler assumes 
that the Srst Sle listed contains the main program. If it does not, you must specify which 
subprogram is the main program with the /MAIN_PR0GRAM switch. For e xam ple, the 
following command compiles the source Sles FOOADA, FOOBARADA, and TI^TADA. 
It compiles the subprogram TEST AD A as the main program: 

-) ADA/MAIN_PROGRAM-TEST FOO TEST FOOBAR 

For more information about the ADA command, refer to the ADE User’s Manual. 


F.18 


08S00007002 

updatMOeMOOOTMO 




ANSI/MIL-ST 0 - 181 SA Ada Rafaranca Manual 


pragma MAX_TASKS 

Specifies the maximum number of Ada tasks you want active 
simultaneously. 


Format 

pragma MAX_TASKS (n); 


where: 

n Specifies an integer value greater than zero. 

Description 

Pragma MAX_TaSKS specifies the maximum number of Ada tasks fhar can be active at the same 
time. If you do not spedfy the number, the system gives you a maximum of SO. 

This pragma must appear at the head of a compilation. It applies to all units in the compilation. 

Example 

pragma MAX_TASKS(40); 
package body TASKS is 

task ONE is...; 
task TWO is...; 

task type THREE TO FORTY is...; 
type remaining" TASKS is 
array (3..40) of fHREE TO FORTY; 

MULTI_TASKS: REMAINING JASKS; 

end TASKS; 


You can also specify the maximum number of tasks by using the /MAX_TASKS switch with the 
ADALINK command. For example: 

-)ADAUNK/MAX_TASKS-40 object_fllename 

If you specify a maximum number of Ada tasks with both a pragma and a switch, the pragma takes 
precedence. For more information, refer to the User’s Manual. 


086.00007002 

updatM oeeooooTooo 


F-19 








ANSI/MIL-ST0-iai5A Ada Rateianca Manual 


pragma MV_ECS 

Specifies the use of the Data General MV External Calling Sequence. 


Format 

pragma MV_ECS( unit^name (,unit_name...J); 


where: 

unit name Specifies the name of the subprogram for which you need the 

compiler to generate MV ECS. 


Description 

To opdfflize code quality, the compiler does not always generate code that conforms to the Data 
General MV External Calling Sequence (ECS). In some cases, however, you will need to tell the 
compiler that MV ECS is necessary. Subroutines that meet any of the following criteria must use 
MV ECS: 

• MACHINE^CODE subroutines with formal arguments 

• Subroutines called from other DGC languages 

• Subroutines that can be called from outer rings. 

Place pragma MV^ECS immediately after the subprogram for which you want the compiler to 
generate MV ECS. 

Example 

procedure TEST is 
procedure RRST is 
end RRST; 

procedure SECOND is 

end SECOND; 
begin 

end TEST; 

pragma MV_ECS( TEST); 


P-20 


OSMOOOTOCS 

updaiMOe»000073-00 







ANSi/MiL-ST0-i8lSA Ada Rafarenc* Manual 


pragma PAGE 

Begins a new page in the compiler output listing file. 

Format 

pragma PAGE; 

Description 

The compiler produces a listing (.LST) Gle unless you do one of the following: 

a Include the /ERRORS switch with the ADA command (and the compilation unit contains no 
errors) 

a . Include pragma LIST (OFF); in the compilation unit. 

If the compiler is produdng a listing of the compilation, pragma PAGE causes the text following 
the pragma to appear on a new page. 

Example 

In the following example, procedure SECOND would be printed on a page by itself. 

procedure FIRST is 

end RRST: 

pragma PAGE; 
procedure SECOND is 

end SECOND; 

pragma PAGE; 


08»00007t>02 
updatM OafrOtXXJTSOO 


F-21 








ANS1/MIL-STD-181SA Ada Rafafenca Manual 


pragma PRIORITY 

Specifies the priority of a task or task type. 


Format 

pragma PRIORITY (n); 


where: 

n Specifies an integer value from 1 to 10. Lower values indicate 

lower priorities. 

Description 

You can assign priorities to tasks or task types by including pragma PRIORITY within the 
appropriate task specifications. 

Assigning priorities tells the system how to handle competing tasks. When more that one task is 
eligible for execution at the same time, the system executes them in the order you specify with 
pr agma PRIORITY. Tasks that are ready for execution are queued first by priority number and. 
wi thin priorities, by order of their occurrence in the source file (FIFO). 

You can assign each task or task type only one priority. If you as.sign more than one priority, the 
system recognires the first assignment and ignores the others. 

Ali gning priorities is optional The default priority is 5. 


Example 

The following code assigns a priority of 7 to TASK__TYPE and a priority of 8 to NEXT_TASK. 

procedure OUTER Is 

task type TASK_TVPE is 
pragma PRIORITY (7); 

end TASK_TYPE: 

task type NEXT_TASK is 
pragma PRIORITY (8); 

end NEXTJASK; 

end OUTER; 


P-22 


oee40007t>o2 

updsMtOee^OOOTMO 









ANSI/MIL-STO-1815A Ad> R*faf«nc# Manual 


pragma SUPPRESS 

Suppresses specified runtime checks. 


Format 

pragma SUPPRESS (checkjdentifier [, [ON = >| name}); 


where: 

checkjdentifier Specifies the check you want to suppress. Check identifier 

names are listed in the description that follows. 

name Specifies the nam e of a type, subtype, object task unit, generic 

unit, or subprogram. 

Description 

To suppress certain runtime checks, place pragma SUPPRESS in the declarative part of a program 
unit or block or immediately within a pack^e specification. For statements in a program unit or 
block, check suppression extends from the pragma statement to the end of the declarative part 
associated with that program unit or block. For statements in a package, check suppression 
extends to the end of the scope of the specified ON « > entity. You must declare that entity 
immediately within the pack^e specification. 

The following table shows the extent of check suppression for each named entity. 


Check suppression for 


Extends over 


An unnam ed entity (name omitted) 
An objea 

An object of the base type or subtype 
A task or task type 
A generic unit 
A subprogram 


The remaining declarative region 

All operations of the object 

Ail operations of the object or subtype 

Ail activations of the task 

All instantiations of the generic 

All calls of the subprogram 


08MCI007002 

updttM06»000073-00 


F-23 









ANSI/MIL-ST0.1815A Ada Bafarenca Manuai 


pragma SUPPRESS (continued) 

Although it is a better programming practice to have runtime exceptions raised automatically, you 
can suppress them if you need to decrease runtime overhead. When you suppress runtime checks, 
you turn off certain program exceptions. If an error arises after you have suppressed a check, your 
compiled program not work correctly. The following table shows which program exceptions 
you turn off when you suppress checks: 


Suppression of this 
checkjdentifler 

Turns off this 
exception 

When program detects this runtime 
error 

ACCESS_CHECK 

CONSTRAINT 

ERROR 

Selection or indexing applied to an 
object with a null value 

DISCIMINANT 

CHECK 

CONSTRAINT 

ERROR 

Violation of discriminant constraiut 

INDEX_CHECK 

CONSTRAINT 

ERROR 

Out-of-range index values 

LENGTH 

CHECK ' 

CONSTRAINT 

ERROR 

Wrong number of mdex components 

RANGE_CHECK 

CONSTRAINT 

ERROR 

Values exceed range constraint, or 
type is incompatible with constraint 

DIVISION 

CHECK ‘ 

NUMERIC 

ERROR 

Division, rem, or mod by zero 

OVERFLOW 

CHECK 

NUMERIC 

ERROR 

Operation result exceeds implemented 
range 

ELABORATION 

CHECK 

PROGRAM 

ERROR 

Attempt to call a unit before it is 
elaborated 

STORAGE 

CHECK 

STORAGE 

ERROR 

Over-allocation of memory space 


F-24 


08»<X)007tH)2 
updataa 0e>»^XX»7^<» 











ANSI/MIL-STD-1815A Ada fletarenca Manual 


pragma SUPPRESS (continued) 

Example 

In the following example, the pragma suppresses the checks on the indices of variables of the type 
TABLE. All type TABLE operations in MAIN are affected. No exceptions are r if X and Y 
are not in the range of I to 3. 

procedure MAIN is 
type COLOR is (RED. BLACK); 
type TABLE is array (1 ..8.1 ..8) of COLOR; 
pragma SUPPRESS (INDEX CHECK. ON= > TABLE); 

X. Y; INTEGER; 

BOARD; TABLE; 
begin 

BOARD P(,Y) := RED; 
end; 


08e-000070d]2 

Updttaa0e»000073^ 


F-25 






ANSI/MIL-ST0>1S15A Ada Rafaranca Manual 


pragma TASK_STORAGE_SIZE 

Specifies the amount of heap storage space to allocate for task 
stacks. 


Format 

pragma TASK_STORAGE_SIZE (n); 


where: 

n Specifies the total cumber of 2-byte words you want to allocate 

for all active task stacks. The variable c can be any integer 
value, but only values greater than -1 have an effect. 


Description 

Pragma TASK_STORAG£_SI2£ allows you to reset the amount of heap space to allocate for all 
task stacks. The amount of space you specify should exceed the amount of storage you need at one 
time for all active tasks. By default, the system allocates 128 K words. 

The pragma must appear at the head of a compilation. It applies to the entire compilation unit. 

You can also use the /TASK__STORAGE_SI2E switch on the ADALINK command line to 
control the maximum heap space allocated to active task stacks. If you use both the pragma and 
the command switch, the pragma takes priority. 

Resetting MTOP 

If you need to set TASK__ST0RAGE_SIZE to a value greater than the current virtual address 
space allows, you must reset the maximum virtual address space by specifying the value of MTOP. 
MTOP defines the maximum virtual address for a program. Use the /MTOP switch with the 
ADALINK command to specify how many megab)^es.your program requires. The default value of 
MTOP is 1 Mbyte. 

For example, this command resets MTOP to 20 Mbytes: 

-) ADAUNK/MTOP=«20 obJect_file 


F-2e 


080-00007002 
updatM 069-00007000 




ANS 1 /MIL-STD-' 315 A Ada Raferanca Manual 


pragma TASK_STORAGE_SIZE (continued) 

Individual Task Storage 

By default, the system allocates 2048 words for each active task stack. If you require a larger or 
smaller stack for a particular task type, use the STORAGE_SIZ£ represeatation clause. For 
example, the following clause tells the compiler to associate task type BIG with a stack of size N: 

for BIG’STORAGE JIZE use N; 

The tninimiim stack size that you can specify is 512 words. 

Example 

In the following example, the value given in the pragma exceeds the storage required for all tasks 
executing at one time. 

pragma TASK_STORAGE_SI2E(56_000) 
procedure MaTn is 

task type ONE is...; 

for ONE’STORAGE^SIZE use 1_000; 

task type TWO is...; 

for TWO*STORAGE_Sf2E use 2J00: 


task type TEN is 

forTEN’STORAGE_SI2E use 10_0Q0: 
end MAIN; 


08»e0007002 
updataa oeeoOOOTSCO 


F-27 





ANSI/MIL-ST0>181SA Ada Rafaranca Manual 


Package SYSTEM 

The predefined library package SYSTEM defines certain types, subtypes, and objects that are 
spedHc to DGC Ada. The package SYSTEM is described in the LRM, Section 13.7. 

SYSTEM contains the following declarations: 


package SYSTEM is 


type ADDRESS is new INTEGER: 

type NAME is (MV); 


SYSTEM NAME 

: constant:» NAME ;» MV; 

STORAGE UNIT 

: constant: > 16; 

memory_size 

: constant:» 2 *• 29; 

MAX INT 

: constant(2**30) -1 + (2**30); 

MIN “NT 

: constant;» -MAXJNT -1; 

MAX DIGITS 

: constant IS: 

max“mantissa 

: constant 31; 

FiNE“ DELTA 

; constant: - 2.0 •* (-31): 

tick" 

: constant :* 0.1: 

subP/pe PRIORITY is INTEGER range i .iO; 


end SYSTEM; 


The following table describes these types and constants and gives the value of each. 


Type or Constant 

Defined as 

Explanation 

ADDRESS 

nMTEGER 

Address clauses and attributes 
(P’ADDRESS) return objects of the 
derived type ADDRESS. 

NAME 

MV 

The enumeration type NAME 
declares one objea: the literal MV. 

SYSTEM_NAME 

MV 

SYSTEM_NAME is an object of type 
NAME and is initialized to MV. 

STORAGE_UNIT 

16 

Denotes the number of bits per 
storage unit. 

MEMORY JIZE 

2**29 

Denotes the number of available 
storage units. 

MAX_INT 

(2**30)-l + (2**30) 

- 2_147_483_647 

Denotes the highest value of 
predefined INTEGER types. 


P-28 


086-00007002 
updataa 08000007300 









ANSI/MtL-STD-i8l5A Ada Reference Manual 


IVpe or Coastant 

Defined as 

Explanation 

MINJNT 

-MAX INT -1 » 
-2_147j83_648 

Denotes the lowest (most negative) 
value of prede&ied INTEGER types. 

MAXDIGITS 

15 

Denotes the largest number of 
significant decimal digits in a floating¬ 
point constraint. 

MAX_MANnsSA 

31 

Denotes the largest allowed number 
of binary digits in the mantissa of 
model numbers of a fixed-point 
subtype. 

FINE_DELTA 


Denotes the smallest delta allowed in 
a fbced-point constraint that has the 
range constraint -1.0..1.0. 

TICK 

0.1 

Denotes the basic clock period in 
seconds. 

PRIORITY 

L.10 

Declares the range of values you can 
use on pragma PRIORITY 
statements. PRIORITY is a subtype 
of the base type INTEGER. 


08M0007002 
updatM OeMOOOTSOO 


F-29 








ANS1/MII.-ST0.1815A Ada Rafarenca Manual 


Representation Clauses 

This sectioa describes the use of represeacacion clauses in the ADE. You can use representation 
clauses for either of two purposes: 

a To specify a more efficient representation of data in the underlying machine 

a To communicate with features outside the domain of the Ada language, for example, 
peripheral hardware. 

The Ada programming language provides four classes of representation clauses: 


Clause Class 

Specifies 

Length clause 

The amount of storage you want associated 
with a type. 

Enumeration representation 

The internal codes for the literals of an 
enumeration type. 

Record representation 

The storage order, relative position, and size of 
record components. 

Address clause 

The required address in storage for an entity. 
Address clauses are not supported by the 

ADE. To assign internal names, use pragma 
ENTRY_POINT whenever possible. 


The following paragraphs describe the use of each class of representation clauses. 


Length Clauses 

You can use the ’STORAGE_SIZ£ attribute only for reserving storage for activating a task type. 
For example: 

BITS :constant;*l: 

BYTES :constant:*8*BITS; 

KBYTES constant: -1024*BYTES; 

task type MONITOR Is...; 

for MONITOR’STORAGE_SI2E use 4-KBYTES; 

The ADE does not support the ’SIZE and 'SMALL attributes. 


F-30 


08e<XXX37042 
updatM oe0-00007y<x 





ANSI/MIL*STD-iaiSA Ada Rafarenca Manual 


Enumeration Representations 

The ADE supports enumeratioa representation clauses as specified in the LRM, Section 13 All 
enumeration literals must be provided with distinct, static integer codes. The sequence of integer 
codes specified for the enumeradon type must consistently increase in value. 

There are two restrictions: 

a The range of internal codes must be a SHORT_INTEGER. 

a Enumeration types with representation clauses are not allowed as the index type of an array 
type definition (refer to the LRM, Section 3.6). 

Change of Representation 

To change the representation clause of a type, you can declare a second type, derived fi-om the 
first, and assign the variables of the first type to the second type. This process is described in the 
Section 13.6. 

Operations of Discrete Types 

If you use the attributes TOS, 'VAL, 'SUCC, and ’PREP, the program may involve 

additional runtime overhead. Since potentially noncontiguous internal codes must be mapped to 
position numbers, executing the program involves additional overhead if the argument is nonstatic 
or is a disaete type or subtype whose base type is enumeration representation. Refer to the LRM, 
Section 133 for more information. 

Conversions that Cause Overhead 

Explicit conversions between enumeration types in which either base type has a representation 
• clause may cause additional runtime overhead. The argument itself and the method of conversion 
both effect the amount of overhead. 

You can perform explicit conversions between enumeration types by using an attribute such as 
'PCS or 'SUCC to evaluate an argument and assign the results to a variable of the target type. 

You can also perform explicit conversions by using the attribute and its argument as the actual 
parameter in a subprogram calL Each method of converting between types causes additional 
overhead if the argument is nonstadc In the latter case, Ada performs checks on the actual 
parameter that may also add overhead. 

Sections 333 , 4.6, and 6.4.1 of the LRM provide more information about explicit conversions and 
parameter associations. 


08»00007002 
updatM 0e»000073^ 


F-31 







ANS1/MIL-STO-1815A Ada Referenca Manual 


Case Statements 

If the base type of the case statement expression is an enumeration type with a representation 
clause, the resulting code is optimized with respect to space rather than time. The value of the 
statement expression is compared with case alternatives until a match is found. 

Case statements with types other than enumeration with a representation clause are unaffected. 


Loop Statements 

FOR loops for which the base type of the loop parameter is an enumeration type with a 
representation clause causes additional nmtime overhead. (For more information refer to the 
LRM, Section 3JS). 

Loop statements for which the base type is not an enumeration type with a representation clause 
do not cause additional overhead. 


Record Representations 

Representation of record types in the ADE is the same as in standard Ada with certain 
restrictions. Specifically, you cannot use record representation clauses to specify alignment and 
component locations for the following; 

• Record types with discriminants 

• Record types with variant parts 

• Record types with array components. 

When specifying component storage, you can cross only one lb-bit word boundary. You cannot 
specify the storage for composite, FLOAT, or LONG_FLOAT components. For components of 
these types, the compiler automatically determines the storage required. You can specify storage 
for all the remaining component types the same way as in standard Ada. 


F-32 


08«^X»07&02 
upeatM oe»000073<X) 





ANSI/MIL-STD-)815A Ada Refarence Manual 


The following example shows a valid record representation specification: 

type lUFl. is 
record 

RETURN FLAGS 
TERMINATION FIELD 
PROCESSJD “ 
end record; 
for lUFL use 
record 

RETURN FUGS 
TERMINATION FIELD 
PROCESSJD “ 
end record: 

These component clauses specify the order, position, and size of lUFL fields relative to the start of 
the lUFL record. They also ensure that the lUFL fields match the structure of the ?IUFL offset 
(user flag word) in a ?IR£C system call: 


: INTEGER range 0 .. 7; 

: INTEGER range 1.. 255; 


at 0 range o.. 4; 
at 0 range 5.. 7; 
at 0 range 8.. IS; 


Field 

Field 

Boundaries 

Contents 


0-4 

RETURN FUGS 

5-7 

termination field 

3-L5 

PROCESS ID 


The ADE does not allow components to overlap storage boundaries; that is, record fields cannot 
cross more than one 16-bit word boundary. 


Unchecked Programming 

The AOE implements the predefined, generic library subprograms 
UNCHECKED_DEALLOCATION and UNCHECKED_CONVERSION. The following 
sections explain how to use these subprograms. 


08 »<xxxm >02 

updatM0a»CQt)073.00 F‘33 








ANSI/MII.-ST01815A Ada Ratarenca Manual 


Procedure UNCHECKED_DEALLOCATION 

You can use the generic procedure UNCHECKED_DEALLOCATION to deallocate dynamic 
objects explicitly that are designated by values of access types. To deallocate dynamic objects 
explicitly, your program must instantiate this procedure for a particular object and access type. In 
the program body, a call to the instantiated procedure specifies the dynamic object as a parameter. 
When that call is executed, the specified object is deallocated, and its value is set to null. The 
following example shows how this works: 

Example 

In the foUowing example, the call to the procedure DISPOSE deallocates the dynamic object 
designated by the access value ROOTl and resets ROOTl to null. However, if the enclosing 
procedure uses the other access value, ROOT2, to designate the same object as ROOTl, this code 
causes a program error because the object no longer exists. You must watch for similar d a ng li n g 
references when using the procedure UNCHECKED_DEALLOCATION. 

with UNCHECKED_OEALLOCAT10N; 
package TFEE_L^BELER is 

type LABEL^TYPE is private; 
t^e NODE;” 

type TREE is access NODE; 
type NODE is record 
LABEL ; LABEL TYPE; 

LEFT : TREE;" 

RIGHT : TREE; 

end record; 


procedure DISPOSE is new UNCHECKED_DEALLOCATION (NODE. TREE): 


procedure-LABEL ROOT (LABEL 

ROOT 
LABELLED TREE 

end TREE LABELER; 


in LABEL_TYPE; 
in out TREE; 
out TREE); 


package body TREE_LABELER Is 
procedure LABEL ROOT (LABEL 

ROOT 

LABELLED TREE 
ROOTl. RdOT2 


In UBEL_TYPE; 
in out TREE; 
out TREE); 
NODE; 


begin 

DISPOSE (ROOT1); 

end LABEL ROOT; 
end TREE_LABELER; 


F-34 


osecoooTtvoa 

upd«Mt0e»<XX»7340 








ANSI/MIL-ST0-iai5A Ada Rafaranca Manual 


Function UNCHECKED_CONVERSION 

The generic function UNCHECKED_CONVERSION allows you to return the value of a copy-in 
param eter as a Value of a target type. The actual bit pattern corresponding to that parameter value 
does not change. 

The function UNC3iECKED_CONVERSION is a unit in the ADE SYSTEM library. The visible 
part of that function is listed below: 

generic 

type SOURCE is limited private; 
type TARGET is limited private; 

function UNCHECKED_CONVERSION (S: SOURCE) return TARGET; 

function UNCHECKED CONVERSION (S : SOURCE) return TARGET is 
pragma SUPPRESS (RANGE_CHECK): 
b^in 
return S; 

end UNCHECKEO_CONVERSION; 

For instandadons of rhi« generic funedon, types SOURCE and TARGET must be of the same 
nta«« and the same length. SOURCE and TARGET cannot be array types. 

For more informadon about unchecked conversions, refer to the LRM, Secdon 13.10. 

Example 

The following example shows source code that uses the funedoq UNCHECKED_CONVERSION. 

with UNCHECKED_CONVERSION. ALPHA; 
package SETA is 
type TEST_NAME is private; 
t^e OATAIs record 

IS VAUD : BOOLEAN; 

TEST^OBJECT ; TEST_NAME; 

end record; 

function CONVERT TO BETA DATA is new 
UNCHECKED CONVERSION {ALPHA.INFO. DATA); 
function CONVERT FROM BETA DATA is new 
UNCHECKED_CONVER^ON (DATA. ALPHA.INFO); 

end BETA; 


oaeooooTpoa 

updatMOe»00007300 


F-35 






ANSI/MIL-STD-1815A Ada Beferenca Manual 


Characteristics of ADE input/Output Packages 

The standard input and output files in TEXT_IO correspond to the AOS/VS generic files 
@INPUT and ©OUTPUT, respectively. For more information about AOS/VS generic files, refer 
to the DGC manual. Learning to Use Your AOS/VS System. 

When you are using the ADE I/O packages, remember the following; 

• The maximum value for TEXTJO.COUNT and TEXT_IO.FIELD is SYSTEM.MAX_INT. 

• The FORM parameter of the TEXT_IO.OPEN procedure is not used. 

• Type TEXT_IO.FILE_TYPE is an access type. 

For more information about input/output operations in the ADE, refer to the ADE User’s Manual. 


F-36 


080-00007002 
updataa 08000007000 












ANSI/MIL-ST0-iai5A Ada R«<«renc« Manual 


Maximum Size Limits in the ADE 

The ADE places the following absoitue limits on the use of Ada language features: 


Compilation step 

Language Feature 

Maximum 
or amount 

Syntax parsing 

Length of identifiers 

120 


Length of line 

120 

Semantics checking 

Discriminants in constraint 

256 


Associations in record aggregate 

256 


Fields in record aggregate 

256 


Formals in generic 

256 


Nested contexts 

250 

Generating machine code 

Indices in array aggregate 

128 


Parameters in call 

128 


Nesting depth of expressions 

100 


Nesting depth of iniined expressions 

100 


Nesting depth of packages with tasks 

100 


F.37 


08»000a70<}2 

updatM0e»<XX)073^ 







ANS1/MIL-STD-1815A Ada Rafarenca Manual 


Summary of the ADE Real Type Attributes 

The following section lists the name and value for each ADE spediic real attribute. 


Float Type 

Value 

TMACHINE^RADDC 

16 

TMACHINE^MANTISSA 

6 for FLOAT 

14 for LONG_FLOAT 

It is the number of TMACHINE_RADIX 
(hex) digits in mantissa. 

rMACHINE_EMAX 

63 

U is the maximum exponent for MV floating 
types, base 16. 

rMACHINE_EMIN 

-64 

It is the minimum exponent for MV floating 
types, base 16. 

TMACHINE^ROUNDS 

TRUE 

rMACHINE_OVERFLOWS 

TRUE 

rSAFE^EMAX 

252 

The formula is: 

log, (TMACHINE RADIX) * 
r^CHINE_EMAX 

rSAFE_SMALL 

2.0 *• (-rSAFE_EMAX -1) 

rSAFE_L\RGE 

2.0 •• TSAFE EMAX * (1.0 - 2.0 ** 
(-TBASE’MANTISSA)) 


F-38 


08S4XXX)7OO2 
updataa 08»00007340 





ANSI/MIL-ST0-181SA Ada Rafaranca Manual 


FLudTVpes 

Value 

TMACHINE^ROUNDS 

TRUE 

rMACHINE^OVERFLOWS 

TRUE 

TBASE’SMALL 

•TSMALL 

TBASE’MANTISSA 

31 

(Same as SYSTEMMAX_MANnSSA) 

rSAFEJMALL 

» TBASE’SMALL 

TSAFE_LARGE 

- TBASE’LARGE 


also 


. (2 •• TBASE’MANTISSA ■ 1) * 
TBASE’SMALL 


08««0007tH» 

updatM08»<XX»7300 


F-39 








ANSI/MIL-STD-1815A Ada Raforanca Manual 


Geoerai Notes 

• All fixed-point numbers are stored in 32-bit integers. 

a Floating-point types requiring 5 digits or less of precision are stored in FLOAT; chose 
requiring 6 to 14 digits are stored in LONG_FLOAT. 

• FLOAT and LONG_FLOAT use 1 bit for the sign and 7 bits for the exponent (of 16) in 
excess-64 notation. FLOAT has 24 bits available for the mantissa; LONG FLOAT has 56. 

• For FLOAT and L0NG_FL0AT, the smallest number that can be represented in the MV 
architecture is given by the following formula: 

TMACHINE_RADIX ** (TMACHINE_EMIN -1). 

This is equal to 16 ” (-65) or 16#0.10000000000000# * 16 ** (-64). 

• For FLOAT and LONG_FLOAT, the largest number that can be represented in the MV 
architecture is given by the following formula: 

(1.0 - TMACHINE RADIX *• (-TMACHINE MANTISSA)) * 
(TMACHINE_RADIX ** TMACHINE_EMa3C). 

For FLOAT, this is equal to 16#0.FFFFF# • 2 *• (63). 

For LONG_FLOAT, this is equal to the following: 

16#0.FFFFFFFFFFFFFF# * 2 ** (63) for LONG_FLOAT. 


I 


F-40 


08»00007042 
updatM 0e»'000073-00 






ANS)/MII.-STD-i 815A AOa R*(«t6nc« Manual 


Type Definitions in the ADE 

The ADE defines the types INTEGER, FLOAT, and DURATION as follows; 


Type 


Definition 


INTEGER The set of integers begins with the value MIN INT and ends 

with MAXJNT. The formulas for MlN_lNT"and MAX_INT 
are described under 'Package SYSTEM.' 

FLOAT The type FLOAT is defined by the values described in the notes 

under 'Summary of the ADE Real Type Attributes.' 

DURATION The type DURATION is defined as follows; 

2.0 •• (-9) range *2 •• 22... 2 **22; 


End of Appendix 




APPENDIX C 


TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, such as 
the maximum length of an input line and invalid file names. A test that makes 
use of such values is identified by the extension .TST in its file name. Actual 
values to be substituted are represented by names that begin with a dollar sign. 
A value must be substituted for each of these names before the test is run. The 
values used for this validation are given below. 


C-1 



MACRO.DFS 


ACVC VERSION 1.10 


— THIS FILE CONTAINS THE MACRO DEFINITIONS USED IN THE ACVC TESTS. 

— THESE DEFINITIONS ARE USED BY THE ACVC TEST PRE-PROCESSOR, 

— MACROSUB. MACROSUB WILL CALCULATE VALUES FOR THOSE MACRO SYMBOLS 

— WHOSE DEFINITIONS DEPEND ON THE VALUE OF MAX_IN_LEN (NAMELY, THE 

— VALUES OF THE MACRO SYMBOLS BIG_ID1, BIG_ID2, BIG ID3, BIG_ID4, 

— BIG_STRING1, BIG_STRING2, MAX_STRING_LITERAL, BIG_INT_LIT, 

— BIG_REAL LIT, MAX_LEN_INT_BASED_LITERAL, MAX_LEN REAL_BASED_LITERAL, 

— AND BLANKS). THEREFORE, ANY VALUES GIVEN IN THIS FILE FOR THOSE 

— MACRO SYMBOLS WILL BE IGNORED BY MACROSUB. 

— NOTE: THE MACROSUB PROGRAM EXPECTS THE FIRST MACRO IN THIS FILE TO 

BE MAX_IN_LEN. 

— EACH DEFINITION IS ACCORDING TO THE FOLLOWING FORMAT: 

— A. A NUMBER OF LINES PRECEDED BY THE ADA COMMENT DELIMITER, —. 

THE FIRST OF THESE LINES CONTAINS THE MACRO SYMBOL AS IT APPEARS 
IN THE TEST FILES (WITH THE DOLLAR SIGN). THE NEXT FEW "COMMENT" 

LINES CONTAIN A DESCRIPTION OF THE VALUE TO BE SUBSTITUTED. 

THE REMAINING "COMMENT" LINES, THE FIRST OF WHICH BEGINS WITH THE 
WORDS "USED IN: " (NO QUOTES), CONTAIN A LIST OF THE TEST FILES 
(WITHOUT THE .TST EXTENSION) IN WHICH THE MACRO SYMBOL APPEARS. 

EACH TEST FILE NAME IS PRECEDED BY ONE OR MORE BLANKS. 

— B. THE IDENTIFIER (WITHOUT THE DOLLAR SIGN) OF THE MACRO SYMBOL, 

FOLLOWED BY A SPACE OR TAB, FOLLOWED BY THE VALUE TO BE 
SUBSTITUTED. IN THE DISTRIBUTION FILE, A SAMPLE VALUE IS 
PROVIDED; THIS VALUE MUST BE REPLACED BY A VALUE APPROPRIATE TO 
THE IMPLEMENTATION. 

— DEFINITIONS ARE SEPARATED BY ONE OR MORE EMPTY LINES. 

— THE LIST OF DEFINITIONS BEGINS AFTER THE FOLLOWING EMPTY LINE. 

— $MAX_IN_LEN 

— AN INTEGER LITERAL GIVING THE MAXIMUM LENGTH PERMITTED BY THE 

— COMPILER FOR A LINE OF ADA SOURCE CODE (NOT INCLUDING AN END-OF-LINE 

— CHARACTER). 

— USED IN: A26007A 

MAX_IN_LEN 120 

— $BIG_ID1 

— AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS $MAX_IN_LEN. 

— THE MACROSUB PROGRAM WILL SUPPLY AN IDENTIFIER IN WHICH THE 
~ LAST CHARACTER IS '1' AND ALL OTHERS ARE ’A'. 

— USED IN: C23003A C23003B C23003C B23003D B23003E C23003G 

C23003H C23003I C23003J C35502D C35502F 

BIG_ID1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

— $BIG_ID2 

— AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS $MAX_IN_LEN, 

— DIFFERING FROM $BIG_ID1 ONLY IN THE LAST CHARACTER. THE MACROSUB 

— PROGRAM WILL USE ' 2 ' AS THE LAST CHARACTER. 

— USED IN: C23003A C23003B C23003C B23003F C23003G C23003H 

' C23003I C23003J 

BIG_ID2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

— $BIG_ID3 

— AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS $MAX_IN_LEN. 

— MACROSUB WILL USE '3' AS THE "MIDDLE" CHARACTER; ALL OTHERS ARE 'A'. 

— USED IN; C23003A C23003B C23003C C23003G C23003H C23003I 

C23003J 

BIG_ID3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3AAAAAAAAAA*i. 




— $MAX_INT_PLUS 1 

— AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX_INT + 1. 

— USED IN; C45232A 
MAX_INT_PLUS_1 2147483648 

— SLESS THAN DURATION 

— A REAL LITERAL (WITH SIGN) WHOSE VALUE (NOT SUBJECT TO 

— ROUND-OFF ERROR IF POSSIBLE) LIES BETWEEN DURATION' BASE ’ FIRST AND 

— DURATION'FIRST. IF NO SUCH VALUES EXIST, USE A VALUE IN 

— DURATION'RANGE. 

— USED IN; C96005B 

LESS_THAN_DtJRATION -4194305.000 

— $GREATER_THAN_DURATION 

— A REAL LITERAL WHOSE VALUE (NOT SUBJECT TO ROUND-OFF ERROR 

— IF POSSIBLE) LIES BETWEEN DURATION'BASE'LAST AND DURATION'LAST. IF 

— NO SUCH VALUES EXIST, USE A VALUE IN DURATION'RANGE. 

— USED IN; C96005B 
GREATER_THAN_DURATION 4194303.998 

— $LESS_THAN_DURATION_BASE_FIRST 

— A REAL LITERAL (WITH SIGN) WHOSE VALUE IS LESS THAN 

— DURATION•BASE•FIRST. 

— USED IN; C96005C 

LESS_THAN_DURATION_BASE__FIRST -4194305.000 

— SGREATER THAN DURATION BASE LAST 

— A REAL LITERAL WHOSE VXLUE IS GREATER THAN DURATION'BASS'LAST. 

— USED IN; C96005C 

GREATER_THAN_DURATION_BASE__LAST 4194305.000 

— $COUNT_LAST 

— AN INTEGER LITERAL WHOSE VALUE IS TEXT 10.COUNT’LAST. 

— USED IN; CE3002B 

COUNT_LAST 2147483647 

— $FIELD LAST 

— AN INTiGER LITERAL WHOSE VALUE IS TEXT 10.FIELD'LAST. 

— USED IN; CE3002C 

FIELD_LAST 2147483647 

— $ILLEGAL_EXTERNAL_FILE NAMEl 

— AN ILLEGAL EXTERNAL FIEE NAME (E.G., TOO LONG, CONTAINING INVALID 

— CHARACTERS, CONTAINING WILD-CARD CHARACTERS, OR SPECIFYING A 

— NONEXISTENT DIRECTORY). 

— USED IN; CE2103A CE2102C CE2102H CE2103B CE3102B CE3107A 

ILLEGAL EXTERNAL FILE NAMEl BAD-CHARACTER*'' 


— $ILLEGAL EXTERNAL_FILE NAME2 

— AN ILLEGSL external FIEE NAME, DIFFERENT FROM $EXTERNAL FILE_NAME1. 

— USED IN; CE2102C CE2102H CE2103A CE2103B 

ILLEGAL EXTERNAL FILE NAME2 MUCH MUCH TOO LONG NAME FOR A FILE 


—— $ACC SIZE 

— AN INTEGER LITERAL WHOSE VALUE IS THE MINIMUM NUMBER OF BITS 

— SUFFICIENT TO HOLD ANY VALUE OF AN ACCESS TYPE. 

— USED IN; CD2A81A CD2A81B CD2A81C CD2A81D CD2A81E 

CD2A81F CD2A81G CD2A83A CD2A83B CD2A83C CD2A83E 

CD2A83F CD2A83G ED2A86A CD2A87A 

ACC SIZE 32 







— $TASK SIZE 

— AN INTEGER LITERAL WHOSE VALUE IS THE NUMBER OF BITS REQUIRED TO 

— HOLD A TASK OBJECT WHICH HAS A SINGLE ENTRY WITH ONE INOUT PARAMETER. 

— USED IN: CD2A91A CD2A91B CD2A91C CD2A91D CD2A91E 

TASK_SIZE 32 

— $MIN_TASK_SIZE 

— AN INTEGER LITERAL WHOSE VALUE IS THE NUMBER OF BITS REQUIRED TO 

— HOLD A TASK OBJECT WHICH HAS NO ENTRIES, NO DECLARATIONS, AND "NULL;" 

— AS THE ONLY STATEMENT IN ITS BODY. 

— USED IN: CD2A95A 
MIN_TASK_SIZE 32 

— $NAME_LIST 

— A LIST OF THE ENUMERA'T’ION LITERALS IN THE TYPE SYSTEM.NAME, SEPARATED 

— BY COMMAS. 

— USED IN: CD7003A 

NAME_LIST MV 

— $DEFAULT SYS_NAME 

— THE VALUE OF THE CONSTANT SYSTEM.SYSTEM NAME. 

— USED IN: CD7004A CD7004C CD7004D 

DEFAULT_SYS_NAME MV 

— $NEW_SYS NAME 

— A VALUE Of THE TYPE SYSTEM.NAME, OTHER THAN $DEFAULT SYS NAME. IF 

— THERE IS ONLY ONE VALUE OF THE TYPE, THEN USE THAT VALUE? 

— NOTE: IF THERE ARE MORE THAN TWO VALUES OF THE TYPE, THEN THE 

PERTINENT TESTS ARE TO BE RUN ONCE FOR EACH ALTERNATIVE. 

— USED IN: ED7004B1 CD7004C 

NEW_SYS_NAME MV 

— $DEFAULT_STOR_UNIT 

— AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.STORAGE UNIT. 

— USED IN: CD7005B ED7005D3M CD7005E 

DEFAULT__STOR_UNIT 16 

— SNEW_STOR_UNIT 

— AN INTEGER LITERAL WHOSE VALUE IS A PERMITTED ARGUMENT FOR 

— PRAGMA STORAGE_UNIT, OTHER TPIAN $DEFAULT STOR UNIT. IF THERE 

— IS NO OTHER PERMITTED VALUE, THEN USE THE VALUE OF 

— $SYSTEM.STORAGE_UNIT. IF THERE IS MORE THAN ONE ALTERNATIVE, 

— THEN THE PERTINENT TESTS SHOULD BE RUN ONCE FOR EACH ALTERNATIVE. 

— USED IN: ED7005C1 ED7005D1 CD7005E 

NEW_STOR_UNIT 16 

— $DEFAULT MEM_SIZE 

— AN integer LITERAL WHOSE VALUE IS SYSTEM.MEMORY SIZE. 

— USED IN: CD7006B ED7006D3M CD7006E 

DEFAULT_MEM_SIZE 536_870_912 

— $NEW MEM SIZE 

— AN integer literal WHOSE VALUE IS A PERMITTED ARGUMENT FOR 

— PRAGMA MEMORY SIZE, OTHER THAN $DEFAULT_MEM SIZE. IF THERE IS NO 

— OTHER VALUE, fHEN USE $DEFAULT_MEM_SIZE. lE THERE IS MORE THAN 

— ONE ALTERNATIVE, THEN THE PERTINENT TESTS SHOULD BE RUN ONCE FOR 

— EACH ALTERNATIVE. IF THE NUMBER OF PERMITTED VALUES IS LARGE, THEN 

— SEVERAL VALUES SHOULD BE USED, COVERING A WIDE RANGE OF 

pnCCTHTT TTTPQ 

— USED IN: ED 7606 CI ED7006D1 CD7006E 

NEW MEM SIZE 536 870 912 






B22001G B22001I B22001J B22001K B22001L B22001M 

B22001N 

< LIMITS OF SAMPLE SHOWN BY ANGLE BRACKETS > 

BLANKS < 

— $MAX_DIGITS 

— AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX DIGITS. 

— USED IN: B35701A CD7102B 

MAX_DIGITS 15 

— $NAME 

— THE NAME OF A PREDEFINED INTEGER TYPE OTHER THAN INTEGER, 

— SHORT_INTEGER, OR LONG_INTEGER. 

— (IMPLEMENTATIONS WHICH HAVE NO SUCH TYPES SHOULD USE AN UNDEFINED 

— IDENTIFIER SUCH AS NO SUCH_TYPE_AVAILABLE. ) 

— USED IN: AVAT007 C452llD B86001X C7D101G 
NAME NO_SUCH_TYPE_AVAILABLE 

— $FLOAT_NAME 

~ THE NAME OF A PREDEFINED FLOATING POINT TYPE OTHER THAN FLOAT, 

— SHORT_FLOAT, OR LONG FLOAT. (IMPLEMENTATIONS WHICH HAVE NO SUCH 

— TYPES SHOULD USE AN UNDEFINED IDENTIFIER SUCH AS NO SUCH TYPE.) 

— USED IN: AVAT013 B86001Z 

FLOAT_NAME NO_SUCH_TYPE 

— $FIXED_NAME 

— THE NAME OF A PREDEFINED FIXED POINT TYPE OTHER THAN DURATION. 

— (IMPLEMENTATIONS WHICH HAVE NO SUCH TYPES SHOULD USE AN UNDEFINED 

— IDENTIFIER SUCH AS NO SUCH TYPE.) 

~ USED IN: AVAT015 BS^OOIY" 

FIXED_NAME NO_SUCH_FIXED_TYPE 

— $INTEGER_FIRST 

— AN INTEGER LITERAL, WITH SIGN, WHOSE VALUE IS INTEGER’FIRST. 

— THE LITERAL MUST NOT INCLUDE UNDERSCORES OR LEADING OR TRAILING 

— BLANKS. 

— USED IN: C35503F B54B01B 

INTEGER_FIRST -2147483648 

— $INTEGER_LAST 

— AN INTEGER LITERAL WHOSE VALUE IS INTEGER'LAST. THE LITERAL MUST 

— NOT INCLUDE UNDERSCORES OR LEADING OR TRAILING BLANKS. 

~ USED IN: C35503F C45232A B45B01B 

INTEGIR_LAST 2147483647 

~ $ INTEGER U.ST PLUS_1 

— AN integer liberal WHOSE VALUE IS INTEGER'LAST + 1. 

— USED IN: C4S232A 
INTEGER_LAST_PLUS_1 2147483648 

— $MIN INT 

— AN ifiTEGER LITERAL, WITH SIGN, WHOSE VALUE IS SYSTEM.MIN_INT. 

— THE LITERAL MUST NOT CONTAIN UNDERSCORES OR LEADING OR TRAILING 
—— BLANKS• 

— USED IN: C35503D C35503F CD7101B 

MIN_INT -2147483648 

— $MAX INT 

— AN IHTEGER literal WHOSE VALUE IS SYSTEM.MAX INT. 

— THE LITERAL MUST NOT INCLUDE UNDERSCORES OR LEADING OR TRAILING 

— BLANKS. 

— USED IN: C35503D C35503F C4A007A CD7101B 

MAX INT 2147483647 







— $LOW PRIORITY 

— AN INTEGER LITERAL WHOSE VALUE IS THE LOWER BOUND OF THE RANGE 

— FOR THE SUBTYPE SYSTEM.PRIORITY. 

— USED IN: CD7007C 
LOW_PRIORITY 1 

— $HIGH PRIORITY 

~ AN INTEGER LITERAL WHOSE VALUE IS THE UPPER BOUND OF THE RANGE 

— FOR THE SUBTYPE SYSTEM.PRIORITY. 

~ USED IN: CD7007C 
HIGH_PRIORITY 10 

— $MANTISSA DOC 

— AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX_MANTISSA AS SPECIFIED 

— IN THE IMPLEMENTOR'S DOCUMENTATION. 

— USED IN: CD7013B 

MANTISSA__DOC 31 

— $DELTA DOC 

— A REAL”LITERAL WHOSE VALUE IS SYSTEM.FINE_DELTA AS SPECIFIED IN THE 

— IMPLEMENTOR'S DOCUMENTATION. 

— USED IN: CD7013D 

DELTA_DOC 2.0**(-31) 

— STICK 

— A REAL LITERAL WHOSE VALUE IS SYSTEM.TICK AS SPECIFIED IN THE 

— IMPLEMENTOR'S DOCUMENTATION. 

— USED IN: CD7104B 
TICK 0.1 




— $BIG_ID4 

— AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS SMAX_IN_LEN, 

— DIFFERING FROM $BIG_ID3 ONLY IN THE MIDDLE CHARACTER. MACROSUB 

— WILL USE '4* AS THE MIDDLE CHARACTER. 

~ USED IN: C23003A C23003B C23003C C23003G C23003H C23003I 

C23003J 

BIG_ID4 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAA 
~ $BIG_STRING1 

— A STRING LITERAL (WITH QUOTES) WHOSE CATENATION WITH $BIG_STRING2 

— ($BIG STRINGl & $BIG STRING2) PRODUCES THE IMAGE OF $BIG IDl. 

— USED TN: C35502D CI5502F 

BIG_STRING1 "AAJyuyyuyyuyy\AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'' 

~ $BIG_STRING2 

— A STRING LITERAL (WITH QUOTES) WHOSE CATENATION WITH $BIG STRINGl 

— ($BIG STRINGl & $BIG STRING2) PRODUCES THE IMAGE OF $BIG IDl. 

— USED IN: C35502D Cl5502F 

BIG_STRING2 "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAl" 

— $MAX_STRING_LITERAL 

— A STRING LITERAL CONSISTING OF $MAX IN LEN CHARACTERS (INCLUDING THE 

— QUOTE CHARACTERS). “ “ 

— USED IN: A26007A 

MAX_STRING_LITERAL "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

— $NEG BASED_INT 

~ A BASED INTEGER LITERAL (PREFERABLY BASE 8 OR 16) WHOSE HIGHEST ORDER 

— NON-ZERO BIT WOULD FALL IN THE SIGN BIT POSITION OF THE 

— REPRESENTATION FOR SYSTEM.MAX INT, I.E., AN ATTEMPT TO WRITE A 

— NEGATIVE VALUED LITERAL SUCH AS -2 BY TAKING ADVANTAGE OF THE 

— BIT REPRESENTATION. 

— USED IN: E24201A 
NEG_BASED_INT 8#37777777776# 

— $BIG_INT_LIT 

— AN INTEGER LITERAL WHOSE VALUE IS 298, BUT WHICH HAS 

— ($MAX IN LEN - 3) LEADING ZEROES. 

— USED TN:“ C24003A 

BIG_INT_LIT 0000000000000000000000000000000000000000000000000000000000000000 

— $BIG_REAL_LIT 

— A UNIVERSAL_REAL LITERAL WHOSE VALUE IS 690.0, BUT WHICH HAS 

— ($MAX IN LEN - 5) LEADING ZEROES. 

— USED TN:“ C24003B C24003C 

BIG_REAL_LIT 0000000000000000000000000000000000000000000000000000000000000000 

— $MAX_LEN_INT_BASED_LITERAL 

— A BASED INTEGER LITERAL (USING COLONS) WHOSE VALUE IS 2:11:, HAVING 

— ($MAX IN LEN - 5) ZEROES BETWEEN THE FIRST COLON AND THE FIRST 1. 

— USED TN: C2A009A 

MAX_LEN_INT_BASED_LITERAL 2:0000000000000000000000000000000000000000000000 

— $MAX LEN REAL BASED_LITERAL 

— A BASED Real Literal (using colons) whose value is 16:F.E:, having 

— ($MAX IN_LEN - 7) ZEROES BETWEEN THE FIRST COLON AND THE F. 

— USED IN: C2A009A 

MAX_LEN_REAL_BASED_LITERAL 16:0000000000000000000000000000000000000000000 00 

— $BLANKS 

— A SEQUENCE OF ($MAX IN LEN - 20) BLANKS. 

— USED IN: B22O01A B22(J01B B22001C B22001D B22001E B22001F 






APPENDIX D 


WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to the Ada 
Standard. The following 44 tests had been withdrawn at the time of validation 
testing for the reasons indicated, a reference of the form Al-ddddd is to an 
Ada Commentary. 

A39005G 

This test unreasonably expects a component clause to pack an array component into 
a minimum size (line 30). 

B97102E 

This test contains an unintended illegality: a select statement contains a null 
statement at the place of a selective wait alternative (line 31). 

C97116A 

This tf ;ontains race conditions, and it assumes that guards are evaluated 
indivi it . A conforming implememtation may use interleaved execution in such 
a way .t. it the evaluation of the guards at lines 50 & 54 and the execution of 
task CV4iNGING_0F THE GUARD results in a call to REPORT.FAILED at one of lines 
52 or 56. 

BC3009B 

This test wrongly expects that circular instantiations will be detected in 
several compilation units even though none of the units is illegal with respect 
to the units it depends on; by AI-00256. the illegality need not be detected 
until execution is attempted (line 95). 

CD2A62D 

This test wrongly requires that an array object's size be no greater than 10 
although its subtype's size was specified to be 40 (line 137). 

CD2A63A..D, CD2A66A..D. CD2A73A..D, CD2A76A..D [16 tests] 

These tests wrongly attempt to check the size of objects of a derived type (for 
which a 'SIZE length clause is given) by passing them to a derived subprogram 
(which implicitly converts them to the parent type (Ada standard 3.4:14)). 
Additionally, they use the 'SIZE length clause and attribute, whose 
interpretation is considered problematic by the WG9 ARG. 

CD2A81G, CD2A83G, CD2A84N & H, & CD50110 

These tests assume that dependent tasks will terminate while the main program 
executes a loop that simply tests for task termination; this is not the case, 
and the main program may loop indefinitely (lines 74, 85, 86 & 96, 86 & 96, and 
58, resp.). 


D-1 








CD2B15C & CD7205C 

These tests expect that a 'STORAGE_SIZE length clause provides precise control 
over the number of designated objects in a collection; the Ada standard 13.2:15 
allows that such control must not be expected. 

CD2Dlia 

This test gives a SMALL representation clause for a derived fixed-point type (at 
line 30) that defines a set of model numbers that are not necessarily represented 
in the parent type; by Commentary AI-00099, all model ntunbers of a derived 
fixed-point type must be representable values of the parent type. 

CD5007B 

This test wrongly expects an implicitly declared subprogram to be at the address 
that is specified for an unrelated subprogram (line 303). 

ED7004B. ED7005C & D, ED7006C & D [5 tests] 

These tests check various aspects of the use of the three SYSTEM pragmas; the 
AVO withdraws these tests as being inappropriate for validation. 

CD7105A 

This test requires that successive calls to CALENDAR.CLOCK change by at least 
SYSTEM.TICK; however, by Commentary AI-00201, it is only the expected frequency 
of change that must be at least SYSTEM.TICK -- particular instances of change 
may be less (line 29). 

CD7203B, & CD7204B 

These tests use the 'SIZE length clause and attribute, whose interpretation is 
considered problematic by the WG9 ARG. 

CD7205D 

This test checks an invalid test objective: it treats the specification of 
storage to be reserved for a task's activation as though it were like the 
specification of storage for a collection. 

CE2107I 

This test requires that objects of two similar scalar types be distinguished when 
read from a file--DATA_ERR0R is expected to be raised by an attempt to read one 
object as of the other type. However, it is not clear exactly how the Ada 
standard 14.2.4:4 is to be interpreted; thus, this test objective is not 
considered valid, (line 90) 

CE3111C 

This test requires certain behavior, when two files are associated with the same 
external file, that is not required by the Ada standard. 

CE3301A 

This test contains several calls to END_OF_LINE & END_OF_PAGE that have no 
parameter: these calls were intended to specify a file, not to refer to 
STANDARD INPUT (lines 103, 107, 118, 132, & 136). 


D-2 







CE3411B 

This test requires that a text file's column number be set to COUNT'LAST in order 
to check that LAYOUT_ERROR is raised by a subsequent PUT operation. But the 
former operation will generally raise an exception due to a lack of available 
disk space, and the test would thus encumber validation testing. 

E28005C 

This test expects that the string TOP OF PAGE. --63" of line 204 will 
appear at the top of the listing page due to a pragma PAGE in line 203; but line 
203 contains text that follows the pragma, and it is this that must appear at 
the top of the page. 


D-3 





APPENDIX E 


OQMPIIfiR OPTIONS AS SUPPLIED BY 
Data General 

Ccjtpiler: ADE Revision 3.01 

ACVC Version: 1.10 

The following conpiler switches eire available for Data General ADE 
Revision 3.01: 


/ASSEMBLY Preserves the assembly language for an Ada program 

in a .SR file. If this switch is not given, the 
assembly-language source may be deleted after the 
coirpilation; this c^ion is controlled by the ADE 
configuration. (For details on ADE configuration, 
see the ADE release notice.) When the user supplies 
this switch, the Ada source code will appear as 
comments in the .SR file. Use this switch for 
machine-level debugging only. 

/AUTO_rNLINING==n Tells the ccmpiler to inline any subroutine called 

n or fewer times. For the conpiler to perform 
automatic inlining on a subroutine, the subroutine 
must not be visible outside its corrpilation unit, and 
must cilso pass scsne inplementation restrictions which 
ensure the code will be duplicated no more than n 
times. Autonatic inlining will not occur vhen the 
/N0_INLINING switch is present. Do not use 
/ALn'0_INUNING on a source vhich contains 
MACHINEjOODE subroutines which manipulate parameters, 
because parameters are not passed on the stack to an 
inlined subroutine. When /AUT0_INLINING=0, the 
oonpiler will not generate code for unreferenced 
subroutines vhich peiss the autonatic inlining 
inplementation restrictions. 

/CONFIGURATION=configname 

Generate code for the configuration vhose source 
text statements begin; ”—/configname". You may give 
multiple confignames by separating them with 
underscores (for exanple: 
/a»JFIGURATIQN=oonfigl_config2_oonfig3). 


E-1 







/CPlrTi 

/DEBUG 

/ERRORS 

/IDIR=dimame 

/LIBRARY=libnanie 

/TPP=n 

/MAIN_PROGRAM [ ===naine ] 

/NO_SYSTEM 

/NO_INLINING 

/SUPPRESS 

/TABLE 


Controls listing columns-per-line. The value of n 
may be from 40 to 200, and includes eight columns per 
line used by the ccatpiler. Lines that are longer than 
n columns are split so that indentation is prf=»‘r“’-'ed 
vdien possible. 

Cortpiles filename for use with the Ada Soiorce Code 
Debugger. (The Ada Etebugger is sold separately with 
the ADEX prxDduct and may not be available at your 
site.) NOTE: Conpiling with the /DEBUG switch will 
increcise the volume of generated code and decrease 
runtime performance. 

Inhibits a full listing. Puts only error messages (if 
any) in the .1ST. If there are no errors, the listing 
file will be enpty. 

Specifies the directory vhere otherwise unqualified 
input filenames may be obtained. When input pathnames 
include a directory prefix, the IDIR= switch is 
ignored. 

Names the target Ada library into vhich the source 
is to be conpiled. If omitted, ADE uses the current 
directory's default library. All binaries output by 
the corpiler are placed in the same directory as the 
one in v*iich the target library reside. 

controls listing lines-per-page, v^here n is an integer 
in the range 0..66. A value of 0 disables page ejects 
and headings. Default n is 66. 

Specifies the source is a main program. If the source 
file contains more than one library unit, the 
/MAlN_FRDGRAM==Tiame keyword switch must be used. 

Prevents automatic inclusion of Ada system library in 
the library searchlist for this coitpile. 

Overrides /ALno_INLrNING and pragma INLINE. Since 
the Ada Source Code Debugger cannot debug inlined 
subprograms, use of this switch will help in using 
the Debugger. 

Sr^presses all run-time checking in the code output by 
the conpiler, including range checking and record 
varicint checking. Ihis makes your coitpiled program 
run faster, but also makes debugging more difficult. 

Generates information needed by the Ada Source Code 
Debugger to view information, but not set breakpoints 


E-2 







nor step. You need not include this switch if the 
/DEBUG switch is specified. NOTE; This switch 
increases the generated code size and decreases 
runtime performance, but not as much as the /DEBUG 
switch. 


E-3 





