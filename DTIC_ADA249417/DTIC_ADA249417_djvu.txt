AD-A249 417 ' 

RL-TR-91 -274, Vol I (of five) 
Final Technical Report 
November 1991 



PENELOPE: AN ADA VERIFICATION 
ENVIRONMENT, Developing Formally 
Verified Ada Programs 


ORA Corporation 


Sponsored by 

Strategic Defense Initiative Office 



APPROVED FOR PUBLIC RELEASE; DISTRIBUTION UNLIMITED. 


The views and conclusions contained in this document are those of the authors and 
should not be interpreted as necessarily representing the official policies, either 
expressed or implied, of the Strategic Defense initiative Office or the U.S. 

Government. 92-11269 


Rome Laboratory 
Air Force Systems Commanu 
Griffiss Air Force Base, NY 13441-5700 


92 4 27 4 IZ 









This report has been reviewed by the Rome Laboratory Public Affairs Office 
(PA) and is releasable to the National Technical Information Service (NTIS). At NTIS 
it will be releasable to the general public, including foreign nations. 

Although this report references limited documents listed below, no limited 
information has been extracted: 

RL-TR-91-274, Vol Ilia, Illb, IVa, and IVb, November 1991. Distribution 
authorized to USGO agencies and their contractors; critical technology; Nov 91. 

RL-TR-91-274, Vol I (of five) has been reviewed and is approved for 
publication. 


APPROVED: 


~\ 


jO 




• JOHN C. FAUST 


Project Engineer 


FOR THE COMMANDER: 



RAYMOND P. URTZ, fIR. 


Director 

Command, Control and Communications Directorate 


If your address has changed or if you wish to be removed from the Rome Laboratory 
mailing list, or if the addressee is no longer employed by your 01 ganization, please 
notify RL(C3AB) Griffiss AFB NY 1344 1-5790. Tins will assist us in maintaining a 
current mailing list. 


Do not return copies of this report unless contractual obligations or notices on a 
specific document require that it be returned. 







s 


DISCLAIMER NOTICE 



THIS DOCUMENT IS BEST 
QUALITY AVAILABLE. THE COPY 
FURNISHED TO DTIC CONTAINED 
A SIGNIFICANT NUMBER OF 
PAGES WHICH DO NOT 
REPRODUCE LEGIBLY. 








PENELOPE: AN ADA VERIFICATION ENVIRONMENT, 
Developing Formally Verified Ada Programs 

Norman Ramsey 


Contractor: ORA Corporation 

Contract Number: F30602-86-C-0071 

Effective Date of Contract: 19 Aug 86 

Contract Expiration Date: 30 Sep 89 

Short Title of Work: PENELOPE: AN ADA VERI¬ 

FICATION ENVIRONMENT, Developing Formally Veri¬ 
fied Ada Programs 


Period of Work Covered: 
Principal Investigator: 

Phone: 

RL Project Engineer: 

Phone: 


Aug 86 - Aug 89 
Maureen Stillman 
(607) 277-2020 
John C. Faust 
(315) 330-3241 


Approved for public release; distribution unlimited. 

This research was supported by the Strategic Defense Initia¬ 
tive Office of the Department of Defense and was monitored 
by John C. Faust, RL/C3AB, Griffiss AFB 13441-5700, under 
contract F30602-86-C-0071. 





REPORT DOCUMENTATION PAGE 


Form Approved 
OMB No. 0704-0188 


PUiksnpaRra tudanforlH>cctKXioncf HomMankMamMadtoanragi t hour p» tmxrm. ncufrgttTtnwfcr rmyng rdn ainna. a—re tire «° ^>B *° x °*f 

odlwnQand m art a ranQ dManaadad and m ' lM dr u and f* i wwngIt'deda ui onrf rtorrmian Sid uarmarta njEKfriQBK txadan^U'Ma era ry ar * **f** ** _ 

Qdhelinnd >ta ii Hm rcU>xiauHBaaBBna(BnadL«>iBMaBndar\inWaaWntfBnHaaddJawaraSan(tBad0>ada«atgHuiii*ln , >0pa> diBnaardR ^»ate.J£i5Ja»aiaon 

Da«Ht»ma», Suta 1204, Aflrgnrv VA 222SS-OCS. idaOiaOIBcarf M a nagamart and Budgd, Pafaacrtc Ratixadn PttjaB (070*47168). Wadangtry DC Z050a _ 


1. AGENCY USE ONLY (Leave Blank) Z REPORT DATE 

November 1991_ 


4. TITLE AND SUBTITLE 

PENELOPE: AN ADA VERIFICATION ENVIRONMENT, 
Developing Formally Verified Ada Program* 


& AUTHOR (S) 

Norman Ramsey 


a REPORT TYPE AND DATES COVERED 
Final Aue 86 - Aue 89 


5. FUNDING NUMBERS 

C - F30602-86-C-0071 
PE - 35167G/63223C 
PR - I070/B413 
TA - 01/03 
WU - 02 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESSES) 
ORA Corporation 
301A Dates Drive 
Ithaca NY 14850-1313 


a PERFORMING ORGANIZATION 
REPORT NUMBER 


ORA TR 17-3 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 
Strategic Defense Initiative 

Office, Office of the Rome Laboratory (C3AB) 

Secretary of Defense Griffiss AFB NY 13441-5700 

Wash DC 20301-7100 


11. SUPPLEMENTARY NOTES 

RL Project Engineer: John C. Faust/C3AB/(315) 330-3241 


10. SPONSORING/MONITORING 
AGENCY REPORT NUMBER 

RL-TR-91-274, 

Vol I (of five) 


112b. DISTRIBUTION CODE 


12a DISTRIBURON/AVAILABILfTY STATEMENT 

Approved for public release; distribution unlimited. 


13. ABSTRACT (M«rnm 200 words) 

Odyssey Research Associates has undertaken a study of the feasibility of developing 
formally verified Ada programs. We have designed a specification language for sequential Ada 
programs. It is a member of the Larch family of specification languages. We have built a 
prototype program editor that is intended to help programmers develop programs and proofs 
from specifications, as advocated by Dijkstra and Gries (2,4). It contains predicate transfor¬ 
mers, which compute wp (an approximation to the weakest precondition of a program), and it 
generates verification conditions. 

The semantics of the specification language and the definition of the predicate transfor¬ 
mers are derivable from a denotational definition of sequential Ada. The predicate transfor¬ 
mers can be proved sound with respect to these definitions by structural induction on programs. 
The denotational-style definition of the predicate transformers is well suited to an implementa¬ 
tion as an attribute grammar. 

The program editor is designed to be used on program fragments, not just complete 
programs. The next step in improving the prototype editor is to find ways to simplify the 
intermediate values of wp so they can be used to guide the development of fragments into 
programs. 


14. SUBJECT TERMS 

AdajLarch, I arch/Ada, Formal Methods, Forma! Specification, 
Program Verification, Predicate Transformers, Ada Verification 


15 NUMBER OE PAGES 

48 

16 PRICE COOE 


i /. SECURITY CLASSIFICATION 
OF REPORT 
UNCLASSIFIED 


Tvs SECURITY CLASSIFICATION |19. SECURITY CLAGSIFICA1ION 20. LIMITATION OF ABS1RAC1 
OF THIS PAGE OF ABSTRACT 

JnCLASSIFIED UNCLASSIFIED UL_ 


NSN 75*001 280-5500 


StwxiBrd F arm 298 (IRev 2-89) 
PrwCrt»eJ b* ANSI Sid Z3&-H 
298-102 










Developing Formal!}’ Verified Ada Programs* 


Norman Ramsey* 
Odyssey Research Associates 

October 10, 1988 


Abstract 

Odyssey Research Associates has undertaken a study of the feasi¬ 
bility of developing formally verified Ada programs. We have designed 
a specification language for sequential Ada programs. It is a member 
of the Larch family of specification languages. We have built a pro¬ 
totype program editor that is intended to help programmers develop 
programs and proofs from specifications, as advocated by Dijkstra and 
Gries [2,4]. It contains predicate transformers, which compute rvp (an 
approximation to the weakest precondition of a program), and it gen¬ 
erates verification conditions. 

The semantics of the specification language and the definition of 
the predicate transformers are derivable from a denotat>onal definition 
cf sequential Ada. The predicate transformers can be proved sound 
with respect to these definitions by structural induction on programs. 
The denotational-style definition of the predicate transformers is well 
suited to an implementation as an attribute grammar. 

The program editor is designed to be used on program fragments, 
not just complete programs. The next step in improving the prototype 
editor is to find ways to simplify the intermediate values of up so they 
can be used to guide the development of fragments into programs. 


Introduction 

Writing formal specifications of programs and proving that programs meet 
those specifications should help programmers develop more reliable software. 

‘This research has been sponsored by the USAF. Rome Air Development Center, under 
contract number F30602-86-C-0071. 

’Current address: Department of Computer Science, Princeton University, Princeton, 
New Jersey 08544 


1 









Edsger Dijkstra and David Gries have stressed that a program should not 
face verification as a hurdle after development, but should be developed 
in such a way as to ensure its correctness [2,4]. One should begin with 
a formal specification, and the development of the program and its proof 
should follow from that specification. Gries, in his Science of Programming , 
suggests ways to use a specification to guide the development of a program 
and its proof. 

We have undertaken to build software that will help programmers apply 
the methods of formal development advocated by Gries and Dijkstra. The 
software is designed to lead to formal verification tools with three properties: 

• The tools should not just help to verify finished programs or to check 
proofs of such programs, but should help programmers to develop ver¬ 
ified programs. 

• The tools should be based on sound, explicitly stated mathematics. 

• The tools should support programming in a subset of Ada. since there 
is a need for reliable software written in Ada. 

Overview of results 

We have designed a specification language, Larch/Ada-88, for sequential 
Ada programs. We have implemented a prototype of an editor. Penelope, 
which will help programmers develop and verify programs specified with 
Larch/Ada-88. 1 The prototype implementation supports a subset of Ada 
that is roughly “PASCAL with exceptions.” We have completed some of the 
mathematics that supports the Larch/Ada-88 definition and the Penelope 
implementation. 

Specification language The Larch/Ada-88 specification language is 
part of the Larch family of two-tierea specification languages [5.19]. 2 The 
two-tiered approach separates the specification of individual program mod¬ 
ules from the specification of underlying abstractions. The Larch Shared 

'The specification language was formerly known as PolyAnna. We have changed the 
name of the language to Larch/Ada because it is a Larch interface language. We have 
also given the name Penelope to our prototype verification system. 

J We use “specification” in the traditional sense of a statement of requirements. What 
the Ada Language Reference calls “specifications” should be thought of as like “declara¬ 
tions” in other programming languages. 


2 




Language is used to specify the underlying abstractions: for example, it 
can be used to define the notions of array, list, set, bag, and so on. A 
Larch Shared Language specification defines a set of terms (and some the¬ 
orems about the terms); this set becomes the assertion language used in 
Larch/Ada-88 specifications. 

Larch/Ada-88 (henceforth Larch/Ada) is a Larch interface language ; it 
is used to specify Ada programs by attaching assertions at certain points, 
like the entry and exit points of subprograms. The specification constructs 
of Larch/Ada are called annotations, since most of them are derived from 
similar constructs in Anna [10]. 

Implementation Most verification tools work in batch mode [7,3]. 

The user writes a program, supplies a specification and appropriate asser¬ 
tions, and then submits it all to a verification condition generator. The 
resulting verification conditions must be shown to hold. A verification con¬ 
dition for a program is an assertion whose truth guarantees that the program 
satisfies its specification. 

When a programmer using a batch system makes a refinement or dis¬ 
covers a mistake, the whole job must be resubmitted, and correct work may 
have to be redone. Moreover, most batch systems cannot verify program 
fragments. As practiced by Gries and Dijkstra, program development con¬ 
sists largely in building up correct fragments by accretion, and in refining 
existing fragments. Batch verification fits poorly with these techniques. 

We have replaced the traditional batch verification system with a pro¬ 
gram editor, which we call Penelope. Using Penelope, programmers can 
examine weakest preconditions as they are computed and can use them to 
guide program development. Program fragments can be proved correct, then 
picked up and placed in larger contexts. 

We have built the Penelope editor by using the Cornell Synthesizer Gen¬ 
erator [17,16]. Penelope can be used to create and edit abstract syntax trees 
that represent parts of an annotated Ada program. The interface is that 
of a traditional syntax-directed editor in which the user may use a mouse 
or an EMACS-like command set to manipulate trees. Penelope computes 
weakest preconditions as attributes of the nodes of the syntax tree. 3 At- — 
tribute evaluation is incremental; that is, every time the user changes the ,r 
tree, weakest preconditions are recomputed where necessary, and the new 

3 Actually, as in Gries [4], the system works with an approximation to the weakest 
precondition, called wp. 



□ □ 







preconditions axe available for display. When certain Ada constructs are 
used, Penelope generates a verification condition; typically one verification 
condition is generated for each subprogram and one for each loop. 

A user of Penelope begins by writing down a formal specification of an 
Ada subprogram using Larch/Ada. (The formal specification takes the form 
of an Ada “specification” augmented with subprogram annotations.) He or 
she then builds the subprogram body, working backwards as described by 
Gries [4]. Penelope can be instructed to display weakest preconditions at any 
point, and also to display any verification conditions that may be generated. 
The user can alter the program and immediately observe the effects on 
preconditions and verification conditions, since the recomputation of wp and 
of verification conditions is incremental and automatic. (The preconditions 
and verification conditions are simplified somewhat before being presented 
to the user.) 

The verification conditions are sentences in pure logic; their statement 
is independent of program context. If they can be shown to hold, the pro¬ 
gram containing them satisfies its specification. Penelope contains a proving 
component that can be used to prove facts about integers, Booleans, and 
Ada types like arrays and records. The proving component is primitive; the 
proof of a program like binary search takes up many pages. 

Formal foundations The formal foundation of Larch/Ada has two 
parts, one dealing with assertions and another dealine with annotations. 
The assertion part covers the semantics of the Larch/Ada assertion language 
as defined using Larch Shared Language specifications. This semantics is 
determined entirely by the semantics of the Larch Shared Language, and 
is therefore independent of Ada. The assertion part also covers the formal 
specification (using the Larch Shared Language) of Ada's data types. 

The annotation part connects the execution semantics of sequential Ada 
with the annotations of Ada programs defined by Larch/Ada. The Penelope 
editor’s weakest precondition computations are based on a formal statement 
of predicate transformers. The predicate transformers define a function from 
a Larch/Ada specification and an annotated Ada program to a set of verifi¬ 
cation conditions. The transformers are based on a continuation semantics 
for the sequential part of Ada. As part of this work, Polak [14] has shown 
how to establish a formal connection between a continuation semantics and 
predicate transformers. To define the predicate transformers, he lets the 


4 




denotation of a program be a function on terms of the Larch/Ada assertion 
language. 

Larch/Ada 

Two-tiered specifications In the two-tiered system of specification, the 
shared language component is used to define all the abstractions used in 
specification and verification. For example, in an arbitrary-precision arith¬ 
metic package, the shared language part of the specification would define 
what we mean by integer and by addition. One might implement arbitrary- 
precision arithmetic using the idea of registers of arbitrary length. The 
shared language would be used to define what we mean by a register and its 
length. 

The interface language part of a specification is used to state what a pro¬ 
gram does in terms of the abstractions defined in the shared language part. 
The interface language part of the arbitrary-precision arithmetic package 
would show which subprograms perform what operations on the data, and 
would state that overflow never occurs. 

Using the two-tiered system, a designer can keep the unpleasant details 
introduced by the programming language isolated in the interface language 
comnonent. while doing the real intellectual work of specification in the 
-ha ■ language component. It is >ossible to use • r.area language to say 
• xai v iat is meant by, for exaim ue. a stack or i ...ected graph, without 
getting bogged down in details of exceptional conditions or of representation. 

The shared language part of a specification defines the assertion lan¬ 
guage used in the interface language part of the specification. Formulas in 
this assertion language are formulas in first-order predicate logic. When we 
attempt to prove that an implementation satisfies its specification, we first 
apply the predicate transformers, which are based m the definition of Ada. 
to a program and its specification. The predicate transformers produce a 
verification condition, which is a sentence in the assertion language. The 
proof of the ’ o rification condition needs to refer only to the shared language 
part of the specification; no further reference to the definition of Ada is 
required. Since the assertion language is really a particular formulation of 
first-order logic, checking the correctness of the proofs of verification condi¬ 
tions is straightforward. 





Languages in the two-tiered system Three languages are impor¬ 
tant in the two-tiered system of specification. The Larch Shared Language 
enables users to write formal specifications of useful abstractions. It is a 
single language, used to write specifications. The Larch Shared Language 
part of a specification consists of one or more traits, each one of which may 
specify several abstractions. The shared language part of a specification 
defines an assertion language, which is the language used to refer to the ab¬ 
stractions. (A sentence stating that a stack is not empty would be a Boolean 
term in the assertion language.) In general, every shared language specifica¬ 
tion defines a different assertion language, although the different assertion 
languages have much in common, since they are just different formulations 
of first-order logic. 

Larch/Ada is the language in wh.ch we write the interface language 
part of a specification. This part uses annotations to specify the behavior 
of a program. The annotations contain assertions, which are formulas in 
the assertion language defined by the shared language part of the same 
specification. 

Description of Larch/Ada The assertion language defined bv a partic¬ 
ular shared-language specification is essentially a particular predicate calcu¬ 
lus. We will describe the features of the Larch/Ada interface language, then 
give an example. 

The simplest Larch/Ada annotation is the embedded assertion. The as¬ 
sertion is a formula in the current assertion language (defined by the shared 
language part of the current specification). Free variables in the asseidon 
refer to program variables. Embedded assertions may be inserted at certain 
control points in an implementation (i.e. between statements or between 
declarations); they constrain the implementation to satisfy the assertion 
whenever control reaches that point. In other words, the embedded asser¬ 
tion says that, whenever control reaches it. if we substitute the actual values 
of program variables into the assertion, it must denote truth. The embedded 
assertion can be used only in an implementation, as a guid° to the predicate 
transformers; it cannot be used in specifications. 

Larch/Ada’s subprogram annotations are used both to constrain subpro¬ 
gram implementations, and to specify subprograms. The entry/exit kinds 
are the in annotation , the out annotation, and the result annotation. Each 
of these contains a single assertion. They are used to constrain states on 


<i 






entry to a subprogram, to constrain states on exit from a subprogram, and 
to constrain the values a function might return. 

Also among the subprogram annotations are several exception propaga¬ 
tion annotations , which are used to say when exceptions may and may not 
be raised, when exceptions must be raised, and what conditions must hold 
when exceptions are raised. Finally there is the side effect annotation, which 
is used to document side effects on or dependence on global variables. 

Larch/Ada has two features which help make the annotation mechanism 
more powerful. The first is the “IN variable.” Within a subprogram, pa¬ 
rameter names can be modified by IN to denote the value of the parameter 
on entry to the subprogram. IN variables are essential in subprogram spec¬ 
ifications. because we almost always need to refer to the initial values of 
parameters. For example, here are specifications for some of the familiar 
stack operations: 

PROCEDURE push(s: IN OUT stack; x: element); 

— I WHERE 

— I OUT s = push(IN s ,x); 

— I END WHERE; 

PROCEDURE pop(s: IN OUT stack); 

— I WHERE 

— I IN NOT is_empty(s); 

— I OUT s ~ pop (IN s); 

— I END WHERE; 

The other enriching feature of Larch/Ada is a way to introduce “virtual 
variables.” 4 These variables are not used in writing specifications, but are 
defined within implementations to help in proofs of correctness. Their values 
don’t actually affect the results of a computation. Larch/Ada allows the 
user to declare virtual variables, to assign to them, and to use them in 
annotations. 

Finally, in support of data abstraction (packages with private types), 
Larch/Ada enables the user to define abstraction functions using the Larch 
Shared Language, and to associate these abstraction functions with Ada 
types, using the based on annotation. Thus, a user writing an arbitrary- 
precision arithmetic package might implement registers using arrays, and 

4 These are called “ghost variables' 1 by Gries and Dijkstra; the name “virtual variable" 
is from Luckham [10]. 


I 





Figure 1: Shared language specification of set operations (Wing [19]) 


SetOfE: trait 
includes Integer 
introduces 

empty: —► SI 
add: SI, E — SI 
remove: SI, E — SI 
has: SI, E —► Bool 
isEmpty: SI —► Bool 
card: SI —► Int 

constrains empty, add, remove, has, isEmpty, card so that 
SI generated by [empty, add] 
for ail [s: SI, e. el: E] 
remove(empty, e) = empty 
remove(add(s, e), el) = 

ife = el then remove(s. el) else add(remove)s. el), e) 
has(empty, e) = false 

has(add(s, e), el) = ife = el then true else has)s. el) 
isEmpty(empty) = true 
isEmpty(add(s. e)) = false 
card(empty) = 0 

card(add(s,e)) = ifhas(s, e) then rard(s) else 1 + card(s) 


would then define an abstraction function from arrays to registers. The 
proofs of correctness of implementations of abstract data types are as de¬ 
scribed by Hoare [8]; the abstraction function is used to rewrite a specifica¬ 
tion that was in terms of an abstract type to a new specificat ion in terms of 
a concrete type. 

Using Larch/Ada As an example, we will present a Larch/Ada specifi¬ 
cation for some set operations. Jeannette Wing used these operators in her 
presentation of a Larch interface language for CLU [19]. As she did. we will 
use a Larch Shared Language description of sets and set operations. The 
trait describing these operations, called SetOfE. is shown in Fieure 1. 







We begin our example with the specification of a “choose"' procedure 
that selects a member of a set, removes it from the set. and returns it. 
Since Ada functions may not have side effects on their parameters, we will 
formulate the returned member as an OUT parameter: 

— I WITH SetOfE WITH [sat FOR si, integer FOR e] ; 

PROCEDURE choose (IN OUT s: set; i: OUT integer); 

— I WHERE 

— I IN NOT IsEmpty(s); 

— I OUT has(IN s, i) AND s = remove(IN s, i); 

— I END WHERE; 

The — I WITH annotation specifies that SetOfE is the trait that defines 
the notion of set and the operations IsEmpty, has. and remove. The IN an¬ 
notation states that choose may be called only on nonempty sets. The 
OUT annotation gives the relation between the initial and final values of the 
set s and the final value of the integer i. (Notice that the final values 
are specified by giving just the variable name, while the initial values are 
specified by modifying the name by IN. In the IN annotation, all variables 
are implicitly modified by IN.) Because no side effect annotation is present, 
choose may not modify or read a. v global variables. 

Figure 2 shows a Larch/Ada specification for a set package. This package 
specifies the same operators as the similar example in Wing [19]. 

Formal foundation of Larch/Ada and Penelope 

Connecting Ada to a denotational model Formal verification of Ada 
programs must be based on a formal definition of the Ada language itself, but 
at this time there is no official formal definition of Ada. We circumvent this 
difficulty by providing a denotational model of a computing language Ada', 
and by considering Larch/Ada to be a specification language for Ada'. Ada 
and Ada' have the same syntax, and we argue informally that for a restricted 
class of programs and computations they have the same observable behavior. 

We restrict Ada most by omitting from Ada' all features involving con¬ 
currency. While there is widespread consensus on what are good methods 
to model and specify sequential imperative languages, there is no similar 
consensus on the utility of the various proposed methods of modeling and 
specifying concurrent programs. We have omjuod other features from Ada' 
because they are machine-dependent (e.g. representation clauses) or because 





Figure 2: Larch/Ada specification for a set package 


— I WITH SetOfE WITH [integer FOR e] ; 

PACKAGE sets IS 

TYPE set IS PRIVATE; — I based on si; 

FUNCTION pair(i, j : integer) RETURN set; 

— I WHERE 

— I RETURN add(add(empty, i), j); 

— I END WHERE; 

PROCEDURE union(sl ; set; s2 : IN OUT set); 

— I WHERE 

—I OUT (FORALL j::((has(s2, j)=has(IN si, j)) 

— I OR has(IN s2, j))) ; 

— I END WHERE; 

PROCEDURE intersect(sl : set; s2 : IN OUT set); 

— I WHERE 

— I OUT (FORALL j::((has(s2, j)=has(IN si, j)) 

— I AND has(IN s2, j))) ; 

— I END WHERE; 

FUNCTION member(s : set; i : integer) RETURN boolean; 

— I WHERE 

— I RETURN has(s, i); 

— I END WHERE; 

FUNCTION sized : set) RETURN integer; 

— I WHERE 

— I RETURN card(s); 

— I END WHERE; 

END sets; 


10 







it is not feasible to formalize them (e.g. the exact circumstances under which 
storage.error is raised). Here is a partial list of omitted features: 

• Concurrency 

• Real number types 

• Representation specifications and other implementation-dependent or 
machine-dependent features 

• Unchecked conversion and unchecked deallocation 

• The predefined exceptions storaga_error and numeric_error (i.e. we 
consider that no execution of an Ada' program ever raises these excep¬ 
tions), and computations that result in “undetected numeric overflow" 

• Optimizations that cause execution of Ada statements in other than 
the canonical order 

• Parameter aliasing in procedure calls 

• Any program called erroneous by the Ada reference manual 

Some of these restrictions (e.g. that forbidding aliasing) can be enforced by 
suitable static checks. 

Although Ada' is not Ada, they are intended to be equivalent within our 
area of interest, and we will not distinguish them in what follows. 

Connecting the denotational model to Larch/Ada and the predi¬ 
cate transformers The predicate transformers implemented in Penelope 
are derived from a continuation semantics for Ada. The task of defining a 
continuation semantics for Ada has been considerably simplified by two ex¬ 
pedients. First, the static semantics of Ada is not part of the definition; the 
definition assumes a suitably checked and attributed abstract syntax repre¬ 
sentation of programs. Second, the semantics of the Ada types is not part of 
the definition; instead, the semantics of Ada types is defined by Larch Shared 
Language specifications. The technique used for deriving predicate trans¬ 
formers from a denotational semantics is one developed by Polak [13,14]. 
The current definition of the predicate transformers used in Penelope does 
not provide for proofs of termination. 

Here we give an example that shows what we mean when we say that 
Larch/Ada and Penelope are formally based. The example suggests how we 


11 






define the semantics of Larch/Ada and how we show that the VC generation 
implemented in Penelope is sound. 

Generating verification conditions involves manipulating a number of 
different languages. Since a VC generator takes as input a program and 
a specification, and produces as output an assertion (the verification con¬ 
dition), the fundamental languages are the programming language P. the 
specification language S , and the assertion language A. For simplicity, we 
take the assertion language as fixed, although it is actually determined using 
the shared language part of the specification. 

The actual input to Penelope is a specification together with an an¬ 
notated implementation; we will call that conglomerate V, and w-e define 
projection functions that extract the relevant parts: 

7 T : V —* P Extract the implementation without annotations 

a : V —* 5 Extract the specification 

Then the VC generator is a function vcgen : V — A, and we wish to show 
that vcgen is sound, i.e. whenever the verification condition vcgen(v) holds, 
the program -kv satisfies its specification ov. 

We need to consider the denotations of the various syntactic objects we 
have been discussing. For simplicity, we'll let the denotation of a program 
be a mapping from states to states (this makes sense even for a continuation 
semantics if one considers whole programs). We'll call B the special Boolean 
domain consisting of the two elements truth and falsehood (which well write 
as t and f). If the set of states is X. we have 

A/p : P —* (A” — A ) A program denotes a state changer. 

Ms’S—* ((A' — A) — B) A specification denotes a predicate on state changers. 

M a '■ A — (X — B) An assertion denotes a predicate on states. 

Intuitively, a program is a function from states to states, a specification 
defines a predicate (“satisfaction”) on programs, and an assertion defines a 
predicate on states (also called “satisfaction"). A program p € P satisfies a 
specification s e S if 

(Mss)(Mpp) = t. 

The semantics of the specification language can be defined in terms of 
the semantics of the programming and assertion languages, Mp and A/ 4 . 
provided we have a fixed (not necessarily finite) set of states A'. If the spec¬ 
ification language is a simple one that gives only entry and exit assertions. 


12 






i.e. S = A x A, then we can define 


Ms{ai,a 2 )p = Vi 6 X.Al a a\x => M a a 2 (px), 

where p = Mp(p ) is a state transformer. The definition says that a program 
satisfies its specification if, whenever the entry condition a\ holds on entry 
to the program, the exit condition a 2 holds on exit from the program. (We 
are using => to denote mathematical implication.) 

The semantics of Larch/Ada is defined in two steps: first, we define 
a mapping from Larch/Ada to a simpler language in which a specification 
consists of an entry condition, an exit condition for normal termination, and 
exit conditions for termination by raising exceptions. In the second step we 
define the semantics of the simpler language; this language is essentially 
S = A x list A, and the definition of its semantics is very similar to that 
just shown. 

As the discussion above suggests, V is not really fundamental; we intro¬ 
duced V to stand for the input to vcgen. If we have an (annotated program, 
specification) pair v € V, we are really only interested in the projections irv 
and (tv. The program satisfies its specification when 

Als{(?v)(M p(ttv)) = true. 

VC generation is sound if the truth of the verification condition guarantees 
that the program satisfies its specification. The truth of a verification con¬ 
dition must be independent of state, so the function vcgen is sound if, for 
any 


Vi 6 X(MA{vcgen(v))) => M s (<yv)(Mp(nv)). 

Polak [14] goes into more detail, giving a complete definition of vcgen for 
a small programming language P. He describes a way of deriving vcgen from 
the semantics of P and sketches a proof of soundness that uses structural 
induction on programs. The techniques he describes are the same ones used 
to define the semantics of Larch/Ada and to prove the soundness of the 
predicate transformers implemented in Penelope. 


The Penelope implementation 

VVe are implementing tools that support research in formal verification us¬ 
ing Larch/Ada. Of these, the most, important is the Penelope editor, which 


13 






helps users develop verified programs. In the prototype, there is no support 
for writing traits: every specification has the same shared language part, and 
there is a fixed assertion language used for all specifications. The prototype 
can be used to specify and prove Ada subprograms, provided those subpro¬ 
grams use no global variables. We plan to extend the Penelope prototype 
to read definitions of extensions to the assertion language. We plan to sup¬ 
plement it with a tool that will help prove Penelope verification conditions. 

Status of the implementation 

Penelope is implemented using the Cornell synthesizer generator [17], The 
Cornell synthesizer generator accepts as input a description of an attribute 
grammar and compiles this description into a syntax-directed editor which 
can compute and display the values of attributes. The heart of this edi¬ 
tor is an algorithm which, when the edited tree is changed, computes and 
propagates the changes in attribute values [16). 

We think of Penelope as having three components: predicate transforma¬ 
tion. proving, and simplification. Predicate transformation is central. That 
component reads and interprets the Larch/Ada annotations, computes u'p, 
and generates verification conditions. The user controls which intermediate 
values of ivp are displayed and which verification conditions are displayed. 
The displayed values are updated every time the user changes his or her 
program or specification. 

The proving component is a sub-editor that enables the user to construct 
proofs of the verification conditions, using a sequent calculus. The editor 
presents a list of hypotheses and a goal, and the user designates an infer¬ 
ence rule to apply. The application may generate subgoals, and the process 
continues until the subgoals are reduced to axioms, which are automatically 
recognized by the editor. The editor has built in a small number of proof 
tactics; the user can designate one of these tactics instead of designating a 
rule. 

The simplification component is a set of functions that can be called 
by the other two components. These functions make the preconditions and 
verification conditions more readable. One function does this by rewriting; 
terms like PAtrue are rewritten to P, and so on. Another function attempts 
to find ways to substitute simpler terms for terms that are especially complex 
or hard to read. Another performs arithmetic operations on integer literals. 
Several functions manipulate the forms of terms in order to make other 
operations easy; depending on circumstances, one may prefer P D (Q D 


14 






( R D S )) to P A Q A R D S, or vice versa. (We are using D to represent the 
implication symbol in the assertion language.) Collectively, these functions 
reduce the size of the verification conditions Penelope generates. 

The currently supported subset of Ada We have imposed a number 
of restrictions on programs editable with Penelope, as described earlier. 
Concurrency, real number types, parameter aliasing, storage.error, and 
some other features are forbidden. Here are the highlights of what Penelope 
does with those programs it accepts: 

• Subprograms may call predefined or user-defined subprograms; recur¬ 
sion is supported. 

• Arbitrary user-defined exceptions, raise statements, and exception 
handlers are supported. 

• Integer, Boolean, enumeration, array, and record types are supported. 
The predefined Ada operators for these types are supported. (Subtyp¬ 
ing is not supported.) 

• All of the Ada control structures are supported except goto state¬ 
ments, case statements, and for loops. 

• Some static semantic checking is performed, including type checking 
and overload resolution. 

The current Penelope is limited in what it can prove. Many capabilities 
which might be considered difficult have been investigated mathematically 
but have not yet been implemented. These include: 

• Proving that neither of the predefined exceptions constraint .error 
and program .error is ever raised 

• Proving that programs terminate 

• Proving that programs are not erroneous 

• Detecting potential aliasing and illegal order dependencies by suitable 
static semantic checking 

• Proving programs that define subtypes whose bounds are set dynam¬ 
ically 

• Proving programs that may raise or handle the predefined exceptions 
constraint .error and program.error 


15 





The currently supported subset of Larch/Ada The current imple¬ 
mentation of the Penelope editor supports most of Larch/Ada. The major 
features that are missing are those associated with termination, global vari¬ 
ables and side effects, and data abstraction. As noted earlier, there is no 
support for writing traits in the Larch Shared Language. This means that 
the shared language part of every specification is the same, and that there 
is a single assertion language used for all Larch/Ada specifications. That 
assertion language is restricted to terms describing integers, Booleans, ar¬ 
rays, and records. (Enumeration literals are converted to integers during 
predicate transformation.) 

Future plans 

Simplification The greatest weakness of the current Penelope editor is 
that weakest preconditions and verification conditions are too hard to read. 
The simplification component is good at reducing the bulk and complexity of 
Boolean terms: most of the complexity in verification conditions comes from 
arithmetic terms. Simplifying such terms is iiie next step in improving our 
implementation. Rather than build an arithmetic simplifier from scratch, we 
plan to connect an existing simplifier to the Penelope editor. The simplifier 
that we plan to use is based on the Nelson-Oppen procedure for combining 
decision procedures [12.15]. 

Extending Penelope In order to support data abstraction, we intend to 
add packages and private types to Penelope's Ada subset. (Adding these 
constructs is straightforward: the major difficulties involved in supporting 
data abstraction arise in extending the assertion language, as discussed be¬ 
low.) We may also add new control structures, in particular the case state¬ 
ment and the for loop. 

In the longer term, we plan to add support for proofs of termination and 
for proofs of subprograms that have side effects on global variables. 

Data Abstraction It is not possible to write readable formal specifica¬ 
tions of large programs without taking advantage of data abstraction. Gen¬ 
erating verification conditions for programs that use abstract data types is 
not hard, but generating sound verification conditions for implementations 
of abstract data types can be tricky. This is especially true in Ada. where 
the abstraction constructs do not completely hide the representation. 


16 







It is also hard to simplify and prove verification conditions when speci¬ 
fications refer to abstract data types. The essence of the difficulty is that, 
when using data abstraction, the user must add new terms to the assertion 
language. (These terms describe the new abstractions, like stacks, buffers, 
registers, or whatever may be needed to specify a particular application. 
They are introduced and defined by traits written in the Larch Shared Lan¬ 
guage.) To be able to make effective use of the new terms, we must be able 
to show that their introduction does not lead to any logical inconsistency. 
VVe must also be able to extend the proving and simplification components 
of Penelope to be able to handle the new terms. 

We will begin studying data abstraction by making our assertion lan¬ 
guage extensible. We will use a tiny subset of the Larch Shared Language, 
a subset which will enable us to add to the assertion language new sort and 
operator symbols. In particular, it will be possible to add abstract sorts and 
abstraction functions to the assertion language. We will then allow users to 
make assertions (without proof) involving the new symbols they have intro¬ 
duced, In proofs of programs, these assertions will be treated like axioms. 
We hope that, by studying the kinds of assertions users make, we will be 
able to learn what methods of proof might help users prove programs that 
use data abstraction. 


Conclusions 

Our efforts have been concentrated on defining Larch/Ada-88 and on build¬ 
ing the Penelope prototype. Evaluation of Larch/Ada and Penelope must 
await the completion of the prototype and experience with its use, but we 
can draw some conclusions about the methods we have applied and about 
the difficulty of the problems that remain. 

We have developed a useful technique for deriving predicate transform¬ 
ers, and we have developed a method for implementing the transformers 
using an attribute grammar. We have some preliminary observations about 
the results of attempting to mechanize Gries’s and Dijkstra’s methods of 
program development. Finally, we believe we have learned what problems 
need to be solved before a useful verification system can be built. 

Implementing predicate transformers The denotational style of writ¬ 
ing predicate transformers lends itself to a natural and efficient implementa¬ 
tion of the transformers as an attribute grammar. Values in the transformer 


IT 





definition map to attributes of the grammar, and meaning functions map to 
the semantic equations that define the relationships among the attributes. 
We can avoid implementing lambda-abstraction and beta-reduction for the 
language of terms by using pairs of attributes to represent values of arrow 
types. 

Mechanizing formal development The biggest obstacle to learning 
Gries’s method of program development is the drudgery of computing wp. 
This difficulty increases as the complexity of the programming language 
increases; it would be unrealistic to expect to compute wp by hand for a 
language like Ada. Fortunately, it is easy to mechanize the computation 
of wp, provided a denotational-style definition of wp is available. 

The problem with a mechanized computation of wp is that the resulting 
preconditions quickly become too complicated to be understood bv a human 
being, at which point they can no longer be used to guide program devel¬ 
opment, which is the whole point of Gries's method. We have vet to learn 
whether mechanical simplifiers like the one described by Nelson and Oppen 
can make the preconditions understandably simple. The problem doesn't 
arise when wp is computed by hand, because in that case the programmer 
constantly applies his or her knowledge of integers, sequences. Booleans. and 
so forth, so that computation and simplification proceed simultaneously. 

Open problems The Larch/Ada specifications we can write using Pene¬ 
lope are limited by the fixed, non-extensible assertion language. (It is a 
severe limit; for example, at this time we cannot introduce the factorial 
function for use in a specification.) The programs we can prove using Pene¬ 
lope are limited by the size of the weakest preconditions Penelope computes. 
We believe that the most important problem remaining to be solved is the 
one of being able to introduce new terms into an assertion language, while 
simultaneously introducing methods of simplification and proof for those 
terms. The Larch Shared Language provides a way of writing formal defini¬ 
tions of new terms. We need to develop a formal representation of methods 
of proof and simplification. Finally, we need to develop ways of showing 
that the addition of new definitions introduces no logical inconsistency, and 
ways of showing that the proof and simplification methods are consistent 
with the definitions. 






Related work 


AFFIRM, built at USC-ISI, was the first verification system to use algebraic 
specifications and a rewrite rule prover [11]. The Gypsy system was the first 
verification system to handle a form of concurrency [7]. The Stanford Pas¬ 
cal Verifier was the first verification system to handle a real programming 
language [9]. The most important contribution of the Stanford Pascal Ver¬ 
ifier project was probably the Nelson-Oppen method of combining decision 
procedures [12]. 

The Anna project is an effort to introduce formal specification to Ada 
programmers by providing specification constructs which can be checked at 
run time [10]. The aim of AVA project is to define a verifiable subset of Ada 
and to give it a formal semantics using Boyer-Moore logic [18.1]. 


Acknowledgements 

The work described herein was done at Odyssey Research Associates with 
Wolfgang Polak. Carla Marceau, David Guaspari. C. Douglas Harper, and 
Doug Weber. Anna provided large repository of specification constructs, 
on which we drew heavily when designing Larch/Ada. The Anna group at 
Stanford was forthcoming with suggestions about how formal verification of 
Ada programs might proceed. John Guttag helped us to understand Larch 
and to explore how we might adapt Larch to Ada. In particular, he helped 
us elucidate the issues that needed to be addressed in defining the semantics 
of a Larch interface language. John Guttag and Steve Garland lent us their 
theorem prover. Ip, which we used in our study of verification conditions 
generated by Penelope. 

David Guaspari and Wolfgang Polak helped me understand the formal 
foundations of Larch/Ada and Penelope, and they corrected many errors in 
earlier drafts of this paper. 


References 

[1] R. S. Boyer and J. S. Moore. "Proving Theorems about LISP Func¬ 
tions/’ JACM 22. 1. 129 144. 

[2j Edsger W. Dijkstra. The Discipline of Programming. Prentice-Hall. 
1976. 


19 






[3] J. Crow. S. Jefferson. R. Lee. M. Melliar-Smith. J. Rushby. 
R. Schwartz. R. Shostak. and F. von Henke. Preliminary Definition of 
the revised SPECIAL specification language, SRI International. 198fi. 

[4] David Gries. The Science of Programming, Springer-Verlag. 1981. 

[5] J. V'. Guttag, J. J. Horning, and J. M. Wing. Larch in Five Easy 
Pieces, DEC/SRC TR 5. July 1985. 

[6] S. Garland. J. Guttag. and J. Staunstrup. "Verification of VLSI Cir¬ 
cuits using LP”, manuscript. 

[7] D. I. Good, R. L. Akers, and L. M. Smith. Report on Gypsy 2.05. 
Computational Logic Inc., 1986. 

[8] C. A. R. Hoare, "Proof of Correctness of Data Representations." Acta 
Information 1, pp 271-281 (1972). 

[9] D. C. Luckham et ai, Stanford Pascal Verifier User Manual. Report 
No. STAN-CS-79-731. Stanford University, March 1979. 

[10] D. C. Luckham et et., Anna: A Language for Annotating Ada Pro¬ 
grams, Reference Manual. 1986. 

[11] D.R. Musser. "Abstract Data Type Specifications in the AFFIRM Sys¬ 
tem,” in Proceedings of the Specifications of Reliable Software Con¬ 
ference. IEEE Computer Scociety (April 1979). 47-57. 

[12] G. Nelson and D. C. Oppen. "Simplification by Cooperating Decision 
Procedures”. .4C.U Trans. Program. Lang. Syst. 1. 2 (Oct. 1979). 245- 
257. 

[13] Wolfgang Polak, "Program Verification Based on Denotational Seman¬ 
tics.” POPL '81. 

[14] Wolfgang Polak. "A Technique for Writing Predicate Transformers." 
submitted to LICS '89. 

[15] T. Redmond. Simplifier Description, Aerospace Technical Report 
ATR-85 (8354)-8, Nov. 1985. 

[16] Thomas Reps, Generating Language-Based Environments. MIT Press. 
1984. 


20 







[17] Thomas Reps and Tim Teitelbaum, The Synthesizer Generator Ref¬ 
erence Manual , Department of Computer Science, Cornell University, 
1987. 

[18] Michael K. Smith, “A Verifiable Ada,” Formal Methods Committee 
Report, Ada Letters 8, 4 (July/August 1988), 136-142. 

[19] J. M. Wing, “Writing Larch Interface Language Specifications,” ACM 
Trans. Program. Lang. Syst. 9. 1 (Jan. 1987), 1-24. 


21 








CI ST 3 I OUTION LIST 


i i 1r e<? s»s number 

a f cooie s 


3 L / C 7 « ■ i 5 

ATTN: John C. Faust 
0 rif # i s s A F -l ‘i Y 174-1-57;: 


OS A Cu’POP ATI ; ,; 

5 01 A Dates ) r i v 
Ithac i NY 14- , -151 i 


3 L/i)'VL 1 

Tecnnic jl. L i r a r y 

1 r i f f i s i A ? ■* *. y ISA**! -- ' 7 '' 


A j n i n i > t r a t o r 

)e ‘-'T T e c h n i c 1 1 Inf j Center 

0 T I C - F 0 A C 

C J n.* r ) n Station ji l 1 i n , • 

a l e n i n 1 r i a V -■ ' 7 * - n 1 ’ 

Ctnte jic ) p ‘ e n • •"* 'ni t i )H v? ^ f f i c " 
office c f t h 1 )py if >f“n^ 

Wish : C ? S 7 ‘ 1 “ " 1 i 


3 L 1 l ’ 4 ■ I 

j r i t c i s s A c > . v 1 ' . - 1 ~ 7 ' ' 


M i J 0 A c / 0 : T ” 1 

Vasnin itin aC , ’ ’ v - 5 1 - , 


SAf/i :'C 1 

’“fit i jnn -’m » ■ ' 1 • 

’ , T , ’ , 


L - 1 








1 


Naval Aar fare -'ssesjuent C a n ? <» r 
r il 0 5. 3 Ooe rations C?nter/Coly 5] 
ATT 1 ,; E s i c a i r j s 
Corona CA V 1 7 .’ 


^i A*iC/*TH 1 

Anlrews 4 F A •' ■) 3j354-522^ 


H3 3AC/3C?T ? 

IFF’JTT AM V M '. 4 c 


M 3 T A C / D 3 I Y 1 

ATT‘ 4 : y a j . 0 i v i no 

L a n j l *? y 6 c J 7A L '5 $ ‘j 5- i j 7 * 


^ TAC/DOA 1 

L i n < ) l « v A F ? 7 A • Ao?5-5M4 


A3D/"7'*I3 1 

Wr 1 11 eraon AF \ r H 4 r 435-r5'5 


Si*ALC/ y ACEA 1 

4 TTfa: Danny 'cC lure 

3 H? 

*c Cl nU an JF' C A VS, 5 2 


'4 k 91 / « 4 AI “ 4 1 

Wri jHt-Aitter jin »f i vm 4'>43 t “F>4 5 


4RDC/A4A:-? 1 

4TTN: Mr Franklin Autson 

y ? A F "* n h 454 T ;-^54'' 


DL- 3 






ifIT/LDE" 

luiUinq 6 4 2* *r»a .5 

Wri^ht'Patterion AFd CH 4S43 T -t5 Q 3 


! J5 0C/MT£L 

W righf-P^tters an a F s 3 h 4 5 4 3 t 


i A v f L / H ; 

• ri^t' 0 itter J^n A F .{ '• * 4343’-*. 573 


Air Farc° in ^source'; lab 

Technical Doc J"tents Center 
4FH3L/Li3 5”T DC 

Vri^ht-ritterion A F- 3 4 454?” 


A U L / L 3 - 
U14 14.5 

w a * w ■» l l j*’ Aw ; Cl 1 1 d ” 5 ~t z- 4 


HJ A ’ : / r T ’ 

ATT;-.: L f C o l ' i l l i a n 

3 an1n(.''h «f : * ’ : 1 5 ■ 


i F L C / l <5 V 

ATT.: M aj. r n 1 1 f e r 

< ui11in; cl l 

5 u o t ° r AF3 AL ’ 1 -«*o ) • ’ 


U 3 •'« r d v 5 t r ,i t * * i c Let 
CSSJ-I — =» A 
*: o * 15'' 

, <u p t < :vi lie -L ' 


CL- 







0 f c o t the “ h i =» t ■> f iv 1 1 '^nti ^ 

- r T r.: william j.Cvjk 

'« 3 vy C Uctr jim net ic ri’ctrun •' t + 

? 3 0 m 5 - i 7 d , - >n*. i pn ( , ->- a /; -?) 

Wish S> C "> j ? i . 

Co" i "ian1ing Officer 
‘Jjval (>vi orics Center 
library 0/7o r 

Indianapolis I '■« n 


Conmniin.) Of < Kfr 
^aval A c e a n ?ystea$ C n nt a r 
Technical Linriry 
Code °v4?-i 

Can oi? 4 n C A * 1 15 ?- ' C ’ 

C m ir 

Naval J e a p o n s Center 
T ecnnical Lia rar y/C 3 4 31 
China L a < e C '* 5 i S 5 r - ^ ^ . 1 


$ u oe r i n t »nd en t 1 

Code 5 ? 4 

■4 a v a l 5 o s t o r a J u a t e school 
71 o n t e r <» y C a 3 S 3 *♦ ?- - C' C 

C o a c 3 J . Naval Airfare Systems C :>" n 1 

W a s n i n } t o n J> C ? ? o 7 “ l 1 1 


J.S. Arm/ 'issile Common i 
3 e'ls r one Scientific Info Center 
AMC/tl-OD-CW'lLL documents 
Peistone Arsenal • L 7 5 ; ' ? ~SZ41 


Advisory Croup on electron Devices 
: 1 1 Varick Street/ ’m 11 A - ' 

New York NY 1 - -14 


Los Alamos National Laboratory 
Peoort Library 

M s 5 ‘ j: 

Los Aljmos N * y 75 44 


hL-4 







AEDC Library 
Tech Fi les/IS-1 3' 
Arnold AF? TK ’73 3 7 


Coitnnnier» U c A ,; 
ASan-^CA-C»L/’ecn Lio 
Blriq 61531 

Ft ujchucd 4 l , Sol 3~o- ' 


1 5 3 v ? I 5 7 E ! T 

<?<*sler Afr y .'> > 3 5 T 4-574 a 


A F t W C / ‘ 3 => I 

San Antonio ’ < 7 p 2 4 3-3 7 ^ 7 


3 3 0 7 * S 3 

^ansco*?' a F ~i -"m .17^1*3... 


Sc! J r ‘ 

4 T T \ ; v J j 0 r : h a r l •> <j J . - y l r 

Cam? jie ' f e 11 5 n 'jniv j r>i *y 
0 ittsaurih r A 1 3 ? 1 : P' 


director N 3 A 7 v. 7 , 

T 5 1 2 7* /’ DL 

4 T T \ : D W a i r j j r ^ m 
Fort ieaie V D ’ . 7 5 3-* 


Director \3 a / ; 

4 1 S 7 

3 p 7 7 a v l j ? :> a ; 

c ort ';P3-)e y 7’ ' 1 ■ '' j 


DL- o 





NS A 

A T T \ : C'. A l l f» y 
Div <511 

> U 1 1 v * 3 e ; o ) J 
ft Mpa le M9 ? C 7 5 *S - r> o 0 j 

director 

NSA/CS3 

W11 OEfS^AC 

ATTN: <* r . M ari -I. Clesn 

fort S ? o r j e G . 'Vj^e : :2 7 55-* l 

Director 
N S A / C $ 3 M? 

ATTN: ''r. Dennis Heinoucn 

5 i G 0 S a v -» q e -? o a *1 

fort (i® or qe G. >ip o.i« 4 3 i ; 7 5 «j - * ; 

3o0 
= 31 

5 3 j 0 "i vige 0 o j :j 
Ft. * e i d “ M D ? r 7 r 5 - a 


D I p N S 4 
3 50 5 

5 i0c S-itfiqe 5 os J 
ft M .ea<1p vd 5.?’ 


0 irector 

N 3 A / C 3 5 

* 33/- •. : r LC j 

fort Georqe 5. v e*rj» '-’0 ;G75 c .-t 


5j 3 Computer Center 
C/TIC 

5 3 ? j 5» ge -oil 

fort Cnorje r -. 'pile A 'C 55-* 


~ 33/AV 

HA NS TON ifh “ A .'1731-5; 3 ' 


c SO/ IC 

HA NSC O'" A F n „1 701-5^ 3 


0L- 6 






FL LI ? 3 A 5 Y 

OL A4/SULL 

HAN3COM AF? >17 31-5 .’CO 


TECHNICAL 0 £ P C S T 3 CENT-’ 
HAIL 070° OIT' 

3U 0 LTN , 3TON PC'-AO 
=> £ 0 F O v r> ft A ^ 1 7 31 


SOI/ 5-pi -EiM 
ATTN: Cidr •<’ar a j o 

The °ent<iqon 
Wash DC 3G3H-71:: 


SO10/S-Pl- p H 
ATTN: Cipt Johnson 

Tfi? “entaion 
Wash 0 C 2 0 ? C1 - 7 T ‘ : 


SDTO/i-ot-^v 
ATTN: L r Col ‘ i n .J t 

T h ° e n t a cj o n 
wash uC ? 5 3 31 - 71 I 1 


SOI Technic jl Infor mation Center 
1753 Jefferson 3 a v i s w i < hw a y * 7 I 
Arlington V A : 1 ; 


5A ft Jj'0 

ATTN: ^ a j . < . J jne s 

Tn j _> ?"tJ5or 
Wash i>C ’ * 3 3 


A FSC /CV-0 

S TTN: Lt Col r ly n n 

Andrews A F r ' u _ 1 3 ~ ■♦ - 5 5 '*• 


H J 3 0 / V V 

A T T *>; Col H-’i : icn 
’’I 1 A 0 X V 7 A f 

W o r l 1 w a / Post tl Ce"t?r 
Los 3 n o e l » s I » v * v - - 5 


hL“ 7 





H J 339/C'JC 
ATT,\i: Co t O’ >ri en 
PO 30 x ->25^ 

Worll.oy c ostol Tenter 
Los in vies T a 

HJ S 9 / C N C I 

4TTN; Col Collins 

p o no* v? ?6■ j 

WorlHuoy Postal Center 

Los 4r>oeles r a o 1 jo•>- 2 5/ 

‘39/41 

4T T N: Col H y »n 

H a n s c o u 4 F 3 ; > 1 7 31 - 3 I * * 


; 3 C / 4 T S 

4 T T ; Lt Col 91 i •? n o e r ; 
Hons COn i F P V ; . 1 7 ; 1 - 3■ ' ' 


r 39/ UN 

ATTN: Col Leib 

Hons con 4 f n a .17 71-31" " 


4P3TC/<py (Lt Col C et oc c i ) 
< i r t l .1 n o A c 1 U -7117 


AFSPAC r CCM/XP9 

ATTN: , v s o j vr Hunter 

Peterson A c > c C J 0 51 1 * 


5 S D / C f* T 

A T T N : Lt Col Jo* c ouNe 
p. J. "ox 

Los imeles A r ~ c. A •/ 9 . ! a - 2 0 6 


ST n J P0 

ATTN: ■ v l3j bon ^ivenscroft 

Falcon A F J C 3 3 .^12 


9L- 




Naval Air Oevelooment Ctr 
ATTN: Or. *ort Hetersky 

Code 30 D 

Warminster PA 1 3 9 ? 7 4 


H3 A F OT t C/0 AH o 

ATTN: Or. Samuel Charlton 

Kirtland A F 3 \ M 87117 


z SO/XT? 

attn: Lt Col Joseph Toil? 

Hanscom A f f ' h .1731 


3 0 IC / ► N A 

ATTN: Col 3. worrell 

Pentagon 

Wash DC 207 11 


USA--: DC C 3 5 0-1-; If 
AT T N: 7r . Onyl* T ham is 

^untsvill« A L *: J 7 


H3 A F 'jo A C r C 3 v / 0^X J 
A T T N, ; C a P t *'■ .irK Terrace 
Stop 7 

Peterson 6 F 3 CO J : ^1A 


: SD/VT r 

ATTN: L t Col f j '..j l m q n i c o 

H ans com A F 3 ,r - .17 7* 


C5SD-H-S1 

ATTN: Sr. Lirry Tunas 

Commander USA TIC 
s 0 7 ox 150' 

Huntsville A»_ 7 5 7 7 

'js:. o Ac r cvvj" ; 

ATTN: Lt Col h irol 1 3 t > n l 

Paterson A r s J" 'o1 ♦ 




NT'i JM 

4 T T \ : *r . jit jO jojn .'r 

falcon A F 3 CO _ ? 1 2 


a A D C / C ! A 

ATTN’: >1r. Antnoiy f. Snyler 

Sriffiss af.3 NY 134h1 


AF Soice Co mo an i/<f*XlS 
s “terson A F j CO 3. v 1 4- 3 r ' 1 


AF0T-C/X-» 

A T T N : Coot n'nj(*l 

<1rt l and A F i M 37117 


Director N S A (VII) 

ATTN: ijeorqe Hoover 

5 8 ' ; j 5 o v i } e ’jj! 

F t o"or^’ G • .•• «-i j t» . 


- '??£-*• 


OSD/CM A 

ATTN: Coot 'r 3i'l?nour ; 

° 0 MX 1 7 1 6 > 7 V o 

LOS A MIL 0 3 c A M MV- 2 Vo • 


Natioml C omoot or 'ecuri*y Center 
4 T T n : CA/TIC 

g 3 0 0 Savage 3 o 3 ! 

r o r t o 9 o r q e j eile 0 D 2 j 7 3 3 - o ~ " 


Unisys Corn/'!eN3r« Info Sys Div 
ATTN: Lorraine Martin 

5151 C amino 
Camarillo CA y T . 1'. 


h i t r ? C or o 

ATTN: )ale *. Jo on son («C a 047) 

Aurlinaton ah 
3«dfor i ha 01 7 7 j- 320.3 




Secure Co.floating Technol ooy Coro 1 

ATTN: J. Thomas Haiqh 

1210 west County 5 oavi ... CSte I] 1 ') 

Arden Hilts H N *> 511-2 


litre Corp 

ATTN: Joshua Guttman (“3 4 G 4 G) 

Purlinjton p1 

led for-1 "* A C173>j2„o 


Hi tro Corp 1 

ATTN: John Jan*ri a 4 ?) 

Rurlimton Ri 
ledfor^ ha j 1 7 5 „ - : G . - 


OR 6 Cor po r a tion 1 

ATTN: Or. -icnard Pldtek 

? j 1 A Harris '■ . Oates Or. 

Ithaca NY 14SS7-1 31 T> 


National Security ** l“ncy 
ATTN: Larry natch/R3 

? 3 J J j a v 1 4 * 7 j 
ft lie ro ?■ 73 5 


National Security Agency 1 

ATTN: i >1 a r V waojcock/^ris 

0 3 j 0 $ a v a 9 e < 1 
Ft h o : 7 ;s. 


Naval p eseorcn Laooratorv 1 

AT T N: Carl F . L.anlwehr C r ooe r 5 4 ^ ) 

Wash 0 C 1 7 7' - 3 3 0 j 


'J3 Army Com manic it ion --l«ct ionics 1 

Command 

ATTN: AfSSL-^-CWS-P 

ATTN; John w. 3 r ? u s s -? 

Ft Honmouth Nj '77'3 

NASA Lanqley-eiearcn Center 1 

ATTN: Nicky . u 11 e r < If. 1 * ' ) 

H a m 0 1 0 n V a ? " 6 f - j 2 G 5 


"'1-11 





National Security -’;cncy 
flTTN: Michele ?ittelli/'353 

P 3 C 0 Savage 3 J 
Ft Meade *1D ? 7S 5 - 6 w ..o.„ 


National Security Ajency 
ATTN: Howard 5tainer/~; T 

P S 3 C Savage -3 o 
c T Meade MD ? j 7 > 5 - 5 r 


SPAW*P/Code 7 3 4 3. 
ATTN: 2 OD < n l 1C A i 

Wash S' C ? 3 T 6: - “ 1 C _ 


Naval 3 esearcn caooratory 
A T T \ : John McLean (CoJe S S 4 ^ ) 
Wash DC ?0’7S- c . o r. J 


ASD/YFAF (ms Swengim) 

Wr i qht~ P a t c er s on a F ^ ON 4 3 4 3 ? -h o'.’ 3 


Naval 3 esearcn moratory 
Code 5 543d 
a T T N : H . n . l u o h e s 
Wash DC 7 u 3 7 5 - j u 0 


DA 5P A/ISTj 

ATTN: Dr. Willian Scherlis 

1 4 j 0 mi Ison ' l v d 
Arlington V A clll'i-ZZ') 3 


DA^pa/ISTO 

ATTN: Dr. Jack Kraser 

14^3 Wilson -Iva 
Arlington VA Z2 2C 9-3 5.3 S 


sli j po 

ATTN: Maj Charles J. c yan 
Carnegie Mellon university 
°ittsour' 5 jh pa 15213-33P3 


DL-1 Z 







1 


Defense C onmunications Agency 
ATTN: Dr. Cass Defiore (Code ACA) 

Advanced Technology Office 
Wash DC 


3DI3/SDA 

ATTN: Lt Col Jim S v e e d e r 

Pentagon# &oo.n 1 c143 
Wash DC 20310 


ESD/AVSE 

ATTN: C a p t R ola a d LeJieur 

danse jn AF-* At. .1 7 21-5?" '• 


1 


Trusted Information Systems* Inc. 1 

ATTN: Richard :. Jchainjer 

0. : n* 45 

3C'6J Washington Pd 
Glenwood ID ? 1 7 

3 ■< I Int er n a t i on il i 

ATTN: Darien.-* Iheruood 

For: Comp 3 c i L u/Jcin s u s h 0 y 

333 ^dvenswon I ^ve 

M e n l o ° a r k Z A R 4 T 1 * 

Institute for Defense Analysis 1 

1 T T N : Dr. Russell ^ r i c -» 

Comj •: Soft c o^ ) i v / J. v ayfi«l' J 
1 i 3 1 1 e j jr e ■ jr i “,tri'«* 

Aleumdria V * 1 ■: 3 1 1 -1 7 ’ ' 

Secure Cpmoutin^ Inconel• j y Coro 1 

A T T N : Jerry . e .* r t> v 

12 1 3 w. County - d r , ; U i J 1'' 

Arden u i l l s w . • r . 1 1 


Sdlln^ernationil i 

4 T T'j: Darlene > h e r * o o 1 
c or: Co-no 3ci Lm/ T »r j sa Loot 
3 3 3 jvonswoo 1 A ve 
^enlo 3 srk CA >v. 2 5 

T h •» -. i r o s n a c <» ' or,; /j"f d »v ? I o o Div 1 

A T T d : J IJIOJ . '..^n 

c or: Sen roe >iltey, v l- as 

F . :• . . O K 3 ? ) ' ? 

Los 4 m e l e s C - : . >- 1 ' a 7 





3 i C i / " t r j t ? t i c 5 v s t •» n s '■•’.it 
A T T ,w : Tim Pavlik 
c or: 'ill :: 1 nsch 

17:7 3°ntry •>. * ''ok 1 

>) l Jeel l P* 1 

r, £ Co/Gtrateoie S /sterna ">»•> t 

ATTN: Tim ^ a - l i k 

For: ■'r. “on '1 irk inn 

17®7 3°nt ry p jrk «i. r P 0 ’’ox 1 ■>• 
5lueo?ll p A 

Advisory 3 -duo on £ l*?ctron 0°vi 
2 j 1 V a r i c k Street* .< m 1 1 ♦ -* 

New York NY 1"14 


KIT,: Toro 

A T T N : Or. Domi Cuomo 

o a 1 f o r 1 ''A ,17’,. 


Tori A 3 r o s n a c e Coro 

c/o Rockwell Internet i mil 

a T T N : Dr. Jin 3 c h u l : 

12 5 3 m c a 1e m y -'irk Looo 
C 0 l 0 r J 1 0 3 o r i n o s CD - * 1 

Essen Coro 

at~n: jr. '• o j * a c k i •» 

Human Tjctor; •' j seercn 0 »v 
c 7 7 5 iO»son ^we 
G o l ? t a CA 03 ) 1 " 

3J 0 Enterorises 
ATTN: v r . Jav> ! ; n e L 

1225 Jefferson nvis my 
5 u i t a '01 
ArlinjT on V A 

A 3 N Systems Technology 
ATT',: Dr. D i c x Pew 

7 3 F swcett :T 
C a m 0 r i a o *■e v A 21:' 


? o n n i e ic5ini elw V| 0 C 
TIT c ronklin > t 
Huntsville A L 5 7 j 1 


U' 1 




Harris Carp 

Government Info Gys Division 
«T T ‘i: °onda Henning 

D 0 j ok ■? p 00Q 
v ‘*etoourne F L ' ? H ' o 

Ford Aerosoico •’ Comm Coro 
ATT.G: P e t <? r a k e (!' a i l Stop L - 3 > 

1 u <* 4 ^ 't3t<> w j ihwiy i 5 

Colon a 1 o Springs C 0 C 7 C : 


Computational L o p i c * Inc. 
JTT'c Dr. Do not-; I. Good 
1717 • . 5th It ( C j i t ? ~f j > 
4 u S t on TX 7 -f 7 „ 7 


Gemini Computer 1 . Inc. 

ATT f«:; r-o.ier Lentil 
7 5 11 Ciripn p c (••Ido C «■ 51 e 1 C' .) 
v o r\ t o r a y C a ~ 7 * a 


<o° i n ] :=>rusn Ke Co 

ATT ,a: Dsn 5 c h n a c k no -»r : ( 1 $ ’ : *1 .') 
°.D. : ok 3 7 7 5 
Seattle w ft . J ,1 


o'j\ L < k pr stories* Tnc. 

ATTN: Steve Vinter 

Id , v ioulton 51 r » -> t 
C I mb r i 1 'A 

’Jniv of Calif it Ganti mir i 
Computer Sci-' , ' i c*- . “.e 
ATT?.: 3 ro ( - it.nr i - . '^mpr-'r 

Santa 1 a r o o r t ‘ • -* 71 ~ o 


!!n i sy. Coro 
ATTN: D* n o rir C c a :• er 

? 7 T 1 3 l su son / v “ 

Culv°r City C - * ' : ’ 


DL-1 5 







MISSION 

OF 

ROME LABORATORY 

Rome Laboratory plans and executes an interdisciplinary program in re¬ 
search, development, test, and technology transition in support of Air 

3 • ■ 

Force Command, Control, Communications and Intelligence (C I) activities 
for all Air Force platforms. It also executes selected acquisition programs 
in several areas of expertise. Technical and engineering support within 
areas of competence is provided to ESD Program Offices (POs) and other 

9 . . 

ESD elements to perform effective acquisition of C I systems. In addition, 
Rome Laboratory's technology supports other AFSC Product Divisions, the 
Air Force user community, and other DOD and non-DOD agencies. Rome 
Laboratory maintains technical competence and research programs in areas 
including, but not limited to, communications, command and control, battle 
management, intelligence information processing, computational sciences 
and software producibility, wide area surveillance/sensors, signal proces¬ 
sing, solid state sciences, photonics, electromagnetic technology, super¬ 
conductivity, and electronic reliability/maintainability and testability. 








