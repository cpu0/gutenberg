NASA-CR-197197 




ANNULAR SUSPENSION AND POINTING SYSTEM 

( A b P !o ' 

MAGNETIC E‘ 0 T A K V j J s * i 


NASw-4435 


OHIQINAt PAGE m 
OF POOR QUALITY 



co 

r» 

■J- 

o 

ro 

O 

O 


m 

o 


INSTRUCTOR: 

DR. S. BAWAB 

TECHNICAL ADVISOR 
DR. C. BRITCHER 


DESIGN TEAM MEMBERS 
W. E. SMITH 
T. QUACH 
THOMAS 




SENIOR DESIGN PROJECT 
OLD DOMINION UNIVERSITY 
FALL 1993 





OVERVIEW OP TEAM PARTICIPATION: 


The magnetic rotary joint was initially divided into three 
lead functions. W.E. Smith served as manager, W. Thomas as 
lead hardware engineer and T. Quach as lead software engineer. This 
proved to be an effective and evenly distributed breakdown. The 

o 

functions and involvement of each team member is as follows; 

T. Quach - Software Engineer 

* Developed C programs by learning the C language, installing 
required software, and writing appropriate code. 

* Assisted in development of hardware configuration to ensure 
proper integration with software. 

* Wrote and presented one status report. 

* Developed mathematical model using MATLAB. 

W. Thomas - Hardware Engineer 

* Developed hardware configuration by reviewing system 

o 

schematics, tracing signal data points, and wiring the 
control panel for digital control. 

* Assisted in development of software configuration to ensure 
proper integration with hardware. 

* Wrote and presented one status report. 

* Developed mathematical model. 

W.E. Smith - Manager 

* Assisted and directed development of hardware and software 
elements. 



* Met with technical advisor weekly. 


* 

* 

* 

* 

* 


Met with managersQji- monthly ^ 

Held weekly meetings with team members. 
Wrote meeting minutes. 

Wrote and presented two status reports. 
Developed mathematical model. 


o 








(a) 




o 



TABLE 07 CONTENTS 


I. ABSTRACT 

II . BACKGROUND 

1. BEARING OPERATION 

2. NASA PROJECT OBJECTIVE 

3. PREVIOUS ANALYSIS 

III. SENIOR PROJECT OBJECTIVES AND APPROACH 

IV. HARDWARE DEVELOPMENT 

1. MBA HARDWARE CONFIGURATION 

2. GOALS 

3. DESIGN APPROACH 

4. RESULTS 

5. FUTURE DEVELOPMENT 

V. SOFTWARE DEVELOPMENT 

1. BACKGROUND 

2. GOALS 

3. DESIGN APPROACH 

4. COMPUTER CONFIGURATION 

• 5. MODIFICATIONS 

6. ANALYSIS 

VI. FEEDBACK CONTROL DESIGN AND ANALYSIS 

VII. CONCLUSIONS 

VIII. REFERENCES 


IX 


APPENDIX 



List Of Figures And Tables 


page 

FI. ASPS magnetic rotary joint 5 

F2. Axial MBA 7 

F3 . Vernier layout 8 

F4. ASPS work control network 11 

F4a. Component Integration n a 

F5. ASPS breadboard electronics tree 13 

F 6 . Power distribution l 6 

° F7 . Control electronics 17 

Tl. Position sensor output 19 

F 8 . Power rack assembly 20 

F9. Detail of position sensor amplifiers 23 

Flo. MBA driver 24 

Fll. Axial MBA compensation 25 

F12 . Driver module block diagram 26 

DWG 07237 34 

F13 . DT 2811 Highlights 36 

DGW 00817 37 

F14. Sample test program 42 

F15. Data flow algorithm 43 

F16. Original control logic 45 

F17 . General PD control 4 ^, 

Proposed PD control Aq 


F18. 


o 


I. ABSTRACT 

The Annular Suspension and Pointing System (ASPS) is a 
prototype of flight hardware for a high— accuracy space payload 
pointing mount. The long term project objective is to perform 
modifications and implement improvements to the existing ASPS 
in hopes of recommission. Also, new applications will 
be investigated for this technology. This report will focus on the 
first aspect of this overall goal, to establish operation of a 
single bearing station. Presented is an overview of the system 
history and bearing operatioiy'followed by the processes, results, 
and status of the single bearing study. 



3 



II. BACKGROUND 


o 


In mid 1976, the NASA Langley Research Center awarded the 
Corporation's Flight Systems Division a contract to develop 
an auxiliary pointing system. This system was to be capable of 
subarcsecond performance maintained in the carrier vehicle 
disturbance environment which consists of both vibrational and 
transient disturbances. The result of this contract is the annular 
suspension and pointing system. This system (figure 1) includes a 

magnetically levitated isolation and vernier pointing system 

/ 

attached to a modular gimbal. j 

The ASPS was delivered to NASA An 1983; however, it has never 
been operated by NASA. Due to /shifting NASA priorities and 
difficulties in the space shuttle program, the ASPS program was 
terminated shortly after delivery. The system had been stored at 
NASA until it was loaned to ODU in the fall of 1992. The hardware 
is now situated in the digital/controls laboratory. 




p AGE ft 

0F r°°* Quality 




5 








1. DESCRIPTION AND OPERATION OP THE MAGNETIC BEARINGS 

The magnetic bearing portion of the ASPS consists of a 
set of stationary electromagnets (stator) and a 50% nickel 50% 
steel annular ring (rotor) . This configuration allows the 
ring and thus the payload, to be suspended in a magnetic field 
and to provide precise positioning (figure 2). The ring 
position is maintained dynamically using sensors to provide a 
continuous feedback loop to the electromagnetic poles. Three 
individual systems are integrated in this application to 
provide a six degree of freedom pointing mechanism. Three 
axial bearings are employed to control vertical positioning, 
two radial bearings control motion in the ring plane, and a 
roll motor provides tangential motion (figure 3) . The 
advantages of such a systemr are numerous. The most evident 
being the lack of contact /between bearing components and thus 
the elimination of wear. This results in extended life for the 
bearing components and less maintenance on the system. 
Additionally, this technology allows disturbances to the 
system to be isolated. These attributes make magnetic bearings 
ideal for space applications. 


OAKHNAL PAGE « 
OF POOH QUALITY 


6 



AXIAL MBA WITH SENSO 
(HALF STATION) 



STATOR IRON: 50% Ni-STEEL 

ROTOR IRON: LOW CARBON STEEL Go= 0.300 

G=Go±0.220 







VERNIER LAYOUT 






8 


2. MAIM PROJECT OBJECTIVE 


Old Dominion University, through this project, desires to 
update the ASPS technology and bring the system back to full 
operating condition. In addition, the hardware will be used 
investigate new applications for this type of ma 
suspension system. 

3. PREVIOUS DESIGN MODIFICATIONS/ANALYSIS BY ODU RESEARCHERS 

Some analysis of the existing ASPS circuitry was 
performed during the spring semester. As a result, the 
function of certain elements were identified. In addition, it 
was determined, that a relatively simplp modification to the 
gap distance would raise the vertical/ force capability to a 
satisfactory level for the lg environment. Consequently, the 
parts for this modification have been fabricated. 



OfWQiNAL PAGE IS 
OF POOH QUAUTY 


9 



III. SENIOR PROJECT OBJECTIVE AND APPROACH - FALL 1993 

The goal of this design team is to make a single ASPS bearing 
station operational using digital indication and control . 

To meet this objective, the project was initially divided into 
two areas of development (figure 4) . The software area focuses on 
learning the C programming language, identifying the required 
program modifications, and writing new code. In parallel to this, 
the hardware aspect focuses on learning the existing system 
circuitry, testing elements for proper operation, and identifying 
the items required to operate a single station. In addition to 
these areas, development of the feedback control logic focuses on 
Proportional-Derivative (PD)/ type control and identifying the 
elements required to implement such logic. 

These elements will be integrated (figure 4a) such that the c 
programming, containing the proper control logic, commands the 
electromagnet output through the electrical hardware. The computer 
then receives a feedback signal from the sensor which is fed back 
into the programming to readjust the electromagnet output and thus 
the annular ring position. 


o 


WW 


10 



Figure 4. ASPS Work Control Network 



MILESTONES 


OF POOS QUALITY 


Midterm 

Presentation 


Operate Single 
Bearing Station 


Final 

Presentation 


11 




















IV. HARDWARE DEVELOPMENT 

1. Existing MBA Hardware Configuration. 

The Magnetic Bearing Assembly (MBA) was initially developed 
to operate in a zero gravity environment. Sperry corporation 
performed the design and construction of the prototype assembly 
that we are currently modifying for operation in normal gravity. 


Sperry's approach was to use an analog feedback and control system 
in which most of the stabilization of the MBA was accomplished by 
electronic means, while an analog computer applied force commands 
and monitored operating parameters. According to Brian Hamilton of 
Sperry Corporation, considerable stability was achieved with this 
scheme in six degrees of freedom operation, but computer 
simulations indicated that instability wojald occur in actual 
operation due to vibrational and inertia}: effects posed by the 
carrier (19) . Our concentration has been to incorporate a modern 
feedback control system to replace the existing hardware which was 
developed during the mid-seventies. 

o 

Before designing a feedback controller for the MBA an 
in-depth understanding of the existing hardware was needed. 
Technical documentation for the system is good as far as 
schematic diagrams are concerned, but it lacks the theory of 
operation for specific circuits. Essentially, while each 
circuit card has a designation (i.e/ MBA Driver) which hints at its 
purpose, there is no detailed description as to how the circuit 
card actually works. 


12 


ORIGINAL PAGC « 
OF POOR QUALITY 



Figure 5. ASPS BreadBoard Electronics Family Tree 
from Sperry Systems original design drawings, 1976. 



ONatNAL PAGE !$ 
OF POOS QUALITY 


L3 











The above situation was remedied by an in-depth study of the 
schematic diagrams coupled with a signal flow analysis. However, 
before the signal analysis could be performed the MBA had to be 
rendered operational. 

Figure (5), on the previous page is an overall block diagram 
of the MBA electronic hardware. An initial assessment showed that 
+28vdc applied to the ASPS power distribution assembly was needed 
to energize the MBA assembly. Specifically, +28vdc was applied to 
terminal l and ground to terminal 12 of terminal block T107 (see 
6, page 16) . Initially this effort failed because a previous 
team had altered the ASPS-0012 CEA Control Panel (see figure 5, 
page 13) in an attempt to energize the MBA. Diodes D4, D36, and 
D45 had been desoldered and jumpered to other points within the 
Control Panel (see figure 7, page 17). Apparently, this was done 
to alter the application of operating voltages to circuit cards 
so that elements of the MBA could be operated individually. After 
removing the jumpers and reconnecting the diodes the MBA was 
successfully turned on. 

It is interesting to note that existing hardware is designed 
to accept an input of +28vdc. This was done because +28vdc is a 
common output from power supplies used in aerospace applications. 
The power supply delivered with the MBA was inoperative and no 
schematics of it were included in the documentation provided by 
NASA. This power supply is currently under repair by Old 
Dominions Universities electronics shop. In its' place we are 


14 


using a KEPCO DRC-40 power supply in place of the original. This 
power supply is capable of providing 40 amps of current and must be 
used with caution because the MBA only requires a fraction of this 


power. 





Figure 7. Control Electronics Assembly, ASPS-0012 
from Sperry Systems final design drawings, 1977. 



NOTE. : vALuca on secTiotsi ** 

ron a-«T 


OefcOiNAL PAGE fS 
OF POOR QUALITY 





During normal operation, in which the rotor disc was attached to 
the top magnetic bearings we observed a current drain of only 4 
amps on the front panel meter of the DRC-40 power supply. 

Once power was applied to the MBA it was possible to perform 
a signal analysis of the circuitry to determine the exact function 
of the cards relative to the feedback control system detailed in 
the final design review (ASPS final design review. May, 1977). By 
comparing this document with the schematic diagrams, the following 
subsystems were initially determined necessary for operation with 
a digital feedback control design: 

1. Power supplies (+28vdc, +,-15vdc, +,-5vdc) 

2. Position Sensor Amplifiers (ASPS-0036) 

3. MBA Driver (ASPS-0039) 

4. Axial MBA Compensation (ASPS-0038-1) 

With the above circuit cards identified for operation of the MBA a 
detailed analysis was conducted. This analysis allowed us to learn 
just how the MBA operated in its current configuration, while at 
the same time determining if any components were faulty. 

One of the first components tested for proper operation was 
the CEA Secondary Supply, dwg.ASPS-0032 (see figure 5, page 13). 
This is the power supply which converts the +28vdc input from the 
KEPCO DCR-40 power supply into the positive and negative 5 and 15 
volts needed by the .transistors and integrated circuit chips . The 
outputs are applied to bus-bars on the back of the Power Rack 
Assembly, dwg. ASPS-0031 (Figure 8, page 20). These bus-bars (T103 
on figure 8) also distribute the +28vdc that is used to apply 

18 

r’ASE I* 

Of POOR QUALITY 



voltage to the DC magnets. The actual test involved simple voltage 
measurements along the bus-bar and reading the test points. 

The next elements that were tested were the position sensors. 
The outputs from all five bearing stations can be read off of the 
front panel of the CEA control panel (figure 10, page 24) . 
Readings were taken from gaps A, B, and C which are the outputs 
from the radial gap sensors. The following results were obtained 
for the upper (rotor assembly stuck to the top magrfets) and lower 
(rotor assembly stuck to the bottom magnets) limits of rotor 

o 

travel: 


Position 

Gap A 

Gap B 

Gap C 

Gap Width 

Top 

1.47vdc 

1.45vdc 

1.44vdc 

+7.315E-3m 

Bottom 

-1. 48vdc 

-1.42vdc 

-1.46vdc 

-7 . 315E-3m 

Range 

QisKI a 1 

403 . 27V/m 


392 . 33V/m 

396.44V/m 

********** 


Table l. PositionSensorOutpuF 


o 



ORIGINAL PAGE IS 
OF POOR QUALITY 


19 


Figure 8. Power Rack Assembly, ASPS-0031 
from Sperry Systems final design drawings, 1 







Further analysis of the position sensor circuitry was made to 
gain a better understanding of how the feedback control system 
operates. Figure 9, page 23, is a simplified schematic of one of 
the six position amplifiers. The position sensors are used to 


convert the mechanical position of the MBA rotor into a varying DC 
signal. The current gap width is 0.288 inches for all axial 

bearing stations. The input from the position sensors to the 

. . / — ^ ? 

position sensor amplifiers is a 25^Mhz) sine wave that varies from 

7 —10 vpp. This variation is dependent on the relative position of 
the MBA rotor . As the MBA nears the top sensor, the signal at AA 
on figure 9 approaches l^vpp) wKle the signa^at BB (from the 
bottom position sensor) approaches 7vpp. Thi^circuit functions as 
a differential amplifier with a gain less than unity. For 
^■**®b3nce, with the AC voltage inputs described above, the output at 
CC is approximately +1.5vdc( this circuit not only functions as a 


comparator but also converts the AC input into a DC output) . 

o 

Finally, the MBA Driver cards, drawing ASPS-0039 (Figure 10, 
page 24) and the Axial MBA Compensation cards, drawing ASPS-0038-1 
(Figure 11, page 25) were investigated/ Through extensive signal 
analysis it was determined that the^e cards function as the heart 
of the analog feedback control system. Correlation with the final 


design review depiction of the MBA Driver Module block diagram 
(Figure 12, page 26) substantiated our suspicions. Specifically, 
the Axial MBA Compensation circuit cards are represented by the 
elements to the left of the dashed line on figure 12, while the MBA 
Driver cards are represented by the remaining portion to the right 


o 


OWGINAL PAGE fS 
OF POOR QUALITY 


21 


of the dashed line. The lower portion titled "Part of VEA" on 
figure 12, on the previous page represents the position sensor 
circuitry whose final output (CC on figure 9, page is 
designated as Ag. 



QW05NAI. PAGE *S 
OF POOR QUAUT/ 


22 



Figure 9. Detail of Position Sensor Amplifiers, 

by Uitr au lliui . 


+V 499k 10.0k 



OWQINAL PAGE (% 
OF POOR QUALITY 
















Figure 11. Axial MBA Compensation, ASPS-0038-1, Sperry Systems 
Final design drawings, 1977. 



25 






Figure 12. MBA Driver Module Block Diagram, ASPS Final 
Design review, page 5-21. 



26 






2. Goals of Hardware Development 

The initial goal of the hardware development, which was to 
learn how the existing system operates, has been met. After 
initial repairs and the powering up of the entire system a full 
understanding of its operation has been gained. Much of the 
circuitry has not been discussed because most of it was designed to 
handle roll, yaw and pitch of the rotor assemble under actual 
operating conditions. Again, this is an extensive analog feedback 
and control system designed to operate with a 1970 's vintage analog 
computer. In light of this design teams approach to minimize 
hardware and incorporate a digital computer into the control scheme 
as a more modern approach, this hardware will not be needed. 
Testing has shown that the MBA Driver circuit cards can be removed 
from the MBA and yet the position sensors still operate properly. 
This will allow the use of off the shelf hardware to apply drive 
currents to the DC magnets while using the position sensor outputs 
from the front panel of the CEA control panel. 

3 • Hardware Design Approach 

The hardware analysis has shown that it is impractical to tie 
a digital computer into the existing feedback control system. 
Several attempts were made to apply force commands that would vary 
the current to the DC magnets. This attempt failed because of the 
absence of the original analog computer that would have closed many 
loops in the feedback control circuitry. Moreover, our current goal 
is to achieve stable magnetic leyitation with one bearing station 
An one degree of freedom. TJlie existing system was designed to 

27 


ORIGINAL PAGE fS 
OF POOR QUALITY 


operate in zero gravity with both the upper and lower banks of DC 


magnets in operation. jj^j U*/ 

Our approach will only require the use of the upper banks of 
magnets to compensate against the force of gravity, with this in 


mind 


Q 


have experimented with the use of a KEPCO BOP 20-20M 
programmable power supply. This unit accepts inputs from a digital 
computer to adjust its current output and also provides a current 
feedback signal 


. <^\ 


have already reconfigured the MBA circuity so 
that the programmable power supply will replace the MBA Driver 
module for bearing station A. This was done by manufacturing a 
connector which applies current at pins 10 and 23 and accepts a 

return at pins 11 and 24 of MBA Driver ASPS 0039 (Figure 10, page 

j 

24) Experimentation has shown that by increasing the current input 
towards the limit of 1.4 amps, the bearing rotor can be drawn from 
the center position to stick to the top magnet. 

4 . HARDWARE DEVELOPMENT RESUM^. 

The KEPCO BOP 20-20M programmable power supply proved more 
than adequate as a current source to drive the electro-magnets in 
the Magnetic Bearing Assembly. The fast transient response 
(83/xsec) was more than adequate for stable operation of the 
magnetic field. One improvement made over the initial design is 
the installation of a one ohm, 25 watt resistor on the return line 
from the MBA coil. This resistor serves to dissipate energy 
resulting from the rapid changes in current during MBA operation. 
Effectively, as the coil current decreases the resistor bleeds off 
this energy in the form of heat. This resistor has cooling fins 


ORKaiNAt. PAGE fS 

OF POOS QUALITY' 


28 



o 


attached and normally gets hot during operation. 

The KEPCO BOP 20-20M power supply has a gain of 2 and is 
capable of a 20 ampere current output ( this would correspond to a 
10 volt input to the programming input terminals) . If this amount 
of current was applied to the MBA electro-magnets, it is likely 
that the windings in the magnets would fuse. For this reason, the 
current limits on the power supply have been set to roughly + or - 
1.75 amps. This allows operation of the DC magnets slightly beyond 
their saturation point, btit ensures that damaging currents can't be 
applied. Additionally, this allows for lengthy operation of the 
bearing assembly without overheating the DC magnets. 

o 

In addition to the installation of the programmable power 
supply, a suitable wiring harness was developed. All of the 
connections in the harness are soldered to reduce the possibility 
of noise generation due to loose connections (this would result in 
instability during operation) . Additionally, a connector was 
installed so that the power supply output can be applied to any 
bearing station by simply removing the associated MBA driver card 
and attaching the connector. During early testing this was done 
quite frequently to avoid overheating the DC-magnets (before 
operating current limits were established) • 

To operate the current hardware configuration , first turn on 

o 

the primary power supply at the bottom of the equipment rack. This 
power supply should indicate +28vdc during normal operation 
( make adjustments if needed) . Next, turn on all of the toggle 
switches on the front of the ASPS control panel (the associated 

29 

ORIGINAL PAGC IS 
OF POOR QUALITY 




amber and green lights should illuminate). This applies power to 
the entire MBA, and will allow the gap sensors to operate. Now, 
turn on the KEPCO programmable power supply and position the 
current control switch in the on position while ensuring that the 

voltage control switch is in the off position. At this point the 

* 

system is fully operational and is ready to interface with the 
digital computer. ( 

5. FUTURE HARDWARE DEVELOPMENT. 

The current hardware configuration provides stable operation 
for a single bearing station but can easily be improved and 
expanded to operate the entire^IBA. ; Two alternatives are available 
to achieve this end. Oije'alternative is to expand the existing 
configuration by installing additional KEPCO programmable power 
supplies ( a total of 5 are needed). The KEPCO BOP 50-2M is an 
Ideal candidate for this application. This model provides a 
current output of + or - 2 amperes as opposed to the 20 amperes 
provided by the current model. The advantage here is that the BOP 
50— 2M model only costs $1,174.00 ( less than half the price of the 
BOP 20-20M) and occupies only half the space. 

The physical connection of five power supplies into the 
existing system would be relatively easy, but integration into the 
digital control scheme would require additional electronic 
development. Specifically, the current A/D & D/A convertor 
(DT2811) only provides one output while five are needed to fully 
operate the MBA. This can be incorporated by developing 
electronics that are capable of multiplexing the output signals 

30 

ORIGINAL PAGE fS 
OF POOS QUALITY 



among the five power supplies. For this scheme to work a memory 
device would be needed at each power supply to maintain its current 
level while the software steps among the five bearing stations. A 
simple commercial memory module could easily be adapted to 
accomplish this end. 

A second alternative is to modify the existing MBA driver 
cards to accept digital input. This can be accomplished by 
replacing U1 ( see fig. 10, page 24) with a non— inverting, low gain 
operational amplifier configuration./ Additionally, resistors R6, 
R12 and RIO need to be desolder^d^to disconnect the feedback loop 
for the analog control system. With the proper gain configuration 
on the new operational amplifier (preferably a LM-741 op-amp) 
analog inputs from the DT2811 patch panel could be provided to pins 
19 and 22 of the MBA driver (this input is currently connected to 
the programming input of the programmable power supply) . 

Either of the above modifications can be incorporated to 
expand the present system to operate the entire MBA. In either 
case a parallel software development will be required. Overall, 
the hardware development accomplished all of its objectives. 


ORIGINAL PAGE fS 
OF POOR QUALITY 



V. software Development 

1. Software Background 

According to NASA's final report on "The Development of 

) 

the ASPS Vernier System" (publication 17-1829) , Sperry Flight 
Systems designed and successfully tested a six degree of freedom 

model of a magnetic suspension system. The software associated 

} 

with the ASPS control system was developed on an analog computer of 

| 

the 1970's. This ASPS assembly designed for an analog controller 

. 1 . 

was tested through a computer simulation. No documentation is 

* 

available on the computer simulation approach. In addition, no 

1 

existing documentation mentions any other applications of the 
microcomputer in relation to the ASPS system. 


2. Software Goal I 

In conjunction with the overall objective of this 

project, the goal of the software division is to produce a program 

| 

in the C language for the analysis and control of a single bearing 
station. 

3. Approach jS 

To achieve the above goal, much time was invested to 

-• ■- - ' . ; V' - ■ 

learn the C programming language as well as the C compiler. In 
Addition, an understanding of the j new timer board, the existing 
digital to analog board, and the interface process and subroutines 


1 • 

was necessary. Despite the above obstacles, the approach for 
achieving the software goal consists of the following: 


ORiGiNA.l PAGF « 
OF POOR QUALITY 


32 



1) identifying the required changes to an existing program. 


which has applicable oscilloscope capabilities (developed 
by Mehran Ghofrani) . i 

2) developing test programs to test the interface and 

applicability of the DT 2811 analog to digital converter 
board and the timer board. 

3) writing and debugging a C program for the single magnetic 

bearing system. 

With time permitting, the single bearing program will be modified 
to reflect the existing three bearing system. 

. 4. Hardware & Software Configuration for Computer System 

The above approach required an understanding of both the 
existing hardware and software configurations of the computer 
system. Knowledge of how the interface occurs between the data 
acquisition board, the timer board, and the Microsoft quick C 
software package will enable the production of the levitation 
program. 

Data Acquisition (DAC) Board 

The DAC board used for ^tlie ASPS project is Data 
Translation's DT2811, which oper 2 ££s from the +5V, +12V, and -12V 
power lines on the IBM PC bus. It is a low-cost analog and digital 
I/O board designed for use with the IBM compatible microcomputer 
systems, which in our case is the Gateway 2000. This half-size 
board features three subsystems, each performing distinct 
functions: analog to digital conversion (A/D) , digital to analog 
conversion (D/A) and digital I/O. The DT 2811 (DWG 07237) 


33 


OfHGINAl PAGE K 
OF POOR QUALITY 



DO NOT INSTALL Rlfi. 



USER fwjual a: 

DT26U 


















typically plugs into any one of the fully bussed expansion slots in 
the compatible computer backplane. Highlights of the main features 
of the DT2811 are depicted in figure 13. 

In order to interface with the input/ output signals, the 
DT707, a simple screw terminal panel, provides connection points to 
the interface. User connections are made through convenient screw 
terminals which are labeled in silkscreen (DWG 00817) . The 
connection to the host computer system is made via an integral 
50-conductor flat ribbon cable (3.3 ft) which plugs directly into 
the ST2811 boards jumper connector. However, this same DAC board 
is accessed via a 10-bit address received from the host processor. 
The A/D conversions are initiated with a either a software or 
hardware trigger. Even though the hardware trigger (which consists 
of an externally generated electrical pulse) is possible, the 
software trigger (which is issued by the program running board) is 
more convenient. The interfacing subroutine librarys are 
incorporated into the LPCLAB software package. This real time 
software facilitates A/D and D/A operations through commands in 
several languages including C. Interface is/ accomplished by 
loading the A/D gain and channel registers trith the valid gain and 
channel numbers along with calling the correct variable and 
function names, depending on the desired application or operation. 


OWGJNAL PAGE fS 
OF POOR QUALITY 



Figure 


TABLE 1 - 1 : MAIN FEATURES OF DT2811 


MODEL 


RANGE 


A/D 

RES GAIN 


MAX 

THRUPUT 


de- 


range RES 


DT2811-PGH 


DT2811-PGL 


0-5V 

±5V 

±2.5V 

■ 

1/2/ 

4,8 

20kHz 

20kHz 

0-5V, 

±sv 

±2.5V 

0-5V 

±5V 

+2.5V 

B 


20kHz 
2.5kHz 
2 . 5kHz 

0-5V 

±5V 

±2.5V 


Fl2 


12 


N S TE ks - Resolution in bits. 


Throughout this manual, un^oards^DT^Sll-FGH and 
specific models. 


QfciaiNAL PAG€ fS 
OF POOR QUALITY 








Timer Board 


• The DT2819 timer board is a multi function counter/timer 
which provides counting, sequencing and timing functions for data 
transfers between the host compatible microcomputer systems and a 
peripheral device such as the DAC board. This timer board plugs 
into a single I/O expansion slot in the IBM backplane and operates 
from the +5V power line on the IBM bus. The counter/timer 
subsystem consists of software selectable 5MHz or 1MHz base 
freque^^c^jsy and an AM9513A system timing controller. The AM9513A 
contains five general purpose counters that use scaled frequencies 
from the 5MHz or 1MHz clock, or from an extern^}/ source connected 
to the DT2819. These counters are software configurable for 
active-high or low polarity and for counting up or down in BCD or 
binary. They can also be cascaded to form an effective counter 
with a length of up to 80 bits. In this way, the host processor 
may read an augmented count at any time without disturbing the 
counting process. In addition, the DT2819 provides a single 
interrupt that is configurable for levels 2-7. This interrupt is 
generated on a high to low transition signal from an external 
source connected to the board. The timer board is interfaced 
through eight 8 bit I/O mapped registers that provide all 
communication with the Am9513A chip. More information on the 
Am9513A system timing controller chip is depicted in figure 2-362. 
Jn order to program this chip, the PACER timer board software, 
which contains the timer board subroutines, is necessary. Similar 


37 


OWUHAL PAGE fS 
OF POOR QUALITY 



-1CM- 


Am951 3 A/ AmZ807 3 A 


System Timing Controller 


DISTINCTIVE CHARACTERISTICS 


• Five independent 16-bit counters 

• High speed counting rates 

• Up/down and binary/BCO counting 

• Internal oscillator frequency source 
a Tapped frequency scaler 

e Programmable frequency output 

• 8-bit or 18-bit bus interface 

• Time-of-day option 

• Alarm comparators on counters 1 and 2 


e Complex duty cycle outputs 
a One-shot or continuous outputs 
a Programmable count/gate source selection 
a Programmable input and output polarities 
e Programmable gating functions 
a Retriggering capability 
a +5 volt power supply 
a Standard 40-pin package 


GENERAL DESCRIPTION 


The Am9513A System Timing Controller is an LSI circuit 
designed to service many types of counting, sequencing 
and timing applications. It provides the capability for pro- 
grammable frequency synthesis, high resolution program- 
mable duty cycle waveforms, retrigger able digital one- 
shots, time-of-day docking, coincidence alarms, complex 
pulse generation, high resolution baud rate generation, 
frequency shift keying, stop-watching timing, event count 
accumulation, waveform analysis, etc. A variety of program- 
mable operating modes and control features allow the 
Am95l3A to be peraonaKzed for particular applications as 
wel as dynanscafty^reconfigured under program control. 

The STC includes five general-purpose 18-bit counters. A 
variety of internal frequency sources and external pins may 


be selected as inputs for individual counters with software 
selectable active-high or active-low input polarity. Both 
hardware and software gating of each counter is available. 
Three-state outputs for each counter provide pulses or 
levels and can be active-high or active-low. The counters 
can be programmed to count up or down in either binary or 
BCD. The host processor may read an accumulated count 
at any time without dtturbing the counting process. Any of 
the counters may be Internally concatenated to form any 
effective counter length up to 80 bits. 

The AmZ8073A* is functionally equivalent to the Am9513A 
with timing enhancements which allow it to be tufty speed 
compatible with the AmZSOOl and AmZ8002 microproces- 
sors. 


BLOCK DIAGRAM 



OUT* 


OVY4 


OUT) 


OVT1 


OUTI 


BD003380 


Figure 1-1. 


*29000 « a qA 2*og. Inc. 


01731D 



















to the DAC board, the desired interface operation is performed by 
calling the appropriate subroutines from PACER and providing the 
correct variables associated. Fortunately, the PACER subroutines 
jire^^allable from Microsoft Quick C. 

Microsoft Quick C 

Microsoft Quick C is a simplified version of 

e 

Microsoft C. As the name suggests, it is produced by Microsoft. 
For the purposes of this project, Microsoft Quick C version 2.5 is 
used. This version required 448 kilobytes of available memory. 
Some special features of this version are that it has an increased 
ANSI standard C compatibility, a new quickwatch debugging feature 
and a color window support which can be customized. The software 
has been installed for compatibility with a small memory model. 
This means that 64K is allotted as the code segment limit and 64K 
as the data segment limit. It is worth noting that certain 
features of QuickC must be changed from the default when a program 
wishes to incorporate the DAC or timer boards. In the case of the 

i 

o 

DAC board, the stack size needs to be increased when continuous 
data conversion operations are desired. Also, if the timer board 
were utilized by a program, the mapping feature under the option, 
as well as the stack check need to be changed when timer board 
interface and an interrupt call is desired. 

5. Problems Encountered and Modifications 

In our attempt to achieve the software goal of the 
project, several problems were encountered . The first problem 
encountered was the software incompatibility problem. The problem 



was that the original LPCLAB version 1.0 was not compatible with 
QuickC 1.0. This fact was not realized until later in the software 
development program since some LPCLAB commands were executable 
while others were not. Also, since the timer board software 
(PACER) required QuickC 2.5, both the QuickC 2.5 and the LPCLAB 
2.01 were purchased and installed soon after. After the 
installation of the correct version of the QuickC compiler, the 
memory setup for the QuickC compiler and the LPCLAB was found to be 
incorrect. This was due to QuickC detecting a mismatch of the 
memory library files with those used by the LPCLAB setup 
requirement. This problem was resolved by reinstalling the QuickC 
and LPCLAB for a small memory model. Next, test programs such as 
the one in figure 14 were developed and successfully interfaced 
with the DAC board. However, the interface with the timer board in 
the test programs was unsuccessful. This was probably due to the 
improper call of the PA_SETUP_INTERRUPT or other required parameter 
definitions. Since the interface with the timer board was 
unsuccessful, the program development only utilized the DAC board 
operations to control the electromagnetic levitation process. 

6. Program Development Analysis 
• Ghofrani Program Modifications 

The Ghofrani program is a complex and very user 
friendly program that controls the leviation of a five degree of 
freedom magnetic suspension system. This program starts off by 
defining the interrupt service routine (ISR) by using DOS assembly 
interrupt commands. These commands were changed to the timer board 


39 



interrupt commands. The controller loop provides for filtering of 
both the yaw changes as well as the lateral changes. The only 
aspect that was modified was the controller model used. This was 
changed from a PID to a PD control model. Other changes to the 
Ghofrani program included the dual phase advance compensator 
aspects, the timer setup aspect, the matrix manipulation and 
decoupling aspects, and the data acquisition I/O aspects. A copy 
of the original program is included in the appendix with the 
changes highlighted. 

Single Magnetic Bearing Assembly Levitation Program 

This program was developed for a one degree of 
freedom suspension system, according to the program algorithm as 
depicted in figure 15. The PD control section of this program was 
modelled after the test program 'levate' (fig 14). It starts off 
with the main menu, where the user is given three choices; passive 
operation, active operation, or quitting. The passive mode entails 
running the levitation control without any screen interaction 
whereas the active mode entails running the control with the 
oscilloscope functions. In either case the voltage data retrieved 
through the DAC board is written to a file until the control loop 
is broken when any key on the keyboard is hit. The data stored in 
the SBAVOLT file can be called later for other calculations such as 
the current, force, and position. These calculations are executed 
and then written into different files, once the control is 

e , i 

terminated. It is worth noting that the equations for the optional 
calculations have not been developed. Therefore, this section only 


40 



has debugging statements for testing purposes. Finally, the user 
is returned to the main menu and may reinitiate the control routine 
by either choosing the active or passive keywords. A copy of the 
program is included in the appendix. 



Figure 14 


Sample Test Program 


#include<stdio.h> 


voidiain(void) 

{ 

floatatergral , xold, speed; 
shomb/alue , actcontrols , control ; 
i<nb,n,m; 

LPINIT ( ) ; 

LPSB(l) ; 
intergral=0 ; 
b=0; 

xvalue=0 ; 
actcontrols=0 ; 
intergral=0 ; 
while(b<15000) { 

/*while(m<5000) { 
m=m+l; 

) */ 

xold=xvalue; 

LPAV (1,1, &xvalue) ; 
printf ("iiXn" ,xvalue) ; 
xvalue=xvalue-2047 ; 
intergral=intergral+. 01*xvalue; 

speed= (xvalue-jjccCLa^ ; 

control=-. 5*xvalue-. 005*speed-0*intergral; 
control=control+2314 ; 

L^DV ( 0 , control ) ; 
b=b+l ; 

} 

control=2047 ; 

LPDV(0, control) ; 

) 


o 


page is 

0^ POOP QUALITY 



.VWy iv : 


Figure 1 S. Data Flow Algorithm 









▼I. FEEDBACK CONTROL DESIGN AND ANALYSIS 


1. BACKGROUND 

The controls model originally developed for the ASPS 
represents a mathematical model of a PID controller. The complexity 
of the original model evolved from the integration of a six degree 
of freedom system with extensive control^. — electronics (analog 
system) . Figure 16 shows the original control logic. 

2 . CONTROL LOGIC GOAL - 

The objective is to design a mathematical'control model that 
represents the stabilization of a single bearing station. 

3. APPROACH 

This aspect of the project first focused on choosing a 
type of control that was compatible with the magnetic rotary joint 
application. The options of a proportional -derivative (PD) and a 
phase advance control were investigated and the PD controller was 
chosen. Reasons for this decision included that the PD control is 
a simple regulating processing controller, and an error minimizer. 
A general representation of the PD controller under inspection is 
included as figure 17. Upon further investigation, the following 
top level diagram of the controller relation was developed (Figure 
18) . 


1 O&MiHAL PAGE fS 
Of POOR QUALITY 



Figur 



MAGNETIC SUSPENSION STATION 



















|zj D-I CD E-I 


Figure l’f. General PD Control 



46 










Figure 18. PD Control USED 







4. PD CONTROLLER DESIGN 

The controller developed for the MBA is a proportional 
derivative controller which is modeled entirely as a computer 
program. Figure 18, is a block diagram of the single loop system 
which consists of the above controller, plant, and position sensor 
feedback loop. The controller is the C program described earlier 
in this report. Physically, the plant consists of the KEPCO 
programmable power supply, the actual bearing station and a one ohm 
resistor on the return line to the power supply. The position 
sensor feedback loop consists of the position sensors, and position 
sensor amplifiers (see figure 9, page 23). 

The transfer function, G(s) models the entire system as 
described above. In the development of this model some assumptions 
were made to simplify the end result. One assumption was that the 
programming time constant of the KEPCO power supply was fast enough 
that any roots or poles that it generated would be very far to the 
left on the left half plane, and hence would not effect the 
stability of the system. Another assumption was that the reaction 
times of the DT2811 patch panel and the position sensor amplifiers 
were also fast enough not to be included in the theoretical model. 
Overall, these assumptions allowed the position sensor feedback to 
be modeled as a constant (403.27 volts per meter for bearing 
station A) and the voltage to current conversion carried out by the 
KEPCO programmable power supply to be represented as a gain of two. 
„ Once the theoretical model was complete it was programmed into 
MATLAB for analysis. Using trail and error, different values of kp 


48 



and kd were analyzed by MATLAB using a ratio of kp/kd that 
generated a root loci plot that was entirely on the LHP was 
determined. The ratio of kp/kd » 100 was determined as an optimum 
gain ratio and produced the root loci plot as shown. The above 
gain ratio resulted in stable magnetic levitation of bearing 
station A. In conclusion, the theoretical model is correct because 

e 

it predicts stability and this is evidenced by stable operation of 
the MBA for the selected^^/kd^ratio. 




r 




i 

V 


49 


-i 



Derivation of Control Logic 



50 



VII. CONCLUSION 


P 

The third order transfer function derived in this project 
represents a stable control system with a gain of 100. This was 
used to produce a control program in the C language that, when 
integrated with the system electronics, operates a single axial 
bearing station. Thus, the objectives of this semester project 
have been met and the ASPS program < is^ready to build on these 
accomplishments. Operation of the entire ASPS should now be a 
primary goal. While there is still much work to be completed, the 
operation of a single station has proven that it is feasible, and 
has identified the aspects that must be/modified to obtain such a 
goal . 

o • ^ 


page is 
O f WW QUALITY 



***$• **■ >■ ^ — • 



REFERENCES 
1) The Development of the ASPS Vernier 
Sperry Corporation. 



System, Final Report, 


2) ASPS-Final Design Review, Sperry Corporation. 

3) Van de Vegte, John. Feedback Control Systems, 2nd ed.. 
New Jersey: Prentice Hall, 1990. 

4) Kemighan, Brian W. and Dennis M. Ritchie. The c 
Programming Language, 2nd ed. New Jersey: Prentice Hall, 
1988. 

5) Microsoft Corp., C For Yourself, 1990. 

6) Ohanian, Hans C. Physics, New York: W.W. Norton & 

Co., 1985. 

Data Translation Manuals for DT2811 & DT2819. 


7 ) 



Appendix 


/***************************************************************************/ 


/* 

/* 

/* 

/* 

/* 

/* 


ASPS */ 

Single Magnetic Bearing Assembly Code */ 

MEM Senior Project Members: WE Smith, W Thomas, T Quach 

Old Dominion University - Fall 1993 */ 


Programming Language: C 


Programmer: T Quach 


/*********************************************************************** 


*/ 

*** 


*/ 

*/ 

*/ 


/*********************************************************************/ 

# include <graph.h> 

# include <stdio.h> 

# include <conio.h> 

# include <math.h> C 

# include <signal.h> ^\ v 

# include <stdlib.h> 

# include <malloc.h> 


/* ASCI definitions for the function keys assoc, with the oscilloscope */ 
'.fine UP 72 
refine DOWN 80 

^define LEFT 75 ■ 

^define RIGHT 77 . 

#define ENTER 28 : '■£ ■ 

#define ESC 27 h < fo: 

# define FI 59 : V ; . • : 

#define F2 60 

Idefine F4 62 

#def ine F5 63 

#define F6 64 ^.;.;.T v y. 

^define F9 67 ' ~ ~ 

tdefine F10 68 

fldefine pi 3.14159 . , 

tdefine On 1 ' — ' ' '■ - 

#define Off 0 y '■ '' - 

/******************************************************************/ 
char choice, /* Bolean for loop termination */ 

ch,chl,ch2, 

prnchoice, 

chin, • • ’■■■? ’ ; :- 

plotmode , loop ; 

short Vf,vi, /* analoge data of sensor signal */ 

Kp,Kd, /* Gain constants */ . 

xvalue , analog_dat ? 

int chanin,chanout, /* I/O Channel for DAC board */ 


. - finish, /* Bolean for main loop termination */ 

maxx,maxy, /* Screen dimension */ 

counter, ii, i, 1, /* interation loop counter */ 

increment, 
temp, 

dim,x,y, /* array counter for data */ 

chd, /* Bolean for loop termination */ 

trig, /* plot type determination */ 

zoom=l, 

positionsign, 

ga inupdo wn, 

/* constants */ 
ix=25; 

double all,a,b,c,d,e, f ; 
float intergral,xold, speed; 
long backc; 

/****************************************************************** / 
/*********************** Function definitions *******************/ 
void scrn_setup(void) ; 
void prn_inf o (void) ; 
void oscilloscope (void) ; 
void plotdat (void) ; 
void keyboard (void) ; 
void outdat(void) ; 

void *gainplot (void) ; ,- 

void positionplot (void) ; 
void trigplot(void) ; 

void compensator (void) ; ■ 

void timer setup (void) ; 
void savedat (void) ; 

double getdat (double *Kp, double *Kd, short *chanin, short *chanout) ; 


/******************************************************************/ 
/*********************** File definitions ***********************/ 

FILE SBAIN, /* pointer for "constin" file */ 

SBAVOLT, /* pointer for "volt" file */ 

SBAY, /* pointer for "gap" file */ 

SBAI, /* pointer for "current" file */ 

SBAFORC; /* pointer for "force" file */ 

/************************** MAIN PROGRAM ****************************/ 

/ *== ===== ========= BEGIN MAIN — =========*/ 

mam() 

{ ■ ' - v : 

prn_4nfo(); ‘ 

scrn_setup() ; 

printf ("This program can perform the following: \n") ? 
printf (" l) Passive Mode - no screen display just controls \n") ; 

printf (" 2) Active Mode - oscilloscope display with controls \n") ; 

printf (" 3) Quit \n") ; 

j ' , v . 


54 



do { 

printf ("Please enter the number of your choice: ") ? 
choice=getchar ( ) ; v 

counter=0; 

Kp=0; ; 

Kd=0? 
chanin=Of 
chanout=0 ; 

switch (choice) { ; 

case 'P': case 'p': /* Passive */■ 

printf ("1") ; 
counter * counter +1? 
dat_retreval ( ) ; 
pd_control ( ) ; 
prn_data(); 

break; -gr- 
ease 'A*: case 'a': /* Active */ 

printf ("2") ; 
counter = counter +1? 
dat_retreval ( ) ; 
pd_ctrlplot ( ) ; 
prn_data ( ) ; 
break; 

case 'Q' tease 'q': /* Quit */ 

finish =1; 

printf ( "bye 1 " ) ; ; 

\ break; 

■■ default: " 

printf ( "invalid choice selected, select again\n" ) ; 
finish = 0; 1 V',.^ 

break; ’ ; v. 


) while ( 1 finish) ; 
exit(l) ; 


y 'V 


/************** end of main ————— ******************************/ 

/************************************************************************ y 

/**************************** SUBROUTINES ***************************/ 
/***********************************************************************/ 
void prn_inf o (void) r : 


scrn_setup() ; 
printf (" 
printf (" 
printf ( " 
printf (" 
printf (" \n 
printf (" util 
printf (" 
printf (" 


\n "); 
Utilizes: 
2 ) " 


ASPS \n 

Single Magnetic Bearing Assembly Code \n 
MEM Senior Project Members: WE Smith, W Thomas, T Quach \n 
Old Dominion University - Fall 1993 \n 


printf (" Hit any key to continue"); 


1) Data Translation Dt2811 DAC board (V 1.02\n"); 

" Pacer Timer board (V 1.00) \n") ; 

3) Microsoft (quick) C > : (V 4 1.20) \n") ; 


55 



getch(); 

ear screen (_GCLEARSCREEN) ; 

'} 

/************************************************************************ . 
void scrn_setup (void) 

{ : . <• 

graphic_config() ; 

_setcolor(4) ; 

_rectangle(_GFILLINTERIOR,550,420,637,447) ; 

_settextposition(5, 10) ? 

) 

/ ****** **************** it***************************************-/,********* t 

double getdat (double *Kp, double *Kd, 

short * chan in, short *chanout) 

scrn_setup() ; l",., t 

SBAIN=fopen ( "c:\data\const (counter) " : "w+") ? : “ 

printf ("\n Please enter the proportional gain: ") ; 

scanf ("%d\n",&Kp) ; 

fprintf (SBAIN, H Kp : %d",&Kp)? 

printf ("Please enter the derivative gain: *) ; 

scanf ("%d\n",&Kd) ; 

fprintf (SBAIN, "Kp : %d",&Kp); 

printf ("Please enter the signal input channel: ") ? 
scanf ("%d\n",&chanin) ; 

fprintf (SBAIN, "chan, in : %s",&chanin) ? 

r ; n tf( "Please enter the signal output chan nel :.**); 

t. anf ( "%d\n" , Schanout) ; - 

fprintf (SBAIN, "chan, out?: %d" , fichanout) ; 

f close (SBAIN) ? :'V- ■ 


/************************************************************************ , 
double pd_control (double *Kp, double *Kd, 

double *chanin, double *chanout) 


{ 


/* 


ch=ESC? 

while (chi !=ESC) ■ ■ 

_setcolor(4) 

_rectangle (_GFILLINTERIOR, 550,420, 637,447);’“ 
_settextposition (28 , 71) ? 
printf ("RUNNING") ; 

_settextposition(29,71) ? 

printf ( "ESC - QUIT" ) ; v. B 

timer (); 

_settextposition(12,24) ? 
while (chi 1 =ESC) 

{ - ’■ ■ ■ ■ ' •. ' : 

SBAVOLT=f open ("volt", "w+") ; */ 



keyboard ( ) ; 



. Vi=LPAD (chanin , analog_dat) ? 

while ( ch2 ! =ESC) ^ T 

) 

xold=xvalue ; 

LPAV (chanin, gain, fixvalue) ? 

Vf=xvalue ; 

printf ("%i\n",xvalue) ; 
xvalue=xvalue-2047 ; 
intergral=intergral+. 01*xvalue? 

speed** (xvalue-xold) /.003? 

analog_dat=~. 5*xvalue-. 005*speed-0*intergral ; 
Vc=analog_dat ? 
analog_dat=analog_dat+2 314; 
LPDV(chanout,analog_dat) ; 

save_dat ( ) ; 

fprintf (SBAVOLT, "%h", &Vi) ? 

Vi=Vf ; 

} 

analog_dat*=2047; 

LPDV(0,analog_dat) ? , 


/************************************************************************/ 
< ible pd_ctrlplot (double *Kp, double *Kd, 

double *chanin, double *chanout) 

{ 

ch=ESC; 

while (chi !=ESC) 

< :: 

_setcolor ( 4 ) 

_rectangle (_GFILLINTERIOR,550,420,637,447) ; 

_settextposition (28 ,71) ? 

printf ("RUNNING") ; ; v 

_settextposition(29,71) ? 

printf ("ESC ** QUIT") ; f'- 

timer() ; 'O’: 

_settextposition(12,24) ; 
while (chi 1=ESC) 


of p=f open ( "volt" , "w+" ) ; */ 


keyboard ( ) ? 

• start_time ( ) ? 

_setvideomode (_VERS16C0L0R) ? 
oscilloscope ( ) ? 

Vi=LPAD (chanin, anal og_dat) ; 
while (ch2l -ESC) 

) 

LPDV (chanout , analog_dat) ; 



57 



Vf=LPAD(chanin, analog_dat) ; 
samplerate=pm_time ( ) ; 

Vc=(Kp*vi) +Kd* ( (Vf-vi)/samplerate) ; 
LPCV(&Vc) ; 
sav_dat ( ) ; 

/* fprintf (ofp,Vi) ; */ 

Vi=Vf; 

. if (chd!=0) 

if(!trig }} ix<474) 

{ 

if (plotmode— • a • ) plotdat ( ) ? 
if (plotmode='s') 

{ 

switch (ch2) 

{ 

case 'x': if(j»*=0) trigplot()? 
break; 

case 'y': if(j=l) trigplot(); 
break; 

case 'z': if(j=2) trigplot() ; 
break; 

case 'm': if ( j=®3) trigplot(); 
break; 

case 'n': if(j=4) trigplot() ; 
break; 

> ■ - C : • 

»• 1 


/***************************************************************/ 

if (trig— 0) 

if(ix>=475) ix=25;/* reset screen position to begining when at end */ 
if (ix<=475) ix++; 

/* screen horizontal advance chk plotdat */ 


_setcolor(2) ; 

_rectangle (_GFILLINTERIOR, 550,420,637,477) ; 
_settextposition (28,71); 

_outtext( w R-Run w ) ; 

_settextposit ion (29,71) ; 

_outtext ( "ESC-exit" ) ; 


* v • ir : $ • 


chl=getch ( ) ; 




} 

) ' ^ : 

/************************************************************************/ 
/* saves data to file 'volt' */ 


' •' C 'Tv:-.' 

V" • X . ■ ;■■■ 




OWGINAL PAGE IS 
OF POOR QUAUTY 



void savedat(void) 

\ 

int i; 

FILE *SBAVOLT; 



if ( (SBAVOLT=f open (volt, "w+") ) !=NULL) 

{ 

Ch— ESC t 

while (chi !=ESC) 

( 

fprintf (SBAVOLT, "%s" , &V) ; 
f print f ( SBAVOLT ," \n" ) ; 

} 

fclose(fp) ; 

’ } . , - ='•' ■ 

/************************************************************************/ 
/* loads data from file 'volt' */ 

void getdat(void) 

{ 

int i,j,k,dim; 


if ( (SBAVOLT=f open (volt, "r+") ) !=NULL) 

{ .--v, 

printf ("Data loading \n") ; 
fscanf (fp, "%d" , &dim) ? 

printf (" Number of data points are: %d \n ",dim) ? 
f or (k=0 ; k<=dim-l ; k++ ) 

fscanf (fp,"%d",&V[k]) ; 

printf (" Data was successfully loaded, hit Enter") ; 
fclose(fp) ? 

} - ;V ; • 

else '■/ \ 

ffrrintf (stderr, "Oops file error"); 


/************************************************************************/ 
/* Calculates the force relationships for printing */ 
double calc_force (double *) 

{ • ■ 

printf ("the force calculation"); 

( fp=f open (volt, "r+") 
printf ("Data loading \n") ; 

fscanf ( f p , " %d" , &dim) ; 

printf (" Number of data points are: %d \n ",dim); 
for ( increments ; increment<=dim-l ; increment-H-) 

; { ■ ■ 

fscanf (fp, "%d" , &V[ increment] ) ; 

J- : .■£> ' ' v . 


PAGE !S 
OF POOR QUAUTY 



F[incrememt]=( /permiability) ; 

} 

fclose(fp) ; 


return F? 

/**********^****************************************************** *******/ 
/* Calculates the position relationships for printing */ 

double calc_y (double *) 

printf ("the position calculation"); 

( fp=f open (volt, "r+" ) 
printf ("Data loading \n") ; 

fscanf (fp, "%d", &dim) ; 

printf (" Number of data points are: %d \n ",dim) ; 
for ( increments ; increment<=dim-l ; increments) 

{ 

fscanf (fp,"%d",&V[ increment] ) ; 
y[ increment] =( /permiability); 

) 

fclose(fp) ; i 

return y°; 

} 

/******************** *^**************************** ************** ********/ 
/* Calculates the current relationships for printing */ 
ible calc_current (double *) 

V - ■ y:- 

printf ("the curent calculation"); 

( f p=f open (volt, "r+") 

printf ("Data loading \n") ; . 

fscanf (fp, "%d", &dim) ; 

printf (" Number of data points are: %d \n ",dim); 
f or ( incr ement= 0 ; increment <=dim-l ; increments ) 

: ■ { : .. 

fscanf (fp, "%d" , &V[ increment] ) ; 
current [ incrememt ] = ( /permiability); 

fclose(fp) ; / 

return current; • 

} • • 

/************************************************************************/ 

/************************************************************************/ 

double jftrn data (double * ) v."'-- 

printf ("Would you like a hardcopy of the results (Y/N) : " ); 
prnchoice=getch ( ) ; 

switch (prachoice) { V-. 

case ' Y* : case 'y ' : 

printf ("What type of data: Force, Position, Current, Voltage, All") ; 
printf ("Please enter the FIRST letter of choice:"); 

: J : , ■ i ■ ■' ■ : 



60 



datachoice=getch ( ) ; 
switch (da tachoice) { 

case 'F': case 'f': 
calc_f orce ( ) ; 
prn_f ormat () ; 
break; 

. case 'P*: case'p': 
calc__y ( ) ; 
pm_format() ; 
break; 

case ’C': case 'c' : 
calc_current ( ) ; 
prn_format() ; 
break; 

case 'V': case 'v's 
fp=f open (volt, "r++") ; 
fscanf (fp,"%d w ,&V) ; 
prn_f ormat ( ) ; 
break; 

case 'A': case 'a': 
calc_force() ; 
calc_y ( ) ; 
calc_current ( ) ; 
fp=f open (volt , "r++" ) ; 
fscanf ( f p , " %d" , &V) ; 
prn_f ormat () ; 
break; 

' ■■ ■' ) :. v v : 

break; S' - t ■ 

case* 'N' :case 'n' ; 
printf( "No printout. selected"); 
break; . • 

} ■ ■ : • ■ ■ 

/************************************************************************/ 
double prn_f ormat (double *) 

( 

printf ( "prn format exec"); ^ 

/ ************************************************************************ y 
/* keyboard; User interaction through keyboard */ 

void keyboard (void) . ' a 

char chin; ' -o' 

if (kbhit() 1=0) 

chin=getch() ; 

/* if (! chin) chin=getch() ; */ 
switch (chin) 

< <o;C-;-;v 

case ’X 1 tease ’x’ ; ch2='x'; 

* _ se t c °l° r (8) ; . V 




61 



35.320.39.478) ; 
35,320,39,340) ; 

:0R, 20, 5, 480, 290) ; 

35.320.39.478) ; 
35,352,39,372 ) J 

OR, 20, 5, 480, 290) ; 

35.320.39.478) ? 
35,384,39,404) ; 

iOR, 20,5,480,290) ; 

35.320.39.478) ; 
35,416,39,436) ? 

[OR, 20, 5, 480, 290) ? 


,35,320,39,478) ? 
,35,448,39,468) ; 




IOR, 20, 5, 480, 290) ; 


62 


I 


""“W*. PACE m 

* ^ 0O P Quautv 









break; 

case 'S': case 's': plotmode* * s ' 
_setcolor(plotcolor) ; 
_rectangle (_GFILLINTERI 
break; 

case 'A': case 'a': plotmode^a' 
break; 

case 'T': case ’t': trig=l; 

break; 

case 'C': case •c's.trig-O; 
break; 

case 0 : 

chin=getch ( ) ; 

switch ( chin) u. 

{ % ' 

case RIGHT: gainupdown=l ; 
gainplot(); 
break; 

case LEFT: gainupdown=-l; 
gainplot ( ) ; 

. break; 

case UP: posit ions ign=l; 
positionplot () ; 
break; 

case DOWN: positionsign=-l; 
positionplot () ; 
break; 

case FI: if(zoom>l) zoom-zoom 
_settextposition(l, 60) ; 
printf ("%i ",zoom) ; 
break; > 

case F2: if(zoom<10) zoom* zoo 
_settextposition(l,60) ; 
printf ("%i ",zoom); 
break; 

case F4: savedat(); /* 

break; 

case F5: 

printf ( "no operation f unc 
break; v ; \. 

case F6: f 

printf ("no operation func 
break; 

case F9: rota*0; 

_settextcolor(8) ; 
_settextposition (19,75) 
_outtext("on") ; 
_settextcolor(4) ; 
_settextposition (18,75) 
_outtext ("of f ") ; 

break; 


■ *. i> kv?-_ 

0WQ1NAL PAGE * I'M 
OF POOH QUA UTV ' 


case F10: rota=l; 

_settextcolor(8) ; 
_settextposition (18, 75) 
_outtext ("off'*) ; 
_settextcolor(4) ; 

• _settextposition(19,75) 

_outtext ( "on" ) ; 
break; 

) : 

break; 

case ' E ' ; case ' e ' : chd=l ; 

break; 

case 'D':case 'd 1 : chd=0; 
break; 

case ESC; ch=ESC; break; 

) 

} 

chin= ' . ' ; 


/*********************************************************** 
/* oscilloscope; signal display screen se£up 
void oscilloscope (void) 

( 

int 11/ j j ,gainstart,posibar; 

/* initialization of the screen clear ai 
\ for (11=0 ;11<=5;++11) 

•V ( . 

for ( j j=0; j j<=500;++j j) 
olddat[jj] [11]=20; 

/* display of the oscilloscope scre< 

_clearscreen (_GCLEARSCREEN) ; 

_setcolor(13) ; 

_rectangle (_GB0RDER, 0/ 0, 639, 479) ; 

_setcolor(plotcolor) ; 

_rectangle(_GFILLINTERIOR, 20, 5, 480,2^0) 

_settextposition (4,2); 
printf ("X") ; 

_settextposition(7,2) ;; . 
printf ("Y") ; 

_settextposition(10,2) ; 
printf ("Z") ; 

_settextposition (13,2) ; 
printf ("M") ; ™ 

_settextposition(16,2) ; 
printf ("N") ; 

_setcolor(7) ; 

for (11=52 ;11<=244; 11=11+48) 

^jnoveto ( 19 , 11) ; 

_lineto(24,ll) ; 


************ 


ORIGINAL PAGE ft 
OF POOR QUALITY 


} 


_moveto (476, 11) ; 
_lineto(484,ll) ? 


*************/ 


/**************************************** 

/* Gain control knobs Display */ 

_setcolor ( 12 ) ; 

_rectangle (_GBORDER, 2,300,480, 478) ? 

_settextposition(20,2) ; 

_settextcolor(14) ; 

_outtext(" Feedback gain control")? 

_settextposition(20,40) ? 

_outtext ("Position Control") ? 

_setcolor(5) ? 

33=0? 

for(ll=21?ll<=29?ll=ll+2) /* la^Leing the gain knobs */ 

_settextposition(ll,27) ? 
printf ("%4.3f",gain[j j]) ; 

j j ++ ? 

_settextposition(ll,4) ? 
printf ("0") ; 

> 

for(ll=319;ll<=447?ll=ll+32) /* &ain control bar display */ 

_rect angle (_GBORDER, 42,11,196, l£t22) ? 

jj=0? 

for (11=320 ;11<=448 ? 11=11+32) /*fe>resetting gain display */ 

} { /* on the screen */ 

gains tart= ( int) (gain[j j]*80)+4< 

_setcolor(6) ; 

_rect angle (_GFILLINTERIOR, 40, ll|gainstart+3 , 11+20) ; 

++jj? 

> 

/* display of position control knobs */ 

_s^tcolor(4) ; 

for(ll=320?ll<=448 711=11+32) /•position control bar display 

_rectangle (_GBORDER, 3 10 , 11 , 4 60 , JL+2 0) ? 

_setcolor(10) ; 
jj=0? 

for (11=320 ; 11<=44 8 ? 11=11+32 ) —fv: 

{ posibar=385+(int) (position[j j]*2s) ? 

_rectangle (_GFILLINTERIOR,posibar, 11, posibar+1, 11+20) ? 

++jj? 

) 

/***************************************yl 

/* labling of gain knob display */ 

_settextposition(21,2) ? 

_outtext("X") ? /* x or axj 

_settextposition (2 3 , 2 ) ; 

_outtext("Y") ? /* y or sic 

_settextposit ion ( 2 5 , 2 ) ? 

J 


v 

v 


QWQHyAL PAGE l« 
Ct POOR QUAUTY 


9 


/* z or vei 


/* M - pitc 


_outtext ( " Z " ) ; 

_settextposition(27,2) ; 

_outtext("M") ; 

_settextpos it ion ( 2 9 , 2 ) ; 

_outtext("N M ) ; /* N - ye 

y'************************************ / 

/* Display of options */ 

_settextposition (2,62); 
printf ("E- enable plot! 1 ); 
_settextposition(3,62) ; 
printf ("D- diseible plot"); 
_settextposition (5,62); 
printf ("Select Channel"); 
_settextposition(6,62) ; 
printf ( " Press " ) ; 
_settextposition(7,62) ; 
printf (" X Y Z M N") ; 

_settextposition(9,62) ; 
printf ("S- single plot") ; 
_settextposition(10, 62) ; 
printf ("A - all plots") ; 
_settextposition(ll, 62) ; 
printf ( "T - triggered " ) ; 
_settextposition ( 12 , 62 ) ; 
printf ("C - continuous"); 
y _settextposition (13,62); 
printf ("FI- unzoom plot"); 
_settextposition (14,62); 
printf ("F2- zoom plot"); 
_settextposition(15,62) ; 
printf ("F4- Save data"); 
_settextposition ( 16 , 62 ) ; 
printf ("F5- - Yaw ") ; 
_settextposition ( 17 , 62 ) ; 
printf ("F6- + Yaw ") ; 
_settextposition(18, 62) ; 
printf ("F9- Auto Yaw off"); 
_settextcolor (4) ; ' i 

_settextposit ion (18,75); 
_outtext("off") ; 

_settextposition ( 19 , 62 ) ; 
printf ("F10- AutoYaw on"); 

_settextposition (24 , 62 ) ; 
printf ("Yaw Error;"); 
_settextposition (22,62) ; 
printf ("Yaw Angle;");. 


Leal V 
; movement */ 
movement */ 


ORIGINAL. PAGE « 
OF POOR QUALITY 


66 


****************************/ 


**************** ******* ******/ 


»****************************/ 

of freedom graphically */ 


) 



<*K**AL PAGE 18 
OF POOR QUALITY 









_setcolor (knobcolor) ? 
gainknob*40+(int) (gain[l]*80.0) ; 

_rectangle (_GFILLINTERIOR, gainknob ,352, gainknob+3 ,372); 
gain [ 1 ] =gain [ 1 ] +gainupdown*gainstep ; 
_settextposition(23,27) ? 
printf ("%4.3f",gain[l]) ? 

) 

else 

if (gain[l]<0) gain[l]=0? 
if (gain[l]>2) gain[l]=2; 
break; ( 

•case ' z ' : 

if ( (gain [2] >=0) && (gain[2]<-2) ) 

{ 

knobcolor=3*(gainupdown+l) ; JL, 

_setcolor (knobcolor) ; 
gainknob=40+(int) (gain[2]*80.0) ; 

_rectangle(_GFILLINTERIOR, gainknob, 384, gainknob+3, 404) ; 
gain [ 2 ] =gain [ 2 ] +gainupdovn*gainstep ; 
_settextposition(25,27) ; 
printf ("%4.3f ", gain [2]) ; 

} 

if (gain[2]<0) gain[2]=0; 
if (gain [2] >2) gain£2]-2; 
break; j 

case 'm* : 

if ( (gain[3]>=0) && (gain[3]<«*2) ).'> • 

knobcolor=3* (gainupdown+1) 7;^:; 

_setcolor (knobcolor) ; 
gainknob=40+(int) (gain[3]*80.0) ? 

_rectangle (_GFILLINTERIOR, gainknob , 416 , gainknob+3 ,436) ; 
o gain[3]=gain[3]+gainupdown*gainstep? 
_settextposition(27,27) ; 
printf ("%4.3f",gain[3]) ? 

else ' v 4": :;-v^ 

if (gain [ 3 ] <0 ) gain [ 3 ) *0 ? 
if (gain[3]>2) gain[3]«2; 
break; 


case *n': 


if ( (gain[4]>=0) && (gain[4]<-2) ) 


knobcolor=3* (gainupdown+1) 7 
_setcolor (knobcolor) ? ' . 

gainknob*40+(int) (gain[4]*80.0) ? 

_rectangle (_GFILLINTERIOR, gainknob , 448 , gainknob+3 ,468) ; 
gain [ 4 ] =gain [ 4 ) +gainupdown*gainstep ; 
_settextposition(29, 27) ? V 

printf ("%4.3f",gain[4]) ? 


) 


tiM&NAL PAGE 18 
Of POOH QUALITY 


68 



else 

if (gain[4]<0) gain[4]«=0; 
if (gain [4] >2) gain [4] -2; 
break; 


} 

} ; . l 

/********************************************************************/ 
/* positionplot: control and display of position knobs */ 

void positionplot (void) 

{ 

int knobcolor,positionknob,bkcolor; 
knobcolor=10 ; 
bkcolor=4 ? 
if (trig=l) 
ix=25; 

<sampler=0 ; /* counter for collecting data in ISR */ 

switch (ch2) 

( 


vJ 


case 'x' : 

_setcolor (0) ; 

_rectangle (_GFILLINTERIOR, 310 # 320,461,340) ? 

_setcolor(bkcolor) ; 

_rectangle (_GBORDER, 310,320,461,340) ? 

_setcolor(knobcolor) ; 

position [ 0 ] =position [ 0 ] +positionsign*positionstep ; 
if (position [ 0 ] <-l) position [0]»-l; 
if (position [ 0 ] >1) position [0]«1; : 
positionknob=385+(int) (position[0]*75.0) ? 

_rectangle (_GFILLINTERI OR, positionknob, 320 , posit ionknob+1 ,340) 
break; 

case 'y ' : : ^ 

_setcolor(0) ; ’ 

__rectangle(_GFILLINTERIOR,310,352,461,372) ; 

_setcolor(bkcolor) ; 

_rectangle (_GB0RDER, 310, 352, 461, 372) ; 

• _setcolor (knobcolor) ; - • 

position [ 1 ] ^position [ 1 ] +positionsign*positionstep ; 
if (position [ 1 ] <-l) position[l)--l; y? , ; . 

if (position [ 1 ) >1) position(l)-l; " ‘ 

positionknob=385+(int) (position [1] *75. 0) ; 

_rectangle (_GFILLINTERI OR, positionknob, 352 ,positionknob+l , 372 ) 
break; 
case % z % : 

_setcolor(0) ; 

_rectangle (_GFILLINTERIOR, 310,384,461,404); 

_setcolor(bkcolor) ; 

^rectangle (J3B0RDER, 310 , 384 , 4 61 , 4 04 ) ; 



OWQJNAL PAGE It 
Of F00R QUALITY 



_setcolor (knobcolor) ? 

position [ 2 ] “position [ 2 ] +positionsign*positionstep ; 
if (position[2]<-l) position [ 2 ]“-l; 

• if (position [2] >1) position[2]~l; * 

positionknob=385+(int) (position(2]*75.0) ; 

_rectangle(_GFILLINTERIOR,positionknob,384,positionknob+l,404) ; 
break; 

case 'm's y-'v.. 

_setcolor(0) ? 

_rectangle (_GFILLINTERIOR, 310,416,461,436); 

_setcolor(bkcolor) ; 

_rectangle(_GBORDER, 310,416,461,436) ; 

_setcolor (knobcolor) ; 

position [ 3 ] “position [ 3 ] +positionsign*positionstep ; 
if (position [ 3 ] <-l) position! 3 ]— 1; 
if (position [ 3 ] >1) position [ 3 ] “1 ; 
positionknob=385+(int) (position! 3] *75.0) ; 

_rectangle(_GFILLINTERI0R,positionknob,416,positionknob+l, 436) ; 
break; 
case 'n'; 

_setcolor(0) ; 

_rect angle (_GFILLINTERIOR, 310,448,461,468); 

_setcolor(bkcolor) ; 

_rectangle (_GB0RDER, 310 , 448 , 461, 468) ; 

_setcolor (knobcolor) ; 

« position ! 4 ] “position [ 4 ] +positionsign*positionstep ; 
if (position [4 ]<-l) position [4 )=-l; . 
if (position (4] >1) position (4 ]“1; 
positionknob=385+(int) (position^] *75.0) ; 

_rectangle (_GFILLINTERIOR, positionknob, 448 , positionknob+1 , 468) ; 
break; 



/********************************************************************/ 



^ OfWGINAL PAQE IS 
Or POOR QLMLfrt 


70 





/* L.A.M.S.T.F. */ 

/* (Large Angle Magnetic Suspention Test Fixture) */ 

/* Controller program for the five degrees of freedom magnetic */ 

suspension system, at NASA Langley Hampton, Virginia. */ 

/* Version 2 programmed by : */ 

/* Lucas Foster */ 

/* Old Dominion University */ 

/* Based on Version One Programmed By: */ 

/* Mehran Ghofrani */ 

/* Old Dominion University */ 

/* */ 


/*********************************************************************/ 
/include <graph.h> 

/include <stdio.h> 

/include <conio.h> 

/include <math.h> 

/include <float.h> 

/include <dos.h> 

/include <bios.h> 

/include <signal.h> 

/include <stdlib.h> 

/include <malloc.h> 


/define 
/define 
/define 
/define 
■ 'ef ine 
„ -ef ine 
/define 
/define 
/define 
/define 
/define 
/define 
/define 
/define 
/define 
/define 
/define 
/define 
/define 

/******* 

/pragma 


Address 512 
ADC_2 0x210 
DDAbase 816 
UP 72 
DOWN 80 
LEFT 75 
RIGHT 77 
ENTER 28 
ESC 27 

FI 59 . / 

60 / 


/* A/D base address 
/* Timer board Address 
/* D/A base address 


*/ 

*/ 

*/ 


A 


C*'< 




/ 


F2 

F4 

F5 

F6 

F9 

F10 


62 

63 | 

64 ) 
67 

68 


s 7 




pi 3.14159 
On 1 
Off 0 

***********************************************************^ 
intrinsic (outp, inp) 


J 


/* External Mode call (Function ) Prototype */ 
extern msc l das40 (int*, int*, int*) ; 

7" stxXX'C'f .-'4r i-t'zC 

/define Inport 512 y 

/* das-40 variables */ 
int mode,flag,params[10] ; 

. .Pointers to Allocated ram Buf's */ 
unsigned int *DMA_buf , *bufof f set ; 


7U ■£ 




yk ry&yj c 


unsigned int chan=10; 


OMQINAL PAGC * 
OF POOR QUALITY 


Ux 



/* Channel and Gain Array to use by Mode 2 */ 
int chans [5]={0, 1, 2 , 3 , 4} ; 
int gains [5]={0, 0, 0, 0, 0} ; 

; far *chans_ptr; 
int far *gains_ptr; 


j *************************************************************** 1c f 

/^unsigned int adcsr; 

-i o mtL int dec , samp 1 er ; 

int yll,xl,samplrate,diviser; 


int intnum=0x0d; /* interrupt vector number */ 

int input , k, j , num, plotcolor=0 , datcolor=15 ; 
int ii, i, l,x,y,chd,olddat[500] [5] ; 


S- 

& 




int zoom=l,ang=0; 

int positionsig n, qainupdow n , trig;^ < 
int dec, tmp[5] = {53 , 101, 149, 197, 245} ,kv, ix=25'; 
double all, a, b, c, d, e, f ,current[5] ,savdat[5] [500] ; 

double v, vl[25] ,v2[25] ,vsensor[5] , initialof f set [5]={4 . 00 , 1 . 631 , -4 . 133 , -4 . 133 , 
double of fset [5]={4 . 86, 1 . 631, -4 . 133 , -4 . 133 , 1. 631} ; J 

double gain[5]={ .5, .5, .5, .1, .08} , gainstep=. 001,position[5] , positionstep 
double mix [5] [5]={{1. 0, 0. 0,-1. 0, 0. 625, 0. 0} , 

{-0.809,0.618,-0.309,1.0,1.0}, 

{ 0.309,-1.0,0.809,0.768,0.618}, 7 

{ 0.309,1.0,0.809,0.768,-0.618}, 
{-0.809,-0.618,-0.309,1.0,-1.0}}; 


= * 1 >" 


. !L ■/ 

r ; , * 






\ double mixall[5] [5] [61] ,yawangle=0,yawanglestep=0. 5, f ilt [5] ,autoyaw=0; 

/double cosdat[800]; v “ ' 

int maxnum,yawerror limit; 
char ch, chi, ch2 , plotmode, loop; 
int rota=0; 
long backc; 




void (_interrupt _far *oldnum) (void) ; 
void _interrupt _far datin(void) ; 

/********************* ******* ************************************** ^ 


void 
void 
void 
void 
void 
void 
void 
void 
void 
void 
void 
void 
void 
void 
j void 
- void 
void 
void 
void 


process_error (void) ; 
initialize (void) ; 
oscilloscope (void) ; 
timerset (void) ; 
adcinitialize (void) ; 
plotdat (void) ; 
keyboard (void) ; 
outdat(void) ; 
gainplot (void) ; 
positionplot (void) ; 
trigplot (void) ; 
compensator (void) ; 
timersetup (void) ; 
acknowledge (void) ; 
savedat (void) ; 
getdat(void) ; 
newmixer (void) ; 
cosmak(void) ; 
shutdown (void) ; 



main() 

/ - ISR vector setup */ 


oldnum=_dos_getvect ( intnum) ; 
_disable () ; 

_dos_setvect( intnum, dat in) ; 
_enable() ; 

4f' outp (0x21,0x00) ; 
printf ("herel") ; 
outp ( 0x2 0 , 0x2 0 ) ; 
printf ( H here") ; 


/* OxOd IRQ-5 */ 

/* Disable all interrupts */ 
/* set new interrupt vector table */ 

/* send acknowledgement signal */ 

/* to the interrrupt handler */ 


_setvideomode(_VRES16COLOR) ; /*select video configuration */ 

/***** *****************************************************************^ 
cosmak(); /* calculate cosine values for every .5 deg */ 

getdat(); /* Get mixer matrix data */ 

^adcinitialize() ; /* initialize the A/D converter board */ 

printf (" Enter Sample rate Please : ") ; 

scanf ("%d", Ssamplrate) ; /* Get the sampling rate */ 

initialize () ; /* Compute The compensators parameters */ 

^7 oscilloscope () ; /* Display the Controller Screen */ 

^timersetup() ; /* Set timer to interrupt at sample-rate */ 

/**********************************************************************^ 

/* Controller loop */ 


ch=ESC ; 

while (chi !=ESC) 


{ 


r<U 


_setcolor ( 4 ; 

_rectangle(_GFILLINTERIOR, 550,420,637,477) ; 
_settextposition(28,71) ; 
printf (''RUNNING n ) ; 

_settextposition(29,71) ; 
printf ("ESC- quit") ; 
acknowledge ( ) ; 


while (ch!=ESC) 

{ 

keyboard () ; /* check for user input */ 

/* _settextposition(12, 24) ; 

printf (" %8 . 5f " , vl [ 14 ] ) ; */ 


f ilt[4]=f ilt[3 ] ; 
filt[3]=filt[2] ; 
filt[2]=filt[l] ; 
filt[l]=filt [0] ; 

I filt[0]=vl[14] ; 

autoyaw=.5*(filt[0]+filt[l] ) ; 
, _settextposition(24,72) ; 
printf ("%4. 3 f", autoyaw) ; 


/* YAW error values for */ 

/* several samples */ 

/* filter yaw error signal */ 
/* display the yaw error */ 



if (rota==l) 
{ 


/* Check for automatic yaw sensing */ 
/* option */ 


if ( autoyaw>=2 ) 

{ 


/* perform two yaw correction steps 


*/ 


> 


yawangle=yawangle+yawanglestep ; 
newmixer ( ) ; 

yawangle=yawangle+yawanglestep ; 
newmixer ( ) ; 


} 


if (autoyaw<=-2) 

{ 

yawangle=yawangle-yawanglestep ; 
newmixer ( ) ; 

yawangle=yawangle-yawanglestep ; 
newmixer ( ) ; 

> 


^ f°r ( j=0 ; j<=4 ; ++j ) 

{ 

i v=vl[2+3*j]; 


if (sampler<=2) 

_setcolor (14) ; 

_rectangle (_GFILLINTERIOR, 600,330,620,325) ; 

} 

else 

if (sampler>200) 

{ ^ 

_setcolor (1) ; 

_rectangle (_GFILLINTERIOR, 600,330,620,325) ; 


if (chd!=0) 

{ 

if (! trig || ix<474) 

{ 

if (plotmode== / a' ) plotdat(); 
if (plotmode=='s / ) 

{ 

switch (ch2) 

{ 

case 'x': if(j==0) trigplot(); 
break; 

case f y' : if(j==l) trigplot(); 
break ; 

case ' z if(j==2) trigplot(); 
break; 

case 'm': if(j==3) trigplot(); 
break ; 

case 'n': if(j==4) trigplot(); 
break ; 



/***************** *************************************** *******/ 
if(trig==0) 

if(ix>=475) ix=25;/* reset screen position to begining when at end */ 
if(ix<=475) ix++; 

/* screen horizental advance chk plotdat */ 


} 

_setcolor(2) ; 

_rectangle (_GFILLINTERIOR , 550,420,637,477); 

_settextposition(28,71) ; 

_outtext ("R-Run") ; 

_settextposition (29 , 71) ; 

_outtext ("ESC-exit") ; 
ch=' . ' ; 
chl=getch() ; 

} 

.y ******************************************************************** y 

_clearscreen(_GCLEARSCREEN) ; 

_settextposition(l, 1) ; 
printf( M The gains are:\n") ; 
for ( j=0 ; j<=4 ; ++ j ) 

printf ("Gain[%d]=%8 . 5f \n" , j,gain[ j] ) ; 

_settextposition(20, 30) ; 

/*******************************************************************/ 
_setvideomode (_DEFAULTMODE) ; 

shutdown(); /* reset vector table etc. */ 

, ************* end of main *******************************/ 

/************************************************************************/ 
/* oscilloscope: signal display screen setup */ 

void oscilloscope (void) 

{ 

int 11, j j ,gainstart,posibar; 

/* initialization of the screen clear array */ 

f or ( 11=0 ; 11<=5 ; ++11) 

{ 

for ( j j=0; j j<=500;++j j) 

olddat [ j j ] [11 ]=20; 

} 

/* display of the oscilloscope screen */ 

_clearscreen (_GCLEARSCREEN) ; 

_setcolor (13) ; 

_rectangle(_GBORDER, 0, 0, 639, 479) ; 

_setcolor (plotcolor) ; 

_rectangle (_GFILLINTERIOR, 20,5,480,290) ; 

_settextposition(4, 2) ; 
printf ("X") ; 

_settextposition(7, 2) ; 
printf ("Y") ; 

_settextposition (10,2) ; 
printf ("Z"); 

_settextposition (13,2) ; 

J printf ("M M ) ; 

_settextposition (16,2) ; 
printf ("N") ; 

_setcolor(7) ; 

for (11=52 ; 11<=244 ; 11=11+48) 



{ 


_moveto (19,11) ; 

_lineto (24 , 11) ; 

_moveto (476 , 11) ; 

_lineto (484 , 11) ; 

> 

/******************************************************/ 

/* Gain control knobs Display */ 

_setcolor (12) ; 

_rectangle (_GBORDER, 2,300,480,478) ; 

_settextposition (20,2) ; 

_settextcolor ( 14 ) ; 

_outtext ("Feedback gain control"); 

_settextposition(20, 40) ; 

_outtext ("Position Control"); 
setcolor (5) ; 

“T • _ 

D3=0; 

for (11=21; 11<=29 ; 11=11+2) /* lableing the gain knobs */ 

{ 

_settextposition(ll, 27) ; 
printf ( "%4 . 3f " ,gain[ j j ] ) ; 

jj++; 

_settextposition(ll,4) ; 
printf ("0") ; 

> 

for (11=319 ; 11<=447 ; 11=11+32 ) /* gain control bar display */ 

_rectangle (_GBORDER, 42,11,196, 11+22) ; 

j j=o; 

for (11=320 ; 11<=448 ; 11=11+32 ) /* Presetting gain display */ 

{ /* on the screen */ 

gainstart=(int) (gain[ j j ] *80) +40; 

_setcolor (6) ; 

_rectangle (_GFILLINTERIOR, 40,11, gainstart+3 , 11+20) ; 

++jj; 

} 

/* display of position control knobs */ 


_setcolor (4) ; 

for (11=320; 11<=448 ; 11=11+32) /* position control bar display */ 

_rectangle(_GBORDER, 310, 11, 460, 11+20) ; 
setcolor (10) ; 

Jj=o; 

for (11=320 ;11<=448; 11=11+32) 


> 


posibar=385+(int) (positionf j j ] *75) ; 

_r ectangle (_GFILLINTERIOR , pos ibar , 11 , posibar+1 , 1 1+2 0 ) ; 

++jj; 


/** r*************************************^ 

/* labling of gain knob display */ 
_settextposition(21, 2) ; 

_outtext ("X") ; 

«— _settextposition(23 , 2) ; 
^_outtext("Y") ; 
v ~_settextposition(25, 2) ; 
y _outtext ( " Z " ) ; 

_settextpos i t ion (27,2) ; 

_outtext ("M") ; 
_settextposition(29,2) ; 
outtext("N") ; 


/* x or axial */ 

/* y or side */ 

/* z or vertical */ 

/* M - pitch movement */ 
/* N - yaw movement */ 



/************************************ y 

/* Display of options */ 

_settextposition (2,62) ; 
printf ("E- enable plot"); 
_settextposition (3,62) ; 
printf("D- disable plot"); 
_settextposition(5, 62) ; 
printf ("Select Channel"); 
_settextposition (6,62) ; 
printf (" Press ") ; 
_settextposition(7, 62) ; 
printf (" X Y Z X M N"); 

_settextposition (9,62) ; 
printf ("S- single plot") ; 
_settextposition (10,62) ; 
printf ("A - all plots"); 
_settextposition(ll, 62) ; 
printf ("T - triggered " ) ; 
_settextposition(12, 62) ; 
printf ("C - continuous"); 
_settextposition (13,62) ; 
printf ("FI- unzoom plot"); 
_settextposition (14,62) ; 
printf ("F2- zoom plot"); 
_settextposition(15, 62) ; 
printf ("F4- Save data") ; 
settextposition ( 16 ,62),^ 

printf ( " F5- - Yaw " ) ; * 

_settextposition(17, 62) ; 
printf ("F6- + Yaw ") ; 
_settextposition(18, 62) ; 
printf ("F9- AutoYaw off") ; 
_sette^tcolor ( 4 ) ; 
_settextposition(18,75) ; 
_outtext (^'off " ) ; 

_settextpositipn(19, 62) ; 
printf ("F10- AutoYaw on") ; 

_settextposition(24>€2) ; 

^ printf ("Yaw Error:"); / 
_settextposition(22 , 62) ; 

7 printf ("Yaw^Angle: ") ; 


} 

/***********************************************************************/ 
/* keyboard: User interaction through keyboard */ 

void keyboard (void) 

{ 

char chin; 
if (kbhit () !=0) 

{ 

chin=getch ( ) ; 

j if ( ! chin) chin=getch ( ) ; */ 
switch (chin) 

{ 

case 'X':case 'x': ch2='x'; 

_setcolor(8) ; 



_rectangle (_GFILLINTERIOR, 35,320,39,478); 
_setcolor (12) ; 

_rectangle (_GFILLINTERIOR, 35,320,39,340); 
if (plotmode==' s' ) 

{ 

_setcolor (plotcolor) ; 

_rectangle(_GFILLINTERIOR, 20, 5, 480, 290) ; 

} 

break ; 

case 'Y' tease 'y': ch2='y'; 

_setcolor (8) ; 

_r ectangle (_GFILLINTERIOR ,35,320,39,478) ; 
_setcolor (12) ; 

_rectangle(_GFILLINTERIOR, 35,352,39,372) ; 
i f ( plotmode— 's') 

{ 

_setcolor (plotcolor) ; 

_rectangle (_GFILLINTERIOR, 20,5,480,290) ; 

} 

break; 

case 'Z':case 'z': ch2='z'; 

_setcolor (8) ; 

_rectangle(_GFILLINTERIOR, 35,320,39,478) ; 
_setcolor (12) ; 

_rectangle (_GFILLINTERIOR, 35,384,39,404); 
if (plotmode=='s' ) 

{ 

_setcolor (plotcolor) ; 

_r ectangle (_GFILLINTERIOR ,20,5,480,290) ; 

> 

break ; 

case 'M' :case 'm' : ch2='m'; 

_setcolor(8) ; 

_r ectangle (_GFILLINTERIOR, 35,320,39,478); 
_setcolor (12) ; 

_r ectangle (_GFILLINTERIOR, 35,416,39,436); 
if (plotmode=='s' ) 

{ 

_setcolor (plotcolor) ; 

_rectangle (_GFILLINTERIOR ,20,5,480,290); 

} 

break; 

case 'N':case 'n': ch2='n'; 

_setcolor (8) ; 

_r ect ang le (_GFILLINTERIOR ,35,320,39,478); 
_setcolor (12) ; 

_rectangle(_GFILLINTERIOR, 35, 448, 39,468) ; 
if (plotmode=='s' ) 

{ 

_setcolor (plotcolor) ; 

_r ectangle (_GFILLINTERIOR ,20,5,480,290); 

> 

break; 

case 'S': case 's': plotmode='s' ; 

_setcolor (plotcolor) ; 

_r ectangle (_GFILLINTERIOR, 20,5,480,290); 
break; 

case 'A': case 'a': plotmode='a' ; 

break ; 

case 'T': case 't': trig=l; 



break ; 

case 'c': trig=0; 
break ; 


case 7 C 7 : 



case 0: 

chin=getch() ; 
switch (chin) 

{ 

case RIGHT: gainupdown=l ; 
gainplot ( ) ; 
break; 

case LEFT: gainupdown=-l; 
gainplot ( ) ; 
break; 

case UP: posit ionsign=l; 

positionplot ( ) ; 
break ; 

case DOWN: posit ionsign=-l; 
positionplot () ; 
break ; 

case FI: if(zoom>l) zoom=zoom-l; 

_settextposition(l, 60) ; 
printf ( "%i ", zoom) ; 
break; 

case F2 : if(zoom<10) zoom=zoom+l; 

_settextposition(l, 60) ; 
printf ( "%i " , zoom) ; 
break; 

case F4: savedat(); /* Save step responses if need 

break ; 

F5: yawangle=yawangle-yawanglestep; 

newmixer ( ) ; 
break; 

F6: yawangle=yawangle+yawanglestep; 

newmixer () ; x 

break; / 

F9 : rota=0 ; / 

_settextcolor (8) ; 

_settextposition(19,75) ; 

_outtext ("on" ) ; 

_settextcolor (4) ; 

_settextposition(18,75) ; 

louttextrcff") ; 

break; 

F10: rota=l; 

_settextcolor (8) ; 

_settextposition(18,75) ; 

_outtext ("off ") ; 

■/_settextcolor (4) ; 

/ _settextposition(19,75) ; 

_outtext ("on") ; 

■- break; 


case 


case 
\ case 


case 


> 

break ; 

case 'Encase x e': chd=l; 

break ; 

case 7 D 7 : case 7 d 7 : chd=0; 

break; 

case ESC: ch=ESC; break; 

> 


PAQf n 

of poor mmjw 



> 

chin =' . ' ; 


V 


} 

/ * * ******************************Tln)lr****************************************y 

initialize: setting the parameters of the dual phase advance compensator */ 
void initialize (void) 

{ 

double dt,T,n,Tnd; 

int breakfreq; I ,> 

printf ("\n Enter Compensator's Break frequency (170hz) : ") ; t ./- f 

scanf ("%d" , Sbreakfreq) ; /* Get the break frequency */ 

dt=l/ ( (double) samplrate) ; /* period of the sampling * 

T=l/ (2 . 0*pi* (double) (breakfreq) ) ; /* 1/ break frequency */ 

printf("\n \n T= %9.6f\n",T) ; 

n=10.0; /* ratio of lead to lag break frequency */ 

all=l/((dt*dt)+4*T*dt+4*(T*T) ) ; ' .• • • 1 

b=(dt*dt) +4*n*dt*T+4*n*n*T*T; 

c=2*dt*dt-8*n*n*T*T; 

d=(dt*dt) -4*n*dt*T+4*n*n*T*T; 

e=2 *dt*dt-8 *T*T ; 

f = (dt*dt) -4 *dt*T+4 *T*T ; 

printf ("\n") ; 

printf ("\n") ; 

printf ("Xn" ) ; 

printf ("The compensator parameters are:\n") ; 

printf ("a=%9 . 6f\n" , all) ; 

printf ("b=%9.6f\n",b) ; 

printf (»c=%9.6f\n",c) ; 

printf ("d=%9.6f\n",d) ; 

printf ("e=%9.6f\n",e) ; 

printf (»f=%9.6f\n",f) ; 

getch() ; 


} 

/**********************************************************************/ 
/* Plotdat: plot of signals */ 

void plotdat (void) 

{ 

kv=4+( j+1) *48-(int) (v*2*zoom) ; 
if (kv>=290) kv=290; 

_setcolor (plotcolor) ; 

_setpixel(ix,olddat[ix] [j+1] ) ; 

_setcolor (datcolor) ; 

_setpixel (ix, kv) ; 
olddat[ix] [ j+l]=kv; 

> 

/**********************************************************************/ 
/* trigplot: plot of signals */ 

void trigplot (void) 

{ int plotcenter=148 ; 

kv=plotcenter-(int) (v*10*zoom) ; 

J if (kv>=290) kv=290 ; 

_setcolor (plotcolor) ; 

_setpixel(ix,olddat[ix] [j+1] ) ; 

_setcolor (datcolor) ; 

_setpixel (ix,kv) ; 


GfllOSNAl PAGC m 
Of POOR QUALITY 



olddat[ix] [ j+l]=kv; 

/* tmp [ j ] =kv ; */ 

} 

/ 4c * ******************************************************************** 

gainplot: to display gain on each degree of freedom graphically */ 
void gainplot (void) 

{ 

int ga inknob, knobcolor; 
switch (ch2) 

{ 

case 'x': 

if ( (gain[0]>=0) && (gain[0]<=2) ) 

{ 

knobcolor=3* (gainupdown+1) ; 

_setcolor (knobcolor) ; 
gainknob=40+(int) (gain[0] *80. 0) ; 

_rectangle (_GFILLINTERIOR, ga inknob, 320, gainknob+3 ,340) ; 
gain [ 0 ] =gain [ 0 ] +gainupdown*gainstep; 
_settextposition(21, 27) ; 
printf ("%4 . 3f " ,gain[0] ) ; 


else 

if (gain[0]<0) gain[0]=0; 
if (gain[0] >2) gain[0]=2; 
break ; 
case 'y ' : 

if ( (gain[ 1] >=0) && (gain[ 1] <=2) ) 

{ 

■j _setcolor (knobcolor) ; 

gainknob=40+(int) (gain [1] *80. 0) ; 

_rectangle (_GFILLINTERIOR, gainknob, 352 , gainknob+3 , 372 ) ; 
gain [ 1 ] =gain [ 1 ) +gainupdown*gainstep ; 
_settextposition(23,27) ; 
printf ( M %4 . 3f " ,gain[l] ) ; 

} 

else 

if (gain[l]<0) gain[l]=0; 
if (gain( 1] >2) gain[l]=2; 

break ; 
case ' z ' : 

if ( (gain[2]>=0) && (gain[2]<=2) ) 

{ 

knobcolor=3* (gainupdown+1) ; 

_setcolor (knobcolor) ; 
gainknob=40+(int) (gain[2]*80.0) ; 

_rectangle (_GFILLINTERIOR, gainknob, 384 , gainknob+3 ,404) 
gain [ 2 ] =gain [ 2 ] +gainupdown*gainstep ; 
_settextposition(25,27) ; 
printf ("%4 . 3f" , gain[2 ] ) ; 

} 

else 

if (gain[2]<0) gain[2]=0; 
if (gain[2]>2) gain[2]=2; 

break ; 

J case 'm' : 

if ( (gain[3 ]>=0) && (gain[3]<=2) ) 

{ 

knobcolor=3* (gainupdown+1) ; 

_setcolor (knobcolor) ; 



gainknob=40+ (int) (gain[3]*80.0) ; 

_rectangle (_GFILLINTERIOR, gainknob, 4 16 , gainknob+3 ,436); 
gain [ 3 ] =gain [ 3 ] +gainupdown*ga instep; 

_settextposition(27 , 27) ; 
printf ("%4 . 3f" ,gain[3] ) ; 

} ' 
else 

if (gain[3]<0) gain[3]=0; 
if (gain [3 ] >2) gain[3]=2; 

break ; 
case 'n': 

if ( (gain[4]>=0) && (gain[4]<=2) ) 

{ 

knobcolor=3* (gainupdown+1) ; 

_setcolor (knobcolor) ; 
gainknob=40+(int) (gain[4 ] *80 . 0) ; 

_rectangle (_GFILLINTERIOR, gainknob, 448 , gainknob+3 , 468) ; 
gain [ 4 ] =gain [ 4 ] +gainupdown*gainstep ; 

_settextposition (29 , 27) ; 
printf ("%4.3f",gain[4]) ; 

} 

else 

if (gain[4]<0) gain[4]=0; 
if (gain[4]>2) gain[4]=2; 

break ; 


} 

} . 

/ \<******************* *************** *********************************/ 
/* positionplot : control and display of position knobs */ 

void positionplot (void) 

{ 

int knobcolor , posit ionknob , bkcolor ; 
knobcolor=10 ; 
bkcolor=4 ; 
if (trig==l) 
ix=25; 

sampler=0; /* counter for collecting data in ISR */ 

switch (ch2) 

{ 


case 'x': 

_setcolor(0) ; 

_rectangle(_GFILLINTERIOR, 310, 320,461, 340) ; 

_setcolor (bkcolor) ; 

_r ectangle (_GBORDER ,310,320,461,340); 

_setcolor (knobcolor) ; 

position [ 0] =position[ 0 ] +positionsign*positionstep; 
if (position[0]<-l) position [0]=-l; 
if (position[0]>l) position[0]=l; 
positionknob=385+ (int) (position[0]*75.0) ; 

_rectangle (_GFILLINTERIOR, positionknob, 320, positionknob+1 ,340) 
) break ; 

case 'y' : 

_setcolor (0) ; 

_rectangle (_GFILLINTERIOR, 310, 352 ,461,372); 
setcolor (bkcolor) ; 



_r ect angle (_GBORDER ,310,352,461,372); 

_setcolor (knobcolor) ; 

position [ 1 ] =position [ 1 ] +positionsign*positionstep ; 
if (position[ 1]<-1) position[l]=-l; 
if (positionf 1] >1) position[l]=l; 
positionknob=385+ ( int) (position[l]*75.0) ; 

_rectangle (_GFILLINTERIOR, positionknob, 352 , positionknob+1, 372) ; 
break ; 
case ' z' : 

_setcolor ( 0) ; 

_rectangle (_GFILLINTERIOR, 310,384,461,404); 

_setcolor (bkcolor) ; 

_rectangle (_GBORDER ,310,384,461,404); 

_setcolor (knobcolor) ; 

position [ 2 ] =position [ 2 ] +positionsign*posit ionstep ; 
if (position[2]<-l) position[2]=-l; 
if (position[2] >1) position[2]=l; 
positionknob=385+(int) (position(2]*75.0) ; 

_rectangle (_GFILLINTERIOR, positionknob, 384 , positionknob+1 , 404 ) ; 
break; 
case 'm' : 

_setcolor(0) ; 

_rectangle(_GFILLINTERIOR, 310,416,461,436) ; 

_setcolor (bkcolor ) ; 

_rectangle(_GBORDER, 310,416,461,436) ; 

_setcolor (knobcolor) ; 

position [ 3 ] =position [ 3 ] +positionsign*positionstep; 
if (position[3]<-l) position[3]=-l; 
if (position[3]>l) position[3]=l; 
positionknob=385+ (int) (position[3 ] *75 . 0) ; 
_rectangle(_GFILLINTERIOR, positionknob, 416, positionknob+1, 436) ; 
break ; 
case 'n': 

_setcolor(0) ; 

_rectangle (_GFILLINTERIOR, 310/448,461,468) ; 

_setcolor (bkcolor) ; 

_r ectangle (_GB0RDER ,310,448,461,468); 

_setcolor (knobcolor) ; 

position ( 4 ] =position [ 4 ] +posit ionsign*positionstep ; 
if (position[4]<-l) position[4 ]=-l; 
if (position[4)>l) position[4]=l; 
positionknob=385+ (int) (position[4]*75.0) ; 

_rectangle(_GFILLINTERIOR, positionknob, 448, positionknob+1, 468) ; 
break; 


} 

} 

/********************************************************************/ 

/* timersetup : sets up the sample rate clock on the second ADC for interrupt */ 

void timersetup (void) 

{ 

int rate; 

/* Timer ic AM9513 setting */ 


^ outp(ADC_2+l,0xdf) ; /* disarms counters */ 


SL 


outp (ADC_2+1 , 23 ) ; /* sets next outp to the 




master register*/ 


} 


•^r outp (ADC_2 , OxcO) ; /* master rgister low byte */ 

outp (ADC_2 , 0x41) ; /* master register high byte */ 


v: outp (ADC_2+1, 0x01) ; /* sets next outp to 
^ the counter 1 register */ 


V outp (ADC_2 , 0x22) ; /* sets wave form and base frequency */ 

y. outp (ADC_2 , 0x0c) ; 

rate=(int) (31250/samplrate) ; 


^ outp (ADC_2+1, 0x09) ; 
outp (ADC_2 , rate) ; 


^ outp (ADC_2+1, 0x61) ; 


/* sets next outp to the load register */ 
/* it will count down from rate 
and set off an interrupt */ 


/* load and arm */ 


/********************************************************************/ 
/* savedat() saves data to file */ 
void savedat (void) 

{ 

char fname[12]; 
int i, j ; 

FILE *fp; 

_settextposition(25, 64) ; 
printf ("Save data? y/n\n"); 
ch=getch ( ) ; 

if((ch== / Y / ) || ( ch== ' y ' ) ) 

{ 

_settextposition(25, 64) ; 
printf ("Enter File Name"); 

_settextposition(26, 64) ; 

scanf ("%s" , &fname) ; 

if ( ( f p=f open ( f name , "w+" ) ) ! =NULL) 

{ 

f printf (fp, "stepdat=[ \n") ; 

for ( i=l ; i<=200 ; i++) 

{ 

for ( j=0; j<=4; j++) 

fprintf (fp, "%le " , savdat [ j ] [i] ) ; 

f printf ( f p , " \n" ) ; 

} 

fprintf (fp, "] ;\n") ; 
fprintf (fp, "gains=[\n") ; 
for ( i=0 ; i<=4 ; i++) 

fprintf (fp, "%le \n",gain[i] ) ; /* Save the gains */ 

fprintf ( f p , " ] ; \n" ) ; 
fclose(fp) ; 

> 

else 

j printf ("Oops file error"); 

} 

_settextposition(25, 64) ; 

printf (" "); 

_settextposition(26, 64) ; 



printf ( " 


ii 


); 


> 


^tt**************************************************************************/ 

/* cosmak : calculates cos values for angles 0..360 */ 

void cosmak (void) 

{ int i , number ; 

/ double radang ; 

/ 

\ xnaxnum=(int) (360. O/yawanglestep) ; 
j yawangle=0 ; 

/ for (i=0;i<=maxnum;i++) 

' ^ { 

1 radang=(yawangle/180. 0) *pi; 

cosdat[i]=cos (radang) ; 
yawangle=yawangle+yawanglestep ; 

} 

yawangle=0; 

} 

^***************************************************************************/ 
/* newmixer : calculates new mixing matrix and current distribution */ 

void newmixer (void) 

{ int i , j , k , nextone , indexl , index2 , index3 , index4 , index5 , seventy2 ; 
int angindex; 

double angstep=6, yawangletemp; 
double mixtemp [ 5 ] [ 5 ] , interpol ; 


angindex=(int) (yawangle/yawanglestep) ; /* Index of the yaw angle */ 

v;-fseventy2= (int) (72 . O/yawanglestep) ; /* Index of 72 deg based on*/ 

nextone=l; /* the yaw step chosen 

if (angindexcO) 

{ 

angindex=maxnum+angindex ; 
nextone=-l ; 


} 

indexl=angindex; /* 

index2=abs(seventy2-angindex) ; 
index3=abs(2*seventy2-angindex) ; 
index4=abs ( 3 * seventy 2 -angindex) ; 
index5=abs (4*seventy2-angindex) ; 


determination of cosine matrix */ 

C /* index for calculating the zero 
w* position current. Every index* 
'Ll* is 72 degrees apart from its 
/* adjasent neighbor. 


if (indexl>maxnum) /* 

index 1= index 1-maxnum ; 
if (index2>=maxnum) /* 

index2=index2-maxnum; 
if (index3>=maxnum) /* 

index3=index3-maxnum; 
if ( index4>=maxnum) 

index4=index4-maxnum; 
if ( index5>=maxnum) 

index5=index5-maxnum ; 


The five if statements rap around */ 
the indceis to the begining after */ 
360 degrees rotation */ 


J offset[0]=initialoffset [0] *cosdat[ indexl] ; 
offset[l]=initialof fset [0] *cosdat[index2] ; 
offset [ 2 ] =initialof f set [ 0 ] *cosdat [ index3 ] ; 
offset[3]=initialoffset[0] *cosdat[index4] ; 
offset [ 4 ] =initialof f set ( 0 ] *cosdat [ index5 ] ; 


/* Levitation current calculatio 
/* using the cosine array, which 
/* selected depending on the ang 
/* of the model. Initialof fset [ 
/* is the highest steady current 



yawangletemp=fabs (yawangle) ; 


if (yawangle>=360) /* Adjustment for angles>360 */ 

yawangletemp=yawangle-360; 

ang=(int) (yawangletemp/angstep) ; /* Determination of number of steps */ 

nextone=l ; 

/* Determination of the interpolating coefficent */ 

interpol=( (yawangletemp) - (double) ( (ang) *angstep) ) /angstep; 

if (yawanglecO) 

{ 

nextone=-l; 

ang=60-ang; 

} 

/* Interpolation between the mixing matrices */ 

for ( i=0 ; i<=4 ; i++) 

{ 

for ( j=0; j<=4; j++) 

{ 

mix[i] [ j ]=interpol* (mixall[i] [j] [ang+nextone] 
-mixall[i] [ j ] [ang] ) 

+mixall[i] [ j] [ang] ; 

> 

> 

_settextposition(22,72) ; 
printf ("%5 . 2f" , yawangle) ; 


/***************************************************************************! 
/* Intrrupt service routine */ 

/* datin() obtains data from ADC in the array */ 

void _interrupt _far datin(void) 

U 

L unsigned int yll,Outport; 
int k,df; 
for (k=0 ;k<=4 ;k++) 

{ 

mode = 7 ; 
flag =0; 
params[0] = k; 
paramsfl] = 0; 



Vo/-£ 


_enable() 


> 


-^mscl_das40 (&mode, params, &flag) ; 
if (flag 1= 0) process_error () ; 
y=params [ 0 ] ; 

> vsensor [k]=(float) (y/409.5); 

"T~ 




/**★**********★***************★******************************************/ 

/* de coupler */ -TJJ' 

vl[2]=vsensor[l]-5; \ J 1 'Jj 

vl[5] = ( (vsensor [3]+vsensor [4] -10) *-0. 5) ; I / a/T^i ^ </" 

vl[8) = ( (vsensor [0]+vsensor [2] -10) *0.5) ; / •/" U 


vl[ll]=(vsensor [0]-vsensor [2] ) ; 
vl [ 14 ] = (vsensor [ 3 ] -vsensor [ 4 ] ) ; 


Jr" j t#** ' 


jr 


i 



if (sampler <=2 00) 

{ 

for (df=0 ;df<=4 ;df++) 

savdat[df ] [sampler]=vl[2+df*3] ; 

sampler++; 

} 

/* compensator: dual phase advance using backward difference method */ 
/* vl [2+3*l]=vl [2+3*1] +position[ 1] *4 ; */ 


for ( 1=0 ; 1<=4 ; 1++) 

{ 

v2[ 2+3*1 ]=all* (gain[l]*(b* (vl[ 2+3*1] +position[l] ) 
+c*vl[l+3*l]+d*vl[3*l] ) - 

e*v2 [ 1+3*1 ]-f*v2[ 3*1]) ; 


> 

/* current formation */ 
for (1=0;1<=4 ; 1++) 

{ 

current [l]=v2 [2] *mix[l] [0]+v2 [5]*mix[l] [l]+v2 [8] *mix[l] [2]+ 
v2 [11] *mix[ 1] [3]+v2[14]*mix[l] [4]+offset[l] ; 

/* Data outputs to the five D/As */ 
if (fabs (current [1] ) <10.0) 

yll= (unsigned int) (204,75* (current [ 1] +10 . 0) ) ; 
0utport=DDAbase+l*2 ; 


- Vo //_r 


disable () ; 


c/< 




asm 




’JLs 


} 


push ax; 
push dx; 
mov dx,0utport; 
mov ax,yll; 
out dx,ax; 
pop dx; 
pop ax; 


L <*~ PAC^_ 


*->AC U<c- 


} 


enable ( ) ; 

vl[3*l]=vl[l+3*l] ; 
vl [ 1+3*1] =vl [ 2+3*1 ] ; 
V2 [3*1] =V2 [ 1+3 * 1 ] ; 
v2 [ 1+3*1 ]=v2[ 2+3*1] ; 


disable () ; 


asm 


push ax 
push dx 


*• > 



mov dx,ADC_2 

; Load the ADC board address 


add dx,6 

; point to adc high byte register 

/ 

or al,al 

; clear al 

s 

in al,dx 

; output command 

) 

mov dx , 2 Oh 

; load 8259 address ( 


mov al,20h 

; set normal priority, EOI=l, (65h) 


out dx,al 

; output command / 


lb 




V 



pop dx 
pop ax 


} 

_enable() ; 


■! / 




} 

/* */ 

^**************************************************************************/ 
void adcinitialize (void) 

{ 

/* DAS-40 Initialization */ 
system("d40") ; 

mode=0; /\>. 

f lag=0; , / , 

params[0]=0; /t/- 

mscl_das40 (&mode,params, &flag) ; ^ (V A 1 " 

if (flag !=0) process_error() ; 
clearscreen( GCLEARSCREEN) ; 


_ rv 




} 

^**********************************************************************^ 
void process_error ( ) 

{ 

putch(7) ; putch(7); 

printf (••**** Error %u detected in mode %u ", flag & Oxff, ((flag & Oxf 

exit(l) ; 

} 

/**********************************************************************/ 
void acknowledge (void) 


• I 

_asm 

{ 



V 

} 

> 


push ax 
push dx 

mov 

dx , ADC_2 

add 

dx, 6 

or al,al 
in al,dx 

mov 

dx, OaOh 

mov 

al, 20h 

out 

dx, al 

mov 

dx, 2 Oh 

mov 

al , 20h 

out 

dx, al 

pop 

dx 

pop 

ax 


Load the ADC board address 
point to adc high byte register 
clear al 
output command 


load second 8259 address 

set normal priority, E0I=1, (65h) 

output command 

; load 8259 address 

; set normal priority, EOI=l, (65h) 
; output command 


^J:* ******* ******** ************ **************************************** j 
void shutdown (void) 

{ 

int dtoa; 

_dos_setvect (intnum,oldnum) ; /* reset interrupt vector table */ 



f or ( dtoa=0 ; dtoa<=4 ; ++dtoa ) 

{ 

outp(DDAbase+dtoa*2,0) ; /* 0000000 for low byte at zero */ 

outp (DDAbase+dtoa*2+l, 8) ; /* 1000 for high byteat zero */ 

?^<&utp(ADC_2+l, Oxdf ) ; /* shut down interrupt counter */ 

? system ("d40 u M ) ; 


> 

/****************************************************************^ 
/* getdat() loads mixing matrix data */ 

void getdat(void) 

{ 

char fname[12]; 
int i,j,k,dim; 

FILE *fp; 

_settextposition (14 , 25) ; 
printf ("Enter Data File Name"); 

_settextposition(15, 30) ; 

scanf ("%s" , &fname) ; 

if ( ( f p=f open (f name, "r+") ) !=NULL) 

{ 

printf ("Please wait for data to load\n"); 
f scanf (fp, "%d" , &dim) ; 

printf (" Number of matrices are: %d \n ",dim); 

f or ( k=0 ; k<=d im- 1 ; k++ ) 

{ 

f or ( i=0 ; i<=4 ; i++) 

{ 

for ( j=0; j<=4; j++) 

fscanf (fp, "%lf ", &mixall[i] [j] [k]) ; 

> 

printf (" Data was successfully loaded, hit Enter"); 
getch() ; 
fclose(fp) ; 

> 

else 

fprintf (stderr, "Oops file error"); 
































From Bohr and Hyat's stored magnetic energy theory, the force of 
attraction for one electromagnet is. 


1 2 

F := B • A = (1/3) m g 

2* H T 

o 


T 


F := 


2-M 


/x -N- (i + I) 
o 


'■ [ 9 o + y ] . 


A 

T 

o 

N- i 

M -N-I ' 
o o 

1 

8 M 

r g 

+ yl 

[g + yl 

o 

1 

LL © 

J 

L ° JJ 


g g + y 

o 

Expanding the squared term 


A 

T 

[V Ni ] 2 

2 2 

2-m -N -I -i 
o o 

["o MI o] 2 

8/1 

T 

2 

2 

2 

o 

. g 

g 

g 


o 



Collecting similiar terms 


A • n -N 

T O [ 2 2 

i + 2- i- 1 + I 

2 O o 

8-g 


2 2 2 

Since, g := g + y then, g :=g + 2 g y + y 

o o o 


2 f 2 2 

A -m -N • i +2 i I +1 
To o o 


2 2 
8- y + 2- g ■ y + g 
o o 


A := A + A 
T 1 2 


-> A := A = A > A := 2-A 

12 T 


Resulting F is the total force acting on the rim. 


2 [ 2 2 
A-m -N • i + 2- i- 1 + I 

o o o 


2 2 
y + 2 g *y + g 
o o 


= (cl/ 4) (c2) 


C-Z, 



From Taylor's Series Expansion at the equilibrium point (y , i ), 


F(y,i) 


F(y,i) 



+ [y - y ,i 



FGradient 




S F 
Sy 


'6 

A' 

• (C2) + 

'6 

(c2) 

. 

Cl 

sy 

4. 

J 

sy 


.4 _ 


S F 
Sy 



ell 


2 2 
y + 2-y-g + g 

o o 


4 


2 2 ' 
y + 2-y-g + y 

o 


4 3 2 2 3 4 

:= y + 4-y -g + 6-y *g + 4-y-g + g 

o o o o 


1 

SY 

— 

y + g ' 
o_ 

-cl 

sy 

i 

2- 

’ 4 3 

y + 4- y • g + 6- 
o 

2 2 2 3 4' 

y *g + 4*y-g + 4-y-g + g 

o o o o_ 




At equilibrium, i := 0 & y := 0 


i 

2 2 

-A- /i • N - I 
S F o o 

___ m — - 

* 

Sy 3 

2-g 


So then. 


JF 1 [i 1 [5 

— := — — (cl) • c2 + — (c2) -cl 

$i 4 J L^i 


2 

A- fi • N 

S F 1 o 



y + 2-yg + g 


o o 


At equilibrium. 


i := 0 & y := 0 



Forothe V-I relationship of the actuator, 

first consider Kirchoff's voltage law for the bearing system, 


d 

V := R- i + — (L- i) 

dt 

di] dl dy 

V := R- i + L- — + i 

dtj dy dt 


then by seperating the volatage, current and gap distance into the 
biased components and contolled components. 


V:=V+v i:=I+i y:=g+y 

b b o 



"So then. 


V + V := R- [I + i 

di 

1 + L + i- 

dl dy 

+ I • 

‘dl dy 

b lb 

i 

J dt 

dy dt 

b 

dy dt 


When y : = g 

o 

then assuming 

V := R- 1 

b b i = 0 & y s o 


o 


therefore. 


dL dy 
dy dt 


0 


And, since 


V(t) 


R-i(t) 


di(t) 

+ L* 

dt 


dL 

dy 


2 

2* N • A- fi • g 
o o 



By taking the Laplace transform. 


when rearanging terms. 


V(s) :=R I(s) + L s-I(s) 
V(s) 

I(s) := 


o 


R + L- s 



So then, from Newton's 2nd Law, 


2 2 2 
2 A- • N • I -A*/i -N - I 

d • y o o o o 

m : i + y 


= c3 i 


dt 


2-g 


2- g 


m s • Y (s) := B-Y(s) + A-I(s) 


recall. 


I(s) := 


2 2 

A-M -N - I 
o o 


Y (s) 


m- s + 


2-g 


:= V (s) 


L- s + R 


A- /X N - I 
o o 


2-g 


J 


o 


+ c4 y 


V(s) 

R. 4* L‘ s 



o 


2 

A/X -N *1 
o o 


2 

2- g • (L- S + R) 
Y(s) O 


V(S) 


2 2 

A-M -N - I 
2 o 

m- s + 


2-g 


dividing the ' 


2 

A - H • N ‘X 
o o 


Y(s) 

V(s) 


2 

2-g -m- 
o 


s + 


R 

L 


2 


s 


2 2 

A* H -N - I 
O 

+ 


3 

2- g • m 
o 




' out 



y(s r 
-- • — 

V(s) 

[s 


Therefore, 


2 

A- H -N - I 
o o 


2 

2- g • m 
o 


2 2 

A-H • N - I 
2 o 

s + 

3 

2- g • m 
o 


Y(s) c5 

v (s) * r 2 

(s + c6) • [s + 


R 

L. 



The variables defined are 



-7 

H := 4- ?r- 10 
0 


N := 1619 


I := 0.57 
0 


g := 0.0075946 
0 


21.59099 
m := 


A = 0.007 


-6 

H = 1.25710 
0 


m = 7.197 


L 


2 

N A/i 

o ri 


2- g 12J 
0 


L = 0.712 


R 


8 



Derivation of the group constants: 


c5 


o 


2 

A- /X • N - I 
0 0 


2 

2- g • in 
0 


C6 


R 


L 


C5 = 14.851 


C6 = 11.235 


C7 


2 2 

A- /X • N • I 
0 


3 

2- g • m 
0 


3 

C7 = 1.115-10 


Therefore the plant dynamics equation or the open loop transfer function is: 



