AD-A253 325 Technical Report 

iiiiiiiiiiiiiiiiiiii 


/ 

♦ 


♦ 



♦ 


♦ 


Carnegie-Mellon University 

Software Engineering Institute 


DTIC 

ittECTF g 

VIA. 3019921 


-feCTF 

.30 m JJ 


Ada Validation Tests for 
Rate Monotonic Scheduling 
Algorithms 


♦ 


Keith A. Kohout 
Kent Meyer 
John B. Goodenough 




February 1992 


♦ 


, / 

♦ 


♦I 


Approved for pnbBe niw 
DfcWri bn ttcn OnBmhad 


♦ 


♦ 


* 


♦ 


♦ 


♦ 


♦ 

5 ? 


♦ 


♦ 


92-20298 








The following statement o t assurance >s more than a statement required to comply wlh the ’ederai law Th.s ^ a sincere statement by the un.^ers-ty to assure that ail 
people are included in fop diversity which makes Carnegie Mellon an exciting place Carnegie Mellon w-;hes to nciude people *• foout regard t? - mce -ok ;r r>at peat 
origin se* handicap, religion, creed, ancestry belief age veteran status or sexual orientation 

Carnegie Mellon University (foes not discriminate and Carnegie Mellon University s required not to (tscrm-nate n a-i'mssions and employment »« . the b*s>s o' race 
color national origin sex or handicap in violation of Title VI of the Civil Rights Act of 1964 Title IX o< (he E d>jcat<gnai Amendments of 197? and Sen ..in 504 o' ft *> 
Rehabilitation Act of 1973 or other federal, state, or local laws or executive orders In add-on Carnegie Meiirm dons not d;sr,r female in adm ssmns and •‘- vi i>l(.Y V p"nr., or 
the basis of religion, creed ancestry belief, age, veteran status or sexual orientation >n violation of any iede*a' state or loc.T <aws or e*ecuhve orders tnqu-nes conceal 
mg application of this policy should be directed to the Provost. Carnegie Mellon University 5000 Fortes Avenue. P-ttsburgn PA teiopf f ne <4i;\. 6f,84 nr the 

Vce President for Enrollment Carnegse Mellon University 5000 Forbes Avenue Pittsburgh. PA 15?13 telephone (41?) ?68 ?056 




Technical Report 
CMU/SEI-92-TR-1 
ESD-92-TR-1 
February 1992 


Ada Validation Tests for 
Rate Monotonic Scheduling 

Algorithms 


Keith A. Kohout 

Naval Weapons Center 


Kent Meyer 

Telesoft, Inc. 


John B. Goodenough 

Rate Monotonic Analysis for Real-Time Systems 


Approved for public release. 
Distribution unlimited. 


Software Engineering Institute 

Carnegie Mellon University 
Pittsburgh, Pennsylvania 15213 







This technical report was prepared for the 

SEI Joint Program Office 
ESD/AVS 

Hanscom AFB, MA01731 

The ideas and findings in this report should not be construed as an official 
OoD position. It is published in the interest of scientific and technical 
information exchange. 

Review and Approval 

This report has been reviewed and is approved for publication. 


FOR THE COMMANDER 




'John S. Herman. Capt. USAF 
SEI Joint Program Office 


The Software Engineering Institute is sponsored by the U.S. Department of Defense. 
This report was funded by the U.S. Department of Defense. 

Copyright © 1992 by Carnegie Melton University. 


This document is available through the Defense Technical Information Center. OTIC provides access to and transfer of 
scientific and technical information tor DoD personnel, DoD contractors and potential contractors, and other U.S. Government 
agency personnel end their contractors. To obtain a copy, please contact DT1C directly: Defense Technical Information 
Center, Attn: FORA, Cameron Station, Alexandria, VA 22304-6145. 

Copies of this document are also available through the National Technical Information Service. For information on ordering, 
please contact NTIS directly: National Technical Information Service. U.S. Department of Commerce, Springfield. VA 22161. 

Copies of this document are also available from Research Access, Inc. 3400 Forbes Avenue. Suite 302, Pittsburgh. PA 15213. 

Use of any trademarks in this report is not intended in any way to infringe on the rights of the trademark holder. 






Table of Contents 

1 Introduction 


1 


2 Test Specifications 

2.1 Priority Service (PS) Tests 

2.2 Basic Inheritance (Bl) Tests 

2.3 Priority Ceiling (PC) Tests 

3 Test Generator 

3.1 Requirements 

3.2 Customization 


4 Test Harness and Test Coding Style 11 

4.1 Server Coding Style 11 

4.2 Test Harness Services 11 

4.2.1 Events to be Logged 12 

4.2.2 Client/Server Event Patterns 13 

4.2.3 Event Timeline Example 14 

4.2.4 Additional Software Support 14 

4.3 Customization 15 

5 Comparator 17 

5.1 Comparator Output and Error Messages 18 

5.2 Customization 19 

6 User’s Guide 21 

6.1 Directory Release Structure 21 

6.2 Testing Process 22 

6.2.1 Test Generator Usage 22 

6.2.2 Test Harness Usage 22 

6.2.3 Comparator Usage 24 

References 25 

Appendix A Logical Test Suite Diagrams 27 

Appendix B Logical Test Suite Expected Events 61 

Appendix C Example of Test Specification 87 


CMU/SEI-92-TR-1 





Appendix D Code for Test Case B!_05 91 

D.1 BI_05_Test_Harness Package Specification 91 

D.2 BI_05_Client_C1_Package Specification 91 

D.3 BI_05_Client_C2_Package Specification 91 

D.4 BI_05_Client_C3_Package Specification 92 

D.5 BI_05_Server_S1_Package Specification 92 

D.6 Bl_05 Server_S2_Package Specification 92 

D.7 BI_05_Test_Harness Package Body 93 

D.8 BI_05_Client_C1_Package Body 94 

D.9 BI_05_Client_C2_Package Body 95 

D.10 BI_05_Client_C3_Package Body 96 

D.11 BI_05_Server_S1_Package Body 97 

D.12 BI_05_Serve r _S2_Package Body 98 

D.13 Main Procedure for Bl_05 98 

Appendix E Obtaining Source Code and Information 99 





-- ^ttat,TT7 ^ 


ii 


CMU/SEI-92-TR-1 



List of Figures 


Figure 1 Logical Test System Components 2 

Figure 2 Server Coding Style 12 

Figure 3 Example Timeline 14 

Figure 4 Comparator Data File Example 17 

Figure 5 Comparator Output Example 18 

Figure 6 Directory Release Structure 21 

Figure 7 Compilation Order for Generator Tool 23 

Figure 8 Compilation Order for the Test Harness Files 23 

Figure A-1 Example Test Case 28 

Figure A-2 PS_01: High-Priority Clients Preempt 29 

Figure A-3 PS_02: Low-Priority Clients (2) Don’t Preempt 30 

Figure A-4 PS_03: Low-Priority Clients (4) Don’t Preempt 31 

Figure A-5 Bl_01: Check for Inheritance Blocking 32 

Figure A-6 Bl_02: Server Priority Is Raised in Sfages 33 

Figure A-7 Bl_03: Inheritance Is Transitive 34 

Figure A-8 Bl_04: Transitive Inheritance with Preemption 35 

Figure A-9 Bl_05: Transitive Inheritance with Server at High Priority 36 

Figure A-10 Bl_06: Delayed Server Doesn’t Block ... 37 

Figure A-11 Bl_07: Delayed Servers Don't Block 38 

Figure A-12 Bl_08: Immediate Rendezvous with Server 39 

Figure A-13 Bl_09: Complex Example #1 40 

Figure A-14 Bl_09 Events 41 

Figure A-15 Bl_10: Complex Example #2 42 

Figure A-16 BMO Events 43 

Figure A-17 PC_01: Simple Ceiling Blocking 44 

Figure A-18 PC_02: Deadlock Avoidance (2 tasks) 45 

Figure A-19 PC_03: Blocked at Most Once 46 

Figure A-20 PC_04: Blocked at Most Once (Nested Calls) 47 

Figure A-21 PC_05: Servers Don’t Execute Above Ceiling Priority 48 

Figure A-22 PC_06: Correct Task Resumes 49 

Figure A-23 PC_07: Delayed High-Priority Server Doesn’t Block 50 

Figure A-24 PC_08: Deadlock Avoidance (3 Tasks) 51 

Figure A-25 PC_09: Deadlock Avoidance (3 Tasks) 52 

Figure A-26 PC_10: Ceiling Blocking Works When Server Is Delayed 53 

CMU/SEI-92-TR-1 ~~-jjj 



Figure A-27 

PC_11: Complex Example #1 

54 

Figure A-28 

PC_11: Events 

55 

Figure A-29 

PC_12: Complex Example #2 

56 

Figure A-30 

PC_12: Events 

57 

Figure A-31 

PC_12: Events When Servers Are Non-Preemptible 

58 

Figure A-32 

PC_12: Events When Servers Execute at Ceiling Priority 

59 

Figure A-33 

PC_13: Priority of Ceiling-Blocked Task Is Inherited 

60 

Figure B-1 

Expected Events for PS_01 

61 

Figure B-2 

Expected Events for PS_02 

62 

Figure B-3 

Expected Events for PS_03 

63 

Figure B-4 

Expected Events for Bl_01 

64 

Figure B-5 

Expected Events for Bl_02 

65 

Figure B-6 

Expected Events for Bl_03 

66 

Figure B-7 

Expected Events for Bl_04 

67 

Figure B-8 

Expected Events for Bl_05 

68 

Figure B-9 

Expected Events for Bl_06 

69 

Figure B-10 

Expected Events for Bl_07 

70 

Figure B-11 

Expected Events for Bl_08 

71 

Figure B-12 

Expected Events for Bl_09 

72 

Figure B-13 

Expected Events for Bl_10 

73 

Figure B-14 

Expected Events for PC_01 

74 

Figure B-15 

Expected Events for PC_02 

75 

Figure B-16 

Expected Events for PC_03 

76 

Figure B-17 

Expected Events for PC_04 

77 

Figure B-18 

Expected Events for PC_05 

78 

Figure B-19 

Expected Events for PC_06 

79 

Figure B-20 

Expected Events for PC_07 

80 

Figure B-21 

Expected Events for PC_08 

81 

Figure B-22 

Expected Events for PC_09 

82 

Figure B-23 

Expected Events for PC_10 

83 

Figure B-24 

Expected Events for PC_11 

84 

Figure B-25 

Expected Events for PC_12 

85 

Figure B-26 

Expected Events for PC_13 

86 


IV 


CMU/SEI-92-TR-1 



Ada Validation Tests for Rate Monotonic Scheduling 

Algorithms 


Abstract: This report presents a set of tests for checking whether an Ada 
runtime system properly supports certain rate monotonic scheduling 
algorithms, specifically, the basic inheritance and priority ceiling protocols. 
These tests are intended to be used by vendors and by users to validate 
implementations of these protocols. The report describes the tests and how 
they are to be used. The source code is available electronically. 


1 Introduction 

Rate monotonic scheduling (RMS) theory [Sha 90] allows a software designer to predict ana¬ 
lytically whether a software system will meet its deadlines. The theory can also be used on 
developed software systems to help locate timing anomalies and performance bottlenecks. A 
major advantage of using RMS theory is that it allows systems to be built in which the software 
structure is not distorted by timing issues [Sha 90]. 

This report is designed to help runtime system developers and end users determine if a given 
Ada runtime system supports certain rate monotonic scheduling algorithms. Two related prod¬ 
ucts are discussed: a set of tests that check for likely implementation errors in runtime system 
support for RMS algorithms and some tools that make it easier to use these tests. 

Two types of tests are needed to check how well a runtime system supports a scheduling al¬ 
gorithm: logical tests that check whether the algorithm has been implemented correctly, and 
performance tests that measure the efficiency of an implementation. This report discusses 
only those logical tests needed to check the priority inheritance protocols [Sha 90] (basic in¬ 
heritance and priority ceiling). The sporadic server algorithms [Sprunt 89] are not tested at this 
time; performance tests are under development. 

This suite of tests assumes that Ada application programs use the monitor task paradigm to 
implement critical regions protected by a semaphore. A monitor task (called a server task in 
the remainder of this report) is a task that ensures mutually exclusive access to some resource 
through a critical region protected by a semaphore. In Ada, the way to represent such critical 
regions is with a task whose body is a single select statement enclosed in an endless loop. 
The task serves the role of the semaphore and the accept alternatives within the select state¬ 
ment serve as different critical regions. Non-server tasks are called client tasks. Such tasks 
may call server tasks. To model a nested critical region, a server task calls another server task. 

The logical test system described in this report contains several components (see Figure 1). 
The next section briefly describes the test objectives for each of the logical tests. (Detailed ob¬ 
jectives are specified in Appendix A.) Section 3 describes a program generator for creating 
specified tests. Section 4 describes the test harness that supports the execution of specified 
tests. Section 5 describes a comparison tool for checking test results. The final section is a 
user’s guide that describes the steps of compiling, executing, and evaluating the tests. 


CMU/SEI-92-TR-1 


1 




Test Specifications 



r- 


PSOl 



TEST SPECIFICATION 

The logical test specifications are summarized beginning on 
page 3; detailed specifications are given in Appendix A. 


Test Generator 



TEST GENERATOR 

The logical test generator is described on page 9. This tool is 
written in Ada. It automatically generates test files. Two gen¬ 
erator packages, generator_structure and test_characteris- 
tics, are used to specify the characteristics of the tests to be 
generated. The tests described in this document were gener¬ 
ated with this tool. The generator is provided to allow further 
development or modification of test cases. 


Logical Tests and Test Harness 


|PS 01 || l |BPof P |PCJ)iP 


constant* 


Spec 


Body 


Spec I Spec j I Body 


hameas_support io 



Spec 


Body 


vendor_specifici 

Test Harness 


harness event_log_manager 


LOGICAL TESTS and TEST HARNESS 
The test harness that supports test case execution is dis¬ 
cussed on page 11. The generator produces individual test 
case files and a hamess_constants package. The generated 
test files “with* the routines provided in the test harness (event 
logging, I/O, vendor interface, etc). The test harness and the 
individual tests must be compiled together. Each test is linked 
into a separate load module that can be executed on the tar¬ 
get machine. The comparator is then used to check the exe¬ 
cution output of each test against the expected results. Some 
modification of the harness_constants and vendor_specifics 
packages may be required for a given implementation. 


Comparator 



COMPARATOR 

The comparator is described on page 17. Like the generator, 
the comparator is written in Ada and runs on the host system. 
The comparator checks test execution output against the ex¬ 
pected output (see Appendix B). 


USER'S GUIDE 

The user’s guide, on page 21, presents the steps that should 
be taken to modify, compile, link, execute, and check the log¬ 
ical tests. 


Figure 1 Logical Test System Components 


2 


CMU/SEI-92-TR-1 







2 Test Specifications 


The tests described in this document check the logical behavior of a runtime system that sup¬ 
ports the basic inheritance (Bl) and priority ceiling protocols (PCP). Each test checks an im¬ 
portant protocol behavior. Three categories of behavior are checked. 

1. Priority service: executing tasks are preempted by tasks of higher priority. 

2. Basic inheritance: a server is executed at either the priority of the task being 
served or at the priority of a caller whose call is unable to be accepted, 
whichever is higher. Moreover, blocked callers are serviced in order of 
priority, not in order of arrival. 

3. Priority ceiling: in addition to basic inheritance, a server task is not allowed to 
accept a call unless its priority ceiling 1 is higher than the priority ceiling of any 
server that is executing a call on behalf of another client task. Since this rule 
introduces a new reason for not accepting entry calls, if a server’s priority 
ceiling causes an entry call to be blocked, the server blocking the call inherits 
the blocked caller’s priority. 

The tests that follow are described in detail in Appendix A. 


2.1 Priority Service (PS) Tests 

Higher-priority clients, when they become eligible to run, must preempt lower-priority clients. 

• PS_01: Check for preemption of lower-priority clients by higher-priority 
clients. 

Low-priority clients are not allowed to preempt high-priority clients. In a priority-based sched¬ 
uling system, only higher-priority clients are allowed to preempt. This is not true of a time- 
sliced scheduling system. 

• PS_02: Check that low-priority client tasks are not executed in favor of high- 
priority clients (for two low-priority clients). 

• PS_03: Check that low-priority client tasks are not executed in favor of high- 
priority clients (for four low-priority clients). 

2.2 Basic Inheritance (Bl) Tests 

Medium-priority clients are prevented from executing (inheritance blocking) when a high-prior¬ 
ity client is waiting to use a server that has been called by a low-priority client. This is because 
the server is executed with the waiting caller’s priority. 

• Bl_01: Check for inheritance blocking. When a server is in rendezvous with 
a low-priority client, the server should inherit the priority of any (higher- 
priority) caller, thereby ensuring that medium-priority tasks do not execute. 


1. The priority ceiling of a server is the highest priority of all client tasks that can call it directly or indirectly. 


CMU/SEI-92-TR-1 


3 




A server should inherit the highest priority of the clients that are waiting for the server. More¬ 
over, queued clients should be serviced in priority order. 

• Bl_02: Check that a server executes at the highest priority of all waiting 
clients’ priorities and that the server’s priority is lowered after a high-priority 
client is served. Also, check that blocked clients are serviced in priority order, 
i.e., when more than one client is waiting for a server, the highest-priority 
waiting client should execute next. 

The n^xt tests check for transitive inheritance, namely, that a client’s priority is transmitted 
through one server to subsequent servers. 

• Bl_03: Check for transitive inheritance of client’s priority. A nested server 
should inherit the server’s inherited priority, and hence, if a lower-priority task 
becomes ready to execute while a nested server call is being performed, the 
lower-priority task should not execute. 

• Bl_04: Check for transitive inheritance of a client’s priority and verify that 
higher-priority clients can preempt the execution of a nested server call. 

• Bl_05: Check that if a high-priority client calls a server while it is executing a 
nested server call, no medium-priority tasks are allowed to execute (since the 
server inherits the priority of the waiting client). 

Servers that are delayed (suspended while executing a delay statement) do not block other 
tasks from executing. This avoids unnecessary periods of idle time. 

• Bl_06: Check that a delayed server running on behalf of a high-priority client 
allows a lower-priority client to execute. 

• Bl_07: Check that a delayed server running on behalf of a high-priority client 
allows a lower-priority client to execute and call other servers. This test does 
not apply to implementations that support the priority ceiling protocol (see 
PC_07). 

To minimize runtime system overhead, when a server has completed a rendezvous, it is ex¬ 
pected to continue to execute until it is ready to accept another entry call instead of giving up 
control as soon as the rendezvous is completed. 

• Bl_08: Check that servers are either executing or are ready to accept an 
entry call. 

Examples from CMU/SEI-89-TR-15 [Borger 89] that combine preemption, direct blocking, in¬ 
heritance (push-through) blocking, simple inheritance, and transitive inheritance: 

• Bl_09: Check for preemption, blocking, inheritance, and proper priorities of 
tasks for Bl (similar to Example #1 in CMU/SEI-89-TR-15). (PC_11 tests for 
behavior of the same task set when the priority ceiling protocol is supported.) 

• BMO: Check for preemption, blocking, inheritance, and proper priorities of 
tasks for Bl (similar to Example #2 in CMU/SEI-89-TR-15). (rc_12 tests for 
behavior of the same task set when the priority ceiling protocol is supported.) 


4 


CMU/SEI-92-TR-1 




2.3 Priority Ceiling (PC) Tests 

The priority ceiling algorithm, in its pure form, requires that a server execute at either the pri¬ 
ority of its caller or at the priority of a blocked calling task, whichever is higher. The tests pre¬ 
pared in association with this paper check for this behavior. But there are two alternative forms 
of implementation that have essentially the same effect on worst-case schedulabiiity and that 
can be easier or more efficient to implement. The simplest implementation is to execute each 
server at the highest possible priority. This means servers execute in a non-preemptible fash¬ 
ion. It also means that the worst-case blocking time for any task is the longest critical region 
(rendezvous) executed by any lower-priority server task. In cases where all critical regions are 
short, this approach has little effect on overall system schedulabiiity. An additional advantage 
is that no caller is ever queued on a server as long a? the server never suspends its execution; 
every server call can be accepted (on a uniprocessor architecture) because once the call is 
accepted, no other task can run to make any call; it is never necessary to make a context 
switch because a call is blocked. We call this form of implementation the non-preemptible- 
server emulation method. 

The second implementation method (the server-ceiling emulation method) is to have each 
server execute at its ceiling priority. In th'S case, higher-priority tasks will be able to execute 
and will be able to call servers, thereby improving the average-case performance and in some 
cases, improving their worst-case. ; ’ formance over the emulation by preemption method. 
This method is only equivalent to me priority ceiling protocol if the server task does not sus¬ 
pend itself while a rendezvous, thereby allowing lower-priority tasks to run. The example in 
Figure A-23 (for PC_07) shows the kind of situation in which the server-ceiling emulation meth¬ 
od could potentially lead to deadlock or chained blocking. 

If an implementation supports one of the priority ceiling emulation methods, the sequence of 
task executions will, in general, be different. Specific differences are described in Appendix A. 

In a pure implementation of the priority ceiling protocol, a high-priority call by a client to an 
available server can be blocked just because of the priority ceiling protocol rule; this form of 
blocking is called ceiling blocking. 

• PC_01 : Check that a high-priority task’s call to an available server is blocked 
when the caller’s priority does not exceed the priority ceiling of a server task 
that is in rendezvous with a lower-priority task. 

Mutual deadlock s prevented by the priority ceiling protocol. The protocol prevents clients from 
deadlocking if they attempt to call the same set of servers in different orders. 

• PC_02: Check for deadlock avoidance involving two clients. 

If a high-priority client accesses two or more servers that are also accessed by lower-priority 
clients, the priority ceiling protocol ensures that the high-priority client will be blocked by at 
most one lower-priority client’s rendezvous with a server. This is because medium-priority cli- 


CMU/SE1-92-TR-1 


5 



ents are not allowed to begin any server calls once a server with a high-priority ceiling is exe¬ 
cuting. 


• PC_03: When lower-priority tasks access the same servers, check that a 
client is prevented from accessing its servers at most once, and that there are 
no nested server calls. 

• PC_04: When there are nested server calls, check that a client is prevented 
from accessing its servers at most once when lower-priority tasks access the 
same servers. 

Clients with priorities above a server’s priority ceiling are not blocked from rendezvousing with 
other servers. The next tests check that servers do not execute above their priority ceiling. 

• PC_05: Check that a client with a priority above a preempted server’s ceiling 
can rendezvous with a ready server. 

• PC_06: Check that a client with a priority above a preempted server’s ceiling 
can rendezvous with a ready server. This test will fail if servers are executed 
at their ceiling priority. 

Servers that are delayed do not block ready tasks from executing. However, if a lower-priority 
task, C2, attempts to call a server while a high-priority task is delayed in a server rendezvous, 
C2 must be prevented from calling the server, since C2’s priority cannot exceed the ceiling of 
the executing server. 

• PC_07: Check that a delayed server running on behalf of a high-priority client 
allows a lower-priority client to execute, but that calls to other servers by the 
lower-priority task will be blocked. (This test is the same as Bl_07, but the 
expected results are different when the priority ceiling protocol is being 
supported.) 

The next two tests provide somewhat more complex deadlock avoidance tests. 

• PC_08: Check for deadlock avoidance (three clients). 

• PC_09: Check for deadlock avoidance (three clients). 

Periods of idle time can exist it no tasks are eligible to run. Servers that are delayed allow 
lower-priority ready tasks to execute as long as no server calls are made. 

• PC_10: Check that delayed servers don’t block lower-priority clients. 

Examples from CMU/SEI-89-TR-23 [Borger 89] that combine preemption, direct blocking, in¬ 
heritance (push-through) blocking, simple inheritance, transitive inheritance, and ceiling block¬ 
ing: 

• PC_11 : Check for preemption, blocking, inheritance, and proper priorities of 
tasks for PCP (similar to Example #1 in CMU/SEI-89-TR-15). The output 
from this test will be different from the output for Bl_09 even though the 
pattern of client and server calls is the same in both tests. 


6 


CMU/SEI-92-TR-1 





• PC_12: Check for preemption, blocking, inheritance, and proper priorities of 
tasks for PCP (similar to Example #2 in CMU/SEI-89-TR-15). As for PC_11, 
the output from this test will be different from the output for Bl_10 even 
though the pattern of client and server calls is the same in both tests. 

The next test checks that if a server is indirectly blocking one or more high-priority tasks, the 
server executes with the highest priority of the blocked tasks. This situation can arise when 
the priority ceiling of the server is higher than the priority of the calling tasks, and the calling 
tasks are calling other servers. 

• PC_13: Check that a server is executed with the priority of tasks that are 
ceiling-blocked in attempting to call other server? This test checks when 
there are two ceiling-blocked tasks and ensures that the highest-priority 
blocked task is executed first. 


CMU/SEI-92-TR-1 


7 





3 Test Generator 


The test cases all have a very similar structure, so they can be generated automatically from 
a specification of test behavior. The specification format allows a user to describe test cases 
in terms of the test case diagrams shown in Appendix A. As new tests are developed or as 
tests change, a new diagram should be created that specifies the expected test behavior and 
the expected sequence of calls. 


3.1 Requirements 

The purpose of the generator is to produce a suite of test cases automatically from a descrip¬ 
tion of the tests. The generator was developed to meet the following requirements. 

1. Generate each test as a stand-alone program. 

2. Create no dependent tasks (i.e., all tasks will be created at the library level). 

This provides compilers with the maximum opportunity to optimize server 
tasks and also reflects expected practice. 

3. Allow for task suspension in a server. Task suspension represents a delay in 
processing. In a real system, a delay could be caused by I/O. 

4. Comply with the recommended server coding style (which gives maximum 
opportunity for compiler optimization): 

• Set priority ceilings outside of the server tasks. 

• Have the generator compute the priority ceiling of each server task. This 
keeps the user from having to specify the server’s priority ceiling. 

• Use the terminate alternative in servers rather than a STOP entry call to 
shut down server tasks. 

• Don't use an exception handler in the body of a server. 

• Don’t give server tasks a priority using pragma PRIORITY. This allows the 
priority inheritance and the priority ceiling protocols to be supported by a 
validated Ada compiler [Sha 90]. (Servers can be given a priority by some 
other mechanism, however, such as a runtime system call.) 

5. Isolate possible test harness dependencies (e.g. TEXTJO, delay_until). This 
separates the possible changes that users may have to make. 

6. In a client’s exception handler, spell out "Unexpected exception in Client_N 
Task". This gives more information to the user. 

7. Rather than placing all clients and servers in one package, place each client 
and server in its own package. This better mirrors an actual code structure 
that would be used in practice. 

8. Allow the generator to accept an arbitrary number of parameters that specify 
the structure of the tasks for the given logical test. This allows for maximum 
flexibility. 


CMU/SEI-92-TFM 


9 





3.2 Customization 


The areas of customization for the generator have been localized to two packages. Each of 
these packages will need to be examined. The generator may be customized with respect to 
task names, priorities, etc.: 


• Generator_Structure. The following can be found in the Generator_Structure 
package (gensts. ada). 

- User Customization Section Begins - 

- Customization for Constraints on Generator 


Max_Number_Of_Tests: constant Positive := 30; 
Max_Task_Events : constant Positive := 5; 
Max_Server_Entries : constant Positive := 5; 


type Task_Names is (Cl, C2, C3, 04, C5, SI, S2, S3, S4, S5); 
type Entry_Name_Types is (El, E2, E3, E4, E5); 


- Customization for Build_Hamess_Constants 


type Byte Is range 0.. 255; - Type Byte Needed 

tor Byte Size use 8; 


Event_Logger_Prk>rity 

Server_Priority 

Main_Priority 

Test_Done_Priority 

Settfing_Time 

I nteracti ve_T race 


: constant Byte :« 60; 

: constant Byte := 32; 

: constant Byte := 1; 

: constant Byte := 59; 

: constant Float := 1.0; 

: constant Boolean > False; 


- Highest Priority 

- Server Priority 

- Lowest Priority 

- Next Highest Priority 

- Startup time 

- Debug Off 


- Priorities P1-P10 should be higher than the ServerJPriority. 
type Priority_Type Is (PI, - Low Priority 

P2, P3, P4, P5, P6, P7, P8, P9, 

P10); - High Priority 
lor Priority_Type use (PI => 33, P2 => 34, 

P3 =>37, - Actual values can be noncontiguous 

P4 => 38. P5 => 41, P6 => 43, P7 => 46, P8 => 47, P9 => 48, P10 => 49); 
for Priority TypeSize use 8; 

- User Customization Section Ends - 


• Test_Characteristics (tstchb.ada). Customization is required only if the 
user needs to change the suite of logical tests. This involves modifying the 
parameters that describe the test suite to be generated. Modifying the 
Test_Characteristics package is easier than creating this package anew. The 
specification for test Bl_05 is given in Appendix C on page 87; the diagram 
describing this test case is found in Appendix A on page 27. 


10 


CMU/SEI-92-TR-1 





4 Test Harness and Test Coding Style 


The test harness is a package of subprograms that support the execution of test cases. In par¬ 
ticular, various setup procedures are provided together with procedures for consuming time 
and for logging events that occur during execution. An automated examination of the event log 
determines whether a given test has been passed. 

Clients and servers comprising a test are assumed to be coded in certain patterns of calls to 
the test harness. The next section discusses the coding style required for servers. Section 4.2 
discusses various services provided by the test harness. 

4.1 Server Coding Style 

The test case generator automatically produces server tasks written in a style that allows serv¬ 
ers to be implemented efficiently as critical regions protected by a semaphore [Borger 89]. 
These restrictions are: 

1. All accept statements must be contained in a single select statement that is 
the only statement in the body of an endless loop. 

2. A server task is not assigned a priority using the pragma PRIORITY. Since 
Ada’s rules do not specify any particular priority or scheduling policy for tasks 
that do not have a defined priority, the runtime system can allow these servers 
to execute in accordance with the basic inheritance and priority ceiling 
protocol rules [Sha 90]. 

The sample Ada code segment shown in Figure 2 Illustrates the server coding style used in 
the tests. The example server task (SI) has a single select statement with two accept alterna¬ 
tives (El and E2) and a terminate alternative. The terminate alternative will be selected when 
the test is finished. 

4.2 Test Harness Services 

The event logger captures the activities of a test case execution. As the test harness executes, 
calls to the logger capture the identity of the active task (a client or a server), the identity of the 
calling client task (when an event is logged within a server), the current time, and the nature 
of the event. A printout of logged events is usually provided after the test case has finished, 
but printouts can be provided interactively. Reporting events as they occur can cause unin¬ 
tended test behavior because of the time taken to print out the information, but interactive re¬ 
porting can be useful when debugging a test case. 


CM'J/SEI-92-TR-l 


11 








task body S1_Task Is 
Exec_Time_1 : constant Duration := 1.0; 
ExecJTime_2 : constant Duration := 3.0; 

bsgin 


- Get my id 


accept Getjd (Task_ld : out Vendor_Specifics.TaskJd) do 
Taskjd := Vendor_Specifics.Get_Task; 
end Getjd; 


- Endless loop servicing clients 


loop 

aelect 

accept El (Callerjd; In TaskJdJType) do 


- Server Execution 


Log_Event(S2, Callerjd, Server_Exec_Begins); 
Hamess_Support Spend_Time(Exec_Time_1); 
Log_Event(S2, Callerjd, Server_Exec_Ends); 
end El; 
or 

accept E2 (Callerjd: In TaskJdJType) do 


- Server Execution 


Log_Event(S2, Callerjd, ServerJExec_Begins); 
Hamess_Support Spend_Time(Exec_Time_2); 
Log_Event(S2. Callerjd, Server_Exec_Ends); 
end E2; 
or 

terminate; - when test is finished 

end select; 
end loop; 
end S1_Task; 


Figure 2 Server Coding Style 
4.2.1 Events to be Logged 

The events that can be logged are defined by the type Task_Exec_Phase. Currently the 
events that can be logged are the following: 

• Client_Exec_8egr/ns - Beginning client execution. Followed by a call to 
SpendJTime. 

• Client_Exec_Encfe - Ending client execution. 

• Task_Suspension_Segr/ns - Beginning task suspension. Followed by a call 
to Suspend_Task. 

• Task_Suspension JEnds- Ending task suspension. 

• Server_Call _Begins - Beginning a call to a server. Followed by the acUia! 
server call. Both clients and servers can call other servers. 

• Server_Call_Encfe- Ending a server call. 


12 


CMU/SEI-92-TR-1 




• Server_Exec_Beg/ns - Beginning server execution. Followed by a call to 
Spend_Time. 

• Server_Exec JEnds - Ending server execution. 

Note: All of the Begins and Ends above are paired to represent actions that can be repeated 
more than once for a given client or server. A client typically performs more than one action. 

4.2.2 Client/Server Event Patterns 

A client may contain any combination of the following patterns of event logging calls and calls 
to harness support procedures. The Log_Event call takes three parameters: the first is the 
identifier of the task containing the call; the second is used in servers and identifies the calling 
client or server task; the third identifies the event that is to be logged. 

• Execution time spent in client (Cl). 

Loa_Event(Cl, None, Client_Exec_Begins); 
Harness_Support.Spend_Tlme(Exec_Tlme_1); 

Log_Event(C1, None, Client_Exec_Ends); 

• Call by a client (Cl) to a server (SI). 

LogLEvent(C1, SI, Server_Call_Begins); 

Server_Sl_Package.Sl_Task.E1 (Cl); 

Log_Event(C1, Si, Server_Call_Ends); 

A server may contain any combination of the following patterns: 

• Execution time consumed by a server (SI) on behalf of a caller. 

Log_Event(Sl, Callerjd, Server_Exec_Begins); 
Hamess_Support.Spend_Time(Exec_Tlme_ 1 ); 

Log_Event(S1, Callerjd, Server_Exec_Ends); 

• Call by a server (SI) to another server (S2). 

Log_Event(S1, S2, Server_Call_Begins); 

Server_S2_Package.S2_Task.E1 (Si); 

Log_Event(S1, S2, Server_Call_Ends); 

• Suspension of a server task (SI) that is executing on behalf of some caller. 

Log_Event(S1, Callerjd, Task_Suspension_Begins): 
Harness_Support.Suspend_Task(SuspensIon_TJme_l); 

Log_Evenl(S1, Callerjd, Task_Suspension_Ends); 


CMU/SEI-92-TR-1 


13 




4.2.3 Event Timeline Example 

The output from the test harness is a log of events that should be compared with expected test 
results (see Appendix B). These events indicate the order of execution of clients and servers 
during the execution of a test case. The expected sequence of events is derived from the test 
case diagrams given in Appendix A. The example given in Figure 3 shows the expected output 
for test case “Bl_05" (page 36). 


[Task; C3 Begins Execution 


att= 1] 

[Task: C3 Ends Execution 


at t - 2] 

[Task; C3 Calls server; 

SI 

at t = 2] 

[Task: Si Begins Execution on behalf of: 

C3 

at t - 2J 

[Task: Si Ends Execution on behalf of: 

C3 

at t = 4] 

[Task: SI Calls server: 

S2 

at t = 4] 

[Task: S2 Begins Execution on behalf of: 

SI 

at t = 4] 

[Task: C2 Begins Execution 


at t« 5] 

[Task: Cl Begins Execution 


at t = 6] 

[Task: Cl Ends Execution 


at t = 7] 

[Task: Cl Calls server: 

SI 

at t = 7] 

[Task: S2 Ends Execution on behalf of: 

SI 

at t = 8] 

[Task: SI Begins Execution on behalf of: 

C3 

at t = 8] 

[Task: SI Ends Execution on behalf of: 

C3 

att- 10] 

[Task: Si Begins Execution on behalf of: 

Cl 

att= 10] 

[Task: SI Ends Execution on behalf of: 

Cl 

att = 11] 

[Task: Cl Begins Execution 


att = 11] 

[Task: Cl Ends Execution 


att = 12] 

[Task: C2 Ends Execution 


att = 13] 

[Task: C3 Begins Execution 


att = 13] 

[Task: C3 Ends Execution 


att = 14] 

..**»*.*...*.*.»»** Test Q om p| et0 •******•• 




Figure 3 Example Timeline 


4.2.4 Additional Software Support 

The test harness contains additional software that is used to calibrate a test case, start and 
stop the test case, activate the event logger, and print the timeline of events captured by the 
event logger. The command sequence for the main procedure for running tests such as Bl_05 
is shown below: 


Harness_Support.Calibrate_Spend_Time; 

Hamess_Event_Log_Manager.lnitialize{Start_Time); 

bi_05_Test_Hamess.Start_Run(Start_nme); 

bi_05_Test_Harness.Test_Done.Complete; 

Harness_Event_Log_Manager.Print_Time_Lines; 

Hamess_Event_L.og_Manager.Quit; 


- Calibration 

-- Initialize Logger 

- Start Clients 

-- Wait for Clients 
-- Print Time Line 
-- Stop Logger 


14 


CMU/SEI-92-TR-1 









The complete code for test case Bl_05 is found in Appendix D. 


4.3 Customization 

The test-harness may be customized in the following areas: 

• Vendor_Specifics. The following can be found in the Vendor_Specifics 
package. It should not be necessary to change the Vendor_Specifics 
package specification except possibly for its types and subtypes. The body 
of this package will need to be modified to support an individual vendor. The 
following code shows the TeleSoft 3.23 TeleAda-Exec vendor-specific 
package, vendor .tel: 

with System; 
with Calendar; 

with Ada_Tasking_Extensions; 
package Vendor_Specifics la 

aubtype Taskjd la Ada_Tasking_Extensions.TaskJd; 

function Get_Task return Taskjd renames 
Ada_Tasking_Extensions.Cunent_Task; 

procedure ChangeJ’riority (OMTask; Ada_Tasking_Extensions.TaskJd; 

New_Priority : System.Priority); 

procedureSet_Priority_Ceiling (OMask: Ada_Tasking_Extensions.TaskJd; 

NewJ’riority: System.Priority); 

function Get_Priority_Ceiling (Of_Task : Ada_Tasking_Extensions.TaskJd) 
return System.Priority renames Ada_Tasking_Extensions.Get_Priority; 

procedure Delay_Until(Wake_Up_Time: In Calendar.Time); 
end Vendor_Spedfics; 


- Package Body 


with Ada_Taskinfl_Extensions; 
package' dyVendor_Spedficsis 

procedure ChangeJ’riority (Of_Task : Ada_Tasking_Extensions.TaskJd; 

New_Priority: System.Priority) Is 
Priority; Ada_Tasking_Extensions.Task_Priority; 

begin 

Priority:» Ada_Tasking_Extensions.Change_Priority (Of_Task, New_Priority); 
end Change_Priority; 

procedure Set_Priority_Ceiling (Of_Task : Ada_Tasking_Extensions.TaskJd; 

New_Priority: System.Priority) la 
Priority: Ada_Tasking_Extensions.Task_Priority; 

begin 

Priority Ada_Tasking_Extensions.Change_Priority (Of_Task, New_Priority); 
end Set_Priority_Ceiling; 

procedure Delay_Until(Wake_Up_Time: In Calendar.Time) la 
Now : Calendar.Day_Duration Calendar.Seconds(Calendar.Clock); 

begin 

delay(Calendar.Seconds{WakeJJp_Time) - Now); 
end DelayJJntil; 
end Vendor_Spedfics; 


CMU/SEI-92-TR-1 


15 




• Modifications to Harness_Constants {hconst. ada) should not be needed if 
the generator creates this package. 

• Modifications to IO_Pkgs package (iopkgs. ada) should be needed only if 
this package does not compile. This would indicate different I/O compiler 
support. 


16 


CMU/SEI-92-TR-1 




5 Comparator 

The comparator compares the actual event sequences of a test case execution with the ex¬ 
pected sequence of events. For a test to pass, the actual and expected sequences of events 
must match line for line, excluding the time stamp. The time stamp is not considered because 
the overhead of the event logger and other execution times that are not accounted for will 
cause the time to vary slightly. At the completion of a test, the last event’s time stamp is 
checked for a drift of no more than ±5%. If the drift was more than ±5%, a warning is given to 
check the execution times. 

The input to the comparator is the data in the file compare. dat. Entries in this file are a suc¬ 
cession of lines having the following format: 

• the keyword Compare 

• the location of the expected output 

• the location of the actual output 

• a descriptive comment 

and a blank line. Copying and modifying this file is easier than creating it anew. An example 
file is shown in Figure 4. 


****** Data File for Comparator 
Compare 

~/Expected/ex_01 .out 
.7Actual/ex_01 .out 
ex_0l 

Compare 

. VExpected/ex_02 .out 

.7Actual/ex_02.out 

ex_02 

Compare 

. 7Expected/ex_03 .out 

.7Actual/ex_03.out 

ex_03 

Compare 

. VExpected/exJM .out 

.7Actual/ex_04.out 

ex_04 

Compare 

. 7Expected/ex_05 .Oout 

.7Actual/ex_05.out 

ex_05 

Compare 

. 7 Expect ed/ex_06 .out 
. VActual/ex_06 .out 
ex_06 


Figure 4 Comparator Data File Example 


CMU/SEI-92-TR-1 


17 








5.1 Comparator Output and Error Messages 

Figure 5 shows example output from the comparator. 

For ex_01, the test case passed. This means that the expected and the actual events matched 
and the completion times differed by less than ±5%. 

For ex_02, the test case passed with a warning. This means that the expected and actual 
events matched but the completion times differed by more than ±5%. The completion times for 
the expected and actual results are printed. 

For ex_03, the test case failed because the expected and actual events did not match. The 
place of the mismatch is shown by looking at the two lines (expected event and the actual 
event). 


Test Suite 

Test: ex 01 -> Passed 


Test: ex_02 «> Passed {check times} 

** Expected_Time = 10. Actual JTime » 9.100 ** 


Test: ex_03 »> FAILED 

[Task: Si Begins Execution on behalf of: Cl at t = 7] 
[Task: Cl Ends Call with server: SI at t ■ 


Test: ex_04 => FAILED ** ERROR -- Data_Error unexpected 
[Task: S2 Ends Suspension on behalf of: C2 at t = 6] 

[Task: Cl Ends Call with server: Si at t * 


Test: ex_05 => FAILED ** ERROR -- Name_Error unexpected ** 

** File = ~/test-suite/Expected/ex_05.Oout, could not be Opened ** 

Test: ex_06 «> FAILED ** ERROR -- End-Of-File unexpected ** 
[Task: C3 Ends Execution at t = 8] 

[Task: C3 Begins Execution at t = 


Figure 5 Comparator Output Example 


18 


CMU/SEI-92-TR-1 





For ex_04, the test case failed with an unexpected error indication. The expected and actual 
events did not match because Data_Error was raised. The expected event and the actual 
event are printed. 

For ex_05, the results file could not be opened. This file name is printed following the erry 
message. 

For ex_06, the end of file was encountered unexpectedly. The events before the unexpected 
end-of-file occurred are printed. 

5.2 Customization 

The comparator should not require customization. But the file compare. dat should change 
as the suite of tests changes. 


CMU/SEI-92-TR-1 


19 





20 


CMU/SEI-92-TR-1 




6 


User’s Guide 


6.1 Directory Release Structure 

The directory release structure for the software that accompanies this report is shown in 
Figure 6. 


<Release Directory> 
document 

Postscript of this document 

events 

ps_01.out (thru) ps_03.out 
bi_01.out (thru) bi_10.out 
pc_01.out (thru) pc_13.out 

tests 

harness 

evlogb.ada 

evlogs.ada 

hsuppb.ada 

hsupps.ada 

iopkgs.ada 

vendor.{aly | tel | trt | vdx) 
logicals 

ps_01 .ada (thru) ps_03.ada 
bi_Ol.ada (thru) bMO.ada 
pc_Ol.ada (thru) pc_13.ada 

tools 

compare 

compare.ada 

oompare.dat 

generate 

genera.ada 

gensep.ada 

genstb.ada 

gensts.ada 

tstchb.ada 

tstchs.ada 

Figure 6 Directory Release Structure 


CMU/SEI-92-TR-1 


21 





6.2 Testing Process 

This section steps through the use of the test case generator, the running of individual test cas¬ 
es, and the running of the comparator. The test case generator allows rapid development of a 
test case. The generator takes an Ada description of the test cases to be generated and pro¬ 
duces appropriate packages. These packages and the test harness are then compiled togeth¬ 
er to produce an executable test program. The results of the test execution are then compared 
with the expected results. The test case generator and the comparator were designed to be 
run on the host machine, while the test harness was designed to be run on the target machine 
(which could be the host). 

6.2.1 Test Generator Usage 

Step 1: Generate the tests. The first step in the testing process is to produce the test files. 
The tests described in this report have already been created and are supplied with the soft¬ 
ware release. If you do not intend to make any major modifications or enhancements to these 
tests, you will not need to use the test generator tool, and you can skip to Step 2. 

The input to the generator is a file containing the package Test_Characteristics 
(tstchb.ada). This package contains a description of the test cases to be generated (see 
Appendix C for an example). This file can be modified to produce new or different tests. The 
steps to follow in compiling the generator tool and specifying the tests it will produce are as 
follows: 

1. Locate the directory <Release_Directory>/tools/generate. This di¬ 
rectory contains all of the generator source files. 

2. The source files tstchb.ada and gensts.ada should be modified 
according to the customization suggestions contained in Section 3.2 on page 
10 . 

3. The generator should be compiled using a HOST Ada compilation system 
(the executable will run on the development machine). The main unit is 
generate, and the compilation order for these packages is shown in Figure 
7. 

4. Once the generator has been compiled and linked, running it will produce the 
harness_constants package and the individual test files (see Appendix D 
on page 91 for an example of a test). 

6.2.2 Test Harness Usage 

Step 2: Compile the tests and the test harness. The test harness is compiled along with the 
generated logical test files to produce the executable load modules that represent each test 
case. The tests may be ones created using the generator, or they may be the versions provid¬ 
ed in the tests/iogicais directory. To compile the test harness, follow these steps: 


22 


CMU/SEI-92-TR-1 




File Name Unit/s) 

gensts.ada GENERATOR_STRUCTURE 

genstb.ada GENERATOR_STRUCTURE <body> 

tstchs.ada TEST_CHARACTERISTICS 

tstchb.ada TEST_CH AR ACTE RISTICS <body> 

genera.ada GENERATE <body> 

gensep.ada GENERATE.BUILD_BODIES <body> 

GENERATE.BUILD_HARNESS_CONSTANTS <body> 
GENERATE.BUiLD_MAIN <body> 

GENERATE.BUILD_SPECS <body> 
GENERATE.CALC_CEILINGS <body> 
GENERATE.MAKE_STRING <body> 

Figure 7 Compilation Order for Generator Tool 


1. Modify the test harness files located in tests/harness (only if they cannot 
otherwise be compiled). 

iopkgs.ada 
hsuppb.ada 

vendor. tel (or other vendor-specific package) 

2. Modify the hconst.ada package located in <Release_Directory>/ 
tests/iogicais if it does not compile. 


3. Compile the test harness and the harness_constants package using the 
TARGET Ada compiler. The compilation order is shown in Figure 8. 


4. Compile and link the individual logical tests. All the unit names for the test 
cases are unique, so one library can contain the entire set of tests. For the 
test cases presented in this report, the file name reflects the main unit name, 
so an example compile and link would be the following: 

compile bi_05.ada 
link bi_05 

5. Run the executable load module for each test, directing or capturing the 
output to a file, e.g., for a target running Unix: 

bi 05 > bi 05.out 


CMU/SEI-92-TR-1 








File Name 

Unitfs) 

hconst.ada 

H ARN ESS_CONSTANTS 

iopkgs.ada 

IO_PKGS 

vendor.??? 

VENDOR_SPECIFICS 


VENDOR_SPECIFICS <body> 

evlogs.ada 

HARNESS_EVENT_LOG_MANAGER 

evlogb.ada 

HARNESS_EVENT_LOG_MANAGER <body> 

hsupps.ada 

HARNESS_SUPPORT 

hsuppb.ada 

HARNESS_SUPPORT <body> 

Note: the above ??? in vendor.??? is specific to the tested compiler (tel, vdx, aly,..) 

Figure 8 

Compilation Order for the Test Harness Files 


6.2.3 Comparator Usage 

Step 3: Check the test output. The input to the comparator is the file compare. dat. The 
format to be used for this file is described on page 17. The steps for creating the comparator 
program are as follows: 

1. Compile <Release_Directory>/tools/compare/compare.ada and 
link the main unit compare, using a HOST compilation system. 

2. Modify compare. dat (to reflect the test case output to be checked). 

3. Run compare. 


24 


CMU/SEI-92-TR-1 



References 


[Altman 87] Altman, Neal. Factors Causing Unexpected Variations in Ada Benchmarks 
(CMU/SEI-87-TR-22, DTIC: ADA187231). Pittsburgh, PA: Software Engineer¬ 
ing Institute, Carnegie Mellon University, October 1987. 

[Borger 89] Borger, Mark W.; & Rajkumar, Ragunathan. Implementing Priority Inheritance 
Algorithms in an Ada Runtime System (CMU/SEI-89-TR-15, DTIC: 
ADA209607). Pittsburgh, PA: Software Engineering Institute, Carnegie Mellon 
University, April 1989. 

[Sha 90] Sha, L.; & Goodenough, J. B. "Real-Time Scheduling Theory and Ada.” IEEE 
Computer 23, 4 (April 1990):53-62. 

[Sprunt 89] Sprunt, B.; & Sha, L. Scheduling Sporadic and Aperiodic Events in a Hard Real- 

Time System (CMU/SEI-89-TR-11, DTIC: ADA211344). Pittsburgh, PA: Soft¬ 
ware Engineering Institute, Carnegie Mellon University, April 1989. 


CMU/SEI-92-TR-1 


25 






26 


CMU/SEI-92-TR-1 





Appendix A Logical Test Suite Diagrams 

This Appendix contains diagrams describing the logical tests. The diagrams show the cli¬ 
ent and server tasks, their calling relationships, and the expected sequence of events. An 
explanatory diagram showing the graphic conventions appears on the next page. The rest 
of the Appendix contains diagrams for the tests described briefly in Section 2. 

For the priority ceiling protocol tests, each diagram is annotated with a comment explaining 
any difference in test behavior under the two emulation methods: the method in which 
servers are executed non-preemptively (the non-preemptible-server emulation method), 
and the method in which servers are executed at their ceiling priority (the server-ceiling 
emulation method). If the difference in test behavior is the same under both emulation 
methods, we say so explicitly. For example, in Figure A-17, the change in test behavior is 
the same under both emulation methods, so we use the phrase “under either emulation 
method”. In Figure A-21, the test behavior only changes when the non-preemptible-server 
emulation method is used, so the comment only mentions the change in this case. 


CMU/SEI-92-TR-1 


27 


































C2 completes 











Priority 





Figure A-3 PS_02: Low-Priority Clients (2) Don’t Preempt 


CMU/SEI-92-TR-1 





Priority 




(A 

e 

V 

• f-H 

u 


V 

I 

►> 


8 

o 

5 

z 

« 

8 
•o 
« 

■I a 

I" *5 

I a 

rH 

- U 

« 

.* V 

w " 

u ** 


a, 

e 


i! 



tu 


2 


Si 


2 


O O 

4-» 4-» 

| | 

60 So 60 

CM CO Tt* 

u u u 

TJ "O 

s s s 

$ 8 $ 

w 4-1 4-» 4-* 

,jf <U <D 0) 

U a a, "a 
£ g £ 


'CO 


8 


48 8 

CM" i—i CM CO 

UUUU 


cm r+< in 
ii » ii 




Figure A-4 PS_03: Low-Priority Clients (4) Don’t Preempt 


CMU/SEI-92-TR-1 


31 


t=7 : C4 completes and C5 begins to execute 
t=8 : C5 completes 






Priority 



Figure A-5 Bl_01: Check for Inheritance Blocking 


>2 


CMU/SEI-92-TR-1 


t=3 : Cl attempts to call SI [DIRECTLY BLOCKED] t=6 : SI completes and Cl resumes 

SI resumes on behalf of C3 t=7 : Cl completes 

t=4 : C2 becomes ready (INHERITANCE BLOCKING] C2 preempts C3 

SI continues on behalf of C3 t=8 : C2 completes and C3 resumes 

t=9 : C3 completes 








Call to Si Directly Blocked 



Figure A-6 Bl_02: Server Priority Is Raised In Stages 


CMU/SEI-92-TR-1 


33 










Cl Cl Cl Cl Cl Cl 



34 


CMU/SEI-92-TR-1 


t=5 : S2 completes and SI resumes 
t=7 : SI completes and Cl resumes 
t=8 : Cl completes and C2 resumes 
t=9 : C2 completes 








Priority 


§ 

•43 

$ $ $ 
-4-» ft) 4-» 

qj a; 

a, c; a, 

m 

n « n 
U U U 


& ii ii 

o *+ 

•« 


CM *-> 
CO CM 
rf CO 


s ^ 

^ "<3 C4 

SS'S 


—I cO 
CO U U 


t in vo 

ii ii 


Figure A-8 Bl_04: Transitive Inheritance with Preemption 




CMU/SEI-92-TR-1 


35 


t=7 : Cl completes and S2 resumes 
t=8 : S2 completes and SI resumes 
t=ll: SI completes and C2 resumes 










Call to SI Directly Blocked 




Figure A-9 Bl_05: Transitive Inheritance with Server at High Priority 


36 


CMU/SEI-92-TR-1 


S2 resumes on behalf of C3 t=14: C3 completes 








CMU/SEI-92-TR-1 


37 


C2 resumes 
t=5 : C2 completes 
t=6 : SI resumes 








Priority 



38 


CMU/SEI-92-TR-1 


t=5 : SI resumes (delay complete) 









C2 begins execution 
C2 rendezvous with SI 










40 


CMU/SEI-92-TR-1 










Check for preemption, blocking, inheritance, and proper priorities of tasks for 
a basic inheritance system. (Similar to [Borger 89] Example #1) 


B | 


£ -a 
53 5 

tfl tfi CO 

S I 8 

4M1I g 

Ua§ 

g 6 

8 8&i 

cficnU 


U I 

2 tJ 

8 ^ 

1 * 8 

1 8 S 

$ u u 


ill! 

I s s $ 

g h h h 

fs. cn tj- in 

U U U U 

’Sill 

g «3 «3 « 

Q; _a> ^ ^ 

^ 6 S £ 6 

§ 8 8 8 8 

55UUUU 


8 3 

2 8 
w> N 
C 

•h 'n 

bO c 

j! i 


£ 

U ^ 

42 P 

Cl, > 

£ 3 

li 

3 3 


28388 

II II II .11 II 


in n n ^ id 'P 
ii ii n ti ii n 


| u 

O v*< 

“ o 

CN 


Ku o c 

42 42 « © 
a, a* » 
£ £ c c 

8 sl I 

a. ci« g 

D N N — i 

UUUw 


co 2 e 
42 « © 

&aS 

ill 

g tJ 5? 

Cl, <« P 

H H fj 

u u to 


2 g 


Figure A-14 Bl_09 Events 


CMU/SEI-92-TR-1 


41 






42 


CMU/SEI-92-TR-1 








Check for preemption, blocking, inheritance, and proper priorities of tasks for a basic inheritance system. 
(Similar to [Borger 89] Example #2) 


% 

•S 


$ 

- i 
& * 
r- *0 

■5 co 


o <5 <2 

K* 45 4-» 

N «} 4} 

« aa 


S 


o 

N 
<u 

"d 

c 5 5 & e 

2 8 8 £ g 


fM 

C/l 

•s 


tfl 

Is 

c x 

o> *i 


$ 8 1 S „ 8 8 


||l 

»■* 

,i- i>4 CO 
T3 >0 "O 


I 

fN 

CD 

-0 


(A 

3 

*d 

I 


aa. &< 
S 6 | 
8 8 8 


5$c5*)c/$Uc/$u*>£r$U 


a> 

ft 
8 1 
uSu 


VO CTJ CVJ 

nr u 


H 


3 

II 


3 tQ 

ii ii 


vO ts. 
tN rvi 
ll II 


3 

ii 


u l 

if 
_ § 
|i 
ii 

K u 


i 

tr> 

U 

T3 


JH ii 

B S 

8 8 

£75 u 


o\ o « ^ 
Nnrtn 
II 11 II II 



H n in \o N 

ll ll ii ll ll 


o h m to ^ in 

005iHririrHri|H 

Jl II II II II II || II 


Figure A-16 BMO Events 


CMU/SEI-92-TR-1 


43 









Gill to SI Ceiling Blocked 




Figure A-17 PC_01: Simple Ceiling Blocking 


14 


CMU/SEI-92-TR-1 


Cl preempts C2 and rendezvous with SI cute until S2 has completed its rendezvous with C2. 
t=5 : SI rendezvous with S2 











Call to SI Ceili 




CMU/SEI-92-TR-1 


Figure A-18 PC_02: Deadlock Avoidance (2 tasks) 


45 


S2 resumes on behalf of C2 t=15: SI completes and Cl resumes 

t=5 : S2 rendezvous with SI t=16: Cl completes and C2 resumes 

t=7 : SI completes and S2 resumes t=17: C2 completes 










46 CMU/SEI-92-TR-1 








Call to SIDirectly Blocked JC1 executes before C2 
' fCl Cl Cl 




Figure A-20 PC_04: Blocked at Most Once (Nested Calls) 


CMU/SEI-92-TR-1 


47 











Rendezvous with SI 






Figure A-21 PC_05: Servers Don’t Execute Above Ceiling Priority 


48 


CMU/SEI-92-TR-1 


t=6 : Cl completes and S2 resumes 
t -7 : S2 completes and C2 resumes 
t=8 : C2 completes 








Rendezvous with SI 




Figure A-22 PC_06: Correct Task Resumes 


CMU/SEI-92-TR-1 


49 


t=4 : Cl preempts S2 Under the server-ceiling emulation method, C2 will 

t=5 : Cl rendezvous with SI not execute until C3's rendezvous is complete. Under 

t=6 : SI completes and Cl resumes the non-preemptible-server emulation method, both Cl 

t=7 : Cl completes and S2 resumes and C2 will not execute until C3's rendezvous is com¬ 

plete. 












Si's delay allows C2 to execute 



Figure A-23 PC_07: Delayed High-Priority Server Doesn’t Block 


50 


CMU/SEI-92-TR-1 


t=4 : C2 attempts to call S2 [CEILING BLOCKED] od, Cl will not execute until Si's rendezvous is com- 

t=5 : SI resumes (delay complete) plete. Under the server-ceiling emulation method, C2 

t=6 : SI completes and Cl resumes will not be blocked from calling S2. This could lead to 

deadlock or chained blocking (e.g., if Cl accessed S2, 
and if C2 accessed SI). 








CMU/SEI-92-TR-1 


51 










Call to SI Directly Blocked 
+ Cl Cl Cl 



Figure A-25 PC_09: Deadlock Avoidance (3 Tasks) 


52 


CMU/SEI-92-TR-1 















£ 

S3 

.a 

73 

T3 

<Q 

a 

x 

u 

o 


C 

•§ 

-a 


•a 

■a 

3 

3 

to 

.a 


T3 

I 

O 

3 

jp 

K3 

V 
w 

(0 

•o' 

§£» 

JS 

3 

T3 

(0 

•m 

n 

V 


« 

ti 

X 



O rH CN CD ID 

H rH rH rH i-h rH 

ii n n n ii ii 

44 4-1 4-4 44 44 4 -* 




*. uuu« 


II! 

8 B.S 

CD U ID 


n N n Tf VO 00 ON 

II II II II II II II 


Figure A-26 PC_10: Celling Blocking Works When Server Is Delayed 


CMU/SEI-92-TR-1 


53 











54 


CMU/SEI-92-TR-1 









Check for preemption/ blocking/ inheritance/ and proper priorities of tasks for a Priority Ceiling Protocol system. 
(Similar to [Borger 891 Example #1) 


$ 5ft 53 

I I 8 

CXTL c 
g c 3 

Ige 

u5!u 


2 8 8 » 

li, a. a, 6 
c 1 g g 3 

I o o s 

y u u c 

^ N (O Tj< 

175 U U U 


| SB | 

„ i I i 

x tn 5 3 

iiii 

fill! 

aj 'S.'S. P« 

■§ 66i S 


es g s -s 

■g | 1 *8 

SJJ1 

U I •§ a> ji 

ibis | 

■S2 c " 2 

g I! 3 £ 

£ a> TJ x 
o -5 x. c* 
•X -tt *• « 5 

1 i 

C 05 _J TJ 

.S3 tn 05 jrj ^ 

1 fi |i s 

bill* 


c e b | § 

a 8 8 8 8 fc £ *Tlg u 

— 4> £ .5 C3 J=3 


CJj r-j fS ^ 

tfi t/H/5 U U 


r-( C'l CO T}< lO N ON r| N C5 

»—< t—i »—it—it—i H H N (N N 

II II II II II II II II II II 

.fel *4 4. 4. -«-• -*-* -4-* 4-* 4-< 


S i-S S3 

issif 

58168 


as 

w N " / 
F) *•*-« 

rH y, O 

CD fsj V*H 

Jf 3} 

isSIs 

<1> > rs42 05 

e B si - ! 
•a-g 8 1 I 
Ji I !.« g 

SS33s 


~ CO U & 

<S) U O G 
42 42 05 ° 

t-g-f-S 

8! S| 1 

CX a, rt g 

CO CN CN __ 

uuuc75 


u u 


O 

Q\ i - * 

ii n 


Figure A-28 PC_11: Events 


CMU/SEI-92-TR-1 


55 













Figure A-29 PC_12: Complex Example #2 


56 


CMU/SEI-92-TR 








Check for preemption, blocking, inheritance, and proper priorities of tasks for a Priority Ceiling Protocol system. 
(Similar to [Borger 89] Example #2) 


111 

CL, £ « 

6 3 T3 

n C 

o J § 
u *■» C 


suss 

id 35 ,2 & 
'H.’Eh & s 


S 1 $ * 

III I 

5 s s § 

UUtfl g 

Tj T3 T3 C 

Iss 1 

gSSJS s 

1u .2 ti 2 

cL 2" &•’&' 1 

6 S G ^ a 

8 8 8 8 2 


ill 

$ s $ 

L L L 
1 Tf ri If) 

u«u 

T3 "2 *T3 

s s g 

rf) VS rA 


a G 8 55 5! u u 35 0 0 Si 3 K 3 53 8 


|H tS (O'# 
N N N N 
II II II II 


SO IN 00 
N N N 
II II II 


o\on^ 
n to to n 
ll ll ll ll 


a> 

■a Sj 0) 


f a at 

$ 3 § 3 

a, g-li, 
g £ g £ 
8 8 8 8 
N ?! H y"? 
CO U C/3 U 


CO 00 

■S cl 


L. £ 2 c 

S» l O 41 

f!| 

ill? 

XI m S G 
o 

|!|2 

g , «US 
§ £* £ 8 
c ’§ 8 .2 
2 ’C tn •£ 

■£ D. J2 t! 
l o 
oi a» in <*. 

ISHs 


WJ 

§ |j •B 

*■§ 

3 s s 

2 g | 

1| S 

‘5b c *2 

i! I § 

U U to 


^ fsi 

U U to 


u U 
2* 
'-M 

* -a 

«J 0) 
CO u & 

CO 2 c 

a « ° 

Sag 
8 2 3 
5 is 2 
Cl, <0 £ 

m m ro 
UUui 


g KS g 

$ 0 u $ 


HNlOvON 
II II II II II 


CO r— 

If II II 


© rH CO Tf in 

rH rH rH rH rH 

II II II II II 


Figure A-30 PC_12: Events 


CMU/SEI-92-TR-1 


57 


line for the server-ceiling emulation method is shown 
on page 59. 












Non-Preemptible region 



>8 


CMU/SEI-92-TR-1 


















Priority Priority level at which Cl ready to start 

A server is running I 















riority Call to SI 

a Directly Blocked 




Figure A-33 PC_13: Priority of Ceiling-Blocked Task Is Inherited 


>o 


CMU/SEI-92-TR-1 


t=7 : Cl preempts C2 t=14: C3 completes and C4 resumes 

t=8 : Cl attempts to call SI [DIRECTLY BLOCKED] t=15: C4 completes and C5 resumes 

SI resumes at Cl's priority on behalf of C5 t=16: C5 completes 














Appendix B Logical Test Suite Expected Events 


[Task: C2 Begins execution 
[Task: Cl Begins execution 
[Task: Cl Ends execution 
[Task: C2 Ends execution 

******************* Test 0 om p| e te ******************* 


Figure 3-1 Expected Events for PS_01 


att = 1] 
at t = 2] 
at t = 5] 
at t = 7] 


CMU/SEI-92-TR-1 





[Task: Cl Begins execution 
[Task: Cl Ends execution 
[Task: C2 Begins execution 
[Task: C2 Ends execution 
[Task: C3 Begins execution 
[Task: C3 Ends execution 


******************* 


Test Complete 


at t = 1 ] 
at t = 4] 
at t = 4] 
at t = 5] 
at t = 5J 
at t = 6] 


Figure B-2 Expected Events for PS_02 


62 


CMU/SEI-92-TR-1 





[Task: Cl Begins execution 

att = 1] 

[Task: Cl Ends execution 

at t = 4] 

[Task: C2 Begins execution 

at t = 4] 

[Task: C2 Ends execution 

at t = 5] 

[Task: C3 Begins execution 

at t = 5] 

[Task: C3 Ends execution 

at t = 6] 

[Task: C4 Begins execution 

at t = 6] 

[Task: C4 Ends execution 

at t = 7] 

[Task: C5 Begins execution 

att = 7] 

[Task: C5 Ends execution 

at t = 8] 


Test Complete 


Figure B-3 Expected Events for PS_03 


CMU/SEI-92-TR-1 


63 








[Task: C3 Calls server: 

SI 

att «= 1J 

[Task: SI Begins execution on behalf of: 

C3 

at t - 1 ] 

[Task: Cl Begins execution 


at t = 2 j 

[Task: Cl Ends execution 


at t = 3] 

[Task: Cl Calls server: 

SI 

at t = 3] 

[Task: SI Ends execution on behalf of: 

C3 

at t * 5] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 5] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 6] 

[Task: Cl Begins execution 


at t = 6] 

[Task: Cl Ends execution 


att = 7) 

[Task: C2 Begins execution 


att = 7] 

[Task: C2 Ends execution 


at t = 8] 

[Task: C3 Begins execution 


at t = 8] 

[Task: C3 Ends execution 


at t = 9] 


Test Complete 


Figure B-4 Expected Events for BI_01 


64 


CMU/SEI-92-TR-1 






[Task: C5 Calls server: 

SI 

att = 1] 

[Task: SI Begins execution on behalf of: 

C5 

att = 1] 

[Task: C4 Begins execution 


at t = 2] 

[Task: C3 Begins execution 


at t = 3] 

[Task: C3 Ends execution 


at t = 4] 

[Task: C3 Calls server: 

SI 

at t = 4] 

[Task: C2 Begins execution 


at t = 5] 

[Task: Cl Begins execution 


at t = 6] 

[Task: Cl Ends execution 


at t = 7] 

[Task: Cl Calls server: 

SI 

at t = 7] 

[Task: SI Ends execution on behalf of: 

C5 

at t = 8] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 8] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 9] 

[Task: Cl Begins execution 


at t = 9] 

[Task: Cl Ends execution 


att = 10] 

[Task: C2 Ends execution 


at t = 11] 

[Task: SI Begins execution on behalf of: 

C3 

at t = 11] 

[Task: Si Ends execution on behalf of: 

C3 

att = 12] 

[Task: C3 Begins execution 


att = 12] 

[Task: C3 Ends execution 


att = 13] 

[Task: C4 Ends execution 


at t= 14] 

[Task: C5 Begins execution 


att = 14] 

[Task: C5 Ends execution 


att = 15] 


******************* iggj Complete ******************* 


Figure B-5 Expected Events for Bl_02 


CMU/SEI-92-TR-1 


65 




[Task: Cl Calls server: 

SI 

att = 1] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 1 j 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 3] 

[Task: SI Calls server: 

S2 

at t = 3] 

[Task: S2 Begins execution on behalf of: 

SI 

at t = 3] 

[Task: S2 Ends execution on behalf of: 

SI 

at t = 5] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 5] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 7] 

[Task: Cl Begins execution 


at t = 7] 

[Task: Cl Ends execution 


at t = 8] 

[Task: C2 Begins execution 


at t = 8] 

[Task: C2 Ends execution 


at t = 9] 


Test Complete 


Figure B-6 Expected Events for Bl_03 


66 


CMU/SEI-92-TR-1 









[Task: C2 Calls server: 

SI 

att = 1] 

[Task: SI Begins execution on behalf of: 

C2 

at t = 1 ] 

[Task: Si Ends execution on behalf of: 

C2 

at t = 4] 

[Task: SI Calls server: 

S2 

at t = 4] 

[Task: S2 Begins execution on behalf of: 

SI 

at t = 4] 

[Task: Cl Begins execution 


at t = 6] 

[Task: Cl Ends execution 


at t = 7] 

[Task: S2 Ends execution on behalf of: 

SI 

at t = 8] 

[Task: SI Begins execution on behalf of: 

C2 

at t = 8] 

[Task: SI Ends execution on behalf of: 

C2 

at t = 11] 

[Task: C2 Begins execution 


at t = 11] 

[Task: C2 Ends execution 


at t = 12] 

[Task: C3 Begins execution 


att = 12] 

[Task: C3 Ends execution 


at t = 13] 


Test Complete 


Figure B-7 Expected Events for Bl_04 


CMU/SEI-92-TR-1 


67 








[Task: C3 Begins execution 


at t = 1 ] 

[Task: C3 Ends execution 


at t = 2] 

[Task: C3 Calls server: 

SI 

at t = 2] 

[Task: SI Begins execution on behalf of: 

C3 

at t = 2] 

[Task: SI Ends execution on behalf of: 

C3 

at t = 4] 

[Task: SI Calls server: 

S2 

at t = 4] 

[Task: S2 Begins execution on behalf of: 

SI 

at t = 4] 

[Task: C2 Begins execution 


at t = 5] 

[Task: Cl Begins execution 


at t = 6] 

[Task: Cl Ends execution 


at t = 7] 

[Task: Cl Calls server: 

SI 

at t = 7] 

[Task: S2 Ends execution on behalf of: 

SI 

at t = 8] 

[Task: SI Begins execution on behalf of: 

C3 

at t = 8] 

[Task: SI Ends execution on behalf of: 

C3 

at t = 10] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 10] 

[Task: Si Ends execution on behalf of: 

Cl 

att = 11] 

[Task: Cl Begins execution 


at t = 11] 

[Task: Cl Ends execution 


at t = 12] 

[Task: C2 Ends execution 


att = 13] 

[Task: C3 Begins execution 


at t = 13] 

[Task: C3 Ends execution 


at t = 14] 

Test complete *****.*** 



Figure B-8 Expected Events for Bl_ 

.05 



68 


CMU/SEI-92-TR-1 








[Task: C2 Begins execution 


at t = 1 ] 

[Task: Cl Begins execution 


at t = 2] 

[Task: Cl Ends execution 


at t = 3] 

[Task: Cl Calls server: 

SI 

at t = 3] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 3] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 4] 

[Task: SI Begins Suspension on behalf of: 

Cl 

at t = 4] 

[Task: C2 Ends execution 


at t = 5] 

[Task: SI Ends Suspension on behalf of: 

Cl 

at t = 6] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 6] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 7] 

[Task: Cl Begins execution 


at t = 7] 

[Task: Cl Ends execution 


at t = 8] 


Test Complete ****—..* 


Figure B-9 Expected Events for Bl_06 


CMU/SEI-92-TR-1 


69 





[Task: Cl Begins execution 


at t = 1 ] 

[Task: Cl Ends execution 


at t = 2] 

[Task: Cl Calls server: 

SI 

at t = 2] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 2] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 3] 

[Task: SI Begins Suspension on behalf of: 

Cl 

at t = 3] 

[Task: C2 Begins execution 


at t = 3] 

[Task: C2 Ends execution 


at t = 4] 

[Task: C2 Calls server: 

S2 

at t = 4] 

[Task: S2 Begins execution on behalf of: 

C2 

at t = 4] 

[Task: SI Ends Suspension on behalf of: 

Cl 

at t = 5] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 5] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 6] 

[Task: Cl Begins execution 


at t = 6] 

[Task: Cl Ends execution 


at t - 7] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 8] 

[Task: C2 Begins execution 


at t = 8] 

[Task: C2 Ends execution 


at t = 9] 


******************* jggj Complete ******************* 


Figure B-10 Expected Events for Bl_07 


70 


CMU/SEI-92-TR-1 




[Task: Cl Begins execution 


at t = 1 ] 

[Task: Cl Ends execution 


at t = 2] 

[Task: Cl Calls server: 

SI 

at t = 2] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 2] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 3] 

[Task: Cl Begins execution 


at t = 3] 

[Task: Cl Ends execution 


at t = 4] 

[Task: C2 Begins execution 


at t = 4] 

[Task: C2 Ends execution 


at t = 5] 

[Task: C2 Calls server: 

SI 

at t = 5] 

[Task: Si Begins execution on behalf of: 

C2 

at t = 5] 

[Task: SI Ends execution on behalf of: 

C2 

at t = 6] 

[Task: C2 Begins execution 


at t = 6] 

[Task: C2 Ends execution 


at t = 7] 


Test Complete 


Figure B-11 Expected Events for Bl_08 


CMU/SEI-92-TR-1 


71 





[Task: C5 Begins execution 


att = 1] 

[Task: C5 Ends execution 


at t = 2] 

[Task: C5 Calls server: 

SI 

at t = 2] 

[Task: SI Begins execution on behalf of: 

C5 

at t = 2] 

[Task: C4 Begins execution 


at t = 3] 

[Task: C4 Ends execution 


at t = 4] 

[Task: C4 Calls server: 

S2 

at t = 4] 

[Task: S2 Begins execution on behalf of: 

C4 

at t = 4] 

[Task: C3 Begins execution 


at t = 5] 

[Task: C2 Begins execution 


at t = 6] 

[Task: C2 Ends execution 


at t = 7] 

[Task: C2 Calls server: 

SI 

at t = 7] 

[Task: Cl Begins execution 


at t = 8] 

[Task: Cl Ends execution 


at t * 9] 

[Task: Cl Calls server: 

S2 

at t = 9] 

[Task: S2 Ends execution on behalf of: 

C4 

at t = 10] 

[Task: S2 Calls server: 

SI 

at t = 10] 

[Task: SI Ends execution on behalf of: 

C5 

at t = 12] 

[Task: SI Begins execution on behalf of: 

S2 

att = 12] 

[Task: SI Ends execution on behalf of: 

S2 

at t = 14] 

[Task: S2 Begins execution on behalf of; 

C4 

att = 14] 

[Task: S2 Ends execution on behalf of: 

C4 

at t = 16] 

[Task: S2 Begins execution on behalf of: 

Cl 

at t = 16] 

[Task: S2 Ends execution on behalf of: 

Cl 

att = 17] 

[Task: Cl Begins execution 


att = 17] 

[Task: Cl Ends execution 


att = 18] 

[Task: SI Begins execution on behalf of: 

C2 

att = 18] 

[Task: SI Ends execution on behalf of: 

C2 

att = 19] 

[Task: C2 Begins execution 


att = 19] 

[Task: C2 Ends execution 


at t = 20] 

[Task: C3 Ends execution 


att = 21] 

[Task: C4 Begins execution 


att = 21] 

[Task: C4 Ends execution 


at t = 22] 

[Task: C5 Begins execution 


at t = 22] 

[Task: C5 Ends execution 


at t = 23] 

******************* jgg| Complete ******************* 




Figure B-12 Expected Events for Bl_09 


72 


CMU/SEI-92-TR-1 





[Task: C5 Begins execution 


at t = 1] 

[Task: C5 Ends execution 


at t = 2] 

[Task: C5 Calls server: 

SI 

at t = 2] 

[Task: SI Begins execution on behalf of: 

C5 

at t = 2] 

[Task: SI Ends execution on behalf of: 

C5 

at t = 5] 

[Task: SI Calls server: 

S2 

at t = 5] 

[Task: S2 Begins execution on behalf of: 

SI 

at t = 5] 

[Task: C4 Begins execution 


at t = 6] 

[Task: C4 Ends execution 


at t = 7] 

[Task: C4 Calls server: 

S2 

at t = 7] 

[Task: C3 Begins execution 


at t = 8] 

[Task: C3 Ends execution 


at t = 9] 

[Task: C3 Calls server: 

S3 

at t = 9] 

[Task: S3 Begins execution on behalf of: 

C3 

at t = 9] 

[Task: C2 Begins execution 


at t = 10] 

[Task: C2 Ends execution 


at t = 11] 

[Task: C2 Calls server: 

S4 

at t = 11] 

[Task: S4 Begins execution on behalf of: 

C2 

at t = 11] 

[Task: S4 Ends execution on behalf of: 

C2 

at t = 12] 

[Task: C2 Begins execution 


at t = 12] 

[Task: C2 Ends execution 


at t = 13] 

[Task: Cl Begins execution 


att= 14] 

[Task: Cl Ends execution 


at t = 15] 

[Task: Cl Calls server: 

S3 

at t = 15] 

[Task: S3 Ends execution on behalf of: 

C3 

at t = 16] 

[Task: S3 Calls server: 

S4 

at t = 16] 

[Task: S4 Begins execution on behalf of: 

S3 

at t = 16] 

[Task: S4 Ends execution on behalf of: 

S3 

att = 19] 

[Task: S3 Begins execution on behalf of: 

C3 

att = 19] 

[Task: S3 Ends execution on behalf of: 

C3 

at t = 22] 

[Task: S3 Begins execution on behalf of: 

Cl 

at t = 22] 

[Task: S3 Ends execution on behalf of: 

Cl 

at t = 23] 

[Task: S3 Calls server: 

S4 

at t = 23] 

[Task: S4 Begins execution on behalf of: 

S3 

at t = 23] 

[Task: S4 Ends execution on behalf of: 

S3 

at t = 24] 

[Task: S3 Begins execution on behalf of: 

Cl 

at t = 24] 

[Task: S3 Ends execution on behalf of: 

Cl 

at t = 25] 

[Task: Cl Begins execution 


at t = 25] 

[Task: Cl Ends execution 


at t = 26] 

[Task: C3 Begins execution 


at t = 26] 

[Task: C3 Ends execution 


at t = 27] 

[Task: S2 Ends execution on behalf of: 

SI 

at t = 28] 

[Task: S2 Begins execution on behalf of: 

C4 

at t = 28] 

[Task: S2 Ends execution on behalf of: 

C4 

at t = 29] 

[Task: C4 Begins execution 


at t = 29] 

[Task: C4 Ends execution 


at t = 30] 

[Task: SI Begins execution on behaif of: 

C5 

at t = 30] 

[Task: SI Ends execution on behalf of: 

C5 

at t = 33] 

[Task: C5 Begins execution 


at t = 33] 

[Task: C5 Ends execution 


at t = 34] 


Test Complete * 


Figure B-13 Expected Events for BI_10 


CMU/SEI-92-TR-1 


73 








[Task: C2 Calls server: 

S2 

at t = 1] 

[Task: S2 Begins execution on behalf of: 

C2 

att = 1] 

[Task: Cl Begins execution 


at t = 2] 

[Task: Cl Ends execution 


at t = 3] 

[Task: Cl Calls server: 

SI 

at t = 3] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 4] 

[Task: Si Begins execution on behalf of: 

Cl 

at t = 4] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 5] 

[Task: SI Calls server: 

S2 

at t = 5] 

[Task: S2 Begins execution on behalf of: 

SI 

at t = 5] 

[Task: S2 Ends execution on behalf of: 

SI 

at t = 6] 

[Task: Si Begins execution on behalf of: 

Cl 

at t = 6] 

[Task: Si Ends execution on behalf of: 

Cl 

at t = 7] 

[Task: Cl Begins execution 


at t = 7] 

[Task: Cl Ends execution 


at t = 8] 

[Task: C2 Begins execution 


at t = 8] 

[Task: C2 Ends execution 


at t = 9] 

******************* fggf Complete ******************* 




Figure B-14 Expected Events for PC_01 


74 


CMU/SEI-92-TR-1 




[Task: C2 Begins execution 


at t = 1] 

[Task: C2 Ends execution 


at t = 2] 

[Task: C2 Calls server: 

S2 

at t = 2] 

[Task: S2 Begins execution on behalf of: 

C2 

at t = 2] 

[Task: Cl Begins execution 


at t = 3] 

[Task: Cl Ends execution 


at t = 4] 

[Task: Cl Calls server: 

SI 

at t = 4] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 5] 

[Task: S2 Calls server: 

SI 

at t = 5] 

[Task: SI Begins execution on behalf of: 

S2 

at t = 5] 

[Task: SI Ends execution on behalf of: 

S2 

at t = 7] 

[Task: S2 Begins execution on behalf of: 

C2 

at t = 7] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 9] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 9] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 11] 

[Task: SI Calls server: 

S2 

att = 11] 

[Task: S2 Begins execution on behalf of: 

SI 

at t = 11 ] 

[Task: S2 Ends execution on behalf of: 

SI 

at t = 13] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 13] 

[Task: Si Ends execution on behalf of: 

Cl 

at t = 15] 

[Task: Cl Begins execution 


att = 15] 

[Task: Cl Ends execution 


att = 16] 

[Task: C2 Begins execution 


att = 16] 

[Task: C2 Ends execution 


at t = 17] 


Test Complete ******************* 


Figure B-15 Expected Events for PC_02 


CMU/SEI-92-TR-1 


75 






[Task: C3 Calls server: 

SI 

at t = 1] 

[Task: SI Begins execution on behalf of: 

C3 

at t = 1 ] 

[Task: C2 Begins execution 


at t = 2] 

[Task: C2 Ends execution 


at t = 3] 

[Task: C2 Calls server: 

S2 

at t = 3] 

[Task: Cl Begins execution 


at t = 4] 

[Task: Cl Ends execution 


at t = 5] 

[Task: Cl Calls server: 

SI 

at t = 5] 

[Task: SI Ends execution on behalf of: 

C3 

at t = 6] 

[Task: SI Calls server: 

S2 

at t = 6] 

[Task: S2 Begins execution on behalf of: 

SI 

at t = 6] 

[Task: S2 Ends execution on behalf of: 

SI 

at t = 9] 

[Task: SI Begins execution on behalf of: 

C3 

at t = 9] 

[Task: SI Ends execution on behalf of: 

C3 

at t = 12] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 12] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 13] 

[Task: SI Calls server: 

S2 

at t = 13] 

[Task: S2 Begins execution on behalf of: 

SI 

att= 13] 

[Task: S2 Ends execution on behalf of: 

SI 

att = 14] 

t SI Begins execution on behalf of: 

Cl 

at t = 14] 

[Task: SI Ends execution on behalf of: 

Cl 

att = 15] 

[Task: Cl Begins execution 


att = 15] 

[Task: Cl Ends execution 


att = 16] 

[Task: S2 Begins execution on behalf of: 

C2 

att = 16] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 17] 

[Task: S2 Calls server: 

SI 

at t = 17] 

[Task: SI Begins execution on behalf of: 

S2 

att = 17] 

[Task: SI Ends execution on behalf of: 

S2 

att = 18] 

[Task: S2 Begins execution on behalf of: 

C2 

at t = 18] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 19] 

[Task: C2 Begins execution 


att= 19] 

[Task: C2 Ends execution 


at t = 20] 

[Task: C3 Begins execution 


at t = 20] 

[Task: C3 Ends execution 


at t = 21] 


Test Complete 


Figure B-17 Expected Events for PC_04 


CMU/SEI-92-TR-1 


77 







[Task: C2 Begins execution 


at t = 1] 

[Task: C2 Ends execution 


at t = 2] 

[Task: C2 Calls server: 

S2 

at t = 2] 

[Task: S2 Begins execution on behalf of: 

C2 

at t = 2] 

[Task: Cl Begins execution 


at t = 3] 

[Task: Cl Ends execution 


at t = 4] 

[Task: Cl Calls server: 

SI 

at t = 4] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 4] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 5] 

[Task: Cl Begins execution 


at t = 5] 

[Task: Cl Ends execution 


at t = 6] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 7] 

[Task: C2 Begins execution 


at t = 7] 

[Task: C2 Ends execution 


at t = 8] 


Test Complete ******************* 


Figure B-18 Expected Events for PC_05 


78 


CMU/SEI-92-TR-1 





[Task: C3 Calls server: 

S2 

att = 1] 

[Task: S2 Begins execution on behalf of: 

C3 

at t = 1] 

[Task: C2 Begins execution 


at t = 2] 

[Task: C2 Ends execution 


at t = 3] 

[Task: C2 Calls server: 

S2 

at t = 3] 

[Task: Cl Begins execution 


at t = 4] 

[Task: Cl Ends execution 


at t = 5] 

[Task: Cl Calls server: 

SI 

at t = 5] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 5] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 6] 

[Task: Cl Begins execution 


at t = 6] 

[Task: Cl Ends execution 


at t = 7] 

[Task: S2 Ends execution on behalf of: 

C3 

at t = 8] 

[Task: S2 Begins execution on behalf of: 

C2 

at t = 8] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 9] 

[Task: C2 Begins execution 


at t = 9] 

[Task: C2 Ends execution 


at t = 10] 

[Task: C3 Begins execution 


at t = 10] 

[Task: C3 Ends execution 


at t = 11] 


Test Complete ******************* 


Figure B-19 Expected Events for PC_06 


CMU/SEI-92-TR-1 


79 






[Task: Cl Begins execution 


at t = 1 ] 

[Task: Cl Ends execution 


at t = 2] 

[Task: Cl Calls server: 

SI 

at t = 2] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 2] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 3] 

[Task: SI Begins Suspension on behalf of: 

Cl 

at t = 3] 

[Task: C2 Begins execution 


at t = 3] 

[Task: C2 Ends execution 


at t = 4] 

[Task: C2 Calls server: 

S2 

at t = 4] 

[Task: SI Ends Suspension on behalf of: 

Cl 

at t = 5] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 5] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 6] 

[Task: Cl Begins execution 


at t = 6] 

[Task: Cl Ends execution 


at t = 7] 

[Task: S2 Begins execution on behalf of: 

C2 

at t = 7] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 9] 

[Task: C2 Begins execution 


at t = 9] 

[Task: C2 Ends execution 


att = 10] 


******************* “pggf Complete ******************* 


Figure B-20 Expected Events for PC_07 


80 


CMU/SEI-92-TR-1 







[Task: C3 Calls server: 

S3 

at t = 1 ] 

[Task: S3 Begins execution on behalf of: 

C3 

at t = 1] 

[Task: C2 Begins execution 


at t = 2] 

[Task: C2 Ends execution 


at t = 3] 

[Task: C2 Calls server: 

S2 

at t = 3] 

[Task: Cl Begins execution 


at t = 4] 

[Task: Cl Ends execution 


at t = 5] 

[Task: Cl Calls server: 

SI 

at t = 5] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 5] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 6] 

[Task: SI Calls server: 

S2 

at t = 6] 

[Task: S2 Begins execution on behalf of: 

SI 

at t = 6] 

[Task: S2 Ends execution on behalf of: 

SI 

at t = 7] 

[Task: Si Begins execution on behalf of: 

Cl 

at t = 7] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 8] 

[Task: Cl Begins execution 


at t * 8] 

[Task: Cl Ends execution 


at t = 9] 

[Task: S3 Ends execution on behalf of: 

C3 

att = 10] 

[Task: S3 Calls server: 

SI 

att = 10] 

[Task: SI Begins execution on behalf of: 

S3 

at t = 10] 

[Task: SI Ends execution on behalf of: 

S3 

att = 13] 

[Task: S3 Begins execution on behalf of: 

C3 

att = 13] 

[Task: S3 Ends execution on behalf of: 

C3 

att = 16] 

[Task: S2 Begins execution on behalf of: 

C2 

att = 16] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 17] 

[Task: S2 Calls server: 

S3 

att = 17] 

[Task: S3 Begins execution on behalf of: 

S2 

att= 17] 

[Task: S3 Ends execution on behalf of: 

S2 

att = 18] 

[Task: S2 Begins execution on behalf of: 

C2 

att = 18] 

[Task: S2 Ends execution on behalf of: 

C2 

att = 19] 

[Task: C2 Begins execution 


att = 19] 

[Task: C2 Ends execution 


at t = 20] 

[Task: C3 Begins execution 


at t = 20] 

[Task: C3 Ends execution 


at t = 21] 

Test Complete 




Figure B-21 Expected Events for PC_08 


CMU/SEI-92-TR-1 


81 





[Task: C3 Calls server: 

S3 

at t = 1] 

[Task: S3 Begins execution on behalf of: 

C3 

at t = 1 ] 

[Task: C2 Begins execution 


at t = 2] 

[Task: C2 Ends execution 


at t = 3] 

[Task: C2 Calls server: 

S2 

at t = 3] 

[Task: S3 Ends execution on behalf of: 

C3 

at t = 4] 

[Task: S3 Calls server: 

St 

at t = 4] 

[Task: SI Begins execution on behalf of: 

S3 

at t = 4] 

[Task: Cl Begins execution 


at t = 5] 

[Task: Cl Ends execution 


at t = 6] 

[Task: Cl Calls server: SI 


at t = 6] 

[Task: SI Ends execution on behalf of: 

S3 

at t = 7] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 7] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 8] 

[Task: SI Calls server: 

S2 

at t = 8] 

[Task: S2 Begins execution on behalf of: 

SI 

at t = 8] 

[Task: S2 Ends execution on behalf of: 

SI 

at t = 9] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 9] 

[Task: SI Ends execution on behalf of: 

Cl 

att = 10] 

[Task: Cl Begins execution 


at t = 10] 

[Task: Cl Ends execution 


att= 11] 

[Task: S3 Begins execution on behalf of: 

C3 

att = 11] 

[Task: S3 Ends execution on behalf of: 

C3 

att = 13] 

[Task: S2 Begins execution on behalf of: 

C2 

at t = 13] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 15] 

[Task: S2 Calls server: 

S3 

att = 15] 

[Task: S3 Begins execution on behalf of: 

S2 

att = 15] 

[Task: S3 Ends execution on behalf of: 

S2 

att = 17] 

[Task: S2 Begins execution on behalf of: 

C2 

at t = 17] 

[Task: S2 Ends execution on behalf of: 

C2 

att = 19] 

[Task: C2 Begins execution 


att = 19] 

[Task: C2 Ends execution 


at t = 20] 

[Task: C3 Begins execution 


at t = 20] 

[Task: C3 Ends execution 


at t = 21] 


Test Complete ******************* 


Figure B-22 Expected Events for PC_09 


82 


CMU/SEI-92-TR-1 





[Task: C2 Calls server: 

S2 

at t = 1 ] 

[Task: S2 Begins execution on behalf of: 

C2 

at t = 1 ] 

[Task: Cl Begins execution 


at t = 2] 

[Task: Cl Ends execution 


at t = 3] 

[Task: Cl Calls server: 

SI 

at t = 3] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 4] 

[Task: S2 Begins Suspension on behalf of: 

C2 

at t - 4] 

[Task: S2 Ends Suspension on behalf of: 

C2 

at t = 6] 

[Task: S2 Begins execution on behalf of: 

C2 

at t = 6] 

[Task: S2 Ends execution on behalf of: 

C2 

at t = 8] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 8] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 9] 

[Task: SI Calls server: 

S2 

at t = 9] 

[Task: S2 Begins execution on behalf of: 

SI 

at t = 9] 

[Task: S2 Ends execution on behalf of: 

SI 

at t = 10] 

[Task: S2 Begins Suspension on behalf of: 

SI 

at t = 10] 

[Task: C2 Begins execution 


at t = 10] 

[Task: C2 Ends execution 


at t = 11] 

[Task: S2 Ends Suspension on behalf of: 

SI 

att= 12] 

[Task: S2 Begins execution on behalf of: 

SI 

att = 12] 

[Task: S2 Ends execution on behalf of: 

SI 

at t = 13] 

[Task: SI Begins execution on behalf of: 

Cl 

att = 13] 

[Task: SI Ends execution on behalf of: 

Cl 

att = 14] 

[Task: Cl Begins execution 


at t = 14] 

[Task: Cl Ends execution 


at t = 15] 


Test Complete ******************* 


Figure B-23 Expected Events for PC_10 


CMU/SEI-92-TR-1 


63 






[Task: C5 Begins execution 


at t = 1 ] 

[Task: C5 Ends execution 


at t = 2] 

[Task: C5 Calls server: 

SI 

at t = 2] 

[Task: SI Begins execution on behalf of: 

C5 

at t = 2] 

[Task: C4 Begins execution 


at t = 3] 

[Task: C4 Ends execution 


at t = 4] 

[Task: C4 Calls server: 

S2 

at t = 4] 

[Task: C3 Begins execution 


at t = 5] 

[Task: C2 Begins execution 


at t = 6] 

[Task: C2 Ends execution 


at t = 7] 

[Task: C2 Calls server: 

SI 

at t = 7] 

[Task: Cl Begins execution 


at t = 8] 

[Task: Cl Ends execution 


at t = 9] 

[Task: Cl Calls server: 

S2 

at t = 9] 

[Task: S2 Begins execution on behalf of: 

Cl 

at t = 9] 

[Task: S2 Ends execution on behalf of: 

Cl 

att = 10] 

[Task: Cl Begins execution 


att = 10] 

[Task: Cl Ends execution 


at t = 11] 

[Task: SI Ends execution on behalf of: 

C5 

att= 12] 

[Task: SI Begins execution on behalf of: 

C2 

att= 12] 

[Task: SI Ends execution on behalf of: 

C2 

at t = 13] 

[Task: C2 Begins execution 


att = 13] 

[Task: C2 Ends execution 


att = 14] 

[Task: C3 Ends execution 


att = 15] 

[Task: S2 Begins execution on behalf of: 

C4 

att = 15] 

[Task: S2 Ends execution on behalf of: 

C4 

att = 17] 

[Task: S2 Calls server: 

SI 

at t = 17] 

[Task: SI Begins execution on behalf of: 

S2 

at t = 17] 

[Task: SI Ends execution on behalf of: 

S2 

at t = 19] 

[Task: S2 Begins execution on behalf of: 

C4 

at t = 19] 

[Task: S2 Ends execution on behalf of: 

C4 

att = 21] 

[Task: C4 Begins execution 


att = 21] 

[Task: C4 Ends execution 


at t = 22] 

[Task: C5 Begins execution 


at t = 22] 

[Task: C5 Ends execution 


at t = 23] 


Test Complete 


Figure B-24 Expected Events for PC_ 11 


84 


CMU/SEI-92-TR-1 






[Task: C5 Begins execution 


at t = 1] 

[Task: C5 Ends execution 


at t = 2] 

[Task: C5 Calls server: 

SI 

at t = 2] 

[Task: SI Begins execution on behalf of: 

C5 

at t = 2] 

[Task: SI Ends execution on behalf of: 

C5 

at t = 5] 

[Task: SI Calls server: 

S2 

at t = 5] 

[Task: S2 Begins execution on behalf of: 

SI 

at t = 5] 

[Task: C4 Begins execution 


at t = 6] 

[Task: C4 Ends execution 


at t = 7] 

[Task: C4 Calls server: 

S2 

at t = 7] 

[Task: C3 Begins execution 


at t = 8] 

[Task: C3 Ends execution 


at t = 9] 

[Task: C3 Calls server: 

S3 

at t = 9] 

[Task: S3 Begins execution on behalf of: 

C3 

at t = 9] 

[Task: C2 Begins execution 


at t = 10] 

[Task: C2 Ends execution 


at t = 11] 

[Task: C2 Calls server: 

S4 

at t = 11] 

[Task: S3 Ends execution on behalf of: 

C3 

at t = 13] 

[Task: S3 Calls server: 

S4 

at t = 13] 

[Task: S4 Begins execution on behalf of: 

S3 

at t = 13] 

[Task: Cl Begins execution 


att= 14] 

[Task: Cl Ends execution 


at t = 15] 

[Task: Cl Calls server: 

S3 

at t = 15] 

[Task: S4 Ends execution on behalf of: 

S3 

att = 17] 

[Task: S3 Begins execution on behalf of: 

C3 

att= 17] 

[Task: S3 Ends execution on behalf of: 

C3 

at t = 20] 

[Task: S3 Begins execution on behalf of: 

Cl 

at t = 20] 

[Task: S3 Ends execution on behalf of: 

Cl 

at t = 21] 

[Task: S3 Calls server: 

S4 

at t = 21] 

[Task: S4 Begins execution on behalf of: 

S3 

at t = 21] 

[Task: S4 Ends execution on behalf of: 

S3 

at t = 22] 

[Task: S3 Begins execution on behalf of: 

Cl 

at t = 22] 

[Task: S3 Ends execution on behalf of: 

Cl 

at t = 23] 

[Task: Cl Begins execution 


at t = 23] 

[Task: Cl Ends execution 


at t = 24] 

[Task: S4 Begins execution on behalf of: 

C2 

at t = 24] 

[Task: S4 Ends execution on behalf of: 

C2 

at t = 25] 

[Task: C2 Begins execution 


at t = 25] 

[Task: C2 Ends execution 


at t = 26] 

[Task: C3 Begins execution 


at t = 26] 

[Task: C3 Ends execution 


at t = 27] 

[Task: S2 Ends execution on behalf of: 

SI 

at t = 28] 

[Task: S2 Begins execution on behalf of: 

C4 

at t = 28] 

[Task: S2 Ends execution on behalf of: 

C4 

at t = 29] 

[Task: C4 Begins execution 


at t = 29] 

[Task: C4 Ends execution 


at t = 30] 

[Task: SI Begins execution on behalf of: 

C5 

at t = 30] 

[Task: Si Ends execution on behalf of: 

C5 

at t = 33] 

[Task: C5 Begins execution 


at t * 33] 

[Task: C5 Ends execution 


at t = 34] 


Test Complete 


Figure B-25 Expected Events for PC_12 


CMU/SEI-92-TR-1 


85 






[Task: C5 Begins execution 


at t = 1 ] 

[Task: C5 Ends execution 


at t = 2] 

[Task: C5 Calls server: 

SI 

at t = 2] 

[Task: SI Begins execution on behalf of: 

C5 

at t = 2] 

[Task: C4 Begins execution 


at t = 3] 

[Task: C3 Begins execution 


at t = 4] 

[Task: C3 Ends execution 


at t = 5] 

[Task: C3 Calls server: 

S2 

at t = 5] 

[Task: C2 Begins execution 


at t = 6] 

[Task: Cl Begins execution 


at t = 7] 

[Task: Cl Ends execution 


at t = 8] 

[Task: Cl Calls server: 

SI 

at t = 8] 

[Task: SI Ends execution on behalf of: 

C5 

at t = 9] 

[Task: SI Begins execution on behalf of: 

Cl 

at t = 9] 

[Task: SI Ends execution on behalf of: 

Cl 

at t = 10] 

[Task: Cl Begins execution 


at t = 10] 

[Task: Cl Ends execution 


at t = 11] 

[Task: C2 Ends execution 


at t = 12] 

[Task: S2 Begins execution on behalf of: 

C3 

at t = 12] 

[Task: S2 Ends execution on behalf of: 

C3 

at t = 13] 

[Task: C3 Begins execution 


att= 13] 

[Task: C3 Ends execution 


att= 14] 

[Task: C4 Ends execution 


at t = 15] 

[Task: C5 Begins execution 


att = 15] 

[Task: C5 Ends execution 


at t == 16] 


Test Complete ******************* 


Figure B-26 Expected Events for PC_13 


86 


CMU/SEI-92-TR-1 



Appendix C Example of Test Specification 


—++. . 

-NAME. 

- tstchb.ada 

-TITLE. 

- TeST_CHaracteristics Body 
-DESCRIPTION. 

-.VERSION. 

- 4.2 modified on 2/28/91 
-COMMENTS. 


-. EXTERNAL_PAC KAGES. 

- PACKAGE NAME PARAMETERS 

- Generator_Stnjcture 

- Customize 

-. INTERN AL_PACKAGES. 

- PACKAGE NAME PARAMETERS 


-++-................................................... 

with Generator_Structure; 
uee Generator_Structure; 
package body Test_Characteristics la 
begin 

Test_Suite := 

(Number_Of_Tests => 25, 

Test => 

(1 «> • • 

8 => 

; (Number_Of_Tasks =>5, 

\ ;Main_Unit_Name => Set_String Cbi_05'), 

; :Generated_File => Set_String ('bi_05.ada’), 

; ^Scheduling => Bl, 

: .‘Tasks => ((Task_Type => Client, 

; : Task_Name => Cl, 

Offset_Start_Time => 6, 

: Priority => P10, 

: : Execution_Pattem => 

| (Number_Of_E vents => 3, 

; : Event_Array => 

; • (1 => (Client_Execution, 1), 

: j 2 => (Server_Call, SI, El), 

; : 3 => (Client Execution, 1) 

i : ) 

: : ) 

; : >. 


USAGE 


USAGE 


CMU/SEI-92-TR-1 


87 














(Task_Type => Client, 

Task_Name »> C2, 

Offset_Start_Time => 5, 

Priority => P9, 

Execution_Pattem => 

(Number_Of_Events => 1, 

Event_Array => 


(1 => (Client_Execution, 2) 
) 

) 

). 


(Task_Type => Client, 

Task_Name => C3, 

Offset_Start_Time => 1, 

Priority => P8, 

Execution_Pattem => 

(NumberOfEvents => 3, 

Event_Array => 


(1 => (Client_Execution, 1), 

2 => (Server_Call, SI, E2), 

3 => (Client_Execution, 1) 

) 

) 

). 

(Task_Type => Server, 

;Task_Name => SI, 

:Entries => 

; (Number_Of_Entries => 2, 

j -Entry Array => 

; : |1 => (Entry_Name =>E1, 

; ; : 1 Execution_Pattem *> 

I '■ • ; (Number_Of_Events => 1, 

; : : \ Event_Array => 

\ i (1 => (Server_Execution, t) 

: : : ; ) 

: : : : ) 

I ; ; ). 

; ; :2 => |Entry_Name => E2, 

J • ; ; Execution_Pattem => 

: I \ (Number_Of_Events => 3, 

; ; ; I Event Anay => 

1 • ; : (1 => (Server_Execution, 2), 

; : : ; 2 => (Server_Cal! S2, El), 

: 3 => (Server_Execution, 2) 

: ; j : ) 

: : : '• ) 

: : : ) 

: : ) 

i ) 

). 


CMU/SEI-92-TR-1 












(T ask_T ype => Server, 

:Task_Name =>S2, 

; Entries => 

; (Number_Of_Entries => 1, 

; '■ Entry_Array => 

• : (1 => (Entry_Name =>E1, 

: • : : Executk>n_Pattem => 

• : • • (Number_Of_Events => 1, 

j • : : Event_Array => 

; : ; ■ (1 => (Server_Execution, 2) 

: : ! ■ ) 

: : : : ) 


25 =>... 

) ); 

end Test_Characteristics; 


CMU/SEI-92-TR-1 


89 













90 


CMU/SEI-92-TR-1 





Appendix D Code for Test Case Bl_05 

This appendix shows the code generated for test case Bl_05. The code is generated in a 
single file. We have split this file into subsections to help the reader identify the various 
generated components. The specification that was sent to the generator is given in Appen¬ 
dix C on page 87. The diagram describing this test case is given in Figure A-9 on page 36. 


D.1 BI_05_Test_Harness Package Specification 


—++ .. 

- Test-case file 

- built by Generator tool 
—++*************************‘ 


with System; 

with Calendar; use Calendar; 
with Hamess_Constants; 
package bi_05_Test_Hamess Is 
procedure Start_Run(Start_Time: In TIME); 
task Test_Done Is 
entry Client_C1_Done; 
entry Client_C2_Done; 
entry Client_C3_Done; 
entry Complete; 

pragma Priority (Hame$s_Constants.Test_Done_Priority); 
end Test_Done; 
end bi_05_Test_Hamess; 


D.2 BI_05_Client_C1_Package Specification 


with System; 

with Calendar; use Calendar; 
with Harness_Constants; 
package bi_05_Client_C1_Package Is 
task C1_Task Is 

entry START(Start_Time : In TIME); 
pragma Priority (Hamess_Constants.P10); 
end C1_Task; 

end bi_05_Client_C1_Package; 


D.3 BI_05_Client_C2_Package Specification 

with System; 

with Calendar; use Calendar; 
with Harness_Constants; 
package bi_05_Client_C2_Package Is 
task C2_Task Is 

entry START(Start_Time : In TIME); 
pragma Priority (Hamess_Constants.P9); 
end C2_Task; 

end bi_05_Client_C2_Package; 


CMU/SEI-92-TR-1 


91 







D.4 Bl_05_Client_C3_Package Specification 

with System; 

with Calendar; use Calendar; 
with Harness_Constants; 
package bi_05_Client_C3_Package la 
task C3_Task Is 

entry START(Start_Time : In TIME); 
pragma Priority (Hamess_Constants.PS); 
end C3_Task; 

end bi_05_Client_C3_Package; 


D.5 BI_05_Server_S1_Package Specification 

with Calendar; 
with Vendor_Specifics; 

with Harness_Constants; use Harness_Constants; 
package bi 05_Server_S1 Package la 
task S1_Task la 

entry Get_ld(Task_ld ; out Vendor_Specifics.Task_ld); 
entry El (Task_Number: In Task_IO_Type); 
entry E2 (Task_Number: in TaskJD_Type); 
end S1_Task; 

end bi_05_Server_S 1 _Package; 


D.6 Bl_05 Server_S2_Package Specification 

with Calendar; 
with Vendor_Specifics; 

with Harness_Constants; use Harness Constants; 
package bi_05_Server_S2_Package la 
task S2_Task Is 

entry Get_ld(Task_ld : out Vendor_Specifics.Task_ld); 
entry El (Task_Number; In Task_ID_Type); 
end S2_Task; 

end bi_05_Server_S2_Package; 


92 


CMU/SEI-92-TR-1 








D.7 BI_05_Test_Harness Package Body 

with System; 
with IO_Pkgs; 
with Calendar; 
with Harness_Constants; 
with Vendor_Specifics; 
with bi_05_Client_C1_Package; 
with bi_05_Client_C2_Package; 
with bi_05_Client_C3_Package; 
with bi_05_Server_S1_Package; 
with bi_05_Server_S2_Package; 
package body bi_05_Test_Harness la 
S1_Task_ld: Vendor_Specifics.TaskJd; 

S2_Task_ld: Vendor_Specifics.TaskJd; 
procedure Start_Run(Start_Time : In TIME) is 
procedure Set_Server_Priorities is 
use Calendar; 
begin 


- Set the priority for each server, and, if PCP, set 

- the priority ceiling. 


Vendor_Spedfics.change_priority( 

S1_Task_ld, 

Hamess_Constants.Server_Priority); 

VendorSpedfics.change_priority( 

S2_Task_ld, 

Hamess_ConstantsServer_Pnority); 
end Set_Server_Priorities; 

begin 

bi_05_Server_S1_Package.S1_Task.Get_ld( S1_Task_id); 
bi_05_Server_S2_Package.S2_Task.Get_ld( S2_Task_id); 
Set_Server_Priorities; 

bi_05_Client_C1_Package.C1_Task.START(Start_Time); 
bi_05_Client_C2_Package.C2_Task.START(Start_Time); 
bi_05_Client_C3_Package.C3_Task.START(Start_Time); 
exception 
when OTHERS => 

IO_Pkgs.Txt_lo.Put_LineC** Unexpected Exception in Start_Run **'); 
end Start_Run; 
task body Test_Done la 
begin 


- Wait for each client to finish 


accept Client_C1_Done 
accept Client_C2_Done 
accept Client_C3_Done 


- Synchronize with Main program (Test is Done) 


accept Complete; 
exception 
when OTHERS => 

lO.Pkgs.TxtJo.PutJ.ineC** Unexpected Exception in Test_Dor>e Task **’); 
end Test_Done; 
end bi_05_Test_Hamess; 


CMU/SEI-92-TR-1 


93 









D.8 BI_05_Client_C1_Package Body 

with bi_05_Test_Hamess; 
with Harness_Support; 
with IO_Pkgs; 

with Harness_E ve n t_Log_Manager; uu Hamess_Event_Log_Manager; 
with Harness__Constants; use Hamess_Constants; 
with bi_05_Server_S1_Package; 
package body bi_05_Client_C1_Package la 
task body C1_Task Is 

bit : constant DURATION := 6.0; 

Exec_Time_1 : constant DURATION := 1.0; 

Exec_Time_2 ; constant DURATION := 1.0; 

C1_Task_Start: TIME; 

begin 


- Wait for Start_Time (Reference to time = 0) & then 

- Suspend client until it is time to begin execution 


accept START(Stait_Time . In TIME) do 
C1_Task_Start := Start_Time + bit; 
end START; 

Hamess_Support.Suspend_Task(C 1 _Task_Start); 


- Client execution 


Log_Event(C1. None, Client_Exec_Begins); 
Hamess_SupportSpend_Time(Exec_Time_1); 
Log_Event(C1. None, Client_Exec_Ends); 

- Call Server 


Log_Event(C1, SI, Server_Call_Begins); 
bi_05_Server_S1_Package.S1_Task.El(C1); 

- Client execution 


Log_Event(Cl, None, Client_Exec_Begins); 
Hamess_Support.Spend_Time(Exec_Time_2); 

Log_Event(Cl, None. Client_Exec_Ends); 

bi_05_Test_Hamess.Test_Done.Client_C1_Done; - Signal Client Finished 
exception 
when OTHERS => 

IO_Pkgs.Txt_lo.Put_Line<"* Unexpected Exception in bi_05_Client_C1 Task**’); 
end C1_Task; 

end bi_05_Client_C1_Package; 


94 


CMU/SEI-92-TR-1 






D.9 BI_05_Client_C2_Package Body 

with bi_05_Test_Hamess; 
with Harness_Support; 
with IO_Pkgs; 

with Harness_Event_Log_Manager; uh Hamess_Event_Log_Manager; 
with Harness_Constants; use Hamess_Constants; 
package body bi_05_Client_C2_Package la 
task body C2_Task la 

lnit : conatant DURATION := 5.0; 

Exec_Time 1 : conatant DURATION := 2.0; 

C2_Task_Start: TIME; 

begin 

- Wait for Start_Time (Reference to time = 0) & then 

- Suspen. client until it is time to begin execution 

accept START(Start_Time : In TIME) do 
C2_Task_Start ;= Start_Time + lnit; 
end START; 

Hamess_Support.Suspend_Task(C2_Task_Start); 

- Client execution 

Log_Event(C2, None. Client_Exec_Begins); 

HamessSupport Spend_Time(Exec_Time_1); 

Log_Event(C2, None, Client_Exec_Ends); 

bi_05_Test_Hamess.Test_Done.Client_C2_0one; - Signal Client Finished 
exception 
when OTHERS => 

IO_Pkgs.TxtJo.Put_Line(”' Unexpected Exception in bi_05_Client_C2 Task **’); 
end C2_Task; 

end bi_05_Client_C2_Package; 


CMU/SEI-92-TR-1 


95 




D.10 BI_05_C!ient_C3_Package Body 

with bi_05_Test_Hamess; 
with Harness_Support; 
with IO_Pkgs; 

with Harness_Event_Log_Manager; um Hamess_Event_Log_Manager; 
with Harness_Constants; use Hamess_Constants; 
with bi_05_Server_S 1 _Package; 
package body bi_05_Client_C3_Package Is 
task body C3_Task Is 

Init : constant DURATION := 1.0; 

Exec_Time_1 : constant DURATION := 1.0; 

Exec_Time_2 : constant DURATION := 1.0; 

C3_Task_Start: TIME; 

begin 


- Wait for StartJTime (Reference to time = 0) & then 

- Suspend client until it is lime to begin execution 


accept START(Start_Time ; in TIME) do 
C3_Task_Start := StartJTime + Init; 
end START; 

Hamess_Support. SuspendTask(C3_Task_Start); 


-- Client execution 


Log_Event(C3, None, Client_Exec_Begins); 
Hamess_SupportSpend_Time(Exec_Time_1); 
Log_Event(C3, None, Client_Exec_Ends); 

- Call Server 


Log_Event(C3, Si. Server_Call_Begins); 
b J05_Server_S 1 _Package.S 1 _Task. E2(C3); 


- Client execution 

Log_Event(C3, None, Client_Exec_Begins); 
Hamess_Support.SpendTime(Exec_Time_2); 

Log_Event(C3, None, Client_Exec_Ends); 

bi_05_Test_Hamess.Test_Done.Client_C3_Done; - Signal Client Finished 

exception 
when OTHERS => 

IO_Pkgs.Txt_lo.Put_Une(~* Unexpected Exception in bi_05_C!ient_C3 Task ***); 
end C3_Task; 

end bi_05_Client_C3_Package; 


96 


CMU/SEI-92-TR-1 









D.11 BI_05_Server_S1_Package Body 

with Harness_Support; 

with Calendar; use Calendar; 

with Harness_Event_Log_Manager; use Hamess_Event_Log_Manager; 
with Harness_Constants; use Hamess_Constants; 
with bi_05_Server_S2_Package; 
package body bi_05_Server_S1_Package is 
task body S1_Task is 

Exec_Time_1: constant DURATION := 1.0; 

Exec_Time_2: constant DURATION := 2.0; 

Exec_Time_3: constant DURATION := 2.0; 

begin 


- Get my id 


accept Getjd (Taskjd : out Vendor_Specifics.Task_ld) do 
Taskjd := Vendor_Spedfics.Get_Task; 
end Getjd; 


- Endless loop servicing clients 


loop 

select 

accept El (Task_Number; in TaskJD_Type) do 


- Server Execution 

Log_Event(S1, TaskNumber, Server_Exec_8egins); 
Hamess_Support.Spend_Time(Exec_Time_1); 
Log_Event(S1, Task_Number, Server_Exec_Ends); 
end El; 
or 

accept E2 (Task Number . In TaskJDJType) do 


- Server Execution 


Log_Event(S1. Task_Number, Server_Exec_Begins); 
Hamess_Support.Spend_7ime(Exec_Time_2); 
Log_Event(S1. Task_Numoer, Server_Exec_Ends); 


- Server Call 


Log_Event(S1, S2. Server_Call_Begins); 
bi_05_Server_S2_Package.S2_Task.E1(S1); 


- Server Execution 


Log_Event(S1, Task_Number, Server_Exec_Begins); 
Hamess_Support.Spend_Time(Exec_Time_3); 
Log_Event(S1, Task_Number, Server_Exec_Ends); 
end E2; 
or 

terminate; - when server is no-longer Callable 

end select; 
end loop; 
end S1_Task; 

end bi_05_Server_S1_Package; 


CMU/SEI-92-TR-1 


97 






D.12 B1_05_Server_S2_Package Body 

with Harness_Support; 

with Calendar; use Calendar; 

with Harness_Event_Log_Manager; um Hamess_Event_Log_Manager; 
with HarnessConstants; use Hamess_Constants; 
package body bi_05_Server_S2_Package la 
taak body S2_Task Is 

Exec_Time_1: constant DURATION := 2.0; 

begin 


- Get my id 


accept Getjd (Task_ld : out Vendor_Specifics.Task_ld) do 
Taskjd := Vendor_Spedfics.Get_Task; 
end Getjd; 


- Endless loop servicing clients 


loop 

select 

accept El (Task_Number: In Task_ID_Type) do 


- Server Execution 


Log_Event(S2, TaskJMumber, Server_Exec_Begins); 
Hamess_Support.Spend_Ttme(Exec_Tlme_1); 
Log_Event(??, Task_Number, Server_Exec_Ends); 
end El; 
or 

terminate; - when server is no-longer Callable 
end select; 
end loop; 
end S2_Task; 

end bi_05_Server_S2_Package; 


D.13 Main Procedure for B! 05 


with bi_05_Test_Hamess; 

with Harness_Event_Log_Manager; 

with Harness_Constants; 

with Hamess_Support; 

with Calendar; use Calendar; 

procedure bi_05 Is 

pragma Priority (Hamess_Constants.Main_Priority); 

Start_Time: TIME; 
begin 

Hamess_SupportCalibrate_Spend_Time; 

Hamess_Event_Log_Manager.lnitialize(Start_Time); 

bi_05_Test_Hamess.Start_Run{Start_Time); 

bi_05_Test_Hamess.Test_Done. Complete; 

HarnessJ~ventJjog_Manager.Print_TimeJJnes; 

Ham ess_Event_U>g_Manager.Quit; 
end bi_05; 


- Calibration 

- Initialize Logger 

- Start Clients 

- Wait for Clients 

- Print Time-line 

- Stop Logger 


98 


CMU/SEI-92-TR-1 






Appendix E Obtaining Source Code and 

Information 

Contact Keith Kohout at Naval Weapons Center Code 3916 (619-939-1278; e-mail: 
keith@sol.nwc.navy.mil) for additional information and access to the software. The 
tests are also available by anonymous FTP from the SEI (ftp.sei.cmu.edu) in the 
directory pub/RMA-Validation-Tests. 


CMU/SEI-92-TR-1 


99 








UNLIMITED, UNCLASSIFIED 
SECURITY CLASSIFICATION OP THIS FACE 


REPORT DOCUMENTATION PAGE 

la. REPORT SECURITY CLASSIFICATION 

Unclassified 

lb. RESTRICTIVE MARKINGS 

None 

2a. SECURITY CLASSIFICATION AUTHORITY 

N/A 

3. DISTRIBUTION/AVAILABILITY OF REPORT 

Approved for Public Release 

Distribution Unlimited 

2b. DECLASSIFICATION/DOWNGRADING SCHEDULE 

N/A 

4. PERFORMING ORGANIZATION REPORT NUMBER(S 

CMU/SEI-92-TR-1 

5. MONITORING ORGANIZATION REPORT NUMBER"5) 

ESD-92-TR-1 

6a. NAME OF PERFORMING ORGANIZATION 

Software Engineering Institute 

6b. OFFICE SYMBOL 
(if applicable) 

SEI 

7a. NAME OF MONITORING ORGANIZATION 

SEI Joint Program Office 

6c. ADDRESS (City. Slate and ZIP Code) 

Carnegie Mellon University 

Pittsburgh PA 15213 

7b. ADDRESS (City, State and ZIP Code) 

ESD/AVS 

Hanscom Air Force Base, MA 01731 

8a. NAME OFFUNDING/SPONSORING 
ORGANIZATION 

SEI Joint Program Office 

8b. OFFICE SYMBOL 
(if applicable) 

ESD/AVS 

9. PROCUREMENT INSTRUMENT IDENTIFICATION NUMBER 

F1962890C0003 

8c. ADDRESS (City, Suie and ZIP Code) 

Carnegie Mellon University 

Pittsburgh PA 15213 

10. SOURCE OF FUNDING NOS. 

PROGRAM 
ELEMENT NO 

63756E 

PROJECT 

NO. 

N/A 

TASK 

NO 

N/A 

WORK UNIT 

NO. 

N/A 


11. TITLE (Include Security Classification) 


Ada Validation Tests for Rate Monotonic Scheduling Algorithms 


12. PERSONAL AUTHOR(S) 

Keith A. Kohout, Kent Meyer, John B. Goodenough 


13a. TYPE OF REPORT 

13b. TIME COVERED 

14. DATE OF REPORT (Yt. Mo.. Day) 

15. PAGE COUNT 

Final 

FROM TO 

February 1992 

107 


16. SUPPLEMENTARY NOTATION 


17. COSATI CODES 

18. SUBJECT TERMS (Continue oa reverse of necessary and identify by Mock number) 

FIELD 

GROUP 

SUB. GR. 

Ada 

basic inheritance 

Rate Monotonic 




real-time systems 




priority ceiling 

task scheduling 

IQ ARXTRArT 






This report presents a set of tests for checking whether an Ada runtime system properly supports 
certain rate monotonic scheduling algorithms, specifically, the basic inheritance and priority ceiling 
protocols. These tests are intended to be used by vendors and by users to validate implementations 
of these protocols. The report describes the tests and how they are to be used. The source code is 
available electronically. 


(please turn ova) 


20. DISTRIBUTtON/AVAILABHJTY OF ABSTRACT 

UNCLASSIFIED/UNLIMrrED J SAME AS RPTQ DTIC USERS J 

21. J3STRACT SECURTTY CLASSIFICATION 

Unclassified, Unlimited Distribution 

22a. NAME OF RESPONSIBLE INDIVIDUAL 

John S. Herman, Cap*, USAF 

22b. TELEPHONE NUMBER (Include Area Code) 

(412) 268-7631 

22c. OFFICE SYMBOL 

ESD/AVS (SEI) 



DD FORM 1473,13 APR 


EDITION of 1 JAN 73 IS OBSOLETE 


UNLIMITED, UNCLASSIFIED 
SECURITY CLASSIFICATION OF THIS 

















































