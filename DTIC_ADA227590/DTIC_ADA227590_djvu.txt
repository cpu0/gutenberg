AD-A227 590 


UNCLASSIFIED 


fiV-esoi 5 

Copy 8 of 15 copies 






DEFINITIONS 

IDA publishes the following documents to report the results of Its work. 


Reports 

Reports are the most authoritative and most carefully considered products IDA publishes. 
They normally embody results of ma|or projects which (a) have a direct bearing on 
decisions affecting major programs, (b) address issues of significant concern to the 
Executive Branch, the Congress and/or the public, or (c) address issues that have 
signilicant economic implications. IDA Reports are reviewed by outside panels ol experts 
to ensure their high quality and relevance to the problems studied, and they are released 
by the President of IDA. 

Group Reports 

Group Reports record the findings and results of IDA established working groups and 
panels composed at senior Individuals addressing major issues which otherwise would be 
the subject of an IDA Report. IDA Group Reports are reviewed by the senior individuals 
responsible for the project and others as selected by IDA to ensure their high quality and 
relevance to the problems studied, and are released by the President of IDA. 

Papers 

Papers, also authoritative and carefully considered p' icts of IDA, address studies that 
are narrower in scope than those covered in Reports. luA Papers are reviewed to ensure 
that they meet the high standards expected ot refereed papers in professional journals or 
formal Agency reports. 

Documents 

IDA Documents are used for the convenience of the sponsors or the analysts (a) to record 
substantive work done in quick reaction studies, (b) to record the proceedings of 
conferences and meetings, (c) to make available preliminary and tentative results of 
analyses, (d) to record data developed in the course of an investigation, or (e) to forward 
information that is essentially unanalyzed and unevaluated. The review of IDA Documents 
is suited to their content and intended use. 



Approved tor public release, unlimited distribution; 30 August 1990. Unclessilied. 




















REPORT DOCUMENTATION PAGE 

Form Approved 

OMB No. 0704-0188 

Public reporting burden for this collection of information is estimated to average 1 hour per response, including the time for reviewing instructions, searching existing data sources, gathering and 
maintaining the data needed, and completing and reviewing the collection of Information. Send comments regarding this burden estimate or any other aspect ot this collection of information. 
Including suggestions tor reducing this burden, to Washington Headquarters Services, Directorate for Information Operations and Reports. 1215 Jefferson Davis Highway, Sule 1204, Arlington, 

VA 22202-4302. and to the Office of Management and Budget, Paperwork Reduction Project (0704-0188), Washington, DC 20503. 

1. AGENCY USE ONLY (Leave blank) 

2. REPORT DATE 

July 1988 

3. REPORT TYPE AND DATES COVERED 

Final 


4. TITLE AND SUBTITLE 

The Ada Recompilation Containment Tool 


6. AUTHOR(S) 

Stephen H. Edwards 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

Institute for Defense Analyses 
1801 N. Beauregard St. 

Alexandria, VA 22311-1772 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

STARS Joint Program Office 
1400 Wilson Blvd. 

Arlington, VA 22209-2308 


S. FUNDING NUMBERS 


MDA 903 84 C 0031 


A-134 


8. PERFORMING ORGANIZATION 
REPORT NUMBER 

IDA Paper P-2099 


10. SPONSORING/MONITORING 
AGENCY REPORT NUMBER 



12a. DISTRIBUTION/AVAILABIUTY STATEMENT 

Approved for public release, unlimited distribution; 30 August 
1990. 


13. ABSTRACT (Maximum 200 words) 


12b. DISTRIBUTION CODE 


IDA Paper P-2099, The Ada Recompilation Containment Tool, documents the development of 
an Ada software prototype for the STARS Joint Program Office. It describes the Ada 
Recompilation Containment Tool (ARCT), a prototype based on the ideas presented in "A New 
Reference Model for Change Propagation and Configuration Management in Software Systems" 
by Joseph L. Linn et al. The article is reprinted in Appendix D. The primary requirement for the 
ARCT prototype was that it reduce compilation time. Although the tool was conceived to 
support Ada programming in-the-large, even very small projects can greatly benefit from the 
recompilation time savings. 


14. SUBJECT TERMS 


Ada Programming Language; Recompilation; Tools and Techniques; 
Prototyping; Software Configuration Management; Compilers. 


15. NUMBER OF PAGES 

148 


16. PRICE CODE 


17. SECURITY CLASSIFICATION 
OF REPORT 

Unclassified 


18. SECURITY CLASSIFICATION 
OF THIS PAGE 

Unclassified 


19. SECURITY CLASSIFICATION 20. LIMITATION OF 


OF ABSTRACT 

Unclassified 


ABSTRACT 

UL 


NSN 7540-01-280-5500 


Standard Form 298 (Rev. 2-89) 
Prescribed by ANSI Std. Z39-10 
298-102 

























UNCLASSIFIED 


IDA PAPER P-2099 


THE Ada RECOMPILATION CONTAINMENT TOOL 


Stephen H. Edwards 


July 1988 



INSTITUTE FOR DEFENSE ANALYSES 


Contract MDA 903 84 C 0031 
DARPA Assignment A-134 


UNCLASSIFIED 



UNCLASSIFIED 


1 


Table of Contents 

1.0. INTRODUCTION. 1 

2.0. SCOPE . 1 

3.0. BACKGROUND. 1 

4.0. REQUIREMENTS SPECIFICATION. 1 

5.0. DEVELOPMENT PLAN . 2 

6.0. DESIGN SPECIFICATION . 2 

7.0. TEST PLAN . 3 

Appendix A: USER’S GUIDE . 7 

A.l. Introduction. 7 

A.2. How ARCT Works . 8 

A.3. Description of Main arct Data Structures . 9 

A.4. Make-File Syntax . 11 

A.4.1. Construction Procedures. 12 

A.4.2. A Make-File Generator. 12 

A.5. A Full arct Example. 13 

A.5.1. An Example ARCT Make-File . 17 

A. 5.2. CHANGE_TYPE Pragmas . 19 

Appendix B: COMMENTED SOURCE CODE . 25 

B. 1. GRAPH_MANAGER Package. 26 

graph_manager Package Specification (graph_manager.a) . 27 

graph_manager Package Body (graph_raanager.b.a) . 28 

GRAPHS Package (graphs.a) . 41 

B.2. MAKE_PROCS Package . 44 

MAKE_PROCS Package Specification (make_procs.a). 44 

MAKEJPROCS Package Body (make_procs.b.a) . 44 

make_util Package Specification (make_util.a). 64 

make_util Package Body (make_util.b.a). 64 

B.3. Main Programs . 75 

arct_ada (arct_ada.a). 76 

arct.create (arct_create.a) . 77 

arct_current (arct_current.a) . 79 

arct_DESCEND (arct_descend.a). 81 

arct_DIR (arct_dir.a). 82 

ARCTJEDIT (arct_edit.a). 83 

arct_make (arct_make.a). 85 

MAKE_MAKE (make_make.a) . 86 

B.4. Library Units . 92 

arct_globals Package Specification (arct_globals.a). 92 

arct.globals Package Body (arct_globals.b.a) .. 92 

arg_scanner Package Specification (arg_scanner.a) . 94 

argjscanner Package Body (arg_scanner.b.a) . 94 

file_util Package Specification (file_util.a). 95 

FILE.UTIL Package Body (file_util.b.a). 96 


UNCLASSIFIED 














































UNCLASSIFIED ii 

MY_STRINGS Package Specification (my_strings.a). 102 

MY_strings Package Body (my_strings.b.a) . 103 

STANDAjRD_UST Package Specification (standardjist.a) . 105 

Definiton of Package COUNTJO (COUNT_IO.def.a) . 107 

Definiton of Package INT_IO (INTJO.def.a) . 108 

Appendix C: TEST RESULTS. 109 

Appendix D: “A New Reference Model for Change Propagation and Configuration 

Management in Software Systems”. 119 


UNCLASSIFIED 












UNCLASSIFIED 


m 


PREFACE 


IDA Paper P-2099, The Ada Recompilation Containment Tool, is a report on the development of 
an Ada software prototype for the STARS Joint Program Office. 

The importance of this document is based on fulfilling the objective of task order T-D5-429, 
Software Technology Acceleration Project, which is to develop selected prototype Ada software 
components. The Ada Recompilation Containment Tool will be used to improve the software 
productivity of Ada programmers and is directed towards individuals interested in Ada software 
development. 

The document was reviewed on April 20, 1988 by the members of the following CSED Peer 
Review: David Carney, Robert Winner, Robert Knapper, James Baldo, and Julia Sensiba. 

P-2099 should be considered a companion paper to ”A New Reference Model for Change Propa¬ 
gation and Configuration Management in Software Systems,” by Joseph L. Linn, Cathy Jo Linn, 
and Robert I. Winner. This paper is included in the text of P-2099 as Appendix D. 

Thanks go to Robert Knapper, whose input was enormously beneficial. 



i Accession For 

...- ---- ^ 

NT1S -JRAfcl 
DTIC TAB 
Unannounced 
JustlfIcati 

□ 

□ 


By 

Dlstr 

Aval 

ibutlon/ 

lability Codes 

Dlst 

tL 

Avail 

Speo 

and/or 

ial 


UNCLASSIFIED 




UNCLASSIFIED 


1 


1.0. INTRODUCTION 


This paper was written to satisfy deliverable 4.1.1 of task order T-D5-429. Its purpose is to 
describe the Ada Recompilation Containment Tool (ARCT) prototype written for the STARS 
program. This tool incorporated a new method of specifying Ada module interdependencies 
aimed at reducing the amount of necessary recompilation. 


2.0. SCOPE 


The primary topic of discussion in this paper is recompilation containment. The paper describes 
the prototype ARCT tool and its use, as well as the main data structures it employs. It also 
explains the difficulties in hooking such a tool to an off-the-shelf Ada compiler. Although exten¬ 
sive efforts were made to forge such a iink, it was impossible to hook the ARCT to many com¬ 
pilers. Where it was possible, the cost was prohibitive (obtaining source code rights and modify¬ 
ing sections of the compiler). A full explanation of these problems and their origins is given in 
section 7.0. 


3.0. BACKGROUND 


The ARCT prototype tool is based on ideas presented in “A New Reference Model for Change 
Propagation and Configuration Management in Software Systems,” by Joseph L. Linn, Cathy Jo 
Linn, and Robert I. Winner. The arct tool is an experimental implementation of the system 
proposed in that paper, and P-2099 should be considered as a companion to this earlier work 
(which is reprinted as Appendix D). 


4.0. REQUIREMENTS SPECIFICATION 


The primary requirement for the arct prototype is that it reduces compilation time. Although 
the tool was conceived to support Ada programming-in-the-large, even very small projects can 
greatly benefit from the recompilation time savings. To achieve this goal, the ARCT follows a 
modified set of recompilation rules. The Ada Language Reference Manual ( LRM) states the 
recompilation rules for Ada units in section 10.3: 

10.3(5) A compilation unit is potentially affected by a change in any library unit named by its 
context clause. A secondary unit is potentially affected by a change in the 
corresponding library unit. The subunits of a parent compilation unit are potentially 
affected by a change of the parent compilation unit. If a compilation unit is success¬ 
fully recompiled, the compilation units potentially affected by this change are 
obsolete and must be recompiled unless they are no longer needed. An implementa¬ 
tion may be able to reduce the compilation costs if it can deduce that some of the 
potentially affected units are not actually affected by the change. 

The arct tool allows a programmer to specify the recompilation rules used by the tool, which in 
turn allows better recompilation behavior. The primary difference between this approach and 


UNCLASSIFIED 




UNCLASSIFIED 


2 


that specified in 10.3(5) is that arct guarantees compliance with the programmer’s specifications 
whereas 10.3(5) guarantees compliance with Ada semantics. 


5.0. DEVELOPMENT PLAN 


The arct prototype development began in July, 1986, as an experimental implementation of the 
change propagation reference model specified in Appendix D. By September, 1986, it was 
implemented in Ada and running on a DEC VAX, but was not hooked to a compatible Ada com¬ 
piler. In July, 1987, the development resumed with the porting of the arct to the Sun Unix 
environment. Again, no compatible compilers were found. The User’s Guide (Appendix A) 
was completed in September, 1987. Final documentation was drafted in late December, 1987, 
and completed in July, 1988. 


6.0. DESIGN SPECIFICATION 


The ada recompilation rules stated in the LRM, and discussed in section 4.0, define the set of 
units which are potentially affected by any change to some library unit. Current Ada implemen¬ 
tations require all potentially affected units to be recompiled. For example, any small changes to 
a package of commonly used library functions for a project can result in a large number of 
recompilations, even though the change may affect only a handful of other units. The Ada 
Recompilation Containment Tool (arct) encorporates a new change control policy and set of 
recompilation rules to minimize the amount of unnecessary recompilation. This tool is based on 
ideas presented in “A New Reference Model for Change Propagation and Configuration 
Management «n Software Sterns,” by Joseph L. Linr, Catbv To Linn, and Robert I. Winner. 

This model of change propagation can be viewed as a new specification of Ada module inter¬ 
dependencies. Rather than stating that one Ada unit depends on the entire contents of another 
Ada unit, a programmer can arbitrarily divide his code into small sections. The programmer 
may then specify that a given unit depends on some subset of the pieces which make up another 
unit. This mechanism allows the programmer to specify the interdependencies between Ada 
units to a fine granularity, ensuring that units will only be recompiled when a section those units 
depend on is changed. 

The programmer uses CHANGE_TYPE pragmas in source files to demarcate regions which other 
units depend on, then specifies these dependencies in make-files similar to those used by the 
UNIX make utility. When a programmer does not wish to divide the units, recompilation 
behavior will be as before. The more effort a programmer applies to dividing the code and creat¬ 
ing an effective make-file, the greater the possible reduction in recompilation time. 

The heart of the ARCT is the program arct.make, which reads these make-files, discovers 
changes to source files in the library, and invokes the compiler. The functionality of arct.make is 
also based on the UNIX make utility. A make file is necessary for this system to work effectively. 
When a programmer states in a make-file that one unit does not depend on another when in real¬ 
ity it does, inconsistent results will be obtained. 


UNCLASSIFIED 







UNCLASSIFIED 


3 


7.0. TEST PLAN 


To complete the arct system, it is neccessary to have a validated Ada compiler that is not 
integrated into a vendor development system. At this time, Ada compilers being marketed have 
been written with the LRM recompilation order deeply embedded in their design. This has been 
the source of significant problems in the development of the arct prototype. 

The reason for this problem is the database of dependency information that must be maintained 
by the Ada compiler. In the Verdix compiler, for example, this database is held in the form of a 
group of files, each containing the dlana tree for some program unit. Other compilers, such as 
the Telesoft or DEC compilers, keep all of this information in one centralized file. Either way, 
these intermediate representations are highly interdependent. To make such a compiler behave 
more like a conventional compiler, the intermediate forms must be made as independent as pos¬ 
sible, and the timestamped ties between the trees should not be timestamped. 

The idea is not to produce an Ada compiler which does not use DIANA as an intermediate form, 
but rather to produce a more robust compiler which does not rely on the sanctity of its DIANA 
representations. For example, the Verdix compiler maps all of the DIANA trees in a given library 
into a Global Virtual Address Space. It is this virtual address which other DIANA trees depend¬ 
ing on this unit use in referencing it. If the unit is recompiled and given a new virtual address, all 
previous references are no longer valid. This is acceptable given the assumptions allowed by the 
LRM, and may be a good idea for performance reasons. However, it introduces many unneeded 
interdependencies between DIANA trees. A more symbolic form of linking would make Verdix’s 
intermediate form more general, and more capable of embracing new compilation concepts such 
as the ARCT. 

The Telesoft compiler appears to be more receptive to the ARCT approach. This is because all 
the DIANA trees are stored in one file, and the only compilation order checking that is done relies 
on a single timestamp field for each program unit. These fields are also in the DIANA tile, and it is 
a simple matter to change one of them to fool the compiler into thinking some unit is up-to-date. 
Unfortunately, more subtle interdependencies exist upon which the Telesoft compiler relies. 

As an example, consider the following Ada units: 


package A is 

type MY_INT is new INTEGER; 

procedure DO_SOMETHING(ARG: in MY_INT); 

end A; 

with A; 
package B is 
use a; 

-other stuff here 

end r; 
with B; 


UNCLASSIFIED 



UNCLASSIFIED 


use B, 

procedure C is 
oegin 

-do something here too 

end; 


Even if a relatively innocuous change should be made to package A, 
such as: 

package A is 

type MY_INT is new INTEGER; 

procedure DO_SOMETHING(ARG: in MY_INT); 

type MY_INT2 is new INTEGER; 

end a; 


changing the timestamp on unit B and then compiling C would 
cause the compiler to crash, even though this change should 
not have altered A’s 
DIANA 

representation enough to prevent proper 
compilation of C. 

To achieve such separation in the intermediate representations, 
an Ada compiler will probably have to be very cleanly separated into 
an 

Ada-to-DIANA 
translator and a 
DLANA-to-object-code 
translator. 

Even though this seems to be the model used by existing compilers, 
their lack of separation and heavy dependence on assumptions about 
their intermediate representations and the recompilation order make 
them less flexible for use with new tools such as the 
ARCT. 

Because the 
ARCT 

could not be successfully hooked to an existing Ada compiler, the test 
plan consisted of running the tool on a test library and collecting the 
commands it would have executed if there were a working compiler interface. 
The 
ARCT 

then updated its graphs based upon the successful completion of the dummy 


UNCLASSIFIED 




UNCLASSIFIED 


5 


commands. The test library was based directly on examples presented in 
Appendix D, and complete results for all tests are presented in Appendix C. 


UNCLASSIFIED 





UNCLASSIFIED 


UNCLASSIFIED 






UNCLASSIFIED 


7 


Appendix A: USER’S GUIDE 


A.l. 

Introduction 


Section 10.3 of the 

Ada Language Reference Manual 

states the recompilation rules for Ada units: 

10.3(5) A compilation unit is potentially affected by a change in any library unit named by its 
context clause. A secondary unit is potentially affected by a change in the 
corresponding library unit. The subunits of a parent compilation unit are potentially 
affected by a change of the parent compilation unit. If a compilation unit is success¬ 
fully recompiled, the compilation units potentially affected by this change are 
obsolete and must be recompiled unless they are no longer needed. An implementa¬ 
tion may be able to reduce the compilation costs if it can deduce that some of the 
potentially affected units are not actually affected by the change. 

Current Ada implementations require all potentially affected units to be recompiled. For exam¬ 
ple, any small changes to a package of commonly used library functions for a project can result 
in a large number of recompilations, even though the change may affect only a handful of other 
units. The Ada Recompilation Containment Tool (arct) encorporates a new change control 
policy and set of recompilation rules to minimize the amount of unnecessary recompilation. 
This tool is based on ideas presented in “A New Reference Model for Change Propagation and 
Configuration Management in Software Systems,” by Joseph I . Linn, Cathy Jo Linn, and 
Robert I. Winner. 

This model of change propagation can be viewed as a new specification of Ada module inter¬ 
dependencies. Rather than stating that one Ada unit depends on the entire contents of another 
Ada unit, a programmer can arbitrarily divide his code into small sections. The programmer 
may then specify that a given unit depends on some subset of the pieces which make up another 
unit. This mechanism allows the programmer to specify the interdependencies between Ada 
units to a fine granularity, ensuring that units will only be recompiled when a section those units 
depend on is changed. 

The programmer uses change_type pragmas in source files to demarcate regions which other 
units depend on, then specifies these dependencies in make-files similar to those used by the 
UNIX make utility. When a programmer does not wish to divide the units, recompilation 
behavior will be as before. The more effort a programmer applies to dividing the code and creat¬ 
ing an effective make-file, the greater the possible reduction in recompilation time. 

A make-file is necessary for this system to work effectively. When a programmer states in a 
make-file that one unit does not depend on another when in reality it does, inconsistent results 
will be obtained. 


UNCLASSIFIED 




UNCLASSIFIED 


8 


A.2. How arct Works 


The arct system is implemented in Ada under the Verdix Ada Development System, Version 5 
( VADS5 ). ARCT consists of two Ada programs which functionally replace the VADS5 functions 

arct.make and arct.ada. 

The arct.make program replaces the VADS5 program of the same name, and provides all the 
make services associated with arct. The invocation syntax is: 

arct.make unit_name 
or 

arct.make -b unit_name make_file 

If invoked with only a unit name, arct.make assumes that the given unit already has a make file 
associated with it. If there is no associated make-file, an error message is produced. If the -b 
option is used, the file name after the unit name is taken to be a make-file, and if that file exists, 
its name is bound to the given unit to be used with later arct.make commands, arct.make then 
processes the given make-file. For each unit specified in the make-file, arct.make scans the 
current source file for each of its dependents to discover any changes which have been made 
(this is called a change-discovery-operation), and uses this information to determine if the 
specified unit needs to be reconstructed. If the unit does need to be reconstructed, arct.make 
invokes the Verdix compiler, the linker, or executes the construction procedure given in the 
make file. It assumes that the current source file for each unit exists in the current directory. 

The arct.ada command is actually a program which “wraps around” the Verdix ada command. 
It passes all of its arguments to the compiler without changing them. Its only purpose is to deter¬ 
mine which source files are successfully compiled, and add them to the source archives for use in 
future change-discovery-operations. The invocation syntax is the same as for the Verdix pro¬ 
gram: 


arct.ada [options] file [files] 

Successfully compiled source files are copied into the .arct.source directory in the current ada 
library and added to the source archive graph structure. If these are descendants of earlier files 
for the same unit, make-files are inherited from these parent files. 

Optionally, the arct.edit program may be used when editing program units. arct.edit will 
automatically place the old version of the source file in the source archive, update the source 
archive graph, and place the results of the edit session in a new file. This is a rudimentary inter¬ 
face to the version control facilities provided by the ARCT, and allows the source archive to con¬ 
tain ail previous versions of a unit’s source, rather than just those which were compiled. 


UNCLASSIFIED 




UNCLASSIFIED 


9 


A.3. Description of Main ARCT Data Structures 


The core of the arct system consists of two data structures: the source archive graph and the 
derived unit graph. The source archive graph contains a record of the last N versions of all suc¬ 
cessfully compiled Ada source files in the program library, and their interrelationships. Each 
time the compiler successfully compiles a source file, that file is copied into the .arct.source sub¬ 
directory, and recorded in the source archive graph. There is a one-to-one mapping between the 
set of Ada source files in the .arct.source and the nodes in the source archive graph. Similarly, 
the derived graph keeps track of all files in the library derived from the Ada source files. There 
is also a one-to-one correspondence between derived files in the library and nodes in the derived 
unit graph. As these two graphs are structurally identical except for the number and names of 
the fields associated with the individual nodes, their structure will be discussed simultaneously. 

Each graph is represented by a record consisting of two elements: an integer representing the 
number of nodes in the graph, and a pointer to an array of nodes. Each graph is actually a 
dynamic array of nodes, and each element in the dynamic array is a pointer to a node record. 
This is how the main portion of the graph is stored. 



merged parent 
(if any) 




alternate child 
(if any) 





merged parent 
(if any) 




alternate child 
(if any) 



Figure A.3-1. Source Archive Graph—a sample source archive 
graph node, showing existing relationships with arrow's, and pos¬ 
sible future relationships with dotted arrows. The node in the 
center represents the current node in the source archive graph 
for the unit “main,” The node(s) at the top represent the 
parent(s) for this unit, and the nodes at the bottom represent the 
children which may be descended from this node in the future. 


UNCLASSIFIED 

















UNCLASSIFIED 


10 


At this stage, the two graphs begin to differ. First, the source archive graph: each node record in 
the source archive graph has in addition to the informational fields, two arrays of integers. One 
array contains information about the arcs outgoing from this node and the other contains infor¬ 
mation about arcs incoming to the node. The outgoing array contains the subscripts of the nodes 
in the graph which receive arcs from this node, while the incoming array contains the subscripts 
of nodes which send arcs to this node. These two arrays are named the “parent” and “child” 
arrays, respectively. 

The derived graph nodes carry only a “child” array, which is different from the child arrays in the 
source archive graph. This difference exists since a node in the derived graph can depend on 
nodes in either the source archive graph or the derived graph. Each array element in a derived 
child array is a record with two fields. The first, called “node,” is the array index of that particu¬ 
lar child node in one of the two graphs. The second field is a boolean called “derived” whic’’ is 
true if that child is also a derived unit, and false if that child is an Ada source file in the source 
archive graph. All derived unit nodes have a “type” designated by a single character. This type 
is help in the node field “f_type.” This corresponds roughly to the file extension (where the unit 
name is the file-name proper) of the file used to hold this particular unit. If the derived node is a 
passthru node, its f_type is ‘ ’. 

Neither of these two data structures can be accessed directly. Their definitions are in the package 
graphs, and they can only be accessed through procedures in the package graph_manager or 
the package make_procs. 



Figure A.3-2. Derived Unit Graph—an example derived unit 
graph node, showing how it can depend on other derived nodes 
as well as nodes in the source archive graph. 


UNCLASSIFIED 
















UNCLASSIFIED 


11 


A.4. Make-File Syntax 


An arct “make-file” is a text file describing dependencies between derived files and the source 
and derived files used to construct them. A make-file can specify dependencies and construction 
procedures for any number of derived units, with only one restriction on the order: if a derived 
unit depends on another derived unit, the second unit’s dependencies must be described earlier 
in the make-file. This is analogous to the “define before use” rule in Ada source code. 

The make-file consists of a list of statements, each describing the dependencies and construction 
procedures for a given derived unit. 


statement unit_identifier : dependency_list [: construction_procedure ]; 

dependency_list ::= unit_jdentifier [exclude_list] { unit_identifier [exclude_list]} 

construction_procedure { constr_graph_character } 

unit_identifier ::= letter {[underline] letter_or_digit } [. letter] 

exclude_list ::= / change_type { / change_type } 

change_type ::= letter {[underline] letter_or_digit } 

Where letter_or_digit is defined in the Ada LRM and constr_graph_character is any 
graphic_character (as defined in the LRM) excluding the ‘;\ Following is an example of a more 
detailed make-file, which contains all possible make-file structures: 


pl.o : pl.a; 

p2.o: p2.a; 

main.o : main.a 

pl.a /body_n_procs /guide 
p2.a /body_n_procs: 
ada -M main.a; 


mainpass: main.a 

pi .a /body_n_procs /guide 
p2.a /body_n_procs /i2def; 

sl.o : sl.a mainpass: 

s2.o: s2.a mainpass; 

main.e : pl.o p2.o main.o sl.o s2.o: 
link pl.o p2.o main.o sl.o s2.o -o main; 


UNCLASSIFIED 





UNCLASSIFIED 


12 


A.4.1. Construction Procedures 


When changes are made to the units a derived unit depends upon, then the derived unit must be 
reconstructed. This is done within the MAKE procedure by a call to the make_procs internal 
procedure BUILDJT. If no construction procedure is specified for a given make-file, its exten¬ 
sion is tested. If it is .E, then the linker is invoked to link all of the files of type .O in its depen¬ 
dency list together. If the derived file is any other type, the Ada compiler is invoked on the first 
file in its dependency list. 

If a construction procedure is specified in the make-file for that derived unit, then it is processed 
and passed on to the operating system for execution. The output from the above example 
(assuming all of the derived units need to be constructed) would be: 

ada pi.a 
ada p2.a 
ada -M main.a 
ada si.a 
ada s2.a 

link pl.o p2.o main.o sl.o s2.o -o main 


A.4.2. A Make-File Generator 


Programmers will probably wish to start with a make-file which describes the default dependen¬ 
cies. Building such a file from scratch for a large collection of files can be tedious, so a make-file 
generator is provided. This program, called make.make, is the main procedure make_make 
listed in Appendix B. It analyzes all of the files specified on its command line, creating a make¬ 
file which will cause the files to be compiled in proper order. If no files are specified on the com¬ 
mand line, it will read file names from its standard input until an end of file condition is reached. 
Its syntax is as follows: 

make.make [-a][-s] filel [file2 ... ] 

Normally, make.make does not include statements for deriving units which appear in with 
clauses but which are not declared in any of the files specified for analysis. If the -a option is 
specified, make.make will include statements for these units, even though the files they are 
defined in were not analyzed, make.make also does not normally include the references to stan¬ 
dard library files in any dependency lists. The -s option requests all ‘with’ed files to be included 
in dependency lists, including those which are in the standard library. 

This program is useful in creating a make-file which a programmer can use to start, slowly adding 
new dependencies and refining the granularity of old ones to achieve optimum recompilation 
behavior. 


UNCLASSIFIED 





UNCLASSIFIED 


13 


A.5. A Full ARCT Example 


This example is designed to demonstrate the use of ARCT tools on regular Ada material. The 
code chosen for this example is taken from the ARCT directory tool used to examine ARCT source 
archives. To show how to adapt existing Ada code to the ARCT system, normal code is presented 
first, then gradually changed to show how more and more advantage can be gained by using 
change_type pragmas. This example shows how unnecessary recompilation can occur even in 
small Ada projects, and how the ARCT can be used to avoid it. The first version of the source, 
without any pragmas is as follows: 

ARCT_DIR Ada Source: 

with GRAPH_MANAGER, ARCT_GLOBALS, ARG_SCANNER, TEXTJO, U_ENV, 

A_STRINGS, FILE_SUPPORT; 

use GRAPHLMANAGER, ARCT.GLOBALS, ARG_SCANNER, TEXTJO, UJENV, 

A_STRINGS; 

procedure ARCT_DIR is 

ARG_PTR : INTEGER 1; 

OPTIONS : FLAG_ARRAY_TYPE := RESET_FLAGS; 

procedure STDERR(s : in STRING) renames FILEjSUPPORT.WRITE_TO_STDERR; 

procedure STDERR_UNE(M : in STRING) is 

begin 

STDERR(M & CHARACTER’VAL(IO)); 

end STDERRJJNE; 


begin 


GET_ARGS(”dv”, OPTIONS, ARG_PTR); 
if ARG_PTR /= ARGC then 
PATH := ARGV(ARG_FTR); 
if PATH.s(PATH.LEN) /= T then 
PATH := PATH & ’/’; 
end if; 
end if; 

if opnoNS(’d’) then 
getjdgraph; 

if not DISPLAYJDER then 

PUT_LINE(”Derived unit graph is empty.”); 

end if; 

elsif OPTIONS(V) then 
GET.VGRAPH; 
if not DISPLAY_VER then 

PUT_LINE(”Source control graph is empty.”); 

end if; 
else 

GET_VGRAPH; 

DIRECTORY; 


UNCLASSIFIED 




UNCLASSIFIED 


14 


end if; 
return; 

exception 

When IKDEX_FILE_NOT_FOUN'D => 

stderr_line(”ARCT index file not found.”); 
STDERR_LINE(”Perhaps this is not an ARCT library.”); 

return; 

when INVALID_FLAG => 

STDERR_LlNE(”Invalid option. Correct usage:”); 
STDERR_LINE(””); 

STDERRXINE(” arct.dir [-d|-v] [path]”); 
STDERRXINE(””); 

return; 

end ARCTJDIR; 


This program is simple. Both of the local variables are used in interpreting the arguments passed 
to the program by the Unix environment (through the U_ENV package). The ARGJTR variable is 
used to keep track of the current position in the argument list, and the options variable is used 
to record the options selected by the user. Both are used in conjunction with the arg_scanner 
package. 

First, the procedure get_args is called (it is contained in the arg_scanner package) to inter¬ 
pret the argument list. The syntax for invoking this program is: 

arct.dir [-d] [-v] [path] 

where path is the optional path name of the arct library to examine. Normally, only units 
contained in this library are listed. However, the -d option asks for an extensive listing of the 
derived units in the library, and the -v option asks for a complete listing of all source files in the 
archive. If both options are given, only the derived listing is shown. 

To process the arguments on the command line, the procedure get_args is used. get_args is 
contained in the package arg_scanner which has the following specification: 

arg_scanner Ada Source: 

package ARGJ5CANNER is 

type flag_array_type is array(’0’ .. ’z’) of BOOLEAN; 

RESET_FLAGS : constant FLAG_ARRAY_TYPE := 

(FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 

FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 

FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 

FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 

FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 

FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 

FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 


UNCLASSIFIED 




UNCLASSIFIED 


15 


I 


false, false, false, false, false, false, false, false, 
false, false, false, false, false, false, false, false, 

► FALSE, FALSE, FALSE); 

procedure GET_ARGS(POSSIBLE_FLAGS : in STRING; 

FLAGS : in out flag_array_type; 

ARG_PTR : in out INTEGER); 

► INVALID_FLAG : exception; 
end ARG_SCANNER; 


This procedure accepts as its first argument a string containing ail characters which are valid 
I flags for the given program. A flag can be any character in the range ‘0’..‘z’, and can be expressed 

on a command line in the following way: 

command -1 -v -asdf 

As with most UNIX commands, the line above is considered to set the flags T’, V, ‘a’, ‘s’, ‘d’, 
k and ‘f . If a flag is specified on a command line but is not listed in the possible_flags argument 

to get_args, an invalidjflag exception is raised. 

GET_ARGS begins scanning at the argument pointed to by its ARG_PTR argument (if arg_ptr = 1, 
it starts with the first argument, etc.). GET_ARGS continues scanning until it reaches a non-flag 
argument, and returns the new argument position through its ARG_PTR argument. For each flag 
t encountered, the appropriate element of the FLAGS array is set to true. Since both flags and 

ARG_PTR are in out arguments, a program can call GET.ARGS to get the first options on the com¬ 
mand line, process the next argument in the list (which cannot be a flag), then iterate until the list 
is empty. As long as the same variables for the argument pointer and flag uray are used, the 
command line is processed from left to right with flags only affecting those parameters to their 
right. 

I 

Once all the flags have been processed by GET_ARGS, the ARCTJDIR program tests to see if any 
arguments remain. If there are more arguments, it takes the first as the path of the arct library 
and sets the path variable (contained in the package arct_globals). This variable is used to 
specify the path of the current library being accessed by arct tools. The specification of the 
ARCT_GLOBALS package is: 

> 

arct^globals Ada Source: 

With AJSTRINGS; 
use A_STRINGS; 

k package ARCT.GLOBALS is 

PATH : A_STRING := EMPTY; 


procedure GET_DGRAPH; 
procedure B ackup_dgraph ; 
procedure PUT_DGRAPH; 


► 


UNCLASSIFIED 





UNCLASSIFIED 


16 


procedure GET_VGRAPH; 
procedure BACKUP_VGRAPH; 
procedure PUT-VGRAPH; 


INDEX_FILE_NOT_FOUND : exception; 
end ARCT_GLOBALS; 


The procedures in this package are all used to manage index files containing arct data. The 
get, BACKUP, and put procedures load a graph into memory, save a graph from memory to a 
backup file, and store a graph from memory into an index file, respectively. There is one set of 
procedures for the derived graph structure (dgraph), and a complimentary set for the source 
archive graph (vgraph). 

Once the arct path has been established, the options on the arct_dir command line are pro¬ 
cessed. If -d is specified, the derived graph is loaded via getjdgraph, and displayed by the 
graph_manager procedure DISPLAY_DER. If -v was specified, the source archive graph is 
loaded and displayed. If neither option was specified, the source archive graph is loaded and a 
directory of current units is displayed. If an error occurs, the exception handler is entered. It 
takes care of the case where the specified path is not an arct library, or an invalid flag is 
specified on the command line. The GRAPH_MANAGER specification which declares the directory 
displaying procedures is as follows: 

GRAPH-MANAGER Ada Source: 

with TEXTJO, MYJSTRINGS; 

use TEXT_IO, MYJSTRINGS; 

package GRAPH-MANAGER is 

- Type and Object declarations ommitted since they are not 

- used in this example. 


procedure DIRECTORY; 

fimction DISPLAYJDER return BOOLEAN; 

function DISPLAY-VER return BOOLEAN; 

- Other Procedure and Function declarations ommitted since 

- they are not used in ARCT_DIR. 


end GRAPH-MANAGER; 


UNCLASSIFIED 





UNCLASSIFIED 


17 


By examining the with clause of arct_dir, it becomes apparent that this procedure depends on 
seven packages (three arct packages in the same library and four packages from the standard 
library). The standard library units can be relied upon to remain constant, but the others might 
change at any time. If any of these three units are recompiled, the normal Ada model would 
require that arct_DIR be recompiled also. However, by examining the with clauses of these 
three units, it becomes clear that arct_DIR depends indirectly on even more units. For this 
example, the package graph_manager has a specification which depends on TEXT_io and 
my_strings. TEXTJC is a library package and will remain constant, but a change in my_strings 
could trigger the recompilation of GRAPH_MANAGER’s specification, and in turn trigger the 
recompilation of arctjdir. Examining the code will show that arct_dir does not really depend 
on the unit my_strings in any way. 

A.5.1. An Example ARCT Make-File 


Instead of providing a rigid model of change propagation, as exists in current Ada implementa¬ 
tions, arct incorporates a flexible model based loosely on the Unix make facility. All file inter¬ 
dependencies are specified in a script which is used by a make-like processor to trigger appropri¬ 
ate recompilations. It is absolutely necessary for the programmer to take all dependencies into 
account or inconsistent libraries will result (the risks this requirement may imply about Ada 
programming-in-the-large can be greatly reduced through the use of a tool such as make.make to 
be described later in this section). 

A simple make file for the ARCT_DIR unit would look like: 

arg_scanner.o: arg_scanner.a; 

arct_globals.o: arct_globals.a; 

my_strings.o: my_strings.a; 

graph_manager.o: graph_manager.a 
my_strings.a; 

arct_dir.o: arct_dir.a 
graph_manager.a 
arct_globals.a 
arg_scanner.a; 

arct_dir.e: arct_dir.o my_strings.o graph_manager.o arct_globals.o arg_scanner.o 
text_io.o u_env.o a_strings.o file_support.o; 


These relationships are derived from the 

with 

statements in each source file. The object file for a given unit 
depends on the source for that unit, and also on the source files of 
all units it 
with’s. 

The process of creating such a file directly from the source files 

is straightforward but tedious; an 

ARCT 

tool is provided for this purpose. The script shown was produced by this tool, 


UNCLASSIFIED 





UNCLASSIFIED 


18 


make, make, 

which 

recursively searches the source code for each file, collecting units 

from 

with 

clauses, and compiling a make file. The tool only looks for files in 

the current directory, and expects all units to have source code 

stored in a file with the unit name as its root, in lower case, 

and ‘.a’ as its extension (i.e., unit 

ARG.SCANNER 

is stored in file 

arg_scanner.a). 

Any units referred to in 
with 

clauses which are in the standard library are omitted from the dependency 

lists. Any units which are referred to but do not have a corresponding 

source file in the current directory are also ommitted. 

make.make 

supports a 

-s 

option to include references to standard library units, and a 

-a 

option to include references to files for which corresponding source files 
cannot be found. 

make.make 

outputs will resemble the following: 

make.make -s arct_dir.a : 

arg_scanner.o: arg_scanner.a; 

arct_globals.o: arct_globals.a 
a_strings.a; 

my_strings.o: my_strings.a; 

graph_manager.o: graph_manager.a 
text_io.a 
my_strings.a; 

arct_dir.o: arct_dir.a 

gr aph_manager. a 

arct_globals.a 

arg_scanner.a 

textjo.a 

u_env.a 

a_strings.a 

file_support.a; 

arct_dir.e: arct_dir.o my_strings.o graphjmanager.o arct_globals.o arg_scanner.o 
text Jo.o u_env.o a_strings.o file.support.o; 


UNCLASSIFIED 






UNCLASSIFIED 


19 


make, make -sa arct_dir.a : 

file_support.o: file_support.a; 

a_strings.o: a_strings.a; 

u_env.o: u_env.a; 

textjo.o: text_io.a; 

arg_scanner.o: arg_scanner.a; 

arct_globals.o: arct_globals.a 
a_strings.a; 

my_strings.o: my_strings.a; 

graph_manager.o: graph_manager.a 
text_io.a 
my_strings.a; 

arct_dir.o: arct_dir.a 
graph_manager.a 
arct_globals.a 
arg_scanner.a 
text Jo. a 
u_env.a 
a_strings.a 
file_support.a; 

arct_dir.e: arct_dir.o my_strings.o graph_manager.o arct_globals.o arg_scanner.o 
textjo.o u_env.o a_strings.o file_support.o; 


Output for make.make -a arct_dir.a is not shown since source files for all units not in the stan¬ 
dard library are available (the output is the same in this case as if no options were specified). For 
this example, the standard library files are assumed to be constant and all source files are avail¬ 
able, so the first make.make output will be used as the basis for the arct_dir make-file script. 


A.5.2. CHANGE_TYPE Pragmas 


What is the difference between the using the arct_dir make-file to maintain the object and exe¬ 
cutable files and relying on the normal Ada rules for recompiling? By looking at the arct_dir 
make-file again, it is clear that a change in the source file my_strings.a will cause the unit 
graph_manager to be recompiled. It will not cause ARCT_DIR to be recompiled, though. For 
the vast majority of programs, this is perfectly acceptable. But sometimes such indirect depen¬ 
dencies should trigger recompilation. For example, a data type in the package MY_STRINGS 
could be rename’d in package grapilmanager, and the renamed version used by arctjdir. If 
this is the case, it is the responsibility of the programmer to make the dependency explicit in the 
corresponding make-file. 


UNCLASSIFIED 




UNCLASSIFIED 


20 


Notice also the dependency of ARCT.DIR on the file graph_manager.a. If there are any non¬ 
white space changes to the file graph_manager.a from the last time it was successfully compiled, 
arct_dir will be recompiled. But by examining the source for both units in detail, it is clear that 
arct_dir depends on only three lines in the graph_manager package specifica;ion. Thus, if a 
new function declaration were added to the specification, and graph_manager were recom¬ 
piled, arct_dir would have to be recompiled as well, even though arct_dir does not depend on 
the change at all. 

This is the typical situation in which the arct model of change propagation demonstrates its use¬ 
fulness. The ARCT model allows the user to divide each source file linearly into contiguous seg¬ 
ments. In a make-file statement, the “exclude list” associated with a particular dependency 
specifies which of the segments to “ignore.” Any changes within an excluded segment will not 
trigger recompilation of the dependent unit. 

The segments are delineated by change_type pragmas. Such a pragma accepts two arguments: 
first, a double-quote delimited string naming the segment, and second, a double-quote delimited 
string used to disambiguate similar pragmas between files. 

If any changes are discovered in a segment, they are given the change type specified by the first 
argument. A list of change types classifying all of the changes made in the source file is col¬ 
lected, the types in the exclude list are removed, and if any are left over, a recompilation is trig¬ 
gered. For example, suppose the GRAPH_MANAGER source file looked like this: 

gra PH_MA NAGER with pragma CHA NGE_ TYPES incorporated: 

with TEXT.JO, iwY_STRINGS; 
use TEXTJI ), MY_STRINGS', 

package GRAPH-MANAGER is 

pragma CHANGE_TYPE(”types_n_objects”, ”-1705581224”); 

- Type and Object declarations ommitted since they are not 

- used in this example. 


pragma CHANGE_TYPE(”ARCT_DIR_dependencies”, ”-1152799532”); 

procedure DIRECTORY; 

function display_DER return boolean ; 

function DISPLAY.VER return BOOLEAN; 

pragma CHANGE_TYPE(”fns_n_procs”, ”-600013388”); 

- Other Procedure and Function declarations ommitted since 

- they are not used in ARCT_DIR. 


end GRAPH-MANAGER; 


UNCLASSIFIED 










ft 


ft 


ft 


ft 


I 


ft 


ft 


> 


i 


UNCLASSIFIED 21 


Any changes occurring between the “types_n_objects” pragma and the 
“ARCT_DIR_dependencies” pragma will cause types_n_objects to be added to the change list. 
ARCT_DiR_dependencies will be added if any changes occur between the 
“ARCT_DIR_dependencies” pragma and the “fns_n_procs” pragma, and any changes below 
the “fns_n_procs” pragma will be given the change type fns_n_procs. If any changes occur 
before the first change_type pragma in the file, the type general is added to the change list. If 
the statement in the make-file which specifies the dependencies of the arct_dir object file is 
now modified to look like this: 

arct_dir.o: arct_dir.a 

graph_manager.a /types_n_objects /fns_n_procs 

arct_globals.a 

arg_scanner.a; 

then no changes to the file graph_manager.a will cause the unit ARCT_DIR to be recompiled 
unless the changes are to the segment of the file that has been labelled 
“ ARCT JDIR_dependencies.” 

The units arct.globals and arg_scanner should now examined. By modifying them as 
shown, they can also be divided into logical segments by change_type pragmas. 

arct_globals with pragma changeltypes incorporated: 

with a_strings; 
use A_STRINGS; 

package ARCT_GLOBALS is 

pragma CHANGE_TYPE(”path_variable”, ”1909261532”); 

PATH : A_STRING := EMPTY; 

pragma CHANGE_TYPE(”dgraph_procs”, ”-1832925332”); 
procedure GET_DGRAPH; 
procedure BACKUPJDGRAPH; 
procedure PUT JDGRAPH; 

pragma CHANGE_TYPE(”vgraph_procs”, ”-1280140486”); 
procedure GET_VGRAPH; 
procedure BACKUP.VGRAPH; 
procedure PUT.VGRAPH; 

pragma CHANGE_TYPE(”additional_procs”, ”-727358928”); 

- Add new procedure declarations here 

pragma CHANGE_TYPE(”exceptions”, ”-174574049”); 

INDEX_JTLEJJOT_FOUND : exception; 

end ARCT.GLOBALS; 


UNCLASSinED 






UNCLASSIFIED 


22 


arg_scanner with pragma change_types incorporated: 

package ARG_SCANNER is 

pragma CHANGE_TYPE(”types_n_objects”, ’’378240656”); 

type FLAG_ARRAY_TYPE is array(’0’ .. ’z’) of BOOLEAN; 

RESETJFLAGS : constant FLAG_ARRAY_TYPE := 

( FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
FAISE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 

FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 

FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 
FALSE, FALSE, FALSE 
); 


pragma CHANGE_TYPE(”fns_n_procs”, ”931020073”); 

procedure GET_ARGS(POSSIBLfc_FLAGS : in STRING; 

FLAGS : in out FLAG_ARRAY_TYPE; 
ARG_PTR : in out INTEGER); 

pragma CHANGE_TYPE(”additional_procs”, ”1483799498”); 
- Add new procedure declarations here 

pragma CHANGE_TYPE(”exceptions”, ”2036578931”); 

invalidJFLAG : exception; 

end ARG_SC ANNER; 


By encorporating the appropriate change types into the make-file or arct_DIR, the amount of 
recompilation can be reduced to a minimum: 

Final arct_dir make-file script: 

arg_scanner.o: arg_scanner.a; 

arct_globals.o: arct_globals.a; 

my_strings.o: my_strings,a; 

graph_manager.o: graph_manager.a 
my_strings.a; 


UNCLASSIFIED 








UNCLASSIFIED 


23 


arct_dir.o: arct_dir.a 

graph_manager.a /types_n_objects /fns_n_procs 
arct_globals.a /additional_procs 
arg_scanner.a /additional_procs; 

arct_dir.e: arct_dir.o my_strings.o graph_manager.o arct_globals.o arg_scanner.o 
text_io.o u_env.o a^strings.o file_support.o; 

.if o 


UNCLASSIFIED 






UNCLASSIFIED 


UNCLASSIFIED 





UNCLASSIFIED 


25 


Appendix B: COMMENTED SOURCE CODE 


This implementation of the arct was a prototyping venture, and the source code reflects this. 
There are several areas where code optimizations would improve run-time performance. This 
disclaimer applies to all of the arct source code: 


DISCLAIMER OF WARRANTY AND LIABILITY 


THIS IS EXPERIMENTAL PROTOTYPE SOFTWARE. IT IS PROVIDED “AS IS” 
WITHOUT WARRANTY OR REPRESENTATION OF ANY KIND. THE INSTITUTE 
FOR DEFENSE ANALYSES (IDA) DOES NOT WARRANT, GUARANTEE, OR MAKE 
ANY REPRESENTATIONS REGARDING THIS SOFTWARE WITH RESPECT TO 
CORRECTNESS, ACCURACY, RELIABILITY, MERCHANTABILITY, FITNESS FOR 
A PARTICULAR PURPOSE, OR OTHERWISE. 

USERS ASSUME ALL RISKS IN USING THIS SOFTWARE. NEITHER IDA NOR ANY¬ 
ONE ELSE INVOLVED IN THE CREATION, PRODUCTION, OR DISTRIBUTION OF 
THIS SOFTWARE SHALL BE LIABLE FOR ANY DAMAGE, INJURY, OR LOSS 
RESULTING FROM ITS USE, WHETHER SUCH DAMAGE, INJURY, OR LOSS IS 
CHARACTERIZED AS DIRECT, INDIRECT, CONSEQUENTIAL, INCIDENTAL, SPE¬ 
CIAL, OR OTHERWISE. 


UNCLASSIFIED 



UNCLASSIFIED 


26 


B.l. graph_manager Package 


DIRECTORY-Displays unit names of all current units in the version control graph in the current 
window. 

DISPLay_der— Function which displays a comprehensive record of the current derived unit 
graph. It returns a boolean value: false if the derived structure is empty, true otherwise. 

display..ver— Function which displays a comprehensive record of the current source archive 
graph. It returns a boolean value: false if the archive structure is empty, true otherwise. 

add_to_ver_graph— Increases the size of the version control graph node array by one. The 
new node pointer is the last one in the array, and points to null. 

add_to_der_graph— Performs the same function as add_to_ver_graph for the derived unit 
graph. 

CREATE_VER(fname_in, unit_in)-Adds a brand new node to the version control graph with the 
given unit and file names. 

FlND_cuRRENT(unit_in, file_out, node_num)-Locates the node with the unit name specified by 
unitjn and the currency flag set. It returns the file name associated with this node in FILE_out, 
and returns the node number itself in NODE_NUM. 

DESCEND(unit_in)-Adds a node to the version control graph as a child of the current UNUJtN. 
The new child node inherits all traits of the parent except file name (a new file name is generated 
from the parent file name- the name and extension are the same, but the next higher version 
number is used). 

PARENT_FILE(node)-Function which returns the file name of the first parent of the given node. 
If the given node has no parents, then (others=>‘ ’) is returned. 

NUM_CHlLDREN(file)— Function which, given a file name identifying a specific node in the version 
control graph, returns the number of child nodes pointed to by that node. If no node with the 
given file name is found, zero is returned. 

NODE_EXlSTENCE_CHECK(file)— Function used to test for the existence of a node with a given file 
name. The boolean value returned is true only if a node with the given file name exists in the ver¬ 
sion control graph. 

ALTERNATTVE(file, unit_out, file_out)-The first input uniquely determines a single node in the 
version control graph. If no unit with the given file name exists, nothing happens. If found, a new 
child of this unit is created with UNIT.OUT as its unit name, and FILE_OUT as its file name. This 
allows multiple inheritance paths to be derived from a single source file. Successive calls to 
MERGE allow a node with an arbitrary number of children to be created. 

STORE_VER_GRAPH(fspec :in FILEJTYPE)—Stores the version control graph in a file of mode 
OUTJFILE. 

STORE_DER_GRAPH(fspec :in filejtype)—S tores the derived unit graph in a file of mode 
OUTJFILE. 


UNCLASSIFIED 






UNCLASSIFIED 


27 


READ_VER_GRAPH(fspec :in file_type)—R eads in a stored copy of the version control graph to 
replace the current copy, fspec must be a file of mode in f tt.f . 

READ_DER_GRAPH(fspec :in FILE_TYPE)—Same as READ_VER_GRAPH, for the derived unit graph. 

MERGE(new_parent, child, new_unit_name, new_file_name)— modifies a node in the version 
control graph so that it has an additional parent. NEW_parent is a file name identifying the node 
to be added to the parent array of the node to be modified. CHILD is a file name identifying the 
node to add a parent to. The node is modified “in place” (no new node is created, the old one is 
replaced). The names in new_unit_name and new_file_name are assigned to the node once it 
is modified so that its names can be changed. Successive calls to merge allow a node with an 
arbitrary number of parents to be created. 

MERGE(new_parent, child)—The same as above, except that the current unit and file names for 
the child unit go unchanged. This allows a node to be MERGEd even thought these quantities are 
unknown. 

SET_cuRRENT(unit_in, file_in)-Finds the node in the version control graph with unit name 
unitjn and the currency flag set. It resets this currency flag, then finds the node with unit name 
UNITJN and file name FILEJN, setting its currency flag. 

BlND(make, file)—Given make, the file name of a make-file, and FILE, the file name of a file in the 
version control graph- it searches for the node in the version control graph associated with file, 
and fills that node’s MAKE_FILE field with MAKE. 

GET_MAKE_FiLE_NAME(module)—This function finds the node in the version control graph with 
unit name MODULE with the currency flag set and returns the MAKE_FILE name associated with 
this node. 


graph_maNAGER Package Specification (graphjnanager.a); 

with TEXT_IO,MY_STRINGS; 
use TEXT_IO,MY_STRINGS; 


package GRAPH_MANAGER is 

type parent_array is array (NATURAL range <>) of NATURAL; 
subtype child_array is parent_array; 


procedure DIRECTORY; 

function DISPLAY_DER return Boolean; 

function DISPLAY.ver return Boolean; 


procedure ADD_TO_VER_GRAPH; 
procedure ADD_TO_DER_GRAPH; 


procedure CREATE.VER 


(fnamejn :in file_name; 

unitjn :in unit_name); 


procedure FIND.CURRENT 


(unitjn :in unit jiame; 

file.out :out filejiame; 

node jium : out natural) ; 


UNCLASSIFIED 





UNCLASSIFIED grapkmanager Specification 


28 


procedure DESCEND 


(unit_in :in unit_name); 


function parent_file (node :in positive) 

return file_name; 

function NUM_CHILDREN (file :in file_name) 
return NATURAL; 

function NODE_EXlSTENCE_CHECK (file :in file_name) 
return BOOLEAN; 


procedure ALTERNATIVE 

(file 

unit_out 

file_out 

:in file_name; 

:in unit_name; 

:in file_name); 

procedure store_ver_graph 
procedure STORE_DER_GRAPH 

(fspec :in FILE_TYPE); 

(fspec :inFlLE_TYPE); 

procedure READ_VER_graph 
procedure READ_DER_GRAPH 

(fspec :inFiLE_TYPE); 

(fspec :in FILE_type); 

procedure MERGE 

(new_parent 

child 

:in file_name; 

:in file_name); 

procedure MERGE 

(new_parent 

child 

new_unit_name 

new_file_name 

:in file_name; 

:in file_name; 

:in unit_name; 

:in file_name); 

function SET_CURRENT 

(unitjn 

file_in 

:in unit_name; 

:in file_name) 


return Boolean; 

procedure BIND (make :in make_file_name; 

file :in file_name); 

function getjmake_FILE_name (module :in unit_name) 
return file_name; 


end GRAPHLMANAGER; 


graph^manager Package Body (graph_manager.b.a); 

with TEXT_IO, INT_IO, GRAPHS, FILE_UTIL, MY_STRINGS, COUNT_IO; 
use TEXT_IO, INT_IO, GRAPHS, FILE.UTIL, MY_STRINGS; 

package body graph_manager is 


procedure directory is -displays names of all current units 

- in the current window 


UNCLASSIFIED 








UNCLASSIFIED 


graph_manager Body 29 


begin 


if ver_graph.num_el > 0 then -make sure there are nodes in graph 
for i in l..ver_graph.num_el loop 

- execute loop for each node 
if ver_graph.vergraph_ptr(i).currency then 

put _line(trim(ver_graph.vergraph_ptr(i) .unit)); 
-if node is a current unit, then display it 

end if; 
end loop; 

end if; 
return; 

end DIRECTORY; 

function DISPLAY_DER return Boolean is 

-displays comprehensive listing of derived graph 
-returns false if there are no nodes in the graph 


begin 


if der_graph.num_el > 0 then -make saure there are nodes in graph 
for i in l..der_graph.num_el loop -repeat for each node 
put(“Unit :”); 

put_line(trim(der_graph .dergraph_ptr(i) .unit)); 
put(“File Type:”); 

put(der_graph .dergraph_ptr(ij.f_type); 

put_Jine(“”); 

put(“Version :”); 

put(der_graph.dergraph_ptr(i).version,3); 

putjine(“”); 

put(“Source Dependencies:”); 
put(der_graph .dergraph_ptr(i).s,3); 
put_line(“”); 

if der_graph.dergraph_ptr(i).s > Othen 
for j In l..der_graph.dergraph_ptr(i).s loop 

put(der_graph.dergraph_ptr(i).source_array(j).node,4); 
put(“ ”); 

if der_graph.dergraph_ptr(i).source_array(j).derived then 
put Jine(“Derived”); 

else 


put_line(“Source”); 

end if; 

end loop; 
end if; 
end loop; 

return True; -when all are successfully printed 

else 


return False; -if no nodes in derived graph 

end if; 


end DISPLAY_DER; 


UNCLASSIFIED 




UNCLASSIFIED 


GRAPHJAANAGER Body 30 


function display.ver return Boolean is 

-displays comprehensive listing of derived graph 
-returns false if there are no nodes in the graph 


begin 


if ver_graph.num_el > 0 then -make saure there are nodes in graph 
fori in l..ver_graph.num_el loop -repeat for each node 
put(“File :’”); 

put_line(trim(ver_graph.vergraph_ptr(i).fname) & 
put(“Unit 

put_line(trim(ver_graph.vergraph_ptr(i).unit) & 
put(“Currency 

if ver_graph.vergraph_ptr(i).currency then 
put_line(“True”); 

else 

put_line(“False”); 

end if; 

put(“Make file:’”); 

put_line(trim(ver_graph.vergraph_ptr(i).make_file) & “”’); 
put(“Parents :”); 

if ver_graph.vergraph_ptr(i). p > 0 then 

for j in 1 .. ver_graph. vergraph_ptr(i). p loop 

put(ver_graph .vergraph_ptr(i) ,parents(j) ,3); 
put(“ ”); 

end loop; 

put_line(“”); 

else 

putJine(“none”); 

end if; 

put(“Children :”); 

if ver_graph.vergraph_ptr(i).c > 0 then 

for j in l..ver_graph.vergraph_ptr(i).c loop 

put(ver_graph. vergraph_ptr(i) ,children(j) ,3); 
put(“ ”); 

end loop; 

put_line(“”); 

else 

putJine(“none”); 

end if; 

put_line(“”); 

end loop; 

return True; -when all are successfully printed 

else 

return False; -if no nodes in derived graph 

end if; 

end DISPLAY_VER; 


procedure ADD_TO_VER_GRAPH is 
result :ver_graph_rec; 


-add a node to the dynamic array 

-in the version graph 

-holds the new VER_GRAPH 


UNCLASSIFIED 




UNCLASSIFIED 


GRAPH_MANAGER Body 31 


i ‘.natural := ver_gr aph .num_el; 

-holds num_el for the new graph 


begin 


result := (i + 1 , new vgraph(l..i + 1)); -allocate new array 

if i > 0 then -if there are any nodes in old array, transfer 
— them to the new array: 

result.vergraph_ptr(l..i) := ver_graph.vergraph_ptr(l..i); 

end if; 

ver_graph := result ; -replace global variable with new VER_GRAPH 
end ADD_TO_VER_GRAPH; 


procedure ADD_TO_DER_GRAPH is -add a node to the dynamic array 

-in the derived graph 
-works just like the above 


result :DER_graph_rec; 

i :natural := der_graph.num_el; 


begin 


result := (i + 1 , new dgraph(l..i + 1)); 

if i > 0 then 

result.dergraph_ptr(l..i) := der_graph.dergraph_ptr(l..i); 

end if; 

der_graph := result; 
end add_to_der_graph; 


procedure CREATE_VER(fname_in :in file_name; unit_in :in unit_name) is 
-adds a new node with no parents to the graph with the given 
- file and unit names 

result :ver_node_ptr; -holds pointer to new node 

begin 


add_TO_ver_graph; -make space in dynamic array for a new node 
result := new version_node(0,0); -allocate new node 
result.fname := fname_in; -file in file name 

result.unit:« unit_in; - and unit name 

result.currency :« TRUE; -make it current 

ver_graph.vergraph_ptr(ver_graph.num_el) := result; 

-insert it as the new element in the array 
return; 


UNCLASSIFIED 




UNCLASSIFIED 


GRAPH_MANAGER Body 32 


end create_ver; 


procedure MY_GET_UNE(fspec : in FILE_TYPE; item : out STRING; 
last : out NATURAL) is 

-This procedure emulates the TEXT_IO procedure GET_LINE 
-It was necessary to write this because the MicroVaxII’s 

-predefined GET_LINE acts differently than it should. • 

-This procedure provides the appropriate results and is 
-compatible with the 8600's Ada. 

-This routine isn't completely fool-proof, but it does the job 
result : string (item'first-.item'last) := (others => 4 ’); 

count : natural := 0; • 


begin 


while not end_of_line(fspec) loop -loop until end of line 
count := count + 1; 
get(fspec,result(count)); 
end loop; 
skip_line(fspec); 
item := result; 

last := count; 

return; 

end my_getjline; 


procedure BIND(make :in makejfile_name; file :in file_name) is 
-This procedure binds the given make file to the node 
- corresponding to the given file 

dest INTEGER :=0; 


begin 

-search for node corresponding to file specified 
for i in reverse l..ver_graph.num_el loop 

ifver_graph.vergraph_ptr(i).fname = file then 
dest := i; 

exit; 
end if; 
end loop; 

if dest > 0 then -if node found 

ver_graph.vergraph_ptr(dest).make_file := make; 

end if; 

-if node isn't found, nothing happens 

end BIND; 


UNCLASSIFIED 







UNCLASSIFIED 


g ra ph_ am na ger Body 33 


function GET_MAKEJFlLE_NAME(module: in unit_name) return file_name is 
-This function returns the make file name associated with 
-The current node for a given unit 

fname :file_name; 

temp integer; 


begin 


FlND_cuRRENT(module,fname,temp); -get the current node for the 

-given unit 

if temp > 0 then —If its found, 

return ver_graph.vergraph_ptr(temp).make_file; 
else -If not found, return blanks 

return (others => ‘ ’); 
end if; 

end get_make_file_name; 


procedure FlND_CURRENT(unit._in :in unit_name; file_out :out file_name; 
node_num :out natural) is 
-This procedure finds the node with the given unit name 
- and returns its file name and array index 

temp .INTEGER; 


begin 

for i in reverse l..ver_graph.num_el loop 

if ver_graph.vergraph_ptr(i).unit = unit_in and then 
ver_graph.vergraph_ptr(i).currency then 
file_out := ver_graph.vergraph_ptr(i) .fname; 

node_num :=i; 
return; 
end if; 

end loop; 

file_out := (others =>*’); 

node_num := 0; 

return; 

end FIND_CURRENT; 


function PARENT_FILE(node :in POSITIVE) return file_name is 

-This function returns the file name of the first parent 

-of the given node (or blanks, if the node doesn't have parents) 

begin 


if ver_graph.vergraph_ptr(node).p > 0 then 

retum(ver_graph ,vergraph_ptr(ver_graph. vergraph_ptr(node). 


UNCLASSIFIED 




UNCLASSIFIED 


GRAPH.MANAGER Body 34 


parent s (1)). f name); 

else return (others => ‘ ’); 
end if; 

end PARENT_FILE; 


procedure DESCEND(unit_in :in unit_name) Is 

-This procedure creates a child of the current node 
-of the given unit, gives it the descended file name of that 
-node, makes the parent node no longer current, and makes the, 
-new child current. 


filel 

parent_node 

new_node 

old_pnode 

old_p 

old_c 


:file_name; 

nnteger; 

:ver_node_ptr; 

:ver_node_ptr; 

:NATURAL; 

:natural; 


begin 


FlND_cuRRENT(unit_in,filel,parent_node); -find the parent node 
old_p := ver_graph.vergraph_ptr(parent_jnode).p; -number of grandparents 
old_c := ver_graph.vergraph_ptr(parent_node).c; -number of children 

old_pnode := new version_node(old_p,old_c+l); -allocate new parent 
-transfer all data from old parent node to new parent node 
old_pnode.fname := ver_graph.vergraph_ptr(parent_node).fname; 
old_pnode.unit := ver_graph.vergraph_ptr(parent_node).unit; 
for i in l..old_p loop 

okLpnode.parents(i) := 

ver_graph.vergraph_ptr(parent_node).parents(i); 

end loop; 

for i in l..old_c loop 

old_pnode.children(i) := 

ver_graph.vergraph_ptr(parent_node).children(i); 

end loop; 

o!d_pnode.currency := false; -make new parent node currency false 

add_TO_ver_graph; -add space for child in array 

-set next element in parent's child array to new child node 
old_pnode.children(olcLc+l) := ver_graph.num_el; 

new_node := new version_node(l,0); -allocate new child node 

new_node.currency := TRUE; -make it current 

new_node.parents(l) := parent_node; -point to its parent 
new_node.unit := old_pnode.unit; -inherit useful info 
new_node.fname := descend_fname(old_pnode.fname); 

-replace old parent node with new version of parent 
ver_graph.vergraph_ptr(parent_node) := olcLpnode; 

-install the child node 

ver_graph.vergraph_ptr(ver_graph.num_el) := new_node; 

return; 


UNCLASSIFIED 








UNCLASSIFIED 


GRAPH^bAA NAGER Body 


end DESCEND; 


function NUM_CHlLDREN'(file :in file_name) return NATURAL is 
result INATURAL := 0; 


begin 


for i in reverse l..ver_graph.num_el loop 

if ver_graph.vergraph_ptr(i).fname = file then 

result := ver_graph.vergraph_ptr(i).c; 
exit; 

end if; 
end loop; 
return result ; 

end NUM_CHILDREN; 


function NODE_EXISTENCE_CHECK(file :h> file_name) return BOOLEAN is 

begin 


for i in reverse l..ver_graph.num_el loop 

if ver_graph.vergraph_ptr(i).fname = file then 
return true; 

end if; 
end loop; 
return False; 

end NODE_EXISTENCE_CHECK; 


procedure ALTERNATIVE ( file 


:in file_name; 
unit_out :in unit_name; 

file_out :in file_name) is 


result :ver_node_ptr; 
new_parent :ver_node_ptr; 
parent INTEGER := 0; 


begin 


-find the parent node: 
for i in reverse l..ver_graph.num_el loop 

ifver_graph.vergraph_ptr(i).fname = file then 
parenti; 
exit; 

end if; 


UNCLASSIFIED 





UNCLASSIFIED 


GRAPH_MANAGER Body 36 


end loop; 

if parent > 0 then -parent = 0 means parent not found 

-allocate and fill new child node # 

result := new version_node(l,0); 
result.unit := unit.ouf; 
result.fname := file_out; 
result.parents(l) := parent; 
result .currency := TRUE; 

-make space for it • 

ADD_TO_VER_GRAPH; 

-install it 

ver_graph.vergraph_ptr(ver_graph.num_el) := result; 

-allocate new parent node and copy from old parent 
new_parent := new version_node(ver_graph.vergraph_ptr(parent).p, • 

ver_graph.vergraph_ptr(parent).c + 1); 
new_parent.unit := ver_graph.vergraph_ptr(parent).unit; 
new_parent.fname := ver_graph.vergraph_ptr(parent).fname; 
new_parent.currency := ver_graph.vergraph_ptr(parent).currency; 
for 1 in l..new_parent.p loop 

new_parent.parents(l) := • 

ver_graph. vergraph_ptr(parent) .parents(l); 

end loop; 

for 1 in l..new_parent.c - 1 loop 
new_parent.children(l) := 

ver_graph. vergraph_ptr (parent) .children(l); 

end loop; • 

-point to new child 

new_parent.children(new_parent.c) := ver_graph.num_el; 

-install in place of old parent 
ver_graph.vergraph_ptr(parent) := new_parent; 

end if; 

return; • 

end ALTERNATIVE; 


procedure STORE.VER_GRAPH(fspec :in FILE_TYPE) is 

-Stores copy of the version control graph into a text file 


begin 


-store number of nodes in graph 
pu t (f spec, ver_gr aph. num_el, width=> 6); 

-sotre each node: 
for i in l..ver_graph.num_el loop 

put(fspec ,ver_graph.vergraph_ptr(i) .p, width->6); 
put(fspec,ver_graph.vergraph_ptr(i).c,width->6); 
put _line(f spec, ver_graph. vergraph_ptr(i). fname); 
put Jine(fspec ,ver_graph.vergraph_ptr(i).unit); 
put _line(fspec ,ver_graph.vergraph_ptr(i).make_file); 
if ver_graph.vergraph_ptr(i).currency then 


UNCLASSIFIED 





UNCLASSIFIED 


GRAPH_MANAGER Body 37 


ft 


put(fspec,‘T’); -store currency 

else put(fspec,‘F’); 

ft end if; 

if ver_graph.vergraph_ptr(i).p > 0 then -store parent array 
for j in l..ver_graph.vergraph_ptr(i).p loop 

put(fspec ,ver_graph. vergraph_ptr(i) .parents(j), 
width=>6); 

end loop; 

ft end if; 

if ver_graph.vergraph_ptr(i).c > 0 then -store child array 
for j in l..ver_graph.vergraph_ptr(i).c loop 

put(fspec ,ver_graph/vergraph_ptr(i) .children(j), 
width=>6); 

end loop; 

ft end if; 

end loop; 

end STORE_VER_GRAPII; 


procedure STORE_DER_GRAPH(fspec :in FILE_TYPE) is 

-same as STORELVER_GRAPH, butu for derived graph 

begin 


put(fspec ,der_graph .num_el, width=>6); 

• for i in 1. .der_graph.num_el loop 

put (f spec ,der_graph .dergraph_ptr(i). s, widt h=> 6); 
put_line(fspec,der_graph.dergraph_ptr(i) .unit); 
put(fspec,der_Graph.dergraph_ptr(i).l_type); 
put(fspec,der_graph.dergraph_ptr(i).version,width => 6); 
for j in l..der_graph.dergraph_ptr(i).s loop 

• put(fspec ,der_graph .dergraph_ptr(i). source_array(j). 

node,width=>6); 

if der_graph.dergraph_ptr(i).source_array(j).derived 
then put(fspec,‘T’); 
else put(fspec,‘F’); 

end if; 

• end loop; 

end loop; 

end store_der_GRAPH; 


procedure READ_VER_GRAPH(fspec :in FILE_TYPE) is 

-recovers version control graph stored in a text file and 
-replaces the current graph with it 


ch 

num_elmts 

p,c 

temp 


:character; -for reading currency variables 
:natural; -for reading number of nodes in graph 
:NATURAL; -for reading parent and child counts 
:NATURAL; 


UNCLASSIFIED 




UNCLASSIFIED 


GRAPHJAANAGER Body 38 


begin 


-get the number of nodes in the graph 
get(fspec,num_elmts,width=>6); 

-allocate space for the node array 
ver_graph := (num_elmts, new vgraph(l..num_elmts)); 
for i in l..ver_graph.num_el loop -get each node 
get(fspec,p,width=>6); 
get(fspec ,c ,width=>6); 

ver_graph.vergraph_ptr(i) := new version_node(p,c); 

my_g e t_li ne (fspec, v e r _g ra ph.vergraph_ptr(i).fname,temp); 

my_get_line(fspec,ver_graph.vergraph_ptr(i). unit, temp); 
my_get_line(fspec,ver_graph.vergraph_ptr(i).make_file,temp); 
get(fspec.ch); 

if ch ** ‘T’ then ver_graph.vergraph_ptr(i).currency := true; 
elsever_graph.vergraph_ptr(i).currency := false; 

end if; 
if p > 0 then 

forj in l..p loop 

get(fspec,ver_graph.vergraph_ptr(i).parents(j), 

width=>6); 

end loop; 
end if; 
if c > 0 then 

for j in l..c loop 

get(f spec ,ver_graph .vergr aph_ptr (i) .children (j), 
width=>6); 

end loop; 
end if; 
end loop; 

end READ_VER_GRAPH; 


procedure READ_JDER_GRAPH(fspec :in FILE-TYPE) is 
-same as above, except for derived graph 


num_elmts 

num_src 

temp 

c 


INATURAL; 

INATURAL; 

integer; 

:character; 


begin 


-get the number of nodes in the graph 
get(f spec, num_elmt s,width* >6); 

-allocate array to hold the nodes 
der_graph (num_elmts, new dgraph(l..num_elmts)); 
for i in l..num_elmts loop 

get(fspec,num_src , width- >6); 

der_graph.dergraph_ptr(i) := new der_node(num_src); 
my_get_line(fspec ,der_graph .dergraph_ptr(i) .unit ,temp); 


UNCLASSIFIED 





UNCLASSIFIED 


GRAPH_MANAGER Body 39 


get(fspec,der_graph.dergraph_ptr(i).f_type); 
get(fspec ,der_graph .dergraph_ptr(i) .version ,width=>6); 
for j in l..num_src loop 

get(fspec, der_graph .dergr aph_ptr (i). source_array (j). 

node,width=>6); 

get(fspec.c); 

if c = ‘t’ then der_graph.dergraph_ptr(i). 

source_array(j).derived := True; 
else der_graph.dergraph_ptr(i). 

source_array(j).derived := False; 

end if; 
end loop; 
end loop; 

end read_der_graph; 


procedure MERGE (new_parent :in file_name; 

child :in file_name) is 

-This procedure calls MERGE to create a child unit that has 
-the same unit and file names it had on entry. This allows 
-MERGE to affect a node without changing its name. 


begin 


for i in reverse l..ver_graph.num_el loop 

if ver_graph.vergraph_ptr(i).fname = child then 
merge(new_parent, child, 

ver_graph.vergraph_ptr(i).unit, 
ver_graph.vergraph_ptr(i).fname); 
return; 
end if; 
end loop; 


end merge; 


procedure MERGE (new_parent 

:in file_name; 

child 

:in file_name; 

new_unit_name 

:in unit_name; 

new_file_name 

-This procedure is used to "add” a parent to a specific node in 
-the version control graph. The first file name identifies 
-the node to be added as a parent, and the second file identifies 
-the node to add the new parent to. This "child” node will 

:in file_name) is 


-be given the unit and file names specified by the last two 
-arguments.. 


new_parent_node 

child-node 

num_parents 


: INTEGER 

:-o; 

: INTEGER 

;*0; 

INTEGER 

:* 0 


UNCLASSIFIED 






UNCLASSIFIED 


GRAPH_MANAGER Body 40 


result :ver_node_ptr; 

new_parent_rec :ver_node_ptr; 


begin 


-find child node and new parent node 
for i in reverse l..ver_graph.num_el loop 

if ver_graph.vergraph_ptr(i).fname = new_parent then 
new_parent_node :=i; 

end if; 

if ver_graph.vergraph_ptr(i).fname = child then 
child_node := i; 

end if; 

exit when new_parent_node > 0 and then child_node > 0; 

end loop; 

-if both nodes found 

if new_parent_node > 0 and child_node > 0 then 
-save num parents of child node 
num_parents := ver_graph.vergraph_ptr(child_node).p; 

-allocate and fill new child node 
result := new version_node(num_parents + 1,0); 
result.fname := new_file_name; 
result.unit := new_unit_name; 
result.currency := TRUE; 
for i in l..num_parents loop 
result.parents(i) := 

ver_graph .vergraph_ptr(child_node) .parents(i); 

end loop; 

result.parents(num_parents + 1) := new_parent_node; 
ver_graph.vergraph_ptr(child_node) := result; 

-allocate and fill new node to replace parent 
new_parent_rec := new version_node( 

ver_graph. vergraph_ptr(new_parent_node). p, 
ver_graph.vergraph_ptr(new_parent_node).c +1); 
new_parent_rec.unit := 

ver_graph.vergraph_ptr(new_parent_node) .unit; 
new_parent_rec.fname := 

ver_graph. vergr aph_ptr (new_parent_node). fname; 
new_parent_rec.currency := 

ver_graph.vergraph_ptr(new_parent_node).currency; 
for 1 in l..new_parent_rec.p loop 
new_parent_rec.parents(l) := 

ver_graph.vergraph_ptr(new_parent_node).parents(l); 

end loop; 

fori in l..new_parent_rec.c-l loop 
new_parent_rec.children(l) 

ver_gr aph .vergraph_ptr(new_parent_node). children (1); 

end loop; 

new_parent_rec.children(new_parent_rec.c)child..node; 
ver_graph.vergraph_ptr(new_parent_node)new_parent_rec; 

end if; 

end merge; 


UNCLASSIFIED 






UNCLASSIFIED 


GRAPHLMANAGER Body 


function SET_CURRENT( unitjn :in unit_name; 

file Jn :in file_name) return Boolean is 
-This procedure finds two nodes: one corresponding to the 
-current version of the specified unit, the second corresponding 
—to the node having both the given unit name and file name. 
-Provided it finds the second (this implies the first exists), 

-it resets the currency flag of the first and sets that of the 
-second, changing which file is considered ’’current” for, 

-the given unit name. 

file :file_name; 

node :natural; 

new_node :natural := 0; 


begin 


FlND_cuRRENT(unit_in, file, node); -find first node 
for i in reverse l..ver_graph.num_el loop -search for second node 
if ver_graph.vergraph_ptr(i).unit = unitjn and then 
ver_graph.vergraph_ptr(i).fname = filejn then 
new_node := i; 

end if; 
end loop; 

if new_node > 0 then -if second node found 

ver_graph.vergraph_ptr(node).currency := FALSE; 
ver_graph.vergraph_ptr(new_node).currency := TRUE; 
return True; 

else 

return False; 
end if; 

end SET_CURRENT; 


end GRAPH_MANAGER; 

GRAPHS Package (graphs.a); 

with MY_STRINGS; 
use MY_STRINGS; 

package GRAPHS is 

type parent_array is array (NATURAL range < >) of NATURAL; 
subtype child_array is parent_array; 

-Type declarations necessary for version control graph: 


UNCLASSIFIED 




UNCLASSIFIED 


graphs Package 42 


type version_node (p,c :NATURAL) is record 


fname 

:file_name 

:= (others = 

unit 

:unit_name 

:= (others = 

currency 

:boolean 

:= FALSE; 

make_file 

:make_file_n?rne 

:= (others => ‘ ’); 

parents 

: par ent_arr ay (1.. p); 


children 

:child_array(l..c); 



end record; 

type ver_node_ptr is access version_node; 

type vgraph is array (NATURAL range <>) of ver_node_ptr; 

type vgraph_ptr is access vgraph; 

type ver_graph_rec is record 

num_el :natural := 0; 

vergraph_ptr :vgraph_ptr; 

end record; 


-Type declarations necessary for derived unit graph 

type source_rec is record 

node :natural := 0; 

derived :Boolean := False; 

end record; 


type s_array is array (POSITIVE range < >) of source_rec; 


type der_node (s :NAIURAL) is record 


unit 

:unit_name 

:= (others => ‘ 

f_type 

: CHARACTER 

i >, 

* > 

version 

:POSnTVE 

:-l; 

source_array 

end record; 

:s_array(l..s); 



type der_node_ptr is access der_node; 

type dgraph is array (natural range < >) of der_node_ptr; 

type dgraph_ptr is access dgraph; 

type der_graph_rec is record 

num_el :natural := 0; 

dergraph_ptr :dgraph_ptr; 

end record; 


-Variables to hold main data structures: 
ver_graph :ver_graph_rec; 

der_graph :der_graph_rec; 


UNCLASSIFIED 







UNCLASSIFIED 


graphs Package 


end GRAPHS; 


UNCLASSIFIED 






UNCLASSIFIED 


44 


B.2. MAKE_PROCS Package 


BUlLD_MAKE_STRUCT(make_file)-This function takes as its argument a make-file name, and 
builds a data structure containing all of the useful information in the make-file for the purposes 
of MAKE. It returns a boolean value that is True if the file was successfully read without any syn¬ 
tax errors. 

make— Called after build_make_struct. It uses the information in make_struct (a global 
data structure generated by build_make_struct) to generate derived files from source files and 
other derived files. 

makelprocs Package Specification (make_procs.a): 

with MY_STRINGS; 
use MY_STRINGS; 

package MAKE_PROCS is 

MAK£_FAILED : exception; 

function Bu'ILD_maKE_struct ( make_file :in make_file_name) 
return Boolean, 

procedure make; 

-Exceptions for this package: 

MAKE_FILE_SYNTAX exception; 

end makejprocs; 


makelprocs Package Body fmake_procs.b.aJ: 

with TEXTJO, GRAPH_MANAGER, FILE_UTTL, GRAPHS, ARCT_GLOBALS, 
MAKE_UTIL, INT_IO, COUNT_IO, A_STRINGS, UNIX_PRCS; 
use TEXT_IO, GRAPH_MANAGER, FILE_UTTL, GRAPHS, 

MAKE_UTIL, INT_IO, A_STRINGS; 

package body MAKE_PROCS is 


-Type declarations 

-Type declarations necessary for MAKE_STRUCT 


type dependency_rec is record 

unit :unit_name; 

Ltype :CHARACTER; 

excludejist :large_vstring; 

end record; 


UNCLASSIFIED 





UNCLASSIFIED 


makelprocs Package Body 


type dependency_array is array (positive range <>) of dependency_rec; 

type dependency_list_rec(dp -.POSITIVE) is record 
unit :unit_name; 

f_typ^ character; 

dependency_list :dependency_array(l. .dp); 

build_proc :xlarge_vstring; 

end record; 

type dependency_ptr is access dependency_list_rec; 

type dependency_ptr_array is array (POSITIVE range < >) 
of dependency_ptr; 

type make_struct_rec(num_deps :POSlTIVE) is record 

dependencies :dependency_ptr_array(l. ,num_deps); 

end record; 

type make_structure is access make_struct_rec; 


-Types necessary for keeping array of changes discovered 
- in the MAKE process 


type change_record is record 
unit 
Oype 

changes_discovered 

changejist 

end record; 


:unitjname; 
:CHARACTER; 
:Boolean := False; 
:large_vstring; 


type change_array_type is array (POSITIVE range <>) of change_record; 
type change_array_ptr is access change_array_type; 


-Type used to hold definitions of extensions used in make files 
type ext_array is array (‘a’..‘z’) of string(1..3); 


-Global variable declarations: 

-Global variables used to store changes that are discovered 
- by MAKE 


UNCLASSIFIED 




UNCLASSIFIED 


MAKEL procs Package Body 


46 


change_array :change_array_ptr; 

len_change_array :natural; 


-Variables used in parsing make files : 


line_buffer 

linejndex 

obj_buffer 

object_type 

make_struct 

name_buffer 

name_type 

word_delim 

extensions 


:large_vstring; 

:positive := 1; 

:unit_name; 

:CHARACTER; 

:make_structure; 

:unit_name; 

CHARACTER; 

CHARACTER; 

:ext_array; 


-procedure and function declarations: 

procedure UPPER_CASE(s. In out string) is 
begin 

for i in s'first..s'last loop 

if s(i) >= ‘a’ and then s(i) <= ‘z’ then 

s(i) := character'vaI(character'pos(s(i)) - 32); 

end if ; 
end loop; 

end; 

procedure MY_GET_UNE(fspec : in FILE_TYPE; item : out STRING; 
last: out natural) is 

-This procedure emulates the TEXT_IO procedure GET_LINE 
-It was necessary to write this because the MicroVaxII's 
-predefined GET_LINE acts differently than it should. 

-This procedure provides the appropriate results and is 
-compatible with the 8600's Ada. 

-This routine isn't completely fool-proof, but it does the job 

result : string (item'first..item'last) := (others => ‘ ’); 
count : natural := 0; 


begin 


while not end_of_line(fspec) loop -loop until end of line 
countcount + 1; 
get(fspec ,result(count)); 
end loop; 
skipjine(fspec); 
item := result; 

last := count; 

return; 


UNCLASSIFIED 






UNCLASSIFIED 


make_procs Package Body 


47 


end MY_GET_LINE; 


function VSTRING_NAME return vstring is 

-This function operates on the global variable N AME_BUFFER 
-for the BUILD_MAKE_STRUCT procedure. It allows unit names 
-(actually excludable change types in a make file specification)( 

-to be treated as vstrings for ”+” concatenation purposes 

result :vstring; 


begin 


-first, make sure name_buffer isn't empty, 
if name_buffer(l) = • ; then retum(0,(others => ‘ ’)); end if; 

-if it's not, find its length and put it in RESULT 
for i in l..unit_name_len loop 

if name_buffer(i) = ‘ ’ then 

result.str(l..i-l) := name_buffer(l..i-l); 

result.len := i-1; 

exit; 

end if; 
end loop; 
return result; 

end VSTR1NG_NAME; 


procedure GET_WORD(fspec :in FILE_TYPE) is 

-This is a custom word-oriented input routine for use 

-in BUILD _MAKE_STRUCT. DELIM contains a character table 

-used to differentiate between ASCII data characters 

-and delimiters in the input. The word read is placed 

-in the global variable NAME_BUFFER, and the delimiter 

-which terminates it is placed in the global variable 

- WORDJDELIM. If a special delimiter ( or 

-is encountered before a data character, input halts immediately 
-(This allows for the detection of these characters as( 

-separators without considering them to be data characters). 

-If a name is found which is delimited on the right by a 
the "extension” (character after the ”.”) is returned" 

-in the global variable NAME_TYPE. The only exception is 
-if the first character in a name is "/"-then ”/” is returned 

- as the NAME_TYPE. 


typeflag :Boolean := False; 

name_len : INTEGER := 0; 

C :CHARACTER; 

delim constant array (0..127) of boolean := 

(True, True, True, True, True, True, True, 


True, 


UNCLASSIFIED 



UNCLASSIFIED 


makelprocs Package Body 48 


True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

False, 


False, False, False, False, 
False, False, True, True, 
True, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, True, 
True, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, True, 


False, False, False, False, 

True, True, True, True, 

False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
True, True, True, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
True, True, True, True); 


begin 


:=c; 

:= True; 

-and get next char 


-if first legal char is ”/” 
-set NAMEJTYPE 


get(fspec,c); -get first char 

while delim(CHARACTER'POS(c)) loop -strip leading delim's 
if c = or c = or c = *=’ then 
word_delim := c; 
name_buffer := (others => ‘ ’); 
return; 
end if; 
get(fspec.c); 
end loop; 
if c = 7’ then 

name_type 
typeflag 
get(fspec,c); 
end if; 

for i in l..unit_namejen loop 
name_buffer(i) := c; 
if end_of_line(fspec) then 
name Jen := i; 

exit; 

end if; 

get(fspec,c); -otherwise, get next char, 

if delim(cHARACTER'POS(c)) then—if it's delim, then end of name 
namejen := i; 
word_delim := c; 

exit; 
end if; 
end loop; 

-once you've got the name, blank remainder of namejmffer 
name J>uffer(nameJen+l..unit_name Jen) := (others => ‘ ’); 
ifc = ‘.’then -if word delim'ed by 

get(fspec.c); -get NAME_TY?E 

namejype := c; 
typeflag := True; 

elsif not typeflag then -otherwise, reset NAME_TYPE, 


-unless they're 
- "special” 


-add to name until no more room 

-place in buffer 

-if EOL, then end of name 


UNCLASSIFIED 





UNCLASSIFIED 


makblprocs Package Body 


49 


name_type := ‘ 

end if; 
return; 

exception -if EOF encountered, just return blanks 

when end_error => 

name_buffer := (others => 4 ’); 
return; 

end GET_WORD; 


procedure GET(fspec :in FILE_TYPE; build_proc :in out xlarge_vstring) is 

-This is another custom input routine for BUILD_MAKE_STRUCT. 

-It is used if a construction procedure is specified in the 

-make file. It reads in the construction procedure for 

-storage in the make data structure (type xlarge_vstring 

-is only used to hold make construction procedures). 


c :character; 

delim constant array (0..127) of boolean := 

(True, True, True, True, True, True, True, True, 


True, 

False, True, 

True, 

True, 

True, 

False, True, 

True, 

True, True, 

True, 

True, 

True, 

True, True, 

True, 

True, True, 

True, 

True, 

True, 

True, True, 


False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, True, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 


False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, True); 


begin 


get(fspec,c); 

-strip leading delim's and spaces: 
while delim(CHARACTER'POS(c)) or else c = ‘ ’ loop 
get(fspec,c); 
end loop; 

-fill xlarge_vstring: 
for i in l..xlslen loop 

build_proc.str(i) := c; -insert char into build_proc 

if end_of_line(fspec) then -if EOL, insert a CR into build_proc 


UNCLASSIFIED 







UNCLASSIFIED 


MAKELPROCS Package Body 50 


c := ascii.cr; 
skipjine(fspec); 

else * 

get(fspec.c); 

end if; 

if delim(CHARACTER'POS(c)) then -if its a delim then 
build_proc.len : = i; -then end the builcLproc 

exit; 

end if; 1 

end loop; 

-blank out rest of build_proc and the name_buffer 
builcLproc.str(build_proc.len+l..xlslen) := (others => 4 ’); 
name_buffer := (others => 4 ’); 
return; 

( 

exception 

when end_error => -if EOF, just return 

return; 


end GET; 


procedure NEXT_WORD(source :in out large_vstring; 
wd_buffer :out vstring) is 

-This procedure splits a large_vstring into a vstring 
-containing the first 4 ’ delimited word in the input 
-large_vstring, and a large_vstring containing the remainder, 

-of the input. On return, SOURCE contains the remainder, 

-and WD_BUFFER contains the first word in SOURCE on entry. 

result :vstring; -temporary storage for wcLbuffer 

ptr :POsmvE; -pointer into SOURCE 


begin 


ptr := 2; -first character in SOURCE to look at 
-find the end of the first word 
while source.str(ptr) /*■= 4 ’ and ptr <= source.len loop 
ptr := ptr + 1; 

end loop; 

-set result equal to first word 
result.str(l..ptr - 1) := source.str(l..ptr - 1); 
result.len := ptr - 1; 

-set source equal to remainder 

source.str(l..source.len-ptr+1) := source.str(ptr..source.len); 
source.len := source.len - ptr + 1; 
wd_buffer := result; 

return; 

end NEXT.WORD; 


UNCLASSIFIED 



UNCLASSIFIED 


makelprocs Package Body 51 


function trans_build_proc( node : natural) return xlarge_vstring is 
-This function takes as input a node in the MAKE_STRUCT 
-and processes its construction procedure for output. 

-it searches the construction procedure for names of the 
-form { name & & alpha_character & delimiter }, where 

-name is a sequence of non-delimiting characters. If such 
-a sequence is found, it is replaced by its "translation” 

-in the output. This translation is produced by the following 
-rules: if the alpha extension is ‘a’, the version control: 

-graph is search for the current node for the unit 
-’’name”, held in the variable CURRENT_NAME. The file name 1 * 
-associated with this node is used to replace the string 
-representing it in the construction procedrure. If the 
-"extension” is any other letter, the list of defined extensions" 

-in the global array variable EXTENSIONS is consulted. If 
-the single charater extension is defined, it is used to replace 
-the single letter extension in the output. If no known 
-expansion for the sequence is found, it is passed unchanged 
-to the output. 


c 

result 

state 

current_name 

current_f_type 

name_ptr 

i 

temp 

filel 

dp_node 

current_ext 


CHARACTER; 
:xlarge_vstring; 
:boolean := False; 
:unit_name; 

: CHARACTER; 
:NATURAL; 

:natural := 1; 
:integer; 

:file_name; 

:NATURAL; 

:string(1..3) := “ ”; 


delim 


constant array (0..127) of boolean := 


(True, 

True, 

True, 

True, 

True, 

True, True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, True, 

True, 


False, False, False, False, 
False, False, True, True, 
True, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, True, 
True, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, True, 


False, False, False, False, 

True, True, True, True, 

False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
True, True, True, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
True, True, True, True); 


begin 


UNCLASSIFIED 





UNCLASSIFIED 


MAKELPROCS Package Body 52 


-I points into the source construction procedure 
-STATE is a boolean which is true iff the last character 
- tested was part of a name sequence 
while i<make_struct.dependencies(node).buil(L.proc.len loop 
-if not looking at a name 
if not state then 

-if its a delimiter, pass it on 
if delim(character'pos( 

make_struct .dependencies(node) .buildLproc. str(i))) then 
result.len := result.len +1; 
result.str(result.len) := 

make_struct.dependencies(node).build_proc.str(i); 
else -if its a name character, change STATE 
name_ptr := 1; 
current_name(name_ptr) := 

make_struct .dependencies(node) .builcLproc. str(i); 
state := True; 

end if; 

else -in the name STATE 

-if a delim is encounter in STATE: 
if delim(character'pos( 

make_struct.dependencies(node).build_proc.str(i))) then 
-first, change STATE:, 
state := False; 

-check for substitution conditions: 
if make_struct.dependencies(node).build_proc.str(i) = 
and then not delim(character'pos(make_struct. 
dependencies(node).build_proc.str(i+l))) and then 
delim(character'pos(make_struct. 
dependencies(node).build_proc.str(i+2))) then 
-blank out remainder of name 
current_name(name_ptr+l..unit_name_len) := 

(others => 4 ’); 

-get "extension” character 
current_f_type := 

make_struct.dependencies(node).build_proc.str(i+l); 
i:= i +1; 

-if "extension” is an ‘a’ 
if current JLtype * ‘a’ then 

find_current(current_name,filel,temp); 
if temp > 0 then -if node found 

-strip file name and use it instead 
for 1 in l..file_namejen loop 
if filel(l+l) - 4 ’ then 

result.str(result.len+l..result.len + 
1):* filel(l..l); 
result.len :- result.len + 1; 
exit; 
end if; 
end loop; 

else -if node not found, send name on 

result .str(result.len+1. .result .len + 

name_ptr) current_name(l..name_ptr); 


UNCLASSIFIED 





UNCLASSIFIED 


makelprocs Package Body 53 


result.len := result.len + name_ptr; 

result. str(result.len + 1) := V; 

result.str(result.len + 2) := current_f_type; 

result.len := result.len + 2; 

end if; 

else -if ’’extension” not ‘a’ 

-get three-letter expansion: 

-if (currentJLtype >= ‘a’) and 

- (currentJLtype <= ‘z’) then 

- current_f_type := CHARACTER'VAL(CHARACTER'POS( 

- currentJLtype) - 32); 

-end if; 

-current_ext := extensions(current_£jype); 

-if three-letter version is defined: 
if not delim(character'pos(current_ext(l))) then 
result.str(result.len+l..result.len + 

name_ptr) := current_name(l..name_ptr); 
result.len := result.len + name_ptr; 
result.str(result.len + 1) := 
result.str(result.len + 2..result.len + 4) := 
current_ext; 

result.len := result.len + 4; 
else -if three-letter version not defined, 

-just pass name on to output: 
result. str(result .len+1. .result .len + 

name_ptr) :=» current_name(l. .name_ptr); 

result.len := result.len + name_ptr; 

result. str(result. len + 1) := 

result.str(result.len + 2) := currentJLtype; 

result.len :» result.len + 2; 

end if; 
end if; 

else -if no substitution, just sendname on 

result.str(result.len + l..result.len+name_ptr) := 
current_name(l. .name_ptr); 
result.len := result.len + name_ptr + 1; 
result.str(result.len) := make_struct.dependencies( 
node) .build_proc .str(i); 

end if; 

else -another name char while in STATE 

-just add to the name: 
name_ptr := name_ptr + 1; 
current_name(name_ptr) := 

make_struc t .dependencies(node) .build_proc. str(i); 

end if; 
end if; 
i := i + 1; 
end loop; 
return result; 

end TRANS_BUILD_PROC; 


UNCLASSIFIED 







UNCLASSIFIED 


makelprocs Package Body 54 


procedure build_it ( i :in positive; current_der_node :in natural; 
current_version :in positive) is 
-This procedure is called by MAKE if a derived unit 
-needs to be constructed. The input variable I points 
-to the node of the unit in the MAKE_STRUCT, while current_version 
-holds the version_number the new derived unit should 
-have.. 


temp 

file2 

dp 

result 

build_proc 

cmd_line 

ada_compile 

adajink 

obj_extension 

exe_extension 


:INTEGER; 

:flle_name; 

:posittve; 

:der_node_ptr; 

:xlarge_vstring; 
la^string := empty; 

constant a_string := to_a(“arct.ada ”); 

constant a_string := to_a(“csh -c echo Id ”); 

:constant string := “.obj ”; 

constant string :=“.exe”; 


begin 


-first, DP=number of units the one to be constructed, 
-depends on: 

dp := make_struct.dependencies(i).dp; 

-create a new derived node for the newly constructed unit 
result:» new der_node(dp); 

-set up the child array of the newly allocated 
-derived node by repeating the following for each dependency: 
for j in l..dp loop 

-if the dependency is on a source file, 
if make_struct .dependencies(i) .dependency_list(j). 
f_type = ‘a’ then 

-find file name of current file for that unit 
find_current(make_struct .dependencies(i). 
dependency_list(j).unit,file2, 
temp); 

-set this element of derived node's child array 
result.source_array(j).node := temp; 
result.source_array(j).derived := False; 
else -dependency is on another derived node 

-find most recent version of the derived node 
- it depends on, and set elements of child array 
for m in reverse l..der_graph.num_el loop 
if der_graph.dergraph_ptr(m).unit = 
make_struct .dependencies(i). 
dependency_list(j).unit then 

result.source_array(j).node :- m; 
result.source_array(j).derived :=True; 
exit; 
end if; 
end loop; 
end if; 
end loop; 


UNCLASSIFIED 





UNCLASSIFIED 


MAKE-PROCS Package Body 55 


-now put the other relevant info into the new derived node 
result.unit := make_struct.dependencies(i).unit; 
result.£_type := make_struct.dependencies(i).fjype; 
result.version := current_version; 

-enlarge derived node array 

ADD_TO_DER_GRAPH; 

-insert the newly created derived node 
der_graph.dergraph_ptr(der_graph.nuxn_el) := result; 

-if the derived node is not a passthru node: 
if make_struct.dependencies(i).f_type /= ‘ ’ then 

-if the derived unit doesn't have a construction procedure 
ifmake_struct.dependencies(i).build_proc.len = Othen 
-if it's an EXEC file (type=‘e’), then link all 
-of its dependents of type ‘o’ together 
if make_struct.dependencies(i).f_type = ‘e’ then 
-for a.ld interface, 

-build cmdjine and use unix_prcs. spawn 
cmdjine := adajink; 
for k in l..dp loop 

if make_struct .dependencies(i) .dependencyJist(k). 
f_type = ‘o’ then 
cmdjine := cmcLline & 

trim(make_struct.dependencies(i). 
dependencyJist(k).unit) & obj_extension; 

end if; 
end loop; 

cmdjine := cmdjine & u -o ” & 

trim(make_struct.dependencies(i).unit) & exe_extension; 
putJine(cmdJine. s); 
if unix_prcs.spawn(cmdjine) /= 0 then 
raise MAKE_F AILED; 
end if; 

else -for any other type, send its first dependent 

-through the Ada compiler: 
cmdjine := ada w compile; 
fork ini. .dp loop 

if make_struct.dependencies(i).dependencyJist(k). 
Ltype /= * ’ then 

find_current(make_struct.dependencies(i). 

dependencyJist(k).unit,file2, temp); 
cmdjine := cmdjine & trim(file2); 

-putjine (trim(file2)); 

-put(”Unit:’”);( 

-put(trim(make_struct .dependencies(i). ( 

- dependencyJist(k). unit)); 

-putJineC””); ( 

-put(”File:’”);( 

-put(trim(file2));( 

-puUine("”’);( 

-put(”Node:”);( 

-put(temp);( 

-putjine(””);( 

-put(”Total Nodes:”);( 


UNCLASSinED 



UNCLASSIFIED 


makelprocs Package Body 


-put(ver_graph.num_el);( 

-put_line(””);( 

exit; 
end if; 
end loop; 

put _line(cm(Lline. s); 
if unix_prcs.spawn(cmd_Jine) /= 0 then 
raise MAKE_F AILED; 
end if; 

end if; 

else -if it has a construction procedure, translate it: 
-put_line(”Beginning TRAN S_BUILD_PROC 
-build_proc := trans_build_proc(i); 

-putjine(”... TRANS_BUILD_PROC completed successfully.”)^ 
put_line(build_proc .str(l. .buildLproc .len)); 
if unix_prcs.spawn(to_a(build_proc.str(l..build_proc.len))) /= 

0 then 

raise MAKEJFAILED; 

end if; 
end if; 
end if; 

end BUILD_IT; 


procedure MAKE is 

-This procedure is driven by the MAKE_STRUCT data 
-structure. Given that structure, it determines. 

-which of the MAKE_STRUCT nodes need to be constructed. 


word 

:vstring; 

builcLflag 

■.Boolean; 

changejlst 

:large_vstring; 

exclude_list 

:large_vstring; 

k 

;posmvE; 

totaLchanges 

:large_vstring; 

current_der_node 

:natural; 

current_version 

:natural; 

current_source 

:natural; 

current_derived 

: Boolean; 

file2 

:file_name; 

archive_file 

:file_name; 

temp 

integer; 

tempstr 

:string(1..6); 

ret_code 

:integer := 0; 

function “&”(1 : in a_string; r : in file_name) return file_name is 


result: file_name; 


begin 

if 1 /= empty and then 1 /= null and then l.len /= 0 then 
result(l..l.len) := l.s; 
result (l.len + 1) := 7’; 


UNCLASSIFIED 







UNCLASSIFIED 


makelprocs Package Body 51 


result(l.len + 2..result'last) := r(l..r'last - Men - 1); 
return result; 


return r; 


end if; 

end 


begin 

-repeat this process for each node in MAKE_STRUCT 
for i in l..make_struct.num_deps loop 

build__flag := False; -reset construction flag 
total_.changes.len := 0; 
current_der_nodc := 0; 
current_version0; 

-search for the previous version of this derived unit 
if der_graph.num_el > 0 then 

for j in reverse l..der_graph.nura_el loop 
ifder_graph.dergraph_ptr(j).unit = 

make_struct.dependencies(i).unit and then 
der_graph.dergraph_ptr(j).f_type = 
make_struct. dependencies (i) .f_type then 
current_der_node := j; 

current_version := der_graph.dergraph_ptr(j). version; 
exit; 

end if; 
endloop; 
end if; 

-If there is no previous version, then set the const, flag 
if current_der_node = 0 then 
builcLflag := True; 

end if ; 

-If const.flag still false 

-(or it's a passthru node (signifled by type=‘ ’))( 
if buildjflag ** False or else 
make_struct.dependencies(i).f_type = ‘ ’ then 
-check each of its dependencies for changes: 
for j in l..make_struct.dependencies(i).dp loop 

-first, find the corresponding element in the, 

-the change discovery array 
k := 1; 

while (change_array(k).unit /= make_struct.dependencies(i). 
dependency jist(j).unit) or else 

(change_array(k).f_type /= make_s!ruct.dependencies(i). 
dependencyJist(j).Ltype) loop 
k k + 1; 

end loop; 

-If the changes haven't been discovered yet: 
if not change_array(k).changes_discovered then 
current_source := 0; 

-if previous version found in the derived graph 
if current_der_node > 0 then 

-then search the previous version's dependents 


UNCLASSIFIED 




UNCLASSIFIED 


makelprocs Package Body 58 


-to find the one corresponding to this dependency 
for 1 in l..der_graph.dergraph_ptr(current_der_node).s 

loop 

if der_graph.dergraph_ptr( 

current_der_node). source_array (1) .derived then 
if der_graph. dergraph_ptr (der_graph .dergraph_ptr( 
current_der_node). source_array(l) .node 
).unit = change_array(k).unit and then 
der_graph .dergraph_ptr(der_graph .dergraph_ptr( 
current_der_node) .source_array(l) .node 
).f_type = change_array(k).£_type then 

current_source := der_graph.dergraph_ptr( 
current_der_node). source_array(l) .node; 
current_derived := True; 
exit; 

end if; 

else 

if ver_graph.vergraph_ptr(der_graph.dergraph_ptr( 
current_der_node) .source_array(l) .node 
).unit = change_array(k).unit then 

current_source := der_graph.dergraph_ptr( 
current_der_node) .source_array(l) .node; 
current_dcrived := False; 
exit; 

end if; 
end if; 
end loop; 
end if; 

-if previous dependency not found, 
if current_source = 0 then 

-if there was a previous derived node 
if current_der_node > 0 then 

-the changes must be stored 
for 1 in l..len_change_array loop 
if change_array(l).unit = 
der_graph. dergr aph_ptr ( 
current_der_node).unit then 

change_lst := change_array(l).change_list; 

if 1 >= k then raise MAKE_FILE_SYNTAX; end if; 

exit; 

end if; 
end loop; 

else -there is no previous dependency 

changeJst.str(l..7) := “GENERAL”; 
changeJst.len := 7; 

end if; 

else -previous dependency found 

-then, if it was a derived dependency, 
if current_derived then 

-see if there is a more current version 
-of the node depended on 
changejst.len := 0; 
for m in reverse current_source+l.. 


UNCLASSIFIED 






UNCLASSIFIED 


makelprocs Package Body 59 


der_graph.num_el loop 

-if there is a more recent node, 

-then signal "general” so unit 
-will be constructed 
if der_graph.dergraph_ptr(m).unit = 

der_graph.dergraph_ptr(current_source).unit 
and then der_graph.dergraph_ptr(m).f_type - 
der_graph .dergraph_ptr(current_source) .f_type 
then 

changejst.str(1..7) := “GENERAL”; 

change Jst.len := 7; 

exit; 

end if; 
end loop; 

-if control makes it this far, then there is no 
-new version, and the old derived node will 
-suffice 

else -if dependency is on a source file 

-compare the current version of the 
-given source file with the one the 
-previous derived node depended on: 
find_current(change_array(k).unit, 
file2,temp); 

changejst := cbanges(file2, 

arct_globals.source_archive & 

ver_grapb .vergraph_ptr(current_source) .fname); 

end if; 
end if; 

-store changes in change array for later use 
change_array(k).change_list := changejst; 
change_array(k).changes_discovered := True; 
else changejst := change_array(k).change_list; 

end if; 

excludejfist :=* make_struct.dependencies(i). 
dependency_list(j) .exclude Jist; 

-subtract each word in exclusion list from the change list 
while excludejist.len > 0 loop 

next_word(exclude_list, word); 
change_lst := change_lst - word; 

end loop; 

-accumulate total changes 
totaLchanges := totaLchanges + change Jst; 

-if there are any changes, then set the const, flag 
if change Jst.len > Othen 

buikLflag := True; 

If make_struct.dependencies(i).f_type /= ‘ ’ then 
exit; 
end if; 

end if; 
end loop; 
end if; 

-if its a passthru node 

if make_struct.dependencies(i).f_type = ‘ ’ then 


UNCLASSIFIED 



UNCLASSIFIED 


makelprocs Package Body 60 


-find the corresponding passthru node slot in 
-the change array and save the total changes there 
for kk in l..len_change_array loop 

if change_array(kk).unit = make_struct.dependencies(i).unit 
and then change_array(kk).f_type = 
make_struct .dependencies(i) .l_type then 

change_array(kk).change_list := total_changes; 
change_array(kk).changes_discovered := True; 
exit; 

end if; 
end loop; 

end if; 

-construct unit, if necessary 
if build_flag then 

-put_line(”Beginning BUILD_IT...”);( 

build. it(i, current.derjod*, currcnt_version + 1); 

-putjine(”... BUILDJT successfully completed.”);( 

end if; 
end loop ; 

end MAKE; 


procedure GET_EXTENSlONS(buf :in unit_name; 

current_make_file :in FILE_TYPE) is 
-This proc is called if a make file starts of with some 
-extension definitions. It saves all of the extension 
-definitions in the global array EXTENSIONS for later use in 
-translating construction procedures. 

temp_name_buf :unit_name := buf; 


begin 


-put _line(”Begin GET_EXTENSIONS...”);( 
if temp_name_buf(l) «‘ ’ then 

temp_name_buf := name_buffer; 
get_word(current_make_file); 

end if; 

if name_buffer(l) = 1 * then 

if word_delim = *=’ then 

get_word(current_make_file); 
else raise MAKE_FILE_SYNTAX; 

end if; 
end if; 
loop 

-put(”current character:’”);( 

-put(temp_name_buf(l));( 

-put_line(”’”);( 

if temp_name_buf(l) >= ‘a’ and temp_name_buf(l) <= ‘z’ then 
-put(”change to ASCII value:”);( 
-put(CHARACTER'POS(temp_name_buf(l)) - 32);( 


UNCLASSIFIED 










UNCLASSIFIED 


makeuprocs Package Body 61 


-put_line(””);( 

temp_name_buf(l) := character'val(character'pos( 
temp_name_buf(l)) - 32); 

end if; 

extensions(temp_name_buf(l)) := name_buffer(1..3); 
if worcLdelim = then exit; end if; 
get_word(current_make_file); 
tempjiame_buf := name_buffer; 
if word_delim = orword_delim = then 
raise MAKE_FILE_SYNTAX; 
end if; 

get_word(current_make_file); 
if word_delim = *=’ and name_buffer(l) = ‘ ’ then 
get_word(current_make_file); 

end if; 
end loop; 

get_word(current_make_file); 
if word_delim /= ‘ then 

temp_name_buf := name_buffer; 
get_word(current_make,_file); 
if worcLdelim /= *:* then 

raise VtAKE_FILE_SYNTAX; 
else name_buffer := temp_name_buf; 
end if; 

end if; 
return; 

end GET_EXTENSIONS; 


function BUlLD_MAKE_STRUCT(make_file :in make_file_name) 
return Boolean is 

-This procedure takes a file name as input, and opens the file, 
-parsing it to create MAKE_STRUCT. 


temp_name_buf 

temp_dep 

old_temp_dep 

temp_ex_list 

current_make_file 

j 

temp_make_struct 

num_deps 

temp_count 


:unit_name; 

:dependency_ptr; 

:dependency_ptr; 

:large_vstring; 

:FILE_TYPE; 

positive; 
:make_structure; 
:natural := 0; 
:count; 


begin 


len_change_array := 0; 

open(current_make_file,lN_FiLE,trim(make_file)); 
make_struct new make_struct_rec(l); 
while not end_of_file(current_make_file) loop 

-save old make_struct in temporary variable 


UNCLASSIFIED 





UNCLASSIFIED 


MAKE.PROCS Package Body 


-put_line(”Beginning B_M_S loop..”);( 
temp_make_struct := make_struct; 
num_deps := num_deps + 1; 

—allocate new make_struct 
make_struct := newmake_struct_rec(num_deps); 

-copy old make_struct into new 
for i in l..num_deps-l loop 

make_struct.dependencies(i) := 

temp_make_struct.dependencies(i); 
end loop; 

—get the name of the next derived unit to ’’make" 
get_word(current_make_file); 
temp_name_buf := (others => ‘ ’); 

-make sure it is a ’’make” clause 
if word_delim /= then 

-if its an extension def, call get_extensions 
—put_line(”Testing for extensions...”); ( 
if worcLdelim = *=’ then 

get_extensions(temp_name_buf,current_make_file); 

else 

temp_name_buf := name_buffer; 
get_word(current_make_file); 
if word_delim /= *:’ then 

get_extensions(temp_name_buf,current_make_file); 
else name_buffer := temp_name_buf; 

end if; 
end if; 
end if; 

obj_buffer := name_buffer; 
object_type := name_type; 
get_word(current_make_file); 
if name_buffer(l) = 4 ’ then 

raise MAKEJFILE_SYNTAX; 
end if; 

j:=l; 

loop 

old_temp_dep := temp_dep; 

temp_dep := new dependency_list_rec(j); 

if j > 1 then 

terap_dep.dependency_list(l..j-l) := 
old_temp_dep.dependency Jist; 

end if; 

temp_dep.dependency_list(j).unit := name_buffer; 
temp_dep.dependency_list(j).f_type := name_type; 
temp_exjist.len := 0; 

if end_of_file(current_make_file) then exit; end if; 
ifword_delim = *;’ or else word_delim = then exit; end if; 
get_word(current_make_file); 
if name_buffer(l) - 4 ’ then 
exit; 
end if; 

while name_type = 7’ looi 

temp_ex_list := temp_jx_list + vstring_name; 


UNCLASSIFIED 







UNCLASSIFIED 


makelprocs Package Body 


If end_o£_file(current_make_file) then exit; end if; 
if worcLdelim = *;’ or else word_delim = then 
exit; 
end if; 

get_word(current_make_file); 
if name_buffer(l) = 4 ’ then 
exit; 
end if; 
end loop; 

temp_exjist.str(temp_exjist.len + L.lslcn) := 

(others => 4 ’); 

upper_case(temp_exjist.str(l..temp_exjist.len)); 
temp_dep.dependencyjist(j).exclude Jist := temp_ex_list; 
if word_delim = or else word_delim = 4 :' then 

if name_type /= 4 ’ or else namc_buffer(l) = 4 ’ then 
exit; 
end if; 
end if; 

j ••=} + 1; 

end loop; 

lcn_change_array := len_change_array + j; 
tcmp_dep.unit := obj_buffer; 
temp_dep.f_type := object_type; 
if word_delim = 4 :’ then 

get(current_make_file,temp_dep.build_proc); 

end if; 

make_struct.dependencies(num_deps) := temp_dcp; 

end loop; 

change_array new change_array_type(l..len_change_array); 

j =-1; 

for i in l..make_struct.num_dcps loop 

for k in l..make_struct.dependencies(i).dp loop 

change_array(j).changes_discovered := False; 
change_array(j).unit := 

make_struct.dependencies(i).dependencyJist(k).unit; 
change_array(j).f_type := 

make_struct.dependencies(i).dependencyJist(k).ILtype; 
change_array(j).changeJistden :» 0; 

j + 

end loop; 
end loop; 

close(current_make_fde); 
return True; 

exception -if there is a syntax error in the make file, 

-issue appropriate diagnostics 

when MAKE_FILF-_SYNTAX => 

temp_count := linc(current_make_filc); 
count Jo.put(tcmp_name_buf(l ..3),tcmp_count); 
put(“Syntax Error in make file near line ”); 
put(temp_namc_buf(1..3)&“, column ”); 
temp_count := col(current_makeJilc); 


UNCLASSIFIED 





UNCLASSIFIED 


MAKELPROCS Package Body 64 


countJo.put(temp_name_buf(1..3),temp_count); 
put _line(temp_name_buf(l. .3)&“."); 
return False; 

end BUILD_MAKE_STRUCT; 


-initialization for package GRAPH_MANAGER: 

begin 


-clear extension definitions 
for i in ‘a’..‘z’ loop 

extensions(i) := “ 

end loop; 

-add predeifined extensions: 
extensions(‘o’) :=“obj”; 

extensions(‘E’) :=“exe”; 

end make_procs; 


MAKE^UTIL Package Specification (niake_util.a); 

with MY_STRINGS; 
use MY_STRINGS; 


package MAKE_UTIL is 

-This package contains one function, CHANGES, which compares 
-two Ada source files to detect changes. It returns the 
-changes in a large_vstring. 

function CHANGES(filel,file2 :in file_name) return LARGE_VSTRING; 

procedure GET_NEXT_WORD(line :in STRING; index :in out NATURAL; 
word :in out STRING); 


end MAKE_UTIL; 

MAKE_UTIL Package Body ('make_util.b.a): 

with FILE_UTIL,TEXT_IO,MY_STRINGS; 
use FILE_UTIL,TEXT_IO,MY_STRINGS; 


UNCLASSIFIED 









UNCLASSIFIED 


makelutil Package Body 


65 


package body MAKE_UTIL is 

-global variables used in this package: 

-the buffers are used to hold input characters from the 
-two source files being scanned for changes; 

-QUOTE is a boolean flag that signals whether or not the current 
-character position in the input file is inside quotes or not. 

buffer 1, buffer2 :buffer; 

quote :Boolean; 


procedure GETC(buff :in out buffer; fspec :in FILE_TYPE) is 

-This is the basic character input function used for scanning 
-a single input file. It places the character it reads 
-in the specified buffer structure, after changing to 
-upper case if necessary. This is used primarily by 
-CONTSCAN, when the two files are found to differ and, 
-must be scanned separately until the next change_type 
-is discovered. 

C :CHARACTER; 


begin 


get(fspec,c); 

if c=‘”’ then quote := not quote; end if; 
if not quote and then c >= ‘a’ and then c O ‘z’ then 
c := character'val(character'pos(c) - 32); 

end if; 

buff.str(buff.bpos) := c; 
buff.bpos := buff.bpos mod slen + 1; 

return; 

end getc ; 


procedure coMPC(fspecl,fspec2 :in FILE_TYPE; test :out boolean) is 
-This procedure is the character level input routine used 
-by CHANGES- it inputs a character from 2 separate files, 
-changing to upper rase if necessary, and compares them. 

-it returns the value of this comparison in TEST. 

cl,c2 : character; 

cl_white : boolean := false; 

c2_white : boolean := false; 


begin 


-get char from first file 

while end_of_line(fspecl) and not end_of_file(fspecl) loop 
skip_line(fspecl); 

end loop; 


UNCLASSIFIED 




UNCLASSIFIED 


MAKELUTiL Package Body 


66 


if not end_of_file(fspecl) then 
get(fspecl,cl); 

if cl = ‘ ’ or cl = ASCII.HT then 
cl_white := true, 
bufferl.str(bufferl.bpos) := ‘ 
bufferl.bpos := bufferl.bpos mod slen + 1; 
while (not end_of_file(fspecl)) and then 
(not end_of_line(fspecl)) and then 
(cl = ‘ ’ or cl = ascii.ht) loop 
get(fspecl,cl); 
end loop; 

if cl = ascii.ht then cl := ‘ end if; 
end if; 

else 

cl 

end if; 

-change to UC if not in quotes 
if not quote and then cl >= ‘a’ and then cl <= ‘z’ then 
cl := character'val(character'pos(c1) - 32); 

end if; 

—get char from second file 

while end_of_line(fspec2) and not end_of_file(fspec2) loop 
skip_Jine(fspec2); 

end loop; 

if not end_of_file(fspec2) then 
get(fspec2,c2); 

if c2 = ‘ ’ or c2 = ASCII.HT then 
c2_white := true; 
buffer2.str(buffer2.bpos) ‘ 
buffer2.bpos := buffer2.bpos mod slen + 1; 
while (not end_of_file(fspec2)) and then 
(c2 - ‘ ’ or c2 = ascii.ht) loop 
get(fspec2,c2); 
end loop; 

if c2 = ascii.ht then c2 := ‘ ’; end if; 

end if; 

else 

c2 := ‘ ’; 

end if; 

if not quote and then c2 >= ‘a’ and then c2 <= ‘z’ then 

c2 := character'val(character'pos(c2) - 32); 

end if; 

-update both global buffers 
bufferl.str(bufferl.bpos)cl; 
bufferl.bpos := bufferl.bpos mod slen + 1; 
buffer2.str(buffer2.bpos)c2; 
buffer2.bpos := buffer2.bpos mod slen + 1; 

-if EOF on one file, but not the other, then 
- signal difference between files 
if end_of_file(fspecl) xor end_of_file(fspec2) then 
test := TRUE; 

else 

if cl_white xor c2_white then 


*i 


0 


UNCLASSIFIED 






UNCLASSIFIED 


makelutil Package Body 


test := true; 

else 

test := (cl /= c2); 

end if; 

end if; 

-toggle quote flag if necessary, 
if cl = then quote := not quote; end if; 
return; 

end compc; 


procedure CONTSCAN(mainbuf :in out buffer; tstring :in out target; 
fspec :in FILE_TYPE) is 

-This procedure is used to continue scanning a single file once 
-the two files have found to differ. It scans until the string 
-represented by tstring is found. This allows the change 
-discovery algorithm to "resynchronize" the scan at every 
- "PRAGMA CHANGEJTYPE”: if a difference is found, CONTSCAN 
-is called for each file separately, advancing each file's pointer 
-to the next occurrance of "PRAGMA CHANGEJTYPE”. 

matchcount :NATURAL :=0; 


begin 


outer: loop 

-while input isn't in a quoted string, scan for target string 
-using the GETC above (not TEXT_IO.GETC) 

while not quote loop 

if mainbuf.str((mainbuf.windowpos + tstring.index - 1) 
mod slen + 1) = tstring.str(tstring.index) 

then 

matchcount := matchcount + 1; 

tstring.index := tstring.index mod tstring.len + 1; 

else 

matchcount := 0; 

mainbuf.windowpos := mainbuf.windowpos mod slen + 1; 

end if; 

if matchcount = tstring len then 
return; 
end if; 

if (mainbuf.windowpos +tstring.index - 1) mod slen + 1 = 
mainbuf.bpos then 

while not end_of_file(fspec) and end_of_line(fspec) loop 
skip_line(fspec); 

end loop; 

if end_of_file(fspec) then return; end if; 
getc(mainbuf,fspec); 
if end_of_file(fspec) then return; end If; 
end if; 
end loop; 


UNCLASSIFIED 




UNCLASSIFIED 


MAKELUTIL Package Body 


-now that input is inside a quoted string, 

-discontinue scan until end of quoted string 
while quote loop 

getc(mainbuf ,fspec); 

if end_of_file(fspec) then quote := FALSE; return; end if; 
end loop; 

-reset scanning params. 
mainbuf.windowpos := mainbuf.bpos; 
tstring.index := 1; 

-loop until target is found. 

end loop outer; 

end CONTSCAN; 


function COMPSCAN(tstr :in vstring; fspecl, fspec2 :in FILE_TYPE) 
return boolean is 

-This function accepts as input a vstring to search for, 

-and scans the two input files simultaneously for it. 

-If the files are identical (with the exception of new Jines 
-and tabs), it returns true when the string is found 
-(or if both files terminate simultaneously)^ 

-If any character differs between the two files, the procedure 
-calls CONTSCAN on each file separately to advance the 
-appropriate file pointers to the target string, and then 
-returns false. If either file terminates while data 
-remains in the other, flase is returned. 


tstring 

matchcount 

test 

tempquote 


: target; 

:natural :*=0; 

:boolean; 

:boolean; 


begin 


-create a ’’target” out of input vstring 
tstring.str := tstr.str; 

tstring.len := tstr.len; 

-test first characters of each file 
compc(fspecl ,fspec2 ,test); 
if test then 

tempquote := quote; 
contscan(bufferl, tstring,fspec 1); 
quote :=» tempquote; 
contscan(buffer2,tstring,fspec2); 
return FALSE; 
end If; 

-if EOF in either file, then both ended simultaneously 
-(since COMPC picks up separate EOF's in TEST).( 


UNCLASSIFIED 






UNCLASSIFIED 


MAKELUTIL Package Body 


if end_of_file(fspecl) then return TRUE; end if; 
outer: loop 


-while not in a quoted string, scan simultaneoulsy for 
-target string 
while not quote loop 

if bufferl.str((bufferl.windowpos + tstring.index - 1) 
mod slen + 1) = tstring.str(tstring.index) 

then 

matchcount := matchcount + 1; 

tstring.index := tstring.index mod tstring.len + 1; 

else 


matchcount := 0; 
bufferl .windowpos 
buffer2. windowpos 

end if; 

if matchcount = tstring.len then 
bufferl. windowpos 
buffer2 .windowpos 
return TRUE; 


:= bufferl.windowpos mod slen + 1; 
:= bufferl. windowpos; 


:= bufferl.bpos - 1; 

:= bufferl .windowpos; 


end if; 

if (bufferl.windowpos +tstring.index - 1) mod slen + 1 = 
bufferl.bpos then 

compc(fspecl,fspec2,test); 
if test then 

tempquote := quote; 
contscan(bufferl ,tstring,fspecl); 
quote := tempquote; 
contscan(buffer2, tstring,fspec2); 
return FALSE; 
end if; 

if end_of_file(fspecl) then return TRUE; end if; 

end if; 
end loop; 


-once in quoted string, compare character by character 
-without scanning 
while quote loop 

compc(fspec 1 ,fspec2,test); 
if test then 

tempquote := quote; 
contscan(bufferl,tstring,fspecl); 
quote := tempquote; 
contscan(buffer2,tstring,fspec2); 
return false; 

end if; 

if end_of_file(fspecl) then return TRUE; end if; 
euu loop, 


-reset scanning pointers before resuming scanning 
bufferl .windowpos : = bufferl .bpos; 

buffer2.windowpos := bufferl. windowpos; 

tstring.index := 1; 


UNCLASSIFIED 



UNCLASSIFIED 


MAKELUTIL Package Body 


end loop outer; 
end compscan; 


function GET_CHANGE_TYPE(fspec 1 , f spec2 :in FILE_TYPE) return VSTRING is 
-This function is calle once botth files are at a 
-"PRAGMA CHANGE_TYPE”. It extracts the change type from" 
-the pragma, making sure it is the same in both files, 

-returning all blanks if anything is wrong with the 
-syntax or layout. 

cl,c2 character; 

result : vstring; 


begin 


-skip to next quote in first file 
get(fspecl,cl); 
while cl /= loop 
get(fspecl,cl); 

end loop; 

-skipp to next quote in second file 
get(fspec2,c2); 

while c2 /= loop 
get(fspec2,c2); 

end loop; 

-get first change type chars in each file 

get(fspecl,cl); 

get(fspec2,c2); 

-keep going 'til closing quote 
while cl /= loop 
If cl /= c2 then 

retum(0,(others => ‘ ’)), 
end If; 

if cl >= ‘a’ and then cl <= ‘z’ then 

cl := CHARACTER' val(character'pos(c1) - 32); 

end if; 

result.len := result.len + 1; 
result.str(result.len) := cl; 
get(fspecl,cl); 
get(fspec2,c2); 

end loop; 

-if one ends before the other: 

If cl /= c2 then 

return(0, (others =>*’)); 
end if; 

-skip to next opening quote in filel 


UNCLASSIFIED 






UNCLASSIFIED 


make_ util Package Body 71 


get(fspecl,cl); 
while cl /= loop 

• get(fspecl,cl); 

end loop; 

-skip to next opening quote in file2 

get(fspec2,c2); 

while c2 /= loop 

• get(fspec2,c2); 

end loop; 

-compare second "validation” strings in both files 

get(fspecl,cl); 

get(fspec2,c2); 

• while cl /= loop 

if cl /= c2 then 

retum(0, (others =>*’)); 

end if; 

get(fspecl,cl); 

get(fspec2,c2); 

® end loop; 

if cl /= c2 then 

retum(0,(others => ‘ ’)); 
end if; 

return result; 

• end GET_CHANGE_TYPE; 


function CHANGES(filel,file2 :in file_name) return large_vstring is 
-This is the function that coordinates the scanning and 
-reading of change_type pragmas to extract change types. 
-It returns a large_vstring which contains a concatenation 
-of all change_types discovered between the two files used 
-as arguments. 

change_type 
search_string 
result 
s_string 
fspecl,fspec2 


:VSTR1NG; 

:vstring; 

: large, vstring; 
: target; 
:FILE_type; 


begin 

open(fspecl,iN_FlLE,trim(filel)); 

open(fspec2,lN_FlLE,trim(file2)); 

search_string.str(1..18) := “PRAGMA CH ANGE.TYPE”; 
search_string.len := 18; 
s.string.str := search_string.str; 

s.string.len := search_string.len; 

-scan for first change.type pragma: 

-if files differ before first pragma, 


UNCLASSIHED 








UNCLASSIFIED 


makejjtil Package Body 


72 


-then return "GENERAL” 
if not coMPSCAN(search_string,fspecl,fspec2) then 

result.str(l..7) := “GENERAL”; ♦ 

result.len := 7; 
return result; 
end if; 


-if files end before first pragma, return null string 
if end_of_file(fspecl) and then end_of_file(fspec2) then 
result.len := 0; 
return result; 

end if; 


loop 

-get change_type from pragma 

change_type := get_change_type(fspecl,fspec2); 

if change_type.len = 0 then 

result.str(l..7) := “GENERAL’ ; 
result.len := 7; 
return result; 

end if; 


-compare 'til next pragma 

if not COMPSCAN(search_string,fspecl,fspec2) then 
result := result + change_type; 

end if; 


-if files both end before next pragma, then done 
if end_of_file(fspecl) and then end_of_file(fspec2) then 
return result; 
end if; 

-if only one ends, then scan 
-other for a change_type pragma. 

-if found, then signal "GENERAL” 
if end_of_file(fspecl) then 

C0NTSCAN(buffer2, s_string, f spec2); 
if not end_of_file(fspec2) then 

result.str(l..7) := “GENERAL”; 
result.len := 7; 
return result; 
else return result; 

end if; 

elsif end_of_file(fspec2) then 

contsc AN(buffer 1, s_string ,f spec 1); 
if not end_of_file(fspecl) then 

result.str(l..7) := “GENERAL”; 
result.len := 7; 
return result; 
else return result; 

end if; 
end if; 
end loop; 


UNCLASSIFIED 






UNCLASSIFIED 


MAKELUTIL Package Body 


close(fspecl); 

close(fspec2); 

end CHANGES; 


procedure GET_NEXT_WORD(line :in STRING; index :in out NATURAL; 
word :in out STRING) is 

-This procedure takes in a buffer and a pointer into 
-that buffer. Beginning with the character pointed to by 
-the pointer, it parses a word, returning the word and the 
-new pointer value. If no legal word is left, it returns 
-a blank ’’word” and a pointer value equal to the length of the 
-input buffer + 1. The only characters considered to be delimiters 
-are * ’, 7’, *=’, and *,’. 

word_index :NATURAL := 0; 


begin 


-make sure there is parse-able material in buffer 
if index > line'LAST then 

word := (word'FlRST..word'LAST => ‘ *); 

return; 
end if; 

-strip leading delimiters 
while line(index) = ‘ ’ or else 

line(index) =7’ or else 

line(index) = ‘=’ or else 

line(index) = V loop 

index := index + 1; 
if index > line'last then 

word := (word'FlRST..word'LAST =>*’); 
return; 
end if; 
end loop; 

-scan for final delimiter while moving LINE to WORD 
- character by character 
for i in index..line'last loop 
if line(i) 
line(i) 
line(i) 


‘ ’or else 
7’ or else 
=’ or else 


line(i) *=‘,’then 

word(word_index+l..word'LAST) := (others => ‘ ’); 
index := i + 1; 

return; 


end if; 

word_index := word_index + 1; 

-change to upper case if necessary: 
if line(i) >= ‘a’ and line(i) <= ‘z’ then 

word(wordjndex) := character'val(character'pos( 
line(i)) - 32); 

else word(word_index) := line(i); 


UNCLASSIFIED 





UNCLASSIFIED 


MAKE-UTIL Package Body 


74 


end if; 
end loop; 

-if parsed to the end of buffer, return 
-buffer len + 1 in pointer 
index := line'last + 1; 

return; 

end get_next_word; 


end MAKE_UTIL; 


UNCLASSIFIED 







UNCLASSIFIED 


75 


B.3. Main Programs 


This table is provided to summarize the functions performed by the executable programs, as well 
as describe available options: 


Description of Main Programs 

Mill^fTfTCTSiBSa 1 

Invocation Syntax 

Option Description 

ARCT_ADA 

arct.ada [-v] filename 

This program is a shell wrapped around the 
Verdix Ada compiler. Since no interface to 
the compiler could be worked out, this is 
more like a stub. 

-v Turns on verbose mode. 

ARCT_C REATE 

arct.create [-b] unit 

Creates a node in the source archive graph 
for the unit—requires file “unit.O.a” to 
exist, and sets this file to be the current file 
for the unit. 

-b Same as “arct.create unit; arct.create 

unit_b”. Can be used when specification 
and body of a package are to be considered 
separate compilation units. 

ARCTJDESCEND 

arct.descend unit 

Finds the current node in the source archive 
graph for the unit, and creates a new child 
node (giving it a new file name which is the 
same as the current file name but with the 
version field incremented). It then makes 
this new child the current node for the unit. 

It does not actually create a new file, it just 
manipulates the source archive graph. 

ARCTJDIR 

arct.dir [-d|-v] [path] 

Lists all units in the specified arct library. 
The -d and -v options are mutually 
exclusive. 

-d Causes the entire contents of the derived 
unit graph to be listed instead. 

-v Causes the entire source archive graph to be 

listed instead. 

AJRCT_ED1T 

arct.edit unit 

Finds the current file for the unit, descends 
it (like ARCT_DESCEND, but ARCT_EDIT actu¬ 
ally creates the new file as well), spawns off 
an instance of the editor specified by the 
environment variable editor on the new 
file, and then moves the old file into the 
source archive directory (.arct.source). 


UNCLASSIFIED 
























UNCLASSIFIED 


76 


Description of Main Programs (Continued) 

Name 

Invocation Syntax 

Option Description 

ARCT_MAK£ 

arct.make unit or 

arct.make -s unit makefile 

This program is the ARCT make processor. 

It locates the make-file for the unit (or, is -s 
is specified, sets the makefile to be the 
current make-file for the unit before 
proceeding), reads it, and invokes 
ARCT_ADA, (or the specified construction 
procedure) on any units which need updat¬ 
ing. 

MAKE_MAKE 

make_make [-a][-s] unit 

Creates a make-file for the unit on its stan¬ 
dard output which will cause normal Ada 
recompilation behavior. 

-a Causes references to units which cannot be 
found in the current directory to be 
included in the make-file (the default is to 
omit references to units outside the current 
directory). 

-s Causes references to standard library' units 
to be included in the make-file. 


ARCT_ADA (arct_ada.aj; 

with textJo,intJo,u_env,a_strings; 
use text_io,intJo,u_env,a_strings; 


procedure arct_ada is 


cmdjine 

cmd_line_ptr 

ret_code 

tempfile 

report_file 

line 

last 


: a_string; 

:integer := 1; 

:integer; 

: string(1..23) := “.arct.source/.arct.temp”; 
: FiLE_TYPE; 

: string(1..80); 

: natural; 


function find_v(s:a_string) return boolean is 
begin 

if next(“ -v”,s) > 0 then 
return true; 

end if; 
exception 

when NOT_FOUND => return false; 
end find_v; 


begin 

cmdjine := to_a(“/usr/vads5/bin/ada ”); 
fori in l..argc-l loop 

cmdjine := cmdjine & argv(i) & ‘ ’; 

end loop; 


UNCLASSIFIED 















UNCLASSIFIED 


if find_v(cmd_line) then 

cmcLline := cmdjine & “] tee ” & tempfile; 

else 

cmdjine := cmdjine & “-v > ” & tempfile; 

end if; 

-ret_code := unix_prcs.spawn(cmdjine); 

putJine(argv(0). s & “=> ” & cmdjine. s); 

putjine(argv(0).s & “-> ” & “(cannot interface to compiler)”); 

- to find out if compilation was successful, 

- grep tempfile for "UNIT UNCHANGED”. 

- if this is found, compilation was unsuccessful, 
return; 

end arct_ada; 


ARCT_CREATE (arct_create.a): 

with text_io, graph_manager, file_util, my_strings, 

A_STRINGS, C_STRINGS, UJENV, ARG_SCANNER, ARCT_GLOBALS; 
use TEXT_IO, GRAPH_MANAGER, FILE_UT1L, MY_STRINGS, 

A_STRINGS,C_STRINGS,U_ENV, ARG_SCANNER, ARCT_GLOBALS; 

procedure arct_create is 


options 

:flag_array_type := reset_flags; 


arg_ptr 

unteger :=1; 


node 

integer := 0; 


module_name 

:unit_name := (others 

=>*’) 

bmodule_name 

:unit_name := (others 

=>‘0 

fname 

:file_naxne := (others 

->*’) 

bname 

:file_name := (others 

=>*’) 

namejen 

integer :=0; 



begin 

if (argc > 3) or (argc < 2) then 

stderrJine(“Incorrect number of arguments. Correct usage:”); 
stderrjine(“”); 

stderrjine(“ arct.create [-b] unit_name”); 

stderrjine(“”); 

return; 
end if; 

get_args(“b”, options, arg_ptr); 

get_vgraph; 

if not options('b’) then 

name Jen := argv(arg_ptr).s'LAST; 
modu!’_name (l..namejen) := argv(arg_ptr).s; 
FlND_cuRRENT(module_name,fname,node); 
if node = 0 then 

fname := file_name_of(module_name); 
if not file_exists(trim(fname)) then 


UNCLASSIFIED 







UNCLASSIFIED 


ARCT_ CREATE 78 


stderr(“File 
stderr(trim(fname)); 
stderr(“’ for unit ’”); 
stderr(trim(module_name)); 
stderrjine(“’ not found.”); 

stderrJine(“Must have initial file to start new unit.”); 

return; 

end if; 

backup_vgraph; 

CREATE_VER(fname,module_name); 

put_vgraph; 

put(“File ’”); 

put(trim(fname)); 

put_line(“’ successfully added to version control”); 
put(“graph for unit ’”); 
put(trim(module_name)); 
putjine(“’.”); 

return; 

else 

stderr(“Unit ”’); 
stderr(trim(module_name)); 

stderr_line(“’ already exists in version control graph.”); 

return; 

end if; 

else 

namejen := argv(arg_ptr).s'LAST; 
module_name (1..namejen) := argv(arg_ptr).s; 
FlND_CURRENT(module_name, fname .node); 
if node = 0 then 

bmodule_name := module_name; 
bmodule_name(nameJen+l..nameJen+2) := “_b”; 
FIND_CURRENT(bmodule_name, fname .node); 
if node = 0 then 

fname := file_name_of(module_name); 
bname := file_name_of(bmodule_name); 
if file_exists(trim(fname)) and 
file_exists(trim(bname)) then 
backup_vgraph; 

CREATE_VER(fname,module_name); 

CREATE. VER(bname,bmodule_name); 
put.vgraph; 

put Jine(“File ’” & trim(fname) & 

for specification and file ’” & 
trim(bname) & for body of unit ’” & 
trim(module_name) & “’”); 

put Jine(“successfully added to version control graph.”); 

else 

stderr Jine(“Cannot find file(s) ’” & 

trim(fname) & and ’” & trim(bname) & 

“’•”); 

stderr Jine(“Both must exist for new nodes to be” & 
“created.”); 

end if; 


UNCLASSIFIED 







UNCLASSIFIED 


ARCT. CREATE 


79 


else 

stderr_line(“Unit & trim(bmodule_name) & 
% “ ’ air cady exist s; 

return; 

end if; 

else 

stderrJine(“Unit & module_name(l..name_len)); 
put_line(“’ already exists.”); 

# return; 

end if; 

end if; 
return; 

exception 

# when IND£X_FILE_NOT_FOUND => 

stderr_line(“ARCT index file not found.”); 
stderr_line(“Perhaps this is not an ARCT library.”); 
when INVALID_FLAG => 

stderrjine(“lnvalid option. Correct usage:”); 
stderr_line(“”); 

# stderrjine(“ arct.create [-b] unit_name”); 

stderr_line(“”); 

end arct_create; 


ARCT_CURRENT (arct_current.a); 

with TEXT_IO, GRAPH_MANAGER, FILE_UT1L, MY_STRINGS, 

A_STRINGS,C_STRINGS,UJENV, ARG_SC ANNER, ARCT_GLOBALS; 
use TEXT_IO, GRAPH_MANAGER, FILE_UnL, MYJSTRINGS, 

• A_STRINGS,C_STRINGS,U_ENV, ARG_SCANNER, ARCT_GLOBALS; 

procedure arct_current is 


options 

arg_ptr 

# node 

module_name 

fname 

namejlen 


:fla^_array_type := reset_flags; 
integer :=1; 

:integer := 0; 

:unit_name := (others =>*’); 

:file_name := (others => ‘ ’); 

integer := 0; 


begin 

if argc < 2 or argc > 3 then 

stderr Jine( M Incorrect number of arguments. Correct usage:”); 
stderr_line(“”); 

stderrjine(“ arct.cur [-s] unit_name”); 

stderr_line(“"); 

return; 

end if; 

get_args(“s”, options, arg_ptr); 


UNCLASSIFIED 






UNCLASSIFIED 


ARCT_CURRENT 80 


get_vgraph; 

namejen := argv(arg_ptr).s'LAST; 
module_name (1..name_len) := argv(arg_ptr).s; 
riND_cuRRENT(module_n2me / fname : node); 
if options(‘s’) then 

if node = 0 then 

put(“Warning: unit ’”); 
put(trim(module_name)); 
putjine(“’ has no current unit.”); 
putJine(“Attempting to complete operation anyway.”); 

else 

put(“Current file for unit ”’); 

put(trim(module_name)); 

putjine(“’”); 

put(“is ”’); 

put(trim(fname)); 

putjine(“’.”); 

end if; 

namejen := argv(arg_ptr + 1 ).s'last; 

fname(l..namejen) := argv(arg_ptr + l).s; 

fname(namejen+l..file_namejen) := (others => 4 ’); 

if file_exists(trim(fname)) then 
backup_vgraph; 

if set_current(module_name,fname) then 
put_vgraph; 
put(“File ’”); 
put(trim(fname)); 
putjine(“’ is now the current”); 
put(“file for unit ”’); 
put(trim(module_name)); 
putjine(“’.”); 

else 

stderr(“Unit ”’); 
stderr(trim(module_name)); 
stderrjine(“’ has no file”); 
stderr(“’”); 
stderr(trim(fname)); 
stderrjine(“’ associated with it.”); 

end If; 

else 

stderr(“File ’”); 
stderr(trim(fname)); 
stderrjine(“’ does not exist in”); 
stderr(“the current library. It cannot be set”); 
stderrjine(“ as a current file.”); 

end if; 

else 

if node = 0 then 

put(“No current node for unit ’”); 
put(trim(module_name)); 
putjine( 44 ’”); 

put Jine( M in the version control graph.”); 

else 


UNCLASSIFIED 










UNCLASSIFIED 


ARCT_CURRENT 


81 


put(“Current file for unit 
put(trim(module_name)); 

# put_line(“”’); 

put(“is 

put(trim(fname)); 

put_line(“’.”); 

end if; 
end if; 

# return; 
exception 

when INDEX_FILE_NOT_FOUND => 

stderr_line(“ARCT index file not found.”); 
stderr Jine(“Perhaps this is not an AJR.CT library.”); 

# when INVALID_FLAG => 

stderr_line(“Invalid option. Correct usage:”); 
stderr Jine(“”); 

stderrjine(“ arct.cur [-s] unit_name”); 
stderrJine(“”); 

# end arct_current; 


ARCT_DESCEND (arct_descend.a); 

• with TEXT JO, GRAPHJvlANAGER, F1LE_UT1L, MYJSTRINGS, 

A_STRINGS, UJENV, ARCT_GLOBALS; 
use TEXT_IO, GRAPH_MANAGER, FILE_UTIL, MY_STRINGS, 
A_STRINGS, UJENV, ARCT_GLOBALS; 

procedure arct_descend is 

functionjflag 
arg_ptr 
node 

modulejiame 
fname 

• namejen 

begin 

if (argc /= 2) then 

stderr_line(“Incorrect number of arguments. Correct usage:”); 

• stderr_line(“”); 

stderr_line(“ arct.desc unit_name”); 
stderrjine(“"); 
return; 
end if; 
get.vgraph; 

• namejen :=argv(arg_ptr).s'LAST; 
modulejiame (1..name Jen) :* argv(arg_ptr).s; 
FIND_cuRRENT(modulejiame,fname,node); 


•.boolean 

integer 

integer 

:unitjname 

:filejiame 

integer := 0; 


= False; 

-l; 

= 0 ; 

:= (others 
:= (others 


=>*’); 

=>*’); 


UNCLASSIFIED 





UNCLASSIFIED 


ARCT^DESCEND 


82 


if node = 0 then 

stderr(“Unit ’”); 
stderr(trim(moduie_name)); 
stderr_line( u ’ does not have”); 
stderr_line(“a current file in this library.”); 

else 

if file_exists(trim(fname)) then 
backup_vgraph; 

DESCEND(module_name); 
put(“Unit ’”); 
put(trim(module_name)); 
put(“’ was descended from file”); 
put(“’”); 

put(trim(fname)); 
putjine(“’”); 
put(“to file ’”); 

FlND_cuRRENT(module_name ,fname,node); 

put(trim(fname)); 

put_line(“’.”); 

put_vgraph; 

else 

stderr(“Cannot find current source file ”’); 

stderr(trim(fname)); 

stderr_Jine(“”’); 

stderr(“for unit ”’); 

stderr(trim(module_name)); 

stderr_line(“’.”); 

end if; 
end if; 
return; 
exception 

when INDEX_FILE_NOT_FOUND => 

stderr_line(“ARCT index file not found.”); 
stderr_line(“Perhaps this is not an ARCT library.”); 

end arct_descend; 


ARCT_DIR farct_dir.a); 

with GRAPH_MANAGER, ARCT_GLOBALS, ARC_SCANNER, 
TEXT_IO, U_ENV, A_STRINGS; 

use GRAPH_MANAGER, ARCT_GLOBALS, ARG_SCANNER, 

TEXT_IO, U_ENV, A_STRINGS; 

procedure arct_dir is 

arg_ptr ; integer :=1; 

options : flag_array_type := reset_flags; 


begin 


UNCLASSIFIED 





UNCLASSIFIED 


ARCT_D1R 83 


get_args(“dv”,options,arg_ptr); 
if arg_ptr /= argc then 

• path := argv(arg_ptr); 

if path.s(path.len) /= 7’ then 
path := path & 7’; 

end if; 

end if; 

if options(‘d’) then 

• get_dgraph; 

if not DISPLAY.DER then 


end if; 
elsif options( V) then 

get_vgraph; 


put_line(“Derived unit graph is empty.”); 


else 


if not DISPLAY.VER then 

put_line(“Source control graph is empty.”); 

end if; 


end if; 
return; 


get_vgraph; 

directory; 


exception 

when INDEX_FILE_NOT_FOUND => 

stderrJine(“ARCT index file not found.”); 

• stderr Jine(“Perhaps this is not an ARCT library.”); 

return; 

when INVALID_EUVG => 

stderr_line(“Invalid option. Correct usage:”); 
stderr_line(“”); 

stderr_line(“ arct.dir [-d|-v] [path]”); 

# stderr_line(“”); 

return; 


end arct.dir; 


ARCT_EDIT farct.edit. 


a): 


with TEXT JO, GRAPH.MANAGER, FILE.UTIL, MY.STRINGS, 

A.STRINGS, C.STRINGS, UJNV, ARCT.GLOBALS, UNIXJRCS; 
use TEXT JO, GRAPH.MANAGER, FILE.UTIL, MYJTRINGS, 

• AJSTRINGS, CJSTRINGS, UJNV, ARCT.GLOBALS; 


procedure arct_edit is 

functionjlag 

arg_ptr 

♦ node 

module jame 
fname 


:boolean 

integer 

integer 

:unit_name 

:file_name 


= False; 

= 1 ; 

- 0 ; 

:= (others 
:= (others 


=> ‘ ’); 
=> 4 ’); 


# 


UNCLASSIFIED 






UNCLASSIFIED 


ARCT_EDIT 


old_fname :file_name := (others =>*’); 

name_len integer := 0; 

ret_code :integer := 0; 

begin 

if (arge /= 2) then 

stderr_line(“Incorrect number of arguments. Correct usage:”); 
stderrJine(“”); 

stderr_line(“ arct.edit unit_name”); 
stderrJine(“”); 

return; 
end if; 

get.vgraph; 

name Jen := argv(arg_ptr).s'LAST; 
module_name (l..namejen) := argv(arg_ptr).s; 

FiND_cuRRENT(module_name, old _fname, node); 
if node = 0 then 

stderr(“Unit ”’); 
stderr(trim(module_name)); 
stderrJine(“’ does not have”); 
stderrJine(“a current file in this library.”); 

else 

if file_exists(trim(old_fname)) then 
backup_vgraph; 

DESCEND(module_name); 

FiND_cuRRENT(module_name, fname, node); 
put Jine(“Descending ” & trim(module_name) & 

“ from ” & trim(old_fname) & 

“to” & trim(fname) & “...”); 
if unix_prcs.spawn(to_a(“cp ” & trim(oldjfname) & 

“ ” & fname)) = 0 than 

if unix_prcs.spawn(to_a(getenv(to_c(“EDITOR”))) & “ ” & 
trim(fname)) = 0 then 
put_vgraph; 

if unix_prcs.spawn(to_a(“mv -f ” & 

trim(old_fname) & “ ”) & source_archive) /= 0 then 
stderrJine(“Error moving ” & trim(old Jname) & 

“ to ” & “source archive.”); 

end if; 

else 

ret_code := unix_prcs.spawn(to_a(“rm -f ” & trim(fname))); 
stderr Jine(“Error editing ” & trim(fname) & 

“. Descend operation failed.”); 

end if; 

else 

stderr Jine(“Could not copy file ” & trim(old Jname) & 

“ to file ” & trim(fname) 

end if; 

else 

stderr(“Cannot find current source file ’”); 
stderr(trim(fname)); 
stderrJine(“’”); 


UNCLASSIFIED 





UNCLASSIFIED 


ARCT-EDIT 85 


stderr(“for unit 
stderr(trim(module_name)); 

# stderr_line(“’.”); 

end if; 

end if; 
return; 
exception 

when INDEXJFILE_NOT_FOUND => 

# stderr_line(“ARCT index file not found.”); 

stderrJine(“Perhaps this is not an ARCT library.”); 

end arct_edit; 


ARCT_MAKE (arctjnake.a): 


With TEXTJtO, GRAPH_MANAGER, FILE_UTIL, MY_STRINGS, MAKE_PROCS, 
A_STRINGS, U_ENV, ARCT_GLOBALS, ARG_SCANNER; 

Use TEXT_IO, GRAPH31ANAGER, FILE_UTIL, MY_STRINGS, MAKEJPROCS, 
• A_STR1NGS, U_ENV, ARCT_GLOB ALS, ARG_SCANNER; 


procedure arct_make is 


set_flag 

arg_ptr 

# node 

module_name 

fname 

mname 

name_len 

INCORRECT_USAGE 


:boolean 

:= false; 


integer 

i; 


: integer 

:■ 0; 


:unit_name 

:= (others 

">*’); 

:file_name 

:= (others 

=>*’); 

:file_name 
:integer :=0; 

: exception; 

:= (others 

->•’); 


begin 


if ((argc /=2) and (argc /= 4)) or else 
((argc = 2) and (argv(ar&_ptr).s(l) = * -’)) then 
raise INCORRECT_USAGE; 

• end if; 

if (argc = 4) then 

if (argv(arg_ptr).s(l) = *-’) and (argv(arg_ptr).s(2) = ‘s’) then 
set_flagTrue; 
arg_ptr :=» arg_ptr + 1; 
else 

• raise INCORRECT_USAGE; 

end if; 
end if; 

get_vgraph; 

get_dgraph; 

namejen argv(arg_ptr).s'LAST; 

• module_name (l..namejen) := argv(arg_ptr).s; 
FlND_cuRRENT(module_name,fname,node); 

if node = 0 then 


UNCLASSIFIED 








UNCLASSIFIED 


ARCT-MAKE 


86 


stderr(“Unit 

stderr(trim(module_name)); 

stderr_line(“’does not have”); % 

stderr_line(“a current file in this library.”); 

return; 

elsif set_flag then 

backup_vgraph; 

namejen := argv(arg_ptt + 1) s'last, 

mname (1..namejen) := argy(arg_ptr + l).s; # 

BIND(mname,fname); 

put_vgraph; 

else 

mname := get_makeJile_name(module_name); 

end if; j 

if file_exists(trim(mname)) then # 

if BUiLD_MAKE_STRUCT(mname) then 
backup_dgraph; 

MAKE; 
put_dgraph; 

else 

stderrJine(“Fatal error reading makefile & #j 

trim(mname) & “’."); 

end if; 

else 

stderr(“Make file ”’); 
stderr (trim(mname)); 

stderrjine(“’ not found.”); # 

end if; 
return; 

exception 

when MAKE_FAILED **> 

stderr Jine(“***** Error code 1”); • 

when INDEX_FILE_NOT_FOUND => 

stderrJine(“ARCT index file not found.”); 
stderrJine(“Perhaps this is not an ARCT library.”); 
when INCORRECT_USAGE => 
stderrJine(“Incorrect usage. Correct usage:”); 

stderrJine( w ”); • 

stderrjine(“ arct.make unit_name or”); 

stderrJine(“ arct.make -s unit_name makejile”); 

stderrjine(“”); 
end arct_make; 


MAKE-MAKE fmake_make.a): 

with TEXT_IO, MY_STRINGS, A_STRINGS, U_ENV, STANDARD_LIST, 

FILE_SUPPORT, ARG_SCANNER; 

use TEXT_IO, MY_STRIMGS, A_STRINGS, U_ENV, ARG_SCANNER; • 

procedure make_make is 


UNCLASSIFIED 






UNCLASSIFIED 


MAKELMAKE 87 


type dependency_rec; 
type a_dependency_rec 
type dependency_rec is 
unit 

dependencies 
source 
next_rec 
end record; 
dependencyjist 
get_another 
globaLdeps 
arg_ptr 
c_ptr 
options 
NO_FILE_ARG 


is access dependency_rec; 
record 
: vstring; 

: large_vstring; 

: boolean; 

: a_dependency_rec; 

: a_dependency_rec; 

: a_dependency_rec; 

: large_vstring; 

: integer := 1; 

:integer; 

: flag_array_type := reset_flags; 

: exception; 


procedure stderr(s: in string) renames file_support.write_to_stderr; 

procedure GET_WORD(fspec: in FILE_TYPE; wd: out vstring; 
wd_delim: out character) is 

word :vstring; 

C : CHARACTER; 

delim constant array (0..127) of boolean := 


(True, 

True, 

True, 

True, 

True, 

True, True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, True, 

True. 

True, 

True, 

True, 

True, 

True, 

True, True, 

True, 

True, 

True, 

True, 

True, 

True, 

False, True, 

True, 


False, False, False, False, 
False, False, True, True, 

True, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, True, 

True, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, True, 


False, False, False, False, 
True, True, True, True, 


False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
True, True, True, False, 

False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
True, True, True, True); 


begin 


word.len :=0; 
get(fspec,c); 

while delim(CHARACTER'POS(c)) loop 
get(fspec,c); 

end loop; 

while not delim(CHARACTER'POS(c)) loop 


UNCLASSIFIED 





UNCLASSIFIED 


MAKELMAKE 88 


if c > = ‘a’ and c <= ‘Z’ then 

c := character'val(character'pos(c) + 32); 

end if; 

word.len := word.len + 1; 
word.str(word.len) := c; 
get(fspec.c); 

end loop; 

wd_delim := c; 

if word.len > 1 and word.str(1..2) = then 

skip_line(fspec); 

get_word(fspec,word,wd_delim); 

end if; 

wd := word; 

return; 

exception -if EOF encountered, just return blanks 

when end_error => 
wd_delim := ‘ ’; 
wd := word; 

return; 


end GET_WORD; 


procedure GET_DEPENDENCIES(unit: in a_dependency_rec) is 


fspec 

depends 

word 

temp_record 

irecord 

word_delim 


: FILE_TYPE; 

: large_vstring; 

: vstring; 

: a_dependency_rec; 
: a_dependency_rec; 
CHARACTER; 


begin 


open(fspec,lNJFlLE,unit.unit.str(l..unit.unit.len) & “.a”); 

unit.source := true; 

while not end_of_file(fspec) loop 

get_word(fspec ,word,word_delim); 
if (word.len = 4) and (word.str(l..word.len) = “with”) then 
while not end_o£_file(fspec) and word_delim /= loop 
get_word(fspec .word ,word_delim); 

-put(”’” & unit.unit.str(l..unit.unit.len) & : ”);( 

-put(”’” & word.str(l..word.len) & :”);( 

if options(V) or else 

not standard_list.exc!ude(word) then 
irecord := dependencyJist; 

-put(”Searching for node in tree...”);( 
if irecord.unit /= word then 

while irecord .next_rec /» NULL and then 
irecord.next_rec.unit /= word loop 
-put(”loop...”);( 
irecord := irecord.next_rec; 


UNCLASSIFIED 





UNCLASSIFIED 


MAKELMAKE 89 


end loop; 

if irecord.next_rec /= null and then 
irecord.next_rec.unit = word then 
-put_line(”Node found.”);( 
temp_record := irecord.next_rec; 
irecord.next_rec := irecord.next_rec.next_rec: 
temp_record.next_rec := dependencyjist; 
dependencyjist := temp_record; 

else 

-put_line(”Node not found-creating new node.”);( 
temp_record := new dependency_rec; 
temp_record.next_rec := dependencyjist; 
dependencyjist := temp_record; 
temp_record.unit :=word; 
get_dependencies(dependencyjist); 

end if; 

end if; 

end if; 

if options(‘s’) or else 

not standardjist.exciude(word) then 
word.str(word.len+l.. word.len+2) := “.a”; 
word.len := word.len + 2; 

unit.dependencies := unit.dependencies + word; 
word.str(word.len) := ‘o’; 

else 

word.str(word.len+l..word.len+2) := “.o”; 
word.len := word.len + 2; 

end if; 

globaLdeps := (globaLdeps - word) + word; 

end loop, 

end if; 
end loop; 

-newjine;; 

-put(unit.unit.str(l..unit.unit.len) & ”.o: ” &( 

- unit.unit.str(l..unit.unit.len) & ”.a”); 

-put(unit.dependencies.str(l..unit.dependencies.len));( 

-putjine(”;”);( 
close(fspec); 
return; 

exception 

when name_error => 

unit.source := false; 

return; 

end GET_DEPENDENCIES; 

function translate(s:in large_vstring) return string is 

c_ptr . integer :=1; 

result : large_vstring := s; 


UNCLASSIFIED 




UNCLASSIFIED 


MAKELMAKE 90 


begin 


while c_ptr < result.len loop 

if result. str(c_ptr) = ‘ ’ and then 
result.str(c_ptr+l) = ‘ ’ then 

result. str(c_ptr..result .len -1) := 

result .str(c_ptr+1. .result .len); 
result.len := result.len -1; 

else 

c_ptr := c_ptr + 1; 

end if; 
end loop; 

return result.str(l..result.len); 


end translate; 

procedure print(s: in large_vstring; gap: in integer) is 
spaces : string(1..40) := (others => ‘ ’); 
beg_ptr : integer :=1; 

begin 

if s.len > 0 then 

for end_ptr in 1 .. s.len loop 

if s.str(end_ptr) = 4 ’ then 

put_line(s.str(beg_ptr. .end_ptr)); 
put(spaces(l. .gap)); 
beg_ptr := end_ptr + 1; 
end if; 
end loop; 

put(s.str(beg_ptr..s.len)); 

end if; 
return; 
end print; 

procedure stderrjine (m: in string) is 
begin 

stderr(m & character'val(lO)); 

end; 


begin 


get_args(“as”,options ,arg_ptr); 
if arg_ptr < argc - 1 then 

stderr_line(“Too many arguments. Only first filename encountered”); 
stderr_line(“will be processed.”); 

end if; 

if ar&_ptr = argc then 

raise NO_FILE_ARG; 

end if; 

dependencyJist := new dependency_rec; 
dependency_list.unit.len:« argv(arg_ptr).len; 

dependency Jist .unit.str(l. .dependencyjist .unit .len) := argv(arg_ptr).s; 
-putJine(”Root of dependency tree formed.”);( 
get_dependencies(dependencyjist); 
get_another := dependencyjist; 


UNCLASSIFIED 




UNCLASSIFIED 


MAKE-MAKE 91 


while get_another.next_rec /= null loop 

if options(‘a’) or else get_another.source then 

put(get_another.unit.str(l..get_another.unit.len) & “.o: ” & 
get_another.unit.str(l..get_another.unit.len) & “.a”); 
print(get_another.dependencies,get_another.unit.len + 4); 
put_line(“;”); 
new_line; 
end if; 

get_another := get_another.next_rec; 

end loop; 

if get_another.source then 

put(get_another.unit.str(l..get_another.unit.len) & “.o: ”& 
get_another.unit.str(l..get_another.unit.len) & “.a”); 
print(get_another.dependencies,get_another.unit.len + 4); 
putjine(“;”); 
newjine; 

put(get_another.unit.str(l..get_another.unit.Ien) £ “.e: ”& 
get_another.unit.str(l..get_another.unit.Ien) & “.o”); 
put(translate(globaLdeps)); 

put_line(“;”); 

else 

put(“Source file ’”); 

put (get_another. unit. s t r (1.. get_another.unit. len)); 
putjine(“.a’ not found in current directory.”); 

end if; 
return; 

exception 

when INVALID_FLAG => 

stderr_line(“Invalid option. Correct usage:”); 
stderrjine(“”); 

stderr_line(“ make_make [-a][-s] unit”); 
stderrjine(“”); 

return; 

when NO_FILE_ARG => 

stderr_line(“No file argument specified. Correct usage:”); 
stderr_line(“”); 

stderrjine(“ make_make [-a][-s] unit”); 
stderr_line(“”); 

return; 

end make_make; 


UNCLASSIFIED 



UNCLASSIFIED 


92 


B.4. Library Units 


ARCT^GLOBALS Package Specification (arct_globals.a): 

with a^strings, file_support, file_namcs; 
use a_strings; 
package arct_globals is 

path : a_string := empty; 

source_archive : a_string := to_a(“.arct.source”); 

procedure get_dgraph; 
procedure backup_dgraph; 
procedure put_dgraph; 
procedure get_vgraph; 
procedure backup_vgraph; 
procedure put_vgraph; 

function file_exists(fnatne :in a_string) return boolean 
renames file_names. exists; 
function file_exists(fname : in string) return boolean; 
procedure stderr(s: in string) renames file_support.write_to_stderr; 
procedure stderrjine (m: in string := “”); 

lNDEX_FiLE_NOT_FOUND : exception; 

end arct_globals; 


arct_globals Package Body (arct_globals.b.a); 

With TEXT_IO, GRAPH_MANAGER, UNCHECKED_DEALLOCATION; 
use TEXT_IO, graph_manager; 


package body arct_globals is 


ver_graph_fname 

ver_graph_backup 

der_graph_fname 

der_graph_backup 


constant string(1..23) 
constant string(1..23) 
constant string(1..23) 
•.constant string(1..23) 


= “.arct.source/vgraph.dat”; 
= “.arct.source/vgraph.bak”; 
= M .arct. source/dgraph .dat ”; 
= M .arct. source/dgraph .bak”; 


procedure free is new unchecked_dealiocation(string_rec,a_string); 


procedure get_dgraph is 

adaindex :FILE_TYPE; 

begin 

If file_names.exists(path & to_a(der_graph_fname)) then 
open(adaindex,IN_FlLE,path.s & der_graph_fname); 
READ_DER_GRAPH(adaindex); 
close (adaindex); 

els ■ 


UNCLASSIFIED 






UNCLASSIFIED ARCT.GLOBALS Package Body 93 


raise INDEX_FILE_NOT_FOUND; 

end if; 
return; 

end get_dgraph; 

procedure backup_dgraph is 
adaindex : file_type ; 

begin 

create(adaindex,ouT_FlLE,path.s & der_graph_backup); 
STORE_DER_GRAPH(adaindex); 
close(adaindex); 
end backup_dgraph; 

procedure put_dgraph is 

adaindex :FILE_TYPE; 

begin 

open(adaindex,our_FILE,path.s & der_graph_fname); 
store jDER_GRAPH(adaindex); 
close(adaindex); 
end put_dgraph; 

procedure get_vgraph is 

adaindex :FILE_TYPE; 

begin 

if file_names.exists(path & to_a(ver_graphJfname)) then 
open(adaindex,iN_FlLE,path.s & ver_graph_Iname); 
RLAD_VER_.GRAPH(adaindex); 
close(adaindex); 

else 

raise INDEX_FILE_NOT_FOUND; 

end if; 
return; 

end get_vgraph; 

procedure backup_vgraph is 

adaindex :FILE_TYPE; 

begin 

create(adaindex,ouT_F iLE.path.s & ver_graph_backup); 
STORE_VER_GRAPH(adaindex); 
close(adaindex); 
end backup_vgraph; 

procedure put_vgraph is 

adaindex :file_type; 

begin 

open(adaindex,ouT_FlLE,path.s & vcr_graph_fname); 
STORE_VER_GRAPH(adaindex); 
close(adaindex); 
end put_vgraph; 

function file_exists(fname :in string) return boolean is 
temp : a_string := to_a(fname); 

result : boolean := false; 


UNCLASSIFIED 




UNCLASSIFIED arct_globals Package Body 94 


begin 

result := file_names.exists(temp); 

free(temp); 

return result ; 

end; 

procedure stderr_line(m :in string := “”) is 

begin 

stderr(m & ascii.If); 

end; 

end arct_globals; 


arg_scanner Package Specification (arg_scanner.a): 
package arg_scanner is 

type flag_array_type is array (‘0’..‘z’) of boolean; 

reset_f!ags : constant flag_array_type := 

( False, False, False, False, False, False, False, False, 
False, False, False, False, False, False, False, False, 

False, False, False, False, False, False, False, False, 
False, False, False, False, False, False, False, False, 
False, False, False, False, False, False, False, False, 
False, False, False, False, False, False, False, False, 

False, False, False, False, False, False, False, False, 
False, False, False, False, False, False, False, False, 
False, False, False, False, False, False, False, False, 
False, False, False 

); 


* 


procedure get_args(possible_flags: in string; 

flags: in out flag_array_type; arg_ptr: in out integer); 

invalidJFLAG : exception; 

end arg_scanner; 


arg.scanner Package Body farg_scanner.b.a); 

with UJENV; 
use U_ENV; 

package body arg_scanncr is 

procedure get_args(possible_flags: in string; 


UNCLASSIFIED 





UNCLASSIFIED 


arg_scanner Package Body 


95 


flags: in out flag_array_type; arg_ptr: in out integer) is 

valid_flags : flag_array_type := reset_flags; 

c : character; 


begin 


if arg_ptr >= argc then 
return; 

end if; 

for i in possible_flags'first..possible_flags'last loop 
valid_flags(possible_flags(i)) :=lrue; 

end loop; 

while argv(arg_ptr).s(l) = loop 

for c_ptr in 2..argv(arg_ptr).len loop 
c := argv(arg_ptr).s(c_ptr); 
if valid_flags(c) then 
flags(c) := True; 

else 

raise INVALID_FLAG; 

end if; 
end loop; 

arg_ptr := arg_ptr + 1; 
exit when arg_ptr = argc; 
end loop; 

end get_args; 


end arg_scanner; 


FILELUTIL Package Specification ffile_util.a); 

with TEXT_IO,MY_STRINGS; 
use TEXT_IO,MY_STRINGS; 


package FILE_UTIL is 


-types used for scanning buffers 
type buffer is record 

str :STRlNG(l..slen); 

bpos :POsmvE := 1; 

windowpos :natural := 0; 

end record; 


type target is record 

str :STRlNG(l..slen); 

len :NATURAL := 0; 

index :positive := 1; 

end record; 


UNCLASSIFIED 





UNCLASSIFIED 


FILELUTIL Specification 


96 


-procedures and functions in this package 

procedure sCAN(tstr :in vstring; fspec :in file_type); 

procedure sCAN(tstr :in vstring; tspec :in FILE_TYPE; 

ospec :in FILE_TYPE); 

function GET_woRD(fspec :in FILE_type) return vstring; 

function GET_woRD(fspec :in FILE_type; ospec :in file_type) 

return vstring; 

procedure DUM?_RE;vIAINDER(ispec :in FILE_TYPE; 
ospec :in FILE_TYPE); 

function FlLE_NAME_OF(module :in unit_name) return file_name; 
function DESCEND_FNAME(fname_in :in file_name) return file_name; 


end FILE_UT1L; 


FILE..UTIL Package Body ffile_util.b.aj. 

with TEXT_IO,MY_STRINGS,INT_IO; 
use TEXT_IO,MY_STRINGS,INT_IO; 

package body FILE_UTIL is 

procedure GETC(buff :in out buffer; fspec :in FILE_TYPE) is 
-This proc gets one character from the specified file 
-and places it in the given buffer 


begin 


get(fspec ,buff. str(buff .bpos)); 

- These lines echo file to terminal as characters are retrieved 

- put(buff.str(buff.bpos)); 

- while end_ofJine(fspec) loop 

- skip_line(fspec); 

- newjine; 

- end loop; 

buff .bpos := buff.bpos mod slen + 1; 

return; 

endGETC; 


procedure scAN(tstr :in vstring; fspec :ln F!LE_TYPE) is 
-This procedure scans the specified file for the 


UNCLASSIFIED 





UNCLASSIFIED 


file, util Package Body 97 


-first occurrence of the given vstring 


mainbuf 

tstring 

matchcount 


:buffer; 

:target; 

:NATURAL :=0; 


begin 


- begin initialization 
tstring.str := tstr.str; 

tstring.len :=tstr.len; 

getc(mainbuf,fspec); 

outer: loop 

if mainbuf. str((mainbuf. windowpos + tstring.index - 1) 
mod slen + 1) = tstring.str(tstring.index) 

then 

matchcount := matchcount + 1; 

tstring.index := tstring.index mod tstring.len + 1; 

else 

matchcount := 0; 

mainbuf.windowpos := mainbuf .windowpos mod slen + 1; 

end if; 

if matchcount = tstring.len then 
return; 
end if; 

if (mainbuf.windowpos +tstring.ind ix - 1) mod slen +1 = 
mainbuf .bpos then 
getc(mainbuf ,fspec); 

end if; 

end loop outer; 

end SCAN; 


procedure GETC_ECHo(buff :in out buffer; fspec :in file_type; 
ospec :in FILE_TYPE) is 
-This procedure is exactly like GETC, but it 
-also echoes the input from FSPEC to the file OSPEC. 
-It inserts end-of-lines where necessary so that 
-OSPEC is an exact duplicate of FSPEC. 


begin 


get(fspec,buff .str(buff.bpos)); 
put(ospec ,buff .str(buff .bpos)); 

loop 

if not end_of_line(fspec) then exit; end if; 

skipjine(fspec); 

newjine(ospec); 


UNCLASSIFIED 






UNCLASSIFIED 


filelutil Package Body 


98 


end loop; 

buff.bpos := buff.bpos mod slen + 1; 

return, 

end GETC_ECHO; 


procedure SCAN(tstr :in vstring; fspec :in FILE_TYPE; 
ospec :in file_type) is 

-This procedure is exactly like SCAN, except that it 
—also echoes the input file to OSPEC. 

mainbuf -.buffer; 

tstring :target; 

matchcount :Natural :=0; 


begin 

- begin initialization 
tstring.str := tstr.str; 

tstring.len := tstr.len; 

getc_echo(mainbuf,fspec,ospec); 

outer: loop 

if mainbuf .str((mainbuf .windowpos + tstring.index - 1) 
mod slen + 1) = tstring.str(tstring.index) 

then 

matchcount := matchcount + 1; 

tstring.index := tstring.index mod tstring.len + 1; 

else 

matchcount :*= 0; 

mainbuf .windowpos := mainbuf .windowpos mod slen + 1; 

end if; 

if matchcount = tstring.len then 
return; 
end if; 

If (mainbuf.windowpos +tstring.index - 1) mod slen + 1 = 
mainbuf.bpos then 

getc_echo(mainbuf,fspec,ospec); 

end if; 

end loop outer; 


end SCAN; 


function GET_woRD(fspec :in FILE_TYPE) return vstring is 
-This function returns a vstring containing the next 
-word in the input file. It is meant to be general 


UNCLASSIFIED 





UNCLASSIFIED 


FILE-UTIL Package Body 99 


-purpose, but not bullet-proof., 

buffer rvstring; 

C : CHARACTER; 

delim ‘.constant array (0..127) of boolean := 


(True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 


False, False, False, False, 
False, False, True, True, 
True, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, True, 
True, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, True, 


False, False, False, False, 

True, True, True, True, 

False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
True, True, True, True, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
True, True, True, True); 


begin 


get(fspec.c); 

while delim(CHARACTER'POs(c)) loop 
get(fspec.c); 
end loop; 
for i in l..slen loop 

buffer.str(i) := c; 
get(fspec,c); 

if delim(CHARACTER'pos(c)) then 
buffer.len := i; 

exit; 
end if; 
end loop; 
return buffer; 

end GET_WORD; 


function GET_WORD(fspec :in FILE_TYPE; ospec :in FILE_TYPE) 
return vstring is 

-This function is identical to GET_WORD above, but also 
-echoes its input to the file OSPEC. 

buffer :vstring; 

C :CHARACTER; 

delim constant array (0..127) of boolean := 


UNCLASSIFIED 







UNCLASSIFIED 


filelutil Package Body 

100 

(True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

Tr”e, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

True, 

Irue, 


False, False, False, False, 
False, False, True, True, 
True, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, True, 
True, False, False, False, 
False, False, False, False, 
False, False, False, False, 
False, False, False, True, 


False, False, False, False, 

True, True, True, True, 

False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
True, True, True, True, 
False, False, False, False, 
False, False, False, False, 
False, False, False, False, 
True, True, True, True); 


begin 


get(fspec,c); 

put(ospec,c); 

while delim(cHARACTER'POS(c)) loop 
while end_of_line(fspec) loop 
new_line(ospec); 
skip_liue(fspec); 
end loop; 
get(fspec.c); 
put(ospec,c); 
end loop; 
for i in l..slen loop 

buffer.str(i) := c; 

get(fspec.c); 

put(ospec,c); 

if delim(CHARACTER’POs(c)) then 
buffer.len := i; 

exit; 
end if; 
end loop; 
return buffer; 

end GET_WORD; 


procedure DUMP_REMAINDER(ispec :in FILE_TYPE; espec :in FILE_TYPE) is 
-This procedure copies a file, new-lines and all, from 
-ISPEC to OSPEC. 

c :character; 


begin 


UNCLASSIFIED 


1 





UNCLASSIFIED 


filelutil Package Body 101 


eoijoop: while not end_o£_file(ispec) loop 
while end_of_Iine(ispec) loop 

if end_of_file(ispec > .‘hen exit eof_loop; 
end if; 

new Jine(ospec); 
skipjine(ispec); 

end loop; 

get(ispec.c); 
put(ospec,c); 
end loop eof_loop; 


end DUMP_RF.MAINDER; 


function FlLE_NAME_OF(module :in unit_name) return file_name is 
-This function accepts as its argument a unit name 
-and returns a file name consisting of that unit name 
-fo»' ’'wed by ”.0.a” 


resuUfile :file_name := (others => ‘ ’); 

modjen INTEGER := unit_namejen + 1; 

begin 

for i in l..unit_namejen loop 
if module(i) = ‘ ’ then 
modjen := i; 

exit; 

end if; 
end loop; 

resultfile(l..modJen - 1) := module(l..modjen - 1); 
resultfile(modJen..modjen + 3) := “.O.a”; 
return resultfile; 

end FILE_NAME_OE; 


function DESCEND_FNAME(fname Jn :in file_name) return file_name is 
-This function accepts a VMS file name in and returns 
-The same file name with the next higher version number 


decLstart 

decLend 

ver_ptr 

new_ver 

result 

temp 


begin 


:POsmvE := file_namejen; 

: positive := file_namejen; 

: positive; 

:INTEGER := 0; 

:file_name := fnamejn; 

: natural; 


for i in reverse l..file_namejen loop 


UNCLASSIFIED 






UNCLASSIFIED 


filelutil Package Body 


if fname_in(i) = V then 
decLend := i - 1; 

exit; 
end if; 
end loop; 

for i in reverse 1..decLend loop 
if fname_in(i) = then 
decLstart := i; 
exit; 

end if; 
end loop; 

ver_ptr := decLstart + 1; 

-calculate the old version number: 
while fnanie_in(ver_ptr)>=‘0’ and fname_in(ver_ptr)<=‘9’ loop 
new_ver := new_ver * 10 + 

CHARACTER'POS(fnameJn(ver_ptr)) - 48; 
ver_ptr := ver_ptr + 1; 
end loop; 

new_ver := new_ver + 1; -calculate new version number 

ver_ptr := decLstart + 1; -set semi to char where version 

- number should be placed 

if new_ver > 99 then 

put(result(ver_ptr..ver_ptr+2),new_ver); 
ver_ptr := ver_ptr + 3; 
elsif new_ver > 9 then 

put(result(ver_ptr..ver_ptr+l),new_ver); 
ver_ptr := ver_ptr + 2; 

else put(result(ver_ptr..ver_ptr),new_ver); 
ver_ptr := ver_ptr + 1; 

end if; 

result(ver_ptr..ver_ptr + 1) := “.a”; 
ver_ptr := ver_ptr + 2; 

-blank out rest of file name 
result(ver_ptr..file_namejen) := (others =>*’); 
return result; 

end descend_fname; 


end FILE_UTIL; 


MY_STR1NC,S Package Specification (my_strings.a): 

package MY.STRINGS is 

slen constant INTEGER := 32; 

lslen constant := 256; 

xislen : constant := 1024; 


UNCLASSIFIED 






UNCLASSIFIED 


my_strings Specification 


103 


type vstring is record 

len :natural:=0; 

str :STRING(l..slen) := (others => ‘ ’)‘» 

end record; 

type large_vstring is record 
len :NATURAL := 0; 
str :STRING(l..lslen) := (others => ‘ ’); 

end record; 

type xlarge_vstring is record 
len :natural := 0; 
str :STRING(l..xlslen) := (others => * ’); 

end record; 

-name types and constants used in AC VS and graph manager packages 

file_name_len constant := 39; 

unit_name_len constant :=32; 

subtype file_name is STRlNG(l..file_name_len); 

subtype unit_name is STRlNG(l..unit_name_len); 

subtype make_file_name is STRlNG(l..file_nameJen); 

function “+”(whole :in large_vstring; part :in vstring) 
return large_vstring; 

function “+”(whole :in large_vstring; part :in large_vstring) 
return large_vstring; 

function “-"(whole :in large_vstring; part :in vstring) 
return large_vstring; 

function trim (str :in string) return STRING; 


end MY_STRINGS; 


my_strjngs Package Body (my_strings.b.a): 
package body MY_STRINGS is 


function “+"(whole :in large_vstring; part :in vstring) 
return large_vstring is 

-This function is used to concatenate large_vstrings 
-with vstrings. It inserts a blank space between the 
-end of the large_vstring and the beginning of the vstring 
-when concatenating. 

i:NATURAL; 


begin 


if part.len = 0 then return whole; end if; 
i := whole.len + part.len + 1; 

return (i, 


UNCLASSIFIED 




UNCLASSIFIED 


my_strings Package Body 


104 


whole.str(l..whole.len) & “ ” & 
part.str(l..part.len) & 
whole.str(i + 1..lslen)); 

end 


function “+”(whole :in large_vstring; part :in large_vstring) 
return large_vstring is 

-This function is used to concatenate large_vstrings 
-in the normal manner (no space is inserted). 

i rNATURAL; 

begin 


if part.len = 0 then return whole; end if; 
i := whole.len + part.len; 
if i < lslen then 
return (i, 

whole.str(l..whole.len) & 
part.str(l..part.len) & 
whole. str(i+ 1..lslen)); 

else 

return (lslen, 

whole.str(l..whole.len) & 

part.str(l. .lslen-whole.len)); 

end if; 

end “+”; 


function “-"(whole :in large_vstring; part :ln vstring) 
return large_vstring is 

-This function is used for removing a substring 
-(specified in the vstring) from a larger string( 
-(specified by the large_vstring).( 


matchcount 

windowpos 

subindex 

answer 


INATURAL :=0 
.-NATURAL :=0 
: POSITIVE :=1 
:large_vstring; 


begin 


if part.len - 0 then return whole; end if; 
while windowpos + part.len o whole.len loop 

if whole.str(windowpos + subindex) - part.str(subindex) 
then matchcountmatchcount + 1; 
if matchcount - part.len then 

answer.Ien whole.len - part.len; 


UNCLASSIFIED 







UNCLASSIFIED 


MYSTRiNGS Package Body 


105 


answer.str(l..windowpos) := whole.str(l..windowpos); 
answer.str(windowpos+l..lslen - part.len) := 
whole .str(windowpos+part .len+1. .lslen); 

return answer; 
end if; 

subindex := subindex mod part.len + 1; 
else 

matchcount := 0; 
windowpos := windowpos + 1; 

end if; 
end loop; 
return whole; 


end 


U W. 


function TRIM (str :in STRING) return STRING is 

-This function returns a string consisting of 
-just the first sequence of non-blank characters 
-in the input string. It is used primarily fro ’’trimming” 
-text strings for output so that there true length does not 
-affect the spacing of the output. 


begin 


for i in str'first..str'last loop 
if str(i) = ‘ ’ then 

return str(str'first..i-l); 

end if; 
end loop; 
return str; 

end TRIM; 


end MY_STRINGS; 


standard _ l?*t Package Specification (standardjist.a): 

with my_strings, a_strings; 
use my_strings, a_strings; 


package STANDARD_LIST is 

function exclude(unit : in vstring) return boolean; 

function exclude(unit : in a_string) return boolean; 

-procedure test_array; 


UNCLASSIFIED 






UNCLASSIFIED standard^ust Specification 106 


end STANDARD_LIST; 


-with text Jo, intjo; 
-use text Jo, intjo; 


package body STANDARD_LIST is 

standarcLarray :constant array(1..31) of vstring := ( 


(len 

=> 7, str => (‘tVeYxVtV-ViVo’, 


(len 

=> 5, str 

others =>*’)), 

=> (‘uVJ.V.V.V, others => ‘ ’)), 


(len 

=> 9, str 

=> (V.JVsVtYrViVnVgVs’, 


(len 

=> 7, str 

others => ‘ ’)), 

=> (‘b’/i’.'t’.'J.'o’.V.V, others => ‘ ’)), 

9 

(len 

=> 9, str 

=> OcVJ/sVtVrViVnVgYs’, 


(len 

=> 8, str 

others => ‘ ’)), 

=> (‘c’/a’.T/c’/n’.'d’.V.V, others => * ’)), 


(len 

=> 9, str 

=> Cd-,‘i',¥, 1 e ) ,‘c , ,‘t’,‘J 1 ‘i’,‘o-, 


(len 

=>10, str => 

others => ‘ ’)), 

(‘f .‘i’/l’/e’/J/n’/a’/m’/e’/s’, 

9 


others => ‘ ’)), 

(len =>12, str => (*f ) ‘i , ,T, , e’,‘J,‘s’,‘u , ,‘p’,‘p , ,‘o , ,‘r , ,‘t , > 
others => ‘ ’)), 


(len 

1! 

V 

u> 

C/i 

ii 

V 

.V.LVeVxVcVeYpytViVoVnVs’, 




others => ‘ ’)), 


• 

(len 

=> 5, str 

=> (‘iVo7c7t\T, others => ‘ ’)), 



(len 

=> 9, str 

=> (‘i7o7c7t\T,‘_7f7m7t\ 





others => ‘ ’)), 



(len 

=> 4, str 

=> (T,‘i7b7c\ others => ‘ ’)), 



(len 

=>11, str 

=> (T,‘o\V,T,‘e\V,‘e717_\*i7o\ 





others => ‘ ’))» 


• 

(len 

=>12, str => (W/a7c7h7i7n7e7_7c7o7d7e\ 




others => * ’))» 



(len 

=> 4, str 

=> (‘m’,‘a’,‘t’,‘h’, others => ‘ ’)), 



(len 

=> 6, str 

=> (‘m’,‘e’,‘m’,‘o’,‘r’,‘y’, others => ‘ ’)), 



(len 

=> 9, str 

=> (‘n’,‘u , ,‘m , ,‘b , ,‘e , ,*r , ,*J,‘i’,‘o’, 





others => ‘ ’)), 


• 

(len 

=> 8, str 

=> (‘o’/s’/J/f ,‘i’,‘r,‘e’,‘s’, others 

=>*’)), 


(len 

=> 8, str 

=> ( , r’,‘a’,‘w’,‘_’,‘d , ,‘u , ,‘m’,‘p’, others 

->*’)). 


(len 

=>13, str 

=> (‘s7e7q7u7e7n7t7i7a717_7i7o\ 





others => ‘ ’)), 



(len 

=> 9, str => (V 

/h'.V.V.V.'d'.'J.i’.V, 




others => ‘ ’)), 

(len =>18, str => (‘u’.V.Y.V/J.V.V/a’.r.V.V/J, 

‘b’,‘u’,‘f ,T,‘e’,‘r’, others 


(len 

=> 6, str 

=> (‘s’,‘y7s7t7e7m\ others 

(len 

=>11, str 

=> (‘t’,‘e’,V,‘t’,‘_’,V,‘u’,‘p’,‘p’,‘r’,‘t’, 



others => * ’)), 

(len 

=> 3, str 

=> (‘t’,‘t’,‘y’, others => ‘ ’)), 

(len 

=>22, str 

=> (‘U7n7c7h7e7c7k7e7d7_\ 


■>°)). 


‘dyeVaVlVlVoVcVaVtViVoVn’, 


UNCLASSIHED 




UNCLASSIFIED standard_list Specification 107 


); 


others => ‘ ’)), 

(len =>20, str => (‘u , f ‘n , ,‘c , ,‘h , ,‘e , , , c , ,‘k , ,‘e , t ‘d , t , _ , t 

others => ‘ ’))> 

(len => 4, str => (‘u’/n’/i’/x’, others => ‘ ’)), 

(len => 9, str => (‘uYnViYxV.VdViVrVs’, 

others => 4 ’)), 

(len => 9, str => (‘uYnYiYxY.YpYrYcYs*, others => 4 ’)) 


function exclude(unit: in vstring) return boolean is 
begin 

for i in standard_array'first..standard_arrayiast loop 
if unit = standard_array(i) then 
return true; 
end if; 
end loop; 
return false; 
end exclude; 

function exclude(unit: in a_string) return boolean is 
begin 

for i in standard_array'first..standardLarray'last loop 
if unit.len = standard_array(i).len and then 
unit.s = standard_array(i).str(l.. 
standard_array(i).len) then 
return true; 
end if; 
end loop; 
return false; 
end exclude; 

- procedure test_array is 

- begin 

- for i in standarcLarray'first..standardLarray'last loop 

put(i,3); 

- put(”:”’); 

- put(standard_array(i) .str(l. .standardLarray(i) .len)); 
putjine(”’”); 

- end loop; 

- return; 

- end tesLarray; 

end STANDARDJLIST; 


Definiton of Package COUNT JO (COUNTJO.def.a); 
with TEXT_Io; 

package COUNT_IO is new TT XT_IO.INTEGER_IO (NUM => TEXT_IO.COUNT); 


UNCLASSIFIED 




UNCLASSIFIED 


108 


Definiton of Package INT_IO (lNT_IO.def.aJ: 


withTEXT_IO; 

package INT_IO is newTEXT_IO.INTEGER_IO (NUM => INTEGER); 


UNCLASSIFIED 





UNCLASSIFIED 


109 


Appendix C: TEST RESULTS 


The arct was tested on a test library patterned after the examples presented in Appendix 
D. This library consisted of 5 program units and a make-file: 

Package PI: 

package pi is 

pragma change_type (”objects_n_types”,”07/08/88 17:21:24”); 

-object and type declarations; 

pragma change_type(”ildef”, ”07/08/88 17:21:37”); 

function il return integer; 

pragma change_type (”i2def’,”07/08/88 17:21:50”); 
function i2 return integer; 

pragma change_type (”body_n_procs”,”07/08/88 17:22:00”); 

-rest of procedures 

end pi; 

package body pi is 

function il return integer is 
begin 
return 0; 
end; 

function i2 return integer is 
begin 
return 0; 
end; 

end pi; 


Package P2: 

package p2 is 

pragma change_type (”objects_n_types”,”07/08/8817:22:59”); 
-object and type declarations; 

pragma change_type (”body_n_procs”,”07/08/88 17:23:20”); 
-rest of procedures 


UNCLASSIFIED 






UNCLASSIFIED 


110 


end p2; 

package body p2 is 
end p2; 

Main Program: 

with pl,p2; use pl,p2; 
procedure main is 

pragma change_type (’’types”,”07/08/88 17:19:50”); 

-type declaractions go here 

-pragma inline(il), inline(i2); 

pragma change_type (”sl_decl”,”07/08/88 17:20:02”); 

procedure si; is separate; 

pragma change_type (”s2_decl”,”07/08/8817:20:20”); 

procedure s2; is separate; 

pragma change_type (”body_n_procs”,”07/08/88 17:20:35”); 
-the rest of main goes here. 

end main; 


Separate Procedure SI: 

separate(main); 
procedure si is 

-body of si 

-contains a call to il but no call to i2 

end si; 


UNCLASSIFIED 




UNCLASSIFIED 


111 


Separate Procedure S2: 

separate (main); 
procedure s2 is 

-body of s2 
-does not call il or i2 

end s2; 


Make-File: 
pl.o : pi.a; 
p2.o: p2.a; 


main.c : main.a 

pi.a /body_n_procs /guide 
p2.a /body_n_procs; 

mainpass: main.a 

pl.a /body_n_procs /guide 
p2.a /body_n_procs /i2def; 

sl.o : si.a mainpass; 

s2.o: s2.a mainpass; 

main.e : pl.o p2.o main.o sl.o s2.o; 


Using the command 

arct_make -s main arct_makefile 

generated the following output (recall that no units were yet compiled): 
arct.adapl.O.a 

arct.ada«=> /usr/vads5/bin/ada pl.O.a -v > .arct.source/.arct.temp 
arct.ada=> (cannot interface to compiler) 
arct.ada p2.0.a 

arct.ada=> /usr/vads5/bin/ada p2.0.a-v > .arct.source/.arct.temp 
arct.ada=> (cannot interface to compiler) 
arct.ada main.O.a 

arct.ada»> /usr/vads5/bin/ada main.O.a-v > .arct.source/.arct.temp 
arct.ada«=> (cannot interface to compiler) 
arct.ada sl.O.a 

arct.ada=> /usr/vads5/bin/ada sl.O.a -v > .arct.source/.arct.temp 
arct.ada=> (cannot interface to compiler) 
arct.ada s2.0.a 


UNCLASSIFIED 





UNCLASSIFIED 


112 


arct.ada=> /usr/vads5/bin/ada s2.0.a-v > .arct.source/.arct.temp 

arct.ada=> (cannot interface to compiler) 

csh -c echo Id pl.obj p2.obj main.obj sl.obj s2.obj -o main.exe 


This command also set 
ara^makefile 
to be the current 
make file for the unit 
main. 

When issued again, no output was produced. 

The first test involved editing units pi and p2, making additions to their bodies and produc¬ 
ing the following: 

Package PI (version 2): 

package pi is 

pragma change_type (”objects_n_types”,”07/08/88 17:21:24”); 

-object and type declarations; 

pragma change_type(”ildef”,”07/08/88 17:21:37”); 

function il return integer; 

pragma change_type (”i2def’,”07/08/8817:21:50”); 

function i2 return integer; 

pragma change_type (”body_n_procs”,”07/08/88 17:22:00”); 

-rest of procedures 

end pi; 

package body pi is 

function il return integer is 
begin 
return 0; 
end; 

function i2 return integer is 
begin 
return 0; 
end; 

procedure new_proc is 
-new procedure added here 

begin 

null; 

end; 
end pi; 


UNCLASSIFIED 





UNCLASSIFIED 


113 


Package P2 (version 2): 

package p2 is 

pragma change_type (”objects_n_ types”,”07/08/88 17:22:59”); 
-object and type declarations; 

pragma change_type (”body_n_procs”,”07/08/88 17:23:20”); 
-rest of procedures 

procedure p2_new_proc; 

end p2; 

package body p2 is 

procedure p2_new_proc is 

- externally visible new procedure inserted 

begin 

null; 

end; 
end p2; 


Issuing the command 

arct_jmake main 
produced the following results: 
arct.ada pl.l.a 

arct.ada=> /usr/vads5/bin/ada pl.l.a-v > .arct.source/.arct.temp 
arct.ada=> (cannot interface to compiler) 
arct.ada p2.1.a 

arct.ada=> /usr/vads5/bin/adap2.1.a-v > .arct.source/.arct .temp 

arct.ada=> (cannot interface to compiler) 

csh -c echo Id pl.obj p2.obj main.obj sl.obj s2.obj -o main.exe 


The second test involved modifying the objects_n_types section of pi so that all units but p2 
would need recompiling. 

Package PI (version 3): 

package pi is 

pragma change_type (”objects_n_types”,”07/08/8817:21:24”); 

-object and type declarations; 
type my_type is new integer; 

pragma change_type(”ilder,”07/08/88 17:21:37”); 


UNCLASSIFIED 





UNCLASSIFIED 


114 


function il return integer; 

pragma change.type (”i2def\”07/08/88 17:21:50”); • 

function i2 return integer; 

pragma change_type (”body_n_procs”,”07/08/88 17:22:00”); 

-rest of procedures 

• 

end pi; 

package body pi is 

function il return integer is 
begin 

return 0; • 

end; 

function i2 return integer is 
begin 
return 0; 
end; 

procedure new_proc is 
-new procedure added here 

begin 

null; 

end; ♦ 

end pi; 


Running arct_make performed as anticipated, producing the following output: 
arct.ada pl.2.a 

arct.ada=> /usr/vads5/bin/adapl.2.a-v > .arct.source/.arct.temp 
arct.ada*=> (cannot interface to compiler) 
arct.ada main.O.a 

arct.ada»> /usr/vads5/bin/ada main.O.a-v > .arct.source/.arct.temp 
arct.ada=> (cannot interface to compiler) 
arct.ada sl.O.a 

arct.ada«> /usr/vads5/bin/ada sl.O.a -v > .arct.source/.arct.temp 
arct.ada=> (cannot interface to compiler) 
arct.ada s2.0.a 

arct.ada=> /usr/vads5/bin/ada s2.0.a -v ^ .arct.source/.arct.temp 

arct.ada=> (cannot interface to compiler) 

csh -c echo Id pl.o'oj p2.obj main.obj sl.obj s2.obj -o main.exe 


The third test included changes to units si and s2: 


UNCLASSIFIED 






UNCLASSIFIED 


115 


Separate Procedure SI (version 2): 

separate (main); 
procedure si is 

-body of si 

-contains a call to il but no call to i2 

begin 

il; -actually change the source of si.a 

end si; 


Separate Procedure S2 (version 2): 

separate(main); 
procedure s2 is 

-body of s2 
-does not call il or i2 

begin 

null; -change s2 as well 

end s2; 


The following results were produced by arct_make: 
arct.ada sl.l.a 

arct.ada=> /usr/vads5/bin/ada sl.l.a-v > .arct.source/.arct.temp 
arct.ada=> (cannot interface to compiler) 
arct.ada s2.1.a 

arct.ada=> /usr/vads5/bin/ada s2.1.a -v > .arct.source/.arct.temp 

arct.ada=> (cannot interface to compiler) 

csh -c echo Id pl.obj p2.obj main.obj sl.obj s2.obj -o main.exe 


The final test consisted of changing unit 
Pi 

before the occurrence of the first 
CHANGE_TYPE 

pragma. This change should give rise to a 
“GENERAL” 

change, causing all units which depend on any part of 

Pi 

to need recompiling. 


UNCLASSIFIED 





UNCLASSIFIED 


116 


Package PI (version 4): 

package pi is 

type my_type2 is new integer; 

- by placing a type declaration before the first change_type 

- pragma, change type ’’GENERAL” will be signalled and will 

- force recompilation of all units depending on this one 

pragma change_type (”objects_n_types”,”07/08/88 17:21:24”); 

-object and type declarations; 
type my_type is new integer; 

pragma change_type(”ildef’,”07/08/88 17:21:37”); 

function il return integer; 

pragma change.type (”i2def”,”07/08/88 17:21:50”); 

function i2 return integer; 

pragma change.type (”body_ji_procs”,”07/08/88 17:22:00”); 
-rest of procedures 

end pi; 

package body pi is 

function il return integer is 
begin 
return 0; 
end; 

function i2 return integer is 
begin 
return 0; 
end; 

procedure new.proc is 
-new procedure added here 

begin 

null; 

end; 
end pi; 


The following output was produced: 


UNCLASSIFIED 



UNCLASSIFIED 


117 


arct.ada pl.3.a 

arct.ada=> /usr/vads5/bin/ada pl.3.a-v > .arct.source/.arct.temp 
arct.ada=> (cannot interface to compiler) 
arct.ada main.O.a 

arct.ada=> /usr/vads5/bin/ada main.O.a-v > .arct.source/.arct.temp 
arct.ada=> (cannot interface to compiler) 
arct.ada sl.l.a 

arct.ada=> /usr/vads5/bin/ada sl.l.a-v > .arct.source/.arct.temp 
arct.ada=> (cannot interface to compiler) 
arct.ada s2.1.a 

arct.ada=> /usr/vads5/bin/ada s2.1.a-v > .arct.source/.arct.temp 

arct.ada=> (cannot interface to compiler) 

csh -c echo Id pl.obj p2.obj main.obj sl.obj s2.obj -o main.exe 


UNCLASSIFIED 






UNCLASSIFIED 


118 


UNCLASSIFIED 








UNCLASSIFIED 


119 


> 


Appendix D: 

A New Reference Model for Change Propagation 
and Configuration Management in Software Systems 


Joseph L. Linn, Cathy Jo Linn, and Robert I. Winner 
I Institute for Defense Analyses 

Alexandria, Virginia 


Abstract: Change-Propagation/Configuration-Management tools for software 
development have the important task of ensuring that changes in source text are 
I correctly propagated to the modules used to construct executable versions of a 

software system while simultaneously attempting to minimize the amount of 
recompilation. In this paper, we present a simple method for modeling various 
changes in source modules and for controlling how these changes should be 
propagated by retranslation. Finally, a basic tool set is described based on 
these notions. 
t 


Introduction 

Ensuring that a (software) system has been constructed using the appropriate source 
modules is a troublesome problem in system development. Moreover, needless recompilation, 
retranslation, and relinking of modules significantly increases development time. Thus, a 
number of systems have been developed that try to reduce the amount of retranslation required; 
two that we will refer to in this paper are the Unix'* make utility [Feldman79] and the Odin sys¬ 
tem [Clemm84], 

These systems are reasonably successful in preventing needless retranslations; still, it is desir¬ 
able to reduce unneeded retranslation even further. This paper attempts to address the following 
two points: 


(a) module interdependencies and module changes may be captured at a very detailed level 
and these detailed characterizations used to reduce the amount of retranslation. 

(b) the discovery of how a module has changed (or, the “types” of module changes) from one 

* version of the source to another may be implemented efficiently. 

We begin with a discussion of basic terminology since the usage of terms here may not 
agree with intuitive usage. First, some of the modules created and manipulated during the 
development process are produced automatically by the invocation of a construction pro- 
I cedure 1 . For example, an object module is produced by the invocation of a compiler using 

appropriate high-level language modules as input. Modules that are created automatically by the 


" Unix is a Trademark of AT&T Bell Laboratories. 

1 By the construction procedure, we mean the sequence of steps that must be accomplished to produce a given 
module from the modules upon which it depends. A construction procedure could be as simple as invoking a single com¬ 
piler or linker; conversely, more complicated steps might also be included such as the invocation of preprocessors, crea¬ 
tion of libraries, the installation of overlay segments, placing modules in specific directories, downloading modules for 
execution on a remote target. The specification of the steps of these construction procedures is, at the lowest levels, 
necessarily dependent on the particular development environment; here, we assume that the construction procedure is 
simply text that is to be processed by the operating system. 


I 


UNCLASSIFIED 




UNCLASSIFIED 


120 


invocation of a construction procedure are called derived modules; modules that are not created 
automatically are called source modules. Note that programs represented in high-level 
languages are not necessarily source modules; a C program entered using an editor is a source 
module, but a C program created by a parser generator is a derived module. 

A source module is changed many times (typically by editing) during the course of its life; 
thus, a module name actually names a set of files rather than a single file. Each of the files in this 
set is called a version of the module. Also, any particular version v that is not an initial version 
has one or more previous versions (almost always, exactly one) that are edited to form v. Fol¬ 
lowing [Clemm84], we do not define a version relationship for derived module, that is, for 
derived modules, we do not define previous versions. How such a relationship might be defined 
and used is an open issue. 

Previously, we mentioned that a derived module was formed by invoking its construction 
procedure using appropriate modules, or more precisely, appropriate version of modules as 
input. Thus, the name of the derived module is related to the names of the input modules used 
in constructing the derived module. If <m,c> is an element of this relation (i.e. c is used to con¬ 
struct m), then m is called the dependent module and c is called a component module. A 
configuration of a particular module m is formed by binding each of the component modules of 
m to specific versions. A valid configuration is one where the versions are found by the con¬ 
sistent application of a version access policy 2 . 

The problem of ensuring that the configurations are valid while simultaneously minimizing 
retranslation has a number of interesting aspects, the most important of which are the following: 

(1) Module Interdependency and Change Control, 

(2) Version Management, and 

(3) Configuration Management. 

After discussing each of these aspects, the paper presents an example to demonstrate how these 
concepts interact in the development process. Next, the tools that were developed to discover 
specific types of changes and propagate them are discussed. Finally, our conclusions are 
presented. 


Module Interdependency and Change Control 


The important concept immediately at hand concerns the relation established from depen¬ 
dent modules to component modules. The key question is this: Given the state information (usu¬ 
ally the creation/modification timestamp) for the current version of the dependent module and 
the state information for the accessed version of each component module, how can one establish 
the need to construct a new version of the dependent module? For example, given that a particu¬ 
lar object module is formed by assembling a main program with two files containing library mac¬ 
ros, how can one determine that a changed macro library causes the object module to need 
reassembly? If the main program does not reference any of the macros that are changed, then 
no reassembly is necessary. Even if changed macros have been utilized, it may happen that the 
changes only affect internals of the operation and not the interface; thus, reassembly may still 
not be required. 

The key to avoiding needless module reconstruction is to capture both the exact nature of 
the dependency between the dependent module and the component module and also the exact 


2 Operating systems and tools provide a wide variety of mechanisms to search for modules. One example is shown 
in the search path mechanism of Multics and Unix whereby a user can specify a list of directories to be searched in order 
to find a particular executable module. Another important example is the method that most linkers employ to determine 
the appropriate search order of libraries used to satisfy undefined referenced symbols. A version access policy uses the 
search mechanisms available to cause specific versions of modules to be accessed. The configuration management system 
supports such policies by permitting parameterization of the search mechanisms via construction procedures. 


UNCLASSIFIED 





UNCLASSIFIED 


121 


nature of the change (if any) between the accessed version of the component module (usually the 
newer version) and the version of the component module used to construct the current version 
of the dependent module. The primary difference between the dependency/change model we 
propose and the model commonly in use derives from the precision in capturing the nature of the 
changes and dependencies 3 . One popular model (discussed later) treats all dependencies the 
same; additionally, all changes are treated identically. (In fact, the simplest model simply 
assumes the modules change each time they are reconstructed) While this has proven to be very 
effective for small- and medium-sized systems with fast compilation tools, it is not effective 
either for large codes or when the translation tools are slow. For example, the popular treatment 
of changes and dependencies can lead to massive recompilations of Ada® code when a low-level 
procedure of a frequently “with-and-use”-ed package is changed even if the change has no effect 
on the intermodule interfaces. The reference model we present can account for different types 
of changes and allow a development team far greater control over reconstruction than models 
that capture changes and dependencies with less precision. 

Version Management 

The reference model developed in this paper supports two additional concepts with respect 
to version mangement. The first of these is the concept of alternative versions, or alternatives. 
Now, each noninitial version of a module almost always has a unique previous version and each 
version of a module normally has at most one direct successor version. However, a version may 
have multiple versions that are direct successors; these are called alternatives. Alternatives typi¬ 
cally arise either from a need to customize a module for a particular environment or from the 
need for an alternative implementation strategy for module implementation. The other impor¬ 
tant notion is that of a revision level; these are also called rev-levels or simply revisions. A revi¬ 
sion is a version that is a component of a configuration that has been released from the develop¬ 
ment organization. These versions must be permanently maintained. Version management tools 
can be implemented relatively independently from tools for supporting change control and 
configuration management. However, our model does impose a few constraints on the version 
management system. These are detailed later in the paper. 

Configuration Management 

For configuration management, the reference model defines how the dependency and 
change control information is used to decide whether the associated construction procedure for 
the module is to be invoked. In addition, an implementation must assume responsibility for 
maintaining the version bindings for the module so that revision levels can be determined. The 
model does not (currently) prescribe any particular language for defining any of the structural 
information that must be maintained; however, examples are presented in terms of a specific, 
user-hostile, easily implemented interface language. 

An Example 

Before attempting to formally describe the information captured by the reference model, 
we first consider an example to demonstrate the various data that are needed. Consider the pro¬ 
gram skeleton shown in Figure-1. The figure depicts an Ada program consisting of a main 

3 Hie statement “the definition of type ‘stack_type’ in module A haj been modified” is clearly more precise than the 
statement “module A has been modified”. Similarly, the statement "module B depends on module A” is less precise than 
the statement “module B uses type ‘stack_type’ and procedures ‘push’ and ‘pop’ from module A”. The aim of this model 
is to represent the more precise statements as well as the less precise. 

® Ada is a Registered Trademark of the U.S. government - Ada Joint Program Office. 


UNCLASSIFIED 







UNCLASSIFIED 


122 



with pl,p2; use pl,p2; 
procedure main; 

object and type declarations; 

pragma inline(il), inline(i2); 
procedure sl(...); is separate; 
procedure s2(...); is separate; 

procedure code; 




Figure-1. 


procedure, two subprograms, and two packages. Each of these five components resides in a 
separate text file. Figure-2 depicts the relation that captures the intermodule dependencies; here, 
we are assuming that each of the source modules is to be compiled into an object module and 
that the object modules are linked into an executable image. Such a graphical depiction can 
become cluttered even for a small number of modules; thus, we will adopt the notation of 
Figure-3. This type of notation is used for describing the relationships to the make utility, first 
developed for the Unix system. Make gives the development team the means to describe not 
only the dependency relation among the modules but also the commands that are required to 
“make” the module. Indeed, the methods described in this paper should be viewed as evolving 
from the capabilities provided by make. 

Returning to the relation described in Figure-2 and Figure-3, one may observe that 
“main.exe” is dependent on the object modules and also that each object module is dependent 


UNCLASSIFIED 







UNCLASSIFIED 


123 



Figure-2. 


main.exe: pl.o p2.o main.o 
sl.o s2.o 

pl.o: pi.a 

p2.o: p2.a 

main.o: pl.a p2.a main.a 
sl.o: pl.a p2.a main.a si.a 
s2.o: pl.a p2.a main.a s2.a 


Figure-3. 

on the .a-module of the same name. It is not so obvious what is represented by the other depen¬ 
dency arcs. Let us first consider how “main.o” is dependent on “pl.a”. First, “main.o” is prob¬ 
ably dependent on the types defined in “pl.a”; likewise, if “main” references any of the vari¬ 
ables declared in “pi” then “main.o” is probably dependent on the variables declared as well. 
What is meant here by “probably dependent” is that a change in either the type or object 
declarations in “pl.a” will probably result in a different object module for “main” being pro¬ 
duced by the compiler. Last, if “main” uses function “pl.il” then “main.o” is dependent on the 


UNCLASSIFIED 




















UNCLASSIFIED 


124 


text that defines “pl.il” because “main” declares “pl.il” as “inline”. However, “main.o” is not 
dependent on the bodies of other procedures (besides “il” and “i2”) or on the package inititiali- 
zation code because the linker is most likely responsible for the final binding of the entry points 
to these codes. The dependencies between “main.o” and “p2.a” are similar. 

Since “si” and “s2” inherit the compilation environment of “main”, the dependencies 
explained above apply to “si” and “s2” as well as “main”. Of course, “si” and “s2” can also 
reference variables and types declared in “main”; thus “sl.o” and “s2.o” are dependent on 
“main.a”. All of these dependency rules derive directly from the Ada language. However, a 
development team may have additional knowledge about the dependencies. 

Now, we proceed to show how a system can make use of the dependency information to 
construct a valid configuration with a reduced need for recompliation. The way that make works 
is that it uses a two-step process for verifying that all dependencies are properly satisfied for each 
module, as follows. 

procedure make(M:module); 

without loss of generality 

assume <Dl..Dn> are the modules that M depends on; 

assume Construct(M) is the specified procedure to remake M; 

if M is a leaf then exit make; 

-step 1 

for D in <Dl..Dn> do make(D) endfor; 

-step 2 

for D in <Dl..Dn> do 

if modification_date(D)>modification_date(M) then 
Construct(M); 
exit make; 
endif; 

endfor; 

endwlg; 
end make; 

First, make recursively verifies that each component module is consistently constructed; a 
module that is a leaf in the dependency relation is consistent by definition. Next, it compares the 
creation/modification date of each component module to the creation/modification date of the 
dependent file. If it finds that one of the component files is younger than the dependent file, it 
“reconstructs” the dependent file using rules that the development team provides. The macro 
capabilities and the techniques that make provides for “guessing” how to make a module result 
in a utility that is very easy to use and very powerful. In the current example, a request to make 
“main.exe” after a change to “p2.a” would first result in remaking “p2.o”, “main.o”, “sl.o”, 
and “s2.o” and then a relinking. 

There are basically two problems with the approach that we have taken so far. The lesser of 
the two is that the dependency graph that we have come up with contains redundancy in that 
“sl.o” and “s2.o” are not really dependent on the packages directly; rather, the main procedure 
acts as an agent in propagating the dependency. In a large system where one has p packages and s 
subprograms, this will require the specification and maintenance of pxs edges. A possible solu¬ 
tion to this redundancy problem is to make “sl.o” and "s2.o” dependent on “main.o” rather 
than on “pl.a”, “p2.a”, and “main.a”; this is depicted in Figure-4 and Figure-5. Using this tech¬ 
nique, only p+s edges are needed. A drawback to the scheme of Figure-4 is that a recompilation 
of “sl.o” (for error checking, say) cannot occur without a recompilation of “main.o”. This 
might be problematic if the compilation of “main” is lengthy. The recompilation of “main” can 
be eliminated by the use of dummy files, i.e. by defining a trivial construction procedure for a file 


UNCLASSIFIED 





UNCLASSIFIED 


125 



Figure-4. 


main.exe: pl.o p2.o main.o 
sl.o s2.o 

pl.o: pl.a 

p2.o: p2.a 

main.o: pl.a p2.a main.a 
sl.o: main.o sl.a 
s2.o: main.o s2.a 


Figure-5. 

with the same components as “main.o”. Thus, except for the added complexity in specifying the 
relation, the redundancy problem can be handled by current techniques. 

The larger problem, the one mainly to be addressed here, is that relations of the sort that 
have been discussed do not capture the various types of dependencies that were discussed above. 
For example, a change in the package body part of “pl.a” is treated in exactly the same way as a 
change in the type declarations of “pl.a”. liiis effectively defeats the separate compilation facil¬ 
ities of the language in our example since any change in “pl.a” causes all of “pl.o”, “main.o”, 
“sl.o”, and “s2.o” to be reconstructed. What is needed is to change the way that we determine 
if a new construction is needed. After first presenting the process, we will then turn to the new 
bookkeeping requirements that arise from the process. 

procedure new_make(M:module_name); 
wig assume <Dl..Dn> are the names of the 


UNCLASSIFIED 















UNCLASSIFIED 


126 


modules that M depends on; 

assume Construct(M) is the specified procedure to remake M; 

if M is a leaf then exit new_make; 

for D in <Dl..Dn> do new_make(D) endfor; 

MM:= module resulting from the previous construction of M; 
for D in <Dl..Dn> do 

DV’:= version of D when MM was constructed; 

DV := current_version(D); 

if the changes from DV’ to DV are propagated along <M,D> then 
invoke Construct(M) to create MM’, the new configuration of M; 
make MM’ the current configured module of M; 
record which versions of each component module are used to 
create MM’; 
exit new_make; 

endif; 
endfor; 
endwlg; 

end new_make; 

There are a number of important differences between the earlier “make” procedure and the 
“new_make” procedure. First, note that we must now distinguish between module names and 
module versions; further, enough versions of modules must be saved so that the changes between 
relevant versions can be determined. Second, the versions used to construct particular 
configurations must now be maintained in order to determine which are the relevant versions; 
this, of course, is a requirement of configuration management systems that support revision lev¬ 
els. Last, arcs are now active parts of the process in that the specification of arcs must now 
specify which changes are not propagated. 

Figure-6 shows a specification for the relationship that takes into account these new ideas. 
The only difference is that some of the source modules are appended by a ” / change_.type-.list” 
specification. (One of the strengths of our model is that the set of change_types are 


main.exe: pl.o p2.o main.o 
sl.o s2.o 

pl.o: pl.a 

p2.o: p2.a 

main.o: main.a 

pi . a/ini t_code_n_procs 
p2 .a/initcode_n_procs 

sl.o: sl.amain.a/proccode_n_procs 
pl.a/initcode_n_procs,i2_def 
p2 .a/initcode_n_procs 

s2.o: s2.a main.a/proccode_n_procs 
pl.a/initcode_n_procs,il_def,i2_def 
p2.a/initcode_n_procs 


Figure-6. 


UNCLASSIFIED 





UNCLASSIFIED 


127 


user_defined; however, an example of a change_type used later in the paper is a 
“initcode_and_procs” change. A change of this type occurs in editing a package if the change 
involves either the initialization code or a procedure not expanded inline in any “with”-er of the 
package.) The changes in the change_type_list are the ones that do not propagate along the arc. 
Notice especially that the dependency from “sl.o” to “pl.a” does not propagate a change of 
type “i2_def”. Another item of note is that the redundancy is still present. The solution that we 
adopt is shown in Figure-7. “Mainpass” is introduced to eliminate the need for a dummy file as 
discussed previously. The interpretation of “mainpass” is that “mainpass” is a node in the graph 
that is not associated with any module; rather, any changes that flow into “mainpass” are pro¬ 
pagated onto its “output arcs” unless they are suppressed by the normal mechanism. Note that 
the “il_def” change_type is not propagated into “s2.o” from “mainpass”. Now we are posi¬ 
tioned to present a formalization of these concepts. 

The Reference Model 

A change control system consists of the following parts: 

(1) A set (possibly infinite) of possible change types (C). 

(2) A set of leaf module nodes(L). 

(3) A set of interior (non-leaf) module nodes (I). 

(4) A ^et of pass-thru nodes (P). N is defined as the set of all nodes, i.e. LuIuP. 

(5) E, the edges in the system, is a subset of NxNx{C—^Boolean}. E is restricted so that 
{<X,Y> | 3f:<X,Y,f> is in E} is a partial order. The interpretation of <X,Y,f>, here, is 
that (a) Y is a component module of X and (b) if (c is in C) and f(c) then c does not pro¬ 
pagate along <X,Y,f>. For example, <sl.o,mainpass,g> is an edge of the example in 
Figure-7, where g is given by 


g(x) = 


true if x=“i2_def’. 
false, otherwise. 


main.exe: pl.o p2.o main.o 
sl.o s2.o 

pl.o: pl.a 

p2.o: p2.a 

main.o: main.a 

pl.a/init_code_n_procs 
p2. a/initcode_n_procs 

mainpass: main.a/proccode_n_procs 
pi. a/initcode_n_proc s 
p2.a/initcode_n_procs 

sl.o: sl.amainpass/i2_def 

s2.o: s2.a mainpass/il_def,i2_def 


Figure-7. 


UNCLASSIFIED 







UNCLASSIFIED 


128 


Changes are propagated in the system according to the following (which is a restatement of the 
previous algorithm with the addition of pass-thru nodes and is couched in the language of the for¬ 
mal model): 

procedure new_make_with_passthrus(M:node); 

wig assume {<M,Dl,fl>,<M,D2,f2>,...<M,Dn,fn>} are the edges in the 
graph out-incident with M; 

assume Construct(M) is the specified procedure to remake M, 
if M is a module node; 

if M is a leaf then exit new_make; 

for <M,D,f> iriflj /<M,Dl,fl>,<M,D2,f2>,...<M,Dn,fh>} do 
new_make(D) 

endfor; 

MM:= module resulting from the previous construction of M; 

CHANGES:= {}; 

for <M,D,f> in {<M,Dl,fl>,<M,D2,f2>,...<M,Dn,fn>} do 
if D is a module node then 
DV’:= version of D when MM was constructed; 

DV:= current_version(D); 

CHANGES’:=changes from DV’ to DV; 
else -if D is a passthru node 

- point 2.2 

recover changes associated with M, calling the set CHANGES’; 

endif; 

CHANGES: 53 CHANGES union {c in CHANGES’ and f(c)}; 
if D is a module node and Changes^} then 

- point 1 

invoke Construct(M) to create MM’, the new configuration of M; 
make MM’ the current configured module of M; 
record which versions of each component module is used to 
create MM’; 
exit newjnake; 
endif; 

endfor; 

if M is a passthru node then 

- point 2.1 

record CHANGES associated with M; 

endif; 

endwlg; 
end new_make; 

There are two important considerations. The first is that the code is somewhat complicated by 
the fact that the loop where propagated changes are discovered is terminated as soon as possible 
in case of a module node (point 1). This is simply because there is no need to continue change 
propagation discovery if one knows that the construction procedure will have to be invoked any¬ 
way. The second consideration is that the process records the changes that propagate through a 
pass-thru node (point 2.1) and later recovers them (point 2.2). The algorithm goes not care 
whether this is done by global variables or by files; it could actually be done in persistent storage 
and cached. These details are to be determined by an implementor. 


UNCLASSIFIED 





UNCLASSIFIED 


129 


Change Propagation on Ada Text Modules 

In this section, we describe a tool set that can be used to implement the concepts of the 
reference model. Actually, three tools have been implemented: the version utility, the new_make 
utility, and the vedit utility. The job of version is simply to maintain two data structures relevant 
to the source modules under its control. One of the data structures contains the version history 
for all the files. Essentially, this just consists of keeping track of the parent module(s) for each 
module that is not an initial version. The second data structure maintains data for revisions, that 
is, it records each instance of one module having been used in the construction of another. Note 
that new_make provides this information whenever it constructs a new configuration of a 
module. This parent module information is provided by vedit for source modules, as explained 
below. The current version management software does not implement the idea of “fus deltas” as 
is used in the SCCS utility [Rochkind75] or the /?CS[Tichy82]. The RCS implementation of 
“separate deltas” seems most appropriate here since we are concerned with alternatives; a more 
sophisticated version server is planned that uses this i '.ea. 

New_make essentially implements the algorithm given previously. It maintains three data 
structures. One of these is the change control system, as modeled above. The format of the 
input used to describe the graph is as given in Figure-6 and Figure-7. Note that the user specifies 
which changes are not to be propagated; this method was chosen so that the user would not inad¬ 
vertantly suppress compilations. The most interesting idea here is how new_jnake discovers 
what changes should be generated; this is the topic of the next section. 

Another data structure maintained by newjmake is the mapping between a module name 
and the actual module represented by the current configuration. Importantly, this data is not 
maintained as part of the version management system; this is because several different projects 
may be using the same files. Suppose, for example, that a project was producing software to run 
on either a Macintosh or a SUN. It is likely that many of the files used in the two configurations 
would be alternatives of the same module. Thus, the current version depends on whether you 
are working on tne Macintosh version or the SUN version of the system. This idea is indepen¬ 
dent of the version utility. 

The last data structure maintained by new_make is the change cache. The idea here is that, 
since it may be very expensive to determine how a module changes from one version to another, 
the result of the change discovery procedure should be saved so that it can be used again. As 
one might expect, this results in a very large savings of time; however, it is not as fast as simply 
comparing the modification dates. 

The last of the three tools is vedit. Vedit is a very simple tool that essentially “wraps¬ 
around” the text editor for maintaining version information. It essentially implements the follow¬ 
ing pidgin code. 

procedure vedit(M:node); 

MV:- current_version(M); 

invoke the text-editor to create MV’, the new version of M; 
record MV as the parent of MV’ 
make MV’ the current version of M; 
end vedit; 

Note the similarity of this process to what is done in new_make. 

Discovering Change Types 

The most difficult aspect of the new model is that it requires a tool that can discover the 
type of change between versions of a module automatically (after an appropriate setup). Since 


UNCLASSIFIED 






UNCLASSIFIED 


130 


we are trying to develop something substantially less complex than an incremental compiler, use 
of the new model is predicated on the invention of an effective means of having the user instruct 
the system what types of changes have occurred. Our approach is to divide modules into two 
kinds: (a) Ada source modules, and (b) other modules. In the case of a module that is not an 
Ada source module, a change of type “general” (note that change_types are represented by text 
strings) is generated if the two files being compared are not identical. This is essentially the same 
technique as used in the Odin system. (One should note, however, that the Odin tool fragments 
work together to provide some of the benefits of the method below.) 

However, our system determines change_types Ada files by having the user conceptually 
partition the source modules into linear regions as shown in Figure-8. An inspection of the parti¬ 
tioning depicted in Figure-8 reveals that a different change_type may be associated with each of 



package pi; 


r 

object and type declarations; 

L 


function il(...); ... end il; 


function i2(...); ..endi2; 


other procedures, functions, 
and the package initialization 


end pi; 

with pl,p2; use pl,p2; 
procedure main; 


object and type declarations; 


pragma inline(il), inline(i2); 
procedure sl(...); is separate; 
procedure s2(...); is separate; 


procedure code; 



end main; 


package p2; 


object and type declarations; 


procedures, functions, 
and the package initialization; 


end p2; 

separate(main); 
procedure sl(...); 


includes a call to il but 
no call to i2; 


end si; 

separate(main); 
procedure s2(...); 


includes calls to neither 
il nori2; 


end s2; 


Figure-8. 


UNCLASSIFIED 




















UNCLASSIFIED 


131 


these linear regions. Thus, after the user has made his partitioning, there are two remaining 
issues: (1) How are these regions communicated to new^makel and (2) Exactly how does this the 
system use these regions to determine change_types? 

The answer to the first question may be obtained by inspecting Figure-9: this is how the file 
would look after the user has delineated the regions in the source text. An Ada “pragma” is 
used to indicate the regions. (In Ada, a pragma is like a compiler directive; Ada compilers are 
supposed to ignore pragmas that they don’t understand). As can be seen, the “change_type” 
pragma has two parameters. The first of these is a change_type, the second is an arbitrary string 
that can be used for disambiguating pragma references. 

The system “discovers” change_types, then, according to the following two-step process. 
First, it reads the two files to be considered and finds all of the “change_type” pragmas in both 
files. If the sequence of “change_type” pragmas is identical (that is, they have identical parame¬ 
ters), then the system can proceed to the second step; otherwise, the change_type set discovered 
is {“general”}. In the second step, the system compares the text following each “change_type” 
pragma to the corresponding text for the other file. If the text is not identical, then the 
change_type indicated in the first of the pragma parameters is added to the set of change_types 
discovered. In this comparison, the text occurring before the first “change_type” pragma is con¬ 
sidered to be preceded by ‘pragma change_type(“general”,“”);’. 

As an example, suppose that during an edit session the package body and the body of func¬ 
tion il were changed. The above process would generate {“initcode_n_procs”,“il_def”} as the 
change set. As a last observation, the above process can actually be implemented as a single 
pass. In fact, it can be based on a two-tape finite state machine; thus, it takes only a little longer 
than simply reading the files. 


package pi; 

r 

pragma change_tvpe 

(“objects_n_types”,“061186 430P”); 

object and type declarations; 

pragma change_type 

(“il_def’,“061186 430P”); 

function il(...);... end il; 

pragma change_type 

(“i2_def’,“061186 430P”); 

function i2(...);... end i2; 

r 

pragma change_type 

(“initcode_n_procs”,“061186 430P”); 

other procedures, functions, 
and the package initialization; 

v_ 

end pi; 


Figure-9. 


UNCLASSIFIED 







UNCLASSIFIED 


132 


Conclusions 

In this paper, we have presented a new model for change propagation and configuration 
management that allow the innovative concepts of the Unix make utility to be extended to give 
the user more control over the compilation process. It requires that the user create a file of 
essentially the same complexity as a “makefile” and that certain “marks” be placed into source 
files so that change.types can be readily identified. Although the presentation is directed 
towards change propagation discovery for Ada text modules, the concepts apply readily to other 
languages as long as the language processor accepts some form of comment. Moreover, the 
scope of the reference model is not limited to the software domain; its applicability to hardware, 
firmware, officeware (i.e. text-processing) is only limited by a system designer’s ability to build 
change_type discovery procedures. Nor is it limited by the granularity of the tool fragments; it 
can be made to work as well for monolithic translators as for translators that each do a small 
piece of the work. 

These points are especially important in light of a rather parochial view of Ada program 
development, that is, that the compiler should be responsible for maintaining the dependencies 
and (since this is an Ada requirement) that the model presented here doesn’t apply. First, while 
Ada compilers do propagate changes among the constiuent modules of a program, the model 
used almost universally is the single change_type model. Since the vendors of Ada compilers are 
also trying to field a product substantially less complex than an incremental Ada compiler, this 
situation is unlikely to change. Second, not all programs eventually compiled by an Ada com¬ 
piler will be coded in Ada; it is highly likely that Ada will often be used as an execution platform 
(i.e. as a intermediate language) in the same way that C is used in the Unix system, e.g. by yacc 
and lex. It is difficult to see how the Ada compiler is going to track changes in non-Ada pro¬ 
grams! 

Nevertheless, important integrated implementations of change control and propagation 
have appeared, notably the CHILL Compiling System [Rudmik82]. The CCS maintains a 
cross-reference between the modules in a system and the program units (i.e. variables, types, 
subprograms) that each module references. In this way, the CCS can capture changes at a lower 
level than the module level. Two key advantages of such a system are (1) that change discovery 
and propagation occur without any user intervention, and (2) that the system automatically 
tracks all program units rather than just the ones that are deemed important by the development 
team. Thus, there is no chance that the development team can define incorrect interdepency 
and change propagation information. The primary disadvantage of the CCS method (as com¬ 
pared with the technique proposed here) is that the CCS method requires a closely integrated, 
sophisticated compilation system whereas our system can be used with completely uncoupled 
toolsets. Importantly, the two techniques are complementary; our method does not preclude the 
use of integrated tool sets and is increasingly attractive as the degree of tool integration 
decreases. 

Finally, one should note that the reference model presented is truly a generalization of 
“makefiles” in that “makefiles” translate directly into the structural specifications of the new 
model. Further, if no “change_type” pragmas are included in a source file, all changes will be 
propagated as general changes, just as in the make model. Of course, make will process the 
structure much faster for these cases since its change_type discovery procedure is so much 
simpler. Also, our current implementation does not nearly compare with make in terms of ease 
of use since moke-style rule-processing is not supported. Further, the concept of actually com¬ 
paring the files to discover changes came to our project via the ODIN system. Also, the ODIN 
system concept of using small granularity tool fragments makes it possible to automatically 
obtain propagation restrictions that our system would have to obtain from the user. We hope to 
extend our system to use rule processing as in make to obtain these specifications automatically 
for tool sets with this small granularity approach. The combination of rule processing and 
greater user control would decrease the effort of using the system. 


UNCLASSIFIED 










UNCLASSIFIED 


133 


References 

The following papers contain information relevant to the topics in the paper. 

[Ada83] Ada Language Reference Manual, January, 1983. 

[Clemm84] G.M. Clemm, “ODIN - An Extensible Software Environment”, University 

of Colorado, Dept, of Computer Science Technical Report CU-CS-262-84,1984. 

[Feldman79] S.I. Feldman “Make - A Program for Maintaining Computer Programs”, 

Unix Programmer’s Manual, Seventh Edition, Volume 2A, January, 1979. 

[Katz86] R.H. Katz, M. Anwarrudin, and E. Chang “A Version Server for Computer- 

Aided Design Data”, Proceedings of the Twenty-third Annual IEEE/ACM Design Automation 
Conference, Las Vegas, Nevada, June/July, 1986, pp. 27-33. 

[Linn86] J.L. Linn and R.I. Winner, editors. The Department for Defense Requirements 

for Engineering Information Systems, Volume 1: Operation Concepts, DRAFT, July 3,1986. 

[Rochkind75] M.J. Rochkind “The Source Code Control System”, IEEE Transactions 

on Software Engineering, SE-1(4), pp. 364-370, December, 1975. 

[Rudmik82] A. Rudmik and B.G. Moore “An Efficient Compilation Strategy for Very 

Large Programs”, Proceedings of the SIGPLAN '82 Symposium on Compiler Construction, 
pp.301-307, Boston, Massachusetts, June, 1982. 

[Tichy82] W.J. Tichy “Design, Implementation, and Evaluation of a Revision Control 

System”, Proceedings of the Sixth International Conference on Software Engineering, pp.58-67, 
Tokyo, Japan, September, 1982. 


UNCLASSIFIED 





UNCLASSIFIED 


134 


UNCLASSIFIED 








Proposed Distribution List for IDA Paper P-2099 
NAME AND ADDRESS NUMBER OF COPIES 

Sponsor 

Dr. John F. Kramer 5 

Program Manager 

STARS 

DARPA/ISTO 
1400 Wilson Blvd. 

Arlington, VA 22209-2308 

Other 

Defense Technical Information Center 2 

Cameron Station 
Alexandria, VA 22314 

Mr. Steve H. Edwards 1 

372 Jones Tower 
101 Curl Drive 
Columbus, OH 43210 

IDA 


General W.Y. Smith, HQ 1 

Mr. Philip L. Major, HQ 1 

Dr. Robert E. Roberts, HO 1 

Ms. Katydean Price, CSED 1 

Dr. Robert I. Winner, CSED 1 

IDA Control & Distribution Vault 2 


Distribution List-1 




