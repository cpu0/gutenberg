s 


NAVAL POSTGRADUATE SCHOOL 
Monterey, California 



k 


I 


ivn-A257 ^•SO 


THESIS 




VERSION AND VARIATION CONTROL OF A 
DESIGN DATABASE FOR A 
COMPUTER AIDED PROTOTYPING SYSTEM 

by 

Michael Dennis O’Loughlin 
June 18,1992 

Thesis Advisor: Dr. Lqui 

Co-Advisor: Dr. Williamson 


i 


Approved for public release; distribution is unlimited. 





security classification of This PAGE 




REPORT DOCUMENTATION PAGE 


UNCLASSIRED 



Computer Science Dept. 
Naval Postgraduate School 


IdC. ADDRESS (City. State, and ZIP Code) 

Monterey, CA 93943-5000 


7b. ADDRESS (City. State, and ZIP Code) 

Monterey, CA 93943-5000 




ORGANIZATION 

National Science Foundation 


8c. ADDRESS (City. State, ana ZIP Code) 

Washington, D.C. 20550 



■raK«ItlsW:««iaailJWIi?MKMWSMa;M 



11. TITLE (Include Secunty Classification) 

VARLATION AND VERSION CONTROL OF A DESIGN DATABASE FOR A CAP SYSTEM (U) 



14 DATE OF REPORT (Year. Month. Day) 

June 1992 


ir^tiiiaaiaaiagirjifjgMQgwurf 


e views expressed in this thesis are those of the author and do not reflect the otfici 
policy or position of the Department of Defense or the United States Government 


COSATI CODES 


GROUP 


SUB-GROUP 


18. SUBJECT TERMS (Continue on reverse if necessary and laentify by block number) 

Key Terms describing Your Work 


19 ABSTRACT /Continue on reverse if necessary and identify by block number) 

The Computer Aided Prototyping System(CAPS) was created for rapidly prototyping real-time systems to deter¬ 
mine early in the software development life cycle wether system requirements can be met. The CAPS consists of sev¬ 
eral software tools that automatically generate an executable Ada model of the proposed system. This thesis describes 
the development of a design database (DDB) for CAPS. The DDB is an engineering database that contains all the 
information related to a software prototype design. The DDB enhances the CAPS environment and the prototyping 
model by providing to the designer the capability to store, retrieve, view, edit, and control variation and versioning 
of the prototype components. This thesis describes the design, test and implementation of a tree structure variation 
and version control method for supporting CAPS. 






[3 UNCLASSIFIED UNLIMITED □ SAME AS RPT Q DTIC USERS UNCLASSIFIED 


22b TELEPHONEJInc/ude Area Code) 

i (408) 646-2735 




DD FORM 1473, 54 MA= 


83 APR edition may be used until exhausted 
All other editions are obsolete 


SECURITY CLASSIFICATION OF THIS PAGE 

UNCLASSIFIED 


1 





























Approved for public release; distribution is unlimited 


VERSION AND VARIATION CONTROL OF A 
DESIGN DATABASE FOR A 
COMPUTER AIDED PROTOTYPING SYSTEM 


Michael Dennis O’Loughlin 
Captain, Umted States Manne Corps 
B.S., Kean College of New Jersey, 1983 


Submitted in partial fulfillment of the 
requirements for the degree of 


MASTER OF COMPUTER SCIENCE 


Author: 


from the 


NAVAL POSTGRADUATE SCHOOL 
June 1992 

1 

' 1 

A /< 


4i 





Su; 


<44 



Michael Dennis O'Louchli 


Approved By: 





Robert B. McGhee, Chairman, 
Department of Computer Science 


» 


4 


11 



ABSTRACT 



» 


Tl:* Computer Aided Prototyping System (CAPS) was created for rapidly protot>'ping real¬ 
time systems to determine early in the software development life cycle wether system require¬ 
ments can be met. The CAPS consists of several software tools that automatically generate an 
executable Ada model of the proposed system. This thesis describes the development of a Design 
Database (DDB) for the CAPS. The DDB is an engineering database that contains all information 
related to a software prototype design. The DDB enhances the CAPS environment and the proto¬ 
typing model by providing to the designer the capability to store, retrieve, view and control varia¬ 
tion and versioning of the protot>q^e components. This thesis describes the design, test and 
implemeritation of a tree structure variation and version control method for supporting CAPS. 


Accesion For 

NTIS CRA&I 
DTIC TAB 
Unannounced O 
Justification 


By. 

Distiibution/ 


Availability Codes 



Avail and / or 

Dist 

Special 

A-/ 




I 


"wnr or- 


I 


in 








THESIS DISCLAIMER 


Trademarks 

ONTOS is a trademark of Ontologic, Inc. 





TABLE OF CONTENTS 


INTRODUCTION.1 

A. THE NEED FOR A DESIGN DATABASE.1 

B. THE HISTORICAL TRAIL.2 

C. THE OBJECT ORIENTED APPROACH.2 

D. THEORY OF THE DESIGN DATABASE.4 

BACKGROUND.6 

A. COMPUTER AIDED PROTOTYPING SYSTEM.6 

B. THE ROLE OF THE DESIGN DATABASE IN 

RAPID PROTOTYPING.10 

1. Classes in the Database Design.10 

a. Protots'pe.10 

b. Versioned Object.10 

c. Thread.15 

d. Configuration.16 

e. Component.16 

f. Text Object.17 

2. Connections Between Classes.17 

C. OTHER ATTEMPTS AT ENGINEERING 

DESIGN DATABASES.18 

IMPLEMENTATION OF A DESIGN DATABASE FOR CAPS. 20 

A. OBJECTIVES.20 

B. METHODOLOGY.22 

C. DESIGN DECISIONS AND JUSTIRCATIONS.23 

1. Database Schema.23 

2. New Versions and New Variations.27 



























3. History Trail.29 

4. Objects in the Working Directory and the 

Concerns of the Design Database.29 

5. Viewing and Editing Objects in the Working Directory.31 

6. Dangerous Obsolete Code.33 

D. TESTING AND TEST RESULTS.33 

IV. RECOMMENDATIONS AND CONCLUSIONS.35 

A. SUMMARY.35 

B. RECOMMENDATIONS FOR FUTURE WORK.35 

APPENDIX A.37 

A. ENTITY-RELATIONSHIP (ER) SCHEMA DIAGRAM.37 

B. DATABASE SCHEMA.38 

APPENDIX B.39 

A. PROTOTYPE COMMANDS.39 

B. CONFIGURATION COMMANDS.40 

C. VERSIONTD COMPONENT COMMANDS.42 

APPENDIX C.44 

A. TEST SCRIPT FILE.44 

B. EXAMPLES WITH CAPS SCREEN DUMPS.55 

C. TEST SHELL SCRIPT.63 

APPENDIX D.69 

A. SOURCE CODE.69 

LIST OF REFERENCES.331 

INITIAL DISTRIBUTION LIST.333 



























ACKNOWLEDGMENTS 


Debbie, Connor and Shavonne: 

For helping me get by the rough times and putting up with my long hours and 
absences. Debbie who kept telling me “I know you will finish." and Connor and Shavonne 
who were still willing to play with me no matter how bad a mood 1 was in. 

Loretta O’Loughlin: 

In the summer of 1970, my mother gave me one of her talks which was suppose to 
prepare me for the future. I will never forget the guidance she gave me that day. She said, 
“Mike, you know now that you are going into high school, it is not going to be like grammar 
school. They w ill offer a lot of different classes for you to take. If they ever offer a class 
about computers, 1 think you should take it. I think computers are going to be important 
someday." 

Professor Williamson: 

Your questions made me better understand what was going on. 

Professor Luqi: 

For the opportunity to do something big. 






I. INTRODUCTION 


A. THE NEED FOR A DESIGN DATABASE. 

“The development of hard real-time and embedded software systems is an extremely 
complex and expensive process... Vast amounts of evolving data are created in the design 
of hard real-time systems” [Ref. l:p. 1]. Management of this data is critical in computer 
aided design (CAD) environments (Ref. 2;p. 261]. There is a requirement for a database 
management system (DBMS) to be developed to meet the needs of systems being 
developed in C.AD environments. Conventional DBMS's were designed for business 
applications and made available only the current value of the records stored in the database. 
The qualities of the currently available DBMS's do not meet the requirements of design 
engineers working in CAD environments. CAD systems require that the objects be stored 
and retrieved according to the needs of the design engineer. These objects must closely 
model the real world object they describe. The design of a system evolves over time, 
requiring the DBMS used in conjunction with CAD tools to store design data as it is viewed 
at different time periods during the system life cycle. TTiis important feature which is a 
requirement of a design application is not available in commercial database management 
system (CDBMS). 

Because the DBMS requirements of a design application are different from those of a 
business application, a new approach must be taken to meet the DBMS requirements 
supporting design applicant ns. Though many CAD organizations have tried to integrate 
commercially available DBMS while developing their projects, they have found “that some 
of the important features which are required in the design application are not available in 
CDBMS” [Ref. 2:pp. 261-262]. Various solutions have been proposed to rectify the 
CDBMS problems of handling CAD databases. Berzins and Ketabchi [Ref. 3;p. 94] list 
four proposed solutions to the problem. 


1 





1. Develope a new DBMS, called a design DBMS (DDBMS), equipped with 
facilities required in the design application. 

2. Enhance the current DBMS by adding new capabilities. 

3. Build a layer of software on top of current DBMS’s to compensate for their 
deficiencies. 

4. Use a special purpose file manager that views the DBMS as a design 
application. 

Of the four approaches listed by Berzins and Ketabchi the first is the approach selected 
for the creation of a design database for the Computer Aided Prototyping System (CAPS). 
As Berzins and Ketabchi [Ref 2:p. 262] state “We have chosen to pursue this approach 
because we believe that the enhancements of CDBMS required in the second approach are 
too e.Ktensive to make this approach feasible, and that the third approach can not meet the 
flexibility and efficiency desired in CAD environments.” 

B. THE HISTORICAL TRAIL. 

During the evolution steps executed on the objects of the DDB. a historical trail will 
be maintained so the design and decision histor>’ of the system being developed will be 
recorded. 

The design history consists of the relationship between each version of the 
requirements and the corresponding version of the parts of the prototype [Ref 4;p. 17]. This 
type of information will be useful when a decision is made to return to a previous version 
of the project. TTie historical trail will provide the information necessary to restore the 
corresponding parts of the prototype to the previous configuration. 

C. THE OBJECT ORIENTED APPROACH. 

The need for a design database, as stated in section A, is the inherent difference 
between the DBMS requirements of a design application and those of business 
applications. The object oriented approach is “based on object oriented data models rather 
then record oriented data models...The object oriented data model (ODM) will increase the 





productivity of the design systems by providing modeling facilities which mirror the 
designs logical view of the data” [Ref. 2:p. 261]. 

There are three basic parts of an ODM: 

1. Object: convenient aggregations of information describing real world objects. 

2. Properties: functions which model characteristics of objects and relationships 
among them. 

3. Operations: Change the state of an object, enforce constraints and provide an 
application oriented interface to the database [Ref. 2:p. 261]. 

The development of object oriented technology (object oriented languages, object 
oriented programs and object oriented data models) has allowed designers to develop 
DDBMS meeting the requirements of design applications. This object oriented approach 
allow s the use of off the shelf Objected Oriented DBMS w hich can be further developed to 
possess the enhanced capabilities needed for design applications. 

Object oriented database management systems (OODBMS) provide several features 
not available in other database types. Tw'o of the major advantages of an OODBMS are the 
increased modeling power and the ability to closely align and store CAD objects to reflect 
real-world relationships. This supports the definition of a design database as defined by 
Katz [Ref. 5:p. 379], “a (large) collection of objects that together describe an anifact being 
designed... ‘Objects’ are usually packages of data and manipulation procedures.” The term 
object as used by Katz, contains the three parts of the ODM listed above. 

Over the past several yea’s, several OODBMS have been developed. The impact of 
these systems on the software development process are just being felt. The object oriented 
approach represents a true paradigm shift [Ref. 6:p. 386]. 

In laying out the conceptional design of the design database Douglas [Ref. 1 :p. 8] 
clearly states what the OODBMS must provide. 

“An object-oriented database management system OODBMS) must provide 
persistence, concurrency, recovery, transaction management, authorization, and security. 
An OODBMS is an objected-oriented system and as such it must also provide the following 
capabilities: 


3 



- Objects 

- Active data 

- Abstraction 

- Extensibility 

An OODBMS should provide application_oriented capabilities such as: 

- Version and configuration control for CAD applications. 

- Dynamic creation of classes. 

- Recursive classes, multiple inheritance, and extensive tool interface capabilities. 

- Support for multimedia objects, distributed environments, and graphs. 

An object-oriented DBMS is one that suppons persistency, values, an extensible set of 
data structures, an extensible set of operations, and abstractions.” 

D. THEORY OF THE DESIGN DATABASE. 

The purpose of a design database (DDB) is the management of system project data, so 
that the system components can be stored and retrieved according to the needs of the design 
engineers. 

The DDB is an independent softw are system in its ow-n right. It is capable of being a 
stand alone system which can manage the design data of any system under development. 
In the context of this thesis, the DDB is a tool contained within CAPS and supports the 
prototype systems being designed by CAPS. Although the DDB supports all the prototype 
systems being designed by CAPS “there will be only one instance of the design database 
for each project” [Ref. 1 :p. 14]. For example, each design engineer will feel that the system 
they are working on has it own design database to manage the design data of their system. 

The physical location of the data w ill be a concern of the actual database management 
system. The design database being developed uses the ONTOS Object Database. ONTOS, 
a distributed object database management system, decides where to physically store the 
data [Ref. 1 l:p. 3] and makes access to the design data transparent to the user. 

The DDB manages the design data by manipulating collections of design data 
identified as nodes. Within CAPS, a node is made up of PSDL text, Ada source code, 
graphic representation data and a postscript representation of the node. The PSDL text is 
separated into specification and implementation components. 

The DDB is a hierarchial storage structure of nodes. Each node represents a different 
component. This hierarchial structure is a tree structure consisting of atomic and composite 


4 




nodes. “Each level of the tree is created by the decomposition of the parent node. The 
decomposition process is complete when all leaf nodes are atomic" [Ref. i:p. 19]. 

The nodes of a DDE are time sensitive. The nodes will version and create new 
variations depending when they are accepted into the design database. This topic will be 
discussed further in chapter two, section two. 

The design database is accessible to the user through a highly developed user interface 
or a low level command line interface. Since the commands issued to the DDE wiU have 
the same effect no matter which platform they are issued from, the DDE is independent of 
the interface used for accessing the design data. 

The major functions of the DDE within CAPS are: 

1. Store the levels of a PSDL program in a hierarchial format by specification. 

2. Retrieve the levels of a PSDL program in a hierarchial format by specification 

for review or editing. 

3. Create and insert new levels of a PSDL program in a hierarchial format by 

specification. 

4. Generate the entire PSDL program [Ref.Lp. 26]. 

Douglas [Ref l:p. 27] gives an excellent example describing the process in which the 
four listed functions must work. 

“To construct a protot>'pe, the PSDL specification of the root operator is entered. 
At this point the DDE would create a root node. Assuming the root node is composite, the 
node would decompose into children operators. The DDE would create child nodes for 
each decomposition. The decomposition would continue until all leaf nodes are atomic... 
the functions of retrieving nodes, parent-child relationships, and deleting nodes will be 
required. The tree will be traversed and the entire PSDL program produced once all leaf 
nodes are atomic.” 


0 


5 





n. BACKGROUND 


A. COMPUTER AffiED PROTOTYPING SYSTEM. 

Thic Computer Aided Prototyping System (CAPS) is a collection of computer-aided 
software tools designed to support prototyping of complex software systems, such as 
control systems with hard real time constraints. Prototyping can be carried out manually, 
but because of the cost in time and effort, manual prototyping produces limited benefits. 
The aim of CAPS is to strengthen the prototyping strategy by allowing the system designer 
to develop and modify the prototype automatically to meet the changing requirements of 
the user. The prototy'pe goes through an evolutionaiy process as do all software systems. 
As the system proceeds through its evolutionary steps, the tools provided by CAPS will aid 
the designer in modifying the protot\-pe to meet new requirements established by the user. 

The main components of CAPS are a special prototj-ping language and a set of 
software tools [Ref 4:pp. 14-15], Figure 1. 



Figure 1. Computer Aided Prototyping System Tools. 


The main components of CAPS are the three tool subsystems: The User Interface, 
Software Database System and the Execution Support System. The special prototjTJing 


6 






language that allows communication between the tools is the Prototype System Description 
Language (PSDL). PSDL integrates the tools and provides the designer with a uniform 
conceptual frame work and a high level description of the system [Ref. 4:p. 15]. PSDL 
enhances the power of the designer to modify the protot>T)e by providing the following 
capabilities: 

- Modularity 

- Adaptability 

- Abstraction 

- Requirements tracing 

The User Interface is composed of five software tools which provide the designer w ith 
the ability to enter requirements and design information, display the results of a prototype 
execution, select the different prototype capabilities to demonstrate, and propagate changes 
throughout the prototype. The user interface contains the: 

- Syntax Directed Editor 

- Graphic Editor 

•• Expert System 

- Debugger 

- Browser 

The syntax directed editor allows for the entry and modification of syntactically 
correct PSDL code. TTie designer will use the syntax directed editor to edit the PSDL code 
generated by the graphic editor, and enter PSDL descriptions and text of prototype design. 
The text portions of the prototype are not represented in the graphic editor. PSDL files are 
identified by the suffixes “.spec.psdl” and “.imp.psdl”. 

The graphic editor supports a graphic view of the prototype. It allows the designer to 
design an augmented data flow diagram of the prototype under development. The graphic 
objects displayed in the editor represent PSDL descriptions of the prototype. Skeletal PSDL 
code will be generated from the data flow diagrams designed using the graphic editor. The 
graphic editor generates files with “.spec.psdl”, “.imp.psdl”, “.ps” and “.graph” suffixes. 


7 





The expert system gives the user, who is unfamiliar with PSDL, the capability to 
examine the prototype by generating english text from PSDL. 

The browser allows the designer to view and retrieve the reusable PSDL and Ada 
components from the software database. * 

The debugger allows the designer to interact with the execution support system. From 
the debugger the designer can execute the protot>'pe, display results and gather statistics ^ 

about a prototypes behavior and performance. The debugger contains tw o components; a 
debugger for the static scheduler and one for the dynamic scheduler. The static scheduler 
debugger processes errors while attempting to create a static schedule and the dynamic 
debugger processes errors that occur while the prototype is executing. 

The Software Database System contains four software tools. 

- the Design Database 

- the Software Base 

- the Software Design Management System 

- the Rewrite Subsystem 

The system is structured to allow for the reuse of prototype designs and reusable 
softw are components during the development of the prototype. Reuse is the key motivation 
for the software database system. The benefits of reusing software include: 

- improved software quality and maintenance 

- increased programmer productivity and efficiency 

- lower development costs [Ref. 7:p. 94] 

The requirements established for the software database system provide for the 
following capabilities: 

- to store PSDL designs and software components 

- to retrieve designs and software components for editing 

- the CAPS user interface should integrate with the software database system in 
such a way that the software database management system is transparent to the prototype 
designer [Ref. 7;p. 97]. 


8 





The design database is a repository for the different variations and versions of PSDL 
prototype descriptions for all software projects developed using CAPS. Each protot>pe 
being developed under CAPS will appear to have its have its own design database. 

The software base contains PSDL descriptions and Ada source code for all reusable 
software components. 

The software design management system maintains the prototype design history. This 
system is used to locate reusable software components from the software base and retrieve 
the versioned system prototypes from the design database. 

The Execution Support System is made up of three tools; 

- the Translator 

- the Static Scheduler 

- the Dynamic Scheduler 

The translator generates high level code from the PSDL prototype which binds the 
reusable components from the software base to the executable prototype [Ref. 4:p. 17]. The 
translator will generate Ada source code. The Ada source code files generated will be 
identified by a “.a” suffix. The purpose of the translator is to produce an Ada translation of 
a PSDL prototype description. The translator performs lexical analysis of the internal 
textual representation of a PSDL system prototype, parses the prototype description and 
constructs an abstract syntax tree. After evaluating the tree attributes, it then constructs Ada 
source code utilizing PSDL abstract data types. 

The static scheduler schedules time constraints that are assigned to PSDL operations 
to ensure that all time constraints are met during execution. 

The purpose of the dynamic scheduler is to coordinate the execution of operators and 
their debuggers during execution. 


9 




B. THE ROLE OF THE DESIGN DATABASE IN RAPID PROTOTYPING. 


The CAPS Design Database is constructed of C++ and ONTOS classes. Each class 
serves a separate and unique function in the prototyping process. This section explains the 
concepts associated with each class and how they relate to the protot>ping process. 

1. Classes in the Database Design. 

a. Prototype. 

The term prototype used in this thesis denotes “a complete executable model 
of selected aspects of a proposed system [Ref. 4:p. 13].” 

A prototv-pe is the highest level class of the design databa.se. Systems under 
development in CAPS cannot be stored in the design database unless a prototype name has 
been entered into the database under which the system will be stored. A protot>’pe can 
consist of numerous versions of a system under development. Each version of the system 
can be a “complete executable model” or a panially developed system that was identified 
as not worthy of funher development. An instance of a prototype class represents all the 
versions being developed under that particular prototype name. 

b. Versioned Object. 

“An object is a software component that is subject to change... A version is 
an immutable snapshot of an object. Versions have unique identifiers. New versions can be 
created but versions cannot be modified after they are created [Ref. 8;p. 917].” A versioned 
object can be composite or atomic. A composite object can be decomposed into two or 
more objects. An atomic object cannot be decomposed into other objects. 

When an object, either atomic or composite, is inserted into the design 
database initially, it is assigned the control number sequence “variation 1, version 1”. 

Each object inserted into the database will be assigned a version number. The 
version numbers will be assigned sequentially as the object evolves from one version to the 
next. The exception to this is when a new variation is created. Since versioning is sequential 


10 






I 


a new variation is created when a versioned object can not version using the next number 
in the sequence. For example, if variation 1, version 3 of object A is modified but variation 
1, version 4 of object A already exists, a new variation will be created. The variation 
number is also assigned sequentially. If the highest variation number assigned is 1, then 
variation 2, version 1 will be assigned to the new object A. 

Figure 2 gives an example of an atomic and a composite object The 
composite object Operator_B decomposes into the atomic objects C)p_Bl, C)p_B2 and 
Op_B3. 



The initial insertion of the objects to the DDB will result in the following 
control number sequence assignments: 

Operator_A Variation 1, Version 1 

Operator^B Variation 1, Version 1 

C)p_Bl Variation 1, Version 1 

C)p_B2 Variation 1, Version 1 

Op_B3 Variation 1, Version 1 


11 









These numbers are a part of an object's properties and determine its 
uniqueness forever. Each versioned object is considered to be created once it has been 
inserted into the DDE. Once created an versioned object cannot be modified. Therefore, for 
each subsequent retrieval of any versioned object, the designer will only receive a copy of 
the versioned object contained in the DDE. If the designer modifies his copy of the 
versioned object, the versioned object will version when inserted back into the DDE. 
Retrieving Operator_A from the DDE, modifying it and inserting it back into the DDE will 
cause the creation of a new version. The new object will be identified as Operator_A 
“variation 1, version 2”. When Operation_E is retrieved fi-om the DDE the decomposed 
objects. Op_El, OP_E2 and Op_E3. which make up Operator_E will also be retrieved. If 
Operator_E is modified it will version upon insertion into the DDE. If its decomposed 
objects are not modified they will not version. Figure 3 shows an example in which 
OP_Ela is added to Operator_E and generates an additional output data flow. This 
additional data flow changes Operator_E- but has no effect on any of the decomposed 
atomic objects.: 



The input declarations of to Op_El have not been modified, so no 
modifications are required of Op_El- After the modified objects have been inserted into 
the DDE they will be identified as follows: 


12 





Operator_B Variation 1, Version 2 

Op_Bla Variation 1, Version 1 

Op_Bl Variation 1. Version 1 

Op_B2 Variation 1, Version 1 

Op_B3 Variation I, Version 1 

Another modification that could have taken place is the addition of a state 
variable to Op_B2, as shown in Figure 4. In this case OP_B2 and Operator_B will version 
and all the other objects will remain the same. When inserted in the DDB after the previous 
modifications, the objects would be assigned the following control number sequences: 

Operator_B Variation 1. Version 3 

Op_Bl Variation 1. Version 1 

Op_B2 Variation 1, Version 2 

Op_B3 V^ariation 1, Version 1 

As described in Figure 3 the top level operator has been modified and 
therefore it will version when inserted into the DDB. In Figure 4 only a decomposed atomic 



Figure 4. Op_2 Versions. 


object is modified. The Op_B2 object is therefore versioned when inserted into the DDB. 
The versioning of the atomic object OP_B2 propagates up the tree versioning each 


13 










successive parent until the root node has versioned. Only those nodes for which Op_B2 is 
a direct descendent will version. 

Objects are not limited to decomposing only to a second level as described in 
the examples above. Op_B3 could be a composite object and not just an atomic object If 
Op_B3 were a composite object, then each of Op_B3’s decomposed objects (composite or 
atomic) would version as described. If C)p_B3 were a composite object Operator_B would 
decompose as shown in Figure 5. 



Figure 5. Decomposition to Composite and Atomic Objects. 


An instance of a versioned object represents one version of an operator in the 
protot>-pe system being developed. The versioned object can be atomic or composite. It is 
a operator node in the tree which represents the decomposition of the system under 
development. Each versioned object is uniquely identified by the object’s name and the 
objects variation numbers. The variation number is used to separate the Versioned objects 
because the version numbers repeat themselves for each new thread. In each instance of a 
thread the versioned object is unique because it possesses a version number that is a 
minimum distance of 1 from the version number of any other versioned object. 


( 


14 









c. Thread. 

An instance of a thread corresponds to a variation in the control number 
sequence. The term thread denotes a C++ class used to manage the paths of development 
of a versioned object The term variation is the equivalent to thread; therefore variation will 
be used in this document where thread is used in the written C++ code. A variation is an 
alternate path of development. A variation contains a totally ordered sequence of versions 
of an object [Ref. 8:p. 918] with strictly increasing creation times. Each version of an object 
belongs to exactly one variation. A new variation will be created if and only if an version 
about to created is not the latest version of the variation. 



Figure 6. Creation of a New Thread (Variation). 


Figure 6 shows a new variation being created. When an object is retrieved 
from the DDB and modified it can version in one of two w ays. Depending on the intention 
of the modifications being made, the system will version along the same variation path or 
version and create a new variation path, in other words, a new parallel line of development. 
In figure 6 the notation C(a, b) is used to identify the versioned object. C(a, b) is read as 
version b of variation a of object C [Ref 9:p. 26]. Modifying C(l, n) will create a new 
variation when the following occurs: 

(1) C(l, n) is retrieved from the DDB when C(l, n+1) already exists. 

(2) C( 1, n) is then modified by the designer and reinserted into the DDB. 
Since C(l, n+1) already exists and C(l, n) has been modified, this new 

versioned object is reinserted as C(2, 1). This versioned object C(2, 1) is the beginning of 


15 









a new variation whose beginning versioned object will be C(2,1). When C(2,1) is retrieved 
and modified, it will follow the same versioning scheme as all versioned objects, and will 
be reinsened as C(2, 2). 

Each thread is uniquely identified by the versioned object’s name and 
variation number. 

d. Configuration. 

A configuration is a selected version of a sub system under development. The 
designer can select any version and place it under a configuration name. The configuration 
contains the entire subtree of the versioned object. The versioned object is a complete sub 
system selected by the designer which contains certain aspects of the system at a point in 
time during the systems evolution. The configuration allows the designer to more 
effectively deal w'ith and identify selected versions of a system under development. 

The configuration represents a version of the system under development and 
therefore can not be modified. 

e. Component. 

A component can be either composite or atomic. The top level view of 
composite components will give a general overview of a system or object. As the 
component decomposes the view of the objects become more detailed. A composite 
component can be viewed as a collection of related parts [Ref. 9:p. 2]. Large systems, like 
those which will be developed using CAPS, are made up of top level composite 
components with several layers of other composite components between them and their 
lowest level atomic components. 

Within the DDB a component contains a list of Text Objects which make up 
the composite or atomic operator. The parts of an atomic component are a subset of “.a”, 
“.ps”, “.spec.psdl”, “imp.psdl” generated by the graphic editor. The component is at the 
base of the class hierarchy. The component is a list of pointers to the actual source text, and 
graphic representation data and PSDL code stored in the DDB. The pointers contained in 


16 



the list point to the files created by the graphic editor and modified by the syntax directed 
editor. These files contain the following information; 

Postscript : Postscript description language required by the graphic 
editor. 

Graph : A file containing shapes and geometric point information 
required by the graphic editor. 

Implementation : A file containing either Ada source code or a PSDL 
decomposition. This file is used by the syntax directed editor, the 
dynamic scheduler and the translator. 

Specification : A file containing PSDL code. This file is used by the 
syntax directed editor, the dynamic scheduler and the translator. 

Source : Ada code. A file containing the source code for the component 
and protot>qDe [Ref 10;pp. 33-34]. 

A composite component contains information concerning the component of 
the next lower level, wether next lower component be composite or atomic. 

/. Text Object. 

Text object contains the name of the file and the actual source text for the 
operator. Tlie text can be any of the five t>'pes pointed to by the component class. 

2. Connections Between Classes. 

The classes of the design database are not independent of each other. Each C-t-i- 
class contains ONTOS based classes that connect that class to other C-i-i- classes or ONTOS 


17 





classes which make up the database schema. Figure 7 shows a pictorial representation of 
these connections without listing all the fields of the database schema. 



Figure 7. C++ and Ontos Class Connections. 

These connections between classes are described in detail in chapter III section C. 

C. OTHER ATTEMPTS AT ENGINEERING DESIGN DATABASES. 

■‘The goals of configuration management include recording the development history 
of evolving systems, maintaining the integrity of such systems, and aiding the management 
of the systems in guiding and controlling their evolution [Ref 8:p. 918]." 

Until recently most attempts at providing support for configuration management 
consisted of a combination of manual and administrative procedures. This t>T)e of 
configuration management was labor and time intensive and prone to errors. Attempts at 
automating the process led to storing many versions of the same document and keeping up 
to date mechanically derived software. 

One attempt at maintaining the integrity of configurations is addressed in the module 
interconnection languages. “This purpose of the module interconnection language is to 
record the interdependencies between components of a system [Ref 8:p. 918]." This 


18 























includes keeping track of functional specifications and structural and syntactic properties. 
The module interconnection language only deals with specifications and programs. 
Another attempt [Ref. 14] supports upward compatibility, strict compatibility and 
implementation compatibility. Implementation compatibility is a weaker restriction than 
strict compatibility which allows the substitution of specifications within particular 
contexts. Maintaining mechanically-derived software is another effort that has been under 
taken [Ref. 15]. 

The shortcomings of these efforts is that they only deal with the most current version 
and not all the versions leading up to the current version [Ref. 8;p. 919]. 

Luqi [Ref. 8:pp. 919-921] describes the Model of Software Manufacture and the 
Model of Software Evolution which support configuration management. 

The aim of the Model of Software Manufacture is to aid in the managing of 
mechanically derived objects, with reducing the nu’ .u^i uf objects that must be rebuilt in 
response to a change. Also it attempts to estimate the computing cost of implementing the 
change. 

The Model of Software Evolution attempts to integrate software evolution and 
configuration management. This work is based on the ANSI/IEEE standard on Software 
Configuration Management [Ref. 8:p. 921]. 


19 





in. IMPLEMENTATION OF A DESIGN DATABASE FOR CAPS 


A. OBJECTIVES. 

The design database currently being used to support the CAPS environment was 
developed by Dwyer and Lewis [Ref. 10]. This design database will be identified as the 
“current” database while the design database developed in this thesis will be called the 
“new” database. 

The current Design Database does not meet all the requirements necessary to support 
CAPS. The requirements that it does support need to be enhanced or redesigned while other 
functions need to be developed in order to fulfill the requirements established by CAPS. 

The schema for the design database needs to be redesigned in order to meet the 
requirements to support variation and version control. The current design database 
structure stores versions in a linear progression. When an object is retrieved from the 
database, modified and reinserted, it versions but it will never create a new variation. If 
version 2 of object A is retrieved from the current database and modified, and version 3 of 
object A already exists, version 2 will be reinserted into the current database as version 4 
of object A. Since here is no link between (object A version 2), and (object A version 4) it 
can not be determined that version 4 came from version 2. The new database must provide 
the functionality to support variations as described in chapter 2. 

All operations that access the design database need to be redesigned. The current 
operations only access objects on a single development path. One of the requirements for 
the CAPS design database is to possess the ability to create and store alternate paths of 
development. Each new path is a new variation of an existing object. Each variation 
contains sequentially numbered versions of an object. 


20 





The current database creates new versions of an object based solely on the time stamp 
of the object. This allows objects to version when no actual changes have taken place. Each 
object needs to be evaluated based on changes in content and not on an external time stamp. 

A historical trail operation is required to trace the development of any object back to 
its original root object. This requirement is necessary because the new database design will 
be based on a tree structure with variations being capable of branching off any object. The 
need to know the evolution of an object is important when making decisions concerning 
future development. 

After an object is reinsened into the current database, a copy of the object still remains 
in the designers working directory. When an object has been successfully inserted into the 
database, the copy remaining in the designers working directory needs to be removed. 

The current design database does not fully support the ability to choose selected 
versions of different objects and place them together to develop a new system. This 
requirement is necessary to avoid rebuilding a section of a system that has already been 
designed and tested. 

Currently objects which the designer wants for view only, are retrieved from the 
database and stored in the designers working directory in read only mode. This requires that 
they later be removed by the user in order to retrieve the object for editing. This is an 
unnecessary requirement placed on the designer. Access to all objects in the design 
database, for view or for modification should require no additional w ork on the part of the 
designer other then issuing commands to insert or retrieve objects. 

The addition of variations to the development path makes much of the current design 
database code obsolete and dangerous. Inadvertent execution of obsolete code can cause 
system failure, data corruption, or numerous other problems without the user being aware 
that a problem has occurred. This code needs to be studied, identified and removed while 
valid code is left intact 


21 




B. METHODOLOGY. 


All design methodologies share a similar path of development at a certain time during 
the project life cycle. Every project goes through the activities of system analysis, design, 
and implementation, even if the names given the activities are different for each 
methodology used. The classical project life cycle, also know as the “waterfall life cycle” 
has stages known as Analysis, Program Design, Coding, Testing, and Operations. The 
semi-structured life cycle is composed of activities named Analysis, Structured Design, and » 

Top-Down Implementation. The Structured Design activity is further decomposed into 
Codify Functional Specification, Derive Structure Chart, Design Module, and Package 
Design. Tlie structured project life cycle contains activities such as Analysis, Design, 
Implementation, Acceptance Test Generation, Quality Assurance and Installation. 

The activities listed above are not all of the activities of the project life cycle 
methodologies named above. They only represent a part of the system life cycle in which 
the work being done on the system is similar in nature no matter which methodology is used 
to develop the system. The areas that they represent are the design, coding, testing and 
implementation activities. The actual implementation of these individual activities is what 
separates the different methodologies [Ref. 12:pp. 77-101]. 

Yourdon [Ref. 12:p. 94] points out that more then one activity can occur at a time in 
the structured project life cycle. Depending on the number of activities occurring at any one 
time it will be known as a radical or conservative implementation of the project life cycle. 

Douglas [Ref. 1] conducted the survey and requirements analysis to establish the 
needs of the design database. Dwyer and Lewis [Ref. 10] expanded on the requirements 
analysis established by Douglas. They also designed, implemented and tested some of the 
functions established by the requirements analysis. A review of their thesis shows a 
structured life cycle approach was taken. 

The issues dealt with in this thesis were the design of a new database structure, that 
being the redesign of the way in which the objects are stored and retrieved. We have 
designed a new database schema to support the new database structure. Because the 


22 






attribute keys for the objects were altered, the insertion and retrieval of objects from the 
database also had to be redesigned. 

The comparison of the objects based on content had to be implemented. Versioning of 
objects based on the value of a time stamp is unacceptable. 

The project life cycle methodology used for this thesis is best described as a 
moderately radical structured approach [Ref. 12:p. 95]. The design of new and redesign of 
existing structures along with implementation and testing all had to occur at the same time. 
Each new function and modification of existing functions had to be tested to evaluate their 
effect on other functions and objects. All modifications to existing functions had to be 
noted and reflected and placed as updates in the users manual. Of the nine activities that 
Yourdon [Ref. 12:p 89] lists as part of the structured project life cycle, four of them were 
simultaneously being implemented during the development of the new design database 
TTiese four activities are design, implementation, acceptance test generation and quality 
assurance. 

C DESIGN DECISIONS AND JUSTIFICATIONS. 

1. Database Schema. 

The database schema of the new design database is made up of user defined and 
pre-defined ONTOS C++ classes [Ref. 11]. The manipulation of these C++ classes allows 
the user to add, delete or modify objects stored in the design database. The design database 
is made up of six user defined classes. Within these six classes there are two ONTOS 
defined classes which help support the tree structure necessary to maintain variations and 
versions. The user defined classes are derived from the ONTOS class Object. The six user 
defined classes are: 

Component 

Configuration 

Prototype 

rext_Object 


23 





Thread 


Versioned_Object 

The ONTOS classes used within in the user defined classes are; 

Dictionary 

List 

The relationship betw'een these classes is a spider web of pointers. Figure 7. 

The Prototype class is at the top level of the hierarchial design structure. This class 
has pointers to Configuration and Text_Object user defined class objects and to an ONTOS 
class Dictionary object. The Configuration object holds the default configuration for the 
prototype. There may be many configurations attached to a prototj-pe but the Configuration 
pointer points to the latest configuration attached. All the other configurations attached to 
the prototype are accessed through the Dictionary object. The default (latest) configuration 
has its own pointer but a pointer to this configuration is also placed in the Dictionary class. 
The Dictionary class contains pointers to all the Configurations attached to the prototype. 
A Text_Object object contains the text description of the PrototNT^e. Figure 8 gives a 
pictorial representation of the Prototype class and its member classes. Other data fields are 



Figure 8. Prototype class and internal classes. 

also contained within Prototype and are used for accounting and historical information. The 
Prototype class has no other classes pointing to, or accessing its data. 


24 












The Configuration class points to Versioned_Object and Text_Object objects. 
Configuration points to two instances of Text_Object. The first instance contains the 
configuration description provided by the designer. The other instance contains log entries. 
Log entries are additional information concerning the makeup of the configuration. The 
Versioned_Object pointer points to the versioned object which is the root node of a tree or 
sub tree to be identified by a unique configuration name. The unique configuration name 
can identify an entire system or any subtree of a system. The Versioned_Object identified 
by the configuration name can be accessed for view or editing. If a Versioned_Object is 
modified when retrieved using the configuration name, the Versioned_Object will version 
but the Configuration name will not reflect the new version. 

For example, variation 1, version 3 of object A is identified by the unique 
configuration name config_l. Variation 1, version 3 of object A is retrieved from the 
database using the name config_l. After the modifications have been completed and 
config_l is reinserted into the database, the configuration name, config_l will still point to 
variation 1, version 3 of object A. Meanwhile a new object has been created, and is 
identified as variation 1, version 4 of object A. 

All other data fields contained in the Configuration class are used for accounting 
and historical purposes. Configuration is pointed to and accessed from Prototype. Figure 9 
gives a pictorial representation of the Configuration class and the class member objects 
contained within it. 



Figure 9. Configuration and its internal classes. 


25 











The Component class, figure 10, contains only one element, the ONTOS defined 
List class. The List object contains a list of pointers to instances of Text_Objects. The 
Text_Objects contain information detailing wether the component is composite or 
atomic.The Component class is a container class for Text_Objects. A Component class can 
contain any number of Text_Objects. 

The Text_Object class, figure 10, is at the bottom of the hierarchial class 
structure. The Text_Object class contains two character string pointers. All “.a”, “.graph”, 
“.spec.psdl”, “.imp.psdl” “.as”, log and description entries are contained in Text_Objects. 
One character string pointer points to a file name, the other to the file containing the actual 
text. Because of required access to text files, Text_Object is pointed to by Prototype, 
Configuration, Versioned_Object and List classes. Each instance of Text_Object. 
depending w hich class points to it, contains a different type of text. 

The Versioned_Object class, figure 11, is a class w hich points to. or is accessed by 
almost every other class in the database. The Versioned_Object class is the crossroads of 
the design database structure. The Versioned_Object points to other Versioned_Objects, 
Text_Objects, Components, a Thread, a List and two instances of Dictionary classes. It is 
pointed to by Versioned_Object, List, Configuration and Dictionary classes. 



One Dictionary object contains the pointers to the first Versioned_Object of each 
new Thread. The other Dictionary object contains pointers to all the Threads which contain 
Versioned_Objects which versioned off this particular Versioned_Object. The List class 
contains the pointers to all the Versioned_Objects which are children of this 


26 












Versioned_Object. The Thread pointer points to the Thread that the Versioned_Object is 
attached. 



Figure 11. V_Object class and internal classes. 


The Component pointer points to the List object, which contains pointers to 
Text_Objects associated with this Versioned_Object. The Versioned_Object pointer points 
to the Versioned_Objects parent if it is not the root node, otherwise the pointer is null. The 
Text_Object points to a description of the Versioned_Object provided by the designer. 

The Thread class, figure 12, is similar to the Component class for the reason that 
it is a container class for Versioned_Objects. The Thread class contains accounting data, 
historical data and a List class object. The List object points to Versioned_Objects attached 
to the Thread. TTuead is pointed to by Versioned_Object. The thread class is the C++ 
equivalent of a variation. 

2. New Versions and New Variations. 

Each time an object is modified by the designer it will version. The new object 
created will be a copy of the object retrieved from the database incorporating the 
modifications made by the designer. The new object can take one of two separate paths of 
development. The new object can become a new version, and continue on the current path 
of development or the new object could become the first version of a new variation. A 
modification of an object at any level will propagate changes up the tree to the root object. 


27 















Because a node on a subtree has changed the functionality of the entire tree has also 
changed and therefore versioning of the entire tree must take place. 



Figure 12. Thread class and its internal classes. 

The current design database creates a new version based on the value of the » 

objects time stamp. The time stamp is updated for an object each time the object is accessed 
while in the designers working directory. This does not mean that the object has been 
modified, just accessed. When inserting the object into the design database the current 
database compares the time stamp of the object being inserted against the time stamp of the 
object in the database. If the value of the time stamps are different, a new version of the 
object will be created. This process does not take into consideration the actual contents of 
the object. Versioning is dependent upon an external time stamp variable. 

The new design database compares the contents of the objects and creates a new 
version if the actual contents of the objects are different. Since an atomic object, at a 
minimum, consists of between one and five Text_Objects contained in the Component 
class, each Text_Object is compared individually. If the contents of any one of the possible 
five Text_Objects is different from the contents of the corresponding Text_Object, of the 
object stored in the database, then the object will version. The new design database then 
will insert into the database the new object from the designer’s working director)'. 

Each versioned object is contained on a thread. A thread is the C++ class 
representation of a variation. When a new object is created, (if no new variation is created) 
it is made unique by creating it with a version number one higher then the previous object. 

The name given the object is the same as the operator name assigned the object in the 
graphic editor. 

A new variation will be created when an object being inserted into the database 
has been modified and there exists an object with a higher version number, on the same 


28 











thread, of the object being inserted. The modified object will become the first versioned 
object of the new variation. The thread is given a unique name by concatenating the object 
name and the variation number. The thread that contains the operator 
c3i_system.sensor_interface, variation 1, version 2 is actually identified in the database as 
c3i_system.sensor_interface_l. All the versions that make up variation 1 of 
c3i_system.sensor_interface are contained in the thread c3i_system.sensor_interface_l. 

If the conditions for the creation of a new variation are met, the new variation will 
be identified in the database as c3i_system.sensor_interface_2. The thread has been made 
unique by appending the variation number to the object name. This thread/variation will 
contain only versions of the c3i_system.sensor_interface object. The 
c3i_system.sensor_interface objects can be assigned version numbers that were assigned in 
previous thread/variations because they are attached to a different and unique thread/ 
variation. 

3. History Trail. 

The historical trail as implemented in the new design database is extremely 

simple. 

The current design database had no need for a historical trail. Since it handled 
only one variation, the history of each version is simple. The current version is assumed to 
have been created from the previous version. With the inclusion of variations the historical 
trail of object development becomes more complicated. Each new variation created 
requires a link back to its parent object. 

The new design database now lists th^ versions of any selected versioned object 
in reverse chronological order from the given to the root object. 

4. Objects in the Working Directory and the Concerns of the Design Database. 

The new design database places object control files in the designers working 
directory. These files in no way interfere with the designers ability to retrieve objects from 
the database, but they do provide control data to the database when reinserting an object 


29 




into the database. When the command is issued to retrieve an object from the database the 
operator name along with the variation and version numbers provided on the command line 
identify the root object to be placed in the designers working directory. Any children 
(objects), subtrees attached to the root object identified on the command line will also be 
retrieved from the database and placed in the designer’s working directory. For each object 
placed in the designer’s working directory a database control file is written to the directory 
also. The control file contains the variation and version numbers of the object that has been 
retrieved. The designer will not see this control file when accessing the objects via the user 
interface or the command line. The control data file name is made up of the complete object 
name prefixed by “ddbCtrlData.” The complete object name is a concatenation of all the 
object names as they decompose to the object. For example, the c3i_system, 
c3i_system.sensor_interface and c3i_system.sensor_interface.add_sensor_data will have 
the following control files; 

ddbCtrlData.c3i_system 
ddbCtrlData.c3i_system.sensor_interface 
ddbCtrlData.c3i_system.sensor_interface.add_sensor_data 
When the objects are being reinserted into the database each object has its control 
file read just prior to being reinserted. The DDBMS uses the information contained in the 
control file to locate the object in the database. Once located, the necessar>' comparisons 
can be conducted to establish wether a new object needs to be created. 

The control files are removed from the directory after the appropriate action has 
been taken to create or not create a new object. 

Under the current design database, copies of all object inserted into the database 
remain in the designer’s working directory. If the designer wants, at some later time, to 
retrieve the same object or a different variation/version of the object, the copies have to be 
removed. If all the copies are not removed, some objects will be retrieved from the database 
and others will not. Once the database attempts to write an object to a directory with an 
object of the same name already existing in that directory, the write fails and the DDBMS 


30 




stops retrieving objects from the database. The objects that have been successfully written 
to the directory are now locked by the database and the complete object tree has not been 
retrieved from the database. The designer has only one option, remove all the objects just 
retrieved from the working directory along with the duplicate object. Issue a release lock 
sub tree command to release the locks of the objects just retrieved and initiate a new 
retrieval. 

The new design database removes all copies of objects from the designers 
directory after successful insertion of the object into the database. 

If for some reason a copy of an object remains in the designer’s directory and then 
the object is later retrieved the DDBMS will ask the designer if they want the old copy to 
be overwritten. If the designer responds yes. overwrite, the DDBMS overwrites the object 
in the designers directory and continues to retrieve objects from the database. If the 
designer responds no then the same procedure as the current database must be followed. 

5. Viewing and Editing Objects in the Working Directory. 

Depending on the parameter passed to the database, any versioned object 
retrieved will be either be read only (view) or editable. If the r or R option is used, the 
versioned object retrieved will be placed in view mode. The designer will be able to access 
the system and all its components, but will not have the capability to alter any of the 
object's contents. The objects retrieved using the view option will be sent to standard out. 
The user interface will then redirect the output from the database to an appropriate 
directory. The directory where the system components will be stored will not be the 
designers working directory. Under the current implementation of the design database, the 
system selected to be viewed is placed in the designers working directory with file 
permission set for read only. This setup later causes additional work for the designer. When 
the same system is retrieved from the database for purposes of editing, the existing read 
only files will not allow the database to store the retrieved data in the working directory. 


31 




This causes the retrieval to terminate. The designer then has to delete each object before 
being able to retrieve the system for editing. 



When retrieving an object for editing the w or W option is used. The object 
retrieved is placed in the designers working director)'. The object and all its components are 
now available for editing or viewing. The designer now has full control over the object 
retrieved from the design database. If two or more designers want to work on different 
sections of the same object tree, in their own directories, each can retrieve from the design 
database the section of the object they will work on. When a tree or subtree of an object is 
retrieved from the database it is locked and then available for view only to all other 
designers. The other designers working on the system can retrieve the locked sections of 
the object for view only and have a complete view of the object while actually working on 
only a part of the object. Figure 13 show how a system could be split up among the 
designers. 


32 









6. Dangerous Obsolete Code. 

The necessity to modify, enhance and redesign the existing design database in 
order to bring it up to the established requirements of the CAPS system, entailed the 
detailed study of existing code. Although some of the functions are reusable as written, 
most of them required extensive modifications or needed to be completely rewritten. 

As code was modified or added, an examination of the code in the immediate area 
was reviewed for potential problems. Required changes were made where necessary, 
deletions were made if necessary and test of all changes were conducted. All code found to 
be obsolete was removed. As much as possible obsolete code has been identified and 
removed. 

D. TESTING AND TEST RESULTS. 

Frakes [Ref 13:p. 125] lists three definitions of software testing. The definition which 
best describes the testing performed on the new design database is “any activity aimed at 
evaluating an attribute or capability of a program or system and determining that it meets 
its required results.” 

Four stages of testing are expected to be traversed before a system can be accepted. 
They are: 

unit testing 
integration testing 
system testing 
acceptance testing 

The new design database has undergone three of the four test stages. 

Unit testing, the testing of a single function, was conducted on each function written 
or modified. Each function was accessed via the command line to ensure that the function 
performed according to its specifications. No function was tested independently, but 
required the interaction of other functions, to call or be called, to complete the actual 
execution of the command. 


33 







Integration testing was conducted when new functions were required to be designed 
and implemented. The new functions were grouped together, according to their 
functionality, and tested to check for mutual interference or data corruption. 

The acceptance test was conducted in the form of a demonstration of the capabilities 
of the new design database using systems developed by other designers. 

The system test, where the system is integrated with the user interface and tested, has 
not been conducted. 

Because of the amount of code already written and the large number of required 
changes that had to be implemented, regression testing was only test strategy that was 
acceptable to use. 

Whenever code is modified or inserted to correct a problem or enhance the system one 
of four things may occur: 

1. TTie problem is fixed or the enhancement is successful. 

2. The problem was not corrected or the enhancement is not as successful as 
planned. 

3. The problem is fixed or the enhancement is successful, but a new problem has 
been introduced. 

4. The problem was not corrected or the enhancement is not successful, and a 
new problem has been introduced [Ref 13:p. 137] 

Since only the first result is acceptable, tests were conducted over and over again each 
time a modification was implemented. Regression testing was not implemented for each 
change made but rather for each group of changes and additions made for a localized 
functionality. A shell script was constructed to aid in this consuming and cumbersome 
testing procedure. 

The shell script and test results are listed in appendix C. 


34 






IV. RECOMMENDATIONS AND CONCLUSIONS 


A. SUMMARY 

Although the main goals of this thesis were met, the implementation of variation and 
version control, there are numerous smaller problems that exist which are annoying to the 
designer and detract from the capabilities of the design database. 

B. RECOMMENDATIONS FOR FUTURE WORK 

The system suffers from unhandled exception errors. All exceptions should be caught 
and the system gracefully shut down or have other appropriate action. Examples of errors 
that s..at the system down are: 

Inserting an object into the database with no object in the directory. 

Using variation and version numbers that do not exist for an object. 

If the design database successfully terminates but an error was detected prior to 
termination the DDBMS will still commit the objects to the database. For example, the 
retrieval of objects is terminated if an object of the same name is in the designer’s directory. 
The designer has the option to overwrite the object if they choose to but if they choose not 
to, the objects already retrieved are locked. The designer’s directory now contains edl 
objects successfully retrieved prior to the error. These objects are only a pan of the object’s 
tree. The database is updated to lock all the objects successfully retrieved. Since the 
retrieval of the entire object tree was not successful the DDBMS should not update the 
design database. 

The dependency on control files in the designer’s working directory should be 
removed. All the required information for an object is in the database. If the root object is 
known the each of the children objects can be identified. 


35 






The ability to access objects and their data via versioned object commands and 
configuration commands is redundant. The configuration commands can be removed and 
all access could be through versioned object commands. 

The DDB schema should be reworked to simplify insertions and take advantage of 
subclasses and inheritance. 

If a object identified by a configuration is modified, the configuration should identify 
the new object. This should occur if the object was accessed by the configuration name. 

Configurations appear to have limited usefulness. The design of the DDB and its role 
in CAPS should be reviewed to determine wether the concepts and structures related to 
configurations can be remover from the DDB. 


36 




APPENDIX A 


A. ENTITY-RELATIONSHIP (ER) SCHEMA DIAGRAM 



37 














































B. DATABASE SCHEMA 
THREAD 

CurTent_Version, {The_list} 

TEXT_OBJECT 
The_file_name, The_text 

PROTOTYPE 

Leader, Dictindex, CrearionDate, {ConfigurationList), Description, DefaultConfig 

CONFIGURATION 

Status, Manager, CreationDate,VobjectNum, Log, Description. Versioned_Object 

COMPONENT 

{Text_object_list} 

VERSIONED_OBJECT 

VariationNum, VersionNum, CreationDate, LockTime, NodeName, Creator. Worker, 
Visit, Last_C)p_Checkin, Description, {ThreadPtr}, {ComponentPtr}. {ChildPtr}, 
ParentPtr, {VariationList}, NumberOfVariations, {VariationReference} 


Multivalued attributes are shown between set braces {}. 
There are no composite attributes. 


38 



APPENDIX B 


COMMAND LINE COMMANDS 


A. PROTOTYPE COMMANDS 

Table 1: PROTOTYPE COMMANDS 


Tag 

Description 

Output 

Command Line^ 

PIP 

In sen Prototype 


ddb <db> pip <p>*’ 

[leader] [description]^^ 

PLN 

List Names 

Names (one per line) 

ddb <db> pin 

PLL 

Long List 

Name, Default Config. 
Default VOBJECT 

ddb <db> pll 


Retrieval Commands: 



PDS 

Dump Summary 

Date Created 

Leader 

Default Config 
Description 

ddb <db> pds <p> 

PRD 

Retrieve Date 

Date Created 

ddb <db> prd <p> 

PGL 

Get Leader 

Leader 

ddb <db> pgl <p> 

PGC 

Get Configuration 

Default Config 

ddb <db> pgc <p> 

PGD 

Get Description 

Description 

ddb <db> pgd <p> 


Update Commands: 



PUL 

Update Leader 


ddb <db> pul <p> 

<'‘new leader”> 

PUD 

Update Description 


ddb <db> pud <p> 
<filename> 


a. <> Angle Drackets are required parameters, u square Brackets are optional parameters. 

b. <db> db = Ontos Database name. <p> p = Prototype name. 

c. Passed in as a filename or string. 


39 









































B. CONnGURATION COMMANDS 


Table 2: CONFIGURATION COMMANDS 


Tag 

Description 

Output 

Command Line^ 

CIC 

Insert Configuration 


ddb <db> cic <p> 

<c>*’[manager] 

[description]^^ 

CLN 

List Names 

Names 

ddb <db> cln <p> 

CLV 

List Default VOBJECT 

Name, Version 

ddb <db> civ <p> <c> 

CLO 

List Operators 

Operator Name,‘* 
Version 

ddb <db> do <p> <c> 

CLL 

Long List Default 
VOBJECT’s ChUdren 

Node^ Name, 

Version 

ddb <db> cU <p> <c> 


Retrieval Commands: 



CDS 

Dump Summary 

Date Created 

Date Changed 
Manager 

Default VOBJECT/ 
Version 

Description 

ddb <db> cds <p> <c> 

CDA 

Get Date Created 

Date Created 

ddb <db> cda <p> <c> 

COM 

Get Manager 

Manager 

ddb <db> cgm <p> <c> 

CGD 

Get Description 

Description 

ddb <db> cgd <p> <c> 

CGL 

View Log^ 

Log Entries 

ddb <db> cgl <p> <c> 


Update Commands: 



CUN 

Update Name 


ddb <db> cun <p> <c> 
<new name> 

CUM 

Update Manager 


ddb <db> cum <p> <c> 
<new_name> 

CUD 

1 

Update Description 


ddb <db> cud <p> <c> 
<filename> 


40 















































Table 2: CONFIGURATION COMMANDS 


Description 


Output 


Command Line^ 


CPL Post Log 


CRL Release Lock 


CAA Update VOBJECT’s 
subtree 


CAO Attach VOBJECT to 
CONHGURATION 


Extraction Commands: 



CDT Dump VOBJECT subtree file(s) 


ddb <db> cpl <p> <c> 
<filename> 


ddb <db> crl <p> <c> 


ddb <db> caa <p> <c> 


ddb <db> cao <p> <c> 
<vobject> 

[variation] [version] 


ddb <db> cdt <p> <c> 
R/W® 


a. <> Angle orackets are required parameters. IJ square orackeLsare optional parameters. 

b. <db> db = Ontos Database name. <p> p = Prototype name. <c> c = Configuration name. 

c. Passed in as a filename or string. 

d. Operator name containing explicit path information for determining location (level) in heirar- 
chical data structure. 

e. Node name contains no reference to location (level) in heirarchicai data structure 

f. Log file is read only. Log can only be updated. Additional log entries are appended to the bot¬ 
tom of the current log. 

g. R for View Only (Read). W for edit (Write). 


41 


















C. VERSIONED COMPONENT COMMANDS 


Table 3: VERSIONED COMPONENT COMMANDS 


Tag 

Description 

Output 

Command Line^ 

VAA 

Add VOBJECT and 
Subtree 

Confirmation 

ddb <db> vaa <p> <v>^ 
[variation] [version] 

VLO 

List Operators 

VOBJECT Name,'" 
Variation, Version 

ddb <db> vlo <p> <v> 
[variation] [version] 

VLL 

Long List VOBJECT’s 
Children 

VOBJECT Name,*^ 
Variation. Version 

ddb <db> vll <p> <v> 
[variation] [version] 

VLP 

Long List VOBJECT’s 
Parent and Siblings 

VOBJECT Name 
Variation, Version 

ddb <db> vlp <p> <v> 
[variation] [version] 


Retrieval Commands 



HTT 

History Trace 

VOBJECT Name 
Variation, Version 

ddb <db> htt <p> <v> 
[variation] [version] 

VDS 

Dump Summary 

Date Created 

Creator 

Worker 

Lock Time 

Description 

ddb <db> vds <p> <v> 
[variation] [version] 

VDD 

Get Date Created 

Date Created 

ddb <db> vdd <p> <v> 
[variation] [version] 

VGL 

Get Lock Time 

Date, Time Locked 

i 

ddb <db> vgl <p> <v> 
[variation] [version] 

VGV 

Get Versions 

Variation/Version 
Number (one per line) 

ddb <db> vgv <p> <v> 

VGD 

Get Description 

Description 

ddb <db> vgd <p> <v> 
[variation] [version] 


Update Commands: 




42 


















































Table 3: VERSIONED COMPONENT COMMANDS 




Description 


Update Description 


VRO Release Lock Operator 


Release Lock Operator 
and Subtree 


Extraction Commands: 


VGP Get Postscript 


Output 


Command Line^ 


ddb <db> vgd <p> <v> 
<filename>^ 
<variation> <version> 


ddb <db> vro <p> <v> 
[variation] [version] 


ddb <db> vrs <p> <v> 
[variation] [version] 


Display Postscript File ddb <db> vgp <p> <v> 

[variation] [version] 





VGG Get Graphics 


Get Implementation 


VGC Get Specification 


Get Source 


Dump Operator 
Atomic® 


Dump Operator and 
Subtree 


Display Graphics File 


Display 

Implementation File 


Display Specification 
FUe 


Display Source Code 
FUe 


ddb <db> vgg <p> <v> 
[variation] [version] 


ddb <db> vgi <p> <v> 
[variation] [version] 


ddb <db> vgc <p> <v> 
[variation] [version] 


ddb <db> vgs <p> <v> 
[variation] [version] 


ddb <db> vdf <p> <v> 
<R/W> 

[variation] [version] 


file(s) ddb <db> vdt <p> <v> 

<R/W> 

[variation] [version] 


gie DracKets are requued parameters, u square brackets are optional parameters. 

b. <db> db = Ontos Database name. <p> p = Prototype name. <v> v = Vobject name. 

c. Operator name containing explicit path information for determining location (level) in heirar- 
chical data structure. 

d. Node name contains no reference to location (level) in heirarchical data structure. 

e. 

f. File containing description. 

g. Atomic is considered a node containing .ps .gr^h .imp.psdl .spec.psdl and .a file(s). 



43 











































APPENDIX C 


A. TEST SCRIPT FILE. 

This test was run with the aid of a shell script. The shell script is listed in section C. 
All design database command line commands begin with the word “main”. The result of 
each command is displayed after each command line. If the line following a command line 
is blank, then there was no output for that particular command. The results of the command 
are accessible from others commands. For example, the first command executed is “pip”, 
insert prototype name. There are no output results for this command to displayed, so the 
line following the command will be blank. The actual commands displayed are produced 
using echo, and only represent the command executed. For that reason any string in single 
quotes (‘’) should actually be placed in double quotes (“”). 

START COMMAND LINE TEST 

main oloughln pip c3i_system_prototype ‘Michael D. O’Loughlin’ descp 

main oloughln pin 

protot\’pe_c3i_system 

c3i_system_prototype 

main oloughln pll 

protot>'pe_c3i_system 

c3i_system_prototype 

main oloughln pgd c3i_system_protot>'pe 

This is a test file added to the design database for example purposes. 

Any thing can be added to it, and nothing can be expected back. 

main oloughln pud c3i_system func_description 

main oloughln pgd c3i_system_prototype 

This file is a test file so that all commands that access or affect the description 
can be tested. 

All Prototype operations have been tested successfully. 

Adding to configuration description. 

All Prototype operations have been tested successfully, EXCEPT ; 


44 




Removing operators CRL and CAA from cofiguration command. 


Adding to Versioned component description. 

main oloughln prd c3i_system_prototype 
Mon Jun 8 14:50:24 1992 

main oloughln pgl c3i_system_prototype 
Michael D. O’Loughlin 

main oloughln pul c3i_system_prototype ‘Larry Williamson’ 

main oloughln pgl c3i_system_prototype 
Larry Williamson 

main oloughln pds c3i_system_prototype 
Mon Jun 8 14:50:24 1992 
Larry Williamson 

This file is a test file so that all commands that access or affect the description 
can be tested. 

All Prototype operations have been tested successfully. 

Adding to configuration description. 

All Prototype operations have been tested successfully, EXCEPT : 

Removing operators CRL and CAA from cofiguration command. 

Adding to Versioned component description. 

main oloughln cic c3i_system_prototype c3i_config_l ‘Michael D. O’Loughlin' 

descp 


main oloughln cln c3i_system_prototype 
c3i_config_l 

main oloughln cda c3Lsystem_prototype c3i_config_l 
Mon Jun 8 14:50:54 1992 


45 




main oloughln cgm c3i_system_prototype c3i_config_l 
Michael D. O’Loughlin 

main oloughln cgd c3i_system_prototype c3Lconfig_l 

This is a test file added to the design database for example purposes. 

Any thing can be added to it, and nothing can be expected back. 

main oloughln cum c3i_system_prototype c3i_config_l ‘Marty Shoppenheimer’ 

main oloughln cgm c3i_system_prototype c3i_config_l 
Marty Shoppenheimer 

main oloughln cud c3i_system_prototype c3i_config_l func_description 

main oloughln cgd c3i_system_prototype c3i_config_l 

This file is a test file so that all commands that access or affect the description 

can be tested. 

All Prototype operations have been tested successfully. 

Adding to configuration description. 

All Prototype operations have been tested successfully, EXCEPT : 

Removing operators CRL and CAA from cofiguration command. 

Adding to Versioned component description. 

main oloughln cpl c3i_system_prototype c3i_config_l ‘This is the first Post to 
c3i_system Log’ 

main oloughln cgl c3i_system_prototype c3i_config_l 

Mon Jun8 14:51:18 1992 

This is the first Post to c3i_system Log 

main oloughln cpl c3i_system_prototype c3i_config_l ‘This is the second Post to 
c3i_config_l Log’ 

main oloughln cgl c3i_system_prototype c3Lconfig_l 


46 





Mon Jun8 14:51:18 1992 


This is the first Post to c3i_system Log 

MonJun8 14:51:23 1992 

This is the second Post to c3Lconfig_l Log 

main oloughln cln c3i_system_prototype 
c3i_config_l 

main oloughln cds c3i_system_prototype c3i_config_l 
MonJun 8 14:50:54 1992 
Marty Shoppenheimer 

This file is a test file so that all commands that access or affect the description 
can be tested. 

All Prototype operations have been tested successfully. 

Adding to configuration description. 

All Prototype operations have been tested successfully. EXCEPT : 

Removing operators CRL and CAA from cofiguration command. 

Adding to Versioned component description. 

main oloughln vaa c3i_system_prototype c3i_system 
c3i_system 

main oloughln pll 

prototype_c3i_system 

c3i_system_prototypec3i_config_l 

main oloughln vlo c3i_system_prototype c3i_system 
c3i_system.comms_interface.convert_to_text_file 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.comms_interface.decide_for_archiving 1 1 
Wed Dec 31 16:00:00 1969 


47 





c3i_system.comms_interface.extract_tracks 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.comms_interface.forward_periodic_report 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.comms_interface.make_routing 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.comms_interface.parse_input_file 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.comms_interface.prepare_periodic_report 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.comms..interface 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.comms_links 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.navigation_system 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.sensor_interface.analyze_sensor_data 1 1 

Wed Dec 31 16:00:00 1969 

c3i_system.sensor_interface.prepare_sensor_track 1 1 

Wed Dec 31 16:00:00 1969 

c3i_system.sensor_interface 1 1 

Wed Dec 31 16:00:00 1969 

c3i_system. sensors 1 1 

Wed Dec 31 16:00:00 1969 

c3i_system.track_database_manager.add_comms_track 1 1 

Wed Dec 31 16:00:00 1969 

c3i_system.track_database_manager.add_sensor_track 1 1 

Wed Dec 31 16:00:00 1969 

c3i_system.track_database_manager.filter_comms_track 1 1 

Wed Dec 31 16:00:00 1969 

c3i_system.track_database_manager.filter_sensor_track 1 1 

Wed Dec 31 16:00:00 1969 

c3i_system.track_database_manager.monitor_ownship_position 1 1 

Wed Dec 31 16:00:00 1969 
c3i_system.track_database_manager 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.user_interface.display_tracks 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.user_interface.emergency_status_screen 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.user_interface.get_user_inputs 1 1 


48 



Wed Dec 31 16:00:00 1969 
c3i_systeni.user_interface.manage_user_interface 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.user_interface.message_arrival_panel 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.user_interface.message_editor 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.user_interface.status_screen 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.user_interface 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.weapons_interface 1 1 
Wed Dec 31 16:00:00 1969 
c3i_sysicm.weapons_systems 1 1 
Wed Dec 31 16:00:00 1969 

main oloughln vll c3i_system_prototype c3i_system 


comms_interface 1 1 

comms_links 1 1 

navigation_system 1 1 

sensor_interface 1 1 

sensors 1 I 

track_database_manager 1 1 

userjnterface 1 1 

weapons_interface 1 1 

weapons_systems 1 1 


main oloughln vlo c3i_system_prototype c3i_system.comms_interface 
c3i_system.comms_interface.conven_to_text_file 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.comms_interface.decide_for_archiving 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.comms_interface.extract_tracks 1 1 
Wed Dec 31 16:00:00 1969 

c3Lsystem.comms_interface.forward_periodic_report 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.comms_interface.make_routing 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.comms_interface.parse_input_rile 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.comms_interface.prepare_periodic_report 1 1 


49 




Wed Dec 31 16:00:00 1969 


main oloughln vU c3i_system_prototype c3i_system.comms_interface 

convert_to_text_file 1 1 

decide_for_archiving 1 1 

extract_tracks 1 1 

forward_periodic_report 1 1 

make_routing 1 1 

parse_mput_fUe 1 1 

prepare_periodic_report 1 1 

main oloughln vlo c3i_system_prototype 

c3i_system.comms_interface.convert_to_text_file 

main oloughln vll c3i_system_prototype 

c 3i_sy stem.c omms_interface .c on vert_to_text_file 

main oloughln caoc3Lsystem_prototypec3i_config_l c3i_system 1 1 
main oloughln do c3i_system_prototype c3i_config_l 
c3i_system.comms_interface.convert_to_text_file 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.comms_interface.decide_for_archiving 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.comms_interface.extract_tracks 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.comms_interface.forward_periodic_repon 1 1 

Wed Dec 31 16:00:00 1969 
c3i_system.comms_interface.make_routing 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.comms_interface.parse_input_file 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.comms_interface.prepare_periodic_report 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.comms_interface 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.comms_links 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.navigation_system 1 1 
Wed Dec 31 16:00:00 1969 

c3Lsystem.sensor_interface.analyze_sensor_data 1 1 
Wed Dec 31 16:00:00 1969 


50 




c3i_system.sensor_interface.prepare_sensor_track 1 1 

Wed Dec 31 16:00:00 1969 

c3i_system.sensor_interface 1 1 

Wed Dec 31 16:00:00 1969 

c3i_system.sensors 1 1 

Wed Dec 31 16:00:00 1969 

c3i_system.track_database_manager.add_comms_track 1 1 
Wed Dec 31 16:00:00 1969 

c3i_systeni.track_database_manager.add_sensor_track 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.track_database_manager.filter_comms_track 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.track_database_manager.filter_sensor_track 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.track_database_manager.moniior_ownship_position 1 1 

Wed Dec 31 16:00:00 1969 
c3i_system.track_database_manager 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.user_interface.display_tracks 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.user_interface.emergency_status_screen 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.user_inierface.get_user_inputs 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.user_interface.manage_user_interface 1 1 
Wed Dec 31 16:00:00 1969 

c3i_system.user_interface.message_arrival_panel 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.user_interface.message_editor 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.user_interface.status_screen 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.user_interface 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.weapons_interface 1 1 
Wed Dec 31 16:00:00 1969 
c3i_system.weapons_systems 1 1 
Wed Dec 31 16:00:00 1969 

main oloughln cll c3i_system_prototype c3i_config_l 
commsjnterface 1 1 


51 




cotnms_links 1 1 

navigation_system 1 1 

sensor_interface 1 1 

sensors 1 1 

track_database_manager 1 1 

user_interface 1 1 

weapons_interface 1 1 

weapons_systems 1 1 


main oloughln cdt c3i_system_prototype c3i_config_l w 
c3i_system 11 

main oloughln vds c3i_system_prototype c3i_system 1 1 

Mon Jun8 14:51:38 1992 

oloughln 

main oloughln vdd c3i_system_prototype c3i_system 1 1 
Mon Jun 8 14:51:38 1992 

main oloughln vgl c3i_system_prototype c3i_system 1 1 
Wed Dec 31 16:00:00 1969 

main oloughln vgv c3i_system_prototype c3i_system 
1 1 

main oloughln vgd c3i_system_prototype c3i_system 1 1 

main oloughln vud c3i_system_prototype c3i_system descp 1 1 
This is a test file added to the design database for example purposes. 
Any thing can be added to it, and nothing can be expected back. 

main oloughln vgp c3i_system_prototype c3i_system 1 1 

main oloughln vgg c3i_system_prototype c3i_system 1 1 

main oloughln vgi c3i_system_prototype c3i_system 1 1 

IMPLEMENTATION 

GRAPH 

VERTEX comms_links : 1200 ms 
VERTEX comms_interface 
VERTEX track_database_manager 
VERTEX user_interface 


52 




VERTEX weapons_interface : 500 ms 
VERTEX weapons_systems : 500 ms 
VERTEX navigation_system ; 800 ms 
VERTEX sensor_interface 
VERTEX sensors : 800 ms 

EDGE input_link_message comms_links -> comms_interface 
EDGE tcd_network_setup user_interface -> comms_interface 
EDGE tdd_archive_setup user_interface -> comms_interface 
EDGE tcd_transmit_command user_interface -> comms_interface 
EDGE terminate_trans user_interface -> comms_interface 
EDGE tcd_emission_control user_interface -> comms_interface 
EDGE initiate_trans user_interface -> comms_interface 
EDGE comms_add_track comms_interface -> track_database_manager 
EDGE comms_emaU comms_interface -> user_interface 
EDGE position_data navigation_ system -> track_database_manager 
EDGE sensor_add_track sensor_interface -> track_database_manager 
EDGE tdd_filter user_interface -> track_database_manager 
EDGE out_tracks track_database_manager -> user_interface 
EDGE weapons_emrep weaponsjnterface -> user_interface 
EDGE weapons_statrep weapons_interface -> user_interface 
EDGE weapon_status_data weapons_systems -> weapons_interface 
EDGE position_data navigation_system -> sensor_interface 
EDGE sensor_data sensors -> sensor_interface 
DATA STREAM 

initiate_trans : initiate_transmission_sequence, 
terminate_trans : BOOLEAN, 
comms_add_track; add_track_tuple, 
position_data: ownship_navigation_info, 
position_data ; ownship_navigation_info, 
sensor_data: sensor_record, 
sensor_add_track: add_track_tuple, 
tdd_filter: set_track_filter, 
out_tracks: track_tuple, 
weapons_statrep : weapon_status_report, 
weapons_emrep; weapon_status_report, 
weapon_status_data : weapon_status, 
comms_email: filename, 
tcd_transmit_command : transmit_command, 
tdd_archive_setup: archive_setup, 
tcd_network_setup: network_setup, 
tcd_emission_control: emissions_control_command. 


53 


input_link_message; filename 


CONTROL CONSTRAINTS 
OPERATOR commsjinks 
PERIOD 50 SEC 

OPERATOR comms_interface 

OPERATOR user_interface 

OPERATOR track_database_manager 

OPERATOR navigation_system 
PERIOD 50 SEC 

OPERATOR sensor_interface 

OPERATOR sensors 
PERIOD 50 SEC 

OPERATOR weaponsjnterface 
TRIGGERED BY SOME 
weapon_status_data 

IF weapon_stanis_data.status = DAM OR weapon_status_data.status = 
service_required OR weapon_status_data.status = out_of_ammunition 

OPERATOR weapons_systems 

PERIOD 50 SEC 

END 

main oloughln vgc c3Lsystem_protot\T)e c3i_system 1 1 

OPERATOR c3i_system 

SPECmCATION 

DESCRIPTION { UNDEFINED_TEXT } 

END 

END COMMAND LINE TEST 


54 





B. EXAMPLES WITH CAPS SCREEN DUMPS. 


The testing conducted in section A was executed with a shell script. In this section a 
certain selection of design database commands will be executed to show how variation and 
versioning work. The examples are accompanied with screen dumps of CAPS graphic 
editor screens. These screens will display the changes made using the graphic editor which 
will correspond to the variations and versions stored in the database. 



Screen 1 shows a top level view of c3i_system. This view is stored in the database as 
object c3i_system variation 1, version 1. To access this object the operator name on the 
command line would be c3i_system. The actual name in the database is c3i_system_l, a 
concatenation of the object name and the variation number. The designers should not 
concern themselves the with the internal database name. The DDBMS handles the 
concatenation of the object name and variation number and also stripping off the variation 
number when the object name needs to be retrieved. 


55 














The command issued below retrieves from the database the object c3i_system 
variation 1, version 1, and displays all the operators and their variation and version numbers 
which are children of c3i_system. The listing, like the graphic editor view' only displays the 
current level view. 

main oloughln vU c3i_system_prototype c3i_system 1 1 


comms_interface 1 1 

comms_links 1 1 

navigation_system 1 1 

sensorjnterface 1 1 

sensors 1 1 

track_database_manager 1 1 

user_interface 1 1 

weapons_interface 1 1 

w'eapons_systems 1 1 


One name is listed for each object displayed in the graphic editor. 
c3i_system is a composite object which can be decomposed on the command line as 
well as in the graphic editor. 

Screen 2, is a graphic editor display of the decomposition of the object 
sensorjnterface. The listing shows that two objects make up c3i_system.sensor_interface 
variation 1. version 1. These two objects are both variation 1, version 1. These two displays 
demonstrate composite and atomic objects. c3i_system is a composite object composed of 
the nine objects listed above and displayed on screen 1. sensor_interface is a composite 
object composed of the two objects listed below and displayed on screen 2. 


c3 1 .syste*.sensor.interfsee 


nag lx 



The two objects displayed above make up the composite object, sensor_interface 
variation 1, version 1. The command below gives a listing of the objects names and their 
variation and version numbers. As with the view of c3i_system, the graphic display shows 
only the current level. The same is true of the object listed on the command line. The two 
objects listed from the command line are atomic objects. This is verified by executing the 
vll command on either of the two objects listed. As shown below, no output is sent to the 
screen. If no output is sent to the screen this signifies that the object is atomic and will not 
decompose. 

main oloughln vll c3i_system_prototype c3i_system.sensor_interface 1 1 
analyze_sensor_data 1 1 

prepare_sensor_track 1 1 


57 














main oloughln vll c3i_system_prototype 

c3i_system.sensor_interface.prepare_sensor_track 1 1 

On screen 3 the graphic editor shows that prepare_sensor_track has been modified by 
the addition loop_l. The graphic editor displays the object retrieved from the database. In 
this case it is c3i_system.sensor_interface variation 1, version 1. 
c3i_system.sensor_interface will not version, because of this modification, until it is 
reinserted into the database. After the modified object has been reinsened into the database 
the object c3i_system.sensor_interface will version and so will all its parents, until the root 
object has versioned. In this example c3i_system.sensor_interface.analyze_sensor_data, 
c3i_system.sensor_interface and c3i_system will all version. The following command from 
the command line demonstrates this versioning. 




grophic.aditor 


iT 


c31.system.sensor.1nterf ace 


Select 

s 

Houe 

Hodify ^ 
Specify 
Streams ^ 
Constraints^ 
Deconoose q 
C oenent ^ 
Label ^ 
MET ^ 

Latency 

\ b 
O o 




prototype Edit Font Pattern FgColor BgColor Phgn Option 


position.dAtA 



sensor^Add^ 

trAck 


SCREEN 3, c3i_system.sensor_interface. Variation 1, Version 2 


58 



















The vgv command lists all the variations and versions in the database for the 
c3i_system. As shown there are now two c3i_systems, c3i_systen variation 1, version 1 and 
c3i_systen variation 1, version 2. 

main oloughln vgv c3i_system_prototype c3i_system 
1 1 
1 2 

The vll command now shows that sensor_interface has versioned also. So c3i_system 
variation 1, version 2 contain sensor_interface variation 1, version 2. While c3i_system 
variation 1, version 1 contains object sensor_interface variation 1, version 1. Further 
decomposition shows c3i_system.sensor_interface variation 1, version 2 is made up of 
prepare_sensor_track variation!, version 1 and analyze_sensor_data variation 1, version 2. 
This reflects the changes made in the graphic editor. 


main oloughln vll c3i_system_prototype c3i_system 1 2 
comms_interface 1 1 

commsjinks 1 1 

navigation_system 1 1 

sensors 1 1 

track_database_n,anr.ger 1 1 

user_interface 1 1 

weapons_interface 1 1 

weapons_systems 1 1 

sensor_interface 1 2 

main oloughln vll c3i_system_protot>'pe c3i_system.sensor_interface 1 2 
prepare_sensor_track 1 1 

analyze_sensor_data 1 2 


Screen 4 shows a modification to the atomic object prepare_sensor_track variation 1, 
version 1. When reinserted into the database, this object and its parents up to and including 
the root object will version. This is demonstrated with the following commands. 


59 







SCREEN 4. c3i_systein.sensorJnterface, Variation 1, Version 3 


main oloughln vgv c3i_system_protot)’pe c3i_system 
1 1 
1 2 
1 3 

There are now 3 version of variation 1 of object c3i_system in the database. 
c3i_system variation 1, version 3 contains the following objects. 


main oloughln vll c3i. 

.system_prototype c3i_system 1 3 

comms_interface 

1 1 

comms_links 

1 1 

navigation_system 

1 1 


60 







sensors 1 1 

track_database_manager 1 1 

user_interface 1 1 

weapons_interface 1 1 

weapons_systems 1 1 

sensor_interface 13 


The object analyze_sensor_data variation 1, version 2 was not effected by the 
versioning of prepare_sensor_track variation 1, version 1 because it is not in the direct path 
between prepare_sensor_track variation 1, version 1 and the root object. In this example 
c3i_system.sensor_interface.prepare_sensor_data, c3i_system.sensor_interface and 
c3i_system all version. 

main oloughln vll c3i_system_protot\'pe c3i_system.sensor_interface 1 3 
analyze_sensor_data 1 2 

prepare_sensor_track 1 2 

In this next example c3i_system variation 1, version 2 was retrieved from the database. 
Using the graphic editor sensorjnterface was decomposed and then the 
prepare_sensor_track object was decomposed. Upon reinsertion of prepare_sensor_track a 
new object was created and prepare_sensor_track became a composite object containing 
the new objects constructed with the graphic editor. Screen 5 shows the new 
prepare_sensor_.track object created. As before each parent of the new object versioned. 
Because prepare_sensor_track variation 1, version 1 was modified and 
prepare_sensor_track variation 1, version 2 already exists a new variation w as created. This 
happened to each parent because a parent object with a greater version number already 
existed. The following commands show the new variations created becau.se of the 
modification of prepare_sensor_track variation 1. version 1. 


main oloughln vll c3i_system_prototype c3i_system 2 1 

comms_interface 

1 1 

commsjinks 

1 1 

navigation_system 

1 1 

sensors 

1 1 

track_database_manager 

1 I 

user_interfacc 

1 1 

weaponsjnterface 

1 1 

weapons_systems 

1 1 

sensor_interface 

2 1 


61 




main oloughln vll c3i_system_prototype c3i_system.sensor_interface 2 1 
analyze_sensor_data 12 

prepare_sensor_track 2 1 

main oloughln vll c3i_system_prototype 

c3i_system.sensor_interface.prepare_sensor_track 2 1 
bubble.l 1 1 

bubble_2 1 1 



SCREEN 5. c3i_system.sensor_interface,.prepare_sensor_track 
Variation 2, Version 1 


The object prepare_sensor_track variation 2, version 1 contains the objects bubble_l 
and bubble_2, both of which are variation 1, version 1. In this example a new level is 
created causing the parent objects to version and create new versions, alternate paths of 
development, because versions of a higher number existed on the same variation. 


62 

















C. TEST SHELL SCRIPT. 

#!/usr/local/bin/tcsh 

echo “START COMMAND LINE TEST “ 

echo 

echo 

echo “main oloughln pip c3i_system_prototype ‘Michael D. 0‘Loughlin’ descp “ 
main oloughln pip c3i_system_prototype “Michael D. O’Loughlin" descp 
echo 
echo 

echo “main oloughln pin “ 
main oloughln pin 
echo 
echo 

echo “main oloughln pll “ 
main oloughln pll 
echo 
echo 

echo “main oloughln pgd c3i_system_prototype “ 
main oloughln pgd c3i_system_protot>'pe 
echo 
echo 

echo “main oloughln pud c3i_system func_description “ 
main oloughln pud c3i_system_protot>T)e func_description 
echo 
echo 

echo “main oloughln pgd c3i_system_prototype “ 
main oloughln pgd c3i_system_protot>T)e 
echo 
echo 

echo “main oloughln prd c3i_system_prototype “ 
main oloughln prd c3i_system_prototype 
echo 
echo 

echo “main oloughln pgl c3i_system_prototype “ 
main oloughln pgl c3i_system_prototype 
echo 
echo 

echo “main oloughln pul c3i_system_prototype ‘Larry Williamson' “ 
main oloughln pul c3i_system_prototype “Larry Williamson” 
echo 


63 




echo 

echo “main oloughln pgl c3i_system_prototype “ 
main oloughln pgl c3i_system_prototype 
echo 
echo 

echo “main oloughln pds c3i_system_prototype” 
main oloughln pds c3i_system_prototype 
echo 
echo 

#-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x- 

x-x-x-x-x- 


echo “main oloughln cic c3i_system_prototype c3i_config_l ‘Michael D. 
OXoughlin’ descp “ 

main oloughln cic c3i_system_prototype c3i_config_l “Michael D. O’Loughlin” 
descp 
echo 
echo 

echo “main oloughln cln c3i_system_protot>pe “ 
main oloughln cln c3i_system_protot>pe 
echo 
echo 

echo “main oluughln cda c3i_system_prototype c3i_config_l “ 
main oloughln cda c3i_system_prototype c3i_config_l 
echo 
echo 

echo “main oloughln cgm c3i_system_prototype c3i_config_l “ 
main oloughln cgm c3i_system_prototype c3i_config_l 
echo 
echo 

echo “main oloughln cgd c3i_system_prototype c3i_config_l “ 
main oloughln cgd c3i_system_prototype c3i_config_l 
echo 
echo 

echo “main oloughln cum c3i_system_prototype c3i_config_l ‘Marty 
Shoppenheimer’ “ 

main oloughln cum c3i_system_prototype c3i_config_l “Marty Shoppenheimer” 

echo 

echo 

echo “main oloughln cgm c3i_system_prototype c3i_config_l “ 
main oloughln cgm c3i_system_prototype c3Lconfig_l 


64 




echo 

echo 

echo “main oloughln cud c3i_system_protot>’pe c3i_config_l func_description “ 
main oloughln cud c3i_system_protot>'pe c3i_config_l func_description 
echo 
echo 

echo “main oloughln cgd c3i_system_prototype c3i_config_l “ 
main oloughln cgd c3i_system_prototype c3i_config_l 
echo 
echo 

echo “main oloughln cpl c3i_system_prototype c3i_conrig_l ‘This is the first Post to 
c3i_system Log’ “ 

main oloughln cpl c3i_system_protot>'pe c3i_config_l “This is the fu-st Post to 
c3i_system Log” 
echo 
echo 

echo “main oloughln cgl c3i_system_prototype c3i_config_l “ 
main oloughln cgl c3i_system_prototype c3i_config_l 
echo 
echo 

echo “main oloughln cpl c3i_system_prototype c3i_conrig_l ‘This is the second Post 
to c3i_config_l Log’ “ 

main oloughln cpl c3i_system_protot>'pe c3i_config_l “This is the second Post to 
c3i_config_l Log” 
echo 
echo 

echo “main oloughln cgl c3i_system_protot>^e c3i_config_l “ 
main oloughln cgl c3i_system_protot>'pe c3i_config_l 
echo 
echo 

echo “main oloughln cln c3i_system_prototype” 
main oloughln cln c3i_system_prototype 
echo 
echo 

echo “main oloughln cds c3i_system_prototype c3i_conrig_l “ 
main oloughln cds c3i_system_prototype c3i_conrig_l 
echo 
echo 

#-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x- 

x-x-x-x-x- 


65 





echo “main oloughln vaa c3i_system_prototype c3Lsystem “ 
main oloughln vaa c3i_system_prototype c3i_system 
echo 
echo 

echo “main oloughln pll “ 
main oloughln pll 
echo 
echo 

echo “main oloughln vlo c3i_system_prototype c3i_system “ 
main oloughln vlo c3i_system_prototype c3i_system 
echo 
echo 

echo “main oloughln vll c3i_system_prototype c3i_system “ 
main oloughln vll c3i_system_protot>pe c3i_system 
echo 
echo 

echo “main oloughln vlo c3i_system_prototype c3i_system.comms_interface “ 
main oloughln vlo c3i_system_prototype c3i_system.comms_interface 
echo 
echo 

echo “main oloughln vll c3i_system_prototype c3i_system.comms_interface “ 
main oloughln vll c3i_system_protot\pe c3i_system.comms_interface 
echo 
echo 

echo “main oloughln 

c3i_system.comms_interface.convert_to_text_file “ 
main oloughln vlo 

c3i_system.comms_interface.convert_to_text_file 
echo 
echo 

echo “main oloughln 

c3i_system.comms_interface.convert_to_text_file “ 
main oloughln vll 

c3i_system.comms_interface.convert_to_text_file 
echo 
echo 

echo “main oloughln cao c3i_system_prototype c3i_config_l c3i_system 1 1 “ 
main oloughln cao c3i_system_prototype c3i_conrig_l c3i_system 1 1 
echo 
echo 

echo “main oloughln do c3i_system_prototype c3Lconfig_l “ 


vlo c3i_system_prototype 

c3i_system_protot>pe 

vll c3i_system_protoiype 

c3i_system_prototype 


66 





main oloughln do c3i_system_prototype c3i_config_l 

echo 

echo 

echo “main oloughln cll c3i_system_prototype c3i_config_l “ 
main oloughln cll c3i_system_prototype c3i_config_l 
echo 
echo 

echo “main oloughln cdt c3i_system_prototype c3i_config_l w “ 
main oloughln cdt c3i_system_prototype c3i_config_l w 
echo 
echo 

#-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x-x- 

x-x-x-x-x- 

echo “main oloughln vds c3i_system_protoiype c3i_system 1 1 “ 
main oloughln vds c3i_system_prototype c3i_system 1 1 
echo 
echo 

echo “main oloughln vdd c3i_system_prototype c3i_system 1 1 “ 
main oloughln vdd c3i_system_prototype c3i_system 1 1 
echo 
echo 

echo “main oloughln vgl c3i_system_prototype c3i_system 1 1 “ 
main oloughln vgl c3i_system_prototype c3i_sysiem 1 1 
echc 
echo 

echo “main oloughln vgv c3i_system_protot\T)e c3i_system “ 
mai: oloughln vgv c3i_system_protot>pe c3i_system 
echo 
ech^ 

echo “main oloughln vud c3i_system_prototype c3i_system descp 1 1 “ 
main oloughln vud c3i_system_prototype c3i_system descp 1 1 
echc 
echc 

echo “main oloughln vgd c3i_system_prototype c3i_system 1 1 “ 
main oloughln vgd c3i_system_prototype c3i_system 1 1 
echo 
echo 

echo “main oloughln vgp c3i_system_prototype c3i_system 1 1 “ 

#main oloughln vgp c3i_system_prototype c3i_system 1 1 
echo 


67 


echo 

echo “main oloughln vgg c3i_system_prototype c3i_system 1 1 “ 
#main oloughln vgg c3i_system_prototype c3i_system 1 1 
echo 
echo 

echo “main oloughln vgi c3i_system_prototype c3i_system 1 1 “ 
main oloughln vgi c3i_system_prototype c3i_system 1 1 
echo 
echo 

echo “main oloughln vgc c3i_system_prototype c3i_system 1 1 “ 
main oloughln vgc c3i_system_prototype c3i_system 1 1 
echo 
echo 

echo “main oloughln caa c3i_system_prototype c3i_config_l “ 
main oloughln cdt c3i_system_protot>'pe c3i_config_l 
echo 
echo 


echo “END COMMAND LINE TEST “ 


68 




APPENDIX D 


A. SOURCE CODE. 


69 






// File Header.. 

// 

// Filename : main.cxx 

//sees ID : 1.3 

// Release No. : 1 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

//.Modified by...; Michael D. O'Loughlin 

//.Modifications.: The modifications made to this module correspond to the 

// modicications made to.as of. 

// The modifications made to this module will. 

// The following operations were added or modified; 

// 1. 

// 2 . 

// 3. 

// 4. 

// The above modifications were made on. 

// Compiler : Glockenspiel C-h- 2.1 

// 

// End header comments. 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char main_SccsId[] = ■■@(#)main.cxx 1.3M9/16/91"; 

// Interface Dependencies. 

// 

#define DEBUG 
#include “debug.h" 

#ifndef _DDBDEFINES_H 
#include “ddbdefines.h" 

#endif 

#include “My_String.h” 

#include <Object.h> 

^include <Transaction.h> 

#include <Directory.h> 

#include <GlobalEntities.h> 


70 












#include <Database.h> 
#include <LisLh> 
#include <stream.hx3i> 


extern “C--” 

#inc]ude <stdlib.h> 
#include <stddef.h> 
#include <string.h> 
#include <ctype.h> 

} 


#ifndef _VOBJECTFUNC_H 
#include "vobjecifunc.h” 

#endif 

#ifndef _EV ALU ATION_H 
#include ''evaluation.h" 

#endif 

tifndef _PROTFUNC_H 
#include "protfunc.h” 

#endif 

#ifndef _CONFFUNC_H 
#include "conffunc.h” 

#endif 

// End Interface Dependencies. 

Type *V_OBJECT_OT\pe; 

7)1)6 *THREAD_OT)i)e; 

Type *COMPONENT_OType; 

Type *TEXT_OBJECT_OType: 

Type *PROTOTYPE_OType: 

Type *CONFIGURATION_OType: 

Type •DDB_OType; 

Directory •prototype_dir = (Directory* )0; 
Directory *ddbRootDir = (Directory* )0; 
List *myPrototypeList = (List*)0; 
char *database_name = (char *)0; 
char *userPtr = (char *)0; 
char *dirNamePtr = (char *)0; 


71 




void initialize_types(void); 

void setUpDirectory(char *. char *); 

int main(int argc. char *argvQ) 

I 

FTRACERrmain", “DDBCAPS.log”, 1); 
dirNamePtr = getenv(“PROTOTYPE”); 
userPtr = getenvC'USER”): 

Boolean done=FALSE; 
int menu_option=0; 

ifstream inFile; 

char *function_tag; 

int number_arguments; 
int run = 0; 

if (argv[l]) 

I 

database_name = new char[strlen(argv[l])+l]; 
strcpy(database_naine.argv[ 1 ]); 

} 

if (argv[2]) 

I 

function_tag = new char[strlen(argv[2])+l]; 
strcpy(function_tag, argv[2]); 

} 


number_arguments = argc - 3; 

// subtract the “design" “database" & “function" 

// from the argument(s) we evaluate. 

if (number_arguments < 0) 
t 

cerr « “<ERROk: Not enough arguments specified>'\n\n" 
« “ Format for Usage: '«Nn" 

« “ designdb dbasename function [argument. ...]Nn\n"; 
// INSERT CODE TO CLOSE TRACER FILE 
SETLMODE; 

DESTROYTRACER; 

exit(l); 


72 





if (C)C_open(database_name)) 


{ 

OC_transactionStart(); 

initializejypesO; 

setUpDirectory(argv[3]. function_tag); 

I 

else 

{ 

cerr « “<ERROR: Error attempting to open database “ 
« database_name 

« " —> database does not exist in registry\n\n'>n"; 

// INSERT CODE TO CLOSE TR.4CER FILE 
SETLMODE; 

DESTROYTRACER; 

exit(l); 


if (strlen(function_tag)<3 II strlen(function_tag)>3) 

{ 

cerr «••<ERROR: illegal function t>'pe--> <“ 

« function_tag « ”> >Nn”; 

} 

else 

I 

if (function_tag[0] = *P' II function_tag[0]='p') 
run = evaluate_prototype_function(upper(function_tag), 
number_arguments): 

else if (function_tag[0] == 'C II function_tag[01='c‘) 
run=evaluate_configuration_function(upper(function_tag). 
number_arguments); 

else if (function_tag[0] == 'V II function_tag[0]=='v’) 
run = evaluate_vobject_function(upper(function_tag). 
number_arguments); 

else if (function_tag[0] == 'H' II function_tag[OI=='h') 
run = evaluate_historical_function(upper(function_tag), 
number_arguments); 
else 
( 

cerr « “<ERROR: illegal function type-> <“; 
cerr « function_tag « "> >\n''; 


73 





} 


} 

switch (run) 

{ 

case LIST.PROTOTYPES: 
list_prot_func(number_argutnents); 
break; 

case LONG_LIST_PROTOTYPES: 
long_list_prot_func(number_arguments); 
break; 

case GET_PROTOTYPE_LEADER: 
get_prot_leader_func(number_arguments, argv[31); 
break; 

case DUMP_PROTOTYPE_SUMMARY: 
dump_prot_summar\_func(number_arguments, argv[3]); 
break; 

case GET_PROTOTYPE_DESCRlPTION; 
get_proi_description_func(number_arguments. argv(3]); 
break; 

case RETRIEVE_PROTOTYPE_DATE: 
retrieve. prot_date_func(number_arguments. argv[3]); 
breat; 

case INSERT_PROTOTYPE: 
insen_prot_func(number_arguments. argv[3). 
argv[4].argv[5]); 

break; 

case UPDATE_PROTOTYPE_LEADER; 
update_protJeader_func(number_arguments. 
argv[3], argv[4]); 

break; 

case UPDATE_PROTOTYPE_DESC; 
update_prot_desc_func(number_arguments. 
argv[3], argv[4]); 

break; 

case UPDATE_PROTOTYPE_NAME: 
update_prot_name_func(nuniber_arguments, 
argv[3]. argv[4]); 

break; 


case PROTOTYPE_VARIATION_LIST: 
list_prot_variations(number_arguments); 
break; 


74 




case PROTOTYPE_VERSION_LIST: 
list_prot_versions(number_arguments); 
break; 

case PROTOTYPE_VAR_AND_VER_LIST: 
list_prot_var_and_ver(number_arguments); 
break; 

case DUMP_CONnGURATION_SUMMARY: 
dump_conf_summary_func(number_arguments. 
argv[3]^gv[4]); 

break; 

case GET_LATEST_CONEIGURATION; 
get_latest_conf_func(nuinber_arguments, 
argv[3]); 

break; 

case ADD_CONFIGURATION_OPERATORS: 
add_conf_operators_func(number_arguments. 
argv[3].argv[4]); 

break; 

case DUMP_CONFIGURATION_OPER,\TORS: 
dump_conf_operators_func(number_arguments, 
argv[3].fxgv[4],argv[5]): 

break; 

case RELEASE_CONFIGURATION_LOCK: 
release_confJock_func(number_arguments. 
argv[3].argv[4]); 

break; 

case LONG_LIST_CONFIGURATION_OPERATORS: 
long_list_conf_operators_func(number_arguments. 
argv[3].argv[4]): 

break; 

case LlST_CONFIGURATION_OPERATORS: 
list_conf_operators_func(number_argumems. 
argv[3]argv[4]); 

break; 

case LIST_CONFIGURATION_DEFAULT_OPERATOR: 
list_conf_default_operator_func(number_argumenus, 
argv[3].argv[4]); 

break; 

case LIST_CONFIGURATIONS; 
list_conf_func(number_arguments, argv[3]); 
break; 

case UPDATE_CONFIGimATION_NAME: 
update_conf_name_func(nuiiiber_arguments. 


75 






argv[3]. argv[4]. 
argv[5]); 

tn^ak; 

case GET_CONFIGURATION_DESCRIPTION: 
get_conf_desc_func(number_arguments, 
argv[3], argv[4]); 

break; 

case INSERT_CONFIGURATION: 
insert_conf_func(number_arguments, argv[3], 
argv[4], argv[5], argv[6]); 

break: 

case UPDATE_CONnGURATION_DESCRIPTION: 
upclate_conf_desc_func(argv(3], argv[4]. 
argv[5]): 

break; 

case GET_CONEIGURATION_MANAGER; 
gel_conf_manager_func(number_arguments. 
argv[3]. argv[41); 

break; 

case UPDATE_C0NFIGURATI0N_MANAGER: 
update_conf_manager_func(number_arguments, argv[3]. 
argv(4]. argv[5]): 

break; 

case GET_C0NFIGURATI0N_DATE; 
get_conf_date_func(number_argiiments. 
argv[3],argv[4]); 

break; 

case GET_CONFIGURATION_CHANGED: 

case POST_CONFIGURATION_LOG: 
post_conf_log_func(argv[3]. argv[4]. argv[5]); 
break; 

case GET_CONFlGURATION_LOG: 
get_confJog_func(number_arguments, 
argv[3].argv[4]): 

break; 

case ATTACH.OPERATOR: 
attach_vobject_to_conf_func(number_arguments, 
argv(3]^gv[4], 
argv[5]^gv[6]^gv[7]); 

break: 

II .X.X.X-X 

// 

// VOBJECT CASE STATEMENTS 


76 






X 


X 


// 

//--X.X 

case LIST.OPERATORS: 
list_operaiors_func(nutnber_arguments^gv[3]. 
argv[4].argv[5]^gv[6]); 

break; 

case GET_VOBJECT_DESCRIPnON; 
get_vobjecl_desc_func(number_arguments, argv[3]. 
argv[41. argv[5]. argv[6]); 

break; 

case UPDATE_VOBJECT_DESCRIPnON: 
update_vobject_desc_func (nuinber_arguments, 
argv[3], argv[4], 
argv[5], argv[6]. argv[7]); 

break; 

case GET_VOBJECT_DATE: 
get_vobject_date_func(number_arguments. argv(3]. 
argv[4], argv[5]. argv[6]); 

break: 

case GET. VOBJECT_ VERS IONS: 
get_vobject_versions_func(number_arguments, 
argv[3], argv[4]); 

break: 

case GET.VOBJECT.LOCK; 
get_vobjectJock_func(number_arguments, 
argv[3],argv[4], 
argv[5], argv[6]); 

break; 

case GET_VOBJECT.\TRSION; 
get.vobject.version.funcO; 
break; 

case DUMP.VOBJECT.SUMMARY; 
dump_vobject_summary_fiinc(number_arguments. argv(3]. 
argv[4], argv[5], argv[6]); 

break; 

case GET.VOBJECT.POSTSCRIPT; 
get_vobjecl_psrde_func(number_arguments. argv(3]. 
argvI4]. argv[5]^gv[6]); 

break; 

case GET.VOBJECT.GRAPH; 
get_vobject.graphfile_func(number_arg'jmentsargv[3], 
argv[4]. argv[5]rfirgv[6]); 

break: 


77 





case GET_VOBJECT_IMPLEMENTATION: 
get_vobject_impfiIe_func(number_arguments, argv[3]. 
argv[4]. argv[5]argv[6]): 

break: 

case GET_VOBJECT_SPECIFICATION: 
get_vobject_specfile_func(number_arguments, argv[3]. 
argv[4]. argv[5],argv[6]); 

break: 

case GET_VOBJECT_SOURCE: 
get_vobject_sourcefile_func(number_arguments. 
argv[3]. argv[4], 
argv[5].argv(6]): 

break: 

case DUMP_VOBJECT_FILES: 
dump_vobject_files_func(number_arguments. 
argv[3]. argv[4], 
argv[5].argv(6], argv[7]): 

break: 

case DLfMP_VOBJECT_TREE: 
dump_vobject_tree_func(number_arguments. argv[3]. 

argv[+4], argv[5]. argv(6]. argv[7]): 

break: 

case ADD_NEW_VARIATION: 
add_new_variation_func(number_arguments. 
argv[3].argv(4], 
argv[5].argv[6]): 

break: 

case RELEASE_OPERATOR_LOCK: 
release_operator_lock_func(number_arguments. 
argv[3].argv(4]. 
argv[5].argv[6]): 

break: 

case RELEASE.SUBTREE.LOCK: 
release_subtree_lock_func(number_arguments, 
argv[3]4irgv[4]. 
argv[5]^gv[6]): 

break: 

case LONG_LIST_OPERATORS; 
longJist_operators_func(number_arguments^gv(3], 
argv[4]^gv(‘i]^gv[6]): 

break: 

case L0NG_L1ST_CHILDREN: 


78 




long_list_children_func(number_arguments.argv[3]. 

argv[4].argv[5]): 

break; 

case LONG_LIST_PARENTS: 
long_list_parems_func(number_arguments^gv[3]. 
argv[4]^gv[5]. argv[6]); 

iM-eak; 

case ERROR_IN_EVALUATION: 
cerr « “<ERROR; Error returned from evaluation” 
« “ function>\n”; 
break; 

case HISTORICAL_TRAn-; 
historical_trail(number_arguments,argv[3]. 
argv[4].argv[5], argv[6]); 

break; 

default: 

I 

cerr «'■<ERROR: Unknown error with function ” 
«■■ call..switch (run)...>\n”; 

// INSERT CODE TO CLOSE TRACER FILE 
SETLMODE; 

SETLMODE; 

DESTROYTRACER; 

exitd); 


} 

OC_transactionCommit(); 

OC_close(database_name); 

/* 1-27-92 cerr « NiNnDesign Database 
« "v 1.1 Copyright 1991(c) WP.D.A.L.G Inc.\n\n\n"; */ 
// INSERT CODE TO CLOSE TRACER FILE 
DESTROYTRACER: 
exit(O); 

) 


H . 

//END OF MAIN 

// 

H . 


void initialize_types(void) 

( 


79 






THREAD_OType=(Type *)OC_lookup(‘THREAD”); 
COMPONENT_OType=(Type * )(X: Jookup(“COMPONENT'): 
V_OBJECT_OType=(Type*)C>CJookup("V_OBJECr’); 
TEXT_OBJECT_OType=(Type*)OC_lookup(‘TEXT_OBJECT’); 
PROTOTYPE_OType=(Type *)OCJookup(“PROTOTYPE"); 
CONFIGURATION.OType = (Type *)OC_lookup(“CONFIGURATION”); 
DDB.OType = (Type *)OC_lookup(“DDB”); 

}; 

void setUpDirectory(char *protName. char *func_tag) 

{ 


ddbRootDir = (Directory *) OC_lookup(DESIGN_DATABASE_DIRECTORY); 
if(ddbRootDir) 

{ 

(Xr_setWorkingDirectory(ddbRootDir); 

myPrototypeList = (List *) C)C_lookup(PROTOTYPE_LlST); 

} 

else 

I 

ddbRootDir = new Directory(DESIGN_DAT.ABASE_DIRE(rTORY); 
ddbRootDir -> putObject(): 

OC_setWorkingDirectory(ddbRootDir); 

rnyPrototypeList = new List(OC_string.PROTOTYPE_LlST); 

myPrototypeList -> putObjectO; 

1 

char *yourDirChoice; 

if ((strcmp(func_tag, LIST_PROTOTYPE_UPC) == 0) 11 
(strcmp(func_tag, LIST_PROTOTYPE_LC) == 0) II 
(strcmp(fiinc_tag, LONG_LlST_PROTOTYPE_LC) — 0) II 
(strcmp(func_tag. LONG_LIST_PROTOTYPE_LT*C) = 0) 11 
(strcmp(func_tag, PR0T0TYPE_L1ST_VARIAT10N_LC) == 0) II 
(strcmp(func_tag. PROTOTYPE_LlST_VARIATION_UPC) == 0) II 
(strcmp(func_tag, PROTOTYPE_LIST_VERS10N_LC) = 0) II 
(strcmp(func_tag. PROTOTYPE_LIST_VERSION_UPC) == 0) II 
(strcmp(func_tag. PROTOTYPE_LlST_ALL_LC) == 0) II 
(strcmp(func_tag, PROTOTYPE_LIST_ALL_UPC) = 0)) 


( 

return: 

I 

else 

i 


80 


yourDirChoice = (char*)(My_String(protName) + My_Stxing(“_dir”)); 

1 

prototype_dir = (Directory *)(Xr_lookup(yoiirDirChoice); 

if ((!(strcmp(func,tag.INSERT_PROTOTYPE_UPC))=0) && 

(! (strcmp(func_tag,INSERT_PROTOTYPE_LC))=0) && 
(!(prototype_dir))) 

{ 

ceiT « “<ERROR: Prototype ” « protName 
« “ not found>\n’' 

« “<0^ you remember to tun “ 

« “INSERT PROTOTYPE first?>\n”; 

OC_transactionCommit(); 

OC_close(database_name): 

// INSERT CODE TO CLOSE TRACER FILE 
exit(O); 

} 

if (!protot\'pe_dir) 

{ 

prototype_dir = new Directory(yourDirChoice); 
prototype_(iir->putObject(); 
if (!prototype_dir) 

cerr« "Did not setup database directorvNn"; 
OC_setWorkingDirectory(protot>pe_dir); 

1 

else 

I 

OC_setWorkingDirectory(protot>'pe_dir); 


81 




// File Header.. 

// . : 

//.Filename.; componenth 

//Date ; 9/16/91 

// Author : Garr>' Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O'Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required 1 discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*1 

//Compiler ; Glockenspiel C-h-2.1 
// 

// End header comments. 


#ifndef _COMPONENT_H 
#define _COMPONENT_H 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char COMPONENT_h_Sccsld[] = "@(#)component.h 1..^9/16/91"; 

// Contents. 

// 

// COMPONENT 

// 

// Description 

// 

// Defines class COMPONENT. 

// 

//End. 

// Implementation Dependencies. 


82 











#include <n'ype.h> 

#include <LisLh> 

#include <Reference.h> 

#include "ReferenceMacros.h” 
#include <stream.hxx> 

//End Implementation Dependencies 

// Interface Dependencies. 

#ifndef _TEXT_OBJECT_H 
#include “text_object.h” 

#endif 


//End. 

TypeCheckReference(TextObjDictReference, Reference. List); 
//Class// 

class COMPONENT : public Object 

( 

private; 

TexiObjDictReference text_object_list; 
public: 

COMPONENT!); 

COMPON'ENTlAPL *theAPL); 

virtual void Destroy(Boolean abort = FALSE); 

virtual Type ‘getDirectTypeQ; 

void getComponentNamesO; 

Boolean getComponentSource(char*); 
void addTextObject(TEXT_OBJECT *); 

Boolean getPSfile(char*); 

Boolean getGRAPHfile(char*); 

Boolean getSPECfilelchar*); 

Boolean getIMPfile(char*); 

Boolean getSOURCEfile(char*); 
char *getTEXTPtr(char*); 

-COMPONENTO { Destroy(FALSE); |; 


3.3 








// Description- 

// 

// Defines an COMPONENT class. The class COMPONENT is a derived 
// class of Object. 

II 

H Constructor 
// 

// COMPON'ENT 

// 

// Constructs an COMPONENT object 

// 

// COMPONENT -APL 

// 

// ONTOS required constructor 

// 

H Public Members 
// 

// Destroy 

// 

// ONTOS heap mangagement method. 

// 

// gelDirectTvTW 

// 

// Return the O.NTOS Type of class COMPONENT. 

// 

// getComponentNames 

// 

// Display the file names of the file contained in the COMPON'ENT node 

// 

// getComponentSource 

// 

// Output the contents of an COMPONENT node to files. 

II 

H addTextObject 
II 

H Inserts a text_object into the COMPONENT node. 

II 

H getPSfile 
// 

// Output the .ps file contained in the COMPONENT node. 

// 

// getGRAPHfile 


84 





II 

H Output the .graph file contained in the COMPONENT node. 

II 

H getSPECfile 

II 

H Ouq)ut the .spec file contained in the COMPONENT node. 

// 

// getIMPfile 

// 

// Output the .imp file contained in the COMPONENT node. 

// 

// getSOURCEfile 

// 

// Output the .a file contained in the COMPONENT node. 

// 

// -COMPONENT 

// 

// Destructor for the CONfPONTNT class. 

// 

//End. 

#endif //_COMPONENT_H 


85 






// File Header. 

// . : 

//filename.: component.cxx 

//Date ; 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by ; Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications ; Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

// Compiler : Glockenspiel C++ 2.1 

// 

// End header comments. 


// sees ID follows; will compile to place date/time stamp in 
// object file 

static char COMPONENT_cxx_SccsId[] = “@(#)component.cxx 1.3Nt9/16/9r'; 

// Contents. 

// 

// COMPONENT: :COMPONENT ONTOS constructor 

// COMPONENT: :COMPONENT constructor 

// COMPONENT:'.getDireetType 

// COMPONENT::Destroy 

// COMPONENT:;getComponentNames 

// COMPON'ENT;;getComponentSource 

// COMPONENT;:addTextObject 

// COMPONENT; :getPSfile 

// COMPONENT: :getGRAPHf.le 

// COMPONENT; :getSPECfile 

// COMPONENT: :geaMPfile 

// COMPONENT: :getSOURCEfile 


86 










II 

// Description 

II 

H Implementation of class COMPONENT member functions. 

// 

//End- 


// TURN DEBUG-TRACE ON OR OFF 
#defme DEBUG 
#include “debug.h" 


// Implementation Dependencies 
#ifndef _DDBDEFIN’ES_H 
#include “ddbdefines.h" 

#endif 

#include <Object.h> 

#include <GlobalEntities.h> 


extern “C--" 


#include <strings.h> 

1 


#ifndef_TRACER_H 
#include “tracer.h" 

#endif 

#ifndef _COMPON'ENT_H 
#include “component.!!” 

#endif 

// End Implementation Dependencies— 

extern Type *COMPONENT_OType; 
extern Type *TEXT_OBJECT_OType; 

// ONTOS required constructor // 


87 








COMPONENT::COMPONENT(APL *theAPL):(theAPL) 


{ 

}; 

// Constructor // 

COMPONENT; ;COMPONENT() 

// Summary. 

// 

// Constructs a persistent COMPONENT object. 

// 

// Parameter 

// 

// None 

// 

// Functional description 

// 

// Creates a list to hold text objects, then reset a reference 
// to point to the list. 

// 

//End. 

{ 

initDirec tT ype( COMPONENT_OT\pe): 

List *newTextObjList = new List(TEXT_OBJECT_OT\pe): 
newTextObjList -> putObjectO; 
text_object_list.Reset(newTextObjList. this); 
putObjectO; 

1 ; 

// End Constructor COMPONENT;;COMPONENT// 

// Member Function // 

Type *COMPONENT;;getDirectType() 

// Summary. 

// 

// returns the ONTOS Type for the COMPONENT class. 

// 

// Return value 

II 

H A pointer to an ONTOS Type. 

// 


88 






w-w « r <w 

luNanssiFiED 


VERSTOir AND VHHIRT l Wr COWTROL OF ft 
ft COMPUTER ftlOEO PROTOTVPING SVSTER<U> NftVftL 
POSTWMUftTE SCHOOL HOHTEREV Cft N D (KLOUGHIN 
18 JUN 92 XS-HPS 


































































//End 


return COMPONENT_OType; 

); 

// End Member Function COMPONENT:;getDirectType // 

// Member Function // 

void COMPONENT;;Destroy(Boolean aborted) 

I 

if( aborted) 

i 

ObjectDesttoy (aborted): 

} 

1 

// End Member Function COMPONENT;;Destroy--- 

// Member Function // 

void COMPON'ENT;;getComponentNames() 

// Summary. 

// 

// Displays the name of each component in an COMPONTiNT object. 
II 

H Parameter 
// 

// None 

// 

// Functional description 

// 

// We get a pointer to the list and then create an iterator 
// for the list. W'e iterate over each text object and 
// display the contents of the name field. 

// 

// 

// End. 

( 

List *my_Iist = (List*)text_object_list.Binding(this); 

Listiterator my_iterator(my_list); 

TEXT_OBJECT •the_text_object; 


89 






while(my_iterator.moreData()) 


I 

the_text_object = (TEXT_OBJECT*)(Entity*)my_iterator(); 
the_text_object -> displayFileNameO; 

} 

) 

//End Member Function COMPONENT;:getComponentNames - 
// Member Function // 

Boolean COMPONENT::getComponentSource(char *fileMode) 

i 

List *my_list = (List*)text_object_list.Binding(this); 
Listiterator my_iterator(my_list); 

TEXT_OBJECT *the_text_object; 

Boolean write_failed = FALSE; 
while(my_iterator.moreData()) 

{ 

the_text_object = (TEXT_OBJECT*)(Entity*)my_iterator(); 
if (!the_text_object -> rebuildTextFile(fileMode)) 
write.failed = TRUE; 

1 

if (write_failed) 
return FAILED; 
else 

return SUCCESS; 

I 


// End Member Function COMP*ONENT:;getComponentSource- 

// Member Function // 

void COMPONENT;:addTextObject(TEXT_OBJECT *my_text_object) 

I 

List *my_list = (List*)text_object_lisl.Binding(this); 
my_list -> Insert(my_text_object); 
rnyjist -> putObjectO; 
putObjectO; 

) 

// End Member Function COMPONENT::addTextObject. 


90 







// Member Function // 


Boolean COMPONENT::getPSfile(char *fileMode) 

I 

List *my_list = (List* )text_object_list.Bin(iing( this); 

Listlterator my_iterator(my_list); 

while(my_iterator.moreData()) 

{ 

TEXT.OBJECT *the_text_object = (TEXT_OBJECT*)(Entity*)my_iteratorO: 
char *the_file_name = the_text_object->getFileName(); 
the_rile_name=(the_rile_name + 

(strlen(the_text_object->getFileName())-LENGTH_PS_EXT;): 

if(strcmp(the_file_name.PS_EXT)=0) 

( 

if (the_text_object->rebuildTextFile(fileMode)); 
return SUCCESS; 

I 

I 

I 


// End Member Function COMPONENT::geiPSfde — 
// Member Function // 

Boolean COMPONENT;;getSPECfile(char ‘fileMode) 

1 


List *my_Iist = (List*)text_object_list.Binding(ihis); 

Listlterator my_iteratorfmy_list); 
while(my_iterator.moreData()) 

{ 

TEXT_OBJECT *the_text_object = (TEXT_OBJECT*)(Entity*)my_iterator(); 
char *the_file_name = the_text_object->getFileName(); 
the_file_name=(the_file_name + 

(strlen(the_text_object->getFileName())-LENGTH_SPEC_EXT)); 

if(strcmp(the_file_name,SPEC_EXT)==0) 

( 

if (the_text_object->rebuitdTextFile(fileMode)) 
return SUCCESS; 
else 

return FAILED; 

) 


91 





) 


// End Member Function COMPONENT::geiSPECfile- 

// Member Function // 

Boolean COMPONENT::getGRAPHfile(char *fileMode) 

1 

List *my_list = (List* )text_object_list.Binding( this): 

Listiterator my_iterator(my_Iist); 
while(my_iterator.moreData()) 

( 

TEXT_OBJECT *the_text_object = (TEXT_OBJECT*)(Entity*)my_iteratorO; 
char *the_file_name = the_text_object->getFi]eName(): 
the_file_name=(the_file_name + 

(strlen(the_text_object->getFileName())-LENGTH_GR.\PH_EXT)); 
if(strcmp( the_file_name.GIL\PH_EXT)=0) 

( 

if (the_text_object->rebuildTextFile(fileMode)) 
return SUCCESS; 
else 

return FAH-ED; 


// End Member Function COMPONENT::getGRAPHfile- 

// Member Function // 

Boolean COMPONENT;;getIMPfi]e(char *fjleMode) 

I 

List *my_list = (List*)text_object_list.Binding(this); 

Listiterator my_iterator(my_list); 
while(my_iterator.moreData()) 

( 

TEXT_OBJECT *the_text_object = (TEXT_OBJECT*)(Entity*)my_iteralor(): 
char *the_file_name = the_text_object->getFileName(); 
the_file_name=(the_file_name + 

(strlen(the_text_object->getFileNameO)-LENGTH_IMP_EXT)); 

if(strcmp(the_file_name.IMP_EXT)=0) 

{ 

if (the_text_object->rebuildTextFile(rileMode)) 
return SUCCESS; 


92 




else 

return FAILED; 

) 

} 

) 


// End Member Function COMPONENT; :getIMPfile- 

// Member Function // 

Boolean COMPONENT:;getSOURCEfae(char *fileMode) 

{ 

List *my_list = (List*)text_object_list.Binding(this); 

Listlterator my_iterator(my_Iist); 
while(my_iterator.moreData()) 

i 

TEXT_OBJECT *the_text_object = (TEXT_OBJECT*)(Entity*)my_iterator(); 
char *the_file_name = the_text_object->getFileName(); 
the_file_name=(the_file_name + 

(strlen(the_text_object->getFileName())'LENGTH_SOLTlCE_EXT)); 

if(strcmp(the_rile_name.SOURCE_EXT)=0) 

{ 

if (the_text_object->rebuildTextFile(fileModeO 
return SUCCESS; 
else 

return FAILED; 

1 

} 

1 

// End Member Function COMPONENT: :getSOURCEfile. 

char *COMPONENT:;getTEXTPtr(char *TextType) 


List *myjist = (List*)text_object_list.Binding(this); 

Listlterator my_iterator(my_list); 
while(my_iterator.moreData()) 

1 

TEXT_OBJECT *the_text_object = (TEXT_OBJECr')(Entity*)my_iteratorO: 
char *the_rile_name = the_text_object->getFileName(); 
char *the_rile=(the_rile_name + 

(strlen(the_text_object->getFileName())- (strlen(TexiType)))); 
if(strcmp(the_file.TextType)=0) 

( 


93 







return the_text_object->text(): 


} 

) 

return (char *)0: 

} 


// End Member Function COMPONENT::getSPECfile 


94 





// File Header... 

// . : 

//filename.: conffunc.h 

//Date : 9/16/91 

// Author : Garry Lewis 

// ; Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required 1 discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*1 

H Compiler ; Glockenspiel C-m- 2.1 
// 

// End header comments. 


#ifndef _CONFFUNC_H 
#define _CONFFUNC_H 

#ifndef _CONFIGURATION_H 
#include "configuration.h" 

#endif 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char conffunc_h_Sccsld[] = •‘@(#)conffunc.h 1.3X19/16/91”; 

// Contents. 

// 

// Prototypes for functions related to manipulating 
// configurations. 

// 

^End. 


95 










void list_conf_func(int, char ’*); 

void diiinp_conf_summary_func(int,char *.char *); 

void geUalest_conf_func(int. char *): 

void attach_vobject_to_conf_func(int.char *. char *, char *. char *. char *); 

void update_conf_name_func(int, char*, char*, char*); 

void get_conf_desc_func(int, char*, char*); 

void inseit_conf_func(int, char*, char*, char*, char*); 

void update_conf_desc_func(char*, char*, char*); 

void get_conf_manager_func(int, char*, char*); 

void update_conf_manager_ftinc(int, char*, char*.char*); 

void get_conf_date_func(int, char*, char*); 

void post_conf_log_func(char*. char*, char*); 

void get_conf_log_func(int, char*, char*); 

//void dump_conf_operators_func(int.char *.char *); 
void dump_conf_operators_func(int.char *.char *,char *); 
void add_conf_operators_func(int,char *.char *); 
void release_confJock_func(int.char *.char *); 
void long_list_conf_operators_func(int.char *.char *); 
void list_conf_operators_func(int.char *,char *); 
void list_conf_default_operator_func(int,char *.char *); 
CONFIGURATION* getConfiguration(char*. char*): 

// Description. 

// 

// list_conf_func 

// 

// Provides a list of configurations associated with a 
// designated prototype. 

// 

// dump_conf_summary_func 

// 

// Provides summarv' information of a configuration to 
// to include; creation date, manager, version number and 
// default VOBJECT name, and a description. 

// 

// getJatest_conf_func 

// 

// Provides the name of the most recently added configuration. 

// 

// attach_vobject_to_conf_func 

// 

// Attaches an instance of the VOBJECT class to a configuration. 

// 

// update_conf_name_func 
// 


96 





// Changes the name of a designated configuration. 

// 

// get_conf_desc_func 

// 

// Provides a description of the designated configuration. 

II 

H insert_conf_func 
II 

H Creates a new configuration and binds it to a particular 
// prototype. 

II 

H update_conf_desc_func 
// 

// Updates the description text of a designated configuration. 

// 

// get_conf_manager_func 

// 

// Provides a configuration manager's name. 

// 

// update_conf_manager_func 

n 

H Changes a configuration manager's name. 

// 

// get_conf_date_func 

// 

// Provides the creation date of a given configuration. 

// 

// post_conf_Iog_func 

// 

// Adds a timestamped log entry (transbted char string) 

// to a configuration. 

// 

// get_conf_log_func 

II 

// Provides the text of a configuration log. 

II 

H dump_conf_operators_func 
II 

// Write a copy of the operators in a designated configuration 
// to disk. 

II 

H add_conf_operators_func 
// 

// Add operator from disk to a particular configuration in the 


97 



// database. 

// 

// release_conf_lock_func 

// 

// Provide a method to release locked operators in a given 
// configuration. 

// 

// long_list_conf_operators_func 

// 

// List all the children’s names and version numbers of a 
// given configuration. 

// 

// list_conf_operators_func 

H 

// List the immediate children's name and version number of 
// a given configuration. 

// 

// list_conf_default_operator_func 

// 

// Provides the name and version number of the default VOBJECT 
// assigned to the configuration. 

// 

// End Description. 

#endif // _CONFFUNC_H 


// File Header. 

// . : 

//.Filename.: conffunc.cxx 

//Date : 9/16/91 

// Author ; Garry Lewis 

// : Drew Dwyer 

// Modified by ; Michael D. O'Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required 1 discarded a lot of obsolete code and build a 


98 









new system on the base Dwyer and Lewis had established. 


*/ 

// Compiler ; Glockenspiel C-h- 2.1 

// 

// End header comments. 


// sees ID follows: will compile to place dateAime stamp in 
//object file 

static char conffunc_cxx_SccsId[] = “(a)(#)conffunc.cxx 1.3\t9/16/9r‘ 

// Contents. 

// 

// list_conf_func 
// dump_conf_summary_func 
// get_latest_conf_func 
// aitach_vobject_to_conf_func 
// update_conf_name_func 
// get_conf_desc_func 
// insert_conf_func 
// update_conf_desc_func 
// get_conf_manager_func 
// update_conf_manager_func 
// get_conf_date_func 
// post_conf_log_func 
// get_conf_log_func 
// dump_conf_operators_func 
// add_conf_operators_func 
// release_conf_lock_func 
// long_list_conf_operators_func 
// list_conf_operators_func 
// list_conf_default_operator_func 
// 

//End. 

// Implementation Dependencies. 

// TURN ON TRACE-DEBUG 
#define DEBUG 
#include “debug.h” 


99 








#include <stream.hxx> 
#include <Directory.h> 
#include “My_String.h" 


extern “C-” 


#include <sys/tinie.h> 
#include <sysAypes.h> 
#include <stdlib.h> 

} 


#ifndef _DIRECTOR Y_H 
#include "directory .h” 

#endif 

#ifndef _TREE_H 
#include "tree.h” 

#endif 

#ifndef _TREENODE_H 
#include “treenode.h" 

#endif 

#ifndef _PROTOTYPE_H 
#include "prototv-pe.h” 

#endif 

#ifndef_THRE.\D_H 
#include “thread.h" 

#endif 

#ifndef _CONFIGURATION_H 
#include "configuration .h" 

#endif 

#ifndef _CONFFUNC_H 
#inc)ude "conffunc.h" 

#endif 

#ifndef _VOBJECTFUNC_H 
#include “vobjectfunc.h” 

#endif 


#ifndef DDBDEFINES H 







#include “ddbdefmes.h" 

#endif 

PROTOTYPE ‘protoPtr; 

CONFIGURATION *configurationPtr; 
extern THREAD *threadPtr, 

// End Implementation Dependencies- 

ifstream inputfile: 

void list_conf_func(int number_arguments, char *argl) 

{ 

TRACER(“list_conf_func”): 

char* protot>'pe_name = (char*) (My_String(argl) + My_String(PROTOTYPE_EXT)); 

switch (number_arguments) 

( 

case 1: 

protoPtr = (PROTOTYPE* )OC_lookup(protot>pe_name); 
protoPtr -> listConfigurationsO; 
break; 
case 3: 
default: 

cerr«■■<ERROR: extra arguments in list conrigurations>\n"; 

I 


void dump_conf_summary_func(int number_arguments, char *argl. char *arg2) 

{ 

TRACER("dump_conf_summarv_func"); 
configurationPtr = getConfiguration(argl. arg2); 

switch(number_arguments) 


case 2: 

iffconfiguradonf^tr) 

I 

configurationPtr -> dumpConfigSummaryO; 

1 

break; 

default; 

cerr « “<ERROR; extra arguments in dump configuration summary>\n"; 

I 


101 





} 

void get_latest_conf_func(im number_argunients. char *argl) 

1 

TRACER("get_latest_conf_func"); 

char* prototype_naine = (char*) (My_String(argl) + My_String(PROTOTYPE_EXT)); 

switch (number_arguments) 

1 

case 1: 

protoPtr = (PROTOTYPE* )OCJookup(prototype_name); 
protoPtr -> gelDefaullConfigNameO; 
break; 
case 3; 
default: 

cerr« "<ERROR: extra arguments in get default configurations>\n"; 

} 


void attach_vobject_to_conf_func(int number_arguments, char *proto_name, 
char *config_name, char *operator_name. 
char *variationstr. char *versionstr) 

{ 

TRACER("attach_vobject_to_conf_func"): 

threadPtr = findThread(proto_name. operator_name): 
if (! threadPtr) 

{ 

return; 

} 

configurationPtr = getConriguration(proto_name, config_name); 

if (configurationP»tr) 
switch (number_arguments) 

I 

case 3; 

cerr « “CAO requires 5 arguments. Default values no longer valid.Nn"; 
bffeak; 
case 5: 

V_0 EJECT *variationPtr = threadPtr -> version(l); 

V_OBJECT ‘NewVariationPtr = variationPtr -> variation(atoi(variationstr)); 
threadPtr = NewVariationPtr -> getThread(); 

VOBJECT *vobjectPir, 

vobjeciPtr = threadPtr->version(atoi(versionstr)); 


102 





configuratioiiPtr->attachVobjecttoConrig(vobjectPtr); 

configurationPtr->putObject(); 

break: 

default: 

cerr « "<ERROR: invalid number args for get vobject description>Nn": 

} 


void update_conf_name_func(int number_arguments. char *argl. char *arg2. char *arg3) 

i 

TRACER("update_conf_name_func”): 
configurationPtr = getConfiguration(arg 1. arg2): 
switch (number_arguments) 

( 

case 3: 

if (configurationPtr) 

1 

configurationPtr -> updateConfigName(arg3): 

} 

break: 

default: 

cerr « "<ERROR; invalid number args for update Config NamoVi": 


void get_conf_desc_func(int number_arguments, char *argl. char *arg2) 

i 

TRACER("get_conf_desc_func”): 
configurationPtr = getConfiguration(argl. arg2): 

switch (number_arguments) 

( 

case 2: 

if (configurationPtr) 

{ 

configurationPtr -> getConfigDescription(): 

} 

break: 

default: 

cerr « “<ERROR: invalid number args for get configuration description>\n'': 

} 


103 





void insert_conf_func(int number_argunients. char *argl. char *arg2. char *arg3, char *arg4) 

I 

TRACER(“insert_conf_func”); 
configurationPtr = getConfiguration(argl, arg2); 

switch (number_arguinents) 

{ 

case 2: 

if (IconfigurationPtr) 

{ 

configurationPtr = new CONFIGURATION(arg2); 
protoPtr -> addConfiguration(configurationPtr); 

} 

else 

I 

cerr « "<ERROR; Configuration name " « arg2 « " already exists! >\n”; 
return; 

) 

break; 
case 3; 

if (iconfigurationPtr) 

{ 

configurationPtr = new CONFIGURATION(arg2, arg3); 
protoPtr -> addConfiguration(configurationF*tr); 

) 

else 

{ 

cerr « ‘■<ERROR: Configuration name " « arg2 « " already exists!>\n"; 
return; 

} 

break; 
case 4; 

if (IconfigurationPlr) 

{ 

configurationPtr = new CONFIGURAnON(arg2, arg3); 
inputfile.open(arg4. ios;;in); 
if (linputfile) 

{ 

cerr «*‘<File with config description contents does not exist>'n” 

«‘’<Constructing configuration w/Name & Manager only>'^"; 

1 

else 

I 


104 


configurationPtr -> updateConfigDescription(arg4.inputfile); 

I 

protoPtr -> addConfiguration(configiirationPtr): 
inputfile.closeO; 

) 

break; 

default: 

cerr«‘■<ERROR: invalid number args for insert configuraiion>Nn’'; 


} 


void update_conf_desc_func(char *argl. char *arg2. char *arg3) 

{ 

TRACER! "update_conf_desc_func”): 
configurationPtr = getConfigurationiargl. arg2); 
if (configurationPtr) 

{ 

inputfile.open(arg3, ios::in); 
if (Iinputfile) 

{ 

cerr « "<Fiie with config description contents not found>Nn’’ 
« "<Aborting update configuration operation>\n'*; 


else 

( 

configurationPtr -> updateConfigDescription(arg3. inputfile): 
inputfde.closeO: 


} 


void get_conf_manager_func(int number_arguments, char ‘argl, char *arg2) 

TRACER(“get_conf_manager_func”); 
configurationPtr = getConfiguration(arg 1, arg2); 

switch (number_arguments) 

{ 

case 2: 

if (configurationPtr) 

I 

configurationPtr -> getConfigManager(); 


105 


} 

break; 

default: 

cerr« "<ERROR: invalid number args for insert configuration>'vi’'; 

I 


void update_conf_manager_func(int number_arguments. char *argl. char *arg2. char *arg3) 

( 

TRACER(’‘update_conf_manager_func’‘); 
configurationPtr = getConfiguration(argl, arg2); 

switch (number_arguments) 

{ 

case 3: 

if (configurationPtr) 

I 

configurationPtr -> updateConfigManager(arg3): 

I 

break; 

default: 

cerr «■■<ERROR; invalid number args for update Config Managet>\n"; 


void get_conf_date_func(int number_arguments, char *argl. char *arg2) 

I 

TRACER("get_conf_date_func"); 
configurationPtr = getConfiguration(arg 1. arg2); 

switch (number_arguments) 

case 2: 

if (configurationPtr) 

I 

time_t systemtime = configurationfir -> getConfCreationDateO; 
cout« ctime(&systemtime) «'^n”; 

I 

break: 

default 

cerr « “<ERROR: invalid number args to get configuration creation date>\n"; 

1 


106 




I 


void post_conf_log_func(char *argl. char *arg2. char *arg3) 

{ 

TRACER(“post_conf_log_func”); 
configurationPtr = getConfiguration(argl. arg2); 

if (configurationPtr) 

I 

inputfile.open(arg3. ios::in); 
if (linputfile) 

{ 

configurationPtr -> addtoConfigLog(arg3); 

} 

else 

I 

configurationPtr -> addtoConfigLog(inputfile): 
inputfile.closeO; 


I 


void get_confJog_func(int number_arguments. char *argl. char *arg2) 

( 

TRACER("get_conf_Iog_func”): 
configurationPtr = getConfiguration(argl. argZ); 

switch (number_arguments) 

I 

case 2; 

if (configurationPtr) 
configurationPtr -> getConfigLogO; 


} 


void dump_conf_operators_func(int number_argumentsxhar •proto_naine.char *conf. 
char *writeOption) 


107 




{ 

TRACER(“dump_conf_operators_func''); 
configurationPir = getConfiguration(proto_name, conf): 

switch (number_arguments) 

( 

case 3: 

if (confjgurationPtr) 

{ 

V_OBJECT *vobjectPtr = configuralionPtr->getDefaultVobject(); 
if (vobjectPtr) 

{ 

cout« vobjectPtr->getNodeName() 

« “ " « vobjectPtr->getVersionNiimber{) 

« vobjectPtr->getVariationNumber() «‘Ni\n"; 

Boolean file_operation_successful = FALSE; 
file_operation_successful = 

vobjectPtr -> checkoutCOMPONENTNode(writeOption); //(fi]e_write_option): 
if (rile_operation_successftil) 
vobjectPu -> dumpSubtree(writeOption): 
else 

cerr« “<Error checking out" « vobjectPtr ->getNodeName() 

« “ Aborting dump_vobject_tree_func>\n"; 


else 

cerr«■■<ErTor: No Vobject is attached to dump configuration>\n”; 

I 

break: 

default: 

cerr « ■■<ERROR; invalid number args for dump configuration operators>\n"; 
t 


void add_conf_operators_func(int number_arguments.char *proto_name. char ‘conf) 

{ 

TRACER(“add_conf_operators_func''); 
configurationPir = getConfiguration(proto_name, conO; 

switch (numher_arguments) 

1 

case 2: 

if (configurationPir) 

I 

V_OBJECT ‘vobjectPtr = configurationPtr->getDefaultVobject(); 


108 




if (vobjectPtr) 


DIRECTORY *capsdireciory; 
capsdirectory = new DIRECTORY!); 

char *operator_naine = new char [strlen(vobjectPtr->getNaine())+l]: 
strcpy(operator_name.vobjectPtr->getName()); 
operator_naine[strlen(operator_naine) - 2] = ‘NO’; 
capsdirectory- >read_direc tory( operator_name); 
capsdirectory->updatetimestamp(); 

TREENODE_linkedIist operatorList = capsdirectory->getOperatorList(); 
TREENODE *rootnode = capsdirectory->find_treenode(operator_name); 
TREENODE ’*'tree_root = new TREENODE{rootnode.NULL); 

TREE ♦workingtree = new TREE(tree_root. operator_nanie); 
workingtree->build_tree(tree_root,operatorList); 

// cerr «‘■CHECKIN-> " « operator_name « "Nn”; 

V OBJECT *new_parent = (V_OBJECT *)0; 
new_parent= vobjectPtr->getParentO; 

V OBJECT *new_root = tree_root->checkin_node(new_parent); 
if (!new_root) 

I 

cerr« "<Error: Could not establish new_root in" 

«■■add_conf_operators_func. Aborting.>Vi"; 
break; 

1 

new_root->seLNodeName(tree_root->getname()); 

tree_root->checkin_subtree(new_root); 

1 

else 

cerr « "<EiTor: No Vobject is attached to this configuration>\n"; 

1 

break; 

default; 

cerr « “TERROR; invabd number args for list configuration operators>Nn"; 

1 


void release_confJock_func(int number_arguments, char *proto_name, 
char *conf) 

{ 

TRACER{‘‘teIease_conf_lock_func"); 
configurationPtr = getConfiguration(proto_name, conO; 

switch (number_arguments) 


109 



case 2: 

if (configurationPtr) 

I 

V_OBJECT *vobjectPtr = configuraiionPtr->getDefaultVobject(); 
if (vobjectPtr) 

( 

if (vobjectPtr'>reIeaseLockO) 

{ 

vobjectI*tr->putObjectO; 
vobjectPtr -> releaseLockSubtreeO; 


1 

else 

cerr « “<Error. No Vobject is attached to this configuration>\n”; 

} 

break; 

default: 

cerr « ■‘<ERROR; invalid number args for Release configuration locloNn"; 

1 

) 


void long_list_conf_operators_func(int number_arguments. char *proto_name. 
char *conO 

1 

TRACER(“long_list_conf_operators_func’'); 
configurationPtr = getConfiguration(proto_name. conO: 

switch (number_arguments) 

I 

case 2: 

if (configurationPtr) 

I 

V_OBJECT ‘vobjectPtr = configurationPtr->getDefaultVobject(); 
if (vobjectPtr) 

I 

vobjectPtr -> longlistOperatorNames(); 

1 

else 

cerr « “<Error: No Vobject is attached to this configuratioroNn": 


break; 

default: 

cerr « “<ERROR: invalid number args for list configuration operators>Nn"; 


110 



void list_conf_operators_func(int number_arguments. char *proto_name. 
char *conf) 

{ 

TRACER(“list_conf_operators_func”); 
configurationPtr = getConfigiiration(proto_name, conf); 

switch (nutnber_argunients) 

{ 

case 2: 

if (configurationPtr) 

{ 

V_OBJECT *vobjectPtr = configurationPtr->getDefaultVobject(); 
if (vobjectPtr) 

vobjectPtr -> listOperatorNamesO; 

1 

else 

cerr « “<Error: No Vobject is attached to this configuration>^r": 

I 

break; 

default: 

cerr «•'<ERROR: invalid number args for list configuration operators>Vi”: 

I 

} 

void list_conf_default_operator_func(int number_arguments. char *proto_name. 

char *conf) 

I 

TR.4CER("list_conf_default_operator_func"); 
configurationPtr = getConfiguration(proto_name, conO: 

switch (number_arguments) 

( 

case 2: 

if (configurationPtr) 

{ 

V_OBJECT •vobjectPtr = configurationPtr->getDefaultVobject(); 
if (vobjectPtr) 

{ 

char ♦name=vobjectPtr->getName(); 
name [strlen(name) - 2] = ‘\0’; 


Ill 




cout« name; 
int i=0; 

y^«*4i4e*****«* 

// Added following for statement for spacing... 

for (i=0;i<(PRINT_VERSION_L(X:ATION - 
strlen(vobjectPtr->getName()));i-H-) 
cout« “ 

cout« vobjectPtr->getVariationNumber(); 
cout« “ 

cout« vobjectPtr->getVersionNumber()« 

} 

else 

cerr «■■<ErTor; No Vobject is attached to this configuraiion>\n*’; 


break; 

default; 

cerr «■‘<ERROR: invalid number args for list" 
« “configuration default operator>\n”; 

1 


CONFIGURATION *getConfiguration(char *proto_name, char •config_name) 

{ 

CONFIGURATION *configurationPtr = (CONnGURATION *)0; 
char* prototype_name = 

(char*) (My_String(proto_name) + My_String(PROTOTYPE_EXT)); 
protoPtr = (PROTOTYPE*)OC_lookup(prototype_name); 

if (protoPtr) 

{ 

configurationPtr = (CONFIGURATION*)OC_lookup(config_name); 
if(!configurationPtr) 

{ 

cerr « “<This Configuration name does not” 

« “ exist for this prototype.>\n”; 


else 

I 

cerr « “<ERROR; Invalid Prototype name>'fl”; 

} 

return configurationPtr; 


112 




113 



// File Header. 

// . : 

//filename.: configuration.h 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

// Compiler ; Glockenspiel C++ 2.1 

// 

// End header comments. 


#ifndef _C0NF1GURAT10N_H 
#define _C0NnGURAT10N_H 

// sees ID follows: will compile to place date/time stamp in object file 

static char configuration_h_SccsId[] = “(2)(#)configuration.h 1.3\t9/16/9r': 

// Contents. 

// 

// CONFIGURATION 

II 

// Description 

II 

H Defines class CONFIGURATION 

// 

//End.. 

// Implementation Dependencies- 


114 











#include <Object.h> 
#include <Reference.h> 
#include <Dictionary.h> 
#include <stream.hxx> 


extern “C-” 


#include <sysAinie.h> 

#include <sys/types.h> 

} 

#include “ReferenceMacros.h" 

//End Implementation Dependencies- 

// Interface Dependencies. 

#ifndef _TEXT_OBJECT_H 
#include ‘■text_object.h” 

#endif 

#ifndef _VERSIONED_OBJECT_H 
#include ‘*versioned_object.h" 

#endif 

// End Interface Dependencies. 

TypeCheckReference(V_ObjectReference. Reference, V_OBJECT); 
TypeCheckReference(LogReference, Reference, TEXT_OBJECT); 
TypeCheckReference(Desc2Reference, Reference. TEXT_OBJECT); 

#define DEFAULT.MANAGER 

//Class// 

class CONFIGUR.' nON : public Object 

{ 

private; 

char conrig_status; 
char *config_manager; 
time_t ConfCreationDate; 
int config_num_vobjects; 

LogReference config_log_entry; 

Desc2Reference config_description; 


115 









V_ObjectReference theVersioned_Object; 
public: 

CONnGURATION{APL *); 

CONFIGlJRATION(char *name, char *manager=DEFAULT_MANAGER): 

virtual void Destroy(Boolean aborted=FALSE); 

virtual Type *getDirectTypeO: 

void getConfigNameO; 

char *naine(): 

void getConfigStatusO; 

void getConfigManagerO; 

void getConfigLx)g(); 

void getConfigDescriptionO; 

void dumpConfigSummaryO; 

void listConfigOperatorsO; 

void updateConfigManager(char *new_config_manager); 
void updateConfigNanie(char *new_config_name); 
void updateConfigStatus(char new_config_status); 
void addtoConfigLog(char *new_log_entry); 
void addtoConfigLog(ifstream&); 
void updateConfigDescription(char *, ifstream& ): 

V_OBJECT *CONFIGURATION::updateVobjectAttachmem(); 
void attachVobjecttoConfig(V_OBJECT*); 
time_t setConfCreaiionDateO: 
time_t getConfCreationDateO; 

V_OBJECT *getDefaultVobjeciO'. 

-CONFIGURATIONO { Destroy(FALSE); 1 


// Description- 

II 

H Defines a CONFIGURATION class. 

// 

// Constructor 

// 

// configuration --APL 

// 

// ONTOS required constructor 

// 

// configuration 

// 

// constructs a configuration object with the given name. 


116 







// and manager. 

// 

// Public Members 

// 

// destroy 

// 

// Used to cleanup memory during deletion and transaction aborts. 

// 

// getDirectType 

// 

// Returns the ONTOS type for this class. 

// 

// getConfigName; 

// 

// Sends the configuration name to standard out. 

// 

// name 

// 

// Returns a pointer to the configuration name. 

// 

// getConfigStatus 

// 

// Sends the configuration status to standard out. 

II 

// getConfigManager 

II 

// Sends the manager’s name for this particular configuration. 

II 

H getConfigLog 

// 

// Sends the configuration log to standard out. 

// 

// getConfigDescription 

// 

// Sends the configuration description to standard ouqiut. 

// 

// dumpConfigSummary 

// 

// Provides name, version number of root vobject. date and 
// description of configuration. 

// 

// listConfigOperators 

// 

// list the name of component operators in a configuration. 


117 







// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 

// 


updateConfigManager 

Changes the manager’s name for this configuration. 
updateConfigName 
Changes the configuration name. 
updateConf igS tatus 
Changes the configuration status field. 
addtoConfigLog 

A log to maintain a history of the configuration. 
updateConfigDescription 

Replaces the existing description if one exist or adds a new description. 

attachVobjecttoConfig 

Adds a versioned object to configuration. 

setConfCreationDate 

Time stamp this object w ith the current system time. 
getConfCreationDate 

Displays the time an instance of this class was created. 
getDefaultVobject 

Returns a pointer to the attach vobject. 

-configuration 

A destructor for the configuration class. 


// End 


#en(lif // _CONFIGURATION_H 


118 







// File Header- 

// . ; 

//filename.: configuration.cxx 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O'Loughlin 

//Date : 6/18/92 

// Modifications; Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*1 

I I Compiler : Glockenspiel C-h- 2.1 

// 

// End header comments- 


// sees ID follows: will compile to place date/time stamp in 
// object file 

static char configuration_cxx_SccsId[] = “@(#)configuration.cxx 1.3\t9/16/9r’; 

// Contents- 

// 

// C0NnGURAT10N::C0NFlGURAT10N ONTOS constnictor 

// CONnGURATION::CONFIGURATION new instance 

// CONnGURATION::Destroy 
// C0NFIGURAT10N::getDirectType 
// CONFIGURATION::getConfigName 
// CONFlGURATION::iiame 
// CONFIGURATION::getConfigStatus 
// CONFlGURAT10N::getConfigManager 
// CONFlGURATION;:getConfigLog 
// CONFIGURATION:;getConfigDescription 
// CONFlGURATION::dumpConfigSummary 
// CONFIGURATION::listConfigOperators 


119 










// CONFIGURATION::updateConfigManager 
// CONFIGURATIONiiupdateConfigName 
// CONFIGURATION::updateConfigStatus 
// CONFlGURATION::addtoConfigurationLog - string 
// CONFIGURATION:;addtoConfigurationLog - file 
// CONFIGURATION;;updateConfigDescription 
// CONFIGURATION: :anachVobjecttoConfig 
H CONFIGURAnON::setConfCreationDate 
// CONFIGURATION::getConfCreationDate 
// CONFIGURATION::getDefaultVobject 
// CONHGURATIONir-CONnGURATION 
II 

H Description 
II 

H Implementation of class CONFIGURATION member functions. 

// 

//End. 

// Implementation Dependencies. 

// TURN ON DEBUG-TRACE 
#define DEBUG 
#include “debug.h" 


#include <GlobalEntities.h> 
#include <Directory.h> 
#include <stream.hxx> 


extern “C-” 


#include <string.h> 

) 

// End Implementation Dependencies 

// Interface Dependencies- 

#ifndef _C0NF1GURATI0N_H 
#include “configuration.h" 

#endif 

#ifndef _DDBDEFINES_H 
#include “ddbdefines.h” 


120 










#en(iif 


// End Interface Dependencies- 

extern Type *V_OBJECT_OType; 
extern Type *CONFIGURATION_OType; 

// ONTOS required constructor // 

CONFIGURATION;:CONnGURATION(APL *theAPL): (theAPL) 

{ 

); 


// New Instance Constructors // 

CONFIGURATION::CONFIGURATION(char •name, 
char *manager):(name) 


// Summary. 

II 

H Constructs a persistent CONFIGURATION object This object 
// contains management (header information) about a CONFIGURATION 
H and a select group of modules in the configuration. 

// 

// Parameter 

II 

// name 

II 

H A pointer to a chr'acter string. 

// 

// manager 

II 

H A pointer to a character string. 

// 

// Functional Description 

// 

// Copies the manager's name into private data member. Initializes 
// the description and log entry to null and creates a dictionary to 
// hold the configuration modules. 

// 

//End- 


I 

initDirectType(CONFIGURATION_OType); 


121 







config_manager = new char(strlen(manager)+ll; 
strcpy(config_manager, manager); 
config_status = ‘A’; 
config_num_vobjects = 0; 

ConfCreationDate = setConfCreationDateQ; 
config_description.initToNull(); 
config_log_entry.initToNull(); 
theVersioned_Object.initToNull(); 

putObjectO; 


} 

// End Constructor for CONFIGURATION::CONnGURATION 
// Member Functions // 

void CONFIGURAT10N::Destroy(Boolean aborted) 

{ 

delete config_manager, 
if (aborted) 

{ 

Object;:Destroy(aborted): 

) 

1 

Type *CONFIGURAnON:;getDirectType() 

{ 

return CONFIGURATION.OType; 

} 


void CONFIGURATION:;getConfigName() 

{ 

Directory *directory; 
char ‘name; 

if(!this) 

{ 

cerr« “<ERROR: cannot get the name of a null C0NFlGURAT10N>\n”; 
return; 

) 

name = Name(); 

(X!_getNameComponents(name. &directory, &name); 
cout« name «'Nn”; 


122 





char *CONFIGURAnON::name() 

{ 

Directory ‘directory: 
char ‘name: 

name = Name(): 

C)C_getNameComponents(name. &directory. &name): 
return name: 

} 


void CONFIGlJRAnON::getConfigStatus() 

{ 

if(!this) 

{ 

cerr «'‘<ERROR: cannot get the Status of a null Configuration>\n": 
return: 

1 

cout« config_status « “\n”: 

1 


void CONFIGURATION::getConfigManager() 

( 

if(!this) 

{ 

ceiT «**<ERROR; cannot get the Manager of a null Configuration>\n 
return: 

} 

cout« config_manager «“Nn": 

) 


void CONFIGURATION: ;getConfigLog() 


ifC.this) 

{ 

cerr« “<ERROR: cannot dump the Log of a null Configuration>\n”: 
return: 

I 

if (!configJog_entry) 

I 

cerr « “<Cannot display an empty log>'«'‘: 
return: 

} 


123 





else 


( 

TEXT_OBJECT* myTextObject = (TEXT_OBJECT*)configJog_entry.Binding(ihis); 
myXextObject -> text(cout); 

} 

) 

void CONFIGURATION:;getConfigDescriptionO 

I 

if(!this) 

I 

ceir « “<ERROR: cannot get the description of a null Configuration>\n’'; 
return; 

} 

if (!config_description) 

( 

cerr « "<This configuration does not contain a description>Nn”; 
return; 

} 

else 

{ 

TEXT_OBJECT* myTextObject = (TEXT_OBJECT*)config_description.Binding(this); 
myTextObject -> text(cout); 

} 

1 


void CONFlGURATION::dumpConfigSummary() 

1 

TRACERC‘CONFIGlJRATION::dumpConfigSummary"); 
int i=0; 

cout« ctime(&ConfCreationDate); 
cout«“ “; 
getConfigManagerO; 
if(!theVersioned_Object) 

{ 

cout« “ “; 

for (i=0;i<PRINT_VERSION_LOCATION -strlenC'VOBJECT Name: NONE ASSIGNED “):i++) 
cout«‘ ■; 
cout« “ “; 
cout«“'n”; 

} 

else 

I 


124 




V_OBJECT "'vobjectPtr = (V_OBJECT*) theVersioned_Object.Bin(iing(this); 
char ♦name = vobjectPtr ->getNameO; 
name[strlen(name)-2] = 
cout« name; 

for (i=0;i < PRINT_VERSION_LOCATION - strlen(vobjectPtr->getNameO) - 
strlen(“VOBJECT Name: “) ; i++) cout« ‘ 
cout« “ 

cout« vobjectPtr -> getVariationNumber()« “ 
cout« “ 

cout« vobjectPtr -> getVersionNumberO «■%n”; 

} 

getConfigDescriptionO; 

) 

void CONFIGURATION::listConfigC)perators() 

{ 

if(! the V ersioned_Objec t) 

{ 

cerr« "This configuration does not contain a v_object"; 

} 

else 

{ 

V_OBJECT *the vobjectPtr = 

(V_OBJECT*) theVersioned_Object.Binding(this); 
theVObjectPtr -> getVObjNameO; 
theVObjectPtr -> listOperatorNames(); 

) 


void CONFIGURATION; :updateConfigManager(char *new_config_manager) 

I 

if(!this) 

{ 

ceiT « “<ERROR: cannot change the manager of a null C0NFIGURAT10N>\n’' 
return; 

if(config_manager) 

strcpy(config_manager, 

) 

config_manager = new char[strlen(new_config_manager)+l]; 
strcpy(config_manager, new_config_manager); 
putObjectO; 

) 


125 





void CONFIGURATION: :updateConfigName(char *new_config_name) 

if(!this) 

{ 

cerr « “<ERROR: cannot change the name of a NULL CONFIGURAnON>\n” 
return; 

} 

Name(new_config_name): 


void CONFIGURAnON;:updateConfigStalus(char new_config_status) 

{ 

if(!this) 

{ 

cerr « “<ERROR; cannot change the status of a null CONFlGURATION>Nn*‘: 
return; 

I 

config_status = new_config_status; 

} 


void CONFIGURATION::addtoConfigLog(char •newJog_entry) 

{ 

if(! config_log_entry) 

i 

TEXT_OBJECT *textObjectPtr = new TEXT.OBJECTO; 
textObjectPtr -> append(new_log_entry); 
config_log_entry.Reset(textObjectPtr, this); 

I 

else 

{ 

TEXT_OBJECT *textObjectPtr = 

(TEXT_OBJECT*) config_log_entry.Binding(this); 
textObjectPtr -> append(new_log_entry); 

I 

putObjectO; 

} 

void CONFIGURAnON:;addtoConfigLog(ifstream& input_file_stream) 

{ 


126 







if(! config_log_entry) 


i 

TEXT_OBJECT *textObjectPtr = new TEXT_OBJECT(); 
textObjectPtr -> append(input_file_stream): 
config_log_entry.Reset(textObjectPtr, this); 

1 

else 

TEXT.OBJECT *textObjectPtr = 
rrEXT_OBJECT*) config_log_entry.Binding(this); 
textObjectlhr -> append(input_file_streain); 

} 

putObjectO; 

} 


void CONFIGURATION;:updateConfigDescription(char *fileName. ifstream& input_file_stream) 

{ 

if(!config_description) 

{ 

TEXT.OBJECT *textObjectPtr = new TEXT_OBJECT(); 
textObjectPtr -> £4)r'"''HrfiieName. input_file_streani): 
config_description.Reset(textObjectPtr. this): 

} 

else 

{ 

TEXT.OBJECT ‘textObjectPtr = 

(TEXT_OBJECT*) config_description.Binding(this): 
textObjectPtr -> resetTheTextO; 
textObjectPtr -> appendlfileName, input_file_stream); 

} 

putObjectO; 

} 

V_OBJECT*CONFIGURATION::updateVobjectAttachment() 

I 

if ('.this) 

I 

cerr« “<ERROR; cannot set the v_object of a null configurationXn”; 
return NULL; 

1 


V_OBJECT ‘vobjectPtr = getDefaultVobject(); 
if (vobjectPtr) 


127 




{ 

THREAD *threadPtr = (THREAD *)OC_lookup(vobjectPtr->getNaine()); 
if (threadPtr) 
i 

vobjectPtr = uireadPtr->curTent(); 

theVersioned_ObjecLReset(vobjectPtr.this); 

putObjectO; 

} 

} 

return vobjectPtr; 

} 


void CONFIGURATION::attachVobjecttoConfig(V_OBJECT *theV_Object) 

( 

if (!this) 

{ 

cerr« “<ERROR: cannot set the v_object of a null configurationNn": 
return; 

) 

if (!theV_Object) 

{ 

cerr «''<ERROR: cannot give to a configuration a null v_object>\n“; 

I 

theVersioned_Object.initToNull(); 
theVersioned_Object.Reset(theV_Object, this); 

I 


//Member Function // 

time_t CONFIGURATION::setConfCreationDate() 

i 

time_t mytloc=0; 

time_t theTime; 

return theTime = time(mytloc); 

) 


//End 


// Member Function // 

time_t CONFIGURATION: :getConfCreationDate() 

I 

return ConfCreationDate; 


128 








} 


// Member Function // 

V_OBJECT * CONFIGURATION::getDefaultVobject() 

i 

return (V_OBJECT *)(Entity *)theVersioned_ObjecLBinding(this); 

} 

//End. 

// end functions 


129 






//FUe Header- 

// . : 

//Jilename.: ddbdefines.h 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required 1 discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

// Compiler : Glockenspiel C-h- 2.1 

// 

// End header comments. 


#ifndef _DDBDEFINES_H 
#define _DDBDEFINES_H 

// sees ID follows: will compile to place date/time stamp in object file 

static char ddbdefines_h_SccsId[] = ■'<S)(#)ddbdefines.h 1.3'^9/16/9r’; 

// Contents. 

// 

// Number Defines for Evaluations functions 

// 

// Description 

II 

H These #defines are all designed just to pass information back and forth 
// between the main program and the modules which evaluate the command line 
// for what function to run. There are basically three types of function 
// arguments CONFIGURATION arguments -- beginning with a 'C', PROTOTYPE 
// arguments -- beginning with a 'P', and VOBJECT functions -- beginning 
// with a ‘V’. All arguments are exactly 3 characters in length and must 
// conform to one of the valid arguments in the designed interface. All 


130 












// other arguments will be invalid and renim <Invalid Function> to the 
// Standard VO. 

II 

II 

II End —.. 

// Interface Dependencies- 

II 

//NONE 

II 

H End Interface Dependencies- 

struct DDBControlData 


char *prototype_name; 
char *v_object_name; 
int variation; 
int version; 

}; 

#define PRINT_CONnG_LOCATION 20 
#define PRINT. VERSION.LOCATION 50 
#define MAX.LINE.LENGTH 1024 
#define COMMAND.TABLE.SIZE 50 
#define SUCCESS TRUE 
#define FAILED FALSE 

#define LIST.PROTOTYPES 1 
#define LONG_LIST_PROTOTYPES 81230 
#define GET_PROTOTYPE_LEADER 2 
#defme GET_PROTOTYPE_DESCRIPTION 3 
#define RETRIEVE_PROTOTYPE_DATE 5 
#define INSERT.PROTOTYPE 6 
#define UPDATE_PROTOTYPE_LEADER 7 
#define UPDATE_PROTOTYPE_DESC 8 
#define UPDATE_PROTOTYPE_NAME 9 
#define GET.LATEST.CONHGURATION 10 
#define PROTOTYPE_VARIATION_LIST 11 
#define PROTOTYPE_VAR_AND_VER_LIST 12 
#define PROTOTYPE. VERSION.LIST 13 
#deftne DUMP.PROTOTYPE.SUMMARY 987 

#define LIST.CONRGURATIONS 21 

#define DUMP.CONFIGURATION.OPERATORS 91372 


131 








#define ADD_CONFIGURATION_OPERATORS 91378 

#define LONG_LIST_CONFIGURATION_OPERATORS 92351 

#define LIST_CONFIGURATION_DEFAULT_OPERATOR 6189 

#define LIST_CONFIGURATION_OPERATORS 91375 

#define UPDATE_CONFIGURATION_NAME 22 

#define GET.CONHGURATION.DESCRIPnON 23 

#define INSERT.CONHGURATION 24 

#define UPDATE_CONFIGURATION_DESCRIPnON 25 

#define GET.CONHGURATION.MANAGER 26 

#define UPDATE_CONFIGURATION_MANAGER 27 

#define GET.CONHGURATION.DATE 28 

#defineGET_CONnGURATION_CHANGED 29 

#define POST_CONnGURATION_LOG 30 

#define GET.CONHGURATION.LOG 31 

#define ATTACH_OPERATOR 32 

#define DUMP_CONFlGURATION_SUMMARY 33 

#define RELEASE.CONHGURATION.LOCK 8124 

#define LIST.OPERATORS 41 
#define GET_VOBJECT_DESCRIPTION 42 
#define GET_VOBJECT_DATE 43 
#define GET_VOBJECT_VERSIONS 44 
#denne GET_VOBJECT_LOCK 45 
#define GET_VOBJECT_VERSION 46 
#define DUMP_VOBJECT_SUMMARY 47 
#define GET_VOBJECT_POSTSCRIPT 48 
ttdefine GET_VOBJECT_GRAPH 49 
#define GET_VOBJECT_IMPLEMENTATION 50 
#define GET_VOBJECT_SPECIFICATION 51 
#define GET_VOBJECT_SOURCE 52 
#define UPDATE.VOBJECT_DESCRIPnON 53 
#define ADD.NEW.VARIATION 57 
#define ADD.VOBJECT.AND.SUBTREE 58 
#derine DUMP.VOBJECT.FILES 59 
#define DUMP.VOBJECT.TREE 60 
#define LONG.LIST.CHILDREN 61 
#define LONG.LIST.PARENTS 62 
#define LONG.LIST.OPERATORS 32981 
tdefine RELEASE.SUBTREE.LOCK 8281 
#derine RELEASE.OPERATOR.LOCK 8992 

#defifie HJSTORICAL.TRAIL 80 
#denne ERROR.IN.EVALUATION 9999 


132 



#denne LENGTH_PS_EXT 3 
#denne LENGTH_GRAPH_EXT 6 
#define LENGTH_IMP_EXT 9 
#define LENGTH_SPEC_EXT 10 
#define LENGTH_SOURCE_EXT 2 

#definePS_EXT“.ps” 

#define GRAPH_EXT “.graph” 

#define IMP_EXT “.imp.psdl” 

#define SPEC_EXT “.spec.psdl” 
tdefine SOURCE.EXT “.a" 

#define DESIGN_DATABASE_DIRECTORY “''DesignDatabase 
#define PROTOTYPE.LIST “PrototypeList” 

#define LONG_LIST_PROTOTYPE_UPC “PLL” 

#denne LONG_LIST_PROTOTYPE_LC "pU” 

#define LIST_PROTOTYPE_UPC “PLN” 

#defme LlST_PROTOTYPE_LC “pin” 

#defin€ INSERT_PROTOTYPE_UPC “PIP" 

#define INSERT_PROTOTYPE_LC “pip” 

#define PROTOTYPE_LIST_VARIATION_UPC “PLV” 

#define PR0T0TYPE_LIST_VARIAT10N_LC “plv” 

#define PROTOTYPE_LIST_VERSION_UPC “PVV” 

#define PROTOTYPE_LIST_VERSION_LC “pvv" 

#define PROTOTYPE_LIST_ALL_UPC “PVA” 

#define PROTOTYPE_LIST_ALL_LC “pva” 

#define PROTOTYPE.EXT “.pij" 

#endif// _DDBDEFINES_H 


// File Header- 

// . : 

//filename.; directory.h 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O'Loughlin 

//Date : 6/18/92 

// Modifications: Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 


133 








some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*1 

I I Compiler ; Glockenspiel C++ 2.1 

II 

H End header comments- 


#ifndef _DIRECTOR Y_H 
#define _DIRECTORY_H 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char directory_h_SccsId[] = “@(#)directory.h 1.3'49/16/91”; 

// Contents. 

II 

H DIRECTORY HEADER 

// 

// Description 

II 

H Defines class DIRECTORY. 

// 

//End- 

// Interface Dependencies- 

#ifndef _TREENODE_H 
tinclude “trecnode.h” 

#endif 

// End Interface Dependencies- 

class DIRECTORY 

1 

private: 

TREENODE_linkedlist operator_nodes: 


134 










public: 

DIRECTORY() {I; 

void read_directory(char *root_oper); 

void updatetimestampO; 

TREENODE *find_treenode(char *); 
TREENODE_linkedlist getOperatorListO; 
}; 


// Description- 

// 

// Defines class DIRECTORY. Class DIRECTORY is a non- 
// persistent class. 

// 

// Constructor 

// 

// DIRECTORY 

// 

// Public Members 

// 

// read_directory 

// 

// Read a list of file from a directory defined by the environment 
// variable PROTOTYPE, creates a corresponding list of operator nodes. 
// 

// updatetimestamp 

// 

// Updates the nodes time to reflect the time of the file 
// most recently updated. 

// 

// find_treenode 

// 

// Find a given node in the list of operator nodes. 

// 

// getOperatorList 

// 

// Returns the operator node list. 

// 

// End Description- 

#endif // header file 


135 





// File Header... 

// . : 

//.Filename.: direciory.cxx 

//.sees ID.: 1.3 

//Jlelease No....; 1 

//.Date.: 9/16/91 

//.Author..: Garry Lewis 

//.: Drew Dwyer 

//.Modified by...: Michael D. O'Loughlin 

//.Modifications.: The modifications made to this module crarespond to the 

// modicications made to.as of. 

// The modifications made to this module will.. 

// The following operations were added or modified; 

// 1. 

// 2 . 

// 3. 

// 4. 

// The above modifications were made on. 

//.Compiler.: Glockenspiel C++ 2.1 

// . : 

// End header comments. 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char directory_cxx_SccsId[j = ''@(#)directory.cxx 1.3Nt9/16/9r'; 

// Contents. 

// 

// DIRECTORY.:read_directory 
// DIRECTORY: ;updatetimestamp 
// DIRECTORY::find_treenode 
// DIRECTORY; ;getOperatorList 
// 

// Description 

// 

// IMPLEMENTS class DIRECTORY CONSTRUCTORS. 

// 


// Interface Dependencies- 

// TURN ON DEBUG.TRACE 


136 























#define DEBUG 
tinclude “debug.h” 
#include “My_String.h” 
finclude <stTeain.hxx> 


extern “C--” 

{ 

* #include <stddef.h> 

#include <stdlib.h> 
#include <string.h> 
#include <dirent.h> 
#include <sys/stath> 
#include <time.h> 

I 


#ifndef _DIRECTORY_H 
#include “directory.h” 

#endif 

#ifndef _DDBDEFINES_H 
#include ‘ddbdefines.h” 

#endif 

//- End Interface Dependencies - 

extern char ‘dirNafnePtr; 

void DIRECTORY;;read_directory(char *root_oper) 

{ 


H - 

// In body comment: 

// 

// Here I will create the list to hold those filenames that 
// contain (as a substring) the operator name. This method 
// will also scan those files that do match the pattern input 
// and throw out those with the .ps, .graph, .imp.psdl. .^lec.psdl 
// and .a files. What I hope will remain is a list of only those 
// filenames which represent that operator node and it's 
// associated SUBTREE operator nodes. We'll then turn around and 
// process the resulting list into an operator tree structure and 
// compare against the database schema for storage of the 
// .ps. graph, .spec.psdl. .imp.psdl. and .a text objects into 
// the database as collected sets of COMPONENT objects. 


137 






// 

II - 

TRACER(“DIRECTORY;;read_directory”); 

DIR *dirp; 

struct dirent *capsdirent; 

char *path[MAX_LINE_LENGTH]; 

char ♦pschk = NULL; 

char ♦graphchk =NULL; 

char *specchk = NULL; 

char *impchk = NULL; 

char *sourcechk =NULL; 

TREENODE *operatomode =NULL; 
char *filename = NULL; 
strcpy(path,(lirNaniePlr); 
dirp = opendir(dirNainePtr); 
int count=0; 

TREENODE *temp; 

TRACE(root_oper); 

for (capsdirent = readdir(diip); capsdirent != NULL; 
capsdirent = readdir(dirp)) 

{ 

61ename=capsdirent->d_name; 

TRACE(filename); 

pschk = capsdirent ->d_nanie + strlen(capsdirent ->d_name) - 3; 
graphchk = capsdirent ->d_name + strlen(capsdirent ->d_name) - 6; 
specchk = capsdirent ->d_name + strlen(capsdirent ->d_nanie) - 10; 
impchk = capsdirent ->d_name + strlen(capsdirent ->d_name) - 9; 
sourcechk = capsdirent ->d_name + strlen(ct^sdirent ->d_name) - 2; 

if (strcmp(pschk,”.ps'')=0) 

( 

pschk[0] = ‘\0’; 

1 

else if (strcmpfgraphchk ”.graph”)=0) 

{ 

graphchk[0] = ‘NO’; 

} 

else if (strcmp(specchk,”.spec.psdl”)=0) 

{ 

specchk[0] = ‘M)’; 

I 

else if {strcmp(impchk.’'.imp.psdl”)==0) 

{ 


138 







impchkfO] = 

) 

else if (strcmp(sourcechk.”.a”)=0) 
i 

sourcechk[0] = ‘M)’; 

} 


if (stmcmpicapsdireni ->d_nainejroot_oper,strlen(root_oper))=0) 

I 

TRACE(capsdirent->d_nanie): 

TRACE(root_oper); 

if (!(iemp=find_treenode(capsdirent-xl_name))) 

operatomode = new TREENODE(capsdirent->d_nameJNULL): 
TRACEC A NEW OPERATOR NODE IS BEING INSERTED' ); 
TRACE(capsdirent->d_name); 
operaior_nodes.insert(operatomode); 

} 


closedir(dirp); 

} 

void DIRECTORY::updatetimestainp() 

{ 

DIR *dirp; 
struct dirent ♦filep; 

struct stat timestats; 

char *psfilename = NULL: 
char *graphfUename = NULL; 
char *specfdenaine = NULL; 
char ^impfilename = NULL; 
char *sourcefilename = NULL; 
char* path; 

char •node_name = NULL; 

TREENODE *node; 

long temptime = 0; 

long filetime = 0; 

dirp = opendir(dirNamePtr); 

slist_iterator OperatorPtr(operator_nodes); 


139 





while (node = OperatorPtrO) 


{ 

node_name = node->getname(); 

psfilename = (char*)(My_String(node_name) + My_String(“.ps’*)); 
graphfilename = (char*)(My_String(node_name) + My_String(".graph”)): 
impfilename = (char*)(My_String(node_naine) + My_String(“.inip.psdl’*)): 
specfilename = (char*)(My_String(node_naine) + My_StringC‘.spec.psdJ”)); 
sourcefilename = (char*)(My_String(node_naine) + My_String(“.a”)); 

filep = readdirCdilp); 

while ((filep != NULL) && (!(strcmp(filep->d_name,psfilename)==0))) 

( 

filep = read(lir(dirp); 

} 

if ((filep != NULL) && (sucinp(filep->d_naine,psfilenanie)==0)) 

( 

path = (char *)(My_String(dirNainePtr) + My_String("/*‘) + 
My_String(filep->d_name)); 
staKpaih .& timestats): 
filetime = tiniestats.st_ctime; 
temptime = node->getJong_time(): 

node->updatetimestamp(temptime < filetime ? filetime ; temptime); 

1 


rewinddir(dirp); 
filep = readdir(dirp); 

while ((filep != NULL) && (!(strcmp(filep->d_name,graphfilename)=0))) 

{ 

filep = readdir(dirp); 

} 

if ((filep != NULL) && (strcmp(filep->d_name,graphfilename)==0)) 

{ 

path = (char *)(My_String(dirNamePtr) + My_String(“r) + 
My_String(filep->d_name)); 
stat(path.&timestats); 
filetime = timestats.st_ctime; 
temptime = node->get_long_time(); 

node->iipdatetimestamp(temptime < filetime ? filetime: temptime): 

) 


rewinddir(dirp); 
filep = readdir(dirp): 


140 




while ((filep != NULL) && (!(strcmp(filep->d_naineimpfilename)=0))) 
filep = readdir(diip); 

} 

if ((filep != NULL) && (strcinp(filep->d_nanne,impfilename)==0)) 

{ 

path = (char *)(My_String((iirNamePtr) + My_String("/’’) + 
My_String(filep->d_name)); 
stat(palh.&ti(nestats); 
fUetime = timestats.st_ctime; 
temptiine = node->get_long_time(); 

node->updaietiinestamp(temptime < filetime ? fdetime ; temptime); 

) 

rewinddir(dirp): 
filep = readdir(diip); 

while ((filep != NULL) && (!(strcmp(filep->d_name.specfilename)==0))) 

{ 

filep = readdir(dirp); 

} 

if ((filep != NLT.L) && (strcmp(filep->d_name.specfilename)==0)) 

{ 

path = (char *)(My_String(dirNamePtr) + My.StringfD + 
My_String(filep->d_name)); 
stat(path.&timestats); 
filetime = timestats.st_ctime: 
temptime = node->get_long_time(); 

node->updatetimestamp(temptime < filetime ? filetime : temptime); 

} 

rewinddir(dirp); 
filep = readdir(dirp); 

while ((filep != NULL) && (!(strcmp(filep->d_name,sourcefilename)=0))) 

{ 

filep = readdir(dirp); 

) 

if ((filep != NULL) && (strcmp(filep->d_name,sourcefilename)=0)) 

1 

path = (char *)(My_String(dirNamePtr) + My_String(‘T) + 
My_String(filep->d_name)): 
stat(path.&timestats); 
filetime = timestats.st_ctime; 
temptime = node->get_long_time(); 

node->updatetimestamp(temptime < filetime ? filetime; temptime); 


141 





} 

tewinddiltdirp); 

} 

closedir(diip); 

} 


TREENODE •DIRECTORY::find_treenode(char *node_naine) 

slistJteratorlist_iteralor(operator_nodes); 

TREENODE *tnode; 
while (tnode=listJterator()) 
if (strcmp(tnode->getname(),node_name)=0) 
return tnode; 
return NULL; 

I 


TREENODE.linkedlist DIRECTORY:;getOperatorList() 

I 

return operator_nodes: 

} 


142 






// File Header- 

// . : 

//JFilename.: evaluation.cxx 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O'Loughlin 

//Date : 6/18/92 

// Modifications ; Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required 1 discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

// Compiler : Glockenspiel C++ 2. 1 
11 

H End header comments- 


// sees ID follows: will compile to place date/time stamp in 
// object file 

static char evaluation_cxx_SccsId[] = “@(#)evaluation.cxx 1.3\t9/16/9r': 

// Contents. 

// 

// charupper 
// upper 

// evaluate_configuration_function 
// evaluate_historical_function 
// evaluate_vobject_function 
// evaluate_prototype_function 
// 

// Description 

// 

// Defines FUNCTIONS FOR SWITCH STMT IN MAIN. 

// 

// This information is required to evaluate the command 


143 











// line input and reconstruct the proper commands internal 
// to the design database program. 

// 

// 

//End- 

// Interface Dependencies- 

#define DEBUG 
#include “debug.h” 

#ifndef _DDBDEFINES_H 
#include “ddbdefines.h" 

#endif 

tinclude <stream.hxx> 
extern “C-” 


#include <stdlib.h> 
#include <string.h> 
#include <ctype.h> 
} 


#ifndef _EVALUATION_H 
#include "evaluaiion.h" 

#endif 

// End Interface Dependencies. 

char charupper(char c) 

{ 

return islowerfc) ? (c-'a'+'A'): c; // change char to upper case 

I; 


char •upper(char •argument) 

{ 

int i; 

for (i=0: i<strlen(argument); i-t-f) // convert argument to upper case 
argument[i] = charupper(argument[i]); // call charupper to convert each one 
return argument; 

I: 


int evaluate_historical_function(char •function, int arguments) 


144 









i 

if (strcinp(function,”HTT’)==0) 

{ 

if (arguinents<4 II arguments >4) 

{ 

cerr « “<ERROR; Invalid number arguments for Historical Trail>\n”: 
return ERROR_IN_EVALUATION; 

} 

else 

return HISTORICAL_TRAIL; 

} 

) 

int evaluate_configuration_function(char *function. int arguments) 

{ 

if (strcmp(function,"CLN")==0) 

{ 

if (arguments<l II arguments >1) 

I 

cerr «''<ERROR: Invalid number arguments for List Configurations>\n"; 
return ERROR_LN_EVALUATION; 

} 

else 

return LIST_CONFIGURATIONS; // tell main() to run LislJPrototypes 

1 

else if (stix:mp(function,"CUN'')==0) 

I 

if (arguments<3 II arguments>3) 

cerr« “<ERROR: Invalid number of arguments for Update Configuration Name>\n’ 
return ERROR_IN_EVALUATION; 

) 

return UPDATE_CONFIGURATION_NAME; 

} 

else if (strcmp(function.”CGD”)==0) 

i 

if (arguments<2 II arguments >2) 

{ 

cerr« “<ERROR: Invalid number arguments for Get Configuration Description>'n" 
return ERR0R_IN_EVALUAT10N; 

) 

return GET_CONnGURATION_DESCRIPnON; 

I 

else if (strcmp{function.''CIC”)=0) 


145 



{ 

if (!arguments>0) 

{ 

cerr« “<ERROR: Not enough arguments for Insert Configuration>\n”; 
return ERROR_IN_EVALUATION; 

I 

return INSERT.CONHGURATION; 

} 

else if (strcmp(function.”CUD”)==0) 

I 

if (arguments<3 II arguments>3) 

{ 

cerr « “<ERROR: Invalid number arguments for Update Configuration DescTiption>Nn" 
return ERROR_IN_EVALUATION; 

} 

return UPDATE_C0NFIGURAT10N_DESCRIPTI0N; 

) 

else if (strcmp(function,”CGM’’)==0) 

I 

if (arguments<2 II arguments >2) 

( 

cerr «'‘<ERROR: Invalid number arguments for Get Configuration Manager>\n": 
return ERROR_IN_EVALUATION; 

} 

return GET_C0NFIGURAT10N_MANAGER: 

} 

else if (sircmpifunction "CDT’)=0) 

I 

if (arguments<3 II arguments>3) 

cerr « “<ERROR: Invalid number arguments for Checkout Configuration>'vi”; 
return ERROR_IN_EVALUATION; 

1 

return DUMP_CONFIGURATION_OPERATORS; 

) 

else if (strcmp(function,’'CRL”)==0) 

I 

if (arguments<2 II arguments>2) 

cerr « “<ERROR: Invalid number arguments for Release Configuration LocloVi"; 
return ERROR_IN_EVALUATION; 

) 

return RELEASE_CONFIGURATION_LOCK; 

} 


146 




else if (strcmp(function,”CAA”)=0) 


1 

if (arguments<2 II arguments>2) 

( 

cerr « “<ERROR: Invalid number arguments for Checkin Configuration>'fl”; 

^ return ERROR_IN_EVALUATION; 

) 

return ADD_CONFIGURATION_OPERATORS: 

} 

• else if (strcmp(function,”CLL”)=0) 

{ 

if (arguments<2 II arguments>2) 

{ 

cerr « “<ERROR: Invalid number arguments for List Configuration Operators>'ji": 
return ERROR_IN_EVALUATION; 

} 

return LONG_LIST_CONnGURATION_OPERATORS; 

} 

else if (strcmp(function,”CLV”)=0) 

{ 

if (arguments<2 II arguments>2) 

{ 

cerr« “<ERROR: Invalid number arguments for List Default Configuration Operator>Nn' 
return ERROR_IN_EVALUATION; 

} 

return LIST.CONHGURATION.DEFAULT.OPERATOR: 

I 

else if {strcmp(function,"CLO’')=0) 

1 

if (arguments<2 II arguments>2) 

( 

cerr « “<ERROR: Invalid number arguments for List Configuration Operators>Vi"; 
return ERROR_IN_EVALUATION; 

I 

return LIST_CONFIGURATION_OPERATORS: 

) 

else if (strcmp(function.”CUM”)==0) 

{ 

if (arguments<3 II arguments>3) 

{ 

cerr « “<ERROR: Invalid number arguments for Update Configuration Manager>Vi’'; 

• return ERROR_IN_EVALUATION; 

} 

return UPDATE_CONFIGURATlON_MANAGER; 


147 






} 

else if (strcmp(function,”CDA”)==0) 

{ 

if (arguments<2 II arguments >2) 

i 

cerr « “<ERROR: Invalid number of arguments for Get Configuration Date>\n”; 
return ERROR_IN_EVALUATION; 

) 

return GET_C0NFIGURAT10N_DATE; 

) 

else if (strcmp(function,”CDS”)==0) 

I 

if (arguments<2 II arguments >2) 

{ 

cerr «‘'<ERROR: Invalid number arguments ...Dump Configuration Summary>Nn"; 
return ERR0R_IN_EVALUAT10N; 

} 

return DUMP_C0NFIGURAT10N_SUMMARY; 

} 

else if (sticmp(function,"CDC")=0) 

{ 

if (arguments<2 II arguments >2) 

{ 

cerr«‘■<ERROR: Invalid number arguments ...Get Last Date Changed>'n": 
return ERROR_IN_EVALUATION; 

1 

return GET_CONFIGURATION_CHANGED; 

} 

else if (sux:mp(function."CPL")=0) 

{ 

if {arguments<3 II arguments>3) 

I 

cerr « “<ERROR: Invalid number arguments for Post to Configuration Log>\n": 
return ERROR_IN_EVALUATION; 

} 

return POST_CONFIGURATION_LOG; 

} 

else if (strcmp(function,"CGL’')=0) 

( 

if (arguments<2 II arguments >2) 

{ 

cen « “<ERROR; Invalid number arguments for Get Configuration Log>\n”; 
return ERR0R_IN_EVALUAT10N; 

1 


148 




return GET_C0NFIGURAT10N_L0G; 

I 

else if (strcmp(function,"CAO”)=0) 

( 

« if (larguments == 5) 

{ 

ceiT « “<ERROR; Not enough arguments fw Attt^h Operators>'«‘*; 
return ERROR_IN_EVALUATION: 

' I 

return ATrACH_OPERATOR; 

} 

else 

i 

cerr « “Error in Configuration Command syntax \n'n”; 

1 

}: 


int evaluate_vobject_function(char *function. int arguments) 

if (strcmp(function "VLO”)=0) 

( 

if (arguments < 2 II arguments > 4) 

{ 

cerr« “<ERROR: Invalid number arguments for List Operators>Nn''; 
return ERR0R_IN_EVALUAT10N; 

) 

return LIST_OPERATORS; // tell main() to run List Operators 

\ 

else if (strcmp(function,"VUD’')==0) 

{ 

if (! arguments == 5) 

{ 

cerr « “<ERROR: Invalid number of arguments for Update VOBJECT Descriplion>\n’' 
return ERROR_IN_EVALUATION; 

1 

return UPDATE.VOBJECT.DESCRIPnON; 

} 

else if (strcmp(function.”VGD”>=0) 

{ 

if (arguments < 2II arguments > 4) 

I 

cerr« “<ERROR: Not enough arguments to Get VOBJECT Description>Nn”; 
return ERROR.IN.EVALUATION; 


149 




} 

return GET_VOBJECT_DESCRIPnON; 

I 

else if (strcmp(function,”VDD”)=0) 

{ 

if (arguments < 2II arguments > 4) 

cerr « “<ERROR: Invalid number of arguments for Get VOBJECT Date>\n”; ■* 

return ERROR_IN_EVALUATION; 

} 

return GET_VOBJECT_DATE: 

I 

else if (strcmp(function,"VGV’‘)==0) 

{ 

if (larguments == 2) 

cerr « "<ERROR: Invalid number arguments for Get VOBJECT Versions>\n"; 
return ERROR.IN.EVALUATION; 

1 

return GET_VOBJECT_ VERSIONS; 

} 

else if (strcmp(function."VVV”)=ssO) 

{ 

if (arguments<l II arguments >1) 

i 

cerr« “<ERROR; Invalid number of arguments for Get VOBJECT Current Version>\n"; 
return ERROR_IN_EVALUATION; 

I 

return GET_ VOBJECT. VERS ION; 


else if (strcmp(function."VGL”)=0) 

( 

if (arguments < 2 II arguments > 4) 

I 

cerr « “<ERROR; Invalid number of arguments for Get VOBJECT Lock>\n''; 
return ERROR_IN_EVALUATION; 

I 

return GET_VOBJECT_LOCK; 

) 

else if (strcmp(function.”VDA”)==0) 


150 




( 

if (arguinents<2 II arguments >4) 

I 

cerr« “<ERROR: Invalid number of arguments for Get VOBJECT Summary>Nn”; 
return ERR0R_IN_EVALUAT10N; 

} 

return DUMP_VOBJECT_SUMMARY; 

} 

else if (stn:mp(function.”VGP”)=0) 

i 

if (arguments < 2II arguments > 4) 

cerr« "<ERROR; Invalid number of arguments for Get VOBJECT Postscript>\n”; 
return ERROR_IN_EVALUATION; 

} 

return GET_VOBJECT_POSTSCRIPT; 

} 

else if (strcmp(function”VGG’')==0) 

{ 

if (arguments < 2 II arguments > 4 ) 

{ 

cerr « “<ERROR: Invalid number of arguments for Get VOBJECT GRAPH>\n"; 
return ERROR_IN_EVALUATION; 

} 

return GET_VOBJECT.GRAPH; 

} 

else if (strcmp(function."VGI”)==0) 

I 

if (arguments < 2 II arguments > 4) 

{ 

cerr «'*<ERROR: Invalid number of arguments for Get VOBJECT lmplementation>Nn" 
return ERROR_IN_EVALUATION; 

} 

return GET.VOBJECTJMPLEMENTATION; 

) 

else if (strcmp(function,"VGC”)==0) 

{ 

if (arguments < 2II arguments > 4) 

I 

cerr «‘‘<ERROR: Invalid number of arguments for Get VOBJECT Specif!cation>Nn"; 
return ERROR_IN_EVALUATION; 


151 



} 

return GET_VOBJECT_SPECIFICAT10N; 
else if (strcmp(function,”VGS”)==0) 

I 

if (arguments < 2II arguments > 4) 

{ 

cerr« “<ERROR; Invalid number of arguments for Get VOBJECT Source>\n”; 
return ERROR_IN_EVALUATION; 

} 

return GET_VOBJECT_SOURCE; 

1 

else if (strcmp(function,”VDS”)=0) 

{ 

if (arguments < 2II arguments > 4) 

( 

cerr « “<ERROR: Invalid number of arguments for Dump VOBJECT Source>\n“; 
return ERR0R_IN_EVALUAT10N: 

I 

return DUMP_VOBJECT_SUMMARY; 

I 

else if (strcmp(function,’‘VAA”)==0) 

{ 

if (arguments < 2 II arguments >4) 

{ 

cerr «‘'<ERROR: Invalid number of arguments for Add VOBJECT Subtree>\n'‘; 
return ERR0R_IN_EVALUAT10N; 

1 

return ADD_NEW_VARIATION; 

} 

else if (strcmp(function,’'VDF”)=0) 

{ 

if (arguments < 3 II arguments > 5) 

I 

cen « “<ERROR: Invalid number of arguments for Dump VOBJECl rILE(S)>'n” 
return ERROR_IN_EVALUATION; 

} 

return DUMP_VOBJECT_FILES; 

) 

else if (strcmp(function,’'VLL”)==0) 

{ 

if (arguments < 2 II arguments > 4) 

( 

cerr « “<ERROR: Invalid number of arguments for long list Operators>\n'': 


152 






retum ERROR_IN_EVALUATION; 

) 

return LONG_LIST_OPERATORS; 

} 

else if (strcmp(function ”VLP”)=0) 

I 

if (arguments < 2II arguments > 4) 

{ 

cerr « “<ERROR: Invalid number of arguments for list Pareni/Siblings>\n”; 
return ERROR_IN_EVALUATION; 

} 

return LONG_LIST_PARENTS; 

} 

else if (strcmp(function,”VLC’’)=0) 

{ 

if (!arguments>l) 

{ 

cerr « “<ERROR: Invalid number of arguments for list Children>\n''; 
return ERROR_IN_EVALUATION; 

) 

return L0NG_L1ST_CHILDREN; 

1 

else if (sm:mp(function,”VDT’)=0) 

i 

if (arguments < 3 II arguments > 5) 

{ 

cerr«'‘<ERROR; Invalid number of arguments for Dump VOBJECT TREE FILE(S)>\n‘' 
return ERR0R_IN_EVALUAT10N; 

} 

return DUMP.VOB^CT.TREE; 

) 

else if (strcmp(function,"VRO'')==0) 

{ 

if (arguments != 4) 

{ 

cerr «■‘<ERROR: Invalid number of arguments for Release Operator Lock>\n”; 
return ERROR_IN_EVALUATION; 

} 

return RELEASE_OPERATOR_LOCK; 

} 

else if (strcmp(function,'’VRS”)==0) 

{ 

if (arguments != 4) 


153 



cerr« “<ERROR: Invalid number of arguments for Release Operator Subtree Locks>'«"; 
return ERROR_IN_EVALUATION: 

} 

return RELEASE_SUBTREE_LOCK; 


else 

( 

cerr« “<«Error in VOBJECT Command syntax»> NnVn”; 

} 


int evaluate_prototype_function(char *function, int arguments) 

{ 

TRACER(“evaluate_prototype_function”); 
if {strcmp(function.’'PLN”)=0) 

if (!arguments=0) 

{ 

cerr « “<ERROR: Too many arguments for List Prototype Names>Nn"; 
return ERROR_IN_EVALUATION: 

1 

else 

return LIST_PROTOTYPES; // tell main() to run List_Prototypes 

} 

else if (strcmp(function,”PLL’')==0) 

( 

if (!arguments=0) 

i 

cerr « “<ERROR: Invalid number of arguments for Long List Prototypes>'«”; 
return ERROR_IN_EVALUATION; 

} 

return LONG_LIST_PROTOTYPES; 

} 

else if (strcmp(function ”PDS’')=0) * 

{ 

if (arguments<l II arguments >1) 

{ 

cerr« “<ERROR: Invalid number of arguments for Dump Prototype Summary>\n”; « 

return ERROR_lN_EVALUATION; 

) 

return DUMP_PROTOTYPE_SUMMARY; 


154 






} 

else if (strcmp(function,”PGL”)=0) 

{ 

if (arguinents<l II arguments >1) 

{ 

cerr« “<ERROR: Invalid number of arguments for Get Prototype Leader>Nn”; 
return ERROR_IN_EVALUATION; 

} 

return GET_PROTOTYPE_LEADER; 

I 

else if (strcmp(function,”PGD”)=0) 

I 

if (arguments<l II arguments >1) 

{ 

cerr « “cERROR: Invalid number arguments for Get Prototype Description>\n" 
return ERROR_IN_EVALUATION; 

} 

return GET_PROTOTYPE_DESCRIPTION; 

} 

else if (sm;mp(function."PRE")==0) 

{ 

if (arguments<l II arguments >1) 

{ 

cerr«‘TERROR; Invalid number arguments for Retrieve Prototype Date>\n"; 
return ERROR_IN_EVALUATION; 

1 

return RETRIEVE_PROTOTYPE_DATE; 

} 

else if {strcmp(function,"PIP”)==0) 

{ 

if (!arguments>0) 

1 

cerr « "<ERROR: Invalid number arguments for Insert Prototype>Nn"; 
return ERROR_IN_EVALUATION; 

} 

return INSERT.PROTOTYPE; 

} 

else if (strcmp(function,”PUL”)=0) 

{ 

if (arguments<2 II arguments >2) 

{ 

cerr« “<ERROR: Invalid number arguments for Update Leader>Vi"; 
return ERROR_IN_EVALUATION; 

} 


155 




return UPDATE_PROTOTYPE_LEADER; 

} 

else if (strcmp(function "PUD”)=0) 

{ 

if (! arguments==l) 

{ 

cerr « “<ERROR: Invalid number arguments for Update Description>\n'‘; 
return ERROR_IN_EVALUATION; 

} 

return UPDATE_PROTOTYPE_DESC; 

} 

else if (strcmp(function,"PUN")=0) 

I 

if (! arguments==l) 

( 

cerr «'■<ERROR: Invalid number arguments for Update NamoVi”; 
return ERR0R_IN_EVALUAT10N; 

1 

return UPDATE_PROTOTYPE_NAME; 

} 

else if (strcmp(function.''PGC”)==0) 

( 

if (arguments<l II arguments>l) 

{ 

cerr « “<ERROR: Invalid number arguments for Get_Latest_Configuration>Vi" 
return ERROR_IN_EVALUATION; 

} 

return GET.LATEST.CONHGURATION; 

1 

else if (strcmp(function,"PLV”)=0) 

{ 

if (!arguments=0) 

{ 

cerr « “<ERROR; Too many arguments for List Prototype Variations>\n”; 
return ERROR_IN_EVALUATION; 

I 

return PROTOTYPE.VARIATION.LIST; 

1 

else if (strcmp(function,’'PVA”)=0) 

I 

if (!arguments=0) 

{ 


156 





cerr« “<ERROR: Too many arguments for List Prototype Variations and Versions>\n" 
return ERROR_IN_EVALUATION; 


I 

return PROTOTYPE_VAR_AND_VER_LIST; 

} 

else if (strcmp(function,”PVV”)=0) 

( 

if (arguments<l II arguments >1) 

{ 

cerr« arguments «‘Vi”; 

cerr « “<ERROR; Too many arguments for List Prototype Versions of a Variaiion>\n"; 
return ERROR_IN_EVALUATION; 

1 

return PROTOTYPE_VERSION_LlST; 

} 


else 

I 

cerr « “Error in Prototype Command syntax \n\n"; 


157 







// File Header.. 

// . : 

//filename.: evaluation.h 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O'Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
[* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Becau.se of the massive 
changes required 1 discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

V 

H Compiler : GltKkenspiel C-m- 2.1 
// 

// End header comments. 


#ifndef _EV ALU AT10N_H 
#definc _EVALUAT10N_H 

// sees ID follows: will compile to place date/time stamp in object file 

.static charevaluation_h_SccsId(l = ■‘(S)(#)evaluation.h l..Tq9/16/9r'; 

// Contents. 

// 

// Prototypes of functions to evaluate the command line TAG 
// argument and set the appropriate case statement in main. 

// 

// 

//End.. 

// Interface Dependencies. 

// 

// NONE 

// 


158 













// End Interface Dependencies- 

char chanipper(char c); 
char ‘upperlchar ‘argument); 

int evaluate_historical_function(char ‘function, int arguments); 
int evaluate_configuration_function(char ‘function, int arguments); 
int evaluate_vobject_function(char ‘function, int arguments); 
int evaluate_prototype_function(char ‘function, int arguments); 

// Description. 

// 

// charupper 

// 

// Converts lower case letters to upper case. 

// 

// upper 

// 

// ConvertsthecommandlineTAGfieldtoupperca.se. Calls 
// charupper to convert each letter. 

// 

// evaluate_configuration_function 

// 

// Determines the appropriate case statement to be executed for 
// database operation pertaining to configurations. 

// 

// evaluate_vobject_function 

// 

// Determines the appropriate case statement to be executed for 
// database operations pertaining to versioned objects. 

// 

// evaluate_prototype_function 

// 

// Determines the appropriate case statement to be executed for 
// database operations pertaining to prototypes. 

// 

// End Description. 

#endif // _E V ALUATION.H 


1.59 






// File Header- 

// . : 

//filename.: nodesuppoit.h 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required 1 discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

// Compiler : Glockenspiel C++ 2.1 

// 

// End header comments- 


#ifndef _NODESUPPORT_H 
#define _NODESUPPORT_H 


// sees ID follows: will compile to place date/time stamp in 
// object file 

static char nodesuppoTt_h_Sccsld[] = "@(#)nodesupport.h 1.3M9/16/9r'; 

// Contents-- 

// 

// NODESUPPPORT HEADER FILE 

// 

// Description 

// 

// SIMPLE NODE SUPPORT Functions 

// 

//End. 


160 









// Interface Dependencies 


#ifndef _TREENODE_H 
#include “treenode.h” 

#endif 

// End Interface Dependencies —-- 

TREENODE* root_fmd(TREENODE_Iinkedlist Iist_to_search. const char* str); 
int str_suffix_check(char* str,char ch); 
int proper_super_string(char* strl, char* str2); 

int proper_super_NODE_check(TREENODE* node_ptr, char* target_string); 

// Description.. 

// 

// root_find 

// 

// Locates the root node associated with given operator name. 

II 

H str_suffix_check 

// 

// Locates the suffix of a given string. 

II 

// proper_super_string 

II 

H Determines whether one string is a prefix of another string 
// (i.e., one operator is the child of another operator). 

// 

// proper_super_NODE_check 

// 

// Determines whether a given node should be added to the childlist 
// of a given operator name. 

II 

H End Description- 

#endif // end nodesupport header file 


// File Header. 

// . : 

//Jilename.; nodesupport.cxx 

//.sees ID.-. 1.3 

//.Release No....: 1 
//.Date.: 9/16/91 


161 














//.Author.: Garry Lewis 

//.: Drew Dwyer 

//.Compiler.: Glockenspiel C++ 2.1 

// . : 

// End header comments- 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char nodesupport_cxx_SccsId[] = "@(#)nodesupport.cxx 1.3Nt9/16/9r’; 

// Contents- 

// 

// root_find 
// str_siiffix_check 
// proper_super_string 
// proper_super_NODE_check 
// 

//End. 

// Interface Dependencies. 

// TURN ON TRACE-DEBUG 
#define DEBUG 
#include “debug.h" 


extern “C--” 


#include <string.h> 

} 


#ifndef _NODESUPPORT_H 
#include “nodesiipport.h” 
#endif 

// End Interface Dependencies - 


TREENODE* root_find(TREENODE_linkedlist list_to_search, const char* str) 

// Summary- 

// 

// this function returns the address of the NODE in the list 
// that has its operator_name matching *str. 

// 


162 

















// End Summary - 


{ 

slistjterator ret_node(list_to_search); 

TEIEENODE* node; 

// BELOW SHOULD BE REPLACED WITH THE ABOVE 
while (ret_nodeO) 

I 

node = ret_node(); 

if (!strcmp(strj)ode->geinameO )) return node; 

1 

return NULL; 

} 


int str_suffix_check(char* strxhar ch) 

// Summary- 

// 

// this function checks to see if the char at address str is ch 
// and that ch only appears in the string *str at this position. 

// Thus *str with ch = is of the form “.example with no more 
// periods”. 

// 

// End Summary- 


( 

if (‘str != ch ) return 0; 

else // check for “ch" in rest of string 


if (strchr(str+l, ch )) return 0; 
else return 1; 

} 


int proper_super_string(char* strl, char* str2) 

// Summary- 

// 

// This function checks to see if strl is a candidate to be a 
// child of str2 in the multi-way tree. 

// 


163 








// End Summary — 


// check to see if str2 is a prefix of strl 
if (strl != strstr(strl,str2)) 
return 0; 
else 
{ 

char* loc = strl + strlen(str2); 
return str_suffix_check(loc, 

} 


int proper_super_NODE_check(TREENODE* node_ptr. char* target_string) 

// Summary- 

II 

H This functions checks to see if the NODE returned by 
// Listiterator should be added to the child_list of the NODE 
// associated with target string. It return a 1 if it should. 

// 

// End Summary. 


{ 

return proper_super_string(node_ptr->getname(). iarget_string); 

1 


// File Header. 

// . : 

//.Filename.: protfunc.h 

//Date : 9/16/91 

// Author ; Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/• original code written by Dwyer and Lewis. Every functiun that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 


164 









changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

•/ 

// Compiler : Glockenspiel C++ 2 .1 

// 

// End header comments- 


#ifndef _PROTFUNC_H 
#defme _PROTFUNC_H 

// sees ID follows: will compile to place dateAime stamp in 
// object file 

static char protfunc_h_SccsId[] = “@(#)protfunc.h l,3\i9/16/91"; 

// Contents. 

// 

// Prototypes for functions related to manipulating 
// instances of the class PROTOTYPE. 

// 

//End. 

void list_prot_func(int); 
void long_list_prot_func(int); 

void list_prot_variations(int): 
void list_prot_versions(int); 
void list_prot_var_and_ver(int); 

void get_prot_leader_func(int. char*); 
void get_prot_description_func(int, char*); 
void dump_prot_summary_func(int, char *); 
void retrieve_prot_date_func(int. char*); 
void insert_prot_func(int, char*, char*, char*); 
void update_protJeader_func(int. char*, char*); 
void update_prot_desc_func(int, char*, char*); 
void update_prot_name_func(int, char*, char*); 

// Description- 

// 

// list_prot_func 

// 

// Provide the name of prototypes in the design database. 


165 








// 

// long_list_prot_func 

// 

// Provides a list of all prototypes, the default configuration 
// assigned to a prototype and the version number of the nx)t 
// versioned object. 

// 

// get_prot_leader_func 

// 

// Provides the name of the leader assigned to a prototype. 

// 

// get_prot_description_func 

// 

// Provides the description of a given prototype. 

// 

// dump_prot_summary_func 

// 

// IVovides a summary of the prototype. Include creation date. 
// leader, default configuration, and a description. 

// 

// retrieve_prot_date_func 

// 

// Provides the creation date. 

// 

// insert_prot_func 

// 

// Creates a new prototype in the database. 

// 

// update_protJeader_func 

// 

// Changes the prototype leader’s name. 

// 

// update_prot_desc_func 

11 

H Changes the description of a prototype. 

// 

// update_prot_name_ftinc 

// 

// Changes the prototype name. 

// 

// End Description- 

#endif // _PROTFUNC_H 


166 






// File Header- 

// . : 

//filename.: protfunc.cxx 

//Date ; 9/16/91 

// Author ; Garry Lewis 

// ; Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications ; Extensive modifications have been conducted on almost all of the 
f* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required 1 discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

I I Compiler : Glockenspiel C++ 2.1 

// 

// End header comments- 


// sees ID follows: will compile to place date/time stamp in 
// object file 

static char protfunc_cxx_SccsIdD = “@(#)protfunc.cxx 1.3\t9/16/91’*; 

// Contents. 

// 

// list_prot_func 
// long_list_prot_func 
// get_iH-ot_leader_func 
// get_prot_description_func 
// dump_prot_summary_func 
// retrieve_prot_date_func 
// inserl_prot_func 
// update_protJeader_func 
// update_prot_desc_func 
// update_prot_name_func 
// 

//End.. 


167 









// Implementation Dependencies 


// TURN ON TRACE-DEBUG 

#define DEBUG 
#include “debug.h” 

#ifndef _DDBDEFINES_H 
#include “ddbdefmes.h” 

#endif 

#include “My_String.h" 
#include <stream.hTX> 
#include <LisLh> 

#include <Directory.h> 


extern “C-” 


#include <sysAime.h> 
#include <sysAypes.h> 

I 


#ifndef _PROTOTYPE_H 
finclude "prototype.h” 

#endif 

// End Implementation Dependencies 


// Interface Dependencies. 

#ifndef _PROTFUNC_H 
#include “protftinc.h” 

#endif 

// End Interface Dependencies — 

extern List ’"myPrototypeList; 
extern char *ddbRootDir; 
PROTOTYPE *prototypePtr; 
ifstream inFile; 








void list_prot_func(int number_arguments) 


switch (number_arguinents) 

{ 

caseO: 

{ 

OC_setWoikingDirectory(ddbRootDir); 
Listlterator my_iterate(inyPrototypeList); 
while(my_iterate.moreDataO) 

{ 

cout«(char *)my_iterateO « 


break; 

default: 

cerr« “<ERROR: problem listing prototypes in database>\n‘'; 

) 

) 

void long_list_prot_func(int number_arguments) 

( 

char *proto_name = (char *)0; 
char *confignane = (char *)0; 
switch (number.arguments) 

{ 

case 0: 

{ 

C)C_setWoikingDirectOTy(ddbRootDir); 

List &protoReference = •myPrototypeList; 

List ♦proto_names = (List*)0; 
proto_names = new List(protoReference); 

Listlterator my_iterate(proto_names); 
while(my_iterate.moreData()) 

{ 

Directory *prototype_dir^(Directory*)0; 
char *proto_name = (char *)0; 
char ♦name = (char *)0', 
proto_name = (char ‘ImyJterateO; 

name = (char *)(My_String(proto_name) + My_String(“_dir”)); 


prototype_dir = (Directory *)OC_lookup(name); 
if (prototype_dir) 

OC_setWorkingDirectory(prototype_dir); 


169 



char *prototype_naiTie = (char*XMy_Strlng(proto_naine) + 
My_String(PROTOTYPE_EXT)): 
prototypePtr = (PROTOTYPE* )OC_lookup(prototype_nanie); 
if (prototypePtr) 

{ 

CONFIGURATION *configPtr. 

configPtr = prototypePtr->getDefaultConfigijrationO: 

if (configPtr) 

( 

configname =new char [strlen(configPtr->naine()+l)]; 
strcpy(confignaine,configPtr->name()); 

} 

else 

I 

configname = new char [2]; 
strcpy(configname,” "); 

} 

cout« proto_name: 
int i=0; 

for (i=0;i<(PRINT_CONFIG_LOCATION-strlen(proto_name));i++) 
cout« “ 

cou*.« configname; 

for (i-.0;i<(PRINT_VERSION_LOCATION- 

(PRINT_CONnG_LOCAT10N+strien(configname)));i++) 
cout« “ 

V_OBJECT *vobjectPtr = prototypePtr->getVobject(); 
if (vobjectPtr) 

{ 

int variation = vobjectPtr->getVariationNumber(): 
cout« variation « “ 

1 

else 
cout« 

if (vobjectPtr) 

{ 

int version = vobjectPtr->getVersiorNumberO; 
cout« version « “Vn”;; 

1 

else 

cout« ““ «'^n’'■, 
delete name; 


170 






delete configname; 


} 

} 

} 

break; 

default: 

ceir « “<ERROR: problem long listing prototypes in database>Nn” 

I 


void list_prot_va/iations(int number_arguments) 

( 

switch (number_arguments) 

{ 

case 0: 

( 

cerr « “In list prototype variationsNn”; 

} 

break; 

default: 

cerr « “<ERROR: FYoblem listing prototype variationsNn": 

1 

I 


void list_prot_versions(int number_arguments) 

{ 

switch (number_arguments) 

{ 

case 1: 

I 

cen' « "In list prototype versionsNn"; 

} 

break; 

default; 

cerr « "<ERROR: Problem listing prototype versionsNn”; 

1 

) 

void list_prot_var_and_ver(int number_arguments) 

( 

switch (number_arguments) 

{ 

case 0: 

I 

cerr « “In list prototype variations and versionsNn"; 


171 











} 

break: 

default 

cerr « “<ERROR: Problem listing prototype variations and versionsNn’* 


} 

void get_prot_leader_func(int number_arguments, char *argl) 

{ 

switch (number_arguments) 
case 1: 

char ‘prototype.name = new char [strIen(argl)+5]; 
strcpy(prototype_name,arg 1); 
strcai(prototype_namei*ROTOTYPE_EXT); 
prototypePtr = (PROTOTYPE*)OC_lookup(prototype_name); 
prototypePtr -> getPrototypeLeader(); 
tweak; 
default 

cerr « “<ERROR: extra arguments in get description calfwi”; 

) 

} 


void get_prot_description_func(int number_arguments, char *argl) 

{ 


switch (number_arguments) 

{ 

case 1; 

char ♦prototype_name = new char [strlen(argl)+5]; 
strcpy(prototype_namearg 1); 
strcat(prototype_nameJ’ROTOTYPE_EXT); 
prototypePtr = (PROTOTYPE*)OC_lookup(prototype_name); 
prototypePtr -> getPrototypeDescriptionO; 
break; 
default 

cerr« “<ERROR: extra arguments in get description calNi”: 

I 


void dump_prot_summary_func(int number_arguments, char ‘argl) 


172 






switch (number_arguments> 

{ 

case 1: 

char* prototype_name = 

(char*)(My_String(arg 1 )+My_Stiing(PROTOTYPE_EXT)); 
prototypePtr = (PROTOTYPE*)OCJookup(prototype_name); 
prototypePtr -> dumpPrototypeSununaryO; 
break; 
default: 

cerr« “<ERROR; extra arguments in dump Prototype Summary calTsn"; 

) 


void retrieve_prot_date_func(int number_arguments, char *argl) 

{ 

switch (number_arguments) 

( 

case 1: 

char* prototype_name = 

(char* )(My_String(arg I )+My_String(PROTOTYPE_EXT)); 
prototypePtr = (PROTOTYPE*X)C_lookup(prototype_name); 
if (prototypePtr) 

( 

timej protTime = prototypePtr -> getProtCreationDateO; 
cout« ctime(&protTime); 

I 

else 

I 

cerr« “<Prototype “ « arg 1 « “ not found>Nn" 

« "<find prototype creation date operation aborted>"; 

t 

break; 

default: 

cerr « “<ERROR: invalid number args for prototype time retrieval>Nn”; 

) 


void insert_prot_func(int number_arguments, char *argl. char *arg2. char *arg3) 

{ 


char* prototype_name = 

(char*)(My_String(arg 1 )+My_Suing(PROTOTYPE_EXT)); 


173 








prototypePtr = (PROTOTYPE •)OC_lookup(prototype_naine); 
if (IprototypePtr) 

{ 

switch (number_arguments) 

{ 

case 1: 

prototypePtr = new PROTOTYPE(prototype_name); 
OC_setWorkingDirectory(ddbRootDir); 
myPrototypeList -> Insert(argl); 
myPrototypeList -> putObjectO; 
break; 
case 2: 
case 3: 

prototypePtr = new PROTOTYPE(prototype_name, arg2); 
inFile.open(arg3. ios;:in); 
if (inFile) 

prototypePtr -> updatePrototypeDescription(arg34nFile): 
OC_setWorkingDirector>'(ddbRootDir); 
myProtot\’peList -> Insert(argl); 
myPrototypeList -> putObjectO; 
inFile.closeO: 
break; 
default: 

cerr « “<ERROR: invalid number args for insert prototype>\n": 


else 

{ 

cerr« “<NOTE: “ « argl « “ already exists!>'yi"; 
return; 

I 

1 


void update_prot_leader_func(int number_arguments. char *argl. char *arg2) 

{ 

switch (number_arguments) 

i 

case 2: 

char* prototype_name = 

(char*KMy_String(arg 1 )+My_String(PROTOTYPE_EXT)); 
prototypePtr = (PROTOTYPE* )OC_lookup(prototype_name); 
prototypePtr -> changePrototypeLeader(arg2); 
break; 


174 




default 

cerr « “<ERROR: invalid number args for update Leader>\n”: 

} 


void updaie_prot_desc_func(int number_arguments, char *argl, char •arg2) 

{ 

switch (number_arguments) 

{ 

case 2: 

{ 

inFile.open(arg2aos::in); 
if (linFile) 

( 

cerr « “File with description contents does not existNn” 

« “Aborting prototype update_descriptionNn”: 

} 

else 

I 

char *prototype_name = new char [strlen(argl)+5]; 

strcpy(prototype_name^g 1); 

strcat(prototype_namePROTOTYPE_EXT); 

prototypePtr = (PROTOTYPE*)OCJookup(prototype_name); 

prototypePtr -> updatePrototypeDescription(arg2inFile); 

inFile.closeO; 

) 

break; 

} 

default: 

cerr« “<ERROR: invalid number args for update description>Nn"; 


} 


void updaie_prot_name_func(int number_arguments, char ‘argl. char •arg2) 

{ 

switch (number_arguments) 

{ 

case 2: 

char* prototype_name = 

(char*KMy_String(arg 1 )+My_String(PROTOTYPE_EXT)); 
char* new_prototype_name = 

(char*)(My_String(arg2)+My_SiTing(PROTOTYPE_EXT)); 


175 







prototypePtr = (PROTOTYPE* )OCJookup(prototype_name); 
[wototypePtr -> changePrototypeName(new_prototype_naine); 
Iffeak; 
default: 

ceiT « “<ERROR: invalid number args for update Name>\n”; 

} 


176 



// File Header- 

// . : 

//filename.; prototype.h 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by ; Michael D. O'Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* CHiginal code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

// Compiler : Glockenspiel C-h- 2.1 

// 

// End header comments- 


#ifndef _PROTOTYPE_H 
#define _PROTOTYPE_H 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char prototype_h_SccsIdD = “@(#)protot>-pe.h 1.3\t9/16/9r'; 

// Contents.. 

// 

// PROTOTYPE 
// 

// Description 

// 

// Defines das-c PROTOTYPE. 

// 

II End .--- 


177 










// Interface Dependencies 


#include <Objecth> 

#include <LisLh> 

#include <Dictionary.h> 
tinclude <Reference.h> 
tinclude “ReferenceMacros.h” 

extern “C--” 

{ 

#include <sysAime.h> 

#include <sysAypes.h> 

} 

#ifndef _TEXT_OB JECT_H 
#include "text_object.h” 

#endif 

#ifndef _CONFIGURATION_H 
#include "configuration.h” 

#endif 

#ifndef_VOBJECT_H 
#include “versioned_object.h” 

#endif 

TypeCheckReference(ConfDictReference, Reference, Dictionary); 
TypeCheckReference(TextObjectReference, Reference, TEXT_OBJECT); 
TypeCheckReference(DefaultConfReference, Reference, CONFIGURATION); 

// End Interface Dependencies- 

#define DEFAULT.NAME “• 

//Class// 

class PROTOTYPE: public Object 

( 

private; 

char *protleader. 
int protDictlndex; 
time_t protCreationDate; 

TextObjectReference protdescription; 

ConfDictReference prot_configurationJist; //points to a Dictionary 


178 







DefaultConfReferenceprot_default_configuration: 

public: 

PROTOTYPE(APL *); 

PROTOTYPE(char ♦prototype_name. 

char *prototype_Ieader=DEFAULT_NAME); 
virtual void Destroy(Boolean aborted=FALSE); 
virtual Type *getDirectTypeO; 
char *getNaine(); 
char *getConfigNaine(); 
void getPrototypeNameO; 
void getPrototypeLeaderC): 
void getPrototypeDescriptionO; 

void changePrototypeName(char *new_prototype_name); 
void changePrototypeLeader(char *new_prototype_leader); 
void updatePrototypeDescription(chaf*, ifstream&); 
void dumpPrototypeSummary(j; 

void addConfiguration(CONFIGURATION *configuration); 
void listConfigurationsO; 
time_t setProtCreaiionDateO; 
time_t getProtCreationDateO; 
void getDefaultConfigNameO; 

CONFIGURATION *getConfiguration(char *); 
CONFIGURATION *getDefaultConfigurationO; 
V^OBJECT •getVobjectO; 

-PROTOTYPEO I DestroylFALSE); } 

}; 

// Description- 

// 

// Defines a PROTOTYPE class. 

// 

// Constructor 

// 

// prototype -APL 

// 

// ONTOS required constructor 

// 

// prototype 

// 

// Constructs a prototype object firom the given name. 

// and optional team leader of the prototype. 

// 


179 





// Public Members 

// 

// Destroy 

// 

// used to cleanup memory during deletion and aborts. 

// 

// getDirectType 

// 

// Return the ONTOS Type of class PROTOTYPE. 

// 

// getName 

H 

// Returns a character string containing the name of the prototype 

// 

// getConfigName 

// 

// Returns a character string containing the last configuration 
// worked on by a user 
// 

// getPrototypeName 

// 

// Prints the prototype name to standard output 

// 

// getPrototypeLeader 

// 

// Displays the prototype designer team leader’s name. 

// 

// getPrototypeProtdescription 

// 

// Displays a protdescription of the prototype. 

// 

// changePrototypeName 

// 

// Change the name of the prototype. 

II 

H changePrototypeLeader 
// 

// Change the prototype leader’s name. 

// 

// updatePrototypeProtdescription 

// 

// Adds a protdescription to a PROTOTYPE object 

// 

// dumpPrototypeSummary 


180 



// 

// Provides date created, leader, default configuration. 

// and description of a prototype. 

// 

// addConflguration 

II 

H Adds a configuration with a given name to the prototype 

II 

H listConfigurations 
// 

// List the names of all the configurations in the prototype. 

// 

// getDefaultConfigName 

// 

// Displays the name of the default configuration. 

II 

H getConfiguradon 
// 

// Used by this class as a suppon function to update the default 
// configuration. 

// 

// getDefaultConfiguration 

// 

// returns a pointer to the default Configuration 

II 

H getVobject 
II 

I I returns the most current root V_OBJECT (Operator or Type) 
// associated with a prototype. 

// 

// -prototype 

// 

// The class destructOT. 

II 

/I End - 

#endif // _PROTOTYPE_H 


181 






// File Header- 

// . : 

//filename.: prototype.cM 

//Date : 9/16/91 

// Author : Gany Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every hmction that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

// Compiler : Glockenspiel C-m- 2.1 

// 

// End header comments- 


// sees ID follows: will compile to place date/time stamp in 
// object file 

static char prototype_cxx_Sccsld[] = ‘*<2)(#)prototype.cxx 1.3\t9/16/9r’; 

// Contents.. 

// 

// PROTOTYPE::PROTOTYPE ONTOS constructor 

// PROTOTYPE.-.PROTOTYPE constructor 

// PROTOTYPE::Destroy 
// PROTOTYPE::getDirectType 
// PROTOTYPE::getName 
// PROTOTYPE::getConfigName 
// PROTOTYPE::getPrototypeName 
// PROTOTYPE::getPrototypeLeader 
// PROTOTYPE;:getPrototypeDescription 
// PROTOTYPE::getNumbeiOfVariations; 

// PROTOTYPE::displayNumberOfVariations; 

// PROTOTYPE::incrementVariations; 


182 











// PROTOTYPE::changePrototypeName 
// PROTOTYPE::changePrototypeLeader 
// PROTOTYPE::updatePrototypeDescription 
// PROTOTYPE-dumpPrototypeSummary 
// PROTOTYPE:;addConfiguration 
// PROTOTYPE::listConfigurations 
// PROTOTYPE: :setProtCreationDate 
// PROTOTYPE::getProtCreationDate 
// PROTOTYPE::getDefaiiltConfigNaine 
// PROTOTYPE::getConfiguration 
// PROTOTYPE::getDefaultConfiguration 
// PROTOTYPE::getVobject 
// 

// Description 

// 

// Implementation of class PROTOTYPE member functions. 

// 

//End. 

// Interface Dependencies- 

// TURN ON TRACE-DEBUG 
#defme DEBUG 
#include “debug.h’* 


#include <GlobaIEntities.h> 
#include <Directory.h> 
#include <stream.hxx> 


extern “C-" 

I 

#include <sys/time.h> 
#include <strings.h> 

) 


#ifndef _PROTOTYPE_H 
#include “prototype.h” 
#endif 


// End Interface Dependencies- 

extern Type *PROTOTYPE_OType; 


183 







extern Type *CONFIGURAnON_OType: 
extern Type •V_OBJECT_OType; 

// ONTOS required constructor // 

PROTOTYPE::PROTOTYPE(APL *theAPL): vtheAPL) 

{ 

I: 

// New Instance Constrictor // 

PROTOTYPE::FrOTOTYPE(char *prototype_name, 

char ‘prototypejeader); (prototype_name) 

// Summary. . 

// 

// Constructs a persistent prototype object. A PROTOTYPE object 
// contains general management information about a prototype and 
// a reference to a container holding configuration objects. 

// 

// Parameter 

// 

// prototype_name 

// 

// A pointer to a character string. 

// 

// prototypejeader 

// 

// A pointer to a character string. 

// 

// Functional Description 

// 

// Passes the object name to class Object. Copies the leader’s name 
// into private data members. We initialize the description to null 
// and create a dictionary to hold various configurations. 

// 

//End... 

I 

initDirectType(PROTOTYPE_OType); 

protleader = new c!iar[strlen(prototypeJeader)+l]; 
strcpyfpH-otleader, prototypejeader); 
protDictIndex = 0; 

184 









protCreaiionDate = setProtCreationDaie(); 

protdescription.initToNullO; 

prot_default_configuration.initToNull(); 

if(!CONFIGURATION_OType) 

{ 

CONFIGURATION.OType = (Type*)OC_lookup{“CONnGURATION”); 

} 

Dictionary *new_configuration = new Dictionary(OC_integer. 

C0NFIGURAT10N_0Type. 

TRUE, FALSE); 

new_configuration ->putObject(); 
prot_configuration_list.Reset(new_configuration. this); 

putObjectO; 

} 

// End Constructor PROTOTYPE: ;PROTOTYPE // 

// Member Function// 

void PROTOTYPE::Destroy(Boolean aborted) 

{ 

delete protleader; 
if (aborted) 

I 

Object::Destroy(aborted): 

1 

} 

Type* PROTOTYPE;:getDirectType() 

// Summary. 

II 

H returns the ONTOS Type for the prototype class. 

// 

// Return value 

// 

// A pointer to an ONTOS Type. 

// 

//End.. 


185 









return PROTOTYPE_OType; 


char * PROTOTYPE: igetNameO 

// Summary- 

// 

// returns the name of the prototype 

// 

// Return vaJue 

// 

// A pointer to a character string 

// 

//End.. 


( 

Directory *directory=(Directory *)0: 
char *name=(char *)0; 
char *temp=(char *)0; 

if(!this) 

I 

cerr«■■<ERROR: cannot get the name of a null PROTOTYPE>\n' 
renim NULL; 

I 

else 

( 

name = NameQ; 

OC_getNameComponents(name, &directory, &name); 
temp = new char [strlen(name)+l]: 
temp = strtok(name,".”); 
return temp; 


void PROTOTYPE: :getPrototypeNameO 

// Summary--- 

// 

// Displays the name of the prototype 

// 

// Return value 

II 

H Displays the Prototype Name and a linefeed to the stdout 


186 











// 

//End 


( 

Directory *directory; 
char *name; 

if(!this) 

ceir « “<ERROR: cannot get the name of a null PROTOTYPE>\n"; 
return; 

} 

else 

{ 

name = NarneQ: 

OC_getNameComponents(name, &directory, &name); 
cout « name « 

} 

1 

void PROTOTYPE; :getPrototypeLeader() 

// Summary. 

II 

H Displays the name of the prototype leader 

II 

// Return value 

II 

// Displays the Prototype leader and a linefeed to the stdout 

II 

II End . 


if(!this) 

{ 

cerr« “<ERROR; cannot get the leader’s name of a null PROTOTYPE>Nn” 
return; 

} 

cout« protleader «‘W; 

1 

void PROTOTYPE: :getPrototypeDescription() 


187 






// Summary- 

// 

// Displays the prototype description 

// 

// Return value 

// 

// Display Description to stdout if description exists 

// 

//End- 

( 

if(!this) 

{ 

cerr« “<ERROR: cannot get the description of a null PROTOTYPE>\n"; 
return; 

1 

if(! protdescription) 

I 

cerr « ”<ERROR: This prototype does not contain a description>'vi"; 
return; 

I 

else 

{ 

TEXT_OBJECT* myTextObjPtr = (TEXT_OBJECT*) protdescription.Binding(this); 
myTextObjPtr -> text(cout); 
cout«‘^i”; 

} 

} 

void PROTOTYPE;;changePrototypeName(char *new_prototype_name) 

// Summary. 

// 

// Changes the prototype name 

// 

// Parameter 

// 

// new_prototype_name 

// 

// a character string pointer containing the new name 

// 

// Return value 

// 

// N/A 


188 







// 

//End 


{ 

if(!this) 

{ 

cerr« “<ERROR: cannot set the name of a null PROTOTYPE>'^”; 
return; 

) 

Name(new_prototype_name); 

} 

void PROTOTYPE: :changePrototypeLeader(char ’'‘new_prototype_leader) 

// Summary. 

// 

// changes the prototype leader 

II 

H Parameter 

// 

// new_prototype Jeader 

// 

// a character string pointer containing the new leader’s name 

// 

// Return value 

// 

// N/A 

// 

//End. 

I 

if(!this) 

I 

cerr « “<ERROR: cannot change the leader of a null PROTOTYPE>\n”; 
return; 

} 

delete protleader, 

protleader = new char[strlen(new_prototypeJeader>fl]; 
strcpy(protleader, new_prototypeJeader); 
putObjectO; 

) 


void PROTOTYPE::updatePrototypeDescription(char *fileName, ifstream& input_file_stream) 


189 






// Summary- 

// 

// changes the prototype description 

II 

// Parameter 

II 

H fileName 

// 

// a character string pointer containing the new name of 
// the file containing the new description. 

// 

// input_file_stream 

// 

// the file handle of the input description file. 

// 

// Return value 

// 

// N/A 

II 

//End. 


if (Iprotdescription) 

i 

TEXT_OBJECT ‘textObjectPtr * new TEXT_OBJECT(); 
textObjectPtr -> append! fileName, input_file_stream); 
protdescriptionJleset(textObjectPtr, this): 
putObjectO; 

} 

else 

I 

TEXT_OBJECT *textObjectPtr = (TEXT_OBJECT*) protdescription.Binding(this); 

textObjectPtr -> resetTheTextO; 

textObjectPtr -> t4)pend(fileName, input_file_stream); 

putObjectO; 


) 

void PROTOTYPE::dumpPrototypeSummary() 

{ 


// Summary 

II 


190 





// Displays the date created. leader, default config. and 
// description of a prototype to stdout 
// 1 item per line ending with the (potentially) multi-line 
// description. 

II 

H Parameter 

II 

H N/A 
// 

// Return value 

// 

// N/A 

// 

//End. 

TRACERC'dumpPrototypeSummary"); 
time_t creationdate = 0: 
creationdate = getProtCreationDateO: 

TRACEC'Creation Date; “); 
cout« ciime(&creationdate); 
getI*rototypeLeader(); 
getDefaultConfigNameO; 
gelPrototypeDescriptionO; 

} 

void PROTOTYPE::addConfiguration(CONFIGURATION *configuration) 

( 


// Summary. 

II 

// adds a configuration to the prototype 

II 

// Parameter 

II 

// configuration 

II 

H a pointer to the configuration to be added to the 
// prototype. 

// 

II 

H Return value 

// 

// N/A 

// 

H End. 


191 









if(!this) 

{ 

cerr « “<ERROR; cannot set the description of a null PROTOTYPE>Nn"; 
return; 

} 

ifflconfigiuation) 

{ 

cerr« “<ERROR: cannot give to a PROTOTYPE a null configuration>Nn” 
return; 

} 

else 

{ 

protDictIndex = protDictIndex + I; 

Dictionary "'confDictionaryPtrs 
(Dictionaiy*)prot_configuration_list.Binding(this); 
confDictionaryPtr -> Insert(protDictIndex. (Entity *)configuration); 
confDictionaryPtr -> putObject(); 
prot_default_configuration.Reset(configuration. this); 
putObjectO; 

1 

} 

void PROTOTYPE::listConfigurations() 

// Summary. 

// 

// Display the configuration names contained in this protot)!^ 

// to stdout. 1 configuration / line. 

// 

// Parameter 

// 

// N/A 

// 

// Return value 

// 

// N/A 

// 

//End. 

{ 

CONFIGURATION ’"the.configuration; 
char •name; 

Directory *directory; 


192 









if(!prot_configuration_list) 

I 

cerr«■■<ERROR: cannot return a prototype from an empty lisoNn"; 
return; 

) 

Dictionary *confDictionaryPtr = 
(Dictionary*)prot_configuration_list.Binding(this); 
DictionaryIteratorconfiglist_iterator(confDictionaryPir); 

while(the_configuration =(CONFIGURATION*)(Entity*)configlist_iteratorO) 

{ 

if (name = the_configuration->Name()); 

{ 

OC_gelNameComponents(name, &directory, &name); 
cout « name « “\n"; 

} 

} 


//Member Function // 

time_t PROTOTYPE:; se tProtCreationDateO 

// Summary. 

// 

// sets the creation date to system date at time of this call. 

// 

// Parameter 

// 

// N/A 

// 

// Return value 

// 

// time_t as a default long value containing the system time 
// This function as a byproduct updates the protCreationDate 
// attribute field. 

// 

//End- 

{ 

time_t mytloc=0; 


193 







theTime; 

retum theTime = time(myUoc): 

} 

//End. 


// Member Function // 

time_t PROTOTYPE::getProtCreationDate() 

// Summary... 

// 

// Returns the prototype's creation date 

// 

// Parameter 

// 

// N/A 

// 

// Retum value 

// 

// time_t as a long value containing the system time 

// 

// End. 

{ 

retum protCreationDate: 

I 

H End. 


void PROTOTYPE; :getDefaultConfigNameO 

// Summary- 

// 

// Displays the default Configuration name for this prototype 
// to stdout 
II 

I I Parameter 

// 

// N/A 

// 

// Retum value 


194 












II 

H N/A 
// 

//End- 


{ 

Directory •directory: 
char *name; 

if(!prot_default_configuration) 

cerr« ‘VkERROR; No configurations are contained in this prototype.>Vi\n"; 

} 

else 

I 

CONFIGURATION *the_configuration = 
(CONFIGURATION*)prot_default_configuration.Binding(this); 
name = the_configuration -> Name(); 

OC_getNameComponents(name. &directory. &name); 
cout« name «‘^n”; 

) 


char * PROTOTYPE; ;getConfigName() 

{ 


// Summary. 

// 

// Returns a character string pointer to an area in memory 
// containing the name of the default Configuration name 
// for this prototype. 

// 

// Parameter 

// 

// N/A 

// 

// Return value 

// 

// character string pointer 

// 

//End. 

Directory *directory; 
char •name: 


195 





if(Iprot_default_configuration) 


{ 

ceir « “<ERROR: No configurations are contained in this prototype.>\nNn”; 
return NULL; 

} 

else 

( 

CONFIGURATION *the_configuration = 
(CONFIGURATION*)prot_default_configuration.Binding(this): 
name = the_configuration -> Name(): 

OC_gelNameComponents(name, &directory, &name); 
return name; 

I 


CONFIGURATION *PROTOTYPE::getConfiguration(char *confName) 

// Summary. 

// 

// Used by this class as a support function to update the default 
// configuration. 

// 

// Parameter 

// 

// confName 

// 

// configuration name to lookup the default configuration 
// for this prototype 
// 

// Return value 

// 

// Configuration pointer if successful. Null pointer if 
// failed. 

// 

//End. 


( 

CONFIGURATION *myConfPtr = (CONFIGURATION *)OCJookup(confName); 
if (myConfPtr) 

{ 

return myConfPtr; 

1 

else 


196 







return (CONFIGURATION* )0; 


CONFIGURATION *PROTOTYPE::geiDefauItConfiguration() 

// Summary.. 

// 

// Returns the default configuration for this prototype. 

// The last configuration worked on. 

// 

// Parameter 

n 

// N/A 

// 

// Return value 

// 

// Configuration pointer if successful. Null pointer if 
// failed. 

// 

//End. 


CONFIGURATION *the_configuration =(C0NF1GURAT10N *)0; 
if(! prot_default_configuration) 

I 

return NULL; 

I 

else 

I 

the_configuration = 

(CONFIGURATION*)prot_default_configuration.Binding(this); 

} 


V_OBJE(7r *PROTOTYPE::getVobject() 

// Summary.. 

// 

// This method assumes that the root versioned object (V_OBJECT) 
// has the same name as the prototype. If this is not the case 
// then this function will not work. Taking the prototype name. 


remm the_configuration; 


197 









// a thread lookup is performed and the most current V OBJECT 
// in the thread is returned. 

// 

// P’arameter 

// 

// N/A 

II 

H Return value 

// 

// V_OBJECT pointer if successful. Null pointer if 
// failed. 

// 

//End.— 

{ 

THREAD *threadPtr=(THREAD*)0; 

char *name = new char [strlen(getName())+l]; 

strcpy(name,getNameO); 

threadPtr = (THREAD ’'')OCJookup(name); 

if (threadPtr) 

{ 

V_OBJECT *vobjectPtr = threadPtr->current(); 
if (vobjectPtr) 
return vobjectPtr; 
else 
I 

return NULL; 


} 

else 

{ 

return NULL; 


) 

// end functions 


198 









// File Header- 

// . ; 

//JFilename.: queue.h 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* caiginal code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required 1 discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

// Compiler ; Glockenspiel C++ 2.1 

// 

// End header comments- 


#ifndef_QUEUE_H 
#define __QUEUE_H 

// sees ID follows; will compile to place date/time stamp in 
// object file 

static char QLfEUE_h_SccsId[] = “@(#)queue.h 1.3Nt9/16/9r’; 

// Contents..-.. 

// 

// QUEUE 

// 

// Description 

// 

// IMPLEMENTS class QUEUE CONSTRUCTORS. 

// 

//End. 

// Interface Dependencies.. 


199 















// 


#include <iostream.hxx> 

extern “C-”{ 

#include <stdio.h> 

#include <string.h> 

) 

// 

// End Interface Dependencies- 

// Description- 

// 

// Defines the slink, slist, slist_iterator, 

// treenodejinkedlist, and treenode_queue classes 

// 

// 

// There are no ontos mechanisms in these classes. The primary 
// purpose of these classes is to provide the support structures 
// of linked_lists and queues in order to process the CAPS 
// PROTOTYPE subdirectory. 

// 

// As a subdirectory is read, each file is analzed to determine 
// whether it is an operator/type. If found to belong to 
// an operator which might version, the operator and operator 
// information is placed into a multi-way tree parralielling the 
// decomposition of an operator in the CAPS system. The 
// TREENODES are then compared against operator strucnires in 
// the Ontos Database in other programs documented elsewhere. 

// 

// These structures are simple in nature and can be found in 
// any good C-m- textbook. These particular examples came from 
// Bjame Stroustrup's C++ Programming Language textbook (pg 203). 
// Please refer to the textbook for further explanation of the 
// data structures and how they are manipulated. 

// 

//End-- 

class TREENODE; 
class slist; 
class slistjterator; 

class slink { 


200 








friend class slist; 
friend class slistjterator; 

private: 
slink* next: 

TREENODE * e; 
slink(TREENODE * a, slink* p); 

}; 


class slist { 

friend class slist_iterator; 
private: 

slink* last: // last-> next is head of list 

public: 

slistO: // ( last = NULL; } 

slist(TREENODE * a): 

int insert(TREENODE * a): // add at head of list 

int append(TRJEENODE * a): // add at tail of list 

TREENODE * getO'. // return and remove head of list 

void cleaiO'. // remove ail links 

int emptyO; // returns 1 if list is empty 

-slistO; // ( clearO: 1 


class slistjterator I 

private; 
slink* ce; 
slist* cs; 

public: 

slist_iterator(slist& s); 
TREENODE * operator()(); 

}; 


class TREENODE_linkedlist: public slist 

1 

public: 

TREENODE_linkedlist(); 
int member(char *name); 


201 





class TREENODE_queue : private slist 

I 

public; 

TREENODE_queue(){} 
void put(TREENODE • a) {^pend(a); } 
slist lempty; 
slist: :get: 

}: 


#endif // QUEUE Class header 



// File Header.. 

// . : 

//JUename.: queue.cxx 

//.sees ID.: 1.3 

//JleleaseNo....: 1 

//.Date.: 9/16/91 

//.Author.: Garry Lewis 

//.: Drew Dwyer 

//.eompiler.: Glockenspiel e++ 2.1 

// . : 

// End header comments- 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char QUEUE_cxx_SccsIdD = "@(#)queue.cxx 1.3Nt9/16/9r’; 

// Gontents.-.. 

// 

// QUEUE 

// 

// Description 

// 

// IMPLEMENTS class QUEL^ GONSTRUeTORS. 

// 

H End. 

// Interface Dependencies. 

// 

// TURN ON TRAGE-DEBUG 
#define DEBUG 
#include “debug.h" 


#ifndef_QUEUE_H 
#include "queue.h” 

#endif 

// 

// End Interface Dependencies- 

H- -X..X-X-X-X 

// these are the implementation methods of classes 
// slink, slist, slistjterator, and TREENODE_linkedlist 


203 




















II- -X.X.X-X-X 

H- -X.X.X.X-X 

II 

H slink methods 

// 

n- -X.X.X - X-X 

slink: :slink(TREENODE * a. slink* p) 

{ 

e = a; 
next = p: 

) 


H- -X.X.X.X-X 

// 

// slist methods 

// 

H- .X.X.X.X-X 

slist: :slist() 


{ 

last = NULL; 

) 


slist: :slist(TREENODE * a) 


{ 

last = new slink(a,NULL); 
last -> next = last; 

) 


int slist::insert(TREENODE * a) 

1 

if (last) 

last->next = new slink(a. last->next); 
else { 

last = new slink(aJ'JULL); 
last -> next = last; 

} 

return 0; 


204 










int slist;;append(TREENODE * a) 


{ 

if (last) 

last = last -> next = new slink(a. last->next); 
else 
{ 

last = new shnk(aJ4ULL); 
last -> next = last; 

) 

return 0; 

I 


TREENODE • slist;;get() 

{ 

// improve the following line for better error detection 
if (last = NULL) cout« "get from empty slistNn”; 
slink* f = last-> next; 

TREENODE * r = f->e; 
if (f = last) last = NULL; 
else last ->next = f->next; 
delete f; 
return r; 

} 


void slist::clear() 

{ 

slink* 1 = last; 

if (1 == NUT-L ) return; 

do 


sUnk* U = 1; 

1 = l-> next; 
delete II; 

} while (1 != last); 


int slist::empty() 

1 

if (last = NULL) return 1; 
else return 0; 

I 


205 




slist;:-slist0 


{ 

clearO; 

1 


//.-X..X-X-X-X 

// 

// slist iterator methods 

II 

H- -X-X-X-X-X 

slist_iterator;;slistJterator(slist& s) 

cs = &s; 
ce = cs -> last; 

} 

TREENODE *slist_iterator;operator()() 

I 

TREENODE * ret = ce ? (ce = ce -> next) -> e : NULL; 
if (ce == cs ->last) ce = NULL; 
return ret; 

) 


//.X.X-.X.X-X 

// 

// TREENODE_linkedlist methods 

// 

H- -X.X-X-X-X 

TREENODE_linkedlist;;TREENODE_linkedlist() 

{ 

} 

int TREENODE_linkedlist;:member(char •name) 

I 

char *temp = name; 
return 1; 

) 


206 








// File Header.. 

//.: 

//filename.: text_objecLh 

//Date ; 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modificatioas have been conducted on almost all of the 
original code written by Dwyer and Lewis. Every function that 
accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required 1 discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

V 

H Compiler : Glockenspiel C-t-t- 2.1 
// 

// End header comments. 


#ifndef _TEXT_OBJECT_H 
#define _TEXT_OBJECT_H 

// sees ID follows: will compile to place date/time stamp in object file 

static char text_object_h_SccsId[] = “@(#)text_object.h 1.3\i9/16/91 

// Contents.. 

// 

// TEXT.OBJECT 

// 

// Description 

// 

// Defines class TEXT_OBJECT. 

// 

//End-- 

// Interface Dependencies- 

// secs ID follows: will compile to place date/time stamp in object file 


207 













// Interface Dependencies 


#include <ObjecLh> 
tinclude <streain.h3ix> 

// End Interface Dependencies - 


class TEXT_OBJECT: public Object 

{ 

private: 

char *the_file_name; 
char *the_iext; 
public: 

TEXT_OBJECT(APL *); 
TEXT_OBJECT(); 

void Destroy(Boolean aborted=FALSE): 
Type *getDirectType(); 
void append(char *, ifstreani&): 
void append(char ♦): 
void append(ifstream&); 
void text(ostream&); // standard output 
Boolean rebuildTextFile(char*): 
void dispIayFileNameO: 
char *getFileName(); 
char *text(); 
void resetTheTextO; 

• -TEXT_OBJECT() { Destroy(FALSE): 1 

): 


// Description-- 

// 

// Defines a TEXT_OBJECT class. The class TEXT_OBJECT is a derived 
// class of Object 
// 

// Constructor 

// 

// TEXT.OBJECT - APL 

// 

// ONTOS required constructor 

// 

//TEXT.OBJECT 


208 








// 

// Creates a new instance of TEXT_OBJECT 

// 

// Public Members 

// 

// Destroy 

// 

// ONTOS required method. 

// 

// getDirectType 

// 

// ONTOS rquired method used to return the class Type. 

// 

// append 

// 

// Reads in a text file. 

// 

// append 

// 

// Read in a string append to existing string in log fashion. 

II 

H text 
II 

// Send the text contents to standard output. 

II 

H rebuildTextFile 
// 

// Write the contents of a text object to a file. 

// 

// displayFileName 

H 

H Send the file name to standard output. 

// 

// getFileName 

// 

// Return a pointer the file name contained in the text object. 

// 

// text 

// 

// Returns a pointer to the text contained in the text object 

// 

// resetTheText 

// 

// Set the text field to a empty string. 


209 




// 

// -TEXT.OBJECT 

// 

// class destructor. 

// 

// End Description. 

#endif //_TEXT_OBJECT_H 


210 



// File Header- 

// . : 

//Jilename.: text_objecLcxx 

//Date ; 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
t* (»iginal code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

// Compiler : Glockenspiel C++ 2.1 

// 

// End header comments.. 


// sees ID follows: will compile to place date/time stamp 
// in object file 

static char composite_cxx_SccsId[] = "@(#)text_object.cxx 1.3\l9/16/91"; 

// Contents. 

II 

II TEXT_OBJECT;:TEXT_OBJECT Ontos Constructor 

// TEXT_OBJECT::TEXT_OBJECT 

// TEXT_OBJECT;: Destroy 

// TEXT_OBJECT::getDirectType 

// TEXT_OBJECT::append 

// TEXT_OBJECT::append 

// TEXT_OBJECT::append 

// TEXT_OBJECT:;text 

// TEXT_OBJECT;:rebuildTextFile 

// TEXT_OBJECT:;displayFileName 

// TEXT_OBJECT:;getFileName 


211 










// TEXT_OBJECT::text 

// TEXT_OBJECT::resetTheText 

// 

// Description 

// 

// Implementation of class TEXT_OBJECT member fimctions. 

// 

//End-- 

// Interface Dependencies- 

// TURN ON TRACE-DEBUG 
#define DEBUG 
#include “debug.h” 

#include “My_String.h” 

#include <strstream.hxx> 

#include <stream.hxx> 

#include <fstream.h3ix> 

#ifndef _TEXT_OB JECT.H 
#include *'text_object.h” 

#endif 

#ifndef_TRACER_H 
#include “tracer.h” 

#endif 

#ifndef _DDBDEFINES_H 
#include “ddbdefines.h” 

#endif 

extern “C-” 

{ 

#include <stdio.h> 

#include <sysAime.h> 
finclude <sysAypes.h> 

#include <stdlib.h> 

#include <strings.h> 

} 

//End- 

extern Type *TEXT_OBJECT_OType: 
extern char •dirNamePtr; 

212 












HEXT_OBJECT::TEXT_OBJECT(APL •theAPL); ObjecKtheAPL) 

// Summary- 

// 

// Ontos Required Constructor 

// 

//Return value 

// 

// A TEXT.OBJECT object 

// 

//End- 

{ 

}: 

TEXT_OB JECT: ;TEXT_OB JECT() 

// Summary- 

// 

// Constructor 

// 

// Return value 

// 

// A TEXT.OBJECT object 

// 

// the_file_name and the_text attributes are initialized to NULL; 
//End- 


the_text = (char *)My_String(‘“‘); 
the_file_name = (char *)My_String(*“*); 
putObjectO; 

}; 


void TEXT_OBJECT::Destroy(Boolean aborted) 

// Summary- 

// 

// Constructor 

// 

// Return value 

// 


213 










// A TEXT.OBJECT object 

// 

// the_file_name and the_text attributes are initialized to NULL; 
//End- 

{ 

if(the_ftle_nanie): 
delete the_file_name; 
delete the_text; 
if(abOTted) 

1 

Object::Destroy(aborted); 

) 

): 

Type •TEXT_OBJECT::getDirectType() 

// Summary- 

// 

// Ontos required method which returns the type of this object. 

// 

// Parameter 

// 

// N/A 

II 

H Return Value 

// 

// the type of this object. TEXT_OBJECT. 

// 

//End. 

return TEXT_OBJECT_OType; 

): 

void TEXT_OBJECT::append(char •filename, ifstream& input_file) 

// Summary- 

// 

// append a file as a text object 

// 

// Parameter 

// 

// filename 

// 

// character string * containing the name of the file which 


214 









4 


// is read into a texi_object. 

// 

// input_file 

// 

// file handle of input file 

// 

//Return Value 

// 

// stores the file as a text_object in the database 
//End- 

( 

TRACER(“TEXT_OBJECT::append(2 params)**); 

the_file_nanie = (char *)(My_String(filename)): 
TRACE(the_file_naine); 

ostrstream buf; 
char ch; 

while (buf && input_file.get(ch)) 

{ 

buf.put(ch): 

} 

buf.putC'O'); 
the_text = buf.strO; 
putObjectO: 

1 ; 

void TEXT_OBJECT::append(char *instring) 

// Summary-- 

// 

// append a character string as a text object, stores the character 
// string as a text_object in the database 
// 

// Parameter 

// 

// insuring 

// 

// character string * containing the description to be added as 
// a text_object. 

// 

//Return Value 

// 


215 










// N/A 

// 

//End-- 


i 

TRACER(“TEXT_OBJECT::append(l paiam-char*)"); 
tiine_t mytloc=0; 
time_t theTime; 

iheTime = time(mytloc); 

My_String Temp_Text(My_String(‘^ii”) + My_String(ctime(&theTime)) 
+ My_St^ing(‘^n”) + My_String(instring) + My_String(‘W)); 

the_text = (char *)(My_String(the_text) + Temp_Text): 

putObjectO; 

); 


void TEXT_OBJECT::append(ifstreain& input_file) 

// Summary.. 

H 

II append a file as a text object stores the file as a 
// text_object in the database 
// 

// Parameter 

// 

// input_file 

II 

H file handle of input file 

// 

// Return Value 

// 

// N/A 

// 

// End-————--— 

{ 

TRACER(‘TEXT_OBJECT::t^)pend(l paiam input_file)’l; 
time_t mytloc=0; 
time_t theTime = 0; 


ostrstream buf; 
char ch; 


216 









while (buf && input_file.get(ch)) 

I 

buf.put(ch); 

} 

buf.put(‘'iO’); 
theTime = time(mytloc); 

My_String Temp_Text(My_String(‘%n”) + My_String(ctiine(&theTime)) 
+ My_String(‘^Il”) + My_String(biif.str()) + My_St^ing(‘^n”)): 
the_text = (char *)(My_String(the_text) + Temp_Text); 

putObject(); 

} 

void TEXT_OBJECT::text(ostreani& outstream) 

// Summary.. 

// 

// output the text_object as a file, dumps the text_object to 
// the PROTOTYPE environment subdirectory 
// 

// Parameter 

// 

// outstream 
// 

// file handle of output file 

// 

// Return Value 

// 

// N/A 

// 

//End.. 


{ 

outstream «the_text; 

}; 


Boolean TEXT_OBJECT::rebuildTextFile(char •fileMode) 

// Summary- 

// 

// output the text_object as a file in “r” - read only or “w” read 
// and write mode (refer to Unix system manual), dumps the 


217 












// text_object to the PROTOTYPE environment subdirectory 

// 

// Parameter 

// 

// HleMode 

// 

// “r” - read only, “w" read/write. 

// 

//Return Value 

// 

// Boolean SUCCESS or FAILURE --refers to success of 
// rebuilding file on the disk. 

// 

//End- 

i 

TRACER(“TEXT_OBJECT;;rebuUdTextFile"); 
ofstream oFile; 

My_String My_Path = My_String((iirNamePtr) + My_String(“r) 
+ My_String(the_file_name); 
char *mypath = (char*)My_Path; 

TRACE(mypath); 

if (strcmp(fileMode. “w") — 0 If strcmp(fiIeMode. “W“) == 0) 

{ 

oFile.openfmypath.ios:: noreplace); 

if (loFile) 

{ 

cerr« “FILE “ «the_file_name « “ already exists.'^" 

« “Do you want to overwrite the file? Y or N: 
char answer, 
cin » answer, 

if (answer == ‘Y’ II answer == ‘y’) 

{ 

oFile.open(mypath,ios::out): 
oFile «the_text; 
oFile.closeO; 
return SUCCESS; 

) 

else 


return FAILED; 

) 


218 





else 


{ 

oFile «the_text; 
oFile.closeO; 

} 

} 

else 

{ 

if (the_text) 
cout«the_text; 

} 


return SUCCESS; 


void TEXT_OBJECT::displayFileName() 

// Summary. 

// 

// Displays the iext_object filename to stdout. 

// 

// Parameter 

II 

H N/A 

// 

// Return Value 

// 

// N/A 

// 

//End. 

{ 

cout«the_file_name « “\n”; 

I 

char *TEXT_OBJECT::getFileName() 

// Summary- 

// 

// Returns the attribute containing the name of the file 
// as it was stored on the disk. 

II 

H Parameter 

// 

// N/A 


219 








II 

//Return Value 
II 

U character string containing the file name of the object 

// 

//End- 

{ 

return the_file_name; 

) 


char *TEXT_OBJECT::text() 

// Summary- 

// 

// return the contents of the_text 

// 

// Parameter 

// 

// N/A 

// 

// Return Value 

// 

// character string pointer with the text in the text_object. 

// 

//End. 

{ 

return thejext; 


void TEXT_OBJECT::resetTheTextO 

// Summary- 

// 

// Reinitialize the_text attribute to a blank character. 

// 

// Parameter 

// 

// N/A 
II 

H Return Value 

// 

// N/A 

// 

//End- 


220 












strcpy(the_text. 





//FUe Header- 

// . : 

//Jilename.: thread.h 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O'Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* cniginal code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required 1 discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

// Compiler : Glockenspiel C-h- 2.1 

// 

// End header comments- 


#ifndef_THREAD_H 
#derme _THREAD_H 

// sees ID follows; will compile to place date/time stamp in 
// object file 

static char thread_h_SccsId[] = “@(#)thread.h 1.3Nt9/16/9r’; 

// Contents- 

// 

//THREAD 

// 

// Description 

II 

// Defines class THREAD. 

II 

//End.. 

// Interface Dependencies. 


222 













#include <ObjecLh> 

#inc]u(le <Dictionary.h> 

#include <Reference.h> 

#include “ReferenceMacros.h” 

#include <stream.hxx> 

class V_OBJECT; 

// End Interface Dependencies- 

TypeCheckReference(VOListReference, Reference, Dictionary); 

class THREAD ; public Object 

( 

private; 

int current_version; // most recent rev. 
int NumbeiOfVersions; 
int ffomVariation; 
int fromVersion; 

VOListReference the_list: 

public: 

THREAD(APL *theAPL); 

THREAD(char *id): 

virtual void Destroy(Boolean aborted=FALSE); 
virtual Type *getDirectTypeO: 
int getCurrentVersionNumO: 

V_OBJECT *current(); 

V_OBJECT *version(int versionjd); 
void add_object(V_OBJECT •new_obJect); 
void displayThreadVersionsO; 
void displayThreadContentsO: 

void updateNumbeiOfVersions(int); 
int getNumberOfVersionsO; 
int previousVersionO; 
int previousVariationO: 
void setPreviousVersion(int); 
void setPreviousVariation(int); 

): 


char *buildThreadName(char*, int); 


223 






// Description.. 

// 

// Defines a THREAD class. The class COMPONENT is a derived class 
// of Object (i.e. It is a persistent class). A thread may 
// contain multiple versions of an COMPONENT, composite or 
// configurations. 

// 

// ConstnKtor 

// 

// Thread -- APL 

// 

// ONTOS required constructor. 

// 

//Thread 

// 

// Constructs a thread with the given name. 

// 

// Public Members 

// 

// Destroy 

// 

// Used in lieu of a class destructor. 

// 

// getDirectType 

// 

// ONTOS required method to return the class type. 

// 

// getCurrentVersionNum 

// 

// Returns the version number of the vobject last add to the thread. 

// 

// current 

// 

// Returns a pointer to the current vobject in the thread. 

// 

// version 

// 

// Returns a pointer to a user designated version of a vobject. 

// 

// add_Object 

// 

// inserts a vobject into the thread. 

// 


224 




// displayThread Versions 

// 

// List the version numbers of vobjects contained in the thread. 

// 

// display ThreadContents 

// 

// Displays the version number and description of each vobject in the thread. 

// 

//End.. 

#endif // _THRE AD_H 


225 








// File Header- 

// . : 

//filename.: thread.cxx 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications: Extensive modifications have been conducted on almost all of the 
f* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

V 

I I Compiler : Glockenspiel C-h- 2.1 

// 

// End header comments- 


// sees ID follows; will compile to place date/time stamp in object file 

static char thread_cxx_SccsldD = “@(#)ihread.cxx 1.3Nt9/16/9r’; 

// Contents- 

// 

// THREAD: :THREAD ONTOS constructor 

// THREAD::THREAD new instance constructor 

// THREAD::Destroy 

// THREAD::getDirectType 

// THREAD::getCurrentVersionNurii 

// THREAD::current 

// THREAD::version 

// THREAD::add_object 

// THREAD::displayThreadVersions 

// THREAD;;displayThreadContents 

// 

// Description 

// 


226 













// Implementation of class THREAD member functions. 

// 

//End- 

// TURN ON TRACE-DEBUG 
#define DEBUG 
#include “debug.h” 

#include <strstream.hxx> 

tinclude <GlobalEntities.h> 

#include <stream.hxx> 

#ifndef_THREAD_H 
#include “thread.h” 

#endif 

#ifndef _VERS10NED_0BJECT_H 
#include “versioned_object.h” 

#endif 

extern Type *THREAD_OType; 
extern Type *V_OBJECT_OType: 

THREAD: :THREAD(APL *theAPL): (theAPL) 

{ 

); 


THREAD::THREAD(char *id): (id) 

// Summary- 

II 

H Constructs a persistent THREAD object. A thread contains 
// a list of V_OBJECTS (objects which version), and maintains 
// the most current version from that list of versioned 
// objects. 

// 

// A thread is stored in the ONTOS database and is given 
// visibility. Therefore, only one iterator may generate any 
// given thread. 

// 

// It is expected that Variations will inherit from threads 
// with two distinctive bits of information: 

• // 


227 









// the thread from which it spawned - 

// the version number from which it originated 

// 

// Parameter 

// 

// id 

// 

// passed to the ONTOS database and gives persistence and 
// ONTOS visibility to that object 
II 

II Return Value 

II 

H a persistent THREAD in the ONTOS database 

II 

//End- 


{ 

TRACER(“THREAD::THREAD - char* “): 
initDirec tT ype(THRE AD_OT ype); 
current_version *0; 

NumbeKDfVersions = 0; 
fromVersion * 0; 
from Variation = 0; 

Dictionary *new_list=new Dictionary(OC_integer. 

V_OBJECT_OType. 

TRUEEALSE); 


newjist ->putObject(); 
the_list Jleset(new_list, this); 
putObjectO; 

1: 


void THREAD;:Destroy(Boolean aborted) 

{ 

TRACER(“THREAD::Destroy”): 

Destroy(aborted); 

}; 

Type *THREAD;:getDirectType() 

// Summary- 

II 

H returns the ONTOS Type for the prototype class. 

// 

// Return value 


228 










// 

// A pointer to an ONTOS Type. 

// 

//End- 


TRACER("THREAD;:getDirectType”); 
return THREAD_OType: 


int THREAD:;getCurrentVersionNufnO 

// Summary- 

// 

// returns the current version number in the thread of 
// versioned objects 
// 

// Parameter 

// 

// N/A 

// 

// Return value 

// 

// An integer value representing the current version of the 
// operatorAype (as defmed by CAPS) 

// 

//End- 


I 

TRACER(“THREAD::getCurTentVersionNum”); 
return current_version; 

) 


int THREAD: :previousVariation() 

{ 

TRACER(“THREAD::previousVariation”); 
return fromVariation; 

) 

int THREAD::previousVersionO 

{ 

TRACER(“THREAD::previousVersion”); 
return ffomVersion; 


229 






} 


void THREAD: :setPreviousVersion(int ParentVer) 

I 

TRACER(“THREAD::setPreviousVersion”); 
fromVosion = ParentVer, 

) 

void THREAD::setPreviousVariation(int ParentVar) 

I 

TRACER(“THREAD::setPreviousVariation”); 
fircmVariation = ParentVar, 

} 

H m*mmm*******************************‘*‘********************************* 

void THREAD: :updateNumberOfVersions(int VerNumber) 

// Summary- 

// 

//End- 


{ 

TRACER(“THRE AD:: updateNumberOfV ersions”): 
NumberOfVersions = VerNumber, 

} 


int THREAD::getNumberOfVersions() 

//Summary- 

// 

// 


{ 

TRACER(‘*THREAD::getNumberOfVersions”); 
return NumberOfVersions; 

} 

char* buildThreadName(char *tlireadName. int variation) 

I 

TRACER(“buildThreadName”): 
if (variation = 0) 


230 








return threadName; 


) 

else 

{ 

int buffsize = strlen(threadName) + S; 

char ♦p = new char[buffsize]; 

ostrstream ost(p,buffsize): 

ost«threadName « « variation; 

osLput(‘'0’); 

return p; 

} 


jj «*****««**««*«4i4i**«*****4i«*4[««**««««««4i******«*4iik4i***************«*«** 

V_OBJECT *THREAD::currentO 

// Summary- 

// 

// returns the current versioned object in the thread. 

// 

// Parameter 

// 

// N/A 

// 

// Return value 

// 

// A V_OBJECT pointer 

// 

//End- 


I 

TRACEkCTHREADixunent"); 

Dictionary *temp_list= (Dictionary*)the_list.BiiKling(this); 

V_OBJECT *mytempvo = (V_OBJECT*)(Entity*)(*temp_list)[current_version]; 
if (mytempvo) 

{ 

TRACE(“mytempvo not NULL”); 

I 

return mytempvo; 


231 








V_OBIECT *THREAD::version(int the_version) 


// Summary- 

II 

H returns the desired version in the thread of versioned 
// objects 
// 

//Parameter 

// 

// N/A 

// 

// Return value 

// 

// A V_OBJECT pointer 

// 

//End- 

{ 

TRACER(“THREAD::version”); 

Dictionary ♦temp_list=! (Dictionary^ )the_list.Binding(this); 

V_OBJECT *mytempvo = (V_OBJE<rT*)(Entity*)(*temp_list)[the_version]; 

if (mytempvo) TRACE(*'mytempvo not NULL”); 

return mytempvo; 

}; 


void THREAD: :add_object(V_OBJECT •new_object) 

// Summary- 

// 

// adds a versioned.object to the thread, and updates the 
// cuirent_version attribute to reflect the newer version 
// 

//Parameter 

II 

H new_vobject 

// 

// V_OBJECT pointer 

// 


232 







//Return Value 

// 

// N/A 

// 

//End- 


I 

TRACER(“THRE AD: :add_object”); 
if(!this) 

1 

cerr « “<ERROR: cannot attach a v_object to a null THREAD>'n 
return; 

} 

if(!new_object) 

cerr « "<ERROR: cannot insert a null v_object into a thread>\n"; 
renrni; 

I 

else 

{ 

current_version = cunent_version + 1; 

Dictionary *tefnp_list = (Dictionary^ltheJist.Bindingithis): 
temp_list -> Insert(current_version.(Entity •)new_object): 
temp_list -> putObjectO; 
putObjectO: 

1 

1 : 


void THREAD:;<iisplayThreadVersions() 

// Summary. 

// 

// Display the versions within a thread to stdout 

// 

// Parameter 

// 

// N/A 

// 

// Return Value 

// 

// N/A 

// 

// End- 


233 









{ 

TRACER(“THREAD::displayThreadVersions”); 
Dictionary *temp_list= (Dictionary*)the_list.Bin<ling(this); 

Dictionarylterator next(teinp_list); 

while(next.moreData()) 

{ 

V_OBJECT *teinp=(V_OBJECr ‘XEntity *)nextO; 

temp-xlisplayVariationNumberO: 

temp-xlisplayVersionNumberO; 


I; 


void THREAD;;displayThreadContents() 

( 

//Summary. 

// 

// Displays the version and description of each versioned 
h object of a thread. 

// 

// NOT USED in current implementation of Design Database. 

// 

// Parameter 

// 

// N/A 

// 

// Return Value 

// 

// N/A 

// 

//End- 

TRACER(“THREAD::displayThreadContents”); 

Dictionary *tempjist= (Dictionary*)the_list.Binding(this); 

Dictionarylterator next(temp_list); 

whilefnext.moreDataO) 

I 


V.OBJECT *temp=(V_OBJECT *)(Entity *)nextO; 

temp->displayVersionNumber(); 

cout« “Nn”; 


234 





temp->getDescriptionO; 
cout«‘^n”; 







// File Header.... 

// . : 

//filename.: tree.h 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modifled by ; Michael D. O’Loughlin 

//Date ; 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* OTiginal code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

V 

// Compiler : Glockenspiel C-h- 2.1 

// 

// End header comments. 


#ifndef_TREE_H 
#define _TREE_H 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char tree_h_SccsId[] = ‘■@(#)tree.h 1.3W16/9r’; 

// Contents.. 

// 

// TREE HEADER 

// 

// Description 

// 

// Defines class TREE. 

// 

HEnA -.-.. 

// Interface Dependencies. 


236 










#ifndef _TREENODE_H 
#include ■treenode.h" 

#endif 

// End Interface Dependencies- 

class TREE 

{ 

private: 

char •tree_name: 

TREENODE * theTreeRootNode; 

public: 

TREE(7REENODE ‘.char *): // input list and resulting rootnode 
void buUd_tree(TREENODE *.TREENODE_linkedlist); 
TREENODE •fmd_treenode(TREENODE_linkedlist. char *); 

1 : 


// Description. 

// 

// Defines the TREE class. 

// 

// Constructor 

// 

// Constructs a multiway tree from a linked list of nodes 
// identified as operators from reading the subdirectory- in 
// TREENODE class. In this tree is one unique TREENODE -- 
// the “roof’. Once the root is identified, reference to 
// the tree can be passed to other classes who can then deal 
// individually with nodes in that tree through the TREENODE 
// class. 

II 

// TREE 

II 

// constructs the tree given a TREENODE object and a character 
// string pointer to the root operator. 

II 

H Public Members 
// 

// build_tree 

// 

// takes in the root TREENODE and a linked list of other 
// generic operator nodes and builds the multiway tree using 


237 





// pointers and lists of children nodes. 

// 

// find_treenode 

// 

// given a character string of a TREENODE and a linked list of 
// TREENODES, search the linked list and return a TREENODE 
// pointer on a match. Return a NULL pointer if fails. 

// 

//End--- 

#endif //_TREE_H 


238 





// File Header.. 

// . ; 

//.Filename.: tree.cxx 

//Date : 9/16/91 

// Author : Garry Lewis 

// ; Drew Dwyer 

// Modified by : Michael D. O'Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

// Compiler : Glockenspiel C-(-+ 2.1 

// 

// End header comments. 


// sees ID follows; will compile to place date/time stamp in 
// object file 

static char U'ee_cxx_Sccsld[l = ■■@(#)tree.cxx l.3Nt9/l6/9r'-. 

// Contents. 

// 

// TREE;;TREE 
// TREE::build_tree 
// TREE::find_treenode 
// 

// Description 

// 

// IMPLEMENTS class TREE CONSTRUCTORS. 

// 

//End. 

// Interface Dependencies. 


239 















// TURN ON TRACE-DEBUG 
#define DEBUG 
#inc]ude “debug.h” 


#include <Database.h> 
#include <streain.hxx> 

extern “C-” 

{ 

#include <stddef.h> 
#include <stdlib.h> 
#include <stdio.h> 
#include <string.h> 
#include <dirent.h> 
#include <sys/stat.h> 
#include <time.h> 

} 


#ifndef _TREE_H 
#include "tree.h" 

#en<lif 

#ifndef_QUEUE_H 
#include “queue.h" 

#endif 

#ifndef _NODESUPPORT_H 
#uic]ude “nodes upportb" 

#endif 

//- End Interface Dependencies - 

TREE::TREE(TREENODE *future_root,char *treename) 

// Summary- 

// 

// Constructor 

// 

// Parameter 

// 

// future_root 

II 

H TREENODE pointer containing the future root of the multiway 


240 







// tree 

// 

// treename 

// 

// character string -• the same name as the root operator 

// 

// Return Value 

// 

// A construted multiway tree reflecting the nodes which 
// exist in the subdirectory and which will be checked into 
// the design database 
// 

//End- 

{ 

tree_name = new char [strlen(treename)+l]; 
strcpy (tree_name.treename); 
theTreeRootNode = future_root; 

} 


TREENODE *TREE;:fmd_treenode(TREENODEJinkediist list_to_search. 
char *node_name) 


// Summary. 

// 

// fmd_treenode 

// 

// Parameter 

// 

// list_to_search 

// 

// aUnkedlistofTREENODES 

// 

// node_name 

// 

// the operator/type to search for (i.e. - the name of the 
// operators filename MINUS the .ps, .graph, .imp.psdl. 
// .spec.psdl. .a extension 
// 

// Return Value 

// 

// TREENODE if found -- NULL pointer if not found. 

// 

// End. 


241 








{ 

slistjterator list_iteraior(list_to_search): 
TREENODE *tnode; 
while (tnode=listJteTator()) 
if (strcmp(tnode->getname()jiode_naine)=0) 
return tnode; 
return NULL; 


) 

void TREE:;build_tree(TREENODE *root_node.TREENODE_linkedlist search_list) 

// Summary- 

II 

H Builds a multiway tree containing the nodes in the directory 
// and information required to determine whether a new version 
// of the node must be created in the ONTOS Design Database. 

// 

// Parameter 

// 

// root_node 

// 

// the unique TREENODE which is the root of this multiway tree 

// 

// search_list 

// 

// a list of operators in the subdirectory pointed to by the 
// environment variable PROTOTYPE 
// 

// Return Value 
II 

H N/A 

// 

//End.. 


{ 

TREENODE * nodeptr; 

TREENODE * temp_TREENODE_ptr; 
TREENODE • new_TREENODE_ptr; 

// create the queue inorder to construct the tree 
TREENODE_queue tree_node_queue; 
tree_node_queue.put(root_node); 


242 








// now the queue has the first TREENODE on it 
while (!tree_node_queue.einpty()) 

{ 

teinp_TREENODE_ptr = tree_node_queue.get(); 

// now iterate through searchjist, look fw NODES whose associated 
// strings are “proper” superstiings of temp_TREENODE_ptr->c^rator_name 
// If they are create a TREENODE for these child nodes. 

// put the TREENODE in queue as well as in temp_TREENODE_ptr->children 
// list. 

slist_iterator OperatorPtr(search_list): 
while (nodeptr=OperatOTPtr()) 

{ 

if (proper_super_NODE_check(nodeptr.temp_TREENODE_ptr->getnameO)) 

// create the new TREENODE 

{ 

new_TREENODE_ptr = new TREENODE(nodeptr. temp_TREENODE_ptr); 

tree_node_queue.put(new_TREENODE_ptr); 

temp_TREENODE_ptr->insertChildNode(new_TREENODE_ptr); 


} 


243 








// File Header- 

// . : 

//.Filename.: treenode.h 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by ; Michael D. O'Loughlin 

//Date : 6/18/92 

// Modifications: Extensive modifications have been conducted on almost all of the 
[* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

H Compiler : Glockenspiel C-h- 2.1 
// 

// End header comments. 


#ifndef _TREENODE_H 
#define _TREENODE_H 

// sees ID follows: will compile to place date/time stamp in 
// object file 

static char treenode_h_SccsId[] = “(®(#)treenode.h 1.3W16/9r'; 

// Contents.. 

// 

// TREENODE HEADER 

// 

// Description 

// 

// Defines class TREENODE. 

// 

//End.. 

// Interface Dependencies.— 


244 













#ifndef_QUEUE_H 
#include “queue.h'‘ 

#endif 

#ifndef _VERSIONED_OBJECT_H 
#include “versioned_object.h” 

#endif 

// End Interface Dependencies- 

class TREENODE; 

class TREENODE 

{ 

private: 

char *tree_node_nanie; 
char *node_name: 
long timestamp; 
int level; 

TREENODEJnkedlist ChildrenList; 
TREENODE • ParentNode: 

public: 

TREENODE(char ‘.TREENODE •); 
TREENODE(TREENODE ‘.TREENODE ‘); 
void updatetimestamp(long time): 
char ‘getnameO: 

void inseriChildNode(TREENODE ‘); 

TREENODE_linkedlist getChildren(); 

TREENODE ‘getParentNodeQ: 

char ‘get_asc_time(); 

int getleveU): 

long get_long_time(); 

void list_subtree(): 

void checlcin_subtree(V_OBJECT ‘); 

V_OBJECT ‘checkin_node(V_OB;ECT ‘): 

I; 


// Description- 

// 

// TREENODE 

// 

// TREENODE 

// 


245 










// Constructor - Builds a treenode to be a node plus pointer 
// information for building a multiway tree. 

// 

// updatetimestamp 

// 

// used to compare the most current fllestamp of the group of 
// five files in a versioned object from the disk directory 
// pointed to by the CAPS environment variable PROTOTYPE to 
// the locktime of the matching versioned object stored 
// in the Design database. 

// 

// getname 

// 

// returns the character string name of the treenode. 

// 

// insertChildNode 

// 

// used to insert a node as a child of the current treenode 

// 

// getChildren 

// 

// returns the linked list of children of this node 

// 

// getParentNode 

// 

// returns the parent of this node 

II 

H get_asc_time 
// 

// returns the ctime function for the treenode timestamp attribute 

// 

// getjevel 

// 

// returns the integer level (0 = root, 1 is removed from root 
// 1 level, etcetera 
// 

// get_long_time 

// 

// returns the timestamp from the treenode as a long that can 
// be used in a comparison in the checkin_node function 
// 

// list_subtree 

// 

// used for debugging. Lists the multiway tree 


246 




// 

// checkin_subtree 

// 

// after the multiway tree is built, this function launches the 
// recursion which does the bulk of the work. 

// 

// checkin_node 

// 

// the function which compares the TREENODE (as read from 
// disk) to threads in the database. If a match is found, 

// locktimes are compared to timestamp and if timestamp is 
// more recent, then a new versioned object is created for 
// the database. All version links are set up in this 
// function 
// 

// End Description.— 


#endif //headerfile 


// File Header. 

// . : 

//.Filename.: treenode.cxx 

//Date ; 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/♦ original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

// Compiler : Glockenspiel C-h- 2.1 

// 

// End header comments. 


247 








« 


// sees ID follows; will compile to place dateAime stamp in 
// object file 

static char treenode_cxx_SccsIdn = “@(#)treenode.cxx 1.3Nt9/16/9r’; 

// eontents- 

// 

// TREENODE::TREENODE 
// TREENODE::TREENODE 
// TREENODE:;updatetimestamp 
// TREENODE::getname 
// TREENODE;;insertehildNode 
// TREENODE:;getehildren 
// TREENODE::getparentNode 
// TREENODE::get_asc_time 
// TREENODE;:getlevel 
// TREENODE:;get_long_time 
// TREENODE;:list_subtree 
// TREENODE::checldn_subtree 
// TR£ENODE::checkin_node 
// 

// Description 

// 

// IMPLEMENTS class TREENODE eONSTRUeTORS and methods. 
// 

//End.. 

// Interface Dependencies. 

// TURN ON TRAeE-DEBUG 
#define DEBUG 
#include “debug.h” 

#include “My_String.h 
#include <Directory.h> 

#include <stream.hxx> 

#include <strstream.hxx> 


extern “G--” 


#include <stddef.h> 
#include <stdlib.h> 


248 






#include <stdio.h> 

#include <string.h> 

#include <diTent.h> 

#include <sys/stat,h> 

#include <tiine.h> 

#include <unistd.h> 

I 

#ifndef_THREAD_H 
#include “thread.h" 

#endif 

#ifndef _COMPONENT_H 
#include “component.h” 

#endif 

#ifndef _TEXT_OBJECT_H 
#include “text_object.h" 

#endif 

#ifndef TREENODE_H 
#include "treenode.h” 

#endif 

#ifndef _DDBDEFINES_H 
#include "ddbdefines.h" 

#endif 

#ifndef _VOBJECTFUNC_H 
#include "vobjectfunc.h” 

#endif 

//. End Interface Dependencies 

extern char ‘dirNamePtr; 


TREENODE::TREENODE(char ‘name. TREENODE* future_parent) 

\ 

tree_node_nanie = new char[strlen(name)+l]; 

strcpy(tree_node_name 4 iame); 

level=0; 

dmestamp = 0; 

ParentNode =future_parent; 

} 


249 







TREENODE::TREENODE(TREENODE *inc_data. TREENODE* future_parent) 

i 

tree_node_name = new char[strlen(inc_data->getname())+l]; 
strcpy(tree_node_name 4 nc_data->getnanie()): 
if ((future_parent)!=NULL) 
level=future_parent->getlevelO+1; 
else 

levels 1; 

timestamp = inc_data->get_long_time(); 

ParentNode = future_parent; 

} 

voidTREENODE;;iipdatetimestamp(long time) 

{ 

dmestami^time; 

} 

char *TREENODE:;getname() 

{ 

return tree_node_name; 

} 

void TREENODE"insertChildNode(TREENODE *new_child) 

{ 

ChildrenLisLinsert(new_child): 

) 

TREENODE_Unkedlist TREENODE::getChUdren() 

i 

return ChildrenList; 

} 

TREENODE *TREENODE::getParentNode() 

I 

return ParentNode; 

1 

char *TREENODE:;get_asc_time() 

( 

return ctimef&timestamp); 

} 

int TREENODE; :getlevei() 

{ 


250 





return level; 

} 

long TREENODE::get_long_time() 
return timestamp; 

} 


void TREENODE::list_subtree() 

{ 

TRACER(“TREENODE::Ust_subtree"); 
slistjterator ChildrenPtr(ChildrenList); 

TREENODE ‘tnode; 

for (;;) // recursive call inside infinite for loop 

{ 

mode = ChildrenPtrO; 
if (tnode!=NULL) 

{ 

char *name=mode->getname(): 

int level = tnode->getlevel(); 

char *asctime = mnde->get_asc_timeO; 

cout«level« « name «‘time: "«asctime: 

tnode->list_subree'^v //preorder 

} 

else 

break; // breaks when end of list reached. 

I 


void TREENODE::checkin_subtree(V_OBJECT *new_parent) 

{ 

TRACERC'TREENODE:; checkin_subtree'’); 
slist_iterator ChildrenPtr(ChildrenList); 

TREENODE ‘tnode; 

V_OBJECT *parent; 

THREAD ‘NewThreadPtr = (THREAD *X); 

THREAD *threadPtr = (THREAD *)0; 

V_OBJECT *new_object = (V_OBJECT *)0; 

V.OBJECT *var_temp = (V.OBJECT *)0; 

V_OBJECT *original_parent = (V_OBJECT *y): 
V_OBJECT ‘child.exists = (V_OBJECT ♦lO; 

List ‘children = (List *)0; 


251 





char *threadName = (char*)0; 


for (::) // recursive call inside infinite for loop 

1 

mode = ChildrenPtrO; 

if (mode!=NULL) 

{ 

parent = mode->checkin_node(new_parent); 
tnode->checkin_subtree(parent); //preorder 

1 

else 

{ 

break; // breaks when end of list reached. 

) 

} 


if (new_parent->Needs_Updating() && lnew_pareni->just_created()) 

{ 

int variationNum; 
int versionNum = 1; 
threadPtr = new_parent->getThread(); 
if (new_parent -> getVersionNumberO < 
threadPtr -> getCurrentVersionNumO) 

I 

threadName = buildThreadName(tree_node_name,l); 

THREAD *tempThread = ((THREAD *)OC_lookup(threadName)); 

var_temp = tempThread -> version(l); 

variationNum = var_temp -> getNumberOfVariationsO + 1; 

char *newThread = buildThreadName(tree_node_name.variationNum); 

NewThreadPtr = new THREAD(newThread); 

NewThreadPtr->setPreviousVariation(new_parent->getVariationNumber()); 

NewThreadPtr->setPreviousVersion(new_parent->getVersionNumber()); 

NewThreadPtr->updateNumberOfVersions( versionNum); 

NewThreadPtr->putObject(); 

newj5arent->Reset_Update(); 

original_parent = new_parent->getParent(); 

var_temp-> incrementNumbetOfVariations(); 

new_object = new V_OBJECT(versionNum); 

new_object-> copyChildren(new_parent); 

new_object-> updateVariationNumber(variationNum); 

new_object-> connect_vobject_to_thread(NewThreadJ*tr); 

new_object-> addVariationThread(NewThreadPtr. variationNum); 

var_temp-> addVariation(new_object. variationNum); 


252 





new_object->setNodeName(new_parent->getNodeNameO): 

new_object->setParent(original_parent); 

new_object-> addCOMPONENTNode(new_parent->getCOMPONENT()); 

new_object->reset_created(); 

new_object->Reset_Update(): 

if (original_parent) 

{ 

chP _exists = 

original_parent->check_for_child(new_object->getNodeName()): 
if (child_exists) 

{ 

original_parent->deleteChildNode(child_exists); 

original_parent->addChildNode(new_object); 


} 

children = new_object->getChildren(); 
if (children) 

{ 

children->putObject(); 

1 

var_temp->putObject(): 

new_object->putObject(); 

NewThreaciPtr->add_object(new_object); 

I 

else 

I 

var_temp = threadPtr -> version( I); 

versionNum = new_parent->getVersionNuniber() + 1; 

variationNum = new_parent->getVariationNumber(); 

new_object = new V_OBfECT(versionNum); 

new_object-> updateVariationNumber(variaiionNum); 

new_object-> connect_vobject_to_thread(threadPtr); 

new_object-> copyChildren(new_parent); 

new_object-> setNodeName(new_parent->getNodeName()); 

original_parent = new_parent->getParent(); 

new_object-> setParent(original_parent); 

new_object-> addVariationThread(threadPtr, variationNum); 

new_object-> addCOMPONENTNode(new_parent->getCOMPONENT()); 

new_object->reset_created(): 

new_object->Reset_Update(); 

child_exists = 

original_parent->check_for_child(new_object->getNodeName()); 
if (child_exists) 

I 


253 








OTiginal_parent->deleteChildNode(child_exists); 

OTiginal_parent->addChil(lNode(new_object); 

} 

children = new_object->getChildren(); 
if (children) 

{ 

children->putObject(); 

} 

var_temp->putObject(): 

threadPtr->add_object(new_object); 

new_object->putObject(); 


else 

{ 

if (new_parent->just_createdO) 

I 

original_parent = new_parent->getParent(): 

if (original_parent) 

( 

child_exists = 

original_parent->check_for_child(new_parent->getNodeNaine())-. 
if (child_exists) 

{ 

original_parent->deleteChildNode(child_e)usts): 

1 

original_parent->addChildNode(new_parent); 

} 

new_parent->teset_creaied(): 
new_parent->Reset_Update(); 
children = new_parent->getChildren(); 
if (children) 

{ 

children->putObject(); 

1 

new_pair;it->putObject(): 

} 

} 


V_OBJECT *TREENODE::checkin_node(V_OBJECT *future_parent) 

I 


254 








TRACER(‘TREENODE::checkin_node"); 

ifstream psfile; 

ifstream graphfile; 

ifstream impfile: 

ifstream specfile: 

ifstream sourcefile; 

Boolean create_new_vobject = FALSE: 

Boolean new_thread_created = FALSE; 

Boolean lockTime_timeStamp = FALSE; 

Boolean new_spec_object = FALSE; 

Boolean new_graph_object = FALSE; 

Boolean new_imp_object = FALSE; 

Boolean new_ps_object = FALSE; 

Boolean new_source_object = FALSE; 

Boolean SPEC.FILE = FALSE: 

Boolean GRAPH.FILE = FALSE; 

Boolean IMP_FILE = FALSE; 

Boolean PS_FILE = FALSE; 

Boolean SOURCE_FILE = FALSE; 

TEXT_OBJECT * new_graphfde_object = new TEXT_OBJECT(); 
TEXT.OBJECT * new_sourcefile_object = new TEXT_OBJECT(); 
TEXT_OBJECT * new_impfile_object = new TEXT_OBJECT(); 
TEXT.OBJECT * new_psfile_object = new TEXT_OBJECT(): 
TEXT_OBJECT * new_specfile_object = new TEXT_OBJECT0: 

char *psfdename; 
char ‘graphfdename; 
char *impfdename; 
char *specfUename; 
char *sourcefilename; 

char *COMPONENT_psfdename; 
char •COMPONENT_graphfdename; 
char •COMPONENT_impfdename; 
char *COMPONENT_specfdename; 
char *COMPONENT_sourcefilename; 

psfdename = (char*)(My_String(dirNamePtr) + My_String(“r) + 
My_String(lree_node_name) + My_String(“.ps”)); 

graphfilename = (char*)(My_String{dirNameF*tr) + My_String(“r) + 
My_String(tree_node_name) + My_String(‘‘.graph”)); 


255 




specfUename = {char*)(My_String(<lirNamePtr) + My_String("/'’) + 
My_String(tree_node_name) + My_String(“.spec.psdl”)); 

impfilename = (char*)(My_String(dirNamePtr) + My_String(“/’’) + 
My_String(tree_node_name) + My_String{“.imp.psdl")); 

sourcefilename = (char*)(My_String(dirNamePir) + My_String(“/’’) + 
My_String(tree_node_nanie) + My_String(“.a”)); 

COMPONENT_psfilename = (char*)(My_String(tree_node_name) + 
My_String(“.ps”)): 

COMPONENT_graphfilename = (chai*)(My_String(tree_node_naiTie) + 
My_String(‘'.graph'’)); 

COMPONENT^impfilename = (char*)(My_String{tree_node_name) + 
My_String(“.imp.psdl")); 

COMPONENT_specfilename = (char*)(My_String(tree_node_name) + 
My.StringC’.spec.psdl”)); 

COMPONENT_sourcefilenafne = (chaf*)(My_String(tree_node_name) + 
My_String(“.a")): 

psfiIe.open(psfilename); 

graphfile.open(graphfilename): 

impfile.open(impfilenaine); 

specfile.open(specfilename); 

sourcefile.open(sourcefilename): 


THREAD *NewThreadPtr = (THREAD •)0; 
THREAD *threadPtr = (THREAD •)0; 
V_OBJECT •vobjectPlr = (V_OBJECT •)0; 
V_OBJECT *new_vobject = (V_OBJECT*)0; 
V_OBJECT •var_temp = (V_OBJECT’‘)0; 
V_OBJECT *SameVarPtr = (V.OBJECT *)0; 
DDBControlData *Working_VarVerPtr, 
char *p = (char *)0; 
char *pp = (char *)0: 
char *oldPsText = (char *)0; 
char *oldSourceText = (char •)0; 
char *oIdSpecText = (char *X): 


256 



char *oldImpText = (char *)0; 
char *oldGraphText = (char *)0; 
long vobjectjocktiine = 0; 
int versionNum = 1; 
int variationNum = 0; 

p = buildThreadName(tree_node_name.l): 
if (threadPtr = ((THREAD *)OCJo(*up(p))) 

( 

char *ddbcontrolpath = new char [strlen(dirNamePtr) + sirlen(tree_node_name) +13]; 
strcpy (ddbcontrolpaih.dirNamePtr); 
strcat (ddbcontrolpath.’VddbCtrlData.”); 
strcat (ddbcontrolpath.tree_node_name); 

Working_VarVerPtr = getddbControlFile(ddbcontrolpath); 

if(Working_VarVerPtr) 

{ 

var_temp = threadPtr -> version(l): 

V_OBJECT *new_var_te(np = 

var_temp -> variation(Working_VarVerPtr->variation); 
threadPtr = new_var_temp -> getThreadO; 
vobjectPtr = threadPtr -> version(Working_VarVerPtr->version); 
char •removeControlFile = new char[3 + strlen(ddbcontrolpath)]: 
unlink (ddbcontrolpath): 

} 

else 

( 

cerr« “Getting default Variation, VersionNn”; 

vobjectPtr = getDefaultVObject(threadPtr); 

cerr « “Default variation being added to variation “ 

« vobjectPtr-> getVariationNumber() 

« “ version “ « vobjectPtr-> getVersionNumberO « “Sn": 

} 

vobjectjocktime = vobjectPtr ->getLockTime(); // return locktime 

1 

else 

{ 

NewThreadPtr = new THREAD(p); 

CTBate_new_vobject = TRUE; 
new_thread_created = TRUE; 
vobjectjocktime = TRUE; 

) 


if (vobjectPtr) 


257 






I 

COMPONENT *SCOMPONENTPtr; 

SCOMPONENTPtr = vobjectPtr->getCOMPONENT(); 
oldSpecText = SCOMPONENTPtr-> getTEXTPtr(SPEC_EXT); 
COMPONENT ♦SRCOMPONENTPtr. 

SRCOMPONENTPtr = vobjectPtr->getCOMPONENT(); 
oldSourceText = SRCOMPONENTPtr-> getTEXTPtr(SOURCE_EXT); 
COMPONENT •GCOMPONENTPtr. 

GCOMPONENTPtr = vobjectPtr->getCOMPONENT(); 
oldGraphText = GCOMPONENTPtr-> getTEXTPtr(GRAPH_EXT): 
COMPONENT *ICOMPONENTPtr; 

ICOMPONENTP*tr = vobjectPtr->getCOMPONENT(); 
oldImpText = ICOMPONENTPtr-> getTEXTPtr(IMP_EXT); 
COMPONENT *PCOMPONENTPlr; 

PCOMPONENTPtr = vobjectPtr->getCOMPONENT(); 
oldPsText = PCOMPONENTPtr-> getTEXTPtr(PS_EXT); 

} 


if (specfile) 

( 

char *newText; 

SPEC.FILE = TRUE; 

new_specfile_object->append(COMPONENT_specfilename.specfile): 
newText = new_specfile_object->text(); 
if (loldSpecText) 

{ 

new_spec_object = TRUE; 

) 

else 

1 

il (strcmp(newText, oldSpecText) == 0) 

( 

new_spec_object = FALSE; 

} 

else 

{ 

new_spec_object = TRUE; 

) 

} 


if (sourcefile) 

i 

char *newText; 


258 





SOURCE.FELE = TRUE; 

new_sourcefile_object->append(COMPONENT_sourcefilenaine,sourcefile): 
newText = new_sourcerile_object->text(); 
if (loldSourceText) 

{ 

new_source_object = TRUE: 

) 

else 

{ 

if (strcmpfnewText, oldSourceText) = 0) 

I 

new_source_object = FALSE: 

} 

else 

{ 

new_source_object = TRUE; 

I 


if (grapiTile) 

{ 

char‘newText; 

GRAPH_FILE = TRUE; 

new_tJraphfile_object'>append(COMPONENT_graphfilename.graphfi]e); 
newText = new_graphrile_object->text(): 
if C.oidGraphText) 

{ 

nev. _graph_object = TRUE; 

1 

else 

{ 

if (>trcmp(newTexu oldGraphText) == 0) 

I 

!:ew_graph_object = FALSE; 

I 

else 

( 

new_graph_object = TRUE; 

) 


259 


J 





if (impfile) 

{ 

char *newText; 

IMP.FILE = TRUE; 

new_impfile_object->append(COMPONENT_impfilename4inpfile): 
newText = new_impfile_object->text(); 
if (loldImpText) 

{ 

new_iinp_object = TRUE; 

} 

else 

{ 

if (strcmp(newText, oldImpText) == 0) 

{ 

new_imp_object = FALSE; 

) 

else 

{ 

new_iinp_object = TRUE; 


if (psfile) 

{ 

char *newText; 

PS.FILE = TRUE; 

new_psfile_object->append(COMPONENT_psfilenanie.psfile); 
newText = new_psfile_object->textO; 
if (loldPsText) 

{ 

new_ps_object = TRUE; 

} 

else 

I 

if (strcnip(newText. oldPsText) = 0) 

{ 

new_ps_object = FALSE; 

} 

else 

{ 

new_ps_object = TRUE; 


260 





) 

if ((new_spec_object II new_graph_object II new_imp_object II 
new_source_object II new_ps_object) && vobjectPir) 

{ 

Boolean last_operation_was_checkin = vobjectPtr->get_last_operation(); 
if (last_operation_was_checkin) 

( 

cout« “Last operation was VAA ... Preventing duplicaiesNn"; 
return vobjectPtr 

) 

else 

i 

if (vobjeclPtr -> getVersionNumberO < 
threadPtr -> getCuirentVersionNumO) 

I 

variationNum = var_temp -> getNumberOfVariar»ons() + 1; 
p = buildThreadName(tree_node_name, variationNum); 

NewThreadPtr = new THREAD(p); 

NewThreadPtr->setPreviousVariation(vobjectPtr->getVariationNumber()): 

NewThreadPtr->setPreviousVersion(vobjectPtr->getVersionNumber()): 

NewThreadPtr->putObject(); 

new_thread_created = TRUE: 

create_new_vobject = TRUE; 

I 

else 

{ 

versionNum = vobjectPtr -> getVersionNumberO + 1; 
variationNum = vobjectPtr -> getVariationNumber(); 
create_new_vobject = TRUE; 


} 


\ 


if (vobjectPtr) 

{ 

vobjectPtr->reset_created(); 

vobjectPtr->releaseLock(); 

vobjectPtr->resetLastOpTrue(); 

vobjectPtr->resetVisitedFlag(): // Just for good measure, before pass 2 
vobjectPtr->putObject(); 

I 


261 




if (create_new_vobject) // if compare says I need a new 

{ 

new_vobject= new V_OBJECT(versionNum); 

if (vobjectPtr) 

{ 

new_vobject->copyChildren( vobjectPtr); 

} 

COMPONENT ♦new_COMPONENT=new COMPONENT(); 

if (new_thread_created) 

{ 

if (var_temp) 

{ 

var_temp-> incrementNumbetOfVariationsO: 
int nextVariation = var_temp-> getNumberOfVariationsO; 
new_vobject-> updateVariationNumber(nextVariation): 
new_vobject-> connect_vobject_to_thread(NewThreadPtr); 
new_vobject-> addVariationThread(NewThreadPtr. nextVariation): 
var_temp-> addVariation(new_vobject, nextVariation); 
var_temp->putObject(); 

NewThreadPtr->displayThreadVersions(): 

I 

else 

{ 

new_vobject-> incrementNumbetOfVariationsO; 
int nextVariation = new_vobject-> getNumberOfVariationsO; 
new_vobject-> updateVariationNumber(nextVariation); 
new_vobject-> addVariationThread(NewThreadPtr, nextVariation); 
new_vobject-> addVariation(new_vobject, nextVariation): 
new_vobject->connect_vobject_to_thread(NewThreadPtr); 


} 

else 

{ 

new_vobject-> updateVariationNumber(variationNum); 
new_vobject->connect_vobject_to_thread(threadPtr); 

I 

if(PS_FELE) 

{ 

new_COMPONENT ->addTextObject{new_psfUe_obJect): 


262 






if(GRAPH_FILE) 

{ 

new_COMPONENT ->addTextObject{new_graphfile_object): 

} 

if(SPEC_FILE) 

new_COMPONENT ->addTextObject(new_specfile_object); 

} 

if(IMP_FILE) 

{ 

new_COMPONENT ->addTextObject(new_impfile_object); 

1 

if(SOURCE_FILE) 

I 

new_COMPONENT ->addTextObject(new_sourcefile_objeci); 

) 

new_vobject->addCOMPONENTNode(new_COMPONENT); 

if (nev. _thread_created) 

1 

NewThreadPtr->updateNumberOfVersions(versionNum); 

NewThreadPtr->add_objecl(new_vobject); 

) 

else 

I 

threadPtr->updateNumberOfVersions(versionNum); 
threadPtr->add_object( new_vobject); 

} 


psfile.closeO; 

graphfde.closeO; 

impfile.closeO; 

specfile.closeO; 

sourcefile.closeO: 

unlink(psfilename); 

unlink(sourcefilename); 

unlink(impfilename); 


263 




unlink(specfilename): 
unlink(graphfilename); 
if (create_new_vobject) 

{ 

new_vobject->setNodeNaine(getnameO): 

new_vobject->setParent(future_parent); 

new_vobject->Update_Parent(); 

return new_vobject; // return new version of vobject as parent 

) 

else 

{ 

vobjectPtr->setParent(future_parent); 

return vobjectPtr; // return old version of vobject as parent 

} 


264 






// File Header- 

// . : 

//filename.: versioned_object.h 

//Date : 9/16/91 

// Author ; Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications : Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

II Compiler : Glockenspiel C++ 2.1 
// 

// End header comments. 


#ifndef _VERSIONED_OBJECT_H 
#define _VERS10NED_0BJECT_H 

// sees ID follows; will compile to place date/time stamp in object file 

static char versioned_object_h_SccsIdD = “@(#)versioned_object.h 1.3Nt9/16/91 ; 

#include <Object.h> 

#include <Listh> 

#include <Dictionary.h> 

#include <Reference.h> 

#include “ReferenceMacros.h” 

#include <stream.hxx> 


extern “C-” 

{ 

#include <sysAime.h> 
#include <sys/types.h> 
#include <string.h> 


265 









) 

#ifndef_THREAD_H 
#include “thread.h” 

#endif 

#ifndef _COMPONENT_H 
#include “component.h” 

#endif 

#define DEFAULT.VER 1 

TypeCheckReference(VariationReference. Reference, Dictionary); 
TypeCheckReference(NewVariationThreads, Reference. Dictionary); 
TypeCheckReference(DescReference, Reference. TEXT.OBJECT); 
TypeCheckReference(COMPONENTObjReference. Reference. COMPONENT): 
TypeCheckReference(ChildVObjReference. Reference. List); 
TypeCheckReference(ThreadObjReference. Reference. THREAD): 

class V.OBJECT: public Object 

{ 

TypeCheckReferencefParentObjReference. Reference. V.OBJECT); 
private: 

int theVersionNutnber; 
int theVariationNumber. 
int NumberOfVariations; 
time.t creationDate; 
time.t lockTime; 
char *node_naine; 
char *creaior, 
char *worker; 

Boolean visited: // for navigation through tree structure 

Boolean last_op_checkin; // guards against double checkin 

Boolean needsUpdating; 

Boolean created; 

DescReference theDescriptionPtr; 

NewVarialionThreads NewVariations; 

VariationReference VariationList; 

ThreadObJReference theThreadPtr. 

COMPONENTObJReference theCOMPONENTPtr. 

ChildVObJReference theChildPtr, 

ParentObjReference theParentPtr; 


266 




public: 


V_OBJECT(APL *); 

V_OBJECT(int= DEFAULT. VER); 
void Destroy(Boolean aborted=FALSE): 

Type *getDirectType(); 

void connect_vobject_to_ihread(THREAD *); 

void setParent(V_OBJECT *); 

void setNodeNaine(char *); 

char *getNodeNameO; 

void getVObjNameO; 

char *getName(); 

void resetVisitedFlagO; 

void setVisitedRagO; 

Boolean getVisitedFlagO: 
void getVObjComponentsNameO: 

void displayVariationNumberO; 

int getVariationNuniberO; 

void updateVariationNuniber(int); 

V.OBJECT *variation(int); 

void displayNumberOfVariationsO; 

int getNumberOfVariationsO: 

void incrementNumbeiOfVariationsO; 

void addVariation(V_OBJECT *, int); 

THREAD *getThread(); 

void addVariationThreadCTHREAD *, int): 

void copyChildren(V.OBJECT*); 

V.OBJECT *check_for_child(char *); 

Boolean Needs_Updaling(); 

void set_created(); 

void reset.createdO; 

Boolean just.createdO; 
void Update.ParentO; 
void Reset_Update(); 

void displayVersionNumberO; 

int getVersionNumberO; 
void dumpVObjSummaryO; 
time.t setCreationDateO; 
time.t getCreationDateO; 
void setLockO; 
char *getWorker(): 
char ‘getCrejuorO; 


267 



void setWorkerO; 
void resetLastOpTnieO; 
void resetLastOpFalseO: 

Boolean get_last_operation(); // returns true if last op was checkin 

int releaseLockO: 

time_t getLockTimeO; 

void getDescriptionO; 

void listChildrenO; 

void longlistOperatoiNamesO; 

void listOperatorNamesO; 

void updateDescription(char *, ifstream &); 

void addCOMPONENTNode(COMPONENT *); 

void deleteChildNode(V_OBJECT *); 

void addChildNode(V_OBJECT *); 

V_OBJECT *getParent(); 

COMPONENT *getCOMPONENT(); 
void dumpSubtree(char *); 
void releaseLockSubtreeO; 

List *getChildren(); 

Boolean getChildPtrO: 

Boolean checkoutCOMPONENTNode(char *); 

-V_OBJECT() ( Destroy(FALSE); }; 

I: 


// Description. 

// V_OBJECT 
// V_OBJECT 
// 

// Constructors - builds a persistent object in the Ontos 
// database. 

// 

// Destroy 
II 

// Required by Ontos. Every persistent object must have a 
// destroy function. 

II 

// getDirectType 
II 

H Returns an Ontos Type 

// 

// connect_vobject_to_thread 

// 

// Connects a vobject to a thread bearing it's name. 

// 


268 









// setParent 

II 

H Used to establish links (Transparent References as Ontos 
// calls them) in the E>esign Database reflecting the 
// decomposition of CAPS operators/types. 

// 

// setNodeName 

II 

H NodeName is maintained as a separate character string field. 
// 

// getNodeName 

// 

// get the shorter NodeName 

// 

// getVObjName 

// 

// Displays the versioned object's name to stdout 

// 

// getName 

// 

// returns the character string pointer of the Operator Name 

// 

// resetVisitedFlag 

// 

// resets visited to FALSE 

// 

// setVisitedFlag 

// 

// sets visited to TRUE 

// 

// getVisitedFlag 

// 

// returns the value of visited (Boolean) 

// 

// getVObjComponentsName 

// 

// display the different components in the Operator 

// 

// displayVersionNumber 

// 

// Display the version number of the V_OBJECT to stdout 

// 

// getVersionNumber 
// 


269 





// return the int versionNumber 

// 

// dumpVObjSummary 

// 

// dump predetermined attribute values to the stdout/stderr 

// 

// setCreationDate 

// 

// gets the system time and stores it in CreationDate 

// 

// getCreationDate 

// 

// Displays the creation date as a 26 character ascii text 
// string of the date and time 
// 

// setLock 

// 

// sets the lock to the system time 

// 

// getWorker 

// 

// returns the character string containing the workers name 

// 

// getCreator 

// 

// returns the character string containing the V_OBJECT 
// creators name 
// 

// setWorker 

// 

// gets the UNIX UserPtr variable and stores the value of that 
// variable into worker 
// 

// resetLastOpTrue 

// 

// Tells the system that the last operation on that V_OBJECT 
// was a checkin. Prevents duplicate checkins from creating 
// new versioned objects on each checkin 
// 

// resetLastOpFalse 

// 

// resets the last operation immediately following checkin 

// 

// get_last_operation 


270 






// 

// returns a Boolean TRUE if last operation was an add 

// 

// releaseLock 

// 

// sets the lockTime back to 0 (epoch time) Sometime in 1969. 

// 

// getLockTime 

// 

// return the lockTime as a time_t (long) structure 

// 

// getDescription 

// 

// Display the V_OBJECT description (if one exists) 

// 

// listChildren 

// 

// list V_OBJECT s chilren 

// 

// longUstOperatorNames 

// 

// list V_OBJECT’s children 

// 

// listOperatorNames 

// 

// gives the explicit name of the operator (to include 
// path information from the root V_OBJECT 
// 

// updateDescription 

// 

// updates the versioned_objects description. 

// 

// addCOMPONENTNode 

// 

// adds an COMPONENT object to this V_OBJECT using the Ontos 
// binding mechanism 
// 

// deleteChildNode 

// 

// removes an operator from the children list of the 
// current V_OBJE(rT 
// 

// addChildNode 

// 


271 




// adds an operator to the children list of the V_OBJECT 

// 

// getParent 

// 

// returns the parent V_OBJECT 

II 

H getCOMPONENT 
// 

// returns an COMPONENT pointer if one is contained in this 
// V.OBJECT 
// 

// dumpSubtree 

// 

// attempts to rebuild files from versioned objects onto 
// the UNIX subdirector> referenced by the UNIX variable 
// PROTOTYPE 
// 

// releaseLockSubtree 

// 

// resets that node and every node under it to zero 
// epoch time (sometime in 1969) 

// 

// getChildren 

// 

// returns a list of the children of the current V_OBJECT 

// 

// getChildPtr 

// 

// returns a Boolean TRUE if the Cardinality of the list 
// referenced by the theChildPtr is > zero 
// 

// checkoutCOMPONENTNode 

// 

// attempts to rebuild the .ps. .graph, .imp.psdl. .spec.psdl 
// and .a files of an operator/type stored in the Design 
// Database 
// 

//End -.... 

#endif 


272 





// File Header- 

// . : 

//Jilename.: versioned_object.cxx 

//Date ; 9/16/91 

// Author : Gan7 Lewis 

// : Drew Dwyer 

// Modified by ; Michael D. O'Loughlin 

//Date : 6/18/92 

// Modifications: Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*t 

//Compiler : Glockenspiel C-h-2.1 

II 

H End header comments. 


// sees ID follows: will compile to place date/time stamp in object file 

static char versioned_object_cxx_Sccsld[] = •‘(©(#)versioned_object.cxx 1.3\i9/16/9r' 

// Contents. 

// 

// V_OBJECT::V_OBJECT 

// V_OBJECT;:V_OBJECr 

// V_OBJECT::Destroy 

// V_OBJECT::getDirectType 

// V_OBJECT::connect_vobject_to_thread 

// V_OBJECT::setParent 

// V_OBJECT::setNodeName 

// V_OBJECT:;getNodeName 

// V_OBJECT;:getVObjName 

// V_OBJECT::getName 

// V_OBJECT::resetVisitedFlag 

// V_OBJECT::setVisitedFlag 

// V_OBJECT::getVisitedFlag 

// V_OBJECT::getVObjComponentsName 


273 








// V_OBJECT::displayVariationNifmber 
// V_OBJECT::getVariationNuinber 
// V_OBJECT;;updateVariationNumber 
// V_OBJECT::displayVersionNumber 
// V_OBJECT::getVersionNuinber 
// V_OBJECT::duinpVObjSununary 
// V_OBJECT::setCreationDate 
// V_OBJECT:;getCreationDate 
// V_OBJECT::setLock 
// V_OBJECT:;getWorker 
// V_OBJECT::getCreator 
// V_OBJECT::setWorker 
// V_OBJECT;:resetLastOpTrue 
// V_OBJECT::resetLastOpFalse 
// V_OBJEC?T:;get_last_operalion 
// V_OBJECT::releaseLock 
// V_OBJECT::getLockTime 
// V_OBJECT;:getDescription 
// V_OBJECT::IistChUdren 
// V_OBJECT::longlistOperatorNames 
// V_OBJECT::listC)peratorNames 
// V_OBJECT::up(lateDescription 
// V_OBJECT::addCOMPONENTNo(le 
// V_OBJECT:;deleteChildNode 
// V_OBJECT:;addChUdNode 
// V_OBJECT;;geiParent 
// V_OBJECT::getCOMPONENT 
// V_OBJECT;:dumpSubtree 
// V_OBJECT::releaseLockSubtree 
// V_OBJECT;:getChiIdren 
// V_OBJECT::getChUdPtr 
// V_OBJECT::checkoutCOMPONENTNode 
// 

// Description 

// 

// methods for manipulating versioned objects 

// 

//End --- 

// Interface Requirements.. 

// 

// TURN ON TRACE-DEBUG 
#define DEBUG 


274 







#include “debug.h' 


#include <GlobalEntities.h> 

#include <Directory.h> 

tifndef _VERSIONED_OBJECT_H 
#include “versioned_object.h” 

#endif 

#ifhdef_TRACER_H 
#include “tracer.h” 

#endif 

#ifndef _DDBDEFINES_H 
#include “ddbdefines.h” 

#endif 

#ifndef _VOBJECTFUNC_H 
#include “vobjectfunc.h” 

#endif 

H Constructor // 

// End Interface Requirements. 

extern Type *THREAD_OType: 
extern Type *V_OBJECT_OType: 
extern userPtr; 
extern char *dirNamePtr; 


V_OBJECT;;V_OBJECT(APL *theAPL): Object(theAPL) 

// Summary.. 

// 

// This is an activation constructor required by ONTOS. 

// ONTOS calls the activation constructor anytime an object 
// is brought into memory. Note the constructor passes 
// theAPL to the base class APL constructor. 

// 

// Parameter 

// 

// theAPL 

// 

// A pointer to an APL (for Activation Parameter List) a 


275 









// stnicture. 


1 

// empty by design 

I: 


//End- 

// Constructor // 

V_OBJECT;;V_OBJECT(int versionNum) 

// Summary.. 

// 

// Parameter 

// 

// Functional Description 

// 

{ 

initDirectType(V_OBJECT_OT>'pe); 
theVariationNumber = 0; 
theVersionNumber = versionNum; 
NumbeiOfVariations = 0; 
creationDate = setCreationDateO; 
lockTime = 0: 
last_op_checkin = TRUE; 
visited = FALSE; 
created = TRUE; 

creator = new char [strlen(userPtr)+l]; 

strcpy(creator,userPtr); 

worker = (char *10; 

node_name = (char *)0; 

needsUpdating = FALSE; 

theDescriptionPtr.initToNullO; 

theCOMPONENTPir.initToNuUO; 

theThreadPtr.initToNuUO; 

theParentPtr.initToNulK); 

List *newChildList = new List(V_OBJECT_OType); 
newChildList -> putObjectO; 
theChildPtr Jleset(newChildList, this); 

if (!THREAD_OType) 


276 





THREAD_OType = (Type*)OC_lookupCTHREAD”); 

} 

Dictionary *new_variation = new Dictionary(C)C_integer, 

THREAD_OType, 

TRUE, FALSE); 
new_variaiion ->putObject(); 
NewVariationsJleset(new_variation, this); 

Dictionary *variationPtr = new Dictionary(OC_integer, 

V_OBJECT_OType, 

TRUE, FALSE); 

variationPtr ->putObject(); 

VariationListJReset(variationPtr. this); 

putObjectO; 

}; 

//End. 


// Member Function (in lieu of destructor)// 

void V_OBJECT;;Destroy(Boolean aborted) 

// Summary. 

// 

// This one is semi tricky. Destroy redefined the Destroy 
// function inherited from the class CleanupObj. DestroyO 
// is used to delete CleanupObj objects and those of all its 
// derived classes. In defining any class that is directly 
// or indirectly derived from CleanupObj. provide the 
// function DestroyCBooIean aborted) in place of a destructor 
// if there is any special processing required when the 
// object’s memory is deallocated. 

// 

// Parameter 

// 

// aborted 

// 

// If DestroyO is called as a result of an abort, aboned 
// is set to TRUE; if it is called to delete the object for 
// other reasons, aborted is set to False. 

// 

// Functional Description 


277 





// 

// CleanupObj in effect provides an audit trail of the 
// creation of all stack-based instances of its derived 
// classes, so that they can be cleanly deleted in the 
// case of an abort during exception handling. Hence 
// the Destroy function. 


Object:: Destroy(aborted); 

}; 

//End.. 

// Member Function // 

Type* V_OBJECT::getDirectType() 

{ 

return V_OBJECT_OType: 

1 


// Member Function // 

void V_OBJECT::connect_vobject_to_thread(THREAD *threadPtr) 

( 

TRACER('‘V_OBJECT;:connect_vobject_to_thread”): 

theThreadPtr.Reset(threadPtr.this): 

) 


void V_OBJECT::setParent(V_OBJECT *parent) 

{ 

theParentPtr.Reset(parent.this); 

} 

void V_OBJECT::setNodeName(char *tree_node_name) 

( 

char ♦token = (char *X): 

token = strrchr(tree_node_name,’.'); 

if (token) 

{ 

node_name = new char(strlen(token)+l]; 
strcpy(node_name,token): // token in the subtree 

node_name+-f; // discard period (.) 

1 

else 


278 







{ 


node_name = new char [strlen(tree_node_name)+l]i 
strcpy(node_naine,tree_node_name); // must be root root. 

} 


char '''V_OBJECT::getNodeName() 

1 

return node_name; 

} 

char * V_OBJECT::getName() 

{ 

char *name; 

Directory ‘directory; 


if(!this) 

{ 

cerr« "<ERROR: cannot get the name of a null V_OBJECT>\n"; 
return NULL; 

} 

if (ItheThreadPtr) 

I 

cerr « “<ERROR: cannot display the name of a null thread>Nn"; 
return NULL; 

I 

else 

( 

THREAD ‘myThreadPtr = (THREAD*) theThreadPtr.Binding(this); 
name = myThreadPtr -> Name(); 

OC_getNameComponents(name, &directory. &name); 
return name; 

} 

} 


// Member Function // 

void V_OBJECT;;getVObjName() 

I 

char ‘name; 

Directory ‘directory; 

ifdthis) 


279 




{ 

ceir « “<ERROR: cannot get the name of a null V_OBJECT>\n”; 
return; 

1 

if (ItheThreadPtr) 

i 

cerr « “<ERROR; cannot display the name of a null threa(l>Nn”; 
return; 

1 

else 

{ 

THREAD *myThreadPtr = (THREAD*) theThreadPtr.Binding(this); 
name = myThreadPtr -> Name(); 

C)C_getNameComponents(name, ctdirectory. &name); 
cout« name « 

} 


// Member Function // 

void V_OBJECT::getVObjComponentsName() 

{ if(!this) 

( 

cerr « “<ERROR: cannot get the names of a null V_OBJECT>Nn"; 
return; 

} 

if (ItheCOMPONENTPtr) 

{ 

cerr «’‘<ERROR: This v_object does not have an COMPONENT component>\n''; 
return; 

I 

else 

i 

COMPONENT *myCOMPONENTPtr = (COMPONENT*) theCOMPONENTPtr.Binding(this); 
myCOMPONENTPtr -> getComponentNames(); 


jj «*«4i«:*>««««4i«*««***************«:t<*****'**********4'<k***«**<k**************** 

V_OBJECT *V_OBJECT::variation(int variationNumber) 

// Summary 

// 


280 



// 

//End 

{ 

TRACER (“V_OBJECT:;variation”); 

Dictionary *temp_list = (Dictionary*) VariationList.Binding(this); 

V.OBJECT *mytempvo = (V.OBJECT*) (Entity*) (*temp_Ust) [variationNumber]: 
if (mytempvo) TRACE(“mytempvo not NULL”); 
return mytempvo; 

): 

void V_OBJECT;:displayVariationNumber() 

// Summary- 

// 

// This function displays the variation number of an object. 

{ 

cout «theVariationNumber « " "; 

1 ; 

int V_OBJECT:;getVariationNumberO 

{ 

return theVariationNumber; 

) 

void V_OBJECT;;updateVariationNumber(int NewVariationNumber) 

// Summary- 

// 

// This function updates the variation number of an object. 

{ 

theVariationNumber = NewVariationNumber; 

}: 

void V_OBJE(rT::displayNumberOfVariations() 

// Summary.. 

// 

// This function displays the number of variations of an object 


cout« NumberOfVariations « 


281 






}: 

im V_OBJECT;:getNumberOfVariations() 

{ 

return NumberOfVariations; 

) 

THREAD *V_OBJECT::getThreadO 

if (theThreadPtr) 

{ 

THREAD *tempThread = (TTIREAD *) theThreadPir.Binding(this); 
return tempThread; 

} 

else 

( 

THREAD *nullthread = (THREAD *)0; 
return nuUthread; 

} 


void V_OBJECT;;incrementNutnberOfVariations() 

// Summary. 

// 

// This function updates the variation number of an object. 

( 

NumberOfVariations = NumberOfVariations + 1; 


void V_OBJECT::addVariation(V_OBJECT *V_ObjeciPtr. int nextVariation) 

( 

if (Ithis) 

I 

cerr « “<ERROR: cannot set the Variation node of a null V_OBJECTn''; 
return; 

I 

if (!V_ObjectPtr) 

{ 

cerr« “<ERROR in AddVariation\n”; 
return; 

) 

Dictionary *VarDictionaryPtr = (Dictionary*)VariaiionList.Binding(this); 


282 







VarDictionaryPtr -> Insert(nextVariation. (Entity ♦) V_ObjectPtr); 
VarDictionaryPtr -> putObjectO; 


void V_OBJECT::addVariationThread(THREAD •NewThreadPtr. int nextThread) 

( 

if (!this) 

{ 

cerr«‘•<ERROR; cannot set the Variation node of a null V_OBJECTfl”; 
return; 

I 

if (INewThreadPtr) 

{ 

cerr« “<ERROR in Add Variation Thread.Vi**; 
return; 

I 

Dictionary *ThreadDictionar\Ptr = (Dictionary*) NewVariations.Binding(this); 
ThreadDictionaryPtr -> Insert(nextThread, (Entity *) NewThreadPtr); 
ThreadDictionaryPtr -> putObjectO; 

I 

void V_OBJECT;;copyChildren(V_OBJE<rr *child_list) 


if (!this) 

cerr « ’'<ERROR; can not copy children of a null V_OBJECT!>Nn"; 
return; 

) 


List *child_copyfrom = (List *) childJist->theChildPtr.Binding(child_list); 
List *child_copyto = (List *) theChildPtr.Binding(this); 

Listlterator ChildrenPtr(child_copyfrom); 

V_OBJECT ‘cnode; 

while(ChildrenPtr.moreData()) 

I 

cnode = (V_OBJECT *) (Entity •) ChildrenPtr(); 
child_copyto->Insert(cnode); 

I 

child_copyto->putObject(); 

return; 


283 




V_OBJECT *V_OBJECT;:check_for_child(char *child_node_name) 

{ 

V_0 iJECT *child = (V_OBJECT *)0; 
if (!this) 

{ 

cerr « “<ERROR; no children for a null V_OBJECT!>\n”; 
retum child: 

} 

List *child_check_list = (List *) theChildPtr.Binding(this); 

ListIteratorChildrenPtr(child_check_list); 

while(ChildrenPtr.moreData()) 

{ 

child = (V_OBJECT *) (Entity *) ChUdrenPtr(): 
if (strcmp(child->getNodeName0.child_node_name) == 0) 

{ 

return child: 


return (V_OBJECT *)0: 

1 


Boolean V_OBJECT:: Needs_UpdatingO 

{ 

return needsUpdating: 

} 

void V_OBJECT;;Update_Parent() 

i 

V_OBJECT *ParentPtr: 

ParentPtr = ihis->getParentO; 
for(::) 

if(ParentPtr !=NULL) 

{ 

ParentPtr->needsUpdating = TRUE: 
ParentPtr = ParentPtr->getParent(): 

1 

else 

{ 

break: 

1 

I 


void V_OBJECT::Reset_Update() 

{ 


284 




needsUpdating = FALSE; 

} 

Boolean V_OBJECT:;just_created() 

{ 

retuni created; 

} 

void V_OBJECT::set_created() 

{ 

created = TRUE; 

} 

void V_OBJECT::reset_created() 

{ 

created = FALSE; 

} 


// Member Function // 

void V_OBJECT:'.display VersionNumberO 

// Summary- 

// 

// This function displays the version number of an object. 


cout«theVersionNumber « 

}; 

int V_OBJECT;:getVersionNumber() 

( 

return theVersionNumber; 

) 

//End.- 


// Member Function // 

void V_OBJECT::dumpVObjSummary() 


285 







I 

cout« ctiine(&creationDate); 
cout« getCreatorO « “Sn”: 
if (woiker) 

cout« worker «‘^n”; 

} 

else 
cout« 

if (!lockTime==0) 
cout« ctiine(&lockTime); 
else 
cout« 

getDescriptionO; 

} 


//Member Function // 

time_t V_OBJECT::setCreationDate() 

{ 

tirnej mytloc=0; 

time_t theTime; 

return theTime = time(mytloc): 

I 


//Member Function // 

void V_OBJECT::setLock() 

{ 

lockTime = setCreationDateO: 

} 


//Member function// 

char *V_OBJECT;:getWorker() 

{ 

return worker, 

) 


//Member function// 


char *V_OBJECT:; getCreatorO 






retum creator. 


) 

//Member function// 

void V_OBJECT::setWorker() 

{ 

char *temp_worker = new char [strlen(userPtr>t-i]; 
strcpy(temp_worker,userPir); 
if (wortcer) 

{ 

delete worker, 

) 

// commented out on 21 may 92 MO’L 
// else 

worker = new char[strlen(temp_worker)+l]; 
strcpy( worker,temp_worker); 

} 


//Member Function // 

void V_OBJECT::resetVisitedFlag() 

( 

visited = FALSE; 

} 

void V_OBJECT::setVisitedFlag() 

{ 

visited = TRUE; 

} 

Boolean V_OBJECT:;getVisitedFlagO 

{ 

retum visited; 

1 


//Member Function // 

void V_OBJECT;;resetLastOpTrue() 

{ 

last_op_checkin = TRUE; 

1 

void V_OBJECT:;resetLastC)pFalse{) 


287 



{ 

lasl_op_checkin = FALSE; 

} 

//Member Function // 

Boolean V_OBJECT::get_last_operationO 

{ 

return last_op_checkin; 

} 

//Member Function // 

int V_OBJECT::releaseLockO 

( 

if (! worker) 

{ 

last_op_checkin = TRUE; 
lockTime = 0; 
return SUCCESS; 

} 


if (strcmp(userPtr,getWorker())==0) 

( 

last_op_checkin = TRUE; 
lockTime » 0; 
delete worker, 
worker = (char *)0; 
return SUCCESS; 

1 

else 

{ 

cerr« “<ERROR; Only “ « getWorkerO «*' May unlock this object!...Aborting>\n"; 
return FAE.£D; 

} 


//Member Function // 

time_t V_OBJECT::getCreationDate() 

I 

return creationDate; 

1 


288 





// Member Function // 


time_t V_OBJECT::getLockTime() 

1 

return lockTime; 

} 

// Member Function // 

void V_OBJECT:;getDescription() 

// Summary.. 

// 

// This function displays the description of an object 

// 

( 

if(!this) 

{ 

cout« “<ERROR; cannot get the description of a null V_OBJECT>\n"; 
return; 

} 

if (ItheDescriptionPtr) 

i 

cerr«‘■<ERROR: This v_object does not have a description>Nn"; 
return; 

} 

else 


TEXT_OBJECT *myTextObjectPtr = 

(TEXT_OB J ECT*) theDescriptionPtr, B inding(this); 
myTextObjectPtr ->text(cout); 


// Member Function // 

void V_OBJECT;;updateDescription(char ‘fileName. ifstream& input_file_stream) 

{ 

if(!this) 

{ 

cerr « “<ERROR; cannot update the description of a null V_OBJECT>\n”; 
return; 


289 





I 


else 

i 

if (strcmp(userPtr.getCreator())=0) 

{ 

if(!theDescriptionPir) 

{ 

TEXT_OBJECT *textObjectPtr = new TEXT.OBJECTO: 
textObjectPtr -> append(fileName, input_file_streain); 
textObjectPtr ->putObject(); 
theE>escripuonPtrJleset(textObjectPtr, this); 

} 

else 

{ 

TEXT_OBJECT *textObjectPu = 

(TEXT_OBJECT*) theDescriptionPtr.Binding(this); 
textObjectPtr -> resetTheTextO; 
textObjectPtr -> append(rileName. input_rile_stream): 


else 

cerr « “<ERROR: only ” « getCreatorQ « " may update description. Aborting...>\n": 

} 

putObjectO; 

) 

// Member Function // 

void V_OBJECT::addCOMPONENTNode(COMPONENT *myCOMPONENTPtr) 

{ 

if (!this) 

{ 

ceiT « “<ERROR: cannot set the COMPONENT node of a null V_OBJECT\n”; 
return; 

} 

li (ImyCOMPONENTPtr) 

i 

cerr « “<ERROR: cannot give to a V_OBJECT a null COMroNENT>Nn"; 
return; 

) 

theCOMPONENTPtr.Reset(myCOMPONENTPtr. this); 


290 




// Member Function // 


void V_OBJECT::deleteChildNode(V_OBJECT *myV_ObjPtr) 

{ 

List *child_nodes = (List *)theChildPtr.Binding(this); 

if (!this) 

{ 

cetr « “<ERROR: cannot delete the child node of a null V_OBJECrr«n”; 
return; 

1 

if (!child_nodes) 

{ 

cerr « “<ERROR; cannot remove a NULL child>\n”; 
return: 

} 

long location =0; 

if (child_nodes->isMember( m y V_ObjPtr)) 

{ 

location » child_nodes->Index(myV_ObjPtr). 
child_nodes->Remove(location); 

) 

} 


// Member Function // 

void V_OBJECT;:addChildNode(V_OBJECT *myV_ObjPlr) 

I 

List *child_nodes = (List •)theChiIdPtr.Binding(lhis); 

if (Ithis) 

{ 

cerr «‘‘<ERROR: cannot set the child node of a null V_OBJECTn"; 
return; 

} 

if (!child_nodes) 

cerr « “<ERROR: cannot give to a V_OBJECT a null child>'n"; 
return; 

} 

child_nodes->Insert(myV_ObjPtr): 

} 


//Member Function // 


J 


291 




V_OBJECT *V_OBJECT::getParent() 

{ 

return (V_OBJECT *)(Entity ♦) theParentPtr.Binding(this); 

} 

COMPONENT *V_OBJECT::getCOMPONENT0 

{ 

return (COMPONENT *) (Entity *) theCOMPONENTPtr.Bin<ling(this): 

} 

void V_OBJECT::listChildren() 

{ 


if (!this) 

( 

cerr « “<ERROR: can not dump children of a null V_OBJECT!>'n”; 
return: 

} 

if(!theChildPtr) 

{ 

cerr « “<ERROR: can not print children of a null childPtr!>Nn”; 
return; 

) 

else 

{ 


List *child_nodes = (List *) theChildPtr.Binding(this); 
Listiterator ChildrenPtr(child_nodes); 

V.OBJECT *cnode; 


while(ChildrenPtr.moreData()) 


cnode = (V_OBJECT *) (Entity *) ChildrenPtrO; 
cout« cnode->getNodeNameO: 




// following for loop provides spacing... 

jj ♦*♦*••*•*** 


inti=0; 


for (i=0;i<(PRINT_VERSION_LOCATION-strIen(cnode->getNodeNameO)):i++) 
cout« “ 

cout« cnode->getVariationNumber(); 
cout« “ 

cout« cnode->getVersionNumber(); 


292 






cout«‘^n”; 


} 

return; 

) 


void V_OBJECT::longIistOperatorNamesO 

{ 

TRACER(“V_OBJECT::longlistOperatorNames”): 
if (!this) 

{ 

cerr« “<ERROR: can not dump operators of a null V_OBJECT!>\n’' 
return; 

} 

if(!theChildPtr) 

{ 

cerr « “<ERROR; can not print list of a null childPir!>V'; 
return; 

} 

else 

{ 


List *child_nodes = (List *) theChildPtr.Binding(this); 
Listlterator ChiIdrenPtr(child_nodes); 

V.OBJECT *cnode; 
int line_feed = 0; 
whi!e{ChildrenPtr.moreData()) 
i 

TRACE(“ileration in while loop”); 

cnode = (V_OBJECT *) (Entity *) ChildrenPtr(); 

// if (cnode->getChildPtr()) 

// ( 

// cnode-> longlistOperatorNamesO; 

// } 

//1-23-92 cerr « “Operator: “; 

if (line_feed) cout«■^n” ; // removes blank line from output 
TRACE(cnode->getNodeName()); 
cout« cnode->getNodeNameO; 
line_feed++; 

^^***4t«**4i««* 

// following for loopprovides spacing... 
int i=0; 


293 







for (i=0;i<(PRINT_VERSION_LC)CATION-strlen(cnode->getNodeName()));i-H-) 
cout« “ 

cout« cnode->getVariationNumber(); 
cout« “ 

cout« cnode->getVersionNuinber(); 
cout« “ 

time_t locktime = cnode->getLockTimeO: 

} 

cout« 

} 

} 

void V_OBJECT::listOperatorNames() 

{ 

Boolean node_was_visited = FALSE; 
if (Ithis) 

( 

cerr «'‘<ERROR: can not dump children of a null V_OBJECT!>\n”: 
return; 

1 

if(!theChUdPtr) 

cerr« “<ERROR: can not print children of a nuU childPtr!>Vi’*; 
return; 

I 

else 

I 

List •child_nodes = (List *) theChitdPtr.Binding(this); 

Listiterator ChildrenPtr(child_nodes); 

V_OBJECT *cnode; 
int index = 1; 

while(ChildrenPtr.moreData()) 

{ 

cnode = (V_OBJECT *) (Entity *) ChildrenPtrO; 
node_was_visited = cnode->getVisitedFlag(); 
if (cnode->getChildPtr()) 

I 

cnode-> listOperatorNames(); 

} 

if (node_was_visited && index > 1) 

( 

cnode->resetVisitedFlag(); 

cnode->putObject(); 

break; 


294 






else 


( 

cnode->resetVisitedFlag(); 

cnode->putObject(); 

} 

if (index =1) 
cnode->setVisitedFlag(); 
index++; 
char *name; 

name = cnode->getName(); 
name[strlen(name)-2] = ‘M)'; 
cout« name; 

y^4i:4t**«4(***** 

// following for loop provides spacing... 

jj *^*m******* 

H int i=0: 

// for (i=0;i<(PRINT_VERSION_LOCATION-strlen(cnode->getName()));i++) 

// cout« “ 
cout«■■ 

cout« cnode->getVariationNumber(); 
cout« “ 

cout« cnode->getVersionNumber(); 
cout«‘^n”; 

time_t locktime = cnode->getLockTimeO: 
cout« ctime(&locktime); 

} 

resetVisitedFlagO: 

putObjectO; 

return; 

) 


void V_OBJECT;:releaseLockSubtree() 

{ 

List ♦child.nodes = (List *) theChildPtr.Binding(this); 
Listiteiator ChildrenPtr(child_nodes); 

V_OBJECT ‘cnode; 

while(ChildrenPtr.moreData()) 

{ 

cnode = (V_OBJECT *) (Entity •) ChildrenPtr(); 
if (cnode->releaseLock()) 
cnode->putObjectO; 


295 





else 


{ 

cerr« “<ERROR: while unlocking “ « cnode->getName()« “ Aborting...>\n"; 
break; // should try to unlock other siblings and their children. 

} 

if (cnode->getChildPtrO) 
cnode-> releaseLockSubtreeO; 


return; 

) 


void V_OBJECT:;dumpSubtree(char *file_write_option) 

( 

TRACER(“ V_OBJECT; :dumpS ubtree”); 

Boolean node_was_visited = FALSE; 

Boolean file_operation_successful = FALSE; 

Boolean write_operation = FALSE; 

if (strcnip(file_write_option,”w”)==0 II strcmp(ftle_wriie_option,"W")==0) 
write_operation = TRUE; 
if (.'this) 

{ 

cerr«‘'<ERROR: can not dump children of a null V_OBJECT!>'^‘‘; 
return; 

) 

if(!theChildP^) 

{ 

cerr « “<ERROR: can not print children of a null childPtr!>W; 
return; 

) 

else 

{ 

if (write_operation) 

DDBControlData VControlFile; 

DDBControlData *VControlFilePtr = &VControFile; 
char •Vnew_name = NULL; 
char *VV_name = getName(); 

VV_name [sirlen(W_naine) - 2] = ‘'O’; 

char *VDDBControlpath = new char [strlen(dirNamePtr) + strlen(VV_name) + 13]; 

strcpy(VDDBControlpath.dirNamePtr); 

strcat(VDDBControlpath. “D; 


296 





strcat(VDDBControlpath, “ddbCtrlData.”); 
strcat(VDDBControlpath, W_name); 
VControlFilePtr->variaiion = getVariationNumber(): 
VControlFilePtr->version = getVersionNumber(); 
putddbControlFile(VDDBControlpalh,VControlFilePtr); 

} 

List ‘child.nodes = (List *) theChildPtr.Binding(this); 
Listlterator ChildrenPtr(child_nodes); 

V.OBJECT *cnode; 
int index = 1; 

while (cnode = (V_OBJECT *) (Entity *)ChildrenPtr()) 

{ 

node_was_visited = cnode->getVisitedFlagO; 
if (cnode->getChildPtr()) 

{ 

cnode-> dumpSubtree(file_WTite_option); 

} 

if (node_was_visited && index > 1) 

{ 

cnode->resetVisitedFlag(); 

cnode->putObject(); 

break; 

I 

else 

{ 

cnode->resetVisitedFlag(); 

cnode->putObject(): 

} 

if (index =1) 
cnode->setVisitedFlag(); 
else 
{ 

cnode->resetVisitedFlag(); 

cnode->putObject(); 

I 

index-H-; 

long cobjectjocktime = 0; 
cobjectjocktime = cnode->getLockTiineO; 
if (cobjectjocktinie>0) // prevent checkout 

{ 

if (strcmp(rde_write_option.”w")=0) 

{ 

cerr « “<ERROR: Module “ « cnode->getNodeNameO 
« “ lockedby “ « cnode->getWorker() 


297 





« “ Reset write option to display>\n’'; 
strcpy(file_write_option,”r”); 

} 

cerr « “<Caution: “ « cnode->getNodeName() 

« “ locked on: “ 

«ctime(&cobject_locktiine) . 

« “Node checked out for display onlyNn”; 

I 

file_(:^ration_successful = cnode->checkout(X>MPONENTNode(file_write_option); 

if ((file_operation_successful) && * 

((strcmp{file_write_option,'’W’')==0) II 
(strcmp(file_write_option,”w”)=0))) 

{ 

cnode->setLock(); 

cnode->setWorker(); 

cnode->resetLastC)pFalse(); 

cnode->putObject(); 

DDBControlData ControlFile; 

DDBControlData *ControlFilePtr = &ControlFile; 

char *new_name = NULL; 

char ‘V.name = cnode*>getNameO; 

V_naine [sirlen(V_name) - 2] = 

char *DDBControlpath = new char [strlen(dirNamePtr) + strlen(V_name) + 13]; 

sticpy(DDBControlpath.dirNaniePtr); 

strcat(DDBControlpath, “D; 

strcat(DDBControlpath. “ddbCtrlData.''); 

strcat(DDBControlpath, V_name); 

ControlFilePtr->variation = cnode-> getVariationNumberO; 

ControlFilePtr->version = cnode-> getVersionNumberO; 
putddbControlFile(DDBControlpath.ControlFilePti>; 


I 

if (write_operation) 
strcpy(file_write_option,”w"); 

1 

resetVisitedFlagO; 

putObjectO: 

return; 


I 

List * V_OBJECT;;getChildren() 

{ 


298 





List *tempjist = (List *)theChildPtr.Binding(this); 
if (temp_list->Car(iinalityO > 0) 
return tenip_list; 
else 

return NULL; 

} 

Boolean V_OBJECT::getChU(IPtrO 

{ 

List *temp_list = (List •)theChildPtr.Binding(this): 
if (temp_list->CardinalityO > 0) 
return TRUE; 
else 

return FALSE; 


// Member Function // 

Boolean V_OBJECT;:checkoutCOMPONENTNode(char *file_wTite_option) 

{ 

TRACER(‘'V_OBJECT;;checkoutCOMPONENTNode”); 
if (!this) 

{ 

cerr « “<ERROR: cannot checkout COMPONENT nodes of a null V_OBJEC'rn": 
return FAILED; 

} 

if (ItheCOMPONENTPtr) 

I 

cerr« “<ERROR: cannot get the source code from a null COMPONENT>'n"; 
return FAILED; 

} 

else 

i 

COMPONENT *myCOMPONENTPtr = (COMPONENT*) theCOMPONENTPtr.Binding(this); 
return (myCOMPONENTPtr -> getComponentSource(file_write_option)); 

} 


299 






// File Header--- 

// . : 

//filename.; vobjectfunc.h 

//Date : 9/16/91 

// Author : Garry Lewis 

// : Drew Dwyer 

// Modified by : Michael D. O’Loughlin 

//Date : 6/18/92 

// Modifications; Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required I discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

V 

// Compiler : Glockenspiel C++ 2.1 

// 

// End header comments- 


#ifndef _VOBJECTFUNC_H 
#define_VOBJECTFUNC_H 

#ifndef _DDBDEFINES_H 
tinclude “ddbdefines.h” 

#endif 

#ifndef_THREAD_H 
#include “thread.h” 

#endif 

// sees ID follows; will compile to place dateAime stamp in object file 

static char vobjectfunc_h_SccsIdQ = “@(#)vobjectfunc.h 1.3Nt9/16/9r’; 

// Contents- 

// 

// VOBJECTFUNC 

// 

// Description 


300 












// 

// Defines functions manipulating Versioned Objects 
// (Operators) as called by mainO 
// 

/(End- 

// Interface Dependencies- 

// 

//NONE 

// 

// End Interface Dependencies- 

void list_operators_func(int, char *, char ♦, char *, char •); 

void update_vobject_desc_func(int, char *,char *,char *.char ♦.char *); 

void get_vobject_desc_(unc(int .char *. char *.char *.char *); 

void get_vobject_date_func(int. char ‘.char *.char *.char *): 

void get_vobject_versions_func(int. char *.char ♦); 

void get_vobject_lock_func(int. char *. char ♦. char *.char *); 

void get_vobject_version_func(); 

void dump_vobject_summary_func(int. char *.char ♦.char ♦.char ♦); 
void get_vobject_psfde_func(int. char ♦, char ♦.char ♦. char ♦); 
void get_vobject_graphfile_func(int. char ♦.char ♦.char ♦. char ♦); 
void get_vobject_impfile_func(int. char ♦. char ♦.char ♦. char ♦); 
void get_vobject_specfUe_func(int. char ♦.char ♦.char ♦. char ♦); 
void get_vobject_sourcerile_func(int. char ♦.char ♦.char ♦. char ♦); 
void dump_vobject_files_func(int. char ♦. char ♦.char ♦. char ♦.char ♦); 
void dump_vobJect_tree_func(int. char ♦. char ♦.char ♦. char ♦. char ♦); 
void long_list_childiBn_func(int.char ♦, char ♦. char ♦); 
void long_list_parents_func(int.char ♦. char ♦. char ♦. char ♦); 
void long_list_operators_func(int, char ♦. char ♦. char ♦. char ♦); 
void release_operatorJock_func(int, char ♦. char ♦. char ♦. char ♦); 
void release_subtreeJock_func(int, char ♦. char ♦. char ♦. char ♦); 
//void add_vobject_and_subtree_func(int, char ♦. char ♦); 
void add_new_variation_func(int, char ♦. char ♦. char ♦. char ♦); 
void historical_trail(int, char *, char ♦. char ♦. char •); 
void putddbControlFile(chai*. struct DDBControlData^); 
DDBControlData^ getddbControlFile(char ♦); 

THREAD^ firstThread(THREAD^. int); 

V_OBJECT^ getDefauItVObject(THREAD^); 

THREAD^ findThieadfchar*. char^); 

// Description- 

II 

H list_operators_func 


301 








// 

// Provides a list of operators associated with a 
// subtree of a designated versioned_object. 

// 

// updaie_vobject_desc_func 

// 

// Updates the description text of a designated vosioned 
// object. 

II 

// get_vobject_desc_func 

II 

// Provides a description of the designated versioned object. 

II 

H get_vobject_date_func 
II 

H Displays the date that the versioned object was created. 

// 

// get_vobject_versions_func 

// 

// Checks the thread and displays the different versions. 

// 

// get_vobject_lock_func 

// 

// Displays a 26 character text entry reflecting the time 
H and date that the versioned object was locked. 

II 

H get_vobject_version_func 
// 

// returns the version of the versioned object instance. 

// 

// dump_vobject_sumniary_func 

II 

// displays predetermined attribute fields to stdout/stderr. 

II 

H get_vobject_psfile_func 
// 

// rebuilds the CAPS postscript file to the PROTOTYPE 
// directory. 

// 

// get_vobject.graphfUe.func 

// 

// rebuilds the CAPS graph file to the PROTOTYPE directory. 

H 

H get_vobject_impfile_func 


302 



H 

H rebuilds the CAPS implementation file to the PROTOTYPE directory. 
// 

// get_vobject_specfile_func 

// 

// rebuilds the CAPS specification file to the PROTOTYPE directory. 

// 

// get_vobject_sourcefile_func 

// 

// rebuilds the CAPS source file to the PROTOTYPE directory. 

// 

// dump_vobject_fiJes_func 

// 

// rebuilds all of the above files (of one operator) to the 
// PROTOTYPE directory. 

// 

// dump_vobject_tree_func 

// 

// rebuilds all existing TEXT_OBJECT attributes to the PROTOTYPE 
// directory for the entire decomposition of the root operator 
// down to the component operators. May be dumped in “read only” 

// or “read/write". When dumped, all versioned objects are 
// locked for modification by other users. 

// 

H long_list_children_func 
// 

// lists the node name and version number of children. 

// 

// long_list_parents_func 

// 

// bsts the most current parent (and that parents siblings). 

II 

H long_list_operators_func 
// 

// lists the node name and version number of a node's children. 

// 

// release_operator_lock_func 

// 

// reset the locktime of a versioned operator. 

II 

// release_subtree_lock_(unc 

II 

H reset the locktime of a versioned operator and all children 
// of that versioned operator. 


303 



II 

H add_vobject_and_subtree_func 

II 

H the reverse of a dumping vobjects. this checks versioned 
// objects back into the database, versioning them if necessary. 
// 

// End Description- 

#endif // end vobjectfiinc header function 


304 






// File Header- 

// . : 

//filename.; vobjectfunc.cxx 

//Date : 9/16/91 

// Author : Garry Lewis 

// ; Drew Dwyer 

// Modified by : Michael D. O'Loughlin 

//Date : 6/18/92 

// Modifications: Extensive modifications have been conducted on almost all of the 
/* original code written by Dwyer and Lewis. Every function that 

accesses an attribute of an object or the entire object has had 
to be modified. The original code is not even recognizable in 
some functions. 

Because the functionality of the design database system changed 
completely from what Dwyer and Lewis developed each individual 
modification has not been documented. Because of the massive 
changes required 1 discarded a lot of obsolete code and build a 
new system on the base Dwyer and Lewis had established. 

*/ 

I I Compiler : Glockenspiel C-h- 2.1 

// 

// End header comments- 

// sees ID (allows: will compile to place date/time stamp in object file 

static char vobjectfunc_cxx_SccsId[] = *’@(#)vobjectfunc.cxx 1.3X19/16/91”; 

// Contents. 

// 

// list_operators_func 
// update_vobject_desc_func 
// get_vobject_desc_func 
// get_vobject_date_func 
// get_vobject_versions_func 
// get_vobjectJock_func 
// get_vobject_version_func 
// dump_vobject_summary_func 
// get_vobject_psfile_func 
// get_vobject_graphfile_func 
// get_vobject_impfile_func 
// get_vobject_specfile_func 
// get_vobject_sourcefde_func 
// dump_vobject_files_func 
// dump_vobject_tree_func 


305 









// long_list_chiIdren_func 
// long_list_parents_fiinc 
// long_list_operators_func 
// release_operator_lock_func 
// release_subtree_lock_func 
// add_vobject_and_subtree_func 
// 

// Description 

// 

// this contains the functions for manipulating versioned objects 

// 

//End... 

// Interface Dependencies. 

// 

// TURN ON TRACE-DEBUG 
#derine DEBUG 
#include “debug.h” 

#include “My_String.h’' 

#include <stream.hxx> 

#include <List.h> 

#include <Directory.h> 


extern “C-" 


#include <stdlib.h> 

1 


#ifndef _DIRECTORY_H 
#include “directory .h” 
#endif 

#ifndef __TREE_H 
#include “tree.h” 

#endif 

#ifndef _TREENODE_H 
#include “treenode.h” 
#endif 

#ifndef _PROTOTYPE_H 


306 




#include “prototype.h" 

#en(iif 

#ifndef _COMPONENT_H 
#include “component.h” 

#endif 

#ifndef _VOBJECT_H 
finclude ‘'versioned_object.h” 

#endif 

#ifndef_THREAD_H 
#include “thread.h" 

#endif 

#ifndef _VOBJECmJNC_H 
#include “vobjectfunc.h” 

#endif 

#ifndef _DDBDEFINES_H 
#include “ddbdefines.h" 

#endif 

// 

// End Interface Dependencies-- 

extern Type *THREAD_OType; 
extern Directory *prototype_dir; 
extern char *dirNamePtr; 

PROTOTYPE *prototypeptr; 

THREAD *threadPtr; 

COMPONENT *COMPONENTPtr; 
long vobjectjocktime =0; 

void list_operators_func(int number_arguments, char *proto_name, 

char ♦operator_name, char • variationstr, char *versionstr) 

I 

TRACER(“bst_operators_func”); 

V_OBJECT •vobjectPtr; 

threadPtr = fuidThread(proto_naine, operator_name); 
if (IthreadPtr) 

307 






{ 

return; 

} 


switch (number_arguments) 

{ 

case 2: 

{ 

vobjectPtr = getDefaultVObject(threadPtr); 
vobjectPtr ->listC)peratorNames(); 
break; 

} 

case 4: 

{ 

int varNum = atoi(variationstr); 
threadPtr = firstThread (threadPtr, varNum); 

V_OBJECT ‘vobjectPtr; 

vobjectPtr = threadPtr->version(atoi(versionstr)); 

vobjectPtr ->listOperatorNames(); 

break; 

} 

default: 

cerr« “<ERROR: invalid number args for get vobject description>''n’‘: 

I 


void update_vobject_desc_func(int number_arguments.char *proto_name. 
char *operator_name, char ‘filename, 
char ‘variationstr, char ‘versionstr) 

{ 

TRACER(’'update_vobject_desc_func”); 

V_OBJECT ‘vobjectPtr, 

threadPtr = findThread(proto_name, operator_name); 
if (IthreadPtr) 

{ 

return; 

} 

« 

ifstream description_file; 
description_file.open(niename, ios:: in); 

if (!description_file) • 

I 

cout« “<Description File does not exist! >\n”; 


308 





} 

else 

{ 

switch (nun\ber_arguments) 

{ 

case S: 

int varNum = atoi(variationstr); 
ihreadPtr = firstThread (threadPtr.varNum); 
vobjectPtr = threadPtr->version(atoi(versionstr)); 
vobjectPtr ->updaieDescription(filenaine,description_file); 
break; 
default: 

cerr « “<ERROR: invalid number args for update vobject description>Nn”; 

} 

} 

) 


void get_vobject_desc_func(int number_arguments.char *proto_name. 
char *operator_name, char *variationstr, 
char *versionstr) 

I 

TRACER(“get_vobject_desc_func‘’): 

V_OBJECT * vobjectPtr; 

threadPtr = findThreadfproto.name, operator_name); 
if (IthreadPtr) 

I 

return; 

» 

switch (number_arguments) 

{ 

case 2: 

{ 

V_OBJECT "'vobjectPtr, 
vobjectPtr = threadPtr->current(); 
vobjectPtr ->getDescriptionO: 
break; 

} 

case 4: 

{ 

int varNum = atoifvahationstr); 

threadPtr = SrstThread (threadPtr, varNum); 

vobjectPtr = threadPtr->ver5ion(atoi(versionstr)); 

vobjectPtr ->getDescription(); 

break; 


309 







default: 

ceiT « “<ERROR: invalid number args for get vobject description>\n" 

} 


1 

void release_subtree_lock_func(int number_arguments, char *proto_name. 
char *operator_name, char *variationstr, 
char *versionstr) 

{ 

TRACER(“release_subtreeJock_func”); 

V_OBJECT *vobjectPtr: 

threadPtr = findThread(proto_name, operator_name): 
if (IthreadPtr) 

{ 

return; 

) 

switch (number_arguments) 

{ 

case 2: 

cerr « “VRS operation no longer valid with default version number.” 
« “ Variation & version number required.”; 

break; 
case 4; 

int varNum = atoi(variationstr); 
threadPtr = firstThread (threadPtr, varNum); 
vobjectPtr = threadPtr->version(atoi(versionstr)); 
if (vobjectPtr ->releaseLock()) 

{ 

vobjectPtr->putObject(); 
vobjectPtr ->releaseLockSubtree(); 
cerr « “Subtree locks released.'^"; 

1 

else 

I 

cerr « “<ERROR; Can’t unlock “«vobjectPtr->getNameO 
« “ Abort releaseLock rest subtree>'n”; 

) 

break; 

) 

default: 

cerr « “<ERROR: invalid number args for subtree release locloVi"; 



} 

} 

void release_operator_lock_func(int number_arguments. char *prolo_name. 
char *opera«Dr_name, char *variationstr, 
char *versionstr) 

{ 

TRACER(“release_operator_lock_func”): 

V_OBJECT •vobjectPtr, 

threadPtr = findThread(proto_nanie, operator_name); 
if (ithreadihr) 

{ 

return; 

} 


switch (number_arguments) 

{ 

case 2: 

cerr« “VRO operation no longer valid with default version number.” 
« “ Variation & version number required.”; 

break; 
case 4; 

int varNum = atoi(variationstr); 
threadPtr * firsiThread (threadPtr. varNum); 
vobjectPtr = threadPtr->version(atoi(versionstr)); 
if (vobjectPtr->releaseLock()) 

{ 

vobjectPtr->putObjectO; 

) 

else 

{ 

cerr « “<ERROR; Can’t unlock “«vobjectPtr->getName() 

« ” Aborting release lock>\n”; 


break; 

} 

1 default: 

cerr« “<ERROR: invalid number args for release lock>\n”; 

) 


void get_vobject_date_func(int number_arguments. char *proto_name, 
char *operator_name, char *variaiionsir. 


311 





char *versionstr) 


{ 

TRACER(“GET_vobject_daie_func”); 
time_t creation.date; 

V_OBJECT*vobjectPtr, 

threadPtr = findThread(proto_name. operator_name); 
if (IlhreadPtr) 

{ 

return; 

} 

switch (number_arguments) 

{ 

case 2: 

vobjectP^ = getDefaultVObject(threadPtr); 
creation_date = vobjectPtr ->getCreationDaie(); 
cout« ctime(&creation_daie); 
break; 
case 4; 

int varNum = atoi(variationstr); 
threadPtr = firstThread (threadPtr. varNum); 
vobjectPtr = threadPtr->version(aloi(versionstr)); 
creation_date = vobjectPtr ->getCreationDate(); 
cout« ctime(&creation_date); 
break; 
default; 

cerr« “<ERROR: invalid number args for get vobject date>Nn”; 

} 


void get_vobject_versions_func(int number_arguments, char •proto_name. 
char *operator_name) 


{ 

TRACER(“GET_vobject_versions_func”); 
threadPtr = findThread(proto_name, operator_name); 
if (IthreadPtr) 

{ 

return; 

1 

switch (number_arguments) 

( 

case 2: 


312 





V_OBJECT *initial Version = threadPtr-> version(l); 
int count = initialVersion->getNumberOfVariations(); 
for (int i=l; i <= count; i++) 

{ 

THREAD *TthreadPtr = firstThread (threadPtr. i); 
TthreadPtr-xlisplayThreadVersionsO; 

} 

break; 

default 

cerr « “<ERROR: invalid number args for get vobject VERSIONS>Nn’‘ 

) 


void historical_trail(int number_arguments, char •proto_name. 

char *operator_name. char •variationstr, 
char *versionstr) 

V_OBJECT *has_parenu 
THREAD *previousThreadPtr = (THREAD *)0; 
threadPtr = findThread(proto_name, operator_name); 
if (IthreadPtr) 

{ 

return; 

I 


previousThreadPtr = firstThread (threadPtr, atoi(variationstr)); 
has_parent = previousThreadPtr->version(atoi{versionsu’)); 

char *name; 

name = has_parent->>'etName(); 
namprstrlen(name)-2] = ‘NO’; 

cout« name « “ “ « has_parent->getVariationNumber()« “ “ 

« has_parent->getVersionNumber()« 

while (!(previousThreadPtr->previousVariationO = 0 )) 

{ 

cout« name « “ “ « previousThreadPtr->previousVariation()« 
« previousThreadPtr->previousVersion()«‘Ni”; 
previousThreadPtr = 

firstThread (threadPtr, previousThreadPtr->previousVariationO); 

I 

} 


313 






void get_vobject_lock_func(int number_arguments, char *proto_name, 
char *operator_name, char *variationstr, 
char •versionstr) 

{ 

TRACER(“GET_vobject_lock_func”); 
tiine_t lock_tiine; 

V_OBJECT *vobjectPtr. 

threadPtr = findThread(proto_naine, operator_name): 
if (IthreadPtr) 

I 

return; 

) 

switch (nuinber_arguments) 

{ 

case 2: 

vobjectPtr = getDefaultVObject( threadPtr); 
vobjectPtr = threadPtr->curTent(); 
lock_time = vobjectPtr ->getLockTime(); 
com « ctime(&lock_time); 
break; 
case 4; 

threadPtr = firstThread (threadPtr. atoi(variationstr)); 
vobjectPtr = threadPtr->version(atoi( versionstr)); 
lock_time = vobjectP*tr ->getLockTime(); 
cout« ctinie(&lock_time); 
break; 
default: 

cerr« “<ERROR: invalid number args for get vobject lock>'vi”; 


void get_vobject_version_func() 

{ 

cerr « “Not implemented. Unclear specs for get version of vobjectNn”; 

) 


void dump_vobject_summary_func(int number.arguments, char *proto_name, 
char *operator_name. char *variationstr, 
char ^versionstr) 

{ 

TRACER(“dump_vobject_summary_func”); 

V_OBJECT *vobjectPtr, 

threadPtr = findThread(proto_name, operator_name); 


314 



if (ithreadPtr) 

{ 

return; 

} 

switch (number.arguments) 

I 

case 2: 

vobjectPtr = getDefaultVObject(threadPtr); 
vobjectPtr-xJumpVObjSummaryO: 
break; 
case 4: 

threadPtr = firstThiead (threadPtr, atoi(variationstr)); 
vobjectPtr = thieadPtr->version(atoi(versionstr)); 
vobjectPtr-xlumpVObjSummaryO; 
break; 
default: 

cerr« “<ERROR: invalid number args for get vobject summary>Nn" 

} 


void get_vobject_psfile_func(int number.arguments, char *proto_name. 
char •operator_name, 
char ♦variationstr, char *versionstr) 

{ 

TRACER(''GET_vobject_psfile_func”); 

V_OBJECT *vobjectPtr; 

threadPtr = findThread(proto_name. operator_name); 
if (IthreadPtr) 

i 

return; 

} 


switch (number.arguments) 

{ 

case 2; 

I 

vobjectPtr = getDefauItVObject( threadPtr); 
vobjectjocktime = vobjectPtr->getLockTimeO; 
COMPONENTPtr =vobjectPtr->getCOMPONENT0; 
COMPONENTPtr->getPSfUe(“Rl; 
break; 

I 

case 4: 


315 




{ 

threadPlr = QistThread (threadPtr, atoi(variationstr)): 
vobjectPtr = threadPtr->vetsion(atoi(versionstr)): 
char *fUe_write_optioii = “R”; 

COMPONENTPtr = vobjectPtr->getCOMPONENT0: 
(TOMPONENTPtr ->getPSfile(file_write_option); 
break; 

) 

default 

ceiT « “<ERROR: invalid number args for get vobject PS>\n”; 


} 


void get_vobject _graphfile_func(int number_arguments, char *proto_name, 
char *operator_name, 
char ’*variationstr, char •versionstr) 

{ 

TRACER{“GET_vobject_graphfile_func*'); 

V_OBJECT ‘vobjeclPtr; 

threadPtr = fmdThread(proto_name. operator_name); 
if ('.threadPtr) 

{ 

return; 

} 


switch (number.arguments) 

I 

case 2: 

{ 

vobjectPtr = getDefaultVObject( threadPtr); 
COMPONENTPtr =vobjectPtr->getCOMPONENT(); 
COMPONENTPtr->getGRAPHfileC‘R”); 
break; 

1 

case 4: 

{ 

threadPtr = firstThread (threadPtr, atoi(vanationstr)); 
V_OBJECT *vobjectPtT; 
vobjectPtr = threadPtr->version(atoi( versionstr)); 
COMPONENTPtr = vobjectPtr->getCOMPONENTO; 
COMPONENTPtr ->getGRAPHfile(“R”); 
break; 

1 


316 





default 

cerr « “<ERROR; invalid number args for get vobject GRAPH>'n”; 

I 


void get_vobject_impfile_func(int number.arguments, char *pit)to_name. 
char *operator_name.char •variationstr. 
char •versionstr) 


TRACER(“GET_vobject_impfile_func’’); 
V_OBJECT *vobjectPtn 

threadPtr = findThread(proto_name, operaior_name); 
if (IthreadPtr) 

{ 

return; 

} 


switch (number_arguments) 

{ 

case 2: 

vobjectPtr = getDefaultVObject(threadPtr); 

COMPONENTPtr ssvobjectPtr->gelCOMPONENT(); 
COMPONENTPtr->getIMPme(‘*R”): 
break; 
case 4; 

threadPtr = firstThread (threadPtr, atoi( variationstr)); 
vobjectPtr = threadPtr->version(atoi( versionstr)); 
COMPONENTPtr s vobjectPtr->getCOMPONENT0; 
COMPONENTPtr ->geaMPfile<“R”); 
break; 
default 

ceiT « “<ERROR: invalid number args for get vobject IMP>'n”; 


} 

void get_vobject_specfile_func(int number_arguments, char *proto_name. 
char *operator_name. 
char *variationstr, char “versionstr) 

( 

TRACER(“GET_vobject_specfile_func”); 

V_OBJECT “vobjectPtr, 

threadPtr = findThread(proto_name. operator_name); 
if (IthreadPtr) 

{ 


317 





return; 


} 

switch (number.arguments) 

I 

case 2: 

vobjectPtr = getDefaultVObject(threadPtr); 

COMPONENTPtr =vobjectPtr->geiCOMPONENT0; 

(X>MPONENTPtr->getSPECfile(‘‘R"); 

break; i 

case 4: 

{ 

threadPtr = firstThread (threadPtr, atoi(variationstr)); 
vobjectPtr = threadPtr->version(atoi(versionstr)); 

COMPONENTPtr = vobjectPtr->getCOMPONENT(); 

COMPONENTPtr ->getSPECfile(“R”); 
break; 

) 

default 

cerr « “<ERROR: invalid number args for get vobject SPEC>\n”; 

} 

I 

void get_vobJect_sourcefile_func(int number_arguments, char *proto_name, 
char *operator_name, 

char *variationstr. char *versionstr) 

1 

TRACER(**GET_vobject_sourcefUe_func’’); 

V_OBJECT *vobjectPtr; 

threadPtr = findThread(proto_name, operator_name); 
if (IthreadPtr) 

{ 

return; 

} 

switch (number_arguments) 

{ 

case 2: ( 

vobjectPtr = getDefaultVObjectf threadPtr); 

COMPONENTPtr =vobjectPtr->getCOMPONENT0; 

COMPONENTPtr->getSOURCEme(“R”); 
break; 
case 4: 


318 






threadPtr = firstThread (threadPtr, atoi(variationstr)); 

V.OBJECT *vobjectPtr, 

vobjectPtr = threadPcr->version(atoi(versionstr)); 

COMPONENTPtr = vobjectPtr->getCOMPONENT0; 

(X)MPONENTPtr->getSOURCEfileC‘R”); 

break; 

) 

default' 

cerr « “<ERROR: invalid number args for get vobject SOURCE>\n” 

} 


void dump_vobject_files_func(int number_arguments. char *proto_name, 
char •operator_name,char •file_write_option. 
char *variationstr, char *versionstr) 

{ 

TRACER(“dump_vobject_files_func”); 

Boolean file_operation_successfiil = FALSE; 

V_OBJECT *vobjectPtr; 

threadPtr = findThread(proto_name, operator_name); 
if (IthreadPtr) 

return; 

1 


switch (number_arguments) 

{ 

case 3; 

vobjectPtr = getDefaultVObject( threadPtr); 
vobjectjocktime = vobjectPtr->getLockTime(); 
if (vobject_locktime>0) 

// lock was set..prevent “w” checkout 

{ 

if (strcmp(file_write_option ”w”)=0) 

// if attempting “W” - change to “r” 

{ 

cerr « “<ERROR Module “ 

« vobjectPtr->getNodeName()« “ locked by ; “ 
« vobjectPtr->getWorkerO 

« “ Resetting w option to ro>\n”; 
strcpy(file_write_option,”r”); 

} 

else 

I 


319 



cerr «*‘<Caution; “ « vobjectPtr->getNodeName() 

« “ is locked> \n” « “Date Locked: “ 

« ctime(&vobject_locktime) 

<<• “operator files checked out in romodeNn”; 

} 

) 

else 

cout« vobjectPtr->geiNodeName() «‘*vn”; 
fUe_operation_successful = 

vobjectPtr -> checkoutCOMPONENTNode(fde_write_option): 
if ((ftle_c^ration_successful) && 

((strcmp(file_write_option,”W”)=0) II (strcmp(file_write_option,”w'’)=0))) 

{ 

vobjectPtr -> setLockQ: // set root lock 

vobjectP^ -> setWorker(): 
vobjectPtr -> resetLastOpFalseO: 
vobjectPtr->putObject(); 

) 

if (!file_operation_successful) 

cerr « “<ERROR: checking out “ « vobjectPtr ->geuName(); 
break; 
case 5; 

threadPir = firstThread (threadPtr, atoi(variationstr)); 
vobjectPtr = threadPtr->version(atoi(versionstr)); 
vobject Jocktime = vobjectPtr->getLockTime(); 
if (vobject Jocktime>0) // prevent checkout 

( 

if (strcmp(file_write_option,’'w")=0) // change “w“ to “r" 

{ 

cerr« “<ERROR; Module “ « vobjectPtr->getNodeName() 

« “ locked by ; “ « vobjectPtr->getWorker() 

« “ Resening w option to ro>\n”; 
strcpy(file_write_option,''r”): 

) 

else 

cerr« “<Caution: “ « vobjectPtr->getNodeName() 

« “ is locked,> 'll" « “Date Locked: “ 

« ctime(&vobjectJocktime) 

« “operator files checked out in ro modeNn”; 


else 

cout« vobjectPtr->getNodeNameO 
COMPONENTPtr = vobjectPtr->getCOMPONENT(); 
file_operation_successful = 


320 




vobjectPtr -> checkoutCOMPONENTNode(file_write_option); 
if ((file_operation_successful) && 
((strcmp(file_write_option,”W”)==0) II 
(strcmp(file_write_option ”w”)==0))) 

{ 

cerr « “Set lock, set worker, reset last op.'fl”; 
vobjectPtr -> setLockQ; // set root lock 

vobjectPtr -> setWorkerQ; 
vobjectPtr -> resetLastOpFalseO: 
vobjectPtr->putObject(); 

DDBControlData VCotttrolFile; 

DDBControlData '"VControlFilePtr = &VControlFile; 
char *Vnew_name = NULL; 
char *VV_r>aine = vobjectPtr-> getName{); 
VV_naine[strlen(VV_name)-2] = ‘'O’; 
char *VDDBControlpath = 

new char[strlen(dirNamePtr) + strlen(VV_nanie) + 13]; 
strcpy(VDDBControlpath, dirNamePtr); 
strcat(VDDBControlpath, "D: 
strcat(VDDBControlpath, “ddbCtrlData.”); 
strcat(VDDBControlpath, VV_naine); 

VControlFilePtr->variation = vobjectPtr->getVariationNumber(); 
VControlFilePtr->version = vobjectP*tr->getVersionNumberO; 
putddbControlFile(VDDBControlpath, VControlFilePtr); 

} 

if (!file_operation_successful) 

cerr « “<ERROR: checking out ' « vobjectP^tr ->getName(); 
break; 
default: 

cerr« “<ERROR: invalid number args for get vobject FILES>Nn”; 

} 

} 


void dump_vobject_tree_func(int number_arguments, char *proto_name, 
char *operator_name,char *file_write_option, 
char *variationstr, char *versionstr) 

{ 

TRACER(“dump_vobject_tree_func’’); 

Boolean file_operation_successful = FALSE; 

V_OBJECT *vobjectPtr, 

threadPtr = findThread(proto_name, operator_name); 
if (IthreadPtr) 

i 

return; 


321 






} 

switch (number_arguments) 

{ 

case 3: , 

vobjectPtr = gelDefaultVObject(threadPtr); 
vobjectjocktiine = vobjectPtr->getLockTimeO; 
if (vobjectjocktime>0) // prevent checkout 

{ 

if (strcmp(file_write_option,"w”)=0) H change “w" to “r”) 

{ 

cerr « “<ERROR: Module “ « vobjectPtr->getNodeNameO 
« “ locked by ; “ « vobjectPtr->getWoiker() 

« “ Resetting write option to display>\n”; 
strcpy(file_write_option.”r”); 

) 

cerr « “<Caution: “ « vobjectPtr->getNodeName() 

« “ is locked> \n” « “Date Locked; “ 

« ctime{&vobject_locktime) 

« “Subtree checked out to display mode.Nn”; 


else 

cout« vobjectPtr->getNodeNanie()« “ “ 

« vobjectPtr-> getVariationNumber() 

« “ “ « vobjectPtr->getVersionNumber() «‘Ni\n"; 
file_operation_successful = 

vobjectPtr -> checkoutCOMPONENTNode(file_write_option); 
if ((file_operalion_successfuI) && 

((strcnip(rile_write_option,’’w'’)=0) II 
(strcmp(file_write_option,”W”)=0))) 

I 

vobjectPtr -> setLockQ; // set root lock 

vobjectPtr -> setWorkeif); 
vobjectPtr -> resetLastOpFalseO; 
vobjectPtr->putObjectO: 

} 

if (file_c^ration_successful) 

I f 

vobjectPtr -> dumpSubtree(file_write_option); 
int vnum = vobjectPtr -> getVersionNumber(); 
threadl*tr -> putObjectQ; 

} ’ 

// dump rest of tree 
else 
I 


322 









cerr « “<ERROR: checking out “ « vobjectPtr ->getName() 
« “ Aborting dump_vobject_tree_func>'fl”; 

TRACE(“file_operation not successful”); 

} 

break; 

caseS: 

TRACE(“case5”); 

threadPtr = firstThread (threadPtr, atoi(variationstr)); 
vobjectPtr = threadPtr->version(atoi(versionstr)); 
vobject_locktime = vobjectPtr->getLockTime(); 
if (vobject_locktime>0) // prevent checkout 

if (strcmp(file_write_option,”w”)=0) // change “w” to ”r”) 

{ 

cerr « “<ERROR: Module “ « vobjectPtr->getNodeNanie() 
« “ locked by : “ « vobjectPtr->getWorker() 

« “ Resetting write option to display>\n”; 
strcpy(file_write_option,”r"); 

1 

cerr« “<Caution; “ « vobjectPtr->getNodeName() 

« “ is locked.> Nn” « “Date Locked: “ 

« ctime(&vobject_locktime) 

« “Subtree checked out to display mode.Vj”; 


else 

cout« vobjectPtr->getNodeName()« “ “ 

« vobjectPtr-> getVariationNuniber() 

« “ ” « vobjectPtr->getVersionNumoer() 
file_operation_successful = 

vobjectPtr -> checkoutCOMPONENTNode(tile_write_option); 
if {(file_operation_successful) && 
((strcmp(file_write_option,”w”)=0) 11 
(strcnip(file_write_option,"W”)=0))) 

{ 

vobjectPtr -> setLockQ; // set root lock 

vobjectPtr -> setWorkerf); 

; vobjectPtr -> resetLastOpFalseQ; 

vobjectPtr->putObject(); 

) 

if (file_operation_successful) 

V { 

vobjectPtr -> dunipSubtree(fde_write_option); 
int vnum = vobjectPtr -> getVersionNumber(); 
threadPtr -> putObjectf); 


323 






} 

// dump rest of tree 
else 
{ 

cerr « “<ERROR: checking out “ « vobjectPtr ->getName() 

« “ Aborting dump_vobject_tree_func>'fl”; 
TRACE(“file_operation not successful”): 

) 

break; 

default: 

cerr « “<ERROR: invalid number args fw get vobject TREE FILES>\n” 

} 


void long_list_operators_func(int number_arguments. char *proto_name. 
char *operator_name, char * variationstr, 
char *versionstr) 

{ 

TRACER(“long_list_operators_func”); 

V_OBJECT *vobjectPtr: 

threadPtr = findThread(proto_name, operator_name): 
if (IthreadPtr) 

I 

return; 

I 


switch (number_arguments) 

{ 

case 2: 

TRACE(“case2”): 

vobjectPtr = getDefaultVObject(threadPtr): 
if (vobjectPtr) 

{ 

TRACE(“vobjectPtr not null”): 
vobjectPtr->longlistOperatorNamesO; 

} 

break: 
case 4: 

TRACE(“case4”); 

TRACE(“threadPtr not null”); 

threadPtr = firstThread (threadPtr, atoi(variationstr)): 

vobjectPtr = threadPtr->version(atoi(versionstr)): 

// change made bj UW 4/6/92 
if (vobjectPtr) 


324 








I 

TRACE(“vobjectPtr not null”); 
vobjectPtr->longlistOperatorNames(); 

) 

break; 

default: 

TRACE(“default”); 

ceir « “<ERROR: invalid number args for long list operators>\n”; 


1 

void long_list_children_func(int number_arguments, char *proto_name, 
char *operator_name.char *versionsir) 

{ 

TRACER(“long_list_children_func”); 

V_OBJECT *vobjectPtr; 

threadPtr = findThread(proto_name, operator_name); 
if (! threadPtr) 

( 

return; 

} 

switch (number_arguments) 

( 

case 2: 

vobjectPtr = threadPtr->currentO; 
vobjectPtr -> listChildren(); 
break; 
case 3: 

vobjectPtr = threadPtr->version(atoi(versionstr)); 
vobjectPtr->listChildren(); 
break; 
default: 

cerr« “<ERROR: invalid number args for long list children >\n”; 


void long_list_parents_func(int number_arguments, char *proto_name. 
char *operator_name, char *variationstr, 
char *versionstr) 

{ 

TRACER(“long_list_parents_func”); 

V_OBJECT *parentPtr. 

V_OBJECT *vobjectPtr. 


325 




threadPtr = findThread(proto_name, operator_name); 
ifdthreadPtr) 

{ 

return; 

} 

switch (number_arguments) 

{ 

case 2: 

TRACE(“case2”); 

vobjectPtr = getDefaultVObject(threadPtr); 
parentPtr = vobjectPtr->getParentO; 
if (parentPtr) 

{ 

V_OBJECT *grandparent = parentPtr->getParent(); 
if (grandparent) 
grandparent -> listChiJdrenO; 
else 

cout« “ -<^nRoot Node: “ 

« parentPtr->getNodeName()« ">\n”; 

) 

break; 
case 4: 

TRACE(“case4”); 

threadPtr = firstThread (threadPtr, atoi(variationstr)); 
vobjectPtr = threadPir->version(atoi(versionstr)); 
parentPtr = vobjectPtr->getParentO: 
if (parentPtr) 

V_OBJECT ‘grandparent = parentPtr->getParent(); 
if (grandparent) 
grandparent -> listChildrenO; 
else 

cerr « “<Can not list Parent/siblings of Root V_Object>'^’’; 

) 

else 

cerr« “<Currently located at Root V_OBJECT>\n”; 
break; 
default: 

TRACE(“dfault"): 

cout« “<ERROR: invalid number args for long list children >\n'' 

) 





DDBControlData* getddbControlFile (char ♦ddbctrlfile) 

i 

TRACERC'GETddbControlFUe”); 

DDBControlData •VarVerNumberPtr = new DDBControlData; 
fstream infile; 

infile.open(ddbctrlfilejos :: in I ios;: nocreate); 
int result = infile.goodO; 

if (Iresult) 

{ 

infile.closeO: 

return VarVerNumberPtr = (DDBControlData •lO; 

} 

infile » VarVerNumberPtr-> variation; 
infile » VarVerNumberPtr-> version; 
infile.closeO; 
return VarVerNumberPtr, 

} 


void putddbControlFile (char *ddbctrlfile, DDBControlData •DDBCtrl) 

{ 

fstream outfile; 

outfile.open(ddbctrlfile.ios:: out); 
outfile « DDBCtrl-> variation «‘^n”; 
outfile « DDBCtrl-> version « “^n”; 
outfile.closeO; 

1 


void add_new_variation_func(int number_arguments. char *proto_name. 

char *operator_name. 
char *variationstr, 
char *versionstr) 

{ 

TRACER(“add_new_variation_func”); 
char *prototype_name = (chai*)(My_String(proto_name) + 
My_String(PROTOTYPE_EXD); 

V.OBJECT *variationPtr = (V_OBJECT ‘lO; 

V.OBJECT *NewVariationPtr = (V_OBJECT *)0; 

V.OBJECT *versionPtr = (V_OBJECT ‘lO; 

V.OBJECT *new_parent = (V.OBJECT ‘lO; 

THREAD ‘TheThread = (THREAD ‘lO; 

prototypeptr = (PROTOTYPE*)C)C_lookup(prot«ype_name); 


327 






if (prototypepir) 

{ 

cout« operator_naine «‘^n”; 

char •p_operator_nanie = buildThreadName(operator_name, 1); 
threadPtr = (THREAD *)OC_lookup(p_operator_name); 

) 

else 

{ 

cerr « “<ERROR: getting Prototype in ADD_NEW_VARIATION:>Nn’*; 
return; 

} 


switch (nuniber_arguments) 

{ 

case 2: 
i 

if (IthreadPtr) 

{ 

variationstr = 'T”; 
versionstr = “1”; 

} 

else 

{ 

// do a get control data here to check if a control fde exists. 
V_OBJECT *default_Version = getDefaultVObject(threadPtr); 
new_parent = default_Version->getParentO; 

} 

break; 

1 

case 4: 

I 

if (threadPtr) 

i 

variationPtrs threadPtr -> version(l); 

NewVariaiionPtr = variationPtr -> variation(atoi( variationstr)); 
TheThread = NewVariaiionPtr -> getThieadO; 
if (TheThread) 

{ 

versionPtr * TheThread -> version(aioi(versionstr)); 
new_parent - versionPtr->getParentO; 

) 

) 

break; 

} 



328 





default: 

I 

cerr « “<ERROR: invalid number args for add new variation>\n”: 
return; 

} 

} 

DIRECTORY ‘capstlirectory; 
capsdirectory = new DIRECTORYQ: 
capsdirectory->read_directory(operator_name); 
capsdirectory->updatetimestampO: 

TREENODE_linkedlist operatorList = capsdirectory->getOperatorListO: 
TREENODE *rootnode = capsdirectory->find_treenode(operator_name): 
TREENODE *tree_root = new TREENODE(rootnodeJ'njLL); 

TREE *workingtree = new TREE(tree_root, operator_name); 
worfcingtree->build_tree(tree_root,operatorList); 

V_OBJECT *new_root = tree_root->checkin_node(new_parent); 
if (!new_root) 

i 

cerr « “<ERROR: Could not establish new_root in” 

« ”add_vobject_and_subtree_func. Aborting.>\n”; 
return; 

I 

new_root->setNodeName(tree_root->getname()); 

tree_root->checkin_subtree(new_root); 

/*Sldp release lock of first variation and version checked into database 
since it does not exist yet. */ 

/* 

if (!((atoi(variationstr) == 1) && (atoi(versionstr) = 1))) 

i 

release_subtree_lock_func( 4. proto_name, operaU)r_name. 
variationstr, versionstr); 


*1 

1 

THREAD* firstThiead (THREAD *threadPtr, int variationint) 

) { 

V_OBJECT *variationPtr = threadPtr -> version(l); 

V_OBJECT *NewVariationPtr = variationPtr -> variation(variationint); 
THREAD ‘firstthreadPtr = New VariationPtr -> getThreadO; 
r return firstthreadPtr; 

} 

V_OBJECT* getDefaultVObject(THREAD •initialThxeadPtr) 


329 





{ 

V_OBJECT *(lefault_Version = initialThreadPtr-> version( 1); 
int latest = default_Version-> getNumbeiOfVariationsO; 

V_OBJECT ’''working_default_Version = 
default_Version-> vanation(latest); 
initialThreadPtr = working_default_Version->get'nueadO; 
default_Version = initialThreadPtr-x:urtentO; 
cerr « “Default VOBJECT being being accessed. Variation: “ «latest 
« “ Version: “ « default_Version-> getVersionNumber() 

«‘N»”; 

return default_Version: 

} 


THREAD* findThread(char ‘proto^name, char *operator_naine) 

{ 

char *prototype_name = (char*)(My_String(proto_name) + 
My_String(PROTOTYPE_EXT)): 

prototypeptr = (PROTOTYPE*)OC_lookup(proU)type_name): 

THREAD *TempthreadPir = (THREAD *)0; 

if (prototypeptr) 

{ 

char *p_operator_name = buildThreadName(operator_narne, 1); 
TempthreadPtr = (THREAD *)OCJookup(p_operator_name); 
if (ITempthreadPtr) 

{ 

cerr « ”<ERROR: Invalid VObject name. Can not get Thread.>Nn"; 


} 

else 


( 

cerr« “<ERROR; Invalid Prototype name.>\n”; 

} 

return TempthreadPtr, 

) 


330 







LIST OF REFERENCES 




) 


; 


[Ref. 1] Douglas, Bryant, S., ^4 Conceptional Level Design of a Design Database for 
a Computer-Aided Prototyping System, Master’s Thesis, Naval Postgraduate 
School, Monterey, California, March 1989. 

[Ref. 2] Ketabchi, M. A., Berzins. V., March, S.,“ODM: Object Oriented Data Model 
for Design Databases”, Proc. ACM. Computer Science Conference, Feb 
1986, pp. 261-269. 

[Ref. 3] Ketabchi, M. A., Berzins. V., “Modeling and Managing CAD Databases, 
"'IEEE Computer, pp. 46-49, February 1987. 

[Ref. 4] Luqi, “Software Evolution Through Rapid Prototyping”, Computer, 
v.22,no.5, pp. 13-25, May 1989. 

[Ref. 5] Katz, Randy, H., Chang, Ellis, Bhateja, Rajiv, “Version Modeling Concepts 
for Computer-Aided Design Databases”, ACM, SIGMOD Rec. 15, pp. 397- 
386, April 1, 1986. 

[Ref. 6] McKenna, J., “Teaching OOP”, OOPSLA ‘88 Conference Proceedings, The 
Association for Computing Machinery, New York, NY, 1988. 

[Ref. 7] White, Laura, J., The Development of a Rapid Prototyping System, Master’s 
Thesis, Naval Postgraduate School, Monterey, California, December 1989. 

[Ref. 8] Luqi, A Graph Model for Software Evolution, IEEE Transactions on 
Software Evolution, v. 16, n. 8. pp. 917-927, August 1990. 

[Ref. 9] Berzins, V., Advanced Software Engineering (Course Notes), 1991. 

[Ref. 10] Lewis, Gary, W., Dwyer, Andrew, P., The Development of a Design Database 
for the Computer Aided Prototyping System, Master’s Thesis, Naval 
Postgraduate School, Monterey, California, September 1991. 

[Ref. 11] Ontologic Inc., ONTOS, Object Database Documentation Set, Release 2.0, 
Burlington, MA. 

[Ref. 12] Yourdon, E., Modern Structured Analysis, Yourdon Press, 1989. 

[Ref. 13] Frakes, William, B., Fox, Christopher, J., Nejmeh, Brian, A., Software 
Engineering in the UINIX/C Environment. Englewood Cliffs, N.J.:Prentice 
Hall, 1991. 


331 




[Ref. 14] Perry, D., “The Inscape Environment,” in Proc. 11th Int. Conf. Software 
Engineering, IEEE, 1989, pp. 2 -12. 

[Ref. 15] Kaiser. G., Feiler, P., and Reps, T., “Intelligent Assistance for software 
development and maintenance,” IEEE Software, pp. 40_49, May 1988. 


f 




332 






INITIAL DISTRIBUTION LIST 


1. Defense Technical Information Center 2 

Cameron Station 

Alexandria, VA 22304-6145 

2. Dudley Knox Library 2 

Code 52 

Naval Postgraduate School 
Monterey, CA 93943 

3. Computer Science Department 2 

Code CS 

Naval Postgraduate School 
Monterey, CA 93943 

4. Office of the Assistant Secretary of the Navy 1 

Research Development and Acquisition 

Department of the Navy 
Attn; Mr. Gerald A. Cann 
Washington, DC 20380-1000 

5. Office of the Chief of Naval Operations 1 

OP-094 

Depanment of the Navy 
Attn; VADM J. O. Tuttle, USN 
Washington, DC 20301-3040 

6. Director of Defense Information 1 

Office of the Assistant Secretary of Defense 

(Command, Control, Communications, & Intelligence) 

Attn; Mr. Paul Strassmann 
Washington, DC 20301-0208 

7. Center for Naval Analysis 1 

4401 Ford Avenue 

Alexandria, VA 22302-0268 


333 




8. Director of Research Administration 
Attn: Prof. Howard 

Code 08Hk 

Naval Postgraduate School 
Monterey, CA 93943 

9. Chairman, Code CS 
Computer Science Department 
Navd Postgraduate School 
Monterey, CA 93943-5100 

10. Prof. Luqi, Code CSLq 
Computer Science Department 
Naval Postgraduate School 
Monterey, CA 93943 

11. Chief of Naval Research 
Attn: ADM. Miller 

800 N. Quincy Street 
Arlington, VA 22217 

12. Director. Ada Joint Program Office 
OUSDRE (R&AT) 

Room 3E114, The Pentagon 
Attn: Dr. John P. Solomond 
Washington, DC 20301-0208 

13. Carnegie Mellon University 
Software Engineering Institute 
Attn: Dr. Dan Berry 
Pittsburgh, PA 15260 

14. Office of Naval Technology (ONT) 
Code 227 

Attn: Dr. Elizabeth Wald 
800 N. Quincy St. 

Arlington, VA 22217-5000 


334 






1 


15. Defense Advanced Research Projects Agency (DARPA) 

Integrated Strategic Technology Office (ISTO) 

Attn: Dr. B. Boehm 
1400 Wilson Boulevard 
Arlington, VA 22209-2308 

16. Defense Advanced Research Projects Agency (DARPA) 1 

ISTO 

1400 Wilson Boulevard 
Attn: LCol Eric Mattala 
Arlington, VA 2209-2308 

17. Defense Advanced Research Projects Agency (DARPA) 1 

Director, Tactical Technology Office 

1400 Wilson Boulevard 
Arlington, VA 2209-2308 

18. National Science Foundation 1 

Division of Computer and Computation Research 

Attn: K. C. Tai 
Washington, DC 20550 

19. Commander Space and Naval Warfare Systems Command 1 

SPA WAR 3212 

Department of the Navy 
Attn: Cdr M. Romeo 
Washington, DC 20363-5100 

20. Office of Naval Research 1 

Computer Science Division, Code 1133 

Attn: Dr. Gary Koob 
800 N. Quincy Street 
ArUngton,VA 22217-5000 

21. Office of Naval Research 1 
Computer Science Division, Code 1133 

Attn: Dr. A. M. Van Tilborg 
800 N. Quincy Street 
Arlington, VA 22217-5000 


335 





22. Office of Naval Research 
Computer Science Division, Code 1133 
Attn: Dr. R. Wachter 

800 N. Quincy Street 
Arlington, VA 22217-5000 

23. University of CA at Berkeley 
Department of Electrical Engineering and 
Computer Science 

Computer Science Division 
Attn: Dr. C.V. Ramamoorthy 
Berkeley, CA 90024 

24. University of MD 

College of Business Management 
Tydings Hall, Room 0137 
Attn: Dr. Alan Hevner 
College Park, MD 20742 

25. University of MD 
Computer Science Department 
Attn: Dr. N. Roussapoulos 
College Park, MD 20742 

26. University of Massachusetts 

Department of Computer and Information Science 
Attn: Dr. John A. Stankovic 
Amherst. MA 01003 

27. University of Pittsburgh 
Department of Computer Science 
Attn: Dr. Alfs Berztiss 
Pittsburgh, PA 15260 

28. Commander, Naval Surface Warfare Center, 

Code U-33 

Attn: Dr. Philip Hwang 
10901 New Hampshire Avenue 
Silver Spring, MD 20903-5000 


336 






29. Attn: Joel Trimble 

1211 South Fern Street, C107 
Arlington, VA 22202 

30. United States Laboratory Command 
Army Research Office 

Atm: Dr. David Hislop 
P. O. Box 12211 

Research Triangle Park, NC 27709-2211 

31. Persistent Data Systems 
75 W. Chapel Ridge Road 
Attn: Dr. John Nester 
Pittsburgh, PA 15238 

32. Commandant of the Marine Corps 
Ada Joint Program Representative 
Code CCI 

Attn: Capt Gerald Depasquale 
Washington, DC 20301 

33. Commandant of the Marine Corps 
Code TE-06 

Washington, DC 20301 

34. Commandant of the Marine Corps 
Code CCT-60 

Attn: Ltcol L. Machabee 
Washington, DC 20301 

35. Mrs. Loretta O’Loughlin 
46 Willow Road 
Metuchen, NJ 08840 

36. Ll Greg Hammond USN 
5 Knoll Court 
Hercules CA. 

37. Capt Michael D. O’Loughlin USMC 
18 Continental Road 
Summerset NJ. 08873 










