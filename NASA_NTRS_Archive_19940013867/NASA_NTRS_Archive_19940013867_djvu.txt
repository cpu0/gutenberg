3rd NASA Symposium on VLSI Design 1991 


N94-18340 

2 . 1.1 


Automated ILA Design, 
for Synchronous Sequential Circuits 

M. N. Liu, K. Z. Liu, G. K. Maki and S. R. Whitaker 
NASA Space Engineering Research Center for VLSI System Design 

University of Idaho 
Moscow, Idaho 83843 

Abstract - This paper presents an ILA architecture for synchronous sequential 
circuits. This technique utilizes linear algebra to produce the design equations. 
The ILA realization of synchronous sequential logic can be fully automated 
with a computer program. A programmable design procedure is proposed to 
fulfill the design task and layout generation. A software algorithm in the C 
language has been developed and tested to generate 1 um CMOS layouts using 
the Hewlett-Packard FUNGEN module generator shell. 


1 Introduction 

The design of sequential circuits presents a major task for most digital systems. As Very 
Large Scale Integrated (VLSI) technology advances, developing an architecture to maxi- 
mize the efficiencies of all the design steps becomes a major goal in the research of sequential 
circuit design. 

This paper introduces the Iterative Logic Array (ILA) as a new architecture for syn- 
chronous sequential circuits. This architecture realizes a sequential circuit by repheating 
sim ple basic modules. With an ILA architecture, a sequential machine can be built into a 
very regular form automatically by a computer program with a single type of ILA mod- 
ule. The simplicity and programmability of the ILA architecture significantly reduce the 
design task in all stages of VLSI implementation, from logic design, circuit design, artwork 
generation to verification. 


2 ILA Architecture 

Iterative Logic Arrays (ILA) have been described in the literature for quite some time [1,2]. 
An ILA circuit consists of an array of identical cells. Generally, as shown in Figure 1, each 
ILA cell contains two sets of input signals. One set of inputs are applied in parallel, while 
the other set of inputs are driven by adjacent cells. Signals normally propagate in only 
one direction between cells, and outputs are derived only from the serial outputs of the 
last cell. 

In an ILA architecture for sequential circuits, the next state of each state variable is 
generated by a slice of concatenated ILA cells. A sequential network is then constructed 
by placing the ILA slices side by side. 



2.1.2 


Serial 

Inpat 



Serial 

Output 


Figure 1: A slice of ILA circuit 



Figure 2: Pass transistor 2-to-i MUX 


THe basic celf of an itA sequential network consists of a 2-to-l multiplexer (MUX) and 
a next state forming logic. A MUX cell has a select line S, its complement 3 and two data 
inputs J 0 and I u and a logic function defined by Equation 1. 

Q = S*Jj+S*J 0 (1) 

The simplest way to implement the MUX function is to use a pass transistor circuit. 
Basically, the pass transistor MUX, excluding level restoration logic, is a module of two 
pass transistors, which functions as two simple switches. Figure 2 shows the circuit of 
two inputs Ji and J 0 and one output Q controlled by two control lines S and 5 which 
are assumed to be asserted exclusively such that only one of two inputs Ii and J 0 can be 
passed to Q at a given time. 

Some details in pass transistor transmission characteristics are omitted here. Design 
considerations, such as level restoration, are assumed to be handled by the output buffers. 
The circuit design considerations have been discussed in [3,4,5]. 


3 Operational Function 

In this research, the one-hot-code is utilized as the state assignment for a synchronous flow 
table. With the one-hot-code assignment, there is a unique state variable corresponding 
to each state. That makes it possible to express the design function using the states in 
the flow table explicitly. A new form of mathematical expression is proposed next which 
describes a flow table directly by flow table states. 


Ill IPI illl I II III 1 1 III! II llll 





3rd NASA Symposium on VLSI Design 1991 


2.1.3 


Definition 1 The set of operational functions is the behavior description of a synchronous 
flow table of n rows and m columns. Each function is an equation for a next state Si in 
the flow table. 

m 

^ = E s *p j p ( 2 ) 

p - 1 

where Si p is an OR function of the states Sj,Vj = 1 , • • * ,n, which have Si as the next entry 
under input I p . 

It can be shown that there is a one-to-one mapping between the next state equation 

y> = E hb (*) 

p=l 

and the operational function. With the one-hot-code state assignment, each T-partition 
can be expressed as 

t = {&;£} 

which partitions a single state Si from the rest states S in the flow table. The number 
of state variables is equal to the number of states. Next state ^-partitions can be formed 
using known procedures [ 6 ]. If an 77 -partition 77 ; is 

Vi = {S1S2 • ■ • Si]S} 

then it is well known that 

ftp — Vi + 1/2 + • • • + Vi- 

On the other hand, Equation 2 

m 

Si = ^2 Si p i p 

p=i 

can be mapped into a next state equation as Equation 3 if the one-hot-code assignment 
is used where fi p are sum of the state variables yj corresponding to 3{ p in Equation 2. 
Therefore, there is a one-to-one mapping between Equation 2 and Equation 3. 

Since the operational function is a direct representation of the flow table, they can be 
derived by inspection. For each state in the next state entry, there is a product term of 
the present state and input state in the operational function. If a synchronous machine 
is specified by a state diagram, the state diagram may need to be converted to a flow 
table, though it will not be too hard for an experienced designer to derive the operational 
functions from the state diagram directly. 

Table 1 is the flow table of a state machine with four states. For example, State S a 
appears as the next state entry of states Sb, S c and Sj under Jj. Therefore, the operational 
function for S a is 

S a = ( Sb + S c + Sd)Ii. 

For State Sb, it appears as the next state under both I\ and I 2 . So the operational 
function for state Sb is 


Sb — S a Ii + {Sb + Sc)!?. 



2.1.4 


h h h 
S* 

Sb 
S e 
S d 

Table 1: A synchronous flow table for the state diagram 

The operational functions for state S c and Sd can be derived in the same way. All 
together, the operational functions for Table 1 are as follows! 

S a = + S c + Sd)I\ 

Sb — Sah + {Sb + S c )i 2 (4) 

Sc ~ (S a + Sb + Sd)!^ 

Sd — {S a + Sd)i2 + (S c + Sd)i 3 

4 ILA Architecture for Synchronous Sequential Cir- 
cuits 

A simple regular ILA structure requires: 

• The design equation is convertible to a pass logic function where each control variable 
passes a single pass variable or a constant. 

* ^'^■ e control variables are shared with each pass logic function. 

With such a structure, if the pass variables in each equation are the same, the signal bus 
to each shce of ILA circuit can be minimized to a single wire. 

If state Si is used as the control and 5, appears as a next state under only one input 
I p , then I p can be the only pass variable in the design equation for 5,. For example, the 
equation for S a in Equation 4 can be converted into a pass logic function with input I x as 
a pass variable: 

Sa = Sb{ /,) + 5 e (J 1 ) + S d (h) 

From the definition of the operational function in Equation 2, if 5, appears only under 
input Ip, then Equation 2 can be rewritten as: 

Si - Siplp (5) 

where is an OR function of the states Sk,k E {1,2, • • • ,n}. Therefore, Equation 5 can 
be written into: 

Si — Ip SikSk 

k = 1 



( 6 ) 



3rd NASA Symposium on VLSI Design 1991 


2.1 



Figure 3: The general ILA structure for synchronous logic 


or in a form of pass logic expression: 

Si — Si(gnl p ) + Si( ■ ■ • Sk(giklp) + Sk( • • • ( S n (gi n I p ) + 5 n (0) • • •)• (7) 


where 


gik = 


1 if S{ is the next state of Sk under I p 
0 if Si is not the next state of Sk under I p 


Theorem 1 The architecture depicted in Figure 3 is a proper model for a synchronous 
sequential circuit. 


Proof: The proof follows directly from one-hot-code assignment that one and only one 
state variable are active at a time and Equation 6 contains only one input state. Clearly, 
the architecture realizes Equation 6 by placing a multiplexer under Sk where g ik = 1 and 
a wire under Sk where gik = 0. 

□ 

To accomplish the ILA structure, Si must be restricted to appear in a flow table under 
only one input I p . If a state Si appears as a next state under both I p and Si has to be 
split into two different states. For example, in Table 1, state Sj, appears under both input 
J x and J 2 . It is necessary to distinguish St, with two unique states Sbi and Sj, 2 where S&i 
represents the St, under Ji and S(, 2 represents the St, under J 2 . Similarly, state Sd needs to 
be split into S<t 2 and S<«. A revised flow table can then be obtained by splitting all states 
under different columns. Table 2 shows the result. 

After updating the flow table, the operational function for each state can be derived 
in the same way as before. For example, St, 2 is the state under J 2 only. Therefore, its 
operational function is 


Sb2 = 0 + S(,i/ 2 -f S(, 2 7 2 4- S C I 2 -f 0 + 0. 







2.1.6 


h h h 


S a 

Sbi Sdl S c 

Sbi 

s« S b2 S c 

Sb 2 

S a S b2 S c 

Sc 

S a S b 2 Sd 3 

Sd 2 

S a Sd 2 Sdz 

Sd 3 

Sa Sd 2 Sd 3 


Table 2: A revised flow table 

AD other operational functions are also ip the same form. The res ult s are shown as follows; 

0 + Sbil\ + S&jJi + S c Ii + Sj 2I1 + S<j 3 Ii 

Sbi = S a Ii + 0 +0 +0 +0 +0 

Sb 2 0 Sbi I 2 -f" Sbi^J “I - S C I 3 -f- 0 f- 0 

Sc = S a Ii -f S M h 4 - 5^3X3 0 +_ 0 ^ + 0 ;~ 

Sj2 SJ 2 +0 +0 + 0 + Sd 2 I 2 -f- S'*/, 

s d3 = 0 +0 +0 + SMf '$&£+ CT S ■ !i v 

Splitting states in a flow table allows aD of the pass variables in an operational function 
to be the same. The disadvantage of splitting states is that it generates additional next 
state equations. Increasing the number of equations implies increasing the area in silicon. 
It is a trade off by gaining programmability and regular ity of the ILA realization versus 
cost. An automated sequential circuit design will significantly reduce the d e sign effor t and 
speedup the process of implementation. 


5 The Matrix Expression 

The operational functions discussed in previous sections can be efficiently expressed with 
matrices. The matrix will also help to implement the function in silicon. With Equation 6, 
a synchronous sequential circuit can be expressed with a set of equations:' - 

n 

Si — ip gikSk 

k=i 

n 

Sn = Iq ^ ] 9nkSk 

k = 1 

Such a set of equations are equivalent to a matrix expression: 


S = A x G x S 


( 8 ) 



3rd NASA Symposium on VLSI Design 1991 


2.1.7 


where matrices S are S are column vectors 



1 i 

Si \ 

Si 

III 

C/5 

Si 

Unj 

1 

s n ) 


matrix A is a diagonal matrix with I p in the i th row/column if the next state Si is under 

( h ' 

0 


A = 


h 


and matrix G is defined as 


/ 


9 li • ' 


’ • < 7 ln 


\ 


G = 


\ 9nl 9nn f 


in which 



if S{ is the next state of Sk 
if Si is not the next state of Sk 


For example, the matrix expression for the flow table in Table 2 is: 


S a ) 


h 

0 

0 

0 

0 

0 \ 

Sbi 


0 

II 

0 

0 

0 

0 

Sb 2 


0 

0 

h 

0 

0 

0 

Sc 


0 

0 

0 

h 

0 

0 

Sd i 


0 

0 

0 

0 

h 

0 

Sd2 J 


0 

0 

0 

0 

0 

h) 


0 1 1 1 1 1 \ 


Sa \ 

1 0 0 0 0 0 


Sbi 

0 1110 0 


Sbi 

1110 0 0 


Sc 

1 0 0 0 1 1 


Sdx 

^ 0 0 0 1 1 1 ) 


Sd2 / 


( 9 ) 


The matrix A and G are directly related to hardware structure. As in the ILA realiza- 
tion, there will be a slice of the ILA circuit for each design equation, as shown in Figure 3. 
Now each element at the diagonal of the matrix A indicates the input state to the ILA 
slice. Each row of matrix G reveals the location of ILA cells in the slice. If the element 
gik is 1, then an ILA cell will be placed under the control of state Sk in the slice of the 
ILA circuit for next state Si. If gik is equal to 0, a wire will be placed in that position. An 
example of the ILA realization will be shown in next section. 



2.1.8 


6 Design Procedure 

From the discussion in the previous section, the design of a synchronous machine can be 
completely automated by programming an ILA cell or a wire into a pre-interconnected 
layout floor. It allows the physical layout to be designed and stored in computer as a set 
of building blocks. Then for each instance of synchronous sequential logic, an ILA circuit 
can be implemented by placing ILA cells according to the corresponding G matrix. The 
A matrix will indicate the interconnection to Input states 

From the layout point of view, a wire can be considered as a cell as well. Hence 
there will be two cell types in an ILA realization. Let the ILA cell which performs the 
multiplexer function be defined as a MUX cell. Let a wire be defined as an ILA ZERO 
cell Now the computer program can search the G matrix and place a MUX cell once a 
1 is encountered or a ZERO cell once a K 0 n is encountered. The schematic of a MUX 
cell and a ZERO cell are shown in Figure 4 (b) and (c) respectively. 

Procedure 1 Synchronous ILA network design procedure. 

Step 1. For a synchronous machine specified Sy a state diagram , convert it into d sljfi* 
chronous flow table (state table). 

Step 2 , If a state appears as a next state under more than one input column, split the 
state and give a unique name to the state under each input column. Repeat this step 
until all states under one column are distinguished from states under other columns. 

Step 3. Generate the A matrix by setting the diagonal element in the i ih column to be I p 
if state Si appears as a next state in the flow table under I p . 

Step 4. Generate the G matrix such that is “1” if Si is the next state of Sj, gij = 0 
otherwise . 

Step 5. Map the matrices to the layout floor. Place a MUX cell under the control of S k 
in the slice of the ILA circuit for the next state 5, if g ik = 1 or place a ZERO cell if 

9ik = 0 . 

Step 6 . Connect Input- 1 of the last ILA cell in the slice of the ILA circuit for Si to I p 
which is the diagonal element of matrix A in the i th row. Connect Input-0 of the last 
ILA cell to the level of logic low (VSS). 

For example, for a synchronous machine specified a flow table shown in Table 1, it 
needs to find those states which are under more than one input state and to split them. 
The result of splitting is shown in Table 2 . The matrices of the flow fable can then be 
generated. For instance, S a is a next state under I\ of state S^i, *S& 2 > S c , S ^2 and Sj 3 . Then 
I x becomes the diagonal element a ia in matrix A; the row of matrix G will have a “0” 
in the first column since the next state of S a under I x is not S a , and have a “ 1 ” in the rest 
of columns. The A matrix and G matrix can then be mapped into an ILA network. The 
result is shown in Figure 4 (a) where each ILA cell is represented by a box. The boxes in 
dash line represent the ZERO cell (g {j = 0 ) and boxes in solid line represent the MUX cell 


II I llll II 


3rd NASA Symposium on VLSI Design 1991 


2.1.9 



(a) Synchronous ILA network 



(b) ILA cell - mux 



(c) ILA cell - zero 


Figure 4: The ILA network for the example 









2.1.10 


iSH = !)• As the first row of matrix G is “011111”, the top slice of the ILA for S a consists 
of one ZERO cell on the left and five MUX cells. Again, from matrix A, the input of the 
last ILA cell is tied to I\ and VSS. 

As mentioned before, a major advantage of the design approach in Procedure 1 is that 
it allows a hierarchical layout design. The high level layout, including interconnections, is 
identical for all synchronous flow tables. When the function of a flow table changes, the 
only thing one has to do is to instruct the computer to re-program the position of MUX 
cell and ZERO cell. Of course, the input state to each slice of the ILA may need to be 
changed as well. I * 

7 Automated Synchronous ILA Design System 

The ILA design procedure has been coded into computer programs and ported to Hewlett- 
Packard FUNGEN layout tool. The automatic synchronous ILA design system consists of 
an HP FUNGEN shell and three major subsystems: 

• Sequential Logic Processor 

• FUNGEN Configuration Code 

• Library of Layout Building Blocks. 

The Sequential Logic Processor is an ILA circuit topology generator which receives the 
specification of synchronous sequential machine and converts it into a form specified by 
FUNGEN Configuration Code. There are three phases in Implementing the Sequential 
Logic Processor: flow table revising, matrices generation and FGNRC formation. The firs t 
two phases follows closely to the step 2, step 3 and step 4 in Procedure 1. The third phase 
is to generate parameters of device modules pre-defined by FUNGEN Configuration Code 
and write them into a FGNRC file. By modifying the last phase, the program can be 
ported to any other artwork generator systems. 

The FUNGEN Configuration Code describes the artwork architecture and defines the 
modules in the FGNRC file. The FUNGEN Configuration Code is written in Fungen 
Configuration Language (FCL), a subset of C language with a number of functions for 
Hewlett-Packard TRANTOR database generation. The overall ILA architecture and a set 
of ILA configuration modules are specified in the FUNGEN Configuration Code. 

When running the FUNGEN shell, the system invokes the FUNGEN Configuration 
Code, FGNRC file and Layout Library, and automatically generates a layout artwork 
by placing pre-designed ILA cells and peripheral buffers. It also labels all of blocks in 
accordance with the FUNGEN Configuration Code and FGNRC file. Figure 5 illustrates 
the block diagram of the ILA design system and the algorithm of Sequential Logic Processor 
implement ation . 



3rd NASA Symposium on VLSI Design 1991 


2 . 1.11 


SYNCHRONOUS FLOW TABLE 


i 


» 

For all States 


NO 


YES 



SPLIT ?^> 

1 




Modify Columrs 








Add Rows 
1 

j 




NO 

< DO 

\ YES 
NE ?> 1 



FUNGEN 

Configuration 

Code 




Figure 5: Block diagram of the automatic ILA design system 












2.1.12 


8 Summary 

This paper presents an ILA architecture for synchronous sequential circuits. The design 
procedure is also proposed to realize synchronous sequential ILA circuits by programming 
the placement of two basic cells, a 2 to 1 multiplexer or a cell of metal wires. The inter- 
connections between ILA cells is only a single route line in both the X and Y dimension. 
The simplicity and programmability of the procedure significantly reduce the effort in all 
stages of synchronous sequential circuit implementation, from logic design, circuit design, 
physical layout to verification. 

The ILA design procedure utilizes matrices expression to represent design equations. 
One of the advantages of using matrices is that they directly indicate the placement of the 
ILA cells in the realization. An ILA design tool for synchronous sequential circuits has 
been implemented into a computer system which automatically generates layout artwork 
from a synchronous sequential machine specification. 


References 

[1] C. Roth, Fundamentals of Logic Design , 3rd Ed,. St. Paul, Minn., West Publishing, 
1985. 

[2] D. Givone, Introduction to Switching Circuit Theory , McGraw-Hill, Inc., 1970. 

[3] S. Whitaker, “Design of Asynchronous Sequential Circuits Using Pass transistors,” 
Ph.D Dissertation, University of Idaho, Feb. 1988. 

[4] S. K. Gopalakrishnan and G. K. Maki, “VLSI Asynchronous Sequential Circuit De- 
sign”, ICCD, Sept, 1990, pp. 238-242. 

[5] S. Whitaker and G. Maki, “Pass-Transistor Asynchronous Sequential Circuits”, IEEE 
JSSC, Vol.24, No.l, Feb. 1989, pp. 71-78. 

[6] W. W. Stiehl, “A Mathematical Basis for the Optimal Synthesis of Finite State Ma- 
chines.” Master of Science Thesis, University of Idaho, Moscow, Idaho, June, 1986. 


