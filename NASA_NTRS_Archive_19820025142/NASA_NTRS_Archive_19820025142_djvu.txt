NASA CONTRACTOR 
REPORT 


DO NOT DESTROY 
RETURN TO IIBRAR 


NASACR-161328 


STANDARD TRANSISTOR ARRAY (STAR) - SIMLOG TESTGN 
PROGRAMMER'S GUIDE, Volume 2, Addendum 2 

By B. D. Carroll 
Electrical Engineering Department 
Auburn University 
Auburn, Alabama 36830 

FOR EARLY DOMESTIC DISSEMINATION 


Because of its significant early commercial potential, this information, 
which has been developed under a U. S. Government program, is being dis- 
seminated within the United States in advance of general publication. This infor- 
mation may be duplicated and used by the recipient with the express limitation that 
it not be published. Release of this information to toher domestic parties by the 
recipient shall be made subject to these limitations. Foreign release may be made 
only with prior NASA approval and appropriate export licenses. This legend shall 
be marked on any reproduction of this information in whole or in part. 


Date for general release: November 1981 

Final Report 
September 14, 1979 



Prepared for 

NASA - GEORGE C. MARSHALL SPACE FLIGHT CENTER 
Marshall Space Flight Center, Alabama 35812 




1 REPORT NO 2 GOVERNMENT ACCESSION NO. 

NASA CR-1G13?S 


4 title and subtitle 

standard Transistor Array (STAR) - SIMLOG/TESTGN Pro- 
grammer’s Guide. Fiaal Report, Volume 2, Addendum 2 


7 AUTHOR(S) 

B. D Carroll 


9 PERFORMING ORGANIZATION NAME AND ADDRESS 

Electrical Engineering Department 
Auburn University 
Auburn, Alabama 36830 


12 SPONSORING AGENCY NAME AND ADDRESS 

National Aeronautics and Space Administration 
Washington, DC 20546 


TECHNICAL REPORT STANDARD TITLE PAGE 


3 RECIPIENT'S CATALOG NO. 


5 REPORT DATE 

September 14, 1979 


6 PERFORMING ORGANIZATION CODE 


8 PERFORMING ORGANIZATION REPORT tt 


10 WORK UNIT NO. 

7i CONTRACT OR GRANT NO. 
NAS8-31572 

13 TYPE OF REPORi & PERIOD COVERED 

Contractor Report 
Final 


14 SPONSORING AGENCY CODE 


15 SUPPLEMENTARY NOTES 

This work was done under the technical supervision of Mr. Jack Matheney, George C. 
Marshall Space Flight Center, Alabama. 


16. ABSTRACT 


A brief introduction to the SIMLOG/TESTGN system of programs is given. SIMLOG is 
a logic simulation program, whereas TESTGN is a program for generating test sequences from 
output produced by SIMLOG. 


The structures of the two programs are described. Data base, main program, and 
subprogram details are also given. Guidelines for program modifications are discussed. 
Commented program listings are included. 




F. BROOKS MOORE 
Dir, Electronics and Control Laboratory, MSF( 


19 SECURITY CLASSIF (Of thU rep'Jrti 

20 SECURITY CLASSIF. (of Ihli page) 

21 NO. OF PAGES 

22 PRICE 

Unclassified 

Unclassified 

136 

NTIS 


MSFC • Form 3 J92 (Rev December 1 9 7 3 ) 


For sale by National Technical Information Service, Springfield, Virginia 221B1 


















Page intentionally left blank 


Page intentionally left blank 


TABLE OF CONTENTS 


LIST OF FIGURES iv 

LIST OF TABLES v 

1. INTRODUCTION 1 

2. SYSTEM STRUCTURE 3 

3. SYSTEM DATABASE 12 


Circuit Description Arrays 

Function Files 

Processing Arrays 

I/O Stream (Channel) Assignments 

4. PROGRAM DESCRIPTIONS 26 

SIMl and SIMA 

SIM2 

RACE 

SIMB 

TESTGN 


5. PROGRAM MODIFICATION GUIDELINES 56 

Parameter Settings 
Suggestions for Improvement 

6. REFERENCES 58 

APPENDIX 59 


iii 



LIST OF FIGURES 


1. SIMLOG/TESTGN System Structure 4 

2. SIMLOG Structure 5 

3. SIMl and SIMA Structure . 7 

4. SIMB Structure 8 

5. SIM2 Structure 9 

6 . RACE Structure 10 

7. TESTGN Structure 11 

8 . Array N(N$) Format 13 

9. JK Flip-Flop Circuit 14 

10. Description of Array P 16 

11. Description of Array 1(1$) 17 

12. Description of Array Q(Q$) 18 

13. Function Representation in Arrays 21 

14. SIMl and SIMA Flowchart 27 

15. SIM2 Flowchart 

16. RACE Flowchart 

17. TESTGN Flowchart 49 

18. Test Function Computation Routine Flowchart 52 


IV 


LIST OF TABLES 


1. Data File Definitions 19 

2. SIMA and SIMl Channel Assignments 23 

3. SIMB I/O Channel Assignments (PDF 11) , 24 

4. SIM2 and RACE I/O Stream Assignments (Sigma 5) 24 


V 


1 . INTRODUCTION 


The purpose of this document is to provide programming level de- 
tail of the SIMLOG/TESTGN system. Those interested in the theoretical 
basis of the system should refer to [1]. User information on the sys- 
tem is given in [2]. 

A brief functional description of the SIMLOG/TESTGN system is 
presented below. Details of the system structure are given in Section 
2. The system database is described in Section 3 while the program 
descriptions are given in Section 4. Modification guidelines can be 
found in Section 5. Heavily commented listings of all programs are in- 
cluded as an Appendix. 

The system of programs described herein was written to provide a 
cost-effective but powerful tool for simulating logic circuits and for 
generating test sequences for logic circuits. BASIC was chosen as the 
implementation language since it is commonly available on minicomputer- 
based and microcomputer-based computing systems. Application of the 
programs to circuits containing five-hundred or more gates is feasible 
if the host computer system provides a sufficient primary and secondary 
storage capacity. 

SIMLOG is a gate-level logic simulation program that is based on a 
three-valued logic model and on a unit-delay timing model. Both com- 
binational and sequential circuits can be handled. Circuits containing 


1 


2 


single or multiple stuck-type faults can be simulated. Logic elements 
available for use include NAND gates, NOR gates, unit delay elements, 
and edge-triggered D flip-flops. 

TEST6N is a test sequence generation program for circuits pre- 
viously simulated by SIMLOG. The program can be used to generate 
tests for unspecified faults or for specified single stuck-type faults. 


2. SYSTEM STRUCTURE 


The top-level structure of the SIML06/TESTGN system is shown in 
Figure 1. Both programs build portions of the database but that seg- 
ment built by SIMLOG must be available prior to the execution of TESTGN. 
The SIMLOG database is self-generated. 

Two versions of the system have been written. One version is writ- 
ten in Xerox BASIC for execution on a Sigma 5 CPV computer system. 

The second version is written in BASIC-PLUS for execution on a POP 11/40 
RSTS/E computer system. 

The structure of SIMLOG is different for the two versions, while 
the TESTGN structure is common to both versions. Figure 2(a) shows the 
SIMLOG structure for the POP 11 version. The structure of the Sigma 5 
version is detailed in Figure 2(b). Differences in the two structures 
are necessary due to array access methods of the two host computers. 
Additional details on these differences are given in Section 3. Cor- 
respondence between the various subprograms is as follows. SIMA and 
SIMl are equivalent, whereas SIMB combines the functions of SIM2 and 
RACE. 

Each SIMLOG module or subprogram is written as a separate program. 
Chaining is used to transfer control and execution from one subprogram 
to another. TESTGN is implemented as a single program module. A lower 
level structural description of each program module will now be given. 


3 







Figure 2. SIML06 STRUCTURE 










6 


Figure 3 shows the structure of the SIMA and SIMl subprograms. 

The SIMB structure is given in Figure 4; while the structures of SIM2 
and RACE are given in Figures 5 and 6, respectively. See Figure 7 for 
the structure of TESTGN. 

It is clear that the subprograms share a number of common routines. 

All routines are described in detail in Section 4. The next section is 
devoted to a description of the system database. 

( 


1 


7 


SIM2 or SIMB 
TESTGN 


RUN 

I 

I 


Main 

Program 



Figure 3. SIM1 and SIMA Structure 




> TESTGN 


8 



SIMB Structure 


























SIMl 



Figure 5. SIM2 Structure. 




Main 


10 



Figure 6. RACE Structure 







Main I >SIM1 

Routine 


11 



Figure 7. TEST6N Structure. 









3. SYSTEM DATABASE 


The SIMLOG/TESTGN database consists of structures for storing a 
description of the circuit to be processed, for storing the function set 
generated for a given ripple-time, and for storing operand and resultant 
functions. Each of these structures is described below. Other related 
matters such as I/O stream assignments are also discussed in this sec- 
tion. In the following descriptions, the array and file names used are 
common to both versions of SIMLOG unless indicated by an alternate name 
enclosed within parentheses. In such a case, the term in parentheses 
corresponds to the POP 11 version, and the preceding term to the Sigma 
5 version. 

CIRCUIT DESCRIPTION ARRAYS 

The description of a circuit to be processed by SIMLOG or TESTGN 
is contained in arrays N(NS), P, 1(1$), and Q(A$) which are described 
below. 

N(N$) . This is an array of character strings with dimensions 
N X 4 where N is the number of elements in the circuit. Each row in the 
array corresponds to a particular element and the row number is the same 
as the record number in the data files where the gate output equations 
are stored. Figure 8(a) describes the general format of the array while 
Figure 8(b) illustrates the array for the circuit shown in Figure 9. 


12 


13 




1 

2 

3 

4 


1 

Gate 

Gate 

Fault 

Circuit 

Records 

2 

Name 

Type 

Condition 

Output 


N or Not 


(a) General Format 
12 3 4 


1 

A 

NANO 

FF 

NO 

2 

B 

NANO 

FF 

NO 

3 

C 

NANO 

FF 

NO 

4 

0 

NANO 

FF 

NO 

5 

E 

NANO 

FF 

NO 

6 

F 

NANO 

FF 

NO 

7 

G 

NANO 

FF 

NO 

8 

Q 

NANO 

FF 

YES 

9 

QBAR 

NANO 

FF 

YES 


(b) Example from Figure 9 


Figure 8. Array N(N$) Format. 


14 



o 



15 


Array P is an N x 2 numerical array used in conjunction with 
array 1(1$) for describing element inputs. The array format is de- 
scribed and illustrated in Figure 10. 

1(1$) . This is an M X 3 string array used in conjunction with 
array P to describe element input lines. Figure 11 shows the format 

of the array. Note that M is equal to the total of all element fan-in. 

\ 

Q(Q$) . This is an L X 2 string array that indicates pairs of 
cross-coupled gates. L is the number of cross-coupled gates in the 
circuit. See Figure 12 for the detailed description of this array. 

FUNCTION FILES 

Equations produced during a SIMLOG simulation run are represented 
as character strings. Each equation is stored as a separate and distinct 
record in a file. Four files are needed for storing all of the equations 
produced and are described in Table 1. Each element in a circuit is 
assigned a record number corresponding to its N(N$) array row number. 
Functions are stored in sum-of-products form with period used to indicate 
the end. 

Function file access switching is used to effect the transfer of 
functions in the NEWO and NEWl files to the OLDO and OLDl files for the 
next ripple-time step. This switching is implemented by use of a switch 
S which is initialized to the value 0. When S=0, functions computed in 
the previous ripple-time (r-1) are accessed from OLDO and OLDl. When 
S=l, functions computed in the previous ripple-time (r-1) are accessed 
from NEWO and NEWl. The value of S is complemented at the end of each 
ripple-time step. 


16 


1 


2 


1 Number of 

2 Gate Inputs 

: (Fan-in) 

N 


Input List 
Pointer to 
Array 1(1$) 


(a) General Format 


1 2 

1 3 1 

2 3 4 

3 2 7 

4 2 9 

5 2 11 

6 2 13 

7 2 15 

8 2 17 

9 2 19 


(b) Example from Figure 9 


Figure 10. Description of Array P. 


17 



1 

2 

3 

1 

Input Names 

Fault Condition 

Circuit 

2 

A 

(a) 

1 

General Format 
2 

Input Flag 
or Net Number 

3 

1 

J 

FF 

YES 

2 

CLOCK 

FF 

YES 

3 

QBAR 

FF 

9 

4 

K 

FF 

YES 

5 

CLOCK 

FF 

YES 

6 

Q 

FF 

8 

7 

A 

FF 

1 

8 

D 

FF 

4 

9 

B 

FF 

2 

10 

C 

FF 

3 

11 

CLOCK 

FF 

YES 

12 

C 

FF 

3 

13 

E 

FF 

5 

14 

0 

FF 

4 

15 

E 

FF 

5 

16 

F 

FF 

6 

17 

QBAR 

FF 

9 

18 

G 

FF 

7 

19 

Q 

FF 

8 


(b) Example from Figure 9 


Figure 11. Description of Array 1(1$) 


18 


1 

First Gate 
Output name 


2 

Second Gate 
Output Name 


(a) General Format 


1 


2 


C 0 

Q QBAR 


(b) Example from Figure 9 


Figure 12. Description of Array Q(Q$). 


19 


File Name 
OLD0 

OLDl 

NEW0 

NEWl 


TABLE 1. Data File Definitions 


File Contents 


Contains records that describe the 
0-equations produced during the previous 
ripple-time step. 


Contains records that describe the 
1 -equations produced during the previous 
ripple- time step. 


Contains records that describe the 
0-equations produced during the current 
ripple-time step. 


Contains records that describe the 
1 -equations produced during the 
current ripple-time step. 



20 


PROCESSING ARRAYS 

Functions to be processed are retrieved from the appropriate 
function file and are copied to a temporary array or its equivalent for 
input to the appropriate processing routine. Only the expression to the 
right of the equal sign is copied to the temporary structure. The out- 
put from a processing routine is placed in a like temporary structure 
prior to further processing or to storage in a function file. These 
temporary structures will now be described for each version of SIMLOG. 

A major difference in the two versions is found in this area. 

POP 11 Version 

The temporary arrays discussed above are implemented using the 
virtual array capability of BASIC-PLUS. This approach yields the 
flexibility of standard arrays without requiring a large segment of 
primary memory space for the arrays. The arrays are described below. 

F$ and G$ . These are one dimension string arrays used to hold 
expressions that are the operands for a processing routine such as the 
AND routine. Each product term of an expression is assigned to a unique 
element of an array. The period is used to indicate end-of-f unction. 
Constant expressions (0 or 1) are represented by the corresponding 
symbol in element one of the array. Functions X1=A-1+B1, Y-1=0, and 
Yl=l are represented as shown in Figures 13(a), (b), (c), respectively. 

H$ . A one dimensional string array used to store the output or 
resultant of a processing routine. H$ has the same structure as F$ and 
G$. 



(a) XI = A-1 + B1 



(b) Y-1 = 0 



(c) Y1 = 1 


Figure 13. Function Representation in Arrays 





22 


Sigma 5 Version 

Virtual arrays are not avialable with Xerox BASIC, Also, the 
implementation of the processing arrays as standard arrays is not 
feasible due to the large amount of primary memory required. Hence, 
the processing arrays are realized in the Sigma 5 version as files, 
herein referred to as processing-array files. The file names are 
FARRAY, GARRAY, and HARRAY. 

Processing-array files are easily accessed by taking advantage 
of the record I/O mode of Xerox BASIC. For example, the equivalent 
of X$=F$(Y) can be performed by a statement of the following form. 

INPUT :F;Y,X$ 

where F represents the I/O stream to which FARRAY has been opened. 

Also, G$(Y)=X$ is accomplished with 

PRINT :G;Y,X$ 

where like before G represents the I/O stream to which GARRAY has been 
opened, 

I/O STREAM (CHANNEL) ASSIGNMENTS 

Files must be opened to an I/O stream (Sigma 5 terminology) or 
I/O channel (POP 11 terminology) before they can be accessed. Assign- 
ment of channels in the POP 11 version is static since at most six 
channels of the available twelve channels are needed. On the other 
hand, the assignment in the Sigma 5 version must be dynamic since only 
four streams are available while up to eight are needed. Table 2 shows 


23 


TABLE 2 

SIMA and SIMl Channel Assignments 


Channel or Stream 


File 


24 


the assignments for subprograms SIMA and SIMl in both versions. Table 
3 shows the assignments for SIMB while Table 4 shows the assignments 
for SIM2 and RACE. Note that the latter assignment is a function of 
the file-switch S and of the function-switch J. 


25 


TABLE 3 


SIMB I/O Channel Assignments (POP 11) 


Channel 

File 

1 

OLDl ' 


2 

OLD0 , 

Function 

3 

4 

NEW0 
NEWl J 

Files 

5 

NET 

Circuit 



Description 

6 

VIR 

Virtual 



Arrays 


TABLE 4 

SIM2 and RACE I/O Stream Assignments (Sigma 5) 










4. PROGRAM DESCRIPTIONS 


Structural diagrams of the SIMLOG/TESTGN subprograms were given in 
Section 2. A more detailed description of each subprogram is given in 
this section in the form of a functional description. Flowcharts are 
included for selected routines. Additional detail is given in the an- 
notated listings found in the appendix. 

SIMl AND SIMA 

The function of these programs is to input the circuit description 
and simulation requirements and to build the database needed by SIM2 
(SIMB). The programs consist of a main routine and four subroutines. 

Main Routine 

The function of the main routine of SIMl and SIMA is to open and 
close files, to initialize parameters and arrays, to request mode 
selections, to call appropriate subroutines, and to chain to the SIM2 
and SIMB programs when all other functions have been completed. A 
flowchart of the routine is given in Figure 14. 

Keyboard Circuit-Description Subroutine 

The purpose of this subroutine is to input circuit description 
information from the keyboard and to load the N(N$), P, 1(1$), and 
Q(Q$) arrays. 


26 


27 




Print Mode 
Selection Header 


Input Mode 
Selection(M0) 


ValicT 

Mode 


Print 

Error Message 


Print Output-Mode 
Selection Header 


Input Output-Mode 
Selection (Ml ) 


Valic 

Mode 

7 


Print 

Error Message 


Print Race Analysis 
Selection Header > 


Input Race 
Analysis 
Selection(ZS) 


Figure 14. SIMl and SIMA Flowchart. 



28 



Figure 14 (con't). 









29 


Keyboard Fault-Description Subroutine 

This subroutine inputs fault descriptions from the keyboard and 
modifies the appropriate entries of the N(N$) and 1(1$) arrays. 


Keyboard Starting-State Subroutine 

This subroutine inputs starting-state information from the key- 
board and loads the starting-state description in files OLDO and OLDl 


File Circuit-Description Subroutine 

The function of this subroutine is to input circuit description 
information from the file NET (NET. DAT). 


SIM2 

The function of SIM2 is to perform the actual simulation computa 
tions for the circuit whose description has been entered in the data- 
base by SIMl. The program consists of a main routine and sixteen 
subroutines. 

Main Routine 

This routine functions to open and close files, to initialize 
parameters, to input the input-time and the ripple-time limits, to 
initialize and increment the input-time and ripple-time counters, to 
call appropriate subroutines, and to chain other subprograms. See 
Figure 15 for a flowchart. 


3 




/ Print Ripple-Time / 
Limit Entry Header / 



/ Enter Ripple-Time / 
Limit (RO) / 



Initialize Input-Time 
Variable, T=1 



Initialize Ripple-Time 
Variable, R-1 


Save Ripple-Time 
for Ripple Increment 
Computation, R1=R 



Figure 15. SIM2 Flowchart. 











31 









32 



Function-File to 
Array-File Transfer 
Subroutine(5000) 


' Yes 


Fl=l 

F2=2 


> 

f 

Fault Insertion 
Subroutine' 
(6000) 





Figure 15 (con’t). 






33 



Figure 15 (con't). 









34 



Figure 15 (con't). 











35 




Figure 15 (con't). 






36 



Figure 15 (con't.) 





37 


Function-File to Array-File Subroutine 

The purpose of this subroutine is to copy the description of a 
function from a specified file record to a specified array-file 
(FARRAY or GARRAY). During the copy process the format of the func- 
tion is changed from a single string to a list of substrings of the 

original string. Each substring is a product term of the function. 

} 

Removal of the function name is performed. 


Fault/Constant-Value Insertion Subroutine 

This subroutine performs the necessary computations to effect 
the insertion of faults or constant input -values in the circuit being 
simulated. 

Mini -AND Subroutine 

This subroutine performs the logical AND of a fault-variable 
with a fault-free function as part of the fault insertion procedure. 


Mini-OR Subroutine 

This subroutine performs the logical OR of a fault-variable and a 
fault-free function as part of the fault insertion procedure. 


OR Subroutine 


The function of this subroutine is to perform the logical OR of 
two functions. Operands are found in array-files FARRAY and GARRAY. 



38 


The resultant function is placed in array-file HARRAY, 

Term Sorting Subroutines 

This subroutine rearranges the product terms stored in HARRAY 
by alphanumeric order and by length. 

' 

Product Term Disassembly Subroutine 

A single product term (X$) is disassembled into its literal 
components by this subroutine. 

AND Subroutine 

This subroutine performs the logical AND of two functions. 

Operands must be placed in FARRAY and 6ARRAY. The resultant is placed 
in HARRAY. 

Zero Product-Term Detection Subroutine 

This subroutine detects zero product-terms that may be produced 
by an AND operation. 

Literal Sort Subroutine 

The purpose of this subroutine is to arrange the literals in a 
product term in alphanumeric order and to remove duplicate literals. 

Array-File to Function-File Subroutine 

The function of this subroutine is to assemble the list of product 
terms in array-file HARRAY into a string format and to place the re- 
sultant string in the specified record of file OLDO, OLDl , NEWO, or 



39 


NEWl . In string form, the function consists of a function name and 
time header followed by an equal sign followed by the product terms 
separated by plus signs. 

Function Set Comparison Subroutine 

This subroutine compares the functions at ripple-time r-1 to the 
corresponding functions at ripple-time r in order to determine if the 
two sets of functions are identical. 

Output Subroutine 

This subroutine outputs a header giving input-time and ripple- 
time. The header is followed by a list of function pairs for each 
net in the circuit. 

Oscillation Detection Subroutine 

This subroutine checks the increment of ripple-time change since 
the last input-time change against the ripple-time limit in order to 
identify a possible oscillation condition. 

Function Minimization Subroutine 

The purpose of this subroutine is to remove redundant terms from 
a function. Terms are redundant in this context if they are covered 
by another term. 

Input-Mode Change Subroutine 

This subroutine permits the user to change input mode from fixed 
input mode to variable input mode or vice-versa. 


40 


RACE 

The RACE subprogram performs the race analysis procedure and is 
chained from SIM2. A main-routine and four subroutines constitute 
the subprogram. The AND subroutine is the same as that used in SIM2 
and will not be described again. 

Main Routine 

This routine opens and closes files, initializes parameters, 
examines functions corresponding to cross-coupled gates, calls the 
appropriate subroutines, and chains to SIM2 when all other operations 
are complete. See Figure 16 for a flowchart. 

Name Removal Subroutine 

This subroutine removes the name field from the string form of 
a function to be examined. 

String to Matrix Subroutine 

This subroutine converts the string form of a function to a list 
of product terms. 

Matrix to String Subroutine 

This subroutine performs the inverse of the above subroutine. 


SIMB 

This subprogram combines the functions of SIMl and RACE in one pro- 
gram. No further discussion in necessary. 



Figure 16. RACE Flowchart. 












42 



Figure 16 (con't). 







43 



Figure 16 (con't). 









44 



Figure 16 (con't). 















Figure 16 (con't). 










46 



Figure 16 (con't). 















47 



Figure 16 (con't). 








48 


TESTGN 

The generation of test sequences from SIMLOG simulations is the 
function of this subprogram. It consists of a main routine and four- 
teen subroutines. Most of the subroutines are identical to ones used 

e 

in SIM2 and will not be described again. 

Main Routine 

The function of the main routine is to open and close files, to 
initialize parameters, to input the test generation mode selection, to 
construct circuit input and output lists, to select input-output pairs 
for processing by subroutines, to call appropriate subroutines, and 
to chain to SIMl. See Figure 17 for a flowchart. 

Test Function Generation Subroutine 

This subroutine generates the test function for a specified input 
net, output net, and input-time, or for a specified fault condition 
and output net. See Figure 18 for a flowchart. 

Output Function Retrieval Subroutine 

This subroutine sets switches as needed by the function-file to 
array-file subroutine for transferring the appropriate function. • 

Test Function Storage Subroutine 

Test functions are placed in a file by this subroutine after each 


is generated. 



49 



Figure 17. TESTGN Flowchart. 







50 



Figure 17 (con't). 









51 




Figure 17 (con't). 












52 



Figure 18. Test Function Computation Routine Flowchart 



















54 



Figure 18. (con't) 




55 


Output Subroutine 

A header Including the output name, the input name, and the time 
tag are printed if mode 1 is chosen. If mode 2 was chosen, the output 
name and the fault condition are printed. The corresponding test 
function is then printed. 


5. PROGRAM MODIFICATION GUIDELINES 


Suggestions for program modifications are givenin this section. 
The first subsection contains guidelines for modifying program para- 
meters that affect the size of circuit that can be handled by the pro- 
grams. The second subsection contains suggestions for changes to the 
program that should improve its performance characteristics. 

PARAMETER SETTINGS 

The size circuit that can be handled by the system is determined 
by several parame^ters that will now be discussed. Dimensions of arrays 
N(N$), P, 1(1$), and Q(Q$) directly influence the maximum circuit size 
that can be handled. 

The number of rows in arrays N(N$) and P must equal or exceed the 
number of circuit elements (a D flip-flop counts as two elements). The 
number of rows in array 1(1$) must equal or exceed the total number of 
element inputs in the circuit. Therefore, the number of rows in 1(1$) 

must be at least double the number of rows in N(N$) or P. Array Q(Q$) 

/ 

must have at least as many rows as there are cross-coupled gate pairs. 

A Q(Q$) array with one fourth the number of rows as array N(N$) is 
recommended . 

Parameter H9 is used as a FOR-NEXT loop limit and should be set 
equal to or greater than the number of rows in 1(1$). In the Sigma 5 
version, parameter Y5 sets the maximum number of product terms that 
can be contained in a function. 


56 


57 


SUGGESTIONS FOR IMPROVEMENT 

Significant improvements in performance (speed) and memory re- 
quirements could be achieved if the programs were rewritten in a 
language that could be compiled into machine code. Another possibility 
is to develop a BASIC compiler for the Sigma 5. Such a compiler is now 
available on some POP 11 installations. 

Modifications to the existing code can also be effective in pro- 
viding substantial improvements. One such possibility is to develop 
a uniform internal code for representing nets and inputs. Such a code 
would improve performance and memory requirements. This feature would 
also permit a more flexible net labeling scheme. Addition of such a 
feature would require translation routines to map the user selected 
net labels to the internal code and vice-versa. A symbol table would 
also be required. 

Another desirable modification is to improve the function minimiza- 
tion routine so that a more extensive minimization is performed. 
Recognition of terms of the form X + X- is the most needed improvement 
in this regard. 


6. REFERENCES 


1. B. D. Carroll, "Test Pattern Generation," Final Report-Vol . 2, 
NAS8-31572, Electrical Engineering Department, Auburn University, 
Auburn, Alabama, September 14, 1979. 

2. B. D. Carroll, "SIMLOG/TESTGN User's Guide," Final Report-Vol. 2, 
Addendum 1, NAS8-31572, Electrical Engineering Department, Auburn 
University, Auburn, Alabama, September 14, 1979. 


58 


APPENDIX 


SIMLOG/TESTGN 
ANNOTATED LISTINGS 
SIGMA 5 VERSION 


59 



60 


10: 10 OCT ll»-79 DC/ST’-^Ii.OC.OCARkOL L 


1 * 

S3SS3 

III 

-.1 y 

LL 

00000 

ggggg 

a* 

S 

1 

jV> I ^ iV* N» 

L 

0 

0 

G 

3* . 

SSSS5 

T 

K V 

L 

0 

U 

G GG 

a* 

S 

I 


L 

0 

0 

G l» 

b* 

SSSSS 

III 

K* \A 

LLLLL 

OOUOO 

GGGGG 


STfncoc 
SIG-^A 5 
OPIGIMAL 
1 0/IU/7V 
e. 0. CARROLL 


b* 

7* PKOGRA'^’: STfncoc 

{j* V VERSIO^J! SIG^a S 

9* revision: opigimal 

10 *. i;ate: io/lu/79 

11*1 PRuGSA'i^'iER: e. 0. CARROLL 

If?* 

15k************************************************************ 

1 «*. 

IS*^ COMRACT SUPPUkT 

lb *1* *********************************************************** 

17* 

18* THIS PROGRAM /vAS DEVELOPED FOR A'ASA MARSHALL FLIGHI 

19*. CEMEH U.NiDER CUMTRACT NAS8-31b7<>. 

«? 0 * 

f?l************************************************************* 

<?P* 

‘MODIFICATION HISTORY 

^U* 

^b************************************************************* 

«?b* 

59 * 

ll^O************************************************************ 

1 0 1 * 

10^* PROGRAM oesCRlPTIUO 

10 5* 

109 ************************************************************ 

1 Ob* 

lOo* vSI<^LuG IS A PR'JGkA.'* FOR SIMULATlf-iG LOGIC CIRCUITS, 

10/* BOTH CO'-gnATinNiAl. AGD SEDOEMIAL CIRCUITS TAM PE 

lOH* SinjLATED. CIRCUITS CAn HE SIMmLATED FAULT-FREE DR 

109* -.ITH SI'MGLE or ^iiltipLE STUCK TYPE FAULTS. 

no* L"G1C ELE'-'E^'TS ACCUt-MODAIED rtY THE SIMULATOR ARE 

111* \A!mD GATES, NOn GATES, AMD DELAY ELEMENTS. 

ll^* other ELE-’r'iT TYPES SOCm AS 0 FLIP-FLOPS / ILL 6E ADDED. 


************ 


************ 


1 Oo * 
10 / * 
1(>H* 
109* 
110* 
I I I * 
1 1^* 
1 1 5* 
I 1 a* 
Ub* 
1 lo* 
11/* 
I 1,0* 
119* 
I £?0 * 
IPl * 
!?<?* 


T.\0 VE^<SIO‘'jS of SImlOG havF. bEE-'J v'/RlTTEM, 

O'lE VFRSin-'i HAS HE El ...R IT TED IN SASIC-PLUS FOR 
EXtCUTlON U'l A Pi;Pll/yi) hSTS/E SYSTE'/', 

AWOTHER VERSION HAS HFEM ^KITTEN' TG XFROX BASIC 
FOR ExECuTIQ'i ON A SIGMA b CPV SYSTEM, 

THE PDP|l/ao vERSIU-i IS PAkTITIDMEU I.jTO Ti^U 
SUHPftOGRA'.'S, Sr-IA AMD SIMM. THIS PARTITIONING ■ 
mcCESSArT due TO TnE LARGF f'ERURY REUUIkEMENTS 1 


( 


THE P^n&R'AM. ■ VIRTUAL AWKATS ARE USED FU« ALL LARGE 
ARRAY STORAGE. 

THE SIG^'A S VERSION IS PARTITIONED INTO THREE 
SUBPROGRAVs, SI»'n, SI^‘2» INO RACE. THIS DEGREE OE 
partitioning .nAS NECESSAkY SINCE VIRTUAL ARRAYS ARE 
not AvAILAHLE on the SIGMA 5, ' 

THE' Function of'simi is to input all data needed 
concerning circuit description# fault description# 
INITIAL CONDI TIOnS# AND' simulation' MODES, ■ 

THE 'FUNCTION 'OF 'SIM2 T"S TOT PERFORM THE ACTUAL 
SIMULATION COMPUTATIONS MTH THE EXCEPTION OF 
■RACE''ANALYSTS AND ■ TO' OUTPUT THE' SIMULA T ION RESULTS. 

THt~FUNCTION“OF' RAC'E~ IS TO PERFORM THE RACE ' 
ANALYSIS computations. 


1>0' CHANNEL'S 


channel 


USAGE 


file of 'OLO'ONE-FUNCTIONS 
FILE' OF— 0CD“ZERO-FUNCT IONS 
CIRCUIT'DESCRIPTION FILE 


variable DEFINITIONS 


variable 


DF.FIMTION 


AN INPUT variable USED FOR THE STARTInG-STATE 
'MODE NUMBER. ' ' ■ 

"AN ' InPTjT' VARIABLE used FOR A'SUBMODE NUMBER ' 
DURING THE starting-state INPUT. 


A STRING VARIABLE USED AS A TEMPORARY VARIABLE 


aifl> 

419* 


420* 

421* 

C5 

"422*“ 


423* 

h9 

■ 424* 
425* 


426* 


427* 

I 

'428<f 

429* 


430* 

451* 

432* 

433* 

434* 

435* 


44 0* 
441* 

- ■ 10 

442* 

443* 

445* 


4b 0* 
451* 
452* 

11 

"460* 

461* 

462* 

L 

470* 

471* 

472* 

MO 

480* 

48H 

482* 

483*^ 

Ml 

490 

491 * 

N 

492* 
49 5* 


494* 

495* 


496*' 

497*' 


498*‘ 

499*' 


510*' 
51 1 

Nr 

512* 

513* 


514* 

515*‘ 



62 

AND AS A(j input variable. 

A string vapiablf used as a tfmporary variable 

AND AS an input variable, 

indicates the upper unit of the loop variable 

OE' SQ'^t FPR-NEXT LOOPS, SHOULD BE SET >= THE 
number of ROk'.S IN the I ARRAY. 

A T«0 DIMENSIONAL li^PLICIT STRING ARRAY USED TO 
STORE CIRCUIT ELEMENT INPUT LISTS. EACH ROvN OF 
THE ARRAY DESCRIBES ONE INPUT VARIABLE OF ONE 
element of the circuit being DESCRIBED. THE 
variable , NAME IS GIVEN IN COLUMN ONE. ANY FAULT 
CONDITION ASSOCIATED i^ilTH THE INPUT IS 
GIVEN IN CULiJMN Ti«.0. THE THIRD COLUMN INDICATES 
!aH£THER oh not the INPUT IS A PRIMARY INPUT, 

A POINTFR to The next ROa of the I ARRAY TO BE 
LUAOED DUPING INPUT OF THE CIRCUIT DESCRIPTION, 

THE FINAL VALUE OF 10 INDICATES THf fJUMBER OF 
ROWS OF ARRAY I THAT ARE USED. 

A pointer to the NEXT FILE RECORD TO HE ACCESSED, 
USED IN SUBP 2000 WHEN LOADING THE NET FILE. 

REPRESENTS THE LENGTH OF A STRING, VALUE IS 
ESfABLISHEO BY THE LEN FUNCTION, 

SIMULATION MODE INPUT VARIABLE, 

LOADED In MAIN PROGRAM, 

OUTPUT-MODE INPUT VARIABLE. LOADED IN MAIN PROG, 
•ilsl: PRINT all equation SETS. 

PRINT STABLE EOUATICN SETS ONLY, 

A Tr'O DIMENSIONAL IMPLICIT STRING ARRAY USED TO 
STORE THE element DESCRIPTIONS AND INTERCONNECTIONS 
OF A CIRCUIT. EACH ROW OF THE ARRAY CORRESPONDS TO 
ONE ELEMENT OF THE CIRLUIT, COLUMN ONE CONTAINS 
THE ELEMENT OUTPUT NAME, COLUMN T'/JQ IS THE ELEMEAfT 
TYPE. COLUMN THREE INDICATFS THE FAULT CONDITION 
OF THE' ELEMFNT OUTPUT, COLUMN FOUR INDICATES 
/WHETHER OR MOT THE ELEMENT OUTPUT IS A PRIMARY 
OUTPUT OF THE CIRCUIT, 

A POINTER TO the N AND P ARPAYS, DURING InPUT OF 
THE CIkCUIT description, M INDICATES THE NEXT ROW 
OF THE ARRAYS TO BE LOADED. 

AFTER CIRLUIT ENTRY IS CUMF’LETE, N1 INDICATES THE 

number of rows loaded in n and P. 


“ 520 *" P- 

S21* 

S2Z* 

b23* 

- 52 Q* 

S25* 
b2'6* ■ 

527* 


sao*' ■ ■ pr "A TE-'^POHAPY "variable used to hepresent the IHPUT 

5ai* list length of an element during input of faults, 

'5a 2* 

5^0* P^ A TJMPORAPY variable USED TO REPRESENT THE POINTER 

551* fO AN'"£LEfVENT INPUT' VARIABLE LIST DURING FAULT" INPUT, 

552* 

"56o> '■ "13 “r'rwxr'Dr^'iETjsiuNAL i^iplicit string array used~to 

561* STORE pairs OF ELEMENT NAMES THAT ARE CROSS 

562* "COUPLED IN THE CIRCUIT, EACH RO"w CORRESPONDS"" TO 

563* A CROSS-COUPLED PAIR, THE NAME OF ONE ELEMENT OF 

564* ' " THE "P'AIR IS stored" IN COLUMN "ONE" AND" THE 'NAME' qF 

565* THE OTHER ELEMENT IS STOKED IN COLUMN THO, 

56o* ' ' ' " ' 

^ POINTER TO THE Q ARRAY, DURING CIRCUIT ENTRY, Ql 
"571*" ' ■ REPRE'S£"!^TS TK£“NtXT'ROvv OF' ui TO ftF LOADED, THE FINAL 

572* __ number of wows USED IN 0, 

5H0* K9 A SWITCH INDICATING WHETHER OR NOT RACE ANALYSIS 

5v"AS~SEI:ECTED; — RP- sOr was SEtECTEDIOEFAULT VALUE). 

582* R9=l: NOT SELECTED. 

5B3* ■ ■ 

590* S A SwITLH INDICATING WHICH CHANNEL TO USE WHEN 

-59'1* ACCE'S'SING 'FUNCTIuM FILES, 

592* 

■60(T* '“Vl,V2 TFMPORARY-'yTS'RrA’BtrES' USED TO' REPRE SENT " THE" NUMERIC 

601* 9f CROSS-COUPLED ELEMENTS. 

602*"" - - - - - . 

610* Vi A TEMPORARY VARIABLE USED TO COUNT THE NUMBER OF 

'6TT* ^character's’Tn a"'subs thing, 

612* 

b2TJ* A' TEMPORARY" VARIABLE "USED AS A SVnITCH INDICATING 

621* WHETHER OP NOT A MATCH wAS FOUND DURING STARTING 

622*' ' state"“e:ntky.' - ---- 

623* 

"630* "X USE"0 AS "A POINTER "TO "CHARACTERS IN 2i DURING THE 

651* PARSING OF ZS, IN ANOTHER CASE, IS USED TO 

6I2V PFDTCA'TE >HrCH“FUNCTrON~ FILES ARE TO 'BE "LOADED. ' “ ' 

633* X=l: load ONE-FNS. X=2; LOAD ZERO-FNS. 



640* xi. A TEMPuRAKY VARIABLE USED STORE A FUNCTION NAME, 

wr*"" r^~ATM(nHEP'"APRClCATrON,“"USED IO'STORE'U or 1' “ ' 

642* FUNCTION VALUES. 

-6'in* 

650* 


63 

A' TwO""'DIMEN'SlONAL NUMERIC 'ARRAY USED TO STORE' 
POINTERS TO THE INPUT LISTS STORED IN ARRAY I. 
RU'.VruF P CORRFSPONOS TO'THE ELEMENT DESCRIBED 
I-J Row l OF ARRAY N. COLUMN ONE OF P CONTAINS THE 
number 0F'"InPDTS"'7 0 TH£ ELEMENT WHILE COLUMN TWO 
CONTAINS THE POINTER TO THE ELEMENT INPUT VARIABLE 
list stored in array 1, " 


XI 


USED AS AM INDEX variable IN FOR-NEXT LOOPS, 



IfM -fltMOTHEP floPLICATIGN, USED AS A POINTER TO 
A FU.vCTIUN PECUWO. 

USfcO AS an Ii'jOEX VAKlAdLE IN FOH-MEXT LOOPS, 

A parameter representing the MAxpnjM number of 

TERM’S THAT CAN BE STORED IN THE FUNCTION FILE OF “ 
EACH FUNCTION. 

A TEMPORARY VARIABLE USED TO REPRESENT PRODUCT TERMS 
■DURING THE PARSING OF A USER ENTERED STARTING STATE 
FUNCTION. I\( ANOTHER APPLICATION/ USED TO STORE 
0 OR 1 FUNCTION VALUES. 

USED AS -A COUNTER OF THE NUMBER OF INPUTS OF AN 
ELEMENT DURING CIRCUIT ENTRY. 

A TEMPORARY VARIABLE USED AS A STRING INPUT VAR, 


SUBROUTINE DESCRIPTIONS 


PROGRAMMER DEFINED SUBROUTINES 


LINE 


OtSCPIPTIOM 


Inputs circuit description from keyboard 


3000 


Inputs fault description from keyboard 


aooo 


inputs starting state conditions FROM KB 


inputs circuit description from file 


DIMENSION STATEMENTS 


DIM NC^nO/a), 1 (400/3)/ U(50/d)/ Plt?00/2) 


1001 
"1 0 (T2 * 
1003* 
1004* 
1005*. 
1006 *' 
1 007* 


START OF MAIN PROGRAM 


65 


1000* 








1050 OPFN "OLJl" 

TO 

:lf INPUT 

UPCATE\*OPEM 

FILE 

FOR 

OLD 

ONE-FNS. 

1060" OPf.M" "OLDO" 

To 

:2# Input 

'UPOATEN*OPEn 

FILE 

FOR 

OLD 

ZEH0-FT4S. 

1070 OPEN "MET" 

TO : 

i, INPUT 

UPDATE \*OPEN 

F ILE 

FOR 

net 

DESCRIPTION 

TlOO H9sa00'\ 


***SEf 

LOOP LIMIT' PARAME 

TER, 




1105 YS=100\_ LIMIT ON tt oF TERMS IM FUMCTIOi'IS. 

1120 S=0\ ***IN"ITI ALIZE FUNCTION FILE SWITCH, 

1125 lNRUr = 'b\ ***StT SkQUENTIAL FILE ACCESS MODE, 

“ll2<)«r(k*i*PfilNT"3IMULATI0w'Mr0E SELECTION HEADER. ********★*<►***** 
UiO PRINI-SELECT SIMULAHQN moOE. "<CR> = 1," 
lI55'>RrMr'' (IT NEW CIRCUIT" ' ' 

1140 PRINT" (2) NE'a_FAULT" 

I 1 4 5'" P R H'H " ■( 3 ) ~^^E 'V S'T A H T I N G S T A T £ • ' ~ 

1150 PRINT" (4) CIRCUIT DESCRIPTION UN FILE" 

1 l55'~lNPUr"M0V ■ ■ ***ENrER"MOOE NUMdER'FfiUM KB, 

1160 IF M0<-4 THEM 1175\ ***£HECK FUR VALID MODE wUMHER, 

1 164*****PRINT 'ERROR-MESSAGE IF INVALID "moUE NUMBER ENTERED, 

1165 PRINT"InVALID_CHOICE. MAJ<E ANOTHER SELECTION," 

11/0 ***REPEAT F'OR new entry, \ GOTO 1155 - - 

11 74*****PRIi'iT OUTPUT MODE SELECTION HEADER. ***** 

1 175" PR1nT"SECECT Of-TPur MOUE'.""<CR>=r, " - 

1100 PRINT" _ (1) PRINT STABLE EOUATION SETS ONLY" 

naS'PRl'NT""' (2)' PRINT "ALL"EUUATI0N SETS"' 

1140 INPUT Mi\ ***EfaER OUTPUT MODE NUMBER, 

1195' IF-Mi<=a then 1210\**CHECK FOR vALII) MuDE NUMBER, 

1 199*****PR INT ERROR-MESSAGE IF INVALID NUMBER ENTERED,***** 
T?'0(rPR7NT"Ii^lTAi:T0 CiT 0 'Icr;''' 1 ^AR:r~AN 0 THER''SECECTI 0 N," “ 

1205 ***RePEAT FOR NEXT ENTRY. \GOTO 1190 
I209**Vi*PRINT” RACE ANALYSIS'SELECTION HEADER,***** 

1210 PR1NT"RAC£ ANALYSIS(YES OR NOJ. <CR>=YES,"; 

1215"INPUT'2SV " ***ENTER RACE-ANALYSIS SELECTION. : , 

1220 IF Z'5 = "YES" TrtEN 124U\*CHECK FOR YES ENTRY. 

1225 ~IF 7S = "“'"' THErvprZTON r**CHECK'-FOR'DEFAULT YES, 

1230 R9=l\ ***SET SWITCH FOR NO RACE ANALYSIS, 

1235 *"**3K IP "ALTERNATIVE 'Sw ITCH "SETT I NG, \GOT0 ' I 245 
1240 R9=0\ ***SET SWITCH FOR RACE ANALYSIS. 

r244V****8RANCH"T0 PRfJPER'lNl H ALIZ4T ION ROUTINE.***** 

1245 ON MO GOTO 1 250 , 1 350 , 1 355 r 1 250 

1250"MAT'P= ‘TER\ ***CLEAR'THE INPUT POINTER ARRAY, 

1255 FOR Xsl ru H9/2\ ***LLEAR THE ELEMENT ARRAY. 

I2b0 FnR"? = r TITT - 

1265 N(X,Y)="" 

£27 0 next Y ■" 

1275 next X 

l280~^0R"'X=l~^O"H9^ ■***CLE'AR"THE 'rNPUT LIST ARRAY," " " “ , 
1285 FOR Y=l TO 3 

1290 ■ ' ' “r('x,'Y)="" ■' ' 

1295_ ^ _____ __ 

n'oo"~NExr'x 

1305 FOR xsl TO H4/a\ ***CLEAR XC ELEMENT ARRAY. 

rrro FUfTTri* ro"^ ■ - - - 

1315 U(X,YJS"" 


66 


1520 “■ “fiEXT / 

15215 NEXT X 

1530 IF M0<>« THEN l3i»5\***CHECK FOR MOOE 4*** 
l33b***IF N<OL»E 4 GET CIRCUIT FROM F ILfe *** XG0SU8 60D0 
t3t»0***SKTP"Ke ENTRY SuBR***\GOTQ 1350 
1345***CALL kb entry SU0R*o*\GU 3UH 2000 
~l350**iCTO~FAULT ENTRY' bUBK\GOSUH 3000 ' 

135b***CALL CIRCUIT INI T I ALI ZATIUM SU8H***\G0SUH 4000 
■ I3^(T FOR X=1 TO IO\***PRINT CONTEivTS OF I ARRAY. 

1365 PRINT I(X,1),I(X,2),I(X,3) 

~Txro NrxT“x 

1575 CLOSE :l\***CLOSE OLD ONE FUNCTION FlLfc,*<k* 

1380 CLOSE' :2\***CL0SE~0L0 7ER0 function FILE*** 

1385 CLOSE :3\***CL0SE CIRCUIT DESC FILE*** 

1390 C06l 

1395 ***TRANSFER TO PROGRAM SIM2,\CHAIN LIwK "SIM2" 

2000*********** ****** A* ****««4 A «k********tk *«*«**«* ************** ******* 
2001 ****************************************************************** 

~2002* SUBROUTINES" . ^ 

2005************************ **************** ************************** 
2000 ****************************************************************** 
2005* SUHROUTINE to F.-mTER circuit DESCRIPTION FROM KEYBOARD * 

20 06 ****************************************************************** 
2000 Il=l\ ***INITIALIZE file RECORD PUINTER*** 

^009***PR1NT ELEMENT ENTRY HEADER MESSAGE**** ******************* 

2010 PRINT"ENTER— ELEMENT imAme, TYPE, AND InPUT LIST," 

2015 P»lNT*StPARATE' entries InTTH A SPACE." 

20ia RRINT’*ENrER<CR>TO TERMINATE ENTRY. - 
■20l5'I0sl\ ■ — ■ ' ***INITIALIZE I ARRAY POINTER, 

aOl’7 NlaO\ ***INITIAL IZE POINTER TO M AND P ARRAYS, 

2020 ***CLEAH Z'S. 

2022 INPUT Z»\ ***EMER ELEMENT OESCRIPTIOim FROM Kb, 

2023 PRINT :3jIl,Z$\ ***PLACE ELEMENT DESCRIPTION IN FILE, 

202'J IlsIlflN ***INC FILE RECORD POINTER. 

2026 IF ZJs" " THEN 2430\*LOOK FOR END OF ENTRIES. 

2050 NISN1*1\ ***INC N ARRAY POINTER, 

2034***** BEGIN PARSING” OF ZS ************************************ 

2035 ***CLEAK B?,*** 

2040 XslV" fc**IT ITIALIZE POINTER TU ZS.*** 

2050 IF ZS(:X,1) = " ’’ ThEig 2090\*£ND OF ELEMENT NAME FIELD?*** 
2060 "H$sBS+ZS(IX, 1 )\ ■ ***IF END NOT REACHED, BUILD NAME IN 8$,*** 

2070 XSX+IN ***INC POINTER TU Zi . 

~208rO"***REPFAT FOR"NFXT' character, \GOTO 2050 
2090 N(Nl,l)=8$\ ***PLACE NAME IN ARRAY rtHEN COMPLETE, 

2100 N(NI ,a)S"NO"\ ***LABEL El EMENT AS NO PRIMARY OUTPUT, 

2110 HJs""\ ***CLEAR 0S FOR NEXT FIELD, 

"2r^0^ Xs)f4-I\ “***INC POINTER TO ZS, 

2130 IF ZSi:X,n=" - Then 2170\*£ND OF ELEMENT-TYPE FIELD? 

2140 HS=BS*ZSCX, 1 )\” ***IF-rNO NOT REACHED, BUILD NAME IN Bi, 

2150 xsx*l\ ***INC POINTER TO ZS, 

'2160 ***REPEAT FOR NEXT CHARACTER IN Zi,\GOTO 2130 
2170 N(Nl,2)=BS\ ***PLACE TYPE IN ARRAY WHEN COMPLETE. 



r?l 71 "IF H3>o"0FF'^' THEivJ 2l7b\»CHeCK F0»< DFF ELt.ME.Mr ENTkY, 

PRI\iT"OFF SP-^JLAriOM RfiUTIME MOT YET IMPLEMENTED." 

I 2173 STOP ■ ■ 

2176 Z = l^ _\*IimITIALIZE COUNT OF ELEMENT INPUTS, 

2177 P(Nl,2) = I0\ ***PLACE" IfJPUT' LIST POINTER IN P ARRAY, 

2iao X = Xfl\ __ _***INC POINTER TO 1 %, 

21R0 6$=""\ ' ViiCLEAR'a^ FOR NEXT FIELD. 

22J0 IF ZT>(:X,n = " " THEN 2250\*ENU OF ELEMENT-INPUT SUBFIELD? 

2'210 b$ = ti1> + Zi»(:X,l)\ ■***£nU NOT REACHED# bUILO NAME, 

2230 X = Xfl\ ***INC_ POINTER TO Zi. 

22ad ***REPEAI FOR NEXT CHARACTER IN Zi».\6UT0 2200 

22J50_I (jO# n=8S\ __ ***INPUT NAME COMPLETE. PLACE IN ARRAY I, 

"2260 Z = Z>'1\ "■ ■■***IF'C INPUT COUNT, 

2270 I0 = I0-Yl\ ***IMC I array POINTER, 

"228u' L slEN(Z5)\’ " ' "***C0MPUTE' length OF Zi. 

2285 IF X<L Then 2160\ ***L00K FUR END UF Z», 

"2290 PfNl,l)=Z-'l\ "■ "**WENO reached; LOAD INPUT COUNT IN P. 

2300 ***REPEAT FOR_N^XT JLEM£NT I^NTRY . \bO.TO 2020, 

2a30“F0R 'Xsr f 0""I0-1 \ ***ASSIGN NUMERIC "CODE TO ALL 
2«31 FOR Tf = l TU M\ ***ELEMENT INPUTS EXCEPT PRIMARY INPUTS. 
2032 IF' ICX', lT<>T7(Yrn' THEN 2U36 

2U33 Zi=STR(Y) 

243a- '""Kx#3)=ZS ~ - 

2aS5 GOTO 2^37 

'2436' " "NEXT Y ~ ■ 

243/ NEXT X 

2439***'T* PRINT PRIMARY~rNPDr NAFE'ENTPY "HEADER." **************** 
2440 PR1NT"ENT£R PRIMARY INPUT LINE NAMES. TERMINATE rtITH<CR>," 
’■2442“IO = rO-f\ ■ ~ ***CUMPUTE NUMHER OF" rows Ifi I ARRAY, 

2445 INPUT Zi>\ *<ixENTER PRIMARY INPUT NAME FROM KB. 

'2446'"PRI.\iT r3;ir,Z$V ■ ■ ***PLACE~ input name IN FILE. 

244/ 11=I1+1\ *»*INC FILE RECORD POINTER, 

2"a49" ir'Zi = " """THEN '2a6‘5\*L'naK“FaR~END OF" INPUT" NAME ENTRY. 

2450 FOR X=1 TO I0\ _ ***SCAN lARHAY FOR PRIMARY INPUT NAMES. 

2455 IF" Zi^<>l (X,l ) ~ThEN~2460" ■" 

2457 I (-X»3) = " Y_ES"\ » *»FL AG NiTH YES AHEN JFOUND, 

24 60 ‘"nE XT'" X" ' ' 

2462 *xxREPEAT FQR NEXT INPliT-NAME ENTRY. \GUTO 244b 
2464V**** ■pRINT”PRIMARY-r;UTPUr NAME “ENTRY HEADER. **************** 
2465 PRINT"ENTER PRIMARY OUTPUT LINE NAMES, TERMINATE Y;ITH<CR>," 
24"b7 lNPCir“Z3\ "***ENTFR PRIMARY-OUTPUT NAME FROM KB, 

2468 PRINT ;3:Il,Zi\ ***PLACE NAME IN FILE, 

“24o9~rr=n + f'v ***TNC rii:E"R£i:ORD"POINTER, 

2471 IF ZJs" " THEi'j 2500\*LnOK FOR END OF OUTPUT NAME ENTRIES. 

2472~RlR“X=l"*rU nTV WTSSrSN-FTARRAYTOR PRIMARY OUTPUT NAMES. 

24/5 IF Z^oNTX#!) THEN 2480 

2'47/' ■* NfXT4)"s"‘YE'S"”*x*FCAG"'iS!nH "YES" VhEN FOUND, 

2480 NEXT X 

•2"u 8'SVi * * il? E P E AT~rn R^l^EV T“0 UTP 0 A M E ""E N r k Y , \ G 0 T 0~ 2 4 6 7 

2499***** PRINT CROSS-COUPLFD ELEMENTS ENTRY HEADER. ************* 

‘Zb'o o^PRTNr^EN r E R=-c ?TD"3"S'=^aprEir‘Ei:E>"'eNr"P a i r s , ' separate ^4AMEs"‘■ " 

2501 PKlNT'ViITH A SPACE. ENTER<CR> TO TERMINATE," 



68 


2S05 
8S10 
2bl2 
2b 1 a 
2521 
25 30 
25^0 
2550 
2560 
25 70 
2580 
2590 

2640 

2641 
2643 

2645 

2646 
2680 
2681 
2682 
2685 
268o 
2690* 
2/00 
2710 


Q1 = 0V - - ***irjITIALIZE POINTEP TO Q APRAY, 

INPUT Zl)\ ***fNTEH CWOSS-CUUPLtD I'lAMES FRUM Kb. 

PRINT ;i;Il,Z3\ ***Pl.ACE name pair in file. 

I1 = IH-1N ***lK-C POINTER TO FILE RttORO. 

IF Z5=" " then 2700\*LOGK FOR END OF ENTRIES. 


Gl=UlflN 

L=LEM(Z5J\ 

FUR X=l TO L\ 

‘IF ZJC:X,1) = " 
next X 

B$=z?(:i;x-n\ - 

C$=Z*(J x + i J\ 

FOR- XI = 1 TO Nl\ 
IF HlSN(Xl,l) 
NEXT XI 
Zi=STR(xn\ 

Q(N1 , 1 )=Z$\ 

FOR Xl=l TO Ml\ 
IF CI=NlXl,iy 
NEXT XI 
Z$ = STR(X1 )\ 

U(Q1 »2)=Zi\ 


***INC y ARRAY POINTER. 

***CONPUTE LENGTH OF 24. 

***bEGIM parse of ZS, 

" THEN 2580\*LOOK FOR END OF FIRST NAME. 

***LET B4= FIRST NAME. 

***LET CisSECONO NAME. 

■***SCAN N ARRAY FOR NAME IM PAIR. 

THEN 2645 

***CONVERT RO* NUMBER WHERE FOUND TO STRING, 
***LUA0 STRING IN 0 ARRAY, 

***SCAN N ARRAY FOR SECOND NA^E IN PAIR, 

THEN 2685 


- ***CONVERT ROW NUMBER WHERE FOUND TO STRING, 

***PLArE ROW number string in q array. 

**** REPEAT FOR NEXT PAIR ENTRY, \GOTO 2510 

PRINT :3;I1»",''\ ***PLACE END OF DATA MARK IN FILE. 

RETURNN ***RFTURN TO MAIN PROGRAM ( 1 350 ) . 


5001* 


SUBROUTINE TO INPUT FAULT DESCRIPTION FROM KB, 


3010 FOR X=1 TO Nl\ 
5020 N(X,3)="FF" 


**INITIALIZF. ALL ELEMEtJT OUTPUTS AS FAULT FREE, 


5050 NEXT X 

5040 FOR X=1 TU I0\ * ** I N I T I AL 1 2E ALL INPUTS AS FAULT FREE. 

3050 I(X,2) = "FF'* ~ 

5060 NEXT X 

3069***** PRINT FAULT SIMULATION MODE SELECTION HEADER. 

5070 PR1NT"FAULT SIMULA T ION ( YES/NU) . <LR>=NU."; 

3072 INPUT Z4\ ***£NTER SELECTION, 

3074 IF Zb="YES" THEN 3076\*L0UK FUR YES ENTRY, 

3075***IF FAULT SIMULATION \'0 SELECTED, RETURN, \GOTO 3500 
3076 PRINr"S£L£C7 FAULT CLASS UR ENTER <CR> TO TERMINATE." 
3077*****PRINT fault-class SELECTION HEADER. 

5080 PRINT" (1) OUTPUT FAULT" 

3001 PRINT" (2)~PRIMARY INPUT FAULT" 

3082 PRINT" (5) ELEMENT INPUT FAULT" 

5083 PRTNT"FAULT CLASS"; 

5084 input 7i\ ***EMTER FAULT-CLASS SELECTION. 

■5085“*****TFANSFER' TO ROUTINE FOR CLASS SELECTED, 

508«) IF Z4 = " " then 35U0\*L00K FOR TERMINATION OF ENTRIES, 
308r IF Z5 = "I"~THEN -51 00 ' 

3088 IF Z5="2" THEw 320U 
'3089 IF Z4="3" then 3340 

3090 PRlNf'INVAL ID CHOICE. MAKE ANOTHER SELEtTION,"; 


1 

1 


'I 


i 


I 


“1 


69 

i09l***** P-^I.vr “h«wnP-''<eSSAGE if I'.VALIO yoot NUN.t3ER Ef'JTERfiD. ******* 
i09U* ****RE TUWig FUrt MEPtAT E NTRY, NGHTO 30fcU 
' 3099* * * I [\i T m£A 0H9 RE'lL'tSTIfiG nuTPUT'NAMt ENTRY, ********** 

3100 prinT'entew line na'^e or <cr> to iewmiimate entries."; 

■SnO"PRl>v;T'’Ll''iE NAME”; 

311b INPUT Z.b\ ***trTER LINE MAmE, 

3121 IE‘Zi=" ”■ THEN 30H3\*LU0K KIR ENO'OF ENTRIES. 

3124***** PRINT FAULT COMUITION ENTRY HEADER. ****** 

3125 PkInT”EnTER fault C0'''D J T IONS” ; 
iliO PR1NT"S0/S1" ; 

'3135 Input ‘***ENTER FAULT-CONDITION. ' ' 

3140 FOR x=l TU Ml\ ***SCAH N ARRAY EQR FAULTED LINE. 

”3150 IF 23<>nTx, 1 )■ THEN 3170”' 

3190 N(X,3)=B$\ ***FLAG ELFNENT WITH FAULT CONDITION, 

3170 NEXT'X 

318U***HEPEAT for entry OF NEXT LINE-NAME TU BE FAUL TED, \GOTO 3110 
3199***‘PRINT header REQUF.STI*“G ENTRY OF PRIN'ARY INPUT NAME,********* 
3200 PRINT"ENTER LINE NAME OR <CR>_ TO TERMINATE. " ; 

3220 PR1NT"LINE NAME" ; ■ 

322b Input zt\ ***ENTER primary input name, 

3241' IF Zi'="“ " THEN' 3085\*LOOR FOH 'END”UF EUlRIES. 

5<fa9***PRINT HEADER REQUESTING ENTRY OF FAuL T-COuD I T I CNS. 

32b0" PKI''iT"ENTER FAULT CCNOITIONS"; 

3260 _PR1NT”S0/S1 " ; 

■ 326b INPUT 0i\ ***FnTER F AUL T-C UnD I T I uN. 

5270 FOR X=1 TU I0\ ***SCAN 1 ARRAY FOR LINE TO BE FAULTED. 

1280 — IF ZS<>lTX/n THEN 3300' ----- - 

3290 HX,2j=B$\ ***FLAG wITH F AULT-CUND I T ION WHEN FOUND, 

”3300 next X " ~ 

330b GUTO 3220 

3339***'PRInT "HFAOEW REQUESTING ELEMENT INPUT NAME TU BE FAULTFU,**** 
3340 PR1NT"ENTEH element INPUT NAME OR <CR> TO TERMINATE."; 

3350 PR1NT"INPUT NAME";'" ------ . - 

3351 INPUT Zi\ ***ENTER INPUT LINE NAMf, 

3356 I r Z THEN ”3083\*REPEAT FOR NEw FAULT CLASS. 

33b9*PRINT HEADER REQUESTING OUTPUT NAMR OF ELEMENT WITH FAULTED INPUT, 
3360 PRInT"ELEMENT - 

5370 PRINT"OUTPUT NAME"; 

3375 INPUr B5\”“ ' ~***EHTER ELEMENT OUTPUT NAME. 

3379***PRINT message REQUESTING FAULT LONOITICN ENTRY. ********** 

“33'8(1 PH I ;4r”FAuLT "CONDITIONS"; " ” 

338b PRlf'lT"SO/Sl " ; 

‘"3'3 90 TNPUT 'CJ’v ■■ ”**'’*ENTEk 'F AULT' CONDI T ION. 

340U FO*^ X=l TG Nl\ ***SCAN N ARRAY FOR INv/QLVEO ELEMENT, 

3'410 IF”Br=Tr(Y7fT~THEfr3a30 ----- ... - 

3420 NEXT X 

3430'x0 = x\ *'**SAVE "RoW'NUMdER '-vheRE ELEMENT FOUND, 

3432 PlsPlX,n\ ***GFT INPUT LIST LENGTH FOR ELEMENT. 

" 37134” P'2 ^PTxT^lS **'*G'ET' P0If4TER TcriigPUT'LlST, 

3440 FOR X=P2 TO P2+P1 -1 \*SCAN INPUT LIST FOR FAULTED INPUT, 

''^4'5o-“- --ir-7r<>TC7» rrTHEN-ia7'0' " ' ' ■ ■ 

3460 I(X/2)=CS\ ***FLAG «ITH FAULT CONDITION WHEN FOUND. 



70 


3a70 NEXT X ■ 

3u80***WLPEAT for next InPUT NAMt TO BE F AULTED. \G0TO 33b0 
3500-RETURfA ***PETUfiN TO MAIN PROGRAM (1355), 

‘T000*A****«******************««***«**«************ft*«**«A***«********* 
'4001# SU8RUUT1UE TU I.^PUT STARTING STATE CONUI T IONS. * 

'4l)0d*#«**#****#*#**#***#*#*#***#*#****##****#*#*#******«******A*****A* 

aoo3* 

4009*** PRINT STARTING STATE mqoe SELECTION HEADER. *** 

4010 PRINiT"ENTER STARTU4G STATE MODE SELECTION. <CR> = 1." 

4012 PRINT"" 

'40I4 PRIWT" (1) ALL UNKNOlf'NS" 

4016 PRINT" (2) DOUBLE CRUSS-COUPLED GATE VARIABLES" 

401H PRINT" (3) ALL VARIABLES" 

4020 PRINT" (4) USER SPECIFIED" 

4022 PRINT" (5) SINGLE CROSS-COUPLED GATE VARIABLE" 

4024 PRINT" (6) SPECIFIED CONSTANTS" 

4026 PRINT" (7) FIXED H PUT VALUES" 

4028 PRINT" (9) MULTIMODE" 

4030 INPUT* A " ' V**ENTER MODE SELECTION NUMBER, 

4040 IF A,<=b THEN 4050 \**CHECK FOR VALID MODE NUMBER. 

4044 ***PRINT ERROR = MESSAGE IF INVALID NUMBER E^lTRED,*** 

4045 PRINT" INVALID CHOICE. MAKE ANOTHER SELECTION." 

4047 ***RETRY MODE ENTRY. NGOTO 4030 

4050 FOR X=1 TO 2 \**IF VALID MUDE SELECTED, INITIALLY SPECIFY 

• 4051 ***ALL ELEMENT OUTPUTS AS UNKNOInM. 

4060 FOR Ysl TO N1 \**SLAN ELEMENT NAMES IN N ARRAY, 

4080 " IF Xsl THEN 4110\*IF Xsl SPECIFY ONE FUNCTIONS, 

4081 **nTH6RrtISt, SPECIFY ZERO FUNCTIONS, 

-4090 ■ • 'Xl = N(Y,nt"-0 = " \*CONSTHUCT ZERO FUNCTION NAME, 

4100 *LOAD FUNCTlUfi IN FILE.NGOTO 4120 

4110 X5=n(Y, n+"0=" \*CGNSTPUCT ONE FUNCTION NAME, 

4120 PRINT : a;Y 5*(Y-1 )+l ,XJ\*LOAD FN NAME IN FIRST RECORD, 

4125 PRINT :X,"0" \*LOAD FN VALUE IN SECOND RECORD, 

4126 PRINT \*LOAD END-OF-FM MARK IN 3RD RECORD, 

4130 NEXT Y 

4140 NEXT X 

«149- ***TKANSFER TO APPROPRIATE ROUTINE FOR MODE NUMBER ENTERED. 

4150 ON A GOTO 4950, 425 0 , 450 0 , 4 7SO , 425U , 490 0 r 50 00 , 420 0 

4151 ***TRANSFER FOR DEFAULT MUDE.NGOTO 4950 

4199 ***pRlnT header FOR MULTIMODE SELELTIOM, 

4200 -PRItMT"SELECT MODE ( 2 ) , ( 3 ) , ( 4 ) , (5 ) , UR (6)." 

4202 PRINT"M0DE (7) IS THEN SELECTED AUTOMATICALLY," 

42T0-TNPUT“A1 \**EMFR MODE NUMBER FOR MULTIMODE. 

4219 ***TRANSFEW ro PROPER ROUTINE FOR mqoE SFLECTEO, 

4220 Orr Al-r GOTO 4250,450 0,4 750,4250,49 0 0 

4250 FOR X=1 TO 2 \**bEGIN ROUTINE TO LOmD DOUBLE OR SINGLE 

-425T ***CROSS-COUPLEDLXC) ELEMENT VARIABLES, 

4270 FOR Y=l TO Nl \**SCAN ELEMENTS IN U ARWAY, 

4275 >=0-'- \**INITIALIZE MATCH FLAG irtlTH NO-MATCH VALUE. 

4280 FUR Z=1 TU ia\*SLAN ELFMEnTS IN 0 ARRAY. 

4282 V1=VAL(Q(Z,1))\*GET XC ELEMENT NUMBER. 

4284 v2=VAL(N(Z,2))\*GET XC ELEMENT NUMBER. 



i y^90 ~ IF'VIrY ThEi>. ai00\*LOOK FOK MATCH WITH ELEMENT 

1 a^93 IF V/f = y THEN 93uO\*I.‘i N AWHAY, 

I '4294 ' *IF '\iu MATCn, LUMTINUE SCAM THHfJUGH Q AkKAY,\GOTO a3b0 

’ x = l J-itM a33U\»IF X = l»LUAO ONE FMS, ELSE LOAD ZERO FNS. 

'4310 'lf- A = 5 THEM 93l2\*ChtCK FUK SINGLE VARIABLE MUDE, 

4311 IF Al<>5 THEM 43l3\*LOOK FOR SINGLE VAK MOOE IM MULTIMODE. 

4312 ' IF Y = V2 THEM 43 1 6 \*CHECK F OR '2ND ELEMENT IN PAIR, 

4313 Xi=N( Y, 1 J +"-0" \*CONSTRUCT OFF VAR FOR 1ST ELEMENT, 

4ri4 *SKIP‘ NEXT'CONSTRUCTIOTi.NGOTO 431S 

4316 Xi = N( VI » I ) T“''0" \*CONSTRIJCT ON VAR FOR 2ND ELEMENT, 

4518 ■' W=1 ■ \*SET MATCH FLAG TO MATCH VALUE, 

_/1520_ *EXir LOOP_ SINCE _MATCH FOUND. \GOTO_4360 

4330 ' ■ 'iF“A = 5 then 4332' \*CHLCK FOR S INGLE' VAR'l ABLE MODE, 

4331 IF Al<>5 then 4333\*lOOK FOR SINGLF VAR MODE IN MULTIMODE, 

4332 " " ■ IF"Y = v2 then 43'36'\*CHECK FOR SECOND ELEMENT IN PAIR, 

4333 X-BsivT Yf 1 J + "0" \*COMSTRUCT ON VAR FuR 1ST ELEMENT. 

433'4 *SKIP NEXT CONSTRUCTION. VGOTO'4338 ' 

4336 _ Xi = fg( VI )+_"-0" _\*CONSTRUCT OFF VAR FOR 2ND ELEMENT, 

4338 ' '' rt'=l ' \*SET MATCH FLAG TO MATCH VALUE,' 

4340 *EXIT LOOP SINCE MATCH FOUND, \GOTO 4360 

435'a NEXT Z ' 

4360 IF w=0 THEN 4370\*LOOK FOR NOMATCh. SKIP LOAD IF NQMATCH, 

431)5' PRTnT ;X; tb*( Y-l )+2 ,xS\*L0AD VAH'IN 2ND RECORD OF FN, 

4370 NEXT Y 

■ 4380 NEX r~x ■ " ■ ' ■ ■ 

438b IF A=8 Then bOOO \***IF MULTIMODE# XFR TO FIXED INPUT ROUTINE. 
4390''RErrURN ■ V***RETURN TO' main' PROGRAM (1360) 

4b00 FOR Xsl TO 2 \*0£GIN ROUTINE TQ LOAD VARIABLES FOR ALL 

■ 4501 ■ *i^eLEMENT OUTPUTS, 

4b20 FUR Ysl TU Nl \*SCAN N ARRAY, 

"4530 "" IF'Xsl THEN 4560\*IF Xsl# LOAD ONE FUNCTIONS? 

4531 ** ELSE# LOAD ZFRO FUNCTIONS, 

'4540 “ X35iV(y7rT+''-0” ■~\*CONSTRUCT''OFF variable, 

4S50 *SKIP CONSTRUCTION OF ON VARIABLE \GOTO 4570 

4560 ' XisNiY, 1 )+"0" ■ \*CDNSTRUC1 ON' VARIABLE . 

4570 PK^NT ;X?Y5*l Y-1 )F2»X*\*L0AD VAR IN 2ND RECORD OF FtJ, 

4b"a'o next y “■ ' 

4590 NEXT X 

4595 'IF 'As6“THEN 5000 ~ \*1F"MUL TIMODE# XFR To FIXED IMPuT ROUTINE, 

4600 RETURN \*R£TURN TO MAINPROGRAM (1360), 

■ 47if9 ■***'B'EGIrr'ROUriN£ 'FO'R”LOADlFfG USER SPECIFIED' INITIAL CONDITIONS. 
47bO PRINT"ENTER equation or ENTER <CR> TO TERMINATE ENTRY," 

"'l/ST^Xls? Na'INTTIALIZE' FN RECORD POINTER. 

47b2 INPUT Z'B \*ENTEk FN FROM Kd. 

■ 4755“rF *75s"--^'^-THErr'49S0V*LC10fr'FOR' END 'OF' ENTRIES. 

4756 CS5""\xi=""\a%="" \*CLEAP temporary VARIABLES. 

476rV3sO \*3NiriALI2E' COUi'iT OF CHARS IN FN NAME. 

4762 FOW X=l TU 100 \*COUNT CHARACTERS IN FN NAME, 

'4TF4' V3'sv3n V*INC' COUNTER. ■ -- - - - 

4766 IF ZS(;x#l)s"=" IhEN 4768\*LOOK FOR END OF NAME. 

~476T"T'TrXT~jf 

4768 FOR x=l TO Vi-l \*EXTRACT FN NAME FROM EUN AMU LOOK 


72 

a769 - - - **FOR ZERO FN U)(-3. 

«770 IF ZSl : I ) = fhE^ «7HO 
U77a C'5=C$ + ZB(:X#n 

<47 7o mEXT X 
a778 GOTO ^762 

a7«0 X$ = "-" \*SAVE symbol f-UR ZERO FM. 

A782 V« = LEriCZ$) \*CO«PUTE IF’JGIh OF Zi, 

'JZHi FUR XSV3+1 TO Va \*EXTRACT fN VALUE FROM tUM, 
i|78a- 8S = EiS + Z5C;X, 1 ) 

4/86 NEXT X 

'4787' FOW~Y=l TO " ‘ \*SEARCH i\i ARRAY FOR F>\i NA^fc, 

4788 IF C4 = iJ(Y,l) THEN 4792 

4789 iMEXrV 

4790 PRi:\iT"FN name DOES NOT MATCH ANY ELEVEN! OUTPUT, PLEASE REENTER," 

4791 ***REPEAT entry. \G0T0 4750 

4792 IF X4="" THEM 4820\*CHECK FUR ONE FN SPECIFICATION. 

4793 Y$=CS+"-0=" \*C0NSTRUCT COMPLETE ZERO FUNCTION NAME. 

4794 PRINT : 2 ; Y5 * I Y- 1) + 1 , Yi\*LOAO FN NAME IN RECORD 1 OF FN, 

‘ 4800' V4=LENC8$T " ' A*COMPUTE LENGTH OF H$. 

4801 YS="" \*CLEAP Y$ FOR PARSING OF BS. 

4803 FOR Xsl TO V4 \*8EGIN PARSING OF 05 INTO TERMS, 

4805 IF 84CX, !) = "♦" THEN 4810\*ENl) UF TER^''? 

4806 Y5=Y5+a5C:X/l) \*CONSTRUCT TERM UNTIL END REACHED, 

4808 »IF E''‘D not reached# GET NEXT CHAR,\GOTO 4814 
4810 PRINT :2; Y5* ( Y-1 J +X1 , Y5\*L0AD TERM IN RECORD XI, 

4812 Y5="" \*CLEAR YS FUR NEXT TERM, 

4813 '• XlsXl+1 \*INC RECORD POINTER, 

4814 NEXT X 

-4815 PRU4T- :2;Y5*(Y-1)FX1,Y5\*L0A0 LAST TERM, 

4816 PRINT ;2;Y5*(Y-l )+XlFl #"."\*LOAD EnO-OF-FN MARK, 

4818 ***RtPEAT FOR NEXT EON ENTRY. \GOTO 4750 
4820 y5=C5+"Os" \*C0USTRULT ONE-FN NAME. 

4822 PRINT : 1 ; Y5* C Y-1) + 1 # Y$\*LOAO TW NAM£ IN RECORD 1 OF FN, 

4824 v4 = LEiJ(b5) ' \*C0WPI)TE LENGTH OF b5, 

4826 Y5 = "" \*.CLEAP Y3 FOP PARSE OF 85, 

4828 FUR X=1 TO V4 \*PARSE 85 INTO TERMS ANU LOAD IN FILE, 

4830 IF 85(;x,l)="+" THEN 4H3o\* END OF TERM? 

483'2 Y5 = Y*+H5(:x#u \*CONSTRUCT TERM, END TOT REACHED, 

4834 ' *DO NOT LOAD UNTIL END RE ACHED. \GO TO 4840 

4836 PRINT : 1 ; Y5* ( Y-1 ) *X 1 , Y5\*L0A0 TERM IN RECORD XI, 

4858 ■ -Y5 = "" ' - \*CLFAR Y5 FOR NEXT TERM, 

4839 Xl=Xltl \*INC PECURD POINTER. 

4840 NEXT X ~ ' 

4841 PRINT :1 ;Y5*{Y-nfXl/Y5\*L0AU LAST TERM, 

4842 PRINT ; 1 ; Y5* ( Y- 1 ) +X I 1 1 # " . " \ *LOAO EUD-OF-FN MARK, 

4844 *** repeat for ENTRY UF NEXT EUUAT ION, NGOTO 4750 
-4-599 *** BEGIN ROUTINE FOR ENTRY OF SPECIFIED CONSTAimTS, 

4900 PRINT"ENTEW— LI<mE NAME = 0 UR 1— ENTER <CP> TO TERMINATE ENTRY," 
4901 "INPUT Z® ■ \*ENTER LINE NAME AND DESIRED VALUE. 

4903 IF 25=" " then 4950 \*EN0 OF ENTRIES? 

4904 V3=0 \*INITIALIZE COUNTER. 

4905 FOR X = 1 ro lOO \*CUUNT NU<^BER of CHARS IN LINE NAME, 



1 


73 


I " ■>/i = v3+r countek. 

i <490/ IF ZiiC ; A, I ) = " = " THF.\ <4909\tNO OF NAME? 

; "4908" .vExr'K - “ ■ ' 

<4909 Ci = Z£(: 1 , Vi-l ) \*tXTHACT LlWE NAMf f. ROM ZS. 

4910' ei = 'Z'h ( ; V 4 + i )■" “ '\*EXTRACT LIf''E VALUE FROM ZJ. 

4911 FOR y=l 10 Ml _ \*SCAU M ARRAY FOR LIME NAME, 

<491<> ' lF 'CJ = NtY#l) 'IHEN 4416' 

4914 \EXT Y 

■49I6TIF' 'Bis"!"' THEM 4924\*TEST "FOR VALUE OF 'ONE. 

4918 X$="0" \*VALUE OF ZERO ENfEHEU, 

4920" YS="r" ■- \"*"ASS'ir,N (0,1) "td-fns. 

4922 *** LLIAO FMS IM FILE,\ GOTO 492H 
~4924 X4 = "l" V'*VALU"r"OF~ONE" entered. 

4926 Y$="0" \*ASSIGN (1,0) TO FNS, 

4928 'PRIiJr I ;Y5T(T-1 )"+2',Xi\'*L0A0""0NE'-FN""VALaEV 

4*^0 PRINT :2; Yb*(Y-l )+2,Y^\*LUAD ZEHU-Fn VALUE. 

4940' ***" repeat FOR "NEXT ENfRY.N 'GOtO 4901 "" ‘ - " 

4950 IF A=8 t hem 5000 \*IF fUJLTIMOOE, GO fO FIXED-INPUT ROUTINE, 

4960 RETURN \*RrTURN~TO "MAIN PROGRAM '( 1 ibO )', ' 

i 4999 *** BEGIN ROUTINE TU ENTER FIXED INPUT VALUES. 

500CT"FQR'"X=r TO' ro V»TR"AS£"PREV10USEY"ENTEPE0 VALUES. 

! 5001 IF UX,2) = ''S0" THEN 5004\*l)0 NOT REMOVE ANY 
. 5002 ‘IF rCx;'2) = "Sl''"THEN 500lJS"'*SPEC IF I£0 FAULTS. 

5O0i I(X,2J="FF" 

' 5004 next X 

5005 IF A<0 Then 5007 \*CrifcCK FOR MULTIMODE ENTRY, 

, -500'b"PRTNT'"ENTER'TIXEO'TNPUT~VAL"UES,'’’''' ' " 

• 500/ PRlllT'’tNTER LIME NAME =0 OR si OR TO STOP ENTER <CR>."? 

! 5010' ITiPtjT' ZJ \*ENTER LI^4£ NAME AND VALUE, 

5020 IF Z?=" " THEN 5300\*£n0 OF ENTRIES? 

• "5030'"V3su — ■ - AMNITIALIZE COUNTER. 

. 5040 FOR Xsl TO 100 \*CUUNT THE CHARACTERS IN LINE NAME, 

saso ■ "V3SV3+1 V* rNc“coi^TTT;; — — ' " ' ' 

5060 IF Zil :X, 1 is-’s" THEN 5080\*LOOK FOR END OF NAME, 

. 5070~mE'XT X "■ ■■■ ■ ■ 

5080 C$sZ6( ; I , V3-1 ) \*LXTRACT LIME NAME FROM Z», 

509Tr"B? = Z5 (; V3'fn " V*EX TRACT" LIf.'E VALOT FROM Z$, ' ' 

5095 w=U \*IM TIALIZE FLAG FOR MO MATCH VALUE, 

51Q0"F0R' X=l TO"IO' ' " \*SCAfJ I"ARRAY FOR CINE NAME', 

5110 IF Ciol(X,l) THEN 5130 
"5120 rCx,"?)'=Bl \;*INSERT~VACOE WT^Tn mA'TCh FOUND, 

5125 ^=1 \*SET FLAG TU MATCH VALUE. 

-SnO'AJExT X ' 

5152 IF .v=l THEN 500/ \*MATCH FOUND, REPEAT FOR NEXT ENTRY. 

5T33' PT5rNT"CT'7rn4AW'"D-OFSn^IGT-TTITCFrANY'PRIMARY INPUT OF CIRCUIT."' 

5134 HRINT"PLFASE TRY AGAIN," 

'5T15' ***RErR"i^E:^rTRY,^^ GOTO 5007 " ' 

' 5300 I? main pr ogra m iiibO). 

6 001 * SUB ROUTINE TO j i JPU T C IRCUIT DESCRIPTION FROM FILE. * 

6005***THIS SUDk -\AS derived FROM AND IS SIMILAR TU SU8R 2000,*** 


74 

oOl5 IO = lV “ ■ ■■■ ***r^ITlALIZE I ARPAY POI.JTEW. 

b01,7 'M=U\ ***r«ITIALI2t I'l ARRAY PUInTER, 

6020 -ZI=""\ ***CLEAR ZS. 

o02d INPUT :S,ZS\ k**lrjPUT bLE^ENT UESLHIPTION FROM FILE, 

602'3 PRT.'jT Zl\ *»*PkINT ELE^'E>'^T uKSLRIP r ION. 

002*3 IF Zj> = " " then oa50\*L<jOK FOP F.Ni) OF EI.E'"E''Jr ENTRIES, 
o030 Nl=Mtl\ h ftPRAY POINTER, 

oOiA***** begin PARSING OF Zi ********** 

603*5 3$ = ""\ ***CLEAR B$ FOR NEXT FIELD, 

O0'40 X=l\ ***INI7 lALIZF pointer TO ZS, 

6050" rF'25 CX7 1 )=" "TriER o090\*END OF ELEMfNT-NAME FIELD? 

bOoO 5S=BiFZ it, ; X, 1)\ **fctwO NOT REACHED, ADD TO iMAMt. 

bOro X = X + 1\ ■■ ***INC POINTER TO Z4. 

bOrtO ***<rREPEAr FUR NEXT CHARACTER In Z'i,\GOTO 6050 

6090 N(N1,1)=HS\ ***GHEN NAME COMPLETE, PLACE IN N ARRAY, 

6100 N( 41 ,*4) = ”N0"\ ***LAHEL all ELEMENTS AS NO OUTPUT, 

6110 RS = "*’\ ***CLEAfi 85 FOR NEXT FIELD, 

612,0 X = X + l\ ***I-'iC PUINTEH 10 Z5, 

6130 IF ZS(;X,I) = " "-THEi'T 6170\*END OF ELEMENT TYPE FIELD? 

6140 BSSBI + Zil : X, 1 )\ ***ENl) NOT REACHED, RUILD NAME. 

6150 X=Xfl\ ***Tnc POINTER TO ZS. 

6lbO*x*HEPE' A I FOR NEXT CHARACTER IN Z%,\GUTO 6130 

6170 M(ni,2J=8S\ ***kvHEN NAME COMPLETE, PLACE IM N ARRAY, 

6175 Z=l\ ***lrjIT lALIZE CUU.mT OF ELEMENT I^;PuTS. 

6177 P(Ml,2J = rO\ ***LOAD POINTER TO INPL'T LIST, 

6180 X=X+l\ ***INC POINTER TO Zi, 

- 6190 ***CLEAR OS FOR NEXT FIELD, 

6200 IF ZSUX,1) = " " THEN b250\*ENU OF INPUT NAME SUbFULO? 

6210 B5 = BSFZi(jX,U\- ***E^40 NOT REACHED. RECOimSTRuCT NAME. 

6230 X=X+l\ *x*lNC POINTER TO ZS, 

h2ao ***repeat for next Character in zs.xgoto 6200 

6250 IU0,1)=B4\ ***.MhEN NAME LOMPLETt, PLACE IN I ARRAY, 

6260 Z = Z + 1\ ***INC CnUfiT OF ELEMENT I'JPUTS, 

6270 IO = IO + 1\ pointer TO I ARnAY, 

6280 L=LEN(ZSJ\ ***COMPUTf LENGTH OF Zi, 

6285 IF X<L then blHO\****IF FNU MOI REACHED, GET nFXT INPUT, 
6290“P(NI , 1 J=Z-I \ ***WHEM END PEACHED, PLACE OF INPUTS IN P, 

6300 a**REPEAT FOR NEXT ELEMENT DESCH I P 1 lON , \GOT 0 6020 
b«30 FOR X = l TO lO-lN t**ASSIGN NUMERIC CODE TO -ALL INPUTS 

6431 FUR Y = 1 TO Nl\ *4»*EXCEPT PRIMARY I.mPUTS. 

6432 IF I(X,U<>r.(Y,n THEN 643b 

6433 ZS)=SrRin 

6454 ■ ICX,-51=ZS 

0455 GOTO 6437 

6436 NEXT-Y 

6437 NEXT X 

■'64raT I0=I0“1V- ***C0MPUTE THE NUFbER OF RO/JS IN I, 

6445 INPUT ;i,Zi\ ft*«GET PRIMARY INPUT NAME FROM FILE. 

6446 PRTN'T Z4\ ft**PPITviT PRIMARY INPUT NAME, 

0448 IF Z'ti = " " THEN 64o5\*LCuK FuR E viD OF PWl'^ARY INPUT ENTRIES, 

6450 FOR X=1 TO I0\ *ft*SCAM I ARRAY FOR PRIMARY INPUT NAMES. 

6455 IF Zk<>i(X,l) THEM 6460 


I 75 

j 6^57 I ( Xi3)'="YES"\ ■^♦♦♦FLAG ,.irh YES k^HEN FOUND.’ ’ 

64160 'JEXT X 

'oa62****FEPEAT F0« NEXT INPUT NAME.NGOTO h44J5, 

641o 6 iNPur_:3,Z6\ *«*GKT PWIMAPy OUTPUT NAME FKOM FILE, 

i 6«66' PRINT Z5\ ■’ *i*PRI>iT PRIMARY OUTPUT name, 

1 tj4l70 IF z^ = ” " 7HEN 6500\*LH0K FOR END OF OUTPUT NAME ENTRIES, 
i ' 6472 FOR X=l TO NlV ' ***SCAN N ARRAY FQK PRIMARY OUTPUT NAMES,’ 

, o47b IF ZiON(X,n THEN 64P0 

647/ ’ NCX,4 ) = "YES’*\ ‘"***FLAG AlTH YES rtHEN FOUND. 

6480 NEXTX _ _ 

'6465 ***REPEAT >0R NE'XT’OUTPU’T NAM£,\GOfO 6465 
6500 01*0 

: '6510' INPUT" : 5’,Z4\ ***GET XC ELEMETlT PAIR FROM >11^',’ 

I t>5ll PRINT Zi\ *»*PRI(\jT element PAIR. 

o520 "rr’2i = " ''~THE>T6700\*LnOK' F OR ' t NO ' OF " XC PAIR ENTRIES, " 

6530 OISOI + IN ***INC POINTER TO Q ARRAY, __ 

’6’540 L = L£NfZ-i>A ’ ***LOMPuTE LENGTH 0F'Z3>. ‘ - -- 

6550 ^OR X=1 1^0 L\ _ ]^**BEGIN PARSING ZS. 

‘ 6SoO IF Z'M;XVf) = " '• then' 6580\*EN0 OF FIRST "NAME IN PAIR? 

' 6570 NEXT X 

i ‘ 6S8"u"8i=7Sr;TrX-lT\ Trscrr B$""=""FIRS"t NANE. " " 

6590 C 5 = Z3>(:x + l)\ _ ***LET CJ> = SECOND NAME. 

66'40* F0R"'X1 = 1 "TO Nl\ ■*"**SLAfj N" ARRAY FOR NAMES OF XC ELEMENTS, 

; 6641 IF 0fi=N(Xl,l) Then 6645 
6643 NEXT xl ■ 

0645 ZSsSThCXUX ***GFNE«ATF NUMERIC CODE FOR ELEMENT, 

; '66«6 "QCT31 f 1 J=Z5'\'~ ***PCA'CE"COOE" IN Q ' ARRAY, 

6680 FOR Xl=l TO Ml\ ***SLAN N ARRAY FOP SECOND NAME IN XC PAIR, 
■”6681 " IF CdsnCXI,!) then 6685 " 

. 6682 NEXT xl 

66a5""2a.s3TH(xn\ ' ■" ***GENER'ATE NUMERIC CUDE. 

' 6686 Q(N1 »2)=Zi\ ***PLACE CODE IN 0 ARRAY. 

“6690 »**REPEAT"FOR 'NEXT" PAIR' -OF XC ELEMEiiTS. \GOTO b5tO 

6700 RETURNN _ *»*RETUR_N TO MAIN PROGRAM (1340). 

' 94999 "ETNiT ' ' " " ■ 


76 


ro : 1 0 

OCT lt»'79 DC/3IM2DOC.bCARROLL 



1* 

S3SS3 III 

M 

M LL 

ooono 

GGGGG 

2* 

S 1 

MM 

L 

0 0 

G 

3*" 

SSSSS I 

M 

MM L 

0 0 

G GG 

'4* 

b 1 

M 

M L 

0 U 

G G 

5* ■■ 

SSSSS“ III 

M 

^ LULLL 

000 DO 

GGGGG 

6* 






7*. 

program: 


STM200C 



rt* 

VERSION: 


SIGMA 5 



-g* 

REVISION 

• 

• 

““ ORIGINAL 



10 * 

DATE: 


10 / 10/79 



1 1 * 

PROGRAMMER: 

B. 0. CARROLL 


12* 







lu* 

15* CO"ITRACT SUPPORT 

lb**A«««**«***«**«ft***** 

17V - - - 

18* THIS PROGRAM .nAS OEVtLQPCO POP •'^ASA MARSHALL FLIGHI 

19* CE^JTtP UOOER CONTRACT UASa-31^7^, 

20 * 

2 r* ************************** 

22 * 

23* MODIFICATino HISTORY 

du tc 


26 * 

39 *“ 


IQI* 

102 * 

103* 


PROGRAM OESCRIPTIO'v 


105 * 

106 * SIMLOG IS A program FOP S I^ULAT J i\.G LOOK CIRCUITS, 
107 * noTH CQMgiNA riQxIAL AfiO SEnOt'MTIAL CIRCUITS CAN PE 
108 * SI'^ULATED. CIRCUITS CAfl hE SIMULATED FAuLT-FREE UR 
109 * .JITH SlivGLE OR MULTIPLE STUCK TYPE FAULTS. 

110 * LOGIC ELEMENTS ACCOMMODATED BY THE SIMULATOR ARE 

lir*' NANO GATES AND NOR GATES. OTHER ELEMENTS ARE TO 
112 * 8 F AUOED. 

- 113 * ' ■ 

119 * I <(0 versions OF SImloG hwVE bEE ^4 i^RITTEv, 

115 *' ■ ONE “VERSION HAS BEEN WRITTEN IN BASIC-PLUS FOR 

116 * E)(ECuTlnN ON A POPll/UO RSTS/t SYSTEM. 

nr* another version has been written in xerox basic 

118* FOR Execution on a sigma 5 cpv system. 

119 * 

120 * THE PDPll /90 VERSION IS PARTITIONED ir.T(’ TwQ 
121 * subprograms^ SIMA ADD SI^B, THIS PARTITIONING WAS 

122 * necessary due TO THF. LARGE MEMORY KEUOIREMENTS OF 


lei* 

125 * 

J2b* 

127 * 

128 * 
id')* 
liO* 

131* 

1 id* 
iii* 

1 34* 

T35* 

I 36* 

137* 

133* 

139* 

140* 

141* 

I4<i* 

300 
301 * 

302* ■ 

303* 

304********** 

305* 

306* ^ ' 

309* 

310* 

31 1 * 


77 

[HE PRUbWA,-r, VI^^TiJAL AKfPAYS AKE UStO FOP ALL LAPGE 
APRAY SIOhAGE, 

THE SIGHA 5 version IS PART I T IC^iED IMO THREE 
SUoPKOGRAf'S/ SIMl, SI'^*2“*'1NU KACE, THIS DEGREE OF 
PARTI T IHNInG ^AS f'iECESSARY SIGCE VIPTOAL ARRAYS ARE 
• JUT AvAILABLE'O'V The SIGMA 5. 

THE FlJiJCriOW OF SIMI IS TO INPUT ALL DATA NEEDED 
concerning CIRCUIT DESCRIPTION* FAULT DESCRIPTION, 
initial “Cn.NDITinNSV and SIMULATION' modes. ■■ 

THE FUi'lCriON“OE"'SIM2"iS''TO"PEKFORM THE ACTUAL' 
SIMULATION COMPUTATIONS YjITH IHE EXCEPTION OF 
RACE 'ANALYSIS and TO OUTPUT THE SIMULATION RESULTS. 

THE HJ motion OF hACE~IS TO PERFORM THE RACE 
analysis COMPUTATIONS, 


1/0 streams 


* * * 


stream 


USAGE 


312* 

1 

FILE 

OF 

old 

ONE-FUNCTlOfiSCS = 0 J 

315* 


FILE 

OF 

nE‘Y 

ONE-FUNLriONSlS=l') 

314* 

' * * 



, * 


315* 

2 

FILE 

OF 

OLD 

2ERO-MJNCTIONS(S=0) 

516* ' 


" FILE 

OF 

Nf A 

ZER0-FUnCTIU.m5(S=1 ) 

31 7* 






3 1 8 * ■ " 

" 3 ■" 

■ ' file 

OF 

I'm F a 

2ER0-FUnCTI0NS(S=0) 

319* 


FILE 

OF 

OLO 

ZERl*-FUNCTIONS(S=l J 

320* “ 






521* 

4 

FILE 

OF 

N E w 

ON£-FUNCTIONS(S=0) 

322* 


F ILE 

CF 

OLD' 

'OtME“FUNCTlONSlS=l )' 

523* 






324* 






325* 

THE 

ABOVE HEPRESFimTS 

THE BASIC ASSIGNMENTS 


^ I/O STREAMS 

'323* ~1(r Fl'jTvTCTTtDN- FIUESi; HnWFVEfT,' THE "SIGMA ‘5 PROVIDES 0ULY"4 I/O 
327* STHM^' nU'^HERS. HENCE, IT BECOMES NECESSARY TO REASSIGN STREAMS 
32"3*" 'when aTCE" 3S TO "APRA YiFlLE'S'IS"iVEEDED,' ' THIS' REASSIGNME NT IS 
329* DYNAMIC AS A FUNC T_in.M__0F PARAf>^ETERS S AND J SINCE IT IS 
■Jl'if* lECESSttHT T'O' KEEP "ACC"e'SS'"ro'ONETUNCT'lON“FILE ALSO, 

331* the FOLLUwI.'mG TABLE DETAILS THIS DYNAMIC 'ASS IGN^ENT , 

" 332 '* - - - 

333*- 1- — : 1 


78 


■ S=0 i S=l 1 

s^s* : 1 

336*STREAMrf! J=0 I J=l 1 J=0 J J=1 1 

33 - I - i I I 

338*’ I '1 OLOl I FAkkAY i FARRAY 1 GARRAY ! 

339* 1- i — i — J.— — — ..— I 

5a0* d { FARi^AY J " OLOO • i GARRAY i FARRAY 1 

3Ul* -i- — .1....— i 

3«2*v 5 I GARkAY » - hARRAY ! hARRAY I i>JEa' 0 i 

343* 1 1 : 1 1 

344* 4 "I HARRAY ' I GARRAY • NE^l 1 HARRAY ! 

34b*— ——i——— ——1——— -—I- !— — .1 

3«6*. 


401*, 

402** variable OEUMITIUNS 

403*.. 


405* 


409* 

410* 

411 * 

412 * 

413 * 
114 * 
41b * 

416 * 

417 * 

418 * 

419 * 

420 * 

421 * 

422 * 

423 * 

424 * 

425 * 

426 * 

42 7 * 
426 * 
429 * 

450 * 

451 * 

4 32 * ' 
4 33 * 
454 *■■ 
4 3b * 
456 * 

43 7 * 
438 * 
459 <r 

440 *’■ 

441 * 


variable 0EFP.JIT10N 

A USED AS A.\ IMUEX fur THE AS ARRAY, 

A:b A string array used to store The LITERALS OF A 
PRODUCT TERM THAT HAS PEEM PARSED, 

B USED AS THE COfiTHOL VARIABLE IN A FOH-NEXT LOOP, 

bO USED AS THE CONTROL VARIABLE U' A FOR-MEXT LOOP, 

01 THE CONTROL VARIABLE TERN'INAL VALUE FOR A FOR-NEXT 

LOOP IN A BUBBLE SORT PHOCEDURF. 

Ri USED AS A TEMPORARY STRING VARIABLE, 

C USED AS A FLAGf A LUUNTERf AimO AS A FUR-NEXT 

LOOP CONTROL VARIABLE, 

CO USED AS A SWITCH THAT I ND I C A TES ( L 0=2 ) WHEN ENTRY 
TO S1M2 IS FRUN' RACE, 

Ci USED AS A TENPUKttRY STRING VARIABLE. 

D USED AS A flag to [hDICATE (U=11 THAT A MINUS 

SIGN SHUULD BE INSERTED IN A TEST STRING, 

--- US ' A string array (nriE-DIMENSIONAL) USED AS 
TEMPORARY STORAGE DURING THE FUilLTlON 
mINIMI/ATION ROUTINE. 

F INDICATES the I/O STREAM TO WHICH F ARRAY FILE 

IS OPENED, 


i 


79 


* 

4^3 * F5 USED fiS a FLAG TmAT INDICATES /JhEThEM DR NOT A 

444 * ~ MINUS (-) HAS HEEn' ENCUuMERED DURING THE PARSING 

44b • OF A PRODUCT TERH. E5=l IC'DlCATtS THAT A MINUS 

44o * HAS 'HEEN'ENCnUNTERED.' LOCAL ru SUHR 7800, 

44 7 * 

448 * FI ’ A flag USED ' TO INDICATE ^HETHEP AN INPUT FAULT (1) 

449 • UR AN OUTPUT FAULT l<?) IS TO BE INSERTED, 

4b0 * 

* Ft? k'HEN AN input FAULT IS TO BE INSERTED, ^^=l 

452 * ■ ~ ‘ INDICATES THAT THE FAULT IS UN THE FIRST INPUT OF 

453 * AN ELE^^E■NT^ F2=2 INDICATES ANY OTHER INPUT, 

^454 * ■ ‘ ' " ■ ■ " ' . ' 

455 * 6 INDICATES THE I/O STREAM TO wriICH THE G ARRAY FILE 

456 * - - - OPENED. " ' 

457 * - - 

458 * ■ GT IISEU AS “a" TE^'PORAHY VARIABLE FOR F OR G. 

459 <t 

460 * ~H“ INDICATES' THE I/O STREAM TO ►»HICH‘ THE H ARRAY FILE 

461 * IS- OPENED. 

462*' ~ 

463 * INDICATES THE UPPER LIMIT OF THE LOOP VARIABLE 

464 * ■ OF SOME FOR-f!Exr LOOPS. “SHOULD HE SET >= THE 

465 * NUMBER OF PU^S IN THE I ARRAY, 

466 *' 

467 * I A TaH DIVENSIUNAL IMPLICIT STRING ARRAY USED TO 

. 468~* ” ■ STOPr CIPCOir ELEMENT INPUT^LISTS.' EACH OF 

469 * THE ARRAY DESCRIBES ONE INPUT VARIABLE OF ONE 

1 470 *■ ■ '■ element of the CIRCUIT'BEING DESCRIBED. THE 

471 * VARIABLE NAMt IS GIVEN IN COLUMN ONE. ANY FAULT 

I 4/2“i ■ ----- cOfJOITIUNASSOClATEO'v'^ITH THE' luPOT IS 

I 4 73 * GIVEN Pi COLUMN Ti.U, THE THIRD COLUMN INDICATES 

'474'* NhETHER~OR NCT'THf INPUT IS A PRIMARY INPUT. 

475 * 

'476 * ' “ "10 A POINTER TO THE NEXT ROi^'UF THE I ARRAY TO BE 

; 4/7 * _ LOADED during INPUT OF' THE CIRCUIT OE'SCR I PT I UN. 

'4/8 *■■"" THE F fNAL'VALUt OF lO I nDIC A T ES THE NUMBER OF 

• 479 * ROaS UF ARRAY' I THAT APE USED, 

4B0' * ■ “ 

481 * II THE' CONTROL VARIABLE IN THE PRIMARY FOR-NtXT LOUP 

"482‘ ■*" OF'THE” SIM2' MA1N“PRGGRAM; In I mI'S 'CONTEXT I T 

483 * SERVES AS A POINTER TO THE N AND P ARRAYS. 

'4'84"*"‘ 

485 * J USED AS A S««ITCH TO INDICATE' WHICH FUNCTION TYPE IS 

,'486~* BETnrrGE7vE:RATE'D;~;j = 0'INDICATES 0-FN, 

48 7_* J = 1 INDICATES 

. 48fl'l>' ' ' 

•489 * J5» USED AS A TEMPORARY STRUG VARIABLE INDICATING THE 

'49'0 '*■ TD"^irMb£R OF" An ELFMEn T ' 1 NPO T i 

491 * 

"a<r2"* «" ~A”WnCH FNO'ICAT Ii'4'G"~liHrCH "ARRAY F (K=l) OR G (K = 0)' 

495 * IS TO BE loaded WITH A FUNCTION. 


80 


aga- 

* 


495 

« 

L 

<496 

* 


497 

ft 


495 

ft"~ 

LI .L2 

499 

ft 


500 

ft " 


501 

ft 

N 

502 

ft 


503 

ft 


5071' 

ft 

— — 

505 

ft 


506 

ft 


507 

ft 


508 

ft 


50R 

ft 


510 

ft 


511 

ft 

NO 

512 

ft 


513 

ft 


514 

ft 

' 

515 

ft 

N1 

516 

ft 


517 

ft 


51 H 

ft 

02 

519 

ft 


520 

ft 


521 

ft 


522 

ft 


523 

ft 

P 

524 

ft 


525 

ft 


526 

ft 


527 

'ft 


52H 

ft 


52R 

ft 


550 

ft 


531 

ft 

PO 

532 

ft 

- 

533 

ft 


554 

ft ' 


535 

ft 

ii 

536 

ft 


557 

ft 


533 

ft 

- - 

539 

ft 


5'4 0' 

ft- 



541 

ft 


542 

ft 

• Q1 

543 

.ft 


544 

ft 


545 

ft 

R 


KEPREbfc'MTS THfc L&^bTH UF A Slklf^Cj. VALUE IS 
ESTAgLISHEn HY THE LEN FUNCTIOr'I. 

USED TO I-'^OICaTE THf LENGTH OF TER’^’S DURING THE 
tern ordering procedure. 

• 

A Tv'iO DIMENSIONAL IMPLICIT STRING ARRAY USED TO 
STORE the element DESCRIPTIONS AMO INTERCONNECTIONS 
OF A circuit, each woir. OF the array CORRESPONDS TO 
ONE element of the circuit, column one contains 
THE element OUTPUT NAM£, COLUMN TrtU IS THE ELEMENT 
TYPE. column three INDICATES THE FAULT CONDITION 
OF THE ELEMENT OUTPUT, COLUMN FOUR IiOOlCATES 
whether or not the ELEMENT OUTPUT IS A PRIMARY 
OUTPUT OF THE CIRCUIT. 

A FLAG INDICATING IE THE OLD FUNCTION SET AND THE 
NE>'i FuNCTrON SET ARE EQUAL (N0 = 1) OR ARE NOT EQUAL 
(N0 = 0) . 

INDICATES THF, NUMbER OF ELEMENTS I^' THE CIRCUIT. 
CONSEQUENTLY THE NUMBER OF RO«S IN N AND P. 

flag IjSEU TO INDICATE IF SIMULATION IS TO BE 
CO'ITIhUEO FULLOhING the DETECTlO'v. OF A POSSIBLE 
OSCILLATION. n^=l MEANS TO CONTINUE Y.HILE 
U5=0 means TO STOP. 

A T-vO DI'^'EmSIONAL numeric array USFO TO STORE 
POINTERS TO ThF INPUT LISTS STORED IN ARRAY I, 

ROW I OF P CORRESPONDS lU THE ELEMENT DESCRIBED 
IN HO'I 1 OF ARRAY N, COUK’N ONE OF P CONTAINS THE 
uU^HEk of INPUTS TO IhE ELEMENT /.'HILE COI UMM Ti-.O 
contains the POINTER TO THF ELEMENT INPUT VARIABLE 
LIST STORED lit ARhAY I, 

USED AS AN INDEX TU ThE InPUT LIST OF 

AN element. PO is ADDED TO THF INPUT LIST POINTER 

TO obtain the PON OF I CORRESPONDING TO THE INPUT. 

A T.tO DIMENSIONAL IMPLICIT STRING ARRAY USED TQ 
STORE pairs of ELEMENT NAMES THAT ARE CROSS 
COUPLED IN the circuit. EACH RJ.v CORRESPONDS TO 
A CROSS-COUPLED PAIR. THE NAME OF ONE ELEMENT OF 
the; pair is stored in CuLUMN unE Af.O the name of 

'THE'PTHER ELF'^FNT IS STOWEP IN COLUMN TwO, 

THE NUMBER OP CROSS-COUPLED PAIRS OF ELEMENTS IN 
THE CIRCUIT, ALSO TRFI NUMHtR OF ROaS IN Q. 

the pipple-time variable. 


81 


5A6 



■in 7 

* 

1 V 

Sas 

* 

■ ' 

549 

* 

Ki 

S50 

'* 


551 

* 


552 

* 


55i 

* 

R9 

554 

ft 


555 

ft 


55b 

ft' 


557 

ft 

3 

"558 

ft' *" 

' 

559 

ft 


560 

ft 

1 

561 

ft 


562 

*■ 

TO' 

563 

ft 


564 

ft 

(T 

565 

ft 


B66 

ft 


567 

ft 

V 

Sbri 

ft 

— 

569 

ft 


570 

ft' 


571 

ft 


572' 

■ft 

****** " 

573 

ft 

X 

■'574' 

ft" 


575 

ft 

xo 

■576" 

■ft 


577 

ft 


578' 

■ ft 

XI 

579 

ft 


580 

if 

_ -- 

581 

ft 

X2 

582 

ft 


585 

ft 

X3 

584 

ft 

.... _ 

585 

ft 

Xi 

5RB' 

-ft ■■“ 

— — — — — ~ 

587 

ft 


■588 

*■ 


589 

ft 


' 590 

ft 

yr- 

‘ 591 

ft 


I 592 

ft 


' 59S 

ft 


■ 59'4 

“ft" 


595 

ft 

Y1 

59b' 

‘ft 


597 

ft 

Y5 


HIPHLE^-Tlf'-T Linii. IiyPuT bY THt USEK, 

Tit \/ALUt OF K’IPPLh-T I^-t (P) AT THE HEGlNfJlNG OF 
A input-time (n. NEEUtl) 10 uetehmime if a 
POSSIBLE OSCILLATION CONDITION EXISTS, 

A SkxITCH INDICATING ahEThEK OK NOT RACE ANALYSIS 
uAS selected. K 9 = 0 : WAS SLLECTtDtOEFAULT VALUE). 
_K 9 =l: NJ)T SELECTED. 

A SrtITLH INIJICATING rthiCH CHANNEL TO USE WHEN 
ACCESSING FUNCTION' FILES, ' - - - 

INPUT-TIME variable, 

INPUT-rP'E LIMIT. INPUT BY USER. 

"A" ONE -dimensional# ONE-ELE^-'EN T ARRAY USED IN 'THE 
C ONVERSIO N OF THE INPUT-JIME VALUE TO A STRING, 

A temporary variable USED TO REPRESENT THE 
|''UM 6 ric value uf' a string variable, 

USED AS A pointer to ThE H (RESULT) ARRAY DURING 
THE AuO routine. 

USEU AS THE LOnTROL VARIABLE IN FOR-NEXT LOOPS, 

A TE'^IPURARY variable USED TO STORE THE SORT LOOP 
LP^'n In' THE TERM' SOkT ' ROUl InE. 

"A TEMPORATTY VARIABLE USED TO STORE THE NUMBER OF 
TERMS III THE FUT 4 CT 10 N BEING SORTED PLUS ONE. 


USED AS THF CUnTROL VARIABLE IN A FUR-NEXT LOOP, 

USEU AS A TEMPORARY STRING VARIABLE TU STORE A 
■FAiJLT“C0nT)IT 10N "TO BE INSERTED, ALSO USED AS A 
TEMPORARY^ VARIABLE TO STORE ONE OPERAND DURING THE 
0R"Dp-)fi>rn OPEkATIUN, ■ 

‘TJBET)'‘A'S"THE~CGMTR0L VARIABLE' IN TOR-NEXT' LOOPS.'" 
^LSO AS the pointer TO THE H (RESULT) ARRAY 

'DURING THc' OR Ruuno't, "ALSO USED AS AN INPUT 
VARI ABLE IN THE InPUT-mODE CHANGE ROUTINE. 

USED AS THE CONTROL VARIABLE IN FOR-NEXT LOOPS. 


A PARAMETER IfiUlLATlNG THE MAXIMUM NUMBER OF TFRmS 


596' * 

599 * 

600 * 
601 * 
60 2“ ■* 
60 3 * 
60« * 

605 * 

606 * 
60 7 * 
608 * 

609 * 

610 * 


82 

THAT CAig f3F STORFD I 'J THE FU\CTIC"'j f-ILE OF EACH 

FU'iC rinw. 

Yi iJSEO AS A te‘’Foka«y i/akiable to store the 

OA.vE OF A LT'IE to 8E FAULTED. ALSO USED AS A 
TE‘’-'HUK AB Y VARIABLE TU STORE OuE OPERAND 
DURING The or Ai'iD THE AwD RUuTIf'KS. 

ZJ ‘ USED AS A TEMPORARY STRING VARIABLE TO TRANSFER 
TERMS bET/jEEU arrays. ALSU USED AS AN INPUT 
VARIABLE. ALSO~iJSEO AS A TEMPORARY VARIABLE TO 
STORE the RESULT TERM oiJHifiG THE UR AND THE Ai\J0 
■ ~ ROUTINES, 


801* 

802* SUBROUTI-jE DESCRIPTIONS 

805* 


”805,* 
809* 
810* 
811* 
312,* 
813* 
81 «* 
815* 


programmer uEFINED SUBRUUnwES 
LINE DESCRIPTION 

5000 function-fill to array-file transfer. 


816* 6000 

817* 

'818* 6^00 ■ 

619* 

020* o500 

821 * 

822* 7000' 

823* 


fault/cdnstant-value insert lOri. 

MIM-ANO. AInD'S faulted VARIABLES aITH FP FUNCTION, 
MI'il-ijR. OP'S FAULTED VAPIABl.ExS .^ITH FF FUNCTION. 

OR SURROUTIME, 


82N* 7200 TER-i SORTING. 

325* 


826* 7300 PRODUCT TERN' DISASSEMBLY INTO LITERAL COMPONENTS, 

827* 


828* 8000 - AND S'UbROUT I N£ , 

829* 

030* '8250 ■ ZERO PRODUCT TERM DETECTION. 

831 * 

852* "” 6650 - -LI'TERAL SORTING. 

833* 


63a* 
835* 
836* 
837* 
838* 
839* 
8«0* 
8ai * 


900 0- 

' rootro 
1 1000 


array-file to FUNCTION-FILE TRANSFER, 

OLD FlJNCTIOr- SET/NEW FUMCTIOW SET COMPARISON, 
NLA function set printing. 


13000 


oscillation DETECTIUN 


83 


FiJNCriun r-I.\l.^IZATIfjN. 
I'lPOT-MODF CHANGE. 


a>H2*' "'17OO0 
Ha3* 

aaa“* " ~iaooo' 

<J05*_ 

9o0***** ****♦' 

901 * 

902* OIMEMSIUN STAftMEHTS 

905* 

904 * * « 1 

905* __ _ _ __ _ 

9'10'' DIN Tn^.ju^a) 1(400/3), U(50,2), P(200,2) 
920 OIH A«(Sl ) , DS (511 

■93(y ■ OTm " 

I 999* 

1000**"***’***** *'* * * I 

I 1 UO 1 **************** A-**** * 

I loo2* ■ 

i 1003* START OF MAIN PROGRAM 

rio'CTA*' 


* 

* 

* 



’'1006*********** 

; 1007* 

1¥08* 


1010 

OPEN 

"OLOl" 

TO 

: 1 , 

INPUT 

UPDATE 


I02u' 

open 

"ULOO" 

TO 

:2, 

INPUT 

UPDATE 

" 

1030 

OPEN 

"NE'/jQ" 

TO 

;3, 

iNPu r 

UPDATE 


iro'40“ 

■■dpfn 


:irr 

'INPUT 

UPDATE 



(1100 H9SU00 
1"105 YSarOO 
1120 Ii\lP(jT = ‘6 


\*ASSIGN value to LOUP LIMIT PARAMETER, 

\*AssiGiJ function max length parameter, 
\*SELECr btQUEUTIAL FILE ACCESS MODE. 


iir25'"IF C0 = 2 then 1950 \'*CHECK FOR tNIRT FROM RACE, 

11130 S = 0 \*IfNlTIALUE FUNCTION FILE SwjtCh, 

1135 PkINT^ENTER "I.viPur-TIMETIMIT’’7\*PRn^T' IwPUT-TIwe LIMIT " 

lUrt *ENTPY '■'ESSAGE, 

lUO InPuT“TO ' '\*EnTER "INPUT-U'^E limit. 

lias PRlMT"Ei^TFH RIPPLE-TIME L I MI T " ; \*PRI NT RIPPLE-TIWE LIMIT 

llat> 

1150 INPUT RO 

1155 r=r “ ■ 

IloO RUT 

llb5 «=R1 

1170 FUR 11=1 TO M 
1175 3=0 

.180 P0=0 

-K=l 


~ *EnTR Y"”'«i£SSAbE , 

\*ENTEP RlPPLE-TIM't LIMIT. 

*I NIT FA CrZE 'INPUT -TIME VARIABLE, 

\*SAVE RIPPLE-TIME VALUE AT START OF NEi« I TiPU T- T I ME , 
“A'^INlTIALnE~RIPPLE-TIME VARIABLE,' ' 

\*BEGIN PRIMARY SIMULATION LOOP, 

\'*INrT I ALUE' FUNCTION type Sif^ITCH, 

\*rNITIALIZE INPUT LIST POINTER INOEX. 
“■V*TMTrffLrzrTUi\iCT10 N“ARRAY SkUlTCH. - 


185 ' 

1190 *LUAi) FUNCTinra A r , \GOSUB SOOU 

195"" ■ rF"Trp(Ti';2)*Po;?)="FF" 'THEN rars - _ . _ 

19o *IS THE ELEMENT INPUT FAULTED? 

"200 ""F2=l \'»IF' YES/'SET FLA(TIND1 C A T TNG FIRST INPUT, 

205 Fl=l \*SET flag IMOICATlwG INPUT FAUL1. 

?nr ^*FJ'SE3Tr“FA‘ULTT~Ti70SUB oOCFu ' 

215 IF N( 1 I ,2J = "0ELAY" lhFi\i 1320 \*Ch£CR FOR DELAY ELEMEWf, 


84 


1217 -P0=P0+1 

1220 *LuA«J KUfJCTlUM Ai,hAv r..\GOS'Jf< 5000 

1225 IF I (PCn »23 +P0,2)="f-F" T^-’E^. 1?45 

1226 *Ib ELE'-^EuT I.OHUr FAULTED? 

1230' Fl = l " \*SET I.'jPUr FAUU FLAG. 

I25b F2 = 2 \*bEf FLAG Imj1CaU,.g 2,\o or > I^PUT, 

1240 *I.\SEKT FAULT. \GOSUH oOuO 

124b U N(11,2) = "DFF'' THEN 13l7\*ChECK FuW U FLIP-FLOP. 

I2ar TF'J=0 THFN 1270\*IS ZERC-FN BEING COPPOTLD? 

1250 IF NUl ,2) = "NAN0" Then 12hO\*OuE-FN IS BEIt'JG CO^'’PurEU, 

12Sr ■"“ ■“ ‘ " *CHECK ELFF'ENT TYPE. 

1255 IF NUl ,2) = "N0H- THEN 1280 

I2b0 ■ 'aPERFQR'^^ or OF" INPUT FUNCTIONS. \GOSuH 7000 
1265 *PRiJCEFU TO NEXT INPUT IF ANY.XGCTO 1285 

1270 IF U( II ,2)="nAN0" then 12HO\*ZEPO-FN IS oEInG COMPUTED, 

1271 *CHECK ELE^'EUT TYPE. 

1275 IF N(Il,2)="NnP" then 1260 

1280 *P£PFuRM ANO OF INPUT FUuC T I ONS. \GQbUb ttUOO 
1285"' IF PCI 1 , n- 2 <P 0 ThEn 1 320\*hAYE AlL ELE'^EnT INPUTS' 

1286 »8EEN PROCESSED? 

1290 FDR X=1 TO H9 \*M0. LOAD F ARRAY aITH PREVIOUS RESULTANT, 

1295 INPUT :H;X,2i\*GET TERM From h ARRAY. 

1300 PRINT :F;X, Z5\*PLACE TER<^ IN F ARRAY. 

1305 IF 2% = "." THtN 121 7\*EN0-0F-Fur>LT ION? 

1510 uEXT X \* RF.PFAT fop NEXT TeRn. 

1315 ^repeat for NEXT ELt'^ENT HiPUl.NGuTO 1217 

1317 aCALL'DFF ROUTINENGOSUB 14000 

1318 STUP 

1320 IF NlIl^Sls-FF" THEN 1335NAALL INPUTS HAVE BEEN PROCESSED, 

1321 *CMECK FOR FAULTED ELEMENT OUTPUT, 

1325 Fl=2 \*SET FLAG FUR OUTPUT FAULT. 

1 330 *I.'iStRT FAULT uN ELFMEnT OUTPUT , \G0SUB 6000 
1535 *TRAN3FFK RESULTANT y\ TO FN FlLE.NGOSUH 9000 
1 340 IF JOO THEN 1355 \*hAVE BOTH FNS oEEU COMPUTED? 

1545 J=1 ■ \*MU. SET SmTCH FOR ONE -puriCT I ON , 

1350 ^REPEAT FOR ONE-FUNC T I Oh, \G 0 TO llBu 

1355 NEXT~I1 \*REPEAT FUR NEXT ELEMENT, 

1360 N0=0 \*ALL ELEMENTS HAVE BEEN PROCESSED. 

-136V '■ ■ *CLEAK FUNCTION SET EUUALITY FLAG, 

1365 ‘CHECK Function set eouality.ngosuh ioooo 

1 370' TF N0 = 1 THEN 1380 \*AKE THE FUNCTION SETS FOUAL? 

1375 *.'JU, PROCEED hITH AfJ AL Y SI S , \GC TO 1410 

1380"R = R’-I \‘SUPPRESS RIPPLE-TIME INCREMENT. 

1390 IF T>=TO THEN 149')\*hA3 IwPUT-TIME LIMIT bFEN REACHED? 

1395 T=Tfl — \*rv,0. INC input-time VARIABLE, 

1400 Rl=RFl \*SAVE N'E». RIPPLE-TIvE VALUE. 

~1405“*CONTrJUE~SIMUL:ATin<M,\G0T0 1 475 
1410 IF 01Wn = '"' TNE'J 1 450\*CROSS-CUUPLED ELEMENTS? 

1415 IF' k9=1 THEN 1450 \*RACE ANALYSIS SELECTED' 

1420 IF K=1 IHE.I 1450 \*FIRST RIPPLE STEP?' 

1425 CLOSE :l \*CLU3E ALL FILES, 

1430 CLOSE :2 


85 


ralb CLust ;i 


laao LIUSE 

laas ChAI'MXI.mK "PACEi)OC" ■ \*PERFUKf-» WACE‘ ANALYSIS PROCf-DURE. 
l«bO__IF •notj Th£aj^ ^ao'SyCHECK UUTPUT HUOE, 
iASb *PH'IWT TATESr tQ'MTlurrSE r'.AfiOSUB llOOO' 
lA6b ♦PEKFOKfn uSCILLATlOI'i A>'iALYSIS PROCEDURE , \GnSUB 13000 
lA/0 IF"0<eol fHEJ l5y5\*POSSIBLE OSCILLATIUN.^ 

1A7B R = K+1 \*N0 OSCILLAIION IfyDICATED. 

ra7b ■ ' *I^C RiPPLE-TiME VARIABLE. 

ladO S=l-S \*St'vI7CH FUAiCTlUN FILES, 

" nes »cuN ri^ot ‘FOR \ext ■R'ipple-time incremea(T.\(,otu iwo 
iaa9 *I(VP'JT-Tli*'E LIMIT HAS BEFN REACHED. INCREASE LIMIT? 

'149XT PRl7Tr"0U‘ ruu .mISh TU £fTER A'wE^- TiMfc LIPI T--YES/i'jO, <CR> = N0,"; 
lA9b MHIjT Zi \*ENTErt HESPU^lSE. 

1500 IF ZJo^YES" THE.\ '1585\,*IF ‘N0"; E>tl f PROGRAM, 

1505 PRIi'j T”EwTER fl£v-^ IhPUTM IME LIMIT"? 

1510 input' T0'“ - -- - \*ENTER 'NErt IMPijT-TlMt LIMIT, 

1515 PRIi'jr'NE'M input MUDE — YES/NU. <CK> = N0.''r 

£520' rNP'Or rs ' N'iENltR response.'" 

1525 IF Z«<>"YES" THEN 1395 

■ 153(T“*£vTE:K'^ET"T'vPUrTHT0£.TGOSlJB' 18000 ' ' - - -- - 

1535 *C(JnTI,vUE_SIMliLATIQjN. NGOTO 13R5 
' 1595 ' GU TO "I 5^5 “ , 

1560 PRINf'EMER InPUT-TIME LIMIT"; 

"1565 INPUT 'TO " \*ENTER N£-^ INPUT -TIME LIMIT, 

1570 PRlNT"E>'<rER NE'v RIPPLE-TIME LIMIT"; 

“T575"ITIPuT~R0 V*£NTER"FrE:w- PIPPLE> TIMr LIMIT , ' 

1580 GOTO 1170 

'i585~rcni3E~ ; I " \*cluse all'files, 

1590 close ;<2 

1395 CLUS£"T3 

1600 CLOSE ;9 

1601 PRITJT""'GEl'TFFrATE~TrST ' SEQTJENCES--YEST/NO'. <CR>sM0, " ; ' " ' 

1602 INPUT ZT) \»riPUT RESPONSE TO QUERY, 

1603 ■IF"Z'6<>"^F5"'rHET'l 1 605'\ *DO~ftOT GENERATE SEO IF NO, 

IbOA CHAIN LINK "TE3TGN0UC" 

'1605 CHAT vj- LINK "’Sl-nOuC"*' \*PETURN 'TO INPUT PROGRAM, 


20 0 r# * * * '* •♦•*'*******»***'* * 

2002* SU6RUUTIw£S 

'200 3 *'* * ilt*V * *T~* * * iltit'i* * 



'iOOO************A*************i 


' 5u0'l* ■ "Subroutine TO' THANSFrK' F'UwCTlUN FROM 

5002* T^mCTI(|N_F ILE j^O FUNCTION ARRAY. 

5009 input = 0 \*RETURN TO NORMAL INPUT MODE. 

■"51105" F=2-J^t2*J''iS\G'=5-STj-2*J*'s\ff=rf2\'*C0MPUr£ CHANNEL NUMBERS FOR 


5006 *F» i;, AND H ARRAY FILES. 

■ 5'('10'7^t:'L'(TSE"rr\CLiJ5E~;2\C'LOSE" ;'3\CLOSE ';9V*CLOSE' ALL OPEN FILES. 

5008 IF NII1#2)="0ELAY" THEN 5a00\*UELAY ELEMENT? 
-■5009'nTPTTg“"FAPRTY"“Tu~;'rrTNrFUT“UPDSTE\*OPEN FlCr FOR F'ARRAY. 
5010 OPErvJ "GAwkaY" TO ;G# INPUT UPDATE\*OPEN FILE FOR G ARRAY, 


86 

50TT rrFE:R''"HARR'AY"- Ta' :H, I’ PUT l'PDfiTF\*OPE!'' FTLE FOP m ARkAY. 
bOl^ II- S=1 fHE.t bai8 \*('E FEP'^UwE .HILh F[LE SHUULU &E ACCESofn, 

S013 IF -J51 THe\ S016 \*LAST FN SET 1-4 OLD FILES IF SsO. 
boia ^PE^J "ouai” in :w I'jpur upua reN^rjEED a cne-fim if- j=o. 
■5’0r5TA-GnT0~NEXT 'STEP“ '\GOTU'5022 “ 

bOlb tUPEi-J "OLOO” TO I>jFI'T UPUA Tfc \ *f«itEO A ZEkG-F''J IF J = 1 , 

5017 *Goro NEXT STEP, \GoTO 5022. ' 

SOIH IF Jsl ThEW S021 \*LA3T FM SET IM NE‘A' FILES IF Ssl , 

5019 OPEN "ME'/.l " Tn :a, input UPDATF\*T'»EED a ri'jE-FN IF J = 0. 

5020 *GUTO NEXT STEP \GUTO 5022 

502r‘OPE)vr"NEwo"” TO :3, INPUT' update\*.%eeo a zepo-fn if J=1. 

5022 IF I(P(I1,2)+PO,3IO"YES" ThEN 5135\*lb THE ELEMENT INPUT 

5023 *A PRIMARY INPUT OF THE CIRCUIT? 

5029 *YFS. therefore# THE IwPUT FUNCTION MijST bE CONSTRUCTED. 

5050 U(l)=T+2ao \*COMPUTE EHCDIC EQUIVALENT UF INPUT-TIME, 

bOao CHANGE U TO Ti \*CONVFRT INPUT-TIME TO STRING VARIABLE, 

5050 IF JOO TT‘EN 5080\*FORF ZERU-IfiPUT OR ONE-InPUT? 

5060 Z*="" \*ZEP0-FN needs A QNE-INPUT, 

SOTO *CnNTiriUE' TO NEXT STEPNGOTO 5090 

5080 ZS="-" \*ON£-FN NEEDS A ZERO-INPUT, 

5090 IF KOI THEN 5120 \*lrJHICH ARRAY IS TO EE LOADED? 

5100 Xi=I (P C 11 »2) tPU, 1) f Zi+T5\*U)NSTRUCT INPUT EXPRESSION, 

5102 PRII4T ;F;liX5 ■ \*PLACC EXPRESSION IN F ARRAY, 

5105 PRINI :F;2,''." \*LOAO ENU-OF -F UNC T ION MARK. 

5110 *C0NTINUE TO NEXT STEPNGOTO 5300 

5120 Y« = UP(I'1#2) FPO,l)-FZi»T£\*CO(43TRUCT INPUT EXPRESSION, 

-5T22 PRINT TGtUY’B " ' •^*LOAO EXPRESSION IN G ARRAY, 

5125 PRINT :Gj2#''."\*L0AU EfiD-UF-FUNCTlON mark, 

5150 ‘CONTINUE TO NEXT STEPNGOTU 5300 

513a ‘ElEMENT Ii'fPUT IS not A PRIMARY If'iPUT. GET F fJ FROM PILE, 

5155 JS = I(P(I1/2J+P0#31 \‘GET INPUT ID NtjMOER. 

biao V = VAL(Jil \‘C 0 KVERT lU TO A imUMFRIC VARIABLE, 

5150 i^PU^ :J-2*S*J*3*S4-1 ;Y5*(V-n,X3\*PETRIEVE FN f!AME FROM FILE, 

51oi) FUR X = 1 TU 1000 \*lRAf)SFERS TERf-'S OF FN FROM FILE TO ARRAY 

5W0 INPUT : J-2*5‘J+3*S + 1 # YJ\*GET TERM FROM FRE. 

5160 PRINT ;G;X,Yi \‘PLACE TERM IN ARRAY, 

5190 IF Yj> = ”.'’ THEN 5260 \*L0UK FOR END OF FUNCTIOTi, 

5200 next X \*repf:ai Fur next term, 

5260 IF KOt THEN- 5300 \*LOAU F ARRAY? 

52/0 FOR Y = 1 TO X NaYES. TRANSFER FROM G TO F , 

5280 INPUT :G;Y,Y'B ■ \*GET TERR FROM G. 

52H5 PRI'VjT :F;Y,Y« \*PLACE TLRm jn F, 

5290 NEXT Y — '\*R'EPEAT FOk NEXT TERM, 

5 300 K = 0 VaCLEAR the akHAY St'^ITCH, 

5305 INPUT=5 \a5EQUENTIAL FILE INPUT MODE. 

5ilU REJURN \*RETURN Kj MAIN PROGRAM, 

5"aa0" HI =T+JF3'f3-2*S*J \aDEFINE CHANNEL FUNCTION FOR HARRAY, 

5902 OPEN "hARrAY" to ;h1, input UPUflTE 

5903 TF S=1THEJ 5990 \aCHECK FUNCTION-FILE SirvITCH, 

5905 IF J=1 then 5925 \aCHECK FUNCTION FLAG. 

5910 dPFN •»OLDO" TO ;2»If.PUT UPUATE 
5920 GOTO 5500 


I 


87 


5a2S" OHhij "Oi.i}r'“io : 1 , ir-puT ■ UPDATE 
'Saib Guru S50o 

'5^40'IP-Jil ThE’^1 sa60 \»ChEC*< FUNCTION FLAG. 

Saab OPt.N. i^O up date 

' SaSS GOTO ssuo"' 

SabO (3PE.V TO :a,I^HUT UPDATE^ 

bSOO IF' l(P(ll,<iJ»3T<>"YES",THEN< S560\*LHFCK FOK PRIMARY IWPUT, 

5505 U(l) = TtfJao \*COf-'PUTt EBCUlC OF TIME. 

5510 CHAMJt o'ru r$ 'n^Cumvert time to string, 

5515 IF JOQ IHE'nj 5530 \*LHECK FOR 0-FN FORMATION. 

5520' Z$ = "-" " \*F0HM - INPUT VAKIAbLE. ' ' “ ' 

5525 GOTO 5535 

- 55'30 ■/$ = '”' " ' \*F0RM I>.PUr VAKIAHLt. ' ' “ 

5535 YJ=I(PC11,2)»U+Z4 + T-S\*C0MPLETE VARIABLE FORMATION. 

'55a0 "PRINT ;hl;l,Y$ ' A»LGA0 FUNCTION. 

5505 PRINT 

5550 INPUTS* \*CHANGE INPUT MUOE, ' 

5555 KETUHtM 

'5560 JisKP'ai »2) ;T) '\-*G'£:t INPUT NAME iNDfX, “ ' 

5565 V=VAL(J*) \*C0NV£RT INDEX TO NUMERIC. 

" 5570-1 ITP^ijT~;2+3'='JP2'*S'*'JTVS* (17- ry;Xi\*GET IiiPUT FUNCTION. 

5575 TOR X=1 10 1000 \*LUA0 TERMS OF INPUT FUNCTION, 

'5560 ruPOT :2 + S-J>2*S*J» Y'4 

5565 PRINT CHljx.Y* 

■"5590 ■ IF y 5 = ";" THErrSbOO “ 

5595 NEXT X 

■5600'TNPUT=1B VSrCFrA-NGE~lF3PlJT“M0DE . 

560a *CLOSt ALL FILES. 

5605 close ~: rr~CL0SE :2's close :3\' close :a 
5609 *RE0PEM files FOR NEXT PROCESSING STEP. 

■"Sblo OPEN "F'AWRaT" To' :f» input "update 
5bl5 OPEN "GARRAY" TO :G, INPUT UPDATE 

5t>20'OPEN'"nARR51r" TO ' :H» INPUrOPDATE" _ 

5625 IF S=l then 5600 

5630 IF T=1'“ThE j"56'35“ - - — 

5631 OPEN "OLDT' TO :1,InT^UT ''PDAJTE_ , 

56 32"GT}IU 5700~ ’ 

5635 OPEN "OLDO" TO : 2, INPUT UPDATE 

SETT-GOTO 'STDTT — " ' 

5600 IF J=1 THEN 5650 

'55a5 'uPEN"'''^NnTr""70"":Z»»lNPUT' DPOATF”' ■' 

5607 GOTO 5700 

■5o50 OPEN n>)EliiO'^'~rcr'';Tri''>PTJT' UPDATE"" “ ' ~ 

5700 RfTURN 

50 (TcrjTiri *■***■>*** ** Tir *~ ******** *'****'* i** *'♦****♦* ********«*'«*******'******* 

6001* SUHROUTIME FUR INSERTING 

-^6WZ* F'A10S"AND 'CO^SrANr"TFPuTS. - -- - 

6003****************************************************************** 
■ o"0"r(rTF“F'T"=2~T'RFf'r6600'"V*CHECK' FUR OUTPUT FAULT (Fl=2), " 

6020 <i=I (P(I1 ,2) FP0,2J\*GET INPUT FmULI DR VALUE. 
■"6(r3XrT5’="r(PTn727fP07rT\"*GET"THPDT"CINEr'NAME." " 

6035 IF N( 11 »2) = ''UELAY" TH£N bbOO\*lS ELEMENT A DELAY ELEMENT, 


88 

■60a0“TF'F2=2 THE.i 6070 \*IS T^^E INPUT THE SECOND OK HIGHEP? 

60b0 C,l=F \*THE FIRST INP'JT. USE ARRAY F, 

6060 *COrTTirjUE TO NEXT STEP.XGOTG 6100 
60/0 Gl=G X^YES, t'St ARRAY G. 

6100“ rr~X5 = "-Sn" THEN~615 uX*IDENTIFY FAULT OK CONSTANT VALUE. 

6U0 IF Xfis"Sr' THErj 6200X*TPA|/SF£R COMPOL TO PROPER RnUTlNE, 

"6120 IF X^s'^0" THEN" 6250 » 

613U IF X'5 = "l" THEN 63u0 
61«0 PRINT"IRVALIO FAULT" “ ' 

6145 STOP 

‘•6150~ir'J=0 THEN 6180 X*CHECK FUNCTION FLAG. 

6160 Y$=Y^+"ft" X*INSERT STUCK-AT-ZEHO SYMBOL, 

6165"oijR FAULT' CONOITIOM RITH FF FUNCTION, XGOSUB 6500 
6170 HE! URN X*HETURN TO MAIN PROGRAM. 

6180 YS=Y?t"-*" X*INSERT NOT STUCK -A T-ZEPO SYMBOL, 

6185 »ANO FAULT CONDITION WITH FF FUiYC T ION, XGOSUn 6^00 
6190' RETURN' ' X*RETUPN TO MAITi PROGRAM. 

6200 IF J = 0 THEfj 6230X*CHECK FUNCTION FLAG, 

6210 Y3'=Y5 + "'“1" X*INSERT NOT' STUCK-A T-ONE SYMBOL. 

6215 *ANO FAULT CONDITION NITH FF FUNC T ION . XGNSUB 6400 
6220 return XaKETURN TO MAIN PROGRAM. 

6.230 Y5 = Yi. + "l" XftlNSEFT STUCK-AT-OME SYMBOL. 

o235'*nR THE FAULT CONDITION lf<ITh FF FUNCTION, XGOSUB 6500 
6240 »ETu«fJ X*RETURn TO MAIN PROGRAM, 

6250 IF J = 1 iHEfl 6280 X*CHECK FUiNlCTlUN FLAG, 

6260 PRINT ;Gl;U"l" X*LUAD INPUT VAL«)E UF ONE. 

6265 PRINr ;Gl;2»","' X*LOAD END-OF -F UNCT lUN MARK, 

6270 RETURN X*RETUMIm TO main PROGRAM, 

6280 PRINT :Gljl»"0" X*LOAO INPUT VALUE OF ZERO, 

6285 PRINT :Gl;2,"." X»LUAD ENG-UF' -FUNC T ION MARK, 

6290 RETURN X*RtTUF«y TO MAIN PROGRAM. 

o300 IF J=l THEN 6260 X*CHELK FUNCTION FLAG. 

6310 ftj=0, “ " XGOTn 6280 

6400****************************************************************** 

6401* SUE3ROUTINF TO AND FAULTED VARIABLES 'aITH FF FUNCTION. 

6402* FF FUNCnon MAY HE IM F, OR M ARRAY, 

6403* G1 MUST BE ASSIGf’E'D THE VALUE SPECIFYING 

6404* WHICH ARRAY CUT-TAINS THE FF FUNCTION,' 

6405**«***«***A************<k**A******«r*'***************************ft**A 

6410 FUR Yl = l TTJ H9 X*AnD FAULTED VARIABLE «ITH EACH TERM OF FN, 
6420 INPUT' :G1 JYI /Z3X*GET TERM OF FUfJCTIOW. 

6425 IF Z»="o" THEN b470X*CHECK FOR ZERO FUNCTIUNAL VALUE. 

6430 IF"Zrs"7"'THErr 6470X*CHFCK FOR END OF FUNCTION, 

6435 IF Z*o"l" then 6440X*CHEUK FUR ONE FUNCTIONAL VALUE. 

6436 '— Z3SYI- - ■■ - X*IF Z3=l then LET Z3 = FAULTED VARIABLE. 

6437 aCUHT IT'JUE TO NEXT STEPXGuTU 6450 

“6'4'aTJ TTfs-Zy+Yt X'*IF Z3O0 THEN CONCATENATE THE TERMS, 

6450 PRINT :Gl : YUZ1 >X*STu'RE THE MODIFIED TERM. 

6460"TIEXT"YI ■ " X*REPEAT FflR NEXT TERM, 

6470 RETuRfJ X*R£.TURN TO FAULT ITjSEHTION SUHHUUriNE, 

65 00****************************************************************** 

6501* SUBROUTINE TO DR FAULTED VARIA8LF.S «ITH FF FUNCTION, 


89 


bbO?.* KF FUi'JLTlUf) '"AY d£ IM F, l,, U« H AHRAY, 

o50i* CA '-USr dt H'AUfcD wlfri THE VALUE UF F, G/ OR H, 


650A***********fr*******i 


6510 F(JK Yl = l TO H9 \*SCAN TERMS UF FF FUNLTIUW. 
o5du'~ 'I-'wPUT :Gr;U“,Zi>\*G£T term FRO^t ARRAY,' 

6525 IF Zs = "‘J" THEN o550\*L00K FOR ZERO FUNCTIOHAL VALUE, 

6527 ■ IF Zj) = "V' THEN' 6570\*LuOK FOR OUE FUNCTIONAL VALUE, 

6530 IF Z3i = "," THEM oS50\*L00h FuR F.NO UF FUNCTION, 

65^0 NEXT VI \*rEPEAT FOR NEXT TERM, 

6550 PWIhT :G1;Y1,YT \*I'jSEPT faulted VARIAFjLE AS nEv'J TERM 
bSSr *(jF' NOoRZERO' function. 


65o0 PR^^^ ;bl ; Y1 f 1 , ''\*LUAD ENU-OF-FUNCT ion mark, 

6570 'REIURN ■' “ V*RETLiRN'TO F AULT " INSERTION SUBROUTINE 


6600 Gl=H 

6601 IF XJ. = "S0" THEN 6630 
6605 IF Xi. = "Sl" THEN oo65 
6610 IF Xli='’0" “THEN 6700 
6615 IF XF = ’M" THEN 6735 
6620 'PRl'NT "iNVALrO'T-AULT," 


\*UEFINE channel for hAHRAY, 
\*3TUCK-At-0 FAULT? 
\*STUCK-AT-1 FAULT? 
\*C0NSTANT 0 VALUE? 
\<»COnSTANT I VALUE’? 


6625 STOP 

663(T“IF'^=0 “TKE>r6650 \*CPECK FUNCTION FLAG, 

6635 Yi = Y'k + "-x" \*INSERT -FAULTISO) SYMBOL, 

6Sao *lN3ERr FAULT IiJ FunCT I0N,AGUSUB biioo ' 

6695 HEIURn 

6b50 Yi = Y1) + "*" ■ \*InS£RT so FAULT SYMBOL, 

6655 *lN3ERr FAULT I FUNCT lON.XGOSUd 6500 

d660"RFTURN ■ ~ * ' 

6065 IF J=0 Then 66B5 \*CHECK FUNCTION FLAG, 

6670 y» = YSt"'i" \*IP1SERT S1"FAULT SYMBOL, 

6675 *INSEHT FAULT IN FIJNC TION\GOSUb 6500 
66rt 0 Rf T URn 

6665 Y.fc=Y£ + "-i'' \*INSERT SI- FAULT SYMBOL, ' 

6670' *INSERT~ FAIJLT"IN~FUNCTI0N\G0SU8 6900 
6695 RETURN 

6700 ■ IF ■Js'nTHEU 6720" '\xCHECK FUNCTION FLAG, 

6705 PRlrgT \*LOAO CONSlANT I, 

6710 'PRINT" ':F;'2',"',"“ ' 

6715 kEIURN 

6720-TRI,<r \*LCAD CONSTANT 0, 

6725 print :F;2»”.'' 

673'(r"RFTTJRi\r " ' ' 

6735_IF J=l THEN 6705 _ \*CHECK FUNUIUN FLAG, 

6/9 0“i;Cnii"'b720"' ■ 

6H00 Xi=N(Il,S) \*UET FAULT CONDITION, 

6802'^3'=Tnir7n' V*6ET'"CiaTPUT'LlNE'NA.VE, 

6809 Gl=h N*FF FUNCTION IS IN h ARRAY, 

6'807" IF" X f=T'T'(7''"'TMF;Fr'6'B5o\iT(y£'f7nF'Y 'rALJUr 'CC'NOIT ION,' 

6810 IF Xb = "Sl" THE'-i 6860\*AS FIhST STEP IN TRANSFER TO 
6'8'2'0'~ I F“"x ■* = " O'”"' T H E' N“7) 87 0"' \ * P R 0 P fR" P R 0 C E S S I N G' R 0 U T I N E . 

6830 IF Xb="l" then o880 

68’9l)""GOl'0'"6T9'0 ' 

0899 *CHECK Function flag (ji for final routine selection. 


90 


JSO the j bloO 
6855 Guru bldU 
6860 IF J = 0 THETi 6210 
6865 GUIO 62i0 
6870 IF J=1 Then o 280 
6875 GUIQ 6^bU 
6880 IF J=l THE:n 62bO 
6885 GOTO 6280 

7000****************************************************************** 

7001* SU8HUUTlMt FUH UWlWG Tn“0 FljfjCTlUNS. 

•■'7002* ■ ONE RJNCTION MUST BE IN ARRAY F AND THE SECCfMO IN ARRAY G, 

7003* the resultant F'JNCTIUM is placed in ARRAY H. 

7000* called by the main program only. 

7005* CALLS THE SORT SUBROUTINE AND THE r-ll N IMI 2A T I ON SUBROUTINE. 
7006************************ ****************************************** 

7010 input ;E;1,aI \*GE r FIRST TERM OF FUNCTION FROM F, 

7011 IF Xi<O"0" THEN 7035\*CHECK FOR ZERO FUNCTIONAL VALUE, 

7015 INPUT :G;l,Y6 \*GET FIRST TERM OF FUNCTION FROM G. 

7016 IF Y5o"0" THEN T075\*CHFCK FOR ZERO FUNCTIONAL VALUE, 

7020 PRINT !h;l,"0'* \*BUTH INPUTS ARE ZERO. RESULT IS ZERO. 

7025 PRINT :H;2,"." \*LOAO Ef\:0-OF-FUNCTION MARK, 

7030 REIURN \*RETURi'- TO MAIN PROGRAM, 

7055 I.NPUT :G;1,Y-B \*GET FIRST TERM OF FUNCTION FROM G, 

70 i6 IF Yi<>"0” then 7U0\*fIRST INRUT NOT ZERO, IS THE SECOND? 

70a0 FOR X = 1 TO H9 \*SECOf'.D INPUT IS ZERO. 

70a5 IMPUr :F j X, Xi\*RESULTANT IS EQUAL TO FIRST FUNCTION, 

70«6 'PRINT :M;X,XJ 

7050 IF Xis",« then 7060\*LU0K FOR END OF FUNCTION, 

7055 NEXT X \*REPEAT FOR F^^EXT TERM, 

7060 *SURT the TERMS, \bUSUb 7200 

70o5 ‘REDUCE THE RESULTANT FN.NGOSUB 17000 

7070' RETURN \*RETURN TO MAIN PROGRAM, 

7075 FOR X = 1 TO H9 \*FIPST FN = 0, SECOND FNOO, 

7080 ITPUT :G;X,r$ \*RESUL TANT F'N = SECOND FN, 

7081 PRItvil ;h;a,Y5 

7085 IF Yj> = ''." then 7095\*L'JOK FOR E^D OF FUNCTION. 

7090 NEXT X \*REPEAT FOR NEXT TERM, 

7095 *SORT THE TERMS. \GOSUH 7200 
• 7100' *REDUCE THE RESULTANT FN.NGUSUB 17000 
7105 REIURN \*RETUPn TO MAIN PROGRAM, 

7110 INPUT :F;l,X-6 \*GET FIRST TERM OF FIRST FN, 

7111 IF XJO"l" then 7130\*CHECK FOR UnE FUNCTIONAL VALUE, 

'7n5'PRri'nn:h; ~ \*fir^st function is one, result is one, 

7120 PRINI :H;2,''." \*L0AD EnQ-OF-FILE MARK, 

7125 RETURN' ' \*RETURN TO MAIN PROGRAM, 

7130 INPUT ;G;1,Y« N*GET FIRST TERM UF SECOND FUNCTION, 

TTir IF'~Yio"l" THE^-'71S0\*CHECK FOR ONE FUNCTIONAL VALUE. 

7135 PRINT :H;l,"r’ \*SECUND FN = I, RESULTANT Fm =1, 

7r90'PRIf'4T ' \*LQAO END-OF-FUWCTION MARK. 

7145 RETURN \*PE1URN TO main PROGRAM, 

7149 *NEITHEK INPUT FN IS ZERO OK ONE, COMPUTE THE RESULT, 

7150 Y=l \*II’Jl TI ALIZE pointer TO m ARRAY. 


91 


ro'HP 


Y=f + 1 


7155 FOR X=1 
7lb0 
7161 
7165 
7l od 
7170 
7175 XT X 
7160 Y=Y+1 

7165 Ft)R X=1 ' Tu HR 

7167 irjPuT 

7166 'PRINT' :H; Y, Yi 
71 6R 

7lRl Y=Y+1 

71Ri NtXT X 
7195 *SORT TERMS, 


\*CURY FIRST Fn Into m ARRAY. 

I'mPUI ;F-;X,xi \*GfcT TERF UP Fim, 

PRIhT ;h*Y,/B \*PLACE TERf-t Ih H, 

I'jPur ;P ; X + 1 , Xi\*GET NtXT TERi^ UF PN, 

IF xi="'"^ THEM 71HU\*e.\lD UF FtM? 

\*NU, INC PulMTtR TO h, 

\*irMC POP4TEH TU'F. 

\*YES, INC POINTER rO H. 

\*C0PY G Into H KOLLOViiING F, 

\*g£t term of G. 

\*PLACE TERM' IN H, 

IF YS="," THEN 71V5\*LOOK FOR END OF FN G. 

\*END MOT REACHED. INC POINTER T0‘ H, 

\*1NC pointer to 6, 

SGuSUB 7200 


7197 *REU'JCE RESULTAMT FUMC T ION, \GUSUB 17000 


7199 return' 
7200**, 

720 1* " ‘ ■■ 

7202* 

7203*^ 

7209* 

7205* 

72u6*** ***** 


\*RETUPI4 TO MAIN PRUGRAM, 
!********************* 

“sijbRounNE~To“ SUP r The terms of a function, 
FUNCTION MUST 8E STURED IN ARRAY H BEFORE 
'BOPTIfiG RUCESrLENGTH' OF TERMT ALPHABETICAL/ 
CALLFO by np AfO AMO SUBROUTINES. 
calls no SUBRUUTINE'S. 


numerical 


'7220 FOR *=1 in 100 \*C0UNT NUMBER OF TERMS IM FN, 

7230 INPUT :H;X,2i) \*GET A ILRM, 

'T23T IF'TSrT" THE'iJ-7250 ■\*EN’D 0F"'FUiMCT ION? 

7290 NEXT X \*NC), 

-7299 *x = THE* hummer OF TERMS IN H PLUS 1. 

7250 IF Xs2 Them 7500 \*CHtCK FUR SINGLE TERM FM, 

7252'‘X0 = X ■ \*SAVE 'X FOR USF AS SORT LOOP LIMITER, 

7255 X1=X \*SAVE X FOR STORE LOOP LIMITER, 

72d0 FOR )T=rT0" xO-2 ' “\*USEr“A “BUBBLE' SORT TO ORDER THE TERMS. ~ 
7270 ImPUT :h;x,X4 \*GET FIRST TERM OF H, 

7272 “' INPUT' ;h; x + l , ri \*GtT AO'JACfNT TERM'OF H. 

7279 IF Xi><Y1> them 75lO\*COMPARE THE IER^•S, 

7280' *Rt'VERS£' THE' ORDER OF TH'E'Ti^O TF.RMS, 

7270 PRINT :H;X,Y4 

'7300 " 'PRPrr 'IH-fX + l ,x5 ' ~ 

7ilO NEXT X \*REPEAT FOR NEXl PAIR UF TERMS, 

-73'19"* UNF^TER-M hA's- BEET- pLACET' r>. ITS PfTuPFR PLACE. ' 


7320 X0=X0-1 \*DECREMtNT SORT LOOP LImITER, 

'T330“ IF' xo>Z~r'H'fTj ■7260'~\*H'AOE“ALL 'TERMS 0EE^ ORDERED? 

7390 XO=Xl \*YtS, RESTORE xO, 

“739 9-'>x'rjprTT7>rrE“TFF’'TS““rrcir'Mm--Br REMOVED.' 

7395 FOB X=l TO Xl \*COMPAHE ADJACENT TERMS FOR EQUALITY. 

‘7397 TMPirr'rr- x'T'xr.i \*GEr“A' tefm'; 

7346 IF XS="," THEM 7920\*END OF FUNCTION? 

‘7350 Tf4PaT3H-;-X + r77t\*N0." 'GET' ADJACENT TERM. 

7 551 IF Xb = Yl> then 73oO\*ARE TERMS IDENTICAL? 

■“7355 *^vr, — iTET"'MEr)rr'P'ffrF7\G0Tcr79rn 

73ftO X 0 =xo -1 \*YE3. DECREMENT TERM COUNT, 


92 

--7365 F0R"T=X4-1 TQ- X1-1\*PEW0VE duplicate TERM AiND COMPACT H. 

7170 INPUT :H; Y + 1 , X3>\*GET TERM FROM H. 

7171 PRINT !H;Y,X5\*MClVt TERM TO NEA' POSITION IN H, 

7380 IF X5="," THEN 7alO\*fND OF FUNCTION? 

T390 .^TEXT-'Y • \*REPEAT FOR NEXT TERM, 

7010 mEXT X \*REPEAT FUR NEXT PAIR UF TERMS. 

“7020 F0R~Xsr~TCrX0-2- '\*SORT TERMS by LENGTH USING BUBBLE SORT, 

M30 INPUT :M;x,xi 

7031 - “"INPUT :HJXF1,Y5 - - 

7032 LlsLEN(XiI 

~T03'3 t25LETTCY33 

7030 IF LKSL2 THEN 7a70\*IF TRUE# 00 NOT REORDER, 

7000 PRINr":H;X,Yi \*REORDER. 

7050 PRINT :h;X‘FI#X3 

7070 NEXT X \*REPEAT FOR NEXT PAIR, 

7080 XO=XO-I \*OECREMENT LOOP LIMIT FOR NEXT PASS, 

7090 IF X0>2TH£N 7020 \*SORTING COMPLETE? 

7500 RETURN \*YES, RETURN TO CALLING PROGRAM. 

- "T80'0*Vi*if ****** *T****^ir*i* ***♦'»*’**♦**** ******************************* 
7b0i* SUBROUTINE TO DISASSEMBLE A PRODUCT TERM INTO ITS 

78ff2* "LITERAL’ COMPONENTS, A LITERAL IS A VARIABLE NAME OR A 
7803* COMPLEMENTED VARIABLE NAME TOGETHER wITH ITS TIME TAG 
7000* OR FAULT SYMBOL, 

7805* TERM IS PASSED TO SUBROUTINE IN X4, LITERALS RETURNED 

780o* ' IN' A$ ARRAY, CALLED BY LITERAL SORT SUBROUTINE, 

7807**********a»****************************************************** 

7810 F5=0 ■ \*CUEAR SPECIAL CHARACTER FLAG, 

7815 Zis"" \*CLEAR DUMMY STRING VARIABLE. 

7820 AST— ~ . \*INITIALIZE POINTER TU A$ ARRAY,- 

7830 L=T-F:M(X$J N*C0MPUTE LENGTH OF TERM, 

7835 FOR X3=l TO L -\*8EGIN DISASSEMBLY OF TERM. 

7800 IF X4( ; X3» I )=-•" IHtN 7900\*LOOK FORSPECIAL CHARS (-), 

7802 IF X4C ;X3, n>"Z" THEN 7900\*LD0K FOR TIME TAG (NUMERAL), 

7800 IF X4(:x3»n<"A" THEN 7900\*LUOK FOR FAULT SYMBOLS (I/*), 

7850 IF F501 THEN 7910\*END OF LITERAL REACHED? 

7860 A5(A)sZ4 \*YES. PLACE LITERAL IN At ARRAY. 

7861" - *END OF LITERAL IS INDICATED jYHF.N A SPECIAL 

7862 *CHARACTEH IS FOLL0*y£D BY A LETTER, 

“7863 — - - - *THE LETTER IS THE F I RST - CHAR AC TER OF THE 

78oO I *NEXT LITERAL, 

7870 Z$sXiC:X3»l)' \*BEGIN CONSTRUCTING NEXT LITERAL, 

7880 FbsO ■ \*CLEAR SPECIAL CHARACTER FLAG, 

■'7890 A^Afl \*-INC-'POINTEH TO At ARRAY, 

7095 GOTO 7920 

7896 ■ *COrTTNUe PROCESSING TERM, 

7900 F5=l \*SET special CHARACTER FLAG, 

"79nr Z"FsZT+xr(:X3TU\*C0NSTPUCT literal; 

7920 NEXT XS \*REPEAT FOR NEXT CHARACTER (’F TERM. 

7930 -AtrA'jsZt -- \*LOAO LAST LITERAL OF TERM IN At ARRAY, 

7900 A$IA*1)="." \*LUA0 END-OF-LI TERAL mark, 

7950 RETURN “ \*RETUPN TO LITERAL SORT SUBROUTINE, 

8000****************************************************************** 


_ 93 

"8O"0r* biJ-iHOUTl'-lE T(1 HERFOkM THE UUGICAL A*\D UF 

^00^* Fi'n) FijNC I inriS. 

aOOJ* “ THE I-lPUT Fur'JCTIdi'jS ARE PASSED HM ARRAYS F AMD G, 

aooa* THE HESULTAMT FU-'-CTlOM IS KETURMED In ARRAY H. , 

'BOOS* talled” 01' '■•i'Ai'‘'r pRo'GPA>' (bi'^2) AMO race program, 

800<5*_ CALLS_ZER(D product detect SiJBR iHibO), LITERAL SORT 

8007* SOBRCrtobOJ, TERM SORT SUHR(72uOJr AnO 'M I ,\j IMJ ZAT lOM SU0R ( I 7000 J 

80 0H*******-»*^k*************'*************************/k***********t»***** 

8010 IMPOT ~:F; I /XS" \*CH£CK FUR ZERO EM VALUE. 

8011 IF x'i = "0" THEM 80i0 

'SDao imkut :GTirn>' \'*chelk' fur' zero fm value,' " 

8021 IF YSO"0" the m 80 50 

"Soio^PR iMT' :' h; r;:''o" " \'*resui:t is Zero, 

80 AO PHIMT ;H;2»"," 

■ 80/45"RErURM" ■”"''\*RETURM TO CALLING PROGRAM, 

80SU IF X1> = 'M" THEM 8058 _ \*CHECK FOR ONE VALUED FUNCTION, 

"8051' IF Yi<>''i"‘THEN'B06d \ *CHECK F UR' ONE VALUED FUNCTION,' 

8052 FOR X = 1 TO h9 \*2MU FM ONLY IS UNE Va'luED, RESULT = F, 

8053 ' IMPOT ;F;'X','X$' \*GET TF.RM OF F, ' . - . - 

8050 PRINT ;H;X,X5 \*PLACE IN h ARRAY, 

■ 8055 rr Xbc”."" TFlEf'I'arreD “ViEN'O OF FUNCTION? 

8056 NEXT X _ \*REPEAT FOR NEXT TEH^>. 

8057 *PRnCEE0 TU F ijNC T IOM“ REfJUC T ION STEP,\GOTO 81b0 

3058 IF Y^<>"^' THEI rtOo2\*l-ST FN IS 1-VALUED. IS IHE 2NU FN 1-VALUEO 

■ 8059 PRINT \*B0TH FNS ARE 1-VALUEU, RESUL T IS 1-VALUEO. 

80b0 PRINT rHjZ,"." 

-5 OoT' RETURN- V*RETgpN“TO~C ACLTNG PROGRAM,' ' " 

8062 FUR X=l TO H9 \*1ST P N IS 1-VALUED. 2ND IS NOT. 

80-63 INPUT' :G;X,YJ \*RESULT ="G. " 

806A PRINT ;H;X,Y£ 

8065 IF Yj. = "." them 8160\*EnO’OF FUNCTION? 

H0o6 NEXT X 

806-7- *proceed-- T o- MrNrMrzATTnTrsTEP,\GDTfr^8i60 - - 

8068 .\.= l \*mEIT'HER input IS CONSTANT-VALUED. 141 T POINTER TO H, 

60o9 PRINT \*INITIALIZE H TO O-VALUE. 

80 7 0 PKKjT :H;2,"." 

8075“FUR X=tT0-H9 “ \*0EGIM PRODUCT-TERM FORMATION LOOP. 

0080 IHF'UT :F;X,Xi \*GET TERM FRO” F. 

•8090 rnR-YTsl'-TO H9 -\«T3EGIN-LOOP FOR ACCESS TO G, 

8091 INPUt :G;Y,YS\*GET TERM FROM G, 

"ffa9-2 Zli = xTFY5 V5F0RM" PROmjCT'OF TERMS , - 

8093 PRINT :H;«,ZS»\*PLACE RESULT IN H, 

~8I00 -FCHEC'fV-FDR’ZERO-PRODUCTTXG-OSiJB 825o ' ' 

8110 input sG; YFWYi\*CHECK G FUR ENU OF FUNCTION, 

“Brn rF'Yi;=’*T’^TrTEN~8 m 

8120 next Y \*M0I ENU of G, GET NEXT TERM, 

■ 81T0 INPUT iTfrCf \ rx'i'\"*CHEr'K~r'TuR “FfTfT oF FUNClIUN,' 

8131 IF xi = ''," THE'4 8150 

■ 8-r-fTJ“NEx'T~'X- "\*N0T-"FT4D of F', GET NEXT URM. 

3150 IF /.<>1 THFil 8155 \*ENU OF BOTH FNS REACHED, 0-VALUE RESULT? 

'“8 r52~P PTlvrrTRT IT" 0 " V* YE 57 '^'L 0 A D ‘0 - V A L LC T N H , 

8153 REJURN \*RETUPN TO CALLING PROGRAM, 



04 

6I'S5 PRT-JT IPAD ENO-nF-FL'‘'irT I O'J f'dRK, 

dloO FOR X=l TO H9 \*HEOt\ STEF SY L'HOZRI'Jb UTS lU EACH TtWi^o 

«165 ■ INPdT SH;X,X5 ■ \*GET A TEn” FHO'^ H, 

ai6/ IF Xir«,» then ai9U\*E^0 OF FUnCTIO.'I? 

8170~ - *rjO.' 'ORDER" literals. \G0SU6 8650 

8175 PMK’T :H;X,Z& \*REPLACt OROEKtn TEK^'i, 

8180 OFKT X ' ■" VoREPEAT /Oft (^ieXl TEK.-1, 

8190 *rjKD£R TtKf^S OF THE F UMCT ION. \GOSUb /200 

8200 *REM0VE REDUNDAfJT TERMS. \G0SUB 17000 

8210 HEFURi'J \*RETUPi\ TO CALLING PROGRAM. ' 

8250 **“^*'* * * * ***'* ■***"*■★ *************** *l*********«A;*****JHHHk**ft*********** 
8251* SUHrtOUTriE fU CHECK FUR ZERO PRODUCT lERM, 

8252* ' " TERM TO BE CHECKED l^AS FORMED BY THE AND SUBROUTINE 

8253* AND nAS PLACED I''( THE H ARRAY. THE TERM IS RETRIEVED PROM H 

8254* for processing, IF THE TERM IS ZERO, THE POINTER TO THE 

8255* H ARRAt IS NOT INCREMENTED WHICH RESULTS IN THE TERM BEING 

8256* overwritten BY ANOTHER TERM. IF THE TERM is NON-0/ W IS INC. 

625,7* CALLED BY THE AND SUBROUTINE, 

~8 25 8* ****#♦♦ *"*r** ************************ ****************j»*<k*<t******jHk 

8260 C=l \*SET THE SPECIAL CHARACTER FLAG, 

8270 D = 1 \*SET THE i'UNUS FLAG. 

8280 l$z”* \*CLEAR A TEMPORARY VARIABLE. 

8290-85 = "’* \*CLEAP ANOTHER TEMPORARY VARIABLE, 

8300 IfiPUT :H*f,,Y'6 \*GET TERf TU HE A:vJALYZED. 

8301 L = LEN(YJIJ \*C0MPUTE LENGTH OF TERM. 

8310 fur A=l TU L \*HEGIN TERM ANALYSIS. 

-8-320— XlisYICA,!) — \*EXAMINE' A CHARACTER FROM YS. 

8330 IF X4>"Z" THEN 8350 \ *NUMERAL? 

- 8332 IF Xis"-" then 8350\*F'INUS SIGN? 

8334 . IF Xis"*" THEV 8350\*STUCK-A T-U SYMdOL? 

8336 ~ IF X3 = **l" THEN 8350\*STUCK-AT-1 SYMBOL? 

8340 IF C=1 THEN 8400\*END UF LITERAL? 

8541 *YES, LOOK FOR ITS COMPLEMENT , \GOTO P420 

8350 C=0 \*SPECIAL SYMBOL FOUND, CLEAR FLAG. 

8360 IF XSo"-" then 8370\*HAS THE SYMBOL A - ? 

8365 0=0 \*YE3. CLEAR FLAG. 

8566 *r,ET NEXT CHARACTE R, \GO TU 8600 

83/0 IF DOl THE J 8400\*CHfcCK FUR COmPLEmEF TED LITERAL. 

- 8390 \*NUT CUf’PLEMEN [ ED, INSERT MINUS, 

8400 Z3 = Z4 + X'». \*CUNSTRUCT TEST LITERAL. 

0410 -- *G£T NEXT CHARACTER, \GUTU 8600 

8420 C = 1 \*SET special CHAkACTER FI AG. 

--B450 B1=A - ■ ■ \*SAVE"P01NTER TO Y3, 

8440 FOR B=Hl To L \*FINU NEXT LITERAL IN TERM. 

8450 -- ■ - "INPUT :H;h/Y'5 \*GET THE TERM FROM THE FILE, 

8451 X4 = YtCb,n \*GFT A CHARACTER OF THF TERM, 

-8^50 — TF- XI>-*r"- THEN P430\*A NUMERAL? 

6462 IF X4="-" then 8480\*A MINUS SIGN? 

8464 rF-X3 = **-*-" THEN -8480\*STUCK-AT-0 SYMBOL? 

8460 IF Xk="l" ThtN 8480 \*STUCK-A T - 1 SYMBOL? 

8470 IF C=1 THEN 8490\*END OF LITERAL? 

8471 *YES. compare TO TEST Ll TERAL . \GQT0 8510 


I 


95 

■8<l30' ' C = U ~ '■\*bPtr.l4L ChAPACTtP. CLfrAk FLAG, 

tts=aj*xj \*ccJ^iSTwucT LirtKAL. 

'8500 *GET <jEaT CHARaCTEP. \*GUT0 854u 

8510 IF = rHf-N tt6i?0\*CUMPARf wlfh TEST LITEMAL. 

. asao " C=T ■ '\*r40T s , SET SPECIAL ChAK FLAG. 

' 8530 _8is"*r \*CLEAH TEKPORAKY VAHIAttLF, 

8535 *StARCH FUR NEXT L I fEKAL". \GOTU " 8<450 

85'iO f'jbxT 8 \*REPEAT FOK TmEXT CHARACTER. 

8550 ' IF ZizBi' FHEv 86^6 \WCOMPARE LAST LITERAL wITM TEST. 


I 


8560 _ _ C = 1 

8570 ■ " "D=r 
8580 _ ZA=-" 
8590 ■ 83="" 

8595 ^DEVELOP 
8600 ^>IEXT A 
8610 = 

8620 RETURN" 


_ _\<SET SPECIAL character FLAG. 

■\t»SET THE'MINUS SIGN FLAG. 

__\^CLEAR A TEMPORARY VARIABLE. 

\*CLEAR ANOfhER TEMP VARIABLE. 

A ME*i TEST literal. \UOIO 8320 

V*REPEAT FOR NEXT CHARACTER. 

_ _ \*NOn-0 term. INC POINTER TO H. 

■ \vreturn To AND subroutine. 


8650 ************************•**«•♦*******.**** *********************** 

8b5'l*“ yiJHRUUTl ME n 0~SURr"T'HE ' literals IN A PROUUCT TERM, 

9652* literals ARE PASSED TO SUBROUTlwE IN AND THE SORTED 

865T* TER'-^' IS' RETnRNED‘'lN~ZS.' - - - 

865‘J* called 8Y THE AND SUBROUTINE, 

8655* "CALLS ThF TERM DlSASSE'^‘8LY SUBROUTINE. 


'■ 86o0' *0ISASSE vISlE ThE TEkM INTO LI TERALS, \GUSU8 7800 
86oi C=u \*IN1TIALIZE COUNTER, 

I '86o8 QT=A \"*GET'fNUV'BER OF LITERALS IN TERM FROM SUBH 7800 

8670 FUR Asl rO bl \*S0RT TH£ LITERALS IN A* USING A BUBBLE SORT, 

' 8‘680' "TF A5\A>n="." "THEN 87»10\*ENO OF LITERALS, 

8<j90 IF Ai(AJ<A1i(A + l ) THFN 8730\*C0MPARE TWO LITERALS, 

8700 " llzAiU) ‘ \*kE-0R0EHING NEEDED, SAVE ONE LITERAL, 

8/10 Ai(A) = AS>(A*l 1 \*SNAP PLACES UF THE T/'O. 

8720 Af CA*n=Zi~ — \*C0MPLETE THE"S»^AP, 

8730 NEXT A \*REPEAT FOR NEXT PAIR, 

87a0 IF T3l = r IHEN 0/50 \*LhECK FUR END UF SUfiT, 

8745 Bl=ol-l \*D6CREASE LOUP LIMIT. COUUnUE SORT, 

8 7a6 "*RErPEAT~FUR NEX T PASS "THROUGH ' THE LI,ST;\GUT0 8670 

8750 FUR A=l TO 20 \*SORT COMPLETE, LOOK FOR DUPLICATE LITERALS, 

" 8760 “ -ir"ASrA'Vrr="," THEN-6630\*LOOi< FOR END OF LITERAL LIST.' 

8770 IF ASiAJsAHA*!) ThEN 8/80\*LOOK FUR IDENTICAL LITERALS, 

" 8771 ■ ■ '*'nOT“TDENT rCAC,“ CunTIwUE SEARCH, \GOTU 8820 ' ' 

8780 C=C_*1_ _ _ \*1NC COUNTER, 

am'- F"OR B() = A TO 2"0 "\'*REM0VE DUPLlCAr'E LITERAL FRU^’ LIST, 

8800 AJ(i3'))=A5(80>l )\*SHIFT A LITERAL, 

"3805 rF“TS-3C9'JT="".""TREM''ff820V*END CrLIST?""- “ ‘ ' ' ' 

8810 NEXT 80 \*CUNTInUE SHIF TIi'<n, 

“flr820“NE'xT" A \'*REPEAT"F"OR "NEaT PAIR, 

8850 Z3="" \*CLEAR TEMPURAkY VARIABLE, 

'8815 Fur" Asl 10 20 S'3b£'GlN"'ReC0i'iSTRUCTl0N' OF ■ PRODUCT TERM. 

8840 IF A3(Ajs”.- then 8ft/0\*FNO OF LITERAL LISTV 

"'885‘T jrzUnvXM T*M0r “■*rPPEND"'TO TERM, 

8860 NEXT A \*REPEAT FOR NEXT LITF.RAL, 


96 

-■ffffTD-PETURR /- — - \*RETUPir-ANO SUBROUTINE. 

9000**********«A******************************«**i^*«*#«***A*A****«**** 

900r* SU3R0UTI >je TO ‘TRANSFER A FN FROM AN ARRAY TO A FILE. 

900d* FUNCTION IS AL*<AYS TRANSFERRED FROM ARRAY H, THE FILE IS 
■90UJ*’ — ETTHER" OLDJ .“OLOOr NE«0, OR~NEv»l AS A FUNCTION OF J AND S, 

90ua* CALLED 6Y THE MAIN PROGRAM tSIM^), 

9 0 0 5 V * *T jHT*T ********* * V* '*********>******•*«***************************** 

9008 INPUTsO ‘ \*RETURN TO NORMAL INPUT MODE. 

-9010“CUaSE" :G ~ - ■ A*CL0SE' file ASSIGNED TO CHANf4EL G. 

9012 on G GOTO 90 1 a , 90 1 6 , 90 1 8/9020\*OPEN ,F ILE TO CHANNEL G. 

~90 r9“0PEN'“'’0UDl " " TO“ : I V ■ INPUT~UPDATE ■ 

901b *GOTO NEXT STEP \GOTO 9022 

9016 OPEN" "OLDO" T0~:2, INPUT UPDATE 

9017 *GOTO NEXT STEP NGOTO 9022 
9010 OPEN "NErtO" TO :3» INPUT UPDATE 

9019 *GOTU NEXT STEP \GOTO 9022 

9020 OPEN "NEhl" TO :a, , INPUT UPDATE 

9022 XisNdWn \*G£T FUNCTION NAME. 

'9a25‘ rF~JO0'THEN“ 90410 \‘*CHECK FUrjCTION FLAG. 

9050 XS=X$+"-" \*0-FN BEING TKAnSFERED. ADD - TO NAME. 

9040 Z$=STR(T1 \*CONVERT TIME VARIABLE TO STRING. 

9041 X,Tsx*tZS( :2J \*APPENO TIME TAG TO FN NAME. 

9045 X$=X'E + '*s" \*APPEMD = TO FUNCTION NAME. 

9060 PRINT ; J-2*S<rJ-S + l;Yb*ai-U + WXi\*L0AD NAME IN FILE 1ST RCD, 

9070 FOR X=l TO 1000 ‘ \*dEGIN TRANSFER OF TERMS. 

907b INPUT :H;X,XS \*GET TERM FROM ARRAY H, 

-9076* -- PRINT ■:j-2*S*J-St3#"XI\*PLACE TERM IN FILE. 

9080 IF Xis”." then 910U\*END UF FUNCTION? 

“9090 NEXT X ' - “\*NOr REPEAT FOR NEXT TERM, 

9100 INPUTS* \*CHANGE INPUT MODE. 

9200 return ' ■ \*RETURN TO MAIN PROGRAM. 

10000 ***************************************************************** 

10001* SUBROUTINE TO COMPARE NEW FUNCTION SET TO OLD SET. 

10002* FUNCTIONS ARE ACCESSED FROM THE OLDlr OLOOf NEWO. AND NEWl 

■ 10003* FUNCTION FILES, IF THE Tl‘-0 SETS OF FUNCTIONS ARE EQUAL, 

10004* N0=l IS returned, OTHERWISE, Nuso IS RETURNED, 

■ 10005* • ” CALLED 0Y MAIN PROGRAM ISIM2), 

10006***************************************************************** 

“100'08 CLOSE UNCLOSE :2\CL0SE :5\CLUSE :4\*CLUSE all open FILES, 
lOOlO OPEN "ULDl" TO :l, INPUT UPDATE 
lOOlT OPEN "OLDO" TO ;2," INPUT UPDATE 
10012 OPEN "uEwO" TU :5, INPUT UPDATE 
•Too*rruFinv~"‘NrAi'" Tn“;a-,-TNPDT 'UPOATE - 
10015 FUR xsl TO Nl \*BEGIN COMPARISUN. 

“10020 — pjpur“:i fi*F;Y5*(X-l )*1,BS\*GET FN NAME. 
lOOAO INPUT :a-5*3; Yb*lX-l )*1 ,L»\*GET FN NAME. -) 

10 0'45 INPTjr" : rTS-A‘57 TTB \*GET term of IST FN, ' 

100'47 INPUT :a-i*S,C5 \*GET TERM OF 2ND FN, 

■"10D50 " IF“8isCi“THEN 1 0060~\ *TERMS EQUAL? 

100^5 return \*no. then fns not equal, { 

10060 " IF 04 = "." THEN n)080\*YES. END OF 'FN? 

100,70 *CUNTl)MUE COMPARISUN, NGOTO 10045 

\ 


97 


1 0060 
10100 
10105 
10107 
10110 
10115 
10120 
10130 
101^0 
10150 
lUloO 


ii-jpu r 
I'MPUT 
Ii-'JP'JT 
IF Ji = 

return 
IF Jb = 
*i\|Q , 

utxr X 
N0 = 1 
RETURN 


;2Fb;'Y5*(X-l J-H , Jl.\*Gk T F 'J hANfc'. 

! 5-5 ; Y5* ( X* I ) + 1 f ^i\ *GE r FN NA'-'E* 

:2+S,Ji " \*GtT TERM OF 151 Fn, 

\*GFT TERi^ OF 2MJ FN, 

Ki iHEivi 10120 \*TERf^S EOUAL? 

\*NO, TMEfs F'NS NOT EQUAL. 

THE'i' 10ia()\*ENG OF Fi«l.>' 
continue CQf^PARISQN.SGOfO 10105 

A»REPEAT FUR NEXT FUNCTIONS. 

\*functiun sets identical. 

\*RETURM ro“MAl.\ PROGRAM (S1M2).' 


11001* SUBROUTIf-iE ■ TO'PRI'nT FUNCTIONS ON DISPLAY OEVICF.. 

11002* functions are accessed from the files containing the 

11003* MUSI CURRENT FUNCTK3N SET. 

IIOOU* CURRENT INPUT-TIME AND RIPPLE-TIME IS ALSO PRINTED, 

11010 PRINT"Ts";T ,"R=”;k \*PW1nT INPUT AnD RlPPLt TI^ES, 

11020'PRINT ■ \*SKIP" A' LINE. ' ‘ 

11030 FUR x=l TO Nl \*SCAM ALL ELEMENf OUTPUTS. 


Iioao 
1 1 060 
11070 
11075 
110 77 
11060 
1 r09tT 
11100 
lino- 
11120 
11130 
11305 
11307 
11310 


for '- y= 3'" TO « SiPftiNT both functions FOR EACH LINE, 

_ INPUT ':Y-2*S*Y*5*S;Y5*lX-nfl ,£3)\*GET Fn NAME FROM FILE, 
print Z5; " \*PRir;T*T«E name. 

Z=l \*SET name print flag. 

INPUT ;Y-2*S*Y*5*S,Z5\iGET' A TERM OF THE FM, 

IF Zb = ".” THEN_ 1 1305 \*EnD OF FN? 

ir'ZsfTREN invo ■'S*N 0 T F.nD-UF FN. CHECK NAME PRINT FLAG. 
zs=''+''fz$ \*nane not printed last, insert ♦, 

- PRINT Zi; ■' " \*PRIf''T‘ TERM v^jITH LEADING 

ZSO \*CLEAR NAME PRINT FLAG, 

“ *GET AfiOTHER term TO PRINT. \GU10 11077 




NEXT 


PRINT 

print 

Y 


\*SKIP T«U LINES. 


11320 NEXT X 
11325 iMPUTsS 
il35y rf:turn’ 
13000* 


\*REPEAT FOR NEXT FN, 

\*REPEAT FOR nFxT LINE. 

\*RFTURN TO complete RECORD INPUT MODE, 
\*RETuRN 10 MAIN program. 


subroutine to OETERmINE" IF A POSSIBLE OSCILLATION EXISTS, 

AN OSCILLATION IS DEFINED AS THE FAILURE OF THE CIRCUIT TO 
R'EA'CH ABLE^-CaNuITTOM AFfEK" A SPECIFIED PIPPLE-TIME 
increment, this inc^rement is euual td the PIPPLE-TIME 
L-IMI T-T^i'TERtO" By* THE USETj AT THE BEGINNING UF THE EXECUriON 
OF 5IM2, A message is PRINTED IF A POSSIBLE OSCILLATION 
-IS- OETtCTEir. ^A-NE/7 RIPPLE-TIME ’LIMI T may Then BE ENTERED ' 

IF SU DESIRED. _ 

13010 IF R-Rj<R0 THEN 1 3 1 00\*CUMPARE RIPPLE-TIME INC /jITH LIMIT, 
nOTR- *PRTNt meVSAGE“I'F LTnIT' IS EQUALLED OR EXCEEDED. 

13020 PRINT''P0SSIBLE OSCILLATION, ENTER NEV' RIPPLE-TIME LIMIT OH <CR> TO STOP 
l 3030 “lNPTJT“ni \*Ef'TER RESPONSE TO wUERY. 

13090 IF Z5=" ” THEN 13200 \*CHELK FOR <CR> ENTRY. 


13001* 
13002* 
13003* 
1 3009* 

rs 0 0 5 * 

13006* 

T3007* 

13006* 


98 


15050 ROsWlZJ) \*VflLL'E Ef^TERED. , COMVERT TO NUMERIC. 

15100 0^=1 \*SET FLAG FOR CCJNTItlUlNG, 

13150 RETURN ' \*RETURW TO MAIN PROGRAM, 

liaoo 0^=0 \*CLEAK FLAG TO STOP SIMULATION. 

13210 RETURN \*RETuRN 10 MAIM PRUGRAM. 

1AOOO«*************************************************************a** 

lAOOl* ' ' 0 FLIP-FLOP SII^ULATION ROUTINE. 

1 AO 02 ********************************************************** ******* 


lAOlO PRINT"DFF SIMULATION ROUTINE NOT YET IMPLEMENTED," 
1«020 RETURN 


mi 00*************** * V* *********************************************** 

wool* SUHRUUTINE TO MINIMIZE FUNCTIONS, 

17002* A'FUNCTION IS SAID TO BE MINIMIZED (IN THIS CONTEXT) IF IT 
17003* contains NO REDUNDANT PRODUCT TERMS.' HENCE THE SUBROUTINE 
WOOa* REMOVES DUPLICATE TERMS AND TERMS COVERED BY ANOTHER TERM. 
17005* A FUNCTION IS PASSED TO THE SUBROUTINE IN ARRAY H, 

17006* THf REDUCED FUNCTION IS RETURNED IN ARRAY H, 

17007* called 8Y THE AND SUBROUTINE AND THE OR SUBROUTINE, 




WOlO FOR X = l 

17015 " • 

17016 
17020 
17050 
170A0 
17050 

17060 ' ' - 

17070 
17080 
170R0 . 

17091 

17100 

17110 

17115 

17116 
W120 

17122 " "" 

17125 
“17150 
17135 

17iao 

171A1 

17150 

17151 
17155~ 

17160 

— ITT55 

17170 

17180- 

17185 

17190 

17195 


TO X2-1 \*EXAmINE EACH TERM OF THE FN, 

INPUT ;H;X,ZS \*GET A TERM FROM ARRAY H, 

IF Z-bs"." THEN 17220\*ENDOF FUNCTION? 

X$ = r$ - \*t'!0, COPY TERM TO X5 FOR PARSING, 

*PARSE TERM INTO L I TERALS, \60SUH 7800 
FOR Y=1 TO 20 \*COPY LITERALS TO ARRAY D$, 

Oi(Y)sAi(Y )\*COPY A TERM, 

“ IF A$(Y)s"," THEN 17080\*END OF LIST? 

NEXT Y \*N0, REPEAT FOR NEXT LITERAL, 

FOR Y = X + 1 TO X-2-l\*C0MPARE ABOVE TERM TO ALL OTHER TERMS, 
INPUT :H;YrZ*\*GET A TERM FROM ARRAY M, 

IF Z$s"." THEN 17210\*EN0 OF FN? 

XJSZJ \*COPY TERM TO X4 FOR PARSING, 

♦PARSE THE TERM INTO LI TERALSNGOSUB 7800 
F5=l \*INITIALIZE FLAG INDICATING 

*A REDUNDANT TERM. 

FOR B=1 TO 20\*C0MPARt LITERAL LISTS OF TWO TERMS, 

' IF F5=0 THEN 17200\*CHECK FLAG FOR NO REDUNDANCY 

IF DMB) = "," THEN 17170\*END OF LIST? 

" * for A=1 TO 20\*SCAN LIST OF 2ND TERM, 

IF A4(AJ="," THEN 17165\*END OF LIST? 

“ IF AS(A)=OJ(B) THEN W160 

WCUMPARE literals OF TWO LISTS. 

F5=0 \*LITERALS ARE NOT ALIKE. 

♦CLEAR FLAG ,10 INDICATE NO REDUNDANCY. 
* ■ ' NEXT A \*REPEAT FOR NEXT LITERAL OF 2ND TERM 
F5=l \*MATCH FOUND, POSSIBLE REDUNDANCY, 

NEXT R \*REPEAr FOR NEXT LITERAL OF 1ST TERM 

FOR C=Y TO X2-1\*2ND lERM REDUNDANT. DELETE FROM H. 

iNPur ;H;C-M rZ4\*GET A TERM FROM H. 

PRINT ;h;C,24 \*PLACE TERM IN NE« POSITION. 

"• NEXT C \*KEPEAT FUR NEXT TERM, 

*GET NE>N 2ND TEKM.NGOIO 1 7090 


f 


99 

I 17200 NfKT Y N^REPtAT FOk MEXT TERM, 

I 17210 I'jKXT X \*RtPEAT KOW NEXT FIRST TERM. 

117220 return \*RETURi\i TO CALLING PROGRAM. 

lttUOO***************'*********<f*****************'k*****<t*-**»jt*********** 

18001* SUBHOU UNE >tjR changing input i'^'OOE. 

18002* CaLLEO BY mAI-M ROUTINE O^F SIM<e. 

18003**************************** ******* **************************A*«* 

18009* PRINT MUOE SELECTION vessaGE. 

18010' PRlNT"SELECr OESIREO mooe;"‘ 

18020 PRINT" (1) FIXED INPUT VALUES" 

18030 PRINT" ' (2) INPUT VARIABLES"' ' 

' laoao INPUT Y \*INPUT MOUE SELECTION NUMBER, 

18050 IF Y<3 ?HEN 18070 \*CMECK FOR' VAL 1 1)' MODE ' NUMBER , 

180b5*PRlNT ERROR MESSAGE. 

18058 PRInT"InVALIO'MOOE NUMBER ENTERED. MAKE ANOTHER TRY," 

1805F *REPEAT THE ENTRY, \GOTO 18010 

18080 RETURN \*RETURN TO MAIN PROGRAM, 

: 18070 FOR X=1 JO 10 \*CLEAR INPUT DESCRIPTION OF ALL CONSTANTS. 
18080 ""IF 'I(X,‘2)'="FF" THEN- 1 8 1 1 5\*L0DK' FOR FAULT-FREE ENTRY, ' ' 

^8090 IF IlX,2)="S0" THEN 18ll5\*L00K FOR STUCK-AT-0 ENTRY. 
l8l00" ■TF'TfX,2J = "Sf" THEN i 8rf5\*L0UK FOR STUCK-AT -1 ENTRY, ' 

,8110 I(X,2J = "FF" \*REPLACE CONSTANTS WITH FAULT-F'REE SYMBOL, 

.8115 .\iEXI~X ' ■■ \*R£PEAT FOR NEXf ENTRY, " 

.8117 IF Y=2 IHEN 18300 \*CHECK FOR VARIABLE INPUT MODE, 

.8119 * PR INT fixed-input £N TRY ' MESSAGE, 

.8120 PH1NT"ENTER FIXED INPUT VALUES." 

: "arno PRINT"ENTEf?'LINE~NAMEs(r OR" sI'Oft T 0 "ST 0 P ENTER 

; .bUo INPUT Zs \*ENT£R LINE NAME AND VALUE. 

'8150' IF"Z$s"/"' ThEN 18300 \'*END'OF' EMRY? “ 

i 8160 FUR X=1 TO 100 \*RARSE ZS, 

■ 8'17‘0" IF'TiCj'x; 1 r="s" then 18190\*LUOK for end UF LINE NAME, ' 

8180 NEXT X \*EXAMlNt NEXT CHARACTER, 

81'90 Ci = ZS'C:l /'X-iy S*LET'C»sLI>'5E-NAmE. 

8200 Hi = ZS(:_Xtl) \*LET 8*sLlNE-VALUE , 

8210 FOR X=1 TU'IO ■ \*SCAN I ARRAY FOR LINE-NAME ENTRIES. 

8220 IF CSOKX.n then 18290\*LOUK FUK A MATCH, 

' "8230 " r(X'»2)=db \*'M'ATCh found; LOAD CONSTANT, 

8290 NEXT X \*REPEAT FUR NEXT ENTRY, 

8250 *k£PEAT for POSSIBLE 'nEw ENTRY, \GOTO 18130 

8500 FUR X=1 TO 10 \*PRINT THE INPUT DESCRIPTION ARRAY, 

8502 pRrNr~irx,n,rfx,2),r(xv3) ' ' " “ ' 

8304 NEXT X 

“83 10' return ■' 'S*fiE'TURN TO MAIN PROGRAM, 

'0000 END 


I 


100 


08:16 OCT 12/'79 DC/BACEDOC.BCARROLL 


1* 

5SSSS III H 

M 

LL 

00000 

GGGGG 

2* 

S I MM 

MM 

L 

0 0 

G 

3* 

SSSSS I MM 

M 

L • 

0 0 

G GG 

4* 

SIM 

M 

L 

0 0 

G G 

5* 

SSSSS III M 

M 

LLLLL 

QOQOQ 

GGGGG 

6* 






7* 

PROGRAM: 


RACEDOC 



8* 

VERSIONS 


SIGMA 5 



9* 

REVISION; 


ORIGINAL 



10* 

DATES 


10/6/79 



11* 

PROGRAMMER: 


B. D. CARROLL 



12 * 

2^3 ft *«***«*«««»«**««« «« ft******** ft***4r*ft*ft ******** ***«««****««****«* ***ft 

14* 

15* CONTRACT SUPPORT 

2 5ft*****«*««*'A<^***'**i^*ft *********** ************************************ 
17 * 

18* THIS PROGRAM WAS DEVELOPED FOR NASA MARSHALL FLIGHT 
19* CENTER UNDER CONTRACT NAS8-ai572* 

20 * 

22 *******************************************************************'* 

22 * 

23* MODIFICATION HISTORY 

24* 

25ft******** ************************************* ********************** 
26* 

39* 

20 Q ******************************************************************* 

101 * 

102* PROGRAM DESCRIPTION 

103* 

10 4 *** ****** ****** **************************************************** 

105* 

106* SIMLOG IS A PROGRAM FOR SIMULATING LOGIC CIRCUITS. 

107* BOTH COMBINATIONAL AND SEQUENTIAL CIRCUITS CAN BE 
108* SIMULATED. CIRCUITS CAN BE SIMULATED FAULT-FREE OR 
109* WITH SINGLE OR MULTIPLE STUCK TYPE FAULTS. 

110* LOGIC ELEMENTS ACCOMMODATED BY THE SIMULATOR ARE 

111* NAND GATES AND NOR GATES. OTHER ELEMENTS ARE TO 
112* BE ADDED, 

113* 

114* TWO VERSIONS OF SIMLOG HAVE BEEN WRITTEN. 

115* ONE VERSION HAS BEEN WRITTEN IN BASIC-PLUS FOR 

116* EXECUTION ON A PDPll/40 RSTS/E SYSTEM. 

117* ANOTHER VERSION HAS BEEN WRITTEN IN ^XEROX BASIC 
118* FOR EXECUTION ON A SIGMA 5 CPV SYSTEM. 

119* 

120* THE PDPll/40 VERSION IS PARTITIONED INTO TWO 

121* SUBPROGRAMS, SIMA AND SIMB. THIS PARTITIONING WAS 

122* NECESSARY DUE TO THE LARGE MEMORY REQUIREMENTS OF 


101 


1123* THE PROGRAM. VIRTUAL ARRAYS ARE USED FOR ALL LARGE 
1124* ARRAY STORAGE. 

125* 

126* THE SIGMA S VERSION IS PARTITIONED INTO THREE 
127* SUBPROGRAMS, SIMl, SIM2, IND RACE. THIS DEGREE OF 

128* PARTITIONING NAS NECESSARY SINCE VIRTUAL ARRAYS ARE 

129* NOT AVAILABLE ON THE SIGMA 5. 

130* 

131* THE FUNCTION OF SIMl IS TO INPUT ALL DATA NEEDED 
132* CONCERNING CIRCUIT DESCRIPTION, FAULT DESCRIPTION, 

133* INITIAL CONDITIONS, AND SIMULATION MODES. 

134* 

135* THE FUNCTION OF SIM2 IS TO PERFORM THE ACTUAL 

136* SIMULATION COMPUTATIONS HITH THE EXCEPTION OF 

137* RACE ANALYSIS AND TO OUTPUT THE SIMULATION RESULTS. 

,138* 

.139* THE FUNCTION OF RACE IS TO PERFORM THE RACE 
!140* ANALYSIS COMPUTATIONS. 

141* 

142* 

300******************************************************************* 

301* 

302* I/O STREAMS 

303* 

3Q^*a**« ********** ** *•*'*'**'*’*«** ********* a ******* ********** ****'***•'*««* 

305* 

306* 

309* STREAM USAGE 

310* 

311* 


312* 

1 

FILE 

OF 

OLD 

ONE-FUNCTIONS(S=0) 

313* 

314* 


FILE 

OF 

NEW 

ONE-FUNCTIONS{S=l) 

315* 

2 

FILE 

OF 

OLD 

ZERO-FUNCTIONS(S=0} 

316* 

317* 


FILE 

OF 

NEW 

ZERO-FUNCTIONS(S=l) 

318* 

3 

FILE 

OF 

NEW 

ZERO-FDNCTIONS(S=0) 

319* 

320* 


FILE 

OF 

OLD 

ZERO-FUNCTIONS(S=l) 

321* 

4 

FILE 

OF 

NEW 

ONE-FUNCTIONS(S=0) 

322* 

323* 

324* 


FILE 

OF 

OLD 

ONS-FUNCTIONS(S=l) 

325* 

THE 

ABOVE REPRESENTS 

THE BASIC ASSIGNMENTS OF I/O STREAMS 


326* TO FUNCTION FILES. HOWEVER, THE SIGMA 5 PROVIDES ONLY 4 I/O 
327* STREAM NUMBERS. HENCE, IT BECOMES NECESSARY TO REASSIGN STREA^MS 
328* WHEN ACCESS TO ARRAY-FILES IS NEEDED. THIS REASSIGNMENT IS 
329* DYNAMIC AS A FUNCTION OF PARAMETERS S AND X7 SINCE IT IS 
330* NECESSARY TO KEEP ACCESS TO ORE FUNCTION FILE ALSO. 

331* THE FOLLOWING TABLE DETAILS THIS DYNAMIC ASSIGNMENT. 

332* 

333* 1 


! 


1 



102 


334* 1 

335* 1 

336*STREAM#I X7=0 


! GARRAY 

.} 

1 FARRAY 


I FARRAY 
j GARRAY 


342* 


344* 


HGMO 


1 HARRAY 


1 HARRAY 


NEWl 


HARRAY 


OLDO 


FARRAY 


GARRAY 


OLDl 


HARRAY 


GARRAY 


FARRAY 


346* 

400 *\**'******'****** ******************************* ********************* 
401* 

402*< VARIABLE DEFINITIONS 

403*. (MAIN PROGRAM ONLY. SEE SIM2DOC FOR SUBROUTINE VARIABLES.) 
404* 

405*'*****************************************************************'* 

406* 

409* VARIABLE DEFINITION 

410* 

423 * B$ USED AS A TEMPORARY STRING VARIABLE. 

424 * 

425 * E$,K$,S$,V$,J$,L$ 

426 * USED AS TEMPORARY STRING VARIABLES. 

427 * 

440 * F INDICATES THE I/O STREAM TO NHICH F ARRAY FILE 

441 * IS OPENED. 

442 * 

455 * G INDICATES THE I/O STREAM TO WHICH THE G ARRAY FILE 

456 * IS OPENED. 

457 • 

460 * H INDICATES THE I/O STREAM TO WHICH THE H ARRAY FILE 

461 * IS OPENED. 


INDICATES THE UPPER LIMIT OF THE LOOP VARIABLE 
OF SOME FOR-NEXT LOOPS. SHOULD BE SET >= THE 
NUMBER OF ROWS IN THE I ARRAY. 

INDICATES THE NUMBER OF ELEMENTS IN THE CIRCUIT. 
CONSEQUENTLY THE NUMBER OF ROWS IN N AND P. 

CONTROL VARIABLE IN A FOR-NEXT LOOP. 

THE NUMBER OF CROSS-COUPLED PAIRS OF ELEMENTS IN 
THE CIRCUIT. ALSO THE NUMBER OF ROWS IN Q. 

A SWITCH INDICATING WHICH CHANNEL TO USE WHEN 
ACCESSING FUNCTION FILES. 


V 


A TEMPORARY VARIABLE USED TO REPRESENT THE 


103 


568 * 

569 * 

573 * 

574 * 

597 * 

598 * 

599 • 

600 • 

800*»' 

801* 

802* SUBROUTINE DESCRIPTIONS 

803* 

804* 

805* 

809* 

810* 

811* 

812* 

813* 

824* 

825* 

826* 

827* 

828* 

829* 

830* 

831* 

832* 

833* 

842* 

843* 

^QO ******************************************************* ************ 

901* 

902* DIMENSION STATEMENTS 

903* 

904******************************************************************* 

905* 

910 DIM N(200,4), 1(400,3), Q(50,2), P(200,2) 

920 DIM A$(51), D$(51) 

930 DIM U(l) 

999* 

1000 ****************************************************************** 
IQQI**** ********************************** ****** ********************** 
1002 * * 
1003* START OF MAIN PROGRAM * 

1004* . * 

1005****************************************************************** 

10 05 *************************************************** *************** 

1007* 

1008* 

1010 OPEN "OLDl” TO :1, INPUT UPDATE 
1020 OPEN "OLDO" TO :2, INPUT UPDATE 


PROGRAMMER DEFINED SUBROUTINES 
LINE DESCRIPTION 

7200 term sorting. 

7800 PRODUCT TERM DISASSEMBLY INTO LITERAL COMPONENTS. . 

8000 AND SUBROUTINE. 

8250 ZERO PRODUCT TERM DETECTION. 

8650 LITERAL SORTING. 

17000 FUNCTION MINIMIZATION. 


NUMERIC VALUE OF A STRING VARIABLE. 

X USED AS THE CONTROL VARIABLE IN FOR-NEXT LOOPS. 

Y5 A PARAMETER INDICATING THE MAXIMUM NUMBER OF TERMS 
THAT CAN BE STORED IN THE FUNCTION FILE OF EACH 
FUNCTION. 


104 


1030 OPEN "NEWO” TO :3, INPUT UPDATE 
1040 OPEN "NEWl" TO I A, INPUT UPDATE 
1155 INPUT=0 

1160 FOR QO=l TO Q1 \*BEGIN PROCESSING OF EACH XC PAIR. 

1165 FOR X=1 TO N1 \*SEAR(fH FOR XC ELEMENT IN ELEMENT ARRAY. 

1170 IF N(X/1)=Q(Q0,1) THEN 1180 

1175 NEXT X 

1179* CHECK ELEMENT TYPE. 

1180 IF N(X,2)="NAND» THEN 1190 

1185 IF N(X/2)=”NOR" THEN 1200 

1190 \*LOAD FLAG FOR NANO GATE. 

1195 GOTO 1205 

1200 X7=l \*LOAD FLAG FOR NOR GATE. 

1205 V=VAL(Q(Q0/1 )) \»CONVERT ELEMENT OFFSET TO NUMERIC. 

1209 * GET NAME LABELS OF FIRST TWO OME-FM'S. 

1210 INPUT :3*X7-S-2*X7*S;Y5*(tf-l)+l,B$ 

1215 INPUT :2-X7>S+2*X7*SjY5*(V-l)+l,E$ 

1219 * GET TERM OF FIRST TWO ONE-FN'S. 

1220 INPUT :3+X7-S-2*X7*S/B$ 

1225 INPUT :2-X7+S+2*X7*S,ES 

1229 * CHECK FOR EQUALITY OF FUNCTIONS. 

1230 IF B$OES THEN 1245 

1235 IF BS='’.'' THEN 1285 \*IF YES, FN'S ARE EQUAL. 

1240 *IF NO/ THEN EXAMINE NEXT TERMS. VGOTQ 1220 

1245 V=VAL(Q(Q0/2)) \*CONVERT ELEMENT INDEX TO NUMERIC. 

1249 » GET NAME LABELS OF FIRST TWO ZERO-FN'S. 

1250 INPUT ;4-X7-3*S42*X7*S;Y5*(V-1)-H/K$ 

1255 INPUT !1+X7+3*S-2*X7*S?Y5*(V-1)»1/S$ 

1259 * GET TERMS OF FIRST TWO ZBRO-FN'S. 

12'60 INPUT :4-X7-3*S+2*X7*S/KS 

1265 INPUT ;l+X7+3*S-2»X7*S/S$ 

1269 * CHECK FOR FUNCTION EQUALITY. 

1270 IF K$OS$ THEM 1365 

1275 IF K$=".» THEN 1285 \*IF YES/ THEN FM'S ARE EQUAL. 

1280 *IF NO/ EXAMINE NEXT TERMS. \GOTO 1260 

1285 V=VAL(Q(Q0/2)) \*CONVERT ELEMENT INDEX TO NUMERIC. 

1289 * GET NAME LABELS OF SECOND TWO ZERO-FN'S. 

1290 INPUT :3>X7-S-2*X7»S;Y5*(V-1)+1/VS 

1295 INPUT ;2-X7+S-f2*X7*S;Y5*(V-l)+l/ZS 

1299 * GET TERM OF SECOND TWO ZERO-FN'S. 

1300 INPUT :3>X7-S-2*X7*S,V$ 

1305 INPUT S2-X7+S+2*X7*S/Z$ 

1310 IF VSOZS THEN 1325 \*CHECK FOR EQUALITY OF FUNCTIONS. 

1315 IF V$=”.» THEN 1830 \*IF YES/ THEN FN'S ARE EQUAL. 

1320 *IF NO/ EXAMINE NEXT TERMS. \GOTO 1300 

1325 V=VAL(Q(Q0/D) \*CONVERT ELEMENT INDEX TO NUMERIC. 

1329 * GET NAME LABELS OF SECOND TWO ONE-FUNCTIONS. 

1330 INPUT :4-X7-3*S*2*X7*S;Y5*(V-l)+l/J$ 

1335 INPUT ;l-»-X7*3*S-2*X7*S;Y5*(Y-l)+l/L$ 

1339 * GET TERMS OF SECOND TWO ONE-FUNCTIONS. 

1340 INPUT ;4-X7-3*S+2*X7*S/J$ 

1345 INPUT :1+X7+3*S-2*X7*S/LS 


) 


105 


1350 IF J$OL$ THEN 1365 \*CHECK FOR EQUALITY OF FUNCTIONS. 

1355 IF JS=*'.'' THEN 1830 \*IF TRUE, FUNCTIONS ARE EQUAL. 

1360 *IF NO, EXAMINE NEXT TWO TERMS. \GOTO 1340 

1364 *CLQSE FUNCTION FILES F AND G. 

1365 CLOSE :2-X7+S>2*X7*S 

1370 CLOSE :1+X7*3*S-2*X7*S 

1375 F=2-X7+S+2*X7*S 

1380 G=1^X7+3*S-2*X7»S 

1384 *OP£N FUNCTION FILES FARRAY AND GARRAY. 

1385 OPEN "FARRAY" TO ;F, INPUT UPDATE 

1390 OPEN "GARRAY" TO tGyINPUT UPDATE 

1394 »CHECK FIRST ZERO-FN FOR ZERO-VALUE. 

1395 V=VAL(Q(Q0,D) 

1400 INPUT :3+X7-S-2*X7*S;Y5*(V-1)+2,B$ 

1405 IF B$="0" THEN 1645 

1409 *CHECK FIRST NEM ONE-FN FOR ZERO-VALUE. 

1410 V=VAL(Q(Q0,2)) 

1415 INPUT :4-X7-3*S+2*X7*S;Y5*(V-l)+2,K$ 

1420 IF K$="0" THEN 1550 

1424 *LOAD FIRST NEW ZERO-FN INTO FARRAY. 

1425 PRINT ;F;1,BS 

1430 FOR X=2 TO H9 

1435 INPUT :3+X7-S-2*X7*S,B$ 

1440 PRINT :F;x,b$ 

1445 IF THEN 1455 

1450 NEXT X 

1454 *LOAD FIRST HEW ONE-FN IN GARRAY. 

1455 PRINT :G;1,K$ 

1460 FOR X=2 TO H9 

1465 INPUT :4-X7-3*S^2*X7*S,K$ 

1470 PRINT :g;X,k$ 

1475 IF K$="." THEN 1485 

1480 NEXT X 

1484 *CLOSE FUNCTION FILE H. 

1485 CLOSE :4-X7-3*S^2*X7*S 

1490 H=4-X7-3*S+2*X7»S 

1494 »OPEN ARRAY FILE HARRAY TO H. 

1495 OPEN "HARRAY" TO ;H, INPUT UPDATE 

1499 *AND FIRST 0-FN AND FIRST 1-FN. 

1500 GOSUB 8000 

1504 *REPLACE FIRST NEW ZERO-FN. 

1505 V=VAL(Q(Q0,D) 

1510 INPUT :H;l,z$ 

1515 PRINT :3+X7-S-2*X7*S;Y5*(V-l)+2,Z$ 

1520 FOR X=2 TO H9 

1525 INPUT ;H;X,Z$ 

1530 PRINT :3+X7-S-2*X7*S,Z$ 

1535 IF Z$="." THEN 1590 

1540 NEXT X 

1545 GOTO 1590 

1549 ^REPLACE FIRST HEW ONE-FH. 

1550 V=VAL(Q(Q0,2)) 


106 


1555 

1560 

1565 

1570 

1575 

1580 

1585 

1589 

1590 

1594 

1595 
1600 
1605 
1610 
1615 
1620 
1625 
1630 
1635 
1640 

1644 

1645 
1650 
1655 
1660 
1665 
1670 

1674 

1675 
1680 
1685 
1690 
1695 
1700 

1704 

1705 
1710 
1715 
1720 
1725 
1730 

1734 

1735 

1739 

1740 

1744 

1745 

1749 

1750 
1755 
1760 
1765 


PRINT :4-X7-3*S+2*X7*S;Y5*(7-l)+2,B$ 
FOR X=1 TO H9 

IHPOT :3+X7-S-2*X7*S/8$ 

PRINT ;4-X7-3*S*2»X.7*S/B$ 

IF B$=*'." THEN 1645 
NEXT X 
GOTO 1645 

♦CLOSE ARRAY FILE H. 
rf nSF • 4— + 

♦OPEN APPROPRIATE FUNCTION FILE TO H. 

IF S=1 THEN 1625 

IF X7=l THEN 1615 

OPEN "NEWl" TO ;4/INPUT UPDATE 

GOTO 1645 

OPEN "NEWO" TO :3, INPUT UPDATE 

GOTO 1645 

IF X7=l THEN 1640 

OPEN "OLDl'' TO :l/INPUT UPDATE 

GOTO 1645 

OPEN "OLDO” TO : 2, INPUT UPDATE 
♦CHECK SECOND NEW 0-FN FOR 0-VALUE. 
V=VAL(Q(Q0,2)) 

INPUT :3+X7-S-2^X7^S;Y5^(V-l)*2/V$ 

IF V$="0” THEN 1830 
V=VAL(Q(Q0/D) 

INPUT :4-X7-3^S+2^X7^S;Y5^(V-1)+2/J$ 

IF THEN 1795 

♦LOAD SECOND NEW 0-FN IN FARRAY. 

PRINT :f;1/V$ 

FOR X=2 to H9 

INPUT :3+X7-S-2^X7^S/V$ 

PRINT :F;X^V$ 

IF V$=".« THEN 1705 
NEXT X 

♦LOAD SECOND NEW 1-FN IN GARRAY. 

PRINT :g;1,j$ 

FOR X=2 TO H9 
INPUT 

PRINT :G;x,JS 
IF JS=''." THEN 1735 
NEXT X 

♦CLOSE FUNCTION FILE H. 

CLOSE :4-X7-3^S+2*X7^S 
♦OPEN ARRAY-FILE HARRAY TO H. 

OPEN "HARRAY” TO :H^ INPUT UPDATE 
♦AND 2ND 0-FN WITH 2ND 1-FN. 

GOSUB 8000 

♦REPLACE SECOND 0-FN. 

V=VAL(Q(Q0,2)) 

INPUT :H;l/Z$ 

PRINT :3+X7-S-2^X7^S>Y5*(V-l)+2/Z$ 

FOR X=2 TO H9 


107 


1770 INPUT ;H;X,Z$ 

1775 PRINT :3+X7-S-2*X7*S^2$ 

1780 IF Z$=".” THEN 1830 

1785 NEXT X 

1790 GOTO 1830 

1794 *REPLACE SECOND 1-FN. 

1795 V=VAL(Q(Q0/D) 

1800 PRINT ;4-X7-3*S+2*X7»S;Y5*(V-l)^2^V$ 

1805 FOR X=1 TO H9 

1810 INPUT :3*X7-S-2»X7*S^7$ • 

1815 PRINT :4-X7-3*S+2*X7*S,V$ 

1820 IF ¥$=•'." THEN 1830 

1825 NEXT X 

1829 *CLOSE ALL FILES. 

1830 CLOSE :1 

1835 CLOSE :2 

1840 CLOSE :3 

1845 CLOSE ;4 

1849 *REOPEN FUNCTION FILES TO INITIAL ASSIGNMENT. 

1850 OPEN ”QL01" TO :1/INPUT UPDATE 

1855 OPEN "OLOO" TO :2, INPUT UPDATE 

1860 OPEN "NEWO” TO :3^INPUT UPDATE 

1865 OPEN "NEWl" TO ;4, INPUT UPDATE 

1870 NEXT QO \*END OF PRIMARY LOOP. 

1875 INPUT=$ 

1879 *CLOSE ALL FILES BEFORE CHAINING. 

1880 CLOSE :1 
1885 CLOSE :2 
1890 CLOSE :3 
1895 CLOSE :4 
1900 C0=2 

1905 CHAIN LINK »SIM2DOC” 

7200 ****************************************************************** 

1201 * SUBROUTINE TO SORT THE TERMS OF A FUNCTION. 

7202* FUNCTION MOST BE STORED IN ARRAY H BEFORE 

7203* SORTING ROLES: LENGTH OF TERM^ ALPHABETICAL/ NUMERICAL. 

7204* CALLED BY OR AND AND SUBROUTINES. 

7205* CALLS NO SUBROUTINES. 

7206 ****************************************************************** 

7220 FOR X=1 TO 100 \*COUNT NUMBER OF TERMS IN FN. 

7230 INPUT ;H;X,Z$ \*GET a TERM. 

7231 IF Z$=".'' THEN 7250 \*END OF FUNCTION? 

7240 NEXT X \*NO. 

7249 *X = THE NUMBER OF TERMS IN H PLUS 1. 

7250 IF X=2 THEN 7500 \*CHECK FOR SINGLE TERM FN. 

7252 X0=X \*SAVE X FOR USE AS SORT LOOP LIMITER. 

7255 X1=X \*SAVE X FOR STORE LOOP LIMITER. 

7260 FOR X=1 TO XO-2 \*USE A BOBBLE SORT TO ORDER THE TERMS. 

7270 INPUT :H;X/X$ \*GET FIRST TERM OF H. 

7272 INPUT :H;X>1/Y$ \*GET ADJACENT TERM OF H. 

7274 IF X$<Y$ THEN 7310\*COMPARE THE TERMS. 

7280 *REVERSE THE ORDER OF THE TNO TERMS. 



108 


7290 PRINT :H;X/Y$ 

7300 PRINT :H;X+1/XS 

7310 NEXT X \*REPEAT FOR NEXT PAIR OF TERMS. 

7319 * ONE TERM HAS BEEN PLACED. IN ITS PROPER PLACE. 

7320 X0=X0-1 \*DECREMENT SORT LOOP LIMITER. 

7330 IF X0>2 THEN 7260 \*HAVE ALL TERMS BEEN ORDERED? 

7340 XOsXl \*YES. RESTORE XO . 

7344 ^DUPLICATE TERMS HILL NOM BE REMOVED. 

7345 FOR X=1 TO XI \*COMPARE ADJACENT TERMS FOR EQUALITY. 

7347 INPOT ;H;X#XS \*GET a TERM. 

7348 IF X$=”.'* THEN 7420\*END OF FUNCTION? 

7350 INPUT :H;X+1/Y$\*N0. get ADJACENT. TERM. 

7351 IF X$=Y$ THEM 7360\*ARE TERMS IDENTICAL? 

7355 *NO. GET NEXT PAIR.XGOTO 7410 

7360 X0=X0-1 \*YES. DECREMENT TERM COONT. 

7365 FOR Y=X4-1 TO Xl-l\*REMOVE DUPLICATE TERM AMD COMPACT H. 

7370 INPUT :H;Y+1/X$\*GET TERM FROM H. 

7371 PRINT :H;Y/X$\»MOVE TERM TO NEW POSITION IN H. 

7380 IF XS=”.'' THEN 7410\*END OF FUNCTION? 

7390 NEXT Y \*REPEAT FOR NEXT TERM. 

7410 NEXT X \*REPEAT FOR NEXT PAIR OF TERMS. 

7420 FOR X=1 TO XO-2 \*SORT TERMS BY LENGTH USING BUBBLE SORT. 

7430 INPUT :H;X/X$ 

7431 INPUT SH;X+1/Y$ 

7432 L1=LEN(X$) 

7433 L2=LEN(Y$) 

7434 IF LK=L2 THEN 7470 \*IF TRUE/ DO NOT REORDER. 

7440 PRINT ;H;X/Y$ \»RE0RDER. 

7450 PRINT :H;X*1/X$ 

7470 NEXT X \*REPEAT FOR NEXT PAIR. 

7480 X0=X0-l \*DECREMENT LOOP LIMIT FOR NEXT PASS. 

7490 IF X0>2 THEN 7420 \»SORTING COMPLETE? 

7500 RETURN \*YES. RETURN TO CALLING PROGRAM. 

7800 ****************************************************************** 
7801* SUBROUTINE TO DISASSEMBLE A PRODUCT TERM INTO ITS 

7802* LITERAL COMPONENTS. A LITERAL IS, A VARIABLE NAME OR A 

7803* COMPLEMENTED VARIABLE NAME TOGETHER WITH ITS TIME TAG 

7804* OR FAULT SYMBOL. 

7805* TERM IS PASSED TO SUBROUTINE IN X$. LITERALS RETURNED 
7806* IN A$ ARRAY. CALLED BY LITERAL SORT SUBROUTINE. 

•ji 80 7 ***************************************************** ************* 
7810 F5=0 \*CLEAR SPECIAL CHARACTER FLAG. 

7815 Z$="” \*CLEAR DUMMY STRING VARIABLE. 

7820| A=1 \*INITIALIZE POINTER TO A$ ARRAY. 

7830! L=LEN(X$) \*COMPUTE LENGTH OF TERM. 

7835' FOR X3=l TO L \*BEGIN DISASSEMBLY OF TERM. 

7840! IF X$CX3/1)="-" THEN 7900\*LOOK FOR SPECIAL CHARS (-). 

7842. IF X$(:X3/1)>”Z” THEN 7900\*LOOK FOR TIME TAG (NUMERAL). 

78441 IF X$(:X3,1)<"A" THEN 7900\*LOOK FOR FAULT SYMBOLS (I/*). 

7850i IF F501 THEN 7910\*END OF LITERAL REACHED? 

7860. A$(A)=Z$ \*YES. PLACE LITERAL IN AS ARRAY. 

7861, *END OF LITERAL IS INDICATED WHEN A SPECIAL 

: 


i 

i 

i 

i 

1 


109 


7862 *CHARACTER IS FOLLOWED BY A LETTER. 

7863 »THE LETTER IS THE FIRST CHARACTER OF THE 

7864 *NEXT LITERAL. 

7870 ZS=X$(:X3^1) \*8EGIN CONSTRUCTING NEXT LITERAL. 

7880 F5=0 \*CLEAR SPECIAL CHARACTER FLAG. 

7890 A=A<-1 \*INC POINTER TO A$ ARRAY. 

7895 GOTO 7920 

7896 »COMTINOE PROCESSING TERM. 

7900 F5=l \*SET SPECIAL CHARACTER FLAG. 

7910 Z$=Z$-»-X$(:X3,U\*CONSTRUCT LITERAL. 

7920 NEXT X3 \*REPEAT FOR NEXT CHARACTER OF TERM. 

7930 A$(A)=ZS \*LOAD LAST LITERAL OF TERM IN A$ ARRAY. 

7940 A$(A+1)=''." \*LOAD END-OF-LITERAL MARK. 

7950 RETURN \*RETURN TO LITERAL SORT SUBROUTINE. 

8000 ************ **************************** ******* ******************* 
8001* SUBROUTINE TO PERFORM THE LOGICAL AMO OF 

8002* TWO FUNCTIONS. 

8003* THE INPUT FUNCTIONS ARE PASSED IN ARRAYS F AND G. 

8004* THE RESULTANT FUNCTION IS RETURNED IN ARRAY H. 

8005* CALLED BY MAIN PROGRAM (SIH2) AND RACE PROGRAM. 

8006* CALLS ZERO PRODUCT DETECT SUBR (8250), LITERAL SORT 

8007* SUBR(8650), TERM SORT SUBR(7200), AND MINIMIZATION SUBR(17000) 

800 8 **** ************************************************** ************ 

8010 INPUT :F;1,XS \»CHECK for ZERO FN VALUE. 

8011 IF X$='’0*’ THEM 8030 

8020 INPUT ;G;1,Y$ \*CHECK FOR ZERO FM VALUE. 

8021 IF Y$<>"0" THEN 3050 

9030 PRINT :H;1,"0” \*RESULT IS ZERO. 

8040 PRINT ;H;2/"." 

8045 RETURN \*RETURN TO CALLING PROGRAM. 

8050 IF X$="l" THEN 8058 \*CHECK FOR ONE VALUED FUNCTION. 

8051 IF Y$0"1” THEN 8068 \*CHECK FOR ONE VALUED FUNCTION. 

8052 FOR X=1 TO H9 \*2ND FN ONLY IS ONE VALUED. RESULT = F. 

8053 INPUT :F;X,X$ \*GET term OF F. 

8054 PRINT ;H;X,X$ \*PLACE IN H ARRAY. 

8055 IF X$="." THEN 8160 \*END OF FUNCTION? 

8056 NEXT X \*REPEAT FOR NEXT TERM. 

8057 *PROCEED TO FUNCTION REDUCTION STEP.\GOTO 8160 

8058 IF YSO"l" THEN 8062\*1-ST FN IS 1-VALUED. IS THE 2ND FN 1-VALUED? 

8059 PRINT :H;1,"1" \*90TH FNS ARE 1-VALUED. RESULT IS 1-VALUED. 

8060 PRINT :H;2,»." 

8061 RETURN \*RETURN TO CALLING PROGRAM. 

8062 FOR X=1 TO H9 \*1ST FN IS 1-VALUED. 2ND IS NOT. 

8063 INPUT :G;X/Y$ \*RESULT = G. 

8064 PRINT :H;X,Y$ 

8065 IF YS="." THEN 8160\»END OF FUNCTION? 

8066 NEXT X 

8067 *PROCEED TO MINIMIZATION STEP.XGOTO 8160 

8068 W=1 \*NEITHER INPUT IS CONSTANT-VALUED. INIT POINTER TO H. 

8069 PRINT :H;1,"0” \*INITIALIZE H TO 0-VALUE. 

8070 PRINT :H;2,"." 

8075 FOR X=1 TO H9 \*BEGIN PRODUCT-TERM FORMATION LOOP. 


no 


8080 INPUT :F;X/X$ \*get term from f. 

8090 FOR Y=1 TO H9 \*3EGIN LOOP FOR ACCESS TO G. 

8091 INPUT :G;Y/YS\-*GET term FROM G, 

8092 ZS=X$^YS \*FQRM PRQDUCT OF TERMS. 

8093 PRINT ;B?W,Z$\»PLACE RESULT IN H. 

8100 *CHECK FOR ZERO PRODUCT.XGOSUB 8250 

8110, INPUT :G;Y+1/Y$\*CHECK G for end of FUNCTION. 

8111 IF YS="." THEN 8130 

8120 NEXT Y \*NOT END OF G. GET NEXT TERM. 

8130 INPUT :F;X+1/X$\*CHECK F for end OF FUNCTION. 

8131 IF X$=”.” THEM 8150 

8140 NEXT X \*NOT END OF F. GET NEXT TERM. 

8150 IF WOl THEN 9155 \*END OF BOTH FNS REACHED. 0-VALUE RESULT? 

8152 PRINT ;H;l/”0" \*YES. LOAD 0-VALUE IN H. 

8153 RETURN \*RETURN TO CALLING PROGRAM. 

8155 PRINT !H;H,“." \*NO. LOAD END-OF-FUNCTION MARK. 

8160 FOR X>1 TO H9 \*BEGIN MIN STEP BY ORDERING LITS IN EACH TERM. 

8165 INPUT :H;X/X$ \*GET a term FROM H. 

8167 IF X$=".” THEM 8190\*END OF FUNCTION? 

8170 *NO. ORDER LITERALS. \GQSUB 8650 

8175 PRINT :H;X,Z$ \*REPLACE ORDERED TERM. 

8180 NEXT X \*REPEAT FOR NEXT TERM. 

8190 *ORDER TERMS OF THE FUNCTION. \GOSU8 7200 

8200 ^REMOVE REDUNDANT TERMS. \GOSUB 17000 

8210 RETURN \*RETURN TO CALLING PROGRAM. 

^ 250 **'*******'*************^***'************'*'********'***^***'****'**^*'**** 

8251* SUBROUTINE TO CHECK FOR ZERO PRODUCT TERM. 

8252* TERM TO BE CHECKED WAS FORMED BY THE AND SUBROUTINE 

8253* AND WAS PLACED IN THE H ARRAY. THE TERM IS RETRIEVED FROM H 

8254* FOR PROCESSING. IF THE TERM IS ZERO/ THE POINTER (H) TO THE 

8255* H ARRAY IS NOT INCREMENTED WHICH RESULTS IN THE TERM BEING 

8256* OVERWRITTEN BY ANOTHER TERM. IF THE TERM IS NON-0/ W IS INC. 

8257* CALLED BY THE AND SOBROUTINE. 

8258****************************************************************** 
8260 C=1 \*SET THE SPECIAL CHARACTER FLAG. 

8270 D=1 \*SET THE MINOS FLAG. 

8280 ZS="" \*CLEAR A TEMPORARY VARIABLE. 

8290 B$=”" \*CLEAR ANOTHER TEMPORARY VARIABLE. 

8300 INPUT :H;W/Y$ \*GET TERM TO BE ANALYZED. 

8301 L=LEN(Y$) \*COMPUTE LENGTH OF TERM. 

8310 FOR A=1 TO L \*BEG1N TERM ANALYSIS. 

8320 X$=Y$CA/1) \*EXAMINE A CHARACTER FROM Y$. 

8330 IF X$>"Z" THEN 8350\*NOMERAL? 

8332 IF X$=”-” THEN 8350\*MINOS SIGN? 

8334 IF X$="*" THEN 8350\*STUCK-AT-0 SYMBOL? 

8336 IF X$=”!” THEN 8350\*STOCK-AT-1 SYMBOL? 

8340 IF C=1 THEN 8400\*END OF LITERAL? 

8341 *YES. LOOK FOR ITS COMPLEMENT. \GOTO 8423 

8350 C=0 \*SPECIAL SYMBOL FOUND. CLEAR FLAG. 

8360 IF X$<>"-” THEN 8370\*WAS THE SYMBOL A - ? 

8365 D=0 \*YES. CLEAR FLAG. 

8366 *GET NEXT CHARACTER. \GOTO 8600 


m 


8370 

8390 

8400 

8410 

8420 

8430 

8440 

8450 

8451 
8460 
8462 
8464 
8466 

8470 

8471 
8480 
8490 
8500 
8510 
8520 
8530 
8535 
8540 
8550 
8560 
8570 
8580 
8590 
8595 


IF DOl THEN 8400\*CHECK FOR COMPLEMENTED LITERAL. 
Z$ = Z$+"-'' \*NOT COMPLEMENTED. INSERT MINUS. 

Z$=Z$+X$ \*CONSTROCT TEST LITERAL. 

♦GET NEXT CHARACTER. \GOTQ 8600 


C=1 

B1=A 

FOR 0=B1 TO L 
INPUT 

X$=Y$(:3/1) 


\*SET SPECIAL CHARACTER FLAG. 
\*SAVE POINTER TO Y$. 

\*FIND NEXT LITERAL IN TERM. 

\*GET THE TERM FROM THE FILE. 
\*GET A CHARACTER OF THE TERM. 

IF X$>”Z” THEN 8480\*A NUMERAL? 

IF X$=”-” THEN 8480\*A MINUS SIGN? 

IF X$=”*»' THEN 8480\»STUCX-AT-0 SYMBOL? 

IF X$=”l” THEN 8480\*STUCK-AT-1 SYMBOL? 

IF C=1 THEN 8490\*END OF LITERAL? 

♦YES. COMPARE TO TEST LITERAL. \GOTO 8510 
C=0 X^SPECIAL CHARACTER. CLEAR FLAG. 

BS=BS^X$ \*CONSTRUCT LITERAL. 

♦GET NEXT CHARACTER. \^COTO 8540 
IF Z$=B$ THEN 8620\^COMPARE WITH TEST LITERAL. 
C=1 \^NOT = . SET SPECIAL CHAR FLAG. 

B$='"' NUCLEAR TEMPORARY VARIABLE. 

♦SEARCH FOR NEXT LITERAL. \GOTO 8450 


NEXT B 

IF Z$=B$ THEN 8620 

C=1 

D=1 

Z$ = '"' 

Bj-nii 


\*REPEAT FOR NEXT CHARACTER. 

\*COMPARE LAST LITERAL WITH TEST. 

\^SET SPECIAL CHARACTER FLAG. 

\^SET THE MINOS SIGN FLAG. 

V^CLEAR A TEMPORARY VARIABLE. 

\*CLEAR ANOTHER TEMP VARIABLE. 

♦DEVELOP A MEW TEST LITERAL. \GOTO 8320 
8600 NEXT A X^REPEAT FOR NEXT CHARACTER. 

8610 ¥=«♦! \^N0N-0 TERM. INC POINTER TO H. 

8620 RETURN X^RETURM TO AND SUBROUTINE. 

8550 *»*****♦*♦**♦***♦*♦♦♦♦♦*♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦*♦*♦♦♦♦ ♦*♦♦♦♦♦♦♦♦♦♦♦♦♦♦♦ 

8651* SUBROUTINE TO SORT THE LITERALS IN A PRODUCT TERM. 

8652» LITERALS ARE PASSED TO SUBROUTINE IN Z$ AND THE SORTED 
8653* TERM IS RETURNED IN 2$. 

8654* CALLED BY THE AND SUBROUTINE. 

8655* CALLS THE TERM DISASSEMBLY SUBROUTINE. 

8555 ****»*************'*»*♦♦*♦♦*♦♦♦*♦♦♦*♦*♦*♦*♦♦♦♦♦*♦♦♦♦ *♦*♦*♦**♦**♦♦♦♦♦ 

8660 *DISASSEMBLE THE TERM INTO LITERALS. XGOSU3 7800 
8663 C=0 X*INITIALIZE COUNTER. 

8668 B1=A X*GET NUMBER OF LITERALS IN TERM FROM SUBR 7800 

8670 FOR A=1 TO B1 X*S0RT THE LITERALS IN A$ USING A BUBBLE SORT. 


8680 

8690 

8700 

8710 

8720 


IF A$(A+1)="," THEN 8740X*END OF LITERALS. 

IF A$(A)<AS(A+1) THEN 8730 X*COMPARE TWO LITERALS. 


ZS=AS(A) 

A$(A)=A$(A+1) 

A$(A+1)=Z$ 


8730 NEXT A 


X*RE-ORDERING NEEDED. SAVE ONE LITERAL, 
X*SWAP PLACES OF THE TWO. 

X^COMPLETE THE SWAP. 

X*REPEAT FOR NEXT PAIR. 


8740 IF Bl=l THEN 8750 X*CHECK FOR END OF SORT. 


8745 81=81-1 


X*DECREASE LOOP LIMIT. CONTINUE SORT. 


8746 *REPEAT FOR NEXT PASS THROUGH THE LIST.XGOTO 8670 



112 


8750 FOR A=1 TO 20 


\»SORT COMPLETE. LOOK FOR DUPLICATE LITERALS. 


8760 IF A$(A*1)=”.” THEN 8830\*LQQK FOR END OF LITERAL LIST. 

8770 IF A$(A)=A$(A+1) THEN 8780\*LOOK FOR IDENTICAL LITERALS. 

8771 *NOT IDENTICAL. CONTINUE SEARCH. \GOTO 8820 

8780 C=C+1 \*IHC COUIItER. 

8790 FOR B0=A TO 20 \*REMOVE DUPLICATE LITERAL FROM LIST. 

8800i AS(80)=A$(80-»-l)\*SHIFT A LITERAL. 

8805 IF A$ (BO )=•*." THEN 8820\*END OF LIST? 

8810 


NEXT BO 
8820 NEXT A 
8830 Z$=“" 

8835 FOR A=1 TO 20 
8840 

8850- Z$=ZS+A$(A) 

8860 NEXT A 
8870 RETURN 


\*CONTIMOE SHIFTING. 

\*REPEAT FDR NEXT PAIR. 

\»CLEAR TEMPORARY VARIABLE. 

\*BEGIN RECONSTRUCTION OF PRODUCT TERM. 
IF A$(A)=»." THEN 8870\*END OF LITERAL LIST? 

\*NO. APPEND TO TERM. 

\*REPEAT FOR NEXT LITERAL. 

\*RETURN AMO SUBROUTINE. 


17000 * **************************************************** ************ 


17001* 

17002* 

17003* 

17004* 

17005* 

17006* 

17007* 

17008* 

17010 

17015 

17016 
17020 
17030 
17040 
17050 
17060 
17070 
17080 

17090 

17091 
17100 
17110 

17115 

17116 
17120 
17122 
17125 
17130 
17135 

17140 

17141 

17150 

17151 
17155 
17160 


SUBROUTINE TO MINIMIZE FUNCTIONS. 

A FUNCTION IS SAID TO BE MINIMIZED (IN THIS CONTEXT) IF IT 
CONTAINS NO REDUNDANT PRODUCT TERMS. HENCE THE SUBROUTINE 
REMOVES DUPLICATE TERMS AND TERMS COVERED BY ANOTHER TERM. 

A FUNCTION IS PASSED TO THE SUBROUTINE IN ARRAY H. 

THE REDUCED FUNCTION IS RETURNED IN ARRAY H. 

CALLED BY THE AND SUBROUTINE AND THE OR SUBROUTINE. 
*«««****•*********«***********•*************««****-*************** 

FOR X=1 TO X2-1 \*EXANINE EACH TERM OF THE FN. 

INPUT :H;X,Z$ \*GET A TERM FROM ARRAY H. 

IF Z$="." THEN 17220\*EN0OF FUNCTION? 

XS=Z$ \*NO. COPY TERM TO X$ FOR PARSING. 

*PARSE TERM INTO LITERALS. \GOSUB 7800 
FOR Y=1 TO 20 \*COPY LITERALS TO ARRAY DS. 
D$(Y)=A$(Y)\*COPY A TERM. 

IF A$(Y)=''.*’ THEN 17080\*END OF LIST? 

NEXT Y \*NO. REPEAT FOR NEXT LITERAL. 

FOR Y=X+1 TO X2-l\*COMPARE ABOVE TERM TO ALL OTHER TERMS. 
INPUT ;H;Y^Z$\*GET A TERM FROM ARRAY H. 

IF Z$=».'* THEM 17210\*END OF FN? 

XS=Z$ \*COPY TERM TO X$ FOR PARSING. 

*PARSE THE TERM INTO LITERALS\GOSUB 7800 
F5=l \*INITIALIZE FLAG INDICATING 

*A REDUNDANT TERM. 

FOR 8=1 TO 20\*COMPARE LITERAL LISTS OF TiflO TERMS. 

IF F5=0 THEN 17200\*CHECK FLAG FOR NO REDUNDANCY 
IF D$(B)=".” THEN 17170\*END OF LIST? 

FOR A=1 TO 20\*SCAN LIST OF 2ND TERM. 

IF A${A)=".” THEN 17165\*END OF LIST? 

IF A$(A)=D$(B) THEN 17160 

*COMPARE LITERALS OF TWO LISTS. 

F5=0 \*LITERALS ARE NOT ALIKE. 

*CLEAR FLAG TO INDICATE NO REDUNDANCY. 
NEXT A \*REPEAT FOR NEXT LITERAL OF 2ND TERM 
F5=l \*MATCH FOUND. POSSIBLE REDUNDANCY. 




I 


i 


113 


17165 

17170 

17180 

17185 

17190 

17195 

17200 

17210 

17220 

20000 


NEXT B \*REPEAT FOR NEXT LITERAL OF 1ST TERM 

FOR C=Y TO X2-1\*2ND TERM REDONDANT. DELETE FROM H. 
INPUT :H;C+1,Z$\*GET A TERM FROM H. 

PRINT ;H;C,Z$ \*PLACE TERM IN NEW POSITION. 
NEXT C \*REPEAT FOR NEXT TERM. 

♦GET NEW 2ND TERM.\GOTO 17090 
NEXT Y \*REPEAT FOR NEXT TERM. 

NEXT X \*REPEAT FOR NEXT FIRST TERM. 

RETURN \*RETURN TO CALLING PROGRAM. 

END 


lOarOCT II, '79 OC/TESTGNDOC.BCARRULL 


sssss 

s 

sssss 

s 

sssss 


MM^WV 
IV) M 

fi/! M 
M M 


program: 

vf-RsiU'M; 

REVISION: 

DATE: 

PROGRAMMER: 


L 

L 

L 

L 

LL\LL 


00000 
0 0 
0 0 
U 0 

uoooo 


TESTGNOOC 
SlGMfl 5 
ORIGINAL 
10/10/79 
B, 0, CARROLL 


GGGGG 

G 

G GO 
G i; 
GGGGG 


CONTRACT SUPPORT 


THIS PROGRAM "VAS DEVELOPED FOK NASA MARSHALL FLIGHT 
CENTER UNDER CONTRACT MASS-3157a. 


MOOIFICATIOM HISTORY 


PROGRAM DESCRIPTION 


TESTGN IS A PROGRAM FOR GENEHATI.mG TEST SEOUENCES FROM ThF 
SIMULATI0r4 OUTPUT PRODUCED BY THE SIMLOG PROGRAM, 

TESTS may be generated FOR CIRCUIT INPUTS FPQM A FAuLT-FREE 

SIMULATION, TESTS FOR SPECIFIC FAULTS MAY ALSO BE GENERATED 

f-ROM A fault SIMULATION OF THE CIRCUIT wITH THE FAULT 
INSERTED. 


'DIMENSION STATFMENTS 


DIM I'jC^OOfU), I(U00,3), U(50,2), P(200,2) 
"DIM A5(51) ,0^(51 ) 

DIM U(1 ) 

DIM LS(I0),M?C10,2) 

DIM Ei(200) 


115 


t************i 
t«*A* k it * i 


STAPT UF ‘-'AIN PPOGW&M 


:****♦■* 


t OPE-'l CIPCiJIT f)ESCRIFTION FILE(f'.hT). 

OPEN "NET" TO ;i, INdiJT UPDATE 

HP=y00 

Y5=10U 

PPINf'SELECT test GENERATION MODE. <CE>=1." 
PRINT" (1) UNSPECIFIED FAULTS," 

PRINT" ' (2) SPECIFIED FAULTS." 

input '^5 

Ip-f-iSoO THEN 1230 ' 

M 5 = l 

IF' mS< = 2"THEN 12 55 ■ - - ^ - 

PRINflMVALID MODE NUMBER FiNTERED, TRY AGAJN." 

GOTO 1212 

♦LOAD CIRCUIT OESLRIPTION PKON FILE NET, 
GOSuIi 6000 

♦rnNSTRUCT A LIST UE PRINARY OUTPUT NAMES. 

Y = 1 

FOK X=1 10 Nl 

■■ IF .Kx7Tno"YE3'^"TPEN' 1270“ ■ ' 

MB(Y» 1 )=N(X, 1) 

■ '~'MB(Y, 2 )=SrR(X) 

YSY + 1 

'NEXT X"'. 

♦ COMPUTE The number OF PRIf»iA«Y OUTPUT NF TS. 


1275 03=V-1 ■ ' ■ 

1279 *CCNSTRUCT A LIST OF PPIi>^ARY INPUT MANES, 

1280 Vil ------ 

1285 FUR x=l TO 10 

1290 IF I(x,S)o"YFS" THEn''1505‘ 

1292 IF Y=1 THE I 1 298 

1290 • - F0R‘Z=I to Y-I 

1295 IE LS(Z)=I(X,l) THEN' 1305 

'1295 NExr-Z ~ 

1296 L5(YJ=I(X,1) 

Trocr YsYri 

1305 NEXT X 

l’30'9 5fC0^iFrjTE'T?<E'N^U.''ffiER '0F 'PRIMARY “INPUT NETS, 

1310 I3=Y-l 

1319 ■“ i'ChECK- FOR ‘MODE SELFC T I ON (^5=2 ; SPECIFIED FAULTS), 

1320 IF M5=2 THEN 1500 

1309 ' *8EG'lM primary CONTROL LOOP FOR UNSPEr IFIED FAULT MODE, ' 
1350 Fur x6=i to 05 

"1350 *SELECT 'A PRIMARY 'O'lTPliT NET. 

1355 UB = mmxo,1) 




116 


1JS6 ~ X5=VALCvjfXo,?) ) 

1360 FOR Y6=1 TO 13 

I36a *SFLECT a primary input rjEf. 

130*5 Ai» = LF(y6) 

1370 • ■ FOR T=l TO TO 

1372 *SELtCT A TJME TAG. 

1373 TS = STR(n 

137a TtsTSCSJ 

137S ' ' ' *COMPUTE' COPRESPONOI.^mG TEST Fi'm.VGOSUH 2020 

1377 *PRIf\lT TEST FUNCTION. JGOSUb 11009 

1380, ' NEXT T ■ ■ ■ 

1385 NEXT Yo 

1390 NEXT X6 
1395 GOTO 1620 

1500, PRTi\lT"ENTER THE FAULTED NET NAME"; 


1510, input w4 

1520, PRINT’’INTER' THE FAULT CONO I T I OM (SO/S 1 ) " ; 
1550 INPUT Si 
I533riF"SS="S0" THEN "1530' 


1536 Tis"!" 

1537 GOTO iSao 

1538 T$="*" 

1559 *BEGII'l PRI'^ARY CONTROL LOOP FOR SPECIFIED FAULTS MODE. 
15ao FOR X6=l 10 05 

1549 - *SELECT A PRIMARY OUTPUT NET. 

1550 05=MS(X6»1) N 

“1560 - XS = VAL(MS(X6#2n 

1569 *C0MP(JTE THE TEST FUNCTION. 

1570 G0SU6 2020 ' 

1579 -aPRINT test FUNCTION HEADER INFO. 

1580 PRIMT"QUTPUT-Lr'iE = ";OT 

1590 PHINT"FAULT = " ;wTt’'/"+Si 

1599 *PRINT THE TEST FUNCTION, 

1600 GOSUH 11030 
1610 NEXT X6 

1620 CLOSE : INCLOSE ;2\ClOSE :3\CL0SE ;a 
1630 CHAIN LINK' "Sr-UEXFC" 


“^ 00 ^ 
2002 * 
■^ 00 T*“*:l 
2004* 
“? 0 TT 5 ‘*' 
2006**' 


subroutines 


200r* ~SURROrjTTNE“TOR COMPUTING A TEST FUNCTION. 


■ 2 oim‘ 


2020 *RtrRIEV£ OUTPUT FUNCTION PAIR.NGOSUH 5000 
2049 *COmPuTE“The first REDUCED FUNCTIOM. 

2U50 FUR X=1 TO 200 
2055 input :F;X,x$ 

2060 IF Xi = "." THEN <>150 


117 


“ 20o5' 

- -y-.J 


20/0 

bOSUri Ot>00 


2072 

IF Z9 = o FhE'm 2095 


2080 

IK Z9=l them 2100 


2090 

IF Xl»l ; 19 - 1 , 1 )>”2” Tht.\ 

2100 

2091 

IF Z9tL2>Ll-L2+l ThEfi 2095 

209tf 

Y=Z9fL2 


209} 

GOTO 2070 


209S 

Xi = "" 


2096 

PFIWT :F;X,X5 


2096 

GOTO 2110 


2100 

IF X£oiA<$ + it them 2105 


2102 

PHINT ;F;l,"r’' 


2105 

PRINT ;F;2,''." 


2100 

GOTO 2300 “ 

■ ■ 

21oS 

IF Z9zl THEN 2108 


2106 

PRar :F ;X/XJ(; l,Z9-l)+X$(:Z9 + L2) 

210/ 

GOTO 2110 


■2108' 

print ':F;x,x£(:Z9kL2) 


21 10 

(•lEXT X 


2150' 

print :H;1,"" " 

* 

2155 

y=i 


215S 

FOP X = 1 "TO 200 


2165 

input :F;X,X£ 


2166 

IF xir'”' THEN 2190 


21/0 

PRINT :m;Y,XS 


2172- 

“IF THET2200~“ ' 


21 /5 

Y=Y + 1 


2190’ 

'NEXT' X 

' 

2200 

INPUT 


2201' 

rF~X'} = ";""THFN-'2250 


2205 

FOR X=1 TO 200 


2210 

■ ' ItjPUr :H;x,'X5 

*— 

221 1 

P*JINT ;F;X,X£ 

' 

2215 

IF 'Xi-s"." ThEN' 2 500 



2220 

NEXT X 


22S0^ 

PRINT' ;F • r,"0" — ‘ 


22o0 

PRINT ;F;2,",'' 


2299 

*COMPUTE~T?TE SECOUn FEDUCED 

function: 

2300 

FUR X=1 lU 200 


2305 

■ 'U4PUT-':r,;X,x5 ' 


2510 

IF X4="." THEN 2532 


“25Tr 

Y = 1 


2512 

GOSUb a50‘» 


“■23 a 

— rF-Z9 = 0“THE'T2T2o 

' 

231 a 

IF Z9=l THEM 2322 


231S- 

IF ”X£T;Z9-1 ,T)>"Z" THEN' 

2322 

2316 

IF Z9+L2>L1-L2+1 THEN 2520 

251/ 

Y=Z9+L2' ■■ ■ 


2318 

GOTO 2512 


2I2(T 

■pRT'iTTG;X, "" 

" 

2521 

GOTO 2530 



118 


-2ZZ2 ir xr<>/jF+'^-" + T« THE^J -3326 

2323 PRIMT 

^32^r - - PRINT 

2325 GOTO 2400 

?32.6'“ IF Z9=rTHE^i 2329" 

2327 PRINT :G;X,X$(: 1 ,29-1 )*XACZ9 + L2) 

2T20 ” GOTO 2330 

2329 PRINT !G; X,XJ(:Z«+L2) 

2330 NEXT X 
233.2 PRINT 

2335 Y=1 ' - - - - 

234(0 POK X=1 TO 200 
23«i5 INPUT :GjX,Xi 

2346 IF XJs"" THEN 2365 

2350 PRINT :H;Y,X$ 

235.5 IF Xi = "." THEN 2370 

2360- Y = Y+1 

236.5 NEXT X 

237.(T‘irY=l then- 2394 - - 

23T5 FOR X=l TO 200 

2380 INPUT ;H;X,XS 

2381 PRINT :G:X,X$ 

2385- IF XJs"," THEN 2400 

2390 NEXT X 

2394 PRINT- :G;1,'»0" 

2396 PRINT :G;2,'’." 

2399 *COMPUTE THE FIRST'AND RESULTANT, 

2400 GOSUH 8000 
2410 FOR X=I TO 200 

2415 . INPUT :H;X,X« 

2416 E*(X)=Xi 

2420 IF X$=”." THEN 2430 

2425 NEXT X - ' ' - 

2430 *RETRIEVE THE OUTPUT FUNCTION PAIR ONCE AGAJN, 

2431 *CONPUTE the third REDUCED FUNCTION, 

2440 G0SU3 3000 

2442 -FOR X=1 TO 200 - 

2444 input :F;X,X$ 

24a6“TF“ XSr»i" THEN" 2480 

2448 Ysl 

“2450 GTJ3UH~45(70 

2451 IF Z9=0 THEN 2462 

2452 IF Z9sr-THEr-Zy-65 

2454 IF XH{;Z9-1, 1)>"2" THEN 2468 

2456 - • IF-Z9tU'2>Ll-L2 + l THEN 2462 
2458 YSZ9+L2 

-24err Gcrnj easo 

2462 XSs”" 

2464 PRINT ;F;X,XF- - 
2466 GOTO 2479 

2468 IF Xl<>.^•S^■"-‘’fTS THEN 2475 

2470 PRINT :F;1,”1" 


I 


119 


\kUJ2' Pk1i.|7 “ ;F;^; " 

I GOTO 25lo 

1 ZmS ~ IF Z9il Tr<tN- ^?a7*^ 

2«76 PkINT :F;X,Xi(; 1 ,Z9-1 ) + XK;Z9-H2) 

2«/7~ "r/riTO 2i<79 

2«79 PWirn jF; X, X«( ; ZP + L2) 

2a 7'^ NEXT X ■ 

2a0() PWINl 
2"a02 Y=l 

2aaa fo« x=i to 200 

2a86 INPUT ;F;X,Xi 
2adH IF XSz"” THEN 2a96 
'2a90 PPINT :H; Y, XF ■ ' ■ ■ 

2a92 IF X-Ss"," THEN 2a98 

'2a9a 'Y=Y + i ' 

2496 NEXT X 

2a‘98 Input ,xi ~ ' 

2S0O IF X.'6 = "," THEN 2512 
■ 2502 FOK xsl 'TU 20"0 ■ ' ----- - 

250U INPUT :H;X,X'B 

2506'PRlNr ;r;X,xF ' - - - 

250H IF XS="." THEN 2516 

2510 NEXT X 

2512 PR TNT ;F : I , "O" 

■■251a PH"lNr :F;'2,"." " - - 

2515 ^COMPUTE THE FOURTH KEOUCtO FUNCTION. 

■25r6~Fni? xsrrcraoo ■ ■ 

25ia INPUT ;G;x,XF 

2520 IF -x$r«;'* THEN 2552 ‘ ’ 

2522 Ysl 

"2S24' GJSU'0 “aooo ' ' 

2525 IF Z9£0 Then 2536 

2526 "■ rF'Z9srTHEN 2540 ' " 

2520 IF XF( :Z9-1 , 1 )>"Z" then 2540 
2530 IF 29^L2>U-l2M then 2536 

2532 Y=Z9+l2 

■2534~G0 TO '2524 ' ~ > - 

2536 PRINT ;G;X,"" 

-2538-G0T0'2550 . 

2540 IF xJ.o.v$ + Ti Then 2546 

”2542“ Pkl.MT'rGnyV' ■ 

2544 PRINT ;G;2,",'' 

~254'5' G0nr~250'6 

2546 IF Z9=l THEN 2549 > 

' 25in -pprTT-TGrxTXTr; rr'Z9-Tm$( ;r9+c2) ' “ 

2546 GOTO 2550 

2549"' ■ PRrMT'rG“;X%Xi(T29FL2) ~ ' 

2550 NEXT X 

2552 PRINT ;H; i , '••• ' 

2554 Y=1 

2556 Fu9''x-=r-TO"200 
‘2550 INPUT :G;X,X5 


120 


~256V' TF X'5 = '^*' THEM 25’68 
2562 PKINT :h;Y,xJ> 

256a IF'XIs"." THEN 2570 ‘ 

2566 Y=V+1 

2568" NEXT X -- - - 

2570 IF Y=1 Then 25H2 
'2572‘TOR X = I TO 200 
257a Input :h*x,xt 
2576 PRINT :G;X,X5 
2578 IF X1i = "," THEN 2586 
~2580"NEXT"X ■" " 

2582 PRINT ;G;1,"0" 

258a PRINT ■:G;2,"." 

2585 *CONPUTE THE SECOND AND RESULTAi\.T. 

2536 GOSUB 8000 
2750 FOR X=1 TO 200 
2755 “ PRINT ;F;X,E$(X) 

2760 IF EJCXjs"." THEN 2770 

■"2765" NEXT X ■' 

2770 FUR X=1 TO 200 

2775 'INPUT ;rl;X,X5 

2776 PRINT ;G;X,X* 

2780 ■' IF XS="," THEN 2790 
2785 NEXT X 

' 2709 *CO>iPUTE THE OR RESULTANT. 

2790 GOSUB 7000 
'2792 IF M5=2 THFN 2999 
2795 FOR xst TU 200 

2800 INPUT :H;X,X$ 

2801 ■ PRINT :F;X,X1i 

2805 IF Xls"." THEN 2815 
2810 NEXT X 

2815 PRINT :G; 1 ,’aS + TJ ' 

2820 print ;G;2,A5 + ''-">T3i 
2825 PRINT 

2829 *CUMPuTE the TEST FUNCTION. 

"2630 GDSU5 8000 
2999 RETURN 

■“5000 * * * *"**** *V** •***'**♦* ***************************************^******* 

3001* ROUTINE TO RETRIEVE OUTPUT FUNCTIONS. 

'SCO'S* f** iitin x"********************************************************** 

3009 *RFTRIEVE Th£ ONF-FUNC T I ON . 

~70 ro"T=o — 

3020 K=1 

3030 GnSUB'5000 

3039 *RETRIEVE THE ^ERO-FUnCTION. 

■TiraTT“'J=3 ~ ■ " ■■ ■"“ 

3050 K=0 

3060 GCSUP 5000 

3070 RETURN 

aooo«***ft******»**»«**’**«************#*****************************«** 

aooi* subroutine for searching FOR the substring XS. 


<400<?V PUSl'n'Or^ OF 

UOOi* I£j fjOT A 


121 

X5”IS ><ETUHNEO AS Z9, 
SuaSTt.PG OF wifTi. 


/9 = 0 IS PE TURNED IF 


the pointc**. 


a 003 *r\)lTlALrZE 
300b_Z9=o _ 

aOlO LlsLEKCX'tJ 

L2=LEN(u'». + T i) 

*SCA.'m "ii~ starting 
MjK Z=Y TU U 
- ' IF--Y$(-;Z,L2) = 'ii + T5 

r4£XT Z _ __ _ „ 

PETuPN 

♦ LOAD POINTER '.vITh POSITION 
Z9=Z 


3015 
UO 19 
3020 
302T 
3030 
3D35 
3039 ^ 
'3 03“0“ 
3035 


AT Y FOR Y.Ti + Ti, 


THEN 3030 


OF SUBSTRING. 


return 


3500***********************i 

_3501* SUBROUTINE FOR SEARCHING STRING W$+-"-" + TS FOR SUBSTRING 

3S0'2* 'Xb\ "position of Xi IS' RE TURNED AS 19 , Z9=0 IS RETURNED IF XS 

3^0_3* IS NOT A SUBSTRING OF rt£V*-"»TS. 

' 35CUi"ViNTT rAXTZF“THE~POINTER^ " ‘ 

3505 ZR=0 

■3510" n=LEN(X$)- "• 

3515 L2 = (.EN(*.'^f"-" + Ti) 

3519 "♦SCAN Xi STARTING A I Y FOR ♦ T i , 

3520 MIR Z=T TU LI 

3525 ~ IE x$(:Z,L2) = .^*t''-" + T'6 THEN 3530 
3530 NEXT Z 

■3535"RETDRK' * ■“ ’ ~ " ' " 

3539 *LOA0 PUIMTER a'ITH POSITION OF SUBSTRING, 

3530"Z9'=Z ' ■ ■ ” . 

3535 RETURN 
5 0 00 * * * i * ★ iT V * * 

5001* subroutine to 

■5002* FU-rjCTinrrTILE: 

500S***************** 

5Qos"ry.p'uT=o "■■ - • 

5006 *DFFIGE file channel FUNCTIOfiS, 

S(T0r'E = J-2*S'*JFT*S" '■■ 

5010 Fsl - 3*S+S*J 

5D15"G=7*S 

5020 H=7-3*S-J+J*S 

■502-3-~*CCCSE ArCE~nCFSV ■ •' - 

5025 CLOSE ; INCLOSE ;2SCLOSE :3\CLUS£ 

'5'029 *(i PEN' 'FILET COiMTXInInG ' rUNCTrd''J“Tu 
5030 IP S=1 THEN 5050 


transfer FUNcrrox from 
T ff"FUMcrio?r array. 


:3 

BE 


retrieved. 


■"5 0 55— TF T= 3~Th FO' 


5030 

open 

"NE.-iO" 

TO 

50 31 

'GP'EfT 

"FARRAY 

II 

5032 

OPEN 

"GARRA Y 

ft 

5033 

OPEN" 

"HARRAY 

n — 

50 33 

GOTO 

5130 


TO'ZJS' 

"OPEf" 

■■".'TE'vT"~ 

TO 

5036 

OPEN 

"HARRAY 

fl 


:S, input update 
to ; r/TwFuT 'update 

TO :2, INPUT UPDATE 
TO 1 O', INPUT" UPDATE 

";'3 “PJPn-mPD ATE - 
TO ;3. INPUT -UPDATE 


122 


5(n7— DFEivj— "FffRRflY" TD~:I,INPUT UPDATE 
S0«8 fJPEM "GARRAY" TQ ;2 ,InPUT UPDATE 
5039 -goto 5 1 30 ~ - " 

5050 IF J = 3 THE>\. 5060 

50'52'0'PEfi "FAPRAY" TQ :l, INPUT UPDATE 

5051 OPEiJ "GARHAY" to :3»lwPUT UPDATE 
“ 505^3 OPfc'N "HARRAY" TO :a, INPUT UPDATE 

5055 OPEN "OLDO” TO :2, INPUT UPDATE 
5056' GOTO 5130 

5060 OPEN "OLDl" TO :l, INPUT UPDATE 
506,1 OPEN~'*FARRAY"“TO :2» INPUT UPDATE 

5062 OPEN "GAPRAY" TO :3#InPUT UPDATE 

5063 OPEN" "HARRAY" TO :3, INPUT UPDATE 
5130 V=X5 

51«,9 *TR4NSFER THE FUNCTION TO ARRAY G, 

5150 input :E;Y5*(V-n + l#X$ 

S160 FOR X=1 TO 1000 
5170 INPUT ;E»Y1i 

~5r80“PRm ":GY)r, YT' 

5190 IF Y$="," THEN 5260 

5200 NEXT X 

5260 IF KOI THEN 5300 

5269 *TPAMSFER THE FUNCTION TO FAPRAY. 

52/0 FOR Y=1 TO X 
5290 INPUT" :G;Y,YS 
5295 print !F;Y,Yi 

"5290 NEXT Y 

5300 inputs? 

5310 return 

6000<t»*****lr*********************************jk******jir*****A********(>** 

6001* subroutine to input circuit DESCRIPTJO'J from file. a 

t}002********************************************A***********A********* 

6010 INPUTS?"- • 

6015 lOslN ***INITIALIZE I ARRAY POINTER, 

bOirNlsn^-- - ***l!VITIALIZE N ARRAY POINTER. 

6020 Z? = ''"\ ***CLEAR Zi, 

602r"TNFnjT :3TT5V »**IK'PUT" ELEMENT DESCRIPTION FPQm FILE, 

6023 PRINT Zi\ ***PRINT ELEMENT DESCRIPTION. 

-6025-TF' THFN-6330\*LOOfC FOR ErJO 'OF ELEMENT ENTRIES, 

6050 N 1 sN 1 * 1 \ ***lr'.C N ARRAY POINTER, 

• 50 - 53 -*-***'* begtn -pAfTSiNG or Zf ********** 

6055 BSs^-S ***CLEAR bJ FOP NEXT FIELD, 

-6r0 3(T-XsTV A'OTNTTIACrZE POINTER "TO Z$. 

o050 IF Z?(;X/ns" " THEN b090\*EN0 OF ELEMENT-NAME FIELD? 

6060 DI5B? + ZS( rxnn ***EriO NOT REACHED. ADD TO NAME. 

6070 XsX*l\ ***liviC POINTER TO Z5>. 

6080“****"REPtAr FOR~NEXT CHARACTER IN Zl.NGGTG 6050 

6090 N(Vl,l)sHS\ ***v>iHEN "'A^E COMPLETE, PLACE IN N ARRAY. 

6100 N(Ml',-3 Js"NO«\ ***LABEL ALL ELEMENTS AS NO OUTPUT, 

6110 bils'"'\ *»*CLEAR B5 FOR NEXT FIELD. 

6120 XsX+tV ***INC POINTER TP ZS. 

6130 IF Z?(;x,l)s" " THE j 61/0\*END OF ELEMENT TYPE FIELD? 


I 


j 61 '10 

6150 
6 1 60 
6170 
6 i / 3 
6177 
6180 
6190 
6?0O 
6210 
6230 
6? '4 0 
6250 
6260 
‘6270 


123 

81>=8'R + 2S( : n\ uUT htACHEOr HUILL' NAi^E. 

x = x + l\ **xirc ^'ilIi'iTfcK TO /!$, 

***w£PEAr FHhi -vitxr CHAKACrtR Irj Z3>.\GnTO 6130 
'm(-M 
Z=l\ 

P ( I , 2 ) J 1 0 \ 
x = xtl\ 

H 4 = ”"\ 

IF Z3(:Arn = " ‘" 

Bi = BTi + Z'l>( ;_X, I )\ 

' X = x + l\"' ■ 


♦ ★♦.'•HEN maf’E complete, place in n array, 
♦♦♦initialize CUUM of element inputs, 

♦♦♦LCAP POINTER TO INPUT LIST, 

■'♦♦♦INC POINTER TO Z*. 

♦♦♦CLEAR B$ FOR NEXT FIELD, 

THEN 6250\^F.ND OF INPUT NAMf SUBFIEUD? 
♦♦♦END NOT REACHED, RECONSTRUCT NAME, 
♦♦♦INC POINTER TO Zi, 

♦♦♦REPEAT FOR NEXT CHARACTER IN Zi.\GOTO 6200 
I(IO,n=Ht\ ■ ♦♦♦rthEN name complete, place in I ARRAY, 

Z=Ztl\ _ ♦♦♦INC COUNT OF' ELEMENT INPUTS, 

IO = IOVl\ ■ ♦♦♦INC POINTER "TO I ARRAY, 


6280 LslENlZilN _ ♦♦♦COMPUTE LENGTH OFZi. 

6285 IF X<L ■■TnE''r 618U\V^^^IF ■ END NOT REACHED, GET NEXT INPUT, 
b^^ P (f'll , 1 )_=^J \ _ ♦♦♦rtHEN end reached, PLACE » OF INPUTS IN P, 

6300 '♦♦♦REPEA T FOR MEXT ELEMENT DESCRiPT ION,\GOTO 6020 

6430 FUR X=1 TO I0-1\ ♦♦♦ASSIGN NUMERIC CODE TO ALL INPUTS 

6431 ■ FURYsI to Nl\ ♦♦♦EXCEPT' primary INPUTS. 

64 32 IF I (X, I )<>.'j( Y, n then 6436 

6443 Z$=STR(Y) 

6444 r(X,3)=Z'B 

' 6435' ■ GOTO 6437 

6436 NEXT Y 

6437"'1E)(T X " ~ “ 


6442 I0S10-1\_ _ ♦♦♦COMPUTE THE NUMBER OF RO^^S JN I, 

6'445 TnP'UT ';3,Z£\ ' '♦♦♦GET PRIMARY 'INPUT' NAME FROM FILE. 

644,^ PRINT Z*\_ ♦♦♦PPINT PRIMARY INPUT NAME, 

644S* IF Z3 = " " THEN '6'465\^Lr OK 'F OR E'NO OF PRIMART INWIJT ENTRIES. 
6450 FOR X=1 TO I0\ ♦♦♦SCAN I ARRAY FQR PRIMARY INPUT NAMES, 

"6455 “ "IF '2I<>Ta7n' THEN 'F46'0" 

6457 _ I ( X, 5) = ”YES"\ ♦♦♦FLAG ^ITH YES vNlHEt' FOUND, _ 

I 6460 NEXT'X 

6462^^^*REPEAT ^OR NE^r INPUT NAFF.VGOTO 6445. 

6"4 65‘ 'INPUT' T3,2'R\' ♦ ♦ ♦GE'T"PR IMAR Y' OU T PU T NAME FRUM FILE, 

6466 PPINT ZS\ ♦♦♦PRI%r primary OUTPUT NAME, 

6a70‘"lF '7v3 = """"rHE'N'6500V*\'OCjir'FOR END OF' OUTPUT' NAME ENTRIES. 

64 72 FOR x = l TO .Y 1 \ ♦♦♦SCAN H ARRAY FOR PRIMARY OUTPUT NAMES, 

' 6475 lT~ZT<>-TT'X7ir'THEN'6u80 ■ - . 

647/ N(x, 4) = '’ yES"\ ♦♦♦FLAG »'ITH YES aHEN FOUND, 

"■64 8'0"'nE'x'T ~x ' 

6485 ♦♦♦repeat for NEXT OUTPUT NAN'E,\GOTO 6465 

65 (T0" T1 sU ' ■ ■ ■ ■ 

6510 input :i,ZTi\ ♦♦♦get xC element PAIR FROM FILE. 

‘ 65'n“'PRIl'JT"Z5\ ♦♦'♦PRlNT' ELEMENrPArR, 

6520 IF Z3 = " " then 6740\*U'OK FgR END OF XC PAIR ENTRIES. 

65'50' Q1=Q1 + 1\ " ' ♦♦♦INC POINTER TO Q ARRAY, 

6540 L = LEN(ZS)\ ♦♦♦LC'MPUTE LENGTH OF IS, 

"6550" FOR X=T TO L'\ " V* ♦BEGIN" PAIiSITiG' ZS. ' ' 

6560 IF Zi(;x,l) = " " IME'*'' 6580\*Ei'l0 OF FIRST NAME IN PAIR? 



124 


“^b5T0 NETXT X ' ' 

6580 Bi = Z%(: I »X-1 )\ ***LET B1> = FIRST 
65R0 C$ = Z5(;X>n\ * *i^*LET CF = SECOND fjAMF, 

66.M0 FOR xl = l TO f)l\ ***SLAr, ^4 AfciRAY FOR MANES OF XC tLE^XENTS. 

6641 ■ IF BS=N(Xl,n THEM 6b45 

6643 NEXT XI 

“6645 Z5 = STRCX1)V- ~ **»r,ENEftftTE NUMERIC CODE FOR ELEMENT. 

6646 U(iJl,l)=ZS\ ***PLACh CODE IN U ARRAY. 

6680 FOR Xlsl TnXJlX *<t*SCA('' N ARRAY FOR SECOND NAME IN XC PAIR, 

6681 IF Ci=N(Xl,lJ THEN 6685 
66S2 Xm'FXT XI ' 

6685 z$=sTR(xn\ ***(;enfratf numeric code. 

6686 0(01 f2)=Zi\ ■ ***PLACE CODE In G ARRAY. 

6690 ***REPEAT for NEXT PAIR OF XC ELEMENTS. \G0 TO 6510 
6700 RETURNS *<.xRETURN TO MAIN PROGRAM (1340), 

7000********* + ********************************<i*********************a* 

7001*'" ■ ' SObROuTINE FOR OPING T/->0 FUNCTIONS. 

7002* ONE FUNCTION MUST BE IN ARRAY F AND THE SECOND IN ARRAY G, 
-JOiTZT'- THE"'RESULTAMT"FONCTION IS PLACED IN ARRAY H. 

7004* CALLED 3Y THE MAIN PROGRAM ONLY. 

7005* CALLS THE SORT SUBROUTINE AND THE MINIMIZATION SUBROUTINE. 
70U6*****************************************************************ik 

7010 INPUT :F;l,xS ' \*GET FIRST TERM OF FUNCTION FROM F. 

7011 IF X*o”0" them 7035\*CHECK FUR ZERO FUNCTIONAL VALUE, 

7015 INPUT :G;1,YT ' \*GET FIPST TERM OF FUNCTION FPQm G, 

7016 IF Y4<>"0" THEN 7075S*CHECK FOR ZERO FUNCTIONAL VALUE. 

-7020- PRINT \*BOTH INPUTS ARE ZERO, RESULT IS ZERO, 

7025 PRINT \*L0AD EnD-OF-F UNC T I ON MARK, 

7030'RETURN ‘ ■" ■\*KETURN TO ^AIN PROGRAM. 

7035 INPUT TGM/Y'S \*G£T FIPST TERM OF FUNCTION FROM (;. 

7036 IF Y'F<>"0'* then 7110\*FIRST INPUT NOT ZERO, IS THE SECOND? 

7040 FOR X=1 TO H9 \*SECONO INPUT IS ZERO, 

7045 INPliT- :FjX,-XS\*RESULTANT IS EQUAL TO FIRST FUNCTION, 

7046 PRINT :H;X,X$ 

7050 *rF' XSs". ^ THEN 7060\*LOOK FOR END OF FUNCTION, 

7055 NEXT X \*REP£AT FOR NEXT TERM, 

7060 *SORr THE“'TE:FMS,- \G0SU8 7200 

7065 ‘REDUCE THE RESULTANT FN.SGOSUB 17000 

707o- return • \*RETURN TO MAIN PROGRAM, 

70 75 FOR X = 1 TO H9 \*F IRST FN = 0. SECOND FNOO. 

“7080 TvIPirr :G;X;YJ ~\*RESULTAT4T FN = second Fivj, 

7081 PRINT :h;X,YI 

~rUS5 IF-T^="V’~rHETrnr095V*LOOK' FOR" END OF 'FUNCTION. 

7090 NEXT X \*REPEAT FUR NEXT TERM. 

7095 '*SnRr THE 'TERMS. \G 0 SU 8 . 7200 

7100 *kEOUCE THE RESULTANT FN.NGOSUb 170v0 

-7I0S“RETURN' -V*RETURN TO MAIN PROGRAM. 

711'0 input :F;1,X6 \*GET FIRST TERM OF FIRST FN. 

71U IF X^O"!" them 7130A*rHECK FOR ONE FUNCTIONAL VALUE. 

7115 PRIimT :m;1,"1" \*FIPST FUNCTION IS OWE. RESULT IS UNE. 

7120 PRINT \*luad eno-of-file mark, 

7125 RETURM \*PETURN TO main PROGRAM. 


4 


125 

7130' I-'iPUT \*GET F I«ST TEP«« OF SECQMO FUNCTIOfJ, 

7151 IF ybo''l" THfc\ 7150\*CHFLK F0« ONE FUN'CTIOnAL VALUE. 

.7135 PRIiNT \*SECOUO FN = 1, RESULTANT FN =1, 

71U0 PRINT \*L0A0 ENO-OF -FUMC T I ON MARK. 

71*45 RETURN \*RETURN TO MAIN PROGRAM. 

71-U9 *rjEITHFR INPUT FN IS 2ERfi OH ONE. COMPUTE THE RESULT, 

7150 Ysl ■ \»INTTIALIZt POINTER TO H ARRAY. 

7155 FOR X=1 TO h9 \*C0PY FIRST FN INTO H ARRAY. 

7160 input :F;X,Xi \*GET TERM OF FN, 

7161 print ;h;Y,X1 \_*PLACE TERM IN H. 

7165 INPUT :F ; Xf lVxi\*GET NEXT TERM OF FN, 

7166 IF Xis”," THEN 7180\*END OF FN? 

;7170^ Y = Y + 1 ' ' \*f<0. "INC POINTER TO H,' 

7175 NEXT X ^ \*INC POINTER TO F, 

7180 YiY + l '■ \*Y£S, INC“ POINTER TO H. 

7185 FUR X=1 T^ MV _\*COPY G INTO H FOLLOWING F, 

7187 iNPOr ;G;X,Yt \*GETTEKM OF G, 

7188 X^tPLACF TERM IN H, 

7189 ' 'IF Yi= THEN 7r9'5S*L0dK FOR END OF FN G. 

7191 Y = Y + l _ _ \*F^40 NOT REACHED. INC POINTER TO H, 

7195 next X ■“ \*IMr'POlNTER TO G. ' ' 

7195 *SORT TERMS. \G0SUB 7^00 

7197 *RED'JCE resultant 'FUNCTION. \G(»SUH 1 7000 

7199 REJURN \*RET^UP'4 TO MAIN PROGRAM. 

7201* subroutine to sort THE TERMS OF A FUNCTION, 

7^0^*■”■ Function ■SiOST'BE''STuRE(nN array H'‘HEFORt 

72ui* sorting RULES; LENGTH OF TERM, ALPHABETICAL, NUMERICAL 

7204* ""CALLEO BY OR Af'O AND' SUBROUT INF s. 

7205* _ CALLvS .mO SUBROUnNES. 

7220 FOR X = 1 TU 100 \*COUNT NUMBER OF TERf’S iN FN, 

7230 luPUT ;'h;>,ZT ' '""N^GEr'A TERM." ' “ 

7231 IF Z4="." THEN 7250 \*ENU OF FUNCTION? 

7240 ^EX7 X \*i'jO,' ■' '■ 

72<49 *X z THE NUMBER OF TERMS IN H PLUS 1, 

7250"rF X=2 THF^’) 750o \*CHECK"P0R SINGLE TERM FN, 

7252 XOzX \*SAVE X FOR USE AS SORT LUOP LIMITER, 

7255 'Xr=X " \'*SAvr X FOR' STORE LOOP LIMITER. 

7260 FOR Xzi TO XO-2 \*USE A HUBBLE SORT TO ORDER THE TER'-'S, 

7270 ^lNpij’TTHrx,Xi)"'T*'GET"'FlRST TERH'OF 'H, ' 

7272 INPUT ;H*X+l,Yi \*GET ADJACENT TERM QF M, 

7?7ii'' IF xS<¥t. THEN 731 OV*CnMpA-RE 7 hE TER'^S, 

7280 *REVER3E THE ORDER OF THE Tv^O TER^S, 

7290 pRrr4"r~:'M';x';vi “ 

7300 PRINT 

7310 NEXT x' \*REPEA T' FCiR 'wEXT PAIR OF TERMS. 

7319 * ONE T£RM hjAS BEEN PLACED IN ITS PROPER PLACE. 

7i20'"XO^0-l ■ " ■ "\*DECRE'’ENT SORT LOOP LIMITER. 

7330 IF X0>2 THEN 72b0 \*HAVE ALL TFRMS BEEN ORDERED? 

7340“Xoz‘xl ' ■" A'*' YCS.' ■ RESTORE' XO. ' 

7344 *0UPL1CATE TeR^'•S *'iILL f O'’* BE REMOVED, 


126 

Tias FDR Xsl TO xr " \*C0MPARF' ADJACE'M TFKi^S FOR EQUALITV. 

7iti7 ir-ipur :m;x,xs \*get a term, 

73as IF X3 = "." TME'm 7U?0\*ENr' OF FUNCTIOf'.? 

7350 INPiil :H; X + l , ri\*MO. GET AfiJACENT TE^’^. 

735T IF XSsYS THEN 73bO\*APE TER-'^’S IDENTICAL? 

7355 *NO, GET wExT PAIH.NGOTG 7<ilO 

73<jO ■ xO = XO-l \*YES. DECREMENT TERR COUNT. 

7365 FOR YsX+1 TO Xl-l\*REwUV£ DUPLICATE TERM AND COMPACT H, 

7370 - INPUT :H:Y+1,XS\*GET TERM FROM H. 

7371 PRINT ;m; Y,X i\*MOVE TERM TO NE« POSITION IN H, 

'7380 IF XSs*^." Then 7UlO\*ENO OF FUNCTION? 

7390 NEXT Y \*REPEAT FOR NEXT TERM, 

7aiO NEXT'X ■ ~ \*REPEAT FOR NEXT PAIR OF TERMS, 

7«20 FOR Xsl TO XO-2 \*SORT TERMS BY LENGTH USING BUBBLE SORT. 

7430 INPUT :H;X,XS 

7431 INPUT :M;X*l,Yi 

7432' LI=LENCX3) 

7433 l2=LEN(YI) 

-7434 -- ir~Ur<=L'2 THEN 7470\>IF TRUE; DO NOT REORDER. 

7440 PRINT :h;X,Y$ \*REUR0ER, 

7450 ' PRINT ;H;Xfl,X$ 

7470 NEXT X \*REP£AT FOR NEXT PAIR. 

7480'X0=X0-1 ■ \*DECREMENT LOOP LIMIT FPk NEXT PASS, 

7490 IF X0>2 then 742G \*SORTI.'i& COMPLETE? 

7500 return \*YEvS, return to calling PROGRAM, 

7600*ft**ft***«*****kk4t******ir*jr*********«**»*** ************************ 

7801* 'SUBROUTINE 'TO DISASSEMBLE A PRODUCT TERM INTO ITS 

7802* LITEhAL COMPONENTS, A LITERAL IS A VARIABLE NAME OR A 

7803* ' COMPLEMFNTEO VARIABLE' NAME TOGETHER Y.ITH ITS TlMf TAG 
7804* ■ OR fault SYMBOL. 

7805*“ term is passed TO SUBROUTINE IN X3, LITERALS RETURNED 
7806* IN Ai ARRAY. CALLED 8Y LITERAL SORT SUBROUTINE. 
7007/k***************************************************************** 
7810 F5=0 \*CLEAP SPECIAL CHARACTER FLAG, 

■ 7815 = ' \*CLEAR DUMMY STRING VARIABLE, 

7820' A = 1 \*INITIALIZE PUIMER TO Ai ARRAY, 

78 50 L=CEN-(XJr \*C0f’PUTE LENGTH OF TERM. 

7835 FOR Xi=l 10 L \*BEG1N DISASSEMBLY OF TERM. 

7840 IF"X$( !X5, n="-" then 7900\*LCOK FOR SPECIAL CHARS (-), 

7842 IF Xi( JX5,1)>"Z" then 7900\*LOUK FOR TIME TAG (NUMERAL). 

'7844 ir“X$(:x3-, IX"'A" then 7900N*LOOK for fault SYMBOLS (J/*), 

7850 IF F5<>! then 7910\*EmO CF LITERAL REACHED? 

— T860" A.F(TTJ=T'E \*'YrST ' PL ACE LITERAL IN Ai ARRAY, 

7861 *END UF literal IS INDICATED ^HEN A SPECIAL 

7862’ - ' ■ *CHARACTER IS FOLLOi'iEO BY A LETTER. 

7863 *ThF letter IS THE FIRST CHARACTER OF THE 

T8F4 ' *NEXr LITERAL. 

7870‘ Z‘'i = X*( ;X3» 1 ) \*BEGIN CONSTRUCTXG NEXT LITERAL. 

7080 F5=0 \*CLEAR SPECIAL CHARACTER FLAG, 

7890' AsA + 1 \*INC pointer TO A$ ARRAY, 

7895 GOTO 7920 

7896 


*CQ^Tl^Ut PROCESSING TERM 


127 

7<)00 FS=1 \*SKT SPtClAL ChAWACTER FLAG. 

/910 7h = Zl’txS(:x3,l )\*COLSTrtULT literal. 

7920 \'EXT x3 \*REHEAT FOR NiEXT CHARACTER OF TERM. 

7930 AtU) = Z3> \*LOAO LAST LITERAL OF TERM In a^ ARRAY. 

79^40 AF(A*n = "." \*LQAD Ef.G-OF-L I T EW AL mark. 

7950 REfURO \*RLTUPfM TO LITERAL SORT’ SUbROUT I ''IE . 

' 8001* SUHROUTlMt TO PERFORM THE LCGlDAL AND OF 

8002* f«P F LINC T inos, 

8003* THF Input functions are passed in arrays F and G, 

800a* THE RES'.'LTA'iT function is returned in array' h, 

8005* called 8Y MAIii PROGRAM (SIm2) and RACE PROGRAM. 

dOObi CALLS'ZERU PRODUCT DETECT SUBR (8250 J f L I TERAL SORT 

8007* SUHR(8e>50), TERM sort SUBR(7200), AFD MINIMIZATION SU8RU7000) 

._8010 INPUT :F;1,XF \*CH£CK FOR ZERO FN VALUE. 

; 8011 IF "xV="0" THEM 8030 

I 8020 INPUT _ A*CHECK FOR ZERO FN VALUE, 

1 8021 'IF '><<>"0" THEN 8050 

. 8030 PRINT. :H; 1 , "O" ^l^'^SULT IS ZERO, 

‘ SOad-PKI.NT rH;2»"." ■ 

8045 return \*RETUPN TO CALLING PROGRAM, 

' 8050 'IF X^s”!"' THFN 8058 \*CHECk FUR UNE VALUED FUNCTION, 

8051 IF Yfo"l" THE'. 8088 \*CHECK FOR ONE VALUED FUNCTION, 

8052 FOR X = 1 TO h 9 \*2.JD FN ONLY IS ONE VALUED. RESULT s F. 

8053 input ;F;X,xi \*GET TERM OF F. 

805'4 PRINT ■•■R'; X, y$ ^*PL'ACE IN'H ARRAY', ' ' 

8055 IF X^«," then 8160 \*ENU UF FUNCTION? 

8056 NEXT x" ■" \'*REPEAT FOP NEXT TERM, 

' 8057 *PK(JCEE0 to FUmCTIO.'J HFOUCTION STEP.VGOTO 8160 
8056 "IF" YI*<>"1" THEN 80t)2\*l-ST FN IS 1-VALUED. IS THE 2ND FN l-VALUEO 
8059 PRINT \*BOTH FHS ARE l-VALLED, RESULT IS t-VALUEO. 

8060"PhInT ;h;2V%" 

8061 return _\*RETUPN TO CALLING PROGRAM, 

8062'F0R“xs'l ~TU M9 " \*1ST Fr. IS I-VALUED, 2ND' IS NOT. 

806 5 INPUT j^G;x,Y3 \*kESULT = G. 

"8064 PMI^4T' ;V;X,Y3 ' 

8065 IF Y2="." THEN 8160\*EN0 OF FUNCTION? 

8066' NE XT^X " 

80b7 *PP0_C_EE^ TO MINIMIZATION STEP. \GOTC 8160 

8068' w = r ' \*n£'I THER iNPUf I S ' CONST AN T- VALUE 0, INIT POINTER TO H,' 
8069 PRItmT \*INITTALIZE H TO 0-VALUE. 

”■8070 HRT'nT ;b;'2',‘’;” 

8075 FmH x=l Tu HR \*HEGIN PRODUCT-TERM PORMATION LOOP. 

■ 80“8‘0 TNP'UT'";FYii;-xr' '\*GET~tTRF FR07« 'FV ' ' ' ' " 

5090 FOR Y=l TU H9 \*8EGIN LOOP FuR ACCESS TO G. 


80'91'" ' ■■ ■■ IflouT :G; YrYSN*'GET 'T'E'RM FKom' g; 

8092 Zk=XFfY3 \*FORM PPCOUCT OF TERMS, 

8093"' ' PRI.'ir'":Hpv 'Z'B\*PLACE RESULT IN H. 

8100 *CH£CK FOR ZERO PRPDtJCT. \G0SU8 8250 

8110 iMt'uT ;G'; Y + 17Y3-\'*CHECK G FOR EfiD OF FUNCTION, 

8111 IF V? = "," THEti 8130 



128 

8120 ■ .vEXT i \*K0T f.\.n OF G, GET mEXT TERM. 

8130 I'jpur :f- ;X4l ,X$\*CtiECK F FOR END r-F Fll^iC^U^'. 

3131 IF X3="," THEN 8150 

81'40 -^EXT X \*ouT EHO OF F, GET NEXT TERM, 

8150 IF rtOl TnF'M 8155 \*EN0 OF BOTH FNS REAChED. 0-VALUE RESULT? 

8152 PRINT \*YES. load 0-VALUE in h, 

'8153 RETURN" \*RETURN ?0 CALLING PkOGRA.vi, 

8155 PRINT \»nQ. LOAD END-OF-FUNC T I ON mark, 

8160 FOR' X = l TO HR \*6EGIN ’^IN STEP BY ORDERING LITS IM EACH TERM, _ 

8165 input :H;X,XJ \*GET A TERM FROM H, 

8167" IP XSs"." THEN"'8190\*END UF FUNCTION? 

8170 *NU. ORDER LI TEHALS.VGOSUB 8650 
8175 PRINT' ;HjX, 23 ''\*PEPLACE ORDERED TERM, 

8180 NEXT X \*REPEAT FOR NEXT TERM, ' 

8190 *0RDER terms OF THE FUMCTIOU.NGOSUH 7200 
8200 *kEM0VE REOUNOA.xT TERMS, \G0SUH 17000 

8210 RETURN \»METURN TO CALLING PROGRAM, i 

8250************************ft*********************#***********<HMHk**** 

8251* ■ SUbWOUTlNE TO CHECK FOR ZERO PRODUCT TERM, 

8252* TERM TO BE CHECKED y»AS FORMED BY THE AND SUbROUTINE 

8253* AND Y.AS PLACED IN THE H ARRAY, THF TERM IS RETRIEVED FROM H 

8259* FOR PROCESSING, IF THE TERM IS ZERC’r THE POINTER (vy) TO THE 

8255* H ARRAY IS 'JOT INCREMENTED y-HICH RESULTS IN THE TERM BEING I 

8256* OVERaHITTEn 6Y ANOTHER TERM. IF THE TERM IS nOn-0, fi IS INC. 

8257* called BY THE AND SUBROUTINE, 

8258***<t***********»*»******** **************** »****<r**<r***»*********** 

8260 C=1 - \*SETTHE SPECIAL CHARACTER FLAG, > 

6270 D=l \*SET THE MINuS FLAG. 

8280 Zis"" ■ \*CLEAP A TEMPORARY VARIABLE. ^ 

8290 83="" \*CLEAR ANOTHER TEMPORARY VARIABLE, I 

8300 input ;H;/i,Y? \*GET TERM TO BE ANALYZED, 

8301 L = LEN(Yi) \*C0MPI)TE LENGTH OF TFRm, 

8310 FOR A=1 TO L '\*BEGIm TERM ANALYSIS. > 

8320 X3=YS(;A,1) \*EXAMjne A CHARACTER FROM Y$, ' 

8330 IF X5>"Z" THEN 8350\ *NUN-ER AL? 

8332 IF XSs"-" THEN 8350 \*mIMuS SIGN? , 

8339 ■ IF X$ = "*’» THEN 8350\*STUCK-AT-0 SYMBOL? ) 

8336 IF X3="l" THEN 8350\*STUCK-AT-1 SYMBOL? 

8390 - ir C = I"THEN' 8900\*END OF LITERAL? 

8391 *YtS. LOOK FOR ITS COMPLEMENT , \GOTO 8920 

3350' ■ C = 0 ■ ■■ ' \*SPECIAL SYMBOL F0U^■D. CLEAR FLAG. 

8360 IF XJo"-" THEN H370\*i«AS TmE SYMBOL A - ? 

'"8365 D's'O " " \*YES,' CLFAF FLAG, ' ' 

8366 *GET NEXT CHAP AC TE> . \GOTC 6600 

3370 ■ ir DOl THEN 39O0\*GHECK FOR COMPLEMENTED LITERAL, 

8390 Z3 = Zif"-" \*NUT COMPLEMENTE'D , INSERT MI'-US, 

ainnr Z5=zitX3 — \*construct test literal, 

8910 *6ET NEXT CHARACTER, \GUTU 6600 

8920 C=I \*SET special CHARACTER FLAG. 

8930 61=A \*SAVE POINTER TO Y», 

8990 FOR 8=81 TO L \*FIND NEXT LITFPAL IN TERM, 

8950 It'jPUT ;H:rt,Y'B \*GET THE TERM FROM THE FILE, 


! 


8951' ■ 

'x$=y 

8960 

IF X 

I" 8962 

"IF' X 

8469 

IF X 

8966 

IF X 

8970 

IF C 

' 8971 

*YES 

8980 

C = o 

■ 8990 

Hi=B 

, 8500 

*G£T 

' 851 0 

' , IF Z 

8520 

C = l 

' 8550' 


8555 

*S£A1 

'~8590 

nExt'b' 

8550 

IF ZisQ$ 

8560 

C=1 

8570 

D=1 




129 


1 ) 

\*GET A 

CHARAC TER 

OP THE 

THEN 

84bO\*A 

numfral? 


ThEim 

8480\*A 

MIfJUS SIGf.'? 

TMt,N 

8980\*STUCK-AT-0 

SY^’BQL? 

ThEN 

"8980\*S1 

TUCK-AT-1 

symbol? 


I - 


as80 

H590 

659b 

8600 

8610 

8620 


■ Z5 = "*'“ 

8 $ = "" 

■ '♦OhVPLUP' A' isi 
NtXT A 

v^=-v+l 

RCTlJKf'- 


>"Z" 

s'* — ” 

= "*" 

— "II I n 

1 THEN' eaqo\*FNn of literal? 

CU'^PAKE TO TEST L 1 TERAL , \GOTO 85 1 0 ' 

\*special ckmpacteh, clear flag, 

+X{ \*C0NSTRUCT'LITERAL. 

next character, \*G0T0 8590 

= HJ THEfJ 6620\*C0MPARE MTH TEST LITERAL." 

\*NOT = , SET SPECIAL CHAR FLAG, 

'■\*clear temporary vakiahle. 

for UEJJ literal. \G0T0 8950 

\*»REPE'AT for next CHARACTER. 
\*C0NPARE LAST LITERAL i^flTH TEST. 
\*S£T special character FLAG, 
\*SFT THE minus sign FLAG. 
\*CLEAR'A TEMPORARY VARIABLE, 
\*CLEAR another TEMP VARIABLE, 
literal, \GOTO 8320 
\*RF.PEAT FOR NEXT CHARACTER. 
\*N'ON-0 TERM. INC pointer TO H, 

\*RF;TURN to AMO subroutine. 


Then 8620' 


E^' TEST 


8651* SUB^niJTlME JO SOFT THE LITERALS IN A PROOUCT TFRM, 

8'6S2* ~ LITE' RAX S ARE" PASSED TU SUBROUTINE' P' 2$ "AND' THE SORTED 
8655* TERM IS RETURNED IN ZS, 

8659*' “called HY ThE AND SUBROUTINE," 

8655* CALLS THE TERM DISASSEMBLY SUBROUTINE, 


8660 *0TSASSEm6LE THE 

'8665 "C'=0' 

8668 B1=A 

86 70 " FUR A^ TO' HI' ' 
8680 IF A$(Afl)="," 
8'6 90”" I F "A'i ( A")'< A S I A t 
8700 Z'f> = A'*.(A) 

’3710 ^ArCAT=AJTA + n “ 

8720 A«(A+l) = Z'»> 

8710“ Nt'xr A 

8790 IF 61=V then 8750 
“8795"~Bl=Bl-l"' 

8796 >*REPEAT fur next 
' 8 750 'FTjfr'ff^rTir2’o 
87o0_ IF A. t(A *l ) = 

8 7 70 IF' a1(AJ='Ai.(A> 
8771 _ *N0T identical 
8780 C'=tXl 
8790 FOk riO=A TO 20 
TiSOO All Coo T=“A 5 

8805 IF Ai(HO) 


TERM INTO literals, \GOSUB 7800 
““\* INH I ALTZE' counter. ■ ■ ■ 

_\*GET NUFBFk of literals in term from SU8R 7800 
' \*'S0RT'THE literals in a* liSlNG 'A BUBBLE “SORT, 
THEN 8790\*EN0 OF LITERALS, 

IC THEN "8730\*C0MPARE T'^O LITERALwS, '' ' 

\*RE-URL'ERIN6 NEEDED. SAVF ONE LITERAL, 

"Vir'SAAP PLACES OF THE T/vO,' ' 

^complete Tj^E S*AP, 

■\*KEPEAT'F0K NE5d~PAlR,‘ 

\*CHECK FOR END OF SOW 

\*OECR"EAS£ LOO'P LI'-'^IT,' C'ON' T I NUE' SORT , 

PASS THROUGH THE LIST,\G0T0 6670 
\*50RT CnKPCE'rE~ LOOK” FOR~ DUPLICATE L I T E R'A L S 
THEN 8830\*L00K for END OF LITERAL LIST, 

If Then 6780\*L0UK ”F0R IDENTICAL LI'TERA'LS. 

. CO^TIt'i'iE SEARCH, \GCTP 8820 
'\*INC COUNTER.' 

\*RENOVE DUPLICATE LITERAL FROM LIST. 

■(Bo+'l l\“*ShIF'T "A LITERAL. 

="." Then 882o\*end of list? 


130 

881D NTXT -BO ‘ \*COf TINUE SHIFTING. 

8H20 NEXT A \*PEPEAT F- OR WfcXT PAIR. 

a83(r~r$="'' "\*cleap temporary variable, 

8835 FOR A = l TO 50 \*BfcGIK- RECONSTRUCTION OF PRODUCT TERM. 

' 8840 IE ABIATs"," THEim'8870\*EN0 of LITERAL LIST? 

8850 ZI = ZjS + Ai(A)_ \*N0. APPEND TO TERM. 

"8860 NEXT'A" ■ \*REPEAT K)K NEXT LITERAL. 

8870 RETURN _ \*RETUPN AMD SUbROUTIME, 

9000* ********* *A***A*******4*****************«**»******4r*«t*****«***i^** 

9001* SUBROUTIfiE TO TRANSFER A FM FROM AN ARRAY TO A FILE, 

~900'2'* "FUNCnOM IS always transferred from array ri, THE FILE IS 
9003* either OLDl, OLHO, N£W0, OR NEVvl AS A FUNCTION OF J AND S. 
‘9004* “CALLEO’'0Y THE MAIN PROGRAM (SIM2). 

9005****************************************************************** 

9008, INPUT=0 \*RETUPN TO NORMAL INPUT MODE. 

9010 CLOSE :G \*CLOSE FILE ASSIGNED TO CHAN.^EL t. 

■'“9ai2”0N“G GOTO 90 1 4 # 90 16 » 90 1 8 , 9020\*OPEN FILE TO CHANNEL G, 

9014, OPEN *’0101" TO :1, INPUT UPDATE 
~90J5"*GOTO' NEXT STEP " "AGOTO 9022 
9016 OPEN "OLOO" TO : 2 , INPUT UPDATE 
‘ 9017 *GOTO NEXT STEP \GOTO 9022 
9018 OPEN "NEwO" TQ :3, INPUT UPDATE 
- 90r9"*G0T0 NEXT~STEP ' \GOTO 9022 ' 

9020 OPEN ’•NEaI" TO !4, INPUT UPDATE 

'9022 X5 = rj(Il/l) -\*GET FUNCTION NAME. 

9025 IF JOO THEN 9040 \*CHECK FUNCTION FLAG. 

"90'3Q- XJaxS>"-"~ ~ *V*0-FN BEING TRANSFEPEO, ADD - 70 NAME, 

9040 Z3=STR(TJ \*CONVERT TIME VARIABLE TO STRING, 

904rAr=X$>ZSCT2) ~~ AAAPPEMO TIME TAG TO FN NAME. 

9045 X$ax$+"=" \*APPEN0 s TO FUNCTION NAME, 

9060 PRINT :J-2*S*J-S+3;y5*(Il-l)+l,X5\*LOAO NAME IM FILE 1ST RCD, 

9070 FOR Xal TO 1000 \*8EGIN TRANSFER OF TERMS, 

"9075 -- INPUT": FT; X,XJ — \*GET 'TERM' FROM ARRAY H, 

9076 print : J-2*S*J-S+3,XS\*PLACE TERM IN FILE. 

9080 IF XS = '»,"-THEN 9100\*FnO OF FUNCTION? 

9090 NEXT X \*MO. REPEAT FOR NEXT TERM, 

' 9100 INPUTS* \*CHANGE INPUT MODE. 

9200 ’RETURN \*RE1URN TO MAIN PROGRAM, 

TO (TOO * * *V*Tf* A'T* *■***■*'* *■***■' ****'***“*********************************»**** 
10001* SUBROUTINE TO COMPARE NEW FUNCTION SET TO OLD SET. 

TOOO-2*- — rUNCTTONS' APT" ACCESSED FFOM THE OLDl, OLDO, NFwO, AND NErtl 
10003* FUNCTION FILES, IF THE THO SETS OF FUNCTIONS AP£ EQUAL, 

Tan-(T4-* ITO^ITSTETURNFCT. TTPEPivISErr^NOsO IS' RETURNED. 

10005* called by main PROGRAMi (SIM2). 

1000 bT*******’***’****************************************************** 

10008 close: :i\CLnsE :2\CL0SE :3\CL0SE :4\*CL0SE all open files, 

“lOOTOTPEN '"OLD r"" TO 'ir,' INPUT UPDATE 

lOOll OPEN "OLOO" TO :2, INPUT UPDATE 

10012" OPEN "MET-O” TO :3, INPUT UPDATE 

10013 OPEN ”NE*M'' Tf) ;4, INPUT UPDATE 

10015 TOR X=1 TO N1 \*8EGIN COMPARISON. 

10020 INPUT : 1+5*S;Y5*(X-1)+1,B*\*GET FN NAMf, 


'roouo ' 

TTyPUT 

! 10045 

INPUT 

' T0047 

" input 

10050 

IF Bj>=i 

" f0055 

return 

10060 

IF 81 = 

“ 1 00 70 

*cnntTi 

10080 

INPUT 

TOT 00' 

input ' 

10105 

INPUT 

' 10107 

INPUT 

' lOllO 

IF JSsi 

' ion'5" 

RETURN 

10120 

IF J$ = 

'T0f3u 

*N0, 

i 10140 

NF X T X 


10150 ^0=l 
' 10160 PtTUKN 


;4-^'*S;Y5*(X-i ) + l,Cli\*GET Fu nakE. 

\*GtT TERi^ C'F 1ST Ff, 

:a-3*S,C'B ' \*GET TFK'' t>F 2ND Ff«. 

Cl rnF N 1 UQ60 \*TEk‘;|^S EGU^L? 

‘ THEN FNS ’JOT EGiUAL,' 

THE-'J lo080\*YFS. END OF FN? 
fjiJE' Cfif^>Af?lSfJN.\G('TO ioOUS 
;2 + S;Y5*(x-l J*l,J%\*GET FN NA’^-E. 

;3-S; YS* (X-1 J ♦! /Kl\*GET FN nave. 

^\*GET TER*^ OF 1ST FN, 

:4-S,Ki ■ ~ \*GET TERM 0F'"2NL) FN, " 

Kf TriEN 10120 \*TERMS EQUAL? 

■ :\*NO'. THEN'FNS fjOT"E«UAL, 

THEN 101<10\*END_UF FN^ 

CONT INUE ■'Cn»"PARIbON,\GOTO 10105“ 

\*REPEAT FUR NEXT FUNCriONS, 
\*FUNCTU)N SETS IDENTICAL, 
\*RETURN TO r-<AIN PROGRAM (SIM2), 


, llOOl* _ SUHROuTINE to print TEST-FUNCTION IDENTIFICATION ANQ 
rroo?* 'rEST-FTjiMCT ION" PRODUCT TEHMS“IN list format. 

11008 *PRirr HEAUfc'R' INFO FOP UNSPECIFIED FAULTS vODF , 

11009 INPUTsO 

1 lOlu' PRI')T"OijIPUT-L INb= 
llOll PRINT"INPUT-LINE= 

' Tiot2~PRrNT"np.r-raG“='"7r$ -- - 

' 11020 PRINT 

" 1 1030' PRINT" rEST-FijNCTION= ”i ' ' " 

, 110a9_*PRINT LIST OFTEST FUNCTION TERMS. 

, IfOSO FOR "Xil Trr"2oo' 

1 1 060 INPUT :H;X,Xt. 

ri.T65 irKi=’^"-'TRE?J 'n325~ ■ " ■ ■" “ 

110?0 PRINT TA8C20);XI 

ri080' PRINT 

11090 NEXT X 
“ rr325“lNPUT = i 
1 1327 PRI>'iI 

' in3‘0"RETUPlj " “ 


“T7001* subroutine 10 MiNivi^e fonctionsV 

, 17002* A FUNCTION IS SAIP TO 6E MINIMIZED (IN THIS CONTEXT) IF IT 
■^y'OOTi CUNTAInS no REOUNOArT PRODUCT TERMS, “'HENCE ’ THE" SllbRUUfl NE 
1700U* removes DUPLICATE TEP^S AND TERMS CCVERED BY ANOTHER TERM, 

' ITOTISTf r'FlJT7CrnrrTT~P'SSSFir'TrrTFTE~SGBR0UTlNE' IN" ARRAY HV — 

17006* ^HE_HF0UCE0 FUNCTIOT I_3 RETIiRNED IN ARRAY H, 

"T7 0 07*"" ■ ' CALL'En" B"Y" THF' AND SUBROUTINE A> D The DR SUeROUTlNET 

1 rolo" FOR' x = r TO x2"-r " "\*EXAMIN£- each term OF THE Fw, 

17015 Input :h:x,zj \*get a term from array h. 

1701b IF'“2£ = "V" 'THEN T72?"0\*ENDOF FUNCTION? 

17020 X5=zi \*N0, COPY TERM TD Xj> FOR PARSING. 


1 

1 

1 



— 

132 

- 

“rroio 

* ~ 

♦ PARSE' TFR^'' INTO' literals, \GOSUB 7800 


170«0 


FOR V=1 TO 20 \*C0PY LITERALS TO ARRAY 05. 


17050 

— 

■' D5(T)=A?(Y)\*C0PY 4 TERM. 


1706,0 


IF A%(yJ = *'." then 170H0\*END OF LIST? 


17070* 

■* — — — — . - 

UEXT'Y “ '\*Fi0. REPEAT FOR NEXT LITERAL. 


17060 


for YsXtl TO X2-l\*CnMPARL ABOVE TERM Tu ALL OTHER TERMS, 


* 170‘)0 


■■ " INPUT :H;Y,Z5\JPGET A TERM FROM ARRAY H, 


17091 


IF 25 = "." THEN 17210\*E''JD OF FN? 


' 17100' 


■ X$ = Z$ ■"\*CQPY TERM TO X5 FOR PARSING, 


17110 


♦PARSE ThF TERM IMTO L I TERALSXGOSUB 7800 


~r7Tl5 

— * 

— ---F5=1 ~ V*INITIALIZE FLAG INDICATING 


17116 


*A redundant term. 


■'17120 


FOR 6sl TO 20\*COMPARE LITERAL LISTS OF TwO TERMS. 


17122 


IF F5=0 THEN 17200\*CHECK FLAG FOR NO REDUNDANCY, 


1712S 


IF' = THEN 17170\*EN0 OF LIST? 


17130 


FOR A = l TO 20\*SCAN LIST OF 2 im0 TERM. 


“ 17135 


IF A$(A)="." then 17165\*EN0 OF LIST? 


17190 


IF AS(Al=05(B) THEN 17160 


17191 


*COMPAfiE literals of T^vO LISTS, 


17150 


F5 = 0 \*LITt'RALS ARE NOT ALIKE. 


17151' 


■ ‘CLEAR FLAG TO INDICATE NO REDUNDANCY. 


17155 


NEXT A \‘kEPEAT FOR NEXT LITFIRAL OF 2M0 TERM 


“17160 

_ - 

F5=l \*matCH found. POSSIBLE REDUNDANCY. 


17165 


NEAT B \*REPEAT for next LITERAL OF 1ST TERM 


17170 

- 

FOR C=Y TO X2-1\*2N0^ TERM REDUNDANT. DELETE FROM H, 


17180 


INPUT ,25\*GET A TERM FROM H, 


-17185 


PRINT :H;C»ZS \*PLACE TERM IN NEw POSITION, 


17190 

■ 

NEXT C \*REPEAT for next TERM. 


17195 

" . 

♦GET NErt 2ND TERM.XGOTO 17090 


17200 


NEXT Y \‘REPEAT for NEXT TERM, 


17210 

f^F-XT X 

\‘RFPEAT FOP NEXT FIRST TERM, 


17220 

PfcTURN 

\‘RETURN TO CALLING PROGRAM, 


20000 

FND “ ■ 

- - - - 


1 

[ 

tV’US. GOVERNMENT PRINTING OFFICE 1979-640-247/27S REGION NO' 4 


t 

f 

- — 

— “ “ * " - ~ “ 


L 

— 

— 

- 


