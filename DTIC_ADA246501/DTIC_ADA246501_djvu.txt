REPORT D An-A246 501 


Form Approved 

OFM No. 0704-0188 

Pubic raportnobiiniMi lor Mi eolKilono(Hoiin«ioi ' ~ Tniiri iiirillll Hill Hill il'll II 

ntoM. and mioiMig (w eolKlIon of HonnaUon. 8 l||l| |||| ul 111|| || I 11 || 

HwdquMn Saiutoo. OkMenM lor kdotmaion Qpo 111111 I 1 l|i I I1 1 

ItengMiMM Md BudgM. Wnhlnglon. DC 206OS. I 'HiIH 'll' 

Hi 

■Uucdoni, MiicMng wMIng dM MuroM gMadns wd iMknMng tM dM 
km el kdormMloa kdudkig luggHdom tar nducing Mr burdMi. 10 WMikwon 
22208-4302. tndta dir Olier d tatannrdonmdritgultaniyaitalrr, OWor el 

1. AGENCY USE ONLY (Leave Blar*) 2. REPORT DATE 

3. REPORT TYPE AND DATES COVERED 

Final: 12 Jun 1991 to 01 Jun 1993 

A.TITLEANDSUBihtLE 

TeleSoft, IBM Ada/370, Version 1.2.0 (without optimization) IBM 4381. MVS/ESA 

Rel. 3.1 (Unopt) (Host & Target), 910612W1.11169 

5. FUNDING NUMBERS / > 

0 

6. AUTHoAtS) 

Wright-Patterson AFB, Dayton, OH 

USA 

7. PERFORMING ORGANIZATION NAM^(S) AND ADDRESS(ES) 

Ada Validation Facility, Language Control Facility ASD/SCEL 

Bldg. 676, Rm 135 

Wright-Patterson AFB, Dayton, OH 45433 

8. PERFORMING ORGANIZATION 

REPORT NUMBER 

AVF-VSR^76-0292 

9. SPONSORINGAAONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Perrtagon, Rm 3E114 

Washington, D.C. 20301-3081 

10. SPONSORINGAHONITORING AGENCY 
REPORT NUMBER 

11. SUPPLEMENTARY NOTES 

12a. DISTRIBUnON/AVAlLABIUTY STATEMENT 

Approved for public release; distribution unlimited. 

12b. DISTRIBUTION CODE 

13. ABSTRACT (Maximum 200 wonts) 

TeleSoft, IBM Ada/370, Version 1.2.0 (without optimization) IBM 4381, Wright-Patterson AFB, MVS/ESA Rel. 3.1 (Unopt) 
(Host & Target), ACVC 1.11. 

DTIC 

^ELECTE 
■ V FEB 2719921 | 

u .. u 


14. SUBJECT TERMS 

Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSi/MIL-STD-1815A, AJPO. 

15. NUMBER OF PAGES 

16. PRICE CODE 

17. SECURITY CLASSIFICATION 18. SECURITY CLASSIFICATION 

OF REPORT 

UNCLASSIFIED UNCLASSIFED 

19. SECURITY CLASSIFICATION 

OF ABSTRACT 

UNCLASSIFIED 

20. UMITATION OF ABSTRACT 


MSN 7540^1-280-550 


Standard Form 298, (Rev. 2-89} 
Prescribed by ANSI Sid. 239-128 











AVF Control Number: AVF-VSR-476-0292 

4 Febnaary 1992 
91-04-24-TEL 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 910612W1.11169 
TeleSoft 

IBM Ada/370, Version 1.2.0 (without optimization) 

IBM 4381, MVS/ESA Rel. 3.1 (Unopt) -> IBM 4381, MVS/ESA Rel. 3.1 (Unopt) 


Prepared By: 

Ada_Validation_Facility 
ASD/SCEL 

Wright-Patterson AFB CHJ 45433-6503 


2 2 24 0 08 


92-04685 

illllllll 





Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on 12 June 1991. 

Compiler Name and Version: IBM Ada/370, Version 1.2.0 

(without optimization) 

Host Computer System: IBM 4381, MVS/ESA Rel. 3.1 (Unoptimized) 

Target Computer System: IBM 4381, MVS/ESA Rel. 3.1 (Unoptimized) 

Customer Agreement Number: 91-04-24-TEL 


See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 

910612V1.11169 is awarded to TeleSoft. This certificate expires on 1 June 

1993. 


This report has been reviewed and is approved. 


Ada Validation Facility 
Steven P. Vilson 
Technical Director 
ASD/SCEL 

Vright-Patterson AFB OH 45433-6503 


AdaAalid^^bn Organization 

Dir^ct(^(j/omputer and Software Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 



Dr. John Solomond, Director 


Department of Defense 
Washington DC 20301 




Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on 12 June 1991. 

Compiler Name and Version: IBM Ada/370, Version 1.2.0 

(without optimization) 


Host Computer System: 
Target Computer System: 
Customer Agreement Number: 


IBM 4381, MVS/ESA Rel. 3.1 (Unoptimized) 
IBM 4381, MVS/ESA Rel. 3.1 (Unoptimized) 
91-04-24-TEL 


See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 

910612V1.11169 is awarded to TeleSoft. This certificate expires on 1 June 

1993. 


This report has been reviewed and is approved. 






Ada Validati^ Facility 
Steven P. Vilson 
Technical Director 
ASD/SCEL 

Vright-Patterson APB OH 


45433-6503 




Ada Va^i 
Direcll^r,l 


fon Organization 

jtputer and Software Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 


Ada Joint Program Offic'e 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 


Accesion For ^ ] 

NTIS CRA&I 

8 

DTiC TAB 

□ 

Uraniiotinced 

□ 

JllStlfiCdtiotl 



‘ * — 

By 


Dist ibdtion/ | 




_ j ii.'lj / 0; 


/>'l 






DECLARATION OF CONFORMANCE 


Customer: TeleSoft 

5959 Cornerstone Court West 
San Diego CA 92121 

Certificate Awardee: International Business Machines Corporation 

Ada Validation Facifity: AVF. ASD/SCEL 

Wright-Patterson AFB, Ohio 45433-6503 

ACVC Version: 1.11 


Ada Implementation: 

Compiler Name and Version: IBM Ada/370, Version 1.2.0 

Host Computer System: IBM 4381 

(under MVS/ESA Release 3.1 
with Unoptimized Compiler) 

Target Computer System: Same as Host 




Yim Chan, Ada Development Manager 


TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 


1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 


APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 


APPENDIX C 


APPENDIX F OF THE Ada STANDARD 















CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro90] against the Ada Standard [AdaSS] using the 
current Ada Compiler Validation Capability (ACVC). This Validation Summary 
Report (VSR) gives an account of the testing of this Ada implementation. 

For any technical terms used in this report, the reader is referred to 
lPro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent vith the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordance with the •'Freedom of 
Information Act" <5 U.S.C. #552). The results of this validation apply 
only to the computers, operating systems, and compiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject implementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1-1 





INTRODUCTION 


1.2 REFERENCES 

[Ada83] Reference Manual for the Ada Programming Language , 

ANSI/MIL-STD-1815a, February 1963 and ISO 8652-1^87. 

[Pro90] Ada Compiler Validation Procedures , Version 2.1, Ada Joint 
Program Office, August 1990. 

[UG89] Ada Compiler Validation Capability User^s Guide , 21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: A, 
B, C, D, E, and L. The first letter of a test name identifies the class to 
which it belongs. Class A, C, D, and E tests are executable. Class B and 
class L tests are expected to produce errors at compile time and link time, 
respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library imits, the packages REPORT and SPPRT13, 
and the procedure CHECK PILE are used for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CBECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 


1-2 






INTRODUCTION 


For each Ada implementation, a customized test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragraph, removing withdrawn tests (see section 2.1), and 
possibly removing some inapplicable tests (see section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 

Ada Compiler The software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compiler The means for testing compliance of Ada implementations. 
Validation consisting of the test suite, the support programs, the ACVC 

Capability user's guide and the template for the validation summary 

(ACVC) report. 

Ada An Ada compiler with its host computer system 2 md its 

Implementation target computer system. 

Ada Joint The part of the certification body which provides policy and 

Program guidance for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification body which carries out the 

Validation procedures required to establish the compliance of an Ada 
Facility (AVF) implementation. 

Ada The part of the certification body that provides technical 

Validation guidance for operations of the Ada certification system. 

Organization 
(AVO) 

Compliance of The ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer A functional unit, consisting of one or more computers and 

System associated software, that uses common storage for all or 

. part of a program and also for all or part of the data 

necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 





INTRODUCTION 


Conformity Fulfillment by a product, process, or service of all 
requirements specified. 

Customer An individual or corporate entity vho enters into an 

agreement with an AVF which specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

Declaration of A formal statement from a customer assuring that conformity 

Conformance is realized or attainable on the Ada implementation for 
which validation status is realized. 


Host Computer A computer system where Ada source programs are transformed 
System into executable form. 

Inapplicable A test that contains one or more test objectives found to be 
test irrelevant for the given Ada implementation. 


ISO 


International Organization for Standardization. 


LRM The Ada standard, or Language Reference Manual, published as 

ANSI/HIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRH take the form "<section>.<subsection>:<paragraph>." 


Operating 

System 


Target 

Computer 

System 


Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


Validated Ada The compiler of a validated Ada implementation. 
Compiler 


Validated Ada An Ada implementation that has been validated successfully 
Implementation either by AVF testing or by registration [Pro90]. 


Validation 


Vi thdrawn 
test 


The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this Implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 



CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 


The following 

tests have 

been withdrawn by the AVO 

. The rationale for 

withdrawing each test is 

available from 

either the 

AVO or the 

AVF. The 

publication date for this 

1 list of withdrawn tests 

is 3 May 1991. 

E28005C 

B28006C 

C34006D 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

C83026A 

B83026B 

C83041A 

B85001L 

C86001P 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 




2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant 
for a given Ada implementation. Reasons for a test's inapplicability may 
be supported by documents issued by the ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
implementation, the following tests were determined to be inapplicable for 
the reasons Indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 




IMPLEMENTATION DEPENDENCIES 


The following 201 tests have floating-point type declarations 
requiring more digits them SYSTEM.MAX__DIGITS: 


C24113L..y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (IS tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


The following 20 tests check for the predefined type LONG_INTEGER; for 
this implementation, there is no such type: 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001V 

C86006C 

CD7101F 


C35404D, C45231D. B86001X, C86006E, and CD7101G check for a predefined 
integer type with a name other than INTEGER, LONG_INTEGER, or 
SHORT INTEGER; for this implementation, there is no such type. 


C35713B, C45423B, B86001T, and C86006H check for the predefined type 
SH0RT_FL0AT; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with a 
name other than FLOAT, L0NG_FL0AT, or SH0RT_FL0AT; for this 
implementation, there is no such type. ~ 

C45423A, C45523A, and C45622A check that the proper exception is 
raised if MACHINE_0VERFL0WS is TRUE and the results of various 
floating-point operations lie outside the range of the base type; for 
this implementation, MACHINE_0VERFL0WS is FALSE. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations for 
types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for this 
implementation, MAX_MANTISSA is less than 47. 

B86001Y uses the name of a predefined fixed-point type other than type 
DURATION; for this implementation, there is no such type. 

CA2009C and CA2009F check whether a generic unit can be instantiated 
before its body (and any of its subunits) is compiled; this 
implementation creates a dependence on generic units as allowed by 
AI-00408 and AI-00506 such that the compilatiun of the generic unit 
bodies makes the instantiating units obsolete. (See section 2.3.) 

CD1009C checks whether a length clause can specify a non-default size 
for a floating-point type; this implementation does not support such 
sizes. 


2-2 




IMPLEMENTATION DEPENDENCIES 


CD2AB4A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length clauses 
to specify non-default sizes for access types; this implementation 
does not support such sizes. 

BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code 
insertions; this implementation provides no package MACHINE_CODE. 

AE2101H, EE2401D, and EE2401G use instantiations of package DIRECT_lO 
with \jnconstrained array types and record types with discriminants 
without defaults; these instamtiations are rejected by this conpiler. 

CE2401H uses instantiations of DIRECT_IO with unconstrained record 
types with discriminants with defaults; this implementation raises 
USE_ERROR on the attenpt to create a file with such a type. 

The tests listed in the following table check that USE_ERROR is raised 
if the given file operations are not supported for the given 
combination of mode and access method; this implementation supports 
these operations. 


Test File Operation Mode File Access Method 


CE2102D 

CREATE 

IN FILE 

SEQUENTIAL 10 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL 10 

CE2102F 

GEIEATE 

INOUT FILE 

DIRECT 10 

CE2102I 

CREATE 

IN FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

OUT FILE 

DIRECT_IO 

CE3102E 

CREATE 

IN_FILE 

TEXT_IO 

CE3102F 

RESET 

Any Mode 

TEXT_IO 

CE3102G 

DELETE 

TEXT_IO 

CE3102I 

CE^TE 

OUT FILE 

TEXT_IO 

CE3102J 

OPEN 

IN FILE 

TEXT 10 

CE3102K 

OPEN 

OUT FILE 

TEXT” 10 


The following 16 tests check operations on sequential, direct, and 
text files v^en multiple internal files are associated with the same 
external file and one or more are open for writing; USE_ERROR is 
raised vdien this association is attenpted. 


CE2107B..E CE2107G..H CE2107L CE2110B C:E2110D 


2-3 



IHPLEHENTATION DEPENDENCIES 


CE2111D CE2111H CE3111B CE3111D..E CE3114B 

CE3115A 


CE3413B checks that PAGE raises LAYOUT ERROR when the value of the 
page number exceeds COUNT'LAST; for this Implementation, the value of 
COUNT'LAST is greater than 150000, making the checking of this 
objective impractical. 

LA3004A..B, EA3004C..D, and CA3004E..F (6 tests) check pragma INLINE 
for procedures and functions; this implementation does not support 
praigma INLINE. 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 28 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the 
way expected by the original tests. 

BAIOOIAI BA2001C BA2001E2 BA3006A6M BA3006B3 

BA3007B7 BA3008A4 BA3008B5 BA3013A6 BA3013A7M 


CS2008B was graded passed by Test Modification as directed by the AVO. 
This test uses a record type with discriminants with defaults; this test 
also has array components whose length depends on the values of some 
discriminants of type INTEGER. The test was modified to constrain the 
subtype of the discriminants. Line 16 was modified to declare a 
constrained subtype of INTEGER, and discriminant declarations in lines 17 
and 25 were modified to use that subtype; the lines are given below: 

16 SUBTYPE SUBINT IS INTEGER RANGE -128 .. 127; 

17 TYPE REC1(D1,D2 : SUBINT) IS 

25 TYPE REC2(D1,D2,D3,D4 ; SUBINT 0) IS 


CA2009C and CA2009F were graded inapplicable by Evaluation Modification as 
directed by the AVO. These tests contain instantiations of a generic unit 
prior to the compilation of that unit's body; as allowed by AI-00408 and 
AI-00506, the compilation of the generic unit bodies makes the compilation 
unit that contains the instantiations obsolete. 

BC3204C and BC3205D were graded passed by Processing Modification as 
directed by the AVO. These tests check that instantiations of generic 
units with unconstrained types as generic actual parameters are illegal if 
the generic bodies contain uses of the types that require a constraint. 
However, the generic bodies are compiled after the units that contain the 
instantiations, and this implementation creates a dependence of the 


2-4 






IMPLEMENTATION DEPENDENCIES 


instantiating units on the generic units as allowed by AI-00408 and 
AI-00506 such that the compilation of the generic bodies makes the 
instantiating units obsolete—no errors are detected. The processing of 
these tests was modified by re-compiling the obsolete units; all intended 
errors were then detected by the compiler. 

CD1009A, CD1009I, CD1C03A, CD2A21C, CD2A24A, CD2A31A, CD2A31B, CD2A3iC 
were graded passed by Evaluation Modification as directed by the AVO. 
These tests use instantiations of the support procedure LENGTH_CHECK, 
which uses Unchecked_Conversion according to the interpretation given in 
AI-00590. The AVO ruled that this interpretation is not binding under 
ACVC 1.11; the tests are ruled to be passed if they produce Failed 
messages only from the instances of LENGTH_CHECK—i.e, the allowed 
Report.Failed messages have the general form: 

" * CHECK ON REPRESENTATION FOR <TYPE ID> FAILED." 


CE2203A and CE2403A were graded passed by Test Modification as directed by 
the AVO. These tests check that USE_ERR0R is raised if the capacity of 
the external file is exceeded; but they require that the capacity can be 
limited to 4096 characters or less. This implementation can restrict file 
capacity in units of disk tracks, whose size is approximately 48K bytes. 
The two tests were revised at lines 45 & 54 (2 lines in each test) to use 
the form parameter "BLKSIZE 512 PRIMARY 1 SECONDARY 0", which restricts 
capacity to one track. The upper bound of the loop range at line 73 of 
each test was changed from 9 to 100, to attempt to write 50K bytes. 

EE3301B, EE3405B, and EE3410F were graded passed by Evaluation 
Modification as directed by the AVO. These tests check certain I/O 
operations on the current default output file, including standard output. 
This implementation outputs the ASCII form-feed character which has no 
effect on the standard IBM output devices; in general, there is no common 
form-feed mechanism for the devices. Thus, the printed output from this 
test did not contain the expected page breaks. The AVO ruled that these 
tests should be considered passed if none of the tests' internal checks 
was failed (i.e., if the tests report "TENTATIVELY PASSED"). 


2-5 





CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 


The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For technical and sales information about this Ada implementation, contact: 

IBM Canada, Ltd 
844 Don Mills Road 
North York, Ontario 
Canada N3C IB7 
ATTN: Antony Niro 

31/257/844/TOR 


Testing of this Ada implementation vas conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pro90]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were withdrawn 
because of test errors (item b; see section 2.1), those that require a 
floating-point precision that exceeds the implementation's maximum 
precision (item e; see section 2.2), and those that depend on the support 


3-1 





PROCESSING INEX3RMATI0N 


of a file system — if none is supported (item d). All tests passed, 
except those that are listed in sections 2.1 and 2.2 (counted in items b 
and f, below). 


a) Total Number of J^licable Tests 3771 

b) Total Number of Withdrawn Tests 94 

c) Processed Inapplicable Tests 104 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 201 

f) Total Number of Inapplicable Tests 305 


g) Total Number of Tests for ACVC 1.11 4170 


3.3 TEST EXECUTICXa 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the vali^tion team for processing. The contents of the 
magnetic tape were loaded directly onto the host conputer. 


After the test files were loaded onto the host conpjter, the full set of 
tests was processed by the Ada in^lementation. 


Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See /^pendix B for a conplete listing of 
the processing options for this inplementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were: 


AEIA dsname {options} 
options 


description 


dsname Dsname specifies the file to be conpiled. 

ERROR(LIST) Creates a listing file only v^en errors are 

encountered. The file contains conpile-time error 
messages interspersed with the source code. 

CC91PILE I MAIN | BIND Conpile is the default option causing a 

compile only. BIND will be used in those 
instances for subunits needing to be 
compiled prior to the main program. MAIN 
is specified for mains and will allow 
execution to take place. 


3-2 




PROCESSING INFORMATIC»I 


Test output, coopiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. Ihe listings examined on-site by 
the validation team were also archived. 


3-3 






APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in {UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, vhich is 
the value for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string~aggregates, where "V represents the maximum input-line 
length. 


Macro Parameter 


Macro Value 


$MAX_IN_LEN 

$BIG_ID1 

200 ~ Value of V 

(1..V-1 -> 'A', V 

-> '1') 

$BIG_ID2 

(1..V-1 -> 'A', V 

-> '2') 

$BIG_ID3 

(1..V/2 -> 'A') & 

' 3 ' & (1..V-1-V/2 -> 'A') 

$BIG_ID4 

(1..V/2 -> 'A') & 

'4' & (1..V-1-V/2 -> 'A') 

$BIG_INT_LIT 

(1..V-3 -> '0') & 

"298" 

$BIG_REAL_LIT 

(1..V-5 -> '0') & 

"690.0" 

$BIG_STRING1 

& (1..V/2 -> ' 

A') & 

$BIG_STRING2 

& (1..V-1-V/2 

-> 'A') & '1' & 

$BLANKS 

(1..V-20 => ' ') 



$MAX_LEN INT BASED LITERAL 

~ “ “ "2;" & (1..V-5 -> '0') & "11:" 

$MAX LEN REAL_BASED_LITERAL 

"16:" & (1..V-7 -> '0') & "F.E:" 

$MAX_STRING_LITERAL & (1..V-2 -> 'A') & 

A-1 



HACRO PARAMETERS 


The folloving table lists all of the other macro parameters and their 
respective values. 


Macro Parameter 

Macro Value 

$ACC_SIZE 

32 

$ALIGNMENT 

4 

$COUNT_LAST 

2_147_483_646 

$DEFAULT_MEM_SIZE 

16777215 

$DEFAULT_STOR_tINIT 

8 

$DEFAULT_SYS_NAME 

IBM370 

$DELTA_D0C 

2#1.0#E-31 

$ENTRY_ADDRESS 

ENT_ADDRESS 

$ENTRY_ADDRESS1 

ENT_ADDRESS1 

$ENTRY_ADDRESS2 

ENT_ADDRESS2 

$FIELD_LAST 

1000 

$FILE_TERMINATOR 

t t 

$FIXED_NAME 

NO_SUCH_TYPE 

$FLOAT_NAME 

NO_SUCH_TYPE 

$FORM_STRING 

If ff 

$F0RM_STRING2 

CANNOT_RESTRICT_FILE_CAPACITY 

SGREATER THAN DURATION 

86401.0 


SGREATER THAN DURATION_BASE_LAST 

131073.0 

$GREATER THAN FLOAT_BASE_LAST 

7.237006E+75 

$GREATER THAN FLOAT_SAFE_LARGE 

7.23004E+75 


A-2 




HACRO PARAMETERS 


$GREATER THAN SHORT FLOAT SAFE LARGE 
■ “ “ 7.257E+75 

$HIGH_PRIORITY 255 

$ILLEGAL EXTERNAL FILE NAMEl 

Sadchar*x 

$ILLEGAL_EXTERNAL_FILE_NAME2 

BAD-CHAR! 

$INAPPROPRIATE_LINE_LENGTH 

1029 

$INAPPROPRIATE PAGE LENGTH 

-1 

$INCLUDE_PRAGMA1 PRAGMA INCLUDE ('’A28006D1.TST"); 

$INCLUDE_PRAGMA2 PRAGMA INCLUDE ("B28006F1.TST"); 

$INTEGER_FIRST -2147483648 

$INTEGER_LAST 2147483647 

$INTEGER_LAST_PLUS_1 2147483648 

$INTERFACE_LANGUAGE C 

$LESS_THAN_DURATION -86401.0 

$LESS THAN DURATION BASE FIRST 

13T073.0 

$LINE_TERMINATOR ' ' 

$LOW_PRIORITY 0 

$MACHINE CODE_STATEMENT 

NULL; 

$MACHINE_CODE_TYPE NO_SUCH_TYPE 

$MANTISSA_DOC 31 

$MAX_DIGITS 15 

$MAX_INT 2147483647 

$MAX_INT_PLUS_1 2147483648 

$MIN_INT -2147483648 

$NAME NO SUCH TYPE AVAILABLE 


A-3 




HACRO PARAMETERS 


$NAME_LIST 

inc68000, anuyk44, ibm370 

$NAME_SPECIFICATIONl 

'TEST3.X2102A' 

$NAME_SPECIFICATION2 

'TEST3.X2102B' 

$NAME_SPECIFICATION3 

'TEST3.X3119A' 

$NEG_BASED_INT 

16#FFFFFFFE# 

$NEW_MEM_SIZE 

16777215 

$NEW_STOR_UNIT 

8 

$NEW_SYS_NAME 

IBM370 

$PAGE_TERMINATOR 

/ / 

$RECORD_DEFINITION 

NEW INTEGER; 

$RECORD_NAME 

NO_SUCH_MACHINE_CODE_TYPE 

$TASK_SIZE 

32 

$TASK_STORAGE_SIZE 

1024 

$TICK 

0.000001 

$VARIABLE_ADDRESS 

VAR_ADDRESS 

$VARIABLE_ADDRESS1 

VAR_ADDRESS1 

$VARIABLE_ADDRESS2 

VAR_ADDRESS2 

$yOUR_PRAGMA 

PRIORITY 


A-4 



APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 


LINKER OPTIONS 

The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation and not 
to this report. 





Compiling a Source Program 


Chapter 2. Compiling Ada Programs 

This chapter describes how to use the IBM Ada/370 compiler You should have 
available a copy of IBM Ada/370 Language Reference (SC09-1297) or 
ANSI/MIL-STD-1815A. the Ada LRM 

If you need help getting started with IBM Ada/370. see Chapter 9. IBM Ada/370 
Tutorial. 


Compiling a Source Program 

The ADA command compiles a source program. The following sections show 
you how to use this command under VM/CMS. MVS TSO. and as an MVS bat"'* 
job. 


Using the ADA Command under VM/CMS 


-AOA- 


\-fi lejtome- 


‘-/f lejype-i -r 

I—/f lejBode—' 
comp unit name ■ - 






i 




r- 

» 

—(-modifiers —' 

-)- 




The option displays syntax information, including a list of the ADA options, on 
the screen 

Most situations require that you pass the file name of the source file. The 
compilation unit name is required when you use the Bind option, or when you 
use the Run and NOCOmDi )e options. The filejype and mejnode default to ADA 
and respectively 

When you specify a compiler option in ADA. you can use the minimum unique 
abbreviation. For example, you can specify CReate as CR. 

Many compiler options are matched by an opposite. For example, the opposite 
of the HAP option is the NOMAP option. For such cases, one of the options is 
designated as the default. For an option that takes a numerical value, a 
particular value may be assigned as the default. The compiler uses default 
settings unless you override them by specifying the nondefault options to ADA. 

Precede the list of options by a blank space and a left parenthesis, and separate 
them from each other by blank spaces. A closing parenthesis is optional. 


T '::3vf'ont IBM Coro. 1991 


2-1 



Compiling a Sourca Program 


Some of the options have modifiers, which you must enclose in parentheses 
Where you can enter multiple modifiers to an option, such as with the Xref 
option, separate the modifiers with a comma. 

Here are some examples; 

1 ADA EXAMPLE 

Example 1 compiles EXAMPLE ADA * using the default options. 

2. AOA EXAMPLE (LIBRARY (DEMO LIBRARY) DEBUG 

Example 2 compiles EXAMPLE ADA * with the LIBrary and Debug options 
LIBrary causes the compiler to use a file containing an alternative library 
The library has the name DEMO LIBRARY * 

3. AOA EXAMPLE (XREF (BYUNIT,FULL) 

Example 3 compiles EXAMPLE ADA * with the Xref option to produce a 
cross-reference listing. The listing is ordered by compilation unit and 
includes cross-references to ail visible units. 


Using the AOA Command under MVS TSO 

a 

CX *ai/oft/<«r.CLIST(AOA)*—'- 


■ET 


-dsnane - 

-qualtfter.dsname- 


'i 


TJ 




r — 

'—(-mdt ft ers —*-) - 




r" 


Under MVS. the qualirier at 0 high-level qualifier assigned to IBM 
Ada/370 by your system administrator. In examples for this book, we use the 
high-level qualifier ADA. The quatiflar at Q is the high-level qualifier for the 
data set you are specifying. By default, the high-level qualifier is set by the 
PROFILE PREFIX command. This, in turn, defaults to your TSO logon identifier 

The "7” option displays syntax information, including a list of the ada options, on 
the screen. 

Most situations require that you pass the file name of the source file. The 
compilation unit name is required when you use the Bind option. 

When you specify a compiler option in ADA. you can use the minimum unique 
abbreviation. For example, you can specify CReate as CR. 

Many compiler options are matched by an opposite. For example, the opposite 
of the MAP option is the nomap option. For such cases, one of the options is 
designated as the default. For an option that takes a numerical value, a 
particular value may be assigned as the default. The compiler uses default 
settings unless you override them by specifying the nondefautt options to ADA. 


2*2 IBM Ada/370 



Compiling a Source Program 


Precede the list of options by a blank space and a left parenthesis, and separate 
them from each other by blank spaces. A closing parenthesis is optional 

Some of the options have modifiers, which you must enclose in parentheses. 
Where you can enter muttiple modifiers to an option, such as with the Xref 
option, separate the modifiers with a comma. 

Here are some exampies 

1. EX 'AOA.CLrSr(AOA)' 'EXAMPLE' 

Example 1 compiles EXAMPLE using the default options. 

2. EX 'AOA.CLIST(AOA)' ‘EXAMPLE (LIBRARY (•'DEMO.LIBRARY") DEBUG’ 

.Example 2 compiles EXAMPLE with the LiBrary and Debug options. LlBrary 
causes the compiler to use a data set containing an alternative library The 
library has the name OEMO.LIBRARY The compiler also saves information 
needed by the IBM Ada/370 debugger 

3. EX •ADA.CLIST(ADA)’ ‘ ‘‘USER 1.EXAMPLE" (XREF (BYUNIT,FULL)' 

Example 3 compiles EXAMPLE with the high-level qualifier USERl. It includes 
the Xref option to produce a cross-reference listing. The listing is organized 
by compilation unit and includes cross-references to all visible units. 

Compiling a Program with Job Control Language (JCL) 

This section describes how to invoke the compiler as a batch job under MVS 
using Job Control Language (JCL). For information on how to invoke the binder 
using JCL. see "Invoking the Binder with Job Control Language (JCL)' on 
page 3-2. 

The AOAC cataloged procedure invokes the compiler on a source file. 


- 

//MYPROG JOe .iSGCLASS'O.MSCLE'i/EL-d.D.NOTIFY.USERl. 

// CLAS5-A 

//• 

//• PURPOSE: to RUN THE AOA COMPILER 
//* 

//compile exec PROC**OAC.AOASRC-'USER1.AOA.SOURCE(HELLO)'. 

// USER'USERl, CHPPRM--CHECK' 

V_ 

Figure 2-f. Using the ADAC Cataloged ProeePure to Invoke the Binder 

The preceding example job. MYPROG. compiles member HELLO in the source 
POS. USERl ADA SOURCE. The user's name. USERl. is identified with the USER 
variable. This variable is used as a high-level qualifier to construct data-set 
names for the compiler, such as USER1.A0A.LIBRARY. which is the default library. 
Your job card will probably be different, because it depends on your site's 
conventions. 

After you execute this job. the Ada program contained in member HELLO is 
compiled into the working sublibrary of USERl.ADA.LI6RARY. 

A sample of AOAC cataloged procedure appears in Figure 2-2 on page 2-4. The 
exact location of aoac may depend on your site's conventions. 


Chaptar 2. Compiling Ada Programs 2*3 





Compiling a Sourco Program 


//AOAC PROC CHPPRM-' ',MEHSIZE-0196K, 

// STPLIB-'AOAUO.LOAOLIB’ ,MAXTIME-60, 

// VIO-V10,SYSOA-SYSALLOA,SYSOUT-'*' 

//* 

//* ERASE AOA.INFO DATASET 
//• 

// EXEC PGM-1EFBR14 

//AOAINFO 00 0SM-&USER..ADA.INF0,0ISP-(M00,DELETE), 

// SPACE-(1,1),UNIT-BSYS0A 

//. 

//* 

INVOKE THE COMPILER 


//***•"*** 

//STEPl 

EXEC PGM-EVGCOMP,PARM-'»CMPPRM',REGI0N-4MEMSI2E, 


// 

TIHE-&HAXTIME,0YNAMNBR-65 


//STEPLIB 

00 0SN-&STPLIB.01SP-SHR 


//CONOUT 

00 SYS0UT-ASYS0UT,DCB-(LRECL-12e,BLKSIZE-120) 


//AOAIN 

00 OSN-&AOASRC,OISP-SHR,FREE-ENO,DCB-BUFNO-4 


//aoalib 

00 0SN-&USER..AOA.LIBRARY,DISP-SHR 


//AOAINFO 

00 0SN-&USER..AOA.INF0,0ISP-(NEW,PASS,CATLG), 


// 

OCB-(RECFM-VB,LRECL-512,BLKSIZE-3120,DSORG-PS), 


// 

SPACE-(80,(10.50}),UNIT-&SYS0A 


//AOALIST 

00 0SN-AUSER..LISTING,0ISP-(M00,CATLG,CATLG), 


// 

DCB-(RECFM-VBA.LRECL-259.BLKSIZE-3120,0S0RG-P0,BUFN0-2), 


// 

SPACE-(132,(500,2000,20)).UNIT-&SYSDA 


//AOAUTl 

00 SPACE-(132,(500,2000)), 


// 

OC8-(RECFH-FB,LRECL-136,BLKSIZE-340O,OSORG-OA,BUFNO-2), 


// 

WIT-iSYSOA 


//A0AUT2 

00 SPACE-(132,(5B0,200e)), 


// 

OCB-(RECFM-V8,LRECL-136,BLKSIZE-3120,DSORG-PS,BUFNO-2), 


// 

UNIT-&VI0 


//A0AUT3 

00 SPACE-(132,(500,2000)), 


// 

OCB-(RECFN-FB,LRECL-ie28,0LKSIZE-2e56,OSORG-OA,BUFNO-2). 


// 

UNIT-&SYS0A 


//A0AUT4 

00 SPACE-(132,(500,2000)), 


// 

OCB-(RECFH-FB.LRECL-132,BLKSIZE-2640,OSORG-OA,BUFNO-Z), 


// 

UHIT-4SYS0A 



figure 2~2. AOAC Cataloged Procedure 


Symbolic Variables for AOAC Cataiogod Procadura 

The AOAC cataloged procedure includes several symbolic JCL substitution 

variables you can modify to specify the various options available. 

Symbolic 

Varlablo Oescriptlon 

ADASRC Specifies the data'Set name (DSN) for the Ada source file. This 
name must be set In order to successfully compile an Ada 
program. 

CMPPRM Specifies options to the compiler in the FARM field. This variable, 
found in Step 1 of the AOAC cataloged procedure, specifies 
options to the compiler in the FARM field. These options are the 
same ones used when you invoke the compiler with the aoa 
command. 


2-4 IBM Ada/370 








Compiling a Source Program 


The compiler options have the following syntax: 


1 



i 

— (-modtfters — 




MAXTIME 

MEMStZE 

STPLIB 

SYSOA 

SYSOUT 

USER 

VIO 


Table 2-2 on page 2-8 lists the valid options, their modifiers, and 
defaults. 

Sets a maximum amount of time for the compiler job step to run 
(via the TIME parameter on a JCL EXEC card). The default value is 
60 minutes, but this value can be changed when the cataloged 
procedure is installed. 

Specifies the amount of memory in which to run the compiler job 
step (via the REGION option on a JCL EXEC card). The greater the 
memory, the better the performance of the compiler The default 
value IS 8t96Kb. but this value may be changed, depending on 
your site s conventions. 

Indicates the data-set name of the partitioned data set that 
contains the compiler module. EVGCOMP. This default can be 
changed when the cataloged procedure is installed. 

Speofies the UNIT for permanent data set allocations. The 
default is sysallda. but this value can be changed depending on 
your site's conventions. 

Identifies the output class for the compiler output. The default is 
but this can be changed, depending on your site's 
conventions. 

Indicates the high-level qualifier that is required to build data-set 
names used by the compiler. You must specify this variable. It 
is common to set this vanable to your TSO logon identifier. 

Specifies the UNIT for temporary data set allocations. The default 
is VIO. but the default can be changed depending on your site's 
conventions. 


Chapter 2. Compiling Ada Programs 2*5 





The Compiler Options 


The Compiler Options 

The ADA command invokes the IBM Ada/370 compiler. Table 2-1 provides a 
brief summary of the compiler options. The square brackets enclose optional 
modiTiers. You do not actually enter the brackets as part of the command 
syntax. For the specifle syntax of each option, see the option descriptions on the 
pages specified in the table. 


Table 2-1 (Page 1 of 2). 

Compiler Options 



Option 

Default 

Function 

Page 

Asm 

NOASffl 

Aaaombly listing. 

2-9 

[NOGen 


Suppress listing of expanded generics. 


1 NOSys) 


Suppress listing of system-supplied generics. 


Bind 

COmpi )e 

Bind previously-compiled main unit. 

2-tO 

CHeck 

compile 

Compile with syntactic and semantic checking only 

2-10 

(Nosemanticl 


Compile with syntactic checking only. 


compile 

compile 

Compile code for a library unit. 

2-11 

CReate [number j)f jjnUa\ 

NOCReate 

Initialize working subiibrary for the compiler. 
numberjiljjnits is number of compilation units in 
sublibrary. 

2-tl 

OebuR 

NOOebuq 

Output information for debugging. 

2-t3 

Error 

MOError 

Specify action to be taken when errors occur. Must 
include at least one modifier. 

2-13 

(Count — number] 


Abort compilation after number errors. 


(Listl 


(ieneraie interspersed listing of errors and source 
code. 


Generate 

NOGenerate 

(VM/CMS) 

Generate a load image. 

2-14 

NOGenerate 

Generate (MVS) 



INI 1st [maxjtumber] 

compile 

Compile multiple source files with one invocation of 
the compiler, masjtumber is the maximum number 
of compilation failures during input list processing. 

2-15 

LIBrary library jiame 


Specify Ada library name. 

2-15 

List 

NOLISt 

Generate interspersed listing of errors and source 
code. 

2-16 

MAIn (comp_omt_na/ne| 

compile 

Compile and bind coda for a main unit. 

2-16 

MAP 

NOHAP 

Produce linkage map during binding. Use with MAIn. 
Bind, or Run options. 

2-17 

NOCOmpile 

compile 

Suppress the compiler. 

2-17 

Run 

NORun 

Execute main program. 

2-18 


2*6 IBM Ada/370 






























































The Compiler Options 


Tabla 2-1 (Page 2 of 2). Compiler Options 


Option 

Default 

Function 

Page 

Suppress 

NOSuopress 

Suppress selected run>time checks or line information 
tables in generated obfect code. Must include at 
least one modiTier. 

2-18 

(Lineinfol 


Suppress generation of tins information tables. 


(Checks 


Suppress all run-time checks. 


1 Elabi 


Suppresses only elaboration checks. 


Trace 

NOTrace 

Display diagnostic messages from the compiler. 

2-19 

Xref 

NOXref 

Produce a cross-reference listing. 

2-19 

(ByunitI 


Order the listing by compilation unit. 


(Full) 


Cross-reference all visible units. 



Chapter 2. Compiling Ada Programs 2~7 












The Compiiar Options 


Compiler Options for Use with ADAC Cataloged Procedure 

This section deTines the standard options for the CMPPRM symbolic variable 
when you invoke the compiler as a batch job under MVS. For more information 
on CMPPRM. see "Symbolic Variables for ADAC Cataloged Procedure' on 
page 2-4 Descriptions of the options appear on the pages shown. 


Table 2-2. Compiler Options for JCL 

Option 

Oeleult 

Function 

Page 

ASM 

NOASM 

Assembly listing. 

2-9 

(NOGEN 


Suppress listing of expanded generics. 


1 NOSYS) 


Suppress listing of system-supplied generics. 


CHECK 

COMPILE 

Compile with syntactic and semantic checking only. 

2-10 

(NOSEMANTIC] 


Compile with syntactic checking only. 


COMPILE 

NOCOMPILE 

Compile code for a library unit. 

2-tt 

CREATE \numeer_oljjnits\ 

NOCREATE 

Initialize working sublibrary for the compiler. 
numberjifjjnits is number of compilation units in 
subiibrary. 

2-11 

OONAMES 

oMjtame <- newjtame 


Specify the Data Description (00) names that identify 
the data sets used by the compiler and binder It 
must include at least one modifier. 

2-12 

DEBUG 

NOOEBUG 

Output information for debugging. 

2-13 

ERROR 

NOERROR 

Specify action to be taken when errors occur. Must 
include at least one modifier. 

2-13 

(COUNT • number) 


Abort compilation after number errors. 


(USTJ 


Generate interspersod listing of errors and source 
code. 


LIST 

NOLIST 

Generate interspersed listing of errors and source 
code. 

2-16 

SUPPRESS 

NOSUPPRESS 

Suppress selected run>time checks or line information 
tables in generated object code. Must include at 
least one modifier. 

2-18 

(LINEINFO) 


Suppress generation of line information tables. 


(CHECKS 


Sui^ett all run-tima chackt. 


1 ELAS] 


Suppresses only elaboration checks. 


TRACE 

NOTRACE 

Display diagnostic messages from the compiler. 

2-19 

XREF 

NOXREF 

Produce a cross>referenca listing. 

2-19 

(BYUNITl 


Order the listing by compilation unit. 


(fulli 


Cross>reference all visiblo units. 



2*8 IBM Ada/370 

















































Asm Option 


Detailed Descriptions of Compiler Options 

The following detailed descriptions of the compiler options include syntax 
diagrams. In these diagrams, uppercase characters indicate the minimum 
abbreviation of options and their modifiers. Options and modiTiers that are 
underscored are the defaults. 


Asm Option 



1 


NOGen- 

NOSys 



The Asm option produces pseudo>assembly language for the object code 
interspersed with the Ada source for each compilation unit. It causes the 
creation one listing for each source file. Asm also provides information on the 
relative offset and size allocation of each data item or constant. This listing is 
called the data mao For more information on the listing produced by Asm. see 
"Source and Assembly Listings" on page 7*1. 

If you use the Asm option at the same time you invoke the IBM Ada/370 binder, 
the compiler also produces a binder listing. 

The NOGen modifier suppresses the listing of code generated for expanded 
generics. Otherwise, listings include the code generated for all expanded 
generics. 

The NOSys modifier suppresses the listing of code generated for system-supplied 
generics. 

Use NOGen or NOSys to reduce the size of listings. 

Under VMICMS 

The name of the listing file takes the form source LISTING A, where source is the 
file name of the source file. 

Under MVS 

The name of the listing data set takes the form qualifier \jST\HG{source) where 
qualifier is the TSO logon identifier and source can be either the name of tfie 
member of a partitioned data set (PDS) used as source or the second qualifier in 
the name of a sequential data set. 


Chapter 2. Compiling Ada Programs 2-9 



Cheek Option 


Bind Option 



The Bind option binds a main program that has been previously compiled as a 
library unit. As output, it produces an object file. When you use this option, 
enter the compilation unit name in place of the source file name. You can only 
use the Bind option for compilation units that reside in the working sublibrary of 
the Ada program library. 

To invoke the binder when you compile the source (rather than in a separate call 
to ADA), use the Mln option. 

You cannot use the Bind option in combination with MAln, CHeck. INlist. Compile, 
or NOCOmpi le. If you enter more than one of these options. IBM Ada/370 only 
accepts the last one in the command line. If you do not use any of these 
options, the default is compile. 

Under VMICMS 

The object file created by compiling with the Bind option has the file type TEXT. 
Under MVS 

The object Tile is a POS created by compiling with the Bind option It takes the 
form qualHler OBMcompjjnit). where qualifier is your TSO logon identifier and 
cotnpjjnit is the compilation unit name. 

Check Option 



The CHeck option causes the compiler to perform only syntactic and semantic 
error checking. Because no object code is produced, you can save compilation 
time and disk space during error checking. If you include the Nosemantic 
modifier, the compiler only performs syntactic error checking. 

You cannot use the CHeck option in combination with MAIn. Bind, INI 1st. Compile, 
or NOCOmpi I e. If you enter more than one of these options. IBM Ada/370 only 
accepts the last one in the command line. If you do not use any of these 
options, the default is compile. 


2*10 IBM Ada/370 





Create Option 


Compile Option 


Create Option 


»» - COaptlfr --- 

The compile option causes all compilation units in the source file to be library 
units, rather than mam units. 

You can also make a library unit into a main unit using the Bind option. 

You cannot use the compile option in combination with MAIn. Bind. CHeck. INI 1st. 
or NOCOmpi 1e. If you enter more than one of these options. IBM Ada/370 only 
accepts the last one in the command line. If you do not use any of these 
options, the default is compile. 


C CReate— 
HOCReate 


• -numbe r_o fjjn its —) 



CReate initializes the working sublibrary for the compiler. The compiler creates a 
new sublibrary, deleting the previous copy, if one exists. 

The number jifjjnits variable specifles the number of compilation units the 
sublibrary can contain The default is 200. The largest number of units a 
sublibrary can contain is 4671. 

This number indicates an approximate size for the sublibrary. The number of 
units that actually fit into a sublibrary depends upon their size and complexity. 
For further information on sublibraries, see Chapter 5. Working with the Ada 
Library System 

When you use CReate m conjunction with the LIBrary option, it initializes the 
working sublibrary m the library specified by LIBrary. 

You cannot use CReate in combination with the Bind option. 

NOCReate is the default With NOCReate. the compiler does not initialize the 
working sublibrary 


Chapter 2. Compiling Ada Programs 2*11 


OONAMES Option (MVS JCL Only) 


DONAMES Option (MVS JCL Only) 


OOMAMES —(-ol —)-— 

OONAMES spectRes the Data Description (DD) names that identify the data sets 
used by the compiler and binder. OONAMES always requires a value. 

For use with the compiler, oldjiama has one of the following values: 

AOAIN 

AOAINFO 

AOALIB 

AOALIST 

AOAUT1 

AOAUn 

AOAUT3 

AOAUT4 

For use with the binder, oldjtante has one of the following values: 

AOAINFO 

AOAUB 

AOAUST 

A0AUT1 

AOAUn 

AOAUT3 

A0AUT4 


Usually, you do not need to change the 00 names associated with the compiler. 

This example of a JCL code fragment uses OONAMES to identify a new 00 name 
specifying the source Tile and the ada library: 

//MYSTEP EXEC PGM-EVGCWP,PARM-*OONAMES(AOAIN-MYSOURCE,AOALIB-MYLIB)' 
//MYSOURCE 00 0SN-<7voit/fer.A0A.S0URCE(PR0GRAMl) 

//HYLIB 00 OSN-<ruoi(/(er.AOA.LIBRARY 


2*12 IBM Ada/370 


Error Option 


Debug Option 


►» I O ebuq-j-—- - 

‘ HiOOebuq -^ 

The Debug option causes information used by the IBM Ada/370 debugger to be 
placed in the working sublibrary. When used with the MAln or Bind options. Debug 
produces a debugging map. which is reguired by the debugger. 

For more information about debugging, see Chapter 8. The IBM Ada/370 
Debugger. 

With NOOebug. the compiler does not place debugging information into the working 
sublibrary. 

Undar VMICMS 

The debug map file takes the name compjjnit OEBUGMAP A where comp_unit is 
derived from the name of the compilation unit. 

Under MVS 

The debug mao file lakes the name qualifier 0EBUGMAP(comp_un;0. where 
qualifier is the high-level qualifier and compjjnit is derived from the name of the 
compilation unit. 


Error Option 


Error (-^CouBt^nwirbcr—|—)- 


r-’Error— 
UwError- 


Ltst- 


Error controls the way (he compiler behaves when it finds errors in the source 
file. You must choose at least one of the modifiers. 

The Count modifier specifies the number of errors that cause the compiler to stop 
processing. The compiler includes syntax, semantic, and warning errors in the 
count. For example, COUNT-5 causes the compiler to stop processing after it finds 
five errors. If you omit the Count modifier, the compiler stops processing when it 
finds 32767 errors, the default error limit. 

The List modifier creates a file containing compile-time error messages 
interspersed with (he source code. If there are no errors, the compiler does not 
generate the listing. To generate this listing regardless, use the List option. 

See "List Option ' on page 2-16. 

With MOError, the compiler does not modify its behavior when it finds errors 
during processing. 

Under VMICMS 

The listing file created by the List modifier is called source LISTING A, where 
source is the file name of the source file. 


Chapter 2. Compiling Ada Programs 2*13 







Gcnaratc Option 


UndT MVS 

The listing file created by the List modifier is called quaUner usVHCisource). 
where qualifier is the TSO logon identifier and source is the file name of the 
source data set. 


Generate Option 

The Generate option generates a load image. 
Under VMICMS 



Under VM/CMS, when you compile with the Generate option, the ADA command 
also invokes the binder, producing an object file. The compiler then uses the 
object file to produce the load module. This option assumes that the source fife 
contains a main program. The load module created by the Generate option has 
the name comp_unit MODULE A. where compjjnit is derived from the 
compilation unit name. 

With NOGenerate. the compiler does not generate an executable load module. 
Under MVS 



The NOGenerate option suppresses the invocation of the linkage editor after 
binding a main program. Use this option when you want to invoke the linkage 
editor with options that differ from the default. For example, you would use 
NOGenerate when you want to link the main program with non>Ada object code. 

The load module created by the Generate option has the name 

qualifier.LOAO{compjjnit). where compjjnit is derived from the name of the 

compilation unit. 

The ftOGenerate option has no effect when used in combination with NOCOmpile. or 
when you compile the program as a library unit instead of a main unit. 

You cannot use NOGenerate in combination with the Run option. 


2*14 IBM Ada/370 





Library Option 


Inlist Option 


L-COimlle- 


(-mojf mbe p- 


U 


The INIist option compiles multiple source files with a single invocation of the 
compiler. When you use this option, enter the name of the file containing the 
input list in place of the source file name. For more information on the use of 
input lists, see "Compiling Multiple Source Files" on page 2-20. 

If a source file fails to compile, the compiler continues to process the remaining 
files. You can specify that the compiler stops processing after a certain number 
of source files fail to compile. To do so. use the max_number variable. 

You cannot use iNl 'st in combination with the Bind, CHeck. MAin, compile or 
NOCOmpi le options If you enter more than one of these options. IBM Ada/370 
only accepts the last one in the command line, if you do not use any of these 
options, the default is compile. 


Library Option 


»» LlBrary-(— I tbraryjtame —)-- 

The LlBrary option specifies the name of the Ada library file to be used by the 
compiler. The library_nam9 modifier is the name of a library file that contains 
the names of one or more sublibraries. 

When you do not specify the LlBrary option, the compiler uses the default library 
file. Under VM/CMS. it has the name ADA LIBRARY * Under MVS. it has the 
name gua/ifier ADA library where qualirier is the TSO logon identifier. For 
information concerning libraries and sublibranes. see Chapter 5. Working with 
the Ada Library System 

Under VMICMS 

You can provide the libraryj^ame variable in either of two formats. The 
preferred is (ile_name lilejype filejnode. The other format is 
rilajnodafilejiame filejype. In both formats, if you specify only the file name. 
filejype defaults to library and file mode defaults to If you do not specify 
a library file. ADA searches for ADA LIBRARY * 

For example, to specify library PROJt LIBRARY A, when you compile the file 
MYPROG, enter; 

AOA MYPROG (LIB(PROJl)) 

It is recommended that you do not select an alternative file type for the Ada 
library file. Retaining the default file type maintains consistent file naming 
conventions for all users 


Chapter 2. Compiling Ada Programs 2*15 




Main Option 


Und 0 r MVS 

A library can be either a sequential data set or a member of a POS. The 
libraryj}am« variable can be any valid data-set name format. For example, to 
specif^library PROJt .UBRARY on USERI when you compile the data set 
MYPROG.SOURCE enter 

EX 'AOA.CLIST(AOA)' * "USERl.MYPROG.SOURCE’' (LIB(*'OSERl.PROJl.LIBRARY")' 


List Option 



The List option creates a file containing a listing for each source Tile. The listing 
contains compiie*time messages interspersed with the source code. If there are 
multiple compilation units in a source file. List places the listings for all units 
into a single file. 

Undar VMICMS 

The compilation listing file lakes the form source LISTING A. where source is the 
file name of the source file. 

Under MVS 

The compilation listing file takes the form qualifier.illXiH(i(source), where 
qualiner is the tSO logon identifier and source can be either the name of the 
member of a POS used as the source or the second qualifier in the name of a 
sequential data set. 

Main Option 


j NAIn- 

Uoeaj 


n 


■ COaelle - 


{—eoiiv_witf_/io 


J 


The NAin option causes the compiler to produce code for the source file as an 
Ada main program. The MAln option compiles a program and performs the 
binding operation without the need to specify any other option. 

If the Ada source file contains one or more library compilation units in addition 
to the main compilation unit, enter the name of the main program in the 
compjunitjiame variable. 

You cannot use the MAin option in combination with Bind. CHeck, INHst, COmoile. 
or NOCOnpt 1e. If you enter more than one of these options. IBM Ada/370 only 
accepts the last one in the command line. If you do not use any of these 
options, the default is compile. 


Under VMICMS 

The object file created by compiling with the MAIn option takes the form 
compjjnit TEXT A. where eompjunit is the compilation unit name. 

Under MVS 

The object file created by compiling with the MAIn option takes the form 
qualifier.OBJlcompjunit). where qualifier is the TSO logon identifier and 
eompjunit is the compilation unit name. 


2-16 IBM Ada/370 



Nocompile Option 


Map Option 


** r W f- 

Lmoh 


NOWP- 


The MAP option causes the compiler to produce a linkage map when the IBM 
Ada/370 binder processes a main program. 

Use MAP in combination with either MAIn or Bind, both of which invoke the binder. 
You can also use MAP in combination with Run as long as you do not use the 
NOCOmpi I e option. 

With NOMAP. the compiler does not create a linkage map when the IBM Ada/370 
binder processes a main program. 

Under VMtCMS 

The map Tile is called ob/ect AOAMAP A. where object is the file name of the 
object Tile 

Under MVS 

The map file is called pualifier AOAUAP(comp_umt). where qualifier is the TSO 
logon identifier and comp_unit is the name of the main compilation unit. 


Nocompiie Option 




NOCOaptle- 
Oentle — 


The NOCOmpi le option causes the ADA command to suppress the compilation step. 
Thus, you can use NOCCmoi le with Run to run an Ada program that has already 
been compiled. When you use NOCOmpi ie with Run. enter the compilation unit 
name in place of the source file name. 


You can also use NOCOmoi le with the CReate to create a new working sublibrary 
without having to compile the source code. 

You cannot use the NOCOmpi le option in combination with MAIn. Bind, CHeck. INIist. 
or compile. If you enter more than one of these options. IBM Ada/370 only 
accepts the last one in the command line. If you do not use any of these 
options, the default is compile. 


Chapter 2. Compiling Ada Programs 2*17 



Suppress Option 


Run Option 


--p«un- 1 -- 

MIORun - ' 

The Run option loads and executes a main program. The compiler assumes that 
the program is a main unit. You can either compile and run a program, or run a 
precompiled program. To run a previously compiled and bound program, use 
Run in combination with the NOCOmpile option. When you use Run with NOCOmpiie. 
you must specify the compilation unit name, rather than the Ada source Hie 
name. 

With NORun. the compiler does not execute the program. 


Suppress Option 



t Suppress—( 

MOSuperess — 



The Suppress option suppresses selected run>time checks and line information in 
generated object code, resulting in smaller, faster modules. You must choose at 
least one of the modifiers. Use of either the Suppress option or pragma Suppress 
causes the compiler to suppress run-time checks. For more information on 
pragma Suppress, see the chapter on tuning in the IBM Adal370 Programmer's 
Guide. 

The Lineinfo modifier suppresses the generation of line information tables, thus 
saving the space required to produce them. These tables display the Ada 
source line number when an unhandled exception occurs, if you compile your 
code with this option and an unhandled exception occurs during run time, the 
error information does not include a line number. 

The Checks modifier suppresses aff run-time checks. 

The Elab modifier only suppresses elaboration checks made by other units on 
this unit. This differs from the way pragma Suppress works. The pragma 
suppresses elaboration checks made on other units from the unit in which it 
resides. 

If you choose both the Checks and Elab modifiers, the Checks modifier takes 
precedence. 

With NOSuppress. the compiler does not suppress selected run-time checks and 
line information in generated object code. 


2*18 IBMAda/370 



Xr«f Option 


Trace Option 


Tract- 




racf- 


The Trace option displays diagnostic messages from the compiler. This option is 
intended for use in submitting problems to IBM. For more information, see the 
IBM Ada/370 Diagnosis Guide. 


Xref Option 


■Xrtf 


HfflXref 



The Xref modifier produces a cross-reference listing for each compilation unit 
contained in the source file. It creates one listing Tile for each source Tile. 

Byunit causes Xref to display symbols by compilation unit. By default, the Xref 
listing displays symbols in alphabetic order. 

Full causes Xref to cross-reference each compilation unit with all unit 
specifications that are visible to it. A unit specification is visible if it is an import 
to the compilation unit. If the compilation unit is a body, its parent and its 
parent's imports are also visible. Full does not display cross references for the 
private parts of imported units. By default. Xref only cross-references the 
compilation units specified in the command. For more information, see 
"Cross-Referencer" on page 7-2. 

VMICMS Usage 

The listing file takes the form source USTING A. where source is the file name of 
the source file. 

MVS Usage 

The listing file takes the form gua/if/er.uSTING(source). where qualifier is the TSO 
logon identifier and source can be either the name of the member of a 
partitioned data set (POS) used as source or the second qualifier in the name of 
a sequential data set. 


Chapter 2. Compiling Ada Programs 2*19 





Compiling Multipio Source Files 


Compiling Multiple Source RIes 

An input list is a Tile containing a list of the names of Tiles to be compiled. Using 
input lists, you can compile multiple source files with a single invocation of the 
compiler. This reduces the time it takes to compile a group of source Tiles 
because it eliminates some redundant activities within the compiler. 

The names of source files appear in the input list, along with other information 
that controls the compilation process. The compiler processes items in the input 
list in sequential order. Besides the object code that is the usual result of 
compilation, the compiler produces a Tile that contains information on the results 
of the success or failure of each compilation. 

If you use a compiler option that produces compilation listings (Asm. List. Error, 
or Xref. the compiler produces a separate listing for each compilation unit. 

To compile multiple files with the ADA command, use the INlist option 

If the compiler detects errors during compilation of any source file in the list, it 
goes on to the next source Tile. There may be cases, especially with a large 
input list, where it is not advisable to continue through the entire input list when 
multiple source files abort. The INlist option has a variable that allows you to 
specify the maximum number of source Tile compilation failures to allow. The 
next failure causes the compiler to stop processing the input list. 

Under VMICMS 
The command string 

ADA MYLIST (IN(8) 

compiles the source files in the input list MYLIST INUST. setting the failure limit at 
six. 

Under MVS 

The command string 

EX •AOA.CLIST(ADA)' 'MYLIST.INLIST (IM(6)' 

compiles the source Tiles in the input list MYLiST.iNUST. setting the failure limit at 
six. The compiler uses the default high'level quaiiTier. 

Constructing the Input List 

An input list contains two types of information, names of source files to be 
compiled and compile-time options. 

The syntax for each line of the input list is; 

- fft lejiaaie - r— . . . - 

-compile-f imejaptton- 
-• eament- -- - 

-blanket Int - 

The rules for creating the input list are: 

• Place only put one file name or compile-time option on a line. 

• Do not place comments on the same line with other information. 

• If the first nonblank character in a line is that line is a comment line. 


2*20 IBM Ada/370 



Compiling Multiple Source Files 


• The compiler ignores blank lines. 

• File names do not have to start in the first column. 

This VM/CMS file list follows the rules correctly. 

* YES, THIS IS A COMMENT 

AFIIE ADA A 
BFILE ADA A 

B1SU8 AOA A 
B2SUB AOA A 

CFILE AOA A 

If an error occurs during input list processing, the compiler updates the working 
sublibrary with information about the units that have been compiled successfully 
Also, the compiler places information about the results in an output file. For 
more information about the contents of this file, see “Getting Information on an 
Input List Compilation ■ on page 2-22. 

VM/CMS Sourca File Names 

Enter the names of source files into the input list. If you leave out the file type, 
the compiler assumes the file type is ADA. 

Input List Compiler Interpretation 

MYFILE MYFILE AOA • 

MYFILE TEST MYFILE TEST • 

MYFILE TEST A MYFILE TEST A 

MVS Source Data Set Names 

Enter the names of source data sets into the input list either fully or partially 
qualified. Enclose fully qualified names inside a pair of single quotation marks. 

If you leave out the high-level qualifier, the compiler assumes the current TSO 
logon identifier 

Input List Compiler Interpretation 

MYFILE 'qua/ifier.MYFILE' 

MYFILE. TEST 'quaf/ffer MYFILE. TEST' 

•OTHER.MYFILE.TEST' ’OTHER.MYFILE.TEST' 

Embedding Compile-Time Options in the Input List 

You can place compile-time options and input list options within the input list. 
Options set when you invoke the compiler apply to each source file until they are 
overridden by an option embedded in the input list. Options that appear in the 
input list apply to all following source files until they are overridden by other 
embedded options. A specific option can appear multiple times in an input list. 


MPTIOMS- -j-comptlerypt ton- 

^inputjlstjapttoi 


Chapter 2. Compiling Ada Programs 2*21 






Compiling Multipto Source Files 


The compiler options you can embed in input lists are; 

ASM 

CHECK 

COMPILE 

DEBUG 

ERROR 

INLIST 

LIST 

SUPPRESS 

XREF 


There is one valid inputjistjoption. OEFault. The DEFault option causes the 
compiler to reset all options to their states as set by the ADA command. OEFaul t 
is only valid as part of the ftOFTlONS command in an input list. 


The following example shows an input list with embedded options, along with 
descriptions of how the options change. This example uses VM/CMS file naming 
conventions: MVS users should use MVS conventions. 


Input List 


How Options Change 


AFILE AOA A 
(OPTIONS DEBUG 
BFILE ADA A 
(OPTIONS NOOEBUG 
CFILE ADA A 
(OPTIONS OEFAULT 
EFILE ADA A 
(OPTIONS DEBUG 
FFILE ADA A 


Command-line options 
Command-line options plus Debug 
Command-line options plus NOOebug 
Command-line options only 
Command-line options plus Debug 


Getting Infonnation on an Input Uat Compilation 

The compiler creates a file and places information about of the compilation into 
it. Each line in the input list aiso appears in this file. Following each line from 
the input list containing the name of a source file is a line that shows 
compilation status for the file. Source files that compile successfully show a 
return code of zero for each compilation unit in the file. Files that do not compile 
show the return code of the error that caused the failure. There are also 
descriptive messages where return codes do not provide enough information. 


The return codes that can appear are: 

Cede Explanation 

0 Execution complete. No errors occurred. 

4 Execution complete. Warnings were issued, but no errors occurred. 

8 Source code errors, such as syntactic or semantic errors, were detected. 
Look for specific errors in the console listing. 

Below is a brief example of an input list and the OUTPUT file that might result. 
This example uses VM/CMS file naming conventions; under MVS the output 
follows MVS conventions. 


2*22 IBM Ada/370 






Generating Recompilation Scripts 


Sample Input List MYLIST INPUT A 

SOFTIONS ASM 
FILEONE AOA A 
&0PTI0NS OEF 
FILETWO AOA A 
MPTIONS 0LTZ 

Sample OUTPUT Rle 

INPUT list processing MYLIST INPUT A - yyyy-nm-dd hh:rm:ss - options {options 

MPTIONS ASM 

FILEONE AOA A 

RC-OO FILEONE AOA A1 

MPTIONS OEF 

FILETUO AOA A 

RC-OO FILETWO AOA AI 

MPTIONS BLTZ 

»> ERROR IN INPUT LIST COMMANO SYNTAX 
VMICMS File Name 

The name of the OUTPUT file lakes the form input Jistjtame OUTPUT a. where 
input Jist_name is the file name of the input list. 

MVS Data Set Name 

The name of the OUTPUT data set takes the form 

qualifier 0UTPUT(/npuf_//sf_name). where qualifier is the current TSO logon 
identifier and input Jist_name is the name of the input list. 


Generating Recompilation Scripts 

VMfCMS SyntaM 

•^AOARECOH—C3mp_un t tjfome 


' —(-pLtbrary—(-1 Ibroryjfome-)- 




lody- 




MVS Syntax 

e*-CX • qualifier.cun (AOARECOH )’—'-xompjinitjiaae 


'—{-^Library—{-! ibraryjtam-)- 


Body- 




The AOARECOM command generates a recompilation order list. When a library 
consists of many compilation units that depend on (possibly multiple levels oO 
with statements, it can be difficult to determine the proper compilation order if 


Chapter 2. Compiling Ada Programs 2*23 






G«n«rating Raeompilatlon Scripts 


the specirication of a unit needs to be recompiled. To use aoarecom. you must 
have compiled the compilation units into a specified library at least once. 
AOARECOM reads the library to build a recompilation list of the units that depend 
upon the specified unit. This list contains the source file names of the units that 
need to be recompiled. Therefore, if you move an Ada compilation unit to a new 
source file, you must modify the recompilation list. 

Por AOARECOM to correctly generate the recompilation list, the association 
between file names and compilation units cannot change between the time they 
are compiled and the AOARECOM invocation. 

The file list produced under either VM/CMS or MVS is suitable for input to the 
INI 1st option to the AOA command. For more on this subject, see "Compiling 
Multiple Source Files" on page 2-20. 

Do not change the names of the source file, separate the specification and body 
into different files, or perform any other change that alters the relationship 
between that file and the compilation unit or units it contains between the time 
you make the recompilation list and the time you perform the recompilation. 

You can to edit the recompilation list after running AOARECOM. to make changes 
to the recompilation order list. 

Also. AOARECOM produces a correct source file list only if each file contains a 
single compilation unit. 

Precede the options by a blank space and a left parenthesis, and separate them 
from each other by blank spaces. A closing parenthesis is optional. 

< he LIBrary option allows you to specify the name of the library file, 
libraryjiam9, that AOARECOM is to read. 

If you specify the BOOy option. AOARECOM assumes that compjjnit_name refers 
to the body of a compilation unit. By default, compjunitjtama refers to the 
specification of a compilation unit. 

Undar VMICMS 

You can provide the library jiama variable in either of two formats. The 
preferred format is fflajtama tllajypa lilajnoda. The other format is 
niajnoda filajiama.niaJypa. In both formats, if you specify only the file name. 
niajypa defaults to UBRARY and nia moda defaults to If you do not specify 
a library file, AOA searches for ADA LIBRARY * 

The recompilation list goes into a file called compjinit INLIST A. 

The command 

AOARECOM HYJROG (L(MYLIB.LIBRARY)) 

generates a recompilation list that includes all units within MYUB LIBRARY that 
must be recompiled if you recompile MY_PROG, also found in that library. 

Under MVS 

If you do not specify libjiama, the default is qualiffar.ADA.UBRAKY. 

The recompilation list goes into a file called ouaff77er.iNLlST(comp_un/f). where 
qualifiar is your TSO logon identifier. 


2-24 IBM Ada/370 




Separate Compilation of Generics 


The command 

EX •ADA.CLIST(AOARECOM)' •MY_Pfl06 (L(MYLIB))‘ 

generates a recomoilation list that includes all units within duat/Tier MYLIB that 
must be recompiled if you recompile MY_PROG, also found in that library 


Separate Compilation of Generics 

IBM Ada/370 supports separately>compiled generics. You can compile a generic 
specification in in file and its generic body in a separate file. 

If you plan to compile your generics separately, compile the generic body before 
you attempt to instantiate the generic. The generic body must be compiled and 
visible in the library before the instantiation can occur. 

You can compile instantiations before you compile the generic body. If you do. 
the compiler issues a warning. When you compile a generic body, all 
instantiations of the generic become obsolete. You must recompile all 
instantiations of the generic after you compile a new generic body. 

Por more information on the compiling and instantiation of generic units, see 
Chapter 12 of the LRM 


Chapter 2. Compiling Ada Programs 2*25 




Separata Compilation of Canaries 


2*26 IBM Ada/370 




Using the IBM Ada/370 Binder 


Chapter 3. Binding and Linking an Ada Program 

The purpose of this chapter is to show you the different ways to invoke the IBM 
Ada/370 binder or the linkage editor, and to explain when you need to use them 

The flexibility in symbol naming allowed by Ada makes implementation of the 
language difficult in environments using pre*existing linkage editors and loaders. 
To alleviate this problem. IBM provides a special Ada linker called the IBM 
Ada/370 binder. It combines object modules produced by the IBM Ada/370 
compiler and outputs them as a standard IBM object module. 

This partially-linked object module is further processed by the system 
linker/loader to produce an executable load module. The IBM Ada/370 binder 
provides full support of Ada requirements for symbol naming. It also drastically 
reduces the number of external definitions and references that must be 
processed by the host system linker. 

An Ada program can use pragma Interface to call subprograms written m a 
programming language other than Ada. The system linker puts the 
standard-format object modules produced for these subprograms into the 
executable load module it creates for an Ada program. 

The IBM Ada/370 binder also includes run-time environment routines as part of 
its output. 


Using the IBM Ada/370 Binder 

To invoke the IBM Ad3/370 binder, compile an Ada main program using the MAfn 
option of the ADA command. The system invokes the binder. The binder can 
produce a link map describing the contents of the partially linked object module 
it generates. The link mao provides you with detailed information about the 
run-time memory locations of the various pieces of code that make up your 
program 

Another option to the ADA command. Bind, causes IBM Ada/370 to bypass the 
compilation step. This allows you to bind a compilation unit that you have 
previously compiled as a library unit as a main program. 

The Generate option of the ADA command takes .binder output and uses system 
utilities to generate a toad module. 

For more information on the HA In. Bind, and Generate options to the ADA 
command, see "The Compiler Options" on page 2-6. 

You must rebind your mam program when you recompile any Ada compilation 
units used in the program You do not have to rebind the program if you 
recompile non-Ada routines that your Ada program calls, but you stilt have to 
link the program again with the linkage editor or loader. 


6 Coovr'dnt i8U Coro. 1991 


3-1 




Invoking the Binder with Job Controi Language (JCL) 


Invoking the Binder with Job Control Language (JCL) 

This section describes how to invoke the binder as a batch job under MVS using 
Job Control Language (JCL). For information on how to invoke the compiler 
using JCL see "CoMpiling a Program with Job Control Language (JCL)" on 
page 2-3. 

The AOAB cataloged procedure invokes the IBM Ada/370 binder to bind an Ada 
main program that has been compiled using the IBM Ada/370 compiler. The 
output of the binder is an System/370 relocatable object data set. You can 
submit this data set to the linkage editor to generate an executable load module. 


/-s 

//MYPROC JOB '.MSGCUSS^D.HSCLEVEL-d.D.NOTIFY-USERl. 

// CUSS-A 

II* 

//• PURPOSE: TO RUN THE ADA BINDER 
II* 

//BIND EXEC PR0C>A0AB.UNIT>HELL0. 

// USCR>USER1 

^_ _ _ _ _ 

figure 3-1. Using the AOAB Cataloged Procedure to Invoke the Binder 

The preceding example shows a job, called MYPROG. which binds the Ada mam 
compilation unit HELLO. The user identifier USER) is specified with the USER 
variable. This vanable is used as a high-level qualifier to construct data-set 
names for the compiler, such as USERI AOA.UBRARY. This library is the defai K 
Ada library. Your job card will probably be different, because it depends on your 
site's conventions. 

As this job executes, the compiler creates relocatable object code in 
USERi OBJ(HELLO). This Object code was generated for the Ada main 
compilation unit called HELLO. 


3-2 


IBM Ada/370 





Invoking the Binder with Job Controi Language (JCL) 


A sample of the aoaS cataloged procedure appears in Figure 3-2. The exact 
location of AOAB may depend on your site's conventions. 


//AOAB 

// 

// 

//.. 

//* 

//**•••••’ 

//STEPl 

// 

//STEPLIB 
//CONOUT 
//AOALIB 
//A0A06J 
// 

// 

//AOAMAP 

// 

// 

//AOAOMAP 

// 

// 

//AOALIST 

// 

// 

//AOAUTl 

// 

// 

//A0AUT2 

// 

// 

//A0AUT3 

// 

7 / 

//A0AUT4 

// 

// 


PROC BNOPRH-' ‘.MEMSIZE-aigeiC, 
STPLie»'A0An0.L0A0LIB',MAXTIME-60, 

VI0-VI0,SYSDA-SYSALLOA,SYSOUT-•••,UNIT-' ' 


INVOKE THE BINDER 


EXEC PGM-£VGBINO,PARM«'iUNIT. ( &BN0PRM',REGION-&MEMSIZE, 
TIME-&MAXTIHE,0YNAHNBR-65,C0N0-(4,LT) 

00 0SN»iSTPLIB,0ISP-SHR 
00 SYSOUT-»SYSOUT,DCB-(LRECL-120,BLKSIZE*120) 

00 0SN>&USER..A0A.L1BRARY,DISP«SHR 
00 OSN-liUSER. .0BJ,DISP-(H0D,CATLG,CATLG), 

OCB-(RECFH-FB,LRECL-BD,BLKSIZE-3120,DS0RG»P0,BUFNO-4), 
SPACE-(8a,(16000,16000,20)),UNIT-4SYSDA 
00 OSN-iUSER..AOAMAP,0ISP-(M0D,CATLG,CATLG), 

OCB-(RECFH«VB,LRECL-1023,BLKSIZE-3120,OSORG-PO,BUFNO-2), 
S PAC E»(i32,(1000,2000,20)),UNIT-&SYSDA 
00 OSN-iUSER..OEBUGMAP,OISP-(MOO,CATLG,CATLG), 

OCB-(RECFH-VB,LRECL-1023,BLKSIZE-3120,DSORG-PO,BUFNO-2), 
SPACE-(i32,(1000,2000,20)),UNIT-iSYSDA 
00 OSN-iUSER..LISTING,DISP-(MOO,CATLG,CATLG), 

OCB-(RECFM-VBA,LRECL-259,BLKSIZE-3120,OSORG-PO,8UFN0-2), 
SPACE-(132,(500,2000,20)),UNIT-iSYSDA 
00 SP4CE-(132,(500,2000)), 

OCB-(RECFM-F0,LRECL-136,BLKSIZE-34O0,DSORC-OA,BUFNO-2), 
UNlT-iSYSOA 

00 SFACE-(132,(5O0,20O0)), 

OCB-(RECFM-VB,LRECL«136,BLKSIZE-3120,OSORG-PS,BUFNO-2), 
UNIT-iVIO 

00 SFACE-(132,(500,2000)), 

OCB-(RECFM-P8,LRECL-1028,BLKSIZE-2056,OSORG-OA,BUFNO-2), 
UNIT-iSYSDA 

00 SF4CE-{132,(500,2000)), 

OCB-(R ECFM-FB,LRECL-132,BLKSIZE-2640,OSORG-OA,BUFNO-2), 
UNIT-iSYSDA 


Figure 3-2. AOAB Cataloged Procedure 


Chapter 3. Binding and Linking an Ada Program 3-3 






Invoking tho Binder with Job Controi Language (JCL) 


Symbolic Variables for AOAB Cataloged Procedure 

The AOAB cataloged procedure includes several symbolic JCL substitution 

variables you can modify to specify the various options available. 

Symbolic 

Variable Description 

BNOPRM Specifies options to the binder in the farm field. A list of options 
you can specify in BNOPRM. along with a syntax diagram, appears 
in “Binder Options for Use with AOAB Cataloged Procedure' on 
page 3-5. 

MAXTIME Sets a maximum amount of time for the binder job step to run 

(using the TIME parameter on a JCL EXEC card). The default value 
is 60 minutes, but can be changed when the cataloged procedure 
is installed. 

MEMSIZE Specifies the amount of memory in which to run the binder job 
step (using the REGION option on a JCL EXEC card). The greater 
the memory, the better the binder's performance. The default 
value is 8196Kb. but this value may be changed when you install 
the cataloged procedure. 

STPLIB Indicates the data-set name of the partitioned data set that 

contains the binder module. MVSBINDE. The default is the load 
library>AOA.LOAOUB but you can change this default when you 
install the cataloged procedure. 

SYSOA Specifies the UNIT for permanent data set allocations. The 

default is SYSALLOA, but this name can be changed depending on 
your site's conventions. 

SYSOUT Identifies the output class for the binder output. The default is 
‘ “**. but this default can be changed, depending on your site's 

conventions. 

UNIT Indicates the compilation unit to be bound. You must specify this 

variable. 

USER Indicates the high-level qualifier level qualifier required to build 

data set names used by the binder. You must specify this 
variable. It is common to set it to your TSO logon identifier. 

VIO Specifies the UNIT for temporary data set allocations. The default 

is VIO. but this default can be changed depending on your site's 
conventions. 


3-4 IBM Ada/370 






Linking Programs that Call Nor.-Ada Routines 


Binder Options for Use with AOAB Cataloged Procedure 

This section defines the standard options for the BNOPRM symbolic substitution 
variable. This variable, found in STEP2 of the AOAB cataloged procedure, 
specines options to the binder in the PARM field. 

The binder options have the following syntax: 


♦ 

—options 




'— {-modlfiers- 




Table 3-1 lists the valid options, their modifiers, and defaults. Descriptions of 
the options appear on the pages shown. 


Table 3-1 Binder Options for JCL 

Option 

Default 

Punction 

Page 

ASM 

NOASM 

Assembly listing. 

2-9 

(NOGEN 


Suppress listing of expanded generics. 


1 NOSYS] 


Suppress listing of system-supplied generics. 


OONAMES 

old_name - new^name 


Specify the Data Description (00| names that identify 
(he data sets used by the compiler and binder. It 
must include at least one modifier. 

2-12 

DEBUG 

NOOEBUG 

Output information for debugging. 

2-13 

MAP 

NONAP i 

Produce linkage map during bimting. 

2-17 

trace 

NOTRACE 

Display diagnostic messages from the compiler Only 
for use in submitting problems to IBM. 

2-19 


Unking Programs that Call Non>Ada Routines 

Pragma Interface enables Ada compilation units to call non-Ada routines. The 
following sections show you how to compile and link programs that take 
advantage of this feature. 

User-written routines do not reside in the Ada library system. The only method 
available to connect non-Ada routines with the Ada routines that call them is to 
load them under VM/CMS or link-edit them under MVS A call to a non-Ada 
routine results in the generation of an external reference. This external 
reference is unresolved following normal ADA processing. You must take special 
steps in order to resolve virtual address constants to non-Ada routines. 


Chapter 3 Binding and Unking an Ada Program 3*5 

















Linking Programs that Call Non-Ada Routines 


Under VM/CMS 

The following table explains the data sets used in calling non-Ada routines 


Table 3-2. VMICMS Files Used in Calling Non-Ada Routines 

File 

Oeecription 

TEST ADA A 

File containing source for the main program. 

TEST 

Compilation unit name. 

TEST TEXT A 

File containing the object code of the Ada routines. 

ROUTINE TEXT A 

File containing the object code of the non-Ada routines 


The following example shows the correct procedure for compiling and linking 

AOA TEST (MAIN NORUN 
LOAD TEST ROUTINES 
GENMOO TEST 

The AOA command creates the object file TEST TEXT A The LOAD loads the 
object files TEST TEXT and ROUTINES TEXT into virtual storage and establishes the 
proper linkages between them. The order In the LOAD is important. The Ada 
module must go first. The GENMOO command uses the two object files to create 
a load module with the name TEST MODULE A. 

You may need to precede the commands in this example with a GLOBAL TXTUB 
command to resolve any missing external references from the LOAD command. 
The need for its use depends on how you load the non-Ada routines. For more 
information on the GLOBAL command, see the Virtual Machine/System Product 
CMS Command and Macro Peferanca. 


Under MVS 

Non-Ada routines do not reside in the Ada library system The only method 
available to connect non-Ada routines with the Ada routines that call them is to 
link-edit them A call to a non-Ada routine results in the generation of an 
external reference. This external reference is unresolved following normal ADA 
processing. You must take special steps in order to resolve virtual address 
constants to non-Ada routines. This section explains those steps. 

The following table explains the data sets used in calling non-Ada routines. 


Table 3-3 (Page 1 of 2). 

MVS Data Sets Used in Calling Non-Ada Routines 

Date Set 

Description 

gua////er.TBST.ADA 

Data set containing source for the main program. 
whose compilation unit name is Test. 

qualifier. NONADA.OBJ 

Data set containing the object code of the non-Ada 
routines. 

qualifier.QBJ 

Partitioned data set containing the object coda of the 

Ada routines. 

qualifier LOAD 

Partitioned data set containing the executable load 
modules; also called the "toad library." 


There are two methods for compiling and linking an Ada program with non-Ada 
routines. The first involves binding with NOGenerate. then linking the foreign 


3 ^ 


IBM Ada/370 





Linking Programs that Call Non*Ada Routinas 


language code manually with the linkage editor. The second involves placing 
the code in a partitioned data set (POS) such that the object goes into the obiect 
library created by the Bino option. The following two examples show how to use 
these methods. 

Using the Linkage Editor 

First compile the main program, using the MOGenerate option. 

EX 'A0A.CLIST(A0A)‘ 'TEST.ADA (MAIN NOGENERATE' 

This member contains one or more unresolved references to non-Ada code. The 
following call to the linkage editor resolves the unresolved external references 
associated with those calls. 

LINK ( •USER 1. NONAOA .08J',‘USER1,08J( TEST)’ ) 

The TEST load library member is now fully linked and ready to execute. 

Using a Partitioned Data Set 

If you choose to use a partitioned data set. use the following steps; 

1 Place the foreign language routine's object code into a partitioned data set. 

2. Issue the TSO ALLOC command for a DO name of SYSUB and then associate 
this with the POS containing the non-Ada object code. 

ALLOC 00(SYSLI8) 0A('USERl.NONAOA.OBJ') SHR 

3. Bind the main program (or compile and bind) without using the NOGenerate 
option. The LINK within ADA will refer to the SYSUB allocation as it attempts 
to resolve references to the non-Ada mutines. 

The TEST load library member is now fully linked to be executed. 

For more information on LINK, see the LINK command in the IBM publication. 
MVS/Extended Architecture TSO Extensioris TSO Command Language Reference. 


Chapter 3. Binding and Linking an Ada Program 3*7 





Linking Program* that Call Non-Ada Routines 


34 IBM Ada/370 





APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this Appendix are to compiler documentation and not to this 
report. Implementation-specific portions of the package STANDARD, which 
are not a part of Appendix F, are: 


package STANDARD is 

type INTEGER is range -2 147 483 648 .. 2_147_483_647; 
type SHORT_INTEGER is range -32768 .. 32_767; 

type FLOAT is digits 6 range -7.23701E+75 .. 7.23701E+75; 
type LONG FLOAT is digits 15 range -7.23700557733225E+75 

.. 7.23700557733225E+75; 

type DURATION is delta 2#1.0#E-14 range -86400.0 .. 86400.0; 
end STANDARD; 


C-1 







ATTACHMENT A 


APPENDIX F 

OF THE LANGUAGE REFERENCE MANUAL 

The Ada language definition allows for certain target dependencies in a controlled manner. 
This section, called Appendix F as prescribed in the LRM, describes implementation-dependent 
characteristics of the IBM Ada/370, Version 1.1.0 running under CMS or MVS. 

1. Implementation-Defined Pragmas 

PRAGMA INTERFACE( Assembly, <subroutine_name> ); 

PRAGMA INTERFACE( Assembler, <subroutine_name> ); 

PRAGMA INTERFACE( Fortran, <subroutine_name> ); 

PRAGMA SUPPRESS ALL; 

to cause Pragma SUPPRESS to be invoked simultaneously for all the following 
conditionjnames: accessjcheck, discriminantjcheck, index check, length check, 
division_check, elaborationjcheck, and storagejcbeck. 

PRAGMA NO JUPPRESS ( <identifier> ); 

to prevent the suppression of checks within a particular scope. Particularly useful when a 
section of code that relies upon predefined checks executes correctly, but, for performance 
reasons, the suppression of checks in the rest of the code is needed. 

PRAG.MA COMMENT (string Jiteral); 

embeds string_literal into object code. 

PRAGMA IMAGED (enumeration_type, <immediate>| <deferred>); 

generates a table of images for the enumeration type, deferred causes the table to be 
generated only if the enumeration type is used in a compilation unit. 

PRAG.MA I.NTERFACE_INF0RM\TI0.N 

(<name>, 

<link_name>. 

<mechanism>, 

< parameters >, 

<clobbered_regs>); 

when used in association with pragma INTERFACE, will provide access to any routine 
whose name can be specified by an Ada string literal. 

PRAGNU PRESERVE LAYOUT ( ON = - • Record_Type_Name> ); 

forces the compiler to maintain the Ada source order of components of a given record type, 
thereby preventing the compiler from performing this record layout optimization. 

^PRAGMA INLINE (procedure_name); 

to specify a subprogram body which should be expanded inline at each call whenever 
possible. 

••PRAGMA OS_TASK (priority); 



to specify the relative urgency of each MVS task created. 

**PRAGMA ALLOCATION DATA 

(<accessjtype>, 

< residencejmodo, 

< allocation_duration >, 

<subpool_number >, 

<discrete user data>); 

to associate MVS virtual storage attributes with an Ada access type. 

*Note that PRAGMA INLINE is effective only when the optimizing option is selected at 
compile time. If optimizing is not selected the pragma is ignored and a warning is issued. 

••Note that PRAGMA OS TASK and PRAGMA ALLOCATION_DATA are effective only 
when compiling for an MVS target. Both pragmas require that an MVS runtime be present. 


2. Implementation-Defined Attributes 

2.1. Integer Type Attributes 

Extended_lmage ( Item, <Width>, <Base>, <Based>, <Space_IF_Po8itive> ); 

to return the image associated with Item as defined in TextJ[O.Integer__IO. The Text_IO 
definition states that the value of Item is an integer literal with no underlines, no exponent, 
no leading zeroes (but a single zero for the zero value), and a minus sign if negative. 

Extended_Value (Item); 

to return the value associated with Item as dehned in Text_IO.Integer__IO. The Text_IO 
definition states that given a string, it reads an integer value from the beginning of the 
string. The value returned corresponds to the sequence input. 

Extended_Width ( <Base>, <Based>, <Space_IF_Positive> ); 
to return the width for a subtype specified. 

2.2. Enumeration Type Attributes 
Extended_Image ( Item, <Width>, <Uppercase>); 

to return the image associated with Item as defined in Text_IO.Enumeration_IO. The 
Text 10 definition states that given an enumeration literal, it will output the value of the 
enumeration literal (either an identifier or a char£u:ter literal). The character case 
parameter is ignored for character literals. 

Extended_Value ( Item ); 

to return the image associated with Item as defined in Text_10.Enumeration_IO. The 
Text_IO definition states that it reads an enumeration value from the beginning of the given 
string and returns the value of the enumeration literal that corresponds to the sequence 
input. 

Extended _Width; 

to return the width for a specified subtype. 



2.3. Floating Point Attributes 

£xtended_Iniage ( Item, <Fore>, <Aft>, <Exp>, <Base>, <Ba8ed> ); 

to return the image associated with Item as defined in Text_IO.Float_IO. The Text_IO 
definition states that it outputs the value of the parameter Item as a decimal literal with 
the format defined by the other parameters. If the value is negative, a minus sign is 
included in the integer part of the value of Item. If Exp is 0, the integer part of the output 
has as many digits as are needed to represent the integer part of the value of Item or is zero 
if the value of Item has no integer part. 

Extended_Value ( Item ); 

to return the value associated with Item as defined in Text_IO.Float_IO. The Text_IO 
definition states that it skips any leading zeroes, then reads a plus or minus sign if present, 
then reads the string according to the syntax of a real literal. The return value is that 
which corresponds to the sequence input. 

Extended_Digits ( <Base> ); 

to return the number of digits using base in the mantissa of model numbers of the specified 
subtype. 

2.4. Fixed Point Attributes 

Extended_Image ( Item, <Fore>, <Aft>, <Exp>, <Base>, <Based> ); 

to return the image associated with Item as defined in Text_IO.Fixed_IO. The TextJIO 
definition states that it outputs the value of the parameter Item as a decimal literal with 
the format defined by the other parameters. If the value is negative, a minus sign is 
included in the integer part of the value of Item. If Exp is 0, the integer part of the output 
has as many digits as are needed to represent the integer part of the value of Item or is zero 
if the value of Item has no integer part. 

Extended_Value ( Image ); 

to return the value associated with Item as defined in Text_IO.Fixed_IO. The Text_10 
definition states that it skips any leading zeroes, reads a plus or minus sign if present, then 
reads the string according to the syntax of a real literal. The return value is that which 
corresponds to the sequence input. 

Extended_Fore ( <Base>, <Based> ); 

to return the minimum number of characters required for the integer part of the based 
representation specified. 

Extended .\ft ( <Base>, <Based> ); 

to return the minimum number of characters required for the fractional part of the based 
representation specified. 

3. Package SYSTEM 

The current specification of package SYSTEM is provided below. 


With Unchecked_Conversion; 
P.\CKAGE System IS 



- CUSTOMIZABLE VALUES 

TYPE Name IS (MC68000, ANUYK44, IBM370); 

System^Name : CONSTANT name := IBM370; 

Memory_Si*e : CONSTANT := (2 ** 24)-l; 

Tick : CONSTANT := 1.0 / (10 ** 6); 


- NON-CUSTOMIZABLE, IMPLEMENTATION-DEPENDENT VALUES 


Storage Unit : CONSTANT ;*= 8; 

Min lnt' : CONSTANT := -(2 ** 31); 

Max Int : CONSTANT := (2 ** 31) - 1; 

Max'Digits : CONSTANT :* 15; 

Max Mantissa : CONSTANT 31; 

Fine~DeJta : CONSTANT :« 1.0 / (2 ** Max Mantissa ); 

Subtype Priority IS Integer RANGE 0 .. 255: 


- ADDRESS TYPE SUPPORT 


type Memory is private; 
type Address is access Memory; 

Nul]_Address i Constant Address nuU: 

type Address_Value is RANGE -(2’'*31) .. (2**31)-1; 

Hex_80000000 : constant Address_V'alue := - 16#80000000#: 
Hex_90000000 : constant Address_Value := - 16#70000000#; 
Hex_AOOOOOOO : constant Address_Value ;= - 16#60000000^; 
Hex_BOOOOOOO : constant Address_Value := - 16#50000000#; 
Hcx_C0000000 : constant Address_Value := - 16#40000000#; 
Hex_DOOOOOOO : constant Address_Value := - 16#30000000#; 
Hex_E0000000 : constant Address_Value - 16#20000000#; 
Hex^FOOOOOOO : constant Address_Value := - 16#10000000#; 

function Location is new Unchecked_Conversion (Address Value, Address); 

function Label (Name: String) return Address: 
pragma Interface (META, Label); 


























- CALL SUPPORT 


type Subprogram_yalue IS 
record 

Proc_eddr : Address; 

ParentjTrame : Address: 
end record; 

Max Object_Size ; CONSTANT :*= Max_lnt; 

Max_RecordjCount : CONSTANT :** Max_Int; 

Max_Text_Io_Count : CONSTANT MaxJbt-1; 

Max_Text_Io_Field : CONSTANT := 1000; 

private 

type Memory is 
record 
null; 

end record; 
end SYSTEM; 

4. Representation Clauses 

This implementation supports address, length, enumeration, and record representation 
clauses with the following exceptions: 

Address clauses are not supported for package, for entry, for tasktype, for 
subprograms. 

Enumeration.clauses are not supported for boolean representation clauses. 

The size in bits of representation specified records is rounded up to the next highest multiple 
of 8, meaning that the object of a representation specified record with 25 bits will actually occupy 
32 bits. 

Non-supported clauses are rejected at compile time. 

5. Implementation-Generated Names 

There are no implementation-generated names denoting implementation-dependent 
components. Names generated by the compiler shall not interfere with programmer-defined 
names. 

6. Address Clause Expression Interpretation 

Expressions that appear in Address clauses are interpreted as virtual memory addresses. 

7. Unchecked Conversion Restrictions 

Unchecked_Conversion u allowed except when the target data subtype is an unconstrained 
array or record type. If the size of the source and target are static and equal, the compiler will 
perform a bitwise copy of data from the source object to the target object. 




Where the siies of source and target differ, the following rules will apply: 

• ff the size of the source is greater than the size of the target, the high address bits will 
be truncated in the conversion. 

• If the size of the source is less than the size of the target, the source will be moved into 
- the low address bits of the target. 

The compiler will issue a warning when UncheckedjConversion is instantiated with unequal 
sizes for source and target subtype. UncheckedjConversion between objects of different or non* 
static sizes will usually produce less efficient code and should be avoided, if possible. 

8. Implementation-Dependent Charact^istics of the I/O Packages 

• Sequential_IO, Direct_IO, and Text_IO are supported. 

• Low_Level__IO is not supported. 

• Unconstrained array types and unconstruned types with discriminants may not be 
instantiated for I/O. 

• File names follow the conventions and restrictions of the target operating system. 

• In Text_IO, the type Field is defined as follows: subtype Field is integer range 

0 .. 1000 ; ” 

• In Text 10, the type Count is defined as follows: type Count is range 
0..2 147 483 646; 



