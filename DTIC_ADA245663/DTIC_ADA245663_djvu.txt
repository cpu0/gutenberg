PuMfipoftingbui 
. fltididf tnd imAm'' 

' HMidQUMiMt Sifyl"'' 

;MiniQMninlindEw^^ cwkm. 


.Y (LeMve Blank) 


NPAGE 


Fom Approved 
0PM No. 0704-0188 


HTa?JTiKr:Tilrt:i 


t, Mudtog tw ikM lor rr^witng katiuctiocN, MireNng Mhtfng du Murc«$ gathMlng ind maMaining tw dn 
• or «nir othor MpM of dik ooloctiun ol Monration. Mudkig luggMtiom for rodudng till burdon, to WMNnglon 
IglMty, SulM 1204, Aidngmi, VA 222K-4X& ind to dM Odlco of MonMdon ond RogUiMiy Aflilft, Oflieo of 


3. REPORT TYPE AND DATES COVERED 

Final: 25 Apr 1991 to 01 Jun 1993 





Intermetrics, Inc., AFCAS1750A/XMEM Ada Compiler, Version 1.0, DEC 
VAXstation 3100 (Host) to Air Force RAID MIL-ST0-1750A Simulator (Target), 
910425W1.11143 




Wright-Patterson AFB, Dayton, OH 
USA 




Ada Validation Facility, Language Control Facility ASD/SCEL 
Bldg. 676, Rm 135 

Wright-Patterson AFB, Dayton, OH 45433 





Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm 3E114 
Washington, D.C. 20301-3081 


S)ANDADORESS(ES) 


r:1fd4:TiSI:MJrcTO:rcTTJIW.^dWJ« 


Ml 

REPORT NUMBER 

AVF-VSR-458.1191 


10. SPONSORINQAHONITORING AQENC 
REPORT NUMBER 


DTI 









AVAILABILI 

Approved for public release; distribution unlimited 





Intermetrics, Inc., AFCAS 1750A/XMEM Ada Compiler, Version 1.0, DEC VAXstation 3100, VMS Version 5.3 (Host) to Air 
Force RAID MIL-STD-1750A Simulator ainning on VMS Version 5.3 (Target), ACVC 1.11. 


92-02719 


, 06 3 



14. SUBJECT TERMS 

Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability. Val. Testing. Ada Val. Office, Ada Val. Facility. ANSI/MIL-STD-1815A, AJPO. 


17. SECURITY CLASSIFICATION 
OF REPORT 

UNCLASSIFIED 


13. SECURITY CLASSIFICATION 19. SECURITY CLASSIFICATION 

OF ABSTRACT 

UNCLASSIFED UNCUSSIFIED 


15. NUMBER OF PAGES 


16. PRICE CODE 


20. LIMITATION OF ABSTRACT 


NSN 7540-01-280-550 


Standard Form 298, (Rev 2-89) 










































AVF Control Number: AVF_VSR 458.1191 

16-Novemberr-1991 

90-11-16-INT 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 910425W1.11143 
Intecmetrics, Inc. 

AFCAS 1750A/XMEM Ada Conpiler, Version 1.0 
DEC VAXstation 3100 «> Air Force RAID MIL-STD-1750A Simulator 


Prepared By: 

Ada Validation Facility 
ASD/SCEL 

Wright Patterson AFB OH 45433-6503 




Certificate Information 


fhefolloving Ada implementation was tested and determined to pass ACVC 
Testing was completed on 25 April, 1991. 

Compiler Name and Version: AFCAS 1750A/XMEM Ada Compiler, 

Version 1.0 

Host Computer System: DEC VAXstation 3100, VMS Version 5.3 

target Computer System: Air Force RAID MIL-STD-1750A simulator 

running on VMS Version 5.3 

Customer Agreement Number: 90-ll*-16-INT 

See Section 3.1 for any additional information about the testing 
Environment. 

As a result of this validation effort. Validation Certificate 
9i0425Vl.11143 is awarded to Intermetrics, Inc. This certificate expires 
bn 1 June 1993. 

This report has been reviewed and is approved. 



Steven F. Wilson 
Technical Director 
ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 



Institute for Defense Analyses 
Alexandria VA 22311 



Dr. John Solomond, Director 


Department of Defense 
Washington DC 20301 




OO 












DECLARATION OF CONFORMANCE 


Gus-tpiner: Intermetrics, Inc., Cambridge, MA 

Ada Validation Facility: ASD/SCEL Wright-Patterson AFB, OH 45433-6503 
A'GVG Version: 1.11 

Ada Implementation 

' Compiler Name and Version: AFCAS 1750A/XMEM Ada Compiler, 

Version 1.0 

Host Computer System: DEC VAXstation 3100, VMS Version 5.3 
Target Computer System: Air Force RAID MIL-STD-1750A simulator 

running on VMS 


Customer's Declaration 

■li the undersigned, representing Intermetrics, Inc., declare that 
Ihtermetrics, Inc. has no knowledge of deliberate deviations from the 
Ada Language Standard ANSI/MIL-STD-1815A in the implementation listed 
in this declaration. I declare that the U.S. Air Force is the owner 
of. the above implementation and the certificates shall be awarded 
only in its name, 

■ _ Date: f/ZS Ml 

Dennis D. Struble, 

Deputy General Manager, Development Systems Group, 

Intermetrics, Inc. 


++++++++++++++++++ CO SIGNER SIGNATURE BLOCK ++++++++++++++++++++ 



Date: 


fseph P. Hall 
Deputy Director, Projects Division 
Deputy for Avionics Control 

Aeronautical Systems Division - Acquisition Logistics Division 
Wright-Patterson Air Force Base, OH 






TABLE OF CC»JTENTS 


GHAPTTO 1 INTOODtJCriON 

i.i‘ USE OF THIS VALIDATION SUMMARY REPORT.1-1 

l;2 REFERENCES.1-2 

1.3 AGVC TEST CLOSES.1-2 

1,4. pEFINiTldN OF TERMS.1-3 

:qHAETER,.2 IMPLEMENTATION DEPENDENCIES 

2.1 WiTHDRMflN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST MODIFICATIONS . 2-4 

aiM>TER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 















CHAPTER 1 


INTRODUCTION 


The? ^ ii^leinehtatioh described above was tested according to the Ada 
Validation Procedures [Pro90] against the Ada Standard [Ada83] using the 
current. i^ Coiipiler Validation capability (ACVC), This Validation Summary 
■iReport (,^R) gives an account of the testing of this Ada implementation. 
'For/^y technical terms used in this report, the reader is referred to 
:t'Pitp9pl • A detailed description of the ACVC may be found in the current 
, ;A^ User' s Guide *[UG89 ]. 


i.i USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report, 
ift the united States, this is provided in accordance with the "Freedom of 
■Information Act" (5 U.S.C. #552). The results of this validation apply 
only to ^e conpiters, operating systems, and conpiler versions identified 
in ^is report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and conplete, or that the subject inplementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from; 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 


Questions regarding this report or the validation test results should be 
directed to the AVF vhich performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1-1 












ft’ 





y,. 


yINpjDUCTION 
liil REFEREIOS 

jAda83:>) Reference Manual ?or tEe aoE Programming Language, 
y ANSiMt^STD-1815A, February 1983 and ISO 8652-1987, 


:tpr,o§0,j.,iyia Coiqpiler Validation Procedures, Version 2.1, Ada Joint Program. 
Office, Au^st 1990, 


|yG89] ^a Conpiler Validation Capability User's Guide, 21 June 1989. 


1.3 AGVC TEST CLASSES 

iCoj^iiamce of Ada inpleroentations is tested by means of the ACVC. The ACVC 
cphtaihs a collection of test programs structured into six test classes: 
kr B» Ar Df E, and L. The first letter of a test name identifies the class 
to A^ich it-belongs. Class A, C, 0, and E tests are executable, class B 
^d class L tests are expected to produce errors at compile time and link 
time, respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK__FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a conpiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code vdiich must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
inplementation-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and 
in^jlementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 









INTRODUCTION 


^pp each Ada iiipleTOntation, a customized test suite is produced by the 

This: cu^t^iatipn consists of making the modifications described in 
:|h4 .ptecj^ing, withdrawn tests (see section 2.1) and, 

;^ssibly sb^ iMpplic^le tests (see Section 2.2 and [UG89]). 

In order to pass ah ACVC an Ada implementation must process each test of 
i^e-^stpndzed test suite, according to the Ada Standard. 


1i4 DEFINITION OF TERMS 


^ Compiler The software and any needed hardware that have to be added 
to a given host and target conpiter system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

^ Cpnpiler The meana for testing conqpliance of Ada implementations, 
Validation consisting of the test suite, the support programs, the ACVC 
Cap^iiity user's guide and the tenplate for the validation summary 

i^t). report. 

Ada^ An Ada conpiler with its host conpiter system and its 

Implementation target con^ter system. 

^a Joint The part of the certification body which provides policy and 
'Program guidance for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification body which carries out the 

Validation. procedures required to establish the compliance of an Ada 
Facility (AVF) inplementation. 

Ada The part of the certification body that provides technical 

Validation guid^ce for operations of the Ada certification system. 

Organization 
(AVO) 

Conpliance of The ability of the inplementation to pass an ACVC version, 
an Ada 

Inplementation 

Computer A functional unit, consisting of one or more computers and 

System associated software, that uses common storage for all or 

part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
conputer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 









Gpnfbjmty E\U.fiiintent a product, process or service of all 

y requirements specified. 

Gustpraer . An individual pr cor^rate entity who enters into an 

f agreement with an JWF ^ich specifies the terms and 

cphditidns for AVF services (of any kind) to be performed, 

;.I^ciai.ati6n of A forml statement from a customer assuring that conformity 
e6nfpi.:ftince is realized or attainable on the Ada in^jlementation for 
vrtiich validation status is realized. 


Hpst Computer A conputer system vdiere Ada source programs are transformed 
System into execute&le form. 

inapplicable A test that contains one or more test objectives found to be 
test irrelevant for the given Ada implementation. 

ISO: International Organization for standardization. 

^fating Software that controls the execution of programs and that 

System provides services such as resource allocation, scheduling, 

input/putput control, and data management. Usually, 
operating systems are predominantly software, but partial or 
ccii^lete hardware in^lementations are possible. 


Target A computer system vrtiere the executable form of Ada programs 

Cpii^ter are executed. 

System 


Validated Ada The con^jiler of a validated Ada inplementation. 
Coii^iler 


Validated Ada An Ada inpleroentation that has been validated successfully 
In 5 )lementation either by AVF testing or by registration [Pro90]. 


Validation 


Withdrawn 

test 


The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this in^lementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails tc meet it; •:esr. obj6Cii:i''e, oi 
contains erroneous or illegal use of ;ne Ada programming 
language. 


1-4 







CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


4:.:i WITHDRAWN TESTS 

fqUowing tests have been withdravm by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for. this list of withdrawn tests is 14 March 1991. 


E28005C 

B28006C 

C34006D 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025b 

C83026A 

B83026B 

C83041A 

B85001L 

C86001F 

C94021A 

C97116X 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BO1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

Cb4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE31ieA 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE360..' 

CE3812A 

CE3814A 

CE3902B 





2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant 
for a given Ada inpleraentation. Reasons for a test's inapplicability may 
be supported by documents issued by the ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
inplementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 








IMPyi-SlNT^TICSI DEPENDENCIES 


The. following 285 tests have floating-point type declarations requiring 
mie digits than sySTEM.MAX_DIGITS; 


G24113F..Y (20 tests) 
C35706P..Y (20 tests) 
C35708F..Y (20 tests) 
C45241F..Y (20 tests) 
C45421F,..Y (20 tests) 
C45524F..Z (21 tests) 
C45641F..Y (20 tests) 


C35705F..Y (20 tests) 
C35707F..Y (20 tests) 
C35802F..Z (21 tests) 
C45321F..Y (20 tests) 
C45521F..Z (21 tests) 
C45621F..Z (21 tests) 
C46012F..Z (21 tests) 


The following 21 tests checlt for the predefined type SHORT_INTEGER; for 
this implementation, there is no such type: 


C35404B 

G45412B 

C45611B 

B52004E 

CD7101E 


B36105C 

C45502B 

C45613B 

C55B07B 


C45231B 

C45503B 

C45614B 

B55B09D 


C45304B 

C45504B 

C45631B 

B86001V 


C45411B 

C45504E 

C45632B 

C86006D 


The following 20 tests checlc for the predefined type LONG INTEGER; for 
this inplementation, there is no such type; 


C35404C 

C45502C 

C45613C 

C55B07A 


C45231C 

C45503C 

C45614C 

B55B09C 


C45304C 

C45504C 

C45631C 

B86001W 


C45411C 

C45504F 

C45632C 

C86006C 


C45412C 

C45611C 

B52004D 

CD7101F 


C35404D, C45231D, B86001X, C86006E, and CD7101G checlc for a predefined 
integer type with a name other than INTEGER, LONG__INTEGER, or 
SHORT_INTEGER; for this iii 5 )lementation, there is no such type. 

C35713B, C45423B, B86001T, and C86006H check for the predefined type 
SHORT_FLOAT; for this inpleraentation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with a 
name other than FLOAT, LONG_FLOAT, or SHORT_FLOAT; for this 
in^lementation, there is no such type. 

C45423A, C45523A, and C45622A check that the proper exception is raised 
if MACHINEjGfVERFLCWS is TRUE and the results of various floating-point 
operations lie outside the range of the base type; for this 
implementation, MACHINEjOVERFLOWS is FALSE. 

C45531M..P a.d C45532M..P (8 tests) check fixed-point operations for 
types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for this 
implementation, MAX_MANTISSA is less than 47. 

C46013B, C-/j 03.\B, C46033B, and C46034B contain length clauses that 
specify valuefor SMALL that are not powers of two or five; this 
implementation does not support such values for SMALL. 


2-2 








IMPLEMENTATION DEPENDENCIES 


,D55Ad3E'i .H C4 tests) use 31 levels of loop nesting vrftiich exceeds the 
da^city of the cpnpiler. 

;'tb56dpiB uses; 65 levels of block nesting vdiich exceeds the capacity of 
;^e toilet. 

J^4005G uses. 17 levels of recursive procedure calls nesting; this 
exceeds the ca^city of the compiler. 

^B860plY uses the name of a predefined fixed-point type other than type 
bURATIOI; for tois ii^^ there is no such type. 

CAiZobPc and CA2009F check Aether a generic unit can be instantiated 
before the separate compilation of its iDody (and any of its subunits); 
this inpiementation requires that the body and subunits of a generic 
unit be in the same conpilDtion as the specification if instantiations 
precede them. (See section 2.3.) 

CD1009C checks v^ether a length clause can specify a non-default size 
for a floating-point type. The representation vdiich this implementation 
uses for floating point types is the smallest available; therefore, vdien 
this test attenqpts to use a representation of other than 32 or 64 bits, 
the length clause is rejected. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length clauses 
to specify non-default sizes for access types; this implementation does 
not support such sizes. 

BP8001A, BD8003A, B08004A..B (2 tests), and AD8011A use machine code 
insertions; this iiqplementation provides no package MACHINE_CODE. 

AE2101C uses instantiations of package SE(3UENTIAL 10 with unconstrained 
array types and record types with discriminants without defaults. These 
instantiations are rejected by this compiler. 

AE2101H uses instantiations of package DIRECT^IO with unconstrained 
array types and record types with discriminants without defaults. These 
instantiations are rejected by this compiler. 

The following 264 tests check for sequential, text, and direct access 
files: 


CE2102A..C 

(3) 

CE2102G..H 

(2) 

CE2102K 


CE2102N..Y 

(12) 

CE2103C..D 

(2) 

CE2104A..D 

(4) 

CE2105A..B 

(2) 

CE2106A.,B 

(2) 

CE2107A, .H 

(8) 

CE2107L 


CE2108A..H 

(8) 

CE2109A..C 

(3) 

CE2110A. .D 

(4) 

CE2111A..I 

(9) 

CE2115A..B 

(2) 

CE2120A..B 

(2) 

CE2201A..C 

(3) 

EE2201D..E 

(2) 

CE2201F..N (9) 

CE2203A 


CE2204A. .D 

(4) 

CE2205A 


CE2206A 


CE2208B 


CE2401A..C 

(3) 

EE2401D 


CE2401E..F 

(2) 

EE2401G 


CE2401H..L 

(5) 

CE2403A 


CE2404A..B 

(2) 

CE2405B 


CE2406A 


CE2407A. .B 

(2) 

CE2408A..B 

(2) 

CE2409A. .B 

(2) 

CE2410A..B 

(2) 

CE2411A 


CE3102A..C 

(3) 

CE3102F..H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A..C 

(3) 

CE3106A..B 

(2) 


2-3 










V. i»|t|MENTATION DEPENDENCIES 


CE3i07B. 


CE3108A..B 

(2) 

CE3109A 


CE3110A 


CEBll-lA. .B 

(2) 

CE311iD,.E 

(2) 

CE3112A. .D 

(4) 

CE3114A..B 

(2) 

CE3115A 


CE3119A 


EE3203A 


EE3204A 


CE3207A 


CE3208A 


CE3301A 


EE3301B 


CE33()2A 


CE3304A 


CE3305A 


CE3401A 


GE3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A. .C 

(3) 

CE3403E..F 

(2) 

CE3404B..D 

(3) 

CE3405A 


EE3405B 


CE3405C..D 

(2) 

CE3406A..D 

(4) 

CE3407A..C 

(3) 

CE3408A..C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE34iOC..E 

(3) 

EE3410F 


CE3411A 


CE3411C 


CE34i2A 


EE3412C 


CE3413A..C 

(3) 

CE3414A 


CE3602A..D 

(4) 

CE3603A 


CE3604A..B 

(2) 

CE3605A..E 

(5) 

CE3606A..B 

(2) 

CE3704A..F 

(6) 

CE3704M..0 

(3) 

CE3705A..E 

(5) 

CE3706D 


CE3706F..G 

(2) 

CE3804A..P 

(16) 

CE3805A..B 

(2) 

CE3806A. .B 

(2) 

CE3806D..E 

(2) 

CE3806G..H 

(2) 

CE3904A..B 

(2) 

CE3905A. .C 

(3) 

CE3905L 


CE3906A..C 

(3) 

CE3906E..F 

(2) 


CE2103A, CE2103B> and CE3107A use an illegal file name in an attenpt to 
create a file and expect NAME_ERi^ll to be raised; this implementation 
does not support external files and so raises USE ERROR. (See section 
2.3.) 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 9 tests. 

The following tests were split into two or more tests because this 
in^lementation did not reporc the violations of the Ada Standard in the way 
expected by the original tests. 

BAIIOIC BC3205D 


C32107A was graded passed by Evaluation Modification as directed by the 
AVO. The test was run using a task size of 16#400 and a stack size of 
16#1200. The other tests were run using a task size of 16#400 and a stack 
size of 16#1000. 

C34003A was graded passed by test modification as directed by the AVO. 

This test checks operations on derived floating-point types and uses a 
con^jlex expression vdiose intermediate results overflow in this 
implementation. For this in¥>lementation, T'MACHINE RADIX * 2, 
T'MACHINE_EMAX -127, arid T'MACHINE_EMIN —128. With these values, the two 
expressions at lines 219 and 226 equate to the calculation 2**126; but this 
calculation will overflow on the 1750A as a consequence of the way 
multiplication occurs (even though the result can be represented), and 
NUMERIC_ERROR is raised. Thus, lines 219 and 225 were modified as shown 
below: 


2-4 











IMPLEMENTATION DEPENDENCIES 


[219] 

from; (1.0 * T'MACHINE_RADIX) ** (T'MACHINE_EMAX -1) / 2 < 

to; ( (1.0 * T'MACHINE_RADIX) ** (T'^a^CHINE_EMAX -2) + 

(1.0 * T'MACH1NE_RADIX) ** (T'MACHINE_EMAX -2) ) / 2 < 

[225] 

from; (1.0 * T'MACHINE_RADIX) ** (T'MACHINF_EMIN + 2) * 

to; ( (1.0 * T'MACHINEJRADIX) ** (T^MACHINE_EMIN + 3) * 

(1.0 * T'MACHINE RADIX) ** (-1) ) * 


CA2009C and CA2009F were graded inapplicable by Evaluation Modification as 
directed by the AVO. These tests contain instantiations of a generic unit 
prior to the separate conpilation of that unit's body; as allowed by 
AI-257, this implementation requires that the bodies of a generic unit be 
in the same conpilation if instantiations of that unit precede the bodies. 
The instantiations were rejected at compile time. 


CE2103A| CE2103B^ and CE3107A were graded inapplicable by Evaluation 
Modification as directed by the AVO. The tests abort with an unhandled 
exception \dien USE ERROR is raised on the attempt to create an external 
file. This is acceptable behavior because this inplementation does not 
support external files (cf. AI-00332). 


2-5 







CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact for sales or technical information about this Ada 
implementation system, see: 

Mike Ryer 
Intermetrics, Inc. 

733 Concord Ave. 

Cambridge MA 02138 


Testing of this Ada implementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming 
Language Standard, v^ether the test is applicable or inapplicable; 
otherwise, the Ada Implementation fails the ACVC [Pro90]. 


For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 


3-1 







’ ‘Pi^SSiNG INFORMATION 


a) Total Number of i^plicable Tests 3436 

b) total Number of Wi^drawn Tests 93 

c) Processed Inappliciible Tests 92 

d) Non-Processed I/O Tests 264 

e) Noh-Processed Floating-Point 

Precision Tests 285 

f) Total Number of Inapplicable Tests 641 


g) Total Number of Tests for ACVC 1.11 4170 


The above number of I/O tests were not processed because this 
inplementation does not support a file system. The above number of 
floating-point tests were not processed because they used floating-point 
precision exceeding that supported by the implementation. When this 
coii^iler was tested, the tests listed in section 2.1 had been withdrawn 
because of test errors. 


3.3 TEST EXECUTION 


A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the validation team for processing. The contents of the 
the magnetic tape were loaded directly onto the host computer. 


The tests were compiled and linked on the host conputer system, as 
appropriate. The executable images were run on the host machine using the 
target simulator. Results were transferred via RSCS to a Sun 4 for 
printing. 


Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a complete listing of 
the processing options for this inplementation. It also indicates the 
default options. Ihe options invoked explicitly for validation testing 
during this test were: 

Option I Switch Effect 


PTR_FILE Ada program library name 


Test output, compiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 


3-2 





APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meeunihg and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
vhlUes that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string”aggregates, vdiere "V" represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 255 

$BIG_ID1 (1..V-1 -> 'A', V»> '1') 

$BIG_ID2 (1..V-1 -> 'A', V -> '2') 

$BIG ID3 (1..V/2 »> 'h') & '3' & 

(1..V-1-V/2 -> 'AM 

$BIG_ID4 {1..V/2 -> 'AM & '4' & 

(1..V-1-V/2 -> 'A') 

$BIG_INT__LIT (1..V-3 -> '0') & "298" 

$BIG_REAL__LIT (1..V-5 -> '0') & "690.0" 

$BIG_STRING1 & (1..V/2 -> 'A') & '"' 

$BIG_STRING2 & (1..V-1-V/2 »> 'A') & '1' & '"' 

$BLANKS (1..V-20 => ' ') 

$MAX_LEN_INT BASED LITERAL 

"2;" & (1..V-5 => '0') & "11:" 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => '0') & "F.E:" 


A-1 






V ' ^ V PARAMETERS 

|:: /' $MAX_STRINGM:.ITERAL & (l..V-2-> 'AM & 

i;;:.: The'following table lists all of the other macro parameters and their 

f,,, . 'respective values; 


Macro Parameter 

Macro Value 

$ACC_SIZE 

16 

$ALIGNNENT 

1 

$COUNT__LAST 

32767 

$DEFAULT_MEM__SIZE 

2097152 

$DEFAULT_STOR_UNIT 

16 

$DEFAULT_SYS_NAME 

MIL_STD_1750A 

$DELTA_DOC 

2.0**(-31) 

$ENTRyjVDDRESS 

SYSTEM.MAKE_ADDRESS(0,16#40#) 

$ENTRy_ADDRESSl 

SYSTEM.MAKE_ADDRESS(0,16#80#) 

$ENTRY_ADDRESS2 

SYSTEM.MAKE_ADDRESS(0,16#100#) 

$FIELD_LAST 

32767 

$FILE_TERMINATOR 

TEST_WITHDRAWN 

$FIXED_NAME 

NO_SUCH_FIXED_TYPE 

$FLOAT_NAME 

NO_SUCH_FLOAT_TYPE 

$FORM_STRING 

11 n 

$FORM_STRING2 

"CANNOT_RESTRICT_FILE_CAPACITY 

$GREATER IHAN DURATION 

" “ 90 000.0 


$GREATER THAN DURATION BASE LAST 

TOJO^JOO.O 

$GREATER THAN FLOAT BASE LAST 

i.TjE+ea 

$GREATER_THAN_FLOAT_SAFE_LARGE 

16#0.FFFFFFFFFFFFEl#E+63 


A-2 









MACRO PARAMETERS 


$GREATER THAN_SHORT_FLQAT. SAFE_LARGE 

16#1!J.FFFFF9#E+63 

$HIGH_PRIORITy 127 

$ILLEGAL_E3CrERNAL_FILE NAMEl 

N0_FILES_AT_ALL_1 

$ILLEGAL- EXTERNAL_FILE NAME2 

N0_FILES_AT_ALL_2 

$INAPPROPRIATE LINE LENGTH 

- -1 


$INAFPROPRIATE PAGE LENGTH 
~ “ -1 


$INaUDE__PRAGMAl 

$INCLUDE_PRAGMA2 

$INTEGER_FIRST 

$INTEGER_LAST 

$INTEGER_LAST_PLUS_1 

$INTERFACE_LANGUAGE 

$LESS_THAN_DURATION 

$LESS_THAN_DURATION_ 


"PRAGMA INCLUDE ("A28006D1.TST”) 
"PRAGMA INCLUDE ("B28006F1.TST") 
-32768 

32767 

32768 

AIE^ASSEMBLER 

-90_000.0 

BASE FIRST 
-115_000_000.0 


tt 

tt 


$LINE_TERMINATOR ASCII.LF 

$LCIW_PRIORI'IY -127 

$MACHINE CODE_STATEMENT 

NULL; 


$MACHINE_CODE_TYPE 

$MANTISSA_DOC 

$MAX__DIGITS 

$MAX_INT 

$MAX_INT_PLUS_1 

$MIN_INT 


NO_SUCH_TYPE 

31 

9 

32767 

32768 
-32768 


A-3 











PAI^HET^ 

$NAI^ 

$I^_LIST 

$NAME_SPECIFICATI0N1 
$NftME_SPECIFICATI0N2 
$NftME_SPECIFICATI0N3 
$NEG_BASED_INT 
$NEW_MEM_SIZE 
$NEW_STOR_UNIT 
$NEW_SYS_NAME 
$PAGE_TERMINATOR 
$RECORD__DEFINITION 
$RECORD_NAME 

$TASK__STORAGE_SIZE 
$TICK 

$VAR1ABLE_ADDRESS 
$VARIABLE_ADDRESS1 
$VARIABLEJ\DDRESS2 
$YOUR PRAGMA 


NO_SUCH_INTEGER_TYPE 

UTS,MVS,CMS,PRIME50,SPERRYllOO, 
MIL_STD_1750A 

NO_FILES_l 

NO_FILES_2 

NO_FILES_3 

16#FFFE# 

TEST_WITHDRAWN 

16 

TESTJrtTHDRAWN 

TESTJWITHDRAWN 

TESTJWITHDRAWN 

TESTJWITHDRAWN 

32 

4096 

0.0001 

SYSTEM.MAKE_ADDRESS(16#0020#) 
SYSTEM.MAKE_ADDRESS(16#0024#) 
SYSTEM.MAKE_ADDRESS(16#0028#) 
TEST WITHDRAWN 


A-4 









APPENDIX B 


COMPILATION SYSTEM OPTIONS 


COMPILER OPTIONS 

The con^iler options of this Ada inplementation, as described in this 
^pendix/ are provided by the customer. Unless specifically noted 
■othen/ise, references in this appendix are to conpiler documentation and 
not to this report. 


B-1 









, .Gp^ILER OPTIONS 


MAiyspA 
,, Parameters 
' inpUt-file-spec 

Ada source file(s) or a batching compiler script file specification. 
The user is. responsible for the order of the compilation if multiple 
source files are specified. Only one script file may be specified. 
The default filetype for the source file is .ADA and for the batching 
coinpiler script, is .SCR. 


AbAl750A 

Command_Qualifiers 

/ASSmBLER 

The assembler listing is written to the listing file. 

/LIST 

/LIST[-list-file-spec] 

/NOLIST 

This qualifier controls the writing of source listing. If not specified 
an interspersed source listing is generated only if the compilation has 
error and/or warning message(s). Specify LIST to generates a source 
listing regardless of the compilation status. The listing file defaults 
to the source filename with character "L" prepended to the first two 
characters of the source filetype (e.g TEST.ADA will produce TEST.LAD). 
If specified the listing file will be placed in the file given by 
list-file-spec. NOLIST generates only the messages if any without any 
source listing. 

/MAX^CONTINUE 

/MAX_CONTINUE(-max~continue-spec] 

The maximum return status allowable for continuing compilation. 

The valid max_continue-spec values are WARNING, ERROR, FATAL, or 
INTERNAL. 

The default value is ERROR. 

/OPTIMIZE 

/OPTIMIZE 

/OPTIMIZE[-optimization-value] 

Sets the level of optimization for the code generated. An integer 
value 0 through 10 may be selected for the optimization-value. 

0 request no optimization and 10 request the highest level of 
optimization. The default optimization-value is 10. 

/0PTI0NS_FILE 

/0PTI0NS_FILE=opt-file-spec 









‘Specif icati^^ of the options file for the compiler phases. 

, ^T$i.;{bp|:io^^^ have the format: 

ioptipn-valuel /.;. 1 

♦ - 

qp^tion^yaluef >... ] 

:^pfR^F;iiJE«ptr-fiie~spec 

■'The;-file specifica^on of the pointer file for the Ada library. 
ifrtHi's ^alifief is not specified the compiler searches for the file 
defihitiph of the pointer file in the logical name PTR_FILE. If the 
l<^icai h^e PTR^FILE is not defined the pointer file defaults to the 
file ADADIB. in the current directory. 

/SCRIPT 

The qualifier specifies that the input-file-spec is a batching compiler 
sciipt file specification. 

./SOURCE_RECONSTRUCT 

The qualifier specifies that sufficient information be retained in 
the program library to reconstruct the source and/or assembler listing. 

/STARTWITH 

/STARTWITH(-phase-spec] 

The compilation will start at the specified phase. The valid values for 
the phase-spec are TB, SEM, GEN, STO, EXP, FLOW, or CG. The default 
value is TB. 

/STATISTICS 

Statistics such as the number of instructions generated will be written 
into the listing file. 

/STOPAFTER' 

/STOPAFTER(-phase-spec] 

The compilation will stop at the specified phase. The valid values for 
the phase-spec are TB, SEM, GEN, STO, EXP, FLOW, or CG. The default 
value is CG. 

/TABLE_DIRECTORY 

/TABLE_DIRECTORY-table-directory-spec 

The qualifier specifies the directory which contains the code generation 
tables. If this qualifier is not specified the compiler searches for the 
table directory definition in the logical name TABLE_DIRECTORY. 

/XMEM 

/XMEM (default) 

/NOXMEM 


Enables or disables the expanded memory feature. 











COMPILATION SYSTEM OPTIONS 


LINKER OPTIONS 

'^e linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation and not 
to this report. 


B-2 






LINKER OP.TIONS 


;LNra^54^ 

^Parameters 

unit-name 

Unit name for which a load module is to be generated. 


LNki75dA 

Commahd_Quaiifiers 
/ALPHA 

ito alphabetically ordered link map is produced. 

/COM_PILE 

/COM_PILE-command-file-spec 

The name of the linker input command file. See User's Manual 
for description of this and other linker input commands. 

/DEBUG_FILE 

/DEBUG_PILE-debug-file-spec 

The name of the file to contain any user-requested listings. 

If /DEBUG_PILE is not specified the default file is unit-name.LBL 
in the current directory. 

/PTR_PILE 

/PTR_PILE-ptr-file-spec 

The file specification of the pointer file for the Ada library. 

If this qualifier is not specified the pointer file defaults to ADALIB. 
in the current directory. 

/MAP 

An ascending address order link map is produced. 

/OUTPUT 

/OUTPUT-output-file-spec 

The name of the output load module file. If /OUTPUT is not 
specified the default file is unit-name.SO in the current directory. 

/XREF 


The cross reference listing is produced. 







Appendix F. Implementation Dependencies 

This section constitutes Appendix F of the Ada LRM for this implementation. 
Appendix F from the LRM states: 

The Ada language allows for certain machine-dependencies in a controlled 
manner. No machine-dependent syntax or semantic extensions or restric¬ 
tions are allowed. The only allowed implementation-dependencies 
correspond to implementation-dependent pragmas and attributes, certain 
machine-dependent conventions as mentioned in Chapter IS, and certain 
allowed restrictions on representation clauses. 

The reference manual of each Ada implementation must include an appendix 
(called Appendix F) that describes all implementation-dependent characteris¬ 
tics. The Appendix F for a given implementation must list in particular: 

1. The form, allowed places, and effect of every implementation- 
dependent pragma. 

2. The name and the type of every implementation-dependent attribute. 

$. The specification of the package SYSTEM (see 1S.7). 

4 . The list of all restrictions on representation clauses (see IS.l). 

5. The conventions used for any implementation-generated name denot¬ 
ing implementation-dependent components (see IS.4). 

6. The interpretation of expressions that appear in address clauses, 
including those for interrupts (see IS.5). 

7. Any restriction on unchecked conversions (see IS. 10.2). 

8. Any implementation-dependent characteristics of the input-output 
packages (see 14 ). 

In addition, the present section will describe the following topics: 

9. Any implementation-dependent rules for termination of tasks depen¬ 
dent on library packages (see 9.d:l3). 

10. Other ir.'.plementation dependencies. 





jippendix f. Implementation Dependencies 
F,1 Pragmas 

THis section describes the form, allowed places, and effect of every 
implemehUtion-dependent pragma. 


F.tl Pragmas LIST, PAGE, PRIORITY, ELABORATE 

Pragmas LIST, PAGE, PRIORITY and ELABORATE are supported exactly in 

the form, in the allowed places, and with the effect as described in the LRM. 

F.1.2 Pragma SUPPRESS 'V 

Form: Pragma SUPPRESS (identifier) 

where the identifier is that of the check that can be omitted. This is as 
specified in LRM B(14), except that suppression of checks for a particular 
name is not supported. The name clause (ON~>name), if given, causes 
the entire pragma to be ignored. 

The compiler will support suppression of all checks. In particular, the 
suppression of the following run-time checks, which correspond to situa¬ 
tions in which the exceptions CONSTRAINT^ERROR, 
STORAGEJERROR, PROGRAMJIRROR, or NUMERICJIRROR may 
be raised, are supported: 

ACCESS.CHECK 
DISCRIMINANT^CHECK 
INDEX.CHECK 
• LENGTH,CHECK 
RANGE«CHECK 
STORAGE.CHECK 
ELABORATION_CHECK 
DIVISION_CHECK 
OVERFLOW_CHECK 

Allowed Places: As specified in LRM B(14): SUPPRESS. 

Effect: Permits tne compiler not to emit code in the unit being compiled to per¬ 
form various checking operations during program execution. The sup¬ 
ported checks have the effect of suppressing the specified check as 
described in the LRM. 


Use: 


To suppress Ada’s builtin error-checking. 









Pragma SUPPRESS^ALL 

Form; As specified in LRM B(14) : SUPPRESS 

; except that the suppression of checks for a particular name is not sup¬ 
ported so the name clause (ON=>uame), if given, causes the entire 
pragma to be Ignored. 

Allowed Place: As-specified in LRM B(14): SUPPRESS 

■ElTect: The implementation-defined pragma SUPPRESS_ALL has the effect of 
the specification of a pragma SUPPRESS for each of the supported 
checks. 

Use: To suppress Ada’s builtin error-checking. 

F. 1.4 Pragma INLINE 

Form; Pragma INLINE ( SubprogramNameCommaList) 

Allowed Places: As specified in LRM B(4): INLINE 

Effect: If the subprogram body is available, and the subprogram is not recureive, 
the code is expanded in-line at every call site and is subject to all optimi¬ 
zations. 

The stack-frame needed for the elaboration of the inline subprogram will 
be allocated as a temporary in the frame of the containing code. 

Parameters will be passed properly, by value or by reference, as for non¬ 
inline subprograms. Register-saving and the like will be suppressed. 
Parameters may be stored in the local stack-frame or held in registers, as 
global code generation allows. 

Exception-handlere for the INLINE subprogram will be handled as for 
block-statements. 

This pragma is used either when it is believed that the time required for 
a call to the specified routine will in general be excessive (e.g. for fre¬ 
quently called subprograms) or when the average expected size of 
expanded code is thought to be comparable to that of a call. 


Use: 









Appendix E. Implementation Dependencies 


F.L5 Pragma INTERFACE 

Form: Pragma INTERFACE (language_name, subprogram_name ) 

where the language_name must be an enumeration value of the type 
SYSTEM.SupportedJLanguage_Name (see Package SYSTEM 
below). 

Allowed Place: As specified in LRM B(5): INTERFACE, 

Effect: Specifies that a subprogram will be provided outside the Ada program 
library and will be callable with a specified calling interface. Neither an 
Ada body nor an Ada body_stub may be provided for a subprogram for 
which INTERFACE has been specified. 

Use: Use with a subprogram being provided via another programming 

language and for which no body will be given in any Ada program. See 
also the LINICJ^AME pragma. 

For a pragma INTERFACE (AIE.JVSSEMBLER) subprogram, standard 
Ada calling conventions will be followed, but no Ada body is expected or 
allowed. The standard Ada calling conventions for the compiler are 
described in Appendix C. 

FJ.6 Pragw.a LINK^NAME 

Form: Pragma LINIC_NAME ( subprogram_name, linkjiame ) 

Allowed Places: As specified in LRM B(5) for pragma INTERFACE. 

Effect: Associates with subprogram subprogj am_name the name link^ame 

Syntax: The value of link_name must be a character string literal. 

Use: To allow Ada programs, with help from INTERFACE pragma, to refer¬ 

ence non-Ada subprograms. Also allows non-Ada programs to call 
specified Ada subprograms. 

FA.I Pragma CONTROLLED 

Form: Pragma CONTROLLED ( AccessTypeName ) 

Allowed Places: As specified in LRM B(2) : CONTROLLED. 

Effect: Ensures that heap objects are not automatically reclaimed, but are expli¬ 
citly reclaimable by use of unchecked_deallocation. 

Since no automatic garbage collection is ever performed, this pragma 
currently has no effect. 








M^i8 Pragma PACK 

;Kofm: Pragma PACK.( type^imple_name ) 

Allpwed Place; As specified in LRM 13.1(12) 

Effect; Records or arrays are allowed their minimal number of storage units as 
provided for by their own representation and/or packing. 

For arraysj elements are bit-packed with a size that is evenly divisible 
into the storage unit size. The elements are then packed into the 
minimal number of storage units. 

For records, scalar components smaller than a word are bit-packed. The 
components are then packed into the minimal number of storage units. 

Use: Pragma PACK is used to reduce storage size. This can allow records 

and arrays, in some cases^ to be passed by value instead of by reference. 

Size reduction usually implies an increased cost of accessing components. 
The decrease in storage size may be offset by increase in size of accessing 
code and by slowing of accessing operations. 

FA.9 Pragma remote 

Form: Pragma REMOTE or Pragma REMOTE (library_umt_narae ) 

Allowed Places: Within library units which are package specifications or immedi¬ 
ately following library units which are subprogram specifications. Note 
that this pragma is only supported when the RTS containing the 
expanded memory support is used. When the 64K RTS is used, this 
pragma is ignored. 

Effect: Pragma REMOTE without a parameter specifies that the library unit is 
to be located in a new group in the 1750a memory map. The library 
unit is then known as the parent of that group and may then be specified 
as the parameter to the pragma. 

Pragma REMOTE with the “library_uii .. .me” parameter specifies 
that the unit which contains the pragma be placed into the same group 
as the specified “library_unit_name.” 

Use: The pragma is used to distribute the library units of a large program 

into the different address states of a 1750A containing support for ihe 
expanded memory option (via page registers). Pragma REMOTEs are 
used to group related units together so as to minimize remote references 
and calls. 











;Appendix:F, implementation Dependencies 


The following, simple example shows how two packages can be specified 
to be placed in the same group. 

package A is 
pragma REMOTE; 
end A; 

with A; 
package B is 
pragma REMOTE(A); 
end i3; 

F.LIO Pragma INTERRUPT 

Form: Pragma INTERRUPT (Handler^Routine, Interrupt_Level) 

Allowed Places: Library unit specifications. 

Effect; Unmasks that level of 1750a interrupt and binds a parameterlesfi pro¬ 
cedure to the interrupt such that when the InterruptJLevel occurs, the 
HandleriRoutine is invoked as quickly as possible. After the procedure 
completes, execution is resumed from where it was prior to the interrupt. 

Use: Prpvides a faster interrupt mechanism than Ada interrupt entries. 

with Interrupt«User«Support; 
package Handlers is 

procedure User«0; -- j no parameters allowed 

pragma Interrupt{User_0, Interrupt_User_Support.Interrupt_XeveLType{2)); 
end Handlers; ■ 

F.Lll Pragmas SYSTEM^NAME, STORAGE^UNIT, 
MEMORY_SIZE, SHARED 

These pragmas are not supported and are ignored. 


F.L12 Pragma OPTIMIZE 

Pragma OPTIMIZE is ignored; opiimlzation is always enabled. 






F.2 linplemehtation-dependent Attributes 

This section d^cribes the name and the type of every implementation-dependent 
attribute. 

There are no implementation defined attributes. These are the values for certain 
languag^defined, implementation-dependent attributes: 

Type INTEGER. 

INTEGER’SIZE = IG - bits. 

INTEGER’FIRSt =*-(2**l5) - - 32,768 

INTEGER’LAST = {2**l5.l) ~ 32,767 


Type FLOAT. 

FLOAT’SIZE =* 32 - bits. 

FLOAT’DIGITS = 6 

FLOAT’MANTISSA = 21 

FLOAT’EMAX = 84 

FLOAT’EPSILON = 2.0**(-20) 

FLOAT’SMALL * 2.0**(-85) 

FLOAT’LARGE =* (2.0**84)*(1.0-2.0**(.21)) 

FLOAT’MACHINE^ROUNDS = false 
FLOAT’MACHINE.RADIX = 2 

FLOAT’MACHINE^MANTISSA =* 24 

float’machinej:max = 127 

FL0AT’MACH1NE_EMIN = -128 
FL0AT’MACHINE_0VERFL0WS = true 
FLOAT’SAFE_EMAX = 127 

FL0AT’SAFE_SMALL == 2#0.100000000000000000000#E-127 

FLOAT’SAFE_LARGE = 2#0.lllllllUllllllllllll#El27 

Type LONG_FLOAT. 

LONG_FLOAT’SIZE = 48 - bits. 

LONG_FLOAT’DlGITS •■= 9 
LONG_FLOAT’MANTISSA = 31 
LONG_FLOAT’EMAX = I2l 
LONG_FLOAT’EPSILON = 2.0* *(-30) 

LONG_FLOAT’SNb\LL = 2.0* *(-125) 

LONG_FLOAT’L/\RGE = 2.0**(l2‘l)*(l.0-2.0**(-3l)) 
LONG_FLOAT’fvL\CHINE_ROUNl)S = false 
L0NG_FL0.^T’^UCH1NE_R.-\D1>: = 2 

LONG_FLOAT’MACHlNE_M.AN'TISSA = 40 
LONG.FI.OAT’NUCllINE.EM.VX = 127 
LO.NC:_FLO.\T'N'IACH1NE_1:M1 i\ - -I28 
I.0Nr;_FI.0ArMACinNE_0\El?l'L0\VS = true 












Arppendix F. Implementation Dependencies 


0NG^FLOAT’SAFE_EMAX = 127 

* L6NG_FL0AT’SAF6_SMALL = 

2#0.UlllllllllinillllllllIllllUllllllll#E-l27 
L0NG:^FL0AT’SAFE_LARGE = 

2#0.1llUUllUlllllllllllUlllillllllllll#E127 

Type DURATION. 

DURATION’DELTA 
DURATION’FIRST 
DURATION’LAST 
DURATION’SMALL 

Type PRIORITY. 

PRIORITY’FIRST * *127 

PRIORITY’LAST =* 127 


= 2.0**(-6) seconds 
= -SG'IOO.O seconds 
= 86400.0 seconds 
= 2.0**(-6) - 15.6 ms Approx. 


mm 


’®kepeiar^4w6‘RunTtim which are available for the i750A compiler. One 

"4ssfbinthe-ii75pA with^.M^^ memory and the other is for a 1750A with the 

fCxpand^ .memoi^^ See the User’s Manual for details; Each RTS has its 

b^h; package iSystemi 


FiSUij Expanded^MemorynRTS 

■:pi-;e k-4|e '-Sys.t em- "i'l 

t y p e ;Add fit I i i. priv.itt*; ?• *»", "/«" defined implieiliy; 
i;ype Name, li (UTS, MVS., CMS, PrimeSO, SperryllOO, M1L_STD_1750A); 

^Syi lein.Nime i eoni.tiht Name MIL_S,TD_17S0A: 

S'iofa|eiUfi’i.t ! eon*tint 16; 

Mtmotx^Si-i:*- : eoniiant, 2 • 18 f 2**16; 

4n storair units I+D irou^ 64K. 

, Syitem-Dependent Named Number*: 

MJn,rnt ! eoni'tant :« |n,t**er'POS( Integer'PIRST) ; 

Mnx-Int I constant integer’POSllnteger’LAST); 

Max.pigit*; : eon»;iant :« flj 
MaxuManMi : constant :>b31; 

•;pin*iD>i l» • constant :* 2.0*»(r3l): 

Tick: : coni t ant !» 6.0001 j 

*• Other Sy s t *m*b* pc nde n t. Declarations 

subtype Prjority is Integer range -127..127; 


Imp I ernehtation•dependent additions to package System 


NuM.Address : constant Address; 

•; Same bit pattern as "null* access value 

•* This is the value of 'ADDRESS for named numbers. 

-• The 'ADDRESS of any object which occupies storage 
;• is NOT equal to this value. 

Add r e s s _S i z e constant ;=s 32; 

-• Number of bits in Address objects, = Address'S1ZE, but static. 

subtype Groufi.iNumbe r is integer range -I 15; 

-t means global area. Other values are address stales. 

Gl 0 baI_Group_Number ; constant Group.Number ;= •1; 

subtype Address_SegmenI is Group_Number; 

.Add r c s s _S e gme ti I _S i i e constant ;= 10; 

-• Number of bits in address segment. =Add r e s s _Segmc ii I ' S I ZE . 
but static 

type .\d d r e s s _Of f .s e t is new Integer: • - Used for .i d d r e s i r i t hnn -1 i . 
■S II b t ) |. e 1,0 g I > .1 1 _.\d d r e s s is \! •! r e » s _Of f e I . 











■ Dipth J-ehe i.et 


^," 7 / V , 

v/^u)i?ft£Co|ii;^^ : cons tah t ,Logi c*(^Add r ess ;=« 0; 

'j ;\"^|_:'‘T!i)'i:s^ ii/s'J-t^k'*.' .yl'i’J'utc 6J. '*• ■n'Vl-l' « «*;» ^XP'* ^ 

' ;;i ■ I.eiV«;i .for llie i7,5p*, 0 is the highest level 

iin,t:l5r ruR^ i s., range 0 .. 15 ; f or In te r rup t_Leve4 _ty pe ' S i ie 


ty.pf Sup;pd.r4eids^^ is ,{: i* Target dependent 

’ ■'••t.Vfi?? ' •'-I. §T * " f of * 18"^ • : 

AiEiASSEMBLER,; s i -NOX^ a "forejgn" language • uses A IE RTS 
<UNSPECiFTEDu^^^^^ 




:jiios.t;//l eis^ -.a^^ hu.i l t-i h i n.t ege r arid f loat types 


>ruKvy'p.* Lbnget.i Jlihctiief i s .S tandard ; Integer; 
aub.ty,p|( .Sh>r tes tsiffti i s. S^ndaf d . I hteger; 

,ihb;ty;p*; .Longesit^FJiOa.t j 1 Stahdard .Lpng.F.i oat; 
ittbtype, S.horU ,iii Standard .Float;, 


,.* -...ifiUhCitkoh,-(. •■i Offset portion of an Address. 

Ad dr : in. Addfeis 

.‘)»reiur,n Addre*s..Of.,f.i.eti 
•i'i?|;'<Retttrnj t.he offset porti'on of an Address, 
p r a'gihi-.I'ni'i'h*:e (,0 ftN e t-0 

funcAi'^n Se|n\eh.t.wbf (; i- j Segment portion of an Addrer*. 

Xddr ' ! i n. Add'r e.s s 

. .. ':)) re'tufh Address,S‘e|mint;j' 

• •IjReturn' segment port i.on; |gr,oup number) of ah Address, 
pragma Tn'I.i h.e (Se,ginentiO,f«)^^^ 


function Make.Addrcs.s ( Compose an Address from parts, 

Segment : ih Address.Segmeht; 

6ffs,et ; in AddfesSiOffset 

)\return Address; 

• : |:.F6rm an. Address from a segment (group number) and an offset 
:P'r agma I n l i ne (Make.Add r ess ); 


p r i V a t e 

-K^^FlX : constant 2.0* *Max^Man t i s s a '1.0; 

MIN.FiX : constant ;» (Min.lnl +Max^Int) • l.O - MAX.FIX: 

type Address is delta 1.0 range MIN.FIX .. MAX.FiX; 

• t Also see type Compos i te_.\ddress. 

•• This is an address state and a logical (simple) address. We use 
fixed point (two words) $0 that an address is not treated as a 
composite object by the compiler (for example it will be passed 
•• by value rather than by reference). We specify maximum ran^e to 
•• avoid constraint checks. We sacrifice some checking in order to 
get speed (in-line code for address arithmetic). Thus the user 
• will be responsible for ensuring that address calculations have 
the appropriate operands. 

-- One mechanism by which the user may enforce more rigorous type 
•• checking is to write another package through which ail address 
•• calculations must pass which provides the appropriate checks. 

-• The current implementation has been chosen because it provides 
-- efficiency and does not preclude stricter type checking (i.e. 

-- the above mentioned package). The type checking which is not 
-- provided is noted below 


Ty i> e 
II .< e 


.\<ld i n g two addresses will g. r o <1 ii c e 1111 !• r e d 1 c t a b 1 c r e s u 1 t .s 








jcX'ijS’- iSjr*»'.Vr,i,c't',i‘^ng\sw.h i ch ir e J .n d i f f e r I groups ivi I I 
-ji Ipjiu ce/ 5re;S u I t s,'. f9<i' way r*' * * Con s t r a i n liEr r o r 

/,-;.*\;Nu;!^i?i:V4’dyievff\ f,-•c'o’n'S.t'an'lt; 'A"d'djr<e's^f :== 0 :6 •, 


;;.|^y,p,*v.;Cd,mp;68;i>i'e'_Ad'de.eis$; ;j''8!’»r;e,C;6rd- 

r V"r' ' ^4*1^**® segen.t and offset, 

ISe'gmeinJt-'’': ;'Add;r'(tfi's'S,egment.-;-- 
: ^,'Ad,d'f.«.8 8sO'hf.'s:e;.V;, 

/e.f'dj:Ke;co,r'dij.. 


enjIjSysttm: 


•pae’ka.l it; '.S/’iitem- ;i;8-- 

‘type Add'r:e8 8, Ui pr i ! ** t */•■" defined implicitly; 

■t|M Nime- 1 8 ‘(lUTS , .%S; CMS;,, Primes 6, Sperry.ilO.Oi MlL>STDil7S0A) ; 

'Sy/iH-emL'Nim^^^ eoHpti'it Name. :« MiL_STPi.l750A; 


;5,;i:or,ig'ejU,n.i‘l; 'epni.i-a'nt: 
:iM\infr.y.-SXi;e;"i- c.dniVaAt' i/fi'd;, 
’.’i- Cn/'8iofa|e;''U>'i-t;ii;' 


• i S^it'.em-bepiAhient Named; Numbe ri;: 

iMi MtnV •! !« 4,#t.eger.'PbS( ittl.egpr'PI.RSf) i 

! con'i'-Unt :'«■ jate.g.er-'PpS^ rnteger'^Sf); 
,:Mix‘iDJ’;g=i'.t8; coni I alt' i» •ii' 
l^ix jMan t iila. : 'eottb.tant 31,; 

'PUneibeKta I-Mconltant ;• 2;0»• (;• 11);; 

Tick: ! con I fan I :• Oi.OOOl,; 

- Other. !Sy8tem«bependent Declaratadns 

lubtype. Prior 1 ty la Integer range • 127. . 127; 


ImpTementat1oh'dependent additione to package System 


NuH.;Address : constant Address; 

•• Same bit pattern as 'null* access value 
•This is the value of ‘ADDRESS for named numbers. 

•r The 'ADDRESS of any object which occupies storage 
- - is NOT equal ^ this value. 

.\ddress_Si ze : constant :== 10; 

•• Number of bits in Address objects, sAddress'SIZE, but static. 

subtvpe Group^Number is integer range -1 IS; 

-- -t means global area. Other values are address states. 

G1obaI_Gr6up_Number : constant Group_Numbcr := -1; 

subtype Add r e s s_S egine n t is Gr o u p _Numb e r; 

Addrcss_Scgment_Size constant ;= IG; 

■ • .N'litnbcr of bits in address •.egineni. =Ad d r c s s _.S c gmc n t ' S 1 7,F.. 

-- but static. 












l.n'tei*’r,; -.-- IJstd' f.br »ddr«,8 j. :ir i-t'hme,fi e 

'•;'. 'C^^'t.tjf^p.’e;' Log;j:,e.|k;i'iAd'<}';fvr«^^ ‘i'f->Ad'd‘.r:;e,j,S'iOr.f;S js t^; 

■-\-NujHl}j|L‘oi;ii^^ _ eon'iiI'.n'.t Lo^g i-.ci;i,_A_dd r e'.s's :» 0 ;, 

';,. i'i-H.* '9'f- •§•> 'V-y:-?.'?;- 

*4'yiPV iS’jii^P.'p^9"i»■■-'.(« .•*• dVptndent 

-vri' *iro;r/*d',g.n'*''’ j:»ngU'%ge8-:' 

■AIE^^V^SSEjiiBLER, • NOT .» "fbriJ gn" 1 ing*.u»g< • u**« AIE'RTS 

fMs.pfciFi|D;4Aw^ -. r.'- 


•'^rMpiVt/triit buiU>;ih Intigtr tnd f,lbit typti 

iiubiyp.f !libngftV^l«it:«g»r i;i S t»hi*rd ./In Ugt r j 
!i u b t y.pt S |i or lift i 1 n t • i •- f* i'» S i a n d b r d. j n l * g «r;; 

<iu.bt^ :li Stindird“**■ I 

t.u^ypt. ’Shbriti:i;.P;lbat i i Stbndard .Float,; 


iiubi‘yp,f NprmiiTl.»tl|^Addf'ii»i^ ii 

.Aiddir;f;MiOfsf,ii t;; ii»'b*l .ringi A Addrti t.iStgmtn,t_Sj li ^ 1; 

• i-Rbiig.* of ^bd.driii offtiti rtturnfcl by, OfNjit.Or 

, ;f;unc,Vipn 9ff>**'V>^^ { ”-1 6f,f.i«t -portion pi on Aidrtii. 

•AidV ! in.Addt-til. 

)' rtifirn Addr'iii-idlf lit; 

• |;'RrVHM»,>'V*^in. Addrtii.. 

,. :P'f bgmb. .'isb ii ni,(.pf 


function S«"|mtnt.Of ( ••.!: Stgmtnt porttiop of an Addrtia.. 

?Ad;d:r.' : in Addfci'i- 

) ifiturnv Addr ttt.'Atgmtnt; 

.'• I Rtturn iigmtnt portion (.'group number) of an Addreis, 
ip ragmat ii n l:i n e ( S t grot n.t ,Of.); 


fiunetiibn Make^Addrets ( Cornpbse an Addrett from parti. 

Segment : in Addr.eia.^Segment; 

Offift : in Address,Offiet 

) return Address; 

•• I Form an Address from a segment (group number) and an offset, 
pragma i ni i nt(Make.;Addr ess); 


function *+*(addr : Address; offset : Address_Offset) return Address 
function “+"(offset : Address_Off$et; addr : Address) return Address 
-• Provide addition between addresses and 

offsets. May cross segment boundaries on targets where 
•• objects may span segments. 

•• Oh other targets, CONSTRA!NT_ERROR will be raised when 

Offset_Of(addr) + offset not in Norma1ized_Address.Offsct . 

function "-"(left, right ; .\ddress) return Add r e s s _Of f s e t; 

-• May exceed Segment.Size on targets where objects may 
-• span segments. 

-- On other targets. Constraint.Error 

will be raised if Segmcnt_Of(1eft) /= Segment_Of(rigbi) 

function "-"(addr ; Address, offset 
•Add r c s s ; 


.■\d d r ^ s _(> f f .1 c t ) return 











XB^Ko^V'ifd.e juaddftsses and offstta,. 

,-MMay; ,C!r-;os,j sMnjejit ;bd!iii^ on targets where 

■■•*- v;o.l>;^'',e;c;t;s '.maxs.'fpah=''S.egmfh'.^'. 

- dn. ^ot^h.er ta.rgeis.f. CONSTrRAINTiERRpR. wi i 1 be raised when 
? pf.»rjse l.iOf4^nd|d r) * ,o f f.,se>t cno t .i n Norma I i sed_Add r es s\i6f f s e t. 



‘ :.»■ 2 .d«'»Max.;Man',i:i ssa 

, jMitnif^l/ ^ .(Mi hi. I n t +MaXi;I nt,) • 1.0 • Max.iF ix; 

-/ ’'Vy^P'.* -'A'i'd r-e'.i'h -Ji- a'c.c’e'ii J^n-t.e'g.e r; 

^ V i-. ;Ndf;e-; Th.e designated type here (Integ.er) is irrelevant. 

' ‘ ,?• Address is rhade ah access type simply, to guarantee it has 

?• the. same sise >a*' »«.«**.* values;, which are single address* 

• • A'l I oc ato.r 8 of type.Address are NOT meaningful. 


^Niid'liiiVddr.est cons.tanl Addres:s :» hull; 


Sintem; 












'!rjii|i4ec^PB^d^cfibw of aj}, r^trictioiis on Representation clauses. 

'..An its apceptancc of representation clauses to 

ffhode tkat ican jie h^ the underlying hardware..., If a prqgrjdm con- 

Vgim ^ is not accepted [by the compilerji then the pro- 

.fjrpwi-w 4’i(e(7ci;''t 


Those. restncVipris w^^^^ are >.3finedT>y the LRM are hot listed, A description of 
the effect of: thpiRepi^esenUtipn clauseas alTO included w 

: :%i iiengtkclaU^;: 


SizeiSpecificaViphir f’S^ 


The size specification may be applied tP a type T or fii-st-named sub- 
type T which ia ah access.type,,a ah array type; pf'a record 


Ai*OP536/!37r haa ailtered: the meaning of a-size specificatipn. In partic¬ 
ular,.the .stateinent from the UiM l'^>2^a that the .exprli^ipn in the 
-length (jjause specifies an upper bpuhd tpr the number of bits to be 
allbe|t®d to objects pf the type is incorrect^ Ihsteaid, the expr^ipn 
specific the exact size for the type, pbjects of the type may be larger 
than the-'specified size for padding. NPte that the specifiedlsize is not 
used when the type is used as a corapohent. of a record type and a 
coniponeht^crause.specifyihg a different size is given. 


If the length -clause can not be^satisfied by the type, an error message 
will-begeherated. 


The supported values of the size expression are explained for the type? 
as follows. If the value of the size expression is not supported, an 
error message will be generated. 

access type: the only size supported is 16. 

integer or enumeration type: minimum size supported is I, the max¬ 
imum size that is supported is 16 the size of the largest 
predefined integer type. Biased representation is not sup¬ 
ported. 


fixed point: minimum size supported is 1, the maximum size that is 
supported is 32. Biased representation is not supported. 


fioating point type: the sizes supported are 32 and 48. Note that the 
size must satisfy the DIGITS requirement. No supp'''rl i.s 
provided for shortened manlis.sa and/or exponent lengths. 







V; -. ^record- typ.e:,4 the .size; r.pf the unpacked type is greater than the 
- .specified, size: of the length clause, an implicit pragina pack 

. . will be-a^umed^pn ir the size of the implicit 

, pragma packed, record type is still greater than the specified 
, / . size ;of the,4ehgth: clause, an erro^^ (See alsd 

Pragma, Pdck K.liS and .Record Representation Glauses 

. . .array type: if the size of the unpacked array type 4s greater than the 
size-' clausd expre^ion, ah iihplicit pragma pack will be 
assumadiPh the ^array type. If thaVizepf an imp^^^^^ 

, packed; .array type is still greater than the sike expr^ion 

, - clause^ anserror Will, be gen^ 

• Specificatipmpf collection:size: TlSTOj^GEiSIZE'. 

The effect of the specificatipn of collection size is that a cphtliuous 
area.?pf the required Vize will be allocated for. the collection. If an 
atteihpt tP allocate.ah object within the collcctiph requires more space 
than currently exists in the coliectiphr STGRAQE^RRO wiij be 
;rais0i Npte that^this,space include, the header information. 

• Specificatibh^pf storage fpr a task activation; T’STGRAGE«SIZE. 

The value, specified by the length clause will be the total size of the 
stacks allocated for the task, rounded up to a multiple of the storage 
;page or “chunk” size (which is .512 words), The default stack size for 
each task is:ip28 words. 

•; Specification of small for a fixed point type : T’SMALL 

The value of T’SMALL is restricted to composite powers of 2 and 5 
(e.g. 2j 5, 10), 

Enumeration Representation Clauses: 

Values must be in the range of MIN_INT .. M/\X_INT. 
Record-representation-clause: 

An alignment clause forces each record of the given type to be allocated at a 
starting address that is a multiple of the value of the given expression. 
Allowed alignment Value is 1 (SU aligned). 

The range of bits specified has the following restrictions: if the starting bit is 
0, there is no limit on the value for the ending bit; if the starting bit is 
greater than 0, then the ending bit must be less than or equal to 15. 

Record components, including those generated implicitly by the compiler. 







w^c^epid^tions. are nqtigive^ are laid out by 

■ , thfexcompiler jfoilpwm components whpsc locations are given by the 

■i!eprwen|atipn--clause. Such components of the invariant part of the record 
, 4f® fplJow the user-specified components of the invariant part, 

. and such, com Sjven variant part are allocated to follow the 

userfspfcified-cpmpon^^^^ that.variant part. 

The,actual size of the record object (including its use as a component of a 
record, pr array type) will always be a multiple of storage units (e.g 16,32, 
ietdr bits); with padd^^ the end of the record, if necessary. User- 

specified TahgM must contain at least the minimal number of bits required 
, tbjreprcsent a (bit-packed) object of the corresponding type; e.g. to represent 
an.ihteger type with a range oro..l5, at least 4 bits must be specified in the 
record repr^entation specification range. 

d; Address clauses: 

Address clauses are allowed for objects (variable or constant) and for sub- 
.programs to which a pragraa INTERFACE applies. Address clauses are not 
allowed for packages or tasks. The interpretation of the value of an address 
clause is described in F.6. 









4escrib|£s the. .conventions used for any Inipfementatiou-generated 

jriames: 


There:: ^ n^ ;imp1ementa,tlon-:generated names denoting implementation- 
;depcndent i(rerord) .(ipmppn^^ ajthojigh. there are, indeed, such coniponehts. 
iHencej ith^^ possibility) of naming them and, therefpre, no 

W aif'la rep raen tatipm cjause^^^^ 

:^dte: Records containing;, dynamic-sized^ cpmponents will coiitain (generally) 
uhnamed; ofiset cpmppnenta which, will ‘‘point’’ to the dynamic-sized components 
itpred^later in ithe record. There is no way to specify the representation pf such 
iprappriehtsi 







‘S'. 


:, ^K,isr,section^.d«cribra4he restrictions upon expr^sions that 

)0p.peapimlid’dr^^^^ 

Me,44i^^;#ecified.*.b^ the ,simpie_exp an address clause, 

Ipr ;simpi§ihame: 
ihb4ld 4!B;a cailipn Syste^^ 

:fpr ^C use atiSjrstemiMake^^ Offest); 


Is a private type. It is recommended that a user utilize the rou- 
.tih«‘provided in package System to manipulate Address values. These routines 
.are “ihlihed?' ^ ipak® the use of them faster so that Unchecked«Gonversipn. 
Settvwh; addri^eSfand access typjw is unnecessary. In fact, for the Expanded 
'Memory ,RT§, addr^es are represented by 32 (rather than 16) Vits and 
;y,nchecked;iGonyer8ipn! is not available to convert between a 32 bit 
|y8tem.Addf^ and'.a 16 bit ^iccess valuci 


An addr^ claus^may be. applied t^ an object (variable or constant), to a sUbpro* 
:graih,.pr to a task entiy. It ihay not be applied to a package Pr task. 

When an addr^ clause is applied to an object, the address value will be inter¬ 
preted as an addrras in memPry which will be used for all reads and updates of 
the object. No storage space will be allocated for the object by the compiler (or 
pre^jinker). 

W^iien an address clause is applied to a subprogram, there must be a pragma 
IHTERFAGE associated with the subprogram to provide the body. No storage 
space is allocated by the compiler and the PLACE command of the linker should 
be used to locate the interfaced unit where the address clause specified it to be. 

For interrupt entries, the addresses of the 1750A interrupt table are used to 
specify the interrupt level which will call the entry. 

















KPiiss. 

*• Vi*^’v^s^^4 a 4 < ^'. 






p|:'?4% 

■^i^'A'-f'' r ' ^ • , c 

>S'> ;•’. '5-»- ; -' 

}\ ,c b . ^ .T’*’*'* ' 
S?i;V'K';’, ‘‘if V 

lfc''|v.'".; -.W: 

|i9^''’\v'' 'T’;'.hk 


?- 

•\),'' ' 


■ ’' •iK'^ 


.•■§4it^>;sect,ionpd«cribw./implement^^^^ characteristics of the ihput- 

jf|ie ;lf5bi^4s*;^H5^iE49-9P®r%te W and without exter- 

' h0? I/Q- Review >pther thaii. the: conrole device which supports Text JO for 
4S,Tj^|i]^^0i4NP^y^^ a^d .$^Ai!^A^^6t)T^ The predefined exception 
%sM^RR6r will to open any external file or use 


1^: 












tf’his^'sectibnK characterlsVics of the tasking 

Eyehsthp,ughui ,mami program (its dependent tasks, if 

ianyj; 'hav!hg; \termihated), the e^ as a whole continues 

jdhtilMeach. iibrary unit package has either terminated or 

;reachednari' dpehitermihato ^ LRM 9.4(13), 


Adav''delay statem^^ are. implemented for the 1750A target using the optional 
4irterM’eferreci Timer B is a)^ used to support the impiemehtatioh 

of ®ackage Calendar. 

















