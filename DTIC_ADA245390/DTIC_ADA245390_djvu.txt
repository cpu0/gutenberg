NAVAL POSTGRADUATE SCHOOL 
Monterey, California 

in= 



THESIS 


A SOFTWARE PROTOTYPE FOR A COMMAND, 
CONTROL, COMMUNICATIONS AND INTELLIGENCE 
(C^I) WORKSTATION 

by 

Vedat Coskun and Cengiz Kesoglu 
December, 1990 

Thesis Advisor Luqi 

Co-Advisor. Gary Hughes 

Approved for public release; distribution is unlimited. 












UNCLASSIFIED 

SECURITY CLASSIFICATION OF THIS PAGE 




REPORT DOCUMENTATION PAGE 


UNCLASSIFIED 





Approved for public release; 
distribution is unlimited 



Computer Science Dept 

Naval Postgraduate School 

(if applicable) 

CS 

Office of (Thief of Naval Research, (Tode D1124 

6c. ADDRESS (City, Stale, and ZIP CodaJ 

Monterey, CA 93943-5000 

7b. ADDRESS (City, State, and ZIP Code) 

Arlington, VA 

22217-5000 


IJ M y, I di d 11 ? I tl I ? re^ lV :1 f LVe= 




ORGANIZATION 

Office of Chief of Naval Operations 

(M applicable) 

OP-942F4 

8c. ADDRESS (City, Stale, and ZIP Code) 


Washington D.C. 


20350 - 2000 




■ J rr»Tc^ :71T. I:] ;T«1I M ri 


ELEMENT NO. NO. 





ACCESSION NO. 


11. TITLE (Indude Security Classification) 

A SOFTWARE PROTOTYPE FOR A COMMAND. CONTROU COMMUNICATIONS AND INTELUGENCE (C^I) WORKSTATION 




Coskun, Vedat and Kesoglu, Cengiz 


1 




14. DATE OF REPORT (Year, Month, Day) 

December, 1990 






The views ex[TOSsed in this thesis are those of the authois and do not reflect the ofTicial policy or position of the Department of Defense or the 
U.S. Govenunent 


COSAH cooes I subject terms (Continue or reverse n necessary and identify by block number) 

group I SUB-GROUP I Computer Aided Prototyping, C^I Systems, Hard-Real-Time Systems, 

User Interface, Ada, Command and Control, Prototyping Language 


19. ABSTRACT (Continue on reverse if necessary and identify by block number) 

Developing large hard-real-time systems in a tradition^ way usually creates inconsistencies among the 
user’s needs, the requirements and the implementation. 

Rapid Prototyping by using Prototype System Description Language (PSDL) and Computer Aided Proto¬ 
typing System (CAPS) minimizes the time and resource costs, and maximizes reliability. In this technique, de¬ 
signer builds the prototype with the initial requirements, and the user evaluates the actual behavior of the 
prototype against its expected behavior. If prototype fails to execute properly, the user and the designer work 
together to change the requirements and the prototype, until the prototype captures the critical aspects of the 
software system. 

This thesis uses the rapid prototyping approach to produce an Ada software prototype of C^I workstation, 
which provides commonality and connectivity between naval platfoims and land bases by providing the ability 
to process tactical data from many interfaces in real-time. The major emphasis of the prototype is to suppon 


DISTRIBUTION/AVAIUkBILITY OP ABSTRACT 121 . 

13 UNCLASSIFIEDAJNLIMITED □ SAME AS RPT. □ DTIC USERS UNCXASSIFIED 




a. NAME^OF RESPONSIBLE INDIVIDUAL |22t>. TELEPHONE, (Include Area Code 

Prof. Luqi 






DO FORM 1473, S4 MAR 


83 APR edilion may be used until exhausted 
An other editions are obsolete 


SECURITY CLASSIFICATION OF THIS PAGE 

UNCLASSIFIED 


1 

































UNCLASSIFIED 

SECUmTY OASSFICATION OF THB PAGE 


>^I infonnation management functions, message generation and infonnation display. 

This thesis has successfully produced an executable Ada prototype, and fiuther demonstrates the feasibility 
»f the software research and develt^nnent policies proposed by the Navy's Next Generation Computer Resourc¬ 
es program. 


ii 


SECURITY CLASSIFICATION OF THIS PAGE 

UNCLASSIFIED 







Approved for public release; distribution is unlimited. 


A SOFTWARE PROTOTYPE FOR A 

COMMAND, CONTROL, COMMUNICATIONS AND INTELLIGENCE (C^D 

WORKSTATION 


by 

Vedat Coskun 
L^g., Tuddsh Navy 
B.S., Turkish Naval Academy, 1984 

and 

Cengiz Kesoglu 
L^g., Tuddsh Navy 
B.S., Turkish Naval Academy, 1984 


Submitted in partial fulfillment of the 
requirements for the degree of 

MASTER OF SCIENCE IN COMPUTER SCIENCE 


from the 


NAVAL POSTGRADUATE SCHOOL 


^^^^^^^^^ecember 1990 



Robert B. McGhee, Chairman, 
Department of Computer Science 


Accesion Fcr 

NTIS cf:.\u 
DTIC TAd 

Justificatif.Ti 


By. 

Dist.'ib.’fi'o ' I 










ABSTRACT 


Developing large hard-ieal-dme systems in a traditional way usually creates in¬ 
consistencies among the user’s needs, the requirements and the implementation. 

Rapid Prototyping by using Prototype System Description Language (PSDL) 
and Computer Aided Prototyping System (CAPS) minimizes the time and resource 
costs, and maximizes reliability. In this technique, designer builds the prototype with 
the initial requirements, and the user evaluates the actual behavior of the prototype 
against its expected behavior. If prototype fails to execute properly, the user and the 
designer work together to change the requirements and the prototype, until the proto¬ 
type captures the critical aspects of the software system. 

This thesis uses the rapid prototyping approach to produce an Ada software pro¬ 
totype of C^I workstation, which provides commonality and connectivity between na¬ 
val platforms and land bases by providing the ability to process tactical data from 

many interfaces in real-time. The major emphasis of the prototype is to support C l 
information management functions, message generation and information display. 

This thesis has successfully produced an executable Ada prototype, and demon¬ 
strates the feasibility of the software research and development policies proposed by 
the Navy’s Next Generation Computer Resources program. 


V 






THESIS DISCLAIMER 


Ada is a registered trademark of the United States Government, Ada Joint Pro¬ 
gram Office. 

TAE Plus is a registered trademark of the National Aeronautics and Space Ad¬ 
ministration (NASA). 

X Window System is a registered trademark of the Massachusetts Institute of 
Technology (MIT). 

SUN is a registered trademark of Sun Microsystems. 

UNIX is a registered trademark of AT&T. 


vu 







TABLE OF CONTENTS 


I. INTRODUCTION_1 

A. SOFTWARE DEVELOPMENT.1 

B. RAPID PROTOTYPING.3 

IL B^L^^ICCf^I^IUND S 

A. THE COMPUTER AIDED PROTOTYPING SYSTEM (CAPS).5 

1. The User Interface.5 

2. The Software Database System.7 

3. The Execution Support System.8 

B. THE PROTOTYPING SYSTEM DESCRIPTION LANGUAGE 

(PSDL).9 

1. PSDL Computational Model...11 

in. REQUIREMENTS FOR THE PROTOTYPE OF A GENERIC C^I 

WORKSTATION_17 

A. BACKGROUND.17 

B. THE ESSENTIAL MODEL.17 

1. The Environmental Model.17 

i. The Statement of Purpose.17 

ii. The Context Diagram.18 

iii. The Event List.19 

2. The Behavioral Model.19 

C. IMPLEMENTATION CONSTRAINTS.20 

D. REQUIREMENTS AND CONSTRAINTS FOR 

PROTOTYPING EFFORT.20 

ix 





























1. Unclassified Environment.20 

2. Prototyping Hardware.21 

3. Prototyping Software.21 

4. Implementation Configuration.21 

5. Timing Constraints.21 

IV. PSDL DESCRIPTIONS OF THE PROTOTYPE OF GENERIC 

C3I WORKSTATION_25 

A. GENERIC C3I WORKSTATION.26 

B. COMMUNICATIONS INTERFACE.29 

1. Operator resolve_incoming_messages.34 

i. Operator parse_input_file.36 

ii. Operator decide_for_relaying.36 

iii. Operator decide_for_archiving.37 

iv. Operator extract_tracks.38 

2. Operator resolve_outgoing_messages.38 

i. Operator make.routing.40 

ii. Operator forward_for_translation.41 

iii. Operator forward_for_transmission.42 

iv. Operator conven_to_text_file.43 

3. Operator preparc_periodic_rcport.43 

4. Operator translate.message.44 

C. SENSOR INTERFACE.44 

1. Operator anaiyze_sensor_data.47 

2. Operator normalize_sensor_information.47 

3. Operator prepare_sensor_track.48 

D. TRACK DATABASE MANAGER.49 


X 






























1. Operator update.tracks.52 

i. Operator filter_cotnms_tracks.54 

ii. Operator filter_sensor_tracks.54 

iii. Operator add_conims_track.55 

iv. Operator add_sensor_track.55 

V. Operator inonitor_ownship_position.56 

vi. Operator updatc_the_track.56 

vii. Operator delete_flie_track.57 

viii Operator add_user_track.57 

2. Operator monitor.database.58 

i. Operator chcck_for_timeout_and_range.59 

ii. Operator identify.similarities.60 

E. USER INTERFACE.60 

1. Operator inanage_user_interface.63 

2. Operator get_user_inputs.65 

3. Operator rcsolution_noticc_pancl.65 

4. Operator emergency_status_screen.66 

5. Operator inessage_anival_panel.66 

6. Operator intelligence_rcport_panel.67 

7. Operator get.modiflcation.data.67 

8. Operator status.screen.67 

9. Operator message.editor.68 

10. Operator display.tracks.68 

11. Operator display_graphic_tracks.69 

F. WEAPONS INTERFACE.69 

G. EXTERNAL SYSTEMS.70 


XI 



































1. Operator comms.links.71 

2. Operator sensors.71 

3. Operator navigation.system.72 

4. Operator weapons_systems.72 

G. DATATYPES.73 

V. IMPLEMENTATION OF THE (A WORKSTATION PROTOTYPE 

THROUGH CAPS_79 

A. PREPARING PSDL DESCRIPTION FILE, PSDL.TXT.80 

B. PRODUCING DRIVER PACKAGE, TLA.80 

C BUILDING THE STATIC SCHEDULE, SSA.81 

D. BUILDING THE DYNAMIC SCHEDULE, DS A.81 

E. BUILDING THE SOFTWARE BASE, SBA.81 

VI. CONCLUSIONS AND RECOMMENDATIONS_83 

A, CONCLUSIONS.83 

B. RECOMMENDATIONS.Z..84 

APPENDIX A Data Flow Diagrams.85 

APPENDIX B PSDL Description of the Prototype, psdl.txt.93 

APPENDIX C Driver Package, tl.a.105 

APPENDIX D Static Schedule, ss.a.135 

APPENDIX E Dynamic Schedule, ds.a.145 

APPENDIX F Software Base, sb.a.147 

APPENDIX G An Algorithm to Calculate Minimum Calling Periods 

and Maximum Response Times.265 

APPENDIX H Producing Executable User Interface Code in Ada.275 

APPENDIX I Ada Code for Excluded Functions.281 


XU 





























LIST OF REFERENCES.301 

BIBUOGRAPHY.303 

INITIAL DISTRIBUTION LIST.305 













ABBREVIATIONS 



MEANING 

CAPS 

Computer Aided Prototyping System 

COMMS 

Communicadons 

CWC 

Composite Warfare Commander 

C3I 

Command, Control, Communicadons and Intelligence 

ECM 

Electronic Counter Measures 

EMAIL 

Electronic Mail 

EMCON 

Emissions Control 

EMREP 

Emergency Report 

ESM 

Electronic Suppon Measures 

FIFO 

First In Rrst Out 

INTREP 

Intelligence Report 

MCP 

Minimum Calling Period 

MET 

Maximum Execudon Time 

MRT 

Maximum Response Time 

NGCR 

Next Generadon Computer Resources 

OTH-T 

Over The Horizon Targedng 

PSDL 

Prototype System Description Language 

STATREP 

Status Repon 

TAE 

Transportable Applications Environment 

TCD 

Tactical Command Display 

TD 

Track Database 

TDD 

Track Data Display 

TDM 

Track Database Manager 


XV 










To my father, whom I love very much, but sadly, I don’t have any more 
chance to share moments; 

and to my mother, whom I love very much, and happily, I still have more 
chance to do so. 


Vedat Coskun 










L INTRODUCTION 


This thesis describes the development of a software prototype of a workstation 

■a 

for a Command, Control, Communications and Intelligence (C l) system. 

This chapter presents a brief description of the software engineering problem, cur¬ 
rent methodologies being used, and the major differences between them. The Proto¬ 
type System Description Language (PSDL), the Computer Aided Prototyping System 

'I 

(CAPS) and C l system are also described briefly to provide a foundation for this the- 

■a 

sis. The requirements for C l system, and the detailed stages of prototyping are giv¬ 
en in successive chapters. These chapters are followed with our conclusions and 
recommendations for further research. 

The design of the prototype with PSDL, and prototyping steps through CAPS are 
performed by Cengiz Kesoglu. Vedat Coskun wrote the Ada code for the modules, 
and designed the user interface for the prototype. 

A. SOFTWARE DEVELOPMENT 

Computers are useful only if they perform the functions needed correctly. Most 
computer faults are due to software design errors rather than hardware malfunctions. 
Software engineering is important because software has a large and increasing effect 
on people’s lives, and has a large and increasing cost. Developing reliable, useful, and 
flexible software systems is one of the great challenges facing software engineers 
today [Ref. 1]. 

There exist many methodologies to support software engineering. The two major 
approaches are the waterfall model and the prototyping method [Ref. 2]. 


1 








The waterfall model describes a sequential approach to software development by 
using a bottom-up implementation, as shown in the Figtire 1-1. The use of bottom-up 
implementation is the major weakness in this life cycle. With this approach, nothing 
seems to be produced until the whole system is finished. There are some difficulties 
in the testing phase, because the most trivial bugs are found at the beginning of 
testing period, and the most serious ones are encountered at the last. Unfortunately, 
debugging is extremely hard during this stage since there are thousands of modules 
to search for the bug. Another weakness of the waterfall model is the sequential 
progression. It insists that a phase must be finished completely before starting the 
next one. The requirement analysis stage can be considered as the most critical 



Figure 1>1. The Waterfall Model 

phase, since the errors made during this phase effect the rest of the project very 
seriously. Because the user begins to see the important results only after coding 


2 











phase ends, if there are some decisions done at the design phase that the user does 
not approve, which is a usual case, lots of effort will be lost, since much work is done 
based on that wrong design decisions. Improvements in the user’s understanding of 
what the system will be like when it is completed would be very helpful if they can be 
achieved before much effort is spent. 

B. RAPID PROTOTYPING 

The demand for large, high-quality systems has increased to the point where a 
jump in software technology is needed. Rapid prototyping is one of the most 
promising solutions to this problem. Rapid prototyping is particularly effective for 
ensuring that the requirements accurately reflect the user’s real needs, increasing 
reliability and reducing costly requirement changes [Ref. 3]. 

Figure 1-2 illustrates the prototyping process. In prototyping cycle, the system 
designer and the user work together at the beginning to determine the critical parts of 
the proposed system. Then the designer prepares a prototype of the system based on 
these critical requirements by using a prototype description language. The resulting 
system is presented to the user for validation. During these demonstrations, the user 
evaluates if the prototype behaves as it supposed to do. If errors arc found at this 
point, the user and the designer work together again on the specified requirements 
and correct them. This process continues until the user determines that the prototype 
successfully captures the critical aspects of the proposed system. Then designer uses 
the prototype as a basis for designing the production software [Ref. 4]. 

The rapid iterative construction of prototypes within a computer aided 
environment automates the prototyping method of software development and is called 
rapid prototyping\Rtf. 5]. The potential benefits of prototyping depend critically on 
the ability to modify the behavior of the prototype with less effort than required to 
modify the production software. Computer aided and object-based rapid prototyping 
provides a solution to this problem. 


3 






Figure 1-2. The prototyping cycle 


4 








n. BACKGROUND 


A. THE COMPUTER AIDED PROTOTYPING SYSTEM (CAPS) 

An integrated set of computer aided software tools, the (Computer Aided 
Prototyping System, has been designed to support prototyping of complex software 
systems, such as control systems with hard-real-time constraints. 

If carried out manually, the prototyping process has limited benefits because of the 
time and effon involved. CAPS can increase the leverage of the prototyping strategy 
reducing and adapting a prototype to perceived user needs. 

The main components of CAPS are The User Interface, The Software Database 
System, and The Execution Support System, as shown in the Figure 2-1. Since the 
CAPS system is a new approach, there is ongoing research on some aspects of it, and 
the system is not finished yet. 



Figure 2-1. CAPS Components 


I. The User Interface 

The user interface aids evolution by providing facilities for entering 
information about the requirements and design, presenting the results of prototype 


5 













execution to the customer, guiding the choice of which aspects of the prototype to 
demonstrate, and helping the designer propagate the effects of a change. The user 
interface consists of a Syntax-directed Editor with graphic capabilities, an Expert 
System for communicating with end users, and a Browser, as shown in Figure 2-2. 
PSDL is the main con^nent of the user interface, and will be explained in the next 
part 



Figure 2*2. User Interface Components 


The Graphic Editor is a tool which permits the designer to specify the 
portions of PSDL prototype using graphical objects to represent the system. 
Graphical objects include Operators, Inputs, Outputs, Data Flows, and Self Loops on 
operators [Ref. 6]. 

The Syntax Directed Editor is used by the designer to enter the textual 
portions of the prototype design not represented by the graphic editor in order to 
completely represent the system [Ref. 4). 

The Browser provides the ability for the designer to view the reusable 
components in the software base [Ref. 4]. 


6 











The Expert System provides the capability that generates English text 
descriptions of PSDL specifications. This tool permits the understanding of PSDL 
components to the users who are not familiar with them. 

2. The Software Database System 

The Software Database System provides reusable software components for 
realizing given functional (PSDL) specificadons, and it consists of Design Database, 
Software Base. Software Design Management System, and Rewrite System as shown 
in the Figure 2-3. 



Figure 2-3. Software Database System Components 


The Design Database contains PSDL prototype descriptions for all software 
projects developed using CAPS [Ref. 4]. 

The Software Base contains PSDL descriptions and implementations for all 
reusable software components developed using CAPS [Ref 4]. 

The Software Design Managements System manages and retrieves the 
versions, refinements and alternatives of the prototypes in the design database and 
the reusable components in the software base [Ref 4]. 


















The Software Base speeds up evolution by providing many different versions 
of conomonly used components, making it easier to try out alternative designs. In the 
PSDL prototyping method, modules are realized by three main mechanisms; 

1. Retrieval of suitable components from the Software Base. The Software 
Base contains generic modules with parameters determined as part of the retrieval 
process. It also contains rules for matching a specification by means of a composite 
operator realized by a network of operators, at least one of which must be an 
available reusable component. The retrieval mechanism can therefore perform some 
routine aspects of bottom-up design, freeing the designer from the need to be familiar 
with all of the reusable components in the software base. 

2. Decomposition of the component into a network of simpler components. 
The designer does this if the component can not be retrieved directly from the 
Software Base, and if the component is sufficiently complex to benefit from 
decomposition into simpler parts. 

3. Direct implementation in a programming language. This is essential if the 
Software Base does not contain a component that performs the required function with 
the required speed. 

3. The Execution Support System 

The Execution Support System contains of a Translator, a Static Scheduler, a 
Dynamic Scheduler, and a Debugger as shown in the Figure 2-4. 

The Translator generates code that binds together the reusable components 
extracted from the software base. Its main functions are to implement data streams, 
control constraints, and timers. 

The Static Scheduler allocates time slots for operators with real time 
constraints before execution begins. If the allocator succeeds, all operators are 
guaranteed to meet their deadlines even with the worst case execution times. If the 
static scheduler fails to find a valid schedule, it provides diagnostic information useful 


8 






for determining the cause of the difficulty and whether or not the difficulty can be 
solved by adding more processors. 



Figure 2*4. Execution Support System Components 

As execution proceeds, the dynamic scheduler invokes operators without 
real-time constraints in the time slots not used by operators with real-time 
constraints. 

The Debugger allows the designer to interact with the execution support 
system. The Debugger has facilities for initiating the execution of a prototype, 
displaying execution results or tracing information of the execution, and gathering 
statistics about a prototype’s behavior and performance. 


B. THE PROTOTYPING SYSTEM DESIGN LANGUAGE! PSDL) 

CAPS tools communicate by means of PSDL, which integrates the tools and 

provides the prototype designer with a uniform conceptual framework and a high level 

description of the system. PSDL supports frequent design modifications by meeting 

the subgoals Modularity, Sin^licity, Reuse, Adaptability, Abstraction, and 

Requirements Tracing. 

Modularity is important for easy modification, and is supponed by PSDL via 
operators and data streams. Good modularity means that the prototype should be 


9 















realized by a set of independent modules with narrow and explicitly specified 
interfaces. 

PSDL is simple and easy to use because it contains a small number of powerful 
constructs. Designs are described in PSDL as networks of operators connected by 
data streams. These networks can be represented as dataflow diagrams augmented 
with control and timing constraints. The operators in the network can either be 
functions or state machines. The data streams can carry exception conditions or 
values of arbitrary abstract data types. 

PSDL supports reusable components with uniform specifications suitable for 
retrieving modules from a software base. The specification part of a PSDL component 
contains several attributes that describe the interface and behavior of the component 

PSDL supports adaptability of modules by making small modifications to them 
when necessary, by means of control constraints. Control constraints can be used to 
impose preconditions on the execution of a module, to add filters to the output of a 
module, to suppress or raise exceptions in specified conditions, and to control timers. 
These facilities allow small modifications to the behavior of a module to be expressed 
independently of its implementation. 

A set of abstractions suitable for describing complex software systems with real¬ 
time constrains is important, and hence PSDL provides abstractions suitable for 
describing large systems and real-time constraints. These include the nonprocedural 
control constraints such as timing constraints, and timers. Examples of timing 
constraints include the maximum execution time, the maximum response time, and 
the minimum calling period. Timing constraints implicitly determine when operators 
with hard-real-time constraints will execute. This sinq)lifies evolution by removing 
explicit scheduling decisions from the design, thus allowing a software tool rather 
than the designer to handle rescheduling caused by design changes. 

Requirements tracing is important because the prototype must adapt the changing 
perceptions of the requirements resulting from demonstrations of prototype behavior. 


10 






PSDL supports requirements by means of a constmct for declaring the requirements 
associated with each part of the prototype. 

1. PSDL Computational Model 

PSDL is based on a computational model. Formally it is an augmented 
graph. The form of the computational model is: 

Graph = (Vertex, Edge, Time(Vertex), Constraint(Vertex)) 

This implies that each graph is represented by its set of vertices, set of 
edges, set of maximum execution times for each vertices, and set of constraints for 
each vertices. 


20 ms 



Figure 2-5. A PSDL Graph Example 

An example of a PSDL graph is shown in the Figure 2-5. In this graph, 
operator translate message takes the input incoming message, outputs into 
translated message, and whole process should take a maximum of 20 milliseconds, 
as the value of time constraint. 

Operators are state machines, and the internal state is modeled by a set of 
state variables. Operators with empty set of state variables behave like functions. 
Operators may be either atomic or composite. Atomic operators represent single 
operations and not need to be decomposed into other operators. 

Data streams arc data which move between operators. They are cither data¬ 
flow streams or sampled data streams. Data-flow streams in PSDL act as FIFO 
buffers of capacity one, and are used for synchronizing data-driven computations. 


11 








Data-flow streams guarantee that each of the data values written into the stream is 
read exactly once. Sampled streams in PSDL model are streams for which only the 
most recent information is meaningful. One distinction between sampled streams and 
data flows streams is that reading a data value from stream does not remove it from 
the stream. 

Operators may be triggered by data streams and/or periodic timing constraints. 
Operators triggered by data streams are called sporadic, and operators triggered by 
periodic timing constraints are called periodic. 

Every time critical sporadic operator has a maximum response time (mrt) and a 
minimum calling period (mcp) in addition to a maximum execution time (met). 

The met is the upper bound on the length of the time between the instant when a 
tiKxlule begins execution and the instant when it completes execution. 

The mrt defines an upper bound on the dme that may elapse between the point in 
time at which an operator is activated to read flom its input streams and the time 
when its write event occurs. 

A mcp defines a lower bound on the time between two successive activations of 
the read transitions of operator f (Figure 2-6). The mcp can be considered as the 
window of opportunity for the operator to use, and the mrt as the used portion of it. 

Periodic operators are triggered by temporal events and must occur at regular time 
intervals. For each operator f, these time intervals are determined by the specifled 
period (OPERATOR f PERIOD t) and deadline (OPERATOR f FINISH WITHIN t). 

The period is the time interval between two successive activation times for the 
read transition of a periodic operator. 


12 







mcp 


mrt 

wrote activated 

to read 

Figure 2*6. MCP and MRT of an Operator 

The deadline defines an upper bound on the occurrence time of the write transition 
of a periodic operator relative to the acdvadon of its read transidon. By default, the 
deadline is equal to the maximum execudon dme, and a stadc feasibility constraint 
requires that deadline must be greater than or equal to maximum execudon dme 
(Figure 2-7). 



acdvated wrote acdvated 

to read to read 

Figure 2-7. Period and Deadline of an Operator 


The difference between the acdvadon dme of a read transidon and the deadline for 
the corresponding write transidon is called the scheduling interval. The scheduling 
intervals of a periodic operator can be viewed as sliding windows, whose posidon on 
dme axis relative to each other is fixed by the period, and whose absolute posidon on 




acdvated 
to read 


13 










the time axis is fixed by the occunence time tQ of the first read transition. This time 

may vary within the interval 0 to period of the operator (Figure 2-8). 

sdieduling interval 



Figure 2-8. Scheduling Interval 

The control constraints and the timing constraints determine both the 
conditions under which the operators are triggered and the buffering disciplines for the 
data streams. Control constraints can express conditional execution and output, and 
can control exceptions and timers. 

Triggering conditions and guarded outputs are expressed by predicates. If an 
input stream is guarded by a triggering condition, input data which do not satisfy the 
condition are read from the stream but do not fire the ''"erator. Similarly, guarded 
output streams of an operator prevent the snecifieu output data from being written 
into the guarded streams if the output guard conditions are not satisfied. 

Synchronization between different operators in PSDL is achieved by 
precedence constraints. These constraints are introduced by data streams as follows. 

Data-flow streams ensure that values are not read until they are written, 
and that a value is not overwritten before it has been read. This property ensures that 
transactions are not lost or repeated, and can be used to correlate data from different 
sources, such as preprocessor operators operating in parallel. 

Sampled streams cannot guarantee that values will never be overwritten 
before they arc read. The purpose of a sampled stream is to provide the most recent 
available version of data. 


14 









The precedence constraints associated with sporadic operators are implicit 
Periodic operators are triggered by temporal events rather than by arrival of data 
values, and in certain conditions the precedence constraints can affect these timing 
constraints. 


15 






m. REQUIREMENTS FOR THE 
PROTOTYPE OF A GENERIC C^I WORKSTATION 

A. BACKGROUND 

A Command, Control, Communications and Intelligence (C^I) System assists the 
commander in understanding a tactical situation within his geographical area of 

responsibility. The generic C^I woricstation would be designed to be implemented on 
a wide variety platforms, in support of a Composite Warfare Commander (CWC) 
command and control architecture. The workstation would provide the CWC and his 
subordinate commanders and coordinators with a system that supports them in 
monitoring air, surface, subsurface, and power-projection (strike) tactical 
environments, and aid in tactical decision making in those areas. The architecture 
provides for connectivity between naval platforms, shore-bases, and external forces 
and information sources, and enables the processing of tactical data from internal and 
external sources [Ref. 7]. 

Requirements for the generic C^I workstation is given in great detail in the thesis 
written by Steven E. Anderson [Ref. 7]. A summary of his study will be provided in 
this chapter as a basis for the prototyping of the C^I workstation. 

B. THE ESSENTIAL MODEL 

1. The Environmental Model 

i The Statement of Purpose 

The purpose of the generic C^I workstation is to provide commonality 
and connectivity between naval platforms and land bases by providing the ability to 


17 





process, in real-time, tactical data from many interfaces. This includes the ability of 

the C l workstation to receive and transmit command and control data via 
communications links, to receive track informadon from organic platform sensors, to 
provide a tactical display interface to the user, to provide a modem text editor for 
generating and forwarding communications messages, and to provide a means for 
verifying track data integrity. 

iL The Context Diagram 

In the Yourdon Environmental Model, the context diagram shows the 
external interfaces with which the designed system communicates. For C^I 
workstation, these external interfaces are the users, weapon systems, platform 
sensors, navigation system, and communications links. The context diagram is given 
in Figure 3-1. 



Figure 3*1. The Context Diagram 


18 








HI. The Event Ust 


The following is an infonnal list of events that occur outside of the 
generic C^I workstation and invoke a response from the station. This list represents a 
list of generic stimuli that could apply to any specific C^I workstation inq)lementation. 

• Network communications message received (via communications 
links). 

• Sensor system data update received. 

• Weapons system change of status received. 

• Navigation system updates own-ship navigation information. 

• User chooses to view track tuple information (textually). 

• User chooses to manually add new track to database. 

• User chooses to manually modify existing track data. 

• User chooses to manually delete track from database. 

• User chooses to view own-ship weapon status. 

• User chooses to view track data (graphically). 

• User chooses to generate a message. 

• User enters message text. 

• User chooses to read a message. 

• User chooses to set system parameters: initiate transmission se¬ 
quence. 

• User chooses to set system parameters: set monitor constraints. 

• User chooses to set system parameters: archive set-up. 

• User chooses to set system parameters: set track filter. 

• User chooses to set system parameters: reporting set-up. 

• User chooses to set system parameters: network set-up. 

• User chooses to set system parameters: set monitor constraints. 


2. The Behavioral Model 

Yourdon Behavioral Model provides an informal means for describing the 
internal behavior of the proposed software system. It consists of data-flow diagrams, 
process specifications for the atomic modules, and the data dictionary. Level 0 
diagram and the data flow diagrams for the first level decomposition are given in 


19 









Appendix A. The detailed decomposition for PSDL is based on these first level 
decompositions, which will be discussed in further chapters. 

C. IMPLEMENTATION CONSTRAINTS 

The following constraints are specified in the functional specifications document 
for a generic C^I workstation [Ref. 7]: 

• Software must adhere to Department of Defense Military Standard 2167-A 
D^ense System Software Development, 29 February 1988 (or latest revi¬ 
sion) and Department of Defence Military Standard 2168 Defense System 
Software Quality Program, 29 April 1988 (or latest revision). 

• The performance constraints for the generic C^I workstation include hard-re¬ 
al-time information processing and display. Since the current systems are so 
antiquated, it is somewhat unknown exactly how well such a system can 
perform. Hence, a policy of "best possible performance" will be adopted 
while looking at the system performance constraints. 

• When interacting with information from multiple sources, the nx>st recent in¬ 
formation should be displayed, unless specified otherwise by the user. 

• The implementation constraints are somewhat sketchy at present. With to¬ 
day’s technology, it is possible to implement such a system on a 100 MIPS 
class machine (such as a militarized SUN workstation). However, the soft¬ 
ware developed must be modular and anticipate the portability of this sys¬ 
tem, as much as possible, onto other machines in the future. Careful 
attention must be paid to distributed architectures in the design and imple¬ 
mentation of this software. 

• The system hardware must also provide for a "modem" computer interface 
including color graphics, windows/menus, rimuse/trackball mechanism, key¬ 
pad, etc. in keeping with the Next Generation Computer Resources (NGCR) 
effon. 

D. REQUIREMENTS AND CONSTRAINTS FOR PROTOTYPING EFFORT 

I. Unclassified Environment 

Since most C^I systems and procedures are classified, many generalizing 
assumptions will be made for the prototype system. Arbitrary representative data 
values have been provided. The OTH-T Gold Reporting Format has been chosen to 


20 






serve as the basis for the prototyping examples since it is both character oriented and 
unclassified. 


2. Prototyping Hardware 

The generic C^I workstation will be implemented on a commercially available 
Sun Microsystems workstation operated by the Naval Postgraduate School Coii^uter 
Science Department, with the goal of producing software directly transferable to the 
Genisco Woricstation. 

3. Prototyping Software 

The Sun Microsystems workstation operating system is derived from UC 
Berkeley Version 4.2BSD and Bell Laboratories’ UNIX System Version 32V. 

TAB Plus, a windowing software package developed by NASA Goddard, will 
be used to generate the user interface to the generic C^I workstation. 

In accordance with Department of Defence policy, Ada shall be used as the 
implementation language for the prototype. 

4. Implementation Configuration 

Initial prototyping efforts will focus on a single user system with multiple 
weapons, sensors, and external communications (Figure 3-2). 

5. Timing Constraints 

• The Inertial Navigation System updates the ownship velocity every 40.96 
ms and transmits this nominally every 983.04 ms. The latitude and longitude 
are updated every 1.3 seconds. 

'I 

• Provisionally the Generic C l Workstation should be capable of retrieving 
data from up to (potentially) 1000 tracks in less than 1 second. 

• The time difference between receiving a track data message by the system 
and entering its contents into the track database should be less than 2 sec¬ 
onds. 


21 









Figure 3*2. Single User Generic C^I Workstation 


• Provisionally for prototyping purposes, the maximum numt^ of tracks per 
sensor will be assumed to be 100 tracks per second. 

• System response times for man-machine interface are as given in Table 3-1: 


TABLE 3-1. Dialogue Type Versus System Response 


Dialogue Type 

Question and Answer 
Menu Selection 
Form Filling 
Function Keys 
Comnuuid Language 
Natural/Query Language 
Graphic Interaction 


System Response Time 

0.5 to less than 2 seconds 
less than 0.2 seconds 
greater than 2 seconds 
less than 0.2 seconds 
0.5 to greater than 2 seconds 
0.2 to less than 0.5 seconds 
less than 0.2 seconds 


22 

















• System response times for ingressing and egressing communications mes¬ 
sages are provided in Table 3-2. 


TABLE 3>2. Message Priorities and System Response 



Time Between Message 
Comnletion and Transmission 

Time Between Message 
Reception and Disolav 

FLASH 

Very Fast 

(less than 1 second) 

Very Fast 

Gess than 1 second) 

IMMEDIATE 

Fast 

Oess than 2 seconds 

Fast 

Gess than 2 seconds 

PRIORITY 

Moderate 

(less than 3 seconds 

Moderate 

Gess than 3 seconds 

ROUTINE 

Slow 

Gess than 4 seconds) 

Slow 

Gess than 4 seconds) 


• Provisionally a nominal weapon status update rate would be once every sec¬ 
ond. 


23 





rv. PSDL DESCRIPTIONS OF THE PROTOTYPE OF 


GENERIC C^I WORKSTATION 


Based on the system requirements given in the previous chapter, it is possible to 
constract a module decomposidon diagram, consisting of modules that are responsible 
for implementing these requirements. The first level noodule decomposition is given in 
Figure 4-1. Modules in this diagram will be decomposed into lower levels to show 


the implementation of the higher level module requirements. A detailed description of 



Figure 4-1. First Level Module Decompo^tion 


25 

























each module with its corresponding PSDL prototype description will be presented in 
following sections. 

Conans Links, Sensors, Navigation System and Weapons Systems modules are ac¬ 
tually external to the prototype, and should not be included in the modular decomposi¬ 
tion. However, the prototype workstation will need their data, so these modules are 
included in the prototype to simulate the related external systems. 

A. GENERIC C^I WORKSTATION 

This module is responsible for the complete implementation of the system 
described. This is the highest level module, and includes the communications 
interface, the sensor interface, the track database manager, the user interface, and 
the weapons interface along with the modules simulating the external interfaces. 

The periods of the external interface simulators are determined according to the 
total maximum execution times of the atomic operators in the system. Other timing 
constraints given at thi<: - a are calculated based upon the requirements, and will be 
explained with the rcir jd operator explanation. The PSDL description follows: 

OPERATOR c3i_system 

SPECIFICATION 

DESCRIPTION { This module is responsible for the imple¬ 
mentation of the complete generic C^I 
workstation } 

END 

IMPLEMENTATION 

GRAPH 


26 







sensors 



27 










DATA STREAMS 

8ensor_rocord, 
oimship_navigation__in£o, 
filename, 
weapon_8tatus, 
filename, 

intelligence__report, 
archive_8etup, 
reaolution_notice, 
initiate_tran8mi88ion_8equence, 
boolean, 

8et_track_filter, 
8et_monitor_con8traint8, 
t ran 8mi t_command, 
emi 8 8 ions__cont rol_command, 
networ]c_8etup, 
weapon_8tatu8_report, 
weapon_8tatu8_report, 
add__t rac]c_tuple, 
add_track_tuple, 
update_track_tuple, 
delete__t rack_tuple, 
add__t rack^tuple, 
track_tuple 

CONTROL CONSTRAINTS 

OPERATOR comm8_interface 
OPERATOR 8en8or__interface 

MINIMUM CALLING PERIOD 2.5 ms 
MAXIMUM RESPONSE TIME 500 ms 
OPERATOR track_database_jaanager 
OPERATOR user__interface 
OPERATOR weapons^^interface 

TRIGGERED BY S^ffi weapon__status_data 
OUTPUT weapon8_emrep IF 

weapon^status^data.status ^ damaged OR 
weapon_statu8_data.status « service_required OR 
weapon_8tatus_data.status » out_of_ammunition 
MINIMUM CALLING PERIOD 250 ms 
MAXIMUM RESPONSE TIME 500 ms 
OPERATOR comms^links 
PERIOD 10 sec 
OPERATOR sensors 


sen8or_aara 

po8ition_data 

input__l ink_me s sage 

weapon_8tatu8_^data 

comms^email 

8en8or__intrep 

tdd__archive_8etup 

tdm_resolution_notice 

initiate_trans 

terminate_tran8 

tdd__filter 

tdd^constraints 

tcd_tran8mit_command 

tcd_emission_control 

tcd_network_8etup 

weapon 8_emr ep 

weapons_statrep 

comms_add_track 

8ensor_add_track 

update__track 

delete_track 

add_track 

out tracks 


28 






PERIOD 10 sec 
OPERATOR navigation^systeffl 
PERIOD 10 sec 
OPERATOR ffEAPONS_SYSTEMS 
PERIOD 10 sec 

END 

B. COMMUNICATIONS INTERFACE 

The Communications Interface performs those functions directly related to the 
reception and transmission of the communications messages. Because of the 
differences between the stations utilizing the communications equipment, this module 

will vary greatly from one instantiation of a generic C^I workstation to another. As it 
was recommended in the requirements analysis [Ref. 7], implementation of this 
module is highly modularized. 

Communications messages which arrive at the interface will be analyzed to 
determine if they contain track information, if they need to be relayed to other 
participants in the network, or if they need to be archived for future reference. 

This interface will need to monitor, relay and transmit messages on the various 
link networks. It performs filtering functions on incoming messages, address routing, 
track precedence sorting and message format translation. 

For prototyping purposes, as proposed in the requirements analysis, the primary 
communications systems of interested will be JTIDS, LINK-11, LINK-16, and 
OTCKS. 

The complete modular decomposition of the communications interface is given in 
Figure 4-2. 


29 









30 














The tuning constraints related to this interface follow ; 

• For incoming messages, time between message reception and display varies 
between less than 1 second and less than 4 seconds, depending upon the pre¬ 
cedence of the incoming message. The prototype is designed to be fast enough 
to handle the highest precedence message. Thus the system shall display any 
incoming message within 1 second after arriving at the interface. On the data 
flow path for a message from the communicadons interface to the CRT there 
are luany operators, and these are limited with 500 ms to process on the mes¬ 
sage. 

• Similarly, requirements state that each outgoing message should be transmit¬ 
ted between 1 second and 2 seconds depending on the precedence. Again the 
prototype is designed to be limited with the lower boundary. Thus each outgo¬ 
ing message shall be processed and forwarded within 1 second after arriving 
at the interface. 

• There is no time constraint for periodic track reports in the requirements. The 
prototype is designed to produce periodic track report every 2 seconds when 
this feature is activated. 

These timing constraints are reflected on the submodules as minimum calling peri¬ 
ods and maximum response times. 

Based on the speeds of the links connected to the workstation (1300-5000 
bits/sec), and the assumption that the shortest navy message is about 100 characters 
(8(X) bits, if start/stop bits and redundant data are neglected), the system will receive 
a maximum of 25 messages from 4 corrununications links in 1 second. Therefore, the 
operator resolveJncomingjnessages has 5(X) ms to handle 12.5 messages, and its 
minimum calling period is 5(X) / 12.5 = 40 ms. Maximum response time is 500 ms as 
indicated above. 

The maximum number of messages arriving at the operator re¬ 
solve outgoing messages in 1 second is calculated as follows: 

• 1 message/2 sec from periodic operator prepare_track_report. 

• 12.5 messages/sec to relay ( an assumption that half of the messages that 
the system received should be relayed). 

• 1 message/ sec from the user (an assumption). 


31 





So totally there are 14.5 messages to process within 1 second. Thus the minimum 
calling period for this operator is 1000 / 14.5 = 68.9 ms. Maximum response time is 
1000 im as given by the constraint. 

Maximum execution times for operators are determined such that the addition of 
maximum execution times for a certain process does not exceed the maximum 
response time of that process. The PSDL description follows; 

OPERATOR conim8_inter£ace 

SPECIFICATION 

INPUT i^put__linlc_m«8saga : filename, 

tcd_tran8mit_command : tran8mit_command, 
tcd_emi88ion_control : emi88ion8__control__command, 
tcd_nettrorlc_8etup : networ]c_8etup, 
tdd_archive_8etup : archive__8etup, 
initiate_tran8 : initiate_tran8ml88ion_ 

aequence, 

tezminate^trana : boolean 

OUTPUT coinm8_email : filename, 

comm8_,add_track : add_traclc_tuple 

DESCRIPTION { Thia operator ia reaponaible for proceaa** 
ing incoming and outgoing meaaagea aa 
well aa producing periodic track reporta 
and format tranalating } 

END 

implementation 

GRAPH 


32 





tdd.archive.setup 



DATA STREAMS 

raw_mes8age : tran8lation_contmand, 
readyjne88age : tran8mi88ion_coinmand 
CONTROL CONSTRAINTS 

OPERATOR re 8 olve__incoming_me 8 s age 8 


33 





KENIMOM CALLING PERIOD 40 as 
MAXIMON RESPONSE TIME 500 as 
OPERATOR resolvtt_outgoing_attssaga8 
MINIMUM CALLING PERIOD 68.9 as 
MAXIMUM RESPONSE TIME 700 as 
OPERATOR trsnslsts^assssgs 

TRIGGERED BY SOME rsw^assssgs 
OPERATOR prapars_p«riodic_rsport 
PERIOD 2 sac 

TRIGGERED IF not tarminata_trans 

END 


Detailed explanations of the decomposed composite operators are provided 
below with their PSDL descriptions. 

i. Operator resolve_incoming_messages 

The primary function of this operator is to process communications messages 
received from the connected links. The operator is still complicated for implementation 
and it is decomposed into four atomic operators as shown in the graph in the PSDL 
description. 

Timing constraints for the operators are given arbitrarily, but the total 
execution time for the operators is less than or equal to the maximum response time 
of the operator resolve_incoming_messages. 

Some input and output guards, and triggering conditions are specified in the 
implementation pan of the PSDL description, and they will be explained under the 
definitions of the atomic operators. The PSDL description follows: 

OPERATOR resolv«__incoiaing_mttssages 
SPECIFICATION 

INPUT input_link__in«sssgs : filsnams, 

tcd_natwork_satup : natwork_satup, 

tdd archiva setup : archiva_satup 


34 








OUTPUT coinms_jainail : filename, 

coinms__add__track : add_trac]c_tuple/ 

tcd_tran8mit_jcoinmand : transmit__coinmand 
DESCRIPTION { This operator processes the incoming 
communications messages } 

END 

implementation 

GRAPH 



DATA STREAMS 

input_text__record ; text_record, 
comms text file : text record 


CONTROL CONSTRAINTS 

OPERATOR par8e_input_file 

TRIGGERED BY S^4E lnput_lin]c_message 


35 

















OPERATOR dacldai_for_r«laylng 

TRIGGERED BY SOME input_text_7acord 
OUTPUT tcd_transmlt_jcoinmand IF 

lnput_text_record.relayed 
OPERATOR decide_for_arc2iiving 

TRIGGERED BY SOME input_text_record 
OUTPUT coinnis_text^file IF coinm8_text_flie.archive, 
OUTPUT coiBais_email IF MOT input_text_record.i8_track 
OPERATOR ex1:ract_track8 

TRIGGERED IF coiBias_text_file. i8_track 

END 


The atomic operators resulting from the decomposition are explained below. 

L Operator parsejnputjile 

This is an atomic operator responsible for parsing the incoming 
communications message and writing the data in the message in an Ada record type 
for further processing. It is a sporadic operator, and triggered by input_link_message. 
The PSDL description follows: 

OPERATOR parse__input_file 
SPECIFICATION 

INPUT input_link_me88age : filename 

OUTPUT input_text_record : text_record 

MAXIMUM EXECUTION TIME 250 m8 

DESCRIPTION ( Paraea the input atring and writea the 
data in a record type } 

END 

implementation Ada par8e_input_file 

END 


ii. Operator decide_for_relaying 

This is a sporadic operator triggered by input_text_record as specified 
one level above. Depending on the network conditions described in variable 


36 






tcd_nctwork_setup, and the address fields in input_text_recoid, this operator outputs 
tcd_transnut_coniniand. As it was determined by the control constraints of this 
operator, output is guarded, and this guarding flag (tcd_transmit_comniand.texUelay) 
is set by the operator depending on the conditions explained above. The PSDL 
description follows: 

OPERATOR d«cid«_for__r«l«ying 

SPECiriCATIOM 

INPUT tcd_ntttirork_8«tup : network__8atup, 
input_tttxt_rttCord : tttxt__r8cord 

OUTPUT tcd_tran8mit_coinmand : tran8init_coinmand 

MAXIMUM EXECUTION TIME 50 m8 

DESCRIPTION { Ch«ck8 the input mes8age record if it ia 
needed to be relayed } 

END 

implementation Ada decide_for__relaying 

END 

tt*i. Operator decide_for_archmng 

There are two main functions performed by this atomic operator. First, 
it is triggered by the input_text_recoid and depending on the tdd_archive_setup 
conditions, the output guard flag for comms_tcxt_filc (comms_tcxt_filc.archivc) is set. 
Second, the input_text_record is checked if it contains track information. This will set 
the output guard flag for comms.email (input_text_TecoTd.is_track). Depending on the 
value of this last flag cither comms_email will be placed on the output stream, or the 
next operator extract_tracks will be triggered as determined by its input guard. The 
PSDL description follows: 

OPERATOR dacide__for__archiving 

SPECIFICATION 

INPUT input__text_r8cord : text__record, 

tdd archlv8_8etup : archiva_8«tup 


37 






OUTPUT coinm8_t«xt_fil« : t«xt_r«cord, 

comms^junxil : filanama 

lAXIMUM EXECUTION TIME 100 B8 

DESCRIPTION { Chacks if tha input fila is naadad to ba 
archivad/ and sats tha is_track flag 
dapanding on tha input data } 

END 

implementation Ada dacida_for_archiving 
END 


iv. Operator extractjracks 

This sporadic operator is triggered if the coinms_text_file.is_track flag 
is set to true by the previous operator, and extracts the tracks from the input variable. 
Then the operator puts them into the output stream. The PSDL description follows; 

OPERATOR axtract^tracks 
SPECIFICATION 

INPUT coinm8_taxt_fila : taxt_racord 

OUTPUT coiiims_add_track : add__track^tupla 

MIOCIMUM EXECUTION TIME 100 ms 

DESCRIPTION ( Extracts tha tracks from coinms_taxt_fila 
and writas tham into add_track } 

END 

IMPLEMENTATION Ada axtract_tracks 
END 


2. Operator resolvejoutgoingjmessages 

This operator performs the functions for processing all messages for 
transmission. It is decomposed into four atomic operators. Maximum execution times 
for the operators are again given arbitrarily, and the triggering and guarding conditions 
will be explained later with the atomic operators. The PSDL description follows: 


38 







OPERATOR resolve_outgoing_mossages 
SPECIFICATION 

INPUT tcd_transinit__coininand : tran8mit_cosimand, 

tcd_aiiiiS8ion_control : emi88ion8_con'trol_coinmand, 
tcdjaatwork__8etup : network__ 80 tup, 
ready^nie88ag« : tran8mi88ion__co]nmand 

OUTPUT raw^iaes8age : tran8lation_c(»Bmand 

DESCRIPTION { Ttii8 operator procesaea the outgoing 
measagea } 

END 

implementation 

GRAPH 



DATA STREAMS 

outputjneaaagea : meaaage^liat, 

tranamiaaionjmeaaage : tran3mi88ion__coinmand 
CONTROL CONSTRAINTS 
OPERATOR make__routing 

TRIGGERED BY S^IE tcd tranamit command 


39 





OPEMITOR £orward__for_tranalation 

TRIGGERED BY SOME tran8mis8ion_oittS8ag« 
OUTPUT rawjna888gtt IF tranalata, 

raady_ma88aga IF NOT tranalata 
OPERATOR forward_for^tran8ml88ion 

TRIGGERED BY SOME tcd_a9il88ion_control, 

ready_jae8 8aga 
OUTPUT outputjDM88age8 

IF tcd_ainl88ion__control.no_^8ilance 
OPERATOR convart_to_t8xt_fil8 

TRIGGERED BY SOME output_me88age8 

END 


The details of the atomic operators with their PSDL descriptions are below. 

L Operator make_routing 

This operator prepares the routing field of the transmission.message 
depending on the tcd_netwoik_setup (it determines which station is in which link), 
and the addresses of the tcd_transmit_command when triggered by the 
tcd_transmit_command as explained in triggering conditions. The PSDL description 
follows: 

OPERATOR inak«_routing 

SPECIFICATION 

INPUT tcd_natwork_8atup : network_8etup, 

tcd_tran8mit__coimnand : tranamit^^command 
OUTPUT traxi8mi88ion_me88age : tran8mi88ion__coinmand 
MAXIMUM EXECUTION TIME 300 ma 
DESCRIPTION { Preparea the routing field of 
tran8mi88ion_me88age } 

END 

implementation Ada make_routing 

END 


40 






iL Operator forward_for_transIation 

This atomic operator is implemented as a state machine with the 
state variable translate. It decides if the transmission_message requires translation 
depending on the format of the message and the links on which it is going to be 
transmitted. If the format of the original message is not compatible with the formats 
allowed in transmission link, than it is necessary to translate it to the appropriate 
format for that link. The state variable is set upon this decision, and output guard 
determined in one level above checks for the value of this flag. 

As it is explained in requirements document [Ref. 7], the message 
formats used in communications links are classified. Therefore, for prototyping 
purposes a graph similar to one in Figure 4-3 is used. 


COMMUNICATIONS COMMUNICATIONS 

FORMAT( A ) FORMAT( B ) 


MESSAGE TYPE «A1 
MESSAGE TYPE «A2 
MESSAGE TYPE «A3 
MESSAGE TYPE #A4 
MESSAGE TYPE «A5 
MESSAGE TYPE #A6 
MESSAGE TYPE «A7 
MESSAGE TYPE #A8 
MESSAGE TYPE «A9 
MESSAGE TYPE #A10 


MESSAGE TYPE «B1 
MESSAGE TYPE «B2 
MESSAGE TYPE #B3 
MESSAGE TYPE «B4 
MESSAGE TYPE «B5 
MESSAGE TYPE «B6 
MESSAGE TYPE «B7 
MESSAGE TYPE «B8 
MESSAGE TYPE #B9 
MESSAGE TYPE «B10 



Figure 4>3. Notional Message Translation Mapping[6] 


The PSDL description follows: 


OPERATOR forward_for_translation 
SPECIFICATION 

INPUT tran8mi88ion_massage : trans8iis8ion__coinmand 
OUTPUT raw_me88age : tran8lation_coininand, 

ready_me88age : tran8mission^coxDmand 

STATES tran8late : boolean INITIALLY false 


41 








lAXZMDM EXECUTION TIME 100 AS 

DESCRIPTION { checks if HMSsage is needed to be 

translated, and sets the state variable } 

END 

IMPLEMENTATION Ada forward_for_translation 
END 


UL Operator forwardJbrjransmission 

As it is determined in the control constraints, this operator is 
triggered by either ready.message or tcd.emission.control. It is a state machine with 
state variable waitingjnessages. As long as the emissions are restricted by 
tcd_emission_control, the messages for transmission are written into the state 
variable waiting_messages. When silence is lifted, again by tcd_emission_contiol, all 
messages in state variable are written into output stream ou^ut.messages. While 
there is no silence, input ready.message is written into output stream. Output of this 
operator is guarded by the values of the input stream tcd_emission_controL The 
PSDL description follows: 


OPERATOR fonmrd_for__transmis8ion 
SPECIFICATION 

INPUT r«ady_me88ag« : tran8mi88ion__cominand, 

tcd__aiiii88ion_control : emi88ion8_control_c<»Bmand 
OUTPUT output_ina88ag«8 : ma88aga_li8t 

STATES waiting_ma88aga8 : meaaage^^liat INITIALLY null 
MAXIMUM EXECUTION TIME 200 A8 

DESCRIPTION ( quauaa tha input while there ia ailence, 
and dequeuea when ailence lifted } 

END 

implementation Ada forward_for_tran8aii88ion 
END 


42 






iV. Operator convertjtojextjile 

This sporadic operator prepares a text file which includes the 
message to be transmitted. The PSDL description follows. 


OPERATOR convart_to_toxt_fil« 

SPECIFICATION 

INPUT output^messages : message__list 

MAXIMUM EXECUTION TIME 100 ms 

DESCRIPTION { writes the message into a text file } 

END 

implementation Ada convert_to_text_file 

END 


3. Operator prepare_periodic_report 

This operator is responsible for producing periodic track reports. This atomic 
operator gets the tracks from the database, and periodically prepares a message that 
contains tracks with matching values deteimined by initiate_trans command. This 
process terminates by terminate_trans command. The PSDL description follows: 

OPERATOR prepare_track__report 
SPECIFICATION 

INPUT initiate_trans ; initiate_transmission_ 

sequence, 

terminate_trans : boolean 

OUTPUT tcd_transmit__command : transmit_command 

MAXIMUM EXECUTION TIME 500 ms 

DESCRIPTION ( produces periodic track report } 

END 

implementation Ada prepare__track_report 
END 


43 







4. Operator translaie_message 

This operator is supposed to perform message format translation in the real 
implementation. Since the message formats are classified, for prototyping purposes, it 
just makes a type conversion between the input and output data streams. The PSDL 
description follows: 

OPERATOR traLnslate_message 

SPECIFICATION 

INPUT rawjaessaga : tran8lation_coiiiinand 
OUTPUT raady_ma8saga : tran8mi88ion_coiDinand 
MAXIMUM EXECUTION TIME 300 m8 

DESCRIPTION { parfonn8 mes8aga format tranalation } 

END 

implementation Ada translate__ffle88age 

END 

C. SENSOR INTERFACE 

The type of sensors used by the U.S. Navy varies from platform t6 platform. There 
are many differences between the sensors such as speed, data accuracy, tracking 
capability, maximum number of tracks that can be tracked, etc. As it was advised in 
the requirements document [Ref. 7], the prototype is designed for a shipboard 
example. The primary sensor systems in the prototype are SPY-1 radar, SAR-8 
IRST, SLQ-32 ESM device, and SQS-53C bow mounted sonar. 

The Sensor Interface is still thought to be complex and it is decomposed into 
atomic operators. The functional decomposition of the interface is in Figure 4-4. The 
functions performed by these atomic modules will be discussed in detail in following 
sections. 

The timing constraints related with this operator were given as follows: 

• The inertial navigation system updates the ownship velocity every 40.96 ms 
and transmits this nominally every 983.04 ms. The latitude and longitude are 
updated every 1.3 seconds. 


44 




Provisionally for prototyping purposes, the maximum number of tracks per 
sensor will be assumed to be 100 tracks per second. 





Figure 4-4. Decomposition of Sensor Interface Module 


The second constraint is used to determine the minimum calling period of this 

interface. Since there will be 4 sensors connected to the prototype C^I workstation, 
maximum number of tracks coming into the system will be 4 * 100 = 400 per second. 

There was not a specific timing constraint for maximum time required to process a 
sensor track data. An assumption was made that a sensor track data shall be 
processed by the sensor interface within 500 ms after arriving the interface. Therefore 
minimum calling period for this interface is 500 / 200 = 2.5 ms. Maximum response 
time is 500 ms as assumed. These timing constraints were stated in PSDL 
description of operator c3i_system. 

Maximum execution time for the atomic operators are again given arbitrarily. The 
PSDL description follows; 

OPERATOR sensor_interface 
SPECIFICATION 

INPUT sensor data : sensor record. 


45 






positionjdata 
OUTPUT 8«n8or^add__track 
8an8or__intrep 


own8hip_navigation_info 
add_track_tupla, 
intelligence report 


DESCRIPTION { thie operator proceeeee the eeneor 
track data ) 


END 

implementation 

GRAPH 


200 ms 



DATA STREAMS 

8en8or_contact__data : local_track_info, 
nonaalized_contact_data ; local_track__info 
CONTROL CONSTRAINTS 

OPERATOR analyze_8en8or__data 
TRIGGERED BY S^<E 8ensor_data 
OPERATOR nonnalize_8en8or_information 
TRIGGERED BY S(^ 8ensor__contact_data 
OPERATOR prepare__8en8or_track 

TRIGGERED BY normalized__contact_data, po8ition__data 

END 


46 














2. Operator analyze jsensor_data 

In the actual system this operator is an expert system that acts as a track 
filter, eliminating duplicate or redundant information. It insures the consistency and 
uniqueness of track identification and labeling. As a second major function, based 
upon the intelligence data supplied by the sensors, such as ESM and ECM 
information, it also provides decision support 

For prototyping purposes, this operator is designed to separate contact and 
intelligence information provided by the sensors. The PSDL description follows: 

OPERATOR analyze_sensor_data 

SPECIFICATION 

INPUT 8ensor_data : 8ensor_racord 

OUTPUT 8en8or__contact_^data : local_trac)c_info, 

8an8or_intrap : intelligenca_report 

MAXIMUM EXECUTION TIME 200 m8 

DESCRIPTION ( 8eparate8 the contact and intelligence 
data portiona of input aenaor data } 

END 

IMPLEMENTATION Ada analyze__aen8or_^data 

END 


3. Operator normalize jsensorJnformaHon 

Sensors on a platform are located separately anywhere from a few meters 
apart, to a hundred meters apart, or more. This module modifies the information 
provided by a sensor depending on its physical location relative to a reference location 
on the platform. Thus all track information from different sensors will be reported from 
the same reference point. 

For prototyping purposes, since this module will completely depend on the 
type of the platform and positions of each individual sen’.;ors on that platform, no 


47 






computations and modifications are made. It has been placed in the decomposition for 
the completeness. The PSDL description follows: 

OPZMITOR nozinallz«_8«nflor_information 

SPECIFICATION 

INPUT s«nsor_contact__data : local^track:__info 
OUTPUT noxmalizad_contact_data : local_track_info 
MAXIMUM EXECUTION TIME 100 ms 

DESCRIPTION { for prototyping purposes, it just 
assigns the input into output > 

END 

IMPZ£MENTATION Ada normalize_8ensor_infonnation 

END 

4. Operator preparejsensorjtrack 

The position information is provided relative to own platform by the sensors. 
This operator is triggered by this relative track information, and it calculates the 
absolute position of the track by using the latest own platform position time 
information. The PSDL description follows: 


OPERATOR prepare_8ensor_track 
SPECIFICATION 

INPUT normalized_contact_^data : local_track_info, 
po8ition__data : ownship_navigation 

information 

OUTPUT 8ensor_^add_track ; add__track_tuple 

MAXIMUM EXECUTION TIME 200 ms 

DESCRIPTION { converts relative location data to 
absolute values ) 

END 

IMPLEMENTATION Ada prapare__8ensor__track 
END 


48 





D. TRACK DATABASE MANAGER 

The track database manager is responsible for integration and synthesis of tracks 
received from communications systems and organic platform sensors. It is 
responsible for including all new tracks, delete old tracks and permitting rapid access 
to information fields for use by the user. A monitor will scan the database periodically 
to match, merge, correlate or delete unnecessary tracks. 

Based on these simplified general functions, the decomposition shown in Figure 4- 
5 was produced. 

The timing constraints specified for this operator are; 

• Provisionally the generic C^I workstation should be capable of retrieving da¬ 
ta from track database up to 1000 tracks in less than one second. 

• From the time a track data message is received by the system and its con¬ 
tents are entered into the track database should be less than 2 seconds. 

• The inertial navigation system updates the ownship velocity every 40.96 ms 
and transmits this nominally every 983.04 ms. The latitude and longitude are 
updated every 1.3 seconds. 

The second constraint is used to determine the maximum response time of the 
operator update.tracks. 500 ms of the given 2 seconds was used by the 
communications interface to process the incoming message. The maximum response 
time of operator update_tracks is determined to be 500 ms. So, for a track data 
message, it takes 1000 ms to enter its contents into the track database, and these 
timing constraints satisfy the given requirement. 

The last constraint is used to determine the type of the operator moni- 
tor_ownship_position. Since the input data comes periodically, this operator is de¬ 
signed as a periodic operator with a period equal to the input data flow rate. There 
was no timing constraint specified in the requirements document for the period of mon¬ 
itoring the database. The prototype is designed to perform this function every 2 sec¬ 
onds. 


49 






' 3. 

track 

database 

unanager. 


3.1. 

update 

tracks 


^ 3.2. 

monitor 

.database 


3.1.1. 

filter 

comms 

Jracks 


3.2.1. > 
check for 
timeout . 
and rangy 


f 3.2.2. 

identify 

simiiaritiej 


3.1.2. 

filter 

sensor 

jracks 


3.1.3. 

add 

comms 

track 


( 3.1.8. 
add user 
L track 


f 3.1.7. > 
delete 
the track 


3.1.4. 

add 

sensor 

track 


3.1.5. ^ 
monitor 
ownship 
position A 


f 3.1.6. > 

[update the 
I track 


Figure 4*5. Decomposition of Track Database Manager Module 


50 




The PSDL description follows: 


OPERiLTOR traclc_databastt_managttr 
SPECIFICATION 

INPUT comms^add^track 
8an8or_add_track 
addjtrack 
updata_track 
dalata__track 
tdd_filt8r 
tdd^con8traint8 
position_data 
OUTPUT out_track8 

tdm re8olution notice 


add_track__tuple, 
add[__t rack_tuple, 
add_track_tuple, 
update_track__tuple, 
deletejtrackjtuple, 
8et_track_filter, 
8et_monitor^con8traint8, 
own8hip_navigation__info 
track_tuple, 
ra8olution notice/ 


DESCRIPTION { managee the track databaae ) 

END 

implementation 

GRAPH 



CONTROL CONSTRAINTS 

OPERATOR update^tracka 
OPERATOR monitor databaee 


51 













END 


PERIOD 2 sac 


The details about the operators in the decomposition at this level are given below. 

1. Operator update Jracks 

This module performs the functions for adding new tracks into the track 
database, deleting tracks ftom the database, and updating tracks in the database. It is 
composed of several atomic operators and the details of them will be provided in the 
following sections. The PSDL description follows: 


OPERATOR updat«_track8 
SPECZriCATION 

add__track_tupla , 
add_track__tupla, 
add__track_tupla, 
updata_track_tupla , 
daleta_track_tupla, 
8at_track__filtar, 
ownship_navigation_info 
track_tupla 
track_tupla 

INITIALLY null 

DESCRIPTION ( adds, dalatas, updates tracks ) 

END 

IMPLEMENTATION 

GRAPH 


INPUT cooms__add_track 
sensor_add_track 
add__track 
update_track 
delete_track 
tdd_filter 
position_data 
OUTPUT out_tracks 
STATES tracks 


52 








500 ms 


500 ms 



DATA STREAMS 

filter«d_coiuns_track : add_track;_tuplo, 
filtared_8ensor_track : add;__track__tuple 
CONTROL CONSTRAINTS 

OPERATOR filter_comms__tracks 

TRIGGERED BY SOME conims__add__track 
OPERATOR filter_sensor_tracks 

TRIGGERED BY SOME sansor__add_track 
OPERATOR add comms track 


53 



TRIGGERED BY SOME filt«r«di_comms_track 
OPERATOR add_s«nsor_track 

TRIGGERED BY SOME filtare<l_8an8or_track 
OPERATOR monitor_own8hipjpo8ltion 
TRIGGERED BY SCBffi poaition^data 
OPERATOR dalata_tha_track 

TRIGGERED BY SOME dalata_track 
OPERATOR updata_tha^track 

TRIGGERED BY SOME updata_track 
OPERATOR add_u8ar_track 

TRIGGERED BY SOME add_track 

END 


L OperatorfiUer_comms_tracks 

This operator prevents unwanted tracks from entering the track 
database. It is triggered by comms addjrack, and depending on the filtering 
conditions set by the user via tddJilter, only the tracks satisfying the filtering 
conditions are placed into the output stream. The PSDL description follows : 

OPERATOR filtar_co8m8_track8 
SPECiriCATION 

INPUT tdd_filtar : s®t_track_filter, 

coinm8_add__track : add_track_tuple 

OUTPUT filtered_coinm8_track : add__track_tuple 

MAXIMUM EXECUTION TIME 500 08 

DESCRIPTION { filtera tha tracka dapanding on tha 
▼aluaa apacifiad by tdd__filtar } 

END 

implementation Ada filtar_coinm8^track8 
END 


n. OperatorfUterjsensorjtracks 

This operator performs a similar filtering operation for the tracks 
coming from the sensor interface. The PSDL description follows : 


54 





OPERATOR filter_8ensor_tracks 
SPECIFICATION 

INPUT tdd__filter : set_trac]c_filter, 

8en8or_add_traclc : add_traclc_tuple 

OUTPUT filterad_8an8or_track : add_track__tupla 
MAXIMUM EXECUTION TIME 500 m8 

DESCRIPTION { £ilter8 the track8 depending on the 
value8 8pecified by tdd_filter } 

END 

implementation Ada filter_8en8or__track8 
END 


tif. Operator addjcommsjtrack 

This atomic operator adds the filtered comms tracks to the track 
database. Tracks are added to the database with a prioritizing scheme as denned in 
the requirements document [Ref. 7] . Air tracks are placed at the top of the database, 
followed by surface and then subsurface tracks. Within these demarcations, the 
tracks arc ordered on the range from our station. The PSDL description follows: 


OPERATOR add_comm8_track 
SPECIFICATION 

INPUT filtered_coinma_track : add_track_tuple, 

tdd_filter : 8et_track_filter 

OUTPUT out_track8 : track_tuple 

MAXIMUM EXECUTION TIME 500 ms 

DESCRIPTION { add8 comma tracka to the databaae } 

END 

implementation Ada add__comm8_track 
END 


IV. Operator addjsensorjtrack 

This atomic operator adds the filtered sensor tracks to the track 
database as explained above. The PSDL description follows: 


55 







OPERATOR add_8«nsor__track 
SPBCiriCATIOM 

INPUT filtttrttd_8«n8or_track : add_track_tupla, 
tdd__flltar : 8at_track_filtar 

OUTPUT out_track8 : track_tuple 

MAXIMUM EXECUTION TIME 500 ma 

DESCRIPTION ( add8 aanaor tracks to tha database ) 

END 

implementation Ada add_8ensor_track 
END 


V. Operator monitor_ownshipjtosiHon 

This is an atomic operator that acts as an interface with ownship 
navigation system. In the actual implementation, this operator would be concerned 
with the message protocols, and bit patterns necessary to retrieve information from 
the navigation system. For the prototype system, as an interface, this operator 
parses through representative navigation data and modifies the own position data in 
the track database. The PSDL description follows; 

OPERATOR monitor_own8hip__po8ition 

SPECIFICATION 

INPUT position__data : own 8 hip_n 8 vi 9 ation_info 
OUTPUT out_tracks : track__tuple 
MAXIMUM EXECUTION TIME 1000 ms 

DESCRIPTION ( parsa8 through the input and modifiea the 
own position in database } 

END 

implementation Ada monitor__ownship_po8ition 

END 


vL Operator update jlhejtrack 

This atomic operator updates the specified track in the track 
database. The PSDL description follows: 


56 




OPERATOR uixlate_the_^traclc 
SPECIFICATION 

INPUT update_track : update__traclc_tuple 
OUTPUT out_tracks : track_tupla 
MAXIMUM EXECUTION TIME 1000 ms 
DESCRIPTION ( updatas tha spacifiad track } 

END 

implementation Ada updata__tha_track 

END 


viL Operator delete JheJrack 

This atomic operator deletes the specified track hrom the database. 
The PSDL description follows: 


OPERATOR dalata_tha__track 
SPECIFICATION 

INPUT dalata__track ; delata_track__tupla 
OUTPUT out_track8 : track_tupla 
MAXIMUM EXECUTION TIME 1000 ms 

DESCRIPTION { dalatas tha track from tha databasa } 

END 

implementation Ada delata_tha_track 

END 


via. Operator addjuserjtrack 

This atomic operator adds the tracks entered by the user. The PSDL 
description follows; 


OPERATOR add_usar_track 
SPECIFICATION 

INPUT add_track : add_track_tupla 
OUTPUT out__tracks : track__tuple 
MAXIMUM EXECUTION TIME 1000 ms 

DESCRIPTION ( adds user tracks to tha databasa } 


57 





END 

implementation Ada add__u8er_traclc 

END 


2. Operator monitor_database 

The purpose of this module is to scan the track database periodically with the 
goal of removing old, unwanted, and redundant tracks. This is performed by specified 
atomic operators. The PSDL description follows: 


OPERATOR monitor__databa8e 
SPECIFICATION 

INPUT tdd__con8traint8 
out_track8 

OUTPUT delete_track 

tdm re8olution notice 


8et_monitor_con8traint8, 
track__tuple 
delete_track_tuple, 
re8olution notice. 


DESCRIPTION { 8can8 the databaee for old, unwanted and 


redundant tracke } 

END 

implementation 

GRAPH 


badjrack.found 



simllarltyjound 



58 





CONTROL CONSTRAINTS 

OPERATOR check_for_time-out_jand_rangG 
OUTPUT delete_track IF bad_track_found 
OPERATOR identify__similarit:ies 
TRIGGERED IF NOT mode = OFF 

OUTPUT tdm_resolution_notice IF mode = AOVTSE AND 
similarity_found, 

delete_track IF mode s AUTOMATIC AND 
8imi1arity_found 

END 


The details about the atomic operators are explained below. 

L Operator check_for_timeout_and_range 

This atomic operator scans the track database and forwards the id’s 
of the tracks with older refreshing time and greater range than specified by the 
constraints. It is implemented as a state machine, and output is placed if the state 
variable bad track Jound is set to true. The state variable is set to true if any out- 
timed or out-ranged track is found in the track database. The PSDL description 
follows; 


OPERATOR check__for_time-out 
SPECIFICATION 

INPUT out_tracks 

tdd__constraints 
OUTPUT delete__track 
STATES bad_track_found 
MAXIMUM EXECUTION TIME 3 


and__range 

: track_tuple, 

; set_monitor_constraints 
: delete_track_tuple 
; boolean INITIALLY false 
0 ms 


DESCRIPTION { scans database for aged and out ranged 
tracks ) 

END 

implementation Ada cbeck_for_timeout_and_range 
END 


59 




n. Operator identify jsimHarides 

This operator scans the database for redundant tracks. If a similarity 
is found, than the state variable is set to true, and depending on the operation mode 
specified by tdd.constraints (advise or automatic), either the track id is forwarded to 
operator update_tracks for deletion, or a notice is sent to the user. The PSDL 
description follows: 


OPERATOR identify_similaritie8 
SPECIFICATION 

INPUT out__tracks : track_tuplo, 

tdd_constraint8 : sat_monitor_constraints 

OUTPUT tdm_resolutionjaotice : resolution_notice, 

delete__track : delete_track_tuple 

STATES 8imilarity__found : boolean INITIALLY false 
MAXIMUM EXECUTION TIME 700 ms 

DESCRIPTION { scans the database for track resolution } 

END 

implementation Ada identify_similarities 

END 

E. USER INTERFACE 

The user interface for generic C^I workstation prototype is implemented with 
version 4.1 release of Transportable Applications Environment (TAE) Plus. TAE 
Plus provides an integrated and consistent environment for developing and running 
both contemporary window-based applications with graphical, point-and-click user 
interfaces based on the X Window System, and more traditional alpha-numeric- 
based applications [Ref. 8]. 

After preparing and running the implemented user interface within TAE Plus 
workbench, the software provides a skeleton of an executable Ada program for the 


60 






user interface. Then, this Ada program is modiHed to meet the requirements of the 
whole system. The PSDL description follows: 


OPERATOR user^^interface 
SPECIFZCATIOM 

INPUT coiims_email 

8ensor__intrep 

out_track8 

tdm^ra 8olutionjnotica 
waapon8_8tatrep 
waapon8_jamrap 
OUTPUT delete__track 
add_track 
update_track 
tdd__filtGr 
tdd__constraints 
tcd_transmit_^coinxaand 
tarminate_trans 
tdd_archive__8etup 
initiata trans 


filanama, 

intalliganca_raport, 
track__tupla, 
raaolukionjnotica, 
waapon_8tatu8_raport, 
waapon__8tatu8__raport, 
dalata_t rack_tupla, 
add_t r ack_jtupla, 
updata__track_tupla, 
8 at_track_filtar, 
8 at_]nonitor_con8traint8 , 
transmit^^cononand, 
boolean, 
archiva_8atup, 
initiata transmiaaion 


aequanca, 

tcd_natwork_8atup : natwork__8atup, 
tcd_aini8sion_control : amiasiona^control 

command 

DESCRIPTION { interfacea with the uaer } 

END 


implementation 

GRAPH 


61 



















DATA STREAMS 

modif yjdatabase 

tcd_^8tatu8_qu«ry 

oditor__8el«ct«d 

td_t rack__reque at 

td_ 9 raphic_track__raque 8 t 


modify_command;, 
boolean, 
boolean, 

databaae^requeat, 
databaae requeat 


CONTROL CONSTRAINTS 

OPERATOR iiianage__u8er_inter£ace 
OPERATOR get_u8er__inputa 
OPERATOR re8olution_notice__panel 

TRIGGERED BY S(B4E tdm_re8olution__notice 
OPERATOR emergency__8tatua_^8creen 
TRIGGERED BY S^ffi weapon8_emrep 
OPERATOR me88age_arrival_panel 
TRIGGERED BY SOME coiDm8_email 
OPERATOR intelligence_report_panel 
TRIGGERED BY SOME aenaor^intrep 
OPERATOR getjnodification_data 

TRIGGERED BY SCBffi modify_databaae 
OPERATOR atatua^acreen 

TRIGGERED IF tcd__8tatu8_query 
OPERATOR mea8age_editor 

TRIGGERED IF editor__8elected 
OPERATOR di8play__track8 

TRIGGERED BY SOME ont__track8 
OPERATOR di8play_graphic_track8 
TRIGGERED BY SCBffi out_track8 

END 


1. Operator managejuser interface 

This is the operator which controls all of interactions with the user. It opens 
and closes the panels, senses and receives the user inputs, and assigns these inputs 
to related variables. This operator does not have any input or output variable 


63 





specified in the PSDL description since the external input and output is not allowed in 
the current version of CAPS. 

First it displays the main menu panel and gets the user’s choice. The main 
menu panel provides the user following options: 

• Archive Setup 

• Track Rlter 

• Display Tracks 

• Display Graphic Tracks 

• Weapon Status 

• Network setup 

• EMCON Status 

• Message Editor 

• Read Message Panel 

• Initiate Track Repon 

• Terminate Track Report 

• Modify Database 

When user selects one of the options above, the specified panel is displayed, 
and user enters related data as shown on the panel. These data is used either to set 
the variables provided by the operator getjtserjnpms, or triggering other operators 
in the user interface module. 

Operator manage user interface is the atomic operator which controls other 
TAE Plus modules. It makes use of many other functions and procedures which are 
not described by PSDL. The explanation for these functions and how the user 
interface runs will be provided in the next chapter. The PSDL description follows: 


OPERATOR inanage_u8er_lnterfac« 

SPECIFICATION 

DESCRIPTION { controls other user interface modules } 

END 

implementation Ada Bianage__user_lnterface 
END 


64 




2. Operator getjuserjnputs 

This atomic operator puts the values supplied by the manage user interface 
to the output data streams. If the user does not specify some values, default values 
are used. The PSDL description follows: 


OPERATOR 90 t_us«r__input 8 
SPECIFICATION 

OUTPUT mo<iify_database 
tcd_^8tatu8_^query 
•ditor^8elected 
td^track_reque8t 
td_graphic_t rack_reque st 
initiate_tran8 

tanninata_tran8 

tdd^filtar 

tdd^conatrainta 

tdd_arcliiva_8etup 
tcdjnatwork^aetup 
tcd_emia 8ion_control 

DESCRIPTION { aaaigna the valuea 


aodify_coinmand, 

boolean, 

boolean, 

databa8e__reque8t, 
dat aba 8e_re<iae at, 
initiate__tran8mi 8 8ion_ 
aequence, 
boolean, 

8et_track_fliter, 

8 etymon! tor__ 
conatrainta, 

; archive_^8etup, 

; network^aetup, 

; eini88ion8__control__ 
command 

of the out parametera } 


END 

IMPLEMENTATION Ada get_u8er_input8 
END 


3. Operator resolutionjnotice_panel 

This atomic operator displays the notice sent by the track database manager. 
The PSDL description follows: 

OPERATOR re8olution_notice_panel 
SPECIFICATION 


65 






IMPUT tdm_rttsolution_notic« : r« 80 lution_notlc« 
DESCRIPTION ( displays tha rasolution notica ) 

END 

IMPLEMENTATION Ada ra8olution^notica_panal 
END 


4. Operator emergency_statusjKreen 

This atomic operator displays the emergency weapon status sent by the 
weapons interface. The PSDL description follows; 

OPERATOR afflargancy_statu8__8craan 
SPECIFICATION 

INPUT waapons_amrap : iraapon__statu8_raport 
DESCRIPTION { displays amargancy waapon status } 

TND 

implementation Ada afflargancy_statu8_scr8an 
END 


5. Operator message jarrival_panel 

This atomic operator displays the name of the file which consists a the newly 
arrived message. If user choices to sec the message, it will be displayed for 
browsing. The PSDL description follows: 

OPERATOR mo8saga_arrival_panal 
SPECIFICATION 

INPUT coinms__amail : filanama 

DESCRIPTION ( displays tha nama of tha fila which has 
tha nawly arrivad massaga in it ) 

END 

implementation Ada ma88aga_arrival_panal 
END 


66 





1 


6. Operator intelligencejreportjanel 

This atomic operator displays the intelligence report supplied by the sensors 
interface. The PSDL description follows; 

OPERATOR intelligance_^report_panel 

SPECIFICATION 

INPUT 8an8or_intrep : ixitolligenca__report 
DESCRIPTION ( dlaplaya tha intalliganca raport } 

END 

implementation Ada lntalliganca__raport_^anal 

END 

7. Operator get_modification_data 

This atomic operator displays a panel with three options in it. By these 
options, the user can add a track into the database manually, or he can delete or 
update an existing track in the database. The PSDL description follows: 


OPERATOR gatjnodification_^data 
SPECIFICATION 

INPUT modify_databasa : modify__coiamand 

OUTPUT add__traclc : add_trac]c_tupla, 

updata_track : updata_track_tupla, 

dalata__track : dalata_track_tupla 

DESCRIPTION ( gat8 track databasa modification valuaa } 

END 

IMPLEMENTATION Ada gat_modificationjdata 
END 

8. Operator status jscreen 

This atomic operator displays the weapon status supplied by the weapons 
interface. The PSDL description follows; 


67 





OPERATOR statuses cr««n 
SPECiriCATIOM 

INPUT waapon8_8tatr«p : waapon__8tatu8_r«port, 
tcd__atatu8__quary : boolean 
DESCRIPTION { diaplaya the weapon atatua ) 

END 

implementation Ada 8tatu8__8creen 
END 

9. Operator message jtditor 

This atomic operator provides the user an empty message template. The 
user can type in the fields of the template to complete the message. The PSDL 
description follows: 

OPERATOR meaaage^editor 
SPECIFICATION 

INPUT editor_8elected : boolean 

OUTPUT tcd^tranamit^coxnmand : tranamit^^command 
DESCRIPTION ( providea the meaaage template ) 

END 

implementation Ada me88age_editor 
END 

10. Operator display Jracks 

This atomic operator first gets the filtering values, such as track type, IFF 
type, maximum range from the user, and then displays the tracks satisfying the 
filtering conditions. User can change these filtering conditions any time by querying 
this panel. The PSDL description follows: 


OPERATOR diaplay^tracka 
SPECIFICATION 


68 



INPUT td_traclc__reque8t : dlatabase_rttquest 
DESCRIPTION { displays the tracks textually ) 

END 

implementation Ada display_trac]cs 
END 

11. Operator display_graphicjracks 

This atomic operator displays the tracks graphically as explained above. The 
PSDL description follows: 


OPERATOR display_graphic_tracks 

SPECIFICATION 

INPUT td_graphic_track_request : database__request 
DESCRIPTION { displays the tracks graphically ) 

END 

implementation Ada display_graphic_tracks 

END 

F. WEAPONS INTERFACE 

In the actual C^I workstation, the Weapons Systems Interface is designed to 
monitor current weapons systems statuses, including operational availability, reload 
status, weapons loadout, and any additional information that may be deemed relevant 
[Ref. 7]. 

For the prototype workstation, in keeping with the provisional shipboard example, 
the primary weapons connected to the system will be a PHALANX CIWS, a 5’754 
gun, TOMAHAWK cruise missiles, and Mk 46 torpedoes. It will be assumed that 
these weapon systems provide real time status data at every 1 second as specified in 
the timing constraints given in previous chapter. 

According to this given timing constraint, there will be 4 weapon status data 
coming to the interface in 1 second, assuming that the interface shall process an 


69 






individual data in 500 ms. the minimum calling period for this interface is 250 ms. 
Maximum response time is 500 ms. These timing constraints were specified at the 
first level PSDL description with the guard conditions. The PSDL description follows: 


woapon^status 
irttapon_8tatu8_report, 
waapon__8tatu8__report 


OPERATOR waapon8_intarfaca 
SPECiriCATIOM 

INPUT waapon__8tatu8_data 
OUTPUT waapon8_aau:ap 

waapon8_8tatrap 
STATES ciw8_8tatu8, 
gun_8tatu8, 
tW8__8tatU8 , 
mk_48_8tatu8 
INITIALLY ready, ready, ready, ready 
MAXIMUM EXECUTION TIME 500 ma 

DESCRIPTION ( interfacea with weapon ayatema, and for- 
warda weapon atatua reporta ) 

END 


weapon_8tatu8__type 


IMPLEMENTATION Ada weapona^interface 
END 


G. EXTERNAL SYSTEMS 

These are separate atomic operators simulating the external systems producing 

data for the prototype C^I workstation. In general, all of them use a random number 
generator package to produce random data. 

Having these external systems included in the C^l prototype actually slows down 
the execution, and effects the timing constraints specified for the other operators. But 

for the completeness of the prototype, these arc included within the C^I prototype. 

Maximum execution times for these operators are given arbitrarily at this 
moment, and they will be minimized during the execution process through CAPS. 


70 






1. Operator comms Jinks 

This operator simulates the communications links attached to the prototype 
workstation. It is defmed as a non time critical operator, so the dynamic scheduler 
will schedule this operator to produce messages. The PSDL description follows: 


OPERATOR coinms__links 
SPECIFICATION 

OUTPUT input_link_message : filename 
description { produces the input messages } 

MAXIMUM EXECUTION TIME 100 ms 

END 

implementation Ada comms_links 
END 

2. Operator sensors 

This is an operator which simulates sensors connected to the prototype C^I 
workstation. It creates a certain number of tracks initially, and then each time it 
reports the current position of a track chosen randomly. The initial positions and 
speed, course values of the tracks are decided randomly by using a random number 
generator. The operator keeps track of the tracks within a database which is 
implemented as a linked list, and updates the values as time passes. The PSDL 
description follows; 


OPERATOR sensors 
SPECIFICATION 

OUTPUT sensor__data : sensor_record 
DESCRIPTION ( creates sensor data } 
MAXIMUM EXECUTION TIME 100 ms 


END 

IMPLEMENTATION Ada sensors 
END 


71 






3. Operator navigationjsystem 

This operator simulates the navigation subsystem of the platform, and 
produces position data. For the prototyping effort, ownship is assumed to start 
navigation from a certain geographic position, and steams to a constant route with 
constant speed. This operator is defined to be a periodic operator to simulate the real 
navigation system. The PSDL description follows: 

OPERATOR navigation_sy8tein 
SPECIFICATION 

OUTPUT position_data : o%mship_navigation_info 
DESCRIPTION { creates ownship position data } 

MAXIMUM EXECUTION TIME 100 ms 

END 

implementation Ada navigation_system 
END 

4. Operator weapons_systems 

This operator simulates the weapons systems attached to the prototype. It 
produces weapon status data periodically. The PSDL description follows: 

OPERATOR weapons_systerns 
SPECIFICATION 

OUTPUT weapon_status_data : weapon_status 
DESCRIPTION { creates weapon status data } 

MAXIMUM EXECUTION TIME 100 ms 

END 

IMPLEMENTATION Ada weapons_systems 
END 


72 




G. DATA TYPES 

A variety of data types are used in the prototype. The definitions of these data 
types, their associations with the data streams, and the names of the operators using 
these data streams are provided in Table 4-1. 


TABLE 4-1. User Defined Data Types 


DATA TYPE DATA STREAMS 

acld_track_tuple comms_add_track 

sensor_add_track 

Ada record type that contains addjrack 

track information which will be filtered_commsjrack 

inserted to the track database. filtered sensor_track 


archhre.setup tdd_archive_setup 

Ada record type that contains 
information to set up the mes¬ 
sage archiving flags. 


OPERATORS 

c3i_system 

commsjnterface 

resolveJncomingL 

messages 

extractjracks 

sensorjnterface 

prepare_sensor_track 

track_database_m 2 nager 

updatejracks 

filterjcommsjracks 

filter_sensor_tracks 

add_comms_track 

add_sensor_track 

add_userjrack 

userjnterface 

get .modification_data 

c3Lsystem 

commsjnterface 

resolveJncomingL 

messages 

decideJor_archiving 

userjnterface 

get_userjnputs 


database_request 

Ada record type that contains 
the desired type and range val¬ 
ues of the tracks for retrieval 
from the database. 


tdjrack_request 

tdjgraphicjrack_request 


userjnterface 
get_userjnputs 
displayJracks 
display .graphic Jracks 


deletejrackjuple delete Jrack 

Ada record type that contains 
information for the tracks 


c3Lsystem 

track_database_manager 
updatejracks 
delete the track 


73 





TABLE 4<1. User Deflned Data Types 


DATATYPE 

DATA STREAMS 

OPERATORS 

messagejist 

output_messages 

resolve_outgoingL 


waitingL.messages 

messages 

Ada linked list type that con¬ 


forwardjorjransmission 

tains communications messages. 


convertjojextjile 

modify.command 

modify_dat£^ase 

userjnterface 

get_userjnputs 

Ada emjmeration type which 
consists of databse modifica¬ 
tion types (add, update, delete). 


get_mo(fification_data 

network_setup 

tcd_network_setup 

c3i_system 

commsjnterface 

Ada array type that contains 


resolveJncomingL 

the names of the stations in 


messages 

four different communications 


declde_for_relaying 

links. 


resolve_outgoingL 

messages 

make.routing 

userjnterface 

get.userjnputs 

ownship_navlgationjnfo 

position.data 

c3i_system 
sensorJnterface 

Ada record type that contains 


prepare_sensor_track 

the position, velocity and 


track_database_manager 

course values for own ship. 


updatejracks 

monitor_ownshipjX)sition 

navigation_system 

resolutlon_notlce 

tdm_resolution_notice 

c3Lsystem 

track_database_manager 

Ada record type that contains 


monitor_database 

the information about the 


identify_similarities 

tracks which are found to be 


userjnterface 

similar by the track database 
manager. 


resolution_notice_panel 

sensor_record 

sensor_data 

c3i_system 
sensor Jnterface 

Ada record type that contains 


analyze_sensor_data 

the track data which is generat¬ 
ed by the sensors. 


sensors 


74 





TABLE 4-1. User Defined Data Types 


DATA TYPE DATA STREAMS OPERATORS 

monitor_database 

checkJor_timeout_and_ 

range 

identify_simitarities 

userjnterface 

get_modification_data 


emlsslons_control_command tcd_emission_control 

Ada record type that contains 
the current EMCON status. 


filename input_link_message 

comms_efnail 

Ada string type that contains 
the name of a message. 


c3i_system 

commsjnterface 

resolvejoutgoingL 

messages 

forwardjorjransmission 

userjnterface 

get_userjnputs 

c3i_system 

commsjnterface 

resolveJncoming_ 

messages 
parsejnputjile 
decideJor_archiving 
userjnterface 
message_amval_panel 
comms links 


lnitlatejransmlssion_ initiate jrans 

sequence 

Ada record type that contains 
the track report which will be 
transmitted to the other sta¬ 
tions periodically. 


c3i_system 

commsjnterface 

prepare_periodic_report 

userjnterface 

get_userjnputs 


intelllgence_report sensorJntrep 

Ada record type that contains 
the intelligence data and the 
source of the information. 


c3i_system 

sensorjnterface 

analyze_sensor_data 

userjnterface 

intelligence_reportj3anel 


localjrackjnio sensor_contact_data 

normalized_contact_data 

Ada record type that contains 
the track information. 


sensorjnterface 

analyze_sensor_data 

normalize_sensor_ 

information 

prepare_sensorjrack 


75 




TABLE 4-1. User Defined Data Types 


DATA TYPE DATA STREAMS 

8et_monitor_constralnts tdd.constraints 

Ada record type which deter¬ 
mines monitor constraints. 


OPERATORS 

c3i_system 

track.database.manager 

monitor_database 

check_for_timeout_and_ 

range 

identify_similarities 

userjnterface 

get_userjnputs 


set_track_finer tddjiiter 

Ada record type which contains 
filtering data for the tracks. 


text_record input_text_record 

~ commsJextjRle 

Ada record type that contains a 
communications message. 


c3i_system 

track_database_manager 

updatejracks 

filter_comms_tracks 

filter_sensor_tracks 

add_comms_track, 

add_sensor_track 

userjnterface 

get_userjnputs 

resolveJncomingL 

messages 
parseJnputJile 
decideJor_relaying 
decideJor_archiving 
extract tracks 


track_tuple 

Ada linked list 
records. 


type of track 


outjracks 

tracks 


c3i_system 

track_database_manager 
updatejracks 
add_commsjrack 
add_sensorjrack 
monitor_ownshipjx)sition 
updatejhejrack 
deletejhejrack 
add_userjrack 
monitor_database 
checkJor_timeout_and_ 
range 

identify_similarities 
userjnterface 
displayJracks 
displayjgraphicjracks 


76 



TABLE 4-1. User Defined Data Types 


DATA TYPE 

DATA STREAMS 

OPERATORS 

translatlon_command 

raw_message 

commsjnterface 

resolve_outgoing_ 

Ada array type which contains 


messages 

the message text which will be 


fonward_for_translation 

translated. 


translate_message 

transmlt.command 

tcd_transmit_command 

c3Lsystem 

commsjnterface 

Ada array type which contains 


resolveJncomingL 

message records which will be 


messages 

transmitted 


decideJor_relaylng 
resolve_outgoingL 

messages 

make.routing 

preparejrack_report 

userjnterface 

message_editor 

update.trackjuple 

updatejrack 

c3i_system 

track_database_manager 

Ada record type that contains 


updatejracks 

the information for the track 


updatejhejrack 

which will be updated in the 


userjnterface 

track database. 


get_modification_data 

weapon_status 

weapon_status_data 

c3i_system 

weaponsjntertace 

Ada record type that contains 
status of the weapon systems. 


weapons_systems 

weapon_status_report 

weapons_emrep 

c3i_system 


weapons_statrep 

userjnterface 

Ada array type that contains 


emergency_status_screen 

current status of the weapon 


status.screen 

systems 


weaponsjnterface 


77 




CHAPTER V 


IMPLEMENTATION OF THE C^I WORKSTATION 
PROTOTYPE THROUGH CAPS 


The prototyping process in the CAPS enviromnent is done by following the steps 
given below: 

• The designer draws the graphs by using the graphic editor. 

• The graphic editor provides the skeleton PSDL code. 

• The designer modifies the skeleton PSDL code by using the syntax directed 
editor, and finally system produces psdl.txt file which contains the PSDL de¬ 
scription of the prototype. 

• The translator produces an Ada package, tla, which handles the instantiation 
of the dau streams, reading data from the data streams, writing data to data 
streams, executing the atomic operators, and etc. CAPS uses psdl.txt file to 
produce this driver package. 

• The static scheduler tries to find a schedule for the time critical operators, and 
if a feasible schedule is found, the static scheduler produces ssjU, Ada package 
that contains the static schedule. 

• Once the static schedule is found, the dynamic scheduler produces the file ds-a 
which contains the dynamic schedule for the non-time critical operators in the 
psdl.txt. 

• CAPS provides the user with matching Ada reusable components for the atom¬ 
ic operators. If a reusable component can not be found, then the designer ei¬ 
ther decomposes the operator and tries to find Ada component for them, or he 
writes the Ada component for that operator. When all the components are 
found, they are placed in Ada package sbji. 

• CAPS compiles and loads sb.a, tl.a, ds.a, and ss.a and starts to execute the 
prototype. 


79 





CAPS environment is still an ongoing research study, and the functions listed 
above were not all ready when we started prototyping. This chapter explains how 
these steps are accomplished for C^I workstation prototype. 

A. PREPARING PSDL DESCRIPTION FILE, PSDL.TXT 

When we started modular decomposidon, and defining PSDL descriptions, the 
graphic and syntax directed editors were not ready to use for a multi level PSDL 
example. For this reason we have used framemaker to draw the graphs and write the 
PSDL code. 

After completing the multi level decomposition, we prepared the psdl.txt file which 
includes only the atomic operators in the bottom level of the decomposition. The 
consistency checking between the levels, and the different modules was done 
manually. 

The psdl.txt file is provided in Appendix B. 

B. PRODUCING DRIVER PACKAGE, TLA 

The translator gets psdl.txt file as input, and produces tl.a as output. 

Package tl.a consists of instantiations of generic package SAMPLED_BUFFER 
(or FIFO_BUFFER) for each data streams used, and driver procedures for each 
atomic operator. 

During the execution of the prototype, the system continuously gave bus errors at 
a certain point of the program. After a long debugging effort, we figured out that this 
error occurs for the data stream which was instantiated as the last package (package 
c3i_system_package in tl.a). We could not find any meaningful reason for this error, 
and solved it by adding a new sampled.buffer instantiation at the end of the package, 
which we actually did not use at all. This problem appears to be caused by a fault in 
the Verdix Ada Compiler, Version 6.0. 

The other problems we encountered either during the translation of psdl.txt or 
compiling tl.a were mostly solved by Prof Berzins, V. 


80 



The driver package tl.a is provided in Appendix C. 

C. BUILDING THE STATIC SCHEDULE, SSA 

The static scheduler that we started with constrained the designer to specify 
minimum calling periods and maximum response times together with the maximum 
execution times. Later, we thought that it would be bett^ if the static scheduler 
calculated the undefined mrt and mcp values, depending on the other tuning 
constraints supplied by the designer, and the static scheduler was modified to do so. 
The algorithm and the corresponding Ada code is provided in Appendix G. 

Another problem with the static scheduler occurred during the execution of the 
prototype. Because of the amount of variables used, the default storage size for the 
static schedule task was not long enough. For this reason the scheduler package was 
modified to produce the static schedule package, ss.a, with sufficient storage size. 
For this modification an Ada representation clause is used. 

The static schedule package ss.a is given in Appendix D. 

D. BUILDING THE DYNAMIC SCHEDULE, DSA 

Similar to static schedule, we encountered a storage size error for the dynamic 
schedule. The dynamic scheduler was also modified to overcome this error. 

The dynamic schedule package produced by the updated dynamic scheduler is 
provided in Appendix E. 

E. BUILDING THE SOFTWARE BASE, SBA 

This step of searching, finding and retrieving matching Ada components for the 
atomic PSDL operators was not yet implemented. In addition, we could not find any 
matching Ada components manually for almost all of the operators used in C3I. For 
this reason we had to write Ada components for all of the atomic operators, and test 





As it was mentioned before, we have used TAE Plus to create the user interface 
modules. TAE Plus provides the interface designer either Ada or C code for the 
designed interface. But this tool generated code is not ready to execute, and the 
designer still has to modify it. The TAE Plus resource file created by the TAE Plus 
Workbench, user.res, must be placed into the directory where the prototype runs. We 
thought that it would be very useful to explain how TAE Plus code is modified to get 
an executable interface code. This is done in Appendix H. 

The Ada components are placed in the software base package, sb.a, written in 
Ada. This is provided in Appendix F. Due to the time limitation of our research, some 
of the functions could not be integrated into the running version of the prototype. But 
the Ada code for these functions were also prepared, and tested. This code is given in 
Appendix I. 


82 





CHAPTER VI 


CONCLUSIONS AND RECOMMENDATIONS 

A. CONCLUSIONS 

Due to its complexity and size, it was impossible to realize this prototype by 
using traditional software engineering techniques and programming languages only. 
Our research has contributed towards the development of a rapid prototype of a C^I 
system software by using the CAPS environment. The required features, 
characterisdcs and difficulties with the development of such a software system have 
been refined as a result of the long term effort which this thesis describes. 

This thesis research incorporated the first attempt to make use of a rapid 
prototyping environment, CAPS, to prototype a hard-real-time software system. This 
required comprehensive understanding of the major tools provided by the CAPS 
environment, besides the knowledge of C^I systems, the PSDL language and other 
system design issues. As was explained in the previous chapter, using the 
environment for the first time, we encountered many problems that slowed down the 
main research effort, and only two thirds of the prototype could be implemented. 

The major emphasis of the prototype designed is to support C^I information 
management functions such as track information correlation, message generation and 
information display. Due to the limited research time, some of the minor functions, 
such as message format translation, automatic message relaying and part of the track 
database manager is excluded from the prototype. The complete list of these functions 
is provided in the following recommendations section. 

Hard-real-time constraints imposed by the requirements analysis are reflected in 
the design of the prototype. These timing constraints were feasible for a stand alone 


83 





Sun Microsystems Workstation. The prototyping research has been carried out on a 
muld user Sun system which is much slower than the proposed hardware. This speed 
difference and the dependency of the system speed on the number of users at the 
execution time forced us to use longer maximum execution times, and periods to make 
the prototype run. 

This thesis provides a running prototype of a C^I system with major functions. 
This work is the first in a series of steps leading toward a complete C^I software 
system. Additional research and development is required to identify weaknesses and 
areas of improvement. 

B. RECOMMENDATIONS 

Following is the list of operators which are not implemented in this thesis. Since 
most of the problems encountered during the prototyping of this version are solved, 
we believe that adding these features to the prototype is relatively easy. 

• Operator translate.message 

• Operator decide_for_relaying 

• Operator forward_for_translation 

• Operator noimalize_sensor_information 

• Operator update_the_track 

• Operator delete_the_track 

• Operator add_user_track 

• Operator check_for_timeout_and_range 

• Operator identify_similarities 

• Operator rcsolution_notice_panel 

• Operator intelligence_report_panel 

• Operator get_modification_data 

• Operator display_graphic_tracks 

As mentioned earlier, timing constraints used in this version were limited by the 
hardware. When faster and stand-alone hardware is available, this prototype should 
be modified to reflect the timing constraints specified by the user. 


84 







LEVEL 0 GENERIC C3I WORKSTATION 


85 


Communications Links 











ts 2 g 

S8 


J O 

HUQ 




////// 


g 

2 << 

^ 0106 

V w 


3|dn| ipiui ppe 


Ed 

CA 

< 

PQ w 

H Ed 
< M 

H 


g ^ 

o ^ 

p M I* u 

^ S S S 

u o o « 


m 


aSessam 


mCO 

I text file_ 5 ^ 

^ ^ 5S 

' mvm wy 




<t/5k 




f sSS 

= i^i 
V '"sS 




/ aio 

ill 

1- Smu 

V g5S 

V 


X 




S s 

“5 

U flu 
<22 
^ a 

H “ 


/<t 


^<< 

<<fluS 
flfl ^ 

H W M 

a 


g<g 

“5| 

°S 


LEVEL 1-1 COMMS INTERFACE 


86 






NAVIGATION 

SYSTEM 




sensor 

information 

p o 


M ^ 

< U 


^ s 

nl 

•< CA 

Ctf S 




z ^ 

o5<o 

SS|h 

“o^s 

U.Z"- 


a.e e 
:= o o 

S es C8 

i-^E 

® 

6*2 


®cS 


•&§ g 

f •§= 


«*£ 


IJii 

U «OZ 
BC <ft.O 
u 


LEVEL 1-2 SENSOR INTERFACE 


87 


TRACK DATABASE 
MANAGER (3) 









LEVEL 1-3 TRACK DATABASE MANAGER 


COMMUNICATIONS SENSOR 
INTERFACE (1) INTERFACE (2) 













uC 

^^1 




H<t5 

S® 


indui leuioua) 


e^Ed 

gp 

Sfi 


aauanbas 

uoissiuisuEj) aiefiiui 
diqas 3Aiq3je 


b «> 

^ I 

£ g 

^ I 

& i 


<S fO 

U 

U Ed 
C 05 

u< •< 

« z 


^ U 
ec cn 

C« BO 

Z < 
Ed H 

(/> •< 

Q 


EriZ 

s^s 

HyOS 

U<0 

OSmEi< 

hS 


5:2^ 


“gsl 

■< 

o 


OSatt 2 

iSpfi 


Ed© 


g<g 

s 


u © 

Sii 

2^1 


uS 

g<g 

“s 


Ed© 

S$< 

“s 


LEVEL 1-4 TRACK DATA DISPLAY 


89 









“si 

“^1 


sii 

s 




511 


*'• ill 


vyV 

m 


I E 

IS § 




m? 


II 


/ s « 

§Sg 

3 i5i 

V 


c & 

I J 

Tg 

^cgU 

SSu 

Sir 


iss 


a esg 


Siecw 

^ H 5; 
Bfi^Q 


•IW, 




\\i i/ 

m #/ 

‘Wfr 


Sj*-?* 






I r 

gg^i® yx^ 

III j 

n — y\ Pso y 




network setup 
emissions control command 


LEVEL 1-5 TACTICAL COMMAND DISPLAY 


INTERFACE (1) 








6j_| 



ll 

ll 

ll 

s s 

22 

S2 

Or 

1 ^ 1 

» “ 


u 


ii|i§ 


<iS2 

ilteS 

H 


O -J 

S§ 

H w 


/ tvV 

^\\% 
'v^« ^V« 

«Q.vV» •^Wa 


m 


^//l 

# 

#7 


^/ys 

y/^ 

y^ 

r . 


U fit 

M 3 r* 

Snafi 

fjj 6 ^ 

= V 3 U 

u 


e 2 

^ii 

ll*i 

« a> 

» 


/ B-5r^8S 

r i2p 

V u^i 


§ a 


Jfiin 

*< z IT 

U<>| 
US BU 

<o^ 

HUq 


& e 
s s 

I I 


ftj o ^ 

< z 

P 5 ^ 
H s -J 
US A. 

2<OS2 

HUQ 


LEVEL 1-6 WEAPONS SYSTEMS INTERFACE 


91 


STATUS 









APPENDIX B 


PSDL DESCRIPTION OF PROTOTYPE 
PSDL.TXT 

In Chapter IV, we have provided the multi-level PSDL description of the C^I pro¬ 
totype with the graphical representations. But, the current version of the translator 
and the static scheduler can handle only flat level PSDL Hies. This Appendix provides 

the flat level PSDL description of the C^I prototype. The graph portion of the PSDL 
code below is the internal representation of the flat level PSDL graph which is provid¬ 
ed at the end of this appendix (Figure B-1). 


OPERATOR C3I_SYSTEM 

SPECIFICATION 

END 

IMPLEMENTATION 

GRAPH 

VERTEX COMMS_LINKS : 1200 MS 
VERTEX PARSE_INPUT_FILE : 500 MS 
VERTEX DECIDE_FOR_ARCHIVING : 500 MS 
VERTEX EXTRACT_TRACKS : 500 MS 
VERTEX FILTER_COMMS_TRACKS : 500 MS 
VERTEX ADD_COMMS_TRACK : 500 MS 
VERTEX SENSORS : 800 MS 
VERTEX NAVIGATION_SYSTEM : 800 MS 
VERTEX ANALYZE_SENSOR_DATA : 500 MS 
VERTEX PREPARE_SENSOR_TRACK : 500 MS 
VERTEX FILTER_SENSOR_TRACKS : 500 MS 
VERTEX ADD_SENSOR_TRACK : 500 MS 
VERTEX MONITOR_OWNSHIP_POSITION : 500 MS 
VERTEX DISPLAY_TRACKS 
VERTEX GET_USER_INPUTS 
VERTEX MANAGE_USER_INTERFACE 
VERTEX WEAPONS_SYSTEMS : 500 MS 
VERTEX WEAPONS_INTERFACE : 500 MS 
VERTEX STATUS_SCREEN 
VERTEX EMERGENCY STATUS SCREEN 


93 




VERTEX MESSAGE_EDITOR 

VERTEX MAKE_ROUTING : 500 MS 

VERTEX PORWARD_FOR_TRANSMISSION : 500 MS 

VERTEX CONVERT_TO_TEXT_FIl-E : 800 MS 

VERTEX MESSAGE_ARRIVAL_PANEL 

VERTEX PREPARE_PERIODIC_REPORT : 800 MS 

EDGE INPUT_LINK_MESSAGE C0MMS_L1NKS -> PARSE_1NPUT_FILE 

EDGE INPUT_TEXT_RECORD PARSE_INPUT_FILE -> DECIDE_FOR_ARCHIVING 

EDGE TDD_ARCHIVE_SETUP GET_USER_INPUTS -> DECIDE_FOR_ARCHIVING 

EDGE COMMS_TEXT_FILE DECIDE_F0R_ARCHIV1NG -> EXTRACT_TRACKS 

EDGE C0MMS_EMA1L DECIDE_FOR_ARCHIVING -> MESSAGE_ARRIVAL_PANEL 

EDGE COMMS_ADD_TRACK EXTRACT_TRACKS -> FILTER_COMMS_TRACKS 

EDGE TDD_FILTER GET_USER_INPUTS -> FILTER_COMMS_TRACKS 

EDGE F1LTERED_C0MMS_TRACK FILTER_COMMS_TRACKS -> ADD_COMMS_TRACK 

EDGE TDD_FILTER GET_USER_INPUTS -> ADD_COMMS_TRACK 

EDGE OUT_TRACKS ADD_COMMS_TRACK -> DISPLAY_TRACKS 

EDGE SENSOR_DATA SENSORS -> ANALYZE_SENSOR_DATA 

EDGE SENSOR_CONTACT_DATA ANAI.Y2E_SENSOR_DATA -> 

PREPARE_SENSOR_TRACK 

EDGE POSITION_DATA NAVIGAT10N_SYSTEM -> PREPARE_SENSOR_TRACK 
EDGE SENSOR_ADD_TRACK PREPARE_SENSOR_TRACK -> FILTER_SENSOR_TRACKS 
EDGE TDD_F1LTER GET_0SER_1NPUTS -> FILTER_SENSOR_TRACKS 
EDGE FILTERED_SENSOR_TRACK FILTER_SENSOR_TRACKS -> 

ADD_SENSOR_TRACK 

EDGE TDD_FILTER GET_USER_INPUTS -> ADD_SENSOR_TRACK 
EDGE OUT~TRACKS ADD_SENSOR_TRACK -> DISPLAY_TRACKS 
EDGE POSITION_DATA NAV1GATI0N_SYSTEM -> 

MONlTOR__OWNSHIP_POSITION 

EDGE TD_TRACK_REQUEST GET_USER_INPUTS -> DISPLAY_TRACKS 

EDGE OUT_TRACKS MONITOR_OVraSHIP_POSlTION -> D1SPLAY_TRACKS 

EDGE WEAPON_STATUS_DATA WEAPONS_SYSTEMS -> WEAPONS_INTERFACE 

EDGE WEAPONS_STATREP WEAPONS_INTERFACE -> STATUS_SCREEN 

EDGE TCD_STATUS_QUERY GET_USER_INPUTS -> STATUS_SCREEN 

EDGE WEAPONS_EMREP WEAPONS_INTERFACE -> EMERGENCY_STATUS_SCREEN 

EDGE EDITOR_SELECTED GET_USER_INPUTS -> MESSAGE_EDITOR 

EDGE TCD_TRANSMIT_COMMAND MESSAGE_EDITOR -> MAKE_ROUTING 

EDGE TCD_NETWORK_SETUP GET_USER_INPUTS -> MAKE_ROUTING 

EDGE TRANSM1SSI0N_MESSAGE MAKE_ROUTING -> FORWARD_FOR_TRANSMISSION 

EDGE TCD_EMlSSION_CONTROL GET_USER_INPUTS -> 

FORWARD_FOR_TRAN SMISSION 
EDGE OUTPUT_MESSAGES FORWARD_FOR_TRANSMISSION -> 

CONVERT_TO_TEXT_F1LE 

EDGE 1NITIATE_TRANS GET_USER_INPUTS -> PREPARE_PER10DIC_REP0RT 
EDGE TERMINATE_TRANS GET_USER_INPUTS -> PREPARE_PERIODIC_REPORT 
EDGE TCD TRANSMIT COMMAND PREPARE PERIODIC REPORT -> MAKE ROUTING 


DATA STREAM 

INPUT_LINK_MESSAGE 
INPUT_TEXT_RErORD 
TDD ARCHIVE SETUP 


FILENAME, 

TEXT_RECORD, 

ARCHIVE_SETUP, 


94 




COMMS_TEXT_FILE 

COMMS_ADD_TRACK 

TDD_FILTER 

FILTERED_COMMS_TRACK 

OUT_TRACKS 

SENSOR_DATA 

SENSOR_CONTACT_DATA 

POSITION_DATA 

SENSOR_ADD_TRACK 

FILTERED_SENSOR_TRACK 

TD_TRACK_REQUEST 

WEAPON_STATUSJDATA 

WEAPONS_STATREP 

WEAPONS_EMREP 

TCD_STATUS_QUERY 

TCD_TRANSMIT_COMMAND 

TCD_NETWORK_S ETUP 

TRANSMISSION_MESSAGE 

TCD_EMISSION_CONTROL 

OUTPUT_MESSAGES 

EDITOR_SELECTED 

COMMS_EMAIL 

INITIATE_TRANS 

TERMINATE TRANS 


TEXT_RECORD, 

ADD_TRACK_TUP LE , 

SET_TRACK_FILTER, 

ADD_TRACK_TUPLE, 

TRACK_TUPIiE, 

SENSOR_RECORD, 

LOCAL_TRACK_INFO, 

OWNSHIP_NAVIGATION_INFO , 
ADD_TRACK_TUPLE , 

ADD_TRACK_TUP LE, 
DATABASE_REQUEST , 

WEAPON_STATUS, 
WEAPON_STATUS_REPORT, 
WEAPON_STATUS_REPORT, 

BOOLEAN, 

TRANSMIT_COMMAND, 

NETWORK_SETUP, 

TRANSMISSION_COMMAND, 

EMISSIONS_CONTROL_COMMAND, 
MESSAGE_LIST, 

BOOLEAN, 

FILENAME, 

INITIATE_TRANSMISSION_SEQUENCE, 

BOOLEAN 


CONTROL CONSTRAINTS 
OPERATOR COMMS_LINKS 
PERIOD 50 sec 
OPERATOR PARSE_INPUT_FILE 

TRIGGERED BY SOME INPUT_LINK_MESSAGE 
OPERATOR DECIDE_FOR_ARCHIVING 

TRIGGERED BY SOME INPUT_TEXT_RECORD 
OUTPUT COMMS_TEXT_FILE IF COMMS_TEXT_FILE.ARCHIVE 
OUTPUT COMMS_EMAIL IF NOT COMMS_TEXT_FILE.IS_TRACK 
OPERATOR EXTRACT_TRACKS 

TRIGGERED IF COMMS_TEXT_FILE.IS_TRACK 
OPERATOR FILTER_COMMS_TRACKS 

TRIGGERED BY SOME COMMS_ADD_TRACK 
OPERATOR ADD_COMMS_TRACK 

TRIGGERED BY SOME FILTERED_COMMS_TRACK 
OPERATOR SENSORS 
PERIOD 50 sec 

OPERATOR NAVIGATION_SYSTEM 
PERIOD 50 sec 


95 







OPERATOR ANALYZE_SENSOR_DATA 
TRIGGERED BY SOME SENSORJDATA 
OPERATOR PREPARE_SENSOR_TRACK 

TRIGGERED BY SOME SENSOR_CONTACT_DATA, POSITION_DATA 
OPERATOR FILTER_SENSOR_TRACKS 

TRIGGERED BY SOME SENSOR_ADD_TRACK 
OPERATOR ADD_SENSOR_TRACK 

TRIGGERED BY SOME FILTERED_SENSOR_TRACK 
OPERATOR MONITOR_OWNSHIP_POSITION 
TRIGGERED BY SOME POSITION_DATA 
OPERATOR DISPIAY_TRACKS 

TRIGGERED BY SOME OUT_TRACKS 
OPERATOR GET_USER_INPUTS 

OPERATOR MANAGE_USER_INTERFACE 
OPERATOR WEAPONS_SYSTEMS 
PERIOD 50 sec 

OPERATOR WEAPONS_INTERFACE 

TRIGGERED BY SOME WEAPON_STATUS_DATA 

OUTPUT WEAPONS_EMREP IF WEAPON_STATUS_DATA,STATUS - DAMAGED OR 

WEAPON_STATUS_DATA.STATUS - SERVICE_REQUIRED OR 
WEAPON_STATUS_DATA.STATUS - OUT_OF_AMMUNITION 
OPERATOR STATUS_SCREEN 

TRIGGERED IF TCD_STATUS_QUERY 
OPERATOR EMERGENCY_STATUS_SCREEN 
TRIGGERED BY SOME WEAPONS_EMREP 
OPERATOR MESSAGE_EDITOR 

TRIGGERED IF EDITOR_SELECTED 
OPERATOR MAKE_ROUTING 

TRIGGERED BY SOME TCD_TRANSMIT_COMMAND 
OPERATOR FORWARD_FOR_TRANSMISSION 

TRIGGERED BY SOME TRANSMISSION_MESSAGE 
OUTPUT OUTPUT_MESSAGES IF DUMMY 
OPERATOR CONVERT_TO_TEXT_FILE 

TRIGGERED BY SOME OUTPUT_MESSAGES 
OPERATOR MESSAGE_ARRIVAL_PANEL 
TRIGGERED BY SOME COMMS_EMAIL 
OPERATOR PREPARE_PERIODIC_REPORT 
TRIGGERED IF NOT TERMINATE_TRANS 
PERIOD 50 sec 

END 

OPERATOR MANAGE_USER_INTERFACE 
SPECIFICATION 
END 


96 










IMPLEMENTATION ADA MANAGE_USER_INTERFACE 
END 

OPERATOR COMMS_LINKS 
SPECIFICATION 

OUTPUT INPUT_LINK_MESSAGE : FILENAME 
MAXIMUM EXECUTION TIME 1200 ms 
END 

IMPLEMENTATION ADA COMMS_LINKS 
END 


OPERATOR PARSE_INPUT_FILE 
SPECIFICATION 

INPUT INPUT_LINK_MESSAGE : FILENAME 
OUTPUT INPUT_TEXT_RECORD : TEXT_RECORD 
MAXIMUM EXECUTION TIME 500 MS 
END 

IMPLEMENTATION ADA PARSE_INPUT_FILE 
END 


OPERATOR DECIDE_FOR_ARCHIVING 
SPECIFICATION 

INPUT INPUT_TEXT_RECORD 
TDD_ARCHIVE_SBTUP 
OUTPUT COMMS_TEXT_FILE 
C0MMS_EMA1L 
MAXIMUM EXECUTION TIME 500 ms 
END 

IMPLEMENTATION ADA DECIDE_FOR_ARCHIVING 
END 


TEXT_RECORD, 

ARCHIVE_SETUP 

TEXT_RECORD, 

FILENAME 


OPERATOR EXTRACT_TRACKS 
SPECIFICATION 

INPUT COMMS_TEXT_FILE : TEXT_RECORD 
OUTPUT COMMS_ADD_TRACK : ADD_TRACK_TUPLE 
MAXIMUM EXECUTION TIME 500 ms 
END 

IMPLEMENTATION ADA EXTRACT_TRACKS 
END 

OPERATOR FILTER_COMMS_TRACKS 
SPECIFICATION 

INPUT COMMS_ADD_TRACK : ADD_TRACK_TUPLE, 

TDD FILTER : SET TRACK FILTER 


97 






OUTPUT FILTERED_COMMS_TRACK ; ADD_TRACK_TUPLE 
MAXIMUM EXECUTION TIME 500 ns 
END 

IMPLEMENTATION ADA FILTER_COMMS_TRACKS 
END 

OPERATOR ADD_COMMS_TRACK 
SPECIFICATION 

INPUT FILTERED_COMMS_TRACK : ADD_TRACK_TUPLE, 
TDD_FILTER : SET_TRACK_FILTER 

OUTPUT OUT_TRACKS : TRACK_TUPLE 

MAXIMUM EXECUTION TIME 500 ns 
END 

IMPLEMENTATION ADA ADD_COMMS_TRACK 
END 

OPERATOR SENSORS 
SPECIFICATION 

OUTPUT SENSOR_DATA : SENSOR_RECORD 
MAXIMUM EXECUTION TIME 800 MS 
END 

IMPLEMENTATION ADA SENSORS 
END 

OPERATOR ANALYZE_SENSOR_DATA 
SPECIFICATION 

INPUT SENSOR_DATA : SENSOR_RECORD 

OUTPUT SENSOR_CONTACT_DATA : LOCAL_TRACK_INFO 
MAXIMUM EXECUTION TIME 500 MS 
END 

IMPLEMENTATION ADA ANALYZE_SENSOR_DATA 
END 


OPERATOR PREPARESENSOR_TRACK 
SPECIFICATION 

INPUT SENSOR_CONTACT_DATA : LOCAL_TRACK_INFO, 

POSITION_DATA : OWNSHIP_NAVIGATICN_INFO 

OUTPUT SENSOR_ADD_TRACK ; ADD_TRACK_TUPLE 
MAXIMUM EXECUTION TIME 500 ms 
END 

IMPLEMENTATION ADA PREPARE_SENSOR_TRACK 
END 


98 










OPERATOR FILTER_SENSOR_TRACKS 
SPECIFICATION 

INPUT SENSOR_ADD_TRACK : ADD_TRACK_TUPLE, 

TDD_FILTER : SET_TRACK_FILTER 

OUTPUT FILTERED_SENSOR_TRACK : ADD_TRACK_TUPLE 
STATES APPROVED : BOOLEAN INITIALLY FALSE 
MAXIMUM EXECUTION TIME 500 MS 
END 

IMPLEMENTATION ADA FILTER_SENSOR_TRACKS 
END 

OPERATOR ADD_SENSOR_TRACK 
SPECIFICATION 

INPUT FILTERED_SENSOR_TRACK : ADD_TRACK_TUPLE, 
TDD_FILTER : SET_TRACK_FILTER 

OUTPUT OUT_TRACKS : TRACK_TUPLE 

MAXIMUM EXECUTION TIME 500 ms 
END 

IMPLEMENTATION ADA ADD_SENSOR_TRACK 
END 

OPERATOR NAVIGATION_SYSTEM 
SPECIFICATION 

OUTPUT POSITION_DATA : OWNSHIP_NAVIGATION_INFO 
MAXIMUM EXECUTION TIME 800 MS 
END 

IMPLEMENTATION ADA NAVIGATION_SYSTEM 
END 

OPERATOR MONITOR_OWNSHIP_POSITION 
SPECIFICATION 

INPUT POSITION_DATA : OWNSHIP_NAVIGATION_INFO 

OUTPUT OUT_TRACKS : TRACK_TUPLE 

MAXIMUM EXECUTION TIME 500 MS 
END 

IMPLEMENTATION ADA MONITOR_OWNSHIP_POSITION 
END 

OPERATOR DISPLAY_TRACKS 
SPECIFICATION 

INPUT OUT_TRACKS : TRACK_TUPLE, 

TD_TRACK_REQUEST : DATABASE_REQUEST 

END 

IMPLEMENTATION ADA DISPLAY TRACKS 


99 





END 


OPERATOR GET_USER_INPUTS 
SPECIFICATION 

OUTPUT TDD_ARCHIVE_SETUP : ARCHIVE_SETUP, 

TDD_FILTER : SET_TRACK_FILTER, 

TD_TRACK_REQUEST ; DATABASE_REQUEST, 

TCD_STATUS_QUERY : BOOLEAN, 

TCD_NETWORK_SETXJP : NETWORK_SETUP, 

TCD_EMISSION_CONTROL : EMISSIONS_CONTROL_COMMAND, 

EDITOR_SELECTED : BOOLEAN, 

INITIATE_TRANS : IN1TIATE_TRANSMISSI0N_SEQUENCE, 

TERMINATE__TRANS : BOOLEAN 

END 

IMPLEMENTATION ADA GET_USER_INPUTS 
END 

OPERATOR WEAPONS_INTERFACE 
SPECIFICATION 

INPUT WEAPON_STATUS_DATA : WEAPON_STATUS 
OUTPUT WEAPONS_EMREP :WEAPON_STATUS_REPORT, 

WEAPONS_STATREP :WEAPON_STATUS_REPORT 

STATES CIWS_STATUS, 

GUN_STATUS, 

TWS_STATUS, 

MK48_STATUS : WEAPON_STATUS_TYPE 
INITIALLY READY, READY, READY, READY 
MAXIMUM EXECUTION TIME 500 ms 
END 

IMPLEMENTATION ADA WEAPONS_INTERFACE 
END 

OPERATOR WEAPONS_SYSTEMS 
SPECIFICATION 

OUTPUT WEAPON_STATUS_DATA : WEAPON_STATUS 
MAXIMUM EXECUTION TIME 500 ms 
END 

IMPLEMENTATION ADA WEAPONS_SYSTEMS 
END 

OPERATOR STATUS_SCREEN 
SPECIFICATION 

INPUT WEAPONS STATREP : WEAPON STATUS REPORT, 


100 







TCD_STATUS_QUERY : BOOLEAN 

END 

IMPLEMENTATION ADA STATUS_SCREEN 
END 

OPERATOR EMERGENCY_STATUS_SCREEN 
SPECIFICATION 

INPUT WEAPONS_EMREP : WEAPON_STATUS_REPORT 

END 

IMPLEMENTATION ADA EMERGENCY_STATUS_SCREEN 
END 

OPERATOR MESSAGE_EDITOR 
SPECIFICATION 

INPUT EDITOR_SELECTED : BOOLEAN 

OUTPUT TCD_TRANSMIT_COMMAND : TRANSMIT_COMMAND 
END 

IMPLEMENTATION ADA MESSAGE_EDITOR 
END 

OPERATOR MAKE_ROUTING 
SPECIFICATION 

INPUT TCD_TRANSMIT_COMMAND : TRANSMIT_COMMAND, 
TCD_NETWORK_SETUP : NETWORK_SETUP 
OUTPUT TRANSMISSION_MESSAGE : TRANSMISSION_COMMAND 
MAXIMUM EXECUTION TIME 500 MS 
END 

IMPLEMENTATION ADA MAKE_ROUTING 
END 

OPERATOR FORWARD_FOR_TRANSMISSION 
SPECIFICATION 

INPUT TRANSMISSION_MESSAGE : TRANSMISSION_COMMAND, 

TCD_EMISSION_CONTROL : EMISSIONS_CONTROL_COMMAND 
OUTPUT OUTPUT_MESSAGES : MESSAGE_LIST 

STATES WAITING_MESSAGES : MESSAGE_LIST INITIALLY NULL 

MAXIMUM EXECUTION TIME 500 MS 
END 

IMPLEMENTATION ADA FORWARD_FOR_TRANSMISSION 
END 

OPERATOR CONVERT_TO_TEXT_FILE 
SPECIFICATION 

INPUT OUTPUT MESSAGES : MESSAGE LIST 


101 




MAXIMUM EXECUTION TIME 800 MS 
END 

IMPLEMENTATION ADA CONVERT_TO_TEXT_FILE 
END 

OPERATOR MESSAGE_ARRIVAL__PAN£L 
SPECIFICATION 

INPUT COMMS_EMAIL : FILENAME 
END 

IMPLEMENTATION ADA MESSAGE_ARRIVAL_PANEL 
END 

OPERATOR PREPARE_PERIODIC_REPORT 
SPECIFICATION 

INPUT INITIATE_TRANS : INITIATE_TRANSMISSION_SEQUENCE, 

TERMINATE_TRANS : BOOLEAN 

OUTPUT TCD_TRANSMIT_COMMAND : TRANSMIT_COMMAND 

MAXIMUM EXECUTION TIME 800 MS 

END 

IMPLEMENTATION ADA PREPARE_PERIODIC_REPORT 
END 


102 








Figure B-1. Flat Level PSDL Graph 




APPENDIX C 


DRIVER PACKAGE 
TL.A 

This appendix contains the Ada package tl.iL The translator gets the psdl.txt file 
provided in Appendix B as input, and creates this driver package. 

Package d.a includes a buffer instantiation for each data stream, and a driver pro¬ 
cedure for each atomic operator. 


package TL is 

procedure PREPARE_PERIODIC_REPORT_DRIVER; 
procedure MESSAGE_ARRIVAL_PANEL_DR1VER; 
procedure CONVERT_TO_TEXT_FILE_DRIVER; 
procedure FORWARD_FOR_TRANSMISSION_DRIVER; 
procedure MAKE_ROUTING_DRIVER; 
procedure MESSAGE_EDITOR_DRIVER; 
procedure EMERGENCY_STATUS_SCREEN_DRIVER; 
procedure STATUS_SCREEN_DRIVER; 
procedure WEAPONS_INTERFACE_DRIVER; 
procedure WEAPONS_SySTEMS_DRIVER; 
procedure MANAGE_USER_INTERFACE_DRIVER; 
procedure GET_USER_INPUTS_DRIVER; 
procedure DISPIAY_TRACKS_DRIVER; 
procedure MONITOR_OWNSHIP_POSITION_DRIVER; 
procedure ADD_SENSOR_TRACK_DRIVER; 
procedure FILTER_SENSOR_TRACKS_DRIVER; 
procedure PREPARE_SENSOR_TRACK_DRIVER; 
procedure ANALYZE_SENSOR_DATA_DRIVER; 
procedure NAVIGATION_SYSTEM_DRIVER; 
procedure SENSORS_DRIVER; 
procedure ADD_COMMS_TRACK_DRIVER; 
procedure FILTER_COMMS_TRACKS_DRIVER; 
procedure EXTRACT_TRACKS_DRIVER; 


105 





procedure DECIDE_F0R_ARCHIV1NG_DRIVER; 
procedure PARSE_1NPUT_FILE_DRIVER; 
procedure COMMS_LINKS_DRIVER; 
end TL; 


with SB; use SB; 

with PSDL_STREAMS; use PSDL_STREAMS; 
with DS_Debug_PKG; use DS_Debug_PKG; 

> with PSDL_TIMER_PKG; 
package body TL is 

type PSDL_EXCEPTION is (UNDECLARED_ADA_EXCEPTION); 
package C3l_SySTEM_SPEC is 

package DS_TERMINATE_TRANS is new SAMPLED_BUFFER(BOOLEAN); 
package DS_INITIATE_TRANS is new 

SAMPLED_BUFFER(INITIATE_TRANSMISSION_SEQUENCE); 
package DS_COMMS_EMAIL is new SAMPLED_BUFFER(FILENAME); 
package DS_EDITOR_SELECTED is new SAMPLED_BUFFER(BOOLEAN); 
package DS_OUTPUT_MESSAGES is new SAMPLED_BUFFER(MESSAGE_LIST); 
package DS_TCD__EMISSION_CONTROL is new 

SAMPLED_BUFFER(EM1SS10NS_C0NTR0L_C0MMAND); 
package DS_TRANSMISSION_MESSAGE is new 

SAMPLED_BUFFER(TRANSMISSION_COMMAND); 
package DS_TCD__NETWORK_SETUP is new SAMPLED_BUFFER(NETWORK_SETUP); 
package DS_TCD__TRANSMIT_COMMAND is new 

SAMPLED_BUFFER(TRANSMIT_COMMAND); 
package DS_TCD__STATUS_QUERY is new SAMPLED_BUFFER(BOOLEAN); 
package DS_WEAPONS_EMREP is new 

SAMPLED_BUFFER(WEAPON_STATUS_REPORT); 
package DS_WEAPONS_STATREP is new 

SAMPLED_BUFFER(WEAPON_STATUS_REPORT); 
package DS_WEAPON_STATUS_DATA is new SAMPLED_BUFFER(WEAPON_STATUS); 
package DS_TD_TRACK_REQUEST is new SAMPLED_BUFFER(DATABASE_REQUEST) 
package DS_FILTERED_SENSOR_TRACK is new 

SAMPLED_BUFFER(ADD_TRACK_TUPLE); 
package DS_SENSOR_ADD__TRACK is new SAMPLED_BUFFER(ADD_TRACK_TUPLE); 
package DS_P0S1T10N_DATA is new 

SAMPLED_BUFFER(OWNSHIP_NAVIGATION_INFO); 
package DS_SENSOR_CONTACT_DATA is new 


106 





SAMPLED_BUFFER(LOCAL_TRACK_INFO) 
package DS_SENSOR_DATA is new SAMPLED_BUFFER(SENSOR_RECORD); 
package DS_OUT_TRACKS is new SAMPI.ED__BUFFER(TRACK_TUPLE) ; 
package DS_FILTERED_COMMS_TRACK is new 

SAMPLED_BUFFER(ADD_TRACK_TUPLE) 

package DS_TDD_FILTER is new SAMPLED_BUFFER(SET_TRACK_FILTER); 
package DS_COMMS_ADD_TRACK is new SAMPLED_BUFFER{ADD_TRACK_TUPLE); 
package DS_COMMS_TEXT_FILE is new SAMPLED_BUFFER(TEXT_RECORD); 
package DS_TDD_ARCHIVE_SETUP is new SAMPLED_BUFFER(ARCHIVE_SETUP); 
package DS_INPUT_TEXT_RECORD is new SAMPLED_BUFFER(TEXT_RECORD); 
package DS_INPUT_LINK_MESSAGE is new SAMPLED_BUFFER(FILENAME); 
package JUNK is new SAMPLED_BUFFER( ARCHIVE_SETUP); 
end C3I_SYSTEM_SPEC; 

procedure PREPARE_PERIODIC_REPORT_DRIVER is 

LV_INITIATE_TRANS: INITIATE_TRANSMISSION_SEQUENCE; 
LV_TERMINATE_TRANS: BOOLEAN; 

LV_TCD_TRANSMIT_COMMAND: TRANSMIT_COMMAND; 

EXCEPTION_HAS_OCCURRED: boolean := false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if true then 
begin 

C3l_SySTEM_SPEC.DS_INITIATE_TRANS.BUFFER.READ 
(LV_INITIATE_TRANS); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("INITIATE_TRANS", "PREPARE_PERIODIC_REPORT"); 

end; 

begin 

C3I_SYSTEM_SPEC.DS_TERMINATE_TRANS.BUFFER.READ 
(LV_TERMINATE_TRANS); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("TERMINATE_TRANS", "PREPARE_PERIODIC_REPORT"); 

end; 

if not LV_TERMINATE_TRANS then 
begin 

PREPARE PERIODIC REPORT 


107 






(LV_INITIATE_TRANS, LV_TERMINATE_TRANS, LV_TCD_TRANSMIT_COMMAND); 
exception 

when others ■> 

DS_Debu 9 .Undeclared_Exception("PREPARE_PERIODIC_REPORT"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECLARED_ADA_EXCEPTION; 

end; 

begin 

C3l_S1fSTEM_SPEC. DS_TCD_TRANSMIT_COMMAND. BUFFER. WRITE 
{LV__TCD_TRANSMIT_COMMAND) ; 
exception 

when BUFFER_OVERFLOW -> 

DS^Debug.Buf £er_Overflow 

("TCD_TRANSMIT_COMMAND", "PREPARE_PERIODIC_REPORT"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

("PREPARE_PERIODIC_REPORT", PSDL_EXCEPTION'image(EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end PREPARE_PERIODIC_REPORT_DRIVER; 

procedure MESSAGE_ARRIVAL_PANEL_DRrVER is 
LV_COMMS_EMAIL: FILENAME; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if C3I_SySTEM_SPEC.DS_COMMS_EMAIL.NEW_DATA then 
begin 

C3I_SySTEM_SPEC.DS_COMMS_EMAIL. BUFFER. READ(LV_COMMS_EMAIL) ; 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buf fer_Underflow 
("COMMS_EMAIL", "MESSAGE_ARRIVAL_PANEL"); 

end; 

if true then 
begin 

MESSAGE_ARRIVAL_PANEL(LV_C0MMS_EMA1L); 
exception 

when others -> 


108 





DS_Debug.Undeclared_Exception("MESSAGE_ARRIVAL_PANEL"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECLARED_ADA_EXCEPTION; 

end; 

if EXCEPTION_HAS_CX:CURRED then 
OS_Debug.Unhandled_Exception 

{"MESSAGE_ARRIVAL_PANEL", PSDL_EXCEPTION' image(EXCEPTION_ID)) 
end if; 
end if; 
end if; 

end MESSAGE_ARRIVAli_PANEL_DRIVER; 

procedure C0NVERT_T0_TEXT_FILE_DR1VER is 
LV_OUTPUT_MESSAGES: MESSAGE_L1ST; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if C3I_SYSTEM_SPEC.DS_0UTPUT_MESSAGES.NEW_DATA then 
begin 

C3I_SYSTEM_SPEC.DS_OUTPUT_MESSAGES,BUFFER.READ 
(LV_OUTPUT_MESSAGES); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("OUTPUT_MESSAGES", "CONVERT_TO_TEXT_FILE"); 

end; 

if true then 
begin 

CONVERT_TO_TEXT_FILE(LV_OUTPUT_MESSAGES); 
exception 

when others ■> 

DS_Debug.Undeclared_Exception("CONVERT_TO_TEXT_FILE"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECLARED_ADA_EXCEPTION; 

end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

("CONVERT_TO_TEXT_FILE", PSDL_EXCEPTION'image(EXCEPTION_ID)) 
end if; 
end if; 
end if; 


109 






end CONVERT_TOJTEXT_PILEJ)RIVER; 

procedure FORWARD_FOR_TRANSMlSSION_DRIVER is 
LV_TRANSMISSION_MESSAGE: TRANSMISS10N_C0MMAND; 
LV_TCD_EMISSION_CONTROL: EMISSIONS_CONTROL_COMMAND; 
LV_OUTPUT_MESSAGES: MESSAGE_LIST; 

EXCEPTION_HAS_OCajRRED: boolean false; 

EXCEPTION_ID; PSDL_EXCEPTION; 
begin 

if C31_SYSTEM_SPEC.DS_TRANSM1SSI0N_MESSAGE.NEW_DATA then 
begin 

C3l_SySTEM_SPEC.DS_TRANSMISSION_MESSAGE.BUFFER.READ 
(LV_TRANSMISSION_MESSAGE); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 

("TRANSMISS10N_MESSAGE", "FORWARD_FOR_TRANSMISSION"); 

end; 

begin 

C3l_SySTEM_SPEC.DS_TCD_EMISSION_CONTROL.BUFFER.READ 
(LV_TCD_EMISSION_CONTROL) ; 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 

("TCD_EMISSION_CONTROL", "FORWARD_FOR_TRANSMISSION"); 

end; 

if true then 
begin 

FORWARD_FOR_TRANSMISSION(LV_TRANSMISSION_MESSAGE, 
LV_TCD_EMISSION_CONTROL, LV_OUTPUT_MESSAGES); 
exception 

when others ■> 

DS_Debug.Undeclared_Exception("FORWARD_FOR_TRANSMISSION"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECLARED_ADA_EXCEPTION; 

end; 

if LV_TCD_EMISSION_CONTROL - UNRESTRICTED 
then 
begin 

C31_SYSTEM_SPEC.DS_OUTPUT_MES SAGES.BUFFER.WRITE 
(LV OUTPUT MESSAGES); 


no 






exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("OUTPUT_MESSAGES", "FORWARD_FOR_TRANSMISSION"); 
end; 
end if; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

("FORWARD_FOR_TRANSMISSION", PSDL_EXCEPTION'image(EXCEPTION_ID)) 
end if; 
end if; 
end if; 

end FORWARD FOR TRANSMISSION DRIVER; 


procedure MAKE_ROUTING_DRIVER is 

LV_TCD_TRANSMIT_COMMAND: TRANSMIT_COMMAND; 

LV_TCD_NETWORK_S ETUP: NETWORK_SETUP; 

LV_TRANSMISSION_MESSAGE: TRANSMISSION_COMMAND; 
EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if C3I_SYSTEM_SPEC.DS_TCD_TRANSMIT_C0MMAND,NEW_DATA then 
begin 

C3I_SYSTEM_SPEC.DS_TCD_TRANSMIT_COMMAND.BUFFER.READ 
{LV_TCD_TRANSMIT_COMMAND); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("TCD_TRANSMIT_COMMAND", "MAKE_ROUTING"); 

end; 

begin 

C3I_SYSTEM_SPEC.DS_TCD_NETWORK_SETUP.BUFFER.READ 
(LV_TCD_NETWORK_SETUP); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("TCD_NETWORK_SETUP", "MAKE_ROUTING"); 

end; 

if true then 
begin 

MAKE_ROUTING(LV_TCD_TRANSKIT_COMMAND, LV_TCD_NETWORK_SETUP, 


111 





LV_TRANSMISSION_MESSAGE); 

exception 

when others ■> 

DS_Debug.Undeclared_Exception("MAKE_ROUTING"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECIARED_ADA_EXCEPTION; 

end; 

begin 

C3I_SYSTEM_SPEC.DS_TRANSMISS10N_MESSAGE.BUFFER.WRITE 
<LV_TRANSMISS10N_MESSAGE); 
exception 

when BUFFER_OVERFLOW -> 

OS_Debug.Buffer_Overflow 
("TRANSMISSION_MESSAGE", "MAKE_ROUTING"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 
("MAKE_ROUTING", PSDL_EXCEPTION'image(EXCEPTI0N_1D)); 
end if; 
end if; 
end if; 

end MAKE_ROUTING_DRIVER; 

procedure MESSAGE_ED1T0R_DRIVER is 
LV_EDITOR_SELECTED: BOOLEAN; 

LV_TCD_TRANSMIT_COMMAND: TRANSMIT_COMMAND; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if true then 
begin 

C3I_SYSTEM_SPEC.DS_EDITOR_SELECTED.BUFFER.READ 
(LV_EDITOR_SELECTED); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("EDITOR_SELECTED", "MESSAGE_EDITOR"); 

end; 

if LV_EDITOR_SELECTED then 
begin 

MESSAGE EDITOR(LV_EDITOR SELECTED, LV_TCD_TRANSMIT_COMMAND); 


112 




exception 

when others -> 

DS_Debug.Undeclared_Exception("MESSAGE_EDITOR"); 

EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECLARED_ADA_EXCEPTION; 

end; 

begin 

C3l_SySTEM_SPEC.DS_TCD_TRANSMIT_COMMAND.BUFFER.WRITE 
(LV_TCD_TRANSMIT_COMMAND); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buf fer_Overflow 
("TCD_TRANSMIT_COMMAND", "MESSAGE_EDITOR"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 
{"MESSAGE_EDITOR", PSDL_EXCEPTION'image(EXCEPT10N_ID)); 
end if; 
end if; 
end if; 

end MESSAGE_EDITOR_DRIVER; 

procedure EMERGENCY_STATUS_SCREEN_DRIVER is 
LV_WEAPONS_EMREP: WEAPON_STATUS_REPORT; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTI0N_1D: PSDL_EXCEPTION; 
begin 

if C3l_SySTEM_SPEC.DS_WEAPONS_EMREP.NEW_DATA then 
begin 

C3l_SySTEM_SPEC.DS_WEAPONS_EMREP.BUFFER.READ(LV_WEAPCNS_EMREP) 
exception 

when BUFFER_UNDERFLOW »> 

DS_Debug.Buffer_Underf1ow 
("WEAPONS_EMREP", "EMERGENCy_STATUS_SCREEN"); 

end; 

if true then 
begin 

EMERGENCy_STATUS_SCREEN(LV_WEAPONS_EMREP); 
exception 

when others *> 

DS_Debug.Undeclared_Exception("EMERGENCy_STATUS_SCREEN"); 


113 




EXCEPTION_HAS_OCCURRED true; 

EXCEPT10N_ID UNDECIARED_ADA_EXCEPTION; 

end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug. Unhanciled_Exception 

("EMERGENCY_STATUS_SCREEN", PSDL_EXCEPTION'image <EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end EMERGENCY STATUS SCREEN DRIVER; 


procedure STATUS_SCREEN_DRIVER is 

LV_WEAPONS_STATREP: WEAPON_STATUS_REPORT; 

LV_TCD_STATUS_QUERY: BOOLEAN; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if true then 
begin 

C3l_SYSTEM_SPEC.DS_WEAPONS_STATREP.BUFFER.READ 
(LV_WEAPONS_STATREP); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow("WEAPONS_STATREP", "STATUS_SCREEN") 

end; 

begin 

C3I_SYSTEM_SPEC.DS_TCD_STATUS_QUERY.BUFFER.READ 
(LV_TCD_STATUS_QUERY); 
exception 

when BUFFER_UNDERFLOW ■> 

DS_Debug.Buffer_Underflow 
{"TCD_STATUS_QUERY", "STATUS_SCREEM"); 

end; 

if LV_TCD_STATUS_QUERY then 
begin 

STATUS_SCREEN(LV_WEAPONS_STATREP, LV_TCD_STATUS_QUERY); 
exception 

when others -> 

DS_Debug.Undeclared_Exception ("STATUS_SCREEiV") ; 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION ID UNDECLARED ADA EXCEPTION; 


114 








end; 

if EXCEPTION HAS OCCURRED then 


DS_Debug.Unhandled_Exception 
("STATUS_SCREEN", PSDL_EXCEPTION'image{EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end STATUS_SCREEN_DRIVER; 
procedure WEAPONS_INTERFACE_DRIVER is 
LV_WEAPON_STATUS_DATA: WEAPON_STATUS; 

LV_WEAPONS_STATREP: WEAPON_STATUS__REPORT; 

LV_WEAPONS_EMREP: WEAPON_STATUS_REPORT; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if C3I_SYSTEM_SPEC.DS_WEAP0N_STATUS_DATA.NEW_DATA then 
begin 

C3I_SYSTEM_SPEC.DS_WEAPON_STATUS_DATA.BUFFER.READ 
(LV_WEAPON_STATUS_DATA); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("WEAPON_STATUS_DATA", "WEAPONS_INTERFACE"); 

end; 

if true then 
begin 

WEAPONS_INTERFACE(LV_WEAPON_STATUS_DATA, LV_WEAPONS_EMREP, 

LV_WEAPONS_STATREP); 

exception 

when others “> 

DS_Debug.Undeclared_Exception("WEAPONS_INTERFACE"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECLARED_ADA_EXCEPTION; 

end; 

if LV_WEAPON_STATUS_DATA.STATUS - DAMAGED or 

LV_WEAPON_STATUS_DATA.STATUS - SERVICE_REQUIRED or 
LV_WEAPON_STATUS_DATA.STATUS = OUT_OF_AMMUNITION 
then 
begin 

C3I_SYSTEM_SPEC.DS_WEAPONS_EMREP.BUFFER.WRITE 
(LV WEAPONS EMREP); 


115 




exception 

when BUFFER_OVERFLOW -> 

DS^Debug.Buffer_Overflow 
("WEAPONS_EMREP", "WEAPONS_INTERFACE"); 
end; 
end if; 
begin 

C3I_SYSTEM_SPEC. DS_WEAPONS_STATREP, BUFFER. WRITE 
(LV_WEAPONS_STATREP); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buf fer_Overflow 
("WEAPONS_STATREP", "WEAP0NS_1NTERFACE"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

("WEAPONS_INTERFACE", PSDL_EXCEPT10N'image(EXCEPTION_ID)) 
end if; 
end if; 
end if; 

end WEAPONS_INTERFACE_DRIVER; 

procedure WEAPONS_SYSTEMS_DRIVER is 
LV_WEAPON_STATUS_DATA: WEAPON_STATUS; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID; PSDL_EXCEPT10N; 
begin 

if true then 
if true then 
begin 

WEAPONS_SYSTEMS (IiV_WEAPON_STATUS_DATA) ; 
exception 

when others "•> 

DS_Debug.Undeclared_Exception ("WEAPONS_SYSTEMS"); 
EXCEPTION_HAS_OCaJRRED true; 

EXCEPTION_ID UNDECLARED_ADA_EXCEPTION; 

end; 

begin 

C3I_SYSTEM_SPEC.DS_WEAPON_STATUS_DATA.BUFFER.WRITE 
{LV_WEAPON_STATUS_DATA); 
exception 


116 






when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("WEAPON_STATUS_DATA", "WEAPONS_SySTEMS"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 
("WEAPONS_SYSTEMS", PSDL_EXCEPTION'image(EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end WEAPONS_SYSTEMS_DRIVER; 

procedure MANAGE_USER_INTERFACE_DR1VER is 
EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if true then 
if true then 
begin 

MANAGE_USER_INTERFACE; 
exception 

when others ■> 

DS_Debug.Undeclared_Exception("MANAGE_USER_I»TERFACE"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECLARED_ADA_EXCEPTION; 

end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

("MANAGE_USER_INTERFACE", PSDL_EXCEPTION'image(EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end MANAGE_USER_INTERFACE_DRIVER; 

procedure GET_USER_INPUTS_DRIVER is 
LV_TDD_ARCHIVE_SETUP: ARCHIVE_SETUP; 

LV_TDD_FILTER: SET_TRACK_FILTER; 

LV_TD_TRACK_REQUEST; DATABASE_REQUEST; 

LV_TCD_STATUS_QUERY: BOOLEAN; 

LV_EDITOR_SELECTED; BOOLEAN; 

LV TCD NETWORK SETUP: NETWORK SETUP; 


117 



LV_TCD_EMISSION_CONTROL: EMISSIONS_CONTROL_COMMAND; 

LV_INITIATB_TRANS; INITIATE_TRANSMISSIOM_SEQUENCE; 

LV_TERM1NATE_TRANS: BOOLEAN; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if true then 
if true then 
begin 

GET_USER_INPUTS(LV_TDD_ARCHIVE_SETUP, LV_TDD_FILTER, 
LV_TI>_TRACK_REQUEST,LV_TCD_STATUS_Ot?ERY, 
LV_TCD_NETWORK_SETUP, LV_TCD_EM1SSION_CONTROL, 
LV_EDITOR_SELECTED, LV_1NITIATE_TRANS, 
LV_TERMINATE_TRANS); 
exception 

when others ”> 

DS_Debug.Undeclared_Exception("GET_USER_INPUTS"); 

EXCEPTION_HASjOCCURRED true; 

EXCEPTION_ID UNDECLARED_ADA_EXCEPTION; 

end; 

begin 

C31_SYSTEM_SPEC.DS_TERMINATE_TRANS.BUFFER.WRITE 
(LV_TERMINATE_TRANS); 
exception 

when BUPFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
(''TERMINATE_TRANS" , "GET_USER_INPUTS" ) ; 
end; 
begin 

C3I_SYSTEM_SPEC.DS_IN1TIATE_TRANS.BUFFER.WRITE 
(LV_INITIATE_TRANS); 
exception 

when BUFFER_OVERFLOW ■> 

DS_Debug.Buffer_Overflow 
("INITIATE_TRANS", "GET_USER_INPUTS"); 
end; 
begin 

C3I_SYSTEM_SPEC.DS_EDITOR_SELECTED.BUFFER.WRITE 
(LV_EDITOR_SELECTED); 
exception 

when BUFFER OVERFLOW -> 


118 




DS_Debug.Buffer_Overflow 
("EDITOR_SELECTED", "GET_USER_INPUTS"); 
end; 
begin 

C3I_SYSTEM_SPEC.DS_TCD_EMISSION_CONTROL.BUFFER.WRITE 
{LV_TCD_EMISSION_CONTROL); 
exception 

when BUFFER_OVERFLOW »> 

DS_Debug.Buffer_Overflow 
{"TCD_EMISSION_CONTROL", ••GET_USER_INPUTS") ; 
end; 
begin 

C3I_SYSTEM_SPEC.DS_TCD_NETWORK_SETUP.BUFFER.WRITE 
(LV_TCD_NETWORK_SETUP); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("TCD_NETWORK_SETUP", "GET_USER_INPUTS"); 
end; 
begin 

C3I_SYSTEM_SPEC.DS_TCD_STATUS_QUERY.BUFFER.WRITE 
(LV_TCD_STATUS_QUERY); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("TCD_STATUS_QUERY", "GET_USER_INPUTS"); 
end; 
begin 

C3I_SYSTEM_SPEC.DS_TD_TRACK_REQUEST.BUFFER.WRITE 
(LV_TO_TRACK_REQUEST); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("TD_TRACK_REQUEST", "GET_USER_INPUTS"); 
end; 
begin 

C3I_SYSTEM_SPEC.DS_TDD_FILTER.BUFFER.WRITE 
(LV_TDD_FILTER); 
exception 

when BUFFER_OVERFI.OW -> 

DS_Debug.Bu f fe r_Ove rf1ow 


119 






(-rDD_FILTER", "GET_USER_INPI;TS") ; 
end; 
begin 

C3I_SySTEM_SPEC.DS_TDD_ARCHIVE_SETUP,BUFFER.WRITE 
(LV_TDD_ARCHIVE_SETUP); 
exception 

when BUFFER_OVERFI.OW -> 

DS_Debug.Buffer_Overflow 
("TDD_ARCHIVE_SETUP", "GET_USER_1NPUTS"); 
end; 

if EXCEPT10N_HAS_0CCURRED then 
DS_Debug.Unhandled_Exception 
("GET_USER_INPUTS", PSDhJEXCEPTION'image(EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end GET USER INPUTS DRIVER; 


procedure DISPLAy_TRACKS_DRIVER is 
LV_OUT_TRACKS: TRACK__TUP LE ; 

IiV_TD_TRACK_REQUEST: DATABASE_REQUEST; 

EXCBPTION__HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPT10N; 
begin 

if C3I_SYSTEM_SPEC.DS_0UT_TRACKS.NEW_DATA then 
begin 

C3l_SySTEM_SPEC. DS_OUT_TBACKS. BUFFER. READ (LV_OUT_TRACKS) ; 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow("OUT_TRACKS", "DISPIiAY_TRACKS") 

end; 

begin 

C3I_SYSTEM_SPEC.DS_TD_TRACK_REQUEST.BUFFER.READ 
(LV_TD_TRACK_REQUEST); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
(»TD_TRACK_REQUEST", "DISPLAY_TRACKS"); 

end; 

if true then 
begin 


120 






D1SPIAY_TRACKS(LV_0UT_TRACKS, LV_TD_TRACK_REQUEST); 
exception 

when others ■•> 

OSJDehug.Undeclared_Elxception ("DISPLAY_TRACKS"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECIARED_ADA_EXCEPTION; 

end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 
("DISPIAY_TRACKS", PSDL_EXCEPTION'image(EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end DISPIAY_TRACKS_DRIVER; 

procedure MONITOR_OWNSHIP_POSITION_DRIVER is 
LV_POSITION_DATA: OWNSHIP_NAVIGATION_INFO; 

LV_OUT_TRACKS: TRACK_TUPLE; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if C3I_SYSTEM_SPEC.DS_P0SITI0N_DATA.NEW_DATA then 
begin 

C31_SYSTEM__SPEC.DS_P0SIT10N_DATA.BUFFER.READ (LV_POSITION_DATA) ; 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("POSITION_DATA", "MONITOR_OWNSHIP_POSITION"); 

end; 

if true then 
begin 

MONITOR_OWNSHIP_POSITION(LV_POSITION_DATA, LV_OUT_TRACKS); 
exception 

when others ■> 

DS_Debug.Undeclared_Exception("MONITOR_OWNSHIP_POSITION"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECLARED_ADA_EXCEPTION; 

end; 

begin 

C3I_SYSTEM_SPEC.DS_OUT_TRACKS.BUFFER.WRITE(LV_OUT_TRACKS); 
exception 


121 




when BUFFER_OVERFLOW -> 

DS_Debug.Buf fer_Overflow 
("OUT_TRACKS", "MONlTOR_OWNSHIP_POSITION"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

("MONITOR_OWNSHIP_POSITION", PSDL_EXCEPTION'image{EXCEPTION_ID)) 
end if; 
end if; 
end if; 

end MONITOR OWNSHIP POSITION DRIVER; 


procedure ADD_SENSOR_TBACK_DRIVER is 

LV_FILTERED_SENSOR_TRACK: ADD_TRACK_TUPLE; 

LV_TDD_FILTER: SET_TRACK_FIliTER; 

LV_OUT_TRACKS: TRACK_TUPLE; 

EXCEPTION_HAS_OCCORRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if C3I_SYSTEM_SPEC.DS_FILTERED_SENSOR_TRACK.NEW_DATA then 
begin 

C3I_SYSTEM_SPEC.DS_FILTERED_SENSOR_TRACK.BUFFER.READ 
(LV_FILTERED__SENSOR_TRACK); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("FILTERED_SENSOR_TRACK", "ADD_SENSOR_TRACK"); 

end; 

begin 

C3I_SYSTEM_SPEC.DS_TDD_FILTER.BUFFER.READ(LV_TDD_FILTER); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow("TDD_FILTER", "ADD_SENSOR_TRACK"); 

end; 

if true then 
begin 

ADD_SENSOR_TRACK{LV_F1LTERED_SENSOR_TRACK, 

LV_TDD_FILTER, LV_OUT_TRACKS); 

exception 

when others ■> 

DS_Debug.Undeclared_Exception{"ADD_SENSOR__TRACK"); 


122 






EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECIARED_ADA_EXCEPT10N; 

end; 

begin 

C3l_SySTEM_SPEC.DS_OUT_TRACKS.BUFFER.WRITE(LV_OUT_TRACKS) 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("OUT_TRACKS", "ADD_SENSOR_TRACK"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

("ADD_SENSOR_TRACK", PSDL_EXCEPTION'image(EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end ADD_SENSOR_TRACK_DRIVER; 

procedure FILTER_SENSOR_TRACKS_DRIVER is 
LV_SENSOR_ADD_TRACK: ADD_TRACK_TUPLE; 

LV_TDD_FILTER: SET_TRACK_FILTER; 

I,V_F1 LTERED_SENSOR_TRACK: ADD_TRACK_TUPLE; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDI,_EXCEPTION; 
begin 

if C3I_SYSTEM_SPEC.DS_SENS0R_ADD_TRACK.NEW_DATA then 
begin 

C3I_SYSTEM_SPEC.DS_SENSOR_ADD_TRACK.BUFFER.READ(LV_SENSOR_ADD_TRACK); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("SENSOR_ADD_TRACK", "FILTER_SENSOR_TRACKS"); 

end; 

begin 

C3I_SYSTEM_SPEC.DS_TDD_FILTER.BUFFER.READ(LV_TDD_FILTER); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("TDD_FILTER", "FILTER_SENSOR_TRACKS"); 

end; 


123 







if true then 
begin 

FILTER_SENSOR_TRACKS(LV_SENSOR_ADD_TRACK, LV_TDD_FILTER, 
LV_FILTERED_SENSOR_TRACK); 
exception 

when others ■■> 

DS_Debug.Undeclare<l_Exception("FILTER_SENSOR_TRACKS"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECIARED_ADA_EXCEPTION; 

end; 

begin 

C3l_SySTEM_SPEC.DS_FILTERED_SENSOR_TRACK.BUFFER.WRITE 
(LV_FILTERED_SENSOR_TRACK); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 

("FILTERED_SENSOR_TRACK", "FILTER_SENSOR_TRACKS"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

("FILTER_SENSOR_TRACKS", PSD1-_EXCEPTI0N'image{EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end FII,TER_SENS0R_TRACKS_DR1VER; 

procedure PREPARE_SENSOR_TRACKJDRIVER is 
LV_SENSOR_CONTACT_DATA: L0CAL_TRACK_1NF0; 

LV_POSITION_DATA: OWNSHIP_NAVIGATION_INFO; 

LV_SENSOR_ADD_TRACK: ADD_TRACK_TUPLE; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPT10N; 
begin 

if C3I_SySTEM_SPEC.DS_POSlTION_DATA.NEW_DATA OR 

C3I_SySTEM_SPEC.DS_SENSOR_CONTACT_DATA.NEW_DATA then 

begin 

C3l_SySTEM_SPEC.DS_SENSOR_CONTACT_DATA.BUFFER.READ 
(LV_SENSOR_CONTACT_DATA); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underf1ow 


124 








("SENSOR_CONTACT_DATA", "PREPARE_SENSOR_TRACK"); 

end; 

begin 

C3I_SYSTEM_SPEC.DS_POSITION_DATA.BUFFER.READ(LV_POSITION_DATA) 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Bu££er_Under£low 
{"POSITION_DATA", "PREPARE_SENSOR_TRACK"); 

end; 

i£ true then 
begin 

PREPARE_SENSOR_TRACK(LV_SENSOR_CONTACT_DATA, 
LV_POSITION_DATA, LV_SENSOR_ADD_TRACK); 
exception 

when others -> 

DS_Debug.Undeclared_Exception("PREPARE_SENSOR_TRACK"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECLARED_ADA_EXCEPTION; 

end; 

begin 

C3I_SYSTEM_SPEC,DS_SENSOR_ADD_TRACK.BUFFER,WRITE 
(LV_SENSOR_ADD_TRACK); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Bu££er_Over£low 
("SENSOR_ADD_TRACK", "PREPARE_SENSOR_TRACK"); 
end; 

i£ EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

("PREPARE_SENSOR_TRACK", PSDL_EXCEPTION'image(EXCEPTION_ID)) 
end i£; 
end i£; 
end i£; 

end PREPARE_SENSOR_TRACK_DRIVER; 

procedure ANALY2E_SENS0R_DATA_DRIVER is 
LV_SENSOR_DATA: SENSOR_RECORD; 

LV_SENSOR_CONTACT_DATA: LOCAL_TRACK_INFO; 

EXCEPTION_HAS_OCCURRED: boolean £alse; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 


125 





if C3I_SySTBM_SPEC.DS_SENS0R_DATA.NEW_DATA then 
begin 

C3I_SYSTEM_SPEC.DS_SENSOR_DATA.BUFFER.READ (I.V_SENSOR_DATA) ; 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("SENSOR_DATA", "ANALYZE_SENSOR_DATA"); 

end; 

if true then 
begin 

ANALYZE_SENSOR_DATA{LV_SENSOR_DATA, LV_SENSOR_CONTACT_DATA); 
exception 

when others *> 

DS_Debug.Undeclared_Exception("ANALYZE_SENSOR_DATA"); 
EXCEPT10N_HAS_0CCURRED true; 

EXCEPTI0N_1D UNDECLARED_ADA_EXCEPTION; 

end; 

begin 

C3I_SYSTEM_SPEC.DS_SENSOR_CONTACT_DATA.BUFFER.WRITE 
(LV_SENSOR_CONTACT_DATA); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("SENSOR_CONTACT_DATA", -ANALYZE_SENSOR_DATA"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

("ANALYZE_SENSOR_DATA", PSDL_EXCEPTION'image(EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end ANALYZE_SENSOR_DATA_DRIVER; 

procedure NAVIGAT10N_SYSTEM_DRIVER is 

LV_POSITION_DATA: OWNSHIP_NAVIGATION_INFO; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if true then 
if true then 
begin 


126 







NAVIGATION_SYSTEM(LV_POSITION_DATA); 
exception 

when others *> 

DS_Debug.Undeclared_Exception("NAVIGATION_sySTEM"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID ONDECLARED_ADA_EXCEPTION; 

end; 

begin 

C3I_SYSTEM_SPEC.DS_POSITION_DATA.BUFFER.WRITE 
(LV_POSITION_DATA); 
exception 

when BUFFER_OVERFLOW -> 

DS__Debug • Buf f er_Overf low 
{"POSITION_DATA", "NAVIGATION_SYSTEM"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

("NAVIGATION^SYSTEM", PSDL_EXCEPTION'image(EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end NAVIGATION_SYSTEM__DRIVER; 

procedure SENSORS_DRIVER is 

IiV_SENSOR_DATA: SENSOR_RECORD; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if true then 
if true then 
begin 

SENSORS{LV_SENSOR_DATA); 
exception 

when others •■> 

DS_Debug.Undeclared_Exception("SENSORS"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPT10N_ID UNDECLARED_ADA_EXCEPTION; 

end; 

begin 

C3I_SYSTEM_SPEC.DS_SENSOR_DATA.BUFFER.WRITE(LV_SENSOR_DATA) 
exception 


127 




when BUFFER_OVERFLOW -> 

DS_Debug.Buf fer_Overflow 
("SENSOR_DATA", "SENSORS"); 
end; 

if EXCEPT10N_HAS_0CCURRED then 
DS_Debug.Unhandled_Exception 
("SENSORS", PSDL_EXCEPTION' ima.,e (EXCEPTI0N_1D) ) ; 
end if; 
end if; 
end if; 

end SENSORS_DRIVER; 

procedure ADD_COMMS_TRACK_DRIVER is 

LV_FILTERED_COMMS_TRACK: ADD_TRACK_TUPLE; 

LV_TDD_FILTER: SET_TRACK_FILTER; 

LV_OUT_TRACKS: TRACK_TUPLE; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if C3l_SySTEM_SPEC.DS_FILTERED_C0MMS_TRACK.NEW_DATA then 
begin 

C3I_SySTEM_SPEC.DS_FILTERED_COMMS_TBACK.BUFFER.READ 
(LV_FILTERED_COMMS_TRACK) ; 
exception 

when BUFFER_UNDERFLOW -> 

DS_De' ig.Buffer_Underflow 
("FI LTERED_COMMS_TRACK " , "ADD_COMMS_’"RACK ") ; 

end; 

begin 

C3I_SYSTEM_SPEC.DS_TDD_FILTER.BUFFER.READ(LV_TDD_FILTER); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow("TDD_FILTER", "ADD_COMMS_TRACK") 

end; 

if true then 
begin 

ADD_COMMS_TRACK(LV_FILTERED_COMMS_TRACK, LV_TDD_FILTER, 
LV_OUT_TRACKS); 

exception 

when others -> 

DS_Debug.Undeclared_Exception(”ADD_COMMS_TRACK"); 


128 






EXCEPTION_HAS_OCCURRED ;■ true; 

EXCEPTION_ID UNDECIARED_ADA_EXCEPTION; 

end; 

begin 

C3I_SySTEM_SPEC.DS_OUT_TRACKS.BUFFER.WRITE{LV_OUT_TRACKS) 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("OUT_TRACKS", "ADD_COMMS_TRACK'’) ; 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 
("ADD_COMMS_TRACK", PSDL_EXCEPTION'image(EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end ADD_COMMS_TRACK_DRIVER; 

procedure FILTER_COMMS_TRACKS_DRIVER is 
I.V_COMMS_ADD_TRACK: ADD_TRACK_TUPLE; 

LV_TDD_FH.TER: SET_TRACK_FILTER; 

LV_FILTERED_COMMS_TRACK: ADD_TRACK_TUPLE; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if C3l_SYSTEM_SPEC.DS_C0MMS_ADD_TRACK.NEW_DATA then 
begin 

C3I_SYSTEM_SPEC.DS_COMMS_ADD_TRACK.BUFFER.READ 
{LV_COMMS_ADD_TRACK); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
{"COMMS_ADD_TRACK'', "FILTER_COMMS_TRACKS") ; 

end; 

begin 

C3I_SYSTEM_SPEC.DS_TDD_FII,TER.BUFFER.READ(LV_TDD_FILTER); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("TDD_FILTER", ’•FILTER_COMMS_TRACKS") ; 

end; 


129 








if true then 
begin 

FILTER_COMMS_TRACKS (LV_COMMS_AI>D_TRACK, LV_TDD_FILTER, 
LV_FILTERED_COMMS_TRACK); 
exception 

when others -> 

OS_Debug.Undeclared_Exception("FILTER_COMMS_TRACKS"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECLARED_ADA_EXCEPTION; 

end; 

begin 

C3I_SYSTEM_SPEC.DS_FILTERED_COMMS_TRACK.BUFFER.WRITE 
{LV_FILTBRED_COMMS_TRACK); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("FILTERED_COMMS_TRACK", "F1LTER_C0MMS_TRACKS"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

("FILTER__COMMS_TRACKS", PSDL_EXCEPTION'image{EXCEPT10N_ID)); 
end if; 
end if; 
end if; 

end F1LTER_C0MMS_TRACKS_DRIVER; 

procedure EXTRACT_TRACKS_DRIVER is 
LV_COMMS_TEXT_FILE; TEXT_RECORD; 

LV_COMMS_ADD_TRACK; ADD_TRACK_TOPLE; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if true then 
begin 

C3I_SYSTEM_SPEC.DS_COMMS_TEXT_FILE.BUFFER.READ 
(LV_COMMS_TEXT_FILE) ; 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("COMMS_TEXT_FILE", "EXTRACT_TRACKS"); 

end; 


130 








if LV_COMMS_TEXT_FILE.IS_TRACK then 
begin 

EXTRACT_TRACKS(LV_COMMS_TEXT_FILE, LV_COMMS_ADD_TRACK); 
exception 

when others “> 

DS_Debug.Undeclared_Exception("EXTRACT__TRACKS"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDEC1ARED_ADA_EXCEPTI0N; 

end; 

begin 

C31_SYSTEM_SPEC.DS_COMMS_ADD_TRACK.BUFFER.WRITE 
(LV_COMMS_ADD_TRACK); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("COMMS_ADD_TRACK", "EXTRACT_TRACKS"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 
("EXTRACT_TRACKS", PSDL_EXCEPTION'image(EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end EXTRACT_TRACKS_DRIVER; 

procedure DECIDE_FOR_ARCHIVING_DRIVER is 
LV_INPUT_TEXT_RECORD: TEXT_RECORD; 

LV_TDD_ARCHIVE_SETUP: ARCHIVE_SETUP; 

IjV_COMMS_TEXT_F I LE : TEXT_RECORD ; 

LV_COMMS_EMAIL: FILENAME; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if C3l_SySTEM_SPEC.DS_INPUT_TEXT_REC0RD.NEW_DATA then 
begin 

C3I_SYSTEM_SPEC.DS_INPUT_TEXT_RECORD.BUFFER.READ 
(LV_INPUT_TEXT_RECORD); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("INPUT TEXT_RECORD", "DECIDE FOR ARCHIVING"); 


131 



end; 

begin 

C3I_SYSTEM_SPEC.DS_TDD_ARCHIVE_SETUP.BUFFER.READ 
(LV_TDD_ARCHIVE_SETUP); 
exception 

when BUFFER_UNDERFLOW *> 

OS_Debug.Buf£er_Under£low 
("TDD_ARCHIVE_SETUP", -DECIDE_FOR_ARCHIVING"); 

end; 

i£ true then 
begin 

DECIDE_FOR_ARCHIVlNG{Ly_INPUT_TEXT_RECORD, 

LV_TDD_ARCHIVE_SETUP,LV_COMMS_TEXT_FILE, LV_COMMS_EMAIL) 
exception 

when others ■> 

DS_Debug.Undeclared_Exception("DECIDE_FOR_ARCHIVING"); 

EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID :« UNDECLARED_ADA_EXCEPTION; 

end; 

if not LV_COMMS_TEXT_FILE.IS_TRACK 
then 
begin 

C3I_SYSTEM_SPEC.DS_C0MMS_EMA1L.BUFFER.WRITE 
(LV_C0MMS_EMA1I.) ; 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("COMMS_EMAIL", "DECIDE_FOR_ARCHIVING"); 
end; 
end if; 

if LV_COMMS_TEXT_FILE.ARCHIVE 
then 
begin 

C3I_SYSTEM_SPEC.DS_COMMS_TEXT_FILE.BUFFER.WRITE 
(LV_COMMS_TEXT_FILE); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("COMMS_TEXT_FILE", "DECIDE_FOR_ARCHIVING"); 
end; 
end if; 


132 



if EXCEPTION_HAS_OCCURRED then 
DS_Debug. UnhanclIed_Exception 

("DECIDE_FOR_ARCHIVING", PSDL_EXCEPTION'image(EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end DECIDE_FOR_ARCHIVING_DRIVER; 

procedure PARSE_INPUT_FILE_DRIVER is 
LV_INPUT_LINK_MESSAGE: FILENAME; 

LV_INPUT_TEXT_RECORD: TEXT_RECORD; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if C3I_SYSTEM_SPEC.DS_INPUT_LINKJMESSAGE.NEW_DATA then 
begin 

C3I_SYSTEM_SPEC.DS_INPUT_LINK_MESSAGE.BUFFER.READ 
(LV_INPUT_LINK_MESSAGE); 
exception 

when BUFFER_UNDERFLOW -> 

DS_Debug.Buffer_Underflow 
("INPUT_LINK_MESSAGE", "PARSE_INPUT_FILE"); 

end; 

if true then 
begin 

PARSE_INPUT_FILE(LV_INPUT_LINK_MESSAGE, 

LV_INPUT_TEXT_RECORD); 

exception 

when others ■> 

DS_Debug.Undeclared_Exception <"PARSE_INPUT_FILE"); 

EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID :■ UNDECLARED_ADA_EXCEPTION; 

end; 

begin 

C3I_SYSTEM_SPEC.DS_INPUT_TEXT_RECORD.BUFFER.WRITE 
(LV_INPUT_TEXT_RECORD); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("INPUT_TEXT_RECORD", "PARSE_INPUT_FILE"); 
end; 


133 




if EXCBPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 

(■PARSE_INPUT_FIIiE", PSDLJEXCEPTION'image{EXCEPTI0N_1D)); 
end if; 
end if; 
end if; 

end PARSE_INPUT_FILE_DRIVER; 

procedure C0MMS_LINKS_DR1VER is 
I.V_1NPUT_LINKJMESSAGE: FILENAME; 

EXCEPTION_HAS_OCCURRED: boolean false; 

EXCEPTION_ID: PSDL_EXCEPTION; 
begin 

if true then 
if true then 
begin 

COMMS_LINKS(LV_INPUT_L1NK_MESSAGE); 
exception 

when others ■> 

DS_Debug.Undeclared_Exception("COMMS_LINKS"); 
EXCEPTION_HAS_OCCURRED true; 

EXCEPTION_ID UNDECLARED_ADAJEXCEPTION; 

end; 

begin 

C3I_SYSTEM_SPEC.DS_INPUT_LINK_MESSAGE.BUFFER. imiTE 
(LV_INPUT_L1NK_MESSAGE); 
exception 

when BUFFER_OVERFLOW -> 

DS_Debug.Buffer_Overflow 
("INPUT_LINK_MESSAGE", "COMMS_LINKS"); 
end; 

if EXCEPTION_HAS_OCCURRED then 
DS_Debug.Unhandled_Exception 
("COMMS_LINKS", PSDL_EXCEPTION'image(EXCEPTION_ID)); 
end if; 
end if; 
end if; 

end COMMS LINKS DRIVER; 


end TL; 


134 







APPENDK D 


STATIC SCHEDULE 
SSA 

This appendix contains the static schedule package ss.a. The static scheduler us¬ 
es the PSDL description file, psdl.txt, as input, and prepares the static schedule for 
the time critical operators. 

with GL0BAL_DECLARAT10NS; use GLOBAL_DECLARATIONS; 
with DS_DEBUG_PKG; use DS_DEBUG_PKG; 
with TL; use TL; 

with DS_PACKAGE; use DS_PACKAGE; 

with PRIORITY_DEFINITIONS; use PRI0RITY_DEF1NITI0NS; 
with CALENDAR; use CALENDAR; 
with TEXT_IO; use TEXT_IO; 
procedure STATIC_SCHEDULE is 

PREPARE_PERIODIC_REPORT_TIMING_ERROR : exception; 
CONVERT_TO_TEXT_FILE_TIMING_ERROR : exception; 
FORWARD_FOR_TRANSMISSION_TIMING_ERROR : exception; 
MAKE_ROUTING_TIMING_ERROR : exception; 

WEAPONS_SYSTEMS_TIMING_ERROR : exception; 
WEAPONS_INTERFACE_TIMING_ERROR : exception; 
MONITOR_OWNSHIP_POSITION_TIMING_ERROR : exception; 
NAVIGATION_SYSTEM_TIMING_ERROR : exception; 
ADD_SENSOR_TRACK_TIMING_ERROR : exception; 
FILTER_SENSOR_TRACKS_TIMING_ERROR : exception; 
PREPARE_SENSOR_TRACK_TIMING_ERROR : exception; 
ANALYZE_SENSOR_DATA_TIMING_ERROR : exception; 

SENSORS_TlMING_ERROR : exception; 

ADD_COMMS_TRACK_TIMING_ERROR : exception; 
FILTER_COMMS_TRACKS_TIMING_ERROR : exception; 
EXTRACT_TRACKS_TIMING_ERROR : exception; 
DECIDE__FOR_ARCHIVING_TIMING_ERROR : exception; 
PARSE_INPUT_FILE_TIMING_ERROR : exception; 


135 




C0MMS_LINKS_TIM1NG_ERR0R : exception; 
task type SCHEOULE_TYPE is 

pragma priority (STATIC_SCHEDULE_PRIORITY); 
end SCHEDULE_TyPE; 

for SCHEDUIiE_TyPE'ST0RAGE_S1ZE use 200_000; 

SCHEDULE : SCHEDULE_TyPE; 
task body SCHEDULE_TYPE is 

PERIOD : duration duration( 5.OOOOOOOOOOOOOOE-fOl); 
COMMS_LINKS_STOP_TIMEl : duration 

duration( 1.20000000000000E+00); 
PARSE_INPUT_FILE_STOP_TIME2 : duration 

duration( 1.70000000000000E-«-00) ; 
DECIDE_FOR_ARCHIVlNG_STOP_TIME3 : duration 

duration( 2.20000000000000E+00); 
EXTRACT_TRACKS_STOP_TIME4 : duration 

duration( 2.70000000000000E+00); 
FILTER_COMMS_TRACKS_STOP_TIME5 : duration 

duration( 3.20000000000000E+00); 
ADD_COMMS_TRACK_STOP_TIME6 : duration 

duration( 3.70000000000000E+00); 

SENSORS_STOP_TIME7 : duration 

duration ( 4. SOOOOOOOOOOOOOE-fOO); 
ANALY2E_SENSOR_DATA_STOP_TIME8 : duration 

duration( 5.OOOOOOOOOOOOOOE-fOO); 
PREPARE_SENSOR_TRACK_STOP_TIME9 : duration 

duration( 5.SOOOOOOOOOOOOOE-fQO); 
FILTER_SENSOR_TRACKS_STOP_TIME10 : duration 

duration( 6.OOOOOOOOOOOOOOE-t-OO) ; 
ADD_SENSOR_TRACK_STOP_TlMEn : duration 

duration( 6.50000000000000E+00); 
NAVIGATION_SYSTEM_STOP_TIME12 : duration 

duration ( 7.30000000000000E4-00) ; 
MONITOR_OWNSHIP_POSITION_STOP_TIME13 : duration 

duration( 7.80000000000000E400); 
WEAPONS_INTERFACE_STOP_TIME14 : duration 

duration( 8.30000000000000E400); 
WEAPONS_SYSTEMS_STOP_TIME15 : duration ;« 

duration( 8.80000000000000E400); 

MAKE_ROUTING_STOP_TIME16 : duration 

duration( 9.30000000000000E400); 
FORWARD FOR TRANSMISSION STOP TIME17 : duration 


136 




duratlon( 9.80000000000000E+00) 
C0NVERT_T0_TEXT_FILE_ST0P_TIME18 : duration 

duration( 1.06000000000000E+01) 
PREPARE_PERI0DIC_REP0RT_ST0P_TIME19 : duration 

duration( 1.14000000000000E+01) 

SIiACK_TIME : duration; 

START_OF_PERIOD : time clock; 

CURRENT_TIME : duration; 
begin 
loop 
begin 

COMMS_LINKS_DRIVER; 

SIACK_TIME START_OF_PERIOD + COMMS_LINKS_STOP_TIME1 - CLOCK; 
if SLACK_TIME >-0.0 then 
delay (SLACK_T1ME) ; 
else 

raise COMMS_LINKS_TIMING_ERROR; 
end if; 

delay (START_OF_PERIOD + COMMS_LINKS_STOP_TIMEl - CLOCK); 

PARSE_INPUT_FILE_DRIVER; 

SLACK_TIME 

START_OF_PERIOD + PARSE_INPUT_FILE_STOP_TIME2 - CLOCK; 
if SLACK_T1ME >-0.0 then 
delay (SLACK_TIME); 
else 

raise PARSE_INPUT_FILE_TIMlNG_ERROR; 
end if; 

delay (START_OF_PERIOD + PARSE_INPUT_FILE_STOP_TIME2 - CLOCK); 

DECIDE_FOR_ARCHIVING_DRIVER; 

SLACK_TIME :- 

START_OF_PERIOD + DECIDE_FOR_ARCHIVING_STOP_TIME3 - CLOCK; 
if SLACK_TIME >-0.0 then 
delay (SLACK_TIME); 
else 

raise DECIDE_F0R_ARCHIVING_TIM1NG_ERR0R; 
end if; 

delay (START_OF_PERIOD + DECIDE_F0R_ARCHIVING_ST0P_TIME3 - CLOCK) 
EXTRACT_TRACKS_DRIVER; 


137 




SIACK_TZME START_OF_PERIOD + EXTRACT_TRACKS_ST0P_TIME4 - CLOCK; 
if SIACK_T1ME >-0.0 then 
delay (SLACK_TIME); 
else 

raise EXTRACT_TRACKS_TIMING_ERROR; 
end If; 

delay (START_OF_PERIOD + EXTRACT_TRACKS_STOP_TIME4 - CLOCK); 

FILTER_COMMS_TRACKS_DRIVER; 

SLACK_TIME 

START_OF_PERIOD + FILTER_COMMS_TRACKS_STOP_TIME5 - CLOCK; 
if SIACK_TIME >-0.0 then 
delay (SLACK_TZME); 
else 

raise FILTER_COMMS_TRACKS_TIMlNG_ERROR; 
end if; 

delay <START_0F_PER10D + FILTER_COMMS_TRACKS_STOP_TIME5 - CLOCK); 

ADD_C0MMS_TRACK_DR1VER; 

SLACK_TIME ;- 

START_0F_PER10D + ADD_COMMS_TRACK_STOP_TIME6 - CLOCK; 
if SLACK_TIME >-0.0 then 
delay (SLACK_TIME); 
else 

raise ADD_COMMS_TRACK_TIMING_ERROR; 
end if; 

delay (START_OF_PERIOD + ADD_COMMS_TRACK_STOP_TIME6 - CLOCK); 


SENSORS_DRIVER; 

SLACK_TIME :- 

START_OF_PERIOD + SENSORS_STOP_TIME7 - CLOCK; 
if SLACK_TIME >-0.0 then 
delay (SLACK_TIME); 
else 

raise SEMSORS_TIMIKG_ERROR; 
end if; 

delay (START_OF_PERIOD + SENSORS_STOP_TIME7 - CLOCK); 

ANALYZE_SENSOR_DATA_DRIVER; 

SLACK TIME :- 


138 










START_OF_PERIOD + ANALYZE_SENS0R_DATA_ST0P_TIME8 - CLOCK; 
if SLACK_TIME >-0.0 then 
delay (SLACK_TIME); 
else 

raise ANALYZE_SENSOR_DATA_TIMING_ERROR; 
end if; 

delay (START_OF_PERIOD + ANALYZE_SENSOR_DATA_STOP_TIME8 - CLOCK); 

PREPARE_SENSOR_TRACK_DRIVER; 

SLACK_TIME 

START_OF_PERIOD + PREPARE_SENSOR_TRACK_STOP_TIME9 - CLOCK; 
if SLACK_TIME >-0.0 then 
delay (SLACK_TIME); 
else 

raise PREPARE_SENSOR_TRACK_TIMING_ERROR; 
end if; 

delay (START_OF_PERIOD + PREPARE_SENSOR_TRACK_STOP_TIME9 - CLOCK) 

FILTER_SENSOR_TRACKS_DRIVER; 

SLACK_TIME :- 

START_OF_PERIOD + FILTER_SENSOR_TRACKS_STOP_TIME10 - CLOCK; 
if SLACK_TIME >-0.0 then * 

delay (SLACK_TIME); 
else 

raise FILTER_SENSOR_TRACKS_TIMING_ERROR; 
end if; 

delay (START_OF_PERIOD + FILTER_SENSOR_TRACKS_STOP_TIME10 

CLOCK) ; 

ADD_SENSOR_TRACK_DRIVER; 

SLACK_TIME :- 

START_OF_PERIOD + ADD_SENSOR_TRACK_STOP_TIMEll - CLOCK; 
if SLACK_TIME >-0.0 then 
delay {SLACK_TIME); 
else 

raise ADD_SENSOR_TRACK_TIMING_ERROR; 
end if; 

delay (START_OF_PERIOD + ADD_SENSOR_TRACK_STOP_TIMEll - CLOCK); 

NAV1GAT10N_SYSTEM_DRIVER; 

SLACK TIME :- 


139 





START_OF_PERIOD + NAVIGATI0N_SySTEM_ST0P_TlME12 - CLOCK; 
if SLACK_TIME >-0.0 then 
delay (SLACK_TIME); 
else 

raise NAVIGAT10N_SYSTEM_TIMING_ERR0R; 
end if; 

delay (START_OF_PERIOD + NAVIGAT10N_SySTEM_ST0P_TIME12 - CLOCK); 

MONITOR_OWNSHIP_POS1TION_DRIVER; 

SLACK_TIME 

START_OF_PERIOD + MONITOR_OWNSHIP_POSITION_STOP_TIME13 - CLOCK; 
if SLACK_TIME >-0.0 then 
delay (SLACK_T1ME); 
else 

raise MONITOR_OWNSHIP_POSITION_TIMING_ERROR; 
end if; 
delay 

(START_OF_PERIOD + MONrTOR_OWNSHIP_POSITION_STOP_TIME13 - CLOCK); 

WEAPONS_INTERFACE_DRIVER; 

SLACK_TIME :- 

START_OF_PERIOD + WEAPONS_INTERFACE_STOP_TIME14 - CLOCK; 
if SLACK_TIME >-0.0 then 
delay (SLACK_TIME); 
else 

raise WEAPONS_INTERFACE_TIMING_ERROR; 
end if; 

delay {START_OF_PERIOD + WEAPONS_INTERFACE_STOP_TIME14 - CLOCK); 

WEAPONS_SYSTEMS_DRIVER; 

SLACK_TIME :- 

START_OF_PERIOD + WEAPONS_SYSTEMS_STOP_TIME15 - CLOCK; 
if SLACK_TIME >-0.0 then 
delay (SLACK_TIME); 
else 

raise WEAPONS_SYSTEMS_TIMING_ERROR; 
end if; 

delay (START_OF_PERIOD + WEAPONS_SYSTEMS_STOP_TIME15 - CLOCK); 


MAKE ROUTING DRIVER; 


140 









SIiACK_TIME START_OF_PERIOD + MAKE_R0UTING_ST0P_TIME16 - CLOCK 
if SLACK_TIME >-0.0 then 
delay (SLACK_TIME); 
else 

raise MAKE_ROUTING_TIMING_ERROR; 
end if; 

delay (START_0F_PERI0D + MAKE_ROUTING_STOP_TIMEl6 - CLOCK); 

FORWARD_FOR_TRANSMISSION_DRIVER; 

SLACK_TIME 

START_OF_PERIOD + FORWARD_FOR_TRANSMISSION_STOP_TIME17 - CLOCK 
if SLACK_TIME >-0.0 then 
delay (S1ACK_TIME); 
else 

raise FORWARD_FOR_TRANSMISSION_TIMING_ERROR; 
end if; 
delay 

(START_OF_PERIOD + FORWARD_FOR_TRANSMISSION_STOP_TIME17 - CLOCK) 

CONVERT_TO_TEXT_FILE_DRIVER; 

SLACK_TIME :- 

START_OF_PERIOD + CONVERT_TO_TEXT_FlLE_STOP_TI!S18 - CLOCK; 
if SLACK_TIME >-0.0 then 
delay (SLACK_T1ME); 
else 

raise CONVERT_TO_TEXT_FILE_TIMING_ERROR; 
end if; 
delay 

(START_OF_PERIOD + CONVERT_TO_TEXT_FILE_STOP_TIME18 - CLOCK) 

PREPARE_PERIODIC_REPORT_DRIVER; 

SLACK_TIME :- 

START_OF_PERIOD + PREPARE_PERIODIC_REPORT_STOP_TIME19 - CLOCK 
if SLACK_TIME >-0.0 then 
delay (SLACK_TIME) ; 
else 

raise PREPARE_PERIODIC_REPORT_TIMING_ERROR; 
end if; 

START_OF_PERIOD :- START_OF_PERIOD + PERIOD; 
delay (START_OF_PERIOD - cloc)c) ; 


141 





exception 

when PREPARE_PERI0DIC_REP0RT_TIM1NG_ERR0R -> 

PUT_LINE 

("timing error from operator PREPARE_PERIODIC_REPORT"); 
START_OF_PERIOD •- clock; 
when C0NVERT_T0_TEXT_FILE_TIM1NG_ERR0R “> 

PUT_LINE ("timing error from operator CONVERT_TO_TEXT_FILE") 
START_OF_PERIOD clock; 
when FORW/iRD_FOR_TRANSMISSION_TIMING_ERROR -> 

PUT_LINE 

("timing error from operator F0RWARD_70R_TRANSMISSI0N"); 
START_OF_PERIOD clock; 

when MAKE_ROUTING_TIMING_ERROR -> 

PUT_LINE ("timing error from operator MAKE_ROUTING"); 
START_OF_PERIOD clock; 

when WEAPONS_SYSTEMS_TIMING_ERROR -> 

PUT_IiINE ("timing error from operator WEAPONS_SYSTEMS"); 
START_OF_PERIOD clock; 

when WEAPONS_INTERFACE_TIMING_ERROR -> 

PUT__LINE ("timing error from operator WEAP0NS_1NTEPFACE"); 
START_OF_PERIOD clock; 

when MONITOR_OWNSHIP_POSITION_TIMING_ERROR -> 

PUT_LINE 

("timing error from operator M0NIT0R_0WNSHIP_P0S1TI0N"); 
START_OF_PERIOD clock; 

when NAVIGATION_SYSTEM_TIMING_ERROR «> 

PUT_LINE ("timing error from operator NAVIGATION_SYSTEM"); 
START_OF_PERIOD clock; 

when ADD_SENSOR_TRACK_TIMING_ERROR -> 

PUT_LINE ("timing error from operator ADD_SENSOR_TRACK"); 
START_OF_PERIOD clock; 

when FILTER_SENSOR_TRACKS_TIMING_ERROR «> 

PUT_LINE ("timing error from operator FILTER_SENSOR_TRACKS") 
START_OF_PERIOD clock; 

when PREPARE_SENSOR_TRACK_TIMING_ERROR -> 

PUT_LINE ("timing error from operator PREPARE_SENSOR_TRACK") 
START_OF_PERIOD clock; 

when ANALYZE_SENSOR_DATA_TIMING_ERROR -> 

PUT__LINE ("timing error from ojaerator ANALYZE_SENSOR_DATA") ; 
START_OF_PERIOD clock; 

when SENSORS TIMING ERROR -> 


142 





PUT_LINE("timing error from operator SENSORS"); 
START_OF_PERIOD :« clock; 
when ADD COMMS TRACK TIMING ERROR -> 


PUT_LINE("timing error from operator ADD_COMMS_TRACK"); 


START_OF_PERIOD clock; 
when FILTER_COMMS_TRACKS_TIMING_ERROR “> 

PUT_LINE("timing error from operator FILTER_COMMS_TRACKS"); 
START_OF_PERIOD clock; 
when EXTRACT TRACKS TIMING ERROR -> 


PUT_LINE("timing error from operator EXTRACT_TRACKS"); 
START_OF_PERIOD clock; 
when DECIDE_FOR_ARCHIVING_TIMING_ERROR -> 

PUT_LINE("timing error from operator DECIDE_FOR_ARCHIVING"); 


START_OF_PERIOD clock; 

when PARSE_INPUT_FILE_TIMING_ERROR => 

PUT_LINE("timing error from operator PARSE_INPUT_FILE"); 
START_OF_PERIOD clock; 

when COMMS_LINKS_TIMING_ERROR -> 

PUT_LINE("timing error from operator COMMS_LINKS"); 

START OF PERIOD clock; 


end; 


end loop; 

end SCHEDULE TYPE; 


begin 

null; 

end STATIC SCHEDULE; 


143 



APPENDIX E 


DYNAMIC SCHEDULE 
DS.A 


This appendix contains the dynamic schedule package, ds.a. The dynamic schedul¬ 
er generates this code automatically for the non-time critical operators in the proto¬ 
type. 


with TL; use TL; 

with PRIORITY_DEFINITIONS; use PRIORITY_DEFINITIONS; 
package DS__PACKAGE is 

task type DYNAMIC_SCHEDULE_TYPE is 

pragma priority (DYNAMIC_SCHEDULE_PRI0R1TY); 
end DYNAMIC_SCHEDULE_TYPE; 

for DYNAMIC_SCHEDULE_TYPE'ST0RAGE_S1ZE use 100_000; 
DyNAMIC_SCHEDULE : DYNAMIC_SCHEDULE_TYPE; 
end DS_PACKAGE; 

package body OS_PACKAGE is 

task body DYNAMIC_SCHEDULE_TYPE is 
begin 

delay (1.0); 
loop 

MANAGE_USER_INTERFACE_DRIVER; 

DISPLAY_TRACKS_DRIVER; 

GET_USER_INPUTS_DRIVER; 

STATUS_SCREEN_DRIVER; 

EMERGENCY_STATUS_SCREEN_DRIVER; 

MES SAGE_EDITOR_DRIVER ; 

MESSAGE_ARRIVAL_PANEL_DRIVER; 

null; 


145 



end loop; 

end DYHAMIC_SCHEDULE_TYPE 
end DS PACKAGE; 








APPENDIX F 


SOFTHAPE BASE 
SB. A 

This q)pendix includes the set of reusable Ada components for C^I workstation 
prototype. An index is provided at the end of this appendix for quick referencing. 

package SB is 


—************ type declarations *********************************** 

TRACK_CAPACITY ; constant NATURAL 1024; 

OWN_ADDRESS : constant STRING(1..6) "NAME_0"; 

subtype FILENAME is STRING<1..10); 
type SECURITY_CLASS is ( U, C, S, TS ); 
type PRECEDENJE_CLASS is ( R, P, O, Z ); 
type ADDRESS_TYPE; 

type ADDRESS_LINK is access ADDRESS_TYPE; 
type ADDRESS_TYPE is record 
NAME : STRING(1..6)" 

NEXT : ADDRESS_LINK:- null; 
end record; 
type VIA_RECORD; 

type VIA_RECORD_LINK is access VIA_RECORD; 
type VIA_RECORD is record 

RELAY_BY : STRING(1..6) " "; 

RELAY_TO : ADDRESS_LINK null; 

NEXT : VIA_RECORD_LINK null; 

end record; 

type HEADER_FORMAT is record 

CLASSIFICATION : SECURITY_CLASS U; 

PRECEDENCE : PRECEDENCE_CLASS R; 

ORIGIN : STRING(1..6) "NAME 0"; 


147 






ADDRESS 

INFO 

VIA_LINE 

SUBJECT 


: ADDRESS_LINK null; 

: ADDRESS_LINK null; 

: VIA_REC0RD_L1NK null; 
: STRING(1..60) 


end record; 


type LINKS_TYPE is ( JTIDS, LINKll, LINK16, OTCIXS ); 
subtype TEXT_STRING is STRING(1..2400); 
type TEXT_RECORD is record 


NAME 

FILENAME : 

n «• « 

0 

HEADER : 

HEADER_FORMAT; 

LINK_ID : 

LINKS_TYPE 

LINKll; 

RELAYED : 

BOOLEAN 

false; 

ARCHIVE : 

BOOLEAN 

true; 

IS_TRACK: 

BOOLEAN 

false; 

FORMAT 

STRING(1.. 

6) " 

TEXT 

TEXT_STRING; 

end record; 



type ARCHIVE_SETUP is 

record 

ALL_SHIPS 

: BOOLEAN 

true; 

ONNSHIP 

: BOOLEAN 

:«• true; 

JTIDS 

: BOOLEAN 

true; 

LINK16 

: BOOLEAN 

true; 

LINKll 

: BOOLEAN 

true; 

OTCIXS 

: BOOLEAN 

:■ true; 

end record; 




type TIME is record 


HOURS 

: NATURAL 

range 

0. 

.23; 

MINUTES 

: NATURAL 

range 

0. 

.59; 

SECONDS 

: NATURAL 

range 

0. 

.59; 

MILISECONDS 

: NATURAL 

range 

0. 

.99; 


end record; 


type TRACK_CLASS_TYPE is ( AIR, SURFACE, SUBSURFACE ); 

type IFF_CLASS_TYPE is ( FRIENDLY, HOSTILE, NEUTRAL, UNKNOWN ); 

type ARCHIVE_CLASS is ( C, N, A, S ) ; 

OWNSHIP_IFF_CLASS : constant IFF_CLASS_TYPE FRIENDLY; 
OWNSHIP_TRACK_CLASS : constant TRACK_CLASS_TYPE SURFACE; 
type TRACK_RECORD; 

type TRACK_TUPLE is access TRACK_RECORD; 
type TRACK_RECORD is record 

ID : NATURAL range 0,.TRACK_CAPACITY; 


148 













OBSERVER 

OBSERVATION_TIME 

TRACK_CLASS 

1FF_CIASS 

LATITUDE 

LONGITUDE 

ALTITUDE 

COURSE 

VELOCITY 

THE_RANGE 

ARCHIVE_FLAG 

NEXT 


STRING(1..8); 

TIME; 

TBACK_CLASS_TYPE; 

IFF_CLASS_TYPB; 

FLOAT range -90.0..90.0; 

FLOAT range -180.0..180.0; 

FLOAT range -10000.0..99999.9; 

FLOAT range 0.0..360.0; 

FLOAT; —in knots 

FLOAT range 0.0..9999.99; —in miles 
ARCH1VE_CLASS; 

TRACK TUPLE; 


end record; 

type ADD_TRACK_TUPLE is record 
ORIGIN : STRING{1..8); 

TRACK : TRACK TUPLE; 


end record; 


type LOCAL_TRACK_INFO is record 


ORIGIN 

: STRING(1..8); 


ID 

: NATURAL range 0..TRACK_CAPACITY 

THE^TIME 

TIME; 



AZIMUTH 

FLOAT 

range -180.0 

.. 180.0; 

ELEVATION 

FLOAT 

range -90.0 

.. 90.0 0 

THE_RANGE 

FLOAT 

:■> 0.0; —in 

miles 

VELOCITY 

FLOAT 

;■ 0.0; —in 

knots 

COURSE 

FLOAT 

range 0.0..360.0; 

IFF_CLASS 

: IFF_CLASS_TYPE; 


TRACK_CLASS 

TRACK_ 

_CLASS_TYPE; 


ARCHrVE_FLAG 

ARCHIVE_CLASS; 



end record; 


type SENSOR_RECORD is record 
INTELLIGENCE : STRING(1..80) ; 
CONTACT : LOCAL_TRACK_INFO; 

end record; 


type OWNSHIP NAVIGATION INFO is record 


COURSE : 
VELOCITY : 
LATITUDE 
LONGITUDE : 
THE_TIME 
end record; 


FLOAT range 
FLOAT; —in 
FLOAT range 
FLOAT range 
TIME; 


0.0..360.0; 
knots; 

-90.0..90.0 
-180.0..180.0 


35.0; 

- 125.0; 


149 








type DESIRED_CLASS_ARRAY is array ( TRACK_CIASS_TyPE ) of BOOLEAN; 
type DESIRED_RANGE_ARRAY is array ( TRACK_CLASS_TyPE ) of FLOAT; 
type SET_TRACK_FILTER is record 

MAX_NUMBER : NATURAL range 0..TRACK_CAPACITY TRACK_CAPACITy; 
DES1RED_CLASS : DESIRED_CLASS_ARRAy ( true, true, true ); 

DESIREO_RANGE : DESIREO_RANGE_ARRAy ( 10000.0,10000.0,10000.0 ); 

end record; 

type UPDATE_TRACK_TUPLE is record 
ORIGIN : STRING(1..8); 

TRACK : TRACK_TUPLE; 
end record; 

type REQUEST_TyPE is ( ADD, DELETE, UPDATE ); 
type CHANGE_DATABASE_R£QUEST is record 
ORIGIN : STRING(1..8); 

REQUEST : REQUEST_TyPE; 

TRACK : TRACK_TUPLE; 
end record; 

type TRACK_CLASS_ARRAy is array(TRACK_CLASS_TyPE) of BOOLEAN; 
type IFF_CLASS_ARRAy is array(IFF_CLASS_TyPE) of BOOLEAN; 
type DATABASE_REQUEST is record 
THE_RANGE : FLOAT 10000.0; 

TRACK_CLASS : TRACK_CLASS_ARRAy ( true, true, true ); 

1FFJ:lASS ; IFF_CLASS_ARRAy < true, true, true, true ); 

end record; 

type INITIATE_TRANSMISSION_SEQUENCE is record 
LINK_ID : LINKS_TyPE JTIDS; 

HEADER : HEADER_FORMAT; 

DESIRED_FORMAT : STRING(1..6) " 

DBASE_REQUEST : DATABASE_REQUEST; 
end record; 

type WEAPONS_TyPE is ( CIWS, GUN, TWS, MK48 ); 
type WEAPON_STATUS_TyPE is{ 

DAMAGED, RELOADING, LAUNCHING, READY, SERVICE_REQUIRED, 

SLEWING, SECURED, MAINTANENCE, ENGAGING, OUT_OF_AMMUNIT10N ); 

type WEAPON_STATUS is record 
SYS_TyPE : WEAPONS_TYPE; 

STATUS : WEAPON_STATUS_TYPE; 
end record; 

type WEAPON_STATUS_REPORT is array ( WEAPONS_TyPE ) of 

WEAPON_STATUS_TYPE; 

type TRANSMIT_RECORD is record 


150 







ROUTE_ADDR : ADDRESS_LINK; 

ROUTED : BOOLEAN false; 

FULL : BOOLEAN false; 

TEXT : TEXT_RECORD; 

end record; 

type TRANSMIT_COMMAND is array < LINKS_TYPE ) of TRANSMIT_RECORD; 
type NETWORK_SETUP is array ( LINKS_TyPE ) of ADDRESS_LINK; 
type TRANSMISSION_RECORD is record 
ROUTE_ADDR : ADDRESS_LINK; 

FULL : BOOLEAN false; 

TEXT : TEXT_RECORD; 

end record; 

type TRANSMISSION_COMMAND is array ( LINKS_TYPE ) of 

TRANSMISSION_RECORD; 

type EMISSIONS_CONTROL_COMMAND is ( EMCON, UNRESTRICTED ); 
type MESSAGE_RECORD; 

type MESSAGE_LIST is access MESSAGE^RECORD; 
type MESSAGE_RECORD is record 
LINK_ID : LINKS_TYPE; 

MAIN : TRANSMISSION_RECORD; 

NEXT : MESSAGE_LIST; 

end record; 


— ******************** procedure declarations 




procedure C0MMS_LINKS( 


INPUT_LINK_MESSAGE 

: out 

FILENAME ); 

procedure PARSE_INPUT_FILE( 




INPUT_LINK_MESSAGE 

: 

in FILENAME 

INPUT_TEXT_RECORD 

: in 

out 

TEXT_RECORD ) 

procedure DECIDE_FOR_ARCHIVING( 



INPUT_TEXT_RECORD : 

in 

out 

TEXT_RECORD; 

TDD_ARCHIVE_SETUP : 

in 


ARCHIVE_SETUP; 

COMMS_TEXT_FILE : 

out 


TEXT_RECORD; 

COMMS EMAIL : 

out 


FILENAME 


procedure EXTRACT_TRACKS( 


151 



COMMS_TEXT_FILE : in TEXT_RECORD; 

C0MM5 ADD TRACK : out ADD TRACK TUPLE ); 


procedure FILTER_COMMS_TRACKS( 


COMMS_ADD_TRACK 

TDD_FILTER 

FILTERED COMMS TRACK 


in out ADD_TRACK_TUPLE; 
in SET_TRACK_FILTER; 

out ADD TRACK TUPLE ); 


procedure ADD_COMMS_TRACK( 

FILTERED_COMMS_TRACK 

TDD_FILTER 

OUT TRACKS 


in ADD_TRACK_TUPLE; 

in SET_TRACK_FILTER; 

in out TRACK TUPLE ); 


procedure SENSORS( 

SENSOR_DATA : out SENSOR_RECORD ); 

procedure ANALYZE_SENSOR_OATA( 

SENSOR_DATA ; in SENSOR_RECORD; 

SENSOR_CONTACT_DATA : out LOCAL_TRACK_INFO ); 

procedure PREPARE_SENSOR_TRACK( 

SENSOR_CONTACT_DATA : in LOCAL__TRACK_INFO; 
POSITION_DATA : in OWNSHIP_NAVIGATION_INFO 

SENSOR ADD TRACK : out ADD TRACK TUPLE ); 


procedure FILTER_SENSOR_TRACKS( 


SENSOR_ADD_TRACK 

: in 

out 

ADD_TRACK_TUP LE; 

TDD_FILTER 

: in 


SET_TRACK_FILTER ; 

FILTERED_SENSOR_TRACK 

: out 


ADD_TRACK_TUPLE ) 

procedure ADD_SENSOR_TRACK( 

FILTERED_SENSOR_TRACK 

: in 


ADD_TRACK_TUP LE; 

TDD_FILTER 

: in 


SET_TRACK_FILTER; 

OUT_TRACKS 

: in 

out 

TRACK_TUPLE ); 


procedure NAVIGATION_SYSTEM( 

POSITION_DATA ; out OWNSHIP_NAVIGATION_INFO ); 

procedure MONITOR_OWNSHIP_POSITION( 

POSITION DATA : in OWNSHIP NAVIGATION INFO; 


152 






OUT__TRACKS : in out TRACK_TUPLE ); 

procedure D1SPLAY_TRACKS{ 

OUT_TRACKS : in TRACKJTUPLE; 

TD_TRACK_REQUEST : in DATABASE_REQUEST ); 

procedure GET_USER_INPUTS( 

TDD_ARCHIVE_SETUP : out ARCHIVE_SETUP; 

TDD__FILTER : out SET_TRACK_FILTER; 

TD_TRACK_REQUEST : out DATABASE_REQUEST; 

TCD_STATUS_QUERY : out BOOLEAN; 

TCD_NETWORK_SETUP : out NETWORK_SETUP; 

TCD__EMISSION_CONTROL : out EMISSIONS_CONTROL_COMMAND; 

EDITOR_SELECTED : out BOOLEAN; 

INITIATE_TRANS : out INITIATE_TRANSMISSION_SEQUENCE 

TERMINATE_TRANS : out BOOLEAN ); 

procedure MANAGE_USBR_INTERFACE; 

procedure WEAPONS_SYSTEMS( 

WEAPON_STATOS_DATA : out WEAPON_STATUS ); 

procedure WEAP0NS_1NTERFACE( 

WEAPON_STATUS_DATA : in WEAPON_STATUS; 

WEAPONS_EMREP ; out WEAPON_STATUS_REPORT; 

WEAPONS_STATREP : Out WEAPON_STATUS_REPORT ); 

procedure STATUS_SCREEN( 

WEAPONS_STATREP : in out WEAPON_STATUS_REPORT; 
TCD_STATUS_QUERY : in BOOLEAN ); 

procedure EMERGENCY_STATUS_SCREEN( 

WEAPONS_EMREP : in out WEAPON_STATUS_REPORT ) ; 

procedure MAKE_ROUTING( 

TCD_TRANSMIT_COMMAND : in TRANSMIT_COMMAND; 

TCD_NETWORK_SETUP : in NETWORK_SETUP; 

TRANSMISSION_MESSAGE : in out TRANSMISSION_COMMAND ); 

procedure MESSAGE_EDITOR( 

EDITOR SELECTED 


: in BOOLEAN, 




TCD_TRANSMIT_COMMAND : out TRANSMIT_COMMAND ); 

procedure F0RWARD_F0R_TRANSMISS10N{ 

TRANSMISSZON_MESSAGE ; in 

TCD_EM1SSI0N_C0NTR0L : in 

OUTPUT_MESSAGES : in out 

procedure CONVERT_TO_TEXT_FILE( 

OUTPUT_MESSAGES : in MESSAGE_LIST); 

procedure MESSAGE_ARRIVAL_PANEL( 

COMMS_EMAZL : in FILENAME ); 

procedure PREPARE_PERIODIC_REPORT( 

1NIT1ATE_TRANS : in 

INITIATE_TRANSMISSION_SEQUENCE; 
TERM1NATE_TRANS : in BOOLEAN; 

TCD_TRANSMIT_COMMAND : in out TRANSMIT_COMMAND ); 

end SB; 

with TEXT_IO; use TEXT_IO; 
with MATH; U3e MATH; 
with TAE; use TAE; 
with CALENDAR, RANDOM, X WINDOWS; 


TRANSMISSION_COMMAND; 

EMISSIONS_CONTROL_COMMAND; 
MESSAGE LIST ); 


package body SB is 

USE TAE.TAE_MISC; 

USE TAE.TAE_WPT; 

USE TAE.TAE_VM; 

USE TAE.TAE_CO; 

package enuin_io is new enumeration_io( boolean ); use enum_io; 


••»***«***♦****«***«****««**#**********♦**********♦***********«**«**** 

—***coinmon global variable&type declarations *** 

— * ****************************************************************** 

—number of characters in text body of separate records 
TEXT LENGTH : constant NATURAL 2400; 


154 













.»******************************************************************* 

procedure COMMS_LINKS global variable£type declarations 

«•••* *****A*************************ik*ir**********1k********************* 

COMMS_TRACK_CAPACITY : constant NATURAL 10; 
type COMMS_TRACK_RECORD; 

type C0MMS_TRACK_L1ST is access COMMS_TRACK_RECORD; 
type COMMS_TRACK_RECORD is record 


ID 

: NATURAL range 1 .. COMMS_TRACK_CAPACITY; 

ORIGIN 

: STRING(1..8); 


THE_TIME 

: TIME; 


AZIMUTH 

: FLOAT range -180.0 .. 

180.0; 

ELEVATION 

: FLOAT range -90.0 .. 

90.0; 

THE_RANGE 

: FLOAT; 


VELOCITY 

: FLOAT; 


COURSE 

: FLOAT range 0.0 .. 360.0; 

IFF_CLASS 

: IFF_CLASS_TYPE; 


TRACK_CLASS 

: TRACK_CLASS_TYPE; 


ARCHIVE_FLAG 

: ARCHIVE_CLASS; 


LATITUDE 

: FLOAT range -90.0 .. 

O 

O 

LONGITUDE 

; FLOAT range -180.0 .. 

180.0; 

ALTITUDE 

: FLOAT range -10000.0 

.. 99999.99; 

REPORTED 

: BOOLEAN false; 


NEXT 

: COMMS_TRACK_LIST; 


end record; 



COMMS_TRACKS 

: COMMS_TRACK_LIST; 



COMMS_TRACKS_ARE_CREATED : BOOLEAN false; 

—******************************************************************* 
—*** procedure SENSORS *** 

—*** variableStype declarations *** 

— ******************************************************************* 

type SENSOR_TRACK_RECORD; 

type SENSOR_TRACK_LIST is access SENSOR_TRACK_RECORD; 
type SENSOR_TRACK_RECOBD is record 

INTELLIGENCE : STRING(1..80); —contains intelligence report 
CONTACT : LOCAL_TRACK_INFO; 

LATITUDE : FLOAT range -90.0 .. 90.0; 

LONGITUDE ; FLOAT range -180.0 .. 180.0; 

NEXT : SENSOR_TRACK_LIST; 

end record; 

SENSOR TRACKS : SENSOR TRACK LIST; 


155 









false 


SENSOR TRACKS ARE CREATED : BOOLEAN :• 




-**★ procedure NAV1GAT10N_SYSTEM 
.*** global variablettype declarations 


START TIME : NATURAL 0; 




__•***********•***********«************«***»************************* 
—*** procedure FILTER_TRACKS *** 

—*** global varlable£type declarations *** 

——**************************************«**************************** 

APPROVED : BOOLEAN true; 


——*****' 


************************************ 


—*** procedure PREPARE_PERIODIC_REPORT *** 

—*** global variable£type declarations *** 

_••**** Ik ** A * A Ik *** A *** *** Ik ******************************************* * 

TRACK FILE NAME : constant FILENAME "TRACK FILE"; 


—.***«********************************************************** 
—*** procedure MODIFy_TRACKS *** 

—*** global variable&type declarations . *** 

__******************************************************************* 

NUMBER OF TRACKS : NATURAL 0; 


TRACKS 


: TRACK TUPLE null; 


.*** procedure WEAPONS_INTERFACE 
-*** global variablettype declarations 




CIWS_STATUS ; WEAPON_STATUS_TyPE READY; 
GUN_STATUS : WEAPON_STATUS_TYPE READY; 
TWS_STATUS : WEAPON_STATUS_TYPE READY; 
MK48 STATUS : WEAPON STATUS TYPE READY; 



156 


















■*** procedures DISPLAy_TRACKS £ GET_USER_INPUTS £ 

-*** MANAGE_USER_1NTERFACE 

-*** global variable£type declarations 


*** 

*** 




TAE_SOURCE_FIIiE : constant STRING(1..8) 
—tae panel pointers 


•user.res"; 


inain_info 

filter_info 

archive_info 

contrnts_info 

display_info 

weapon_info 

einerg_info 

network_in£o 

emcon_info 

editor_info 

inesscaine_in£o 

inessdisp_in£o 

infissret_in£o 

trac)crep_in£o 

tertrrep_in£o 


event_context_ptr; 
event_context_pt r; 
event_context_ptr; 
event_context_ptr; 
event_context_ptr; 
event_context_pt r; 
event_context_ptr; 
event_context_ptr; 
event_c ont ext_pt r; 
event_context_ptr; 
event_context_pt r; 
event_context_ptr; 
event_context_ptr; 
event_context_ptr; 
event_context_pt r; 


—values o£ these variables are changed globaly by dif£erent 
—procedures, and these variables are used by 
—procedure GET_USER_INPUTS when it is triggered. 


new_archive_setup 
new_t ra c k_£i11e r 
new_track_request 
new_status_query 
new_emi ssion_control 
new_network_setup 
new_transmit_command 
new_editor_selected 
new_initiate_trans 
new terminate trans 


archive_setup; 

set_track_£ilter; 

database_request; 

boolean; 

emi3sions_control_coinmand EMCON; 
network_setup; 
t ransmi t_conimand; 
boolean £alse; 
initiate_tran3mi3sion_sequence; 
boolean :■ true; 


—old valuea £or uaer inputa. these variables are used to restore 
—the old values o£ each variable in case that some components o£ 
—the variable are begun to be changed, but user has changed 


157 






—his/her mind then. For Example, user opened the panel and changed 

—some conponents of a record variable, but then requested 

—CANCEL in the panel. 

old_archive_setup : archive_aetup; 

old_trac)c_filter : aet_track_filter; 

old_tracJc_request : database_request; 

old_emission_control : emissions_control_command :■ EMCON; 

old_network_setup : network_setup; 

old_transmit_command : transmit_command; 

old_initiate_trans : initiate_transmission_sequence; 

—shows if initial configuration is already set 
panels_are_initialized : boolean false; 

—shows if related panel is already displayed 
track_display__panel_is_displayed : boolean :« false; 

weapon_3tatus_panel_is_displayed : boolean false; 

emergency_weapon_status_panel_is_displayed : boolean false; 

—X Window display pointer 
theDisplay : X_Windows.Display; 

—main program pointer 
user_ptr : event_context_ptr; 

—event data types & pointers 
etype : wpt_eventtype; 
wptEvent : wpt_eventptr; 

—used by the manage_user_interface 

value : array (1..1) of string (1..tae_taeconf.STRINGSIZE); 


__******************************************************************* 
—*** Procedure COMMS_LINKS *** 

procedure COMMS_LINKS( INPUT_LINK_MESSAGE : out FILENAME ) is 

package F_CLASS_IO is new ENUMERATION_IO( PRECEDENCE_CLASS ); 
use P_CLASS_IO; 

package S_CLASS_10 is new ENUMERATION_IO( SECURITy_CLASS ); 
use S_CLASS_IO; 

package LINKS_IO is new ENUMERATION_IO( LINKS_TYPE ); 
use LINKS_IO; 

package INT_IO is new INTEGER_IO( INTEGER ); 
use INT 10; 


158 










package FLT_10 ia new FLOAT_IO( FLOAT ); 
use FLT_IO; 

PI : constant FLOAT :« 3.1415926536; 

RADIANS_PER_DEGREE : constant FLOAT PI / 180.0; 

DEGREES_PER_RADIAN : constant FLOAT 1.0 / RADIANS_PER_DEGREE; 

SECONDS_SINCE_MIDNIGHT : NATURAL; 

—name of the origin of the simulated message 
FROM_NAME : STRING(1..6); 

—physical file for the file which to be created and filled 
—with message 
FILE_NAME : FILENAME; 

—logical file variable for the file which to be created and 

—filled with message 

FILE : TEXT_IO.FILE_TYPE; 

—declare types and variables about name of the current stations 
—in the environment 

NUMBER_OF_ADDRESSES : constant NATURAL 10; 
type NAME_ARRAY_RECORD is record 
NAME : STRING(1..6); 

USED : BOOLEAN false; 

REUSED : BOOLEAN false; 

end record; 

type NAME_ARRAY is ARRAY(0..NUMBER_OF_ADDRESSES-l) Of 

NAME_ARRAY_RECORD; 

NAMES : NAME_ARRAY; 

—link id of the message 
LINK_ID : LINKS_TYPE; 

—float numbers which are used to store the last RANDOM.NUMBER 
—for the case same random value is needed more than once 
TO_NtJMBER : FLOAT; 

INFO_NUMBER : FLOAT; 

RANDOM NUMBER : FLOAT; 


_ ***************************************************************** 

—*** Function CHABACTER_OF *** 

Itititltlrlfkit'kltitltitHiiicitltifitliltiHrlrliititltlftltltitlticitifirititiiitltitlritiiitltltltltiiitii'kigicItit'klilt 

function CHARACTER_OF{ N : in NATURAL ) return CHARACTER is 
begin 

return( CHARACTER'VAL( N + 48 ) ); 


159 













end CHARACTER OF; 


It********** ***11*** ****** ******* **** ********* *it* ********* *****1i-k* 


—*** FUNCTION GET_FILE_NAME *** 
—*** Algorithm : creates a file name by using current time *** 
—*** and returns it *** 

••»************ 4r *********************** ********************** Ik **** * 


function GET FILE NAME return FILENAME is 


YEAR 

MONTH 

DAY 

HOURS 

MINUTES 

SECONDS 

FILE NAME 


CALENDAR.YEAR_NUMBER; 
CALENDAR.MONTH_NUMBER; 
CALENDAR.DAY_NUMBER; 
NATURAL; 

NATURAL; 

CALENDAR.DAY_DURATION; 
FILENAME; 


„**********************************************»********•********* 
—*** Function NATURAL_TO_STRING_2 *** 

—*** Algorithm : converts 2-digit natural number to *** 

—*** 2-character string *** 

—^**************** ************************************************* 

function NATURAL__TO_STRING_2( NUMBER : in NATURAL ) 

return STRING is 

N : NATURAL NUMBER; 

S : STRTNG(1,.2) "00"; 

begin 

if N > 9 then 

S{1) :- CHARACTER_OF( N/10 ) ; 

N N - ( (N/10) * 10 ); 

end if; 

S(2) CHARACTER_OF( N ); 

return{ S ); 

end NATURAL TO STRING 2; 


begin —GET_FILE_NAME; 

CALENDAR.SPLIT( CALENDAR.CLOCK, YEAR, MONTH, DAY, SECONDS ); 
HOURS INTEGER(SECONDS) / 3600; 

MINUTES (INTEGER(SECONDS) mod 3600) / 60; 


160 








FILE_NAME(1.,2) 

FILE_HAME(3..4) :- NATURAL_T0_STRING_2(NATURAL(DAY ) ) 

FILE_NAME(5..6) NATURAL_T0_STRING_2(NATURAL(HOURS ) ) 

FILE_NAME(7..8) NATURAL_T0_STR1NG_2(NATURAL(MINUTES ) ) 

FILE_NAME(9..10) NATURAL_TO_STRING_2(NATURAL(SECONDS) mod 60 ) 

return( FILS_NAME ); 
end GET FILE NAME; 


—A**************************************************************** 

—*** Procedure CREATE_COMMS_TRACKS *** 

—*** Algorithm : creates and Initializes all of the *** 

—*** comms trac)cs *** 

_ ***************************************************************** 

procedure CREATE_COMMS_TRACKS( 

COMMS_TRACKS : in out COMMS_TRACK_LIST; 

SECONDS_SINCE_MIDNIGHT : in NATURAL ) is 

NEW_TRACK : COMMS_TRACK_LIST; 

RANDOM_NUMBER : FLOAT; 

—trade information are reported by using 10 tracks 
COMMS_TRACK_Cyi>PACITY : constant NATURAL 10; 

—constant attributes for the tracks 


MIN_AIR_HEIGHT 

: constant 

FLOAT 

1 ** 

3000.0; 

MIN_AIR_VELOCITY 

: constant 

FLOAT 


300.0; 

MAX_AIR_VELOCITY 

: constant 

FLOAT 


800.0; 

AIR_VELOCITY_DIFF 

: constant 

FLOAT 



MAX_AIR_VELOCITY - MIN_ 

_AIR_VELOCITY 

MIN_SURFACE_VE LOCITY 

: constant 

FLOAT 

• m 

o 

o 

MAX_SURFACE_VELOCITY 

: constant 

FLOAT 


o 

o 

MAX_HEADING_ANGLE 

: constant 

FLOAT 


360.0; 

MAX_COMMS_RANGE 

; constant 

FLOAT 


500.0; 

MIN_SUBSURFACE_DEPTH 

: constant 

FLOAT 


o 

o 

MIN_SUBSURFACE_VELOCITY 

: constant 

FLOAT 


o 

o 

MAX_SUBSURFACE_VELOCITY 

: constant 

FLOAT 


30.0; 

MIN_ELEVATION 

: constant 

FLOAT 

• m 

o 

o 

a\ 

1 

MAX_ELEVATION 

: constant 

FLOAT 


90.0; 

MIN_AZIMUTH 

; constant 

FLOAT 


-180.0; 

MAX_AZIMUTH 

: constant 

FLOAT 


180.0; 

MAX BEARING ANGLE 

: constant 

FLOAT 




MAX AZIMUTH - MIN AZIMUTH; 


161 













MIN_ALTITUDE : constant FLOAT 

MAX_ALTITUDE : constant FLOAT 

AIR_TRACK_REBIRTH_RATIO : constant FLOAT 

SURFACE_TRACK_REBIRTH_RATIO : constant FLOAT 

MILES_PER_DEGREE : constant FLOAT 

begin —CREATE_COMMS_TRACKS 

for I in 1.,COMMS_TRACK_CAPACITy loop 

NEW_TRACK new COMMS_TRACK_RECORD; 

NEW_TRACK.ID I; 

RANDOM_NUMBER RANDOM.NUMBER; 

if RANDOM_NUMBER < AIR_TRACK_REBIRTH_RATIO then 
—create air track 
NEW_TRACK.TRACK_CIASS AIR; 

NEW_TRACK.ELEVATION MAX_ELEVATION * RANDOM.NUMBER 

NEW_TRACK.VELOCITY MIN_AIR_VELOCITY + 

{ RANDOM.NUMBER*AIR_VELOCITY_DIFF ); 

NEW_TRACK.ALTITUDE MAX_ALTITUDE * RANDOM.NUMBER; 

elsif RANDOM_NUMBER < SURFACE_TRACK_REBIRTH_RATIO then 
—create surface track 
NEW_TRACK.TRACK_CLASS SURFACE; 

NEW_TRACK.ELEVATION :- 0.0; 

NEW_TRACK.VELOCITY MIN_SURFACE_VELOCITY + 

( RANDOM.NUMBER * MAX_SURFACE_VELOCITY ); 

NEW_TRACK.ALTITUDE 0.0; 

else 

—create subsurface track 
NEW_TRACK.TRACK_CLASS SUBSURFACE; 

NEW_TRACK.ELEVATION MIN_ELEVATION * RANDOM.NUMBER 

NEW_TRACK.VELOCITY MIN_SUBSURFACE_VELOCITY + 

( RANDOM.NUMBER * MAX_SUBSURFACE_VELOCITY ); 

NEW_TRACK,ALTITUDE MIN_ALTITUDE * RANDOM.NUMBER; 

end if; 

NEW_TRACK.COURSE RANDOM.NUMBER * MAX_HEADING_ANGLE 

NEW_TRACK.THE_RANGE RANDOM.NUMBER * MAX_COMMS_RANGE; 

NEW_TRACK.AZIMUTH MIN_AZIMUTH + 

( RANDOM.NUMBER * MAX BEARING ANGLE ); 


- 10000 . 0 ; 

99999.99; 

0 . 2 ; 

0 . 8 ; 

60.0; 


162 










NEWJTRACK.ORIGIN "COMMS 

NEW_TRACK.THE_TIME.HOURS SECONDS_SINCE_MIDNIGHT / 3600; 

NEW_TRACK.THE_TIME.MINUTES 

(SECONDS_SINCE_MIDNIGHT mod 3600) / 60; 

NEW_TRACK.THE_TIME.SECONDS SECONDS_SINCE_MIDNIGHT mod 60; 

RANDOM_NUMBER RANDOM.NUMBER; 

if RANDOM_NUMBER <0.25 then NEW_TRACK.IFFjCLASS FRIENDLY; 
elsif RANDOM_NUMBER <0.50 then NEW_TRACK.IFF_CLASS HOSTILE; 

elsif RANDOM_NUMBER <0.75 then NEW_TRACK.IFF_CLASS NEUTRAL; 

else NEW_TRACK.IFF_CLASS UNKNOWN; 

end if; 

NEW_TRACK.LATITUDE 35.0 + (NEW_TRACK.THE_RANGE * 

COS(NEW_TRACK.AZIMUTH*RADIANS_PER_DEGREE))/ 

MILES_PER_DEGREE; 
if NEW_TRACK.AZIMUTH > 0.0 then 

NEW_TRACK.LONGITUDE 125.0 + (NEW_TRACK.THE_RANGE * 
SIN(NEW_TRACK.AZIMUTH*RADIANS_PER_DEGREE))/ 

MILES_PER_DEGREE; 
else 

NEW_TRACK.LONGITUDE 125.0 ~ (NEW_TRACK.THE_RANGE * 
SIN(NEW_TRACK.AZIMUTH*RADIANS_PER_DEGREE))/ 

MILES_PER_DEGREE; 
end if; 

NEW_TRACK,NEXT COMMS_TRACKS; 

COMMS TRACKS NEW TRACK; 


end loop; 

end CREATE COMMS TRACKS; 







Procedure 

UPDATE_COMMS_TRACK 

*** 


Algorithm 

: Updates the position of the trac)c 




according to its previous position, course 

*** 

_*** 


& velocity 



procedure UPDATE_COMMS_TRACK( 

SELECTED_T®ACK : in out COMMS_TRACK_LIST; 

SECONDS SINCE MIDNIGHT : in NATURAL ) is 


PREVIOUS_SECONDS_SINCE_MIDNIGHT : NATURAL; 
SECONDS PASSED : NATURAL; 


163 











MILES_PER_DEGREE : constant FLOAT 60.0; 

—o%m3hip information variables 

OWN_LAT : FLOAT range -90.0 .. 90.0 35.0; 

ONN_LONG : constant FLOAT 125.0; 

OWN_COURSE : FLOAT 0.0; 

OWN_VELOCITy : FLOAT 25.0; 

—distance between current £ previous position of the track 
DISTANCE : FLOAT; 


"latitude £ longitude distances between current £ previous 
—position of the track 
LAT_DIST : FLOAT; 

LONG_DIST : FLOAT; 

begin —UPDATE_COMMS_TRACK 

—get the the time difference between consecutive echos 
—of the track in seconds 
PREV10US_SEC0NDS_S1NCE_MIDNIGHT 3600 * 
SELECTED_TRACK.THE_T1ME.HOURS + 60 * 
SELECTED_TRACK.THE_T1ME.MINUTES + 

SELECTED_TRACK.THE_TIME.SECONDS; 

SECONDS_PASSED SECONDS_SINCEJ4IDNIGHT - 
PREVIOUS SECONDS SINCE MIDNIGHT; 


—write the new observation time of the track to the 

—track's record 

SELECTED_TRACK.THE_TIME.HOURS SECONDS_SINCE_MIDNIGHT/3600; 

SELECTED_TRACK.THE__TIME.MINUTES (SECONDS_SINCE_MIDNIGHT 

mod 3600) / 60; 

SELECTED_TRACK.THE_TIME.SECONDS <SECONDS_SINCE_MIDNIGHT 

mod 3600) mod 60; 

—change the position values of the track £ write to the 

—track's record 

OWN_LAT 35.0 + ((FLOAT(SECONDS_PASSED)*OWN_VELOCITy) / 

3600.0)/MILES_PER_DEGREE; 

DISTANCE (FLOAT(SECONDS_PASSED)*SELECTED_TRACK.VELOCITY)/ 

3600.0; 

SELECTED_TRACK.LATITiroE SELECTED_TRACK.LATITUDE + 

(DISTANCE * COS(SELECTED_TRACK.COURSE*RADIANS PER DEGREE))/ 


164 




MILES_PER_DEGREE; 

SELECTED_TRACK.LONGITUDE SELECTED_TRACK.LONGITUDE + 

(DISTANCE * SIN(SELECTEDjrRACK.COURSE*RADIANS_PER_DEGREE))/ 
MILES_PER_DEGREE; 

—change the range of the track & write to the track's record 
LAT_DIST (SELECTED_TRACK.LATITUDE - OWN_LAT) * 
MILES_PER_DEGREE; 

LONG_DIST (SBLECTED_TRACK.LONGITUDE - OWN_LONG) * 

MILE3_PER_DEGREE; 

SELECTED_TRACK.THE_RANGB SQRKLAT DIST**2 + LONG_DIST**2); 


—change the azimuth of the track & write to the track's record 
SELECTED_TRACK.AZIMUTH 

DEGREES_PER_RADIAN * 

ARCCOS(LAT_DIST/SELECTED_TRACK.THE_RANGE); 
end UPDATE COMMS TRACK; 


_.****«************************************************************ 
—*** procedure PRINT_0NE_TRACK *** 

—•** Algorithm : Prints out components of one track to *** 

--*** the file *** 

..*************«************************************«***«********** 

procedure PRINT_ONE_TFACK( TRACK : in out COMMS_TRACK_LIST ) is 


—«** procedure PUT_LEADING_ZEROS *** 

—*** Algorithm : Puts leading ZEROS in front of the value *** 
—**• into text *** 

—_*************************************************************** 

procedure PUT_LEADING_ZEROS( 

FILE : in FILE_TyPE; 

OUT_NUMBER : in FLOAT; 

BEFORE : in NATURAL ) is 


—BEFORE is number of original digits to be filled by both 
—LEADING ZEROS and the number itself 


NUMBER : FLOAT FLOAT( 10** ( BEFORE-1 )); 


165 











b«gin —PUT_LEAD1NG_ZER0S 
while NUMBER /- 1.0 loop 

if OUT_NUMBER < NUMBER then 
PUT( FILE, '0' ); 
end if; 

NUMBER NUMBER / 10.0; 
end loop; 

end PUT_LEADING_2EROS; 
begin —PRINT_ONE_TRACK 

—put "beginning of track information" indicator 
PUT( FILE, "PCS/" ); 

—put TRACK.ID 

PUT_LEADING_ZEROS( FILE, FLOAT(TRACK.ID), 4 ); 

PUT( FILE, TRACK.ID, 1 ); PUT{ FILE, '/' ); 

—^put TRACK,ORIGIN 

PUT{ FILE, TRACK.ORIGIN ); PUT( FILE, '/' ); 

—put TRACK.THE_TIME 

PUT_LEADING_ZEROS( FILE, FLOAT(TRACK.THE_TIME,HOURS), 2 ); 
PUT( FILE, TRACK.THE_TIME.HOURS, 1 ); 

PUT_LEADING_ZEROS( FILE, FLOAT(TRACK.THE_TIME.MINUTES), 2 ); 
PUT( FILE, TRACK.THE_TIME.MINUTES, 1 ); 

PUT_LEADING_ZEROS( FILE, FLOAT(TRACK.THE_TIME.SECONDS), 2 ); 
PUT( FILE, TRACK.THE_TIME.SECONDS, 1 ); PUT( FILE, '/' ); 


—put TRACK.TRACK_CLASS 
if TRACK.TRACK_CLASS - AIR 

then 

PUT( 

FILE, 

"AA/" 

); 

elsif TRACK.TRACK_CLASS - SURFACE 

then 

PUT( 

FILE, 

"SU/" 

); 

else 


PUT( 

FILE, 

"SS/" 

); 

end if; 







—put 

TRACK. IFF_ 

_CLASS 







if 

TRACK.IFF_ 

_CLASS 

- FRIENDLY 

then 

PUT( 

FILE, 

"F/" 

) 

elsif 

TRACK.IFF_ 

_CLASS 

- HOSTILE 

then 

PUT( 

FILE, 

"H/" 

) 

elsif 

TRACK.IFF_ 

_CLASS 

- NEUTRAL 

then 

PUT( 

FILE, 

"N/" 

) 

else 





PUT( 

FILE, 

"U/" 

) 


end if; 

—put TRACK.LATITUDE 
if TRACK.LATITUDE <0.0 then 
PUT( FILE, ' ) ; 

PUT_LEADING_ZEROS( FILE, -TRACK.LATITUDE, 2 ); 
else 

PUT( FILE, ' ' ); 


166 







PUT_LEADING_ZEROS( FILE, TRACK.LATITUDE, 2 ); 
end 1£; 

POT( FILE, TRACK.LATITUDE, 1, 1, 0 ); PUT( FILE, '/' ); 
—put TRACK.LONGITUDE 
if TRACK.LONGITUDE <0.0 then 
PUT( FILE, ); 

PUT_LEADING_ZEROS( FILE, -TRACK.LONGITUDE, 3 ); 
else 

PUT( FILE, ' ' 

PUT_LEADING_ZEROS( FILE, TRACK.LONGITUDE, 3 ); 
end if; 

PUT( FILE, TRACK.LONGITUDE, 1, 1, 0 ); PUT( FILE, '/' ); 
—put TRACK.ALTITUDE 
if TRACK.ALTITUDE <0.0 then 
PUT( FILE, ); 

PUT_LEADING_ZEROS( FILE, -TRACK.ALTITUDE, 5 ); 

PUT( FILE, -TRACK.ALTITUDE, 1, 1, 0 ); 
elsif TRACK.ALTITUDE >0.0 then 
PUT( FILE, ' ' ); 

PUT_LEADING_ZEROS( FILE, TRACK.ALTITUDE, 5 ); 

PUT( FILE, TRACK.ALTITUDE, 1, 1, 0 ); 
else 

PUT( FILE, " 00000.0" ); 
end if; 

PUT( FILE, ); 

—put TRACK.COURSE 

PUT_LEADING_ZEROS( FILE, TRACK.COURSE, 3 ); 

PUT( FILE, TRACK.COURSE, 1, 1, 0 ); PUT( FILE, '/' ); 

—put TRACK.VELOCITY 

PUT_LEADING_ZEROS( FILE, TRACK.VELOCITY, 3 ); 

PUT( FILE, TRACK.VELOCITY, 1, 1, 0 ); PUT( FILE, ); 

—put TRACK.THE_RANGE 

PUT_LEADING_ZEROS( FILE, TRACK.THE_RANGE, 4 ); 

PUT( FILE, TRACK.THE_RANGE, 1, 2, 0 ); PUT( FILE, ); 

—put "end of track information" indicator to the file 
PUT_LINE( FILE, "C/" ); 
end PRINT ONE TRACK; 


167 



__***************************************************************** 


—*** procedure PRINT_TRACKS *** 

__****************«************************************************ 

procedure PR1NT_TRACKS( 

FILE : in FILE_TyPE; 

COMMS_TRACKS : in out COMMS_TRACK_LIST; 

SECONDS SINCE MIDNIGHT : in out NATURAL ) is 


SELECTED_TRACK_ID 

SELECTED_TRACK 

PREVIOUS 

CURRENT 

RANDOM NUMBER 


NATURAL; 

COMMS_TRACK_LIST ; 
COMMS_TRACK_LIST; 
COMMS_TRACK_LIST; 
FLOAT; 


begin —PRINT_TRACKS 

CURRENT COMMS_TRACKS; 

—initialize all track's reported component to befalse 
for 1 in 1..COMMS_TRACK_CAPACITy loop 
CURRENT.REPORTED false; 

CURRENT CURRENT,NEXT; 
end loop; 

—read one random number 
BANDOM_NUMBER RANDOM.NUMBER; 

—find a number between 0 & COMMS_TRACK_CAPAClTy, and then 
—report that amount of tracks 
for I in 0 .. NATURAL 

(RANDOM_NUMBER * FLOAT(COMMS_TRACK_CAPACITY-l)) loop 
—begin from the head of the list each time to search 
SELECTED_TRACK COMMS_TRACKS; 

PREVIOUS null; 

—select a track to report 
SELECTED_TRACK_ID 1 + 

NATURAL{ RANDOM.NUMBER * FLOAT(COMMS_TRACK_CAPACITY-l) ); 
—search the track list with the SELECTED_TRACK_ID and find 
—the related track 

while SELECTED_TRACK.ID /- SELECTED_TRACK_ID loop 
PREVIOUS SELECTED_TRACK; 

SELECTED_TRACK SELECTED_TRACK.NEXT; 
end loop; 

—if selected track has not already been reported, 

—then report it, else pass it 


168 







if SELECTED_TRACK.REPORTED - false then 

UPDATE_COMMS_TRACK( SELECTED_TRACK, SECONDS_SINCE_MIDNIGHT ); 
PRINT_ONE_TRACK( SELECTED_TRACK ); 

SELECTED_TRACK.REPORTED true; 
end if; 
end loop; 

—put "end of all tracks indicator" to the file 
PUT( FILE, '\' ); 
end PRINT TRACKS; 


begin --COMMS_LINKS 

SEC0NDS_SINCE_MIDN1GHT :- NATURAL{CALENDAR.SECONDS(CALENDAR.CLOCK)); 
if not COMMS_TRACKS_ARE_CREATED then 

—initialize the configuration of the COMMS_TRACKS 
CREATE_COMMS_TRACKS( COMMS_TRACKS, SECONDS_SINCE_MIDNIGHT ); 
COMMS_TRACKS_ARE_CREATED true; 
end if; 

—assign the names of all of the individual stations 
for I in 0 .. (NUMBER_0F_ADDRESSES-1) loop 
NAMES(I).NAME(1.,5) :-"NAME_"; 

NAMES(I).NAME(6) CHARACTER_OF( I ); 

end loop; 

—open file to which message will be printed 

FILE_NAME GET_FILE_NAME; 

CREATE( FILE, NAME -> FILE_NAME ); 

SET_LINE_LENGTH( FILE, 80 ); 

—assign the out variable of the procedure 
INPUT_LINK_MESSAGE FILE_NAME; 

—process FILE_NAME field 
PUT( FILE, "NAME : " ) ; 

PUT( FILE, FILE_NAME ); 

NEW_LINE( FILE ); 

—process LINK_ID field 
PUT( FILE, "LINK_ID : " ) ; 

RANDOM NUMBER RANDOM.NUMBER; 


if 

RANDOM_ 

NUMBER 

< 

0.25 

then 

PUT( 

FILE, 

JTIDS 

) ; 

elsif 

RANDOM_ 

_NtmBER 

< 

0.50 

then 

PUT( 

FILE, 

LINKll 

); 

elsif 

RANDOM_ 

NUMBER 

< 

0.75 

then 

PUT( 

FILE, 

LINK16 

) ; 

else 






PUT( 

FILE, 

OTCIXS 

); 


end if; 


169 




NEW_LINE( FILE ); 

—process CLASSIFICATION field 
PUT( FILE, "CLASSIFICATION : " 

RANDOM_NUMBER RANDOM.NUMBER; 

if RANDOM_NUMBER < 0.25 then 
elsif RANDOM_NUMBER <0.50 then 
elsif RANDOM_NUMBER < 0.75 then 
else 
end if; 

—process PRECEDENCE field 
PUT( FILE, " PRECEDENCE : "); 

RANDOM_NUMBER RANDOM.NUMBER; 

if RANDOM_NUMBER < 0.25 then 
elsif RANDOM_NUMBER <0.50 then 
elsif RANDOM_NUMBER <0.75 then 
else 
end if; 

NEW_LINE( FILE ) ; 

—process FM field 
PUT( FILE, "FM ; " ); 

RANDOM_NUMBER RANDOM.NUMBER; 

PUT( FILE, NAMES 

(NATURAL(RANDOM_NUMBER*FLOAT(NUMBER_OF_ADDRESSES-l))).NAME ) 

NAMES 

( NATURAL(RANDOM_NUMBER*FLOAT(NUMBER_OF_ADDRESSES-l))).USED true; 
FROM_NAME :- NAMES 

( NATURAL(RANDOM_NUMBER*FLOAT(NUMBER_OF_ADDRESSES-l))).NAME; 
NEW_LINE( FILE ); 

—process TO field 
PUT( FILE, "TO : " ) ; 

TO_NUMBER RANDOM.NUMBER; 

for I in 0..NATURAL(TO_NUMBER*FLOAT(NUMBER_OF_ADDRESSES/3)) loop 
RANDOM_NUMBER RANDOM.NUMBER; 

while NAMES(NATURAL 

(RANDOM_NUMBER*FLOAT(NUMBER_OF_ADDRESSES-l))).USED loop 
RANDOM_NUMBER RANDOM.NUMBER; 
end loop; 

SE'r_COL( FILE, 6 ); 

PUT( FILE, NAMES 

(NATURAL(RANDOM_NUMBER*FLOAT(NUMBER_OF_ADDRES3ES-l))).NAME ) 
NEW LINE( FILE ); 


0 




PUT( 

FILE, 

U 

) 

PUT( 

FILE, 

C 

) 

PUT( 

FILE, 

S 

) 

PUT( 

FILE, 

TS 

) 


PUT( 

FILE, 

R 

); 

PUT( 

FILE, 

P 

); 

PUT( 

FILE, 

0 

); 

PUT( 

FILE, 

Z 

); 


170 







HAMES 

(NATURAL(RANDOM_NUMBER*FLOAT(NUMBER_0F_ADDRESSES-1))).USED true; 
end loop; 

NEW_LINE( FILE ); 

—process INFO field 
PUT{ FILE, "INFO : " ); 

INFO_NUMBER RANDOM.NUMBER; 

for I in 0..NATURAL(INFO_NUMBER*FLOAT{NUMBER_OF_ADDRESSES/3)) loop 
RANDOM_NUMBER RANDOM.NUMBER; 

while NAMES(NATURAL 

(RANDOM_NUMBER*FLOAT(NUMBER._OF_ADDRESSES-l) ) ) .USED loop 
RANDOM_NUMBER RANDOM.NUMBER; 

end loop; 

SET_COL( FILE, 8 ); 

PUT( FILE, NAMES 

(NATURAL(RANDOM_NUMBER*FLOAT(NUMBEP_OF_ADDRESSES-l))).NAME ); 
NEW_LINE( FILE ); 

NAMES(NATURAL 

(RAn30M_NUMBER*FL0AT(NUMBER_0F_ADDRESSES-l))).USED true; 
end loop; 

NEW_LINE( FILE ); 

—process VIA field 
PUT( FILE, "VIA : " ); 

RANDOM_NUMBER RANDOM.NUMBER; 

for I in 0,.(NATURAL(TO_NUMBER*FLOAT(NimBER_OF_ADDRESSES/3)) + 

NATURAL(INFO_NUMBER*FLOAT(NUMBER_OF_ADDRESSES/3))) loop 
RANDOM_NUMBER RANDOM.NUMBER; 

while not ( NAMES(NATURAL 

(RANDOM_NUMBER*FLOAT(NUMBER_OF_ADDRESSES-l))).USED 
and NAMES(NATURAL(RANDOM_NUMBER* 

FLOAT(NUMBER_OF_ADDRESSES-l))).NAME /* FROM_NAME 
and not NAMES(NATURAL(RANDOM_NUMBER* 

FLOAT(NUMBER_OF_ADDRESSES-l))).REUSED)loop 
RANDOM_NUMBER RANDOM.NUMBER; 

end loop; 

SET_COL( FILE, 7 ); 

PUT( FILE, NAMES 

(NATURAL(BANDOM_NUMBER*FLOAT(NUMBER_OF_ADDRESSES-l))).NAME ); 
NEW_LINE{ FILE ); 

NAMES(NATURAL 


171 



{RANDOM_NUMBER*FLOAT{NUMBER_OF_ADDRESSES-1))).REUSED true; 
end loop; 

—process BY field 
SET_COL( FILE, 7 ); 

PUT( FILE, "BY " ); 

while not ( NAMES(NATURAL(RANDOM_NUMBER* 

FLOAT(NUMBER_OF_ADDRESSES-l))).USED 
and NAMES(NATURAL(RANDOM_NUMBER* 

FLOAT(NUMBER_0F_ADDRESSES-1))).NAME /- FROM_NAME 
and not NAMES(NATURAL(RANDOM_NUMBER* 

FLOAT(NUMBER_OF_ADDRESSES-l))).REUSED ) loop 
RANDOM_NUMBER RANDOM.NUMBER; 

end loop; 

PUT_L1NE( FILE, NAMES 

(NATURAL(RANDOM_NUMBER*FLOAT(NUMBER_OF_ADDRESSES-l))).NAME ); 
NAMES(NATURAL 

(RANDOM_NUMBER*FLOAT(NUMBER_OF_ADDRESSES-l))).REUSED true; 
NEW_LINE( FILE ); 

—process SUBJECT field 

PUT( FILE, "SUBJECT : THIS IS THE SUBJECT" ); 

NEW_LINE( FILE, 4 ); 
if RANDOM.NUMBER < 0.25 then 

—approximately one fourth of the messages will contain 
—plain text data 
PUT( FILE, "THIS IS THE TEXT"); 
else 

—approximately three fourth of the messages will contain 
—trac)c data 

PRINT_TRACKS( FILE, COMMS_TRACKS, SECONDS_SINCE_MIDNIGHr ); 
end if; 

CLOSE( FILE ); 
end COMMS LINKS; 


— ************■>****************************************************** 

—*** procedure PREPARE_PERIODIC_REPORT *** 

_ ************* ****************************************************** 

procedure PREPARE_PERIODIC_REPORT( 

INITIATE_TRANS : in 

INITIATE_TRANSMISSION_SEQUENCE; 
TERMINATE TRANS : in BOOLEAN; 


172 











TCD_TRANSMIT_COMMAND : in out TRANSMIT_COMMAND ) is 

PERIODIC_REPORT_FILE : constant FILENAME "TRACK_FILE"; 

LINK : LINKS TYPE; 


—*** Function PUT_TRACKS *** 

_—***************************************************************** 

function PUT_TRACKS ( 

TRACK : TRACK_TUPLE; 

INITIATE_TRANS : INITIATE_TRANSMISSION_SEQUENCE ) 

return TEXT STRING is 


TEXT 

I 

CURRENT 
STRING_4 
STRING 0 


TEXT_STRING; 

NATURAL := 1; —index of TEXT variable 
TRACK_TUPLE; 

STRING(1..4) " 

STRING(1..8) " 


__************************•******>►******************************* 

—*** Function CHARACTER_OF '• *** 

-._**«*****•************«;***************************************** 

function CHARACTER_OF( N : in NATURAL ) return CHARACTER is 
begin 

return( CHARACTER'VAL( N + 48 ) ); 
end CHARACTER OF; 


—*************************************************************** 
—*** Function FLOAT_TO_STRING_8 *** 

—*** Algorithm : converts 8-digit float number to *** 

—*** 8-character string *** 

_ *************************************************************** 

function FL0AT_T0_STRING_8( NUMBER ; in FLOAT ) return STRING is 
S : STRING(1..8) " 00000.0"; 

N : NATURAL; 

F : FLOAT NUMBER; 

R ; FLOAT; 
begin 


173 















if F < 0.0 then 
S(l) 

F :■ -F; 
end if; 

N NATURAL{ F ); 

R F - FLOAT( N ); 

if R < 0.0 then 
N N - 1; 

R R + 1.0; 

end if; 
if N > 9 then 
if N > 99 then 
if N > 999 then 
if N > 9999 then 

S{2) CHARACTER_OF( N/10000 ); 
N N - ( (N/10000) * 10000); 
end if; 

S(3) CHARACTER_OF( N/1000 ); 

N N - ( (N/1000) * 1000 ); 
end if; 

S(4) CHARACTER_OF( N/lOO ); 

N N - ( (N/lOO) * 100 ); 
end if; 

S(5) CHARACTER_OF( N/10 ); 

N :» N - ( (N/10) * 10 ); 
end if; 

S(6) CHARACTER_OF( N ); 

N NATURAL( R * 10.0 ); 

S(8) CHARACTER_OF( N ); 

return(S); 

end FLOAT TO STRING 8; 


__*************************************************************** 
—*** Function NATURAL_TO_STRING_4 *** 

—*** Algorithm : converts 4-digit natural number to *** 

—*** 4-character string *** 

function NATURAL_TO_STRING_4( NUMBER : NATURAL ) return STRING is 
S : STRING(1..4) "0000"; 

N : NATURAL NUMBER; 


174 








begin 

if N > 9 then 
if N > 99 then 
if N > 999 then 

S(l) CHARACTER_OF( N/1000 ); 

N N - ( (N/1000) * 1000 ); 
end if; 

S(2) CHARACTER_OF( N/lOO ); 

N N - ( (N/lOO) * 100 ); 
end if; 

S(3) CHARACTER_OF( N/10 ); 

N N - ( (N/10) * 10 ); 
end if; 

S(4) :- CHARACTER_OF(N); 
return(S); 

end NATURAL_TO_STRING_4; 

begin —PUT_TRACKS 
CURRENT TRACK; 
while CURRENT /- null loop 

if (INITIATE_TRANS.DBASE_REQUEST.TRACK_CLASS 

(CURRENT.TRACK_CIiASS) ) and 
(INIT1ATE_TRANS.DBASE_REQUEST.IFF_CLASS 

(CURRENT.IFF_CLASS) ) and 

(INITIATE_TRANS.DBASE_REQUEST.THE_RANGE>-CURRENT.THE_RANGE) 

then 

TEXT(I..1+3) "POS/"; 

TEXT(1+4..1+7) :- NATURAL_TO_STRING_4(CURRENT.ID); 

TEXT(1+8) '/'; 

TEXT(I+9..1+16) CURRENT.OBSERVER; 

TEXT(1+17) '/'; 

STRING_4 NATURAL_TO_STRING_4 

(CURRENT.OBSERVATION_TIME.HOURS); 

TEXT(1+18..1+19) STRING_4(3..4); 

STRING_4 NATURAL_TO_STRING_4 

(CURRENT.OBSERVATION_TIME.MINUTES); 

TEXT(1+20..1+21) STRING_4(3..4); 

STRING_4 NATURAL_TO_STRING_4 

(CURRENT.OBSERVATION_TIME.SECONDS); 

TEXT(1+22..1+23) STRING_4(3..4) ; 

TEXT(1+24) '/'; 


175 






if CURRENT.TRACK_C1ASS - SURFACE then 
TEXT(1+25..1+26) :-"SU"; 
elsif CURRENT.TRACK_CIASS - SUBSURFACE then 
TEXT(1+25..1+26) "SS"; 

else 

TEXT(I+25..1+26) "AA"; 

end if; 

TEXT(1+27) 

if amRENT.IFF_CLASS - FRIENDLY then 
elsif CURRENT.IFF_CLASS - HOSTILE then 
elsif CURRENT.IFF_CLASS - NEUTRAL then 
else 
end if; 

TEXT(1+29) '/'; 

STRING_8 FLOAT__TO_STRING_8 (CXHWENT.LATITUDE) ; 

if STRING_8(1) - then 

TEXT(1+30) 
else 

TEXT(1+30) ' '; 

end if; 

TEXT(1+31..1+34) STRING_8(5..8) ; 

TEXT(1+35) '/'; 

STRING_8 FLOAT_TO_STRING_8(CURRENT.LONGITUDE); 

if STRING_8(1) - then 

TEXT(1+36) 
else 

TEXT(1+36) ' '; 

end if; 

TEXT(1+37..1+41) STRING_8(4..8); 

TEXT(1+42) '/'; 

TEXT(I+43..1+50) FLOAT_TO_STRING_8(CURRENT.ALTITUDE); 

TEXT(1+51) '/'; 

STRING_8 FLOAT_TO_STRING_8(CURRENT.COURSE); 

TEXT(1+52..1+56) STRING_8(4..8) ; 

TEXT(1+57) :• 

STRING_8 FLOAT_TO_STRING_8(CURRENT.VELOCITY); 

TEXT(1+58..1+62) STRING_8(4..8) ; 

TEXT(1+63) '/'; 

STRING_8 :- FLOAT_TO_STRING_8(CURRENT.THE_RANGE); 

TEXT(1+64..1+70) STRING_8(2..8) ; 

TEXT(1+71) :• '/'; 


TEXT(I+28) :« 'F' 
TEXT(1+28) 'H' 

TEXT(1+28) 'N' 

TEXT(1+28) :» 'U' 


176 





















FILE 

LINE 

I 

ADDRESS_HEAD 
NEW_ADDRESS 
VIA_HEAD 
NEW_VIA 
LINE LENGTH 


TEXT_IO.FILE_TYPE; 

STRING(1..80); 

NATURAL; 

ADDRESS_LINK; 

ADDRESS_LINK; 

VIA_RECORD_LINK; 

VIA_RECORD_LINK; 

NATURAL; 




mit * it 
.*** 


*** 

*** 


*** procedure GET_ONE_LINE 

*** algorithm : this procedure reads one line from the 

pointed file and returns the content of the 
file. The difference between this procedure *** 
-*** and TEXT_IO.GET_LINE is that, this procedure *** 

-*** adds BLANK character to the empty places in *** 

-*** the line *** 


*** 


procedure GET_ONE_LINE( 

FILE : in TEXT_IO.FILE_TYPE; 

LINE : out STRING; 

LINE LENGTH : out NATURAL ) is 


THE_LINE : STRINGd. .80); —dummy line variable is used 
THE_LENGTH : NATURAL; —dummy line_length variable is used 

begin —GET_ONE_LINE 

—read the line from the input file 
TEXT_IO.GET_LINE( FILE, THE_LINE, THE_LENGTH ); 

—add BLANK character to the empty places 
for I in THE_LENGTH+1 ., 80 loop 
THE_LINE( I ) 
end loop; 

—assign the OUT variables to local variables 
LINE THE_LINE; 

LINE_LENGTH THE_LENGTH; 
end GET ONE LINE; 


begin —PARSE_INPUT_FILE 

—open the file to be parsed 


178 







OPEN( FILE, NAME -> 1NPUT_LINK_MESSAGE, MODE -> IN_FILE ); 

—process filename field 

INPUT_TEXT_RECORD.NAME INPUT_LINK_MESSAGE; 

SKIP_LINE( FILE ); 

—process link_id field 

GET_ONE_LINE( FILE, LINE, LINE_LENGTH ); 
if LINE(11..15) - "JTIDS" then 
INPUT_TEXT_RECORD.LINK_ID JTIDS; 
elsif LINE(11..16) - "LINKll" then 
INPUT_TEXT_RECORD.LINK_ID LINKll; 
elsif LINE(11.. 16) -> "LINK16" then 
1NPUT_TEXT_REC0RD.LINK_ID LINK16; 
else 

INPUT_TEXT_RECORD.LINK_ID OTCIXS; 
end if; 

—s)cip route field £ blank lines 
while LINE(1..14) /- "CLASSIFICATION" loop 
GET_ONE_LINE( FILE, LINE, LINE_LENGTH ); 
end loop; 

—process classification field 
if LINE(18) - 'U' then 

INPUT_TEXT_RECORD.HEADER.CLASSIFICATION:-U; I 33; 

elsif LINE(18) - 'C' then 

INPUT_TEXT_RECORD.HEADER.CLASSIFICATION:-C; I 33; 

elsif LINE(18) - 'S' then 

INPUT_TEXT_RECORD.HEADER.CLASSIFICATION:-S; I 33; 

else 

INPUT_TEXT_RECORD.HF' ;ER.CLASSIFICATION:-TS;I :- 34; 
end if; 

—process precedence field 

if LINE(I) - 'R' then INPUT_TEXT_RECORD.HEADER.PRECEDENCE :- R, 

elsif LINE(I) - 'P' then INPUT_TEXT_RECORD.HEADER.PRECEDENCE :- P 

elsif LINE(I) - 'O' then INPUT_TEXT_RECORD.HEADER.PRECEDENCE :- 0 

else INPUT_TEXT_RECORD.HEADER.PRECEDENCE :- Z, 

end if; 

—process origin field 

GET_ONE_LINE( FILE, LINE, LINE_LENGTH ); 

INPUT_TEXT_RECORD.HEADER.ORIGIN :- LINE(6..11); 

—process address field 

GET_ONE_LINE( FILE, LINE, LINE_LENGTH ); 

ADDRESS HEAD :« null; 


179 





while LINE_LENGTH > 1 loop —there exist another address 
NEW_ADDRESS new ADDRESS_TYPE; 

NEW_ADDRESS.NAME LINE(6..11); 

NEW_ADDRESS.NEXT ADDRESS_HEAD; 

ADDRESS_HEAD NEW_ADDRESS; 

GET_ONE_LINE( FILE, LINE, LINE_LENGTH ); 

end loop; 

INPOT_TEXT_RECORD.HEADER.ADDRESS ADDRESS_HEAD; 

—process info field 

GET_ONE_LINE{ FILE, LINE, LINE_LENGTH ); 

ADDRESS_HEAD null; 

while LINE_LENGTH > 1 loop —there exist another address 
NEW_ADDRESS new ADDRESS_TyPE; 

NEW_ADDRESS.NAME LINE(8..13); 

NEW_ADDRESS.NEXT ADDRESS_HEAD; 

ADDRESS_HEAD NEW_ADDRESS; 

GET_ONE_LINE( FILE, LINE, LINE_LENGTH ); 

end loop; 

INPUT_TEXT_RECORD.HEADER.INFO :« ADDRESS_HEAD; 

—process via field 

GET_ONE_LINE{ FILE, LINE, L1NE_LENGTH ); 

VIA_HEAD null; 

while LINE_LENGTH > 1 loop —there exist another address 
NEW_VIA new VIA_RECORD; 

ADDRESS_HEAD null; 

while LINE(7..8) /- "BY" loop 
—process relay_to field 
NEW_ADDRESS new ADDRESS_TYPE; 

NEW_ADDRESS.NAME LINE(7..12); 

NEW_ADDRESS.NEXT ADDRESS_HEAD; 

ADDRESS_HEAD NEW_ADDRESS; 

GET_ONE_LINE( FILE, LINE, L1NE_LENGTH ); 
end loop; 

—process relay_by field 

NEW_VIA.RELAY_BY :- LINE(10..15); 

NEW_VIA.RELAY_TO ADDRESS_HEAD; 

NEW_VIA.NEXT :- VIA_HEAD; 

VIA_HEAD NEW_VIA; 

GET_ONE_LINE( FILE, LINE, LINE_LENGTH ); 
end loop; 

INPUT TEXT RECORD.HEADER.VIA LINE VIA HEAD; 


180 












—process subject field 

GET_ONE_LINE( FILE, LINE, LINE_LENGTH ); 

INPUT_TEXT_RECORD.HEADER.SUBJECT(1..60) LINE(11..70); 

SKIP_LINE( FILE, 3 ); 

—fill in relay field 
INPUT_TEXT_RECORD.RELAYED false; 

—fill in archive field 
INPUI_TEXT_RECORD.ARCHIVE false; 

—process text field 
I 1; 

while ( not END_0F_F1LE ( FILE ) and I <- TEXT_LENGTH ) loop 
GET_ONE_LINE( FILE, LINE, LINE_LENGTH ); 

INPUT_TEXT_RECORD.TEXT(I..I+LINE_LENGTH-1) :- 

LINE(1..LINE_LENGTH); 

I I + 80; 
end loop; 

if INPUT_TEXT_RECORD.TEXT(1.,4) - "POS/" then 
—file consists of trac)c info 
1NPUT_TEXT_REC0RD.IS_TRACK true; 

Close ( FILE ); 

else —file consists of message 

INPUT_TEXT_REC0BD.1S_TRACK false; 
close( FILE ); 
end if; 

end PARSE INPUT FILE; 


—*** procedure DECIDE_FOR_ARCHIVING *** 


procedure DECIDE_FOR_ARCHIVING( 


INPUT_TEXT_RECORD 

: in 

out TEXT_RECORD; 

TDD_ARCHIVE_SETUP 

: in 

ARCHIVE_SETUP 

COMMS_TEXT_FILE 

: out 

TEXT_RECORD; 

COMMS EMAIL 

: out 

FILENAME ) is 


CURRENT : ADDRESS LINK; 


begin 

if TDD_ARCHIVE_SETUP.ALL_SHIPS then 

—we are done, since all incoming messages are to be archived 


181 




INPUT_TEXT_RECORD.ARCHIVE true; 

C(»1MS_TEXT_FILE INPUT_TEXT_RECORD; 
elsif ((TDD_ARCHIVE_SETUP.JTIDS) and 

(INPUT_TEXT_RECORD.LINK_ID - JTIDS)) or 
((TDD_ARCHIVE_SETUP.LIKK16) and 
(INPUT_TEXT_RECORD.LINK_ID - L1MK16)) or 
((TDD_ARCHIVE_SETUP.LlNKl1) and 
(INPUT_TEXT_RECORD.LINK_ID - LlNKll)) or 
({TDD_ARCHIVE_SETUP.OTCIXS) and 
(INPUT_TEXT_RECORD.LINK_ID - OTCIXS)) then 
—link_ld of the incoming message matches with user choice 
—specified in by the archive setup. 

INPUT_TEXT_RECORD.ARCHIVE true; 

COMMS_TEXT_FILE INPUT_TEXT_RECORD; 
else 

--we want to archive only the files which are directed to us 
CURRENT INPUT_TEXT_RECORD.HEADER.ADDRESS; 

while CURRENT.NEXT /- null and not INPUT_TEXT_RECORD.ARCHIVE loop 
if CURRENT.NAME - OWN_ADDRESS then 

INPUT_TEXT_RECORD.ARCHIVE true; 

COMMS_TEXT_FILE INPUT_TEXT_RECORD; 
else 

CURRENT CURRENT.NEXT; 

end if; 
end loop; 
end if; 

COMMS_EMAIL INPUT_TEXT_RECORD.NAME; 
end DECIDE FOR ARCHIVING; 


—*** procedure EXTRACT_TRACKS *** 


procedure EXTRACT_TRACKS( 


COMMS_TEXT_FILE : in TEXT_RECORD; 

COMMS_ADD_TRACK : out ADD_TRACK_TUPLE ) is 
NEW_TRACK : TRACK_TUPLE; 

HEAD : TRACK_TUPLE; 

TEXT : TEXT_STRING; 

1 : NATURAL :* 1; —index of TEXT variable 

END OF TEXT : BOOLEAN false; 


182 






ID 

STRING(1..6) 

- "000000"; 

HOUR 

STRING(1. .6) 

- "000000"; 

MINUTE 

STRING(1. .6) 

- "000000"; 

SECOND 

STRING(1. .6) 

- "000000"; 

LATITUDE 

STRING(1. .8) 

- "000000.0"; 

LONGITUDE 

STRING(1. .8) 

- "000000.0"; 

ALTITUDE 

STRING(1..8) 

. "000000.0"; 

COURSE 

STRING(1..8) 

- "000000.0"; 

VELOCITY 

STRING(1. .8) 

- "000000.0"; 

THE RANGE 

STRING(1..9) 

- "000000.00"; 


a..***************************************************************** 

—*** function NATURAL_OF *** 

..* **************************************************************** 

function NATURAL_OF( CHAR : in CHARACTER ) return NATURAL is 
begin —NATURAL_OF 

return ( CHARACTER'POS( CHAR ) - 48 ); 
end NATURAL OF; 


w«.* **************************************************************** 

—*** function STRING_6_T0_NATURAL *** 

— ***************************************************************** 

function STRING_6_T0_NATURAL( STR : in STRING ) return NATXn<AL is 
COEFFICIENT : NATURAL 100000; 

OUT_NUMBER ; NATURAL 0; 

begin —STRING_6_TO_NATURAL 
for I in 1..6 loop 

OUT_NUMBER OUT_NUMBER + NATURAL_OF( STR(I) ) * COEFFICIENT; 
COEFFICIENT :» COEFFICIENT / 10; 
end loop; 

return ( OUT_NUMBER ); 
end STRING 6 TO NATURAL; 


—***************************************************************** 

—*** function STRING_8_TO_FLOAT *** 

_—***************************************************************** 

function STRING_8_TO_FLOAT( STR : in STRING ) return FLOAT is 
PREFIX : NATURAL; 


183 









POSTFIX ; NATURAL; 

OUT_NUMBER : FLOAT; 
begin 

PREFIX STRING_6_TO_NATURAL( STR(1..6) ); 

POSTFIX NATURAL_OF < STR(8) ); 

OUT_NUMBER FLOAT( PREFIX ) + O.i * FLOAT( POSTFIX ); 
return( OUT_NUMBER ); 
end STRING 8 TO FLOAT; 


__««*«***************** ********************lk**'********1k************ 

—*** function STRING_9_TO_FLOAT *** 

—.***************************************************************** 

function STRING_9_TO_FLOAT( STR : in STRING ) return FLOAT is 
OUT_NUMBER : FLOAT; 
begin —STRING_9_TO_FLOAT 

OUT_NUMBER STRING_8_TO_FLOAT 

(STR(1..8)) + 0.01 * FLOAT(NATURAL_OF(STR(9))); 
return{ OUT_NUMBER ); 
end STRING_9_TO_FLOAT; 

begin —EXTRACT_TRACKS 
HEAD null; 

TEXT COMMS_TEXT_FILE.TEXT; 

while not END_OF_TEXT loop 

NEW_TRACK new TRACK_RECORD; 

—process ID field 

ID(3..6) TEXT(1+4..1+7); 

NEW_TRACK.ID :- STRING_6_TO_NATURAL(ID); 

—process OBSERVER field 

NEW_TRACK.OBSERVER TEXT(1+9..1+16); 

—process TIME field 
HOUR(5..6) TEXT(1+18..1+19); 

MINUTE(5..6) TEXT(1+20..1+21); 

SECOND(5..6) TEXT(1+22..1+23); 

NEW_TRACK.OBSERVATION_TIME.HOURS STRING_6_TO_NATURAL(HOUR ) 

NEW_TRACK.OBSERVATION_TIME.MINUTES STRING_6_TO_NATURAL(MINUTE) 

NEW_TRACK.OBSERVATION_TIME.SECONDS STRING_6_TO_NATURAL(SECOND) 

—process TRACK_CLASS field 
if TEXT(1+25..1+26) - "SU" then 

NEW TRACK.TRACK CLASS SURFACE; 


184 










SS" then 


elsif TEXT(1+25..1+26) - " 

NEW_TRACK.TRACK_CLASS SUBSURFACE; 

else 

NEW_TRACK.TRACK_CLASS AIR; 

end if; 

—process IFF_CLASS field 

if TEXT(1+28) - 'F' than NEW_TRACK.IFF_CLASS 
elsif TEXT(1+28) - 'H' then NEW_TRACK.IFF_CLASS 
elsif TEXT(1+28) - 'N' then NEW_TRACK.IFF_CLASS 
else NEW_TRACK.IFF_CLARS 

end if; 

—process LATITUDE field 
LATITTOE(5..8) TEXT(1+31..1+34); 

NEW_TRACK.LATITUDE :- STRING_8_TO_FLOAT(LATITUDE); 
if TEXT(1+30) - then 

NEW_TRACK.LATITUDE -NEW_TRACK.LATITUDE; 

end if; 

—process LONGITUDE field 
LONGITUDE(4..8) TEXT(1+37..1+41); 

NEW_TRACK.LONGITUDE STRING_8_TO_FLOAT(LONGITUDE) 
if TEXT(1+36) - then 

NEW_TRACK.LONGITUDE -NEW_TRACK.LONGITUDE; 

end if; 

—process ALTITUDE field 
ALTITUDE(2..8) TEXT(1+44..1+50); 

NEW_TRACK.ALTITUDE STRING_8_TO_FLOAT(ALTITUDE); 

if TEXT(1+43) - then 

NEW_TRACK.ALTITUDE -NEW_TRACK.ALTITUDE; 

end if; 

—process COURSE field 
COURSE(4..8) TEXT(1+52..1+56); 

NEW_TRACK.COURSE STRING_8_TO_FLOAT(COURSE); 

—process VELOCITY field 

VELOCITY(4..8) TEXT(1+58..1+62); 

NEW_TRACK.VELOCITY STRING_8_TO_FLOAT(VELOCITY); 

—process THE_RANGE field 
THE_RANGE(3..9) TEXT(1+64..1+70); 

NEW_TRACK.THE_RANGE :» STRING_9_TO_FLOAT(THE_RANGE) 
—process ARCHIVE_FLAG field 

if TEXT(1+72) - 'C' then NEW_TRACK.ARCHIVE_FLAG 
elsif TEXT(1+72) - 'N' then NEW TRACK.ARCHIVE FLAG 


FRIENDLY; 

HOSTILE; 

NEUTRAL; 

UNKNOWN; 


C; 

N; 


185 







elsif TEXT(1+72) - 'A' then NEW_TRACK,ARCHIVE_FLAG A; 
else NBM_TRACK.ARCHIVE_FLAG S; 

end if; 

—link NEW_TRACK to head of tracks 
NEW_TRACK.NEXT HEAD; 

HEAD NEW_TRACK; 

—go to the begininng of the next line 
I I + 80; 
if TEXT(l) - 'V then 

—end of tracks sign is encountered 
END_OF_TEXT true; 
end if; 
end loop; 

COMMS_ADD_TRACK.TRACK HEAD; 

COMMS_ADD_TRACK.ORIGIN "COMMS 
end EXTRACT TRACKS; 


__**********>******************************************************** 

—*** procedure FILTER_COMMS_TRACKS *** 

__******************************************************************* 

procedure FILTER_COMMS_TRACKS( 

COMMS_ADD_TRACK : in out ADD_TRACK_TUPLE; 

TDD_FILTER : in SET_TRACK_FILTER; 

FILTERED_COMMS_TRACK : out ADD_TRACK_TUPLE ) is 

HEAD : TRACK_TUPLE COMMS_ADD_TRACK.TRACK; 

CURRENT : TRACK_TUPLE COMMS_ADD_TRACK.TRACK; 

PREVIOUS : TRACK_TUPLE null; 

begin —FILTER_COMMS_TRACKS 
while CURRENT /- null loop 

—search through conims_add_track in order to find the place 
—for the new track according to the precedence 

if (TDD_FILTER.DESIRED_CLASS(CURRENT.TRACK_CLASS)) and 
(TDD_FILTER.DESIRED_RANGE(CURRENT.TRACK_CLASS) >- 

CURRENT.THE_RANGE) then 

PREVIOUS CURRENT; 

CURRENT :<• CURRENT.NEXT; 
else 


186 







if PREVIOUS - null then 
HEAD CURRENT.NEXT; 

else 

PREVIOUS.NEXT CURRENT.NEXT; 

end if; 

CURRENT CURRENT.NEXT; 
end if; 
end loop; 

if HEAD - null then 
APPROVED false; 

end if; 

FILTERED_COMMS_TRACK.TRACK HEAD; 

end F1LTER_C0MMS_TRACKS; 


—***************************************************************** 

—*** procedure DELETE_TRACK *** 

„***************************************************************** 

procedure DELETE_TRACK( 

TRACKS : in out TRACK_TUPLE; 

TARGET_ID : in NATURAL ) is 

TRACK_1S_F0UND : BOOLEAN false; 

POSITION : TRACK_TUPLE; 

PREVIOUS : TRACK_TUPLE; 

CURRENT : TRACK_TUPLE; 

begin —DELETE_TRACK 
POSITION TRACKS; 

PREVIOUS null; 

while POSITION /- null and not TRACK_IS_FOUND loop 
if POSITION.ID - TARGET_ID then 
TRACK_IS_FOUND true; 

NUMBER_OF_TRACKS NUMBER_OF_TRACKS - 1; 
if PREVIOUS - null then 
TRACKS POSITION.NEXT; 

else 

PREVIOUS.NEXT POSITION.NEXT; 
end if; 
else 

PREVIOUS POSITION; 


187 











POSITION POSITION.NEXT; 
end if; 
end loop; 
end DELETE TRACK; 


**************************************************************** 

—*** procedure PIACE_TRACK *** 

—*** algorithm : this procedure adds the new__tracJc to TRACKS *** 


^«.*** 

.^*** 

_^*** 

...*** 

..*** 

..*** 


*** 

*** 


so that the resultant TRACKS link list have 
AIR tracks followed by SURFACE tracks, 
followed by SUBSURFACE tracks. Also the track *** 
with the same TRACK_CLASS but with smaller *** 
RANGE comes before the other track in TRACKS *** 
link list *** 


„***************************************************************** 
procedure PLACE_TRACK( 

TRACKS : in out TRACK_TUPLE; 

NEW TRACK ; in TRACK TUPLE ) is 


CURRENT 

PREVIOUS 


TRACK_TUPLE 
TRACK TUPLE 


TRACKS; 

null; 


begin —PLACE_TRACK 

if CURRENT « null then 

--currently, there is no track in TRACKS, so assign it to 

—new track 

TRACKS NEW_TRACK; 

elsif CURRENT.TRACK_CLASS > NEW_TRACK.TRACK_CLASS then 

—new track's position is before the head of the tracks list 
—according to their track_class in the track_claas_type, 

—so add new_track to the head of the TRACKS 
NEW_TRACK.NEXT TRACKS; 

TRACKS NEW_TRACK; 

elsif (CURRENT.TRACK_CLASS <- NEW_TRACK.TRACK_CLASS) then 
—new track's position is after the head of the tracks list 
—according to their track_class in the track_class_type, 

—so find a suitable position for the new_track, so that it 
— will satisfy the condition, described at the algorithm 
—of the procedure 
while ( CURRENT /•• null ) and then 


188 









( CURRENT.TRACK_CIASS < NEW_TRACK.TRACK_CLASS ) loop 
PREVIOUS CURRENT; 

CURRENT OnWENT.NEXT; 
end loop; 

if CURRENT - null then 

PREVIOUS.NEXT NEW_TRACK; 

else 

while ( CURRENT /- null ) and then 

( CURRENT.TRACK_CLASS - NEW_TRACK.TRACK_CIiASS ) loop 
if CURRENT.THE_RANGE < NEW_TRACK.THE_RANGE then 
PREVIOUS CURRENT; 

CURRENT CURRENT.NEXT; 

else 
exit; 
end if; 
end loop; 

if CURRENT - null then 

PREVIOUS.NEXT NEW_TRACK; 
elsif PREVIOUS - null then 
NEW_TRACK.NEXT TRACKS; 

TRACKS NEW_TRACK; 
else 

PREVIOUS.NEXT NEW_TRACK; 

NEW_TRACK.NEXT :» CURRENT; 
end if; 
end if; 
end if; 

end PLACE TRACK; 


—*** procedure DELETE_LAST *** 

— ***************************************************************** 

procedure DELETE_LAST( TRACKS : in out TRACK_TUPLE ) is 

CURRENT : TRACK_TUPLE TRACKS; 

PREVIOUS : TRACK_TUPLE null; 

begin —DELETE_LAST 

while CURRENT.NEXT /- null loop 
PREVIOUS CURRENT; 


189 











CURRENT CURRENT.NEXT; 
end loop; 

PREVIOUS.NEXT null; 
end DELETE LAST; 


__*************************«***************************************** 

—*** procedure ADD_COMMS_TRACK *** 

— ******************************************************************* 

procedure ADD_COMMS_TRACK( 

FILTERED_COMMS_TRACK : in ADD_TRACK_TUPLE; 

TDD_FILTER : in SET_TRACK_FILTER; 

OUT_TRACKS : in out TRACK_TUPLE ) is 

CURRENT : TRACK_TUPLE FILTERED_COMMS_TRACK.TRACK; 

NEW_TRACK : TRACK_TUPLE; 

begin —ADD_COMMS_TRACK 

while CURRENT /- null loop 

NEW_TRACK new TRACK__RECORD; 

NEW_TRACK.ALL CURRENT.ALL; 

CURRENT CURRENT.NEXT; 

NEW_TRACK.NEXT null; 

if NUMBER_OF_TRACKS < TDD_FILTER.MAX_NUMBER then 
NUMBER_OF_TRACKS NUMBER_OF_TRACKS + 1; 
else 

DELETE_LAST( TRACKS ); 
end if; 

DELETE_TRACK{ TRACKS, NEW_TRACK.ID ); 

PLACE_TRACK( TRACKS, NEW_TRACK ); 
end loop; 

OUT_TRACKS new TRACK_RECORD; 

OUT_TRACKS.ALL TRACKS.ALL; 
end ADD CO^mS TRACK; 


—*** procedure SENSORS *** 


procedure SENSORS( SENSOR_DATA : out SENSOR_RECORD ) is 


190 

















SECONDS_SINCE_MIDNIGHT 

NEW_ECHO 

PREVIOUS 

SELECTED_TRACK 

SELECTED_TRACK_ID 

SENSOR_TRACK_CAPAClTy 

PI 

RA0IANS_PER_DEGREE 
DEGREES PER RADIAN 


NATURAL; 

SENSOR_RECORD; 

SENSOR_TRACK_LIST; 

SENSOR_TRACK_LI ST.- 
NATURAL; 

constant NATURAL :* 15; 
constant FLOAT 3.1415926536; 

constant FLOAT PI / 180.0; 

constant FLOAT 1.0 / RADIANS PER DEGREE 


—***************************************************************** 

—*** procedure CREATE_SENSOR_TRACKS *** 

— —«*-*«************************************************************* 

procedure CREATE_SENSOR_TRACKS( 

SENSOR_TRACKS : in out SENSOR_TRACK_LIST; 

SECONDS_SINCE_MIDNIGHT : in NATURAL ) is 

NEW_TRACK : SENSOR_TRACK_LIST; 

RANDOM_NUMBER : FLOAT; 

—constant attributes for the tracks 


MIN_AIR_HEIGHT 


constant 

FLOAT 


3000.0; 

MIN_AIR_VELOCITy 


constant 

FLOAT 


300.0; 

MAX_AIR_VELOCITy 


constant 

FLOAT 


800.0; 

AIR_VELOCITy_DIFF 


constant 

FLOAT 



: 

- 

MAX_AIR_VELOCITy - 

MIN_AIR_VELOCITy 

MIN_SURFACE_VELOCITy 


constant 

FLOAT 


0.0; 

MAX_SURFACE_VELOCITy 


constant 

FLOAT 


40.0; 

MAX_HEADING_ANGLE 


constant 

FLOAT 


360.0; 

MAX_SENSOR_RANGE 


constant 

FLOAT 


500.0; 

MIN_SUBSURFACE_DEPTH 


constant 

FLOAT 


0.0; 

MIN_SUBSURFACE_VELOCITy 


constant 

FLOAT 

• m 

0.0; 

MAX_SUBSURFACE_VELOCITy 


constant 

FLOAT 


30.0; 

MIN_ELEVATION 


constant 

FLOAT 


-90.0; 

MAX_ELEVATION 


constant 

FLOAT 

• m 

90.0; 

MIN_AZIMUTH 


constant 

FLOAT 

1 * 

-180.0; 

MAX_AZIMUTH 


constant 

FLOAT 

• m 

180.0; 

MAX_BEARING_ANGLE 


constant 

FLOAT 





MAX 

AZIMUTH - 

MIN_AZIMUTH; 

AIR_TRACK_REBIRTH_RATIO 

; 

constant 

FLOAT 

1 m 

0.2; 

SURFACE TRACK REBIRTH RATIO 


constant 

FLOAT 


0.8; 


191 










MILES_PER_DEGREE : constant FLOAT 60.0; 

begin ~CREATE_SENSOR_TRACKS 

for I in 11 .. SENSOR_TRACK_CAPACITY loop 

NEW_TRACK new SENSOR_TRACK_RECORD; 

NEW_TRACK.CONTACT.ID I; 

RANDOM_NXJMBER t- RANDOM.NUMBER; 

if RANDOM_NUMBER < AIR_TRACK_REBIRTH_RATIO then 
—create air track 

NEW_TRACK.CONTACT.TRACK_CLASS AIR; 

NEW_TRACK.CONTACT.ELEVATION MAX_ELEVATION * 

RANDOM.NUMBER; 

NEW_TRACK.CONTACT.VELOCITY MIN_AIR_VELOCITY + 

( RANDOM.NUMBER * AIR_VELOCITY_DIFF ); 
elsif RANDOM_NUMBER < SURFACE_TRACK_REBIRTH_RATIO then 
—create surface track 

NEW_TRACK.CONTACT.TRACK_CLASS SURFACE; 

NEW_TRACK.CONTACT.ELEVATION :» 0.0; 

NEW_TRACK.CONTACT.VELOCITY MIN_SURFACE_VELOCITY + 

( RANDOM.NUMBER * MAX_SURFACE_VELOClTY ); 

else 

—create subsurface track 

NEW_TRACK.CONTACT.TRACK_CLASS SUBSURFACE; 

NEW_TRACK,CONTACT.ELEVATION MIN_ELEVAT10N * 

RANDOM.NUMBER ; 

NEW_TRACK.CONTACT.VELOCITY :» MIN_SUBSURFACE_VELOCITY + 

( RANDOM.NUMBER * MAX_SUBSURFACE_VELOCITY ); 

end if; 

NEW_TRACK.CONTACT.COURSE RANDOM.NUMBER * 

MAX_HEADING_ANGLE; 

NEW_TRACK.CONTACT.THE_RANGE RANDOM.NUMBER * MAX_SENSOR_RANGE; 

NEW_TRACK.CONTACT.AZIMUTH MIN_AZIMUTH + 

(RANDOM.NUMBER * MAX_BEARING_ANGLE); 
NEW_TRACK.CONTACT.ORIGIN "SENSOR "; 

NEW_TRACK.CONTACT.THE_TIME.HOURS :- 

SECONDS_SINCE_MIDNIGHT/3 600; 
NEW_TRACK.CONTACT.THE_TIME.MINUTES :- 

(SECONDS_SINCE_MIDNIGHT mod 3600) / 60; 
NEW_TRACK.CONTACT.THE_TIME.SECONDS :- 

(SECONDS SINCE MIDNIGHT mod 3600) mod 60; 


192 





RANDOM_NUMBER RANDOM.NUMBER; 
if RANDOM_NUMBER <0.25 then 

NEW_TRACK.CONTACT.IFF_CIASS FRIENDLY; 

elsif RANDOM_NUMBER < 0.50 then 

NEW_TRACK.CONTACT.IFF_CLASS HOSTILE; 

elsif RANDOM_NUMBER <0.75 then 

NEW_TRACK.CONTACT.IFF_CLASS NEUTRAL; 

else 

NEW_TRACK.CONTACT.IFFjCLASS UNKNOWN; 

end if; 

NEW_TRACK.CONTACT.ARCHIVE_FLAG C; 

NEW_TRACK.INTELLIGENCE( 1..40) 

"THIS IS INTELLIGENCE "; 

NEW_TRACK.INTELLIGENCE (41..80) 

•t If • 

$ 

NEW_TRACK.LATITUDE 35.0 + (NEW_TRACK.CONTACT-THE_RANGE * 

COS(NEW_TRACK.CONTACT.AZIMUTH*RADIANS_PER_DEGREE))/ 
MILES_PER_DEGREE; 

if NEW_TRACK.CONTACT.AZIMUTH >0.0 then 

NEW_TBACK.LONGITUDE 125.0 + (NEW_TRACK.CONTACT.THE_RANGE * 
SIN(NEW_TRACK.CONTACT.AZIMUTH*RADIANS_PER_DEGREE))/ 
MILES_PER_DEGREE; 

else 

NEW_TRACK.LONGITUDE 125.0 - (NEW_TRACK,CONTACT.THE_RANGE * 

SIN(NEW_TRACK.CONTACT.AZIMUTH*RAD1ANS_PER_DEGREE))/ 
MILES_PER_DEGREE; 

end if; 

—add NEW_TRACK to the head of the SENSOR_TRACKS 
NEW_TRACK.NEXT SENSOR_TRACKS; 

SENSOR_TRACKS NEW_TRACK; 

end loop; 

end CREATE SENSOR TRACKS; 


—jt**************************************************************** 

—*** procedure UPDATE_SENSOR_TRACK *** 

— ***************************************************************** 

procedure UPDATE_SENSOR_TRACK( 

SELECTED_TRACK ; in out SENSOR_TRACK_LIST; 

SECONDS SINCE MIDNIGHT : in NATURAL ) is 


193 








PREVIOUS_SECONDS_SINCE_MIDNIGHT : NATURAL; 

SECONDS_PASSED : NATURAL; 

OWN_LAT : FLOAT range -90.0..90.0 35.0; 

OWN_LONG : constant FLOAT 125.0; 

OWN_COURSE : FLOAT 0.0; 

OWN_VELOCITY : FLOAT 25.0; 

DISTANCE : FLOAT; 

LAT_DIST : FLOAT; 

LONG_DIST : FLOAT; 

MILES_PER_DEGREE : constant FLOAT 60.0; 

begin —UPDATE_SENSOR_TRACK 

—get the the time difference between consecutive echos of 

—the track in seconds 

PREVIOUS_SECONDS_SINCE_MIDNIGHT 

3600 * SELECTED_TRACK.CONTACT.THE_TIME.HOURS + 

60 * SELECTED_TRACK.CONTACT.THE_TIME.MINUTES + 

SELECTED_TRACK.CONTACT.THE_TIME.SECONDS; 
SECONDS_PASSED SECONDS_SINCE_MIDNIGHT - 

PREVIOUS_SECONDS_SINCE_MIDNIGHT; 
—write the new observation time of the track to the 
—track's record 

SELECTED_TRACK.CONTACT.THE_TIME.HOURS 

SEC0NDS_S1NCE_MIDNIGHT/3600; 
SELECTED_TRACK.CONTACT.THE_TIME.MINUTES ; •• 

(SECONDS_SINCE_MIDNIGHT mod 3600) / 60; 
SELECTED_TRACK.CONTACT.THE_TIME.SECONDS :- 

(SECONDS_SINCE_MIDNIGHT mod 3600) mod 60; 
—update own_ship'3 latitude 
OWN_LAT 35.0 + 

((FLOAT(SECONDS_PASSED)*OWN_VELOCITy) / 3600.0)/MILES_PER_DEGREE; 

—calculate the distance that the contact has went 

DISTANCE 

(FLOAT(SECONDS_PASSED)*SELECTED_TRACK.CONTACT.VELOCITY)/3600.0; 
—update selected_track's latitude 

SELECTED_TRACK.LATITUDE SELECTED_TRACK.LATITUDE + (DISTANCE* 

COS(SELECTED_TRACK.CONTACT.COURSE*RADIANS_PER_DEGREE))/ 

MILES_PER_DEGREE; 

—update selected_track'3 longitude 

SELECTED_TRACK.LONGITUDE SELECTED_TRACK.LONGITUDE + (DISTANCE* 
SIN(SELECTED TRACK.CONTACT.COURSE‘RADIANS PER DEGREE))/ 


194 








MILES_PER_DEGREE; 

—change the range of the track £ write to the track's record 
LAT_DIST ( SELECTED_TRACK.LATITUDE - OWN_LAT ) * 

MILES_PER_DEGREE; 

LONG_DIST ( SELECTED_TRACK.LONGITUDE - OWN_LONG ) * 
MILES_PER_DEGREE; 

SELECTED_TRACK.CONTACT.THE_RANGE 

SQRT( LAT_DIST**2 + L0NG_DIST**2 ) 
—update selected_track's range 

SELECTED_TRACK.CONTACT.AZIMUTH DEGREES_PER_RADIAN * 

ARCCOS(LAT_DIST/SELECTED_TRACK.CONTACT.THE_RANGE); 
end UPDATE SENSOR TRACK; 


begin —SENSORS 

SECONDS_SINCE_MIDNIGHT ;- NATURAL(CALENDAR.SECONDS(CALENDAR.CLOCK)) 
if not SENSOR_TRACKS_ARE_CREATED then 

CREATE_SENSOR_TRACKS( SENSOR_TRACKS, SECONDS_SINCE_MIDNIGHT ); 
SENSOR_TRACKS_ARE_CREATED true; 
end if; 

—begin from the head of the list each time to search 
SELECTED_TRACK_ID 0; 

SELECTED_TRACK SENSOR_TRACKS; 

PREVIOUS null; 

while SELECTED_TRACK_ID < 11 loop 

— because sensor tracks start with id 11 
SELECTED_TRACK_ID :» 

NATURAL( RANDOM.NUMBER*FLOAT( SENSOR_TRACK_CAPACITY ) ) 

end loop; 

while SELECTED_TRACK.NEXT /- null and 

SELECTED_TRACK.CONTACT.ID /- SELECTED_TRACK_ID loop 
PREVIOUS SELECTED_TRACK; 

SELECTED_TRACK SELECTED_TRACK.NEXT; 
end loop; 

UPDATE_SENSOR_TRACK( SELECTED_TRACK, SECONDS_SINCE_MIDNIGHT ); 
SENSOR_DATA.INTELLIGENCE :- SELECTED_TRACK.INTELLIGENCE; 

SENSOR_DATA.CONTACT :- SELECTED_TRACK.CONTACT; 
end SENSORS; 


195 






...*«***************************************************************** 


—*** procedure ANALYZE_SENSOR_DATA *** 

<»******************************************************************* 

procedure ANALYZE_SENSOR_DATA( 

SENSOR_DATA : in SENSOR_RECORD; 

SENSOR_CONTACT_DATA : out LOCAL_TRACK_INFO ) is 
begin —^ANALYZE_SENSOR_DATA 

SENSOR_CONTACT_DATA SENSOR_DATA.CONTACT; 
end ANALYZE SENSOR DATA; 


—*** procedure PREPARE_SENSOR_TRACK *** 

——* *********&**********•********************************************* 


procedure PREPARE_SENSOR_TRACK( 

SENSOR_CONTACT_DATA : in LOCAL_TRACK_INFO; 
POSITION_DATA : in OWNSHIP_NAVIC5ATION_INFO; 

SENSOR_ADD TRACK : out ADD TRACK TUPLE ) is 


HEAD 

NEW_TRACK 

PI 

RADIANS_PER_DEGREE 
MILES PER DEGREE 


TRACK_TUPLE; 
TRACK_TUPLE; 
constant FLOAT 
constant FLOAT 
constant FLOAT 


3.1415926536; 
PI / 180.0; 
60.0; 


begin —PREPARE_SENSOR_TRACK 
SENSOR_ADD_TRACK.ORIGIN 
HEAD 

NEW_TRACK 
NEW_TRACK.ID 
NEW_TRACK.OBSERVER 
NEW_TRACK.OBSERVATION_TIME 
NEW_TRACK.TRACK_CLASS 
NEW TRACK.IFF CLASS 


- "SENSOR "; 

“ null; 

- new TRACK_RECORD; 

- SENSOR_CONTACT_DATA.ID; 

- SENSOR_CONTACT_DATA.ORIGIN; 

- SENSOR_CONTACT_DATA.THE_TIME; 

« SENSOR_CONTACT_DATA.TRACK_CLASS; 

- SENSOR CONTACT DATA.IFF CLASS; 


NEW_TRACK.LATITUDE POSITION_DATA.LATITUDE + 

(SENSOR_CONTACT_DATA.THE_RANGE * 

COS(RADIANS_PER_DEGREE*SENSOR_CONTACT_DATA.AZIMUTH)) / 
MILES_PER_DEGREE; 

NEW TRACK.LONGITUDE POSITION DATA.LONGITUDE + 


196 

















( SENSOR_CONTACT_DATA.THE_RANGE * 

SIN(RADIANS_PER_DEGREE*SENSOR_CONTACT_DATA.AZIMUTH))/ 

MILES_PER_DEGREE; 

NEW_TRACK.ALTITUDE SENSOR_CONTACT_DATA.THE_RANGE * 

SIN(RADIANS_PER_DEGREE*SENSOR_CONTACT_DATA.ELEVATION); 
NEW_TRACK.COURSE SENSOR_CONTACT_DATA.COURSE; 

NEW_TRACK.VELOCITY SENSOR_CONTACT_DATA.VELOCITY; 

NEW_TRACK.THE_RANGE SENSOR_CONTACT_DATA.THE_RANGE; 

NEW_TRACK.ARCHIVE_FLAG SENSOR_CONTACT_DATA.ARCHIVE_FLAG; 

NEW_TRACK.NEXT HEAD; 

HEAD NEW_TRACK; 

SENSOR_ADD_TRACK.TRACK HEAD; 

end PREPARE SENSOR TRACK; 


— ******* ************************************************************ 

—*** procedure FILTER_SENSOR_TRACKS *** 

— ******************************************************************* 

procedure FILTER_SENSOR_TRACKS< 

SENSOR_ADD_TRACK : in out ADD_TRACK_TUPLE; 

TDD_FILTER : in SET_TRACK_FILTER; 

FILTERED_SENSOR_TRACK : out ADD_TRACK_TUPLE ) is 

HEAD : TRACK_TUPLE SENSOR_ADD_TRACK.TRACK; 

CURRENT : TRACK_TUPLE SENSOR_ADD_TRACK,TRACK; 

PREVIOUS : TRACK_TUPLE null; 

begin —FILTER_SENSOR_TRACKS 
while CURRENT /* null loop 

if (TDD_FILTER.DESIRED_CLASS(CURRENT.TRACK_CLASS)) and 
(TDD_FILTER.DESIRED_RANGE(CURRENT.TRACK_CLASS) >= 

CURRENT.THE_RANGE) then 

PREVIOUS :•= CURRENT; 

CURRENT :« CURRENT.NEXT; 
else 

if PREVIOUS - null then 
HEAD :» CURRENT.NEXT; 
else 

PREVIOUS.NEXT CURRENT.NEXT; 

end if; 

CURRENT CURRENT.NEXT; 


197 







end i£; 
end loop; 

if HEAD - null then 
APPROVED :•> false; 
end if; 

FILTERED_SENSOR_TRACK.TRACK HEAD; 

end FILTER SENSOR TRACKS; 


* 4r Ik ******** 4r *************************************************** A ** * 

—*** procedure ADD_SENSOR_TRACK *** 

__************************«****************************************** 

procedure ADD_SENSOR_TRACK( 

FILTERED_SENSOR_TRACK : in ADD_TRACK_TUPLE; 

TDD_FILTER : in SET_TRACK_FILTER; 

OUT_TRACKS : in out TRACK_TtJPLE ) is 

CURRENT : TRACK_TUPLE; 

NEW_TRACK ; TRACK_TUPLE; 

begin —ADD_SENSOR_TRACK 

CURRENT FILTERED_SENSOR_TRACK.TRACK; 

while CURRENT /- null loop 

NEW_TRACK :» new TRACK_RECORD; 

NEW_TRACK.ALL CURRENT.ALL; 

CURRENT CURRENT.NEXT; 

NEW_TRACK.NEXT null; 

if NUMBER_OF_TRACKS < TDD_FILTER.MAX_NUMBER then 
NUMBER_OF_TRACKS NUMBER_OF_TRACKS + 1; 
else 

DELETE_LAST( TRACKS ); 
end if; 

DELETE_TRACK( TRACKS, NEW_TRACK.ID ); 

PLACE_TRACK( TRACKS, NEW_TRACK ); 
end loop; 

OUT_TRACKS new TRACK_RECORD; 

OUT_TRACKS.ALL TRACKS.ALL; 

end ADD SENSOR TRACK; 


198 










—*** procedure NAVIGATION_SYSTEM *** 

_ ******************************************************************* 

procedure NAVIGATION_SYSTEM( 

POSITION DATA : out OWNSHIP NAVIGATION INFO ) is 


CONSTANT_COURSE 


FLOAT 

0.0; 

CONSTANT_VELOCITY 


FLOAT 

25.0; 

START_LATITUDE 


FLOAT 

35.0; 

START_LONGITUDE 


FLOAT 

125.0 

SECONDS_PASSED 


NATURAL; 


SECONDS_SINCE_MIDNIGHT 


NATURAL; 


MILES PER DEGREE 


constant 

FLOAT 


begin —NAVIGATION_SYSTEM 
SECONDS_SINCE_MIDNIGHT:- 

NATURAL( FLOAT( CALENDAR.SECONDS( CALENDAR.CLOCK ) ) ); 
if START_TIME - 0 then 

START_TIME SECONDS_SINCE_MIDNIGHT; 
end if; 

SECONDS_PASSED :« SECONDS_SINCE_MIDNIGHT - START_TIME; 

POSITION_DATA.COURSE CONSTANT_COURSE; 

POSITION_DATA.VELOCITY CONSTANT_VELOCITY; 

POSITION_DATA.LONGITUDE START_LONGITUDE; 

POSITION_DATA.LATITUDE :» START_LATITUDE + 

({ FLOAT(SECONDS_PASSED)/3600.0) * CONSTANT_VELOCITY)/ 

MILES_PER_DEGREE; 

POSITION_DATA.THE_TIME.HOURS SECONDS_SINCE_MIDNIGHT/3600; 

POSITION_DATA.THE_TIME.MINUTES 

( SECONDS_SINCE_MIDNIGHT mod 3600 )/ 60; 
POSITION_DATA.THE_TIME.SECONDS :« 

(SECONDS_SINCE_MIDNIGHT mod 3600) mod 60; 

end NAVIGATION SYSTEM; 


__* ****************************************************************** 

—*** procedure MONITOR_OWNSHIP_POSITION *** 

_ ******************************************************************* 

procedure MONITOR_OWNSHIP_POSITION( 

POSITION_DATA : in OWNSHIP_NAVIGATION_INFO; 

OUT TRACKS : in out TRACK TUPLE ) is 


199 









OWNSHIP : TRACK TUPLE 


__*******************«********************************************* 

—*** procedure DELETE_OWNSHIP *** 

—.***************************************************************** 

procedure DELETE_OWNSHIP is 

OWNSHIP_IS_FOUND : BOOLEAN false; 

CURRENT : TRACK_TUPLE; 

PREVIOUS : TRACK_TUPLE; 

begin —MONITOR_OWNSHIP_POSITION 
CURRENT TRACKS; 

PREVIOUS null; 

OWNSHIP_IS_FOUND false; 

while CURRENT /- null and not OWNSHIP_IS_FOUND loop 
if CURRENT.ID - 0 then 

OWNSHIP_IS_FOUND true; 

NUMBER_OF_TRACKS NUMBER_OF_TRACKS - 1; 
if PREVIOUS - null then 
TRACKS CURRENT.NEXT; 

else 

PREVIOUS.NEXT CURRENT.NEXT; 

end if; 
else 

PREVIOUS CURRENT; 

CURRENT CURRENT.NEXT; 
end if; 
end loop; 

end DELETE OWNSHIP; 


—**************************************************************«** 

—*** procedure PLACE_OWNSHIP *** 

—******************************************************«:********** 

procedure PLACE_OWNSHIP( 

TRACKS : in out TRACK_TUPLE; 

NEW TRACK : in TRACK TUPLE ) is 


CXmRENT : TRACK_TUPLE TRACKS; 

PREVIOUS : TRACK TUPLE null; 


200 









begin —PLACE_OWNSHIP 
if CURRENT - null then 

—currently, there is no track in TRACKS, so assign it 

—to ownship 

TRACKS NEW_TRACK; 

elsif (CURRENT.TRACK_CLASS > NEW_TRACK.TRACK_CLASS) then 
—ownship's position is before the head of the tracks list 
—according to their track_class in the track_class_type, 

—so add new_track to the head of the TRACKS 
NEW_TRACK.NEXT TRACKS; 

TRACKS NEW_TRACK; 

elsif (CURRENT.TRACK_CLASS <- NEW_TRACK.TRACK_CLASS) then 
—ownship's position is after the head of the tracks list 
—according to their track_class in the track_class_type, 

—so find a suitable position for the ownship, so that it 
—will satisfy the condition, described at the algorithm 
—of the procedure 
while ( CURRENT /« null ) and then 

( CURRENT.TRACK_CLASS < NEW_TRACK.TRACK_CLASS ) loop 
PREVIOUS CURRENT; 

CURRENT CURRENT.NEXT; 

end loop; 

if CURRENT - null then 

PREVIOUS.NEXT NEW_TRACK; 
else 

while ( CURRENT /« null ) and then 

( CURRENT.TRACK_CLASS - NEW_TRACK.TRACK_CLASS ) loop 
if CURRENT.THE_RANGE < NEW_TRACK.THE_RANGE then 
PREVIOUS CURRENT; 

CURRENT CURRENT.NEXT; 
else 
exit; 
end if; 
end loop; 

if CURRENT - null then 

PREVIOUS.NEXT NEW_TRACK; 
elsif PREVIOUS - null then 
NEW_TRACK.NEXT TRACKS; 

TRACKS NEW_TRACK; 
else 

PREVIOUS.NEXT NEW TRACK; 


201 







NEW_TRACK.NEXT CURRENT; 
end if; 
end if; 
end If; 

end PIACE_OWNSHIP; 
begin —^MONITOR_OWNSHIP_POSITION 
DELETE_OWNSHIP; 

OWNSHIP new TRACK_RECORD; 

OWMSHIP.ID 0; 

OWNSHIP.OBSERVER "NVSYSTEM"; 

OWNSHIP.OBSERVATION_TIME POSITION_DATA.THE_TIME; 
OWNSHIP.TRACK_CIASS OWNSHIP_TRACK_CLASS; 

OWNSHIP.IFF_CIiASS OWNSHIP_IFF_CLASS; 

OWNSHIP.LATITUDE POSITION_DATA.LATITUDE; 

OWNSHIP.LONGITUDE POSITION_DATA.LONGITUDE; 

OWNSHIP.COURSE POSITION_DATA.COURSE; 

OWNSHIP.VELOCITY POSITION_DATA.VELOCITY; 

OWNSHIP.ARCHIVE_FLAG C; 

OWNSHIP.NEXT null; 

PLACE_0WNSH1P( TRACKS, OWNSHIP ); 

NUMBER_OF_TRACKS NUMBER_OF_TRACKS + 1; 

OUT_TRACKS new TRACK_RECORD; 

OUT_TRACKS.ALL :- TRACKS.ALL; 

end MONITOR OWNSHIP POSITION; 


—»***********♦**************************************♦***************« 

—*** procedure WEAPONS_SYSTEMS *** 

************* ***** A ********** ***************************** **** * 

procedure WEAPONS_SYSTEMS( 

WEAPON_STATUS_DATA ; out WEAPON_STATUS ) is 

RANDOM_NUMBER : FLOAT; 

begin —WEAPONS_SYSTEMS 

RANDOM_NUMBER RANDOM.NUMBER; 
if RANDOM_NUMBER < 0.001 then 

WEAPON_STATUS_DATA.STATUS DAMAGED; 
elsif RANDOM NUMBER <0.01 then 


202 









WEAPON_STATUS_DATA.STATUS SERV1CE_REQUIRED; 

elsif RANDOM_NUMBER <0.1 then 

WEAPON_STATUS_DATA.STATUS LAUNCHING; 

elsif RANDOM_NUMBER < 0.2 then 

WEAPON_STATUS_DATA.STATUS OUT_OF_AMMUNITION; 
elsif RANDOM_NUMBER < 0.3 then 

WEAPON_STATUS_DATA.STATUS SLEWING; 

elsif RANDOM_NUMBER <0.4 then 

WEAPON_STATUS_DATA.STATUS SECURED; 

elsif RANDOM_NUMBER <0.5 then 

WEAPON_STATUS_DATA.STATUS MAINTANENCE; 
elsif RANDOM_NUMBER <0.55 then 

WEAPON_STATUS_DATA.STATUS ENGAGING; 

elsif RANDOM_NUMBER < 0.6 then 

WEAPON_STATUS_DATA.STATUS RELOADING; 
else 

WEAPON_STATUS_DATA.STATUS READY; 

end if; 

RANDOM_NUMBER RANDOM.NUMBER; 

if RANDOM_NUMBER < 0.25 then WEAPON_STATUS_DATA.SYS^TYPE CIWS 
elsif RANDOM_NUMBER <0.50 then WEAPON_STATUS_DATA.SYS^TYPE GUN; 

elsif RANDOM_NUMBER <0.75 then WEAPON_STATUS_DATA.SYS_TYPE TWS; 

else WEAPON_STATUS_DATA.SYS_TYPE MK48 

end if; 

end WEAPONS SYSTEMS; 


—*** procedure WEAPONS_INTERFACE *** 

__****************************•************************************** 

procedure WEAPONS_INTERFACE( 

WEAPON_STATUS_DATA : in WEAPON_STATUS; 

WEAPONS_EMREP ; out WEAPON_STATUS_REPORT; 

WEAPONS_STATREP : out WEAPON_STATUS_REPORT ) is 

begin —WEAPONS_INTERFACE 

—assign the status to the related weapons states 
if WEAPON_STATUS_DATA.SYS_TYPE « CIWS then 
CIWS_STATUS WEAPON_STATUS_DATA.STATUS; 

elsif WEAPON_STATUS_DATA.SYS_TYPE - GUN then 
GUN_STATUS WEAPON_STATUS_DATA.STATUS; 
elsif WEAPON STATUS DATA.SYS TYPE - TWS then 








TWS_STATUS WEAPON_STATUS_DATA.STATUS; 
else 


MK48_STATUS WEAPON_STATUS_DATA.STATUS; 
end i£; 


—assign the weapons states to the related status report component 


WEAP0NS_STATREP(C1WS) CIWS_STATUS; 

WEAPONS_STATREP(GUN) GUN_STATUS; 

WEAPONS_STATREP(TWS) TWS_STATUS; 

WEAPONS_STATREP(MK48) MK48_STATUS; 

—check wheteher there is an emeregency situation 
if { WEAPON_STATUS_DATA.STATUS - DAMAGED ) or 

( WEAPON_STATUS_DATA.STATUS - SERVICE_REQUIRED ) or 
( WEAPON_STATUS_DATA.STATUS - OUT_OP_AMMUNITION ) then 
—build the emergency weapons status 


WEAPONS_EMREP(CIWS) 
WEAPONS_EMREP(GUN) 
WEAPONS_EMREP(TWS) 
WEAPONS_EMREP(MK48) 
end if; 


CIWS_STATUS; 
GUN_STATUS; 
TWS_STATUS; 
MK48 STATUS; 


end WEAPONS INTERFACE; 


******************************************************************** 

—*** procedure MAKE_ROUTING *** 

******************************************************************** 

procedure MAKE_ROUTING( 

TCD_TRANSMIT_COMMAND : in TRANSMIT_COMMAND; 

TCD_NETWORK_SETUP : in NETWORK_SETUP; 

TRANSMISSION MESSAGE : in out TRANSMISSION COMMAND ) is 


ADDRESS_FOUND_IN_NETWORK_SETUP 
TRANSMlT_CURRENT 
NETWORK_CURRENT 
TRANSM1SSI0N_I,INK 
NEW ADDRESS 


BOOLEAN false; 
ADDRESS_LINK; 
ADDRESS_LINK; 
LINKS_TYPE; 
ADDRESS LINK; 


begin —MAKE_ROUTING 

for TRANSMIT_LINK in LINKS_TYPE loop 

—search through all array conq^onents of the TCD_TRANSMIT_COMMAND 

if TCD_TRANSMIT_COMMAND(TRANSMIT_LINK).FULL 

and not TCD TRANSMIT COMMAND(TRANSMIT LINK).ROUTED then 


204 












—there is a file in the current con^onent of 
—TCD_TRANSMIT_COMMAND, and it needs to be routed 
—first, process the ADDRESS field 
TRANSMIT_CURRENT 

TCD_TRANSMIT_COMMAND(TRANSMIT_LINK).TEXT.HEADER.ADDRESS; 
while TRANSMIT_CURRENT /- null loop 

—search through TCD_TRANSMIT_COMMAND to find the 
TRANSMISSION_LINK JTIDS; 

ADDRESS_FOUND_IN_NETWORK_SETUP false; 
while not ADDRESS_FOUND_IN_NETWORK_SETUP loop 

NETWORK_CURRENT TCD_NETWORK_SETUP(TRANSMISSION_LINK); 
while NETWORK_CURRENT /- null and 

not ADDRESS_FOUND_IN_NETWORK_SETUP loop 
if NETWORK_CURRENT.NAME « TRANSM1T_CURRENT.NAME then 
ADDRESS_FOUND_IN_NETWORK_SETUP true; 

NEW_ADDRESS new ADDRESS_TyPE; 

NEW_ADDRESS.NAME TRANSMIT_CURRENT.NAME; 

NEW_ADDRESS.NEXT 

TRANSMISSION_MESSAGE{TRANSMISSION_I.INK).ROUTE_ADDR; 
TRANSMISSION_MESSAGE(TRANSMISSION_LINK),ROUTE_ADDR 

NEW_ADDRESS; 

TRANSMISS10N_MESSAGE(TRANSMISSI0N_LINK).FULL true; 
TRANSMISS10N_MESSAGE{TRANSMISSI0N_L1NK).TEXT :- 

TCD_TRANSMIT_COMMAND(TRANSM1T_L1NK).TEXT; 

end if; 

NETWORK_CURRENT NETWORK_CURRENT.NEXT; 
end loop; 

if TRANSMISSION_LINK - OTCIXS then 
exit; 
else 

TRANSMISSION_LINK LINKS_TYPE'SUCC(TRANSMISSION_LINK); 
end if; 
end loop; 

TRANSMIT_CURRENT TRANSMIT_CURRENT.NEXT; 
end loop; 

—second, process the INFO field 
TRANSMIT_CURRENT 

TCD_TRANSMIT_COMMAND(TRANSMIT_LINK).TEXT.HEADER.INFO; 
while TRANSM1T_CURRENT /- null loop 

—search through TCD_TRANSMIT_COMMAND to find the 
TRANSMISSION LINK JTIDS; 


205 








—initialize the boolean value again 
ADDRESS_F0UND_1N_NETW0RK_SETUP false; 
while not ADDRESS_FOUND_IN_NETWORK_SETUP loop 

NETWORK_CURRENT TCD_NETWORK_SETUP(TRANSM1SSI0N_LINK); 
while NETWORK_CURRENT /- null and 

not ADDRESS_FOUND_IN_NETWORK_SETUP loop 
if NETWORK__CURRENT.NAME - TRANSMIT_CURRENT.NAME then 
ADDRESS_FOUND_IN_NETWORK_SETUP true; 

—address is found, so add the file and other necessary 
—information to the related LINK component of 
—TRANSMISSION_MESSAGE where the address is staying 
NEW_ADDRESS new ADDRESS_TYPE; 

NEW_ADDRESS,NAME TRANSMIT_CURRENT.NAME; 

NEW_ADDRESS.NEXT 

TRANSMISSION_MESSAGE <TRANSMISSION_LINK).ROUTE_ADDR; 
TRANSMISSION_MESSAGE(TRANSMISSION_LINK).ROUTE_ADDR :- 

NEW_ADDRESS; 

TRANSMISSION_ME S SAGE(TRANSMISSION_LINK) .FULL :- t rue; 
TRANSMISSION_MESSAGE{TRANSMISSION_LINK).TEXT 

TCD_TRANSMIT_COMMAND(TRANSMIT_LINK).TEXT; 

end if; 

—move forward in the NETWORK_SETUP 
NETWORK_CURRENT NETWORK_CURRENT.NEXT; 
end loop; 

if TRANSMISSION_LINK - OTCIXS then 

—we traversed the whole TRANSMISSION_MESSAGE, so 
—exit from the loop 
exit; 
else 

—there is still remaining component in 
—TRANSMISSION_ME S SAGE, 

TRANSMISSION_LINK LINKS_TyPE'SUCC(TRANSMISSION_LINK); 
end if; 
end loop; 

TRANSMIT_CURRENT TRANSMIT_CURRENT.NEXT; 

end loop; 
end if; 
end loop; 
end MAKE ROUTING; 


206 








—*** procedure FORWARD_FOR_TRANSMISSION *** 

„*******************************«*********************************** 

procedure FORWARD_FOR_TRANSMISSION( 

TRANSMISSIONJMESSAGE : in TRANSMISSION_COMMAND; 

TCD_EMISSION_CONTROI. : in EMISSIONS_CONTROL_COMMAND 

OUTPUT_MESSAGES : in out MESSAGE_LIST ) is 

LINK : LINKS_TYPE JTIDS; 

NEW_MESSAGE : MESSAGE_LIST; 

begin —FORWARD_FOR_TRANSMISSION 
for I in LINKS_TYPE loop 

if TRANSMISSION_MESSAGE(I).FULL then 

NEW_MESSAGE :« new MESSAGE_RECORD; 

NEW_MESSAGE.LINK_ID I; 

NEW_MESSAGE.MAIN :- TRANSMISSION_MESSAGE(I); 

NEW_MESSAGE.NEXT WAITING_MESSAGES; 

WAITING_MESSAGES NEWJMESSAGE; 

end if; 
end loop; 

if TCD_EMISSION_CONTROL - UNRESTRICTED then 
OUTPUT_MESSAGES new MESSAGE_RECORD; 

OUTPUT_MESSAGES.ALL WAITING_MESSAGES.ALL; 

WAITING_MESSAGES null; 

end if; 

end FORWARD FOR TRANSMISSION; 


—_*************«*****•***************************•******************* 

—*** procedure CONVERT_TO_TEXT_FILE *** 

—******************************************************************* 
procedure CONVERT_TO_TEXT_FILE 

( OUTPUT_MESSAGES : in MESSAGE_LIST ) is 

package P_CLASS_IO is new ENUMERATION_IO( PRECEDENCE_CLASS ); 
use P_CLASS_IO; 

package S_CLASS_IO is new ENUMERATION_IO( SECURITY__CLASS ); 
use S_CLASS_IO; 

package LINKS_IO is new ENUMERATION_IO( LINKS_TYPE ); 
use LINKS 10; 


207 










CURRENT_MESSAGE 

FILE 

ADORESS_HEAD 
VIA_HEAD 
FILE NAME 


MESSAGE_LIST OUTPUT_MESSAGES; 
FILE_TYPE; 

ADDRESS_LIKK; 

VIA_RECORD_LINK; 

STRING(1..17) " 


begin ~CONVERT_TO_TEXT_FILE 

while CURRENT_MESSAGE /- null loop 

—there is still at least one message to convert to text file 
—first, prepare the file name, the resultant file name 
—should have the form 

—"CURRENT_MESSAGE.LINK_ID £ CURRENT_MESSAGE.MAIN.TEXT.NAME" 
if CURRENT_MESSAGE.LINK_ID - JTIDS then 
FILE_NAME(1..6) "JTIDS."; 

FILE_NAME(7..16) :- CURRENT_MESSAGE.MAIN.TEXT.NAME; 
elsif CURRENT_MESSAGE.LINK_ID - LINKll then 
FILE_NAME(1.,7) "LINKll."; 

FILE_NAME(8,.17) :- CURRENT_MESSAGE.MAIN.TEXT.NAME; 
elsif CURRENT_MESSAGE.LINK_ID - LINK16 then 
F1LE_NAME(1.,7) :-"LINK16."; 

FILE_NAME(8..17) :- CURRENT_MESSAGE.MAIN.TEXT.NAME; 
else 

FILE_NAME(1..7) :- "OTCIXS."; 

FILE_NAME(8..17) :- CURRENT_MESSAGE.MAIN.TEXT.NAME; 
end if; 

—open the file to be filled in, and set the line length 
CREATE( FILE, NAME -> FILE_NAME ); 

SET_LINE_LENGTH( FILE, 80 ); 

—print FILENAME info 
PUT ( FILE,"NAME : " ); 

PUT( FILE, CURRENT_MESSAGE.MAIN.TEXT.NAME ); NEW_LINE( FILE ); 

—print LINK_ID info 

PUT( FILE, "LINK ID : " ) ; 

PUT( FILE, CURRENT_MESSAGE.LINK_ID ); NEW_LINE( FILE ); 

—print ROUTE info 
PUT( FILE, "ROUTE : "); 

ADDRESS_HEAD CURRENT_MESSAGE.MAIN.ROUTE_ADDR; 
while ADDRESS_HEAD /- null loop 
PUT{ FILE, fX)DRESS_HEAO,NAME ); 

PUT( FILE, ", " ); 

NEW LINE( FILE ) ; 


208 











PUT( FILE, " "); 

ADDRESS_HEAD ADORESS_HEAD.NEXT; 

end loop; 

NEW_LINE{ FILE ); 

—print CLASSIFICATION info 
PUT{ FILE, "CLASSIFICATION : "); 

PUT{ FILE, CURRENT_MESSAGE.MAIN.TEXT.HEADER.CLASSIFICATION ) 
—print PRESEDENCE info 
PUT( FILE, " PRECEDENCE : " 

PUT( FILE, CURRENT_MESSAGE.MA1N.TEXT.HEADER.PRECEDENCE ); 
NEW_LINE( FILE ); 

—print origin(FM) info 
PUT( FILE, "FM : " ); 

PUT( FILE, CURRENT_MESSAGE.MAIN.TEXT.HEADER.ORIGIN ); 
NEW_LINE( FILE ); 

—print address(TO) info 
PUT( FILE, "TO : " ); 

ADDRESS_HEAD CURRENT_MESSAGE.MAIN.TEXT.HEADER.ADDRESS; 

while ADDRESS_HEAD /- null loop 
PUT( FILE, ADDRESS_HEAD.NAME ); 

PUT( FILE, ", " ); 

NEW_LINE( FILE ); 

SET_COL( FILE, 6 ); 

ADDRESS_HEAD ADDRESS_HEAD.NEXT; 
end loop; 

NEW_LINE( FILE ) ; 

—print INFO info 
PUT( FILE, "INFO : " ); 

ADDRESS_HEAD :- CURRENT_MESSAGE.MAIN.TEXT.HEADER.INFO; 
while ADDRESS_HEAD /- null loop 
PUT( FILE, ADORESS_HEAD.NAME ); 

PUT( FILE, ", " ); 

NEW_LINE( FILE ); 

SET_COL( FILE, 8 ); 

ADDRESS_HEAD ADORESS_HEAD.NEXT; 

end loop; 

NEW_LINE( FILE ); 

—print VIA info 
PUT{ FILE, "VIA : " ); 

VIA_HEAD CURRENT_MESSAGE.MAIN.TEXT.HEADER.VIA_LINE; 
while VIA_HEAD /« null loop 


209 









ADDRESS_HEAD VIA_HEAD.RELAy_TO; 

while ADDRESS_HEAD /- null loop 
PUT( FILE, ADDRESS_HEAD.NAME ); 

PUT( FILE, ", "); 

NEW_LINE( FILE ); 

SET_COL( FILE, 7 ); 

ADDRESS_HEAD ADDRESS_HEAD.NEXT; 
end loop; 

PUT( FILE, "BY " ) ; 

PUT( FILE, VIA_HEAD.RELAY_BY ); NEW_LINE( FILE ); 
PUT{ FILE, " " 

VIA_HEAD VIA_HEAD.NEXT; 
end loop; 

NEW_LINE( FILE ); 

—print SUBJECT info 
PUT( FILE, "SUBJECT : " ); 

PUT( FILE, CURRENT_MESSAGE.MAIN.TEXT.HEADER.SUBJECT ); 
NEW_LINE( FILE, 4 ); 

—print body(TEXT) of the message 

PUT( FILE, CURRENT_MESSAGE.MAIN.TEXT.TEXT ); 

NEW_LINE( FILE ); 

—close the file 
CLOSE( FILE ); 

—Do everyting for the all of the messages in the list 
CXJRRENT_MESSAGE CURRENT_MESSAGE.NEXT; 
end loop; 

end CONVERT TO TEXT FILE; 


—*** procedure MESSAGE_EDITOR *** 

__«*****************«*******««***********•*********•**************'*** 

procedure MESSAGE_EDITOR( 

EDITOR_SELECTED : in BOOLEAN; 

TCD_TRANSMIT_COMMAND : out TRANSMIT_COMMAND ) is 
begin —MESSAGE__EDITOR 

TCD_TRANSMIT_COMMAND NEW_TRANSMIT_COMMAND; 
end MESSAGE EDITOR; 


210 
















—*** procedure DISPIiAY_TRACKS *** 

__*************** It*** ****************************************** **** * 

procedure display_tracks( 

out_tracJca : in track_tuple; 

td_track_request : in database_request ) is 

current : track_tuple :■ out_tracks; —track to be displayed 

—item id's of the related panels 


id_id 

string(1..5) 

- "id_00"; 

observer_id 

stringd. .11) 

- "observer_00"; 

time_id 

string(1..7) 

— "time_00"; 

track_class_id 

string(1..14) 

« "track_class_00"; 

iff_claas_id 

string(1..12) 

- "iff_class_00"; 

latitude_id 

string(1..11) 

“ "latitude_00"; 

longitude_id 

string(1..12) 

- "Iongitude_00"; 

altitude_id 

stringd. .11) 

“ "altitude_00"; 

course_id 

stringd. .9) 

« "course_00"; 

velocity_id 

stringd. .11) 

« "velocity_00"; 

range_id 

string(1..8) 

- "range_00"; 

—row of related track 

postfix : string(1..2) 

It 

3 

O 

O 

3 


—string correspondence of time 
time_string : string(1..8) :« "00:00:00"; 


—*** Function CHARACTER_OF *** 

_ ***************************************************************** 

function CHARACTER_OF( N : in NATURAL ) return CHARACTER is 
begin 

return( CHARACTER'VAL( N + 48 ) ); 
end CHARACTER OF; 


211 















-*** procedure display_ownship *** 

—******************************************************************* 

procedure display_ownship( current: in traclc_tuple ) is 

tiine_string : string(1..8) :* "00:00:00"; 

—string correspondence of tinffi 

begin —display_ownship 

if current.observation_time.hours > 9 then 
tinve_string(l) 

character_of( current.observation_tijne.hours/10 ); 
tiine_string(2) 

character_of( current.observation_time.hours mod 10 ); 

else 

time_string(2) 

character_of( current.observation_time.hours ); 

end if; 

if current.observation_time.minutes > 9 then 
time_string(4) 

character_of( current.observation_time.minutes/10 ); 
time_string(5) :■ 

character_of ( curr*>nt.observation_time.minutes mod 10 ); 

else 

time_string (5) 

character_of( current.observation_time.minutes ); 

end if; 

if current.observation_time.seconds > 9 then 
time_string(7) 

character__of( current.observation_time.seconds/10 ); 
time_string(8) 

character_of( current.observation_time.seconds mod 10 ); 

else 

time_3tring(8) 

character_of( current.observation_time.seconds ); 

end if; 

Wpt_SetString(display__info.panel_id, "time_00", time_string); 


212 





Wpt_SetReal(display_info.panel_id, "latitude_00", 

taefloat(float(integer(current.latitude*!0.0))/lO.O)); 

Wpt_SetReal(di5play_info.panel_id, "longitude_00", 

taefloat(float(integer(current.longitude*10.0))/lO.O)); 

Wpt_SetReal(display_info.panel_id, "course_00", 

taefloat(float(integer(current.course*10.0))/lO.O)); 

Wpt_SetReal(display_info.panel_id, "velocity_00", 

taefloat(float(integer(current.velocity*10.0))/lO.O)); 

end display_ownship; 


—*** function satiafies_database_request *** 

— _************************************************ ***************** 

function satisfies_database_request( 

track : in track_tuple; 

td_track_request ; in database_request ) return boolean is 

begin —satisfies_databa8e_req[uest 

if (td_track_request.track_cla3s(track.track_cla5s)) and 
(td_track_request.iff_cla3s(track.iff_class) ) and 
(td_track_request.the_range >- track.the_range ) then 
return ( true ); 
else 

return ( false ); 
end if; 

end satisfies_database_request; 


begin —display_tracks 

if track_display_panel_is_displayed then 
while current /- null loop 

—there is another track to be displayed 
—check if current is the ownship 
if current.id ■ 0 then 

display_ownship( current ); 
elsif 


213 








satls£ies_database_request( current, td_trac)c_request ) then 
--find the current track's display row 
if current.id > 9 then 

postfix(1) character_of{ current.id/10 ); 

postfix(2) :>■ character_of ( (current.id mod 10) ); 

else 

postfix(1) 'O'; 

postfix(2) character_of( current.id ); 

end if; 


—assign the postfixes of the panel id's and get the 
—panel specifications 


id_id(4..5) 
observer_id(10..11) 
tiroe_id{6..7) 
track_cla3S_id(13..14) 
iff_class_id(ll..12) 
latitude_id(10..11) 
longitude_id(ll..12) 
altitude_id{10..11) 
course_id(8..9) 
velocity_id(10..11) 
range_id{7..8) 


postfix; 

postfix; 

postfix; 

postfix; 

postfix; 

postfix; 

postfix; 

postfix; 

postfix; 

postfix; 

postfix; 


--print out the track information into the related row of 
—the panel 

Wpt_SetIntg(display_info.panel_id, id_id,taeint(current.id)); 
Wpt_SetString( 

display_info.panel_id, observer_id, current.observer ); 

if current.observation_time.hours > 9 then 
time_string(l) 

character_of(current.observation_time.hours/10 ) 
time_3tring(2) 

character_of(current.observation_time.hours mod 10 ); 

else 

time_string(1) :« 'O'; 
time_string(2) :*■ 

character_of(current.observation_time.hours ); 

end if; 


214 










if current.observation_tiroe.minutes > 9 then 
time_string(4) 

character_of(current.observation_tiine.minutes/10 ); 
time_string(5) :■ 

character_of(current.observation_time.minutes mod 10 ); 

else 

time_string(4) 'O'; 

time_string(5) 

character_of(current.observation_time. minutes ); 

end if; 

if current.observation_time.seconds > 9 then 
time_string(7) 

character_of(current.observation_time.seconds/10 ); 
time_string(8) 

character_of(current.observation_time.seconds mod 10 ); 

else 

time_string(7) 'O'; 

time_3tring(8) :« 

character_of(current.observation_time.seconds ); 

end if; 


Wpt_SetString( display_info.panel_id, time_id, time_string ); 


if current.track_class ■ AIR then 

Wpt_SetString( display_info.panel_id, track_cla3S__id, "AA"); 
elsif current.track_class » SURFACE then 

Wpt_SetString( display_info.panel_id, track_class_id, "SU"); 
else—current.track_class “ SUBSURFACE 

Wpt_SetString( display_info.panel_id, track_class_id, "SS"); 
end if; 


if current.iff_class ■ FRIENDLY then 

Wpt_SetString( display_info.panel_id, 
elsif current.iff_class - HOSTILE then 
Wpt_SetString( display_in£o.panel_id, 
elsif current.iff_class * NEUTRAL then 
Wpt_SetString( display_info.panel_id, 
else—current.iff_class « UNKNOWN 

Wpt_SetString( display_info.panel_id, 
end if; 


if f_class_id, 
iff_class_id, 
if f_class_id, 
if f_class_id. 


"F") ; 

"H") ; 

"N") ; 
"U") ; 


215 




if current.Id > 10 then 

—truncate the extra zeros because of the limitations 
—of the tae 

Wpt_SetReal(diaplay_info.panel_id, latitude_id, 

taefloat(float(integer(current.latitude*10.0))/10.0)); 
Wpt_SetReal(diaplay_info.panel_id, longitude_id, 

taefloat(float(integer(current.longitude*10.0))/lO.0)); 
Wpt_SetReal(display_info.panel_id, altitude_id, 

taefloat(float(integer(current.altitude*!0.0))/lO.0)); 
Hpt_SetReal(display_info.panel_id, course_id, 

taefloat(float(integer(current.course*10.0))/lO.0)); 
Wpt_SetReal(display_info.panel_id, velocity_id, 

taefloat(float(integer(current.velocity*10.0))/10.0)); 
Wpt_SetReal(diaplay_info.panel_id, range_id, 

taefloat(float(integer(current.the_range*l00.0))/100.0)) 

else —current.id <- 10 

—no truncation is required 

Wpt_SetReal(display_info.panel_id, latitude_id, 
taefloat(current.latitude)); 

Wpt_SetReal(display_info.panel_id,longitude_id, 
taefloat(current.longitude)); 
wpt_SetReal(display_info.panel_id,altitude_id, 
taefloat(current.altitude)); 

Wpt_SetReal(display_info.panel_id,course_id, 
taefloat(current.course)); 

Wpt_SetReal(di3play_info.panel_id,velocity_id, 
taefloat(current.velocity)); 

Wpt_SetReal(di3play_info.panel_id,range_id, 
taefloat(current.the_range)); 

end if; 
end if; 

current :■ current.next; 
end loop; 

end if;—track_di3play_panel_is_displayed 
end display_trac)c8; 


216 









—*** procedure GET_USER_1NPUTS *** 

—_**************************************«**************************** 


procedure get_user_inputs( 

tdd_archive_aetup 

tdd_filter 

td_t rack_request 

tcd_status_query 

t cd_net wo r )c_set up 

tcd_emission_control 

editor_selected 

inltiate_tran3 

terminate trans 


; out archive_setup; 

: out set_track_filter; 

: out database_request; 

: out boolean; 

: out networlc_setup; 

: out einissions_control_coinmand; 

: out boolean; 

: out initiate_transmission_8equence 
: out boolean ) is 


begin —get_inputs; 
tdd_a rchive_set up 
tdd_filter 
td_track_request 
tcd_status_query 
tcd_emission_control 
tcd_network_setup 
editor_selected 
initiate_trans 
terminate_tran8 
new_editor_selected 
end get_user_inputs; 


■ new_archive_setup; 

- new_track_filter; 

" new_track_request; 

“ new_status_query; 

- new_emission_control; 

- new_network_setup; 

« new_editor_selected; 

* new_initiate_trans; 

- new_terminate_trans; 

- false; 


******************************************************************** 

—*** procedure GET_DISPLAY_VALUES *** 

****************************************************************** 

procedure get_display_value3( 

weapons_statrep : in weapon_status_report; 
weapon : in weapons_type; 

display_item_id : out string; 
status : out string ) is 

begin —get_di3play_value3 


if weapon * CIWS then di3play_item_id :■ "ciws" 
elsif weapon ■ GUN then display_item_id :■ "gun " 
elsif weapon ■ TWS then di3play_item_id "tws " 


217 










elslf weapon •• MK48 then diaplay_item_id ;■ "ink48"; 

end if; 

if weapons_statrep(weapon) > DAMAGED then 

status "DAMAGED 

elsif weapons_statrep(weapon) > RELOADING then 

status "RELOADING 

elsif weapons_statrep(weapon) - LAUNCHING then 

status "LAUNCHING 

elsif weapons_statrep(weapon) - READY then 

status "READY 

elsif weapons_statrep(weapon) - SERVICE_REQUIRED then 

status "SERVICE_REQUIRED "; 

elsif weapons_statrep(weapon) - SLEWING then 

status "SLEWING 

elsif weapons_statrep(weapon) - SECURED then 

status "SECURED 

elsif weapons_statrep(weapon) > MAINTANENCE then 

status "MAINTANENCE 

elsif weapons_statrep(weapon) -> ENGAGING then 

status "ENGAGING 

elsif weapons^statrep(weapon) - OUT_OF_AMMUNITION then 
status "0UT_0F_AMMUN1T10N"; 

end if; 

end get_display__values; 


__*«******************************************** 1 ^******************** 

—*** procedure STATUS_SCREEN *** 

—_*****«************•************************************************ 

procedure status_screen( 

weapons_statrep : in out weapon_status_report; 
tcd_atatus_query : in boolean ) is 

display_item_id : string(1..4); 
status : string(1..17); 

begin —status_screen 

Wpt_NewPanel ("", weapon_info.target, weapon_info.view, 

XJWindows.Null_Window, weapon_info, WPT_DEFAULT, 
weapon_info.panel_id); 


218 















for weapon in HEAPONS_TYPE loop 
get_display_values( 

weapons_statrep, weapon, clisplay_iteni_id, status ); 
Wpt_SetString( weapon_info.panel_id, display_iteni_id, status ); 
end loop; 

new_status_query :■ false; 
weapon_status_panel_is_displayed true; 
end status screen; 


—**************************************************•**************** 

—*** procedure E»!ERGENCY_STATUS_SCREEN *** 

__******************************************************************* 

procedure en»ergency_status_screen ( 

weapons_emrep : in out weapon_status_report ) is 

display_item_id : string(1..4); 
status : string(1..17); 

begin —emergency_status_screen 

if not einergency_weapon_status__panel_is_displayed then 
Wpt_NewPanel emerg_info.target, emerg_info.view, 

X_Windows.Null_Window, enverg_info, WPT_DEFAULT, 
emerg_info.panel_id); 
for weapon in WEAPONS_TYPE loop 
get_display_values( 

weapons_enirep, weapon, display_item_id, status ); 
Wpt_SetString( emerg_info.panel_id, display_item_id, status ); 
end loop; 

envergency_weapon_status_panel_is_displayed true; 
end if; 

end emergency_status_screen; 


— * ****************************************************************** 

—*** procedure MESSCAME_DISPLAy *** 

_ ******************************************************************* 

procedure messcaine_display ( file_nanve : in filenanve ) is 
incoming_file : text_io.file_typ€; 


219 

















display_£ile : text_io.file_type; 
lln« : string(1..80); 

length : natural; 

begin —inesscaine_display 

-“Open the inconiing_file to be displayed 

open( incoming_£ile, name ■•> £ile_naine, mode ■•> in_£lle ); 

—create diaplay_£ile, because tae uses a £ilename which is 
—entered in creation o£ tae_source_£ile process 
create ( display_£ile, name -> "DISPLAY_F1LE"); 

—copy content o£ the incoming_file to display_£ile 
while not end_of_file( incoming_£ile ) loop 
get_llne( incoming_£lle, line, length ); 
put_line( diaplay_£ile, lined, .length) ); 
end loop; 

close( display_£ile ); 

Wpt_NewPanel messdisp_in£o.target, messdisp_info.view, 

X_Windowa.Null_Window, messdisp_in£o, WPT_DEFAULT, 
messdisp_in£o.panel_id); 

loop 

Wpt_NextEvent (wptEvent, etype); 

case etype is 

when Wpt_PARM_EVENT -> 

Wpt_Extract_Context (wptEvent, U3er_ptr); 

Wpt_Extract_Pann (wptEvent,user_ptr.parm_name); 
Wpt_Extract_Data (wptEvent,user_ptr.datavm__ptr); 

Vm_Find ( 

use r_pt r.datavm_pt r,user_pt r.pa rm_name,user_pt r.pa rm_pt r) 

if s_equal ("save", user_ptr.parm_naine) then 
close( incoming_file ); 


220 






Hpt_PanelErase(messdisp_in£o.panel_id); 
exit; 

elsif s_equal ("delete", user_ptr.pann_name) then 
delete( incoming_£ile ); 

Wpt_PanelErase (ine3sdisp_ln£o.panel_id); 
exit; 
else 

put_llne("Enter data to MESSAGE PANEL Only"); 
end i£; 

when Wpt_WINDOW_EVENT -> 
null; 

when OTHERS -> 

put("ERROR: Unexpected Hpt_NextEvent. "); 

end case; 

end loop; 

exception 

when NAME_ERROR -> 
begin 

put(£ile_name); put_line(" DOES NOT EXIST !!!"); 
end; 

end ntesscaine_display; 


—*** procedure NEW_NAME 

.—****•***«********************************************************** 
£unction new_nanve ( £ile_name : in tilename ) return £ilenante is 

new_£ile_name : tilename; 

begin —new_name 

for I in 1..10 loop 

i£ file_nanie( I ) ' then 

new £ile name( I ) £ile name( I ); 


221 










elae 
exit; 
end if; 
end loop; 

return ( new_£ile_neuive ); 
end new name; 


——************************************«****************************** 

—*** procedure MESSAGE_ARRIVAL_PAtIEL *** 

„******************************************************************* 

procedure mes3age_arrival_panel( coinms_email : in filename ) is 
begin —message_arrival_panel 

Wpt_NewPanel messcame_info.target, mes5came_info.view, 

X_Windowa.Null_Window, mesacame_info, Wpt_DEFAULT, 
messcame_info.panel_id); 

Wpt_SetString{ came_info.panel_id, "filename", comms_email ); 

loop 

Wpt_NextEvent (wptEvent, etype); 

case etype is 

when Wpt_PARM_EVENT -> 

Wpt_Extract_Context (wptEvent, userjptr); 

Wpt_Extract_Parm (wptEvent,U3er_ptr.parm_name); 
Wpt_Extract_Data (wptEvent,user_ptr.datavm_ptr); 

Vm_Find ( 

user_ptr.datavm_ptr,userjptr.pa nn_name,user_ptr.parmjptr); 
if s_equal ("display", user_ptr.parm_name) then 
Wpt_PanelErase(messcaroe_info.panel_id); 
messcame_display (comms^email); —display the message 

exit ; 

elsif s_equal ("cancel", user_ptr.parm_name) then 
Wpt_PanelErase (niesscame_info.panel_id); 
exit; 


222 





else 

put_line("Enter data to MESSAGE ARRIVAL PANEL Only"); 
end i£; 

when Wpt_WINDOW_EVENT -> 
null; 

when OTHERS -> 

put("ERROR: Unexpected Wpt_NextEvent. "); 
end case; 
end loop; 

end message_arrival_panel; 


—**********************************«******************************** 

—*** procedure MESSAGE_RETRIEVAL_PANEL *** 

_—******************************************«************************ 

procedure message_retrieval_panel is 

£ile_name : filename; 
count : taeint; 

value ; array (1..1) of string (1..tae_taeconf.STRINGSIZE); 

filename_is_entered : boolean false; 

begin —message_retrieval_panel 

Wpt_NewPanel ("", messret_info.target, messret_info.view, 

X_Windows.Null_Window, messret_info, Wpt_DEFAULT, 
messret_info.panel_id); 
loop 

Wpt_NextEvent (wptEvent, etype); 
case etype is 


when Wpt_PARM_EVENT -> 

Wpt_Extract_Context (wptEvent, user_ptr); 
Wpt_Extract_Pann (wptEvent,user_ptr.parm_name); 
Wpt_Extract_Data (wptEvent,user_ptr.datavm__ptr); 
Vm Find ( 


223 










user_j>tr. datavin_ptr, user_ptr. pann_nanie, U3er_ptr. pann_ptr) ; 

if s_equal ("filename", user_ptr.parm_naroe) then 
—Vm_Extract_Count {info.pann_ptr, count); 

—if count <" 0 then 

Vm_Extract_SVAL (U3er_ptr.parm__ptr, 1, value (1)); 
file_naine new_name (value (1) (1.. 10)); 
filename_i3_entered true; 
el3if 3_equal ("diaplay", U3er_ptr.parm_name) then 
if filename_is_entered “ true then 

Wpt_PanelRe3et (ine33ret_Info.Panel_id); 

Wpt_PanelEra3e(me33ret_info.panel_id); 
me33came_di3play (file_name); 
exit; 
elae 

Wpt_ParmReject( messret_info.panel_id, u3er_ptr.parm_name, 
"Filename should be Entered"); 
end if; 

elsif s_equal ("cancel", user_ptr.parm_name) then 
Wpt__PanelRe3et (me33ret_Info.Panel_id); 

Wpt__PanelEra3e(me33ret_info.panel_id); 
exit; 
else 

put_line("Enter data to MESSAGE RETRIEVAL PANEL Only"); 
end if; 

when Wpt_WINDOW_EVENT -> 
null; 

when OTHERS -> 

put("ERROR: Unexpected Wpt_NextEvent. "); 
end case; 

end loop; 

end message_retrieval_panel; 


—*** procedure INITIALIZEPANELS *** 

—*****************«'•************************************************ 

procedure initializepanels( file : in string ) is 


224 













tn 5 >_info : event_context_ptr; 
begin —initializePanels 

f_force_lower (false); — pe:,.nit upper/lowercase file nanves 

Wpt_Init ("",theDisplay); 

Wpt_NewEvent (wptEvent); 

tinp_info new event_context; 

Co_New (0, tit^_info.collection); 

Co_ReadFile (tn^_info.collection, file, P_CONT); 

— pair of Co_Finda for each panel in this resource file 

main_info :• new event_context; 
main_info.collection tnp_info.collection; 

Co Find (main_info.collection, "inain_v", main_info.view); 

Co_Find (main_info.collection, "main_t", main_info.target); 

filter_info :» new event_context; 
filter_info.collection tmp_info.collection; 

Co_Find (filter_info.collection, "filter_v", filter_info.view); 
Co_Find (filter_info.collection, "filter_t", filter_info.target); 

archive_info new event_context; 

archive_info.collection tmp_info.collection; 

Co_Find (archive_info.collection, "archive_v”, archive_info.view); 
Co_Find (archive_info.collection, "archive_t", archive_info.target) 

contrnts_info new event_context; 
contrnts_info.collection :« tmp_info.collection; 

Co_Find (contrnts_info.collection, "contrnts_v", 
contrnts_info.view); 

Co_Find (contrnts_info.collection, "contrnts_t", 
contrnts_info.target); 

display_info new event_context; 

display_info.collection tmp_info.collection; 

Co_Find (display_info.collection, "display_v", display_info.view); 
(3o_Find (di3play_info.collection, "display_t", display_info.target) 


225 






weapon_info new event_context; 
weapon_in£o.collection tn^_in£o.collection; 

Co_Find (weapon_info.collection, "weapon_v", weapon_info.view); 
Co_Fincl (weapon_info.collection, "weapon_t", weapon_info.target); 

enverg_info :■ new event_context; 
en»erg_info.collection tnp_info.collection; 

Co_Find (einerg_info.collection, "eme:g_v", einerg_info.view) ; 
Co_Find (einerg_info.collection, "emerg_t", einerg_info.target); 

network_info :■« new event_context; 
network_info.collection :■ tiip_info.collection; 

Co_Find (network_in£o.collection, "network_v", network_in£o.view); 
Co_Find (network_in£o.collection, "network_t", network_in£o.target) 

emcon_in£o new event_context; 
emcon_in£o.collection tinp_in£o.collection; 

Co_Find (emcon_in£o.collection, "emcon_v", emcon_in£o.view); 
Co_Find (emcon_in£o,collection, "eincon_t", eincon_in£o. target); 

editor_in£o new event_context; 
editor_in£o.collection tmp_in£o.collection; 

Co_Find (editor_in£o.collection, "editor_v", editor_in'£o.view) ; 
Co_Find (editor_in£o.collection, "editor_t", editor_in£o.target); 

messcame_info new event_context; 

messcame_in£o.collection ;■ tmp_in£o.collection; 

Co_Find (ine33came_in£o.collection, "messcame_v", 
me33came_info.view); 

Co_Find (nie33can»e_in£o.collection, "inesscaine_t", 
inesscanie_in£o.target); 

me33di3p_in£o new event_context; 

ine33di3p_in£o.collection tinp_in£o.collection; 

Co_Find (messdisp_in£o.collection, "niessdisp_v", 
nie33di3p_in£o.view) ; 

Co_Find (nie33di3p_info.collection, "me3sdisp_t", 
ine3sdisp_in£o.target) ; 

inessret_in£o :■ new tae_wpt.event_context; 
n»e3sret_info.collection tmp_info.collection; 


226 




Co_Find (inessret_in£o.collection/ “messret_v", niessret_info.view) ; 

Co_Find (nvessret_info.collection/ "inessret_t", inessret_info.target); 

trackrep_info new tae_wpt.event_context; 

trackrep_in£o.collection :■ tn¥>_info-collection; 

Co_Find (trac]crep_in£o.collection, "trac)crep_v", 
traclcrep_in£o.view) ; 

Co_Find (trackrep_in£o.collection, "trackrep_t", 
trackrep_in£o.target); 

tertrrep_in£o new tae_wpt.event_context; 

tertrrep_in£o.collection tn?j_in£o.collection; 

Co_Find (tertrrep_in£o.collection, "tertrrep_v", 
tertrrep_in£o.view); 

Co_Find (tertrrep_in£o.collection, "tertrrep_t", 
tertrrep_in£o.target); 

Wpt_NewPanel main_in£o.target, main_in£o.view, 

X_Windows.Null_Window, inain_in£o, Wpt_DEFAULT, 
inain_in£o.panel_id); 

end initializepanels; 


—******«************************************************************ 
—*** procedure MANAGE_USER_INTERFACE *** 

„.******************************************** Ik * Ik ******************** * 

procedure manage_user_inter£ace is 


..* **************************************************************** 

—*** procedure GET_TRACK_F1LTER_VALUES *** 

_** * *************************************************************** 

procedure get_track_£ilter_values is 

value : array (1..1) o£ string (1..tae_taecon£.stringsize); 

£loat_value : array (1..1) o£ tae£loat; 
integer_value : array (1..1) o£ taeint; 

begin —get_track_£ilter_values 


227 












Npt_NewPanel filter_info.target, filter_info.view, 

XJWindows .NullJWindow, f ilter__info, 

WptJDEFAULT,filter_info.panel_id); 

loop 

Wpt_NextEvent (wptEvent, etype); 
case etype is 

when Wpt_PARM_EVENT -> 

Wpt_Extract_Context (wptEvent, user_ptr); 

Wpt_Extract_Parm (wptEvent, user_ptr. parm_naine); 

Wpt_Extract_Data (wptEvent,user_ptr.datavin_ptr); 

Vin_Find ( 

user_ptr.datavmjptr,user_ptr,parm_name,user_ptr.parm_ptr); 

if s_equal ("max_num_track", user_ptr.pann__name) then 

Vin_Extract_IVAL (user_ptr .pann_ptr, 1, integer__value (1)) / 
if integer_value(1) >• 0 then 
new_track__filter.max_^n\iniber ;■ 

integer(integer_value(1)); 

else 

Wpt_ParxnRe ject ( filter_info.panel_id, 

user_ptr.pann_narne, "Number of Track >■ 0 required"); 
end if; 

elsif s_equal ("class_air", user_ptr.pann_naroe) then 
Vm_Extract_SVAL (user_ptr.parm__ptr, 1, value (1)); 
if value(1)(1..3) “ "yes" then 

new_track_filter.desired_class(air) :» true; 
else 

new_track_filter.desired_class(air) false; 
end if; 

elsif s_equal ("class_surface", user__ptr.pann_name) then 
Vm_Extract_SVAL (user_ptr.parm_ptr, 1, value(l)); 
if value(1)(1..3) - "yes" then 

new_track_filter.desired_class(surface) :■ true; 
else 

new_track_filter.desired_class(surface) :• false; 
end if; 


228 



elsif s_equal ("claas_subsurf", user_ptr.parm_name) then 
Vm_Extract_SVAL (u 3 er_ptr.pann_ptr, 1, valued)); 
if value(1)(1..3) - "yes" then 

new_trac)c_filter.desired_class (subsurface) true; 

else 

new_trac)c_filter.desi*^d_class(subsurface) false; 

end if; 

elsif s_equal ("air_range", user_ptr.parm_naine) then 

Vin_Extract_RVAL (user_ptr.parm_jptr, 1, float_value (1)); 
if float_value(1) >- 0.0 then 

new_trac)c_f ilter. desired_range (air) : - 

float(float_value(1)); 

else 

Wpt_PannReject( filter_info.panel_id, 

U3er_ptr.pann_name, "Range >« 0.0 required"); 

end if; 

elsif s_equal ("surface_range", user_ptr.parm_naine) then 
Vm_Extract_RVAL (user_ptr.pann_ptr, 1, float_value(1)); 
if float_value(1) >- 0.0 then 

new_trac)c_filter.desired_range (surface) 

float(float_value(1)) 

else 

Wpt_PannReject( filter_info.panel_id, 

user_ptr.pann_nanie, "Range >“ 0.0 required") 

end if; 

elsif s_equal ("subsurf_range", user_ptr.pann_naine) then 
Vin _Extract_RVAL (user_ptr.pann_ptr, 1, float_value (1)); 
if float_value(1) >- 0.0 then 

new_trac)c_filter.desired_range (subsurface) 

float(float_value(1)) 

else 

Wpt_PannReject( filter_info.panel_id, 

user_ptr.pann_name, "Range >» 0.0 required") 

end if; 

elsif s_equal ("cancel", user_ptr.pann_naine) then 
—reassign the new values to old values, 

—changes are not valid 
new_track_filter old__trac)c_filter; 

Wpt_PanelEra3e(filter_info.panel_id); 
exit; 

elsif s_equal ("o)c", user_ptr.parm_naine) then 


229 





Wpt_PanelErase(filter_info.panel_id); 
exit; 
else 

put_line("Enter data to TRACK FILTER PANEL Only"); 
end If; 

when Wpt_WINDOW_EVENT -> 
null; 

when OTHERS -> 

put("ERROR: Unexpected Wpt_NextEvent. "); 
end case; 
end loop; 

end get_trac)t_filter_values; 


—***************«*★****************************«****************** 

—**• procedure GET_ARCHIVE_SETUP_VALUES *** 

—**«************************************************************** 

procedure get_archive_setup_values is 

value : array (1..1) of string (1..tae_taeconf.stringsiie); 
begin 

Wpt_NewPanel ("", archive_info.target, archive_info.view, 
X_Windows.Null_Window,archive_info, 

Wpt_DEFAULT,archive_info.panel_id); 

loop 

Wpt_NextEvent (wptEvent, etype); 
case etype is 

when Wpt_PARM_EVENT -> 

Wpt_Extract_Context (wptEvent, user_ptr); 


230 






Wpt_Extract_Parm (wptEvent,user_ptr .pamjnaine); 

Wpt_Extract_Data (wptEvent,user_ptr.datavin__ptr); 

Vm_Find ( 

U8er_ptr.datavin_ptr,user_ptr.parm__naine,user_ptr.parm_ptr); 

if 8_equal ("all8hip8", u8er_ptr.parTn_naine) then 
Vm_Extract_SVAL (U8er_ptr.parm_ptr, 1, value (1) ); 
if value(l) (1..3) - "yea" then 
new_archive_aetup.all_8hip8 :■ true; 
elae 

new_archive_aetup.all_ahips false; 
end if; 

elaif 8_equal ("ownahip", U8er_ptr.pann_name) then 
Vm_Extract_SVAL (u3er_ptr.parjnjptr, 1, valued)); 
if value<l) (1..3) - "yea" then 

new_archive_3etup.ownship true; 
elae 

new__archive_3etup.ownahip :■> falae; 
end if; 

elaif 3__equal ("jtida", U3er_ptr.pann_naine) then 
Vm_Extract_SVAL (uaerjptr.parmjptr, 1, valued)); 
if valued) (1..3) - "yea" then 
new_archive_8etup.jtida true; 

elae 

new_archive_3etup.jtida falae; 

end if; 

elaif 8_equal ("linkll", U3er_ptr.pann_naine) then 
Vm_Extract_SVAL {u3er__ptr.pann_ptr, 1, valued)); 
if valued) (1..3) - "yea" then 
new_archive_3etup.linkll ;■ true; 
elae 

new_archive_3etup.linkll falae; 

end if; 

elaif 3_equal ("linkl6", user_ptr.parm_nanve) then 
Vin_Extract_SVAL (u3er_ptr.pann__ptr, 1, valued)); 
if valued) (1..3) - "yea" then 
new_archive_3etup.Iinkl6 true; 

elae 

new_archive_3etup.linkl6 falae; 

end if; 

elaif 3_equal ("otcixs", uaerjptr,parm_naine) then 


231 


Vm_Extract_SVAL (user_ptr.pann_ptr, 1, valued)); 
if valued) (1. .3) ■ "yes" then 
new_a rchive_setup.otcixs :- t rue ; 
else 

new_archive_setup.otcixs :<• false; 
end if; 

elsif s_equal ("cancel", user_ptr.parm_naine) then 
—reassign the new values to old values, 

—changes are not valid 
new_archive_aetup old_archive_setup; 
Wpt_PanelErase(archive_info.panel_id); 
exit ; 

elsif s_equal ("o)c", user_ptr.pann_naxne) then 
Wpt_PanelErase(archive_info.panel_id); 
exit; 
else 

put_line("Enter data to ARCHIVE SETUP PANEL Only"); 
end if; 

when Wpt_WINDOW_EVENT -> 
null; 

when OTHERS ■> 

put("ERROR: Unexpected Wpt_NextEvent. "); 
end case; 
end loop; 

end get_archive_setup_values; 


__**«***«**«********************•*•*****•************************** 

—*** procedure GET_TRACK_DISPLAy_CONSTRAINTS *** 

—*****************«************•********************************** 

procedure get_trac)c_display_constraints is 

value : array d..l) of string (1..tae_taeconf.stringsize) 

float_value : array (1..1) of taefloat; 
integer_value : array (1..1) of taeint; 


232 









begin 


Mpt_NewPanel contrnts_info.target, contrnts_info.view, 

X_Windows.Null_Window, contrnts_info, 

Wpt_DEFAULT,contrnts_info.panel_id); 

loop 

Wpt_NextEvent (wptEvent, etype); 

case etype Is 

when Wpt_PARM_EVENT -> 

Wpt_Extract_Context (wptEvent, user_ptr); 

Wpt_Extract_Pann (wptEvent,user_ptr.pann_naine) ; 
Wpt_Extract_Data (wptEvent,user_ptr.datavin_ptr); 

Vm_Find ( 

user_ptr. datavin_ptr, user_ptr. parm_naine, user_pt r. pann_ptr) 

if s_equal ("range", U3er_ptr.pann_naine) then 

Vm_Extract_RVAL (userjptr.parmjptr, 1, float_value(1)); 
if float_value(1) >- 0.0 then 

new_track_request.the_range :■> float(float_value(1)); 
else 

Wpt_PannReject( contrnts_info.panel_id, 

user_ptr.pann_naine, "Range >- 0 required") 

end if; 

elsif s_equai ("class_air", userjptr.pann_naine) then 
Vm_Extract_SVAL (user_ptr.pann_ptr, 1, valued)); 
if value(1)(1..3) - "yes" then 

new_trac)c_request.trac)c_class (air) :■ true; 
else 

new_trac)c_request.trac)c_class (air) false; 
end if; 

elsif s_equal ("class_surface", user_ptr.pann_naine) then 
Vm_Extract_SVAL (userjptr.pann__ptr, 1, valued)); 
if valued) (1..3) “ "yes" then 

new_trac)t_request .trac)c_class (surface) true; 

else 

new_trac)c_request .trac)c_class (surface) false; 


233 





end if; 

elsif s_equal {"claas_subsurf", user_ptr.pann_naine) then 
\hn_Extract_SVAL (u3er_ptr.parm_ptr, 1, valued)); 
if value(1)(1..3) ■ "yes" then 

new_track_request.track_class(subsurface) true; 
else 

new_track_request.track_cla3S(subsurface) :« false; 
end if; 

elsif s_equal ("friendly", user_ptr.pann_name) then 
Vin_Extract_SVAL (user_ptr.pann_ptr, 1, valued)); 
if value(1)(1..3) “ "yes" then 

new_track_request.iff_class(friendly) true; 

else 

new_track_request.iff_class(friendly) false; 

end if; 

elsif s_equal ("hostile", user_ptr.parjn_name) then 
Vm_Extract_SVAL (user_ptr.partn_ptr, 1, valued)); 
if valued) (1. .3) “ "yes" then 

new_track_request.iff_class(hostile) :« true; 
else 

new_track_request.iff_class(hostile) :■ false; 
end if; 

elsif s_equal ("neutral", user_ptr,parm_name) then 
Vn\_Extract_SVAL (user_ptr.pannjptr, 1, valued)); 
if valued) (1..3) ■ "yes" then 

new_track_request.iff_class(neutral) true; 

else 

new_track_request.iff_class(neutral) false; 

end if; 

elsif s_equal ("unknown", user_ptr.pann_naine) then 
Vm_Extract_SVAL (user_ptr .parTn_ptr, 1, value (1)); 
if valued) (1. .3) ■ "yes" then 

new_track_request.iff_class(unknown) true; 

else 

new_track_request.iff_class(unknown) false; 

end if; 

elsif s_equal ("cancel", U3er_ptr.pann_naine) then 
—reassign the new values to old values, 

—changes are not valid 
new_track_request :• old_track_request; 

Wpt_PanelErase(contrnts_info.panel_id); 


234 







exit; 

elsif s_equal ("ok", user_ptr.parTn_nanie) then 
old_track_reque3t new_track_request; 

Wpt_PanelErase{contrnts_info.panel_id); 
if track_display_panel_is_displayed then 
Wpt_PanelRe3et{di3play_Info.Panel_id); 
el3e 

Wpt_NewPanel ("",di3play_info.target,di3play_info.view, 
X_Window3.NullJMindow,di3play_info,Wpt_DEFAULT, 
di3play_info.panel_id); 
track_di3play__panel_i3_di3played true; 
end i£; 
exit; 
el3e 

put_line < 

"Enter data to TRACK DISPLAY CONSTRAINTS PANEL Only"); 
end if; 

when Wpt__WINDOW_EVENT -> 
null; 

when OTHERS -> 

put("ERROR: Unexpected wpt_NextEvent. "); 
end case; 
end loop; 

end get_track_display_constraints; 


A********************************-******************************* 

—*** procedure GET_EMCON_STATUS *** 

__***************************************************************** 

procedure get_emcon_status is 

value : array (1..1) of string (1..tae_taeconf.STRINGSIZE); 
begin —get_emcon_status 

Wpt_NewPanel ("", eincon_info.target, emcon_info.view. 


235 











XJMindows.NullJWindow, eincon_info, WPT_DEFAULT, 
emcon_ln£o.panel_id); 

loop 

Hpt_NextEvent (wptEvent, etype); 

case etype is 

when Wpt_PARM_EVENT -> 

Wpt_Extract_Context (wptEvent, user_ptr); 

Wpt_Extract_Pann (%fptEvent,user_ptr.pann_naine); 
Wpt_Extract_Data (wptEvent,user_ptr,datavin_ptr); 

Vni_Find ( 

uaer_ptr. datavin_ptr, user_ptr. pann_naine, user_ptr. parm_ptr) 

if s_equal ("emcon_atatus", user_ptr.parm_nanve) then 
Vm_Extract_SVAL (user_ptr.parm_ptr, 1, valued)); 
if a_equal ("SILENCE", user_ptr.parm_naine) then 
new_emission_control :* EMCON; 
else 

new_emission_control :■ UNRESTRICTED; 
end if; 

elsif s_equal ("ok", user_ptr.pann_naroe) then 
old_emission_control new_endssion_control; 
Wpt_PanelErase(emcon_info.panel_id); 
exit; 

elsif s_equal ("cancel", user_ptr.pann_naine) then 
—reassign the new values to old values, 

—changes are not valid 

new_eniisaion_control :• old_emission_control; 
Wpt_PanelErase (eincon_info.panel_id); 
exit; 
else 

put_line("Enter data to EMCON STATUS PANEL Only"); 
end if; 

when Wpt_WINDOW_EVENT -> 
null; 


236 







when OTHERS -> 


put("ERROR: Unexpected Wpt_NextEvent. "); 
end case; 
end loop; 

end get_eincon_3tatus; 


__***************************************************************** 
—*** procedure GET_NETWORK_SETOP *** 

—_**** <t« jt ****************************** **-*************** *********** 

procedure get_network_3etup is 

value : array (1..1) of string (l,.tae taeconf.STRINGSIZE); 


_—*************************************************************** 

—*** procedure ATTACH_TO_LINK *** 

„*************************************************************** 

procedure attach_to_link( 

new_network_setup : in out network_setup; 

link_name : in links_type; 

address_naine : in string ) is 

previous : addre3S_link null; 

current : addre3S_link :» new_network_setup(link_name); 

new_address : addres3_link new address_type; 

begin —attach_to_link 

new_address.name address_name; 
if current - null then 

new_address.next new_network_setup(link_name); 
new_network_setup(link_name) new_address; 

else 

while current /■ null loop 
previous current; 
current current .next; 
end loop; 

previous.next new_address; 


237 








end if; 

end attach_to_link; 

begin —get_network_setup 

for I in links_type loop 

new_network_8etup(I) null; 
end loop; 

Hpt_NewPanel network_info.target, network_info.view, 

XJWindows.Null_Hindow, network_info, WPT_DEFAULT, 
network_info.panel_id); 

loop 

Wpt_NextEvent (*;ptEvent, etype) ; 

case etype is 

when Wpt_PARM_EVENT -> 

Wpt__Extract_Context (wptEvent, userjptr); 

Wpt_Extract_Parm (wptEvent,userjptr.panii_naine) ; 
Wpt_Extract_Data (wptEvent,user_ptr.datavm_ptr); 

Vm_Find ( 

user_ptr.datavin__ptr,user_ptr.panti_naroe,user_ptr.parm_ptr); 

if 3_eqtual ("jtids_l", user_ptr.pann_nanie) then 
Vin_Extract_SVAIi (u3er_ptr.pann_ptr, 1, valued)); 
attach_to_link(new_network_setup, jtids, value(1)(1..6)); 
elsif 3_equal ("jtid3_2", user_ptr.parm_nanie) then 
Vin_Extract_SVAL (user_j>tr.parm_ptr, 1, value (1)); 
attach_to_link(new_network_setup, jtids, value(1)(1..6)); 
elsif s_equal ("jtid3_3", user_ptr.pann_name) then 
Vm_Extract_SVAL (user_ptr.parm_ptr, 1, valued)); 
attach_to_link(new_network_setup, jtids, value(1) d..6)); 
elsif s_equal ("jtid3_5", user_ptr.parm_naroe) then 
Vm_Extract_SVAL (userjptr.pann_ptr, 1, valued)); 
attach_to_link(new_network_3etup, jtids, value(1) d..6)); 
elsif s_equal ("jtids_4", user_ptr.panrjname) then 
Vm_Extract_SVAI, (user_ptr.parm_ptr, 1, valued)); 


238 



attach_to_lin)c (new_networ)c_3etup, jtids, value (1) (1. . 6)); 
elsif s_equal user__ptr.parm_name) then 

Vm_Extract_SVAL (u3er_ptr.parTn_ptr, 1, valued)); 
attach_to_lin)c(new_network_3etup, linkll, valued) (1 C)); 

elaif 3_equal ("lin)cll_2”, U3er_ptr.parm_neune) tnen 
Vm_Extract_SVAL (U3er_ptr.pann_ptr, 1, valued)); 
attach_to_lin)c(new_network_3etup, linkll, value(1) (1..6)); 
elaif 3_equal ("linkll_3", U3er_ptr.parm_naine) ‘.lien 
Vin_Extract_SVAL (u3er_ptr.pann_ptr, 1, valued)); 
attach_to_link(new_network_3etup, linkll, value(1) (1..6)); 
elaif 3_equal {"linkll_4", U3er_ptr.parm_name) then 
Vm_Extract_SVAL (u3er_ptr.pann_ptr, 1, valued)); 
attach_to_link(new_network_3etup, linkll, value(1)(1..6)); 
elaif 3_equal ("linkll_5*', U3er__ptr.parm_naine) then 
Vm_Extract_SVAIi (U3er_ptr.pann_ptr, 1, valued)); 
attach_to_link(new_network_3etup, linkll, value d) (1..6)); 
elaif 3_equal ("linkl6_l*’, U3er_ptr.pann_name) then 
Vm_Extract_SVAL (u3er_ptr.parm_ptr, 1, valued)); 
attach_to_link(new_network_3etup, linkl6, value(1)(1..6)); 
elaif 3_equal ("linkl6_2", U3er_ptr.parm_name) then 
Vm_Extract_SVAL (u3er__ptr.pann_ptr, 1, valued)); 
attach_to_link(new_network_3etup, linkl6, value(1)(1..6)); 
elaif 3_equal ("linkl6_3", uaerjptr.parm_name) then 
Vm_Extract_SVAL (u3er_ptr.pann_ptr, 1, valued)); 
attach_to_link(new_network_3etup, linkl6, valued)(1..6)); 
elaif 3_equal ("linkl6_4", U3er_ptr.pann_name) then 
Vm_Extract_SVAL (u3ei:_ptr.pann_ptr, 1, valued)); 
attach_to_link(new_network_3etup, linkl6, value(1) (1..6)); 
elaif 3_equal ("linkl6_5", U3er_ptr.pann_name) then 
Vm_Extract_SVAL (u3er_ptr.pann_ptr, 1, valued)); 
attach_to_link(new_network_3etup, linkl6, value(1)(1..6)); 
elaif 3_equal ("otcix3_l", U3er_ptr.parm_name) then 
Vin_Extract_SVAL (u3er_ptr.pann_ptr, 1, valued) ); 
attach_to_link(new_network_3etup, otcixa, value d) (1..6)); 
elaif 3_equal ("otcix3_2", U3er_ptr.pann_name) then 
Vm_Extract_SVAL (U3er_ptr.pann_ptr, 1, valued)); 
attach_to_link(new_network_3etup, otcixa, value(1) (1..6)); 
elaif 3_equal ("otcix3_3", U3er_ptr.parni_name) then 
Vm_Extract_SVAL (u3er_ptr.pann_ptr, 1, valued)); 
attach_to_link(new_network_3etup, otcixa, value (1) (1..6)); 
elaif 3_equal ("otcixs_4", u3er_ptr.parm_name) then 


239 





Vni_Extract_SVAL (user_jptr.pann__ptr, 1, value (1)); 
attach_to_link(new_network_setup, otcixs, value(1)(1.•6)); 
elsif s_equal ("otcixs_5", user_ptr.parm_naine) then 
Vm_Extract_SVMi (user_ptr.pantv_ptr, 1, valued)); 
attach_to_link{new_network_setup, otcixs, value(1)(1..6)); 
elsif s_equal ("cancel", user_ptr.panti_naine) then 
—reassign the new values to old values, 

—changes are not valid 
new_network_setup old_network_setup; 

Wpt_PanelReset(network_info.panel_id)/ 

Wpt_PanelErase(network_info.panel_id) ; 
exit ; 

elsif s_equal ("ok", user_ptr.parm_naine) then 
old_network_setup new_network_setup; 

Wpt_PanelReset(network_info.panel_id); 

Wpt_PanelErase(network_info.panel_id); 
exit; 
else 

put_line("Enter data to NETWORK SETUP PANEL Only"); 
end if; 

when Wpt_WINDOW_EVENT -> 
null; 

when OTHERS -> 

put("ERROR: Unexpected Wpt_NextEvent. "); 
end case; 
end locp; 

end get_network_setup; 


—*** procedure GET_USER_MESSAGE *** 

procedure get_user_nvessage is 

value : array (1..1) of string (1..tae_taeconf.STRINGSIZE); 

current_relay_to : integer 0; 


240 












—following flags are used to determine if at least minimum 
—required information is entered into the editor 
name_is_entered : boolean false; 
origin_is_entered : boolean :• false; 
address is entered : boolean false; 


—*************************************************************** 
—*** procedure ATTACH_TO_LIST *** 

procedure attach_to_list( 

address_list : in out address_link; 
in_name : in string ) is 

previous : address_link; 

current : address_link address_list; 

new_address : address_link new address_type; 

begin —attach_to_list 

new_addre s s.name :■ in_name; 

if current ~ null then 

new_address.next :■ address_list; 
address_list new_addreas; 

else 

while current /« null loop 
previous :« current; 
current current.next; 
end loop; 

previous.next :■ new_address; 
end if; 

end attach to list; 


._************************************************★************** 

—*** procedure GET_BODY_CONTENT *** 

..**«********************************************«*************** 

procedure get_body_content( text : in out string ) is 


241 












string_count : taeint; 

string_vector : tae.tae_vm.s_vector(1..30); 
entered_8tring : tae.variable_ptr; 

tenqp_string : stringd. .tae__taecon£.STRINGSIZE); 
count : natural 1; 

begin —get_body_content 

Vm_Find {editor_info.target, "body", entered_string ); 
Vm_Extract_COUNT( entered_atring, string_count ); 

for X in 1 .. TEXT_LENGTH loop 
text(I) 
end loop; 

for line in 1..string_count loop 

Vm_Extract_SVAL( entered_string, line, ten?j_string ); 
3tring_vector(integer(line)) 

new string (1.. teinp_string' length) ; 
string_vector(integer(line)).all :» ten^_string; 
text(count..count+ten¥)_string'length-1) :• 

string_vector(integer(line)).all; 

count :■ count + 80; 
end loop; 

end get_body_content; 


..^*************************************************************** 

—*** procedure CHECK_AND_ATTACH_TO_VIA_LIST *** 

«>— * * ************************************************************* 

procedure check_and_attach_to_via_list( 
relay_by : in string; 

to : in string; 

I : in integer ) is 


—*** procedure ATTACH_TO_VIA_LIST *** 


procedure attach_to_via_list( 


242 












relay_by : in string; 
to : in string ) is 

new_address : address_link; 

new_via_line : via_record_link; 

current : address_link; 

previous : address_link null; 

begin —attach_to_via_list 
if current_relay_to ■ 1 then 
new_via_line new via_record; 

new_transiidt_conimand(jtids) .text.header.via_line 

new_via_line; 

elsif current_relay_to ■ 5 then 
new_via_line new via_record; 

new_tran3mit_connnand(jtids).text.header.via_line.next :- 

new_via_line 

end if; 

if current_relay_to < 5 then 
new_via_line 

new_transinit_conimand (jtids) . text. header. via_line 

^Ise 

new_via_line :■ • 

new_tran3mit_coinmand{jtids).text.header.via_line.next 

end if; 

if relay_by ■ " " then — relay_to field came 

new_address new address_type; 

new_address.name to; 

current new_via_line.relay_to; 
if current - null then 

new_address.next :» new_via_line.relay_to; 
new_via_line.relay_to new_address; 
else 

while current /■ null loop 
previous current; 
current current.next; 

end loop; 

previous.next new_address; 

end if; 
else 

new_via_line.relay_by relay_by; 


243 





end if; 

end attach_to_via_list; 

begin —check_and_attach_to_via_list 

if (I >- 1 and I <•• 3 and I - current_relay_to - 1) or 
(I >“ 5 and I <» 7 and 1 - current_relay_to ■ 1) or 
(1-4 and current_relay_to >- 1 and current_relay_to 
(1-8 and current_relay_to >- 5 and current_relay_to 
current_relay_to 1; 
attach_to_via_list(relay_by,to); 
else 

put_line("Enter data to APPROPRIATE ADDRESS FIELD"); 
end if; 

end chec)c_and_attach_to_via_list; 
begin —get_user_inessage 

Wpt_NewPanel ("", editor_info.target, editor_info.view, 
X_Window8.Null_Window, editor_info, WPT_DEFAULT, 
editor_info.panel_id); 

—initialize new_transmit_connjiand 
for I in links_type loop 

new_transmit_coinmand(I) .route_addr 
new_tran3niit_conBnand(I) .routed 
new_transmit_command(I).full 
end loop; 

—initialize new_transnu.t_conimand( jtids) 
new_transmit_conunand(jtids).full 

new_transmit_coinmand(jtids) .text.name 

n • 

t 

new_transmit_conniand(jtids).text.header.classification 
new_transnu.t_conimand(jtids) .text.header.precedence 
new_transmit_cornmand(jtids).text.header.origin 
new_transmit_command(jtids).text.header.address 
new_transmit_coinmand(jtids).text.header.info 
new_transmit_conimand(jtids).text.header.via_line 
for I in 1..60 loop 

new_transmit_conimand(jtids).text.header.subject(I) 
end loop; 


- null; 

- false; 

- false; 


<-3) or 
<-7) then 


true; 


U; 

R; 

"NAME_0"; 

null; 

null; 

null; 


244 






new_transmit_conimand( jtida) .text.linJc_id :■ jtids; 

new_tran5nu.t_coinmand(jtids) .text.relayed falae; 

new_tranamit_conBnand( jtida) .text.archive :* true; 

new_transniit_connnand(jtida) .text.is_track :* falae; 

for I in 1..TEXT_LENGTH loop 

new_tranandt_conimand( jtida) .text.text (I) ' '; 

end loop; 

loop 

Wpt_NextEvent (%fptEvent, etype); 
caae etype ia 


when Wpt_PARM_EVENT -> 

Wpt_Extract_Context (wptEvent, U3er_ptr); 

Wpt_Extract_Pann (»#ptEvent,user_ptr.pann_name); 

Wpt_Extract_Data (wptEver-t,u5er_ptr.datavni_ptr); 

Vm_Find ( 

uaer_ptr.datavm_ptr,uaer_ptr.parm_name,uaer_ptr.parm_ptr); 

if a_equal ("name", uaer_ptr.pann_naine) then 

Vm_Extract_SVAL (uaer_ptr.pann_ptr, 1, valued)); 
new_tranamit_coinniand( jtida) .text.name :■ value(1) (1.. 10); 
name_ia_entered true; 

elaif a_equal ("claaaification", uaer_ptr.pann_naine) then 
Vm_Extract_SVAL (u3er_ptr.pann_ptr, 1, value(1)); 
if 3_equal (valued), "U") then 

new_tran3niit_conimand(jtids) .text.header.claaaification U 

elaif 3_equal (valued), "C") then 

new_transmit_coinmand( jtids) .text.header.claasification :•> C 
elaif 3_equal (valued), "S") then 

new_tran3niit_conBnand( jtids) .text.header.claaaification :■ S 
elae 

new_tran3nu.t_coinmand(jtids) .text.header.classification TS 

end if; 

elsif s_equal ("precedence", user_ptr.pann_naine) then 
Vm_Extract_SVAL (user_ptr.parTn_ptr, 1, valued)); 
if 3_equal (valued), "R") then 


245 





new_transmit__commanci(jtids) .text.header.precedence :■ R; 
elsif s_equal (valued), ”P") then 

new_tran3mit_coniniand(jtida) .text.header.precedence P; 

elsif s_equal (valued), "O") then 

new_transmit_coinmand(jtids).text.header.precedence :■ O; 
else 

new_transmit_coinmand(jtids).text.header.precedence 2; 

end if; 

elsif s_equal ("origin",user_ptr.pann_naine) then 
Vm_Extract_SVAL (user_ptr.pann_ptr, 1, valued)); 
new_transinit_connvand( jtids) .text.header.origin 

value(1)(1..6); 

origin_is_entered :■ true; 
elsif s_equal ("to_l", user_ptr.parm_naine) then 
Vm_Extract_SVAL (user_ptr.pannjptr, 1, valued)); 
attach_to_list( 

new_transmit_coininand( jtids) .text.header.address, value (1) (1. .6)); 
address_is_entered true; 
elsif s_equal ("to_2", user_ptr.parm_naroe) then 
Vm_Extract_SVAl, (u3er_ptr.pann_ptr, 1, valued)); 
attach_to_list( 

new_transmit_conimand( jtids) .text.header.address,value d) (1. .6)); 
elsif s_equal ("to_3", user_ptr.pann_name) then 
Vm_Extract_SVAL (user_ptr.pann_ptr, 1, valued)); 
attach_to_list( 

new_transnu.t_coinmand( jtids) .text.header.address,valued) d. .6)); 
elsif s_equal ("to_4", user_ptr.pann_nan»e) then 
Vm_Extract_SVAL (u3er_ptr.pann_ptr, 1, valued)); 
attach_to_list( 

new_tran3mit_conBiiand(jtids) .text.header.address,valued) d. .6)); 
elsif s_equal ("info_l", user_ptr.pann_name) then 
Vm_Extract_SVAL (user_ptr.pann_ptr, 1, valued)); 
attach_to_list( 

new_transiiiit_comniand(jtids) .text.header.info,value(1) (1..6)); 
elsif s_equal ("info_2", u3er_ptr.pann_name) then 
Vm_Extract_SVAL (user_ptr.pann_ptr, 1, valued)); 
attach_to_list( 

new_transmit_con»nand(jtids).text.header.info,value(1)(1..6)); 
elsif s_equal ("info_3", user_ptr.parm_name) then 
Vm_Extract_SVAL (user_ptr.parm_ptr, 1, valued)); 
attach to list( 


246 




new_transmit_coininand( jtids) .text.header, info, value (1) (1.. 6)); 
elaif s_equal ("info_4", user_ptr.pann_naine) then 
Vin_Extract_SVAL (user_ptr.pann_ptr, 1, value (1)); 
attach_to_list( 

new_transmit_conoiiand( jtids) .text.header.info,value(1) (1. .6)) ; 
elaif a_equal ("via_l_l", uaer_ptr.pann_naine) then 
Vm_Extract_SVAL (uaer_ptr.pannjptr, 1, valued)); 
chec)c_and_attach_to_via_liat (" ", value (1) (1.. 6), 1); 

elaif a_equal ("via_l_2", uaer_ptr.pann_naine) then 
Vm_Extract_SVAL (uaer_ptr.pann_ptr, 1, value(1)); 
check_and_attach_to_via_liat(" ", value(1)(1..6),2); 

elaif a_equal ("via_l_3", uaer_ptr.pann_naine) then 
Vin_Extract_SVAL (uaer_ptr.pann_ptr, 1, valued)); 
checlc_and_attach_to_via_liat (" ", value (1) d..6),3); 

elaif a_equal ("by_l", uaer_ptr.pann_naine) then 
Vm_Extract_SVAL (u3er_ptr.pann_ptr, 1, valued)); 
check_and_attach_to_via_list(valued) d..6)," ",4); 

elaif a_equal ("via_2_l", uaer_ptr.pann_naine) then 
Vm_Extract_SVAL {uaer_ptr.pann_ptr, 1, valued)); 
chec)c_and_attach_to_via_li3t (" ", value (1) d..6),5); 

elaif a_equal ("via_2_2", uaerjptr.pam_nanie) then 
Vni_Extract_SVAL (uaer_ptr.partn_ptr, 1, valued)); 
check_and_attach_to_via_liat(" ", value d)(1..6),6); 

elaif a_equal ("via_2_3", uaer_ptr.parTn_naine) then 
Vm_Ext ract_SVAL (uae r_pt r.pa rm_pt r, 1, value(1)); 
check_and_attach_to_via_liat(" ", value(1)(1..6),7); 

elaif a_equal ("by_2", u 3 er_ptr.pann_name) then 
Vm_Extract_SVAL (U3er_ptr.pann_ptr, 1, valued)); 
check_and_attach_to_via_li3t(value(1)(1..6)," ", 8); 

elaif 3_equal ("aubject", u3er_ptr.pann_nanve) then 
Vra_Extract_SVAL (u3er_ptr.pannjptr, 1, valued)); 
new_tran3mit_conBnand(jtida).text.header.aubject 

value(1)(1..60); 

elaif 3_equal ("body", u 3 er__ptr.pann_name) then 

—actually, becauae of the type of the item (: pageedit), 

—the flow of the program doea not enter here ever. 

—the content of the pageedit item 
—( here: body) will be get after SEND ia preaaed 
Vm_Extract_SVAL (u 3 er_ptr.parm_ptr, 1, valued)); 
new_transmit_command( jtida) .text.text 

value (1) (1..TEXT LENGTH); 


247 




alsif s_equal ("cancel”* user_ptr.pana_naitie) then 

—reassign the new values to old values* changes are not valid 
ffpt_PanelReset (editor_in£o.panel_id); 

Hpt_PanelErase(editor_in£o.panel_id); 
exit; 

elsi£ s_equal ("send"* user_ptr.parm_naine) then 
Wpt_CloseIteins( editor_in£o.panel_id ); 
get_body_content(new_transndt_connnand(jtids).text.text); 
i£ nanie_is_entered and 
origin_is_entered and 
address_ls_entered then 
new_editor_selected :■ true; 

Wpt_PanelReset(editor_info.panel_id); 

Wpt_PanelErase(edltor_info.panel_id); 
exit; 
else 

Wpt_PannReject( editor_in£o.panel_id, user_ptr.parm_naine* 
"Minimum Required In£ormatlon Is Missing"); 
end 1£; 
else 

put_line("Enter data to MESSAGE EDITOR PANEL Only"); 
end 1£; 

when Wpt_WINDOW_EVENT -> 
null; 

when OTHERS -> 

put("ERROR; Unexpected Wpt_NextEvent. "); 
end case; 
end loop; 

end get_user_message; 


_—*•*******•*•****«**••****•*****•***••********•***************«*** 

—*** procedure GET_TRANSMISSION_SEQUENCE *** 

**************************************************************** 

procedure get_transmi3sion_3equence is 


248 










value : array (1..1) of string (1..tae_taecon£.strings!ze); 

£loat_value : array (1..1) of taefloat; 

current_relay_to : integer 0; 

origin_is_entered : boolean false; 

address_is_entered : boolean false; 

—*** procedure ATTACH_TO_LIST *** 

—*************************************************************** 

procedure attach_to_list( 

address_list : in out address_linlc; 
in_naine : in string ) is 

previous : address_link; 

current ; address_link address_list; 

new_address : address_link new address_type; 

begin —attach_to_list 

new_address.name :■ in_name; 

if current ■ null then 

new_address.next address_list; 
address_list :■ new_address; 
else 

while current /- null loop 
previous :■ current; 
current current.next; 

end loop; 

previous.next new_address; 
end if; 

end attach to list; 


— *************************************************************** 

—«** procedure CHECK_AND_ATTACH_TO_VIA_LIST *** 

.•.•****♦*******«*******************♦***********«****************** 

procedure chec)c_and_attach_to_via_iist ( 


249 
















procedure attach_to_via_list{ 
relay_by : in string; 
to : in string ) is 


new_record : address_lin)c; 

new_via_line : via_record_lin)c; 

current : address_link; 

previous : address_link :■ null; 

begin —attach_to_via_list 
if current_relay_to - 1 then 
nevi_via_line new via_record; 

new_initiate_trans.header.via_line :* new_via_line; 
elsif current_relay_to • 5 then 
new_via_line new via_record; 

new_initiate_trans.header.via_line.next new_via_line; 

end if; 

if current_relay_to < 5 then 

new_via_line new_initiate_trans.header.via_line; 

else 

new_via_line new_initiate_trans.header.via_line.next; 

end if; 

if relay_by - " " then — relay_to field came 

new_record new address_type; 

new_record.name :■ to; 
current :■ new_via_line.relay_to; 
if current - null then 

new_record.next new_via_line.relay_to; 
new_via_line.relay_to :* new_record; 
else 

while current /- null loop 
previous :• current; 
current current.next; 













new record; 


end loop; 
previous.next 
end if; 
else 

new_via_line.relay_by relay_by; 
end if; 

end attach_to_via_list; 

begin —chec)t_and_attach_to_via_liat 

if (I >“ 1 and 1 <» 3 and I - current_relay_to “1) or 
(I >•• 5 and I <«• 7 and I - current_relay_to - 1) or 
(1-4 and current_relay_to >«• 1 and current_relay_to <- 3 ) or 
(1-8 and current_relay_to >-5 and current_relay_to <- 7) then 
current_relay_to I; 
attach_to_via_liat(relay_by,to); 
else 

put_line("Enter Data to APPROPRIATE ADDRESS FIELD"); 
end if; 

end check_and_attach_to_via_list; 

begin —get_transmiaaion_aequence 

Wpt_KewPanel ("", trackrep_info.target, trackrep_info.view, 
X_Windows.Null_Window, trackrep_info, 
tae_wpt.WPT_DEFAULT, trackrep_info.panel_id); 


loop 

Wpt_NextEvent (wptEvent, etype); 

case etype is 

when Wpt_PARM_EVENT -> 

Wpt_Extract_Context (wptEvent, user_ptr); 

Wpt_Extract_Pann (wptEvent,user_ptr.pann_naine); 
Wpt_Extract_Data (wptEvent, user_ptr.datavin_j5tr) ; 

Vm_Find ( 

user_ptr. datavin_pt r, user_pt r. pann_naine, user_ptr. partn__ptr); 
if a_equal ("link_id", user__ptr.pann_name) then 


251 







Vm_Extract__SVAL ( uaer_ptr.pam_ptr, 1, value (1)); 
if s_equal (valued), "JTZDS") then 
new_initiate_trans.link_id JTIDS; 
elsif s_equal (valued), "LINKll") then 
new_initiate_tran3.1in)c_id LINKll; 
elsif s_equal (value (1), ''LINK16") then 
new_initiate_trans.lin)c_id LINK16; 
else —if s_equal (valued), "OTCIXS") then 
new_initiate_trans.link_id OTCIXS; 
end if; 

elsif s_equal ("classification", user_ptr.pann_nanie) then 
Vm_Extract_SVAL (user_ptr.pann_ptr, 1, valued)); 
if a_equal (valued), "U") then 

new_initiate_trans.header.classification U; 

elsif 3_equal (value(1), "C") then 

new_initiate_trans.header.classification C; 

elsif s_equal (valued), "S") then 

new_initiate_trans.header.classification S; 

else 

new_initiate_trans.header.classification TS; 

end if; 

elsif s_equal ("precedence", user_ptr.pann_name) then 
Vm_Extract_SVAL (user_ptr.parm_ptr, 1, valued)); 
if s_equal (valued), "R") then 

new_initiate_trans.header.precedence :« R; 
elsif 3_equal (valued), "P") then 

new_initiate_trans.header.precedence :» P; 
elsif s_equal (valued), "O") then 

new_initiate_trans.header.precedence ;• O; 
else 

new_initiate_trans.header.precedence :■ Z; 
end if; 

elsif s_equal ("origin", userjptr.pann_nanve) then 
Vm_Extract_SVAL (user_ptr.pann__ptr, 1, value(l)); 
new_initiate_trans.header.origin value(1)(1..6); 

origin_i3_entered :* true; 

elsif s_equal ("to_l", user_ptr.pann_naine) then 
Vm_Extract_SVAL (user_ptr.parmjptr, 1, value(l)); 
attach_to_list( 

new_initiate_trans.header.address,valued) (1. .6)) 
address is entered true; 


252 










elsif 3_equal ("to_2", user_ptr.parm_najne) then 
Vm_Extract_SVAL {user_ptr.pann_ptr, 1, value(1)); 
attach_to_list( 

new_initiate_trans.header.address,value(1)(1..6)); 
address_is_entered true; 

elsif 3_equal ("to_3", user_ptr.pann_naine) then 
Vin_Extract_SVAL (user_ptr.pann_ptr, 1, value (1)); 
attach_to_list( 

new_initiate_trans.header.address, value(1)(1..6)); 
address_is_entered true; 
elsif s_equal ("to_4", user_ptr.pann_n«uiie) then 
Vm_Extract_SVAL (u3er_jptr.pann_ptr, 1, valued)); 
attach_to_list( 

new_initiate_trans.header.address,value(1)(1..6)); 
address_is_entered true; 

elsif s_equal ("info_l", user_ptr.pann_name) then 
Vm_Extract_SVAL <u3er_ptr.pann_ptr, 1, value(1)); 
attach_to_li3t( 

new_initiate_trans.header.info,value (1) (1..6)); 
elsif s_equal ("info_2", user_ptr.parm_name) then 
Vm_Extract_SVAL (userjptr.pann_ptr, 1, value(1)); 
attach_to_list( 

new_initiate_trans.header.info,value(1)(1..6)); 
elsif s_eq[ual ("info_3", user_ptr.pann_name) then 
Vm_Extract_SVAL (u3er_ptr.pann_ptr, 1, value(1)); 
attach_to_list( 

new_initiate_trans.header.info,value(1) (!..€)); 
elsif 3_equal ("info_4", U3er_ptr.pann_naine) then 
Vm_Extract_SVAL (user_ptr.pann_ptr, 1, valued)); 
attach_to_list( 

new_initiate_trans.header.info,value(1)(1..6)); 
elsif 3_equal ("via_l_l", U3er_ptr.pann_name) then 
Vin_Extract_SVAL (u3er_ptr.parmjptr, 1, valued)); 
check_and_attach_to_via_list(" ",value d) (1..6),1); 

elsif s_equal ("via_l_2", user_ptr.pann_name) then 
Vm_Extract_SVAL (user_ptr.parjn_ptr, 1, valued)); 
check_and_attach_to_via_list (" ", valued) d..6),2); 

elsif s_equal ("via_l_3", user_ptr.pann_name) then 
Vm_Extract_SVAL (user_ptr.pann_ptr, 1, valued)); 
check_and_attach_to_via_list{” ", value d) d..6),3); 

elsif s_equal ("by_l", user_ptr.parm_name) then 


253 




4 ); 


Vm_Extract_SVAL {U3er_ptr.parm_ptr, 1, value(1)); 
check_and_attach_to_via_list(value(1)(1..6)," 
elsif s_equal ("via_2_l", U3er_ptr.pann_name) then 
Vm_Extract_SVAL (u3er_ptr.pann_ptr, 1, value(1)); 
chec)c_and_attach_to_via_li3t (" ",valued) (1..6),5); 

elaif 3_equal ("via_2_2", user_ptr.parm_naine) then 
Vin_Extract_SVAL (u3er_ptr•pann_ptr, 1, value (1)); 
check_and_attach_to_via_list (" ", valued) d..6),6); 

elaif 3_equal {"via_2_3", U3er_ptr.panti_name) then 
Vm_Extract_SVAL (user_ptr.parm_ptr, 1, valued)}; 
check_and_attach_to_via_li3t(" ", value d) d..6),7); 

elaif 3_equal ("by_2", U3er_ptr.pann_naine) then 
Vni_Extract_SVAL (u3er_ptr.parm__ptr, 1, valued)); 
check_and_attach_to_via_list(value(1) (1..6)," ", 8); 

elaif 3_equal ("range", user_ptr.parm_name) then 

Vm_Extract_RVAL (U3er_ptr.pann_ptr, 1, float_value(1)); 
if float_value(1) >« 0.0 then 

new_initiate_trans.dbase_request.the_range :« 

float(float_value(1)); 

elae 

Wpt_PannRe ject ( 

trackrep_info.panel_id, user_ptr.parm_name, "Range >■ 0 required"); 
end if; 

elsif s_equal ("friendly", user_ptr.pann_name) then 

Vm_Extract_SVAL (trackrep_info.parm_ptr, 1, value(1)); 
if valued) (1..3) « "yea" then 

new_initiate_trans.dbase_request.iff_class(friendly) := 

true; 

elae 

new_initiate_trans.dbase_request.iff_class(friendly) 

false; 

end if; 

elsif s_equal ("hostile", user_ptr.parm_name) then 

Vm_Extract_SVAL (trackrep_info.pann_ptr, 1, value(l)); 
if valued) (1..3) « "yes" then 

new_initiate_trans.dbase_request.iff_class(hostile) ;- 

true; 

else 

new_initiate_trans.dbase_request.iff_class(hostile) ;= 

false; 

end if; 


254 





elsif s_equal ("neutral", user_ptr.pann_naine) then 

Vm_Extract_SVAL (trackrep_info.pann_ptr, 1, value(1)); 
if value(1)(1..3) - "yes" then 

new_initiate_trans.dbase_request.iff_class(neutral) 

true; 

else 

new_initiate_trans.clbase_reciuest.iff_class (neutral) 

false; 

end if; 

elsif s_equal ("un)cnown", user_ptr.pann_naine) then 

Vm_Extract_SVAL (trac)crep_info.pann_ptr, 1, valued)); 
if value(1)(1..3) “ "yes" then 

new_initiate_trans.dbase_request.iff_class(unlcnown) 

true; 

else 

new_initiate_trans.clbase_request.iff_class (un)cnown) :« 

false; 

end if; 

elsif 3_equal ("air", user_ptr.pann_naine) then 

Vin_Extract_SVAL (trackrep_info.parm_ptr, 1, value (1)); 
if value (1) (1.. 3) "yes" then 

new_initiate_trans.dbase_request.track_class(air) 

true; 

else 

new_initiate_trans.dbase_request.track_class(air) : *• 

false; 

end if; 

elsif s_equal ("surface", user_ptr.pann_name) then 

Vm_Extract_SVAL (trackrep_info.pann_ptr, 1, valued)); 
if value(1) (1..3) - "yes" then 

new_initiate_tran3.dbase_request.track_clas5(surface) 

true; 

else 

new_initiate_trans.dbase_request.track_class(surface) 

false; 

end if; 

elsif s_equal ("subsurface", user_ptr.pann_name) then 
Vm_Extract_SVAL (trackrep_info.pann_ptr, 1, valued)); 
if valued) (1..3) - "yes” then 

new_initiate_trans.dba3e_request.track_cla33(surface) 

true; 


255 




else 

new_initiate_trans.<lbase_request.track_class(surface) 

false 

end if; 

elsif s_equal ("cancel", user_ptr.pann_naine) then 
new_initiate_trans old_initiate_trans; 

Wpt_PanelEraae(trackrep_info.panel_id); 
exit ; 

elsif s_equal ("ok", U3er_ptr.parjn_naine) then 

if ( origin_is_entered and address_is_entered ) then 
old_initiate_tran3 new_initiate_trans; 
new_terminate_trans false; 

Wpt_PanelErase(trackrep_info.panel_id); 
exit; 
else 

Wpt_ParmReject( trackrep_info.panel_id, 
user_ptr.parTn_name,"Minimum Required Information is Missing"); 
end if; 
else 

put_line( 

"Enter data to PERIODIC TRACK REPORT PANEL Only") 

end if; 

when Wpt_WINDOW_EVENT -> 
null; 

when OTHERS «> 

put("ERROR: Unexpected Wpt_NextEvent. "); 
end case; 
end loop; 

new_initiate_trans.header.subject(1..12) :« "track_report"; 
new_initiate_trans.desired_format ” "; 

end get_transmission_sequence; 


256 






—*** procedure GET__TERMINATE_TRACK_REPORT *** 

—************* Ik************************ *** lit ******************** * 

procedure get_tenninate_track_report is 

begin —get_terTtdnate_track_report 

Wpt_NewPanel tertrrep_info.target, tertrrep_info.view, 

X_Windows.NullJWindow, tertrrep_info, 
tae_wpt.WPT_DEFAULT, tertrrep_info.panel_id); 

loop 

Wpt_NextEvent (wptEvent, etype); 

case etype is 

when Wpt_PARM_EVENT -> 

Wpt_Extract_Context (wptEvent, user_ptr); 

Wpt_Extract_Pann (wptEvent, user_ptr.parTn_name); 
wpt_Extract_Data (wptEvent,user_ptr.datavm_ptr); 

Vm_Find ( 

user_pt r. datavm__pt r, user_pt r. pa rm_naine, userjpt r. partn_pt r); 
if s_equal ("cancel", u5er_ptr.parjn__name) then 
Wpt_PanelErase(tertrrep_info.panel_id); 
exit; 

elsif s_equal ("ok", user_ptr.pann_naine) then 
new_terminate_trans :• true; 

Wpt_PanelErase(tertrrep_info.panel_id); 
exit; 
else 

put_line( 

"Enter data to TERMINATE TRACK REPORT PANEL Only"); 
end if; 

when Wpt_WINDOW_EVENT -> 
null; 

when OTHERS -> 

put("ERROR: Unexpected Wpt_NextEvent. "); 


257 







end case; 


end loop; 

end get_tenninate_traclc_report; 


begin“MANAGE_USER_INTERFACE 


if not panels_are_initialized then 

InitializePanels( file ■> tae_source_file ); 
panels_are_initialized :• true; 
end if; 

while Npt_Pending loop 

Wpt_NextEvent (wptEvent, etype); 

case etype is 

when Wpt_PARM_EVENT -> 

Wpt__Extract_Context (wptEvent, user_ptr); 

Wpt_Extract_Parm (wptEvent, user_ptr.pann_naine); 
Wpt_Extract_Data (wptEvent, userjptr.datavm_ptr); 

Vin_Find ( 

user_ptr.datavin_ptr, U3er_ptr.pann_nanve, user_ptr.pann_j)tr); 

if (U3er_ptr, inain_info) then 

if s_equal ("options", user_ptr.pann_nan>e) then 
Vm_Extract_SVAL (user_ptr.pann_ptr, 1, valued)); 
if 3_equal (valued), "Archive Setup") then 
get_archive_setup_values; 

elsif s_equal (valued), "Trac)t Filter Values") then 
get_trac)c_filter_values; 
elsif s_equal (valued), "Display Tracks") then 
get_trac)c_display_constraints; 
elsif s_equal (valued), "Weapon Status") then 
if weapon_status_panel_is_displayed - false then 
new_status_query true; 


258 




else 

put_line("WEAPON STATUS PANEL is already displayed"); 
end if; 

elsif s_equal (valued), "EMCON Status" ) then 
get_emcon_status; 

elsif s_equal (value(1), "Network Setup" ) then 
get_network_aetup; 

elsif s_equal (valued), "Message Editor") then 
get_uaer_ineasage; 

elsif s_equal (valued), "Read Message") then 
inessage_retrieval_panel; 

elsif s_equal (valued), "Periodic Track Report") then 
get_t ransmission_sequence; 

elsif s_equal (valued), "Terminate Track Report") then 
get_terminate_track_report; 
end if; 

elsif s_equal ("quit", user_ptr.parm_name) then 
if track_display_panel_is_displayed - true then 
Wpt_PanelErase(display_info.panel_id); 
track_display_panel_is_displayed :» false; 
end if; 

if weapon_statusjpanel_is_displayed - true then 
Wpt_PanelErase(weapon^info.panel_id); 
weapon_status_panel_is_displayed false; 
end if; 

if emergency_weapon_status_panel_is_displayed - true then 
Wpt_PanelEra3e(emerg_info.panel_id); 
emergency_weapon_status_panel_is_displayed :« false; 
end if; 

Wpt_PanelEra3e(main_info.panel_id); 
end if; 

elsif "«" (user_ptr, display_info) then 

if s_equal ("change_values", user_ptr.parm_name) then 
get_track_display_constraints; 
elsif s_equal ("quit", user_ptr.parm_name) then 
Wpt_Pai.elErase(display_info.panel_id); 
track_display_panel_i3_displayed false; 
end if; 

elsif "-" (user_ptr, weapon_info) then 

if s_equal ("ok", user_ptr.parm_name) then 
Wpt_PanelErase(weapon_info.panel_id); 


259 





weapon_statusjpanel_is_<iisplayed false; 
end if; 

elsif {user_ptr, emerg_info) then 

if s_equal ("eni_oJc", userjptr.parm_nanie) then 
Npt__PanelErase (einerg_info.panel_id); 

einergency_weapon_3tatus_panel_is_displayed false; 
end if; 
else 

put_line("unexpected event from wpt!"); 
end if; 

when Wpt_WINDOW_EVENT -> 
null; 

when OTHERS -> 

put("ERROR: Unexpected Wpt_NextEvent. "); 
end case; 
end loop; 

end manage_user_interface; 
end SB; 

TABLE OF CONTENTS FOR APPENDIX F 


Type Declarations.147 

Procedure Declarations.151 

Variable Declarations.154 

Procedrre commsjinks.158 

Simulates the communications links connected to the system, 
and produces messages. 

Procedc^ prepare_periodic_report.172 

Prepares the periodic track repons 

Procedure parse_input_file.177 

Parses the incoming communications message and writes the 
contents of the message into an Ada record type for funher 
processing. 


260 










Procedure dccide_for_archiving.181 

Depending on the archive setup value, this procedure archives 
the input ^e 

Procedure extract_tracks.182 

Extracts the track data fipom the message. 

Procedure filter_comms_tracks.186 

Hlters the tracks from the communicadon links according to the 
track frltering values. 

Procedure add_comms_track.190 

Adds the frltered u^ks to the track list 

Procedure sensors.190 


Simulates the sensors connected to the system and generates 
track data. 


Procedure analyze_sensor_data.196 

Extracts the track information from the input variable. 

Procedure prepare_sensor_track.196 

Calculates the real position of a track from the relative position. 

Procedure filter_sensor_tracks.197 

Filters the tracks from the sensors according to the track 
filtering values. 

Procedure add_sensor_track.198 

Adds the filtered tracks to the track list. 

Procedure navigation_system.199 

Simulates the navigation system and generates own position 
data. 

Procedure monitor_ownship_position.199 

Modifies own position value in the track dambase. 


261 















Procedure weapons.systems. 


202 


Simulates the weapon systems connected to the C^I system, 
and produces random situation reports for each weapon system. 


I^ocedure weapons_interface.203 

Provides the last situations of the weapon systems. 

Procedure make.routing.204 

Prepares the route field of the outgoing messages. 

Procedure forward.for.transmission.207 

It acts as a buffer to keep the outgoing messages until the 
EMCON status allows message transmission. 

Procedure convert_to_text_file.207 

Writes the contents of the input Ada record type into a text file 
which represents the outgoing message. 

Procedure message_editor.210 

Assigns the value of the message generated by the user to the 
output data stream. 

Procedure display.tracks.211 

Outputs the track values to the screen. 

Procedure gct_uscr_inputs.217 

Assigns the current values of various variables to the output 
data streams. 

Procedure status_screen.218 

Displays the weapon status panel on the screen. 

Procedure emcrgency_status_screen.219 

Displays the emergency weapon status panel on the screen. 

Procedure messagc_arTival_panel .222 

Displays the name of the message which is received from the 
communications links. 


262 
















Procedure manage.user.interface 


121 


This is the control procedure for the user interface. It senses 
the user inputs, opens necessary panels, gets the user inputs, 
and assigns them to the related variables. 


263 






APPENDIX 6 


AN ALGORITHM TO CALCULATE 
MINIMUM CALLING PERIODS (MCP) AND 
MAXIMUM RESPONSE TIMES (MRT) 

The initial version of the static scheduler required that Minimum Calling Period 
and the Maximum Response Time must be specified for each time critical operator in 
the prototype [Ref. 9]. The static scheduler is improved by implementing an algorithm 
that calculates these dixiing constraints from the Maximum Execution Time, if they 
are not specified by the user. 

This algorithm calculates the minimum calling periods and the maximum response 
times of the sporadic operators by making four passes on the graph that includes the 
data for these time critical operators. 

In the first pass the load factor and the greatest common divisor for the periods of 
the periodic operators is calculated. The load factor is the sum of ratios for maximum 
execution time over period for all periodic operators. 

In the second pass the number of sporadic operators is found, and for the sporadic 
operators with a defmed MCP or MRT, the undefined MCP or MRT value is calculat¬ 
ed with the assumption that MCP = MRT - MET, where MET is the maximum Exe¬ 
cution time of the operator. Then, for these operators, an equivalent period (= MCP) 
and a unit factor is calculated. Unit factor is a coefficient which is used to avoid combi- 
natorical explosion in the length of the static schedule. To calculate the unit factor, for 
each sporadic operator with user defined MCP and/or MRT value, an even ratio of cal¬ 
culated equivalent period over the greatest common divisor of the periods of the peri- 


265 






odic operators is found. Then, the least common multiplier of these ratios is detined as 
the unit factor. 

In the third pass equivalent periods for the sporadic operators with MCP and/or 
MRT value is calculated and inserted in the graph by using the unit factor calculated 
in the second pass such that, 

PERIOD = PERIOD - (PERIOD mod UNIT FACTOR) 

Then the load factor calculated in the first pass is modified to include the ratios for 
these sporadic operators. 

In the fourth pass MCP, MRT and PERIOD values for the sporadic operators 
without user defined MCP or MRT values are calculated and entered to the graph by 
using following assumptions: 

MRT = ALPHA* MET 

MCP = PERIOD = MRT - MET 

These assumptions guarantee a feasible schedule for some constant ALPHA, 
which is determined by the Mok’s Theorem [Ref. 10]. This theorem states that a 
schedule is feasible if total load is less than or equal to 0.5. By using the above equa¬ 
tions, and the Mok’s theorem, ALPHA is determined. 

ALPHA = (number of sporadic operators / (C - load factor)) + 1 

Where C is 0.5 if load factor is less than 0.5, otherwise the average value of 0.5 
and load factor. If load factor exceeds 1, then user is notified that a feasible schedule 
is not possible with single processor. 

The Ada code for the algorithm is as follows, and it is inserted into file processor 
package which is in fp_b.a file. 


266 






procedure FIND_PERIODS{ THEjGRAPH : in out DIGRAPH.GRAPH ) is 


TARGET 

: DIGRAPH.V_LISTS.LIST; 

N 

: NATURAL 0; 

L 

: FLOAT 0.0; 

NEW_PERIOD 

: NATURAL 0; 

OP 

: OPERATOR; 

C 

: FLOAT; 

FIRST 

: BOOLEAN true; 

FOUND 

: BOOLEAN false; 

FRACTION 

: NATURAL; 

FR_GCD 

: NATURAL; 

LCM 

: NATURAL; 

UNIT 

: NATURAL; 

ALPHA 

: FLOAT; 

GCD 

: NATURAL; 


package I_IO is new TEXT_IO.INTEGER_IO(NATURAL); 

procedure CALCULATE_NEW_PERIOD (O : in OPERATOR; 

NEW_PERIOD : in out NATURAL 

DIFFERENCE ; NATURAL; 

package VALUE_IO is new TEXT_IO.INTEGER_IO(NATURAL); 
begin 

DIFFERENCE O.THE_MRT - O.THE_MET; 
if DIFFERENCE < O.THE_MCP then 
NEW_PERIOD DIFFERENCE; 
else 

NEW_PERIOD O.THE_MCP; 
end if; 

TEXT_IO.put("The new PERIOD is => "); 

VALUE_IO.put(NEW_PERIOD) ; 


) is 


267 








TEXT_IO.NEW_LINE; 
end CALCULATE NEW PERIOD; 


function FIND_GCD (SMALL : in VALUE; LARGE : in VALUE) 

return VALUE is 

REMAINDER : VALUE SMALL; 
begin 

if LARGE mod SMALL - 0 then 
return REMAINDER; 
else 

REMAINDER FIND_GCD(LARGE mod SMALL, SMALL); 
return REMAINDER; 
end if; 
end FIND GCD; 


function FIND_LCM (NUMBERl, NUMBER2 : VALUE) return VALUE is 
begin 

return(NUMBERl * NUMBER2) / GCD; 
end FIND_LCM; 

function REDUCE_TO_EVEN_FRACTION( GCD,PERIOD : NATURAL) 

return NATURAL is 

N : NATURAL GCD / PERIOD; 
begin 

if N * PERIOD - GCD then 
return N; 
else 

return N + 1; 
end if; 

end REDUCE TO EVEN FRACTION; 


268 






begin 

— FIRST PASS 

TARGET :» THE_GRAPH.VERTICES; 
while DIGRAPH.V_LISTS.NON_EMPTY(TARGET) loop 
OP DIGRAPH.V_LISTS.VALUE(TARGET); 
if OP.THE_MET - 0 then 

Exception_Operator OP.THE_OPERATOR_ID; 
raise CRIT_OP_LACKS_MET; 

elsif OP.THE_PERIOD /- 0 then — a periodic operator 
L L + FLOAT(OP.THE_MET)/FLOAT(OP.THE_PERIOD); 
if FIRST then 

GCD OP.THE_PERIOD; 

FIRST false; 
else 

if GCD > OP.THE_PERIOD then 

GCD :- FIND_GCD(OP.THE_PERIOD,GCD); 
else 

GCD :- FIND_GCD(GCD,OP.THE_PER10D); 
end if; 
end if; 
end if; 

DIGRAPH.V_LISTS.NEXT(TARGET); 
end loop; 

— SECOND PASS 

TARGET THE_GRAPH.VERTICES; 

FIRST :• true; 

while DIGRAPH.V_LISTS.NON_EMPTy(TARGET) loop 
OP DIGRAPH.V LISTS.VALUE(TARGET); 


269 







if OP.THE_PERIOD - 0 then — a sporadic operator 
if OP.THE_MCP /- 0 and OP.THE_MRT - 0 then 
OP.THE_MRT OP.THE_MET + OP.THE_MCP; 

TARGET.ELEMENT.THE_MRT OP.THE_MRT; 

elsif OP.THE_MCP ■ 0 and OP.THE_MRT /- 0 then 
OP.THEJMCP OP.THE_MRT - OP.THE_MET; 

TARGET.ELEMENT.THE_MCP OP.THE_MCP; 

end if; 

if OP.THE_MCP /- 0 and OP.THE_MRT /- 0 then 
CALCULATE_NEW_PERIOD(OP,NEW_PERIOD); 
if NEW_PERIOD < GCD then 
FOUND true; 

FRACTION GCD/REDUCE_T0_EVEN_FRACT10N{GCD,NEW_PERI0D); 

if FIRST then 

FR_GCD FRACTION; 

LCM FRACTION; 

FIRST false; 
else 

if FRACTION > FR_GCD then 

FR_GCD FIND_GCD(FR_GCD, FRACTION); 

else 

FR_GCD FIND_GCD(FRACTION,FR_GCD); 

end if; 

LCM FIND_LCM(LCM,FRACTION); 

end if; 
end if; 
else 

N N + 1; 
end if; 
end if; 

DIGRAPH.V LISTS.NEXT(TARGET); 


270 




end loop; 
if FOUND then 
UNIT LCM; 

else 

UNIT GCD; 

end if; 


— THIRD PASS 

TARGET THE_GRAPH.VERTICES; 

while DIGRAPH.V_LISTS.NON_EMPTy(TARGET) loop 
OP DIGRAPH.V_LISTS.VALUE(TARGET); 

if OP.THE_PERIOD - 0 then — a sporadic operator 
if OP.THE_MRT /- 0 and OP.THE_MCP /« 0 then 
CALCULATE_NEW_PERIOD(OP,NEW_PERIOD); 

NEW_PERIOD NEW_PERIOD - NEW_PERIOD mod UNIT; 
OP.THE_PERIOD :» NEW_PERIOD; 

TEXT_IO.PUT("New PERIOD for operator "); 
VARSTRING.PUT(OP.THE_OPERATOR_ID); 

TEXT_IO.PUT(" is ") ; 

I_IO.PUT(NEW_PERIOD,1); 

TEXT_IO.NEW_LINE; 

TARGET.ELEMENT.THE_PERIOD OP.THE_PERIOD; 

L L + FLOAT(OP.THE_MET)/FLOAT(NEW_PERIOD); 
end if; 
end if; 

DIGRAPH.V_LISTS.NEXT(TARGET) ; 
end loop; 


if L < 0.5 then 
C 0.5; 

elsif L >- 0.5 and L < 1.0 then 


271 





C (1.0 + L) / 2.0; 
else 

raise NOT_FEASIBLE; 
end if; 

ALPHA FLOAT(N)/{C - L) +1.0; 
if ALPHA <2.0 then 
ALPHA 2.0; 
end if; 

— FOURTH PASS 

TARGET THE_GRAPH.VERTICES; 

while DIGRAPH.V_LISTS.NON_EMPTy(TARGET) loop 
OP DIGRAPH.V_L1STS.VALUE(TARGET); 

if OP.THE_PERIOD ■ 0 then — a sporadic operator 
if OP.THE_MRT - 0 and OP.THE_MCP - 0 then 
OP.THE_MRT NATURAL(ALPHA) * OP.THE_MET; 

OP.THE_MCP OP.THE_MRr - OP.THE_MET/ 
if (OP.THE_MCP / UNIT) * UNIT /- OP.THE_MCP then 
OP.THE_PERIOD OP.THE_MCP + 

UNIT - (OP.THE_MCP mod UNIT) 

else 

OP.THE_PERIOD OP.THE_MCP; 

end if; 

TEXT_IO.PUT("New PERIOD for operator "); 

VARSTRING.PUT(OP.THE_OPERATOR_ID); 

TEXT_IO.PUT(" is "); 

I_IO.PUT(OP.THE_PERIOD,l); 

TEXT_IO.NEW_LINE; 
end if; 
end if; 

TARGET.ELEMENT.THE PERIOD OP.THE PERIOD; 


272 





TARGET.ELEMENT.THE_MRT :•» OP.THE_MRT; 
TARGET.ELEMENT.THE_MCP OP.THE_MCP; 

DIGRAPH.V_LISTS.NEXT(TARGET) ; 
end loop; 
end FIND PERIODS; 


273 




APPENDIX H 


PRODUCING EXECUTABLE 

USER INTERFACE CODE 
IN ADA 


We used TAE Plus software to create a C^I workstation User Interface. TAE 
Plus is a user interface tool based on X Window System, Version 11, release 3, and 
the X Toolkit 

To create the C^I Workstation User Interface, we first used TAE Plus Workbench 
tool. We created the panels (windows) and items needed for the user interface, in the 
Workbench environment. After creation, the Workbench saves the required informa¬ 
tion into the TAE Plus resource file, user.res. While still in the Workbench environ¬ 
ment, we chose the Generate selection of the Utility option from Workbench, to 
generate Ada programs for user interface. If you do not change anything in this pro¬ 
gram, after compiling and loading with TAE Plus library packages on your path, when 
you run the program, it outputs values you have entered into the panels to the stan¬ 
dard output (Screen). 

There were differences between the program that TAE Plus Workbench tool gener¬ 
ated, and the program that we needed. First of all, the program that TAE Plus gener¬ 
ated is arranged to be a main program, so that this User Interface program would 
control the whole environment, and all other utility subprograms would run under con¬ 
trol of this main program, in accordance with the user inputs. But in our case, our main 
program is created by CAPS and we needed only subprograms corresponding to each 
atomic operator, not a main program that controls the whole environment. Another dif- 


275 












ference was, we wanted to store the inputs that the user enters, into the variables 
that the atomic operators should output, instead of outputting those to the standard 
output device. 

We have changed the program to satisfy our needs. The resulting Ada code be¬ 
came a collection of separate subprograms v'hich match the atomic modules of the C^I 
Workstation prototype. These subprograms are included in the software base which 
is given in Appendix F. 

A. REQUIREMENTS IN ORDER TO USE THE TAE Plus PROGRAM 

In order to run the TAE Plus program, you have to bring up X-Window with uwm 
window manager. Also the TAE Plus resource file that is created by using 
Workbench (user .res in our case) must be in the current directory. 


B, WALKING THROUGH TAE PLUS UTILITY FUNCTIONS 

Package TAE is the program that contains all of the utility functions. There are 
four separate packages declared in this package that we have used. Hiese packages 
and the utility functions are as follows: 


/. Package TAE.TAEJWPT 

The Window Programming Tools package is a library of application program- 
callable routines used to define and control elements of the TAE Plus user interface. 

The following Utility functions are used in our application: 

• Wpt_NewPancl : Displays an Interaction Panel. This function is used 
every time a previously established panel is needed to either get the 
user inputs or to output some values. 

• Wpt_Extract_Context, Wpi_Extract_Parm, Wpt_Extract_Data, 
Vm_Find functions arc used as a block every time the user inputs 


276 






some value to one of the panels, in order to extract the contents of 
the input. 

• Wpt_PanelReset : Resets the parameter values in a specific panel to 
the values those are initially shown when Wpt_NewPanel was first 
called to display the panel. This function is used in two cases. First, 
we may always choose to display the values as initialized, not as 
made on the previous session. In this case, this function is used to re¬ 
store the initial values of the items on the panel before removing the 
panel from the screen, so that when same panel is called another 
time, it will have the initial values, instead of the values as entered in 
this session. Second, when we want to clear the information on the 
items, this procedure allows to clear the items on the panel if their ini¬ 
tial values are blank. 

• Wpt_PaneIErase : Removes the displayed panel from the screen. 

• Wpt_SetString : Sets the value of a "YAE Plus string variable and up¬ 
dates the displayed value of the associated TAE Plus item. 

• Wpt_SetReal : Sets the value of a TAE Plus float variable and up¬ 
dates the displayed value of the associated TAE Plus item. 

• Wpt_SetIntg: Sets the value of a TAE Plus integer variable and up¬ 
dates the displayed value of the associated TAE Plus item. 

• Wpt_ParmReject : Generates a rejection message for a given param¬ 
eter, and restores the last value before the change on the item. 

• Wpt_NextEvent: Reads next panel-related event from Wpt. 

• Wpt_Pending ; Determines if the user entered a value to any panels. 

2. Package TAE.T EjCO 

The Collection Package provides the capability to manage groups of TAE 

objects. 

• Co_New : Creates an empty collection. This is used for whole TAE 
program once, to create the collection of all objects. 

• Co_ReadFile : Reads collection of Vm objects from the TAE resource 
file. 

• Co_Find : Finds the related information about each panel in the col¬ 
lection of all the objects. 

3, Package TAE.TAE_VM 

The Collection Package allows the program to manipulate process TAE 
variables. 


211 





• Vm_Fmd: Finds the related variable in the structure object 

• Vm_Extract_S VAL: Extracts string value of TAE variable structure. 

• Vm_Extract_rVAL : Extracts integer value of TAE variable struc¬ 
ture. 

• Vna_Extract_RVAL: Extracts float value of TAE variable structure. 

4. Package TAE.TAEJfISC 

The Miscellaneous Functions Package provides some utility functions. 

• s_cqual ( variable, parameter.name ) : checks if the user entered a a 
speciEc value. 

• f_force_lower; enables lower case file names for source files. 


C. INITIALIZING THE TAE PLUS APPLICATION ENVIRONMENT 

Before using any of the TAE+ subprograms, The panels must be initialized. This 
is done by procedure InitializePanels in our application. Procedure InidalizePanels 
opens the TAE resource file and then associates each panel pointer with the related 
panel. 

D. TAE PLUS PROCEDURES 

A typical TAE Plus procedure consists of: 

• Wpt_NewPanel procedure to open the related panel 

• Wpt_NextEvent procedure to get the next panel related event, mostly the 
ones that the user entered, 

• Case statement to choose different types of events, 

• Wpt_Extract_Context, Wpt_Extract_Paim, Wpt_Extract_Data, Vm_Find 
funcdons to extract the contents of the input, if the eventtype is a 
Wpt_PARM_EVENT. 

• if-clause on s_equai funcdon to determine which input the user entered, if 
the eventtype is a Wpt_PARM_EVENT. The related acdons follows relat¬ 
ed if section. 

• when eventtype is Wpt_WINDOW_EVENT, nothing is to be done. 


278 





No other types of events are expected in this case statement So if any other type 

of event arrives, it is handled with a put_line statement following the related when 

OTHERS selection. A typical procedure is shown below: 

procedure inessage_retrieval_panel is 
name : filename; 
count : taeint; 

value : array (1..1) of string (1 ..tae_taeconf.STRINGSIZE); 
filename_is_entered : boolean :• false; 
begin —message_retrieval_panel 

Wpt_NewPanel messret_info.target, messret_info.view, 

X_Windows.Null_Window, measret_info, Wpt_DEFAULT, 
measret_info.panel_id); 

loop 

Wpt_NextEvent (wptEvent, etype); 
case etype is 

when Wpt_PARM_EVENT -> 

Wpt_Extract_Context (wptEvent, user_ptr); 

Wpt_Extract_Parm (wptEvent,user_ptr.parm_name); 
Wpt_Extract_Data (wptEvent,user_ptr.datavm__ptr); 

Vm_Find(use r_pt r.dat avm_pt r,use r_pt r.pa rm_name, 
user_ptr.parm_ptr); 

if s_equal ("filename", uaer_ptr.parm_name) then 
Vm_Extract_SVAL (uaer_ptr.parm_ptr, 1, valued) ); 
file_name new_name(value(1)(1..10)); 
filename_is_entered true; 
elsif s_equal ("display", user_ptr.parm_name) then 
if filename_is_entered * true then 

wpt_PanelReset(messret_Info.Panel_id); 

Wpt_PanelErase(messret_info.panel_id); 
mes3came_display (file_name); 
exit; 
else 

Wpt_ParmReject( messret_info.panel_id, 
user_ptr.parm_name, "Filename should be Entered"); 
end if; 

elsif s_equal ("cancel", user_ptr.parm_name) then 
Wpt_PanelReset(messret_Info.Panel_id); 

Wpt_PanelErase(messret_info.panel_id); 
exit; 

else 

put_line("Enter data to MESSAGE RETRIEVAL PANEL Only"); 
end if; 

when Wpt_WINDOW_EVENT -> 
null; 

when OTHERS -> 


279 





put("ERROR: Unexpected Wpt_NextEvent. "); 
end case; 
end loop; 

end inessage_retrieval_panel; 

The boolean variable fiiename_is_entereci is used in the procedure to check if 
filename is entered , before trying to retrieve the file. If the filename is not entered 
yet, then the SEND event is rejected by displaying a related message, by using 
Wpt_ParmRejecL 


280 





APPENDIX I 


ADA CODE 

FOR EXCLUDED MODULES 


This appendix includes the reusable Ada components for the atomic operators 

which are not included in the running version of the C l prototype. These modules can 
be used to improve the features of the prototype by following the prototyping steps 
explained in previous chapters. 




“ * MODULE NUMBER 

— * MODULE NAME 

— * DATE 

— * REVISED 


1 . 1.2 

DECIDE FOR RELAYING 
9 AUGUST 1990 
5 SEPTEMBER 1990 




with DECLARATIONS; 
use DECLARATIONS; 


procedure DECIDE_FOR_RELAYING( 

INPUT_TEXT_RECOt<D : in out TEXT_RECORD; 

TCD_NETWORK_SETUP : in out NETWORK_SETUP; 

TCD_TRANSMIT_COMMAND : in out TRANSMIT_COMMAND ) is 
VIA_POINTER : VIA_RECORD_LINK; 

TO POINTER : ADDRESS LINK; 


281 











ADDR_PTR : ADDRESS_LINK; 

FOUND : BOOLEAN false; 

NEW_ADDRESS : ADDRESS_LINK; 

LINK : LINKS_TyPE; 

begin 

VIA_POINTER :- INPUT_TEXT_RECORD.HEADER.VIA_LINE; 
while VIA_POINTER /- null loop 

if VIA_POINTER.RELAy_BY - OWN_ADDRESS then 
TO_POINTER VIA_POINTER.RELAY_TO; 
while T0_P01NTER /- null loop 
LINK JTIDS; 

FOUND false; 
while not FOUND loop 

ADDR_PTR TCD_NETWORK_SETUP{LINK); 
while ADDR_PTR /» null and not FOUND loop 
if TO_POINTER.NAME - ADDR_PTR.NAME then 
FOUND true; 

» 

NEW^ADDRESS new ADDRESS_TYPE; 

NEW_ADDRESS.NAME TO_POINTER.NAME; 

NEW_ADDRESS.NEXT 

TCD_TRANSMIT_COMMAND(LINK).ROUTE_ADDR; 
TCD_TRANSMIT_COMMAND(LINK).ROUTE_ADDR NEW_ADDRESS; 
TCD_TRANSMIT_COMMAND(LINK).ROUTED :» true; 

TCD_TRANSMIT_COMMAND(LINK).FULL ;- t rue; 

TCD__TRANSMIT_COMMAND (LINK) . TEXT : - 

INPUT_TEXT_RECORD; 

end if; 

ADDR_PTR ADDR_PTR.NEXT; 
end loop; 

if LINK - OTCIXS then 
exit; 


282 








else 


LINK L1NKS_TYPE'SUCC(LINK); 
end if; 
end loop; 

TO_POINTER TO_POINTER.NEXT; 
end loop; 

INPUT_TEXT_RECORD.RELAYED true; 
end if; 

VIA_P01NTER VIA_POINTER.NEXT; 
end loop; 

end DECIDE FOR RELAYING; 


_ ***************************************************************** 

— * MODULE NUMBER ; 1.2.2. 

— * MODULE NAME : FORWARD FOR TRANSLATION 

-- * DATE : 10 AUGUST 1990 

-- * REVISED : 8 SEPTEMBER 1990; 

*********************************************4r*****A************* 

with DECLARATIONS; 
use DECLARATIONS; 

package FORWARD_FOR_TRANSLATION is 
TRANSLATE : boolean false; 
procedure FORWARD_FOR_TRANSLATION( 

TRANSMISSION_MESSAGE 
READY_MESSAGE 
RAW_MESSAGE 
end FORWARD_FOR_TRANSLATION; 

package body FORWARD_FOR_TRANSLATION is 


: in out TRANSMISSION_COMMAND; 

: out TRANSMISSION_COMMAND; 

; in out TRANSLATION COMMAND ); 


283 










procedure F0RWARD_F0R_TRANSIiAT10N ( 

TRANSMISSION_MESSAGE : in out TRANSMISSION_COMMAND; 
READY_MESSAGE : out TRANSMISSION_COMMAND; 

RAW MESSAGE : in out TRANSLATION COMMAND) is 


procedure MATCH_FORMAT ( LINK 

: in 

LINKS_TyPE 

SOURCE_FORMAT 

: in 

STRING; 

DESIRED FORMAT 

: out 

STRING 


— this procedure looks at a table with the input variables, 

— and finds the matching format, 
begin 

null; 

end MATCH_FORMAT; 

begin 

for LINK in LINKS_TyPE loop 

if TRANSMISSIONJMESSAGE(LINK).FULL then 
MATCH_FORMAT( LINK, 

TRANSMISSION_MESSAGE(LINK).TEXT.FORMAT, 
RAW_MESSAGE(LINK).DESIRED_FORMAT); 
if TRANSMISSION_MESSAGE(LINK).TEXT.FORMAT /- 

RAW_MESSAGE(LINK).DESIRED_FORMAT then 
TRANSLATE true; 

RAW_MESSAGE(LINK).TEXT TRANSMISSION_MESSAGE(LINK).TEXT; 
RAW_MESSAGE(LINK).ROUTE_ADDR 

TRANSMISSION_MESSAGE(LINK).ROUTE_ADDR; 
RAW_MESSAGE(LINK).FULL TRANSMISSION_MESSAGE(LINK).FULL; 
RAW_MESSAGE(LINK).SOURCE_FORMAT 

TRANSMISSION_MESSAGE(LINK).TEXT.FORMAT; 

else 

TRANSLATE false; 


284 




end if 


end if; 
end loop; 

READy_MESSAGE TRANSMISSION__MESSAGE; 
end FORWARD_FOR_TRANSLATION; 
end FORWARD FOR TRANSLATION; 


__ ***************************************************************** 

— * MODULE NUMBER : 1.3 

— * MODULE NAME : TRANSLATE MESSAGE 

— * DATE : 13 AUGUST 1990 

— * REVISED : 7 SEPTEMBER 1990 

«« i^**********^*****1ir******1k*******4r***llr******************'**'******** 

with DECLARATIONS, TEXT_IO; 

use DECLARATIONS, TEXT_IO; 
procedure TEANSLATE_MESSAGE( 

RAW_MESSAGE : in TRANSLAT10N_C0MMAND; 

READY MESSAGE : out TRANSMISSION COMMAND ) is 


begin 

PUT_LINE("*** MESSAGE TRANSLATION IS IN PROCESS."); 

for LINK in LINKS_TYPE loop 

READY_MESSAGE(LINK).ROUTE_ADDR :- RAW_MESSAGE(LINK).ROUTE_ADDR; 
READY_MESSAGE(LINK).FULL RAWJMESSAGE(LINK).FULL; 

READY_MESSAGE(LINK).TEXT :- RAW_MESSAGE(LINK).TEXT; 

READYJMES SAGE(LINK).TEXT.FORMAT :- 

RAW_MESSAGE(LINK).DESIRED_FORMAT; 

end loop; 

PUT_LINE("**’* TRANSLATION COMPLETED.") ; 

end TRANSLATE MESSAGE; 


285 












— * MODULE NUMBER 

— * MODULE NAME 

— * DATE 

— * REVISED 


3.2.1 

CHECK_FOR_TIMEOUT_AND_RANGE 
17 AUGUST 1990 
13 SEPTEMBER 1990 


—— ***************************************************************** 


with DECLARATIONS, CALENDAR,TEXT_IO; 
use DECLARATIONS, TEXT_IO; 

package CHECK_FOR_TlMEOUT_AND_RANGE is 
BAD_TRACK_FOUND : BOOLEAN false; 
procedure CHECK_FOR_TIMEOUT_AND_RANGE{ 

TDD_CONSTRAINTS ; in SET_MONITOR_CONSTRAINTS; 

TRACKS : in TRACK_TUPLE; 

DELETE_TRACK ; in out DELETE_TRACK_TUPLE ); 

end CHECK FOR TIMEOUT AND RANGE; 


package body CHECK_FOR_TIMEOUT_AND_RANGE is 
procedure CHECK_FOR_TIMEOUT_AND_RANGE( 

TDD_CONSTRAINTS : in SET_MONITOR_CONSTRAINTS; 

TRACKS : in TRACK_TUPLE; 

DELETE_TRACK : in out DELETE TRACK TUPLE ) is 


FILE_NAME 
CtJRRENT 
PREVIOUS 
NEW_RECORD 
TRACK HEAD 


FILENAME; 
TRACK_TUPLE 
TRACK_TUPLE, 
TRACK_TUPLE 
TRACK TUPLE, 


286 






FILE : FILE_TyPE; 

package INT_IO is new INTEGER_IO( NATURAL ); 
use INT_IO; 

package FLT_IO is new FL0AT_10( FLOAT ); 
use FLT_IO; 

package TRACK_CLASS_IO is new ENUMERATION_IO(TRACK_CLASS_TyPE); 
use TRACK_CLASS_10; 

package IFF_CLASS_IO is new ENUMERATI0N_10( IFF_CLASS_TyPE ); 
use IFF_CLASS_IO; 

package ARCHIVE_CLASS_IO is new ENUMERATION_IO( ARCHIVE_CLASS ) 
use ARCHIVE_CLASS_IO; 

function IS_OLD( 

THE_TIME : DECLARATIONS.TIME; 

TIMEOUT : ARCHIVE_TIMEOUT; 

TRACK_CLASS : TRACK_CLASS_TYPE ) return BOOLEAN is 

OBS_TIME : NATURAL; 

SECONDS : NATURAL; 

begin 

OBS_TIME 3600*THE_TIME.HOURS + 60*THE_TIME,MINUTES + 

THE_TIME.SECONDS; 

SECONDS NATURAL( FLOAT( CALENDAR.SECONDS 

{ CALENDAR.CLOCK ) ) ) 

if SECONDS - OBS_TIME >- TIMEOUT( TRACK_CLASS ) then 
return( true ); 
else 

return( false ); 
end if; 
end IS OLD; 


287 





function 1S_FAR< 

RANGE_1 : FLOAT; 

TRACK_CLASS : TRACK_CLASS_TYPE; 

RANGE_2 : MONITOR_RANGE ) return BOOLEAN is 

begin 

if ( RANGE_1 - RANGE_2{TRACK_CLASS) > 0.0001 ) then 
return( true ); 
else 

return( false ); 
end if; 
end IS_FAR; 

function GET FILE NAME return STRING is 


CURRENT_TIME 


CALENDAR.TIME; 

YEAR 


CALENDAR.YEAR_NUMBER; 

MONTH 


CALENDAR.MONTH_NUMBER 

DAY 


CALENDAR.DAY_NUMBER; 

HOURS 


NATURAL; 

MINUTES 


NATURAL; 

SECONDS 


CALENDAR.DAY_DURATION 

FILE NAME 


FILENAME; 


function NATURAL_TO_STRING_2( NUMBER : INTEGER ) 

return STRING is 

N : NATURAL NUMBER; 

S : STRING(1..2) "00"; 

begin 

if N > 9 then 

S(l) CHARACTER'VAL( N/10 + 48 ) ; 

N N - ( (N/10) * 10 ); 
end if; 


288 




S(2) CHARACTER'VAL( N 48 ); 

return( S ); 

end NATURAL_T0_STRING_2; 

begin 

CURRENT_T1ME CALENDAR.CLOCK; 

CALENDAR.SPLIT( CURRENT_TIME, YEAR, MONTH, DAY, SECONDS ); 
HOURS :» INTEGER(SECONDS) / 3600; 

MINUTES (INTEGER(SECONDS) mod 3600) / 60; 

PILE_NAME(1..2) "f_"; 

FILE_NAME(3..4) :- NATURAL_TO_STRING_2( INTEGER(MONTH ) ) 

PILE_NAME(5..6) :- NATURAL_TO_STRING_2( INTEGER(DAY ) ) 

FILE_NAME(7..8) :- NATURAL_TO_STRING_2( INTEGER(HOURS ) ) 

FILE_NAME(9..10) ;- NATURAL_TO_STRING_2( INTEGER(MINUTES) ) 
return( FILE_NAME ); 
end GET_FILE_NAME; 

begin 

DELETE_TRACK.ORIGIN "MONITOR "; 

TRACK_HEAD TRACKS; 

while TRACK_HEAD /- null loop 

if ( IS_OLD(TRACK_HEAD.OBSERVA'^ION_TIME, 

TDD_CONSTRAINTS.TIMEOUT,TRACK_HEAD.TRACK_CLASS ) ) or 
( IS_FAR(TRACK_HEAD.THE_RANGE, 

TRACK_HEAD.TRACK_CLASS, 
TDD_CONSTRAINTS.THE_RANGE) ) then 
BAD_TRACK_FOUND true; 

NEW_RECORD new TRACK_RECORD; 

NEW_RECORD.ID :- TRACK_HEAD.ID; 

NEW_RECORD.NEXT :- DELETE_TRACK.TRACK; 

DELETE TRACK.TRACK NEW RECORD; 


289 











end if; 

TRACK_HEAD TRACK_HEAD.NEXT; 

end loop; 

F1I.E_NAME GET_FILE_NAME; 

CREATE( FILE, NAME -> FILE_NAME ); 
CURRENT DELETE TRACK.TRACK; 


while CURRENT /- null loop 


PUT( 

FILE, 

CURRENT.ID 

); 

NEW_ 

_LINE(FILE) 

PUT( 

file. 

CURRENT.OBSERVER 

); 

NEW_ 

LINE(FILE) 

PUT( 

FILE, 

CURRENT.OBSERVATION_ 

TIME.HOURS ); 

NEW_ 

_LINE(FILE) 

PUT( 

FILE, 

CURRENT.OBSERVATION_ 

TIME.MINUTES); 

NEW_ 

_LINE(FILE) 

PUT( 

FILE, 

CURRENT.OBSERVATION_ 

TIME.SECONDS); 

NEW_ 

_LINE(FILE) 

PUT( 

FILE, 

CURRENT.TRACKjCLASS 

); 

NEW_ 

_LINE(FILE) 

PUT( 

FILE, 

CURF£NT.IFF_CLASS 

); 

NEW_ 

LINE(FILE) 

PUT( 

FILE, 

CURRENT.LATITUDE 

) ; 

NEW_ 

LINE(FILE) 

PUT{ 

FILE, 

CURRENT.LONGITUDE 

); 

NEW_LINE(FILE) 

PUT( 

FILE, 

CURRENT.ALTITUDE 

>; 

NEW_ 

_LINE(FILE) 

PUT( 

FILE, 

CURRENT.COURSE 

); 

NEWSLINE(FILE) 

PUT( 

FILE, 

CURRENT.VELOCITY 

); 

NEW_ 

LINE(FILE) 

PUT( 

FILE, 

CURRENT.THE_RANGE 

); 

NEW_ 

LINE(FILE) 

PUT( 

FILE, 

CURRENT.ARCHIVE_FLAG 


NEW_ 

LINE(FILE) 

NEW_LINE(FILE); 




CURRENT 

CURRENT.NEXT; 





end loop; 
CLOSE(FILE) ; 


end CHECK_FOR_TIMEOUT_AND_RANGE; 

end CHECK FOR TIMEOUT AND RANGE; 


290 









— ***************************************************************** 
—' * MODULE NUMBER ; 3.2.2 

— * MODULE NAME : IDENTIFY_SIMILARITIES 

— * DATE : 17 AUGUST 1990 

— * REVISED : 12 SEPTEMBER 1990 

— ***************************************************************** 

with DECLARATIONS, text_io; 
use DECLARATIONS, text_io; 

package IDENTIFy_SIMILARITIES is 
procedure IDENTIFY_Sj.MILARITIES ( 

TDD_CONSTRAINTS : in SET_MONITOR_CONSTRAINTS; 

TRACKS ; in out TRACK_TUPLE; 

TDM_RESOLUTION_NOTICE : in out RESOLUTION_NOTICE; 

DELETE_TRACK : in out DELETE_TRACK_TUPLE ); 

SIMILARITY_FOUND : BOOLEAN false; 

end IDENTIFY_SIMILARITIES; 

package body IDENTIFY_SIMILARITIES is 

procedure IDENTIFY_SIMILARITIES( 

TDD_CONSTRAINTS : in SET_MONITOR_CONSTRAINTS; 

TRACKS : in out TRACK_TUPLE; 

TDM_RESOLUTION_NOTICE : in out RESOLUTION_NOTICE; 

DELETE_TRACK : in out DELETE_TRACK_TUPLE ) is 

CURRENT : TRACK TUPLE; 


291 







CURRENT_2 : TRACK_TUPLE; 

NEW_RECORD : TRACK_TUPLE; 
begin 

if TDD_CONSTRAINTS.MODE - OFF then 
null; 
else 

TDM_RESOLUTION_NOTICE.SIMILAR false; 

TDM_RESOLUTION_NOTICE.TRACK null; 

DELETE_TRACK.TRACK null; 

CURRENT TRACKS; 
while CURRENT /> null loop 
CURRENT_2 CURRENT.NEXT; 
while CURRENT_2 /- null loop 

if (CURRENT_2.LATITUDE - CURRENT.LATITUDE < 0.01) and 
(CURRENT_2.LONGITUDE - CURRENT.LONGITUDE < 0.01 ) and 
(CURRENT_2.TRACK_CLASS - CURRENT.TRACK_CLASS ) then 
SlMILARlTy_FOUND true; 

NEW_RECORD new TRACK_RECORD; 

NEW_RECORD.ID CURRENT_2.ID; 
if TDD_CONSTRAINTS.MODE - AUTOMATIC then 
NEW_RECORD.NEXT DELETE_TRACK.TRACK; 

DELETE_TRACK.TRACK NEW_RECORD; 

DELETE_TRACK.ORIGIN "TDM 
else 

TDM_RESOLUTION_NOTICE.SIMILAR true; 
NEW_RECORD.NEXT TDM_RESOLUTION_NOTICE.TRACK; 
TDM_RESOLUTION_NOTICE.TRACK NEW_RECORD; 
end if; 
end if; 

CURRENT_2 CURRENT_2.NEXT; 
end loop; 


292 






CURRENT CURRENT.NEXT; 

end loop; 
end if; 

end IDENTIFY_SIMILARITIES; 
end IDENTIFy_SIMIIARITIES; 

—— ***************************************************************** 

— * MODULE NAME : DECLARATIONS 

— * DATE : 17 AUGUST 1990 

— * REVISED ; 12 OCTOBER 1990 

— ***************************************************************** 

with TEXT_IO, CALENDAR; 
use TEXT_IO; 

package DECLARATIONS is 

tyF>e TIME is record 

HOURS : NATURAL range 0..23; 

MINUTES : NATURAL range 0..59; 

SECONDS : NATURAL range 0..59; 

MILISECONDS : NATURAL range 0..99; 

end record; 

TRACK_CAPACITY : constant NATURAL 1024; 

type ARCHIVE_CLASS is { C, N, A, S ); 

type TRACK_CLASS_TYPE is ( AIR, SURFACE, SUBSURFACE ); 

type IFF_CLASS_TYPE is ( FRIENDLY, HOSTILE, NEUTRAL, UNKNOWN ); 

OWNSHIP_IFF_CLASS : constant IFF_CLASS_TYPE FRIENDLY; 

OWNSHIP_TRACK_CLASS : constant TRACK_CLASS_TYPE SURFACE; 

type TRACK_RECORD; 

type TRACK_TUPLE is access TRACK_RECORD; 


293 












type TRACK_RECORD is 
ID : 

OBSERVER : 

OBSERVATION_TIME : 
TRACK_CIASS 
IFF_CLASS ; 

LATITUDE : 

LONGITUDE : 

ALTITUDE 

COURSE : 

VELOCITY 

THE_RANGE : 

ARCHIVE_FLAG 

NEXT : 


record 

NATURAL range 0..TRACK_CAPACITY; 
STRINGCl..8); 

TIME; 

TRACK_CLASS_TYPE; 

IFF_CLASS_TyPE; 

FLOAT range -90.0..90.0; 

FLOAT range -180.0..180.0; 

FLOAT range -10000.0..99999.9; 

FLOAT range 0.0..360.0; 

FLOAT; —in knots 

FLOAT range 0.0..9999.99; —in miles 
ARCHIVE_CLASS; 

TRACK TUPLE; 


end record; 


type ADD_TRACK_TUPLE is record 
ORIGIN : STRING(1..8); 

TRACK ; TRACK TUPLE; 


end record; 


type UPDATE_TRACK_TUPLE is record 
ORIGIN : STRING(1..8); 

TRACK : TRACK_TUPLE; 
end record; 

type DELETE_TRACK_TUPLE is record 
ORIGIN : STRING(1..8); 

TRACK : TRACK_TUPLE; 
end record; 

type REQUEST_TYPE is ( ADD, DELETE, UPDATE ); 
type CHANGE_DATABASE_REQUESr is record 
ORIGIN : STRING(1..8); 

REQUEST : REQUEST TYPE; 


294 







TRACK : TRACK TUPLE; 


end record; 

subtype TEXT_STR1NG is STRING(1..3440); 
subtype SENSOR_lNFORMATION is STRING(1..132); 
type LOCAL_TRACK_INFO is record 


ORIGIN 


STRING(1..8) ; 

ID 


NATURAL range 0..TRACK_CAPACITY 

THE_TIME 


TIME; 

AZIMUTH 


FLOAT range -180.0 .. 180.0; 

ELEVATION 


FLOAT range -90.0 .. 90.0 :■ 0 

THE_RANGE 


FLOAT 0.0; —in miles 

VELOCITY 


FLOAT •» 0.0; —in )cnots 

COURSE 


FLOAT range 0.0..360.0; 

IFF_CLASS 


IFF_CLAS S_TYPE; 

TRACK_CLASS 


TRACK_CLAS S_TYPE; 

ARCHIVE_FLAG 


ARCHIVE_CLASS; 


end record; 


type INTELLIGENCL_REPORT is record 
ORIGIN : STRING(1..8); 

INTELLIGENCE : STRING(1..80); 
end record; 

type SENSOR_RECORD is record 
INTELLIGENCE : STRING(1..80); 

CONTACT : LOCAL_TRACK_INFO; 

end record; 

type OWNSHIP_NAVIGATION_INFO is record 
COURSE : FLOAT range 0.0..360.0; 
VELOCITY : FLOAT; —in )cnots; 

LATITUDE : FLOAT range -90.0..90.0; 
LONGITUDE : FLOAT range -180.0..180.0; 
THE TIME : TIME; 


295 






end record; 

OWN_ADDRESS : constant STRING(1..6) :<« "AAAAAA"; 
type ADORESS_TYPE; 

type ADDRESS_LINK is access ADDRESS_TYPE; 
type ADDRESS_TYPE is record 
NAME : STRING(1..6); 

NEXT : ADDRESS_LINK; 
end record; 
type LINKS; 

type LINKS_LINK is access LINKS; 

type LINKS_TYPE is ( JTIDS, LINKll, LINK16, OTCIXS ); 
type LINKS is record 
NAME : LINKS_TYPE; 

NEXT : LINKS_LINK; 
end record; 

type SECURITY__CLASS is ( U, C, S, TS ); 
type PRECEDENCE_CLASS is ( R, P, O, Z ); 
type VIA_RECORD; 

type VIA_RECORD_LINK is access VIA_RECORD; 
type VIA_RECORD is record 
RELAY_BY : STRING(1..6); 

RELAY_TO : ADDRESS_LINK; 

NEXT : VIA_RECORD_LINK; 

end record; 


type HEADER_FORMAT is record 

CLASSIFICATION : SECURITY CLASS; 


PRECEDENCE 

ORIGIN 

ADDRESS 

INFO 

VIA LINE 


PRECEDENCE_CLASS ; 
STRING(1..6) ; 
ADDRESS_LINK; 
ADDRESS_LINK; 

VIA RECORD LINK; 


296 






SUBJECT 


: STRING(1..60); 


end record; 

aubtype FILENAME is STRING(1..10) ; 
subtype TEXT_FILE is FILE_TYPE; 
type TEXT_RECORD is record 


NAME : 

FILENAME; 

HEADER : 

HEADER_FORMAT; 

LINK_ID : 

LINKS_TYPE; 

RELAYED : 

BOOLEAN; 

ARCHIVE ; 

BOOLEAN; 

IS_TRACK: 

BOOLEAN; 

FORMAT : 

STRING(1,.6) ; 

TEXT : 

TEXT_STRING; 

end record; 



type TRANSMISSION_RECORD is record 
ROUTE_ADDR : ADDRESS_LINK; 

FULL : BOOLEAN; 

TEXT : TEXT_RECORD; 

end record; 

type TRANSMISSION_COMMAND is array ( LINKS_TYPE ) of 
TRANSMISSION_RECORD; 
type TRANSMIT_RECORD is record 
ROUTE_ADDR : ADDRESS_LINK; 

ROUTED : BOOLEAN; 

FULL : BOOLEAN; 

TEXT : TEXT_RECORD; 

end record; 

type TRANSMIT_COMMAND is array ( LINKS_TYPE ) of TRANSMIT_RECORD; 
type MESSAGE_RECORD; 

type MESSAGE_LIST is access MESSAGE_RECORD; 
type MESSAGE_RECORD is record 


297 






L1NK_ID : LINKS_TyPE; 

MAIN : TRANSMISSION_RECORD; 

NEXT : MESSAGE_LIST; 

end record; 

type TRANSLATION_RECORD is record 
ROUTE_ADDR : ADDRESS_LINK; 

FULL : BOOLEAN; 

TEXT : TEXT_RECORD; 

SOURCE_FORMAT : STRING(1..6); 

DESIRED_FORMAT : STRING(1..6); 
end record; 

type TRANSLATION_COMMAND is array ( LlNKS_TyPE ) of 
TRANSLATION_RECORD; 

type NETWORK_SETUP is array ( LINKS_TYPE ) of ADDRESS_LINK; 
type EMISSIONS_CONTROL_COMMAND is ( EMCON, UNRESTRICTED ); 
type PERIODIC_NETWORK_TRANSMISSION is record 
LINK_ID : LINKS; 

TEXT : TEXT_STRING; 
end record; 

type ARCHIVE_SETUP is record 


ALL_SHIPS 


BOOLEAN; 

OWNSHIP 


BOOLEAN; 

JTIDS 


BOOLEAN; 

LINK16 


BOOLEAN; 

LINKll 


BOOLEAN; 

OTCIXS 


BOOLEAN; 


end record; 

type TRACK_CLASS_ARRAy is array(TRACK_CLASS_TYPE) of BOOLEAN; 
type IFF_CLASS_ARRAY is array(IFF_CLASS_TYPE) of BOOLEAN; 
type DATABASE_REQUEST is record 
THE RANGE : FLOAT; 


298 






TRACK_CIASS : TRACK_CIiASS_ARRAY ( true, true, true ); 

IFF_CLASS : IFF_CLASS_ARRAY ( true, true, true, true ); 

end record; 

type INITIATE_TRANSM1SS10N_SEQUENCE is record 
LINK_ID : LINKS_TYPE; 

HEADER : HEADER_FORMAT; 

DESIRED^FORMAT : STRING(1..6); 

DBASE_REQUEST : DATABASE_REQUEST; 
end record; 

subtype REPORT_DATA is STRING(1..20); 

type WEAPONS_TYPE is ( CIWS, GUN, TWS, MK48 ); 

type WEAPON_STATUS_TYPE is( 

DAMAGED, RELOADING, LAUNCHING, READY, SERVICE_REQUIRED, 

SLEWING, SECURED, MAINTANENCE, ENGAGING, 

OUT_OF_AMMUNITION ); 
type WEAPON_STATUS is record 
SYS_TYPE : WEAPONS_TYPE; 

STATUS : WEAPON_STATUS_TYPE; 
end record; 

type WEAPON_STATUS_REPORT is array ( WEAPONS_TYPE ) of 
WEAPON_STATUS_TYPE; 

OWNSHIP_CLASS : constant TRACK_CLASS_TYPE SURFACE; 
type DESIRED_CLASS_ARRAY is array { TRACK_CLASS_TYPE ) of BOOLEAN; 

type DESIRED_RANGE_ARRAY is array ( TRACK_CLASS_TYPE ) of FLOAT; 

type SET_TRACK_FILTER is record 

MAX_NUMBER : NATURAL range 0..TRACK_CAPACITY TRACK_CAPACITY; 
DESIRED_CLASS : DESIRED_CLASS_ARRAY ( true, true, true ); 
DESIRED_RANGE : DESIRED_RANGE_ARRAY; 
end record; 

type ARCHIVE_TIMEOUT is array ( TRACK_CLASS_TYPE ) of NATURAL; 
type MONITOR_RANGE is array ( TRACK_CLASS_TYPE ) of FLOAT; 


299 









type MONITOR_MODE ia ( AUTOMATIC, ADVISE, OFF ); 
type SET_MONITOR_CONSTRAINTS is record 
TIMEOUT : ARCHIVE_TIMEOUT; 

THE_RANGE : MONITOR_RANGE; 

MODE : MONITORJMODE; 

end record; 

type RESOLUTION_NOTICE is record 
SIMILAR : BOOLEAN; 

TRACK ; TRACK_TUPLE; 
end record; 
end DECLARATIONS; 


300 




LIST OF REFERENCES 


1. Bendns, V. and Luqi, Software with Abstractions, Addison-Wesley, 1991. 

2. Yourdon, E., Modern Structured Analysis, Yourdon Press, 1989 

3. Luqi and Berzins, V., "Rapidly Prototyping Real-Time Systems", IEEE 
Transactions on Software Engineering, September 1988. 

4. Luqi, "Software Evolution Through Rapid Prototyping", Computer, v.22, no.5, pp. 
13-25, May 1989. 

5. White, L., The Development of a Rapid Prototyping Environment, M.S. Thesis, 
Naval Postgraduate School, Monterey, California. December 1990. 

6. Luqi and Berzins, V., and Yeh, R., "A Prototyping Language for Real Time 
Software", IEEE Transactions on Software Engineering, October 1988. 

7. Anderson, E, S., Functional Specification For a Generic C3I Station, M.S. Thesis, 
Naval Postgraduate School, Monterey, California, September 1990. 

8. Transportable Applications Environment (TAE) Plus, National Aeronautics and 
Space Administration, Goddard Space Flight Center, January 1990. 

9. Kilic, M., Static Schedulers for Embedded RealJTime Systems, M.S. Thesis, Naval 
Postgraduate School, Monterey, California, December 1989. 

10. Mok, A., "A Graph Based Computational Model for Real-Time Systems", 
Proceedings of the IEEE International Cottference on Parallel Processing, 
Pennsylvania State University, 1985. 


301 




BIBLIOGRAPHY 


Aldzer, C, Implementation of a Language Translator for the Computer Aided 
Prototyping System, M.S. Thesis, Naval Postgraduate School, Monterey, California, 
December 1988. 

Beam, W. R., Command. Control, and Communications Engineering, McGraw-Hill, 
1989. 

Booch, G., Software Engineering with Ada, 2d ed., Benjamin-Cummings, 1987. 

Cohen, N., Ada as a Second Language, McGraw-Hill, 1986. 

Cummings, M. A., The Development of User Interface Tool for the Computer-Aided 
Prototyping System, M.S. Thesis, Naval Postgraduate School, Monterey, California, 
December 1990. 

Gonzales, D. W., Ada Programmer’s Handbook and Language Reference Manual, 
Benjamin-Cummings, 1991. 

Luqi, "Handling Timing Constraints in Rapid Prototyping", Proceedings of the 22nd 
Annual Hawaii International Conference on System Sciences, IF-F.F Computer 
Society, pp.4-17-424, January 1989. 

Luqi, Rapid Prototyping for Large Software System Design, Ph.D. Dissertation, 
University of Minnesota, Minneapolis, Minnesota, May 1986. 

Luqi, and Ketabchi, M., "A Computer-Aided Prototyping System", IEEE 
Transactions on Software Engineering, October 1988. 

Naval Research Advisory Committee, "Next Generation Computer Resources", 
Committee Report, February 1989. 

Ng, P. A. and Yeh, R. T., Modern Software Engineering Foundations and Current 
Perspectives, Van Nostrand Reinhold, 1990. 

Marlowe, L., A Scheduler for Critical Time Constraints, M.S. Thesis, Naval 
Postgraduate School, Monterey, California, December 1988. 

Massachusetts Institute of Technology, X Window System Manual, 1988. 


303 





OiT, George E., Combat Operations C3I: Fundamentals and Interactions, Air 
University Press, Maxwell Air Force Base, Alabama, 1983. 

Palazzo, F. V., Integration of the Execution Support System for the Computer-Aided 
Prototyping System (CAPS), M.S. Thesis, Naval Postgraduate School, Monterey, 
California, September 1990. 

PDW 120-S-00533(Rev.B, Change 4), "Over-the-Horizon Targeting (OTH-T) Gold 
Reporting Format", Naval Tactical Interoperability Support Activity, 30 June 1989. 

Schneiderman, B., Designing the User Interface: Strategies for Effective Human- 
Computer Interaction, Addison-Wesley, 1987. 

Skansholm, J., Ada from the Beginning, Addison-Wesley, 1988. 

Stankovic, J. A. and Ramamritham, K., Hard-Real Time Systems Tutorial, Computer 
Society Press, 1988. 

Sun Microsystems, Sun Documentation Manual, 1989. 

Tanik, M. and Yeh, R.T., "Rapid Prototyping in Software Development", Computer, v. 
22, n. 5,pp. 9-10, May 1989. 

United States Depanment, Reference Manual for the Ada Programming Language, 
1983. 


304 





INITIAL DISTRIBUTION LIST 


Defense Technical Information Center 
Cameron Station 
Alexandria, VA 22304-6145 

Dudley Knox Library 
Code 52 

Naval Postgraduate School 
Monterey, CA 93943 

Office of the Chief of Naval Operations (OP-094) 

Attn: VADM Tuttle 
Department of the Navy 
Washington. DC 20350-2000 

Office of the Chief of Naval Operations (OP-094H) 

Attn: Dr. John Davis 
Department of the Navy 
Washington. DC 20350-2000 

Office of the Chief of Naval Operations (OP-940) 
Department of the Navy 
Washington, DC 20350-2000 

Office of the Chief of Naval Operations (OP-940C) 
Department of the Navy 
Washington, DC 20350-2000 

Commander, Space and Naval Warfare Systems Command 
Attn: Captain John Gauss, PMW-162 
Washington, DC 20350-2000 

Office of the Chief of Naval Operations (OP-942) 
Department of the Navy 
Washington, DC 20350-2000 


Office of the dlhief of Naval Operations (OP-942E) 
Department of the Navy 
Washington, DC 20350-2000 






Office of the Chief of Naval Operations (OP-942F) 
Department of the Navy 
Washington, DC 20350-2000 

Office of the Qtief of Naval Operations (OP-942G) 
Department of the Navy 
Washington, DC 20350-2000 

Prof. Luqi, Code CS/Lq 
Naval Postgraduate School 
Monterey, CA 93943 

CDR Gary Hughes, Code CS/Hu 
Naval Postgraduate School 
Monterey, CA 93943 

Chief of Naval Research 
Atm: RADM W. Miller 
800 North Quincy Street 
Arlingtion, VA 22217-5000 

Commander, Naval Sea Systems Command 
Atm: LCDR Scott Kelly 
Codc06D3131 

Washington, DC 20362-5101 

Commander, Naval Sea Systems Command 

Atm: Bill Wilder 

PMS412 

Washington, DC 20362-5101 

NOSC, Code 805 

Atm: Mr. Jack Stawiski 

San Diego, CA 92152-5000 

NOSC, Code 40 

Director of Computer Technology 

Atm: Dr. Waslowski 

San Diego, CA 92152-5000 

Naval Surface Warfare Center 
Atm: Philip Q. Hwang (U33) 

Silver Spring, MD 20903-5000 







Director of Research Administration 
Code 012 

Naval Postgraduate School 
Monterey, CA 93943 

Chairman, Code CS 
Computer Science Department 
Naval Postgraduate School 
Monterey, CA 93943 

/• 

Prof. Carl R. Jones 

* C3 Academic Group, Code CC 

Naval Postgraduate School 
Monterey, CA 93943 

Prof. Michael G. Sovereign, Code OR/Sm 
Naval Postgraduate School 
Monterey, CA 93943 

Office of Naval Technology 
Attn: CDR Jane Van Fossen, Code 227 
800 Nonh Quincy Street 
Arlingrion. VA 22217-5000 

Office of Naval Research 
Attn: Dr. Van Tilborg 
Computer Science Division, Code 1133 
800 North Quincy Street 
Arlingrion, VA 22217-5000 

Office of Naval Research 
Atm: Dr. R. Wachter 
Computer Science Division, Code 1133 
800 North Quincy Street 
Arlingrion, VA 22217-5000 

* National Science Foundation 

^ Attn: Dr. K. C. Tai 

Division of Computer and Computation Research 
Washington, DC 20550 


307 



Ada Joint Project Office 
OUSDRE (D&AT) 

Attn; Dr. John Solonuin 
The Pentagon 
Washington, DC 20301 

Assistant Secretary of the Navy(RD&A) 

Attn: Mr. G. Cann 
Washington, DC 20310 

Deputy Assistant Secretary of the Navy (C3I, EW & S) 
Attn: Dr. E. Whitman 
Washington, DC 20310 

Defence Advanced Research Projects Agency (DARPA) 
Integrated Strategic Technology Office (ISTO) 

Attn: Dr. B. Boehm 
1400 Wilson Boulevard 
Arlingtion, VA 22209-2308 

Defence Advanced Research Projects Agency (DARPA) 
Integrated Strategic Technology Office (ISTO) 

Atm: Dr. E. Mettala 
1400 Wilson Boulevard 
Arlingtion, VA 22209-2308 

Department of the Air Force 
Director of Computer Sciences 
Atm: Dr. Charles Holland 
Bolling AFB, DC 20332-6448 

U.S. Army Research Office Elec. Div. 

Atm: Dr. David Hislop 

4300 S. Miami Boulevard 

Research Triangle Park, NC 27709-2211 

Dr. Raymond Yeh 
ISSI, Echelon 4, Suite 250 
9420 Research Boulevard 
Austin, TX 78759 

LTJG Cengiz Kesoglu 

Nuri Pamir (Tad. Duz Sok. 51/19 

Kecioren, ANKARA TURKEY 








LTJG Vcdat Coskun 

Visnezade Mah. Catlak Cesme Sok. 13/6 

Besiktas, 80680 ISTANBUL TURKEY 

Kara Harp Okulu Kutuphanesi 
Kara Harp Okulu Komutanligi 
Bakanliklar, ANKARA TURKEY 

Deniz Harp Okulu Kutuphanesi 
Deniz Harp Okulu Komutanli^ 

Tuzla, ISTANBUL TURKEY 

Hava Harp Okulu Kutuphanesi 
Hava Harp Okulu Komutanligi 
YesUyurt, ISTANBUL TURKEY 






