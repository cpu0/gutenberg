224 472 



REPORT DOCUMENTATION PAGE 


Form Approved 
OMB No. 0704-0183 


Public reporting burden for this collection of information is estimated to average i hour per response, including the time for reviewing instructions, searcnmg existing data sources, 
gathering and maintaining the data needed, and completing and reviewing the collection of information. Send comments reqardmg this burden estimate or an/ other aspect of this 
collection of information, including suggestions for reducing this burden to Washington Headquarters Services. Directorate for information Operations and Reports, 1215 Jefferson 
Davis Highway. Suite 1204, Arlington, VA 22202-4302. and to the Office of Management and Budget. Paperwork Reduction Project (0704-0188). Washington, DC 20S03. 


1. AGENCY USE ONLY (Leave blank) 2. REPORT DATE 3. REPORT TYPE / 

_ 1990 _LitefijAtea 

4. TITLE AND SUBTITLE 

THE EFFECT OF SOFTWARE REUSABILITY ON INFORMATION THEORY 
BASED SOFTWARE METRICS 


6. AUTHOR(S) 

WILLIAM R. TORRES 


1. PERFORMING ORGANIZATION NAME(S) ANO ADDRESS(ES) 

AFIT Student at: Oklahoma State University 


I. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

AFIT/CI 

Wright-Ptatterson AFB OH 45433 


3. REPORT TYPE AND DATES COVERED 





8. PERFORMING ORGANIZATION 
REPORT NUMBER 

AFIT/CI/CIA -90-61 


10. SPONSORING/MONITORING 
AGENCY REPORT NUMBER 



12a. DISTRIBUTION/AVAILABILITY STATEMENT 

Approved for Public Release IAW AFR 190-1 

Distribution Unlimited 

ERNEST A. HAYGOOD, 1st Lt, USAF 

Executive Officer, Civilian Institution Programs 


13. ABSTRACT (Maximum 200 words) 


12b. DISTRIBUTION CODE 


DT1C 

^ELECTEf* 
WaUGO 119901 1 

O B U 

<K? . • 



17. SECURITY CLASSIFICATION 
OF REPORT 

UNCLASSIFIED 


NjN 7540-01-280-5500 


18. SECURITY CLASSIFICATION 
OF THIS PAGE 


19. SECURITY CLASSIFICATION 
OF ABSTRACT 


15. NUMBER OF PAGES 

246 


16. PRICE CODE 


20. LIMITATION OF ABSTRACT 


90 07 


Standard Form 298 {Rev 2-89) 
Prescribed bv ^NSi Sid 239-'8 

799.n? 























THE EFFECT OF SOFTWARE REUSABILITY ON 


INFORMATION THEORY BASED SOFTWARE METRICS 


William R. Torres, Capt, USAF 


Date of Degree: July, 1990 Pages in Study: 246 

Degree Awarded: Master of Science 

in Computing and Information Science 

Institution: Oklahoma State University 

ABSTRACT 


/•A 

The main purpose of this thesis is to theoretically 
investigate the effect of reusing software on metrics that are 
based on the entropy function of communication information 
theory. R. Chanon's Entropy Loading and E. Chen's Control 
Structure Entropy were applied to C and Ada programs obtained 
from the open literature. Four units of program decomposition 
(statement, component, module, and program) along Chanon's 
definition of an object were introduced to classify software 
reuse units. A total of three versions for each of the programs 
included in the .udy were considered (i.e., optimum reuse, 
intermediate re.^e, and no reuse). The lines of code metric was 
utilized to quantify the amount of nonreusable code in each of 
the versions of the programs. The lines of code metric was not 
applied to the "reused" segments of code since they are not 
considered part of the effort of writing the new program. 

Pearson product-moment correlations were computed between the 
metrics studied and the lines of code metric. 

Entropy loading was found to be inversely proportional to 
the amount of reuse present in the programs. Strong correlations 
were found between entropy loading and the size of the resulting 
new program, measured by the lines of code metric. Consequently, 
entropy loading can presumably provide a mechanism for selecting 
the optimum reuse case among different possibilities for reuse. 
Control structure entropy was also found to be a good indicator 
of reuse. Strong correlations exist between control structure 
entropy and the size of the resulting new program. 


1 


' \ 

o 



90 


07 



THE EFFECT OF SOFTWARE REUSABILITY ON 


INFORMATION THEORY BASED SOFTWARE METRICS 
William R. Torres, Capt, USAF 

Date of Degree: July, 1990 Pages in Study: 246 

Degree Awarded: Master of Science 

in Computing and Information Science 

Institution: Oklahoma State University 

ABSTRACT 


The main purpose of this thesis is to theoretically 
investigate the effect of reusing software on metrics that are 
based on the entropy function of communication information 
theory. R. Chanon's Entropy Loading and E. Chen's Control 
Structure Entropy were applied to C and Ada programs obtained 
from the open literature. Four units of program decomposition 
(statement, component, module, and program) along Chanon's 
definition of an object were introduced to classify software 
reuse units. A total of three versions for each of the programs 
included in the study were considered (i.e., optimum reuse, 
intermediate reuse, and no reuse). The lines of code metric was 
utilized to quantify the amount of nonreusable code in each of 
the versions of the programs. The lines of code metric was not 
applied to the "reused" segments of code since they are not 
considered part of the effort of writing the new program. 

Pearson product-moment correlations were computed between the 
metrics studied and the lines of code metric. 


Entropy loading was found to be inversely proportional to 
the amount of reuse present in the programs. Strong correlations 
were found between entropy loading and the size of the resulting 
new program, measured by the lines of code metric. Consequently, 
entropy loading can presumably provide a mechanism for selecting 
the optimum reuse case among different possibilities for reuse. 
Control structure entropy was also found to be a good indicator 
of reuse. Strong correlations exist between control structure 
entropy and the size of the resulting new program. 




Unannounced 
Justlft cation. 


By--- 

Distr ibution/_ 

Ava ilability Codes 
[Avail and/or 


Diet 


\ 


Special 


□ □ 








THE EFFECT OF SOFTWARE REUSABILITY 


ON INFORMATION THEORY BASED 
SOFTWARE METRICS 


By 

WILLIAM R. TORRES 
Bachelor of Science 
in Electrical Engineering 
University of Puerto Rico 
Mayaguez, Puerto Rico 
1985 


Submitted to the Faculty of the 
Graduate College of the 
Oklahoma State University 
in partial fulfillment of 
the requirements for 
the degree of 
MASTER OF SCIENCE 
July, 1990 






Dean of the Graduate College 


11 











ACKNOWLEDGMENTS 


I wish to express sincere appreciation to Dr. Mansur H. 
Samadzadeh for his encouragement and advice throughout my 
thesis research. His dedication and attention to detail 
made all the work required to complete this thesis 
worthwhile. Many thanks also go to Dr. G. E. Hedrick and 
Dr. John P. Chandler for serving on my graduate committee. 

My wife, Maria, and my daughters Maria C. and Diana B., 
encouraged and supported me all the way and kept me 
motivated to achieve the end goal. Their love and support 
made everything much easier. I also thank my parents, 
William and Nelida, and my In Laws, Jose and Marian Setien, 
for their support, encouragement, and many prayers. 






TABLE OF CONTENTS 


Chapter Page 

I. INTRODUCTION. 1 

II. LITERATURE REVIEW . 3 

2.1 Fntropy Function of Information Theory. 3 

2.1.1 Entropy and the Software 

Development Process. 3 

2.1.2 Information Theory Based 

Metrics. 5 

2.1.2.1 Entropy Loading . 5 

2.1.2.2 Control Structure 

Entropy . 9 

2.1.2.3 Additional Metrics. . . 13 

2.2 Software Reusability.15 

2.2.1 Definitions.16 

2.2.2 Advantages and Limitations ... 17 

2.2.3 Current Trends.19 

III. DESCRIPTION OF THE EXPERIMENT.22 

3.1 Design Approach.22 

3.1.1 Introduction.22 

3.1.2 Reuse Candidates . 22 

3.1.3 Theoretical Perspective and 

Limitations.25 

3.1.4 Coupling and Cohesion.27 

3.2 Carrying out the Experiment.29 

3.2.1 Quantifying Software Reuse ... 29 

3.2.2 Experiment Operation . 30 

3.2.2.1 Programs Developed to 

Collect the Data.30 

3.2.2.2 Data Collection.31 

3.2.3 Programs Studied in the 

Experiment.32 

3.2.3.1 C Language Programs ... 33 

3.2.3.2 Ada Language Programs . . 3 5 

IV. ANALYSIS OF THE MEASUREMENTS.3 9 

4.1 Description of the Analysis.39 

4.2 Entropy Loading Analysis.43 

4.3 Control Structure Entropy Analysis. . . 44 


IV 






























Chapter Page 

V. SUMMARY, CONCLUSIONS, AND FUTURE WORK.4 6 

REFERENCES.4 9 

SELECTED BIBLIOGRAPHY. 53 

APPENDIXES. 54 

APPENDIX A - PROGRAMS USED TO COMPUTE THE 

METRICS. 55 


APPENDIX B - ADA PROGRAMS INCLUDED IN THE STUDY . 70 
APPENDIX C - C PROGRAMS INCLUDED IN THE STUDY . . 92 


APPENDIX D - ENTROPY LOADING DATA TABLES.112 

APPENDIX E - EXECUTION FLOW CHARTS FOR PROGRAMS 

INCLUDED IN THE STUDY.193 

APPENDIX F - MAXIMAL INTERSECT NUMBER (MIN) 

CHARTS.200 

APPENDIX G - METRICS STATISTICAL DATA.222 


v 















LIST OF TABLES 


Table Page 

I. Testbed Program Sources.3 2 

II. Metrics Evaluated for Programs . 41 

III. Correlations Between Metrics . 42 

IV. Assumptions for the C Program fastfind, 

Case 1.113 

V. List of Assumption Numbers for Objects in the 

C Program fastfind, Case 1.116 

VI. Assumptions for the C Program fastfind. 

Case 2.117 

VII. List of Assumption Numbers for Objects in the 

C Program fastfind, Case 2.12 0 

VIII. Assumptions for the C Program fastfind, 

Case 3.121 

IX. List of Assumption Numbers for Objects in the 

C Program fastfind, Case 3.124 

X. Assumptions for the C Program mail, Case 1 . .126 

XI. List of Assumption Numbers for Objects in the 

C Program mail, Case 1.128 

XII. Assumptions for the C Program mail, Case 2 . . 129 

XIII. List of Assumption Numbers for Objects in the 

C Program mail, Case 2.131 

XIV. Assumptions for the C Program mail, Case 3 . . 132 

XV. List of Assumption Numbers for Objects in the 

C Program mail, Case 3.135 

XVI. Assumptions for the C Program editor, Case 1 . 138 

















Table 


Page 


XVII. List of Assumption Numbers for Objects in the 

C Program editor, Case 1.14 0 

XVIII. Assumptions for the C Program editor, Case 2 . 141 

XIX. List of Assumption Numbers for Objects in the 

C Program editor, Case 2.14 4 

XX. Assumptions for the C Program editor, Case 3 . 146 

XXI. List of Assumption Numbers for Objects in the 

C Program editor, Case 3.150 

XXII. Assumptions for the Ada Program intlist. 

Case 1.153 

XXIII. List of Assumption Numbers for Objects in the 

Ada Program intlist, Case 1. . . ..155 

XXIV. Assumptions for the Ada Program intlist, 

Case 2.156 

XXV. List of Assumption Numbers for Objects in the 

Ada Program intlist, Case 2.158 

XXVI. Assumptions for the Ada Program intlist, 

Case 3.159 

XXVII. List of Assumption Numbers for Objects in the 

Ada Program intlist, Case 3.161 

XXVIII. Assumptions for the Ada Program calc, Case 1 . 163 

XXIX. List of Assumption Numbers for Objects in the 

Ada Program calc, Case 1.164 

XXX. Assumptions for the Ada Program calc, Case 2 . 165 

XXXI. List of Assumption Numbers for Objects in the 

Ada Program calc, Case 2.167 

XXXII. Assumptions for the Ada Program calc, Case 3 . 168 

XXXIII. List of Assumption Numbers for Objects in the 

Ada Program calc, Case 3.170 

XXXIV. Assumptions for the Ada Program address. 

Case 1.172 

XXXV. List of Assumption Numbers for Objects in the 

Ada Program address, Case 1.17 6 


Vll 























Table 


Page 


XXXVI. Assumptions for the Ada Program address. 

Case 2.177 

XXXVII. List of Assumption Numbers for Objects in the 

Ada Program address, Case 2.181 

XXXVIII. Assumptions for the Ada Program address, 

Case 3.183 

XXXIX. List of Assumption Numbers for Objects in the 

Ada Program address, Case 3.189 


vm 














r 


1 

! 


LIST OF FIGURES 


Figure Page 

1. Maximal Intersect Number Examples . 10 


2. Execution Flow Chart for the C Program fastfind . . 194 

3. Execution Flow Chart for the C Program mail .... 195 

4. Execution Flow Chart for the C Program editor . . . 196 

5. Execution Flow Chart for the Ada Program intlist. . 197 

6. Execution Flow Chart for the Ada Program calc . . . 198 

7. Execution Flow Chart for the Ada Program address. . 199 


8. Maximal Intersect Number Chart for the C Program 

fastfind. 201 

9. Maximal Intersect Number Chart for the C Program 

mail.204 

10. Maximal Intersect Number Chart for the C Program 

editor.208 

11. Maximal Intersect Number Chart for the £da Program 

intlist.212 

12. Maximal Intersect Number Chart for the Ada Program 

calc.214 

13. Maximal Intersect Number Chart for the Ada Program 

address.217 


IX 













"1 


CHAPTER I 

INTRODUCTION 

The notion of reusing software dates back to the early 
stages of the history of computing when subroutine libraries 
were developed [SOMME89]. 

The advantages and limitations of software reuse have 
been widely publicized [BIGGE87, BOLDY89, PRIET87, RATCL87, 
and SOMME89]. In particular, it is clear that the extensive 
reuse of software is likely to reduce software costs during 
the design and implementation phase (software already exists) 
and during the validation phases (software has already been 
checked) [SOMME89]. 

The main purpose of this thesis is to theoretically 
investigate the application of software quality assessment 
metrics to development environments that employ reuse 
techniques and principles in the construction of software 
systems. In particular, the effect of reusing software on 
the metrics that are based on the entropy function of 
communication information theory will be investigated. 

The following chapters define the metrics used in this 
study, describe the experimental design including how the 
datawere collected, discuss the analysis of the measure- 


1 





2 


merits, and summarize and conclude with recommendations for 
future work. 




CHAPTER II 


LITERATURE REVIEW 

2.1 Entropy Function of Information 
Theory 

2.1.1 Entropy and the Software 
Development Process 

In communication information theory, information is 
defined as "what we don't know about what is going to happen 
next" [SHANN64]. Information theory presents entropy as a 
synonym for information uncertainty or unpredictability. 
Therefore, entropy can be used as a measure of information. 

When an attempt is made to predict the outcome of an 
event, uncertainty approaches zero as the probability of an 
outcome approaches unity. On the other hand, uncertainty, 
as a function of the number of different things that can 
happen, reaches its maximum value when all the outcomes have 
the same probability of occurrence (i.e., in the case of 
equiprobable events). In other words, the more unpredicta¬ 
ble the output of a system, the more information it yields 
upon occurrence and the higher the entropy of the system, 
and vice versa. The entropy function, H, which measures 
information in bits is defined as 






4 


n 

Pz' • ' * ' Pn^ ~ ^ Pj (^/Pj) (^ ^ 

j = l 

where pj is the probability of occurrence of the jth event. 

van Emden [VANEK70] defines a system as a set of 
variables influencing one another. A challenge often faced 
by software designers when designing a system is managing 
the complexity resulting from the presence of a large number 
of variables and the fact that most of them influence many 
others. To alleviate this problem, Alexander [ALEXA64] 
states that a system composed of a set of variables, S, 
should be partitioned into subsets or subsystems 
(S 1f S 2 , ..., Sj, ..., S k ) in such a way that the 
interactions 1 among subsystems should be minimized with 
respect to the interactions within a subsystem. This 
partitioning process allows for the variables in Sj to be 
manipulated freely without constraints imposed by any of the 
other subsets. 

If a program structure could be decomposed into 
distinct classes of subsystems, the information contained in 
the structure can be measured [M0HAN79, M0HAN81, and 
VANEM7Q] by the entropy metric, H, based on Shannon’s 
communication information theory [SHANN64]. More specific¬ 
ally, the entropy metric H is defined for a system S as 

n 

H (S) = H(P,, . . . ,P n ) = Z { ( | Xj 1 / | X| )log 2 (|X|/|X j | ) } 

j = l 

1 An interaction is viewed as an information transfer 
within or among subsystems [ALEXA64]. 




5 


n 

or by simple algebraic manipulation 

H(S) = log 2 | X | - 1/ | X | 2 ()X j |log 2 |X j |) (2) 

j=l 

where X lf X 2 , X n are the distinct classes of 

subsystems, | Xj | denotes the cardinality of the set X ; , and 
Pj = I x j I / IX | . 

2.1.2 Information Theory Based Metrics 

Software metrics are usually categorized as either 
process metrics or products metrics. Process metrics are 
defined by Conte et al. [CONTES6] as "metrics that quantify 
attributes of the development process and of the development 
environment." Conte et al. also define product metrics as 
"measures of the software product." 

Product metrics are the most common metrics since they 
are easier to obtain as they "can be derived from analyzing 
the software itself using an automatic tool" [CONTE86]. 
Examples of product metrics include size of the product 
(lines of code), logic structure complexity (e.g., flow 
control and depth of nesting), and data structure complexity 
(number of variables used) [CONTE86]. 

Information theory based metrics can be classified as 
product metrics. The following subsections discuss various 
information theory based metrics. 

2.1.2.1 Entropy Loading . Section 2.1.1 described how 
we can use the entropy metric to measure the information 






6 


contained in a system. Using the same basic principles, we 
can use the entropy loading measure, as described by Chanon 
[CHAN073], "to measure the information shared among 
subsystems, as opposed to the information contained in each 

subsystem." 

According to Chanon [CHAN073], the term interaction, 
means "a shared assumption among two or more objects" where 
objects are defined as "an identified portion of a program 
that has net effects." The following is a list of 
assumptions identified by Chanon. 

1. Relationships that must hold prior to the 
execution of an object in order for its effects to 
be realized. 

2. Data structures or data values. 

3. Assumptions about the environment in which an 
object is executed, such as frequency of usage or 
order of computation. 

4. Assumptions based on mathematical theorems 
that are relevant to the problems being solved. 

Once all the assumptions have been identified, they can be 

recorded in what Chanon calls an obiect/assumption table . 

For a given program, such a table, T, is defined for all 

objects, I, and assumptions, J, such that 

/— 1, if object I makes assumption J 

T(I,J) = < 


0, otherwise 

According to van Emden [VANEM70] and as demonstrated by 
Chanon [CHAN073], the data contained in the object/assump¬ 
tion table characterizes the extent to which collections of 




7 


objects interact. This data is used in the calculation of a 
measure which van Emden and Chanon call entropy loading . 
Entropy loading is defined for a set of rows, S, in an 
object/assumption table at a given time in the development 
of a system. 

Assume that S is partitioned into subsets A and B such 
that A n B = 0 and A U B = S. Then C(S), the entropy 
loading of S, is given by 

C(S) = H (A) + H (B) - H (S) (3) 

where H(X) is given by the entropy metric mentioned in 
Equation (2). 

Suppose the table T of objects and assumptions is given 
as 



where A and B are subsets of the object set S, and a through 
f are the assumptions. For example, for row 1, the entry 1 
indicates that object 1 (an element of A) makes one assump¬ 
tion, a. H(A) is computed by considering the columns for 
which the entry for any object of A is 1, i.e., a, d, and f. 
In the submatrix composed of the columns a, d, and f, (100) 
occurs once, (001) occurs three times, (010) occurs once, 
and (000) occurs once. The total number of objects is six. 
Therefore, using Equation (2), we have 





8 


H(A) = log 2 6 - l/6[llog 2 l + 31og 2 3 + llog 2 l + llog 2 l] 
or 

H(A) = log 2 6 - l/6[3log 2 3] = 1.79 
Similarly, 

H (B) = log 2 6 - l/6[2log 2 2] = 2.25 
Since 1 occurs in each column at least once and each row is 
different, thus 

H(S) = log 2 6 = 2.58 

and 


C(S) = H(A) + H(B) - H(S) = 1.46 

Chanon [CHAN073] demonstrated that programs that 
possess small entropy loadings also possess properties 
consistent with the principles of "good" structure stated by 
Alexander [ALEXA64J, Dijkstra [DIJKS72], Parnas [PARNA71], 
and Simon [SIMON62] as follows: 

1. The information required to study, understand, 
and verify individual parts of a system is 
supplied in conjunction with those parts, and 
relatively little information about the rest of 
the system is required. 

2. Single parts can be changed drastically 
(algorithms and/or data structures) without 
requiring much knowledge of the rest of the system 
and without changing the rest of the system; i.e., 
drastic changes can actually be confined to single 
parts. 

3. Should an error occur as a result of the 
failure of one small part to function correctly, 
the error can be localized to that part of the 
system quickly and easily, permitting the error to 
be repaired using only a knowledge of that part. 

4. During system construction, each working group 
can be given an assignment to write a set of parts 
such that the assignment can be completed with 
very little communication between the groups. 






9 


Based on the aforementioned discussion, entropy loading 
can be used as a quality assessment metric to determine how 
"good" a program is, when compared to other input/output 
equivalent programs or different versions of the same 
program. 

2.1.2.2 Control Structure Entropy . Chen [CHEN78] 
defines a measure of program control complexity based on an 
information theoretic viewpoint. Given a strongly-connected 
proper flow chart 2 which results from structured 
programming, Chen defines the maximal intersect number, MIN, 
as "the maximum number of edges which can be intersected by 
a continuous line drawn such that the line never enters any 
region, including the external region, more than once." 

Chen utilizes three basic types of control structures 
[CHEN78] to obtain MIN from the charts: 1) SEQUENCE, 2) IF p 
THEN f ELSE g, and 3) WHILE p DO f. These structures are 
shown in Figure l.a. 

If a flow chart or graph is not strongly connected, but 
can be visualized as consisting of more than one strongly- 
connected subparts connected in series, MIN can be obtained 
from 

n 

MIN = Z MIN. - 2n + 2 (4) 

i=l 


2 A flow chart is strongly connected if there is a path 
from node a to node b for every pair of distinct nodes a and 
b [CONTE86]. A flow chart is proper if each node can be 
reached from the entry point of the program and if each 
control structure has only one entry and one exit [SHOOM83]. 






















where n is the number of strongly-connected subparts and 
MINi is the MIN for the ith strongly-connected subpart. 
Figure l.b illustrates an example obtained from [CHEN78] in 
which two weakly connected subparts with MIN's equal to 4 
and 5, respectively, yield a MIN equal to 7 for the combined 
chart (i.e., 4 + 5 - 2(2) + 2 = 7). 

The attribute MIN can also be computed analytically 
from the expression MIN = Z n + 1 where Z n is given by the 
following formula 
n 

Z n = 1 + E log 2 (2 Pj + gp (5) 

j=2 

where n is the number of decision symbols on the flow chart 
or graph, q^ is the probability that the j th IF symbol is 
forming a serial relation with any of its preceding and 
adjointed 3 IF symbols, and Pj = 1 - q-. For a given flow 
chart, qj is either 1 or 0 depending on whether it is in the 
specified serial relationship. Considering the left subpart 
in Figure l.b (three IF symbols), we have that p 2 = p 3 = 1 
and q 2 = q 3 = 0 since neither IF symbol is serially 
connected to their preceding IF symbol. Consequently we 
have that 

Z 3 = 1 + log 2 (2 + 0) + log 2 (2 + 0) =1 + 1 + 1 = 3 

thus 

MIN = Zj+l = 3 + l = 4 


3 Adjointed IF symbols are two IF symbols which can be 
connected without passing through any vertices (nodes) which 
belong to a third IF symbol [CHEN78]. 







12 


which is the same result obtained earlier. 

Chen describes a programmer to be (in information- 
theoretic terms [SHANN64]) a "channel" who is to handle 
information from a program specification or problem 
statement described as the "source." A source of informa¬ 
tion is characterized by the variety of output symbols that 
it produces. In this case, the output is a sequence of IF 
symbols. The other components of a proper flow chart, i.e., 
function nodes and collecting nodes are considered and 
ignored because function nodes do not contribute to the 
branching or nesting structure of a flow graph and 
collecting nodes are merely converging points for the 
branches of the corresponding decision points. 

Z n is defined as the control structure entropy of an 
information source when it emits n IF symbols. This control 
structure entropy is a measure of the control variety of a 
source's output and is correlated with the conceptual 
complexity of the program [CHEN78]. The higher the Z n 's 
value, the more complex the program is. In fact, MIN was 
originally proposed to address some of the deficiencies of 
McCabe's cyclomatic complexity measure [MCCAB76]. 

For a given total number of IF symbols, the programming 
job can be modeled [CHEN78] by the task of determining the 
exact flow chart structure which will determine the p-' s and 
qj's in Equation (5). An approximation to Equation (5) can 
be obtained by assuming Pj = = 1/2 [CHEN78]. Substitu¬ 

ting these values in Equation (5), we have 







13 


Z n = (n - l)log 2 3 - n + 2. Given the number of IF symbols 
that a program is to have, Z n can be calculated easily since 
it only depends upon n. 

Based on the work by Chen [CHEN78], control structure 
entropy can be used as a quality assessrent metric to 
determine how "complex" a program is, when compared to other 
programs or different versions of the same program. 

2.1.2.3 Additional Metrics. In addition to the 
entropy loading and control structure entropy metrics, other 
information theory based software metrics have been proposed 
by, among others, E. Berlinger, M. H. Samadzadeh and W. R. 
Edwards, and T. T. Lee. 

Berlinger [PLRLI80] proposed the following information 
theory based complexity measure. Given a program, he counts 
the frequency, f, of all tokens in the program. Berlinger 
also assumed that the probabilities of the occurrence of the 
tokens used in the program are known. The complexity 
measure, M, is defined as 
n 

M = -Z fj log 2 pj (6) 

j=l 

where n is the total number of distinct tokens, and f. and 
Pj are the frequency and probability of occurrence of the 
j th token, respectively. 

Berlinger [BERLI80] presents two interpretations for 
this measure. First, from an information theory point of 
view, assuming the program to be a message, the measure 





14 


represents the total information contained in the program. 
Second, the measure represents the total length in bits 
required to encode the program assuming that each token is 
to be coded using a uniform encoding scheme. 

One problem with this measure is that the Pj' s need to 
be accumulated over a period of time at the installation 
where the new program is to be written. Consequently, the 
measure is of little help to a programmer at a different 
installation where the possibility of a completely different 
set of pj's exists. This makes two purportedly similar 
programs, written in two different installation, incompara¬ 
ble. 

Samadzadeh and Edwards presented a model that regards 
the understanding process of software as a process of 
grouping together the tokens of a software document (either 
distinct tokens or all of the tokens) that have certain 
characteristics in common [SAMAD88]. According to the 
authors, "this model captures the amount and some of the 
structure of the information present in the software 
document." A simple example is the classification of 
program tokens into operators and operands, as originally 
used by Halstead [HALST79]. 

The measure, denoted as R, is called residual complex¬ 
ity. This measure is based on the difference between the 
maximum value of the computational work and the computatio¬ 
nal work, w, of a partition, n which is the result of 
classifying a piece of software into q token types. The 






15 


"1 

! 


residual complexity can be obtained from the equation 

R = N log 2 N - N H (N^/N, N 2 /N, . .., N^/N) (7) 

where N is the total number of tokens, N s is the number of 
tokens in the i th block of the partition, and H is the 
entropy function. 

Lastly, Lee [LEE87] uses Shannon's information 
theoretic entropy metric to quantify the information 
associated with a set of attributes. An attribute is a 
symbol taken from a finite set n = (A,, ..., A n ) [LEE87]. 

For each attribute k jt 1 < j < n, there is a set of possible 
values, denoted DOM(Aj) , which comprise its domain. 

Database design is based on the concept of data dependency, 
which is the interrelationship between data contained in 
various sets of attributes [LEES7]. In particular, Lee 
[LEE87] states that functional, multivalued and acyclic join 
dependencies play an essential role in the design of 
database schemas. Lee proves that data dependencies can be 
formulated in terms of entropies making the numerical 
computation and testing of data dependencies feasible. 

2.2 Software Reusability 

The notion of software reuse has been around since the 
early stages of the history of computing when the main 
motivation for the development of subroutine libraries was 
software reuse [SOMME89]. Software reuse has also been 
associated with software portability. According to 
Sommerville [SOMME89], "porting a program to another 






16 


computer can be considered an example of software reuse 
although it is possible to reuse a program which is not 
portable and can only run on a single computer." 

2.2.1 Definitions 

Reusability is, as defined by Wegner [WEGNE83], "a 
general engineering principle whose importance derives from 
the desire to avoid duplication and capture commonality in 
undertaking classes of inherently similar tasks." In the 
title and body of this thesis the notion of reusability has 
been used with Wegner's definition in mind. 

Prieto-Diaz [PRIET87] defines reuse as "the use of 
previously acquired concepts and objects in a new situation" 
and reusability as "a measure of the ease with which one can 
use those previous concepts and objects in the new 
situation." Consequently, in order for software reusability 
to be beneficial, the effort to reuse a piece of software 
needs to be smaller than the effort required to develop the 
software from scratch. 

Conceptual complexity and size are two common and 
related software problems. As these problems continue to 
loom larger, software reuse and reusability is starting to 
be looked upon as a possible solution; as demonstrated by 
the increasing attention it has received in the last seven 
to ten years. In spite of this fact, not a lot of effort 
has been devoted to standardizing and implementing reuse by 
major companies in the USA. On the other hand, Matsumoto 






17 

[MATSU84] demonstrated that Japanese industries had been 
reusing software for the past six to seven years. 

2.2.2 Advantages and Limitations 

When we think of software reuse, one of the first 
things that comes to mind is the reductions in cost as the 
number of components that must be specified, designed, 
implemented, and tested is reduced. However, Sommerville 
[SOMME89] states that "it is difficult to quantify the 
actual cost reductions attained by reusing software; if in 
fact there are any." The number of applications where code 
can be reused without any modification whatsoever is very 
small. Nevertheless, cost reduction is not the only 
advantage of software reusability. Some of the other 
advantages of software reusability are mentioned below. 

Software reuse increases system reliability [LUBAR86b 
and SOMMER89]. It is widely accepted that operational use 
adequately tests software components, and reused components, 
which have been previously in operational use, should be 
more reliable than brand new components. Also, if a 
component is originally developed to be reusable, Freeman et 
al. and Lubars [FREEM83 and LUBAR86b] state that "the 
debugging costs can be amortized among the products that 
reuse the component." 

As a result of software reuse, programming resource 
utilization can be improved [SOMMER89]. The availability of 
reusable software allows for a better distribution of 







programming resources since not all the code needed is to be 
developed anew. Sommerville states that "application 
specialists can develop higher reusable components that 
encapsulate their knowledge." 

Another advantage is the reduction in software 
development time [SOMMER89]. Reusing components speeds up 
system production because both development and validation 
time should be reduced. 

However, as expected, software reusability is not a 
perfect science and there are limitations that must be kept 
in mind. This is specially true since some researchers 
think that the limitations and disadvantages outweigh the 
advantages. 

The first problem is what to do with a piece of 
software once it has been determined that it is a candidate 
for reuse. In a recent article, Tracz [TRACZ88] presents 
his "Golden Rules of Reusability." Tracz says that "before 
you can reuse something, you need to find it, know what it 
does, and know how to reuse it", which go along with the 
need for means of cataloging, classifying, and retrieving 
software components. 

Lubars [LUBAR86a] describes the problem of finding a 
desired piece of reusable code as the most significant 
technical barrier to code reusability. The problem of 
software classification has been addressed by Prieto-Diaz 
and Freeman [PRIET87] where they attempt to rank reusable 
software components using a reuse effort estimation metric. 







19 


Another problem is the not-developed-here syndrome 
experienced by some programmers and reflected in some 
company policies that do not allow non-local programs to be 
utilized. They prefer to write their own code because they 
believe that they can improve on the reusable component. 

But even if this is true, Cheatham and Sommerville [CHEAT83 
and SOMMER89] state that "it is at the expense of greater 
risks and higher costs." 

The last limitation we are concerned with involves the 
reusable code itself. Researchers are concerned about how 
specific or, on the other hand, abstract the code needs to 
be before reuse pays off. This topic is discussed in the 
next section on current trends. 

2.2.3 Current Trends 

There are two main schools of thought on software 
reusability [BIGGE87 and PRIET87]. The first one promotes 
the reuse of ideas and knowledge acquired while developing 
software, while the other promotes the reuse of particular 
artifacts and components. Although the second approach is 
more popular, researchers disagree on how abstract the code 
needs to be before it may be reused. Kernighan [KERNI84] 
presents reuse at the program level utilizing the UNIX 4 
pipe. 


4 UNIX is a Trademark of AT&T Bell Laboratories. 







20 


On the other hand, Matsumoto [MATSU84] promotes reusing 
modules defined in higher levels of abstraction to increase 
the scope of the reusable code. According to Matsumoto, 
"there are four levels of specification: requirements, 
design, program, and source code." A module, when 
originally conceived, is transformed from the requirements 
level, into the design level, the program level, and finally 
into the source code level. When a module is to be reused, 
the requirements level of the new module is compared to the 
requirements levels of previously designed modules and when 
a match is found, a trace is made from the requirements 
level to the source code level through previously made 
transformations to reuse the source code. 

Other researchers that promote the use of higher 
abstract levels for software reusability include Kaiser and 
Garlan, Goguen, and Cheng et al. Kaiser and Garlan 
[KAISE87] promote the use of Meld, "a language that blends a 
package library, automatic software generation, and 
object-oriented programming approaches to reusability." In 
their approach, a software system that needs to be developed 
is written in Meld and then translated into the desired 
implementation language. 

Goguen [GOGUE86] presents a "library interconnection 
language," called LIL, to assemble large programs from 
existing entities by combining Ada 5 programming language 

5 Ada is a Trademark of the U.S. Department of Defense 
(Ada Joint Program Office). 









21 


specification parts with commands for interconnecting 
components to form systems. In a somewhat different 
approach, Cheng, Lock, and Prywes [CHENG84J present a very 
high level language, Model, which acts as a program gene¬ 
rator to allow the nonprogrammer professional to design a 
system by solely describing the data interrelationships 
without referencing any computer operations. The result, 
according to Cheng et al., is "a language that is free of 
the conventional programming control and flow concepts, and 
is thus simpler and easier to use." 










CHAPTER III 


DESCRIPTION OF THE EXPERIMENT 

3.1 Design Approach 


3.1.1 Introduction 

In this study the intent is to explore theoretically 
the effects of software reusability on Chanon's entropy 
loading metric [CHAN073] and Chen's control structure 
entropy [CHEN78]. But before either calculation can be 
applied, we need to establish some guidelines for 
identification of the "program parts" that are to be reused. 
This is needed because a program part is not defined in 
Chanon's definition of an object [CHAN073], in fact, it is 
left, apparently intentionally, an unspecific and generic 
concept (See Chapter II for a discussion of Chanon's entropy 
loading metric). 

3.1.2 Reuse Candidate s 

Even though program decomposition or partitioning is, 
in general, language and application dependent, we define 
four units of program decomposition which are objects that 
can be considered to be along Chanon's object definition, 


22 




are visible to one another, and can be candidates for 
reuse. These units of decomposition are statements, 
components, modules, and the obvious one-block rtition, 
the program itself. The definitions of the four units of 
decomposition follow. 

The first unit of decomposition is a statement which is 
the lowest level at which reuse will be considered and is 
defined as any executable instruction of a program which 
makes assumptions about, and is visible to, any other object 
in the program. Executable instructions that do not make 
assumptions are not considered statements, e.g., NEW_LINE in 
Ada or printf("\n") in C. These instructions do not depend 
on any other instruction for their execution. 

The unit of the next higher level decomposition is a 
component . A component is a collection of one or more 
contiguous statements having a name and represented by the 
implementation of a procedure or algorithm. None of the 
statements in a component are visible to any other object. 
The only assumptions that a component can make are about the 
parameters passed to it when invoked or the visibility of 
other objects and/or global variables. Examples of 
components are functions in C, and procedures and functions 
in Ada. 

A module is a unit of decomposition or a candidate for 

’An object, a, is visible to any other object, b, if b is 
in control of program execution and control of execution can 
be transferred from object b to a. 





24 


reuse above the component level. A module is a collection 
of components which also has a name and can be invoked by 
any other object. Analogously to the component, none of the 
components inside a module are visible to any other object. 
The only assumptions that a module can make are about the 
parameters passed to it when invoked or the visibility of 
other objects and/or global variables. Examples of modules 
are procedures and packages in Ada and functions in C. 

The highest level of decomposition or reuse is 
obviously the program itself. An entire program is the 
highest level at which reuse can occur. A program is 
defined as a collection of modules. It is an extreme case 
since it is the only block in the partition. 

The four definitions offered above for an object are 
not supposed to be rigid prescriptive units of reuse. They 
are merely the easily recognizable milestones along the 
decomposition spectrum. In other words, a candidate for 
reuse can consist of a mixture of the above-mentioned units. 

Other possibilities for reuse candidates are plans and 
delocalized plans [LETOV86]. These are stereotypic action 
sequences in a program which are not necessarily contiguous 
segments of code. However, because of the absence of a 
standard or a widely-accepted set of criteria for 
identification of plans across programming languages and 
application areas, only a brief abstract treatment of 
non-contiguous "program parts" is mentioned in the next 


section. 







25 


3.1.3 Theoretical Perspective and 
Limitations 

Now that we have defined the possible ways in which the 
objects in a program can be identified, we need to find a 
way to relate these objects to program reusability. But 
before we do that, we need to establish a basis for 
comparison. Assume that there is a program, S, consisting 
of n m modules, n c components, and n s statements. Modules are 
composed of components and components are composed of 
statements. Consequently, in general, to keep the potential 
for reuse high, S can be considered as a set of modules plus 
some components and even some individual statements. 

We can study the reusability of a program, S, by 
assuming that a new program, S', is to be written and that 
we can identify a set of existing program parts (statements, 
components, and/or modules) that can be included in S' thus 
saving the effort of writing them from scratch. In this 
manner, we can model or simulate the alternative to writing 
new code which is reusing an "existing" portion of code as 
it can be obtained "off the shelf." 

The basic case can be established by removing the 
barriers from all modules and components in S, i.e., 
allowing all of the statements to be visible to one another. 
In this case, we attempt to simulate a worst case scenario 
in which the program has been developed from scratch. A 
case where a programmer was asked to write the entire 




T 


26 

program without the option of reusing any modules or 
components. 

At the other extreme, we can model an optimum reuse 
case where the programmer was asked only to write the main 
program statements and had the opportunity of reusing all 
the other independent modules and/or components that exist 
in the program. 

Now that we have described the boundary cases for our 
study of reusability, we can describe a third case which 
seems to fit inside our reusability spectrum. A case in 
which the programmer is asked to developed the main program 
statements along with the statements for some of the 
components anew, and has the option of using new modules 
that combine some of the original components. This generic 
case brings out the problem of determining which of 
the statements, components, and/or modules are the best 
candidates to be "reused". 

In general, we have a partition, n, on a program, S, 
defined as a collection of disjoint and nonempty subsets of 
statements in S whose union isS, i.e., v = {B a }, a e I 
where I is an indexing set, such that B a ^ $, for all a e I, 
B fl n B 6 = $ for a ^ 5, and U (B a ) = S where a e I. We refer 
to the sets in n as blocks of n [HARTM66]. For example, if 
S is a set consisting of 4 elements, S = (1,2,3,4), we can 
see that n can be written in 8 different ways if the element 
sequence is to be preserved, i.e., {{1},{2),{3},{4}}, 

{{1,2},{3},{4}}, { { 1} , {2,3} , (4} }, { (1), {2}, {3,4}}, 







27 

{{1,2},{3,4}}, {{1,2,3},{4}}, {{1},{2,3,4}}, and 

{{1,2,3,4}}. Thus, as the size of S increases, the number 

of ways in which it can be written increases much faster. 

To have an intuitive appreciation of the above- 
mentioned increase, consider the problem of the number of 
partitions of an integer, p(n) [GROSS84 and HALL67]. p(n) 
represents the total number of ways in which an integer, 
n > 0, can be represented as a sum of positive integers if 
he instances that differ only by the order of the summands 
are not considered different. Each such representation is 
called a partition of n. For example, p(4) = 5 (i.e., 
l+l+l+l, 1+2+1, 1+3, 2+2, and 4) while p(25) = 1958 
[HALL67]. Consequently, in a program with a large number of 
statements, all the possible ways in which the statements 
can be considered becomes prohibitively time consuming. 

3.1.4 Coupling and Cohesion 

To reduce the number of possible combinations of 
objects, we use the notions of coupling and cohesion. 
Coupling, as defined by Stevens, Myers, and Constantine 
[STEVE74], is a measure of the strength of the association 
established by a connection from, in this case, one object 
to another. Cohesion is defined by Stevens et al. and 
restated by Booch [BOOCH86] as how tightly bound or related 
the internal elements within an object are to one another. 

Stevens et al. [STEVE74] also state that "the fewer and 
simpler the connections between objects, the easier it is to 







28 


understand each object without reference to other objects." 
The complexity of a system is affected not only by the 
number of connections but by the degree to which each 
connection couples two objects, making them interdependent 
rather than independent. Thus coupling is reduced when the 
relationships between objects are minimized or, in Chanon's 
terms, when the number of assumptions that the objects make 
is minimized. 

One way to minimize coupling is to maximize the 
relationships among elements within the same object, i.e., 
obtaining the objects that display the highest cohesiveness 
[STEVE74]. Consequently, we can reduce the number of 
possible statement combinations by combining into objects 
the statements that possess the highest cohesiveness, thus 
resulting in the lowest degree of coupling. Similarly, we 
can combine into modules the components that possess the 
highest cohesiveness. 

Based on the aforementioned discussion on coupling, we 
can now identify some realistic combinations of the 
statements, components, and/or modules in the original 
program that potentially can be selected for reuse to allow 
us to compute the entropy loading and control structure 
entropy of tne resulting program consisting of the reused as 
well as original parts. 










29 


3.2 Carrying out the Experiment 
3.2.1 Quantifying Software Reuse 

The main objective of the experiment is to determine if 
a relation exists between software reusability and the 
information theory based.metrics: entropy loading and 
control structure entropy. The major problem is finding a 
mechanism that can help us quantify the notion of software 
reuse. 

As mentioned in Chapter II, one of the benefits of 
software reusability is the reduction in the amount of 
software that needs to be written when software is available 
for reuse. The amount of software reused can be correlated 
with the amount of code that needs to be developed from 
scratch for a given program. The more code that is 
available for reuse, the less new code is needed for the new 
program. Thus, intuitively, an inverse relation exists 
between software reused and the amount of software needed to 
be developed anew. 

For this study, the lines of code metric was used to 
quantify the amount of code that needs to be developed from 
scratch. The lines of code metric was not applied to the 
"reused" segments of code since they are not considered part 
of the effort of writing the new program. 

2 A line of code is defined by Conte et al. [CONTE86] as 
"any line of program text that is not a comment or blank line, 
regardless of the number of statements or fragments of 
statements on the line." 





30 


“1 


3.2.2 Experiment Operation 

The next two subsections explain the software tools 
that were developed and used to collect the measurements. 

3.2.2.1 Programs Developed to Collect the Data . 

Because pre-written software packages that compute entropy 
loading and lines of code metrics were not available, 
software tools to collect the measurements had to be 
developed. A total of three programs in C [KERi.T7Pl were 
developed on a VAX 11/785 running ULTRIX 3 (see Appendix A 
for program listings). The first program, called ent_lo5.c, 
was developed to compute the entropy loading of a collection 
of objects in a given program based on the set of 
assumptions made by the objects as demonstrated by Chanon 
[CHAN073]. In addition to the entropy loading, this program 
also computes the average object entropy, system entropy 
(H(S)), and the ratio of entropy loading to the total number 
of objects. No program was developed to extract the 
assumptions made by the objects in the programs. All 
assumptions were manually extracted from the programs based 
on Chanon's work [CHAN073] and are listed in Appendix D. 

The other two programs, called loc_c2.c and loc_adal.c, 
were developed to compute the lines of code metric for the C 
and Ada language programs used in the experiment. Both 
programs compute the lines of code metric as defined by 

^VAX and ULTRIX are Trademarks of Digital Equipment 
Corporation. 






31 


Conte et al. [C0NTE86] but go one step further. The lines 
of code was partitioned into three categories for the c 
programs, namely, declaration lines, non-declaration lines, 
and brace lines ("{" or "}" and no C statements). Ada lines 
of code were partitioned into declaration and non¬ 
declaration lines only. Declaration lines were extracted to 
investigate if there is any relation between them and the 
information contained in the objects (i.e., average object 
entropy and system entropy). Additionally, a relation is 
expected between the number of brace lines in C programs and 
MIN since they are expected to correlate well with the depth 
of nesting in programs. 

3.2.2.2 Data Collection . A total of three versions 
for each of the programs included in the study (see Section 
3.2.3) were considered. These versions follow the guide¬ 
lines for reuse established earlier as follows: version 1, 
optimum reuse; version 2, intermediate reuse; and version 3, 
no reuse. All metrics were applied to all three versions of 
the programs. 

The following convention was used to identify the 
objects in the programs under study. All object numbers are 
of the form A.4, C.O, or FHI.O. A.4 corresponds to the 
fourth statement in function or procedure A, C.O corresponds 
to a component which identifies function or procedure c, and 
FHI.O corresponds to a module composed of components F, H, 


and I. 






32 

All measurements, with the exception of the control 
structure entropy, were collected on the VAX 11/785 running 
ULTRIX. Control structure entropy, 2 n , was the only metric 
that was not computed using a program. This metric was 
computed using the Maximal Intersect Number charts in 
Appendix F and the equation 
Z n = MIN - 1 

where MIN is the Maximal Intersect Number determined from 
the charts as demonstrated by Chen [CHEN78]. The object 
numbers are shown inside the IF symbols in the charts in 
Appendix F. 

3.2.3 Programs Studied in the Experiment 

A total of six programs obtained from the open 
literature were studied in this experiment (see TABLE I and 
Appendixes B and C). Three of the programs were written in 


TABLE I 

TESTBED PROGRAM SOURCES 


Name 

Language 

Application 

Source 

fastfind 

C 

string processing 

[MILLE87] 

mail 

C 

database 

[SCHIL87] 

editor 

C 

string processing 

[SCHIL87] 

int_list 

Ada 

string processing 

[SHUMA89] 

calc 

Ada 

numeric 

[MOHNK86] 

address 

Ada 

database 

[M0HNK86] 






33 


C [KERNI78] and the other three in Ada [ADA83]. A 
noticeable difference between the C and Ada programs studied 
was the number of compilation units. All C programs were 
compiled as single units, while all Ada programs had two or 
more compilation units per program. 

The following subsections describe the main purpose of 
each of the programs along with a description of the objects 
used in the intermediate reuse case. The set of objects 
used in the intermediate reuse case are chosen to be a 
mixture of the three types of objects available. 

3.2.3.1 C Language Programs. The first C language 
program is a program called fastfind. The main purpose of 
this program is to search through one or more files 
containing ASCII text looking for a match for a character 
string given as input. The input string may consist of any 
sequence of up to eighty characters including spaces. The 
output consists of the entire text line in which a match was 
found for the input string preceded by the name of the file 
to which the text line belongs if more than one file was 
specified. 

The fastfind program consists of a main program and six 
functions (See Appendix E, Figure 2). Out of the six 
functions, two functions (fill_buffer and print_line) were 
combined into a module called module_l in the intermediate 
reuse case. These functions were combined because of the 
logical binding [STEVE74] exhibited between them. Function 













34 

scan was not considered to be a candidate for reuse so all 
of its statements were visible to the rest of the objects. 
The remaining functions were "reused" as components. 

The second C language program is a program called mail. 
The main purpose of this program is to create and update a 
personal mailing list database with a total of five fields 
per record (name, street, city, state, and zip code). There 
are a total of six options available on the database. The 
user can enter new records, delete existing records, list 
all records, search for a particular record, save all 
records to a file, and load an existing database from a 
file. The primary field in the database is the field name. 

The mail program consists of a main program and eleven 
functions (See Appendix E, Figure 3). Out of the eleven 
functions, three functions (enter, inputs, and dls_store) 
were combined into a module called module_l in the 
intermediate reuse case. These functions were combined 
because of the temporal binding [STEVE74] exhibited between 
them since all of these functions are executed at one time. 
Functions list, search, and delete were the functions not 
selected as candidates for reuse in this case. The 
remaining functions were "reused" as components. 

The last C language program is a program called editor. 
This program simulates a simple text editor with very 
limited capabilities. There are five options available to 
the user. The user can enter one or more lines of text in 
the same operation beginning at the specified line number or 






35 


delete a line of text based on the line number. He/she can 
also list the contents of the text file, save all text into 
a file, and retrieve an existing text file from a file. All 
lines are indexed by the line numbers in each line. 

The editor program consists of a main program and nine 
functions (See Appendix E, Figure 4). Out of the nine 
functions, two functions (patchup and find) were combined 
into a module called module_l in the intermediate reuse 
case. These functions were combined because of the logical 
binding [STEVE74] exhibited between them. Functions enter 
and delete were the functions that were not selected for 
reuse in this case. The remaining functions were considered 
to be objects that are candidates for reuse as components. 

3.2.3.2 Ada Language Programs . The first Ada language 
program studied is a program called int_list. The main 
purpose of this program is to illustrate the concepts of 
dynamic allocation and garbage collection. Memory is 
dynamically allocated for a list of numbers accepted from 
the keyboard as the numbers are added both to the beginning 
and end of the list. Subsequently, garbage collection is 
used to reclaim memory allocated as numbers are deleted from 
the beginning and the end of the list. The remaining 
numbers are then printed to demonstrate that the first and 
last numbers were deleted. 

The int_list program consists of a main program called 
exercise_20_l, seven procedures, and two functions (see 




36 


Appendix E, Figure 5). Out of the seven procedures, three 
procedures (insert_at_head, insert_at_tail, and alloc) were 
combined into a module called module_l in the intermediate 
reuse case. These procedures exhibit communicational 
binding [STEVE74] as they reference the same input data and 
are related in time. Procedures delete_tail and delete_head 
were not selected as candidates for reuse. The remaining 
functions and procedures were considered for reuse 
as components. 

The second Ada language program used in the study is a 
program called calc. This program simulates a four function 
calculator using Reverse Polish Notation (RPN). In RPN, the 
equal sign is never used. All operators precede the 
operation and when the operation symbol is entered, the 
result is displayed. Consequently, no parentheses are 
needed either. One of the good points about this program, 
is that it accepts numeric input in any of the common 
notations, including integers, signed integers, floating 
point fractions starting with a decimal point, signed 
floating point fractions, and any of the above followed by 
an exponent. A stack of ten entries is also provided to 
store the last ten operands entered. 

The calc program consists of a main program called 
calculate_2 and seven procedures (see Appendix E, Figure 6). 
Out of the seven procedures, three procedures (push, pop, 
and clear) were combined into a module called module_l in 
the intermediate reuse case. These procedures were the only 







37 


ones that exhibited some binding among themselves although 
it was only of a temporal type [STEVE74]. Procedure operate 
was not selected for reuse in this case hence all of its 
statements were visible to the rest of the objects. The 
remaining procedures were considered for reuse as 
components. 

The last Ada language program included in the. 
experiment is a program called address. This programs 
provides access to an address book database. The concept is 
similar to the C language program mail, although the 
implementation is completely different. Fields are provided 
to accommodate name, street address, city, state, zip code, 
and telephone number. The field name is used as the only 
key in the database. 

A separate index file based on name entries was 
maintained. To speed up search operations, binary search 
was provided as the search mechanism in contrast with 
sequential search used in mail. The operations provided 
include database initialization, new address insertion, 
address deletion, address modification, and address search 
based using the name as the key. 

The address program consists of a main program called 
address_book and twelve procedures (see Appendix E, Figure 
7). Out of the twelve procedures, two of the procedures 
(alter_data and alter_field) were combined into one module 
called module_l in the intermediate case of reuse. These 
two procedures exhibit communicational binding [STEVE74] as 





38 


they refer to the same input data obtained from the keyboard 
and are related in time, i.e., executed at data alteration 
time. Procedures delete and insert were not reused in this 
case. On the other hand, all other procedures were 
considered for reuse as components. 





CHAPTER IV 


ANALYSIS OF MEASUREMENTS 
4.1 Description of the Analysis 

All data analysis was done on a VAX 8550 running VMS 1 
using SAS [SAS85a,b]. Standard statistical methods 
described by Conte et al. [CONTE86] were used. 

The sample sizes for this study on software reusability 
using Ada and C programs were not arrived at statistically; 
rather, three correct programs written in each language 
found in the open literature were used. The three Ada 
programs have 137, 168, and 493 nonblank, noncomment lines 
of code and the three C programs have 138, 272, and 286 
nonblank, noncomment lines of code. Each of the three 
versions for each of the programs were considered as 
separate cases (optimum, intermediate, and no reuse cases). 

Pearson product-moment correlations [SAS85a,b] were 
computed between the lines of code metric and the control 
structure entropy metric, and between the lines of code 
metric and the entropy loading metric. Use of this 
correlation method requires that the measurements be 
parametric [CONTE86]. The measurements should be 

’VMS is a Trademark of Digital Equipment Corporation. 


39 








1 


40 

independent, drawn from normally distributed populations, 
the populations should have nearly the same standard 
deviations, and all measurements should be in at least the 
same interval scale (meaning that the data have meaningful 
differences and can be ranked and categorized). 

Correlations were also computed within the lines of 
code class and within the entropy loading class. The lines 
of code class is composed of lines of code (LOC), 
declaration lines (Dec), non-declaration lines (NDe), Brace 
lines (Bra, only used with C programs), comment lines (Com), 
and blank lines (Bla) . The entropy loading class is 
composed of the object total (Obj Tot), average object 
entropy, system entropy loading to object total ratio (SEL 
to OT Ratio), system entropy, and system entropy loading. 

See TABLE II for a list of the measurements obtained. TABLE 
III contains some of the correlations between the metrics. 

No correlations were computed between the entropy loading 
metric and the control structure entropy as these 
correlations were deemed outside of the scope of the 
experiment. A complete list of the correlations is provided 
in Appendix G. 

Correlations using natural logarithm transformations of 
the measurements were computed. The next two sections 
analyze the results obtained from the correlations of the 
metrics. 


TABLE II 


41 




re 

CO 

eg 

Cl 

CO 

^y 

o 

re 

rH 

CO 

re 

O' 

re 

eg 

in 

rH 



O' 

eg 

*y 

in 

re 

o 

m 

*<y 

O' 

*y 

O' 

CM 

re 

co 

■*r 


m 

r- 

CD 

E Cl, C 

rH 

eg 

in 

r* 

eg 

rH 

re 

eg 

o 

eg 

r- 

rH 

eg 

in 

eg 

o 

in 

ID 

(1) 

D -H 

re 

in 

rH 

o 


re 

CO 

O' 

rH 

CM 

m 

r- 

co 

co 

m 


eg 

rH 

P P T3 

re 

in 

eg 

■*r 

eg 

rH 

in 

eg 

rr 

re 

VO 

in 


o 

co 

rH 

eg 

O' 

M P <0 

* 

* 

* 

• 

• 

• 

• 

• 

* 

• 

• 

• 

• 

• 

• 

• 

• 

• 

>, C 0 

o 

rH 

o 

CO 

m 

r~ 

re 

O' 

r>- 

in 

O' 

rH 

o 

o 

eg 

o 

in 

CO 

t/1 U J 

eg 

eg 

ce 

eg 


o 

eg 

^y 

rH 

eg 

eg 

in 

rH 

re 

re 

in 

r~ 

co 








rH 



rH 











>, 

O' 

CO 

eg 

re 

o 

o 

rH 

o 

CO 

eg 

TT 

o 

vo 

<J\ 

*y 

re 

vo 

in 

E 

a 

*y 

o 

in 

O' 

o 

^y 

CO 

rH 

rH 

in 

VO 

o 


in 

in 

eg 

in 

vo 

(1) 

0 

r- 


in 


o 

O' 

o 

eg 

re 

^y 

rH 

CO 

r- 

co 

in 

o 

rg 

in 

jj 

p 

re 

re 

eg 

•*y 

cn 

O' 

CO 

ee 

o 

re 

CM 

re 

co 

in 

in 

co 

r- 

co 

IA P 

O' 

eg 

r- 

eg 

o 

o 

VO 

in 

■<y 


in 

rH 

o 


vo 

o 

co 

CO 

>, C 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

* 

• 

• 

w w 


in 

in 

^y 

in 

CO 

*y 

in 

in 

re 

^y 

in 

^y 

^y 

in 

in 

in 

CD 

0 


in 

cn 

Ch 

ro 

o 

VO 

vO 

re 

in 

O' 

^y 

O' 

co 

r- 

^y 

re 

vo 

in 

P 

0 

re 

rH 

in 

rH 

<J> 

CO 

^y 

CO 

rg 

in 

in 

o 

rg 

rg 

in 

*y 

O' 

rg 

E 

■H *H 

in 

in 

re 

in 

m 

eg 

re 

eg 

m 

O' 

O' 

ry 

^y 

^y 

in 

in 

vo 

rH 

PI 

0 P 

ce 

in 

o 

cn 

rH 

CO 

r- 

rH 

O' 

co 

in 


re 

rH 

r- 

co 

r- 

O' 

w 

(fl 

in 

in 

in 


eg 

cn 

CO 

O' 

CO 

<<y 

o 

CO 

m 

rH 

in 

rg 

CJs 

^y 

co 

a 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

• 

* 

• 



o 

o 

o 

rH 

rH 

o 

o 

o 

o 

rH 

rH 

o 

o 

rH 

o 

rH 

o 

o 

<u 

>, 

in 

o 

re 

o 

^y 

eg 

eg 

CO 

^y 

m 

re 

CO 

rg 

rH 

co 

O' 

re 

O' 

CT>P Cl, 

in 

*y 

o 


00 

CO 

CO 

rg 

rH 

eg 

o 

rH 

t"- 

'y* 

r**- 

m 

rg 

eg 

TO O O 

Ch 

O' 

o> 

CO 

o 

CO 

CO 

in 

in 

O' 

rH 

rH 

*y 

O' 

in 

in 

re 

c\ 

P ID P 

CX) 

CO 

av 

rH 

in 

re 

*y 

rH 

^y 

o 

eg 

vo 


r- 

r- 

•H 

in 

eg 

O -n P 

r- 

in 

in 

r* 

m 

o 

o 

o 

O' 

r* 

eg 

O' 

co 

eg 

m 

^y 

o 

in 

>ja c 

• 

• 

« 

• 

• 

• 

* 

• 

* 

• 

• 

• 

• 

• 

• 

• 

• 

• 

< c 

D W 

o 

o 

o 

rH 

rH 

rH 

rH 

rH 

o 

rH 

rH 

o 

o 

rH 

o 

rH 

rH 

o 

•re -P 

eg 

01 

o 

CTi 

CO 

0^ 


*y 

rH 

t" 

CO 

O' 

r- 

O' 


O' 

r* 

rH 

Si 

3 

re 

ce 

m 

rH 

re 

o 

eg 

in 

re 

rH 

eg 

m 

rH 

eg 

in 

re 

r> 

co 

O Eh 






rH 



rH 









rH 

C P P 

in 

CO 

re 


re 

rH 

in 

re 

VO 

rH 

CM 

CO 

re 

in 

^y 

CO 

re 

CD 

0 P C 



rH 


rH 

re 


rH 

CM 





rH 

IM 


rH 

re 

U CO W 




















P 

ce 



ce 


rH 


eg 

O' 

^y 

r* 

O' 

rH 

rH 

rH 

eg 

in 

O' 


O 

rH 

*y 

(M 

in 

rH 

re 

VO 

re 

re 

^y 

CTi 

r-~ 

VO 

CO 

rH 

ce 

in 

r* 


Eh 

rH 

rH 

CM 


rH 

re 


rH 

re 



rH 



CM 

H 

rg 

VO 


«3 

CO 

rH 


in 


r~ 


o 

rH 

in 

o 

t" 

re 

re 

o 

CO 

a\ 

O' 


rH 


rH 

eg 


rH 

re 


rH 

re 


rH 

rH 



rH 


rH 

in 


(X) 



















(u 




















T5 

E 

eg 

o 

eg 

o 

rH 

eg 

o 

eg 

eg 

o 

rH 

re 

rH 

rH 

re 

o 

r- 


0 

0 

^y 

in 

in 

rH 

rH 

eg 

rH 

rH 

eg 

rH 

eg 

CM 

rH 

rH 

ce 

eg 

^y 

eg 

u 

o 


















rH 

<4-4 




















0 

(0 

eg 

CO 

^y 

m 

o 

CO 

CO 

rH 

CO 

i 

i 

i 

i 

! 

i 

i 

i 

i 


p 

rH 

rH 

ce 


eg 

in 


eg 

co 

i 

i 

i 

i 

1 

i 

i 

i 

i 

w 

a 










i 

i 

i 

i 

1 

i 

i 

i 

i 

QJ 




















c 




















•H 

<D 

VO 

O' 

*y 

m 

o 

^y 

CO 

O' 

r~ 

co 

o 

CO 

eg 

rH 

vo 

e- 

CM 

in 

pi 

Q 

re 


CO 

eg 

in 

CO 

re 

O' 

O' 

eg 

in 

rg 


VO 

ry 

r- 

in 

re 


Z 






rH 



rH 



rH 



rH 


rH 



U 

in 

in 

o 

vn 

01 

o 

in 

o 

re 

rH 

VO 

rH 

in 

VO 

rg 


r'- 

00 


(1) 

rH 

rH 

eg 



eg 


rH 

eg 



rH 



< ' 

CM 

re 

in 


Q 




















U 

re 

re 

CO 

CO 

01 

eg 

o 

o 

m 

O' 

CO 




CO 

XT 

O' 

ce 


o 

VO 

CO 

ce 

ro 

CO 

O' 

in 

rH 

CO 

eg 

VO 

re 

^y 

in 

vo 

o 

O' 

O' 


PI 



rH 



eg 


rH 

rg 



rH 



rH 

rH 

rH 

^y 



rH 

eg 

re 







rH 

eg 

re 









T3 

n 

T3 







P 

p 

p 




rH 

rg 

ce 

E 


C 

c 

C 




rH 

rg 

re 

in 

U) 

V) 




w 

in 

in 

ro 


•H 

•rH 

•»H 




p 

p 

p 

•rH 

•rH 

•H 




[A 

in 

in 

p a 

<4-H 

4-t 

4h 

rH 

eg 

re 

0 

0 

o 

rH 

rH 

rH 

rH 

eg 

re 

O 

0) 

0) 

O' E 

p 

p 

p 

rH 

rH 

r-H 

p 

p 

p 



1 

u 

u 

o 

P 

p 

p 

0 ro 

10 

10 

10 

•H 

•H 

•H 

•H 

•rH 

•rH 

P 

p 

P 

rH 

rH 

rH 

TJ 

"0 

T3 

P z 

ro 

<0 

ro 

ro 

ro 


TS 

T5 

T5 

c 

c 

c 

(Z 

(Z 

fO 

n 

V 

T5 

a 


< 4-1 

<4-< 

WH 

E 

E 

E 

a) 

<V 

<D 

•H 

-H 

•*H 

u 

o 

U 

ro 

ro 

CO 












42 


TABLE III 


CORRELATIONS BETWEEN METRICS 


(Ada) 

LOC 

Dec 

NDe 

Com 

Bla 

Tot 


ConStrEnt 

.8551 

. 8385 

.8467 

. 6925 

. 5225 

.8136 


(Ada) 

LOC 

Dec 

NDe 

Com 

Bla 

Tot 


ObjTot 

. 9860 

.8693 

.9886 

.9616 

. 9279 

.9921 


AveObjEnt 

-.7692 

-.6495 

-.7934 

-.7427 

-.6034 

-.7619 


SELtoOTRat 

-.6368 

-.5398 

-.6619 

-.6117 

-.4529 

-.6257 


SysEntr 

. 9852 

. 9346 

. 9745 

. 9505 

. 8898 

. 9856 


SysEntLoa 

.8095 

. 7265 

.7978 

.7949 

. 8489 

.8234 


(C) 

LOC 

Dec 

NDe 

Bra 

Com 

Bla 

Tot 

ConStrEnt 

. 9284 

. 5944 

.9510 

.9101 

. 0077 

. 8900 

.8395 


(C) 

LOC 

Dec 

NDe 

Bra 

Com 

Bla 

Tot 

ObjTot 

.9947 

.8142 

. 9897 

.2896 

.9670 

.9168 

.9637 

AveObjEnt 

-.3292 

-.6901 

-.2442 

-.8891 

-.3626 

-.3524 

-.4985 

SELtoOTRat 

-.1778 

-.5906 

-.0887 

-.8856 

-.2169 

-.2141 

-.3615 

SysEntr 

. 9785 

.8549 

.9609 

. 3942 

.9656 

.9142 

. 9732 

SysEntLoa 

.8537 

. 4589 

. 8969 

-.2007 

.8061 

.7597 

. 7251 








43 


4.2 Entropy Loading Analysis 

Entropy loading, as described in Chapter II, is a 
measure of the information shared among collections of 
objects as opposed to the information used inside each 
collection [CHAN073]. Consequently, we can expect a higher 
entropy loading as the number of collections making 
assumptions increases (considering each object as a 
collection only containing itself) since the total amount of 
information shared increases. This assumption was verified 
by a strong, positive, and significant correlation (signifi¬ 
cance of 0.004 or less) between entropy loading and the 
total number of objects for both C and Ada programs. 

The increase in the number of collections was 
represented by an increase in the amount of code (quantified 
by the lines of code metric) that needs to be written when 
the opportunity for reuse is smaller. As expected, a 
strong, positive, and significant correlation (significance 
of 0.0082 or less) was found between the lines of code and 
the total number of objects, and between lines of code and 
entropy loading for both C and Ada programs. In other 
words, the larger the amount of code needed anew (smaller 
reuse), the larger the number of objects and consequently, 
the higher the entropy loading. 

Overall, strong, positive, and significant correlations 
(significance of 0.027 or less) were found between the total 
number of objects, system entropy, and entropy loading on 






44 

one side and most of the lines of code metrics class for 
both C and Ada programs on the other side. 

Additionally, strong, negative, and significant 
correlations (significance of 0.02 or less) exist between 
the average object entropy measure and most of the measures 
in the lines of code class for the Ada programs. The 
average object entropy is an indicator of the information 
contained inside objects. 

4.3 Control Structure Entropy Analysis 

While entropy loading is used as a measure of 
information among collections of objects, control structure 
entropy, defined in Chapter II, is used as a measure of the 
complexity of a program [CHEN78]. Consequently, a higher 
control structure entropy is expected as the perceived 
complexity of the program increases. 

One of the assumptions that we are trying to validate 
(or at least provide support for) in this study is that the 
more code that is available for reuse, the less complex the 
resulting new program tends to be. This is expected because 
the internal complexity of the reusable modules is not seen 
by the programmer when the new program is being developed 
since the modules already exist and either have been 
previously understood or can be understood in one chunk. 

Strong, positive, significant correlations (signifi¬ 
cance of 0.0033 or less) exist between the control structure 
entropy metric and the lines of code metric for both C and 









45 


Ada programs. This should be expected as the lines of code 
metric is used to quantify the amount of software that needs 
to be developed anew, validating our assumption. In other 
words, the less code available for reuse, the more complex 
the new program tends to be. 

The relation between MIN and the brace lines measure 
discussed in Section 3.2.2.1 was verified by a strong, 
positive, significant correlation (significance of 0.0007) 


between them. 








CHAPTER V 


SUMMARY, CONCLUSIONS, AND FUTURE WORK 

The main theme of this thesis was to theoretically 
explore the relationships between software reusability and 
two information theory based metrics: entropy loading and 
control structure entropy. A survey of the open literature 
indicated that previous work in this area had not addressed 
the idea of quantifying software reuse with this type of 
metrics. 

Entropy loading was found to be inversely proportional 
to the amount of reuse present in the programs. Entropy 
loading was always smaller in the optimum reuse cases. This 
was corroborated by strong correlations found between 
entropy loading and the size of the resulting new program, 
measured by the lines of code metric. Consequently, entropy 
loading can presumably provide a mechanism for selecting the 
optimum reuse case among different possibilities for reuse. 

Control structure entropy, a measure of the complexity 
of a program, was also found to be a good indicator of 
reuse. The optimum reuse case (higher reuse) was always 
found to be the one with the lowest control structure 
entropy. Strong correlations exist between control 


46 











47 


structure entropy and the size of the resulting new program, 
measured by the lines of code metric. 

In conclusion, there seems to be a relation between 
entropy loading and software reuse, and between control 
structure entropy and software reuse. But, care should be 
taken not to make any irrational generalizations since this 
study was not a controlled experiment and the sample sizes 
were not arrived at statistically. The intent of this study 
was only to determine if a possible relation between the 
metrics and software reuse existed. 

Suggestions for future work include conducting a 
similar, but controlled and larger scale experiment to test 
the hypothesis that the notion of software reuse can be 
quantified. Perhaps, adding other software metrics to the 
ones used in this study and/or adding other programming 
languages would provide more insight. Possible candidates 
include other information theory based metrics such as 
residual complexity [SAMAD88] and other metrics such as 
software science metrics [HALST79]. 

Other work might also include software reuse instances 
where some of the objects overlap (i.e., there is a certain 
degree of harmless overkill involved in the objects that are 
being reused). In such a case, entropy loading can not be 
applied but other measures can be applied (e.g., [SAMAD88 
and SCHUT77]). 

Finally, automated tools can be developed to determine 
assumptions made by objects in the calculation of the 









48 


entropy loading metric. This task is considered the most 
time consuming in the application of the entropy loading 


metric. 







REFERENCES 


[ADA83] Reference Manual for the Ada Programming Language . 
United States Department of Defense, ANSI/MIL-STD-1815A, 
January 1983. 

[ALEXA64] Alexander, Christopher, Notes on the Synthesis of 
Form . Harvard University Press, Cambridge, Mass., 1964. 

[BERLI80] Berlinger, Eli, "An Information Theory Based 
Complexity Measure," Proceedings of the 1980 ACM National 
Computer Science Conference , Arlington, VA, AFIPS Press, 
pp. 773-779. 

[BIGGE87] Biggerstaff, Ted and Richter, Charles, 

"Reusability: Framework, Assessment, and Directions," IEEE 
Software, March 1987, pp. 41-49. 

[BOOCH86] Booch, Grady, Software Engineering with Ada . The 
Benjamin/Cummings Publishing Company Inc., Second Edition, 
1986. 

[CHAN073] Chanon, Robert N., "On a Measure of Program 
Structure," Ph.D. Dissertation, Department of Computer 
Sciences, Carnegie-Mellon University, Pittsburgh, PA, 
November 1973. 

[CHEAT83] Cheatham, Jr., T. E., "Reusability Through 
Program Transformations," Proceedings ITT Workshop on 
Reusability in Programming , September 7-9, 1983, pp. 
122-128. 

[CHEN78] Chen, Edward T., "Program Complexity and 

Programmer Productivity," IEEE Transactions on Software 
Engineering . Vol. SE-4, No. 3, May 1978, pp. 187-194. 

[CHENG84] Cheng, Thomas T., Lock, Evan D., and Prywes, Noah 
S., "Use of Very High Level Languages and Program 
Generation by Management Professionals," IEEE Transactions 
on Software Engineering . Vol. SE-10, No. 5, September 
1984, pp. 552-563. 

[C0NTE86] Conte, S. D., Dunsmore, H. E., and Shen, V. Y., 
Software Engineering Metrics and Models . The 
Benjamin/Cummings Publishing Co., Inc., Menlo Park, CA, 
1986. 


49 





[DIJKS72] Dijkstra, E. W., "Motes on Structured 

Programming," Structured Programming . Academic Press, 

New York, 1972. 

[FREEM83] Freeman, Peter, "Reusable Software Engineering: 
Concepts and Research Directions," Proceedings of the ITT 
Workshop on Reusability in Programming . September 7-9, 
1983, pp. 2-15. 

[GOGUE86] Goguen, Joseph A., "Reusing and Interconnecting 
Software Components," IEEE Computer , Vol. 19, February 
1986, pp. 16-28. 

[GROSS84] Grosswald, Emil, Topics from the Theory of 
Numbers . Birkhauser, 1984. 

[HALL67] Hall Jr., Marshall, Combinatorial Theory . 
Blaisdell Publishing Co., 1967. 

[HALST79] Halstead, M. H., "Advances in Software Science," 
Advances in Computers . (Yovits, ed.), Vol. 18, Academic 
Press, New York, 1979, pp. 119-172. 

[HARTM66] Hartmanis, J. and Stearns, R. E., Algebraic 
Structure Theory of Sequential Machines . Prentice-Hall, 
Inc., Englewood Cliffs, NJ, 1966. 

[KAISE87] Kaiser, Gail E. and Garlan, David, "Systems from 
Reusable Building Blocks," IEEE Software . July 1987, pp. 
17-24. 

[KERNI78] Kernighan, Brian W. and Ritchie, Dennis M., The 
C Programming Language . Prentice-Hall, Englewood Cliffs, 
NJ, 1978. 

[KERNI84] Kernighan, Brian W., "The UNIX System and 
Software Reusability," IEEE Transactions on Software 
Engineering . Vol. SE-10, No. 5, September 1984, pp. 
513-518. 

[LEE87] Lee, Tony T., "An Information-Theoric Analysis of 
Relational Databases-Part I: Data Dependencies and 
Information Metric," IEEE Transactions on Software 
Engineering , Vol. SE-13, No. 10, October 1987, pp. 
1049-1061. 

[LETOV86] Letovsky, Stanley and Soloway, Elliot, 
"Delocalized Plans and Program Comprehension, 

Computer . May 1986, pp. 41-49. 


IEEE 






51 


[LUBAR86a] Lubars, Mitchell D., "Code Reusability in the 
Large Versus Code Reusability in the Small," ACM SIGSOFT 
Software Engineering Notes , Vol. 11, No. 1, January 1986, 
pp. 21-27. 

[LUBAR86b] Lubars, Mitchell D., "Affording Higher 

Reliability Through Software Reusability," ACM SIGSOFT 
Software Engineering Notes . Vol. 11, No. 5, October 1986, 
pp. 39-42. 

[MATSU84] Matsumoto, Yoshihiro, "Some Experiences in 
Promoting Reusable Software: Presentation in Higher 
Abstract Levels," IEEE Transactions on Software 
Engineering . Vol. SE-10, No. 5, September 1984, pp. 
502-513. 

[MCCAB76] McCabe, J., "A Complexity Measure," IEEE 

Transactions on Software Engineering . Vol. SE-2, No. 4, 
December 1976, pp. 308-320. 

[MILLE87] Miller, Webb, A Software Tools Sampler . Prentice- 
Hall, Inc., Englewood Cliffs, NJ, 1987. 

[MOHAN79] Mohanty, Siba N., "Models and Measurements for 
Quality Assessment of Software," ACM Computing Surveys . 
Vol. 11, No. 3, September 1979, pp. 251-275. 

[MOHAN81] Mohanty, Siba N., "Entropy Metrics for Software 
Design Evaluation," T he Journal of Systems and Software 2 . 
1981, pp. 39-46. 

[MOHNK86] Mohnkern, Gerald L. and Mohnkern, Beverly, 

Applied Ada . Tab Professional and Reference Books, 1986. 

[PARNA71] Parnas, D. L., "Information Distribution Aspects 
of Design Methodology," Proceedings of the IFIP Congress . 
Ljubljana, Yugoslavia, 1971. 

[PRIET87] Prieto-Diaz, Ruben and Freeman, Peter, 

"Classifying Software for Reusability," IEEE Software . 
January 1987, pp. 6-16. 

[SAMAD88] Samadzadeh, Mansur H. and Edwards, William R., 
Jr., "A Classification Model of Comprehension," Twenty 
First Annual Hawaii International Conference on System 
Sciences (HICSS21) . Hawaii, 1988. 

[SAS85a] SAS User's Guide: Basics. Version 5 Edition . SAS 
Institute Inc., Box 8000, Cary, NC 27511, 1985. 

[SAS85b] SAS User's Guide: Statistics. Version 5 Edition . 
SAS Institute Inc., Box 8000, Cary, NC 27511, 1985. 








52 


[SCHIL87] Schildt, Herbert, Advanced Turbo C . Osborne 
McGraw-Hill, New York, NY, 1987. 

[SCHUT77] Schiitt, Dieter, "On a Hypergraph Oriented Measure 
for Applied Computer Science," Proceedings of COMPCON . 
Washington, D.C., Fall 1977, pp. 295-296. 

[SHANN64] Shannon, Claude E. and Weaver, Warren, The 
Mathematical Theory of Communication . The University of 
Illinois Press, Urbana, Ill., 1964. 

[SHOOM83] Shooman, Martin L., Software Engineering: Design . 
Reliability, and Management . McGraw-Hill Book Company, New 
York, 1983. 

[SHUMA89] Shumate, Ken, Understanding Ada with Abstract 
Data Types . John Wiley and Sons, Inc., New York, NY, 

Second Edition, 1989. 

[SIMON62] Simon, H. A., "The Architecture of Complexity," 
Proceedings of the American Philosophical Society . 106, 
December 1962, pp. 467-482. 

[SOMME89] Sommerville, Ian, Software Engineering , Addison- 
Wesley Publishing Co., Third Edition, 1989. 

[STEVE74] Stevens, W. P., Myers, G. J. , and Constantine, L. 
L., "Structured Design," IBM Systems Journal . Vol. 2, 

1974, pp. 115-139. 

[TRAC288] Tracz, Will, "Software Reuse Maxims," ACM SIGSOFT 
Software Engineering Notes . Vol. 11, No. 5, October 1988, 
pp. 28-31. 

[VANEM70] van Emden, M. H. , "Hierarchical Decomposition of 
Complexity," Machine Intelligence 5 , 1970, pp. 361-380. 

[WEGNE83] Wegner, Peter, "Varieties of Reusability," 
Proceedings of the ITT Workshop on Reusability in 
Programming . September 7-9, 1983, pp. 30-44. 









SELECTED BIBLIOGRAPHY 


1. Belady, L. A. and Evangelisti, C. J., "System 
Partitioning and Its Measure," The Journal of Systems and 
Software 2 . 1981, pp. 23-29. 

2. Brown, P. J., Software Portability . Cambridge 
University Press, 1977. 

3. Chandersekaran, C. S. and Perriens, M. P., "Towards an 
Assessment of Software Reusability," Proceedings of the ITT 
Workshop on Reusability in Programming . September 7-9, 1983, 
pp. 179-182. 

4. Hellerman, Leo, "A Measure of Computational Work," IEEE 
Transactions on Computers . Vol. C-21, No. 5, May 1972, pp. 
439-446. 


53 








APPENDIXES 









APPENDIX A 

PROGRAMS USED TO COMPUTE THE METRICS 


55 







** ^ 


56 


* Entropy Loading Metric * 

★ ★★★*★★★★★★★★★★★*★*★★★★★★**★★*★★*★★★★*★★■**★********** ******** ***★★**★ 

* * 

* File: ent_lo5.c * 

* Author: William R. Torres * 

* Date: 90/01/25 * 

* Class: COMSC 5000 - Thesis * 

* Adviser: Dr. Mansur Samadzadeh * 

* * 
******★★******★★*★★****★***★★★★*★*★★*★*★***★**★***★******★★★★***★**** 


★ 
* 
★ 
★ 
★ 
★ 
★ 
★ 
★ 
* 
* 
* 
t k 
★ 
★ 
★ 
★ 
★ 
★ 
* 
★ 
★ 
★ 
★ 
★ 
* 
-r 
* 
•A: 


This program computes the entropy loading metric as presented * 
by Chanon [CHAN074]. The input for this program consists of the* 
name of the file that contains the input data for the program. * 
The first line of the input file must contain the total number 
of subsystems, which in our case is always the same as the 
number of objects, the total number of objects, and the total 
number of assumptions. 


The remaining input lines are divided into two groups. Each 
line in the first group corresponds to each of the objects in 
the program under study. Each line contains the object's name 
(i.e., A. 1, C.2), the total number of assumptions the object 
makes, and the numbers of the assumptions the object makes 
(i.e., 245 when the object makes assumptions 2, 4, and 5). 
Each line in the second group corresponds to each subsystem in 
the program under study. Each of these lines contain the 
total number of objects in the subsystem and the numbers that 
identify the objects in the subsystem. 

The output of this program is divided into two groups. In the 
first group, the program produces a line with the name of the 
object and the entropy for each of the objects in the program. 
The next output group produces the total number of objects, the 
average object's entropy (sum of entropies divided by total 
number of objects), the system entropy, the system entropy 
loading, and the ratio of system entropy loading to total 
number of objects. 




include <stdio.h> 
include <math.h> 
define OBJECTS 190 
^define ASSUMPTIONS 170 
^define SUBSYSTEMS 190 

main() 

{ 

int i, j, k, m, n, p; 
double entropy[OBJECTS + lj, 
entropy_loading, 
double_sum, 
tempdouble; 


/*subsystem entropy calculation*/ 
/*system entropy loading*/ 
/♦temporary double variable*/ 
/♦temporary double variable*/ 








57 


int OAT{OBJECTS]fASSUMPTIONS], /*Object/Assumption Table*/ 
subsys cnt, /*subsystem count*/ 

subsys_size[SUBSYSTEMS 1, /*No. of Objects in Subsys.*/ 

sub_system[SUBSYSTEMS](OBJECTS], /*Subsys. Objects*/ 
obj cnt, /*number of Objects in OAT*/ 

asmp cnt, /^assumption count in OAT*/ 

asmp no, /*Number of assmp. for Object*/ 

asmp col, /*columns with assumptions*/ 

occurrences[OBJECTS], /*submatrix element occurrences*/ 

NODO, /*Number Of Distinct Occurrences*/ 

sub matrix[OBJECTS][ASSUMPTIONS], /*OAT temporary submatrix*/ 


submatrix size, 
columns[ASSUMPTIONS][2] 
columns_head, 
rem_obj[OBJECTS]; 
char file_buffer(25J; 
struct { 

char name[10]; 

FILE *datafp, 

*outputfp; 
double loga_n(); 
double pover(); 


/*submatrix row size*/ 

/*columns where assmp. are present*/ 
/*columns list head*/ 

/*remaining rows not compared yet*/ 
/*data filename buffer*/ 


obj[OBJECTS]; /*object names*/ 

/*data file pointer*/ 
/*output file pointer*/ 


strcpy(file_buffer, 

vhile(strcmp(file_buffer, "quit") != 0) 

{ 

printf("\nEnter data filename or quit to stop program\n==>> "); 
scanf("%s", file_buffer); /*get data filename*/ 
if(strcmp(file_buffer, "quit"') != 0) 

( 

if((datafp = fopen(file_buffer, "r")) == NULL) /*open file*/ 
printf("Error opening file 2s\n", file buffer); 
else /*file opened for reading*/ 

{ 

outputfp = fopen("ent_load_out", "w"); /*open output file*/ 
/*Read No. of Subsystems, Objects, and Assumptions*/ 
fscanf(datafp, "%d Xd Xd", &subsys_cnt, Aobj_cnt, &asmp_cnt); 
for(i = 0;i < obj_cnt; i++) /*initialize OAT to zero*/ 
for(j = 0;j < asmp_cnt; j++) 

OAT[i][j] = 0; 

for(i = 0; i < obj_cnt; i++) /*assumption input loop*/ 

( 

fscanf(datafp, "Xs" , obj[i].name); /*read object's name*/ 
fscanf(datafp, "%d", &asmp_no); /*read number of assumptions*/ 
for(j = 0;j < asmp_no; j++) /*read assumptions*/ 

{ ' 

fscanf(datafp, "%d", &asmp_col); 

0AT[i][asmp_col - 1] = 1; /*assign assumptions*/ 

} /*end for*/ 

) /*end for*/ 

for(i = 0; i < subsys_cnt; i++) /*subsvstem input loop*/ 

{ 

fscanf(datafp, "%d", Asubsys size[i]); /*no. of objects*/ 
for(j = 0; j < subsys_size[ i ] ; j*-*-) /*read object numbers*/ 

{ 




58 


“1 


fscanf(datafp, H Xd", &sub_system[i][j1); 
sub system[i][j]—; /*adjust object number*/ 

) /*end for*/ 

} /*end for*/ 

printf("\nObject Name Entropy (H(X))\n"); 

printf("===============================\n”); 

for(i = 0;i < subsys_cnt; i++) /*subsystem loop*/ 

( 

submatrix_size = 0; 

columns_head = 0; /*initialize list*/ 
for(n = 0;n < subsys size[i]; n++) 

{ /*Find Assmp. made in the subsys. objects*/ 
for(j = 0;j < asmp_cnt; j++) 

{ /*obtain subsystem submatrix from OAT*/ 
if(0AT[sub_system[i][n]][j] == 1) /*1 pres, in the col.*/ 

{ 

if(submatrix_size == 0) /*empty list*/ 

{ 

columns[submatrix_size][0] = j; / *save col. no.*/ 
columns(submatrix_size++][11 = -1; /*end*/ 

} /*end if*/ 

else /*list is not empty*/ 

{ 

for(k = columns_head;k > — 1;p = k,k = columns[k] [ 1 ]) 

{ /*search list to insert column number*/ 
if(j < columns[k][0]) /*insert before present*/ 

{ 

columns[submatrix_size][1] = k; /*link to pres.*/ 
columns[submatrix_size++][0] = j; /*save col. #*/ 
if(k == columns_head) /*pres. was first*/ 

columns_head = submatrix_size - 1; /*nev first*/ 
else /*pres was not first, link to previous*/ 
columns[p][1] = submatrix_size - 1; 
break; /*end search*/ 

) /*end if*/ 

else if(j == columns[k][0]) /*repeated column*/ 
break; /*stop search*/ 

) /*end for*/ 

if((j > columns[p][0]) && (k == -1)) 

( /*place at the end of the list*/ 
columns[submatrix_sizeJ[0] = j; /*save col. no.*/ 
columns[submatrix_size++] [1 ] = -1; /*end*/ 

columns[p](1] = submatrix_size - 1; /*link back*/ 

} /*end if*/ 

) /*end else*/ 

} /*end if*/ 

3 /*end for*/ 

) /*end for*/ 

for(j = 0;j < obj_cnt; j-*--*-) /'*form submatrix*/ 

for(k = columns_head,m = 0;k > -1; m++,k = columns [ k][1]) 
sub_matrix[j]Jm] = OAT[j][columns[k][0]]; 
for(j = 0;j < obj_cnt; j++) 

rem_obj[j] = 0; /*mark rows as not compared yet*/ 
for(j = 0,N0D0 = 0;(j < (obj_cnt - 1)); j++) 

{ /*j t h row is compared with mth row*/ 








59 


m = j + 1; 

if(rem_obj[j] != 1) /*row not previously compared*/ 

{ 

rem obj[j] = 1; /*remove object from submatrix*/ 
occurrences[NODO++] = 1; /*initial occurrence*/ 
vhile(m < obj_cnt) 

{ /*m is the following rov index*/ 

if(rem obj(m] != 1) /*rov not matched before*/ 

f 

for(k = 0;((sub_matrix[j] [ k] == sub_matrix|mJ[kJ) && 
(k < submatrix_size)); k++); /*compare rows*/ 
if(k == submatrix_size) /*matching rows*/ 

{ 

occurrences[N0D0 - 1]++; /*increase count*/ 
rem obifm! = 1; /*remove object from submatrix*/ 

} /*end if*/ 

) /*end if*/ 

m++; /*get ready for next row*/ 

} /*end while*/ 

) /*end if*/ 

} /*end for*/ 

if<(j == (obj_cnt - 1)) && (rem_obj[j] == 0)) 

occurrences[N0D0++] = 1; /*last row is unique*/ 

/*Entropy function computation for the subsystems*/ 
entropy[i] = (double) obj_cnt; 

entropy[i] = loga_n(entropy[i]); /* log |X| */ 

double_sum = 0.0; /initialize sum of partitions*/ 
for(j = 0;j < N0D0; j++) 

{ 

temp_double = (double) occurrences[j]; 

/*printf("Xd ", occurrences[j]); DEBUG*/ 
temp_double *= loga_n(temp_double); /* Xj log Xj */ 

double_sum += temp_double; /* Sum of terms */ 

) /*end for*/ 

/*printf("\n"); DEBUG*/ 

double_sum = (double) double_sum / obj_cnt; /*Div by X */ 
entropy!i] -= double_sum; 

entropy[i] /= loga_n(2.0); /*convert result to log base 2 */ 
printf("£lls %15.12f\n", obj[i].name, entropy[i]); 
fprintf (outputfp, "JJ15.12 f £3d\n", entropy(i), i + 1) ; 

} /*end for*/ 

/*Analyze system matrix to compute system entropy*/ 
for(j = 0;j < obj_cnt; j++) 

rem_obj[jj = 0; /*mark rows as not compared yet*/ 
for(j = 0,N0D0 = 0;(j < (obj_cnt - 1)); j++) 

{ /*j t h rov is compared with mth row*/ 

m = j + 1; 

i f(rem_obj(j] != 1) /’row not previously compared*/ 

{ 

rem_obj[j] = 1; /*remove object from submatrix*/ 
occurrences[N0D0++ ] = 1; /initial occurrence*/ 
vhile(m < obj_cnt) 

{ /*m is the following row index*/ 

if(rem_obj[m] != 1) /*rov not matched before*/ 

{ 





60 


for(k = 0; ((OAT[ j ] [ k ] == OAT(m] (k ]) 

(k < asmp_cnt)); k++); /^compare system rows*/ 
if(k == asmp_cnt) /^matching rows*/ 

{ 

occurrences[NODO - 1]++; /*increase count*/ 
rem obj[m] = 1; /*remove object from submatrix*/ 

} /*end if*/ 

) /*end if*/ 

m++; /*get ready for next row*/ 

} /*end while*/ 

} /*end if*/ 

) /*end for*/ 

if((j == (obj_cnt - 1)) && (rem_obj[j] == 0)) 

occurrences[N0D0++] = 1; /*last row is unique*/ 

/*System Entropy Computation*/ 
entropy[OBJECTS] = (double) obj_cnt; 

entropy(OBJECTS] = loga_n(entropy[OBJECTS]); /*log |X|*/ 
double_sum = 0.0; /*initialize sum of partitions*/ 
for(j = 0;j < N0D0; j ++ ) 

{ 

temp_double = (double) occurrences[j]; 

temp_double *= loga_n(temp_double); /* Xj log Xj */ 

double_sum += temp_double; /* Sum of terms */ 

} /*end for*/ 

double_sum = (double) double_sum / obj_cnt; /*Div by X */ 
entropy[OBJECTS] -= double_sum; 

entropy[0BJECTS] /= loga_n(2.0); /*convert to log base 2*/ 
for(i = 0, entropy_loading = 0.0;i < subsys_cnt; i++) 

entropy_loading += entropy[i]; /*compute entropy loading*/ 
temp_double = (double) entropy_loading / subsys_cnt; 
printf("NnObject Count is 2d\n", i); 

printf("Average Object Entropy is X15.12f\n", temp_double); 
printf("System Entropy (H(S)) is 215.12f\n",entropy[OBJECTS]); 
fprintf(outputfp, "%15.12f %3d\n", entropy[0BJECTS], i + 1); 
entropy_loading -= entropy[0BJECTS]; /*subtr. system entropy*/ 
printf("System Entropy Loading (C(S)) is %15.12f\n", 
entropy_loading); 

temp_double = (double) entropy_loading / obj_cnt; 
printf("C(S) to Object Count Ratio is Z15.12f\n",temp_double); 
fclose(datafp); /*close input data file*/ 
fclose(outputfp); /*close output file*/ 

} /*end else*/ 

} /*end if*/ 

} /*end while*/ 

} /*end main*/ 




★ ★ 

* This function accepts a double floating point number as input. * 

* The output consists of the natural logarithm of the number * 

* passed as input. The output is of double floating point type. * 

* * 


double loga_n(param) 








61 


double param; 

{ 

double temp[3]; 
int i, j, k; 

temp[l] = 0.0; 

temp[2] = (param - 1.0) / (param + 1.0); 
for(i = 1;i < 160;i += 2) 

temp[l] += (double) power(temp[2], i) / i; 
temp[l] *= 2.0; 
return temp[l]; 

} /*end loga n*/ 




* * 

* This function computes the nth power of a double floating point * 

* number. The power can only be an integer. The output is a * 

* double floating point number. * 

* * 


*****★****★★*★★★★**★*★**★★*★**★★★***★**★★*★**★★★★★** *★★★**★*★* ****★★/ 
double power(base, exp) 
double base; 
int exp; 

{ 

double temp; 
int i; 

for(i = 1, temp = 1.0;i <= exp; i++) 
temp *= base; 
return temp; 

) /*end power*/ 








62 


/★**★********★★★*★★★*****★*★***★***★******************************* 

* Lines of Code Metric (C) * 

★★a**************************************************************** 

* ★ 

* File: loc_c2.c * 

* Author: William R. Torres * 

* Date: 89/09/23 * 

* Class: COMSC 5000 - Thesis * 

* Adviser: Dr. Mansur Samadzadeh * 

* ■k 

* ★★*★★**★★★**★★★*★*★★**★*★★★★★**★*★*★★******★****★**★*■#:*★★★*★**★***• 

* * 

* This program computes the lines of code for correct C * 

* language source code. The input for this program consists * 

* of the filename of the file for which the lines of code * 

* metric is desired. The output is broken down into six * 

* categories: actual C language lines of code, declaration * 

* lines of code, non-declaration lines of code, lines of code * 

* with braces ('(' or comments lines, and blank lines. * 

* * 

* The following criteria is used to categorize the lines: * 

* (1) all lines in which C statements are present, even if they * 

* include comments or multiple statements separated by * 

* terminators (;), are counted as one line of code, (2) all * 

* lines with comments and no C statements, even if the lines * 

* have multiple comments, are counted as one comment line, * 

* (3) all other lines are considered blank lines. + 

* * 

* The following criteria is used to subdivide the lines of * 

* code: (1) all lines with a brace and no C statement are * 

* counted as brace lines, (2) all lines in which a variable is * 

* declared are counted as declaration lines, and (3) all other * 

* lines are considered non-declaration lines. * 


^include <stdio.h> 
^include <ctype.h> 
^define BUF_SIZE 80 
^define TRUE 1 
.refine FALSE 0 


main() 

{ 

int loc, 

blank_cnt, 
comm_cn t, 
comm_pres, 
instr_pres, 
comm_coun ted, 
brace_cnt, 
brace_pres, 
decla_cnt, 
decla_pres, 
decla counted, 


/★lines of code*/ 

/*blank line count*/ 

/*comment line count*/ 

/^comment present*/ 
/★instruction present*/ 

/*line counted as comment*/ 
/*brace line count*/ 

/*brace present*/ 

/★declaration line count*/ 
/★declaration line presence*/ 
/★line counted as declaration*/ 







63 


i, j; 

char inp_buffer[8UF_SIZE], 
file_buffer[25], 
c; 

FILE *filefp; 


/★buffer for program lines*/ 

/★buffer for input program filename*/ 

/★pointer to input program*/ 


strcpy(file_buffer, ""); 

vhile(strcmp(file_buffer, "quit”) != 0) /*main loop*/ 

{ 

printf("Enter filename or quit to stop program\n==>> "); 
scanf("%s", file_buffer); /*get input filename*/ 
if(strcmp(file_buffer, "quit") != 0) 

{ 

if((filefp = fopen(file_buffer, "r")) == NULL) /*open file*/ 
printf("Error opening file Xs\n", file_buffer); 
else /*file opened for reading*/ 

{ 

loc = 0; /initialize lines of code count*/ 
blank_cnt = 0; /initialize blank line count*/ 
comm_cnt = 0; /initialize comment line count*/ 
brace_cnt = 0; /initialize brace line count*/ 
decla cnt = 0; /initialize declaration line count*/ 
comm_pres = FALSE; /*no comment*/ 
decla_pres = FALSE; /*no declaration*/ 

vhile(fgets(inp_buffer, BUF_SIZE, filefp)) /*read pgm. line*/ 

{ 

instr_pres = FALSE; /*clear instruction presence*/ 
comm_counted = FALSE; /*line not counted as comment*/ 
decla_counted = FALSE; /*line not counted as declaration*/ 
brace_pres = FALSE; /*clear brace presence*/ 
for(i = 0;inp_buffer[i] != '\n'; i++) 

{ 

if((inp_buffer[i] == '/') AA (inp_buffer[i + 1] == '*')) 
comm pres = TRUE; /*beginning of comment found*/ 
c = inp_buffer[i]; 

if(((c == 'c') || (c == 'd') || (c == 'f') || (c == 'i') || 
(c == '!') || (c == 's') || (c == 'F')) AA (!comm_pres)) 

{ /*lst letter in declarations*/ 
if(isdecla(inp_buffer, i)) 
decla_pres = TRUE; 

} /*end if*/ 

if((inp_buffer[i] == ';') AA (decla_pres)) 

{ 

decla pres = FALSE; /*cancel decla. presence*/ 
decla_counted = TRUE; /*mark line as counted*/ 

} /*end if*/ 

if((isgraph(inp_buffer[i 1 )) AA (!comm_pres) AA 

(inp buffer[ij != '{') AA (inp_buffer[i ] != ')')) 
instr_pres = TRUE; /*print char, not sp, comm, or brace*/ 
if((inp_buffer[i] == ’{') || (inp_buffer[i ] == ')') AA 
(!instr_pres) AA (!comm_pres)) 
brace_pres = TRUE; /*brace found*/ 
if((inp_buffer[i - 1] == '*') AA (inp_buffer[i] == '/')) 

{ 

comm pres = FALSE; /*cancel comment presence*/ 














64 


if((!instr_pres) && (!comm_counted) && (!brace_pres) && 

(ldecla_pres)) 

[ 

comm_cnt++; /*add to comment count*/ 

comm_counted = TRUE; /*mark line as counted for comm*/ 

} /*end if*/ 

} /*end if*/ 

} /*end for*/ 

if((decla_pres) || (decla_counted)) 

decla cnt++; /*add to declaration line to count*/ 
else if(instr_pres) 

loc++; /*add to lines of code*/ 
else if((comm_pres) && (!brace_pres)) 

comm_cnt++; /*add comment line to count*/ 
else if(brace_pres) 

brace_cnt++; /*add to brace line count*/ 
else if(!comm_counted) 

blank_cnt++; /*add to blank line count*/ 
if((comm_counted) && (instr_pres)) 

comm_cnt—; /*correct comm, count if intr. is found*/ 

) /*end while*/ 

printf("\nTotal lines of code = Xd\n", loc + decla_cnt + 
brace_cnt); 

printf(" Total declaration lines of code = %d\n", declacnt); 
printf(" Total non-declaration lines of code = %d\n", loc); 
printf(" Total brace lines = Xd\n", brace_cnt); 
printf("Total comment lines = £d\n", comm_cnt); 
printf("Total blank lines = %d\n", blank_cnt); 
printf("\nTotal program lines = 2d\n\n",loc + decla_cnt + 
comm_cnt + brace_cnt + blank_cnt); 
fclose(filefp); /*close input file*/ 

) /*end else*/ 

} /*end if*/ 

) /*end while*/ 

) /*end main*/ 


* * 

* This function is used to determine if a declaration line has * 

* been found. This function is called whenever a character is * 

* found that matches the first character of the different * 

* variable declaration types (e.g., char, int, float, etc.). * 

* This program assumes that these keywords are always followed * 

* by at least one space in the input program. Function * 

* declaration lines are not counted as declaration lines. * 

* * 


* If a match is found, a TRUE condition is returned to the main * 

* program. A FALSE condition is returned otherwise. * 

* * 

isdecla(buffer, i) 
char bufferf ] ; 
int i; 

{ 










int j, type; 
char c; 


65 


c = buffer[i]; 

type = FALSE; 

if(c == 'c') /*char*/ 

{ 

if ((buffer! i + 1] == 'h') 66 (buffer[i + 21 == 'a') 66 
(bufferji + 3] == 'r') 66 (buffer!i + 4] == ' ')) 

{ 

type = TRUE; 
j = i + 5; 

} /*end if*/ 

} /*end if*/ 

else if(c == 'i') /*int*/ 

{ 

if((buffer[i + 1] == 'n') 66 (buffer[i + 2] == 't') 66 
(buffer!i + 3 ] == ' ')) 

{ 

type = TRUE; 
j = i + 4; 

} /*end if*/ 

) /*end else if*/ N 

else if(c == 'd') /*double*/ 

{ 

if((buffer[i + 1] == 'o') 66 (buffer[i + 2] == 'u') 66 
(buffer! i + 3) == ' b') 66 (buffer[i + 4] == '1') 66 
(bufferji + 5] == 'e') 66 (buffer[i + 6J == ' ')) 

{ 

type = TRUE; 
j = i + 2; 

} /*end if*/ 

} /*end else if*/ 
else if(c == 'f') /*float*/ 

{ 

if((buffer(i + 1] == '1') 66 (bufferfi + 2) == 'o') 66 
(buffer[i + 3] == 'a') 66 (bufferfi + 4] == 't') 66 
(buffer!i + 5] == ' ')) 

{ 

type = TRUE; 
j = i + 6; 

} /*end if*/ 

) /*end else if*/ 
else if(c == '1') /*long*/ 

( 

if((buffer[i + 1] == 'o') 66 (bufferji + 2] == 'n') 66 
(buffer[i + 3] == 'g') 66 (buffer[i + 4) == ' ')) 

{ 

type = TRUE; 
j = i + 5; 

) /*end if*/ 

} /*end else if*/ 
else if(c == 's') /*short*/ 

( 

if((buffer[i + 1] == 'h') 66 (buffer[i + 2] == 'o') 66 






(buffer[i + 3) == 'r') && (buffer(i + 4] == 't') && 
(buffer!i + 5] == ' ')) 

{ 

type = TRUE; 

j = i + 6; 

) /*end if*/ 

} /*end else if*/ 
else if(c == *F') /*FILE*/ 

{ 

if ((buffer} i + 1] == 'I') && (buffer[i - 2] == ' L' ) &*. 
(bufferli + 3] == 'E') &£. (buffer{i + 4] == ' ')) 

{ 

type = TRUE; 
j = i + 5; 

} /*end if*/ 

) /*end else if*/ 
if(type == TRUE) 

{ 

for(;buffer[j ] != '\n';j++) 

if(buffer!j] == '(') /*function declaration*/ 
return (FALSE); 
return (TRUE); 

} /*end if*/ 
return (FALSE); 

) /*end isdecla*/ 





67 


/****************************************************************** 

* Lines of Code Metric (Ada) * 

******************************************************************* 

★ * 

* File: loc_adal.c * 

* Author: Villiam R. Torres * 

* Date: 90/03/12 * 

* Class: COMSC 5000 - Thesis * 

* Adviser: Dr. Mansur Samadzadeh * 

* * 

******************************************************************* 
* ★ 

* This program computes the lines of code for correct Ada * 

* language source code. The input for this program consists * 

* of the filename of the file for which the lines of code * 

* metric is desired. The output is broken down into five * 

* categories: actual Ada language lines of code, variable * 

* declaration lines of code, non-declaration lines of code, * 

* comments lines, and blank lines. * 

* * 

* The following criteria is used to categorize the lines: * 

* (1) all lines in which Ada statements are present, even if * 

* they include comments or multiple statements separated by * 

* terminators (;), are counted as one line of code, (2) all * 

* lines with comments and no Ada statements are counted as one * 

* comment line, (3) all other lines are considered blank lines. * 

* * 

* The following criteria is used to subdivide the lines of * 

* code: (1) all lines in which a variable is declared are * 

* counted as declaration lines and (2) all other lines are * 

* counted as non-declaration lines. * 

* * 

******************************************************************/ 

#include <stdio.h> 

#include <ctype.h> 

^define BUF_SIZE 80 
#define TRUE 1 
#define FALSE 0 


main() 

{ 

int loc, 

blank_cnt, 
comm_cnt, 
comm_pres, 
instr_pres, 
paren_count, 
decla_cnt, 
decla_pres, 
term_pres, 
i; 

char inp_buffer[BUF 
file_buffer[25 
FILE *filefp; 


/*lines of code*/ 

/*blank line count*/ 

/*comment line count*/ 

/*comment present*/ 

^instruction present*/ 

/*parenthesis count*/ 

/*declaration line count*/ 
/*declaration line presence*/ 
/*command terminator (;) presence*/ 

_SIZE], /*buffer for program lines*/ 

); /*buffer for input program filename*/ 

/*pointer to input program*/ 







68 


strcpy(file_buffer, 

vhile(strcmp(file buffer, "quit”) != 0) /*main loop*/ 

{ 

printf("Enter filename or quit to stop program\n==>> "); 
scanf("2s", file_buffer); /*get input filename*/ 
if(strcmp(file_buffer, "quit") != 0) 

( 

if((filefp = fopen(file_buffer, "r")) == NULL) /*open file*/ 
printf("Error opening file %s\n", file_buffer); 
else /*file opened for reading*/ 

{ 

loc = 0; /initialize lines of code count*/ 
blank_cnt = 0; /initialize blank line count*/ 
comm_cnt = 0; /initialize comment line count*/ 
decla_cnt = 0; /initialize declaration line count*/ 
paren_count «= 0; /*clear parenthesis count*/ 

vhile(fgets(inp_buffer, BUF_SIZE, filefp)) /*read pgm. line*/ 

{ 

instr_pres = FALSE; /*clear instruction presence*/ 
decla_pres = FALSE; /*clear declaration presence*/ 
comm pres = FALSE; /*no comment*/ 
term_pres = FALSE; /*clear terminator presence*/ 
for(i = 0;inp_buffer[i] != '\n'; i++) 

l 

if((inp_buffer[i] »= '-') && (inp_buffer[i + 1] == '-')) 
comm_pres = TRUE; /*comment found*/ 
if(inp_buffer{i ] == '(') 

paren_count++; /*opening parenthesis found*/ 
if(inp_buffer[i] == ')') 

paren_count—; /*closing parenthesis found*/ 
if((inp_buffer[i ] == ':') && (inp_buffer[i + 1] != ' = ') && 
(paren_count == 0) && (! comm_pres)) 
decla_pres = TRUE; /*declaration found*/ 
if(inp_buffer[i] == ';') 

term pres = TRUE; /*command terminator present*/ 
if ((isgraph(inp_buf fer [ i ])) £>& (! comm_pres)) 

instr_pres = TRUE; /*print char, not sp, or comm*/ 

) /*end for*/ 

if((decla_pres) && (term_pres)) 

decla_cnt++; /*add to declaration line to count*/ 
else if(instr_pres) 

loc++; /*add to lines of code*/ 
else if(comm_pres) 

comm_cnt++; /*add comment line to count*/ 
else 

blank_cnt++; /*add to blank line count*/ 

) /*end while*/ 

printf("\nTotal lines of code = 2d\n", loc * decla__cnt); 
printf(" Total declaration lines = ?id\n", decla_cnt); 
printf(" Total non-declaration lines = °od\n", loc); 
printf("Total comment lines = %d\n", comm_cnt); 
printf ("Total blank lines = 5id\n", blank_cnt); 
printf("\nTotal program lines = %d\n\n",loc + decla_cnt + 
comm cnt + blank cnt); 





69 

fclose(filefp); /*close input file*/ 

} /*end else*/ 

} /*end if*/ 

) /*end while*/ 

} /*end main*/ 







APPENDIX B 


ADA PROGRAMS INCLUDED IN THE STUDY 





71 


_ **■***************************-***********★********★******★*'***★*>*** 

—* Integer List (lof2) * 

_ ******************************************************************* 

* 

—* File: intmain.ada * 

—* Author: Ken Shumate * 

_* "Understanding Ada with Abstract Data Types" * 

_* John Wiley and Sons, 2nd ed., 1989 * 

_ * * 

_ **************-******************************'*********************** 


with TEXT_I0; use TEXT_IO; 

with Integer_List; use Integer_List; 

procedure Exercise_20_l is 

package Int_I0 is new INTEGER_IO(INTEGER); 
use Int_I0; 

Number : INTEGER; 
begin 

Initialize_J ist; 

PUT LINE("Enter list of numbers terminated by -1"); 

Create^List : loop 
A.1 GET(Number); 

A.2 exit Create_List when Number = -1; 

A.3 Insert_At_Head(Number); 

A.4 Insert_At_Tail(Number); 

end loop Create_List; 

PUT_LINE("The list of numbers is"); 

A.5 for I in 1. . List__Length loop 
A.6 PUT(Value_At_Position(I)); 

end loop; 

NEV_LINE; 

PUT_LINE("Chopping the ends off"); 

Delete_Head; 

Delete_Tai1; 

PUT_LINE("The list of numbers is"); 

A.7 for I in 1..List_Length loop 
A.8 PUT(Yalue_At_Position(I)); 

end loop; 

NEV_LINE; 

end Exercise_20_l; 

_ **★*+*★****★***★**★*★*********★**★★★*****++*★*★*★★*******★★★★**+*** 

—* Integer List (2 of 2) * 

__************************************+********+*+*+*+******* ******** 


_ * 



* 


File: intlist.ada 


* 

_ _ ★ 

Author: Ken Shumate 


* 


"Understanding 

Ada with Abstract Data Types” 

★ 


John Vi ley and 

Sons, 2nd ed., 1989 

★ 




★ 















72 


package Integer_List is 
procedure Initialize_List; 

procedure Insert At_Head(Value : in INTEGER); 
procedure Insert__At_Tail(Value : in INTEGER); 
procedure Delete Head; 
procedure Delete__Tai 1; 

function Value_At_Position(Pos : in POSITIVE); return INTEGER; 
function List_Length return NATURAL; 
end Integer_List; 

package body Integer_List is 
type List; 

type Link is access Lise; 
type List is record 
Value : INTEGER; 

Next : Link; 
end record; 

Free, Head, Tail : Link; 

procedure Reclaim(P : in Link) is 

—add the node indicated by P onto the free list 

begin 

B.l if Free = null then 

B.2 Free := P; 

B.3 Free.Next := null; 

B.4 else 

B.5 P.Next := Free; 

B.6 Free := P; 

end if; 
end Reclaim; 

function Alloc(Initial_Value : List) return Link is 
—allocate storage and initialize it 


C.l 

P : Link := Free; 
begin 

C. 2 

if P = 

null then 

C. 3 

C. 4 

P : = 
else 

new List; 

C. 5 

F ree 
end if: 

:= Free.Next; 

C. 6 

P.all : 

:= Initial Value; 

C. 7 

return 

P; 


end Alloc; 


procedure Initialize_List is 
P : Link; 
begin 

D.l while Head /= null loop 

D.2 P := Head; 

D3 Head := Head.Next; 

D.4 Reclaim(P); 

end loop; 

D.5 Tail := null; 

end Initialize List; 







73 


procedure Insert_At_Head(Value : in INTEGER) is 
begin 

E.l Head := Alloc(List'(Value, Head)); 

E.2 if Tail = null then — new list 

E. 3 Tail := Head; 

end if; 

end Insert_At_Head; 

procedure Insert_At_Tail(Value : in INTEGER) is 
begin 

F. l if Head = null then — first item to put into list 

F.2 Head := Alloc(List'(Value, null)); 

F.3 Tail := Head; 

F.4 else 

F.5 Tail.Next := Alloc(List'(Value, null)); —tack onto end 

F. 6 Tail := Tail.Next; —move tail to the nev end of the list 

end if; 

end Insert_At_Tail; 

procedure Delete_Head is 

G. 1 P : Link := Head; 

begin 

G.2 Head := Head.Next; 

G.3 Reclaim(P); 

G.4 if Head = null then —deleted last item in list 

G. 5 Tail := null; 

end if; 

end Delete_Head; 

procedure Delete_Tail is 

H. l P : Link := Head; 

begin 

H.2 if Head = Tail then —single item list 

H.3 Head := null; 

H.4 Tail := null; 

H.5 else —more than one item in list 

H.6 while P.Next /= Tail loop 

H.7 P := P.Next; 

end loop; 

—P now points to the next to last item in the list 
H.8 Reclaim(Tail); 

H. 9 Tail := P: 

H. 10 Tail.Next := null; 

end if; 

end Delete_Tail; 

function Value_At_Position(Pos : in POSITIVE) return INTEGER is 

I. 1 P : Link := Head; 

begin 

1.2 for I in 2..Pos loop 

1.3 P := P.Next; 
end loop; 

1.4 return P.Value; 






74 


end Value_At_Position; 

function List_Length return NATURAL is 
Len : NATURAL := 0; 

J.l P : Link := Head; 
begin 

J.2 while P /= null loop 

J.3 Len := Len + 1; 

J.4 P := P.Next; 

end loop; 

J.5 return Len; 

end List Length; 
end Integer List; 




75 


—* Four Function Calculator (1 of 3) * 


- * * 

—* File: calcmain.ada * 
—* Author: Gerald L. Mohnkern and Beverly Mohnkern * 
—* "Applied Ada" * 
—* Tab Professional and Reference Books, 1986 * 
_* ★ 


with TEXT_IO, FPSTACK, FL0AT_C0NV; 
procedure CALCULATE2 is 

use TEXT_IO, FPSTACK, FL0AT_C0NV; 
package F_I0 is new FL0AT_I0(FLOAT); 
subtype LINE40 is STRING(1..40); 

STR : LINE40 := (1..40 => ' ' ); 

NUM_VAL : FLOAT := 0.0; 

FIRST : BOOLEAN := TRUE; 

LEN : NATURAL; 

INVALID_ENTRY : exception; 

procedure DIRECTIONS is —To display directions for use 
begin 

NEV_LINE; 

PUT_LINE("This is a simple calculator program. It can "); 
PUT_LINE("add(+), subtract(-), multiply(*), and "); 
PUT_LINE("divide(/). The calculator uses reverse Polish"); 
PUT_LINE("notation and has a stack holding up to ten"); 
PUT_LINE("floating point numbers. Numbers and operators"); 
PUT_LINE("must be entered one per line. Enter 'R' for"); 
PUT_LINE("reset to start over, ' ?' to get directions,"); 
PUT_LINE("'D' to delete last entry, and 'Q' to quit."); 
NEW_LINE; 
end DIRECTIONS; 

procedure OPERATE(STRG : LINE40) is 
X, Y : FLOAT; 
begin 

case STRG(l) is 


B.l 

when '+' => POP(X); POP(Y); 

Y 

: = X + 

Y; 

B. 2 

PUSH(Y); F IO.PUT(Y); 




B. 3 

when => POP(X); POP(Y); 

Y 

:= Y - 

X; 

B. 4 

PUSH(Y); F IO.PUT(Y); 




B. 5 

when => POP(X); POP(Y); 

Y 

:= X * 

Y; 

B. 6 

PUSH(Y); F IO.PUT(Y); 




B. 7 

when '/' => POP(X); POP(Y); 

Y 

: = Y / 

X; 

B. 8 

PUSH(Y); F IO.PUT(Y); 




B. 9 

when 'r' | 'R' => CLEAR; 




B.10 

vhen 'd' | 'D' => POP(X); 




B.ll 

when '?' => DIRECTIONS; 




B. 12 

vhen 'q' | 'Q' => null; 




B. 13 

vhen others => raise INVALID ENTRY; 



end case; 





NEV LINE; 





76 


end OPERATE; 


A. 1 


A.2 


A.3 


A.4 
A.5 


A.6 
A.7 


A.8 


begin —Body of CALCULATE2 
DIRECTIONS; 

while STR(l) /= 'Q' and STR(l) /= 'q' loop 

ERROR_SCOPE: begin —Block containing exception handler 

if not FIRST then 


SKIP_LIN£; 
end if; 

GET_STRING(STR, LEN); 

NEV_LINE; 

FIRST := FALSE; 

if (STR(l) in '0' .. '9') or (STR(l) - or 

(STR(l) = and LEN > 1) then 
STR_T0_FLT(STR, LEN, NUM_VAL); 

PUSH(NUM_VAL); 
else 


A.9 OPERATE(STR); 

end if; 

exception —Handler for block ERR0R_SC0PE 
A.10 when INVALID_ENTRY => PUT_LINE(" Invalid entry.”); 

A.11 when NUMERIC_ERR0R => 

PUT_LINE(" Attempt to divide by zero."); 
end ERR0R_SC0PE; 
end loop; 
end CALCULATE2; 


—* Four Function Calculator (2 of 3) * 


- ★ * 

—* File: calcstac.ada * 
—* Author: Gerald L. Mohnkern and Beverly Mohnkern * 
—* "Applied Ada" * 
—* Tab Professional and Reference Books, 1986 * 
—* * 


- ***★*★**★*************★**★★★************** 


package FPSTACK is 

procedure CLEAR; --Resets the stack 
procedure PUSH(NUM : FLOAT); 
procedure P0P(NUM : out FLOAT); 
STACK_0VERFL0W, STACK_UNDERFLOV: exception; 
end FPSTACK; 

package body FPSTACK is 
NUH : FLOAT; 

LIMIT : constant NATURAL := 10; 

STACK : array(1 .. LIMIT) of FLOAT; 

TOP : NATURAL := 0; 

procedure PUSH(NUM : FLOAT) is 
begin 

C.l if TOP = LIMIT then 

raise STACK_0VERFL0V; 

C.2 else 








77 


C.3 TOP := TOP + 1; 

C.4 STACK(TOP) :« NUM; 

end if; 
end PUSH; 

procedure POP(NUM : out FLOAT) is 
begin 


D. 1 

if TOP = 

0 then 


raise 

STACK_UNDERFLOV; 

D.2 

else 


D.3 

NUM : = 

STACK(TOP); 

D.4 

TOP : = 
end if; 

TOP - 1; 


end POP; 


procedure CLEAR is 
begin 


E.l TOP := 0; 
end CLEAR; 
end FPSTACK; 


—* Four Function Calculator (3 of 3) * 


_ * 

—* File: calcfloa.ada 

—* Author: Gerald L. Mohnkern and Beverly Mohnkern 

—* "Applied Ada" 

—* Tab Professional and Reference Books, 1986 

_ * 


* 

* 

* 

* 

* 

* 


_ *★*★★*★*★★*★★★★★★★★★★★★★★★★★★★★★*★★★★**★*★★★★*★*★★★***★★★**★*★★*★★* 


with TEXTJtO; use TEXT_I0; 
package FL0AT_C0NV is 

subtype LINE40 is STRING(1 .. 40); 
INVALID_ENTRY : exception; 
procedure GET_STRING(STR : out LINE40; 

LEN : out NATURAL); 
procedure STR_T0_FLT(STR : LINE40; 

LEN : NATURAL; 

NUM_VAL : out FLOAT); 

end FL0AT_C0NV; 

package body FL0AT_C0NV is 

procedure GET_STRING(STR : out LINE40; 

LEN : out NATURAL) is 

CH : CHARACTER; 

CUK_C0UNT : NATURAL := 0; 
begin 

F.l while not END_QF_LINE loop 

F.2 GET(CH); 

F.3 CUM_C0UNT := CUM_C0UNT + 1; 

F.4 STR(CUM_C0UNT) := CH; 

end loop; 

F. 5 LEN := CUM_C0UNT; 

end GET STRING; 



78 


procedure STR_T0_FLT(STR : LINE40; 

LEN : NATURAL; 

NUM_VAL : out FLOAT) IS 

X : FLOAT := 0.0; 

SIGN : FLOAT := 1.0; 

D£CIMAL_POINT : BOOLEAN := FALSE; 

COUNT : INTEGER := 0; 

EXP : INTEGER := 0; 

EXP_SIGN : INTEGER := 1; 

INDEX : INTEGER := 1; 

CH, CHR : CHARACTER; 

begin 

G.l if STR(l) = then 
G.2 SIGN := -1.0; 

G.3 INDEX := 2; 

end if; 

G.4 while INDEX <= LEN loop 
G. 5 CH := STR(INDEX); 

case CH is 

G.6 when '.' => DECIMAL POINT := TRUE; 

G.7 when 'O'..'9' => X 7 = X * 10.0 

+ FLOAT(CHARACTER'POS(CH) - CHARACTER'POS('0')); 
G.8 if DECIMAL_POINT then 

G. 9 COUNT := COUNT + 1; 

end if; 

G.10 when 'E' | 'e' => 

G.ll for JDEX in (INDEX + 1)..LEN loop 

G. 12 CHR := STR(JDEX); 

case CHR is 

G. 13 when '0'..'9' => 

EXP := EXP * 10 + CHARACTER'POS(CHR) 

- CHARACTER'P0S('0'); 

G.14 when '-' => EXP_SIGN := -1; 

G.15 when others => raise INVALID_ENTRY; 

end case; 
end loop; 

G.16 INDEX LEN; 

G.17 when others => raise INVALID_ENTRY; 

end case; 

G.18 INDEX := INDEX + 1; 

end loop; 

G.19 NUM_VAL := SIGN * X * 10.0**(EXP_SIGN * EXP - COUNT); 
end STR_TO_FLT; 
end FLOAT CONV; 








79 


—* Address Book (lof 12) * 


_ * * 

—* File: addrdec.ada * 

—* Author: Gerald L. Mohnkern and Beverly Mohnkern * 

—* "Applied Ada" * 

_* Tab Professional and Reference Books, 1986 * 

_ * * 


*•*★**★*★★*★*★***★*************★******* 


with DIRECT_IO; 

with TEXT_IO; use TEXT_IO; 

package ADDRDEC is 

subtype LINE40 is STRING(1..40); 
type ADDRESS is record 

NAME : STRING(1..40) := (1..40 => ' '); 

STREET : STRING(1..40) := (1..40 => ' '); 

CITY : STRING(1..20) := (1..20 => ' '); 

STATE : STRING(1..2) := ” "; 

ZIP : STRING(1..5) := (1..5 => ' '); 

AREA : STRING(1..3) := " "; 

PHONE : STRING (1. . 8) := (1..8 => ' 
end record; 
type KEY is record 

NAME : STRING(1..40) := (1..40 => ' '); 

PT_DATA : POSITIVE; 
end recoid; 

MAX_SIZE : constant := 20; —Maximum size of deletion array 

type INT_ARRAY is array (POSITIVE range <>) of INTEGER; 
type KEY_ARRAY is array (POSITIVE range <>) of KEY; 
type LIST(SIZE : NATURAL) is record 
LAST REC : INTEGER; 

NEXT[_'SPACE : INTEGER; 

SPACE : INT_ARRAY(1..MAX_SIZE); 

KEYLIST : KEY_ARRA V (1..SIZE); 
end record; 

type A_LIST is access LIST; 

package ADDRESS_I0 is new DIRECT_I0(ADDRESS); 
package INDEX_I0 is nev DIRECT_I0(LIST); 

type OPERATION is (CREATE, ADD, DELETE, CHANGE, SEARCH, QUIT); 
QUITTING : exception; 

INDX_ID : INDEX_I0.FILE_TYPE; 

DATA_ID : ADDRESS_I0-FILE TYPE; 

DATA_NAME : constant STRING := "ADDRBK1"; 

INDX_NAME : constant STRING : = "ADDRINDX1"; 
end ADDRDEC; 

- ★ ★★★★*★★★★★**★**★★**★★★★★★★★*★★★★*★★****★★********★★*****★******:*■** 

—* Address Book (2 of 12) * 

_* 

—* File: addrmain.ada 


★ 

k 









80 



Author: Gerald L. Mohnkern and Beverly Mohnkern 

"Applied Ada" 

Tab Professional and Reference Books, 1986 


* 

★ 

"k 

* 


★★★★★★★★★★★it**************★★★*★***★*★★*★*★★★★★★*★*★★★★***★★★★**★★** 


vith TEXT_I0? use TEXT_10; 
with GET_STRING; 
vith DISPLAY; 

vith ADDRDEC; use ADDRDEC; 

vith START_UP; 

vith ENTER_DATA; 

vith CREATE_LIST; 

vith SELECT_ALTERNATIVE; 

vith SEARCH; 

vith ALTER_DATA; 

vith INSERT; 

vith DELETE; 


procedure ADDRESS_B00K is 
NAME : STRING(1..40); 
PT_LIST : A_LIST; 

LEN_LIST : A_LIST; 

DATA : ADDRESS; 

INDEX : INTEGER; 

FOUND : BOOLEAN; 

OP : OPERATION; 

FIRST : BOOLEAN := TRUE; 


procedure GET_NAME(NAME : in out STRING) is 

COUNT : INTEGER; 

begin 

PUT_LINE("Enter name(last, first)"); 

SKIP_LINE; 

B.l GET_STRING(NAME, COUNT); 

B. 2 for I in COUNT + 1..NAME'LAST loop 
B.3 NAME(I) 

end loop; 
return; 
end GET_NAME; 

begin —Open Files and Load Index from File 
A.1 PT_LIST := nev LIST(O); 

A.2 LEN_LIST := nev LIST(O); 

A.3 START_UP(PT_LIST, LEN_LIST, FIRST); 

loop 

A.4 SELECT_ALTERNATIVE(OP, FIRST); 

case OP is 

A.5 vhen CREATE => CREATE_LIST(PT_LIST, LEN_LIST); 

A.6 vhen ADD => ENTER_DATA(DATA); 

A.7 INSERT(DATA, PT_LIST); 

A.8 vhen CHANGE => GET_NAME(NAME); 

A.9 SEARCH(SEEK_NAME => NAME, 

PT_LIST => PT_LIST, 

DATA = > DATA, 








81 


A. 10 
A.11 
A.12 


A.13 


A.14 
A.15 
A.16 
A.17 


A.18 
A.19 
A.20 


A.21 

A.22 

A.23 
A.24 
A.25 
A.26 
A.27 


INDEX => INDEX, 

FOUND => FOUND); 
if FOUND then 
ALTER_DATA(DATA); 

ADDRESS_IO.WRITE(DATA_ID, DATA, 
ADDRESS_IO.POSITIVE_COUNT 
(PT_LIST.KEY_LIST(INDEX).PT_DATA)); 

else 

PUT_LINE("Name not found."); 
end if; 

when DELETE => GET_NAME(NAME); 

DELETE(NAME, PT_LIST); 
when SEARCH => GET_NAME(NAME); 

SEARCH(SEEK_NAME => NAME, 

PT_LIST => PT LIST, 

DATA => DATA, - 
INDEX => INDEX, 

FOUND => FOUND); 
if FOUND then 
DISPLAY(DATA); 
else 

PUT_LINE("Name not found."); 
end if; 

when QUIT => null; 
end case; 

exit when OP = QUIT; 
end loop; 

LEN_LIST.LAST_REC := PT_LIST.SIZE; 

INDEX_I0.WRITE(INDX_ID, LEN_LIST.?11, 1); 

INDEX_I0.VRITE(INDX_ID, PT_LIST.all, 2); 

INDEX_I0.CLOSE(INDX_ID); 

ADDRE S S_10.CLO SE(DATA_ID); 


end ADDRESS_B00K; 

—* Address Book (3 of 12) * 


- * * 

—* File: startup.ada * 

—* Author: Gerald L. Mohnkern and Beverly Mohnkern * 

"Applied Ada" * 

—* Tab Professional and Reference Books, 1986 * 

- * * 


-★★★★**■★*★***★**-*****■★★★**•******★★ * •k'k'k’k 


with TEXT_I0; use TEXT_I0; 
with ADDRDEC; use ADDRDEC; 
with GET_STRING; 
with CREATE_LIST; 

procedure START_UP(PT_LIST : in out A_LIST; 

LEN_LIST : in out A_LIST; FIRST : in out BOOLEAN) is 
RESPONSE : STRING(1..40); 

LEN : NATURAL; 


begin 




82 


0PEN_INDX : 
begin 

C.l INDEX 10.0PEN(INDX_ID, INDEX 10.INOUTFILE, INDX NAME); 

C.2 INDEX_IO.READ(INDX_ID, LEN_LIST.all, 1); 

C.3 PT_LIST := new LIST(LEN_LIST.LAST_REC); 

C.4 INDEX_IO.READ(INDX_ID, PT_LIST.aH, 2); 
exception 

C.5 when INDEX_IO.NAME_ERROR => 

PUT_LINE("There is no Index File. Do you”); 

PUT_LINE(''vant to create one (C) or quit (Q)?"); 

C.6 GET_STRING(RESPONSE, LEN); 

C.7 FIRST := FALSE; 

C.8 if RESPONSE(l) = 'Q' or RESPONSE(l) = 'q' then 

raise QUITTING; 

C.9 else 

C.10 CREATE_LIST(PT_LIST, LEN_LIST); 

end if; 

end OPEN_INDX; 

OPEN_DATA : 
begin 

C.ll if not ADDRESS_IO.IS_OPEN(DATA_ID) then 

C. 12 ADDRESS_IO.OPEN(DATA_ID, ADDRESS_IO.INOUT_FILE, DATA_NAME); 

end if; 
exception 

C.13 when ADDRESS_IO.NAME_ERROR => 

PUT_LINE(''fhere is no Data File. Do you"); 

PUT_LINE("vant to create one (C) or quit (Q)?"); 

C.14 if FIRST then 

C.15 FIRST := FALSE; 

C.16 else 

SKIP_LINE; 
end if; 

C.17 GET_STRING(RESPONSE, LEN); 

C. 18 if RESPONSE(l) = 'O' or RESPONSE(l) = 'q' then 

raise QUITTING; 

C.19 else 

C.20 INDEX_I0.DELETE(INDX_ID); 

C.21 CREATE_LIST(PT_LIST, LEN_LIST); 

end if; 

end 0PEN_DATA; 
end STARTJJP; 

—* A d d r e s s Book (4 of 12) * 

- * * 

—* File: crelist.ada * 

—* Author: Gerald L. Mohnkern and Beverly Mohnkern * 

—* "Applied Ada" * 

—* Tab Professional and Reference Books, 1986 * 

- * * 


with TEXT 10; use TEXT 10; 







83 


with ADDRDEC; use ADDRDEC; 
with ENTER_DATA; 

procedure CREATE_LIST(PT_LIST : in out A_LIST; 

LEN_LIST : in out A_LIST) is 
RESPONSE : STRING(1..40); 

INIT_K£Y : KEY; 

DATA : ADDRESS; 


begin 

FILE1_GEN : 
begin 

D.l ADDRESS_IO.CREATE(DATA_ID, ADDRESS_IO.INOUT_FILE, DATA_NAME); 

exception 

D.2 when ADDRESS 10.STATUS_ERR0R => 

D.3 ADDRESS_IO.DELETE(DATA_ID); 

D.4 ADDRESS_IO.CREATE(DATA_ID, ADDRESS_IO.INOUT_FILE, DATA_NAME); 

end FILEl^GEN; 

FILE2_GEN : 
begin 

D.5 INDEX_I0.CREATE(INDX_ID, INDEX_I0.INOUT_FILE, INDX_NAME); 

exception 

D.6 when INDEX_I0.STATUS_ERR0R => 

D.7 INDEX_I0.DELETE(INDX_ID); 

D.8 INDEX_I0.CREATE(INDX_ID, INDEX_I0.INOUT_FILE, INDX_NAME); 

end FILE2_GEN; 

D.9 ENTER_DATA(DATA); 

D.10 ADDRESS_IO.VRITE(DATA_ID, DATA, 1); 

D.11 INIT_KEY.NAME := DATA.NAME; 

D.12 INITJCEY.PT_DATA := 1; 

D.13 PT_LIST := new LIST'(SIZE => 1, 

LAST_REC => 1, 

NEXT_SPACE => 0, 

SPACE => (1..MAX_SIZE => 0), 

KEY_LIST => KEY_ARRAY'(1 => INIT_KEY)); 

D.14 LEN_LIST.LAST_REC := 1; 

D.15 LEN_LIST.NEXT_SPACE 0; 

D. 16 LEN__LIST. SPACE := (LEN_LIST. SPACE'RANGE => 0); 
end CREATE_LIST; 

Address Book (5 of 12) * 

_ **★**★***★*****★★★★★*★★*■****■** ★★★★★★★ 

_ * * 

—* File: entdata.ada * 

—* Author: Gerald L. Mohnkern and Beverly Mohnkern * 

—* "Applied Ada" * 

Tab Professional and Reference Books, 1986 * 

* 


with TEXT_I0; use TEXT_I0; 
with ADDRDEC; use ADDRDEC; 
with GET STRING; 







84 


with ALTERJDATA; 
with DISPLAY; 

procedure ENTER_DATA(DATA : out ADDRESS) is 
RESPONSE : STRING(1..40); 

COUNT : INTEGER; 

NEV ADDRESS : ADDRESS; 


begin 

PUT LINE("Enter name of addressee(last, first)."); 

SKIP_LINE; 

E.l GET_STRING(NEV_ADDRESS.NAME, COUNT); 

PUT LINE("Street address"); 

SKIP_LINE; 

E.2 GET_STRING(NEV_ADDRESS.STREET, COUNT); 

PUT_LINE("City"); 

SKIP_LINE; 

E.3 GET_STRING(NEV_ADDRESS.CITY, COUNT); 

PUT_LINE("Two-letter abbreviation for state"); 

SKIP_LINE; 

E.4 GET_STRING(NEW_ADDRESS.STATE, COUNT); 

PUT_LINE("Five digit zip code"); 

SKIP_LINE; 

E.5 GET_STRING(NEW_ADDRESS.ZIP, COUNT); 

PUT_LINE("Phone area code"); 

SKIP_LINE; 

E.6 GET_STRING(NEV_ADDRESS.AREA, COUNT); 

PUT_LINE("Phone number"); 

SKIP_LINE; 

E.7 GET_STRING(NEV_ADDRESS.PHONE, COUNT); 

E.8 DISPLAY(NEV_ADDRESS); 

PUT_LINE("Is this correct? (Y/N)"); 

SKIP_LINE; 

E.9 GET_STRING(RESPONSE, COUNT); 

E.10 if RESPONSE(l) /= 'Y' and RESPONSE(l) /= 'y' 

E.11 then ALTER_DATA(NEV_ADDRESS); 
end if; 

E.12 DATA := NEW ADDRESS; 
end ENTER_DATA; 

—* Address Book (6 of 12) * 

- •k’k-k-k-k-k'k'k'k'k'k'^-k'k’k’k-k'^-^-k'k-^'k'k-kir'k'k'k-k'k-k^ic^ir'k 


* 

—* File: display.ada * 

—* Author: Gerald L. Mohnkern and Beverly Mohnkern * 

"Applied Ada" * 




85 


—* Tab Professional and Reference Books, 1986 * 

_ * * 

_ ******************************************************************* 


vith TEXT_I0; use TEXT_I0; 
with ADDRDEC; use ADDRDEC; 

procedure DISPLAY(DATA : ADDRESS) is 
begin 

F.l PUT_LINE(DATA.NAME); 

F.2 PUT_LINE(DATA.STREET); 

F.3 PUT(DATA.CITY);PUT(", ");PUT(DATA.STATE); 

F.4 PUT(" ");PUT(DATA.ZIP);NEV_LINE; 

F.5 PUT(DATA.AREA);PUT("-");P UT(DATA.PHONE);NEV_LINE; 

end DISPLAY; 

—* Address Book (7 of 12) * 

_ **★*★*★★★*★★**★*★★★*★**★★★***★★★★★★★★**★★*★**★★★★★★★★★★★★*★★★★***** 


_ 'k 



★ 

_ -k 

File: altdata.ada 


* 

_* 

Author: Gerald L. Mohnkern and Beverly 

Mohnkern 

* 

_* 

"Applied Ada" 


★ 

_★ 

Tab Professional and Reference 

Books, 1986 

fc 

-★ 



* 


_ ******************************************************************* 


vith TEXT_I0; use TEXT_I0; 
vith ADDRDEC; use ADDRDEC; 
vith GET_STRING; 
vith DISPLAY; 

procedure ALTER DATA(DATA : in out ADDRESS) is 
NUM_CHAR : NATURAL; 

RESPONSE : STRING(1..40); 

procedure ALTER FIELD(STRG : in out STRING) is 
REPLY : STRING(STRG'range) := 

(STRG'FIRST..STRG'LAST => ' '); 

IN_CHAR : NATURAL; 
begin 

H.l PUT_LINE(STRG); 

SKIP_LINE; 

H. 2 GET_STRING(REPLY, IN_CHAR); 

H. 3 if IN_CHAR > 0 then 
H.4 STRG := REPLY; 
end if; 

end ALTER_FIELD; 

begin — ALTER_DATA 
loop 

PUT_LINE("For each line push carriage return vithout"); 
PUT_LINE("entry to leave line unchanged. Othervise,"); 
PUT_LINE("enter a new line."); 

NEW LINE; 





86 


G.l ALTER_FIE’.D^ r >ATA.NAME); 

G.2 ALTER FIELD V UATA.STREET); 

G.3 ALTER~FIELD(DATA.CITY); 

G.4 ALTER FIELD(DATA.STATE); 

G.5 ALTER~FIELD(DATA.ZIP); 

G.6 ALTER_FIELD(DATA.AREA); 

G.7 ALTER_FIELD(DATA.PHONE); 

PUT_LINE("Address is nov: "); 

NEV_LINE; 

G.8 DISPLAY(DATA); 

NEV_LINE; 

PUT_LINE("Is this correct? (Y/N)"); 

G.9 RESPONSE(l) := 'Y'; 

SKIP_LINE; 

G.IO GET_STRING(RESPONSE, NUM_CHAR); 

G. 11 if RESPONSE(l) = 'Y' or RESPONSE(l) = 'y' then 
return; 
end if; 
end loop; 

end ALTER_DATA; 

—* Address Book (8 of 12) * 


- * * 

—* File: selalte.ada * 

—* Author: Gerald L. Mohnkern and Beverly Mohnkern * 

—* "Applied Ada" * 

—* Tab Professional and Reference Books, 1986 * 

* 


*******************************************•> *********************** 


with TEXT_I0, ADDRDEC; 
use TEXT_I0, ADDRDEC; 
with GET_STRING; 

procedure SELECT_ALTERNATIVE(MODE : out OPERATION; 

FIRST : in out BOOLEAN) is 

RESPONSE : STRING(1..40); 

COUNT : INTEGER; 


begin 

loop 

PUT_LINE("Data base operations are:"); 

NEW_LINE; 

PUT_LINE(" INITIALIZE DELETE"); 

PUT_LINE(" CHANGE SEARCH"); 

PUT_LINE(" ADD QUIT”); 

NEW_LINE; 

PUT_LINE("Enter first character of selection."); 

1.1 if not FIRST then 

SKIP_LINE; 
end if; 

1.2 GET_STRING(RESPONSE, COUNT); 





87 


1.3 

1.4 


1.5 

1.6 


1.7 

1.8 

1.9 

1.10 
1.11 


1.12 

1.13 


1.14 


FIRST := FALSE; 
case RESPONSE(l) is 

when 'I' j 'i' => MODE := CREATE; 

PUT_LINE("Initialize replaces your address files!”); 
PUT_LINE("Do you want to continue? (Y/N)”); 

SKIP LINE; 

GET_STRING(RESPONSE, COUNT); 

if RESPONSE(l) = 'Y' or RESPONSE(l) = 'y' then 


return; 
end if; 

when 'C' | 'c' => MODE := CHANGE; return; 

when 'A' j 'a' => MODE : = ADD; return; 

when 'D' j 'd' => MODE := DELETE; return; 

when 'S' | 's' => MODE := SEARCH; return; 

when 'Q' | 'q' => MODE := QUIT; 

PUT_LINE("QUIT (Y/N)?"); 

SKIP_LINE; 

GET_STRING(RESPONSE, COUNT); 
if RESPONSE(l) «= 'Y' or RESPONSE(l) = 'y' 
return; 
end if; 

when others => null; 
end case; 
end loop; 


= CHANGE; return; 
= ADD; return; 

= DELETE; return; 
= SEARCH; return; 
= QUIT; 


end SELECT_ALTERNATIVE; 

—******************************************************************** 
—* Address Book (9 of 12) * 


- ★ * 

—* File: insert.ada * 
—* Author: Gerald L. Mohnkern and Beverly Mohnkern * 
—* "Applied Ada" * 
—* Tab Professional and Reference Books, 1986 * 
—* * 




with TEXT_I0; use TEXT_I0; 
with ADDRDEC; use ADDRDEC; 
with DISPLAY; 
with GET_STRING; 
with SEARCH; 

procedure INSERT(DATA : ADDRESS; PT_LIST : in out A_LIST) is 
TEMP DATA : ADDRESS; 

INDEX, COUNT, REC_NUM : NATURAL; 

FOUND : BOOLEAN; 

RESPONSE : STRING(1..40); 

NEV_LIST : A_LIST; 

begin 

J.l SEARCH(DATA.NAME, PT_LIST, TEMP_DATA, INDEX, FOUND); 

J•2 if FOUND then 

PUT_LINE("There is an address for this name. It is: "); 
NEW LINE; 






1 


88 


J.3 DISPLAY(TEMP_DATA); 

PUT_LINE("Overwrite (0) or Leave (L) this address?"); 
SKIP_LINE; 

J.4 GET_STRING(RESPONSE, COUNT); 

J.5 if RESPONSE(l) /= 'O' AND RESPONSE(l) /= 'o' then 
return; —terminate insertion 
J.6 else —overwrite the existing record 

j.7 REC_NUM := PT_LIST.KEY_LIST(INDEX).PT_DATA; 

end if; 

J.8 else •— no address found 

— allocate a new index list with space for a new entry 
J.9 NEV_LIST := new LIST(PT_LIST.SIZE + 1); 

J.10 for I in 1..INDEX loop 

— copy entries up to one preceding insertion 
J.ll NEV_LIST.KEY_LIST(I) := PT_LIST.KEY_LIST(I); 

end loop; 

J.12 INDEX := INDEX + 1; 

J.13 NEW_LIST.KEY_LIST(INDEX).NAME := DATA.NAME; 

— Where should data be written? 

J.14 if PT_LIST.NEXT_SPACE = 0 then -- append to file 
J.15 NEV_LIST.LAST_REC := PT_LIST.LAST_REC + 1; 

J.16 REC_NUM := NEW_LIST.LAST_REC; 

J.17 NEV_LIST.NEXT_SPACE := 0; 

J.18 else — a deleted address can be overwritten 
J.19 NEV_LIST.LAST_REC := PT_LIST.LAST_REC; 

J.20 REC_NUM := PT_LIST. SPACE(PT_L.IST.NEXT_SPACE); 

J.21 NEV_LIST.NEXT_SPACE := PT_LIST.NEXT_SPACE - 1; 

end if; 

J.22 NEW_LIST.SPACE := PT_LIST.SPACE; 

J.23 NEW_LIST.KEY_LIST(INDEX).PT_DATA :=REC_NUM; 

—copy entries following insertion 
J.24 for I in INDEX+1..NEV_LIST.SIZE loop 

J.25 NEV_LIST.KEY_LIST(I) := PT_LIST.KEY_LIST(I - 1); 

end loop; 

J.26 PT_LIST := NEV_LIST; — access new list with PT_LIST 
end if; 

J.27 ADDRESS_I0.WRITE(DATA_ID, DATA, 

ADDRESS_IO.POSITIVE_COUNT(REC_NUM)); 


end INSERT; 

_****★★★**★*★★★★***★★*★★*★ •k'k'k'k'k'k'k'k'k'k'k'k’k'k'k'k-k'k'k'k-k'k'k'k'k'k-k'kic'k'k'k 

—* Address Book (10 of 12) * 

_ ★★★*★★**★*★★★★★*★*★★*★★★*★★★★★★★★*★★★★★★★*★★*★★★★★****★★***★★★***** 

_ * * 

—* File: search.ada * 

—* Author: Gerald L. Mohnkern and Beverly Mohnkern * 

—* "Applied Ada" * 

—* Tab Professional and Reference Books, 1986 * 

_ * * 


with TEXT_I0; use TEXT_I0; 
with ADDRDEC; use ADDRDEC; 


procedure SEARCH(SEEK NAME : STRING; PT LIST : A LIST; 







89 


DATA : out ADDRESS; INDEX : out NATURAL; 
FOUND : out BOOLEAN) is 
THIS_NAME : STRING(SEEK_NAME'RANGE); 

LAST : INTEGER := 0; 

LLAST : INTEGER := 0; 

HIGH : INTEGER := PT_LIST.SIZE; 

LOW : INTEGER 1; 

NEXT : INTEGER := (HIGH + L0V)/2; 

BLANKS : ADDRESS; 


K.l 
K. 2 
K.3 
K.4 
K. 5 
K. 6 


K.7 
K.8 
K. 9 
K. 10 
K. 11 
K. 12 
K. 13 
K. 14 
K.15 
K. 16 


K. 17 
K. 18 
K. 19 
K. 20 
K. 21 
K. 22 


begin 

while (NEXT /= LAST) and (NEXT /= LLAST) loop 
THIS_NAME := PT_LIST.KEY_LIST(NEXT).NAME; 
if SEEK NAME = THIS_NAME then 
FOUND := TRUE; 

INDEX := NEXT; 

ADDRESS_I0.READ(DATA_ID, DATA, ADDRESS_IO. 

POSITIVE_C0UNT(PT_LIST.KEY_LIST(NEXT).PT_DATA)); 
return; 

elsif SEEK_NAME > THIS_NAME then 
LOW := NEXT; 

LLAST := LAST; 

LAST := NEXT; 

NEXT := (NEXT + HIGH + l)/2; 
else — SEEK_NAME < THIS_NAME 
HIGH := NEXT; 

LLAST := LAST; 

LAST := NEXT; 

NEXT := (NEXT + L0V)/2; 
end if; 
end loop; 

FOUND := FALSE; 

DATA := BLANKS; 
if SEEKJNAME > THIS_NAME then 
INDEX := LAST; 

else — SEEK_NAME < THIS_NAME 
INDEX := LAST - 1; 
end if; 
end SEARCH; 


_ ******************************************************************* 


—* Address Book (11 of 12) * 

_ ★**★**★**★★**★★**★★★*★*★★★**★*★★***★★*★**★★★*★★****★**★*★**★*★*★*** 


_ * * 

—* File: delete.ada * 
—* Author: Gerald L. Mohnkern and Beverly Mohnkern * 
—* "Applied Ada" * 
—* Tab Professional and Reference Books, 1986 * 
_* * 


_ ******************************************************************* 


with TEXT_I0; use TEXT_I0; 
with DISPLAY; 

with ADDRDEC; use ADDRDEC; 
with GET_STRING; 
with SEARCH; 









procedure DELETE(DEL_NAME : STRING; 

PT_LIST : in out A_LIST) is 
RESPONSE : STRING(1..40) : = (1..40 -> ' '); 

TEMP_DATA : ADDRESS; 

INDEX, COUNT, REC_NUM : INTEGER; 

FOUND : BOOLEAN; 

NEV_LIST : A_LIST; 

begin 

L.l SEARCH(SEEK_NAME => DEL_NAME, 

PT_LIST => PT_LIST, 

“DATA => TEMP DATA, 

INDEX => INDEX, 

FOUND => FOUND); 

L.2 if not FOUND then 

PUT_LINE("Name not found."); 
return; 

L.3 else —delete index entry and address record 
NEWSLINE; 

L.4 DISPLAY(TEMP_DATA); 

PUT LINE("Do you want to delete this address? (Y/N"); 
SKIP_LINE; 

L.5 GET_STRING(RESPONSE, COUNT); 

L.6 if RESPONSE(l) /= 'Y' and RESPONSE(l) /= 'y' then 

return; 
end if; 

—delete entry from index 

L.7 REC_NUM := PTJL.IST.KEY_LIST(INDEX). PT_DATA; 

L.8 for I in INDEX..PT_LIST.SIZE - 1 loop 
L.9 - > T_LIST.KEY_LIST(I) := PT_LIST.KEY_LIST(I + 1); 

end loop; 

—make a new list that is one entry shorter 
L. 10 NEV_LIST := new LIST'(PT_LIST.SIZE - 1, PT_LIST.LAST_REC, 
PT_LIST.NEXT_SPACE, PT_LIST.SPACE, 

PT_LIST.KEY_LIST(1..PT_LIST.SIZE - 1)); 

—add record number to stack of space available 
L.11 if NEV_LIST.NEXT_SPACE < NEV_LIST.SPACE'LAST then 
L. 12 NEV_LIST.NEXT SPACE := NEW LIST.NEXT_SPACE + 1; 

L.13 NEV_LIST.SPACE(NEV_LIST.NEXT_SPACE) := REC_NUM; 

end if; 

L. 14 PT_LIST := NEV_LIST; —access new list with PT_LIST 
end if; 

end DELETE; 

—* Address Book (12 of 12) * 

_ * * 

—* File: getstr.ada * 

—* Author: Gerald L. Mohnkern and Beverly Mohnkern * 

—* "Applied Ada" * 



_ * 


Tab Professional and Reference Books, 1966 


* 

* 


91 


_ ★ 


_ ******************************************************************** 


with TEXT_IO; use TEXT_I0; 

with ADDRDEC; use ADDRDEC; 

procedure GET STRING(STR : out LINE40; 

LEN : out NATURAL) is 

CH : CHARACTER; 

CUM_COUNT : NATURAL := 0; 
begin 

M.l while not END_0F_LINE loop 
M.2 GET(CH); 

M.3 CUM_C0UNT := CUM_C0UNT + 1; 

M.4 STR( CUM_C0UNT) := CH; 

end loop; 

M.5 LEN := CUM_C0UNT; 
end GET STRING; 





APPENDIX C 

C PROGRAMS INCLUDED IN THE STUDY 


92 


93 


/****************************************************************** 

* Fastfind * 

******************************************************************* 

* * 

* File: fastfind.c * 

* Author: Webb Hiller * 

* "A Software Tools Sampler" * 

* Prentice-Hall, Inc., 1987 * 

* * 

* * 

* fastfind - print lines containing a given pattern string. * 

* * 

* Program description: * 

* * 

* A command line has the form * 

* fastfind pat |filel] |file2] .... * 

* where pat is any sequence of characters. A character pair * 

* "\n" at the beguinning or end of pat matches the beguinning * 

* or end of a text line. If no file is named, then standard * 

* input is read. If more than one file is named, then each * 

* printed line is preceded by its file's name. * 

* * 

* Portability: * 

* * 

* Files are read with the UNIX routines: * 

* * 

* int read(fd, buffer, max_chars) * 

* int fd, max_chars; ” * 

* char buffer[]; * 

* Read at most max_chars characters from the file with * 

* file descriptor fd to the buffer. The returned value * 

* is the actual number of characters read. * 

* * 

* File lines should be separated by '\n'. * 

* * 
******************************************************************/ 

^include <stdio.h> 

^define MAX_NAME 50 

/*Two buffers of length BUFSIZ (defined in stdio.h are arranged as 
a circle; the location just left of the current buffer is the end 
of the other buffer. 

*/ 


#define T0_LEFT 
#define DECREMENT(x) 
tdefine INCREMENT(x) 
“define PROG NAME 


buf[1 - curbuf] + BUFSIZ - 1 

if(x == buf(curbufj) x = T0_LEFT; else —x 

if(x == T0_LEFT) x = buf[curbuf]; else ++x 

"fastfindl" 


int curbuf, 
fd, 

nfile, 

shift[ 128 ]; 


/*current buffer*/ 
/*file descriptor*/ 
/*number of files*/ 
/*shift table*/ 



94 


char buf[2 J[BUFSIZJ, 
*end_pat, 

*file, 

*lim, 

*pat, 

*pos; 


/*text buffers*/ 

/*last position in the pattern*/ 
/*name of the file*/ 

/*limit for search*/ 

/*pat tern*/ 

/*search pointer to the text*/ 


char prog name[MAX_NAME + 1]; /*used in error messages*/ 


main(argc, argv) 
int argc; 
char *argv[ ]; 

{ 

int i, length; 
char *p; 

A.1 savename(PROG_NAME); /*for error messages*/ 

A.2 if(argc == 1) 

A.3 fatal("No pattern vas given."); 

A.4 pat = argv[1 ]; 

/*handle new line characters in the pattern*/ 

A.5 if (pat [0] == 'W' &A pat [ 1 ] == 'n') 

A.6 *++pat = '\n' ; 

A.7 if((length = strlen(pat)) == 0) 

A.8 fatal("Pattern length is zero."); 

A.9 if (length > 1 £.& pat[length - 2] == 'W &£. pat[length - 1] == 'n') 

{ 

A.10 pat[length - 2] = '\n'; 

A.11 patflength - 1] = '\0'; 

A.12 —length; 

) /*end if*/ 

A.13 end_pat = pat + length - 1; 

A.14 for(i = 0;i < 128; ++i) 

A.15 shif t[i] = length; 

A.16 for(p = pat; *p != '\0'; ++p) 

A.17 shift[*p & 0177] = —length; 

A.18 if((nfile = argc - 2) == 0) 

{ 

A.19 fd = 0; /*standard input*/ 
scan(); 

} /*end if*/ 

A.20 else 

{ 

A.21 for(i = 2;i < argc; ++i) /*for each specified file*/ 

( 

A.22 file = argv[i]; 

A.23 if((fd = open(file, 0)) < 0) 

A.24 fprintf(stderr, "%s: Cannot open Xs.\n", PR0G_NAME, file); 

A.25 else 

( 

scan(); 
close(fd); 
j /*end else*/ 

} /*end for*/ 


A.26 



95 


} /*end else*/ 
exit(O); 

} /*end main*/ 


/*scan - find lines in file that contains the pattern string*/ 
scan() 

{ 

int increment; 

B.l buff 1][BUFSIZ - 1] = '\n'; /*in case the first line matches*/ 

B.2 curbuf = 1; 

B.3 lim = pos = buf[l]; /*force an immediate call to fill buffer()*/ 
f or (; ;) 

[ 

/*Pos points to a text position that might end on an occurrence 
of 

pat. If that character differs from the last character of pat, 
then pos is shifted to the next position that might yield a 
match. The shifting stops when pos reaches the end of the 

buffer 

or an instance of the last pattern character. 

*/ 

B.4 vhilefpos < lim && (increment = shift[*pos & 0177]) > 0) 

B.5 pos += increment; 

B.6 if(pos < lim) /*shifting ended with pos in buffer*/ 

{ 

B.7 if(is_match()) 

print_line(); 

B.8 ++pos; 

} /*end if*/ 

/*else past end of buffer; fill the other buffer*/ 

B.9 else if(fill_buffer() == EOF) 
break; 

) /*end for*/ 

} /*end scan*/ 


/*fill_buffer - fill other buffer; points pos to first char read; 
point 

lim just beyond the last character read; return EOF at the end of 
the file. 

*/ 

fill_buffer() 

{ 

C.l curbuf = 1 - curbuf; 

C.2 pos = bvf[curbuf]; 

C.3 if((lim = pos + read(fd, pos, BUFSIZ)) == pos) 

return(EOF); 
return(!EOF); 

} /*end fill buffer*/ 


/*is_match - tell if a copy of the pattern ends at pos*/ 
is match() 




96 


1 


{ 

D.l char *t = pos, *p = end_pat; /*already know that *t == *p */ 

D.2 vhile(—p >= pat) 

{ 

D.3 DECREMENT(t); 

D.4 if(*p != *t) 

return(O); 

} /*end while*/ 

D.5 return(l); 

) /*end is match*/ 


/*print_line - print the line pointed to by pos; move pos to the end 
of line. 

*/ 

print_line() 

{ 

char *t; 

E.l if(nfile > 1) 

E.2 printf("%s:", file); 

E.3 if(*pos == '\n') /*find the start of the line*/ 

E.4 DECREMENT(pos); 

E.5 for(t = pos; *t != '\n'; ) 

E.6 DECREMENT(t); 

! /*print the portion of the line before the match*/ 

< E.7 while(t != pos) 

{ 

E.8 INCREMENT(t); 

E.9 putchar(*t); 

) /*end while*/ 

/*print the portion of the line after the match*/ 

E.10 while(*pos != '\n') 

{ 

E. 11 if(++pos >= lim && fill_buffer() == EOF) 
break; 

E.12 putchar(*pos); 

} /*end while*/ 

) /*end print line*/ 


/*savename - record a program name for error messages*/ 
savename(name) 
char *name; 

{ 

char *strcpy(); 

F.l if(strlen(name) <= MAX_NAME) 

F.2 strcpy(prog_name, name); 

} /*end savename*/ 


/*fatal - print message and die*/ 
fatal(msg) 









1 


97 


char *msg; 

{ 

G.l if(prog_name(0] != '\0') 

G.2 fprintf(stderr, "Xs: ",prog_name); 

G.3 fprintf(stderr, "Zs\n",msg); 

exit(l); 

} /*end fatal*/ 





* MailingList * 

★★**★★★★******★*★***************★★★★**★*★★**★★****★★★*★★*★★*★★**★★★ 

★ + 

* File: mail.c * 

* Author: Herbert Schildt * 

* "Advanced Turbo C" * 

* Osborne McGraw-Hill, 1987 * 

* * 


#include "stdio.h" 

struct address ( 
char .JOJ; 

char su.eet(40]; 
char city[20J; 
char state[3 ] ; 

char zip[10J; /*hold US A Canadian zips*/ 
struct address *next; /*pointer to next entry*/ 
struct address *prior; /*pointer to previous entry*/ 

) list_entry; 

struct address *start; /*pointer to first entry in list*/ 
struct address *last; /*pointer to last entry*/ 

void enter(), displayO, search(), save(), load(); 

main() 

{ 

char s[80 ], choice; 
struct address *info; 

A.1 start = last = NULL; /*zero length list*/ 
for(; ;) 

{ 

switch(menu_select()) 

{ 


A.2 

A.3 

A.4 

case 1: 

break; 
case 2: 

break; 
case 3: 
break; 

enter(); 

delete(); 

list(); 




A.5 

case 4: 
break; 

search(); 

/*find a 

name*/ 

A.6 

case 5: 
break; 

save(); 

/*save 

list 

to disk*/ 

A.7 

A.8 

case 6: 

break; 
case 7: 

load(); 

exit(0); 

/*read 

from 

disk*/ 


} /*end switch*/ 
) /*end for*/ 

} /*end main*/ 




99 


/* select an operation */ 
menu_select() 

{ 

char s[80]; 
int c; 

printf("l. Enter a name\n"); 
printf("2. Delete a name\n"); 
printf("3. List the file\n"); 
printf("4. SearchW); 
printf("5. Save the file\n"); 
printf("6. Load the file\n"); 
printf(’'7. Quit\n"); 
do 

{ 

printf("\nEnter your choice: "); 

B.l gets(s); 

B.2 c = atoi(s); 

B. 3 } vhile(c < 1 || c > 7); 

return c; 

} /*end menu_select*/ 

/* enter name and address */ 
void enter() 

{ 

struct address *info, *dls_store(); 

for(;;) 

{ 

C. l info = (struct address *) malloc (sizeof(list_entry)); 

C.2 if(!info) 

{ 

printf("\nOut of memory\n"); 
return; 

} /*end if*/ 

C.3 inputs(” enter name: " , info->name,30); 

C.4 if(!info->name[0j) break; /*stop entering*/ 

C.5 inputsC'enter street: ",info->street,40); 

C.6 inputs(" enter city: ",info->city,20); 

C.7 inputs(" enter state: ",info->state,3); 

C.8 inputs(" enter zip: ",info->zip,10); 

C.9 start = dls_store(info, start); 

) /*end for*/ 

) /*end enter*/ 

/* This function will input a string up to the length in count. 
This will prevent the string from overrunning its space and 
display a prompt message. 

*/ 

inputs(prompt, s, count) 
char *prompt; 
char *s; 




D.l 

D.2 

D. 3 


E. 1 

E. 2 
E. 3 
E. 4 
E.5 

E.6 
E. 7 
E.8 

E.9 

E. 10 
E. 11 

E. 12 

E. 13 

E. 14 
E. 15 
E. 16 
E. 17 
E. 18 

E. 19 
E. 20 
E. 21 
E. 22 


100 


int count; 

{ 

char p{255J; 
do 

{ 

printf(prompt); 
gets(p); 

if(strlen(p) > count) 
printf("\ntoo long\n"); 

) vhile(strlen(p) > count); 
strcpy(s.p); 

} /*end inputs*/ 

/* This function creates a doubly linked list in sorted order. A 
pointer to the first element is returned because it is possible 
that a new element will be inserted at the start of the list. 

*/ 

struct address *dls_store(i,top) 

struct address *i; /*nev element*/ 

struct address *top; /*first element in list*/ 

{ 

struct address *old, *p; 

if(last == NULL) /*first element in list*/ 

{ 

i->next = NULL; 
i->prior = NULL; 
last = i; 
return i; 

} /*end if*/ 

p = top; /*start at top of list*/ 

old = NULL; 

vhile(p) 

{ 

if(strcmp(p->name, i->name) < 0) 

{ 

old = p; 
p = p->next; 

) /*end if*/ 
else 
{ 

if(p->prior) 

[ 

p->prior->next = i; 
i->next = p; 
i->prior = p->prior; 
p->prior = i; 
return top; 

} /*end if*/ 

i->next = p; /*nev first element*/ 
i->prior = NULL; 
p->prior = i; 
return i; 






} /*end else*/ 

} /*end while*/ 

E.23 old->next = i; /*put on end*/ 

E.24 i->next = NULL; 

E.25 i->prior = old; 

E.26 last = i; 

E.27 return start; 

} /*end dls store*/ 


/* Remove an element from the list. */ 
delete() 

{ 

struct address *info, *find(); 
char s[80 ]; 

printf("enter name: "); 

F.l gets(s); 

F.2 info = find(s); 

F. 3 if(info) 

{ 

F.4 if(start == info) 

{ 

F.5 start = info->next; 

F.6 if(start) 

F.7 start->prior = NULL; 

F.8 else 

F.9 last = NULL; 

) /*end if*/ 

F.10 else 

{ 

F.ll info->prior->next = info->next; 

F.12 if(info != last) 

F.13 info->next->prior = info->prior; 

F.14 else 

F.15 last = info->prior; 

) /*end else*/ 

F.16 free(info); /*return memory space to system*/ 

) /*end if*/ 

) /*end delete*/ 


struct address *find(name) 
char *name; 
r 

struct address *info; 

G.l info = start; 

G.2 vhile(info) 

{ 

G.3 if(!strcmp(name, info->name)) 

G.4 return info; 

G.5 info = info->next; /*get next address*/ 

) /*end while*/ 
printf("name not found\n"); 



return NULL; /*not found*/ 
} /*end find*/ 


list() 

( 

register int t; 
struct address *info; 

H.l info = start; 

H.2 while(info) 

{ 

H.3 display(info); 

H.4 info = info->next; /*get next address*/ 

] /*end while*/ 
printf("\n\n" ); 

} /*end list*/ 


void display(info) 

struct address *info; 

{ 

1.1 printf("Xs\n",info->name); 

1.2 printf("%s\n",info->street); 

1.3 printf("%s\n",info->city); 

1.4 printf("Xs\n",info->state); 

1.5 printf("Xs\n",info->zip); 
printf("\n\n"); 

} /*end display*/ 


void searchQ 

{ 

char name[40]; 

struct address *info, *find(); 

printf("enter name to find: "); 

J.l gets(name); 

J.2 if(!(info = find(name))) 
printf("not found\n"); 

J.3 else 

J.4 display(info); 

) /*end search*/ 


void save() 

{ 

register int t; 
struct address *info; 

FILE *fp; 

K.l if((f p = fopen("mail_list","vb")) == NULL) 

{ 

printf("Cannot open file\n"); 
exit(l); 



} /*end if*/ 

printf("\nSaving file\n"); 

K.2 info « start; 

K.3 vhile(info) 

{ 

K.4 fwrite(info,sizeof(struct address),1,fp); 

K.5 info = info->next; /*get next address*/ 

) /*end while*/ 

K.6 fclose(fp); 

} /*end save*/ 


void load() 

{ 

register int t; 

struct address *info, *temp = NULL; 

FILE *fp; 

L. 1 if((fp = fopen("mail_list","rb")) == NULL) 

{ 

printf("Cannot open file\n"); 
exit(l); 

} /*end if*/ 

L.2 while(start) 

( 

L.3 info = start->next; 

L.4 free(info); 

L.5 start = info; 

) /*end while*/ 
printf("\nLoading file\n"); 

L.6 start = (struct address *) malloc (sizeof(struct address)); 

L.7 if(.'start) 

{ 

printf("Out of memory\n"); 
return; 

) /*end if*/ 

L.8 info = start; 

L.9 while(!feof(fp)) 

{ 

L. 10 if(1 != fread(info,sizeof(struct address),1,fp)) 
break; 

/*get memory for next*/ 

L.ll info->next = (struct address *) malloc(sizeof(struct address 
L.12 if(!info->next) 

{ 

printf("Out of memoryXn"); 
return; 

) /*end if*/ 

L.13 info->prior = temp; 

L.14 temp = info; 

L.15 info = info->next; 

) /*end while*/ 

L.16 temp->next = NULL; /*last entry*/ 

L.17 last = temp; 

L.18 start->prior = NULL; 






104 


L. 19 fclose(fp); 

} /*end load*/ 








/A***************************************************************** 


* Text Editor * 

*********************************************************** ******** 

* * 

* File: editor.c * 

* Author: Herbert Schildt * 

* "Advanced Turbo C" * 

* Osborne McGraw-Hill, 1987 * 


★*★★★★★★**:*•*'*•*■*★**■★**★**★★*■★★★★ **************************■********** / 

tinclude "stdio.h" 
tinclude "ctype.h" 

struct line 

{ 

char text[81]; 

int num; /*line number of line*/ 

struct line *next; /*pointer to next entry*/ 

struct line *prior; /*pointer to previous entry*/ 

}; 

struct line *start; /*pointer to first entry in list*/ 
struct line *last; /*pointer to last entry*/ 
struct line *dls_store(), *find(); 
void patchupO, delete(), list(), save(), load(); 

main(argc, argv) 
int argc; 
char *argv[]; 

{ 

char s[80], choice, fname[80]; 
struct line *info; 
int linenum = 1; 

start = NULL; /*zero length list*/ 
last = NULL; 
if(argc == 2) 

load(argv[1]); /*read file on command line*/ 
do 

{ 

choice = menu_select(); 
svitch(choice) 

{ 

case 1: printf("Enter line number: "); 
gets(s); 

linenum = atoi(s); 
linenum = enter(linenum); 
break; 

case 2: delete(); 
break; 

case 3: 1ist( ); 
break; 

case 4: printf("Enter filename: "); 
gets(fname); 

save(fname); /*vrite to disk*/ 


A. 1 
A.2 
A.3 
A.4 


A.5 


A.6 
A.7 
A.8 
A.9 

A.10 

A.11 

A.12 
A.13 
A.14 



106 



break; 

A.15 

case 5: printf("Enter filename: "); 

A.16 

gets(fname); 

A.17 

load(fname); /*read from disk*/ 


break; 

A.18 

case 6: exit(0); 


} /*end switch*/ 
) vhile(l); 

) /*end main*/ 


/* Select a menu option */ 
menu_select() 

{ “ 

char s[80]; 
int c; 

printf("l. Enter text\n"); 
printf("2. Delete a line\n"); 
printf("3. List the file\n"); 
printf("4. Save the file\n"); 
printf("5. Load the file\n"); 
printf("6. Quit\n"); 
do 

printf ("NnEnter your choice: "); 
B.1 gets(s); 

B.2 c = atoi(s); 

B.3 ] vhile(c <1 || c > 6); 

return c; 

} /*end menu_select*/ 


/* Enter text at linenum */ 
enter(linenum) 
int linenum; 

{ 

struct line *info; 
char t[81]; 

do /*entry loop*/ 

C.l info = (struct line *) malloc (sizeof'struct line)); 

C.2 if(!info) 

{ 

printf("\n0ut of memory\n"); 
return linenum; 

) /*end if*/ 

C.3 printf("Zd : ".linenum); 

C.4 gets(info->text); 

C.5 info->num = linenum; 

C.6 if(*info->text) 

{ 

C.7 if(find(linenum)) 

C.8 patchup(linenum, 1); /*fix up old line numbers*/ 






*1 


107 

C.9 if(*info->text) 

C.10 start = dls_store(info); 

) /*end it*/ 

C.ll else 

break; 

C. 12 linenum++; 

) vhile(l); 
return linenum; 

) /*end enter*/ 

/*This function increases line numbers by 1 of lines below an 
inserted line and decreases line numbers by 1 of lines after 
deleted lines. 

*/ 

void patchup(n, incr) 
int n; 
int incr; 

{ 

struct line *i; 

D. l i = find(n); 

D.2 vhile(i) 

{ 

D.3 i->num = i->num + incr; 

D.4 i = i->next; 

} /*end while*/ 

) /*end patchup*/ 


/* Store in sorted order by line number */ 
struct line *dls_store(i) 
struct line *i; 

{ 

struct line *old, *p; 

E.l if(last == NULL) /*first element in list*/ 

{ 

E.2 i->next = NULL; 

E.3 i->prior = NULL; 

E.4 last = i; 

E.5 return i; 

} /*end if*/ 

E.6 p = start; /*start at top of list*/ 

E.7 old = NULL; 

E.8 vhile(p) 

{ 

E.9 if(p->num < i->num) 

{ 

E.10 old = p; 

E.ll p = p->next; 

) /*end if*/ 

E.12 else 

( 

if(p->prior) 


E. 13 





108 


{ 

E.14 p->prior->next = i; 

E.15 i->next = p; 

E.16 i->prior = p->prior; 

E.17 p->prior - i; 

E.18 return start; 

} /*end if*/ 

E.19 i->next = p; /*nev first element*/ 

E.20 i->prior = NULL; 

E.21 p->prior = i; 

E.22 return i; 

} /*end else*/ 

} /*end while*/ 

E.23 old->next = i; /*put on end*/ 

E.24 i->next = NULL; 

E.25 i->prior = old; 

E.26 last = i; 

E.27 return start; 

] /*end dls_store*/ 


/* Delete a line */ 
void deleteO 
{ 

struct line *info; 
char s[80]; 
int linenum; 

printf("Enter line number: "); 

F• 1 gets(s) ; 

F.2 linenum = atoi(s); 

F.3 info = find(linenum); 

F.4 if(info) 

{ 

F.5 if(start == info) 

{ 

F.6 start = info->next; 

F.7 if(start) 

F.8 start->prior = NULL; 

F.9 else 

F.10 last = NULL; 

} /*end if*/ 

F.ll else 

{ 

F.12 info->prior->next = info->next; 

F.13 if(info != last) 

F.14 info->next->prior = info->prior; 

F.15 else 

F.16 last = info->prior; 

) /*end else*/ 

F.17 free(info); /*return memory space to system*/ 

F.18 patchup(linenum + 1, -1); /*decrement line numbers*/ 
) /*end if*/ 

) /*end delete*/ 





109 


/* Find a line of text */ 
struct line *find(linenum) 
int linenum; 

{ 

. struct line *info; 

G.l info = start; 

G.2 vhile(info) 

! { 

} G.3 if(linenum == info->num) 

G.4 return info; 

i G.5 info = info->next; /*get next address*/ 

| ) /*end vhile*/ 

return NULL; /*not found*/ 

} /*end find*/ 

/* List the text */ 

I void list() 

; { 


! 

i 

H. 1 

struct line *info; 

info = start; 


fi. 2 

vhile(info) 

prin tfC'Zd: Zs\n",info->num, info->text); 

1 

i 

H.3 

; 

H. 4 

info = info->next; /*get next address*/ 



} /*end vhile*/ 
printf("\n\n"); 

} /*end list*/ 

/* Save the file */ 



void save(fname) 
char *fname; 

{ 

register int t; 
struct line *info; 
char *p; 

\ 

1.1 

FILE *fp; 

if((fp = fopen(fname, "v")) == NULL) 

{ 

printf("Cannot open file\n"); 

i 




exit(O); 

) /*end if*/ 



printf("\nSaving file\n"); 


1.2 

info = start; 


1.3 

vhile(info) 

{ 

p = info->text; /*convert to char pointer*/ 


1.4 


1.5 

vhile(*p) 


1.6 

putc(*p++, fp); /*save byte at a time*/ 


1.7 

putc('\r', fp); /*terminator*/ 




no 


1.8 putc('\n', fp); /*terminator*/ 

1.9 info = info->next; /*get next line*/ 
} /*end while*/ 

1.10 fclose(fp); 

) /*end save */ 


/* Load the file */ 
void load(fname) 
char *fname; 

{ 

register int t, size, Inct; 
struct line *info, *temp; 
char *p; 

FILE *fp; 

J.l if((fp = fopen(fname, "r")) == NULL) 

{ 

printf("Cannot open file\n"); 
exit(0); 

) /*end if*/ 

J.2 while(start) /*free any previous edit*/ 

{ 

J.3 temp = start; 

J.4 start = start->next; 

J.5 free(temp); 

} /*end while*/ 
printf("\nLoading file\n"); 

J.6 size = sizeof(struct line); 

J.7 start = (struct line *) malloc (size); 

J.8 if(!start) 

{ 

printf("0ut of memory\n"); 
return; 

} /*end if*/ 

J.9 info = start; 

J.10 p = info->text; /*convert to char pointer*/ 

J.ll lnct = 1; 

J.12 vhile((*p = getc(fp)) != EOF) 

{ 

J.13 if(!isprint(*p)) 

break; 

J . 14 p++; 

J.15 vhile((*p = getc(fp)) != '\r') 

J.16 p++; 

J.17 getc(fp); /*throv avay the \n */ 

J.18 *p = '\0' ; 

J.19 info->num = lnct++; 

J.20 info->next = (struct line *) malloc (size); /*get memory for 
next*/ 

J.21 i f ( !info->next) 

{ 

printf("0ut of memory\n"); 
return; 




} /*end if*/ 

J.22 info->prior = temp; 

J.23 temp = info; 

j.24 info = info->next; 

J.25 p = info-> text; 

} /*end while*/ 

J.26 temp->next = NULL; /*last entry*/ 
J.27 last = temp; 

J.28 free(info); 

J . 29 start->prior = NULL; 

J.30 fclose(fp;, 

} /*end load*/ 



APPENDIX D 

ENTROPY LOADING DATA TABLES 


112 









113 


TABLE IV 

ASSUMPTIONS FOR THE C PROGRAM 
FASTFIND, CASE 1 


Asmp. 

Number Assumption 


1 

2 

3 

4 

5 

6 

7 

8 

9 

10 
11 
12 

13 

14 

15 

16 

17 

18 

19 


There exists a function called fill_buffer(). 

There exists a function called is_match(). 

There exists a function called print_line(). 

There exists a function called savename() with one 
parameter. 

The parameter for the function savename() has read 
access only. 

There exists a function called fatal() with one 
parameter. 

The parameter for the function fatal() has read 
access only. 

Read access to character string pointer called 
end_pat that points to the last character in 
pattern. 

Read access to integer table called shift. 

Read access to curbuf, index to the text buffer in 
use. 

Write access to curbuf, index to the text buffer in 
use. 

Read access to buf, buffers used to store text read 
from the files being searched. 

Write access to buf, buffers used to store text read 
from the files being searched. 

Read access to lim, character pointer that points 
to the last character read from the file being 
searched. 

Write access to lim, character pointer that points 
to the last character read from the file being 
searched. 

Read access to pos, character pointer that points 
to the character being compared with the input 
pattern. 

Write access to pos, character pointer that points 
to the character being compared with the input 
pattern. 

Function is_match returns 1 if a match to the input 
pattern has been found in the file being searched, 
and returns 0 otherwise. 

Function fill_buffer returns EOF when the an 
attempt is made to read from the file being 
searched beyond the end of the file. 



1 


TABLE IV (Continued) 


114 


F 


j 


Asmp. 

Number Assumption 


20 Read access to prog_name, character string that 
holds the name of the executable program, i.e. 
(fastfindl). 

21 Write access to prog_name, character string that 
holds the name of the executable program, i.e. 

(fastfindl). 

22 Write access to character string name. 

23 Read access to integer variable argc. 

24 Variable argc equals 1. 

25 Write access to character string msg. 

26 Write access to character string pointer pat that 
points to the pattern to be matched. 

27 Read access to character string pointer argv[]. 

28 Read access to character string pointer pat that 
points to the pattern to be matched. 

29 The first character in the string pointed at by pat 
is '\'. 

30 The second character in the string pointed at by pat 
is 'n *. 

31 Read access to character string pointed at by pat. 

32 Write access to character string pointed at by pat. 

33 Read access to integer variable length. 

34 Write access to integer variable length. 

35 Variable length equals 0. 

36 Variable length is greater than 1. 

37 The next to last character in the string pointed at 
by pat is ' \'. 

38 The last character in the string pointed at by pat 
is 1 n'. 

39 Write access to character string pointer called 
end_pat that points to the last character in 
pattern. 

40 Read access to integer variable i. 

41 Write access to integer variable i. 

42 Variable i is less than 128. 

43 Write access to integer array shift. 

44 The character being read from the string pointed at 
by the pointer p is not the line terminator ('\0 ' ) . 

45 Write access to character string pointer p. 

46 Read access to character string pointer p. 

47 Read access to the character string pointed at by p. 

48 Variable nfile equals 0. 

49 Read access to integer nfiles holding the number of 
files to be searched for pattern. 






TABLE IV (Continued) 


Asmp. 

Number Assumption 


50 Write access to integer nfiles holding the number of 
files to be searched for pattern. 

51 Read access to character string file holding the 
name of the file presently being searched. 

52 Write access to character string file holding the 
name of the file presently being searched. 

53 Read access to file pointer fd that points to the 
file presently open. 

54 Write access to file pointer fd that points to the 
file presently open. 

55 Complement of assumption number 48. 

56 i < argc, i.e., there are more files to be searched. 

57 File pointed at by fd can't be opened for reading. 

58 Complement of assumption number 57. 





1 


116 

TABLE V 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE C PROGRAM FASTFIND, CASE 1 


Object Assumptions 


A-1 

4, 

5 


A.2 

23 , 

24 


A. 3 

6, 

7 


A.4 

26, 

27 


A. 5 

29, 

30, 31 


A. 6 

A. 7 

32 

31, 

33, 35, 

36 

A. 8 

A.9 

5 

31, 

33, 36, 

37, 38 

A. 10 

31, 

33 


A. 11 

31, 

33 


A. 12 

A. 13 

34 

28, 

33, 39 


A.14 

40, 

41, 42 


A.15 

33, 

40, 43 


A.16 

28, 

44, 45, 

46, 47 

A.17 

34, 

35, 43 


A.18 

23, 

48, 49, 

50 

A. 19 

A. 20 

54 

23, 

49, 50, 

55 

A.21 

40, 

41, 56 


A.22 

27, 

40, 52 


A. 23 

51, 

53, 54, 

57 

A.24 

A.25 

51 

51, 

53, 54, 

58 

A. 26 

B. O 

53 

1, 

2, 3, 9, 

11, 12, 13, 14, 15, 16, 17, 18, 19 

C. 0 

10, 

11, 12, 

15, 16, 17, 53 

D. 0 

8, 

10, 12, 

16, 28 

E. 0 

1, 

10, 12, 

14, 16, 17, 19, 49, 51 

F. 0 

5, 

21 


G. 0 

7, 

20 






1 


117 


TABLE VI 

ASSUMPTIONS FOR THE C PROGRAM 
FASTFIND, CASE 2 


Asmp. 

Number Assumption 


i 


1 There exists a module called module_l with one 
parameter. 

2 The parameter in module module_l has read access 
only. 

3 There exists a function called is_match(). 

4 There exists a function called savename() with one 
parameter. 

5 The parameter for the function savename() has read 
access only. 

6 There exists a function called fatal () with one 
parameter. 

7 The parameter for the function fatal() has read 
access only. 

8 Read access to character string pointer called 
end_pat that points to the last character in 
pattern. 

9 Read access to integer array called shift. 

10 Read access to curbuf, index to the text buffer in 
use. 

11 Write access to curbuf, index to the text buffer in 
use. 

12 Read access to buf, buffers used to store text read 
from the files being searched. 

13 Write access to buf, buffers used to store text read 
from the files being searched. 

14 Read access to lim, character pointer that points 
to the last character read from the file being 
searched. 

15 Write access to lim, character pointer that points 
to the last character read from the file being 
searched. 

16 Read access to pos, character pointer that points 
to the character being compared with the input 
pattern. 

17 Write access to pos, character pointer that points 
to the character being compared with the input 
pattern. 

18 Function is_match returns 1 if a match to the input 
pattern has been found in the file being searched, 
and returns 0 otherwise. 









118 


TABLE VI (Coi -inued) 


Asmp. 

Number Assumption 


19 Module module_l returns EOF when the an attempt is 
made to read from the file being searched beyond the 
end of the file. 

20 Read access to prog_name, character string that 
holds the name of the executable program, i.e. 
(fastfindl). 

21 Write access to prog_name, character string that 
holds the name of the executable program, i.e. 

(fastfindl). 

22 Write access to character string name. 

23 Read access to integer variable argc. 

24 Variable argc equals 1. 

25 Write access to character string msg. 

26 Write access to character string pointer pat that 
points to the pattern to be matched. 

27 Read access to character string pointer argv[]. 

28 Read access to character string pointer pat that 
points to the pattern to be matched. 

29 The first character in the string pointed at by pat 
is '\' . 

30 The second character in the string pointed at by pat 
is ' n' . 

31 Read access to character string pointed at by pat. 

32 Write access to character string pointed at by pat. 

33 Read access to integer variable length. 

34 Write access to integer variable length. 

35 Variable length equals 0. 

36 Variable length is greater than 1. 

37 The next to last character in the string pointed at 
by pat is '\'. 

38 The last character in the string pointed at by pat 
is 'n'. 

39 Write access to character string pointer called 
end_pat that points to the last character in 
pattern. 

40 Read access to integer variable i. 

41 Write access to integer variable i. 

42 Variable i is less than 128. 

43 Write access to integer array shift. 

44 The character being read from the string pointed at 
by the pointer p is not the line terminator ('\0'). 

45 Write access to character string pointer p. 

46 Read access to character string pointer p. 

47 Read access to the character string pointed at by p. 

48 Variable nfile equals 0. 







119 


•t 

l 


TABLE VI (Continued) 


Asmp. 

Number Assumption 


49 Read access to integer nfiles holding the number of 
files to be searched for pattern. 

50 Write access to integer nfiles holding the number of 
files to be searched for pattern. 

51 Read access to character string file holding the 
name of the file presently being searched. 

52 Write access to character string file holding the 
name of the file presently being searched. 

53 Read access to file pointer fd that points to the 
file presently open. 

54 Write access to file pointer fd that points to the 
file presently open. 

55 Complement of assumption number 48. 

56 i < argc, i.e., there are more files to be searched. 

57 File pointed at by fd can't be opened for reading. 

58 Complement of assumption number 57. 

59 Read access to character string pointed at by pos. 

60 Write access to integer variable increment. 

61 Read access to integer variable increment. 

62 Pointer pos is less than pointer lim, i.e., the 
character pointed at by pos is closer to the 
beginning of the file than the character pointed at 
by lim. 

63 Variable increment is larger than zero. 

64 Module module 1 is in fill buffer mode. 












121 


TABLE VIII 

ASSUMPTIONS FOR THE C PROGRAM 
FASTFIND, CASE 3 


Asmp. 

Number Assumption 


1 Write access to character string name. 

2 Read access to character string name. 

3 Write access to character string prog_name. 

4 Read access to integer variable argc. 

5 Variable argc equals 1. 

6 Write access to character string msg. 

7 Read access to character string prog_name. 

8 First character in character string prog_name is 
not the line terminator ( 1 \ 0 '). 

9 Read access to character string msg. 

10 Write access to character string pointer pat that 
points to the pattern to be matched. 

11 F^-' access to character string pointer argv[]. 

12 Pp id access to character string pointer pat that 
joints to the pattern to be matched. 

13 The first character in the string pointed at by pat 
is ’ V . 

14 The second character in the string pointed at by pat 
is 1 n' . 

15 Read access to character string pointed at by pat. 

16 Write access to character string pointed at by pat. 

17 Read access to integer variable length. 

18 Write access to integer variable length. 

19 Variable length equals 0. 

20 Variable length is greater than 1. 

21 The next to last character in the string pointed at 
by pat is '\'. 

22 The last character in the string pointed at by pat 
is 'n' . 

23 Write access to character string pointer end_pat. 

24 Read access to integer variable i. 

25 Write access to integer variable i. 

26 Variable i is less than 128. 

27 Write access to integer array shift. 

28 The character being read from the string pointed at 
by the pointer p is not the line terminator ('\ 0 '). 

29 Write access to character string pointer p. 

30 Read access to character string pointer p. 

31 Read access to the character string pointed at by p. 

32 Variable nfile equals 0. 

33 Read access to integer variable nfile. 

34 Write access to integer variable nfile. 



TABLE VIII (Continued) 


Asmp. 

Number Assumption 


35 Write access to integer file descriptor fd. 

36 Write access to character string buf. 

37 Write access to integer variable curbuf. 

38 Head access to character string pointer pos. 

39 Write access to character string pointer pos. 

40 Write access to character string pointer lim. 

41 Read access to character string buf. 

42 Read access to integer array shift. 

43 Read access to character string pointed at by pos. 

44 Write access to integer variable increment. 

45 Read access to integer variable increment. 

46 pos < lim, i.e., the character pointed at by pos is 
closer to the beginning of the file than the 
character pointed at by lim. 

47 Variable increment is greater than 0. 

48 Read access to character string pointer lim. 

49 Read access to character string pointer endjpat. 

50 Write access to the character string pointed at by 
P- 

51 Write access to the character string pointed at by 
t. 

52 p >= pat, i.e., the character pointed at by p is at 
the same location as the character pointed at by pat 
or at a location after the location of the character 
pointed at by pat. 

53 Read access to character string pointer t. 

54 Write access to character string pointer t. 

55 Read access to integer variable curbuf. 

56 Variable t equals buf[curbuf]. 

57 Character being read from the string pointed at by 
p is not the same character being read from the 
string pointed at by t. 

58 Complement of assumption number 52. 

59 Character string pointed at by p is the same as the 
character string pointed at by t. 

60 nfile > 1 , i.e., more than one file is to be 
searched for the same pattern. 

61 Read access to character string pointed at by 
pointer file. 

62 The character being read from the string pointed at 
by pos is the newline character ('\n'). 

63 Variable pos equals buf[curbuf]. 

64 Complement of assumption number 62. 

65 Read access to character string pointed at by t. 


1 






123 


TABLE VIII (Continued) 


Asmp. 

Number Assumption 


66 Pointers t and pos are not equal, i.e., point to 
different locations in the file. 

67 t = buf[l - curbuf] + BUFSIZ - 1. 

68 The character being read from the string pointed at 
by pos is not the newline character ('\n'). 

69 Complement of assumption number 46. 

70 The end of the file being searched has been reached. 

71 lim = pos, i.e., lim and pos point to the same 

character in the file. 

72 Read access to integer file descriptor fd. 

73 Write access to string pointed at by pos. 

74 Complement of assumption number 70. 

75 Complement of assumption number 32. 

76 i < argc, i.e., there are more files to be searched. 

77 Write access to character string pointer file. 

78 File pointed at by fd can't be opened for reading. 

79 Complement of assumption number 78. 







124 



TABLE IX 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE C PROGRAM FASTFIND, CASE 3 


Object Assumptions 


A. 1 

1 





A.2 

4, 

5 




A. 3 

6 





A. 4 

10 , 

11 




A. 5 

13, 

14, 

15 



A. 6 

16 





A. 7 

15, 

17, 

18, 

19 


A. 8 

6 





A.9 

15, 

17, 

20 , 

21 , 

22 

A. 10 

16, 

17 




A. 11 

16, 

17 




A. 12 

18 





A. 13 

12 , 

17, 

23 



A. 14 

24, 

25, 

26 



A. 15 

17, 

24, 

27 



A. 16 

12 , 

28, 

29, 

30, 

31 

A. 17 

17, 

18, 

27, 

31 


A. 18 

4, 

32 , 

33 , 

34 


A. 19 

35 





A.20 

4, 

33, 

34, 

75 


A.21 

24, 

25, 

76 



A.22 

11 / 

24, 

77 



A.23 

35, 

61, 

72, 

78 


A. 24 

61 





A.25 

35, 

61, 

72, 

79 


A.26 

72 





B. 1 

36 





B. 2 

37 





B. 3 

38, 

39, 

40, 

41 


B. 4 

38, 

42, 

43, 

44, 

45, 46, 47, 48 

B. 5 

38, 

39, 

45 



B. 6 

38, 

46, 

48 



B. 7 

59 





B. 8 

38, 

39 




B. 9 

70 





C. 1 

37, 

55 




C. 2 

39, 

41, 

55 



C. 3 

38 , 

40, 

70, 

71, 

72 , 73 

D. 1 

38 , 

49, 

50, 

51 


D. 2 

12 , 

29, 

30, 

52 


D. 3 

41, 

53, 

54, 

55, 

56 

D. 4 

31, 

51, 

57 



D. 5 

58 , 

59 






125 


TABLE IX (Continued) 


Object Assumptions 


E.l 

33, 

60 




E. 2 

61 





E. 3 

43, 

62 




E. 4 

38, 

39, 

41, 

55, 

63 

E. 5 

38, 

54, 

64 , 

65 


E.6 

41, 

53, 

54, 

55, 

56 

E. 7 

38, 

53, 

66 



E. 8 

41, 

53, 

54, 

55, 

66 

E. 9 

65 





E. 10 

43, 

68 




E. 11 

38 , 

39, 

00 

69, 

70 

E. 12 

43 





F. 1 

2 





F. 2 

2 , 

3 




G. 1 

7, 

8 




G. 2 

7 





G. 3 

9 









TABLE X 


ASSUMPTIONS FOR THE C PROGRAM 
KAIL, CASE 1 


Asmp. 

Number Assumption 

1 There exists an structure of type address with five 
character string fields (name, street, city, state, 
and zip) and two pointers of type address (next and 
prior). 

2 Write access is required to pointer called start of 
type address. 

3 Write access is required to pointer called last of 
type address. 

4 Read access is required to pointer called start of 
type address. 

5 Read access is required to pointer called last of 
type address. 

6 There exists a function called menu_select() . 

7 Integer value returned by function menu_select 
equals 1. 

8 There exists a function called enter(). 

9 Integer value returned by function menu_select 
equals 2. 

10 There exists a function called delete(). 

11 Integer value returned by function menu_select 
equals 3. 

12 There exists a function called list(). 

13 Integer value returned by function menu_select 
equals 4. 

14 There exists a function called search(). 

15 Integer value returned by function menu_select 
equals 5. 

16 There exists a function called save(). 

17 Integer value returned by function menu_select 
equals 6. 

18 There exists a function called load(). 

19 Integer value returned by function menu_select 
equals 7. 

20 There exists a function called inputs() with three 
parameters. 

21 The first and second parameters of the function 
inputs() have read and write access. The third 
parameter has only read access. 

22 There exists a function called dls_store() with two 
parameters. 

Both of the parameters for the dls_store function 
have read and write access. 


23 




127 


TABLE X (Continued) 


Asmp. 

Number Assumption 


24 Function dls_store() returns the address of the 
first element of a doubly-linked list of structures 
of type address. 

25 There exists a function called find() with one 
parameter. 

26 The parameter for the function called find() has 
read access only. 

27 Function find() returns the address of the structure 
holding a string that matches the input parameter or 
NULL if there is no match. 

28 There exists a function called display() with one 
parameter. 

29 The parameter for the function display() has read 
access only. 

30 Function menu_select() returns an integer. 




128 


TABLE XI 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE C PROGRAM MAIL, CASE 1 


Object 

Assumptions 

A. 1 

1 / 

2, 3, 5 

A. 2 

6 , 

7, 8, 30 

A. 3 

6 , 

9, 10, 30 

A.4 

6 , 

11, 12, 30 

A. 5 

6 , 

13, 14, 30 

A. 6 

6 , 

15, 16, 30 

A.7 

6 , 

17, 18, 30 

A.8 

6 , 

19, 30 

B. 0 

C. 0 

30 

lr 

2, 4, 20, 

D. 0 

If 

21 

E. 0 

If 

2, 3, 4, 5 

F. 0 

If 

2, 3, 4, 5 

G. 0 

1 , 

26, 27 

H.O 

1 , 

4, 28, 29 

1.0 

1 , 

29 

J. 0 

If 

25, 26, 27 

K.O 

1 , 

4 

L.O 

If 

2, 3, 4, 5 


21, 22, 23, 24 
23 , 24 


29 








129 


TABLE XII 

ASSUMPTIONS FOR THE C PROGRAM 
MAIL, CASE 2 


Asmp. 

Number Assumption 


1 There exists an structure of type address with five 
character string fields (name, street, city, state, 
and zip) and two pointers of type address (next and 
prior). 

2 Write access is required to pointer called start of 
type address. 

3 Write access is required to pointer called last of 
type address. 

4 Read access is required to pointer called start of 
type address. 

5 Read access is required to pointer called last of 
type address. 

6 There exists a function called menu_select(). 

7 Function menu_select() returns an integer. 

8 Integer value returned by function menu_select 
equals 1. 

9 There exists a module called module_l. 

10 Integer value returned by function menu_select 
equals 2. 

11 Integer value returned by function menu_select 
equals 3. 

12 Integer value returned by function menu_select 
equals 4. 

13 Integer value returned by function menu_select 
equals 5. 

14 There exists a function called save(). 

15 Integer value returned by function menu_select 
equals 6. 

16 There exists a function called load(). 

17 Integer value returned by function menu_select 
equals 7. 

18 There exists a function called find() with one 
parameter. 

19 The parameter for the function called find() has 
read access only. 

20 Function find() returns the address of the structure 
holding a string that matches the input parameter or 
NULL if there is no match. 

21 There exists a function called display() with one 
parameter. 

The parameter for the function display() has read 
access only. 


22 







130 


TABLE XII (Continued) 


Asmp. 

Number Assumption 


23 Write access to character string s. 

24 Write access to pointer info of type address. 

25 Read access to pointer info of type address. 

26 Pointer info points to the structure to be deleted 
or NULL if the structure was not found. 

27 Pointer info points to the first structure in the 
list. 

28 Read access to the field next in structure pointed 
at by info. 

29 List is not empty. 

30 List is empty. 

31 Write access to the field prior in structure 

pointed at by start. 

32 Complement of assumption number 26. 

33 Read access to the field prior in structure pointed 
at by info. 

34 Write access to the field next in structure pointed 
at by the field prior in the structure pointed at 
by info. 

35 Structure pointed at by info is not the last struc¬ 
ture in the list. 

36 Write access to the field prior in structure pointed 
at by the field next in the structure pointed at by 
info. 

37 Pointer info points to the last structure in the 
list. 

38 Pointer info points to the structure being presently 
looked at in the list or NULL if there are no more 
structures in the list. 

Pointer info points to the structure to be displayed 
or NULL if the structure was not found. 


39 





131 


TABLE XIII 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE C PROGRAM MAIL, CASE 2 


Object 

Assumptions 

A. 1 

1 / 

2, 3, 5 

A.2 

6 , 

7, 8, 9 

A. 3 

6 , 

7, 10 

A.4 

6 , 

7, 11 

A. 5 

6 , 

7, 12 

A. 6 

6 , 

7, 13, 14 

A.7 

6 , 

7, 15, 16 

A. 8 

6 , 

7, 17 

B.O 

7 


CDE. 0 

1 , 

2, 3, 4, 5 

F. 1 

23 


F.2 

1 , 

18, 19, 20 

F. 3 

1 , 

25, 26 

F. 4 

1 , 

4, 25, 27 

F • 5 

1 , 

2 , 28 

F. 6 

1 , 

4, 29 

F. 7 

1 , 

31 

F. 8 

30 


F. 9 

1 , 

2 

F. 10 

32 


F. 11 

1 , 

28, 33, 34 

F. 12 

If 

5, 25, 35 

F. 13 

If 

28, 33, 36 

F. 14 

1 , 

37 

F. 15 

If 

3 , 33 

F. 16 

If 

25 

G. 0 

1 , 

19 , 20 

H. 1 

1 , 

4 , 24 

H. 2 

1 , 

25, 38 

H. 3 

If 

21, 22, 25 

H. 4 

1 , 

24 , 28 

I. 0 

1 , 

22 

J. 1 

23 


J. 2 

1 , 

19, 20, 21 

J. 3 

1 , 

39 

J. 4 

1 , 

21, 22, 25 

K. 0 

1 , 

4 

L. 0 

1 , 

2, 3, 4, 5 








TABLE XIV 


ASSUMPTIONS FOR THE C PROGRAM 
MAIL, CASE 3 


Asmp. 

Number Assumption 


1 Read access to pointer start of type address. 

2 Write access to pointer start of type address. 

3 Read access to pointer last of type address. 

4 Write access to pointer last of type address. 

5 Write access to string s. 

6 Read access to string s. 

7 Write access to integer c. 

8 Read access to integer c. 

9 c is in the range c < 1 or c > 7. 

10 c = 1. 

11 Structure of type address exists. 

12 Write access to pointer info of type address. 

13 Memory space for pointer info is not available. 

14 Read access to pointer info of type address. 

15 Write access to integer count. 

16 Write access to string p. 

17 Read access to string p. 

18 Length of string p is larger than value in count. 

19 Write access to field name in structure pointed at 

by info. 

20 Read access to field name in structure pointed at 
by info. 

21 Length of field name in structure pointed at by 
info is 0. 

22 Write access to field street in structure pointed 
at by info. 

23 Write access to field city in structure pointed 
at by info. 

24 Write access to field state in structure pointed 
at by info. 

25 Write access to field zip in structure pointed at 
by info. 

26 last = NULL and list is empty. 

27 Write access to field next in structure pointed at 
by info. 

28 Write access to field prior in structure pointed at 
by info. 

29 Write access to pointer p of type address. 

30 Write access to pointer old of type address. 

31 Pointer p points to structure being presently 
looked at in the list or NULL if there are no more 
structures in the list. 










L33 


TABLE XIV (Continued) 


Number Assumption 


Read access to pointer p of type address. 

Read access to field name in structure pointed at 
by info. 

Read access to field name in structure pointed at 
by p. 

Field name in structure pointed at by p precedes 
alphabetically the field name in structure pointed 
at by info. 

Read access to field next in structure pointed at 
by p. 

Complement of assumption number 35. 

Read access to field prior in structure pointed at 
by p. 

Structure pointed at by p is not the first one in 
the list. 

Write access to field next in structure pointed at 
by the field prior in the structure pointed at by p. 
Write access to field prior in structure pointed at 
by p. 

Read access to pointer old of type address, 
c = 2. 

Pointer info points to the structure being presently 
looked at in the list or NULL if there are no more 
structures in the list. 

String in s is the same as the string in the field 
name in the structure pointed at by info. 

Read access to field next in structure pointed at 
by info. 

Pointer info points to the structure to be deleted 
or NULL if the structure was not found. 

Pointer info points to the first structure in the 
list. 

List is not empty. 

Write access to field prior in structure pointed at 
by start. 

Complement of assumption number 49. 

Complement of assumption number 47. 

Read access to field prior in structure pointed at 
by info. 

Write access to field next in structure pointed at 
by the field prior in the structure pointed at by 
info. 

Structure pointed at by info is not the last struc¬ 
ture in the list. 




TABLE XIV (Continued) 


Asmp. 

Number Assumption 


56 Write access to field prior in structure pointed at 
by the field next in structure pointed at by info. 

57 Pointer info points to the last structure in the 
list. 

58 Read access to field street in structure pointed at 
by info. 

59 Read access to field city in structure pointed at 
by info. 

60 Read access to field state in structure pointed at 
by info. 

61 Read access to field zip in structure pointed at by 
info. 

62 Pointer info points to the structure to be displayed 
or NULL if the structure was not found. 

63 c = 3. 

64 C = 4 . 

65 C = 5. 

66 c = 6. 

67 C = 7. 

68 Write access to field next in structure pointed at 
by old. 

69 File mail_list exists. 

70 File mail_list can be opened for writing. 

71 Write access to file pointer fp. 

72 Read access to file pointer fp. 

73 File mail_list can be opened for reading. 

74 Pointer start points to the present structure being 
looked at or NULL if there are no more structures 
in the list. 

75 Read access to field next in structure pointed at 
by start. 

76 Memory space for pointer start is not available. 

77 End of the file pointed by fp has not been reached. 

78 Memory space for pointer pointed by the field next 

in the structure pointed at by info, is not 

available. 

79 Read access to pointer temp of type address. 

80 Write access to pointer temp of type address. 

81 Write access to field next in the structure pointed 
at by temp. 






135 


H 


TABLE XV 


LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE C PROGRAM MAIL, CASE 3 


Object Assumptions 


A. 1 

2, 3, 4 

, 11 

A.2 

8 , 10 


A. 3 

8 , 43 


A.4 

8 , 63 


A. 5 

8 , 64 


A. 6 

8 , 65 


A.7 

8 , 66 


A. 8 

8 , 67 


B. 1 

5 


B. 2 

6 , 7 


B. 3 

8 , 9 


C. 1 

11 , 12 


C. 2 

11, 13, 

14 

C. 3 

11, 15, 

19 

C. 4 

11 , 20, 

21 

C. 5 

11, 15, 

22 

C. 6 

11, 15, 

23 

C. 7 

11, 15, 

24 

C. 8 

11, 15, 

25 

C. 9 

2 , 11 


D. 1 

16 


D. 2 

17, 18 


D. 3 

17, 18 


E. 1 

3, 11, 

26 

E. 2 

11, 27 


E. 3 

11 , 28 


E. 4 

4, 11, 

14 

E. 5 

11, 14 


E. 6 

1 , 11, 

29 

E. 7 

30 


E. 8 

31, 32 


E. 9 

11, 31, 

33, 

E. 10 

30, 32 


E. 11 

11, 29, 

36 

E. 12 

37 


E. 13 

11, 38, 

39 

E. 14 

11, 14, 

38 , 

E. 15 

11, 27, 

32 

E. 16 

11 , 28, 

38 

E. 17 

11, 14, 

41 

E. 18 

1 , 11 


E. 19 

11, 27, 

32 

E. 2 0 

11 , 28 










137 


TABLE XV (Continued) 


Object 

Assumptions 


K. 6 

72 




L.l 

69, 

71, 

72, 

73 

L. 2 

1 , 

11 , 

7 4 


L. 3 

11 , 

12 , 

75 


L. 4 

11 , 

14 



L. 5 

2 , 

11 , 

14 


L. 6 

1 , 

11 



L. 7 

1 , 

11 , 

76 


L. 8 

1 , 

11 , 

12 


L. 9 

72, 

77 



L. 10 

11 , 

12 , 

72, 

77 

L. 11 

11 , 

27 



L. 12 

11 , 

46, 

78 


L. 13 

11 , 

28, 

79 


L. 14 

11 , 

14, 

80 


L. 15 

11 , 

12 , 

46 


L. 16 

11 , 

81 



L. 17 

4, 

11 , 

79 


L. 18 

11 , 

50 



L. 19 

72 









138 


TABLE XVI 

ASSUMPTIONS FOR THE C PROGRAM 
EDITOR, CASE 1 


Asmp. 

Number Assumption 


1 


2 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 

16 

17 

18 

19 

20 
21 

22 

23 

24 


There exists an structure of type line with one 
character string field (text), one integer field 
(num), and two pointers of type line (next and 
prior) . 

Write access is required to pointer called start of 
type line. 

Write access is required to pointer called last of 
type line. 

Read access is required to pointer called start of 
type line. 

Read access is required to pointer called last of 
type line. 

There exists a function called menu_select(). 
Function menu_select() returns an integer. 

Character choice equals 1 . 

There exists a function called enter() with one 
parameter. 

The parameter for the function enter() has read and 
write access. 

Character choice equals 2. 

There exists a function called delete(). 

Character choice equals 3. 

There exists a function called list(). 

Character choice equals 4. 

There exists a function called save() with one 
parameter. 

Character choice equals 5. 

There exists a function called load() with one 
parameter. 

Character choice equals 6. 

There exists a function called patchup(). 

Both parameters of the patchup() function have read 
access only. 

There exists a function called dls_store() with one 
parameter. 

The parameter for the dls_store() function has read 
and write access. 

Function dls_store() returns the address of the 
first element of a doubly-linked list of structures 
of type line. 

There exists a function called find() with one 
parameter. 


25 



139 


TABLE XVI (Continued) 


Asmp. 

Number Assumption 


26 The parameter for the function find() has read 
access only. 

27 Function find() returns the address of the structure 
holding the line number that matches the input 
parameter or NULL if there is no match. 

28 The parameter for the function save() has read 
access only. 

29 The parameter for the function load() has read 
access only. 

30 Each line stored in the field, text, in the 
structure type line is terminated with a carriage 
return (\r) character followed by a new line 
character (\n). 

31 Write access to integer variable linenum. 

32 Read access to integer variable argc. 

33 Integer variable argc equals 2, i.e., filename 
present in command line. 

34 Read access to character string argv. 

35 Write access to character choice. 

36 Read access to character choice. 

37 Read access to integer variable linenum. 

38 Write access to character string s. 

39 Read access to character string s. 

40 Write access to character string fname. 

41 Read access to character string fname. 








140 


TABLE XVII 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE C PROGRAM EDITOR, CASE 1 


Object 

Assumptions 


A. 1 

1, 2 


A. 2 

1, 3 


A. 3 

32, 33 


A. 4 

18, 29, 34 


A. 5 

6, 7, 35 


A. 6 

8, 36 


A. 7 

38 


A. 8 

31, 39 


A. 9 

9, 10, 31, 37 


A. 10 

11, 12, 36 


A. 11 

13, 14, 36 


A. 12 

15, 36 


A. 13 

40 


A. 14 

16, 28, 41 


A. 15 

17, 36 


A. 16 

40 


A.17 

18, 29, 41 


A. 18 

19, 36 


B. 0 

7 


C. 0 

1, 2, 10, 20, 

21, 

D. 0 

1, 21, 25, 26, 

27 

E. 0 

1, 2, 3, 4, 5, 

23, 

F. 0 

1, 2, 3, 4, 5, 

20, 

G. 0 

1, 4, 26, 27 


H. 0 

1, 4 


I. 0 

1, 4, 28, 30 


J. 0 

1, 2, 3, 4, 29 

, 30 


141 


TABLE XVIII 

ASSUMPTIONS FOR THE C PROGRAM 
EDITOR, CASE 2 


Asmp. 

Number Assumption 


1 There exists an structure of type line with one 
character string field (text), one integer field 
(num), and two pointers of type line (next and 
prior). 

2 Write access is required to pointer called start of 
type line. 

3 Write access is required to pointer called last of 
type line. 

4 Read access is required to pointer called start of 
type line. 

5 Read access is required to pointer called last of 
type line. 

6 There exists a function called menu_select(). 

7 Function menu_select() returns an integer. 

8 Character choice equals 1. 

9 Character choice eguals 2. 

10 Character choice equals 3. 

11 There exists a function called list(). 

12 Character choice equals 4. 

13 There exists a function called save() with one 

parameter. 

14 The parameter for the function save() has read 
access only. 

15 Character choice equals 5. 

16 There exists a function called load() with one 

parameter. 

17 The parameter for the function load() has read 
access only. 

18 Character choice eguals 6. 

19 There exists a function called dls_store() with one 
parameter. 

20 The parameter for the dls_store() function has read 
and write access. 

21 Function dls_store() returns the address of the 
first element of a doubly-linked list of structures 
of type line. 

22 Each line stored in the field, text, in the 
structure type line is terminated with a carriage 
return (\r) character followed by a new line 
character (\n). 

23 Write access to integer variable linenum. 

24 Read access to integer variable argc. 





142 


TABLE XVIII (Continued) 


Asmp. 

Number Assumption 


25 Integer variable argc equals 2, i.e., filename 
present in command line. 

26 Read access to character string argv. 

27 Write access to character choice. 

28 Read access to character choice. 

29 Read access to integer variable linenum. 

30 Write access to character string s. 

31 Read access to character string s. 

32 Write access to character string fname. 

33 Read access to character string fname. 

34 There exists a module called module_l with three 
parameters. 

35 All parameters in module module_l have read access 
only. 

36 Module module_l is in patchup mode. 

37 Module module_l is in find mode. 

38 Module module_l returns the address of the structure 

holding the line number that matches the input 
parameter or NULL if there is no match when 
module__l is in find mode. 

39 Write access to pointer info of type line. 

40 Memory space for pointer info is not available. 

41 Read access to pointer info of type line. 

42 Write access to field text in structure pointed at 
by info. 

43 Read access to field text in structure pointed at 
by info. 

44 The first character in the field text in the 
structure pointed at by info is not the line 
terminator ('\0') . 

45 Pointer info points to the structure in the list 
whose field num has the same value as linenum. 

46 Write access to integer variable increment. 

47 Complement of assumption number 44. 

48 Pointer info points to the structure to be deleted 
or NULL if the structure was not found. 

49 Pointer info points to the first structure in the 
list. 

50 Read access to field next in structure pointed at 
by info. 

51 List is not empty. 

52 Write access to field prior in structure pointed at 
by start. 

53 Complement of assumption number 51. 

54 Complement of assumption number 48. 




143 


TABLE XVIII (Continued) 


Asmp. 

Number Assumption 


55 Read access to field prior in structure pointed at 
by info. 

56 Write access to field next in structure pointed at 
by the field prior in the structure pointed at by 
info. 

57 Structure pointed at by info is not the last struc¬ 
ture in the list. 

58 Write access to field prior in structure pointed at 
by the field next in structure pointed at by info. 

59 Pointer info points to the last structure in the 
list. 



144 


TABLE XIX 


LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE C PROGRAM EDITOR, CASE 2 


Object 

Assumptions 

A. 1 

1, 2 

A. 2 

1, 3 

A. 3 

24 , 25 

A. 4 

16, 17, 26 

A. 5 

6, 7, 27 

A. 6 

8, 28 

A. 7 

30 

A. 8 

23 , 31 

A. 9 

23 , 29 

A. 10 

9, 28 

A. 11 

10, 11, 28 

A. 12 

12, 28 

A. 13 

32 

A. 14 

13, 14, 33 

A. 15 

15, 28 

A. 16 

32 

A.17 

16, 17, 33 

A. 18 

18, 28 

B. 0 

7 

C. 1 

1, 39 

C. 2 

1, 40, 41 

C • 3 

29 

C. 4 

1, 42 

C. 5 

1, 29, 42 

C. 6 

43, 44 

C. 7 

29, 34, 35, 37, 38 

C. 8 

29, 34, 35, 36 

C. 9 

43 , 44 

C. 10 

1, 2, 19, 20, 21, 41 

C. 11 

43 , 47 

C. 12 

23 , 29 

DG. 0 

1, 4, 35, 38 

E. 0 

1, 2, 3, 4, 5, 20, 21 

F. 1 

30 

F. 2 

23 , 31 

F. 3 

1, 34, 35, 37, 38, 39 

F. 4 

1, 41, 48 

F. 5 

1, 4, 41, 49 

F. 6 

1, 2, 50 

F. 7 

1, 4, 51 

F. 8 

1, 52 

F. 9 

1, 4, 53 

F. 10 

1, 2 







TABLE XIX (Continued) 


Object Assumptions 


F.ll 

1, 

F. 12 

1, 

F. 13 

1, 

F. 14 

1, 

F. 15 

1, 

F. 16 

1, 

F. 17 

1, 

F. 18 

46 

H. 0 

1, 

1.0 

1, 

J. 0 

1, 


41, 54 
50, 55, 56 
5, 41, 57 
50, 55, 58 
5, 41, 59 

3 , 55 
41 

4 

4, 14, 22 
2, 3, 4, 17, 22 





146 


TABLE XX 

ASSUMPTIONS FOR THE C PROGRAM 
EDITOR, CASE 3 


Asmp. 

Number Assumption 


1 Write access to integer variable linenum. 

2 Write access to pointer start of type line. 

3 Write access to pointer last of type line. 

4 argc = 2, i.e., filename present in command line. 

5 Read access to integer variable argc. 

6 Read access to character string argv. 

7 Write access to character choice. 

8 Write access to string s. 

9 Read access to string s. 

10 Write access to integer c. 

11 Read access to integer c. 

12 c is in the range c < 1 or c > 6. 

13 choice = 1. 

14 Read access to integer variable linenum. 

15 choice = 2. 

16 choice = 3. 

17 choice = 4. 

18 Write access to character string fname. 

19 choice = 5. 

20 choice = 6. 

21 Structure of type line exists. 

22 Write access to pointer info of type line. 

23 Memory space for pointer info is not available. 

24 Read access to pointer info of type line. 

25 Write access to field text in structure pointed at 
by info. 

26 Read access to field text in structure pointed at 
by info. 

27 The first character in the field text in the 
structure pointed at by info is not the line 
terminator ('\0'). 

28 Pointer info points to the structure being presently 
looked at in the list or NULL if there are no more 
structures in the list. 

29 Read access to field text in structure pointed at by 
info. 

30 The value of the integer linenum is the same as the 
value in the field num in the structure pointed at 
by info. 

31 Read access to field next in structure pointed at by 
info. 




147 


TABLE XX (Continued) 


Asmp. 

Number Assumption 


32 Pointer info points to the structure in the list 
whose field nun has the same value as linenum. 

33 Write access to pointer i of type line. 

34 Pointer i points to the structure whose field nun 
needs to be incremented by one. 

35 Read access to pointer i of type line. 

36 Read access to field nun in the structure pointed at 

by i. 

37 Write access to field num in the structure pointed 

at by i. 

38 Write access to integer variable increment. 

39 Read access to integer variable increment. 

40 Read access to field next in the structure pointed 

at by i. 

41 Read access to pointer last of type line. 

42 last = NULL and list is empty. 

43 Write access to field next in structure pointed at 
by info. 

44 Write access to field prior in structure pointed at 
by info. 

45 Read access to pointer start of type line. 

46 Write access to pointer p of type line. 

47 Write access to pointer old of type line. 

48 Pointer p points to structure being presently 
looked at in the list or NULL if there are no more 
structures in the list. 

49 Read access to pointer p of type line. 

50 Read access to field num in structure pointed at by 

info. 

51 Read access to field num in structure pointed at by 
P- 

52 Field num in structure pointed at by p is smaller 
than the field num in structure pointed at by info. 

53 Read access to field next in structure pointed at 
by p. 

54 Complement of assumption number 52. 

55 Read access to field prior in structure pointed at 
by p. 

56 Structure pointed at by p is not the first one in 
the list. 

57 Write access to field next in structure pointed at 
by the field prior in the structure pointed at by p. 
Write access to field prior in structure pointed at 
by p. 


58 







148 


TABLE XX (Continued) 


Asmp. 

Number Assumption 


59 Write access to field next in structure pointed at 
by old. 

60 Read access to pointer old of type address. 

61 Complement of assumption number 27. 

62 Pointer info points to the structure to be deleted 
or NULL if the structure was not found. 

63 Pointer info points to the first structure in the 
list. 

64 List is not empty. 

65 Write access to field prior in structure pointed at 
by start. 

66 Complement of assumption number 64. 

67 Complement of assumption number 62. 

68 Read access to field prior in structure pointed at 
by info. 

69 Write access to field next in structure pointed at 
by the field prior in the structure pointed at by 
info. 

70 Structure pointed at by info is not the last struc¬ 
ture in the list. 

71 Write access to field prior in structure pointed at 
by the field next in structure pointed at by info. 

72 Pointer info points to the last structure in the 
list. 

73 Filename fname can be opened for writing. 

74 Write access to file pointer fp. 

75 Read access to character string fname. 

76 Write access to character string pointer p. 

77 The character pointed at by p is not the null 
terminator ('\0'). 

78 Read access to character string pointer p. 

79 Read access to the character pointed at by p. 

80 Read access to file pointer fp. 

81 Filename fname can be opened for reading. 

82 Pointer start points to the present structure being 
looked at or NULL if there are no more structures 
in the list. 

83 Write access to pointer temp of type line. 

84 Read access to pointer temp of type line. 

85 Read access to field next in structure pointed at 

by start. 

86 Write access to register variable size. 

87 Read access to register variable size. 

88 Memory space for pointer :art is not available. 

89 Write access to register variable lnct. 







149 


TABLE XX (Continued) 


Asmp. 

Number Assumption 


90 Write access to character pointed at by p. 

91 End of the file pointed by fp has not been reached. 

92 The character pointed at by p is not a printable 
character. 

93 The character pointed at by p is not a carriage 
return ('\r 1 ). 

94 Write access to field nun in structure pointed at 
by info. 

95 Read access to register variable lnct. 

96 Memory space for pointer pointed by the field next 
in the structure pointed at by info, is not 
available. 

97 Read access to pointer temp of type address. 

98 Write access to pointer temp of type address. 

99 write access to field next in the structure pointed 
at by temp. 

Read access to character choice. 


100 





150 


TABLE XXI 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE C PROGRAM EDITOR, CASE 3 


Object Assumptions 


A. 1 

2, 

21 

A. 2 

3, 

21 

A. 3 

4, 

5, 21 

A.4 

6 


A. 5 

7, 

11 

A. 6 

13, 

100 

A. 7 

8 


A. 8 

1, 

9 

A. 9 

1, 

14 

A. 10 

15, 

100 

A. 11 

16, 

100 

A. 12 

17, 

100 

A. 13 

18 


A. 14 

75 


A. 15 

19, 

100 

A.16 

18 


A.17 

75 


A. 18 

20, 

100 

B. 1 

8 


B.2 

9, 

10 

B. 3 

11, 

12 

C.l 

21, 

22 

C. 2 

21, 

23, 24 

C. 3 

14 


C. 4 

21, 

25 

C. 5 

14, 

21, 25 

C. 6 

26 , 

27 

C. 7 

14, 

21, 24 

C. 8 

14, 

38 

C. 9 

26, 

27 

C. 10 

2 , ; 

21, 24 

C. 11 

26, 

61 

C. 12 

1, 14 

D. 1 

14, 

21, 33 

D. 2 

21, 

34 , 35 

D. 3 

21, 

36, 37 

D. 4 

21, 

35, 40 

E. 1 

21, 

41, 42 

E. 2 

21, 

43 

E. 3 

21, 

44 

E. 4 

3, 21, 24 

E. 5 

21, 

24 

E. 6 

21, 

45, 46 



151 


TABLE XXI (Continued) 


Object Assumptions 


E. 7 

21 

, 47 



E.8 

21 

, 48 

, 49 


E. 9 

21 

, 48 

, 50, 

51, 52 

E.10 

21 

, 47 

, 49 


E. 11 

21 

, 46 

, 53 


E. 12 

21 

, 48 

, 50, 

51, 54 

E. 13 

21 

, 55 

, 56 


E. 14 

21 

, 24 

, 55, 

57 

E. 15 

21 

, 43 

, 49 


E. 16 

21 

, 44 

, 55 


E. 17 

21 

, 24 

, 58 


E. 18 

21 

, 45 



E. 19 

21 

, 43 

, 49 


E. 2 0 

21 

, 44 



E.21 

21 

, 24 

, 58 


E.22 

21 

, 24 



E. 23 

21, 

, 24, 

, 59 


E. 24 

21, 

, 43 



E- 25 

21, 

r 44 , 

, 60 


E. 26 

3, 

21, 

24 


E. 27 

21, 

, 45 



F.l 

8 




F. 2 

1, 

9 



F. 3 

1, 

21, 

22 


F. 4 

21, 

24, 

62 


F. 5 

21, 

24, 

45, 

63 

F. 6 

2, 

21, 

31 


F.7 

21, 

45, 

64 


F. 8 

21, 

65 



F. 9 

21, 

45, 

66 


F. 10 

2, 

21 



F. 11 

21, 

24, 

67 


F. 12 

21, 

31, 

68, 

69 

F. 13 

21, 

24, 

41, 

70 

F. 14 

21, 

31, 

68 , 

71 

F. 15 

21, 

24, 

41, 

72 

F. 16 

3, 

21, 

68 


F. 17 

21, 

24 



F. 18 

38 




G. 1 

1, 

21, 

22 


G. 2 

21, 

24, 

28 


G. 3 

14, 

21, 

29, 

30 

G. 4 

21, 

24 



G. 5 

21, 

22 , 

31 


H. 1 

21, 

22 , 

45 


H. 2 

21, 

24, 

48 




152 


TABLE XXI (Continued) 


Object Assumptions 


H. 3 

21, 

29, 50 

H. 4 

21, 

22, 31 

1.1 

12 , 

74, 75 

1.2 

21, 

22, 45 

1.3 

21, 

24 , 28 

1.4 

21, 

29, 76 

1.5 

77, 

79 

1.6 

76, 

78, 79 

1.7 

80 


1.8 

80 


1.9 

21, 

22, 31 

I. 10 

80 


J. 1 

74, 

75, 81 

J. 2 

21, 

45, 82 

J. 3 

2 j- , 

45, 83 

J. 4 

2, 

21, 85 

J. 5 

21, 

84 

J. 6 

21, 

86 

J. 7 

2, 

21, 87 

J. 8 

88 


J. 9 

21, 

22, 45 

J. 10 

21, 

29, 76 

J. 11 

89 


J. 12 

79, 

80, 90, 

J. 13 

79, 

92 

J. 14 

76, 

78 

J. 15 

79, 

80, 90, 

J. 16 

76, 

78 

J. 17 

80 


J. 18 

90 


J. 19 

89, 

94 , 95 

J. 20 

21, 

43, 87 

J. 21 

21, 

31, 96 

J.22 

21, 

44 , 97 

J. 2 3 

21, 

24 , 98 

J. 2 4 

21, 

22, 31 

J. 25 

21, 

29, 76 

J. 26 

21, 

99 

J . 27 

3, 21, 97 

J. 28 

21, 

24 

J. 29 

21, 

65 

J. 30 

80 



153 


TABLE XXII 

ASSUMPTIONS FOR THE ADA PROGRAM 
INTLIST, CASE 1 


Asmp. 

Number Assumption 


1 Read access to pointer Head of type link. 

2 There exists a record of type List with an integer 
field called Value and a pointer to the next record 
of type link called Next. 

3 Read access to the field Next in the pointer Head. 

4 Write access to pointer Head of type link. 

5 Read access to pointer Free of type link. 

6 Write access co pointer Free of type link. 

7 Write access to field Next in pointer Free. 

8 Write access to pointer Tail of type link. 

9 Write access to integer variable Number. 

10 Read access to integer variable Number. 

11 Integer variable Number equals -1. 

12 Read access to pointer Tail of type link. 

13 Write access to field Next in pointer Tail. 

14 Read access to field Next in pointer Tail. 

15 Read access to integer variable I. 

16 Write access to integer variable I. 

17 There exists a procedure called Insert_At_Head with 

one parameter. 

18 The parameter in procedure Insert_At_Head has read 
access only. 

19 There exists a procedure called Insert_At_Tail with 
one parameter. 

20 The parameter in procedure Insert_At_Tail has read 
access only. 

21 There exists a function called List_Length. 

22 Function List_Length returns the number of elements 
in the list, i.e., the length of the list. 

23 There exists a function called Value_At_Position 
with one parameter. 

24 The parameter in function Value_At_Position has read 
access only. 

25 Function Value_At_Position returns the number stored 
in the field Value in the position determined by the 
input parameter. 

26 There exists a procedure called Reclaim with one 
parameter. 

27 The parameter in procedure Reclaim has read access 
only. 

There exists a function called Alloc with one 
parameter. 


28 




154 


TABLE XXII (Continued) 


Asmp. 

Number Assumption 


The parameter in function Alloc has read access 
only. 

Function Alloc returns a pointer of type Link to 
the newly created record that contains the new 
value and a pointer to the next record. 


30 





155 


TABLE XXIII 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE ADA PROGRAM INTLIST, CASE 1 


Obj ect 


Assumptions 


A. 1 

9 





A.2 

10, 11 





A. 3 

10, 17, 

18 




A.4 

10, 19, 

20 




A.5 

15, 16, 

21, 

22 



A. 6 

15, 23, 

24, 

25 



A. 7 

15, 16, 

21, 

22 



A. 8 

15, 23, 

24, 

25 



B. 0 

2, 5, 6, 

7, 

27 



C. 0 

2, 5, 7, 

29, 

30 



D.O 

1, 2, 3, 

4, 

8, 

26, 27 


E. 0 

1, 2, 4, 

8, 

12, 

18, 28, 

29 

F. 0 

If 2, 4 , 

8, 

13, 

14, 20, 

28 

G. 0 

1/ 2, 3, 

4, 

8, 

26, 27 


H.O 

If 2, 4, 

8, 

12, 

13, 26, 

27 

I. 0 

1, 2, 24 

, 25 




J. 0 

1, 2, 22 






156 


TABLE XXIV 

ASSUMPTIONS FOR THE ADA PROGRAM 
INTLIST, CASE 2 


Asmp. 

Nu mb er Assumption 


1 Read access to pointer Head of type link. 

2 There exists a record of type List with an integer 
field called Value and a pointer to the next record 
of type link called Next. 

3 Read access to the field Next in the pointer Head. 

4 Write access to pointer Head of type link. 

5 Read access to pointer Free of type link. 

6 Write access to pointer Free of type link. 

7 Write access to field Next in pointer Free. 

8 Write access to pointer Tail of type link. 

9 Write access to integer variable Number. 

10 Read access to integer variable Number. 

11 Integer variable Number equals -1. 

12 Read access to pointer Tail of type link. 

13 Write access to field Next in pointer Tail. 

14 Read access to field Next in pointer Tail. 

15 Read access to integer variable I. 

16 Write access to integer variable I. 

17 There exists a function called List_Length. 

18 Function List_Length returns the number of elements 
in the list, i.e., the length of the list. 

19 There exists a function called Value_At_Position 
with one parameter. 

20 The parameter in function Value_At_Position has read 
access only. 

21 Function Value_At_Position returns the number stored 
in the field Value in the position determined by the 
input parameter. 

22 There exists a procedure called Reclaim with one 
parameter. 

23 The parameter in procedure Reclaim has read access 
only. 

24 There exists a module called module_l with two 
parameters. 

25 The first parameter in module_l has read access and 
the second, called mode selector, has also read 
access. 

26 The mode selector in module_l is in Insert_At_Head 
mode. 

27 The mode selector in module_l is in Insert_At_Tail 
mode. 

Write access to pointer P of type link. 


28 






TABLE XXIV (Continued) 


Asmp. 

Number Assumption 


29 Read access to the field Next in the pointer Head. 

30 Write access to pointer Head of type link. 

31 Read access to pointer P of type link. 

32 Pointer Head is null, i.e., list is empty. 

33 Write access to pointer Tail of type Link. 

34 Read access to pointer Tail of type link. 

35 Pointers Head and Tail are equal, i.e., only one 
record in list. 

36 Complement of assumption 35. 

37 Read access to field Next in pointer P. 

38 The record pointed by the field Next in pointer P 
is not the same record pointed at by pointer Tail. 
Write access to field Next in pointer Tail. 


39 





1 

158 

TABLE XXV 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE ADA PROGRAM INTLIST, CASE 2 


Object 

Assumptions 



A. 1 

9 



A. 2 

10, 11 



A. 3 

10, 24, 25, 

26 


A.4 

10, 24, 25, 

27 


A. 5 

15, 16, 17, 

18 


A. 6 

15, 19, 20, 

21 


A.7 

15, 16, 17, 

18 


A. 8 

15, 19, 20, 

21 


B. 0 

2, 5, 6, 7, 

23 


CEF. 0 

1, 2, 4, 5, 

7, 

8, 12, 13, 14, 25 

D. 0 

1, 2, 3, 4, 

8, 

22, 23 

G.l 

1, 28 



G. 2 

2, 29, 30 



G. 3 

22, 23, 31 



G. 4 

1, 32 



G. 5 

33 



H. 1 

1, 28 



H. 2 

1, 34, 35 



H. 3 

30 



H. 4 

33 



H. 5 

1, 34, 36 



H. 6 

2, 34, 37, 

38 


H. 7 

2, 28, 37 



H. 8 

22, 23, 34 



H. 9 

31, 33 



H. 10 

2, 39 



I. 0 

1, 2, 20, 21 


J. 0 

1, 2, 18 









159 



Asmp. 

Number Assumption 


Read access to pointer Head of type link. 

Pointer Head is not null, i.e., points to the first 
record in the list. 

Write access to pointer P of type link. 

There exists a record of type List with an integer 
field called Value and a pointer to the next record 
of type link called Next. 

Read access to the field Next in the pointer Head. 
Write access to pointer Head of type link. 

Read access to pointer P of type link. 

Read access to pointer Free of type link. 

Pointer Free is null, i.e., no records in free 
list. 

Write access to pointer Free of type link. 

Write access to field Next in pointer Free. 
Complement of assumption 9. 

Write access to field Next in pointer P. 

Write access to pointer Tail of type link. 

Write access to integer variable Number. 

Read access to integer variable Number. 

Integer variable Number equals -1. 

Write access to integer variable Value. 

Read access to integer variable Value. 

Pointer Tail is null, i.e., number list is empty. 
Read access to pointer Tail of type link. 

Pointer P is null, i.e., list is empty. 

Complement of assumption 22. 

Write access to field Value in pointer P. 

Write access to field Value in pointer 
Initial_Value. 

Write access to field Next in pointer 
Initial_Value. 

Read '.ccess to field Value in pointer 
Initial_Value. 

Read access to field Next in pointer 
Initial_Value. 

Complement of assumption 2. 

Write access to field Next in pointer Tail. 

Read access to field Next in pointer Tail. 

Read access to integer variable I. 

Write access to integer variable I. 

Read access to natural variable LEN. 









TABLE XXVI (Continued) 


Asmp. 

Number Assumption 


35 Write access to natural variable LEN. 

36 Read access to field Next in pointer P. 

37 Read access to positive variable Pos. 

38 Write access to positive variable Pos. 

39 Read access to field Value in pointer P. 

40 Pointers Head and Tail are equal, i.e., only one 
record in list. 

41 Complement of assumption 40. 

42 The record pointed by the field Next in pointer P 
is not the same record pointed at by pointer Tail. 







161 


TABLE XXVII 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE ADA PROGRAM INTLIST, CASE 3 


Object 

Assumptions 

A. 1 

15 

A. 2 

16, 17 

A. 3 

16, 18 

A. 4 

16, 18 

A. 5 

32, 33, 34 

A. 6 

32, 38, 39 

A. 7 

32, 33, 34 

A. 8 

32, 38, 39 

B. 1 

8 , 9 

B. 2 

7, 10 

B. 3 

4, 11 

B. 4 

9, 12 

B. 5 

4, 8, 13 

B. 6 

7, 10 

C.l 

3, 8 

C. 2 

7, 22 

C. 3 

3, 4 

C. 4 

7, 23 

C. 5 

4, 10, 11 

C. 6 

4, 13, 24, 

C.l 

7 

D. 1 

1 , 2 

D. 2 

1 , 3 

D. 3 

4, 5, 6 

D.4 

7 

D. 5 

14 

E. 1 

1, 4, 6, 19 

E. 2 

20 , 21 

E. 3 

1 , 14 

F. 1 

1, 29 

F. 2 

4 , 6, 19 , 2 

F. 3 

1 , 14 

F. 4 

1 , 2 

F. 5 

4, 19, 25, 

F. 6 

4, 14, 31 

G. 1 

1 , 3 

G. 2 

4, 5, 6 

G. 3 

7 

G. 4 

1, 29 

G. 5 

14 

H. 1 

1 , 3 

H. 2 

1, 21, 40 

H. 3 

6 






162 


TABLE XXVII (Continued) 


Object Assumptions 


H.4 

14 


H. 5 

1 , 

21, 41 

H. 6 

4, 

21, 36, 

H. 7 

3, 

4 , 36 

H. 8 

3, 

21 

H. 9 

7, 

14 

H. 10 

4, 

30 

I. 1 

1 , 

3 

1 .2 

32 

, 33, 37 

1 .3 

3, 

4 , 36 

1.4 

4, 

39 

J. 1 

1 , 

3 

J. 2 

7, 

23 

J. 3 

34 

, 35 

J. 4 

3, 

4 , 36 

J. 5 

34 







TABLE XXVIII 


ASSUMPTIONS FOR THE ADA PROGRAM 
CALC, CASE 1 


Asmp. 

Number Assumption 


Write access to string variable STR. 

Write access to float variable NUM_VAL. 

Write access to boolean variable FIRST. 

Read access to string variable STR. 

The first character in string variable STR is not 
"q" or "Q". 

Read access to boolean variable FIRST. 

Boolean variable FIRST is not true. 

Write access to natural variable LEN. 

The first character in string variable STR is eithe 
a digit, a or a and the value of the 

natural variable LEN is larger than one. 

Read access to natural variable LEN. 

Read access to natural variable TOP. 

Read access to natural constant LIMIT. 

Write access to natural variable TOP. 

Write access to array of float STACK. 

Write access to float variable NUM. 

Read access to float variable NUM_VAL. 

Read access to float variable NUM. 

Complement of assumption 9. 

Read access to array of float STACK. 

Exception INVALID_ENTRY has been raised. 

Exception NUMERIC_ERROR has been raised. 

There exists a procedure called GET_STRING with two 
parameters. 

Both of the parameters in procedure GET_STRING have 
write access only. 

There exists a procedure called STR_TO_FLT with 
three parameters. 

Two parameters in procedure STR_TO_FLT have read 
access and the third parameter has write access. 
There exists a procedure called PUSH with one param 
The pr^ameter in procedure PUSH has read access. 
There exists a procedure called OPERATE with one 
parameter. 

The parameter in procedure OPERATE has read access. 
There exists a procedure called POP with one param. 
The parameter in procedure POP has write access. 
There exists a procedure called CLEAR with no 
parameters. 



164 


TABLE XXIX 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE ADA PROGRAM CALC, CASE 1 


Object Assumptions 


A.l 
A. 2 
A. 3 
A. 4 
A. 5 
A. 6 
A. 7 
A. 8 
A. 9 
A. 10 

A. 11 

B. 0 

C. 0 

D. O 

E. O 

F. 0 

G. O 


4 , 
6 , 
1 , 

3 

4, 

2 , 

16, 

4 , 

4 , 
20 
21 
26, 
11 , 
11 , 
13 
23 
25 


5 

7 

8, 22, 23 
9 

4, 10, 24, 25 
26, 27 

18 

28, 29 


27, 

29, 

30, 

31, 

32 

12, 

13, 

14, 

17, 

27 

13, 

15, 

19, 

31 





165 


TABLE XXX 

ASSUMPTIONS FOR THE ADA PROGRAM 
CALC, CASE 2 


Asmp. 

Number Assumption 


1 Write access to string variable STR. 

2 Write access to float variable NUM_VAL. 

3 Write access to boolean variable FIRST. 

4 Read access to string variable STR. 

5 The first character in string variable STR is not 
"q" or "Q". 

6 Read access to boolean variable FIRST. 

7 Boolean variable FIRST is not true. 

8 Write access to natural variable LEN. 

9 The first character in string variable STR is either 

a digit, a ".", or a and the value of the 

natural variable LEN is larger than one. 

10 Read access to natural variable LEN. 

11 Read access to float variable NUM_VAL. 

12 Complement of assumption 9. 

13 Exception INVALID_ENTRY has been raised. 

14 Exception NUMERIC_ERR0R has been raised. 

15 There exists a procedure called GET_STRING with two 
parameters. 

16 Both of the parameters in procedure GET_STRING have 
write access only. 

17 There exists a procedure called STR_TO_FLT with 
three parameters. 

18 Two parameters in procedure STR_TO_FLT have read 
access and the third parameter has write access. 

19 Read access to float variable X. 

20 Write access to string variable STRG. 

21 Read access to string variable STRG. 


22 

The 

first 

character 

in 

string 

variable 

STRG 

is 

n it 

23 

The 

first 

character 

in 

string 

variable 

STRG 

is 

ii _ n 

24 

The 

first 

character 

in 

string 

variable 

STRG 

is 

ii * ii _ 

25 

The 

first 

character 

in 

string 

variable 

STRG 

is 

"/" . 

26 

The 
or " 

first 
R" . 

character 

in 

string 

variable 

STRG 

is 

II £-11 

27 

The 
or " 

first 
D" . 

character 

in 

string 

variable 

STRG 

is 

"d" 

28 

The 

first 

character 

in 

string 

variable 

STRG 

is 

n -> ii 

29 

The 
or " 

first 

Q". 

character 

in 

string 

variable 

STRG 

is 

"q" 

30 

The 

first 

character 

in 

string 

variable 

STRG 

is 

not 


II _i_ II 
x / 

nor 

II _ II 

"Q" . 

II * II II / II 

/ / / 

It -v- H 
X 

, "R", 

"d", "D", 

it 7 it 
* t 

" <5 

It 

t 


30 







166 


I 

TABLE XXX (Continued) 


Asmp. 

Number Assumption 


31 Read access to float variable Y. 

32 Write access to float variable Y. 

33 There exists a module called module_l with two 
parameters. 

34 The first parameter in module_l has read and write 
access and the second, called mode selector, has 
read access only. 

35 The mode selector in module_l is in PUSH mode. 

36 The mode selector in module_l is in POP mode. 

37 The mode selector in module 1 is in CLEAR mode. 






167 


TABLE XXXI 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE ADA PROGRAM CALC, CASE 2 


Object Assumptions 


A.1 4,5 

A.2 6, 7 

A.3 1, 8, 15, 16 

A. 4 3 

A.5 4,9 

A.6 2, 4, 10, 17, 18 


A. 

7 

11. 

33, 

34, 

35 





A. 

8 

4 . 

12 







A. 

9 

4, 

20 







A. 

10 

13 








A. 

11 

14 








B. 

1 

19, 

21, 

22, 

31, 

32, 

33, 

34, 

36 

B. 

2 

31, 

33, 

34, 

35 





B. 

3 

19, 

21, 

23 , 

31, 

32, 

33, 

34, 

36 

B. 

4 

31, 

33, 

34, 

35 





B. 

5 

19, 

21, 

24, 

31, 

32, 

33, 

34, 

36 

B. 

6 

31, 

33, 

34, 

35 





B. 

7 

19, 

21, 

25, 

31, 

32, 

33, 

34, 

36 

B. 

8 

31, 

33, 

34, 

35 





B. 

9 

21, 

26, 

33 , 

34, 

37 




B. 

10 

19, 

21, 

27, 

33, 

34, 

36 



TV 

U « 

11 

21, 

28 







B. 

12 

21, 

29 







B. 

13 

21, 

30 








CDE.O 34 

F. 0 16 

G. 0 18 





168 


TABLE XXXII 

ASSUMPTIONS FOR THE ADA PROGRAM 
CALC, CASE 3 


Asmp. 

Number Assumption 


1 Write access to string variable STR. 

2 Write access to float variable NUM_VAL. 

3 Write access to boolean variable FIRST. 

4 Read access to string variable STR. 

5 The first character in string variable STR is not 
"q" or "Q". 

6 Read access to boolean variable FIRST. 

7 Boolean variable FIRST is not true. 

8 Write access to natural variable LEN. 

9 Write access to natural variable CUM_COUNT. 

10 Boolean variable END_0F_LINE is not true. 

11 Write access to character variable CH. 

12 Read access to natural variable CUM_C0UNT. 

13 Read access to character variable CH. 

14 The first character in string variable STR is either 

a digit, a or a and the value of the 

natural variable LEN is larger than one. 

15 Read access to natural variable LEN. 

16 Write access to float variable X. 

17 Write access to float variable SIGN. 

18 Write access to boolean variable DECIMAL_POINT. 

19 Write access to integer variable COUNT. 

20 Write access to integer variable EXP. 

21 Write access to integer variable EXP_SIGN. 

22 Write access to integer variable INDEX. 

23 The first character in string variable STR is a 

24 Integer variable INDEX is smaller than or egual to 

natural variable LEN. 

25 Read access to integer variable INDEX. 

26 The character in character variable CH is a 

27 The character in character variable CH is a digit. 

28 Read access to float variable X. 

29 Boolean variable DECIMAL_POINT is true. 

30 Read access to boolean variable DECIMAL_POINT. 

31 Read access to integer variable COUNT. 

32 The character in character variable CH is either an 
"e" or an "E". 

33 Read access to integer variable JDEX. 

34 Write access to integer variable JDEX. 

35 Write access to character variable CKR. 

36 Read access to character variable CHR. 

37 The character in character variable CKR is a digit. 



169 


TABLE XXXII (Continued) 


Asmp. 

Number Assumption 


38 Read access to integer variable EXP. 

39 The character in character variable CHR is the 

40 The character in character variable CHR is not the 

nor a digit. 

41 The character in character variable CHR is not the 

a digit, "E", nor "e». 

42 Read access to float variable SIGN. 

43 Read access to integer variable EXP_SIGN. 

44 Read access to integer variable EXP. 

45 Read access to natural variable TOP. 

46 Read access to natural constant LIMIT. 

4 7 Integer variables TOP and LIMIT are equal. 

48 Complement of assumption 47. 

49 Write access to natural variable TOP. 

50 Write access to array of float STACK. 

51 Write access to float variable NUM. 

52 Read access to float variable NUM_VAL. 

53 Read access to float variable NUM. 

54 Complement of assumption 14. 

55 Write access to string variable STRG. 

56 Read access to string variable STRG. 


57 

The 

first 

character 

in 

string 

variable 

STRG 

is 

It It 

58 

The 

first 

character 

in 

string 

variable 

STRG 

is 

II _ II 

59 

The 

first 

character 

in 

string 

variable 

STRG 

is 

II *11 ^ 

60 

The 

first 

character 

in 

string 

variable 

STRG 

is 

II J II 

61 

The 

first 

character 

in 

string 

variable 

STRG 

is 

II j-ll 


or " 

'R" . 








62 

The 

first 

character 

in 

string 

variable 

STRG 

is 

"d" 


or " 

D" . 








63 

The 

first 

character 

in 

string 

variable 

STRG 

is 

ti it 

64 

The 

first 

character 

in 

string 

variable 

STRG 

is 

Hqii 


or " 

Q" • 








6 5 

The 

first 

character 

in 

string 

variable 

STRG 

is 

not 


II _i_ ft 
' / 

II _ II 

i 

It * It It / It 

/ / / 

it M 

, "K" , 

"d", "D", 

It o It 
• / 

"q 

•ti 

t 


nor "Q". 

56 Read access to float variable Y. 

67 Write access to float variable Y. 

68 Integer variable TOP equals 0. 

65 Complement of assumption 68. 

70 Read access to array of float STACK. 

71 Exception INVALID_ENTRY has been raised. 

72 Exception NUKERICERROR has been raised. 









170 


TABLE XXXIII 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE ADA PROGRAM CALC, CASE 3 


Object Assumptions 


A. 1 

4, 

5 





A. 2 

6, 

7 





A. 3 

1/ 

8 





A. 4 

3 






A. 5 

4 , 

14 





A. 6 

2, 

4 , 15 




A. 7 

51, 

52 





A. 8 

4 , 

54 





A. 9 

4, 

55 





A. 10 

71 






A. 11 

72 






B. 1 

28, 

53, 

56, 

57, 

66, 

67 

B. 2 

51, 

66 





B. 3 

28, 

53, 

56, 

CO 

66, 

67 

B. 4 

51, 

66 





B.5 

28, 

53, 

56, 

59, 

66, 

67 

B. 6 

51, 

66 





B. 7 

28 , 

53, 

56, 

60, 

66, 

67 

B. 8 

51, 

66 





B. 9 

56, 

61 





B. 10 

28 , 

53, 

56, 

62 




B. 11 56, 63 

B. 12 56, 64 

B.13 56, 65 


C. 1 

45, 46, 47 

C. 2 

45, 46, 48 

C. 3 

45, 49 

C. 4 

45, 50, 53 

D. 1 

45, 68 

D. 2 

45, 69 

D. 3 

45, 51, 70 

D. 4 

45, 49 

E. 1 

49 

F. 1 

10 

F. 2 

11 

F. 3 

9, 12 

F. 4 

1, 12, 13 

F. 5 

8, 12 

G. 1 

4 , 23 

G. 2 

17 

G. 3 

22 

G. 4 

15, 24, 25 

G. 5 

4, 11, 25 







171 


TABLE XXXIII (Continued) 


Object 

Assumptions 


G. 6 

13, 

18 , 26 


G. 7 

13, 

16, 27, 

28 

G. 8 

29, 

30 


G. 9 

19, 

31 


G. 10 

13, 

32 


G. 11 

15, 

25 , 33, 

34 

G. 12 

4, 

33, 35 


G. 13 

20, 

36, 37, 

38 

G. 14 

21, 

36, 39 


G. 15 

36, 

40 


G. 16 

15, 

22 


G. 17 

13, 

41 


G. 18 

22 , 

25 


G. 19 

2, 

28, 31, 

42, 43, 44 






172 


TABLE XXXIV 

ASSUMPTIONS FOR THE ADA PROGRAM 
ADDRESS, CASE 1 


Asmp. 

Number Assumption 


1 Write access to pointer PT_LIST of type A_I.IST. 

2 There exists a record of type LIST with two integer 
fields called LAST_REC and NEXT_SPACE respectively, 
a field called SPACE which is an array of type 
integer, and a field called KEY_LIST which is an 
array of type KEY. 

3 There exists a record of type KEY with a field 
called NAME of character string type and a field 
PT_DATA of type positive. 

4 Read access to constant MAX_SIZE. 

5 Write access to pointer LEN_LIST of type A_LIST. 

6 Read access to pointer LEN_LIST of type A_LIST. 

7 Read access to pointer PT_LIST of type A_LIST. 

8 Read access to boolean variable FIRST. 

9 Write access to boolean variable FIRST. 

10 Write access to variable OP of type OPERATION. 

11 Read access to variable OP of type OPERATION. 

12 The value in variable OP is equal to CREATE. 

13 The value in variable OP is equal to ADD. 

14 The value in variable OP is equal to CHANGE. 

15 The value in variable OP is equal to DELETE. 

16 The value in variable OP is equal to SEARCH. 

17 The value in variable OP is equal to QUIT. 

18 Write access to variable DATA of type ADDRESS. 

19 Read access to variable DATA of type ADDRESS. 

20 Write access to character string variable NAME. 

21 Read access to character string variable NAME. 

22 Write access to integer variable INDEX. 

23 Write access to boolean variable FOUND. 

24 Boolean variable FOUND is true. 

25 Read access to boolean variable FOUND. 

26 There exists a record of type ADDRESS with the 
following seven character string fields: NAME, 
STREET, CITY, STATE, ZIP, AREA, and PHONE. 

27 Read access to file pointer DATA_ID of type 
ADDRESS_IO. 

28 Read access to field PT_DATA in the record pointed 
at by the field KEY_LIST in the record pointed at 
by pointer PT_LIST. 

29 Read access to integer variable INDEX. 

30 Boolean variable FOUND is not true. 




173 


TABLE XXXIV (Continued) 


Asmp. 

Number Assumption 


31 Write access to field LAST_REC in record pointed at 
pointer LEN_LIST. 

32 Read access to field SIZE in record pointed at by 
pointer PT_LIST. 

33 Read access to file pointer INDX_IL of type 
INDEX_IO. 

34 Read access to all fields in record pointed at by 
pointer LEN_LIST. 

35 Read access to all fields in record pointed at by 
pointer PT_LIST. 

36 Read access to character string constant INDX_NAME. 

37 Write access to file pointer DATA_ID of type 
ADDRESS_IO. 

38 Write access to file pointer INDX_ID of type 
INDEX_IO. 

39 There exists a procedure GET_NAME with one 
parameter. 

40 The parameter in the procedure GET_NAME has read 
and write access. 

41 Procedure GET_NAME returns a character string 
obtained from standard input. 

42 There exists a procedure START_UP with three 
parameters. 

43 All of the three parameters in procedure START_UP 
have read and write access. 

44 Procedure STARTJJP returns a pointer to the first 
record of data, a pointer to the first record of 
the index, and a boolean indicator that indicates 
if input has been accepted. 

45 There exists a procedure CREATE_LIST with two 
parameters. 

46 Both parameters in procedure CREATE_LIST have read 
and write access. 

47 Procedure CREATE_LIST returns a pointer to the 
created list of data records and a pointer to the 
list of index records. 

48 There exists a procedure ENTER_DATA with one 
parameter. 

49 The parameter in procedure ENTER_DATA has write 
access only. 

50 Procedure ENTER_DATA returns a pointer to a 
newly created data record. 

51 There exists a procedure DISPLAY with one 
parameter. 





174 


TABLE XXXIV (Continued) 


Asmp. 

Number Assumption 

52 The parameter in procedure DISPLAY has read access 
only. 

53 There exists a procedure ALTER_DATA with one 
parameter. 

54 The parameter in procedure ALTER_DATA has read and 
write access. 

55 Procedure ALTER_DATA returns a pointer to the 
record for which the data has been altered. 

56 There exists a procedure ALTER_FIELD with one 
parameter. 

57 The parameter in procedure ALTER_FIELD has read and 
write access. 

58 Procedure ALTER_FIELD returns a new character 
string accepted from standard input or the same 
character string received as input if no changes 
were desired. 

59 There exists a procedure SELECT_ALTERNATIVE with two 
parameters. 

60 One parameter in procedure SELECT_ALTERNATIVE has 
both read and write access, the other has only 
write access. 

61 Procedure SELECT_ALTERNATIVE returns the type of 
operation desired to be performed on the database. 

62 There exists a procedure INSERT with two parameters. 

63 One parameter in procedure INSERT has both read and 
write access, the other has only read access. 

64 Procedure INSERT returns a pointer to the first 
record after the insertion has taken place. 

65 There exists a procedure SEARCH with five 
parameters. 

66 Two parameters in procedure SEARCH have read access 
only, the other three have both read and write 
access. 

67 Procedure SEARCH searches the index for a name and 
if found, returns the address of the record and 
indicates that the record was found. 

68 There exists a procedure DELETE with two parameters. 

69 One parameter in procedure DELETE has both read and 
write access, the other has only read access. 

70 Procedure DELETE returns a pointer to the first 
record after the deletion has taken place. 

71 There exists a procedure GET_STRING with two 
parameters. 

Both parameters in procedure GET_STRING have write 
access only. 


72 




175 


TABLE XXXIV (Continued) 


Asmp. 

Number Assumption 


73 Procedure GET_STRING returns a character string 

obtained from standard input and the number of 
characters in the returned string. 





176 


TABLE XXXV 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE ADA PROGRAM ADDRESS, CASE 1 


Object Assumptions 


A. 1 

1, 2, 3, 4 


A. 2 

2, 3, 4, 5 


A. 3 

1, 5, 6, 7, 8, 9, 42, 43, 44 


A.4 

8, 9, 10, 59, 60, 61 


A. 5 

1, 5, 6, 7, 11, 12, 45, 46, 47 


A. 6 

11, 13, 18, 48, 49, 50 


A. 7 

1, 7, 19, 62, 63, 64 


A. 8 

11, 14, 20, 21, 39, 40, 41 


A. 9 

7, 18, 21, 22, 23, 65, 66, 67 


A. 10 

24 , 25 


A. 11 

18, 19, 53, 54, 55 


A. 12 

2, 3, 19, 27, 28, 29 


A. 13 

25, 30 


A. 14 

11, 15, 20, 21, 39, 40, 41 


A. 15 

1, 7, 21, 68, 69, 70 


A. 16 

11, 16, 20, 21, 39, 40, 41 


A. 17 

7, 18, 21, 22, 23, 65, 66, 67 


A. 18 

24, 25 


A.19 

19, 51, 52 


A. 20 

25, 30 


A.21 

11, 17 


A.22 

11, 17 


A. 23 

2, 31, 32 


A.24 

2, 33, 34 


A.25 

2, 33, 35 


A. 26 

33 


A. 27 

27 


B. 0 

40, 41, 71, 72, 73 


C. 0 

2, 27, 33, 36, 37, 38, 43, 44, 45, 
72 

46, 47, 71, 

D. 0 

2, 3, 4, 26, 27, 36, 37, 38, 46, 47 

, 48, 49, 50 

E. 0 

26, 49, 50, 51, 52, 53, 54, 55 


F. 0 

26, 52 


G. 0 

26, 51, 52, 54, 55, 56, 57, 58, 71, 

72 , 73 

H. 0 

57, 58, 71, 72, 73 


I. 0 

60, 61, 71, 72, 73 


J. 0 

2, 3, 4, 26, 27, 51, 52, 63, 64, 65 

72 , 73 

, 66, 67, 71, 

K. 0 

2, 66, 67 


L. 0 

2, 3, 4, 51, 52, 65, 66, 67, 69, 70 

, 71, 72, 73 

M. 0 

72 , 73 






177 


TABLE XXXVI 

ASSUMPTIONS FOR THE ADA PROGRAM 
ADDRESS, CASE 2 


Asmp. 

Number Assumption 


1 Write access to pointer PT_LIST of type A_LIST. 

2 There exists a record of type LIST with two integer 
fields called LAST_REC and NEXT_SPACE respectively, 
a field called SPACE which is an array of type 
integer, and a field called KEY_LIST which is an 
array of type KEY. 

3 There exists a record of type KEY with a field 
called NAME of character string type and a field 
PT_DATA of type positive. 

4 Read access to constant MAX_SIZE. 

5 Write access to pointer LEN_LIST of type A_LIST. 

6 Read access to pointer LEN_LIST of type A_LIST. 

7 Read access to pointer PT_LIST of type A_LIST. 

8 Read access to boolean variable FIRST. 

9 Write access to boolean variable FIRST. 

10 Write access to variable OP of type OPERATION. 

11 Read access to variable OP of type OPERATION. 

12 The value in variable OP is equal to CREATE. 

13 The value in variable OP is equal to ADD. 

14 The value in variable OP is equal to CHANGE. 

15 The value in variable OP is equal to DELETE. 

16 The value in variable OP is equal to SEARCH. 

17 The value in variable OP is equal to QUIT. 

18 Write access to variable DATA of type ADDRESS. 

19 Read access to variable DATA of type ADDRESS. 

20 Write access to character string variable NAME. 

21 Read access to character string variable NAME. 

22 Write access to integer variable INDEX. 

23 Write access to boolean variable FOUND. 

24 Boolean variable FOUND is true. 

25 Read access to boolean variable FOUND. 

26 There exists a record of type ADDRESS with the 
following seven character string fields: NAME, 
STREET, CITY, STATE, ZIP, AREA, and PHONE. 

27 Read access to file pointer DATA_ID of type 
ADDRESS_IO. 

28 Read access to field PT_DATA in the record pointed 
at by the field KEY_LIST in the record pointed at 
by pointer PT_LIST. 

29 Read access to integer variable INDEX. 

30 Boolean variable FOUND is not true. 





178 


TABLE XXXVI (Continued) 


Asmp. 

Number Assumption 


31 Write access to field LAST_REC in record pointed at 
pointer LEN_LIST. 

32 Read access to field SIZE in record pointed at by 
pointer PT_LIST. 

33 Read access to file pointer INDX_ID of type 
INDEX_IO. 

34 Read access to all fields in record pointed at by 
pointer LEN_LIST. 

35 Read access to all fields in record pointed at by 
pointer PT_LIST. 

36 Read access to character string constant INDX_NAME. 

37 Write access to file pointer DATA_ID of type 
ADDRESS_IO. 

38 Write access to file pointer INDX_ID of type 
INDEX_IO. 

39 There exists a procedure GET_NAME with one 
parameter. 

40 The parameter in the procedure GET_NAME has read 

and write access. 

41 Procedure GET_NAME returns a character string 

obtained from standard input. 

42 There exists a procedure START_UP with three 
parameters. 

43 All of the three parameters in procedure START_UP 

have read and write access. 

44 Procedure START_UP returns a pointer to the first 

record of data, a pointer to the first record of 

the index, and a boolean indicator that indicates 
if input has been accepted. 

45 There exists a procedure CREATE_LIST with two 
parameters. 

46 Both parameters in procedure CREATE_LIST have read 
and write access. 

47 Procedure CREATE_LIST returns a pointer to the 
created list of data records and a pointer to the 
list of index records. 

48 There exists a procedure ENTER_DATA with one 
parameter. 

49 The parameter in procedure ENTER_DATA has write 
access only. 

50 Procedure ENTER_DATA returns a pointer to a 
newly created data record. 

There exists a procedure DISPLAY with one 
parameter. 


51 


179 


TABLE XXXVI (Continued) 


Asmp. 

Number Assumption 


52 The parameter in procedure DISPLAY has read access 
only. 

53 There exists a module called M0DULE_1 with 
one parameter. 

54 The parameter in module M0DULE_1 has read and write 
access. 

55 Module M0DULE_1 returns a pointer to the record for 
which the data has been altered. 

56 There exists a procedure SELECT_ALTERNATIVE with two 
parameters. 

57 One parameter in procedure SELECT_ALTERNATIVE has 
both read and write access, the other has only 
write access. 

58 Procedure SELECT_ALTERNATIVE returns the type of 
operation desired to be performed on the database. 

59 There exists a procedure SEARCH with five 
parameters. 

60 Two parameters in procedure SEARCH have read access 
only, the other three have both read and write 
access. 

61 Procedure SEARCH searches the index for a name and 
if found, returns the address of the record and 
indicates that the record was found. 

62 There exists a procedure GET_STRING with two 
parameters. 

63 Both parameters in procedure GET_STRING have write 
access only. 

64 Procedure GET_STRING returns a character string 
obtained from standard input and the number of 
characters in the returned string. 

65 Write access to integer variable COUNT. 

66 Write access to integer variable I. 

67 Read access to integer variable I. 

68 Write access to character string RESPONSE. 

69 Read access to character string RESPONSE. 

70 Read access to field NAME in record pointed at by 
pointer DATA of type ADDRESS. 

71 Read access to field NAME in record pointed at by 
pointer DATA. 

72 The first character in character string RESPONSE is 
either a "y" or a "Y". 

73 Write access to pointer TEMP_DATA of type ADDRESS. 

74 Read access to pointer TEMP_DATA of type ADDRESS. 

75 The first character in character string RESPONSE is 

either a "o" or a "O". 






180 


TABLE XXXVI (Continued) 


Asmp. 

Number Assumption 


76 Complement of assumption number 111. 

77 Write access to natural variable REC_NUM. 

78 Write access to pointer NEW_LIST of type A_LIST. 

79 Read access to field KEY_LIST in record pointed at 
by pointer PT_LIST. 

80 Write access to field KEY_LIST in record pointed at 
by pointer NEW_LIST. 

81 Write access to field NAME pointed at by the field 
KEY_LIST in the record pointed at by pointer 
NEW_LIST. 

82 Field NEXT_SPACE in record pointed at by pointer 
PT_LIST is zero. 

83 Read access to field NEXT_SPACE in record pointed at 
by pointer NEW_LIST. 

84 Write access to field LAST_REC in record pointed at 
by pointer NEW_LIST. 

85 Read access to field LAST_REC in record pointed at 
by pointer PT_LIST. 

86 Read access to field LAST_REC in record pointed at 
by pointer NEW_LIST. 

87 Write access to field NEXT_SPACE in record pointed 
at by pointer NEW_LIST. 

88 Complement of assumption number 118. 

89 Read access to field SPACE in record pointed at by 
pointer PT_LIST. 

90 Read access to field NEXT_SPACE in record pointed 
at by pointer PT_LIST. 

91 Write access to field SPACE in record pointed at by 
pointer NEW_LIST. 

92 Read access to natural variable REC_NUK. 

93 Write access to field PT_DATA in record pointed at 
by fid KEY_LIST in rec. pointed at by ptr. NEW_LIST. 

94 Read access to field SIZE in record pointed at by 
pointer NEW_LIST. 

95 Read access to pointer NEW__LIST of type A_LIST. 

96 Read access to natural variable REC_NUM. 

97 Read access to character string DEL_NAME. 

98 Write access to field KEY_LIST in record pointed at 
by pointer PT_LIST. 

99 Read access to field SPACE in record pointed at by 
pointer NEW_LIST. 

100 The last entry in the arrayed field SPACE in record 
pointed at by ptr. NEW_LIST is larger than the field 
NEXT_SPACE in record pointed at by pointer NEW_LIST. 






181 


TABLE XXXVII 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE ADA PROGRAM ADDRESS, CASE 2 


Object 

Assumptions 


A. 1 

1, 2, 3, 4 


A. 2 

2, 3, 4, 5 


A. 3 

1, 5, 6, 7, 8, 9, 42, 43, 44 

A. 4 

8, 9, 10, 56, 57, 58 


A. 5 

1, 5, 6, 7, 11, 12, 45, 46, 

47 

A. 6 

11, 13, 18, 48, 49, 50 


A.7 

1, 7, 19 


A. 8 

11, 14, 20, 21, 39, 40, 41 


A.9 

7, 18, 21, 22, 23, 59, 60, 

61 

A. 10 

24, 25 


A. 11 

18, 19, 53, 54, 55 


A. 12 

2, 3, 19, 27, 28, 29 


A. 13 

25, 30 


A. 14 

11, 15, 20, 21, 39, 40, 41 


A.15 

1, 7, 21 


A.16 

11, 16, 20, 21, 39, 40, 41 


A. 17 

7, 18, 21, 22, 23, 59, 60, 

61 

A. 18 

24 , 25 


A. 19 

19, 51, 52 


A.20 

25, 30 


A.21 

11, 17 


A.22 

11, 17 


A.23 

2, 31, 32 


A.24 

2, 33, 34 


A.25 

2, 33, 35 


A.26 

33 


A.27 

27 


B. 0 

40, 41, 62, 63, 64 


C. 0 

2, 27, 33, 36, 37, 38, 43, 

63 

44, 

D. 0 

2, 3, 4, 26, 27, 36, 37, 38 

, 46 

E. 0 

26, 49, 50, 51, 52, 53, 54, 

55 

F. 0 

26, 52 


GH. 0 

26, 51, 52, 54, 55, 62, 63, 

64 

I. 0 

57, 58, 62, 63, 64 


J. 1 

7, 19, 22, 23, 59, 60, 61, 

71, 

J. 2 

24 , 25 


J. 3 

51, 52, 82 


J. 4 

62, 63, 64, 65, 68 


J. 5 

69, 75 


J. 6 

69, 76 


J.7 

2, 3, 28, 29, 77 


J. 8 

25, 30 



46, 47, 62, 

7, 48, 49, 50 








182 


TABLE XXXVII (Continued) 


Object 

Assumptions 

J. 9 

2, 3, 4, 32, 78 

J.10 

29, 66, 67 

J.ll 

2, 67, 79, 80 

J. 12 

22 , 29 

J.13 

2, 3, 26, 29, 70, 

J. 14 

2, 82, 83 

J. 15 

2, 84, 85 

J. 16 

2, 77, 86 

J. 17 

2, 87 

J. 18 

2, 83, 88 

J. 19 

2, 84, 85 

J. 20 

2, 77, 89, 90 

J. 21 

2, 87, 90 

J. 22 

2, 89, 91 

J. 23 

2, 3, 29, 92, 93 

J. 24 

2, 29, 66, 67, 94 

J. 25 

2, 67, 79, 80 

J. 26 

1, 95 

J.27 

19, 27, 96 

K.O 

2, 60, 61 

L.l 

7, 22, 23, 59, 60, 

L. 2 

25, 30 

L. 3 

24, 25 

L. 4 

51, 52 

L. 5 

62, 63, 64, 65, 68 

L. 6 

69, 72 

L. 7 

2, 3, 28, 29, 77 

L. 8 

29, 32, 66, 67 

L. 9 

67, 79, 98 

L. 10 

2, 3, 4, 78, 80, 8■ 

L. 11 

2, 83, 99, 100 

L. 12 

2, 83, 87 

L. 13 

2, 83, 91, 92 

L. 14 

1, 95 

M. 0 

72 , 73 


73 , 97 








183 


~! 


TABLE XXXVIII 

ASSUMPTIONS FOR THE ADA PROGRAM 
ADDRESS, CASE 3 


Asap. 

Number Assumption 


1 

2 


3 


4 

5 

6 

7 

8 

9 

10 
11 
12 

13 

14 

15 

16 

17 

18 

19 

20 
21 
22 

23 

24 

25 

26 

27 

28 


29 

30 


31 


Write access to pointer PT_LIST of type A_LIST. 
There exists a record of type LIST with two integer 
fields called LAST_REC and NEXT_SPACE respectively, 
a field called SPACE which is an array of type 
integer, and a field called KEY__LIST which is an 
array of type KEY. 

There exists a record of type KEY with a field 
called NAME of character string type and a field 
PT_DATA of type positive. 

Read access to constant MAX_SIZE. 

Write access to pointer LEN_LIST of type A_LIST. 
Read access to pointer LEN_LIST of type A_LIST. 

Read access to pointer PT_LIST of type A_LIST. 

Read access to boolean variable FIRST. 

Write access to boolean variable FIRST. 

Write access to variable OP of type OPERATION. 

Read access to variable MODE of type OPERATION. 

Read access to variable OP of type OPERATION. 

The value in variable OP is equal to CREATE. 

The value in variable OP is equal to ADD. 

The value in variable OP is equal to CHANGE. 

The value in variable OP is equal to DELETE. 

The value in variable OP is equal to SEARCH. 

The value in variable OP is equal to QUIT. 

Write access to variable DATA of type ADDRESS. 

Read access to variable DATA of type ADDRESS. 

Write access to character string variable NAME. 

Read access to character string variable NAME. 

Write access to character string variable SEEK_NAME. 
Write access to integer variable INDEX. 

Write access to boolean variable FOUND. 

Boolean variable FOUND is true. 

Read access to boolean variable FOUND. 

There exists a record of type ADDRESS with the 
following seven character string fields: NAME, 
STREET, CITY, STATE, ZIP, AREA, and PHONE. 

Read access to file pointer DATA ID of type 
ADDRESS_IO. 

Read access to field PT_DATA in the record pointed 
at by the field KEY_LIST in the record pointed at 
by pointer PT_LIST. 

Read access to integer variable INDEX. 




184 


TABLE XXXVIII (Continued) 


Asmp. 

Number Assumption 


32 Boolean variable FOUND is not true. 

33 Write access to field LAST_REC in record pointed at 
pointer LEN_LIST. 

34 Read access to field SIZE in record pointed at by 
pointer PT_LIST. 

35 Read access to file pointer INDX_ID of type 
INDEX_IO. 

36 Read access to all fields in record pointed at by 
pointer LEN_LIST. 

37 Read access to all fields in record pointed at by 
pointer PT_LIST. 

38 Write access to integer variable COUNT. 

39 Read access to integer variable LEN. 

40 Read access to character string variable STR. 

41 Write access to integer variable I. 

42 Read access to integer variable I. 

43 Read access to integer variable COUNT. 

44 Read access to character string constant INDX_NAME. 

45 Write access to all fields in record pointed at by 
pointer LEN_LIST. 

46 Read access to field LAST_REC in record pointed at 
by pointer LEN_LIST. 

47 Write access to all fields in record pointed at by 
pointer PT_LIST. 

48 Exception INDEX_IO.NAME_ERROR has been raised. 

49 Write access to character string RESPONSE. 

50 Write access to natural variable LEN. 

51 The first character in character string RESPONSE is 
either a "q" or a "Q". 

52 Read access to character string RESPONSE. 

53 Complement of assumption number 51. 

54 File pointer DATA_ID of type ADDRESS_IO is null, 
i.e., file-is not open. 

55 Write access to file pointer DATA_ID of type 
ADDRESS_IO. 

56 Write access to file pointer INDX_ID of type 
INDEX_IO. 

57 Read access to character string constant DATA__NAME. 

58 Exception ADDRESS_IO.NAME_ERROR has been raised. 

59 Boolean variable FIRST is true. 

60 Boolean variable FIRST is not true. 

61 Exception ADDRESS_IO.STATUS_ERROR has been raised. 

62 Exception INDEX_IO.STATUS_ERROR has been raised. 

63 Read access to field NAME in record pointed at by 
pointer DATA of type ADDRESS. 








185 


TABLE XXXVIII (Continued) 


Asmp. 

Number Assumption 


64 Write access to field NAME in record pointed at by 
pointer INIT_KEY of type KEY. 

65 Write access to field PT_DATA in record pointed at 
by pointer INIT_KEY of type KEY. 

66 Read access to pointer INIT_KEY of type KEY. 

67 Write access to field N£XT_SPACE in record pointed 
at by pointer LEN_LIST. 

68 Write access to field SPACE in record pointed at by 
pointer LEN_LIST. 

69 Write access to field NAME in record pointed at by 
pointer NEW_ADDRESS. 

70 Write access to field STREET in record pointed at by 
pointer NEW_ADDRESS. 

71 Write access to field CITY in record pointed at by 
pointer NEW_ADDRESS. 

72 Write access to field STATE in record pointed at by 
pointer NEW_ADDRESS. 

73 Write access to field ZIP in record pointed at by 
pointer NEW_ADDRESS. 

74 Write access to field AREA in record pointed at by 
pointer NEW_ADDRESS. 

75 Write access to field PHONE in record pointed at by 
pointer NEW_ADDRESS. 

76 Read access to pointer NEW_ADDRESS of type ADDRESS. 

77 Write access to pointer NEW_ADDRESS of type ADDRESS. 

78 Read access to field NAME jn record pointed at by 
pointer DATA. 

79 Read access to field STREET in record pointed at by 
pointer DATA. 

80 Read access to field CITY in record pointed at by 
pointer DATA. 

81 Read access to field STATE in record pointed at by 
pointer DATA. 

82 Read access to field ZIP in record pointed jt by 
pointer DATA. 

83 Read access to field AREA in record pointed at by 
pointer DATA. 

84 Read access to field PHONE in record pointed at by 
pointer DATA. 

85 Write access to field NAME in record pointed at by 
pointer DATA. 

86 Write access to field STREET in record pointed at by 
pointer DATA. 

Write access to field CITY in record pointed at by 
pointer DATA. 


87 







TABLE XXXVIII (Continued) 


186 


Asmp. 

Number Assumption 


88 

89 

90 

91 

92 

93 

94 

95 

96 

97 

98 

99 

100 
101 

102 

103 

104 

105 

106 
107 


108 

109 

110 
111 

112 

113 

114 

115 


Write access to field STATE in record pointed at by 
pointer DATA. 

Write access to field ZIP in record pointed at by 
pointer DATA. 

Write access to field AREA in record pointed at by 
pointer DATA. 

Write access to field PHONE in record pointed at by 
pointer DATA. 

Write access to natural variable NUM_CHAR. 

The first character in character string RESPONSE is 
either a "y" or a "Y". 

Read access to character string STRG. 

Write access to character string STRG. 

Read access to character string REPLY. 

Write access to character string REPLY. 

Write access to natural variable IN_CHAR. 

Natural variable IN_CHAR is larger than zero. 

Read access to natural variable IN_CHAR. 

The first character in character string RESPONSE is 
either a "i" or a "I". 

The first character in character string RESPONSE is 
either a "c" or a "C". 

The first character in character string RESPONSE is 
either a "a" or a "A". 

The first character in character string RESPONSE is 
either a "d" or a "D". 

The first character in character string RESPONSE is 
either a "s" or a ,, S". 

Write access to variable MODE of type OPERATION. 

The first character in character string RESPONSE is 
not an "i", "I", "c", "C", "a", "A", "d", "D", ”s", 
nor "S". 

Write access to pointer TEMP_DATA of type ADDRESS. 
Write access to character string SEEK_NAME. 

Read access to pointer TEMP_DATA of type ADDRESS. 
The first character in character string RESPONSE is 
either a "o" or a "O". 

Complement of assumption number 111. 

Write access to natural variable REC_NUM. 

Write access to pointer NEW_LIST of type A_LIST. 
Read access to field KEY_LIST in record pointed at 
by pointer PT_LIST. 

Write access to field KEY_LIST in record pointed at 
by pointer NEW__LIST. 


116 









187 


TABLE XXXVIII (Continued) 


Asmp. 

Number Assumption 


117 Write access to field NAME pointed at by the field 
KEY_LIST in the record pointed at by pointer 
NEW_LIST. 

118 Field NEXT_SPACE in record pointed at by pointer 
PT_LIST is zero. 

119 Read access to field NEXT_SPACE in record pointed at 
by pointer NEW_LIST. 

120 Write access to field LAST_REC in record pointed at 
by pointer NEW_LIST. 

121 Read access to field LAST_REC in record pointed at 
by pointer PT_LIST. 

122 Read access to field LAST_REC in record pointed at 
by pointer NEW_LIST. 

123 Write access to field NEXT_SPACE in record pointed 
at by pointer NEW_LIST. 

124 Complement of assumption number 118. 

125 Read access to field SPACE in record pointed at by 
pointer PT_LIST. 

126 Read access to field NEXT_SPACE in record pointed 
at by pointer PT_LIST. 

127 Write access to field SPACE in record pointed at by 
pointer NEW_LIST. 

128 Read access to natural variable REC_NUM. 

129 Write access to field PT_DATA in record pointed at 
by field KEY_LIST in record pointed at by pointer 
NEW_LIST. 

130 Read access to field SIZE in record pointed at by 
pointer NEW_LIST. 

131 Read access to pointer NEW_LIST of type A_LIST. 

132 Read access to natural variable REC_NUM. 

133 Read access to integer variable NEXT. 

134 Read access to integer variable LAST. 

135 Read access to integer variable LLAST. 

136 Variable NEXT is not equal to variable LAST. 

137 Variable NEXT is not equal to variable LLAST. 

138 Write access to character string THIS_NAME. 

139 Read access to field NAME in record pointed at by 
field KEY_LIST in record pointed at by pointer 
PT_LIST. 

140 Read access to character string SEEK_NAME. 

141 Read access to character string THIS_NAME. 

142 Character strings SEEK_NAME and THIS_NAME contain 
the same string. 










TABLE XXXVIII (Continued) 


Asmp. 

Number 


143 


144 

145 

146 

147 

148 

149 


150 

151 

152 

153 

154 

155 

156 


157 

158 

159 

160 
161 
162 
163 


Assumption 


The character string in variable SEEK_NAME succeeds 
alphabetically the character string in variable 
THIS_NAME. 

Write access to integer variable LOW. 

Write access to integer variable LLAST. 

Write access to integer variable LAST. 

Write access to integer variable NEXT. 

Read access to integer variable HIGH. 

The character string in variable THIS_NAME succeeds 
alphabetically the character string in variable 
SEEK_NAME. 

Write access to integer variable HIGH. 

Read access to integer variable LOW. 

Read access to pointer BLANKS of type ADDRESS. 

Read access to character string DEL_NAME. 

Write access to field KEY_LIST in record pointed at 
by pointer PT_LIST. 

Read access to field SPACE in record pointed at by 
pointer NEW_LIST. 

The last entry in the arrayed field SPACE in record 
pointed at by pointer NEW_LIST is larger than the 
field NEXT_SPACE in record pointed at by pointer 
NEW_LIST. 

END_OF_LINE boolean indicator is not true. 

Write access to character variable CH. 

Read access to character variable CH. 

Write access to natural variable CUM_C0UNT. 

Read access to natural variable CUM_C0UNT. 

Write access to character string STR. 

Write access to natural variable LEN. 









189 


TABLE XXXIX 

LIST OF ASSUMPTION NUMBERS FOR OBJECTS 
IN THE ADA PROGRAM ADDRESS, CASE 3 


Object 

Assumptions 

A.l 

1, 2, 3, 4 

A.2 

2, 3, 4, 5 

A.3 

1, 5, 6, 7, 8, 

A.4 

8, 9, 10, 11 

A. 5 

1, 5, 6, 7, 12 

A. 6 

12, 14, 19 

A.7 

1, 7, 20 

A. 8 

12, 15, 21, 22 

A.9 

7, 19, 22, 23, 

A. 10 

26, 27 

A. 11 

19, 20 

A. 12 

2, 3, 20, 29, 

A. 13 

27, 32 

A.14 

12, 16, 21, 22 

A.15 

1, 7, 22 

A.16 

12, 17, 21, 22 

A.17 

7, 19, 22, 23, 

A. 18 

26, 27 

A. 19 

20 

A.20 

27, 32 

A.21 

12, 18 

A.22 

12, 18 

A.23 

2, 33, 34 

A.24 

2, 35, 36 

A.25 

2, 35, 37 

A. 26 

35 

A.27 

29 

B. 1 

21, 38, 39, 40 

B.2 

22, 41, 42, 43 

B. 3 

21, 42 

C.l 

44, 56 

C. 2 

2, 35, 45 

C. 3 

1, 2, 46 

C. 4 

2, 35, 47 

C. 5 

48 

C. 6 

39, 40, 49, 50 

C.l 

9 

C. 8 

51, 52 

C. 9 

52, 53 

C. 10 

1, 5, 6, 7 

C. 11 

29, 54 

c. 12 

55, 57 

C. 13 

53 


9 


, 13 


24, 


30, 


24 , 


25 


31 


25 









TABLE XXXIX (Continued) 


Object Assumptions 


G. 6 

28 , 90 

G. 7 

28, 91 

G. 8 

20 

G. 9 

49 

G. 10 

39, 40, 49, 92 

G.ll 

52, 93 

H. 1 

94 

H. 2 

39, 40, 97, 98 

H. 3 

99, 100 

H. 4 

95, 96 

1.1 

8, 60 

I . 2 

39, 40, 43, 49 

1.3 

9 

1.4 

52, 101, 106 

1.5 

38, 39, 40, 49 

1.6 

52, 93 

1.7 

52, 102, 106 

1.8 

52, 103, 106 

1.9 

52, 104, 106 

1.10 

52, 105, 106 

1.11 

51, 52, 106 

1.12 

38, 39, 40, 49 

1.13 

52, 93 

1.14 

52, 107 

J. 1 

7, 20, 24, 25, 78, 108, 

J. 2 

26, 27 

J. 3 

110 

J. 4 

38, 39, 40, 49 

J. 5 

52, 111 

J. 6 

52, 112 

J. 7 

2, 3, 30, 31, 113 

J • 8 

27 , 32 

J. 9 

2, 3, 4, 34, 114 

J. 10 

31, 41, 42 

J. 11 . 

2, 42, 115, 116 

J. 12 

24 , 31 

J. 13 

2, 3, 28, 31, 63, 117 

J. 14 

2, 118, 119 

J. 15 

2, 120, 121 

J. 16 

2, 113, 122 

J. 17 

2 , 123 

J. 18 

2, 119, 124 

J. 19 

2, 120, 121 

J. 20 

2, 113, 125, 126 

J. 2 1 

2, 113, 126 

J. 22 

2, 125, 127 






192 


TABLE XXXIX (Continued) 


Object Assumptions 


J. 23 

2, 3, 31, 128, 129 

J.24 

2, 31, 41, 42, 130 

J. 25 

2, 42, 115, 116 

J. 26 

1, 131 

J. 27 

20, 29, 132 

K. 1 

133, 134, 135, 136, 137 

K. 2 

2, 133, 138, 139 

K. 3 

140, 141, 142 

K. 4 

25 

K. 5 

24, 133 

K. 6 

2, 20, 29, 30, 133 

K. 7 

140, 241, 143 

K. 8 

133, 144 

K. 9 

134, 145 

K. 10 

133, 146 

K. 11 

133, 147, 148 

K. 12 

140, 141, 149 

K. 13 

133, 150 

K. 14 

134, 145 

K. 15 

133, 146 

K. 16 

133, 147, 151 

K. 17 

25 

K. 18 

10, 157 

K. 19 

140, l*., 143 

K. 20 

24, 134 

K. 21 

140, 141, 149 

K. 22 

24, 134 

L. 1 

7, 24, 25, 108, 109, 153 

L. 2 

27, 32 

L. 3 

26, 27 

L. 4 

110 

L. 5 

38, 39, 40, 49 

L. 6 

52 , 93 

L.7 

2, 3, 30, 31, 113 

L. 8 

31, 34, 41, 42 

L.9 

2, 42, 215, 154 

L. 10 

2, 3, 4, 37, 114, 116, 120 


L. 11 
L. 12 
L. 13 

L. 14 

M. 1 
M.2 
M. 3 
M.4 


119 , 

119, 123 

119, 127, 128 

131 


2 
2 
2 
1 

157 

158 
160, 161 


120, 123, 127 




APPENDIX E 

EXECUTION FLOW CHARTS FOR PROGRAMS 
INCLUDED IN THE STUDY 


193 






























main 



inputs 


















main 



rind 















































a 1 c u 1 a t e 



















o o K 



Ft d a 
































APPENDIX F 

MAXIMAL INTERSECT NUMBER (MIN) CHARTS 


200 
































































































































































push 


























jstart 







create_list 


218 



(Continued) 














MIN 





























kin 

























APPENDIX G 

METRICS STATISTICAL DATA 


222 







I 











CONTROL STRUCTURE ENTROPY 13:23 TUESDAY, APRIL 10, 1990 

FOR ADA PROGRAMS 






CONTROL STRUCTURE ENTROPY 13:23 TUESDAY, APRIL 10, 1990 

FOR ADA PROGRAMS 


n 

„ 225 


H 

Z 

M ono\«DfN«oO'vn 

H oo>r^<7>r^r*r»%o«o 

io ovooor««-40trtio 

z . 

O o©*N.-ir>imcMC**n 

U 

ryr*^HCNvc>flor^vo 
•O vvifiov^nao 

< «or*p»womcor*fN 

H r-mHHinn«intrt 

O . 

h t'ivmvviflri/1'c 

v'CN'owwrvin 
S£ a.rvn«©iNavr' 

Z oo^avoxor-vr*- 

< V£><*'1«000«—lOenO 

m3 . 

C HfNNHi-(rNMfNV 

10 

M wminc'Oiinr'^N 

Z <x-<rinr-~r'V£>ino'w 

10 0vnW0'0>C\lftV 

X r>o*^*nnvc>«c 

X . 

O fNnnrvMnrvnir 

O 

J 

U MWrtr-cvowvo^ 

Lo rv ««r vc r-> 

C ^-i^mro^eo'^rasr" 

X ^o«r-^c^^oo 

O . 

2 nrvnwwvinic 

O«0<7'*J’«0O«0CT\®’ 

•J o—<r-tr.~4~<moo 

U 0»WO(fO'W«<'C 

U} or»r-»vor^orMsco 

O . 

(o nr-o^hovwi/i 

O r-ty-ooTr-'C'rrmo 

O VOCfNlOOfNVOlO 

O n^O'«OfNHVC(N(N 

O . 

O r-i'VTrm<«rinTrtn^c 

10 

e ^pvr-)’W4nv£>r'«3<^ 

O 













ENTROPY LOADING METRIC 15:08 TUESDAY, APRIL 10, 1990 

FOR ADA PROGRAMS 


1 


226 


X. ooooooooooo 

D ooooooooooo 

►-< ©om^r*o«Ds©w©'r* 

X ©vor-vr^«Nov»''vov«>«w 

< moowom—cmr-iO'^r 

T, . 

«iv>ow(£iinooHr 


£ ooooooooooo 

r> ooooooooooo 

E nOM'0»NW»N®»0 

W r*OfNCN«0^fn^OP'«0 

K soo»n©o»»m»nf-<-<r* 

M mocnmor'*«osor-*r , 'fn 

sc . 

f^or^r^r-^mr^oo —»»n 

I I 


X OOOOOOOOOOO 

D 00r-©'mmO'wmHrvc 

CO V O' ■-< » « tf> O O • >C IN 

^▼o'o»p'^«o«n - v© 
r'yo'cvnnvoHO^^ 


i^HO«50^»^O^VM 
r rn w r< n v n ( — -i 


> «^r*o«r'r*p , ‘ntntn 

u np*r*»H«ao'^r'0'^'N 

O mmoxw^w^^r^mw 

(N'DincNinr'eso'T'c 
O 

H «omwwe'wr»*-v»i-Hve 

w . 

ooooooooooo 



Z w^Of s *oO'Vc©iO'-Hr- U 

< r>ro'oo«i/ , '«>e-vc *■* J 

u r-v'-kr-r^mvcomr-o u. u 

X #-im-Hm©om©r~©w u. w 

'TO-'C'fi^nNHO'^ U3 Q 

vc nr m —< rv CP r- O —< m VC O 

. u 

I Z 

o 

►H U2 

Z (y'C'0'Oia^(?'0\0'^0' f-« q 

< O 

u 

u O 

C -3 

c 
o 
u 

U V) tJ 

J J H < Z 


OU3UZ H Z H < O 

< O UUXJOWQZO lA 

►« OJOXZ<HC^U)J tt 

CC UUZX<H*-JOHWH < 

< OWOO*JOC><>-Z U3 

> JOZUOHO<KV)UJ a. 


O —* OO c-v m O' —« rvi nr 

-4 0 O' r»-H Ift o -cr VO 

rMo —* —* in r* mo m o 

oo i© © INO wo rxo 

C7v P* • v© O' W 

. o • o • o • o • o 

O O O o O 

1 I 

© *■"> O' v ©\ in n in w 

O' o n m w o w r-» « n 

r» © m w mm O' o w © 

n o oo m m mo v o 

O' • vs • v w * w 

. o • O • O • o • o 

o o o o o 

I I 

m -h v av m © "< m m 

mo m -h r»o mo O' o 

-ho m ^ —« m oo v h 

voo v c -ho mo ct' o 

O' • r» ■ vo o* r*- 

• o • o • o • o • o 

o o o o o 

I I 

ht —* r*» r» v© m w —« r~ O 

vo o v o m m c o r- o 

eo o n -H -h m v» o r« «h 

wo O' o vo o r~ o O' o 

o r- so a\ • r* • 

. o • o • o • o • o 

o o o o o 

1 I 

m PA VO V o s© -H#N SOSO 

mm « w <n so © nr vo 

O' O O' m O' r"i v o VO PH 

i© © *rO pa -h pa © m © 

w vo in o r- 

■ o • o • o • o • o 

o o o o o 

I I 

w —* «o*^r O —h —h —h vo m 

O' O rum CO m mo w 

mo O' —• vc vc mo O' o 

to O soo n o wo oo 

O' • r~ vc O' • w 

. o • o • o • o • o 

o o o o o 

I I 

< 

h- Z H < 

o U o z o 

H cc *-» U) J 

OOf-^h* 

a > < > z 

o < K «A UJ 









ENTROPY LOADING METRIC 15:09 TUESDAY, APRIL 10, 1990 

FOR ADA PROGRAMS 




os 

u 




\ 

a 

CO «H 

r- 

CO 


< 

oc o 

V 

o 

o 

H 

SC O 

VC 

o 

h 

O 

O' O 

o 

o 

o 

H 

Os • 

OS 

• 

~ 


• o 


o 

K 


O 

O 


O 





2; 

* 

m os 

in 

V 


Z 

o m 

o» 

OS 

K 

< 

r* o 

r* 

rN 

US 

_3 

r* o 

H 

O 

Q 

BJ 

CO 

r* 


2 


• o 


o 

E 


o 

o 


OS 

V) 

Os ^ 

o 

sc 

1 — 


m o 

CO 

V 


2 

m o 

os 

O 

A. 

US 

m o 

rs 

o 


z 

O' • 

CO 


c 

a: 

• o 


o 

O 

o 

o 

O 


cs 

u 




C_ 






j 

m m 

V 

og 

\ 

u 

—1 o 

V 

m 


US 

sc O 

rN 

O 

l“, 

D 

O' o 

O' 

O 

H 

2 

O' • 

CO 


2 

O 

• o 


o 

w 

2 

o 

O 


K-< 





u 





M 


m m 

O 

o 

u. 

U 

sc O 

o 

o 

u_ 

US 

sc O 

o 

o 

u 

O 

fN O 

o 

o 

O 


O • 

o 


U 


• o 


o 



o 

m 


2 





C 





*-l 

US 

o o 

rs 

m 

H 

O 

o o 

sc 

o 

< 

O 

o o 

sc 

o 

•J 

U 

o o 

r* 

o 

US 

O 

o • 

O' 


CS 


■ o 


o 

cs 



o 


o 





u 





2 





o 


US 



tn 


a 



c 


O 

►3 


< 


U 

U 


u 


O 

US 


c. 


•J 

o 



r-i w-i v —* os vc oo 

O CO O SCO oo 

mo fw o m o oo 

O' o r^o o oo 

Os • O' Os • O • 

• o ■ o • o • o 
o o o -< 


m v w* oo o< vo 

sc H VO OO SCO 

r- o m o oo —< o 

« 0 O VO oo m © 

B • O' O • O' 

. o • o • o • o 
O O m o 


mm oo r* m v m 

VO OO VO COO 

VO OO 0*0 r*o 

mo oo vo r- o 

O' • O’ Os O' 

• o • o • o • o 

O m O O 


OO m —< m V »•** m 

OO vo vo m —• O 

oo vo r* © mo 

OO mo eoo o>o 

o O' « O' 

• o • o • o • o 

— o o o 


v r\i o vo m v r*<e 

v m COV O' O' vo 

r^O O O r-rsi sco 

O' O *-"»© o oo 

•o «o rv O' 

- o ■ o • o • o 

o o o o 


mm o» m mo. eo m 

—* o mo © m rv © 

SCO m O r^o SCO 

O' o mo o*o o>o 

O' Os B • O' 

• o • o ■ o • o 
o o o o 


U 2 

US US * J 

Q s: E < 

z n < h- 

O O j o 

2 U CO H 





ENTROPY LOADING METRIC 15:09 TUESDAY, APRIL 10 

FOR ADA PROGRAMS 


228 






08S LOCO DC DEC L NONDCCL COMMENTS BLANK TOTAL OBJTOTAL AVOBEN RATIO SYSENT ENTLOA 


229 



r*ooooM»«AP' 


»ocir , ci«5r*M* 

heicr-vinino^ 

^<Orooo\rsirvr*r\» 

nm'c^v^'cr'O' 



tn®\o»nf\f>on«c 

(or'«rin®o^^o 

nOHfHinNor' 


ooooooooo 

II I II 

Hr'»ooivcrH , n(MN 

vo»ONn\oHiow>c 

nawmvo'vtn^ 

inHOHfNMMOVC 


OOOOOOOOO 
III I 


NMinfNW^VC®^ 

nnr^w^vvovci 

•OmO^OrMOVO*^*^ 




rNr'^0'vo'«r-\£i 

•c-vveov^r^a^o 

aoP~r'-»-<C7'iri«DP'r>j 

MnHHmMBWiin 


nvi/ivvmvirt'c 

r'CM'flyc'cvvifl 

Ovn«r’*®«orxo^vP*‘ 

oo^^^»or»^r^ 

V0-~i«DOO<~^OCT'O 


HfNINHHINfNfNV 


vcifltna^iAr'-<r>j 

(Nrinr s r'»cino v 
ovna'0'^0'»ov 



r>*«—i»~^r--O'vr:«3V0'''> 
ry^»/ir'orimr'in 
mO'^''«"'i>-<eo^r«or- 
*no«r^-*C'«"’»oo 


o-r'ciw^»noo 

or^oaiaa>^>c 

o>n'cr'O r <'CO 


o— 

roioovv^no 

\c«(NinoNvaio 

fnn^ervHBNiN 
























CONTROL STRUCTURE ENTROPY 15:55 TUESDAY, APRIL 10 

TOR C PROGRAMS 


n 


230 


E 

o 

o 

o 

O 

o 

o 

O 

o 


J 

Ol 

VO 

D 

o 

o 

o 

o 

o 

Q 

O 

o 


< 

m 


E 

o 

in 

04 

in 

H 

O' 

O 

o 


H 

O' 

o 

M 

VO 

m 

Ol 

o 

r- 

o 

VO 

•c 

O' 

O 

m 

o 

X 

in 

ro 

C 0 

*4 

04 

—t 

04 

m 


H 

«o 

» 

< 

VO 

•—1 

Ol 

04 

—4 

VO 

CO 


fl 



o 

E 

• 

. 

• 

• 


* 

• 

• 



O 



m 

Ol 

m 




in 

m 

z 













\ 

SC 

H 

m 











z 

O 

—4 

E 

o 

o 

o 

o 

o 

o 

o 

O 

o 

< 

o 

© 

D 

o 

o 

o 

o 

o 

© 

o 

o 

n 

J 

O' 

O 

E 

VO 

« 

.W 

CO 

VO 


4-1 

4^ 

o 

a 

CO 


M 

r-» 

•-» 

CO 

•-4 

04 

VO 

O 

O' 

£ 


• 

o 

z 

ro 

cn 

m 

o 

a 

•0 

r- 

o 

K 


o 


w 

VO 


04 

r* 

Ol 

Ol 

O' 

VC 





E 

• 

• 







o 





m 

H 

Ol 

h 

04 

—4 

m 

r4 

Z 

V) 


04 











H 

r- 











« 

Z 

ro 

CO 










U3 

U3 

o 

O' 

E 

o 

O 

o 

o 

o 

O 

o 

o 

Q 

E 

o 


D 

r- 

o 

VD 

r* 

CO 

r> 

H 

m 

Z 

E 


© 

to 

O' 

r-i 

m 


VO 

r* 

in 

m 

r> 

O 

o 



«o 

O' 

VO 

Ol 

■*r 

O' 

co 



<J 




>r 


r» 

o 

r- 

vo 

TT 

w 

— 






• 







d 

w 

40 

n* 



04 

r* 

VO 

o- 

04 

V 


— 

u 


o 



04 

m 

04 

04 

04 


04 


< 

o 

© 










o 

d 

—4 

o 











c 

O' 











C 



© 

> 

o 

04 

m 

04 

r» 

04 

.-4 

m 

o 


o 


u: 


O' 


o 

O' 

O' 

4-1 

\£> 

d 




Q 


•“4 

«o 

o 


■0 


VC 

fc. 





CT> 

in 

CO 

CO 

—4 

o 

—4 

o 


J 

04 


O 

P" 

r- 

V 

04 

CD 

CO 

~4 

■ 4 

\ 

u 

o 

o 

H 

O' 


o 

O' 

04 

O* 

m 

4-1 


u 


o 

to 

VD 

m 

r* 

«C 

r*> 

r» 

VP 

VC 

w 

o 

m 

o 










H 

z 

o 



O 

o 

o 

O 

o 

o 

o 

o 

Z 

c 


o 










U 

z 

o 











M 




Z 

o- 

Ol 

VO 

V 

«e» 

o 

O' 

o 

u 




< 

VO 

04 

m 

■w 


o 

■3 

o 

*— 


o 

«w 

u: 

O' 

04 

O' 

o 

VO 

4—1 

r* 

r- 

u. 

u 

V 


E 

O' 


in 

04 


m 

04 

on 

u. 

U3 

yr 

O' 


o 

04 

O' 

O' 

«o 

—4 


rv 

(C 

Q 

O' 

o 


»c 

m 

•-4 

O' 

O 

m 

O' 

cr 

O 


m 











u 



© 


■VT 

04 

■v 

04 

40 

Ol 


04 



© 











z 













o 













»-« 

U2 

in 

4—1 

Z 

O' 

O' 

O' 

O' 

O' 

O' 

O' 

o- 

f- 

Q 

i—i 

o 










< 

O 

CO 

o 











u 

04 

o 










UJ 

o 

Oi 











c 

►J 


© 










a 


o 











O 













u 




u 





to 



H 



H 





J 


t- 



2 

z 


z 


o 

10 


U 


Z 



U3 

o 


u; 


< 

a 


w 

u 

u 



H 

l/J 


H 


»-< 

o 


Q 

u 

E 

z 

< 

to 

K 


V) 


cc 

u 

U 

Z 

< 

E 

< 

H 

Z 

< 


z 


< 

o 

to 

o 

cs 

O 

•J 

O 

O 

Li 


o 


> 


a 

z 

03 

u 

53 

H 

U 

a 


u 










CONTROL STRUCTURE ENTROTY 
FOR C PROGRAMS 


~1 


231 


« 

u, 

< 


X 

< 

o 

m 

w 

D 

H 

m 

m 

m 


•J r* -h 

< vo o 

N n o 

Ok o r- o 

H o> ♦ 

n • o 


(n w v pn m -w 

mo -ho mo 

r- o vo mo 

ni o mo co o 

c*> « ov • c* 

• o • o • o 
o o o 


-4 -4 VO —h O O 

vo m o o o o 

Ok VO VO o o 

O m VO O O O 

in o\ o 

♦ o • o • o 
o o —I 



V -H co CO 

O O V fN 

Ok O P'4 O 

VO VO o 

Ok CO • 

• o • o 

o o 


f** VO CO -4 

mo o o 

fN o mo 

-4 O CO O 

Ok • Ok • 

• O • O 

O O 


v m o O 

m vo o o 

-H V O O 

m <n o o 

v . O • 

• o • o 

O m 


vo -h 
o o 
v O 
vo O 
O' • 

• o 
o 


o 

X 

X 

W 

Q 

X 

D 


V) 

N 

X 

to 

T. 

Z 

O 

u 


m in 04 O' mm 

-H V VO *0 CO -4 

O' m -4 —4 o v 

Ok V 0*0 CO VO 

04 • !"• —4 • 

• o • o • o 

O O o 


r* r* o o v -4 

vo vo o o m vo 

v O O O -4 v 

eo m O O m 04 

m o v • 

. o • o • o 

0-4 0 


O' VO 
O -H 


X tO 

— U 

< 

n X 

C3 

C 

o 

x 

a 

•o 

\ u 

to 

11 Q 

H X 

X O 

to X 

u 

t*- u 

u. to 

to Q 

O 

U 


O 

►4 to 

I- Q 

< O 

•J u 

to o 

X *J 

c 
o 
u 

X 

o 

t/> 

X 

< 
to 
X 


o m m r* vo -4 

O' O CO P'4 — o 

V O fN O CO o 

co o vo o mo 

O' CO O' 

• o • o • o 
o o o 


o o r- © «o -h 

O O vo VO o o 

O O v o mo 

o o «o m co o 

© m O' 

• o • o • o 

-4 0 0 


m —h 

m O 
m o 
a o 

O' • 

• o 
o 


v *-< m co o o 

o o in '■n o o 

-ho O fN o o 

o< o mo c o 
o • r- o 

• o • o . o 

O o -* 


vo —» mm r** vo 

-4 0 co -4 mo 

CD O O V 04 o 

mo co vo -4 0 

O' -4 O' 

• o • o • o 
o o o 


V PV 
-H O 

V O 

m o 

O' 

• o 
o 


-4 ® O O 

VO vo o o 

O' o o o 

-4 0 o o 

CO o 

• o • o 

O -4 


m « m r* 

m pn ao fN 

O ni PN O 

mo vo o 

r* cd 

• O • o 

o o 


P '4 O' CO co 

vo v v fN 

—4 —4 Pv O 

r* o vc o 

r* ce 

• o • o 

o o 


m o 
r- o 

PN O 
O' • 

• o 
o 


O O -4 co 

O O vo vo 

O O Ok o 

O O -4 0 

O eo 

• o • © 

-H O 


rn —• o W 

O O O' o 

— © V O 

O' O CO o 

O' O' 

• O • o 

© o 


m pn v «— 

-4 V O O 

O' m O' o 

O' v v o 

PN O' 

• o • © 

o o 


P* -4 

vo O 

PV O 

r* o 

O' ■ 

• o 

o 


u 

o 

o u 

u u 

o to 

o 


o 

u 

u: to 

O u 

X < 

O X 

X x 


tr> 

H 

X 

UJ 


O 

U 


X 

X 

< 

e 


_2 

< 

H 

O 

H 





CONTROL STRUCTURE ENTROPY 15:55 TUESDAY, APRIL 10 

FOR C PROGRAMS 


I 


232 


o 



H 

2 ^VOlO'O'OtOO'^ 

u 

H 

in «ao«/>chinvr'mrv 

2 . 

o HfNINHfNnMfvn 

u 

^reovomr'jwcp'ooo 
•J r'0\WO'flN«N«) 

< moHp , nom®fY 

H r'o»vo»r*»H««> 

O . 

H 

XL (7>r*BCl(^0'DrN'ff 

2 r'0»r*0r^^*wor^ 

< onHVDvcvown 

*J • .. 

P fN 

V) 

H r>o^vciT'0'ocAO 

2 

w i-%^YNOO0'O«>^ 

JC r* ©» «-< ro p*i o *r © 

r . 

o nnvfNNWiNMM 

u 

0'Tr^«or*u i i®»Ar*' 

uj 

u •o.*N^<r\-^O'^r«0 

a: ... . 

J 

U (A®*"<ro(riicvrY 

u n^o«^vr-0'n 

O BOinina^ri'ce 

2 m«rtNOw«riN 

O . 

^vor^«oiNr^«o\ctn 
»J BNi/i^r'iTi^r'Jin 

U Or^CT'CT'CT'O'tT'OC^ 

uj r'r-o'r^^or'*-i-M 

o . 

MNpv^pvpvhPY^ 

u ^««vc««oino 

Q r*»«p'r~«omfNOAO 

O rHMnBo-<oir 

U —•^r«y»5£>^vso>r'V£ 

O . 

«/> 

O 













ENTROPY LOADING METRIC 23:26 WEDNESDAY, APRIL II 

FOR C PROGRAMS 


233 








o 

O 


o 

o 

o 

© 


J 

rg 

•—t 

rn 

O' 

CO «H 

oo ^g 

o 

•g 







o 

o 

O 

o 

o 

o 

© 


< 

fx 

© 















rg 

vo 

rg 

CO 



H 

m 

o 





m 



VO 

in 

tn 

O' 

r* 

o 

vo 

in 

-g 

rg 

vo 

m 

O' 

O 

vo 

© 







K 

in 

m 

«o 


rg 


rg 

r- 

xr 

© 

in 

VO 


H 


o 


■ 





< 

vo 

*-g 

rg 

m 

•—< 

vo 

CO 

CO 

in 

XT 

CD 

Px 

n 


o 

o 


© 

O 

o 



in 

m 

in 

XT 

XT 

tn 

in 

*o 

o 

© 



z 

\ 


© 

m 

1 

vo 

rg 

rg --4 

XT VO 

rg 

m 














Z 

to 

o 

XT 

rg 

»-< O 

rg o 









o 


o 

o 

o 

o 

© 

© 

< 

vo 

o 

rg 

in 

XT CO 

XT O 

O' 



o 


O 

O 

O 

o 

o 

o 

o 

© 

© 

© 

n 

tJ 

•-g 

o 







X 

VO 

CO 

•H 

CO 

VO 

n 

m 

XT 

XT 

o 

xr 

rg 

o 

S3 

O' 






*** 


M 

r- 


CO 

H 

rg 

vo 

o 


rg 

vo 

vo 

rg 

x 










Z 

m 

cr> 

m 

o> 

O 

co 

r* 

•0* 

•g 

CO 

XT 

—* 

a 










M 

VD 

p* 

m 

r* 

m 

tn 

O' 

o 

m 

vo 


o 



















rg 




m 

2 

to 


r~ 

XT 

m 

o in 

rg co 

XT 

in 















u 

VO 

O' 

*■* 

•H 

vo -g 

rg m 
















o: 

< 

O' 


O' 

o 

in © 

XT O' 

© 

o 














u 


CD 

XT 

CD 

o 

CD © 

O' rg 

o 

VO 

X 

O 


o 

o 

O 

o 

o 

O 

o 

o 

© 

o 

o 

CO 

rg 


CO 

♦ 

CO 

r-> 

IN 


s 


o 

vo 

r- 

CO 

p* 

—i 

o 

m 

CO 

© 

m 

z 



o 


o 






O' 


ro 

XT 

vo 

r~ 

in 

vo 

in 

rg 

© 

XT 

© 


© 









OO 

C7> 

VO 

tn 

xr 

ri 

«c 

in 

m 

CO 

O' 

P* 













VO 



xT 



vo 

rg 

XT 

CTl 

*-g 























CC 


to 


m 

in 

r* ~g 

p* -g 






r» 


p» 

rg 


XT 

© 

H 

XT 

m 

— 

H 

O' 

O 

vo 

p* 

co in 

m o 


to 


xt 


m 

eg 

m 

rg 

XT 

tn 

1 

1 


tn 


Z 

vo 

O 

rg 

m 

vo r- 

in o 

VO 

o 














rs 

LO 

vo 

o 

vo 

m 

—< in 

VO O 

o 

o 















E 

O' 


m 


pg 

O' • 

CD 















c 

r 


© 


© 

• © 

• © 


© 

> 

o 

rg 

m 

M 

r* 

rg 

•-H 


rg 

tn 

CD 

O' 

o 

o 

o 


© 


o 

o 

O 


10 

m 

crv 

~g 

O 

O' 

m 


in 

O' 

O' 

r~ 

VO 

c: 

u 









Q 

—t 

—« 

CD 

cr> 


<o 

XT 

rg 

VO 

rg 

m 

m 

c- 











O' 

m 

CD 

CD 

~g 

O 

»*g 

P* 

rg 

VO 

VO 

CO 


o 

XT 

—< 

CO 

vo 

n't xr 

cd -g 

O' 

© 

O 

r> 

r* 

xt 

fg 

CO 

CO 

^g 

—* 

XT 

vo 

O' 

^g 

\ 

u 

r- 

o 

w~* 

vo 

p* o 

CD © 

CD 



o< 


O 

O' 

rg 

r» 

in 

tn 

rg 

m 

rg 

VO 


to 

O' 

© 

XT 

rg 

co rg 

o o 

VO 



VO 

in 

p* 

CO 

r* 

p* 

VO 

vo 

rn 

*n 

_g 

VO 

in 

o 

co 

o 

XT 

in 

co co 

VO © 

O' 

© 














H 


O' 


rg 


o 

O' • 

03 



© 

o 

o 

© 

o 

o 

o 

O 

© 

o 

© 

© 

Z 

o 


© 


© 

• © 

• o 
















w 

z 

© 


O 


o 

© 

o 



r* 

rg 

VO 

XT 

XT 

o 

O' 

P* 

p* 

VO 

vo 

m 

u 










< 

VO 

rg 

in 

XT 


o 

4D 

VO 

vo 

in 

m 

m 

+-* 

J 

r* 

vo 

m 

vO 

co —x 

co m 

rw 

© 

u 

O' 

rg 

O' 

r*» 

VO 

m 

p 

r* 

~g 

p« 

in 

O 

u. 

u 

—< 

r« 

— 1 

O' 

in xr 

co tn 

O' 

XT 

X 

O' 

,H 

in 

rg 

O' 

m 

rg 

o 

VC 

XT 

m 

vo 

u. 

to 

XT 

o 

© 

m 

O O' 

XT © 

co 



o 

rg 

O' 

crv 

XT 

w 

XT 

in 

rg 

vO 

VO 

« 

u: 

Q 

•-* 

© 

O' 

© 

O' © 

in o 

in 



VO 

in 

_4 


O 

in 

o< 

CO 

© 


VO 

vo 

O 


«o 


vo 


in • 

to 

XT 















u 



© 


o 

• © 

• © 


© 



rg 

XT 

rg 

tn 

rg 

XT 

m 

O 

1 

© 

1 


m 

z 


o 


© 

1 


© 

l 

© 

© 















o 

to 

m 


o 

o 

in m 

xr »g 

O' 

XT 


O' 

Os 

O' 

O' 

O' 

O' 

O' 

O' 

O' 

O' 

O' 

O' 

H 

o 

P* 

o 

rg 

r~~ 

r>- r* 

in o 

VO 

tn 














< 

o 


o 

O' 

CO 

P* XT 

CD O 

tn 

O 














o 

u 

O' 

o 

rg 

r-i 

fx SO 

r» o 

m 

O 














to 

c 

O' 


m 


W4 

O' • 

CD 
















J 


© 


O 

■ © 

• © 


© 














c: 

o 


o 


O 

1 


o 

1 

o 

O 


u 




W 




J 





u 


J 








o 



J 

H 




< 





z 


< 








o 

id 


U 

Z 




H 

Z 


H 

< 

o 


H 


Z 



H 



< 

O 


UJ 

u 

id 

id 

o 

O 

u 

O 

2 

O 

tn 


O 


U3 


O 

Z 

o 



O 

•J 

Q 

X 

U 

Z 

< 

H 

c 

*-g 

Id 


C£ 


H 


Q 


rg 

w 



tt 

u 

U 

2 

X 

< 

< 

H 

n 

O 

H 

in 

H 

< 


*n 


O 


H 


H 


< 

o 

u 

O 

o 

(X 

J 

O 

a 

t> 

< 

>» 

Z 

to 


a 


> 


< 


z 


:> 

J 

Q 


u 

to 

CD 

H 

o 

< 

ct 

in 

to 



O 


< 


OS 

in 













r' -< 

fN 

m 

N- fN 

m 

•H 

H H 

VO 

•—l 

o 


< 

NO O 

m 

o 

^ o 

fs 

o 

NO 

o 

© 

o 


H 

»N O 

r* 

o 

*o o 

ps 

© 

O' VO 

cr 

© 

o 

os 

O 

r* o 

m 

o 

m o 

co 

o 

© -< 

NO 

© 

o 


H 

CT\ . 

ON 

• 

OS • 

os 

• 

in . 

O' 

• 

o 

H 


• o 

• 

o 

• o 

» 

© 

• o 


© 




o 

o 


o 

o 


© 

o 



z 












\ 

* 

Cj- «-4 

co 

CO 

r- no 

oo 

r-4 

Cf r-< 

© 

o 

NO 


Z 

o o 

V 

fN 

m o 

© 

© 

in vo 

o 

© 

o 

o 

< 

os o 

fN 

o 

fN o 

ps 

o 

*h -cr 

o 

o 

•*r 

n 


o 

to 

o 

—< o 

CO 

© 

ps fN 

o 

o 

NO 

o 

CO 

Os . 

•o 


o> ♦ 

Os 


v • 

© 


o> 

s 


• o 

• 

o 

• o 


o 

• o 

» 

o 


K 


o 

O 


o 

O 


o 

H 


o 

O 












sc 

14 

r*> fN 

fN 

Os 

m m 

r- 

r* 

© © 

TT 

—* 

—1 


U 

«-< cr 

SO 

V 

CO «-f 

VO 

no 

© © 

in 

NO 

VO 

ex 

< 

Os rN 


w* 

O NT 

«o* 

o 

© o 


cr 

os 

u 

(X 

Os v 

r- 

O 

CO VO 

CO 

pn 

o o 

fN 

fN 

© 

o 

o 

fN 

r» 



pn 


o • 



m 

z 


• O 


o 

• o 


© 

• © 


© 




o 

o 


o 

o 



o 


© 

c: 

to 

o 

fN 

r* 

VO — C 

o 

© 

r- r- 

CO 


in 

— 

H 

OS o 

co 

fN 

w o 

o 

O 

NO VO 

o 

© 

pn 


z 

V o 

rv 

o 

CO o 

o 

o 

NT © 

fl 

© 

PS 


u 

CO O 

NO 

o 

in o 

o 

© 

co ps 

CO 

O 

CD 


r 

os • 

CO 


O' • 

© 


pi 

© 


ON 

Q 


* © 


o 

• o 


© 

• O 


o 


O 

o 

o 

o 


o 

. • 


© 

o 


o 

CX 

u 











C~ 


TT _ 

in 

CO 

© © 

NO 


fN m 

r- 

VO 


\ 

u 

O O 

in 

fN 

© © 


o 

CO w* 

in 

© 

*-* 


(4 

—' o 

o> 

fN 

© o 

to 

o 

© V 

fN 

© 


to 

D 

On O 

fs 

o 

O o 

m 

© 

CD NO 


© 

fN 

H 

Z 

Os 

r» 


© 

o 


_< 

o> 


o 

Z 

o 

* O 


o 

* © 


o 

• © 


© 


U3 

z 

o 

o 


iH 

© 


© 

© 


© 













U 












*-< 

-5 

^ CD 

o 

o 

If' CO 

pn 

r- 

fN Os 

® 

CO 

fN 

b. 

u 

N© 

o 

o 

m «n 

<o 

fN 

SO «■ 

cr 

fN 

in 

U. 

14 

Os o 

o 

© 

O' fN 

fN 

© 

•—4 ^ 

fN 

© 

r* 

(4 

D 

—' o 

o 

o 

r-s O 

NO 

© 

r* o 

NO 

o 

fN 

o 


co 

o 


P* 

CO 


r* 

CO 


o. 

u 


• o 


o 

• O 


© 

■ © 


© 




o 

—« 


© 

o 


© 

o 


o 

z 












o 












*-■ 

t4 

o o 


«o 

tr -- 

o 


PS fN 

*T 


p- 

H 

Q 

o o 

VO 

VC 

© o 

Os 

© 

•f TT 

© 

© 

VC 

< 

O 

o o 

ON 

o 

© 

Tf 

o 

Os fN 

o 

© 

fN 


u 

o o 

—1 

o 

os o 

OO 

o 

OS *T 


© 

r- 

U3 

o 

o • 

CO 


o. • 

ON 


fN 

o 


o. 

K 

w 

• o 


o 

» o 


o 

* © 


© 


ex 


•-S 

o 


o 

o 


© 

© 


o 

o 












u 






to 






z 





_} 

H 






o 


14 



u 

2 






to 


a 



(4 

(4 


(4 

uc 



ex 


o 

J 


Q 

z 


U 



< 

< 


o 

u 


Z 

z 


< 

< 


H 

u 


o 

(4 


o 

o 


K 



O 

b. 


J 

Q 


z 

u 


CD 

© 


H 





ENTROPY LOADING METRIC 23:26 WEDNESDAY, APRIL It 

FOR C PROGRAMS 


M 

z 

\ 


o 

5 


a 

z 

D 


< 

O 

►J 

H 

Z 


ro o 

O v 
—< O 
o vc 


o o 
© o 
o o 
o o 


• o 


rs O 
m O 

co o 


CD O' 

r~ 
lTi r-~ 


o o 
o o 
o o 
o o 


o 

CL 


• O 


I 


H 

z 


o vo 


m O 

r* o 
co o 


o o 
o o 
o o 
o o 


■v <r 

O' f*"i 
—« in 
in 


vc 
r* O 
vc iC 


o O 
O O 
O O 
o o 


o —« —< 


O O'. 
O' O' 


• o 


I 


I 


H 

< 


< 

H 

o 

H 


o o 
o o 
o o 
o o 


r- vc 
r» o 

VO VO 


O. 

nr o 

o 

CO O 


O' o 
v © 


• o 


O 

U 


< 

U3 


< 

f- 

o 

H 


< 

O 


o 

> 

< 


H 

Z 









ENTROPY LOADING METRIC 23:26 WEDNESDAY, APRIL II 

FOR C PROGRAMS 



< 

PN 


TT 

vo 

O' 

—i 

m 

eo 

r» 

o 

PN 

in 

eo 

vo 

PH 

«PT 

o 

© 

in 

•J 

w-4 

r* 

O 

V 

PH 

r* 

vo 

O' 

VO 

H 

O 

o 

V 

PH 

40 

VO 

•>4 

eo 

r» 

E 










W 

PH 

rH 

PH 

PH 

PH 


PH 

PH 


H 

© 

PN 

•H 

V 

PH 

PN 

in 

VO 

« 

Z 

VO 

in 

in 

VO 

r* 

CO 

PH 

o 

»o 

u 

cr> 

»n 

*tr 

V 

PN 

o 

TT 

«-4 

in 

l/> 

vn 

VO 

r~ 

V 

VO 

eo 

m 

r* 

eo 











V) 

r-P 

•—I 


*—p 

r"4 

-< 

»H 

•—i 



VO 

•r 

o 

PN 

PH 

PH 

PH 

IN 

m 

O 

ph 

CO 

VO 

PN 

VO 

© 

in 


© 

M 

in 

40 

CO 

O 

03 


PH 

O' 

© 

H 


in 

vo 

V 

pH 

O 

W 

© 


£ 

o 

► 

o 

1 

o 

1 

o 

o 

© 

1 

o 

1 

© 

1 

o 

1 


rv 

03 

V 

vo 

r-' 


eo 

IN 

er 

Z 

vo 


PN 

»-4 

o 

eo 

in 

m 

vo 

u 

m 

r- 

H 


o 

PH 


•—i 

m 

a 

PN 

ph 

in 

in 

PH 

© 

© 

o 

© 

O 

* 

» 

• 

« 

• 

• 

• 

• 


> 

o 

o 

o 

o 

o 

© 

© 

© 

o 

< 

1 

1 

1 






1 

J 










< 

r- 

VO 

pn 


vo 

PH 

eo 

© 

PN 

H 

in 

ph 


V 

r* 

»-H 

in 

03 

in 

O 

VO 

VO 

03 

■er 

PH 

O' 

03 

CO 

r> 

H 

*«r 

vo 

o 

03 

VO 

VO 

PN 

03 

■3 

»"> 

• 

• 


• 



• 



m 

ph 

PH 


PN 

PH 

tr 

PH 

PH 


o 











TT 

CO 

vo 

PH 

PN 

«H 

O' 

eo 

o 

o 

r- 

03 

H 

O 

VO 

IN 

CD 

PN 

vo 

< 

PN 

vo 

»“< 

r- 

PH 

O 

in 

CD 

PN 

H 

P' 

03 


03 

r- 



«D 

eo 

O 




• 






H 

■NT 


m 

PH 


in 



in 



03 


NT 

^4 

O' 

PH 

VO 

© 

* 

O' 

|N 

CO 

O' 

03 

o 

vo 

PN 

v 

Z 

r* 

03 

r* 

o 

PH 


eo 

o 

PH 

< 

o 

PH 


VO 

VO 

vo 

PH 

PH 

TT 

J 










a 

PN 

IN 

PH 


PN 

PH 

pH 

PN 

PH 


r-* 

o 


VO 

O' 

© 

VO 

© 

o 

u 

r- 

PN 

r* 

IN 

r» 

— 

PN 



u 

ph 

«-P 

PN 

o 

O' 

O' 

O 

eo 

© 

< 

r* 

03 


PH 

PH 

o 

(H 


o 

c 










CD 

PH 

«h 


PN 

IN 

PH 

PN 

PN 

PH 

to 










H 

© 

er 

V 

•O 

r- 

m 

eo 

in 

r» 

c 

TT 

o 

VO 


in 

© 

pH 


© 

U’ 

eo 

O' 

PN 

O' 

O' 

•H 

O' 

v 

■o 

r 

*T 


in 

r- 

O' 

PN 

r- 

o 

«-4 

r 










o 

PN 

IN 

PH 

H 

PN 

H* 


PH 


u 










J 










u 

in 

CO 

eo 

.-H 

PH 

O' 

VO 

er 

PN 

u 

ph 

»-t 

O 

00 


TT 

r* 

O' 

PH 

o 

to 

O' 

PH 

in 

O' 

-H 

PH 

VO 

CO 

z 

m 

CD 

*T 

»N 

© 

PN 

VO 

PH 

PN 

o 










z 

ph 

PH 

rr 

PH 


m 

PH 

V 

m 



VO 

r* 

CD 

PN 

© 

eo 

vo 

in 

J 

00 

PN 

in 

~-4 

r- 

in 

•-p 

PN 

m 

u 

o 

r* 

O' 

O' 

O' 

o 

O' 

o 

PH 

to 

n* 

r* 

O' 

r~~ 

,-4 

O' 

r~ 

PH 

r-4 

O 











PN 

PN 

PN 


PN 

IN 


IN 

PH 

to 


CO 

PH 

vo 

VO 

CD 

o 

in 

O 

D 

ph 

flO 

r~~ 

r- 

«0 

in 

PN 

© 

VO 

O 

■NT 

•-« 

PN 

PH 

CD 

o 

*-4 

© 

in 

U 

•H 


© 

vo 

rr 

VO 

O' 

r> 

VC 

o 










•-J 

*r 

*e- 


PH 

*T 

in 

PH 


m 


V) 

c 

O 


^fNpH^invor**eo© 


















VITA 


William R. Torres 
Candidate for the Degree of 
Master of Science 


Thesis: THE EFFECT OF SOFTWARE REUSABILITY ON INFORMATION 

THEORY BASED SOFTWARE METRICS 

Major Field: Computing and Information Science 

Biographical: 

Personal Data: Born in San Juan, Puerto Rico, December 
27, 1962, the son of William R. and Nelida Torres. 
Married to Maria A. Torres and father of Maria C. 
and Diana B. Torres. 

Education: Graduated from Our Lady of Pilar High 

School, Rio Piedras, Puerto Rico, in May 1980; 
received Bachelor of Science Degree in Electrical 
Engineering from University of Puerto Rico at 
Mayaguez in May 1985; completed requirements for 
the Master of Science degree at Oklahoma State 
University in July 1990. 

Professional Experience: Teaching Assistant, 

Department of Electrical Engineering, University 
of Puerto Rico at Mayaguez, August 1984, to 
December 1984. Physical Security Systems 
Engineer, Tinker Air Force Base (AFB) Oklahoma, 
June 1985, to July 1987. Local Area Network 
Design Engineer, Tinker AFB Oklahoma, July 1987, 
to August 1988. Branch Chief, Communications 
Support Branch, Wright Patterson AFB Ohio, January 
1990, to present. 








BIBLIOGRAPHY 


(ADAS3] Reference Manual for the Ada Programming Language , 
United States Department of Defense, ANSI/MIL-STD-1815A, 
January 1983. 

[ALEXA64] Alexander, Christopher, Notes on the Synthesis of 
Form, Harvard University Press, Cambridge, Mass., 1964. 

[BIGGE87] Biggerstaff, Ted and Richter, Charles, "Reusability: 
Framework, Assessment, and Directions," IEEE Software . March 
1987, pp. 41-49. 

[BOOCH86] Booch, Grady, Software Engineering with Ada . The 
Benjamin/Cummings Publishing Company Inc., Second Edition, 
1986. 

[CHAN073] Chanon, Robert N., "On a Measure of Program 
Structure," Ph.D. Dissertation, Department of Computer 
Sciences, Carnegie-Mellon University, Pittsburgh, PA, November 
1973. 

[CHEAT83] Cheatham, Jr., T. E., "Reusability Through Program 
Transformations," Proceedings ITT Workshop on Reusability in 
Programming . September 7-9, 1983, pp. 122-128. 

[CHEN78] Chen, Edward T., "Program Complexity and Programmer 
Productivity," IEEE Transactions on Software Engineering . Vol. 
SE-4, No. 3, May 1978, pp. 187-194. 

[CHENG84] Cheng, Thomas T., Lock, Evan D. , and Prywes, Noah S. 
"Use of Very High Level Languages and Program Generation by 
Management Professionals," IEEE Transactions on Software 
Engineering . Vol. SE-10, No. 5, September 1984, pp. 552-563. 

[CONTE86] Conte, S. D., Dunsmore, H. E., and Shen, V. Y., 

Software Engineering Metrics and Models . The Benjamin/Cummings 
Publishing Co., Inc., Menlo Park, CA, 1986. 

(GOGUE86I Goguen, Joseph A., "Reusing and Interconnecting 
Software Components," IEEE Computer , Vol. 19, February 1986, 

pp. 16-28. 

(HALST79] Halstead, M. H., "Advances in Software Science," 

Advances in Computers . (Yovits, ed.), Vol. 18, Academic Press, 
New York, 1979, pp. 119-172. 

[HARTM66] Hartmanis, J. and Stearns, R. E., Algebraic Structure 
Theory of Sequential Machines . Prentice-Hall, Inc., Englewood 
Cliffs, NJ, 1966. 

[KAISE87] Kaiser, Gail E. and Garlan, David, "Systems from 

Reusable Building Blocks," IEEE Software . July 1987, pp. 17-24 









[KERNI781 Kernighan, Brian W. and Ritchie, Dennis M., The C 
Programming Language . Prentice-Hall, Englewood Cliffs, NJ, 

1978. 

[KERNI84] Kernighan, Brian W. , "The UNIX System and Software 
Reusability," IEEE Transactions on Software Engineering . Vol. 
SE-10, No. 5, September 1984, pp. 513-518. 

[LETOV86] Letovsky, Stanley and Soloway, Elliot, "Delocalized 
Plans and Program Comprehension," IEEE Computer . May 1986, pp. 
41-49. 

[LUBAR86a] Lubars, Mitchell D., "Code Reusability in the Large 
Versus Code Reusability in the Small," ACM SIGSOFT Software 
Engineering Notes . Vol. 11, No. 1, January 1986, pp. 21-27. 

[LUBAR86b] Lubars, Mitchell D., "Affording Higher Reliability 
Through Software Reusability," ACM SIGSOFT Software Engineering 
Notes , Vol. 11, No. 5, October 1986, pp. 39-42. 

[MATSU84] Matsumoto, Yoshihiro, "Some Experiences in Promoting 
Reusable Software: Presentation in Higher Abstract Levels," 

IEEE Transactions on Software Engineering . Vol. SE-10, No. 5, 
September 1984, pp. 502-513. 

[MCCAB76] McCabe, J., "A Complexity Measure," IEEE Transactions 
on Software Engineering . Vol. SE-2, No. 4, December 1976, pp. 
308-320. 

[MILLE87] Miller, Webb, A Software Tools Sampler . Prentice-Hall, 
Inc., Englewood Cliffs, NJ, 1987. 

(MOHAN81] Mohanty, Siba N., "Entropy Metrics for Software Design 
Evaluation," The Journal of Systems and Software 2 . 1981, pp. 
39-46. 

[MOHNK86] Mohnkern, Gerald L. and Mohnkern, Beverly, Applied 
Ada . Tab Professional and Reference Books, 1986. 

[PRIET87] Prieto-Diaz, Ruben and Freeman, Peter, "Classifying 
Software for Reusability," IEEE Software . January 1987, pp. 
6-16. 

[SAS85a] SAS User's Guide: Basics. Version 5 Edition . SAS 
Institute Inc., Box 8000, Cary, NC 27511, 1985. 

[SAS85b] SAS User's Guide: Statistics. Version 5 Edition . SAS 
Institute Inc., Box 8000, Cary, NC 27511, 1985. 

[SCHIL87] Schildt, Herbert, Advanced Turbo C . Osborne McGraw- 
Hill, New York, NY, 1987. 







[SCHUT77] Schiitt, Dieter, "On a Hypergraph Oriented Measure for 
Applied Computer Science," Proceedings of COMPCON . Washington, 
D.C., Fall 1977, pp. 295-296. 

[SHANN64] Shannon, Claude E. and Weaver, Warren, The 
Mathematical Theory of Communication . The University of 
Illinois Press, Urbana, Ill., 1964. 

[SHOOM83] Shooman, Martin L., Software Engineering: Design . 
Reliability, and Management . McGraw-Hill Book Company, New 
York, 1983. 

[SHUMA89] Shumate, Ken, Understanding Ada with Abstract Data 
Types . John Wiley and Sons, Inc., New York, NY, Second Edition, 
1989. 

[SOMME89] Sommerville, Ian, Software Engineering . Addison-Wesley 
Publishing Co., Third Edition, 1989. 

[STEVE74] Stevens, W. P., Myers, G. J., and Constantine, L. L., 
"Structured Design," IBM Systems Journal . Vol. 2, 1974, pp. 
115-139. 

[TRACZ88] Tracz, Will, "Software Reuse Maxims," ACM SIGSOFT 
Software Engineering Notes . Vol. 11, No. 5, October 1988, pp. 
28-31. 

(VANEM70] van Emden, M. H. , "Hierarchical Decomposition of 
Complexity," Machine Intelligence 5 . 1970, pp. 361-380. 






