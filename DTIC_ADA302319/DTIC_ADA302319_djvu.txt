Special Report 
CMU/SEI-95-SR-018 



Carnegie-Mellon University 

Software Engineering Institute 


Information Technology -- Programming Language ~ The SQL Ada Module 
Description Language (SAMeDL) 





Special Report 

CMU/SEI-95-SR-018 

October 1995 


Information Technology -- Programming Language -- The SQL Ada Module 

Description Language (SAMeDL) 



ISO/IEC 12227 


Approved for public release. 
Distribution unlimited. 


Software Engineering Institute 

Carnegie Mellon University 
Pittsburgh, Pennsylvania 15213 


This report was prepared for the 

SEI Joint Program Office 
HQ ESC/ENS 
5 Eglin Street 

Hanscom AFB, MA 01731-2116 

The ideas and findings in this report should not be construed as an official DoD 
position. It is published in the interest of scientific and technical information exchange. 

Review and Approval 

This report has been reviewed and is approved for publication. 


FOR THE COMMANDER 



Thomas R. Miller, Lt. Col., USAF 
SEI Joint Program Office 


This work is sponsored by the U.S. Department of Defense. 

Copyright © 1995 by Carnegie Mellon University 

This work was created in the performance of Federal government Contract Number F19628-95- 
C-0003 with Carnegie Mellon University for the operation of the Software Engineering 
Institute, a Federally Funded Research and Development Center. The Government of the 
United States has a royalty-free government purpose license to use, duplicate, or disclose the 
work, in whole or part and in any marmer, and to have or permit others to do so, for goverrunent 
purposes. 

This material may be reproduced by or for the U.S. Government pursuant to the copyright 
license under the clause at 52.227-7013. 


This document is available through Research Access, Inc., 800 Vinial Street, Pittsburgh PA 
15212: Phone: 1-800-685-6510. FAX: (412) 321-2994. 


Copies of this document are available through the National Technical Information Service 
(NTIS). For information on ordering, please contact NTIS directly: National Technical 
Information Service, U.S. Department of Commerce, Springfield, VA 22161. Phone: (703) 487- 


This document is also available through the Defense Technical Information Center (DUC). 
DUC provides access to and transfer of scientific and technical information for DoD persoimel, 
DoD contractors and potential contractors, and other U.S. Government agency personnel and 
their contractors. To obtain a copy, please contact DTIC directly: Defense Technical 
Information Center, Attn: DTIC-OCP, 8725 John J. Kingman Road, Suite 0944, Ft. Belvoir, VA 
22060-6218. Phone: (703) 767-8019/8021/8022/8023. Fax: 703-767-8032/DSN-427. 

Use of any trademarks in this report is not intended in any way to infringe on the rights of the 
trademark holder. ^ 


VERSION 2 


Contents 


Foreword v 

Introduction vi 

1 Scope 1 

2 Normative References 1 

3 Notations and Structures 2 

3.1 Syntax Notation 2 

3.2 Semantic Notation 2 

3.3 Structure 2 

3.4 Examples, Notes and Index Entries 3 

4 Design Goals and Language Summary 4 

4.1 Design Goals 4 

4.2 Language Summary 4 

4.2.1 Overview 4 

4.2.2 Compilation Units 5 

4.2.3 Modules 5 

4.2.4 Procedures and Cursors 5 

4.2.5 Domain and Base Domain Declarations 6 

4.2.6 Other Declarations 6 

4.2.7 Value Expressions, Atomic Predicates and Typing 6 

4.2.8 Static Typing, Dynamic Schema Definition and Dynamic SQL. 7 

4.2.9 Standard Post Processing 7 

4.2.10 Extensions 7 

4.2.11 Default Values in Grammar 7 


5 Lexical Elements 

5.1 Character Set 

5.2 Lexical Elements, Separators, and Delimiters 

5.3 Identifiers 

5.4 Literals and Data Classes 

5.5 Comments 

5.6 Reserved Words 

6 Common Elements 

6.1 Compilation Units 

6.2 Context Clause 

6.3 References 

6.4 Domain Compatibility 

6.5 Standard Post Processing 

6.6 Extensions 



Database Programming Language - SAMeDL 


I 






VERSION 2 


7 Data Description Language and Data Semantics 

19 

7.1 

Definitional Modules 

19 


7.1.1 Base Domain Declarations 

20 


7.1.1.1 Base Domain Parameters 

20 


7.1.1.2 Base Domain Patterns 

21 


7.1.1.3 Base Domain Options 

22 


7.1.2 The SAME Standard Base Domains 

23 


7.1.3 Domain and Subdomain Declarations 

24 


7.1.4 Constant Declarations 

27 


7.1.5 Record Declarations 

29 


7.1.6 Enumeration Declarations 

30 


7.1.7 Exception Declarations 

31 


7.1.8 Status Map Declarations 

32 

7.2 

Schema Modules 

33 

7.3 

Data Conversions 

36 

8 Abstract Module Description Language 

37 

8.1 

Abstract Modules 

37 

8.2 

Procedures 

38 

8.3 

Non cursor data statements 

42 

8.4 

Cursor Declarations 

44 

8.5 

Cursor Procedures 

48 

8.6 

Input Parameter Lists 

51 

8.7 

Select Parameter Lists 

53 

8.8 

Insert Column Lists and Insert Value Lists 

55 

8.9 

lnto_Clause and lnsert_From_Clause 

57 

8.10 

Value Expressions 

59 

8.11 

Search Conditions 

62 

8.12 

Status Clauses 

62 

9 Conformance 

63 

9.1 

Introduction 

63 

9.2 

Claims of Conformance 

63 


9.2.1 Introduction 

63 


9.2.2 Conformance via mapping. 

63 


9.2.2.1 Conformance via SQL module. 

63 


9.2.2.2 Conformance via embedded SQL Syntax. 

64 


9.2.3 Conformance via effects. 

64 


9.2.4 Multiple claims of conformance. 

64 

9.3 

Extensions 

64 

Annex A SAMeDL_Standard 

65 

Annex B SAMeDL_System 

76 

Annex C Standard Support Operations and Specifications 

77 

C.1 Standard Base Domain Operations 

77 

C.1.1 

All Domains 

77 

C.1.2 

Numeric Domains 

78 


Database Programming Language - SAMeDL 


VERSION 2 


C.1.3 Int and Smallint Domains 78 

C.1.4 Character Domains 79 

C.1.5 Enumeration Domains 79 

C.1.6 Boolean Functions 80 

C.1.7 Operations Available to the Application 80 

C.2 Standard Support Package Specifications 82 

C.2.1 Interfaces.SQL 82 

C.2.2 SQL_Boolean_Pkg 82 

C.2.3 SQL_lnt_Pkg 83 

C.2.4 SQL_Smallint_Pkg 85 

C.2.5 SQL_ReaLPkg 87 

C.2.6 SQL_Double_Precision_Pkg 89 

C.2.7 SQL_Char_Pkg 91 

C.2.8 SQL_VarChar_Pkg 94 

C.2.9 SQL_Bit_Pkg 97 

C.2.10 SQL_Enumeration_Pkg 99 

Annex D Transform Chart 101 

Annex E Glossary 104 

Index 107 


Database Programming Language - SAMeDL iii 



VERSION 2 


Database Programming Language - SAMeDL 


VERSION 2 


Foreword 

ISO (the International Organization for Standardization) is a worldwide federation of national standards bod¬ 
ies (ISO member bodies). The work of preparing International Standards is normally carried out through ISO 
technical committees. Each member body interested in a subject for which a technical committee has been 
established has the right to be represented on that committee. International organizations, governmental 
and non-governmental, in liaison with ISO, also take part in the work. ISO collaborates closely with the In¬ 
ternational Electrotechnical Commission (lEC) on all matters of electrotechnical standardization. 

Draft International Standards adopted by the technical committees are circulated to the member bodies for 
approval before their acceptance as International Standards by the ISO Council. They are approved in ac¬ 
cordance with ISO procedures requiring at least 75% approval by the member bodies voting. 

International Standard ISO/IEC 12227:1994, Database Programming Language — The SQL Ada Module 
Description Language SAMeDL, was prepared by Joint Technical Committee ISO/IEC JTC1, Information 
Processing Systems. 

This International Standard contains six annexes of which three are normative and three informative: 

- Annex A (normative): SAMeDL_Standard 

- Annex B (normative): SAMeDL_System 

- Annex C (normative): Standard Base Domain Operations and Specifications 

- Annex D (informative): Transform Chart 

- Annex E (informative): Glossary 

- Annex F (informative): Bibliography 


V 



ISO/IEC 12227:1994 (E) 


Introduction 


The organization of this International Standard is as follows: 

1. Clause 1, “Scope,” specifies the scope of this International Standard. 

2. Clause 2, “Normative References,” identifies additional International Standards that, through 
reference in this International Standard constitute provisions of this International Standard. 

3. Clause 3, “Notations and Structures,” describes the syntax notation used in and the structure 
of the clauses of this International Standard. 

4. Clause 4, “Design Goals and Language Summary,” presents an overview of the SQL Ada Mod¬ 
ule Description Language. 

5. Clause 5, “Lexical Elements,” defines the lexical elements of the language. 

6. Clause 6, “Common Elements,” defines concepts and syntactic categories which are used in 
the definition of further concepts and syntactic categories of the language. 

7. Clause 7, “Data Description Language and Data Semantics,” defines that portion of the SQL 
Ada Module Description Language in which database description and other declarative items 
are encoded. 

8. Clause 8, “Abstract Module Description Language,” defines that portion of the SQL Ada Module 
Description Language in which database manipulation procedures are encoded. 

9. Clause 9, “Conformance,” defines conformance criteria. 

10. Annex A, “SAMeDL_Standard,” is a normative Annex containing the text of the predefined 
SAMeDL Definition Module SAMeDL_Standard. 

11. Annex B, “SAMeDL_System,” is a normative Annex containing the text of the predefined SAM¬ 
eDL Definition Module SAMeDL_System. Portions of this module are implementation defined. 

12. Annex C, “Standard Support Package Specifications,” is a normative Annex containing Ada text 
declaring the standard support packages. 

13. Annex D, ‘Transform Chart,” is an informative annex giving in a tabular form a description of 
string-to-string transformation functions used in the definition of the SAMeDL. 

14. Annex E, “Glossary,” is an informative annex giving explanations of terms used in this Interna¬ 
tional Standard. 

15. Annex F is a Bibliography. 

This International Standard is based on and defined with respect to the International Standards for Data¬ 
base Language SQL, ISO 9075:1992 and Programming Language Ada, ISO 8652:1987 (endorsement by 

ISO of ANSI/MIL-STD-1815A-1983 and AFNOR NF Z 65-700). 


vi Database Programming Language - SAMeDL 



ISO/IEC 12227:1994 (E) 



ISO/lEC 12227:1994 (E) 


viii Database Programming Language - SAMeDL 


INTERNATIONAL STANDARD 


ISO/IEC 1227:1994 (E) 


SQL/Ada Module Description Language SAMeDL 

1 Scope 

This International Standard specifies the syntax and semantics of a database programming language, the 
SQL Ada Module Description Language, SAMeDL. Texts written in the SAMeDL describe database inter¬ 
actions which are to be performed by database management systems (DBMS) implementing Database 
Language SQL. The interactions so described and so implemented are to be performed on behalf of appli¬ 
cation programs written in Programming Language Ada. 

The SAMeDL is not a Programming Language; it may be used solely to specify application program data¬ 
base interactions and solely when those interactions are to occur between an Ada application program and 
an SQL DBMS. 

The SAMeDL is defined with respect to Entry Level SQL. Therefore, all inclusions by reference of text from 
ISO/IEC 9075:1992 include all applicable Leveling Rules for Entry Level SQL. 

This International Standard does not define the Programming Language Ada nor the Database Language 
SQL. Therefore, ISO/IEC 8652:1995 takes precedence in all matters dealing with the syntax and semantics 
of any Ada construct contained, referred or described within this International Standard; similarly, ISO/IEC 
9075:1992 takes precedence In all matters dealing with the syntax and semantics of any SQL construct con¬ 
tained, referred or described within this International Standard. 

Note: The SAMeDL is an example of an Abstract Modular Interface. A reference model for programming 
language interfaces to database management systems, which includes a description of Abstract Modular 
interfaces, can be found in reference [2]. 

2 Normative References 

The following International Standards contain provisions which, through reference in this text, constitute 
provisions of this International Standard. At the time of publication, the editions indicated were valid. All In¬ 
ternational Standards are subject to revision, and parties to agreements based on this International Stan¬ 
dard are encouraged to investigate the possibility of applying the most recent editions of the International 
Standards indicated below. Members of lEC and ISO maintain registers of currently valid International Stan¬ 
dards. 

- ISO/IEC 9075:1992, Information technology - Database languages - SQL 

- ISO/IEC 8652:1995, Information technology -- Programming languages — Ada 


Scope 1 



VERSION 2 


3 Notations and Structures 

3.1 Syntax Notation 

The context-free syntax of the language is described using a simple variant of the variant of BNF used in 

the description of Ada, (1.5 in ISO/IEC 8652:1995). The variation is: 

- Underscores are preserved when using the name of a syntactic category outside of a syntax 
rule (1.5(6) of ISO/IEC 8652:1995). 

- The italicized prefixes Ada and SQL, when appearing in the names of syntactic categories, in¬ 
dicate that an Ada or SQL syntactic category has been incorporated into this document. For 
example, the category Ada_identifier is identical to the category identifier as described in 2.3 of 
ISO/IEC 8652:1995; whereas the category SOLJdentifier is identical to the category identifier 
as described in 5.4 of ISO/IEC 9075:1992. 

- Numerical suffixes attached to the names of syntactic categories are used to distinguish ap¬ 
pearances of the category within a rule or set of rules. An example of this usage is given below. 

3.2 Semantic Notation 

The meaning of a SAMeDL compilation unit (except where specified as implementation-defined) is given by: 

- An Ada compilation unit, conforming to ISO/IEC 8652:1995. 

- A module conforming to the SQL standard as given by clause 12 of ISO/IEC 9075:1992. 

- Interface rules, concerning the relationship between the SQL and Ada texts. 


The semantics of SAMeDL constructs are given in part by collections of string transformers that produce 
Ada and SQL texts from SAMeDL input. 

Note: A quick reference to these transformers appears in Annex D. 

The effects of these transformers are described through the use of sample input strings. Those strings are 
written in a variant of the syntax notation. For example, the syntax of an input_parameter (see 8.6) is given 
by: 


identifier_l [named_phrase] : doinain_reference [not null] 

A representative input parameter declaration is given by 
Id_l [named Id_2] : ld_3 [not null] 

It is then possible to discuss the four variants of input parameters (the variants described by the presence 
or absence of optional phrases) in a single piece of text. 

3.3 Structure 

The remainder of this International Standard is structured in the following way. Clause 4 contains a descrip¬ 
tive overview of the goals and concepts of the SAMeDL. Clause 5 defines the lexical structure of the SAM- 


2 Database Programming Language - SAMeDL 


VERSION 2 


eDL including the rules for identifier and literal formation and the list of reserved words. Clauses 6, 7 and 8 
define the syntax and semantics of the SAMeDL. Each subclause of those clauses adheres to the following 
general format. 

- The purpose of the item being defined by the subclause is introduced. 

- The syntax of the item being defined is given in the notation described earlier. 

- Abstract (non-context free) syntactical rules governing formation of instances of the item being 
defined are given, if applicable. 

- The semantics of the item being defined are given. These semantics are given under the head¬ 
ings Ada Semantics, SQL Semantics and interface Semantics, as appropriate. 

3.4 Examples, Notes and Index Entries 

Many of the subclauses of this International Standard are illustrated with examples. These examples are 
Introduced by the words: “Note: Examples” on a line by themselves and are terminated by the words “End 
Examples,” likewise appearing on a line by themselves. 

This is an example of an example. 

other notes also appear in this Standard, introduced by the word Note. Both kinds of note are informative 
only and do not form part of the standard definition of the SAMeDL. 

Items in the grammar that contain underscores are represented in the Index by a corresponding entry with¬ 
out underscores. For example, the "Ada identifier" entry in the index contains the page numbers of occur¬ 
rences of both “Adajdentifier" and "Ada identifier". 


Notations and Structures 3 


VERSION 2 


4 Design Goals and Language Summary 

4.1 Design Goals 

The SQL Ada Module Description Language (SAMeDL) is a Database Programming Language designed 
to automate the construction of software conformant to the SQL Ada Module Extensions (SAME) application 
architecture. This architecture is described in the document, Guidelines for the Use of the SAME[^]. 

The SAME is a modu/ararchitecture. It uses the concept of a Module as defined in 4.16 and 12 of ISO/IEC 
9075:1992. As a consequence, a SAME-conformant Ada application does not contain embedded SQL 
statements and is not an embedded SQL Ada program as defined in 19.3 of ISQ/IEC 9075:1992. Such a 
SAME-conformant application treats SQL in the manner in which Ada treats all other languages: it imports 
complete functional modules, not language fragments. 

Modular architectures treat the interaction of the application program and the database as a design object. 
This results in a further isolation of the application program from details of the database design and imple¬ 
mentation and improves the potential for increased specialization of software development staff. 

Ada and SQL are vastly different languages: Ada is a Programming Language designed to express algo¬ 
rithms, while SQL is a Database Language designed to describe desired results. Text containing both Ada 
and SQL is therefore confusing and difficult to maintain. SAMeDL is a Database Programming Language 
designed to support the goals and exploit the capabilities of Ada with a language whose syntax and seman¬ 
tics is based firmly in SQL. Beyond modularity, the SAMeDL provides the application programmer the fol¬ 
lowing services: 

- An abstract treatment of null values. Using Ada typing facilities, a safe treatment of missing in¬ 
formation based on SQL is introduced into Ada database programming. The treatment is safe 
in that it prevents an application from mistaking missing information (null values) for present in¬ 
formation (non-null values). 

- Robust status code processing. SAMeDL’s Standard Post Processing provides a structured 
mechanism for the processing of SQL status parameters. 

- Strong typing. SAMeDL’s typing rules are based on the strong typing of Ada, not the permissive 
typing of SQL. 

- Extensibility. The SAMeDL supports a class of user extensions. Further, it controls, but does 
not restrict, implementation defined extensions. 

4.2 Language Summary 

4.2.1 Overview 

The SAMeDL is designed to facilitate the construction of Ada database applications that conform to the 
SAME architecture as described in [1]. The SAME method involves the use of an abstract interface, an ab¬ 
stract module, a concrete interface, and a concrete module. The abstract interface is a set of Ada package 
specifications containing the type and procedure declarations to be used by the Ada application program. 
The abstract module is a set of bodies for the abstract interface. These bodies are responsible for invoking 


4 Database Programming Language - SAMeDL 


VERSION 2 


the routines of the concrete interface, and converting between the Ada and the SQL data and error repre¬ 
sentations. The concrete interface is a set of Ada specifications that define the SQL procedures needed by 
the abstract module. The concrete module is a set of SQL procedures that implement the concrete interface. 

Within this International Standard, the concrete module of [1] is called an SQL module and its contents are 
given under the headings SQL Semantics within the clauses of this specification. The abstract modules of 
[1] are given under the heading Ada Semantics within the clauses of this specification. 

4.2.2 Compilation Units 

A compilation un/'f consists of one or more modules. A module may be either a definitional module contain¬ 
ing shared definitions, a schema module containing table, view, and privilege definitions, or an abstract 
module containing local definitions and procedure and cursor declarations. 

4.2.3 Modules 

A definitional module contains the definitions of base domains, domains, constants, records, enumerations, 
exceptions, and status maps. Definitions in definitional modules may be seen by other modules. 

A schema module contains definitions of tables, views, and privileges and other so-called schema or data 
definition language (DDL) constructs. These may appear within procedure declarations, in which case they 
become “executable DDL” and may be invoked from an Ada application. 

An abstract module defines (a portion of) an application’s interface to the database: it defines SQL services 
needed by an Ada application program. An abstract module may contain procedure declarations, cursor 
declarations, and definitions such as those that may appear in a definitional module. Definitions in an ab¬ 
stract module, however, may not be seen by other modules. Any SQL statement, including dynamic SQL 
statements and schema manipulation statements, but excluding schema definition statements, which are 
restricted to schema modules, may appear in abstract modules. 

4.2.4 Procedures and Cursors 

A procedure declaration defines a basic database operation. The declaration defines an Ada procedure 
declaration and a corresponding SQL procedure. A SAMeDL procedure consists of a single statement along 
with an optional input parameter list and an optional status clause. The input parameter list provides the 
mechanism for passing information to the database at runtime. A statement in a SAMeDL procedure may 
be any statement defined by SQL (see 12.5 of ISO/IEC 9075:1992) or an implementation-defined extended 
statement. Generally speaking, SAMeDL statements differ from SQL statements in that strongly typed value 
expressions and atomic predicates are used. See 4.2.7, below. 

In contrast to the language of ISO/IEC 9075:1992, the procedures that operate on cursors, procedures con¬ 
taining either an open, fetch, close, update positioned or delete positioned statement, are packaged with 
the declaration of the cursor upon which they operate, thereby improving readability. Further, if no proce¬ 
dure containing an open, fetch or close statement is explicitly given in a cursor declaration, the language 
provides such procedures implicitly, thereby improving writeability (ease of use). 


Design Goals and Language Summary 5 


VERSION 2 


4.2.5 Domain and Base Domain Declarations 

Objects in the language have an associated domain, which characterizes the set of values and applicable 
operations for that object. In this sense, a domain is similar to an Ada type. A SAMeDL domain is not an 
SQL domain. 

A base domain is a template for defining domains. A base domain declaration consists of a set of parame¬ 
ters, a set of patterns and a set of options. The parameters are used to supply information needed to declare 
a domain or subdomain derived from the base domain. Patterns contain templates for the generation of Ada 
code to support the domain in Ada applications. This code generally contains type declarations and package 
instantiations. Options contain information needed by the compiler. Parameters may be used in the patterns 
and options and their values may be referenced in other statements. 

Base domains are classified according to their associated data class. A data class is either integer, fixed, 
float, enumeration, or character. A numeric base domain has a data class of either integer, fixed, or float. 
An enumeration base domain has a data class of enumeration, and defines both an ordered set of distinct 
enumeration literals and a bijection between the enumeration literals and their associated database values. 
A character base domain has a data class of character. 

SQL provides for the storage of date and time information (“temporal data”) in its databases. It does not al¬ 
low this data to pass across the application program interface; the application must deal with temporal data 
as character strings and cast between the string and internal representations in the SQL statements. The 
SAMeDL supports temporal data as statement and as database data and the base domain facility recog¬ 
nizes that certain data can not appear at the interface. 

4.2.6 Other Declarations 

Certain SAMeDL declarations are provided as a convenience for the user. For example, constant declara¬ 
tions name and associate a domain with a static expression. Record declarations allow distinct procedures 
to share types. An exception declaration defines an Ada exception declaration with the same name. 

4.2.7 Value Expressions, Atomic Predicates and Typing 

Value expressions are formed and evaluated according to the rules of SQL, with the exception that the 
strong typing rules are based on those of Ada. In the typing rules of the SAMeDL, the domain acts as an 
Ada type in a system without user defined operations. Strong typing necessitates the introduction of domain 
conversions. The SQL cast operator is used. For compatibility with an earlier version of SAMeDL, a syntax 
resembling Ada type conversion is also provided. If that Ada-like syntax is nof used, the concrete syntax of 
value expressions as defined in this specification is identical to that of SQL except for the removal of the 
colon in parameter references. The abstract syntax is different, primarily in that it applies strong typing. Sim¬ 
ilarly, the concrete syntax of predicates is that of SQL but these predicates are strongly typed. 


6 Database Programming Language - SAMeDL 


VERSION 2 

4.2.8 Static Typing, Dynamic Schema Definition and Dynamic SQL. 

Following the principles of Ada, the SAMeDL is statically typed. SQL, in contrast, allows for run time modi¬ 
fication of its set of data definitions, the schema. Schema modules may contain declarations of tables or 
views that anticipate the state of the SQL schema at run time, rather than the state of the SQL schema at 
the time at which the schema module is written or compiled. 

Dynamic SQL statements take parameters whose types may not be known untii run time. It is the program¬ 
mer’s responsibility to provide parameters of the correct types. The SAMeDL presents this paradigm directly 
to the Ada programmer. 

4.2.9 Standard Post Processing 

Standard post processing is performed after the execution of an SQL procedure but before control is re¬ 
turned to the calling appiication procedure. The status clauseimm a SAMeDL procedure declaration attach¬ 
es a status mapping to the application procedure. That status mapping is used to process SQL status data 
in a uniform way for all procedures and to present SQL status codes to the application in an application- 
defined manner, either as a value of an enumerated type, or as a user defined exception. SQL status codes 
not specified by the status map result in a call to a standard database error processing procedure and the 
raising of the predefined SAMeDL exception, SQL_Database_Error. This prevents a database error from 
being ignored by the application. 

4.2.10 Extensions 

The data semantics of the SAMeDL may be extended without modification to the language by the addition 
of user-defined base domains. For example, a user-defined base domain of DATE may be included without 
modification to the SAMeDL. 

DBMS specific (i.e., non-standard) operations may also be included into the SAMeDL. Such additions to the 
SAMeDL are referred to as extensions. Schema elements, table elements, statements, query expressions, 
query specifications, and cursor statements may be extended. The moduies, tables, views, cursors, and 
procedures that contain these extensions are marked (with the keyword extended) to indicate that they go 
outside the standard. 

4.2.11 Default Values in Grammar 

Qbvious but over-ridable defaults are provided in the grammar. For example, open, close, and fetch state¬ 
ments are essential for a cursor, but their form may be deduced from the cursor declaration. The SAMeDL 
will therefore supply the needed open, close, and fetch procedure declarations if they are not supplied by 
the user. 


Design Goals and Language Summary 7 




VERSION 2 


5 Lexical Elements 


The text of a compilation is a sequence of lexical elements, each composed of characters from the basic 
character set. The rules of composition are given in this chapter. 

5.1 Character Set 

The only characters allowed in the text of a compilation are the basic characters and the characters that 
make up character literals (described in 5.4 of this specification). Each character in the basic character set 
is represented by a graphical symbol. 

basic_character 

upper_case_letter lower_case_letter | digit | 
special_character space_character 

The characters included in each of the above categories of the basic characters are defined as follows: 

1. upper_case_letter 

ABCDEFGHIJKLMNOPQRSTUVWXYZ 

2. lower_case_letter 

abcdefghijkimnopqrstuvwxyz 

3. digit 

0123456789 

4. speciaLcharacter 

’()* + , - •/ ::< = >_i 

5. space_character 

5.2 Lexical Elements, Separators, and Delimiters 

The text of each compilation is a sequence of separate lexical elements. Each lexical element is either an 
identifier (which may be a reserved word), a literal, a comment, or a delimiter. The effect of a compilation 
depends only on the particular sequences of lexical elements excluding the comments, if any, as described 
in this chapter. Identifiers, literals, and comments are discussed in the following clauses. The remainder of 
this clause discusses delimiters and separators. 

An explicit separator is required to separate adjacent lexical elements when, without separation, interpreta¬ 
tion as a single lexical element is possible. A separator is any of a space character, a format effector, or the 
end of a line. A space character is a separator except within a comment or a character literal. Format effec¬ 
tors other than horizontal tabulation are always separators. Horizontal tabulation is a separator except with¬ 
in a comment. 

The end of a line is always a separator. The language does not define what causes the end of a line. 


One or more separators are allowed between any two adjacent lexical elements, before the first lexical el¬ 
ement of each compilation, or after the last lexical element of each compilation. At least one separator is 
required between an identifier or a numeric literal and an adjacent identifier or numeric literal. 


8 Database Programming Language - SAMeDL 


VERSION 2 


A delimiter is one of the following special characters 

or one of the following compound delimiters each composed of two adjacent special characters 
=> .. := <> >= <= 

Each of the special characters listed for single character delimiters is a single delimiter except if that char¬ 
acter is used as a character of a compound delimiter, a comment, or a literal. 

Each lexical element shall fit on one line, since the end of a line is a separator. The single quote and under¬ 
score characters, as well as two adjacent hyphens, are not delimiters, but may form part of other lexical el¬ 
ements. 

5.3 Identifiers 

identifier ::= S'01/_actual_identifier 

The length restrictions that apply to SQ/__identifiers (see 5.2, syntax rules 8, 9 and 5.4 syntax rule 3 of ISO/ 
lEC 9075:1992) do notapplyXo SAMeDL identifiers. Whenever two identifiers are deemed equivalent, it is 
in the sense of the rules of SQL (see 5.2, syntax rules 10 through 14 of ISO/IEC 9075:1992). 

Note. An SOi_actuaIJdentifier is either a dellmitedjdentifier or a regularjdentifier. The form of an SQL regular_identlfier 
is essentially the same as the Ada identifier, except that a regularjdentifier may end in an underscore. A delimitedJdentifier 
is any character string within a pair of double quote characters ("). Delimited identifiers provide a means of using tokens that 
would othenvise be reserved words (see 5.6 of this specification) as identifiers. Thus fetch is a reserved word, but the con¬ 
struct 

procedure "fetch'* is fetch; 
defines a procedure named "fetch" that contains a fetch statement. 

Identifier equivalence in SQL is similar to Ada identifier equivalence for regular identifiers. Equivalence for delimited identi¬ 
fiers is case sensitive. Equivalence of regular identifiers with delimited identifiers proceeds by considering the regular Iden¬ 
tifier to be all upper case and then doing a case sensitive comparison to the delimited identifier. So a column named Status 
is not identified by the delimited identifier "Status" but is Identified by the delimited identifier "STATUS", end Note 

Ada Semantics 

Let ident be an identifier. Define AdalD(ident) by 

AdalD(ident) = ident if ident is a regular identifier 

id if ident is the delimited identifier "id" 

Note: If ident is an identifier, AdalD(ident) is not necessarily an Acfajdentifier. 

SQL Semantics 

Let SQLna^/ie be a function on identifiers into the set of SQLJdentifiers with the property that SQL- 
name(I'^-I) SQLNAME(^‘i—2) Shall be equivalent if and only if ld_1 and ld_2 are equivalent (see 

above). 


Lexical Elements 9 



VERSION 2 


5.4 Literals and Data Classes 


Literals follow the SQL literal syntax (5.3 of ISO/IEC 9075:1992). There are eight classes into which literals 
are placed based on their lexical properties: character, bit, integer, fixed, float, date, time, timestamp, 
interval and enumeration. 

literal ::= 

database_literal | enumeration_literal 

database_literal ::= 

character_literal 
SQI/_b i t_.s t r i ng_l i t er a 1 
SQL_hex_s t ring_lit e ra1 
[+ I -] niiineric_literal 
SQL_date_literal 
ime_l i t er al 
imes t amp_l i t er al 
*^0-^_interval_literal 

n\iineric_literal : : = 

integer_literal | fixed_literal | float_literal 
character_literal :: ' {character} ' 
character implementation defined 

integer_literal digit (digit) 

fixed_literal 

integer_literal . integerjiteral 
I . integer_literal 

I integer_literal . 

float_literal ::= fixed_literal exp [+ | -] integer_literal 
exp ::= e | E 

enumeration_literal ::= identifier 

1. Each literal has an associated data class, denoted DATACLASS(Z.;. In particular: 
if L is a character_literal then DATACLASS(Z.) is character 


SQL_bit_string_literal 

bit 

SOL_hex_string_literal 

bit 

integer_literal 

integer 

fixed_literal 

fixed 

floatjiteral 

float 

SQL_date_literal 

date 

SQLjime_literal 

time 

SO/.Jimestamp_literal 

timestamp 

SQL_interval_literal 

intervai 

enumerationjiteral 

enumeration 


Literals of a temporal data class are called temporal literals, (see data_class in 7.1.1.1 of this 
specification). 

2. If Id is an enumeration literal, than AdalD(id) shall be an Acfajdentifier. In particular, an enu¬ 
meration literal shall not be an Ada character literal. 

3. The qualifier of an SQUntervaIJiteral, IL, denoted QUALIFIER(//.), is the value of it’s 
SQLJntervaLqualifier. See 5.3 and 10.1 of ISO/IEC 9075:1992. 

4. The single quote or “tic” character can be inciuded in a characterjiteral by duplication in the 
usual way. Thus the string of tics: " " represents a characterjiteral of length one containing 
the single quote as its only character. 


10 Database Programming Language - SAMeDL 


VERSION 2 


5.5 Comments 

A comment starts with two adjacent hyphens and extends up to the end of the line. A comment can appear 
on any line of a module. The presence or absence of comments has no influence on whether a module is 
legal or illegal. Furthermore, comments do not influence the meaning of a module; their sole purpose is the 
enlightenment of the human reader. 

5.6 Reserved Words 

The following is the list of the SAMeDL reserved words: 


ABSTRACT 

ALL 

AND 

ANY 

AS 

ASC 

AUTHORIZATION 

AVG 

BASE 

BETWEEN 

BODY 

BY 

CHECK 

CLASS 

CLOSE 

COMMIT 

CONSTANT 

CONVERSION 

COUNT 

CURRENT 

CURSOR 

DATA 

DBMS 

DECLARE 

DEFAULT 

DEFINITION 

DELETE 

DERIVED 

DESC 

DISTINCT 

DOMAIN 

END 

ENUMERATION 

ESCAPE 

EXISTS 

EXCEPTION 

EXTENDED 

FETCH 

FOR 

FOREIGN 

FROM 

GRANT 

GROUP 

HAVING 

IMAGE 

IN 

INSERT 

INTO 

IS 

KEY 

LIKE 

MAP 

MAX 

MIN 

MODULE 

NAME 

NAMED 

NEW 

NOT 

NULL 

OF 

ON 

OPEN 

OPTION 

OR 

ORDER 

OUT 

PATTERN 

POS 

PRIMARY 

PRIVILEGES 

PROCEDURE 

PUBLIC 

RAISE 

RECORD 

REFERENCES 

ROLLBACK 

SCALE 

SCHEMA 

SELECT 

SET 

SOME 

STATUS 

SUBDOMAIN 

SUM 

TABLE 

TO 

TYPE 

UNION 

UNIQUE 

UPDATE 

USE 

USER 

USES 

VALUES 

VIEW 

WHERE 

WITH 

WORK 





6 Common Elements 

6.1 Compilation Units 

A compilation unit is the smallest syntactic object that can be successfully compiled. It consists of a se¬ 
quence of one or more modules. 

compilation_unit ::= 
module {module} 

module ::= 

definitional_module | abstract_module | schema_module 


6.2 Context Clause 

The context clause is a means by which a module gains visibility to names defined in other modules. The 
syntax and semantics of context clauses are similar to the syntax and semantics of Ada context clauses 
(8.4,10.1.1 of ISO/IEC 8652:1995) but there are differences. 


Common Elements 11 



VERSION 2 


context ::= 

context_clause {context_clause} 
context_clause ::= 

with_clause | use_clause | with_scheina_clause 
with_clause 

with inodule_name [as_phrase] 

{, module_name [as_phrase]} ; 

use_clause ::= 

use inodule_naine {, module_naine} ; 

with_schema_clause ::= 

with schema scheina_inodule_name [as_phrase] 
schema_inodule_naine [as_phrase] } ; 

module_name 

identifier 

schema_module_naine :: = 
identifier 

as_phrase ::= 
as identifier 

1. Consider the following with_clause and with_schema_clause: 

with M [as N^]; 
with schema S [as N 2 ]; 

In these clauses, M shall be the name of a definitional module and S the name of a schema 
module. The name M of the definitional module is said to be exposed if the as_phrase is not 
present in the context_clause; otherwise the name M is hidden and the name N. is the exposed 
name of M. Similar comments apply to S and N 2 . The name of a module (see 7.1,7.2, and 8.1 
of this specification) is its exposed name within the text of that module. Within the text of any 
module, no two exposed module names shall be the same. 

2. A module_name in a use_clause shall be the exposed name of a definitionaLmodule that is an 
operand of a prior with_clause. 

3. The scope of a with_clause or use_clause in the context of a module (see 7.1,7.2, and 8.1 of 
this specification) is the text of that module. 

4. Only an abstract or schema module context may contain a with_schema_clause. 

Note: As a consequence of these definitions, abstract modules cannot be brought into the context of (withed by) another 
moduie. 


6.3 References 


The rules concerning the meaning of references are modeled on those of Ada and those of SQL. As neither 
module nesting nor program name overloading occurs, these rules are fairly simple, and are therefore listed. 
For the purposes of this clause, an item is either: 

- A definitional module (See 7.1), an abstract module (8.1), ora schema module (7.2 of this spec¬ 
ification). 

- A procedure (See 8.2), a cursor (8.4), or a procedure within a cursor (8.5 of this specification). 

- Anything in the syntactic category ‘definition’ as given by 7.1 of this specification. This includes 
base domains, domains, subdomains, enumerations, constants, records, and status maps. 

- A domain parameter (See 7.1.1.1 of this specification.) 


12 Database Programming Language - SAMeDL 






VERSION 2 


- An enumeration literal within an enumeration (See 5.4 and 7.1.6 of this specification). 

- An exception (7.1.7 of this specification). 

- An inpuLparameter of a procedure or cursor declaration (See 8.2, 8.4, and 8.6 of this specifi¬ 
cation). 

- A table or view defined within a schema module or a temporary table declared within an abstract 
module, (see 7.2 and 8.1 of this specification). 

- A column defined within a table (see 7.2 of this specification). 

A location within the text of a module is said to be a defining location if it is the place of 

- The name of an item within the item’s declaration. {Note: This includes enumeration literals 
within the declaration of an enumeration and domain parameters within the declaration of a do¬ 
main.) 

- The name of a table or view in an SQL_from_clause. For the definitions of exposed table name 
and the scope of a table name see 6.3 in ISO 9075:1992. 

- The name of the target table of an insert, update, or delete statement. 

- A schema_module_name or module_name in a context_clause. 

Text locations not within comments that are not defining locations are reference locations. An identifier that 
appears at a reference location is a reference to an item. The meaning of that reference in that location, that 
is, the identity of the item referenced, is defined by the rules of this clause. When these rules determine 
more than one meaning for an identifier, then all items referenced shall be enumeration literals. 

module_reference ::= identifier 

schema_inodule_reference schema_inodule_naine | identifier 

base_domain_reference : : = [itiodule_reference. ] identifier 

doinain_reference [module_reference.] identifier 

doinain_paraineter_reference : := domain_reference. identifier 

subdomain_reference [inodule_reference.] identifier 

enuineration_reference ::= [module_reference.]identifier 

enuineration_literal_reference ::= [module_reference.]identifier 

exception_reference ::= [inodule_reference.] identifier 

constant_reference ::= [module_reference.]identifier 

record_reference ::= [module_reference.]identifier 

procedure_reference :;= [module_reference.]identifier 

cursor_reference ::= [module^reference.]identifier 

cursor_proc_reference [cursor_reference.]identifier 

input_reference ::= [procedure_reference.]identifier 
I [cursor_proc_reference.]identifier 

status_reference [module_reference.]identifier 

table_name : := [scheina__inodule_reference. ] SQL_identifier 
I MODULE. 5(?L_identifier 

coluimi_name : := S01/_identif ier 


Common Elements 13 


VERSION 2 


coliJinn_reference ::= [qualifier .] coluiTin_name . 
qualifier : := table_naine 

I 5'QL_correlation_name 

Note: A table_name differs from an SQ/._table_name only in that a schema_module_reference replaces a schema name. 


A reference is a simple name (an identifier) optionally preceded by a prefix: a sequence of as many as three 
identifiers, separated by dots. 


For the purposes of this clause, the “text of a cursor” does not include the text of the procedures, if any, 
contained in the cursor. A dereferencing rule is said to “determine a denotation” for a reference if it either (i) 
specifies an item to which the reference refers, or (ii) determines that the reference is not valid. 

Note: Unlike the Ada dereferencing rules (see 8.2 and 8.3 in ISO/IEC 8652:1995), the SAMeDL rules treat the prefix as a 
whole, not component by component. 

Prefix Denotations 


The prefix of a reference shall denote one of the following; 

- An abstract module, procedure, cursor or cursor procedure, but only from within the text of the 
abstract module, procedure, cursor, or cursor procedure. 

- A table or view, if the table or view is in scope at the location in which the reference appears. 

- A domain. 

- A definitional or schema module. 


Note: As a consequence of the rule given eariier, that all meanings of an identifier with multiple meanings must be enumer¬ 
ation literals, a prefix may have at most one denotation or meaning, as it may not denote an enumeration literal. 


Let L be the reference location of prefix P. Let X, Y, and Zbe simple names. Then 

1. If L is within the text of a cursor procedure U, then P denotes 

a. The cursor procedure U if either 

1. P is of the form X and X is the simple name of U; or 

2. P is of the form X.Y, X is the name of the cursor containing L (and therefore also U)] in which 

case Y shall be the simple name of U else the prefix is not valid; or 

3. P is of the form X. Y.Z] A" is the name of the module containing L; yis the name of the cursor 
containing L (and therefore also U)] in which case Zshall be the simple name of Lfelse the 
prefix is not valid; 

b. The table Tbeing updated in a cursor_update_statement, if the statement within the cursor proce¬ 
dure containing L is a cursor_update_statement and either 

1. P is of the form X and X is the simple name of 7; or 

2. P is of the form X. Y, X is an exposed name for the schema module S containing the declara¬ 

tion of T and /is the simple name of T. 

2. If rule 1 does not determine a denotation for P, then P denotes 

a. The cursor or procedure P, if Lis within the text of P and either 

1. P is of the form X and A is the simple name of P; or 


14 Database Programming Language - SAMeDL 


VERSION 2 


2. P is of the form X. VI X is the name of the module containing L (and therefore also R); Y is the 
simple name of R; 

b. The table T (or view V), if P denotes the table T (or view V) according to 6.3 of ISO 9075:1992, 
unless P \s of the form X.V'and Xis not the keyword module, In which case Xis the exposed name 
of a schema module containing the table T and V'is the simple name of T. 

3. If rules 1 and 2 do not determine a denotation for P, then P denotes the domain R, 

a. If P is of the form X and X is the simple name of R and the declaration of R appears in the module 
containing L and precedes L within that module; or 

b. Pis of the form X. Y, Xis the exposed name of the module containing the declaration of Pand V'is 
the simple name of R. 

4. If none of the above rules determines a denotation for P, then P is a simple name that denotes 
the 

a. Definitional module M if either 

1. L is in the scope of a with_clause exposing Pas the name of M; or 

2. L is in the definitional module M and P is the name of M. 

b. Schema module S if either 

1. L is in the scope of a with_schema_clause exposing Pas the name of S; or 

2. L is in an abstract module whose authorization clause identifies S and P is the name of S; 

c. Abstract module M if L is within the text of M and P is the name of M; 

d. Domain D, if D is declared within a module N such that there is a use clause for N in the module 
containing L, and P is the name of D. 

Denotations of Full Names 


Let L be the location of a reference Id. Then Id is a reference to the item Im if Im is not a module, procedure, 
cursor or cursor procedure, or table and 

1. Id is of the form P.X where X is the name of Im and P is a prefix denoting 

a. A definitional module containing the declaration of Im] 

b. The abstract module, M, in which L appears, and Im is declared in Mat a text location that pre¬ 
cedes L] 

c. The procedure, cursor, or cursor procedure that contains L, and Im is an input parameter to that 
procedure, cursor, or cursor procedure; 

d. A table, in which case Im is a column within that table; 

e. A schema module, in which case Im Is a table within that module. 

f. A domain, in which case Im is a parameter in that domain. 

g. The keyword MODULE, in which case Im is the local table name of a temporary table. 

2. Id is of the form Xand X is the name of Im. Then 

a. L appears in a cursor, procedure, or cursor procedure. (See 8.4,8.2, and 8.5 of this specification) 
and 

1. Im is an input parameter to that cursor, procedure, or cursor procedure; 


Common Elements 15 



VERSION 2 


2. Im is a column of one of the tables in scope of L; 

b. If rule (a) does not determine a denotation for Id, then Im is 

c. declared in the module containing L at a location preceding L; 

d. If neither rule (a) nor (b) determines a denotation for Id, then Im is declared within a module M 
such that the module containing L has a use clause for M. 

Note: An item Im is visible at iocation L if there exists a name Id (either simple or preceded by a prefix) such that if Id were 
at location L, then Id would be a reference to Im. 


Note: Examples 

The following clause contains examples of the disambiguation of prefixes, with the applicable rule in a comment. At the point in Prod 
marked by Note1, the declaration of constant inp2 is hidden by the input parameter Inp2: that constant would have to be qualified by 
the prefix “Abmod” to be visible. At the point in Proc2 marked by Note2, if COL is the name of a column of visible table TABNAME, 
then that reference is ambiguous. A reference to the input parameter would have to be “Proc2.Cor’, while a reference to the table col¬ 
umn would have to be ‘TABNAME.COL”. Finally, Dom1 is visible at Note3 since Defmod is in both a with and use clause in Abmod. 
Without the use clause, the reference at Note3 would have to be to “Defmod.Dorn 1”. 

with SAMeDL_Standard; 
use SAMeDL_Standard; 

definition module Defmod is 
constant Newfirst is 0; 
constant Newlast is 999; 

domain Doml is new SQL_Int (First => Newfirst, 

Last => Defmod.Newlast); -- 4a(ii) 

end Defmod; 

with Defmod, SAMeDL_Standard; 
use Defmod, SAMeDL_Standard; 

with schema Snamel; 
abstract module Abmod is 
authorization Sname2 

constant Newfirst is 0; 

constant Inp2 : Doml is 1; -- Note3 

domain Dorn is new SQL_Int (First => Abmod.Newfirst, — 4c 

Last => Defmod.Newlast); -- 4a(i) 
declare local temporary table TEMTAB 
(COL : DOMl); 

procedure Proc (Inpl : Dorn; Inp2 : Dorn) is 
insert into TABNAME 

select Proc.Inpl, — 2a(i) 

Abmod.Proc.Inp2 -- 2a(ii) 
from TABNAME 

cursor Curse 
for 

select COL 

from Snamel.TAB -- 4b(i) 


rs 


procedure Prod (Inpl ; Dorn; Inp2 : Dorn; Inp3 : Dorn) is 
update Sname2.TABNAME — 4b(ii) 

set COLl = Prod. Inpl, -- la(i) 

COL2 = Curse. Prod. Inp2, — la(ii) 

COL3 = Abmod.Curse . Prod . Inp3 , — la(iii) 
TABNAME.COL4 = Inpl, -- 2b(i) 

Sname2.TABNAME.COL5 = Inp2 -- 2b(ii) : Notel 


end Curse; 

procedure Proc2 (Col : Dorn) is 
insert into TABNAME 

select COL -- Note2 

from TABNAME 


16 Database Programming Language - SAMeDL 


VERSION 2 


procedure Proc3 is 

insert into TABNAME 

select COL -- Note2 

from MODULE.TEMPTAB Ig 

cursor Cursel 
for 

select COL 

from Sname2 . TABNAME — 4b (i i) 

end Abmod; 

End Examples 


6.4 Domain Compatibility 


An expression E is compatible with a domain D if 

1. DOMAIN(E) ^ NO.DOMAIN then DOMAIN(E)=D; otherwise 

2. D is an enumeration domain and E evaluates to a literal of D; othenwise 

3. If DATACLASS(D) is not numeric, then DATACLASS(E) = DATACLASS{D) and if DATA- 
CLASS(D) is interval then QUALIFIER(D) = QUALIFIER(E). 

4. If DATACLASS(D) is numeric, either both of DATACLASS(E) and DATACLASS(D) are integer 
or neither is. 

Note: The rule concerning intervals reproduces the concept of comparability of temporal data types from ISO/I EC 
9075:1992. When used in a context requiring a domain, e.g., assignment to a column, a numeric literal conforms to the rule 
of Ada. 


A pair of expressions Ej and E^are said to be domain compatible 

1 . DOMAIN(Ej) NO_DOMAIN, implies E^ is compatible with DOMAIN(Ej); othenwise, 

2. D 0 MAIN(E 2 ) NO_DOMAIN, implies E-, is compatible with DOMAIN(E 2 ); otherwise, 

3. SQL\/£(Ei) and SOLvefEg^ are comparable as defined in ISO/IEC 9075:1992. 

Note: Any two numeric literals will be domain compatible, in contrast to the situation when one of the expressions has a do- 
main, as described above. 

See sections 7.1.3 and 8.10 of this specification. 


6.5 Standard Post Processing 

Standard post processing is the processing that is done after execution of an SQL procedure, but before 
control is returned to the calling application. That processing is described as follows: 

1. The SQL status parameter in an SQL procedure call is SQLSTATE unless a status clause ap¬ 
pears in the procedure declaration that references a status map specifying sqlcode, in which 
case the SQL status parameter is SQLCODE. See 7.1.8 and 8.12 of this specification. 

Note-. SQLSTATE is the preferred status parameter. SQLCODE is a deprecated feature of ISO/IEC 9075:1992. 

If a status map is attached to the procedure via a status clause (see 8.12 of this specification), 
then if the value of the status parameter appears in the left hand side of some status_assign- 
ment in that status map (possibly via the equivalences in 7.1.8 of this specification) then the 


Common Elements 17 



VERSION 2 


Ada procedure’s status parameter is set to the value of the right hand side of that status_as- 
signment, if that right hand side is an enumeration_literal; if that right hand side is a raise state¬ 
ment, then the named Ac/a_exception is raised. This is not considered an error condition in the 
sense of the next paragraph. In particular, SQL_Database_Error_Pkg.Process_- 
Database_Error is not called. 

2. If the value of the SQL status parameter does not appear in the left hand side of any status_as- 
slgnment in the map attached to the procedure orthere is no status map attached to the pro¬ 
cedure and the SQL status parameter indicates a condition other than successful completion, 
then an error condition exists. In this case the parameterless procedure SQL„Database_Er- 
ror_Pkg.Process„Database__Error is called. Upon return from that procedure, the exception 
SAMeDL_Standard.SQL_Database_Error is raised. 

Note: Successful completion is indicated by an SQLSTATE value of “00000” or an SQLCODE value of 0. In par¬ 
ticular, warning values, SQLSTATE values “01xxx” or positive SQLSTATE values other than 100, are not consid¬ 
ered to indicate successful completion in the sense of this paragraph. 


6.6 Extensions 

Extended tables, views, modules, procedures, and cursors allow for the inclusion into the SAMeDL of 
DBMS-specific, that is, non-standard, operations and features, while preserving the benefits of standardiza¬ 
tion. These DBMS-specific extensions may be verbs, such as connect and disconnect, that signal the be¬ 
ginning and end of program execution, or functions, such as date manipulation routines, that extract the 
month from a date. The use of extensions, particularly the extended keyword, serves to mark those mod¬ 
ules, tables, views, cursors, and procedures that go outside the standard and may require effort should the 
underlying DBMS be changed. 

extended_schenia_eleinent = 
implementation defined 

extended_table_element ::= 
implementation defined 

extended_statement ::= 
implementation defined 

extended_cursor_specification ::= 
implementation defined 

ext:ended_query_specif ication : : = 
implementation defined 

extended_cursor_statement ::= 
implementation defined 

Notice that the grammar is arranged such that extensions cannot influence the formation of 

- procedure names 

- cursor names 

- module names 

- table names 

- view names 

- status clauses, status parameter names and types, and standard post processing 


18 Database Programming Language - SAMeDL 



VERSION 2 


Although the syntax and semantics of extensions are implementation defined, any portion of an extension 
whose semantics is expressible in standard SAMeDL shall be expressed in standard SAMeDL syntax. An 
extension may expand the class of: 

- Value expressions by adding operators and functions. The operands of those operators and 
functions shall be restricted by rules similar to those in 6.4 and 8.10 of this specification. 

- Search conditions by adding atomic predicates. Operands of those atomic predicates shall like¬ 
wise be restricted according to rules such as those in 8.11 of this specification. 

- Input parameter lists by adding the mode out to the parameter declarations, according to the 
rules of 8.6 of this specification. 

- Table elements. If the extended table element is in the form of a column definition, the domain 
reference shall be present (see 7.2 of this specification). 

Similarly, database data returned from extended procedures and cursors shall be defined in the syntax and 
semantics of select parameter lists (8.7 of this specification) with the syntax and semantics of the extended 
value expression class replacing the standard syntax and semantics. Such outputs shall be record objects. 
An extended statement returning such data shall accept an into_clause as described in 8.9 of this specifi¬ 
cation for specifying the record parameter name and type. 

7 Data Description Language and Data Semantics 

7.1 Definitional Modules 


Definitional modules contain declarations of base domains, domains, subdomains, constants, records, enu¬ 
merations, exceptions, and status maps. An Ada library unit package declaration is defined for each defini¬ 
tional module. 

definitional_module ::= 

[context] 

[extended] definition module identifier^! is 
{definition} 
end [identifier_2]; 

definition 

base__domain_declaration | 

domain^declaration | subdoinain_declaration | 
constant_declaration | record_declaration | 
enuineration_declaration | exception_declaration | 
status_inap_declaration 

1. When present, identifier_2 shall be equivalent to identifier_1. (See 5.3 of this specification.) 

Notes: 

No with_schema_clause shall appear in the context of a definitional module. (See 6.2 of this specification.) 

No two declarations within a definitional module shall have the same name, except for enumeration literals (see 
7.1.6 of this specification). 

End Notes. 


Data Description Language and Data Semantics 19 



VERSION 2 


Ada Semantics 


For each definitional module within a compilation unit there is a corresponding Ada library unit package the 
name of which is the name of the definitional module, that is, AdalD(identifier_1). The Ada construct giving 
the Ada semantics of each definition within a definitional module is declared within the specification of that 
package. Nothing else appears in the specification of that package. 

7.1.1 Base Domain Declarations 

Base domains are the basis on which domains are defined. A base domain declaration has three parts: a 
sequence of parameters, used in domain declarations to supply information to the other two parts; a se¬ 
quence of patterns, used to produce Ada source code in support of a domain; and a sequence of options, 
used by the compiler in implementation-defined ways. 

base_domain_declaration 

[extended] base domain identifier_l 
[ (base_domain_paraineter_list) ] 
is 

patterns 

options 

end [identifier_2]; 

base_domain_paraineter_list = 

base_domain_parameter {; base domain pararaeter) 

1. If present, identifier_2 shall be equivalent to identifier_1. Identlfier_1 is the name of the base 
domain. 

2. The keyword extended may appear in a base_domain_declaration only if it also appears In the 
enclosing module declaration. 

7.1.1.1 Base Domain Parameters 

base_domain_paraineter :: = 

identifier : data_class [ := static_expression] 

I map := pos 

I map : = image 

data_class 

integer | fixed | float 
character | bit 

date I time | timestamp | interval 
enumeration 

1. The Ada identifiers within the list of base_domain_parameters of a base_domain_declaration 
are the names of the parameters that may appear in a parameter_association_list within a do- 
main_declaration based on this base domain (see 7.1.3 of this specification). The static_ex- 
pression within a base_domain_parameter, when present, specifies a default value for the pa¬ 
rameter. This default value shall be of the correct data_class; that is, in the parameter declara¬ 
tion 

Id : del := expr; 

where del is a data_class, DATACLASS(expr) shall be del. Further, DATACLASS(ld) is del, 
whether or not the initializing expression expr is present, and DOMAIN(ld) is NO_DOMAIN. 

2. A base domain is classified by its data_class. That is, an enumeration base domain is a base 
domain whose data_class is enumeration, a fixed base domain is a base domain whose 
data_class is fixed, etc. Integer, fixed and float base domains are collectivley known as numer¬ 
ic base domains; date, time, timestamp and interval base domains are collectivley known as 


20 Database Programming Language - SAMeDL 



VERSION 2 


temporal base domains. 

3. Every enumeration base domain has two predefined parameters: enumeration and map. 

These parameters are special in that the values that are assigned to them by a domain decla¬ 
ration (see 7.1.3 of this specification) are not of any of the data classes listed above. The value 
of an enumeration parameter is an enumeration_reference (see 6.3 of this specification); the 
value of map is a database_mapping (see 7.1.3 of this specification). A base domain declara¬ 
tion may explicitly declare a map parameter for the purpose of assigning a default mapping. An 
enumeration base domain shall not redefine the predefined base_domain_parameter enumer¬ 
ation. 

There are two possible default mappings: pos and image. The value pos specifies that the Ada 
predefined attribute function 'POS of the Ada type corresponding to the enumeration_refer- 
ence, which is the enumeration parameter value in the domain declaration, shall be used to 
translate enumeration literals to their database encodings. Similarly for image and the 'IMAGE 
attribute. See annex A of ISO/IEC 8652:1995 and 7.1.3 and 7.3 of this specification. 

Every enumeration base domain whose dbms type is char or character shall have a third pre¬ 
defined parameter, length whose value is an integer of an implementation defined range. Such 
an enumeration base domain shall not redefine the predefined base_domain_parameter 

length. 

4. Every fixed base domain has a predefined parameter scale whose value is an integer of an im¬ 
plementation defined range (see 6.1 of ISO/IEC 9075:1992). A fixed base domain shall not re¬ 
define the predefined base_domain_parameter scale. 

5. Every character and bit base domain has a predefined parameter length whose value is an in¬ 
teger of an implementation defined range (6.1 of ISO/IEC 9075:1992). No character nor bit 
base domain shall redefine the predefined base_domain_parameter length. 

6. Every interval base domain has a predefined parameter qualifier whose value shall be an SQL 
interval qualifier. See 10.1 of ISO/IEC 9075:1992 and 7.1.3 of this specification. No interval 
base domain shall redefined the predefined base_domain_parameter qualifier. 

7.1.1.2 Base Domain Patterns 

The patterns portion of a base domain declaration forms a template for the generation of Ada text, which 

forms the Ada semantics of domains based on the given base domain. 

patterns ::= {pattern} 

pattern ;:= 

domain_pattern | subdomain__pattern | derived_doinain_pattern 

domain^pattern ::= 

domain pattern Is pattern_list 
end pattern; 

subdoinain_pattern : : 

subdomain pattern is pattern_list 
end pattern; 

derived_domain_pattern ::= 

derived domain pattern is pattern_list 
end pattern; 

pattern_list ::= 

pattern_element (pattern_element} 

pattern^element character_literal 


Data Description Language and Data Semantics 21 



VERSION 2 


Patterns are used to create the Ada constructs that implement the Ada semantics of a domain, subdomain, 
or derived domain declaration (see 7.1.3 of this specification). Patterns are considered templates; parame¬ 
ters within a pattern are replaced by the values assigned to them either In the domain declaration, by inher¬ 
itance, or by default. See 7.1.3 of this specification. 

For a parameter to be recognized as such in a pattern, it is enclosed in square brackets ([,]). For the purpose 
of pattern substitution, a base domain may use a parameter self. When a pattern is instantiated, self is the 
result of applying the transformation AdalD to the name of the domain or subdomain being declared (see 

5.3 of this specification). A base domain may use a parameter parent for the purpose of pattern substitution 
in a subdomaln_pattern or a derived_domain_pattern. When such a pattern is instantiated, parent is AdalD 
applied to the name of the parent domain (see 5.3 and 7.1.3 of this specification). 

Within a given characterjiteral of a pattern, a substring contained in matching curly brackets ({,}) is an op¬ 
tional phrase. Optional phrases may be nested. An optional phrase appears in the instantiated template if 
all parameters within the phrase have values assigned by a domain declaration (see 7.1.3 of this specifica¬ 
tion); the phrase does not appear when none of the parameters within the phrase has an assigned value. If 
some but not all parameters within an optional phrase have values assigned by a given domain declaration, 
the declaration is in error. 

7.1.1.3 Base Domain Options 

options ::= {option} 

option fundamental! for word_list use pattern_list ; 

fundamental ::=classification_options j conversion_options 

clasification_options ::= 

for data class use data_class; 

for dbms type use dbms_type [pattern_list] ; 

[for interface type use inter_type;] 

conversion_options ::= 

for not null type name use pattern_list ; 

for null type name use pattern_list ; 

for conversion from type to type use converter ; 

dbms_type ::= 

int I integer | smallint 
real double precision 
char character | bit 

implementation defined 

inter_type ::= dbms | none j dbms_type 

type ::= dbms j not null | null 

converter ::= function pattern_list j type mark 

word_list ::= implementation defined 

Options are used to define aspects of base domains that are essentiai to the declaration of domains within 
the SAMeDL. Implementations may define options beyond the fundamental options. The classification op¬ 
tions are required in all base domains. If the interface type option is missing, the option 

for interface type use dbms 

is assumed. The conversion options are required if the interface type is not none. The meanings of the 
fundamental options are given by the following list. 


22 Database Programming Language - SAMeDL 



VERSION 2 


1. The interface type of a base domain is the SQ/._data_type (see 6.1 of ISO/IEC 9075:1992) to 
be used when declaring parameters of the concrete interface (SQL module) for all objects of 
domains based directly or indirectly on the base domain. See 8.6, 8.7, and 8.8 of this specifi¬ 
cation. 

If the dbms type of a base domain is DT, an interface type specification of dbms is equivalent 
to the specification 

for interface type use DT; 

If an interface type of none is specified, then domains based directly or indirectly on the base 
domain shall not be used for the parameters of any procedure. 

Note: Objects of temporal data types can not appear as parameters to SQL procedures. 

If the interface type of a base domain is implementation defined, the keyword extended shali 
appear in the declaration of the base domain. 

2. The dbms type of a base domain is the SQL_data_type (see 6.1 of ISO/IEC 9075:1992) to be 
used when declaring columns having a domain based directly or indirectly on the base domain 
and when using the domain as the target of an SQL CAST expression. See 7.2 and 8.1 Oof this 
specification. 

If the dbms type of a base domain is implementation defined, the keyword extended shall ap¬ 
pear in the declaration of the base domain. 

3. The null and not null type names are the targets of the function AdaTYPE. They are the names 
of the types of parameters and parameter components in Ada procedures. See 8.6 and 8.7 of 
this specification. 

4. The data class option specifies the data class (see 7.1.1.1 of this specification) of all objects 
of any domain based on this base domain. If BD is a base domain to which the data class dc is 
assigned by an option in its definition, and if D is a domain based directly or indirectly (see 7.1.3 
of this specification) on BD, then DATACLASS(D)=ofc. The data class governs the use of literals 
with such objects (see 8.8 and 8.10 of this specification). 

5. An operand of the conversion option is a means of converting non-null data between objects 
of the not null-bearing type, the null-bearing type (see 7.1.3 of this specification) and the dbms 
type associated with a domain. A method shall be a function, an attribute of a type, or a type 
conversion. A means of determining the identity of these methods shall appear in the options 
of a base domain. The identity of a method may be given as a pattern containing parameters. 

However, enumeration domains do not have converters between the dbms type and the not 
null-bearing type, as the map parameter predefined for all enumeration domains describes a 
conversion method between enumeration and database representations of non-nuli data. The 
method is the application, as appropriate, of the function described by the database_mapping 
that is the operand of the map parameter association. See 7.1.1.1 and 7.1.3 of this specifica¬ 
tion. 

7.1.2 The SAME Standard Base Domains 

The predefined definitional module, SAMeDL_Standard, contains the declarations of the predefined SAME 
Standard Base Domains: SQL_lnt, SQL_Smailint, SQL_Char, SQL_Nchar, SQL_VarChar, SQL_Bit, SQL_- 
Real, SQL_Double_Precision, SQL_Enumeration_as_Char, and SQL_Enumeration_as_lnt. The text of 
SAMeDL_Standard appears in Annex A of this specification. 


Data Description Language and Data Semantics 23 



VERSION 2 


7.1.3 Domain and Subdomain Declarations 

domain_declaration 

domain identifier is new bas_doin_ref [not null] 

[ ( parameter_association_list ) ] ; 

subdomain_declaration ::= 

subdomain identifier is doin_ref [not null] 

[ ( paraineter_association_list ) ] ; 

dom^ref doinain_reference | subdoinain_reference 

bas_doin_ref ::=dom_ref | base_domain_reference 

paraineter_association_list :: = 

paraineter_association {, paraineter_association} 

parameter_association ::= 

identifier => static_expression 
map => database_mapping 
enumeration => enumeration_reference 
scale => static_expression | 
length => static_expression 
qualifier => 50I/_interval_qualifier 

database_inapping :: = 

eniimeration_association_list | pos | image 

enumeration_association_list ::= 

( enuineration_association {, enuineration_association} ) 

enumeration_association 

enumeration_literal => database_literal 

1. Consider the domain declaration: 

domain DD is new EE ... 

a. If EE is a base_domain_reference, then EE is said to be the base domain of DD. 

b. Otherwise, EE is a domain_reference or subdomain_reference, the base domain of DD is defined 
to be the base domain of EE, DD is said to be derived from EE, and EE is said to be the parent of 
DD. 

2. Similarly, in the subdomain declaration 

subdomain FF is GG ... 

the base domain of FF is defined as the base domain of GG, FF is said to be a subdomain of 
GG, and GG is said to be the parent of FF. 

3. The database type of a domain D, denoted as DBMS_TYPE(D), is the value, appropriately pa¬ 
rameterized, of the for dbms type option from the base domain of D. See 7.1.1,3 of this spec¬ 
ification. 

4. The interface type of a domain D, denoted as INTER_TYPE(D), the value, appropriately param¬ 
eterized, of the for interface type option from the base domain of D. See 7.1.1.3 of this spec¬ 
ification. 

5. If INTER_TYPE(D) is not none, the values of DBMS_TYPE(D) and INTER_TYPE(D) shall be 
such that conversion between them is legal in both directions by the rules of 9.1 and 9.2 of ISO/ 

I EC 9075:1992. 

6. The data class of a domain D, denoted DATACLASS(D), is the data class of its base domain, 
the value of the for data class option. A domain is numeric if its data class is numeric (see 
7.1.1.1 of this specification). 

7. Except for scale, enumeration, length, map and qualifier, an identifier within a parameter_- 
association shall be the name of a base_domain_parameter in the declaration of the base do- 


24 Database Programming Language - SAMeDL 



VERSION 2 


main of the domain or subdomain being declared. See 7.1.1.1 of this specification. 

8. A domain or subdomain D is said to assign the expression E to the parameter P, if 

a. the parameter_association P=>E appears in the declaration of D; or 

b. (a) does not hold, D is a subdomain or a derived domain, and the parent domain assigns the 
expression E to the parameter P, or 

c. (a) and (b) do not hold and in the base_domain_declaration for the base domain of D, the base_- 
domain_parameter 

P : class := E 

appears. 

In all cases, DATACLASS{£) shall be DATACLASS(P) as defined by the declaration of the 
base domain. See 7.1.1.1 of this specification. 

9. If a domain D assigns the expression E to a parameter P, then 

- DOMAIN(D.P) - NO_DOMAIN. 

- DATACLASS(D.P) = DATACLASS(E) 

10. A domain_declaration shall assign an expression to each base_domain_parameter that ap¬ 
pears in any non-optional phrase 

- of the base domain’s domain_pattern, if the declaration is not declaring a derived domain; 

- of the base domain’s derived_domain_pattern, if the declaration is the declaration of a derived 
domain. 

Similar rules govern subdomain_declarations and subdomain_patterns. See 7.1.1.2 of this 
specification. 

11 . The value assigned to the scale parameter in the declaration of a fixed domain shall be an in¬ 
teger from an implementation defined range. 

12. The value assigned to the length parameter in the declaration of a character domain shall be 
an integer from an implementation defined range. 

13. The value assigned to the qualifier, parameter in the declaration of an interval domain shall be 
an SQL_intervaLqualifier. The value of the qualifier parameter of an interval domain D is de¬ 
noted QUALIFIER(D). 

14. Any domain_declaration or subdomain_declaration of an enumeration domain shall assign an 
enumeration_reference as to the base_domain_parameter enumeration and a data- 
base_mapping to the base_domain_parameter map. if the map parameter is assigned an enu- 
meration_association_list, then 

a. Each enumeration_literal within the enumeration referenced by the enumeration_reference given 
by the enumeration parameter shall appear as the enumeration_literal of exactly one enumeratio- 
n_association. 

b. No database_literal shall appear in more than one enumeration_association. 

Note: These constraints ensure that the database_mapping is an invertibie (i.e., one-to-one) function. That function is used 
for both compile time and runtime data conversions. See 7.1.1.3 and 7.3 of this specification. 

Let D be an enumeration domain or subdomain declaration and let En be the name of the enu¬ 
meration referenced by the value assigned by Dto the enumeration base_domain_parameter. 

D is said to assign the expression E to the enumeration literal El, if D assigns the data- 
base_mapping M as the value of the map base_domain_parameter and M 

- is pos, and E = En’Pos{E(), or 


Data Description Language and Data Semantics 25 



VERSION 2 


- is image, and E = En’lmage(El), or 

- is an enumeration_associationJist containing an enunneration_association of the form El=> E 
See 7.1.6 of this specification. 

15. The database_mapping of an enumeration domain or subdomain declaration D should pre¬ 

serve the ordering implied by that domain’s enumeration_reference ER. That is, if L. and Lp 
are enumeration literals of ER such that occurs before enumerationjiteralji^, 

then the value assigned to /. ^ by D should be less than the value assigned to by D. 

16. A domain or subdomain is said to be not null only if it or any of its parent domains is declared 
with the not null phrase. In that case no object of the domain can contain the null value. 

Ada Semantics 


An instantiation of a pattern defined for the base domain of the domain being declared, as described in 
7.1.1.2 of this specification, shall appear within the Ada package specification corresponding to the module 
within which the domain_declaration appears. If in the domain declaration: 

domain DD is new EE ... 

EE is a base_domain_reference, then the domain_pattern is instantiated; if EE is a domain_reference, the 
derived_domain_pattern is instantiated; for the subdomain declaration 

subdomain FF is GG ... 

the subdomain_pattern is used. 


Note: Examples 

The following examples illustrate the declaration of domains and have been annotated with references to the appropriate clauses of 
the language definition. The base domains used in these examples exist in the predefined definitional module SAMeDL_Standard, 
which appears in Annex A of this specification. The constant Max_SQL_lnt is declared in the predefined definitional module SAMeDL_- 
System. Both SAMeDL_Standard and SAMeDL_System (see Annex B of this specification) are assumed to be visible, as is the enu¬ 
meration declaration Colors (see 7.1.6 of this specification). 

domain SWITCHES is new SQL_Bit (Length => 4); 

domain Weight is new SQL_Int ( -- 7.1.3: #la 

First => 0, -- 7.1.3: #5 and #8 

Last => Max_SQL_Int); -- 7.1.3: #5 and #8 

domain Weight_In_Pounds is new Weight; 

domain Weight_In_Grains is new Weight; 

domain City_Names is new SQL_Char { -- 7.1.3: #la 

Length =>15); -- 7.1.3: #5 and #10 

domain Colors is new SQL_Enumeration_As_Char ( -- 7.1.3: #la 
enumeration => Color_Values, -- 7.1.3: #ll 

map => image); -- 7.1.3: #11 and #12 

domain Auto_Weight is new Weight ( -- 7.1.3: #lb 
Last => 10000); -- 7.1.3: #5 

subdomain Auto_Part_Weight is Auto_Weight { -- 7.1.3: #2 

Last => 2000); -- 7.1.3: #5 and #8 

domain DB_Date is new SQL_Date; 

domain DB__Date_Strings is new SQL_VarChar; 

These declarations produce the following Ada code. 

— the instantiation of an SQL_Bit domain 

type SWITCHESNN_Base is new SQL_Bit_Not_Null; 


26 Database Programming Language - SAMeDL 



VERSION 2 


subtype SWITCHES_Not_Null is SWITCHESNN_Base (1 .. 4}; 
typo SWITCHES_Base is now SQL_Bit; 

subtypo SWITCHES_Type is SWITCHES_Base (SWITCHES_Not_Null ' Length) ; 
package SWITCHES_Ops is now SQL_Bit_Ops( 

SWITCHES_Base, SWITCHESNN_Base); 

-- the Ada code below is the instantiation of the domain pattern 
from base domain SQL_Int 

typo Weight_Not_Null is now SQL_Int_Not_Null 
range 0 .. implementation_defined; 
typo Weight_Type is now SQL_Int; 
package Weight_Ops is now SQL_Int_Ops ( 

Weight_Type/ Weight_Not_Null); 

-- The domains Weight_In_Pounds and Weight_In_Grams are not illustrated 
-- here as there instantiations are essentially identical to Weight. 

— the Ada code below is the instantiation of the domain pattern 
from base domain SQL_Char 

typo City_NamesNN_Base is now SQL_Char_Not_Null; 

subtype City_Names_Not_Null is City_NamesNN_Base (1 .. 15); 

typo City_Names_Base is now SQL_Char; 

subtype City_Names_Type is City_Names_Base (City_Names_Not_Null'Length); 
package City_Names__Ops is now SQL_Char_Ops ( 

City__Names_Base, City_NamesNN_Base) ; 

-- the Ada code below is the instantiation of the domain pattern 
from the base domain SQL_Enumeration_As_Char 

package Colors_Pkg is now SQL_Enumeration_Pkg(Color_Values); 
typo Colors_Type is now Colors_Pkg.SQL_Enumeration; 

-- the Ada code below is the instantiation of the derived domain 
pattern from the base domain SQL_Int 

typo Auto_Weight_Not_Null is now Weight_Not_Null 
range Weight_Not_Null"First .. 10000; 
typo Auto_Weight_Type is now Weight_Type; 
package Auto_Weight_Ops is now SQL_Int_Ops( 

Auto_Weight_Type, Auto_Weight_Not_Null); 

-- the Ada code below is the instantiation of the subdomain 
pattern from the base domain SQL_Int 

subtype Auto_Part_Weight_Not_Null is Auto_Weight_Not_Null 
range Auto_Weight_Not_Null'First .. 2000; 
typo Auto_Part_Weight_Type is now Auto_Weight_Type; 
package Auto_Part_Weight_Ops is now SQL_Int_Ops( 

Auto_Part_Weight_Type, Auto_Part_Weight_Not_Nul1); 


-- the DB_Date base domain generates no Ada code 

— DB_DATE_String is an example of SQL_VarChar 
typo DB_Date_Strings_Not_Null is now SQL_VarChar_Not_Null; 
typo DB_Date_Strings_Type is now SQL_VarChar; 
package DB_Date_Strings_Ops is now SQL_VarChar_Ops( 
DB_Date_Strings_Type, DB_Date_Strings_Not_Null); 

End Examples 


7.1.4 Constant Declarations 

constant_declaration 

constant identifier [: domain_reference] 
is static_expression ; 

static_expression ::= value_expression 

A static expression is a value expression (see 8.10 of this specification) whose value can be calculated at 
compile time; I.e., whose leaves are all either literals or constants. 


Now let K denote the constant declaration 

constant C [: D } is E ; 


Data Description Language and Data Semantics 27 



VERSION 2 


1. DATACLASS(K) is DATACLASS(£), the data class of the expression E. See 5.4 and 8.10 of 
this specification. 

2. If DATACLASS(K) is enumeration, character or bit then D shall be present. 

3. If the domain_reference D is not present, then 

a. C is a un/Versa/constant of class DATACLASS(K). 

b. If DATACLASSf'K'j is not a temporal data class, then AdaTYPE(/<) is an anonymous type, univer- 
sa/_T, where T is DATACLASS(/<). 

c. DOMAIN(K) = NO_DOMAIN 

4. If the domain_reference D is present, then 

a. DOMAIN(/<)=D and E shall conform to D (see 6.4 of this specification). 

b. If DATACLASSCK} is not a temporal data class, then AdaTYPE(/<) is defined as the type name 
within D designated as not null-bearing. That type name shall not refer to a limited type. 

Ada Semantics 

Let VALUE represent the function which calculates the value of a static_expression. Let SEbe a static_ex- 
pression. VALUE(S£) is given recursively as follows: 

1. If SE contains no operators, then 

a. If SE is a database_literal, then VALUE(S£) = SE. 

b. If SEis an enumeration_literai of domain D, and D assigns expression E to that enumeration lit¬ 
eral, then VALUE(S£) = E. 

c. If SE is a reference to the constant whose declaration is given by 

constant C [: D ] is E ; 

then VALUE(SE) = VALUE(E). 

d. If SEis a reference to a parameter P from domain D, and D assigns the expression E to P, then 
VALUE(SE) = VALUE(E). 

2. If SE is D(SE.i), where D is a domain name, then VALUE(D^SE^;) = VALUEfSE^;. 

3. If SEis +SE^ (or -SE^) then VALUE^SEj = -i-VALUE(SE^) (or -VALUE(SE^)). 

4. If SE is SEj op SE^ where op is an arithmetic operator, then VALUE^SEJ = VALUE(SE.) op 
VALUEiSb^) where op is evaluated according to the rules of SQL. See 6.12 of ISO/IEC' 

9075:1992. 

5. If SE is fSE^j then VALUE^SEj = (VALUE(SE^)). 

If DATACLASSC/Cj is not a temporal data class, let K denote the constant declaration 

constant C [: D ] is E ; 

If E is not an enumeration literal, let Obe the Ada representation of VALUE(E); otherwise, let Q be AdalD(E). 
Then the Ada library unit package specification corresponding to the module in which the constant declara¬ 
tion K appears shall have an Ada constant declaration of the form 

AdalD(C) : constant [AdaTYPE (fC) ] := Q ; 

The type designator AdaTYPE(K) is omitted from this declaration if it is an anonymous type. 

A/ofe.'Temporal constants have no direct Ada analogue and therefore do not generate Ada constants. 


28 Database Programming Language - SAMeOL 



VERSION 2 


Note: Examples 

The following are examples of constant declarations. 

constant Grams_In_Pound is 453.59237; 
constant The_Color_Red : Colors is Red; 
constant Home_Port : City_Names is 'Pittsburgh'; 
constant All_On : SWITCHES is B'llll' 

Note that Grams_in_Pound is a universal constant of class fixed. These declarations generate the following Ada declarations. 

Grams_In_Pound : constant := 453.59237; 

The_Color_Red : constant ; Color_Values := Red; 

Home_Port : constant City__Name_Not_Null := "Pittsburgh 
A1l„On; constant SWITCHES:= (1,1,1,1); 

End Examples 


7.1.5 Record Declarations 

record_declaration ::= 

record identifier__l [nained_phrase] is 
component^declarations 
end [identifier_2] ; 

named phrase ::= named identifier 

component_declarations ::= component_declaration {component_declaration} 
component_declaration ::= 

component {, component} : domain_reference [not null] ; 
component ::=component_name [dblength [named^phrase]] 
component_name ::= Ada_identifier 

If present, identifier_2 shall be equivalent to identifier_1. Identifier_1 is the name of the record. 

Let f? be a record declaration. Define AdaNAME(fl) to be 

1. The alias N, if the named_phrase named A/appears in the declaration. 

2. Row, othenwise. 

Note: AdaNAME(R) is the default for the name of the row record formal parameter in the parameter profile of any procedure 
that uses the declaration R. See 8.2,8.5, and 8.9 of this specification. 


Ada Semantics 

The Ada library unit package specification corresponding to the module within which the record_declaration 
R appears shall have an Ada record type declaration defined as follows: 

1. The name of the record type shall be AdaID(identifier_1). 

2. For some integer k, let the component_declarations of R be given by the sequence 

components^ : [not null^] 

for 1 <i<k, where componentS| is given by the sequence 

j [dblength^j [named ^ ] ] 

where 1 ^ y ^ m^for some integer m* ^Ada shall be equivalent, in the sense of 3.2.10 and 3.7.2 
of ISO/lEC 8652:1995, to a record type whose components are given by the sequence 

COMP^j [DBleng^j] 


Data Description Language and Data Semantics 29 



VERSION 2 



AdaID(C..) : T. ; 

13 1 

where Tj is an Ada type name determined to be: 

a. The not null-bearing type name within the domain D|, if either D| is a not null only domain or not 
null| is present in R; 

b. Otherwise the null-bearing type name within the domain D|. 

The optional component DBIeng-. appears if the optional dblength|| phrase appears and in that 
case is of the form 

DBLngNAME^j : Ada_Indicator_Type ; 

where DBLngNAMEjj is AdalD(N||) if Nj: appears and is AdalD(Cjj)_DbLength, otherwise; and 
Ada_lndicator_Type is the type SQL_Standard.lndicator_Type (see 12.3.8.a.iii of ISO/IEC 
9075:1992). 


Note: Examples 

The following example illustrates the declaration of a record object. 

record Parts„Row_Record_Type named Parts„Row_Record is 
Part_N\iinber : Part_Nuinbers not null; 

Part_Naine : Part_Names; 

Color : Colors; 

Weight : Weight_In_Grams; 

City : City_Naiiries ; 

end Parts_Row_Record_Type; 

This declaration produces the following Ada code. It has been annotated with references to the appropriate clauses of the language 
definition. 


type Parts_Row_Record_Type is record -- Ada Semantics #1 

Part_Nnmber : Part_Nuinbers_Not_Null; Ada Semantics #2 

Part_Name : Part_Names_Type; 

Color : Colors_Type; 

Weight : Weight_In_Grams_Type; 

City : City_Names_Type; 

end record; 


End Examples 


7.1.6 Enumeration Declarations 

Enumerations are used to declare sets of enumeration literals for use in enumeration domains and status 
maps. See 7.1.3 and 7.1.8 of this specification. 

entiineration_declaration : : = 

enumeration identifier_l is ( enuineration_literal_list ) ; 

enumeration_literal__list : : = 

enuineration_literal {, eniimeration_literal} 

1. IdentifieM is the name of the enumeration. 

2. Each identifier within an enumerationJiteraLlist is said to be an enumeration literal of the enu¬ 
meration. The enumeration_declaration is considered to declare each of its enumeration_liter- 
als. An enumeration_literal may appear in multiple enumeration_declarations. 


30 Database Programming Language - SAMeDL 



VERSION 2 


Ada Semantics 


There shall be, within the Ada package specification corresponding to the module within which an enumer¬ 
ation appears, a type declaration of the form 

type AdaID(identifier_l) is ( AdaID{enuineration_literal_list) ) ; 

The application of the transformer AdalD (see 5.3 of this specification) to a list is accomplished by applica¬ 
tion of the transformer to each element of the list. Ada character literals shall not be used in enumerations. 
See 5.4 of this specification. 


Note: Examples 


The following are examples of enumeration declarations. 

eniameration Single_Row_Status is { 

More_Than_One_Row, No_Such_Row, Row_Found); 

enumeration Color_Values is ( 

Purple, Blue, Green, Yellow, Orange, Red, Black, White); 

The above declarations produce the following Ada code. 

type Single_Row_Status is ( 

More_Than_One_Row, No_Such_Row, Row_Found); 

type Color_Values is ( 

Purple, Blue, Green, Yellow, Orange, Red, Black, White); 


End Examples 


7.1.7 Exception Declarations 

exception_declaration ::= exception identifier ; 

Identifier is the name of the exception. 


Ada Semantics 


There shall be, within the Ada package specification corresponding to the module within which an exception 
declaration appears, an exception declaration of the form 

AdalD(identifier_l) : exception ; 


Note: Examples 

The following are examples of exception declarations. 

exception Data_Definition_Does_Not_Exist; 
exception Insufficient_Privilege; 
exception Transaction_Rollback; 

The above declarations produce the following Ada code. 

Data_Definition_Does_Not_Exist : exception; 
Insufficient_Privilege : exception; 
Transaction_Rollbasck : exception; 

End Examples 


Data Description Language and Data Semantics 31 



VERSION 2 


7.1.8 Status Map Declarations 

The execution of any procedure (see 6.6, 8.2, and 8.5 of this specification) causes the execution of an SQL 
procedure. That execution causes a special parameter, called the SQL status parameter, to be “set to a sta¬ 
tus code that either indicates that a call of the procedure completed successfully or that an exception con¬ 
dition occurred during execution of the procedure” (See 4.18.1 of ISQ/IEC 9075:1992). Status maps are 
used within abstract modules to process the status data in a uniform way. Each map declares a partial func¬ 
tion from the set of all possible SQL status parameter values onto (1) enumeration literals of an enumeration 
and (2) raise statements. 

status_map_declaration 

[ SQlcode I sglstate ] status identifier_l 
[ nained__phrase ] 

[uses target_enumeration] 
is ( status_assignment {, status_assignment} ); 

target_enuineration :: = 

enumeration_reference | boolean 

status_assigninent :: = 

left_hand_side => en\inieration_literal 
I left_hand_side => raise exception_reference 

Isft_hand_side ::= static_expr { , static_expr ) 

static_expr ::= 

static_expression 

I static_expression .. static_expression 
(see 3.5 of ISO/IEC 8652:1995) 

1. Identifier_1 is the name of the map. 

2. A target_enumeration of boolean is a reference to the predefined Ada enumeration type Stan- 
dard.boolean. 

3. If the optional uses clause is not present, then only status_assignments that contain raise shall 
be present in the status_map_declaration. 

4. Every Ac/a_enumeration_literal within a status_assignment shall be an Acfa_enumeration_liter- 
al within the enumeration referenced by the target_enumeration. 

5. If neither sqlcode nor sqistate is specified, then sqistate is assumed. 

6. If sqlcode is specified, then if E is a static_expression appearing in a left_hand_side, then 
DATACLASS(E) = integer. In this case a static_expr of the form E. .. Ep shall be permitted in 
a left_hand_side, provided E., < Ep. If v.|, Vp ,..., v^.^ are all the integers between E. and Ep 
inclusive, then the form E.| .. Ep is equivalent to the list of static expressions v.^, Vp ,..., v^ 

7. If sqistate is specified, then if E is a static_expression appearing in a left_hand_side, then 
DATACLASS(E) = character, and either 

a. E shall contain five characters and, if DQMAIN(E) 5 ^ NO_DQMAIN, then DQMAIN(E) = SAMeDL_- 
Standard.SQLSTATE_Domain; or 

b. E shall contain two characters and, if DOMAIN(E) NO_DQMAIN, then DQMAIN(E) = SAMeDL_- 
Standard.SQLSTATE_Class_Domain. If v.,, Vp ,..., v are all the SQLSTATE values whose Class 
value is given by the value of E, then E is equivalent to the list of static expressions v.., Vp ,..., v 
See annex A for the text of the predefined module SAMeDL_Standard. See 22.1 of is'o^'c ' ^ 
9075:1992 for the standard values of SQLSTATE. Other values of SQLSTATE may be defined by 
an implementation. 

8. If E and E’ are distinct static expressions appearing in the clauses of a status map (possibly via 


32 Database Programming Language - SAMeOL 



VERSION 2 


the equivalence of previous rules), then E and E’ shall not evaluate to the same value. 

Notes: sqistate is the preferred form, sqlcode is a feature deprecated in ISO/IEC 9075:1992, annex D. 

A status_assignment takes the form of a list of alternatives as found in Ada case statements, aggregates, and representation 
clauses. The others choice is not valid for status_assignments, however. 

SAMeDL_Standard contains the definition of a status map Standard_Map, defined as foliows: 

sqistate status Standard_Map 
named Is_Found 
uses boolean 
is 

(Successful_Coinpletion_No_Subclass => True, 

No_Data_No_Subclass => False); 

Standard_Map is the status map for those fetch statements that appear in cursor declarations by default. (See 8.5 of this 
specification.) It signals end of table by returning false. 


Note: Examples 

The following is an example of a status map declaration. For the enumeration and exception declarations, refer to the examples in 
7.1.6 and 7.1.7 of this specification. They are assumed to be visible at the point at which the status map is declared. Further, direct 
visibility (i.e., use) of SAMeDL_Standard is assumed. 

This map might be usefully applied to single row select statements. It distinguishes the exceptional condition of retrieving more than 
one row from the condition of retrieving no rows. It eliminates the distinction between a successful completion and a completion In 
which a warning was returned. It raises an exception in the Ada application in two subcases of an SQL transaction rollback. See 6.5 
and Annex A of this specification and 22 in ISO/IEC 9075:1992.) 

status Single_Row_Select_Map 
named Result 

uses Single_Row_Status is ( 

Cardinality_Violation_No_Subclass => More_Than_One_Row, 

No_Data_No_Subclass => No_Such_Row, 

Succesful_Completion_No_Subclass, 

Warning => Row_Found, 

Trans ac tion_Ro11ba ck_No_Subclass, 

Transaction_Rollback_Serialization_Failure => raise Transaction_Rollback); 


End Examples 

7.2 Schema Modules 

schema_module ::= 

[context] 

[extended] schema module identifier.,! is 
{schema^element} 
end [identifier_2]; 

schema_eleinent : : = 

schema_procedure 
Ischema_definition_statement 

schema_procedure ::= 

[extended] procedure identifier_3 is 
s chema^de finition_s tat ement 
[status_clause] 
end [identifier_4]; 

schema_definition_statement ::= see the rules 

1. If present, identifier_2 shall be equivalent to identifier_1. Identifier_1 is the name of the sche- 
ma_module. Similarly, if present identifier_4 shall be equivalent to identifier's. Identifier's is 
the name of the schema procedure. 


Data Description Language and Data Semantics 33 



VERSION 2 


2. IdentifieM shall be different from any other schema module name (See clause 11.1 oflSO/lEC 
9075:1992). Identifier_3 shall be different from any other procedure name in the enclosing 
schema_module. 

• 3. An extended_schema_element may appear in a schema_module only if the keyword extended 
appears in the associated schema module declaration. 

A schema_definition_statement differs from schema definition statement as defined in ISO 9075:1992 in the 
following ways: 

1. The keyword create is optional in a table and view definition. A view or table definition ends 
with the phrase end [T] where t is the name of the table or view being defined. 

Note: In the prior version of this specification, the create keyword was not present in view and table definitions. 

2. In all schema definitions statements: 

a. Value expressions as defined in 8.10 replace SQL value expressions. 

b. Search conditions as defined in 8.11 replace SQL search conditions. 

Note: Conditions in ISO 9075:1992 prohibit vaiue expressions in schema definition statements from containing 
input_references. Note that the seiect parameters in a query expression defining a view are those of SQL, not 
those in 8.7 of this specification. 

3. In table definitions: 

a. A column definition shall contain a domain_reference appearing in the syntactic location of a data 
type. A domain name, as defined in ISQ 9075:1992 shall not appear in a column definition. 

b. Suppose that column_definition CD contain a reference to the domain D. 

i. The domain of CD, denoted DQMAIN(CD), is D. 

ii. DATACLASS(CD) is DATACLASS(D). 

4. In view definitions: 

a. The column of the defined view has domain DQMAINj as defined by the query expression con¬ 
tained in the view definition; see 8.4 of this specification. 

b. DATACLASS of the column of the defined view is DATACLASS(DQMAINj). 

Ada Semantics 

For each schema module within a compilation unit there is a corresponding Ada library unit package the 
name of which is the name of the schema module, that is AdalD(identifier_1). 

For each schema procedure defined within a schema module, there is an Ada procedure defined within the 
corresponding Ada library unit package. The name of the Ada procedure is the name of the schema proce¬ 
dure, that is, AdalD(identifier_3). If a status_clause appears in the schema procedure, the Ada procedure 
will have a single parameter of mode out. For the name and type of this parameter, see 7.1.8 and 8.12 of 
this specification. 


34 Database Programming Language - SAMeDL 



VERSION 2 


SQL Semantics 

There is an SQL module associated with each schema module. The name of the SQL module is implemen¬ 
tation defined. The language clause of the SQL module shall specify Ada. 

For each schema procedure within a schema module, there is an SQL procedure defined within the corre¬ 
sponding SQL module. The name of this procedure is implementation defined. The procedure declaration 
shall declare an SQLSTATE parameter unless a status_clause appears in the schema procedure that ref¬ 
erences a status map specifying sqlcode, in which an SQLCQDE parameter is declared. (See 7.1.8 and 
8.12 of this specification.) 

The SQL schema definition statement within the SQL procedure is derived from the schema definition state¬ 
ment as follows: 

1 . Any search condition SC is replaced with SQLsc (SC), defined in 8.1 1 of this specification. Any 
value expression VE is replaced with SQLve(VE) as defined in 8.10 of this specification. 

2. For view and table definitions: if needed, the keyword create is prepended; the end [t] ; is 
removed. 

3. For table definitions, the domain name, D, is replaced with DBMS_TYPE(D). 

4. Otherwise, the statement is unchanged. 

Interface Semantics 

A call to the Ada procedure corresponding to a schema procedure shall have the effect of executing the 
corresponding SQL procedure and performing standard post processing as defined in 6.5 of this specifica¬ 
tion. 


Note: Examples 


The following is an example of a schema module. 


schema module Parts_Suppliers_Database is 


-- the Parts table 

table P is -- 7.2.1: #1 and #2 


PNO not null 

PNAME : 
COLOR : 
WEIGHT : 
CITY : 


: Part^Niimbers, — 
Part_Naines, 

Colors, 

Weight_In_Pounds, 
City_Naines, 


unique (PNO) 


7.2.1: #3 and #4 
-- 7.2.1: #5 


end P; 

-- the Suppliers table 

table Sis --7.2.1:#1 and #2 

7.2.1: #3 and #4 
7.2.1: #5 
5.3 

unique (SNO) 


SNO not null : Supplier_Nuinbers, -- 

SNAME : Supplier_Naines, 

"STATUS" : Status_Values, 

CITY : City_Names, 


Data Description Language and Data Semantics 35 




VERSION 2 


end S; 

-- the Orders table 

table SP is -- 7.2.1: #1 and #2 

SNO character(5) not null : Supplier_Numbers, 7.2.1; #3 and #4 

PNO character(6) not null : Part_Numbers, 

QTY integer : Quantities, -- 7.2.1: #5 

Date__Order : DB_Date 
uni<iue {SNO, PNO) 
end SP; 

the Part_Number_City view 
procedure Create_PNO_City_View is 

view PNO_CITY as --7.2.2: #1 and #2 

select distinct PNO, CITY 
from SP, S 

where SP.SNO = S.SNO 
end PNO_CITY; 


end Parts_Suppliers__Database; 

This schema module generates the following Ada package 
package Parts_Supplier_Database is 

procedure Create_PNO_City_View; 

and the following SQL procedure (within a module whose name is not specified by the standard.), 
procedure implementation_defined (SQLSTATE) 

create view PNO_CITY as ~~ 1.2.2: #1 and #2 
select distinct PNO, CITY 
from SP, S 

where SP.SNO = S.SNO 


End Examples 

7.3 Data Conversions 


The procedures that are described in an abstract module (see clause 8 of this specification) transmit data 
between an Ada application and a DBMS. Those data undergo a conversion during the execution of those 
procedures. Constants and enumeration literals used in statements are replaced by their database repre¬ 
sentation in the form of the statement in the concrete module. This process occurs at module compile time. 
Both processes are described in this clause. 

Execution Time Conversions 


The execution time conversions check for and appropriately translate null values; for not null values, the 
conversion method identified by the appropriate base domain definition (see 7.1.1.3 of this specification) is 
executed. 


Input parameter conversion rule. If the type of an input parameter is null-bearing, then in the correspond¬ 
ing SQL procedure there is an associated SO/._parameter_specification to which an SQ/._indicator_param- 
eter has been assigned. (See 8.6 and 8.8 of this specification.) If, for any execution of the procedure, the 
value of the input parameter is null, then the indicator parameter is assigned a negative value. (See 4.17.2 
and General Rule 6 in 6.2 of ISO/IEC 9075:1992.) Otherwise, the indicator parameter shall be non-negative 
and the SQL parameter shall be set from the input parameter by the conversion process identified for the 


36 Database Programming Language - SAMeDL 



VERSION 2 


base domain. If the type of an input parameter is not null-bearing, the SQL parameter shall be set from the 
input parameter by the conversion process identified for the base domain (7.1.1.3 of this specification). 

Output parameter conversion rule. For output parameters of procedures containing either fetch or select 
statements, this process is run in reverse. Let SP be a select parameter. Then the corresponding SQL pro¬ 
cedure has a data parameter and an indicator parameter corresponding to SP (see 8.2, 8.5, and 8.7 of this 
specification). For any execution of the procedure: 

- If the indicator parameter is negative, then 

- if the type of the Ada record component COMPAda(SP) (see 8.2 and 8.5 of this specification) is 
nuii-bearing, then COMP;^(ja(SP) is set to the null value; else 

- if the type of COMPAda(SP) is not null-bearing, the exception SAMeDL_Standard.NulLVaiue_Error 
is raised. 

- If the indicator parameter is non-negative, then the value of COMPAcja(SP) is set from the value 
of the SQL data parameter by the conversion process identified for the base domain of SP (see 
7.1.1.3) of this specification). If the record component DBLeng/^jja(SP) is present (see 8.2 and 
8.4 of this specification), then it is set to the value of the indicator parameter. 

Compile Time Conversions 

The SQL semantics of constants, domain parameters, and enumeration literals (and constants that evaluate 
to enumeration literals) used in value lists of insert statements (see 8.8) and value expressions (see 8.10 of 
this specification) require that they be replaced in the generated SQL code by representations known to the 
DBMS. For enumeration literals, the enumeration mapping is used (see 7.1.1.1, 7.1.1.3 and 7.1.3 of this 
specification). 

Let Vbe an identifier. If Vis not a reference to a constant, a domain parameter, or an enumeration literal, 
then Vis not static and undergoes no compile time conversion. 

If Vis a reference to 

- a constant declared by 

constant C [: D ] is E ; 

- a domain parameter param of domain D, and D assigns the expression E to param (see 7.1.3 
of this specification), 

- or an enumeration literal E/from enumeration domain D (see 8.3, 8.8, 8.10, and 8.11 of this 
specification), and D assigns the expression E to V, 

then Vis replaced by the static expression SQLve(E) (see 8.10 of this specification). 

8 Abstract Module Description Language 

8.1 Abstract Modules 

abstract_inodule :: = 

[context] 

[extended]abstract module identifier^! is 


Abstract Module Description Language 37 


VERSION 2 


SQL_modu 1e_authoriz a tion_c1aus e] 

{definition} 

{temporary_table_declaration} 

{modu1e_contents} 
end [identifier_2]; 
module__contents : : = 
cursor_declaration | 
dynainic_declare_cursor 
procedure_declaration 

1. When present, identifier_2 shall be equivalent to identifier_1. Identifier_1 is the name of the ab¬ 
stract module. 

2. No two of the items (that is, temporary table, procedures, cursors, and definitions) declared 
within an abstract module shall have the same name. 

3. A temporary_table_declaration differs from an SQL temporary table declaration (see 13.11 of 
ISO 9075:1992) in the same way in which table declarations differ from SQL table definitions 
(see 11.3 of ISO 9075:1992 and 7.2 of this specification). 

4. A temporary table, procedure or cursor declared in an abstract module may be an extended 
temporary table, procedure or cursor (see 8.2 and 8.4 of this specification) only if the keyword 
extended appears in the abstract module declaration. 


Ada Semantics 


For each abstract module within a compilation unit there is a corresponding Ada library unit package the 
name of which is the name of the abstract module, that is, AdalD(identifier_1). The Ada construct giving the 
Ada semantics of any construct declared within an abstract module is declared within the specification of 
that library unit package. Nothing else appears in the specification of that package. 

SQL Semantics 


There is an SQL module associated with each abstract module. The SQL construct giving the SQL seman¬ 
tics of any construct declared within an abstract module is declared within that SQL module. The name of 
the SQL module is implementation defined. The language clause of the SQL module shall specify Ada. If a 
module authorization clause appears in the abstract module, the identical clause shall appear in the SQL 
module; otherwise the module authorization clause in the SQL module is implementation defined. See 
clause 12 of ISO/IEC 9075:1992. 

A temporary table declaration is transformed into an SQL temporary table declaration in the same way that 
a table definition is transformed into an SQL table definition. See 7.2 of this specification. 

8.2 Procedures 

The procedures discussed in this clause are not associated with a cursor. Cursor procedures are discussed 
in 8.5 of this specification. 

For every procedure declared within an abstract module there is an Ada procedure declared within the li¬ 
brary unit package specification corresponding to that abstract module (see 8.1 of this specification) and an 


38 Database Programming Language - SAMeDL 


VERSION 2 


SQL procedure declared within the corresponding SQL module. A call to the Ada procedure results in the 

execution of the SQL procedure. 

procedure_declaration ::= 

[extended] procedure identifier_l [input^araineter_list] is 
statement [status_clause]; 

statement ::= 

executable_schema_statement 

non__cursor_data_statement 

dynamic_statement 

schema_manipulation_statement 

transaction_statement 

connection_statement 

s e s sion_s tat ement 

diagnostic_statement 

extended_statment 

1. Identifier_1 is the name of the procedure. 

2. If the statement within a procedure is an insert_statement_row, then the procedure shall not 
have an input_parameter_list. See 8.3. 

3. Schema manipulation, transaction, connection, session, dynamic and diagnostic statements 
are identical to the identically named statements in ISO/IEC 9075:1992 except that any SQL 
value expressions or search conditions are replaced by the value expressions and search con¬ 
ditions of this specification (see 8.10 and 8.11). 

4. A statement may be an extended_statement only if the keyword extended appears in the pro¬ 
cedure declaration. If the keyword extended appears in the procedure declaration, then the 
keyword extended shall appear within the definition of the module in which the procedure is 
declared. 


Ada Semantics 


Each procedure declaration P shall be assigned an Ada procedure declaration in a manner that sat¬ 
isfies the following constraints: 

- If P is declared within the declaration of an abstract module M, then P^^jg is declared directly 
within the library unit package specification M. 

- The simple name of P^^jg is AdalD(ldentifier_1), the name of P. 

The parameter profile of the Ada procedure is defined as follows: 

1. Let the input_parameter_list of the procedure contain k input parameteirs (for some k> 0), given 

f H 

by INP.|, INP 2 , ..., INP|^. Then the i parameter declaration in the AofaJormaLpart of P/^^g. 
denoted PARM;^jja(INPj) for /< k, is given by 

AdaNAME(INP.) : in AdaTYPE(INP.) 

1 1 

(See 8.6 of this specification.) 

2. If the statement within the procedure is a select_statement_single_row, then the (k+lf^ param¬ 
eter in the Acfa_formaLpart of P/^^jg is a row record. The mode of the row record parameter 
shall be in out. 

Let 1C be the into_clause appearing (possibly by assumption, see 8.3 of this specification) in 
the select_statement. Then the name of the row record parameter is PARMRoyj,(/C); the name 


Abstract Module Description Language 39 



VERSION 2 


of the type of that parameter is TYPEroJ/Q- See 8.9 of this specification. If 1C contains the 
keyword new, then the declarative region containing the declaration of P • ^ shall also contain 
the declaration of TYPEro^(/C). 

The names, types, and order of the components of the row record parameter are determined 
from the selectjist within the select_statement. Let that list be given by SP..; SP 2 ;...; SP . (If 
the select_list takes the form then assume the transformation described in 8.7 of this speci¬ 
fication has been applied.) Then the row record type is equivalent in the sense of 3.2.10 and 
3.7.2 of ISO/IEC 8652:1995, to a record whose sequence of components is given by the se¬ 
quence 

... COMPAda(SPj) (DBLengAda(SPj)] ... 
where COMPAda(SPj) is given by 

AdaNAME(SP^) : AdaTYPE(SP^) 

provided that AdaNAME(SPj) and AdaTYPE(SPj) are defined (see 8.7 of this specification). 
The record component COMPAda(SPj) is otherwise undefined. The record component DBLen- 
gAda(SPj) is given by 

DBLngNAME(SP^) : Ada_Indicator_Type 

where Ada_lndicator_Type is the type SQL_Standard.lndicator_Type (see 12.3.8.a.iii of ISO/ 
lEC 9075:1992), provided \h3.\ DBLngNAME(SPj) is defined; otherwise this component is not 
present. 

Note: C0MP;^;J3(SP.) is undefined only if the i*'^ select parameter is improperly written; whereas DBLeng^j,,{SP.) 

is undefined when the i^^ select parameter does not have a dblength phrase. See 8.7 of this specification. 

3. If the statement within the procedure is an insert_statement_row and it is nofthe case that the 
insert_valuejist is present and consists solely of literals and constants, then the first parameter 
is a row record. The mode of the record parameter is in. 

Let 1C be the insert_from_clause appearing (possibly by assumption, see 8.3 of this specifica¬ 
tion) in the statement. Then the name of the row record parameter is PARMrovv(/C): the name 
of the type of that parameter is TYPErow(/C). See 8.3 of this specification. If /C contains the 
keyword new, then the declarative region containing the declaration of P-also contains the 
declaration of TYPEro^(/C). 

The names, types, and order of the components of the record type are determined from the in- 
sert_columnJist and insert_valuejist. So, let C.,, C 2 , ..., be the subsequence of insert_- 
column_specifications appearing in an insert_column_list such that the corresponding element 
of the insert_valuejist is not a literal or constant reference. Then the row record type is equiv¬ 
alent in the sense of 3.2.10 and 3.7.2 of ISO/IEC 8652:1995, to the record whose i“^ component 
COMPAcia(Cj) for 1<i<m is given by 

AdaNAME(C^) : AdaTYPE(C^) 

(See 8.8 of this specification). 

4. If the statement within the procedure is an extended_statement, see 6.6 of this specification; 
for extended parameter lists, see 8.6 of this specification. 

5. For all procedures, regardless of statement type, if a status_clause appears in the procedure 
declaration, then the final parameter is a status parameter of mode out. For the name and type 
of this parameter, see 7.1.8 and 8.12 of this specification. 


40 Database Programming Language - SAWIeDL 



VERSION 2 


SQL Semantics 


Each procedure declaration P shall be assigned an SQL procedure P 3 QL within the SQL module for the 
abstract module in which the procedure appears. Psql P^rts: 

1. An SOL_procedure_name. This is implementation defined. 

2. A list of SQL_parameter_declarations. An SQLSTATE parameter is declared for every SQL 
procedure unless a status_clause appears In the procedure declaration that references a status 
map specifying sqlcode, in which case an SQLCODE parameter is declared. (See 7.1.8 and 
8.12 of this specification.) 

3. If an input parameter list is present, then the SQL parameters derived from the input_parame- 
ter_list of the procedure, as described in 8.6 of this specification, appear in the parameter dec¬ 
larations of P 5 Q|_- 

4. Other parameters depend on the type of the statement within the procedure P. 

a. If the statement is an insert_statement_row, then the SQL parameters are determined by the 
insert_values in insert_value_lists that are column_names. See 8.8 of this specification. 

b. If the statement is a select_statement_single_row, then the SQL parameter declarations for P 5 q|_ 
are determined by the select_list of the select_statement_single_row, as described in 8.7 of this 
specification. 

c. If the statement Is an extended_statement, see 6.6 of this specification. 

5 . An SQL_SQL_procedure_statement (see 12.5 in ISO/IEC 9075:1992). This is derived from the 
statement in the procedure declaration by applying the transformations SQLve to any value ex¬ 
pression and SQLsc fo any search condition appearing in the statement in the procedure. Cer¬ 
tain statement types have specific transformation rules. See 8.3. 

Interface Semantics 

A call to the Ada procedure P/^^g shall have effects that cannot be distinguished from the following: 

1 . The procedure P 5 q|_ is executed in an environment in which the values of parameters PARM- 

sql(INP) and INDICsql(INP) (see 8.6 of this specification) are set from the value of PARM^. 
da(INP) (see Ada Semantics above) according to the rule for input parameters of 7.3 of this 
specification, for every input parameter INP in the input_parameterjist of the procedure. Sim¬ 
ilarly, for each insert_value Cthat is a column_name in an insert_valuejist of an insert_state- 
ment_row, the value of PARMsql(C) and INDICsql(C) are set from the value of COMPAdaCQ. 
according to the rule of 7.3 of this specification. See 8.8 of this specification. 

2. Standard post processing, as described in 6.5 of this specification, is performed. 

3. If the value of the SQL status parameter indicates successful completion or if it is handled by a 
status map attached to the procedure (see 6.5 of this specification) and is defined by the SQL- 
implementation to permit the transmission of data and the statement within the procedure is a 
select_statement, then the value of the component of the row record parameter components 
COMPAda(SPj) and DBLengAda(SPj) are set from the values of the actual parameters associ¬ 
ated with the SQL formal parameters PARMsoJSPj) and INDICsql(SP:) (see 8.7 of this spec¬ 
ification), according to the rule for output parameters of 7.3 of this specification. 


Note; Examples 


Abstract Module Description Language 41 



VERSION 2 


The following are examples of procedure declarations. The first is a declaration of a procedure with no input parameters. 

procedure Parts_Suppliers_Commit is 

commit work; 

The above declaration produces the following Ada procedure specification in the abstract interface. 

procedure Parts_Suppliers_Commit; 

The next procedure declaration contains an input parameter and a status clause. 

procedure Delete_Parts ( 

Input__Pname named Part_Name : Part_Names) is 

delete from P 

where PN7VME = Input_Pname 

status Operation_Map named Delete_Status 


The above declaration produces the following Ada procedure specification in the abstract interface. 

procedure Delete_Parts ( 

Part_Name : in Part_Names_Type; -- 8.6: Ada Semantics #1 

8.2: Ada Semantics #1, #2 

Delete_Status : out Operation_Status); -- 8.2: Ada Semantics #5 

A somewhat more complex example, involving a row record: the SAMeDL procedure: 

procedure Insert_Redparts is 
insert into P 

(PNO named Part_Nuinber, 

PNAME named Part_Name, 

COLOR, 

CITY) 

from Red_Parts 

values {PNO, PNAME, Red, CITY); 
produces the following Ada declarations: 

type Insert_Redparts_Row_Type -- 8.2, Ada semantics #3, 8.9 

is record 

Part_Number : Part_Numbers_Type; -- 7.2.1 

Part_Name : Part_Names_Type; 

City : City_Names_Type; 

end record; 

procedure Insert_Redparts 

(Red_Parts : in Insert_Redparts_Row__Type) ; 


The color of all parts inserted using the lnsert_Redparts procedure will be red. The weight of all such parts will be null. See the exam¬ 
ples in 7.2 of this specification. The number, name and city of those parts are specified at run time. 

End Examples 

8.3 Non cursor data statements 

This clause describes the concrete syntax of data statements that are not cursor-oriented. The text of the 
SQL statement derived from the text of a statement is defined. 

non„cursor_data_statement ::= 
deleterstatement_searched 


42 Database Programming Language - SAMeDL 



VERSION 2 


insert_statement 

insert_statement_row 

update_statement_searched 

select_statement_single_row 

insert_statement_row ::= 

insert into table_name [(insert_coliimn_list)] 

[insert_from_clause] values [(insert_value_list)] 

Other than the insert_statement_row, the non cursor data statements are identical to the similarly named 

SQL data statements (see 12.5 of ISO/IEC 9075:1992) except that 

1. Value expressions as defined in 8.10 replace SQL value expressions: 

2 . Search conditions as defined in 8.11 replace SQL search conditions: 

3 . The select list defined in 8.7 and the into clause defined 8.9 of this specification replace the SQL 
select list and select target list in a single row select statement. However, the select list of any 
contained subquery is not replaced in this way. 

In the following discussion, let ProcName be the name of the procedure in which the statement appears. 

1 . If no insert_from_clause appears within an insert_statement_row, then the following clause is 
assumed: 

from Row : new ProcA/ame_Row_TYpe 

If an insert_from_clause that does not contain a recordjd appears in an insert_statement_row, 
the recordjd 

: new ProcA/a/T?e_Row_Type 
is assumed. See 8.9 of this specification. 

2. If no into_clause appears within a select_statement_single_row, then the following clause is as¬ 
sumed: 

into Row : new PfOCA/a/77e_Row_Type 

If an into_clause which does not contain a record_id appears in a select_statement, the recor¬ 
djd 

; new ProcA/ame_Row_Type 
is assumed. See 8.9 of this specification. 

3. This rule applies to all forms of insert statements. If an insert_column_list is not present, then 
a column list consisting of all columns defined for the table denoted by SQZ.Jable_name is as¬ 
sumed, in the order in which the columns were declared (8.7.3 of ISO/IEC 9075:1992). 

Note: Use of the empty insert_columnJist is considered poor programming practice. The interpretation of the 
empty insert_columnJist is subject to change as the database design changes. Programs that use an empty in- 
sert_columnJist present maintenance difficulties not presented by programs supplying an insert_columnJist. 

4. If the statement is an insert_statement_row, then 

a. If the insert_valuejist is not present, then a list consisting of the sequence of column 

names in the insert_columnJist is assumed. 

b. The insert_columnJist and insert_valuejist shall conform, as described in 8.8 of this 

specification. 

5. In an insert_statement not an insert_statement_row, let C.j, Cg,..., 0^^^ be the columns appear¬ 
ing in the SQLJnsert_columnJist (possibly by assumption, see above). The query_expression 
appearing in the statement is equivalent (see ISO/IEC 9075:1992 7.5 and 7.10) to one of the 


Abstract Module Description Language 43 



VERSION 2 


form 

El [OP E2] 

where OP is a set operator and the two query_expressions, and E 2 , define tables of the 
same length. Let that length be n and let C^j and C^j for 1 < i < n be the sequence of columns 
of those tables. We may assume, by recursion over the number of set operators, that 
DOMAIN(C^i) and DOMAIN(C^j) are defined. Then 

a. m = n, that is, the lists are of the same length; and 

b. DOMAIN(C^l) = DOMAIN(C2i) = DOMAIN(Cj). 

6. The following apply to update statements. Let 

C = V 

be a set_item within an update_statement. Let D be DOMAIN(C). Then 

a. If V is null, D shall not be a not null only domain. 

b. Otherwise, if v is a value_expression. v shall conform to D (see 6.4 of this specification). 

SQL Semantics 


This clause describes the text of an SQL statement corresponding to the statement within a procedure. 

1. The transformations SQLy^ and SQLsc sre applied to all value expressions and search condi¬ 
tions in the statement. 

2. The insert_statement_row is transformed into an SQL_insert_statement by transforming each 
insert_value_list and the insert_column_list as described in 8.8 of this specification and drop¬ 
ping any insert_from clause. The remainder of the statement is unchanged. 

3. The select_statement is transformed into an SOL_select_statement: single row by 

a. Replacing the selectjist with the SQL_selectJist described in 8.7 of this specification. 

b. inserting the phrase INTO target list, where target list is as specified in 8.7 of this specification, and 
removing the into_clause in the statement, if any. 

The remainder of the statement is unchanged. 

8.4 Cursor Declarations 

cursor_declaration 

[extended] cursor identifier„l [insensitive] [scroll] 

[input_parameter_list] 

for 

cjuery 

[ is cursor_procedures 
end [identifier_2];] 

query ::= 

cursor_specification | extended_cursor_specification 

1 . Identifier_1 is the name of the cursor. If present, identifier_2 shall be equivalent to identifier_1. 

2. No two procedures within a cursor_declaration shall have the same name. 

3. For each column C, INTER_TYPE(DOMAiN(C)) shall not be none. See the Ada and SQL Se¬ 
mantics sections, below. 

4. A query may be an extended_cursor_specification only if the keyword extended appears in the 


44 Database Programming Language - SAMeDL 



VERSION 2 


cursor declaration. If the keyword extended appears in the cursor declaration, then the key¬ 
word extended shall appear in the declaration of the module in which the cursor is declared 
(see 6.6 of this specification). 

A cursor_specification is identical to an SQL cursor_specification except that 

1. Value expressions as defined in 8.10 replace SQL value expressions; 

2. Search conditions as defined in 8.11 replace SQL search conditions; 

3. The select list defined in 8.7 of this specification replace the SQL select list in the contained 
query specification. However, any select list within a subquery of the contained query specifi¬ 
cation is not replaced in this way. See 7.11 of ISO 9075:1992. 

Ada Semantics 

If a cursor named C is declared within an abstract module named M, then a subpackage named C shall exist 
within the Ada package M (see 8.1 of this specification). That subpackage shall contain the declarations of 
the procedures declared in the sequence cursor_procedures. (Some of those procedures may appear by 
assumption. See 8.5 of this specification.) The text of the procedure declarations is described in 8.5 of this 
specification. 

If the query in a cursor declaration is an extended_cursor_specification, see 6.6 of this specification. 


As a consequence of the rules of SQL (see ISO/IEC 9075:1992 7.5 and 7.10), the query_expression within 
a cursor_specfication has a definition in the form 

El [OP Ej] 

where op is a set operator and the two query_expressions, Ei and E2, define tables of the same length. Let 
that length be m and let C^j and C^j for 1 < i < m be the sequence of columns of those tables. Define the 
values AdaTYPEj, AdaNAMEj, DOMAINj and DBLngNAMEj for the i*^ column of the result, as follows. (We 
may assume, by recursion over the number of set operators in the query_expression, that these mappings 
are defined for C''| and C^j. See 8.7 of this specification.) 

1. The two columns shall have the same Ada type, that is, AdaTYPE(C^j) = AdaTYPE(C^j) (see 

8.7 of this specification). The Ada type of the i'*^ parameter, AdaTYPEj, is that type. This implies 

DOMAIN(C^j)=DOMAIN(C^j) and DQMAIN| is that domain. 

Note: This further implies that either (i) DOMAIN. Is a not null only domain, or (ii) not null is specified either for 
both or for neither of Cf and C^j. 

2. If AdaNAME(C^j) = AdaNAME(C^j), then AdaNAMEj shall be that name; AdaNAMEj shall be 
said to be specified if either of jOr C^j is a select parameter containing a named_phrase or 
either AdaNAME(C^) or AdaNAIVE(C j) is specified. If AdaNAME(CV) 9 !: AdaNAME(C^j), then 
if exactly one of AdaNAME(C'' j) or AdaNAME(C^j) is specified, AdaNAMEj shall be that name. 
Otherwise, AdaNAMEj = NO_NAME. 

3. If either DBLngNAME(C^j) or DBLngNAME(C^|) is defined, then both shall be defined and shall 
be equivalent; DBLngNAMEj shall be that name. If neither is defined, then DBLngNAMEj is said 
to be null; otherwise, DBLngNAMEj is undefined. 


Abstract Module Description Language 45 



VERSION 2 


The type of the row record parameter is equivalent in the sense of 3.2.10 and 3.7.2 of ISO/IEC 8652:1995, 
to a record type whose sequence of components is given by the sequence 

... COMPAda(Cj) [DBLengAda(Cj)] ... 
where COMPAda(SPj) is given by 

AdaNAME, : AdaTYPE. 

1 1 

provided\ha\ AdaNAMEj and AdaTYPEj are defined; the record component COMPAda(Cj) is otherwise un¬ 
defined. The record component DBLengAda(Cj) is given by 

DBLngNAME^ : Ada_Indicator_Type 

where Ada_lndicator_Type is the type SQL_Standard.lndicator_Type (see 12.3.8.a.iii in ISO/IEC 
9075:1992), prov/decf that DBLngNAMEj is defined. If DBLngNAMEj is null, this component is not present 
in the row record parameter. 

SQL Semantics 

From a cursor_specification, two SQL fragments are derived: 

1. A list of SOL_parameter_declarations. 

2 . An SQL_fetch_target_list. 

These are defined on the basis of the components of the row record parameter as described above. 

- There are two SQL parameters declared for each component COMPAda(Cj). They are PARM- 

SQL(Cj) and INDICsQL(Cj), where the SQL_parameter_declaration declaring PARMsQL(Cj) is 

: SQLname () INTER_TYPE (DOMAIN^) 

and the SQL_parameter_declaration declaring INDICsqlCCj) is 
: INDIC^ame indicator_type 

where SQL[vjAME(Cj) and INDICNAME(Cj) S'"® SQL_identifiers not appearing elsewhere. 

- The target list generated from a select_list is a comma-separated list of SQ/._target_specifica- 
tions (6.2 of ISQ/IEC 9075:1992). The i^^ SQL_target_specification in the target list is 

:SQLname(C^) indicator : INDICname (C^) 

Note: All derived target specifications contain indicator parameters, irrespective of the presence or absence of a 
not_null phrase In the select parameter declaration. 

A cursor declaration is transformed into an SQL cursor declaration as follows. 

1. The string “declare” is prepended to the cursor declaration and, if present, the keyword extend¬ 
ed is dropped. 

2 . The input_parameter_list and cursor_procedures are discarded, as is the keyword cursor and 
the is ... end bracket. The cursor name identifier_1 is transformed into SQLNAME(identifier_1). 

3. The string “cursor” is inserted immediately after the transformed cursor name, but before the 
keyword for. 

4. The selectjist of any contained query expression is transformed into an SQL_select_list as de¬ 
scribed in 8.7 of this specification. 


46 Database Programming Language - SAMeDL 



VERSION 2 


5 . The search conditions are transformed using the transform SQLsc of 8.11 of this specification. 
The remainder of the declaration is unchanged. 


Note: Examples 

The following note consists of two examples of cursor.declarations: the first contains a simple cursor_declaration, while the second 
contains a more complex declaration that exercises many of the features of the syntax. In both cases the generated Ada code is shown, 
annotated with references to the appropriate clauses of the language definition. 


The example below is a simple cursor_declaration. 

cursor Select_Suppliers (Tiine_Limit : DB_Date_String) 

for 

select SNO, SNAME, "STATUS", CITY dblength — 5.3 

from S, SP 

where S.SNO = SP.SNO and 

Date_Order = CAST(TIMR_LIMIT As DB_Date); 


This declaration produces the following Ada code. 

package Select_Suppliers is -- 8.4: Ada Semantics 
type Row_Type is record-- 8.5, #5 and #8 

Sno : Supplier_Numbers_Type;— 8.5, #3 and #8 

Sname : Supplier_Names_Type; 

STATUS : Status_Values_Type; 

City : City_Names_Type; 

City_Dblength : SQL_Standard.Indicator_Type; 

end record; 

procedure Open (Time_Liinit : in DB_Date_Strings_Type) ;8.5: #3 
procedure Fetch (-- 8.5: #5 

Row : in out Row_Type; -- 8.5: #8 and Ada Semantics #3 

Is_Found : out boolean);-- 8.5: #5 and Ada Semantics #6 

procedure Close;-- 8.5: #4 

end Select_Suppliers; 

The following is an example of a more complex cursor_declaration. 

cursor Supplier_Operations ( 

Input_City named Supplier_City : City_Names not null; 

Adjustment niuned Status_Adjustment : Status_Values not null) 
for 

select SNO named Supplier_Number, 

SNAME named Supplier_Name, 

"STATUS" + Adjustment named Adjusted_Status,— 5.3 
CITY named Supplier_City 

from S 

where CITY = Input_City 


procedure C)pen_Supplier_Operations is 
open Supplier_Operations; 
procedure Fetch_Supplier_Tuple is 
fetch Supplier_Operations 

into Supplier_Row_Record : new Supplier_Row_Record_Type 
status My_Map naxned Fetch_Status; 
procedure Close_Supplier_Operations is 
close; — optional "cursor name" omitted 
procedure Update_Supplier_Status { 

Input_Status named Updated_Status : Status_Values not null; 
Input_Adjustment named Adjustment : Status_Values) is 

update S 

set "STATUS" = Input_Status + Input_Adjustment — 5.3 
where current of Supplier_Operations; 
procedure Delete_Supplier is 

delete from S; — optional "where current of "cursor name"" omitted 

end Supplier_Operations; 


Abstract Module Description Language 47 




VERSION 2 


This declaration produces the following Ada code, 

package Supplier_Operations is -- 8.4: Ada Semantics 

type Supplier_Row_Record_TypG is 
record-- 8.5: Ada Semantics #5 #8 

Supplier_Number : Supplier_Numbers_Type; 

-- 8.5: Ada Semantics #3 #8 

Supplier_Name : Supplier_Names_Type; 

Adjusted_Status : Status_Values_Type; 

Supplier_City : City_Names__Type ; 
end record; 

procedure Open_Supplier_Operations { 

Supplier_City : in City_Names_Not_Null;8.5: Ada Semantics 

Status_Adjustment : in Status_Values_Not_Null); -- #1, #3, Modes 

procedure Fetch_Supplier_Tuple ( 

Supplier_Row_Record : in out Supplier_Row_Record_Type; -- 8.5 

FGtch_Status : out Operation_Status);-- 8.5 

procedure Close_SuppliGr„Operations; 

procedure Update_Supplier_Status ( 

Updated„Status : in Status_Values_Not_Null;-- 8.5: Ada Semantics #2 
Adjustment : in Status__Values_Type) ;— 8.5: Ada Semantics 

procedure Delete_Supplier; 

end Supplier_Operations; 

End Examples 


8.5 Cursor Procedures 

cursor_procedures ::= 
cursor_:procedure {cursor_procedure} 

cursor_procedure ::= 

[extended] procedure identifier_l 
[input_paraineter_list] is 
curs or_s t at ement 
[status_clause] 


cursor_statement ::= 

open_statement | fetch_statement | close_statement | 
update_statement_positioned | delete_statement_positioned| 
extended_curs©restatement 

The cursor statements are identical to the SQL statements except that 

1. Cursor names are optional, as is the “where current of’ phrase in the update and delete posi 
tioned statements. If the cursor name is present, it shall be equal to the name of the cursor with 
in which the procedure declaration appears. 

2 . The into keyword and fetch target list of an SQL fetch statement is replaced by an into clause, 
see 8.9 of this specification. 


Furthermore 

3. Identifier_1 is the name of the procedure. 

4. If no open_statement appears in a list of cursor_procedures, the declaration procedure "open" 
is open; is assumed. 

5. If no close_statement appears in a list of cursor_procedures, the declaration procedure "close" 
is close; is assumed. 

6 . If no fetch_statement appears in a list of cursor_procedures, the declaration procedure "fetch" 
is fetch status standard_map; is assumed. See 7.1.8 of this specification. 


48 Database Programming Language - SAMeDL 




VERSION 2 


7. The restrictions that apply to the set_items of a non-cursor update_statement (see 8.3 of this 
specification) also apply to the setjtems of a cursor_update_statement. 

8. If no into_clause appears within a fetch_statement, then the following clause is assumed: 

into Row : new Row_Type 

If an into_clause which does not contain a recordjd appears in a fetch_statement, the recor- 
d_id 

: new Row_Type 

is assumed. See 8.9 of this specification. 

9. A cursor_statement may be an extended_cursor_statement only if the keyword extended ap¬ 
pears in the cursor_procedure declaration. If the keyword extended appears in the cursor_pro- 
cedure declaration, then the keyword extended shall appear within the declaration of the cursor 
in which the cursor_procedure is declared. 

Ada Semantics 

Each procedure declaration P that appears in or is assumed to appear in a cursor_procedures list shall be 
assigned an Ada procedure declaration that satisfies the following constraints. 

- If P is declared within the declaration of a cursor named C, then P^^jg shall be declared within 

the specification of an Ada subpackage named C. 

- The simple name of P^^jg is AdalD(identifier_1), the name of P. 

Note: The default open, fetch and close procedures use delimited identifiers (see 5.3 of this specification) as their 
procedure names. 

The parameter profiles of the Ada procedures depend in part on the statement within the procedure, as fol¬ 
lows: 

1. For open_statements: Let INP.|, INPg, .... INP|^ /<> 0 be the list of input parameters in the in- 

put_parameter_list of the cursor_declaration within which the procedure appears. For all other 
statements, let this list be list of input parameters in the input_parameterjist of the procedure 

xU 

in which the statement appears. Then PARMAda(INPj), the i parameter of the Ac/a_formal_- 
part, is of the form 

AdaNAME(INP.) : in AdaTYPE(INP.) 

1 1 

for 

1 <i<k 

(see 8.6 of this specification). 

2 . For fetch_statements: The first parameter after any resulting from the input parameter list is a 
row record parameter of mode in out. The names, order, and types of the components of the 
type of this parameter are described in 8.2 and 8.4 of this specification. Let 1C be the into_- 
clause appearing (possibly by assumption) in the fetch_statement. Then the name of the row 
record formal parameter is PARMrovj,(/C), and the type of that parameter is TYPErow(/Q- See 
8.9 of this specification. If /C contains the keyword new, then the declarative region containing 
the declaration of P^^jg shall contain the declaration of TYPErow(/C)- 

3. For extended_cursor_statements, see 6.6 of this specification. For extended parameter lists, 
see 8.6 of this specification. 


Abstract Module Description Language 49 



VERSION 2 


4. For all statement types: If a status_clause referencing a status map that contains a uses ap¬ 
pears in the procedure declaration, then the final parameter is a status parameter of mode out. 
For the name and type of this parameter, see 7.1.8 and 8.12 of this specification. 

SQL_Semantics 


Each procedure P that appears in or is assumed to appear in a cursor_procedures list shall be assigned an 
SQL procedure P 5 QL within the SQL module for the abstract module within which the cursor_procedures 
iist appears. ^SQL has three parts: 

1. An SQL_procedure_name. This is implementation defined. 

2. A list of SOL_parameter_declarations. An SQLSTATE parameter is declared for every SQL 
procedure unless a status clause appears in the procedure declaration that references a status 
map specifying sqlcode, in which case an SQLCODE parameter is declared. (See 7.1.8 and 
8.12 of this specification.) Other parameters depend on the type of the statement within the pro¬ 
cedure P. 


a. If the statement is an open_statement, then the SQL parameters derived from the inpuLparame- 
terjist of the cursor_deciaration, othenwise the SQL parameters derived from the inpuLparame- 
ter_list of the procedure, if any, as described in 8.6 of this specification appear in the parameter 
declarations of P 5 q|_- 

b. If the statement is a fetch_statement, then the SQL parameters determined by the query of the 
cursor_declaration (as described in 8.4) of this specification appear in the parameter declarations 

^SQL- 

The order of the parameters within the list is implementation defined. 

3. An SQL_SQL_data_statement or SQ/._SQL_data_change_statement. (See 12 . in ISO/IEC 
9075:1992.) This is derived from the statement in the procedure declaration, as follows. 

a. If the statement is an open_statement, then the SQL_open_statement is open SQLname(CA 
where C is the cursor name. 

b. If the statement is a close_statement, then the SQL_close_statement is close SQLname(Q). 
where C is the cursor name. 

c. If the statement is the delete_statement_positioned 

delete from Id_l [where current of C] 

then the SQL_delete_statement_positioned is identical, up to the addition of the where phrase, 
where current of SQL|gAME(C), replacing the where phrase of the cursor_delete_statement, if 
present. 

d. If the statement is the update_statement_positioned 

Update Id__l 
set set_iterns 
[where current of C] 

then the SQL_update_statement_positioned is formed by applying the transformation SQLve de¬ 
fined in 8.10 of this specification to the value expressions in the set_items of the statement and ap¬ 
pending or replacing the where phrase so as to read where current of SQLname(C). 

e. If the statement is a fetch_statement, then the SQL_fetch_statement is 

fetch SQLj^^£(CJ into target list 

where C is the cursor name and target list as described in 8.4 of this specification. 


50 Database Programming Language - SAMeDL 



VERSION 2 


f. If the statement is an extended_statement, see 6.6 of this specification. 

Interface Semantics 

A call to the Ada procedure *^Ada shall have effects that can not be distinguished from the following: 

1. The procedure P 3 QL is executed in an environment in which the values of parameters PARM- 

Sql(INP) and INDICsql(INP) (see 8.6 of this specification) are set from the value of PARM/^. 
da(INP) (see Ada semantics above) according to the rule of 7.3 of this specification for every 
input parameter, INP, in either the input_parameterjist of the cursor_declaration for open pro¬ 
cedures, or the input_parameter_list of the procedure itself for update procedures. 

2 . Standard post processing, as described in 6.5 of this specification, is performed. 

3. If the value of the SQL status parameter indicates successful completion or if it is handled by a 
status map attached to the procedure (see 6.5 of this specification) and is defined by the SQL- 
implementation to permit the transmission of data and the statement within the procedure is a 
fetch_statement, then the value of the row record components COMPAcja(SPj) and DBLengA- 
tja(SPj), are set from the values of the actual parameters associated with the SQL formal pa¬ 
rameters PARMsQL(SPj) and INDICsQL(SPj) (see 8.4 and 8.7 of this specification) according 
to the rule of 7.3 of this specification. 

8.6 Input Parameter Lists 

Input parameter lists declare the parameters of the procedure, cursor, or cursor procedure declaration in 
which they appear. The list consists of parameter declarations that are separated with semicolons, in the 
manner of Ada formal parameter declarations. 

Each parameter declaration of a procedure or cursor procedure P is represented as an Acfa_parameter_- 
specification within the Ada_formaLpart of the procedure each parameter declaration within a cursor 
declaration is represented as an Acfa_parameter_specification within the Ada_formaLpart of the Ada open 
procedure. The parameter is also represented as either one or two SQL_parameter_declarations within the 
SQL_procedure P 5 q|_- The second SQL parameter declaration, if present, declares the indicator variable 
for the parameter (see 4.17.2 of ISQ/IEC 9075:1992). 

The order of parameter specification within the AcfaJormaLpart is given by the order within the input_pa- 
rameterjist. The order of the SQL_parameter_declarations within the list of declarations in the SQL proce¬ 
dure is implementation defined. 

input_paraineter_list :: = 

(parameter {; parameter}) 

parameter ::= 

parameterename [named_phrase] : 

[in] [out] domain_reference [not null] 

parameter_name identifier 


Ada Semantics 

Let INP be a parameter the textual representation of which is given by 


Abstract Module Description Language 51 



VERSION 2 


Id_l [named Id_2] : [in] [out] [Jd_3.]Id_4 [not null] 

then ld_1 is the name of the parameter. 

The domain associated with INP, denoted DOMAIN(INP), is the domain referenced by [ld_3.]ld_4. Let DO- 
MAIN(INP) = D; then DATACLASS(INP) = DATACLASS(D). INTER_TYPE(D) shall not be none. 

The functions AdaNAME and AdaTYPE are defined on parameters as follows; 

1. If ld_2 is present in the definition of INP, then AdaNAME(/A/P) = AdalD(/oL2) otherwise, AdaN- 
AME(/AfP) = AdalD(/cL7). For no two parameters, INP^ and INP^ in an input parameter list 

shall AdaNAME(/A/P^) = AdaNAME(/A/P 2 )- 

2. AdaTYPE(/A/P) shall be the name of a type within the domain identified by the domain_refer- 
ence [ld_3.]ld_4. If not null appears within the textual representation of INP, orthe domain 
identified by the domain_reference is not null only, then AdaTYPE(/A/P) shall be the name of 
the not null-bearing type within the identified domain; otherwise it shall be the name of the null¬ 
bearing type within that domain (see 7.1.3 of this specification). 

The optional out may occur only in a parameter that is associated with a procedure or cursor that is extend¬ 
ed. The optional in, however, may be included in any parameter declaration. 

Given INP as defined above, define mode(/A/P) to be 

- In, if INP either contains (1) the optional in, but not the optional out, or (2) neither in nor out. 

- out, if /A/P contains out but not in. 

- in out, if INP contains both in and out. 

Then the generated parameter, PARMAcia(INP). in the AdaJormaLpart is of the form 

AdaNAME(JWP) : mode(JNP) AdaTYPE(JNP) ; 

SQL Semantics 

Let INP be as given above and let D be the domain referenced by [ld_3.]ld_4. The SQL parameter PARM- 
sql(INP) is declared by the following SO/._parameter_declaration 

: SQLjjame () INTER_TYPE ( D) 

where INTER_TYPE(D) is given in 7.1.3 of this specification. If not null does no/appear within the textual 
representation of INP, and [ld_3.]ld_4 does no/identify a not null only domain, then the parameter INDIC- 
sql(INP) is defined and is declared by the SQ/._parameter_declaration 

: INDICjjame ( indicator_type 

Where indicatorjype is the implementation-defined type of indicator parameters (Syntax Rule 1 of 6.2 of 
ISO/IEC 9075:1992). The name INDICname(INP) shall not appear as the name of any other parameter of 
the enclosing procedure. 


52 Database Programming Language - SAMeDL 



VERSION 2 


8.7 Select Parameter Lists 

Select parameter lists serve to inform the DBMS of what data are to be retrieved by a select or fetch state¬ 
ment. They also specify the names and types of the components of a record type —^the so called row record 
type—^which appears as the type of a formal parameter of Ada procedure declarations for select and fetch 
statements. 


seiect_iist : := * I select_parameter{, select_parameter} 

selectj)araineter :; = 

value_expression [named^phrase] [not null] 

[dblength [nained_phrase] ] 

1. The select list star (“*”) is equivalent to a sequence of select parameters described as follows: 

Let T.|, Tg.T|^ be the list of the exposed table names in the table expression from clause 

for the query specification in which the select list appears (see 7.9 of ISO/IEC 9075:1992). Let 
Uj, for 1 < i < k be defined as Sj _ Vj if T| is of the form Sj.Vj (i.e., Sj is a schema_module_name, 

and Vj is a table name); otherwise, Uj is T|. In other words, Uj is Tj with every dot replaced 

by an underscore Let Aj , Aj 2 , • • •, Aj ^.^j be the names of the columns of the table named 

Tj. Then the select list is given by the sequence T.| .A.| ^ named U.( _ A.| .j, T.| .A.| 2 named U.| 

_ A.J 2 > • • • > Tj.Aj j named Uj _ Aj j, ... , T|^.A|^ named U|^ _ Aj^ That is, the columns are 

listed in the order in which they were defined (see 7.2 of this specification) within the order in 
which the tables were named in the from clause. 

Notes: This definition differs from that given in syntax rule 3.b of 7.9 in ISO/IEC 9075:1992 in specifying that the 
column references are qualified by table name or correlation name. The table that is described in the cited rule of 
SQL has anonymous columns. The record type being described must have well-defined component names. 

Use of * as a select list in an abstract module is considered poor programming practice. The interpretation of * is 
subject to change with time as the database design changes. Programs that use * as a select list present mainte¬ 
nance difficulties not presented by programs supplying a proper select list. 

In the following discussion, assume that a select list has been replaced by its equivalent list, 
as described above. 

2. If the keyword dblength is present, then value_expression shall have the dataclass character. 

3. Let VE be the value_expression appearing in a select_parameter. DOMAIN(VE) shall not be 
NO_DOMAIN and VE shall conform to DOMAIN(VE). 

Ada Semantics 


Let SP be a select parameter written as 

VE [neuned Id_l] [not null] 

[dblength [named Id_2] ] 

SP is assigned the Ada type name AdaTYPE(SP), the Ada name AdaNAME(SP) and the dblength name 
DBLngNAME(SP) as follows: 

- Let DOMAIN(VE) = D (see 8.10 of this specification) where NO_DOMAIN. If not null ap¬ 
pears in SP, or D is a not null only domain, then AdaTYPE(SP) is the name of the not null-bear¬ 
ing type name within the domain D; else AdaTYPE(SP) is the name of the null-bearing type 
within the domain D. 


Abstract Module Description Language 53 



VERSION 2 


- If DOMAIN(VE) = NO_DOMAIN then AdaTYPE(SP) is undefined. 

- If ld_1 appears in SP, then AdaNAME(SP) = AdalD{/cLr); else AdaNAME(SP) = AdaN- 
AME(VE) (see 8.10 of this specification). 

- If the dblength phrase appears in SP, then 

- if ld_2\s present then DBLngNAME(SP)=AdalD(/aL2) 

- else, DBLngNAME(SP)=AdaNAME(SP)_DbLength 

Otherwise, DBLngNAME(SP) is undefined. 

- DBLngNAME(SP) and AdaNAME(SP) shall not appear as either DBLngNAME(SP|) or as 
AdaNAME(SPj) for any other select_parameter SP| within the select_list that contains SP. 

SQL Semantics 

From a selectjist, three SQL fragments are derived: 

1. An SQ/._selectJist within a select statement or cursor declaration. 

2 . A list of SO/._parameter_declarations. 

3. Either an SQL_select_target_list within a select statement or an SQL_fetch_target_list within a 
fetch statement. 

An SOL_select_list is derived from a selectjist as follows: 

- The selectjist * becomes the SQL_selectJist *. 

- Otherwise, suppose SP.|, SP 2 ,..., SP^.^ is a select_list, where SPj is given by: 

VE^ [named Jd_I^] [not null]^ [dblength^ [named Id_2^] ] 

The SQL_select list, SP’.,, SP’ 2 , ..., SP’^^ is formed by setting SP’, to SQLve(VE|). 

For the purpose of defining the SOL_parameter_declarations and target list generated from a select_list, let 
SPi, SP 2 ,.... SP^, be the select_list supplied or the select_list that replaced the selectjist * as described 
above. Let each SP, be as given above. Then 

- There are two SQL parameters associated with each select_parameter, SP,. They are PARM- 
SQL(SPj) and INDICsQL(SPj), where the SQL_parameter_declaration declaring PARMsQL(SPj) 
is 

: SQLname ( ) INTER_TYPE (DOMAIN (VE^ ) ) 

and the SQL_parameter_declaration declaring INDICsQL(SPj) is 
: INDICjj;y.iE(SPj^) indicator_type 

where SOLmameCSP,) and INDiCNAME(SPj) are SQLJdentifiers not appearing elsewhere. 

- The target list generated from a select_list is a comma-separated list of SQ/.Jarget_specifica- 
tions (6.2 of ISO/IEC 9075:1992). The i^^ SOLjarget_specification in the target list is 

: SQLname (SP^) INDICATOR : INDICname (SP^) 


54 Database Programming Language - SAMeDL 




VERSION 2 


Note: All derived target specifications contain indicator parameters, irrespective of the presence or absence of a 
not_null phrase in the select parameter declaration. 

8 8 Insert Column Lists and Insert Value Lists 

insert_coluinn_list :: = 

insert_coliainn_specification {, insert_coluinn_specification) 

insert_coluinn_specification :: = 
coluinn_name [named_phrase] [not null] 

insert_value_list ::= 

insert_value {, insert_value} 

insert_value ::= 
null I constant_reference 
literal | column_naine 
domain_paraineter_reference 

Each column_name within an insert_column_list shall specify the name of a column within the table into 
which insertions are to be made by the enclosing insert_statement_row. (See 8.3 of this specification and 
13.8 in ISO/IEC 9075:1992.) 

Let C be the insert_column_specification 

Col [named Id] [not null] 

Then AdaNAME(C) is defined to be A6a\D{ld), if Id is present; otherwise it is AdalD(Co/). Let DOMAIN(C) 
= DOMAIN(Col) = D be the domain assigned to the column named Col. If not null appears in C, or D is a 
not null only domain, then AdaTYPE(C) is the name of the not null-bearing type within the domain D; other¬ 
wise, AdaTYPE(C) is the null-bearing type within the domain D. 

INTER_TYPE(D) shall not be none. 

Let CL = C.J.be an insert_column_list; let /L = V.|,... be an insert_valuejist. CL and IL are said 

to conform if: 

1 . m = n, that is, the length of the two lists is the same. 

2. For each 1< i< m, if VA is 

a. null, then DOMAIN(Cj) shall not be a not null only domain. 

b. A literal or a reference to either a constant or a domain parameter, then V- shall conform to 
DOMAIN{Cj) (see 6.4 of this specification). 

c. A column_name, then V- shall be identical to the column_name in Cj. 

Ada Semantics 

The insert_value_list of an insert_statement_row defines the components of an Ada record type declaration. 
The names, types and order of those components are defined in 8.2 of this specification on the basis of the 
functions AdaNAME and AdaTYPE described above. For the name of the record type and its place of dec¬ 
laration, see 8.9 of this specification. 

Note: If the insert_valuejist contains only constants and literals, then the Ada procedure corresponding to the procedure 
containing the insert_statement_row statement of which these lists form a part does not have a row record parameter. See 
8.2 of this specification. 


Abstract Module Description Language 55 



VERSION 2 


SQL Semantics 

There is an SQL parameter corresponding to each insert_value in an insert_value_list that is a column_- 
name. So let Cbe such a column_name. Then the SQL parameter declaration PARMsqi_(C) is given by 

: SQLname (C) INTER_TYPE (DOMAIN (C) ) 

where 

1. SQLname(Q is an implementation-defined identifier that does not otherwise appear in the en¬ 
closing procedure. 

2. INTER_TYPE(DOMAIN(C)) is as defined in 7.1.3 of this specification. 

Assuming the conformance of the insert_valuejist with the insert_column_list of the enclosing statement 
(see above), an entry of the form 

C [named Id] [not null] 

appears in the insert_columnJist. If not null does not appear and the domain DOMAIN(C) is not not null 
only, then the parameter INDICsql(C) is defined and the parameter declaration 

: INDICfjAME indicator_type 
also appears in the list of SQL parameter declarations, where 

1. INDICname(Q is 3n implementation-defined identifier that does not otherwise appear in the en¬ 
closing procedure. 

2. indicatorjype is the implementation-defined type of indicator parameters (6.2 in ISQ/IEC 
9075:1992). 

An insert_column_list and insert_value_list pair are transformed into an SQ/._insert_column_list and SQL_- 
table_value_constructor pair (see 7.2 and 13.8 of ISQ/IEC 9075:1992) as follows: 

1. An insert_columnJist is transformed into an SQ/._insert_column_list by the removal of all 
named_phrases and not_null phrases that appear in it. 

Note: This implies that the empty insert_column_list is transformed into the empty SOL_insert_column_list. 

2 . Each insert_value_list is transformed into an SQ/._table_value_constructor by replacing each 
list element as follows: 

a. A literal, or null (but excluding any enumeration literal), is replaced by itself; i.e., is unchanged. 

b. A constant_reference or enumeration literal k is replaced by a textual representation of its data¬ 
base value SQLvE(/f) (see 7.3 and 8.10 of this specification). 

c. A column_name Co/| is replaced by 

: SQLname (Col^) [ INDICATOR : INDICjjame ( C^ ) ] 

where the INDICATQR phrase appears whenever the indicator parameter, INDICsql(C ), is defined 
(see above). ' 

The resulting list is enclosed in parentheses. 


56 Database Programming Language - SAMeDL 



VERSION 2 


8.9 lnto_Clause and lnsert_From_Clause 

An into_clause is used within a select_statement or a fetch_statement, and an insert_from_clause is used 
within an insert_statement„row to explicitly name the row record parameter of those statements and/or the 
type of that parameter. 

into_clause ::= 
into into_from_body 
insert_from_clause ::= 
from into_froin_body 
into_from_body : : = 
identifier_l : record_id | 
identifier_l | 

; record_id 
record_id : : = 

new identifier_2 | record_reference 

Ada Semantics 

Define the string PARMf^Q^(IC) as follows, where 1C is an into_clause or insertJrom_clause. 

1 . If identifier_1 appears in 1C, then PARM^^y^jilC) = AdalD(identifier_1). 

2. Otherwise, if record_id is a record_reference referencing the record declaration R, then PARM- 
Row(/C) = AdaNAME(fl). See 7.1.5 of this specification. 

3. Otherwise, PARMf^Qy^{IC) = Row. 

Define TYPERoy^,{/C) as follows: 

1 . If record Jd has the form 

new identifier_2 

then TYPErqvv(/C) = AdalD(identifier_2). 

2 . Otherwise, TYPErovv(^ 0 is the record type referenced by the record_reference. 

Note: The assumptions made about into_clause and insei1_from_clause In 8.3 and 8.5 of this specification are sufficient to 
ensure that every such clause contains a record Jd, possibly by assumption. Therefore, the case of a missing record Jd need 
not be considered in the definition of TYPE^q^{IC). If the recordjd is a record_reference, then the names, types, and order 
of the components of the referenced record must exactly match the names, types, and order of the components of the record 
type declaration that would have been generated had the recordjd been “new Identifier” (see 8.4, 8.2, and 8.7 of this spec¬ 
ification). 

Note: Examples 

The following is a set of example procedure declarations that Illustrate various uses of Into and from clauses. It is assumed that each 
of these procedures is declared within an abstract module, and that any enumeration, record, and status map declarations used are 
visible at the point at which each procedure is declared. Declarations for these constructs can be found in 7.1.6, 7.1.5, and 7.1.8 of 
this specification, respectively. In addition, it is assumed that the abstract modules in which these procedures are declared have direct 
visibility to the contents of the Parts_Suppliers_Database schema module shown in the examples in 7.2 of this specification. 


Abstract Module Description Language 57 




VERSION 2 


The two examples below illustrate the use of a previously declared record object in the into clauses of select statements. The cursor 
and the select statement retrieve the same object, namely a part. The row record, Parts_Row_Record_Type (see 7.1.5 of this speci¬ 
fication), contains the definition of the part abstraction. 

cursor Parts_By_CitY ( 

Input_City named Part_Location : City not null) 
for 

select PNO named Part_Number not null, 

PNAME named Part_Name, 

COLOR, 

Weight_In_Grains (WEIGHT * Grams_In_Pound) named Weight, 

-- 8.10, 7.1.4 

CITY 

into Parts_By_City_Row : Parts_.Row_Record_Type 

from P 

where CITY = Input_City 


procedure Parts__By_NurrLber ( 

Input_Pno named Part__Nuinber : Pno not null) is 
select PNO named Part__Nuiriber not null, 

PNAME named Part_Name, 

COLOR, 

Weight_In_Grams(WEIGHT * Grams_In_Pound) named Weight, 
-- 8.10, 7.1.4 

CITY 

into Parts_By_Nuinber_Row : Parts_Row„Record_Type 

from P 

where PNO = Input_Pno 

status Operation_Map named Parts_By_N\iniber_Status 


The above declarations produce the following Ada declarations at the abstract interface, 
package Parts_By_City is 
procedure Open ( 

Part_Location : in City_Names_Not_Null);— 8.5: Ada Semantics 

procedure Fetch ( 

Part s_By_City_Row 
-- 8.5: Ada Semantics #3 
Is_Found 

procedure Close; 
end Parts_By_City; 

procedure Parts_By_Nuinber ( 

Part_Number : in Part_Numbers_Not_Null; 

-- 8.2: Ada Semantics 

Parts_By_Number_Row : in out Parts_Row_Record„Type; 

Parts_By„Number_Status : out Operation_Status); 

The select procedure below illustrates the use of an into clause to specify the name and type of the generated row record parameter. 

procedure Part_Name_By_Number ( 

Input_Pno named Part_Number : Part_Numbers not null) is 
select PNAME named Part_Name 

into Part_Name_By_Number„Row : new Part_Name_Row_Record_Type 

from P 

where PNO = Input_Pno 
status Standard__Map 


: in out Parts_Row_Record_Type; 

: out boolean);-- 8.5: Ada Semantics #6 


The above declaration produces the following Ada record type and procedure declarations at the abstract interface. 


type Part_Name_Row_Record_Type is record -- 8.2: Ada Semantics 
Part_Name : Part__Names_Type;— 8,2 

end record; 


procedure Part_Name_By_Nuinber ( 

: in Part_Nuinbers_Not__Null ; 

Part_Name_By_Number_Row : in out Part_Name_Row_Record_Type; 
Is_Found : out boolean); 


58 Database Programming Language - SAMeDL 



VERSION 2 


The example declaration below uses the default from clause, which produces a record_declaration at the abstract interface, 
procedure Add_To_Suppliers is 

insert into S (SNO, SNAME, "STATUS", CITY)-- 5.3 

values 

status Operation_Map named Insert_Status 


The procedure_declaration above produces the following Ada code at the abstract interface. 

type Add_To_Suppliers_Row_Type is record -- 5.3: #1 

Sno : Supplier_Nurtibers_Type;— 5.2: Ada Semantics, 

Sname : Supplier_Names_Type;--Parameter Profiles, #3 

STATUS : Status_Values_Type;5.8: Ada Semantics 

City : City_Names_Type; 

end record; 

procedure Add_To_Suppliers ( 

: in Add_To_Suppliers_Row_Type;-- 5.2: Ada Semantics 
Insert_Status ; out Operation_Status); 

This last example illustrates an insert values procedure declaration where all of the values are literals; therefore, no row record param¬ 
eter is needed for the procedure declaration at the interface. 

procedure Add_To_Parts is 

insert into P (PNO, PNAME, COLOR, WEIGHT, CITY) 
values ('P02367', 'RIGHT FENDER: TOYOTA', Red, 25, 

'PITTSBURGH') 

status Operation_Map named Insert„Status 


The above declaration produces the following Ada procedure declaration at the abstract interface. 

procedure Add_To_Parts ( -- 5.8: Ada Semantics, Note 
Insert_Status : out Operation_Status); 


End Examples 


8.10 Value Expressions 

A value expression is a value expression of SQL with the following modifications. 

1 . Enumeration literals, domain parameters and constants are added to the class of expressions. 

2. If D is a domain name and VE is a value expression, then the domain conversion D(VE) is a 
value expression. 

3. The syntactic classes parameter specification and variable specification (see 6.2 of ISO 
9075:1992) are replaced with the syntactic class parameter (see 8.6 of this International Stan¬ 
dard): similarly, the classes parameter name and embedded variable name are replaced with 
identifier. 

Note: This removes the colon from the front of parameter names and eliminates INDICATOR variables. 


Four mappings are defined on value_expressions; SQLve, AdaNAME, DOMAIN, and DATACLASS. 


SQLve fiisps a value expression to an SQL value expression. It is described in the section “SQL Seman¬ 
tics.” below. 


The mapping AdaNAME calculates the default names of row record components when value expressions 
appear in select parameter lists. It is defined as follows: 


Abstract Module Description Language 59 



VERSION 2 


For any value expression VE, AdaName(VE) is the special value NO_NAME except when VE is an 
identifier that is the simpie name of an input parameter, constant, domain parameter or column, in 
which case AdaNAME(VE) = VE. 

The mapping DATACLASS assigns a data class to each well-formed value expression. It is defined as foi- 
lows. 

If VE is an enumeration literal or DOMAIN(VE) is an enumeration domain, then DATACLASS(VE) 
is enumeration. Otherwise, DATACLASS(VE) is the data type of SQLve(VE) as defined by ISO 
9075:1992 providedXha\ data type is not numeric. Otherwise, DATACLASS(VE) is one of integer, 
fixed or float defined as follows: 

a. The DATACLASS of a literal, constant, column reference or domain parameter reference is given 
in sections 5.4, 7.1.4, 7.2 and 7.1.1.1 of this Internationai Standard. 

b. The DATACLASS of any numeric value function shall be integer (see 6.6 of ISO 9075:1992) 

c. The DATACLASS(COUNT(VE')) shall be integer; DATACLASS(SUM(VE')), DATACLASS(M- 
IN(VE')) and DATACLASS(MAX(VE')) shall be DATACLASS(VE'). DATACLASS(AVG(VE')) shall 
be implementation defined (see rule 9 in 6.5 of ISO 9075:1992). 

d. DATACLASS(-hVE) and DATACLASS(-VE) is DATACLASS(VE). DATACLASS(VEi op VEs), for 
some arithmetic operator, op, shall be the greater of DATACLASS(VEi) and DATACLASS(VE 2 ), 
where float > fixed > integer. 

The DOMAIN mapping and Abstract Syntax Rules of an Expression 

The mapping DOMAIN assigns a domain to each well formed value expression. A value expression is well 
formed precisely when the DOMAIN mapping assigns it a domain. This section defines the DOMAIN map¬ 
ping and the abstract syntax (type matching rules) of value expressions. 

For any value expression, VE, SOLve(VE) shall conform to the rules of 6.11 ISO 9075:1992. DOMAIN(VE) 
is the special value NO_DOMAIN except when defined otherwise by one of the following rules. 

1 . If VE is an input reference, a reference to a constant, a domain parameter reference or a col¬ 
umn reference, then if O is the object referenced, DOMAIN(VE) is DOMAIN(O); 

2. If VE is the set function min ( ve ' ) or max ( ve '), then DOMAIN(VE)=DOMAIN(VE') (see 6.5 
in ISO 9075:1992); 

3. If VE is a character or bit substring function, a fold or a trim function, then DOMAIN(VE) is DO- 
MAIN(E) where E is the character value expression, bit value expression or trim source directly 
contained in VE (see 6.7 of ISO 9075:1992); 

4. If VE is a case expression, let (RE-), ... REn) be the set of result expressions of VE. Then 

• {RE^, ... REp) shall be domain compatible and 

• if for some i, DOMAIN(RE|) ^ NO_DOMAIN, then DOMAIN(VE)=DOMAIN(REi) provid¬ 
ed if DATACLASS(REj) is numeric, then the precision and scale of each result ex¬ 
pression, as determined by the rules of ISO 9075:1992, shall not exceed the precision 
and scale of DOMAIN(RE|) (see 6.9 and 9.3 of ISO 9075:1992); 

5. If VE is the cast specification CAST [ve' as d) or the domain conversion d(ve' ), then D 


60 Database Programming Language - SAMeDL 



VERSION 2 


shall be a domain name, not a data type and, if D is an enumeration domain VE' shall evaluate 
to a literal of D. DOMAIN(VE) =D; 

6 . If VE is a string value expression, date time value expression or interval value expression such 
that the operands of VE are domain compatible and for at least one operand Op, DOMAIN(Op) 

^ NO_DOMAIN, then DOMAIN(VE) = DOMAIN(Op) (see 6.12, 6.13, 6.14 and 6.15 of ISO 
9075:1992). 

7. If VE is the numeric value expression VE^ op VE 2 , let Ti=DATACLASS(VEi), T 2 =DATA- 
CLASS(VE 2 ). Di=DOMAIN(VEi), D2 =D0MAIN(VE2 ). VEi and VE 2 shall be domain compatible 
unless 

a. T^=T 2 = fixed and op is either multiplication (*) or division (/), or 

b. = fixed, 7^ = integer and = NO_DOMAIN and op is either multiplication (*) or 
division (/), or else 

c. T 2 = fixed, 7y= integer and = NO_DOMAIN and op is multiplication (*) 

If NO_DOMAIN, then DOMAIN(VE)=D1, else DOMAIN(VE)=D 2 , unless rule a applies, in which 
case DOMAIN(VE) = NO_DOMAIN. 

Note: These rules simulate Ada’s arithmetic restrictions. 

8 . If VE is a scalar subquery, then DOMAIN(VE) is the domain of the single column in the result 
of the subquery. See 8.4 of this specification. 

SQL Semantics 

The SQL value expression derived from a value expression VE is formed by removing all domain conver¬ 
sions and replacing all constants and domain parameters with their values and all enumeration literals with 
their database representations (see 7.3 of this specification). Let SQLve represent the function transforming 
value_expressions into SQL_value_expressions. Let VEbe a value_expression. SQLve( VE) is given recur¬ 
sively as follows: 

1 . If VE contains no operators, then 

a. If VE is a column reference or a database literal, then SQLve( VE) is VE. 

b. If VE is an enumerationjiteral of domain D, and D assigns expression E to that enumeration literal 
(see rule 7.1.3 of 7.1.3 of this specification), then SQLve( VE) = SQLve(E). 

c. If VE is a reference to the constant whose declaration is given by 

constant C [: D ] is E ; 
then SQLve(VE) = SQLve(E). 

d. If VE is a reference to a domain parameter P of domain D, and D assigns the expression E to P 
(see rule 7.1.3 of 7.1.3 of this specification), then SQLve(VE) = SQLve(E). 

e. If VE is a reference to the input parameter, INP, and PARMsql(INP) is :C T (for C an SQZ._ldenti- 
fier and T a data type, see 8.6 of this specification), then SQLve( V^ is 

: C [ INDICATOR : INDICname () ] 

Where INDICATOR INDICname(INP) appears precisely when INDICsql(INP) is defined. See 8.6 
of this specification. 


Abstract Module Description Language 61 



VERSION 2 


2 . If VE is a domain conversion D(VE'), then SQL\/e(VE) is 

SQLve(CAST (VE'AS D)) 

If VE is the cast specification 

CAST (VE' AS D) 

then SQLve(VE) is 

a. SQLve(VE'), if D is an enumeration domain, 

b. CAST(SQLve(VE’) as DBMS_TYPE(D)) othenA/ise. 

3. Otherwise, SQLve(VE) is formed by recursively applying the transformer SQLve to the subex¬ 
pressions of VE. 

8.11 Search Conditions 

The concrete syntax of search conditions differs from that of clause 8 of ISO/IEC 9075:1992 only in that 

1 . Value expressions replace SQL_Value_Expressions in the definitions of the atomic predicates; 

2 . The requirement of comparability in the definitions of the (atomic) SQL_predicates is strength¬ 
ened to require domain compatibility. See 6.4 of this specification. 

The conversion transformation SQLsc applied to a a search condition produces an SQZ._search_condition 
by applying the transformer SQLve to each value expression in the search condition. 

8.12 Status Clauses 

A status clause serves to attach a status map to a procedure and optionally rename the status parameter. 

status_clause 

status status__reference [named^phrase] 

Ada Semantics 

If a procedure P has a status_clause of the form 

status M [named Id_l] 
and the definition of Mwas given by 

enumeration T is /-J; 

status M 1 rr 

[named Id_2] 
uses T 

is n => L, ...); 

(see 7.1.8 of this specification), 

then: 

1. The procedure (see 8.2 and 8.5 of this specification) shall have a status parameter of type 
T. 

2 . The name of the status parameter of is determined by: 

62 Database Programming Language - SAMeDL 



VERSION 2 


a. If ld_1 is present in the status_clause, then the name of the status parameter shall be ld_1. 

b. If rule (8.12) does not apply, then if ld_2 is present in the definition of the status map M, the name 
of the status parameter shall be ld_2 (see 7.1.8 of this specification). 

c. If neither rule (8.12) nor rule (8.12) applies, then the name of the status parameter shall be Status. 

9 Conformance 

9.1 Introduction 

This International Standard specifies conforming SAMeDL language and conforming SAMeDL implemen¬ 
tations. 

Conforming SAMeDL language shall abide by the BNF Format and associated discussion of this specifica¬ 
tion. 

A conforming SAMeDL implementation shall process conforming SAMeDL language according to the Ada 
Semantics, SQL Semantics and Interface Semantics of this specification. 

9.2 Claims of Conformance 

9.2.1 Introduction 

Claims of conformance to this International Standard shall be to one or more of the following binding styles: 

a) conformance via mapping: 

b) conformance via effects. 

9.2.2 Conformance via mapping. 

An implementation claiming conformance via mapping shall, for each abstract module, generate an Ada li¬ 
brary unit package satisfying the Ada semantics of clause 8.1 of this specification. In addition, an implemen¬ 
tation claiming conformance via mapping shall specify one of the following binding substyles: 

i) conformance via SQL module; 

ii) conformance via embedded SQL Syntax. 

9.2.2.1 Conformance via SQL module. 

An implementation claiming conformance via SQL module shall, for each abstract module, generate an SQL 
module satisfying the SQL semantics of clause 8.1 of this specification. 


Conformance 63 


VERSION 2 


9.2.2.2 Conformance via embedded SQL Syntax. 

An implementation claiming conformance via embedded SQL Syntax shali, for each abstract moduie, gen¬ 
erate one or more embedded SQL host programs or program fragments, which program(s) or program frag- 
ments(s) shall conform to ISO/IEC 9075:1992. Such an implementation shall state which of the host pro¬ 
gramming languages listed in ciause 19 of ISQ/IEC 9075:1992 it generates. 

9.2.3 Conformance via effects. 

Although the processing of abstract modules is defined in terms of the derivation of a program conforming 
to the Ada programming language standard ISO/IEC 8652:1995 and the SQL Database Language ISO/IEC 
9075:1992, implementations of SAMeDL claiming conformance via effects are not constrained to foiiow that 
method, provided the same effect is achieved. 

9.2.4 Multiple claims of conformance. 

An impiementation claiming conformance in more than one of the styles of clause 9.2.1 may provide a user 
option as to which style is to be used. 

9.3 Extensions 

Conforming SAMeDL implementations shall not process SAMeDL language that is not conforming. Imple¬ 
mentation defined facilities may be included into conforming SAMeDL via the extensions facility provided 
by the SAMeDL (see 4.2.10 of this specification). Schema elements, table elements, statements, query ex¬ 
pressions, query specifications, and cursor statements may be extended. The modules, tables, views, cur¬ 
sors, and procedures that contain these extensions are marked (with the keyword extended) to indicate 
that they contain implementation defined functionality. 

Implementation defined functionality introduced by extensions may imply an implementation defined exten¬ 
sion of the list of reserved words and thereby may prevent proper processing of some texts that otherwise 
conform to the requirements of this specification. 


64 Database Programming Language 


SAMeDL 



VERSION 2 


Annex A SAMeDL_Standard 

The predefined SAMeDL definitional module SAMeDL_Standard provides a common location for declara¬ 
tions that are standard for all implementations of the SAMeDL. This definitional module includes the SAM¬ 
eDL declarations for 

- the exceptions SQL_Database_Error and NulLValue_Error (see 6.5 and 7.3 of this specifica¬ 
tion); 

- the SAMeDL standard base domains; 

- integer constants whose values are the SQLCODE values predefined in ISO/IEC 9075:1992; 

- the domains SQLSTATE_Domain and SQLSTATE_Class_Domain and constants of those do¬ 
mains, mirroring the constants defined in ISO/IEC 9075:1992; 

- the pre-defined Status Map Standard_Map. 

definition module SAMeDL_Standard is 
exception SQL_Database_Error; 
exception Null_Value_Error; 

-- SQLJnt Base Domain 

SQL_Int is based on the Ada type Interfaces.SQL.Int 
base domain SQL_Int 
(first : integer; 
last : integer) 

is 

domain pattern is 

'type [self]_Not_Null is new SQL__Int_Not_Null' 

'{ range [first] .. [last]};' 

'type [self]_Type is new SQL_Int;' 

'package [self]_Ops is new SQL_Int_Ops( 

'[self]_Type, [self]_Not_Null);' 
end pattern; 

derived domain pattern is 

'type [self]_Not_Null is new [parent]_Not_Null' 

'{ range [first] .. [last]};' 

'type [self]_Type is new [parent]_Type;' 

'package [self]_Ops is new SQL_Int_Ops(' 

'[self]_Type, [self]_Not_Null);' 
end pattern; 
subdomain pattern is 

'subtype [self]_Not_Null is [parent]_Not_Null' 

'{ range [first] .. [last]};' 

'type [self]_Type is new [parent]_Type;' 

'package [self]_Ops is new SQL_Int_Ops(' 

'[self]_Type, [self]_Not_Null);' 
end pattern; 

for not null type name use '[self]_Not_Null'; 
for null type name use '[self]_Type'; 
for data class use integer; 
for dbms type use integer; 

for conversion from dbms to not null use type mark; 
for conversion from not null to null use function 

'[self]_Ops.With_Null'; 

for conversion from null to not null use function 
'[self]_Ops.Without_Null'; 
for conversion from not null to dbms use type mark; 

end SQL_Int; 


SAMeDL.Standard 65 



VERSION 2 


-- SQL_Smalllnt Base Domain 

-- SQL_Sinallint is based on the Ada type Interfaces.SQL.Smallint 
base domain SQL_Sinallint 
(first : integer; 
last : integer) 

is 

domain pattern is 

'type [self]_Not_Null is new SQL_Smallint_Not_Null' 

'{ range [first] .. [last]};' 

'type [self]_Type is new SQL__Smallint; ' 

'package [self]_Ops is new SQL_Smallint_Ops(' 

' [self]_Type, [self ]_Not_.Null) ; ' 
end pattern; 

derived domain pattern is 

'type [self]_Not_Null is new [parent]_Not_Null' 

'{ range [first] [last]};' 

'type [self]_Type is new [parent]_Type;' 

'package [self]_Ops is new SQL_Smallint_Ops{' 

'[self]_Type, [self]_Not_Null);' 
end pattern; 
subdomain pattern is 

'subtype [self]_Not„Null is [parent]_Not_Null' 

'{ range [first] .. [last]};' 

'type [self]_Type is new [parent]_Type;' 

'package [self]_Ops is new SQL_.Smallint_Ops ( ' 

'[self]_Type, [self]_Not_Null);' 
end pattern; 

for not null type name use '[self]_Not_Null'; 
for null type name use ' [self ]__Type'; 
for data class use integer; 
for dbms type use smallint; 

for conversion from dbms to not null use type mark; 
for conversion from not null to null use function 

'[self]_Ops.With_Null'; 

for conversion from null to not null use function 
'[self]_Ops.Without_Null'; 
for conversion from not null to dbms use type mark; 

end SQL_Smallint; 

-- SQL_Real Base Domain 

-- SQL_Real is based on the Ada type Interfaces.SQL.Real 
base domain SQL_Real 
(first : float; 
last : float) 

is 

domain pattern is 

'type [self]_Not_Null is new SQL_Real_Not_Null' 

'{ range [first] .. [last]};' 

'type [self]_Type is new SQL_Real;' 

'package [self]_Ops is new SQL_Real_Ops(' 

'[self]_Type, [self]_Not_Null);' 
end pattern; 

derived domain pattern is 

'type [self]_Not_Null is new [parent]_Not__Null' 

'{ range [first] .. [last]};' 

'type [self]_Type is new [parent]_Type;' 

'package [self]_Ops is new SQL_Real__Ops ( ' 

'[self]_Type, [self]_Not_Null);' 
end pattern; 

subdomain pattern is 

'subtype [self]_Not_Null is [parent]_Not„Null' 

'{ range [first] .. [last]};' 

'type [self]_Type is new [parent]_Type;' 

'package [self]_Ops is new SQL_Real_Ops(' 


66 Database Programming Language ~ SAMeDL 



VERSION 2 


'[self]_Type, [self]_Not_Null);' 

end pattern; 

for not null type naime use ' [self ]_Not_Null' ; 
for null type name use '[self]_Type'; 
for data class use float; 
for dbms type use real; 

for conversion from dbms to not null use type mark; 
for conversion from not null to null use function 

'[self]_Ops.With_Null'; 

for conversion from null to not null use function 
'[self]_Ops.Without_Null'; 
for conversion from not null to dbms use type mark; 

end SQL_Real; 

-- SQL_Double_Precision Base Domain 

SQL_Double_Precision is based on the Ada type 
-- Interfaces.SQL.Double_Precision 
base domain SQL_Double_Precision 
(first : float; 
last : float) 
is 

domain pattern is 

'type [self]_Not_Null is new SQL_Double_Precision_Not_Null' 
'{ range [first] .. [last]};' 

'type [self]_Type is new SQL_Double_Precision;' 

'package [self]_Ops is new SQL_Double_Precision_Ops(' 

'[self]_Type, [self]_Not_Null);' 
end pattern; 

derived domain pattern is 

'type [self ]__Not_Null is new [parent] _Not_Null' 

'{ range [first] .. [last]};' 

'type [self]_Type is new [parent]_Type;' 

'package [self]_Ops is new SQL_Double_Precision_Ops(' 

'[self]_Type, [self]_Not_Null);' 
end pattern; 
subdomain pattern is 

'subtype [self]_Not_Null is [parent]_Not_Nul1' 

'{ range [first] .. [last]};' 

'type [self]_Type is new [parent]_Type;' 

'package [self]_Ops is new SQL_Double_Precision_Ops(' 

'[self]_Type, [self]_Not_Null);' 
end pattern; 

for not null type name use '[self]_Not_Null'; 
for null type name use '[self]_Type'; 
for data class use float; 
for dbms type use double precision; 
for conversion from dbms to not null use type mark; 
for conversion from not null to null use function 
'[self]_Ops.With_Null'; 

for conversion from null to not null use function 
'[self]_Ops.Without_Null'; 
for conversion from not null to dbms use type mark; 

end SQL_Double_Precision; 

- SQL_Numeric Base Domain 

-- SQL^Numeric is based on the Ada types 
-- in the package Interfaces.SQL.Numerics 
base domain SQL_Numeric 
(first : numeric; 
last ; numeric; 
digits : integer) 
is 

domain pattern is 

'type [self]_Not_Null is new' 

'Interfaces.SQL.Numerics.Scale_[scale] digits [digits];' 


SAMeDL.Standard 67 



VERSION 2 


^package [self]_Pkg is new SQL„Nuineric_Pkg ( ' 

'Scale_Type => [self]_not_null);' 

'type [self]„type is new [self ] _Pkg. SQL_Nuineric; ' 
'package [self]_Ops is new [self ]_Pkg, SQL_Nuineric_Ops ( ' 
'[self]_Type, [self]_Not_Null);' 
end pattern; 

derived domain pattern is 

'type [self]_Not_Null is new [parent]_Not_Null' 

'{ range [first] .. [last]};' 

'type [self]_Type is new [parent]„Type;' 

'package [self]_Ops is new [self]_Pkg.SQL_Numeric_Ops( 

'[self]_Type, [self]_Not„Null);' 
end pattern; 

subdomain pattern is 

'subtype [self ]__Not__Null is [parent ] _Not_Null' 

'{ range [first] .. [last]};' 

'type [self]_Type is new [parent]_Type;' 

'package [self]_Ops is new [self ]_Pkg. SQL„Nuineric_Ops ( 

'[self]_Type, [self]_Not_Null);' 
end pattern; 

for not null type name use '[self]_Not_Null'; 
for null type name use '[self]_Type'; 
for data class use numeric; 

for dbms type use 'numeric {[digits], [scale])'; 

for conversion from dbms to not null use type mark; 
conversion from not null to null use function 

'[self]_Ops.With_Null'; 

for conversion from null to not null use function 

'[self]_Ops-Without_Null'; 

conversion from not null to dbms use type mark; 

end SQL_Numeric; 


— SQL_Char Base Domain 

-- SQL_Char is based on the Ada type Interfaces.SQL.Char 

base domain SQL__Char 
is 

domain pattern is 

'type [self]NN_Base is new SQL_Char_Not_Null;' 

'subtype [self]__Not_Null is [self]NN_Base (1 [length]);' 
'type [self]_Base is new SQL_Char;' 

'subtype [self]_Type is [self]_Base {' 

'[self]_Not_Null''length);' 

'package [self]_Ops is new SQL_Char_Ops(' 

'[self]_Base, [self]NN_Base);' 
end pattern; 

derived domain pattern is 

'type [self]NN__Base is new [parent]NK_Base; ' 

'subtype [self]_Not_Null is [self]NN__Base (1 .. [length]);' 
'type [self]_Base is new [parent]_Base;' 

'subtype [self]_Type is [self]_Base (' 

'[self]_Not_Null''length);' 

'package [self]_Ops is new SQL_Char_Ops {' 

'[self]_Base, [self]NN„Base);' 
end pattern; 

subdomain pattern is 

'subtype [self]NN__Base is [parent]NN_Base; ' 

'subtype [self]_Not_Null is [parent]NN_Base (1 .. [length]) 
'subtype [self]_Base is new [parent]_Base;' 

'subtype [self]_Type is [self]_Base (' 

'[self]_Not_Null''length);' 

'package [self]_Ops is new SQL_Char_Ops (' 

'[self]_Base, [self]NN_Base);' 
end pattern; 

for not null type name use '[self]_Not_Null'; 
for null type name use ' [self ]__Type' ; 


68 Database Programming Language ~ SAMeDL 



VERSION 2 


for data class use character; 

for dbms type use character '{ [length] )'; 

for conversion from dbms to not null use type mark; 

for conversion from not null to null use function 

'[self]_Ops.With_Null'; 

for conversion from null to not null use function 
'[self]_Ops.Without_Null"; 
for conversion from not null to dbms use type mark; 

end SQL_Char; 

-- SQL_NChar Base Domain 

-- SQL_NChar is identical to SQL_CHAR except that it is 
-- based on the Ada type Interfaces.SQL.NChar 

base domain SQL_NChar 
is 

domain pattern is 

'type [self]NN_Base is new SQL_NChar_Not_Null;' 

'subtype [self]_Not_Null is [self]NN_Base (1 .. [length]);' 
'type [self]_Base is new SQL_NChar;' 

'subtype [self]_Type is [self]_Base (' 

'[self]_Not_Null''length);' 

'package [self]_Ops is new SQL_NChar_Ops(' 

'[self]_Base, [self]NN_Base);' 
end pattern; 

derived domain pattern is 

'type [self]NN_Base is new [parent]NN_Base;' 

'subtype [self]_Not_Null is [self]NN_Base {1 .. [length]);' 
'type [self]_Base is new [parent]_Base;' 

'subtype [self]_Type is [self]_Base (' 

'[self]_Not_Null''length);' 

'package [self]_Ops is new SQL_NChar_Ops (' 

'[self]_Base, [self]NN_Base);' 
end pattern; 
subdomain pattern is 

'subtype [self]NN_Base is [parent]NN_Base;' 

'subtype [self]_Not_Null is [parent]NN_Base (1 .. [length]);' 
'subtype [self]_Base is new [parent]_Base;'. 

'subtype [self]_Type is [self]_Base (' 

'[self]_Not_Null''length);' 

'package [self]_Ops is new SQL_NChar_Ops (' 

'[self]_Base, [self]NN„Base);' 
end pattern; 

for not null type name use ' [self ] _Not_Null '; 
for null type name use ' [self ]__Type ' ; 
for data class use character; 
for dbms type use character '{ [length] )'; 
for conversion from dbms to not null use type mark; 
for conversion from not null to null use function 
'[self]_Ops.With_Null'; 

for conversion from null to not null use function 
'[self]_Ops.Without_Null'; 
for conversion from not null to dbms use type mark; 

end SQL_NChar; 

-- SQL_VarChar Base Domain 

base domain SQL_VarChar 

is 

domain pattern is 

'type [self]_Not_Null is new SQL_VarChar_Not_NUll' 

'type [self]_Type is new SQL_VarChar;' 

'package [self]_Ops is new SQL_VarChar_Ops(' 

'[self]_Type, [self]_Not_Null);' 

end pattern; 

derived domain pattern is 

'type [self]_Not_Null is new [parent]_Not_Null;' 

'type [self]_Type is new [parent]_Type;' 


SAMeDL^Standard 69 



VERSION 2 


'package [self]_Ops is new SQL_VarChar_Ops (' 

'[self]_Type, [self]_Not„Null);' 

end pattern; 
subdomain pattern is 

'subtype [ self ] _Not„Null is [parent ] __Not_Null' 

'subtype [self]_Type is [parent]_Type {' 

'package [self]„Ops is new SQL_VarChar_Ops (' 

'[self]_Type, [self]„Not_Null);' 

end pattern; 

for data class use character; 

for dbms type use character varying '([length])'; 

for conversion from dbms to not null use type mark; 
for conversion from not null to null use function 

'[self]_Ops.With_Null'; 

for conversion from null to not null use function 
'[self]_Ops.Without_Null'; 
for conversion from not null to dbms use type mark; 

end SQL__VarChar; 

-- SQL_Bit Base Domain 

““ SQL_Bit is similar to the character string base domains 

base domain SQL_Bit 
is 

domain pattern is 

'type [self]NN_Base is new SQL_Bit_Not_Null;' 

'subtype [self]_Not_Null is [self]NN_Base (1 .. [length]);' 
'type [self]_Base is new SQL_Bit;' 

'subtype [self]_Type is [self]_Base (' 

'[self]_Not_Null''length);' 

'package [self]_Ops is new SQL_Bit_Ops{' 

'[self]_Base, [self]NN_Base);' 
end pattern; 

derived domain pattern is 

'type [self]NN_Base is new [parent]NN_Base;' 

'subtype [self]_Not_Null is [self]]SlN_Base (1 .. [length]);' 
'type [self]_Base is new [parent]_Base;' 

'subtype [self]_Type is [self]_Base (' 

'[self]_Not_Null''length);' 

'package [self]_Ops is new SQL_Bit_Ops (' 

' [self ] _Ba.se , [self ] NN_Base) ; ' 
end pattern; 

subdomain pattern is 

'subtype [self]NN„Base is [parent]NN_Base;' 

'subtype [self]_Not_Null is [parent]NN_Base (1 .. [length]) 
'subtype [self]_Base is new [parent]_Base;' 

'subtype [self]_Type is [self]„Base (' 

'[self]_Not_Null''length);' 

'package [self]_Ops is new SQL_Bit_Ops (' 

' [self]_Base, [self ]NN__Base) ; ' 
end pattern; 

for not null type name use '[self]_Not_Null'; 

for null type name use '[self]_Type'; 

for data class use bit 

for dbms type use bit '([length])'; 

for conversion from dbms to not null use type mark; 
for conversion from not null to null use function 

'[self]_Ops.With_Null'; 

for conversion from null to not null use function 
'[self]_Ops.Without_Null'; 
for conversion from not null to dbms use type mark; 

end SQL_Bit; 

-- SQL_Enumeration_AsJnt Base Domain 

SQL_Enumeration_As_Int is based on the Ada type 
Interfaces.SQL.Int 
base domain SQL_Enumeration_As_Int 


70 Database Programming Language - SAMeDL 



VERSION 2 


(map := pos) 
is 

domain pattern is 

'type [self]„Not_Null is new [enumeration];' 

'package [self]_Pkg is new SQL_Enumeration_Pkg{' 

'[enumeration]);' 

'type [self]_Type is new [self]_Pkg.SQL_Enumeration;' 

end pattern; 

derived domain pattern is 

'type [self]_Not_Null is new [parent]__Not_Null;' 

'type [self]_Type is new [parent]_Type;' 

end pattern; 
subdomain pattern is 

'subtype [self]_Not_Null is [parent]_Not_Null;' 
'subtype [self]_Type is [parent]„Type;' 

end pattern; 

-- SQL_Enumeratlon_As_Char Base Domain 

-- SQL_Enumeration_As_Char is based on the Ada type 

-- Interfaces.SQL.Char 

base domain SQL_Enumeration_As_Char 

(map := image) 
is 

domain pattern is 

'type [self]_Not_Null is new [enumeration];' 

'package [self]_Pkg is new SQL_Enumeration_Pkg(' 

' [enijmeration] ) ; ' 

'type [self]_Type is new [self]_Pkg.SQL_Enumeration;' 

end pattern; 

derived domain pattern is 

'type [self]_Not_Null is new [parent]_Not_Null;' 

'type [self]_Type is new [parent]_Type;' 

end pattern; 
subdomain pattern is 

'subtype [self]_Not_Null is [parent]_Not_Null;' 
'subtype [self]_Type is [parent]_Type;' 

end pattern; 

for not null type name use ' [self ] _Not_Null ' ; 
for null type name use '[self]_Type' ; 
for data class use enumeration; 
for dbms type use character '([length])' ; 
for conversion from not null to null use function 
'[self]_Pkg.With_Null'; 

for conversion from null to not null use function 

'[self]_Pkg.Without_Null'; 
end SQL_Enumeration_As_Char ; 

-- Temporal Base Domains 

base domain SQL_Date is 

for data class use date; 
for dbmstype use none; 
end SQL_Date; 
base domain SQL_Time is 

for data class use time; 
for dbmstype use none; 
end SQL_Time; 

base domain SQL_Timestamp is 

for data class use timestamp; 
for dbmstype use none; 
end SQL_Timestamp; 
base domain SQL_Interval is 

for data class use interval; 
for dbmstype use none; 
end SQL_Interval; 


SAMeDL Standard 71 



VERSION 2 


-- SQLCODE Standardvalues 

-- SQLCODE for successful execution of a statement 
constant Success is 0; 

SQLCODE for data not found 
constant Not_Found is 100; 

-- SQLSTATE domains and constants 
-- Domain declarations for SQLSTATE values 
domain SQLSTATE_Domain is new SQL_Char not null 
(Length => 5); 

domain SQLSTATE__Class_Domain is new SQL_Char not null 
(Length => 2); 

-- These SQLSTATE values and their names 

-- are taken from the definition of the Ada package Interfaces.SQL, 

-- defined in 12.4 of ISO/IEC 9075:1992. 

-- Any discrepency between this list and the list in the citation 
-- is resolved in favor of the later, which is definitive, 
constant Ainbiguous_Cursor_Name : SQLSTATE_Class_Domain is '3C'; 
constant Ambiguous_Cursor_Name_No_Subclass : 

SQLSTATE_Domain is '3C000'; 

constant Cardinality_Violation : SQLSTATE_Class_Domain is '21^- 
constant Cardinality_Violation_No_Subclass : 

SQLSTATE_Domain is '21000\* 

constant Connection_Exception : SQLSTATE„Class_Domain is '08^- 
constant Connection_Exception_No_Subclass : 

SQLSTATE_Domain is '08000'; 

constant Connection_Exception_Connection_Does_Not_Exist : 

SQLSTATE_Domain is '08003'; 
constant Connection_Exception_Connection_Failure : 

SQLSTATE_Domain is '08006'; 

constant Connection_Exception_Connection_Name_In_Use : 

SQLSTATE_Domain is ' 08 002 ' ; 

constant Connection_Exception_SQLClient__Unable_To_Establish_SQLConnection 
SQLSTATE_Domain is '08001'; 

constant Connection_Exception_SQLServer_Rejected_Establishment_Of_SQLConne 

tion : 

SQLSTATE_Domain is '08004'; 

constant Connection_Exception_Transaction_Resolution_Unknown : 
SQLSTATE_Domain is ' 08007'; 

constant Data_Exception: SQLSTATE__Class__Domain is '22'; 
constant Data_Exception__No_Subc 1 ass : 

SQLSTATE_Domain is '22000'; 
constant Data_Exception_Character_Not_in_Repertoire : 

SQLSTATE__Domain is '22008'; 
constant Data„Exception__DateTime„Field_Overflow : 

SQLSTATE_Domain is '22008'; 
constant Data_Exception_Division_By_Zero : 

SQLSTATE_Domain is '22012'; 
constant Data_Exception_Error_In_Assigninent : 

SQLSTATE_Domain is '22005'; 
constant Data_Exception_Indicator_Overflow : 

SQLSTATE_Domain is '22022'; 
constant Data_Exception_Interval_Field_Overflow : 

SQLSTATE_Domain is '22015'; 

constant Data_Exception_Invalid_Character_Value_For_Cast : 

SQLSTATE„Domain is '22018'; 
constant Data__Exception_Invalid_DateTime__Format : 

SQLSTATE_Domain is '22007'; 
constant Data_Exception_Invalid_Escape_Character : 

SQLSTATE_Domain is '22019'; 
constant Data_Exception_Invalid_Escape_Sequence : 

SQLSTATE_Domain is '22025'; 
constant Data_Exception_Invalid__Parameter_Value : 

SQLSTATE_Domain is '22023'; 

constant Data__Exception_Invalid_Time_Zone„Displacement_Value • 
SQLSTATE^Domain is '22009'; 


72 Database Programming Language - SAMeDL 



VERSION 2 


constant Data_Exception_Null_Value__No_Indicator_Parameter : 

SQLSTATE_Domain is '22002'; 
constant Data_Exception_Nuineric_Value_Out_of_Range : 

SQLSTATE„Domain is '22003'; 
constant Data_Exception_String_Data_Length_Mismatch : 

SQLSTATE_Doinain is '22026'; 

constant Data_Exception_String_Data_Right_Truncation : 

SQLSTATE_Doinain is '22001'; 
constant Data_Exception__Substring„Error : 

SQLSTATE_Domain is '22011'; 
constant Data_Exception_Trim_Error : 

SQLSTATE__Domain is ' 22 027 ' ; 
constant Data_Exception_Unterminated_C_String : 

SQLSTATE_Domain is ' 22 024'; 
constant Dependent_Privilege_Descriptors_Still_Exist: 
SQLSTATE_Class_Doinain is '2B'; 

constant Dependent_Privilege_Descriptors_Still_Exist_No_Subclass : 
SQLSTATE_Domain is '2B000'; 

constant Dynainic_SQL_Error : SQLSTATE_Class_Doinain is '07'; 
constant Dynainic_SQL_Error_No_Subclass : 

SQLSTATE_Doinain is '07000'; 

constant Dynainic_SQL_Error_Cursor_Specification_Cannot_Be_Executed : 

SQLSTATE_Domain is '07003'; 
constant Dynainic_SQL_Error_Invalid_Descriptor_Count : 

SQLSTATE_Domain is '07008'; 
constant Dynainic_SQL_Error_Invalid_Descriptor_Index : 

SQLSTATE_Domain is '07009'; 
constant 

Dynainic_SQL_Error_Prepared_Statement_Not_A_Cursor_Specification : 
SQLSTATE_Domain is '07005'; 

constant Dynainic_SQL_Error__Restricted_Data_Type_Attribute_Violation : 

SQLSTATEJomain is '07006'; 
constant 

Dynainic_SQL_Error_Using_Clause_Does_Not_Match_Dynainic_Paraineter_Sec : 
SQLSTATE_Doniain is '07001'; 

constant Dynainic_SQL_Error_Using_Clause_Does_Not_Match_Target_Spec : 

SQLSTATE_Domain is '07002'; 
constant 

Dynainic_SQL_Error__Using_Clause_Required_For_Dynainic_Paranieters : 
SQLSTATE_Domain is '07004'; 

constant Dynainic_SQL_Error_Using_Clause_Required_For_Result_Fields : 
SQLSTATE_Domain is '07007'; 

constant Feature_Not_Supported : SQLSTATE_Class_Domain is 'OA'; 
constant Feature_Not_Supported_No_Subclass : 

SQLSTATE_Doinain is 'OAOOO'; 

constant Feature_Not_Supported_Mutliple_Environinent_Transaetions : 
SQLSTATE_Doinain is 'OAOOl'; 

constant Integriy_Constraint_Violation : SQLSTATE_Class_Doinain is '23'; 
constant Integriy_Constraint_Violation_No_Subclass : 

SQLSTATE_Domain is '23000'; 
constant 

Invalid_Authorization_Specification : SQLSTATE_Class_Domain is '2'; 
constant Invalid_Authorization_Specification_No_Subclass : 
SQLSTATE_Domain is '28000'; 

constant Invalid_Catalog_Naine : SQLSTATE_Class_Domain is '3D'; 
constant Invalid_Catalog_Naine_No_Subclass : 

SQLSTATE_Domain is '3D000'; 

constant Invalid__Character_Set_Name : SQLSTATE_Class_Domain is '2C'; 
constant Invalid_Character_Set_Naine_No_Subclass : 

SQLSTATE^Domain is '2C000'; 

constant Invalid_Condition_N\i[nber : SQLSTATE_Class__DoiTiain is '35'; 
constant Invalid__Condition_Nuinber_No_Subclass : 

SQLSTATE_Doinain is '35000'; 

constant Invalid_Connection_Naine : SQLSTATE_Class_Doinain is '2E'; 
constant Invalid_Connection_Naine__No_Subclass ; 

SQLSTATE^Domain is '2E000'; 

constant Invalid_Cursor_Name : SQLSTATE_Class_Domain is '34'; 
constant Invalid_Cursor_Naine_No_Subclass : 


SAMeDL^Standard 73 



VERSION 2 


SQLSTATE__Domain is '34000'; 

constant Invalid_Cursor_State : SQLSTATE_Class_Domain is '24'; 
constant Invalid_Cursor_State_No_Subclass : 

SQLSTATE_Domain is '24000'; 

constant Invalid_Schema_Name : SQLSTATE_Class_Doinain is '3F'; 
constant Invalid_Schema_Naine„No_Subclass : 

SQLSTATE^Domain is '3F000'; 

constant Invalid_SQL__Descriptor_Name : SQLSTATE_Class_Domain is '33'; 
constant Invalid__SQL_Descriptor_Naine_No_Subclass : 

SQLSTATE_Domain is '33000'; 

constant Invalid_SQL_Statement_Naine : SQLSTATE_Class_Doinain is '26'; 
constant Invalid_SQL__Stateinent__Naine_No_Subclass : 

SQLSTATE_Domain is '26000'; 

constant Invalid„Transaction_State : SQLSTATE_Class_Domain is '25'; 
constant Invalid_Transaction_State_No_Subclass : 

SQLSTATE„Doinain is '25000'; 
constant 

Invalid_Transaction_Termination : SQLSTATE_Class_Domain is '2D'; 
constant Invalid_Transaction_Termination_No_Subclass : 

SQLSTATE_Domain is '2D000'; 
constant No_Data : SQLSTATE_Class_Doinain is '02'; 
constant No_Data_No_„Subclass : 

SQLSTATE_Domain is '02000'; 

constant Remote_Database_Access : SQLSTATE_Class_Domain is 'HZ'; 
constant Remote_Database_Access_No_Subclass : 

SQLSTATE_Domain is 'HZOOO'; 

constant Successful_Completion : SQLSTATE_Class__Domain is '00'; 
constant Successful_.Completion_No_Subclass : 

SQLSTATE_Domain is '00000'; 
constant 

Syntax_Error_Or_Access_Rule_Violation : SQLSTATE_Class„Domain is '42'; 
constant Syntax_Error_Or_Access_Rule_Violation_No_Subclass : 
SQLSTATE_Domain is '42000'; 

constant Syntax„Error_Or_Access_Rule_Violation_In_Direct_Statement: 
SQLSTATE_Class_Domain is '2A'; 

constant 

Syntax_Error_Or_Access_Rule_Violation_In_Direct„Statement_No_Subclass 
SQLSTATE_Domain is '2A000'; 

constant Syntax_Error__Or_Access_Rule„Violation_In_Dynamic_Statement: 
SQLSTATE_Class_Domain is '37'; 

constant 

Syntax_Error_Or__Access„Rule_Violation_In_Dynamic_Statement__No_Subclass 
SQLSTATE_Domain is '37000'; 

constant Transaction__Rollback : SQLSTATE_Class_Domain is '40'; 
constant Transaction_Rollback_No_Subclass : 

SQLSTATE_Domain is '40000'; 

constant Transaction__Rollback_Integrity_Constraint_Violation : 

SQLSTATE_Domain is '40002'; 
constant Transaction_Rollback_Seriali 2 ation_Failure : 

SQLSTATE__Domain is '40001'; 

constant Transaction_Rollback_Statement_Completion_Unknown : 

SQLSTATE_Domain is '40003'; 
constant 

Triggered_Data_Change_Violation : SQLSTATE_Class_Domain is '27'; 
constant Triggered_Data_Change_Violation__No_Subclass : 

SQLSTATE_Domain is '27000'; 
constant Warning : SQLSTATE_Class_Domain is '01'; 
constant Warning_No_Subclass : 

SQLSTATE__Domain is ' 01000 ' ; 
constant Warning_Cursor_Operation_Conflict : 

SQLSTATE_Domain is '01001'; 
constant Warning_Disconnect_Error : 

SQLSTATE_Domain is '01002'; 
constant Warning„Implicit_Zero_Bit_Padding : 

SQLSTATE_Domain is '01008'; 
constant Warning_Insufficient_Item__Descriptor__Areas : 

SQLSTATE_Domain is '01005'; 

constant Warning_Null_Value_Eliminated_in__Set_Function : 


74 Database Programming Language - SAMeDL 



VERSION 2 


SQLSTATE_Domain is ^ 01003 '; 
constant Warning_Privilege_Not_Granted : 

SQLSTATE_Domain is ' 01007 '; 
constant Warning_Privilege_Not__Revoked : 

SQLSTATE_Domain is '01006'; 

constant Warning_Query_Expression_Too_Long_For_Infonnation_Scheina : 
SQLSTATE_Domain is 'OlOOA'; 

constant Warning_Search_Condition_Too_Long_For_Information_Schema : 
SQLSTATE_Domain is '01009'; 

constant Warning_String_Data_Right_Truncation_Warning : 
SQLSTATE_Domain is '01004'; 

constant With_Check_Option_Violation : SQLSTATE_Class„Domain is '44'; 
constant With_Check_Option_Violation_No_Subclass : 

SQLSTATE_Domain is '44000'; 

sqlstate status Standard_Map 
named Is_Found 
uses boolean 
is 

{Successful_Completion_No„Subclass => True, 

No_Data_No_Subclass => False); 
end SAMeDL_Standard; 


SAMeDL_Standard 75 



VERSION 2 


Annex B SAMeDL_System 

The predefined SAMeDL definitional module SAMeDL_System provides a common location for the decla¬ 
ration of implementation-defined constants that are specific to a particular DBMS/Ada compiler platform. 

with SAMeDL_Standard; use SAMeDL_Standard; 
definition module SAMeDL_System is 

-- Smallest (most negative) value of any integer type 
constant Min_Int is implementation defined; 

-- Largest (most positive) value of any integer type 
constant Max„Int is implementation defined; 

-- Smallest value of any SQL_Int type 
constant Min_SQL_Int is implementation defined; 

-- Largest value of any SQL_Int type 
constant Max__SQL„Int is implementation defined; 

-- Smallest value of any SQL_Smallint type 
constant Min_SQL_Smallint is implementation defined; 

-- Largest value of any SQL_Smallint type 
constant Max_SQL_Smallint is implementation defined; 

-- Largest value allowed for the number of significant decimal 
-- digits in any floating point constraint 
constant Max_Digits is implementation defined; 

Largest value allowed for the number of significant decimal 
-- digits in an SQL_Real floating point constraint 
constant SQL_Real_Digits is implementation defined; 

Largest value allowed for the number of significant decimal 
-- digits in an SQL_Double__Precision floating point constraint 
constant SQL_Double_Precision_Digits is implementation defined; 

Largest value allowed for the number of characters in a 
-- character string constraint 

constant Max_SQL_Char_Length is implementation defined; 

-- implementation defined SQLSTATE and SQLCODE values 
-- should be declared as constants here 
end SAMeDL_System; 


76 Database Programming Language - SAMeDL 



VERSION 2 


Annex C Standard Support Operations and 
Specifications 

The following two sections discuss the SAME standard support packages. The first section describes how 
they support the standard base domains, and the second section lists their Ada package specifications. 

C.1 Standard Base Domain Operations 

The SAME standard support packages encapsulate the Ada type definitions of the standard base domains, 
as well as the operations that provide the data semantics for domains declared using these base domains. 
This section describes the nature of the support packages, namely the Ada data types and the operations 
on objects of these types. 

The SQL standard package Interfaces.SQL (see C in this International Standard and 12.3.8.a.iii of ISO/IEC 
9075:1992; contains the type definitions for a DBMS platform that define the Ada representations of the con¬ 
crete SQL data types. A standard base domain exists in the SAMeDL for each type in Interfaces.SQL (ex¬ 
cept for SQLCode_Type), and these base domains are each supported by one of the SAME standard sup¬ 
port packages. In addition to the above base domains, two standard base domains exist that provide data 
semantics for Ada enumeration types. 

Each support package defines a not null-bearing and a null-bearing type for the base domain. The not null¬ 
bearing type is a visible Ada type derived from the corresponding type in Interfaces.SQL with no added con¬ 
straints. This type provides the Ada application programmer with Ada data semantics for data in the data¬ 
base. The null-bearing type is an Ada limited private type used to support data semantics of the SQL null 
value. In particular, the null-bearing type may contain the null value; the not null-bearing type may not. 

Domains are derived from base domains by the declaration of two Ada data types, derived from the types 
in the support packages, and the instantiation of the generic operations package with these types. The type 
derivations and the package instantiation provide the domain with the complete set of operations that define 
the data semantics for that domain. These operations are described below, grouped by data class. 

C.1.1 Al! Domains 

All domains derived from the standard base domains make an Assign procedure available to the application 
because the type that supports the SQL data semantics is an Ada limited private type. For the numeric do¬ 
mains, this procedure enforces the range constraints that are specified for the domain when it is declared. 
The Ada Consfra/nL&ror exception is raised by these procedures if the value to be assigned falls outside 
of the specified range. 

A parameterless function named Null_SQL_<type> is available for all domains as well. This function returns 
an object of the null-bearing type of the appropriate domain whose value is the SQL null value. 

Every domain has a set of conversion functions available for converting between the not null-bearing type 
and the null-bearing type. The function With_Null converts an object of the not null-bearing type to an object 


Standard Support Operations and Specifications 77 




VERSION 2 


of the null-bearing type. The function Without_Null converts an object of the null-bearing type to an object 
of the not null-bearing type. Without_Nullwill raise the Null_Value_Errorexception if the value of the object 
that it is converting is the SQL null value, since an object of the not nuli-bearing type can never be null. 

Two testing functions are available for each domain as well. The boolean functions ls_Null and Not_Null 
test objects of the null-bearing type, returning the appropriate boolean value indicating whether or not an 
object contains the SQL null value. 

Additionally, all domains provide two sets of comparison operators that operate on objects of the null-bear¬ 
ing type. The first set of operators returns boolean values, and the second set of operators returns objects 
of the type Boolean_With_Llnknown, defined in the support package SQL_Boolean_Pkg (see Section C), 
which implements three-valued logic (see @cite(guide)). The boolean comparison operators are =, /=, <, >, 
<=, and >=, and return the value False if either of the objects contains the SQL null value. @Foot[Note: 
These semantics have a peculiar side effect, namely that, for objects 0.| and O 2 , the boolean expression 
(Qf < Q^) or else (Q.| >= O 2 ) is not a tautology.] Otherwise, these operators perform the comparison, and 
return the appropriate booiean result. The Boolean_With_Unl<nown comparison operators are Equals an6 
Not_Equals, <, >, <=, and >=, and return the value Unknown if either of the objects contains the SQL nuli 
value. Otherwise, these operators perform the comparison, and return the Boolean_Wlth_Unknownvalues 
True or False. 

C.1.2 Numeric Domains 

In addition to the operations mentioned above, all numeric domains provide unary and binary arithmetic op¬ 
erations for the null-bearing type of the domain. The subprograms that implement these operations provide 
the data semantics of the SQL null value with respect to these arithmetic operations. Specifically, any arith¬ 
metic operation applied to a null value results in the null value. Qtherwise, the operation is defined to be the 
same as the Ada operation. The unary operations that are provided are - 1 -, -, and Abs. The binary operations 
include +, -, *, and /. Finally, all numeric domains provide the exponentiation operation (**). 

C.1.3 Int and Smallint Domains 


Inland Smallint domains provide the application programmer with the Ada functions Mod and Rem that op¬ 
erate on objects of the null-bearing type. Again, the subprograms that implement these operations provide 
the data semantics of the SQL null value with respect to these arithmetic operations. As with the other arith¬ 
metic operations. Mod and Rem return the null value when applied to an object containing the null value. 
Qtherwise, they are defined to be the same as the Ada operation. 


These domains also make Image and Value functions available to the application programmer. Both of 
these functions are overloaded, meaning that there are Image and Value functions that operate on objects 
of both the not null-bearing and the null-bearing types of the domain. The Image function converts an object 
of an Int or Smallint domain to a character representation of the integer vaiue. The Value function converts 
a character representation of an integer value to an object of an Int or Smallint domain. These functions 
perform the same operation as the Ada attribute functions of the same name, except that the character set 
of the character inputs and outputs is that of the underlying Interfaces.SQL.Char character set. If the Image 
and l/a/ue functions are applied to objects of the null-bearing type containing the null value, a null character 
object and a null integer object are returned respectively. 


78 Database Programming Language - SAMeDL 



VERSION 2 


C.1.4 Character Domains 

In addition to the operations provided by all domains, character domains provide the application program¬ 
mer with some string manipulation and string conversion operations. 

Character domains provide two string manipulation functions that operate on objects of the null-bearing 
type. The first one is the catenation function (&). If either of the input character objects contains the null val¬ 
ue, then the object returned contains the null value. Otherwise this operation is the same as the Ada cate¬ 
nation operation. The other function is the Substring iuncWon, which is patterned after the substring function 
in ISO/IEC 9075:1992. This function returns the portion of the input character object specified by the Start 
and Length index inputs. An Ada Constraint_Error is raised if the substring specification is not contained 
entirely within the input string. 

The remaining operations provided by the character domains are conversion functions. A To_String and a 
To_Unpadded_String tuncWon exist for both the not null-bearing and the null-bearing types of the domain. 
The ro_Sfr/ngf function converts its input, which exists as an object whose value is comprised of characters 
from the underlying character set of the platform, to an object of the Ada predefined type Standard.String. 
If conversion of a null-bearing object containing the null value is attempted, the Null_Value_Errorexception 
is raised. The To_Unpadded_String tuncWons are identical in every way to the To_Sfr/ng'functions, except 
that trailing blanks are stripped from the value. 

The Without_Null_Unpadded function is identical to the WithouLNull function, described in section C 
above, except that trailing blanks are stripped from the value. 

Two functions exist that convert objects of the Ada predefined type Standard.String to objects of the not null¬ 
bearing and null-bearing types of the domain. The To_SQL_Char_Not_Null tunction converts an object of 
type Standard.String to the not null-bearing type of the domain. The To_SQL_Chartunct\on converts an ob¬ 
ject of type Standard.String to an object of the null-bearing type. 

Finally, character domains provide the function Unpadded_Length, which returns the length of the character 
string representation without trailing blanks. This function operates on objects of the null-bearing type, and 
raises the Null_Vaiue_Errorexception if the input object contains the null value. 

C.1.5 Enumeration Domains 

Enumeration domains provide functions for the null-bearing type that are normally available as Ada attribute 
functions for the not null-bearing type. The Image and Value functions have the same semantics as de¬ 
scribed for Int and Smallint domains in Section C above, except that they operate on enumeration values 
rather than integers. 

The Pred and Succ functions operate on objects of the null-bearing type, and return the previous and next 
enumeration literals of the underlying enumeration type, respectively. If these functions are applied to ob¬ 
jects containing the null value, an object containing the null value is returned. 


Standard Support Operations and Specifications 79 


VERSION 2 


The last two functions are the Pos and Val functions. These functions also operate on objects of the null¬ 
bearing type. Pos returns a value of the Ada predefined type Standard.lntegerrepreseutlng the position (rel¬ 
ative to zero) of the enumeration literal that is the value of the input object. If the input object contains the 
null value, then the Null_Value_Errorexception is raised. The Va/function accepts a value of the predefined 
type Standard. Integer and returns the enumeration literal whose position in the underlying enumeration type 
is specified by that value. If the input integer value falls outside the range of available enumeration literals, 
the Ada Constraint_Error \s raised. 

C.1.6 Boolean Functions 

The SAME standard support package SQL_Boolean_Pkg defines a number of boolean functions, namely 
not, and, or, and xor, which implement three-valued logic as defined in ISO/IEC 9075:1992. All of these 
functions operate on two input parameters of the type Boolean_With_Unl<nown, and return a value of that 
type. 


This support package also provides a conversion function, which converts the input of the type Boolean_- 
With_Unl(nown to a value of the Ada predefined type boolean. If the input object has the value Unknown, 
then the Null_Value_Errorexception is raised. 


Finally, the package provides three testing functions that return boolean values. These functions, ls_True, 
ls_False, and ls_Unknown, return the value true if the input passes the test; otherwise the functions return 
the value false. 

C.1.7 Operations Available to the Application 


Operand Type Exceptions 

Left Right Result 

All Domains 

Nul1_SQL_<type>_ 

With_Null 
Without_Null 
Is_Nul^, Not_Null 
Assign 

Equals, Not_Equals 
</ >/ <=, >= 

=/ /=/ ># <, >=, < 


Numeric Domains 


unary +, Abs 


_Type 

_Type 


__TYpe 

_Type 

_Type 


_Type 

Integer 

__Type 

Int and Smallint Domains 

Mod, Rem 

-Type 

-Type 

-Type 

Image 

_Type 


SQL_Char , 

Image 

_Not_Null 


SQL_ChrNN' 

Value 

SQL_Char 


_Type 

Value 

SQL_ChrNN 


_Not_Null 




-Type 



_Not_yull 

-Type 



_Type‘^ 

_Not_Null 

Null_Value_Error 


-Type 

Boolean 


_Type 

_Type 


Constraint_Error 

_Type 

_Type 


_Type 

_Type 

B_W_U 


-Type 

-Type 

Boolean 



Character Domains 


80 Database Programming Language - SAMeDL 


VERSION 2 


Without_Null_Unpadded 


_Type 

_Not_Null 

Null_Value_Error 

To_String 


_Not_Null 

String 


To_String 


_Type 

String 

Null_Value_Error 

To_Unpadded_String 


_Not_Null 

String 


To_Unpadded_String 


_Type 

String 

Null_Value__Error 

To_SQL_Char_Not_Null 


String 

_Not_.Null 


To_SQL_Char 


String 

-Type Q 


UnpaddedLength 


_Type 

SQL_U_L 

Null_Value_Error 

Substring 


_Type 

_Type 

Constraint__Error 

Sc 

_Type 

_Type 

_Type 


Bit String Domains 





10 

Substring 


_Type 

_Type 

Constraint_Error 

& 

_Type 

_Type 

_Type 


Enumeration Domains 





Pred, Succ 


_Type 

_Type 


Image 


_Type 

SQL_Char 


Image 


_Not_Null 

SQL_ChrNN 


Pos 


_Type 

Integer 

Nul l_Value__Error 

Val 


Integer 

_Type 


Value 


SQL_Char 

_Type 


Value 


SQL_ChrNN 

_Not_Null 


Boolean Functions 





not 


B_W_U 

Boolean 


and, or, xor 

B_W_U 

B_W_U 

Boolean 


To_Boolean 


B_W_U 

Boolean 

Null_Value_Error 

Is_True, 


B_W_U 

Boolean 


Is_False, 


B_W_U 

Boolean 


Is_Unknown 


B_W_U 

Boolean 



1 ■ "_Type“ represents the type in the abstract domain of which objects that may be null are declared. 

2. ''_Not_NuH" represents the type in the abstract domain of which objects that are not null may be declared. 

3. Assign" is a procedure. The result is returned in object "Left." 

4. "B_W_U" is an abbreviation for Boolean_With_Unknown. 

5. "SQL_ChrNN" is an abbreviation forSQL_Char_Not_Null. 

6. "SQLJntNN" is an abbreviation for SQLJnt_Not_Null. 

7. ''SQL_DblNN" is an abbreviation forSQL_Double_Precision_Not_Null. 

8. "SQL_Dbr‘ is an abbreviation for SQL_Double_Precision. 

9. "SQL_U_L" is an abbreviation for the SQL_Char_Pkg subtype SQL_Unpadded_Length. 

10. Substring has two additional parameters Start and Length which are both of the SQL Char Pkq subtvoe 

SQL_Char_Length. - _ » 


Standard Support Operations and Specifications 81 


VERSION 2 


C.2 Standard Support Package Specifications 

C.2.1 Interfaces.SQL 


The package Interfaces.SQL is defined in 12.4 of ISO/IEC 9075:1992 and is reproduced here for information 


package Interfaces.SQL is 

package Character_Set renames csp; 

subtype Character_Type is Character_Set.cst; 

type Char is array (positive range <>) of Character_Type; 

type Bit is array (natural range <>) of boolean; 

type Smallint is range bs..ts; 

type Int is range bi..ti; 

type Real is digits dr; 

type Double__Precision is digits dd; 

subtype Indicator_Type is t; 

type Sqlcode_Type is range bsc..tsc; 

subtype Sql_Error is Sqlcode_Type range Sqlcode_Type^FIRST .. -1; 
subtype Not_Found is Sqlcode_Type range 100..100; 
type SQLSTATE_Type is new Char {1 .. 5); 

-- csp is an implementor-defined package and cst is an 
— implementor-defined character type. bS/ ts, bi, ti^ bsc, 

-- and tsc are implementor defined integral values, t is int or 
-- smallint corresponding to an implementor-defined exact 
-- numeric type of indicator parameters, 
package SQLSTATE_Codes is 

-- this subpackage contains a constant declaration for each 
-- SQLSTATE value defined by ISO/IEC 9075:1992. These constants 

are reproduced in the SAMeDL module (and therefore the Ada package) 

-- SAMeDL_Standard. See Annex A of this specification. 

-- The list of constants declared in 12.4 of ISO/IEC 9075:1992 
-- is definitive, 
end SQLSTATE_Codes; 
end Interfaces.SQL; 

C.2.2 SQL_Boolean_Pkg 


package SQL_Boolean_Pkg is 

type Boolean_with_Unknown is (FALSE, UNKNOWN, TRUE); 

- Three valued Logic operations — 

- three-val X three-val => three-val -- 

function "not” (Left : Boolean_with„Unknown) 
return Boolean_with_Unknown; 
pragma INLINE ("not"); 

function "and" (Left, Right : Boolean_with_Unknown) 
return Boolean__with_Unknown; 
pragma INLINE ("and"); 

function "or" (Left, Right : Boolean_with_Unknown) 
return Boolean_with_Unknown; 
pragma INLINE ("or"); 

function "xor" (Left, Right : Boolean__with_Unknown) 
return Boolean_with_Unknown; 
pragma INLINE ("xor"); 

- three-val => bool or exception - 

function To_Boolean (Left : Boolean__with__Unknown) return Boolean; 
pragma INLINE (To_Boolean); 

- three-val => bool - 

function Is_True (Left : Boolean_with_Unknown) return Boolean; 
pragma INLINE (Is„True); 

function Is_False (Left : Boolean_with_Unknown) return Boolean; 
pragma INLINE (Is_False); 

function Is_Unknown (Left : Boolean_with_Unknown) return Boolean; 


82 Database Programming Language - SAMeDL 


VERSION 2 


pragma INLINE (Is_Unknown); 
end SQL_Boolean_Pkg; 

C.2.3 SQLJnt_Pkg 


with Interfaces.SQL; 

with SQL_Boolean_Pkg; use SQL_Boolean_Pkg; 
with SQL_Char__Pkg; use SQL_Char_Pkg; 
package SQL_Int_Pkg is 

type SQL_Int_Not_Null is new Interfaces.SQL.Int; 

- Possibly Null Integer - 

type SQL_Int is limited private; 
function Null_SQL_Int return SQL_Int; 
pragma INLINE (Null_SQL_Int); 

-- this pair of functions convert between the 
null-bearing and non-null-bearing types, 
function Without_Null_Base (Value : SQLJnt) 
return SQL_Int_Not_Null; 
pragma INLINE {Without_Null_Base); 

-- With_Null_Base raises Null_Value_Error if the input 
value is null 

function With_Null_Base(Value : SQL_Int_Not_Null) 
return SQL_Int; 

pragma INLINE (With_Null_Base); 

-- this procedure implements range checking 
-- note: it is not meant to be used directly 
by application programmers 
-- see the generic package SQL_Int_Ops 
-- raises constraint_error if not 
(First <= Right <= Last) 
procedure Assign_with_check ( 

Left : in out SQL_Int; Right : SQL_Int; 

First, Last ; SQL_Int_Not_Null); 
pragma INLINE (Assign_with_check); 

-- the following functions implement three valued 
arithmetic 

-“ if either input to any of these functions is null 
the function returns the null value; otherwise 
they perform the indicated operation 
-- these functions raise no exceptions 
function (Right : SQL_Int) return SQL_Int; 
pragma INLINE ("+”); 

function (Right : SQL_Int) return SQL_Int; 
pragma INLINE ("-"); 

function "abs" (Right : SQL_Int) return SQL__Int; 
pragma INLINE ("abs"); 

function "+"(Left, Right : SQL_Int) return SQL_Int; 
pragma INLINE (” + "); 

function "*''(Left, Right : SQL__Int) return SQL_Int; 
pragma INLINE ("*"); 

function "-"(Left, Right : SQL_Int) return SQLJnt; 
pragma INLINE ("-"); 

function "/"(Left, Right : SQL_Int) return SQL_Int; 
pragma INLINE ("/"); 

function "mod" (Left, Right : SQL_Int) return SQL_Int; 
pragma INLINE ("mod"); 

function "rem" (Left, Right : SQL_Int) return SQL_Int; 
pragma INLINE ("rem"); 

function "**" (Left : SQL_Int; Right: Integer) return SQL_Int; 
pragma INLINE («**»); 

-- simulation of 'IMAGE and 'VALUE that 

-- return/take SQL_Char[_Not_Null] instead of string 

function IMAGE (Left : SQL_Int_Not_Null) return SQL_Char_Not_Null; 

function IMAGE (Left : SQL_Int) return SQL_Char; 

pragma INLINE (IMAGE); 

function VALUE (Left : SQL_Char_Not__Null) return SQL_Int_Not_Null; 
function VALUE (Left : SQL^Char) return SQL^Int; 


Standard Support Operations and Specifications 83 





VERSION 2 


pragma INLINE (VALUE); 

Logical Operations -- 
-- type X type => Boolean_with_unknown -- 
-- these functions implement three valued logic 
-- if either input is the null value, the functions 
return the truth value UNKNOWN; otherwise they 
perform the indicated comparison, 

-- these functions raise no exceptions 
function Equals (Left, Right : SQL_Int) 
return Boolean_with_Unknown; 
pragma INLINE (Equals); 

function Not_Equals (Left, Right : SQL_Int) 
return Boolean_with_Unknown; 
pragma INLINE (Not_Equals); 

function (Left, Right : SQL^Int) return Boolean_with_Unknown; 

pragma INLINE (■'<”); 

function (Left, Right : SQL_Int) return Boolean_with_Unknown; 

pragma INLINE ( ">”) ; 

function "<=" (Left, Right : SQL_Int) return Boolean__with_Unknown; 
pragma INLINE ("<='■) ; 

function ">=" (Left, Right : SQL_Int) return Boolean__with_Unknown; 
pragma INLINE (''>=”); 

-- type => Boolean -- 

function Is__Null (Value : SQL_Int) return Boolean; 
pragma INLINE (Is_Null); 

function Not_Null(Value : SQL_Int) return Boolean; 
pragma INLINE (Not„Null); 

These functions of class type => Boolean 
-- equate UNKNOWN with FALSE. That is, they return TRUE 
-- only when the function returns TRUE. UNKNOWN and FALSE 
-- are mapped to FALSE. 

function (Left, Right : SQL_Int) return Boolean; 

pragma INLINE (" ="); 

function "<" (Left, Right : SQL_Int) return Boolean; 
pragma INLINE ("<"); 

function ">■’ (Left, Right : SQL_Int) return Boolean; 
pragma INLINE ; 

function •'<=" (Left, Right : SQL_Int) return Boolean; 
pragma INLINE ('■< = •■); 

function ">=” (Left, Right : SQL_Int) return Boolean; 
pragma INLINE (”>=•'); 

-- this generic is instantiated once for every abstract 
domain based on the SQL type Int. 

-- the three subprogram foimal parameters are meant to 
default to the programs declared above, 
that is, the package should be instantiated in the 
scope of a use clause for SQL_Int_Pkg. 
the two actual types together form the abstract 
domain. 

-- the purpose of the generic is to create functions 
which convert between the two actual types and a 
procedure which implements a range constrained 
assignment for the null-bearing type. 

-- the bodies of these subprograms are calls to 

subprograms declared above and passed as defaults to 
the generic, 
generic 

type With_Null_type is limited private; 

type Without_null_type is range <>; 

with function With_Null„Base(Value : SQL_Int_Not_Null) 
return With__Null_Type is <>; 
with function Without_Null_Base (Value : With__Null_Type) 
return SQL_Int_Not_Null is <>; 
with procedure Assign__with__check ( 

Left : in out With_Null_Type; Right : With__Null_Type ; 

First, Last : SQL_Int_Not__Null) is <>; 
package SQL_Int_Ops is 

function With_Null (Value : Without_Null_type) 


84 Database Programming Language - SAMeDL 




VERSION 2 


return With_Null_type; 
pragma INLINE (With_Null); 

function Without_Null (Value : With_Null_Type) 
return Without_Null_type; 
pragma INLINE (Without_Null); 
procedure assign ( 

Left : in out With_null_Type; 

Right : in With_null_type); 
pragma INLINE (assign); 
end SQL_Int__Ops ; 
private 

type SQL_Int is record 

Is_Null: Boolean := True; 

Value: SQL_Int_Not_Null; 
end record; 
end SQL_Int_Pkg; 

C.2.4 SQL_Smallint_Pkg 


with Interfaces.SQL; 

with SQL_Boolean_Pkg; use SQL_Boolean_Pkg; 
with SQL_Char_Pkg; use SQL_Char_Pkg; 
package SQL_Smallint_Pkg is 

type SQL_Smallint_Not_Null is new Interfaces.SQL.Smallint; 

- Possibly Null Integer - 

type SQL_Smallint is limited private; 
function Null_SQL_Smallint return SQL_Smallint; 
pragma INLINE (Null_SQL_Smallint); 

-- this pair of functions converts between the 
null-bearing and not null-bearing types, 
function Wi thou t__Null_Base (Value : SQL_Smallint) 
return SQL_Smallint_Not_Null; 
pragma INLINE (Without_Null_Base); 

-- With_Null_Base raises Null_Value_Error if the input 
value is null 

function With_Null_Base(Value : SQL_Smallint_Not_Null) 
return SQL_Smallint; 
pragma INLINE (With_Null_Base); 

— this procedure implements range checking 

— note: it is not meant to be used directly 

by application programmers 

— see the generic package SQL_Smallint_Op 
-- raises constraint_error if not 

(First <= Right <= Last) 
procedure Assign_with_check ( 

Left : in out SQL__Smallint; Right : SQL_Smallint; 

First, Last : SQL_Smallint_Not_Null); 
pragma INLINE (Assign_with_check); 

-- the following functions implement three valued 
arithmetic 

-- if either input to any of these functions is null 
the function returns the null value; otherwise 
they perform the indicated operation 
-- these functions raise no exceptions 

function "+"(Right : SQL_Smallint) return SQL_Smallint; 
pragma INLINE ("+”); 

function "-"(Right : SQL_Smallint) return SQL_Smallint; 
pragma INLINE ("-"); 

function "abs"(Right : SQL_Smallint) return SQL_Smallint; 
pragma INLINE ("abs"); 

function (Left, Right : SQL_Smallint) return SQL_Smallint; 
pragma INLINE ("+"); 

function "*"(Left, Right : SQL_Smallint) return SQL_Smallint; 
pragma INLINE ("*"); 

function "-"(Left, Right : SQL_Smallint) return SQL_Smallint; 
pragma INLINE ("-"); 

function "/"(Left, Right ; SQL_Smallint) return SQL_Smallint; 


Standard Support Operations and Specifications 85 




VERSION 2 


pragma INLINE ("/”); 

function "mod” (Left, Right : SQL_Smallint) return SQL_Smallint; 
pragma INLINE {"mod"); 

function "rem" (Left, Right : SQL_Smallint) return SQL_Smallint; 
pragma INLINE ("rem"); 

function "**" (Left : SQL_Smallint; Right: Integer) 
return SQL_Smallint; 
pragma INLINE (■•**-); 

-- simulation of 'IMAGE and 'VALUE that 
-- return/take SQL_Char[_Not_Null] instead of string 
function IMAGE (Left : SQL_Smallint_Not_Null) 
return SQL_Char_Not_Null; 

function IMAGE (Left : SQL_Smallint) return SQL_Char; 
pragma INLINE (IMAGE); 

function VALUE (Left : SQL_Char_Not_Null) 
return SQL_Smallint_Not_Null; 
function VALUE (Left : SQL_Char) return SQL_Smallint; 
pragma INLINE (VALUE); 

-- Logical Operations -- 

-- type X type => Boolean_with_unknown -- 
-- these functions implement three valued logic 
-- if either input is the null value, the functions 
return the truth value UNKNOWN; otherwise they 
perform the indicated comparison. 

-- these functions raise no exceptions 
function Equals (Left, Right : SQL_Smallint) 
return Boolean_with_Unknown; 
pragma INLINE (Equals); 

function Not_Equals (Left, Right : SQL_Smallint) 
return Boolean_with_Unknown; 
pragma INLINE (Not_Equals); 
function "<" (Left, Right : SQL_Smallint) 
return Boolean_with_Unknown; 
pragma INLINE ("<"); 

function ">" (Left, Right : SQL_Smallint) 
return Boolean_with_Unknown; 
pragma INLINE (">”); 

function "<=" (Left, Right : SQL_Smallint) 
return Boolean__with_Unknown; 
pragma INLINE ("<="); 

function ">=" (Left, Right : SQL_Smallint) 
return Boolean_with__Unknown; 
pragma INLINE (">="); 

-- type => Boolean -- 

function Is_Null(Value : SQL_Smallint) return Boolean; 
pragma INLINE (Is__Null); 

function Not_Null(Value : SQL_Smallint) return Boolean; 
pragma INLINE (Not„Null); 

-- These functions of class type => Boolean 

equate UNKNOWN with FALSE. That is, they return TRUE 
-- only when the function returns TRUE. UNKNOWN and FALSE 
-- are mapped to FALSE. 

function (Left, Right : SQL_Smallint) return Boolean; 

pragma INLINE {'• = -•); 

function (Left, Right : SQL_Smallint) return Boolean; 

pragma INLINE ("<"); 

function (Left, Right : SQL_Smallint) return Boolean; 

pragma INLINE (">"); 

function "<=" (Left, Right : SQL_Smallint) return Boolean; 
pragma INLINE ("<="); 

function ">=" (Left, Right : SQL_Smallint) return Boolean; 
pragma INLINE (">="); 

this generic is instantiated once for every abstract 
domain based on the SQL type Smallint. 

-- the three subprogram formal parameters are meant to 
default to the programs declared above, 
that is, the package should be instantiated in the 
scope of a use clause for SQL_Smallint„Pkg. 


86 Database Programming Language - SAMeDL 



VERSION 2 


-- the two actual types together form the abstract 
domain. 

““ the purpose of the generic is to create functions 
which convert between the two actual types and a 
procedure which implements a range constrained 
assignment for the null-bearing type. 

-- the bodies of these subprograms are calls to 

subprograms declared above and passed as defaults to 
the generic, 
generic 

type With_Null_type is limited private; 

type Without_null_type is range <>; 

with function With_Null_Base(Value : SQL_Smallint_Not_Null) 
return With_Null_Type is <>; 
with function Without_Null_Base(Value : With__Null_Type) 
return SQL_Smallint_Not_Null is <>; 
with procedure Assign_with_check ( 

Left : in out With__Null_Type; Right : With_Null_Type; 
First, Last ; SQL_Smallint_Not„Null) is <>; 
package SQL_Smallint_Ops is 

function With_Null (Value : Without_Null_type) 
return With_Null_type; 
pragma INLINE (With_Null); 

function Without_Null (Value : With_Null_Type) 
return Without_Null_type; 
pragma INLINE (Without_Null); 
procedure assign ( 

Left : in out With_null_Type; 

Right : in With_null_type); 
pragma INLINE (assign); 
end SQL_Smallint_Ops; 
private 

type SQL_Smallint is record 
Is_Null: Boolean := True; 

Value: SQL_Smallint_Not_Null; 
end record; 
end SQL_Smallint_Pkg; 

C.2.5 SQL_Real_Pkg 


with Interfaces.SQL; 

with SQL_Boolean_Pkg; use SQL_Boolean_Pkg; 
package SQL_Real_Pkg is 

type SQL_Real_Not_Null is new Interfaces.SQL.Real; 

- Possibly Null Real - 

type SQL_Real is limited private; 
function Null_SQL_Real return SQL_Real; 
pragma INLINE (Null_SQL_Real) ; 

-- this pair of functions converts between the 
null-bearing and not null-bearing types 
function Without_Null_Base(Value : SQL_Real) 
return SQL_Real_Not_Null; 
pragma INLINE (Without_Null_Base); 

— With_Null_Base raises Null_Value_Error if the input 
value is null 

function With_Null_Base(Value : SQL_Real_Not_Null) 
return SQL_Real; 
pragma INLINE (With_Null_Base); 

-- this procedure implements range checking 
-- note: it is not meant to be used directly 
by application programmers 
-- see the generic package SQL_Real_Ops 
-- raises constraint_error if not 
(First <= Right <= Last) 
procedure Assign__with_Check ( 

Left : in out SQL_Real; Right : SQL_Real; 

First, Last : SQL_Real_Not_Null); 


Standard Support Operations and Specifications 87 


VERSION 2 


pragma INLINE (Assign_with_Check); 

-- the following functions implement three valued 
-- arithmetic 

-- if either input to any of these functions is null 
the function returns the null value; otherwise 
they perform the indicated operation 
-- these functions raise no exceptions 
function "+"(Right : SQL_Real) return SQL„Real; 
pragma INLINE ("+"); 

function "-’’(Right : SQL_Real) return SQL_Real; 
pragma INLINE (" - ") ; 

function ’’abs’’(Right : SQL_Real) return SQL_Real; 
pragma INL INE (" abs ’’) ; 

function "+"(Left, Right : SQL_Real) return SQL_Real; 
pragma INLINE ("+"); 

function "^"(Left, Right : SQL_Real) return SQL_Real; 
pragma INLINE ("*"); 

function ’’-’’(Left, Right : SQL_Real) return SQL_Real ; 
pragma INLINE ("-"); 

function ’’/"(Left, Right : SQL_Real) return SQL_Real; 
pragma INLINE ("/"); 

function "**'’(Left : SQL_Real; Right : Integer) return SQL_Real; 
pragma INLINE (■'**>■); 

-- Logical Operations -- 

-- type X type => Boolean_with_unknown -- 
-- these functions implement three valued logic 
-- if either input is the null value, the functions 
return the truth value UNKNOWN; otherwise they 
perform the indicated comparison. 

-- these functions raise no exceptions 
function Equals (Left, Right : SQL_Real) 
return Boolean__with_Unknown; 
pragma INLINE (Equals); 

function Not_Equals (Left, Right : SQL_Real) 
return Boolean_with_Unknown; 
pragma INLINE (Not_Eguals); 

function "<" (Left, Right : SQL_Real) return Boolean_with_Unknown; 
pragma INLINE ( " <") ; 

function ">" (Left, Right : SQL_Real) return Boolean_with_Unknown; 
pragma INLINE (">’’) ; 

function "<=" (Left, Right : SQL_Real) return Boolean_with_Unknown; 
pragma INLINE ("<="); 

function ">=" (Left, Right : SQL_Real) return Boolean_with_Unknown; 
pragma INLINE (">="); 

-- type => Boolean -- 

function Is_Null(Value : SQL_Real) return Boolean; 
pragma INLINE (Is^Null); 

function Not_Null(Value : SQL_Real) return Boolean; 
pragma INLINE {Not_Null); 

-- These functions of class type => Boolean 
-- equate UNKNOWN with FALSE. That is, they return TRUE 
-- only when the function returns TRUE. UNKNOWN and FALSE 
-- are mapped to FALSE. 

function "=" (Left, Right : SQL_Real) return Boolean; 
pragma INLINE ("="); 

function ’’<" (Left, Right : SQL_Real) return Boolean; 
pragma INLINE {"<’’); 

function ">■’ (Left, Right : SQL„Real) return Boolean; 
pragma INLINE (">"); 

function "<=" (Left, Right : SQL_Real) return Boolean; 
pragma INLINE ("<="); 

function (Left, Right : SQL_Real) return Boolean; 

pragma INLINE (">="); 

-- this generic is instantiated once for every abstract 
domain based on the SQL type Real, 
the three subprogram formal parameters are meant to 
default to the programs declared above. 

-- that is, the package should be instantiated in the 


88 Database Programming Language - SAMeDL 



VERSION 2 


scope of the use clause for SQL_Real__Pkg. 

-- the two actual types together form the abstract 
domain. 

the purpose of the generic is to create functions 
which convert between the two actual types and a 
procedure which implements a range constrained 
assignment for the null-bearing type. 

-- the bodies of these subprograms are calls to 

subprograms declared above and passed as defaults to 
the generic, 
generic 

type With_Null_type is limited private; 

type Without_null_type is digits <>; 

with function With_Null_Base(Value : SQL_Real_Not_Null) 
return With_Null_Type is <>; 
with function Without_Null_Base(Value : With_Null_Type) 
return SQL_Real_Not_Null is <>; 
with procedure Assign_with_check ( 

Left : in out With_Null_Type; Right : With_Null_Type; 
First, Last : SQL_Real_Not_Null) is <>; 
package SQL_Real_Ops is 

function With_Null (Value : Without_Null_type) 
return With_Null_type; 
pragma INLINE (With^Null); 

function Without_Null (Value : With_Null_Type) 
return Without_Null_type; 
pragma INLINE (Without_Null); 
procedure assign ( 

Left : in out With_Null_Type; 

Right : in With_Null_type); 
pragma INLINE (assign); 
end SQL_Real_Ops; 
private 

type SQL_Real is record 

Is_Null: Boolean := True; 

Value; SQL_Real_Not_Null; 
end record; 
end SQL_Real_Pkg; 

C.2.6 SQL_Double_Precislon_Pkg 


with Interfaces.SQL; 

with SQL_Boolean_Pkg; use SQL_Boolean_Pkg; 
package SQL_Double_Precision_Pkg is 

type SQL_Double_Precision_Not_Null is new 
Interfaces.SQL.Double_Precision; 

- Possibly Null Double_Precision - 

type SQL_Double_Precision is limited private; 

function Null_SQL_Double_Precision return SQL_Double_Precision; 
pragma INLINE (Null_SQL_Double_Precision); 

— this pair of functions converts between the 
null-bearing and not null-bearing types, 
function Without_Null_Base(Value : SQL_Double_Precision) 
return SQL_Double__Precision_Not_Null ; 
pragma INLINE (Without__Null_Base) ; 

-- With_Null_Base raises Null_Value_Error if the input 
value is null 

function With_Null_Base(Value : SQL_Double_Precision_Not_Null) 
return SQL_Double_Precision; 
pragma INLINE (With_Null_Base); 

-- this procedure implements range checking 
-- note: it is not meant to be used directly 
by application programmers 
-- see the generic package SQL_Double_Precision_Op 
-- raises constraint_error if not 
(First <= Right <= Last) 
procedure Assign_with_Check ( 


Standard Support Operations and Specifications 89 



VERSION 2 


Left : in out SQL_Double_Precision; 

Right : SQL_Double_Precision; 

First, Last : SQL_Double_Precision_Not_Null); 
pragma INLINE (Assign_with_Check); 

-- the following functions implement three valued 
arithmetic 

-- if either input to any of these functions is null 

the function returns the null value; otherwise they 
perform the indicated operation 
-- these functions raise no exceptions 
function (Right : SQL_Double_Precision) 
return SQL_Double_Precision; 
pragma INLINE (”+"); 

function "-"(Right : SQL_Double_Precision) 
return SQL_Double_Precision; 
pragma INLINE ("-"); 

function "abs"(Right : SQL_Double_Precision) 
return SQL_Double_Precision; 
pragma INLINE ("abs"); 

function '' + "(Left, Right : SQL_Double_Precision) 
return SQL_Double_Precision; 
pragma INLINE (" +"); 

function "*"(Left, Right : SQL_Double_Precision) 
return SQL_Double_Precision; 
pragma INLINE ("*"); 

function "-"(Left, Right : SQL_Double_Precision) 
return SQL_Double_Precision; 
pragma INLINE ("-"); 

function "/"(Left, Right : SQL_Double_Precision) 
return SQL_Double_Precision; 
pragma INLINE { " / ") ; 

function "**"(Left : SQL_DoubIe_Precision; Right : Integer) 
return SQL_Double_Precision; 
pragma INLINE (-**"); 

-- Logical Operations -- 

type X type => Boolean_with„un3cnown -- 
-- these functions implement three valued logic 
-- if either input is the null value, the functions 
return the truth value UNKNOWN; otherwise they 
perform the indicated comparison. 

-- these functions raise no exceptions 
function Equals (Left, Right ; SQL_Double_Precision) 
return Boolean_with_Unknown; 
pragma INLINE (Equals); 

function Not_Equals (Left, Right ; SQL_Double_Precision) 
return Boolean_with_Unknown; 
pragma INLINE (Not_Equals); 

function "<" (Left, Right : SQL_Double_Precision) 
return Boolean_with_Unknown; 
pragma INLINE ("<"); 

function ">" (Left, Right : SQL_Double_Precision) 
return Boolean_with_Unknown; 
pragma INLINE (">"); 

function "<=" (Left, Right : SQL_Double_Precision) 
return Boolean_with_Unknown; 
pragma INLINE ("<="); 

function ">=" (Left, Right : SQL_Double„Precision) 
return Boolean_with_Unknown; 
pragma INLINE (">="); 

type => Boolean -- 

function Is__Null(Value : SQL_Double_Precision) return Boolean; 
pragma INLINE (Is_Null); 

function Not_Null(Value : SQL_Double_Precision) return Boolean; 
pragma INLINE (Not_Null); 

-- These functions of class type => Boolean 
-- equate UNKNOWN with FALSE. That is, they return TRUE 
-- only when the function returns TRUE. UNKNOWN and FALSE 
-- are mapped to FALSE. 


90 Database Programming Language - SAMeDL 



VERSION 2 


function "=" (Left, Right : SQL_Double_Precision) return Boolean; 

function "<" (Left, Right : SQL_Double_Precision) return Boolean; 

function (Left, Right : SQL_Double_Precision) return Boolean; 

function ”<=" (Left, Right : SQL_Double_Precision) return Boolean; 
function (Left, Right : SQL_Double_Precision) return Boolean; 

this generic is instantiated once for every abstract 
domain based on the SQL type Double_Precision. 

-- the three subprogram formal parameters are meant to 
default to the programs declared above. 

-- that is, the package should be instantiated in the 
scope of the use clause for 
SQL_Double_Precision_Pkg. 

-- the two actual types together form the abstract 
domain. 

-- the purpose of the generic is to create functions 
which convert between the two actual types and a 
procedure which implements a range constrained 
assignment for the null-bearing type. 

-- the bodies of these subprograms are calls to 

subprograms declared above and passed as defaults 
to the generic, 
generic 

type With_Null_type is limited private; 
type Without_null_type is digits <>; 
with function With_Null_Base( 

Value : SQL_Double_Precision_Not_Null) 
return With_NulLType is <>; 
with function Without_Null_Base(Value : With_Null_Type) 
return SQL_Double_Precision_Not_Null is <>; 
with procedure Assign_with_check ( 

Left : in out With_Null_Type; Right : With_Null_Type; 

First, Last : SQL_Double_Precision_Not_Null) is <>; 
package SQL_Double_Precision_Ops is 

function With_Null (Value : Without_Null_type) 
return With_Null_type; 
pragma INLINE (With_Null); 

function Without_Null (Value : With_Null_Type) 
return Wi thout_Nul l__type ; 
pragma INLINE (Without_Null) ; 
procedure assign ( 

Left : in out With_null_Type; 

Right : in With_null_type); 
pragma INLINE (assign); 
end SQL_Double_Precision_Ops; 
private 

type SQL_Double_Precision is record 
Is_Null: Boolean := True; 

Value: SQL_Double_Precision_Not_Null; 

end record; 

end SQL_Double_Precision__Pkg; 

C.2.7 SQL_Char_Pkg 


with SQL_System; use SQL_System; 
with SQL_Boolean_Pkg; use SQL_Boolean_Pkg; 
with Interfaces.SQL; 
package SQL_Char_Pkg is 

subtype SQL_Char_Length is natural 
range 1 .. MAXCHRLEN; 
subtype SQL_Unpadded_Length is natural 
range 0 .. MAXCHRLEN; 

type SQL_Char_Not_Null is new Interfaces.SQL.Char; 
type SQL_Char{Length : SQL_Char„Length) is limited private; 
function Null_SQL_Char return SQL_Char; 
pragma INLINE (Null_SQL_Char); 

-- the next three functions convert between 
null-bearing and not null-bearing-types 


standard Support Operations and Specifications 91 



VERSION 2 


-- Without_Null_Base and With_Null_Base are 
inverses (mod. null values) 

-- see also SQL„Char_Ops generic package below 
function With_Null_Base(Value : SQL„Char_Not_Null) 
return SQL_Char; 
pragma INLINE (With_Null_.Base) ; 

-- Without_Null_Base and Without_Null_Base_Unpadded raise 
null_value_error on the null input 
function Without_Null__Base (Value : SQL_Char) 
return SQL_Char_Not_Null; 
pragma INLINE (Without_Null_Base); 

-- Without_Null_Unpadded_Base removes trailing blanks from 
the input 

function Without_Null_Unpadded_Base(Value : SQL_Char) 
return SQL_Char_Not_Null; 
pragma INLINE (Without_Null_Unpadded_Base); 

-- axiom: unpadded_Length(x) = 

Without_Null_Unpadded_Base(x)'Length 
~~ both functions raise null_value_error if x is null 
-- the next six functions convert between Standard.String 
types and the SQL_Char and SQL_Char_Not_Null types 
function To_String (Value : SQL_Char_Not_Null) 
return String; 

function To„String (Value : SQL__Char) 
return String; 

function To_Unpadded_String (Value : SQL_Char„Not_Null) 
return String; 

function To_Unpadded_String (Value : SQL_Char) 
return String; 

pragma INLINE (To_Unpadded_String); 

this INLINE works for BOTH functions!! 
function To_SQL_Char_Not__Null (Value : String) 
return SQL_Char__Not„Null ; 
function To_SQL_Char (Value : String) 
return SQL_Char; 
pragma INLINE (To_SQL_Char); 
function Unpadded_Length (Value : SQL_Char) 
return SQL_Unpadded_Length; 
pragma INLINE (Unpadded_Length); 
procedure Assign( 

Left : out SQL_Char; 

Right : SQL_Char); 
pragma INLINE (Assign); 

-- Substring(x,k,m) returns the substring of x starting 
at position k (relative to 1) with length m. 

-- returns null value if x is null 

-- raises constraint_error if Start < 1 or Length < 1 or 
Start + Length - 1 > x.Length 
function Substring ( 

Value : SQL^Char; 

Start, Length : SQL_Char_Length) 
return SQL_Char; 
pragma INLINE (Substring); 

-- "Sc" returns null if either parameter is null; 

otherwise performs concatenation in the usual way, 
preserving all blanks. 

-- may raise constraint_error implicitly if result is 

too large (i.e., greater than SQL_Char_Length'Last 
function "Sc" (Left, Right : SQL_Char) 
return SQL_Char; 
pragma INLINE ("&"); 

Logical Operations -- 
-- type X type => Boolean_with_unknown -- 
-- the comparison operators return the boolean value 
UNKNOWN if either parameter is null; otherwise, 
the comparison is done in accordance with 
ANSI X3.135-1986 para 5.11 general rule 5; that is, 
the shorter of the two string parameters is 


92 Database Programming Language - SAMeDL 


VERSION 2 


effectively padded with blanks to be the length of 
the longer string and a standard Ada comparison is 
then made 

function Equals (Left, Right : SQL_Char) 
return Boolean_with_Unknown; 
pragma INLINE (Equals); 

function Not_Equals (Left, Right : SQL_Char) 
return Boolean_with_Unknown; 
pragma INLINE (Not_Equals); 

function ”<" (Left, Right : SQL_Char) return Boolean_with_Unknown; 
pragma INLINE ("<''); 

function (Left, Right : SQL_Char) return Boolean_with_Unknown; 

pragma INLINE (">"); 

function ”<=" (Left, Right : SQL_Char) return Boolean_with_Unknown; 
pragma INLINE ("<="); 

function ">=" (Left, Right : SQL_Char) return Boolean_with_Unknown; 
pragma INLINE (”>="); 

-- type => Boolean -- 

function Is_Null(Value : SQL_Char) return Boolean; 
pragma INLINE (Is_Null); 

function Not_Null(Value : SQL_Char) return Boolean; 
pragma INLINE (Not_Null); 

-- These functions of class type => Boolean 
-- equate UNKNOWN with FALSE. That is, they return TRUE 
-- only when the function returns TRUE. UNKNOWN and FALSE 
are mapped to FALSE. 


function 

(Left, 

Right : 

SQL_Char) 

return 

Boolean; 

pragma INLINE 

(" = ") 

t 




function 

(Left, 

Right : 

SQL_Char) 

return 

Boolean; 

pragma INLINE 

("<„) 

/ 




function ">" 

(Left, 

Right : 

SQL_Char) 

return 

Boolean; 

pragma INLINE 

(">") 

/ 




function "<=" 

(Left 

, Right 

: SQL_Char) 

return Boolean 


pragma INLINE (''<=“); 

function ">=" (Left, Right : SQL_Char) return Boolean; 
pragma INLINE (">=:'') ; 

-- the purpose of the following generic is to generate 
conversion functions between a type derived from 
SQL_Char_Not_Null, which are effectively Ada 
strings and a type derived from SQL_Char, which 
mimic the behavior of SQL strings. 

-- the subprogram formals are meant to default; that is, 
this generic should be instantiated in the scope 
of an use clause for SQL_Char_Pkg. 
generic 

type With_Null__Type is limited private; 

type Without_Null_Type is array (positive range <>) 

of Interfaces.SQL.Character_Type; 
with function With__Null_Base (Value: SQL_Char_Not_Null) 
return With_Null_Type is <>; 
with function Without_Null_Base (Value: With_Null_Type) 
return SQL_Char_Not_Null is <>; 

with function Without_Null_Unpadded_Base (Value: With_Null_Type) 
return SQL_Char_Not_Null is <>; 
package SQL__Char_Ops is 

function With_Null (Value : Without_Null_Type) 
return With_Null_Type; 
pragma INLINE (With_Null); 

function Without_Null (Value : With_Null_Type) 
return Without_Null__Type; 
pragma INLINE (Without_Null) ; 

function Without_Null_Unpadded (Value : With_Null_Type) 
return Without_Null_Type; 
pragma INLINE (Without_Null_Unpadded); 
end SQL_Char_Ops; 
private 

type SQL_Char (Length : SQL__Char_Length) is record 
Is_Null: Boolean := True; 


Standard Support Operations and Specifications 93 





VERSION 2 


Unpadded__Length: SQL_Unpadded_Length ; 
Text: SQL_Char_Not_Null(1 .. Length); 
end record; 
end SQL_Char_Pkg; 

C.2.8 SQL_VarChar_Pkg 


mimics Ada.Strings.Bounded while also adding 3-valued 
-- comparison operators and conversion functions 
with Ada.Strings.Maps; 
with Ada,Finalization; 

with Interfaces.SQL, Interfaces.SQL,Varying; 
package SQL_VarChar is 

subtype SQL_VarChar_Not_Null is Interfaces.SQL.Varying.Char; 
type SQL_VarChar is private; 

function Null_SQL__VarChar return SQL_VarChar; 

function 

function Length (Source : SQL_VarChar) return Natural; 
function To_SQL_VarChar (Source : Interfaces.SQL.Char) 
return SQL^VarChar; 

-- Without_Null_Base and With_Null_Base are 
inverses (mod. null values) 

-- see also SQL_Char_Ops generic package below 
function With_Null_Base(Value : SQL_VarChar_Not_Null) 
return SQL_Char; 

-- Without_Null_Base and Without„Null_Base_Unpadded raise 
null_value_error on the null input 
function Without_Null_Base(Value : SQL_VarChar) 
return SQL_VarChar_Not_Nul1; 

function To„SQL__VarChar (Length : in Natural) return SQL_VarChar; 
function To_SQL_Char (Source : SQL_VarChar) return Interfaces.SQL.Char; 
procedure Append (Source : in out SQL_VarChar; 

New_Item : in SQL_VarChar); 
procedure Append (Source : in out SQL_VarChar; 

New_Item : in Interfaces.SQL.Char); 
procedure Append (Source : in out SQL_VarChar; 

New__Item : in Character) ; 

function (Left, Right : SQL_VarChar) return SQL_VarChar; 

function (Left : in SQL_VarChar; 

Right : in Interfaces.SQL.Char) return SQL_VarChar; 
function (Left : in Interfaces.SQL.Char; 

Right : in SQL_VarChar) return SQL_VarChar; 
function (Left : in SQL_VarChar; 

Right : in Character) return SQL_VarChar; 
function (Left : in Character; 

Right : in SQL__VarChar) return SQL_VarChar; 
function Element (Source : in SQL_VarChar; 

Index : in Positive) return Character; 
procedure Replace_Element (Source : in out SQL_VarChar; 

Index : in Positive; By : Character); 
function Slice (Source : in SQL_VarChar; 

Low : in Positive; High : in Natural) 
return Interfaces.SQL.Char; 
function (Left, Right : in SQL_VarChar) 

return Boolean__with__Unknown; 
function (Left : in SQL_VarChar; 

Right : in Interfaces.SQL.Char) return Boolean_with_Unknown; 
function (Left : in Interfaces.SQL.Char; 

Right : in SQL_VarChar) return Boolean__with_Unknown; 
function "<" (Left, Right : in SQL_VarChar) 
return Boolean_with_Unknown; 
function (Left : in SQL_VarChar; 

Right : in Interfaces.SQL.Char) return Boolean_with__Unknown; 
function "<« (Left : in Interfaces.SQL.Char; 

Right : in SQL_VarChar) return Boolean_with_Unknown; 
function "<=" (Left, Right : in SQL_VarChar) 
return Boolean_with_Unknown; 


94 Database Programming Language - SAMeDL 



VERSION 2 


function "<=" (Left : in SQL_VarChar; 

Right : in Interfaces.SQL.Char) return Boolean„with_Unknown; 
function "<=" (Left : in Interfaces.SQL.Char; 

Right : in SQL_VarChar) return Boolean_with_Unknown; 
function ">" (Left, Right : in SQL_VarChar) 
return Boolean_with_Unknown; 
function (Left : in SQL^VarChar; 

Right : in Interfaces.SQL.Char) return Boolean_with_Unknown; 
function (Left : in Interfaces.SQL.Char; 

Right : in SQL_VarChar) return Boolean_with_Unknown; 
function ">=" (Left, Right : in SQL_VarChar) 
return Boolean_with_Unknown; 
function ">=" (Left : in SQL_VarChar; 

Right : in Interfaces.SQL.Char) return Boolean_with_Unknown; 
function ">=" (Left : in Interfaces.SQL.Char; 

Right : in SQL_VarChar) return Boolean_with_Unknown; 

-- these versions of the relationship tests 
-- equate UNKNOWN with FALSE 

function "=" (Left, Right : in SQL_VarChar) return Boolean; 
function "=" (Left : in SQL_VarChar; 

Right : in Interfaces.SQL.Char) return Boolean; 
function (Left : in Interfaces.SQL.Char; 

Right : in SQL_VarChar) return Boolean; 
function (Left, Right : in SQL_VarChar) return Boolean; 

function (Left : in SQL_VarChar; 

Right : in Interfaces.SQL.Char) return Boolean; 
function "<" (Left : in Interfaces,SQL.Char; 

Right : in SQL_VarChar) return Boolean; 
function "<=" (Left, Right : in SQL_VarChar) return Boolean; 
function "<=" (Left : in SQL_VarChar; 

Right : in Interfaces.SQL.Char) return Boolean; 
function "<=" (Left : in Interfaces.SQL.Char; 

Right : in SQL_VarChar) return Boolean; 
function ">" (Left, Right : in SQL_VarChar) return Boolean; 
function ">" (Left : in SQL_VarChar; 

Right : in Interfaces.SQL.Char) return Boolean; 
function ">" (Left : in Interfaces,SQL.Char; 

Right : in SQL_VarChar) return Boolean; 
function ">=" (Left, Right : in SQL_VarChar) return Boolean; 
function ">=" (Left : in SQL_VarChar; 

Right : in Interfaces.SQL.Char) return Boolean; 
function ">=" (Left : in Interfaces.SQL.Char; 

Right : in SQL_VarChar) return Boolean; 

--- Search Subprograms -- 

function Index (Source : in SQL__VarChar; 

Pattern : in Interfaces.SQL.Char; 

Going : in Direction := Forward; 

Mapping : in Maps.Character_Mapping := Maps.Identity) 
return Natural; 

function Index (Source : in SQL_VarChar; 

Pattern : in Interfaces.SQL.Char; 

Going : in Direction := Fojrward; 

Mapping : in Maps.Character_Mapping_Function) 
return Natural; 

function Index (Source : in SQL_VarChar; 

Set : in Maps.Character_Set; 

Test ; in Membership := Inside; 

Going : in Direction := Forward) 
return Natural; 

function Index_Non_Blank (Source : in SQL_VarChar; 

Going : in Direction := Forward) 
return Natural; 

function Count (Source : in SQL_VarChar; 

Pattern : in Interfaces.SQL.Char; 

Mapping : in Maps.Character_Mapping := Maps.Identity) 
return Natural; 

function Count (Source ; in SQL_VarChar; 

Pattern : in Interfaces.SQL.Char; 


Standard Support Operations and Specifications 95 






VERSION 2 


Mapping : in Maps.Character_Mapping_Function) 
return Natural; 

function Count (Source : in SQL_VarChar; 

Set : in Maps.Character_Set) 
return Natural; 

procedure Find_Token (Source : in SQL_VarChar; 

Set : in Maps.Character_Set; 

Test : in Membership; 

First : out Positive; Last : out Natural); 
function Translate (Source : in SQL_VarChar; 

Mapping : in Maps.Character_Mapping) 
return SQL_VarChar; 

procedure Translate (Source : in out SQL_VarChar; 

Mapping : Maps.Character_Mapping); 
function Translate (Source : in SQL_VarChar; 

Mapping : in Maps,Character_Mapping_Function) 
return SQL_VarChar; 

procedure Translate (Source : in out SQL_VarChar; 

Mapping : in Maps.Character_Mapping_Function); 
function Replace_Slice (Source : in SQL_VarChar; 

Low : in Positive; 

High : in Natural; 

By : in Interfaces.SQL.Char) 
return SQL_VarChar; 

procedure Replace_Slice (Source : in out SQL_VarChar; 
Low : in Positive; 

High : in Natural; 

By : in Interfaces.SQL.Char); 
function Insert (Source : in SQL_VarChar; 

Before : in Positive; 

New__Item : in Interfaces . SQL. Char) 
return SQL_VarChar; 

procedure Insert (Source : in out SQL_VarChar; 

Before : in Positive; 

New_Item : in Interfaces.SQL.Char); 
function Overwrite (Source : in SQL_VarChar; 

Position : in Positive; 

New__Item : in Interfaces . SQL. Char) 
return SQL_VarChar; 

procedure Overwrite (Source : in out SQL_VarChar; 
Position : in Positive; 

New_Item : in Interfaces.SQL.Char); 
function Delete (Source : in SQL_VarChar; 

From : in Positive; 

Through : in Natural) 
return SQL_VarChar; 

procedure Delete (Source : in out SQL_VarChar; 

From : in Positive; 

Through : in Natural); 
function Trim (Source : in SQL_VarChar; 

Side : in Trim_End) 
return SQL_VarChar; 

procedure Trim (Source : in out SQL_VarChar; 

Side : in Trim_End); 
function Trim (Source : in SQL_VarChar; 

Left : in Maps.Character_Set; 

Right : in Maps.Character_Set) 
return SQL_VarChar; 

procedure Trim (Source : in out SQL_.VarChar; 

Left : in Maps.Character_Set; 

Right : in Maps.Character_Set); 
function Head (Source : in SQL_VarChar; 

Count : in Natural; 

Pad : in Character := Space) 
return SQL_VarChar; 

procedure Head (Source : in out SQL_VarChar; 

Count : in Natural; 

Pad : in Character := Space); 


96 Database Programming Language - SAMeDL 



VERSION 2 


function Tail (Source : in SQL_VarChar; 

Count : in Natural; 

Pad : in Character := Space) 
return SQL_VarChar; 

procedure Tail (Source : in out SQL_VarChar; 

Count : in Natural; 

Pad : in Character := Space); 
function (Left : in Natural; 

Right : in Character) 
return SQL_VarChar; 
function (Left : in Natural; 

Right : in Interfaces.SQL.Char) 
return SQL_VarChar; 
function (Left : in Natural; 

Right : in SQL_VarChar) 
return SQL_VarChar; 
generic 

type With_Null_Type is limited private; 
type Without_Null_Type is limited private 
with function With_Null_Base (Value: Without_Null_Type) 
return With_Null_Type is <>; 
with function Without_Null_Base (Value: With_Null_Type) 
return SQL_VarChar_Not_Null is <>; 
with function Without_Null_Unpadded__Base (Value: With_Null_Type) 
return SQL_VarChar_Not_Null is <>; 
package SQL_VarChar_Ops is 

function With_Null (Value : Without_Null_Type) 
return With_Null_Type; 
pragma INLINE (With_Null); 

function Without_Null (Value : With_Null_Type) 
return Without_Null_Type; 
pragma INLINE (Without^Null); 

function Without_Null_Unpadded (Value : With_Null_Type) 
return Without_Null_Type; 
pragma INLINE (Without_Null_Unpadded); 
end SQL_VarChar_Ops; 

private 

type SQL_VarChar is record 
Is_Null : Boolean := True; 

Text : SQL_VarChar„Not_Null; 
end record; 
end SQL_VarChar; 

C.2.9 SQL_Blt_Pkg 


with SQL_System; use SQL_System; 
with SQL_Boolean_Pkg; use SQL__Boolean_Pkg; 
with Interfaces.SQL; 
package SQL„Bit_Pkg is 

subtype SQL_Bit_Length is natural 
range 1 .. MAXCHRLEN; 
subtype SQL_Unpadded_Length is natural 
range 0 .. MAXCHRLEN; 

type SQL_Bit_Not_Null is new Interfaces.SQL.Bit; 
type SQL_Bit(Length : SQL_Bit_Length) is limited private; 
function Null_SQL_Bit return SQL_Bit; 
pragma INLINE (Null_SQL_Bit); 

the next three functions convert between 
null-bearing and not null-bearing-types 
— Without_Null_Base and With_Null_Base are 
inverses (mod. null values) 

— see also SQL_Bit_Ops generic package below 
function With_Null_Base(Value : SQL_Bit_Not_Null) 
return SQL__Bit; 

pragma INLINE (With_Null_Base); 

-- Without_Null_Base and Without_Null_Base_Unpadded raise 
null_value_error on the null input 


Standard Support Operations and Specifications 97 


VERSION 2 


function Without_Null_Base(Value : SQL_Bit) 
return SQL_Bit„Not_Null; 
pragma INLINE (Without_Null_Base); 
procedure Assign( 

Left : out SQL_Bit; 

Right : SQL_Bit); 
pragma INLINE (Assign); 

-- Substring(x,k,m) returns the substring of x starting 
at position k (relative to 1) with length m. 

-- returns null value if x is null 

-- raises constraint_error if Start < 1 or Length < 1 or 
Start + Length - 1 > x.Length 
function Substring ( 

Value : SQL_Bit; 

Start, Length : SQL_Bit_Length) 
return SQL_Bit; 
pragma INLINE (Substring); 

-- returns null if either parameter is null; 

otherwise performs concatenation in the usual way, 
preserving all blanks. 

““ may raise constraint_error implicitly if result is 
too large (i.e., greater than SQL_Bit_Length'Last 
function "Sc" (Left, Right : SQL_Bit) 
return SQL_Bit; 
pragma INLINE ("&"); 

-- Logical Operations -- 

-- type X type => Boolean_with_unknown -- 
--the comparison operators return the boolean value 
--UNKNOWN if either parameter is null; otherwise, 

--the comparison is done in accordance with 
--the rules of SQL 9075:1192 8.2 
function Equals (Left, Right : SQL_Bit) 
return Boolean_with_Unknown; 
pragma INLINE (Equals); 

function Not_Equals (Left, Right : SQL__Bit) 
return Boolean_with„Unknown; 
pragma INLINE (Not_Equals); 

function (Left, Right : SQL_Bit) return Boolean_with_Unknown; 

pragma INLINE ( "<"); 

function ">" (Left, Right : SQL_Bit) return Boolean_with_Unknown; 
pragma INLINE (">'') ; 

function "<=" (Left, Right : SQL_Bit) return Boolean„with_Unknown; 
pragma INLINE ("<="); 

function ">=’■ (Left, Right : SQL_Bit) return Boolean_with_Unknown; 
pragma INLINE (">="); 

-- type => Boolean -- 

function Is_Null(Value : SQL_Bit) return Boolean; 
pragma INLINE (Is„Null); 

function Not_Null(Value : SQL_Bit) return Boolean; 
pragma INLINE (Not_Null); 

-- These functions of class type => Boolean 
-- equate UNKNOWN with FALSE. That is, they return TRUE 
-- only when the function returns TRUE. UNKNOWN and FALSE 
-- are mapped to FALSE. 

function (Left, Right : SQL_Bit) return Boolean; 

pragma INLINE (" = ”); 

function ■'<'■ (Left, Right : SQL_Bit) return Boolean; 
pragma INLINE ("<"); 

function ">" (Left, Right : SQL_Bit) return Boolean; 
pragma INLINE (”>"); 

function "<=" (Left, Right : SQL_Bit) return Boolean; 
pragma INLINE ("<="); 

function ">=" (Left, Right : SQL_Bit) return Boolean; 
pragma INLINE (">=”); 

the purpose of the following generic is to generate 
conversion functions between a type derived from 
SQL„Bit_Not_Null, which are effectively Ada 
arrays and a type derived from SQL_Bit, which 


98 Database Programming Language - SAMeDL 




VERSION 2 


mimic the behavior of SQL bit strings. 

-- the subprogram formals are meant to default; that is, 
this generic should be instantiated in the scope 
of an use clause for SQL_Bit_Pkg. 

generic 

type With_Null_Type is limited private; 

type Without_Null_Type is array (positive range <>) 

of Interfaces.SQL.Bitacter_Type; 
with function With_Null_Base (Value: SQL_Bit__Not_Null) 
return With_Null_Type is <>; 
with function Without_Null_Base (Value: With_Null_Type) 
return SQL_Bit_Not_Null is <>; 

with function Without_Null_Unpadded_Base (Value: With_Null_Type) 
return SQL_Bit_Not_Null is <>; 
package SQL_Bit_Ops is 

function With_Null (Value : Without_Null_TYpe) 
return With_Null_Type; 
pragma INLINE (With_NuIl); 

function Without_Null (Value : With_Null_Type) 
return Without_Null_Type; 
pragma INLINE (Without_Null); 

function Without_Null_Unpadded (Value : With_Null_Type) 
return Without_Null_Type; 
pragma INLINE (Without_Null_Unpadded); 
end SQL_Bit_Ops; 
private 

type SQL_Bit(Length : SQL_Bit_Length) is record 
Is_Null: Boolean := True; 

Unpadded_Length: SQL_Unpadded_Length; 

Text: SQL_Bit_Not_Null(1 .. Length); 
end record; 
end SQL_Bit_Pkg; 

C.2.10 SQL_Enumeration_Pkg 


with SQL„Boolean_Pkg; use SQL_Boolean_Pkg; 
with SQL_Char_Pkg; use SQL_Char_Pkg; 
generic 

type SQL__Enumeration_Not_Null is (<>) ; 
package SQL_Enumeration_Pkg is 

- Possibly Null Enumeration - 

type SQL_Enumeration is limited private; 

function Null_SQL_Enumeration return SQL_Enumeration; 

pragma INLINE (Null_SQL_Enumeration); 

-- this pair of functions convert between the 
null-bearing and not null-bearing types, 
function Without_Null(Value : in SQL_Enumeration) 
return SQL_Enumeration_Not_Null; 
pragma INLINE (Without_Null); 

— With_Null raises Null_Value__Error if the input 
value is null 

function With^Null(Value : in SQL_Enumeration__Not_Null) 
return SQL_Enumeration; 
pragma INLINE (With_Null); 
procedure Assign ( 

Left : in out SQL_Enumeration; 

Right : in SQL_Enumeration); 
pragma INLINE (Assign); 

-- Logical Operations -- 

-- type X type => Boolean_with_unknown -- 

— these functions implement three valued logic 

— if either input is the null value, the functions 

return the truth value UNKNOWN; otherwise they 
perform the indicated comparison. 

-- these functions raise no exceptions 
function Equals (Left, Right : SQL_Enumeration) 
return Boolean_with_Unknown; 


Standard Support Operations and Specifications 99 



VERSION 2 


function Not_Equals (Left, Right : SQL_Enuraeration) 
return Boolean_with_Unknown; 
pragma INLINE (Not_Equals); 

function (Left, Right : SQL_Enumeration) 

return Boolean_with_Unknown; 
function ">■' (Left, Right : SQL_Enuineration) 
return Boolean_with_Unknown; 
function ’•<=" (Left, Right : SQL_Enuineration) 
return Boolean_with_Unknown; 
function ">=" (Left, Right : SQL_Ennmeration) 
return Boolean_with__Unknown; 

-- type => Boolean -- 

function Is_Null (Value : SQL_Enumeration) return Boolean; 
pragma INLINE (Is_Null); 

function Not_Null (Value : SQL_Enuineration) return Boolean; 
pragma INLINE (Not_Null); 

function "=" (Left, Right : SQL_Enuineration) return Boolean; 
pragma INLINE (•' = "); 

function "<" (Left, Right : SQL_Enuineration) return Boolean; 
pragma INLINE ("<"); 

function ">" (Left, Right : SQL^Enumeration) return Boolean; 
pragma INLINE ( ">") ; 

function "<=" (Left, Right : SQL_Enuineration) return Boolean; 
pragma INLINE (’■< = ’■); 

function ">=" (Left, Right : SQL_Enumeration) return Boolean; 
pragma INLINE (">=■'); 

-- the following six functions mimic the 

'Pred, 'Succ, 'Image, 'Pos, 'Val, and 'Value 
attributes of the SQL_Enumeration_Not_Null type, passed 
in, for the associated SQL__Enumeration (null) type 
-- they all raise the Null_Value_Error exception if a null 
value is passed in 

-- Pred raises the Constraint_Error exception if the value 
passed in is equal to SQL__Enumeration_Not_Null' Last 
-- Succ raises the Constraint_Error exception if the value 
passed in is equal to SQL_Enumeration_Not_Null'First 
-- Val raises the Constraint_Error exception if the value passed 
in is not in the range P'POS(P'FIRST)..P'POS(P'LAST) for 
type P 

-- Value raises the Constraint_Error exception if the sequence of 
characters passed in does not have the syntax of an 
enumeration literal for the instantiated enumeration type 
function Pred (Value : in SQL__Enumeration) 
return SQL_Enumeration; 
pragma INLINE (Pred); 

function Succ (Value : in SQL_Enumeration) 
return SQL_Enumeration; 
pragma INLINE (Succ); 

function Pos (Value : in SQL_Enumeration) return Integer; 
pragma INLINE (Pos); 

function Image (Value : in SQL_Enumeration) return SQL_Char; 
function Image (Value : in SQL_Enumeration_Not_Null) 
return SQL_Char__Not_Nul 1 ; 
pragma INLINE (Image); 

function Val (Value : in Integer) return SQL_Enumeration; 
pragma INLINE (Val); 

function Value (Value : in SQL_Char) return SQL_Enumeration; 
function Value (Value : in SQL_Char_Not_Null) 
return SQL_Enumeration_„Not_Null ; 
pragma INLINE (Value) ; 
private 

type SQL_Enumeration is record 
Is_Null: Boolean := True; 

Value: SQL_Enumeration__Not_Null; 

end record; 

end SQL_Enumeration__Pkg; 


100 Database Programming Language SAMeDL 



Annex D Transform Chart 


CO 

B 

o 

D 

O* 

o 

x: 


CD 
0 
E 

1 

Q. ® 

2 « 


c 

o 


0 


o 


CO 

o .E 
0 ) ^ 
■O c 


0 

c 

o 

Q- 


0 

x: 


c 

0 

5 

Q. O 
>. Q- 


c 

0 

c 

o 

Q. 

E 

o 

0 8 
§; E 


§ 0 


(0 :2 

■D 

3 I 0) 

Q. 

3 
O 


E 
0 
C 

I I 
0 0 
Q Q 


u. 

0 

w r" 

o o 

■E 

o 

■g 

g 

Q. 

2 o 

o 

o 

o 

0 

E 

0 

0 

Cl 0 
0 £ 

o 

0 

0 

£ 

o 

0 

L- 

*0 

< o 

o 

M— 

o 

5 

o 

C 

•*-> 

0 

0 0 


0 


D 

E 

£ E 

0 

E 

0 

0 

0 

z 

c ^ 
~ Z 

"D 

< 

0 

z 

"D 

< 

*0 

Q 


0 

<0 

0 

i— 

0 

0 

n 1 - 

Q. S 
0 0) 


0 c 
c5 o 

11 

S o 

Q- o 
0 T? 
:£ 0 


'tr O ^ 


Q. O 
X 0 


0 _ 
Q_ C 

.Q 

V- 

0 2 

£ « 

‘t:: ^ 
O 0 

o -o 

E ^ 
< 


^ *D 
0 0 
Q. O 
O 

•t—' k_ 

<j) CL 

£ 0 
l!! *0 
o < 
0 0 
E £ 
S5 c 


c 

0 

c 

o 

CL 

I ® 
0 

x: "o 

*0 8 
0 2 


c 

0 

c 

o 

Q. 

O g_ 

0 ^ 
-C *o 

'o 8 
0 E 


0 

Q. 

o ^ 
.9 o 


0 

a. 


UL 

o 

o 

E 

0 

E 

0 

L_ 

0 »- 

o 


-C 

0 

£ CO 

0 

o 


*0 

^ ~o 

■Q 

Vm. 

O 

0 

< 

0 

o < 
0 0 

C 

0 

*o 

< 

E 


E £ 

"O 

0 

0 

0 

c 

iS C 

0 

g 

z 


Z 

3 



•S 8 

P 


_0 

O 

0 

"O 








k. 


0 

0 

0 

0 

0 

0 


I*— 

»♦— 

Jt: 


ft 

L— 


c 

C 

C 

c 

c 

C 

3 

0 

0 

0 

0 

0 

0 

Q. 

g 

g 

g 

g 


g 


0 

0 

0 

0 

0 

0 

3 

•o 

■D 

■O 

“D 

■D 

■D 

O 

< 

< 

< 

< 

< 

< 






c 

C 





0 

0 





c 

C 





o 

o 





Q. 

Q. 





E 

E 





o 

o 



u. 


O 

O 

0 

0 

0 

0 

"D 

"O 


H— 



ik_ 


c 

c 

c 

c 

o 

o 

o 

0 

0 

0 

0 

0 

0 

g 

g 

g 


cr 

cn 

0 

0 

0 

0 

0 

0 

■D 

"D 

T 3 

■D 

TJ 

X} 

< 

< 

< 

< 

< 

< 


3 

a 

c 


c 

g 

E 

0 

O 

0 



C o 

0 S 
2 GC 


0 

0 

E 

0 

0 

0 - 


0 

0 

E 

E 

0 

CL 

O 

0 

0 

CO 


c 

o 


o to 


c 
E 

o 
O 

i s § 

I w ^ 


Q. 
O ^ 

H LU 


c 

g 

_0 

O 

0 

a 


c 

0 


0 

C 

o 


O 



0 



0 



0 


0 



0 



0 

k. 

E 

E 

c 

E 

_2 

c 

g 

E 

E 

c, 

E 

_3 

c 

g 

E 

E 

0 

0 


0 

0 


0 

0 

Q 

CL 

o 

.9 

**— 

CL 

w 

o 

g 

U— 

CL 

b 

o 

tl 

o 

o 

tl 

‘o 

o 

0 

0 

CL 

0 

0 

CO 

0 

0 

c 

0 

CL 

CO 

0 

0 

CO 

0 

0 

C 

0 

Q. 

CO 

0 

0 

CO 


o 

o 

(0 


in 

CO '1-^ CD 


00 


in h- 00 


00 00 00 


N 


CD 

00 


00 


00 

00 


C\i 

00 


00 


c 

o 


m 


o 

c 

3 

LL 


qI 


0 0 
•O *0 


< < 



Transform Chart 101 



CC 0 
in 


52 

□ 

Q. 

4-ii 

3 

O 



in 

in 

in 

in 

in 

in 

in 


in 

in 

in 

in 

in 

in 

in 

4 -f 

0 

0 

0 

0 

0 

0 

0 

3 

O 

O 

O 

O 

O 

o 

O 


0 

£ 

0 

0 

0 

0 

0 

3 

0 

*0 

0 

0 

0 

0 

0 

o 

Q 

Q 

Q 

Q 

o 

Q 

Q 


c 

*05 

E 

-D 

03 

S 03 O 

= rj “o 

0 0 0 
^ ^ JZ 

i i i 

0 0 0 
0 0 0 
_0 _0 _CC 

o o o 
0 0 0 
0 "cS 0 
Q Q Q 


c 

iS 

0 

0 8 


0 


C 

0 o 

0 ^ 
^ /A 


0 


0 M_ 

CL O 

C 0 

■g ^ 

o ^ 

~0 TO 

^ (5 

o Q 


0 0 0 

x: ^ ^ 

.1...^ 

fcf— M— 

o o o 

0 0 0 

in if) in 

0 0 0 

o o o 

0 0 0 

0 0 0 

Q Q Q 


0 

0 

0 


x: 

CL 


0 
0 

E ^ 

0 X 

Q. 0 


0 
0 

E_ 

0 CD C 

C 
0 


^ -i 
0 
o 
0 

0 


C 

0 

E 

o 

u 


a- 

£ € 

^ o 

JZt •” 

T3 T3 


O 
0 *0 
E ^ 
0 


0 

0 

"D 0 

x: ^ 

S >2 

C 


cc 


0 
0 
0 
XJ 
0 

0 ^ 
_ CL ^ 

^ ^ s 
>-5 

2 45 "co 
■O ^ T3 
0 ) -J 0 
0 Cf <^5 
w ^ 


X3 

0 E 
^ o 

O •D 

g. ® 
0 2 
0 0 
^ •- 


o < 
o ^ 
.2 O 

O 1 
0 


0 

0 

E 

0 


C 

0 

0 

C 

o 

o 

lo 

0 

L. 

0 

> 


0 0 
0 0 
E E 


0 


0 

c 

_ o 

0 O 

Q- 0 

C £ 

0 ‘tr 

^ ? 
o C 

*0 0 

0 E 

O 

Q 


c 

3 


c 
E 

2 o 

< £ 

O 

Q .E 
( 0 
O E 

Z O 

-- Q 


i_ £Z 0 

2 0 

^ ^ B 
E 0 ) ^ 

m 1— 


0 

CL 0 
0 0 ^ 
£ £ < 


o O 

.E Q 

0 I 

E O 
8 ^ 


0 
0 
E 

0 0 0 
IL. I... 
0 0 0 
Q. CL CL 
^ ^ 

2 2 2 
0 0 0 
o o o 
'u 7J T) 
E £ £ 
_l _l _l 

O O O 
CO CO c /3 
c c c 
0 0 0 

o o o 
0 0 0 
£ E E 
0 0 0 
z z z 


0 


c 

0 

C 

o 

CL 

E 

o 

O 

■o 

Ik. 

o 


0 

CL 

>* 

H 

0 


0 

0 

0 

o 

_c 

E 

c 

c 

"a 

CC 

Q 

Q 

*0 

*0 

*0 

*0 

0 

0 


1 

E 

E 

E 

E 

■D 

-o 

O 

O 

o 

o 

o 

o 

< 

< 

CO 

z 

Q 

Q 

Q 

Q 


B 

B 

0 




c 

c 

c 

0 

0 

0 

2 

2 

2 

_i 

— j 

«j 

O 

O 

O 

CO 

CO 

CO 


3 

a 

c 


.E 

*0 

E 

o 

_ Q 
2 0 
.ti 


0 

0 

E 

0 

i_ 

0 

0 - 


E £ 
0 *0 
E E 
o o 


c 

0 

V) 

c 

o 


□ CD Q Q O O CL 


c 

.2 

in 

in 

0 

v. 

CL 

X 

LJJ 

0 

2 

0 

> 


0 

in 

0 


ay 

c 

_0 

X3 

Q 


1— 

0 

CD 


0 

0 

E 




c 

o 

in 


1— 

2 

*0 



E 

0 

0 


0 

k_ 

0 

CL 



L- 

0 

in 

0 

Q. 

k— 

0 

E 

CD 

V_ 

0 

c. 

E 

D 

c 

o 

0 

D_ 

o 

c 

*0 

E 

*0 

c 

0 
<«— • 
in 

c 

E 

*0 

E 

LU 

0 

0 

E 

CL 

o 

O 

tz 

o 

‘o 

0 

E 

E 

c 

3 

CD 

k- 

_3 

0 

0 

0 

0 

0 

o 

o 

o 

O 

cn 

0 

0 

0 

0 

CL 

CO 

Q 

Q 

O 

O 

CL 

> 

CL 

CO 

C 

CO 



T- 

CO 




o 


iq 



cq 

CO 


T-. 


Q 






T- 

'T- 

C\J 

CD 



T— 

OJ 


T“ 


T“ 

c\i 

to 

T— 

CD 

N; 

00 

i6 





00 

00 

00 

K 

00 

CO 

1^ 

r^' 

N-’ 

1^ 

00 

c6 

cd 

00 

00 


OJ 

Z 

g 

O) 

oc 

LU 

> 



LU 


LU 



to 

CL 



■D 

> 


z 

< 

ay 

H 

I 

Z 

O) 

c 

c 

0 

-j 

CO 

< 

CQ 

CD 

CD 

O 

Q 

Q 

Q 

Q 


UJ 

< 

g 

Q 

z 


102 Database Programming Language - SAMeDL 






CO 

3 

Q. 

3 

O 


3 

a 

3 

O 


CM 

z 

o 

CO 

cr 

in 

> 


3 

Q. 

C 


o 

o 

(0 


c 

o 

"•g 

c 


c 

Q> 

1- E i- 

(U 0 0 
0) 0 Q 

E to E 
CO O CO 

D. CO Q. 


o 

CO 


o 0 g 
^ 0 ^ 
.E £ .£ 

_j CO _| 
o CO O 
CO Q. CO 
c o C 
< '*“ < 


0 

0 

E 

E 

0 


0 

0 

E 

E 

0 


0 0 
S E 

_i 2 « 

O to 
w <=^-J 

- I ^ 

0 g C 

1 - i 

2 _j _3 

5 O o 

Q-CO o 

o c o 


0 

0 

E 

0 


E 0 
£ 

I - 

0 Q) 

0 o 
^ E 

d - 

o ^ 
0) ^ 

« -o 
0 O 
Q S 


O § 


S 2 

« Jo 
o 
0 
■D 


0 

i_ 

=3 

u 

0 

o 

o 


c 

.9 

E 

_0 

O 

0 

-O 

E 

13 

•o 


0 

0 

E 

0 

0 

Q. 


C 

o 


c c 
o o 




73 13 E 
■C3 O 
« 8 


0 




^ $ 
■g 2 

< o 
0 0 
£ E 


(0 2 £5 
0 0 0 
O O O 
0 0 0 
"D -D T3 

0 0 0 
0 O O 

E E E_ 

CO CO 0 


£ £ 

0 0 
Q. Q. V- 

E E -E 
o o ^ 
O O c 
0)0)0 
ecu 


0 0 0 
Q. Q. Q. 

O O O 
(/)(/)(/) 


o o 


c 

< 


c c 
< < 


■O 

0 

« 

r) 


o 

CO 

0 

o 

S’ 

‘c 

Z) 


0 

. i 

I S 
0 0 
C cS 

E E 

O 0 
O Q- 

_l —I 

o o 

CO CO 


0 0 
0 0 
E E 
0 0 
i_ 1- r- 

0 0 O 

Q- CL 
-J -J ^ 
O O C 
CO CO 3 


o o 
0 0 
E E 
0 0 
C C 


C 

O 

'(/) 

0 

0 

0 0 
X) £ 


0 

0 

E 

E 

0 

CL 


O 

CO 


0 ^ 
^ O 


0 ^ 


CO 

0 

I 2 

O CD 


>s 

JD 


0 0 0 0 rx 

3 3 3 O O 

O’ g* gr g“ CO 

c c *c ‘c c 

Z) 3 3 3 < 


O O 
CO CO 
c c 
< < 



O) 

C 

$ 

■« 

.9 

o 

0 

</> 

u_ 

0 

0 

0 

0 

_3 

0 

E 

X 

o 

> 

0 


0 0 


0 0 


C 

o 


CL 

u- 

0. 

CL 

0 

o 


1_ 

0 



V. 

0 

k.. 

0 

0 

-j 

O’ 

I 

O" 

I 

Li. 


L_ 

L. 

L. 

o 

O 


O 

0 

_g 

o 
■«—» 

0 

g 

o 

0 

.9 

0 

0 

*o 

0 

E 

0 

C 

.9 

0 

c 

0 

E 

0 

0 

E 

0 

0 

E 

0 

i 

0 

i 

0 

0 

C 

0 

**— 

c 

0 

c 

0 

c 

0 

C 

2 

0 

0 

3 

O' 

'u 

c 

u 

c 

u 

c 

0 

Q 

o 

:e 

u. 

0 

CL 

E 

0 

0 

U 

0 

CL 

0 

CL 

0 

CL 

C 

I 

c 

I 

0 

U 

0 

3 

0 

3 

0 

3 

0 

0 

CO 

3 

CO 

-J 


_l 

_J 

0 

0 

O 

0 

_J 

_l 

_l 

_J 

-J 

-J 


-J 

_J 


_J 

_l 

O 

O 

O 

o 

■D 

■D 

0 

"D 

o 

o 

o 

O 

O 

O 

o 

O 

O 

O 

O 

O 

CO 

CO 

CO 

CO 

< 

< 

LJ 

< 

CO 

CO 

CO 

CO 

CO 

CO 

CO 

CO 

CO 

CO 

CO 

CO 


c 

o 

'« 

E 

Q. 

X V- 
LU o 
0 it: 

£ C 
0 0 

> £ 

£ CO 
O T3 
CO < 


0 

k_ 

0 


0 

■o 

< 


0 

0 

E 

0 


C 

E 

3 


0 

0 


0 


0 

0 

0 

CL 

o 

g 

c 

0 

0 

E 

O 

3 

'c5 

'0 

E 

E 

0 

0 

0 

0 

0 

« 

0 

CL 

E 

o 

E 

0 

0 

0 

CL 

CO 

c 

CO 

Q 

CL 

CL 


0 

</) 

3 

0 

o 

E 


0 

3 2 
0 U- 
O t 

o ^ - 
•§9 0 


0 

0 

E 

0 


E o 

- _ 3 

0 0 7S 0 

OCL S 

£ o tr *cj 

0^00 


0 

I 

_ .£ .® ? 
CO 0 S O 
^ F c CO 

CD c 


0 

E 

0 


0 

3 0 

I ^ 

E 0 

0 z 


c 

o 


■O 

c 

o 

O 


^W000 ^SO03CO0O03 

££a.co£^_iQ2ocLcoococo 


S ^ ^ O ^ X 
0 0- C 0 LU 

2 ts E ■§ g. ® 

2 ® = ro 3 

0 0 0 0 3 0 


0 

3 C 

0 .9 
O ^ 

0 E 
« o Q- 
3 2 X 
0 U- UJ 
O tr g 

£ CO 0 

£ £ CO 


CO 


CO 

00 1-^ CO 


CO 


CO 


C3) 


CO N 00 


CO Tf CO 1^ 00 T- 


OJ o 


1“ C3) 1- 


00 

aS 

00 

00 

CD 

00 

CD 00 00 

iri 

iri 00 00 

00 CD CD CD CD CD 





LU 








.J 

o 

CO 

O 

PS 



CL 

> 

*"1 

OC LU 

LU Q 

zi 

(0 

T3 

< 

tr 

5 

o 

cc 

cc 

_J 

O 

CO 

:e 

DC 

DC 
LU 
LL 
— J 
< 

LU 

< 

z 

1 

O O LU OC 

CO CO > LU 
-J .J _i n 

LU 

3 

2 



< 

< 

< 

3 

O 

O O O > 

< 





0- 

CL 

Q- 

o 

CO 

CO CO CO 1- 

> 


Transform Chart 103 




VERSION 2 


Annex E Glossary 

Abstract interface. A set of Ada package specifications containing the type and procedure declarations to 
be used by an Ada application program to access the database. 

Abstract module. A module that specifies the database routines needed by an Ada application. 

Assignment context. A value expression appears in an assignment context if the value of that value ex¬ 
pression is to be implicitly or explicitly assigned to an object. The assignment contexts are: select parame¬ 
ters, constant declarations, values in a VALUES list of an insert statement, set items in an update statement. 

Base domain. A template for defining domains. 

Conform. A value expression in an assignment context conforms to a target domain if the rules of SQL allow 
the assignment of a value of the data class of the expression to an object of the data class of the domain. 

Conversion method. A method of converting non-null data between objects of the not null-bearing type, 
the null-bearing type, and the database type associated with the domain. 

Correlation name. See ISO/IEC 9075:1992. 

Cursor, See ISO/IEC 9075:1992. 

Data class. The data class of a value is either character, integer, fixed, float, or enumeration. The data class 
of a domain determines which values may be converted, implicitly or explicitly, to the domain. 

Database type. The SQL data type to be used with an object of that domain when it appears in an SQL 
parameter declaration. This need not be the same as the type of the data as is stored in the database. 

Definitional module. A module that contains shared definitions: that is, declarations of base domains, do¬ 
mains, subdomains, constants, records, exceptions, enumerations, and status maps that are used by other 
modules. 

Domain. The set of values and applicable operations for objects associated with a domain. A domain is sim¬ 
ilar to an Ada type. 

Exposed. The exposed name of a module (table or view) that appears in a context clause (table ref) con¬ 
taining an as phrase (correlation name) is the identifier in the associated as phrase (correlation name); the 
module name (table name) is hidden. If the as phrase (correlation name) is not present, the exposed name 
is that module’s (table’s or view’s) name. The exposed name of a table or module is the name by which that 
table or module is referenced. 

Extended. A table, view, module, procedure, cursor, or cursor procedure that includes some nonstandard 
operation or feature. 


104 Database Programming Language - SAMeDL 



VERSION 2 


Hidden. See exposed. 

Module. A definitional module, a schema module, or an abstract module. 

Not null type. The Ada type associated with objects of a domain that may not take a null value. 

Null type. The Ada type associated with objects of a domain that may take a null value. 

Null value. SQL’s means of recording missing information. A null value in a column indicates that nothing 
is known about the value that should occupy the column. 

Options. The aspects of the base domain that are essential to the declaration of domains based upon the 
base domain. In particular they define the base domain’s null- and not null-bearing type name, data class, 
database type, and conversion methods. 

Patterns. A template used to create the Ada constructs that implement the Ada semantics of a domain, sub- 
domain, or derived domain declaration. 

Row record. The Ada record associated with procedures that contain either a fetch, select, insert state¬ 
ment. It is used to transmit the database data to or from the client program. 

Row record type. The Ada type of the row record. 

SAME. SQL Ada Module Extensions. 

SAMeDL. SQL Ada Module Description Language. 

Schema module. A module containing definitions of database tables and views. 

SQL. Formerly an acronym for Structured Query Language, SQL is the name of the relational database lan¬ 
guage defined in ISO/IEC 9075:1992. 

SQLCODE. See ISO/IEC 9075:1992. 

Standard Map. The Standard Map is a status map defined in SAMeDL_Standard that has the form “status 
Standard_Map as is_found uses boolean is (0 => true, 100 => false);". Standard_Map is the status map for 
fetch statements that appear in cursor declarations by default. 

Standard post processing. The processing that occurs after the execution of an SQL procedure but before 
control is returned to the calling application. 

Static expression. A value expression that can be evaluated at compile time (i.e., all the associated leaves 
consist solely of literals, constants, or domain parameter references). 


Glossary 105 



VERSION 2 


Status map. A partial function that associates an enumeration literal or a raise statement with each speci¬ 
fied list or range of SQLCODE values. Status maps are used within the abstract module to uniformly process 
the status data for all procedures. 

Target domain. The domain of the object to which an assignment is being made in an assignment context. 

Universal constant. A constant whose declaration does not contain a domain reference. 

Value expression. A value expression differs from an SQL value expression in that (1) an operand may be 
a reference to a constant or a domain parameter, and (2) SAMeDL value expressions are strongly typed. 


106 Database Programming Language - SAMeDL 



VERSION 2 


Index 


Abstract Module 11, 12, 15, 16, 32, 36, 37, 38, 39, 
45, 53 

abstract module 63 
Actual Identifier 10 
Ada Exception 18, 32 
Ada Identifier 2, 9 

AdalD 9,10, 22, 28, 29, 31,38, 39, 52, 54, 55, 57 
AdaNAME 29, 39, 40, 45,46, 49, 52, 53, 54, 55, 57, 
59, 60 

AdaTYPE 28, 39, 40, 45, 46, 49, 52, 53, 55 
As Phrase 2,12 
Atomic Predicate 19 
Authorization Clause 15 

Bas Dorn Ref 24 

Base Domain 12,19, 20, 21,22, 23, 24, 26, 36, 37 

Base Domain Body Declaration 19 

Base Domain Declaration 19, 20, 25 

Base Domain Name 20 

Base Domain Parameter 20, 24, 25 

Base Domain Reference 13, 24, 26 

Bit 10, 20, 21,28 

Bit Literal 10 

Character 10, 20, 21,28 
Character Literal 10, 21,22, 31 
Close Statement 48, 50 
Column Definition 19, 34 
Column Name 13, 55 
Column Reference 14, 61 
Comment 11 

COMPAda 37,40, 41, 46, 51 
Compilation Unit 11 
Component 29 
Component Declaration 29 
Component Declarations 29 
Component Name 29, 53 
Conform 28, 43, 44, 55 
Constant Declaration 19, 27, 28 
Constant Reference 13,28, 41,56, 61 
Context 12, 19, 33, 37 
Context Clause 11,12,13,15 
Conversion Method 23, 36 
Converter 22 
Correlation Name 53 
Cursor 12, 15, 38, 42, 44, 45, 46, 49, 50 
Cursor Declaration 13, 33, 38, 44, 45, 46, 49, 50, 
51, 54 

Cursor Delete Statement 48, 50 


Cursor Name 14,18 

cursor name 48 

Cursor Proc Reference 13 

Cursor Procedure 14, 15, 38, 48, 49 

Cursor Procedures 44, 45, 46, 48,49, 50 

Cursor Reference 13 

Cursor Statement 48, 49 

Cursor Update Statement 48,49, 50 

Data Class 10, 20, 21,22, 23, 24, 25 
Database Literal 10, 24, 25, 28, 61 
Database Mapping 21,23, 24, 25 
DATACLASS 10, 25, 28, 34, 59, 60 
Date 10, 20 
Date Literal 10 
Datetime 10 

DBLengAda 37,40,41,46, 51 
Dblength 29, 30, 40, 45, 53, 54 
DBLngNAME 45, 53, 54 
Dbms 22 

Dbms Type 22, 23 
DBMS_TYPE 24, 35 
Default Mapping 21 
Defining Location 13 
Definition 19, 20 

Definitional Module 11, 12,15,19, 20, 26 
Delete Statement 13 
Delimited Identifier 10 
Derived Domain Pattern 21 
Dorn Ref 24 

DOMAIN 15, 28, 34, 44, 45, 53, 55, 56, 59 
Domain Conversion 61 
Domain Declaration 19, 21,22, 24, 25, 26 
Domain Parameter Reference 13, 28, 61 
Domain Pattern 21 

Domain Reference 2,13, 24, 27, 28, 29, 51, 52, 59 

Enumeration 10, 20, 21,24, 25, 28, 30, 62 
Association 24, 25, 26 
Association List 24, 25 
Declaration 19, 30 

Literal 10,13,18,21,25,28, 30, 31,32, 36, 37, 
56, 61 

Literal List 30, 31 
Literal Reference 13 
Reference 13, 21,24, 25, 32 
Enumeration Declaration 30 
Enumeration literal 30 
Enumeration literal list 30 
Exception 13,18,19, 31 
Exception Declaration 19, 31 
Exception Reference 13 
Exposed 12,15 


107 


VERSION 2 


Extended 18, 23, 33, 34, 37, 38, 39, 44, 45, 48, 49, 
52, 64 

Extended Cursor Statement 18, 48, 49 
Extended Query Expression 18, 44, 45 
Extended Query Specification 18 
Extended Schema Element 18, 34 
Extended Statement 18, 39, 40, 41, 51 
Extended Table Element 18,19 

Fetch Statement 33, 48, 49, 50, 51, 53, 54, 57 

Fixed 10, 20 

Fixed Literal 10 

Float 10, 20 

Float Literal 10 

From Clause 13, 53, 57 

Function 22 

Fundamental 22 

Hidden 12,16 

Identifier 2,10,13,19,20,24,27,29,30, 31,32,33, 
37, 38, 39, 44, 46, 48, 51,57 
Image 20, 21, 24, 26 

Indicator Parameter 36, 46, 51,52, 54, 56, 61 
indicator parameter 37 
INDICNAME 46, 52, 54, 56, 61 
INDICSQL 41,46, 51, 52, 54, 56, 61 
Input Parameter 2,13,15,16 
Input Parameter Declaration 2 
Input Parameter List 19, 39, 41,44, 46, 48, 49, 50, 
51 

Input Reference 13 

Insert Column List 40, 41,43, 44, 55, 56 

Insert Column Specification 55 

Insert From Clause 40, 43, 57 

Insert Statement 13, 43 

Insert Statement Row 40, 41,43, 44, 55, 57 

Insert Value 55 

Insert Value List 40, 41,43, 44, 55, 56 

Integer 10, 20 

Integer Literal 10 

INTER_TYPE 24, 46, 52, 54 

Interface Type 22, 23 

Interval 10, 20 

Interval Qualifier 24 

Into Clause 19, 39, 43, 44, 49, 57 

Item 3,12,13,15,16 

Left Hand Side 17, 32 
LENGTH 21,24, 25 
Enumeration 28 

Literal 10, 23, 27, 40, 41,55, 56, 60 


Map 20,21,23, 24, 25 

Mode 19, 39, 40, 49, 50 

Module 11, 12, 13, 16, 18, 28, 29, 31,36, 45 

Module Name 12, 13, 14, 15, 18 

Module Reference 12, 13 

Named Phrase 29, 32, 51, 53, 55, 56, 62 
NO_DOMAIN 25, 53 

Not Null 2, 22, 23, 24, 26, 28, 29, 30, 36, 37, 45, 51, 
52, 53, 54, 55, 56, 61 

Not Null Only 26, 30, 44, 45, 52, 53, 55, 56 
Null 4, 22, 23, 30, 36, 37, 44, 52, 53, 55, 56 
Null Value Error Exception 37, 65 
Numeric Literal 10 

Open Statement 48, 49, 50 
Options 22, 23, 24 

Parameter 15, 22, 23, 51,52 

Parameter Association 23, 24, 25 

Parameter Association List 20, 24 

Parameter Declaration 20 

Parameter Name 20 

Parent 24, 25 

PARMAda 39, 41,49, 51 

PARMRow 40, 49, 57 

PARMSQL 41,46, 51, 52, 54, 56, 61 

Pattern 21,22, 23, 26 

Pattern Element 21 

Pattern List 21 

Patterns 21 

Poor Programming Practice 43, 53 
Pos 21,24, 25 
Procedure 22 

Procedure Declaration 38, 39,40,41,45,49, 50,53 
Procedure Name 18 
Procedure Or Cursor 13, 38 
Procedure Reference 13 

Qualifier 21,25 
Query 44, 45 
Query Specification 53 

Raise 18, 32 

Record Declaration 19, 29 

Record Id 57 

Record Reference 13, 57 

Reference 14,16 

Reference Location 13, 14, 15 

Row Record 39, 40, 41, 49, 51, 55, 57, 59 


108 Database Programming Language - SAMeDL 



VERSION 2 


SCALE 21,24, 25, 59 
Schema 11,12,13, 15,16 
Schema Element 33 
Schema Module 11,12, 33, 34 
Schema Name 12,13, 53 
Schema Reference 13 
Scope 12, 15,16 

Select List 40, 41, 44, 46, 50, 53, 54 
Select Parameter 53 
select parameter 37 

Select Statement 39, 40, 41,43, 44, 54, 57 

Set Item 44, 49, 50 

SQL Bit String Literal 10 

SQL Close Statement 50 

SQL Data Type 56 

SQL Database Error Exception 18, 65 
SQL Delete Statement 50 
SQL Fetch Statement 50 
SQL Fetch Target List 54 
SQL hex string literal 10 
SQL Identifier 2,13, 56 
SQL Insert Column List 56 
SQL Insert Statement 44 
SQL Insert Value List 56 
SQL interval literal 10 
SQL Select List 44, 46, 54 
SQL Select Statement 
Single Row 44 
SQL Select Target List 54 
SQL Status Parameter 17,18, 32, 41,51 
SQL Target Specification 46, 54 
SQL Update Statement Positioned 50 
SQL Value Expression 61 
SQL_Standard 29 
SQLCODE 18, 32, 35, 41, 50 
SQLnamE 10 

SQLNAME 46. 50, 52, 54, 56, 61 
SQLSC 35, 41, 44, 47, 62 
SQLSTATE 17, 32, 35, 41,50 
SQLVE 35, 37, 41,44, 50, 56, 59, 61,62 
Standard Map 33, 48 

Standard Post Processing 17,18, 32, 41, 51 
Standard_Map 33 
Statement 36, 39, 40 

Static Expression 20, 24, 25, 27, 28, 32, 37 
Status Assignment 17,18, 32, 33 
Status Clause 17,18,34,35, 39,40,41,48, 50,62, 
63 

Status Map 12,17, 18, 19, 32, 33, 62, 63 
Status map 30 

Status Map Declaration 19, 32 
Status Parameter 18, 40, 50 


Status Reference 13, 62 
Subdomain Declaration 19, 24, 25, 26 
Subdomain Pattern 21 
Subdomain Reference 13,24 
Subquery 43, 45 

Table Element 19 
Table Name 13,18, 43, 53 
Table Reference 13,14 
Target Enumeration 32 
Target enumeration 32 
Temporal 28 
Time 10, 20 
Time Literal 10 
Timestamp 10, 20 
Timestamp Literal 10 
Type 22 
Type Mark 22 
TYPERow 40, 49, 57 

Universal 28 

Update Statement 13, 39, 44, 49 
Use Clause 12,16 

VALUE 28 

Value Expression 27, 44, 53, 59, 61 
View Name 18 
Visible 16 

With Clause 12,15 

With Schema Clause 12,15,19 

Word List 22 



VERSION 2 


110 Database Programming Language - SAMeDL 



UNLIMITED, UNCLASSIFIED 
SECURITY CLASSinCATION OF THIS PAGE 


la. REPORT SECURITY CLASSIFICATION 

Unclassified 


REPORT DOCUMENTATION PAGE 


lb. RESTRICTIVE MARKINGS 

None 


2a. SECURITY CLASSIFICATION AUTHORITY 

N/A 

2b. DECLASSIHCATION/DOWNGRADING SCHEDULE 

N/A 


4. PERFORMING ORGANIZATION REPORT NUMBER(S) 

CMU/SEI-95-SR-018 


3. DISTRIBUTION/AVAILABILITY OF REPORT 

Approved for Public Release 
Distribution Unlimited 


5. MONITORING ORGANIZATION REPORT NUMBER(S) 


6a. NAME OF PERFORMING ORGANIZATION 

Software Engineering Institute 


6b. OFFICE SYMBOL 7a. NAME OF MONITORING ORGANIZATION 

(ifapplicable) g^l Program Office 

SEI 


6c. ADDRESS (city, state, and zip code) 

Carnegie Mellon University 
Pittsburgh PA 15213 


7b. ADDRESS (city, state, and zip code) 

HQ ESC/ENS 
5 Eglin Street 

Hanscom AFB, MA 01731-2116 


8a. NAME OFFUNDING/SPONSORING 
ORGANIZATION 

SEI Joint Program Office 


8b. OFFICE SYMBOL 9. PROCUREMENT INSTRUMENT IDENTIFICATION NUMBER 


(if applicable) 

ESC/ENS 


F19628-95-C-0003 


8c. ADDRESS (city, state, and zip code)) 

10. SOURCE OF FUNDING NOS. 

Carnegie Mellon University 

Pittsburgh PA 15213 

PROGRAM 
ELEMENT NO 

63756E 

PROJECT 

NO. 

N/A 

TASK 

NO 

N/A 

WORK UNIT 

NO. 

N/A 


11. TITLE (Include Security Classification) 

Information Technology - Programming Language - The SQL Ada Module Description Language (SAMeDL) 


12. PERSONAL AUTHOR(S) 

Marc Graham 


13a. TYPE OF REPORT 

Final 


13b. TIME COVERED 


14. DATE OF REPORT (year, month, day) 

October 


15. PAGE COUNT 

110 



17. COSATI CODES 



18. SUBJECT TERMS (continue on reverse of necessary and identify by block number) 

Ada, ISO, SQL 


19. ABSTRACT (continue on reverse if necessary and identify by block number) 






(please turn over) 

20. DISTRIBUTION/AVAILABILITY OF ABSTRACT 
UNCLASSIFIED/UNLIMITED | SAME AS RPT[] 

DTIC USERS 1 

21. ABSTRACT SECURITY CLASSIRCATION 

Unclassified, Unlimited Distribution 

22a. NAME OF RESPONSIBLE INDIVIDUAL 

Thomas R. Miller, Lt Col, USAF 

22b. TELEPHONE NUMBER (include area code) 

(412) 268-7631 

22c. OFFICE SYMBOL 

ESC/ENS (SEI) 


DD FORM 1473, 83 APR 


EDITION of 1 JAN 73 IS OBSOLETE 


UNLIMITED, UNCLASSIRED 

SECURITY CI.ASSIFfC.ATTON OF THIS PAGE 
































