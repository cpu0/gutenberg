
NAVAL 

POSTGRADUATE 

SCHOOL 

MONTEREY, CALIEORNIA 


THESIS 


EFFECTIVE USE OF JAVA DATA OBJECTS IN 
DEVELOPING DATABASE APPLICATIONS. 
ADVANTAGES AND DISADVANTAGES 

Paschalis Zilidis 

June 2004 


Thesis Advisor: Thomas Otani 

Seeond Reader: ArijitDas 


Approved for public release; distribution is unlimited 




THIS PAGE INTENTIONALLY LEET BLANK 



REPORT DOCUMENTATION PAGE 


Form Approved OMB No. 0704-0188 
Public reporting burden for this collection of information is estimated to average 1 hour per response, including 
the time for reviewing instruction, searching existing data sources, gathering and maintaining the data needed, and 
completing and reviewing the collection of information. Send comments regarding this burden estimate or any 
other aspect of this collection of information, including suggestions for reducing this burden, to Washington 
headquarters Services, Directorate for Information Operations and Reports, 1215 Jefferson Davis Highway, Suite 
1204, Arlington, VA 22202-4302, and to the Office of Management and Budget, Paperwork Reduction Project 
(0704-0188) Washington DC 20503. __ 

I. AGENCY USE ONLY (Leave blank) 2. REPORT DATE 3. REPORT TYPE AND DATES COVERED 

June 2004 Master’s Thesis 

4. TITLE AND SUBTITLE: Effective Use of Java Data Objects in Developing 5. LENDING NUMBERS 
Database Applications. Advantages and Disadvantages _ 

6. AUTHOR(S) Paschalis ZILIDIS _ 

7. PEREORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 8. PERFORMING 

Naval Postgraduate School ORGANIZATION REPORT 

Monterey, CA 93943-5000 _ NUMBER _ 

9. SPONSORING /MONITORING AGENCY NAME(S) AND ADDRESS(ES) 10. SPONSORING/MONITORING 
N/A AGENCY REPORT NUMBER 

II. SUPPLEMENTARY NOTES The views expressed in this thesis are those of the author and do not reflect the official 

policy or position of the Department of Defense or the U.S. Government. _ 

12a. DISTRIBUTION / AVAII.ABII JTY STATEMENT 12b. DISTRIBUTION CODE 

Approved for public release; distribution is unlimited 

13. ABSTRACT (maximum 200 words) 

Currently, the most common approach in developing database applications is to use an object-oriented 
language for the frontend module and a relational database for the backend datastore. The major disadvantage of 
this approach is the well-known “impedance mismatch” in which some form of mapping is required to connect the 
objects in the frontend and the relational tuples in the backend. 

Java Data Objects (JDO) technology is recently proposed Java API that eliminates the impedance 
mismatch. By using JDO API, the programmers deal strictly with objects. JDO hides the details of the backend 
datastore by providing the object-oriented view of the datastore. JDO automatically handles the mapping between 
the objects and the underlying data in the relational database, which is hidden from the programmer. 

This thesis investigates the effectiveness of JDO. Part of the analysis will develop a database application 
using JDO. Although JDO provides the benefits of object-orientation in design and implementation of the 
databases, it is not immune from problems and limitations. The thesis will also analyze the advantages and 
disadvantages of using JDO and discuss the areas requiring improvements in future releases. 

14. SUBJECT TERMS Datastore, Java Data Objects, JDO, API, Java 15. NUMBER OF 

PAGES 

_285_ 

16. PRICE CODE 

17. SECURITY 18. SECURITY 19. SECURITY 20. LIMITATION 

CLASSIFICATION OF CLASSIFICATION OF THIS CLASSIFICATION OF OF ABSTRACT 

REPORT PAGE ABSTRACT 

Unclassified Unclassified Unclassified UL 

NSN 7540-01-280-5500 Standard Form 298 (Rev. 2-89) 

Prescribed by ANSI Std. 239-18 


1 




























THIS PAGE INTENTIONALLY LEET BLANK 


11 



Approved for public release; distribution is unlimited 


EFFECTIVE USE OF JAVA DATA OBJECTS IN DEVELOPING DATABASE 
APPLICATIONS. ADVANTAGES AND DISADVANTAGES 


Paschalis Zilidis 
Major, Hellenic Air Force 
B.S., Hellenic Air Force Academy, 1988 


Submitted in partial fulfillment of the 
requirements for the degree of 


MASTER OF SCIENCE IN COMPUTER SCIENCE 


from the 


NAVAL POSTGRADUATE SCHOOL 
June 2004 


Author: Paschalis Zilidis 


Approved by: Thomas Otani 

Thesis Advisor 


Arijit Das 
Second Reader 


Peter Denning 

Chairman, Department of Computer Science 



THIS PAGE INTENTIONALLY LEET BLANK 


IV 



ABSTRACT 


Currently, the most common approach in developing database applications is to 
use an object-oriented language for the frontend module and a relational database for the 
backend datastore. The major disadvantage of this approach is the well-known 
“impedance mismatch” in which some form of mapping is required to connect the objects 
in the frontend and the relational tuples in the backend. 

Java Data Objects (JDO) technology is recently proposed Java API that eliminates 
the impedance mismatch. By using JDO API, the programmers deal strictly with objects. 
JDO hides the details of the backend datastore by providing the object-oriented view of 
the datastore. JDO automatically handles the mapping between the objects and the 
underlying data in the relational database, which is hidden from the programmer. 

This thesis investigates the effectiveness of JDO. Part of the analysis will develop 
a database application using JDO. Although JDO provides the benefits of object- 
orientation in design and implementation of the databases, it is not immune from 
problems and limitations. The thesis will also analyze the advantages and disadvantages 
of using JDO and discuss the areas requiring improvements in future releases. 


V 



THIS PAGE INTENTIONALLY LEET BLANK 


VI 



TABLE OF CONTENTS 


1. INTRODUCTION.1 

IL DEVELOPMENT TOOLS AND TECHNIQUES.5 

A. LIDO.5 

B. MYSQL.7 

C. JDBC CONNECTOR.8 

D. THE JFREECHART.8 

E. THE PROPERTIES FILE.9 

III. PROJECT DESCRIPTION.11 

A. THE TRAINING-SQUADRON APPLICATION.11 

B. UML.12 

C. THE INTERFACE MYINTERFACE.13 

1. The Method: getFieldLengthsQ.13 

2. The Method: getFieldByName ().14 

3. The Method: getField.15 

4. The Method: setFieldByName ().15 

5. The Method: setFieldValue ().16 

6. The Method: getTheTypeOfTheCollection ().18 

D. THE FORM InstructorsForm.20 

1. The JDOImplHelper.20 

2. Collection Fields.23 

E. GETTING THE VALUES OF THE RECORD.24 

F. SETTING VALUES TO THE RECORD.26 

1. Creating Suhforms.27 

IV. JDO DISADVANTAGES.29 

A. MANY TO MANY RELATIONSHIPS.29 

1. The Redundancy of Tables.29 

2, Inverse Relationship.31 

B. FIELD REDUNDANCY.35 

C. JDO GROUP BY QUERIES.40 

1. Performance Imitating a GROUP BY Query.40 

2, Performance for Simple SELECT Queries.42 

D. NO SUPPORT OF ALL THE DATA STRUCTURE TYPES.49 

E. NO FREE SOURCE CODE.52 

F. WHY XML?.52 

G. METADATA DEFICIENCY.54 

V. JDO ADVANTAGES.57 

A, OBJECT ORIENTED VIEW OF THE DATABASE.57 

B, AUTOMATE PERSISTENT.60 

C, EASE OF IMPLEMENTATION.61 

vii 










































D, JDOQL.64 

VI. CONCLUSION.69 

A, ADVANTAGES.69 

B, DISADVANTAGES.70 

APPENDIX. SOURCE CODE.75 

A. PACKAGE COMPANY.75 

1. The Class: Aircraftjava.75 

2. The Class : AircraftType.java.78 

3. The Class: BaseCategory.java.79 

4. The Class: BaseStadio.java.82 

5. The Class: Categories.java.85 

6. The Class: Exercise.]ava.90 

7. The Class: Flights.]ava.94 

8. The Class: GroundCourse.java.99 

9. The Class: Instructors.java.103 

10. The Interface: Myinterface.java.110 

11. The Class: Rank.java.Ill 

12. The Class: Schedule.java.114 

13. The Class: Series.java.118 

14. The Class: SpecialType.java.123 

15. The Class: Squadron.]ava.126 

16. The Class: Stadio.java.130 

17. The Class: Students.]ava.135 

B. PACKAGE TEST.142 

1. The Class: InstructorsForm.java.142 

2. The Class: MyBarChart.java.189 

3. The Class: Populate.java.195 

4. The Class: PureSQL.java.198 

5. The Class: QueryForm.java.201 

6. The Class: ReportsForm.java.215 

7. The Class: SquadronsForm.java.243 

C. METADATA JDO FILE.264 

LIST OF REFERENCES.267 

INITIAL DISTRIBUTION LIST.269 


viii 





































LIST OF FIGURES 


Figure 1. The Properties File for the Training-Squadron Applieation.9 

Figure 2. UML for the Training-Squadron Applieation.12 

Figure 3. JDO Performanee Imitating a GROUP BY Query.40 

Figure 4. JDO Performance Imitating a GROUP BY Query (Second Execution).41 

Figure 5. LIDO Message for ‘sql’ tag.42 

Figure 6. JDO Performance Using ‘sql’ Tag and retrieveAll() Operation.43 

Figure 7. JDO Performance Using ‘sql’ Tag without retrieveAll() Operation.44 

Figure 8. JDO Performance Using ‘sql’ Tag without retrieveAll() but with Iteration 

through the Result Set.44 

Figure 9. JDO Performance without ‘sql’ Tag with retrieveAll() Operation and with 

Iteration through the Result Set.45 

Figure 10. JDO Performance without ‘sql’ Tag with retrieveAll() Operation but 

without Iteration through the Result Set.46 

Figure 11. JDO Performance with ‘sql’ Tag with retrieveAll() operation but without 

Iteration through the Result Set.46 

Figure 12. JDO Performance without retrieveAll(), and with Iteration.47 

Figure 13. JDO Performance without retrieveAll(), and without Iteration.48 

Figure 14. JDO Performance without retrieveAll(), and without Iteration Using ‘sql’ 

Tag.48 

















THIS PAGE INTENTIONALLY LEET BLANK 


X 



LIST OF TABLES 


Table 1. Features of FIDO’s Community Edition, 


6 


XI 




THIS PAGE INTENTIONALLY LEET BLANK 



ACKNOWLEDGMENTS 


This thesis is dedicated to my loving family, my beloved and wonderful wife, 
Petroula, for her unconditional support and patience during my studies, and my 
wonderful and lovely daughter Despoina whose birth nine months ago I was not able to 
attend since I was here at the Naval Postgraduate School. 

I would like to also thank my thesis advisor Thomas Otani for his outstanding 
help support and guidance for the implementation of the thesis, and Arijit Das for his 
insightful commitment to this work. In addition, I would like to thank Nancy Sharrock for 
her valuable help in editing and formatting this thesis. 

Finally I would like to thank my father Christos and my mother Despoina, who in 
sacrificing much of their personal life in trying to provide me everything that I needed 
and taught me through their valuable experiences and undisputable values about life. 



THIS PAGE INTENTIONALLY LEET BLANK 


XIV 



I. INTRODUCTION 


The Java Data Objects (JDO) API is a standard interface-based Java model 
abstraction of persistence. It was developed in 2000 as Java Specification Request 12 
under the auspices of the Java Community Process . 

The specification, reference implementation, and technology compatibility kit 
were approved by the Java Community Process (JCP) in March 2002 and published in 
April 2002. Alternatives to JDO include direct file I/O, serialization, JDBC, and 
Enterprise Java Beans (EJB) Bean Managed Persistence (BMP) or Container Managed 
Persistence (CMP) Entity Beans. Even though the program was not indented to replace 
the previous solutions as the JDO API, the product appeared to be very promising that 
resulted in providing valuable solutions to the programmer and the implementation of the 
program. 

According to the specifications, the programmer can write code in the Java 
programming language that transparently accesses the underlying data store, without 
using database-specific code. Thus, the Application programmers can use JDO to store 
their Java object instances directly into the persistent datastore (database). 

JDO provides the following benefits: 

• Portability: Applications written with the JDO API can be run on multiple 
implementations without recompiling or changing source code. 

• Database independence: Applications written with the JDO API are 
independent of the underlying database. 

• Ease of use: Application programmers can focus on their domain object 
model and leave the details of persistence (field-by-field storage of 
objects) to the JDO implementation. 

• High performance: Application programmers delegate the details of 
persistence to the JDO implementation, which can optimize data access 
patterns for optimal performance. 

• Integration with EJB: Applications can take advantage of EJB features 
such as remote message processing, automatic distributed transaction 
coordination, and security, using the same domain object models 
throughout the enterprise.”! 

1 See http://iava.sun.com/products/ido/overview.html. accessed March 2004. 


1 



The thesis explores JDO eapabilities and deficiencies and evaluates JDO 
performance against traditional ways of accessing and creating a database. 

As part of the study, the thesis develops an application which involves the 
creation of a database, and a suitable GUI for accessing and navigating the data along 
with the creation of queries. The entire application will be constructed using only JDO 
interfaces and pure Java classes. No direct interaction with DBMS is made. 

Finally, in an effort to asses the performance of JDO queries, the thesis involves 
the creation of pure SQL commands to retrieve the same set of data and analyze their 
retrieval performance. 

The organization of the thesis follows. 

Chapter I is the introduction which presents the JDO specifications and the 
purpose of the thesis. Chapter II includes the presentation and the installation of the 
development tools to use for the implementation of the application. 

Chapter III introduces the specification of the database application- form currently 
on the Training Squadron application, with a short description of the tables and the java 
classes that represent these tables. The Training-Squadron application created is used to 
automate the data of flights and the training program of student pilots in a Training 
Squadron. Thus, this chapter describes the relationship found in this specific application. 
There is also a description of a model that can be created to achieve access to different 
java classes, which represent entities of the model for this thesis and the queries used to 
handle the data retrieval. 

Chapter IV discusses the weakness of JDO. Thus, this chapter provides detailed 
disadvantages about using JDO in creating database applications. The chapter uses the 
data from the previous chapter and identifies when the implementation was difficult or 
cumbersome. 

Chapter V presents the advantages of JDO. In contrast to the previous chapter, it 
will present the strengths of JDO and the advantages of using it in creating a database 
application. Specifically, the chapter uses the experience obtained in using JDO when 
developing the case study application to formulate the general discussion. In addition. 


2 



contrary to the previous ehapter, there is a description of the good points encountered 
during the implementation of the application and assesses how they facilitate the 
implementation of an applieation. 

The final chapter is the conclusion providing the overall evaluation of JDO and 
some assessment for its future. 


3 



THIS PAGE INTENTIONALLY LEET BLANK 


4 



II. DEVELOPMENT TOOLS AND TECHNIQUES 


A. LIDO 

JDO is a specification from Sun Microsystems that helps Java programmers to 
persist objects. In other words, to read objects from or write objects to a data source. JDO 
greatly simplifies persistence compared to other solutions such as JDBC, JCA or EJBs. 

The Java Specification Request that lead to the creation of JDO can be found at: 
http ://www. i cp. or g/j sr/detail/12. j sp . 

LiDO is a JDO implementation that support different types of data sources 
including many relational databases. Libelis created LIDO. It is also an implementation 
of the official JDO 1.0 specification. 

The project uses LIDO version 1.4.0. JDO provides the basic APIs for managing 
persistent java objects in a transactional manner. LiDO uses the functionality of JDO 
APIs. There are currently three editions of LiDO: 

• Community Edition 

• Standard Edition 

• Professional Edition 

The LiDO Community Edition is free of charge. However, it requires a license 
that must be obtained from Libelis. The thesis application uses the Community Edition, 
and available for downloading from http://www.libelis.com/ . 

The features of LiDO’s community edition appear in the next table: 


5 



Table 1. Features of FIDO’s Community Edition. 



Community 

Edition 

Open Source RDBMS 

Yes 

Mapping of existing database model 
(Application Identity) 

Yes 

Connection pooling of client/server connections 
(at least 2 connections) 

Yes 

LIBeEIS FileDB (File system database) 

No 

Commercial RDBMS 

No 

Versant ODBMS 

No 

JCA Compliance for J2EE integration 

No 

JSP tag library 

No 

GUI mapping tool (LiDO Project Manager) 

No 

NAViLIS (e-Business Browser) 

No 


In order to use LiDO effectively, the following are also required; 

• Java SDK 1.2.x or higher http://iava.sun.com/i2se/ 

• If Java SDK is version 1.2: JCE http://iava.sun.com/products/ice/ 

The following are used for the development of a database; 

• RDBMS: The database and JDBC drivers 

• ODBMS: Versant JVI 2.4.x or enJin 2.x 

• LIBeEIS FileDB; a standard or professional LiDO license 

RDBMS, and specifically, MySQE is used for the development of the application 
of this thesis. 

The installation file, called EiDO_<Edition>_x.y.z.jar, is used to install EiDO 
where the <Edition> is either “Community”, “Standard or “Professionaf’ and “x.y.z” is 
the release number. The installation file is an “executable jar”. 2 

The following script sets the EiDO environment: 

• <EIDO_FIOME>/bin/lidoEnv.bat (Windows) 


2 For information about FIDO’s installation, see the LIDO user’s manual. 


6 

















This script adds or modifies the following environment variables: 

• LIDO_HOME: set to the root installation directory of LiDO 

• PATH: <LIDO_HOME>/bin is pretended. 

• CLASSPATH: <LIDO_HOME>/bin is pretended and all jar files in 
<EIDO_HOME>/lib are appended. 

EiDO currently supports a wide area of RDBMS. As states previously, the thesis 
uses MySQE, which the Community edition supports. Even though LiDO relational uses 
JDBC, each RDBMS requires a custom dictionary to support it since implementation 
details are abstracted by JDBC. The dictionary tells LiDO how to interact with a given 
database. 

The file <LIDO_HOME>/bin/dictionary.properties maps JDBC driver names to 
database engines. When creating a schema or opening a connection with 
PersistenceManagerEactory, this file is read to discover which database engine to use.3 


The <LIDO_HOME>/bin/dictionary.properties file must be in the Java CLASSPATH. 
This can be done by running the <LIDO_HOME>/bin/lidoEnv.bat script. 

Before using a JDBC driver, verify that it is in 

<LIDO_HOME>/bin/dictionary .properties. If not present, it must be added by associating 
it with the appropriate dictionary. 

B. MYSQL 

MySQL edition 4.0 is used for the development of the Training-Squadron 
application possessing the following specifications 


Windows 95/98/NT/2000/XP/2003 (x86) 4.0.18 23.IM 


It is available for download from http://www.mvsql.com/downloads/mvsql- 
4.0.html, and is installed in c:\mysql. 


The mysql program is used for the creation of the database as follows: 


3 For database support, see the LiDO user’s manual 


7 








c:\ mysql\bin> mysql 

mysql> create database <database_name> 

For example, 

mysql> create database pilotdb 

Pilotdb will be tbe name of tbe database for bolding tbe data of our 
Training-Squadron application 

Additionally, it is necessary to change the javax.jdo.option.connectionURL 
property as follows: 

javax,jdo,option.connectionURL=jdbc:mysql://localhost/pilotdb 

Thus, it is now possible to use the database pilotdb and let FIDO’s JDO 
implementation create the schema. 

C. JDBC CONNECTOR 

MySQL Connector/J 3.0 , the production release, was used. It is also available for 
download from http://www.mvsql.eom/downloads/mvsql-4.0.html . It is also necessary to 
to change the Lidomysql.properties file and assign the property 
javax.jdo.option.connectionDriverName as follows: 

javax.jdo,option,connectionDriverName=com,mysqLjdbc,Driver 

The driver comes with ajar file. 


In order for the program to be able to find the com.mysql.jdbc. driver, it is necessary to 
install the jar file of mysql JDBC connector (mysql-connector-java-3.0.9-stable-bin.jar) 
to the 

<LIDO_HOME>\lib directory. Otherwise, it can be added to its parent directory location 
at CLASSPATH 


D. THE JFREECHART 

JFreeChart was used to create the graphs that show the performance of JDO and 
this of JDBC in similar queries. JFreeChart is available for download from 
http://www.ifree.org/ifreechart/index.html . JFreeChart contains two jar files: the 
jfreechart-0.9.16.jar and the jcommon-0.9.1.jar, which is included in the lib directory of 
JFreeChart. 


8 







In order for the program to be able to find the classes for the graph, it is necessary to 
install the jfreechart-0.9.16.jar and the jcommon-0.9.1.jar to the <LIDO_HOME>\lib 
directory. Otherwise, it can be added to its parent directory location at CLASSPATH 


E. THE PROPERTIES FILE 

The final properties file for mysql driver is as follows: 

# lido.properties file 

# jdo standard properties 

javax.jdo.option.eonneetionURL=jdbe:mysql://loealhost/pilotdb 
javax.jdo.option.eonnectionDriverName=eom.mysql.jdbe.Driver 
#j avax. jdo. option. eonneetionUserN ame=lido 
#j avax.j do. option. eonnectionPass word=lido 

j avax. j do. option.ms W ait=5 
j avax. j do. option.multithreaded=false 
j avax.j do. option. optimistic=false 
j avax.j do. option.retainValues=false 
j avax.jdo. option.restoreValues=true 
j avax. j do. option.nontransaetionalRead=tme 
j avax.j do. option.nontransaetionalWrite=false 
j avax.j do. option. ignoreCaehe=false 

# set to PM, CACHE, or SQL to have some traees 

# ex: 

#lido.traee=SQL,DUMP,CACHE 

# set the Statement pool size 
lido.sql.poolsize=10 
lido.eaehe.entry-type=weak 

# set the max batched statement 

# 0: no batch 

# default is 20 

lido.sql.maxbatch=30 

lido.objectpool=90 

# set for PersistenceManagerFactory pool limits 
lido.minPool=l 

lido.maxPool=10 

j do. metadata=metadata.j do 


Figure 1. The Properties File for the Training-Squadron Application. 


9 





THIS PAGE INTENTIONALLY LEET BLANK 


10 



III. PROJECT DESCRIPTION 


A. THE TRAINING-SQUADRON APPLICATION 

The application developed in this project is a Training-Squadron application. The 
basic purpose of a training squadron is to provide a flight education to the air cadets. The 
following are the requirements of the system; 

• A Training squadron should have a set of Aircraft that it will use for the 
implementation of the daily flights 

• A Training squadron should have a number of Instructors pilots that will 
teach the flight techniques to the Students 

• A Training squadron should have a number of Students that will undergo 
the education process 

• Every student follows an educated flight program. 

• The educated flight program is specific for a class of students. However, it 
is possible to change it for a new class as the aviation evolutes or new 
weapon products become known. 

• The flight program consists of flight courses, which have some certain 
limitations and characteristics. 

• The flight courses are part of the Categories of flights, which share certain 
characteristics. 

• The categories also are part of a bigger subdivision, the Stadio which also 
shares certain characteristics and limitations. A student moves from one 
Stadio to another as the student’s experience increases and the limitations 
and demands also change. 

• Above all is the Series, which represents the total program that a class (a 
series) of students will follow. 

• Series except the students and the flight program have a simulation flight 
program that must be implemented by the students. 

• Additionally, a ground course program that students must attend for their 
education plan also exists. 

• Students could have a set of Instructors that help in the implementation of 
the flight program. Student can fly only with these instructors during their 
training. 

• The same relation works in reverse for the Instructors. 

• The relational schema for the above application demands all types of 
relationships from one to one, one to many, and many to many. 


11 












LiDO creates the schema for the application with the following command: 


java -cp %CLASSPATH% com.libelis.lido.DefineSchema -properties lido mysql 

A part of the project includes an effort to develop a form that will show the data 
of all the tables. 

C. THE INTERFACE MYINTERFACE 

The following interface was created to achieve the aforementioned purpose. 

public interface Myinterface { 
public int[] getFieldLengths(); 

public Object getFieldByName(String fieldName); 
public Object getField(int i); 

//to handle the collections 

public void setFieldByName(String name,Object 
value,boolean flag); 

public void setFieldValue(int i,Object value); 
public Class getTheTypeOfTheCollection(String 
collectionName); 

} 

Every class handled must implement the previously mentioned interface. 

1, The Method: getFieldLengthsQ 


public int[] getFieldLengths 


This returns an integer array containing the length of the fields in number of 
characters. 

For example, the BaseCategory class is: 

public class BaseCategory { 
private String id; 
private String description; 


public int[] getFieldLengths(){ 


13 





} 


int[] ar={10,20}; 
return ar; 


} 

The method returns the length of the two fields of the class. 

The application verifies if the number of fields of a particular class is not equal to 
the number of the elements of the array that the getFieldLengthsQ returns and raises a 
warning message. In case a contradiction occurs, the application uses a default length for 
the number of fields. 

2, The Method: getFieldByName () 


public Object getFieldByName(String fieldName) 


This returns the value of the field in which the name is equal to the String 
fieldname. 

For example, the BaseStadio class is: 

public class BaseStadio { 

private String id; 
private String description; 


public Object getFieldByName(String fieldName)! 
if (fieldName.equals("id")) 
return id; 

else if (fieldName.equals( "description")) 
return description; 
return null; 

} 


} 


14 






3. 


The Method: getField 


public Object getField(int i); 


This returns the value of the field aeeording to the field index , 

For the same example, the method in BaseStadio elass will provide the following: 

public class BaseStadio { 
private String id; 
private String description; 


public Object getField(int i){ 
switch (i) { 

case 0: 

return id; 
case 1: 

return description; 

} 

return 

} 

4, The Method: setFieldByName 0 

public void setFieldByName(String name, Object value, boolean flag); 


This assigns the value to the field with name “name” and the value “value”. The 
Boolean flag is used for one to many relationships. In this ease, the field will be a 
eolleetion. When the flag is true, the method will add the Object value to the eolleetion. If 
the flag is false, the method will remove the Object value from the eolleetion if it is there. 
For example, in the Series elass: 


15 





public class 
private 
private 
private 
private 
private 


Series { 

String id; 

String description; 
Collection stadio; 
LinkedList students ; 
Collection groundcourse; 


public void setFieldByName(String name,Object 

value,boolean flag){ 
if(name.equals("students") ){ 

if(flag) addStudents((Students) value); 
else deleteStudents((Students) value); 

} 

if(name.equals("stadio") ){ 

if(flag) addStadio((Stadio) value); 
else deleteStadio((Stadio) value); 

} 

if(name.equals("groundcourse") ){ 
if(flag) 

addGroundCourse((Groundcourse) value); 
else 

deleteGroundCourse((Groundcourse) value); 

} 


} 


5, The Method: setFieldValue () 


public void setFieldValue(int i,Object value); 


16 
















This assigns a value to a specific field. The method assigns the Object value to the 
field with the index i in the declaration of the class’ fields. For example, in the 
Categories class: 

public class Categories { 
private Series series; 
private Stadio stadio; 
private BaseCategory catid; 
private String description; 
private LinkedList exercise; 
private String seriesid; 
private String stadioid; 
private String id; 


public void setFieldValue(int i,Object value)! 
switch (i) { 

case 0: 

setSeries( (Series) value); 
break; 
case 1: 

setStadio((Stadio) value); 
break; 
case 2 : 

setCatId((BaseCategory) value); 
break; 
case 3: 

setDescription(value.toString()); 
break; 
case 4 : 

// 

break; 

} 

} 


17 




Note: Here the fields seriesid, stadioid are not informed by the method. 

The reason is that these fields are redundant and were used to make the mapping 
and assigning the key values. These fields hold the same values as series and studio, and 
are informed inside the methods that inform the series and studio fields. 

Note: The fields of collection-type as in the exercise in this example are not 
handled by this method, which instead is used the previous value: 

public void setFieldByNume(String nume, Object vulue,booleun flug) 

6. The Method: getTheTypeOfTheCollection () 


public Cluss getTheTypeOfTheCollectionjString collectionNume); 


This is used for returning the type of objects that a collection-type field contains. 
Actually, it returns the class of the object contained in the collection field. For example, 
in the Series class: 

public class Series { 
private String id; 
private String description; 
private Collection stadio; 
private LinkedList students; 
private Collection groundcourse; 
public Series () { 

} 


public Class getTheTypeOfTheCollection(String 

collectionName){ 

if (collectionName.equals("students")) 
return Students.class; 
else if (collectionName.equals("stadio")) 
return Stadio.class; 

else if (collectionName.equals("groundcourse")) 


return Groundcourse.class; 

18 




return null; 


} 

} 

In this manner, it is possible, for example, to know the eolleetion field students 
eontains objeets of Students elass. This is very important for ereating a form that eould 
provides the data depiction for every class. 

Actually, JDO provides such information when creating the metadata JDO file. 
For example, for the Series class, the metadata is as follows: 

<class name="Series" identity-type="application"> 

<field name="id" primary-key="true"/> 

<field name="stadio" > 

<coflection element-type="Stadio"> 

<extension vendor-name="libelis" 

key="sql-reverse" 

value="javaField:series"/> 

</collect!on> 

</field> 

<field name="groundcourse" > 

<COflection element-type="GroundCourse"/> 

</field> 

<field name="students" > 

<COflection element-type="Students"/> 

</field> 

</class> 

Unfortunately, it was not possible to find a method or an API that returns the 
metadata to the programmer. Thus, it was necessary to provide the above method along 
with the others in a separate interface that the classes had to implement. 


19 





D. 


THE FORM InstructorsForm 


class InstructorsForm extends JPanel implements ActionListener, 
MouseListener, ItemListener{ 


} 


Having the classes implement the above methods included in interfaee 
Mylnterface, it is possible to then use them effectively and along with the advantages that 
JDO provides, to ereate an effieient form that will be able to present the data for all of 
them. 

1, The JDOImplHelper 

An important class for use in the implementation is the JDOImplHelper. 
JDOImplHelper provides the following methods: 

getFieldFlags (java . lanq .Class pcClass) 

Get the field flags for a PersistenceCapable class. 
getFieldNames (i ava. lanq .Class pcClass) 

Get the field names for a PersistenceCapable class. 
getFieldTypes (java . lanq .Class pcClass) 

Get the field types for a PersistenceCapable class. 

An instance of JDOImplHelper can be taken as follows: 

getinstance () 

Get an instance of JDOImplHelper. 


JDO API states: This elass is a helper class for JDO implementations. It eontains 
methods to register metadata for persistence-capable classes and to perform common 
operations needed by implementations, not by end users. 

However, it resulted in being very important for the implementation 


Thus, in the Training -Squadron applieation could have an instance: 


20 









myJDOImplHelper=JDOImplHelper.getInstance(); 


One of the parameters of InstructorsForm elass is an Object that represents the 
instance of the class that will display its data from the underlying database. 


The name InstructorsForm was given because it was tried first to display the data of 
the Instructors class. Later, improving the class abilities make it work (display the 
data) for all the classes, but the initial name is retained. 


One of the constructors is as follows: 

public InstructorsForm ( 

PersistenceManager pms, 

LinkedList result. 

Object mainFormObject //represents the object of 

//the database that we will handle 

) { 


} 

It is then possible to obtain the name of the fields of the class that will its data: 

String mainFieldNames= 

myJDOImplHelper.getFieldNames(mainFormObject.getClass()); 

It is also possible to obtain the type of the fields of the class that will display its 

data: 

Class [] fieldtypes= 

myJDOImplHelper.getFieldTypes(mainFormObject.getClass()); 


21 




The possible values for fieldtypes are: 

• primitive types 

• a kind of eollection (LinkedList, HashMap ete.) 

• a date field 

• a elass of my classes. (In Flights class, for example, the field student is a 

type of Students class) 

It is then possible to verify the type and introduce the manner in which it will be 
displayed: 


if(fieldtypes[i].getName().equals("boolean")) 

mainFelds [i] = new JCheckBoxO; 


mainFields is an array of components, 
private JComponent[] mainFelds; 

It will hold all the component objects that will display the data for every field. 
Its initial length is assigned using: 

mainFelds = new JComponent [fieldNames.length]; 


For the date- type fields, the following are used: 

if(fieldtypes[1] .getName() .equals("j ava.util.Date")) 
mainFelds[i] =new JSpinner(new SpinnerDateModel()) ; 

It is also possible to ascertain if the field represents a class being used. The name 
of the package for this is: 

String mypackage= 

mainFormObj ect.getClass() .getPackage() .getName() ; 

if( fieldtypes[1].getName().indexOf(mypackage+".")>-!) 
mainFelds[1] = new JComboBox( 

getTheDataForComboBoxes(fieldtypes[1])); 

//fieldtypes hold the class of the field 


22 



Since it is known that the field represents a class of our classes, then it is possible 
to execute a query using the elass of that field as a parameter. The method 
getTheDataForComboBoxes(fieldtypes[i]) actually performs exactly this function: 

public static Collection getTheDataForComboBoxes( 

Class dataclass){ 

Collection sresult; 

//tx is the transaction 

if(!tx.isActive()) tx.begin(); 

q = pm.newQuery(dataclass) ; 
sresult = (Collection) q.execute(); 
tx.commit(); 
return sresult; 

} 

In this manner, it is feasible to represent, for example, the student field in Flights 
elass as a comboBox that will eontain the students objects from which it is also possible 
to choose for editing or inserting new values. 

String Fields 

For String field, the following is used: 

mainFelds[i] = new JTextField( fleldLength[i]); 

where fieldLength[i\ represents the length of the field as taken using the method int[] 
getFieldLengthsQ) of Myinterface. 

2. Collection Fields 

For recognizing and handling the Collection fields, the following are used: 

byte[] fieldFlags= 

myJDOImplHelper.getFieldFlags(mainFormObject.getClass()); 

The above method returns the flag for every field. 


23 



With the following if statement, it is possible to aseertain whether a field 
represents a eolleetion; 

if (myJDOImplHelper.getFieldFlags( 

mainFormObject.getClassO) [i]==10) { 

//the panel that will hold data for the subform 
//we will have one subform for every eolleetion field 

JPanel subpane=createSubFormPanel( i, fieldNames[i]); 

// 

} 


The flag for a eolleetion field is equal to 10, and mueh experimentation is required 
before finding the flag values and what they represent. Again, JDO speeifieations do 
not provide this information. As the API describes, the JDOImplHelper is for 
implementations and not for the end user. It is not possible to understand this mystic 
behavior since this kind of information provides the advantages that an object oriented 
programming can exploit for the development of an application. 


E. GETTING THE VALUES OF THE RECORD 

The InstructorsForm has a variable currentRecord. The variable is an object and 
represents the instance of the class currently displayed in the form. 

The instances of a class are possible using a query; 

public static Collection getTheData (Object dataclass){ 

Collection sresult; 

//tx is the transaction 

if(!tx.isActive()) tx.begin(); 

q = pm.newQuery(dataclass.getClass0); 
sresult = (Collection) q.execute(); 
tx.commit(); 
return sresult; 

} 


24 



where dataclass will be the object passed as parameter to the form and for which the 
intent is to display the data from the underlying database. 


The result of the query can iterate through the result and take every instance. 
Every time an iteration occurs, the value of the current object is obtained: 

if(iterator.hasNext0) { 

currentRecord = iterator.next (); 


Then, it is possible to obtain the values of the current instance and display them in 
the form. 

for (int i = 0; i < mainFelds.length; i++) { 

Class[] rc={int.class}; 

Object!] obi={ (new Integer(i)) } ; 

try{ 

java.lang.reflect.Method meth= 
currentRecord.getClass().getMethod( 

"getField", rc) ; 

Object returnValue= 

meth.invoke(currentRecord,obi); 


} 

Thus, it is possible to have the value of the field (for every field of the record) by 
simply passing the currentRecord instance as a parameter even without exactly knowing 
what the current record represents. 

It is then possible to inform the form: 

if(mainFelds[i] instanceof JTextField){ 

((JTextField) mainFelds[i]) .setText ( 

returnValue.toString() ); 

} 


25 





if(mainFelds[i] instanceof JSpinner){ 

((JSpinner) mainFelds[i]).setValue( returnValue ); 


As stated previously, the mainFelds is a JComponentWihsii is indented for 
displaying the data and the same is done for the comboBoxes and checkboxes. 

F. SETTING VALUES TO THE RECORD 

A similar taetie is followed for setting values to reeords. Onee again, the 
currentObject represents the instanee of the elass that the program is going to ehange the 
values of its field or to ereate a new instance. 

for (int i = 0; i < mainFelds.length; i++) { 

Class[] classParameters={ 

int.class, (new Object ()) .getClass () }; 

Obj ect[] ob={}; 

if( mainFelds[i] instanceof JTextField ){ 

Object!] obi={(new Integer(1)), 

((JTextField) mainFelds[1]) .getText () 

}; 

ob=obi; 

} 

Next, the values of other JComponents are obtained such as : 

checkboxes, ComboBoxes etc. 

Then the values are assigned as: 

java.lang.reflect.Method meth= 

record.getClass().getMethod("setFieldValue", 

classParameters); 

meth.invoke(record,ob); 


26 




Thus, the record is informed without even knowing the class of the record. Note 
that with JDO implementation and with the java abilities, it is possible to write code that 
covers many of the cases. Therefore, it is possible to minimize the code and check it more 
efficiently. 

1. Creating Subforms 

The following function creates the subforms; 

public void setSubformForTheField(String nameSubformField, 

Object subformObject){ 
for (int i=0;i<mainFieldNames.length;i + + ) 
if(myJDOImplHelper.getFieldFlags( 

mainFormObject.getClass())[i]==10 ) 
if(mainFieldNames[i].equals(nameSubformField)){ 

InstructorsForm subform=new InstructorsForm ( 

pm, subformObject); 
subform.setParentForm(this) ; 

subform.setTheLinkedFieldName(mainFieldNames[i]); 
mainFelds[i] = subform; 


} 


} 


The myJDOImplHelper.getFieldFlags(mainFormObject.getClass())[iJ==10 
verifies if the field represents a collection. Otherwise, it is not necessary to create the 
subform since the field will not represent a link to another table. 

If the above is functioning correctly, then a new form is created using: 
InstructorsForm subform=new InstructorsForm (pm, subformObj ect); 

Where: 

pm: is the Persistent Manager 

subformObject :declares what kind of object the subform holds. 

27 



For example, to create a subform in Students form representing the Instructors 
with whom the student fly, the subformObject will be an instance Instructors class. The 
Student class has a collection field named instructors for that purpose. It is possible to 
create a subform representing the instructors of the Student instance using the following: 

setSubformForTheField("instructors", new Instructors ()) 

The link is also set using: 
subform.setParentForm(this); 

In order to have the correct data, when iterating through the main form, the 
dataset of the subform is changed to that of the main form using the following: 

if (mainFelds [ i ] instanceof InstructorsForm) {//Means that 
//this will be a subform 

LinkedList datalist=new LinkedList(); 
if(returnValue!=null) 

datalist=new LinkedList((Collection) returnValue ); 

/ (InstructorsForm) mainFelds[1]) .setMainData (datalist )/ 

//Get the data from the main form 

//this first and then nextRecord() because nextRecord() goes recursively 
((InstructorsForm) 

mainFelds[i]).updateNumberOfRecords() 

( (InstructorsForm) mainFelds[i]) .nextRecord() ; 


28 



IV. JDO DISADVANTAGES 


This chapter explores the disadvantages of JDO. 

A, MANY TO MANY RELATIONSHIPS 
1. The Redundancy of Tables 

The JDO is able to create a one to many relationship by using the <colleetion> 
Tag in the JDO metadata file. For example, in the Training-Squadron application, the 
elass Categories exists, whieh have a one to many relationship with the elass Exereise 
(An Instance of Categories ean have many Exereise instances). 

A field in elass Categories (named exereises) is used to ereate the relationship. 
The field is a list (EinkedList) and it is neeessary to provide the content of the list in order 
to help EiDO ereate the tables in the database. 

The relative eommands to the JDO metadata file were: 

<class name="Categories" identity-type="application"> 
<field name="seriesid" primary-key="true"/> 

<field name="stadioid" primary-key="true"/> 

<field name="id" primary-key="true"/> 

<field name="exercise" > 

<collection element-type="Exercise"/> 

</field> 

</class> 

As seen, it is possible to deelare explieitly that the exercise field will contain 
instances of Exereises elass. The metadata for the Exercise elass are as follows: 

<class name="Exercise" identity-type="application"> 

<field name="seriesid" primary-key="true"/> 

<field name="stadioid" primary-key="true"/> 

<field name="categoriesid" primary-key="true"/> 

<field name="id" primary-key="true"/> 

</class> 


29 






When the bateh file for the ereation of the sehema is run (using inside the 
eommand); 

java -cp %CLASSPATH% com.libelis.lido.DeJineSchema -properties lidojnysql). 

LiDO ereated three tables for the above relationship; 

One Table represents the Categories named; c_categories. 

(c_ ;eomes from the initial of the 
paekage eontaining the elass- company 
in our ease) 

Another Table represents the Exereise named c exereise. 

The last table represents the relationship named; e eategories exereises. 

The relationship eontains the primary keys of both tables. 

The primary key of the Table from the one side beeomes a foreign key in that 
table named as follows; 

LIDOFK_ seriesid 
LIDOFK_ stadioid 
LIDOFK_ id 

(for Link to Categories class) 

The primary key of the Table from the many side beeomes a value key in that 
table named as follows; 

LIDOVALUE_ seriesid 
LIDOVALUE _ stadioid 
LIDOVALUE _ categoryid 
LIDOVALUEJd 
(for Link to Exercise class) 

Thus, it is possible to have a elear representation for a one to many relationship. 
The problem is that it is not possible to navigate from Exercise to Categories while it is 
easy to navigate from Categories to Exercises. 

An inverse relationship is neeessary to navigate in both sides. 


30 



2, Inverse Relationship 

The implementation of a many-to-many relationships is very diffieult in JDO, 
which demands the use of a key- inverse tag, also called a managed relationship. The 
main problem is that managed relationships are not supported by JDO but is an 
implementation a specific feature. In other words, some vendors support it while others 
do not, which is not, of course, a portable solution. 

A relational DBMS could solve the problem by using another table that could 
hold the reference of both tables (their relationship). An attempt at representing the 
many-to-many relationship in JDO is discussed as follows. The Training Squadron 
application has a many-to-many relationship between Instructors and Students. Students 
can have many Instructors and Instructors can teach many students. The JDO creates 
four tables when using collections on both sides of the tables, and it is necessary to 
inform the relation in both sides programmatically. Trying to use a managed relationship 
with a reverse-key in both tables does not work. To resolve the problem, it was first 
necessary to define two lists in both classes; One in Instructors class is named students 
and the other in Students class is named instructors. Then, a managed relationship in both 
sides was attempted as follows. 


<class name="Instructors" > 

<field name="id" primary-key="true"/> 

<field name="students" > 

<collection element-type="Students"> 

<extension vendor-name="libelis" 
key="sql-reverse" 

value="JavaField:Students.instructors"/> 
<collection/> 

</field> 


</class> 


<class name="Students" > 


31 


<field name="id" primary-key="true"/> 

<field name="instructors" > 

<collection element-type="Instructors"> 

<extension vendor-name="libelis" 
key="sql-reverse" 

value="JavaField:Instructors.students"/> 
<collection/> 

</field> 

</class> 


However, this approach does not work since JDO was unable to do the mapping 
using this syntax. The next attempt tried to change the references from a Java field to a 
Table field (JavaField- dbfield) as follows but was also unsuccessful: 

<class name="Students" > 

<field name="id" primary-key="true"/> 

<field name="instructors" > 

<collection element-type="Instructors"> 

<extension vendor-name="libelis" 
key="sql-reverse" 

value="dbfield:id=LIDOVALUE_id"/> 

<collection/> 

</field> 


</class> 


The only way to solve the problem is to create an additional class to represent the 
relationship (An Intsructors_Students class) and then use a managed relationship with 
collections in both of the other two tables These represent the Students and the Instructors 
classes. Such an implementation would increase the complexity of the program and the 
queries. The most important, however, is that such an implementation requires a managed 
relationship (the use of a key-inverse element) which is not supported by JDO, but is 
implementation specific (vendor specific). LiDO fortunately supports managed 


32 



relationships but implementing the program using that LiDO-specific feature might case 
a lack of portability among other JDO implementations. 

It is possible to write the metadata as follows by using the features that JDO 
supports: 

<class name="Instructors" identity-type="application"> 

<field name="id" primary-key="true"/> 

<field name="lname" > 

<extension vendor-name="libelis" key="sql-index" 
value="unique"/> 

</field> 

<field name="students" > 

<collection element-type=" Students "> 

</collection> 

</field> 

<field name="aircrafts" > 

<coflection element-type="Aircraft"/> 

</field> 

</class> 


<class name="Students" identity-type="application"> 

<field name="id" primary-key="true"/> 

<field name="instructors" > 

<coflection element-type="Instructors"> 
</collection> 

</field> 


</class> 


This implementation demonstrates that JDO creates the following tables: 
c instructors 


33 


c_instructors_students 

cstudents 

cstudentsinstructors 

Thus, there are four tables instead of three, and it is necessary to inform both 
relationships explicitly when a new reference is added in either the Instructors or 
Students classes. 

Fortunately, this is easily done using JDO capabilities, but in any case, it is not a 
good implementation. This implementation could render false data if a break occurs in 
the sequence of informing the tables. Thus, it is possible to inform the Instructors table 
about the students and a loss of power could prevent the informing of the Student class 
about the instructors, leading to possible corrupted data in the application. Additionally, 
since it is necessary to inform both reference tables instead of one, the time for such an 
operation will almost double. Thus, a decrease in performance occurs. 

In this case, the following commands in the implementation are used in 
Instructors class: 

public void addStudents(Students student) { 
if(students==null) 

students=new LinkedList(); 
students.add(student); 

if(!student.getInstructorsO .contains(this)) 
student.addinstructors(this); 

} 

In Students class: 

public void addinstructors(Instructors instructor) { 
if (instructors==null) 

instructors=new LinkedList(); 
instructors.add(instructor); 
if(!instructor.getStudents().contains(this)) 

instructor.addStudents(this); 


} 


34 


The same must be done for the delete proeedures. In Instructors class: 


public void deleteStudents(Students student) { 
if(students!=null{ 

students.remove(student); 
if(student.getInstructors().contains(this)) 

student.deletelnstructors(this); 

} 

} 


In Students class: 

public void deletelnstructors(Instructors instructor) { 
if(instructors!=null){ 

instructors.remove(instructor); 
if(instructor.getStudents().contains(this)) 

instructor.deleteStudents(this); 

} 

} 


In summary, an additional table is needed in order to implement a many to many 
relationship. Thus, the normal JDO implementation requires more space on a hard disk, 
more code to implement the read, write, and delete procedures, and a profoundly longer 
time operation for also informing the additional table. 

B. FIELD REDUNDANCY 

Also, a big problem is the use of additional redundant fields. JDO and the LiDO 
implementation cannot create a compound key when the relative field is part of a 
reference. 

For example, the application contains the Stadio class, Stadio represents a super 
category where many categories belongs to it. The Stadio class has a one to many 
relationship with Series class and represents the part of many in this relationship. 


35 



In the definition of the Studio class, there is a field called series which represents 
the Series class of which the Studio is a part. Actually, the series field in the database 
only keeps the primary key of the possessing class, which in this case is the id field of the 
Series class. If the following is attempted, an error message occurs stating that JDO is 
unable to find a getter method for type compuny.Series: 

<class name="Stadio" identity-type="application"> 

<field name="id" primary-key="true"/> 

<field name="series " primary-key="true"/> 

<field name="categories" > 

<collection element-type="Categories"/> 

</field> 

</class> 

Another possible solution could include an effort to make a compound primary 
key for the Studio class consisting of the id field of the Studio class and the id field of the 
series field, which is an instance of the Series class. 

The following shows the metadata code for the above purpose. 

<class name="Stadio" identity-type="application"> 

<field name="id" primary-key="true"/> 

<field name="series.id" primary-key="true"/> 

<field name="categories" > 

<collection element-type="Categories"/> 

</field> 

</class> 

However, this does not work. When it was tried, LiDO created the c stadio table 
and used the field name id as a primary key, while the series field, and specifically, the 
series.id was not part of the table’s primary key. Not only did this happen, but there was 
no error message or any other message stating that JDO completely ignored the following 
statement: 


36 



<field name="series.id" primary-key="true"/> 


The problem is that JDO uses only primitive types for the key values. 

However, in this case, some problems need discussion. It was not possible to not 
reuse the same id and include it to another relation with a series, id by having the table 
c stadio with the id as the only member of the primary-key. The limitation results 
because the id will be a primary key, and therefore, duplicate values are not allowed. 
Thus, the desirable one to many relationship between the c series and c stadio tables 
could not be implemented using the id field as the only member of the key. This was 
impossible since a managed relationship was used for the two tables. The metadata for 
the Series class is as follows: 


<class name="Series" identity-type="application"> 

<field name="id" primary-key="true"/> 

<field name="stadio" > 

<collection element-type="Stadio"> 

<extension vendor-name="libelis" 
key="sql-reverse" 
value="javaField:series"/> 
</collection> 

</field> 


<field name="groundcourse" > 

<collection element-type="GroundCourse"/> 

</field> 

<field name="students" > 

<collection element-type="Students"/> 

</field> 

</class> 

Using the ksy='"sql-reverse'”, LiDO creates only two tables for the relationship: 
the c series and the c_stadio. The c stadio table includes a field series_id which declares 
the relationship between the two tables. Since the primary key for c_stadio is only the id 


37 




field of the Studio elass, it was not able to have a studio instanee with a same id to be 
referenced by another Series instance. Actually, this means that it was not possible to 
have a one to many relationship. 

A possible solution was to let LIDO create the primary key. In this case, the 
identity type of the class would be dutustore as follows: 

<class name="Stadio" identity-type="datastore"> 

In this case, as JDO determines the vendor, it will create the key. The primary key 
will be one field of a long unique value. However, this implementation again entails the 
danger that it is possible to install the same studio instance (with the same id value) more 
than once in the same series instance without receiving an error message, something that 
makes the database very risky and error prone. 

A solution could be to write a query to check whether the studio instance is 
already referenced by a specific series instance before the addition of a new reference. 
However, this is also time consuming and it could not prevent the insertion of wrong data 
from another application. 

Thus, the only solution for the Training-Squadron application was to introduce a 
new field to keep the series id in the c stadio table, which will provide the reference for 
the series instance of which the studio is a part. The final metadata was: 

<class name="Stadio" identity-type="application"> 

<field name="seriesld" primary-key="true"/> 

<field name="id" primary-key="true"/> 

<field name="categories" > 

<collection element-type="Categories"> 

</collect!on> 

</field> 

</class> 

where seriesid is the new field t introduced to the database. The definition of the class 
became: 


38 



public class Stadio { 

private Series series; 
private BaseStadio sid; 
private String description; 
private Collection categories; 
private String seriesid; 
private String id;. 


In order to avoid new entries, the seriesid field is informed automatieally along 
with the series elass. 

public void setSeries(Series ser) { 
this.series= ser; 
this.seriesld=ser.getid() ; 

} 


Thus, there is a redundant field. The same situation appears to Categories and 
Exercise elasses where it was neeessary to introduce two and three more fields in order to 
have a suitable primary key. 

Although the information of these fields is not difficult, more code is needed 
when creating a form to display the data either for the display of these fields or for their 
abstract of the set fields that appears on the form. Actually, these additional fields must 
be hidden since the user should not be able to change their values. Instead, their values 
must be set automatically and according to their referenced class. 

However, more importantly, there are redundant fields consuming more space and 
time for the implementation. The author believes that JDO could be able to understand 
the values. Although JDO needs to use primitive types, there must be a solution either to 
have the primary key of the class when referred to a class or to be able to set the value of 
the field to the metadata JDO file such as 


<field name="series.id" primary-key="true"/> 

39 




instead of 


<field name="series" primary-key="true"/> 

which does not work, or when in the second case, the JDO could automatically provide 
transformation to the key field or fields of the series class. 

C. JDO GROUP BY QUERIES 

JDO does not support GROUP BY queries, which is a great disadvantage. 

1, Performance Imitating a GROUP BY Query 

The performance of JDO queries in a set of 2000 records is provided that have 
been stored in Flights class in the underlying c fiights table. 

The following chart shows the time required for a JDBC GROUP BY query to 
take group data. The first bar is the time of receiving the result set while the second 
includes the time for iteration through the result. The third bar represents the time it takes 
the JDOQL to execute a query and then iterates through the result set in order to achieve 
the same group data as the JDBC GROUP BY query. 

JDO takes almost 4 seconds when it executes for the first time while the group by 
query is significantly faster. 



Figure 3. JDO Performance Imitating a GROUP BY Query. 


40 




















The following chart shows the results after executing the queries for a second 
time with more operations already in memory. Note that the time is minimized to less 
than one second but the same happens to the GROUP BY query and the difference is 
again the same. 



Figure 4. JDO Performance Imitating a GROUP BY Query (Second Execution). 

LIDO can pass pure SQL commands using the “sql” tag. 

In attempting to pass a GROUP BY query as follows: 


String sql="SELECT a.instructor_id, SUM(a.endurance) "+ 
"FROM c_flights a "+ 

"GROUP BY a.instructor id 


Query query=pm. newQuery [("sql"| , sql) ; 
query.setClass(Flights.class); 

Collection result=(Collection) query.execute(); 


the following message is received. 


41 





















m C:\WINDOWS\System32\cmd.exe -[□! X 


GROUP BV31 
1080542139218 

javax.jdo.JDOFatalDataStoreException: Jdbc ResultSet Error SQLEXP iColutnn 'LIDO 
ID’ not found. 

NestedThrowables: 

java.sql.SQLException: Column 'LIDOID' not found. 

at com.libelis.lido.ds.jdbc.b.e.l<e.jaua:243> 
at com.libelis.lido.ds.rmapping.d.b.p.a<p.jaoa:89> 
at com.libelis.lido.ds.jdbc.j.k.a<k.jaoa:104> 
at com.libelis.lido.ds.jdbc.j.bg.a<bg.jaua:145> 
at com.libelis.lido.ds.jdbc.j.bd.f<bd.jaoa:153) 
at com.libelis.lido.ds.jdbc.j.bq.f<bq.jaoa:90) 
at com.libelis.lido.ds.jdbc.j.br.i<br.jaoa:122) 
at com.libelis.lido.ds.jdbc.j.br.a<br.jaua:82) 
at com.libelis.lido.ds.jdbc.j.bd.a<bd.jaoa:112) 
at com.libelis.lido.ds.jdbc.j.be.a<be.jaoa:68) 
at com.libelis.lido.ds.jdbc.n.aCn.jaoa:175) 
at com.libelis.lido.ds.jdbc.j.bo.d<bo.jaoa:91) 
at com.libelis.lido.ds.jdbc.j.bo.execute<bo.jaoa:47) 
at test.QueryForm.QuerifCetFlightsSQLGROUPBVCQuervForm.jaoa:231) 
at test.ReportsForm.sbowGROUPBVI nstruetorsHours<ReportsForm.jaoa:954) 
at test.ReportsFormS7.actionPerformed<ReportsForm.jaoa:341) 
at jaoax.suing.RbstraetButton.fireBctionPerformedCUnknoun Source) 
at jaoax.suing.fibstractButton$ForuardflctionEoents.actionPerformed<Unknou 
n Source) 


Figures. LIDO Message for‘sql’tag. 


It appears that the “sql” tag does not support GROUP BY queries. 

2, Performance for Simple SELECT Queries 

JDO’s performance, however, is slow even for simple SELECT statement queries. 
The following chart is created by executing a select query using the “sql” tag and 
retrieveAll(). The first bar is again from JDBC execution of the same query (SELECT 
query here). The time for JDO is 1672 milisec. 


42 






Figure 6. JDO Performance Using ‘sql’ Tag and retrieveAll() Operation. 

If the same query is executed without the retrieveAll() operation, the following 
result occurs. The time for JDO falls to 297 milisec. This huge difference is caused by 
JDO because the result set does not contain the values of each record but contains only 
hollow instances, indicating that the time desired to learn the studentJd of a specific 
flight instance JDO will go and read it from the datastore after the request. Data 
information are not loaded in memory. 


43 




















Figure 7. JDO Performance Using ‘sql’ Tag without retrieveAll() Operation. 

For example, if the same query is executed without retrieveAll() and iterated 
through the result set to get values of the instances, the time will increase significantly as 
the following chart shows. 



Figure 8. JDO Performance Using ‘sql’ Tag without retrieveAll() but with Iteration 

through the Result Set. 


44 





























The situation is not better in a simple SELECT elause query. Below are the results 
of executing a select query using JDBC and JDO without the “sql” tag. The results are 
taken using RetrieveAll() and iteration through the data of the JDO result set. 



Eigure 9. JDO Performance without ‘sqT Tag with retrieveAll() Operation and with 

Iteration through the Result Set. 

The same query without iterating through the data of JDO result test gives the 
following chart. 


45 














Figure 10. JDO Performance without ‘sql’ Tag with retrieveAll() Operation but 

without Iteration through the Result Set. 

The results are the same using the “ sql” tag. 



Figure 11. JDO Performance with ‘sql’ Tag with retrieveAll() operation but without 

Iteration through the Result Set. 


46 





























The remaining eharts shows the performance of JDO without RetrieveAll() (With 
Iteration) 



Figure 12. JDO Performance without retrieveAll(), and with Iteration. 

Without retrievcAllO (and without iteration), the result was very high because the 
result set contains hollow instances. 


47 
















Figure 13. JDO Performance without retrieveAll(), and without Iteration. 


Without RetrieveAllO (Without iteration) and using SQL TAG results in: 



Figure 14. JDO Performance without retrieveAll(), and without Iteration Using ‘sql’ 

Tag. 


48 


































Note that the performance of the JDO is far worse than that of JDBC and pure 
SQL. The problem is more significant in GROUP BY queries where it is necessary to 
iterate through the data in order to achieve a group result. 

Another interesting conclusion is that even when using the “sql” tag and passing 
pure SQL to the query, the performance of JDO remained far behind the performance of 
JDBC using the same SQL commands. The retrieveAllQ command almost doubles the 
performance of JDO queries when iterating through the data. 

D, NO SUPPORT OF ALL THE DATA STRUCTURE TYPES 

Another disadvantage is that JDO does not currently support all types of data 
structures for all the operations. 

For example, the following definition for the Series class was used; 

public class Series { 
private String id; 
private String description; 
private LinkedList stadio; 
private LinkedList students; 


} 

The Series class as described previously has a one to many relationship with the 
Stadio class. (The Series is part of the one while the Stadio is part of the many) 

Initially the (I THINK THAT YOU LEFT SOMETHIG OUT HERE) was used to 
represent the above relationship. 

private EinkedList stadio; 

Attempts at mapping the underlying database were unsuccessful. 

Efforts were made to keep the data in two tables without the intermediate 
representing the relationship. Thus, the “sql-reverse” key was used to keep the data in 
only two tables, with the table representing the Series class and the table representing the 
Stadio class, which will have a foreign key declaring the ownership reference in the 
series table. 


49 




The metadata file appears as: 


<class name="Series" identity-type="application"> 
<field name="id" primary-key="true"/> 

<field name="stadio" > 

<collection element-type="Stadio"> 

<extension vendor-name="libelis" 
key="sql-reverse" 
value="javaField:series"/> 
</collection> 

</field> 

<field name="students" > 

<collection element-type="Students"/> 

</field> 


</class> 


The eode seemed valid but the following error message was reeeived: 


SI C:\WINDOWS\System32\cmd.exe -[□! X 


The system cannot find the file specified. 

Deleting log ... 

The system cannot find the file specified. 

Database created 

- Creating Schema ... 

LiDO DefineSchema 

LiDO 1.4.B build #075 <02/01/2004> 

<C> 2001-2003 LIBeLIS 

fln exception as been raised 

java.lang.UnsupportedOperationException: Unable to map a reverse collection in a 
list: stadio 

at com.libelis.lido.ds.rmapping.d.d.b.a.a.c.a<c.java:193> 
at com.libelis.lido.ds.rmapping.d.e.b.a<b.java:44> 
at com.libelis.lido.ds.jdbc.c.a.a.a<a.java:255> 
at com.libelis.lido.ds.jdbc.c.a.a.a<a.java:121> 
at com.libelis.lido.ds.jdbc.c.d.a<d.java:190> 

at com.libelis.lido.ds.jdbc.DefineSchema.a<DefineSchema.java:150> 

at com.libelis.lido.ds.jdbc.DefineSchema.b<DefineSchema.java:417> 

at com.libelis.lido.ds.jdbc.DefineSchema.runUith<DefineSchema.java:105> 

at com.libelis.lido.b.a.runUith<a.java:98> 

at com.libelis.lido.b.a.runWith<a.java:61> 

at com.libelis.lido.DefineSchema.a<DefineSchema.java:13> 

at com.libelis.lido.DefineSchema.main<DefineSchema.java:5> 

ERROR:Unable to define the schema 

Press any hey to continue . . ._ 


The problem oeeurred when using the LinkedList for the stadio data. The 
definition of the Series class was changed as follows: 


50 





public class Series { 


private String id; 
private String description; 
private Collection stadio; 
private LinkedList students; 
private Collection groundcourse; 


The problem was solved without ehanging the metadata JDO file, whieh was 
extremely interesting sinee the implementation of a LinkedList is not a problem for 
representing the one to many relationships. The problem only appeared when attempts 
were made to use an inverse relationship. In this case, only a Collection is suitable while 
LinkedList is prohibited or unsupported as the message states. 

It was not possible to find a good reason for this diversity since LinkedList is used 
for relationships as previously stated. Moreover, this kind of diversity creates inquiries 
concerning the reason for the error. Additionally, the use of metadata file, which is 
written in XML, makes discovering the errors more difficult. It will not be easy to accept 
that a collection will be supported for normal and inverse-key relationships while the 
LinkedList is only supported for a normal relationship. Therefore, the use of LinkedList 
is all the more effective. It provides the listiterator, which is able to use the previousQ 
along with nextQ. Thus, a far more better navigation ability exists than using the simple 
iterator of a Collection. In this application, the listiterator is used in order to be able to 
move efficiently through the data in the forms. In order to do so, it was necessary to 
convert every Collection data type to LinkedList using the following constructor: 

new LinkedList( Collection c); 

Thus, support of all kinds of data structures could eliminate the need to write 
much more code and use of memory. 


51 




E, NO FREE SOURCE CODE 

One of the main problems impeding the evolution of JDO is its vendor specific 
implementation. No open source implementation exists so becoming familiar with the 
concept is not very easy. The only open source implementation is Sun’s reference 
implementation but this is very limited in abilities. 

One of the very few free implementations is the community edition of LiDO by 
libelis. However, even this needs a license which expires after six months. Most vendors 
provide their product only by payment. This is expensive for a product when no clear 
depiction of how it works exists and how efficient it could be. This depiction is all the 
more difficult since familiarization with JDO is not easy considering the absence of open 
source implementations. 

This image has, of course, negative repercussions for the evolution of JDO. 
Although its investors support that the implementation of an application will be much 
faster, many problems exists. 

Actually, quite a bit of time is required for installing and the executing the classes 
of the program. The enhancement of the classes requires additional preparation which 
makes the compilation time little trouble. Batch files could be used for the execution of 
the code and much time was spent on debugging and error detection and correction with 
this procedure. An integrated environment covering the JDO specification would be very 
useful. 

The vendors might have their integrated environments. However, these are not 
open source and so familiarization with the product is difficult. Moreover, the use of the 
metadata file, which is written in XML, makes the situation more cumbersome. 

F. WHY XML? 

The metadata file could also be considered one of the negative aspects of JDO. 
First, it is written in XML, which is another language with which the user needs to be 
familiar. 

However, JDO came as a solution that will work completely with java and will 
free the user from the necessity of learning and using another complex language, such as 
SQL. Then, why does the user need to become familiar with XML? At least SQL can 


52 



provide a more effieient approaeh for retrieving and manipulating data and is mueh faster 
as the previous ehart and figures have shown. Its use eould be justified sinee the 
performanee of JDO lags behind, so it is a risk worth taking. However, using XML just 
for mapping or deseribing the method for ereating the underlying database is not 
neeessarily a very good idea. 

The detection of errors is very difficult inside the XML file, which could result in 
a bad experience. For example, using the following metadata in Series class renders: 

<class name="Stadio" identity-type="application"> 

<field name="id" primary-key="true"/> 

<field name="series.id" primary-key="true"/> 

<field name="categories" > 

<collection element-type="Categories"/> 

</field> 

</class> 

It can be expected that the JDO would create the primary key using the primitive type of 
series.id. However, this does not happen because a message for the above code fragment 
stating that something is going to be ignored will not be received. It is possible to 
discover that JDO ignores the command only when looking at the underlying database. 

Writing the metadata file also, in a simple text editor, is not very simple, which is 
especially true when it is necessary to create a large application with many tables taking 
care of the xml file. This will now be all the more difficult. Using different environments 
for writing the xml file and the java files is also a disturbing issue. In conclusion, this 
metadata file will be preferable to be included as an API interface in JDO. No other 
important reason exists why it could not be done. 

Classes that need to be persistent could be done by implementing the particular 
Persistent interface, for example. Mapping with a database could be done also using the 
particular methods of that interface, (i.e. Persistent.setKey(Class, field[]) ) Thus, it is 
possible to achieve more scalable applications. 


53 



It is necessary to now provide the vendor’s name and the vendor’s specific keys 
with the xml file. Additionally, it is essential to learn what every vendor does and how it 
uses its commands, something that could be hidden behind the implementation of the 
Persistent interface. With the current profile, it is at least necessary to change the 
metadata file when changing vendors, which could be very burdensome if the application 
is large enough. 

Also, what if one vendor supports a managed relationship while others do not. 
Then, the application will only be vendor specific, and one of the key strengths of JDO 
disappears. In addition, what if a managed relationship is desired but referential integrity 
is required during the deletion of a record or the receiving of a message for applying or 
not applying referential integrity or not is also preferred. It is possible to create such 
issues easier using an interface instead of the xml file. 

G. METADATA DEFICIENCY 

Finally, the problem with the metadata exists. For example, while the length of 
the fields is specified, it was not possible to find a good way to retrieve this metadata 
information. 

The only usable method for the programmer found is JDOImplHelper CLASS. 
However, as the API states: 

This class is a helper class for JDO implementations. It contains methods 

to register metadata for persistence-capable classes and to perform 

common operations needed by implementations, not by end users. 

The following can be taken from JDOImplHelper: 

Field names 

Field types 

Field flags. 

It was not even possible to find a description of the flags. JDO is pragmatically 
very limited in what it provides to the programmer. 

It was necessary to experiment with different cases to conclude finally that 
A flag of 10 is a list 
A flag of 8 is a primary key ... 


54 



In addition, this information is very important for the programmer. Attempts were 
made to find classes that provided the field length but they were unsuccessful. Methods 
that return the values of the field parametrically were also tried, such as 

getField(int fieldindex) 

or 

getFieldByname(String fieldname) 

These types of methods are very useful for creating strong and short applications. 
Additional methods must be found for setting values to a field. Certainly, JDO knows 
these kinds of methods and uses them for the implementation but it does not provide 
them. It might provide them, but the author did not find them, although even the 
JDOImplHelper comes with the comment that it is not indented for use by the final user. 

Since the idea was to create a very fast application and exploit the advantages of 
java and since no JDO metadata information was found, an interface was provided to 
provide some metadata and the parameterized access of the fields for reading and writing. 
While the interface does not use more than six methods, it was possible to create a class 
that provides the navigation and handling of all the classes that implement this interface. 

The description of this class is provided in Chapter III where the description of 
the application appears. However, it is important that using the metadata can result in a 
very good and very fast job with JDO. It will be greatly advantageous to application 
development if JDO provided all this metadata information. It was, however, disturbing 
to give the metadata information to the xml file and write them again using an interface 
simply because no other way exists to retrieve them. 


55 



THIS PAGE INTENTIONALLY LEET BLANK 


56 



V. JDO ADVANTAGES 


This chapter describes the advantages of JDO for the development of an 
applieation in eomparison with other approaehes. 

JDO is an important innovation for the Java platform. Before JDO, java 
developers had to use the JDBC for database aeeess. For enterprise applieations, the 
solution was Enterprise Java Beans APIs whieh provided a container-managed 
persistenee. JDO was an effort to provide a simpler way for ereating persistenee in a Java 
platform. Thus, development eould be easier for java developers. JDO eame as a solution 
for providing database persistenee minimizing the amount of time the Java programmer 
must spend developing. 

A, OBJECT ORIENTED VIEW OF THE DATABASE 

JDO provides transparent persistenee of Java objeet models in transaetional 
databases. The user ean map the Java classes to the data of the underlying datastore. With 
this mapping, the user does not need to be extremely knowledgeable of the database, and 
only needs to know how to handle the Java elasses. Thus, the user works with an objeet- 
oriented model even if the applieation manages data from tables in a relational data 
model. 

The development of a database applieation eomes with the advantages of the 
objeet oriented programming. During the development of the Training-Squadron 
applieation, many of these advantages were apparent. First, the aeeess of field values and 
the read write eommitment to the data happened inside the elass in a elear and effieient 
way. For the Instruetor class, for example, it was possible to take the value of a field by 
simply ealling a method of the elass: 

Public String .getLastName(){ 
return lastName; 

} 

This is a very simple way to aeeess the data of a database. Similarly, it is easy to 
assign the values to a partieular field: 

Public void setLastName(String name){ 


57 



lastName=name; 


} 


This is easier, of course, than executing a SQL query of type: 

INSERT INTO Instructors 


VALUES [.] 

Or better : 

UDATE Instructors 

SET lastName . 

VALUES . 

WHERE id=. 


What is more impressive, however, is the method used to access fields in a 
relationship: Instructor class (actually the underlying instructors table) has a one to many 
relationship with Students class (actually the students table). 

The retrieval or modification of data from one table to the referenced one can be 
done in a completely object oriented way. 

The instructors class have a list representing the students 

public class Instructors { 

private String id; 


private LinkedList students; 


} 

Some simple java methods can easily manage the relation. 


58 








public void addStudents(Students student) { 


if (students==null) 

students=new LinkedList(); 
students.add(student) ; 


} 

Either a Map can be used to keep uniformity of the data or verification if the 
student is already present in the Instructors list by simply using 

If (!students.contains(stiudent))// 
students.add(student); 

This is easier than using a query of type 

INSERT INTO Instructor student 


VALUES XX.yy. 

before maybe executing a SELECT query for obtaining the values of xx or yy in both the 
Instructors and Students tables. Equally iimpressive is the method used to access values 
of fields of a referenced table. 

Series.getStadio().get(l).getCategory().get(l).getExercise().get(l).getId() 

This is much more understandable and easier than a query of type: 

SELECT a.id 

FROM exercise a INNER JOIN (categories b INNER JOIN 

(Stadio c INNER JOIN (series d on d.id=c.series_id) 
On c.id=b.stadio_id) 
on b.id=exercise.category_id 

WHERE Series.id=xx and stadio id=yy and categories.id =zz.. 


59 






B, AUTOMATE PERSISTENT 

Also important is the method for automate or transitive persistent. Attempting to 
add some reeords to the Flights elass eould ereate an instanee of Flights elass using the 
eonstructor; 

public Flights(Aircraft aircraft,Instructors instructor. 

Students student. Date date) { 


} 


The way to store the new reeords in JDO eould be; 

Students student= new Student ; 
Instructors instructor= new Instructors (...) ; 
Aircaft aircraft =new Aircraft (...) ; 

Finally: 


Flights flight = new Flights( 

aircraft, instructor, student, today()) 


if: 


PersistentManager pm.makePersistent(flight) 

All instanees of the instruetor, student, and aircraft will become persistent by 
reachability and will be stored to the database if not already there. This is a great 
advantage when thinking about how many SQL codes it is necessary to written in order 
to insert all the above instances to the database. 


60 




C. EASE OF IMPLEMENTATION 

During the implementation of the Training-Squadron applieation, it was able to 
use one elass for handling the data of all the elasses. When using JDO, the data using 
only java classes is handled. Thus, all the advantages of object-oriented programming 
provided are possible. 

For the implementation of the Training- Squadron application, it was tried to 
exploit database programming in this manner. Thus, it used the functionality that java 
classes provides. During the development, it used parameterized methods and it proved 
possible to provide one class for the data. 

It also exploited the JDOImplHelper class and the data that it provides. The 
following methods were mainly used: 

getFieldNames(Classs c) 

getFieldTypes (Classs c) 

getFieldLength(Classs c) 

Using an interface succeeded in obtaining additional metadata such as the field 
length. Moreover, there were created functions for retrieving the values of the fields and 
setting the values of the fields. 

For all the above, of course, java functionality and the object representation of 
data that JDO provides was exploited. Since the tables are provided as java classes or 
java objects, their manipulation is very efficient. 

It proved possible to obtain the metadata from every table simply by using 
commands such as the following: 

myJDOImplHelper=JDOImplHelper.getInstance (); 

//try to get the lengths of the fields 

int[]fieldLength=getTheLengthOftheFields (); 

//get the name of the fields 

61 



mainFieldNames= 


myJDOImplHelper.getFieldNames( 

mainFormObject.getClass ()); 

myJDOImplHelper.getFieldTypes(mainFormObject.getClass()) 

It was only necessary to pass an object as a parameter and using the getClassQ 
method to receive whatever data desired. It was possible to obtain additional metadata by 
simply invoking the method that provides these metadata. It used the functionality of 
reflection which made the application very short and cohesive 

Below is an example of using reflection for taking the type (the kind of class that 
a list contains) of the field that represents a collection in a class. 

java.lang.reflect.Method meth= 

mainFormObj ect.getClass() .getMethod( 

"getTheTypeOfTheCollection", rc); 

Object retumValue= meth.invoke(mainFormObject,obi); 

For the Instructors class where the student field represents a LinkedList (which 
contains students) the following is applied: 

public class Instructors { 
private String id; 


private LinkedList students; 


} 

java.lang.reflect.Method meth= 

mainFormObj ect.getClass() .getMethod( 

"getTheTypeOfTheCollection", "students") ; 


//(The String value “students” can be taken just using the ) 

JDOImplHelper.getFieldNames( 

62 





mainFormObject.getClass ())) 

Object returnValue= meth.invoke(mainFormObject,obi); 

From the above statement, returnValue will determine the elass of the objeets 
eontained in students List. 

Next, it was possible to pass the returnValue to a query and retrieve all the data of 
the elass eontained in the List without even knowing the class. 

Actually the getTheTypeOfTheCollection (String fieldname) was 

created in order to receive the metadata information for the relationship between the 
tables. The implementation could be easier if JDO would provide this kind of metadata, 
which JDO could do since this information is provided when using the metadata file. 

For example, for the instructors class, the following is written: 

<class name="Instructors" identity-type="application"> 
<field name="id" primary-key="true"/> 

<field name="lname" > 

<extension vendor-name="libelis" 
key="sql-index" 
value="unique"/> 

</field> 


<field name="students" > 

<collection element-type="Students"> 
</collection> 

</field> 

<field name="aircrafts" > 

<collection element-type="Aircraft"/> 
</field> 

</class> 


63 





Note that the field with name students is explicitly declared, which represents a 
Collection (to the specific example a LinkedList) that will contain objects of the Students 
class. 

However, even without the provision of the above information by JDO, the 
implementation was easy using an interface that requires the method: 
getTheTypeOfrheCollection(String fieldname) and then reflection for the invocation of 
this method. This method of programming might be one of the most powerful points that 
JDO provides. Using the interface, it was able to create methods for retrieving the value 
of the fields and for setting the value of the fields. Using reflection for the invocation of 
these methods could create very beautiful programs minimizing the amount of code 
needed. 

Thus, it used one and only one class for the representation of the data of many 
tables instead of using many different classes for each table. Also, the same parameterize 
techniques in JDBC could be used, but this is the most efficient and easiest. 

D, JDOQL 

The ability of using the advantages of java language for accessing the database is 
obvious also to JDOQL (JDO Query Language). JDOQL could be considered one of the 
advantages of JDO, used to provide access to persistent instances based on specified 
search criteria. JDOQL has been designed to accomplish the following goals: 

• Query Language neutrality. This means that the query that will actually be 
executed will be either a SQL query for a relational database, or an object 
database query such as the Object Query Language (OQL). JDOQL will 
support all these operations with the same syntax, meaning it is 
independent of the query language of the underlying datastore. 

• Optimization to a specific query language. This means that the query must 
be able to exploit datastore specific query features. 

• Accommodation of multi-tier architectures. A query must be executed 
entirely in application memory, delegated to a query engine running in a 
back-end datastore server, or executed using a combination of processing 
in the application and datastore server processes.4 

• Large set support. A query might return a massive number of instances. 
The query architecture must be able to process the results within the 
resource constrains of the execution environment. 

4 David Jordan and Craig Russell, “Java Data Objects,” p. 146. 


64 



• Compiled query support. Parsing a query may be resource intensive. In 
many applications, the parsing can be done during application 
development or deployment prior to execution. The query interface must 
allow for the compilation of queries and bind values to parameters at 
runtime for optimal execution. 

The query can be implemented in two ways. Either by the Persistent Manager or 
delegated to the database. In the second case, the query will actually be translated to the 
query language that is supported from the underlying database. In this case, the query 
might be optimized to take advantage of the particular query language implementation. 

As understood from the specifications, JDOQL is a powerful tool. Only the ability 
to write queries that can run in different underlying datastores could be a great advantage 
for JDO. 

This feature could make the application platform independent or better datastore 
independent. Thus, it is possible to change the database without needing to make any 
changes to the code. Fr example, moving from a relational database to an object-oriented 
database, and keeping the code and specifically the queries exactly the same is feasible. 

However, this ability is not without cost. JDOQL queries are very slow as 
opposed to those executed by JDBC as seen in the chapter regarding the disadvantages of 
JDO. Moreover, JDOQL, at least in this first edition, (JDO 1.0) does not support all type 
of queries. GROUP BY queries, for example, are absent. 

Thus, the advantage is a real advantage as far as the current JDOQL abilities are 
enough for the development of a specific application. If more query features are needed, 
then using a native language such as a pure SQL, for example, for a relational database, is 
required, which actually becomes a disadvantage of JDO. 

Otherwise, the queries using JDOQL are very easy to implement if their syntax is 
understood, which is not difficult part,. The development of the queries in the Training- 
Squadron application was one of the easiest parts of the project. 

The implementation of the queries is very uncomplicated and easy as is the 
parameterization of the queries. An example of a query found in the application is 
provided below: 


65 



PersistenceManager pm=.. 

Extent extent=pm.getExtent(Flights.class, true) ; 

Query query=pm.newQuery(extent) ; 

Collection result=(Collection) query.execute(); 
query.close(result) ; 

It is possible to execute the same query without using the Extent interface as 

follows 


Query query=pm.newQuery(Flights.class ) ; 

Thus, it is easy to use a parameter for the query. If an object instance of a class 
exists, it is possible to execute the following: 

Qbject myQbject= ... 

Query query=pm.newQuery( myQbject.getClass() ); 

Thus, the result set of an object is achieved with the data instances stored in a 
datastore, even without knowing the type of object, such as if it is an Instructors instance 
or a Students instance for example. 

Therefore, a strong and sort code is possible that could be easier to manage and 
could cover many different cases. All the advantages of an object oriented programming 
are available even if working in a relational DBMS. 

The same techniques can be applied to more complex queries. For example, the 
following query uses a fdter: 

Extent extent=pm.getExtent(Flights.class,true); 

String filter="date==d && squadron==squad"; 

Query query=pm.newQuery(extent,filter); 


66 



query.declareImports("import java.util.Date"); 

query.declareParameters("Date d. Squadron squad"); 

Collection result=(Collection) query.execute(d, squad) ; 

query.close(result) ; 

It is possible to have a method and simply pass a parameter as a string declaring 
the filter and the objects representing the values of that string, such as an array of objects 
since there can be many parameters to the filter string. 

What is impressive, however, is the manner in which the queries can access fields 
of classes that are fields in the current class: 

Extent extent=pm.getExtent(Flights.class, true) ; 

String filter="exercise.categories==cat"; 

Query query=pm.newQuery(extent,filter); 

query.declareParameters("Categories cat") ; 

Collection result=(Collection) query.execute(cat); 

Here, exercise is a field in Flights class. However, Exercise is a class in itself, 
meaning that exercise instances are represented in a different data table. 

The Exercise class has a field named category. The value of the field can be taken 
from the Flight class using the dot (.) operator although Flight and Category, which is the 
class of the category field of the Exercise class, has no direct relation. 

Thus, the: 


exercise.categories==cat 

returns the category class of the exercise which is installed in the Flight class. With just 
a simple line, access to three tables is possible. In the application, every student belongs 
to a series and must fly the program that is included in that series. Series includes 


67 



different Studio. Studio includes different Cutegories which, in turn, include the 
Exercises that the Student must fly. For example, it is possible to take the Series that the 
exercise is a part of simply by doing the following in JDOQL: 

exercise.categories.stadio.series 


where: 


exercise.cutegories returns the Categories class 
cutegories.studio returns the Stadio class 
und studio.series returns the Series class 

This simple line could provide data or filter the data using a command 
exercise.cutegories.studio.series==seriesl// seriesl an object of Series class 

and accessing five tables simultaneously. The Flights table is included. 

Trying to do a similar action using pure SQL commands, of course, will be far 
more difficult, and result in longer code lines, which is the great advantage of working 
with relational databases but using an object-oriented approach. 

It must be noted that the above implementation of the queries actually violates the 
security of the classes. Even if the field cutegories in Exercise class is declared private, or 
the studio field in Cutegories class is declared private, or the series field in Studio class is 
declared private, as they actually are,, the code violates the privacy and accesses the 
value of those fields. 

Additional advantages and derivatives from JDOQL is not having to know a 
second query language, SQL. Linally, since JDOQL works with many databases, it is 
thus understandable that it is not necessary to know the specifications of the underlying 
database. 


68 



VI. CONCLUSION 


This thesis concludes by summarizing the advantages and disadvantages of JDO 
by beginning with the advantages; 

A. ADVANTAGES 

JDO provides transparent persistence of Java object models in transactional 
databases. The user can map the java classes to the data of the underlying datastore. Thus, 
the user works with the object-oriented model even if the application manages data from 
tables in a relational data model. The handling of objects during the development of an 
application for database management is far easier than the usual method used and 
provides many advantages for the implementation. 

The automate persistent or persistent by reachability is also a very flexible method 
for handling a database. JDO provides a means so that the objects become persistent even 
without declaring them as persistent, which happens when the objects is referenced by a 
persistent object. Thus, a code will also make the Students s persistent because it is 
referenced by a persistent object flight f. 


Students s = new Students(..); 

Flights f=new Flights(s,.); 

PersistentManager pm.makePersistent(f); 


Thus, the code is minimized and is more efficient for avoiding error prone 
procedures. 

JDOQL also provides flexibility with the underlying database. This means that 
the query that actually will be executed will be either a SQL query for a relational 
database, or an object database query such as the Object Query Language (OQL). 
JDOQL will support all these operations with the same syntax, even if the underlying 
datastore can be queried using SQL or OQL. It is independent of the query language of 
the underlying datastore. 


69 


Additionally JDOQL can be optimized to a specific query language and can 
support large datasets. Moreover, JDOQL can be easily parsed. Using parameters ean 
maintain the same eode for the execution of a large set of query options. 

As a result, there is no need for knowing a separate query language. JDBC, for 
example, assumes that the programmer knows SQL and can write queries in order to 
aceess the data of a relational DBMS, which according to specifications, is not a 
necessity in JDO. The user ean access a database using only one language: Java. 
However, many aspects in queries have not yet been implemented in the current JDO 
edition. 

This implies that the programmer does not need to know the peculiarities of the 
underlying datastore. The programmer writes the codes according to the JDO 
speeification and the eode is able to run no matter what the underlying database. It is only 
necessary to change the drivers to the Factory. The result is less code and less time to 
implement the code. JDO, however, also has a number of disadvantages, some of whieh 
are strong enough to negate its advantages. 

B, DISADVANTAGES 

Creating a many to many relationship is extremely difficult. Even if JDO 
provides a solution, it is not good enough sinee the implementation requires four tables 
instead of three for this kind of relationship. Moreover, this solution of four tables 
requires additional code for informing all the tables and for verifying the eorrectness of 
the insertion of new records. This creates additional problems also concerning the 
performance of JDO. Aceessing four tables instead of three will require more time and 
JDO is already behind in terms of quickness of returned results. 

Even if some vendors can support a managed relationship, whieh might enable the 
better representation of a many to many relationship, this is vendor specific and not a 
general JDO characteristic. Thus, the eode eould not be independent of the vendor in this 
case, whieh again is a disadvantage. 

Also, another important aspect is that JDO requires primitive types to be part of a 
relationship. This goes against the philosophy of object-oriented programming. 


70 



Additionally, JDOQL does not support all types of queries. GROUP BY queries, 
for example, are absent from JDOQL specification. Either it is necessary to use direct 
SQL commands using the JDBC interface for a relational database or accept the low 
performance of JDO providing group results via iteration through a select result set. In 
both cases, the disadvantages fo JDO are still encountered. In the former, the 
specification that states there is no need for other language since SQL is used is simply 
discarded, and in the latter, the very low speed, which can be disturbing in a large dataset, 
must be accepted. 

The speed is not good even for simple SELECT clause queries. The retrieveAll() 
operation, when used, provides the double speed but lags again far behind JDBC and 
could be a problem for large datasets since JDOQE supports large datasets. 

Eurthermore, an important problem is that JDO does not support all types of data 
structures. There are cases where JDO supports some data structures for specific 
operations while not supporting other data structures for the same operations. 
EinkedEists, for example, are not supported for a key-inverse mapping. Additionally, no 
central specification exists of what will or will not be supported. Thus, a data structure 
for an operation can be used and the situation encountered in which another vendor does 
not support this data structure for the same specific operation. Then, the compatibility, 
even binary compatibility, of the code among vendors disappears, and the 
implementation would become vendor specific. 

Another problem is the use of a XML file for the metadata description and for the 
mapping with the underlying database. Many errors cannot be detected during the 
compilation of the code. This increases the developing time. It will be better to use a java 
interface (s) for the same purpose. 

Einally, the current JDO edition does not provide efficient metadata. This is a 
huge disadvantage because it negates the advantages of object oriented programming. 
Cases exist in which information is provided for the metadata but it is not possible to this 
information. When creating the metadata file, information is provided about the length of 
the field but it is not feasible to retrieve this information. No interface with such 
functionality exists. 


71 



For example, for the following; 


< class name ="Flights"> 

<field name="date"> 

<!-- Specify the format of the date --> 

<extension vendor-name=" 1ibe1is" 

key ="s q1-mapping" 
value="date, date-only"/> 

</field> 

</ class > 

There was no method to retrieve the information that the date field is of type date- 
only. Additionally, for the following, no method was found to retrieve the length of the 
field. This will be very important for the implementation of a form where the edit box 
that shows the value of the specific field must be of length 50. 

<field name="f ield"> 

<extension vendor-name=" 1ibe1is" 

key="sql -mapping" 
value="s bring,50"/> 


</field> 

A great problem is the absence of open source implementation. A considerable 
amount of time was spent to discover which implementation to use. Fortunately, with 
considerable help from the author’s hesis advisor, LiDO was used. However, this was one 


72 


of the very few solutions found. Again, its free source edition was under license which 
also must be renewed every six months. Additionally, LIDO has developed the next 
edition of the other money products, but this next edition has not been provided to the 
community, which is free. Also, the community edition might not continue to be updated. 
Then, how is a programmer to learn about the benefits of a product? Who will pay the 
considerable amount of money to use the JDO vendor edition when not knowing the 
benefits? In addition, how could the programmer learn of the benefits without the free 
source practice that characterize Sun products thus far? 

Moreover, Sun’s reference implementation is very poor in providing incentives 
for the use of JDO. Nonetheless, the product is very promising. Do not forget that it is 
currently the first edition available to the market. Usually, the first edition is not very 
good. The second edition might succeed in solving many of the current problems. 

However, what will be the driving factor for this evolutionary process? With all 
these vendors, the problem that comes to light is the decentralization of the effort which 
may cause a common solution to be impossible. Then, the likely outcome could be some 
very good products from strong vendors but which are vendor-specific and far from the 
general purpose of JDO. This is an undesirable solution since the very concept of JDO is 
rather interesting and has provided much thus far. 


73 



THIS PAGE INTENTIONALLY LEET BLANK 


74 



APPENDIX. 


SOURCE CODE 


A. PACKAGE COMPANY 

1. The Class: Aircraft.java 


* <p>Title; Aircraft.] ava</p> 

* <p>Description;Handles the setter and getter methods of the Aireraft table </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: os JDO 

* @author Paschalis Zilidis 

* @version 1.0 
*/ 


package company; 

import java.util.List; 
import java.io. Serializable; 

publio class Aircraft { 

private String num; 
private AircraftType type; 
private double totalHours; 


/**NO ARGUMENT CONSTRUCTOR 

*/ 

public AircraftO { 
this. totalHours = 0.0; 

} 


/**MAIN CONSTRUCTOR 

*/ 

public Aircraft(String num,AircraftType type, double totalHours) { 
this.num = num; 
this, type = type; 
this. totalHours = totalHours; 

} 


/**Retums the length of the fields. The number of the 


75 



* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the elass' fields 
*@return the length of the fields 

*/ 

publie mt[] getFieldLengths(){ 
int[] ar={ 10,20,20}; 
return ar; 

} 


/**represents a getter method. Returns the value of a field 
*m the elass 

*@param i the index of the field 
*@return the value of the field 

*/ 

publie Objeet getField(mt i){ 
switeh (i) { 

case 0: 

return num; 
case 1: 

return type; 
case 2: 

return new Double(totalHours); 

} 

return 

} 


/**represents a setter method. Sets the value of a field 
*m the class 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*/ 

public void setFieldValue(int i,Object value)} 

//here to make try catch formatException for the numbers 
switch (i) { 

case 0; 

setNum(value .to String})); 
break; 
case 1: 

setType} (AircraftType) value ); 


76 



break; 


case 3: 

setTotalHours(Double.parseDouble(value.toString())); 
break; 


} 


} 

public String getNum() { 
return num; 

} 

public void setNum(String num) { 
this.num = num; 

} 

public double getTotalHours() { 
return totalHours; 

} 

public void setTotalHours(double hours) { 
this. totalHours = hours; 

} 

public AircraftType getType() { 
return type; 

} 

public void setType(AircraftType type) { 
this, type = type; 

} 


public String toString() { 

return getNum()+” “ + getType();//”Aircraft (“ + getNum()+” “ + getType()+”)”; 

} 


} 


77 



2, The Class : AircraftType.java 

* <p>Title; AircraftType.java</p> 

* <p>Description;Handles the setter and getter methods of the AireraftType table </p> 

* <p>Copyright: Copyright (e) 2004</p> 

* Company: os JDO 

* @author Pasohalis Zilidis 

* @version 1.0 
*/ 

package company; 

import java.util.List; 
import java.io. Serializable; 

/**NO ARGUMENT CONSTRUCTOR 

public class AireraftType { 

private String type; 
private String role; 


/**MAIN CONSTRUCTOR 

*/ 

public AircraftType(Strmg type,String role) { 
this, type = type; 
this.role = role; 


} 


public String getType() { 
return type; 

} 

public void setType(String type) { 
this, type = type; 

} 

public String getRole() { 
return role; 


78 



} 

public void setRole(String role) { 
this.role = role; 

} 


publie String toString() { 

return “AireraftType (“ + getType() + 

} 


} 


3. The Class: BaseCategory.java 


BaseCategory 

* <p>Title: BaseCategory.java</p> 

* <p>Desoription:Handles the setter and getter methods of the BaseCategory table </p> 

* <p>Copyright: Copyright (e) 2004</p> 

* Company: os JDO 

* @author Pasohalis Zilidis 

* @version 1.0 
*/ 

package oompany; 

//import java.util.List; 

//import java.util.LinkedList; 
import java.io. Serializable; 

publie olass BaseCategory { 
private String id; 
private String description; 


/**NO ARGUMENT CONSTRUCTOR 

*/ 


public BaseCategoryO { 

} 


79 



/**MAIN CONSTRUCTOR 

*! 

public BaseCategory(String num,String type) { 
this.id = num; 
this.description = type; 


} 


/**Retums the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the elass' fields 
*@return the length of the fields 

*/ 

public int[] getFieldLengths(){ 
int[] ar={ 10,20}; 
return ar; 

} 


/**represents a getter method. Returns the value of a field 
*in the class 

*@param i the index of the field 
*@return the value of the field 

*! 

publie Objeet getField(int i){ 
switch (i) { 

case 0: 

return id; 
case 1: 

return description; 

} 

return 

} 


/**represents a setter method. Sets the value of a field 
*in the elass 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 


80 



*/ 

public void setFieIdVaIue(int i,Object value){ 
switch (i) { 

case 0; 

setId(vaIue.toString()); 
break; 
ease 1: 

setDeseription(value.toString()); 

break; 

} 

} 


publie String getld() { 
return id; 

} 

publie void setId(String num) { 
this.id = num; 

} 

publie String getDescription() { 
return deseription; 

} 

publie void setDesoription(String desc) { 
this.deseription = dese; 

} 


public String toString() { 

return getld()+” “+getDeseription(); 

} 


} 


81 



4. 


The Class: BaseStadio.java 


BaseStadio 

* <p>Title: BaseStadio.java</p> 

* <p>Description;Handles the setter and getter methods of the BaseStadio table </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: os JDO 

* @author Pasohalis Zilidis 

* @version 1.0 
*/ 

paokage oompany; 

//import java.util.List; 

//import java.util.LinkedList; 
import java.io. Serializable; 

publio class BaseStadio { 
private String id; 
private String description; 


/**NO ARGUMENT CONSTRUCTOR 

*/ 

public BaseStadioO { 

} 

/**MAIN CONSTRUCTOR 

*/ 

public BaseStadio(String num,String type) { 
this.id = num; 
this.description = type; 


} 


/**Retums the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the class' fields 
*@return the length of the fields 

*/ 

public int[] getFieldLengths(){ 

82 



int[] ar={ 10,20}; 
return ar; 

} 


/**represents a getter method. Returns the value of a field 
*in the class 

*@param i the index of the field 
*@return the value of the field 

*! 

public Object getField(int i){ 
switch (i) { 

case 0: 

return id; 
case 1: 

return description; 

} 

return 

} 


/**represents a getter method. Returns the value of a field 
*in the class 

*@param fieldName the name of the field 
*@return the value of the field 

*/ 

public Object getFieldByName(String fieldName)} 
if (fieldName.equals(“id”)) 
return id; 

else if (fieldName.equals( “description”)) 
return description; 

return null; 

} 


/**represents a setter method. Sets the value of a field 
*in the class 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 


83 



*/ 

public void setFieIdVaIue(int i,Object value){ 
switch (i) { 

case 0; 

setId(vaIue.toString()); 
break; 
ease 1: 

setDeseription(value.toString()); 

break; 

} 

} 


publie String getld() { 
return id; 

} 

publie void setId(String num) { 
this.id = num; 

} 

publie String getDescription() { 
return deseription; 

} 

publie void setDesoription(String desc) { 
this.deseription = dese; 

} 


public String toString() { 

return getld()+” “+getDeseription(); 

} 


} 


84 



5. 


The Class: Categories.java 


Categories 

* <p>Title: Categories.java</p> 

* <p>Deseription;Handles the setter and getter methods of the Categories table </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: cs JDO 

* @author Pasehalis Zilidis 

* @version 1.0 
*/ 

package company; 

import j avax. swing. *; 
import java.util.LinkedList; 
import java.io. Serializable; 

public class Categories { 
private Series series; 
private Stadio stadio; 

private BaseCategory catid; 
private String description; 
private LinkedList exercise; 

private String seriesid; 
private String stadioid; 
private String id; 


/**NO ARGUMENT CONSTRUCTOR 

*/ 

public CategoriesO { 
seriesid=“mall”; 
stadioid=“mal2”; 

} 


/**MAIN CONSTRUCTOR 

*/ 

public Categories(Series series, String num,String type) { 
this.series = series; 
this.id = num; 


85 



this.description = type; 


} 

//I must to delete this method . JDO must provides the metadata for this 
public Class getTheTypeOfrheCollection(String collectionName){ 
if (collectionName.equals(“exercise”)) 
return Exercise.class; 

return null; 

} 


/**Retums the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the class' fields 
*@return the length of the fields 

*! 

public int[] getFieldLengths(){ 

int[] ar={10,20,20,15,15,10,10,10}; 
return ar; 

} 


/**represents a getter method. Returns the value of a field 
*in the class 

*@param i the index of the field 
*@return the value of the field 

*/ 

public Object getField(int i){ 
switch (i) { 

case 0: 

return series; 
case 1: 

return stadio; 

case 2: 

return catid; 
case 3: 

return description; 
case 4: 

return exercise; 


86 



case 5: 

return seriesid; 
case 6: 

return stadioid; 
case 7: 
return id; 

} 

return 

} 


//to handle the eollections 

/**Represents a setter method for the collection fields 
*we can add or delete a value from a colleetion field 
* according to whether a flag is true of false 
*@param name the name of the eollection field 
*@param value the value 

*@param flag the flag when it is true we add otherwise we delete 

*/ 

publie void setFieldByName(String name,Objeot value,boolean flag){ 
if(name.equals(“exereise”) ){ 

if(fiag) addExereise((Exercise) value); 
else deleteExercise((Exercise) value); 

} 


} 


/**represents a setter method. Sets the value of a field 
*in the class 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*/ 

publie void setEieldValue(int i,Objeot value)) 
switch (i) { 

case 0; 

setSeries((Series) value); 
break; 
case 1: 

setStadio((Stadio) value); 
break; 


87 



case 2: 

setCatId((BaseCategory) value); 
break; 
case 3: 

setDescription(value.toString()); 
break; 
case 4: 

// 

break; 

} 

} 

publie Series getSeries() { 
return series; 

} 

public void setSeries(Series ser) { 
if (ser!=null){ 

this.seriesid=ser.getld(); 

this.series= ser; 

} 

} 

public Stadio getStadio() { 
return stadio; 

} 

publie void setStadio(Stadio stad) { 
this.stadio=stad; 
if (stad!=null) 

stadioid=stad.getId(); 


} 

publie BaseCategory getCatId() { 
return catid; 

} 

publie void setCatId(BaseCategory oat) { 
this.catid = cat; 
if(cat!=null) 

this.id= cat.getIdO; 

} 

public String getld() { 
return id; 


88 



} 

public void setId(String num) { 
this.id = num; 

} 

public String getDescription() { 
return description; 

} 

public void setDescription(String desc) { 
this.description = desc; 

} 

public LinkedList getExercise() { 
return exercise; 

} 

publie void addExeroise(Exeroise iexereise) { 
if(exeroise==null) 

exereise = new EinkedListQ; 
exereise.add(iexereise); 

} 

publie void deleteExeroise(Exeroise iExereise) { 
if(exeroise! =null) 

exereise.remove(iExercise); 

} 


publie String toString() { 

if (series !=null && stadio!=null) 
return getld(); 
else 

return “(Series null stadio null )”+” “+getld() +” poly malakas—>“+seriesid; 


} 


89 



6 . 


The Class: Exercise,]ava 


Exercise 

* <p>Title: Exercise.]ava</p> 

* <p>Description;Handles the setter and getter methods of the Exercise table </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: cs JDO 

* @author Paschalis Zilidis 

* @version 1.0 
*/ 

package company; 

//import java.util.Eist; 
import java.io. Serializable; 

public class Exercise { 

private Series series; 

private Stadio stadio; 
private Categories categories; 
private String id; 

private String description; 

private String seriesid; 
private String stadioid; 
private String categoriesid; 

/**NO ARGUMENT CONSTRUCTOR 

*/ 

public ExerciseO { 

} 

/**MAIN CONSTRUCTOR 

*/ 

public Exercise(Stadio stadio,String num,String type) { 

this.id = num; 

this.description = type; 

this.stadio= stadio; 

} 


90 



/**Retums the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the elass' fields 
*@return the length of the fields 

*! 

publie mt[] getFieldLengths(){ 
int[] ar={10,20,20,15,15,12,15,10}; 
return ar; 

} 


/* misrepresents a getter method. Returns the value of a field 
*m the elass 

*@param i the index of the field 
*@return the value of the field 

*/ 

publie Objeet getField(mt i){ 
switeh (i) { 

ease 0: 

return series; 
ease 1: 

return stadio; 
ease 2: 

return eategories; 

ease 3: 

return id; 
ease 4: 

return deseription; 
ease 5: 

return seriesid; 
ease 6: 

return stadioid; 
ease 7: 

return eategoriesid; 

} 

return 


91 



} 


/**represents a setter method. Sets the value of a field 
*in the elass 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*/ 

public void setFieldValue(int i,Object value){ 
switch (i) { 

case 0: 

setSeries((Series) value); 
break; 
case 1: 

setStadio((Stadio) value); 
break; 
case 2: 

setC ategories((C ategories) value); 
break; 
case 3: 

setId(value.toString()); 
break; 
case 4: 

setDescription(value.toString()); 

break; 

} 

} 

public Series getSeries() { 
return series; 

} 

public void setSeries(Series ser) { 
this.series= ser; 
if(ser!=null) 

this.seriesid=ser.getld(); 

} 

public Stadio getStadio() { 
return stadio; 

} 

public void setStadio(Stadio stad) { 


92 



this.stadio = stad; 
if(stad!=null) 

this.stadioid=stad.getId(); 


} 

public Categories getCategories() { 
return eategories; 

} 

public void setCategories(Categories Categoric) { 
this.categories = Categoric; 
if(Categorie! =null) 

categoriesid=Categorie.getId(); 

//since there is not referencial integrity 
//Categoric.addExercise(this); 

} 

public String getld() { 
return id; 

} 

public void setId(String num) { 
this.id = num; 

} 

public String getDescription() { 
return description; 

} 

public void setDescription(String desc) { 
this.description = desc; 

} 


public String toString() { 

return “Exercise (“ + getld() + “)”; 

} 


} 


93 



7. 


The Class: Flights.]ava 


Flights 

/** 

* <p>Title: Flights.java</p> 

* <p>Description:Handles the setter and getter methods of the Flights table </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: os JDO 

* @author Paschalis Zilidis 

* @version 1.0 
*/ 

package company; 

import java.util.List; 
import java.util.Date; 
import java.io. Serializable; 
import j avax. swing. *; 

public class Flights { 

private Squadron squadron; 
private Aircraft aircraft; 
private Instructors instructor; 
private Students student; 
private Date date; 
private double endurance; 
private Exercise exercise; 
private SpecialType specialtype; 

/**NO ARGUMENT CONSTRUCTOR 

*/ 

public Elights(){ 
this.endurance=0; 
this.date= new DateQ; 

} 


/**MAIN CONSTRUCTOR 

*/ 

public Elights(Aircraft aircraft, Instructors instructor, 
Students student. Date date) { 
this, aircraft = aircraft; 
this.instructor = instructor; 
this.student = student; 


94 



this.date = date; 
this.endurance=0; 

} 


/**Retums the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the elass' fields 
*@return the length of the fields 

*! 

publie int[] getFieldLengths(){ 

int[] ar= {10,10,20,20,35,10,10,15}; 
return ar; 

} 

publie Object getFieldByName(String fieldName) {//NoSuchFieldExceptionj 
try{ 

//Not a beautiful way however, this will have as a result JDO will assign 
//values to the private fields retrieving values from the database 
//otherwise JDO cannot understand the complexity of the following code and will 
//return null values for the fields of this specific object 
String x=““+date; 

return this.getClass().getDeclaredField(fieldName).get(this); 

} 

catch (Exception e){e.printStackTrace();} 
return “ “; 

} 


/**represents a getter method. Returns the value of a field 
*in the class 

*@param i the index of the field 
*@return the value of the field 

*! 

public Object getEield(int i){ 
switch (i) { 
case 0; 


95 



return squadron; 
case 1: 

return aircraft; 
case 2: 

return instructor; 
case 3: 

return student; 
case 4: 

return date; 
case 5: 

return new Double(endurance); 
case 6: 

return exercise; 
case 7: 

return specialtype; 

} 

return 

} 

//to handle the collections 

/* public void setFieldByName(String name,Object value,boolean flag){ 
if(name.equals(“students”) ){ 

if(flag) addStudents((Students) value); 
else deleteStudents((Students) value); 


} 


*/ 


} 


/**represents a setter method. Sets the value of a field 
*in the cass 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*! 

public void setFieldValue(int i,Object value)) 
switch (i) { 
case 0; 


96 



setSquadron((Squadron) value); 
break; 

case 1: 

setAircraft((Aircraft) value); 
break; 
case 2: 

setInstructor((Instructors) value); 
break; 
case 3: 

setStudent((Students) value); 
break; 
case 4: 

setDate((Date) value); 
break; 
case 5: 

setEndurance(Double.parseDouble(value.toString()) ); 
break; 
case 6: 

setExercise((Exercise) value); 
break; 
case 7: 

setSpecialType((SpecialType) value); 
break; 


} 


} 

public Squadron getSquadron() { 
return squadron; 

} 

public void setSquadron(Squadron squadron) { 
this.squadron=squadron; 

} 

public Aircraft getAircraft() { 
return aircraft; 

} 

public void setAircraft(Aircraft aircraft) { 
this. aircraft=aircraft; 

} 

public Instructors getInstructor() { 


97 



return instructor; 


} 

public void setInstructor(Instructors instructor) { 
this.instructor = instructor; 

} 

public Students getStudent() { 
return student; 

} 

public void setStudent(Students student) { 
this.student = student; 

} 

public double getEndurance() { 
return endurance; 

} 

public void setEndurance(double endurance) { 
this.endurance = endurance; 

} 

public Date getDate() { 
return date; 

} 

public void setDate(Date dates) { 
this.date = dates; 

} 

public Exercise getExercise() { 
return exercise; 

} 

public void setExercise(Exercise ex) { 
this.exercise = ex; 

} 

public SpecialType getSpecialTypcQ { 
return specialtype; 

} 

public void setSpecialType(SpecialType type) { 
this.specialtype = type; 

} 


98 



public String toString() { 

return “flight (“ +getAircraft()+” “ + “ “ + 
“ “+getDate()+” “+getEndurance()+”)”; 

} 


} 


8, The Class: GroundCourse.java 


GroundCourse 

* <p>Title: GroundCourse.java</p> 

* <p>Description;Handles the setter and getter methods of the GroundCourse table </p> 

* <p>Copyright: Copyright (e) 2004</p> 

* Company: os JDO 

* @author Pasohalis Zilidis 

* @version 1.0 
*/paokage oompany; 

//import java.util.*; 

//import java.util.LinkedList; 
import java.io.Serializable; 

publio olass GroundCourse implements Myinterfaoe { 

private Series series; 
private String id; 
private String desoription; 
private int hours; 
private boolean done; 


/**NO ARGUMENT CONSTRUCTOR 

*/ 

publio GroundCourse(){ 

} 

/**MAIN CONSTRUCTOR 

*/ 

publio GroundCourse(String num,String type) { 
this.id = num; 


99 



this.description = type; 


} 

//I must to delete this method . JDO must provides the metadata for this 
public Class getTheTypeOfrheCollection(String collectionName){ 

return null; 

} 


/**Returns the length of the fields. The number of the 

* elements of the array that holds the length of the fields must be 

* equal with the TOTAL number of the class' fields 
*@return the length of the fields 

*/ 

public int[] getFieldLengths(){ 
int[] ar={10,20,20,15,10}; 
return ar; 

} 


/**represents a getter method. Returns the value of a field 
*in the class 

*@param i the index of the field 
*@return the value of the field 

*/ 

public Object getField(int i){ 
switch (i) { 
case 0; 

return series; 
case 1; 

return id; 
case 2: 

return description; 
case 3: 

return new Integer(hours); 
case 4; 

return new Boolean(done); 

} 

return 


100 



} 


/**represents a getter method. Returns the value of a field 
*in the elass 

*@param fieldName the name of the field 
*@return the value of the field 

*/ 

public Object getFieldByName(Strmg fieldName) { 
return null; 

} 

//to handle the collections 

/**Represents a setter method for the collection fields 
*we can add or delete a value from a collection field 
* according to whether a flag is true of false 
*@param name the name of the collection field 
*@param value the value 

*@param flag the flag when it is true we add otherwise we delete 

*/ 

public void setFieldByName(Strmg name,Object value,boolean fiag){ 

} 


/**represents a setter method. Sets the value of a field 
*in the cass 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*! 

public void setFieldValue(mt i,Object value)) 
switch (i) { 
case 0; 

setSeries((Series) value); 
break; 
case 1; 

setld( value. toS tringO); 
break; 
case 2: 

setDescription( value. to String))); 


101 



break; 
case 3: 

setHours(Integer.parseInt(value.toString())); 
break; 
case 4; 

setDone((new Boolean(value.toString())).booleanValue() ); 
break; 

} 

} 

public Series getSeriesQ { 
return series; 

} 

public void setSeries(Series ser) { 
this.series = ser; 

} 


public String getld() { 
return id; 

} 

public void setId(String num) { 
this.id = num; 

} 

public String getDescription() { 
return description; 

} 

public void setDescription(String desc) { 
this.description = desc; 

} 

public int getHours() { 
return hours; 

} 

public void setHours(int desc) { 
this.hours = desc; 

} 

public boolean getDone() { 
return done; 

} 

public void setDone(boolean b) { 


102 



this.done=b; 


} 


public String toString() { 
return “Course (“ + getldQ + 

} 


} 


9. The Class: Instructors.]ava 


Instruetors 

* <p>Title: Instructors.java</p> 

* <p>Description;Handles tbe setter and getter methods of tbe Instructors table </p> 

* <p>Copyrigbt: Copyright (e) 2004</p> 

* Company: os JDO 

* @author Paschalis Zilidis 

* @version 1.0 
*/ 

package company; 

import java.util.List; 
import java.util.LinkedList; 
import java.io. Serializable; 

publio class Instructors { 

private String id; 
private String Iname; 
private String fname; 
private Rank rank; 
private boolean absent; 

private double totalHours; 

private int status; //permanent or temporary 
private LinkedList students; 
private Squadron squadron; 


103 



private LinkedList aircrafts; 

/**N0 ARGUMENT CONSTRUCTOR 

*/ 

public InstructorsO { 
this.id=“defaultid”; 
this.lname =“defaullname”; 
this.fname = “defaullfname”; 
this.totalHours = 0; 
this.status=10; 

// this.absent=false; 
this.students=new LinkedListQ; 


} 

/**MAIN CONSTRUCTOR 

public Instructors(String id,String Iname,String fname, double totalHours) { 
this.id=id; 
this.lname = Iname; 
this.fname = fname; 
this.totalHours = totalHours; 


} 


/** Returns the class fo the objects that a collection 

* field holds in it. 

*@param collectionName the name of the field that represents 

* a collection 

*@return the class of the object that the collection holds 

*/ 

public Class getTheTypeOfTheCollection(String collectionName) { 
if (collectionName.equals(“students”)) 
return Students.class; 

return null; 

} 

/**Retums the length of the fields. The number of the 

* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the class' fields 
*@return the length of the fields 

*/ 


104 



public int[] getFieldLengths(){ 

int[] ar={10,20,20,15,10,7,17,10,10,15}; 
return ar; 

} 


/**return the field names of the class 

*/ 

public String[] getMetaData(){ 

String[] ar= {“id”,’’fname”,”lname”,’’status”,’’totalHours”}; 
return ar; 

} 

/* misrepresents a getter method. Returns the value of a field 
*m the elass 

*@param i the index of the field 
*@return the value of the field 

*/ 

publie Objeet getField(mt i){ 
switch (i) { 

case 0: 

return id; 
case 1: 

return Iname; 
ease 2: 

return finame; 
ease 3: 

return rank; 
ease 4: 

return new Boolean(absent); 
ease 5: 

return new Double(totalHours); 
ease 6: 

return new Integer( status); 
ease 7: 

return students; 
case 8: 

return squadron; 
ease 9: 

return airerafts; 


} 


105 



return 

} 

//to handle the eolleetions 

/**Represents a setter method for the collection fields 
*we can add or delete a value from a collection field 
* according to whether a flag is true of false 
*@param name the name of the collection field 
*@param value the value 

*@param flag the flag when it is true we add otherwise we delete 

*/ 

public void setFieldByName(String name,Object value,boolean flag){ 
if(name.equals(“students”) ){ 

if(fiag) addStudents((Students) value); 
else deleteStudents((Students) value); 

} 

if(name.equals(“aircrafts”) ){ 

if(fiag) addAircrafts((Aircraft) value); 
else deleteAircrafts((Aircraft) value); 

} 


} 


/**represents a setter method. Sets the value of a field 
*in the class 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*/ 

public void setFieldValue(int i,Object value)) 
switch (i) { 

case 0: 

setId(value.toString()); 
break; 
case 1: 

setLastName( value. to String))); 
break; 
case 2: 

setF irstName( value. to String))); 
break; 
case 3: 

setRank))Rank) value); 
break; 


106 



case 4: //this will become false in case of null value 

setAbsent( (new Boolean(value.toString())).booleanValue() ); 
break; 

case 5: 

setTotalHours(Double.parseDouble(value.toString()) ); 
break; 
case 6: 

setStatus( Integer.parseInt(value.toString()) ); 
break; 
case 7: 
break; 

//setStudents((LinkedList) value); 
case 8: 

setSquadron( (Squadron) value ); 
break; 


} 


} 

public String getld() { 
return id; 

} 

public void setId(String id) { 
this.id = id; 

} 

public String getLastName() { 
return Iname; 

} 

public void setLastName(String name) { 
this.Iname = name; 

} 

public String getFirstName() { 
return fname; 

} 

public void setFirstName(String name) { 
this.fname = name; 

} 

public Rank getRank() { 
return rank; 


107 



} 

public void setRank(Rank r) { 
this.rank = r; 

} 

public double getTotalHours() { 
return totalHours; 

} 

public void setTotalHours(double hours) { 
this. totalHours = hours; 

} 

public boolean getAbsent() { 
return absent; 


} 

publie void setAbsent(boolean absent) { 
this.absent = absent; 

} 


publie int getStatus() { 
return status; 

} 

publie void setStatus(int status) { 
this.status = status; 

} 

publie LinkedList getStudents() { 
return students; 

} 

publie void setStudents(LinkedList listStudents) { 
this. students=listStudents; 

} 

publie void addStudents(Students student) { 
if(students==null) 

students=new LinkedList(); 

students.add( student); 


if( student.getInstruetors()==null) 
student.addlnstruetors(this); 


108 



else if(!student.getInstruetors().eontains(this)) 
student.addlnstructors(this); 

} 

publie void deleteStudents(Students student) { 
if(students !=null) { 

students.remove(student); 

if( student.getInstruetorsO !=null) 

if(!student.getInstruetors().contains(this)) 

student.deletelnstructors(this); 


} 


} 


public Squadron getSquadron() { 
return squadron; 

} 

public void setSquadron(Squadron sq) { 
this.squadron=sq; 


} 

public void addAircrafts(Aircraft student) { 
aircrafts. add( student); 


} 

public void deleteAircrafts(Aircraft student) { 
aircrafts. remove (student); 

} 


public String toString() { 

return getld()+” “+getLastName();//”Instructor (“ + getLastName() + “)”; 

} 


} 


109 



10, The Interface: Myinterface.java 


Myinterface 

* <p>Title: Mylnterface.java</p> 

* <p>Description;Dtermines an interface with methods that we need 

* to use for the implementation of the forms that display data for the tables<p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: cs JDO 

* @author Paschalis Zilidis 

* @version 1.0 
*/ 

package company; 


public interface Myinterface { 


/**Retums the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the class' fields 
*@return the length of the fields 

*/ 

public int[] getFieldLengthsQ; 


/**represents a getter method. Returns the value of a field 
*in the class 

*@param fieldName the name of the field 
*@return the value of the field 

*/ 

public Object getFieldByName(String fieldName); 


/**represents a getter method. Returns the value of a field 
*in the class 

*@param i the index of the field 
*@return the value of the field 

*/ 

public Object getField(int i); 


//to handle the collections 

/**Represents a setter method for the collection fields 
*we can add or delete a value from a collection field 
* according to whether a flag is true of false 


no 



*@param name the name of the eollection field 
*@param value the value 

*@param flag the flag when it is true we add otherwise we delete 

*/ 

public void setFieldByName(String name,Object value,boolean flag); 


/**represents a setter method. Sets the value of a field 
*m the class 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*/ 

public void setFieldValue(mt i,Object value); 


/** Returns the class of the objects that a collection 

* field holds in it. 

*@param collectionName the name of the field that represents 

* a collection 

*@return the class of the object that the collection holds 

*/ 

public Class getTheTypeOfrheCollection(Strmg collectionName); 


} 


11, The Class: Rank.java 


Rank 

/*=!= 

* <p>Title: Rank.java</p> 

* <p>Description:Handles the setter and getter methods of the Rank table </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: cs JDO 

* @author Paschalis Zilidis 

* @version 1.0 
*/ 

package company; 

//import java.util.List; 
import java.io. Serializable; 

public class Rank { 


111 



private String id; 
private String deseription; 
// private Stadio stadio; 
//private List exereise; 


/**MAIN CONSTRUCTOR 

*/ 

pub lie Rank(String num, String type) { 

this.id = num; 

this.deseription = type; 


} 

/**Retums the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the elass' fields 
*@return the length of the fields 

*/ 

publie int[] getFieldLengths(){ 
int[] ar={ 10,20}; 
return ar; 

} 

/**represents a getter method. Returns the value of a field 
*in the elass 

*@param i the index of the field 
*@return the value of the field 

*/ 

publie Objeet getField(int i){ 
switeh (i) { 

case 0: 

return id; 
case 1: 

return description; 

} 

return 

} 


/**represents a setter method. Sets the value of a field 


112 



*in the cass 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*/ 

publie void setFieldValue(int i,Objeot value) { 
switch (i) { 

case 0: 

setId(value.toString()); 
break; 
case 1: 

setDescription(value.toString()); 

break; 

} 


} 


public String getld() { 
return id; 

} 

public void setId(String num) { 
this.id = num; 

} 

public String getDescription() { 
return description; 

} 

public void setDescription(String desc) { 
this.description = desc; 

} 


public String toString() { 

return “Rank (“ + getDescription() + “)”; 

} 


} 


113 



12 . 


The Class: Schedule.]ava 


Schedule 

* <p>Title: Sehedule.java</p> 

* <p>Deseription:Handles the setter and getter methods of the Sehedule table </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: cs JDO 

* @author Pasehalis Zilidis 

* @version 1.0 
*/ 

paekage company; 

import j avax. swing. *; 
import java.util.LinkedList; 
import java.io. Serializable; 

publie class Schedule implements Myinterfaee { 
private Squadron squadron; 
private int month; 
private int year; 

private double hours; 
private int totalflights; 

private String squadronid; 

/**NO ARGUMENT CONSTRUCTOR 

public ScheduleQ { 
month=0; 
year=0; 
hours=0; 
totalflights=0; 

} 


//I must to delete this method. JDO must provides the metadata for this 
/** Returns the class of the objects that a collection 

* field holds in it. 

*@param colleetionName the name of the field that represents 

* a collection 

*@return the class of the object that the eolleetion holds 


114 



*/ 

public Class getTheTypeOfrheCollection(String collectionName){ 
return null; 

} 


/**Retums the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the elass' fields 
*@return the length of the fields 

*/ 

public mt[] getFieldLengths(){ 
int[] ar={10,20,20,15,15,10}; 
return ar; 

} 


/* misrepresents a getter method. Returns the value of a field 
*m the elass 

*@param fieldName the name of the field 
*@return the value of the field 

*/ 

publie Objeet getFieldByName(Strmg i){ 
return null; 

} 


/* misrepresents a getter method. Returns the value of a field 
*m the elass 

*@param i the index of the field 
*@return the value of the field 

*/ 

publie Objeet getField(mt i){ 
switch (i) { 

case 0: 

return squadron; 
case 1: 

return new Integer(month); 
case 2: 

return new Integer(year); 
ease 3: 

return new Double(hours); 


115 



case 4: 

return new Integer(totalflights); 
case 5: 

return squadronid; 


} 

return 

} 


//to handle the colleetions 

/**Represents a setter method for the collection fields 
*we can add or delete a value from a colleetion field 
* aceording to whether a flag is true of false 
*@param name the name of the eolleetion field 
*@param value the value 

*@param flag the flag when it is true we add otherwise we delete 

*/ 

public void setFieldByName(String name,Object value,boolean flag){ 

} 


/**represents a setter method. Sets the value of a field 
*in the class 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*/ 

public void setFieldValue(int i,Object value) { 
switeh (i) { 

case 0: 

setSquadron((Squadron) value); 
break; 
case 1: 

setMonth(Integer.parseInt(value.toString()) ); 
break; 

case 2: 

setYear(Integer.parseInt(value.toString())); 
break; 
case 3: 

setHours(Double.parseDouble(value.toString())); 
break; 
case 4: 

setTotalFlights(Integer.parseInt(value.toString()) ); 


116 



break; 


} 

} 

public Squadron getSquadron() { 
return squadron; 

} 

public void setSquadron(Squadron sq) { 
if (sq!=null){ 

this. squadronid=sq. gets quadron(); 
this.squadron= sq; 

} 

} 

public int getMonth() { 
return month; 

} 

public void setMonth(int m) { 
this.month=m; 

} 

public int getYear() { 
return year; 

} 

public void setYear(int num) { 
this.year= num; 

} 

public double getHours() { 
return hours; 

} 

public void setHours(double hour) { 
this.hours = hour; 

} 

public int getTotalFlightsQ { 
return totalflights; 

} 

public void setTotalFlights(int num) { 
this.totalflights= num; 

} 


117 



public String toString() { 

return getSquadron() +” “+getMontii()+” / “+getYear(); 

} 


} 


13. The Class: Series.java 


Series 

* <p>Title: Series.]ava</p> 

* <p>Description:HandIes the setter and getter methods of the Series table </p> 

* <p>Copyright: Copyright (e) 2004</p> 

* Company: os JDO 

* @author Pasohalis Zilidis 

* @version 1.0 
*/ 

paokage oompany; 

import java.util.*; 
import java.util.LinkedList; 
import j ava. io. Serializable; 

publio olass Series { 

private String id; 
private String desoription; 
private Colleotion stadio; 
private LinkedList students; 
private Collection groundcourse; 


/**NO ARGUMENT CONSTRUCTOR 

*/ 

public Series(){ 

} 


118 



/**MAIN CONSTRUCTOR 

*/ 

public Series(String num,String type) { 
this.id = num; 
this.description = type; 


} 


//I must to delete this method . JDO must provides the metadata for this 
/** Returns the class of the objects that a collection 

* field holds in it. 

*@param collectionName the name of the field that represents 

* a collection 

*@retum the class of the object that the collection holds 

*/ 

public Class getTheTypeOfTheCollection(String collectionName)) 
if (collectionName.equals(“students”)) 
return Students.class; 
else if (collectionName.equals(“stadio”)) 
return Stadio.class; 

else if (collectionName.equals(“groundcourse”)) 
return GroundCourse.class; 

return null; 

} 


/*=[= Returns the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the class' fields 
*@retum the length of the fields 

*! 

public int[] getFieldLengths(){ 
int[] ar={10,20,20,15,10}; 
return ar; 

} 


/**represents a getter method. Returns the value of a field 
*in the class 

*@param i the index of the field 


119 



*@retum the value of the field 

*/ 

public Object getField(int i){ 
switch (i) { 

case 0; 

return id; 
case 1: 

return description; 
case 2: 

return stadio; 
case 3: 

return students; 
case 4: 

return groundcourse; 

} 

return 

} 


//to handle the collections 

/**Represents a setter method for the collection fields 
*we can add or delete a value from a collection field 
* according to whether a flag is true of false 
*@param name the name of the collection field 
*@param value the value 

*@param flag the flag when it is true we add otherwise we delete 

*/ 

public void setFieldByName(Strmg name,Object value,boolean fiag){ 

if(name.equals(“students”) ){ 

if(fiag) addStudents((Students) value); 
else deleteStudents((Students) value); 

} 

if(name.equals(“stadio”) ){ 

if(fiag) addStadio((Stadio) value); 
else deleteStadio((Stadio) value); 

} 

if(name.equals(“groundcourse”) ) { 

if(fiag) addGroundCourse((GroundCourse) value); 
else deleteGroundCourse((GroundCourse) value); 

} 


} 


120 



/**represents a setter method. Sets the value of a field 
*in the class 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@retum the value of the field 

*/ 

public void setFieldValue(int i,Object value) { 
switch (i) { 

case 0: 

setId(value.toString()); 
break; 
case 1; 

setDescription(value.toString()); 
break; 
case 2: 

// 

break; 
case 3: 

// 

break; 

} 

} 

public String getld() { 
return id; 

} 

public void setId(String num) { 
this.id = num; 

} 

public String getDescription() { 
return description; 

} 

public void setDescription(String desc) { 
this.description = desc; 

} 

public Collection getStadioQ { 
return stadio; 

} 

public void addStadio(Stadio stadion) { 
if(stadio==null) 

stadio = new LinkedList(); 


121 



stadio. add(stadion); 


} 

public void deleteStadio(Stadio stadion) { 
if(stadio!=null) 

stadio.remove(stadion); 

} 


public LinkedList getStudents() { 
return students; 

} 

publie void setStudents(LinkedList listStudents) { 
this.students=listStudents; 

} 

publie void addStudents(Students student) { 
if(students==null) 

students=new LinkedList(); 

students. add( student); 

} 

publie void deleteStudents(Students student) { 
students.remove(student); 

} 

publie Collection getGroundCourse() { 
return groundeourse; 

} 

publie void addGroundCourse(GroundCourse groundcours) { 
if(groundoourse==null) 

groundeourse = new LinkedList(); 
groundeourse.add(groundeours); 

} 

publie void deleteGroundCourse(GroundCourse groundeours) { 
if(groundoourse!=null) 

groundoourse.remove(groundcours); 

} 


publie String toString() { 

return “Series (“ + getld() + “)”; 


122 



} 


} 


14, The Class: SpecialType.java 

SpecialType 

* <p>Title: SpecialType.java</p> 

* <p>Description;Handles the setter and getter methods of the SpecialType table </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: cs JDO 

* @author Paschalis Zilidis 

* @version 1.0 
*/ 

package company; 

//import java.util.List; 
import java.io. Serializable; 

public class SpecialType { 

private String id; 

private String description; 

private String color; 


/**NO ARGUMENT CONSTRUCTOR 

*/ 

public SpecialTypeO { 

} 


/**MAIN CONSTRUCTOR 

public SpecialType(String id) { 


123 



this.id = id; 


} 


/**Retums the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the elass' fields 
*@return the length of the fields 

*/ 

publie int[] getFieldLengths(){ 
int[] ar={ 10,20,10}; 
return ar; 

} 


/* misrepresents a getter method. Returns the value of a field 
*in the elass 

*@param i the index of the field 
*@return the value of the field 

*/ 

publie Objeet getField(int i){ 
switeh (i) { 

case 0: 

return id; 
case 1: 

return description; 
case 2: 

return color; 


} 

return 

} 


/* misrepresents a setter method. Sets the value of a field 
*in the class 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*! 

public void setFieldValue(int i,Object value)} 
switch (i) { 


124 



case 0: 

setId(value.toString()); 
break; 
case 2: 

setDescription(value.toString()); 
break; 
case 3: 

setColor(value.toString()); 

break; 


} 


} 


publie String getld() { 
return id; 

} 

publie void setId(String num) { 
this.id = num; 

} 

publie String getDescription() { 
return deseription; 

} 

publie void setDescription(String desc) { 
this.description = desc; 

} 

public String getColor() { 
return color; 

} 

public void setColor(String color) { 
this.color = color; 

} 


public String toString() { 
return getld(); 

} 


125 



} 


15, The Class: Squadron.]ava 


Squadron 

/*=!= 

* <p>Title: Squadron.]ava</p> 

* <p>Description:Handles the setter and getter methods of the Squadron table </p> 

* <p>Copyright: Copyright (e) 2004</p> 

* Company: cs JDO 

* @author Paschalis Zilidis 

* @version 1.0 
*/ 

package company; 

import java.util.*; 
import java.io. Serializable; 

public class Squadron implements Myinterface { 

private String squadron; 
private String description; 
private Collection schedule; 

//private List exercise; 


/**NO ARGUMENT CONSTRUCTOR 

*/ 

public SquadronO { 

} 


/**MAIN CONSTRUCTOR 

*! 

public Squadron(String num,String type) { 

this.squadron = num; 
this.description = type; 


} 


126 



/**Retums the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the class' fields 
*@return the length of the fields 

*/ 

public mt[] getFieldLengths(){ 
int[] ar={ 10,20,30}; 
return ar; 

} 


/**represents a getter method. Returns the value of a field 
*m the class 

*@param i the index of the field 
*@return the value of the field 

*/ 

public Object getField(mt i){ 
switch (i) { 

case 0: 

return squadron; 
case 1: 

return description; 
case 2: 

return schedule; 

} 

return 

} 


/**represents a getter method. Returns the value of a field 
*m the class 

*@param fieldName the name of the field 
*@return the value of the field 

*/ 

public Object getFieldByName(Strmg fieldName) {//NoSuchFieldException} 
try{ 

//Not a beautiful way however, this will have as a result JDO will assign 
//values to the private fields retrieving values from the database 
//otherwise JDO cannot understand the complexity of the following code and will 
//return null values for the fields of this specific object 
String x=““+squadron; 


127 



return this .getClass() .getDeclaredField(fieldName). get(this); 

} 

catch (Exception e){e.printStackTrace();} 
return “ 


} 


//I must to delete this method . JDO must provides the metadata for this 
/** Returns the class of the objects that a collection 

* field holds in it. 

*@param collectionName the name of the field that represents 

* a collection 

*@return the class of the object that the collection holds 

*/ 

public Class getTheTypeOfrheCollection(String collectionName) { 
if (collectionName.equals(“schedule”)) 
return Schedule.class; 

return null; 

} 


//to handle the collections 

/**Represents a setter method for the collection fields 
*we can add or delete a value from a collection field 
* according to whether a flag is true of false 
*@param name the name of the collection field 
*@param value the value 

*@param flag the flag when it is true we add otherwise we delete 

*/ 

public void setFieldByName(String name,Object value,boolean fiag){ 
if(name.equals(“schedule”) ){ 

if(flag) addSchedule((Schedule) value); 
else deleteSchedule((Schedule) value); 

} 


} 


/**represents a setter method. Sets the value of a field 


128 



*in the class 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*/ 

public void setFieldValue(int i,Object value){ 
switch (i) { 

case 0; 

setSquadron(value.toString()); 
break; 
case 1: 

setDescription(value.toString()); 

break; 


} 

} 

public String getSquadron() { 
return squadron; 

} 

public void setSquadron(String num) { 
this.squadron = num; 

} 

public String getDescription() { 
return description; 

} 

public void setDescription(String desc) { 
this.description = desc; 

} 


public Collection getSchedule() { 
return schedule; 

} 

public void addSchedule(Schedule schedules) { 
if(schedule==null) 

schedule=new LinkedList(); 
schedule.add(schedules); 

//instructor.addStudents(this); 

} 


129 



public void deIeteSclieduIe(SclieduIe schedules) { 
if(schedule!=null) 

sehedule.remove(sehedules); 


} 


public String toString() { 

return “Squadron (“ + getSquadron() + 

} 


} 


16, The Class: Stadio.java 


Stadio 

* <p>Title: Stadio .java</p> 

* <p>Desoription:Handles the setter and getter methods of the Stadio table </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: cs JDO 

* @author Paschalis Zilidis 

* @version 1.0 
*/ 

package eompany; 

import java.util.*; 
import java.util.LinkedList; 
import java.io. Serializable; 

publie elass Stadio { 
private Series series; 
private BaseStadio sid; 
private String description; 
private Colleetion eategories; 

private String seriesid; 
private String id; 

/**NO ARGUMENT CONSTRUCTOR 


130 



public StadioO { 

} 

/**MAIN CONSTRUCTOR 

*/ 

public Stadio(Series series, BaseStadio num,String type) { 
this.series = series; 
this.sid = num; 
this.description = type; 


} 


//I must to delete this method . JDO must provides the metadata for this 
/** Returns the class of the objects that a collection 

* field holds in it. 

*@param collectionName the name of the field that represents 

* a colleetion 

*@return the class of the object that the eollection holds 

*/ 

public Class getTheTypeOfrheCollection(String collectionName)) 
if (eollectionName.equals(“categories”)) 
return Categories.class; 

return null; 

} 


/**Retums the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the elass' fields 
*@return the length of the fields 

*/ 

publie int[] getFieldLengths(){ 
int[] ar={10,20,20,15,10,12}; 
return ar; 

} 


131 



/**represents a getter method. Returns the value of a field 
*in the elass 

*@param i the index of the field 
*@return the value of the field 

*/ 

publie Objeet getField(int i){ 
switeh (i) { 

ease 0; 

return series; 
ease 1: 

return sid; 
case 2: 

return description; 
case 3: 

return categories; 
case 4: 

return seriesid; 
case 5: 
return id; 


} 

return 

} 


//to handle the collections 

/**Represents a setter method for the collection fields 
*we can add or delete a value from a collection field 
* according to whether a flag is true of false 
*@param name the name of the collection field 
*@param value the value 

*@param flag the flag when it is true we add otherwise we delete 

*/ 

public void setFieldByName(String name,Object value,boolean fiag){ 
if(name.equals(“categories”) ) { 

if(flag) addCategories((Categories ) value); 
else deleteCategories((Categories) value); 

} 


} 


/**represents a setter method. Sets the value of a field 


132 



*in the class 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*/ 

public void setFieldValue(int i,Object value){ 
switch (i) { 

case 0; 

setSeries((Series) value); 
break; 
case 1: 

setSId((BaseStadio) value); 
break; 
case 2: 

setDescription(value.toString()); 
break; 
case 3: 

// 

break; 

} 

} 

public Series getSeries() { 
return series; 

} 

public void setSeries(Series ser) { 
this.series= ser; 
this.seriesld=ser.getld(); 

} 

public String getld() { 
return id; 

} 

public String getSeriesId() { 
return seriesid; 

} 


public void setId(String num) { 
this.id = num; 


} 


133 



public BaseStadio getSId() { 
return sid; 

} 

public void setSId(BaseStadio num) { 
this.sid = num; 
if(num!=null) 

setld(num.getld()); 


} 

public String getDescription() { 
return description; 

} 

public void setDescription(String desc) { 
this.description = desc; 

} 

public LinkedList getCategories() { 
return new LinkedList(categories); 

} 

publie void addCategories(Categories ieategories) { 
if(categories==null) 

eategories = new LinkedListQ; 
eategories.add(ieategories); 

} 

publie void deleteCategories(Categories ieategories) { 
if(categories! =null) 

eategories.remove(icategories); 

} 


publie String toString() { 

return getDeseription()+getId(); 


} 


} 


134 



17. The Class: Students,]ava 


Students 

* <p>Title: Students.]ava</p> 

* <p>Deseription; Handles the setter and getter methods of the Students table </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: cs JDO 

* @author Pasehalis Zilidis 

* @version 1.0 
*/ 

paekage company; 

import java.util.List; 
import java.util.LinkedList; 
import java.io. Serializable; 

public class Students { 

private String id; 
private String Iname; 
private String fname; 
private Rank rank; 
private boolean absent=false; 
private double totalHours; 

private int status; 

private LinkedList instructors; 

private Squadron squadron; 

private Series series; 


//private boolean isManager; 

/**NO ARGUMENT CONSTRUCTOR 

*/ 

public Students(){ 
totalHours=0.0; 

} 


135 



/**MAIN CONSTRUCTOR 

*/ 


public Students(String id, String Iname,String fname, double totalHours) { 
this.id=id; 
this.Iname = iname; 
this.fname = fname; 
this. totalHours = totalHours; 


} 


/**Retums the length of the fields. The number of the 
* elements of the array that holds the length of the fields must be 
*equal with the TOTAL number of the elass' fields 
*@return the length of the fields 

*/ 

publie int[] getFieldLengths(){ 

int[] ar= {10,20,20,15,7,17,7,10,10,10}; 
return ar; 

} 

//poly shmantrko . An den zhthsv th timh ths linkedlist to pedio ua exei null otan pav 
na to 

//diabasv tote kanei prosbash. An exv quoted to //LinkedList l=getInstructors(); pernv 
null gia 

//tous instruetors 

/**represents a getter method. Returns the value of a field 
*in the elass 

*@param fieldName the name of the field 
*@return the value of the field 

*/ 

publie Objeet getFieldByName(String fieldName) {//NoSuchFieldExeeption{ 
try{ 

//Not a beautiful way however, this will have as a result: JDO will assign 

//values to the private fields retrieving values from the database 

//otherwhise JDO eannot understand the eomplexity of the following eode and 

will 

//return null values for the fields of this speeific objeet 
String x=““+totalHours; 

//LinkedList l=getInstruetors(); 

return this .getClass() .getDeelaredField(fieldName). get(this); 

} 


136 



catch (Exception e){e.printStackTrace();} 
return “malaka”; 

} 

/** Returns the elass of the objects that a collection 

* field holds in it. 

*@param oolleetionName the name of the field that represents 

* a eolleetion 

*@return the class of the object that the eolleetion holds 

*! 

public Class getTheTypeOfrheCollection(String collectionName){ 
if (collectionName.equals(“instructors”)) 
return Instruetors.elass; 

return null; 

} 


//to handle the eolleetions 

/**Represents a setter method for the eolleetion fields 
*we ean add or delete a value from a eolleetion field 
* aeeording to whether a flag is true of false 
*@param name the name of the collection field 
*@param value the value 

*@param flag the flag when it is true we add otherwise we delete 

*/ 

publie void setFieldByName(String name,Objeot value,boolean fiag){ 
if(name.equals(“instruetors”) ){ 

if(fiag) addInstruetors((Instruetors) value); 
else deleteInstruetors((Instruetors) value); 

} 

} 

/**represents a setter method. Sets the value of a field 
*in the eass 

*@param value the value that the field will be assigned to 
*@param i the index of the field 
*@return the value of the field 

*/ 

publie void setFieldValue(int i,Objeot value)) 


137 



switch (i) { 
case 0: 

setId(value.toString()); 
break; 
ease 1: 

setLastN ame( value. to StringO); 
break; 
ease 2: 

setF irstName( value. to StringO); 
break; 
case 3: 

setRank((Rank) value ); 
break; 

case 4: //this will beeome false in case of null value 

setAbsent( (new Boolean(value.toString())).booleanValue() ); 
break; 

case 5: 

setTotalHours(Double.parseDouble(value.toString())); 
break; 
ease 6: 

setStatus( Integer.parseInt(value.toString()) ); 
break; 
ease 7: 
break; 

//setStudents((LinkedList) value); 
case 8: 

setSquadron( (Squadron) value ); 
break; 
case 9: 

setSeries( (Series) value ); 
break; 


} 


} 


/**represents a getter method. Returns the value of a field 
*in the elass 

*@param i the index of the field 
*@return the value of the field 

*/ 

publie Objeet getField(int i){ 
switeh (i) { 


138 



case 0: 

return id; 
case 1: 

return Iname; 
case 2: 

return fname; 
case 3: 

return rank; 
ease 4: 

return new Boolean(absent); 
case 5: 

return new Double(totalHours); 
case 6: 

return new Integer( status); 
case 7: 

return instructors; 
case 8: 

return squadron; 
case 9: 

return series; 

} 

return 

} 

publie String getld() { 
return id; 

} 

publie void setId(String id) { 
this.id = id; 

} 

publie String getLastName() { 
return Iname; 

} 

publie void setLastName(String name) { 
this.Iname = name; 

} 

public String getFirstName() { 
return fname; 

} 

publie void setFirstName(String name) { 


139 



this.fname = name; 

} 

public Rank getRank() { 
return rank; 

} 

public void setRank(Rank r) { 
this.rank = r; 

} 

public double getTotalHours() { 
return totalHours; 

} 

public void setTotalHours(double hours) { 
this. totalHours = hours; 

} 

public boolean getAbsent() { 
return absent; 


} 

public void setAbsent(boolean absent) { 
this.absent = absent; 

} 

public int getStatus() { 
return status; 

} 

public void setStatus(int status) { 
this.status = status; 

} 

public Squadron getSquadron() { 
return squadron; 


} 

public void setSquadron(Squadron squadron) { 
this.squadron = squadron; 

} 

public LinkedList getInstructors() { 
return instructors; 


140 



} 

public void addInstructors(Instructors instructor) { 
if(instructors==null) 

instructors=new LinkedList(); 

instructors.add(instructor); 

if(instructor.getStudents()==null) 
instructor.addStudents(this); 
else if( !instruetor.getStudents().eontains(this)) 
instructor.addStudents(this); 


} 

publie void deletelnstruotors(lnstructors instructor) { 
if(instructors !=null) { 

instructors .remove(instructor); 


} 


if(instructor. getStudents()!=null) 

if(instructor.getStudents().contains(this)) 

instructor.deleteStudents(this); 


public Series getSeries() { 
return series; 


} 

publie void setSeries(Series serie) { 
this.series = serie; 

} 


publie String toString() { 

return getld()+” “+getLastName();//”Student (“ + getLastName() +” 

“+getFirstName()+ “)”; 

} 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 


} 


141 



B, 


PACKAGE TEST 


1. The Class: InstructorsForm.java 

InstructorsForm 

* <p>Title: InstructorsForm.java</p> 

* <p>Description: Displays the data of the underlying datastore</p> 

* <p>Copyright: Copyright (e) 2004</p> 

* Company: CS JDO 

* @author Pasehalis Zilidis 

* @version 1.0 
*/ 

paekage test; 

import j avax.j do. JDOHelper; 

import javax.jdo.PersisteneeManagerFaetory; 

import j avax.j do .PersisteneeManager; 

import j avax .j do .Transaction; 

import j avax.j do. Query; 

import java.io.FileInputStream; 

import java.io.IOException; 

import java.io.InputStream; 

import javax.jdo.spi.JDOImplHelper; 

import j avax.j do .Extent; 

import company.*; 

import j avax. swing. *; 

import j avax. swing .event. *; 

import java.awt. *; 

import j ava. awt. event. *; 

import javax.swing. JComboBox; 

import java.util.*; 

import java.text.DecimalEormat; 


class InstructorsEorm extends JPanel implements ActionListener, MouseEistener, 
ItemListenerj 

/* The persistent manager Eactory 

*/ 

private static PersistenceManagerEactory pmf; 

/* The persistent manager 

*/ 

private static PersisteneeManager pm; 

142 




/* The Transaction 

*/ 

private static Transaction tx; 

/* The query variable 
private static Query q; 

/* The source of the data for the form 

*/ 

private Collection result; 

/* The iterator that we will use to iterate through the data 
Listiterator iterator; 

/* Variable that holds every time the current record when we 

* iterate through the instances of the result Collection. 

*/ 

Object currentRecord; 

/*represent the instance of the object that we are going to display 

* its data to the form. If for example we are going to display records 
*from the students table this will be an instance of the Students class 

*/ 

Object mainFormObject; 

/* Use for entering data to a subform 

*/ 

private static JList subFormList; 

/* Holds the subform data 

*/ 

JPanel[] listPanel; 

/* For selecting data for various field 

*/ 

JList[] popUpListBoxes; 

/* The name of the fields of the underlying table 

*/ 

String[] mainFieldNames; 

/* The toolbar 

*! 

143 



JToolBar mainToolbar; 


/* Hold the main data 

*/ 

JPanel mainFormPanelData; 

/* The JDOImplHelper 

*/ 

JDOImplHelper my JDOImplHelper; 

/* Hold the name of the fields for whieh we want to 
* use default values 

*/ 

String[] defaultValueName; 

/* Holds the default values for the fields 

*/ 

Object[] defaultValueValue; 

/* Holds the linked field name 
String Name; 

/* Constant for the PREVIOUS button 

*/ 

final int PREVIOUS=0; 

/* Constant for the NEXT button 

V 

final int NEXT =1; 

/* Constant for the DELETE button 

*/ 

final int DELETE=2; 

/* Constant for the NEW button 

V 

final int NEW=3; 

/* Constant for the SAVE button 

*/ 

final int SAVE=4; 

/* Constant for the UPDATE button 

V 

final int UPDATE=5; 


144 



/* Constant for the FIRST button 

*/ 

final int FIRST=6; 

/* Constant for the LAST button 

*/ 

final int LAST=7; 


/* Holds the buttons 

*/ 

JButton[]mainToolBarButton= new JButton[8]; 

/* In case of a subform point to the parent form 

*/ 

InstructorsForm parentForm; 

/* Used to indicate the number of records 

*/ 

JLabel numberOfRecordLabel=new JLabel(“0”); 

* JComponent array holds the data for every field of a table 

* in the datastore 

*/ 

private JComponent[] mainFelds; 

* JTextField array holds the data for every field of a linked table 

* (subform) in the datastore 

*/ 

private JTextField[][] subFields; 

* The top level panel used in showing a dialog using JOptionPane's 

* class method showOptionDialog. 

*! 

private JPanel topPanel; 

* Default frame width 

*/ 

private static final int FRAME WIDTH = 800; 


145 



* Default frame height 

*/ 

private statie final int FRAME HEIGHT =480; 

* X eoordinate of the frame default origin point 

*/ 

private static final int ERAME_X_ORIGIN = 150; 

* Y coordinate of the frame default origin point 

*/ 

private static final int FRAME_Y_ORIGIN = 250; 


* constructs a form and displays the data 

* @param pms the Persistent Manager 

* @param result the EinkedList that contains the data 

* we are going to display 

* @param mainObj an instance of the object that 

* represents the data we are going to display 
*/ 

public InstructorsEorm( 

PersistenceManager pms, 

EinkedList result, 

Object mainObj //represents the object of the database that 
//we will handle 

){ 


this.pm = pms; 

tx = pm.currentTransactionO; 

this .mainF ormObj ect=mainObj; 

this.result=result; 

if (result !=null) 

iterator= result.listIterator(); 
else 

JOptionPane.showMessageDialog( null,”form is empty of records”); 


146 



myJDOImplHelper=JDOImplHelper.getInstance(); 


//try to get the lengths of the fields 
int[]fieldLength=getTheLengthOftheFields(); 


//get the name of the fields 

mainFieldNames=myJDOImplHelper.getFieldNames(mainFormObjeet.getClass()); 


hstPanel=new JPanel[fieldLength.length]; 
for(int i=0;i<fieldLength.length;i++) 
hstPanel[i]=new JPanelQ; 
popUpListBoxes=new JList[fieldLength.length]; 

//finaly ereate the form to handle the data 
topPanel=adjustThePanel(); 


mainFormPanelData=new JPanel(new GridLayout( 0,1,5,5 )); 


mainF ormPanelData. add(createMainF ormPanel( 
mainFieldNames, //the name of the fields (metadata) 

fieldLength, //the length of the fields 

myJDOImplHelper.getFieldTypes(mamObj.getClass()) //type of the fields 

) 

); 


JScrollPane jsp=new JSerollPane(mamFormPanelData); 

topPanel.add(jsp,BorderLayout.CENTER); 

this.add(topPanel); 


} 


* eonstructs an initial form. Then we ean modify 

* the way the form will display the data 

* @param pms the Persistent Manager 


147 



* @param result the LinkedList that contains the data 

* we are going to display 

* @param mainObj an instance of the object that 

* represents the data we are going to display 

*@param i integer to declare the difference with the previous 

* constructor 


public InstructorsForm( 

PersistenceManager pms, 

LinkedList result, 

Object mainObj, //represents the object of the database that 

//we will handle 

int i //do nothing 

){ 


this.pm = pms; 

tx = pm.currentTransactionO; 

this .mainF ormObj ect=mainObj; 

this.result=result; 

if (result !=null) 

iterator= result.listIterator(); 
else 

JOptionPane.showMessageDialog( null,’’form is empty of records”); 
myJDOImplHelper=JDOImplHelper.getInstance(); 


//get the name of the fields 

mainFieldNames=myJDOImplHelper.getFieldNames(mainFormObject.getClass()); 


mainFelds = new JComponent [mainFieldNames.length]; 

JComboBox FormInComboBoxView; 
if (result !=null) 

FormInComboBoxView=new JComboBox(result.toArray()); 
else 

FormInComboBoxView=new JComboBox(); 


148 



FormInC omboB oxView. addltemListener(this) ; 


this. add(F ormInComboB ox V iew); 

//show the data 
// refreshRecordO; 


} 

* constructs a form without data 

* @param pms the Persistent Manager 

* @param mainObj an instance of the object that 

* represents the data we are going to display 

*/ 

public InstructorsForm( 

PersistenceManager pms, 

Object mainObj //represents the object of the database that 
//we will handle 

){ 


this.pm = pms; 

tx = pm.currentTransactionO; 

this .mainF ormObj ect=mainObj; 

myJDOImplHelper=JDOImplHelper.getInstance(); 

//try to get the lengths of the fields 
int[]fieldLength=getTheLengthOftheFields(); 

//get the name of the fields 

mainFieldNames=myJDOImplHelper.getFieldNames(mainFormObject.getClass()); 

hstPanel=new JPanel[fieldLength.length]; 
for(int i=0;i<fieldLength.length;i++) 
hstPanel[i]=new JPanelQ; 
popUpListBoxes^new JList[fieldLength.length]; 


149 



//finally create the form to handle the data 
topPanel=adjustThePanel(); 


mainFormPanelData=new JPanel(new GridLayout( 0,1,5,5 )); 


mainF ormPanelData. add(ereateMainF ormPanel( 
mainFieldNames, //the name of the fields (metadata) 

fieldLength, //the length of the fields 

myJDOImplHelper.getFieldTypes(mamObj.getClass()) //type of the fields 

) 

); 


JScrollPane jsp=new JSerollPane(mamFormPanelData); 

topPanel.add(jsp,BorderLayout.CENTER); 

this.add(topPanel); 


} 


* constructs an initial form and a subform for 

* a specific linkedfield of the form 

* @param pms the Persistent Manager 

* @param result the EinkedList that contains the data 

* of the parent form we are going to display 

* @param mainObj an instance of the objeet that 

* represents the data of the parent form we are going to display 

* @param nameSubformField the name of the field for which we are going 

* to create a subform 

* @param sameSubformField an instance of the object that 

* represents the data of the subform we are going to display 

* constructor 

*/ 

public InstructorsEorm( 

PersistenceManager pms, 

EinkedList result, 

Objeet mainObj, //represents the objeet of the database that 


150 



//we will handle 

String nameSubformField ,//the name of the field that will create a same subform 
Object sameSubformField// the object that represent the name 
){ 


this.pm = pms; 

tx = pm.currentTransactionO; 

this .mainF ormObj ect=mainObj; 

this.result=result; 

if (result !=null) 

iterator= result.listIterator(); 
else 

JOptionPane.showMessageDialog( null,’’form is empty of records”); 
myJDOImplHelper=JDOImplHelper.getInstance(); 


//try to get the lengths of the fields 
int[]fieldLength=getTheLengthOftheFields(); 


//get the name of the fields 

mainFieldNames=myJDOImplHelper.getFieldNames(mainFormObject.getClass()); 


hstPanel=new JPanel[fieldLength.length]; 
for(int i=0;i<fieldLength.length;i++) 
hstPanel[i]=new JPanel(); 
popUpListBoxes=new JList[fieldLength.length]; 

//finaly create the form to handle the data 
this.setLayout(new BorderLayout()); 
this.setBackground( Color.white ); 

//create a panel to hold the main form fields 

//create and add the command toolbar to handle the data 
mainToolbar= createToolBar(); 
this.add(mainToolbar, BorderLayout.SOUTH); 

mainFormPanelData=new JPanel(new GridLayout( 0,1,5,5 )); 


mainF ormPanelData. add(createMainF ormPanel( 
mainFieldNames, //the name of the fields (metadata) 


151 



fieldLength, 


//the length of the fields 


myJDOImplHelper.getFieldTypes(mainObj.getClass()) //type of the fields 

) 

); 


for(int 1=0; i<mainF leldN ames. length; i++) 

if(myJDOImplHelper.getFieldFlags(mainFomiObjeet.getClass())[i]==8)//asfaleia 
if(mainF leldNames [i]. equals(nameSubformField)) { 

mainFelds[i] = new InstruetorsForm( pm, sameSubformField); 

mainFormPanelData. add(mainFelds [i] ); 

} 

JSerollPane jsp=new JSerollPane(mamFormPanelData); 
this.add(jsp,BorderLayout.CENTER); 

} 

/**Sets the parent form for a subform 

* @param parentf the parent form 

*/ 

publie void setParentEorm(InstruotorsEorm parentf) { 
this .parentE orm=parentf; 

} 

/**Returns the parent form of a subform 

* @return the parent form of a subform 

*/ 

publie InstruetorsEorm getParentEorm(){ 
return parentEorm; 

} 


/*=!= Returns the eurrent reeord of a form 

* @return the eurrent reeord of a form 

*! 

publie Objeet getCurrentReeord(){ 
return eurrentReeord; 

} 

/**Set the name of the field that links the 

* parent form and the subform 

* @param name the name of the field 


152 



*/ 

public void setTheLinkedFieIdName(String name){ 

Name=name; 

} 

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH^ 

/**Creates a subform for a field 

* @param nameSubformField the name of the field 

* @param subformObjeet the objeet that the subform field represents 

*/ 

publie void setSubformForTheFieId(Strmg nameSubformField, Objeet 

subformObjeet)! 

for(int i=0; i<mainFieldNames. length; i++) 

if(myJDOImplHeIper.getFieIdFlags(mamFormObjeet.getCIass())[i]==10)//asfaleia 

>eoIleetion 

if(mainF ieldNames [i]. equals(nameSubformField)) { 

InstruetorsForm subform=new InstruetorsForm( pm, subformObjeet); 
subform. setParentF orm(this); 

subform. setTheLinkedFieIdName(mamFieldNames[i]); 
mainFeIds[i] = sub form; 


} 


/*InstruetorsForm sf=subform; 
while (sf.getParentForm()!=null) 
sf=sf.getParentForm(); 


} 

/**Sets the datalayout for the display of the data 

* in a form 

* @param mgr the Layout Manager 

*/ 

publie void setMainFormPanelDataLayout(LayoutManager mgr){ 
mainFormPanelData.setLayout( mgr); 

} 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll^ 

/**Disables the editing of some fields in the form 

* @param ar an array eontaining the name of the fields for 

* whieh we want to disable the editing 

*/ 


153 



public void disableTheData(String[] ar){ 
for (int i = 0;i< mainFelds.length; i++) 
for (int j = 0; j < ar.length; j++) 

if(ar[j].equals(mainFieldNames[i]) ) 
mainFelds[i].setEnabled( false); 


} 

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH 

/**Return the object that displays the data of a particular 

* field. 

* @param ar the name of the field 

* @return the eontainer of that field 

*/ 

publie Objeet getTheFieldContainerByFieldName(String ar){ 
for (int i = 0;i< mainFelds.length; i++) 
if(ar.equals(mamFieldNames[i]) ) 
return mainFelds [i] ; 

return null; 

} 

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH 

/**Sets the source of the data for a form. i.e. 

* the data that the form will display 

* @param sresult the source of the data 

*/ 

publie void setMainData(LinkedList sresult) { 

this.result=sresult; 
if (sresult !=null) 

iterator= sresult. listIterator(); 
else 

JOptionPane.showMessageDialog( null,’’form is empty of records”); 


} 

/**Gets the data for a form according to a filter 

* and the string that holds the variables 

* @param dataclass the elass of the object that it will be displayed to 

* the form 

* @param filter the filter for retrieving the data 

* @param query Variables the parameters for retrieving the data 

* @param theObject an instance of the objeet of the data that we are going to 

* display 


154 



public void getTheMainData(Class dataclass, String fdter, String query Variables, 
Obj ect theObj eet) { 

LinkedList sresult; 
tx.beginO; 

q = pm.newQuery(dataclass); 
q.deeIareParameters(query Variables); 
q.setFilter( fdter); 

sresult = new LinkedList( (Collection) q.execute(theObject)); 

tx.commitO; 

this.result=sresult; 
if (sresult !=null) 

iterator= sresult. listIterator(); 
else 

JOptionPane.showMessageDialog( null,’’form is empty of reeords”); 


} 

*Adjusts the panel 
*@return the panel 
V 

private JPanel adjustThePanel(){ 

JPanel top=new JPanel(new BorderLayout()); 

//create a panel to hold the main form fields 

//create and add the command toolbar to handle the data 
mainToolbar= ereateToolBar(); 
top.add(mainToolbar, BorderLayout.SOUTH); 

return top; 


} 


/* Creates the form panel that displays the data of the fields for 

* every reeord 

*@param fieldNames eontains the name of the fields 
*@param fieldLength eontains the length of the fields 
*@param fieldtypes contains the type of the fields (if its 

* is a colleetion, a key etc. 

*@retum the panel that displays the data of the fields 


155 



*/ 

private JPanel createMainFormPanel(String[] fieldNames, int[] fieldLength, Class[] 
fieldtypes) { 

JPanel mainFormPanel = new JPanel( ); 

mainFormPanel.setLayout( new BoxLayout( mainFormPanel, BoxLayout.X AXIS ) 

); 


//panels for the fields and their labels 

JPanel mainFormLabelPanel= new JPanel(new GridLayout( 0,1,5,5 )); 
JPanel mainFormfieldPanel= new JPanel(new GridLayout( 0,1,5,5 )); 

JLabel[] labels; 


//ereate and add the labels and the textFields 
mainFelds = new JComponent [fieldNames.length]; 
labels = new JLabel[fieldNames.length]; 

JPanel psubdata=new JPanel(new GridLayout( 0,1,25,25 )); 


for (int i = 0;i< fieldNames.length; i++) { 

labels[i] = new JLabel( fieldNames[i], JLabel.LEFT); 


JPanel p=new JPanel(new FlowLayout(FlowLayout.LEFT)); 


//EieldElag =10 when the field is a eolleetion 

if(myJDOImplHelper.getEieldElags(mainEormObjeet.getClass())[i]==10){ 
//the panel that will hold data for the subform 
//we will have one subform for every eolleetion field 
JPanel subpane=ereateSubPormPanel( i, fieldNames [i]); 
subpane.setPreferredSize(new Dimension(80, 150)); 
psubdata.add( subpane); 


} 

else if(fieldtypes[i].getName().equals(“boolean”)) 
mainPelds[i] = new JCheekBoxQ; 

else if(fieldtypes[i].getName().equals(“java.util.Date”)) 


156 



mainFelds[i] =new JSpinner(new SpinnerDateModel()) ; 
else{ 

String mypackage=mainFormObject.getClass().getPackage().getName() ; 
if(fieldtypes[i].getName().indexOf(mypackage+”.”)>-!) 

//see if we need some restrictions to the query here 

mainFelds[i] = new JComboBox( 

getTheDataForComboBoxes(fieldtypes[i]).toArray()); 

else 

mainFelds[i] = new JTextField( fieldLength[i]); 

} 

// only if the field is not a collection add the field and its label 
// to the mainform's panel 

if(my JDOImplHelper .getFieldFlags(mainFormObj ect.getClassQ) [i]!=10) { 
p.add(mainFelds[i]); 

JPanel l=new JPanel(new FlowLayout(FlowLayout.LEFT)); 
l.add(labels[i]); 

//make a button to filter the record using the key of the record 
if(myJDOImplHelper.getFieldFlags(mainFormObject.getClass())[i]==8){ 
JButton filterButton= new JButton(“&”); 
filterButton. addActionListener(this); 
l.add(fdterButton); 

} 

mainFormLabelPanel.add(l); 
mainFormfieldPanel.add(p ); 

} 


// add all to the mainForm's panel 

mainFormPanel.setLayout( new BoxLayout( mainFormPanel, BoxLayout.X AXIS ) 

mainFormPanel.add( mainFormLabelPanel); 
mainFormPanel.add( mainFormfieldPanel); 
mainFormPanel.add( psubdata ); 
return mainFormPanel; 

} 


157 



/** Creates a sub form for a linked field 

* @param i tyhe index of the field 

* @param theNameOffheField the name of the field 

* @return a subform for the field 

*/ 

public JPanel createSubFormPanel(int i, String theNameOfrheField){ 

//create the panel that will hold the subform data 
JPanel psub=new JPanel(new BorderLayout()); 

//this must be label[i] 

psub.add( (new JPanel()).add(new JLabel( theNameOffheField) ) 
BorderLayout.NORTH ); 

JList jl=new JList(); 

jl.setName(““+i);// for use by the Mouse listener 
mainFelds[i] =jl; 

mainF elds [i]. addMouseListener(this); 

JScrollPane scrollpane = new JScrollPane(mainFelds[i]); 


psub.add(scrollpane,BorderLayout.CENTER); 

//create and add the subEorm's toolbar 
JToolBar subEormToolbar= createToolBar2(); 

psub.add(subFormToolbar, BorderEayout.SOUTH); 

//the list that will provide data for the subform 
popUpEistBoxes[i]=new 

JEist(getTheDataEorEistBoxes(theNameOfrheEield).toArray()); 

hstPanel[i].add(popUpListBoxes[i]); 

psub.setPreferredSize(new Dimension(80, 150)); 
return psub; 

} 


/**Get the data that we will use for the subforms 

* @param dataclassName the class of the field 

* that represents a subform 

* @return the data for the subform */ 

public Collection getTheDataEorEistBoxes(String dataclassName)) 
Class)] rc={String.class}; 


158 



Object[] obi={ dataclassName }; 
try{ 

//I use reflection here to find out the class type of the collection 
//i.e. what kind of objects are included in the collection field. 
//Unfortunately JDO does not provide this information so I must use 
// a method in every class that will return the class of the object 
//stored in the collection. 
java.lang.reflect.Method 

meth=mainFormObject.getClass().getMethod(“getTheTypeOfrheCollection”, re); 
Obj ect returnV alue=meth. invoke(mainF ormObj ect,obi); 

Collection sresult; 
boolean wasActive=true; 
if (returnValue! =null) { 

if(!tx.isActive()) 

tx.beginO; 

q = pm.newQuery((Class)retumValue); 
sresult = (Collection) q.execute(); 
tx.commitO; 

return sresult; 

} 


} 

catch( NoSuchMethodException e){e.printStackTrace(); 

printMessageNoSuchMethod( dataclassName);} 

catch( IllegalAccessException ed){ed.printStackTrace();} 

catch( java.lang.refiect.InvocationTargetException ex){ex.printStackTrace();} 

return new EinkedList(); 

} 


/** Return the data that we store in comboboxes and can select them 

* to assign value to a specific field of a table 

* @param dataclass the class of the field 

* @return the data of the table that represents the field 

*! 

public static Collection getTheDataEorComboBoxes(Class dataclass)} 
Collection sresult; 

if(!tx.isActive()) 

tx.beginO; 


159 



q = pm.newQuery(dataclass); 
sresult = (Collection) q.execute(); 

tx.commitO; 

return sresult; 


} 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

/** Creates a subformpanel 

* @param subFormMetadata the name of the fields for the 

* subform 

* @return the subform panel 

*/ 

private JPanel createSubFormPanel(Strmg[] subFormMetadata)) 

JPanel subFormPanel=new JPanel(); 
subFormPanel.setBackground( Color .blue ); 

subFields = new JTextField[6][subFormMetadata.length]; 

JLabel[] labels = new JLabel[subFormMetadata.length]; 
//create and add the labels 

subFormPanel.setLayout( new GridLayout( 0,2,0,5 ) ); 
for (int i = 0;i< subFormMetadata.length; i++) { 

labels)!] = new JLabel( subFormMetadata)!], JLabel.LEFT); 
subFormPanel.add( labels)!] ); 

} 


//create and add the subForm's fields 
for (int k = 0; k < 6; k++) 

for (int i = 0;i< subFormMetadata.length; i++) { 
subFields)k])i] = new JTextField( 20 +1); 
subFields)k] )i] .addMouseListener(this); 
subFormPanel.add( subFields)k])i] ); 

} 

//create and add the subForm's toolbar 
JToolBar subFormToolbar= createToolBar2(); 

JPanel basesubFormPanel=new JPanel(new BorderLayout()); 
basesubFormPanel.add(subFormPanel,BorderLayout.CENTER); 
basesubEormPanel.add(new JPanel(),BorderEayout.WEST); 
basesubEormPanel.add(new JPanel(),BorderEayout.EAST); 
basesubEormPanel.add(new JPanel(),BorderEayout.NORTH); 
basesubE ormPanel. add(subE ormToolbar,BorderEay out. SOUTH); 


160 



return basesubFormPanel; 


} 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll^ 

H - 

// Main method 

H - 

public static void main(String[] args) { 


try { 

pmf = getPMF( “lido mysql.properties”); 
pm = pmf.getPersistenceManagerO; 
tx = pm.currentTransactionO; 

Instructors object=new Instructors(); 

String[] instructorsMetaData={“id”,’’LastName”}; 


InstructorsForm sf=new InstructorsForm( pm, object); 

JFrame myframe=new JFrame(); 

Container contentPane=myframe.getContentPane(); 
contentPane.setLayout(new BorderLayout()); 

JPanel head= new JPanel(); 
head.add(new 

JComboBox(getTheDataForComboBoxes(Squadron.class).toArray())); 
contentPane.add(head, BorderLayout.NORTH ); 

contentPane.add(sf, BorderLayout.CENTER ); 

myframe.packO; 

myframe.setVisible(true); 

//pm.closeO; 

// EiDOHelper.close(pmf); 

} catch (Exception e) { 
e .prints tackX rac e(); 

} 


} 


/**Return all the records from the Instructors 

* @param results the total amount of records 

* @return the results 


161 





*/ 

public static Collection getAllInstructorsResult(CoIIection results) { 
String answer=““; 


tx.beginO; 

q = pm.newQuery(Instructors.class); 
results = (CoIIeetion) q.exeeute(); 

//System.out.println(“Load ail Instruetors (“ + result.size() + “)”); 


tx.commitO; 
return results; 

} 

H - 

// actionPerformed 
H - 

* @param event */ 

pub lie void actionPerformed(ActionEvent event) { 
if (event.getActionCommand().equals(“&”)) 

fmdRecordByKeyO; 

} 


/**Depreciated ehooses an instructor from a list 

* used for entering data to a subform 

* @param i determines the ist that it will be displayed 

* @return the component that holds the Instructors data 

*/ 

public JComponent[] chooseInstructor(mt i){ 

Strmg[] buttonLabel = { “Enter”, “Delete” }; 

int result = JOptionPane.showOptionDialog( null, listPanel[i], 
Information”, 

JOptionPane.DEEAUETOPTION, 

JOptionPane.QUESTION MESSAGE, null, 
buttonEabel, buttonLabel[0] ); 

Object isd=popUpEistBoxes[i].getSelectedValue(); 
if(isd! =null&& currentRecord! =null) 

if (result == JOptionPane.OK OPTION) { 
try{ 


“Instructors 


162 





tx.beginO; 

pm. makePersistent(currentRec ord); 

Class[] classParameters={String.class,(new 

Object()).getClass(),boolean.class};//class parameters of the method 
//i.e. “students” 

Objeet[] ob={mamFieldNames[i],isd,new Boolean(true) }; //value 

parameters 

java.lang.refleet.Method 

meth=eurrentReeord.getClass().getMethod(“setFieldByName”, elassParameters); 
meth.mvoke(eurrentReeord,ob); 
tx.eommitO; 

showInstruetorsO; 

} 

eateh(Exeeption e){e.printStackTraceO;} 


// return mainFelds; 

} else { 
try{ 

tx.beginO; 

pm. makePersistent(currentRee ord); 

Class[] olassParameters= {String.elass,(new 

Objeet()).getClass(),boolean.elass};//elass parameters of the method 

Objeot[] ob={mamFieldNames[i],isd,new Boolean(false) }; //value 

parameters 

java.lang.refleet.Method 

meth=currentReoord.getClass().getMethod(“setFieldByName”, elassParameters); 
meth.mvoke(currentReeord,ob); 
tx.eommitO; 

showInstruetorsO; 

} 

catch(Exception e){e.printStackTraceO;} 


} 

refreshRecordO; 
return null; 

} 


* Creates a toolbar with Add, Delete, Modify, and update ete. 

* eontrol buttons 


163 



*/ 

private JToolBar createToolBar( ) { 

JButton button; 

JToolBar toolbar = new JToolBar(); 

// toolbar.addSeparatorO; 

//DELETE 

mainToolBarButton[PREVIOUS] = toolbar.add( 

new AbstraetAction(“previous”, new ImageIeon(“previous.gif’)) { 
publie void aotionPerformed(AotionEvent e) { 

//deletePetQ; 
previousRee ord(); 
showInstruetorsO; 

} 

}); 

mainToolBarButton[PREVIOUS].setToolTipText(“Deletes the seleeted Pet 
objeet”); 

// toolbar.addSeparatorO; 

//ADD 

mainToolBarButton[NEXT] = toolbar. add( 

new AbstraetAction(“next”, new ImageIeon(“next.gif’)) { 
publie void aotionPerformed(AotionEvent e) { 

//newDataO; 

nextReeordO; 

showInstruetorsO; 

// showInstruetorsInListO; 

} 

}); 

mainToolBarButton[NEXT].setToolTipText(“Adds a new Pet objeet”); 

// toolbar.addSeparatorO; 


//SEARCH 

mainToolBarButton[DELETE] = toolbar. add( 
new AbstraetAetion(“delete”, new ImageIeon(“delete.gif’)) { 
publie void aotionPerformed(AotionEvent e) { 

deleteReeordO; 

} 

}); 

mainToolBarButton[DELETE]. setToolTipText(“Deletes the Reeord”); 
// toolbar.addSeparatorO; 


164 



//LIST 

mainToolBarButton[NEW] = toolbar. add(new AbstractAction(“new”) { 
public void actionPerformed(ActionEvent e) { 

newRecordO; 

} 

}); 

mainToolBarButton[NEW].setToolTipText(“Lists all Pet objects in the kennel”); 

// toolbar.addSeparatorO; 

//WORKOUT 

mainToolBarButton[SAVE] = toolbar.add( 
new AbstraetAetion(“Save”, new ImageIeon(“save.gif’)) { 
publie void aotionPerformed(AotionEvent e) { 
saveReeordQ; 

} 

}); 

mainToolBarButton[SAVE].setToolTipText(“Make the pets go through the workout 
routines”); 

//toolbar.addSeparatorO; 
mainToolBarButton[UPDATE] = toolbar. add( 
new AbstraetAetion(“Update”) { 

publie void actionPerformed(AotionEvent e) { 
upDateReeordO; 

} 

}); 

mainToolBarButton[UPDATE].setToolTipText(“Make the pets go through the 
workout routines”); 

// toolbar.addSeparatorO; 

mainToolBarButton[FIRST]= toolbar.add( 
new AbstraetAction(“«First”, new ImageIeon(“tirst.gif’)) { 
publie void aotionPerformed(AotionEvent e) { 

} 

}); 

mainToolBarButton[FIRST].setToolTipText(“Make the pets go through the workout 
routines”); 

mainToolBarButton[LAST] = toolbar.add( 
new AbstraetAetion(“last»“,new ImageIeon(“last.gif’)) { 
publie void aotionPerformed(AotionEvent e) { 

} 

}); 


165 



mainToolBarButton[LAST].setToolTipText(“Make the pets go through the workout 
routines”); 

// toolbar.addSeparatorO; 

// button.setEnabled(false); 
numberOfReeordLabel=new JLabel(“num”); 
if(result!=null) 

numberOfReeordLabel.setText(““+result.size()); 
toolbar.add(numberOfReeordLabel); 

button = toolbar. add( 

new AbstractAction(“Tabular”) { 

public void actionPerformed(ActionEvent e) { 
show! abularE orm(); 

} 

}); 

toolbar.setEayout(new GridLayout(l, 0)); 
return toolbar; 

} 


/*Disables a set of buttons in the toolbar 
*@param ar int[] an array holding the buttons 
* we are going to disable 

*/ 

private void mainToolBarSetDisable(int[] ar){ 
for(int i=0;i<ar.length;i++) 

mainToolBarButton[ar[i]].setEnabled(false); 


} 


/*Enables a set of buttons in the toolbar 
*@param ar int[] an array holding the buttons 
* we are going to enable 

*/ 

private void mainToolBarSetEnable(int[] ar){ 
for(int i=0;i<ar.length;i++) 

mainToolBarButton[ar[i]].setEnabled(true); 


} 


/*Disables all the buttons in the toolbar 

*/ 

private void mainToolBarDisableAll(){ 


166 



for(int i=0;i<mainToolBarButton.length;i++) 
mainToolBarButton[i].setEnabled( false); 


} 


/*Enables all the buttons in the toolbar 

private void mainToolBarSetEnableAll(){ 
for(int i=0;i<mainToolBarButton.length;i++) 
mainToolBarButton[i].setEnabled(true); 


} 


/* updates the label that displays the total number of reeords 

*/ 

publie void updateNumberOfReoords() { 

numberOfReoordLabel.setText(“Records “+this.result.size()); 

} 


* Creates a toolbar with Add, Delete, Modify, and Eist 

* eontrol buttons 

* 

*/ 

private JToolBar ereateToolBar2( ) { 

JButton button; 

JToolBar toolbar = new JToolBar(); 

String[] ar={“New”,”Delete”}; 
for(int i=0; i<ar. length; i++){ 
button=new JButton(ar[i]); 
toolbar.add(button); 

} 

return toolbar; 

} 


/* shows the data in a form using 
* a tabular view 


167 



*/ 

public void sliowTabularForm(){ 


String[] fieIds=myJDOImplHeIper.getFieIdNames(mainFormObject.getCIass()); 
JTablejt=createJTabIeForCoIIection(result,mainFormObject,fields ); 

JScroIIPane jsp=new JScroIIPane(jt); 

JFrame myframe =new JFrame(); 

Container eont=myframe.getContentPane(); 
cont.add(jsp); 

myframe.packO; 
myframe. setV isib le(true); 


} 

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH 

/** Creates a JTable to display a data from a colleetion 

* @param sresult the colleetion 

* @param record represents the objeet instance of whieh 

* we will display 

* @param fields the fields of the object or the underlying data table 

* @return the JTable 

*/ 

public static JTable ereateJTableForCollection(Collection sresult,Object record, 
String [] fields ){ 

Vector rowVector=new Vector(); 

Vector columnVector=new Vector(); 

Iterator iter=sresult.iterator(); 
while(iter.hasNext()) { 

rowVector.add( putRecordFieldsInVector( iter.next(), fields )); 

} 

//Strmg[] fields=; 

for (int i = 0;i< fields.length; i++) 
columnVector.add(fields [i]); 

return new JTable(rowVeetor, columnVeetor); 


} 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll^ 

/**Creates a vector form records of a data table 
* @param reeord the reeord 


168 



* @param fieldnames the field names of the data table or the reeord 

* @return the veetor 

*! 

publie static Vector putRecordFieldsInVector(Object record, String[] fieldnames) { 
Vector returnVector=new Vector(); 

Class[] rc={mt.class}; 

if (record !=null){ 

for (int i = 0;i< fieldnames.length; i++) { 
try{ 

Object[] obi={ (new Integer(i))}; 

java.lang.reflect.Method meth=record.getClass().getMethod(“getField”, re); 
Object returnValue=meth.mvoke(record,obi); 
if(returnValue==null) retumValue=“null”; 
returnV ector. add(returnV alue); 


} 

catch( NoSuchMethodException e){e.prmtStackTrace();} 
catch( IllegalAccessException ed){ed.prmtStackTrace();} 
catch( java.lang.reflect.InvocationTargetException ex){ex.printStackTrace();} 

} 

} 

return returnVector; 

} 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 


/** refreshes the record 
* @return true if everything is ok */ 
public boolean refreshRecord(){ 

if (currentRecord !=null){ 

for (int i = 0;i< mainEelds.length; i++) { 

Class[] rc={mt.class}; 

Object[] obi={ (new Integer(i))}; 

try{ 

java.lang.reflect.Method 

meth=currentRecord.getClass().getMethod(“getEield”, re); 

Object returnValue=meth.invoke(currentRecord,obi); 

if(mainEelds[i] instanceof JTextEield){ 

if (returnValue==null) returnValue^new String(““); 


169 



((JTextField) mainFelds[i]).setText( returnValue.toString() ); 

} 

if(mainFelds[i] instanceof JSpinner){ 

((JSpinner) mainFelds[i]).setValue( returnValue ); 

} 

if(mainFelds[i] instanceof JComboBox){ 


refreshTheLinkedDataForComboBoxesAfterUpdateOrDeleteOrNext((JComboBox) 

mainFelds[i],i); 

((JComboBox) mainFelds[i]).setSelectedItem( returnValue ); 

} 

if(mainFelds[i] instaneeof JCheekBox) 

((JCheekBox) mainFelds[i]).setSeleeted( ((Boolean) 

returnValue).booleanValue()) ; 

if(mainFelds[i] instaneeof JList){ 

if (retumValue==null) returnValue=new LinkedList(); 

((JList) mainFelds[i]).setListData(((Collection) returnValue).toArray()) ; 

} 

if(mainFelds [i] instaneeof InstruetorsForm) { 

LinkedList datalist=new LinkedList(); 

if(retumValue!=null) datalist=new LirLkedList((Colleotion) returnValue ); 
((InstruetorsForm) mainFelds[i]).setMainData(datalist); 

//this first and then nextReeord() beeause nextReeord() goes reeursively 
((InstruetorsForm) mainFelds[i]).updateNumberOfRecords(); 
((InstruetorsForm) mainFelds [i]) .nextReeord(); 


} 


} 

eateh( NoSuehMethodExeeption e){e.printStaekTraee(); 
printN o SuehGetMethod(); 
return false; } 

eateh( IllegalAeeessException ed){ed.printStackTraee();} 

eateh( java.lang.refieet.InvoeationXargetExeeption ex){ex.printStaekTraee();} 

} 

/* try{// ayto den doyleyei giati einai private to 

JOptionPane.showMessageDialog(null, 


170 




“ Lnamefields 

>“+currentRecord.getClass().getDeclaredField(“lname”).get(currentRecord) ); 

} 

catch(Exception e){} 


*/ 

} 

else{ 

for (int i = 0;i< mainFelds.length; i++) { 
if(mainFelds[i] instanceof JTextField) 

((JTextField) mainFelds[i]).setText( “null” ); 
if(mainFelds[i] instanceof JComboBox) 

((JComboBox) mainFelds[i]).setSelectedItem( null); 

if(mainFelds[i] instanceof InstructorsForm) { 

FinkedFist datalist=new FinkedFist(); 

// if(retumValue!=null) datalist=new FinkedFist((Collection) returnValue ); 
((InstructorsForm) mainFelds[i]).setMainData(datalist); 

//this first and then nextRecord() because nextRecord() goes recursively 
((InstructorsForm) mainFelds[i]).updateNumberOfRecords(); 

((InstructorsForm) mainFelds [i]). nextRecord(); 


} 


} 

} 

return true; 


} 

////////////////////////////////////////////////////////////////////////////// 

/** goes to the next record 
* @return true if everything is ok 

*/ 

public boolean nextRecord() { 
mainToolBarSetFnablcAllO; 
int[] ar2={SAVF}; 
mainToolBarSetDisable( ar2); 

if(iterator.hasNext()) { 

currentRecord = iterator.next(); 

refreshRecordO; 

return true; 


171 



} 

else{ 

if(result.size()==0) 
currentRecord=null; 
int[] arl={DELETE}; 
mainToolBarSetDisable( arl); 

refreshRecordO; 

} 

return false; 


} 


/** goes to the previous reeord 
* @return true if everything is ok 

*/ 

publie boolean previousReeordQ { 
mainToolBarSetEnableAllO; 
int[] ar2={SAVE}; 
mainToolBarSetDisable( ar2); 

if(iterator.hasPrevious()) { 

eurrentReeord = iterator .previous(); 

refreshReeordO; 

return true; 

} 


return false; 

} 


/** Cheeks if there are linked tables with reeords n it 

* we use it to avoid delete a reeord if there are linked reeords 

* on it. 

* @return true if there are dependent reeords 

*! 

publie boolean thereAreEinkedTablesWithReeords(){ 

if (eurrentReeord !=null){ 

for (int i = 0;i< mainEelds.length; i++) { 

if(myJDOImplHelper.getEieldElags(mainEormObjeet.getClass())[i]==10){//eolleetion 


172 



Class[] rc={int.class}; 

Object[] obi={ (new Integer(i))}; 

try{ 

java.lang.reflect.Method 

meth=currentRecord.getClass().getMethod(“getField”, rc); 

Object returnValue=meth.invoke(currentRecord,obi); 
if (returnValue!=null) 

// if(retumValue instanceof Collection) 
if(((Collection) returnValue).size()>0) 
return true; 


} 

catch(Exception e){JOptionPane.showMessageDialog( null,’’public boolean 
there AreLinkedT ablesWithRecords()\n”+e);} 

} 

} 

} 

return false; 

} 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

/** deletes the records 
* @return true if everything is ok 

*/ 

public boolean deleteRecord(){ 

JOptionPane.showMessageDialog( null,’’delete?”); 
try{ 

if (thercArcLinkedTablesWithRecordsO) 

JOptionPane.showMessageDialog( null,”there are linked records in this records 

\n”+ 

“You must first delete the records to the linked table”); 
else) 

//edv na enhmervsv kai to parent 
tx.beginO; 

informParentF ormT oDeleteTheReference(); 

pm.deletePersistent(currentRecord); 

tx.commitO; 

pm.refreshAllO; 

if(getParentForm()==null){//only for the primary form) 
refreshTheSourceDataForTheFormAfterUpdateOrDelete(); 


173 



} 

updateNumberOfRecordsO; 

if(iterator.hasNext()) currentRecord=iterator.next(); 

if( iterator.previousIndex()>-1 )currentRecord=iterator.previous(); 

else currentRecord=null; 

refreshRecordO; 

return true; 

} 

} catch (Exception ed) { 
ed.prints tackX rac e(); 
return false; 

} 

return false; 


} 


/*in case of delete inform the parent record to 
*remove (delete) the reference 

*/ 

public void informParentFonnToDeleteTheReference(){ 
if(getParentForm()! =null) { 
try{ 

Object parentCurrentRecord=getParentForm().getCurrentRecord(); 
pm.makePersistent(parentCurrentRecord); 

Class[] classParameters={String.class,(new 

Object()).getClass(),boolean.class};//class parameters of the method 
//i.e. “students” 

Object[] ob= {Name,currentRecord,new Boolean(false)}; //value parameters 
java.lang.reflect.Method 

meth=parentCurrentRecord.getClass().getMethod(“setFieldByName”, classParameters); 
meth.invoke(parentCurrentRecord,ob); 

} 

catch(Exception e) {e.printStackTrace();} 


} 


} 


/**updates the record 
* @return true if everything is ok 

*/ 


174 



public boolean upDateRecordQ { 
try{ 

tx.beginO; 

setTheValuesToTheRecord(currentRecord); 


pm. makePersistent(currentRec ord); 

tx.commitQ; 
return true; 

}eateh (Exeeption ed) { 
ed.prints taekT rae e(); 
tx.rollbaekO; 
return false; 

} 


} 


/*refreshes the data after an update or insert or delete 

*/ 

publie void refreshTheSouroeDataForTheFormAfterUpdateOrDelete(){ 
Extent recExtent=pm.getExtent(mainFormObjeet.getClass(),true); 
Iterator iter= reoExtent.iterator(); 

FinkedEist listo=new FinkedEist(); 
while (iter.hasNext()){ 
hste.add(iter.next()); 


} 

setMainData(hste); 

} 


/**refreshes the data of eomboboxes after an update or insert or delete or 

* previous, or next command has been executed 

* @param eombo the eombobox 

* @param i the index of the field 

*/ 

publie 

refreshTheFmkedDataForComboBoxesAfterFipdateOrDeleteOrNext(JComboBox 
eombo,int i){ 

InstruetorsForm eurrentParentForm=getParentForm(); 
while (eurrentParentForm!=null){ //the form is a subform 


void 


175 



Object parentCurrentRecord=currentParentForm.getCurrentRecord(); 
if(parentCurrentRecord! =null) 

if(myJDOImplHelper.getFieldTypes(mainFormObject.getClass())[i]== 
parentCurrentRecord.getClassO ){ //there are fields based in the parent form 
Obj ect[] arobj= {parentCurrentRecord}; 
combo.removeAllItemsQ; 
combo. addltem(parentCurrentRecord); 

} 

currentParentForm=currentParentForm.getParentForm() ; 

} 


} 


/** saves the record 
* @return true if everything is ok 

*! 

public boolean saveRecord(){ 

Class[] ar={}; 
if(parentForm==null) { 

try{ //mainFormObject must not be null or must be 
//class and i have to change the sentence 
//as mamFormObject.getConstructor(ar ).newlnstance(null) 

currentRecord=mamFormObject.getClass().getConstructor(ar 
). newinstanc e(null); 

setTheValuesToTheRecord(currentRecord); 

tx.beginO; 

pm. makePersistent(currentRec ord); 
tx.commitO; 

refreshTheSourccDataForTheFormAfterUpdateOrDeleteO; 

pm.evictAllO; 
pm.refreshAllQ; 
pm. refreshAll(result); 


} 

catch(Exception e) {e.printStackTraceO; 

tx.rollbackO; 

} 

} 


176 



else{ //the form is a sub form 
try{ 

tx.beginO; 

Object parentCurrentRecord=parentF orm. getCurrentRecord(); 
currentRecord=mamFormObject.getClass().getConstructor(ar 
). newinstanc e(null); 

setTheValuesToTheRecord(currentRecord); 

//curreRecord will also be done persistent 
pm.makePersistent(currentRecord); 

pm.makePersistent(parentCurrentRecord); 

Class[] classParameters= {String.class,(new 

Object()).getClass(),boolean.class};//class parameters of the method 
//i.e. “students” 

Object[] ob= {Name,currentRecord,new Boolean(true) }; //value parameters 


java.lang.reflect.Method 

meth=parentCurrentRecord.getClass().getMethod(“setFieldByName”, classParameters); 
meth.invoke(parentCurrentRecord,ob); 
tx.commitO; 

pm.evictAllO; 
pm.refreshAllO; 
pm. refreshAll(result); 

parentForm.refreshRecord(); 

} 

catch(Exception e) {e.printStackTrace(); 
tx.rollbackO;} 

} 

int[] arl={SAVE}; 
mainToolBarSetDisable( arl); 
int[] ar2={DEEETE}; 
mainToolBarSetEnable(ar2 ); 

refreshRecordO; 
return false; 

} 

/*Depriciated 

*/ 

public void updateTheComboBoxesData() { 


177 



/* InstructorsForm currentParentForm=this; 


while(currentParentForm!=null){ //the form is a subform 

for(mt i=0;i<currentParentForm.mamFelds.length;i++) { 

//see if we need some restrictions to the query here 
if(currentParentForm.mainFelds[i] instanceof InstructorsForm) 

currentParentForm=currentParentForm.InstructorsForm.mainFelds[i] 
if(currentParentForm.mainFelds[i] instanceof JComboBox) 

currentParentForm.mainFelds[i] = new JComboBox( 
(getTheDataForComboBoxes(myJDOImplHelper.getFieldTypes( 
currentParentForm.mainFormObject.getClass())[i]).toArray() )); 

} 

} 

*! 


} 


/**Informs a record with the new values that have been 

* entered to the components of the form 

* @param record the record */ 

public void setTheValuesToTheRecord(Object record)) 
try) 

for (int i = 0;i< mainFelds.length; i++) ) 

Class)] classParameters=)int.class,(new Object()).getClass()};//, Object}; 
//parameters of the method 
Object)] ob=)}; 

if( mainFelds)!] instanceof JTextField )) 

Object)] obi=) (new Integer(i)), ((JTextField) mainFelds)i]).get!ext()}; 
ob=obi; 

} 

if(mainFelds)i] instanceof JComboBox)) 

Object)] obj=) (new Integer(i)), ((JComboBox) 

mainFelds)i]).getSelectedItem()}; 
ob^obj; 

} 

if(mainFelds)i] instanceof JCheckBox)) 

Object)] obj=) (new Integer(i)), new Boolean( ((JCheckBox) 
mainFelds)!]).isSelectedO)}; 
ob^obj; 

} 

if(mainFelds)i] instanceof JList)) 


178 



Object[] obj={ (new Integer(i)), null};// do nothing ; 
ob=obj; 

} 

if(mainFelds[i] instanceof JSpinner)} 

Object}] obj={(new Integer(i)), ((JSpinner) mainFelds[i]).getValue( ) }; 

//JOptionPane.showMessageDialog(null,obj); 

ob^obj; 

} 

if(mainFelds[i] instanceof InstructorsForm) { 

Object}] obj={(new Integer(i)), null};// do nothing ; 

//JOptionPane.showMessageDialog(null,obj); 

ob^obj; 

} 

java.lang.reflect.Method meth=record.getClass().getMethod(“setFieldValue”, 
classParameters); 

meth.invoke(record,ob); 

} 

} 

catch( NoSuchMethodException e){e.printStackTrace(); 
printN o SuchS etMethod();} 

catch( IllegalAccessException ed){ed.printStackTrace();} 

catch( java.lang.reflect.InvocationTargetException ex){ex.printStackTrace();} 


} 


/**Creates a new record with default values 
* @return */ 

public boolean newRecord() { 


Class}] ar={}; // for a constructor without arguments 
try{ 

currentRecord=mainEonnObject.getClass().getConstructor(ar 
). newinstanc e(null); 

//assign default values using the Parent Eorm 
setDefaultValuesEromParentPormO; 

////assign default values that might user had entry using before the 
setDefaultValues(..) method 

setDefaultV aluesEromU serEntry(); 

//but we must add the new record otherwise it is not going to be in the combobox 
refreshRecordO; 


179 



} 

catch(Exception e){e.printStackTrace(); return false;} 

int[] arl={DELETE}; 
mainToolBarSetDisable( arl); 
int[] ar2={SAVE}; 
mainToolBarSetEnable( ar2); 

return true; 

} 


/**Sets the default values that the user 
*has assigned for the reeord 

*/ 

publie void setDefaultValuesEromElserEntry(){ 

Class}] olassParameters={int.olass,(new Objeot()).getClass()}; //elass parameters of 
the method 
try{ 

int fieldindex=-l; 

if(defaultValueName!=null)//if there have been assigned default values bye the 
setDefaultValuesO method 

for (int 1=0; i<mamEieldNames.length;i++) 
for (int j=0; j<defaultValueName.length;j++) 

if(mainEieldNames[i].equals(defaultValueName[j])){ 

fieldmdex=i; 

java.lang.refleet.Method 

meth=ourrentReoord.getClass().getMethod(“setEieldValue”, elassParameters); 

Objeet}] ob={ (new Integer(fieldmdex)), defaultValueValue[j]};//the 
parameters of the methods 

meth.mvoke(currentReoord,ob); 


} 

} 

oatch(Exoeption e){e.printStaekTraceO;} 


} 


/**Sets the default values from 
*the parent form 

*/ 

publie void setDefaultValuesPromParentPorm(){ 


180 



Class[] classParameters={int.class,(new Object()).getClass()}; //class parameters of 
the method 

InstruetorsForm currentParentForm=getParentForm(); 
while(ourrentParentForm!=null){ //the form is a subform 
try{ 

Objeet parentCurrentRecord=currentParentForm.getCurrentReoord(); 
if(parentCurrentReoord! =null) { 

for(int i=0; i<mainFieldNames. length; i++) 

if(my JDOImplHelper .getF ieldX ypes(mamF ormObj ect. getClass()) [i]== 
parentCurrentRecord.getClassO ) {//there are fields based in the parent 

form 


java.lang.refleet.Method 

meth=currentRecord.getClass().getMethod(“setFieldValue”, elassParameters); 

Object[] ob={ (new Integer(i)), parentCurrentReeord};//the parameters 

of the methods 

meth.mvoke(currentReoord,ob); 


} 


} 

} 

} 

oatch(Exoeption e){e.prmtStackTrace(); } 

//continue to the previous forms to get the default values 
currentParentForm=currentParentForm.getParentForm(); 


} 

//////////////////////////////////////////////////////////////////////////////////////// 


/** Depriciated 
* @return */ 

publie boolean showInstruetors() { 

/*for (int k = 0; k < subFields.length; k++) 
for (int i = 0; i < subFields[k].length; i++) { 
subFields[k][i].setText(““); 

} 


if (currentRecord !=null){ 

// iterator=(( Students)currentRec ord). getInstructors(). listIterator() 
LinkedList linst=((Instructors)eurrentRecord).getStudents(); 
for (int i = 0;i< linst.sizeO; i++) { 


181 



subFields[i][0].setText( ((Students) linst.get(i)).getld() ); 
subFields[i] [ 1 ] .setText( ((Students) 

linst.get(i)).getLastName() ); 

} 

return true; 

} 

*! 

return false; 

} 


/**depreeiated 

*/ 

pub lie void showInstructorsInList() { 

LinkedList ll=((Students)eurrentReeord).getInstruetors(); 

//*ll.toArray(); 

String[] arl={“M”,”ksk”}; 
if(ll!=null) 

subFormList.setListData(ll .toArray());//ll .toArray());/A^eetor listData) 
else 

subFormList.removeAllO; 


} 


/**gets the persistent manager faetory 

* @param path the url path 

* @return the persistent manager faetory*/ 

publie static PersistenceManagerFactory getPMF(String path) { 
try { 

InputStream propStream = 
new FilelnputStream(path); 

Properties props = new Properties(); 
props.load(propStream); 

props.put(“javax.jdo.PersistenceManagerFactoryClass”, 
“com. libelis. lido .PersistenceManagerF actory”); 

return JDOHelper.getPersistenceManagerFactory(props); 

} catch (lOException e) { 
e .prints tackX rac e(); 

System.exit(-l); 
return null; 

} 


182 



} 


* @param e */ 

public void mouseCIicked(MouseEvent e) { 

chooseInstructor(Integer.parseInt(e.getComponent().getName())); 


} 

* @param e */ 

public void mousePressed(MouseEvent e) { 

} 

* @param e */ 

public void mouseReIeased(MouseEvent e) { 

} 

* @param e */ 

public void mouseEntered(MouseEvent e) { 

} 

* @param e */ 

public void mouseExited(MouseEvent e) { 

} 

* @param e */ 

public void itemStateChanged(ItemEvent e) { 
currentRecord=e.getItem() ; 
refreshRecordO; 


} 

/** used for experiment 

*/ 

pub lie void expirement() { 

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH 

String[] buttonLabel = { “Enter”, “Delete” }; 

JPanel JtablePanel=new JPanelQ; 


183 



JTable myjtable= new JTable(10,5);// 

Object mycurrentRecord; 

Object[][] objarray= new Object[result.size()][mainFieldNames.length]; 
//iterator.firstO; 

for (int i=0; i<objarray.length;i++){ 
currentRecord = iterator.next(); 

//bazontas to currentRecord na typvuei tote kale! kai enhmervnei ta paidia toy 
//String x=““+currentRecord; 

// JOptionPane.showMessageDialog(null,”The array of the length of the 
”+currentRec ord); 

// objarray[i]=putRecordFieldsInVector( currentRecord ).toArray(); 


} 

//currentRecord = new Flights(); 

// JOptionPane.showMessageDialog(null,”The array of the length of the 
”+getRecordInFormOfObjectArray( currentRecord )); 

Object[] 

objcolumn=myJDOImplHelper.getFieldTypes(mainFormObject.getClass()); 
myjtable= new JTable(obj array,obj column); 

JScrollPane scrollpane = new JScrollPane(myjtable); 

JtablePanel.add(scrollpane); 

JOptionPane.showOptionDialog( null, JtablePanel, “Instructors Information”, 
JOptionPane.DEFAULTOPTION, 

JOptionPane.QUESTION MESSAGE, null, 
buttonLabel, buttonLabel[0] ); 

///////////////////////////////////////////////////////////////////////////////////////////////// 

//////////////////////////////////////////////////////////////////////////////////////////////// 


setVisible(true); 

} 

/** experiment for finding 
*record using key values 

*! 

public void fmdRecordByKey(){ 

EinkedList sresult; 

q = pm.newQuery(mamEormObject.getClass()); 

byte[] arflag=myJDOImplHelper.getEieldElags(mamEormObject.getClass()) ; 
Strmg[] amame=myJDOImplHelper.getEieldNames(mamEormObject.getClass()); 


184 



string filter=““; 

String parameters=““; 

//Students.class,”squadron==sq”, “Squadron sq”, sq 
for (int i=0;i<arflag.length;i++) 

if(arflag[i]==8) {//8 means primary key 
if(fdter.equals(““)) { 

filter=arname[i]+”=“+”param”+i; 

parameters+=myJDOImplHelper.getFieldTypes(mainFormObject.getClass())[i] ; 

} 

else { 

fdter=fdter+” && “+amame[i]+”=“+”param”+i; 
parameters+=“ 

“+myJDOImplHelper.getFieldTypes(mainFormObject.getClass())[i] ; 

} 

} 


/* JOptionPane.showMessageDialog( null,” filter—>“+lilter +”\n”+”parameters—> 
“+parameters+ 

“\n\n\nTHIS NEEDS TO FIX IT”); 
q.declareParameters(queryVariables); 
q.setFilter(filter); 

// q.declareVariables(queryVariables); 

sresult = new EinkedList( (Collection) q.execute(theObject)); 


this .result=sresult; 
if (sresult !=null) 
iterator= sresult.listIterator(); 
else 

JOptionPane.showMessageDialog( null,”form is empty of records”); 

// return sresult; 

*/ 


} 


/**Sets the default values from a user 

* @param defaultValucName array containing the name of the fields 

* @param defaultValueValue array containing the default values for the 

* above fields 

*/ 

public void setDefaultValues(String[] defaultValueName,Object[] 

defaultV alue V alue) { 


185 



this .de faulty alueN ame=defaultV alueName; 
this .de faulty aluey alue=defaulty aluey alue; 


} 


/**Tries to get the length of the fields. If there is no result raise a message and assigns 

* default values for the length of the fields 

* @return the length of the fields 

*! 

public int[] getTheLengthOftheFields(){ 

//just a default value 

int[]fieldLength= {30,20,20,15,10,7,17,10}; 
try{ 

Class}] classParameters={};//class parameters of the method 
Object}] ob={ }; //value parameters of the method 

java.lang.refiect.Method 

meth=mainFormObject.getClass().getMethod(“getFieldLengths”, classParameters); 
fieldLength=( (int}]) meth.invoke(mainFormObject,ob) ); 


if(fieldLength. length! =my JDOImplHelper. getF ieldNames(mainF ormObj ect. getClass()). 1 
ength){ 

JOptionPane.showMessageDialog(null,”The array of the length of the fields 
does not correspond to the \n”+ 

“number of the fields. You need to correct the returned int array \n”+ 

“to the getFieldLengthsO method of the Class. The number of the \n”+ 
“elements of the array must be equal to the number of the fields \n”+ 

“of the class.\n I will assign default values for the length of the\n”+ 

“fields (temporary)”); 
fieldLength=new 

int}myJDOImplHelper.getFieldNames(mainFormObject.getClass()).length]; 
for(int i=0;i<fieldLength. length;i++) 
fieldLength}i]=20; 


} 


} 

catch(Exception e) 

{ e.printStackTraceO; 

JOptionPane.showMessageDialog(null,’T don’t have information about the 
length\n”+ 

“of the fields. I will use a default length\n”+ 


186 



“for the fields. If you want to have better\n”+ 

“representation of the data you should declare\n”+ 

“a public method in the “ +mainFormObject.getClass().getName()+”\n”+ 
“as bellow:\n\n”+ 

“public int[] getFieldLengths(){\n”+ 

“ return (the length of ALL the fields)\n”+ 

“}\n\n\n”+ 

“pzilidis@nps.navy.mil”); 

fieldLength=new 

int[myJDOImplHelper.getFieldNames(mamFormObject.getClass()).length]; 
for(int 1=0; i<fieldLength. length; i++) 
fieldLength[i]=20; 


return fieldLength; 


} 


/** Checks when a field is a collection then tries to 

*find what kind of objects holds that collection. If its 

* unable to do so raise a message 

* @param dataclassName the class of the collection field 

*/ 

public void prmtMessageNoSuchMethod(Strmg dataclassName)] 

JOptionPane.showMessageDialog(null,”I dont have information about the class “+ 
“of the collection field:”+ dataclassName+” “ +”You need to provide\n”+ 

“the class of the object that the above collection field will contain. \n”+ 

“Just add a public method in the “+ 

““ +mamFormObject.getClass().getName()+”\n”+ 

“as bellow:\n\n”+ 

“ public Class getTheTypeOfrheCollection(Strmg collectionName){\n”+ 

“ if (collectionName.equals(\”students\”“+”))”+ 

“ return Students.class;”+ 

“\n”+ 


“ }\n”+ 


return null;\n”+ 


“\n\n\n”+ 

“pzilidis@nps.navy.mil”); 


/** Checks if there is a setter method, otherwise 


raises a message 




187 



public void printNoSuchSetMethod(){ 

JOptionPane.showMessageDialog(null,”I cannot add the values to the speeific elass 

“+ 

“You need to provide\n”+ 

“a method in the class that will set the values to the objeet. \n”+ 

“Just add a public method in the “+ 

““ +mamF ormObj ect. getClassQ .getName()+”\n”+ 

“exactly with the same name as bellow:\n\n”+ 

“ public void setFieldValue(mt i,Object value){\n”+ 

“ switch (i) {\n”+ 

“ case 0:\n”+ 

“ setId(value.toStrmg());\n”+ 

“ break;\n”+ 

“ .\n”+ 

“ .\n”+ 

“\n”+ 

“ }\n\n\n”+ 

“Although you can navigate through the data you can not \n”+ 

“ add or modify (update ) the records without the above\n”+ 

“ in your class”+ 

“\n\n\n”+ 

“pzilidis@nps.navy.mil”); 


} 

/** Cheeks if there is a getter method, otherwise 
* raises a message 
*/ 

publie void prmtNoSuchGetMethod(){ 

JOptionPane.showMessageDialog(null,”I eannot retrieve the values to the specific 
class “+ 

“You need to provide\n”+ 

“a method in the elass that will provide the values to the object. \n”+ 

“Just add a public method in the “+ 

““ +mamFormObject.getClass().getName()+”\n”+ 

“exactly with the same name as bellow:\n\n”+ 

“ public Object getField(mt i){\n”+ 

“ switch (i) {\n”+ 

“ case 0:\n”+ 

“ return aireraft;\n”+ 

“ break;\n”+ 


188 





“ .\n”+ 

“ .\n”+ 

“\n”+ 

“ }\n\n\n”+ 


“\n\n\n”+ 

“pzilidis@nps.navy.mil”); 


} 


} 


2. The Class: MyBarChart,java 

MyBarChart 

* <p>Title: MyBarChart.java</p> 

* <p>Description; Creates a bar cliart</p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: CS JDO 

* @author Pasehalis Zilidis 

* @version 1.0 
*/ 

package test; 

import java.awt.Color; 
import java.awt.Dimension; 
import j ava. awt. GradientPaint; 
import javax.swing. JFrame; 

import org.jfree.chart.ChartFactory; 
import org.jfree.chart.ChartPanel; 
import org.jfree.chart.JFreeChart; 
import org j free. chart. axis. C ategory Axis; 
import org.jfree.chart.axis.CategoryLabelPositions; 
import org.jfree.chart.axis.NumberAxis; 
import org.jfree.chart.plot.CategoryPlot; 
import org.jfree.chart.plot.PlotOrientation; 
import org.jfree.chart.renderer.BarRenderer; 
import org.jfree.data.CategoryDataset; 
import org.jfree.data.DefaultCategoryDataset; 
import org.jfree.ui.ApplicationFrame; 
import org.jfree.ui.RefineryUtilities; 


189 






import j avax. swing. *; 

public class MyBarChart extends JPanel{ 


private ChartPanel ehartPanel; 

JComboBox jComboBoxl = new JComboBoxQ; 

* Construetor 

* 

* @param data the data 

* @param eategories the eategories 

* @param series 1 the series 
*/ 

publie MyBarChart(int[] data, String[] eategories,String seriesl) { 

CategoryDataset dataset = ereateDataset(data, eategories, seriesl); 
JFreeChart ehart = ereateChart(dataset); 

ehartPanel = new ChartPanel(ehart); 

ehartPanel.setPreferredSize(new Dimension(700, 400)); 

add(ehartPanel); 


} 


* Construetor 

* @param data the data 

* @param eategories the eategories 

* @param seriesl the series 

*/ 

publie MyBarChart(long[] data, String[] eategories,String seriesl) { 


CategoryDataset dataset = ereateDataset(data, eategories, seriesl); 
JFreeChart ehart = ereateChart(dataset); 

ehartPanel = new ChartPanel(ehart); 

ehartPanel.setPreferredSize(new Dimension(700, 400)); 

add(ehartPanel); 


} 


190 



/** 

* Creates a dataset 

* 

* @param data the data 

* @param categories the categories 

* @param series 1 the series 

* return the dataset 

*! 

private CategoryDataset createDataset(long[] data, String[] category,String series 1) { 
// create the dataset... 

DefaultCategoryDataset dataset = new DefaultCategoryDataset(); 
for (int i = 0; i < data.length; i++) { 

dataset.addValue(data[i], seriesl, category[i]); 

} 

return dataset; 

} 


* Creates a dataset 

* @param data the data 

* @param categories the categories 

* @param seriesl the series 

* return the dataset 

*/ 

private CategoryDataset createDataset(int[] data, String[] category,String seriesl) { 

String category 1 = “Category 1”; 

String category! = “Category 2”; 

// create the dataset... 

DefaultCategoryDataset dataset = new DefaultCategoryDataset(); 
for (int i = 0; i < data.length; i++) { 

dataset.addValue(data[i], seriesl, category[i]); 

} 

return dataset; 


} 


191 



* Creates a dataset 

* 

* @param data the data 

* @param eategories the eategories 

* @param series 1 the series 

* return the dataset 

*/ 

private CategoryDataset ereateDataset(double[] data, String[] eategory,String series 1) 


String eategory 1 = “Category 1”; 

String eategory! = “Category 2”; 

// ereate the dataset... 

DefaultCategoryDataset dataset = new DefaultCategoryDataset(); 
for (int i = 0; i < data.length; i++) { 

dataset.addValue(data[i], seriesl, eategory[i]); 

} 

return dataset; 

} 


/=t=* 

* Displays the ehart 

* @param title the title of the chart 

* 

public void toForm(String title) { 
JFrame jf= new JFrame(title); 
j f getContentPaneO. add(this); 
jfpackO; 
j f setV isible(true); 

} 


* Sets the dataset for the chart 

* 

* @param data the data 

* @param categories the categories 

* @param seriesl the series 


192 



public void setDataset(int[] data, String[] category,String seriesl){ 
CategoryDataset newdata=createDataset( data, category, series 1); 
JFreeChart ehart = ereateChart(newdata); 
ehartPanel.setCliart(ehart); 

} 


* Sets the dataset for the ehart 

* @param data the data 

* @param eategories the categories 

* @param series 1 the series 

* 

*! 

public void setDataset(doubIe[] data, String[] category,String seriesl){ 
CategoryDataset newdata=createDataset( data, eategory, series 1); 
JFreeChart ehart = ereateChart(newdata); 
ehartPanel.setChart(ehart); 

} 


* Sets the dimensions of the ehart 

* 

* @param x the x dimension 

* @param y the y dimension 

* 

*/ 

public void setDimension(int x , int y) { 

chartPanel.setPreferredSize(new Dimension(x, y)); 

} 


* Creates a sample ehart. 

* 

* @param dataset the dataset. 

* @return The ehart. 

*/ 

private JFreeChart ereateChart(CategoryDataset dataset) { 


193 



// create the ehart... 

JFreeChart chart = ChartFactory.createBarChart( 


“Bar Chart Demo”, // chart title 

“Category”, 

// domain axis label 

“Value”, 

// range axis label 

dataset. 

// data 

PlotOrientation.VERTICAL, // orientation 

true. 

// include legend 

true. 

// tooltips? 

false 

// URLs? 


); 


// set the background color for the chart... 

chart.setBackgroundPaint(new Color(OxBBBBDD)); 

// get a referenee to the plot for further eustomisation... 

CategoryPlot plot = chart.getCategoryPlot(); 

// set the range axis to display integers only... 

NumberAxis rangeAxis = (NumberAxis) plot.getRangeAxis(); 
rangeAxis.setStandardTickUnits(NumberAxis.oreateIntegerTiokUnits()); 

// disable bar outlines... 

BarRenderer renderer = (BarRenderer) plot.getRenderer(); 
renderer.setDrawBarOutline(false); 

// set up gradient paints for series... 

GradientPaint gpO = new GradientPaint( 

O.Of, O.Of, Color.blue, 

O.Of, O.Of, Color.lightGray 

); 

GradientPaint gpl = new GradientPaint( 

O.Of, O.Of, Color.green, 

O.Of, O.Of, Color.lightGray 

); 

GradientPaint gp2 = new GradientPaint( 

O.Of, O.Of, Color.red, 

O.Of, O.Of, Color.lightGray 

); 

renderer.setSeriesPaint(0, gpO); 
renderer.setSeriesPaint(l, gpl); 
renderer.setSeriesPaint(2, gp2); 

Category Axis domainAxis = plot.getDomainAxis(); 
domainAxis.setCategoryLabelPositions(CategoryLabelPositions.UP_90); 


194 



domainAxis.setMaxCategoryLabelWidthRatio(5.0f); 


return chart; 


} 

public MyBarChartO { 
try { 
jblnitO; 

} 

catch(Exception e) { 
e .prints tackT rac e(); 

} 

} 

private void jblnitQ throws Exception { 
this.add(jComboBoxl, null); 

} 


3, The Class: Populate,]ava 


Populate 

* <p>Title: Populate.)ava</p> 

* <p>Description; The class is used to add some records to the tables for the 

* implementation and the checking of the project </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: CS JDO 

* @author Paschalis Zilidis 

* @version 1.0 
*/ 

package test; 

import javax.jdo.PersistenceManagerPactory; 
import j avax.j do .PersistenceManager; 
import j avax j do .Transaction; 
import java.util.Date; 


import utils.Connection; 
import company.*; 
public class Populate { 


195 



private static PersistenceManagerFactory pmf; 
private static PersistenccManager pm; 
private static Transaction tx; 


public static void main(String[] args) { 
try { 

pmf = Connection.getPMF(args); 
pm = pmf getPersistenceManagerO; 
tx = pm.currentTransactionO; 
int identity = 0; 

Students student; 

Students studentl; 

studentl=new Students( ““+100,”paspartou”,’’ fname”+100, 0.0); 

Instructors instructor = null; 

Aircraft aircraft; 

AircraftType aircrafttype; 

Flights flight; 

Rank rank; 

Squadron squadron; 

Series series; 

BaseStadio bstadio; 

long debut = 0; 

String[] ins = {“Paschalis”, “Nikos”, “George”, “Tom”, “Malakas”}; 

String[] stu= {“papa”, “kilo”, “lima”, “charlie”, “echo”}; 

String}] bst= {“advance”, “beginers”, “fihter”, “initial”, “adaptive”}; 

String}] ser= {“72”, “73”, “74”, “75”, “76”}; 

// String}] depts = {“Sales”, “Marketing”, “RD”, “Admin”}; 

debut = System.currentTimeMihisO; 

System, out.println(“Creating instances “); 

String}] ranks = {“SEc Lieutenant”, “Lieutenant”, “Captain”, “Major”, 
“colonel”}; 

int nbComp = 5; 
int nbdpt = 4; 
int nbEmp = 6; 
for (int i = 0; i < 5; i++) { 
tx.beginO; 

series= new Series(ser}i],ser}i]+i); 
bstadio^new BaseStadio(bst}i],bst}i]+i); 


student=new Students} ““+i,stu}i],” fname”+i, 0.0); 
instructor= new Instructors(““+i, ins}i],”instr_name”+i, 0.0); 


196 



aircrafttype^new AircraftType(“T2-EBAck”,’’DEception”); 

rank= new Rank(““+i,ranks[i]); 

aircraft= new Aircraft(“10”+i,aircrafttype, 0.0); 

studentl .addInstructors( instructor); 

flight= new Elights( aircraft, instructor, student, new Date()); 

squadron=new Squadron(“34”+i,”description-”+i); 

pm. makePersistent(student); 

pm. makePersistent(instructor); 

pm.makePersistent(flight); 

pm. makePersistent(aircraft); 

pm.makePersistent(aircrafttype); 

pm. makePersistent(rank); 

pm.makePersistent(squadron); 

pm.makePersistent(bstadio); 

pm.makePersistent(series); 

try{ 

tx.commitO; 

System.out.println(“]”); 

} 

catch(javax.jdo.JDOException e) { 

System.out.println(“Problem: “+e); 

} 


} 


tx.beginO; 

pm.makePersistent(studentl); 

try{ 

tx.commitO; 

System. out.println(“] ”); 

} 

catch(javax.jdo.JDOException e) { 
System.out.println(“Problem: “+e); 

} 


} catch (Exception e) { 
e .prints tackX rac e(); 


197 



} 


} 


} 


4. The Class: PureSQL.java 

PureSQL 

* <p>Title: PureSQL.java</p> 

* <p>Description: Creates pure SQL COMMANDS retrieving 

* exactly the same result set as the JDOQL. These are used to asses the 

* performance of JDO in contrast to that of JDBC</p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: CS JDO 

* @author Paschalis Zilidis 

* @version 1.0 
*/ 

package test; 


import j ava. sql.DriverManager; 
import java.sql.SQLException; 
import java.sql.Connection; 
import java.sql.Statement; 
import java.sql.ResultSet; 

import j avax.swing. *; 


* 

*/ 

class PureSQL { 

* multi Constructor 

public PureSQL( ) { 


} 


198 




II - 

// Main method 

H - 

public static void main(String[] args) { 

} 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll^ 

/* creates and executes a GROUP BY query. 

* The method iterates or not through the result 

* set when a boolean is true or false accordingly 

* 

* @param iteration The boolean that determine if we will 

* iterate through the result or not 

* @retum the time that takes for the retrieval of the result 

*/ 

public static long showGROUPBYInstructorsHours( boolean iteration)! 
String sql=“SELECT a.instructor id, SUM(a.endurance) “+ 

“EROM c_flights a “+ 

“GROUP BY a.instructor id 

return getQuery( sql,iteration); 

} 

lllllllllllllllllllllllllllllllllllllllllllllllllllll 


/* creates and executes a SEEECT query. 

* The method iterates or not through the result 

* set when a boolean is true or false accordingly 

* @param iteration The boolean that determine if we will 

* iterate through the result or not 

* @retum the time that takes for the retrieval of the result 

*/ 

public static long showSEEECTQueryPlights( boolean iteration)) 
String sql=“SEEECT * PROM c flights 

return getQuery( sql,iteration); 


} 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 


199 





/* EXECUTES A QUERY AND RETURN THE TIME HAS BEEN TAKEN 

* EOR THE EXECUTION. 

* @param sql the SQE command 

* @param iteration The boolean that determine if we will 

* iterate through the result or not 

* @retum the time that takes for the retrieval of the result 

*/ 

public static long getQuery(String sql,boolean iteration)! 
long timeStart=System.currentTimeMillis() ; 

System.out.println(“GROUP BY: “+iteration+” timeStart:”+ timeStart); 

Connection connection; 
try{ 

Class.forName(“com.mysql.jdbc.Driver”); 

String dburl=“jdbc:mysql://localhost/pilotdb”; 

String username=““; 

String password=““; 

connection = DriverManager.getConnection(dburl); 

System. out.println(“Eyruthing ok”); 

Statement statement= connection.createStatement(); 

ResultSet rset=statement.executeQuery(sql); 
int k=0; 
if (iteration) 

while (rset.next()){ 
k++; 

String s=rset.getString(l); 

//System.out.println(k+” “+s); 

}//do nothing just iterate 


} 

catch(ClassNotEoundException e){ 

System.out.println(“Database driver not found.”); 

} 

catch(SQEException e){ 

System.out.println(“Error opening db connection: “+ e.getMessage()); 


} 

long timeStop=System.currentTimeMillis() ; 


200 



System.out.println(“GROUP BY”+ timeStop); 
System.out.println(“GROUP BY”+(timeStop-timeStart)); 
return timeStop-timeStart; 


} 


} 


5, The Class: QueryForm.java 


QueryForm 

* <p>Title: QueryForm.java</p> 

* <p>Description: Contains the JDOQL queries that we will 

* use in our application </p> 

* 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: CS JDO 

* @author Paschalis Zilidis 

* @version 1.0 

*/ 

package test; 

lllllllllllllllllllllllllllllllllllllllllllllllllll 

lllllllllllllllllllllllllllllllllllllllllllllllllll 

import j avax.j do. JDOHelper; /////// 

import javax.jdo.PersistenceManagerFactory; /////// 
import javax.jdo.PersistenccManager; /////// 

import javax.jdo.Transaction; ////// 

import javax.jdo.Query; /////// 

import java.io.FileInputStream; /////// 

import java.io.IOException; /////// 

import java.io.InputStream; //////// 

import javax.jdo.spi.JDOImplHelper; /////// 

import j avax.j do.*;///////// /////// 

/////////////////////////////////////////////////// 
/////////////////////////////////////////////////// 

import company.*; 
import j avax.swing. *; 
import j avax. swing .event. *; 
import java.awt.*; 
import j ava. awt. event. *; 


201 





import javax.swing. JComboBox; 

import java.util.*; 

import java.text.DecimalFormat; 

* Constructor 

*/ 

class QueryForm extends JFrame { 

H . 

H . 

private static PersistenceManagerFactory pmf; 
private statie PersistenceManager pm; 
private static Transaction tx; 
private statie Query q; 
private static Collection result; 

private JPanel topPanel; 
private JPanel formPanel; 
private JComboBox squadronComboBox; 

private JComboBox seriesComboBox; 

* Default frame width 

*/ 

private static final int FRAME WIDTH = 800; 

* Default frame height 

*/ 

private statie final int FRAME HEIGHT =480; 

* X eoordinate of the frame default origin point 

*/ 

private statie final int ERAME X ORIGIN = 150; 

* Y eoordinate of the frame default origin point 

*/ 

private statie final int ERAME_Y_ORIGIN = 250; 

/=t=* 

* multi Construetor 

*/ 

publie QueryEorm( ) { 


202 





try { 

pmf = getPMF( “lido mysql.properties”); 
pm = pmf.getPersistenceManagerO; 
tx = pm.currentTransactionO; 

Container contentPane=getContentPane(); 

contentPane.setLayout(new BorderLayout()); 
topPanel= new JPanelQ; 


} 

eatch (Exeeption e){e.printStaekTraee();}; 


} 

H - 

// Main method 

H - 

publie statie void main(String[] args) { 
QueryForm f=new QueryForm( ); 
f.paekO; 

f.setVisible(true); 

} 


/** Query the flight table and seareh for a speeifie 

* instruetor 

* @param pm the Persistenee Manager 

* @param inst the speeifie Instruetor 

* @return a eolleetion of the result 

*/ 

publie statie Colleetion queryTheFlights(PersisteneeManager pm, Instructors inst) { 
Extent extent=pm.getExtent(Flights.class,true); 

String filter=“instructor==inst”; 

Query query=pm.newQuery(extent,fdter); 
query.declareParameters(“Instructors inst”); 

Collection result=(Collection) query.execute(inst); 

return result; 

} 


203 





/**gets the persistent manager factory 

* @param path the url path 

* @return the persistent manager factory 

*/ 

public static PersistenceManagerFactory getPMF(String path) { 
try { 

InputStream propStream = 
new FilelnputStream(path); 

Properties props = new PropertiesQ; 
props.load(propStream); 

props.put(“javax.jdo.PersistenceManagerFactoryClass”, 

“com. libelis. lido .PersistenceManagerF actory”); 

return JDOHelper.getPersistenceManagerFactory(props); 

} catch (lOException e) { 
e .prints tackX rac e(); 

System.exit(-l); 
return null; 

} 

} 

/** Tests the query 

*/ 

private void testTheQuery(ActionEvent e){ 

JButton jb=(JButton) e.getSourceQ; 

Hi have put the button to the Categories form 
InstructorsEorm iform=(InstructorsEorm) jb.getParentQ; 

Categories cat=(Categories) iform.getCurrentRecordQ; 

EinkedList list= new EinkedList( QueryGetEhghtsExcerciseReportPerCategory( 
cat)); 

JEist j2=new JEist(list.toArray()); 

JPanel l=new JPanelQ; 
l.add(new JButton()); 
l.addG2); 

JScrollPane jsp=new JScrollPane(l); 


204 



JFrame myframe =new JFrame(); 

Container cont=myframe.getContentPane(); 

cont.add(jsp); 

myframe.packO; 

myframe. setV isib le(true); 


} 


llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH 
//////////////////////FLIGHTS QUERIES//////////////////////////////////////////////////////// 
//////////////////////////////////////////////////////////////////////////////////////////// 
//////EEIGHTS QUERIES//////////////////////////////////////////////////////////////////////// 


/** Query the flights table 

* @param pm the Persistenee Manager 

* 

* @return a collection of the result 

*/ 


public static Collection QueryGetPlights(PersistenceManager pm) { 


Extent extent=pm.getExtent(Elights.class,true); 
Query query=pm.newQuery(extent); 

Collection result=(Collection) query.execute(); 
query.close(result); 
return result; 


} 


/** Query the flights table 

* @param pm the Persistence Manager 

* @return a collection of the result 

*! 

public static Collection QueryGetPlightsSQE(PersistenceManager pm){ 


//Extent extent=pm.getExtent(Elights.class,true); 

Query query=pm.newQuery(“sql”,’’SEEECT * EROM c flights”); 


205 



query. setC lass (Flights .class); 

Collection result=(Collection) query.execute(); 
query.close(result); 
return result; 


} 

/** Query the flight table and GROUP BY THE 

* instructors 

* @param pm the Persistence Manager 

* 

* @return a collection of the result 

*/ 

public static Collection QueryGetFhghtsSQLGROUPBY(PersistenceManager pm){ 

String sql=“SELECT a.instructor id, SUM(a.endurance) “+ 

“FROM c_fhghts a “+ 

“GROUP BY a.instructor id 


Query query=pm.newQuery(“sql”,sql); 
query. setC lass (Flights .class); 

Collection result=(Cohection) query.execute(); 
query.close(result); 
return result; 


} 


/** Query the flights table and search for a specific 

* date 

* @param pm the Persistence Manager 

* @param d the date 

* @return a collection of the result 

public static Collection QueryGetFhghtsDailyReport(PersistenceManager pm, Date 


Extent extent=pm.getExtent(Fhghts.class,true); 
String fdter=“date==d”; 

Query query=pm.newQuery(extent,fdter); 


206 



query.declareImports(“importjava.util.Date”); 
query.deelareParameters(“Date d”); 

Collection result=(Collection) query.execute(d); 
query.close(result); 
return result; 


} 

/** Query the flights table and search the results for a specific 

* date and squadron 

* @param pm the Persistence Manager 

* @param squad the Squadron 

* @param d the d 

* @return a collection of the result 
*/ 

public static Collection QueryGetFlightsDailyReportPerSquadron(PersistenceManager 
pm,Date d, Squadron squad) { 


Extent extent=pm.getExtent(Flights.class,true); 

String fdter=“date==d && squadron==squad”; 

Query query=pm.newQuery(extent,fdter); 
query.declareImports(“importjava.util.Date”); 
query.declareParameters(“Date d. Squadron squad”); 
Collection result=(Collection) query.execute(d,squad); 
query.close(result); 
return result; 


} 


//the field might be private however here the JDOQE seem to have access 
// directly to them using the dot(.) operator i.e. flights.exercise 
/** Query the flights table and search the results for a specific 

* category 

* @param cat the category 

* 

* @return a collection of the result 

*/ 

public Collection QueryGetElightsExcerciseReportPerCategory(Categories cat){ 


Extent extent=pm.getExtent(Elights.class,true); 


207 



String filter=“exercise.categories==cat”; 

Query query=pm.newQuery(extent,filter); 

//query.deelareImports(“importjava.util.Date”); 
query.deelareParameters(“Categories cat”); 
Collection result=(Collection) query.execute(cat); 

return result; 


} 


/** Query the flights table and search the results for a specific 

* year and month 

* @param pm the Persistence Manager 

* @param year the year 

* @param month the month 

* @return a collection of the result 

*/ 

public static Collection QueryGetFlightsMonthlyReportAllSquadrons( 
PersistenceManager pm, int month, int year) { 

Calendar cl = new GregorianCalendar(year,month,l) ; 
if(month==l 1){ 
year+=l; 
month=0; 

} 

else 

month+=l; 

Calendar c2= new GregorianCalendar(year,month,l) ; 

Date beginDate=c 1 .getTime(); 

Date endDate=c2.getTime(); 

Extent extent=pm.getExtent(Flights.class,true); 

String filter=“date>=beginDate && date<endDate”; 

Query query=pm.newQuery(extent,filter); 

query.declareImports(“importjava.util.Date”); 

query.declareParameters(“Date beginDate, Date endDate”); 

Collection result=(Collection) query.execute(beginDate,endDate); 

query.close(result); 

return result; 


} 


208 



/** Query the flights table and seareh the results for a specific 

* Squadron for a specific year and month 

* @param pm the Persistence Manager 

* @param year the year 

* @param month the month 

* @param squad the Squadron 

* @return a collection of the result 
*/ 

public static Collection QueryGetFlightsMonthlyReportPerSquadron( 
PersistenceManager pm,int month, int year, Squadron squad) { 

Calendar cl = new GregorianCalendar(year,month,l) ; 
if(month==l 1){ 
year+=l; 
month=0; 

} 

else 

month+=l; 

Calendar c2= new GregorianCalendar(year,month,l) ; 

Date beginDate=c 1 .getTime(); 

Date endDate=c2.getTime(); 

//JOptionPane.showMessageDialog(null,beginDate+”-“+endDate); 

Extent extent=pm.getExtent(Flights.class,true); 

String fdter=“date>=beginDate && date<endDate && squadron==squad”; 
Query query=pm.newQuery(extent,fdter); 
query.declareImports(“importjava.util.Date”); 

query.declareParameters(“Date beginDate, Date endDate, Squadron squad”); 
Collection result=(Collection) query.execute(beginDate,endDate, squad); 
query.close(result); 
return result; 


} 


/** Query the flights table and search the results for a specific 

* student in a Squadron for a specific year and month 

* @param stude the Student 

* @param year the year 

* @param month the month 

* @param squad the Squadron 

* @return a collection of the result 
*/ 


209 




public static Collection QueryGetFlightsMonthlyReportPerSquadronPerStudent( 
int month, int year, Squadron squad. Students stude){ 

Calendar cl = new GregorianCalendar(year,month,l) ; 
if(month==l 1){ 
year+=l; 
month=0; 

} 

else 

month+=l; 

Calendar c2= new GregorianCalendar(year,month,l) ; 

Date beginDate=c 1 .getTime(); 

Date endDate=c2.getTime(); 

//JOptionPane.showMessageDialog(null,beginDate+”-“+endDate); 

Extent extent=pm.getExtent(Flights.class,true); 

String fdter=“date>=beginDate && date<endDate && squadron==squad && 
student=stude”; 

Query query=pm.newQuery(extent,fdter); 
query.declareImports(“importjava.util.Date”); 

query.declareParameters(“Date beginDate, Date endDate, Squadron squad. Students 
stude”); 

Objeet[] parameters={beginDate,endDate, squad, stude}; 

Colleetion result=(Collection) query.executeWithArray(parameters); 
query.close(result); 
return result; 


} 


/** Query the flights table and seareh the results for a speeific 

* instructor in a Squadron for a specific year and month 

* @param Inst the instructor 

* @param year the year 

* @param month the month 

* @param squad the Squadron 

* @return a eollection of the result 
*/ 

publie static Collection QueryGetElightsMonthlyReportPerSquadronPerInstructor( 
int month, int year. Squadron squad. Instructors instr){ 

Calendar el = new GregorianCalendar(year,month,l) ; 


210 




if(month==l 1){ 
year+=l; 
month=0; 

} 

else 

month+=l; 

Calendar c2= new GregorianCalendar(year,month,l) ; 

Date beginDate=c 1 .getTime(); 

Date endDate=c2.getTime(); 

//JOptionPane.showMessageDialog(null,beginDate+”-“+endDate); 

Extent extent=pm.getExtent(Flights.class,true); 

String filter=“date>=beginDate && date<endDate && squadron==squad && 
instructor=instr”; 

Query query=pm.newQuery(extent,filter); 
query.declareImports(“importjava.util.Date”); 

query.declareParameters(“Date beginDate, Date endDate, Squadron squad, 
Instructors instr”); 

Object[] parameters={beginDate,endDate, squad,instr}; 

Collection result=(Collection) query.executeWithArray(parameters); 
query.close(result); 
return result; 


} 


/** Query the flights table and search the results for a specific 

* series 

* @param pm the Persistence Manager 

* @param serie the Series 

* @return a collection of the result 

*/ 

public static Collection QueryGetFhghtsPerSeries(PersistenceManager pm. Series 
serie) { 


Extent extent=pm.getExtent(Elights.class,true); 
String filter=“student.series==serie”; 

Query query=pm.newQuery(extent,filter); 

//query.declareImports(“importjava.util.Date”); 
query.declareParameters(“Series serie”); 

Collection result=(Collection) query.execute(serie); 


211 




query.close(result); 
return result; 


} 


lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 
IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH^ 
iiiiiiiiiiiiiiiiiiiiiiiiiiiimsjmjCTOKS Q\]m.Yiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii 
iiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii^ 
///INSTRUCTORS QUERY//////////////////////////////// 


/** Query the Instructors table and search the results for a specific 

* squadron 

* @param pm the Persistence Manager 

* @param squad the Squadron 

* @return a collection of the result 

*/ 


public static Collection QueryGetInstructorsPerSquadron(PersistenceManager pm, 
Squadron squad) { 


Extent extent=pm.getExtent(Instructors.class,true); 
String fdter=“squadron==squad”; 

Query query=pm.newQuery(extent,fdter); 

//query.declareImports(“importjava.util.Date”); 
query.declareParameters(“Squadron squad”); 
Collection result=(Collection) query.execute(squad); 
query.close(result); 
return result; 


} 


///////////////////////////////////////////////////////////////////////////////// 
///////////////////////////////////////////////////////////////////////////////// 
////////////////////////////STUDENTS QUERY/////////////////////////////////////// 
///////////////////////////////////////////////////////////////////////////////// 
///STUDENTS QUERY//////////////////////////////// 


/** Query the Students table and search the results for a specific 
* squadron 


212 



* @param pm the Persistence Manager 

* @param squad the Squadron 

* 

* @return a collection of the result 

*/ 

public static Collection QueryGetStudentsPerSquadron(PersistenceManager pm, 
Squadron squad) { 


Extent extent=pm. getExtent(Students .class,true); 
String fdter=“squadron==squad”; 

Query query=pm.newQuery(extent,fdter); 

query.declareParameters(“Squadron squad”); 
Collection result=(Collection) query.execute(squad); 
query.close(result); 
return result; 


} 


/** Query the Students table and search the results for a specific 

* series 

* @param pm the Persistence Manager 

* @param serie the Series 

* 

* @return a collection of the result 

*/ 

public static Collection QueryGetStudentsPerSeries(PersistenceManager pm, Series 
serie) { 


Extent extent=pm. getExtent(Students .class,true); 
String filter=“series==serie”; 

Query query=pm.newQuery(extent,fdter); 

query.declareParameters(“Series serie”); 

Collection result=(Collection) query.execute( serie); 
query.close(result); 
return result; 


} 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 


213 



IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH 
IIIIIIIIIIIIIIIIIIIIIIIIIIIISQVKDMmS Q\]m.YIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIII 
lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll^ 
///SQUADRONS QUERY//////////////////////////////// 

/** Query the Squadron table and search the results 

* @param pm the Persistence Manager 

* 

* @return a collection of the result 

*/ 

public static Collection QueryGetSquadrons(PersistenceManager pm){ 


Extent extent=pm.getExtent(Squadron.class,true); 
Query query=pm.newQuery(extent); 


Collection result=(Collection) query.execute(); 
query.close(result); 
return result; 


} 

/////////////////////////////////////////////////////////////////////////////////// 
/////////////////////////////////////////////////////////////////////////////////// 
////////////////////////////SERIES QUERY/////////////////////////////////////////// 
/////////////////////////////////////////////////////////////////////////////////// 
///SERIES QUERY//////////////////////////////////////////////////////////////////// 


/** Query the Stadio table and search the results 

* for a specific series 

* @param pm the Persistence Manager 

* @param serie the Series 

* 

* @return a collection of the result 

*/ 

public static Collection QueryGetStadioPerSeries(PersistenceManager pm, Series serie 


Extent extent=pm.getExtent(Stadio.class,true); 
String filter=“series==serie”; 

Query query=pm.newQuery(extent,fdter); 

query.declareParameters(“Series serie”); 


214 



Collection result=(Collection) query.execute(serie); 
query.close(result); 
return result; 


} 


} 


6, The Class: ReportsForm.java 


ReportsForm 

* <p>Title: ReportsForm.java</p> 

* <p>Description; Creates THE gui FOR THE REPRESENTATION OE THE 

* REPORTS OP THE VARIOUS TABEES </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: CS JDO 

* @author Paschalis Zilidis 

* @version 1.0 

V 


package test; 

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 


import j avax.j do. JDOHelper; /////// 

import javax.jdo.PersistenceManagerPactory; /////// 
import javax.jdo.PersistenccManager; /////// 

import javax.jdo.Transaction; /////// 

import javax.jdo.Query; /////// 

import java.io.PileInputStream; /////// 

import java.io.IOException; /////// 

import java.io.InputStream; /////// 

import javax.jdo.spi.JDOImplHelper; /////// 

import javax.jdo.*; //////// 


llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 


import java.sql.DriverManager; 
import java.sql.SQLException; 
import java.sql.Connection; 
import java.sql.Statement; 
import java.sql.ResultSet; 


215 





import company.*; 

import j avax. swing. *; 

import j avax. swing .event. *; 

import java.awt. *; 

import j ava. awt. event. *; 

import javax.swing. JComboBox; 

import java.util.*; 

import java.text.DeeimalFormat; 

elass ReportsForm extends JFrame implements AetionListener, MouseListener{ 

H . 

H . 

private statie PersistenceManagerFaetory pmf; 
private statie PersisteneeManager pm; 
private statie Transaetion tx; 
private statie Query q; 
private statie Colleetion result; 

H . 

H . 


* The top level panel used in showing a dialog using JOptionPane's 

* elass method showOptionDialog. 

*/ 

private JPanel topPanel; 

* The formpanel level panel used in showing the eurrent form 

* that displays data 

*/ 

private JPanel formPanel; 

* The squadronComboBox is a JComboBox that holds all 

* the squadrons we ean choose from for various \ 

* queries 

*/ 

private JComboBox squadronComboBox; 

/=t=* 

* The seriesComboBox is a JComboBox that holds all 

* the series we ean ehoose from for various \ 

* queries 


216 







*/ 

private JComboBox seriesComboBox; 

* The yearComboBox is a JComboBox that holds all 

* the years we ean ehoose from for various \ 

* queries 

*/ 

private JComboBox yearComboBox; 

* The monthComboBox is a JComboBox that holds all 

* the months we ean ehoose from for various \ 

* queries 

*/ 

private JComboBox monthComboBox; 

* The dateSpinner is a JSpinner that 

* we can choose various dates for various \ 

* queries 

*/ 

private JSpinner dateSpinner; 

/**is the JDOImplHelper 

*/ 

JDOImplHelper my JDOImplHelper; 

* Default frame width 

*/ 

private static final int FRAME WIDTH = 800; 

* Default frame height 

*! 

private static final int FRAME HEIGHT =480; 

* X coordinate of the frame default origin point 

*/ 

private static final int ERAME_X_ORIGIN = 150; 

* Y coordinate of the frame default origin point 

*/ 

private static final int ERAME_Y_ORIGIN = 250; 


217 



^CONSTRUCTOR 

*/ 

public ReportsForm( ) { 


try { 

pmf = getPMF( “lido mysql.properties”); 
pm = pmf.getPersistenceManagerO; 
tx = pm.currentTransactionO; 

Container contentPane=getContentPane(); 
myJDOImplHelper=JDOImplHelper.getInstance(); 
contentPane.setLayout(new BorderLayout()); 
topPanel= new JPanelQ; 

squadronComboBox=new 

JComboBox(getTheDataForComboBoxes(Squadron.elass).toArray()); 

seriesComboBox=new 

JComboBox(getTheDataForComboBoxes(Series.elass).toArray()); 

yearComboBox=new JComboBox(); 

Objeet[] aryear=new Objeet[40]; 
for(int i=0;i<40;i++) 

aryear[i]= new Integer(2004+i); 
yearComboBox=new JComboBox(aryear); 

Objeet[] 

annonth={“Jan”,”Feb”,”Mareh”,’’April”,’’May”,’’June”,’’July”,’’August”, 
“September”,”Oetomber”,”November”,”December”}; 
monthComboBox=new JComboBox(armonth); 

topPanel.add(squadronComboBox); 

topPanel.add(seriesComboBox); 

topPanel.add(monthComboBox); 

topPanel.add(yearComboBox); 

dateSpinner=new JSpinner(new SpinnerDateModel() ) ; 
topPanel.add(dateSpinner); 

eontentPane.add(topPanel, BorderLayout.NORTH ); 
formPanel=new JPanel(); 

eontentPane.add(formPanel, BorderLayout.CENTER ); 

oontentPane.add(oreateToolBar( ),BorderEayout.WEST); 
oontentPane.add(oreateToolBar( ),BorderLayout.EAST); 


218 



} 

catch (Exception e){e.printStackTrace();}; 

} 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 


/**gets data form a table that is represented by 

* a elass and store them in list boxes 

* @param dataelassName the elass 

* @return the result set eontaining the data 

*/ 

publie Colleetion getTheDataForListBoxes(String dataelassName) { 

Colleetion sresult; 
boolean wasAetive=true; 

if(!tx.isAetive()){ 

tx.beginO; 

wasAetive=false; 

} 

q = pm.newQuery(dataelassName); 
sresult = (Colleetion) q.exeoute(); 
tx.eommitO; 
if(wasAotive) 
tx.beginO; 

return sresult; 


} 

/**gets data form a table that is represented by 

* a class and store them in eombo boxes 

* @param dataelass the elass 

* @return the result set eontaining the data 

*/ 

publie statie Colleetion getTheDataForComboBoxes(Class dataelass)) 
Colleetion sresult; 
boolean wasAetive=true; 
if(!tx.isAetive()){ 
tx.beginO; 
wasAetive=false; 

} 


219 



q = pm.newQuery(dataclass); 
sresult = (Collection) q.execute(); 


tx.commitO; 

if(wasActive) 

tx.beginO; 

return sresult; 


} 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

H - 

// Main method 

H - 

public static void main(String[] args) { 

SquadronsForm f=new SquadronsForm( ); 
f.packO; 

f.setVisible(true); 

} 

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 


H - 

// actionPerformed 
H - 


public void actionPerformed(ActionEvent event) { 

if (event.getActionCommand().equals(“exerciseSampleQuery”)) { 

testTheQuery( event); 

} 


} 


* Creates a toolbar with button for every form 

* we are going to display 

* 

*/ 

private JToolBar createToolBar( ) { 


220 







JButton button; 

JToolBar toolbar = new JToolBar(); 
toolbar.addSeparatorO; 


button = toolbar. add( 

new AbstraetAetion(“Instruetors Monthly”) { 
publie void aotionPerformed(AotionEvent e) { 

Object obiect=squadronComboBox.getSelectedItem(); 
if(object!=null){ 

Squadron squad=(Squadron) object; 

int year= ((Integer) yearComboBox.getSelectedItem()).intValue(); 
int month=monthC omboB ox. getS electedlndex(); 
//showInstructors( squad); 

showInstructorsMonthlyHours( squad, month, year); 

} 

} 

}); 

button. setToolTipText(“Instructors Monthly”); 
toolbar.addSeparatorO; 


button = toolbar. add( 

new AbstractAction(“Students Monthly”) { 
public void actionPerformed(ActionEvent e) { 

Object object=squadronComboBox.getSelectedItem(); 
if(object!=null){ 

Squadron squad=(Squadron) object; 

int year=((Integer) yearComboBox.getSelectedItem()).intValue(); 
int month=monthC omboB ox. getS electedlndex(); 

showStudentsMonthlyHours( squad, month, year); 


} 


} 

}); 

toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“Arcrafts Daily”) { 


221 



public void actionPerformed(ActionEvent e) { 

Object obiect=squadronComboBox.getSeIectedItem(); 
if(object!=nuII){ 

Squadron squad=(Squadron) object; 

Date d =(Date) dateSpinner.getValue() ; 
showAircraftsDailyHoursPerSquadron( squad, d ); 

} 


} 

}); 

tooIbar.addSeparatorO; 
button = toolbar. add( 

new AbstractAction(“Aierafts Monthly”) { 
publie void actionPerformed(ActionEvent e) { 

Object object=squadronComboBox.getSelectedItem(); 
if(object!=null){ 

Squadron squad=(Squadron) object; 

int year=((Integer) yearComboBox.getSelectedItem()).intValue(); 
int month=monthC omboB ox. getS electedlndex(); 

showAircraftsMonthlyHoursPerSquadron( squad, month, year); 

} 

} 

}); 

button.setToolTipText(“Aierafts Monthly”); 
tooIbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“Squadron's Monthly”) { 
public void actionPerformed(ActionEvent e) { 

Object object=squadronComboBox.getSelectedItem(); 
if(object!=null){ 

Squadron squad=(Squadron) object; 

int year= ((Integer) yearComboBox.getSelectedItem()).intValue(); 
int month=monthC omboB ox. getS electedlndex(); 

showSquadronsMonthlyHours( squad, month, year); 

} 

} 

}); 

button.setToolTipText(“ Squadron's Monthly”); 
tooIbar.addSeparatorO; 


222 



button = toolbar. add( 

new AbstractAction(“All Squad. Monthly”) { 
public void actionPerformed(ActionEvent e) { 

Object obiect=squadronComboBox.getSelectedItem(); 
if(object!=null){ 

Squadron squad=(Squadron) object; 

int year=((Integer) yearComboBox.getSelectedItem()).intValue(); 
int month=monthC omboB ox. getS electedlndex(); 

showALLSquadronsMonthlyHours( squad, month, year); 

} 

} 

}); 

button.setToolTipText(“ Squadron's Monthly”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“JDO JDBC test”) { 

public void actionPerformed(ActionEvent e) { 
showGROUPBYInstructorsHours(); 

} 

}); 

button.setToolTipText(“ JDO JDBC test”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“add 100 flights”) { 

public void actionPerformed(ActionEvent e) { 
addlOOElightO; 


} 

}); 

button.setToolTipText(“ add 100 flights”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“Magic “) { 

public void actionPerformed(ActionEvent e) { 

Object object=seriesComboBox.getSelectedItemO; 
if(object!=null){ 

Series series=(Series) object; 

showALEExcercisesPerSeries( series); 

} 


} 

}); 


223 



button.setToolTipText(“ Magic”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“Magic 2”) { 

public void actionPerformed(ActionEvent e) { 

Object obiect=seriesComboBox.getSelectedItem(); 
if(object!=null){ 

Series series=(Series) object; 

showALLExcercisesPerSeriesForEVERYStudent(series ); 

} 

} 

}); 

button. setToolT ipText(“ Magic”); 
toolbar.addSeparatorO; 


toolbar.setEayout(new GridEayout(0, 1)); 


return toolbar; 

} 


H . 

H . 

/**gets the PersisteneeManagerEaetory 

* @param pathteh url 

* @retum the PersisteneeManagerEaetory 
*/ 

public static PersisteneeManagerEaetory getPMF(String path) { 
try { 

InputStream propStream = 
new FilelnputStream(path); 

Properties props = new PropertiesQ; 
props.load(propStream); 

//!!!!!!ti kanv edv!!!!! 

props.put(“javax.jdo.PersistenceManagerFactoryClass”, 
“com. libelis. lido .PersistenceManagerF actory”); 

return JDOHelper.getPersistenceManagerFactory(props); 

} catch (lOException e) { 
e .prints tackX rac e(); 


224 







System.exit(-l); 
return null; 

} 


} 


* @param e */ 

public void mouseClicked(MouseEvent e) { 

} 


* @param e */ 

public void mousePressed(MouseEvent e) { 

} 


* @param e */ 

public void mouseReleased(MouseEvent e) { 

} 

* @param e */ 

public void mouseEntered(MouseEvent e) { 

} 

* @param e */ 

public void mouseExited(MouseEvent e) { 

} 

lllllllllllllllllllllllllllllllllllllllllllllllllllll 


/** Shows the exercise per series for every student 
* @param series the series 

*! 

public void showALEExcercisesPerSeriesEorEVERYStudent(Series series ){ 

Object[]arStudent = QueryPorm.QueryGetStudentsPerSeries(pm, series).toArray(); 
Obj ect[] [] [] []arStudentExer=new Obj ect[arStudent. length] [] [] []; 


225 



Object[][][] arExer=getALLExcercisesFromSeries( series ); 

Object[][][] arResult=new Object[arExer.length][][]; 

//ereate an equal array with zero values 
for(int i=0;i<arResult.length;i++) { 

arResult[i]=new Object[arExer[i].length][]; 
for(int j=0;j<arResult[i].length;]++) { 

arResult[i][j]=new Objeet[ arExer[i][j].length ]; 
Arrays.fill( arResult[i][j], ““ ) ; 

} 

} 


for(int i=0;i<arStudentExer.length;i++) { 
arStudentExer[i]=arrayCopy( arResult); 

} 

Colleetion e=QueryEorm.QueryGetEhghtsPerSeries( pm, series); 


Iterator iter=c.iterator(); 

while(iter.hasNext()) { 

Flights flight=( (Flights) iter.next() ); 

Students student=flight.getStudent(); 

Exereise exereise=flight.getExercise(); 
if(student!=null && exereise !=null){ 
for (int i=0;i<arStudent.length;i++) 
if(( arStudent[i]).equals(student) ){ 

// JOptionPane.showMessageDialog(null,”lama”); 
findAndInformTheExercise( arExer, arStudentExer[i], flight); 

} 

} 

} 


JTabbedPane tabs^new JTabbedPane(); 
for(int i=0;i<arExer.length;i++) { 

Stadio stadio=(Stadio ) arExer[i][0][0]; 

JTabbedPane tabeat=new JTabbedPane(); 
tabs.addTab(stadio.getId(),tabeat); 
for(int j=0;j<arExer[i] .length;j++) { 

Categories eategories= (Categories) arExer[i][j][l]; 
if (eategories!=null){ 
lllllllllllllllllllllllllllllllll 


226 



Object[][] aro^new Object[arStudent.length][]; 
for(int r=0;r<arStudent.length;r++) { 
aro[r]= arStudentExer[r][i][j]; 
aro[r][0]=arStudent[r]; 

//JOptionPane.showMessageDialog(null,aro[r]); 

} 

Obiectri arColumn=arrayCopy( arExerriiril): 

arColumn[0]=“Student”; 

arColumn[ 1 ]=“Category”; 

for(int h=2;h<arColumn.length;h++) 

arColumn[h]=((Exercise) arColumn[h]).getId(); 

JTable table= new JTable(aro, arColumn ); 
tabcat.addTab(categories.getId(),new JScrollPane(table) ); 

} 

} 

} 

showThePorm( tabs); 


} 

/**find the exereise type and stores them in a array 

* @param arExer an array eontaining the exreise 

* @param arStudentExer an array eontaining the exereises that 

* the student has fly 

* @param flight the eurrent flight 
*/ 

publie void findAndInfonnTheExereise(Objeet[][][] arExer,Objeot[][][] arStudentExer, 
Elights flight) { 

if (flight.getExereise()!=null) 
for(int j=0;j<arExer.length;j++) 

for(int k=0;k<arExer[j] .length;k++) 

for(int m=0;m<arExer[j][k].length;m++){ 

Objeet ex= arExer[j][k][m] ; 
if(ex!=null) 

if( ex.equals(flight.getExereise() ) ){ 

arStudentExer[j] [k] [m] =flight.getSpeeialType(); 
break; 

} 

} 

} 

llllllllllllllllllllllllllllllllllllllllllllllllllllll 

llllllllllllllllllllllllllllllllllllllllllllllllllllll 

lllllllllllllllllllllllllllllllllllllllllllllllllllll 


111 



/** Creates a copy of an dimensional array 

* @param aray the source array 

* @return a copy of an array */ 

public Object[] arrayCopy(Object[] aray){ 
Object[] ar=new Object[aray.length]; 
for(int i=0;i<aray.length;i++) 
ar[i]=aray[i]; 

return ar; 

} 

/**Creates a copy of a two-dimensional array 

* @param aray the source array 

* @return a copy of a two-dimensional array 

*/ 

public Object[][] arrayCopy(Object[][] aray){ 
Object[][] ar=new Object[aray.length][]; 
for(int i=0;i<aray.length;i-l-l-){ 
ar[i]=new Object[aray[i].length]; 
for(int j=0 ;j <aray [i]. length;]++) 
ar[i]|j]=aray[i]|j']; 

} 

return ar; 

} 

/**Creates a copy of a 3-dimensional array 

* @param aray 

* @return a copy of a 3-dimensional array 

*/ 

public Object[][][] arrayCopy(Object[][][] aray){ 
Object[][][] ar=new Object[aray.length] [][]; 
for(int i=0;i<aray.length;i-l-l-){ 

ar[i]=new Obj ect[aray[i]. length] []; 
for(int j=0;j<aray[i].length;j+-H) { 

ar[i][j]=new Object[aray[i][j].length]; 
for(int k=0;k<aray [i] [j ] .length;k-l-l-) 

ar[i]D][k]=aray[i]D-][k]; 

} 

} 

return ar; 

} 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

/**Shows all the exercises for a specific 

* series 

* @param series the series 


228 



*/ 

public void sliowALLExcercisesPerSeries(Series series){ 


Object[][][] arExer=getALLExcercisesFromSeries( series ); 

JTabbedPane tabs=new JTabbedPane(); 
for(int i=0;i<arExer.length;i++) { 

Stadio stadio=(Stadio ) arExer[i][0][0]; 

JTabbedPane tabeat=new JTabbedPaneQ; 
tabs.addTab(stadio.getId(),tabcat); 
for(int j=0;j<arExer[i] .length;j++) { 

Categories categories= (Categories) arExer[i][)][!]; 
if (categories !=null) 

tabcat.addTab(eategories.getId(),new JScroIIPane(new JEist(arExer[i][j]))); 

} 

} 

showTheForm( tabs); 


} 

/**Gets all the exercises for a specific 

* series 

* @param series 

* @return a 3 dimensional array containing the exercises per 
series per eategory*/ 

public Object[][][] getAEEExcercisesFromSeries(Series series ){ 
Collection c=QueryFonn.QueryGetStadioPerSeries(pm, series ); 

Iterator iter=c.iterator(); 

Object[][][] arExer=new Object[o.size()][][]; 
int is=-l; 
int io,ie; 

while(iter.hasNext()) { 

Stadio stadio=( (Stadio) iter.next()); 

Iterator itC at=stadio. getCategories(). iterator(); 
is++; ic=-I; 

arExer[is]=new Object[stadio.getCategories().size()+I][2]; 

arExer[is][0][0]=stadio; 

while(itCat.hasNext()) { 

Categories eategories=( (Categories) itCat.next()); 

Iterator itExo=categories.getExeroise().iterator(); 
ic++; ie=-I; 

//to avoid null 

arExer[is][ic]=new Object[categories.getExeroise().size()+2]; 


229 



arExer[is][ic][0]=stadio; 
arExer[is] [ic] [ 1 ]=categories; 

while(itExc.hasNext()){ 

Exercise exercise=( (Exercise) itExc.next() ); 
ie++; 


arExer [is] [ic] [ie+2]=exercise; 

} 

} 

} 

return arExer; 

} 

lllllllllllllllllllllllllllllllllllllllllllllllllllll 

/**Show the monthly hours that have been flown for all squadrons 
* 

* @param squad the squadron 

* @param month the month 

* @param year the year 

*/ 

public void showALESquadronsMonthlyHours(Squadron squad,int month, int year ){ 
Collection c=QueryEorm.QueryGetSquadrons( pm ); 

Object[] arSquadrons= c.toArray(); 

double[] arHours=new double[arSquadrons.length]; 

Arrays.fdl( arHours, 0 ) ; 

int[] arEligths=new int[arSquadrons.length]; 

Arrays.lill( arEligths, 0 ) ; 

Object[][] arSquadronsHour=new Object[arSquadrons.length][3]; 


Collection c2=QueryEorm.QueryGetElightsMonthlyReportAllSquadrons(pm,month, 
year); 

Iterator iter=c2.iterator(); 

while(iter.hasNext()) { 

Elights fly=( (Elights) iter.next() ); 

Squadron sq= fly.getSquadron(); 


230 



if(sq!=null) 

for(int i=0;i<arSquadrons.length; i++) 

if( fly.getSquadron().equals((Squadron) arSquadrons[i]) ){ 

arHours[i]+= fly.getEnduranceQ; 
arFligths[i]+=l; 

} 


for(int i=0;i<arSquadronsHour.length; i++){ 
arSquadronsHour[i][0]= arSquadrons[i]; 
arSquadronsHour[i][l]=new Double(arHours[i]); 
arSquadronsHour[i] [2]=new Integer(arFligths[i]); 


} 

Object[] ColumnHeader= {“Squadron”, “hours”,”# fbgths”}; 

liable instruetorsTable=new JTable(arSquadronsHour,ColumnHeader); 
showTheForm( instruetorsTable); 


} 

lllllllllllllllllllllllllllllllllllllllllllllllllllll 

lllllllllllllllllllllllllllllllllllllllllllllllllllll 

/**Show the monthly hours that have been flown for a 

* speeifie squadrons 

* @param squad 

* @param month 

* @param year */ 

publie void showSquadronsMonthlyHours(Squadron squad,int month, int year ){ 

Colleetion c= QueryForm.QueryGetFlightsMonthlyReportPerSquadron(pm,month, 
year, squad); 

Object[][] arSquadronHour=new Objeet[l][3]; 
arSquadronHour[0] [0]=squad; 
arSquadronHour[0] [ 1 ]=new Integer(O); 
arSquadronHour[0] [2]=new Double(O); 

Iterator iter=o.iterator(); 


231 



while(iter.hasNext()) { 

Flights fly=( (Flights) iter.next() ); 

int countFhghts= ((Integer) arSquadronHour[0][l] ).intValue(); 
arSquadronHour[0][ 1 ]=new Integer(eountFhghts+1); 

double hours= ((Double) arSquadronHour[0][2] ).doubleValue(); 
arSquadronHour[0][2]=new Double( hours + fly.getEnduranoe() ) ; 

} 


Objeot[] ColumnHeader= {“Squadron”,’’# flights”, “hours”}; 

liable instruetorsTable=new JTable(arSquadronHour,ColumnHeader); 
showTheForm( instruetorsTable); 


} 

lllllllllllllllllllllllllllllllllllllllllllllllllllll 

lllllllllllllllllllllllllllllllllllllllllllllllllllll 

/** Shows the hours of ah the students of a speeifie squadron 

* @param squad the squadron 

* @param month the month 

* @param year the year */ 

publie void showStudentsMonthlyHours(Squadron squad,int month, int year)} 
Coheetion e=QueryForm.QueryGetStudentsPerSquadron(pm, squad); 

Objeet[] arInstruetors= e.toArray(); 

double}] arHours=new double[arInstruetors.length]; 

Arrays.fih( arHours, 0 ) ; 

int[] arFhgths=new int[arInstruetors.length]; 

Arrays.lill( arFligths, 0 ) ; 

Objeet[][] arInstrHour=new Objeet[arInstruetors.length][4]; 

Coheetion o2=QueryForm.QueryGetFhghtsMonthlyReportPerSquadron(pm,month, 
year, squad); 

Iterator iter=o2.iterator(); 

while(iter.hasNext()) { 

Flights fly=( (Flights) iter.next() ); 

for(int i=0;Karinstruetors.length; i++) 


232 



if( fly.getStudent().equals((Students) arInstructors[i]) ){ 


arHours[i]+= fly.getEnduranceQ; 
arFligths[i]+=l; 

} 


for(int i=0;i<arInstrHour.length; i++){ 

arInstrHour[i][0]=((Students) arInstructors[i]).getId(); 
arInstrHour[i][ 1 ]=((Students) arInstructors[i]).getLastName(); 
arInstrHour[i][2]=new Double(arHours[i]); 
arInstrHour[i][3]=new Integer(arFligths[i]); 


} 

Object[] ColumnHeader={“ID”, “last name”, “hours”,”# fligths”}; 

JTable instructorsTable^new JTable(arInstrHour,ColumnHeader); 
showTheForm( instructorsTable); 


} 

lllllllllllllllllllllllllllllllllllllllllllllllllllll 

/** Shows the Aireraft's monthly hours for a 

* speeific squadron 

* @param squad the squadron 

* @param month the month 

* @param year the year 
*/ 

publie void showAiroraftsMonthlyHoursPerSquadron(Squadron squad,int month, int 
year){ 

Colleetion e= QueryForm.QueryGetFlightsMonthlyReportPerSquadron(pm,month, 
year, squad); 

FinkedFist aireraftFist=new FinkedFist(); 

FinkedFist aireraftHours=new FinkedFistO; 

FinkedFist aircraftFlights=new FinkedFist(); 

Iterator iter=o.iterator(); 

while(iter.hasNext()) { 

Flights fly=( (Flights) iter.next() ); 

int i=airoraftFist.indexOf(fly.getAiroraft() ) ; 
if(i<0){ 


233 



aircraftList. addLast(fly. getAircraft()); 
aircraftHours.addLast(new Double(fly.getEndurance() )); 
aircraftFlights.addLast(new Integer( 1)); 

} 

else{ 

double hours= ((Double) aireraftHours.get(i) ).doubleValue(); 
aireraftHours.set(i, new Double( hours + fly.getEnduranoe() )); 

int oountElights= ((Integer) aireraftElights.get(i) ).intValue(); 
aireraftElights.set(i, new Integer(eountElights+l)); 


} 

} 

Object[] arAireraft=aireraftEist.toArray(); 

Object[][] arAireraftHour=new Object[arAireraft.length][4]; 

for(int i=0;i<arAireraftHour.length;!++){ 

arAireraftHour[i][0]=((Aireraft) arAireraft[i]).getNum(); 
arAircraftHour[i] [ 1 ]=((Aircraft) arAircraft[i]). getXype(); 
arAircraftHour[i][2]=aircraftHours.get(i); 
arAircraftHour[i][3]=aircraftElights.get(i); 


} 

Object[] ColumnHeader={“Aircraft ID”, “Aircraft type”, “hours”,”# flights”}; 

JTable instructorsTable=new JTable(arAircraftHour,ColumnHeader); 
showTheEorm( instructorsTable); 


} 

lllllllllllllllllllllllllllllllllllllllllllllllllllll 

/** Shows the Aircraft's hours for a 

* specific squadron during a specific date 

* @param squad the squadron 

* @param d the date 

*/ 

public void showAircraftsDailyHoursPerSquadron(Squadron squad,Date d ){ 

Collection c= QueryForm.QueryGetFlightsDailyReportPerSquadron(pm, d, squad); 

EinkedList aircraftEist=new EinkedList(); 

EinkedList aircraftHours=new EinkedList(); 

EinkedList aircraftFlights=new LinkedList(); 


234 



Iterator iter=c.iterator(); 

while(iter.hasNext()) { 

Flights fly=( (Flights) iter.next() ); 

int i=aircraftList.indexOf(fly.getAircraft() ) ; 
if(i<0){ 

aircraftList. addLast(fly. getAircraft()); 
aircraftHours.addLast(new Double(fly.getEndurance() )); 
aireraftFhghts.addLast(new Integer( 1)); 

} 

else) 

double hours= ((Double) aireraftHours.get(i) ).doubleValue(); 
aircraftHours.set(i, new Double( hours + fly.getEnduranoe() )); 

int countEhghts= ((Integer) aireraftEhghts.get(i) ).intValue(); 
aireraftEhghts.set(i, new Integer(countEhghts+I)); 


} 

} 

Objeet[] arAireraft=aircraftEist.toArray(); 

Object[][] arAireraftHour=new Object[arAireraft.length][4]; 

for(int i=0;i<arAireraftHour.length; i++){ 

arAircraftHour[i][0]=((Aircraft) arAircraft[i]).getNum(); 
arAircraftHour[i] [ I ]=((Aircraft) arAircraft[i]). getType(); 
arAircraftHour[i][2]=aircraftHours.get(i); 
arAircraftHour[i][3]=aircraftEhghts.get(i); 


} 

Object[] ColumnHeader={“Aircraft ID”, “Aircraft type”, “hours”,”# flights”}; 

JTable instructorsTable^new JTable(arAircraftHour,ColumnHeader); 
showTheEorm( instructorsTable); 


} 

lllllllllllllllllllllllllllllllllllllllllllllllllllll 

/** Shows the instructors monthly hours 

* of a specific squadron 

* @param squad the squadron 

* @param month the month 

* @param year the year */ 

public void showInstructorsMonthlyHours(Squadron squad,int month, int year)} 
Collection c=QueryEorm.QueryGetInstructorsPerSquadron(pm, squad); 


235 



Object[] arInstructors= c.toArray(); 


double[] arHours=new double[arInstructors.length]; 

Arrays.fdl( arHours, 0 ) ; 

int[] arFligths=new int[arInstructors.length]; 

Arrays.lill( arFligths, 0 ) ; 

Objeet[][] arInstrHour=new Objeet[arInstruetors.length][4]; 

Colleetion e2=QueryForm.QueryGetFlightsMonthlyReportPerSquadron(pm,month, 
year, squad); 

Iterator iter=o2.iterator(); 

while(iter.hasNext()) { 

Flights fly=( (Flights) iter.next() ); 

for(int 1=0;Karinstruetors.length; i++) 

if( fly.getInstruetor().equals((Instruetors) arInstruetors[i]) ){ 

arHours[i]+= fly.getEnduranee(); 
arFligths[i]+=l; 


} 

} 

for(int i=0;i<arInstrHour.length;!++){ 

arInstrHour[i][0]=((lnstruetors) arInstruetors[i]).getId(); 
arInstrHour[i] [ 1 ]=((Instruetors) arInstruetors[i]).getLastName(); 
arInstrHour[i][2]=new Double(arHours[i]); 
arInstrHour[i][3]=new Integer(arFligths[i]); 


} 

Objeet[] ColumnHeader={“ID”, “last name”, “hours”,”# flights”}; 

JTable instruotorsTable=new JTable(arInstrHour,ColumnHeader); 
showTheForm( instruetorsTable); 


} 

/**pure SQL query used for aeoesing the performanee 
* of JDO in eontrast to JDBC 

*/ 

publie void showGROUPBYInstruotorsHoursl(){ 


236 



long[] arLong=new long[3]; 


arLong[0]=PureSQL.showGROUPBYInstructorsHours(true); 
arLong[ 1 ]=PureSQL.showGROUPBYInstructorsHours(false ); 


LinkedList lInstructor=new LinkedList(); 

LinkedList lHours=new LinkedList(); 

long timeStart=System.currentTimeMillis() ; 
System.out.println( timeStart); 

Collection c2=QueryForm.QueryGetFlights( pm); 
Iterator iter=c2.iterator(); 

while(iter.hasNext()) { 

Flights fly=( (Flights) iter.next()); 

Instructors inst=fly.getInstructor(); 

//instructor is not there 
if( ! lInstructor.contains(inst)) { 
llnstructor.addLast(inst); 

lHours.addLast(new Double(fly.getEndurance())); 

} 

else) 

Obj ect obj=lHours. get(lInstructor. indexO f(inst)); 
obj=new Double( 

((Double) obj).doubleValue()+ 
lly.getEnduranceO 
); 


} 

} 

long timeStop=System.currentTimeMilhs() ; 

System.out.println( timeStop); 

System.out.println(timeStop-timeStart); 

arEong[2]=timeStop-timeStart; 

Collection c3=QueryEorm.QueryGetEhghtsSQE( pm); 
Iterator iterc3=c3.iterator(); 


237 



while(iterc3 .hasNextQ) { 

Flights fly=( (Flights) iterc3.next() ); 

} 

String[] categories= {“GROUP BY Iter:”+arLong[0], “GROUP BY 
”+arLong [ 1 ], ” JDO: ”+arLong [2]}; 

MyBarChart bar=new MyBarChart(arLong, categories,’’performance in milisec”); 
bar.toForm(“JDO Performance for imitating a Group By query”); 


} 

/**pure SQL query used for accessing the performance 
* of JDO in eontrast to JDBC 

*/ 

pub lie void showGROUPB YInstructorsHours2( ) { 
long[] arLong=new long[3]; 


arLong[0]=PureSQL.showGROUPB YlnstructorsHours(true); 
arLong[l]=PureSQL.showGROUPBYInstruotorsHours(false ); 

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH^ 

LinkedList lInstructor=new LinkedList(); 

LinkedList lHours=new LinkedList(); 

long timeStart=System.currentTimeMihis() ; 

System.out.println( timeStart); 

//Coheetion c2=QueryForm.QueryGetFlightsSQL( pm); 
Coheetion o2=QueryForm.QueryGetFhghtsSQL(pm); 
pm. retrieve Ah(o2); 

System.out.println(“ sixe:”+c2.size()); 

Iterator iter=c2.iterator(); 

while(iter.hasNextQ) { 

Flights fly=( (Flights) iter.nextQ ); 
double i=fly.getEndurance(); 

/* Instructors inst=fly. getlnstructorQ; 

//instructor is not there 

if( !lInstructor.contams(mst)){ 
llnstruetor.addLast(inst); 

lHours.addLast(new Double(fly.getEndurance())); 

} 


238 



else{ 

Object obj=lHours.get(lInstructor.indexOf(inst)); 
obj=new Double( 

((Double) obj).doubleValue()+ 
fly.getEnduranceO 
); 

} 

*! 

} 

long timeStop=System.currentTimeMillis() ; 
System.out.println( timeStop); 
System.out.println(timeStop-timeStart); 
arLong[2]=timeStop-timeStart; 


String[] categories= {“GROUP BY Iter:”+arLong[0], “GROUP BY 
”+arLong[ 1 ],”JDO sql:”+arLong[2]}; 

MyBarChart bar=new MyBarChart(arLong, categories,’’performance in milisec”); 
bar.toForm(“JDO Performance for imitating a Group By query”); 


} 

/**pure SQL query used for accesing the performance 
* of JDO in contrast to JDBC 

*/ 

public void showGROUPBYInstructorsHours(){ 
long[] arLong=new long[3]; 


arLong[0]=PureSQL.showSELECTQueryFlights(true); 
arLong[l]=PureSQL.showSELECTQueryFlights(false ); 

LinkedList lInstructor=new LinkedList(); 

LinkedList lHours=new LinkedList(); 

long timeStart=System.currentTimeMillis() ; 
System.out.println( timeStart); 


239 



//Collection c2=QueryForm.QueryGetFlights( pm); 
Collection c2=QueryFonn.QueryGetFlightsSQL(pm); 
//pm.retrieveAll(c2); 

System.out.println(“ sixe:”+c2.size()); 

Iterator iter=c2.iterator(); 

while(iter.hasNext()) { 

Flights fly=( (Flights) iter.next() ); 
double i=fly.getEndurance(); 

/* Instructors inst=fly. getInstructor(); 

//instructor is not there 

if( !lInstructor.contains(inst)){ 
llnstructor.addLast(inst); 

lHours.addLast(new Double(fly.getEndurance())); 

} 

else) 

Object obj=lHours.get(lInstructor.indexOf(inst)); 
obj=new Double( 

((Double) obj).doubleValue()+ 
fly.getEnduranceO 
); 

} 

*/ 

} 

long timeStop=System.currentTimeMilhs() ; 
System.out.println( timeStop); 
System.out.println(timeStop-timeStart); 
arEong[2]=timeStop-timeStart; 


String[] categories={“JDBC SEEECT ITER.:”+arEong[0], “JDBC SEEECT 
:”+arEong[l],”JDO SEEECT:”+arEong[2]}; 

MyBarChart bar=new MyBarChart(arEong, categories,’’performance in milisec”); 
bar.toEorm(“JDO Performance EOR SEEECT Queries WITHOUT retrieveAll() - 
sql- Tag Iteration”); 

} 


/////////////////////////////////////////////////////////////////////////////////// 


240 



/** Shows the instructors of a specific squadron 
* @param squad the squadron 

*/ 

public void showInstructors(Squadron squad) { 

Collection c=QueryForm.QueryGetInstructorsPerSquadron(pm, squad); 

Object[] arInstructors= c.toArray(); 

int[] arHours=new int[arInstructors.length]; 

Arrays.fill( arHours, 0 ) ; 

Object[][] arInstrHour=new Object[arInstructors.length][3]; 

for(int i=0;i<arInstrHour.length; i++){ 

arInstrHour[i][O]=((lnstructors) arInstructors[i]).getId(); 
arInstrHour[i] [ 1 ]=((Instructors) arInstructors[i]).getLastName(); 
arInstrHour[i][2]=new Integer(arHours[i]); 


} 

Object[] ColumnHeader={“ID”, “last name”, “hours”}; 

liable instructorsTable^new JTable(arInstrHour,ColumnHeader); 
showThcForm} instructorsTable); 


} 


/** displays the form inside a container 
* 

* @param container the container */ 
public void showTheForm(Container container)} 

JScrollPane jsp=new JScrollPane(container); 

JFrame myframe =new JFrame(); 

Container cont=myframe.getContentPane(); 

cont.add(jsp); 

myframe.packO; 

myframe. setV isib le(true); 


} 


/** adds a number of records to the tables 


241 



* in order to calculate the performance of JDO 

*/ 

public void addlOOFlight(){ 
tx = pm.currentTransactionO; 
for(int i=10000;i< 12000; i++){ 
tx.beginO; 

Students student=new Students( ““+i,”lname”+i,” fname”+i, 1.0); 
Instructors instructor= new Instructors(““+i, “lname”+i,”instr_name”+i, 1.0); 
AircraftType aircrafttype=new AircraftType(“T2-EBAck”,’’DEception”); 
Aircraft aircraft= new Aircraft(“0”+i,aircrafttype, 0.0); 

Elights flight= new Elights( aircraft, instructor, student, new Date()); 
//squadron=new Squadron(“34”+i,”description-”+i); 

//pm.makePersistent( student); 

//pm.makePersistent(instructor); 
pm.makePersistent( flight); 

// pm.makePersistent(aircraft); 

//pm.makePersistent(aircrafttype); 

// pm.makePersistent(rank); 

try{ 

tx.commitO; 

//System, out .println(“] ”); 

} 

catch(javax.jdo.JDOException e) { 

System. out.println(“malaka “+e); 

} 


} 


} 

/** tests the query 

*/ 

private void testTheQuery(ActionEvent e){ 

JPanel l=new JPanelQ; 

JScrollPane jsp=new JScrollPane(l); 

JErame myframe =new JErame(); 

Container cont=myframe.getContentPane(); 
cont.add(jsp); 


242 



myframe.packO; 
my frame. setV isib le(true); 


} 


} 


7. The Class: SquadronsForm.java 


SquadronsForm 

* <p>Title: SquadronsForm.java</p> 

* <p>Description: Creates THE gui FOR THE REPRESENTATION OE THE 

* DATA OE THE VARIOUS EORMS </p> 

* <p>Copyright: Copyright (c) 2004</p> 

* Company: CS JDO 

* @author Paschalis Zilidis 

* @version 1.0 

V 


package test; 

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 


import j avax.j do. JDOHelper; /////// 

import javax.jdo.PersistenceManagerPactory; /////// 
import javax.jdo.PersistenceManager; /////// 

import javax.jdo.Transaction; /////// 

import javax.jdo.Query; /////// 

import java.io.EilelnputStream; /////// 

import java.io.IOException; /////// 

import java.io.InputStream; /////// 

import javax.jdo.spi.JDOImplHelper; /////// 

import javax.jdo.*; /////// 


llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

import company.*; 

import j avax.swing. *; 

import j avax. swing .event. *; 

import java.awt.*; 

import j ava. awt. event. *; 

import javax.swing. JComboBox; 


import java.util.*; 

import java.text.DecimalEormat; 


243 




class SquadronsForm extends JFrame implements AetionListener, MouseListener{ 


H . 

H . 

private statie PersisteneeManagerFactory pmf; 
private statie PersistenceManager pm; 
private static Transaction tx; 
private statie Query q; 
private statie Colleetion result; 

H . 

H . 

* The top level panel used in showing a dialog using JOptionPane's 

* elass method showOptionDialog. 

*/ 

private JPanel topPanel; 

* The formpanel level panel used in showing the current form 

* that displays data 

*/ 

private JPanel formPanel; 

* The squadronComboBox is a JComboBox that holds all 

* the squadrons we ean ehoose from for various \ 

* queries 

*/ 

private JComboBox squadronComboBox; 

* The seriesComboBox is a JComboBox that holds all 

* the series we ean ehoose from for various \ 

* queries 

*/ 

private JComboBox seriesComboBox; 

* Default frame width 

*/ 

private statie final int FRAME WIDTH = 800; 

* Default frame height 

244 







private static final int FRAME HEIGHT =480; 

* X coordinate of the frame default origin point 

*/ 

private static final int ERAME_X_ORIGIN = 150; 

* Y coordinate of the frame default origin point 

*/ 

private static final int ERAME Y ORIGIN = 250; 

* Constructor 

*/ 

public SquadronsEorm( ) { 


try { 

pmf = getPME( “lido mysql.properties”); 
pm = pmf.getPersistenceManagerO; 
tx = pm.currentTransactionO; 

Container contentPane=getContentPane(); 

contentPane.setLayout(new BorderLayout()); 
topPanel= new JPanelQ; 

squadronComboBox=new 

JComboBox(getTheDataPorComboBoxes(Squadron.class).toArray()); 

seriesComboBox=new 

JComboBox(getTheDataPorComboBoxes(Series.class).to ArrayO); 


topPanel.add(squadronComboBox); 

topPanel.add(seriesComboBox); 


contentPane.add(topPanel, BorderLayout.NORTH ); 
formPanel=new JPanel(); 

contentPane.add(formPanel, BorderLayout.CENTER ); 

contentPane.add(createToolBar( ),BorderLayout.WEST); 
contentPane.add(createToolBar( ),BorderLayout.EAST); 


} 


245 



catch (Exception e){e.printStackTrace();}; 


} 


/**gets data form a table that is represented by 

* a elass and store them in list boxes 

* @param dataclassName the class 

* @return the result set eontaining the data 

*/ 

publie Colleetion getTheDataForListBoxes(String dataelassName){ 

Collection sresult; 

if(!tx.isActive()){ 

tx.beginO; 

} 

q = pm.newQuery(dataclassName); 
sresult = (Colleetion) q.execute(); 
tx.eommitO; 

return sresult; 


} 


/**gets data form a table that is represented by 

* a elass and store them in eombo boxes 

* @param dataelass the elass 

* @return the result set eontaining the data 

*/ 

publie statie Colleetion getTheDataForComboBoxes(Class dataelass)) 
Colleetion sresult; 

if(!tx.isActive()){ 

tx.beginO; 

} 

q = pm.newQuery(dataelass); 
sresult = (Colleetion) q.exeoute(); 

tx.eommitO; 

return sresult; 


246 



} 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

lllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

II - 

// Main method 

H - 

public static void main(String[] args) { 

SquadronsForm f=new SquadronsForm( ); 
f.packO; 

f.setVisible(true); 

} 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 


H - 

// actionPerformed 
H - 

public void actionPerformed(ActionEvent event) { 

if (event.getActionCommand().equals(“exerciseSampleQuery”)) { 

testTheQuery( event); 

} 


} 


* Creates a toolbar with BUTTONS FOR THE 

* DISPEAY OE VARIOUS EORMS 

* 

*/ 

private JToolBar createToolBar( ) { 

JButton button; 

JToolBar toolbar = new JToolBar(); 

toolbar.addSeparatorO; 

final JButton jd=new JButton(“flight”); 

jd. addMouseEistener(this); 

//ADD 

button = toolbar. add( 

new AbstractAction(‘Tnstructors”) { 

public void actionPerformed(ActionEvent e) { 
Instructors object=new Instructors(); 


247 







LinkedList Iist0f0bject= 

LinkedList(getTheDataForComboBoxes(Instructors.class)); 

InstructorsForm sf=new InstructorsForm( pm, listOfObject, object); 

getContentPane().remove(formPanel); 

formPanel.removeAllO; 

sf.add(jd); 

forniPanel.add(sf); 

getContentPane().add(formPanel); 

pack(); 

repaintO; 

} 

}); 

button. setToolT ipText( “Instructors”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“Students”) { 

public void actionPerformed(ActionEvent e) { 

Students object=new Students(); 

LinkedList listOfObject= 

LinkedList(getTheDataLorComboBoxes(Students.class)); 

InstructorsLorm sf=new InstructorsLorm( pm, listOfObject, object ); 
String[] ar={“squadron”,”instructors”}; 


Squadron sq=(Squadron) squadronComboBox.getSelectedItem(); 

getContentPane().remove(formPanel); 

formPanel.removeAllO; 

formPanel.add(sf); 

getContentPane().add(formPanel); 

pack(); 

repaintO; 

} 

}); 

button. setToolT ipText(“Students”); 
toolbar.addSeparatorO; 


new 


new 


248 



button = toolbar. add( 

new AbstractAction(“Schedule”) { 

public void actionPerformed(ActionEvent e) { 

Schedule schedule^new SchedulcQ; 

Squadron squadron=new Squadron(); 

LinkedList listOfObject= new 

LinkedList(getTheDataForComboBoxes(Squadron.class)); 

InstructorsForm sf=new InstructorsForm( pm, listOfObject, squadron,! ); 

//sf.nextO; 

sf.setSubformForTheField(“schedule”,schedule); 

InstructorsForm sfschedule=(InstructorsForm) 

sf.getTheFieldContainerByFieldName(“schedule”); 

getContentPane().remove(formPanel); 

formPanel.removeAll(); 

formPanel.add(sf); 

formPanel.add(sfschedule); 

getContentPane().add(formPanel); 

pack(); 

repaintO; 


} 

}); 

button. setToolT ipText(“schedule”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“flights”) { 

public void actionPerformed(ActionEvent e) { 

Flights object=new Flights(); 

FinkedFist listOfObject= new 

FinkedFist(getTheDataForComboBoxes(Flights.class)); 

InstructorsForm sf=new InstructorsForm( pm, listOfObject, object); 

getContentPane().remove(formPanel); 

formPanel.removcAllO; 

formPanel.add(sf); 

getContentPane().add(formPanel); 

pack(); 


249 



repaintO; 

} 

}); 

button. setToolT ipText(“flights”); 
toolbar.addSeparatorO; 

button = toolbar. add(new AbstractAction(“Aircraft”) { 
public void actionPerformed(ActionEvent e) { 

Aircraft object=new Aircraft(); 

LinkedList listOfObject= 

LinkedList(getTheDataForComboBoxes(Aircraft.class)); 

InstructorsForm sf=new InstructorsForm( pm, listOfObject, object); 

getContentPane().remove(formPanel); 

formPanel.removeAll(); 

formPanel.add(sf); 

getContentPane().add(fonnPanel); 

pack(); 


repaintO; 

} 

}); 

button. setT oolTipT ext(“ Aireraft”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“Squadron”) { 

publie void actionPerformed(AotionFvent e) { 

Squadron object=new SquadronO; 

FinkedFist listOfObjeet= 

FinkedFist(getTheDataForComboBoxes(Squadron.class)); 

InstruetorsForm sf=new InstruotorsForm( pm, listOfObject, object); 


getContentPaneO.rcniove(formPanel); 

formPanel.removeAllO; 

formPanel.add(sf); 

getContentPaneO.add(formPanel); 

//getContentPane0.add(sf, BorderFayout.CENTER ); 

packO; 

repaintO; 

} 


new 


new 


250 



button. setT oolTipT ext(“Squadron”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“Series”) { 

public void actionPerformed(ActionEvent e) { 

Series object=new SeriesQ; 

LinkedList listOfObject= new 

LinkedList(getTheDataForComboBoxes(Series.class)); 

InstructorsForm sf=new InstructorsForm( pm, listOfObject, object ,1); 

Stadio stadio=new Stadio(); 
sf.setSubformForTheField(“stadio”,stadio); 

InstructorsF orm sfstadio=(InstructorsF orm) 

sf.getTheFieldContainerByFieldName(“stadio”); 

getContentPane().remove(formPanel); 

formPanel.removeAllO; 

formPanel.add(sf); 

formPanel.add(sfstadio); 

getContentPane().add(fonnPanel); 

pack(); 

repaintO; 

} 

}); 

button, set! oolTipT ext(“Series”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“Stadio”) { 

public void actionPerformed(ActionEvent e) { 

Stadio stadio=new Stadio(); 

Series object=new SeriesQ; 

FinkedFist listOfObject= new 

FinkedFist(getTheDataForComboBoxes(Series.class)); 

InstructorsForm sf=new InstructorsForm( pm, listOfObject, object 
,”stadio”,stadio); 


getContentPaneO.remove(formPanel); 

formPanel.removeAllQ; 


251 



formPanel.add(sf); 

getContentPane().add(formPanel); 

pack(); 

repaintO; 

} 

}); 

toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“Test”) { 

public void actionPerformed(ActionEvent e) { 

Stadio stadio=new Stadio(); 

Series series=new Series(); 

Categories categories=new Categories(); 

Exercise exercise=new Exercise(); 

EinkedList listOfObject= new 

EinkedList(getTheDataEorComboBoxes(Series.class)); 

InstructorsEorm sf^new InstructorsEorm( pm, listOfObject, series ); 


sf.setSubformEorTheEield(“stadio”,stadio); 

InstructorsE orm sfstadio=(InstructorsE orm) 

sf.getTheEieldContainerByEieldName(“stadio”); 

sfstadio. setSubformE orTheE ield(“categories”,categories); 


InstructorsE orm sfc ateg=(InstructorsE orm) 

sfstadio.getTheEieldContainerByEieldName(“categories”); 

sfcateg.setSubformEorTheEield(“exercise”,exercise); 


getContentPane().remove(formPanel); 

formPanel.removeAllO; 

JPanel l=new JPanel(new GridLayout(0,2,5,5)); 

l.add(sf); 

l.add(sfstadio); 

l.add(sfcateg); 

1. add( (InstructorsE orm) 

sfcateg.getTheEieldContainerByEieldName(“exercise”)); 
JScrollPane jsp=new JScrollPane(l); 


252 



JFrame myframe =new JFrame(); 

Container cont=myframe.getContentPane(); 

cont.add(jsp); 

myframe.packO; 

myframe.setVisible(true); 

repaintO; 

} 

}); 

toolbar.addSeparatorO; 

final JButton jbeat=new JButton(“exereiseSampleQuery”); 
jbe at. addAetionListener(this); 

button = toolbar. add( 

new AbstraetAction(“Categories”) { 

publie void aotionPerformed(AotionEvent e) { 

Categories objeet=new Categories(); 

LinkedList listOfObjeet= 

LinkedList(getTheDataForComboBoxes(Categories.elass)); 

InstruetorsForm sf=new InstruetorsForm( pm, listOfObjeet, objeet); 

getContentPane().remove(formPanel); 

formPanel.removeAll(); 

sfadd(jbcat); 

formPanel.add(sf); 

getContentPane().add(formPanel); 

repaintO; 

pack(); 


} 

}); 

button. setToolT ipText(“Categories”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstraetAction(“Exereise”) { 

publie void aotionPerformed(AotionEvent e) { 

Exereise objeot=new ExereiseO; 

LinkedEist listOfObjeot= 

EinkedEist(getTheDataEorComboBoxes(Exeroise.olass)); 

InstruetorsEorm sf^new InstruotorsEorm( pm, listOfObjeet, objeet); 


new 


new 


253 



getContentPane().remove(formPanel); 

formPanel.removeAllO; 

forniPanel.add(sf); 

getContentPane().add(formPanel); 

//getContentPane().add(sf, BorderLayout.CENTER ); 

pack(); 

repaintO; 

} 

}); 

button. setToolT ipText( “Exercise”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“BasicStadio”) { 

public void actionPerformed(ActionEvent e) { 

BaseStadio object=new BaseStadio(); 

EinkedList listOfObject= 

EinkedList(getTheDataEorComboBoxes(BaseStadio.class)); 

InstructorsEorm sf=new InstructorsEorm( pm, listOfObject, object); 

getContentPane().remove(formPanel); 

formPanel.removeAllO; 

formPanel.add(sf); 

getContentPane().add(formPanel); 

//getContentPane().add(sf, BorderEayout.CENTER ); 

pack(); 

repaintO; 

} 

}); 

button. setToolT ipText(“BasicStadio”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“BasicCategory”) { 

public void actionPerformed(ActionEvent e) { 

BaseCategory object=new BaseCategoryO; 

EinkedList listOfObject= 

LinkedList(getTheDataEorComboBoxes(BaseCategory.class)); 

InstructorsEorm sf=new InstructorsEorm( pm, listOfObject, object); 

getContentPaneO.rcniove(formPanel); 

formPanel.removeAllO; 

formPanel.add(sf); 

getContentPaneO.add(formPanel); 


new 


new 


254 



//getContentPane().add(sf, BorderLayout.CENTER ); 

pack(); 

repaintO; 

} 

}); 

button. setToolT ipText(“BasicCategory”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“SpecialType”) { 

public void actionPerformed(ActionEvent e) { 

SpecialType object=new SpecialType(); 

EinkedList listOfObject= 

EinkedList(getTheDataEorComboBoxes(SpecialType.class)); 

InstructorsEorm sf=new InstructorsEorm( pm, listOfObject, object); 

getContentPane().remove(formPanel); 

formPanel.removeAll(); 

formPanel.add(sf); 

getContentPane().add(fonnPanel); 

//getContentPane().add(sf, BorderEayout.CENTER ); 

pack(); 

repaintO; 

} 

}); 

button.setToolTipText(“SpecialType”); 

toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstractAction(“Ground course”) { 

public void actionPerformed(ActionEvent e) { 

GroundCourse object=new GroundCourseO; 

EinkedList listOfObject= 

LinkedList(getTheDataEorComboBoxes(GroundCourse.class)); 

InstructorsEorm sf^new InstructorsEorm( pm, listOfObject, object); 

getContentPaneO.rcmove(formPanel); 

formPanel.removcAllO; 

formPanel.add(sf); 

getContentPaneO.add(formPanel); 

//getContentPane0.add(sf, BorderLay out. CENTER ); 

packO; 

repaintO; 

} 


new 


new 


255 



}); 

button.setToolTipText(“Ground course”); 
toolbar.addSeparatorO; 

button = toolbar. add( 

new AbstraetAetion(“Reports form”) { 

publie void aotionPerformed(AotionEvent e) { 

ReportsForm rf=new ReportsFormO; 

rfpaekQ; 

rfsetVisible(true); 

repaintO; 

} 

}); 

toolbar.setFayout(new GridFayout(0, 1)); 


return toolbar; 

} 


/** Query the flights for a speeifie instruetor 

* @param Inst the instruetor 

* @return the result of the query 

*/ 

publie Colleetion queryTheFlights(Instruetors Inst) { 
Extent extent=pm.getExtent(Flights.elass,true); 
String lilter=“instruetor==inst”; 

Query query=pm.newQuery(extent,fdter); 
query.deelareParameters(“Instruetors Inst”); 
Colleetion result=(Colleotion) query.exeoute(inst); 

return result; 


} 


/**get the PersisteneeManagerFaetory 

* @param path the url path 

* @return the PersisteneeManagerFaetory 


256 



public static PersistenceManagerFactory getPMF(String path) { 
try { 

InputStream propStream = 
new FilelnputStream(path); 

Properties props = new PropertiesQ; 
props.load(propStream); 

props.put(“javax.jdo.PersistenoeManagerFaotoryCIass”, 

“com.libelis.Iido.PersistenoeManagerFaetory”); 

return JDOHelper.getPersisteneeManagerFaetory(props); 

} 

eateh (lOExeeption e) { 
e .prints taekT rae e(); 

System.exit(-l); 
return null; 

} 


} 


/* *MouseCIieked 

*/ 

publie void mouseCIioked(MouseEvent e) { 

InstruetorsEorm iform=(InstruotorsEorm) e.getComponent().getParent(); 

Instruetors inst=(Instruotors) iform.getCurrentReoord(); 

EinkedList listOfObject= new EinkedList( QueryEorm.queryTheElights(pm, inst) ); 

InstruetorsEorm sf^new InstruotorsEorm( pm, listOfObjeet, new Elights() ); 

JPanel I=new JPaneI(); 

I.add(sf); 

EinkedList listMonth= new LmkedList( QueryGetElightsMonthlyReport(l 1, 2003)); 
JList j2=new JList(listMonth.toArray()); 

Squadron squad=(Squadron) squadronComboBox.getSeleetedltemQ; 

JList j3=new JList(QueryGetElightsMonthlyReportPerSquadron(l 1, 2003, 

squad) .to Array 0); 

JList jl=new JList(listOfObjeot.toArray()); 


I.add(jl); 

I.add(j2); 


257 



I.add(j3); 

JScrollPane jsp=new JScrollPane(l); 

JFrame myframe =new JFrame(); 

Container cont=myframe.getContentPane(); 

cont.add(jsp); 

myframe.packO; 

myframe. setV isib le(true); 


} 


publie void mousePressed(MouseEvent e) { 

} 

publie void mouseReleased(MouseEvent e) { 

} 

publie void mouseEntered(MouseEvent e) { 

} 

publie void mouseExited(MouseEvent e) { 

} 

/** tests the query 
*/ 

private void testTheQuery(ActionEvent e){ 

JButton jb=(JButton) e.getSoureeQ; 

Hi have put the button to the Categories form 
InstruetorsEorm iform=(InstructorsEorm) jb.getParentQ; 

Categories cat=(Categories) iform.getCurrentReeordQ; 

EinkedList list= new EirLkedList( QueryGetEhghtsExeereiseReportPerCategory( 
cat)); 

JEist j2=new JEist(list.toArray()); 

JPanel l=new JPanelQ; 
l.add(new JButton()); 
l.addG2); 

JSerollPane jsp=new JSerollPane(l); 


258 



JFrame myframe =new JFrame(); 

Container cont=myframe.getContentPane(); 

cont.add(jsp); 

myframe.packO; 

myframe. setV isib le(true); 


} 

////////////////////////////////M^^^ 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

//////////////////////QUERIES/////////////^^^^^^ 

llllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllll 

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIH 

/**Query the flights for a speeifie date 

* @param d the date 

* @return the result of the query 

*! 

publie Colleetion QueryGetElightsDailyReport(Date d) { 


Extent extent=pm.getExtent(Elights.elass,true); 
String filter=“date==d”; 

Query query=pm.newQuery(extent,filter); 
query.deelareImports(“importjava.util.Date”); 
query.deelareParameters(“Date d”); 

Colleetion result=(Collection) query.exeoute(d); 

return result; 


} 

/** Query the flights for a speeifie date 

* and a speeifie squadron 

* @param squad the squadron 

* @param d the date 

* @return the result of the query 
*/ 

publie Colleetion QueryGetPlightsDailyReportPerSquadron(Date d, Squadron squad) { 


Extent extent=pm.getExtent(Elights.class,true); 
String filter=“date==d && squadron==squad”; 
Query query=pm.newQuery(extent,filter); 
query.declareImports(“importjava.util.Date”); 


259 



query.declareParameters(“Date d, Squadron squad”); 
Collection result=(Collection) query.execute(d,squad); 

return result; 


} 


//the field might be private however here the JDOQL seem to have access 
// directly to them using the dot(.) operator i.e. flights.exercise 
/**Query the flights for a specific category of 

* exercises 

* @param cat the category 

* @return the result of the query 

*/ 

public Collection QueryGetFlightsExcerciseReportPerCategory(Categories cat){ 


Extent extent=pm.getExtent(Elights.class,true); 
String filter=“exercise.categories==cat”; 

Query query=pm.newQuery(extent,fdter); 

query.declareParameters(“Categories cat”); 
Collection result=(Collection) query.execute(cat); 

return result; 


} 


/** Query the flights for a specific month 

* @param month the month 

* @param year the year 

* @return the result of the query 

*/ 

public Collection QueryGetElightsMonthlyReport(int month, int year) { 

Calendar cl = new GregorianCalendar(year,month,l) ; 
if(month==l 1){ 
year+=l; 
month=0; 

} 

else 

month+=l; 


260 



Calendar c2= new GregorianCalendar(year,month,l) ; 

Date beginDate=e 1 .getTime(); 

Date endDate=c2.getTime(); 

Extent extent=pm.getExtent(Flights.class,true); 

String filter=“date>=beginDate && date<endDate”; 

Query query=pm.newQuery(extent,filter); 
query.declareImports(“importjava.util.Date”); 
query.declareParameters(“Date beginDate, Date endDate”); 
Collection result=(Collection) query.execute(beginDate,endDate); 

return result; 


} 


/** Query the flights for a specific month 

* and a specific squadron 

* @param month the month 

* @param year the year 

* @param squad the squadron 

* @return the result of the query 
*/ 

public Collection QueryGetElightsMonthlyReportPerSquadron(int month, int year. 
Squadron squad) { 

Calendar cl = new GregorianCalendar(year,month,l) ; 
if(month==l 1){ 
year+=l; 
month=0; 

} 

else 

month+=l; 

Calendar c2= new GregorianCalendar(year,month,l) ; 

Date begmDate=c 1 .getTime(); 

Date endDate=c2.getTime(); 

//JOptionPane.showMessageDialog(null,begmDate+”-“+endDate); 

Extent extent=pm.getExtent(Elights.class,true); 

String filter=“date>=beginDate && date<endDate && squadron==squad”; 

Query query=pm.newQuery(extent,filter); 
query.declareImports(“importjava.util.Date”); 

query.declareParameters(“Date beginDate, Date endDate, Squadron squad”); 


261 




Collection result=(Collection) query.execute(beginDate,endDate, squad); 
return result; 


} 


/**Query the flights for a specific month and a specific 

* student in a specific squadron 

* @param month the month 

* @param year the year 

* @param stude the student 

* @param squad the squadron 

* @return the result of the query 
*/ 

public Collection QueryGetFlightsMonthlyReportPerSquadronPerStudent( 
int month, int year, Squadron squad. Students stude) { 

Calendar cl = new GregorianCalendar(year,month,l) ; 
if(month==l 1){ 
year+=l; 
month=0; 

} 

else 

month+=l; 

Calendar c2= new GregorianCalendar(year,month,l) ; 

Date begmDate=c 1 .getTime(); 

Date endDate=c2.getTime(); 

//JOptionPane.showMessageDialog(null,begmDate+”-“+endDate); 

Extent extent=pm.getExtent(Flights.class,true); 

String filter=“date>=beginDate && date<endDate && squadron==squad && 
student=stude”; 

Query query=pm.newQuery(extent,filter); 
query.declareImports(“importjava.util.Date”); 

query.declareParameters(“Date beginDate, Date endDate, Squadron squad. Students 
stude”); 

Object[] parameters={begmDate,endDate, squad, stude}; 

Collection result=(Collection) query.executeWithArray(parameters); 

return result; 


262 




} 


/**Query the flights for a specific month and a specific 

* instructor in a specific squadron 

* @param month the month 

* @param year the year 

* @param instr the instructor 

* @param squad the squadron 

* @return the result of the query 
*/ 

public Collection QueryGetFlightsMonthlyReportPerSquadronPerInstructor( 
int month, int year, Squadron squad. Instructors instr) { 

Calendar cl = new GregorianCalendar(year,month,l) ; 
if(month==l 1){ 
year+=l; 
month=0; 

} 

else 

month+=l; 

Calendar c2= new GregorianCalendar(year,month,l) ; 

Date beginDate=c 1 .getTime(); 

Date endDate=c2.getTime(); 

Extent extent=pm.getExtent(Flights.class,true); 

String fdter=“date>=beginDate && date<endDate && squadron==squad && 
instructor=instr”; 

Query query=pm.newQuery(extent,fdter); 
query.declareImports(“importjava.util.Date”); 

query.declareParameters(“Date beginDate, Date endDate, Squadron squad. 
Instructors instr”); 

Object[] parameters={beginDate,endDate, squad,instr}; 

Collection result=(Collection) query.executeWithArray(parameters); 

return result; 


} 


} 


263 



C. METADATA JDO FILE 

<?xml version=“1.0”?> 

<!DOCTYPE jdo SYSTEM “jdo.dtd”> 
<jdo> 

<package name=“company”> 


<class name=‘Tnstructors” identity-type=“application”> 

<field name=“id” primary-key=“true”/> 

<field name=“lname” > 

<extension vendor-name=“libelis” key=“sql-index” value=“unique”/> 
</field> 

<field name=“students” > 

<collection element-type=“Students”> 

</collection> 

</field> 

<field name=“aircrafts” > 

<collection element-type=“Aircraft”/> 

</field> 

</class> 


<class name=“Students” identity-type=“application”> 
<field name=“id” primary-key=“true”/> 


<field name=“instructors” > 

<collection element-type=‘Tnstructors”> 

</collection> 

</field> 

</class> 


<class name=“Series” identity-type=“application”> 
<field name=“id” primary-key=“true”/> 

<field name=“stadio” > 

<collection element-type=“Stadio”> 
<extension vendor-name=“libelis” 
key=“sql-reverse” 
value=“j avaEield: series’V> 
</eolleetion> 


264 



</field> 

<field name=“groundcourse” > 

<collection element-type=“GroundCourse”/> 
</field> 

<field name=“students” > 

<collection element-type=“Students”/> 
</field> 

</class> 


<class name=“Stadio” identity-type=“application”> 
<field name=“seriesld” primary-key=“true”/> 
<field name=“id” primary-key=“true”/> 


<field name=“categories” > 

<collection element-type=“Categories”> 

</collection> 

</field> 

</class> 

<class name=“BaseStadio” identity-type=“application”> 
<field name=“id” primary-key=“true”/> 

</class> 

<class name=“Categories” identity-type=“application”> 
<field name=“seriesid” primary-key=“true”/> 

<field name=“stadioid” primary-key=“true”/> 

<field name=“id” primary-key=“true”/> 

<field name=“exercise” > 

<collection element-type=“Exercise”/> 

</field> 

</class> 

<class name=“BaseCategory” identity-type=“application”> 
<field name=“id” primary-key=“true”/> 

</class> 

<class name=“Exercise” identity-type=“application”> 

<field name=“seriesid” primary-key=“true”/> 

<field name=“stadioid” primary-key=“true”/> 


265 



<field name=“categoriesid” primary-key=“true”/> 
<field name=“id” primary-key=“true”/> 

</class> 


<class name=“Aircraft” identity-type=“application”> 
<field name=“num” primary-key=“true”/> 

</class> 

<class name=“AircraftType” /> 


<class name=“Rank” /> 


<class name=“Squadron” identity-type=“application”> 
<field name=“squadron” primary-key=“true”/> 
<field name=“schedule” > 

<collection element-type=“Schedule”/> 

</field> 

</class> 


<class name=“Flights”> 

<field name=“date”> 

<!— Specify the format of the date —> 

<extension vendor-name=“libelis” key=“sql-mapping” value=“date, date- 

only”/> 

</field> 

</class> 

<class name=“SpecialType” identity-type=“application”> 

<tield name=“id” primary-key=“true”/> 

</class> 

<class name=“Schedule” identity-type=“application”> 

<tield name=“squadronid” primary-key=“true”/> 

<tield name=“year” primary-key=“true”/> 

<tield name=“month” primary-key=“true”/> 

</class> 

<class name=“GroundCourse” identity-type=“application”> 

<tield name=“id” primary-key=“true”/> 

</class> 


</package> 

</jdo> 


266 



LIST OF REFERENCES 


Jordan, David and Russell, C raig, “Java Data Objects.” 

LIDO User’s Manual. 

http://iava.sun.com/products/ido/overview.html , accessed April 2004. 


267 



THIS PAGE INTENTIONALLY LEET BLANK 


268 



INITIAL DISTRIBUTION LIST 


1. Defense Teehnieal Information Center 
Ft. Belvoir, Virginia 

2. Dudley Knox Library 
Naval Postgraduate Sehool 
Monterey, California 

3. Professor Thomas Otani 
Aeademie Assoeiate 
Department of Computer Seienee 
Naval Postgraduate Sehool 
Monterey, California 

4. Professor Arijit Das 
Department of Computer Seienee 
Naval Postgraduate Sehool 
Monterey, California 

5. Hellenie Air Foree General Staff 

Athens, Greeee 

6. Hellenie Air Foree Aeademy 
Athens, Greeee 

7. Christos Zilidis 

Neo Monastiri Domokos 
TK 35010, 

Greeee 

8. MAJ Pasehalis Zilidis 
Neo Monastiri Domokos 
TK 35010, 

Greeee 


269 



