
NAVAL 

POSTGRADUATE 

SCHOOL 

MONTEREY, CALIEORNIA 


THESIS 


OPTIMAL SENSOR ALLOCATION FOR A DISCRETE 
EVENT COMBAT SIMULATION 

by 

Thomas Doll 
June 2004 

Thesis Advisor; Matt Carlyle 

Second Reader: Donovan Phillips 


Approved for public release; distribution is unlimited. 




THIS PAGE INTENTIONALLY LEET BLANK 



REPORT DOCUMENTATION PAGE 


Form Approved OMB No. 0704-0188 
Public reporting burden for this collection of information is estimated to average 1 hour per response, including 
the time for reviewing instruction, searching existing data sources, gathering and maintaining the data needed, and 
completing and reviewing the collection of information. Send comments regarding this burden estimate or any 
other aspect of this collection of information, including suggestions for reducing this burden, to Washington 
headquarters Services, Directorate for Information Operations and Reports, 1215 Jefferson Davis Highway, Suite 
1204, Arlington, VA 22202-4302, and to the Office of Management and Budget, Paperwork Reduction Project 

(0704-0188) Washington DC 20503. __ 

2. REPORT DATE 3. REPORT TYPE AND DATES COVERED 
June 2004 Master’s Thesis 

4. TITLE AND SUBTITLE: Optimal Sensor Allocation for a Discrete Event 5. PENDING NUMBERS 
Combat Simulation 

6. AUTHOR(S) Thomas Doll _ 

7. PERPORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 8. PERPORMING 

Naval Postgraduate School ORGANIZATION REPORT 

Monterey, CA 93943-5000 NUMBER 

9. SPONSORING /MONITORING AGENCY NAME(S) AND ADDRESS(ES) 10. SPONSORING/MONITORING 
U.S. Army TRADOC Analysis Center AGENCY REPORT NUMBER 

Monterey, CA 

11. SUPPLEMENTARY NOTES The views expressed in this thesis are those of the author and do not reflect the official 
policy or position of the Department of Defense or the U.S. Government. 


13. ABSTRACT 

The U.S. Army’s Future Force is being developed as a faster, lighter, more rapidly deployable alternative to 
the current force structure. The Future Force will feature a smaller in-theater footprint and require the ability to 
cover a larger area of the battle space with intelligence-gathering assets. To support this development the Naval 
Postgraduate School and TRAC Monterey began to conduct research in the area of allocation of Future Force 
sensor platforms. 

A previous thesis developed the Sensor Allocation Model (SAM) for finding an appropriate mix and allocation 
strategy for organic Unit of Action sensors in a given threat scenario. The mix suggested by the model is robust to 
uncertainties in sensor performance and target quantity and location. SAM shows great promise for use as a 
screening tool in support of analysis of alternatives studies as well as in support of Army and Joint war fighting 
experimentation. It also has potential for use as an operational decision support tool for unit commanders. 

This thesis discusses three improvements to SAM. First, SAM has been translated into a programming language 
that easily can be implemented into any simulation environment. Second, it now contains more realistic constraints 
on sensor platform employment duration and distance. Third, the model estimates of sensor performance have 
been improved with a Probability Line of Sight model. Together, these improvements have greatly improved 
SAM’s usability._ 


16. PRICE CODE 


NSN 7540-01-280-5500 Standard Form 298 (Rev. 2-89) 

Prescribed by ANSI Std. 239-18 


20. LIMITATION 
OE ABSTRACT 

UL 


15. NUMBER OE 
PAGES 

89 


14. SUBJECT TERMS 

Optimization, Objective Force, Unit of Action, Unmanned Aerial Vehicles, Sensors, Sensor 
Allocation, Mixed Integer Program, MIP, Operations Research, Java 

18. SECURITY 
CLASSIEICATION OE THIS 
PAGE 

Unclassified 


19. SECURITY 
CLASSIEICATION OE 
ABSTRACT 

Unclassified 


17. SECURITY 
CLASSIEICATION OE 
REPORT 

Unclassified 


12b. DISTRIBUTION CODE 

unlimited 


12a. DISTRIBUTION / AVAILABILITY STATEMENT 

Approved for public release; distribution unlimited 


1. AGENCY USE ONLY (Leave blank) 


1 




























THIS PAGE INTENTIONALLY LEET BLANK 


11 



Approved for public release; distribution is unlimited. 


OPTIMAL SENSOR ALLOCATION FOR A DISCRETE EVENT COMBAT 

SIMULATION 

Thomas M. Doll 
Captain, German Army 

Diploma in Electrical Engineering, University of the German Armed Eorces Munich 

Submitted in partial fulfillment of the 
requirements for the degree of 

MASTER OF SCIENCE IN OPERATIONS RESEARCH 


from the 


NAVAL POSTGRADUATE SCHOOL 
June 2004 


Author: Thomas M. Doll 


Approved by: W. Matthew Carlyle 

Thesis Advisor 


Donovan Phillips 
Second Reader 


James N. Eagle 

Chairman, Department of Operations Research 


ill 



THIS PAGE INTENTIONALLY LEET BLANK 


IV 



ABSTRACT 


The U.S. Army’s Future Foree is being developed as a faster, lighter, more 
rapidly deployable alternative to the current force structure. The Future Force will feature 
a smaller in-theater footprint and require the ability to cover a larger area of the battle 
space with intelligence-gathering assets. To support this development the Naval 
Postgraduate School and TRAC Monterey began to conduct research in the area of 
allocation of Future Force sensor platforms. 

A previous thesis developed the Sensor Allocation Model (SAM) for finding an 
appropriate mix and allocation strategy for organic Unit of Action sensors in a given 
threat scenario. The mix suggested by the model is robust to uncertainties in sensor 
performance and target quantity and location. SAM shows great promise for use as a 
screening tool in support of analysis of alternatives studies as well as in support of Army 
and Joint war fighting experimentation. It also has potential for use as an operational 
decision support tool for unit commanders. 

This thesis discusses three improvements to SAM. First, SAM has been 
translated into a programming language that easily can be implemented into any 
simulation environment. Second, it now contains more realistic constraints on sensor 
platform employment duration and distance. Third, the model estimates of sensor 
performance have been improved with a Probability Line of Sight model. Together, 
these improvements have greatly improved SAM’s usability. 


V 



THIS PAGE INTENTIONALLY LEET BLANK 


VI 



TABLE OF CONTENTS 


1. INTRODUCTION.1 

A, BACKGROUND.1 

1. Background on the Original Sensor Allocation Model.1 

2, Sensors, Platforms and Packages in the Old Model.2 

B, PROBLEM DEFINITION.5 

C, SCOPE, LIMITATIONS AND ASSUMPTIONS.6 

IL IMPROVEMENTS TO SAM.9 

A, REFINEMENT OF SENSOR ALLOCATION LOGIC.9 

1. Employment Prohahility of Line Of Sight.9 

2. Implementation of Distance and Time Constraints.11 

3. Adjustments to Represent Sensor Performance Realistically.13 

B, ADAPTATION OF SAM FOR INTEGRATION WITH A 

SIMULATION ENVIRONMENT.16 

III. ANALYSIS.19 

A, TEST AND EVALUATION OF THE ISAM OUTPUT FOR 

DIFFERENT TARGET DISTRIBUTIONS.19 

B, TEST AND EVALUATION OF THE JSAM OUTPUT FOR 

DIFFERENT PLOS PARAMETERS.24 

IV. CONCLUSIONS AND RECOMMENDATIONS.27 

A. RECOMMENDED MODEL REFINEMENTS.27 

1. Classified Data.27 

2. Tuning.27 

3. Verification and Validation.27 

4. Model Split.28 

B. SUGGESTED FURTHER RESEARCH.28 

LIST OF REFERENCES.29 

APPENDIX A OPTIMIZATION MODEL IN NPS FORMAT.31 

A. INDICES.31 

B. PARAMETERS.31 

1. Asset Data.31 

2. Target Data.31 

3. Parameter Weights.31 

4. Derived Data.32 

C. DECISION VARIABLES.32 

D. CONSTRAINTS.33 

E. OBJECTIVE FUNCTION.33 

APPENDIX B DOCUMENTATION OF THE JAVA SENSOR ALLOCATION 

PROGRAM.35 

vii 





































A, ISAM DOCUMENTATION AND PROGRAM DESCRIPTION.35 

B, DATA EXTRACTION AND DOCUMENTATION.40 

APPENDIX C CODE FOR THE JAVA SENSOR ALLOCATION PROGRAM 43 

A. MAIN.43 

B. INPUT MODELDATA.43 

C. SENSORS.45 

D. PLATFORMS.53 

E. PACKAGES.56 

F. SCENARIO.59 

G. GAMS_HANDLING.60 

H. OUTPUT GAMSFILES.62 

I. OUTPUT COMMAND.64 

INITIAL DISTRIBUTION LIST.71 


viii 
















LIST OF FIGURES 


Figure 1. Example of Target Clustering.2 

Figure 2. Example of a Eateral Range Curve (the vertieal axis represents deteetion 

probability, or a similar measure for ranged deviees).2 

Figure 3. Sensor Detection Zone.3 

Figure 4. Empirical PEGS Distribution.10 

Figure 5. PEGS Parameters for predefined locations.11 

Figure 6. Probability of Detection without PEGS.11 

Figure 7. Probability of Detection after PEGS correction.11 

Figure 8. Basic modeling idea.14 

Figure 9. Sectors.14 

Figure 10. Ground Distances.15 

Figure 11. Area Transformation.15 

Figure 12. Transformation for Sensor Sweep Width.16 

Figure 13. ISAM Design Concept.17 

Figure 14. Variable and Parameter setup for Analysis with different target 

distributions.20 

Figure 15. Variable and Parameter setup used for Analysis with different PEGS 

parameters.25 

Figure 16. Excerpt of the class Input ModelData.35 

Figure 17. Description of plos modebng.40 

Figure 18. Description of scenario modeling.41 

Figure 19. Description package modeling.41 

Figure 20. Description of field_of_view_modeling.42 


IX 























THIS PAGE INTENTIONALLY LEET BLANK 


X 



LIST OF TABLES 


Table 1. Operational Time and Radii for different Platforms.12 

Table 2. Target Deseription.20 

Table 3. Randomly generated target distribution (seed 13769).21 

Table 4. Randomly generated target distribution (seed 45832).21 

Table 5. Randomly generated target distribution (seed 91273).22 

Table 6. Platform Alloeations for the three test runs.22 

Table 7. Platform Deseription.23 

Table 8. Number of Platforms available.23 

Table 9. Platform Alloeations for 3'^‘* run with increased operational time for 

Platform 1.23 

Table 10. Platform Allocations just for platforms 1 to 4.24 

Table 11. Allocation Output for different types of terrain.26 

Table 12. Excerpt of Sensor Data.csv.36 















THIS PAGE INTENTIONALLY LEET BLANK 



ACKNOWLEDGMENTS 


I would like to thank my thesis team of Professor Matthew Carlyle and Major 
Donovan Phillips for agreeing to aeeept me as the thesis student to work on this projeet 
six months ago and direet me through the proeess. Numerous additional thanks go out to 
the many professors in the NPS OR department who helped further direet me in a 
forward direction. 



THIS PAGE INTENTIONALLY LEET BLANK 


XIV 



EXECUTIVE SUMMARY 


The U.S. Army’s Future Force is being developed as a faster, lighter, more 
rapidly deployable alternative to the current force structure. The Future Force will feature 
a smaller in-theater footprint and require the ability to cover a larger area of the battle 
space with intelligence-gathering assets. To support this development the Naval 
Postgraduate School and TRAC Monterey began to conduct research in the area of 
allocation of Future Force sensor platforms. One result of that effort was the Sensor 
Allocation Model (SAM), the subject of a prior report. 

This thesis seeks to improve the Sensor Allocation Model (SAM) and translate it 
into a programming language that can easily be implemented into a simulation 
environment. Initially the model did not include realistic constraints on sensor platform 
employment duration and distance, and it overestimated sensor performance. 

The model developed in this thesis ensures that sensor platforms are represented 
realistically in terms of range, time on station, and performance level. Two major 
improvements were made: the implementation of a Probability of Line-of-Sight (PLOS) 
approach to represent the effects of terrain on sensor performance and 2) the refinement 
of the sweep width sub-model to more accurately assess sensor detection capabilities 
based on the geometry of the sensors and platforms. 

The model is demonstrated using an unclassified set of sensor performance data 
similar in type and format to the classified data currently available from the US Army 
Materiel Systems Analysis Activity (AMSAA). The data set includes ten platforms, 92 
consolidated ‘packages’ of sensor platforms, ten target clusters and four enemy order of 
battle configurations. 

This research was sponsored by the U.S. Army Training and Doctrine Command 
Analysis Center - Monterey (TRAC-Monterey). The Java SAM output has the potential 
for use as input in future simulation studies. 


XV 



THIS PAGE INTENTIONALLY LEET BLANK 


XVI 



I. INTRODUCTION 


A. BACKGROUND 

This thesis seeks to improve the Sensor Allocation Model (SAM) developed in 
[Tutton, 2003] and translate it into a programming language that can easily be 
implemented into any simulation environment. Since the new model is programmed in 
Java it is called the Java-Sensor-Allocation-Model (ISAM). At the outset of this research, 
SAM did not include realistic constraints on sensor platform employment duration and 
distance. These have now been added to the model. The model also overestimated sensor 
performance. This issue has been resolved using the geometry of the sensors and the 
target areas, as well as adding a probabilistic model of the existence of line-of-sight from 
sensor to target to capture terrain effects, so that the model represents sensor performance 
realistically. 

To define a starting point for this thesis the following paragraphs summarize the 
research that has been done in this area before. 

1, Background on the Original Sensor Allocation Model 

The original version of SAM used results from search theory to estimate the 
performance of various allocations of sensors. It employed the following levels of sensor 
aggregation: a sensor is a specific piece of technology and is the fundamental unit we 
discuss; a platform can carry (multiple) sensors on one body (e.g., an airframe); and a 
package consists of multiple platforms that will be deployed simultaneously to a single 
geographical area. Sensors are identified as specific technologies or capabilities, such as 
infrared (IR), acoustic, and radar, and their performance can be measured by a probability 
of detection at a given range against a specific target type. Platforms are further identified 
as ground or aerial, and as moving or stationary. Finally, packages consist of either a 
single platform type, or multiple platforms. Single-platform packages are referred to as 
basic packages. Basic packages can be combined to form consolidated packages, and are 
generated automatically by SAM. SAM uses the performance of each package to 


1 



determine an effeetive assignment of packages to target clusters. Figure 1 gives an 
example for target clustering. 



Figure 1. Example of Target Clustering (From [Tutton, 2003]) 


2, Sensors, Platforms and Packages in the Old Model 

Following the sweep width idea in search theory the sensor sweep width in SAM 
was gained by numerical integration over the sensor’s lateral range curve [Wagner, 
1999]. 



Range 

Figure 2. Example of a Lateral Range Curve. The vertical axis represents detection 

probability, or a similar measure for ranged devices. (Erom [Tutton, 2003]) 


2 































Each sensor detects targets with a certain probability at a certain range resulting in a 
lateral range curve for each specific sensor/target pair. Sensors are not guaranteed to 
move directly toward a target but pass the target at some lateral range within the sensor’s 
detection zone. Figure 3 below illustrates a sensor detection zone. 



Figure 3. Sensor Detection Zone (From [Tutton, 2003]) 

Sweep width is a scalar measure of the search effectiveness of a sensor. By definition, 
sweep width is equal to the area under the lateral range curve and represents the effective 
width of the sensor detection zone (see equation below). Flsing this approach in the old 
Sensor Allocation Model, sensors were modeled as ‘cookie cutter’ sensors with sweep 
width, W, defined as: 

00 

w= \Fpx)dx 

—00 

The Cumulative Detection Probability (CDP) is the probability that a platform searching 
for a target over a specific time interval detects that target at least once and is determined 
by the total amount of time spent over any single area in the region surveyed, by its 
adjusted sweep width (explained in the next paragraph) and the speed with which the 
platform moves over or within the search area. 

Multiple sensors mounted on the same platform perform at least at the level of the 
best sensor, and no better than the sum of all sensors. This aggregate platform 
performance can be depicted with an adjusted sweep width. In the absence of actual 
performance data for the platform, its adjusted sweep width is assumed to be slightly 


3 



greater than the sweep width of the best-performing sensor on the platform. Transit 
speed is defined as the speed at whieh the platform ean travel to, and return from the 
seareh area. Operational time is the amount of time a platform ean remain operational, 
including transit time and search time. Using this an associated time on station (time 
available over the search area) can be determined. 

A CDP was calculated for each individual platform (for each target type) using 
the platform’s sensing velocity, adjusted sweep width, time on station, and area of the 
target cluster. Since a uniform target distribution was assumed, the overall ‘effectiveness’ 
of a package was simply the average of the CDPs, which represents the expected 
proportion of all targets detected within a cluster. Thus the package CDP could be 
determined using the velocity, sweep width, and time on station of any platform in the 
package because each platform had the same CDP once the effective proportion of search 
area was determined. 

3. Enemy Order of Battle and System Characteristics 

Four potential enemy orders of battle (EOBs) were generated to model the 
uncertainty associated with target location, type and number of entities for each identified 
target cluster. Each EOB had a probability of occurrence that the model considered when 
determining a robust allocation of sensors to target areas. 

Sensor platform combinations were evaluated using the four characteristics of 
cost, logistical footprint, perishability (opposite of survivability), and latency. Each 
characteristic can be calculated at each level of aggregation, and used at the package level 
to assess overall characteristics of the suite of packages employed. SAM allowed the 
analyst or decision maker to provide a relative weighting to each characteristic category 
according to importance in the scenario or outcome. The objective function of SAM 
incorporated these characteristics by minimizing their effects while maximizing expected 
number of targets detected in the search area. The solution of SAM, for any threat 
scenario, is a proposed packaging of available sensors, and an assignment of those 
packages to target areas, in order to maximize the effectiveness of the sensors employed. 

See appendix for the description of the optimization model in NFS format. 


4 



B, PROBLEM DEFINITION 

Tutton [Tutton, 2003] extended the baste idea of sensor employment in SAM to 
find an appropriate mix and alloeation strategy for organie Unit of Aetion sensors in a 
given threat seenario. The mix suggested by the model is robust to uncertainties in sensor 
performance and target quantity and location, as modeled by a finite (but possibly large) 
number of credible scenarios. This includes the ability to model weather effects as well. 
The model shows great promise for use as a screening tool in support of analysis of 
alternatives (AOA) studies as well as in support of Army and Joint war fighting 
experimentation. The model also has potential for use as an operational decision support 
tool for unit commanders. 

This thesis builds on the model described above. The two principal research 
questions we address are as follows: “How can SAM be improved and brought to the 
point where it can be validated for use in Future Combat Systems studies and analyses?” 
and “How can SAM be translated into a programming language that easily can be 
implemented into any simulation environment?” 

The first question is especially interesting because of several problems that 
evolved when the model was designed in the first place. Initial testing revealed that SAM 
overestimated sensor performance. The calculated sweep width for the sensors on the 
various platforms are too wide compared to data generated with real sensor platforms. A 
probability-of-line-of-sight approach for representing sensor degradation due to terrain 
solves part of the problem, but the model needs to be further redefined and extended. 
Constraints for operational time and distance also needed to be improved. 

To understand the second question, it is necessary to describe the model setup a 
little bit more in detail. The model actually has two parts, a preprocessor part and an 
optimization part. The preprocessor calculation section uses inputs from the user and data 
management sections to calculate required input for the optimization part. Required 
preprocessor calculations include such things as platform time on station (in hours), 
target cluster search area (in square kilometers), platform characteristic information, and 
consolidated package performance measures. The optimization part of the model is 
defined in the General Algebraic Modeling System (GAMS), a mathematical modeling 


5 



language especially suited for optimization. To embed SAM into a simulation, both the 
preprocessor and the model need to be included into a programming environment. At the 
moment it takes several manual steps to set the preprocessor and the model up for an 
optimization run. We have developed an implementation of SAM in Java, for use with 
Simkit, a Java based simulation environment. This implementation needs to have a 
structure that makes it easy to exchange data, and evolving data issues still need to be 
identified and resolved. 

C. SCOPE, LIMITATIONS AND ASSUMPTIONS 

To answer the stated research questions we developed a Java program to do all the 
preprocessor calculations, call GAMS, and capture the GAMS output. Within this setup 
the model has been improved to produce usable output results, and distance and time 
constraints have been added to the model. Probability of Line of Sight (PLOS) 
calculations have also been added to the model to allow more realistic estimates of sensor 
performance in a variety of scenarios. 

For each scenario we assume all sensor platforms are located at a single, 
predefined entry point. We use ten different target types and ten cluster areas different in 
location and dimension. For testing purposes the target distribution within a cluster is 
generated by the program on a random basis. However seeds can be used to fix the 
produced distributions. The scenarios used are different in location based on the 
underlying terrain and on the target distribution generated by the program. In the 
analysis part of this thesis we distinguish between six different scenarios. Three have 
fixed terrain using the PLOS model, but different seeds for the target distribution, and 
three have the same seed but with different terrains. 

One optimization run takes about 30 seconds. The optimization model that needs 
to be solved consists of 416 Continuous Variables, 7680 Integer Variables and 7680 
Binary Variables. There are two sets of constraints defined in the model. One with a total 
number of 7744 constraints and one with a total number of 416 constraints. Considering 
the described complexity of the Optimization Program, 30 seconds is not a bad runtime. 
Although not perfect it is still possible to use the model in a simulation environment. 


6 



More than 99% of the time is used to solve the optimization model. There is also a good 
ehanee that the runtime ean be signifieantly deereased by using a faster commereial 
solver than the XP-Solver in the GAMS environment. 


7 



THIS PAGE INTENTIONALLY LEET BLANK 


8 



II. IMPROVEMENTS TO SAM 


A. REFINEMENT OF SENSOR ALLOCATION LOGIC 

1. Employment Probability of Line Of Sight 

One of the most serious limitations of the first version of SAM was that it did not 
take the effeets terrain on sensor performanee into account. The model assumed the 
ground to be a flat plane. Observer to target line-of-sight interruption affected by 
roughness of terrain remained unaccounted for. To overcome this limitation we 
implemented a Probability of Line of Sight model following the JWARS approach 
[Blacksten, 2002]. The most basic idea behind the implementation is that the sensor 
performance data provided by AMSAA describes the conditional probability to detect a 
target given that line-of-sight exists, and the PLOS methodology provides the probability 
that line of sight exists. Using the following basic probabilistic formula for conditioning 
we achieve the ‘true’ probability of detection. 

(R) = Pj^(R\ LOS )• Pj^(LOS) ( 1 ) 

Based on operational altitude of the observer and given terrain characteristics the 
JWARS PLOS model provides the probability to detect a target at a specific range. As a 
measure of precision this distribution can be compared to empirical data that can be 
generated. Empirical PLOS curves are constructed by randomly dropping observer-target 
pairs on the terrain in question, each pair separated by a specified range and observer 
height. This sampling is repeated for some number of trials to establish an average PLOS 
for the terrain type, range and observer height used. This is repeated for a series of ranges 
to give an empirical PLOS curve for the specified observer height. The process is then 
repeated for other observer heights of interest to yield a family of curves. An example is 
given in Figure 4. 

The JWARS PLOS model is subdivided into three parts that build on each other. 
In the first step the parametric effective roughness curve is designed. As a first 
implementation in SAM the data in column 6 (Southern Iran, Moderate mountainous) 
was used. 


9 



Empirical PLOS Distribution 



Figure 4. Empirical PLOS Distribution 


The four parameters in this formula are Corrected Roughness Ceiling, Corrected 
Roughness Growth Rate, Extinction Ceiling and Extinction Growth Rate. Corrected 
Roughness Ceiling is the effective maximum value of roughness as ranges become large. 
Corrected Roughness Growth Rate is the growth rate parameter for the model. The 
dimensions are meters and meters'^ Extinction Ceiling is the highest value possible for 
the extinction factor in the model and the Extinction Growth Rate is a measure of how 
fast the extinction coefficient grows with roughness. These parameters have to be defined 
to give the best fit to the empirical PLOS curves. 


Lat Long 

20N SOW 

23N 48W 

25N SOW 

28N 48W 

28N S2W 

28N S7W 

30N SSW 

33N 48W 

33N S3W 

Location 

Description 

Southeast 

centrai 

Saudi 

Arabia 

Desert 

dunes? 

Eastern . 

^ , Eastern 

central . , 

Q coastal 

Saudi Arabia 

Arabia 

Piedmont? Flat coastal? 

North 

eastern 

coastal 

Saudi 

Arabia 

Flat 

coastal? 

Western Iran 

Moderate 

mountainous 

Southern 

Iran 

Moderate 

mountainous 

Central Iran 

Mountainous 

^ , ,, Central 

Central Iran , 

Iran 

Mountainous? Piedmont? 

Corrected 










Roughness 
Ceiiing (m) 
Corrected 

6.59E+00 

3.46E+00 

4.31 E+00 

1.12E+01 

7.S4E+02 

1.45E+01 

2.1SE+01 

S.69E+01 

1.44E+03 

Roughness 
Growth Rate 
(m/m) 

1.22E-03 

6.83E-04 

2.2SE-04 

S.69E-04 

4.33E-0S 

7.04E-04 

6.99E-0S 

3.40E-04 

2.61 E-06 

Extinction 

Ceiiing (m"') 
Extinction 

2.13E-04 

7.54E-05 

2.S2E-04 

1.20E-04 

7.43E-04 

6.0SE-04 

S.26E-04 

4.78E-04 

3.60E-04 

Growth Rate 
(m/m) 

8.34E-01 

8.356E-01 

1.08E+00 

S.S3E-01 

8.60E-01 

S.69E-01 

1.30E+00 

1.06E+00 

1.31 E+00 


10 











Figure 5. 


PLOS Parameters for predefined locations 


The effect of PLOS implementation in the SAM can easily be shown graphically. 
Figure 6 shows the probability of detection graph without PLOS correction and Figure 7 
shows the same graph after the PLOS correction. It can be seen that the probability to 
detect a target decreases significantly even for small ranges at around 500 meters. This 
curve is much more realistic than the one without the PLOS correction. It does not 
overestimate the sensor capabilities as much as the pure probability curve. 


Platform 5 against Target 2 (Tank) 



0 500 1000 1500 2000 2500 3000 

Range 

Figure 6. Probability of Detection without PLOS 


Platform 5 against Target 2 (Tank) 



Figure 7. Probability of Detection after PLOS correction 

2, Implementation of Distance and Time Constraints 

The implementation of constraints for operational time and radius turned out to be 
relatively easy in Java. The operational time constraint was already implemented in the 
spreadsheet preprocessor developed by Tutton and Olson [SMM Preprocessor, 2003]. In 


11 














this modeling approach the preprocessing part was done in an Excel workbook with 
several spreadsheets. As a first step for the implementation two floating point arrays were 
used to store operational time and radius values for the different platforms. The values 
used for this thesis are shown in Table 1. They are taken from the platform description in 
the ‘Army Future Combat Systems Unit of Action Systems Book Version 3.0’ [AMSAA, 
22 May 2003]. 


Platform 

UAV 

UAV 

UAV 

UAV Class 

ARV 

UGS 


Class I 

Class II 

Class III 

IVa 

RSTA 


Operational Time 

[hours] 

1 

2 

6 

5 

72 

72 

Operational Radius 

1km] 

16 

30 

40 

75 

50 

assumed 

unlimited 


Table 1. Operational Time and Radii for different Platforms 
It is worth mentioning that the UGS is the only stationary platform. Its search speed is 
zero. The CDP for a UGS is calculated based on target speed which usually is much 
smaller than the average search speed of a UAV. It is designed to operate for 72 hours 
and decreasing this time decreases its cumulative detection probability significantly. The 
Operational Radius is assumed to be unlimited because these platforms can be delivered 
by several long-distance means (aircraft, artillery tube, etc.). 

The values for operational time and radius are used to calculate the time-on- 
station for a platform. Using travel speed and distance from the entry point to the closest 
point of a cluster we get the travel time. This time can be subtracted from the operational 
time to give the time-on-station. If this value is negative it is set to zero, which essentially 
means that the platform cannot get to an area (and back) within the time frame of the 
scenario, and therefore will have no time to search for targets. If a cluster lies outside the 
operational radius of a platform the time on station also is set to zero. This simple 
adjustment to the data makes sure that a platform is not used outside its operational radius 


12 





or outside its operational time. (The described calculation is performed in the 
timeOnStation method in the class Platforms, see Appendix B. 

3, Adjustments to Represent Sensor Performance Realistically 

To determine how best to model the performance of sensor platforms in our 
model, we must first have a sense as to how the platform performs operationally. 
Additionally, since most of these platforms exist in concept only, their operational 
employment techniques can only be surmised. One expert opinion on how these 
platforms may be employed is summarized as follows (an airborne platform with an 
optical or IR sensor is assumed); as the platform proceeds along its search path, it 
captures three ‘stilT images - left, center, and right with respect to its flight direction. 
Still images from a moving platform are obtained by vertically (in the direction of flight) 
moving the sensor lens to briefly (1-2 seconds) compensate for the platform’s forward 
movement. The sensor lens is then shifted horizontally (orthogonal to flight direction) to 
obtain the center and right images in similar fashion. This process is repeated continually 
as the platform proceeds along its search path, resulting in an effective search width of 
three times the sensor’s field of view (FOV). See Figure 8. 

A new modeling approach was developed to represent sensor platform 
employment as described above. The sensor itself is restricted by vertical and horizontal 
angles within which they can observe - its FOV. Within this FOV a sensor can detect 
targets with specific probability that is defined by the observing sensor, sensor-target 
range, and target type. Outside the FOV, the probability to detect a target is zero. In our 
modeling approach one or more sensors are mounted on each platform and each of them 
looks in a specific observation angle forward and captures still images as described in the 
paragraph above and Figure 8. 


13 


Horizontal UAV 



center 

picture 


Figure 8. Basic modeling idea 

Our model represents sensor performance as if the sensor takes three pictures in a 
row before the platform moves on to the next sector, as shown in Figure 9. Platform 
speed and altitude are assumed fixed (user input data). 



Figure 10 shows how the ground distances from the sensor to the three pictures 
(left, center and right) in one sector are calculated in ISAM. Depending on the geometric 
differences in surface range and slant range to the sensor the center picture and the side 
pictures (left and right) have a different geometry. In this diagram the pictures are drawn 
side by side. This is not how they really are distributed in the sector but is necessary to 
calculate the distances correctly. Based on the surface range from the sensor to the center 
of each picture, an ‘average’ detection probability is interpolated from sensor 
performance data input. The sensor is assumed to perform at this ‘average’ level at all 
points within the picture. 


14 





































UAV 



Figure 10. Ground Distances 


Picture length, picture width and probability to detect a target within a picture are 
used to define a volume that represents the detection capability of the sensor in one 
picture. This volume can be transformed into a cube with probability of detection one and 
an effective detection area smaller than the original picture area. The volumes of the two 
cubes are, of course, identical. The effective detection area is the area relative to the 
original picture within which the probability to detect a target would be one (note: this is 
the three-dimensional analog to the two-dimensional Sweep Width concept discussed in 
section 1.2). See Figure 11. 


Effective 

Detection 



Figure 11. Area Transformation 

Finally we can sum the effective detection areas of the tree pictures in a sector to 
get the total effective area covered in a sector. To simplify the model, the sector length is 
assumed to be twice the length of a picture (in reality, this dimension depends on several 
factors: length of time spent observing a single picture area; altitude; speed; and 


15 

































observation angle). As shown in Figure 12 this now can easily be transformed into a 
sensor sweep width. 



Effective 
Detection Area 


Figure 12. Transformation for Sensor Sweep Width 


B. ADAPTATION OF SAM FOR INTEGRATION WITH A SIMULATION 

ENVIRONMENT 

Initially SAM was designed in two parts. An Excel Workbook with various 
macros was used to do all the preprocessing. The optimization model itself was and still 
is defined in the General Algebraic Modeling System (GAMS). The way the model was 
set up the user had to do several steps manually before he could start the optimization in. 
To port SAM into Java the system had to be refined and restructured. Objective was to 
create a program that in one single step does all the preprocessing calculations, produces 
the necessary GAMS input files, starts GAMS and captures the GAMS output. The final 
design setup is shown in Figure 13. It uses interfaces as well as inheritance. 


16 
























lnput_ModelData 

<lnterface> 

Parameters for modeling: 
-FLOS 

- Platform SweepWidth 

- Package Combinations 

- Package Characteristics 

- Enemy Order of Battle 
Cluster Coordinates and 

Dimensions 


Sensors 

- int numberOfPlatforms; 

- int numberOfTargets; 

- int sensorDataHight; 

- int sensorDataWidth; 

- int[] numberOfSensors; 

- double[][] centerPictureWidth; 

- double[][] sidePictureWidth; 

- double[][] pictureLength; 

- double[][] longCPictDist; 

- double[][] shortSPictDist; 

- double[][] longSPictDist; 

- double[][][] toRangeArray 

- double[][][] centerPictureProbability 

- double[][][] sidePictureProbability 

- double[][][] sensorSweepWidth 

- double[][][][] rangeData 

- double[][][][] plosCorrectedData 

- double[][][][] sensorData 

- void sensorDataO 

- void plosCorrectedDataO 

- void pictureDimensionsO 

- void pictureDistancesO 

- void pictureProbabilityO 

- void sensorSweepWidthO 


Platforms extends 
Sensors 


Packages extends 
Platforms 

- double[][] platformSweepWidth 

- double[][] timeOnStation 

- double [][][] platformRate 

- double[][][] platformCDP 

-► 

- int numberofPackages 

- int[][] packageCombinations 

- double[][] packageCharacter... 

- double[][][] packageCDP 



- void packageCombinationsO 

- void packageCharacteristicsQ 

- void packageCDPQ 

- int chooseO 

- int fact() 

- void platformSweepWidthO 

- void timeOnStationO 

- void platformCDPO 



I 



Gams Handling 


Scenario extends 


- Scenario scenario 

- int[][] allocationData ^ 


Packages 


- int scenarioData 

- int[][] targetDistribution 

- void startGAMSO 

- void allocationTableO 

- void scenarioDataO 

- void targetDistributionO 


—► Output_Command 

- Scenario scenario 

- Gams Handling gams 

Output for data sets in: 

- Input_ModelData 

- Sensors 

- Platforms 

- Packages 

- Scenarios 


- Output_GamsFiles 

- Scenario scenario 


- void makeTargetDistributionO 

- void makePackageCombinationsO 

- void makePackageCharacteristicsO 

- void makePackageCDPO 


Figure 13. ISAM Design Concept 

ISAM consists of eight classes shown in the diagram and the Main class from which the 
program is executed. The classes Sensors, Platforms, Packages and Scenario inherit from 
each other. This makes sense since Sensors are mounted on Platforms and Platforms are 
combined to Packages. Finally Packages are employed in Scenarios. Another good reason 
for doing this is that parameters defined in parent classes are available in child classes. In 
our case this means that all instance variables defined in the parent classes are available 
in the child class Scenario. This class is the only one of the four that needs to be 
instantiated in Main. The object instantiated from Scenario is called scenario. The 


17 














































interface ‘Input ModelData’ is implemented by all other classes besides Main. It is used 
to control the model. All model parameters are defined within this class. For the user this 
is very convenient. The complete parameter set up can be done from within this class. 
‘Output Command’ handles all output methods that print to the command line. This again 
is very convenient for the user. If one of the output methods needs to be adjusted he just 
needs to focus on this one class. The ‘Output Command’ is instantiated in Main. The 
object is called output. 

The Optimization Part of the model is executed in GAMS. ISAM handles this with the 
‘Output GamsFiles’ and ‘Gams Handling’ classes. ‘Output GamsFiles’ produces four 
GAMS input files. ‘Gams Handling’ starts GAMS as a Java encapsulated process. This 
process runs completely in the background, invisible to the user. It also captures the 
GAMS output. ‘Output GamsFiles’ as well as ‘Gams Handling’ are instantiated in Main. 
The objects are called gamsFiles and gams respectively. 


18 



III. ANALYSIS 


A, TEST AND EVALUATION OF THE ISAM OUTPUT FOR DIFFERENT 

TARGET DISTRIBUTIONS 

The main purpose of this ehapter is to test the program and to analyze and 
evaluate the optimization output. In this first subehapter the faetor of varianee is ehosen 
to be the distribution of targets on the battlefield. It was mentioned earlier in the text that 
ISAM is capable of producing target distributions randomly. In the following test setup 
three different seeds are used to generate three different target distributions. The 
objective of this test is to see if the program can handle different types of input and if the 
optimization results generated make sense. It is expected that the output for each run is 
different. The distribution of targets within clusters is one of the main factors for the 
GAMS optimization model. The different seeds for runs one to three are as follows: 


r'mn 13769 run 45832 3^Vn 91273 

The values chosen for all other model variables and parameters are shown in Figure 14. 
This is to make sure that the analysis can easily be reproduced. The reader just needs to 
copy the content and paste it into the class Input ModelData. The values for the seeds of 
course need to be set accordingly. I used ISAM Version 1.5 for the analysis. It is more 
convenient than Version 1.6, which is optimized for the implementation into an Event 

Graph Simulation. Besides this the two versions produce exactly the same output. 

II parameters for modeling PLOS 
double sigma ceiling =14.5; 

doublegrgh" =0.000704; 

doublec’ceiling =0. 0 0 0 6 0 5; 

doublegAtnct =0.5 69; 

double!) oper at ona I Al t i t ude = { 1 5 0.0, 3 0 0.0, 6 0 0.0, 2 0 0 0.0, 3.0, 1.0 }; 

II parameters for modleing platform 5 weep Width 
doublellll horizontalAngle = { 

{ 2 0.0 0, 1 5.0 0 }, 

{ 2 0,0 0, 9.2 0 0 }, 

{ 8.9 2 0, 8.9 0 0 }, 

{ 8,9 2 0, 8.9 0 0 }, 

{ 2 0,0 0, 1 5.0 0 }, 

{ 1 0,0 0, 7.5 0 0 } 

}; //[Platform] [Sensor] horizontal observation angle 

double]]]] vertical Angle = { 

{ 1 5,0 0, 1 1.2 5 }, 

{ 1 5.0 0, 6.9 0 0 }, 

{ 6.6 8 0, 6.7 0 0 }, 

{ 6.6 8 0, 6.7 0 0 } 

}; //[Platform] [Sensor] vertical observation angle 

double)] observationAngle = {45.0, 45.0, 45.0, 45,0}; //[Platform] 
double swag_dependance = 0.1; 


19 


II parameters for modeling package combinations 
i nt[1[1 basi c Pac kages = { 


{ 

1, 

0, 

0, 

0, 

0, 

0}, 

//PI 

at f or mComb 

nat 

0 n 

f 0 r 

Package 

1 

{ 

0, 

1, 

0, 

0, 

0, 

0}, 

//PI 

at f or mComb 

n a t 

0 n 

f 0 r 

Package 

2 

{ 

0, 

0, 

1, 

0, 

0, 

0}, 

//PI 

at f or mComb 

nat 

0 n 

f 0 r 

Package 

3 

{ 

0, 

0, 

0, 

1, 

0, 

0}, 

//PI 

at f or mComb 

nat 

0 n 

f 0 r 

Package 

4 

{ 

0, 

0, 

0, 

0, 

1, 

0}, 

//PI 

at f or mComb 

nat 

0 n 

f 0 r 

Package 

5 

{ 

0, 

0, 

0, 

0, 

0, 

1}, 

//PI 

at f or mComb 

nat 

0 n 

f 0 r 

Package 

6 

{ 

1, 

1, 

0, 

0, 

0, 

0}, 

//PI 

at f or mComb 

nat 

0 n 

f 0 r 

Package 

7 

{ 

0, 

0, 

1, 

1, 

0, 

0}, 

//PI 

at f or mComb 

n a t 

0 n 

f 0 r 

Package 

8 


}; 


double package_enhFact = 1.1; 


II parameters for modleing 

Package 

Character! sti c s 






d 0 u b 1 

el 1 

pi atformtatency 

= 

{0. 

6, 

0. 5, 

0. 3, 

0. 

1, 0.4, 

1. 0} 



d 0 u b 1 

el 1 

pi at f 0 r mCost 

= 

{0. 

1, 

0. 3, 

0.7, 

1, 

0, 0.8, 

0. 2} 



d 0 u b 1 

el 1 

platformPerishability 

{0. 

2, 

0. 2, 

0, 8, 

1, 

0, 0.4, 

0. 2} 



d 0 u b 1 

el 1 

pi atformLogi sti cs 

= 

{0. 

3, 

0. 4, 

0, 5, 

0, 

7, 0.1, 

0. 1} 



d 0 u b 1 

el 1 

travel Speed 

= {80 

. 0, 


100. 0, 

2 0 0, 

0, 

135. 0, 

200 

. 0, 

2 0 0,0 } 

d 0 u b 1 

el 1 

searchSpeed 

= {60 

. 0, 


80. 0, 

140, 

0, 

100.0, 

20. 

0, 

0,0 } 

d 0 u b 1 

el 1 

operati onal Ti me 

= {2. 

0, 


2. 0, 

6,0, 


5, 0, 

72. 

0, 

72,0 } 

d 0 u b 1 

el 1 

operati onal Radi us 

= {16 

. 0, 


30. 0, 

40,0, 

75, 0, 

800 

. 0, 

800,0} 


boolean!) airDropped = {false, false, false, false, true, true,}; 


II cluster coordinates and dimensions 


d 0 u b 1 el 1 

entryPoint = {19.0, 

50, 0}; 


doublellll cluster Data = { 



{30, 5, 

5 4.0, 3 1.0, 2 2,0 }, 

//cl ust er 

01 {xCoord, yCoord, ewDimension, nsDimension} 

{20, 5, 

3 9.0, 2 1.0, 2 8,0 }, 

//cl ust er 

‘02 

{36, 0, 

4 4.0, 2 0.0, 1 8.0 }, 

//cl u s t e r 

'03 

{49, 0, 

6 3.5, 3 2.0, 2 3,0 }, 

//cl ust er 

'04 

{50, 5, 

4 9.0, 2 9.0, 2 6,0 }, 

//cl ust er 

‘05 

{48,0, 

3 2.0, 2 4.0, 2 8,0 }, 

//cl u s t e r 

'06 

{65, 0, 

5 3.0, 2 0.0, 3 4,0 }, 

//cl ust er 

'07 

{62,5, 

3 2.0, 2 5.0, 2 8,0 }, 

//cl ust er 

"08 

{55. 5, 

2 0.5, 3 9.0, 1 5.0 }, 

//cl u s t e r 

'09 

{62,0, 

}; 

10.0, 28.0, 31.0}, 

//cl ust er 

AO 

d 0 u b 1 el 1 

targetSpeed = {1.0, 

5,0, 4.0, 

7.0, 5.0, 6,0, 6, 0, 6,0, 7.0, 5.0}; 

II e n e my 

order of battle 



long scenario Seed 

= 13769; 


I nt max Nu mber Of Ta r get s 

= 100; 


d 0 u b 1 e [ I 

eOB_Fact or 

= {0.45, 

0.5 0, 0.6 0, 0.6 5 }; 


Figure 14. Variable and Parameter setup for Analysis with different target 

distributions 


For this modeling set up the following ten targets were used: 


Target 1 

Rifleman, RPG, SOF 

Target 2 

Tracked Main Battle Tank 

Target 3 

Special Purpose Artillery 

Target 4 

Wheeled Light Transport 

Target 5 

Tracked Armor Vehicle 

Target 6 

Fleavy Wheeled Transport 

Target 7 

Towed Artillery 

Target 8 

Wheeled Armor Vehicle 

Target 9 

Engineer Vehicle 

Target 10 

Tracked Missile Launcher 

Table 2. 

Target Description 


20 




















The target distribution generated for the first run with seed 13769 is shown in Table 3. 




Target 

Di St 

: r 1 but i or 

1 EOBOl ■ 





Tar get 

Di St 

: r 1 buti on 

EOBll ■ 



Cl 

TOl 

T02 

T03 

T04 

T05 

T06 

T07 

T08 

T09 

TIO 

Cl 

TOl 

T02 

T03 

T04 

T05 

T06 

T07 

T08 

T09 

TIO 

01 

026 

089 

069 

000 

025 

006 

071 

000 

072 

000 

01 

026 

000 

069 

013 

000 

000 

000 

000 

072 

000 

02 

088 

027 

000 

000 

040 

000 

000 

099 

000 

000 

02 

000 

027 

047 

000 

040 

000 

000 

000 

000 

000 

03 

000 

000 

000 

065 

000 

000 

000 

000 

000 

020 

03 

000 

000 

078 

065 

000 

053 

073 

056 

060 

000 

04 

000 

000 

000 

000 

000 

000 

000 

013 

000 

045 

04 

000 

100 

044 

070 

000 

000 

000 

000 

000 

045 

05 

000 

000 

000 

000 

000 

000 

000 

000 

000 

000 

05 

000 

050 

000 

000 

Oil 

076 

000 

091 

029 

049 

06 

035 

002 

000 

083 

000 

055 

053 

000 

000 

000 

06 

000 

002 

000 

083 

013 

000 

053 

047 

057 

000 

07 

000 

000 

000 

000 

000 

081 

033 

000 

000 

000 

07 

064 

000 

075 

000 

080 

081 

033 

028 

000 

000 

08 

000 

005 

076 

018 

063 

000 

000 

000 

000 

000 

08 

000 

000 

000 

000 

063 

064 

060 

075 

000 

099 

09 

013 

024 

000 

009 

000 

012 

000 

000 

000 

000 

09 

000 

000 

000 

009 

000 

000 

000 

000 

019 

022 

10 

000 

002 

000 

000 

000 

000 

099 

026 

099 

000 

10 

021 

000 

091 

093 

089 

000 

099 

000 

000 

044 



Target 

Di St 

: r i but i or 

1 E0B21 ■ 





Tar get 

Di St 

: r i buti on 

EOB31 ■ 



Cl 

TOl 

T02 

T03 

T04 

T05 

T06 

T07 

T08 

T09 

TIO 

Cl 

TOl 

T02 

T03 

T04 

T05 

TOO 

T07 

T08 

TOO 

TIO 

01 

026 

000 

069 

013 

000 

000 

000 

013 

000 

091 

01 

026 

089 

069 

013 

025 

006 

000 

013 

000 

091 

02 

088 

000 

047 

000 

040 

000 

097 

000 

036 

000 

02 

088 

027 

000 

060 

040 

092 

097 

099 

036 

000 

03 

000 

089 

078 

065 

000 

053 

000 

056 

060 

000 

03 

000 

000 

000 

065 

000 

053 

073 

000 

060 

000 

04 

035 

100 

044 

070 

000 

000 

004 

013 

000 

000 

04 

000 

100 

044 

070 

000 

037 

004 

013 

000 

045 

05 

000 

000 

055 

017 

Oil 

000 

000 

091 

029 

049 

05 

000 

050 

055 

017 

000 

076 

072 

091 

029 

000 

06 

035 

000 

038 

000 

013 

055 

000 

047 

000 

000 

06 

000 

002 

038 

083 

013 

000 

053 

047 

000 

000 

07 

000 

036 

075 

000 

000 

081 

033 

028 

000 

000 

07 

000 

000 

000 

000 

080 

081 

000 

000 

061 

050 

08 

024 

000 

076 

018 

063 

064 

000 

000 

000 

000 

08 

000 

005 

076 

018 

063 

000 

000 

075 

073 

000 

09 

000 

000 

077 

000 

015 

000 

000 

043 

000 

000 

09 

000 

024 

077 

009 

015 

012 

000 

043 

000 

000 

10 

000 

000 

091 

000 

089 

015 

000 

000 

099 

044 

10 

021 

002 

091 

093 

089 

015 

099 

026 

000 

044 


Table 3. Randomly generated target distribution (seed 13769) 


The tables are very easy to read. Eaeh sub table eonsists of ten rows for ten clusters and 
ten columns for ten targets. The number 026 in the first row first column means that there 
are 26 targets of type one in cluster one. In cluster 07 there are 81 targets of type 6. The 
target distribution generated for the second run with seed 45832 is shown in Table 4. 




Tar get 

Di St 

r I b ut1 0 r 

1 EOBOl ■ 





Tar get 

Di St 

ribut I 0 r 

1 EOBll ■ 



Cl 

TOl 

T02 

T03 

T04 

T05 

T06 

T07 

T08 

T09 

TIO 

Cl 

TOl 

T02 

T03 

T04 

T05 

T06 

T07 

T08 

TOO 

TIO 

01 

000 

068 

000 

058 

000 

000 

087 

033 

087 

052 

01 

096 

068 

000 

000 

000 

012 

087 

033 

000 

000 

02 

094 

000 

000 

000 

079 

018 

000 

000 

000 

000 

02 

094 

000 

044 

000 

000 

018 

000 

080 

000 

000 

03 

000 

000 

099 

000 

037 

067 

000 

000 

038 

072 

03 

000 

000 

099 

000 

037 

067 

000 

090 

000 

000 

04 

066 

000 

043 

083 

000 

035 

000 

000 

000 

044 

04 

000 

000 

043 

083 

029 

000 

093 

042 

050 

044 

05 

000 

000 

015 

000 

000 

000 

053 

041 

049 

000 

05 

000 

000 

015 

059 

000 

033 

053 

000 

049 

064 

06 

000 

000 

091 

063 

058 

000 

024 

000 

000 

000 

06 

066 

081 

091 

063 

000 

000 

024 

000 

000 

000 

07 

000 

000 

000 

012 

000 

000 

035 

000 

000 

087 

07 

031 

000 

000 

012 

021 

073 

000 

044 

000 

087 

08 

016 

020 

000 

000 

000 

095 

007 

000 

070 

000 

08 

000 

000 

028 

000 

051 

000 

007 

000 

000 

000 

09 

000 

048 

040 

091 

000 

088 

076 

000 

000 

000 

09 

000 

000 

000 

091 

000 

000 

076 

000 

000 

055 

10 

000 

049 

000 

000 

063 

000 

000 

000 

000 

000 

10 

000 

000 

000 

003 

063 

096 

000 

000 

002 

000 




Target 

Di St 

r i buti on 

EOB21 - 





Target 

Di St 

: r 1 but i or 

1 EOB31 ■ 



Cl 

TOl 

T02 

T03 

T04 

T05 

T06 

T07 

T08 

TOO 

TIO 

Cl 

TOl 

T02 

T03 

T04 

T05 

T06 

T07 

T08 

TOO 

TIO 

01 

000 

068 

071 

058 

059 

012 

087 

000 

000 

052 

01 

000 

068 

071 

058 

059 

012 

000 

033 

087 

000 

02 

094 

000 

044 

000 

079 

000 

000 

080 

044 

000 

02 

094 

000 

000 

000 

079 

000 

027 

080 

000 

000 

03 

076 

082 

099 

051 

037 

067 

045 

090 

000 

072 

03 

076 

000 

099 

051 

037 

000 

045 

090 

000 

072 

04 

066 

000 

043 

000 

029 

035 

093 

000 

050 

000 

04 

066 

028 

043 

083 

000 

035 

093 

042 

050 

044 

05 

000 

047 

015 

000 

037 

000 

053 

041 

049 

000 

05 

008 

047 

000 

059 

037 

000 

053 

041 

049 

000 

06 

000 

081 

091 

063 

058 

000 

000 

054 

000 

000 

06 

066 

081 

000 

063 

058 

023 

024 

054 

100 

004 

07 

031 

050 

007 

012 

021 

073 

035 

044 

000 

000 

07 

031 

050 

000 

012 

000 

073 

035 

044 

030 

000 

08 

016 

000 

000 

083 

000 

095 

000 

000 

000 

000 

08 

016 

020 

028 

000 

000 

095 

000 

000 

070 

000 

09 

055 

000 

040 

091 

005 

088 

076 

000 

049 

055 

09 

055 

000 

040 

000 

000 

088 

000 

000 

049 

000 

10 

000 

049 

000 

003 

063 

096 

006 

064 

002 

072 

10 

077 

049 

000 

000 

063 

096 

006 

000 

002 

072 


Table 4. Randomly generated target distribution (seed 45832) 


21 


















Table 5 shows the target distribution generated for the third run with seed 91273. 




Target 

Di St 

r I buti on 

EOBOl ■ 





Tar get 

Di St 

r i buti on 

EOBll ■ 



Cl 

TOl 

T02 

T03 

T04 

T05 

T06 

T07 

T08 

T09 

TIO 

Cl 

TOl 

T02 

T03 

T04 

T05 

T06 

TOT 

T08 

T09 

TIO 

01 

000 

062 

000 

070 

085 

045 

000 

003 

080 

002 

01 

069 

000 

000 

070 

085 

045 

038 

003 

080 

000 

02 

000 

000 

000 

082 

000 

000 

000 

043 

100 

057 

02 

000 

062 

088 

082 

065 

073 

070 

043 

000 

057 

03 

034 

000 

000 

000 

000 

049 

075 

094 

000 

055 

03 

000 

060 

000 

065 

000 

049 

000 

094 

063 

055 

04 

000 

044 

000 

000 

055 

000 

035 

000 

000 

051 

04 

000 

000 

097 

000 

055 

024 

035 

000 

000 

051 

05 

000 

096 

000 

049 

000 

060 

000 

000 

081 

000 

05 

000 

096 

089 

000 

005 

000 

000 

096 

081 

000 

06 

074 

000 

000 

Oil 

000 

000 

006 

000 

000 

000 

06 

000 

069 

000 

Oil 

055 

000 

000 

032 

000 

042 

07 

000 

053 

000 

014 

043 

016 

000 

095 

000 

050 

07 

000 

053 

093 

014 

043 

016 

049 

000 

063 

000 

08 

002 

000 

072 

000 

000 

000 

091 

000 

000 

064 

08 

002 

000 

000 

077 

012 

047 

091 

000 

039 

064 

09 

000 

009 

078 

028 

013 

000 

039 

000 

000 

025 

09 

095 

000 

000 

028 

013 

022 

000 

000 

090 

025 

10 

062 

000 

000 

092 

000 

019 

015 

000 

071 

000 

10 

062 

046 

090 

000 

061 

019 

015 

006 

000 

097 



Tar get 

Di St 

r I buti on 

E0B21 ■ 





Tar get 

Di St 

r i buti on 

E0B31 ■ 



Cl 

TOl 

T02 

T03 

T04 

T05 

TOO 

T07 

T08 

T09 

TIO 

Cl 

TOl 

T02 

T03 

T04 

T05 

TOO 

TOT 

T08 

TOO 

TIO 

01 

069 

062 

000 

070 

000 

045 

038 

000 

000 

002 

01 

069 

000 

000 

070 

000 

045 

038 

003 

080 

000 

02 

022 

062 

088 

000 

000 

000 

070 

043 

100 

057 

02 

022 

062 

088 

082 

000 

000 

070 

043 

100 

000 

03 

034 

000 

047 

065 

067 

049 

075 

094 

063 

055 

03 

034 

060 

047 

000 

000 

049 

075 

094 

063 

055 

04 

000 

044 

000 

031 

000 

024 

000 

000 

099 

000 

04 

037 

044 

097 

000 

055 

024 

000 

016 

099 

051 

05 

000 

096 

000 

000 

005 

060 

000 

096 

081 

000 

05 

090 

000 

089 

049 

005 

000 

054 

096 

081 

000 

06 

074 

069 

035 

000 

000 

000 

000 

032 

000 

000 

06 

074 

069 

035 

000 

055 

065 

000 

032 

053 

042 

07 

097 

053 

093 

014 

043 

000 

000 

095 

000 

000 

07 

097 

000 

093 

014 

043 

000 

000 

095 

000 

000 

08 

002 

000 

000 

000 

012 

047 

091 

000 

039 

000 

08 

002 

056 

072 

077 

012 

000 

091 

081 

000 

064 

09 

095 

000 

078 

000 

013 

000 

000 

078 

090 

025 

09 

000 

000 

078 

028 

000 

022 

039 

078 

090 

025 

10 

062 

046 

090 

092 

000 

019 

015 

000 

000 

097 

10 

062 

000 

090 

092 

061 

019 

015 

006 

071 

097 


Table 5. Randomly generated target distribution (seed 91273) 


The quadrants two, three and four are for the other three ‘enemy orders of battle’ 
eonstellations. A simple visual inspeetion of the three distribution tables shows that they 
are completely different. Table 6 shows the output allocations of the three runs. 


1®' run 


. PI at f Alloc . 

PI P2 P3 P4 P5 P6 

COl .10 - - 10 

C 0 2 1 6 1 6 - - 0 8 - - - - 

C03 -- 20 10 . 

C 0 4 0 2 04 - - 

C 0 5 0 2 04 -- 

COO . 0 3 03 -- 

C 0 7 . 04 0 8 

C 0 8 . 04 0 8 

C 0 9 0 2 02 -- 

CIO . 06 0 3 

Sum 16 36 10 27 27 29 


Table 6. 


2“‘^run 


. PI at f Alloc . 

PI P2 P3 P4 P5 P6 
COl 2 0 2 0 - - 1 0 - - - - 

C0 2 0 8 . 0 4 - - 

C0 3 - - 0 6 - - - - 0 3 - - 

C0 4 . 0 6 0 3 -- 

COS - - - - 0 6 0 6 - - 1 2 

C0 6 - - - - 0 2 0 2 0 4 - - 

C0 7 . 0 4 0 8 

C0 8 . 0 1 0 2 - - 

C0 9 . 0 2 0 4 - - 

CIO . 0 3 0 6 

Sum 28 26 08 27 27 26 


3"^^* run 


. Platt Alloc . 

PI P2 P3 P4 PS P6 

COl .10 - - 10 

C0 2 .. 1 6 - - 0 8 - - - - 

COS - - 1 8 0 9 . 

C0 4 . 0 2 0 4 - - 

COS . 0 2 0 4 - - 

C0 6 - - - - 0 3 0 3 0 3 - - 

C0 7 . 0 4 0 8 

C0 8 . 0 4 0 8 

C0 9 . 0 2 0 2 -- 

CIO . 0 6 0 6 

Sum 00 34 12 27 27 32 


Platform Allocations for the three test runs 


In these output tables we can directly see which platforms are assigned to which clusters. 


In the allocation table for run one for example there are 16 UAV II (Platform 2) sent to 
cluster 2 and 20 are sent to cluster 3. For this modeling set up the following six platforms 
were used; 


Platform 1 
Platform 2 
Platform 3 


22 


Unmanned Aerial Vehiele - Class I 
Unmanned Aerial Vehiele - Class II 
Unmanned Aerial Vehiele - Class III 









































Platform 4 Unmanned Aerial Vehicle - Class IVa 

Platform 5 Armed Robotic Vehicle - RSTA 

Platform 6 Unattended Ground Sensors 

Table 7. Platform Description 

Due to the complexity of the optimization model it is still hard to analyze the output but 
there are at least a few things that can be mentioned. First of all we can see that the 
results for the three runs are different from each other. This makes sense since the model 
is expected to react differently for different target distributions. The following platform 
distribution was used: 

Platform 1 2 3 4 5 6 

# available 108 36 12 27 27 33 

Table 8. Number of Platforms available 


By comparison with the total number of platforms of each type that are used by the model 
we see that in average 90% of the platforms 2 to 6 are chosen. Platform one is rarely 
chosen. Platform one has a limited range of 16 km and a limited operational time of 120 
minutes. The output below was generated with the setup for the run above. Just the 
value for the operational time for platform 1 was increased by one hour to a total of three 
hours. We can see that the number of platforms of type one increased from a total of 0 to 


a total of 36. 


. PI at f Alloc . 

PI P2 P3 P4 P5 P6 

COl 20 20 10 . 

C0 2 1 6 1 6 - - 0 8 - - - - 

C03 - - -■ 0 2 0 2 0 2 - - 

C0 4 . 0 4 0 8 

COS . 0 6 0 3 -- 

C0 6 . 0 4 0 2 

C0 7 . 0 2 0 4 -- 

C0 8 . 0 9 - - 1 8 

C0 9 . 0 4 0 2 

CIO . 0 6 0 3 

Sum 51 36 12 27 27 33 


Table 9. Platform Allocations for 3"^^* run with increased operational time for 

Platform 1 


To see how the model reacts with only airborne sensor platforms available we also 
generated the three runs just with platforms 1 to 4. The parameters p_avail(p) in the 
GAMS Model for platforms 5 and 6 were set to be zero. The operational time for 
platform 1 was set back to 2 hours. The result is shown in Table 10. 


23 













ist 

run 




2 nd 

run 




3 rd 

run 




PI atf 

Al 1 





PI atf 

Al 1 





PI atf 

Al 1 

















PI P2 

P3 

P4 

PS 

P 6 


PI P2 

P3 

P4 

PS 

P 6 


PI P2 

P3 

P4 

PS 

P 6 

COl 

3 0 2 0 





COl 

OS OS 


04 



COl 

3 0 2 0 





C02 

24 16 





C02 

3 0 2 0 





C02 

14 14 

07 




C03 


02 

03 



COS 

- - OS 


04 



COS 

- - 02 


04 



C04 


04 

02 



C04 


06 

02 



C04 


02 

02 



COS 


03 

03 



COS 


03 

02 



COS 


02 

03 



C06 


03 

02 



C06 


03 

03 



C06 


01 

01 



C07 



04 



C07 



04 



C07 



04 



COS 



05 



COS 






COS 



04 



C09 



01 



C09 



05 



C09 



04 



CIO 



07 



CIO 



03 



CIO 



05 



S u m 

3 4 3 6 

12 

27 

00 

00 

S u m 

3S 36 

12 

27 

00 

00 

S u m 

4 4 3 6 

12 

27 

00 

00 


Table 10. Platform Allocations just for platforms 1 to 4 


B. TEST AND EVALUATION OF THE JSAM OUTPUT FOR DIFFERENT 
PLOS PARAMETERS 

In chapter II A 1 we described how the JWARS PLOS model was implemented 
into JSAM. In this chapter we want to test the implementation and show how JSAM 
reacts to different types of terrain. Three different terrain types were chosen to be tested. 


The PLOS parameters for these terrain types are shown below. 


Set Up 1: Southern Iran (moderate mountainous) 


sigma_ceiling 

g.rgh 

cceiling 

gxtnct 


= 14.5; 

= 0.000704; 
= 0.000605; 
= 0.569; 


Set Up 2: Southeast Central Arabia (desert dunes) 


sigmaceiling 

gAgh 

cceiling 

gxtnct 

Set Up 3: Central Iran (mountainous) 

sigmaceiling 

gAgh 

cceiling 

g_xtnct 


= 6.59; 

= 0 . 00122 ; 
= 0.000213; 
= 0.834; 

= 56.9; 

= 0.00034; 
= 0.000478; 
= 1.3; 


24 



































The setup for all other model parameters is shown in Figure 15: 

II parameters for modeling PLOS 

double!] oper at ona I Al 11 t ude = { 1 5 0.0, 3 0 0.0, 6 0 0.0, 2 0 0 0.0, 3.0, 1.0 }; 


II parameters for modleing platform 5 weep Width 


doubi e[ ] [ ] 

hori zontal Angl e 

{ 2 0,0 0 , 

15. 00}, 

{ 2 0,0 0 , 

9. 2 0 0 }, 

{ 8.9 2 0, 

8 . 9 0 0 }, 

{ 8.9 2 0, 

8 . 9 0 0 }, 

{ 2 0,0 0 , 

15. 00}, 

{ 10 , 00 , 

7. 5 0 0 } 


}; //[Platform] [Sensor] horizontal observation angle 

double]]]] vertical Angle = { 

{ 1 5.0 0, 1 1.2 5 }, 

{ 1 5,0 0, 6.9 0 0 }, 

{ 6.6 8 0, 6.7 0 0 }, 

{ 6.6 8 0, 6.7 0 0 } 

}; //[Platform] [Sensor] vertical observation angle 

double]] observationAngle = {45.0, 45.0, 45.0, 45.0}; //[Platform] 
double swag_dependance = 0 . 1 ; 


II parameters for modeling package combinations 
I nt[][] basI c Pac kages = { 


{ 

1 , 

0 , 

0 , 

0 , 

0 , 

0 }, 

//PI 

at f or mComb 

n at 

0 n 

f 0 r 

Package 

1 

{ 

0 , 

1 , 

0 , 

0 , 

0 , 

0 }, 

//PI 

at f or mComb 

n a t 

0 n 

f 0 r 

Package 

2 

{ 

0 , 

0 , 

1 , 

0 , 

0 , 

0 }, 

//PI 

at f or mComb 

n a t 

0 n 

f 0 r 

Package 

3 

{ 

0 , 

0 , 

0 , 

1 , 

0 , 

0 }, 

//PI 

at f or mComb 

n at 

0 n 

f 0 r 

Package 

4 

{ 

0 , 

0 , 

0 , 

0 , 

1 , 

0 }, 

//PI 

at f or mComb 

n a t 

0 n 

f 0 r 

Package 

5 

{ 

0 , 

0 , 

0 , 

0 , 

0 , 

1 }, 

//PI 

at f or mComb 

n a t 

0 n 

f 0 r 

Package 

6 

{ 

1 , 

1 , 

0 , 

0 , 

0 , 

0 }, 

//PI 

at f or mComb 

nat 

0 n 

f 0 r 

Package 

7 

{ 

0 , 

0 , 

1 , 

1 , 

0 , 

0 }, 

//PI 

at f or mComb 

nat 

0 n 

f 0 r 

Package 

8 


}: 


double package_enhFact = 1.1; 


II parameters for modleing Package Characteristics 


doubi 

e[ ] 

pi atformtatency 

= 

{ 0 . 

6 , 

0. 5, 

0, 3, 

0 , 

1 , 

0. 4, 

1 . 0 } 



doubi 

e[ ] 

pi at f or mCost 

= 

{ 0 . 

1 , 

0. 3, 

0,7, 

1 . 

0 , 

0 . 8 , 

0 . 2 } 



doubi 

e[ ] 

platformPerishability 

= 

{ 0 . 

2 , 

0 . 2 , 

0 , 8 , 

1 . 

0 , 

0. 4, 

0 . 2 } 



doubi 

e[ ] 

pi atformLogi sti cs 

= 

{ 0 . 

3, 

0. 4, 

0,5, 

0 , 

7, 

0 . 1 , 

0 . 1 } 



doubi 

e[ ] 

travelSpeed 

{80 

. 0 , 


100 . 0 , 

2 0 0 , 

0 , 

135. 0, 

200 

. 0 , 

200 , 0 } 

doubi 

e[ ] 

searchSpeed 

{60 

. 0 , 


80. 0 , 

140, 

0 , 

100 . 0 , 

20 . 

0 , 

0,0 } 

doubi 

e[ ] 

operationalTime 

{ 1 . 

0 , 


2 . 0 , 

6 . 0 , 


5. 

0 , 

72. 

0 , 

72,0 } 

doubi 

e[ ] 

operationalRadius 

{16 

. 0 , 


30. 0, 

40,0, 

75 

. 0 , 

800 

. 0 , 

8 0 0,0 } 


boolean]] air Dropped 


{false, false, false, false, true, true,}; 


II cluster coordinates and dimensions 


doubi e [ ] 

entryPoint = {19.0, 

50, 0}; 


double]]]] cluster Data = { 



{30. 5, 

5 4.0, 3 1.0, 2 2.0 }, 

//cl u s t e r 

01 {xCoord, yCoord, ewDimension, nsDimension} 

{20,5, 

3 9.0, 2 1.0, 2 8,0 }, 

//cl u s t e r 

"02 

{36, 0, 

4 4.0, 2 0.0, 1 8,0 }, 

//cl ust er 

'03 

{49. 0, 

6 3.5, 3 2.0, 2 3.0 }, 

//cl u s t e r 

"04 

{50,5, 

4 9.0, 2 9.0, 2 6.0 }, 

//cl u s t e r 

'05 

{48, 0, 

3 2.0, 2 4.0, 2 8,0 }, 

//cl ust er 

'06 

{65. 0, 

5 3.0, 2 0.0, 3 4.0 }, 

//cl u s t e r 

"07 

{62. 5, 

3 2.0, 2 5.0, 2 8.0 }, 

//cl u s t e r 

"08 

{55,5, 

2 0.5, 3 9.0, 1 5.0 }, 

//cl ust er 

'09 

{62. 0 , 

}; 

10.0, 28.0, 31.0}, 

//cl u s t e r 


doubi e ] ] 

targetSpeed = {1.0, 

5.0, 4.0, 

7.0, 5.0, 6.0, 6 . 0, 6.0, 7.0, 5.0}; 

II e n e my 

order of battle 



long scenario Seed 

= 12345; 


I nt max Nu mber Of Ta r g et s 

= 100 ; 


doubi e ] I 

e OB_ Factor 

= {0,45, 

0.5 0, 0,6 0, 0,6 5 }; 


Figure 15. Variable and Parameter setup used for Analysis with different PLOS 

parameters 


25 




















The output generated with the three different terrains is shown in Table 11. It is 


worth mentioning that this time the target distribution was not changed at all. Each run 
was generated with the seed 45832 and the corresponding target distribution can be seen 
in Table 4. 


Setup 1 


. PI at f Alloc . 

PI P2 P3 P4 P5 P 6 

COl .10 -- 10 

C0 2 1 6 1 6 - - 0 8 - - - - 

C0 3 - - 2 0 1 0 . 

C0 4 0 2 04 - - 

COS . 0 2 04 - - 

C0 6 0 3 03 -- 

C0 7 . 04 0 8 

C0 8 . 04 0 8 

C0 9 0 2 02 -- 

CIO . 06 0 3 


Set up 2 


. PI at f Alloc . 

PI P2 P3 P4 PS P 6 
COl 2 0 2 0 - - 1 0 - - - - 

C0 2 0 8 . 0 4 -- 

C0 3 - - 0 6 - - - - 0 3 - - 

C0 4 . 0 6 0 3 -- 

COS - - - - 0 6 0 6 - - 1 2 

C0 6 - - - - 0 2 0 2 0 4 - - 

C0 7 . 0 4 0 8 

C0 8 . 0 1 0 2 -- 

C0 9 . 0 2 0 4 - - 

CIO . 0 3 0 6 


Set up 3 


. Platt Alloc . 

PI P2 P3 P4 PS P6 
COl 2 0 2 0 - - 1 0 - - - - 

C0 2 1 4 1 4 - - 0 7 - - - - 

C0 3 - - 0 2 - - - - 0 4 - - 

C0 4 - - - - 0 8 - - 0 4 - - 

COS .10 - - 10 

C0 6 - - - - 0 4 - - 0 4 - - 

C0 7 . 0 4 0 4 

C0 8 . 0 3 0 3 

C0 9 . 0 4 0 8 

CIO . 0 4 0 8 


Table 11. Allocation Output for different types of terrain 


The variability between the three different tables is not as significant as it was in the 
previous chapter. Some of the allocations are equal. On the other hand it is quite obvious 
that terrain modeled as Probability of Line of Sight has a significant effect on ISAM and 
it’s output. The reason why platform one is used much less than all the other platforms is 
exactly the same as in the previous subchapter. Its operation time is set to be just two 
hours and its operational range is just 16 km. It is capable to operate for a limited time in 
clusters one and two and it is not capable to reach the other clusters at all. 


26 






























IV. CONCLUSIONS AND RECOMMENDATIONS 


The Java SAM allocates sensor platforms to target clusters on the battlefield. The 
model ensures that platforms have sufficient range, time on station, and performance 
level if it allocates it to a specific cluster in a specific enemy order of battle scenario. Two 
major improvements were made. First, the JWARS FLOS methodology was implemented 
to represent the effects of terrain on sensor performance. Second, the sweep width sub¬ 
model was refined to incorporate the constraints on sensor performance imposed by the 
sensor’s Field of View. These improvements result in a significantly more accurate 
representation of sensor performance in the model. 

A. RECOMMENDED MODEL REFINEMENTS 

1, Classified Data 

Classified sensor data is available from AMSAA sources. The AMSAA data was 
reviewed to determine type and format available and a surrogate data set was generated to 
mirror the classified data and to develop our models. The assumption was made in 
development of the optimization models that platform and package performance data 
would become available as further experimentation and research is conducted. The 
availability of such data would eliminate the need to surrogate. 

2, Tuning 

A good mathematical model should always build on and be checked against 
historical data. Data that describes how many targets were detected by some platform on 
a battlefield would be perfect to tune this model. Checking against such a data set would 
make sure that the results produced are reliable and usable. 

3, Verification and Validation 

Verification and Validation have not been conducted on this model. TRAC- 
Monterey is in the process of developing the Dynamic Allocation of Fires and Sensor 
(DAFS) simulation. The ISAM output can directly be used as input to the DATS model. 
Validation would be accomplished by comparing the performance (in DAFS or other 
simulations) of sensor allocations suggested by ISAM to those derived by other means. 


27 



4, Model Split 

At the moment the model mixes the use of Unmanned Aerial and Unmanned 
Ground Operating Vehicles. Both systems are modeled differently but resulting Sweep 
Width for both models is used as a decision parameter for the optimization part. The 
model might be much more reliable if the two types of platforms were handled separately 
by the model. 

B, SUGGESTED FURTHER RESEARCH 

Many possibilities can be pursued to extend or to improve the model presented in 
this thesis. This thesis only addresses the allocation of organic Unit of Action sensor 
assets. The model could be modified to include joint assets at the higher echelons. At the 
moment the model also just uses a single entry point as the single coordinate for all 
available sensors. To represent dislocated troops on the battlefield realistically many 
sensor locations need to be handled by the model. 

Another more challenging project would be to create a dynamic model 
significantly improving the utility of the presented model. There are two components for 
consideration in the development of a dynamic model. The inclusion of multiple time 
periods would take into account equipment or platform resupply, attrition rates, 
maintenance, follow-on missions, and new launch sites. The second more difficult 
component would involve the allocation of a package to a higher priority or just- 
identified target area. This reallocation would also apply to reallocation to a secondary 
target area if the allocation to the original target area was no longer required [Tutton, 
2003]. 


28 



LIST OF REFERENCES 


1. Tutton, Stephanie, [2003] Optimizing the Alloeation of Sensor Assets for the Unit of 
Action , Monterey: Naval Postgraduate School, Master’s Thesis 

2. Wagner, Daniel H., [1999] Naval Operations Analysis, Edition, Naval Intitule 
Press 

3. Blacksten, H. Ric, Burdick, Charles D., Grell, Mihly G. [2002], Probability of Line- 
of-Sight (PLOS) and Roughness Enhancements for JWARS 1.5, San Jose: 
INEORMS/MAS 

4. Tutton, Stephanie, Olson, Keith, [2003], SMM Preprocessor.xls. Monterey, Naval 
Postgraduate School, Excel Spreadsheet Model 

5. Director US Army Materiel Systems Analysis Activity (AMSAA) [2003], Army 
Euture Combat Systems Unit of Action Systems Book Version 3.0. Aberdeen: 
AMSAA 

6. Rutherford, Thomas E., [2003], Rutherford’s GAMS Programming Tools 2003, 
Denver: University of Colorado, Department of Economics, 

Available: http://debreu.colorado.edu/inclib/tools.htm 

7. McCarl, Bruce A. McCarl’s GAMS User Guide 2003 , 

Texas: A&M University, Department of Agricultural Economics 
Available: http://www.gams.com/dd/docs/bigdocs/gams2002/ 


29 














THIS PAGE INTENTIONALLY LEET BLANK 


30 



APPENDIX A OPTIMIZATION MODEL IN NPS FORMAT 


The mixed-integer program makes the best overall alloeation of paekages based on the 
mix available, taking into aeeount the eharaeteristic weightings of eaeh package, target 
type weights, and sensor/platform performance. The decision variables for the Sensor 
Allocation Model are integer and indicate how many sensor packages of a certain type to 
allocate to a target cluster. 

A, INDICES 

p platform type {'UAV,'ARV,'UGS',...} 

k package configuration {'KT, 'K2', 'K3',...} 

t target type {'INF', 'Main Battle Tank', ...} 

c target cluster {'Cl','C2','C3',...} 

ch sensor characteristic {'latency','cost','logistics', ...} 

w outcome_scenario {'WF,'W2','W3',...} 

eob enemy order of battle {'EOBl', 'EOB2', 'EOB3', ...} 

n number of packages of type k to cluster c 

{'Nr,'N2', ...,'NIO'} 

B, PARAMETERS 

1. Asset Data 

plat_pkg p,k number of platforms of type p required for one package of type k 

p_avail p number of platforms of type p available (inventory) 
pkg_char k,ch value of package k contribution to each characteristic ch 
cdp c,t,k,w Cumulative Detection Probability for package k against target t 
type in cluster c in outcome w 

2 . Target Data 

numjgt t.c.eob number of targets of type t in cluster c for a specific eob 

3. Parameter Weights 

wtjgt t value of detecting target type t 

wt_charch platform characteristic weights ch 
pr_eob eob probability of a specific eob occurring 

31 



pr_out„ 

alpha_det 

alphajchar 


probability of a specific w occurring 

overall weight for expected targets detected portion of the 

objective function 

overall weight for characteristic portion of the objective function 


4. Derived Data 

cdpccxhw.n Cumulative Detection Probability Enumerated for n packages of 
type k against target type t in cluster c in outcome w 

The model inputs are CDPs (indexed by target cluster, target type, package, and 
outcome) for one package, and the MIP precomputes the CDPs for assignment of 
up to ten packages of a single type assigned to a target cluster against a specific 
target type and indexes them by n. 


C. DECISION VARIABLES 

Unrestricted continuous variables in the model; 


CH_OBJch,w 


EXP_TGTr,c.^ 

OBJ 


value of characteristic weights ch over all packages 
assigned to all clusters for an outcome w 
expected number of targets detected by target type t in 
cluster c for outcome w 
objective function value 


Integer variables in the model: 

KTOCcXw Integer Variable: number of packages of type k 

assigned to cluster c in outcome w 

Binary variables in the model: 


{ 1 if n packages of type k are assigned to 
cluster c in outcome w 
0 otherwise 

The key decision variables in the Sensor Allocation Model are integer and allow 
for the selection of which consolidated package, and how many are assigned to 
each target cluster. 


32 



D, 


CONSTRAINTS 


The model requires two main constraints. The first constraint set ensures that only 
one package type (regardless of configuration) is assigned to a target cluster. 




Vvr,c 


k.n 


^TOC,,^,=Xo'-d(n)*lND_VAR^j,^,, Vc,/c,«- 

n 

The second constraint ensures that only available platforms are used: 

Z ^p- ; ^P^ 

c.k 

The next two constraints calculate terms in the objective function. 


EXP_TGT,,,, = 

Z - ^S^c t eob * * P’’ _ ^oh^ob * 

eob.k.n 


CH _OBJ,, , = 2;Z A.TOC.• pkg_cl,ar,„ • _char,„ 

c k 

The final constraint defines the objective as a weighted combination of expected, 
weighted targets detected and weighted sensor characteristics. 

OBJ = alpha _ clet * EXP _ TGT^ ^,,, - alpha _ char * OBJ _ ,,, 

E. OBJECTIVE FUNCTION 

The objective in this model is to maximize the weighted combination of expected 
number of weighted detections and overall sensor characteristic penalties. 

Maximize OBJ 


33 



THIS PAGE INTENTIONALLY LEET BLANK 


34 



APPENDIX B DOCUMENTATION OF THE JAVA SENSOR 
ALLOCATION PROGRAM 


A. JSAM DOCUMENTATION AND PROGRAM DESCRIPTION 

In this subchapter we describe JSAM, its classes and methods in more detail. See 
Appendix () for the JSAM code. ‘Input ModelData’ is used to handle and capture all the 
data input. It is subdivided into several paragraphs. These are for Parameters to model the 
Probability of Line of Sight, the Sweep Width of a Platform, the Package Combinations 
and Characteristics as well as the Enemy Order of Battle. Cluster Coordinates and Cluster 
Dimensions are defined here too. The idea is that all input and modeling data can be set 
up and changed in one single place. An excerpt that shows how some of the parameters 
mentioned above are defined is shown in Figure 16. 


To make sure that whenever something is changed in the interface all classes in 
the program are compiled again, the text file ‘PackageClasses.txt’ was added to the 
package folder. This file contains the names of all classes in the program and the 
command ‘javac @PackageClasses’ compiles all classes listed in the text file. Compiling 
just the interface is insufficient for a correct JSAM run. 


II parameters for modeling PL OS 
double sigma ceiling =14.5; 

doublegrgh’ =0.000704; 

doublec’ceiling =0. 0 0 0 6 0 5; 

doubi e gAt net = 0.5 6 9; 

double!) oper at ona I Al t i t ude = { 1 5 0.0, 3 0 0.0, 6 0 0.0, 2 0 0 0.0, 3.0, 1.0 }; 

double!] oper at ona I Obs er vat I on Ra nge = { 1 5 0.0, 3 0 0.0, 6 0 0.0, 2 0 0 0.0, 3.0, 1.0 }; 

II parameters for modleing platform Sweep Width 
double!!!! horizontal Angle ={ 

{ 2 0.0 0, 1 5.0 0 }, 

{ 2 0,0 0, 9.2 0 0 }, 

{ 8,9 2 0, 8.9 0 0 }, 

{ 8,9 2 0, 8.9 0 0 }, 

{ 2 0.0 0, 1 5.0 0 }, 

{ 2 0,0 0, 1 5.0 0 } 

}; //!Platform]!Sensor] horizontal observation angle 

double!!!! vertical Angle = { 

{ 1 5,0 0, 1 1.2 5 }, 

{ 1 5.0 0, 6.9 0 0 }, 

{ 6.6 8 0, 6.7 0 0 }, 

{ 6,6 8 0, 6.7 0 0 } 

}; //!Platform]!Sensor] vertical observation angle 

double!) observationAngle = {45,0, 45.0, 45.0, 45.0}; //!Platform] 
double swag_dependance = 0.1; 

Figure 16. Excerpt of the class Input ModelData 


35 


The Sensors class handles data that has to do with sensors mounted on a platform. 
It provides six methods. The first one is called sensorData. It is used to read the actual 
sensor performance data into the Java Program. For this purpose the data file was 
restructured similar to a network data file. The two numbers in the first row define width 
and height of the data block. The first column is for the platform, the second is for the 
sensor and the third column specifies different types of targets. ‘1 2 1’ in row three for 
instance means Sensor 2 on platform 1 observing target 1. The next three columns are for 
the ranges within which data are provided. Column four is for start range, column five is 
for end range and column six defines the range increments in which data is provided. The 
combination ‘0 1200 100,’ for instance, means that data is provided between 0 and 1200 
meters in increments of 100 meters. All other columns provide data for a specific sensor 
on a specific platform against a specific target at a specific range. The name of the file is 
‘SENSOR DATA.CSV’. 


27 120 


1 

1 

1 

0 

6000 

500 

1 0.911596 

0.978829 

0.957341 

0.967688 

0.924096 

1 

2 

1 

0 

1200 

100 

1 0.991558 

0.951871 

0.898665 

0.931452 

0.917393 

1 

1 

2 

0 

6000 

500 

1 0.991627 

0.964177 

0.908344 

0.89414 

0.93644 

1 

2 

2 

0 

1200 

100 

1 0.957563 

0.969453 

0.961055 

0.917477 

0.875669 

1 

1 

3 

0 

6000 

500 

1 0.908911 

0.960705 

0.914058 

0.918571 

0.883918 

1 

2 

3 

0 

1200 

100 

1 0.980121 

0.910741 

0.947372 

0.852149 

0.823776 

1 

1 

4 

0 

2400 

200 

1 0.989058 

0.900173 

0.948794 

0.936191 

0.947119 

1 

2 

4 

0 

1200 

100 

1 0.965566 

0.928927 

0.950795 

0.919499 

0.884167 

1 

1 

5 

0 

2400 

200 

1 0.999963 

0.919988 

0.900865 

0.885747 

0.859609 

1 

2 

5 

0 

1200 

100 

1 0.918437 

0.982633 

0.912627 

0.955035 

0.892936 

1 

1 

6 

0 

2400 

200 

1 0.921525 

0.92376 

0.985256 

0.89319 

0.816344 

1 

2 

6 

0 

1200 

100 

1 0.969328 

0.95034 

0.928775 

0.859611 

0.769106 

1 

1 

7 

0 

6000 

500 

1 0.948291 

0.930717 

0.949882 

0.911142 

0.937599 

1 

2 

7 

0 

1200 

100 

1 0.97779 

0.948167 

0.970712 

0.981202 

0.895133 

1 

1 

8 

0 

6000 

500 

1 0.952212 

0.946774 

0.930221 

0.950682 

0.935158 

1 

2 

8 

0 

1200 

100 

1 0.904197 

0.972343 

0.95461 

0.954945 

0.881419 

1 

1 

9 

0 

6000 

500 

1 0.970761 

0.907008 

0.905394 

0.906715 

0.876577 

1 

2 

9 

0 

1200 

100 

1 0.980482 

0.947848 

0.91017 

0.867379 

0.774993 

1 

1 

10 

0 

2400 

200 

1 0.957574 

0.969968 

0.904337 

0.916768 

0.951048 

1 

2 

10 

0 

1200 

100 

1 0.99842 

0.92159 

0.971495 

0.891958 

0.826662 


Table 12. Excerpt of Sensor Data.csv 

ISAM stores this information in three multidimensional arrays, per platform, sensor, 
target and a range index. The method plosCorrectedData computes a correction factor to 
take Probability of Eine of Sight into account. The basic theory behind this is described in 
chapter II A I. The next three methods in this class are pictureDimensions, 
pictureDistances and pictureProbability. They are used to compute dimensions, distances 
and probabilities assigned to a picture taken by a sensor. These data are necessary to 
calculate the sweep width of a sensor, which finally is done by sensorSweepWidth. 


36 


The Platforms class handles all the calculations to produce platform data. Since 
this class extends Sensors it has access to its methods and instance variables. The latter is 
used extensively in this program. Platforms has three methods. The method 
platformSweepWidth computes the adjusted sweep width for a platform. Apart from a 
few necessary ‘if-statements’ it simply applies the following formula; 


^adj = max((S “ max()) 


( 6 ) 


Wadj is the adjusted sweep width for a platform. Ws represents the individual sweep width 
of a sensor and Upu is the positive independence factor indicating added benefit of 
multiple sensors mounted on one platform. Upn is one of the parameters that are defined in 
the interface class. Here it is called swag dependence. Typically it is a value between 0 
and 1. 0 means that just the sensor with the maximum sweep width contributes to the 
platform sweep width. 1 means that the sweep width of all sensors mounted on a platform 
are added up. timeOnStation calculates the distance form the entry point to each of the 
clusters and finally the time on station for each platform. It also checks the operational 
radius of a platform. Is a platform out of a clusters range, its time on station for this 
cluster is set to be zero. PlatformCDP finally is used to compute the Cumulative 
Probability of Detection of a target within a specific cluster. The calculation relies on the 
following basic formula from random search theory; 


CPDplt=\-e A 


(7) 


A is the total area of a specific cluster, v is the search speed and t is the time on station of 
the platform. Depending on whether the platform is stationary or moving the search speed 
V is either the actual search speed of the platform itself or the speed of the target that is 
observed. 

A Package is a combination of Platforms which itself somehow is a combination 
of Sensors. It just makes sense that the class Packages extends Platforms as Platforms 
extends Sensors. This class has three main methods and two helper methods. The helper 


37 



methods are needed to eompute ‘n faetorial’ and the probabilistie formula ‘n ehoose k’. 
They are easy to understand and will not be explained here. packageCombinations adds 
up eombinations of platforms to paekages. This is done intelligently based on user input 
data. Firstly the method ads each of the rows in ‘basicPackages’ to each other row in this 
array. Then it adds each row multiplied by two to each other row in the array. Finally it 
adds each row to each other row in the array after this was multiplied by two. 
packageCharacteristics takes the arrays platformLatency, platformCost, platformLatency 
and platformCost as well as the results from the previous described method and computes 
the characteristics for the whole package. It just adds up all the values. The third method 
in this class finally calculates the Cumulative Probability of Detection of the package. 
The theory behind this is explained extensively in [Tutton, 2003]. The basic formulas 
used to compute the package CDP are shown below: 

Rate pit =vWadjt (8) 


Effprop = 


Rate pit 
Y, Rate pit 


(9) 


Rate 


pit 


CDPpkg=X-e Effprop-Pp,, 


( 10 ) 


Like in the formulas before v is defined to be the search speed, t is the time on station and 
Wadj is the adjusted sweep width for a platform. Effprop is the effective proportion of the 
cluster that is searched by the platform for which the Rate was calculated. Finally the 
Cumulative Detection Probability for each package is calculated. Ppkg is a positive 
dependence factor associated with a specific configuration of individual platforms 
designed as a package. 


38 



Scenario has two methods which both somehow produce target distributions. 
scenarioData uses the Java built in random number generator to produce a target 
distribution per cluster and targetDistribution uses the Enemy Order of Battle factors 
defined as user input data to vary the target distribution produced by the previous 
method. The eob-factor defines a uniform distribution that is used to decide whether a 
target is absent or present. 

There are three more classes in the program that need to be explained. Two of 
them are for output handling and the third class takes care of the GAMS environment. Let 
us have a look at the output classes first. Output Command holds all the print methods of 
the program that print tables and arrays to the eommand line, either for error checking or 
for a better understanding of the program itself. Which method is called or not can be 
defined in the construetor. By default just the final program result is printed out. 

Output GamsFiles produces the input files needed for the GAMS optimization. 
The class needs an instanee variable of Type Scenario to have aeeess to the data needed. 
Basically the methods in this class just transform the Java data into a format that can be 
red in by GAMS. 

Gams Handling finally is responsible for the GAMS environment. It uses the 
Java Runtime feature to start GAMS. The started application runs completely in the 
background. The output file created by the GAMS application is captured. A GAMS Plug 
In is used to modify the GAMS Output file. The new format is mueh easier to capture. 
The Plug In is called ‘Gams2csv’ and ean be downloaded for free form Thomas F. 
Rutherford’s GAMS programming tools homepage [Rutherford, 2003]. The following 
explanation is from Me Carl’s GAMS User Guide [Me Carl, 2003]. GAMS users do not 
have to do put file programming to move data in CSV format. Rather they can use a 
libinclude routine called Gams2csv developed by Rutherford and associates at the 
University of Colorado. 

Gams2csv is invoked as follows: 


FILE localname /externalname/ ; 

PUT localname; 

$LIBInclude gams2csv [row domain [column domain] ] item [. suffix] 
[item[ . suffix] ... ] 


39 


However the method alloeationTable takes the GAMS output and reads its eontent. It 
stores assigned paekages to elusters. This aetually is the final result and output produeed 
by ISAM. 

B. DATA EXTRACTION AND DOCUMENTATION 

To finally prepare ISAM for Implementation into a diserete event simulation all 
the modeling data that is set up within the interface has to be extracted and stored in text 
files. The class Read DataFiles has to be added to read the generated text files back in. 
The advantage of this structure is that the simulation can generate the modeling input 
necessary for a Java Sensor Allocation run. The disadvantage of this setup is that it is not 
as user friendly as the setup with the interface. The four new files have the following 
names: 


PLOSMODELING.CSV 

SCENARIOMODELING.CSV 

PACKAGEMODELING.CSV 

EIELDOFVIEWMODELING.CSV 

They keep all the input data needed for a Java Sensor Allocation run. Figure 17 shows the 
content of PLOS MODELING.CSV. Although for a better reading the data below is 
shown tabulator delimited, the real data files are all comma delimited. 

numberOfPlatforms 



signna_ceiling -► 14.5 0.000704 0.000605 0.569 

150 300 600 2000 3 1 M - operatonalAltitude per Platform 

Figure 17. Description of plos modeling 

The number in row one is for the number of platforms used in the model, row two is for 
the four PEGS parameters and row three is for the operational altitude of the different 
platforms. Figure 18 shows the content of SCENARIO_MODELING.CSV. 


40 




numberOfTargets 

numberOfClusters 



numberOfEOB 



coordinates of the entry point 


target speed in km/h 


10 

10 

4 


19 

50 



30.5 

54 

31 

22 

20.5 

39 

21 

28 

36 

44 

20 

18 

49 

63.5 

32 

23 

50.5 

49 

29 

26 

48 

32 

24 

28 

65 

53 

20 

34 

62.5 

32 

25 

28 

55.5 

20.5 

39 

15 

62 

10 

28 

31 

1 

5 

4 

7 

0.45 

0.5 

0.6 

0.65 




^ data block for clusters ordered by 

xCoord, yCoord, ewDimension, nsDimension 


J 

5 6 6 6 7 


four differerent enemy order of battle factors 


5 


Figure 18. Description of scenario modeling 

The file provides x- and y-Coordinates for the entry point as well as Cluster Coordinates, 
Cluster Dimensions and speed values for the different types of targets used in the model. 
The last row shows the four eob parameters used to generate enemy order of battle 
setups. PACKAGE MODELING is shown in Figure 19. 


numberOfPlatforms 

numberOfBasicPackages 





8 

6 









1 

0 

0 

0 

0 

0 





0 

1 

0 

0 

0 

0 





0 

0 

1 

0 

0 

0 





0 

0 

0 

1 

0 

0 


^ basic Packages to generate 



0 

0 

0 

0 

1 

0 


different package combinations 



0 

0 

0 

0 

0 

1 





1 

1 

0 

0 

0 

0 





0 

0 

1 

1 

0 

0 





0.6 

0.5 

0.3 

0.1 

0.4 

1 

◄- 

- platform Latency 



0.1 

0.3 

0.7 

1 

0.8 

0.2 

◄- 

- platformCost 



0.2 

0.2 

0.8 

1 

0.4 

0.2 

◄- 

- platformPerishability 



0.3 

0.4 

0.5 

0.7 

0.1 

0.1 

◄- 

- platformLogistics 

travelSpeed 

-► 

80 

100 

200 

135 

200 

200 



searchSpeed 

-► 

60 

80 

140 

100 

20 

0 



operationalTime 

-► 

1 

2 

6 

5 

72 

72 



operationalRadius 

-► 

16 

30 

40 

75 

800 

800 




FALSE 

FALSE 

FALSE 

FALSE 

TRUE 

TRUE 

◄- 

— airOropped 


Figure 19. Description package modeling 
In the first row the number of basic packages that are shown in the next eight rows is 
defined. The columns in this file are for data related to different platforms. Data in 
column one is for platform one, data in column two is for platform two and so on. All 
other necessary explanations are shown in the picture. 


41 


















numberOfUAV 


numberOfPlatforms 


numberOfSensors 



f 

6 

4 



20 

15 

horizontalAngle 


20 

9.2 

per Platform 


8.92 

8.9 

and Sensor 


8.92 

8.9 



20 

15 



20 

15 

verticalAngle 

r 

15 

11.25 

per UAV 


15 

6.9 

and Sensor 


6.68 

6.7 


1 

6.68 

6.7 



45 

45 


/ 


45 


45 


observationAngle per UAV 


Figure 20. Description of field of view modeling 
This file provides data for horizontal angles per platform and sensor, vertical angles per 
UAV and Sensor. In our set up platforms 5 and 6 are not UAV’s. Operating on the 
ground they are modeled just on basis of their horizontal angle. The observation angles 


for the four UAV’s are shown in the last row. 


42 





APPENDIX C CODE FOR THE JAVA SENSOR ALLOCATION 

PROGRAM 


A. MAIN 


package j SAM; 


/* 

* File: Mai n. j ava 

* Created: 25th October 2 0 0 3, 1 8:0 0 
*! 

I »» 

* ©author Thomas Doll 


I mpor t j a va. utiI, *; 
import java.io.*; 
import java.text.*; 

public class Ma i n { 

public static void main(String[] args) { 

j SAM. S c e n a r i 0 scenario = new j SAM. Scenar i o( ) ; 

jSAM.Output GamsFiles gamsFiles = new jSAM.Output Ga ms F i I es ( s c e n a r i o ) ; 

jSAM.Gams Handling gams = new jSAM.Ga ms Handling(scenario); 

jSAM.Output Command output = new jSAM.Output Co mma n d ( s c e n a r i o , gams); 


} 


} 


B. INPUT MODELDATA 


package jSAM; 


I* 

* File: Input Model Data, j ava 

♦ Created: 25th November 2 0 0 3, 1 8:0 0 
♦/ 


I »» 

♦ ©author Thomas Doll 
*/ 


import j a va. t ex t. Dec I ma I F 0 r ma t ; 


public interface I n p u t _ Mod e I Da t a { 


II parameters for modeling PLOS 
double sigma ceiling 
double g r g h" 
double c’ceiling 
double g’xtnct 


14.5; 

0.0 0 0 7 0 4; 
0. 0 0 0 6 0 5; 
0. 5 6 9; 


double!) oper at ona I Al 11 t ude = { 1 5 0.0, 3 0 0.0, 6 0 0.0, 2 0 0 0.0, 3.0, 1.0 }; 

double!) oper at ona I Obs er vat i on Ra nge = { 1 5 0.0, 3 0 0.0, 6 0 0.0, 2 0 0 0.0, 3.0, 1.0 }; 


II parameters for modleing 


d 0 u b I e! 

{ 2 0.0 0 , 
{ 2 0,0 0 , 
{ 8. 9 2 0, 
{8,920, 
{ 2 0,0 0 , 
{ 2 0,0 0 , 
}; 


pi a t f 0 r m 
= { 


SweepWi dt h 


hori zontal Angl e 
15. 00}, 

9. 2 0 0 }, 

8. 9 0 0 }, 

8. 9 0 0 }, 

15. 00}, 

15. 00} 

/ /! PI at f or m] ! Sens 0 r 1 


hori zontal 


observation angle 


43 




double[][] vertical Angle = { 

{ 1 5,0 0, 1 1.2 5 }, 

{ 1 5,0 0, 6.9 0 0 }, 

{ 6.6 8 0, 6.7 0 0 }, 

{ 6.6 8 0, 6.7 0 0 } 

}; //[Platform] [Sensor] vertical observation angle 


double]] observationAngle = {45.0, 45.0, 45.0, 45,0}; //[Platform] 


double swag_dependance = 0.1; 


II 
I nt 


}; 


arameters for modeling package combinations 
]] 1 basI c Pac kages = { 


{ 

1, 

0, 

0, 

0, 

0, 

0}, 

//PI 

a t f 0 r mCo mb 

nat 

0 n 

f 0 r 

Package 

1 

{ 

0, 

1, 

0, 

0, 

0, 

0}, 

//PI 

a t f 0 r mCo mb 

nat 

0 n 

f 0 r 

Package 

2 

{ 

0, 

0, 

1, 

0, 

0, 

0}, 

//PI 

a t f 0 r mCo mb 

nat 

0 n 

f 0 r 

Package 

3 

{ 

0, 

0, 

0, 

1, 

0, 

0}, 

//PI 

a t f 0 r mCo mb 

nat 

0 n 

f 0 r 

Package 

4 

{ 

0, 

0, 

0, 

0, 

1, 

0}, 

//PI 

a t f 0 r mCo mb 

nat 

0 n 

f 0 r 

Package 

5 

{ 

0, 

0, 

0, 

0, 

0, 

1}, 

//PI 

a t f 0 r mCo mb 

n a t 

0 n 

f 0 r 

Package 

6 

{ 

1, 

1, 

0, 

0, 

0, 

0}, 

//PI 

a t f 0 r mCo mb 

n a t 

0 n 

f 0 r 

Package 

7 

{ 

0, 

0, 

1, 

1, 

0, 

0}, 

//PI 

a t f 0 r mCo mb 

nat 

0 n 

f 0 r 

Package 

8 


double package_enhFact = 1.1; 


II par a me 
d 0 u b I e ] I 
d 0 u b I e 1 ] 
d 0 u b I e [ ] 
d 0 u b I e [ ] 

d 0 u b I e ] ] 
d 0 u b I e [ ] 
d 0 u b I e [ ] 
d 0 u b I e [ ] 

bool ean] ] 


f or 


Character! sti cs 


pi atformtatency 

= 

{0. 

6, 

0. 

5 


0, 3, 

0, 

1, 0. 

4, 

1. 0} 




pi at f 0 r mCos t 

= 

{0. 

1, 

0. 

3 

, 

0,7, 

1. 

0, 0. 

8, 

0. 2} 




platformPerishability 

= 

{0. 

2, 

0. 

2 

, 

0, 8, 

1, 

0, 0. 

4, 

0. 2} 




pi atformtogi sti cs 

= 

{0. 

3, 

0. 

4 

• 

0,5, 

0, 

7, 0. 

1, 

0. 1} 




travelSpeed 

{80 

. 0, 


100 


0, 

2 0 0, 

0, 

135. 

0, 

200 

. 0, 

2 0 0, 

0} 

searchSpeed 

{60 

. 0, 


80. 

0 


140, 

0, 

100. 

0, 

20. 

0, 

0, 0 

} 

operationalTime 

{1. 

0, 


2. 0 



6.0, 


5. 0, 


72. 

0, 

72.0 

} 

operational Radius 

{16 

. 0, 


30. 

0 

’ 

40, 0 


75. 

, 

800 

. 0, 

8 0 0, 

0} 

air Dropped ={fa 

1 e 

, f a 1 

se. 


f al se. 

f al se. 

t 

rue. 

t r 

ue, }; 



II cluster coordinates and dimensions 
double]] entryPoint = {19.0, 50.0}; 


double]]]] cluster Data = { 


{30, 5 

54 

0, 

31 

0, 

22, 

0}, 

lie 

u s t e r 

01 {xCoord, yCoord, ewDimension, nsDimension} 

{20, 5 

39 

0, 

21 

0, 

28, 

0}, 

lie 

ust er 

'02 

{36, 0 

44 

0, 

20 

0, 

18, 

0}, 

lie 

ust er 

"03 

{49, 0 

63 

5, 

32 

0, 

23. 

0}, 

lie 

u s t e r 

'04 

{50, 5 

49 

0, 

29 

0, 

26, 

0}, 

lie 

ust er 

'05 

{48, 0 

32 

0, 

24 

0, 

28, 

0}, 

lie 

ust er 

"06 

{65, 0 

53 

0, 

20 

0, 

34. 

0}, 

lie 

u s t e r 

'07 

{62. 5 

, 32 

0, 

25 

0, 

28. 

0}, 

lie 

u s t e r 

"08 

{55. 5 

, 20 

5, 

39 

0, 

15, 

0}, 

lie 

ust er 

'09 

{62,0 

}; 

, 10 

0, 

28 

0, 

31. 

0}, 

lie 

u s t e r 

‘10 

d 0 u b 1 e ] 1 

t a r get Speed 

= {1 

. 0, 

5. 0, 

4. 0, 

7.0, 5,0, 6,0, 6.0, 6.0, 7.0, 5.0}; 

II e n e my 

order 

of 

bat 11 e 





long s c e n a rI 

Seed 




= 12345; 


I nt max 

Nu mbe r Of Ta r g et s 


= 100; 


d 0 u b 1 e ] I 

eOB 

_ F a c 1 0 r 



= {0.45, 

0.5 0, 0,6 0, 0,6 5 }; 


II common used 
Dec I maI F or mat 
Dec I maI F or mat 
Dec I maI F or mat 
Dec I maI F or mat 
Dec I maI F or mat 
Dec I maI F or mat 
Dec I maI F or mat 
Dec I maI F or mat 
Dec I ma I F o r mat 
Dec I maI F or mat 
Dec I maI F or mat 
Dec I maI F or mat 
Dec I maI F or mat 
Dec I maI F or mat 
Dec I maI F or mat 


obj ect s 
f or mat Pr ob 
f or mat I dent I fI er 
f or mat Number 
formatPackage 
f or mat Range 
formatCharacteri sti cs 
f or mat Ti me 
f or mat SweepWi dt h 
f or mat CDP 
f or mat Rat e 
f or mat Pr ob2 
formatldentifier2 
f 0 r mat Nu mber 2 
f or mat Co or d 
f 0 r mat Nu mbe r 3 


new 

new 

new 

new 

new 

new 

new 

new 

new 

new 

new 

new 

new 

new 

new 


Dec! maI For mat ( 
Dec! ma I F o r mat ( 
Dec! maI For mat ( 
Dec! ma I F o r mat ( 
Dec! maI For mat ( 
Dec! ma I F o r mat ( 
Dec! maI For mat ( 
Dec! ma I F o r mat ( 
Dec! maI For mat ( 
Dec! ma I F o r mat ( 
Dec! maI For mat ( 
Dec! ma I F o r mat ( 
Dec! maI For mat ( 
Dec! ma I F o r mat ( 
Dec! maI For mat ( 


0,0 0 0 " ) ; 

00 " ) ; 

0 0 0 " ); 

0 0 0 0 " ) ; 

0 0 0 0 0 " ); 
0,0 " ) ; 
00,00 " ); 

0 0 0 0 0 " ); 

0 , 0 0 0 " ) ; 

0 0 0 0,0 0 " ) ; 
0 , 0 0 0 0 0 " ); 
00 " ) ; 

0 ") ; 

0 0 0 . 0 0 0 " ) ; 
0 "); 


II control panel 


44 


























bool ean debugging Mode 
boolean print Verbose 
boolean use operational Radi us 
bool ean r un^Mode 

} II end I n p u t _ Mod e I Da t a interface 


false; //for error checking 

true; //prints everything to the command line 

true; //use operational radius or not 

true; //prints so me information about the run 


C. SENSORS 

package j SAM; 


/* 

* File; Sensor.java 

* Created; 25th November 2 0 0 3, 1 8;00 
*! 

I »» 

* ©author Thomas Doll 
*1 


mpor t j a va. utiI, * ; 
mport java.io.*; 
mport java.text.*; 


public class Sensors implements Input Model Data { 

/ / cI ass const ant s 

final static String s e n s o r Da t a F i I e = "SENSOR DATA MOD.CSV"; 


II class variables 
II instance variables 
private i n t n u mbe r Of PI a t f o r ms ; 
private int number Of Targets; 
private int sensor Dat aFli ght ; 
private int sensor Da taWidth; 

private int[] n u mbe r Of Se n s o r s ; II [Platform] Indicates the number of 

sensors per platform 


private double[][] 
private doubi e[ ] [ ] 
private doubleilll 
private doubleilM 


centerPi ctureWi dth; 
si dePi CtureWi dth; 
pi ctureLength; 
s hort CPi ct Di St ; 


private double[][] longCPictDist; 


private double[][] s h o r t S P i c t Di s t ; 


private double[][] longSPictDist; 


II [Platform] [Sensor] 
II [ PI at f or m] [ Sens or ] 
II [ PI at f or m] [ Sens or ] 
II [Platform] [Sensor] 
Di St ance form UAV 
II [ PI at f or m] [ Sens or 1 
Distance form UAV 
II [ PI at f or m] [ Sens or ] 
Distance form UAV 
Pi c t u r e 

II [ PI at f or m] [ Sens or 1 
Distance form UAV 
Pi c t u r e 


shortest ground 
to Center Picture 
longest ground 
to Center Picture 
shortest ground 
to one of the Side 

longest ground 
to one of the Side 


private double]]]]]] 
private doubi e[ ][]] ] 
private doubi e[ I]]] ] 
private doubi e[ ] [11 ] 

private double]]]]]]]] r angeDat a; 
private double]]]]]]]] sensor Data; 
private d o u b I e [][][][ ] p I os Co r r e c t ed Da t a ; 


II [Platform] [SensorllTarget] 

II [Platform] [SensoriiTarget] 

II [Platform] [SensoriiTarget] 

II iPlatformiiSensoriiTargeti 

II [Platform] ]Sensor][Target][Rangelndex] 
II iPlatformjiSensoriiTargetiiSensorIndex] 
II iPlatformjiSensoriiTargetjilndex] 


toRangeArray; 
centerPi ctureProbabi I ity; 
si dePi CtureProbabi I i ty; 
s ens 0 r Sweep Wi dth; 


II class met hods 
II constructor met hods 

I »» 

♦ constructor for parameter inputstring 
*/ 


public Sensors] ) { 

II this if for debugging 
if (run Mode) { 

S y s f e m. 0 u t. p r i n 11 n ( " 

S y s t e m. 0 u t. p r i n 11 n ( " 

S y s t e m. 0 u t. p r i n 11 n i " 

S y s t e m. 0 u t. p r i n 11 n i " 

S y s t e m. 0 u t. p r i n 11 n ( " 


\ n] AVA SENSOR ALLOCATI ON MODEL 
NAVAL POSTGRADUATE SCHOOL" ); 
Version; 1.5"); 

Date ; january 19 2004 "); 
Author ; Dipl.-Ing. Thomas 
Contact; tdoll@nps.navy.mil 


(J SAM) 


Doll t d 0 1 I @n ps. n a V y. mi I " ) ; 

II 1 . 


45 







System, out. pri ntl n("\n->Start Preprocessor"); 

} 

if (debugging Mode) { 

Sy s t e m. 0 uf. p r i n t i n ( " \ n. Debugging Output for Ciass Sensors 


} 


s ens or Dat a (); 

t h i s. c ent er Pi ct u r eWi dt h = new dou bi e [ get Nu mber Of UAV( ) ] [ ] ; 

t h i s. s i dePi c t u r e Wi dt h = new dou bi e [ get Nu mber Of UAV( ) j [ ] ; 

t h i s. pi c t u r eLeng t h = new dou bi e [ get Nu mbe r Of UAV( ) ] [ ] ; 
p i c t u r e Di me n s i 0 n s ( ) ; 

t h i s. s h 0 r t CP i c t Di s t = new d o u b i e [ g et Nu mb e r Of UAV( ) ] [ ] ; 

t hi s. i ongCPi ct Di St = new d o u b i e [ g et Nu mbe r Of UAV( ) ] [ j ; 

t h i s. s h 0 r t SPi c t Di s t = new do u bi e [ get Nu mber Of UAV( ) ] [ ] ; 
t h i s . i 0 n g S P i c t Di s t = new d o u b i e [ g et Nu mbe r Of UAV( j ] [ ] ; 
pi c t u r eDi s t a nc es ( ) ; 

pi os Cor r ect ed Dat a( ); 
pictureProbabiiityi); 
s ens 0 r SweepWi d t h ( ) ; 


II instance methods 

II reads the sensor data into the new data structure from a textfiie 
pubiic void sensor Da ta() { 

String i nput St r i ng; 

Fi i eReader i nput Fi i e; 

Buffered Reader inputUnit; 

St r i ngTokeni zer t k; 

II this is to predefine the vai ues for n u mbe r Of P i a t f o r ms and n u mbe r Of Ta r g et s 
try { 

inputFiie = new F i i e Rea d e r ( s e n s o r Da t a F i i e ) ; 

inputUnit = new Buf f e r ed Rea d e r ( i n p u t F i i e ) ; 

inputstring = i n p u t Un i t. r e a d L i n e ( ) ; 

tk = new StringTokenizer(inputString, ","); 

sensor Data Width = Integer.parselnt(tk.nextToken()); 
s ens 0 r Dat a Fli g ht = I nt ege r. pa r s eI nt ( t k. n ext Token ( ) ) ; 

for j i nt i = 0; i < s e n s o r Da t a Fli g h t ; i+ + ) { 

inputstring = i n p u t U n i t. r ea d L i n e ( ) ; 
tk = new StringTokenizer(inputString, ","); 

i nt p = (int) Do u b I e. p a r s e Do u b I e ( t k. n ex t To ke n ( ) ) ; 

i nt s = (int) Do u b I e. p a r s e Do u b I e ( t k. n ex t To ke n( ) ) ; 

int t = (int) Do u b I e. pa r s e Do u b I e ( t k. n ex t To ke n ( ) ) ; 

if ( p > n u mbe r Of PI a t f 0 r ms ) { 

n u mber Of PI a t f 0 r ms = p ; 

} 

if ( t > n u mbe r Of Ta r g et s ) { 
n u mber Of Ta r get s = t ; 

} 

} 

inputUnit.close(); 

} catch ( FiI eNotFoundExcepti on e) { 

System, out.println(e); 
return; 

} catch (lOException e) { 

System, out.println(e); 
return; 

} 

II this is to predefine the values for n u mbe r Of Se n s o r s 
n u mber Of Sens 0 r s = new i nt [ n u mber Of PI at f o r ms ] ; 
try { 

inputFiie = new F i I e Rea d e r ( s e n s o r Da t a F i I e ) ; 
inputUnit = new Buf f e r ed Rea d e r ( i n p u t F i I e ) ; 
inputstring = i nput Uni t. r eadti ne( ) ; 

tk = new StringTokenizer(inputString, ","); 

for (int i = 0; i < s e n s o r Da t a Fli g h t ; i+ + ) { 


46 













inputstring = i n p u t U n i t. r ea d L i n e ( ) ; 
tk = new StringTokenizer(inputString, 

i nt p = (int) Do u b i e. p a r s e Do u b i e ( t k. n ex t To ke n( ) ) ; 

i nt s = (int) Do u b i e. p a r s e Do u b i e ( t k. n ex t To ke n ( ) ) ; 

int t = (int) Do u b i e. p a r s e Do u b i e ( t k. n ex t To ke n ( ) ) ; 

if ( s > n u mber Of Sens or s [ p - 1 ] ) { 

n u mber Of Sens 0 r s [ p - 1 ] = s ; 

} 

} 

inputUnit.ciose(); 

} catch ( Fii eNotFoundExcepti on e) { 

System, out.printin(e); 
return; 

} catch (iOException e) { 

System, out.printin(e); 
return; 

} 

II this is to define the the size of r a ngeDat a [][][][] , sensor Dat a[ ][][][] , 
piosCorrectedData[][][][], pictureProbabiiityiiiiill], 

II and sensors we epWidthilliil 

this. range Data = new doubie[nu mber Of Piatfor ms ][][][]; 
this. sensor Data = new doubie[nu mber Of Piatfor ms ][][][]; 
t h i s. p i os Cor r ec t ed Dat a = new dou bi e [ n u mber Of Pi at f or ms ] [ ] [ ] [ ] ; 
this.centerPictureProbabiiity = new doubie[nu mber Of Piatfor ms ][][]; 
this.sidePictureProbabiiity = new doubie[nu mber Of Piatfor ms ][][]; 
t h i s. 1 0 Ra ngeAr r a y = new dou b i e [ n u mber Of P i at f or ms ] [ ] [ ] ; 
this. sensors weep Width = new doubie[nu mber Of Piatfor ms ][][]; 
try { 

inputFiie = new Fi i eReader ( sensor Dat aFi i e) ; 
inputUnit = new Buf f e r ed Rea d e r ( i n p u t F i i e ) ; 

inputstring = i n p u t Un i t. r ea d L i n e ( ) ; 

tk = new StringTokenizer(inputString, ","); 

for (int i = 0; i < s e n s o r Da t a Fli g h t ; i+ + ) { 

inputstring = i n p u t U n i t. r ea d L i n e ( ) ; 

tk = new StringTokenizer(inputString, ","); 

int p = (int) Do u b i e. p a r s e Do u b i e ( t k. n ex t To ke n ( ) ) ; 

t h i s. r a n geDat a [ p - 1] = new dou b i e[ n u mber Of Sens or s 

[p - 1 1 1 [ n u mbe r Of Ta r g et s 1 [ s e n s 0 r Da t a Wi d t h - 6] 
t h i s. s en s 0 r Dat a [ p - 1] = new dou bi e[ n u mber Of Sens or s 

[p - 1 1 1 [ n u mbe r Of Ta r g et s 1 [ s e n s 0 r Da t a Wi d t h - 6] 

t h i s. p i 0 s Co r r ec t ed Da t a [ p ■ 1] = new d o u b i e [ n u mbe r Of Se n s o r s 

[p ■ 1 ] 1 [ n u mbe r Of Ta r g et s 1 [ s e n s 0 r Da t a Wi d t h - 6] 

this.centerPictureProbabiiityip - 1] = new doubie[nu mber Of Sensors 

[ p ■ 1 ] 1 [ n u mber Of Ta r g et s 1; 

this.sidePictureProbabiiitylp ■ 1] = new doubielnu mber Of Sensors 

[ p - 1 1 1 [ n u mber Of Ta r g et s 1; 

t h i s. 1 0 Ra ngeAr r ay [ p - 1] = new d ou bi e [ n u mber Of Sens or s 

[ p ■ 1 1 1 [ n u mber Of Ta r g et s 1; 

this. sensors we epWidthlp - 1] = new doubielnu mber Of Sensors 

[ p ■ 1 1 1 [ n u mber Of Ta r g et s 1; 

} 

inputUnit.ciose(); 

} catch ( Fii eNotFoundExcepti on e) { 

System, out.printin(e); 
return; 

} catch (iOException e) { 

System, out.printin(e); 
return; 

} 

II this finaiiy is to read in the data 
try { 

inputFiie = new F i i e Rea d e r ( s e n s o r Da t a F i i e ) ; 

inputUnit = new Buf f e r ed Rea d e r ( i n p u t F i i e ) ; 

inputstring = i nput Uni t. r eadti ne( ) ; 

tk = new StringTokenizer(inputString, ","); 

for (int i = 0; i < s e n s o r Da t a Hi g h t ; i + + ) { 

inputstring = i n p u t U n i t. r ea d L i n e ( ) ; 

tk = new StringTokenizer(inputString, ","); 

int p = (int) Do u b i e. p a r s e Do u b i e ( t k. n ex t To ke n ( ) ) ; 


47 








i nt s = (int) Do u b I e. p a r s e Do u b I e ( t k. n ex t To ke n ( ) ) ; 

i nt t = (int) Do u b I e. p a r s e Do u b I e ( t k. n ex t To ke n ( ) ) ; 

double fromRange = Do u b I e. pa r s e Do u b I e ( t k. n ex t To ke n ( ) ) ; 

double toRange = Do u b I e. pa r s e Do u b I e( t k. n ex t To ke n ( ) ) ; 

double increment = Double.parseDouble(tk.nextToken()); 
double range = fromRange; 

1 0 Ra n g eAr r a y [ p - l][s - l][t - 1] = toRange; 

for (int j = 6; j < sensor Dat aWi dt h; j + + ) { 
if (range <= toRange) { 

rangeDatalp - l][s ■ l][t ■ l][j - 6] = range; 
range += increment; 

} el se { 

rangeDat a [ p - 1 ] [ s ■ 1 ] [ t ■ 1] [ j - 6] =0.0; 

} 

sensor Dat a[ p - 1] [ s - lift - 1] [ j - 6] = 

DoubI e. parseDoubI e(tk. nextToken( ) ) ; 


} 

if (debugging Mode) { 

for (int p = 0; p < g et Nu mbe r Of PI a t f o r ms ( ) ; p + + ) { 
for (int s = 0; s < g et Nu mbe r Of Se n s o r s ( p ) ; s+ + ) { 

for (int t = 0; t < g et Nu mbe r Of Ta r g e t s ( ) ; t + + ) { 

for (int index = 0; index < g et S e n s o r Da t a S i z e( ) ; index+ + ) { 

II System, out.println(" range Da ta[p-l][s-l][t-l][j-6] = " + 

r a ngeDat a [ p- 1 ] [ s - 1 ] 11 - 1 ] [ j - 6] ) ; 

Syst em. out. pr i nt I n( " sensor Dat a[ p-1] [ s-1] [ t -1] [ j - 6] = " + 

sensor Dat a[ p 1[ s 1[ 1 1[ i ndex ] ); 

II Syst em. out. pr i nt I n( “ get Sensor Dat a[ p -1] [ s -1] [ t - 1] [ j - 6] = 
" + getSensor Da ta(p-l,s-l,t-l,index)); 

} 

} 

} 

} 

} 


inputUnit.close(); 

} catch ( FiI eNotFoundExcepti on e) { 
System, out.println(e); 
return; 

} catch (lOException e) { 

System, out.println(e); 
return; 

} 

} 

II PLOS correction of sensorData 
public void pi osCor r ect edDat a( ) { 
double slant Range = 0.0; 


} 


for (int p = 0; p < g et Nu mbe r Of PI a t f o r ms ( ) ; p+ + ) { 
for (int s = 0; s < g et N u mbe r Of Se n s o r s ( p ) ; s+ + ) { 

for (int t = 0; t < g et Nu mbe r Of Ta r g et s ( ) ; t+ + ) { 

for (int index = 0; index < get Sensor Dat aSi ze( ) ; index+ + ) { 

slantRange = Ma t h. s q r t ( r a n g e Da t a [ p ] [ s ] [ t ] [ i n d ex ] * 

rangeDat a [ p ] [ s 1[ 1 1 [ i ndeX 1 + operatona I Al t i tude[ p ] * 
operatonal Al ti tude[ p] ) ; 

double sigma rgh = sigma ceiling ♦ (1 - Math.exp(-g rgh * 

"slant Rangejl; 

double c xtnct = c ceiling * (1 - Math.exp(-g xtnct * sigma rgh / 
operatonalAltit udelp] )); 
double pi os = Math.exp(-c xtnct * slantRange); 


} 


pi os CorrectedData [ p] [ s 1 [ 1 1 [ i ndex 1 = sensorData [ p ] [ s ] [ t ] [ i ndex ] ♦ 
pi os ; 


II method to compute the Dimensions of a single observaton picture taken by a 
pi at f 0 r m 

public void pictureDimensions() { 

for (int p = 0; p < g et Nu mbe r Of UAV( ) ; p + + ) { 

this.centerPictureWidthlp] = new double[getNumberOfSensors(p)]; 


48 


this.sidePictureWidthlp] = new double[getNumberOfSensors(p)]; 
t hi s. pi ct ur eLengt h [ p ] = new doubI e [ get Number Of Sensor s ( p ) j ; 

for ( i nt s = 0; s < g et N u mbe r Of Se n s o r s ( p ) ; s+ + ) { 

double slant Range = 0.0; 

double ground Dl St = 0.0; 

// this Is for the width of the areas 
slantRange = o pe r a t o n a I Al 11 t u d e[ p ] / 

Math. cos( Math. toRadI ans( observatl onAngl e[ p] ) ) ; 
centerPlctureWldth[p][s] = 2 * (slantRange * 

Ma t h. t a n ( Ma t h. 1 0 Ra d I a n s ( h 0 r I z 0 n t a I An g I e [ p ] [ s 1 / 2))); 

s I d e PI c t u r e Wl d t h[ p 1 [ s 1 = slantRange * Ma t h. t a n ( Ma t h. t o Ra d I a n s ( 3 * 

horlzontalAngle[p][s] / 2)) - centerPlctureWldth[p][s] / 2; 

II this Is for the length of the areas 
groundDlst = o pe r a t o n a I Al 11 t u d e[ p ] * 

Math. tan( Math. toRadi ans( observatl onAngl e[ p] - 
vert I cal Angl e[ p] [ s] / 2) ) ; 

pI c t u r eLengt h [ p 1 [ s 1 = ( o per at ona I Al 11 t ude [ p ] * 

Math. tan( Math. toRadi ans( observatl onAngl e[ p] + 
vert I cal Angl e[ pi [ s] / 2))) - groundDlst; 

} 

} 

} 

II method to compute the Ground DIstancles from the UAV to the different Pictures 
public void plctureDlstances() { 

for ( I nt p = 0; p < g et Nu mbe r Of UAV( ) ; p + + ) { 

t h I s. s h 0 r t CP I c t Dl s t [ p 1 = new d o u b I e [ g e t Nu mbe r Of S e n s o r s ( p ) ] ; 

t h I s . I ongCPI ct Dl St [ p] = new d o u b I e [ g e t Nu mbe r Of Se n s o r s ( p ) ] ; 

t h I s. s h 0 r t S PI c t Dl s t [ p 1 = new d o u b I e [ g e t Nu mbe r Of S e n s o r s ( p ) ] ; 

t h I s. I 0 n g S PI c t Dl s t [ p 1 = new d o u b I e [ g et Nu mbe r Of Se n s o r s ( p ) ] ; 

for ( I nt s = 0; s < g et N u mbe r Of Se n s o r s ( p ) ; s+ + ) { 
double slant Range = 0.0; 
double groundDlst = 0.0; 


} 


II this Is for the distancles to the center picture 
s h 0 r t CPI c t Dl s t [ p 1 [ s 1 = oper at ona I Al 11 t ude[ p] ♦ 

Math. tan( Math. toRadi ans( observatl onAngl e[ p] ) ) ; 


I f 


} 


( debuggi ng Mode) { 

System, out. prlntln("p= " + p + " operatonalAltItudelp] " + 
operatonal Al tl tude[ p] ) ; 

System, out. prlntln("p= " + p + " observatlonAnglelp] " + 
observatl onAngl e[p] ); 

System, out. prlntln("p= " + p + " s= " + s + " shortCPIctDlst[p][s] = 
+ s hor t CP I c t Dl s t [ p] [ s 1 ) ; 


I 0 n g CP I c t Dl s t [ p 1 [ s 1 = Ma t h. s q r t ( ( s h o r t CP I c t Dl s t [ p ] [ s ] + 

pi ct ureLengt h[ p] [ s] ) * ( s h o r t CP I c t Dl s t [ p ] [ s ] + 
pIctureLengthiplisj) + (centerPlctureWldth[p][sl / 
2 ) * ( c e n t e r PI c t u r e Wl d t h [ p 1 [ s 1 / 2 ) ); 


II this Is for the distancles to the side picture 
s h 0 r t S PI c t Dl s t [ p 1 [ s 1 = Ma t h. s q r t ( s h 0 r t CP I c t Dl s t [ p 1 [ s 1 ♦ 

s hor t CPI c t Dl s t [ p] [ s 1 + ( c ent er PI c t u r eWI dt h [ p] [ s 1 / 

2 ) » ( c e n t e r PI c t u r e Wl d t h [ p ] [ s ] / 2 ) ); 

I 0 n g S PI c t Dl s t [ p 1 [ s 1 = Ma t h. s q r t ( ( s h o r t CP I c t Dl s t [ p ] [ s ] + 

pi ct ureLengt h[ p] [ s] ) * ( s h o r t CP I c t Dl s t [ p ] [ s ] + 
pi ct ureLengt hi p] [ s] ) + (3 * 
centerPIctureWidthiplls] / 2) * (3 ♦ 
centerPIctureWldthipiisj / 2)); 


II method to compute the mean probability of detection In a picture 
public void pIctureProbabllltyi) { 
double shortCenterProb = 0.0; 
double longCenterProb = 0.0; 
double shortSIdeProb = 0.0; 
double longSIdeProb = 0.0; 


for ( I nt p = 0; p < g et Nu mbe r Of LIAV( ) ; p + + ) { 

for ( I nt s = 0; s < g et N u mbe r Of Se n s o r s ( p ) ; s+ + ) { 

for ( I nt t = 0; t < g et Nu mbe r Of Ta r g et s ( ) ; t+ + ) { 

for ( I nt Index = 0; Index < get Sensor Dat aSI ze( ) - 1; lndex+ + ) { 


If ( s h 0 r t CP I c t Dl s t [ p 1 [ s 1 >= 1 0 Ra n g eAr r a y [ p 1 [ s 1 [ 1 1 ) { 


49 


shortCenterProb = 0.0; 

} else if ( s hor t CPi c t Di s t [ p] [ s ] >= r a n g e Da t a [ p ] [ s ] [ t ] [ i n d ex ] && 

s hor t CPi c t Di s t [ pi [ s 1 < r a ngeDat a [ p] i s 1 [ 1 1 i i ndex + 1] ) 

{ 

II interpolation 

double probDiff = Ma t h. a bs ( p I os Co r r ec t ed Da t a [ p ] [ s ] [ t ] [ i n d ex ] 
- pi os CorrectedData[ p] [ s 1 [ 1 1 [ i ndex + 1]); 

double rangeDiff = Ma t h. a bs ( r a n g e Da t a [ p ] i s ] [ t ] [ I n d ex + 1] - 

r a ngeDat a i p] [ s 1[ 1 1[ I ndex 1 ) ; 

double r a n g e I n t e r c e p t = Ma t h. a bs ( s h o r t CP I c t Di s t [ p ] [ s ] - 
r a ngeDat a [ p j[ s ]1 1 1[ I ndex ]); 
double p r 0 b I n t e r c e pt = (probDiff / rangeDiff) ♦ 
rangel ntercept; 


ShortCenterProb 


plosCorrectedData[p][s][t][index] 
probi ntercept; 


if (longCPictDist[p][s] >=toRangeArray[p][s][t]) { 
longCenterProb = 0.0; 

} else if ( I ongCPi ct Di St [ p] [ s 1 <= r a n g e Da t a [ p ] [ s ] [ t ] [ i n d ex + 1] 

&& s hor t CPi c t Di s t [ p] [ s 1 > r a ngeDat a i pi i s 1 i 1 1 [ i ndex + 

11) { 

II interpolation 

double probDiff = Ma t h. a bs ( p I os Co r r ec t ed Da t a [ p ] [ s ] [ t ] [ i n d ex ] 
- pl os CorrectedData[ p][s ] [ 11 [ i ndex + 1]); 

double rangeDiff = Ma t h. a bs ( r a n g e Da t a [ p ] i s ] [ t ] [ i n d ex + ij - 

r a ngeDat a i p] [ s 1[ 1 1[ i ndex i ) ; 

double r a n g e I n t e r c e p t = Ma t h. a bs ( s h o r t CP i c t Di s t [ p ] [ s ] - 
r a ngeDat a [ p] [ s ][ 1 1[ i ndex 1 ) ; 
double p r 0 b I n t e r c e pt = (probDiff / rangeDiff) ♦ 
rangel ntercept; 


} 


longCenterProb = p I o s Co r r ec t ed Da t a [ p ] [ s ] [ t ] [ i n d ex ] - 
probi ntercept; 


if ( s hor t SPi c t Di s t [ p] [ s 1 >= t oRa ngeAr r ay [ p] [ s 1 [ 1 1 ) { 
shortSideProb = 0.0; 

} else if ( s h or t SPi c t Di s t [ p] [ s 1 >= r a ngeDat a [ p] [ s ] [ t ] [ i ndex ] && 
s hor t SPi c t Di s t i pi i s i < r a ngeDat a [ p] [ s 1 [ 1 1 [ i ndex + 1] ) 
{ 

II interpolation 

double probDiff = Ma t h. a bs ( p I os Co r r ec t ed Da t a [ p 1 [ s 1 [ t ] [ i n d ex ] 
- p I os CorrectedData [ p 1[ s 1[ t i[ i ndex + 1]); 
double rangeDiff = Ma t h. a bs ( r a n g e Da t a [ p i i s i i t i i i n d ex + li - 
r a ngeDat a [ p] [ s 1[ 1 1[ i ndex i i ; 

double r a n g e I n t e r c e p t = Ma t h. a bs ( s h o r t CP i c t Di s t [ p ] [ s ] - 
r a ngeDat a [ p j[ s i[ 1 1[ i ndex 1); 
double p r 0 b I n t e r c e pt = (probDiff / rangeDiff) * 
rangel ntercept; 


shortSideProb = p I os Co r r ec t ed Da t a [ p ] [ s ] [ t ] [ i n d ex ] 
probi ntercept; 


} 


if ( I ongSPi ct Di St [ p] [ s] >= t o Ra n g eAr r a y [ p ] [ s ] [ t ] ) { 
longSideProb = 0.0; 

} else if ( I 0 n g S P i c t Di s t [ p ] [ s 1 <= r a n g e Da t a [ p ] [ s ] [ t ] [ i n d ex + 1 

1 && s hor t SPi c t Di s t [ p] [ s 1 > r a ngeDat a i p] [ s 1 [ 1 1 [ i n dex + 

11) { 

II interpolation 

double probDiff = Ma t h. a bs ( p I os Co r r ec t ed Da t a [ p 1 [ s 1 [ 1 1 [ i n d ex 1 

- pl os Correct ed Data [ p] [ s 1[ t i [ i ndex + 11); 

double rangeDiff = Ma t h. a bs ( r a n g e Da t a [ p i i s i [ t i i i n d ex + li - 
r a ngeDat a [ pl [ s 1[ 1 1[ i ndex i i ; 

double r a n g e I n t e r c e p t = Ma t h. a bs ( s h o r t CP i c t Di s t [ p 1 [ s 1 - 
r a ngeDat a [ p j[ s 11 1 1[ i ndex ]); 
double p r 0 b I n t e r c e pt = (probDiff / rangeDiff) ♦ 
rangel ntercept; 


longSideProb = p I os Co r r ec t ed Da t a [ p ] [ s 1 [ t ] [ i n d ex ] - 
probi ntercept; 


} 

c e nt er Pi c t u r ePr 0 ba bi I i t y [ p ] [ s 1 [ 1 1 = (shortCenterProb + 

longCenterProb) / 2; 

s i dePi ct ur ePr 0 babi I i t y [ p 1 [ s 1 [ 1 1 = (shortSideProb + longSideProb) / 2; 


50 


} 

} 

II method to compute the SensorS weep Width based on the reltive area covered with 
pi ct u r es 

public void sensors weep Width!) { 
double c e n t e r S we e pAr ea = 0,0; 
double sidesweepArea = 0.0; 
double coveredSegmentArea = 0.0; 

for ( i nt p = 0; p < g et Nu mbe r Of PI a t f o r ms ( ) ; p+ + ) { 

for ( i nt s = 0; s < g et N u mbe r Of Se n s o r s ( p ) ; s+ + ) { 

for ( i nt t = 0; t < g et Nu mbe r Of Ta r g et s ( ) ; t+ + ) { 

if (p < g et Nu mbe r Of UAV( ) ) { II This is for UAV s flying at an 

operational altitude 

centers weepArea = centerPictureWidth[p][s] * pictureLength[p][s] 

♦ centerPictureProbability[p][s][tl; 
sides weepArea = sidePictureWidth[p][s] * pictureLength[p][s] * 
sidePictureProbability[p][sj[t]; 
coveredSegmentArea = c en t er SweepAr ea + (2 ♦ si deSweepArea) ; 

sensors we epWidth[p][s][t] = coveredSegmentArea / (2 ♦ 
pi ct ur etengt h [ p] [ s 1 ) ; 

} else { II This is for UAV s operting on the ground (also referred 
to as airdropped) 

II Integration over p I os Co r r ec t ed Da t a to get the Se n s o r S wee p Wi d t h 
for stationary groundoperating platforms 
double increment = range Da ta[p][s]it][l]; 
double sector Part = 0.0; 
double sectorProb = 0.0; 
double c 0 ve r ed Sec 1 0 r Ar e a = 0,0; 


} 


for ( i nt index = 0; index < g et PI os Co r r ec t ed Da t a S i z e ( ) - 1 ; 
i ndex+ + ) { 

if ( r a ng eDat a [ p] [ s 1 1 1 1 [ i ndex +1 1 !=0.0) { 

sectorPart =(Math.PI ♦ r a n g e Da t a [ p ] [ s ] [ t ] [ i n d ex +1 ] ♦ 

r a n geDat a [ p] [ s 1 [ 1 1 [ i ndex +1 1 * 

horizontalAngleipiis]/360.0) - 
(Math.PI ♦ r a n g e Da t a [ p 1 [ s 1 [ 1 1 [ i n d ex 1 ♦ 

r a n geDat a [ p] [ s 1 [ 1 1 [ i ndex 1 * 

horizontal Angle[piis]/360.0); 
sectorProb = ( sensorData [ p ][ s ][ t ][ i ndex ] + 

sensor Dat a [ p] [ s 1 [ 1 1 [ i ndex +1 ] ) / 2.0; 
c 0 VeredSect 0 rArea += sectorPart ♦ sectorProb; 
if (debugging Mode) { 

i f ( p==5 && s= = l && t = = 1) { 

System, out.printin ("SectorPart!" + 
rangeData [ p 1[ s 1 [ 1 1 [ i ndex +1 1 + ") = " + 
sectorPart) ; 

System, out.printin (" SectorProb) " + 

(range Da ta[p][s][t][index] + (increment/2,0)) + 
") = " + sectorProb); 

} 

} 


sensors we epWidth[p][s][t] = coveredSectorArea / 

t oRa ngeAr r ay [ p] [ s 1[ 1 1; 

if (debugging Mode) { 

i f ( p ==5 5,& s= = l && t==l) { 

System, out.printin) "coveredSectorArea(Plat 5, Sensor 1, 
Target 1) = " + coveredSectorArea); 
System, out.printin) "sweep Width(Plat 5, Sensor 1, Target 
1) = " + sensor SweepWi dt h[ 5] [ 1] [ 1] ) ; 

} 

} 


II getter methods for instance variables 
public i nt g et Nu mbe r Of PI a t f 0 r ms ( ) { 
return n u mber Of PI at f or ms ; 

} 

public i nt get Number Of UAV( ) { 
i n t n u mbe r Of UAV = 0; 


51 


for ( i nt p = 0; p < g et Nu mbe r Of PI a t f o r ms ( ) ; p+ + ) { 
if ( ! a i r Dr op pedl pi ) { 

+ + number Of UAV; 


} 


} 


return n u mbe r Of UAV; 


public i nt g et Nu mbe r Of Ta r g et s ( ) { 
return n u mber Of Ta r get s ; 


public i nt g et Nu mbe r Of Se n s 0 r s ( i n t index) { 
return n u mbe r Of S e n s o r s [ i n d ex ] ; 


public i nt g et Nu mbe r Of Se n s 0 r s L e n g t h ( ) { 
return n u mbe r Of S e n s o r s. I e n g t h ; 


public i nt get Sensor Dat aHi ght ( ) { 
return sensor Da taHi ght; 


public int getSensor Data Width!) { 
return s e n s o r Da t a Wi d t h ; 


public double get RangeDat a( i nt indexP, int i ndexS, int i ndexT, int indexR) 
ret urn rangeDatal i ndexP] [ i ndexS] [ i ndexT] [ i ndexR] ; 

} 

public int get RangeDat aSi ze( ) { 

return rangeData[0][0][0].length; 

} 

public double get Sensor Dat a( i nt indexP, int i ndexS, int i ndexT, int indexR) 
return sensorData[i ndexP][i ndexS][i ndexT][i ndexR]; 

} 

public int get Sensor Dat aSi ze( ) { 

return sensorData[0][0][0].length; 

} 

public double g et PI o s Co r r ec t ed Da t a ( i n t indexP, int indexS, int i ndexT, int 
ret urn pi osCorrectedDatal i ndexP] [ i ndexS] [ i ndexT] ] i ndexR] ; 

} 

public int g et PI os Co r r ec t ed Da t a S i z e( ) { 

return pi osCorrectedData] 0] ] 0] ]0] . I ength; 

} 

public double getCenterPictureWidth(int indexP, int indexS) { 
return centerPictureWidth]indexP]]indexS]; 

} 

public int getCenterPictureWidthHight!) { 
return centerPi ctureWi dth. I ength; 

} 

public int getCenterPictureWidthWidth!) { 
return centerPi ctureWi dth]0] . I ength; 

} 

public double getSidePictureWidth(int indexP, int indexS) { 
return sidePictureWidth]indexP]]indexS]; 

} 

public int getSidePictureWidthHight!) { 
return sidePictureWidth.length; 

} 

public int getSidePictureWidtWidth!) { 
return si dePi ctureWi dth] 0] . I ength; 

} 

public double g et P i c t u r e L e n g t h ( i n t indexP, int indexS) { 
return pictureLength]indexP]]i ndexS]; 


{ 


{ 


indexR) { 


52 



public i nt g et P i c t u r e L e n g t h Hi g ht ( ) { 
return pi ctureLength. length; 

} 

public int getPicturetengthWidthl) { 
return pictureLength[0].length; 

} 

public double get Short CPI ct Di st ( I nt indexP, int I ndexS) { 
return shortCPi ctDi st[ I ndexP] [ I ndexS] ; 

} 

public double get LongCPi ct Di st ( I nt indexP, int i ndexS) { 
return I ongCPi ctDi st[ i ndexP] [i ndexS] ; 

} 

public double get Short SPi ct Di st ( i nt indexP, int i ndexS) { 
return shortSPi ctDi st[ i ndexP] ] i ndexS] ; 

} 

public double get LongSPi ct Di st ( i nt indexP, int i ndexS) { 
return I ongSPi ctDi st[ i ndexP] Ji ndexS] ; 

} 

public double g et Ce n t e r P i c t u r e P r o ba b i I i t y ( i n t indexP, int i ndexS, int index!) { 
return centerPictureProbability[indexP][indexS][indexT]; 

} 

public double g et S i d e P i c t u r e P r o ba b i I i t y ( i n t indexP, int i ndexS, int index!) { 
return sidePictureProbability[indexP]lindexS][index!]; 

} 

public double getSensorSweepWidth(int indexP, int indexS, int index!) { 
return sensorSweepWi dth] i ndexP] ] i ndexS] ] i ndex!] ; 

} 

public int get Number Of Cl ust er ( ) { 
return cluster Data, length; 

} 

public String get Sensor Dat aFi I e( ) { 
return sensorDataFile; 

} 

} II end Sensor 


D. PLATFORMS 

package ] SAM; 


/* 

* File; Platform, java 

* Created; 25th November 2 0 0 3, 1 8;00 
*! 

I ♦» 

* ©author !homas Doll 
*! 


i mport 

j ava. 

util.*; 



i mport 

j ava. 

i 0. *; 



i mport 

j ava. 

text. *; 



p u b 1 i c 

cl ass 

Platforms extends Sensors 

i mpl ement 

II 

class 

constants 



II 

cl ass 

var i abl es 



II 

instance variables 



pri 

vat e 

double]]]] platformSweepWi 

dth; 

II 

pr i 

vat e 

double]]]] timeOnStation; 

II 

] PI 

pri 

vat e 

double]]]]]] platfor mRa t e; 

II 

] PI 

pri 

vat e 

doublelilili platfor mC DP; 

II 

] PI 

II 

class 

me t h 0 d s 



II 

1 »» 

constructor met hods 




s I n put _ Mode I Dat a { 


1 PI atform] l!arget] 
at f or m] 1 Cl ust er ] 
atform]iCluster]l!arget] 
atform]iCluster]l!arget] 


53 





*1 


constructor for parameter inputstring 


pubiic Piatforms() { 
s u pe r ( ) ; 

II this if for debugging 
if (debugging Mode) { 

S y s t e m. 0 u t. p r i n t i n ( " \ n 


} 


Debugging Output for Ciass Piatforms 


this. piatformS weep Width = new doubie 

[ getNumberOfPi atforms( ) ] [ getNu mb er Of Targets) ) ] ; 

pi at f or mSweepWi dt h( ) ; 

t hi s. t i meOnSt at i on = new dou bi e [ get Number Of Pi at f or ms ( ) ] [ get Number Of Ci ust er ( ) ] ; 
t i meOnSt at i on( ) ; 


thi s. pi atfor mRa t e = new doubie 

[ getNumberOfPi atfor ms ( ) ] [ getNumberOfCi uster( ) ] [ getNu mb er Of Targets) ) ] ; 
this.piatformCDP = new doubie 

[ getNumberOfPi atfor ms ( ) ] [ getNumberOfCi uster) ) ] [ getNu mb er Of Targets) ) ] ; 
pi atfor mC DP) ) ; 


II instance met hods 

II computes the sweep width for the piatform 
pubiic void piatforms weep Width)) { 
doubie sensorl Sweep Width = 0.0; 
doubie sensor2'S weep Width = 0.0; 
doubie sensorS’S weep Width = 0.0; 

for ( i nt p = 0; p < g et Nu mbe r Of P i a t f o r ms ( ) ; p+ + ) { 
for ( i nt t = 0; t < g et N u mbe r Of Ta r g e t s ( ) ; t + + ) { 

if ( g et Nu mbe r Of Se n s 0 r s ( p ) == 1) { 

piatforms we epWidth[p][t] = getSensorSweepWidth(p, 0, t); 

} 

if ( g et Nu mbe r Of Se n s 0 r s ( p ) == 2) { 

sensorl Sweep Width = getSensorSweepWidthfp, 0, t); 
sensor2‘S weep Width = getSensorSweepWidthjp, 1, t); 
doubie max = Math. max(sensorl_S weep Width, sensor2_S weep Width); 

piatforms we epWidth[p][t] = max + (sensorl Sweep Width + 

s ens 0 r 2 SweepWFdt h ■ max) ♦ 
swag dependance; 

if (debugging Mode)! 

if ( p == 0 && t == 1) { 

System, out.printin)" This Piatform has 2 Sensors"): 

Syst em. out. pr i nt i n( " \ t maxi mum Sensor Sweep Wi dt h New : " + 
max) ; 

System, out.printin) "\ts weep width for the piatform New : " + 
p i at f 0 r mSweep Wi dt h [ p 1 [ 1 1 ) ; 

} 

} 

} 

if ( g et Nu mbe r Of Se n s 0 r s ( p ) == 3) { 

sensorl Sweep Width = getSensorSweepWidth(p, 0, t); 

sensor2‘S weep Width = getSensorSweepWidthjp, 1, t); 

sensor3'S weep Width = getSensorSweepWidthjp, 2, t); 

doubie maxi = Math.max(sensorl Sweep Width, sensor2 Sweep Width); 

doubie max = Math, max) maxi, sehsor3_S weep Width); 

piatforms we epWidth[p][t] = max + (sensorl Sweep Width + 

sensor2 SweepWFdth + sensor3 Sweep Width - 
max) * swag dependance; 

} 

} 

} 

} 

II computes the time on station for the piatform 
pubiic void timeOnStation)) { 

for ( i nt p = 0; p < g et Nu mbe r Of P i a t f o r ms ( ) ; p+ + ) { 

for ( i nt c = 0; c < g et N u mbe r Of Ci u s t e r j ) ; C+ + ) { 

doubie distance = Ma t h. s q r t ( ( e n t r y Po i n t [ 0 ] - c i u s t e r Da t a [ c ] [ 0 ] ) * 

( entryPoi nt [ 0] - c i us terData [ c ] [ 0 ] ) + ( entryPoi nt [ 1 ] - 

c i ust er Dat a [ c ] [ 1 ] ) * ( ent r yPoi nt [ 1 ] - 
c i ust er Dat a i c ] i 1 ] ) ) ; 


54 






double time = operationalTime[p] - (2 ♦ distance / travelSpeedlp]); 


if (use operationalRadius) { 

if [distance <= operati ona I Radi us [ p ]) { 
if (airDroppedlpl) { 

timeOnStation[p][c] = operationalTime[p]; 

} else { 

if ( t i me > 0.0) { 

t i meOnSt at i on[ p] [ c 1 = t i me; 

} else { 

timeOnStation[p][c] = 0.0; 

} 

} 

} el se { 

timeOnStation[p][c] = 0.0; 

} 

} else { 

if (airDroppedlpl) { 

timeOnStationIpllc] = operationalTimelp); 

} el se { 

if ( t i me >0.0) { 

t i me On St a t i 0 n 1 p 1 1 c 1 = t i me ; 

} else { 

timeOnStationIpllc] = 0.0; 

} 


II computes the CDP for the platforms 
public void platformCDP() { 

for (int c = 0; c < g et Nu mbe r Of Cl u s t e r ( ) ; C+ + ) { 

for (int t = 0; t < g et N u mbe r Of Ta r g e t s ( ) ; t + + ) { 

for (int p = 0; p < g et Nu mbe r Of PI a t f o r ms ( ) ; p+ + ) { 

i f ( searchSpeedl p] >0.0) { 

platformRatelpllcllt] = searchSpeedlp] ♦ 

(platformsweepWidthlpllt] / 1000) ♦ 
timeOnStationiplld; 

} el se { 

platformRatelpllcllt] = t a r get Speed 1 1 ] * 

(platforms we epWidthlpllt] / 1000) ♦ 
timeOnStationIpllc]; 

} 

pi at f or mCDPI p] I c 1 1 1 1 = 1.0 ■ Mat h. ex p (- pI at f or mRat e I p ] I c ] 1 1 ] / 

I c I usterData I c 1 1 2 1 * c I usterDatal c ] 1 3] ) ) ; 

II this if for debugging 
if (debugging Mode) { 

if ( c == D && t == 0 && p == 1) { 

S y s t e m. 0 u t. p r i n 11 n ( " \ n c = " + c + " t = " + t + " p = " + p ) 

Sy s t e m. 0 u t. p r i n 11 n ( " p I a t f 0 r mRa t e I p =" + p + "]Ic=" + c + 

" 1 11 =" + t + " 1 ; " + 

formatRate. format) pi atformRatel p] I c] It] ) ) 
S y s t e m. 0 u t. p r i n 11 n ( " p I a t f 0 r mC D PI p =" + p + " ] I c =" + c + “ ] 11 = 
+ t + " I : " + 

formatCDP. format( pi atformCDPI p] I c] It] ) ) ; 

} 

} 

} 

} 

} 

} 

II getter methods for instance variables 

public double getPlatformSweepWidth(int indexP, int index!) { 
return pi atformSweepWi dthi i ndexP] I i ndexT] ; 

} 

public int getPlatformSweepWidthHight() { 
return pi atformSweepWi dth. I ength; 

} 

public int getPlatformSweepWidthWidth() { 
return pi atformSweepWi dthIO] . I ength; 

} 

public double g et Ti meOn St a t i o n ( i n t indexi, int index]) { 
return ti meOnStati onli ndexi ] li ndex] ]; 

} 


55 


pub 


pub 


p u b 


pub 


pub 


p u b 


pub 


pub 


p u b 


pub 

} 


ic int getTimeOnStationHight() { 
return timeOnStati on. length; 


ic int getTi me OnStation Width!) { 
return ti meOnStation[0].length; 


ic double get PI at f or mRat e( i nt indexP, int I ndexC, int index!) { 
return pi atformRate) i ndexP] [ i ndexC] [ i ndexT] ; 


ic int getPlatfor mRat e Hi g h t ( ) { 
return pi atformR ate. length; 


ic int getPlatfor mR ate Width!) { 
return platformRate[0].length; 


ic int getPlatfor mRat e De pt h! ) { 
return platformRate[0][01.length; 


ic double getPlatfor mCDP!int indexP, int indexC, int index!) { 
return pi atformCDP[ i ndexP] [ i ndexC] [ i ndex!) ; 


ic int getPlatfor mCDPHight!) { 
return pi atformC DP. length; 


ic int getPlatfor mC DP Width!) { 
return platformCDP[0].length; 


i c int g et PI a t f 0 r mCDP De pt h! ) { 
return platformCDP[0][0].length; 


} II end Platform 


E. PACKAGES 

package j SAM; 


/* 

* File; Pac kage. j ava 

♦ Created; 25th November 2 0 0 3, 1 8;00 
*1 

I »» 


* ©author !homas Doll 
*! 

i mport 

java, util.*; 

i mport 

j ava. I 0 . * ; 

I mport 

java.text.*; 

p u b 1 I c 

class Packages extends 

II 

class constants 

II 

class variables 

II 

instance variables 


int nu mb er Of Packages; 

int[][] packageCombinations; II [PackageliPlatform] 

doubleilll pa c ka g eCh a r a c t e r i s t i c s ; II [ Pa c ka g e ] [ La t e nc y, Cost, Perishability, 

Logi Sti cs j 

double[][][] packageCDP; II [ Pa c ka g e ][ Cl u s t e r ] [ !a r g et ] 

II class met hods 
II constructor met hods 

I »» 

* constructor for parameter inputstring. 

*1 


56 




public Packages!) { 
s u pe r ( ) ; 

II this if for debugging 
if (debugging Mode) { 

Sy s t e m. 0 uf. p r i n 11 n ( " \ n. Debugging Output for Class Packages 


} 

this. number Of Packages = basicPackages.length + 3 * choose(basicPackages.length, 

2 ) ; 

t hi s. pac kageCombi nat i 0 ns = new i nt [ number Of Pac kages ] [ get Number Of PI at f or ms ( ) ] ; 
packageCombi nati ons( ) ; 

this.packageCharacteristics = new double[numberOfPackages][4]; 
packageCharacteri sti cs( ); 
this.packageCDP = new double 

[ nu mb er Of Packages] [ getNumberOfCI uster( ) ] [ getNu mb er Of Targets! ) ] ; 

pac kageCDP! ); 

} 

II instance met hods 


II method to combine basic packages to consolidated packages 
public void packageCombinations!) { 

int combinationHight = choose!basicPackages.length, 2); 
i nt count =0; 


for (int k = 0; k < has i c Pac kages. I engt h; k + + ) { 

for (int p = 0; p < g et N u mbe r Of PI a t f o r ms ( ) ; p+ + ) { 

packageCombi nati ons[k][p] = basicPackages[k][p]; 

} 

for (int kl = k + 1; kl < ba s i c Pa c ka g es. I e n g t h ; kl + + ) { 

for (int p = 0; p < g et Nu mbe r Of PI a t f o r ms ( ) ; p + + ) { 

packageCombi nations[basicPackages.length + countjlpj = 

basi cPackages] k] [ pi + basi cPackages [ k 1 ][ p ] ; 
packageCombi nations! basicPackages. length + combinationHight + 
countjlpj = 2 ♦ has i c Pac kages 1 kj 1 pj + 
basi cPackagesj klj j p] ; 

packageCombi nations] basi cPackages. length + 2 ♦ combinationHight + 
countjlpj = basi cPackages] kj 1 pj + 2 » 
basi cPackagesj kl] j pj ; 

} 

count + + ; 

} 

} 

} 


II method to compute the package characteristics 
public void pa c ka g eC h a r a c t e r i s t i c s ( ) { 

for (int k = 0; k < n u mbe r Of Pa c ka g es ; k + + ) { 
double packageLatency = 0.0; 
double packageCost = 0.0; 
double pa c ka g e Pe r i s h a b i I i t y = 0.0; 
double packageLogistics = 0.0; 


} 


for (int p = 0; p < g et N u mbe r Of PI a t f o r ms ( ) ; p+ + ) { 

packageLatency += packageCombi nati ons 1 k j[ p j ♦ pI atformLatency [ p j 
packageCost += packageCombi nati ons j k jj p j 
packagePerishability += packageComb' 

pi at f or mPer 

packageLogistics += pac kageCombi nat 


pi at f or mCos1 1 p j 
nat i onsj kj 1 pj * 
s ha bi I i t y 1 pj ; 

onsjkjjpj ♦ platformLogisticsjpj 


packageCharacteri sti csj kj jOj 
packageCharacteristicslkijl] 
packageCharacteristicslkjl2i 
packageCharacteristicsikjlSl 


packageLatency; 
packageCost; 
packagePeri shabi I i ty; 
packageLogi sti cs; 


II method to compute the Package CDP 
public void packageCDP() { 

for (int c = 0; c < g et Nu mbe r Of Cl u s t e r ( ) ; C+ + ) { 

for (int t = 0; t < g et N u mbe r Of Ta r g e t s ( ) ; t + + ) { 

for (int k = 0; k < n u mbe r Of Pa c k a g es ; k+ + ) { 

int firstPlatformInPackage = 0; 
bool ean found = false; 
double f i r s t PI a t f 0 r ml n Pa c k a g e Ra t e = 0.0; 

double a I I PI a t f 0 r ml n Pa c ka g e Ra t e = 0.0; 

double ef f ec t i ve P r 0 po r t i 0 n Co ve r ed = 0.0; 
double areaPrime = 0.0; 
int number Of Platfor ms InPackage = 0; 


57 








for (int p = 0; p < getNu mb er Of Platforms!) 
if' .. 


(packageCombinationsIkllp] 
get PI at f or mRat e( p, c , t ) I = 
firstPlatformInPackage = p; 
fi rstPI atformi nPackageRate 
found = true; 


1 , 0 
0 , 0 ) 


P+ + ) { 
I f 0 u n d 


&& 


get PI at f or mRat e( p, c , t ) 


II 

I f 


this if for debugging 
(debugging Mode) { 
i f (c==0 && t ==0 && k= = 19) 
S y s t e m. 0 u t. p r i n 11 n ( " c 


{ 


+ " t = 


+ t + 


= " + c 

+ k + " p = " + p ) ; 

System, out. pri ntl n( "packageCombi nat i ons[ k 

[ p =" + p +" ] : " + 

packageCombinationsIkllp]) 


k = 


+ k+" 1 


} 


} 


all PI atfor ml nPackageRate + = 


packageCombinationsIkllp] 
get PI atfor mRat e( p, c , t ) 


} 


number Of Platfor ms InPackage += packageCombinationsIkllp] 


(fi rstPI atfor ml nPackageRate 
0 . 0 ) { 

effect! veProporti onCovered 
el se { 

effect! veProporti onCovered 


= = 0.0 && a I I PI at f 0 r ml n Pac kageRat e 
= 1 . 0 ; 

= f i r s t PI at f 0 r ml n Pa c kageRat e / 
al I PI atfor ml nPackageRate; 


a r e a P r I me 


(cl ust er Dat alc 1 12] 


effect! veProporti onCovered 
c I us t er Dat a I c 1 I 3 1 ) ; 
if (number Of Platfor ms InPackage == 1) 
packageCDPIklldlt] = 1.0 - Math. 

I a r e a P r I me ) ; 

} el se { 

packageCDPIklldlt] = 1.0 - Ma t h. ex p (- f I r s t PI a t f o r ml n Pa c ka g e Ra t e 
/ areaPrime * package enhFact); 


{ 

exp( ■ 


fi rstPI atfor ml nPackageRate 


} 

II 
I f 


this if for debugging 
(debugging Mode) { 


I f 


c == D 
System, 


&& 

0 u t 


k == 19) { 


= = 0 && 

println(" firstPlatformInPackage " + 

formatl dent! fi er.format(fi rstPI atformi nPackage) ) 
System, out. println("firstPlatfor ml nPackageRate " + 

formatRate. format(fi rstPI atformi nPackageRate) ) ; 
println("allPlatfor ml nPackageRate " + 

formatRate. format) al I PI atformi nPackageRate) ) ; 

println("effectiveProportionCovered " + 

formatProb. format) effect! veProporti onCovered) ) ; 
p rI n 11 n ( " a r e a P r I me :" + 

formatRate.format(areaPri me)); 
pri ntl n ( " pac kageCDPI k = " + k + d I c = " +c + " 1 11 =" +t +" 1 
" + formatCDP.format(packageCDPIk]ic]It])); 


S y s t e m. 0 u t. 
S y s t e m. 0 u t. 
System, out. 
System, out. 


} 

II probabilistic method to compute n choose k 
public int choose(int n, int kj { 

return fact(n) / (fact(k) ♦ fact(n ■ k)); 

} 

II probabilistic method to compute faculty of n 
public int f act ( I nt n) { 

int answer = 1; II Accumulate the product 


for (int I 
a n s we r 


1; I 


I + + ) { 


return a n s we r ; 

} 

II getter methods for instance variables 

public double getPackageCombinations(int indexi, int indexj) { 
return packageCombi nati onsi I ndexi ] I I ndexj ] ; 

} 


58 


public int getPackageCombinationsHight() { 
return packageCombi nati ons. I ength; 


public int getPackageCombinationsWidth!) { 
return packageCombi nati ons[ 0] . I ength; 


public double g et Pa c ka g eCh a r a c t e r i s t i c s ( i n t indexi, int index)) { 
return packageCharacteri sti cs[i ndexi ][i ndexj ]; 


public int g et Pa c ka g eCh a r a c t e r i s t i c s Hi g h t ( ) { 
return packageCharacteri sti cs.I ength; 


public int getPackageCharacteristicsWidth() { 
return packageCharacteri sti cs[0].I ength; 


public int g et Nu mbe r Of Pa c ka g es ( ) { 
return number Of Packages; 


public double get Pac kageCDP) i nt indexK, int i ndexC, int index!) { 
return packageCDP) i ndexK] [ i ndexC] [ i ndexT] ; 


public int g et Pa c ka g eCDP Hi g h t ( ) { 
return packageCDP. I ength; 


public int getPackageCDPWidth() { 
return packageCDP[0].length; 


public int g et Pa c ka g eCDP De pt h ( ) { 
return pac kageCDP) 0] [ 0] . I engt h; 

} 


} // end Platform 


F. SCENARIO 

package j SAM; 


/* 

* File; Scenario.java 

* Created; 25th November 2 0 0 3, 1 8;00 
*1 

I »» 

* ©author Thomas Doll 
*! 

i mport j ava. utiI. ♦; 
import java.io.*; 
import java.text.*; 

public class Scenario extends Packages implements Input Model Data { 

/ / cI ass const ant s 
II class variables 
II instance variables 
Random random; 

private int [j[j scenar i oDat a; / / [ Cl s u t e r j [ Ta r g et j 

private int [][][] t a g et Di s t r i b u t i o n ; / / [ E n e my Or d e r Of Ba 111 e ] [ Cl s u t e r j [ Ta r g e t j 

II class met hods 
II constructor met hods 

I *» 

♦ constructor for parameter inputstring. 

*/ 

public Scenario!) { 
super!); 

II this if for debugging 


59 




if (debugging Mode) { 

Sy s t e m. 0 uf. p r i n t i n ( " \ n. Debugging Output for Ciass Sc e n a r i oGe n e r a t o r 


} 

this. random = new Ra n d o mj s c e n a r i o Seed); 

t h i s. s c ena r i 0 Dat a = new i nt [ g et Nu mber Of Ci us t er ( ) ] [ get Nu mber Of Ta r get s ( ) ] ; 

scenari oDat a( ); 

t hi s. t aget Di St r i but i on = new i nt 

[ get NumberOf EOB( ) ] [ get NumberOfCi uster( ) ] [ get Nu mb er Of Targets) ) ] ; 
target Distribution)); 

} 

II instance methods 

II generates basic target distribution in ciusters 
pubiic void scenarioData)) { 

for ( i nt c=0; c <g et Nu mbe r Of C i u s t e r ( ) ; C+ + ) { 

for ( i nt t=0; t <g et Nu mbe r Of Ta r g et s ( ) ; t+ + ) { 

s c e n a r i 0 Da t a [ c 1 [ 1 1 = r a n d o m. n ex 11 n t ( ma x Nu mb e r Of Ta r g et s +1) ; 

} 

} 


II generates t a r get Di s t r i but i o n according enemyOr der Of Bat t i e Factor 

pubiic void t a r g et Di s t r i b u t i 0 n ( ) { 

for ( i nt e=0; e <g et Nu mbe r Of E OB) ) ; e+ + ) { 

for ( i nt c=0; c <g et Nu mbe r Of Ci u s t e r ( ) ; C+ + ) { 

for ( i nt t=0; t <g et N u mbe r Of Ta r g e t s ( ) ; t + + ) { 

doubie decisionVaiue = random, next Do ubie)); 
if (decisionVaiue <= eOB Factor[e]) { 

t aget Di s t r i but i on [ e] r c 1 [ 1 1 = s c ena r i oDat a [ c ] [ t ] ; 
} ei se { 

tagetDistribution[e][c][t] = 0; 

} 

} 

} 

} 

} 


II 
p u b 


p u b 


pub 


pub 


p u b 


pub 


pub 


getter methods for instance variabies 
'ic i nt get Scenar i oDat a) i nt i ndexC, i nt i ndexT) { 
return scenari oData) i ndexC] [ i ndexT] ; 


i c i nt get Scenar i oDat aFli ght ( ) 
return scenario Da ta.iength; 


p u b 


ic int getScenarioDataWidth)) 
return scenario Da ta[0].iength; 


ic int g et Ta g et Di s t r i b u t i 0 n( i n t indexE, int i ndexC, 
return tagetDi st ri buti on) i ndexE] [ i ndexC] [ i ndexT] ; 


ic int g et Ta g et Di s t r i b u t i 0 n Fli g h t ( ) 
return tagetDi stri buti on. iength; 


ic int getTagetDistributionWidth)) { 
return tagetDi stri buti on[0] . i ength; 

ic int g et Ta g et Di s t r i b u t i 0 n De pt h () { 
return tagetDistribution[0][0].iength; 


i nt i ndexT) { 


i c int get Number Of EOB) ) { 


} 


return eOB_ Factor, i ength; 


} II end Sensor 


G. GAMS_HANDLING 

package ] SAM; 


60 






/» 

♦ File: Ga ms Ha n d I i n g. j a va 

* Created: 25th November 2 0 0 3, 1 8:0 0 
*! 


I »» 

♦ ©author Thomas Doll 
*! 

i mp 0 r t j a V a. u 11 I . *; 
import java.io.*; 
import java.text.*; 


public class Gams Handling implements Input ModelData { 

//classconstants 

final static String sensorData = "ALLOCATION TABLE.CSV"; 

//classvariables 
II instance variables 
Scenario scenario; 
int[][] allocationTable; 

II class me t h 0 d s 
II constructor methods 

I»* 

* constructor for para me ter inputstring. 

*/ 

public Gams HandlingjScenario scenario) { 
this. scenario = scenario; 
this. allocationTable = new int 

[ scenari o. getNumberOfCI usterj ) j [ scenari o. getNu mb er Of Packages! ) j ; 

s t a r t GAMS ( ) ; 
allocationTable!); 

} 

II instance met hods 


II met hod to start GAMS 
public void start GAMS! ) { 
if ! r un Mode) { 

System, out. p r i n11 n ! " \ n - >St a r t GAMS" ) ; 

} 


String!) cmdArray = new String[5] 
c md A r r a y [ 0 ] 
c md A r r a y [ 1 ] = 
c md A r r a y [ 2 1 = 
c md A r r a y [ 3 ] = 
c md Ar r a y [ 4 ] = " L 0=2" ; 


C:\\Program Fi I es\\Gams21. l\\gams. exe"; 
C;\\] ava Cl asspath\\j SAM\\GamsModel . gms' 
WDI R=C;\\] ava Cl asspathWj SAM"; 

SCRDI R=C;\\] ava Cl asspathWj SAM"; 


t ry { 

Process gams Process = Runtime.getRuntime!).exec!cmdArray); 
g a ms P r oc es s. wa i t F o r ! ) ; 

} 

catch ! I OExcept ion e) { 
e. pri ntStackTrace! ) ; 

} 

catch ! I nt er r upt edExcept i on ex) { 
ex. pri ntStackTrace! ) ; 

} 

if ! r un Mode) { 

System, out. pri n 11 n ! " \ n - >E n d GAMS" ) ; 

} 


} 

II reads AllocationTable form Gams Lst File 


public void 
St r i ng 
Fi I eReader 
Buffered Reader 
St ri ngTokeni zer 


allocationTable!) { 
nput St ri ng; 
nput Fi I e; 
nput Uni t ; 
t k; 


try { 

inputFile = new FI I e Rea d e r ! s e n s o r Da t a ) ; 
inputUnit = new Buf f e r ed Rea d e r ! i n p u t F i I e ) ; 
inputstring = i nput Uni t. r eadLi ne! ) ; 


61 








inputstring = i nput Uni t. r eadti ne( ) ; 
inputstring = i nput Uni t. r eadti nej ) ; 

tk = new StringTokenizer(inputString, 

for (int c = 0; c < s c e n a r i o. g et Nu mbe r Of Ci u s t e r ( ) ; C+ + ) { 
inputstring = i n p u t Un i t. r e a d L i n e ( ) ; 
tk = new StringTokenizer(inputString, 
for (int k = 0; k < s c e n a r i o. n u mbe r Of Pa c ka g es ; k+ + ) { 
if(k< = l) { 

tk.nextToken(); 

} ei se { 

Doubie number = new Do u b i e ( Do u b i e. pa r s e Do u b i e ( t k. n e x t To ke n ( ) ) ) 
a i i ocat i 0 nTabi e[c 1 [ k 1 = number. i ntVai ue ( ) ; 

} 

} 

} 

inputUnit.ciosel); 

} catch ( Fi i eNot FoundExcept i on e) { 

System, out.printin(e); 
return; 

} catch ( i OExcepti on e) { 

System, out.printin(e); 
return; 

} 

} 


II getter methods for instance variabies 
pubiic int g et Ai i oc a t i 0 nTa b i e ( i n t i ndexC, int indexK) { 
return aiiocationTabie[indexC][indexK]; 

} 

pubiic int g et Ai i oc a t i 0 nTa b i e Fli g h t ( ) { 
return aiiocationTabie.iength; 

} 


pubiic int getAiiocationTabieWidth!) { 
return aiiocationTabie[0].iength; 

} 


} II end Gams_Flandi i ng 


H, OUTPUTGAMSFILES 

package j SAM; 


/* 

* Fiie; Output GamsFiies.java 

* Created; 25tli November 2 0 0 3, 1 8;00 
*1 

I »» 

* ©author Thomas Doi i 
*! 


mpo r t j a va. utii. ♦; 
mport java.io.*; 
mport java.text.*; 


pubiic ciass Output GamsFiies impiements input ModeiData { 

//ciassconstahts 

finai static String t a r g et Di s t r i b u t i o n = "TARGET Di STRi BUTi ON. CSV" ; 

finai static String pac kageCombi nat i ons = "PACKAGE COMBi NATi ONS. CSV" ; 

finai static String pa c ka g eCh a r a c t e r i s t i c s = "PACKAGE CHARACTERi STi CS. CSV" ; 

finai static String packageCDP = "PACKAGE CDP.CSV"; 


II ciass variabies 
II instance variabies 
Scenario scenario; 


II ciass met hods 
II constructor methods 

I»* 

♦ constructor for parameter inputstring. 







♦/ 

public Output GamsFiles(Scenario scenario) { 
if (run Mode) { 

Sy s t e m. 0 u t. p r i n 11 n ( " \ n->Ge n e r a t e GAMS Include Files"); 

} 

this. scenario = scenario; 
t ry { 

makeTargetDistributionl); 
makePackageCDP) ); 
makePackageCharacteri sti cs( ) ; 
makePackageCombi nat i ons( ) ; 

} 

catch (I OExcept ion ex) { 
ex. pri ntStackTrace( ) ; 

} 


II instance methods 

II method to create the textfile TARGET Dl STRI BUTI ON. CSV 
public void ma keTa r g et Di s t r i b u t i 0 n ( ) throws lOException { 

FileWriter filewriter = new F i I e Wr i t e r ( t a r g et Di s t r i b u t i o n ) ; 

Buffered Writer buffered Writer = new Buffered Writer(file writer); 

Pri ntWr iter pri ntWr iter = new Pri ntWriter(bufferedWr iter); 

String out put Li ne = new String)); 

0 u t p u t L i n e = " d u mmy, d u mmy" ; 

for ( i nt c=0; c <s c e n a r i o. g et Nu mbe r Of Cl u s t e r ( ) ; C+ + ) { 

0 u t p u t L i n e + = ( ", C" + ( c + 1 ) ) ; 

} 

p r i n t Wr i t e r. p r i n t ( 0 u t p u t Li n e + " \ n" ) ; 

for ( i nt e=0; e <s c e n a r i o. g et Nu mbe r Of EOB( ) ; e+ + ) { 

for ( i nt t = 0; t < s c e n a r i o. g et Nu mb e r Of Ta r g et s ( ) ; t + + ) { 

0 u t p u t L i n e = ""; 

for ( i nt c = 0; c < s c e n a r i o. g et Nu mbe r Of Cl u s t e r ( ) ; C+ + ) { 

0 u t p u t L i n e + = ( ", " + 

formatl denti fi er2. for mat) scenari o. getTagetDi stri buti on 
( e, c, t )) ) ; 

} 

pr i nt Wr i t er. pr i nt ( " T" + (t+1) + ".EOB" + (e+1)); 

p r i n t Wri t e r. p r i n t ( 0 u t p u t L i n e + " \ n" ) ; 

} 

} 

p r i n t Wr i t e r. c I 0 s e ( ) ; 
if (run Mode) { 

System, out. pri ntl n( " TARGET DI STRI BUTI ON. CSV" ) ; 

} 


II method to create the textfile PACKAGE COMBI NATI ONS. CSV 
public void ma ke Pa c k a g eCo mb i n a t i 0 n s ( ) throws lOException { 

Filewriter filewriter = new FileWriter(packageCombinations); 

Buffered Writer buffered Writer = new Buffered Writer(file writer); 

Pri ntWr iter pri ntWr iter = new Pri ntWriter(bufferedWr iter); 

String outputLine = new String)); 

0 u t p u t L i n e = " d u mmy" ; 

for ( i nt p = 0; p < s c e n a r i o. g e t Nu mbe r Of PI a t f o r ms ( ) ; p+ + ) { 
outputLine += (",P" + (p+1)); 

} 

p r i n t Wr i t e r. p r i n t ( 0 u t p u t Li n e + " \ n" ) ; 

for ( i nt k=0; k <s c e n a r i o. g et Nu mbe r Of Pa c k a g es ( ) ; k+ + ) { 

outputLine = "" ; 

for ( i nt p = 0; p < s c e n a r i o. g et Nu mb e r Of PI a t f o r ms ( ) ; p+ + ) { 
outputLine + = ( ", " + 

formatldentifier2.format(scenario.getPackageCombinations(k, p))); 

} 

p r i n t Wr i t e r. p r i n t ( " k" + ( k + 1 ) ) ; 

p r i n t Wr i t e r. p r i n t ( 0 u t p u t Li n e + " \ n" ) ; 

} 

p r i n t Wr i t e r. cI 0 s e ( ) ; 
if (run Mode) { 

System, out. pri ntl n( " PACKAGE COMBI NATI ONS. CSV" ) ; 

} 


II method to create the textfile PACKAGECHARACTERI STI CS. CSV 
public void ma ke Pa c k a g eCh a r a c t e r i s t i c s ( ) throws lOException { 

Filewriter filewriter = new FileWriter(packageCharacteristics); 
Buffered Writer buffered Writer = new Buffered Writer(file writer); 
Pri ntWr iter pri ntWr iter = new Pri ntWriter(bufferedWr iter); 


63 


string out put Li ne = new String!); 

out put Line = " d u mmy, L a t e n c y, Cos t, Pe r i s h a b i i i t y, Log i s t i c s" ; 

p r i n t Wr i t e r. p r i n t ( 0 u t p u t Li n e + " \ n" ) ; 

for ( i nt k=0; k <s c e n a r i o. g et Nu mbe r Of Pa c k a g es ( ) ; k+ + ) { 

0 u t p u t L i n e = "" ; 

for (int a = 0; a < scenario.getPackageCharacteristicsWidth(); a+ + ) { 

0 u t p u t L i n e + = ( ", " + 

formatCharacteri st i cs. for mat) scenari o. getPackageCharacteri sti cs( k, a) ) ) ; 

} 

p r i n t Wr i t e r. p r i n t ( " k" + ( k + 1 ) ) ; 

p r i n t Wr i t e r. p r i n t ( 0 u t p u t Li n e + " \ n" ) ; 

} 

p r i n t Wr i t e r. ci 0 s e ( ) ; 
if (run Mode) { 

System, out. pri nti n( " PACKAGE CHARACTERi STi CS. CSV" ) ; 

} 

} 

II method to create the textfiie PACKAGE_CDP. CSV 
pubiic void ma ke Pa c k a g eCDP ( ) throws iOException { 

FiieWriter fiiewriter = new F i i e Wr i t e r ( p a c ka g eCDP ) ; 

Buffered Writer buffered Writer = new Buffered Writer(fiie writer); 

Pri ntWr iter pri ntWr iter = new Pri ntWriter(bufferedWr iter); 

String out put Li ne = new String)); 

0 u t p u t L i n e = " d u mmy, d u mmy" ; 

for (int k=0; k <s c e n a r i o. g et Nu mbe r Of Pa c k a g es ( ) ; k+ + ) { 
outputLine += (",k" + (k+1)); 

} 

p r i n t Wr i t e r. p r i n t ( 0 u t p u t Li n e + " \ n" ) ; 

for (int c=0; c <s c e n a r i o. g et Nu mbe r Of Ci u s t e r ( ) ; C+ + ) { 

for (int t=0; t <s c e n a r i o. g et Nu mbe r Of Ta r g et s ( ) ; t+ + ) { 

outputLine = ""; 

for (int k=0; k <s c e n a r i o. g et Nu mb e r Of Pa c ka g es ( ) ; k+ + ) { 

outputLine += ("," + formatProb2.format(scenario.getPackageCDP 
(k, c, t))); 

} 

pr i nt Wr i t er. pr i nt ( " C" + (c+1) + ".T" + (t+1)); 

p r i n t Wri t e r. p r i n t ( 0 u t p u t L i n e + " \ n" ) ; 

} 

} 

p r i n t Wr i t e r. c i 0 s e ( ) ; 
if (run Mode) { 

Sy s t e m. 0 u t. p r i n t i n ( " PACKAGE CDP.CSV"); 

} 


} II end Output_GamsFi(es 


I. OUTPUT COMMAND 

package j SAM; 


I* 

♦ Fiie; Output Command, java 

♦ Created; 25tli November 2 0 0 3, 1 8;00 
*1 

I »» 

♦ ©author Thomas Doi i 
*1 

i mport j ava. utii. ♦; 
import java.io.*; 
import java.text.*; 


pubiic ciass Output Command impiements input ModeiData { 
//ciassconstants 
II ciass variabies 
II instance variabies 
Scenario scenario; 

Gams Flandiing gams; 


II ciass met hods 
II constructor met hods 


64 



I »♦ 

♦ constructor for para me ter i 
♦/ 

public Output Command! Scenar i ( 
this. scenario = scenario; 
t h i s. g a ms = g a ms ; 


nput St ri ng. 

scenario, Gams_Handling gams) 


{ 


if (print Verbose) { 

/ / pr i nt Cl ust er Dat a( ) ; 

II pri ntPI atformSensorl nformati on( ) ; 

//printPictureDimensions(); 

//printPictureDistanciesj); 

// pr i nt Sensor Dat a(); 

pr i nt RangeDat a( ) ; 

pri ntPI osCorrectedDataj ) ; 

//printPictureProbabilityl); 

pri ntSensorSweepWi dth( ) ; 

pri ntPI at f or mSweepWi dt h( ) ; 

//printTimeOnStationj); 

printPackageCombinations(); 

//printPlatformCDP(); 

//pri ntPI at f or mRat e( ) ; 

II pri ntPackageCharacteri sti cs( ) ; 
pri ntPackageCDP( ) ; 
//printScenarioDatal); 

//printTarget Distribution)); 

//printAllocationTableFull(); 

printAllocationTable)); 

} el se { 

printAllocationTable(); 

} 

} 


II instance methods 


II output for data sets in Input ModelData 
public void pr i nt Cl ust er Dat a( ) 


System, out.print) "\n. Clusters and Target Data ■■■■"); 

System, out.print) "\n X-Coord Y-Coord EW-Dime NS-Dime"); 

S y s t e m. 0 u t. p r i n t ( " \ n" ) ; 

for (int c = 0; c < s c e n a r i o. g et Nu mbe r Of Cl u s t e r ( ) ; C+ + ) { 

System.out.print) "C" + formatldentifier.format(c+l)); 
for (int s = 0; s <c I u s t e r Da t a [ 0 ] . I e n g t h ; s+ + ) { 

System, out. pri nt(formatCoord.format(cl usterData[c][s])); 

} 

S y s t e m. 0 u t. p r i n t ( " \ n" ) ; 

} 

} 

II output for data sets in Sensor 

public void printPlatformSensorInformation)) { 

System, out.println("\n . Platform Sensor Information . \n"); 

Syst em. out. pr i nt I n( " Name of the data file;\t" + s c e n a r i o. g et Se n s o r Da t a F i I e ( ) ) ; 
System, out.printlnj" Number of Platforms ;\t" + scenario.getNu mb er Of Platforms))); 
System, out.printlnj" Number of Targets ;\t" + scenario.getNu mb er Of Targets))); 


System, out.printin)" Platform Sensor Table;\tPlatform Senors"); 
for (int p = 0; p < s c e n a r i o. g et Nu mbe r Of Se n s o r s L e n g t h ( ) ; p+ + ) { 

S y s t e m. 0 u t. p r i n 11 n ( " \ t \ t \ t" + ( p + 1 ) + " \ t " + 

scenari o. getNu mb er Of Sensors) p) ) ; 


} 


public void pr i nt Sensor Dat a) ) { 

S y s t e m. 0 u t. p r i n 11 n ( " \ n. 

- - Sensor Dat a 


I ' 

System, out.printin) "PI Se Tg . This part of the array 

shows probabilities of detection at a specific range . 

.\ n" ) ; 

for (int p = 0; p < s c e n a r i o. g et Nu mbe r Of PI a t f o r ms ( ) ; p + + ) { 

for (int s = 0; s < s c e n a r i o. g et Nu mb e r Of Se n s o r s ( p ) ; s+ + ) { 

for (int t = 0; t < s c e n a r i o. g et Nu mbe r Of Ta r g et s ( ) ; t + + ) { 

System, out.print(formatldentifier.for mat(p+l) + 
formatldentifier.format(s+l) + 
f or mat I dent i f i er. f or mat ( t +1) ) ; 

for (int index = 0; index < scenar i o. get Sensor Dat aSi ze( ) ; index+ + ) 
System, out. pri nt(formatProb. for mat 

( scenari o. getSensorDat a) p, s, t , i ndex) ) ) ; 


} 


{ 


65 














} 


S y s t e m. 0 u t. p r i n t ( “ \ n" ) ; 


} 

} 

} 

public void pr i nt RangeDat a( ) { 

S y s t e m. 0 u t. p r i n 11 n ( " \ n. 

- - Ra ngeDat a 


I ' 

System, out.println(" PI Se Tg . This part of the array 

shows probabilities of detection at a specific range . 

.\ n" ) ; 

for ( i nt p = 0; p < s c e n a r i o. g e t Nu mbe r Of PI a t f o r ms ( ) ; p+ + ) { 
for ( i nt s = 0; s < s c e n a r i o. g et Nu mb e r Of Se n s o r s ( p ) ; s+ + ) { 
for ( i nt t = 0; t < s c e n a r i o. g et Nu mbe r Of Ta r g et s ( ) ; t + + ) { 

System, out.print(formatldentifier.for mat(p+l) + 

formatldentifier.format(s+l) + formatldentifier.format(t+l)); 
for ( i nt index = 0; index < s c e n a r i o. g et Ra n g e Da t a S i z e( ) ; index+ + ){ 
System, out. pri nt(formatRange. for mat 
( scenari o. getRangeData( p, s, t, i ndex) ) ) ; 

} 

S y s t e m. 0 u t. p r i n t ( " \ n" ) ; 

} 

} 

} 

} 

public void p r i n t PI os Co r r ec t ed Da t a ( ) { 

S y s t e m. 0 u t. p r i n 11 n ( " \ n. 

PLOS Corrected Data . 

." ) : 

System, out.println(" PI Se Tg . This part of the array 

shows probabilities of detection at a specific range . 

.\ n") ; 

for ( i nt p = 0; p < s c e n a r i o. g e t Nu mbe r Of PI a t f o r ms ( ) ; p+ + ) { 

for ( i nt s = 0; s < s c e n a r i o. g et Nu mb e r Of Se n s o r s ( p ) ; s+ + ) { 

for ( i nt t = 0; t < s c e n a r i o. g et Nu mbe r Of Ta r g et s ( ) ; t + + ) { 

System, out.print(formatldentifier.for mat(p+l) + 
formatldentifier.formatjs+l) + 
f or mat I dent i f i er. f or mat ( t +1) ) ; 

for ( i nt index = 0; index < s c e n a r i o. g et Ra n g e Da t a S i z e( ) ; index+ + ) { 
System, out. pri nt(formatProb. for mat 

( scenari o. get PI osCor rectedData( p, s, t, i ndex) ) ) ; 

} 

S y s t e m. 0 u t. p r i n t ( “ \ n" ) ; 

} 

} 

} 

} 

public void p r i n t P i c t u r e P r 0 ba b i I i t y ( ) { 

S y s t e m. 0 u t. p r i n 11 n ( " \ n - - - Picture P r o b 

System, out.printlnj" PI Se Tg CProb SProb\n"); 

for ( i nt p = 0; p < s c e n a r i o. g et Nu mbe r Of UAV( ) ; p+ + ) { 

for ( i nt s = 0; s < s c e n a r i o. g et Nu mbe r Of Se n s o r s ( p ) ; s+ + ) { 

for ( i nt t = 0; t < s c e n a r i o. g et Nu mbe r Of Ta r g et s ( ) ; t + + ) { 

System, out. print(forma tidentifier.for mat(p+l) + 
formatldentifier.formatjs+l) + 
for ma tidentifier.for matjt+l) + 

formatProb.format(scenario.getCenterPictureProbability(p,s,t)) + 
formatProb. formatj scenari o. getSi dePi ctureProbabi I i ty( p, s, t) ) ) ; 

S y s t e m. 0 u t. p r i n t ( “ \ n" ) ; 

} 

} 

} 

} 

public void printPictureDimensions() { 

Syst em. out. pr i nt I n( " \ n. Picture Dimensions ----"): 

System, out.printlnj "PI Se CentWCentL SideWSideL\n"); 
for (int p = 0; p < s c e n a r i o. g e t Nu mbe r Of UAV( ) ; p+ + ) { 

for (int s = 0; s < s c e n a r i o. g et Nu mb e r Of Se n s o r s ( p ) ; s+ + ) { 

System, out.print(forma tidentifier.forma t(p + 1) + 
for ma tidentifier.for mat(s + 1) + 

for mats weep Width.for matjscenario.getCenterPictureWidth(p, s)) + 
for mats weep Width.for matjscenario.getPictureLength(p, sj) + 
for mats weep Width.for matjscenario.getSidePictureWidth(p, s)) + 
formatSweepWidth.formatjscenario.getPictureLength(p, s))); 


66 




















S y s t e m. 0 u t. p r i n t ( “ \ ( 1 " ) ; 


} 

} 

public void p r i n t P i c t u r e Di s t a n c i es ( ) { 

System, out.println("\n . Picture Distancies 

System, out.println(" PI Se shorC longC shorS longS\n"); 
for ( i nt p = 0; p < s c e n a r i o. g et Nu mbe r Of UAV( ) ; p+ + ) { 

for ( i nt s = 0; s < s c e n a r i o. g et Nu mb e r Of Se n s o r s ( p ) ; s+ + ) { 

System, out.print(formatldentifier.forma t(p + 1) + 
formatldentifier.format(s + 1) + 

for mats weep Width.for matjscenario.getShortCPictDistlp, s)) + 
for mats weep Width.for matjscenario.gettongCPictDistlp, s)) + 
for mats weep Width.for matjscenario.getShortSPictDistlp, s)) + 
formatSweepWidth.formatjscenario.gettongSPictDistlp, s))); 

S y s t e m. 0 u t. p r i n t ( " \ n" ) ; 

} 

} 

} 

public void printSensorS weep Width!) { 

S y s t e m. 0 u t. p r i n 11 n ( " \ n - - S e S we e p W - -" ) ; 

System, out. printlnj" PI Se Tg Sweep\n"); 

for ( i nt p = 0; p < s c e n a r i o. g et Nu mbe r Of PI a t f o r ms ( ) ; p + + ) { 

for ( i nt s = 0; s < s c e n a r i o. g et Nu mb e r Of Se n s o r s ( p ) ; s+ + ) { 

for ( i nt t = 0; t < s c e n a r i o. g et Nu mbe r Of Ta r g et s ( ) ; t + + ) { 

System, out.print(formatldentifier.for mat(p+l) + 
formatldentifier.format(s+l) + 
formatldentifier.formatjt+l) + 
f or mat SweepWi dt h. f or mat 
( scenar i o. getSensorSweepWi dt h( p, s, t ) ) ) ; 

S y s t e m. 0 u t. p r i n t ( " \ n" ) ; 

} 

} 

} 

} 

II output for data sets in Platform 
public void printPlatformS weep Width!) { 

System, out.println!"\n . Platform Sweep Width New. 

■"); 

System, out. println!"Tgt01 Tgt02 Tgt03 Tgt04 TgtOS Tgt06 Tgt07 TgtOS Tgt09 
Tgt 10\n" ) ; 

for !int p = 0; p < s c e n a r i o. g e t PI a t f o r mS wee p Wi d t h Hi g h t ! ) ; p+ + ) { 

for !int t = 0; t < scenario.getPlatformS weep Width Width!); t+ + ) { 

System, out. pri nt!formatRange. for mat! scenari o. get PI atformSweepWi dth! p, 
t) ) ) ; 

} 

S y s t e m. 0 u t. p r i n t ! " \ n" ); 

} 


public void p r i n t Ti meOn St a t i 0 n ! ) { 

System, out.println!"\n . Platform Ti me on Station . 

System, out. pri ntln!"Ciu01 Clu02 Clu03 Clu04 CluOS Clu06 Clu07 CluOB Clu09 
Cl ul0\ n") ; 

for !int p = 0; p < scenario.getTi me OnStationHight!); p + + ) { 
for ! i nt c = 0; c < c I u s t e r Da t a. I e n g t h ; C+ + ) { 

System, out. pri ntfformatTi me. format! scenari o. getTi meOnStati on! P. c) ) ) ; 

} 

S y s t e m. 0 u t. p r i n t ! " \ n" ); 

} 


public void printPlatfor mRa t e ! ) { 

System, out.println!"\n. Platform Rate . "); 

System, out.printlnj "Cl Tg PlatfOl Platf02 Platf03 Platf04 PlatfOS Platf06\n"); 
for !int c = 0; c < s c e n a r i o. g et Nu mbe r Of Cl u s t e r ! ) ; C+ + ) { 

for ! i nt t = 0; t < s c e n a r i o. g et Nu mb e r Of Ta r g et s ! ) ; t + + ) { 

System, out.printfformatldentifier.forma t!c + 1) + 
f 0 r ma 11 d e n t i f i e r. f 0 r ma t i t + 1 ) ) ; 

for ! i nt p = 0; p < s c e n a r i o. g et Nu mbe r Of PI a t f o r ms ! ) ; p+ + ) { 

System, out. pri ntfformatRate. for mat! scenari o. getPI atformRate! p, c, 
t) )) ; 

} 

S y s t e m. 0 u t. p r i n t ! “ \ n" ) ; 

} 

> 


67 











public void printPlatformCDP() { 

System, out.println("\n . Platform CDP . "); 

System, out.printlnj" Cl Tg Platl Plat2 Plat3 Plat4 Plats Plat6\n"); 
for (int c = 0; c < s c e n a r I o. g et Nu mbe r Of Cl u s t e r ( ) ; C+ + ) { 

for (int t = 0; t < s c e n a r I o. g et Nu mb e r Of Ta r g et s ( ) ; t + + ) { 

System, out.print(formatldentifier.forma t(c + 1) + 
f 0 r ma 11 d e n 11 f I e r. f 0 r ma t ( t + 1 ) ) ; 

for (int p = 0; p < s c e n a r I o. g et Nu mbe r Of PI a t f o r ms ( ) ; p+ + ) { 

System, out.print(formatCDP.for mat(scenario.getPlatformCDP(p, c, t))); 

} 

S y s t e m. 0 u t. p r I n t ( “ \ n" ) ; 

} 

} 

} 

II output for data sets in Package 
public void printPackageCombinations() { 

System, out.println("\n---- Package Comb . "); 

System, out.printlnj" PI P2 P3 P4 PS P6\n"); 

for (int k = 0; k < s c e n a r i o. g e t Pa c ka g eCo mb i n a t i o n s Hi g h t ( ) ; k+ + ) { 

S y s t e m. 0 u t. p r i n t ( " P a" + f o r ma t N u mb e r. f o r ma t ( k + 1 ) ) ; 

for (int p = 0; p < s c e n a r i o. g et Nu mb e r Of PI a t f o r ms ( ) ; p+ + ) { 

if (p < basicPackageslOj.length) { 

if (scenario.getPackageCombinations(k, p) 1= 0) { 

System, out. pri nt(formatl denti fi er. for mat 

(scenario.getPackageCo mb inations(k, p))); 

} el se { 

S y s t e m. 0 u t. p r i n t ( " - - " ) ; 

} 

} else { 

System, out. pri nt(formatCharacteri sti cs. for mat 

i scenari o. getPackageCo mb i nati ons( k, p) ) ) ; 

} 

} 

S y s t e m. 0 u t. p r i n t ( “ \ n “ ) ; 

} 

} 

public void p r i n t Pa c ka g eCh a r a c t e r i s t i c s ( ) { 

System, out.println("\n--- Package Char ----"); 

System, out.printlnj" Lat Cos Per Log\n"); 

for (int k = 0; k < s c e n a r i o. g et Pa c ka g eC h a r a c t e r i s t i c s Hi g h t ( ) ; k + + ) { 

Syst em. out. pr i nt ( " Pa" + f or mat Number. f or mat ( k + 1)); 

for (int a = 0; a < scenario.getPackageCharacteristicsWidth(); a+ + ) { 

System, out. pri nt(formatCharacteri sti cs. for mat 

j scenari o. getPackageCharacteri sti cs( k, a) ) ) ; 

} 

S y s t e m. 0 u t. p r i n t ( " \ n" ); 

} 

} 

public void pr i nt Pac kageCDP( ) { 

System, out. pri nt("\n . Package CDP . "); 

for ( i nt i =6; i < s c e n a r i o. g et Nu mbe r Of Pa c ka g es ( ) ; i + + ) { 

S y s t e m. 0 u t. p r i n t ( " ." ) ; 

} 

S y s t e m. 0 u t. p r i n t ( " \ n CI T g " ) ; 

for ( i nt i =0; i < s c e n a r i o. g et Nu mbe r Of Pa c ka g es ( ) ; i + + ) { 

Syst em. out. pr i nt ( " Pa" + f or mat Number. f or mat ( i + 1)); 

} 

S y s t e m. 0 u t. p r i n 11 n ( " \ n" ) ; 

for (int c = 0; c < s c e n a r i o. g e t Nu mbe r Of Cl u s t e r ( ) ; C+ + ) { 

for (int t = 0; t < s c e n a r i o. g et Nu mb e r Of Ta r g et s ( ) ; t + + ) { 

System, out.print(formatldentifier.forma t(c + 1) + 
f 0 r ma 11 d e n t i f i e r. f 0 r ma t j t + 1 ) ) ; 
for (int k = 0; k < s c e n a r i o. g et Nu mbe r Of Pa c k a g es ( ) ; k+ + ) { 

System, out.print(formatCDP.for mat(scenario.getPackageCDP(k, c, t))); 

} 

S y s t e m. 0 u t. p r i n t ( " \ n" ) ; 

} 

} 


II output for data sets in Sc e n a r i oGe ne r a t o r 
public void pr i nt Scenar i oDat a( ) { 

Syst em. out. pr i nt I n( " \ n. Scenario Data . "); 

Syst em. out. pr i nt I n( " Cl TOl T02 T03 T04 T05 T06 T07 T08 T09 T10\n"); 
for (int c = 0; c < s c e n a r i o. g et Nu mbe r Of Cl u s t e r ( ) ; C+ + ) { 


68 












System, out.print(formatldentifier.forma t(c + 1)); 

for ( i nt t = 0; t < s c e n a r i o. g et Nu mb e r Of Ta r g et s ( ) ; t + + ) { 

System, out.print(formatNu mb er.for mat(scenario.getScenario Da ta(c, t))); 

} 

S y s t e m. 0 u t. p r i n t ( " \ n" ) ; 

} 

} 

public void p r i n t Ta r g et Di s t r i b u t i 0 n ( ) { 

for (int e = 0; e < s c e n a r i o. g e t Nu mbe r Of EOB( ) ; e+ + ) { 

System, out.println("\n. Target Distribution EOB" + e + 1 + " . 

") ; 

Syst em. out. pr i nt I n( " Cl TOl T02 T03 T04 T05 T06 T07 T08 T09 T10\n"); 

for (int c = 0; c < s c e n a r i o. g et Nu mb e r Of Cl u s t e r ( ) ; C+ + ) { 

System, out.print(formatldentifier.forma t(c + 1)); 

for (int t = 0; t < s c e n a r i o. g et Nu mbe r Of Ta r g et s ( ) ; t + + ) { 

System, out. pri nt(formatNumber. format(scenari o. getTagetDi stri buti on(e, 
c, t))); 

} 

S y s t e m. 0 u t. p r i n t ( " \ n" ) ; 

} 

} 

} 

public void p r i n t Al I oc a t i 0 nTa b I e F u I I ( ) { 

System, out.print("\n. AllocationTable . "); 

for (int i = 14; i < s c e n a r i o. g et Nu mbe r Of Pa c ka g es ( ) ; i + + ) { 

S y s t e m. 0 u t. p r i n t (“---“) ; 

} 

S y s t e m. 0 u t. p r i n t ( " \ n CI " ) ; 

for (int p = 0; p < s c e n a r i o. g et Nu mbe r Of Pa c ka g es ( ) ; p + + ) { 

S y s t e m. 0 u t. p r i n t ( "" + f o r ma 11 d e n t i f i e r. f o r ma t ( p + 1 ) ) ; 

} 

S y s t e m. 0 u t. p r i n 11 n ( " \ n" ) ; 

for (int c = 0; c < s c e n a r i o. g et Nu mbe r Of Cl u s t e r ( ) ; C+ + ) { 

System, out.print(formatldentifier.forma t(c + 1)); 
for (int k = 0; k < s c e n a r i o. g et Nu mb e r Of Pa c ka g es ( ) ; k+ + ) { 
if (gams.getAllocationTable(c, k) 1=0) { 

System, out. pri nt(formatl denti fi er.format(gams. getAI I ocati onTabI e(c, 
k) ) ) ; 

} else { 

S y s t e m. 0 u t. p r i n t ( " - ■ " ) ; 

} 

} 

S y s t e m. 0 u t. p r i n t ( " \ n" ); 


public void p r i n t Al I oc a t i 0 nTa b I e( ) { 

ArrayList arrayList = new ArrayList(); 
for (int k = 0; k < s c e n a r i o. g et Nu mbe r Of Pa c ka g es ( ) ; k + + ) { 
for (int c = 0; c < s c e n a r i o. g e t Nu mbe r Of Cl u s t e r ( ) ; C+ + ) { 

if (gams.getAllocationTable(c, k) 1= 0 && larrayList.contains(new Integer(k)) 

) { 

arrayList. add(new Integer(k)); 

} 

} 

} 


S y s t e m. 0 u t. p r i n t ( " \ n" ) ; 

for (int a = 0; a < ( a r r a y L i s t. s i z e ( ) - 2 ) / 2 ; a+ + ) { 

S y s t e m. 0 u t. p r i n t ( “ -“ ) ; 

} 

S y s t e m. 0 u t. p r i n t ( " - Allocations - " ) ; 

for (int a = 0; a < ( a r r a y L i s t. s i z e ( ) ■ 2 ) / 2 ; a+ + ) { 

S y s t e m. 0 u t. p r i n t ( “ -“ ) ; 

} 

S y s t e m. 0 u t. p r i n t ( " \ n " ) ; 

for (int a = 0; a < a r r a y L i s t. s i z e ( ) ; a+ + ) { 

S y s t e m. 0 u t. p r i n t ( " P" + 

formatldentifier.format(((lnteger)arrayList.get(a)).intValue() + 1)); 

} 

S y s t e m. 0 u t. p r i n t ( " \ n" ) ; 

for (int c = 0; c < s c e n a r i o. g e t Nu mbe r Of Cl u s t e r ( ) ; C+ + ) { 

System.out.print) "C" + formatldentifier.format(c+l)); 
for (int a = 0; a < a r r a y L i s t. s i z e ( ) ; a + + ) { 

i f (gams. getAI I ocati onTabI e(c, ( (I nteger)arrayLi st. get(a) ) . i ntVal ue( ) ) 

I = 0 && 


69 







gams. getAI I ocati onTabI e 

( c, ( ( I nt eg er ) a r r ay L i s t. get ( a ) ) . i nt Va I ue ( ) ) < 10) { 

System, out. pri nt(formatNumber2. format(gams. getAI I ocati onTabI e(c, 
((lnteger)arrayList.get(a)).intValue()))); 

} else if (gams.getAllocationTable(c, 

i(lnteger)arrayList.get(a)).intValue()) 

1= 0 && ga ms. get Al I oc a 11 0 nTa bI e ( c , 

((I nteger ) arrayLI st. get ( a )).I ntVaI ue ()) >= 10) { 

System, out. pri nt(formatNumber3. format(gams. getAI I ocati onTabI e(c, 
((lnteger)arrayList.get(a)).intValue()))); 

}el se { 

S y s t e m. 0 u t. p r i n t ( " - - - " ) ; 

} 

} 

S y s t e m. 0 u t. p r i n t ( “ \ n “ ); 

} 

} 

} II end Output _ Co mma n d 


70 



INITIAL DISTRIBUTION LIST 


1. Dudley Knox Library 

Naval Postgraduate Sehool 
Monterey, California 

2. LTC Thomas Cioppa 

TRADOC Analysis Center Monterey 
Monterey, California 

3. Maj Donovan Phillips 

TRADOC Analysis Center Monterey 
Monterey, California 

4. Professor W. Matthew Carlyle 

Department of Operations Researeh 
Monterey, California 


71 



