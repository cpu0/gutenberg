AD-A228 480 





SfIS file cqpy 


d) 

Document No. 2020-001 
30 June 1990 


User's Manual for A Prototype Binding of ANSI-Standard 
SQL to Ada Supporting the SAME Methodology 

for the 

Software Technology for Adaptable, Reliable Systems 

(STARS) Program 


Contract No. F19628-88-D-0032 
Task IR67 - Prototype Binding of ANSI-Standard SQL 

CDRL Sequence No. 2020 




i 


I 



Prepared lor; 


Electronic Systems Division 
Air Force Systems Command, USAF 
Hanscom AFB, MA 01731-5000 


“ iWATiiApfrjri 


//fifxvrwl Irv pnbllo 

pWdbiitlein Uttllmbeti . 


Prepared by: 

iBM Federal Sector Division U ^) 
BOO North Frederick Avenue 
Oaithorsburg, MD 20879 




REPORT DOCUMENTATION PAGE 

-; - --1 

loir.. j 

OMil Vo o.w-otsa 

} . . f ^ ‘ n? -'"Tiat uC r ?• » ir 5 : .% t-.r--'' i’ -i* i j'j... ^ il- • • * ■ • ■ r- •• . i m -• 

1 ,, . ’r 0 A"ir- It'. 2 A ^CJ ••’O • ■ • .r. ; . » ^. r- • •- g ■ S ■ .A o • ^ ' 

' , . .'1 •" ■, 

:. . .-f.Tv.r 

i '. AGENCY USE ONLY (Leave blank) 

\ , . M, 

2. REPORT DATE j 3, REPORT TYPE AND DATES COVERED j 

June 30, 1990 f Final j 


4 TITLL AND SUBTITLE 

User's Manual for a Prototype Binding of ANSI-Standard 
SQL to Ada Supporting the SAME Methodology 

6, AUTHOR(S) 

S. Phillips 


I 'j. FUNDING NUMBERS 

' C: F19628-88-D-0032 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRFSS(ES; 

IBM Federal Sector Division 
800 N. Frederick Avenue 
Gaithersburg, MD 20879 


[8. PFIirOiLvIiNG ORGANIZATION 
i REPORT NUMBER 


9. SPONSORING/MONITORING AGENCY NAM£(S) AND ADDRESSIES; 

Electronic Systems Division 
Air Force Systems Command, USAF 
Hanscom AFB, MA 01731-5000 


I 10. SPONSORING/MONITORING 
AGENCY REPORT NUMBER 


[ CDRL Sequence No. 2020 




11. SUPPLEMENTARY NOTES 


( 


120. DISTRIBUTION. AVAILABILITY STATEMENT 


12b. DISTRIBUTION CODE 


13. ABSTRACT (Maximum 200 words) 

A standard binding was needed between Ada and SQL (Structured Query Language), the 
ANSI and DoD standard for accessing commercial relational data base management sys¬ 
tems (DBMS's). SQL was not designed to be embedded within applications in general 
purpose programming languages, such as Ada. Previously developed Ada-SQL bindings 
have had various technical drawbacks. 

A prototype Ada-SQL binding was built by automating the SQL Ada Module Extension 
methodology (SAME). SAME is a method for building Ada applications that access 
DBMS's via SQL. SAME extends SQL by exploiting the features of Ada. - 

t This User's Manual contains TIT?jLaliation instructions, compilation order, guidelines 
for input data, detailed steps to create a specific binding, and information about 
porting the system to another DBMS. , 

^ n c S'f 

'• - w, ^ /. /■■ T'.'. (4 ' r . 






^ ; 


14 SUBJECT TERMS 

STARS, Ada, SQL, Structured Query Language, 
system, DBMS, SAME 

_ 

data base management 

iy NUMBER OF PAGES 

145 

16. PRICE CODE 

17. SECURITY CLASSIFICATION 

18. SECURITY CLASSIFICATION 

19. SECURITY CLASSIFICATION 

2'J. LIMITATION OF ABSTRACT 

OF REPORT 

OF THIS PAGE 

OF ABSTRACT 


Unclassified 

Unclassified 

Unclassified 

UL 


SM'Vt.i'L'i ‘Orr’-- .""V. A\-v z-H'H) 


\S'. /S^0-0:-/B0-5b0‘) 






LMSC-F376702 


USER»S MANUAL 
for 

A Prototype Binding of 
ANSI-Standard SQL to Ada 
Supporting the SAME Methodology 



Contract Number: F19628-88>D-0032/0002 
CDRL Number: C2020 


Submitted to 


IBM Corporation 
Systems Integration Division 
800 N. Frederick Road 
Gaithersburg, Maryland 20879 


June 7,1990 


"^^Lockheed 

Missiles A Space Company, Inc. 

Softwars Tadinoiogy Cantar 

2100 East Sl Elmo Road 
Org.96-10/Bldg.30E 
Austin, TX 78744 
(512)448-5740 


E-mail: phillips@stc.lockheedcom 


Accession For 


NTIS G1RA&I 

00^ 

DTIC TAB 

□ 

Unannounced 

□ 

Justification_ 

-- 



Distribution/ 


Availability Codes 
jAvall and/or 
Special 




LMSC-F376702 


Contract F19628-88-D-0032/0002 
USER’S MANUAL 


CDRL 2020 


RELEASE PAGE 

This manual is compatible with Version 1 of A Prototype Binding of ANSI- Standard SQL to 
Ada Supporting the SAME Methodology, released June 7,1990. 


page II 


6/19/90 


\ 


LMSC-F376702 Contract F19628-88-D-0032/(X)02 CDRL2020 

USER’S MANUAL 


RELEASE PAGE 

This manual is compatible with Version 1 of A Prototype Binding of ANSI- Standard SQL to 
Ada Supporting the SAME Methodology, released June 7,1990. 


pageu 



CDRL2020 


Conaaa F19628-88-D-0032/0002 
USER’S MANUAL 


LMSC-F376702 


TABLE OF CONTENTS 

Section Title Page 

LISTOFnOURES.vi 

LIST OF TABLES.vi 

Section 1 Overview. 1 

1.1 INTRODUCTION. 1 

1.2 THE PURPOSE OF THIS MANUAL. 2 

1.3 THE SCOPE OF THIS MANUAL. 2 

1.4 MANUAL ORGANIZATION AND CONTENT. 2 

1.5 MANUAL TYPESET AND NOTATION CONVENTIONS. 3 

Section 2 Computer Program System Capabilities. 5 

2.1 PROGRAM PURPOSE. 5 

2.2 GENERAL DESCRIPTION OF THE SAME APPROACH. 5 

2.3 GENERAL DESCRIPTION OF PROGRAM. 6 

Section 3 Deflning and Generating the Domains. 9 

3.1 GENERAL PREPARATION. 9 

3.2 INPUTS FOR DOMAIN DEFINITION AND GENERATION.11 

3.3 STEPS AND GUIDELINES FOR PROCEDURE Domain^Vievi .12 

3.4 DETAILED DESCRIPTION OF DOMAIN GENERICS.-.15 

3.4.1 Domain Generic Parameter Set.16 

3.4.2 Generics for Char, Int, and Smallint Domains and Subtypes.17 

3.4.3 Generics for Real, Dedmal, and Double_Prccision Domains and Subtypes.18 

3.4.4 Generics for Enumeration Domains and Subtypes.18 

3.6 RESULTS OF OPERATION.21 

3.7 SUMMARY.23 

Section 4 Deflning and Generating the Interface.25 

4.1 GENERAL PREPARATION.25 

4.2 INPUTS FOR INTERFACE DEFINITION AND GENERATION.25 

4.3 STEPS AND GUIDELINES FOR PROCEDURE Interface_View. .26 

4.4 DETAILED DESCRIPTION OF PROCEDURE GENERICS.33 

4.4.1 Procedures without Parameters.33 

4.4.2 Procedures with Parameters.34 

4.5 EXAMPLE INTERFACE DEFINITION PROCEDURE.38 

4.6 RESULTS OF OPERATION.42 

4.7 SUMMARY.49 


6/19/90 page iii 



































LMSC-F376702 


Contract Fl%28-88-D-0032/0002 
USER’S MANUAL 


CDRL 2020 


Section 5 Usage Instructions for the Application Programmer.51 

5.1 GENERAL PREPARATION.51 

5.2 INPUTS FOR THE Ada APPLICATION PROGRAM.51 

5.3 STEPS AND GUIDELINES FOR THE Ada APPLICATION.51 

5.4 SAMPLE Ada APPLICATION.54 

5.5 RESULTS OF OPERATION.58 

5.6 SUMMARY.58 

Section 6 Operating Instructions.59 

6.1 OVERVIEW.59 

6.2 INSTALLATION.59 

6.2.1 Hardware Requirements.59 

6.2.2 Software Requirements.59 

6.2.3 Installation of Ada/SQL Software.60 

6.2 USE OF THE BINDING WITH DEC Ada AND RDB.62 

6.3 ERROR PROCESSING WITH RDB.63 

6.4 rdb_specific PROCEDURE ADAPTIONS.66 

APPENDIX A Component Description and Compilation Order.69 

A. 1 FUNCTIONAL AREAS.69 

A.2 DOMAIN DEFINITION AND GENERATION.69 

A.3 INTERFACE DEFINITION AND GENERATION.70 

A.4 GENERAL BINDING SUPPORT COMPONENTS.70 

A.5 SAME STANDARD COMPONENTS.72 

A.6 DOMAIN DEFINITION AND GENERATION. 72 

APPENDIX B SAME SUPPORT EXCLUSIONS.75 

APPENDIX C EXECUTION ERROR MESSAGES AND ERROR CORRECTION.77 

C. 1 DOMAIN DEFINITION AND GENERATION EXECUTION ERRORS.77 

C. 1.1 Domain Package Errors.77 

C.1.2 Domain Errors.77 

C. 2 INTERFACE DEFINITION AND GENERATION EXECUTION ERRORS.78 

C.2.1 Error Definition Errors.78 

C.2.2 Record Defiiution Errors.79 

C.2.3 Procedure Definition Ettots .79 

APPENDIX D SAMPLE PROGRAMS.83 

D. 1 SAMPLE PROGRAMS OVERVIEW.83 

D.2 DOMAIN DEFINITION AND GENERATION FOR ALL SQL TYPES.83 

D.3 LARGE-SCALE BINDING PROCESS.87 

APPENDIX E REFERENCES.135 


page IV 


6/19/90 










































CDRL2020 


Contract Fl%28-88-D-0032/0002 
USER’S MANUAL 


LMSC-F376702 


LIST OF FIGURES 

Figure Title Page 

Figure 2-1 Ada Application Accessing a DBMS Using SAME. 6 

Figure 2-2 A Graphic Overview of the Binding's Architecture. 7 

and the Ordered Steps (1-4) for Crating the Interface 


LIST OF TABLES 

Table Title Page 

Table 3.1 Structure for the DIXIE_DB Data Base. 9 

Table 3.2 SQL Module DDOE.CONC.INTERFACE. 9 

Table 3.3 Domain Definition Template.14 

Table 3.4 Example Domain DeHnidon Pnscedure Dixie_Domain_View.20 

Table 3.5 Generated Products. 21 

Table 3.6 Tasks to be Performed During Domain Definition and Generation.23 

Table 4.1 SQL Statements and Corresponding Ada Procedure Kinds.26 

Table 4.2 Interface Definition Template. 31 

Table 4.3 Example Interface Definition Procedure Dixie_Intciface_View. 38 

Table 4.4 Generated Products.43 

Table 4.5 Task Summary.49 

Table 5.1 Generalized Ada Application. 53 

Table 5.2 Sample Ada Application Dixic_Application.....54 

Table 5.3 Steps Summary.58 

Table 6.1 Modified Package Body Sql_Communications_Pkg.64 

Table 6.2 Modified Package Body Sql_Databasc_Ent)r_Pkg.65 


6/19/90 page V 




















CDRL2020 


Contract F19628-88-D-0032/0002 
USER’S MANUAL 


LMSC-F376702 


Section 1 
Overview 


1.1 INTRODUCTION 

This rnanual is intended for users of the Ada/SQL binding supporting the SQL Ada Module 
Extensions (SAME) methodology developed by Lockheed Software Technology Center. Ada is 
a programming language resulting from a collaborative effort to design a common language for 
developing large-scale, real-time systems. Structured Query Language (SQL) consists of a set of 
facilities for defining, manipulating, and controlling data in a relational data base. The SAME 
approach as describ^ in Guidelines for the Use of the SAME, an SEI Technical Report [1], is a 
method for the construction of Ada applications that access data base management systems 
(DBMS) whose data manipulation language is SQL. 

Conventional approaches for binding ANSI-standard SQL to Ada allow the embedding of SQL 
statements directiy into Ada programs, thereby creating something that is neither pure SQL nor 
pure Ada. A preprocessor is us^ to remove tiie SQL statements and replace them with valid 
Ada subprogiW calls. However, direct access to the data base is still part of the application 
program. Using Lockheed’s SAj(^ approach, the SQL statements and Ada statements are 
separate, proving a modular approach to data base definition and access and allowing the 
efficiency of having programming tasks assigned to programmers who specialize in each area. 

As its name implies, SAME extends the module language defined in the ANSI SQL standard 
Database Language—SQL [2] by exploiting the capabilities of Ada. The defining characteristic 
of the module language is the collocation of SQL statements, physically separated from the Ada 
application, in an object called the concrete module. SAME t^ows an Ada application to treat 
the module much the same as it treats any other foreign language; that is, it imports complete 
modules, not language fragments. SAME provides the bin^ng between these two modules 
through an interface layer—called the abstract interface —that consists of an Ada specification 
and b^y. The abstract interface transfonns data from abstract definitions to concrete types (and 
back again). The abstract interface makes calls to an Ada specification representative of the SQL 
module. Both the SQL module and its representative Ada specification are called the concrete 
interface. All abstract data types supporting this interface are contained in abstract domain 
paclmges. 

The Ada/SQL binding tool provides automatic generation of the abstract interface, the 
specification part of the concrete interface and &e abstract domain packages. This binding also 
allows Ada compile-time checking of all data manipulation procedures within a user's 
application program. The approach uses no preprocessor, and all code is valid Ada, compilable 
under any validated Ada compiler. The binduig may be associated with any commercial off-the- 
shelf data base. For development, the DEC RDB data base management system executing on a 
Vax workstation running the VMS operating system was used. At present, this is the only 
commercially available platform that has an SQL module language compiler. A module 
language compiler can be simulated using one of many DBMS systems that support embedded 
SQL. When associating the binding with another data base, some implementation details will 
change. Included in this manual is a description of the support provided by this implementation 
to fa^itate those changes. 


6/19/90 


page 1 


LMSC-F376702 


Contract Fl9628-88-D-0032AX)02 
USER’S MANUAL Section 1 Overview 


CDRL 2020 


1.2 THE PURPOSE OF THIS MANUAL 

The purpose of this manual is to provide the guidance needed to use tools to define and generate 
a SAME binding for a specific data base application. This manual offers assistance for all types 
of users during development of an interface and the accompanying application programs. It 
explains the methodologies and strategies used to define and generate an interface and to use the 
int^ace with an Ada application. This explanation is given as a series of well-defined steps. 
These steps arc outlined in Sections 3 through 6. This manual is intended for use by the 
following people: 

• The interface programmer—to define the abstract domain packages, the abstract interface, 
and the concrete interface. 

• The application programmer—to use the binding and have compile-time checking of all data 
manipulation statements within the Ada program. 

• The system operator—to install the system on any machine using any data base and modify it 
for use with efferent data base implementations. 

This manual is not intended to be either an SQL or SAME reference manual, and the audience of 
this manual is assumed to be familiar with both SQL and the SAME method. Refer to either 
Guidelines for the Use of the SAME or the ANSI SQL standard Database Language—SQL for 
more information about SQL and the SAME method. 

1.3 THE SCOPE OF THIS MANUAL 

This manual is intended as a guide to installing and using an implementation of an Ada/SQL 
binding. The manud does not define specific uses for this binding nor any of the reasons that a 
binding is necessary. The manual does not provide design decisions made during development 
or give any rationale to the choices made during implementation. Finally, this manual is written 
for persons knowledgeable of ANSI-standard Ada, the SQL data manipulation and definition 
language, and the SAME method. Explanations of what specific SQL statements do (i.e.. What 
is an update statement?) or detailed explanations of the SAME method (i.e.. How are abstract 
domains determined?) are not provided. The manual can be used by all members of a team who 
are responsible for writing an Ada application program that accesses a data base with an SQL 
interface. The noanual provides instruction at each step in this process. 

1.4 MANUAL ORGANIZATION AND CONTENT 

This manual is divided into five main sections and five appendices. Section 1 provides an 
overview of the binding and manual content. Section 2 briefly discusses the SAME approach 
and the major functionality of the delivered software. Includ^ in this section are graphic 
representations of both the SAME approach and in^ace creation and architecture. Sections 3 
and 4 are intended for use by the interface programmer. Section 3 provides instructions for 
defining and generating the abstract domains, while Section 4 explains the methodology for 
defining an interface and generating the abstract interface and the Ada specification part of the 
concrete module. Section 5 is used by the Ada application programmer. It provides the user 
with the names of all packages that must be imported by the application to use the binding. A 
description of these packages is also included. Section 6 is intended for use by system personnel 
who are responsible for installing the software for the binding. Included in this section are 
instructions for associating the binding with another data base. 


page 2 


6/19/90 



CDRL 2020 


Contract F19628-88-D-0032/0002 
USER’S MANUAL Section 1 Overview 


LMSC-F376702 


Appendix A provides a more detailed description of the program’s components with each major 
component within the system discussed in terms of inputs, outputs, and functionality. This 
appendix also contains the compilation order of all components. Appendix B lists all program 
exclusions of the SAME method. Errors, error messages, and suggestions for correction are 
discussed in Appendix C. Comprehensive sample pro^ams illustrating domain and interface 
definition, generation, and use are provided in Appendix D. Appendix E contains a reference 
list. 

1.5 MANUAL TYPESET AND NOTATION CONVENTIONS 

Throughout this manual, the following typeset and notation conventions are used to increase 
clarity: 

• Courier Type face denotes actual filenames or Ada unit names and Ada code. 

Examples: 

[project ] test_instructions.txt—Full name of a text file 
Abstract_Interf ace_Generator—^An actual Ada unit 
type records is (first_record, second_record) ;—Adacode 

• COURIER CAP ITALS denote SQL module language commands and code. 

Examples: 

CLOSE CURSOR —SQL module language command 
SELECT AGE FROM EMPLOYEE —SQL module language code 

• {Courier typeset enclosed in .brackets) denotes VMS or RDB commands and 
code. Note that the brackets are not part of the code. 

Examples: 

{set def [directory_naine] }—^A VMS command 
{create table)—An ROB command 

• <Key > denotes a key. 

Example: 

<Return > —^The return key 

• Italics denote user-supplied names, expressions, and commands. 

Example: 

Procedure Name —A specific procedure to be named by the user (e.g., substitute 
"Update_Row^' for Procedure Name ) 


6/19/90 


page 3 




CDRL2020 


Contract F19628-88-D-0032/0002 
USER’S MANUAL 


LMSC-F376702 


Section 2 

Computer Program System Capabilities 


2.1 PROGRAM PURPOSE 

The purpose of this ADA/SQL binding is to provide tools and methodologies to assist in L.e 
construction of a SAME AtWSQL interface to a commercial SQL data base. This program is to 
be used for the automatic generation of the SAME-.equired domain packages, abstract interface, 
and Ada specification part of the concrete interface from two procedures, a domain view 
procedure and an interface view procedure. These products can then be withed by an Ada 
application programmer. This approach requires no preprocessing of source code in any 
language and is compatible with any commercial Ada compiler. Note that this program does not 
assist in acmal data base creation and assumes that a data base exists and its structure and content 
are known. 

2.2 GENERAL DESCRIPTION OF THE SAME APPROACH 

During application design and development, the SAME method is used as shown here. The 
automatic suppon provided by this binding tool is also indicated. 

• The application programmer, along with the SQL programmer, determines the services that 
will be needed from the data base. They are coded in SQL and collected in an SQL module 
called the concrete module. 

• The abstract domains that occupy data base columns are defined and described as Ada types. 
This is done using standard packages available to users of SAME methodology. The domain 
packages are specific to a given data base but not necessarily to a given application (more 
than one application can be supported by the packages). Automatic support is provided for 
domain generation. 

• An abstract interface is created. This is a set of package specifications declaring the record 
type definitions needed to describe row records and the procedure declarations needed to 
access the relevant concrete module procedures. This interface will be called by the Ada 
application. Unlike the domain pacl^ges, the interface is specific to one application. Note 
that each application can use multiple abstract interfaces. Automatic support is provided for 
abstract interface generation. 

• The application program is written. Once the abstract interface specification is completed, 
the application program can be written concurrently with the creation of the abstract module 
bodies because the application docs not need the module bodies to compile. 

• The abstract module—the bodies of the prcxiedurcs declared in the abstract interface—is 
created. Automatic support is provided for abstract module generation. 

Figure 2-1 shows the configination of an Ada application accessing a DBMS using SAME. 
Dashed, two-way arrows indicate data flow and solid, one-way arrows indicate Ada visibility. 


6/19/90 


pages 




LMSC-F376702 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 2 Computer Program System Capabilities 


CDRL 2020 



Figure 2-1. Ada Application Accessing a DBMS Using SAME 


2.3 GENERAL DESCRIPTION OF PROGRAM 

This program can be conceptually thought of as two tools, one for SAME domain package 
generation and one for SAME abstract interface and concrete interface generation. Figure 2-2 
provides a graphic overview of the binding's architecture and the order^ steps (steps 1-4) for 
creating the interface. Hashed arrows represent automatic code generation, and solid arrows 
represent Ada visibility. 

Step 1. The SQL programmer writes the SQL module containing all of the SQL data 
manipulation statements needed by the Ada application accessing the database. Once written, 
the SQL module is turned over to the interface programmer who will generate the corresponding 
domain packages and interface. 

Step 2. The interface programmer writes an Ada procedure (Domain View in Figure 2-2) to 
defhie and generate the domain packages used by the application. Specific syntax and content 
for this procedure are given in Section 3. This procedure instantiates the generic package, 
Abstract_Domain_Generator, with several parameters that are used to define the name of 
the package containing the abstract domains, the names of the columns within the data base that 
are being defined as dotnaii , and the attributes of each domain, such as length or type. 

When this Ada procedure (Domain View) is compiled and executed, syntactically valid Ada 
packages that support SAME abstract domain semantics are generated automatically. These 
packages are compiled and made available to the application programmer. All generated 
domains are based on the data types contained in the SAME standard types packages and 
declared in the Ada specification SQL Standard. This method provides enough redundancy 
to check for undefined or multiply defined domains (or columns). The interface programmer is 
notified of any errors in domain definition by means of error messages printed to the screen. The 
domain packages are generated only after a successful execution. 


page 6 


6/19/90 















CDRL2020 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 2 Computer Program System Capabilities 


LMSC-F376702 



Figure 2-2. A Graphic Overview of the Binding's Architecture 

and the Ordered Steps (1-4) for Creating the Interface 


In addition to the domain packages, an Ada package specification, Base_Specif ic_ 
Domains, is generated automatically. This package is an Ada specification that contains an 
enumerated list of all valid domains and all valid domain packages to be used by the interface 
programmer when generating the abstract interface. 

Step 3. The interface programmer writes another Ada procedure (Abstract Interface View in 
Figure 2-2), as detailed in Section 5, that generates the Abstract Interface, both 
specification and body, and the Ada specification for the SQL module. This procedure, as well 
as Abstract Interface_Generator, will with the previously generated 
Base_Specific T)omains package specification to ensure consistency between the abstract 
interface being gerierated and the domain packages previously generated. The interface 
programmer is notified of any errors in abstract interface definition by means of error messages 


6/19/90 


page 7 
























LMSC-F376702 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Sectmn 2 Computer Program System Capabilities 


CDRL 2020 


printed to the screen. The abstract interface and Ada specification part of the concrete interface 

are generated only after a successful execution. ) 

This procedure instantiates the generic package, Abstract_Interface_Generator, with 
parameters that define the name of the abstract interface package, the names and components of 
each row record, and the names and parameters of each procedure corresponding to the SQL 
procedures. When this Ada procedure is compiled and executed, syntactically valid Ada 
packages that support SAME abstract and concrete interface semantics are automatically 
generated. These packages are compiled and made available to the application programmer. 

Because the interface programmer's procedure provides the 

Abstract_Interf ace_Generator with enough semantic knowledge of the structure of the 
Abstract__^Interf ace, most incomplete definitions, missing definitions, and semantically 
invalid definitions are caught at compilation. 

In addition to the interface packages, a text file—Dbms^Specif ic—is generated 
automatically. This text file contains interface infonnaubn that can be used to modify the SAME 
standard interface to support different DBMS implementation. 

Step 4. The final phase deals with the application programmer, who has been given the Ada 
domain packages, the abstract interface and the Ada specification of the concrete interface, and 
the SQL concrete module. The programmer will import the interface and the domain packages 
into his program via with clauses. Once imported, the application program has access to the 
DBMS through the domains and procedures provided. 


) 


) 


pages 


6/19/90 



CDRL2020 


Contract F19628-88-D-0032/0002 
USER’S MANUAL 


LMSC-F376702 


Section 3 

Defining and Generating the Domains 


3.1 GENERAL PREPARATION 

For this prototype binding, it is assumed that 
all data base tables and views have been 
created. The data base structure for a 
hypothetical data base, Dixie_Db, shown 
in Table 3.1 will be the basis for later 
examples of interface development 
throughout Sections 3 through 5. 

After data base creation, the application 
programmer informs the SQL programmer 
of the data base services that are required. 
Based on that information, the SQL 
programmer writes an SQL module 
containing all of the SQL statements needed 
by the Ada application. Guidelines and 
rules governing SQL module programming 
are defined in ti\c ANSI SQL standard 
Database Language —SQL [2]. 

Table 3.2 shows an example SQL module 
named DIXIE_CONC_INTERFACE. This 
SQL module contains some example SQL 
statements for manipulating data in the 
DIXIE_DB data base. 


Table 3.1. Structure for the 

DIXIE_DB Data Base 

TABLE EMPLOYEES 
EMPLOYEEJD CHAR(5) NOT NULL 
LAST_NAME CHAR(10) NOT NULL 
FIRST_NAME CHAR(10) NOT NULL 
ADDRESS CHAR(30) NOT NULL 

WEIGHT REAL NOT NULL _ 

TABLE JOB_HIST 

EMPLOYEEJD CHAR(5) NOT NULL 
TITLE CHAR(15) 

YEARS_EMPLYD INT _ 

TABLE SALARY_raST 
EMPLOYEEJD CHAR(5) NOT NULL 
SALARY REAL NOT NULL 
MERIT PTS INT 


Table 3.2. SQL Module DIXIE CONC INTERFACE 


— THIS SQL MODULE PROVIDES THE SQL STATEMENTS NEEDED BY THE 

— DIXIE APPLICATION.ADA PROGRAM. 


— HEADER INFORMATION SECTION 


MODULE NAME 

LANGUAGE OF CALLING PROGRAM 
PROVIDES DEFAULT DB HANDLE 

— DECLARE STATEMENTS SECTION 


MODULE DIXIE_CONC_INTERFACE 

LANGUAGE ADA 

AUTHORIZATION DIXIE DB 


6/19/90 


page 9 




LMSC-F376702 


Contract F19628-88-D-0032AX)02 

USER’S MANUAL Sectioa 3 Defining and Generating the Domains 


CDRL 2020 


DECLARE SCHEMA FILENAME 'DIXIE_DB' — DECLARATION OF THE DATABASE 

DECLARE EMPLROW CURSOR FOR 

SELECT EMPLOYEE_ID, LAST_NAME, FIRST_NAME, ADDRESS, WEIGHT FROM EMPLOYEES 
WHERE EMPLOYEE ID ■ INPUT EMPLOYEE ID 


— PROCEDURE SECTION 


— THIS PROCEDURE USES THE DEC RDB EXECUTABLE FORM FOR STARTING A TRANSACTION 

— THIS PROCEDURE IS ONLY USED WITH THE DEC RDB DBMS 
PROCEDURE SET_TRANSACTION 

SQLCODE; 

SET TRANSACTION READ WRITE; 

— THIS PROCEDURE OPENS THE CURSOR THAT HAS BEEN DECLARED FOR EMPLOYEES TABLE 
PROCEDURE OPEN_EMPLOYEES_CURSOR 

INPUT_EMPLOYEE_ID CHAR(5) 

SQLCODE; 

OPEN EMPLROW; 

— THIS PROCEDURE FETCHES THE DATA FROM THE OPENED EMPLROW CURSOR 
PROCEDURE FETCH_EMPLOYEES 

OUTPUT_EMPLOYEE_ID CHAR(5) 

OUTPUT_LAST_NAME CHAR(10) 

OUTPUT_FIRST_NAME CHAR(10) 

OUTPUT_ADDRESS CHAR(30) 

OUTPUT_WEIGHT REAL 
SQLCODE; 

FETCH EMPLROW INTO OUTPUT_EMPLOYEE_lD, 

OUTPUT_LAS T_NAME, 

OUTPUT_FIRST_NAME, 

OUTPUT^ADDRESS, 

OUTPUT_WEIGHT; 

— THIS PROCEDURE UPDATES THE SALARY_HISTORY TABLE 
PROCEDURE INSERT_SAL_HIST_ROW 

INPUT_EMPLOYEE_ID CHAR(5) 

INPUT_SALARY REAL 

INPUT_MERIT_PTS INT MERIT_IND SMALLINT 
SQLCODE; 


page 10 


6/19/90 




CDRL2020 


Contraa Fl%28-88-D-0032/0002 

USER’S MANUAL Section 3 Defining and Generating the Domains 


LMSC-F376702 


INSERT INTO SALARY_HIST 

VALUES {INPUT_EMPLOYEE_ID, INPUT_SALARY, INPUT_MERIT_PTS MERIT_IND); 

— THIS PROCEDURE UPDATES THE JOB_HIST TABLE 
PROCEDURE UPDATE_JOB_HIST 

INPUT_EMPLOYEE_ID CHAR(5) 

SQLCODE; 

UPDATE JOB_HIST 

SET YEARS_EMPLYD - YEARS_EMPLYD + 1 
WHERE EMPLOYEE_ID - INPUT__EMPLOYEE_ID; 

— THIS PROCEDURE COMMITS THE TRANSACTION 
PROCEDURE COMMIT_TRANSACTION 

SQLCODE; 

COMMIT; 

— THIS PROCEDURE ROLLS BACK THE TRANSACTION 
PROCEDURE ROLLBACK_TRANSACTION 

SQLCODE; 

ROLLBACK; 

— THIS PROCEDURE CLOSES THE EMPLROW CURSOR 
PROCEDURE CLOSE_EMP_CURSOR 

SQLCODE; 

CLOSE EMPLROW; 


Once the SQL module is completed, the SQL programmer hands over the module to the interface 
programmer, and all further operational en^ tas^ in this section are the responsibility of the 
intmace programmer. 

Before beginning domain definition, the interface programmer creates a directory to contain the 
SQL module(s), the domain packages, the interface(s), and the Ada/SQL binding tool. A 
characteristic of the binding tool requires that only one set of domains packages is in a directory 
at any given time to avoid ambiguity. All components of the binding tool up to and including ^e 
Abstract__Domain_Generator should be compiled in the order shown in Appendix A. 

3.2 INPUTS FOR DOMAIN DEFINITION AND GENERATION 

Based on SQL statements coded in the SQL module, the interface programmer determines the 
abstract domains needed to support the interface. Guidelines for domain determination are 
explained in Guidelines for the Use of the SAME [1]. Next the interface programmer writes an 


6/19/90 


page 11 




LMSC-F3T67Q2 Contract F19628-88-D-0032/0002 CDRL2020 

USER’S MANUAL Section 3 Defining and Generating the Domains 

Ada procedure, Do/nain_Vienr, to create the domain packages. This procedure instantiates 
several layers of nested generics contained in Abstr act_Doma in Generator. When 
executed, it produces two or more text files, one or more Domain Packages, and the file 
Base_Specific_Domains. 

The following paragraphs provide the steps and guidelines for writing the Ada procedure, 
Domain_View, that will generate these files. 

3.3 STEPS AND GUIDELINES FOR PROCEDURE Doiaalji_Vie»r 

To define the domain packages, the interface programmer always follows the same basic steps. 
These steps take the form of writing an Ada procedure that instantiates each of the three levels of 
nested generics within the Abstract_Domain_Generator generic package. This does not 
mean that every procedure or generic package is used but that at least one generic package in 
each level of the nesting must be instantiate. 

The following numbered steps are described in the order in which the interface programmer 
writes the Ack code. Each step includes example code that implements the step and a complete 
procedure template, also naming the steps, is shown in Table 3.3. Note that italics indicate user- 
supplied names or values. Names can be any valid Ada name but must be used consistently 
throughout the procedure. 

Step!. Import 2 packages: 

Abstract__Domain_Generator => contains the generics that when instantiated 
generate the Domain packages and the file Base_Speci f ic_Domains. This 
package must always be imported. 

I 

Generator_Support => contains common declarations (mostly enumerated types 
and constants). This package must always be imported. 

with abstract_domain_generator; 

with generator_support; use gerterator_support; 

Step 2. Create an Ada main procedure. 

procedure Domain_View is 
begin 

end Domain_View; 

Step 3. Within this procedure declare an enumerated type representing all valid names of 

domain packages to be generated. These names will also appear as the filenames of the 
generate packages. 


Note: Duplicate package names are not allowed. 


type Pack_Names is 

(PackageJNamel, Package_Name2, Package_Name3, ...) ; 
Step 4. Instantiate the outermost generic package Abstract_Domain Generator with the 
type representing the domain package names. From now on, only the package names 


page 12 


6/19/90 






CDRL2020 Contract F19628-88-D-0032/0002 LMSC-F376702 

USER’S MANUAL SectioB 3 Defining and Generating the Domains 

represented by Pack_Names will be recognized as valid during elaboration of 
subsequent generic packages, 
package Dom_Packs is new 

abstract_domain_generator (Pack_Names ); 

Step 5. Steps 5 through 8 are repeated once for each domain package, PackagejtJamel, 

Package Na/ne2, etc., enumerated in Step 3. For each domain package, declare an 
enumerate? type representing all valid names of domains to be contained in that 
domain package. From now on, only these domain names will be recognized as valid 
during elaboration of subsequent generics. 


Note: Duplicate domain names are not allowed. 


declare 
type Dorns is 

{Domain_Namel, Domain_Name2, Domain_Name3, ...); 

Step 6. Instantiate the second-level generic package, Generate_Domain_Package, with 
the specific domain package name and the enumerated type Dorns that represents the 
domain names. 

package Dom_l is new 

Dom_Packs.qenerate_domain_packaqe (Package_Namel, Dorns ); 

Step 7. Step 7 is repeated once for each domain, DomainjtJamel, Domain Name2, etc., 
enumerated in Step 5. For each domain, instantiate a third-level genenc package with 
parameters that describe the domain. Which generic and what parameters depend on 
the type of domain. An example of each one of the six possible generic instantiations 
is shown below, however, more detailed descriptions of each generic along with 
parameter explanations are found in the next section. 

— For domains of type char, int or small int. 
package First is new Dom_I.generate_int_domain 

(Domain_Namel, Domain^Type, Null_Indicator, 
Range_Start, Range_Stop ); 

— For subtypes of domains of type char, int or small int. 
package Second is new Dom_I.generate_subint_domain 
{Domain_Name2, Domain_^Based_On, Domain_Type, 
Null_Indicator, Range_Start, Range_Stop) ; 

— For domains of type real, decimal or double^precision. 
package Third is new Dom_I.generate_flt_domain 

(Domain_Name3, Domain^Type, Null_Indicator, 
Range_Start, Range_Stop ); 

For subtypes of domains of type real, decimal or 
double_precision. 

package Fourth is new Doin_I,generate_subflt_domain 
(Domain__Name4, Domain^Based_On, Domain_Type, 
Null_Indicator, Range_Start, Range_Stop) ; 


6/19/90 


page 13 







LMSC-F376702 Contract Fl%28-88-D-0032/0002 CDRL2020 

USER’S MANUAL S«ctioii 3 Defining and Generating the Domains 

For domains of type enumeration, 
type Vais is {Value_l, Value_2, Value__3, ...); 
package Fifth is new Doin_I .generate_enum_domain 

(Vais, Domain_Name5, Domain_Type, Null_Indicator) ; 

For subtypes of domains of enumeration, 
package Sixth is new Dom_l.generate_subenum_domain 
(DomainJtJameS, Domain__Based_On, Domain_Type, 
Null_Indicator, Range_Start, Range_Stop) / 

Step 8. After defining all the domains for a single domain package, invoke the generic 
procedure Start_Generation. 

begin 

Doin_I. start__generation; 
end; 

Now, repeat Steps 5 through 8 for the next domain package. 

Step 9. After defining all domain packages, invoke the generic procedure 
Gene rate_Base_Specific. 

Dom_Packs.generate_base_specifc; 

Step 10. Compile the procedure and connect any indicated errors. 

Step 11. Execute the procedure. 

All of the Ada code required by Steps 1 through 9 is shown in template form in Table 3.3. When 
wri^g a domain definition and generation procedure, use this template as a guide substituting 
desired names and values for any expressions in italics. 

Table 33. Domain Deflnition Template 


with abstract_doinain_generator; — Step 1 

with generator_3upport, use generator_support; 


procedure Doiaain_View is 


— Step 2 


type Pack_Names is _ Step 3 

(Package_Namel, Package_Name2, Package_Name3, . . .) ; 
package Dom_Packs is new abscract_doinain_generator (PacJk_Nanies) ; — Step 4 


begin 

declare , __ step 5 

type Dorns is (DomainJUamel, Domain_Name2, Domain_Name3, ...); 

package Dom_l is new _ Step 6 

Dom_Packs .generate_domain_j3ackage (Package_Namel, Dorns ); 


page 14 


6/19/90 





CDRL2020 


Contract Fl%28-88'D-0032/0002 

USER’S MANUAL Section 3 Defining and Generating the Domains 


LMSC-F376702 


— For domains of type char, int or smallint. — Step 7 

package First is new Dom_l .generate_int_domain (Z?omain_Nainei, 
Domain_Type, Null_Indicator, Range_Start, Range_Stop ); 

— For subtypes of domains of type char, int or smallint. 

package Second is new Dojn_l .generate_subint_domain (Oomain_Name2, 
Domain_Based__On, Domain_Type, Null_Indlcator, Range_Start, 
Range_Stop ); 

For domains of type real, decimal or double_precision. 
package Third is new Do/n_l .generate_f lt_domain (Domairt_Na/ne3, 
Domain_Type, Null_Indicator, Range_Start, Range_Stop ); 

For subtypes of domains of type real, decimal or 
double_precision. 

package Fourth is new Oom_i .generate_subflt_domain (i3oniain_Name4, 
Domain_Based_On, Domain_Type, Null_Jndicator, Range_Start, 
Range_Stop); 

— For domains of type enumeration. 

type Vais is (Value_l, Value_2, Value_3, ...); 

package Fifth is new Oom_J.generate_enum_domain(Vais, Domain_Name5, 
Domain_Type, Null_Indicator ); 

— For subtypes of domains of enumeration. 

package Sixth is new Dom_J .generate_subenum__domain (Do/nai/i_Nameff, 
Domain_Based_On, Domain_Type, Null_Indicator, Range_Start, 
Range_Stop): 

— Additional domains here... 

begin — Step 8 

Dom_l .start_generation; 
end; 

— Additional domain packages here... 

Dom_Packs.generate_base_specifc; — Step 9 

end Domain View; 


3.4 DETAILED DESCRIPTION OF DOMAIN GENERICS 

Each individual domain definition uses a different generic and a different subset of the the 
domain generic parameters depending on its SQL type, such as "char" or "int." Each domain to 
be defined will be of one of the SQL types and, depen^g on the type, will use one of six 
possible generics. Domains can be instantiated during Step 7 in any order (regardless of type) 


6/19/90 


page 15 



LMSC-F376702 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Secdon 3 Defining and Generating the Domains 


CDRL 2020 


with the important exception that any subtype generic must defined only after its parent domain 
has been defined via a generic instantiation. Descriptions, syntactic and semantic guidelines, and 
examples of the set of domain generic parameters and each of the six type-based generics are 
provided in the following paragraphs. 

3.4.1 Domain Generic Parameter Set 

All of the domain generics use some subset of these seven parameters. This paragraph provides 
general guidelines, rules, a;id examples for assigning values to these parameters. 

1. Domain_Name —^The name of the domain being defined. The name should be descriptive 
of the domain, however, avoid adding such things as "domain," "type," or "not_nuU" to the 
n ame s. These suffixes will be added automatically where appropriate. 

Example-> Parts_Numbers for a domain describing columns that will contain part 
numbers or Employee_Name for a domain describing columns that contain 
names. 

2. Domain_Based_On —^The name of the parent domain on which the subtype to be defined is 
based. Remember that the parent domain must already be defined before defining the 
subtype. 

Example-> Part_Numbers_Over_1000 fora subtype based on the Part_Number domain 
or Employee_Names_L__To_S for a subtype based on the Employee_Names 
domains. 

3. Domain_Type —^Thedoc. tin’s or subtype’s SQL type. Subtypes are, of course, always of 
the same type as the parent aomain. The valid SQL types, as defined in the SAME package 
Sql_Standard, are char, int, smallint, real, decimal, doublc_precision, and enumeration. 

Example-> char for an SQL character domain or real for an SQL real domain. 

4. Null_Indicator —^This domain’s null bearing state and always one of: 

• null_and_not_null if the domain has both null bearing and not null types. 

• contains_null if the domain is null bearing, 

• not_nul 1 if the domain is not null bearing. 

A characteristic of the SAME support packages and their treatment of null values is the 
inability to preform the Ada assign procedure on variables of numeric, null bearing 
(cont ains_ nul 1) domains or subtypes. Therefore, if a numeric domain or subtype 
needs to be defined as null bearing, but the assign procedure will also be needed, use the 
null_and_not_null indicator. 

Examplc-> not null for a domain describing columns that are constrained to never 
contaTn a null value. 

5. Range_Start —A value representing the beginning of a domain’s range. For domains or 
domain subtypes of type char, int, or smallint, this value is always an numeric integer. For 
domains or domain subtypes of type real, decimal, or double_precision, this value is always 


page 16 


6/19/90 



CDRL2020 Contract F19628-88-D-0032A)002 LMSC-F376702 

USER’S MANUAL Section 3 Defining and Generating the Domains 

an numeric real. Domains of type enumeration have no ranges, but for enumeration domain 
subtypes, this value is one of the parent domain's enumerate values. 

Example-> 4 for a domain of type char describing columns will be at least 4 characters long 
or 5.5 for a domain of type decimal describing columns with a value of at least 
5.5. 

6. Range_St op —A value representing the end of a domain's range. 

Example-> 3 0 for a domain of type char describing columns will be no longer than 30 

characters long or 2 3.6 for a domain of type decimal describing columns with a 
value no higher than 23.6. 

7. Vais—The name of the enumerated type declaring all of the valid enumeration values for a 
domain of type enumeration. 

Example-> In type color_vals is (red, blue, green), color_vals is the name of the enumerated 
type, and thus, is the parameter value. 

3.4 J Generics for Char, Int, and Smallint Domains and Subtypes 

The Generate_Int Domain generic is used to define domains of type char, int, or smallint. 

Its genert^zed syntax Is: 

package A_Package_Name is new 

Secorjd_Le veI_Generic_Package_Na/ne. generate_int_domain 
(Domain_Name, Domain_^Type, Null__Indicator, 

Range_Start, Range_Stop ); 


Example -> 

package First is new Domain_l .generate_int_clomain 

(Employee_Id, int, null_and_not_null, 0, 999); 


Resulting generated domain definition-> 

type employee_id_not_null is new sql_int_not_null range 0..999; 
type employee_id_type is new sql_int; 
package employee_id_ops is new 

sql_int_ops(employee_id_type, employee_id_not_null); 


The Generate_Subint_Domain is used to deHne subtypes of type char, int, or small int Its 
generalized syntax is: 

package A_Package_Name is new 

Second_Level_Generic_Package_Name.generate jBubxnt_domain 
(Domain_Name, Domain_Based_On, ^omain_Type, 
Null_Indicator, Range_Start, Range_Stop ); 


6/19/90 


page 17 



LMSC-F376702 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 3 Denning and Generatmg the Domains 


CDRL 2020 


Example -> 

package Second is new domain_l.generate_£ub_domain 

(Id Over_50, Employee_Id, int, null_and_not_null, 50, 999); 


Resulting generated domain definition-> 

subtype id_over_50_not_null is employee_id_not_null 
range 51..100; 

subtype id_over_50_type is new employee_id_type; 
package id_over_50_ops is new 

sql_int_ops (id_over_50_type, id_over_50_not_null) ; 

3.43 Generics for Real, Decimal and Double_Precision Domains and Subtypes 

The Generate_Flt Domain is used for domains of type real, decimal, or double_precision. 
Its generalized syntax Is: 

package A_Package_Name is new 

Second_Level_Generic_Package_Name .generate_flt_domain 
(Domain_Name, Domain_Type, Null_Indicator, 
Range_Start, Range_Stop ); 


Example -> 

package Third is new Domain_l.generate_flt_domain 

(Weekly_Earnings, decimal, not_null, 0.00, 1500.00); 

Resulting generated domain definition-> 

type weekly_earnings_not_null is new sql_real_not_null 
range 0.00..1500.00; 

The Generate_Subf lt_Domain is used for subtypes of type real, decimal, or 
double_precision. Its generalized syntax is: 
package A_Package_Name is new 

Second_Level_Genezic_Package__Name.generate_ai3bflt_domain 
(Domain_Name, Domain_Based_On, Domain_Type, 
Null_Indicator, Range_Start, Range Stop); 


Example -> 

package Fourth is new Domain_l.generate_subflt_domain 

{Low_Earnings, decimal, not_null, 0.00, 500.00); 

Resulting generated domain definition-> 

subtype low_earnings_not_null is weekly_earnings_not_null 
range 0.00..500.00; 

3.4.4 Generics for Enumeration Domains and Subtypes 

The Generate_Enum_Domain is used for domains of type enumeration. Its generalized 
syntax is: 


page 18 


6/19/90 







CDRL2020 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 3 Defining and Generating the Domains 


LMSC-F376702 


type Vais is {Value_l, Value_2, Value_3, ...); 
package A_Package_Name is new 

Second_Level_Generic_Package_Name. generate_Bnym_domain 
(Vais, Domain_Name, Domain_Type, Null_Indicator) ; 


Example -> 

type Color_Vals is (red, white, blue); 

package Fifth is new domain_l.generate_enum_domain 

(Color_Vals, Colors, enumeration, null_and_not_null); 

Resulting generated domain definition-> 

type colors_not_null is (red, white, blue); 
package colors_ops is new 

sql_enumeration_pkg(colors_not_null); 
type colors_type is new colors_ops.sql_enumeration; 

The Generate_Subint_Domain is used for subtypes of type enumeration. Its generalized 
syntax is: 

package A_Package_Name is new 

Second_Level_Generic_Package_Name. geiierate_aub&n\m_domain 
(Domain_Name, Domain_Based_On, Domain_Type, Null__Indicator, 
"Range_Start”, "Range_Stop "); 

I Note; The range values for enumeration subtypes must in double quotes. [ 


Example -> 

package Sixth is new domain_l.generate_enum_domain 

(Colors_Not_Red, Colors, enumeration, null_and_not_null, 
"White", "Blue"); 

Resulting generated domain definition-> 

subtype colors_not_red_not_null is colors_not_null 
range white..blue; 

package colors_not_red_ops is new 

sql_enumeration_pkg(colors_not_red_not_null); 

type colors_not_red_type is new 

colors_not_red_ops.sql_enumeration; 


3.5 EXAMPLE DOMAIN DEFINITION PROCEDURE 

Given the parameters used in the SQL module shown in Table 3.2, seven domains can be 
defined. The code in Table 3.4 can be used to generate those domain definitions and was written 
using the template illustrated in Table 3.3 as a guideline. In essence, the code was written by fill- 
in-the-blank technique. 


6/19/90 


page 19 










LMSC-F376702 rontract F19628-88-0-0032/0002 

USER’S MANUAl >ectkHi 3 Defining and Generating the Domains 

Table 3.4. Example Domain Definition Procedure Oixi«__Domain 


— This procedure is used to define and generate abstract domains 

— corresponding to column types in the dixie_db data base. 

with abstract_domain_generator; 

with generator_support; use generator_support; 

procedure dixie_domain_view is 
type package_neimes is 

(dixie_employee_def_pkg, dixie_salary_def_pkg); 

package domjpacks is new abstract_domain_generator 
(package_names); 

begin 

declare 

type doms is (employee_id, name, address, weight); 

package domain_l is new domjpacks.generate_domainjpackage 
<dixie_employee_def_pkg, doms); 

package first is new domain_l.generate_int_domain 
(en:^loyee_id, char, not_null, 1, 5) ; 
package second is new doinain_l .generate_int_doinain 
(name, char, not_null, 1, 10); 
package third is new domain_l.generate_int_domain 
(address, char, not_null, 1, 30); 
package four is new domain_l.generate_flt_domain 
(weight, real, not_null, 0.0, 300.0); 


begin 

domain_l.start_generation; 

end; 

— Repeated Steps 5-8 below for the second domain package 
declare 

type doms is (title, points, salary); 

package domain_2 is new dom_packs.generate_domain__package 
(dixie_salary_def_pkg, doms); 


CDRL 2020 

View 


— step 1 

— Step 2 

— Step 3 

— Step 4 

— Step 5 

— Step 6 

— Step 7 


— Step 8 


page 20 


6/19/90 





CDRL 2020 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 3 Defining and Generating the Domains 


LMSC-F376702 


package five is new domain_2.generate_int_doinain 
(title, char, contains_null, 1, 15); 
package six is new doinain_2.generate_int_domain 
(points, int, null_and_not_null, 0, 99); 
package seven is new domain_2 .generate_flt_domain 
(salary, decimal, not_null, 0.00, 99000.00); 


begin 

domain_2.start_generation; 
end; 

dom_packs.generate_baae_specific; — Step 9 

end dixie domain view; 


3.6 RESULTS OF OPERATION 

The end results of the Dixie_Domain_View procedure are the generated domain packages, 
Dixie_Employee_Def_Pkg and Dixie_Salary_Def_Pkg, and the file 
Base_Specif icJDomains. Table 3.5 illustrates these generated products. 

Table 3.5. Generated Products 


Dlxln_KnployM_D«£_Pkg - Sp«cl£lc«tlon 

with sql_char_pkg; 

use 3ql_char_pkg; 

with sql_real_pkg; 

use 3ql_real_pkg; 

package dixie_employee_def_pkg is 

type employee_idnn_ba3e is new 3ql_char_pkg.sql_char_not_null; 
subtype employee_id_not_null is en:55lo,yee_idnn_base (1..5); 

type namenn_base is new sql_char_jpkg.sql_char_not_null; 
subtype name_not_null is namenn_ba3e (1..10); 

type addre3snn_base is new sql_char_pkg.3ql_char_not_null; 
subtype addre3s_not_null is addre33nn_ba3e (1..30); 

type weight_not_null is new sql_real_not_null 


6/19/90 


page 21 




LMSC-F376702 


Contracl F19628-88-D-0032/0002 

USER’S MANUAL Section 3 Defining and Generating the Domains 


CDRL 2020 


range 0.00000..300.00000; 
end dixie_en^loyee_def_pJcg; 

Dixl«_Salaxy_pe£__Pkg - Specification 

with sql_char_pkg/ 

use sql_char__pkg; 

with sql_int_pkg; 

use sql_int_pkg; 

with sql_real_pkg; 

use sql_real_pkg; 

package dixie_salary_def_pkg is 

type title_base is new sql_char_pkg.sql_char; 
subtype title_type is title_ba3e; 
type points_not_null is new sql_int_not_null 
range 0..99; 

type points_type is new sql_int; 
package points_ops is new 

sql_int_ops(points_type, points_not_null); 

type salary_not_null is new sql_real_not_null 
range 0.00000 .. 99000.00000; 

end dixie_salary_def_pkg; 

Base__Specl£lc_DoiBaln8 - Specification 

with generator_support; 

use generator_support; 

package base_specific_doinains is 

type base_specific_domain_types is (eii¥)loyee_id__not_null, name_not_null, 
address_not_null, weight_not_null, title_type, points_not_null, 
points_type, salary_not_null, null_doinain_type) ; 

type corresponding_concrete_types is (crnployee_id_not_null_char_5, 
naine_not_nul l_cha r_l 0, addres s_not_nul l_cha r_3 0, 
weight_not_null_real, title_type_char_15, points_not_null_int, 
points_type_int, salary_not_null_real); 


page 22 


6/19/90 



CDRL2020 


Contract Fl%28-88-D-0032/0002 

USER’S MANUAL Section 3 Defining and Generating the Domains 


LMSC-F376702 


type valid_ciomain_names is (ciixie_en^loyee_def_pkg, dixie_salary_def_pkg) ; 

type ops_packages is (points_ops); 

longest_en\ini_value : constant integer 0; 

type doinain__package_array is array (positive range <>) of 
valid_doinain_names; 

end base_specific_domains; 


These packages are to be compiled with no further coding. Once compiled, the domain packages 
are made available to the application programmer, and the Base^Specif ic_ Domains 
package is ready for input during interface definition and generanbn. 

3.7 SUMMARY 

In summary, the following tasks must be performed during domain definition and generation. 


Table 3.6. Tasks to be Performed During Domain Definition and Generation 


Tasks 

Outcome 

1. Create a working directory containing the 
compiled ADA/SQL binding tool. 


2. Using the SQL Module, determine the 
necessary domain definitions. 


3. Write an Ada procedure using 

Abstract_Domain Generator to 
describe the domains. TJse the template 
provided in Table 3.3. 


4. Compile and execute the procedure. 

Two or more files: the domain packages 
and the package 

Base_Specific_Domains. 

5. Compile the domain packages. 

Semantically correct SAME domains to 
suppon the application. 

6. Compile the package Base_ 

Specific_Domains for later input 

Semantically correct package describing the 
valid domains. 


6/19/90 


page 23 














CDRL 2020 


Contract F19628-88-D-0032/0002 
USER’S MANUAL 


LMSC-F376702 


Section 4 

Defining and Generating the Interface 


4.1 GENERAL PREPARATION 

After compiling the domain packages and the file Base_Speci f ic_Domains, the interface 
programmer compiles the packages Concrete_Package and Abstract_Inter face_ 
Generator. Both of these packages import the Base_Specif ic_Domains specification, 
and because the information in Base_Specif ic_Domains is specific to each set of domain 
packages, compilation of Abstract_Interface_Generator and Concrete_Package is 
required with every new Base_Specif ic_Doniains specification. After these compilations, 
the interface programmer is ready to begin interface definition. 

The programmer must refer to the SQL module to determine what Ada procedures will be 
ne^ed in the abstract interface to represent the SQL data manipulation statements in the concrete 
module. There is a one-to-one mapping between procedures in the concrete module and 
procedures in the abstract interface sp^ification. Central to interface definition is the mapping 
of each of the SQL statements in the SQL module to one of these Ada procedures. See 
Guidelines for the Use of the SAME [1] for further explanation. When the interface programmer 
writes the Ada procedure that generates the abstract interface, these Ada procedures and 
parameters will be described to generate the actual interface procedures and parameters. Table 

4.1 shows the SQL statement types, their matching Ada procedure, and the parameters and 
modes for each l^d of Ada procedure. 

At this time, the interface programmer is also responsible for providing access to DBMS 
enror/status calls from the application program. A feature of the SQL language provides that the 
execution of every SQL statement returns a status code, SQLCODE, indicating statement 
execution success or type of failure. Though there is a core of ANSI standard SQLCODE values, 
some additional v^ues are DBMS implementation dependent The programmer determines what 
types of errors are expected from the data base in the form of SQLCODE during application 
program execution. Each expected error and its SQLCODE should be mapped to an enumeration 
value representing that error. For example, if a fetch procedure is expected, occasionally, to 
fail to find row and return a SQLCODE value of 100, the enumeration value row_not_f ound 
could represent this error. An exception to this is the SQLCODE value for transa(mon success. 
This SQLCODE value should not lx represented because it is automatically provided by the 
interface. SAME also provides error pressing and recovery capabilities through two SAME 
packages, Sql Conununications_Pkg and Sql_Database_Error_Pkg. These packages 
can be mcxlifieH^ to meet the error processing requirements of the application. Instructions for 
modifying the packages for the Digital RDB DBMS are found in Section 6. 

4.2 INPUTS FOR INTERFACE DEFINITION AND GENERATION 

Based on SQL statements coded in the SQL nxxlule, the interface programmer has determined 
the actual Ada procedures, associated tow records or individual parameters, and error processing 
needed to generate the interface. At this point, a unique name should be determined for each 
procedure, row record and individual parameter that will be part of the interface. Next the 
interface programmer writes an Ada procedure. Interface_view, to create the abstract 


6/19/90 


page 25 





LMSC-F376702 


Contract F19628-88-D-0032/0002 

USER’S MANUAL SectHm 4 Dining and Generating the Interface 


CDRL 2020 


Table 4.1. S< 

[^L Statements and Corresponding Ada Procedure Kinds 

SQL Statement Type 

Ada Procedure Kind 

Ada Parameter Kind 

Mode 

CLOSE 

close 

none 


COMMIT 

conunit 

none 


DELETE (positioned! 

delete_positioried 

none 


DELETE (searched) 

delete_searched 

individual parameters 

in 

FETCH 

fetch 

row record* 

in out 

INSERT VALUES 

insert_values 

row record 

in 

INSERT (subquery) 

insert_subq[uery 

individual parameters 

in 

OPEN (cursor) 

open 

individual parameters 

in 

ROLLBACK 

rollback 

none 


SELECrr 

selec** 

row record 

in out 



individual parameters 

in 

UPDATE (positioned) 

update_positioned 

individual parameters 

in 

UPDATE (searched) 

update_searched 

individual parameters 

in 


* Row record is an Ada record in which each record component represents one of the columns of an SQL row 
record. A unique row record is not required for each (socedure (i.e. more than one procedure can take the 
same row recc^ as a parameter). 


** "Select" is a reserved word in Ada. 

interface. This procedure instantiates several layers of nested generics contained in 
Abstract_Interface_ Generator. When executed, it produces four text files: 

• The Ada specification and body (each a file) of the Abstract_Interf ace 

• The Ada specification of the Concrete_Interf ace 

• A text file, DBMS_Specific, that contains information needed to modify the concrete 
interface specification if any DBMS-required changes are needed. 

The following paragraphs provide the steps and guidelines for writing the Ada procedure. 

In ter fa ce_ Vi e w, that will generate these files. 

4.3 STEPS AND GUIDELINES FOR PROCEDURE Xnterfac»_Vi 0 w 

To define the interface, the interface programmer always follows the same basic steps. These 
steps take the form of writing an Ada procedure that instantiates each of the three levels of nested 
generic within the Abstract_Interface^Generator generic package. This does not 
mean that every procedure or generic package Is used but that at least one generic package in 
each level of the nesting must be instantiated. 


page 26 


6/19/90 




















































CDRL2020 Contract F19628-88-D-0032AXX)2 LMSC-F376702 

USER’S MANUAL Section 4 Defining and Generating the Interface 

The following numbered steps are described in the order in which the interface programmer 
writes the Ada code. Each step includes example code that implements the step and a complete 
procedure template, which also shows the steps, is shown in Table 4.2. Note that italics in^cate 
user-supplied names and values. Names can be any valid Ada name but must be used 
consistently throughout the procedure. 

Step 1. Import 3 packages: 

Base_Specif ic_Domains => contains declarations of all valid domain packages 
and domains. This package must always be imported. 

Abstract_Ir^terf ace_Generator => contains the generics that when 
instantiated generate the interface packages. This package must always be imported. 

Generator Support => contains common declarations (mostly enumerated types 
and constantsy. T^is package must always be imported. 

with base_specific_domains; use base_specific_domains; 

with abstract_interface_generator; 

with generator_support; use generator_support; 

Step 2. Create an Ada main procedure. 

procedure Interface_View is 
begin 

end Interface_View; 

Step 3. Within this procedure declare an enumerated type representing all valid names of the 
row records needed. 


Note: Duplicate record names are not allowed. 


type Record_Names is 

{Record_Namel, Record_Name2, Record_Name3, ...); 
Step 4. Declare an enumerated type representing all valid names of the procedures needed. 


Note: Duplicate procedure names are not allowed. 


type Procedure__Naines is 

(Procedure_Namel, Procedure_Name2, ...); 

Step 5. Declare an enumerated type representing all valid names of any errors expected by the 
user's application. These names will be mapped in the next step to specific SQLCODE 
values. 


Note: Each SQLCODE value expected requires its own named error, 
and duplicate error names are not allowed. Note also that the 
SQLCODE value for transaction success is not to be represented 
because it is automatically provided. 


6/19/90 


page 27 






LMSC-F376702 Contract F19628-88-D-0032/0002 CDRL2020 

USER’S MANUAL Section 4 Defining and Generating the Interface 

type Error_Names is 

(Error_Namel, Error_Uame2, Error_Name3, ...); 

Step 6. Instantiate the outermost generic package. 

Abstract_Interface_Generator with the following eight parameters: 

• Conorete_Name_String —a string representing the desired name of the 
concrete interface specification. This name will also appear as the filename. 

• Abstract_Name_String —a string representing the desired name of the 
abstract interface specification and body. This name will also appear as the 
filename (with appropriate extensions) for both files. 

• Dbms_Speci fi c String —a string representing the desired name of the 
dbms_specific text Hie. This name will appear as the filename (with the 
extension ". txt". 

• (1=> Domain^Packagel, 2=> Domain_Package2, 3=>....) —an 
array of the domain package names that will be used by tMs interface. These are 
the packages (generated by the steps in Section 4) containing the domain 
declarations. From now on, only the domains in these packages will be 
recognized as valid domains during elaboration of subsequent generics. 

• Recordjtiames — the previously enumerated type representing all valid row 
record names. Only these record names will be recognized as valid during 
elaboration of subsequent generics. 

• Procedure_Naines —the previously enumerated type representing all valid 
procedure names. Only these procedure names will be recognized as valid during 
elaboration of subsequent generics. 

• Error_Names —the previously enumerated type representing all valid error 
names. Only these error names will be recogmzed as valid during elaboration of 
subsequent generics. 

• (1=> Error_Valuel, 2=> Error Value2, 3=>....) — anarrayof 
integer values representing the SQLCOD£*values expected from the data base and 
corresponding to the errors named previously. The error values must be 
enumerated in exactly the same order as their corresponding errors were 
enumerated. 

Example: 

package Int_Packs is new abstract_interface_generator 
(” Concrete_Name_String”, "Abstract_Name_String‘', 
”Dbms_Specific_String*', (1=> Domain_Packagel, 2=> 
Domain_Package2, 3=>....) ,Record_Names, Procedure_Names, 
Error_Names, (1=> Error_Valuel, 2=> Error_Value2, 3=>....) 

Step 7. Steps 7 through 10 arc repeated once for each row record, Record_Namel, 

Record_Name2, etc., enumerated in Step 3. For each row record, declare an 


page 28 


6/19/90 



CDRL2020 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 4 Defining and Generating the Interface 


LMSC-F376702 


enumerated type representing the name of each component of the row record. Record 
component names should be descriptive of their corresponding SQL column. 

Note: If this record is to be used to track string truncation, the 

components must be named exactly the same as the corresponding 
component in the row record. 


declare 

type Rec_Components is 

(Component_Namel, Component_Name2, ...) ; 

Step 8. Instantiate a second-level generic package Record_Generator with 

• the type, Rec_Components, representing the components enumerated in the 
previous step 

• the name of the record firom the enunwrated list in Step 3 

• a boolean value indicating that the record is used for returning SQL indicator 
values to the application (true), or if it is used to store or fetch an SQL row 
(false). 

From now on, only these component names will be recognized as valid component 
names for this row record during elaboration of subsequent generics. 

package Rec_l is new Int_Packs.record_generator 

{Rec__Components, Record_Namel, true_or_^false_value ); 

Step 9. Step 9 is repeated once for each con^nent, Component_Namel, 

Component_Name2, etc., in a particular record and in the same order as the 
components are enumerated in Step 7. Instantiate a third-level generic package, 
Component_Generator, with two parameters. The first parameter is the record 
component's name from the set of names enumerated in Step 7. The second parameter 
is the component's domain type as declared in one of the domains packages of Step 6. 

If this record is to be used for tracking string truncation, however, the second 
parameter is not given. 

package Com_ll is new Pec_I.component_generator 
{Component_Namel, Component_Domain ); 

Repeat this step for the next component of this row record. 

Step 10. After defining all row records, invoke the procedure Generat e_Record. 
begin 

Rec_l.generate_record; 
end; 

Now, repeat Steps 7 through 10 for the next row record. 

Step 11. Step 11 is repeated once for each procedure, Procedure_Namel, Procedure_ 

Name2, etc., enumerated in Step 4. For each procedure, instantiate a second-level (and 
possibly third-level) generic package with parameters that describe the procedure and 
invoke the generic procedure Generate_Procedure. Which generic to instantiate 
and what parameters to use depend on whether the procedure itself has parameters. 

An example of each one of the two possible generic instantiations is shown here. 


6/19/90 


page 29 




LMSC-F376702 


Contract F19628-88-D-0032/0(X)2 

USER’S MANUAL Section 4 Defining and Generating the Interface 


CDRL 2020 


however, more detailed descriptions of each generic, along with parameter 
explanations, are found in the next section. 

For procedures without parameters. 
declare 

package Procedure_l is new 

I/it_Packs.procedure_without_parameters_generator 

(Procedure_Name, Procedure^Type, ”Concrete_Proc_Name"); 
begin 

Procedure__l . generate_procedure; 
end; 


— For procedures with parameters, 
declare 

type Abstract_Params is 

{Abs_Parameter_Namel, Abs_Parameter_Name2, 

•. • ); 

type Concrete_Params is 

(Conc_Paranieter_Namel, Conc_Parameter_Naine2, ...); 

package Procedure_2 is new 

Int_Packs.procedure_with_parameters_generator 
{Procedure_Name, Abstract_Params, 

Procedure_Type, 

" Conor ete_P rocJtJame”, Concrete_Params 
(l=>Error_l, 2=> Error_2, ...)); 
package Param_l is new 

Procedure_2.params_of__domain_type_generator 
{Ahs_Parameter_Name, Parameter_Type) / 
package Param_2 is new 

Procedure_2.params_of_record_type_generator 
(Abs_Parameter_Name, Record_Type ); 
package Param_3 is new 

Procedure_2.params_of_boolean_type_generator 
(Abs_Parameter_Name ); 
package Param_4 is new 

Procedure_2.params_of_error_conditions_generator 
(Abs Parameter Name ); 


begin 

Procedure_2.generate_procedure; 
end; 

Repeat this step for the next procedure. 

Step 12. After defining all row records and procedures invoke the generic procedure 
Generate_Interface. 

Int_Packs .generate_interface; 

Step 13. Compile the procedure and correct any indicated errors. 

Step 14. Execute the procedure. 


page 30 


6/19/90 




CDRL2020 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 4 Defining and Generating the Interface 


LMSC-F376702 


All of the Ada code required by Steps 1 through 12 is shown in template form in Table 4.2. 
When writing an interface definition and generation procedure, use this template as a guide, 
substimting desired names and values for any expressions in italics. 

Table 4.2. Interface Definition Template 


with base_3pecific_doinains; use ba3e_specific_doniains; — Step 1 

with ab3tract_interface_generator; 

with generator_support; use generator_support; 

procedure Interface_View is — Step 2 

type Record_Names is — Step 3 

{RecordJNamel, Record_Name2, Record_Name3, ...); 


type Procedure__Names is — Step 4 

{Procedure__Namel, Procedure_Name2, Procedure_Name3, ...); 

type Error__Names is — Step 5 

{Error_Namel, Error_tfame2, Error_Niune3, ...); 

package Int_Packs is new abstract_interface_generator — Step 6 

{”Concrete_Name_StriTg ", ''Abstract_Name_String'', 
”Dbms_Specifc__String ", 

(1“> Domain_Packagel, 2-> Domain_Package2, 

Record_Name3, Procedure_Names, Error_Ncunes, 

(1»> Error_Valuel, 2>-> Error Value2, 3=>....)); 


begin 


declare — Step 7 

type Rec_Components is 

{Coniponent_Namel, Conponent_Name2, Component_Name3, . . .) ; 

package Rec_l is new Jnt_Pac*s.record_generator — Step 8 

(Rec_Conponent3, Record_Namel, Rec^Indicator); 


package Com_ll is new nec_J .coniponent_generator — Step 9 

iComponent_Namel, CotnponentJDomain); 
package Com_12 is new Rec_l.component_generator 
(Component_Name2, Conponent_Domain ); 
package Com_13 is new Rec_l .coinponent_generator 
{Conponent_Name3, Conponent Domain ); 


6/19/90 


page 31 




LMSC-F376702 Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 4 Defining and Generating the Interface 

— Additional record components here... 

begin 

Aec_I.generate_record; 

end; 

— Additional row records here... 

— For procedures without parameters, 
declare 

package Procedure_l is new 

Jnt_Packs.procedure_without_parameter3_generator 

(Procedure_Name, Procedure_Type, ”Concrete_Proc_Nanie”); 

begin 

Procedure_l .generate_procedure; 
end; 


For procedures with parameters, 
declare 

type Abstract_Params is 

lAb3_Parameter_Uamel, AbaJPaTameter_Name2, ...); 
type Concrete_Params is 

(ConcJPazameterJtJamel, Conc_Parameter_Name2, . . .) ; 

package Procedure_2 is new 

Jnt_Packs.procedure_with_parameters_generator 

{Procedure_Naine, Abstract_Params, Procedure_Type, 

"Concrete_Proc_Name”, Concrete_Params, 

(l“>Error_l, 2-> Error_2, ...)); 

package Param_l is new 

Procedure_2.pararas_of_domain_type_generator 
{Ab3_Pazameter_Name, Parameter^Type ); 
package Param_2 is new 

Procedure_2 .param3_of_record_type_generator 
(Ab3_Parameter_Name, Record_Type ); 
package Param_3 is new 

Procedure_2.params_of_boolean_type_generator 
{Ab3_Parameter_Name) ; 
package Param_4 is new 

Procedure_2 .pa rams_o f_e rro r_conditions_gene ra t or 
(Abs Parameter Name ); 


CDRL2020 


— Step 10 


— Step 11 


page 32 


6/19/90 




CDRL2020 Contract F19628-88-D-003:a0002 LMSC-F376702 

USER’S MANUAL Section 4 Defining and Generating the Interface 

— Additional parameters here... 

begin 

Proceriure_2 . gener ate_procedure; 

end; 

— Additional procedures here... 

Xnt_Pac*s.generate_interface; — Step 12 

end Interface View; 


4.4 DETAILED DESCRIPTION OF PROCEDURE GENERICS 

As shown previously, there are two types of procedure definition generics, one for procedures 
with parameters and one for procedures without parameters. An ^ditional third-level generic is 
used for procedures with parameters to define each of the procedure parameters. Refer to Table 

4.1 for a listing of procedures that take parameters. Descriptions, syntactic and semantic 
guidelines, and examples of the two types of procedure generics are provided below. 

4.4.1 Procedures without Parameters 

The generic Procedure_Without_Parameters Generator is used to generate the Ada 
procedures corresponding to the SQL statements that do not take parameters, such as procedure 
commit. This generic is instantiated with three parameters: 

• Procedure__Name —a procedure name from the previously enumerated list of procedure 
names represented by the type Procedure_Names in Paragraph 4.3, Step 4. 

• Procedure_Type —the t;^ of procedure, such as update_positioned, or close. 
Table 4.1 shows the 12 possible procedure types. 

• Con ere t e_Pro c_Name —a string in double quot;s representing the name of the 
corresponding procedure in ’he SQL module. The abstract procedure name and the concrete 
procedure name do not have to be the same. 

Following each instantiation of this generic, invoke the generic procedure Generate_Procedure. 
The generalized syntax is: 

declare 

package Procedure_l is new 

Ibt_Packs.procedure_without_parameters_generator 
{Procedure_Name, Procedure_Type, "Concrete Proc Name"); 

begin 

Procedure_l .generate_procedure; 
end; 

Example -> 
declare 

package Prod is new 

Int_Packs.procedure_without_parameters_generator 
(Start_Over, Rollback, "Rollback_Transaction"); 


6/19/90 


page 33 




LMSC-F376702 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 4 Defining and Generating the Interface 


CDRL 2020 


begin 

Prod.generate_procedure; 
end; 

4.42 Procedures with Parameters 

The Procedure_With_Parameters_Generator is used to generate the Ada procedures 
corresponding to the SQL statements that do take parameters, such as procedure fetch. When 
defining the Ada procedures with parameters, it is not necessary to inthcate parameter mode. All 
modes are automatically built into the abstract interface based on procedure kind (see Table 4.1). 
Defining procedures with parameters requires the following steps: 

Step 1. Declare an enumerated type representing the parameters for this specific abstract 

procedure. 

Note: Indicator parameters are not declared here since they are generated I 
automatically. ___ I 

Parameters can be: 

• A single parameter of domain type where that domain type is one of the domain 
types in the domain packages. 

• A record parameter of record type where that record type is one of the record types 
declared in Paragraph 4.3, Step 3 for a row record or string indicator record. 

Either: 

• A parameter of boolean type used to return a true or false value as SQL statement 
result information to the application. This boolean result parameter can either be 
mapped to one (and only one) of the expected errors or to no expected errors. In 
the ^t case, the result parameter will be returned automatically as false to the 
application if the Ada procedure's corresponding SQL statement returns the 
SQLCODE for that one expected error. In the second case, the result parameter 
will be returned automaticily as false to the application if the Ada procedure's 
corresponding SQL statement results in an SQLCODE value not ^ual to 0 (i.e., if 
the statement fails for whatever reason). In this instance, the application is only 
interested in pass/fail information, not the reason the statement failed. 

Or: 

• A parameter name to return an expected error (from the set of errors declared in 
Paragraph 4.3, Step 5). This error condition result parameter will be used to return 
the applicable error based on SQLCODE returned from the SQL statement. This 
parameter will be associated with a specific subset of expected errors in the 
following Step 3. 

Note: Declaring both a boolean result parameter and an err^;r condition 

result parameter is not allowed. Duplicate parameter names are also 
not allowed. 


The generalized syntax is: 
declare 

type Abstract_Params is 

(AJbs Parameter Namel, Abs Parameter Name2, ...); 


page 34 


6/19/90 



CDRL 2020 


Contract F19628-88-D-0032A)002 

USER’S MANUAL Section 4 Defining and Generating the Interface 


LMSC-F376702 


Example -> 
declare 

type Proc2_Abs_Params is 

(Employee_Id, Personnel_Record, Row_Not_Found); 

Step 2. Next, declare an enumerated type representing the parameters to the corresponding 

concrete procedure in the SQL modide. Parameters must be listed in the same order as 
those in the SQL module procedure. Parameters can be: 

• A single domain type parameter from the list of abstract parameters. 

• A record component type parameter. If a record was one of the parameters to the 
abstract interface, then every component of that record must be represented by a 
separate component type parameter in this step. The record itself may not be used, 
only its separate components. 

Either: 

• The boolean type result parameter from the list of parameters represented by 
Abstract Params . 


Or: 

• The error condition type result parameter from the list of parameters represented by 
Abstract Params. 


Note: Duplicate parameter names are not allowed. 


The generalized syntax is: 
type Concrete_Params is 

{Conc_Parameter_Namel, Conc_Parameter_Name2, ...); 
Example -> 

type Proc2_Conc_Params is 

(Employee_Id, Name, Address, Id_Nuinber, 

Row_Not_Found); 

— Name, Address, Id_Number are the components of 
Personnel_Record. 

Step 3. Instantiate the Procedure_With_P3rameters_Generator with six parameters: 

• Procedure_Nam^ —the procedure name from the previously enumerated list of 
procedure names represent^ by the type Procedure_Names in Paragraph 4.3, 
Step 4. 

• Abstract Params —the enumerated type representing the procedure’s abstract 
parameters declared in step 1 above. 

• Procedure_Type —the type of procedure, such as update_posit ioned, or 
close. Table 4.1 shows the 12 possible procedure types. 


6/19/90 


page 35 





LMSC-F376702 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 4 Defining and Generating the Interface 


CDRL 2020 


• Concrete_Proc_Name —a string in double quotes representing the name of the 
corresponding procedure in the SQL module. The abstract procedure name and the 
concrete procedure name do not have to be the same. 

• Concrete Params —the enumerated type representing the procedure’s concrete 
parameters declared in Step 2. 

• (1=> Error_l, 2=> Error_2, ...)—any one of a number of errors 
expected from the data base. Each error must be of the valid errors declared in 
Paragraph 4.3, step 5. The error condition type result parameter in step 1 represents 
this error set. If a boolean type parameter was specific in the Ahstract_Params 
declaration of step 1, then eidier give only one expected error or give no errors. 

The generalized syntax is; 
package Procedure_2 is new 

Int_Packs,procedure_with_parameters_generator 
{Procedure_Name, Abstract_Parains, Procedure_Type, 

" Con ere t e_Proc_Name”, Concre t e_Params, 

(l=>Error_I/ 2=> Error_2, ...)); 

Example when Abstract_Params has an error condition type result parameter-> 
package Proc2 is new 

Int_Packs.procedure_with_parameters_generator 
(Fetch_On_Id, Abstract_Pars, fetch, "Id_Fetch", 
Concrete_Pars, (l=>row_not_found, 2-> bad_record)); 

Example when Abstract_Params has a boolean type result parameter (one error)-> 
package Proc2 is new 

Int_Packs.procedure_with_parameters_aenerator 
(Update_On_Id, Abstract_Pars, update, "Id_Update”, 
Concrete_Pars, (l=>row_not_found)); 

Example when Abstract_Params has a boolean type result parameter (no errors)-> 
package Prc';2 is new 

Int_Packs .procedure_with__paraineters_generator 
(Delete_On_Id, Abstract_Pars, delete, "Id_Delete", 
Concrete_Pars); 

Step 4. Next, instantiate one of four parameter generics for each parameter of the abstract 

procedure represented by type Abstract_Params. Which parameter generic used 
depends on parameter 

• For domain type parameters—instantiate the generic Params_Of_Domain__ 
Typ«_Generator with two parameters. The first parameter, Abs_ 
Parameter_Name, is the name of the parameter from the list represented by 
Abstract^Params. The second parameter, Parameter_Type, is the abstract 
domain type of this parameter. 

The generalized syntax is; 
package Param l is new 

Procedure_2 .params_of_domain_type_generator 
(Abs Parameter Name, Parameter JType)-, 

Example-> 


page 36 


6/19/90 




CDRL2020 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 4 Defining and Generating the Interface 


LMSC-F376702 


package First_Parameter is new 

Proc2.params_of_domain_type_generator 

(Employee_Id, Id_Numbers_Not_Null); 

• For record type parameters—instantiate the generic Params_0f_Record_ 
Type_Generator with two parameters. The first parameter, Abs_ 
Parameter_Name, is the name of the record from the list represented by 
Abstract_Params. The second parameter, Record_Type, is the record type 
of this parameter. The generalized syntax is: 

package Param_2 is new 

Procedure^ .params_of_record_type_generator 
(AbsJParameterName, Record_Type)\ 

Example-> 

package Second_Parameter is new 
Proc2.params_of_record_type_generator 

(PersonneLRecord, Employee_Rec_Type); 

• For boolean result parameters—^instantiate the generic Params_Of_BooIean_ 
Type_Generator with one parameter, Abs_Parameter_Name, the name of the 
parameter from the list represented by Abstract_Params. The generalized syntax 
is: 

package Param_3 is new 

ProcedMre_2.params_of_boolean_type_generator 

(Abf_Parameter_Name); 

Example-> 

package Third_Parameter is new 

Proc2.params_of_boolcan_type_generator 

(Employec_Exists); 

• For error condition result parameters—^instantiate the generic Params_Of_Error_ 
Conditions.Generator with one parameter, Abs_Parameter_Name, the name of the 
parameter from the list represented by Abstract!* arams. 

package Param_4 is new 

Procedure_2.patams_of_crror_conditions_generator 
{Abs Parameter Name ); 


Example-> 

package Fourth_Parameter is new 

Proc2.params_of_error_conditions_generator 
(Error_Result); 

Step 5. Following each complete procedure and parameters definition, invoke the generic 
procedure Generate_Procedure. This generalized syntax is: 

begin 

Procedure_2. generate_proceciure; 
end; 


6/19/90 


page 37 



LMSC-F376702 


Contract F19628-88-D-0032/0(X)2 

USER’S MANUAL Section 4 Defining and Generating the Interface 


CDRL 2020 


Example -> 
begin 

Proc2.generate_procedure; 
end; 


4.5 EXAMPLE INTERFACE DEFINITION PROCEDURE 

Given the procedures and parameters used in the SQL module shown in Table 3.1, eight 
procedures and two row records require definition. The code in Table 4.3 can be used to 
generate an interface for those procedures and was written using the template illustrated in Table 
4.2 as a guideline. As with the domain definition procedure, the code was written by fiU-in-the- 
blank technique. 


Table 4.3. Example Interface Definition Procedure Dixie_Interface_View 


— This procedure is used to define and generate the abstract interface 

— corresponding to the SQL statements in the SQL module dixie cone interface. 


with base__specific_domains; use base;__specific_domains; — Step 1 

with abstract__interface_generator/ 

with generator_support; use generatot_8upport; 

procedure dixie_interface_view is — Step 2 

type the_record3 is (en^_rec, sal_rec); — Step 3 


type the_procedures is (startup, open_emp_cur3or, — Step 4 

ert¥)_fetch, new_sal_row, add_year, 
k:eep_it, trash_it, close_emp_cursor) ; 

type the_errors is (row_not_found, cursor_already_open, — Step 5 

no_duplicates, cursor_not_open); 

package make_int6rface is new ab3tract_interface_generator — Step 6 

("dixie_conc_interface", "dixie_abs_interface", 

"dixie_dbms_specific", 

(l-> dixie_errployee_def_pkg, 2-> dixie_salary_def_pkg), 
the_record3, the_procedures, the_errors, 

(l-> 100, 2-> 1001, 3-> -803, 4-> -501)); 


page 38 


6/19/90 






CDRL2020 


Contract Fl%28-88-D-0032/0002 

USER’S MANUAL Section 4 Defining and Generating the Interface 


LMSC-F376702 


begin 

declare 

type rec_conp3l is (einp_id, einp_la3tname, en¥>_firstname, 

einp_addres3, einp_weight) ; 

package reel is new make_interface.record_generator 

(rec_con^3l, einp_rec, false) ; 

package comp_ll is new reel .coinponent_generator 
(emp_id, employee_id_not_null); 
package coit^_12 is new reel .con^onent_generator 
(emp_lastname, naine_not_null) ; 
package comp_13 is new reel .coinponent_generator 
{einp_f irstname, name_not_null) ; 
package comp_14 is new reel .coniponent_generator 
(einp_address, addres3_not_null) ; 
package comp_15 is new reel .coinponent_generator 
(einp_weight, weight_not_null); 

begin 

reel•generate_record; 

end; 

— Repeated Steps 7-10 below for the second record 
declare 

type rec_comps2 is {new_en^_id, new_emp_sal, new_emp_pts); 

package rec2 is new make_interface.record_generator 

(rec_con?)s2, sal_rec, false) ; 

package con^_21 is new rec2.con?>onent_generator 

(new_en?>_id, einployee_id_not_null) ; 
package coinp_22 is new rec2 .coitponent_generator 

(new_en 5 )_sal, salary_not_null); 
package con:p_23 is new rec2 .coniponent_generator 

(new_enp_pts, points_type); 

begin 

rec2.generate_record; 

end; 


— Step 7 


— Step 8 


— Step 9 


— Step 10 


6/19/90 


page 39 




LMSC-F376702 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 4 Defining and Generating the Interface 


CDRL 2020 


declare — Step 11 

package prod is new 

inake_interface .procedure_without_paraineters_generator 
(startup, connnit, ”set_transaction") ; 

— The set transaction SQL procedure is only used with the RDB DBMS. 

— Therefore, it is not one of the standard SQL statement types and has 

— no corresponding ada procedure kind. "commit" can be used though 

— because it too is a kind of procedure without parameters like set 

— transaction, 
begin 

prod .generate_procedure; 

end; 

— Repeated step 11 for seven additional procedures 
declare 

package proc2 is new 

make_interface.procedure_without_parameters_generator 
(keep_it, commit, "commit_transaction"); 

begin 

proc2.generate_procedure; 

end; 

declare 

package proc3 is new 

niake_interface .procedure_without_parameters_generator 

{close_eii?J_cursor, close, "close_emp_cursor") ; 

begin 

proc3.generate_procedure; 

end; 

declare 

package proc4 is new 

niake_interface.procedure_without_parameters_generator 

<trash_it, rollback, "rollback_transaction"); 

begin 

proc4.generate_procedure; 

end; 


page 40 


6/19/90 




CDRL2020 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 4 Defining and Generating the Interface 


LMSC-n76702 


declare 

type abs_params5 is (in_en¥>_id, result); 
type con._parains5 is (in_eiip_id, result) ; 

pacicage procS is new make_interface.procedure_without_parameters_generator 
(open_emp_cursor, abs_pareuns5, open, "open_eirqployees_cursor", 
con_paranis5, (1“> cursor_already_open)) ; 

package paramSl is new proc5.par^^ns_of_domain_type_generator 
(in_emp_id, einployee_id_not_null) ; 
package param52 is new proc5.parains_of_error_conditions_generator 
(result); 

begin 

proc5.generate_procedure; 

end; 

declare 

type absjparamse is {fetch_rec, fetch_done); 
type conjparamsS is { eirp_id, enqp_lastname, 

enp_firstname, erp_address, ernp_weight, fetch_done) ; 

package proc6 is new make_interface.procedure_with_paraineters_generator 
(en¥'_fetch, abs_parains6, fetch, "fetch_einployees", 
con_param36, (1”> row_not_found, 2“> cur 3 or_not_open)); 
package param61 is new proc6.parains_of_record_type_generator 

(fetch_rec, emp_rec); 

package parain62 is new proc6 .parains_of_error_conditions_generator 

(fetch_done); 

begin 

proc 6.generate_procedure; 
end; 

declare 

type abs_parains7 is (insert_rec, insert_done); 

type con_params7 is (new_enip_id, new_einp_sal, new_emp__pts, in 3 ert_done) ; 

package proc7 is new make_interface.procedure_with_parameter3_generator 
(new_sal_row, abs_params7, in3ert_values, "insert_ 3 al_hi 3 t_row", 
con_parains7, (l-> no_duplicate3)); 


6/19/90 


page 41 




LMSC-F376702 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 4 Defining and Generating the Interface 


CDRL 2020 


package parain71 is new proc7 .parain3_of_record_type_generator 
(insert_rec, 3al_rec); 

package param72 is new proc7 .params_of_error_conciitions_geiifcrator 
(in3ert_done); 

begin 

pEOc7.generate_procedure; 

end; 

declare 

type ab3_params8 is {in_ert^_id, change_done) ; 
type conjparamsS is (in_eit¥>_id, change_done) ; 

package proc8 is new make_interface.procedure_with_parameters_generator 
(add_year, abs_paranis8, update_searched, "update_job_hi3t'’, 
con_params8) ; 

package parain81 is new proc8 .parajns_of_domain_type_generator 
(in_emp_id, einployee_id_not_null) ; 
package parain82 is new proc8.params_of_boolean_type_generator 
(change_done); 

begin 

proc8.generate_procedure; 

end; 

niake_interface.generate_interface; — Step 12 

end Dixie Interface view; 


4.6 RESULTS OF OPERATION 

The results of executing the Dixie_Inter f ace_View procedure are the generated abstract 
interface speciHcation and body, Dixie_Abs_Interf ace, the Ada specification of the SQL 
module, Dixie_Conc_Interface, and the text file Dixie_Dbms_Specif ic . Table 4.4 
illustrates these generated products. 


page 42 


ei\9l90 




CDRL2020 Contract Fl%28-88-D-0032/0002 

USER’S MANUAL Section 4 Dcfiniog and Generating the Interface 

Table 4.4. Generated Products 
Dixie_Abs_Interface - Specification 

with dixie_einployee_def_pkg; 
use dixie_en^loyee_def_j5kg; 
with dixie_salary_def_pkg; 
use dixie_salary_def_pkg; 
with sql_3tandard; 
use sql_standard; 
package dixie_abs_interface is 

type valid_status_result_type is 

(row_not_found, cursor_already_open, no_duplicates, cursor 

type einp_rec is record 

einp_id : einployee_id_not_null; 
eit53_lastname : naine_not_null; 
en^_firstname : name^not_null/ 
eir55_address : address_not_null; 
emp_weight : weight_not_null; 
end record; 

type sal_rec is record 
new_en?j_id : einployee_id_not_null; 
new_einp_sal : salary_not_null; 
new_en 5 J_pts : points_type; 
end record; 

procedure startup; 

procedure keep_it; 

procedure close_emp_cursor; 

procedure trash_it; 

procedure open_enp_cursor(in_emp_id : in employee_id_not_null; 
result : out valid_3tatus_result_type); 


LMSC-F376702 


not_open); 


6/19/90 


page 43 




LMSC-F376702 Contraa F19628-88-D-0032/0002 

USER’S MANUAL Sectkm 4 Defining and Generating the Interface 

procedure en^_fetch (fetch_rec : in out einp_rec; 

fetch_done : out valid_statu3_re3ult_type); 

procedure new_3al_row(in3ert_rec : in 3al_rec; 

in3ert_done : out valid_3tatu3_re3ult_type); 
procedure add_year (in_enp_id : in eir¥>loyee_id_not_null/ 
change_done : out boolean); 

end dixie_ab3_interface; 

Dixie_Abs__Znterface - Body 

with sql_coinmunication3_pkg, 3ql_databa3e__error_p)cg, converaions, 
dixie_conc_interface; 

U3e sql_communication3_pkg, 3ql_databa3e_error__pkg, converaions; 
package body dixie_ab3_interfav-e ia 
uae point3_op3; 

row_not_found_value : conatant :■ 100; 

our3or_already_open_value : conatant 1001; 
no_duplicate3_value : conatant -803; 
cur3or_not_open_value : conatant -501; 

procedure atartup ia 
begin 

dixie_conc_interface.3et_tran3action (aqlcode); 
if aqlcode /- 0 then 
proce33_databa3e_error; 
raiae 3ql_databa3e_error; 
end if; 
end atartup; 

procedure keep_it ia 
begin 

dixie_conc_interface.commit_tran3action (aqlcode); 
if aqlcode /- 0 then 


CDRL 2020 


page 44 


6/19/90 



CDRL2020 


Contract Fl%28-88-D-0032/0002 

USER’S MANUAL Section 4 DeHning and Generating the Interface 


LMSC-F376702 


proces3_databa3e_error; 
raise sql_databa3e_error; 
end if; 
end keep_it; 

procedure close_emp_cur3or is 
begin 

dixie_conc_interface.close__enp_cur30r (sqlcode); 
if sqlcode /- 0 then 
process_database_error; 
raise sql_databa3e_error; 
end if; 

end close__enp_cursor; 

procedure trash_it is 
begin 

dixie_conc_interface.rollback__transaction (sqlcode); 
if sqlcode /- 0 then 
proce3s_databa3e_error; 
raise sql_database_error; 
end if; 
end trash it; 


procedure 


begin 


open_einp_cur3or (in_eny_id : in einployee_id not null; 

result : out valid_status_result_type) 


is 


dixa.e__conc_interface.open_en?)loyees_cur3or (char (in_einp_id), sqlcode) ; 
if sqlcode - cursor_already_open_value then 
result cursor_already_open; 
elsif sqlcode /- 0 then 


proces3_database_error; 
raise 3ql_database__error; 
end if; 

end open_einp_cur3or; 


6/19/90 


page 45 



LMSC-F376702 Contract F19628-88-D-0032/0002 CDRL2020 

USER’S MANUAL Section 4 Defining and Generating the Interface 

procedure emp_fetch (fetch_rec : in out einp_rec; 

fetch_done : out valid_status_result_type) is 

begin 

dixie_conc_interf ace. fetch_einployee3 (char (fetch_rec .eit^_id), 

char (fetch_rec .einp_lastname), char (fetch_rec .einp_f irstname), 
char(fetch_rec.emp_addre3s), real(fetch_rec.emp_weight), sqlcode); 
if sqlcode - row_not_found_value then 
fetch_done row_not_found; 
elsif sqlcode = cur3or_not_open_value then 
fetch_done :• cursor_not_op€n; 
elsif sqlcode /■ 0 then 
proces3_databa3e_error; 
raise sql_database_error; 
end if; 

end emp_fetch; 

procedure new_sal_row(insert_rec : in sal_rec; 

insert_done : out valid_statu3_result_type) is 
new_empjpts_c : int; 
new_en^_pt3_indic : indicator_type; 
begin 

if i3_null (insert_rec. new_en?5_pts) 
then new_eit¥)_pts_indic -1; 
else new_en^_pts_indic 0; 

new_en^5_j>ts_c int (without_null_base (insert_rec .new_einp_pt3)) ; 
end if; 

dixie_conc_interface.inaert_sal_hi3t_row (char{insert_rec.new_emp_id), 
real (insert_rec. new_en53_sal), new_einp_pt3_c, new_emp_pts_indic, 
sqlcode); 

if sqlcode - no_duplicates_value then 
insert_done no_duplicates; 
elsif sqlcode /- 0 then 

process_database_error; ’’ 

raise sql_database_error; 
end if; 

end new sal row; 


page 46 


6/19/90 


CDRL2020 


Contract F19628-88-D-0032/0002 

USER’S MANUAL Section 4 DeHning and Generating the Interface 


LMSC-F376702 


procedure add_year (in_eiTp_id : in einployee_id_not_null; 

change_done : out boolean) is 

begin 

dixie_conc_interface.update_job_hi3t ( char(in_en^_id), sqlcode); 
if sqlcode /- 0 then 
change_done false; 
else change_done true; 
end if; 
end add_year; 

end dixie abs interface; 


DixiajConc__Interfaca - Sp«cification 

with 3ql_standard; use sql__standard; 
package dixie_conc_interface is 

procedure set_transaction(sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql/ 3et_tran3action); 

procedure coinmit_tran3action(sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, commit_transaction); 

procedure clo3e_en^_cur3or(sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, clo3e_en^_cursor); 

procedure rollback_tran3action(sqlcode : out sql_3tandard.sqlcode_type); 
pragma interface (sql, rollback_transaction); 

procedure open_eiiployees__cur3or (in_en^_id: in char; sqlcode : out 
3ql_standard.3qlcode_type); 
pragma interface (sql, open_ertq3loyee3_cursor) ; 

procedure fetch_employees( emp_id: in out char; emp_la 3 tname: in out char; 
emp_firstname; in out char; emp_address: in out char; 
emp_weight: in out real; 
sqlcode : out sql_standard.sqlcode_type); 


6/19/90 


page 47 



LMSC-F376702 


Contract F19628-88-D-0032AX)02 

USER’S MANUAL Section 4 Defining and Generating the Interface 


CDRL 2020 


pragma interface (sql, fetch_einployee3) ; 

procedure insert_sal_hist_row( new_en^_id: in char; new_eTnp_3al: in real; 
new_emp_pts : in out int; 

new_emp_jpts_indic : in 3ql_standard.indicator_type; 
sqlcode : out 3ql_3tandard.3qlcode_type); 
pragma interface (sql, in 3 ert_sal_hist_row); 

procedure update_job_hi3t(in_emp_id: in char; 

sqlcode : out 3ql_standard.3qlcode_type); 
pragma interface (sql, update_job_hi3t); 

end dixie_conc_interface; 

Dixie__Dbms_Specific - Text File 

set_tran3action sqlcode out 3qlcode_type 
commit_transaction sqlcode out sqlcode_type 
close_en?5_cursor sqlcode out sqlcode_type 
rollback_transaction sqlcode out sqlcode_type 
open_employee3_cursor in_emp_id in char 5 
open_employee3_cur3or sqlcode out sqlcode_type 
fetch_employee3 emp_id in_out char 5 
fetch_employee3 en¥)_la3tname in_out char 10 
fetch_en^loyees emp_firstname in_out char 10 
fetch_enployee3 en¥>_addre33 in_out char 30 
fetch_en 5 )loyees emp_weight in_out real 
fetch_employees sqlcode out sqlcode_type 
insert_sal_hist_row new_emp_id in char 5 
in3ert_3al_hist_row new_eii:¥’_s®l in real 
in3ert_sal_hist_row new_eitp_pt3 in_out int 
in3ert_3al_hi3t_row new_emp_pts_indic in indicator_type 
insert_3al_hist_row sqlcode out 3qlcode_type 
update_job_hist in_emp_id in char 5 
update_job_hist sqlcode out sqlcode_type 


page 48 


6/19/90 








CDRL2020 Contract F19628-88-D-0032/0002 LMSC-F376702 

USER’S MANUAL Section 4 Denning and Generating the Interface 

These packages are to be compiled with no further coding. If DBMS specific modifications are 
required for die interface due to DBMS implementation incompatibilities with the SAME 
standard, the text file containing information needed for these modifications and the interface 
packages are handed over to the person responsible for such modifications. Steps and guidelines 
for modifying the interface packages for use with the Digital RDB DBMS are provided in 
Section 6. If no modifications are required, then link the concrete interface specification to the 
SQL module. Steps for associating the concrete interface Ada specification to the SQL module 
are implementation dependent Section 6 contains instructions for linking using the Digital ACS 
Ada language facility. After linking the specification to the module, make the interface packages 
available to the application programmer. 

4.7 SUMMARY 

In summary, the tasks shown in Table 4.5 must be performed during interface definition and 
generation. 


Table 4.5. Task Summary 


Task 

Outcome 

1. Compile both specification and body of 
Concrete_Package andAbstract_ 
Interface_Generator against 

Base Specific Domains. 

Concrete_Package andAbstract_ 
Interface_Generator compiled with 
the valid domains. 

2. Using the SQL module, determine the 
necessary row records, procedures and 
expected errors. 


3. Modify the SAME packages 

Sql_Communications_Pkg and 

Sql Database_Error_Pkg for use 
with'Die DBMS and application (See DEC 
instructions in Section 6). 

DBMS and application specific error 
processing and recovery capabilities. 

* 

4. Write an Ada procedure using 

Abstract Interface Generator 
to describe the interface. Use the template 
provided in Table 4.2. 


5. Compile and execute the procedure. 

I^our files; (1) the abstract interface 
specification, (2) the abstract interface body, 

(3) the concrete interface specification, and (4) 
a text file contairung information needed to 
modify the generate interface for a particular 
implementation 

6. Compile the interface packages. 

Potentially semantically correct abstract 
interface and concrete interface specification 
to support the application. 

7. If necessary, modify the interface for use 
with a specific DBMS using the DBMS 
specific file. (See DEC instructions in 
Section 6). 

DBMS-compatible interface packages. 

8. Link the concrete interface 

Application specific SAME interface 
specification to the SQL module.(See DEC 
instructions in Section 6). 


6/19/90 


page 49 






















CDRL2020 


Contract F19628-88-D-0032/0002 
USER’S MANUAL 


LMSC-F376702 


Section 5 

Usage Instructions for the Application Programmer 


5.1 GENERAL PREPARATION 

At this stage, the application progranuner has the compiled versions of the domain package 
specifications; the abstract interface specification and body, the concrete interface specification 
and the compiled, linked SQL module. The programmer is now ready to use these packages with 
the Ada application. 

5.2 INPUTS FOR THE ADA APPLICATION PROGRAM 

Given the Ada procedures in the abstract interface and their corresponding data manipulation 
statements in the SQL module, the application programmer now has access to the DBMS through 
the application. During application development, the programmer can use any of the procedures 
provided by the interface just as any other standard A^ procedure or function. However, all 
parameters to these procedures must be of a type declared in one of the domain packages or in 
the abstract interface, or of type boolean. 

The following paragraphs provide the steps nd guidelines for writing an Ada application, 
Ada_Application, that uses a SAME interface. 

5.3 STEPS AND GUIDELINES FOR THE ADA APPLICATION 

To use a SAME interface, the application programmer always follows the same basic steps. 

These steps take Ae form of writing an Ada application that imports one or more domain 
packages containing data types and the newly generated abstract interface. 

The following numbered steps are described in the order in which the application programmer 
^tes the Ada code. Where appropriate, each step includes example code, and in some 
instances, specific code that implements the step. A gener^zed Ada application, also showing 
the steps, is shown in Table 5.1. Note that italics indicate user-supplied names. Names can be 
any valid Ada name but must be used consistently throughout the procedure. 

Step 1. Import 2 or more packages: 

Domain Definition_Pkg(s) => One or more packages containing declarations 
of valid domains. Name and content of this package(s) is determined by die interface 
programmer. This package(s) must always be imported. 

t ra ct_In t erfa ce(s) => One or more packages containing the abstract 
interface portion of the SAME interface created for this application. 

Name and content of this package(s) is determined by the interface programmer. This 
package(s) always be impOTted. 

with domain_definition_jpkg_l; use domain_definition_pkg_l; 
with domain_definition_pkg_2; use domain_definition_pkg_2; 


6/19/90 


page 51 



V 


LMSC-F376702 Contract F19628-88-D-0032/0002 CDRL2020 

USER’S MANUAL Section 5 Usage InstnictioDS for the Application Programmer 

with domain_definition_pkg__3; use domain_definitionjpkg_3; 
— Additional domain packages here... 
with abstract_interface_l; use abstract_interface_l; 
with abstract_interface_2; use abstract_interface_2; 

— Additional abstract interfaces here... 

Example-> 

with parts_definition_pkg; use parts_definition_pkg; 
with supplier_definition_pkg; use supplier_definition_pkg; 
with product_abs_interface; use product_abs_interface; 

Step 2. Create an Ada main procedure. 

procedure Ada_App Heat ion is 
begin 

end Ada_Application; 

Step 3. Within this procedure declare all interface-required row records or string indicator 

records to be used by interface procedures tal^g row records as parameters. All valid 
row record types are declared in the abstract_interface specification. 

declare 

Row_Record_Namel : Row__Record_Typel; 

Row_Record_Name2 : Row_Record_Type2 ;... 

Example-> 

Parts_Record : Parts__Record_Type; 

Northern_Supplier__Record ; Supplier_Record_Type; 

Step 4. Declare all interface-required single parameters of domain type to be used by interface 
procedures taking single, domain-ba^ parameters. All valid domain types are 
declared in the domain packages. If one of the SAME standard types’ assign 
procedures will be used on a parameter of a null bearing domain type, you must declare 
another parameter of the corresponding not-null bearing domain type for conversion 
use (see Paragraph 3.4.1). 

Domain_Parameter_Namel : Domain_Typel; 
Domain_Parameter_Name2 : Domain_Type2 ;... 

Example-> 

declare 

Part_Name : Product_Name_Not_Null; 

Part_Price ; Part_Price_Type;— Null bearing numeric domain 
Part_Price_nn ; Part_Price_Not_Null;—Conversion parameter 

Step 5. Declare all interface-required error condition result parameters. These result 

parameters will be used by the interface procedures to return expected error conditions 
to the application. Error condition result parameters are always <Jf type 
Valid_Status_Result_Type. 

ErrorJtJamel : Valid_Status_Result_Type; 


page 52 


6/19/90 




CDRL2020 Contract F19628-88-D-003Z/0002 LMSC-F376702 

USER’S MANUAL Section 5 Usage Instructions for the Application Programmer 


Error_Name2 : Valid_Status_Result_Type;... 

Example-> 

Result1 : Valid_Status_Result_Type; 

Result2 : Valid_Status_Result_Type; 

Step 6. Declare all interface-required parameters of boolean tj^ to be used by interface 
procedures returning result information to the application. 

Boolean_Result_Namel : Boolean; 

Boolean_Result_Name2 ; Boolean;... 

Example-> 

Part_Exists : Boolean; 

Positive_Result : Boolean; 

Step 7. Make all other application-required declarations and then begin coding the rest of the 
application, callmg the interface procedures when needed as you would any other 
standard Ada procedures. Invalid interface procedure syntax and semantics will be 
caught during application compilation. 

Step 8. Compile the application and correct any indicated errors. 

Step 9. Execute the application. 

All of the interface-required Ada code for this application is shown in a generalized form in 
Table 5.1. When writing an Ada application using a SAME interface, use this table as a guide 
substituting required names and values for any expressions in italics. 

Table 5.1. Generalized Ada Application 


with cioinain_definition_pkg_l; use doinain_defihition_pkg_l/ — Step 1 

with domain_definition_pkg_2; use domain_definition_pkg_2; 
with domain_definition_pkg_3; use domain_definition_pkg_3; 

— Additional domain packages here... 

with ai}Stract_interface_l: use abstract_interface_l; 
with abstract_interface_2; use ab3tract_interface_2; 

— Additional abstract interfaces here... 

procedure Ada_Application is — Step 2 

declare 

Row_Record__Namel : Row_Record_Typel; — Step 3 


Row_Record_Name2 : Row_Record_Type2 :... 

— Additional record type declarations here... 


6/19/90 


page 53 




1 


LMSC-F376702 Contraa F19628-88-D-0032/0002 CDRL2020 

USER’S MANUAL Section 5 Usage Instructions for the Application Programmer 


Domain_Parameter_Namel : Domain_Typel: — Step 4 

Domain_Parameter_Name2 : Domain_Type2:... 

— Additional domain type declarations here... 

Error_Namel : Valid_Statu3_Re3ult_Type; — Step 5 

Error_Name2 : Valid_Statu3_Result_Type;... 

— Additional expected error type declarations here... 

Boolean_Result_llamel : Boolean; — Step 6 

Boolean_Result_Name2 : Boolean;... 

— Additional boolean result type declarations here... 

— Additional application-required declarations here... — Step 7 

begin 

— Application statements and calls to interface procedures here... 
end Ada_Application: 


5.4 SAMPLE ADA APPLICATION 

The SQL module shown in Table 3.1, the generated abstract domain packages shown in Table 
3.4, and the generated abstract interface and concrete interface specification shown in Table 4.4 
together provide the interface support for the Ada application shown in Table 5.2. The 
procedures in the abstract interface appear in bold-f^e type within the application body. 

Table 5.2. Sample Ada AppHcatitm Dixio__Application 


— This application inports the abstract inte ace dixie_abs_interface 

— and the abstract domain packages to access the dixie_db data base. 

with dixie_eitployee_def_pkg; use dixie_employee_def_pkg; — Step 1 

with dixie_salary_def_pkg; use dixie_salary_def_pkg; 

with dixie_ab3_interface; use dixie_abs_interface; 

with text_io; use text_io; 

with string_pack; use string_pack; 

procedure dixie_application is — Step 2 

per3onnel_record ; emp_rec; — Step 3 

business record : sal rec; 


page 54 


6/19/90 





CDRL2020 ContraaF19628-88-D-0032/0002 LMSC-F376702 

USER’S MANUAL Sectioii 5 Usage Instrnctioiis for the Applicatioo Programmer 


id_nuinber : eit 5 Jloyee_id_not_null; — Step 4 

— toerit_pts_nn is used for type conversion between the null bearing 

— points_type and the non null bearing points_not_null so that the 

— points_ops.assign procedure can be used on a variable of this type 
merit_pts_nn : points_not_null; 

error_result : valid_atatua_result_type; — Step 5 

boolean_result : boolean; — Step 6 

— Variables and instantiations for general program use -- Step 7 

valid_code : boolean false; 

option_entry : character; 
exit_code : constant character *8*; 
see_en55loy_code : constant character ’1'; 
add_job_code : constant character :■ *2’; 
new_sal_code : constant character *3*; 
coinnu.t_code : constant character '4*; 
rollback__code ; constant character *5'; 
release_screen : character; 

weight_image, string_holder : string(1..100) :■ (others -> ’ '); 
last : natural; 

trash ; string (1..1) (others -> • •); 

package integer_io is new text_io.integer__io (integer) ; 

package real_io is new float_io(float); use real_io; 

— This function gets the option code (either access dixie_db or exit 

— the program) from the user, 
function option_input return character is 

begin 

valid_code false; 
while not valid_code loop 
text_io.put_line(" "); 

put_line("Please enter an option number. Either: "); 
put_line("l : to view a record from the enployees table or"); 
put_line 

("2 : to add 1 year to years employed in the job_hist table or"); 
put_line("3 : to insert a new record into the salary_hist table"); 
put_line("4 : to commit the transaction"); 


6/19/90 


page 55 






LMSC-F376702 Comi»ctF19628-88-D-0032A)002 a)RL2020 

USER’S MANUAL Scctkw 5 Usage lastractioBs for the Appikatkm Programmer 


put_line{"5 : to rollback the transaction"); 
put_line{"8 ; to exit this program."); 
put_line(" "); 

put ("Enter option here «■> ") ; 
get (option_entry); 
text_io.get_line(trash, last); 
case option_entry is 

when see_employ_code «> valid_code true; 
when add_job_code “> valid_code :■ true; 
when new_sal_code •»> valid_code :* true; 
when coininit_code ■> valid_code true; 
when rollback_code ■> valid_code true; 
when exit_code -> valid_code true; 
when others *> 

put("Invalid option. Type 'C* and press <RET> to continue."); 
get(release_screen); 
end case; 
end loop; 

return option__entry; 
end option__input; 

begin 

— The main program will loop iintil the user requests option 8 or exit. 

put^line("**********Welcoine to the Dixie_Db update program**********"); 

put_line(" "); 

startup; 

loop 

if option_input <■ exit_code then 
exit ; 

elsif option_entry ■ aee_employ_code then 

put_line ("Please enter an ei^ployee id number ■>> "); 

string_holder (others -> ' '); 

text_io.get^line(string_holder, last); 

move(strip(string_holder), string(id_number)); 

op«n_jaaip_cur8or (ld_nuaibex, error__result) ; 

if error_result - cursor_already_open 

then close__aBp_eursor; 

text_io.put_line("Try again"); 
else eap_fetch(personnel_record, erxor_result); 
if error result ■ row not found 


page 56 


6/19/90 





CI«L2020 CoiUiactF19628^D-0032/0002 LMSC-F376702 

USER’S MANUAL Scctk»5 Usage laslractioas for the Application Programnwr 

then text_io.put_line("No en^loyee with this number found"); 
else real_io.put (weight_image» float (personnel_record.en 5 >_weight), 
2 , 0 ) ; 

text_io.put_line{atrip(string(peraonnel_record.enp_id)) & " " & 
strip(string(personnel_record.emp_lastname)) & " " & 
strip(string(personnel_record.en^_firstname)) & " " & 
strip(string(personnel_record.emp_address)) s " " & 
strip(weight_image)); 
end if; 
end if; 

clo8e_eatp_cuxsor ; 

put_line (" ") ; 

elsif option_entry - add_job_code then 

put_line ("Please enter an en^iloyee id nvunber -> ") ; 

atring_holdet (others ■> ' '); 

text_io.get_line(string_holder, last); 

move(strip(string_holder), string(id_number)); 

add year (ld_n\aDbex, boolean_xesult); 

put__line(" "); 

if boolean_result - false 

then text_io.put_line("Year not updated"); 

put_line(" "); 
end if; 

elsif option_entry - new_sal_code then 

put_line("Enter an enployee id number (5 characters) .. not null -> "); 
string_holder (others «> ' '); 

text_io.get_line(string_holder, last); 

move(strip(string_holder), string(business_record.new_enp _id)) ; 

put_line ("Enter earnings for employee (0.00 to 99000.00) .. not null ->" 

real_io.get(float(buainess_record.new_emp_sal)); 

text_io.get_line(trash, last); 

put_line 

("Enter merit points for employee (0 to 99) .. return for null -> "); 
string_holder (others ■> ' ’); 

text_io.get_line(string_holder, last); 
if last “0 — they are inputting a null 

then points_ops.assign(business_record.new_emp_pts, null_sql int); 
else 


6/19/90 


page 57 




LMSC-F376702 CoattaaF19628-88-D-0032/D002 CDRL2020 

USER’S MANUAL ScctkMiS Usage Instnictkms for the Applicatioo Programmer 


integer_lo.get (string_holder, integer (inerit_pts_nn), last) ; 
points_ops.assign(business_record.new_einp_pts, 

points_ops .with_null {inerit_pts_nn)) ; 

end if; 

neir_8al__row(busln«ss_recoxd, •rror__^result); 
put_line{" ") / 

elsif option_entry - coinmit_code then 
ke a p_ lt; 


elsif option_entry - rollbaclc_code then 
tra8h_it; 

end if; 
end loop; 

end dixie_application; 


SJ RESULTS OF OPERATION 

The Ada application using the generated domain packages and the abstract interface has access to 
an SQL m^ule and, through thk module, access to a DBMS. Because creation of the domain 
packages and the interface packages is implemented through strong typing definitions and ' 
successive generic instantiations to match the SQL module, syntactic and semantic consistency is 
ensured between those packages and the SQL m^ule. Because the SQL module is a compiled 
module, all SQL data manipulation statements are ensured to be both syntactically and 
semantically correct Therefore, the application program is ensured syntactically and 
semantically correct access to the DBMS. 

5.6 SUMMARY 

In summary, the steps shown in Table 5.3 are taken to use the interface in an Ada application. 


Table 53. S 

leps Summary 

Steps 

Outcome 

1. Receive compiled versions of the abstract 
domain package(s) and the abstract 
interface(s). 


2. Write an Ada application importing the 
abstract domain package(s) and the 
abstract interface(s). 

Ability to invoke Ada procedures that 
access a DBMS. 

3. Compile the application 

Syntactic or semantic errors of interface 
procedures caught during compilation 

4. Execute the application. 



page 58 


6/19/90 











CDRL2020 


Coatnct F19628-88-D-0032AX)02 
USER’S MANUAL 


LMSC-F376702 


Section 6 

Operating Instructions 


6.1 OVERVIEW 

This section contains operational infonnadon for using the Ada/SQL binding to interface with 
die Digital RDBDBMS. section is organized into four parts. After this overview, 

paragraph 6.2 provides installation requirements and instructions. Paragraph 6.3 contains 
guidelines for using RDBA^S error processing capabilities in the abstract interface. Paragraph 
6.4 discusses adapting the rdb_speclf ic procedure for use with other DBMS systems. 

6 J INSTALLATION 

The following subparagraphs outline the hardware and software requirements for installation and 
provide step-by-step procedures for installation. 

6.2.1 Hardware Requirements 

The hardware requirements for this implementation of the Ada/SQL binding consist of the 
following: 

• A Digital VAX with a minimum of 8Mb physical memory 

• Sufficient disk space for 
-The RDB software 

-The DEC Ada compilation software 
-The Ada/SQL bindmg program software 
-Swap space for Ada compUations 

• Capability for loading software—cartridge tape device 

6.2.2 Software Requirements 

The exact locations for the following software are not important. However, in the following 
paragraphs it will be assumed that the user has visibility into RDB DBMS, DEC Ada compiler, 
and VMS executable commands. It is also assumed that an RDB data base has been created, 
loaded, and placed within a working directory together with the Ada/SQL binding. 

• Ada/SQL, Version 1.0 - Ada/SQL binding tool 

• DEC VMS, Version 5.2 - operating system 

• DEC Ada, Ve rsion 1.4 - Ada compiler 

• DEC RDB, Version 3.0 - DMBS 

See the DEC reference manuals Vox RdbfVMS Reference Manual [3] or Developing Ada 
Programs on VaxlVMS [4] for further information concerning installation and use of DEC Ada 
or DEC ^B. 


6/19/90 


page 59 




LMSC-F376702 Contract F19628-88-D-003?/0002 CDRL2020 

USER’S MANUAL Scctioa ( Operating Dnstructions 

6^3 Installation of Ada/SQL Software 

Follow these steps to install the Ada/SQL binding tool: 

Step 1. Copy all of the directories and objects on the delivered tape into an equivalent 

directory structure. The top-level delivered directory is [pro ject. c2 010 ]. This 
directory should contain the following: 

• ada units. dir—subdirectory containing all components of the Ada/SQL 
binding tool, executable procedures for testing the binding and the file, 
ada_units. ord showing unit compilation order. Ada package specifications 
have the file extension . ads and Ada package bodies or procedures have the file 
extension . adb. A description of each unit in this directory is provided in 
Appendix A. 

• dixie_db. rdb—a fully created data base supporting the test procedures in 
ada_unit s. dir. The file dixie_db. snp is simply a snapshot of the data 
base. 

• dixie_conc_interf ace. sqlmod—^a complete SQL module supporting the 
test procedures in ada_unit s. dir. 

• domain template. txt—a program template with instructions for creating 
and defimhg the domain packages 

• interface template.txt—a program template with instructions for 
creating and defining the interface packages 

• readme, nte—a text file containing additional information concerning the 
file [pro ject. c2010. ada_units] ada_units. ord. 

• test_inst r. tst—instructions for using the test procedures contained in 
[project.c2010.ada_units]. 

• vdd. t Xt—the Ada/SQL binding version description document 

Step 2. Create a DEC Ada ACS library in directory [project .c2010.ada_units] with 
the DEC Ada command: 

{acs create lib [project.c20l0.ada_units.adalib]} 

Step 3. Set the default Ada library to this library with the command: 

{acs set library [project.c2010.ada_units.adalib]} 

Step 4. Following the compilation order given in ada_uraits. ord (also in Appendix A) 

compile all units in directory [project.c2010.ada_units] up to and including 
unit abstract_domain_generator. ada using the DEC ada compile command 
{ada}. 


page 60 


6/19/90 




CDRL2020 


Contract F19628-88-D-0032/0002 
USER’S MANUAL Sectkwi Operating InstructiiHis 


LMSC-F376702 


If you are installing on a system with another Ada compiler, you must follow instructions for 
compiling and executing Ada procedures and packages for that system. 

6.2 USE OF THE BINDING WITH DEC ADA AND RDB 

The directory [project .c2 010. ada_units] contains three executable procedures that 
serve as both tests and examples for using the binding. These procedures are, in fact, the same 
procedures shown in Sections 3 through 5 as examples. 

• dixie_domain_view. ada—^test domain definition procedure. 

• di X i e_int erf ace_vi ew. ada—^test interface definition procedure. 

• dixie_application. ada—test application. 

The following steps, using these test procedures as examples, are taken when using the Ada/SQL 
binding with the DBMS. 


Step 1. Go into the directory [project. c2010. ada_units]. Copy both the data base and 
the SQL module to be used by the Ada application into this directoiy. For this example, 
copy dixie_db. rdb, dixie_db. snp and 
dixie_conc_interf ace. sqlmod into this directory. 

Step 2. Compile, link, and execute the domain definition procedure to generate the abstract 

domain package specification(s) and the specification base_specif ic_dcinains. 
Use procedure dixie_domain_view. ada for this example. 

{ada dixie_domain_view.ada} 

{acs link dixie__domain_view} 

{run dixie_domain_view} 

Step 3. Compile the generated products. For this example, compile the doniain packages 

dixie_employee_def_pkg_.ada and dixie_salary_def_j>kg_. ada and 
base_specific__domains_.ada. 

{ada dixie_employee_def_j3kg_.ada} 

{ada dixie_salary_def_j)kg_.ada} 

{ada base_specific_domains_.ada} 

Step 4. Compile the abstract_^interface generator and concrete_package 
packages against this spe^c base.specific.domains. 

{ada concrete_package_.ada} 

{ada concrete_package.ada} 

{ada abstract_interface_generator_.ada 
{ada abstract_interface_generator.ada} 

Step 5. Compile, link, and execute the interface definition procedure to generate the abstract 
interface specification and body, the concrete interface specification and a text file 
containing interface information. Use procedure dixie_inter f ace_view. ada 
for this example. 

{ada dixie_interface_view.ada} 

{acs link dixie_interface_view} 

{run dixie interface view) 


6/19/90 


page 61 




LMSC-F376702 


Contract F19628-88-D-0032/0002 
USER’S MANUAL Scctioa6 Operating Instructions 


CDRL2020 


Step 6. Compile all generated products except the text file having the file name extension 

. txt. For this example, compile the abstract interface specification, dixie_abs_ 
interf ace_. ada, the concrete interface specification 
dixie_conc_interface_.ada and the body, 

dixie_abs_inter face. ada. Do not compile dixie_dbms_specifc.txt. 
{ada dixie_abs_interface_.ada} 

{ada dixie_conc_interface_.ada} 

{ada dixie_abs_interface.ada} 

Step 7. Compile, link and execute rdb specif c to generate three files. Two of the files are 
the Ada specification and body^at will repine the original concrete interface 
specification for the abstract interface. This procedtu-e will assign the original concrete 
specification's name to both this new specification and body (so that no units 
dependent on the original specification require modification). The other file is an Ada 
specification that will replace the original concrete specification for the SQL module. 

It is this new specification that will contain the actusd RDB compatible interface 
procedures. 

{ada rdb_specifc.ada} 

When executing rdb^speci f ic, the user will be asked to provide the filename of 
the original concrete mt^ace specification, the filename of the text file containing 
interface information, Liid a name to be given to the new RDB-compatible concrete 
interface specification. An execution e r r or will occur if either the original specification 
or the text file arc incorrectly named or not present in the directory. At the end of the 
program, the user will be asked if additional specifications require replacement. A 
positive response will cause the program to loop throu^ again. For this example, 
respond to the program prompts as follows: 

Input name of the file containing original concrete__spec => 
{dixie_conc_interface_.ada <return>} 

Input name of the fi.le containing dbms specific information > 
{dixie_dbms_specifc.txt <return>} 

Input the name of the actual concrete_spec => 

{dixie_rdb_interface_.ada <return>} 

Any more abstract specifications? Answer y or n => 

{n <return>} 

Steps. Compile all generated products. For this example, compile the new RDB-compatible 
concrete interface specification dixie_rdb_interface_. ada, the new concrete 
interface specification, dixie_conc_interface_. ada, and the body, 
dixie_conc_ inter face. ada. The abstract_intcrface specification and body 
will need to be recompiled to reflea the newly generated conaete.imerface. 

{ada dixie_rdb_interface_.ada} 

{ada dixie_conc_interface_.ada} 

{ada dixie_conc_interface.ada) 

{ada.dixie_abs_interface_.ada) 

{ada.dixie abs interface.ada} 


page 62 


6/19/90 





CDRL2020 


Connaa F19628-88-D-0032/0002 
USEIR’S MANUAL Section 6 Operating Instrnctions 


LMSC-F376702 


Stq) 9. Q>mpilc the SQL module, dixie_conc_inter face. sqlmod for this example, 
using the RDB SQL module language compiler with following command: 

{run sys$system:sql$mod <return>}. 

Input file=> 

{dixie_conc_interface.sqlmod} 

After compilation the SQL module object file will appear in the directory, for example 
dixie_conc_inter f ace. ob j. This is the file tihat must be linked to the concrete 
interface Ada specification. 

Step 10. Define the link library as: 

{define lnk$library sys$library:sql$user.olb} 

Step 11. Link the SQL module to the Ada specification using the DEC Ada ACS command 
copy foreign. More than one concrete interface specification can be linked a 
given SQL module. To link dixie_conc_inter f ace. ob j to dixie_rdb_ 
interf ace_. ada, enter the command: 

{acs copy foreign dixie_conc_interface.obj 
dixie_rdb_interface} 

I Note: dixie_rdb_interface is a unit name with no file extension. | 


Step 12. Compile, link and execute the application. Use the procedure dixie_ 
application. ada in this example: 

{ada dixie^application.ada} 

{acs link dixie_application} 

{run dixie^application} 

6.3 ERROR PROCESSING WITH RDB 

During interface development, the interface programmer determines what types of errors are 
expected from the data base during application program execution. These expected errors are 
handled within the application program. In the case of unexpected errors, however, SAME 
provides a place for error processing procedures within two packages: 

• Sql_Conununications_Pkg 

• Sql_Database^Error_Pkg. 

These packages are intended to be modified by the interface progranuner to meet the error 
processing requirements of the application and the platform. 

Sql_Coinmunications_Pkg contains a function, sql_database_error_message for 
DBMS error message retrieval and an Ada exception, sql_dat abase_error. Sql_ 
Database_Error_Pkg contains a procedure, process_database_error, for error 
processing and recovery. If an unexpected err or occurs during application execution, the abstract 
interface body first calls the procedure process_database_error and then raises tlie 
sql_database_error exception. The procedure process_database_errcr should 
minimall y make a call to the function sql_database_error_message to print out what 


6/19/90 


page 63 








LMSC-F376702 


Contract F19628-88-D-0032/0002 
USER’S MANUAL Scctkmi Operating Instrnctioiis 


CDRL2020 


unexpected error occurred. Other processing might include a call to the rollback or commit 
proc^ures. Once the error sql database_error has be raised, it propagates to the user 
thereby alerting the application that an unexpected error has occurred. Thus, all unexpected error 
processing and recovery procedures or functions should be contained within the process_ 
database_error procedure. 

The Vax RDBA^S system provides a large number of useful error processing procedures. 

Refer to the Vax Rdb/VMS Reference Manual [3] for complete information concerning Vax 
RDBA^MS error processing capabilities. For the purpose of illustration, the following examples 
show modified versions of the Sql_Cominunications_Pkg body (Table 6.1) and the 
Sql Database_Error_Pkg body (Table 6.2). These modified package bodies use the 
RDB/VMS service procedure SYS$GET_ERROR_TEXT to retrieve and output a descriptive 
error message from the RDB DBMS. 

Table 6.1. Modified Package Body Sql_Coinmunications_Pkg 


— This version of sql_cominunications_pkg.ada is modified for use with the 

— DEC RDB DBMS. The function sql_database_error_message 

— will get an RDB error message using the RDB/VMS supplied procedure 

— SQL$GET_ERROR_TEXT. 

with sql_system; use sql_system; 
with text_io; use text_io; 

with condition_handling; — RDB/VMS package providing error condition system 

— service functions. 

with system; -- RDB/VMS package providing general system service 

— functions. 

package body sql_communications_pkg is 

— The following variables are part of the standard sql_communications_pkg 

— They are used here in slightly modified form as parameters in the 

— SQL$GET_ERROR_TEXT procedure. 

function sql_database_error_message return sql_char_not_null is 

me33age_buffer : stringd .. 256); — Always a string this length 

len : short_integer; — Always a 3hort_integer 

— Declaration of SQIi$GET_ERROR_TEXT. 
procedure 3ql_get_error_text (error_text : ou\. string; 
error_text_len : out 3hort_integer); 
pragma interface (SQL, sql_get_error_text); 


page 64 


6/19/90 





CDRr.2020 


Connaa F19628-88-IW)032/0002 
USER’S MANUAL Scc«io«< Operating Instructioas 


LMSC-F376702 


pragma in?3ort_procedure (internal <■> sql_get_error_text, 

external -> "SQL$GET_ERROR_TEXT", 
parameter_types -> (string, short_integer), 
mechanism ■■> (descriptor, reference) ) ; 

begin 

— This function gets the RDB DBMS error message and passes it on to 
— the sql_database_error_p)cg for output. 
sql_get_error_text(message_buffer, len); 
return (sql_char_not_null(mes3age_buffer)); 

end sql_database_error_me33age; 
end sql_communication3_pkg; 


Table 6J1. Modifled Package Body Sql_Databasa_Error_P]cg 


— This version of sql_database__error_pkg.ada is modified for use with the 

— DEC RDB DBMS. RDB/VMS provides various functions and procedures for 

— processing data base errors. See the Vax RDB/VMS reference manual for 

— information concerning error processing capabilities. 

with text_io, sql_communications_pkg, sql_char_pkg; 
use text_io, sql_communications_pkg, sql_char_pkg; 

package body 3ql_database_error_pkg is 

procedure process_database_error is 

begin 

— This procedure is always called in the abstract interface in response 

— to some unexpected database exception (as opposed to one of the 

— expected errors declared in the abstract interface). 

— This procedure may be modified per the needs of the abstract 

— interface developer. All needed error processing procedures and 

— functions, whether supplied by RDB/VMS or developed by the interface 

— programmer should be pla< sd within the body of this procedure. 


6/19/90 


page 65 





LMSC-F376702 


Conliaa F19628'88-D-0032A)002 
USER’S MANUAL Scctioa6 Operating Instructions 


CDRL2020 


— This is a minimal inplementation of an error processing procedure. 

— This procedure gets a descriptive error message from the DBMS 
— (through sql_communications_pJcg) and displays it on standard output. 

put_line {to_string (sql_char_not__null(sql_database_error_mes3age))); 

end process_database_error; 
end sql_database_error_pkg; 


6.4 rdb_spacif ic PROCEDURE ADAPTIONS 

Using the SAME methcxl with any specific DBMS implementation very probably will require 
some modification to the concrete interface. In the case of a DBMS with no SQL module 
language compiler, for example, the concrete interface will have to simulate a compiled SQL 
module and provide DBMS supplied programmatic access instead, such as a libr^ of C 
routines. SAME standard data types may also be incompatible with a particular DBMS (as with 
the Digital RDB DBMS) requiring conversion of the SAME standard data types declared in the 
concrete interface to DBMS required data types. Although each DBMS implementation will 
require its own particular concrete interface modification, the rdb speci f ic procedure, for 
use with the Digital RDB-DBMS, can be adapted to woik with different DBMS implementations. 

The rdb_speci f ic procedure uses the information contained in the original concrete interface 
Ada specification and the the Dbms_Specific text file. Both of these files are automatically 
gen^ted along with the abstract interface. The concrete interface specification contains the 
specifications of the Ada procedures representing SQL procedures and the pragma interface 
statement for each procedure. Dbms_Specific contains procedure descriptions: procedure 
name, parameter name, parameter mode, parameter type, and with char type parameters, their 
length. By using these two f'les, the rdb_specific procedure has enough information to 
convert procedures and data types to be compatible with the RDB DBMS. In the process, three 
new files are generated to replace the original concrete interface specification. Any adaptation of 
the rdb_specif ic will also use this infOTmation for procedure and data type conversions and 
will generally generate these three files. 

The first two files are an Ada package, specification and body, that will substitute for the original 
concrete interface specification. This package always bears the same name as the original 
concrete specification so that no modification to the calling abstract interface is required. The 
third file is an Ada specification that contains the actual Ada procedures and data types that are 
compatible with the RDB DBMS and is the specification that represents the SQL module. 

to summary, the rdb_specific procedure takes information fi-om the original concrete 
interface specification and Dbms^Specific text file, converts the procedures and data types, 
and outputs three replacement files. Therefore, adapting the rdb_specif ic procedure for use 
with another DBMS implementation basically requires changing the rcib_specif ic's file 
output statements. 

For instance, if a DBMS supplies data base access through a library of C routines rather than an 
SQL module language compiler, the rcib_specif ic procedure could be changed to generate 


page 66 


6/19/90 




CDRL2020 ContiaaF19628-88-D-0032/0002 LMSC-F376702 

USER’S MANUAL Section^ Operating instructioos 

the following three replacement files. The first file will be a package specification containing 
Ada procedures that r^resent the needed C routines and associated pragma interface statements 
to C. These C routines will in turn, provide access to the required SQL statements, and like the 
SQL module, will be develoj^ separately. The second and third files will comprise the package 
specification and body to be imported by the abstract interface instead of the original concrete 
specification. This package specification will declare the Ada procedures that represent the SQL 
statements firom the abstract interface side, and it will look like the original concrete specification 
with the pragma interfaces removed. In the package body each procedure will call the matching 
Ada procedure specification and pragma int^ace to C in the first specification. 


6/19/90 


page 67 






CDRL2020 


Conoact F19628-88-D-0032/0002 
USER’S MANUAL 


LMSC-F376702 


APPENDIX A 

Component Description 
and 

Compilation Order 

A.1 FUNCTIONAL AREAS 

This appendix describes the components of the Ada/SQL binding in terms of functionality and, 
where appropriate, input and output Names in italics indicate user-supplied names. The 
components are grouped into four overall functional areas. The first group of components 
provides do main defimdon and generation capabilities. The second group provides abstract 
interface definition and generation capabilities. The third group is compris^ of general purpose 
components that support this binding by providing additional functionality to the generators and 
glob^ declarations. The fourth group consists of all components that are part of the standard 
SAME method. The final portion of Append A provides the compilation order of the 
components. 

A.2 DOMAIN DEFINITION AND GENERATION 

Abst ract_Domain_Generat or is a generic Ada package that contains several layers of 
nested generics that arc to be instantiated by an Ada procedure, the Domain^View , written by 
the interface programmer. Based on the information contained in the Domain_yiew, the 
Abstract_Domain Generator will generate a set of Ada specifications, the domain 
packages, containing declarations of all domains needed by the application programmer. 

Inputs to Abstract_Domain_Generator: 

The Domain View is an Ada procedure writttn by the interface programmer following 
the guidelinesln Section 3. When this procedure is compiled and executed, one or more 
Ada specifications representing the domains are automatically generated. This procedure is 
written specifically for each application or set of applications. 

Outputs from Abstract_Domain__Generator: 

• The Domain packages generated by the instantiation of the Do/nain_ Vie V. These 
packages are syntactically and semantically correct Ada and adhere to the SAME 
methodology. No further coding or modification is required. These packages will be 
wlthed by both the application and the abstract interface and give both packages access 
to data types represented by the domains. 

• Base_Specific_Domains is another package created by the Abst ract_Domain 
Generator during domain package generation. This Ada specification contains 
information about the domain packages and the individual domains that will be used by 
Abstract_ Interface_Generator. This specification also requires no further 
coding or modification. 


6/19/90 


page 69 





LMSC-F376702 Contract F19628.88-IM)032/0002 CDRL2020 

USER’S MANUAL Appendix A: Conpaaent Dcicription ud CompUatkn Order 


AJ INTERFACE DEFINITION AND GENERATION 

Abstract_Inter f ace_Generator is a generic Ada package that contains several layers of 
nested generics that are to be instantiated by an Ada procedure, the Interface_view, 
written by the interface programmer. Based on the information contained in the 
Interface_View, Abstract Interface Generator will generate an Ada 
specification and body for a specific abstract interlace and an Ada spe^cation representing a 
specific and corresponding concrete SQL module. 

Inputs to Abstract_Interface_Generator: 

Interface View is the second Ada procedure that must be written by the interface 
programmer following the directions given in Section 4. When this procedure is compiled 
and executed, an Ada specification and body of an abstract interface and an Ada 
specification of an SQL module are automatically generated. This procedure is specific to 
the services requested of the data base and particular rows in the data base and is written 
specifically for each application or set of applications. 

Outputs fiom Abstract_Interf ace_Generator: 

• Abstract_Interface is an Ada package, specirication and body, automatically 
generated by the instantiation of the Abstract_Interface generic. This package will give 
an Ada application access to Ada procedures representing SQL data manipulation 
statements. This package is syntactically and semantically correct Ada and will adhere to 
the SAME methodology. No further co^g or rrxxlification is required. This package 
will be withed by the application. 

• Concrete Interface is an Ada specification representing the SQL module that 
contains the~SQL statements to implement services requested ^m the data base. This 
specification is complete, requiring no further coding or modifications. 

• DBMS_Specific is an additional text file that contains all interface information, such 
as parameter lengA or type, necessary to successfully interface with various types of data 
base implementations. Tlus text file is complete and requires no modifications. 

A.4 GENERAL BLVDING SUPPORT COMPONENTS 

• rdb specific is a special purpt^ Ada procedure to be used only with Digital RDB 
DBM'S. Because some SAME required data types and RDB data ty^s are incompatible, the 
SAME, data types declared in the Concrete_lnterface must be converted to their 
corresponding RDB data types. The rcib_specific procedure takes the original 
Concrete_Interface and the interface information contained ir Db/ns Specific and 
generates three files. These files, in turn, replace the original concrete specification for use 
with the RDB data base. This procedure can be modified to work with different DBMS 
implementations. 

Inputs to rcib_specifc: 

• Dbms_Speci fi c contains all interface information, such as parameter length or type, 
necessary to successfully interface with various types of data base implementations. 


page 70 


6/19/90 




CDRL2020 


CooliaaF19628-88-EMX)32/0002 LMSC-F376702 

USER’S MANUAL Appcndbi A: CoapoMBt Docriptloil and CompUatioa Order 


• Concrete Interface is the Ada specification representing the SQL module that 
contains the~SQL statements to implement services requested from the data base. 

Outputs from rdb_specif c: 

• Concrete_lnterface is an Ada package, specification and body, automatically 
generated by executing the rdb_specif ic procedure. This entire package will 
substitute for the original Concrete Interface specification. TTus package will 
always bear the same name as the ori^al concrete specification. No further coding or 
mod^cation is required. This package will be withed by both the application and the 
abstract interface instead of the original Concrete_Interface. 

• Dbms_Required_Interface is an Ada specification automatically generated by 
executing the rdb specific procedure. This specification contains the actual Ada 
procedure declarations that are compatable with the RDB DBMS and is the specification 
that will represent the SQL module. Dbms Concrete_Interface imports this 
package to obtain access to the SQL module. No further coding or modification is 
requii^ 

• Concrete_Package is an Ada package that given an abstract domain, provides base type 
information. like package Abstract_Interface_Generator, this package imports the 
specification Base_Specific_Domains. 

• Conversions is an Ada package that tracks and supports conversions of null values returned 
in indicator variables. 

• Domain_Template is a text file containing a code template and instractions for writting the 
procedure that defines and generates the domain packages. 

• Enumeration_Image is an Ada generic function that takes an enumeration type and 
returns a string equivalent of an Ada enumeration declaration statement 

• Generator Support contains the global enumeration types and constants used by the 
generators and^the application program. Some values, such as maxim um string lengths, can be 
modified to suit user preference or platform constraints. 

• Interf ace_Template is a text file containing a code template and instructions for writting 
the procedure that defines and generates the abstract interface. 

• Longest_Enum is an Ada generic function that takes an enumeration list and returns an 
integer representing the length of the longest enumerated value 

• Linked_List is an Ada generic package that implements lists. List building, updating, and 
deleting, as well as logical list operations, are provided. 

• String Pack is an Ada package containing utility procedures and functions that operate on 
fixed antfvariable length strings. 

• Variable_Io is an Ada generic package that takes a value representing the desired 
maximum length of a file output line and then controls outputs lines to meet this specification. 


6/19/90 


page 71 




LMSC-F376702 Contact F19628-88-D-0032/D002 

USER’S MANUAL Appendix A: Coapoarat Dcecription and Compilatkia Order 


CDRL2020 


SAME STANDARD COMPONENTS 

• sql_Standard is an Ada specification containing Ada type definitions corresponding to 
SQL types with each type definition directly defining the SQL type of the same name. The 
types in Sql Standard define the representation of SQL data to the Ada compiler, and all 
abstract domains and interface parameters are based on these types. The type definitions are 
DBMS implementation dependent 

• Sql_System is a supporting Ada specification that defines maximum string output length. 
Tto specification is DBMS implementation dependent 

• Sql Coininunications_Pkg and Sql_Database_Error_Pkg are Ada packages that 
provide the interface programmer with error recovery processing. Both packages are to be 
modified to the requirements of the DBMS and the user. Note that Sql_Communicat ions 
_Pkg is DBMS implementation dependent and Sql_ Database_Error_Pkg is 
application dependent 

• The following are Ada packages supporting logical operations of the types defined in 
Sql Standard. These packages are in^lementation independent and should never be 
modi&ed. 

Sql_Boolean_Pkg 

Sql_Char_Pkg 

Sql_Double__Precision_Pkg 
Sql__Enumerat i on_Pkg 
Sql_Exceptions 
Sql_Int__Pkg 
Sql_Real__Pkg 
Sql_Smallint_Pkg 
T o_Sql_Cha r__No t_Nu 11 
To__String 

A.6 DOMAIN DEFINITION AND GENERATION 

The following list of filenames represents the required compilation order for all components of 
the Ada/SQL binding. Filename extensions ending in . ads are Ada package specifications and 
those ending in . adb are Ada package bodies or Ada procedures. File names in italics such as 
domain_view. adb represent either files created by the interface program or files 
automatically generated by the execution of a procedure. The names of such files are, therefore, 
user-supplied 

enumeration_image.ads 
string_jpack. ads 
string_pack.adb 
enuineration_image. adb 
generator_support.ads 
longest_enum.ads 
longest_enum.adb 
linked_sets.ads 
linked_sets.adb 
sql_boolean_pkg.ads 
sql_exceptions.ads 
sql_boolean_pkg.adb 


page 72 


6/19/90 



CDRL2020 


ConliactF19628-88-D-0032/D002 LMSC.F376702 

USER’S MANUAL Appendix A: Compoient Daecriptloii'and CompiUdoB Order 


sql_syStem.ads 
sql_database_errorjpkg. ads 
sql_standard.ads 
sql_char_pkg.ads 
sql_char_pkg.adb 
sql_communications_pkg.ads 
sql_coinmunicat ions_pkg. adb 
sql_database_error_pkg.ads 
variable_io.ads 
variable_io.adb 
sql_int_pkg. ads 
sql_int_pkg.adb 
sql_real_pkg.ads 
sql_real_pkg.adb 
sql_smallint_pkg.ads 
sql_smallint_pkg.adb 
to_string.adb 
to_sql_char_not_null. adb 
sql_double_precision_pkg.ads 
sql_doxible_precision_pkg. adb 
sql_en\imerat ion_pkg. ads 
sql_enumeration_pkg.adb 
conversions.ads 
conversions.adb 
abstract__domain_generator. ads 
abstract_domain_generator.adb 
domain_view. adb 

base_specific_domains.ads 

abstract^domain_package (s), ads 

concrete_package.ads 
concrete_package.adb 
abstract_interface_generator.ads 
abstract_interface_generator.adb 
interface_view. adb 

abstract_interface.ads 

concrete_interface.ads 

abstract_interface.adb 

SQL MODULE 


Executable procedure written by the 
interface programmer. 

Generated by executing 
domain_view.adb. 

One or more packages generated by 
executing doinain_view. adb. 


Executable procedure written by the 
interface programmer. 

Generated by executing 
interface_view.adb. 

Generated by executing 
interface_view.adb. 

Generated by executing 
interface_view.adb. 

Compiled and linked to 


concrete_interface.adb. 

user_appl i cat ion. adb Executable procedure written by the 

application programmer. 


If the generated interface requires DBMS-specific modifications, compile as before up to and 
including abstract_interface. adb and then use the compilation order below. Also, see 
Section 6. 


6/19/90 


page 73 






LMSC-F376702 Conttact F19628-88-D-0032/0002 

USER’S MANUAL Apptndlz A: Conpoacpt Description and Compilatlan Order 


CDRL2020 


rdb_specifc.adb 
dbms_requlrecl^inter face. ads 
dbms_concrete^interface.ads 
dbms_^concrete^inter face. adb 
abstract_interface .ads 
ahstract_inter face. adb 
SQL MODULE 
user_appllcation .adb 


Executable procedure for 

modifying the interface 

Generated by executing 

nlb_specifc.adb 

Generated by executing 

rdb_specifc.a(lb 

Generated by executing 

r(lb_specifc.adb 

Generated by executing 

interface_view.adb. 

Generated by executing 

interface_view.adb. 

Compiled and linked to 
dbms_required_interface,adb. 
Executable procedure written by the 
application programmer. 


page 74 


6 / 19/90 


CDRL2020 


Cooinct F19628-88-EMX)32/0002 
USER’S MANUAL 


LMSC-F376702 


APPENDIX B 

SAME SUPPORT EXCLUSIONS 


The following list shows all exclusions to SAME support for this prototype implementation: 

• Dedmal Types—ANSI SQL supports the type decimal. The Ada programming language, 
however supports no directly analogous type. Furthermore, ANSI standard SQL, as described 
in [2], does not support decimal data in Ada programs. The SAME standard, therefore, does 
not provide a standi support package for null and non-null bearing decimal types and, 
therefore, this implementation also does not support Dec imal Types. 

• Arbitrary Data Types—SAME provides standard support for types in ANSI standard SQL. 
Many data base management systems extend the standi to other types. SAME 
documentation outlines the way a SAME user can extend the data typing facilities, however, 
this implementation does not support data typing extensions. 

• Enumeration Type Representation—^Whether enumeration values are represented as string 
literals or integer values is the responsibility of the abstract module. This implementation o^y 
provides string representation. 


6/19/90 


page 75 


CDRL2020 Coi«iactF19628-88-D-0032/0002 LMSC-F376702 

USER’S Mil^AL 

APPENDIX C 

EXECUTION ERROR MESSAGES 
AND ERROR CORRECTION 

C.1 DOMAIN DEFINmON AND GENERATION EXECUTION ERRORS 

C.1.1 Domain Package Errors 

ERROR TYPE: duplicate package name 

message Error. .. Domain package domain_package_name has 
been defined more than once. 

correction Multiple packages sharing the same name are not allowed. Declare a 
unique name for each domain package. 

ERROR TYPE: uncreated package 

message Error.. . One or more domain packages has been 
declared but never described. 

correction Domain packages that are declared but then not later described are not 

allowed. For every domain package name declared, completely define the 
content(domains) of that package. 

C.1.2 Domain Errors 

ERROR TYPE: duplicate domain namw 

message Error... domain_name in domain package 

domain_package_name has been defined more than 
once. 

correction Multiple domains sharing the same name are not allowed. Declare a 
unique name for each domain. 

ERROR TYPE: undefined domain 

message Error... One or more domains in domain package 
domain_package_name has been declared but never 
described. 


6/19/90 


page 77 


LMSC-F376702 Conttaa F19628-88-D-0032/0002 CDRL2020 

USER’S MANUAL Appendix C: Excentioa Error Messages and Error Correctitm 

correction Donsains that are declared but then not later described are not allowed. 

For every domain name declared for a domain package, completely define 
that domain. 

ERROR TYPE: illegal char subtype 

message Error... Subtype based on domain of type char in 
domain package domain_package_name not allowed, 
correction SAME does not allow char subtypes. Remove the char subtype 
declaration and definition. 

ERROR TYPE; imdeclared parent domain 

message Error.. . parent type for domain_suhtype_name has 

not been previously defined. ... cannot declare a 
subtype unless parent type has been previously 
defined. 

correcdon The SAME iixqilementadon requires that all derived subtypes be declared 
after their parent type. Declare the parent domain before declaring the 
derived subtype domain. 

ERROR TYPE: undefined parent do main 

message Error... parent_domain_name has not been previously 
defined. ... cannot derive a new type unless 
parent domain has been has been previously defined 
correction The SAME inq)lementation requires that all derived subtypes be described 
after their parent type is described. Define the parent domain before 
defining the derived subtype domain. 

C.2 INTERFACE DEFINITION AND GENERATION EXECUTION ERRORS 

C.2.1 Error Definition Errors 

ERROR TYPE: unequal e r ro r s and SQLCODEs 

message Error... Number of expected SQL errors does not 
match corresponding sql_code values given, 
correction For every expected error declared, one and only one corresponding 
SQLCODE value must be given. Add or remove the incorrect 
SQLCODES. 


page 78 


6/19/90 



CDRL2020 ConliaaF19628-88-D-0032/0002 LMSC-F376702 

USER'S MANUAL Appendix C: Execntiaa. Error Messages and Error Correction 

ERROR TYPE: too many cirors for boolean result 

message Error... A result parameter of type boolean has too 
many possible errors associated with it. 

collection Boolean type results are with either no eirors or at most, one (and only 
one) error. Remove all extra errors from association with this result 
parameter. 

C.22 Record Definition Errors 

ERROR TYPE: duplicate record 

message Error... record_name has been defined more than 
once. 

correction Multiple records sharing the same name are not allowed. Declare a unique 
name for each record. 

ERROR TYPE: duplicate record component 

message Error... record_component_name has been defined 

more than once. 

correction Multiple record components sharing the same name are not allowed. 

Declare a unique name for each record component 

ERROR TYPE: undefined record component 

message Error... record_component_name in record 

record_name has been declared but never described. 

correction Components that are declared but then not later described are not allowed. 

For every component name declared for a record, completely define that 
component 

CJ23 Procedure Definition Errors 

ERROR TYPE: duplicate procedure 

message Error... procedure_naine has been defined more than 
once. 

correction Multiple procedures sharing the same name are not allowed. Declare a 
unique name for each procedure. 


6/19/90 


page 79 




LMSC-F376702 Contract F19628-88-D-0032/0002 

USER’S MANUAL Appendix C: Execntkm Error Messages and Error Correction 


CDRL2020 


ERROR TYPE; 
message 

conection 

ERROR TYPE; 

message 

correction 


ERROR TYPE; 
message 

correction 

ERROR TYPE; 
message 

conection 

ERROR TYPE; 
message 

correction 

ERROR TYPE; 
message 


duplicate procedure parameter 

Error... procedure_parameter_name of procedure 
procedure_name has been defined more than once. 
Multiple procedure parameters sharing the same name are not allowed. 
Declare a umque name for each procedure parameter. 

undefined procedure parameter 

Error... procedurejparameter_name in procedure 
procedure_name has been declared but never 
described. 

Parameters that are declared but then not later described are not allowed. 
For every parameter name declared for a procedure, completely define that 
parameter. 

multiple result parameters 

Error... Cannot provide more than one result 
parameter for procedure procedure_name. 

Only one result parameter is allowed per procedure. Remove all but one 
result parameter from the procedure definition. 

no result paramter 

Error... Must provide result parameter for 
procedure procedure_name. 

This kind of procedure expects a result parameter. Provide a result 
parameter in the procedure definition. 

illegal parameter profile 

Error... The procedure procedure_name of SQL 
statement type procedures_SQL_type must have 
parameters. 

This procedure corresponds to an SQL statement that always expects 
parameters. Re-dcfine this procedure as a procedure that has parameters. 

invalid concrete parameter 

Error... Concrete_parameter_name in procedure 
procedure_name is not a valid parameter to send to 
a concrete interface. 


page 80 


6/19/90 



CDRL2020 


ContrartF19628-88-I>-(X)32/0002 LMSC-F376702 

USER’S MANUAL Appendix C: Execotioa Error Messages and Error Correction 


cc faction 

ERROR TYPE: 
message 

correction 

ERROR TYPE: 
message 

correction 


AH parameters passed to the concrete interface must have been passed to 
the abstract interface first (with the exception of indicator variables or the 
"SQLCODE" parameter). Either remove the illegal concrete parameter 
or add a corresponding abstract parameter first. 

illegal record type 

Error... Record types are only allowed to be sent 
to abstract procedures which represent select, 
fetch, or insert SQL statements. 

Replace the record type parameter with parameter(s) appropriate to the 
procedure kind. 

no ops_package 

Error... concrete_parameter_name in procedure 
procedure_naine is a null bearing type with no ops 
package instantiated for it..therefore it cannot be 
re-assigned to a variable of a concrete type. 

Either redefine the domain definition to include both null and not null 
bearing types and the ops package, or never reassign the null bearing type. 


6/19/90 


page 81 









CX>RL2020 


Contact F19628-88-I>0032/0002 
USER’S MANUAL 


LMSC-F376702 


APPENDIX D 
SAMPLE PROGRAMS 

D.l SAMPLE PROGRAMS OVERVIEW 

In order to provide more comprehensive examples of domain and interface definition, generation 
and use, this appendix contains two sets of sample programs. The first set in Section D.2 shows 
a domain definition procedure. Every_Kind_Domain_View, that defines a domain and sub^e 
of every possible SQL type. All products generated by this procedure are also shown. Section 
D.3 shows examples of the entire binding process, from domain definition to a large-scale 
application. This Ada application imports three abstract domain packages definition and two 
abstract interfaces. The two abstract interfaces contain between Aem 8 row record definitions 
and 28 procedures. 

D.2 DOMAIN DEFINITION AND GENERATION FOR ALL SQL TYPES 

Table D-1. Every_Kind_Doiiiain_View - Domain Definition Procedure 

" This procedure shows domain definition for all domain types and 
-- subtypes with one example for each sql type possible. 

— SQL types are char, int, smallint, double_precision, enumeration, 

— real, decimal. 

with abstract_doiaain_generator; 

with generator_support; use generator_support; 

procedure every_kind_domain_view is 

type package_names is (suppliers_def_p)cg, parts_def_pkg) ; 
package dom_packs is new abstract_domain_generator(package_names); 

begin 

declare 

ti^ doms is (sname, sno, sno_over_50, colors, colors_not_red, 

tax_range, tax__over_33, status, high_status) ; 

package domain_l is new dom_packs.generate_domain_package 

(suppliers_def_pkg, doms); 

— declares domain of type CHAR. No CHAR subtypes are allowed, 
package first is new domain_l.generate_int_domain 

(sname, char, null_and_not_null, 1, 15); 

— declares domain of type INT. 

package second is new domain_l .ger.erate_int_doriiain 

(sno, int, null_and_not_null, 1, 100) ; 

— declares INT subtype. 

package third is new domain_l.generate_subint_domain 

(sno_over_50, sno, int, null_and_not_null, 51, 100); 


6/19/90 


page 83 





LMSC-F376702 


Contract F19628-88-D-0032/0002 
USER’S MANUAL Appendix D: Sample Programs 


CDRL2020 


— declares domain of typ>e ENUMERATION 

type vals is (red, white, blue); 

package fourth is new domain_l .generate_enum_doinain 

(vals, colors, enumeration, contains_null); 

— declares ENUMERATION subtype 

package fifth is new domair_l .generate_suben>;ni_doma.''.n 

{cclors_aot_red, colors, enumeration, 
containa_null, "white", "blue"); 

— declares domain of type REAL 

package sixth is new domain_l.generate_flt_domain 

(tax_range, real, not_null, 0.000, 100.000); 

— declares REAL subtype 

package seventh is new domain_l.generate_subflt_domain 

(tax_over_33, tax_range, real, not_null, 33.001, 100.000); 

— declares domain of type SMALLINT 

package eighth is new domain_l.generate_int_domain 

(status, smallint, contains_null, 0, 3); 

— declares SMALLINT subtype 

package nine is new domain_l.generate_subint_domain 

(high_status, status, smallint, contains_null, 3, 3); 


begin 

domain_l.start_generation; 
end; 

declare 

type dorns is (pno, price, mid__price, weight, light_weight) ; 

package domain_2 is new dom_packs.generate_domain_package 

(parts_def_pkg, doms); 

— declares domain of type INT 

package first is new domain_2.generate_int_domain 

(pno, int, not_null, 0, 550); 

— declares domain of type DECIMAL 

package second is new domain_2.generate_flt_domain 

(price, decimal, null_and_not_null, 0.00, 1000.00); 

— declares DECIMAL subtype 

package third is new doroain_2 .generate_subflt_domain 
(mid_price, price, decimal, null_and_not_null, 300.33, 600.66); 

— declares domain of type DOUPLE_PRECISION 
package fourth is new domain_2.generate_flt_domain 

(weight, double_precision, contains_null, 1.456, 45.567); 

— declares DOUBLE_PRECISION subtype 

package fifth is new domain_2 .generate_subflt_Llomain 

(light_weight, weight, double_precision, 

contains null, 1.456, 10.600); 


begin 


page 84 


6/19/90 




CDRL2020 


Contract Fl%28-88-D-0032/000Z 
USER’S MANUAL Appcndiz D: Sample Programs 


LMSC-F376702 


domain_2.start_generation; 
end; 

dom_packs.generate_ba3e_specific; 
end every_kind_doinain_view; 


Table D-2. Parts_Def_Pkg • 1st Abstract Domain Package Specification 

with sql_int_pK.g; 

use sql_int__pkg; 

with sql_double_precision_pkg; 

use sql_double_preci3ion_pkg; 

with sql_real_pkg; 

use sql_real_pkg; 

package parts_def_pkg is 

type pno_not_null is new sql_int_not_null 

range 0..550; 

type price_not_null is new sql_real_not_null 

range 0.00000..1000.00000; 

type price_type is new 3ql_real; 
package price_op3 is new 

sql_real_op3(price_type, price_not_null); 

subtype mid_price_not_null is price_not_null 

range 300.32999..600.65997; 
subtype midjpric^type is price_type; 
package niidjprice_ops is new 

sql_real_ops (mid_price_type, mid__price_not_null) ; 

type weight_type is new 3ql_double_preci3ion; 

S-ibtype light_weight_type is weight_type; 

end part3_def_pkg; 


Table D-3. Suppliers_Def_Pkg • 2nd Abstract Domain Package Specification 

with sql_char_pkg; 

use sql_char_pkg; 

with 3ql_int_pkg; 

use 3ql_int_pkg; 

with sql_sinallint_pkg; 

use 3ql_3iiiallint_pkg; 

with sql_enumeration_pkg; 

with sql_real_pkg; 

use sql_realjpkg; 

package supplier3_def_pkg is 

type snamenn_base is new 3ql_char_pkg.sql_char_not_null; 
subtype 3naine_not_null is snainenn_ba3e (1..15); 
type snanie_base is new sql_char_pkg.3ql_char; 
subtype 3name_type is snaine_ba3e {sname_not_null'length); 
package 3naine_ops is new 

3ql_char_jpkg.3ql_char_ops{3name_base, snamenn_base); 


6/19/90 


page 85 





LMSC-F376702 


Contiact F19ti28<88-I>-0032AXX)2 
USER’S MANUAL Appeadix D: Sample Programs 


CDRL2020 


type sno_not_null is new sql_int_not_null 

range 1..100; 

type sno_type is new sql_int; 
package sno_ops is new 

sql_int_ops{sno_type, sno_not_null); 

subtype sno_over_50^not^null is sno_not_nulJ 

range 51..100; 

subtype sno_over_50_type is sno_type; 
package sno_over_50_ops is new 

sql_int_ops (sno_over_50_type, sno_over_50_not_null) ; 

type colors_not_null is (red, white, blue) ; 
package colors_ops is new 

sql_enuineration_pkg (colors_not_null) ; 
type colors_type is new colors_ops.sql_enuineration; 

subtype colors_not_red_not_null is colors_not_null 

range white..blue; 

package colors_not_red_opa is new 

sql_enxinieration_pkg(colora_not_red_not_null) ; 
type colors_not_red_type is new 

color3_not_red_ops. sql_enuineration; 

type tax_range_not_null is new sql_real_not_null 

range 0.000^00.. 100,00000; 

subtype tax_over__33_not_null is tax_range_not_null 

range 33.00100..100.00000; 

type status__type is new sql_smallint; 

subtype high_status_type is status_type; 

end suppliers_def_pkg; 


Table D-4. Base_Spedfic_Doinains > Domain Description Specification 

with generator_support; 

use generator_support; 

package base_speci£ic_domains is 

type base_specific_doroain_types is (snaine_not_null, snajne_type, 
sno_not_null, sno_type, sno_over_50_not_null, 
sno_over_50_type, colors_type, colors_not_red_type, 
t ax_range_no t_nu11, tax_over_3 3_not_nul1, 
status_tyF)e, high_3tatus_type, pno_not_null, 
price_not_null, price_type, mid_price_not_null, 
mid_price_type, weight_type, light_weight_type, 
null_doinain_type) ; 

type corresponding_concrete_types is (3nanie_not_null_char_15, 
snaine_type_char_15, sno_not_null_int, sno_type_int, 
3no_over_50_not_null_int, 3no_over_50_type_int, 
colcrs_type_enuineration, color3_not_red_type_enuineration, 
tax_range_not_null_real, tax_over_33_not_null_real, 
status_type_sinallint, high_statu3_type_sinallint. 


page 86 


6/19/90 





CDRL2020 Cooa*aF19628-88-D-0032/0002 LMSC-F376702 

USER’S MANUAL Appcwltr D: Sample Programs 

pno_not_null_lnt, price_not^null_real, price_typ€_real, 
mid_price_not_null_real, mid._price_type_real, 
weight_t ype_double_preciaion, 
light_weight_type_doublejprecision); 

type valid_doinain_naine8 is (suppliers_def_pkg, parts_def_pkg); 

type ops_packages is (snaine_ops, sno^ops, 3no_over_50_ops, 
price_ops, mid_price_ops); 

longest_enuin_value : constant integer 5; 

type doinain_package_array is array (positive range <>) of 
valid_doniain_names; 

end base_sp€cific_domain3; 


D^. LARGE-SCALE BINDING PROCESS 

Table D-5. DOCTORS^LMOD • SQL Module 


— This SQL module provides the SQL procedures needed by the 

— doctors.ada program. 


— Header 

Information Section 



module 

doctors 

— module name 

language 

ada 

— language 

of calling program 

authorization physician^reference 

~ provides 

default db handle 

— Declare 

Statements Section 




declare schema filename 'physician_reference' — Declaration of the 

— database 


declare dr_row cursor for 

select p.dr_name, p.dr_address, p.phone_nuinber, p.office_hours, 

p.area, p.specialty, p.bedsidejntanner 

from physician p 

where p.dr_name *■ in__dr_name 

declare dr_hosp cursor for 

select p.dr_name, p.dr_address, p.phone_number 
from physician p, dr_hosp d 

where d.dr_name ■ p.dr_name and d.hosp_name - in_hosp_name 

declare spec_area cursor for 

select p.dr_name, p,dr_addres3, p.phone_numb€r 
from physician p 

where p.specialty ■ in_spec and p.area - in_area 


declare doc_ins cursor for 

select p.dr_name, p.dr_address, p.phone_number 
from physician p, dr_ins d 

where p.dr_name ■ d.dr_name and d.in_name ■ in_ins_name 


6/19/90 


page 87 








LMSC-F376702 


Contract F19628-88'D-0032/0002 
USER’S MANUAL Appcndiz D: Sample Proerams 


CDRL 2020 


declare area_ins cursor for 

select p.dr_naitie, p.dr_address, p.phone_number 
from physician p, dr_ins d 

where p.dr_najne ■ d.dr_name and in_ina_name • d.in_naine and 
in_area ■ p.area 


— Procedure Section 


" This procedure uses the executable form for starting a transaction 
procedure set_transaction 
sqlcode; 

set transaction read write; 

— This procedure opens the cursor that has been declared for the 

— physician table 
procedure open_dr_row 

in_dr_naine char (25) 
sqlcode; 

open dr_row; 

— This procedure closes the cursor 
procedure close_dr__row 

sqlcode; 

close dr_row; 

— This procedure fetches the data from the opened dr_row cursor 
procedure fetch_doctor 

in_dr_narae char (25) 
in_dr_addresa char (25) 

in_phone_number char (11) in_phone_ind smallint 
in_office_hours char (20) in_office_ind smallint 
in_area char(5) in_area_ind smallint 
in_specialty char (11) in_specialty_ind smallint 
in_bedside_manner int in_bedside_ind smallint 
sqlcode; 

fetch dr_row into in_dr_name, 

in_dr_addre s s, 

in_phone_number indicator in_phone_ind, 
in_office_hours indicator in_office_ind, 
in_area indicator in_area_ind, 
in_3pecialty indicator in_specialty_ind, 
in_bedside_manner indicator in_bed3ide_ind; 

— This procedure updates the doctor information by incrementing 

— the bedside manner 
procedure increment_bedside_manner 

sqlcode; 

update physician 

set bedside_manner - bedside_manner ^ 1 
where current of dr row; 


page 88 


6/19/90 




CDRL 2020 Coonact F19628-88-D-0032AX)02 

USER'S MANUAL Appendix D: Sample Prograiiu 


—This procedure adda a new insurance con^any to the database 
procedure insert_insurance 
Injnaine char (20) 

. deduc real 
ov real 
drug real 
sqlcode; 

insert into insurance 
values (in_naine, deduc, ov, drug) ; 

—This procedure adds a new hospital to the database 
procedure insert_hosp 
in_naiiie char (20) 
in_address char (20) 
sqlcode; 

insert into hospital 
values(in_name,in_address); 

—This procedure adds a new dr to the database 
procedure insert__dr 

in_dr_naa»e char (25) 
in_dr_addreaa char (25) 

in_phone_nuniber char (11) in_phone_ind smallint 
in_office_hours char (20) in_of£_hrs_ind smallint 
in__area char (5) ln__area_ind smallint 
in_specialty char (11) in_apec_ind smallint 
in__bedside_manner int in_bed_inan_ind smallint 
sqlcode; 

insert into physician 

values (in_dr_naine, in_dr_address, 

in_phone_nuinber in_phone_ind, 
in_office_hours in_off__hrs_ind, 
in_area in_area_ind, 
in_specialty in_spec_ind, 
in_bedside_manner in_bed_inan_ind) ; 

—This procedure adds a new doctor & insurance pair to the 

— dr_ins table 
procedure insert_dr_ina 

in_dr_naine char (25) 
in_ins_name char (20) 
sqlcode; 

insert into dr_ins values (in_dr_neune, in_in3_name) ; 

—This procedure adds a new doctor £ hospital pair to the 

— dr_hosp table 
procedure in3ert_dr_hosp 

in_dr_name char (25) 

in_hosp_naine char (20) , 

sqlcode; 

insert into dr_hosp values (in_dr_nan«, in_hosp_name); 

—This procedure tells doctors at a certain hospital 


LMSC-F376702 


6/19/90 


page 89 




LMSC-F376702 Conttart F19628-88-D-0032/D002 

USER’S MANUAL Appendix D: Sample Programs 

procedure open_dr_hosp 
in_hosp_naine char (20) 
sqlcode; 

open dr_hosp; 

— This procedure fetches a row from the dr_hosp cursor 
procedure fetch_dr_hosp 

in_dr_name char (25) 
in_dr_address char (25) 

in_phone_number char (11) in__phone_ind smallint 
sqlcode; 

fetch dr_hosp into in_dr_name, 

in_dr_address , 

in__phone_nuinber indicator in_phone_ind; 

— This procedure closes the cursor 
procedure close_dr_hosp 

sqlcode; 

close dr_hosp; 

—This procedure deletes a doctor from the dr table 
procedure delete_dr_in_dr 
in_dr_name char (25) 
sqlcode; 

delete from physician 
where dr_name ■ in_dr_name; 

—This procedure deletes a doctor from insurance table 
procedure delete_dr_in_ins 
in_dr_name char (25) 
sqlcode; 

delete from dr_ins 

where dr__name ■ in_dr_name; 

—This procedure deletes a doctor from the hospital table 
procedure delete_dr_in_hosp 
in__dr_name char (25) 
sqlcode; 

delete from dr_hosp 
where dr_name - in_dr_name; 

—This procedure selects all doctors w/ a certain 
-o specialty within a certain area 
procedure open_spec_area 
in_spec char (11) 
in_area char (5) 
sqlcode; , 

open spec area; 

"This procedure will fetch a row from the spec_area cursor 
procedure fetch_spec_area 


CDRL2020 


page 90 


6/19/90 




CDRL 2020 Coniract F19628-88-D-0032/0002 

USER’S MANUAL Appeal D: Sampk Programs 

in_dr_naine char (25) 
in_dr_addre5S char (25) 

in__phone_nuinber char (11) in_phone_ind sinallint 
sqlcode; 

fetch spec_area into in_dr_naine, 

in_dr_addre3 a , 

in_phone_nuniber indicator in_j5hone_ind; 

— This procedure closes the cursor 
procedure close_spec_area 

sqlcode; 

close spec_area; 

—This procedure selects doctors with certain insurance 
procedure open_doc_ins 
in_ins_naine char (20) 
sqlcode; 

open doc_in3; 

—This procedure will fetch a row from the doc_ins cursor 
procedure fetch_doc_in3 
in_dr_name char (25) 
in_dr_address char (25) 

in_jphone_number char (11) in_phone_ind smallint 
sqlcode; 

fetch doc_ins into in_dr_nanie, 

in_dr_address, 

in_phone__number indicator in_phone_ind; 

— This procedure closes the cursor 
procedure close_doc_in3 

sqlcode; 

close doc_ins; 

—This procedure will update information about a doctor 
procedure update_doctor 
in_dr_n 2 une char (25) 
in_dr_address char (25) 

in_phone_number char (11) in_phone_ind smallint 
in_office_hours char (20) in_office_ind smallint 
in_area char(5) in_area_ind smallint 
in_specialty char (11) in_3pecialty_ind smallint 
in_bedside_manner int in_bedside_ind smallint 
sqlcode; 


update physician 

set dr_address ■ in__dr_addres3, 

phone_number in_phone_number in_phone_ind, 

office_hours ■ in_office_hours in_office_ind, 

area in_area in_area_ind/ 

specialty ■ in_specialty in_3pecialty_ind, 

bedside manner - in bedside manner in bedside ind 


LMSC-F376702 


6/19/90 


page 91 




LMSC-F376702 


CDRL2020 


Contnct F19628-88-D-0032/0002 
USER’S MANUAL Appcwfiz D: Sampk Prograiiis 

where dr_naine - in_dr_naine; 

—This procedure selects doctors within a specific 

— area that honor a specific insurance 
procedure open_area_ins 

in_ins_narne char (20) 
in_area char(5) 
sqlcode; 

open area_ins; 

—This procedure will fetch a row from the area_ins cursor 
procedure fetch_area_ins 
in_dr_iiaine char (25) 
in_dr_address char (25) 

in_phone_nuniber char (11) in_phone_ind smallint 
sqlcode; 

fetch area_in3 into in_dr_name, 

in_dr_addre s s, 

in_phone_nuniber indicator in_phone_ind; 

— This procedure closes the cursor 
procedure close_area_ins 

sqlcode; 

close area ins; 


— This procedure commits the transaction 
procedure commit__transaction 

sqlcode; 

commit; 

— This procedure rolls bac)c the transaction 
procedure rollback_transaction 

sqlcode; 

rollbaclc; 


Table D>6. Doctors^Domview • Domain Definition Procedure 


with abstract_domain_generator; 

with generator_support; use generator_support; 

procedure doctors_domview is 

type PACK_NAMES is (doctors_def__enum_p)cg, hospital_def_pkg, 

insurance_def_pkg) ; 

package DOM_PACKS is new abstract_domain_generator (PACK_NAMES); 

begin 

declare 

type DOMS is (dr_name, dr_address, phone_number, office_hours, 

area, specialty, bed3ide_manner); 
package DOMAIN_l is new DOM_PACKS.generate_domain_package 

(doctors_def_enum_pkg , DOMS); 


page 92 


6/19/90 



CDRL2020 


ContiBCt F19628-88-D-0032A)002 
USER’S MANUAL Appemtti'D: Sample Programs 


LMSC-F376702 


package FIRST is new D0MAIN_1.generate_int_domain 
(dr_nanre, char, not_null, 1, 25); 
package SECOND is new DOMAlN_l .generate_int_doinain 
(dr_address, char, not_null, 1, 25); 
package THIRD is new DC»lAIN_l.generate_int_doniain 
(phone_nuinber, char, null_and_not_null, 1, 11) ; 
package FOURTH is new DOMAIN_l.generate_int__domain 
(office_hour 3 , char, null_and_not_null, 1, 20); 
type areas is (north, south, east, west); 
package FIFTH is new DOMAIN_l.generate_enum_domain 
(areas, area, enumeration, null_and_not_null); 
package SIXTH is new DOMAIN_l .generate_int_doniain 
(SF>ecialty, char, null_and_not_null, 1, 11) ; 
package SEVENTH is new DOMAIN_l.generate_int_domain 
(bedside_manner, int, null_and_not_null, 1, 10); 

begin 

DOMAIN_l.start_generation; 

end; 

declare 

type DOMS is (ins_name, deductible, ov_copay, drug_copay); 

package DOMAIN_2 is new DOM_PACKS.generate_doinain_package 

(insurance_def_pkg , DOMS); 
package FIRST is new DOMAIN_2.generate_int_domain 
(ins_name, char, not_null, 1, 20); 
package SECOND is new DOMAIN_2 .generate_flt__doinain 
(deductible, real, not_^null, 0.00, 2500.00); 
package THIRD is new DOMAIN_2.generate_flt_domain 
(ov_copay, real, not_null, 0.00, 25.00); 
package FOURTH is new DOMAIN_2 .generate_flt_doinain 
(drug_copay, real, not_null, 0.00, 20.00); 

begin 

DOMAIN_2.start_generation; 

end; 

declare 

type DOMS is (hosp_naine, hosp_address); 

package DOMAIN_3 is new DCM_PACKS.generate_domain_package 

(hospital_def_pkg , DOMS); 
package FIRST is new DOMAIN_3 .generate_int_doinain 
(hosp_naiQe, char, not_null, 1, 20); 
package SECOND is new DOMAIN_3 .generate_int_doinain 
(hosp_address, char, not_null, 1, 20); 

begin 

DOMAIN_3.atart_generation; 

end; 

DOM_PACKS.generate_base_specific; 
end doctors domview; 


Table D-7. I>octors_Def_Enuin_Pkg • 1st Abstract Domain Package Specification 

with sql_char_pkg; 

use sql_char_pkg; 

with sql_int_pkg; 

use sql_int_pkg; 

with sql_enuineration_pkg; 


6/19/90 


page 93 


LMSC-F376702 


Coniract F19628-88-D-0032/0002 
USER’S MANUAL Appendix D: Sample Programs 


C:DRL2020 


package doctors_def_enum_pkg is 

type dr_nainenn_base is new sql_char_pkg.sql_char_not_null; 
subtype dr_naiine_not_null is dr_nainenn_base (1..25); 

type dr_addressnn_base is new sql_char_pkg.sql_char_not_null; 
subtype dr_address_not_null is dr_addressnn_base (1..25); 

type phone_nuinbernn_base is new sql_char_pkg.sql_char_not_null; 
subtype phone_nuinber_not_null is phone^nuinbernn_base {1..11); 
type phone_nuinber_base is new sql_char^kg,sql_char; 
subtype phone_number_type is phone_nuniber_ba3e 

(phone_nun\ber_not_null' length) ; 


package phone_nuinber_ops is new 

sql_char_pkg. sql_char_ops (phone_nuinber_base, 

phone_nunibemn_base) ; 

type office_hoursnn_base is new sql_char_pkg.sql_char_not_null; 
subtype office_hours_not_null is office_hoursnn_base (1..20); 
type office_hours_base is new sql_char__pkg.sql_char; 
subtype office_hours_type is office_hours_base 

(office_hours_not_null'length); 


package office_hours_ops is new 

sql_char_pkg.sql_char_ops(office_hours_base, 

office_hour3nn_base); 

type area_not_null is (north, south, east, west); 
package area_ops is new 

3ql_enuineration_pkg (area_not_null); 

♦•ype specialtynn_base is new sql_char_pkg.sql_char_not_null; 
subtype specialty_not_null is 3p>ecialtynn_base (1..11); 
type specialty_ba3e is new sql_char_pkg.sql_char; 
sxibtype speciaity_type is 3F>ecialty_base 

(specialty_not_null'length); 

package specialty_op3 is new 

sql_char_pkg.sql_char_ops(specialty_base, 

3pecialtynn_base); 

type bedside_manner_not_null is new sql_int_not_null 

range 1..10; 

type bed3ide_tnanner_type is new sql_int; 
package bedside_inanner_ops is new 

sql_int_ops(bedside_manner_type, bedside_inanner_not_null); 

end doctors_def_enuin_pkg; 


Table D-8. Hospital_Def_Pkg • 2nd Abstract Domain Package Specification 

with sql_char_pkg; 

use 3ql_char_pkg; 

package hospital_def_pkg is 

type hosp_naunenn_ba3e is new 3ql_char_pkg .3ql_char_not_null; 
subtype hosp_name_not_null is hosp_nainenn_ba3e (1..20); 


iage94 


6/19/90 





CDRL2020 


Cooiraa F19628^IM)032/0002 
USUI’S MANUAL Appcadir D: Sampk Programs 


LMSC-F376702 


type hosp_addressnn_baae is new aql_char_pkg.sql_char_not_null; 
subtype hosp_address_not_null Is hosp_addressnn_base (1..20); 

end hospital_def_pkg; 


Table D>9. Iiisuraiice_Def_Pkg - 3rd Abstract Domain Package Spedfication 


with sql_char_pkg; 

use sql_char_pkg; 

with sql_real_pkg; 

use sql_real_pkg; 

package insurance_def_pkg is 

type ins_nainenn_base is new sql_char_pkg.3ql_char_not_null; 
subtype in3_name_not_null i3 in3_nafflenn_ba3e (1..20); 

type deductible_not_null i3 new 3ql^real_not_null 
range 0.00000..2500.00000; ” 

type ov_copay_not_null is new sql_real_not_null 
range 0.00000. .25.00000; 

type drug_copay_not_null is new sql_real_not_null 
range 0.00000. .20.00000; ~ 

end in3urance_de£_pkg; 


Table D<10. Base_SpecificJDonHuiis • Domain Description Spedfication 

with generator_support; 

use generator^support; 

package base_speci£ic_doinains is 

type base_specific_doinain_types is (dr_naine_not_null, 
dr_address_not_null, phone__nuinber_not_null, 
phone_nuinber_type, of f ice_hours_not_null, 
office_hours_type, area_not_null, area_type, 
specialty_not_null, specialty_type, 
beds ide_manne r_not_null, beds ide_inanne r_type, 
ins_naine_not_null, deductible_not_null, 
ov_copay_not_null, drug_copay_not_null, 
hosp_naine_not_null, hosp_addre3s_not_null, 
null_doniain_type) ; 

type corresponding_concrete_types is <dr_naine_not_null_char_25, 

dr_address_not_null_char_25,phone_nuinb€r_not_null_char_ll, 
phone_nuinber_type_char_ll, office_hours_not_null_char_20, 
office_hours_type_char_20, area_not_null_enumeration, 
area_type_enumeration, specialty_not_null_char_ll, 
specialty_type_char_ll, bedside_inanner_not_null_int, 
beds ide_manne r_type_int, ins_naine_not_nul l_cha r_2 0, 
deductible_not_null_real, ov_copay_not_null_real, 
drug_copay_not_null_real, hosp_naine_not_null_char_20, 
hosp_addres3_not_null_char__20); 

type valid_doinain_names is {doctor3_def_enum_pkg, hospital_def_pkg, 

insurance_def_pkg); 


6/19/90 


page 95 






LMSC-F376702 


ConiXKt F19628-88'D-003?/0002' 

USER’S MANUAL Appendix D: Sampk Programs 


CDRL2020 


type ops_packages is (phone_nuinber_ops, of£ice_hours_op3, area_ops, 

specialty_ops, bedside_manner_ops); 

longest_enum_value : constant integer 5; 

type doniainjpackage_array is array (positive range <>) of 

valid_domain_names; 

end base_speci£ic_doinains; 

Table D-11. Doctors_lntview_Enuiii - 1st Interface Definition Procedure 

with base_speci£ic_domains; 

use base__speci£ic_doinains; 

with abstract_inter£ace_generator; 

with generator_support; use generator_support; 

procedure doctors_intview_enum is 

type record_naines is (doctor_record, insurance_record, 

hospital_record, dr_ins_record, 
dr_hosp_record); 

type proc_nanves is (open_dr_row, close_dr_row, £etch_doctor, 

insert_insurance> insert_hosp, 
insert_dr, insert_dr_ins, insert_dr_hosp, 
delete_dr_in_dr, delete_dr_in_ins, 
delete_dr_in_hosp, update_do-tor, 
coinait_transaction,. rollback_transaction) ; 

type ok_errors is (cursor_already_open, cursor__not_open, not_£ound, 

duplicate_valuer £etch_not_done); 

package iny_inter£ace is new abstract__inter£ace_generator 

("concrete_inter£ace_enum",'”"abstract_inter£ace_enum", 
"dbms_speci£ic_enuni", (1 -> doctors_de£_enum_pkg, 

2 ->> insurance_de£_pkg, 3 -> hospital_de£jpkg), 
record_na]neSr proc_nanies, ok_errors, 

(l-> 1001, 2-> -501, 3-> 100, 4-> -803, 5-> -508)); 

use my_inter£ace; 

begin 

declare 

type rec_conponents is (dnaine, daddress, dphone, do££_hrs, 

darea, dspec, dbed_nian); 

package reel is new record_generator (rec_coirponents, 

doctor_record); 

package com_ll is new reel .coinponent_generator 

(dname, dr_name_not^null) ; 
package com_12 is new reel.component_generator 

(daddress, dr_addre5S_not_null); 
package coin_13 is new reel .conponent_generator 

(dphone, phone_nuinber_type) ; 
package com_14 is new reel .cottqponent_generator 

(do££_hrs, o££ice_hour3_type); 
package coin_15 is new recl.component_generator 

(darea, area_type); 


page 96 


6/19/90 





CDRL2020 


Coatna F19628-8S-D-0032A)002 
USER’S MANUAL AppcMUx D: Sample Programs 


LMSC-F376702 


package com_16 is new recl.coinponent_generator 

(dspec, specialty_type); 
package com_17 is new recl.con 5 )onent_generator 

(dbed_inan, bedside_inanner_type) ; 

begin 

reel.generate_record; 
end; 

declare 

type rec_conf>onenta is (iname, ided, iov_co, idr_co); 
package rec2 is new record_generator (rec_cornponents, 

insurance_record) ; 

package com_21 is new rec2.con^onent_generator 

(iname, ins_name_not_null); 
package com_22 is new rec2.component_generator 

(ided, deductible_not_null); 
package coin_23 is new rec2 .coniponent_generator 

(iov_co, ov_copay_not_null); 
package com_24 is new rec2.con^onent_generator 

(idr_co, drug_copay_not_null); 

begin 

rec2.generate_record; 
end; 

declare 

type rec_con^onents is (hnarae, haddress); 

package rec3 is new record_generator (rec_con^onents, 

hospital_record); 

package com_31 is new recS.con^onentjgenerator 

(hname, hosp_name_not_null); 
package com_32 is new rec3.component_generator 

(haddress, hosp__addresfis_not_null) ; 

begin 

rec3.generate_record; 
end; 

declare 

type rec_conponents is (dnaine, iname) ; 

package rec5 is new record_generator (rec_conponents, 

dr_ins_record); 

package com_51 is new recS.component^generater 

(dname, dr_name_not_null) ; 
package com_52 is new rec5.component_generator 

(iname, ins_name_not_null) ; 

begin 

rec5.generate_record; 
end; 

declare 

type rec_con^onents is (dname, hnasve); 

package rec6 is new record_generator (rec_con 5 Jonents, 

dr_hosp_record); 

package com_€l is new rec€.component_generator 

(dname, dr_name_not_null) ; 
package com_62 is new rec6.component_generator 

(hname, hosp_name_not_null); 

begin 

rec6.generate_record; 


6/19/90 


page 97 



LMSC-F376702 


Cootiact F19628-88-D-0032/0002 
USER’S MANUAL Appcadta'D: Sample Programs 


C35RL2020 


end; 

declare 

type params Is (in_dr_naine, result); 

type pareuns_conc is (in_dr_naffle); 

package procedurel is new procedure_with_paraineters_generator 
(procedure_name “> open_dr_row, 
parameters *■> params, 
sql_statement_type “> open, 
sql_module_procedure_name “> "open_dr_row'’, 
params^to_concrete_procedure *> params_conc, 
valid_errors ■> (1 “> cursor_already_open)); 

use procedurel; 

package paraml is new params_o£_domain_type_generator 

(in__dr_name, dr_name_not_null) ; 

package param2 Is new params_o£_error_conditions_generator 

(result); 

begin 

procedurel.generate_procedure; 

end; 

declare 

package procedure2 is new 

procedure_without_parameters_generator 

(procedure_name ■•> close_dr_row, 
sql_statement_type ■> close, 
sql_module_procedure__naine -> "close_dr__row"); 

begin 

procedure2.generatejprocedure; 

end; 

declare 

type params is (dr_record, result); 

type params_conc is (dname, daddress, (^hone, do££_hrs, 

darea, dspec, dbed_man); 

package procedures is new procedure_with_parameters_generator 
(procedure_name -> £etch_doctor, 
parameters ~> params, 
sql_statement_type “> £etch, 
sql_module_procedure_name “> "£etch_doctor", 
params_to_concrete_procedure •«> params_conc, 
valld_errors “> (1 -> cursor_not_open, 

2 ■> not_£ound)); 

use procedures; 

package paraml is new params_o£_record_type_generator 

{dr__record, doctor_record) ; 

package param2 is new params_o£_error_conditions_generator 

(result); 

begin 

procedures.generate_procedure; 

end; 

declare 

type params is (ins_record, result); 

type params_conc is (iname, ided, iov_co, idr_co, result); 

package procedures is new procedure_withjparameters_generator 
(procedure_name •> insert_insurance, 
parameters -> params, - 


page 98 


6/19^ 


CDRL2020 


CcntEBCt F19628^*D-0032AX)02 
USER’S MANUAL Appeadix O: Sampk Programs 


LMSC-F376702 


8ql_statenient_typ>e -> insert_values, 
aql_module_procedure_naine “> 

■insert_insurance", 

paraina_to_qoncrete_procedure “> parains_conc, 
valid_errors -> (1 -> duplicate_value)); 

use procedures; 

package paraml is now parains_of_record_type_generator 

<ins_record, insurance_record); 

package parain2 is new parains_of_error_conditions_generator 

(result); 

begin 

procedures.generate_procedure; 
end; 

declare 

type params is (hosp_record, result); 
type parains_conc is (hname, haddress, result); 
package procedures is new procedure_with_parameters_generator 
(procedure_naine •■> insert_hosp, 
parameters ■•> params, 
sql_statement_type -> insert_value3, 
sql_module_procedure_name -> "insert_hosp", 
params_to_concrete_procedure ■> parain3_conc, 
valid_errors ■> (1 "> duplicate_value)); 

use procedures; 

package paraml is new params_of_record_type_generator 

(ho3p_record, hospital_record); 

package param2 is new params_of_error_conditions_generator 

(result); 

begin 

procedures.generate_procedure; 
end; 

declare 

type params is (dr_record, result); 

type params_conc is (dname, daddress, dphone, doff_hrs, 

darea, dspec, dbed_inan, result) ; 
package procedure? is new procedure_with_parameters_generator 
(procedure_name ■> insert_dr, 
parameters >> params, 
sql_statement_type -> insert_value3, 
sql_module_procedure_name -> "in3ert_dr", 
params_to_concrete_procedure •> parains_conc, 
valid_errors -> (1 ■> duplicate_value)); 

use procedure?; 

package paraml is new params_of_record_type_generator 

(dr_record, doctor_record); 

package param2 is new params_of_error_conditions_generator 

(result); 

begin 

procedure?.generate_procedure; 
end; 

declare 

type params is (dr_in3_rec, result); 
type params_conc is (dname, iname, result); 
package procedures is new procedure_with_parameters_generator 
(procedure_name "> insert_dr_ins. 


6/19/90 


page 99 






LMSC-F376702 


Coamct F19628-88<D-0032/0(X)2 
USER’S MANUAL Appcadix D: Sample Programs 


CDRL2020 


parameters -> params, 
sql_statement_type ■> insert_values, 
sql_module_procedure_name ••> "insert_dr_in3", 
params_to_concrete_procedure *> params_conc, 
valid_errors -> (1 ■•> duplicate_value)) ; 

use procedures; 

package paraml is new params_of_record_type_generator 

(dr_ins_rec, dr_ins_record); 

package parain2 is new param3_of_error_conditions_generator 

(result); 

begin 

procedures.generate_procedure; 
end; 

declare 

type params is (dr_hosp_rec, result); 
type params_conc is (dneune, hname, result); 

package procedures is new procedure_with_parameters_generator 
(procedure_name «»> insert_dr_hosp, 
parameters -> params, 
sql_statement_type “> insert_values, 
sql_module_procedure_name ■> "insert_dr_hosp", 
params_to_concrete_procedure “> params_conc, 
valid_errors “> (1 «> duplicate_value)); 

use procedures,* 

package paraml is new params__of_record_type_generator 

(dr_hosp_rec, dr_hosp_record); 

package param2 is new params_of__error_conditions_generator 

(result); 

begin 

procedures.generate_procedure; 
end; 

declare 

type params is (dr_naroe, result); 
type params_conc is (dr_naroe, result); 
package procedurel3 is new 

procedure_with_pararoeters_generator 

(procedure_naroe -> delete_dr_in_dr, 
parameters params, 
sql_statement_type ■•> delete^searched, 
sql_module_procedure_name 

"delete_dr_in_dr", 

params_to_concrete_procedure ■> par 2 uns_conc, 
valid_errors ■> (1 ■> not_found)); 

use procedurel3; 

package par 2 unl is new parama_of_domain_type_generator 

(dr__name, dr_name_not_null) ; 

package param2 is new params_of_error_conditions_generator 

(result); 

begin 

procedurel3.generate_procedure; 
end; , 

declare 

type params is (dr_name, result); 
type params_conc is (dr_narae, result); 
package procedurel4 is new 


page 1(X) 


6/19/90 



a«L2Q20 


CootEKt F19628-88-D-0032/0002 
USER’S MANUAL Appcadtr D: Sample Programs 


LMSC-F376702 


procedure_with_paraineters_^generator 

(procedure_nane “> delete_dr_in_ins, 
parameters ■> paramsr 

sql_statement_type ->> delete_searched, 
sql_inodule_procedure_name -> 

"delete_dr_in_ins", 

parama_to_concrete_procedure ■> params_conc, 
valid_errors “> (1 ■> not_found)); 
use procedurel4; 

package paraml is new parains_of_domain_type_generator 

(dr_name, dr_name_not_null); 

package param2 is new params_of_error_conditions_generator 

(result); 

begin 

procedurel4.generate_procedure; 
end; 


declare 

type params is (dr_name, result); 

type params_conc is (dr_name, result); 

package procedurelS is new 

procedure_with_parameters_generator 

(procedure_name -> delete_dr_in_hosp, 
parameters ->> params, 

sql_statement_type ■•> delete^searched, 
sqljinodule_procedure_name -> 

"delete_dr_in_hosp", 
params_to_concretejprocedure ■> params_conc, 
valid_errors ■> {1 ■> not_found)); 

use proeedLurelS; 

package paraml is new params_of_domain_type_generator 

(dr_name, dr__name__not_null); 

package param2 is new params__of_error_conditions_generator 

(result); 

begin 

procedurelS. generate_j>rocedure ; 

end; 

declare 

package procedurelS is new 

procedure_without_parameters_generator 

(procedure_name -> conimit_transaction, 
sql_statement_type -> commit, 
sql_module_procedure_name *> 

"comiiiit_transaction'') ; 

begin 

procedurelS. generate__procedure ; 

end; 

declare 

package procedure20 is new 

procedure_without_parameters_generator 

(procedur^_name •> rollback_tran3action, 
sql_statement_typ>e «> rollback, 
sql_module_procedure_name ■> 

"rollback_transaction"); 

begin 

procedure20.generate_procedure; 


6/19/90 


page 101 



LMSC-F376702 


Coatna F19628-88-D-0032AX)02 
USER’S MANUAL Appcpdlx'D: Sample Programs 


CDRL2020 


end; 

declare 

type params is (doc_naine, doc_address, doc_phone, 

doc_off_hrs, doc_area, doc_spec, 
doc_bed_man, result); 

type params_conc is (doc_nane, doc_address, doc_phone, 

doc__off_hrs, doc_^area, 
doc_spec, doc_bed_man, result); 

package procedure27 is new 

procedure_with_parainetera_generator 

(procedure_naflie ■> update_doctor, 
parameters -> params, 

sql_statement_type “> update_searched, 
sql_module_procedure_name •■> "update_doctor", 
params_to_concrete__procedure -> params_conc, 
valid_errors «> (1 “> duplicate_value)); 

use procedure27; 

package paraml is new params_of_domain_type_generator 

(doc_name, dr_name_not_null) ; 
package param2 is new params_of_domain_type_generator 

(doc_address, dr_address_not_null) ; 
package param3 is new params_of_domain_type_generator 

(doc_phone, phone_number_type); 
package param4 is new params_of_domain_type_generator 

(doc_off_hrs, office_hours_type); 
package paramS is new params_of_domain_type_generator 

{doc__area, area_type); 

package param€ is new params_of_domain_type_generator 

(doc_spec, specialty_type); 

package pararn? is new params_of_domain__type_generator 

(doc_bed_roan,bedside_manner_type); 
package paramS is new params_of_error_conditions_generator 

(result); 

begin 

procedure27.generate_procedure; 

end; 

my_inter£ace.generate_interface; 
end doctors_intview_enum; 

Table D-12. Abstract_Interface_Enuin - 1st Abstract Interface Package Specification 

with DOCTORS_DEF_ENUM_PKG; 
use DOCTORS_DEF_ENUM_PKG; 
with INSURANCE_DEF_PKG; 
use INSURANCE_DEF_PKG; 
with HOSPITAL_DEF_PKG; 
use HOSPITAL_DEF_PKG; 
with sql_standard; 
use sql_standard; 

package abstract_inter£ace_enum is 

type valid_status_result_type is {CURSOR_ALREADY_OPEN, 

CURSOR_NOT_OPEN, NOT_FOUND, 

DUPLICATE VALUE, FETCH NOT DONE); 


page 102 


6/19/90 






CDRL 2020 Cbotna F19628-88'D-0032A)0Q2 

USER’S MANUAL Appcadix D: Sample Programs 

typo DOCTOR_RECORD is record 
DNAME : DR_NAME_NOT_NULL; 

DADDRESS : DR_ADDRESS_NOT_NULL; 

DPHONE ; PHONEJHUMBERJTYPE; 

DOFF_HRS : OFFICE_HOURS_TyPE; 

DAREA : AREA_TYPE; 

DSPEC : SPECIALTY_TYPE; 

DBED_MAN ; BEDSIDE_MANNER_TYPE; 
end record; 

type INSXJRANCE_RECOKD is record 
INAME : INS_NAME_NOT_NULL; 

IDED : DEDUCT IBLE__NOT_NULL; 

10V_C0 : OV_COPAy_NOT_NULL; 

IDR_CO : DRUG_COPAY_NOT_NULL; 
end record; 

type HOSPITAL_RECORD is record 
HNAME : HOSP_NAME_NOT_NULL; 

HADDRESS : HOSP_ADDRESS_NOT_NULL; 
end record; 

type DR_INS_RECORD is record 
DNAME : DR_NAME_NOT_NULL; 

INAME ; INS_NAME_NOT_NULL; 
end record; 

type DR_HOSP_RECORD is record 
DNAME ; DR_NAME_NOT_NULL; 

HNAME : HOSP_NA5iE_NOT_NULL; 
end record; 

procedure OPEN_DR_ROW(IN_DR_NAME : in DR_NAME_NOT_NULL; 

RESULT ; out valid_status_result_type); 

procedure CLOSE DR ROW; 


procedure FETCH_DOCTOR{DR_RECORD ; in out DOCTOR_RECORD; 

RESULT ; out valid_statu3_result_type); 

procedure INSERT_INSURANCE(INS_RECORD : in 1NSURANCE_REC0RD; 

RESULT ; out valid_status_result_type); 

procedure INSERT_HOSP(HOSP_RECORD ; in HOSPITAL_RECORD; 

RESULT : out valid_status_re3ult_type); 

procedure INSERT_DR(DR_RECORD : in DOCTOR_RECORD; 

RESULT : out valid_status_re3ult_type); 

procedure INSERT_DR_INS<DR_INS_REC : in DR_INS_RECORD; 

RESULT ; out valid_3tatu3_re3ult_type); 

procedure INSERT_DR_HOSP(DR_HOSP_REC : in DR_HOSP_RECORD; 

RESULT : out valid_3tatus_re3ult_type); 

procedure DELETE_DR_IN_DR(DR_NAME : in DR_NAME_NOT_NULL; 

RESULT : out valid_3tatu3_re3ult_type); 


LMSC-F376702 


6/19/90 


page 103 



LMSC-F376702 


CDRL2020 


Conma F19628^-D-0032/0002 
USER’S MANUAL Appeodix D: Sample Programs 


procedure DELETE_DR_IN_INS(DR_NAME : in DR_NAME_NOT_NULL; 

RESULT : out valid_status_result_type); 

procedure DELETE_DR_IN_HOSP(DR_NAME : in DR_NAME_NOT_NULL; 

RESULT : out valid_status_result_type); 

procedure COMMIT_TRANSACTION; 

procedure ROLLBACK_TRANSACTION; 

procedure UPDATE_DOCTOR(DOC_NAME : in DR_NAME_NOT_NULL; 

DOC_ADDRESS : in DR_ADDRESS_NOT_NULL; 
DOC_PHONE : in PHONE_NUMBER_TYPE; 
DOC_OFF_HRS : in OFFICE_HOURS_TYPE; 
DOC_AREA : in AREA_TyPE; 

DOC_SPEC : in SPECIALTY_TYPE; 
DOC_BED_MAN : in BEDSIDE_MANNER_TYPE; 
RESULT : out valid_status_result_type); 

end abstract interface enuin; 


Table D*13. Abstract_Interface_Enuin - 1st Abstract Interface Package Body 

with sql__coinmunications_pkg, sql__database_error_pkg, conversions, 
concrete_interface_enum; 

use sql_communications_pkg, sql_databasejerror_pkg, conversions; 

package body abstract_interface_enum is 

use PHONE_NUMBER_OPS, 0FF1CE_H0URS_0PS, AREA_OPS, SPECIALTY_OPS, 
BEDSIDe3«ANNER_0PS 

CURSOR_ALREADY_OPEN_VALUE ; constant :« 1001; 

CURS0R__N0T_0PEN_VALUE : constant -501; 

NOT_FOUND_VALUE : constant 100; 

DUPLICATE_VALUE_VALUE : constant. -803; 

FETCH_NOT_DONE_VALUE : constant -508; 

procedure OPEN_DR_ROW(IN_DR_NAME ; in DR_NAME_NOT_NULL; 

RESULT : out valid_status_result_type) is 

begin 

concrete_interface_enum.open_dr_row 

(CHAR{IN_DR_NAME), SQLCODE); 
if sqlcode - CURSOR_ALREADY_OPEN_VALUE then 
RESULT C:URSOR_ALREADY_OPEN; 
elsif sqlcode /- 0 then 
process_database_error; 
raise sql_database_error; 
end if; 

end OPEN_DR_ROW; 

procedure CLOSE_DR_ROW is 
begin 

concrete_interface_enum.close_dr_row (sqlcode); 
if sqlcode /■■ 0 then 

process_database_error; 


page 104 


6/19/90 





CDRL2020 


Conoact F19628-88-D-0032/0002 

USER’S MANUAL AppcndU D: Sample Programs 


LMSC-F376702 


raise sql_database_error; 
end if; 

end CLOSE_DR_ROW; 

procedure FETCH_DOCTOR{DR_RECORD : in out DOCTOR_RECORD; 

RESULT : out valid_status_result_type) is 
DPHONE^c : CHAR(l..ll) (others -> ’ '); 

DPHONE^indic : indicator_type; 

DOFF_HRS_c : CHAR(1..20) (others -> ’ '); 

DOFF_HRS_indic : indicator_type; 

DAREA_c : char (1.. 5) (others -> * '); 

DAREA_indic : indicator_type; 

DSPEC_c : CHAR(l..ll) (others «> ' '); 

DSPEC_indic : indicator_type; 

DBED_MAN_C : INT; 

DBED_MAN_indic : indicator_typ>e; 
begin 

concrete_interface_enuia.fetch_doctor (CHAR(DR_RECORD.DNAME), 

CHAR(DR_RECORD.DADDRESS), 

DPHONE_C, DPHONE_indic, 

DOFF_HRS_c, DOFF_HRS_indic, 
DAREA_C, DAREA_indic, DSPEC_c, 
DSPEC_indic, DBED_MAN_C, 
DBED_MAN_indic, SQLCODE); 
if sqlcode - CURSOR_NOT_OPEN_VALUE then 
RESULT CURSOR_NOT_OPEN; 

elsif sqlcode - NOT_FOUND_VALUE then 
RESULT NOT_FOUND; 

elsif sqlcode /- 0 then 
process_database_error; 
raise sql__database_error; 
else 

assign(DR_RECORD.DPHONE, 

PHONE_NUMBER_base(convert(DPHONE_c, DPHONE_indic))); 
assign(DR_RECORD.DOFF_HRS, 

OFFICE_HOURS_base(convert(DOFF_HRS_c, DOFF_HRS_indic))); 
assign(OR_RECORD.DAREA, 

with_null(AREA_NOT_NULL’value(string(DAREA_c)))); 
assign(DR RECORD.DSPEC, 

SPEClALTy_base(convert(DSPEC_c, DSPEC_indic))); 
assign(DR_RECORD.DBED_MAN, 

BEDSIDE_MANNER_TyPE(convert(DBED_MAN_c, DBED_MAN_indic))); 
end if; 

end FETCH_DOCTOR; 

procedure INSERT_INSURANCE(INS_RECORD : in INSURANCE_RECORD; 

RESULT : out valid_status_result_type) is 

begin 

concrete_interface_eniun.inaert_insurance(CHAR(INS_REC0RD.INAME), 

REAL (INS_RECORD.IDED), 

REAL(INS_RECORD.IOy_CO), 

REAL(INS_RECORD.IDR_CO), 

SQLCODE); 

if sqlcode - DUPLICATE_VALUE_VALUE then 
RESULT DUPLICATE_VALUE; 
elsif sqlcode /- 0 then 
process_database_error; 
raise sql_database_error; 


6/19/90 


page 105 





LMSC-F376702 


Contract F19628-88-D-0032/D002 
USER’S MANUAL Appendix D: Sample Programs 


CDRL2020 


end i£; 

end INSERT_INSURANCE; 

procedure INSERT_HOSP(HOSP_RECORD : in HOSPITAL_RECORD; 

RESULT : out valid_3tatus_ra3ult_type) i3 

begin 

concrete_interface_enum.in3ert_ho3p (CHAR(HOSP_RECORD.HNAME), 
CHAR(HOSP_RECORD.KADDRESS), SQLCODE); 
if eqlcode - DUPLICATE_VALUE_VALUE then 
RESULT DUPLICATE_VALUE; 
el3if 3qlcode /- 0 then 
proce33_databa3e_error; 
raiee 3ql_databa3e_error; 
end if; 

end INSERT_HOSP; 

procedure INSERT_DR(DR_RECORD : in DOCTOR_RECORD; 

RESULT : out valid_3tatus_re3ult_type) is 
DPHONE_c : CHAR(1..11) (others -> ' ’); 

DPHONE_indic ; indicator_type; 

DOFF_HRS_C : CHAR(1..20) (others -> ’ ’); 

DOFF_HRS_indic : indicator_type; 

DAREA_c : char (1.. 5) (others *> ' *); 

DAREA_indic : indicator_type; 

DSPEC_c : CHAR(1.,11) (others -> ' ’); 

DSPEC_indic : indicator_type; 

DBED__MAN_c : INT; 

DBED_MAN_indic : indicator_type; 
begin “* 

if is_null(DR_RECORD.DPHONE) 
then DPHONE_indic -1; 
else DPHONE_indic 0; 

DPHONE_c char(without_null_ba3e(DR_RECORD.DPHONE)); 
end if; 

if is_null(DR_RECORD.DOFF_HRS) 
then DOFF_HRS_indic -1; 

else DOFF_HRS_indic 0; 

DOFF_HRS_c char(without_null__ba3e(DR_RECORD.DOFF_HRS)); 
end if; 

if is_null(DR_RECORD.DAREA) 
then D/J^EA_indic :» -1; 
else DAREA_indic 0; 

DAREA_c 

Char(AREA_NOT_NULL'image(without_null(DR_RECORD.DAREA))); 
end if; 

if is_null(DR_RECOBD,DSPEC) 
then DSPEC_indic -1; 

else DSPEC_indic :«■ 0; 

DSPEC_c char(without_null_base(DR_RECORD.DSPEC)); 
end if; 

if is_null(DR_RECORD.DBED_MAN) 
then DBED_MAN_indic -1; 
else DBED_MAN_indic 0; 

DBED_MAN_c INT(without_null_base(DR_RECORD.DBED_MAN)); 
end if; ~ 

concrete_interface_enum.insert_dr (CHAR(DR_RECORD.DNAME), 

CHAR(DR_RECORD.DADDRESS), 
DPHONE_c, DPHONE_indic, 


page 106 


6/19/90 




CDRL2020 


Contract F19628-88-IM)032/00(» 

USER’S MANUAL Appcndiz D: Sampk Programs 


LMSC'F376702 


DOFF_HRS_C, DOFF_HRS_indic, 
DAREA_c, DAREA_indic, DSPEC_c, 
DSPEC_indic, DBED_MAN_c, 
DBED_MAN_indic, SQLCODE); 
if sqlcode - DtJPLICATE_VALUE_VALUE then 
RESULT DUPLICATE~VALUE; 
elsif sqlcode /“ 0 then 
process_database_error; 
raise sql_database_error; 
end if; 

end INSERT_DR; 

procedure INSERT_DR_INS{DR_INS_REC : in DR_INS_RECORD; 

RESULT : out valid_status_result_type) is 

begin 

concrete_interface_enuni.insert_dr_ins (CHAR(DR_INS_REC.DNAME), 

CHAR{DR_INS_REC.INAME), SQLCODE); 
if sqlcode - DUPLICATE_VALUE_VALUE then 
RESULT DUPLICATE_VALUE; 
elsif sqlcode /- 0 then 
process_database_error; 
raise sql_database_error; 
end if; 

end INSERT_DR_INS; 

procedure INSERT_DR_HOSP(DR_HOSP_REC : in DR_HOSP_RECORD; 

RESULT : out valid_status_result_type) is 

begin 

concrete_interface_enuin.insert dr_hosp (CHAR(DR_HOSP_REC.DNAME) , 

CHAR(DR_HOSP_R£C.HNAME), SQLCODE); 
if sqlcode - DUPLICATE VALUE_VALUE then 
RESULT DUPL1 CATE”vALUE; 
elsif sqlcode /«• 0 then 
process_database_error; 
raise sql_database_error; 
end if; 

end INSERT_DR_HOSP; 

procedure DELETE_DR_IN_DR(DR_NAME : in DR_NAME_NOT_NULL; 

RESULT : out valid_status_re3ult_type) is 

begin 

concrete_interface_enum.delete_dr_in_dr (CHAR (DR_NAME) , 

SQLCODE); 

if sqlcode - NOT_FOUND_VALUE then 
RESULT NOT_FOUND; 
elsif sqlcode /■ 0 then 
process_database_error; 
raise sql_database_error; 
end if; 

end DELETE_DR_IN_DR; 

procedure DELETE_DR_IN_INS(DR_NAME : in DR_NAME_NOT_NULL; 

RESULT : out valid_status_result_type) is 

begin 

concrete_interface_enuin.delete_dr_in_ins (CHAR(DR_NAME) , 

SQLCODE); 

if sqlcode - NOT_FOUND_VALUE then 
RESULT NOT FOUND; 


6/19/90 


page 107 




LMSC-F376702 


CDRL2020 


Connact F19628-88-D-0032A)002 
USER’S MANUAL Appendix D: Sample Programs 

elsif sqlcode /> 0 then 
process_databa3e_etror; 
raise sql_database_error; 
end if; 

end DELETE_DR_IN_1NS; . 

procedure DELETE_DR_1N_H0SP(DR_NAME : in DR_NAME_NOT_NULL; 

RESULT : out valid_status_re8ult_type) is 

begin 

concrete_interface_enum.delete_dr_in_hosp {CHAR(DR_NAME), 

SQLCODE); 

if sqlcode - NOT_FOUND_VALUE then 
RESULT NOT_FOUND; 
elsif sqlcode /- 0 then 
process_dat£d5a3e_error; 
raise sql_database_error; 
end if; 

end DELETE_DR_IN_HOSP; 

procedure COMMIT_TRANSACTION is 
begin 

concrete_interface_enum.conBiiit_transaction (sqlcode) ; 
if sqlcode /- 0 then 

process_database_error; 
raise sql__database_error; 
end if; 

end COMMIT_TRANSACTION; 

procedure ROLLBACK_TRANSACTION is 
begin 

concrete_interface_enum.rollback_transaction (sqlcode); 
if sqlcode /« 0 then 

process_database_error; 
raise sql__database_error; 
end if; 

end ROLLBACK_TRANSACTION; 

procedure UPDATE_DOCTOR(DOC_NAHE : in DR_NAME_NOT_NULL; 

DOC_ADDRESS : in DR_ADDRESS_NOT_NULL; 

DOC_PHONE : in PHONE_NUMBER_TYPE; 

DOC_OFF_HRS : in OFFICE_HOURS_TYPE; 

DOC_AREA : in AREA_TYPE; 

DOC_SPEC : in SPECIALTy_TyPE; 

DOC_BED_MAN : in BEDSIDE_MANNER_TyPE; 

RESULT : out valid_status_result_type) is 

DOC_PHONE_c:CHAR(PHONE_NUMBER_NOT_NULL’range)(others «> ' '); 
DOC_PHONE_indic : indicator_type; 

DOC_OFF_HRS_c:CHAR(OFFICE_HOURS_NOT_NULL'range):-(others ->' '); 
DOC_OFF_HRS_indic : indicator_type; 

D(X:_AREA_c : char (1.. 5) (others -> ’ '); 

DOC_AREA_indic : indicator_type; 

DOC_SPEC_c : CHAR(SPECIALTY_NOT_NULL’range) (others -> ' '); 
DOC_SPEC_indic : indicator_type; 

DCX:_BED_MAN_C : INT; 

DOC_BED_MAN_indic : indicator_type; 
begin 

if is null(DOC PHONE) 


page 108 


6/19^ 






CDRL2020 


Contiaa F19628-88-D-0032AXX)2 
USER’S MANUAL Appcadlz D: Sampk Programs 


LMSC-F376702 


then DOC_PHONE_indic -1; 
else DOC_PHONE_indic 0; 

DOC_PHONE_c :■ char(without_null_base(DOC_PHONE)); 
end if; 

if is_null(DOC_OFF__HRS) 

then DOC_OFF_HRS_indic -1; 
else DOC_OFF_HRS_indic 0; 

DOC_OFF_HRS_c char(without_null_base{DOC_OFF_HRS)); 
end if; 

if is_null(DOC_AREA) 

then DOC_AREA_indic :■ -1; 
else DOC_AREA_indic 0; 

DOC_AREA_c :- char(AREA_NOT_NUI*L'image{without_null(DOC_AREA))); 
end if; 

if is_null(DOC_SPEC) 

then DOC_SPEC_indic -1; 

else DOC_SPEC_indic :■> 0; 

DOC_SPEC_c char(without_null_base(DCX;_SPEC)); 
end if; 

if is_null(DOC_BED_MAN) 

then DOC_BED_MAN_indic -1; 
else DOC_BED_MAK_indic 0; 

DOC_BED_MAN_c INT(without_null_base(DOC_BED_MAN)); 
end if; 

concrete_interface_enuni.update_doctor (CHAR(DOC_NAME), 

CHAR(DOC_ADDRBSS), DOC_PHONE_c, 

DOC_PHONE_indic, DOC_OFF_HRS_c, 

DOC_OFF_HRS_indic, DOC_AREA_c, DOC_AREA_ihdic, 
DOC~SPEC_c, DOC_SPEC_indic, 

DOC_BED_MAN c, DOC_BED_MAN_indic, SQLCODE); 
if sqlcode - DUPLICATE VALUE_VALUE then ” 

RESULT DUPLICATE“vaLUE; 
elsif sqlcode /* 0 then 
process_database_error; 
raise sql_database_error; 
end if; 

end UPDATE_DOCTOR; 
end jUsstract interface enum; 


Table D-14. Concrete_Interface_Enuin • 1st Concrete Interface Package Specification 

with sql_standard; use sql_standard; 

package concrete_interface_enuin is 

procedure open_dr_row(IN_DR_NAME : in CHAR; 

sqlcode ; out sql_standard.sqlcode_type); 
pragma interface (sql, open_dr_row); 

procedure close_dr_row(sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, close_dr_row); 

procedure fetch_doctor(DNAME: in out CHAR; DADDRESS: in out CHAR; 
DPHONE : in out CHAR; 

DPHONE_indic : out sql_standard.indicator_type; 

DOFF_HRS : in out CHAR; 

DOFF_HRS_indic : out sql_standard.indicator_type; 


6/19/90 


page 109 





LMSC-F376702 


Contraa F19628-88-D-0032/00Gi2 
USER’S MANUAL Appcadbi D: Sample Programs 


CDRL2020 


DAREA : in out CHAR; 

DAREA_inciic : out aql_standard.indicator_type; 

DSPEC : in out CHAR; 

DSPEC_indic : out sql_standard.indicator_type; 

DBED_MAN : in out INT; 

DBED_MAN_indic : out sql_standard.indicator_type; 
sqlcode : out sql_standard.aqlcode_type); 
pragma interface (aql, fetch_doctor); 

procedure inaert_inaurance(INAME: in CHAR; 

lOEO: in REAL; 

IOV_CO: in REAL; 

IDR_CO: in REAL; 

aqlcode : out aql_3tandard.sqlcode_type); 
pragma interface (aql, inaert__insurance); 

procedure inaert_hosp(HNAME: in CHAR; 

HADDRESS: in CHAR; 

aqlcode : out aql_standard.sqlcode_type); 
pragma interface (aql, inaert_hoap); 

procedure insert_dr(DNAME: in CHAR; 

DADDRESS: in CHAR; 

DPHONE : in out CHAR; 

DPHONE_indic : in 3ql_standard.indicator_type; 
DOFF_HRS : in out CHAR; 

DOFF_HRS_indic:in 3ql_standard.indicator_type; 
DAREA : in out CHAR; 

DAREA indie ; in aql standard.indicator_type; 
DSPEC”; in out CHAR;" 

DSPEC^indic : in sql_standard.indicator_type; 
DBED^MAN ; in out INT; 

DBED_MAN_indic;in sql_standard.indicator_type; 
aqlcode : out sql_standard.sqlcode_type); 
pragma interface (aql, insert_dr); 

procedure insert_dr_ins(DNAME; in CHAR; 

INAME: in CHAR; 

aqlcode : out sql_standard.sqlcode_type); 
pragma interface (aql, in3ert_dr_ins); 

procedure insert_dr_hosp(DNAME: in CHAR; 

HNAME: in CHAR; 

aqlcode : out sql_standard.sqlcode_type); 
pragma interface (aql, inaert_dr_hosp); 

procedure delete_dr_in_dr(DR_NAME : in CHAR; 

aqlcode : out sql_standard.3qlcode_type); 
pragma interface (aql, delete_dr_in_dr); 

procedure delete_dr_in_ina(DR_NAME : in CHAR; 

aqlcode : out 3ql_standard.sqlcode_type>; 
pragma interface (sql, delete_dr_in_ins); 

procedure delete_dr_inj_hosp (DRJNAME : in CHAR; 

sqlcode : out 3ql_standard.3qlcode_type); 
pragma interface (sql, delete_dr_in_hosp); 


page 110 


6/19/90 




CDRL2020 


Cootnct F19628-88-D^2/0002 
USER'S MANUAL Avpndte D: Sample Programs 


LMSC-F376702 


procedure coinmit_transaction 

(sqlcode : out sql_standard.aqlcode_type); 
pragma Interface (sql, commit_transaction); 

procedure rollback_transactlon 

(sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, rollbaclc_transaction); 

procedure update_doctor(DOC_NAME : in CHAR; 

DOC_ADDRESS : in CHAR; 

DOC_PHONE : in CHAR; 

DOC_PHONE_indic : in sql_standard.indicator_type; 
DOC_OFF_HRS : in CHAR; 

DOC_OFF_HRS_indic : in sql_standard.indicator_type; 
DOC_AREA : in CHAR; 

DOC__AREA_indic : in sql_standard.indicator_type; 
DOc“sPEC : in CHAR; 

DOC_SPEC_indic : in sql_standard.indicator_type; 
DOC_BED_MAN : in INT; 

DOC_BED_MAN_indic : in sql_standard.indicator_type; 
sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, update_doctor); 

end concrete interface entjun; 


Table D-15. Dbms^Spedfic^Enum • 1st Interface Description Text File 

open_dr_row IN_DR_NAME in CHAR 25 
open__dr_row sqlcode out sqlcode_type 
close_dr_row sqlcode out sqlcode_type 
fetch_doctor DNAME in_out CHAR 25 
fetch_doctor DADDRESS in_out CHAR 25 
fetch_doctor DPHONE'in_out CHAR 11 
fetch_doctor DPHONE_indic out indicator_type 
fetch_doctor DOFF_HRS in_out CHAR 20 
fetch_doctor DOFF_HRS_indic out indicator_type 
fetch_doctor DAREA in_out CHAR 5 
fetch_doctor DAR£A_indic out indicator^type 
fetch_doctor DSPEC in_out CHAR 11 
fetch_doctor DSPEC_indic out indicator^type 
fetch_doctor DBED_MAN in_out INT 
fetch_doctor DBED_MAN_indic out indicator_type 
fetch_doctor sqlcode out sqlcode_type 
insert_insurance INAME in CHAR 20 
insert_insurance IDED in REAL 
insert_insurance IOV_CO in REAL 
insert_insurance IDR_CO in REAL 
insert_insurance sqlcode out sqlcode_type 
insert_hosp HNAME in CHAR 20 
insert_hosp HADDRESS in CHAR 20 
insert_hosp sqlcode out sqlcode_type 
insert_dr DNAME in CHAR 25 
insert_dr DADDRESS in CHAR 25 
insert_dr DPHONE in_out CHAR 11 
insert_dr DPHONE_indic in indicator_type 
insert_dr DOFF_HRS in_out CHAR 20 
insert_dr DOFF_HRS_indic in indicator_type 
insert dr DAREA in out CHAR 5 


6/19/90 


page 111 




LMSC-F376702 Cootn« F19628-88-I><X)32/0002 CDRL2020 

USER’S MANUAL ApptBdbi D: Sample Procrans 

insert_dr DAREA_indic in incLicator_type 
insert_dr DSPEC in_out CHAR 11 
insert_dr DSPEC_inciic in inciicator_type 
insert_dr DBEDJMAN in_out INT 
insert_dr DBED_MAN_indic in indicator_type 
insert_dr sqlcode out 3qlcode_type 
insert_dr_ins DNAME in CHAR 25 
insert_dr_ins IMAME in CHAR 20 
insert_dr_in3 sqlcode out sqlcode_type 
insert_dr_hosp DNAME in CHAR 25 
insert_dr_hosp HNAME in CHAR 20 
insert_dr_hosp sqlcode out sqlcode_type 
delete_dr_in_dr DR_NAME in CHAR 25 
delete_dr_in_dr sqlcode out sqlcode_type 
delete_dr_in_ins DR_NAME in CHAR 25 
delete_dr_in_ins sqlcode out sqlcode_type 
delete_dr_in_hosp DR_NAME in CHAR 25 
delete_dr_in_hosp sqlcode out sqlcode_type 
coinniit_transaction sqlcode out sqlcode_type 
rollback_transaction sqlcode out sqlcode_type 
update_doctor DOC_NAME in CHAR 25 
update_doctor DOC_ADDRESS in CHAR 25 
update_doctor DOC_PHONE in CHAR 11 
update_doctor DOC_PHONE_indic in indicator_type 
update_doctor DOC_OFF_HRS in CHAR 20 
update_dootor DOC_OFF^HRS_indic in indicator_type 
update_doctor DOC_AREA in CHAR 5 
update_doctor DOC_AREA_indic in indicator_type 
update_doctor DOC_SPEC in CHAR 11 
update__doctor DOC__SPEC__indic in indicator_^type 
update_doctor DOC_BED__MAN in INT 
update_doctor DOC_BED__MAN_^indic in indicator_type 
update_doctor sqlcode out sqlcode_type 


Table D-16. Doctors_Intview2 • 2nd Interface Deflnition Procedure 


with base_specific_domains; 

use base_specific_dornains; 

with abstract_interface_ 9 enerator; 

with generator_support; use 9 enerator_support; 

procedure doctors_intview2 is 

type record_naines is (short_doctor_record); 

type proc_naines is {increnient_bedside_manner, open_dr_hosp, 

fetch_dr_hosp, close_dr_hosp, open_spec_area, 
fetch_spec_area, close_spec_area, 
op€n_doc_ins, fetch_doc_ins, close_doc_ins, 
open_area_ins, fetch_area_ins, close_area_ins, 
set_transaction); 

type ok_errors is (cursor_already_open, cursor_not_open, not_found, 

duplicate_value, fetch_not_done); 

package my_interface is new abstract__interface_generator 

("concrete_interfaceII", 
"abstract_interfacell". 


page 112 


6/19y90 





CDRL2020 


Coninct F19628-88-IMX)32/D002 
USER'S MANUAL AppcMibi D: Sample Programs 


LMSC-F376702 


"dbms_specificll", 

(1 -> doctors_def_enum_pkg, 

2 “> insurance_def_pkg, 

3 “> hospital_def_pkg ), 
record_naines , 
proc_naines , 
ok_errors, 

(1001, -501, 100, -803, -508)); 

use my_interface; 


begin 

declare 

type rec_con55onents is (dnaine, daddress, dphone) ; 
package rec4 is new record_generator (rec_con 5 >onents, 

short_doctor_record); 

package com_41 is new rec4.con^onent_generator 

(dnaine, dr_naine_not_null); 
package com_42 is new rec4.coniponent_generator 

(daddress, dr_address_not_null); 
package com_43 is new rec4.conponent_generator 

(dphone, phone_nuinber_type) ; 

begin 

rec4.generate_record; 
end; 


declare 

type params is (result); 
type parains_conc is (result); 

package procedure4 is new procedure_withjparaineters_generatot 
(procedure_naine ■> incr€anent_bedside_manner, 
parameters~*>> params, 

sql__stateinent__type -> update_positioned, 
sql_module_procedure_nanie -> 

" inc reinent_beds ide_manne r ", 
params_to_concrete_j5rocedure ■> parains_conc, 
valid_errors ■> (1 "> cursor_not_open, 

2 -> fetch_not_^done)) ; 

use procedure4; 

package paraml is new paraina_of_error_conditions_generator 

(result); 

begin 

procedure4.generate_procedure; 
end; 


declare 

type params is (hos_name, result); 
type params_conc is (hos_name, result); 
package procedure10 is new 

procedure_with_parameters_generator 

(procedure_name “> open_dr_hosp, 
parameters -> params, 
sql_statement_type -> open, 

sql_module_procedure_name -> "open_dr_hosp", 
params_to_concretejprocedure -> pareuns_conc, 
valid_errors -> (1 ■■> cursor_already_open) ) ; 
use procedurelO; 

package paraml is new params_of_domain_type_generator 

(hos_name, hosp_name_not_null); 


6/19/90 


page 113 




LMSC-F376702 Contiact F19628-88-D-0032/0002 CDRL2020 

USER’S MANUAL Appcadix D: Sample Programs 

package par 2 un 2 Is now parains_of_error__conditions_geneEator 

(result); 

begin 

procedurelO. generate_pEOcedure; 
end; 

declare 

type params is (short_doctor__rec, result); 

type parains_conc is (dnane, daddress, dphone, result); 

package procedure!! is new 

procedure_with_paranieters_generator 

(procedure_naiDe “> fetch_dr_hosp, 
parameters ~> params, 
sql_statement_type -> fetch, 
sql_module_procedure_name “> "fetch_dr_hosp", 
params_to_concrete_procedure -> params_conc, 
valid_errors ■> (1 ■> cursor_not_open, 

2 -> not_found)); 
use procedurell; 

package paraml is new params_of_record_type_generator 

(short_doctor_rec, shor 

t_doctor_record); 

package param2 is new params_o£_error_conditions_generator 

(result); 

begin 

procedurell .generate_procedure; 

end; 

declare 

package procedurel2 is new 

procedure_without_paraiiieters_generator 

(procedure_name “> close_dr_hosp, 
sql_stateinent_type “> close, 

sql_inodule_procedure_name •■> "close_dr_hosp") ; 

begin 

procedurel2.generate_procedure; 

end; 

declare 

package procedure13 is new 

procedure_without_parameters_generator 

(procedure_name “> set_transaction, 
sql_statement_type -> close, 

sql_inodule_procedure_name->"set_transaction"); 

begin 

procedurel3.generate_procedure; 

end; 

declare 

type params is (insurance_name, area_naroe, result); 
type params_conc is (insurance_name, area_name, result); 
package procedurel6 is new 

procedure_with_parameters_generator 

(procedure_name ■■> open_area_ins, 
par2UBeters -> params, 
sql_statement_type »•> open, 

sql_module_proceduEe_naiae ■> "open_area_ins", 
params_to_concrete_procedure -> params_conc. 


114 


6/19/90 





CDRL2020 


Contract F19628^-£M)032/0002 
USER’S MANUAL Appendix' D: Sample Programs 


LMSC-F376702 


valid_errora *> (1 -> cursor_already_op€n)); 

use procedurel€; 

package paraml is new parains_o£_domain_type_generator 
(insurance_naine, ins_nanie_not_null) ; 
package parain2 is new params_of_domain_type_generator 

(area_nanie, area_not_null) ; 

package paramS is new params_of_error_conditions_generator 

(result); 

begin 

procedurel6.generate_procedure; 

end; 

declare 

type params is (short_doctor_rec, result); 

type params_conc is (dname, daddress, dphone, result); 

package procedurel7 is new 

procedure_with_paraineters_generator 

(procedure_naxae -> fetch_area_in3, 
parameters ~> params, 
sql_statement_type -> fetch, 

sql_module_procedure_name -> "fetch_area_ins'', 
params_to_concrete_procedure -> pareuns_conc, 
valid_errors ■> (1 “> cui-sor_not_open, 

2 -> not_found)); 
use procedurel7; 

package paraml is new params_of_record_type_generator 
(ahort_doctor_rec,short_doctor_record); 
package param2 is new params_of_error_conditions_generator 

(result); ~ 

begin 

procedurel7.generate_procedure; 

end; 

declare 

package procedure18 is new 

procedure_without_parameters_generator 

(procedure_name -> close_area_in3, 
sql_statement_type ■> close, 
sql_module_procedure_name-> '’close_area_ins") ; 

begin 

procedurelS.generate_procedure; 

end; 

declare 

type params is (insurance_name, result); 
type params_conc is (insurance_name, result); 
package procedure21 is new 

procedure_with_parameters_generator 

(procedure_name -> open_doc_in3, 
parameters -•> params, 
sql_statement_type ■> open, 
sql_module_procedure_name -> "open_doc ins", 
params_to_concrete_procedure -> params_conc, 
valid_errors -> (1 -> cur3or_already_open)); 
use procedure21; 

package paraml is new parains_of_domain_type_generator 
(insurance_name, ins_name_not_null); 
package param2 is new params_of_error_conditions_generator 


6/19/90 


page 115 





LMSC-F376702 Conliact F19628-88rD-(X)32A)00i CDRL2020 

USER’S MANUAL Appendix D: Sample Programs 

(result); 

begin 

procedure21.generate_procedure; 

end; 

declare 

type params is (3hort_doctor_rec, result); 

type par 2 uns_conc is (dname, daddress, dphone, result); 

package procedure22 ia new 

procedure_with_paraineters_generator 

(procedure_naroe “> fetch_doc_ins, 
parameters -> pareuna, 
aql_atatenient_type -> fetch, 

aql_module_procedure_name *> "fetch_doc_ins", 
parama_to_concrete_procedure -> param3_conc, 
valid_errora —> (1 *> cursor_not_open, 

2 ■> not_found)); 
uae procedure22; 

package paraml ia new params_of_record_type_generator 
(ahort_doctor_rec, short_doctor_record); 
package param2 ia new paraitia_of_error_conditions_generator 

(result); 

begin 

procedure22.generate_procedure; 
end; 

declare 

package procedure23 is new 

procedure jwithoutjparametersjgenerator 

(pTOcedure_name ■> close_doc_ins, 
sql_stateinent_type «> close, 

sql_module_procedure_neune ■> ’’close_doc_ins") ; 

begin 

procedure23.generate_procedure; 

end; 

declare 

type pareuns is (specialty, area_naiDe, result) ; 
type parains_conc is (specialty^ area_name, resul^); 
package procedure24 ia new 

procedure_with_jparainetera_generator 

(procedure_name “> open_3pec_area, 
parametera -> parama, 
aql_atatenient_type *> open, 

aql_module_procedure_name -> "open_apec_area", 
parama_to_concrete_procedure -> parama_conc, 
valid_errora -> (1 ■> curaor_already_open)); 

uae procedure24; 

package paraml ia new params_of_domain_type_generator 

(apccialty, ai5ecialty_not_null) ; 
package parain2 ia new params_of_domain_type_generator 

(area_name, area_not_null) ; 

package param3 ia new params_of_error_conditions_generator 

(reault); 

begin 

ptocedure24.generate_procedure; 

end; 


page 116 


6/19/90 


CDRL2020 


Coatxact F19628-88-D-0032/00a2 
USER’S MANUAL Appeadir D: Sample Programs 


LMSC-F376702 


declare 

type parains is (short_doctor_rec, result) ; 

type params_conc is (dnaine, daddress, dphone, result); 

paclcage procedure25 is new 

procedure_with_paraineters_generator 

(procedure_naine “> fetch_spec_area, 
parameters «> parains, 
sql_statement_type -> fetch, 

sql inodule_procedure_naine*> "fetch_spec_area", 
params to_concrete_procedure ■> parains_conc, 
valid_errora “> (1 “> cursor_not_open, 

2 -> not_found)); 
use procedure25; 

package paraml is new parains_of_record_type_generator 
(ahort_doctor_rec, short_doctor_record); 
package parain2 is new params_of_error_conditions_generator 

(result); 

begin 

procedure25.generate_procedure; 

end; 

declare 

package procedure2€ is new 

procedure_without_parameters_generator 

(procedure_name “> close_spec_area, 
sql_statement_type ■> close, 

sql_module_procedure_naroe“>"close_spec_area") ; 

begin 

procedure2 6.generatejprocedure; 

end; 

my_interface.generate_interface; 
end doctors intview2; 


Table D-17. Abstract_Interfacen • 2nd Abstract Interface Package Speciflcation 


with DOCTORS_DEF_ENUM_PKG; 
use DOCTORS_DEF__ENUM_PKG; 
with INSURANCE_DEF_PKG; 
use INSURANCEJDEF_PKG; 
with HOSPITAl”dEF_PKG; 
use H0SPITAL_DEF_PKG; 
with sql_standard; 
use sql_standard; 

package abstract_interfacell is 

type valid_status_result_type is 

(C:URSOR_ALREADy_OPEN, CURSOR_NOT__OPEN, 
NOT_FOUND, DUPLICATE_VALUE, FETCH_NOT_DONE); 

type SHORT_DOCTOR_RECORD is record 
DNAME : DR_NAME_NOT_NULL; 

DADDRESS : DR_ADDRESS_NOT_NULL; 

DPHONE : PHONE_NUMBER_TYPE; 
end record; 


6/19/90 


page 117 




LMSC-F376702 Contract F19628-88 tD-0032AX)02 CDRL2020 

USER’S MANUAL Appendix D: Sample Programs 

procedure INCREMENT_BEDSIDE_MANNER 

(RESULT : out valid_status_result_type); 

procedure OPEN_DR_HOSP(HOS_NAME : in HOSP_NAME_NOT_NULL; 

RESULT : out valid_status_result_type); 

procedure FETCH_DR__HOSP 

(SHORT_DOCTOR_REC : in out SHORT_DOCTOR_RECORD; 

RESULT : out valid_3tatu3_result_type); 

procedure CLOSE_DR_HOSP; 

procedure SET_TRANSACTION; 

procedure OPEN_AREA_INS 

(INSURANCE_NAME : in INS_NAME_NOT_NULL; 

AREA_NAME : in AREA_NOT_NULL; 

RESULT : out valid_3tatU3_re3ult_type); 

procedure FETCH_AREA_INS 

{SHORT_DOCTOR_REC : in out SHORT_DOCTOR_RECORD; 

RESULT : out valid_3tatu3_re3ult_type); 

procedure CLOSE_AREA_INS; 

procedure OPEN_DOC_INS 

(INSURANCE_NAME : in INS_NAME_NOT_NULL; 

RESULT : out valid_3tatu3_re3ult_type); 

procedure FETCH_DOC_INS 

{SHORT~DOCTOR_REC : in out SHORT_DOCTOR_RECORr>; 

RESULT : out valid_3tatu3_re3ult_type); 

procedure CLOSE_DOC_^INS; 

procedure OPEN_SPEC_AREA(SPECIALTY : in SPECIALTY_NOT_NULL; 

^ AREA_NAME : in AREA_NOT_NULL; 

RESULT ; out valid_3tatu3_re3ult_type); 

procedure FETCH_SPEC_AREA 

(SHORT_DOCTOR_REC ; in out SHORT_DOCTOR_RECORD; 

RESULT : out valid_3tatu3_re3ult_type); 

procedure CLOSE_SPEC_AREA; 

end ab3tract interfacell; 


Table D>18. Abstract_Interfacen • 2nd Abstract Interface Package Body 

with 3ql_coininunications_pKg, sql_databa3e_error_p)cg, conversions, 
concrete_interfaceII; 

use sql_coinmunications_p)cg, sql_database_error_pkg, conversions; 

package body abstract_interfacell is 

use PHONE_NUMBER_OPS, 0FF1CE_H0URS_0PS, AREA_OPS, SPECIALTY_OPS, 

BEDSIDE MANNER OPS; 


page 118 


6/19/90 


CDRL2020 


Contract F19628-88-D-0032/0()02 

USER’S MANUAL Appendix' D: Sample Programs 


LMSC-F376702 


CURSOR_ALREADY_OPEN_VALUE : constant 1001; 

CURSOR_NOT_OPEN_VALUE : constant -501; 

NOT_FOUND_VALUE : constant 100; 

DUPLICATE_VALUE_VALUE : constant -803; 

FETCH_NOT_DONE_VALUE : constant -508; 

procedure INCREMENT_BEDSIDE_MANNER 

(RESULT : out valid_status_result_type) is 

begin 

concrete_interfaceII.increnient_bed3ide_inanner (SQLCODE) ; 
if sqlcode - CURSOR_NOT_OPEN_VALUE then 
RESULT CURSOR_NOT_OPEN; 

elsif sqlcode - FETCH_NOT_DONE_VALUE then 
RESULT FETCH_NOT_DONE; 

elsif sqlcode /- 0 then 
process_database_error; 
raise sql_database_error; 
end if; 

end INCREMENT_BEDSIDE_MANNER; 

procedure OPEN_DR_HOSP 

(HOS_NAME : in HOSP_NAME_NOT_NULL; 

RESULT : out valid_status_result_type) is 

begin 

concrete_interfaceII.open_dr_hosp ( CHAR(HOS_NAME), SQLCODE); 
if sqlcode - CURSOR_ALREADY_OPEN_VALUE then 
RESULT CURSOR_ALREADY_OPEN; 
elsif sqlcode /- 0 then 
process_database_error; 
raise sql__database_error; 
end if; 

end OPEN_DR_HOSP; 
procedure FETCH_DR_HOSP 

(SHORT_DOCTOR_REC : in out SHORT_DOCTOR_RECORD; 

RESULT : out valid_status result type) is 
DPHONE_c : CHAR{1.,11) (others -> ' '); “ 

DPHONE_indic : indicator_type; 
begin 

concrete_interfacell.fetch_dr_hosp 

(CHAR(SHORT_DOCTOR_REC.DNAME), 
CHAR(SHORT_DOCTOR_REC.DADDRESS), 

DPHONE_c, DPHONE_indic, SQLCODE); 

- if sqlcode - CURSOR_NOT_OPEN_VALUE then 
RESULT CURSOR_NOT_OPEN; 

elsif sqlcode - NOT_FOUND_VALUE then 
RESULT NOT_FOUND; 

elsif sqlcode /- 0 then 
process_database_error; 
raise sql_database_error; 
else 

assign(SHORT_DOCTOR_REC.DPHONE, 

PHONE_NUMBER_base(convert(DPHONE_c, DPHONE_indic))); 
end if; 

end FETCH_DR_HOSP; 
procedure CLOSE_DR_HOSP is 


6/19/90 


page 119 



LMSC-F376702 Contiaa F19628-88-D-0032AXX)2 

USER’S MANUAL AppcodhT D: Sample Programs 


begin 

concrete_interfaceII .cloae_dLr_ho5p (aqlcode) ; 
if aqlcode /- 0 then 

procea3_databaae_error; 
raiae aql_databaae_error; 
end if; 

end CIiOSE_DR_HOSP ; 

procedure SET_TRANSACTION ia 
begin 

concrete_interfaceII.aet_tranaaction (aqlcode); 
if aqlcode /• 0 then 

proceaa_databaae_error; 
raiae sql_databaae_error; 
end if; 

end SET_TRANSACTION; 

procedure OPEN_AREA_INS 

(INSURANCE_NAME : in INS_NAME_NOT_NULL; 
AREA_NAME : in AREA_NOT_NULL; 

RESULT : out valid_3tatus_re3ult_type) i3 

begin 

concrete_interfacelI.open_area_in3(CHAR{INSURANCE_NAME), 
CHAR(AREA_NOT_NULL'image(AREA_NAME)), SQLCODE); 
if aqlcode - CURSOR_ALREADY_OPEN VALUE then 
RESULT CURS0R_ALREADY_0 PEn 7 
elaif aqlcode /- 0 then 
proceaa_databaae_error; 
raiae aql_database_error; 
end if; 

end OPEN_AREA_INS; 

procedure FETCH_AREA_INS 

(SHORT_DOCTOR_REC : in out SH0RT_DCX:T0R_REC0RD; 

RESULT ; out valid_atatu3_result_type) ia 
DPHONE_c : CHAR(l..ll) (others -> ' ’); 

DPHONE_indic ; indicator_typ)e; 
begin 

concrete_interfacell.fetch_area_ins 

(CHAR(SHORT_DOCTOR_REC.DNAME), 
CHAR(SHORT_DOCTOR_REC.DADDRESS), 

DPHONE_c, DPHONE_indic, SQLCODE); 
if aqlcode - CURSOR_NOT_OPEN_VALUE then 
RESULT CURSOR_NOT_OPEN; 

elaif aqlcode - NOT_FOUND_VALUE then 
RESULT NOT_FOUND; 

elaif aqlcode /- 0 then 
process_databaae_error; 
raise sql_database_error; 
else 

assign(SHORT_DOCTOR_REC.DPHONE, 

PHONE_NUMBER_base(convert(DPHONE_c, DPHONE_indic))); 
end if; 

end FETCH_AREA_INS; 

procedure CLOSE_AREA_INS is 
begin 

concrete_interfaceII.close_area_in3 (aqlcode); 


CDRL2020 


page 120 


6/19/90 



CDRL2020 


Contract F19^-88-D-0032/0002 
USER’S MANUAL Appeadfat D: Sample Programs 


LMSC-F376702 


if sqlcode /- 0 then 

process_ciatabase_error; 
raise sql_database_error; 
end if; 

end CLOSE_AREA_INS; 

procedure OPEN_DOC_INS(INSURANCE_NAME : in INS_NAME_NOT_NULL; 

RESULT : out valid_status_result_type) is 

begin 

concrete_interfaceII.open_doc_ins(CHAR(INSURANCE_NAME),SQLCODE); 
if sqlcode - CURSOR_ALREADY_OPEN_VALUE then 
RESULT CURSOR_ALREADY_OPEN; 
elsif sqlcode /- 0 then 
process_database_error; 
raise sql_database_error; 
end if; 

end OPEN_DOC_INS; 

procedure FETCH_DOC_INS 

(SHORT_DOCTOR_REC : in out SHORT_DOCTOR_RECORD; 

RESULT : out valid_status_re3ult_type) is 
DPHONE_c : CHAR(l..ll) (others -> • '); 

DPHONE_indic : indicator_type; 

begin 

concrete_interfacell.fetch_doc_ins(CHAR{SHORT_DOCTOR_REC.DNAME), 

CHAK(SHORT_DOCTOR_REC.DADDRESS), 

DPHONE_C, DPHONE in^^c, SQLCODE); 
if sqlcode - CURSOR_NOT_OPEN_VALUt/ cnen 
RESULT CURSOR~NOT_OPEN; 

elsif sqlcode - NOT FOt:..D_VALUE then 
RESULT NOT_FOUND; 

elsif sqlcode /■• 0 then 
process_database_errcr; 
raise sql_database_error; 
else 

assign(SHORT_DOCTOR_REC.DPHONE, 

PHONE_NUMBER_base(convert(DPHONE_c, DPHONE_indic))); 
end if; 

end FETCH_DOC_INS; 

procedure CLOSE_DOC_INS is 

begin 

concrete_interfaceII.close_doc_ins (sqlcode); 
if sqlcode /- 0 then 

process_database_error; 
raise sql_database_error; 
end if; 

end CLOSE_DOC_INS; 

procedure OPEN_SPEC_AREA (SPECIALTY : in SPECI.\LTY_NOT_NULL; 

AREA_NAME : in AREA_NOT_NULL; 

RESULT : out valid_status_result_type) is 

begin 

concrete_interfacell.open_spec_area(CHAR(SPECIALTY), 

CHAR(AREA_NOT_NULL'image(AREA_NAME)), SQLCODE); 
if sqlcode - CURSOR_ALREADY_OPEN_VALUE then 
RESULT :* CURSOR_ALREADY_OPEN; 
elsif sqlcode /- 0 then 


6/19/90 


page 121 








LMSC-F376702 


Contract F19628-88-D-0032/0002 
USER’S MANUAL Appcadiz D: Sample Programs 


CDRL2020 


process_databaae_error; 
raise sql_ciatabase_error; 
end if; 

end OPEN_SPEC_AREA; 

procedure FETCH_SPEC_AREA 

(SH0RT_DCX:T0R_REC : in out SHORT_DOCTOR_RECORD; 

RESULT : out valid_status_result_type) is 
DPHONE_c : CHAR(1..11) (others -> ' '); 

DPHONE_indic : indicator_type; 
begin 

concrete_interfacell.fetch_spec_area 

(CHAR(SHORT_DOCTOR_REC.DNAME), 
CHAR{SHORT_DOCTOR_REC.DADDRESS), 

DPHONE_c, DPHONE_indic, SQLCODE); 
if sqlcode - CURSOR_NOT_OPEK_VALUE then 
RESULT CURSOR_NOT_OPEN; 

elsif sqlcode - NOT_FOUND_VALUE then 
RESULT NOT_FOUND; 

elsif sqlcode /- 0 then 
process_database_error; 
raise sql_database_error; 
else 

assign(SHORT_DOCTOR_REC.DPHONE 

PHONE_NUMBER_base(convert(DPHONE_c,DPHONE_indic))); 
end if; 

end FETCH_SPEC_AREA; 

procedure CLOSE_SPEC_AREA is 
begin 

concrete_interfacell.close__spec_^area (sqlcode); 
if sqlcode /■ 0 then ~ 

process_database_error; 
raise sql_database_error; 
end if; 

end CLOSE_SPEC_AREA; 
end abstract interface!!; 


Table D-19. Concrete_InterfaceII - 2nd Concrete Interface Package Specification 

with aql_standard; use sql_standard; 

package concrete_interface!! is 

procedure increnient_bedside_n\anner 

(sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, increinent_bedside_inanner) ; 

procedure open_dr_hosp(HOS_NAME : in CHAR; 

sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, open_dr_hosp); 

procedure fetch_dr_hosp(DNAME: in out CHAR; DADDRESS: in out CHAR; 

DPHONE: in out CHAR; 

DPHONE_indic:out sql_standard.indicator_type; 
sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, fetch_dr_hosp); 


page 122 


6/19/90 









CDRL2Q20 


Contact F19628-88-D-00"2/0002 
USER’S MANUAL AppcwUx D: Sample Programs 


LMSC-F376702 


procedure close_dr_hosp(sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sqlr close_dr_hosp); 

procedure set_transactIon(sqlcode : out sql_3tandard.sqlcode_type); 
pragma interface (sql, set_transaction); 

procedure open_area_ins(INSURANCE_NAME : in CHAR; 

AREA_NAME : in CHAR; 

sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, open_area_ins); 

procedure f etch_area_ins (DNAME : in out CHAR; 

DADDRESS: in out CHAR; 

DPHONE : in out CHAR; 

DPHONE_indic: out sql_standard.indicator_type; 
sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, fetch_area_ins); 

procedure close_area_ins(sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, close_area_ins); 

procedure open_doc_ins(INSURANCE_NAME : in CHAR; 

sqlcode : out 3ql_standard.sqlcode_type); 
pragma interface (sql, open_doc_in3); 

procedure fetch_doc_in3(DNAME: in out CHAR; 

DADDRESS: in out CHAR; 

DPHONE : in out CHAR; 

DPHONE_indic: out sql_standard.indicator_type; 
sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, fetch_doc_in5); 

procedure close_doc_ins(sqlcode : out sql_standard.sqlcode_type); 
pragma interface (sql, close_doc_ins); 

procedure open_spec_area (SPECIALTY : in CHAR; 

AREA_NAME : in CHAR; 

sqlcode : out 3ql_standard.sqlcode_type); 
pragma interface (sql, open_3pec_area); 

procedure fetch_spec_area (DNAME: in out CHAR; 

DADDRESS: in out CHAR; 

DPHONE : in out CHAR; 

DPHONE_indic: out sql_standard.indicator_type; 
sqlcode : out sql_3tandard.sqlcode_type); 
pragma interface (sql, fetch_3pec_area); 

procedure close_spec_area(sqlcode : out 3ql_standard.sqlcode_type); 
pragma interface (sql, close_3pec_area); 

end concrete interfacell; 


Table D-20. Dbiiis_Spedficn • 2nd Interface Description Text File 


increment_bedside_manner sqlcode out 3qlcode_type 
open_dr_hosp HOS_NAME in CHAR 20 


6/19/90 


page 123 



LMSC-F376702 Contiact F19628-88-D-0032/0002 C:DRL2020 

USER’S MANUAL Appendix D: Sample Programs 

open_dr_hosp sqlcode out sqlcode_type 
fetch_dr_hosp DNAME in_out CHAR 25 
fetch_dr_hosp DADDRESS in_out CHAR 25 
fetch_dr_hoap DPHONE in_out CHAR 11 
fetch_dr_hosp DPHONE_indic out indicator_type 
fetch_dr_hosp sqlcode out sqlcode_type 
close_dr_hosp sqlcode out sqlcode_type 
set_transaction sqlcode out sqlcode_type 
open_area_ins INSURANCE_NAME in CHAR 20 
open_area_ins AREA_NAME in CHAR 5 
open_area_ins sqlcode out sqlcode_type 
fetch_area_ins DNAME in_out CHAR 25 
fetch_area_ins DADDRESS in_out CHAR 25 
fetch_area_ins DPHONE in_out CHAR 11 
fetch_area_ins DPHONE_indic out indicator_type 
fetch_area_ins sqlcode out sqlcode_type 
close_area_ins sqlcode out sqlcode_type 
open_doc_ins INSURANCE_NAME in CHAR 20 
open_doc_ins sqlcode out sqlcode_type 
fetch_doc_ins DNAME in_out CHAR 25 
fetch_doc_ins DADDRESS in_out CHAR 25 
fetch_doc_ins DPHONE in_out CHAR 11 
fetch_doc_ins DPHONE_indic out indicator_type 
fetch_doc_ina sqlcode out sqlcode_type 
close_doc_ins sqlcode out sqlcode_type 
open_spec_area SPECIALTY in CHAR 11 
open_spec__area AREA_NAME in CHAR 5 
open_spec_area sqlcode out sqlcode_type 
fetch_spec_area DNAME in_out CHAR 25 
fetch_spec_area DADDRESS in_out CHAR 25 
fetch_spec_area DPHONE in_out CHAR 11 
£etch_spec__area DPHONE_indic out indicator_type 
fetch_spec_area sqlcode out sqlcode_type 
close_spec_area sqlcode out sqlcode_type 


Table D<21. Doctor_Appiication • Ada Application 


with DOCTORS_DEF_ENUM_PKG; 
use DOCTORS_DEF_ENUM_PKG; 
with INSURANCE_DEF_PKG; 
use INSURANCE_DEF_PKG; 
with HOSPITAL_DEF_PKG; 
use HOSPITAL_DEF_PKG; 
with abstract_interface_enum; 
use abstract_interface_enum; 
with abstract_interfaceii; 
use abstract_inter£aceii; 
with text_io; 
uae text^io; 
with string_pack; 
use string_pack; 

procedure doctor_application is 
choice : integer 0; 

package int_io is new text_io.integer_io(integer); use int_io; 

package real_io is new float^io(float); use real_io; 

package enum_io is new enumeration_io(area_not_null); use enuin_io; 


page 124 


6/19/90 




CDRL2020 


Contract F19628-88-D-0032A)002 
USER’S MANUAL Appendix D: Sample Programs 


LMSC-F376702 


ins_rec : abstract_interface_enum.insurance_record; 
doc_rec : abstract_interface_enum.doctor_record; 
hosp_rec : abstract_interface_enum.hospital_record; 
doc_ins_rec : abstract_interface_enum.dr_ins_record; 
doc_hosp_rec : abstract_interface_enuni.dr_hosp_record; 
short_doc_rec : short_doctor_record; 

doctor_naine : dr_name_not_null; 
doctor_addreas : dr_addre3a_not_null; 
doctor_phone : phone_nuinber_type; 
doctor_houra : office_houra_type; 
doctor_apecialty : apecialty_type; 
doctor_area : area_type; 
doctor_manner : bedaide_inanner_type; 
the_area : area_not_null; 

bedaide_manner : bedaide_manner_not_null; 

hoapital_naine : hoap_naine_not_null; 

inaurance_nanie : ina_naine_not_null; 

apecialty_name : apecialty_not_null; 

atring_holder : atring (1..100) (othera -> ' ’); 

laat : natural; 

done : boolean falae; 

anawer ; atring (l.,l) (othera -> * '); 
traah : atring (1..1) :* (othera «> * *); 

worked ; abatract_interface_eniani.valid_atatu3_result_type; 
workedii : ab3tract_interfaceii.valid_3tatu3_re3ult_type; 

begin 

s«t_t ransaction; 

text_io.put_line("WELCOME TO THE DOCTOR DATABASE"); 

text_io.put_line("What operation would you like to perform?"); 

text_io.put_line("Enter appropriate number"); 

text_io.put_line(" "); 

text_io.put_line(" "); 

while choice /■ 14 loop 

text_io.put_line("1 “> Add new inaurance company."); 
text_io.put_line("2 -> Add new hoapital."); 
text_io.put_line("3 •> Add new doctor."); 
text_io.put_line("4 ■> Delete doctor from databaae."); 
text_io.put_line("5 -> Commit thia aeaaion."); 
text_io.put_line("6 <•> Rollback thia aeaaion."); 
text_io.put_line("7 -> Update doctor information."); 
text_io.put_line("8 ■> Increment bedaide manner."); 
text_io.put_line("9 -> View doctor information."); 
text_io.put_line("10 "> View doctors from certain hospital."); 
text_io.put_line 

("11 ■> View doctors honoring certain insurance."); 
text_io.put_line 

("12 ->View doctors in an area with certain specialty."); 
text_io.put_line 

("13“>View doctors in an area honoring certain insurance."); 
text_io.put_line("14 •■> End this session,"); 
int_io.get(choice); 
text_io.get_line(trash, last); 
case choice is 
when 1 «> 


6/19/90 


page 125 



LMSC-F376702 


Contiaa F19628-88'I>^32/0002 
USER’S MANUAL Appcodiz D: Sample Programs 


CDRL2020 


text_io.put("Input insurance con^any name -> "); 

string_holder :■ (others *■> * *); 

text_io.get_line(string_holder, last); 

move(strip(string_holder), string(ins_rec.iname)); 

text_io.put_line("Input deductible ■> "); 

real_io.get(float(lns_rec.ided)); 

text_io.put_line("Input office visit copayment -> "); 
real_io.get(float(ina_rec.iov_co)); 

text_io.put_line("Input perscription copayment »> "); 
real_io.get(float(ina_rec.idr_co)); 
lnsert^in8uxance(lns_xec, worked); 

when 2 “> 

text_io.put_line("Input hospital name “> "); 

string_holder (others -> ' *); 

text_io.get_line(string_holder, last); 

move(strip(string_holder ), string(hosp_rec.hname)); 

text_io.put_line("Input hospital address ■> "); 

string_holder (others ■> ’ '); 

text_io.get_line(string_holder/ last); 

move(strip(string_holder ), string(hosp_rec.haddress)); 

lnaext_hoap(ho8p_xec, worked); 

when 3 ■> 

text_io.put_line("Input doctor's name(NO NULL ALLOWED) *> "); 

string__holder (others -> ' ’); 

text_io.get_line(string_holder/ last); 

move (strip (string__holder ), string(doc_rec .dname) ) ; 

move (strip (string__holder), string (doc~ins_rec .dneune)) ; 

move(strip(string_holder), string(doc_hosp_rec.dneune)); 

text^io.put_line 

("Input doctor's address (NO NULL ALLOWED) -> "); 
string_holder (others “> * '); 

text_io.get_line(string_holder, last); 
move(strip(string_holder), string(doc_rec.daddress)); 
text_io.put_line 

("Input doctor's phone number <RET> for NULL ••> "); 
string_holder :■ (others ■> ' '); 
text_io.get_line(string_holder, last); 
if last > 0 then 

assign(doc_rec.dphone, null_sql_char); 
else 

assign(doc_rec.dphone, to_sql_char(strip(3tring_holder))); 
end if; 

text_io.put_line 

("Input doctors office hours <RET> for NULL “> "); 
string_holder (others -> ' '); 

text_io.get_line(string_holder, last); 
if last - 0 then 

assign(doc_rec.doff_hrs, null_sql_char); 
else 

assign(doc_rec.doff_hrs,to_sql_char(strip(3tring_holder))); 
end if; 

text_io.put_line 

("Input doctors area of practice <RET> for NULL -> "); 
string_holder (others ■> ’ ’); 

text_io.get_line(string_holder, last); 
if last “0 — they want a null value then 


page 126 


6/19/90 






CDRL2020 


CoiitiaaFl%28-88-IW)032/0002 LMSC-F376702 

USER’S MANUAL Appendix'D: Sample Programs 

assign (doc_rec .darea, null_^sql_enuineration) ; 
else 

enuni_io.get (string_holder, the_area, last) ; 
assign{doc_rec.darea, with__null (the_area)) ; 
end if; 

text_io.put_line 

("Input doctor's specialty <RET> for NULL -> "); 
string_holder (others -> ' '); 

text_io.get_line(string_holder, last); 
if last * 0 then 

assign(doc_rec.dspec, null_sql_char); 
else 

assign(doc_rec.dspec, to_sql_char(strip(string_holder))); 
end if; 

text_io.put_line 

("Input doctor's bedside manner rating <RET> for NULL -> "); 
string_holder (others -> ’ '); 

text_io.get_line(3tring_holder, last); 
if last " 0 then — they want a null bedside manner 
bedside_inanner_ops .assign 

(doc_rec.d]Ded_man, null_sql_int) ; 

else 

int_io.get(string_holder, integer(bedside_manner), last); 

bedside_manner_^ops.assign(doc_rec.dbed_man, 
bedside_manner__ops. with_null (bedside_manner) ) ; 

end if; 

insext_dx (doc^xec, worked); 
while not done loop 
text_io.put_line 

("Input doctor's hospital(NO NULL ALLOWED) -> "); 
string_holder (others -> ’ '); 
text_io.get_line(string_holder, last); 
move(strip(string_holder), string(doc_hosp_rec.hname)); 
lnsext_dr_hosp (doc_hosp_xec, worked); 

text_io.put_line("More hospitals? .. answer y or n -> "); 
text_io.get_line(answer, last); 
if answer - "y" then 

text_io.get_line(trash, last); 
else 

done :■ true; 
end if; 
end loop; 
done false; 

text_io.get_line(trash, last); 
while not done loop 
text_io.put_line 

("Input doctor's insurance (NO NULL ALLOWED) -> "); 
atring_holder (others -> ' '); 
text_io.get_line(string_holder, last); 
move(strip(string_holder), string(doc_ins_rec.iname)); 

lnsert_dr_ins (doc__laa_rec, worked); 

text_io.put_line("More insurance? .. answer y or n »> "); 

^.ext_io.get_line (answer, last); 
if answer - "y" then 

text_io.get_line(trash, last); 
else 

done :■ true; 
end if; 


6/19/90 


page 127 



LMSC-F376702 


Coouaa F19628-8&-D-0032A)002 
USER’S MANUAL AppcMitx D: Sample Programs 


CDRL2020 


end loop; 
when 4 «> 

text_io.put_line("Input doctor's name -> "); 
string_holder (others ■•> ' *); 
text_io.get_line(string_holder, last); 
move(strip(string_holder), string(doctor_name)); 
delete_dr_ln_dr (doctor_naae, worked); 
delete_dr3[la__ln8 (doctor_naa)e, worked); 
delete_dr~ln_hosp (doctorjnaam, worked) ; 

when 5 ■> 

caomit_tran8actlon; 

8et_transaction; 

when 6 ■> 

rolIback_t ranaactIon; 
aet_tranaactlon; 

when 1 -> 

text_io.put_line("Input doctor's name -> ") ; 
atring_holder :■ (others ■> ' '); 
text_io,get_line(string_holder, last); 
move(strip(string_holder), string(doctor_name)); 
open_(lr_row(doctor_nama, worked); 

£etch_doctor(doc__reC/ worked); 
text_io.put_line("Current address -> " 4 

string_pack.strip(string(doc_rec.daddress))); 
text_io,put_line("Kew address ■> <RET> if s^une"); 
string__holder :■ (others ■> ' '); 
text_io.get_line(string_holder, last); 
if last - 0 then 

doctor_address doc_rec.daddress; 
else 

move(strip(string_holder), string(doctor_address)); 
end if; 

if is_null(doc_rec.dphone) then 

text_io.put_line("Current phone number is NULL"); 
else 

text_io.put_line("Current phone number -> " s 
strip(to_string(doc_recdphone))); 

end if; 

text_io.put_line 

("New phone ■> <RET> if same, NULL for null value"); 
string_holder :« (others ■> ' '); 
text_io.get_line(string_holder, last); 
if last - 0 then 

assign(doctor_phone, doc_rec.dphone); 
elsif strip (string_holder) ■■ "NULL" then 
assign(doctor_phone, null_sql_char); 
else 

assign(doctor_phone, to_sql_char(strip(string_holder))); 
end if; 

if is_null(doc_rec.doff_hrs) then 

text_io.put_line("Current office hours are NULL"); 
else 

text_io.put_line ("Current office hours ■•> " s 

strip(to_string(doc_rec.doff_hrs))); 


page 128 


6/19/90 



CDRL2020 


Contnct F19628-88-D-0032/0002 
USER’S MANUAL AppeadU: D: Sample Programs 


LMSC-F376702 




end 1£; 

text_io.put_line 

("New hours -> <RET> if same, NULL for null value"); 
string_holder (others ■> * *); 
text_io.get_line(string_holder, last); 

If last ~ 0 then 

assign(doctor_hours, doc_rec.doff_hrs); 
elsif strip (string_holder) "NULL" then 
assign(doctor_hours, null_sql_char); 
else 

assign(doctor_hours, to_sql_char(strip(string_holder))); 
end if; 

if is_null(doc_rec.darea) then 

text_io.put_line("Current area is NULL"); 
else 

text_io.put_line("Current area -> " fi 
area_not_null* image(without_null(doc_rec.darea))); 
end if; 

text_io.put_line 

("New area -> <RET> if same, NULL for null value"); 
atring_holder (others -> ' '); 
text_io.get_line(string_holder, last); 
if last - 0 — then they want to )ceep this value 
assign(doctor_area, doc_rec.darea); 
elsif strip(string_holder) “ "NULL" then 

assign(doctor_area, null_sql_enumeration); 
else 

enum_io.get(string_holder, the_area, last); 
assign(doctor_area, withjnull(the_area)); 
end if; . 

if is^null(doc_rec.dspec) then 

text^io.put_line("Current specialty is NULL"); 
else 

text_io.put_line("Current specialty -> " 4 

atrip(to_string(doc_rec.dspec))); 

end if; 

text_io.put_line 

("New specialty -> <RET> if same, NULL for null value"); 
string_holder :•» (others -> * ’); 
text_io.get_line(string_holder, last); 
if last 0 then 

assign(doctor_specialty, doc_rec.dspec); 
elsif strip(string_holder) - "NULL" then 
assign(doctor_specialty, null_sql_char); 
else 

assign(doctor_specialty, 

to_sql_char(strip(string_holder))); 

end if; 

if is_null (doc_rec.dbed_inan) then 

text_io.put_line("Current bedside manner is NULL"); 
else 

text_io.put_line("Current bedside manner rating -> " & 
integer'image(integer(without_null_base(doc_rec.dbed_man)))); 
end if; 

text_io.put_line 

("New rating -> <RET> if same, NULL for null value"); 
atring_holder (others -> * '); 
text_io.get_line(string_holder, last); 


6/19/90 


page 129 



LMSC-F376702 


Contract F19628-88'D-0032/0002 
USER'S MANUAL Appcwitz D: S^ple Programs 


CDRL2020 


ix last - 0 then — they want to keep this value 
bedslde_inanner_ops. assign 

(doctorjmanner, doc_rec.dbed_man); 
elsif strip(string_holder) “ "NULL" then 
bedside_nianner_ops. assign 

{doctor_njanner, null_sql_int) ; 

else 

int_io.get 

(strip(string_holder), integer(bedside_manner), last); 
bedside_manner_ops.assign 

(doctor_inanner, 

bedside_manner_ops. with_null (bedsidejnianner) ) ; 

end if; 

t 9 date_doctor(docbor_naae, doctor_addres8, 

doctor_phon«, doctor_hours,doctor_ar«a, 
doebor__8p*ci.alty, doctor_aranner, 
worked); 

cl 08 «__dr__r ow ; 
when 8 -> 

text_io.put_line("Input doctor's name ■> "); 
string_holder :■ (others ■> ' '); 
text_io.get_line(string_holder, last); 
move(strip(string_holder ), string(doctor_name)); 
op«n_dr_row(doctor_ttaae, worked); 

£etcE_jdoctor (doc^^ree, worJced) ; 
lncre8Mnt^bedslde_aanner (workedil); 
clo8e_dr_row; 

when 9 -> 

text_io.put_line("Input doctor's name -> "); 
string__holder :■ (others ■> ' '); 
text_io.get_line(string_holder, last); 
move(strip(string_holder), string{doctor_name)); 
open__dr__row(doctor_naae, worked); 

£otcb_doctor(doc_rec, worked); 
text_io .put_line ("Current address ■•> " 

String_pack.strip(String(doc_rec.daddress))); 
if is_null(doc_rec.dphone) then 

text_io.put_line("Current phone number is NULL"); 
else 

text_io.put_line("Current phone number -> " & 
strip(to_string(doc_rec.dphone))); 

end if; 

if is_null(doc_rec.doff_hrs) then 
text_io.put_line 

("Current office hours are NULL"); 

else 

text_io.put_line("Current office hours -> " s 

strip(to_string(doc_rec.doff_hrs))); 

end if; 

if is_null(doc_rec.darea) then 

text_io.put_line("Current area is NULL"); 
else 

text_io.put_line("Current area ■> " fi 
area_not_null'image(without_null(doc_rec.darea))); 
end if; 

if is_i;ull (doc_rec.dspec) then 


page 130 


6/19/90 




CDRL2020 


Contna F19628-88-EWX)32/0002 
USER’S MANUAL Appendix'D: Sample Programs 


LMSC-F376702 


text_io.put_line("Current specialty is NULL"); 
else 

text_io.put_line{"Current specialty *> " 4 

strip(to_string(doc_rec.dspec))); 

end if; 

if is_null<doc_rec.dbed_man) then 

text_io.put_line("Current bedside manner is NULL"); 
else 

text_io.put_line("Current bedside manner rating -> " 4 
integer'image(integer(without_null_base(doc_rec.dbed_man)))); 
end if; 
clo8e_dr_row; 

when 10 —> 

text_io.put_line("Input hospital name *> "); 

3 tring_holder (others ■> * *); 

text_io.get_line(string_holder, last); 

move(strip(string_holder), string(hospital_name)); 

op«n_dx_hosp(ho8pital_nama, workedii); 

text_io.put_line ("Doctors with privileges at " 4 

string_holder(1..last)); 

text_io.put_line (" "); 
fetcb_drJho8p(8hort_doc__xec, woxkedli); 
while (worked!' /- not_found) loop 

if is_r-l■{short_doc_rec.dphone) then 
texc iO.put^line 

' •.ring_pack.strip(atring(short_doc_rec.dname)) 

a " " 4 

string_pack.Strip(string(short_doc_rec.daddress)) 

4 " NULL PHONE NUMBER"); 
else text_io.put_line 

(string;_pack. strip (string (short_doc_rec .dname)) 

4 « " « 

String_pack.strip(string(short_doc_rec.daddress)) 

4 " " 4 strip(to_string(short_doc_rec.dphone))); 
end if; 

fetch_drJho8p(short_doc__xec, workedii); 
end loop; 
clo8e_dr_ho8p; 

when 11 “> 

text_io.put_line("Input insurance name -> "); 
string_holder (others -> ' '); 
text_io.get_line(string_holder, last); 
move(strip(string_holder), string(insurance_name)); 
op«n_doc_ins (Insurancejoaom, workedll) ; 
text_io.put_line ("Doctors honoring " 4 

string_holder(1..last) 4 " insurance"); 
text_io.put_line (" "); 
f«tch_doc_ins(8hort__doc_x«c, workedll); 
while (workedii /■ not_found) loop 

if is_null(short_doc_rec.dphone) then 
text_io.put_line 

(string_pack.strip(string(short_doc_rec.dname)) 

4 " " 4 

St ring_pack.strip(string(short_doc_rec.daddress)) 

4 " NULL PHONE NUMBER"); 

else 


6/19/90 


page 131 




LMSC-F376702 Contract F19628-88-D-0032/0002 

USER’S MANUAL AppcwUx^ D: Sample Programs 

text_io.put_line 

(string_pack.strip(string(short_doc_rec.dname)) 

& " " & 

string_pack.strip(string(short_doc_rec.daddres3)) 
& " " & 

strip(to_string(short_doc_rec.dphone))); 
end if; 

f«tch_doc__ln8 (shoxt_doc_x«Cr workedii) ; 
end loop; 
cl 08 e__doc_ln 8 ; 

when 12 -> 

text_io.put_line("Input specialty -> "); 
string_holder (others -> • '); 
text_io.get_line(string_holder, last); 
move(strip(string_holder ), string(specialty_name)); 
text_io.put_line("Input area -> "); 
string_holder :■ (others -> • '); 
text_io.get_line(string_holder, last); 
enum_io.get(string_holder, the^area, last); 
op«n__spec_axea(sp«clalty_naBm, the_area, workedii); 
fetch_apec_area(ahort_doc_xec, workedii); 
while (workedii /■ not_found) loop 

if is_null(short_doc_rec.dphone) then 
text_io.put_line 

(String_pack.strip(string(short_doc_rec.dname)) 

t " " 4 

string_pack,strip(string(short_doc_rec.daddress)) 
4 " NULL PHONE NUMBER"); 

else 

text_io.put_line 

(string_pack.strip(string(short doc rec.dname)) 

4 " * 4 - - 

st ring_pack.strip(string(short_doc_rec.daddress)) 

4 " " 4 

strip(to_string(short_doc_rec.dphone))); 
end if; 

fetch__spec__area(short_doc_r«c, workedii); 
end loop; 
close__spec__area; 

when 13 “> 

text_io.put_line("Input area "); 
string_holder (others -> • •); 

text_io.get_line(string_holder, last); 
enum_io.get (string_holder, the__area, last); 
text_io.put_line("Input insurance name »> "); 
string_holder (others ■> ' '); 

text_io.get_line(string_holder, last); 
move(strip(string_holder), string(insurance_neune)); 
open_area_ins (insurancejaaam, the_area, workedii) ; 
£etch__area_^ins (short_doc__rec, workedii) ; 
while (workedii /- not_found) loop 

if is_null(short_doc_rec.dphone) then 
text_io.put_line 

(St ring_pack.strip(string(short_doc_rec.dname)) 

4 " " 4 

string_pack.strip(string(short_doc_rec.daddress)) 


CDRL^O 


page 132 


6/19/90 




CDRL2020 


Contract F19628-88-D-0032/0003 
USER’S MANUAL Appendix D: Sample Programs 


LMSC-F376702 


& " NULL PHONE NUMBER"); 

else 

text_io.put_line 

(string_pack.strip(string(short_doc_rec.dname)) 

4 " " & 

String_pack.strip(string(short_doc_rec.daddress)) 

& " " & 

strip(to_atring(ahort_doc_rec.dphone))); 
end if; 

£«tch_area__ln8 (short_doc_r*c, worlcedll) ; 
end loop; 
clo8e_area_ina; 

when 14 ->null; 

when others “> null; 
end case; 

end loop; — (while choice /“ 14) 
end doctor_application; 


6/19/90 


page 133 






CDRL2020 Contract F19628-88-D-0032/0002 LMSC-F376702 

USER'S MANUAL 

APPENDIX E 
REFERENCES 

[1] M. H. Graham. 1989. Guidelines for the Use of the SAME. SEI Technical Report 
CMU/SEI-89-TR-16 and ESD-TR-89-24. Pittsburgh, PA: Software Engineering Institute, 
Carnegie Mellon University. 

[2] American National Standards Institute. 1986. Database Language—SQL. X3.135-1986. 

[3] Digital Equipment Corporation. 1988. VaxRdblVMS R^erence Manual.Uz.yndird,MA: 
Digital Equipment Corporation. 

[4] Digital Equipment Corporation. 1988. Developing Ada Programs on VaxJVMS. Maynard, 
MA: Digital Equipment Corporation. 


6/19/90 


page 135 




