T 


W\ 

AD-A259 002 

AFn-ZGCE/ENCWD-U IHilMliPRIi 


AN INTELLIGENT REAL-TIME SYSTEM 
ARCHITECTURE IMPLEMENTED IN ADA 

THESIS 


DTIC 



Michael Anthony Whelan 
Captain, USAF 

AFIT/GCE/ENG/92D-12 



93-00145 

iiiiinin 


Approved for public release; distribution unlimited 


93 1 


4 127 





AFrr/GCE/ENG/92D-12 


AN INTELLIGENT REAL-TIME 
SYSTEM ARCHlTECrURE IMPLEMENTED IN ADA 


THESIS 








^Sp. 




Presented to the Faculty of the Sdiool of Engineering 


of the Air Force Institute of Technology 


Air University 
In Partial Fulfillment of the 
Requirements for the Degree of 
MastCT of Science in Computer Engineering 


Michael Anthony Whelan, A.A.S., B.S£JE. 
Captain, USAF 


Accesion For 


NTIS 

CRA&I 

k 

DTIC 

TAB 


Unannounced 

□ 

Justification 


By 

Distribution/ 


Availability Codes 

A 5 

CO 

• 

Avail and/or 1 

Spe 

cial 


December, 1992 


Approved for public release; distribution tnilimited 






Preface 


The research conducted here was motivated by my experiences as a project engineer for the Pilot’s 
Associate program. During the develoiunent phases of the program, most of the effort focused on 
developing the knowledge bases necessary to build a Pilot’s Associate with little attention paid to die 
environment in which such a system would eventuaUy be deployed. I decided to address the issues of real¬ 
time and Ada in this thesis to help smooth future efforts to transition “intelligent systems” into real-time 
enviroiments. I believe the experience and knowledge gained while I pursued that goal to be invaluable. 

I am indebted to a number of faculty at AFTT for die knowledge I gained while attending there. First 
is my thesis advisor. Major Gregg Gunsch, who taught me the meaning of the word “scope”. He also 
provided valuable feedback that allowed this document to at least be readable. Second is Dr. Gary Lamont 
whose algorithms class taught me more about “cMiqiuter science” than all other computer classes 
combined. Major Eric Christensen assisted me in solving some tricky Ada problems I had given up on as 
un-solvable. In addition, all my fellow students provided die valuable moral support that allowed me to 
continue “pressing on”. 

My most heart felt thanks is rested for my family. First for my wife, Mary, who ran the household 


without me and suffered through quite a few “do nothing” weekends. Second are my children, Shaun and 
Shaunna, who now have a daddy back. Without their understanding and love, I could never have 
completed this research. 


Michael Anthony Whelan 





Table of Contents 


Page 

Preface.ii 

Table of Contents.iii 

List of Figures.vii 

List of Tables.x 

Abstract.xi 

I. bitroduction.1-1 

1.1. Background.1-1 

1.2. Problem Statement.1-3 

1.3. Assumptions.1-4 

1.4. Scope.1-4 

1.5. Approach.1-4 

1.6. Summary.1-5 

1.7. Thesis Overview.1-6 

n. Background.2-1 

2.1. Traditional Real-Time Systems.2-1 

2.2. Scheduling hnprecise Computations.2-4 

2.3. bitelligent Real-Time Systems.2-7 

2.3.1. Pilot's Associate Progran.2-7 

2.3.2. Lockheed's Pilot's Associate.2-8 

2.3.3. McDonnell Aircraft's Pilot's Associate.2-10 

2.3.4. Adaptive Suspension Vehicle.2-14 

2.4. Common Intelligent Real-Time System Components.2-18 

2.5. Schedulable Task Types.2-19 

2.6. Summary.2-20 

iii 




























in. E)esign Approaches, Assumptions, and Key Decisions.3-1 

3.1. Perfomiance Measures.3-1 

3.2. Design Considerations.3-2 

3.3. Design Assumptions.3-3 

3.4. Possible Design Approaches.3-5 

3.4.1. Modifying CLIPS/Ada Design Approach.3-5 

3.4.2. Controllable Real-Time Task Manager Approach.3-8 

3.5. Design Problem Statement.3-9 

3.6. Key Design Decisions.3-9 

3.7. Design Approach Summary.3-10 

rV. An hitelligent Real-Time System Architecture.4-1 

4.1. Top Level Design.4-1 

4.2. Environment Model.4-2 

4.3. System Model.4-3 

4.4. I/O Process.4-4 

4.5. Reasoning Process.4-4 

4.6. Task Manager.4-5 

4.6.1. Periodic Task Scheduling.4-6 

4.6.2. Non-Poiodic Task Scheduling.4-10 

4.7. Architecture Summary.4-13 

V. Feasibility Demonstration System.5-1 

5.1. General Inqilementation Issues.5-1 

5.1.1. Ada Compile Qioice.5-2 

5.1.2. Memory Management ksues and hnpacts.5-2 

5.1.3. Dynamic Task Creatirni and Control.5-3 

5.1.4. Top Level Priority Assignments.5-6 

5.2. System and Environment Model.5-8 

5.3. I/O Process.5-8 

5.4. Reasoning Process bnplementation.5-8 

5.5. Task Manager hnplementation Details.5-11 

5.5.1. Task Manager Data Structures.5-11 

5.5.2. Task States and State Transitions.5-13 

5.5.2.1. Periodic Task State Transitions.5-14 

5.5.2.2. Non-Periodic Task State Transitions.5-15 

5.5.3. Periodic Task Priority Assignments.5-18 

5.5.4. Task Manager Entry Call Descriptions.5-18 

5.5.4.I. Add_Task Entry CaU.5-19 

iv 








































5.5.4.2. Modify_Task Entry CaU.5-20 

5.5.4.3. RenK)ve_Task Entry Call.5-23 

5.5.4.4. Change_Periodic_Utilization Entry Call.5-24 

5.5.4.5. Task_Conq)lete Entry Call.5-24 

5.5.4.6. Task Dispatcher.5-25 

5.6. h):q)lementation Summary.5-26 

VL Results and Analysis.6-1 

6.1. Architecture Feasibility.6-1 

6.2. Dynamic Task Creation and Control.6-3 

6.2.1. Dynamic Task Creation Results.6-5 

6.3. Task Scheduling Evaluation.6-5 

6.4. Code Complexity Analysis.6-7 

6.5. Results Summary.6-10 

Vn. Conclusion.7-1 

7.1. Summary.7-1 

7.2. Recmnmendations.7-2 

7.2.1. Task Manager Recommendations.7-3 

7.2.2. Other Architecture Components Recommendations.7-3 

7.2.3. Implementation and Development Recommendations.7-5 

7.3. Thesis Summary.7-5 

A^iendixA. Test Results.A-1 

A. 1. Scheduling Overhead Timing Results.A-1 

A. 2. Schedules Produced.A-10 

Appendix B. Periodic Priority Assignment Methods Investigated.B-1 

B. 1. Periodic Priority Assignment Problem and Potential Solution Methods.B-1 

B.1.1. Periodic Priorities Normal Distribution Method.B-2 

B. 1.2. Periodic Priorities Linear Method.B-3 

B. 1.3. Periodic Priorities Static Method.B-4 

B. 2. Evaluatirxi of Priority Assignment Methods.B-5 

Aj^ndix C. IRTS Demonstration System User’s Guide.C-1 

C. 1 System Requirements and Conpilation Order.C-1 

C.2 Source Code.C-4 


V 






































Bibliogra{^y.BIB-1 

Vita.VITA-1 


VI 





List of Figures 


Figure Page 

Figure 2.1 Overall Concept of the Pilot's Associate.2-9 

Figure 2.2. Reasoning Process Diagram.2-12 

Figure 2.3 Me Air’s Top Level Architecture.2-13 

Figure 2.4 Me Air's Module Internal Architecture.2-14 

Figure 2.5 ASV Planning and Confrol Architecture [Payton, 1991:55].2-16 

Figure 2.6 ASV Plan Generation [Payton, 1991:551.2-17 

Figure 3.1 CLIPS Rule Defmition Stmctuie [CLIPSRefMan, 1991a:27].3-6 

Figure 3.2 Modifled CLIPS Rule Stmeture.3-7 

Figure 4.1 Top Level Design Diagram.4-2 

Figure 4.2 Some Calculable Periodic Utilizations.4-9 

Figme 4.3 Predicting Non-Periodic Task Actual Durations.4-12 

Figure 5.1 Package Structure of Tasks.5^ 

Figure 5.2 Normal and Importance Ordered Priority Ranges.5-7 

Figure 5.3 IRTS Ada Task Stmeture EKagram.5-10 

Figure 5.4 Task Control Block Ada Record Type Declaration.5-13 

Figure 5.5 Periodic Task State Transition Diagram.5-15 

Figure 5.6 Nrai-Periodic Task State Transition Diagram.5-16 

Figure 6.1 Example Periodic Task Manager Overhead versus Task Duration.6-2 

Figure 6.2 Example Non-Periodic Task Manager Overhead versus Task DuraticHi.6-2 

Figure 6.3 Summary of Periodic Task Control Times.6-4 

Figure 6.4 Summary of Non-Periodic Task Control Times.6-4 


vii 

























Figure 6.5 Example of Execution Priority Inversion.6-8 

Figure A.1 Periodic Tasks Add Time, New Task Instantiated.A-2 

Figure A.2 Periodic Tasks Add Time, Task Shell Reused.A-3 

Figure A.3 Periodic Tasks Modify Time, Period and hnpoitance Changed.A-4 

Figure A.4 Periodic Tasks Remove Time.A-5 

Figure A.5 Non-Periodic Tasks Add Time, New Task Instantiated.A-6 

Figure A.6 Non-Periodic Tasks Add Time, Task Shell Reused.A-7 

Figure A.7 Non-Periodic Tasks Modify Time, E)eadline and Importance Changed.A-8 

Figure A.8 Non-Periodic Tasks Remove Time.A-9 

Figure B. 1 Example Periods of a Task Set.B-2 

Figure B.2 Periodic Priorities Using Normal Distrilnition.B-3 

Figure B.3 Periodic Priorities Using Linear Method.B-4 

Figure B.4 Periodic Priorities Using Static Method.B-5 

Figure B.5 Period vs. Priority, Static Mefliod, All Optional.B-8 

Figure B.6 Tasks per Priority, Static Mctliod, All Optional.B-8 

Figure B.7 Period vs. Priority, Static Method, Some Mandatory.B-9 

Figure B.8 Tasks per Priority, Static Method, Some Mandatory.3-9 

Figure B.9 Period vs. Priority, Linear Method, AU Optional.B-10 

Figure B.IO Tasks per Priority, Linear Method, All Optional.B-10 

Figure B. 11 Period vs. Priority, Linear Method, Some Mandatory.B-11 

Figure B. 12 Tasks per Priority, Linear Method, Some Mandatory.B-11 

Figure B.13 Period vs. Priority, Normal Distribution Method, All Optional.B-12 

Figure B.14 Tasks per Priority, Nonnal Distribution Method, All Optional.B-12 

Figure B.15 Period vs. Priority, Normal Distribution Method, Some Mandatory.B-13 

Figure B.16 Tasks per Priority, Normal Distribution Method, Some Mandatory.B-13 

Figure B.17 Paiod vs. Priority, New Method, All Optional.B-14 


vui 





























Figure B. 18 Tasks per Priority, New Method, All Opdcmal.B-14 

Figure B. 19 Period vs. Priority, New Method, Some Mandatory.B-15 

Figure B.20 Tasks per Priority, New Method, Some Mandatory.B-15 

Figure C. 1 Recommended Directory Structure for IRTS Demonstration System.C-1 


IX 









List of Tables 


Table Page 

Table 4.1. Example Periodic Task Set.4-7 

Table 5.1 Effects of Modifying Tasks and Periodic Utilization.5-21 

Table 5.2 Allowed Modify Operations by Task Type and State.5-22 

Table 6.1 Time Complexity of Procedures Used By the Task Manager.6-9 

Table 6.2 Time Complexity of Task Manager Entry Calls.6-9 

Table A.1 Printout Status Number to State Name Translation.A-13 


X 










AFrr/GCE/ENG/92D- 


Abstract 

This research begins the process of transitioning real-time intelligent laboratory demonstration 
programs into the congressionally mandated implementation language Ada. The investigation objective is 
to analyze the characteristics of real-time intelligent systems and then to design and implement an software 
architecture capable of supporting die identified characteristics. By beginning to address the specific needs 
of real-time intelligent systems as implemented in Ada, the path from laboratory demonstration to fielded 
system is further illuminated. 

Conventional real-time systems are fully deterministic allowing for off-line, optimal, task scheduling 
under all circumstances. Real-time intelligent systems add non-deterministic task execution times and non- 
deterministic task sets for scheduling purposes. Non-detenninistic task sets force intelligent real-time 
systems to trade-off execution time with solution quality during mn-time and perfonn dynamic task 
scheduling. Four basic design considerations addressing those tradeoffs have been identified; control 
reasoning, focus of attention, parallelism, and algorithm efficacy. 

Non-real-time intelligent systems contain an environment sensor, a model of the environment, a 
reasoning process, and a large collection of procedural processes. Real-time intelUgent systems add to 
these a model of the real-time system's behavior, and a real-time task scheduler. In addition, the reasoning 
process is augmented with a metaplanner to reason about timing issues using the system's behavioral 
model. Additionally, real-time deadlines force the inclusion of pluralistic solution methods in the 
intelligent system to allow multiple responses ranging from reactive to fully reasoned and calculated. 


XI 





AN INTELLIGENT REAL-TIME 
SYSTEM ARCHITECrURE IMPLEMENTED IN ADA 


/. Introduction 


I feel compelled to point out the obvious; a demonstration of some capability (in 
AI or other technology) on one restricted instance of a general class of problems is 
important as an existence proof of a technology, but it does not satisfy the general need 
for a technology that will be able to produce solutions for all unrestrict^ problems in that 
class. It is in this sense that I believe that AI will require much basic and engineering 
research from DoD and other sources for many years to come. Given the utility derived 
from the relatively modest level of today's technology, I believe that even incremental 
gains here will prove of phenomenal value to DoD and the economy in general. 
[Simpson, 1988:1] 

Sec. 8092. Notwithstanding any other provisions of law, after June 1, 1991, 
where cost effective, all Department of Defense software shall be written in the 
programming language Ada, in the absence of special exemption by an official 
designated by the S^etary of Defense [Public Law 101-511]. 


If you believe the first quotation, then clearly, DoD use of Artificial Intelligence (AI) techniques 
requires a method to create and field AI systems in Ada. Additionally, the relatively new AI field of Real- 
Time Intelligent Systems is subject to the same congressionally mandated use of the Ada programming 
language. Thus Real-Time Intelligent Systems research must begin to focus some attention on 
implementation issues associated with Ada. The research conducted here attempts to do just that: 
investigate some implementation issues associated with intelligent real-time systems in Ada. By 
integrating three broad areas of DoD relevant research; artificial intelligence, real-time systems, and Ada, 
this research incrementally advances the field of AI and assists the DoD in complying with the 
congressionally mandated use of the Ada programming language. 

1.1. Background 

To understand the directicxi this thesis investigation is taking, it is necessary to examine a number of 
areas of computer science. These areas include expert systems, blackboard systems, associate systems, and 
real-time systems. The first requirement, however, is a simple definition of what is meant by the term 


1-1 






'intelligent real-time systems'. For the purposes of this thesis, an intelligent real-time system (IRTS) is 
defined as a computer control system which can perform some initially specified function and which can 

1) zAapX. its control strategy based upon changes in its operating environment, 

2) trade off the quality of a solution against the computational time required to calculate a solution 
in order to adapt to changes in its operating environment, and 

3) guarantee the response times of some set of tasks. 

Expert systems are one class of intelligent systems. An expert system tries to perform a given task in 
a method that is comparable to a human expert. Typically an expert system consists of explicitly 
represented domain knowledge (in the form of a knowledge base) and an inference engine [Klahr, 1986:28; 
CLIPS-Ada, 1991] [CLIPSRefMan, 1991]. The knowledge base consists of English-like rules of the form: 
If A and B then C. The inference engine (sometimes called a monitor) arranges the rules for execution and 
executes them. The knowledge base and inference engine are separate and distinct entities. By adding or 
deleting knowledge (rules) in the knowledge base, the expert system's level of expertise can be altered. 
(Thanging the knowledge base altogether results in an expert in another domain. 

Blackboard systems were developed to allow for multiple cooperating expert systems [Nii, 1989:13- 
82]. The analogy generally used to describe its operation is a group of experts standing around a 
blackboard trying to solve a multi-disciplinary problem. Information is placed on the blackboard and each 
expert responds by providing partial solutions from their particular field of expertise. Eventually, the group 
may solve the problem that no single expert could. 

A blackboard system consists of a global database and a collection of knowledge sources (KS) that 
act upon the data in the global database. Each of the KS's contributes to the problem solving process by 
identifying goals, contributing partial solutions, or evaluating partial solutions. Eventually, as each of the 
KS's responds to changes in the blackboard data, a satisfactory solution is reached. The two types of 
knowledge sources are domain and control. Domain KS's operate on a specific problem and control KS's 
help in deciding which domain KS's are appropriate to execute. 

Associate Systems are an area in A1 that have received significant DoD attention and funding. 
Associate Systems help operators of planes, helicopters, tanks, and submarines cope with the avalanche of 


1-2 



data available to them and make effective decisions to accomplish their mission [Aldem, 1990] [Lambert, 
1990], One of the most heavily funded systems in this category is the DARPA/USAF Pilot's Associate. 
(Others include Day/Night Adverse Weather Pilotage System, Submarine Operator’s Associate System, 
Rotocraft Pilot's Associate, and a Special Operations Forces spin-off effort from the Pilot's Associate 
program). To date, each of these systems has used a collection of rule-based approaches and blackboard 
systems. Each program has also developed a methodology to acquire the appropriate domain knowledge 
and represent that knowledge in a form the system implementor can use [Aldem, 1991:4-1 to 4-20]. All of 
these systems so far are proof-of-concept systems. One key concern is the requirement to operate in “real¬ 
time”. Although research is moving in this direction [Aldem, 1991] [Lambert, 1990] [Dodhiawala, 1988] 
[Payton, 1991], none currently guarantee operation in real-time and none are implemented in Ada. 

Real-time systems usually mean fast systems that operate on temporally valid data. Both the term 
fast and real-time are problem specific and precise definitions are only relevant for the specified domain. 
For example, a real-time system used to monitor continental drift may only be required to take and record 
measurement samples once a month. On the other end of the spectrum, a space shuttle flight control system 
may require that hundreds of sensors be checked in milliseconds. The point is that real-time systems must 
operate fast enough for the particular application. Generally, this requirement is stated by saying that the 
system’s response must be calculated by the required deadline, with httle said about how to determine what 
is the deadline. Thus a intelligent real-time system must exhibit ^propriate behavior fast enough in the 
chosen domain. 

1.2. Problem Statement 

Due to funding limitations and program constraints, the concept of dynamically controlling the real¬ 
time performance of an intelligent system was never fully developed in the Pilot’s Associate program. 
Additionally, both contracted development teams used implementation languages other than Ada. Thus, to 
date no large intelligent real-time system has been developed and implemented in Ada, and no analysis of 
such a system performed. This thesis effort proposes to investigate issues in the development of such a 
system and analyze some of the performance issues raised. By providing a potenflal design solution, a 
feasibility demonstration, and some analysis of its performance, this thesis can have a direct impact on 
future real-time, embedded, intelligent DoD systems. 


1-3 






1.3. Assumptions 

This thesis investigation assumes a basic system functional description as outlined in the Pilot's 
Associate program [Lambert, 1991] [Lambert, 1990] [Aldem, 1990] [Aldem, 1991], Thus it is assumed 
that there exists a large collection of known procedures or tasks that are required to perform a given 
function. In addition, the relationship between these tasks and their impact on the current problems facing 
the system can be determined. This mapping of functions and relationships to the current context in which 
the system is operating is referred to as a plan/goal graph or task network [Wilensky, 1983] [Smith, 1990]. 
It is not the goal of this thesis effort to design from scratch an intelligent real-time system. Rather, this 
thesis effort investigates the mapping of previous designs to Ada, the addition of components necessary to 
overcome deficiencies in the previous designs, and the issues arising out of that mapping and addition of 
components. 

No effort is made to acquire the knowledge necessary to add 'intelligence' to the system. Instead, a 
baseline system similar to the Pilot's Associate is assumed. The goal of this system is not the development 
of the knowledge base for such a system, rather it is the mapping of the designed system to Ada and to 
investigate the control of such a system. The application of the architecture resulting from this work to a 
specific domain is left as future work. 

1.4. Scope 

This research proposes to examine intelligent real-time systems but is limited primarily to 
knowledge based systems acting as the intelligent agents in the system. It is not the intent of this research 
to examine the real-time issues associated with other AI software disciplines, nor are hardware issues 
addressed. Thus, no effort is being made to consider machine learning, neural networks, genetic 
algorithms, or any of the other AI disciplines. Similarly, no effort is made to examine hardware 
architectures, chip designs, or memory systems. It is fully expected that areas requiring performance 
improvements will be encountered and that these other AI areas and hardware may provide solutions to 
those problem areas. It is left as future research to incorporate those AI technologies and hardware into the 
framework this thesis is proposing. 

IJ. Approach 

The ^proach used in this thesis effort is typical of most research efforts. First, a literature review of 
real-time and intelligent real-time systems is conducted. The purpose of the review is to educate myself 



and the reader about the issues affecting both traditional real-time systems and intelligent real-time systems. 
Additionally, the literature review exposes problems with current systems and examines some potentially 
useful methods of dealing with those problems. Specifically, scheduling real-time tasks using the rate 
monotonic scheduling theory and methods of scheduling imprecise computations. 

From that review, conclusions are drawn about what constitutes an intelligent real-time system. 
Once the constituent parts are identified, an architecture is presented that incorporates each of those parts. 
The component most lacking in current intelligent real-time systems is identified and methods of including 
it into an intelligent real-time system architecture is examined. 

Next, a feasibility demonstration system is constructed that investigates incorporating a dynamic 
real-time task manager into an intelligent real-time system. The feasibility demonstration is constructed to 
allow for validation of the concepts developed in this thesis and provide insight into potential problem 
areas. It is not offered as an optimal solution tuned for maximum performance. 

Next, an analysis of the implemented system’s performance is made. Specifically, an analysis of the 
dynamic task creation and control strategies is made and the impact of each parameter on system 
performance identified and quantified in terms of execution speed, code size, and appropriateness for the 
context. Additionally, performance problems are traced to either a flaw in the implementation or perhaps a 
more serious flaw in the design. 

Finally, an attempt to point the direction of future wwk in this area is made. Drawing on the results 
of the efforts of this thesis, a suggested path of ccmtinuing research and development is laid out. 

1.6. Summary 

This research has four objectives. Listed in order of importance, they are 

1) development of an integrated set of Ada data and control structures that allows for the 
implementation of an intelligent real-time system and architecture to support such a system, 

2) implementation of the developed data and control structures into an intelligent real-time system 
and a feasibility demonstration of the developed architecture, 

3) an evaluation of the implemented intelligent system architecture to determine the utiUty of the 
design and the overhead necessary to support its run-time computational needs, and 


1-5 



4) identification and evaluation of some performance metrics useful in evaluating intelligent real¬ 
time systems performance. 

1.7. Thesis Overview 

This thesis follows the pattern used by most scientific research reports. In Chapter 2, the results of a 
literature search are presented. Current knowledge in AI systems, real-time systms, and intelligent control 
is examined and issues important to this thesis are identified. Additionally, the common components of 
intelligent real-time systems are listed. Chapter 3 addresses some of the possible design approaches for 
developing an intelligent real-time system and enumerates the design assumptions. The key design 
decisions made are discussed. Chapter 4 presents the intelligent real-time system architecture vision 
developed and addresses some of the features that are missing in previous architectures. Chapter S provides 
a detailed look at the developed feasibility demonstration system. The goal of the feasibility demonstraticm 
is to provide confidence in the potential of the architecture presented in Chapter 4 and allow for concept 
testing. Chapter 6 presents the results obtained by testing the feasibility demonstration system and the 
impact of those results on the proposed intelligent real-time system architecture. Chapter 7 culminates the 
thesis with conclusions and recommendations. 


1-6 




11. Background 


The technology needed to build an intelligent real-time system spans a multitude of engineering 
disciplines. Those that are relevant to this thesis include traditional real-time system design, real-time 
scheduling algorithms, real-time system design in Ada, knowledge representation, expert systems, associate 
systems, blackboard systems, planning, and intelligent control. In order to lay the foundation for 
understanding the work presented in this thesis, it is necessary to examine some of the more important 
aspects of these related technologies. The following background information covers traditional real-time 
systems rate monotonic scheduling, then imprecise computation scheduling, followed by intelligent real¬ 
time systems, and culminating with a description of the components needed to implement intelligent real¬ 
time systems. 

2 .1. Traditional Real-Time Systems 

Sprunt, Sha, and Lehoczky provide a good introduction to real-time system design issues and 
algorithms [Sprunt, 1989] [Sprunt, 1990]. They classify tasks based upon the task’s deadline and arriv(U 
pattern. Classifications for deadlines are hard and soft. Hard-deadline tasks are defined as "If meeting a 
given task's deadline is critical to the system's operation, then the task’s deadline is considered to be hard" 
[Sprunt, 1990:2]. Soft-deadline tasks are tasks whose deadline is desirable but not absolutely essential for 
correct system operation. Additionally, Sprunt and Sha add the category background task for those tasks 
without a timing constraint 

Classifications for task arrival rates include periodic and aperiodic. A periodic task is defined by 
Sprrmt and Sha as a task that arrives at regular, predictable times. Sprunt and Sha include things like seaisor 
updates or monitoring tasks in this category. Aperiodic tasks are defined to be tasks with irregular arrival 
times and result from "the processing requirements of events with nondeterministic request patterns, such 
as operator requests" [Sprunt, 1990:2]. Using deadlines and arrival patterns, they essentially divide the 
types of real-time tasks into four categories: hard-deadline periodic tasks, soft-deadline aperiodic tasks, 
sporadic tasks, and background tasks. Sprunt and Sha define each task type as follows: 

• Hard-Deadline Periodic Task. A periodic task consists of a sequence of requests 
arriving at regular intervals. A periodic task’s deadline coincides with the end of its 
poiod. 


2-1 






• Soft-Deadline Aperiodic Task. An aperiodic task consists of a stream of requests 
arriving at irregular intervals. Soft deadline ^)eriodic tasks typically require a fast 
average response time. 

• Sporadic Tasks. A sporadic task is an aperiodic task with a hard deadline and a 
minimum inter-arrival time (the amount of time between two requests). 

• Background Tasks. A background task has no timing requirements and no particular 
aihv^ pattern. Background tasks are typically assign^ the lowest priority in the 
system... [Sprunt, 19W;2] 


Systems with hard-deadline periodic tasks can be constructed efficiently using the rate-monotonic 
scheduling algorithm [Sha, 1991] [Sha, 1989] [Sprunt, 1989] [Liu, 1973]. This algorithm "assigns 
priorities to tasks as a monotonic function of the rate of a (periodic) function" and assumes a priority 
driven, preemptive scheduling discipline [Sha, 1991:3]. The rate-monotonic algorithm is the provably 
optimal scheduling algorithm for preemptive scheduling of hard-deadline periodic tasks [Sprunt, 1990:2]. 
The rate monotonic theory provides a simple inequality to determine whether a given set of periodic tasks is 
schedulable. Theorem 1 below provides a sufficiency test that ensures all tasks meet their deadlines. For 
task sets whose utilization, U(n}, exceeds that of (2.1), Theorem 2 below is both a necessary and sufficient 
test. 

Theorem 1: A set of « independent periodic tasks scheduled by the rate monotonic 
algorithm will always meet its deadlines, for all task phasings, if 


... + 1=- ^ /i(2>"" - 1) - U{n) 


( 2 . 1 ) 


where Ci and Tj are the execution times and period of task Zi respectively and U(n) is 
the utilization of the task set [Sha, 1989:5]. 

Theorem 2: A set of n independent periodic tasks scheduled by the rate-monotonic 
algorithm will always meet its deadlines, for all task phasings, if and only if 


V/, l<i<n. 


nun 

(W)€ 


Tc — 
R: ^ ' /r* 



< 1 


( 2 . 2 ) 


where Ci and Ti are the execution times and period of task T/ respectively and 

Ri = {(1. 0 I 1 ^ k ^ i, I = 1.Lr,- /rjtJ J. i represents the task to be checked, k 

represents the tasks of equal or higher priority, and / represents the scheduling points for 
task i [Sha, 1989:5]. 


In Theorem 1, for large values of n,U(n) converges to 0.69 {In 2). Assuming the worst case scenario where 
all tasks are started simultaneously. Theorem 2 checks if each task can complete its execution by its first 


2-2 





deadlines at each scheduling point before task /’s deadline. A scheduling point for a task t is the deadline 
of each task with a deadline befcare t’s. 


In addition to using a priority driven, preemptive scheduling discipline. Theorems 1 and 2 also 
assume, process switching is instantaneous, the tasks account for all the execution (i.e. the qjerating system 
consumes zero time), the tasks do not interact, tasks become ready to execute exactly at the beginning of 
their periods and, task deadlines are always at the end of the period. Continuing research is addressing 
some of the limitations associated with the assumptions used to develop Theorem 1 and Theorem 2 [Sha, 
1991] [Klein, 1990]. First, the effect of non-zero task switching times is addressed by modifying the 
execution time of a task, C/ to include context switching times, C^. In Theorems 1 and 2, the new task 
execution time beccanes C’/ = C/ + 2Cj since the processing context is switched at the beginning and end of 
each task’s execution. 


Task synchronization was addressed by the development of the priority ceiling protocol. “The 
priority ceiling protocol has two important properties, 1) freedom from mutual deadlock and 2) bounded 
priority inversion, which means at most (me lower {aiority task can blcmk a higher priority task during eacdi 
task peritxl” [Sha, 1991:6]. Inclusion of the priority ceiling protixml allowed the formulation of the two 
additional theorems: 

Theorem 3: A set of n periodic tasks using the pricmty ceiling protocol can be scheduled 
by the rate monotonic algorithm, for all task phasings, if the following condition is 
satisfied [Sha, 1989:15]. 



T. 


max 


y,’ 


B. 


‘ /l-l / 


^ n{2" -1) 


(2.3) 


Theorem 4: A set of n periodic tasks using the priority ceiling probmol can be scheduled 
by the rate monotoiuc algorithm, for all task phasings, if and only if the following 
condition is satisfied: 


Vr, I ^ ^ n, nun 
{kj)^ Ri 


1 

IT, 

\ 

C B 


k 

+ —+ —i- 


rr, rr,) 


5 1 


(2.4) 


where C/, T/, and /?/ are defined in Theorem 2, and Bi is the worst-case blcmking time for 
task i [Sha, 1989:15], 


Theorems 3 and 4 provide generalized forms of Theorems 1 and 2 that handle blcmking due resource 
sharing or task synchronization. To handle soft-deadline apericxlic tasks the Deferrable Servo- and Priority 
Exchange algorithms can be used [Sprunt, 1989:11], Both of these approaches create a high priority 


2-3 


periodic task (called a server) for servicing ^riodic tasks. The goal of each algorithm is to preserve the 
resource bandwidth allocated to aperiodic tasks; allowing inunediate executirm of the aperiodic task when it 
arrives. In the case of the Deferrable Server, during each server period, the aperiodic task's time is held for 
the entire period and replenished at the end of the server's period. Thus when an aperiodic task arrives, it is 
serviced immediately if time remains in the aperiodic task's time budget 

The Priority Exchange algorithm, as the name implies, exchanges its priority with lower priority 
periodic tasks whenever there are no aperiodic tasks ready for execution. At the end of the server's period, 
the aperiodic tasks priority is again raised to the highest level. Again, since the ^riodic task always has 
the highest priority, the Priority Exchange algorithm ensures that aperiodic tasks are handled immediately 
when they arrive if time remains in the aperiodic task's time budget. The difference between the two 
algorithms lies in their complexity and schedulability bounds as discussed by Sprunt, Sha. and Lehoczky 
[Sprunt, 1989:6-10]. 

The point of this discussion is that mathematicaUy precise methods exist for real-time system design 
of systems composed of static priority, hard-deadline, periodic, sporadic, and/or aperiodic tasks. The 
importance of rate-monotonic scheduling theory for use in intelligent real-time systems lies in its feasibility 
test and corresponding priority assignment. The feasibility of a periodic task set can be quickly calculated 
and the result acted upon. Additionally, the scheduling problem associated with assigning priorities is 
significantly reduced if not eliminated. 

2 . 2 . Scheduling Imprecise Computations 

The preceding discussion dealt with methods to determine the feasibility of a task schedule and 
schedule fairly well defined tasks to achieve real-time perframance. There exists another class of tasks that 
vary in processing times and so carmot be handled easily by the preceding methods. The imprecise 
computation technique can be used to help schedule tasks that fall into this category [Liu, 1991]. It allows 
tradeoffs between result quality and computation time. This quality/time trade-off helps prevent timing 
faults and assists in achieving graceful degradation. 

Liu, Lin, Shih and Yu explain that their basic strategy revolves around the division of ail time critical 
tasks into two subtasks: a mandatory subtask that provides an adequate result and an optional subtask that 
provides a refined result [Liu, 1991:58]. If the optional subtask is scheduled and executes to completion. 


24 



then the result is said to be precise. If the optional task is terminated before it completes, and the 
mandatcvy task has been completed, then the result is said to be imprecise. 

Three methods and the associated costs of each method for creating mandatory and ofkional subtasks 
are discussed by them [Liu, 1991:59]. The first method is the milestone method and takes ^vantage of 
monotone tasks. A monotone task is one whose result quality does not decrease as the task executes. If the 
results of the task's execution and error indicators are recorded at appropriate instances, then the task's 
result grows more precise as it is allotted more time to execute. The user can then decide, based upon the 
error indications and result, when to terminate the task. The cost of the milestone method is the storing of 
the intermediate results. 

The second method described by them is referred to as a sieve function [Liu, 1991:59], In this 
method, computation steps (and therefore result quality) are traded off for processing time. The example 
given to illuminate how this method is employed involves using a previous cycle's noise level estimate 
when examining this cycle's radar returns. The cost for sieve functions is higher scheduler overhead. Liu, 
Lin, Shih and Yu classify this type of scheduling problem as a Oil constraint problem [Connen, 1990:335]. 
Since no benefit is gained unless the entire sieve function completes before its deadline, it should either be 
scheduled to execute to completion or not scheduled at all. 

The third method they describe is the multiple version method [Liu, 1991:59]. As the name implies, 
each task has two versions; a primary version and an alternate version. The primary version has a longer 
execution time, but produces a precise result. The alternate version produces a less precise result in a 
shorter time. The cost of the multiple version method includes both storage space for the multiple versions 
and higher scheduler oveihead. Again, Liu, Lin, Shih and Yu classify the multiple versirai method as a 0/1 
constraint problem for the same reasons cited above. In this case, scheduling the primary version is 
considered to be the same as scheduling both the mandatory subtask and the optional subtask. Scheduling 
the alternate version corresponds to scheduling only the mandatory subtask. 

Liu, Lin, Shih and Yu then go on to develop a basic workload model for all imprecise computation 
methods they described [Liu, 1991:59-60]. Given a set of preemptable tasks, 

T=\Ti.T2 . Tn) 


2-5 






the tasks T/ in the set can be described by the following parameters: 


• r’i Ready time at which time 7/ becomes ready for execution 

• d'i Deadline by which Ti must be completed 

•t/ Processing time required to execute 7/ to completion 

• wj Weight that measures the relative impcntance of Ti 

• Mi Mandatory subtask of Ti 

• Oi Optional subtask of Ti 

• mi Processing time required to execute A// to completion 

• Oi Processing time required to execute Oi to completion 

Note that in the preceding defmitions, mi + oi = tj. Additionally, the deadlines of the subtasks Mi 
and Oi are the same as the deadline for 7/. The ready time for the Mi subtask is the same as Ti but the Oi 
does not become ready until after the mandatory subtask completes. 

A valid schedule of 7 is defined as one that "assigns the processor to at most one task at any time, 
and every task is scheduled after its ready time. Moreover, the total length of the intervals in which the 

processor is assigned to Ti .is at least equal to and at most equal to Tj." [Liu. 1991:591. 

Additionally, a valid schedule is termed feasible if every task is completed by its deadline. Schedulable 
task sets have at least one feasible schedule. 

One final parameter used by Liu, Lin, Shih and Yu is the error parameter, e,’. This parameter is used 
to calculate a value for processing the optional subta^. The error parameter is calculated by the equation 
e/. = Eiioi - o/). Here, o/ is the amount of processor time allotted to Oi, and £/ is assumed to be a 
monotone non-inCTeasing function of Oj. 

OiKe the imprecise computation scheduling problem is defined in these terms, it becomes a matter of 
rqiplying an approfniate algorithm to obtain a particular scheduling goal. Scheduling goals can be designed 
to minimize die total error, average error, the number of discarded optional tasks, the number of tardy tasks, 
or the average response time [Coffman, 1976] [Liu, 1991]. It becomes the job of the system designer ot the 
run-time controller to determine the rqipropriate scheduling goal at any particular instant during the 
system's operation. 


2-6 




2.3. Intelligent Real-Time Systems 


As vague as it may sound, real-time in an intelligent system seems to mean "fast enough". 
Traditionally, as discussed above, a real-time system's performance is dictated by hard limits imposed on the 
amount of time a task has to execute. These limits are normally pre-defmed by the process that is being 
controlled and the speed of the equipment used to control that process. For example, in a flight control 
system the real-time requirements of the digital computer are dictated by the speed of the control mechanisms 
which move the control surfaces, the speed with which the instnunents monitoring the aircraft attitude can 
detect changes resulting from control surface movements, and the time that the laws of aerodynamics 
establish a response must be made. In an intelligent real-time system, real-time performance is context 
dependent The response time required of an autonomous aircraft from the detection of a threat depends upon 
how quickly a response is required to ensure a successful outcome. The system obviously must respond 
much faster to an inbound missile targeted at the ownship than it does to a threat aircraft which is beyond the 
lethal radius of any weapons it can carry. 

The key point of this type of variable response timeline is that it places the additional burden upon 
the system of being able to determine the time constraints at any particular instant. A run-time, 
dynamically adaptable control structure appears to be required [Payton, 1991] [Lambert, 1990] [Lizza, 
1989] [Stankovic, 1988]. The system must be able to respond to rapidly changing requirements and still 
produce valuable output. Two DoD funded programs, Klot's Associate and Adaptive Suspension Vehicle, 
have been addressing these issues. The programs, as they relate to intelligent real-time systems, are 
examined below. 

2.3.1. Pilot's Associate Program. Basically, the Pilot's Associate program is developing an 
electronic back-seater to assist tomorrow's single-seat fighter pilot cope with the ever increasing amounts of 
information presented to him [Whelan, 1990] [Banks, 1991] [Aldem, 1990] [l^ambert, 1990] [Aldem, 
1991]. The Pilot's Associate is developing a system to help the pilot identify the crucial information from 
the background noise. It is the system which makes the aircraft understand the pilot's objectives, 
preferences, and restrictions, and works in the tireless fashion of the computer in complying with them. 

Figure 2.1 shows the overall concept of a Pilot's Associate. The system consists of six functional 
elements: Situation Assessment (SA), Mission Planner (MP), Tactics Planner (TP), Pilot-Vehicle Interface 
(PVI), System Status (SS), and the System Executive (SE). SA is responsible for assessing the world 


2-7 




external to the aircraft MP is responsible for global planning from take-off to landing. TP is responsible 
for responding to immediate threats. PVI ensures the system provides what the pilot wants, when he needs 
it. SS is responsible for assessing the world internal to the aircraft. And Tmaliy, S£ is responsible for 
ensuring that all elements are solving not only the same problem but also the right problem. In the 
following discussions, the term system refers to the entire collection of functions that make up the Pilot's 
Associate. A sub-system or module is one particular functional element (e.g. Tactics Planner, Pilot Vehicle 
Interface). A machine is a computer that pieces of the functional elements are implemented upoi,. (Note 
that originally, the system was developed with each module to resicfe upon a different machine. However, 
as the system developed over time, it became apparent that different pieces of the modules needed to 
closely work together. This fwced a migration of module pieces together based primarily upon data usage). 

2.3.2. Lockheed's Pilot’s Associate The current Lockheed version of the Pilot's Associate is 
probably the furthest along in trying to implement a fairly complex intelligent real-time system [Aldem, 
1991J. Essentially, the approach is to code the system in C++ and then to statically distribute the set of 
coded tasks across as many processors as necessary to achieve real-time performance. The process is based 
upon the premise that processing power will be available (or can be added) to operate the.se systems in real¬ 
time and thus no separate executive for controlling execution exists. This approach has some potential 
problems. 

First, the domain chosen for these systems, by their very nature, is dynamic. It is widely held that 
predictability in any combat situation will lead to higher risk of death or failure. Thus systems that operate 
in a combat situation, or any competitive situation, face continually changing environments as one system 
tries to overcome or defeat another. Any system designed for a competitive environment must be able to 
change quickly as new knowledge is obtained. In the current Lockheed Pilot's Associate, since the 
knowledge acquired is translated directly into an implementation language (C++), changes potentially 
require significant work to locate the piece of code to change, determine how to change it. code the 
changes, and tune the system performance to again ensure real-time constraints can be meet [Aldem. 
1991:4-6 to 4-20). Essentially, the performance goals of the program have eliminated what was the 
knowledge base as a separate entity and distributed the knowledge throughout the system. Given the syntax 
of the Ada language, this same Icnowledge coding’ approach may be neces-sary for any DoD system. 


2-8 



ENHANCED 

^TUATIONAL 

AWAHENESS 



Figure 2.1 Overall Concept of the Pilot’s Associate 

Additionally, the computational times for a large percentage of AI approaches are generally non- 
deterministic (i.e., the search space is so large that an exhaustive search is impossible, thus some sort of 
guiding heuristics are used to get a solution that satisfies some domain specific criteria). Traditional real¬ 
time systems do not handle non-deterministic tasks well and mapping an intelligent system’s approach into 
a traditional real-time system usually means modifying the original problem to eliminate some of the 
difficulties associated with real-time operation. Generally, tasks are off loaded from the computer to the 
human operator. If no human operator exists, as is the case in a fully autonomous system, the system 
generally is given a ’canned’ response to apply in all conditions. 

Finally, this approach assumes there always is, or will be able to obtain the necessary processing 
power to handle any possible workload. Although this may be Uiie, 1 tend to believe that the opposite is 
true; namely that there will never exist enough processing power to solve all problems simultaneously. 
This should not be taken as a condemnation of the current Pilot’s Associate approach. For example, one 
can envision the problem as a standard set partitioning problem where the sets are combinations of the tasks 
and the goal is to partition those tasks among n processors as efficiently as possible [Brassard, 1988:92] 
[Cormen, 1990:946] [Tindell, 1992]. If the initial engineering design effort has ensured that some amount 


2-9 














of excess computing power exists, the problem is then reduced to creating a tool to solve the set partitioning 
problem. At the point where no more additional tasks can be added, one simply upgrades the existing 
processors to newer and faster versions, or adds another. 

The Lockheed Pilot's Associate program is currently not experiencing any major run-time problems 
with this method. However, the system is not completed and is known to have reduced functionality 
because of the real-time constraints. If at some future point, processing power becomes an insunnountable 
problem, a major system redesign will be required. Because of this constraint, Lockheed's real-time 
method will not be used in this thesis investigation. 

2.3.3. McDonnell Aircraft's Pilot's Associate McDonnell Aircraft Company's (McAir) Pilot's 
Associate program real-time efforts were divided into two major thrust areas. McAir tackled the actual 
implementation and sub-contracted FMC Coiporation to investigate the software design and architecture 
issues. Since McAir's implementation built upon the work FMC did, a review of the general model FMC 
created is dtme first. Following that discussion, the McAir implementation of that model is examined. The 
discussion is fairly in-depth since the work by FMC and McAir shapes the direction of this thesis effort 

Intelligent real-time system analysis by FMC [Dodhiawala, 1988] reached two conclusions: 

1. In a system such as the Pilot's Associate, there will never be enough processing power to do all 
required tasks, which dictates then, 

2. Real-time performance cannot be obtained by speed alone. 

Although the number and speed of the processors used in implementing a real-time system are a 
primary concern, they are not by any means the only concerns in a complex intelligent real-time system. The 
software architecture which controls the operation of the system plays an equaUy large part in achieving real¬ 
time performance. FMC examined those characteristics (other than processor type and processor speed) of a 
complex, real-time, intelligent system that affect it's real-time performance. 

FMC's research determined there are four basic dimensions of an intelligent real-time system; speed, 
responsiveness, timeliness, and graceful adaptation [Dodhiawala, 1988:1-2]. Speed is the dimension 
concerned with the number of tasks executed per time unit. Speed can be increased by more and faster 
processors or by increasing the efficiency of the algorithms. Responsiveness is the ability of the system to 


2-10 






take on new tasks quickly. It requires that the system be predictive enough to begin composing and executing 
responses to new developments rapidly, and to appear as though all requests are handled instantly. 
Timeliness is the system's ability to conform to task priorities. In other words, the system must be able to 
perform those functions that are the most urgent when they are required. Any responses must be able to be 
determined, presented, and acted upon in order to affect the current situation, not the past. Graceful 
adaptation refers to the system's ability to reset priorities based upon the changing processing load of the 
system. When the workload exceeds the capacity of the system, it must be able to focus its resources on those 
tasks that are the most crucial for that moment. Clearly, three of these architectural features are dynamic in 
nature and require run-time control to ensure the desired system performance is obtained. 

Starting with the assumption of a blackboard implementation of the intelligent system, FMC believes 
the run-time adjustable parameters of execution margin, scheduler heuristics, and channel priorities can be 
used to form the basis of run-time, closed-loop, control of knowledge-based systems [Dodhiawala, 1988:7]. 
The execution margin is defined as the number of knowledge sources that are allowed to execute during each 
pass through the top level control cycle. Scheduler heuristics refers to the rules of thumb used to order the 
currently active knowledge sources for execution. Channel priorities are run-time assigned values that dictate 
how important a particular event is. Figure 2.2 shows the internal operation of the reasoning process in an 
intelligent system that allows adjustment of these parameters. It should be pointed out here that although at 
the top level, the intelligent system operates in an asynchronous fashion; inside the reasoning process, 
synchronous control is exercised. 

In Figure 2.2, the four channels (represented by the thick gray horizontal lines) are EMERGENCY 
for processing events immediately, HIGH for processing fairly critical events, AVERAGE for processing 
routine events such as monitoring the mission plan, and LOW which processes items only when the other 
three channels are empty. The channel priority assigned to an event determines the relative importance of 
that event 

The four gray rectangles in Figure 2.2, Trigger, IVe-Condition, Schedule, and Execute, represent the 
stages a knowledge source goes through. The Trigger step attempts to trigger knowledge sources based on 
the attributes of either the asynchronous external events or the synchrtxtous internal events. It is important 
to realize that an event can trigger more than one knowledge source. When a knowledge source is 
triggered, its variables are set, establishing the context for the execution of the knowledge source or 
instantiation (called a Knowledge Source Activation Record or KSAR). The PRECONDITION step 


2-11 




establishes whether a valid context exists for the execution of that KSAR. Possible values returned in this 
step are OBVIATE - the KSAR is irrelevant or inappropriate for the triggering event, NIL - the context has 
yet to be established, or the preconditions are satisfied and the KSAR moves to the scheduler to be 
scheduled. In the Schedule step, KSARs are ranked and scheduled for execution based upon the current 
scheduler heuristics. These heuristics evaluate the KSAR based upon its importance and urgency. An 
important KSAR is one that is relevant to the current system goal, while an urgent KSAR is one whose 
deadline for execution is approaching. The Execute step will execute the KSARs based upon the execution 
margin. The execution margin determines how many KSARs on each priority channel will be allowed to 
execute during each run through the top level control cycle. Using this approach, and assuming that not all 
tasks can be processed in real-time, EMC believes that the control overhead involved is justifiable in teims 
of the total system performance [Lambert, 1990] [Dodhiawala, 1988]. 


Event Data 
Channel Channel 


O - Internal Event 


Q • External Event □ ■ 
Channels 


Knowledge Source 



Figure 2.2. Reasoning Process Diagram 

McAir's system ran on four Texas Instruments Explorer n machines with an assortment of other 
machines providing support functions [Lambert, 1991]. The top-level architecture is shown in Figure 2.3. 
Each of the sub-systems (indicated by the circles) operated asynchronously and ran in parallel on 
independent machines. The system was event-driven, allowing communication of changes to blackboard 


2-12 





data instead of transmitting entire updated blackboard data structures. The blackboard itself was distributed 
among each of the machines that make up the system. Each sub-system was further divided into a 
blackboard process, VO process, and a reasoning process as shown in Figure 2.2. 



Figure 2.3 McAir's Top Level Architecture 


Using FMC’s approach, McAir's team incorporated some of the real-time concepts into their system. 
The system was implemented primarily in Inference Corporation's Automated Reasoning Tool (ART), 
modified to allow for some PA-specific functions. A modification to the ART agenda mechanism allowed 
for heuristic-scheduling, a feature from FMC's real-time work. Additionally, the Knowledge Source syntax 
was modified to put trigger and pre-condition patterns into a context slot and extra declaratirxis were added 
to include specification of the knowledge source urgency and importance [Lambert, 1991]. 

The module internal architecture shown in Figure 2.4 implemented the blackboard, I/O, and 
reasoning processes [Lambert, 1991]. Basically, the ART working memory used Rete Net pattern matching 
provided with ART to match the context of the knowledge sources [Lambert, 1991] [Fanning, 1990]. Once 
a knowledge source was matched, it was placed on the agenda for execution. From the agenda, the 


2-13 
















knowledge source was executed using a LISP macro that expanded into ART rules. The LISP macro 
allowed McAir to augment the ART rule representation and include the real-time scheduling features of 
importance and urgency. The gray lines indicate the control cycle. Again, ART was modified to allow for 
communication (H'ocessing to take place after each knowledge source was activated. The control cycle was 
designed so that the Blackboard and I/O processes slept if not required, thus allowing more of the machines 
resources to be used in knowledge source execution. 



Blackboard Data 


Knowledge 

Source 

Execution 


Support 

FuncUone 


Exiamal 
Communlcallon Data 


Intar-Btaekboaid 
Communication Data 


Intar-Blackboanl 
Communlcallon Data 


^ Exiamal 
Communication Data 


Data 

Control 


Figure 2.4 McAir's Module Internal Architecture 


23.4. Adaptive Suspension Vehicle. The Adaptive Suspension Vehicle (ASV), is a self-contained 
six-legged, human operated, walking vehicle. The ASV consists of an engine driving 18 hydraulic leg 
actuators, over 100 leg position, leg velocity, leg pressure, and inertial sensors, and a laser range scaimer 
[Payton, 1991:53] [Bihari, 1989:59-62]. The processing suite consists of seven Intel 80386 processors and 
two special purpose numerical processors. As of August, 1991, the control software was approximately 
100,000 lines of Pascal source code. 


The ASV plaiming and control hierarchy is shown in Figure 2.5. The human operator "flies" the 
vehicle with a joystick. The Planned Vehicle responds to the joystick commands by providing leg 
movements to fulfill them while simultaneously avoiding local obstacles. The Planned Vehicle sees the 


2-14 



















Servoed Vehicle as a system of interacting legs. The Servoed Vehicle takes plans provided to the Planned 
Vehicle from the Motion Planner and sends the apjffopriate commands to each Servoed Leg. Each Servoed 
Leg knows its corresponding physical leg's state from the sensors mentioned above. The Servoed Leg 
translates the commands from the Servoed Vehicle into direct commands to the Physical Leg's three 
hydraulic actuators. [Payton, 1991:52] 

The Servoed Legs and Servoed Vehicle operate in the a well-defined world and as such, functional 
as 'traditional real-time systems' as discussed in section 2.1. Extensive analysis of the physical legs being 
ccHitroUed residted in a 10ms period for each Servoed Leg and a 25ms period for Vehicle Servo. Although 
the Leg Servo ideally runs at a 5ms period, processing power limitations forced a 10ms period and 
correspondingly slightly degraded performance. The Leg Servo can even miss an occasional period, 
allowing for some slight timing constraint negotiability. The rate-monotonic scheduling algorithm (section 
2.1) was used to implement these fixed period, fixed pricaity tasks. 



Figure 2.5 ASV Planning and Control Architecture [Payton, 1991:55] 


2-15 























The Motion Planner differs from the servo control in that it operates on the constantly changing 
terrain. It periodically produces a continuous velocity plan segment that is steadily consumed by the 
Servoed Vehicle. The plan segment is made up of two parts: a normal portion containing requested body 
acceleration to be used for a certain duration into the future (Pin), followed by a safety portion containing 
contingency deceleration to zero body velocity (P/j). Each newly generated plan segment overwrites the 
previous plan segment’s safety portion. This two portion plan segment method operates as a 'forward 
recovery' technique in case of planning system failures as illustrated in Figure 2.6. 

The Motion Planner's period varies between 100ms and 500ms dep)ending upon the current state of 
the vehicle and the environment. Payton and Bihari state that the time to calculate a plan segment is 
approximately: 

Vmax/ 

DTcp = -^ + DTov 

~ 1 (2.5) 

where 

DTcp = the time required to compuie a plan segment 

Vmax = the vehicle's maximum allowable velocity 

i4s = the acceleration during the safety portion of the plan segment; 

SR = the rate at which the internal simulation of the vehicle’s movements runs, as a 
multiple of real time; 

DTov = a fixed amount of overhead time associated with computing a plan segment 
[Payton, 1991:56] 

Although not currently implemented in the ASV, the existence of Vmax in the planning cost equation 
(2.5) could allow the scheduling algorithm to adjust its performance to meet timing constraints, telling the 
vehicle to slow down to allow for more planning time. The ASV does, however, use an adaptive 
scheduling algorithm. It starts with short planning periods and monitors how close to its deadline esK:h 
segment completes. Payton and Bihari state that "If plan segments are completed uncomfortably close to 
their deadlines, it lengthens the normal portion of the plan segments and increases the planning period." 
[layton, 1991:56]. 


2-16 






Rgure 2.6 ASV Plan Generation [PaytMi, 1991:55] 

In suminaiy, because the six-legged vehicle can become unstable if the legs operate independently, 
the ASV fits nicely into the centralized, hierardiical control structure. The ASV has successfully integrated 
both a fixed rate-monotonic scheduling algorithm (controlling the leg servos) and an adaptive schedular 
handling the planning tasks. The two-portion plan segment (normal and safety) technique is ad^table to a 
variety of systems. One can envision an airborne autonomous vehicle simply circling if the plaimer misses 
its deadline. Additionally, the link Payton and Bihari make between planning time and vehicle velocity is 
also adrqitable to other domains. Both of these features should be addressed in any intelligent real-time 
system. However, this thesis is focusing «i the software architecture issues of intelligent real-time systems, 
and not on domain-specific techniques. 

2 .4 . Common Intelligent Real-Time System Components 

In order to proceed with the development of an architecture to support intellig^t real-time systems, 
it is necessary to determine what components appear to be common among the systems discussed so far. 
The architecture as developed in the Pilot's Associate program is perhaps a good place to start (Figure 2.2). 
In the figure, the top level components that have been identified are a Blackboard Process, an VO Process, 
and a Reasoning Process. What is missing from this architecture is the notion of a real-time task scheduler 
or task manager. Basically, the McAir Pilot's Associate approach to real-time can be sununed up by the 
term 'agenda-management'. Because there is no preemption, or guarantee of any kind on the execution time 


2-17 






of the KSARs, the a|)proach needs to be enhanced to handle hard real-time constraints and provide some 
guarantees of perfonnance. 

The ASV goes one step further in that it does add a real-time task scheduler. It uses a real-time 
operating system, employing rate-monotonic scheduling to control execution of the leg actuators. The ASV 
also includes a component that performs the I/O Process similar to the Pilot's Associate, namely the 
component that sends commands to the leg actuators and receives data from the system's sensors. 
Additionally, it possess a reasoning process in the form of the motion planner. However, its architecture 
does not address the computation time - solution quality trade off issue. 

In [O’Reilly, 1988], O'Reilly and Cromarty propose still another component of an intelligent real¬ 
time system called a metaplanner. The job of the metaplanner is to plan, monitor, and evaluate the 
execution of problem solving. O'Reilly and Cromarty st^ that such a system would also require a model 
of the computational times and cost of the various tasks the system can perform. With this 'system model' 
the metaplarmer is able to make trade oR^s about which tasks to execute and when, given the current state 
the system finds itself in and the amount of time available to calculate a solution. 

From all of these sources, I have drawn the conclusion that the following components need to exist 
in any intelligent real-time system architecture; 

• Environment Model. This component performs the job of the blackboard in the Pilot's Associate 
program, acting as a repository of information about the current state of the environment 
external to the system. 

• System Model. This component is used to evaluate potential threads of execution. It consists of 
a grai^ like structure which indicates the hierarchical ord^ing of the system’s problem solving. 

• HO Process. This component translates signals from the environment into a format usable by 
the system and vice versa. 

• Reasoning Process. The Reasoning Process or perhaps metaplarmer, provides the adaptive 
control needed by the system to act 'intelligently'. Its primary job is to determine what the 
current task set is in contrast to solving the problems associated with the current task set. 


2-18 






• Task Scheduler. The Task Scheduler schedules the workload of the system based upon 
directions from the Reasoning Process, and provides some real-time guarantees of meeting 
deadlines. 

2 J. Schedulable Task Types 

I have also drawn the conclusion that in an intelligent real-time system there exist three broad 
categories of tasks: periodic, singular, and any-time. Each task also is broken into a mandatory part and an 
optional part. Mandatory task parts represent the minimum acceptable processing required in order to 
complete a task. Optional task parts represent the additional processing to increase a solutiems quality. All 
mandatory task parts are fully deterministic while the optional task parts execution time depends upon the 
type of algorithm used. 

The three task types allow for a mapping of the task types discussed in sections 2.1 and 2.2. Periodic 
tasks are real-time periodic tasks as described in section 2.1. Both the mandatory and optional parts of 
periodic tasks are fully deterministic. Singular tasks are non-periodic tasks that generalize the sieve 
function and primary/altemate task types in section 2.2. The optional part a singular task gives a more 
precise solution, but requires more processing time to compute. Any-time tasks generalize the monotone 
tasks in section 2.2. The optional part of an any-time task provides solutions whose quality increases with 
processing time. 

2.6. Summary 

Methods to determine the schedulability of periodic task sets are well defmed. Methods also exist to 
schedule tasks which have non-deterministic execution times. Also, intelligent real-time systems are being 
developed that operate in a number of different domains. However, no intelligent real-time systems are 
currently addressing dynamic real-time task scheduling and control. The Pilot’s Associate program has 
developed a system to dynamically adapt and control the execution of a knowledge-based system and is 
described in section 2.3.3. What the Pilot's Associate system is missing is a method of ensuring that tasks 
will meet their deadlines. 

By integrating some of the traditional real-time systems methods, imprecise computation scheduling 
methods, and techniques developed in the PA and ASV programs, developing an intelligent real-time 
system architecture in Ada is feasible. The goal of this thesis research is to develop the architecture of such 
a system and demonstrate the feasibility of the design; in particular, demonstrate the ability to dynamically 


2-19 



create, schedule, and execute tasks to achieve real-time performance. Analysis of the results of this 
examination should allow one to suggest heuristics that can be used to dynamically determine the current 
scheduling policy. 


2-20 




///. Design Approaches, Assumptions, and Key Decisions 


Chapter 2 provided some necessary background needed tr design and implement w intelligent real¬ 
time system (IRTS). This chapter draws from that background informatl a and provides design 
methodology for implementing such a system. In particular, how the architecture Lrcorporates the cmumcm 
IRTS components identified in Ch^ter 2 is examined. In this chapter, performance measures for IRTS are 
examined along with design considerations that can be used to affect the performance measures. Following 
that, some basic design assumptions are stated and two possible design approaches discussed. 

3.1. Performance Measures 

Before attempting to design an architecture that supports intelligent real-time systems an 
examination of potential performance measures is prudent. Once these measures have been defined, it is 
then possible to begin making design decisions with an idea of the performance impact such decisions will 
have. The definition of performance measures then is a critical element in any design process. 

A prevalent, but inaccurate, belief is that real-time systems are concerned with execution speed 
alone. In [Shamsudin, 1991], [Dodhiawala, 1989] and [Dodhiawala, 1988] the authors identify four 
performance measures for real-time systems. Those performance measures are as follows: 

• Speed. This performance measure refers to the number of tasks executed per unit time. Speed is 
highly dependent upon the processing hardware. Generally, more and faster processors increase 
this perfcmnanoe measure. Additionally, efficient algorithms can increase the speed of a system. 

• Responsiveness. "Responsiveness refers to the ability of the system to take on new tasks 
quickly. Operating in a rapidly changing dynamic enviroiunent, a responsive system perceives 
new developments early enough to compose and execute responses, possibly at the expense of 
ongoing tasks that may be delayed or even abandoned" [Dodhiawala, 1988:1-2]. 

• Timeliness. This measure "characterizes the system’s ability to conform to task priorities" 
[Dodhiawala, 1988:2]. Assuming that not all tasks can be finished by their deadlines, a timely 


3-1 



system is one that finishes as many as possible. Thus some tasks must be "postponed, scaled 
down or discarded to allow the other work to be completed on time" [Elodhiawala. 1988:2]. 

* Graceful Adaptation. "This refers to the ability of the system to reset task priorities according to 
changes in the resource availability and/or demand and workload" [Shamsudin, 1991:15]. 

These performance measures are well suited for describing both traditiimal and intelligent real-time 
systems. However, two additional measures should be considered. The first is data consistency and the 
second is solution quality. Data consistency refers to the system’s ability to maintain a timely and 
cmsistent view of the environment in which it operates. A timely view of the environment ensures that the 
system is solving problems that exist currently, and not responding to events that have been superseded by 
the passage of time. 

A fundamental premise of intelligent real-time systems is that solution quality can be naded off 
against computation time to produce better solutions to the more important tasks. In order to determine the 
effectiveness of the system in performing this job, some measure of the system's solution quality must 
exist. This measure is probably the most domain specific of the performance measures mentioned thus far. 
but should be addressed by any evaluation effort. 

Summarizing, the performance measures are speed, responsiveness, timeliness, graceful adaptation, 
data consistency, and solution quality. With the performance measures identified, the design effort can 
begin to focus on ways to affect those measures. In the next section, general design considerations are 
examined and related to the performance measures they are attempting to address. 

3.2. Design Considerations 

In [Dodhiawala, 1988:6] the authors presented a number of candidate methods useful when 
designing a real-time system. They suggest that a designer should consider control reasoning, focus of 
attention, parallelism, and improving algorithm efficacy when addressing design issues. Control reasoning 
is based upon the notion that knowledge about task demands, time constraints, system goals, and resource 
demands can be used to make smarter scheduling choices. Control reasoning can be used to affect graceful 
adaptation by recognizing overload situations and adjusting task priorities appropriately. Control reasoning 
can also impact the solution quality, timeliness, and responsiveness of the system. The limiting factor in 
applying control reasoning is the processing overhead associated with performing the rea.soning and 


3-2 



implementing the controls. Temporal reasoning, speed/effectiveness trade-offs, supervisory control, and 
discretionary VO are examples of implementable control reasoning strategies [Dodhiawala, 1988]. 

The capability to quickly respond to critical events is a desirable feature of any real-time system. 
This ability is referred to as the focus of attention. Preemption of executing tasks, prioritization of ready 
tasks, and the ability to change processing contexts quickly are methods of implementing focus of attention. 
Implementing focus of attention strategies directly affect a system’s responsiveness and timeliness, 
generally with a corresponding decrease in speed as a result of processing the context switches. 

Parallelism is primarily a concept associated with speed. By exploiting parallelism at both the 
architecture and application levels, significant performance gains are possible [Sawyer, 1990]. Multiple 
processors or concurrent processes are examples of methods to achieve paralleUsm. Increased parallelism 
generally results in increased design complexity. Adding parallelism to systems as an afterthought can be a 
significant challenge, since most of the inherent parallelism in the system may have been lost in the 
implementation. 

Algorithm efficacy also primarily addresses the speed performance measure, but has a great impact 
upon the timeliness of the system as well. Methods used to improve algorithm efficacy include algorithm 
caching, incremental algorithms, and anticipatory processing. Generally, algorithm efficacy is an issue at 
design time, but each algorithm is tuned during implementation to meet system timeliness or speed 
requirements. 

From the design perspective, each consideration needs to be addressed and each trade-off examined. 
First however, it is necessary to present the design assumptions that are a driving factor in this thesis effort 

3.3. Design Assumptions 

The first assumption is that in any intelligent system, the majority of the work performed by the 
system is procedural in nature [Wilber, 1989:75]. For example, if one was to create a fully autonomous 
system to pilot a modem fighter aircraft, the existing computer software that drives the flight control, 
sensor, weapons, and navigation systems would in all likelihood not be replaced with AI programs. Rather, 
an AI system would be installed to control these existing systems, similar to the way in which a human 
pilot decides what system to activate, what mode to activate it in, and when to activate a particular system. 
Thus the AI system treats the other aircraft systems as either tools for gathering information or as effectors 






to achieve a desired state. It does not duplicate the procedural fimctions already performed by the other 
systems. 

The first assumption thus leads directly to the second assumption and the primary system design 
goal: design a system that allows an intelligent agent to control procedural tasks in such a way as to 
effectively and efficiently achieve a dynamically determined goal within real-time deadlines. The focus of 
the design effort then is not on the design of an ERTS for a specific domain, but rather on an architecture 
necessary to implement any intelligent real-time system. 

An additional assumption is the use of Ada as the implementation language. Research and 
development communities, in my opinion, seem to believe that an implementation language is of little or no 
consequence to a research effort. In general this may be true, however, the rising trend in DoD software 
costs has resulted in a public law that dictates the use of the Ada progranuning language for all DoD 
software, making the implementation language an engineering issue. Any software system that is migrating 
into operational use must address the Ada implementation question. In essence, the implementing lan guage 
is an engineering hurdle to overcome, similar to choice of the technology used to implement integrated 
circuits. This thesis effort recognizes the issue and attempts to add some basis for making decisions on the 
use of Ada in intelligent real-time system design. 

The fmal design assumption steins from the belief that not all the desired processing can be done in 
the required time. The design assumpticm is that overload situations occur. If the opposite were true, then 
there is little need for any explicit control structure to prioritize what the system is doing. This design 
assumption dictates that the system must be able to prioritize the current task set to ensure those that are 
most relevant to the current situation are executed first and completed by their deadlines. Consolidated and 
restated, these four design assumptions are: 

1) A real-time intelligent system consists of a large collection of procedural tasks whose execution 
timeline is determined by an intelligent agent. 

2) The focus of this effort is on the software architecture of a system that provides the intelligent 
agent the necessary control to achieve its current goals in a timely maimer. 

3) The system must use the Ada programming language for implementation. Thus, it is critical to 
show how the concepts outlined in this thesis can be implemented in Ada. 


34 







4) The system is at times overloaded and thus must be able to dynamically prioritize the tasks. 
(Note that this thesis research does not purport to develop the domain knowledge necessary to 
determine what task is the most important at any particular instant; rather, it gives the intelligent 
agent in the system the tools with which to ensure those priorities are enforced). 

Finally, a critical element of this thesis is real-time and, as discussed in Ch^ter 2, the guaranteed 
ability to meet deadlines. The design effort must provide a method for the system to ensure real-time 
performance as deHned by the ability to guarantee deadlines. Additionally, it is impmtant to remember that 
execution speed is always an issue, even if not explicitly mentioned, in any design decision. 

3.4. Possible Design Approaches 

Drawing from the background research, two fundamentally different approaches for achieving the 
goals of this thesis effort were envisioned. The first method is to modify an existing "reasoning process's" 
data and control structures to allow for the addition of real-time programming constructs. The second 
approach is to use standard Ada and design separate real-time data and control structures controllable by 
the reasoning process. The work done by the Pilot's Associate Program as outlined in section 2.3.3 seems 
to indicate that the first tqiproach, modifying an existing reasoning process, would be the most apprc^riate. 
After a long period of consideration, I opted to use the second approach. What follows is a brief 
examination of the issues involved in both approaches and the reasmis for the decision to not to attempt to 
modify an existing reasoning process. 

3.4.1. Modifying CUPSIAda Design Approach. In sectitm 2.3.3, the ^proach to achieving real-time 
performance in an intelligent system can be suiiuned up by the term agenda management. The system must 
determine what is the most important knowledge source, process, rule, or other computation to execute 
next Agenda management requires an agenda, and a method to prioritize items on the agenda. Thus for 
my purposes, I needed a reasoning process that allows for basic agenda management and, because of my 
third design assumption, is implemented in Ada. Additionally, since modifications to the source code of 
the reasoning process are practically guaranteed, access to the source code and documentation is required. 
CLIPS/Ada is the tool I found best suited to fill this role. 

CLIPS/Ada is an Ada implementation of version 4.3 of NASA’s C Language Integrated Production 
System. (XIPS/Ada provides a basic set of functions which can be used to achieve agenda management 
and rule prioritization [CLIPS-Ada, 1991:20] [CLIPSRefMan, 1991a] [CLIPSRefMan, 1991b] [CLIPSUG, 


3-5 





1991]. Given these basic building blocks, it is easy to envision adding the modifications as outlined in 
[Dodhiawala, 1988], [Lambert, 1990], and [Lambert, 1991] and discussed in section 2.3.3. In particular, 
adding channels or multiple agenda queues, scheduling policies based upon completion deadlines, and 
monitors to detect missed deadlines appears a straight-fcxward task. 

CLIPS/Ada provides three basic parts to its rule structure as shown in Figure 3.1: the declaration 
part, the conditional-element(s) (the asterisk indicates plurality is possible), and the action(s). The 
conditional-element is traditionally referred to as the left-hand side of the rule and the action part is right- 
hand side of the rule. The declaration deflnes properties of the rule, the conditional-element(s) defmes the 
conditions necessary for the rule to execute, and the action(s) defmes what should occur when the rule 
executes. 


(defrule <rule-name> [<comment>] 


[<declaration>] 

<conditional-erement>* 

; Rule Properties 
; Left-Hand Side (LHS) 

<action>*) 

; Right-Hand Side (RHS) 


Figure 3.1 CUPS Rule Definition Structure [CUPSRefMan, 1991a:27] 

The only currently defined declarative characteristic available in CLIPS/Ada is the salience of the 
rule. Salience is the priority of the rule and can either be assigned dynamically or statically. The salience 
defines which rule on the agenda of active rules executes next and thus provides one feature required of an 
intelligent real-time system. Additionally, because CLIK/Ada allows the salience to be evaluated at every 
cycle through the rule execution loop, it is easy to imagine the agenda management functions discussed in 
section 2.3.3 being added with relative ease. 

What is missing from the CLIPS/Ada system is the ability to determine and enforce the execution 
time allotted to each rule's actioas or of the CLIPS/Ada inference engine itself. Thus, mice a rule is chosen 
it is executed to completion, regardless of any changes in the environment. Additionally, the ability to 
declare periodic rules or functions (periodic tasks are fundamental in real-time systems) is also missing, 
although CLIPS version 5.1 is begirming to address this issue [CLIPSRefMan, 1991a:220]. Thus, for my 


3-6 










purposes, I would be required to add the ability to declare and execute periodic tasks, ensure execution 
deadlines, and interrupt or terminate executing rule actions. 

One method of incorporating these abilities into CLIPS/Ada would be to expand the declarative part 
of the rule structure to include additional characterisdcs necessary to ensure real-time performance. Figure 
3.2 shows an example of such a modification to the CLIPS/Ada rule structure. Here added declarations of 
rule-type, mandatory-duration, and optional-duration allow scheduling decisions to be made. Additionally, 
the RHS actions are divided into mandatory and optional actions which can be executed as determined by 
the current situatirm and scheduling policy. 


(defrule <rule-name> [<comment>] 


[<declaration> 

; Rule Properties 

<salience> 


<rule-type> 

<manaatory-duration> 

<optional-cluration>] 


<conditional-element>* 

; Left-Hand Side (LHS) 

<mandatory-action>* 

; Right-Hand Side (RHS) 

[<optional-action>*]) 


Figure 3.2 Modified CLIPS Rule Structure 

Adding the ability to start, stop, and terminate executing rules is much more complex. First, it 
implies multiple processes operating concurrently. Each rule therefore needs to be encapsulated in a form 
that allows control of its execution time. Because my design assumes Ada is used and Ada coiKunency is 
expressed in Ada tasks, essentially, each rule needs to become a separate Ada task. This is a significant 
change from the single thread of control CLIPS/Ada executes under now and a method to translate 
CLIPS/Ada rules into Ada tasks is required. 

These changes are possible to implement; however, the job of implementing them is .staggering 
[Sawyer, 1990]. First, the CLIPS/Ada source code contains over 130 files that total to more than 2.5MB of 
source code. Second, the changes involve both syntactic and semantic modifications, implying changes 
through out all the source code. Finally, this thesis effort is focusing on the design of an generalized 
architecture capable of supporting IRTSs, and not restricted to only rule-based systems; thus, this ^iproach 


3-7 








was deemed currently impractical. The modification of CLIPS/Ada to support real-time is left as future 
research. 

3.4.2. Controllable Real-Time Task Manager Approach. The second approach consists of using 
standard Ada and designing a system that supports real-time constraints and is controllable by another 
process called the Reasoning Process. The goal is not to modify the Reasoning Process itself, but rather to 
treat it as a separate entity that controls a real-time system. The Reasoning Process must be able to control 
what the current task set is, what the cunent scheduling policy is, and be able to change them as required. 
What it is not required to do is the actual scheduling and execution control of each task in the currently 
deOned task set. This elevates the Reasoning Process to a “supervisory level”, acting as the central element 
in the control reasoning of the system, and alleviated of the bookkeeping necessary to implement the 
desired scheduling policy. 

This approach requires a separate entity called the Task Manager that controls the instantiation, 
scheduling, and execution of Ada tasks as directed by the Reasoning Process. Additionally, it provides 
staUis information about the state of a task or the state of the system as a whole to the Reasoning Process. 
The design process using this approach requires that a set of controllable parameters be devised that are 
manipulated by the Reasoning Process and implemented by the Task Manager. The identification and 
implementation of these controllable parameters is the heart of this thesis effort. 

As implied above, the controllable parameters can be divided into groups based upon the function 
they are performing: scheduling policies, control variables, status variables, and task controls. Example 
scheduling policies are earliest deadline fust, important task fust, and shortest task first. Example control 
variables are the percentage of CPU time to allocate for periodic tasks, or execute mandatory or optional 
task parts flags. Example status variables include the actual number of tasks currently running or the 
percentage of CPU time currently in use. Finally, task controls include task instantiation, task modification, 
and task deletion. Note that creating a task is a different operation than scheduling a created task. 

The concepts and methods developed using this second approach are also applicable to the first 
approach. It is crmceivable that the Task Manager can be incorporated directly into the Reasoning Process. 
Alternatively, one can choose from the methods developed here to meet real-time constraints and only 
incorporate those that seem to provide the most utility. Taking this second approach does not prevent 
someone from taking the first approach and may actually be the necessary first step in the first approach. 


3-8 




The remainder of the chapter addresses the design decisions made to use the second approach and concisely 
defines the design problem. 

5-5. Design Problem Statement 

A statement of the design problem now helps to define >^t this research is attempting to do. It is 
important to remember that an underlying assumption of this thesis effort is the existence of a domain 
specific problem solving stmcture (plan-goal graph or task network). Remembering that, and drawing upon 
the information presented thus far in this thesis, the (tesign problem can be stated as follows: 

Given a graph structure (plan-goal graph or task network) that represents the system's operation, and 
some currently active subset of that stmcture, dynanrically gmerale and execute a processw schedule 
to maximize system performance based upon a dynamically determined scheduling policy. Each 
node in the graph represents a task to accomplish in response to some event firom the enviroiment or 
needed operation to accomplish the system's mission, and each node represents either a periodically 
performed task, single event response task, (r a continually refined event response task (an any-time 
task). 

3.6. Key Design Decisions 

From the backgroimd research performed, constraints upon development tools, and my own 
intuition, a number of key design decisions are easily made. This section explicitly lists those decisions and 
some of the reasons for each one. In short, those key design decisions call for small scale parallelism, 
asynchronous operation, Ada tasks as the scheduling elements, dynamic Ada task instantiations, and a 
single processor feasibility implementation. 

All of the systems examined in die background research were implemented with between four and 
eleven processors [Lambert, 1990] [Aldem, 1990] [Payton, 1991]. This relatively small number of 
processors can generally be classified as small scale parallelism. The architecture developed in this thesis 
effort should consider a partitioning of functions suitable for a small number of processors. 

Asynchronous operation of the partitioned functions is also a conclusion drawn from the background 
research. Each of the partitioned fuiKtions should operate at its own speed as dictated by the work it 
performs. This tqrproach aUows for decoupling of the system components and corresponding performance 


3-9 






benefits. Additionally, events external to the system, generally asynchronous in origin, can be handled as 
they occur. 

A direct result of the design assumption of Ada as the implementing language is the use of Ada 
tasks. Ada represents concurrency in the form of tasks and thus any system implemented in Ada, and 
intended to execute concurrently, should use Ada tasks. This implementation language imposed constraint 
must be addressed if task scheduling is to be performed in this system. 

A decision resulting fiom my literature review is the requirement for dynamic Ada task creation and 
control. From examination of knowledge engineering documents of the Pilot's Associate program, it is 
clear that in any real system, there are a very large number of tasks the system can perfcum. Clearly, not all 
of the tasks can be economically instantiated simultaneously within the limits imposed by today's 
processing systems. This forces me to the conclude that tasks must be created or instantiated dynamically 
at run time. 

Finally, the issue of a design feasibility demonstration must be addressed. Given the tools available 
for this research effort, and the limited time to develop a demonstration, a single processor feasibility 
demonstration is the only viable alternative. Since, this thesis effort is the begiruiing in a series of related 
efforts to develop and flush out an intelligent real-time system, I believe the most imprxiant issue to address 
first is the feasibility of dynamic task creation and scheduling. For that reastxi, I have chosen to start Hrst 
with a single processor implementation, while maintaining concurrency in the design. 

3.7. Design Approach Summary 

This chrqrter has attempted to provide some of the design methodology and some design guidelines 
used in developing this intelligent real-time system architecture. In summary, I have listed some 
performance measures and some design concepts and methods to afl'ect those performance measures. 
Additionally, basic design assumptions and some key (fesign decisions have been addressed. The following 
chapters in this thesis develop an architecture based upon the design assumptions and decisions, and 
examine the issues arising from that development effort 


3-10 




rv. An Intelligent Real-Time System Architecture 


Because the scope of this thesis investigation is so large, the research and development effort is not 
completed within this thesis effort. The research area of intelligent real-time systems is diverse and 
complicated, and this effort is beginning the piXKess of examining the issues involved. Examination of the 
issues is done by incrementally designing and implementing a syst^ c^ble of performing the role of an 
intelligent real-time system (IRTS) and addressing potential problems as they arise. Acknowledging the 
broad subject area of this research, it is necessary to provide a larger vision of how such a system should be 
constructed. The goal of this chiq)ter is to provide that vision. 

4.1. Top Level Design 

The top-level intelligent real-time system conceptual architecture is shown in Figure 4.1. Briefly, 
the Environment Model acts as the data repository, similar to a blackboard as discussed in section 2.3.3. 
The I/O Process is responsible for communications with the environment The Reasoning Process is 
responsible for determining the currently active set of tasks and the current scheduling poUcy to use in 
scheduling that set of tasks. The Task Manager is resptmsible for implementing the scheduling policy and 
notifying the Reasoning Process of the current status of the task set. Finally, the System Model represents 
the system’s problem solving approaches in a form that can be used by the Reasoning Process in 
determining the currently active task set. The tq>-ievel design includes all the basic components of an 
intelligent real-time system as identified in Chapter 2. The Reasoning Process is nUing the intelhgent agent 
role and uses the Environment Model, System Model, and status information provided by the Task 
Manager to reason with. The Task Manager schedules tasks as directed by the Reasoning Process to 
achieve real-time performance. 

The architecture vision presented in Figure 4.1 attempts to maintain as much parallelism as possible 
in the design. From the background research, it can be concluded that most IRTSs run on multiple 
processors, usually loosely coupled or distributed. The recognition of that probable direction is shown by 
separation of system functions. Each function is envisioned as a separate Ada task. As mentioned 
previously, in Ada, parallelism is represented in tasks. Additionally, the language provides a number of 
features specifically designed to handle task scheduling and inter-task communications [Booch, 1983:231- 


4-1 






304] [Locke, 1992] [AdaLRM, 1983;Chapter 9] [Real-Time, 1984]. Methods other than using Ada tasks 
are possible and should be examined, but for the purposes of this effort and the top-level design, Ada 
tasking is a keystone. 

The component most lacking in previous intelligent real-time systems is the Task Manager. For that 
reason, it is the primary focus of the rest of this thesis effort However, befeve discussing the design issues 
of the Task Manager, the other components are briefly discussed. The discussion also contains suggested 
aiq)roaches to implementing the components not yet implemented in this research effot. 



Figure 4.1 Top Level Design Diagram 


4.2. Environment Model 

The development and implementation of the Enviroiunent Model is beyond the scope of this 
particular thesis effort. However, its impact on the overall system design must be accounted for and 
addressed in any feasibility demonstration. The Environment Model is perhaps the most domain specific 
aspect of any IRTS. The Environment Model encapsulates all the data structures that are deoned relevant 
to the system's ability to function intelligently in the envirorunent. The exact method used to represent the 
envirraunent model is an open issue; however, this research plans to pursue an object oriented approach. 


4-2 


















Along those lines, my investigations have centered around the use of Classic-Ada to implement an 
object-oriented environment model [ClassicAda, 1989], This package provides all the standard object 
oriented data and control structures. In addition, it allows object references to be passed by means of an 
object ID value. This ability is highly desirable when passing information to the Task Manager for use in 
controlling tasks. Essentially, a pointer task's data structure can be passed and stored as a single object ID. 
Although shared memory structures are common practice in real-time systems, there is a potential 
communication bottleneck that can be created with this approach. Future efforts should examine this issue 
closely. 

Again, it is out of the scope of this thesis effort to fully implement an environmental model. 
Identifying the relevant ideas (passing pointers to data structures by object ID and object oriented design 
techniques) suffices to give the direction this is pursuing. Additionally, it provides general guidance on 
where to begin in any follow-on thesis effort. 

4.3. System Model 

Development of a specific system model for a particular dennain is not the purpose of this thesis. As 
has been mentioned previously, this research is i^edicated upon the assumption that a Systc.” Model for the 
chosen domain already exists. Thus for the purposes of this architecture, a method of representing that 
model needs to be provided. The plaimed direction is to use a graph theory approach to represent the 
System Model. 

It is important to point out that the graph structure used to represent the system to the reasoning 
process is not, in fact, the system. Instead, each node in the graph is a representation of some processing 
required of the system as a whole. The actual code that represents each node in the System Model is 
accessed and controlled by the Task Manager. 

While the system is executing, there should conceptually be two system models present. The first 
one is the sum total of all the possible nodes that the system can instantiate, and the second represents the 
set of tasks currently instantiated by the system. The first model contains in each node, information on how 
to instantiate that particular node and the real-time impacts of instantiating that node. The nodes in the 
second network should contain the information actually used to instantiate that particular instance, and 
information that allows the Reasoning Process to communicate with the instantiated task. 


4-3 






Simple grai^ fimctions should be able to acc(Mnplish the job of the System Model effectively. Thus, 
the design must allow one to add or delete nodes in the graph, search the graph for a particular node, and 
allow the reasoning process access to the data stored in that node. All of these are standard graph functions 
available as Booch components [Booch, 1986]. In addition, reasoning about the temporal relationships 
between tasks must be allowed for. Future research should pursue the use of temporal logic and temporal 
constraint networks to achieve that ability [Wood, 1989] [Dechter. 1991]. 

4.4. HO Process 

The exact internal workings of the I/O Process is again implementation dependent The important 
issues to address are the fact that I/O is required and tte relative priority associated with I/O in general. For 
example, reducing sampling rates on I/O charmels can be one method for the Reasoning Process to gain 
some CPU time. However, critical external signals must still be acknowledged and dealt with. 

The concepts of periodic and non-periodic tasks with varying importances and execution priorities 
can be easily extended to include I/O processes. This imphes that the Reasoning Process could treat the I/O 
Process as simply another task to be scheduled and executed by the Task Manager. The purpose of making 
an explicit I/O Process in the overall design is to emphasize the fact that communications with the world 
external to the system is inherent in all intelligent real-time systems. 

45. Reasoning Process 

Although the focus is on the architecture required for an intelligent real-time system, it is primarily 
addressing the controls necessary and not the design of the intelligent agent that manipulates the controls. 
It should not be taken as a given that the appropriate choice for an intelligent agent is always a rule based 
expert system. Rather, the nature of the intelligent agent should be viewed as domain dependent. Possible 
choices for an intelligent agent include straight procedural code designed for the particular domain, a rule 
based expert system, or a neural network or coimectionist approach. It is my belief that eventually, the 
intelligent agent should incorporate all of these approaches. 

However, this thesis effort is primarily addressing the Task Manager and some compromises have to 
be made. For this reason, the Reasoning Process used is a rule-based system made up of CLIPS/Ada and 
the appropriate interface code. CLIPS/Ada was available and provided the necessary functions with which 
to prototype the system operation. In addition, both the .source code and user manuals were available. 


4-4 




The basic ^proach is for the I/O Process to signal the occurrence of events in the environment by 
asserting facts into the CLIPS fact base. CLIPS rules are then pattern matched against these facts and 
actions taken as t^prq)riate to guide the system into a desired state. Those actions can include directing the 
Task Manager to create new tasks, modify current tasks, or remove current tasks. The Task Manager 
responds to these actions and asserts new facts into the CLIPS fact base that describe the state of the 
currently active task set. CLIPS rules are again pattern matched against these new facts and further actions 
taken as appropriate to handle any problems. CLIPS is filling the role of a metaplanner for purposes of this 
design. 

4.6. Task Manager 

The literature review and analysis of intelligent real-time systems conducted in Chapter 2 revealed 
three broad categories of tasks the Task Manager needs to manage. These categories are periodic, singular, 
and any-time. A periodic task arises from the necessity to either control some process or monitor for some 
condition. Periodic tasks are fundamental to traditional real-time systems as exemplified by the large body 
of knowledge covering real-time periodic task scheduling [Spnmt, 1989] [Sha, 1989] [Broger, 1989] 
[Borger, 1989] [Sprunt, 1990] [Sha, 1991] [Lamont, 1991]. Examples that produce periodic tasks are 
things like maintaining a flight path in the presence of strong winds, or monitoring a radar track to ensure it 
does not become a threat, or screen updates to video displays. 

Singular tasks and any-time tasks are both types of non-periodic tasks. Examples that produce 
singular or any-time tasks are things like taking off in an autonomous aircraft, or responding to an obstacle 
that blocks the path of a mobile robot. In the autonomous aircraft, taking off usually only happens once 
during the life of the mission and once accomplished, that task can be forgotten and purged from the active 
task list. The mobile robot may encounter many obstacles while negotiating a route or may not encounter 
any at all. In either case, there are generally specific task starting times, execution sequences, and deadlines 
that must be adhered to. 

The difference between singular and any-time tasks lies in the underlying algorithm encapsulated by 
the task. A singular task arises from the asynchronous nature of events occurring in the real-world, or one 
time steps in a control process. An any-time task is similar to singular task, in that it arises from the same 
conditions, however, its solution method differs significantly. A singular task has a specific starting time 


4-5 






and after some time interval provides an answer. An any-time task also has a specific starting time, but 
provides answers of increasing accuracy (tx* quality) the longer the task is allowed to nm. 

Additionally, one of the premises stated for an intelligent real-time system is the ability to trade-off 
solution quality and execution time. Thus, each task is assumed to have a mandatory and optional part. 
This concept, as outlined in section 2.2, provides one method of performing the solution 
quality/computation time trade-off and is adopted fully in this approach. The mandatory part of each task 
ensures that, at least, some answer is provided by the intelligent real-time system by the task's deadline. 
The optional part of each task provides ways to increase solution quality, provided execution time is 
allotted. 

Finally, a method of mixing the task types together in one system needs some consideration. Real¬ 
time systems generally cast both periodic and non-periodic tasks into the periodic framework [Spnmt, 
1989] [Sprunt, 1990]. Using this approach, non-periodic tasks are given periodic time shces in which to 
execute that go unfilled if not needed. The approach taken in this research is a slightly different 
methodology that allows the Reasoning Process to control the amount of CPU time allotted to periodic 
tasks, called the “budgeted periodic utilization”. Non-periodic tasks are scheduled to execute in the 
remaining CPU time. 

The impact on task scheduling of these varying task types is enormous and is discussed in greater 
detail in the following sections. However, the need to achieve real-time performance levies a common set 
of constraints upon how each task type is dealt with. In particular, it is necessary to determine if a given 
task set is feasible (i.e., can be scheduled to meet its deadlines) and then to schedule the task set. Also, 
since it is assumed that there are infeasible task sets, an infeasible task set needs to be detected, and a 
feasible sub-set of the tasks scheduled. 

4.6.1. Periodic Task Scheduling. Periodic tasks have a period, a mandatory and optional duration, 
and a dynamically assigned importance which represents the current relevance of the task. The distinction 
between importance, and priority is necessary to emphasize. The priority of a periodic task is the value 
assigned to the task by the scheduler to ensure the task’s execution characteristics. The task's importance is 
a system wide value of the task’s relevance to the ciurent problem. The problem for the periodic task 
scheduler then is to assign an execution priority to a task, given the task's importance, a scheduling policy, 
and the current state of the system. 


4-6 





The rate-monotonic theory plays a critical role in fulfilling the job required of the periodic task 
scheduler. As discussed in section 2.1, the rate-monotonic algorithm provides a method of determining the 
feasibility of a given task set and a corresponding priority assignment method for a feasible task set. By 
keeping track of the durations and periods of the periodic tasks, it is simple to see if an additional task can 
be accommodated with a guarantee of its ability to meet its deadline. Table 4.1 below is an example set of 
periodic task that is used to illustrate some of the potential methods to schedule periodic tasks. 


Table 4.1. Example Periodic Task Set 


Task 

Desired 

Max Period 

Mandatory 

Optional 

Total 


Period 


Duration 

Duration 

Duration 

Tl 

33 

50 

1 

1 

2 

T2 

67 

100 

1 

3 

4 

T3 

67 

100 

2 

4 

6 

T4 

100 

100 

2 

5 

7 

^5 

360 

450 

jMjjjl 

6 

10 

T6 

500 

750 

4 

8 

12 

T7 

750 

1000 

3 

15 

18 

T8 

1000 

1500 

3 

11 

14 


From Table 4.1, one can determine four possible periodic utilizations; (1) minimum mandatory 
utilization, which is the absolute minimum periodic utilization that can be achieved, (2) maximum 
mandatory utilization, (3) minimum optional utilization, and finally, (4) the maximum optional utilization, 
which is the absolute maximum periodic utilization of the current task set. Figure 4.2 gives the relative 
positions of the four values. 

Note that there is no minimum period given for each task in Table 4.1. The desired period is 
assumed to be the minim'un period. It is inconsistent with real-time system design to propose periodic task 


4-7 





























































sets whose periods are not the minimum desired. This implies then that the periodic scheduler does not try 
to maximize processor utilization simply because processing time may be available. Rather, the periodic 
task scheduler tries to obtain the best solution quality (as a fimctim of optional task portions scheduled and 
executed) based upon available time. 


Assuming the current set of periodic task consists of tasks Tj thru T 7 , the maximum utilizatirxi of the 
example periodic task set is shown below. Note that the maximum utilization calculation uses the 
minimum, or desired periods and both the mandatory and optional task durations. 


UtiL 


n 



(w.+O,) 

Pi 


P\ P2 Pi 

33 67 67 100 360 ^ 500 750 
0.3673 


where mi and 01 are the mandatory and optional durations of each task and pi is the period of each task in 
the set. And similarly, the minimum utilization is calculated using the maximum periods and only the 
mandatory part of the tasks. 










Pi P2 

Pi 



1 1 

2 2 

4 

4 3 

50 100 

100^100 

450 

1 1 

750 1000 

0.0872 





Equation 2.1 says that with 7 tasks, the utilization must be less than or equal to 0.728. However, in 
our case we are restricting the CPU time allotted to periodic tasks to not exceed the current budgeted 
periodic utilization. Thus Equation 2.1 must be adjusted to reflect this further restriction as follows: 




BU 


(4.1) 


where BU is the budgeted periodic utiUzation. Assuming the current budgeted periodic utilization is set at 
0.51, we get a required utilization of 0.728 * 0.51 = 0.3712. Since the current maximum utilization is less 
than 0.3712 we can guarantee that the deadlines of our periodic task set are meet 


4-8 





Adding Tg to the task set raises thf utilization to 0.36%. Using (4.1) the required utilization with 8 
tasks and a budgeted periodic utilization of 0.51 is 0.3693, and we can no longer guarantee the ability to 
meet the deadlines for the task set However, we can still guarantee the deadlines of the task set if only the 
mandatory parts of each task are executed, or the budgeted periodic utilization is raised. It is the job of the 
Task Manager to schedule the task set as best it can and notify the Reasoning Process of its current status. 
It is up to the Reasoning Process to either step in and adjust the task set, or let the Task Manager schedule 
the task set 


Min 


Mandatory 


0.0 

Ian* 


Max 

Mandatory 




ajp 


f 


1.0 

utilization 


Min Max 

Optional Optional 


Figure 4.2 Some Calculable Periodic Utilizations 

Using the minimum utilization, the maximum utilization and a dynamically determined budgeted 
utilization, the scheduler should initially schedule tasks using the rate monotonic algorithm with both the 
mandatory and optional portions of each task. When the currently budgeted periodic utilization is 
exceeded, then a scheduling policy decision must be made, and that decision is left to the Reasoning 
Process. From the periodic scheduler’s point of view, it simply needs to detect a violation of the current 
policy, and be able to implement a new scheduling policy. 

Some intuitively obvious scheduling policies are (as mentioned above) scheduling both the 
mandatory and optional task portions, or scheduling only the mandatory portions of tasks. Another task 
scheduling policy that directly affects the system’s ability to degrade gracefully is importance-ordered 
scheduling. In importance-ordered scheduling, periodic tasks with higher importance need to be scheduled 
at a higher execution priority then tasks of lower importance. Note that this approach is directly addressing 
the issues of focus-of-attention and control reasoning. 


4-9 








The policy of scheduling both the mandatory and optional task portions can be viewed as the 
'normal' case. Here the scheduler is trying to provide the best possible answer to every problem. When 
computation time is in short supply, switching to mandatory-only task portions frees up the maximum 
amount of processor time, at the cost of solution quality for all periodic tasks. When computation time is of 
a minimum but solution quality is important, switching to an importance ordered schedule is desirable. 

In sununary, the periodic scheduler needs to assign execution priorities to a new task, based upon the 
current scheduling policy. Thus, a scheduling step occurs whenever a new task is created. Additionally, 
the periodic scheduler needs to provide the reasoning process with a variety of implementable scheduling 
policies that achieve different goals. As mentioned above, these implementable scheduling policies should 
include at least, mandatory only, optional and mandatory, and importance-ordered. 

4.6.2. Non-Periodic Task Scheduling. Non-periodic tasks consist of a mandatory and optional 
dirration, a dynamically determined importance, a start time, a deadline, and possibly precedence 
constraints. Additionally, non-periodic tasks can either be singular or any-time tasks. The job of the non¬ 
periodic task scheduler then is to assign execution priorities to both singular and any-time tasks to ensure 
tasks are completed on or before the task's deadline. 

The concepts used here are primarily derived from the work done by Liu, et al, [Liu, 1991]. Thus, as 
is the case with all tasks in this system, each task is assumed to have a mandatory portion and an optional 
portion. Again, as is the case with the periodic tasks, the job of scheduling non-periodic tasks can be 
decomposed into determining the feasibility of scheduling a task set, and actually scheduling the tasks. 

Before discussing the proposed scheduling methods, a word about the durations of the optional parts 
of singular and any-time tasks is required. The optional duration of a singular task is a one time chunk of 
time that the task needs to compute a solution that is more accurate than its mandatory part. The optional 
duration of an any-time task is the amount of time it takes to cycle once through the solution refmement 
process. Thus when a singular task’s optional duration has elapsed, the ta.sk is completed. When an any¬ 
time task’s optional duration has elapsed, it is simply placed back into the set of tasks ready to execute until 
its deadline has passed or some other teiminating condition met 

One is cautioned that the problem of optimally scheduling varying length tasks with precedence 
constraints preemptively is an NP-complete problem [Coffman, 1976:Table 1.1]. A real-time system that 
faces such a problem must make some simplifying assiunptions, or place artincial constraints upon the 


4-10 







problem size. The approach taken in this thesis is to make some simplifying assumptions. Thus, optimal 
solutions are not generated; rather a working scheduling is found quickly. This approach means that the 
Task Manager does the on-line scheduling of the non-periodic task set using the assigned importances, 
deadlines, and start times while the Reasoning Process does the off-line scheduling to determine what the 
task set, importances, deadlines, and start times should be. 

The scheduling policy used is, basically earliest deadline fnst as enhanced for on-line scheduling by 
Baruah, et al, [Baruah, 1991]. In addition, the earliest deadline Hrst algorithm has been enhanced to deal 
with the concept of mandatory and optional task parts. The algorithm assumes the existence of two priority 
queues, one with tasks arranged with the earliest deadline Hrst, and another arranged with the latest start 
time fnst. The latest start time of a task is its deadline minus its mandatory duration if its mandatory part 
has not completed, or its optional duration if it has. 

When a new task arrives in the system, it is placed into the deadline and latest start time queues. The 
scheduler removes the first task from the deadline queue and begins to execute it. If this is the first time 
that task has been started, then it will be executing its mandatory part. When the task is completed, it is 
removed from the latest start time queue, its latest start time for its optional part is calculated and the task is 
reinserted into both the deadline and latest start time queue. As long as the system is not overloaded, the 
latest start time of any task will never be exceeded. An overload situation is detected by the presence of a 
task on the front of the latest start time queue whose latest start time is equal to the current time. 

When an overload situation occurs, tasks ate executed based both on the deadline of the ta.sk and its 
importance. The choice of which task to execute must now be made. Assuming that the goal of the system 
is to execute as many mandatory tasks as possible, then if the currently executing task is not executing its 
mandatory part, and the task with a latest start time equal to the current time has not executed its mandatory 
part, the currently executing task is preempted, and the other task is started. If both tasks are executing 
their mandatory parts, then the currently executing task is checked to see if it has any slack time. If it docs, 
then again it is preempted and the other task is started. If it does not. then the task with the highest 
importance is allowed to execute and the other task misses its deadline. 

Using the latest start time queue allows the scheduler to easily detect overload situations. 
Organizing tasks with both a mandatory part and an optional part allows the solution quality/computation 


4-11 






time trade off to be made. Combining the two allows one to defme multiple scheduling policies that can be 
adapted to the current situation. 

The “feasibility test" consists primarily of determining if every task in the task set can at least 
complete its mandatory part by its deadline. Given the task’s mandatory duration, feasibility testing is 
fairly straight-forward with one exception. That one exception deals with accounting for the periodic task 
set's processor utilization. Figure 4.3 below illustrates the approach used to address this issue. 



nii»ir t 


Duration r i i 1 

till 

Mandatory 1 i < l 

- 1 

1 

Duration P | i | 

Periodic 1 —| j —| 1 —| I 

Utiiization , i \ I 

till 
V 1 l 1 

1 1 1 1 

start 1, 12 13 

time 

t| t. 



Figure 4.3 Predicting Non-Periodic Task Actual E)urations 

Since the periodic utilization is the percentage of the CPU time that is unavailable for non-periodic 
tasks, each non-periodic task's predicted execution time must include some amount of time waiting for the 
periodic tasks to complete. The approach taken is to simply divide the task's mandatory or optional 
durations by the processor utilization not used by the periodic tasks to predict the non-periodic task's actual 
duration. Thus, the feasibility of a particular non-periodic task is determined by the equation; 

V,er. + TT^ ^ di (4.2) 

(l-pw) 


where: 


r = set of non-periodic tasks 

di = deadline of task i 

mi = mandatory duration of task i 


4-12 










pu = cuirent periodic utilization 


tn = time now 


This method does have some problems, namely that the periodic utilization is an average value and not a 
accurate reflection of any rare particular duradoiL System testing has to examine this issue to determine the 
validity of this approach. 

In summary, both the periodic and non-periodic schedulers need to determine the feasibility of a 
given task set and assign execution priorities as directed by the current scheduling policy. Scheduling 
policies implemented by the schedulers should include both policies for feasible task sets and importance 
ordered scheduling for infeasible task sets. 

4.7. Architecture Summary 

The architecture as described in this chapter is a vision of how an intelligent real-time system should 
be craistructed. Research into some of the components has already been accompUshed (as is the case of the 
Reasoning Process by the Pilot’s Associate program and outlined in (Chapter 2). To add some validity to the 
approach outlined in this chapter, a feasibility demonstration of the architecture is necessary, and in 
particular, the functions of the Task Manager. This demonstration is described in the next ch^ter. 


4-13 





V. Feasibility Demonstration System 


This chapter discusses in detail how the feasibility demonstration system is implemented. The 
primary focus of the feasibility demonstration is on the development of the Task Manager. As mentioned 
previously, the Task Manager is responsible for guaranteeing real-time performance of the system in 
normal load conditions. In addition, it must respond ^propriately to changing task importances and task 
loads, and guarantee deadlines of a sub-set of tasks in overload situations. This chapter begins by 
discussing some general implementation issues, then gives a brief description of how each of the other 
architecture components is implemented. Following that, the data structures used in the Task Manager are 
examined along with the transitions each task type can make. Finally, the procedures that make up the 
Task Manager are reviewed. 

5.1. General Implementation Issues 

As with any demonstration effort, there are some implementation assumptions. In this effort, those 
assumptions are as follows. First, the number of processes that are running at any one time is unknown. 
This implies that the size of the problem is dynamic and should not be artificially constrained by some 
maximum size limit Dynamism at the implementation level usually means variable-sized data structures. 
In this thesis effort, this translates to linked list structures, at cost of processing time and determinism. 
Arbitrarily deciding up front, the size of the problem would greatly increase the speed of the system, 
essentially reducing a large number of 0(n) linked list operations to 0(1) array operations. Future work 
should look at using predetermined data structure sizes and the poformance issues associated with them. 

Additionally, this thesis effort is unfunded and does not have primary access privileges to the 
computer system the design is implemented upon. What that means is there are always tasks nmning in the 
backgroimd, urtknown to the Task Mattager, that consirme processor time. Thus, any testing of the Task 
Manager's timing characteristics are subject to an urtknown amormt of error. The research has not 
specifically addressed that issue in the scheduling algorithms used in this feasibility demonstration. 
However, the impact of the additional, unknown processor loading is missed deadlines, and missed 
deadlines are important events the system is designed to detect and handle. 


5-1 







5.1.1. Ada Compiler Choice. The choice of an Ada compiler plays a crucial role in this feasibility 
demonstration. Since Ada tasking is a “big” part of the thesis effort, the compiler's support of tasking 
primitives is an important issue. Chapters 3 and 4 expressed the need for dynamic priority assignments and 
any Ada development envirorunent used needed to support them. The feasibility demonstration uses the 
Verdix Ada development envirorunent over Meridian Ada for the following reasons. 

First, Verdix Ada provides tasking primitives that allow direct control of the a task's priorities and 
execution. Verdix provides the procedures Set_Priority, Suspend_Task, and Resume_Task [VERDIX, 
1990]. In addition, Verdix's has implemented the Priority Inheritance Protocol in their Ada run-time 
system. The Priority Inheritance Protocol prevents a major problem with Ada tasking known as priority 
inversion [Broger, 1989]. It is important that these parts are identified here because they are compiler 
specific and not readily transportable to other Ada development environments. 

These specific procedures, Set_Priority, SuspendJIask, and Resume_Task all take the Verdix Ada 
defined Task_ID as input. Each procedure also returns a value that specifies the result of that particular 
operation. In the cases of Suspend_Task and ResumeJIask, the returned values are used to determine 
whether or not a periodic task has missed its deadline, or if a problem exists with a non-periodic task. Also, 
the range of task priorities that are available with the Meridian compiler is 20, while the Verdix compiler 
allows for 100 different priorities and thus a finer prioity resolution. 

Additionally, Verdix Ada is available cm most of the computer systems at AFTT and should continue 
to be in the future. Finally, both CLIPS/Ada and Classic Ada (an object-oriented Ada pre-processor 1 
plarmed to use in developing the Envirorunent Model) successfully compile with the Verdix Ada but not 
with the Meridian Ada compiler [ClassicAda, 1989]. The choice of Verdix Ada thus allows the inclusion 
of existing tools, provides readily transportable code within AFTT, eases the task control problem, and 
allows a greater range of task priorities. For these reascuis, Verdix Ada was chosen as the Ada development 
environment. 

5.1.2. Memory Management Issues and Impacts. Another implementation issue to be addressed in 
any real-time system is memory management. This means two things: first, ensuring that the memory does 
not become fragmented and thereby forcing a garbage collection problem; and second, ensuring that 
available memory is used efficiently. For these reasons, all the data structures used in this feasibility 
demonstration employ their own memory management. This means that once an item of that type has been 


5-2 





allocated from system memory, it is retained and reused by the data structure as needed and never returned 
to the system's he^^) space. 

The issue of monory management has a profound affect upon how tasks are used, created, and 
deleted, presenting a significant diallenge in the development of this feasibility demonstration. The actual 
work of the system is assumed to be performed by the periodic, singular, and any-time tasks (see Chapt^ 
3). In Ada, any task object that is declared within the scope of another task only gives iq> its memory when 
the task that declares it terminates [AdaLRM, 1983:9] [Cohen, 1986:699-708]. Additionally, the language 
specifically prevents a user-directed deallocation of the task's memory space [AdaLRM, 1983:13.10.1.8]. 
Since the Task Manager is where all tasks are created and deleted, no task returns the memory it consumes 
until the Task Manager terminates, and since the Task Manager never terminates, no memory from a task 
object is ever returned to the system. Given that a substantial number of tasks may be created during the 
execution of this Intelligent Real-Time system, this could lead to a significant 'memory leak'. 

The term memory leak is a euphemism used by real-time system designers to describe a situation in 
which a program’s memory is omtinually consumed without ever being replenished. The analogy to a leak 
in a water bucket is clear. In the case of the Task Manager, task objects never return the memory 
consumed, the more task objects that are declared, the more memory has 'leaked' out of the system. 
Eventually, the system consumes all available memory and no additional tasks can be accommodated. 

5.1.3. Dynamic Task Creation and Control. To combat the memory leak problem, a method was 
developed that allowed tasks to be reused. The tasks managed by the Task Manager are divided into three 
types: periodic, singular, and any-time tasks. Each of the three task types has its own Ada task type 
declared for it. Each Ada task type is encapsulated in its own Ada package along with a buffer used to 
communicate with tasks of that type. Each of the Ada packages provides externally visible procedures that 
allow an external task (i.e., the Task Manager) to store items into the buffer, create new tasks of that type, 
and remove items from the buffer. The Ada package specification for each task type additionally exports 
an access type for that task type and a variables record type used to pass information from the Task 
Manager to a specific task or the buffer and vice versa. The method used to do dynamic task creation, 
reuse, and scheduling is a fundamental accomplishment of this thesis research. Figure 5.1 illustrates the 
crxicept and how it is implemented. 


5-3 



Each of the tasks Pi, Si, Ai, etc., shown in Figure 5.1, acts more as a wrapper or shell than a stand¬ 
alone self-contained task. The task shell essentially provides the system with a reusable task that can be 
directed to execute any of the procedures that are contained in that task type's package. As each task type is 
declared or used, it is passed a parameter that specifies what procedure to use. The task type contains a 
case statement for invoking the correct procedure based upon the passed parameter. Note that extending 
this concept to include new or different task types, or additional procedures for a task type, is relatively 
easy should it become necessary. 



Figure 5.1 Package Structure of Tasks 


5-4 

































Each task also must provide at least two task entries called 'Initialize' and 'Change.Variables' that 
accept the variables record defined for that task type. The Initialize entry is used by the externally visible 
procedure Create, to instantiate a new task and provide the Task Manager with information about that task. 
In particular, the Create/Initialize pair provides the Task Manager with the Verdix Ada defined Task.ID, 
and the execution times of the task. The Task.ID is needed to use the Set.Priority, Suspend.Task, and 
Resume.Task procedures and the durations are needed to determine the scheduling of the task. 

The Change.Variables task entry is used by the Task Manager to put a previously used task ‘shell’ 
into a new known initial state. It returns to the Task Manner the new durations of the procedure associated 
with the task shell. Additionally, after either of these entries/procedures is called, the task suspends itself 
using the Verdix Ada Suspend.Task procedure. Note that all task shells not currently in use are assumed to 
be in a 'suspended' state by the scheduler. 

The reason for using the Suspend.Task procedure may not be obvious. Ada has a delay statement 
that can be used to put a task to sleep until some specified duration has elapsed. The language standard 
guarantees that the minimum time the task sleeps can be specified by the duration given to the delay 
statement, but it does not specify the maximum amount of time the delay statement may consume. For 
real-time systems, this is an unacceptable situation. Ensuring some exact period for a periodic task means 
not relying upon the delay statement. Usually, a clock that generates an interrupt is used to ensure exact 
durations. However, in this thesis, task execution and suspension is explicitly controlled using the Verdix 
supplied Suspend.Task and Resume.Task procedures and a task dispatcher. The only place that a delay 
statement is used to ensure task timings is in the task dispatcher. This was a deliberate decision to ensure 
that the addition of an interrupt driven clock should be simple for any future work. 

The existence of each of the Task Variables buffers provides the Task Manager an easy method to 
control each task. When each task starts its execution cycle, it checks in its variables buffer for control 
inputs from the Task Manager. The control inputs ccmsist of a display flag, an execution mode, a procedure 
identifier, and an Envirorunent Model object identifier. Any-time task types also include a boolean variable 
that tells the task whether or not it should continue executing, if it is executing its optional part. The 
display flag is a debugging aid that tells the task shell whether or not to print out its execution statistics. 
The execution mode is either mandatory or optional, and the procedure identifier and Environment Model 
object identifier tell the task shell which procedure to execute and which piece of data in the Environment 
Model to use. 


5-5 



5.1.4. Top Level Priority Assignments. The methods used to assign priorities to the different task 
types is built upon a niunber of underlying assumptions, some previously stated, others not. Before we 
begin the discussion of priority assignments though, the difference between priority and importance needs 
reiterating. The priority of a task determines the execution order of the task and the importance of a task 
has to do with its global relevance to the problem at hand. 

The basic assumption that the system is at times overloaded which implies that at times the priority 
of a task must be driven by its importance. Conversely, using the rate monotonic algorithm for periodic 
tasks implies that when the system is not overloaded, for periodic tasks, importance is almost meaningless 
to the scheduler. The problem faced in the implementation then is under what conditions and how should 
different priority schemes be used, and what are some practical schemes to use. 

Since the feasibility demonstration system is being implemented on a single processor system, the 
priorities must also be used to simulate concurrency of the other architecture components. This causes 
some problems when deciding upon the priorities to assign to the Reasoning Process, I/O Process, 
Environment Model, System Model, and Task Manager. If the Reasoning Process is given a priority higher 
than that of the periodic tasks, the assumptions used in the rate monotonic theory no longer hold. Since the 
behavior of the Reasoning Process is not periodic, it would not be preempted by a periodic task. The result 
is an inability to schedule periodic tasks to meet their deadlines. Additionally, any non-periodic task with a 
priority higher than the periodic tasks would result in same problem. The I/O Process on the other hand 
should execute at a relatively high priority to ensure rapid response to external events. 

The compromise solution settled upon is shown in Figure 5.2. Of the 100 task priorities available, 
eighty are allotted for periodic tasks (89-10) and four are allotted for non-periodic tasks (9-6). The 
remaining twenty priorities are used for the I/O Process, the Task Manager, emergency tasks, non- 
schedulable periodic tasks, and discarded non-periodic tasks. A discarded task is one that is no longer 
doing useful work because it has missed its deadline. The possible task states and their meanings are 
discussed in detail later in this chapter. 

The I/O Process is assigned the highest priority (99) and the Task Manager the second highest (98). 
Priorities (97-90) are reserved for emergency tasks. The allowance for emergency tasks gives the 
Reasoning Process the ability to ensure that a specific task runs regardless of the current workload. The 
Reasoning Process is assigned a static priority of five (5), to prevent it from interfering with the scheduling 


5-6 





and execution of both the periodic and non-periodic tasks. The impact of assigning the Reasoning Process 
such a relatively low priority must be examined during testing. The Environment Model, System Model, 
and Task Variables Buffer tasks are not assigned priorities since they basicnlly act as passive tasks, only 
consuming CPU time when called. The implementation and use of priority inheritance protocols by the 
Verdix Ada compiler ensures that these tasks do not block high priority tasks from executing. 



Normal 



Importance 

Ordered 



“ I/O Process - 

-Task Manager- 

Emergency Tasks | 


Penodic 

Tasks 


Scheduleable 
Periodic Tasks 


Non-Penodic 
_ Preempted . 
Non-Periodic 


Reasoning Process 

Non-Schedulable 
Periodic Tasks 


Discarded Tasks 



iiSSSSlHi 


Figure 5.2 Normal and Importance Ordered Priority Ranges 


1 he Importance Ordered side in Figure 5.2 shows the result of overload (i.e., the existence of tasks 
that can not be scheduled to guarantee completion by their deadlines) on the priorities assigned to the tasks 
in the system. The effect of overload on task priorities is primarily restricted to periodic tasks. Periodic 
tasks, whose importance is not high enough to put them in with the tasks scheduled rate monotonically, are 
assigned the bottom priority in the system. They only execute when nothing else can. Note that it may 


5-7 





















happen that there are not enough periodic tasks to use all of the periodic priorities. In this situation, those 
priority values are not used. 

Now that some of the general implementation issues have been addressed, the specifics of each 
component’s implementation will be discussed. Figure S.3 is used to facilitate the discussion. Note, 
however, that the focus of the feasibility demonstration is on the Task Manager and thus the other 
components, with the exception of the Reasoning Process, are simply acting as place holders. Their 
inclusion is simply to emphasize the requirement for their existence in a complete system and force the 
feasibility demonstration system to address them, at least in a limited way. 

5.2. System and Environment Model 

As mentioned previously, both the System Model and Environment Model exist only as place 
holders. Each cf these models are implemented as Ada tasks that are passive in nature, meaning they only 
perform work when an entry call is made to them. These two IRTS components require significant 
additional work to fully implement the architecture as outlined in this thesis. However, they are not the 
primary focus of the feasibility demonstration and thus little effort was expended in developing them or 
addressing issues in their implementation. 

53. HO Process 

For the purposes of the feasibility demonstration, the I/O process simply sends intermittent event 
messages to the Reasoning Process’s Event_Message entry. There is no significance to the messages. 
They are simply used to simulate the arrival of I/O and generate an appropriate response by the Reasoning 
Process. For demonstration purposes, this approach suffices. 

5.4. Reasoning Process Implementation 

The Reasoning Process used in this feasibility demonstration is the expert system tool as 
implemented by CLIPS/Ada. The purpose of this discussion is not to explain the irmcr workings of 
CLIPS/Ada but rather the incorporation of it into the feasibility demonstration. Since the focus is not on 
the use of an expert system shell, for a detailed description of CLIPS/Ada, refer to the CLIPS user’s 


5-8 







manuals [CUPS-Ada, 1991] [CUPSRefMan, 1991a] [CUPSRefMan, 1991b] [CLIPSRefMan, 1991c] and 
[CLIPSUG, 1991]. 


The basic Ada Task structure of the Reasoning Process is shown in Figure 5.3. The Reasoning 
Process Ada package consists of an Ada task to encapsulate the entire process and two CLIPS/Ada defined 
packages, Embedded_CLIPS and User_Functions. Embedded_CLIPS is the CLIPS/Ada inference engine, 
modified as the name implies to be embedded in other applications instead of being a standalone 
application. The User_Functions package is a user-defmed package that contains the interface between 
CLIPS/Ada and any user-defined functions. 

The user-defined functions developed and coded for this feasibility demonstratim allow CLIPS/Ada 
to add, modify, and remove tasks in addition to changing the budgeted periodic utilization. Each of these 
functions is callable from either the right-hand-side or left-hand-side of rules defined in the CLIPS/Ada rule 
format Specific parameters needed to use these functions can be found in Appendix A and is not discussed 
here. What is discussed are some problems that had to be overcome to write those user defined functicms. 

The first problem involved data types available in CLIPS/Ada and the conversion firom external d ata 
types to CLIPS/Ada data types. First CLIPS/Ada explicitly defines what it uses for numbers as either 
CLIPS_Reals or CLIPS_Integers. This forces the use of Ada explicit type conversions to communicate 
numbers between CUPS/Ada and external tasks. Second, a method of referring to a particular task needed 
to be developed since CLIPS/Ada can not use the data type for Task Control Blocks. The approach taken 
was to allow CLIPS/Ada to refer to tasks by their Task_ID using the Ada unchecked conversion procedure. 
This approach required the Task Manager to search through the currently instantiated tasks to match a 
Task_ID with a Task_Control_Block, potentially adding search time to any operation directed by the 
Reasoiting Process. 

The Reasoning Process task that encapsulates CLIPS/Ada provides the interfaces between the other 
IRTS components and CLIPS/Ada. Currently, those interfaces consist of 1) an entry to assert a fact into 
CLIPS/Ada (supplied as a string), 2) an entry to receive Task Manager status updates from the Task 
Manager, 3) an iititialize entry to load the rules used by CLIPS/Ada, 4) an ^try to signal when a task has 
missed its deadline, 5) an entry used by the I/O Process to signal an external event, and 6) an entry to signal 
that an infeasible task creatitm request has been made. The I/O Process event message entry is used by the 
VO Process to insert facts into CLIPS/Ada that stimulate CLIPS/Ada to add, remove, or modify tasks. 


5-9 




5-10 


Figoie 5.3. IRTS Ada Task Stractun Diagram 












































The Reasoning Process internal task structure is arranged similarly to the system outlined in section 
2.3.3. Although not implemented in the feasibility demonstration, almost all of the agenda management 
methods as discussed in section 2.3.3 could be easily implemented. The implementation as it stands now 
first checks for any entry calls to the Reasoning Process and performs any that exist. Next, one rule is 
allowed to fire and the cycle then repeats. Future efforts should look at fully implementing the agenda 
management methods developed under the Pilot’s Associate program to improve and control the 
performance of the Reasoning Process [IDodhiawala, 1988] [Lambert, 1991] [Lambert, 1990]. 

5 J. Task Manager Implementation Details 

In this section the Task Manager is described in detail. The description begins with the data 
structures used by the Task Manager. Next, periodic, singular, or any-time task state diagrams are 
examined along with the events that trigger a transition from one state to another. Following that, the 
assignment of periodic priorities is discussed. The Task Manager implementation discussion is concluded 
with an explanation of each major procedure it contains. 

55.1. Task Manager Data Structures. In order to understand how the Task Manager works, it is 
important to outline its major data structures. The data structures consist primarily of priority deques 
[Booch, 1986] and a record structure called a Task Control Block. A priority deque is a queue in which 
items can be added or removed from either the front or the rear of the queue. In addition, the items in the 
queue are arranged by some user defmed 'priority'. When a new item is added to the queue, it is placed in 
priority order; a new item with the same priority as an existing item can either be placed in front of or 
behind the existing item. This equal priority wdering choice allows one to implement either LIFO or FIFO 
ordering for items of equal priority. All items of equal priority added to a queue are added in FIFO order 
(i.e., behind items of equal priority). 

There are six priority deques that are the most important data structures used in the Task Manager. 
They are as follows: 

• Ready Queue - A deque of tasks that are ready to execute but not yet scheduled, arranged so 
that the task with the earlier start times are ahead of the tasks with later start times. 


5-11 







• Latest Start J^ime Queue - A deque of singular and any-time tasks that are currently 
executing, arranged such that tasks with earlier latest start times are ahead of tasks with later 
latest start times. 

• Deadline Queue - A deque of singular and any-time tasks that are currently executing, 
arranged such that the tasks with the earlio- deadlines are ahead of tasks with later deadlines. 

• Tasks by Period - A deque of only periodic tasks that are arranged with tasks of shorter 
periods ahead of tasks with Irniger periods. 

• Periodic Importance Queue - A deque of only periodic tasks, arranged so that tasks with a 
higher importance (lower number) are ahead of tasks with lower importances. 

• Task JD Queue - A deque of all tasks arranged by an integer representation of their Task ID. 
This deque is used to find the task control block (described below) for a given Task ID. 

There is one additional priority deque that is used for scheduling periodic tasks. It is a temporary 
deque used when the system is overloaded. The algorithm for handling this situation involves searching 
through each task in the Periodic_Importance_Queue and determining which tasks can be feasibly 
scheduled. Those that can are added to the period-ordered temporary deque. Once all the important tasks 
that can be scheduled are found, the temporary deque is used to assign them priorities. 

A Task Ccxitrol Block is an Ada variant record type that holds the information about each task that is 
needed by the Task Manager. Figure 5.4 shows the Ada type declaration for the Task Control Block. 
There are currently three variants of the recwd structure, one fw each of the task types (periodic, singular, 
and any-time). A variant record was used because each of the task types has different variables associated 
with its scheduling and execution, but all the tasks have some common features. The common items 
consist of the task’s type, Task_ID, integer Task_ID, mandatory duration, optional duration, importance, 
priority, starting time, latest starting time, time remaining, deadline, period and status. 

The different task types do not use all the common parts of a TCB in the same way. Periodic tasks 
use the deadline value as a stop time while ncm-periodic tasks have a period of zero. The variant part of a 
Task_Controi_Block contains a pointer to the task type it is controlling and another record structure that 
holds the task specific variables needed by that task. Note in both cases these are data types exported by 


5-12 







the packaged specifications for the any-time, periodic, and singular tasks. With a basic understanding of 
the data structures used, the task states can be discussed. 


5.52. Task States and State Transitions. Although there are three types of tasks (periodic, any-time, 
and singular), the scheduler handles the tasks as either periodic or non-periodic. All periodic tasks are 
scheduled rate monotonically while non-periodic tasks are scheduled with a modified earliest deadline first 
algorithm. This section describes the states each task type goes through and explain what events cause the 
transiticHi from one state to another. For this discussion, both the any-time and singular task types are under 
the non-periodic task heading. 


type Task Control Block Type ( Kind : Task Kind Type := PERIODIC ) 

is record 


Deadline 

Calendar.Time ; 

Iirportance 

Integer ; 

Latest Start Time 

Calendar.Time ; 

Mandatory Duration 

Duration ; 

Next 

Task Control Block Ptr ; 

Optional Duration 

Duration ; 

Period 

Duration := 0.0 ; 

Priority 

System.Priority ; 

Start Time 

Calendar.Time ; 

Started At 

Calendar.Time ; 

Status 

Status Type ; 

Task Kind 

Global Data Types.Task Kind Type ; 

Task ID 

System.Task ID ; 

Time Remaining 

Duration ; 

Integer Task ID 

Integer ; 

— A case is required for every kind of task that you wish 

— to be able to create. 

case Kind is 


when Global Data Types.Periodic => 

Periodic_Variables : Periodic Variables Type ; 

The Periodic Task Ptr : Periodic Task Ptr ; 

when Global Data Types.Any Time => 

Any_Time_Variables : Any_Time Variables Type ; 

The Any Time Task Ptr : Any Time Task Ptr ; 

when Global Data Types.Singular => 

Singular_Variables : Singular_Variables Type ; 

The Singular Task Ptr : Singular Task Ptr ; 

end case ; 


end record ; 



Figure 5.4 Task Control Block Ada Record Type Declaration 


5-13 













5.52.1. Periodic Task State Transitions. A periodic task can be in one of four states, 
READY, EXECUTING, SUSPENDED, or COMPLETED. A periodic task in the READY state is ready to 
execute, but its start time has not yet been reached. An EXECUTING periodic task has passed its start time 
and is currently executing. A SUSPENDED periodic task is an executing task that has completed its woik 
for that period and has called the Suspend_Task procedure. A COMPLETED periodic task has passed its 
deadline or more correctly, its stop time, and is now available for reuse. Figure 5.5 shows each state and 
labels the transition arcs from one state to another. The following discussion refers to Figure 5.5. 

Event El occurs when a periodic task is added to the system and there are no available periodic task 
‘shells’. This event causes the Task Manager to use the Ada “new” command to allocate a new TCB for a 
periodic task. The task’s variables are set and the task is inserted into the Task_ID_Queue, Ready_Queue, 
Tasks_By_Period_Queue, and Periodic_Importance_Queue. The task’s status is then changed to READY. 
Note that all periodic tasks not currently executing are in the suspended state. 

Event E2 occurs when the task first makes it to the front of the Ready_Queue. When the task 
reaches the front of the Ready_Queue and its start time equals the current time, it is started using the 
Resume_Task procedure and its status changed to EXECUTING. Its next start time is calculated and the 
task’s TCB is reinserted into the Ready_Queue. When the task completes its work for the current period, it 
suspends itself (event E3) and is considered in the SUSPENDED state. When it again makes it to the head 
of the Ready_Queue, it is resumed again (event E4). The cycle continues until either the task is explicitly 
told to stop or its stop time has past, as signaled by event E5. It is during this cycle that periodic task 
missed deadlines are detected and signaled to the Reasoning Process. Again, the ResumeJTask procedure 
detects when the resumed task was not suspended and generates an exception. 

Once event E5 has occurred, the task is placed on the free task list for periodic tasks. Note that it is 
possible for a task to transition from the READY state to the COMPLETED state (event E5). This 
transition occurs when the Task Manager is told to remove a task and the task has not yet started executing. 
Also, since each task is in a known internal state when placed in the COMPLETED state, it can be reused 
without any difficulty (event E6). 


5-14 








Figure 5.5 Periodic Task State Transition IMagram 

5J.22. Non-Periodic Task State Transitions. Non-periodic tasks have seven possible states 
because the scheduling of non-periodic tasks is more difficult The non-periodic task state transition 
diagram is shown in Figure 5.6. In the figure, the gray lines represent the normal, non-overloaded, non¬ 
periodic task state transitions. Event El occurs when there are no any-fime or singular task ‘shells' 
available and one is needed. Once the new task has been allocated, its variables are set its status changed 
to READY, and it is placed in both the Ready_Queue and the Task_ID_Queue. Note that a READY non¬ 
periodic task is not in the Latest_Start_Time_Queue or the Deadline_Queue. 

From the READY state, there are two possible transitions, event E2 and event E6. Both events occur 
when the task reaches the head of the Ready_Queue. If the task has a deadline that is earlier than the 
currently executing non-periodic task, then the task is placed in the EXECUTING_MANDATORY state 
and is given the highest non-periodic priority (event E2). Additionally, what was the currently executing 
task is preempted and depending on its state, it is either placed in the PREEMPTED_MANDATORY 
(event E8) or PREEMPTED_OPTIONAL state (event ElO). In addition, the preempted task’s remaining 
computation time and latest start time are calculated, and the task is inserted in both the 
LatesLStart.Time_(^eue and the Deadline_Queue. If the task coming from the Ready_Queue does not 
have the earliest deadline (i.e., is not at the head of the Deadline_(^eue), then its state is changed to 
PREEMPTED_MANDATORY, its time remaining and latest start time are calculated, and it is inserted in 
both the Latest_Stait_Time_(2ueue and the Deadline_(2ueue (event E6). 


5-15 








Figure 5.6 Non-Periodic Task State Transition Diagram 

Note that an EXECUTING.MANDATORY or EXECUTING.OPTIONAL task is not in either the 
Latest_Start_Time_Queue or the Deadline_Queue. The reason is that in the normal case, the task has been 
scheduled to execute because it has the earliest deadline and, therefore, it is assumed it executes to 
completion. If it could not have completed before its deadline (i.e., its remaining computation time was 
more than the time remaining until its deadline) then a missed deadline would have been signaled for the 
task and the task’s state changed to DISCARDED (event E9). 

A task that is in the EXECUTING_MANDATORY state can either be preempted (event E8), or 
complete its mandatory part and be scheduled to execute its optional part (event E3), or be DISCARDED 
(event E9). Event E8 occurs either in the case outlined above where a newly “eligible to execute” task has 
an earlier deadline, or the latest start time for a task has occurred and the EXECL)TING_MANDATORY 


5-16 






task either has slack time (i.e., its execution time remaining is less than the time remaining until its 
deadline) or the task at the head of the Latest_Start_Time_Queue has not completed its mandatory part (i.e., 
is in the PREEMPTED_MANDATORY state) and has a higher importance value than the current 
EXECUTING_MANDATORY task. 

If the preempted task is in the EXECUTING_MANDATORY state, and does not have any slack 
time, then it misses its deadline (event E9). In this case, the task is placed in the DISCARDED state and its 
priority set to the lowest available. Note that the task cannot immediately be placed back into the free list 
because it is not in a known state. It must be allowed to finish its current work, but not alter either the state 
of shared data before it can be placed in the COMPLETED state (event E13) and in the free task Ust. Thus, 
in addition to changing its state, the preempted task's continue flag is also set to false. 

If a preempted task is in the EXECUTING_OPriONAL state, and the task does not have any slack 
time, then the task will miss its optional part deadline (event E9). This condition is different then missing 
the deadline for its mandatory part in that there is still an answer available, only the quality of the answer is 
affected. Thus, this case is not signaled to the Reasoning Process as a missed deadline. Note, however, 
that the task is still discarded and only marked as COMPLETED when it signals completion (event El3). 

When a task that completes its mandatory part, either whUe in the PREEMPTED_MANDATORY or 
EXEClJTING_MANDATORY state, new values for both its latest start time and computation time 
remaining is calculated. Next, the task's TCB is placed in both the Latest_Start_Time_(Jueue and the 
Deadline_(^eue, and the task's state changed to PREEMPTED_OPTIONAL (event ElO). If the task is at 
the head of the Deadline_(Jueue then its state will be changed to EXECUTING_OFTIONAL and it will 
begin executing its optional part (event E12). 

The values used in the calculation of the remaining computation time and the latest start time depend 
upon which state the task is transitioning from. When a task transitions from the READY state to either the 
EXECUTING_MANDATORY or PREEMPTED_MANDATORY states (events E2 or E6), the value of 
the task's mandatory duration is used to determine its latest start time and the iiritial value of the 
computation time remaining. When the task transitions from either the EXECUTING_MANDATORY or 
PREEMPTED_MANDATORY state to the PREEMPTED_OPTIONAL state (event ElO), the task's 
optiorud duration is used. 


5-17 






The effect of a task completing its optional part depends upon the type of task. A singular task that 
completes its optional part from either the EXECirTING_OPT10NAL or PREEMPTED_OPTIONAL state 
(event E4), is placed in the free task list and its state changed to COMPLETED (because it is possible for a 
task in the EXECUTING_OPTIONAL state to block for some external process, it is possible for a 
PREEMPTED_OPTIONAL to execute and complete). Note that the task itself will call the Suspend_Task 
procedure after it signals it is complete. When an any-time task completes its optional part, if there is 
enough time to complete another complete cycle through an optional part, its computation time and latest 
start time are adjusted and the task’s TCB is reinserted into the Latest_StaTt_Time_Queue (event E14). 
This process is repeated until the any-time task’s deadline arrives. 

5J.3. Periodic Task Priority Assignments. A number of different methods of assigning periodic 
priorities were investigated during the development of the feasibility demonstration. The investigation 
focused the problem of assigning priorities when there are mwe tasks than priorities. Appendix B contains 
a description of the various methods developed and the results of testing each method. Note that when 
there are fewer tasks than periodic priorities, it is a simple matter to cycle through the 
Tasks_By_Period_<)ueue to assign priorities. 

The investigation concluded that for the feasibility demonstration system, the problem would be 
solved by simply dividing the number of periodic tasks by the number of periodic priorities. The result of 
that division is then used as the number of tasks to assign to each priority. Again the 
Tasks_By_Period_Queue is cycled through, this time assigning the appropriate number of tasks the same 
priority before moving on to the next priority. 

55.4. Task Manager Entry Call Descriptions. The Task Manager is implemented as an Ada task 
with five entry calls. The entry calls are Add_Task, Modify_Task, Remove_Task, 
Change_Periodic_Utilization, and Task_Complete. The task entries Add_Task, Modify_Task, 
Remove_Task, and Change_Periodic_UtiUzation are used by the Reasoning Process to control the current 
task set The Task__Complete entry is used by the any-time and singular tasks to signal the Task Manager 
that they have completed executing. In addition, the Ada task is set up with a delay statement that 
essentially places the Task Manager in an idle state when it is not in use. The following sections describe 
the processing that takes place whenever a call is made to any of the task entries and explains how the Ada 
select statement with a delay alternative is used in the Task Manager. 


5-18 








5.5.4.}. Add Task Entry Call. Task creation is done in response to a request from the 
Reasoning Process to instantiate a new task. The process varies depending upon the type of task that 
requires creation, but the basic process is; getting a Task Control Block, filling in the appropriate values, 
determining the feasibility of the task, adding the new task to the appropriate priority queue, scheduling the 
task, and finally sending the control variables to the task's control buffer. 

Getting a new Task Control Block (TCB) is accomplished by the procedure GetJTCB. Because the 
system reuses task shells it first checks the free task list to see if there are any tasks of the required type 
available for use. If there are, then the TCB for an unused task shell is modified to reflect the new 
parameters as passed to the Task Manager. Since task starting and stopping is explicitly controlled by the 
Task Manager, any task not currently in use (i.e., stored in the free task list) is in the suspended state. 
Therefore, the Resume_Task procedure is called and a call to the task's Change_Variables entry is made. 
The call to the task's Change_Variables entry returns to the Task_Manager the task's durations and the 
values are stored in the task's TCB. If there are no task shells of the right type available on the free task 
list, then a new task of the appropriate type is instantiated and a similar call to the Change_Variables entry 
is made. Note the task itself has again been placed in the suspended state after it responds to the 
Change_Variables entry call. 

Once the task’s durations are returned to the Task Manager, a call to test the feasibility of the new 
task is made. The feasibility check for a periodic task consists of detennining if the task's period is greater 
than the task’s combined mandatory and optional durations and if at least its mandatory part can be 
executed without exceeding the current budgeted periodic utilization. The feasibility check for a non¬ 
periodic task consists of determining whether the task can complete its mandatory part before its deadline. 
If the task is feasible, then it is placed into the Ready_Queue and the Reasoning Process is notified of the 
new status of the task set 

Deciding what to do with a new task that is infeasible is an area where future work is required. The 
chosen method is to make a distinction between periodic and non-periodic tasks. If a periodic task is 
infeasible (i.e., the task set, which includes the new task, utilization exceeds the amount available), it is 
added to the Ready_Queue anyway. The assumption is that at some future time there may be enough 
processor time available to execute the task. Non-periodic infeasible tasks are simply removed from the 
system altogether. The assumption made here is that the deadline is going to be mis.sed. so the Reasoning 
Process has to adjust its request. 


5-19 



If the new task is a periodic task, then the parameters used for assigning periodic priorities are 
updated. In particular, if there are more periodic tasks than periodic priorities, then the ranges of periods 
assigned to each priority is updated. If not, then there is no need to perform this operation and some time is 
saved by not doing it. The periodic task's TCB is then added to the Ready_Queue, Task_By_Period, and 
the Periodic_Importance_Queue. If the new task is not periodic, then the number of active non-periodic 
tasks is incremented by one and the task's TCB is added to the Ready_Queue. 

New periodic tasks are also assigned an execution priority when they are added to the system. In 
addition, periodic tasks are assigned a new execution priority whenever a periodic task is modified, 
removed, or the budgeted periodic utilization is changed. The steps in assigning periodic priorities are as 
follows: 


1) If the current periodic utiUzation is below the utilization required for running all tasks with 
their optional parts, then instruct each task to execute both its mandatory and optional parts. 
Assign each task's priority rate monotonically. This condition is called ALL_OPTIONAL 
in the program. 

2) If the current periodic utilization is above the utilization required for running all tasks with 
their optional parts, but below that required for all tasks to execute only their mandatory 
parts, then assign all tasks to execute their mandatory parts and assign each task's priority 
rate monotonically. Then loop through the Periodic_Importance_Queue adding optional 
parts until the utilization equals the required utilization. This condition is known as 
SOME_OPTIONAL in the program. 

3) If the current periodic utilization is above the utilization required for running all tasks with 
their mandatory parts, then loop through the PER10DIC_IMP0RTANCE_QUEUE adding 
mandatory parts until the utilization equals the required utilization. Then assign this subset 
of tasks to execute theii mandatory parts and assign each task's priority rate monotonically. 
This condition is known as SOME_MANDATORY in the program. 

55.4.2. ModifyJTask Entry Call. A task can only be modified in a limited number of ways. 
Only the task’s period, importance, start-time, deadline, or display flag can be changed and only when the 
task is in a certain state. Gianging the task’s procedure identifier is treated as adding another task and is 
not allowed as an external modifying option by the current implementation. With the exception of 


5-20 




changing the display flag, all the changes may involve rescheduling most of the tasks in the system. Table 
5.1 and Table 5.2 show the allowed modify operations for each task type and the potential effects of that 
modification. However, the first operation is always finding the task’s TCB in the Task_ID_Queue. 


Table 5.1 Effects of Modifying Tasks and Periodic Utilization 


Changed Item 

Task Variables 

Reschedule 

Reschedule Non- 


Buffer 

Periodics 

Periodics 

Display Flag 

V 



Deadline 

V 


V 

Importance 

V 

V 

V 

Period 

V 

V 

V 

Start Time 

V 


yl 

Periodic Utilization 

V 


V 


Modifying a periodic task’s period or importance can have time-expensive consequences. It is 
possible for the modification to require communicating a significant number of changes to the periexlic 
task’s variables buffer. For example, changing a task’s period enough to change the periodic condition 
from ALL_OPTIONAL to SOME_MANDATORY will require each periodic task’s variables to be 
changed. Additionally, since the Display Flag is specific to each task, and changes must be signaled to 
each task, it also requires the task’s variables record stored in the task’s variables record buffer be changed. 

Modifying a non-periodic task is not quite as expensive. The worst case occurs whenever the task 
that is modified has started its execution. In this case, the task is modified and then a reevaluation of which 
task to execute is made. This reevaluation is made by checking both the Latest_Start_Time_Queue and the 
Deadline_Queue and executing the ^propriate task. 


5-21 
































Table 5.2 Allowed Modify Operations by Task Type and Stale 


Task Type 

State 

Allowed to Modify 

Actions Taken 

PERIODIC 

READY 

PERIOD 

Recalciilate the Utilizations 

Adjust the Tasks by Period Queue 
Reassign the Periodic Priorities 



STARTJTIME 

Adjust the Start Time Ordered Queue 



DEADLINE 

No Action Required 



IMPORTANCE 

Adjust the Importance Ordered Queue 


EXECUTING 

PERIOD 

Recalculate the Utilizations 

Adjust the Tasks by Period Queue 
Reassign the Periodic Priorities 



DEADLINE 

No Action Required 



IMPORTANCE 

Adjust the Importance Ordered Queue 
Recalculate the Utilizations 

Reassign the Periodic Priorities 


COMPLETED 

NONE 

Error Condition 

ANY-TME 

SINGULAR 

READY 

DEADLINE 

No Action Required 



IMPORTANCE 

No Action Required 



START.TIME 

Adjust the Start Time Ordered Queue 


EXECUTING_MAN 

DEADLINE 

Stop Current Task 



IMPORTANCE 

Place in LST and Deadline Queues 


EXECUTING.OPT 

DEADLINE 

Pick new Current Ta.sk 



IMPORTANCE 



PREEMPTED_MAN 

DEADLINE 




IMPORTANCE 



PREEMPTED_OPT 

DEADLINE 




IMPORTANCE 



DISCARDED 

None 

Error Condition 


COMPLETI'D 

None 

lirror Condition 


5-22 






























































55.4.3. Remove Task Entry Call. The actions taken when a task is removed depend upon the 
task type and the task’s current state. In any case, however, the Task_ID_Queue must first be searched to 
locate the task’s TCB. For a periodic task, the removal process is as follows: 

1) Remove the task from the Tasks_by_Period, Periodic_Importance_Queue, and Ready_Queue. 

2) Adjust the values of the mandatory utilization, optional utilization, and required utilization 
based upon the task’s current execution mode. 

3) Change the task’s state to COMPLETED and place the TCB on the free task list. 

4) Reschedule the remaining periodic and non-periodic tasks. 

Note that there is no communication with the periodic task itself. This is possible because each task 
suspends itself after it has performed its work and, in the worst case, the task terminates after the current 
execution cycle it is performing. Allowing the periodic task to complete its cycle also ensures that the task, 
and the data it is manipulating are in known states. 

Removing a non-periodic task is only slightly more complicated, mainly because direct 
communication with the task may be necessary. The procedure is as follows: 

1) If the task’s state is READY, then it has not started executing yet, so: 

a) Remove the task from the Ready_Queue. 

b) Change the task’s state to COMPLETED and place the TCB on the free task list. 

2) If the task’s state is EXECUTING_MANDATORY, EXECUTING_OPTIONAL, 
PREEMPTED_OPTIONAL, or PREEMPTED_MANDATORY, then it has started executing, 
so: 

a) If the task’s state is PREEMPTED_MANDATORY or PREEMFrED_OPTIONAL. then 
remove the task from the Deadline_Queue and Latest_Start_Time_Queue. Otherwise, the 
task is not in either queue. 


.'5-23 







b) Change the task’s continue flag to FALSE and send the new value to the task's variables 
buffer. Also change the task’s state to DISCARDED. 

c) If the task’s state was EXECUTING_MANDATORY or EXECUTING_OPTIONAL, then 
make the task at the head of the Deadline_Queue the currently executing task. 

5.54.4. Change Periodic Utilization Entry Call. Because the budgeted periodic utilization 
value is used to schedule both periodic and non-periodic tasks, changing the budgeted periodic utilization 
can be the most expensive entry call. Whenever the budgeted periodic utilization is changed, all periodic 
tasks priorities are reassigned. This may require conununicating execution mode changes to a large number 
of periodic tasks. 

Non-periodic tasks use the budgeted periodic utilization when calculating their execution times. 
Once the new budgeted periodic utilization is set, the latest start time and time remaining for every non¬ 
periodic task is recalculated. However, since the effect is the same on all non-periodic tasks (i.e., they are 
each changed by the same factor) the current scheduling method is continued. 

5.5.4.5. Task Complete Entry Call. The Task_Complete entry call is used by the non¬ 
periodic tasks to signal the Task Manager that they have completed execution of their assigned part 
(mandatcny or optional). Again, the effect of the entry call depends upon the status of the task that calls the 
entry. The effect of the call for the different task state’s are as follows: 

1) If the calling task’s state is DISCARDED, then the task’s TCB is placed on the free task list and 
no other action is required. 

2) If the calling task’s state is EXECUTING_MANDATORY or PREEMPrED_MANDATORY, 
then the task’s latest start time and time remaining is recalculated using the task’s optional 
duration and the task is reinserted into the Latest_Start_Time_Queue and Deadline_Queue. The 
task’s state is changed to PREEMPTED_OPTIONAL. If the task’s state was 
EXECUTING_MANDATORY then a new non-periodic task is executed. 

3) If the calling task’s state is EXECUTING.OPTIONAI. or PREEMPTED.OPTIONAL and the 
task is a singular task, then the task’s state is changed to COMPLETED and its TCB is placed 


5-24 








on the free task list. If the task’s state was EXECUTING_OPTIONAL, then a new non-periodic 

task is executed. 

5.5.4.6. Task Dispatcher. The goal of the Task Dispatcher is to implement the schedule. It 
does this by starting tasks from the Ready_Queue. Tasks are started using the Resume_Task procedure. 
Additionally, the dispatcher will delay the Task Manager until the next scheduled action is to occur. This 
delay statement ensures that other tasks are given processor time if needed. The dispatcher removes tasks 
from the Ready_Queue and operates on them as follows: 

1) If the task is a periodic task then; 

a) If its stop time has not been exceeded, the task is resumed, its next start time calculated, and 
it is placed back on the Ready_Queue. 

b) If its stop time has been exceeded, the task’s status is changed to COMPLETED and the 
task’s TCB is placed on the free task list. 

2) If the task is non-periodic then; 

a) If there is no currently executing task, set the task's status to 
EXECUTING_MANDATORY and resume the task. 

b) If there is a currently executing task, and the new task's deadline is before the currently 
executing task’s, preempt the currently executing task, set the new task’s state to 
EXEClJTING_MANDATORY and resume the new task. 

c) If there is a currently executing task, and the new task’s deadline is after the currently 
executing task's, calculate the new task’s latest start time and time remaining, pl^e the task 
in the Latest_Start_Time_Queue and Deadline_Queue, and change the new task’s state to 
PREEMPTED.MANDATORY. 

Once all the tasks in the Ready_Queue that need to be started have been started, the time until the 
next scheduling event is calculated. This time is the lesser of the first time in the 
Latest_Start_Time_Queue, Deadline_Queue, or Ready_Queue. The delay is then used to ‘sleep’ the Task 
Manager until that delay expires or an entry call to the Task Manager is made. 


5-25 








5.6. Implementation Summary 


This chapter has spelled out the important details of the feasibility demonstration system. It has 
discussed the compiler choice, memory management issues, task states, priority assignments, and 
scheduling. The implementation handles both periodic and non-periodic tasks, detects missed deadlines 
and overload situations, and responds to those conditions as required. In addition, it provides for the 
dynamic creation and control of Ada tasks. These mechanisms provide “hooks” needed by the Reasoning 
Process to specify the cuirent task set and influence its run-time scheduling. These c^abilities are crucial 
to managing dynamic, real-time, periodic and non-periodic task scheduling. 

The following chapter presents the results of testing done to confirm the operation of the developed 
system and thus, the feasibility of the developed architecture. The code developed for the demonstration 
system is included in Appendix A. 


5-26 



VI. Results and Analysis 


Since accurate tuning analysis is both impractical and unwarranted at this stage (because the design 
is implemented upon a multi-user UNIX platform), the approach used to demonstrate feasibility is more an 
existence proof of desired c!g)ability. In particular, the architecture includes, and this investigation is 
focused on, a Task Manager that dynamically creates, schedules, and executes the real-time tasks of an 
ERTS. Additionally, the architecture specifies that the Task Manager receives commands from the 
Reasoning Process dictating which tasks are to be created, modified, or removed. In addition, the Task 
Manager accepts some control inputs about how they should be scheduled. The following sections discuss 
the results of csqiability tests beginning with an assessment of the overall architecture feasibility. Next, the 
system’s ability to dynamically create and control Ada tasks is addressed Finally, the particular scheduling 
policies discussed in previous chapters are examined 

6.1. Architecture Feasibility 

The question to be addressed is, “Does the feasibility demonstration lend one to believe that the 
architecture as outlined in Chapter 4 is viable?” The answer, from testing of the system’s performance to 
date is, “yes, with some modifications”. In particular, tests indicate that the current CLIPS/Ada based 
Reasoning Process executes too slowly. The reasons for the inadequate performance of the Reasoning 
Process have not been fully explored, primarily because the majority of the effort was in developing the 
Task Manager component of the architecture. 

Figure 6.1 and Figure 6.2 show examples of the Task Manager overhead incurred by periodic and 
non-periodic tasks of different durations. The graphs assume each task uses an existing task shell when 
added, is modified once, and then removed. Figure 6.1 assumes an add task qieratian takes 0.(X)4 seconds, 
a modify operation takes 0.(X)1 seconds, and a remove operation takes 0.001 seconds. Similarly, Figure 6,2 
assumes an add task operation takes 0.(X)4 seconds, a modify operation takes 0.003 seconds, and a remove 
operation takes 0.001 seconds. The times are derived from testing results contained in Appendix A. 
Assuming a desired maximum oveihead of 10%, the results indicate the approach is feasible for systems 
whose task durations are about 0.07 seconds or greater. However, two observations are in order. 


6-1 




Percentage of Overhead 


6 o!l o!2 o'3 0.4 0.5 0.6 0.7 0.8 0.9 1 

Task Duration (Seconds) 


Figure 6.1 Example Periodic Task Manager Overhead versus Task Duration 



Figure 6.2 Example Non-Periodic Task Manager Overhead versus Task Duration 


6-2 



















First, because the feasibility denumstradon is currently executing on a single processor machine, and 
there are numerous higher priority tasks executing at any one time (the Reasoning Process priority is 5, 
periodic priorities start at 10 and go to 90), the reasoning process, as implemented, does not receive 
adequate processor time. Two conclusions can be drawn. One is the need for at least one additional 
processor in the system, and the other is a different priority for the Reasoning Process. Raising the priority 
of the Reasoning process in the current implementation is not a practical solution because the execution 
time of the Reasoning Process is unpredictable. This means task deadlines could not be guaranteed if the 
tasks had priorities below the Reasoning Process’s. The better solution is a separate processor for the 
Reasoning Process. Most IRTSs examined in the background research required multiple processors and 
this feasibility demonstration has simply reiterated that requirement 

Second, because of the execution speed difference between the Reasoning Process and the Task 
Manager, a “message buffer” should be used whenever the Task Manager communicates with the 
Reasoning Process. As implemented currently, whenever the Task Manager wishes to communicate 
information to the Reasoning Process, it makes an entry call directly to the Reasoning Process. If the 
Reasoning Process is not ready to accept the entry call, the Task Manager will block. The inclusion of the 
buffer would allow the Task Manager to complete its control actions independent of the Reasoning Process. 
In addition, the Reasoning process could exert mote control over its VO. 

6.2. Dynamic Task Creation and Control 

A major accomplishment of this thesis is the development of an ability to dynamically create and 
control Ada tasks. One of the fundamental assumptions of this thesis is the existence of a plan/goal graph 
or task network for the chosen domain. The mapping of that problem domain structure into a solution 
requires the ability to dynamically create and control real-time tasks. The results of testing the feasibility 
demonstration indicate that the methods outlined in Chapter 5 for just that purpose are feasible. 

Figine 6.3 and Figure 6.4 summarize the testing results contained in Appendix A. Each graph shows 
the minimum time required to: 1) adding a task that requires instantiating a new task shell, 2) adding a task 
that reuses a task shell, 3) modifying a task, and 4) removing a task. The effect of UNIX multiprocessing 
operating system is evident in the fluctuating minimum times. The graphs indicate the design sqrproach is 
feasible for applications whose real-time response requirements are on the order of milliseconds. However, 
testing indicated a potential problem area. 


6-3 







(Seconds) 



Figure 6.3 Summaiy of Periodic Task Control Times 



6-4 


















62.1. Dynamic Task Creation Results. Test results show the time required to add and schedule 
either a periodic or non-periodic task is around 0.004 seconds. Graphs of the results are included in 
Appendix A. The results can be interpreted to mean that the minimum response time for the feasibility 
demonstration is 0.004 seconds. The time to add a task is not the same fw reusing a task or instantiating a 
new one. 

The varying times to add a new task to the system is a problem. Testing results indicate that the 
average time to add a task that reuses a task shell differs from the time to instantiate a new task shell by 
about 0.004 seconds. The results were obtained by making numerous runs which create all new tasks, and 
reuse tasks and averaging together the fastest ten times from each run. The key here is not the exact times 
(as mentioned previously, exact timing numbers are subject to uncontrolled error), but rather the variance 
between the two sets of times. 

The reason for the variance is the extra overhead required to instantiate a new task, however, no 
provisions have been made in the implementation to address it. What this means is that the Reasoning 
Process does not currently have a method to determine how long it will take in terms of overhead to add a 
new task. One solution to the problem is to provide the Reasoning Process with a running count of the 
instantiated but unused task shells. Using this information, the Reasoning Process could adjust its 
calculations of start times and execution times to account for the additional overhead if a new task is 
required. 

A second, and perhaps better approach, is to instantiate a predetermined munber of each type of task 
shell. This approach would allow a number of improvements. First, the variance in task creation times 
would be eliminated. Second, it becomes easier to detect and handle potential memory shortages. If the 
number of instantiated tasks is assumed to be the maximum allowed, an attempt to add a new task that 
would exceed that maximum is easily detected. Once detected, it is then possible to determine which task, 
if any, should be abandoied in favor of the new task. 

6.3. Task Scheduling Evaluation 

The evaluation of scheduling performance has to be looked at only to detect major deficiencies. 
From that point of view, there were two significant problems encountered and one interesting anomaly. 
The first problem dealt with the way missed deadlines were handled, and the second problem dealt with the 


6-5 





way durations for non-periodic tasks were calculated. The interesting anomaly dealt with the ordering of 
periodic tasks with the same periods. 

Originally, when a deadline violation was detected, a message was sent to the Reasoning Process 
signaling the violation. In the case of a non-periodic task, the deadline violation was detected when the 
task’s TCB made it to the head of the Latest_Start_Time_Queue, and the task dispatcher discarded the task. 
For periodic tasks, a missed deadline was detected when the task was instructed to resume for its next 
execution period. For non-periodic tasks, it was reasoned that the Reasoning Process would determine 
whether or not to extend the deadline, cancel the task, or take some other action. The same was thought to 
be the case for periodic tasks. For periodic tasks, this approach turned out to be infeasible. 

The problem stemmed from the method used to insure the periodicity of the periodic tasks; adding 
the task’s period to the last start time rather than the time the task is told to execute. What happens is a 
cascading of missed deadlines because the time used to figure the next starting time of the periodic task 
does not take into account any previous missed deadlines. In eRect, it still tries to meet the deadline of the 
next cycle even if it too has already past, j ne aHrectimr for this problem was to restart the period from the 
time the missed deadline was detected, thus “forgetting” the cyclefs) that missed its deadline. 

The problem with non-periodic task durations stems from the method used to adjust the duration of a 
non-periodic task to accoimt for the processor time consumed by the periodic tasks. The current method 
uses the formula: 


Wj Oj 

(l-BU) (l-BU) 

where mi is the mandattay duration of the task, oi is the optional duration, and BU is the current budgeted 
periodic utilization. Because the budgeted periodic utilization is an average value, and not an accurate 
reflection of a particular duration, as long as the non-periodic tasks are of relatively long durations, the 
formula works well. However, it quickly fails to provide accurate predictions when non-periodic durations 
ate short. 

One possible method to increase the accuracy of the predicted non-periodic durations is to create a 
periodic task that is used to execute non-periodic tasks. This method would allow the Reasoning Process to 
guarantee some minimum response times. By adjusting the duration and period of the task, the amount of 


6-6 




processor time allotted to non-periodic tasks could be better regulated. The new equation for calculating 
the actual durations of non-periodic tasks becomes: 


r ^ 

-1 T and E, = 

'o' 



c 


where T is the period of the task, c is the duration of the task, m and o are the mandatory and optional 
durations of the non-periodic task respectively, and are the predicted execution times of the non¬ 

periodic task. 

The anomaly dealing with tasks of the same period is illustrated in Figure 6.S. Because the wdering 
in the queues is only based upon one field in the task’s TCB, there are numerous cases where a “priority 
inversion” can occur. This particular problem surfaced when a test case was lun with all periods equal and 
randomly generated importances. From Figure 6.S it is clear that the priority assigned to each task will 
depend solely upon its position in the queue, and not be influenced by its importance. The impact of this 
priority inversion, however, is not clearly understood. 

In general, for periodic tasks, the importance of a task only assures that the task will be in the 
schedulable set, and the rate monotonic algorithm determines the priority of each task in that set. In the 
case of all or some tasks in the schedulable set having the same period, priorities are assigned currently first 
come first served. However, the set is still classified as schedulable and thus the priority assigned should 
not matter. The testing conducted to date was unable to determine if the anomaly could cause problems. 
Given better timing analysis tools and a more controlled execution environment, an understanding of the 
impact of this inversion could be conducted. However, no timing faults could be traced to Uk inversion. 

6.4. Code Complexity Analysis 

In Chapter 3, improving algorithm efficacy was presented as a method of obtaining real-time 
performance. This section examines the code that makes up the feasibility demonstration system in terms 
of its time complexity. The analysis presented here should assist follow-on efforts in tuning the algmithms 
used to obtain maximum performance from the system. 

The results of the complexity analysis are shown in Table 6.1 and Table 6.2. In the tables, n is the 
number of currently active periodic tasks and m is the number of currently active non-periodic tasks. The 


6-7 





were no unexpected results; however, there are a few areas that could be improved upon. First, the number 
of context switches is excessive in some places and second, implementation of the task buffers needs a 
reexamination. The task control buffers are the primary area where a simple change in data structures can 
lead to significant performance gains. 

Both Table 6.1 and Table 6.2 contain a column for the number of context switches. Context 
switches are important because they consume significant amounts of processor time, dwarfing the code 
complexity numbers for all but very large values of n (the average time for a context switch on the 
Sparcstation is about 0.(XX)2S seconds). A context switch occurs whenever one task calls another (as is the 
case with the Task Manager writing to the task control buffers). The code developed did not explicitly try 
to reduce the number of context switches and this issue should be addressed in the future. 

The task control buffers, as written, used a linked list for implementation convenience. A task that 
wishes to get something from the buffer provides an index value. The task buffer then searches through the 
link list buffer until it fmds the index and returns that item to the calling task. The effect of this 
implementation is an 0(n) operation every time the buffer is accessed. Since every active task accesses the 
buffer at least once during its execution, this is a very inefficient data structure. 

Also, there is very little structure to the access sequences. For example, the periodic task control 
buffer access pattern is determined by the period of the periodic tasks. If a periodic task terminates and 
then is reused, its period is most likely to be different than the previous one. In addition, the set of items in 
the buffer only changes when a new task is instantiated, not when a task shell is reused. 


Tasks By Period (^eue 


Priorit; 


• Frioi 

rity n 

7 


y n ..... .. 



m 

1 

1 

1 

i 

■ 

I 

■ 

1 

1 

■ 

■ 



^ 1 

Period = 2.0 Seconds 

1 


Importance = High 

'Period = 2.0 Seconds 
Importance = Lx)w 


Figure 6.5 Example of Execution Priority Inversion 


6-8 








Table 6.1 Time Complexity of Procedures Used By the Task Manager 


Procedure Name 

Context 

Switches 

Complexity for 

Periodic Tasks 

Complexity for 

Non-Periodic T asks 

Assign_Periodic_Priorities 

3n 

0(n2) 


Dispatch Tasks 

SA* 

0(n * SA) 

0(m * SA) 

Feasible 


0(1) 

0(1) 

Find_TCB 


0(n + in) 

0(n + m) 

GetJTCB 

2 

(X3n + m) 

0(n -t- m) 

Modify 

3n** 

0(n2) 

0(m) 

Non_Periodic_Completed 

1 


0(m) 

Periodic_Priorites_By_Importance 

n 

0(n2) 


P_T asks_<_P_Priorities 

2n 

0(n2) 


P_T asks_>_P_Priorities 

2n 

0(n2) 


Schedule 

1 

0(n + m) 

0(n + m) 

Sc»ne_ Periodics_C)ptional 

n 

0(n2) 


Un_Schedule 


0(n) 

0(m) 


% 

♦* 


SA stands for scheduling action, thus the order depends upon how many tasks need to start or stop at 
the time the procedure is called. 

only one context switch required for non-periodic task modify 
only the non-periodic tasks require a context switch 


Table 6.2 Time Complexity of Task Manager Entry Calls 


Task Entry Name 

Procedures Called 

Context 

Complexity for 

Complexity for 



Switches 

Periodic Tasks 

Non-Periodic Tasks 

Add_Task 

Get_TCB, Feasible, 
Schedule, Un_Schedule 

3n+ 1 

0(n2) 

0(n + m) 

Modify JTask 

FindJTCB, Modify, 
Feasible 

3n+ 1 

0(n2) 

0(m) 

Remove_Task 

Find_TCB, Un_Schedule 

1 

0(n) 

0(m) 

Change_BU* 

Assign_Periodic_Priorities 

3n+ 1 

0(n2) 

0(m) 

Task_Complete 

Non_Periodic_Completed 

1 


0(m) 


Changing the budgeted periodic utilization affects both the periodic and non-periodic tasks. 


6-9 


























































































Given the random access patterns and the fairly stable number of buffer items, a balanced binary tree 
data structure may be much more efHcient Since the search through a balanced binary tree takes 0(log n) 
time, the speed of the buffer access could be significantly enhanced. The increased efficiency of this 
heavily used data structure should provide substantial performance gains. Note that the 
Tasks_By_ID_Queue could also benefit from this approach for the same reasons. 

Although testing was not specifically conducted on the use of the priority deques, their use appears 
extremely benefrcial. First, the removal or value testing of the item at the head of the queue takes 0(1) 
time. Also, although in the worst case the time to insert an item into the priority queue is of 0(n), the 
ability to start the insertion from either end of the queue structure can help reduce the average insertion 
time. For example, when inserting items into the time ordered queues (nearest time at the head of the queue 
and farthest time at the tail) starting from the tail of the queue can result in better average insertion times. 
This is because time is always advancing in a real-time system and new tasks generally have starting times 
later than tasks currently in the system. Of course, in one particular system the opposite could be true. It is 
recommended that the current time ordered deques (Ready_Queue, Deadline_Queue, and 
Latest_Start_Time_(3ueue) remain as deques until some overwhelming evidence is produced to replace 
them with some other data structure. 

6J. Results Summary 

Testing of the feasibility demonstration system has validated the approach taken. In particular, the 
Task Manager is able to dynamically create and control tasks as directed by the Reasoning Process. The 
scheduling overhead incurred is not excessive and additional algorithm and data structure improvements 
will reduce the scheduling overhead further. The feasibility demonstration system clearly shows the 
viability of the architecture developed. 

However, some perfOTmance gains are possible. The task control buffer’s internal data structures are 
inappropriate in the current implementation. The same can be said for the Tasks_By_ID_Queue. Changing 
these data structures to binary trees would improve the performance of these heavily used data structures. 
In addition, an some effort should be expended to reduce the number of context switches required in the 
current implementation. 


6-10 





VII. Conclusion 


This research has taken the first steps of a much larger research effort into the development of 
Intelligent Real-Time Systems. This cluq)ter outlines the specific accomplishments of this thesis effort and 
lays out some possible directions in which to continue the development of the architecture. 

7.1. Summary 

The primary result of this thesis eR^ort is an intelligent real-time system architecture and top level 
design. The majority of the effort expended in this thesis has gone into researching existing work in the 
field and identifying what is required or common in most intelligent real-time systems and what appears to 
be missing or needed. The architecture developed allows for inclusion of all the identified components. 
Additionally, the implemented portions of the Task Manager directly address what is missing from other 
intelligent real-time systems, namely guaranteed ability to meet task deadlines. Adding this ability to a 
dynamic system involved development of the ability to dynamically create and control Ada tasks, 
dynamically assign priorities to those tasks, and export task scheduling and execution controls to a 
Heasoning Process', while maintaining a large degree of parallelism. The top level design and a robust 
Task Manager has been implemented and the architecture’s feasibility demonstrated. 

Overcoming the problems associated with dynamic task creation and control in Ada is fundamental 
to the development of an intelligent real-time system implemented in Ada. The method developed has 
demonstrated the ability to solve a large number of the problems involved with dynamic task creation. 
Namely, it allows for re-use of Ada task shells and helps prevent a potentially serious memory leak. 
Additionally, communication between the dynamically created tasks and the rest of the system has been 
addressed and a method using a "variables buffer” has been implemented and demonstrated. The methods 
developed to control the execution of the dynamically created tasks “appear to work well” in the limited 
tests conducted. However, the limited testing leaves unanswered a large number of questions regarding the 
efficiency of the methods developed. 

PCThrqrs the single most important control implemented is the dynamic executim priority assigrunent 
scheme. The methods as implemented in the Task Manager are effective in solving the problems posed in 
guaranteeing real-time performance. The system is able to schedule and execute both periodic and non- 


7-1 






periodic tasks in both overloaded and nonoverloaded situations, thus demonstrating an ability to degrade 
gracefully. To add this capability, non-standard Ada had to be used. Ada does not provide for dynamic 
task priority assignments and thus Verdix Ada specific procedures had to be used. The use of Verdix Ada 
specific procedures and functions limits portability of the system. However, this problem of dynamic task 
priority assignments in Ada is being addressed and may change in the near future [@Ada9X]. If and when 
that h^pens, the methods used here will have to be reevaluated and most likely changed. 

Exporting task scheduling and execution controls also was demonstrated and implemented. The 
ability of the Reasoning Process to affect the current scheduling policies used without having to actually 
implement the task scheduling itself allows the Reasoning Process to operate at a conceptually higher level. 
Yet it can directly affect the execution of any particular task as it deems necessary. In effect, the Reasoning 
Process is able to perform off-line schedul'mg while the Task Manager performs the on-line scheduling. 
Again, the lack of an ability to “rigorously test” the implementation prevents optimizations to reduce the 
overhead required to implement such abilities or characterize their behaviors. 

Finally, the developed architecture has intentionally not sacrificed any inherent parallelism in order 
to achieve some domain specific performance goals. The architecture developed here is easily 
implementable on a multi-processor system with little, if any, re-writing of the code. The cost of 
maintaining this parallelism is increased code complexity and the associated communication overhead. 

The architecture as developed in this thesis effort is by no means the ideal one. Instead, this thesis 
has presented one architecture and implementation and by doing so has charted a course for future work in 
the field. The work done is leading edge research with a large number of unanswered questions and 
potential problems. Like most difficult problems, this thesis effort has provided an incremental advance 
towards a solution. 

7 . 2 . Recommendations 

Since this research is not an end in itself, perhaps, the most important section is this one. The 
recorrunendations presented here outline the research areas that still need to be addressed to fully 
implement the developed architecture. Additionally, another potential path to achieve the same goal was 
previously mentioned in Chapter 3 but not explored by this thesis; that path also deserves to be exatruned. 
The following recommendations are divided into three parts: recorrunendations to improve the implemented 


7-2 



Task Manager, architecture components other than the Task Manager, and other implementation and 
development issues. 

72.1. Task Manager Recommendations. The Task Manager as implemented can easily be improved 
upon. First, the system as implemented does not make use of the full rate monotonic theory. In particular, 
the blocking time any particular task may suffer is not included in the current periodic task utilization 
calculations (Theorems 3 and 4 from Chapter 2). The effect is reduced accuracy in the utilization 
calculations. Also, no allowance for aperiodic tasks is implemented, but details of how to incorporate 
support for aperiodic tasks are readily available and should be incorporated into the implementation 
[Sprunt, 1990]. 

The issues associated with determining the feasibility of the non-periodic tasks has not been 
adequately addressed. As implemented, priorities of non-periodic tasks are assigned earliest deadline first, 
and feasibility is only checked for tasks in isolation, not in conjunction with other non-periodic tasks of 
varying importances. Incorporation of more robust (and correspondingly more time and space complex) 
algorithms is required. Again, there exists a large body of knowledge dealing with these types of 
algorithms to draw upon and allowances for incorporating these algorithms has been made in the existing 
design [Liu, 1991] [Coffman, 1976]. 

Also, although memory management has been addressed, the problem has by no means been solved. 
In particular, each data structure retains the maximum memory it has ever been allotted. This approach 
may lead to problems when the system operates in an overloaded condition. There is currently no method 
implemented to deal with Ada storage errors generated when no more memory is available. It is possible 
for this condition to occur and a critical task is unable to execute. A method must be implemented to allow 
for the reclamation of memory when required. 

Finally, the problems with using the Ada delay statement for accurate tuning control are well known 
in the Ada community. The Task Dispatcher, as implemented, makes use of the Ada delay statement and 
should be corrected. Attaching a procedure to directly respond to timer generated interrupts should greatly 
enhance the tuning accuracy of the Task Dispatcher. 

7.2.2. Other Architecture Components Recommendations. Neither the Environment Model, System 
Model, or the reasoning logic of the Reasoning Process was implemented in this thesis effort, primarily 
because they all appear to be very domain specific. Otoosing a domain and develt^ing the reasoning logic. 


7-3 




Environment Model, and System Model for that domain should be attempted. Choosing a particular 
domain should greatly simplify the development effort by anchoring the system to some definable 
performance criteria to measure the effectiveness of the system as a whole. Thus, not only can speed of 
execution be evaluated against some requirement, but also the quality of the system's responses can be 
evaluated. 

The Environment Model should allow for efficient access by all currently executing tasks and 
address the issues of data consistency and data timeiiness. Given time, I had envisioned using an object 
oriented Ada pre-processor (Classic Ada) for implementing the Environment Model. I believe an object 
oriented approach most suitable for this type of model but clearly the issue requires investigation. 
Additionally, the tradeoffs associated with placement of the data pertaining to the condition of the 
environment into a single repository versus distribution among the various tasks should be investigated. 

The System Model should allow the Reasoning Process the ability to make effective predictions of 
future events and accurately reflect the current state of the system. A fundamental assumption of this thesis 
effort was the existence of such a model in the form of a task network or plan-goal graph. Converting these 
knowledge acquisition tools into an implementation usable by the reasoning process is required. The 
envisioned method uses a graph structure with each node representing a task in the system. Future efforts 
along these lines should closely examine the idea of temporal constraint networks when developing the 
system model and the corresponding reasoning logic [E)echter, 1991]. 

The current Reasoning Process makes only minimum use of existing techniques for agenda 
management. The architecture, however, allows for relatively easy inclusion of most of the techniques 
developed under the Pilot’s Associate program and presented in section 2.3.3 of the thesis into design. By 
moving the Reasoning Process to a separate processor and including the additional agenda management 
techiuques, I believe a significant overall performance gain can be achieved. 

Finally, specific implementations of the I/O Process should be investigated to match performance 
with system capabilities. In particular, the idea of reflexive behavior can be implemented by allowing the 
I/O Process to instantiate tasks in response to external events directly, without having to report the event 
first to the Reasoning Process. The correct mix of this type of reactive behavior versus reasoned behavior 
should be investigated. 


74 


7.23. Implementation and Development Recommendations. The (fcvelopment of this thesis suffered 
significantly from the lack of a dedicated or single user workstation. Because the system was developed on 
a multi-user system, accurate timing information is virtually impossible to obtain. The multi-user system 
used allows other processes to start and stop at anytime. Additionally, there is the additional overhead 
associated with managing multiple user processes. It is highly recommended that any future effort use a 
dedicated workstation operating in the single user mode to provide an accurate pictmre of the system’s 
performance and timing characteristics. 

Although allowed for in the design, the system does not make use of multi-processors. Splitting the 
system across multiple processors would greatly increase the performance of the system. I would 
recommend moving the Reasoning Process to a separate machine as the first step. This move would 
alleviate the problem of which priority to assign the Reasoning Process. Additionally, it should allow the 
remaining components to act more as a traditional real-time system with the corresponding improvement in 
its ability to meet task deadlines, while at the same time, allowing the Reasoning Process more 
computational resources and hopefully a corresponding increase in overall system performance. 

Tools for the development of these types of systems should also be explored. In particular, tools to 
debug multiple task Ada programs should be examined. Also useful, would be the development of a 
system that allows for a 'rubber clock' so that system's view of the passage of time could be slowed. The 
rubber clock would allow a programmer the ability to step through the program with the clock only 
advancing by the time to execute each step and stopping while the programmer examines the results of that 
step. 


The final recommendation is for a more rigorous specification process to be conducted. 
Unfortunately, only modest software engineering techniques were applied in the development of the 
feasibility dcmo;istration system. Using a structured analysis and design method would provide better 
measurement criteria, greater design visibility, and perhaps increased performance. Using this thesis and 
the accompanying code as a guide, the task could be easily accomplished as another thesis effort 

7.3. Thesis Summary 

The literature review reported in Qiapter 2 identified the Environment Model, System Model, I/O 
Process, Reasoning Process, and Task Manager as the components necessary for an intelligent real-time 
system. It also identified real-time task scheduling and deadline guarantees as the missing component in 


7-5 




most previous IRTSs. In addition, rate monotonic theory and imprecise computation scheduling were 
discussed as ways to handle real-time task scheduling. Finally, Giapter 2 identified the general task types 
any-time, singular, and periodic. 

Chapters 3 discussed IRTS performance measures and design considerations. Speed, 
responsiveness, timeliness, graceful degradation, data consistency, and solution quality are tl^ perfcainance 
measures for intelligent real-time systems. Control reasoning, focus of attention, parallelism, and 
improving algorithm efficacy are design considerations used when addressing the performance measures. 
Chsqiter 3 concluded with the rationale for the design ^proach used. 

Chapter 4 presented the top level view of an intelligent system architecture and discussed general 
issues of the architecture. The methods used to perform on-line task scheduling of both non-periodic and 
periodic tasks was presented. Ch^ter 5 discussed the details of the demonstration system implemented to 
confirm the feasibility of the architecture presented in Chapter 4 and Chapter 6 discussed the results of the 
feasibility demonstratioa 

This thesis effort has researched and developed a feasible architecture for use in creating an 
intelligent real-time system. Dynamic task creation and real-time scheduling methods were developed and 
successfully demonstrated. But the work is not complete. It is clear that further research is required along 
a number of different paths. This research establishes a starting point and provides possible paths for 
further work. 


7-6 






Appendix A. Test Results 


This appendix contains numerous gra]^ that show the results of timing tests conducted on the 
feasibility demonstration system. The effect of the underlying UNIX multiproccssingAime slicing 
operating system can be clearly seen in all (he graphs. The graphs are not intended to be accurate measures 
of the systems performance, rather they are intended to validate the ^proach taken in this research. In 
addition, a number of “queue dumps” are included that show the effects of adding, modifying, or removing 
tasks from the Task Manager. 

A.l Scheduling Overhead Timing Results 

Figures A.1 through A.4 show a sample of the measured times to add, modify, and remove periodic 
tasks. For these tests, a loop which first added a new task, then modified it was executed 150 tasks. Once 
all 150 tasks were created, another loop was executed which removed all 150. Both loops were run 20 
times and the minimum, maximum, and average tuws for each operation recorded. The vertical lines 
represoit the range of times obtained with the corresponding number of acitve tasks in die system. The tick 
marks on each line represent the minimum, average, and maximum times. For these tests, there were no 
non-periodic tasks currently active in the system. 

Figures A.5 through A.8 show a sample of the measured times to add, modify, and remove non¬ 
periodic tasks. The same testing method used for the periodic task tests was used to acquire these times. 
For these tests, there were no periodic tasks currently active in the system. 


A-1 



0 . 030 - 



1 ■ ■ 

^ 1 1 1 

T 1 — 1 1 — 

' ' 1 

to 

o 

in 

o 

CM 

CM 

T” 

T” 

O 

o 

o 

o 

d 

d 

d 

d 


(spuooes) ©ujij. 


A-2 


hsooo 












































































































M«J 



































0 . 01 - 









































































0 . 0 : 



oqoqcjo9 99 
dddd dddd 

(spuooes) eujii 


A-6 












0.01 






0.0 



Number of Active Non-Periodics Tasks 150 






A.2. Schedules Produced 


The following san^le printouts show ttie affect of adding a periodic task whose additicxial utilization 
causes the the periodic condition to change from ALL_OPTIONAL to SOME_OPnONAL. Periodic task 
kind 8 has mandatory duration of 0.008 seconds and an optional duration of 0.02 seconds. The first 
printout shows the state of the periodic task set before the addition of Task ID 1280600 and the second one 
shows the state of the periodic task set after Task ID 1280600 has been added. Note some tasks have been 
deleted from the printout to make it easier to read. 


Task ID 

Period 

Kind 

Iitportance 

Priority 

Mode 

1233880 

1.12100 

8 

46 

90 

OPTIONAL 

848440 

1.49900 

8 

13 

89 

OPTIONAL 

976920 

2.29800 

8 

24 

88 

OPTIONAL 

1245560 

2.39900 

8 

47 

87 

OPTIONAL 

790040 

2.43300 

8 

8 

86 

OPTIONAL 

965240 

2.59300 

8 

23 

85 

OPTIONAL 

801720 

3.42200 

8 

9 

84 

OPTIONAL 

930200 

3.78900 

8 

20 

83 

OPTIONAL 

731640 

3.93600 

8 

3 

82 

OPTIONAL 

1058680 

4.23600 

8 

31 

81 

OPTIONAL 

1257240 

4.34100 

8 

48 

80 

OPTIONAL 

836760 

4.36300 

8 

12 

79 

OPTIONAL 

1035320 

4.45700 

8 

29 

78 

OPTIONAL 

860120 

4.49800 

8 

14 

77 

OPTIONAL 

1011960 

4.60500 

8 

27 

76 

OPTIONAL 

918520 

4.96800 

8 

19 

75 

OPTIONAL 

719960 

5.13200 

8 

2 

74 

OPTIONAL 

825080 

5.40600 

8 

11 

73 

OPTIONAL 

906840 

5.57900 

8 

18 

72 

OPTIONAL 

883480 

5.64100 

8 

16 

71 

OPTIONAL 

941880 

5.90700 

8 

21 

70 

OPTIONAL 

988600 

6.09400 

8 

25 

69 

OPTIONAL 

871800 

6.61600 

8 

15 

68 

OPTIONAL 

1187160 

7.15300 

8 

42 

67 

OPTIONAL 

1082040 

7.47600 

8 

33 

66 

OPTIONAL 

1047000 

7.48300 

8 

30 

65 

OPTIONAL 

1128760 

7.51200 

8 

37 

64 

OPTIONAL 

895160 

7.52000 

8 

17 

63 

OPTIONAL 

1210520 

7.64000 

8 

44 

62 

OPTIONAL 

1222200 

7.68000 

8 

45 

61 

OPTIONAL 

1000280 

7.92000 

8 

26 

60 

OPTIONAL 

1093720 

8.14400 

8 

34 

59 

OPTIONAL 

1070360 

8.21900 

8 

32 

58 

OPTIONAL 

1140440 

8.24400 

8 

38 

57 

OPTIONAL 

1152120 

8.38500 

8 

39 

56 

OPTIONAL 

778360 

8.86800 

8 

7 

55 

OPTIONAL 

1117080 

8.90200 

8 

36 

54 

OPTIONAL 

953560 

8.92700 

8 

22 

53 

OPTIONAL 

755000 

8.97900 

8 

5 

52 

OPTIONAL 

743320 

9.37000 

8 

4 

51 

OPTIONAL 

1175480 

9.79600 

8 

41 

50 

OPTIONAL 

813400 

9.82100 

8 

10 

49 

OPTIONAL 

1163800 

10.03100 

8 

40 

48 

OPTIONAL 

1268920 

10.12300 

8 

49 

47 

OPTIONAL 


A-10 







1105400 

10.13400 

8 

35 

46 

OPTIONAL 

1198840 

10.46100 

8 

43 

45 

OPTIONAL 

766680 

10.68200 

8 

6 

44 

OPTIONAL 

1023640 

10.76600 

8 

28 

43 

OPTIONAL 


Periodic Utilization => 2.75986964545906E-01 

Mandatory Utilization => 8.23119017066736E-02 

Optional Utilization => 2.75986964545906E-01 

Required Utilization => 2.79270430800456E-01 

Periodic Utilization Budget => 4 .OOOOOOOOOOOOOOE-01 

Current Periodic Condition => ALL OPTIONAL 


Task ID 

Period 

Kind 

Inportance 

Priority 

Mode 

1233880 

1.12100 

8 

46 

90 

OPTIONAL 

848440 

1.49900 

8 

13 

89 

OPTIONAL 

976920 

2.29800 

8 

24 

88 

OPTIONAL 

1245560 

2.39900 

8 

47 

87 

OPTIONAL 

790040 

2.43300 

8 

8 

86 

OPTIONAL 

1280600 

2.55800 

8 

49 

85 

MANDATORY 

965240 

2.59300 

8 

23 

84 

OPTIONAL 

801720 

3.42200 

8 

9 

83 

OPTIONAL 

930200 

3.78900 

8 

20 

82 

OPTIONAL 

731640 

3.93600 

8 

3 

81 

OPTIONAL 

1058680 

4.23600 

8 

31 

80 

OPTIONAL 

1257240 

4.34100 

8 

48 

79 

MANDATORY 

836760 

4.36300 

8 

12 

78 

OPTIONAL 

1035320 

4.45700 

8 

29 

77 

OPTIONAL 

860120 

4.49800 

8 

14 

76 

OPTIONAL 

1011960 

4.60500 

8 

27 

75 

OPTIONAL 

918520 

4.96800 

8 

19 

74 

OPTIONAL 

719960 

5.13200 

8 

2 

73 

OPTIONAL 

825080 

5.40600 

8 

11 

72 

OPTIONAL 

906840 

5.57900 

8 

18 

71 

OPTIONAL 

883480 

5.64100 

8 

16 

70 

OPTIONAL 

941880 

5.90700 

8 

21 

69 

OPTIONAL 

988600 

6.09400 

8 

25 

68 

OPTIONAL 

871800 

6.61600 

8 

15 

67 

OPTIONAL 

1187160 

7.15300 

8 

42 

66 

OPTIONAL 

1082040 

7.47600 

8 

33 

65 

OPTIONAL 

1047000 

7.48300 

8 

30 

64 

OPTIONAL 

1128760 

7.51200 

8 

37 

63 

OPTIONAL 

895160 

7.52000 

8 

17 

62 

OPTIONAL 

1210520 

7.64000 

8 

44 

61 

OPTIONAL 

1222200 

7.68000 

8 

45 

60 

OPTIONAL 

1000280 

7.92000 

8 

26 

59 

OPTIONAL 

1093720 

8.14400 

8 

34 

58 

OPTIONAL 

1070360 

8.21900 

8 

32 

57 

OPTIONAL 

1140440 

8.24400 

8 

38 

56 

OPTIONAL 

1152120 

8.38500 

8 

39 

55 

OPTIONAL 

778360 

8.86800 

8 

7 

54 

OPTIONAL 

1117080 

8.90200 

8 

36 

53 

OPTIONAL 

953560 

8.92700 

8 

22 

52 

OPTIONAL 

755000 

8.97900 

8 

5 

51 

OPTIONAL 

743320 

9.37000 

8 

4 

50 

OPTIONAL 

1175480 

9.79600 

8 

41 

49 

OPTIONAL 

813400 

9.82100 

8 

10 

48 

OPTIONAL 

1163800 

10.03100 

8 

40 

47 

OPTIONAL 

1268920 

10.12300 

8 

49 

46 

MANDATORY 

1105400 

10.13400 

8 

35 

45 

OPTIONAL 

1198840 

10.46100 

8 

43 

44 

OPTIONAL 

766680 

10.68200 

8 

6 

43 

OPTIONAL 

1023640 

10.76600 

8 

28 

42 

OPTIONAL 


All 








Periodic Utilization => 2.77404244072816E-01 

Mandatory Utilization => 8.56348102289566E-02 

Optional Utilization => 2.87128481355913E-01 

Required Utilization => 2.79229184559615E-01 

Periodic Utilization Budget => 4.OOOOOOOOOOOOOOE-01 

Current Periodic Condition => SOME OPTIONAL 


The following printouts show the affects of modifying a periodic task. In this case, the period of 
Task ID 801720 has been changed from 2.422 seconds to 3.422 seconds and its importance value decreased 
by one. Note its priority has been changed to reflect its new period along with ttie priority of Task ID 
790040. 


Task ID 

Period 

Kind 

Importance 

Priority 

Mode 

801720 

2.42200 

8 

8 

90 

OPTIONAL 

790040 

2.43300 

8 

8 

89 

OPTIONAL 

731640 

3.93600 

8 

3 

88 

OPTIONAL 

719960 

5.13200 

8 

2 

87 

OPTIONAL 

778360 

8.86800 

8 

7 

86 

OPTIONAL 

755000 

8.97900 

8 

5 

85 

OPTIONAL 

743320 

9.37000 

8 

4 

84 

OPTIONAL 

766680 

10.68200 

8 

6 

83 

OPTIONAL 


Periodic Utilization => 
Mandatory Utilization => 
Optional Utilization => 
Required Utilization => 
Periodic Utilization Budget => 
Current Periodic Condition => 


4.83728493284041E-02 
1.44269901505767E-02 
4.83728493284041E-02 
2.89624744528825E-01 

4.00000000000000E-01 
ALL OPTIONAL 


Task ID 

Period 

Kind 

In 5 )ortance 

Priority 

Mode 

790040 

2.43300 

8 

8 

90 

OPTIONAL 

801720 

3.42200 

8 

9 

89 

OPTIONAL 

731640 

3.93600 

8 

3 

88 

OPTIONAL 

719960 

5.13200 

8 

2 

87 

OPTIONAL 

778360 

8.86800 

8 

7 

86 

OPTIONAL 

755000 

8.97900 

8 

5 

85 

OPTIONAL 

743320 

9.37000 

8 

4 

84 

OPTIONAL 

766680 

10.68200 

8 

6 

83 

OPTIONAL 


Periodic Utilization => 4.49341776161001E-02 

Mandatory Utilization => 1.34014213942755E-02 

Optional Utilization => 4.49341776161001E-02 

Required Utilization => 2.89624744528825E-01 

Periodic Utilization Budget => 4. OOOOOOOOOOOOOOE-01 

Current Periodic Condition => ALL OPTIONAL 


The following printout traces modify operations on an active set of any-time tasks. Ibere are two 
sets of data for each modify operation, one takoi immediately before the modify, and one immediately 
after. During the modify, a task’s deadline and importance is changed. The numbers in the status column 
represent the task’s current state. The inimber to state translation is as shown in Table A.I. Note that at 
times, the time remaining for a task jumps back up to 0.100 seconds. The reason for the jumps is the 


A-I2 







method used to handle errors induced by the UNIX multitasking opentting system. In order to insure that 
the time remaining never goes negative, a check in the code detects this situation and sets the time 
remaining to 0.100 seconds. 


Table A.1 Printout Status Numbo^ to State Name Translation 


Status Number 

State Name 

Applies to 

0 

READY 

All 

1 

EXECUTING 

periodic tasks 

2 

EXECUTING.MANDATORY 

ncai-periodic tasks 

3 

EXECUTING.OPnONAL 

nm-periodic tasks 

4 

PREEMPTED_MANDATORY 

nrai-periodic tasks 

5 

PREEMPTED.OPTIONAL 

nm-peiiodic tasks 

6 

DISCARDED 

nfflt-periodic tasks 

7 

COMPLETED 

nm-peiiodic tasks 


»»»>» The Time Now is => 60175.427 Periodic Utilization Budget => 5.00E-01 ««««< 

Durations Time Latest 

Task ID Mandatory Optional Remaining Start-Time Deadline Started-At Importance Status Start-Time 


749552 0.100 1.000 0.200 60175.363 60178.886 60175.422 1 2 


>»»»» The Time Now Is => 60175.453 Periodic Utilization Budget => 5.00E-01 «««<« 

Durations Time Latest 

Task ID Mandatory Optional Remaining Start-Time Deadline Started-At Importance Status Start-Time 


749552 0.100 1.000 0.178 60175.363 60179.886 60175.422 2 2 


»»»»> The Time Now Is => 60175.727 Periodic Utilization Budget => 5.00E-01 ««««< 

Durations Time Latest 

Task ID Mandatory Optional Remaining Start-Time Deadline Started-At Importance Status Start-Time 


749552 0.100 1.000 1.760 60175.363 60179.886 N/A 2 5 60178.126 

761232 0.100 1.000 0.200 60175.674 60185.718 60175.725 2 2 


»»>»» The Time Now Is => 60175.757 Periodic Utilization Budget => 5.00E-01 «««<« 

Durations Time Latest 

Task ID Mandatory Optional Remaining Start-Time Deadline Started-At Importance Status Start-Time 


749552 0.100 1.000 1.760 60175.363 60179.886 N/A 2 5 60178.126 

761232 0.100 1.000 0.178 60175.674 60186.718 60175.725 3 2 


»»>»» The Time Now is => 60176.139 Periodic Utilization Budget => 5.00E-01 ««««< 

Durations Time Latest 

Task ID Mandatory Optional Remaining Start-Time Deadline Started-At Importance Status Start-Time 


749552 

0.100 

1.000 

1.321 

60175.363 

60179.886 

N/A 

2 

761232 

0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 

3 

772912 

0.100 

1.000 

0.200 

60175.983 

60185.558 

60176,135 

3 


5 60178.565 
5 60184.718 
2 


A-13 











































>>>»»» The Time Now is => 60176.169 Periodic Utilization Budget => 5.00E-01 <<«<<v<< 

Durations Time Latest 

Task ID Mandatory Optional Remaining Start-Time Deadline Started-At Importance Status Start-Time 


749552 

0.100 

1.000 

1.321 

60175.363 

60179.886 

N/A 

2 

5 

60178.565 

761232 

0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 

3 

5 

60184.718 

772912 

0.100 

1.000 

0.178 

60175.983 

60186.558 

60176.135 

4 

2 



>>»»»> The Time Now is => 60176.431 Periodic Utilization Budget => 5.00E-01 <«<<<<<< 

Durations Time Latest 

Task ID Mandatory Optional Remaining Start-Time Deadline Started-At Importance Status Start-Time 


749552 

0.100 

1.000 

1.122 

60175.363 

60179.886 

N/A 

2 

5 

60178.764 

761232 

0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 

3 

5 

60184.718 

772912 

0.100 

1.000 

2.000 

60175.983 

60186.558 

N/A 

4 

5 

60184.558 

784592 

0.100 

1.000 

0.200 

60176.392 

60188.011 

60176.426 

4 

2 



»»>»» 

The Time 

Now is 

=> 60176.474 Periodic Utilization Budget => 

5.00E-01 

««««< 



Durations 

Time 







Latest 

Task ID 

Mandatory 

Optional 

Remaining 

Start-Time 

Deadline 

Started-At 

Importance Status 

Start-Time 

749552 


0.100 


1.000 

1.122 

60175.363 

60179.886 

N/A 


2 

5 

60178.764 

761232 


0.100 


1.000 

2.000 

60175.674 

60186.718 

N/A 


3 

5 

60184.718 

772912 


0.100 


1.000 

2.000 

60175.983 

60186.558 

N/A 


4 

5 

60184.558 

784592 


0.100 


1.000 

0.163 

60176.392 

60189.011 

60176.426 


5 

2 


»»»»> 

The Time 

Now is 

=> 60176.735 Periodic Utilization Budget => 

5.00E-01 

««««< 



Durations 

Time 







Latest 

Task ID 

Mandatory 

Optional 

Remaining 

Start-Time 

Deadline 

Started-At 

Importance Status 

Start-Time 

749552 


0.100 


1.000 

0.909 

60175.363 

60179.886 

N/A 


2 

5 

60178.977 

761232 


0.100 


1.000 

2.000 

60175.674 

60186.718 

N/A 


3 

s 

60184.718 

772912 


0.100 


1.000 

2.000 

60175.983 

60186.558 

N/A 


4 

5 

60184.558 

784592 


0.100 


1.000 

2.000 

60176.392 

60189.011 

N/A 


5 

5 

60187.011 

796272 


0.100 


1.000 

0.200 

60176.7X3 

60186.154 

60176.734 


5 

2 


»>»»» 

The Time 

Now IS 

=> 60176.749 Periodic Otilization Budget => 

5.00E-01 

««««< 



Durations 

Time 







Latest 

Task ID 

Mandatory Optional 

Remaining Start-Time 

Deadline 

Started-At 

Importance Status 

Start-Time 

749552 


0.100 


1.000 

0.909 

60175.363 

60179.886 

N/A 


2 

5 

60178.977 

761232 


0.100 


1.000 

2.000 

60175.674 

60186.718 

N/A 


3 

5 

60184.718 

772912 


0.100 


1.000 

2.000 

60175.983 

60186.558 

N/A 


4 

5 

60184.558 

784592 


0.100 


1.000 

2.000 

60176.392 

60189.011 

N/A 


5 

5 

60187.011 

796272 


0.100 


1.000 

0.187 

60176.713 

60187.154 

60176.734 


6 

2 



>>»»»> The Time Now is 
Durations 

Task ID Mandatory Optional 

=> 60177.109 Periodic Utilization Budget => 5.00E- 

Time 

Remaining Start-Time Deadline Started-At Importance 

•01 ««««< 

Latest 

Status Start-Time 

749552 

0.100 

1.000 

0.749 

60175.363 

60179.886 

N/A 

2 

5 

60179.137 

761232 

0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 

3 

5 

60184.718 

772912 

0.100 

1.000 

2.000 

60175.983 

60186.558 

N/A 

4 

5 

60184.558 

784592 

0.100 

1.000 

2,000 

60176.392 

60189.011 

N/A 

5 

5 

60187.011 

796272 

0.100 

1.000 

2,000 

60176.713 

60187.154 

N/A 

6 

5 

60185.154 

807952 

0.100 

1.000 

0.200 

60177.015 

60178.735 

60177.108 

6 

2 



>>>>>>>>> The Time Now is 
Durations 

Task ID Mandatory Optional 

=> 60177.153 Periodic Otilization Budget => 5.00E-01 <<<<<<«< 

Time Latest 

Remaining Start-Time Deadline Started-At Importeuice Status Start-Time 

749552 

0.100 

1.000 

0.749 

60175.363 

60179.886 

N/A 

2 5 

60179.137 

761232 

0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 

3 5 

60184.718 

772912 

0.100 

1.000 

2.000 

60175.983 

60186.558 

N/A 

4 5 

60184.558 

784592 

0.100 

1.000 

2.000 

60176.392 

60189.011 

N/A 

5 5 

60187.011 

796272 

0.100 

1.000 

2.000 

60176.713 

60187.154 

N/A 

6 5 

60185.154 

807952 

0.100 

1.000 

0.165 

60177.015 

60179.735 

60177.108 

7 2 



>>>>>>>>> The Time Now is 
Durations 

Task ID Mandatory Optional 

=> 60177.415 Periodic Utilization Budget => 5.00E- 

Time 

Remaining Start-Time Deadline Started-At Importance 

-01 ««<«« 

Latest 

Status Start-Time 

749552 

0.100 

1.000 

0.749 

60175.363 

60179.886 

N/A 

2 

5 

60179.137 

761232 

0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 

3 

5 

60184.718 

772912 

0.100 

1.000 

2.000 

60175.983 

60186.558 

N/A 

4 

5 

60184.558 

784592 

0.100 

1.000 

2.000 

60176.392 

60189.011 

N/A 

5 

5 

60187.011 

796272 

0.100 

1.000 

2.000 

60176.713 

60187.154 

N/A 

6 

5 

60185.154 

807952 

0.100 

1.000 

1.777 

60177.015 

60179.735 

N/A 

7 

5 

60177.958 

819632 

0.100 

1.000 

0.200 

60177.374 

60180 281 

60177.414 

7 

2 



A-14 












>>>>>>>>> The Time Now is => 60177.432 Periodic Dtilization Budget => 5.00E-01 <<<<<<<<< 

Durations Time Latest 

Task ID Mandatory Optional Remaining Start-Time Deadline Started-At Importance Status Start-Time 


749552 

0.100 

1.000 

0.749 

60175.363 

60179.886 

N/A 

2 

5 

60179.137 

761232 

0.100 

1.000 

2.000 

60175.674 

60185.718 

N/A 

3 

5 

60184.718 

772912 

0.100 

1.000 

2.000 

60175.983 

60186.558 

N/A 

4 

5 

60184.558 

784592 

0.100 

1.000 

2.000 

60176.392 

60189.011 

N/A 

5 

5 

60187,011 

796272 

0.100 

1.000 

2.000 

60176.713 

60187.154 

N/A 

6 

5 

60185,154 

807952 

0.100 

1.000 

1.777 

60177.015 

60179.735 

N/A 

7 

5 

60177.958 

819632 

0.100 

1.000 

0,185 

60177.374 

60181.281 

60177.414 

8 

2 


»»»»> The Time Now is 

=> 60177 

.729 Periodic Dtilization Budget 

=> 5.00E- 

-01 «<««« 


Durations 

Time 






Latest 

Task ID 

Mandatory 

Optional 

Remaining Start-Time 

Deadline 

Started-At Imporcance 

Status 

Start-Time 

749552 

0.100 

1.000 

0.749 

60175.363 

60179.886 

N/A 

2 

5 

60179.137 

761232 

0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 

3 

5 

60184.718 

772912 

0.100 

1.000 

2.000 

60175.983 

60186.558 

N/A 

4 

5 

60184.558 

784592 

0.100 

1.000 

2,000 

60176.392 

60189.011 

N/A 

5 

5 

60187.011 

796272 

0.100 

1.000 

2.000 

60176.713 

60187.154 

N/A 

6 

5 

60185.154 

807952 

0.100 

1.000 

1.417 

60177.015 

60179.735 

N/A 

7 

5 

60178.318 

819632 

0.100 

1.000 

2.000 

60177.374 

60181.281 

N/A 

8 

5 

60179.281 

831312 

0.100 

1.000 

0.200 

60177.651 

60188.236 

60177.728 

8 

2 



>>>>>>>>> The Time Now is 
Durations 

Task ID Mandatory Optional 

=> 60177.748 Periodic Dtilization Budget => S.OOE- 

Time 

Remaining Start-Time Deadline Started-At Importance 

-01 ««««< 

Latest 

Status Start-Time 

749552 

0.100 

1.000 

0.749 

60175.363 

60179.886 

N/A 

2 

5 

60179.137 

761232 

0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 

3 

5 

60184.718 

772912 

0.100 

1.000 

2.000 

60175.983 

60186.558 

N/A 

4 

5 

60184.558 

784592 

0.100 

1.000 

2.000 

60176.392 

60189.011 

N/A 

5 

5 

60187.011 

796272 

0.100 

1.000 

2.000 

60176.713 

60187.154 

N/A 

6 

5 

60185.154 

807952 

0.100 

1.000 

1.417 

60177.015 

60179.735 

N/A 

7 

5 

60178.318 

819632 

0.100 

1.000 

2.000 

60177.374 

60181.281 

N/A 

8 

5 

60179.281 

831312 

0.100 

1.000 

0.183 

60177.651 

60189.236 

60177.728 

9 

2 



»»»»> The Time Now is 
Durations 

Task ID Mandatory Optional 

=> 60178.025 Periodic Dtilization Budget => 5.00E- 

Time 

Remaining Start-Time Deadline Started-At Importance 

-01 «<««« 

Latest 

Status Start-Time 

749552 

0.100 

1.000 

0.749 

60175.363 

60179.886 

N/A 

2 

5 

60179.137 

761232 

0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 

3 

5 

60184.718 

772912 

0.100 

1.000 

2.000 

60175.983 

60186.558 

N/A 

4 

5 

60184.558 

784592 

0.100 

1.000 

2.000 

60176.392 

60189.011 

N/A 

5 

5 

60187.011 

796272 

0.100 

1.000 

2.000 

60176.713 

60187.154 

N/A 

6 

5 

60185.154 

807952 

0.100 

1.000 

1.111 

60177.015 

60179.735 

N/A 

7 

5 

60178.624 

819632 

0.100 

1.000 

2.000 

60177.374 

60181.281 

N/A 

8 

5 

60179.281 

831312 

0.100 

1.000 

2.000 

60177.651 

60189.236 

N/A 

9 

5 

60187.236 

842992 

0.100 

1.000 

0.200 

60177.971 

60183.258 

60178.022 

9 

2 



»»»>» The Time Now is 
Durations 

Task ID Mandatory Optional 

=> 60178.069 Periodic Dtilization Budget => 5.00E- 

Time 

Remaining Start-Time Deadline Started-At Importance 

•01 ««««< 

Latest 

Status Start-Time 

749552 

0.100 

1.000 

0.749 

60175.363 

60179.886 

N/A 

2 

5 

60179.137 

761232 

0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 

3 

5 

60184.718 

772912 

0.100 

1.000 

2.000 

60175.983 

60186.558 

N/A 

4 

5 

60184,558 

784592 

0.100 

1.000 

2,000 

60176.392 

60189.011 

N/A 

5 

5 

60187.011 

796272 

0.100 

1.000 

2.000 

60176.713 

60187.154 

N/A 

6 

5 

60185.154 

807952 

0.100 

1.000 

1.111 

60177.015 

60179.735 

N/A 

7 

5 

60178.624 

819632 

0.100 

1.000 

2.000 

60177.374 

60181.281 

N/A 

8 

5 

60179.281 

831312 

0.100 

1.000 

2.000 

60177.651 

60189.236 

N/A 

9 

5 

60187.236 

842992 

0.100 

1.000 

0.164 

60177.971 

60184.258 

60178.022 

10 

2 



>>»»»> The Time Now is 
Durations 

Task ID Mandatory Optional 

=> 60178,335 Periodic Dtilization Budget => 5.00E- 

Time 

Remaining Start-Time Deadline Started-At Importance 

01 ««««< 

Latest 

Status Start-Time 

749552 


0.100 

1.000 

0.749 

60175.363 

60179.886 

N/A 


2 

5 

60179.137 

761232 


0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 


3 

5 

60184.718 

772912 


0.100 

1.000 

2.000 

60175.983 

60186.558 

N/A 


4 

5 

60184,558 

784592 


0.100 

1.000 

2.000 

60176.392 

60189.011 

N/A 


5 

5 

60187.011 

796272 


0.100 

1.000 

2.000 

60176.713 

60187.154 

N/A 


6 

5 

60185.154 

807952 


0.100 

1.000 

0.926 

60177.015 

60179.735 

N/A 


7 

5 

60178.809 

819632 


0.100 

1.000 

2.000 

60177.374 

60181.281 

N/A 


8 

5 

60179,281 

831312 


0.100 

1.000 

2.000 

60177.651 

60189.236 

N/A 


9 

5 

60187.236 

842992 


0.100 

1.000 

2.000 

60177.971 

60184.258 

N/A 


10 

5 

60182.258 

854672 


0.100 

1.000 

0.200 

60178.301 

60182.336 

60178.324 


10 

2 


»>»»» 

The Time Now is 

=> 60178.432 Periodic Dtilization Budget 

=> 5.00E- 

01 ««««< 



Durations 

Time 







Latest 

Task ID 

Mandatory Optional 

Remaining Start-Time 

Deadline 

Started-At 

Importance 

Status 

Start-Time 

749552 


0.100 

1.000 

0.749 

60175.363 

60179.886 

N/A 


2 

5 

60179.137 


A-15 













761232 

0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 

3 

5 

€0184.718 

772912 

0.100 

1.000 

2.000 

60175.983 

60186.558 

N/A 

4 

5 

60184.558 

784592 

0.100 

1.000 

2.000 

60176.392 

60189.011 

N/A 

5 

5 

60187.011 

796272 

0.100 

1,000 

2.000 

60176.713 

60187.154 

N/A 

6 

5 

60185.154 

807952 

0.100 

1.000 

0,926 

60177.015 

60179.735 

N/A 

7 

5 

60178.809 

819632 

0.100 

1.000 

2,000 

60177.374 

60181.281 

N/A 

8 

5 

60179.281 

831312 

0.100 

1.000 

2.000 

60177.651 

60189.236 

N/A 

9 

5 

60187.236 

842992 

0.100 

1.000 

2.000 

60177.971 

60184.258 

N/A 

10 

5 

60182.258 

854672 

0.100 

1.000 

0.146 

60178.301 

60183.336 

60178.324 

11 

2 



>>>>>>>» The Time Now is => 60180.039 Periodic Otilization Budget => 5-OOE-Ol <«««<< 

Durations Time Latest 


Task ID 

Mandatory Optional 

Remaining 

start-Time 

Deadline 

Start ed-At 

Importance 

Status 

start-Time 

749552 

0.100 

1.000 

0.749 

60175.363 

60179.886 

N/A 

2 

6 


761232 

0.100 

1.000 

2,000 

60175.674 

60186.718 

N/A 

3 

6 


772912 

0.100 

1.000 

2,000 

60175.983 

60186.558 

N/A 

4 

6 


784592 

0.100 

1.000 

2.000 

60176.392 

60189.011 

N/A 

5 

6 


796272 

0.100 

1.000 

2,000 

60176.713 

60187.154 

N/A 

6 

6 


807952 

0.100 

1.000 

0.100 

60177.015 

60179.735 

N/A 

7 

4 

60179.635 

819632 

0.100 

1.000 

2.000 

60177.374 

60181.281 

N/A 

8 

6 


831312 

0.100 

1.000 

2.000 

60177.651 

60189.236 

N/A 

9 

6 


842992 

0.100 

1.000 

2.000 

60177.971 

60184.258 

N/A 

10 

6 


854672 

0.100 

1.000 

2.000 

60178,301 

60183.336 

N/A 

11 

6 


878032 

0.100 

1.000 

0.200 

60179.983 

60184.180 

60180.036 

1 

2 



>»>»>» The Time Now is 
Durations 

Task ID Mandatory Optional 

=> 60180.101 Periodic Otilization Budget => 5.00E- 

Time 

Remaining Start-Time Deadline Started-At Importance 

-01 ••«««« 

Latest 

Status Start-Time 

749552 

0.100 

1.000 

0.749 

60175.363 

60179.886 

N/A 

2 

6 


761232 

0.100 

1.000 

2.000 

60175.674 

60186.718 

N/A 

3 

6 


772912 

0.100 

1.000 

2.000 

60175.983 

60186.558 

N/A 

4 

6 


784592 

0.100 

1.000 

2.000 

60176.392 

60189.011 

N/A 

5 

6 


796272 

0.100 

1.000 

2.000 

60176.713 

60187.154 

N/A 

6 

6 


807952 

0.100 

1.000 

0.100 

60177.015 

60179.735 

60180.099 

7 

2 


819632 

0.100 

1.000 

2.000 

60177.374 

60181.281 

N/A 

8 

6 


831312 

0.100 

1.000 

2.000 

60177.651 

60189.236 

N/A 

9 

6 


842992 

0.100 

1.000 

2.000 

60177.971 

60184.258 

N/A 

10 

6 


854672 

0.100 

1,000 

2.000 

60178.301 

60183.336 

N/A 

11 

6 


878032 

0.100 

1.000 

0.166 

60179.983 

60184.180 

N/A 

1 

6 



A-16 






Appendix B. Periodic Priority Assignment Methods Investigated 


Using rate monotonic theory to schedule the periodic tasks requires that priorities be assigned based 
upon the i)eriod of each task. In theory, this sounds simple, but in practice, additional problems arise. In 
particular, a problem arises when there are more periodic tasks than there are periodic priorities. The 
investigation undertaken to solve that problem is outlined in the following sections. 

B.l. Periodic Priority Assignment Problem and Potential Solution Methods 

The problem of assigning priorities to periodic tasks is compounded by the dynamic nature of the 
system. At any one time there may be only a handful of tasks, with more than enough distiiKt primities to 
assign a unique priority to each task. At other times, there may be many more periodic tasks than periodic 
priorities. When this condition occurs, the problem becomes one of determining which tasks to assign to 
which priority 'bin'. The problem is better illustrated in figure B.l. 

By examining the figure, four possible groupings for the tasks stand out. This tends to put a large 
number of tasks into the priority bins for tasks of shorter periods and hardly any in the priority bins for the 
ta«ks with longer periods. A solution might be to assign tasks based upon some predetermined method or 
try to calculate the best method for the current situation, b is possible for the situation shown above to be 
reversed, and have a large number of tasks with long periods and only a small number of tasks with short 
periods. Four methods were developed to handle the problem under different conditions. No attempt is 
made to determine which is the best, rather this research illustrates that different solutions are possible and 
should be examined in future work. The fom methods developed are called Static, Linear, Normal 
Distribution, and Simple. 

The simple method is for the trivial case were the number of periodic tasks is less than the number of 
periodic priorities. A count of the number of currently active periodic tasks is always maintained by the 
system and the simple method is always employed if it can be. This method meets the theoretical basis 
used in the rate monotonic algorithm and assigns each periodic task a distinct priority and is the ideal 
method of assigning priorities when using the rate monotonic algorithm. The other methods are described 
in the following sections. 


B-1 





Figure B. I Example Periods of a Task Set 

B.1.1. Periodic Priorities Normal Distribution Method. The Normal Distribution method is 
designed around the assumption that the periodic task's periods will, as the name implies, have a statistical 
normal distribution. Thus, the middle priorities have more tasks than either the highest or lowest priorities. 
There is no empirical basis for this assumption and the purpose of implementing it is to show how 
statistical distributions can be used to help assign priorities in a dynamic system. Other distributions are 
likely in any given domain. Hguie B.2 illustrates the concept. 

The algorithm used to implement the normal distribution method uses the standard formula's to 
calculate the mean and variance [Allen, 1990]. The mean and standard deviation can be quickly calculated 
with each new task that is added or removed. Once they are calculated, the values of the periods that 
belong to each priority bin are calculated by dividing the spread between ± 2 standard deviations from the 
mean by the number of periodic (niorities minus two. The highest poiodic priority is used for tasks with 
periods that are less than 2 standard deviations below the mean period, and the lowest periodic priority is 
used for tasks with poiods that are greater than 2 standard deviations above the mean period. 

B.I.2. Periodic Priorities linear Methor. The Linear Method of assigning periodic priorities is 
illustrated in Figure B.3. The basic idea is to assign poiod ranges to the different priorities using a straight 
line equation generated by using the task with the Icmgest period. Note that the periodic task with the 
longest period is simply the task at the tail of the Tasks_By_Period_Queue. 


B-2 






















Number of Tasks per Priority 



Priority 


Figure B.2 Periodic PriOTities Using Normal Distribution 


Maximum 

Period 



Priority 


Figure B.3 Periodic Priorities Using Linear Method 


B-3 






The sl(^ of the line generated by starting at the origin and proceeding to the maximum period (refer 
to Figure B.3), is simply equal to the maximum period divided by the number of periodic priorities. Once 
this slope is known, calculating the range of periods associated with each priority is a matter of plugging 
each priority into the straight line equation y = /rax, wdiere x is the priority and /n is the slope calculated 
above and assigning the result as the maximum period for any task with that priority. 

Unlike the Normal Distribution method, this method assumes that task periods is evenly distributed. 
The result of using this method is to split the tasks into the different priority bins so that the higher priority 
bins have fewer tasks than the lower priority bins. 

B.1.3. Periodic Priorities Static Method. The Static method differs from the other two in that the 
spread of periods assigned to each priority is defined before the system starts executing and does not 
change while the system is executing. Figure B.4 below illustrates the Static Method. The static method is 
clearly the most efficient, both in its memory requirements and its execution speed. The tradeoff, of course, 
is dealing with widely varying task sets with widely varying periods. 

To determine which method is best, an analysis of the results of each method will have to be made. 
It is important to remember that the problem these methods are designed to handle is more tasks than 
priorities. The initial guess is that given some random task set, the static method has the least distribution 
of the tasks over the available priorities while the linear method has the best 



Priority 


Figure B.4 Periodic Priorities Using Static Method 


B4 






B.2. Evaluation of Priority Assignment Methods 


Perhaps the area of greatest misdirected effort was in the thought and development of the differing 
methods to assign periodic priorities. The assumption was that assigning priorities to insure that the rate 
monotonic theory held would be difficult when the number of tasks, exceeded the number of priorities. 
Complicating the issue was the belief the unknown spread of periods might make it difficult to spread tasks 
effectively over the available periods. This is indeed a problem if the periods for each priority are assigned 
statically, but as was discovered, can be simply done dynamically. 

Before the discussion of the results of testing the various methods, a note about the graphs included 
in this section is necessary. First, there are two types of graphs included. The first type shows the period of 
a task versus its assigned priority. The second graph types shows the number of tasks assigned to each 
priority. In addition, there are four graphs for each priority assignment method; static, linear, normal 
distribution, and a new method developed during this testing. One set of two of the graphs for each method 
reflects the condition when both the mandatory part and the optional part of all the periodic tasks has been 
scheduled (i.e. a non-overloaded condition). The other set of two reflects the condition when only the 
mandatory part of some periodic tasks are scheduled (i.e. an overload condition). Graphs showing the 
middle condition, where some tasks are scheduled to execute both their mandatory and optional parts, and 
some only are scheduled to execute their mandatory parts, are not included because the priority assignments 
are identical to that of the all optional condition. The difference lies in the execution mode assigned each 
task, not the priorities. 

As mentioned above, results show a lot of unnecessary effort was put into this area. The belief that a 
serious problem may develop if priority bins are defined statically is, however, well founded. Figure 6.2 
thru Figure 6.5 clearly show the problem. Because, the size of each priority bin has been defined statically, 
it obviously does not handle a dynamic set of tasks well. Note that in both Figure 6.3 and Figure 6.5 only a 
small number of the available priorities are used. This can potentially lead to a significant problem when 
using rate monotonic theory, essentially lowering the utilization levels needed to insure the tasks will 
complete by their deadlines [Sha, 1989]. 

There are some factors that can be used to improve upon the static method. First, for this thesis, 
periods are generated using a random number generator. In any “real" application, periods would be 
assigned based upon some definable criteria. It is clearly possible to better match the static priorities to the 


B-5 





particular system. Note, however, that at any instant in time, it is still possible to have a very uneven 
distribution of tasks to priorities. I would suggest abandoning static priority assignments altogether for any 
ccHitinuadcm of the work in this thesis. 

Figure B.9 thru Figure B.16 show a sample of the test results of the Linear and Normal E)istribution 
methods developed. In Figure B.9, Figure B.l 1, Figure B.13, and Figure B.15, the slope of die line shows 
that indeed priorities are being assigned conecdy (i.e. rate monotonically). However, Figure B.IO, Figure 
B.12, Figure B.14, and Figure B.16 show that the distribution of tasks to priorities, although much better 
than the static method, is very uneven. The results of these distribution methods on run time performance 
can not be accurately ascertained with the current implementation, but from the prospective of effective 
utilization of available pri«ities, this approach is unacceptable. 

Analysis of the graphs in Figure B.9 thru Figure B.16 lead to the development of a much simpler 
priority assignment method. The “new” method simply takes the number of tasks and divides by the 
number of priorities. The integer result of that division is then used to assign that number of tasks to each 
bin. Any remaining tasks are assigned the lowest periodic priority. This approach eliminated the need to 
maintain an array that held the allowable values for eadi priority given the current task set. In addition, the 
calculation of that array was eliminated. Thus, the “new’ method is simpler, more time efficient and more 
space efficient. The results from a run using the new method are shown in Figure B. 17 thru Figure B.20. 

Note that there is problem still in the implementation when an overload condition occurs as shown 
by the spread of priorities in Figure B.20. The problem stems £",/m using the fact that the routine to assign 
the priorities uses the total number of periodic tasks currently in the system, instead of the number of 
periodic tasks in the queue it is passed to assign priorities to. The fix is relatively simple and will be 
implemented in future versions. 


B-6 







Figure B.5 Period vs. Priority, Static Method, All Optional 



Priorities 


Figure B.6 Tasks per Priority, Static Method, All Optional 


B-7 



















































Priority 

























































90 

85 

80 

75 

o 65 
“■ 60 


50- 


454 


40 ^ 


is 











tig 

ii-i_ 






















SHI 










■1 

SSi 










-T 

EES 












*11 


j 









H44. 

j 





















23456789 10 

Period (Seconds) 


Figure B.9 Period vs. PriOTity, Linear Method, All Optiraial 



Priorities 


Figure B.IO Tasks per Priority, Linear Method, AU Optional 


B-9 



































Period (Seconds) 


Figure B.l 1 Period vs. Priority, Linear Method. Some Mandatory 


120-j- 

inn 





III 




- - 

■1 

III 

III 

II 

II 

Ml 




.■g ou- 

.2 

"C 

CL 

60- 





III 





Q. 

a An 

III 

III 

II 

1 

III 



mil 



III 

III 

II 

II 

III 





■ 

Pn M 




III! 



mil 

11 


1 1 1 1 1 1 

■ fi. ^ ' 

1 1 1 1 1 1 
iT FT S' ; 
£■ sS. £• J 

1 1 

L ^ 

1 1 1 

g 1 

1 1 1 1 1 

S’ ” Co- 
>. ts. Cl 

1 1 1 
lo- G 
C 

1 1 1 1 

1 1 1 1 

1 i ! 

1 1 


Priorities 


Figure B.12 Tasks per Priority, Linear Method, Some Mandatory 


B-IO 





































Task per Priority ^ ^ 



0123456789 10 

Period 

Figure B. 13 Period vs. Priority, Normal Distribution Method, All Optional 



Priorities 

Figure B.14 Tasks per Priority, Normal Distribution Method, All Optional 


B-11 













































































Task per Priority Priority 


90- 

80- 






704 
60 
50 






'+4<. 


nrF 








404 


304 
10 
10 
0 




MM 




MHr 


I ■ II I 

f"rr 


I ! I 11“ 


23456789 
Period (Seconds) 


Figure B.15 Period vs. Priority, Norma! Distribution Method, Some Mandatory 



Figure B.16 Tasks per Priority, Nonnal Distribution Method, Some Mandatory 


B-12 
























































Tasks per Priority Priority 



Figure B.17 Period vs. Privity, New Method, All Optional 



Figure B.18 Tasks per Priority, New Method, All Optional 


B-13 















































































Task per Priority 



B-14 















































Appendix C. IRTS Demonstration System User’s Guide 


Hiis q)pendix explains how to compile and use the IRTS feasibility demonstration code. The first 
section details the system requirements, reconsnended library stmcture, and conq)ilation order. Ihe second 
section contains the source for the feasibility demonstration system. The source code is included for 
reference only and is not intended to be “production quality code”. Chapter 6 of diis thesis has pointed out 
a number of deficiencies and recommended the changing some of the data structures used. Any future 
work should address diese issues before continuing to use the demonstration code. 

C.l System Requirements and Compilation Order 

The IRTS demonstration system requires Veidix Ada 6.0 in order to compile. It uses the Verdix 
supplied task management procedures Suspend_Task, Resume_Task, and Set_Priority. To use these 
features, it is necessary to link in the Verdix library V_XTasking. In addition, CLIPS/Ada is used as the 
Reasoning Process and also must be compiled and Imked to the users library. Also, the Booch component 
files Storage_Manager_Sequential, Deque_Priority_Balking_Scquential_Unbounded_Managed_Iterator, 
and Mrmitor are required. Figure C.l shows the recommend directory stmcture. 



Figure C. 1 Recommended Directory Stmcture for IRTS Demonstration System 


After creating a new Verdix Ada Library in the IRTS Source Code directory, modify the file 
“ada.lib” to reflect the locations of CLIPS/Ada and the required Booch components. In addition, the 


C-1 












“vads_exec” library should be linked in. An example ada.lib file after these modifications should look as 
follows: 

!ada library 

ADAPATH= /usr/vads6_0/verdixlib /uar/vads6_0/standard /usr/vads6_0/vads_exec 
ADAPATH= /home/hawkeyeS/mawhelan/Booch /home/hawlceye3/mawhelan/CLlPS_Ada 

Note that the third line reflects user specific locations for the CLIPS/Ada source code and Booch 
components. These locations should reflect the actual locations for the users directory stmchue. 

To compile the IRTS demonstration system, first compile the CLIPS/Ada source code (refer to the 
CLIPS/Ada manual) and the required Booch components. After those flies have been successfully 
compiled, die IRTS flies should be compiled in the following order: 


random.a 

get_tcb.a 

global_data_types_spec.a 

flnd_tcb.a 

suppoit_functions.a 

feasible.a 

task_control_buffer_spec.a 

p_tasks_<_p_priorities.a 

periodic_tasks_spec.a 

p_tasks_>_p_priorities.a 

any_time_tasks_spec.a 

PP_by_inq)oitance.a 

singular_tasks_spec.a 

soine_periodics_optionaI.a 

taskjmanager_spec.a 

assign_periodic_priorities.a 

reasoning_pn)cess_spec.a 

scbedule.a 

io_process_spec.a 

un_schedule.a 

task_controLbuffer_body.a 

non_periodic_conipleted.a 

periodic_tasks_body.a 

modify.a 

any_time_tasks_body.a 

niodifled_feasible.a 

singular_tasks_body.a 

dispatch_tasks.a 

task_niam^er_body.a 

print_periodic_tasks.a 

useifun_body.a 

print_non_periodic_tasks.a 

reasoning process body.a 

print_test_times.a 

io_process_body.a 

record_times.a 

task_nianager.a 



The IRTS demonstration system makes use of a file called “test_rp_rales.clp”. The file contains die 
CLIPS/Ada mies diat drive the Reasoning Process. In addition to all the functions available in CLIPS/Ada, 


C-2 







a number of additional functions used to communicate with the Task Manager are available. The Task 
Manager functions are as follows (all times are given as a real number of seconds from midnight): 

• (addjask <display flag> <task type> <procedure id> <period> <deadline> 

<starttime> <importance>) The display flag is a boolean value that instmcts 
the task to print out its start and stop times while executing, task type is either any-time, 
periodic, or singular, procedure id is the identifier of the procedure within the task type package 
that this task shell is to use. period is the value to be used as the period. ITie use of the deadline 
value depends on the task type. If the task type is periodic, then flie deadline is the stop time for 
the periodic task; otherwise, the deadline is the time by which a task must provide an answer. 
start time is the time when the task is eligible to start execution, importance is the task's global 
relevance in relation to all other tasks. The procedure returns an integer value that represents the 
task’s id. It must be used to refer to the task whenever the modify or remove procedures are 
used. 

• (modify task <display flag> <period> <deadline> <starttime> <importance> <task id>) 
The parameters should reflect the new values desired. The old values should be used for those 
parameters that are not to be changed. 

• (remove task /d>) This procedure simply removes the specified task from the currently 

active set. 

• (newjjeriodic utilization <value>) value is the new amount of processor utilization to allot for 
periodic tasks. It should range between 0.0 and 1.0. 

In addition to these procedures, the Task Manager also communicates with the Reasoning Process by 
asserting facts into the CLIPS/Ada fact base. The Task Manager signals infeasible ta.sks, missed deadlines, 
completed tasks, and its ciurent status through facts. The facts asserted by the Task Manager have the 
following forms: 

• (infeasible task <task id>) This fact is asserted whenever a modify or add operation has tried 
to assert an infeasible task as described in Chapter S. 


C-3 





• (missed deadline <task id> <time>) This fact is asserted whenever a periodic task does not 
complete its execution during its period or a non-periodic task fails to complete its execution by 
its deadline, time is the time at which the missed deadline was detected. 

• (taskjnanager status <time> <PU> <MU> <OU> <RU> <periodic condition> 

<ffperiodic tasks> <ttnon-periodic taslcs>) time is the time at which 
this status report was generated. PU is the current periodic utilization. MU is the utilization of 
the mandatory parts of die current periodic task set. OU is the utilization of the optional parts of 
die current periodic task set. RU is the utilization required given the curroit number of periodic 
tasks and die current budgeted utilization, periodic condition is either SOME_MANDATORY, 
SOME_OPTIONAL, or ALL_OPnONAl. as described in Chapter 5. ((periodic taslts and 
((non-periodic tasics are the number of currently active tasks of each type. A status report is sent 
after an Add_Task, Modify_Task, RemoveJTask, or Change_Periodic_Utilization entry is 
called. 

C.2 Source Code 

The source code developed for this research effort follows. The purpose of its inclusion is to allow 
future researchers to see a concrete example of how the architecture outlined in this thesis has been 
implemented. No attempt has been made to make die code robust or tuned for optimal performance and no 
such claims are made. The source code should be used as a guide for any future research efforts and not as 
a fully developed Intelligent Real-Time System. 






MOO $ 
OGO 0 > 
u n 
<« O. 

M U 

«o c 
c*-- o 



§ t 


to (0 
>*0 

e B 


o 

to Of*) . •» 
-H -OOffiO 
r* ^ r* • 

<0 ® ^ f** 




s 

i 

• i<« 

O' cije 

4 « 0 
je 9 i« 

U U Oi, 


9 OJrf 
O' M « 
9 Oi i 
JC fr- 
0 o • 

9 M 9 

X 

Ch M M 

9 O' 9 

8.SJ 

OCX. 


ft, . o» 
19 9 

■4 

M 

O' 

O' 

9 9 U 

:> 


6 g®*! 

u 

M 0 1 

“■iS-S 

•M 

>1 
«) *J 

M ce M 


o2s5 

HM 

ce M 

0'9 9 


•e 


n.: 

o 4 O' 

M M i 

0.£kj5 


O M !»• 
Cl vy 
<0 f«H 
• o ice 
e ce M fH *-4 


I i 


-8 

£ 

I 


*J u 

m o 

M*M 

b 

s-a 




> 9 
to iJ 
J1 9 


■as 2 


8. ^ 


2. ? 


8 . 

f. 


8 . & & 


I 3. 


C-5 














M 

• • IV 

(V ««-l Ji« 

C'M o 
O 9 <V 
-H 00,0., 

4-i I I 

U •« 

C O « 
a V* O'O' 

«b.,^ IV c « 

tC C-H M 


taM 

a u 

O IV 
H O- 
^ < 
y M •* 
C O 
a O'O' 
U.,<V G 

_ _- IC-H 

T 3 u ui.ca'O M a,<a 

CO |iv c o |iv 

0 a»3i<^ H H 

«-<a<aax^a<ax. 

iv a <v IV iiv a <v l 


i3 

9S4J 
H <V 
IM 

•sa 

• o 

ca 

8." 

>«• 

^i8. 
iV >, 
U H 
« i 

:■! 

J3 I 

O >1 


I 

« <*. 

M • 

*M (V Q 

a -H M 
ca M I 

-• >.» 
o i« 


cw s 
o c-« « 

o. \U 

J*q>, 

(a<>C<o 

A A 

» ‘ " 

• K 

“I-* 

<1 «J C 

-H •»« t-t 




kAAAAAAAAAAA/ 


A A A A A 


IV 

> » 

|IV 


H » *i 
IV IV 

>. CV M k4 


.. *i 
H.iV IV 
|U M 
>.3 3 

S“° 

V 4-> 
C 3 3 
H 0 O 


ii; 


V 9 

e 3 3 3 o c c 
-^ 0 0 0^00 


9 C C iV -J 9 

.HO o o>oo, 

H H I • I 

iv • e ^ 

•H X IV IV 4 o. 

U 9 u ut^XO 
« IV IV 3 a 

• 9 • C 9 

IV a9 

3 H H s O-H 

^ .. 


5S 

0*3 


ss 


9 U 

*H *J •«. 

J3 a. 

10 ba 

'H.X l-t 
M 9 I 
10 9 
> i-.,9 

I »9 

“ 1 H C C 
1*00 
■ B -H H 
H H® 4J *i 
I |4J 10 <V 
>, >, 9 M M 

SiS!SS 

4J 4 } 4.1 

e a a a a 
•H o o o o 


• M c C 

.H 4J O O O 

■3 *^1*^1** iJ 

-H JO JO 9 9 
M 9 9 M U 
9 9 9 3 9 

H H H X O 


9 JV 

K 

-H B 
H • 
I 4 J 
>« 9 

c c 


-H JO 

M 9 
9 9 

>1^1 

JIJ 


8 


•§ 

8 


C-6 






























^ * 

o,-* 

OA 


• a 

a o 
c o 

-H hj, 

■M I 

C >< 
O n» 
o 

<s £ 

o i 

-H C 

ia a 

(Q 06 


ca ca 
<a<H 
E-< O 


c -u • 
o cZ 
•H o 

4J 0*0 • 

:H <H >> 

T? a a «J 

C 4J O -H 
O OJ::^ 
U <i « <6 

0 >>i<a §• 
C 

•H *J O C 
a.-H o 
ao .pH 
O H H 4J 

♦i-sTj a 

« 0<C>H 

X o o 

>•« u ca 

C M h c 

o « « g 
O'x: o. 
« <« 4-* a 
A co_ 

13 *9 

) O U Of 

= sa-“ 

4J H <<*0 
JS b« O 
0> ® 'O 
OTJ 
06 4J -P « 


li 

•H a 

H,0 

P « 
P o 

**■ 02*^1 

J 16 9 (/).M 
UX CO 
OP » <0 

U >.8^1 
• « H >» 
P'H H X 

9 a I 

■o « >. 

C -H C 
OOioS 

■H • 

u • 

.‘.II 

•W H. 


i 9 p 

>1® 

ax-H 


TJ-HTJ 
C X c 

000 


a O' 
P c 

• -H 


>ip 

X o 
3 c 


a « 

9 (• 


I 

hi <s >\ 

9 9 •« C 

U3 « ^ 

3 H a I 
X.O O 
I I t (O-H 
I t I > 'P P 

•oS 

9 ^ 


>ra *'* 

li^gg 

-p -p fi "p -p 
9 P P 
) tP 9 (0 
>*>t« P P 

c c >ta a 

«<tQOO 
p p 4J P 

c a a a a 
■p o o o o 


9 P c c P 
^ P Q o o P 

jaouH-i-p -po. 

9 Mp p I 

■HMM 9 taM 

p (B e p p tt 
9 9 9 3 9 9 

^rrppri 

H H H X O -P 


9 P 

ica, 


!-• P P 

1 9 a 

X>.Q, 

G I I 
•<9 C •••> 
U: 9 p 
U H X p 

-p 

p'-' 




J 


3 9 

9P 

C P 


• I 

P P M 

p P ta 

CU.O 4 . 9 9 
I I HP 
a O. 19 
B a 9 9 

9 9 X P 

C H H HU 


9X 

>9 

19 


9 Q 

S’“i 

9 JO 

•P ca 

p 9 

9 H 


>>ca X 

Sir 

P c 

C C IP M 

•p -p i I 

9 9 
•• •• J3J3 
HH 


9 9 
9 9 


S. i 


SJ! 

p ja 
p 9 •% 
9 p 
> p ca 
19 JO 

|="iS 

o 9 
XB i 

S 9-3 

06 H 


O O' 

SJ 


TJ X 

iS 


S. 

& 


•%P 

' 'q'S 

Sg^i'S 

■P -P JO 9 
HH 9>. 
• • 9 I 
P P H 9 

9 9 P ^1 
pp <a >> 
9 9 >1 c 
u u CO I? 


9 OP 

IH CO P 
P ^9 9 
p aH> 
9 0 11 


•P IP "O 

P I 

9X 

> ca 
19 

9H C C 
S • O O 
•P B "P 'P 
H,9 P P •• 
IP 9 9 
>. ca P P JO 

S >. a a <0 

<0009 

H. 

P P P 

a a a a P 
•H o o o c 

9 


9 c c u •« 9 

P Q O O • p 
^ M-p-p 

^ Ip p c ca ca 
•pjo 9 9 -p H e c 
p ca p PJO JO POO 
99aaca«a9-p-P 
> H op 9 9 > P P 
I I I IpH, 19 9 
99CPX |9PP 


9 


H H a 


I I a I a 

9 C C ’• 
0 9 0 0 
Q M P -P p 9 

9 9 P 
JO 9 P P P P 

9 9 p a a 9 


c 9 P 

S a 
9 9D 


) p 9 

’£1 


> B 

X 9 h. 
9 P • O 
P 9 9 O 

Jl >-6 .. 


9 C D B 

•P a. 

H P U P 
0 9 -P 
X P > 

I S.9J0 




P P 

c a a 

•POO 


TJja a 

9 P 9'- 
9 CP 
3 3 0 9 
0 0 9 
9P P 
•pp p* 

9 O 

> e 9 

a-o 

0P*0 O' 

O 3P C 
P O 3P 
3 O P 

9 3 9 I 

P p P t 

-p c P a 5 

•Sirs < 

• 9T) 9 < 

9 9 gp ( 

P O J 

P 9X C. 

9 9 9 

JS X9 9 * 

P 9 P 9 ( 

9 J 9 ^ \ 

p*0 p p pc 

o JS a o < 

x<<p a 9 

1111119 
I I I I t I 9 


I 9 9 

-p .p .p 99 
HPP XX 
19 9 HH 
><P P 

S 3 3 » * 

““ STp 

O 9 

P C 

■3-2 

.. C P 

H a 
9 9X0 

9 c c 9 

P O OP'"'"*' 
X -P -P ^ 

^ p p 9 9 9 
-P 9 9P c c 

b M M H O O 
9 3 3 9P P 
> O O > P P 
I I r 19 9 
9 9 C P 9 P P 

9X9 a a •' 

PHXC'"''^ 

X 


SOHOO 


1 




HP 

1C 

ao 


^ 9 9>. 
-P P P I 

p a a 9 
9 0.0.0* 

i ax 
B ou 


..-a 

•p 
M U 
O 9 


!8. ‘^i 

IP P P 


C X 

^S 


8x 




OP 
p p 

Si 


is 

•p p 

^r3 

P C 


S ~ 


I 


X 9 8x 

ox P 9 
O P H 9 
P 

U XX 

-3?-^ 

C-P 

•5°s 

9 9P 

U 9H. 

P I 
a X p 
-x 9 

•p p 

§ p 9 
9P 

>. 0 * 

H, 9 •* 

XC6 - 

ax 


C-7 


















c O 

9 0 cL 

CQ-H >1 

H 

O •«. I 

O C (0 

M 9 0> «J 

*ib4,C « <0 

C H Q 

™ I . o -M Jg I 

•O^ e u M ca-d-H 
c <a « to <« — 
4J O.H 


u o. 


b*C O. 

M 

_ M « T3 

C (Q O O <« O 

4J ai-> A 


.099 axw o 9 ax 

>(0 3 N'H >3 t 

uu(ne>(/)>(JUv)<A> 


I ( ( I ( 


(« u 
(0^ 

H-* M 

*JAtu 
9 O 

0 

W> O CT* 


Sa) 

>t9 

H-H 

IM 

u « 

o u 


.<« 

9 9 O' (0 
‘”♦^9-0 
O O a O 
O O C-» 
CO CQ •-• O 


c <0 *d 

M 

a o 


Oh "I h u o & 

M O 

9 9 0 

aou 9 
> M 

a 9 

■il 

<« 


&.2 

>>a 


a- 

>(» 

^•a 
<0 >• 
♦it-*. 
« I 
0.0 
M 
^*0 
9 O 
A '* 
o 

^ 9 

o a* 


I 

a -« 
9 

9-h-h 

•M.O 

90 

to M I 
l«J< 
-H>.a 

O (9 
♦« Ut^ 

e 

0 0 9 
0;H +J 
IM a 
^ 9 > 
a a to 
a 

f-* A A 


inomotnomooo 


= §■8 


AAAAAAAAAAAAAAAAAAAA 


*4 I 

mM *0 ♦> ♦> 

> a o (0 9 
la -H M u 
O C C »4 3 3 
>0 0 900 
^ B H H a. 
o 9 ♦> ♦* *j *j 
-4 ♦i *0 (0 C 3 3 

M a M -4 o o 

9 >3 3 

Ck. too O. 

♦i ♦i V a 
C 3 3 3 9 C C 
•H O O O-H O O 
J3-4 "4 

.. .. 9 ♦> 4J 

•Ham 
a h w 

9 C C 9 3 3 
•H O O O >,0,Q, 
J3MHH I \ I 
9 ♦i v 9 C «i 
-4 9 9 iS 9 a 

b a U Vi H X O 
9 9 9 3 3 

■o^ppr 

U 9 9 C a a 
' - - ^ a9 

.. 


t> H H a 


9 k4 

•H M 

Mai •« 
9 9X 

>,H.a —. 

I 19 

O O H C C 
•H-H >00 
^•O B -H-H 
o O 9 a ♦i 
--4 -4 Vi 9 9 
M M a M M 
9 9 >* 3 3 

a b* to o Q 

♦i ♦i ♦> ♦> 
C 3 3 3 3 
•H O O O O 


9 M e c 

-4^000 
ia o. M-.4 -H 
9 v> 'P 
9 9 
M a a M M 
9 9 9 3 9 

=*rri“,“i 


9 

>.a 

9 

OH 

^ B 

O 9 

•H *J 

u a 

9 > 

cv to 

B B 


M a 
9 9 


JSJJSJK a 

HHHXO 9 -H 


U --4 
9 *J 
C-4 

5S 


>P 
P B 

9 


C-8 


tafik body Generic_Periodic is 

Start Time : Calendar.Time 





























a 


I |(D 

U U H C C 
jH:H • O O 
■0*0 e -H-H 
o O O 4 J -P 

•H -H P (fl (0 

U M (ft M M 

« • >,3 S 
ch cb 0) Q a 

p p p p 
C 9 9 9 S 

-H O O O O 


O M C C 

^ P O O O P 

Ua -H-H Ob. 

<a I Ip p I 

■HJirf (Q (Q M 

u ta <0 u u ta 

<9 <Q (Q 9 9 <0 

O • • C P u 

X jCX iS ( 3 . -H 

HHHSO *0 


5 

I 

S S.3 •' 
i ^’iS 5 

0 o>. a 


P o u 

9 P B -H 

*0 B • *0 

S CObCK O 
•P -P 

o *0 P 

18 i £ 


(II j< -P -p 

> a M p 

la a a 

y H c c >,>, 

:d • o o II 

*9 S -P -P « « 

o « P P J3X 

•p p a a •» H H 

p a p p 

« >i 9 3M % • 

cb V) o a a >1 
a p ^ 
p p p fH. o a 
C 9 9 9 I PC 
•p o o o P a o 
c •DP 

.• -.CP 

p a Oi 
a p a z o 

« c c 9 •« « 

^ o o o o -H 

ja^b.p-p .Q^ 

a Ip p D»p a a a 
-pj< a a c H c c 

papp-PJi<poo 
aa 99 J<aa-p-p 
>.H Q.a.a a >.p p 
I 1 I laH, la a 
aacpp opp 
USX a ax.>u 3 9 9 

H H z o a a 

— ^ « I I « 


a c c •* 
o « o o 

QM^ P P 0 


a o a 

9 p c _ a 

«-( o ■•D i 

rP a P -P PC -P 

Ci 3 >«p ca p 
■pa a O. a & 
_pa o SaaD 
*0 px a a 9 Xab 
aap-PC papo 
c > -pa 
a-p o a p o p a 
oaap-Ha apos 
O P'D X 9 b. 9 

-PCO-pa—• • e a 

oza-pa >ia c 
ay • 9 p> ap <0 
•p ava -paay 
X a.H a > a a >6 
pao X 'oa-pp 
^paap • pa 
»JQ P P *0 K7‘ 9 

o a c_ o o a es> fi 

C P O *0 £ p -p Ob 

p u a • H p u p 
pa pa-H oa -p 
9 > a a'H a z p >« 

M xao 9 _ac* 
ap s p V V A0M 
ax pa CO a 
pp<pac a aa 


o • a a a c-h 

D''D aaxa 9 >oa 

_a-*xpp ooa 

*D c o P a a >4 p 

>H-pp 'Ma -p>pp> 
9 bbPC»P» ao 

o a c a • c a 

9*9 ox a Q.'D 

w P • E O-^-D O* 

a a c -p o c 
paa »op -109 p 
a p >.-p » o P 

pagppa a >a 

aflpoax - 4 p >4 

•pyppp -PCP 9 
PP 9^9 Xa-PH 
0 p'Doe >B 

aapc la •^a'Oa 
•(-I a a a >%js p e 

XP_.HPP aa a'M 

o a'D o • p o 
apop •cpaJ^ 
Ckopa—loa aa 
o y *0 a-Px >ia a 
>iapccppapa 
x»p p a a o a -h o 
yo> az-HPaaaa 
afia pgp'o-pp 
x-Hxa'paoo X 9 
uappoo BbxpQi 


a a 

a a 

d c -H-p 
00 XX 
-H -p a a 

p p -p p 

a a M p 
p p a a 
9 9 >>. 

JJ 

a a 

P P XX 
9 9 HH 
O O 


p<P 

a o a 

a c c PC 
-4 00 a o 

X P -P "U -P 

^ P p •« c P 

•p a a a CL 

p p p a £ o 

a 99a 

^1 

a c pa a a 

X a a-p e c 

H £ o p o o 

a -p "p 

> p p 

la a 

a a p p 

a X 9 9 

-p ^00 


a a a>. 

•p p p 

p 9 9 a 
a O.Q.& 
>, c 
le p a 

>• a CLX 
z £ O U 


a a a 

c^ -P 

38, a, 

p I I 

I 

ec ec 


G U I 
X a-p.M 
yx*o a 
o p o a 

—4 P H, 
U >1 P I 

• a a pH 
P'P Ob z 

C-P 

3 eg 

a a -p 
u a H, 


a fl a-p j 

a-4>.o* • TJ 

3 h .la P D* o 

p u c -p 

_ az _ a-p p 

■o o ‘D- 4 X a 

c ppb c a a '^Gb. 

aco-p a a a I 

t-> CL y 
•DX.O-P 
C 10 H 

aa 


C-9 


















(0 Ji< 

a u 

o «o 

•H Ot, 


•w « 

w a> 

« O 

C'M o 
O 9 <0 
•Hoa,o<, 

I I 

§ o « 

^ o> o> 

«(i4,4j <n c 
n Ic - 
« *j o 

t3 w 

CO INC 

« H • ...- 

•X aca QX'H aax. 

<0 9 <Q a N 9 4 I 


9 0'0> 


a 'H Id'H 

l.-s-ssl-s 

i 


, 

I >10^ 
I ,4 

I « 9 

I *oo 


I 

i >ttt 

l^iS. 

I 4 >1 
I U H 
• 4 I 
I QU 
i 14 
I «H 
I 4 9 
i JH D> 
I O C 
I 

I o *n 

t 

t 


i 8. 


I & 

t I I I >t 



4 •« ir>oinoknotnooo.« 

M4 o«-i<-«NNtnr«ooo 

4-4^- — 

'W 40 
9-Ht-l, 

- 

O 14 aaaaaaaaaaaaaaaaaaaa 
MMfi tllNIlBIIHiailllllll 
*» 4 • 

c-H a o o 

0 9 4 

iC 4 
•K-H >1 
4m<o 

4 

H A A 


“i-8 

4 C 


ir 


.j 

*.^iS 

M 0.H, 
4 O I 
■*J *J >* 

muiX 



agS; 

«ti « H. 
b. H I 


£8. 


SS. 




IM 


4 4 4 V 
4 

O O O *i 

o c 
00 a o »-t 


|M 

M 4 4 

4 > >i9 

4 C 




. . O.*/4‘9 O 

C'H^ 4 CO C O 
9 TJ -H O Q -H 4 
VJVMQUX^ifM 
CO ^ 


IS 

4 



M H e C H 9 9 

4 • o o V} o a 

•H B "H -H 
9 4 V «> 

V«j 4 4 B 9 9 

c 4 M M-H O O 

•-« >« 9 9 

(O V) Q O.. 

*i *J 9 

C 9 9 9 4 C B 
-< 0 0 0-^00 
ja-H-4 

. 4 *> *> 

■'4 4 4 

4 h U hi 

4 C B 4 9 9 

-^O O 0>,O.Q, 

«i u> 4J 4 ** •■ 
HX 4 4C 
M 4 M M H 
4 4 9 9 

4 4 B 4 

ujsji 4 a4 

4 H H s O-H 



n 


B 4 

•H N 
Vi^ 

O 4 
•H -H 
M 4J 

5" 

>• 

IS 


•H.W^ 4 4 
M 4 4 M M 
4 4 4 9 9 

=‘rri“i“i 

i5JS8 

HHHXO 


&3 

-S*^i 

(Oh 

4 


S5 

S" 

T5 & 
B >• 


■8 

8 


C-10 


























•O-H 

c « 

a <a 


« (0 
<0 9 


2 $ 


V Q 

(0 O. 

(« a 


® C 
U3 0.® 
4J 9 O. 

« 

® « 3 

u 4J a 

a u 

■H ® ® 
U) 4J J3 
« 


iH a 

X o u 

|0-H 

>>H 

-oS 

s<s 


® (o 

Cl 

U (0 

>,H a 
I ® 

M M {-• C C 
4 ® • O O 
•H •H 6 'W -H 
3 3 O 4J ^ 
Ot 4 4 
C C « M h 
H-H >.3 3 

w) cn <0 O Q 

4J 

C 3 3 3 9 
-H O O O O 


• 4J 
O 4 
»H W 
|3 
MO, 
tt I 

4 *i 

(-a 

lo 


® M 3 C h 
•H cJ Q O O 4J 
A a M W H ck<. 
4 I 4-1 .P I 
4 4J< 
M a « W W 4 
4 4 4 3 3 4 

® « « C P M 
-4 a 4 




• Q 

-H W 

-H a 

P 4 

>^l 

I® 
9 A 

JS H 


1-8 

P C 


9M 

II 

C 4 

•H >« 
CA <Q 


-S.S "r, 

.... ss 

H H 

1=,! 
-HJtf P 
p a M, 

4 4 I 

>.et. P 

I I 3 

c • a 

C-*H P 


4 ^9 

-h3 

• P^ 

> 4-W 

O > P 
e 14 
® p>. 

« 4 I 

• ”3 5 

P 90 
3 C B 
•TS -H • 
g C tA CB 

O O* *0 

^ s 


p 

4 .ii< 

> 05 

14 

P (-> C C 
4 < O O 
M S *H -H 
3 ® P P •« 
CP 4 4 
cap p-K 
H >,3 3 « 
CO cn o a 4 
H, 

p p p I 
C 3 3 3 P 
•P O O O C 


H'-''-' 4 


•H 4 4 -H M 3 C 
P C| P PJ<-a POO 
4433494 HH 
>.f-*P Q.4 4 >.P P 
I I I IP H. 14 4 
• 4 3 P X. I® P P 

X jc 4 a >pa 3 3 

S O > X H Q Q 


•H 

4 

>. 


4 C C •* 
0 9 0 0 

Q M -W -P ® 

M tP P P P 
U< 4 4 4 -P 
.M 4-P P P*H 
4 4 P 3 3 4 
4 H 4 0.0. P 
H. I>. I IP 


C c P 

S a 
4 « D 
« 3X O. 
P 4 P (J 


a 3 
- B VI 
>«« 

4 P ’ O 
-i fa 9 o 
9 >,U 
*o » p *J 
• PM 
C 3 

4 CD a 

■P o> 

H P U P 
0 4 -P 
Z P > 

T) 8.4 J? 

CO 4 


3 » O 4 

O u « 

4 -P P 

•H-H P» 

4 O 

• C 4 

au^ 

O-PtJ c 
O 3'H C 
•M o 9 P 
» p p 
« $4 

^ P ^ 
■P C P 3 

- «*d 4 

4 4 Sp 
P O 
P 431 
4 4 4 

X >i4 • 
P 4 P r 


^IC C 
POO 
4 -P -P 
-H P p 
3 4 4 
CMP 
C 3 9 
•POO 
CO 

p p 
3 3 3 
•POO 


9 9 

JiJZ 

H H 


%-P 

OP 
4 4 
3^1 


c P 
O 4 
•P>, 


a - 


® ® . 

P'O-P P 

0^X3 

z<<p a 


a 8 


4 P PM 
•P 4 4.0 
M M M 4 4 4 
4 3 3 P 3 3 
>.0,0.P O O 
I I 14 -P -P 
® 3 P >,P P 
X 4 a l4 4 
4 |H X O ® P M 

® X 3 3 

-H-— l-< O Q 

III® 

.p »» — --M 

4 4 3 3*^ 

>, • O O-P 

I .p .p .p W 

® X p p 4 

C ^ 4 4 >, 

S P P P I 

P 3 3 ® 
X 4Q.Q.C 

U >. I >3 

is ^ 

P >.4 0>X 

xxoo 


M P 
O 4 

o>, 

M I 
D p 
• 4 
PM 

-3§. 

3 3 
®-P 
MCO 

4 

U I 


3 P I 
M 9 4X 
OXM 4 
O P 3 4 
M CH. 
O >3 I 

PM(0^ 

■3S'- 


Is 

H O 
hP 
P P 

p a 

4 O 
P 

1 no 

: o 

«IP 

3 P 1 
M 9 9M 

OXM 4 
O P 9 4 
M Cl-i. 

CJ >3 I 
• 4-P >1 
PM «) X 

■3 S'- 

CM 

®o 




i r 


15 

H;P 

IP 

P>. 


.'.-as 

•p P 

§ P 4 
4 P 
> 9 


£' 


a'S'" 


'P • 
M P 
P ® 
OM 

O 


a s 


|s.: 

a'?" 


P o 
O 4 

« 


C-11 


Notify Tack Manager optional part ic complete 
















« H, 


X o> 
9 « 
H OS 



O 

u e 
as 


9 w 

0*0 

JJ8, 

O « 




8... ..*'8. 
> o >< 

li § I I 

.• -H J- - 


■o 

B 


S. 

>1 

^1 

■8 


S. 


. i HJ< <« 
4J H « V 
^9 . < (« <« 
Q M Mf-Q 
C I *5 *s ♦ 

o-H*oT> e-< 
•H <4 B B • <« 
• • «JjQ 
<4 <• O 

k4-l (4 (4 >•-♦ 
3 W O OWO 

a 

C B B B C 


" 8 . 

'i§3 


o >« 
1^1 


*'S‘ 

M 3 ( 


3 a 
9 

o av 
M >t 3 
an o 


< « f I I I 


M H H O Q 
>iad, 

<4 Itf III 
^ M a.K J4 

a a <4 o « a 

a 4j 4-> <4 <4 

fx V) V) H H 


M 

o o* 

■o'e 

• •H 
X ' 
■HO 


O 

»H K 

l« 

H 


H !-• a V 
(4 > > <4 a 
Q,M MHO, 

-h'^-8 b J 

<4 B B • a 
ja • • 

a o 

<4 a >.-H 

O u u m O 

B B B B B 


a 

8. *n 

> tf) 

H •»• » 

I « 

T? VO 

B 


8. 

>1 

8' 


as o 

>t> c 

-iS £, 

ao. I 
4J„I ** 
• (4 *0 •• 

* h 0,9 O 

ag-3,-^^! 


Bv) 

a MxH o u 4> 

>.• a-^ • 

V) H U O D <4 O' 
U 14 


0 A a 

• '0 3 


il 

<4 M 

-H • 

ss 

H 

SS' 

OC 06 

9 9 

M U 

%% 

8! 


m 

IH 1“ 
>» ♦ • 
• MM 

3-38 

O B B 

• • 


au u 


MM >vX 

V u a u 

O OxH O 


M M «> M 

33S-3 

B B M B 


S3 


■O 8 gaj 

M M 0»M4< 
a «4 o a « 
« M 4J « a 

H «n (O H H 


3 3 


- § 


ao 

•H Ml 

oq' 

I I 


•S' 

i 


8 . 8 . 

<4 <4 

U U 

83. 


M B 

• O 

o>u 

••o' 

B • 

-I 

o u 

H B 


i I- 


.I.-. 


'3- 


3-“ 

B» «• 


s-'i I ^'1 

H. O 

VI 5 

_la-M a-Hoe*' 


“ tc 

• • 

M M M 

3 a M 
•o V 3 


x-iH.C - 

• i M aa 

M Q*H 

16 3 O • 

M • •UxhQ 
M MxH 

■0 6 
B 3 

• ee 


• vObU** 

M 

a 

4J • 4J 4J 4J 4J 4i 4J 

3 0333333 

a iH^O. 0« a a O. Ob 

d o d d d d d d 


. ^ _ *i 3JS 

» V) u c V) u » 


I I I I I I 

C 4J • ^ • 4 

I K fi X B X 1 

I • -H • -M • I 


BH HHHHHHH 


• O 

§8 


C-I2 











S-iS. 

>. >» >1 

V 4^ 

C« « CO 
•H -H -H 
nJ hJ >-3 

I I i 

M M M •- 

o d> o _ 

^ tM g 
CM <4-i CM 0 

3 a :3 *j 

CQ CQ CQ t-i 


><4J 6 
M CO « 
*j a*j 

a M ►J M, 
® 9 1^1 

M & o 0, 

M g S s 

:3 « M « 
O H U, H 


(• 0>H 
•H -P 3 
•4 C C 


B a.'• M 


^CM 
>H «M 
3 3 
(3 A 


■P £ 
CO 

i c 

p 

13 

• P 
« « 
M P 


Cp >iP P 

p X c 

■ (Q O H 
.. p Z O 
$ • 

P 0. P I 
• fi O >1 
P O -P P 
CH C3 <0 
•H -H P 

O B o 5 

o,|-p.||. 

>,p >, o 

P CO P H 
(« -H (0 p 

P >-3 P C O 
O lO P P 

o, o a 3 •« c 
e o a P -H 
0 p O O'M o 

C-> (p H P H 04 

: -d>' 

-t CO 

0 o z 


c o> 


I 

o 

*0 

<< 

D 

s 


o I 

o< P >1 
X P 
BOO 
•• Z P 

p p H. 
o o e 
P P o 
C C H 
-H H 
O O H 

$ 

>,>|4J P 
P P <0 b4. 
O O-H I 
P P •-) o 

a o IH. 
ao_ 

B 6 0*0 

o O P ‘0 

C H H bu << 


^..2 


4-. P 4*0 

X *o X g P 

jp p iS • • 

X> IS “O p >M 

C 3 C »H •M 

•HO ►-•IS 

* lo A 
c p 0 4: 


— ►MO P D* p CM 

3«mQ,BCC X •M 

X fficMO OP**^ O 3 

^ SOX P '0 Z 0 
*0 P IS B 

C ^l-OSOO P 

0*0-H CO«P c 

I C4;-H>H, H. o o* 

o :HE-.3 iia p c 

JS 'O'CO-'OO. P :H 

H OPUSPg ST? 

OOBHgtOO O IS 

KCM-s. 4 o -H O 

hi p p p ■ a 

S PSPCtMOC - I 

p a c o Ip p -o^ o. 

■H o OP a-H 3 P o 

o PSHPBCPCMC—P'O 

p to44p3ooo-Ho tn 

P 30HS p_ P a • O 

O PPO 'OPOP> 

K OC«M CSOOH 

POO-H OU^PO 

C -H pi-1 -HP 

O c P -H *0 C P 

•H o 3 4: COO 

PCZU» OZB 

U-H 

C O' *0 

3 0 C 

HijS o 


o 
o o 

4:-i 

{-• o 
o 

-'A 


6*8 
o c 


3 C fl •' 
OCH" 

• O o _ X 
P4; A B o 
OP 10*0 


_ I I 
A3 0 0 
C ■ 4:43 

»• ti H 
I • • 

O' P P P 

c p o o o 
•H o 'P 'P cP 

jj CM CM >M P 
P<P 3 3 3 
P 3 A A A 
XA, I I I 

I to o o 

p 04 : 4 : 4 : 
P4S (1 (-> H 
IS H 4 • 4 
p ■ p p p 
A P O O O 
• O'P'P'P 
M CM CM CM CM 

ocp 3 3 3 
p 3 A A A 
PA 9 


■Si 

c P 


•P o o 

p_4;4: 
0*0 H H 
CM O • • 
CM P p p 
3 O C C 
A P O O 

A P P 
I IP P 
•• P 3 3 
O U U 
PZ 


PP 

P-H 

34 : 

O » 



CM >l>C>tO 
CM M P P CM 
3 p p pep 
A C e C 3 

O O O A 


8.S 8. 


>. U 

^ 1 " 


“ 1^1 

P P 
m CO 

-H H 


C P 
•H Cl 

“.3 


•H P 
CCM 
O 3 

X A 


P P 

o o 

<M <M 
<MCm 

3 3 
A A 


, -*1 •' 

•H C P TJ 

>-a Mt PC p 

I IP o 
P o O X u 

0'O4:4: o o 

CM p H H Z P 


8. ^ 


3*0 
•O A P 
P O 
IS o u 

. J 3X O 
• P O H P 
CM O 


0*0 ; 


S.S. 8. 


C-13 


























TI 

C 


• • H 

4S 4J I 

C It •• 


•'•3 

U C 9 C C(1 

a .i^ra 

U. 4J • £ 


• -7C ** *i *i •• 

• K X X_ ■ 

-O V • • VT) 

• czzz• 

M • • • • U 4^ 
o M 4J *4 4J O C 

M c c c ^ • 

to^a •••»). M •« 

KJ U W M I M 

4J M k4 k4 «J 9M4 

o'^^aaao u»4 

X HOOOX • 


“O o 

e o 


TJ c o 

CQ»J 

• Zco 


V A 


• c 

J3 « •» 


*0 3 C 3 «j 

C U C ■ C 

M . t •• « 

kt •» 0 ■ u 

C « X u M 

H «W U (-• k4 • 3 

• .« 9 'k4 U 

3 >M Ol ■ kJ 'M 

o c a-— 

K 3-* O K H to, 

-« 

C O' • C ic M 

M C-C ■ -H *H >»H b. 

I H H •• 3 lx • J 
9 *J ‘ C 9 9 X O 

>: -Xk4k4 iSX9f-' 
I- X 9 • ■ H 

Z 4J . CL'M TJ 

—• C 4J fi 9*0 

4J3H >4C9(a<< 

$ x to O C 9 H 

9 QU,9 X 

O I |x X'M 

B 10 •• >iX 9 -'4 

9 X 3 U 

CO X 4J 9 U 

OCX H4 

9 kJ 9 Q 9 H 

X -H X 0<-l 

- C X j H 


•O O 9 C_ 
9 C S U (-<1 

u 

o o* 

S.1 



-8 


■8'' 

55 


■X a c 
o 9 i-t 
9 kj I 


af-> (j 

8 u 

kJ u c 

0 9 9 


9 K 

^■8 


I 

a 9 

94 : •*> 

44 k> 

a •*->. 

CX X I 

o 44 
k> kJ 3 
av) cx 

8 tj 


^•8 

"fis 


g;$ 

“ a § ' 
ki 9 9 kJ 
aoe oc u 


c 9 •* 

• • ^ 

_ *'* 
•o o 
cox 
O'-* 9 

«k4 

C 9 

9 a 


1 


c a 

144 


„.. 

44 a u H a 

3 9 9 

k> X c X 

xt 9 X xt 

C I 'k4 3 I 
09 <k4 44 X 

•XiS 3 9 9 

X f- C a X O 


C-14 














I«C «9 IdOK 

•X. -Cli? ^.O S 

N I «a e>, M iu(i 

•H> 3 0 0 I • V eu^ 

-♦ -fOTJ a ‘-i 3 h 

<«■ 4CCO §0.0' 

-H •> >4 4'o as • 0 

*J _tt 06 C ozp H 

•HO a <« O H 0 

Cii O • tt'H ^ lo 


•h<sj3 «o iS I 

c'Q « aM a u a 

0 0 4 0 lo • Q 

I«^x U K O O 0 
O <« !>• i 0 4 

«u>coHa;o« 


a I « ft 
>,o *i a <* a 

3*0 0 9^.a 

3SS 8>,'§ 

field 0 <0 


C-15 








•O W-H I 

« CU^ 4J 
^ M U 
Q >-3 ^ l« 

2 U D k. 

O O O fl c 

(« ca « (• o 

3 3 a a -H 


•A X U «T7Cn'4 l« I 

3 e« z « Ao<'-i 4JUS 4J 

o 3 «^H4-HOOx 

> < «^>J«i<ac<D 

« u u o k S k-< 

« jsm^jsjgjs 

U*9**tl*U*J*J*i»J*i 
I I I I I ( I HH-H-HH-H 

.. 


c « w 

<«J) <1 M 

O O O 9 

*-«.H C 9» 

0 15 0 -H 9 « 

O |«J *J 

Am G 4 J n c 
cu -H cn o H« 


«j •• • c^ 

-H MCA 
C *> -H -M i 
•-• OIkW-^Q 
Stt 

aUi a (A II 
a io loja 
A 6 a 
'HA 3A • a 
OC-* a (-> H H 


*.A cr 

4J 4^ A 
% C O'44 
(-• A C C 
O. > A •-*. 
* 

I o> 

A A S 

t^AA A 
Cb H (- H 


^ a 4J 0.U A 
a o. A a 'H 4J N 

•H-H a a '< 

*4^ c o o 
-HUGO I la 
C 10^1*4 
bt 44 ro A A 44 
44 a a a -H 
44 c A o A c 

Oi-H a ^ 4i 4-1 


- i I mS 

^ -H H •» A "O 
H H O' C 

O' *%**%« A A 

c 44 M 44^ 
-HijjguaMca 
44 AT? AT? A*-*0 
44 O' C O' C O' 
V)AAAAACC 

44 ^ 44 ^ 44 -H W 

c c a c a c 

■H (J »H (J i-a 


•0 *0 A A 

C44444444 O O'O* 

Aaaaa-HAA 

^0000414444 

ACC 

Ok«b4tMibO.«-4^ 


44J< A^ A J<Z H, 

44 a 2 a e a I 1 
(A a -H a -3 a 44 44 

aHH.H.H H C C 
44 I I I I la A 

OAAAAA>> 

a js X u: X X fa] ki 

b4 f-i H H H 


^ A 

a H 

■HO TJ 

If) '-'A 

a ••> 4> 

a—’ 44 A 

8 A 

>1N a a 

O 44 H bh,B 

10 

O..44 U 44 U. 
O H U I 
44 A .X 

c 4 «-H a a 
H (fa c a a 
C 

a 2 >■><>• 
a O' M 44 44 
A a 44 44 44 
X 44 c c c 

X A A A 


c o c c a 

o -H o o a 

•H 44 H -H C m t-.. 

«i a 44 44 OA I 
a (4 a a-H a u 
N -H N N 44 a :H 

I lo 

n H H C V H 

A44944440-H44 

go top0*0 A 

■H |>» L.I Joo*. 

H O 44 T? O H I 

a H o 2 AH ^ c 

3 a'0 44 C 4«T^ AO 
*4 3 o ij O -H oxx, 

a 44-H-0 -* a-* 

44a44C^74«flB 

V)44AaOiAA33 

Kaxxoxxzz " 


C-16 


Asserts a fact into CLIPS of the form 















D H 

o q 

•-'tJ 
-H 
•V CD 

« o. 


D 6 - 
os u 
'-W 


|4J 
.ki u 
(« (« 
O [b, 


—.H 
H O 
Ck. Ul 

O'CO 
C O 

5/ 


.a ■^e 


- It 

8 .‘“i 

>»® 


O -P 
o It 
P tu. 


_ MOO MOk 
'“'O' 0'“'® 

« P« C -H O'o o<« 

P *o ® p *0 ® p 
-j c P O C P o 
. . . . - - *0 H C « M CS It 

XtitbubclbubuicSV) CSc:l-•U4^c!MU. 

I I ri I I I 1 . 0*1 I ri ri 

PPOPP®ppr>-c>PP®PP® 

c cjn G cx c: c . ic c cjz 

iriril^“irir 

O' O"-' O' O"-* O' O' ® "O O' o*'-'' O' D"-' 

®® ®® ®®b. O®® ®® 

V) tfl vj.in, w.«, H CO OT •■ ■■ 

II II I I® M I 

4JP PP PPXOPP 

-- voncb®® 


(0(0 (0(0 (0(0 (0(0 


{ 0 |( 0 | 
p p 

o o 

(O (O 


>1 >1 >1 >1 


-H H H M H -H 

p p p p p p 

D D D D D D 


0 ) ® •. 
® H, 
H. W 
I® (t 
«j:: ra 
-H H E-* 


« Q H 
P M CB 
C I® 
>-tj< « 

(a p 
P ® c 

an 


H ja ►:> 
U -H OQ 

(duo 
rj It I 
cQ ® ce 
O'pW 
ic u 

Q p (d 

oe> (-> 


<N P It P 

u u.,u 

■«- It 1 ® 
(m ® (m, 


I 


-51 


-Ml 
CO C O ® 

ro -M'o ® O' 

P C M C P ® 
® -H P -M C P 

>,p p p p 

P c c c c . 

• “ “ “ “ <N 


(0 !-• 

**. I I 

I « « 

JSJZ 


1 - II 


p ® ® ® ® p 
D <0 (O (O <0 o 
I I I I® 

H p p p p (t< 

■' ® ® Q ® I 

(O (O (O (0 ® 


« « 
6 0 , 
Q H_ 
« 6 -T» 

I I® 

M O.U 


I a. HE-iac 


It u 

® (d 

o ica 
(d*0 O 
« I 
a u « 
o.u u 

hH tj) 
O S td 
<X* P> 


I 

M H 
U (J 
® (d 
I- n 


O'l-a 

ga 


o ® 
H 

M ® 


. U . 
fO P ® P 
O (a. O 
— ® I® 

c: ® H ® 

® ^ JZ Of ^ 
i*->—t" 0>H Ui 
O'— — M ® — 

® O' ® P . 

C 0 _ C O'C pro 
rO -H *0 ® p T3 ® 
PCMCP CO . 

5 PP-P C P 

^CO^t^r'JSdCa. U 

* fill II® 

>,p p p P .P P (!,_ 
PCCCCPCC I 
.-taeoou®«9 

•M i> O* O' O' OH 
P ® ® ® ® I® o 
Dtocococo ®toco — 

HPPPPHPP 
CO to CO (O — CO to 


O' c 

® « 

p 

c ® 


■21 

® H 

9 0 .. 


® p p p p 


9 'H -H -M H *H *H 
X P P p P P P 
HDDrD DD 


® -H 

*"l^l 

99 .. 


Q '4 O 
M^H|U| 

Jd 0.M 

u 6 u 

H H H 


.. p 
« H 
O 
atd 
H e >'9 

U O CO 

“^l®l 

SDMOi 

o » w 

It la 
O H (d 

ce« H 


■3 


ro 


PUP 
U (fb U 

— ® I® 
(a. ® (M 
P IC 
COHO 


o*»t 

C A 
O O. 


0 .^ 


)P 
M O 

0 ® 

0>b. 


to c ov'< p 

ro -M "o 9 ”0 ® 

PCMCP %CO . 

5 -M P-H c P-M.-I p 
Oitf.la. O 
• I I I I® II® 

>. 0 ppp(a.pp(a, 
P ; C C C IC C I 

•H 0'0'0'0'H 0'0'H 
DtOCOCOOT — tow 

I p p p p 
..9999 
to <0 CO CO 


I I 

p p 

9 9 

to CO 


O >« >« >1 >1 
® p p p p 
(a.;M - 


3 


ii 


® 0 

x:x; 

H H 
V V 




_ _ - ® H ® ® 

(O CO CO <0 to (O — 

I M N' 1 ) 

p p p p *j p 

9999 ® ® 

(O (O (O to (0(0 


. >1 >1 

p p p p tJ *J 

H -H M H H -H 

<-H <—( <P ■—4 .H <H 

-h-h-m-h -h h 

p p p p p p 

D D D D D D 


D A 
OH 
V a. 


X 6 


_ _ - P fO 

■O H TJ ® CN *0 ® 

C M c P CO . 
-H P H C .-H 'H P 

atf.to It: Mp kiUiO 

I I I lu l I® 

pppp UppU. 
C C C C (a. C C I 
-I® ® 9 


O SB 
J3 O 
H (J 
V V 


C P 


UUP 
PC® 
P N 
U U -P 

® *5 p 

P c o 
« o 
u u 

U 9 -p 
P WO 


SmS. 


M U 

® .. .. .. «.-P M M 

•o -o 0 ® 

CPPPPOO'O' 

0 ® ® -t ® -p 0 0 

-4 O O O w P P 

■< 9 c C 

Otattbi*. UiAk-ii-i 


COCC W>. COCC'. •. ® 

O P O O ® O P O O H, 

P P -p p C « H. O P P P P C » I 
p®pPO.k< Igp'tPPOJ^U 
tt UNUU-PUUhUNUU-PU-P 
^ M-PNNPU-PHN-PNNPU'O*. 
p 'P 'P 'P -P H T? |P ’P *P 'P H O 
(t (O O-H P-H-H'O Hu 

p -P p -P P C U p 3 p P -p -p C U M 3 

to.® PO,P PO:PMppDP POPUP 
ISd. to.D.O.TJ ® U D. ID,D,CJ.T3AU 
MP !>, I / \oa.jJ !>. II 10 Ip 

9HOM-4-0UP kOUMP-OUPCco 
O' HOUOtJMC POUOPMO I 
uu'OPCM’Oooi’OPCM’ooas.M 

S 30JtO-POAZ*'OUOPOA l9 
P -P'O-P 3 -P I I -P’O-P b 18 
x.uMCPO’MgaoMCP&Mesu 
iPOUaoOSOBOUCLOOSSBC 
XCOAXOAAZSBPAZOtfASB ® 
« H, I X, 

®— III R a R a I 


I 

u.. M 

ODDDDUHO. ® 
HAZOAAAZH 


— o 
u 

P (a. 



P — O' .— — 


— 55 


_ pc* . , _ - 

•P *0® TJUp’OWP 
M .CO .COtJCOU 
P P -P P P P P ® P -4 ® 
to UXCa. Ui(:ia.(i.XCa.Ca. 
II® II® I I It I I 

;»i«^ptaippta4pp OPM 9 

PCC ICC ICCXC CX 

p i ii I ii 1i 8^ 

•P O' O'H O' O'H O' O'— O’ O'— 

D '^I'^l'*^ '^1*^1 ^1^1 

Rpp PP PP PM 

"®® ®® ®® 09 

toco toco coco ( 0(0 


® p p 

(a. -P P 

H-H 


I I I I I I u 

I I I I I I ® 


M 

O 


C-17 










i I I I i i t I > 



SSuSS ss ss 

a a a a a a a a a 


* o 


( 111(1 

(((((( 


<« 

Q C o o 
Ijg eg |••>^ ^ 

-H Z.TJ I l<fl X >*-H *J a O 

^^09 Q.0.^ *JJS 

o <0 o ae-'4 « u 

Ue-UUUUUeZtODMD 


4 J 4 J 4 J 4 J 4 J 4 J 4 J 4 J 4 J 4 J<kl 4 J 
•H -H - 1 ^ "H "H -H ‘H -H -H -H -H 

33 I 39 S »»»»»»3 




A OO'O 4 -> 4 JjQ MCV 4 
*0 *.*0 5 c fi 9 < 3 * O 4 « 

k fp O 0.3 » » UP > 

o M u >.ej3 o« c o 

900 «m« 4 J 4 J.H -HP*D 
Q-Haoo P .H«0 -H 
3P3 CC(a4<'H&M4 

• 4k C0O4-.H 4 9-P 

N ox "I a «4P<M 

%-H .-H H P 3 P ■ M C -P 

• ^»p 40‘CS Ifc^HP 

0.-H 0.4 MMQ4«OQ^ 

OP o,p • s 4 a M o.M-i a3 
13. Ic 4 i_ 9 CT-H a 
IG 9 9 3*0 3 0^> 4 
4 0 0 larH C U Ov»4 OS 4 
4:H-H939-HU0. • P 

4J'0PMM X4(P OO 
10 4 0. 9P X O P 
>fH N94X ^3<M9 
>pPHP‘OP94« C> P 
*-^39 

O Q. P 0‘'>.'PH-H 4*0 P» P 
V O IP Ct/)0 >M-H>P C 
P as 3.-P Cb X 4 %-P 

» *9 (PMe.94J. CQ 

« ..CUPf^OOX 9>440. 

• • * :P 4 0 -H O.H ?sC 9 

j< j< *0 P >» X O O^ 4 
4 4"— 0494P ^-H.P O 

4 4 h'OP •’OIOP 

P,CP.£:P4 PCo k 9 4 PX O 
lO I09-H 490.0.C0.9 'P 

S P >t-H Q. C400P-HP4 
P««4J I+J-H9 I I3-H C - 

oo-pusc p'O’opo-Hpa • 

a 0*0 G 9 9*0 a9 9 9 Q 0> *0 
03-*-)9CCPPO.'- 


9 3 O 3 C I 


P Cb e buB 


c_ 4 P -H- O • O fa. 

I b >3 •* 4 W 4 pb 44 > 9 > i 

" P 0>9 9 9 X O. P 
4 9 CQ.'O.P» P- >iP 9 
X-P IlS'HO P 04 
P PPpe>'P» 'pS 
4 .PP 994 *04 I 

P.H 444 P 9 ' PP- 9 
-P-P D 34 P 40 ^>N 
PS 4 -K 04 - S* 0 > P 




C-18 











D 

ro ic 

4j'c‘d •n TJ 

5 -H B « c c 

btS-H 3-H -H 

R O |« 1 |.v 

•• 9 • > O • 
^JZ X jB'm 

O « (-•'M H H 
9 > -W « 


CS V 
O i« 
0.4J 

a 

9 O 
ca J3 


?8. 


9 a 
O 4J 
‘w C 


■P IDIO 
«O H 4J 

■y®* j 

<• t-»*d a 
o^a-H-o 
-HO fi c 
o 

tt a u 
ax u « 

H B a 


4J a‘V-H 

— c 
T) 4 J o % 

0 u Qt 

*1 a o B 
) -H a w 


8:3' 


B 1 < t I X 


a*> B 4J 
9 H 
a'M « 

o » i 

a o a 

•H • fl a 

B 

4J.H A « 

fix 

a -o -H 4J O 
§ a ^ B-' 

9« a a 

ax w 
u X a 
a a X o u 
X X 

X 4J a N 
X B'a 

'M a M a 
•H 4J 9 a a 

'M B X o fl 

a a O 4 -H 
a a M o. >-* 
X a 9 T) 

^g.i* 3 

ana a. 

♦J-H I 

a 

I 1 I I I ( X 


& « . « D> 

3 — a, 

I MMM I 

4J'»4 U O O X 

a o o o o a 
o o 

^ a u u o -H 
ct«.S cu. 

'O I 

•H *i t-» -H ♦i 

X X a • X ^ a 
.4*j aowM^j ao 
• a B >iw a a B > 1 ^ 

4 a o a 9'*--D a o a 9'*' 
l><zao c><zoo 



a H 


a o> 

% B a B 
a -H u o 

(-•a a CO 
ax cb 
a a H H4 
X I X 

fr4 a -.u. 

X a 

5 o 

O' B £-• 

a_f a t 
-H’O X n 

b <,0 w a 
Moo* 
>«w o.a 
a a 8 

'H Ck. i-i B 
a I M 

Q a a 

■HXX 
O H H I 


0*0 c c u 

6 I a B a a *0 

+> < 

ro u ad M M 

X B 0 * O o M 

a-H a.a 0 i o. a 

oac fi 9 a 8 o> 

• i-t i-i Hi •-« a 


I 


X*hS, 

H H 
» M 
* ^ a 

H B a 
» an 



H I-* a—• 
u X u 9 

U fl bl^X 

H *9 a a 
|CD> a 



• a n I. 
j^xoicoa; 

O »H • H 
I 8 9 II a M 
a a a •■ 9 a a 
> M a >-«x a*M 
o '—oe.a aHH-H 
8 I9> _ 

a a^ “O 

M I i X a<M B 

I I H>-H a 


a o 


a-H 
a a 

D > 


^1 


II 

-H H 


0,§ 

53 


B B M ki 

■2 S°'5'3 

la X B B 
a a a 
a o u-H-H 
a o 9 a a 

H OQ Q U U 


-H TJ -i I V 

1*4 ** 

a MT? M »TJ 0 

o.>>Maaa3BA 

>,aaa4JUMfi 


a B 

3H 

-H*W 

Si 


u a 
o.> 
X a 

9X 


a«H 
X 9 
a o 
-HX 
M a 
a 

o a 

88 
a >< 
a 4J 

a a 

X B 
o 


“oi 


lu 

s§ 

a (iM 


!•§ 


Si 

D,H 


ill 


? a 
a 

a Q a 
ax o 
o a 

a 

a ax 
-^x 
X 4J 


HX H 
•O U X 
o a B 
XU a 



6-H 

a-^ « 

X a •«^4. 

^ X • C. H 

e a u a u a flg 

H X £ X Hi 4j a 
U c HI C O B X 

.^5^i5S58 

I 10 I< O 0< O CO 

S I *i I 'i R 

o o o •• >1 •• >. •• 

B XX CO CO 

B I &S.a S.a S. 

D„ CO >1 9 >1 9 Ss 

ro .f-.-HH.-iH. 
X B a la la 1 
a-H9a>a>a 
c5 x^x X X 

. a H X H*i^ H 

I a > -H -H a 


C-19 














u « c 

<9 G 'i 

04 OM 

CO <• 4 
CO M O). 


ct <0 <0 8 > >1 

O C 

CO <0 CO M 0-W 
<0 i» <0 •cupw 
H c-> e-> cj> lo 
I I 1C ty>T3 H 
««MU-HCOV4 

o B « 0 :dX-HXa,, 

»H <0 C U I 

. o n o 9 o 

X P I&-H H cox C 
^x>iCMXcauo 
<0 «CH «^l®e« 


CO CO M 
4 <9 <9 C<,*« 
lo» 

i ICT'C 

• ® H O C -H 

o 9 lO -H hx 

M -H C tt 
. 9*.a 0 0 4 
X +i JO»-H «t-» 
4J K >|C h fix. 

3 « C -H fi « I 

H cn a. a > 


k4k4 

*i 8>* 8** * * 8>* S>8 

fi®®®®®®®® ®® 

O 4J 4J 4J X 4J 4J ^ 4J 

^cccccccc cc 

IHtH 

SSilSSiSi S5 

iJ iJ U ** ** 4J *i ** *■> 4J 

• «ioa»»co9v fico 

ccccccccc cc 
ooooooooo oo 

UOUUUOOUU DO 


xo 

4J -H CO 

>«X H U ® 

4 4J H D<, H 

-S-W O I *1 

• M H CJ >1 >t-H 

0.0 k4:H 4^ 4J M 

H O. *0 -H H -I o 

O.U |OMM»4-4>« 
4 O..O H O O O M 
Ji H M -H -H *4 O4 -'4 
CO>4‘0®hklM |W 

I® OCbCb.CktCUCU o 
J9 O*-* I I_I_I5B,'^ 

10 4 h «M IV4 

fi C O O.C • O'M ct., 
t-» 40-. M 0,_l 
DC. lM 4J O. u IS 

8 tP • 3 B 4 4-> O 
XMXU®U»4X 
■H«4i®®C044J 
S44J3KM-H4JO 
^•^•cnsdcxiOcnn 


■'< I 

M C 

• O 

“• 1=1 

ss 

X X 



o»-^-o • 


ii - ii — 


Kb fi 
MM H 

- - -- •>•*<:> 
^ _ Cmm m CbU O' O'"* B 

4JCHM044M®e0fifiM®® ® 
Cfiaii®-'4'0'0®t7*fi-'4’0’D®*i*J**4J 
*-* 9 lo*** C C O'® • c C 0*c C CO 

^ji<0fiOOOA^'-4fiO09iMM«-^>. 
COC8*JM-^-^XCOM-^-^*J MCO 

-H04CS44e«H03fi4CCC^ 

O) {-• Mt O U U !-• 0J Q U O tM -4 -4 D C 


I 


So~ 


tb 


iS 


M -£ 


C H fi O O I 

4 ’0-1 |4J«-«.M.CJ« 

^ -HO-44JM I 104 

C H 4 O 0. -4 *0 M O 4< -I fi 
•O -H 4 M fi fi Q, 4 CO M H, 

0^*4 M M 044JHfi4fi^l 
tv OH *0 M O j< 0.0* .0 ,H.l- N • 

— 4>.ZLck4fi4a« 1 

*J fi >.--1 4CVBfi»®>»»®®-HH 
^ -H-HE-XO>OCO*-<|->00®®®XX'4 

ca t i ( I I i iSzzzzhh44'm 

ici®®®®®®» 

■ — — 


• ^ 


iJ -4 9M 
H-M H.4 
14 4 14 

O H H. 
•H X Cl 
U H -<2 
Ot C H'O 

•1 Qi << 

3 X>iX 

&M M M 
9 *J *t ** 
M C C C 

a • • • 





8.S. 


X >1 

{S 

C M 

CO « 
• ® 

3 3 


4 4 
® ® 

!-• H 

S.S. 


C-21 


Note that the use of the variant record requires that a default 
be given to the variant. The program will not compile without 


























CO A A A A A 

« -H N H I ■ I 

3 4J 


M I M V 4 

A 0 'S o o • 

*6 C 9-H-Hs I 
M H ^ M V V 
M O, Cb* • 

® fl'-' 


•o M e-« o* • 

• 4J . I . . 

*0 C M • M M 

is-g^-a-a 

o ic^ a a 

AM 0*0 « • 

s «a^ cO'H-H 

S *0 cO ® <0 <0 
|H U Q U U 


a « 0 ' S o o • 

J 3 C ® •'4 -H • I 
« H 4J H H V V 
3Ma«0 l4« • 

fl Or* 
r* *0 oa. 


o I 

*0 « 

O tJ u 

*0 B * C •«. 
COM® 
au««j 
O lO'k^ 

® o «• 
c w &• ■ 
s CO B a A A 

tH C-^ CH • • 


—I® 

T} U « 

^ G GO, •• 
i O H TJ ^ 

^^ho-H *• 

C tt H H* • 
D ® 3 • A A 
IH O & 4 B • 


H, ® O'S o o • 

3 B « -H -H • « 

« O-H 4J M W VV 
B iK t-H 0< Cm* • 


a I H H 
- -H O'S O O « 
G ®-H-H« ■ 

a ®-H4JM»4VV 

o 3 J<Maaa ■ 

I 3 a-' 

• 0,A. 

^ • • 
l-< *0 >» 

® ** 

M -H 


I o> 

‘T3 tot 
O -O I 
-H O ® 
U -H 3 


A A AtHOO 

\ ■ I 

I AAA 

CQ a m I ■ a 

e S S S o) a a 
-• o o o 3 s X 

AOOO 

^ A A ■ 

III A 

a A A a 
n VI VI B a a 

le B B U VI 

d u u X VI w B 

c 3 X H ec B a 

H ii (-• o a a X 
300 '-' 3 xh 
E-'i-'O 

oo-*-’ 

AAA 

\ I a a 
a AAA 

a a a 

B IH < D 

dXSvixxx 


O oQ 

u yu 

® *a; f-> 

-c xoa 

y B H 3 


<a S 

M o x q 


h H B C C ( 

<0 be jo O O O ( 

“0 OTJ -HO H-. 
B O' B 4J |4J 4 
o • ® ® JC ® < 

^ 4J'H H « ke I 

® B ® 3 ® 3 : 

u M o a H a c 


H-H « 4 X 
•• H a. 4 J ® 

• • X® ® 

4 be «-• a,E-< B 

0 ® ( I • O »e 

D-O W-* B -H ® 

5 B 3 ® ® bJ O' 

9 9 4J i3 4J ® ® 

rt O « M 4J 

0 (0 > 3 B 

J o VI o VI o M 


J 3 Q> Aq» Adt 


U U OS b< M 

^ g g ® <0 

ATJ'OAH-eA^-H 

y be 14 S XXbe C B 

:d®®ficco-^-« 

‘OOia-H«C«'HV10l 


V. ..g..... 


J 4J 4J B*0 H I® 
e ca jo O O be V 4J 
> « “O 4J H H O be be 
^4J B K -bi k4 -H ® ® 
i®®®q®be4J4J 
4>J:BXoa.Bvivi 


TJ ® H 
I B 6 I 
•H a « be 
m X,*H B,® 

3 I I lO* 
mmm a o 

® O S g bJ 
4J ® O -H B I 
W H H H IH I 


O. .• B .• o., 

SO |«B « |« O 

• O 9M « 9M 

O O.^ O &-4 <• 

XjQ tt >wQ ® >vQ « 

H « e-.H O 
M I M I M I 

ObeOOMfObebe 
bi®-Hb>®gb>®® 
®^*0 ®>-H OX'H 
O, lOQ. IHO. 13 
lO H I® I 1^4 2 * 

*H H M -♦ B X-H • C 

O'OOO-HEO-HH 

A oeuAt^Sfi 3v> 

• O-H Jo I Jo O'^l 

•H-H be ®-^ X®>H B • 

O ®XOBJSO-H^ 

TJ BH *3h af-** 

C B B B 

-H • « • • 

U= JS s 


B O be O 
BOOtH, 

O to* I 

^ X OX «• 
B « 4J «• I 
D ® B ® A A 
tH E-t • • 


C-22 



















-CO, 


*i m 
« a 


uo 

*i 

a,c 

M 

M 9 
U 

O • 

•H M 
CD, 




C-H 
M -tJ 
9 U 

<9 

« 


M M 
*J jj 
o<,*a 
ic 

j< • 
OM 

o <« 

HO 

a, 

Ic 

H U 
O 9 
M V 
4J • 


♦J e w H 1 
OH 1 

1 4J 

1 u 

G u<n 1 

1 ** 

1 O 

G 1 

•H 1 

1 *i 

I O 

c 

H 

e O' *o 1 

9 9 C II 

9 1 1 

.. 1 § 

1 1 I «M 

O' TJ 1 

9 C II 

.0 9 I 1 

1 1 ! § 

1 1 1 

O' 'V t 

9 C II 

^9 II 

■ 1 1 § 

1 1 i 'M 

o* 

s 


Si 

♦J -H 

3% 

• O' 
A C 
OH 

9 9 

jG U 
HW 

C 4J 

M ca 

9 • 

4J 


9 

3 


A 9 
M 


S.' 

cS 

9-0 

tJ « 

:Sa 


M M 

A,C 

M 

M 9 
U ^ 

O • 


O '*-< 

• • 


C *i 
u u 
9 O 
4J O. 

• a 

C h M 


O' *0 


5 i 


CTJ 
M O 
9H 
4-* U 

• 9 

C M A 
•H 

O' TJ 


9 

§• 

& 


0 9 9 
H*0 9 
O 9 

“•rS3 

CSEto 

jC'-' 



C-23 




















M M 

•A 9 M M O 
0.9 "B * H 

<*> >. i^i8 £ 

o a ■ 

%0 <9-'j <•« 

*o 4J CO .u o 

oft o O MH 

•H -0 -H O I 
M C ^ M Q, O 

o a a« ex 

CU Z O Oi M H 

OQ (Q CQ CQ CP M 
U O U U U 0* 
HH.HH.H.O' 
..I I I I )« 

S e o 0 9 -u 

x^xxx c 


■P 4J 4J *i 

9 9 9 4J 4J 9 
04 O. eu 9 9 9 

d d d ^ ^ d 

"rrisss'" 

•H H -H C C C ® 
H H (-• M M M H 


*i‘0 

« o 

• M 
*i ® 
M a< 


o I 

9 a 

OM 

■o S 

•8^ 
MH. 
O, I 

•o^c 

OH 


« 8 
OHO 
3— H 
O.'OCk, 

•OH'— 
O U 
-H C 
H 0<. 


•O I 

o a « 

Z O • \M 
G a 9 9 
■•i UM 9 
i4.H a H. 
^1 I 

> 1 H,4J 
0 •• IC 
Z 0-H 
• ox >4 

o Sh.o* 

I H ^ O 

4J 4J e H 
X CH 9 
O O M-O 
HUD.® 

•o o 

G U 

« a 


Is 

9 o 
® CO 


(S 9 
u c 

® H.-H 
^ l-p 

® o c 

4X0 

HHO 




••* » ♦J H 

m % H *0 

^ « 4 » 


• n 


A c « o ^ 

O C(A • •>< I 
« H O o A (t O ® 
C 0*JH «UUO<X 
• M a ^ O'H.H.Ih SKt-* 
X |H 4 C I KO'- 
4J ;X9M'H®®OHIC| 

_ 40.9 cxx5h*o 

•o 4 kO;H (H lx 2 A C 

c:cfH,>i I®-——2,0.0 
4 « |H«H e 4 a I lo 
^MOOO'O'OOO® 
GCC.G CZZM 


• • h M 9 , ^ 

uAAAA44(i](i}«H 
JOUOO'O'O 4 
H O H.fxH H.C C • • U 
''xU I I I I® O 

®®®®<H>H«<»'— 
•o H XXXX 4 4 9 9 
C'N.|xC->{xC-iUO«i«J*i 

2 4 4 9 

19 tnvi • 

M *i 

44«J99999AA»-i. 
44J9AAAAAUU i 
^ A A.HCx A 

• • *00000 t iS 

AAO*hm,*hmm 4 ®-H 

U U M I I I I ICXH 

i 

XX tH lx H H |x H-H < 
|x H 



_ lA A'H 
U 4 4 

ix 9 a I u 

l+i 

• 4 4 a — 

X W 9 9 ® 

fx A 4J 4J 4J C 

4 4 9 -H 

4J 4J A *-3, 

A A * 

• • O » 

4J A A tH • 

9 9 O U I Z 

«x*^AA|x{^a<^ • 

X • • ) IS o 

®<MOO • ®-H'*4»-», 
tx-HMMXXIxH 
_ I pH xj 

•O 

G G C«H 


I 


5^ 

4 O 
H-H 

• U 

*i ® 


o c 

:C' 

4 G 

4-H 
H H 


•'»s 

4^ O 
J< 4 H 
4 4 A 
4 H. 

•o o 

O H 


® A. 
® A. 

9 IC 
U G O 
H OZ. 


• >9 


® B H 
•O X 9 O.A 
G ®«H C I 
® H -H -H +J O 
_ 4J G M 
•o C-H 9 
G O HTJ 
• U A O 

® a 


3. 3. 



ii & 


G C H M _ „ 

C-HM04j9MOAO 
4 Z.®-H*0*0 9 0. U 
• C C 0« |h I 

xHX ® 4 • ® ®^ 9M O - . 
O4«JMxH^^aO»40HM 
04B944C404B 0,0, 
A H M O O U *-« H-U H 4 I I 
G *J O'O 
BCBBCBBC)>HCuOo 
•H -H -H -H -H -H -H W H O C -H 
9 B 9 0.4 H 

.V-H +J B 4J ® 

• •ll.HA 


® — CH ,4 
.H •O-H l*J 
Us *j u 

I a -o -H -o u o 
>«0.B H 4 4 O. 

4 >,-H e a 

o.^ri'*'ri”ri 

“ • • ® ® ® • 


. . 4 8. 

A.B 5 ca 

H O O M 


O H H H H H H 


^4 9 

O ® O • 

•H ® 9-H 9 
M 9 •‘O • 
A.® 9 0 9 
iSar.-HO, 

0O«.„^|M I 
rj lO.® ® 
■o ® BAX 
OX ® P 


■s 

s 


§s 

0 4 

4 O 
4 A 


A 9 
O C 
H -H 

® C 
X O 
H O 


c ^S, 

J 

*J M 4 
tt ® 4 

■8 

1*68 

»'S^ri 

I H H 
N >• 

«-8 4 

'Co® 

JS *x 

. 4 4 
4 ® H 
• -H H 
1 X 4 

I ®>. 


H: 

■HU® 
M 4 U 

.5 

=*lo'S 

*o ox 

O H 4 
-H U 4 
U ®H, 
«A I 

A • U 

A 5^ 
OHO 
H. H 
9 u 
®X • 
X H A 


I 


A,>. 
OH 
^ O 


U A. 

® I 

A.4J 

IC 

4J 9 

U U 
4 U 
*J 9 
A U 


« *J 
9 -H 
® M 
9 O 

O.-H 

•O A 
® 

U A 

8 * 
U 4 
0.4 

•o'8 

O O 
■H U 
U A 


• •-O 


•O'H 
■ ■ O M 
«. .M-U ® 
H A, 

>t><® « I 
4J ^ 9 A.>i 
•H U U bP, 
U mH >. 

O O- 




U U •• 4 -H 
A A 9 4 
• I® H 4 

•«A a *Jii 
'M u C B H 
•H H.® H M • 
|M O U 
•O 9 u C -H b 
CX 9 O WO 
9 H O U A g 

■O O 
a u 
9 a 


4 
« 
9H 
9 4J 
9 -H 
9 U 
0.0 
M 
9 M 
X A, 
H I 

~s' 

•O 4 
OX 
•HH, 
U I 

• 4 

A,4 

>,'3 

“n' 

Is 

:ID 



H I 

4 s' 
BX 
•H H. 


I® 

><u 

®.s 

^BC 


S3 


C B 
O 4 
U.O 

4 O 
4 A 


® 

A 9 
U B 

®H'H 

3 •■y 

O.® B 
LB O 
■OHO 


C-24 























M C 

• 4 

O' « 

• -» 

4J O 

c o 

M CQ 


« U 
M C 
« 4 > 
4 4 

H.K-H 
« IQ a 
Q ck< a (■ 

>H 2 fi H 

C^.O. 


ii^ 


u C-> 

•3*3 fi 

C fi « 

• • 4J 


I 

« 4 ''I 

'O • fi W IM 
O fi -H ^ ♦J <■ 
-H H H -a w 4 
MH, }4 4H. 

• ..•*' 4 < 

. . _ «A- anr 
^ S ^LiS lo <" 

43>sS»4J.i. 

4 «-H « co.eo • • • 

I BB.SS.--' 
la I II \*j I la 
>a4«:S«44««a 
• ^jCA'rsji 4 4x^ o 


M.tJ 


4 c o c c i-. 

^ 0-4 0 0 * !•* 

4 -H 4J -H -n C U 
u 4 n n 
« N 4 « -n*0 
-«'N-nNN4J04 

•H ^-n-n n-n 

n 4 

9-n n -H-n C 4 4 
nnDnnOCktH 
4D. tDp.O. I I 
n l>i 1 I Ma 
v)on>H*ouoz 
M o 4 4:d 11 

C n*0 M'M 
4040 H 040 
O'-H'O n a-w J I 
4 n c«> &n^ e 
C44a44Sd 
4Ck.:EO(eo.zz 


H*i *i G 
4 lO 

3 4 C 4 

0>> 4 

0 4 0 

C a 4*0 

4 9Ji 

Ji U 4J 
» *> 4 

c 4u: 

• •Ji w 


4 4J 
4 *J 

4 4 4 

4 4 

3 I 4 
>!>*> 

4«M'*4 O 

x a 

4 

O O n 
X fi fi 
*» O 
-n C O 4J 
> 4 
X ^ 
'O 4J C 

4 C 4 
C *. 4 S 
-n «J 9 
w 4 *J 
4 n «J O 
^ -n O C 

'** G 


0*0 3 O 

-n O >« 

a*^-o 

.§ 


b* CM G I 
'-'4 4 4 0 
4 C £ 4 jC -h 
^ 4 4 4-» H 4^*0 


4^ 

4 4 
4 4 np 

Mp+J’O 
*8 *4 ^ * 

n * 4 C 
O ^JS 4 
4** 4 • 
4jC Z n 
C 4 
H 4 4J-n 
oji 4 X 
4 >«4 



i-,»' r I r'l*! 

14 4 4-> 4 n 

i H.C JC C J5 C •• 


•* O 

o ••. 

Q«H 
»H U O 
I • *-• 
M n I 

4 4J< 

4*0 4 

^lS5 

^*4 4 
!-• U jS 

H 

I 


S!8-~ 

"an 4 * 

a IH 4 

O 4J_W 

U n-O a 

14 4 B 


f-> n CU« 
4 B 4 
n 4 O 4 
aHUH 


00-H 

U u 


i's. 


o •. 

4 

ViM 


t-*p 4I-, 

O 00 


*^o' 

IS 

O -H n 

n lok., 
4 I 
*0 MkM 

C 40. 
4 *J I 
'H cn n 

5J| 

. Si 

••HZ 

S'' 

-H 4 

tl'S 

a-H 
O H, 
n I 
M*0 
in 
^ o 

4 O 
4 4 


3 C 
O n 
> 3 


4 4J 4 
n 4 n 
4 n <*. 4 
a 4 n a 
4 un 4 
4 4 a 4 


n ••. 
4 n 
U V 
4 tU 


n I 
4i n^ 

cb n o 
kb n 
M 44 
O C 
O O O 

>n o U 

I 

\aiM 
•^-H |« 

0>H 4 
4 n o H 
n n n 
4 C 4J C 
n O C -H 
4 U O 

a KJ.“ 

4-x I 
4 4 00 

4 4 U 
4 H 4 H. 
H H I 


O ■• u n 
H H.4 
n GO H 

cb u 4 a 
ihZ a 
o i- o 
J 4 O. 
■DUS’-* I 
OH O 

£.-g-S 

H 4 n 
C SZ 4 
0**0 o o., 

H 4 V) I 

4JS |C 


4 4 4 4 

n n n n 
3 3 3 3 
* 00 * 0*0 


S-3-"S 

•% 4 n 4 4 4 

-H *4 fl fl-^ 

4o 3 -n n o 

n C ^ V 

4 M ja o ,• -.a 
n «J In M 
40. CJi< 4 4 C •«. 
a In 4*0*0 n 
••••••4J<34CC34 

4UnH44nn 

8 4 0 4 4 4 

_ g 4.H M C 4 4 n n 


O •« H H 
O. •* • •-- . 
IC n n o 
O C 4 4 n n 
4 H 4 0*0 4 44 
4 4J 4 C C O' e 
H 4'H 4 • • O 
n O'H.H n U 
C 3 O 4 4 C I 

■H O ffi U U •-• jitf 


I 


8 8c 

4 H C -H 
>t C H 4 
O 4 H Iv •• 


8888 8 

O O O O O 

n n n n n 

a a a a a 


-H*^| 

^ n 

(0 4 4 

U 4 n 

^1 l”l 

4 » » 
4S 4 • 

HZZ 


-H ao n o (0 

CO n 4 4 4 au 
U 4 •H 4 n B H. 
H Ob O O V) •-« 

.'.','.',','5 

K* z z as z z 


■s 

i 


i § 


n 

■nn 4 4 

HH > O' 

, . 14 

n n n «J 

•<.4 4 n n 4 c 

■O *0 4 4 4 H 

a 4 e c O' o'H 

4 n 4 4 4 4 C 

4 •«4>n.H4jnn-H 
n 4 4 C C 3 
4 4 4 U W n H o •• 

■n «j a 

44CCCCCn 
c n 4 H n -n n -H 4 
0 4 * 

•H a4 •• • 

n 4 -• _ - 

4 4 4 Z 

n 4 fi 4 4 >14 

34Ji<nfiH44n«J 
O -H 4 H-n IH n 4 4 

4 |Ha n 4 n 

C 4Hn .^BBO.*<.H 4 

n^ In a I a 
34U4oa64'-'4 

n4;Hnn33JS 4 

4 Hp (0 V) Z Z H 4 

I- 


-1 


y n<- 

4 O (b 4 
4 H ifi 
H n c H 
14 OH. 

■g“-|*ro' 

«j n n n 
4 C C O 
an H u 

4 n n 4 

-H cb Ob oe 

o 

cSSS 

S-3-S-i 

t!5!8 


H n 
14 
n O' 
4 4 
4 C 

n I 


■Si 

8a. 
o 4 

w 4 

an 


C-25 











Q 


•H'd'd «4-) 
■U C C O' c 

m • 9 o iH 


OH c 

^ C H « Q 

TJ-H l+JM 

4^ H I 
■H’O H 
H 0 O &C9 

o 9 4 J e o 

fcScnMH 

» » > » 9 
9 O 9 O J= 
Z Z Z Z H 


c o c c t*, o 

O-H O O % !•- fr*. 

-H 4J -H -H c O I 

fl .p 4J ^ 

9 N (Q 4 -HTl Z. 
<.N-HNN4JO0l I 

,K -H ^ -H -H -H -H 
U^ H^tHT) M (B O 
O HP-H-H C 9 9 

.H p ou p o ft< H, a 

UD, bpu^ I I 99 

• i>i r I >Mo. %*« 

P U M ^*0 o oz o 

Jg H O 9 9 -H II ‘X. 
'o'Dpep'au’*-* 9 I 
C090 H 09 0. iP 
9 H *d -H a H Ja I -H « 
^pcp&Haa H<D 


C O C C H, 
O-H O O •> 

-H p H -H c O 
p 9 P P 0:H«*. 
9 N 9 9 -H T) 
kN-HNNp09 
JK-H ^ H-H-H-H 

O -H P -H -H C 9 9 
^ p P O O 4 H 
OD, fc3p.U» 

• >. C K-g; 


T)*P P C P*D P'44 
0090 H 090 
9 H TJ -H 3-H j I 


O P P 

'H a-H aTJ P Q 
u 9 p a 9 9 a 

• H ® -H 9 p a 

p kb op «).>-• 

9 0 

» » > » » 
C H 0 0 9 9 9 
9 ZZZZZ 


■‘■:;i IS 

T? 9 H C 
9 C_ >.0E-»,9 
E -HTl 9 H Ip 
H U« O ^ ^ P P 
H. -H a-O P Q 
li p a 9 9 a 

p .. 9 H 9 p a 

p (bpopM, 

9« ^11 II I 

P <J S 9 » > » 
<0,H,9 9 9 9 9 

I tezzzz, 

4J 9 . I I I I I 

9 8 9 9 9 9 9 

9 9jsj:mjsjs 

(H H (H l>« Ch H (H 


*|*^^H®|.^ 

9 P P 9 
jC P 9X^ 
H 9 O 4 H 
■P 9 
%o 

O 19 9 C 
U »Z C 9 
HO H P 
BS 9w P 

a 10*0 o 

a 9 H 9 Q. 

9 u= 9 a 

H H «0 »H 
« ^ 
u » a 

H 9 9 

'H 0. I I 

P 8 9 9 


‘O'O p 
C C p« 
9 9 i 
A 

o ■ a 


^ B 9 
CO 

3 PH 
O • C 
o a-' 
► P o 
9 CUJ|< 
p a* a 
9 9 

an. 

Qr- 9 I 
eji< H 9 
o a > 
O 9 >) o 
iH'p a 

M H 9 
9*0*0 a 
9*0 o 

H4<XP 


..„g0 

Jit U H P 

U>-<H 9 
00 kb, 
-HOP I 

O >-• P *44 

S 9 O, 
P I 

9 a. 0i,p 

-o iS 

C H PP 


CO 

a p p 
o B c c 
u a a 
•POO 

9 cuu 

p a* • 

9 OJ<Ji< 
-H o a a 
9 9 
a JXH.H, 
o a II 
0 9 >.9 
|H,»P > 
M HO 

a-o-o a 

9 *0 O 9 
H<£a 


CHP0^9P9 
9Z.9 H*0*0 9 O' 
9 lO'P C C O' 0 
^j^99900P 
OaPP-H-HpC 
09Ca99C>-< 
OQ H PI O U U 44 


C H,9 Q 
*O h Ip pi. 
O'H P P I 


II |9'0h* 0 P OJi< 
>«S,CP99aa 
P 9 >i H 9 9 P a 9 

09090999} 

• aHHB'<HHHZ 


f-i 9 
^ 9M 
»H O 9 
O' C 9 
Ji< 9 •OH 
0-H*0 P 
O (■• O P P 
-H H Q 9 
u >ip ac 

• 9 9 a 9 

P -H (b PI P 
9 a I ic 
*0 a 0 9 PI 
e -H js js • 

0 O H H CQ 


'44 p ax 9 
PI a P K 
-OHO 
P O 9 

•00 0 

9 e p OX 

-H 

X a *0 

-H -P O' O -H 

a c p a 

9 P -H O 
9 H C PX 
*** 0 9a 

'44 ax 
a PI 9 9 9 


a 9 9 4J a 
9 cx o 9 
P O P 9 9 
*0 X'P 
» p u e 
9 9 3 H 

c px 
• • a 

9 9 • a p 
X S*o 9 9 
p 9-H a 
*0-HX 
*44 CP OM 
H 9*0 p a 
9 0.9 
9 PX P 
9 -H O 9 
a ax 9 
_ 0 PX 
*0-H 9 P 

§-6^'S« 

9 0 9 

Jtf X p 9 JB ' 
00 P 9 >. 
0 a a 9 
X *0 » 9 

u p 9 9 p a 
a 9 9 0 

p a c 9X-H 
a *0 p y 
p -H 9 
-H C-H a 0 
u< 9-H a p 
X P o 9 o 
p a p P a 


C O C C H. 
OH O O % I- 
-H p P -H C U 
p 9 P P OH—. 
9 N 9 9 -H*0 
«N'HNNpOa 
JlC -H -H P -P P P J< 
y-H-p-4-H*0 P a 
O-H P P-P C 9 9 

.p p Dp p o lb h 
UD, t>,DV^ I I 
• I>| l_^l H lb 
pyp-^’OUOZ 
a-j o 9 O-j I I 
*0*0 P C p*0 P'44 
C090 P090 
9-H-O-H d-pX I 
-4pcpo*p§a 
999a99aa 
UlbZOCCCk.ZZ 


c a 9 
-pa 

A "^IH O 
DO. O 


— a • 
A 9 a 

A m 9 o 

A U <44 H 

• J 

M a 
^ a . a 
a a 9 
9 9 a H 


A 9 m 
A m 9 u 

A 0144 H 

• ^,5 J 

H O. 

^ a ' a 

a a 9 

0 9 an 


C-26 























•o 

I ( i I t I I I c 

I I I t I I I I « 


C-28 









C-29 









!• 

C 3 
O O. 

9 

■H C 


og 

•OH, 


ss 


3 W 

Otpp 

ss 


H • 

S -tJ 3 

« « 


■P M 
C C O. 
• • I 
M M O 
PMC 
3 3 -H 
uu:^ 


ts « 

• *» p 

' ”l*^l 

^ • 
Ct.» • 

O ^ 4J •- 

“;53- 


« - 


a • 

-H 3 

j: c • 

H -H • 
P C 
• C M 

S ozJ 

OTJ 
-H <0 
POO 


U 0 (■ 

(SOP 
■H C H 
m (S 
P ca 

O M Qt 

“as 

« e 

•H 'M 

• P -M 
M (S S 
9 9 
JS J3T3 
P 9 C 

■H 4 
C J3 

• T3 
JC « • 
P^ P 

P M 


=i 8 


• P (. 
XH 

» a 

p p 
-MX 

ax 

• <s a 

X p a 


X M 

g*, . 

a p 

>p » o 


X o 

a^H 
(S o 

'^IM 
C p <5 

9 C*0 

X o c 

P MO 

•» M ^ 

O 3 4 

3 0 U U 

^ O 

a c •-■ 

>,4 

-.1*^ ® 

*T3 M C 


P & 

ae T) 

8 PI ^ a 

ShomS 
M u a I 
cuH aTJ 
fe -<,0 
VO la 
X p a 

H c M 
OX 
c a M • 
- •• M a 

3 a 

M o u 0 


8^ 


o 

B a M 
->^0.1 
AT} 3 V 
O 0*0 C 
HP 0-M 

lox c 
o e o o 
X o A,a 
HO la 
M c o 


ox 

O' o 

o o 

p<p 

cu 

PI • 
• M 

A a 
0*0 
H C 
lO 
o-p 
X a 
H u 


A a 
UH 

o a 
X a 

^8 

O 


X c 
o o 

*^la 

ss 


9 9 
O'X 

O H 


I 


•H a M p 
3 -M 
'OX o 

a « *o 
o a o o X 

*o PXX P 
P o ( 

a p as 
C'O 9 

a o 3 MX 
a M a ( 


o a 

P -00 

X ox ax 
O'X a 3 P 
M p a a 

8 P u o 
C 0 A 

9 9 SX 

o'* c*o • 

ipo^i 

O CX 3 M 
a M P '0 P 

1 o 

t. BX P 

a o M 
c ax a a 


a c 
>,o 

|M -p p p 

TJ M »jc a a ( 
o 3 >>p M a 

p o. a o » p 

a I XXp a 
8 P 0 0^X0 

So. a M a P 

0 8 o a a a 

MO H o P <-H 

eu 9 ( 

M I I I I I I I 

<P A I I I I t I I ' 


p a a X 

o a o p s 

P pp a c o 

o a M p p a c 

M p—( -H-H 

a c 0 a o 

O a c 0*0 MX 

a >• p H M o P 

O M M -I o X X 
3 3 *0 N O a-O 

-* o "O a a a c 
a o o o o >> a 

> OXOX M 
X o _ p -0 

MpaaTJPcr 


Ig8 


o a 


1-^3 MM 

o o M a • 

• a s a 3 o o 
p M a 3 o a V 
p -M o a H a 
3 0 0 8 3 0 0*0'H 
X p a 'H 0 X a 
o 3>-i a 3 p a 
a z a—• >_ -H a 
*0 o M ro p p 

M OS'OOiMpp 

a 'X o^ -H 
:» *j a p 3 c 
X o ■* 3 a.*o • B H 
ucoxaooa 
a a-M p ox ex'o 

XP3 OO-MPO 
M*o*o M a p ^ 
a Q O B A P 3 

X &x a pp M*o 
0 8 0 o M a o 
o H a o * B a ax 

^ BTJ P O 

M c-M o a a-H a 
a o 0 p P (S a 
■hxo aspca 
X O'X P 8 a o -H 
H H w ox o H 
xaa-^appo 
a p M a a a c 
ax a ap-H o o 


I 


1(11 


-H p o 
3 CX 
*o o P 

i'-o 

u a B 
a a a 



a o p 

■p a P o 

P M VI 

o a a > 

-H p P O' 
3 A V. B 


O A AX 

px u u a 
•M O H H a 
A, I IH 
■o lo O X. 
c cxx^ I 

ODHK'> 


OX 

0*0 

o o 

P-H 

c u 
*-« • 
• M 

A a 
0*0 
OH.C 

c io 

•M 0-M 

^x a 
•Oho 

a 

sr 


<>•> o 

a 
A a 

O-M 

o a 
X a 


o o 
A.a 

a 
c o 

DA 


laa 
o o D, 
X o I 
H^ P 
M 

•o a 
c P 
O A 


B*o a 
M B a 
OH 
>< 8 
M o 

PX-1 
B P-H 


p a 
a c p 

3 O-'H 


P-O O 
C-HP 

c % 
a O' 

P c 
>*aH 
X 3 P 

■O M y • 
o o o 
'H P X o 
-I C o 6 
a -H -H 
u P P, 
o M I 
ox a p 

X H P M 

a a 


M a 'H 

■€>,§ . 

0X00 

o 

0*0X-H 

M o a 
a a a « 
3 P o 
a a B 
-M o a -H 
X -H 
HX 0*0 
a 8 a 
a HO 

P p*o 


g-s 


• M M 

3 P '0 
O A.C 
3 lo 
OP-H 
la a 
•o o o 


Si 


•s 

OP § 
lOjH 

Ip*^! 

•H c P 

HO M 

|M a 

PAP 
M A. 

a I 


O O' 

I M 0 

t ax 


C-30 






*j (a 
•H w 

o 8 
M o 
o M 

>■'*-« Oi • 

c 3 

C « ■'4 u 

o c c c 

•H O <0 
4J^ tt 

caTJ <fl • 
9 <9 9 9 

4j e 06 (0 


4J 9 9 >4-4 
•H *j j: • 


3 O O' 
"0 C 9 
9 «9U)T) 


•H ^ 9 
O -1 *> 
-H *J 9 9 
C 9 C U 
OJS 0*-H 

•P rl "O 

U 9 9 
0 9 U 
B V4 9 Q. 

3 -H 

9 9 9 

P C M -H 
9 H Oj3 
u M 
O U 

9 P 9 9 

<—4 

>y^ 

6 9 3 9 
U 9 < U 
O P 

<*4 4J 

M U . 9 
9:HTJ j: 
O.'O 9 P 
O P 

9 -H ki 9 

M M 9 ^ 

3 9 P 3 

*0 0.9*0 

9 ^ 

OTJ >.0 
Oi-H O 
W "O .-H H 

a'o 9 o. 

9 3 

9 p 9 
■H >,0^ 
JS'H 9 P 
H 3 

2 5- 

I I I I I . 

(1(11 


c >.o P. 
o 0:^1 
o o *0 >1 
P o c 
J|< 9 -4 9 
0-0 u 
9 C 9 o 
9 0.9 
U e j= 

't-i p 

>900 

PUS 

-H P P 'M 

-H y o 
.O P 9 
■H 9 'M P 

9 9'p y 
9 9 9 9 
9 .-H 'M 
<p 9 «p 

PX 9 
9 9 P 
Ji 9 
P 9 3.0 
POP 
.. 9 C 

P 

9 a<P 3 

9 e OA 

P O 

y 9 P 

P <9 9 

9 0 9 


O' 9 9 > 
C P C P 
•P 9 H P 
9-H^-H 

X'O H 
u 9 9i3 
O 9H 
9*0 9 


IC 9 P 
>iO<9.fi O 

S 3 P P C 
O O 

C'M C 9 
C 9 9 H -H 
9 A 
<*< *0 9 

'p P 9 
O 9*0 9 
O' 9 3 9 
9 C P^ P 
9 H y 
9 C 9 C P 




9 P 9 3 
J3 9'*4 H O' 
P P O C 
9 9 -H 

C*0 P.a< 9 
»H p 9 
'w 9 9 P 
O 0.P O 

I I I I ( < 


P -P 
9 P 
P a 


=1 

■H'O 

x< 


P 3 

S f 


Ji< u *o P 

9 •-( O 3 
9 £9 P P 
H O P 9 
• 9 P 

cQ ce a. < 

u S ( 

H 

I p < 

9 C 


"-•a. i A I 


P t 9 C 

9 C*0 C 9 

OOP Cpj= 

>-t la—t *i 

U.^73 *0 

9>** 

9 C 9 C 
R 's.O OQ O 
.. ..H .-p 

m P A P 
U 90 9 
H P(-> P 
13 13 9 

9 A 9 O 3 
A ^tC IP 
(-• f-< JR H 

9 

9 9 C 

Pt-.Pf- P 
9 |9 13 

O C O C P 


lo 


I 


■•ZviX > 


9 P 
3 9 
9 9 
3 P 
O 9 


P P 

o,c 

lo 


9 P 
3 9 
0,9 
P •« 
-3 9 
9-4 9 


A '*4 


•O > 9 
P P H 

o.a I 
IB y 

2'"^ 

6 ro 

P w o 

H,M P 

I p 


Is 

j:' 

P D 
9 I 
P P 

cn p 


C-31 








4-) 


o o o. 

M h 

4J -P M U • 
c C IQ hJ 0) 
O O P D U 
U U 0] O (Q 
I bl'-l 
ji< ^ « x a 
(A cQu:: u 
■Q IQ p to c 

H H -P 
•w O 

IQ P >t^ U 
3 p p-H 
W O -P 
0_ P >P 
JATJ Oja IQ 
rt ®-P M 
P ^ M C P 
^ a-P 
® -p_« 

p '*-1 "O "O e 

3 ® ® ® 

•o >,c«hj: 

® •H C7>^ u 
u ^ -H -P <A 
O IQ td «w 


U ® ® 'H 

■p aj: <a 3 

JS P ® 'O 

H iQ 3 « 
®-H-C 
0 p <Q U 

p ® > <d 


C C P p 
c -p p o ® Jg p 
® ac,® H-o-o o 

® |9>P C C C7> 

® ® ® ® ® 
o ta p p 'p 'p p 
O ® C 3 ® ® C 
oa H IP Q U U M 


« a H.fl 

T3 p Ip 
a o-H p p 
l®'0 P '0 P o 

>1 a c p ® ® a 

® >1 p ® ® P 6 
*p H a£ a Q V) IP 
a I I I I I I 

<d ® ® ® ® ® ® 


c 1 -^ ®^S 

js O'© -w-P Ip 

POO ^ P P 
^ -P «*TJ p O 

WO) p a® ® a 

'p I® >t® p fi 
3^0. t- QW.*-*, 
CO II I 1^1 
P ® ® « ® ® 


—. o 

O.K H • 8 a 

8^'. 

>, (d ® ® 

H ® 'O 6 U 

IH C © P C 

« -P Cf-i ® 

J3 > -O -p I^J 

H ® o H H 

C -P^'O P o tt 
p (d ® ® a-P 
H ® ® ® P £ 

P ••(PHOtOiP ® 

cd .a 


lo. a a a a.a, I 
^ I I i I I lo 
(dcaiziAAtnn^ 
fluooouoe^ 

I® 

«®®®®®®® 
PZZZZSSS o 


® I » p^ 
B >iO O ® 
•P C IP p C 

Hrf, ig o 
I Wts p 
>1 O (d C P 

S j: ® ® a 

*- H SB O 

p p M P P 
p p p p p 

n A A A 
L> L> U O L> 

Pi'i's's' 

zzzzz 


O C 

_a. -H « P o 

•O ) ^ ® P -P 

C >1 ® (H ® p 

•p ® .* p I M ® 

iC^ P O 3 p 

lau ®:P a 3 

® Cd D >,-0 ka. 
X-PA lo >1 I 

HQHU-P ^P-^ 
■p P o o ® 
D I n*o®i-4PC 

.o a I® o 

•P UATI-P 

9 P 9 ® c P 

>43 «x ® ® a 
® c a H H £ o 

»p -p • • • • • 

*D ap p p p p p 

Cacppppp 
-p p o a a a a a 
bclou I I I I I 

®®®(J(JUL>U 

**^^1*^ 1*^1^ 1^1 
XXX » > » » » 
®®®®®®®® 
•P -P -P z z z z z 

p p p 

I « 

U U O P 


p p p ® 
P p p H 

aaa, I 
I I lu 
A A A-P 
U O OtJ 

t-. t- t-i o 
I I Ip 

» » » p 

9 9 9 ® 
z zz a 


P P 3 P 

® ® 0 3 

IQ 

13 >1 I 

P O' » P ^ 

® c o o ® 

-H -p l-l P C 
3 A I® O 
O* l^TJ-P 
C 9 ® C P 

•p X ® ® a 

A I- H £ O 


p 4J P P P 

Q,^0.|0,|0.|0,^ 

A A A A A 
U U U U O 

zzzzz 


C-32 
















a a 

" tfl 
>iC 
M O 

•TJ OH T3 

O O 

-H « O. -H 

U *0 O >• H 
• C • (0 0 
O* ^ 

• s 4^ 9 • 

w+ •a.p.w 
*J H i ^ l+J 

Ot.c 03 IXO 4 . 

|o a.,u <0 I 
CQ H K-> 9 ca 
o 4J m iwp 
HrtO > IH 
iNHaj^ I 
» H ^Bb « » 
o<M s a o 

Z -H 

I 

W J3 


• 9 C 

ajz o 

^ *4 -H 


-lir 


4J^ ^ ^ 

a a V'H 9 a 
o c a u< H o 
^00 -H 

In -H -^ + + In 
4 J In 

"v. 0. >>. 

O'-’ 



“fS 

o a 
uoa 


V a 

H • 

.>< o a 
K u « 0,0 
T) ro H Q I 
o ca 4J »H a 
•H to., 10 
•N H 0 IOC 
H 9 a ca H a 
■p a.,a u tj p 
a., ia (-*,0 M 

l>o. H o 

ffiCO_ » u c. 

u ro a a e 
H,a o z a< M 

t«H 


>•9-4 o aH< < 

4J M i -H a- 

•H a P a p a » 

p a o. a -H Ha 
o -H c a p • p 
•Hpa'o.naTJ oot 
p-HiS a^ a -H-H- 
ap p c a a a P ’07 
o -H ^ p X a. o < 
.c -H p a -H a p M - 
o p a p au3 a o p » 
a ao>p > p > -f a < 
a p a a o ‘ocuc 
'p a a c 01 

44 0>H PU3 a C •H«P4 
O C 0.C O P o < 
p a 9 a » a I 
aa-H 9_a cup» 
nZ c ’O'H la { 
•HS>iapaP 'pZJ 
a 9 P o P P o,§ f 
c -H j: 44 a -H Id: 
a '-t u ^—1 PZ9 
£ a a -H a 9 a 
p fi c >*o u a Z'-' 
o -H o ^ g 
a a*o^-i a a 9 p 
c POPU> za 
-H c a a a a o 
e a o a S.>a a a 

p > ^ p 

a-Ha'O'Pco ac 
po^acoop 
a o a a 

'OPU3 aaa ai 
a > a tp-i a H •• 
OU3 a c -H I 
ppa-naap oa 

M 4J U-H-H •HP 

aaa-H js n “O-h 
-H capaHO on 
a P O X -H -H 1 
a a HP p PC 

pa‘pp_«^a a-H 
a o c.'O a cu A 

X p ^x c I I 

a P<p 9 a «p u 
^x a o o >ix o,:H 
ana x p p fo 

o p a -H p o 

o> a a pa a-« 

• X p X p 

ac’OBapa sa 
x-Hcdxpa do* 
HX a c » ap z 


a*o 
a c 
H a 


c a 
a a 

X P 

Si 


iM 
M O 

a a 

<903. 


P 9 

P a 

a.,9 
lot, 
a I 

U Q 

:c' 

a a, 


c a 

oC' 

H« 

o a 


>»H 
o P P 

p a a 
a 

4< a a 
a a 
a u a 
p a-H 

> 

a a o 

C-HH 

aaa 

XH 

px a 
_ S’* « 
■o 9 
■o • a 

< A U 

as 


a A 

a a 
^ 1 * 


Ov-O 
9*0 
P < 


p a 
p 9 

A|0| 
A Q 


> a 
a a 
z H 


X 9 44 <H a 

ic • o c*H a 
^ p c nap 
a -Ha OH 
a p_ c a 
H 0*0 ox aj< 
fp a -H a 

J a p o c a 
a a a p a p 
p a a p_x 

In -* ad*0X9 

X -o a_x • 
a ff 0 g’o p a 
X HO a 3 c P 
p PHX a a 9 a 
a pa X P 

c > a a «p a 
o xa *0 „ 

a p *0 a a a *0 

ax H pip2 

•Hpp>a 3 o '0 
•HO a z c 
99 p a a a 
a &’o ax p a 
>•£9 a 'a 
p a c o a a a 9 
x -H p p-H*® a 
a o a a 

-H pa CT'x e a 
X o c'O c a X 
ppoa-naap 
_ o a c p H 
‘W'O c C o D 

oaa daap P" 

a p44 PX a c a . 

xca^ipw-H -Ha 

a a c X X, 
a a p a o pax la 

pSapca-Ho xa 


p 

8,^1 -18 
>,A •« a H c 
Hp_ CH.a 

IH’O '- H Ip 
a 10 ^ p p 

X ^ •H 9*0 P O 

H a p a a a a 
z a >• a p 6 

H “‘i^i I ri 

p >• a a a a a 


H f( I ■ a 


•o a p -4 H a 5 
a £ x -444 > 
a a a a a •« 
9 a 9 a » a^ 

8 9 p a a O' a 
>• -4 O p c a 
•Hpaacaap 
p a > X -H p X -H 

ex pA au 
an» _ a 

p a •• *0 a 0 

p c c 'ax a 

9 ' OX'S a-H 
opanocaa 

•H X P •«"* 9 p 

*t p;H a -4 
a 'Oka a^ 
a 0*0 a 9X H 

9 p a c a P k 




« I 


an _ 9 9 

H -o So 

la a-H c 

aH-iikJ.-H Ip 
p O h4 P P 
Cn'-'HX'OPOa 

p a a a an 
N P a a a p 8 

••aAHIOWMa 
PXPPMPP>i 
p ip p p p p H, 
AXAA.A.A.A, I 

la I I 1 ) la 

A aAAAAAX 
OHOOUOOH 
Kh H H H H 
^la^i L L I la 

kakkkkka 

anaaaaaa 

ZCnZZZZZO 


-o I 
e >• 

iSJ' 


a a p 
•H p a 
p 9 p 
a o 9 
a >, ID 
a l>> I 
_ . ••»-4 a p-4 

lau X 8 o a 
aao-'^a-Hpc 
XHA HH a O 
H O H O H ro H 
M a >,c p 
a ■ I >,c a a 

.X WZO 

« 9 . . . 

a a O' p p p 

>•9 H C P p P 

a c * a A.A A. 

'4 H PX III 
*0 ap P 0 A A A 
c a CA. *000 

-H-HO iHH.HH. 
ZOO AP _l I I 
• • • u A.k k k 

a a a H, I a a a 
aaa u<zzz 
-4X-4 k a 
XXX a a'-’ 

^ a a z H, 

•H -H -H I 

p p p —’ a 
aaa 8 


Ill'll! 
sssjl 

» • • (B • 
p p p < p 
P P p O'P 
AjAjA CA| 

A A AX A 
u U O a o 

tm;' 


c >••* 


a C 

a o c 

-4-H o 
X PP 
a a p 
•H p a 
p 9 p 
a 0,9 
«?>. lo, 
!>• I 




P c 


lao- - . - . _ 
a a A p o Jp o 

X -H H Q P -H TJ -H 
HO Ma p cp 

0 l>,a a a 

■ I "X lAZO 

.... a a • > ' 
a a O'P p p 

>•9H ePPp 

a c * a A A.A. 

_-4-PPX III 
*0 ap P O A A A 
e a c A • u u o 
■HHO IPHHH. 

zouAP ,^Lr 

• • 'OA k k k 

a a an, la a a 
aaa ,^lxzzz 
-4-4X k a 

•HHH I 


=’r’f’(9'S 

o o o a -H 
o o o a A. 

-H -H P H I 

p p p 3 a 
aaa ax 

A A A a H 
• • • A • 
PPM . p 

p p p O'P 
A.A AC A, 
I I M I 
A AAXA 

000 ao 

i£i:><i 


c >••> 


■H p a 
p 9 p 
a 0.9 
a >, ID, 
a !>• I 

-.4 <V P P^ 

Z-4U X a o a 
ia5—^-HP c 
a a A -H 9 a o 

X-H H Q P 0'’D H 

HO )-• a c c P 


» 


l>, H a a 
X |c/>ZO 


9 a O' p p p 
>. 9 H e p p p 
a c > a A.AA. 

•H-H PX III 
-o ap P U A A A 
c a c A ' u o u 

2 H O IP H.H.H. 
DU A P L I 
• • > o A.k k k 

a a a H 19 9 9 
aaa z z z 
-4-4-4 k a 
XXX a a'-’ 
a a «izH. 


•• a ( 

> a V), 

ri.' 


aaa h.c 

-4 - > —4 |H 

^O'O'I 
c e c 9 a 

-P-P ax 
v>(/>(o aH 


P P P O'P 
A A.A.C A, 

i I M I 
A A AX A 
U U U a U 

k k k X k 



C-33 









0 O'O 

2.®'^ 

o'ta 4J 

• u ca 


CQ U 

o a 0 

§-••0 J3 
u *J 
0 o 
Ji 0 

4J 4J O* 

u c 

S <» (Q 

O M O 
S O 
9 O .P 
P O 

0 C 
OX 
P P V 


M p ca 
<9 Wi p 

<a 9 H 

<Q CQ 

s-si- 

9 9_ 

c wo • 

O 9 
(Q C H a 
•H 9 P 9 


p p 


"s'*' 

3,8.. 

8^ 

C MX 
9 0 0 
p a 9 

“li'o'S 

C 9 

o ,ro 3 
•M o o o. 
Pid'H 
•H*0 M 9 
CQ O 9 (J 
OMft, C 
O. M (9 

. o «4J 

•> 9 Ot n M 
9 3 U O 
8 3 9 •.Eh O. 

S c 9 9 
9 MX'*' 

O P 9 H 9 
8 M'0'^"0 3 

9 O M *0 u 

06|.O| < t- 

9 •-•,9 9 H 

3 lU 3 
9 O C 9 
3 -H 9 9 ce 

O.TJ P O 0 
O M I -H 
'Oho "O "0 
9 ^ 0< 9 O 

M 9 8 M -H 

^ CU M ^ M 

p'-' M 0^ 


8 .& 


S,f, 

» 9 

1= 


•O 9 
9 9 
90 


*0 9 9 P 
CXX M 
9 P P O 

a 

I ( t ( I 8 


COj- 

9^ 
cc -H 


19 

9X<M 
X H H 


U I 

« 9 9 9 
9X 9 3 
9 H B OX 
o^ to 


-.•—.H «0, 


4 P O 

»H I • 

IP 9 9 
P M > 9 
M 9 O 9 
9 P 8 3 
p <n,9 o, 

IS • T3 
S 9 9 9 
9 as 3 M 
C as 9 9 
9 « 3*0 

X fl •• O.M 

?! S ^ ^ S 

B IP M I 
P M O.P 
a M 9 |M 
9 P 9 9 

ca P c/) 8 P 

avy • -H <« 
P •AH 
9 A U I 
P O H P 
CO H |m 
• 19 9 

A 9X P 
u X H cn 
H^H 

9 •M 


^r& 

9 9 


9 O 
O-H 
-H M 
“O A, 
O I 
■H U 
M-H 
9*0 
AO 
►h 
9 M 
-H 9 
3 A 


OH • 
ut <s 

lea** 

5<' 


• MO 
X 9»h 
P •->. I 

>.>i9 «i 

.3.3.35 

a an. • 

9 9 lA 
-H H >,0 

“.“vS"-. 

S S • 9 
9 9AX 
25SUH 
H, 

I > I 

v. *. 9 
X 

>«>«H 
9 9 

»H 'H hp» 

AO. 

9 9 9 

-H-H 9 
O ow 


•3-S3 

-H -H I 
M M 9 
9 9 M 

11"! 

-H H 9 

"’rrS 

>t><9 

55^1 

ssl 

1^1 
9 9 >« 
XX c 
H H <2 


-So 
-AO,9<-> 
90 IS 
3 H^OX 
o. ro fo 

19 9^9 

^S'S“| 

9 9 9 

O'-" « 3 


p 

it 


ig 

P ‘H 


• -, I H 

Ip 9 9 
P M > o 
M 9 o A 

P A § 9 

S 9 9 3 

9 SB 3 O. 
SB 9_l 

I 3*0 

"1 •• 0»|g 

ilsl 

5,^r8°i 

p tio § 

M 9 IH 
9P 9H, 
P M 8 I 
A ‘-HP 
• AH M 
AO 19 
O H P P 
H. )M A 
19 9 
9X P 


9 9 
X 9 
HB 


9 C PM 

C-H MO 

•H^ o O. 

=1'2 &e 

^9 8 •H 

9 9 Ml 

9 0 S 

S 9 
9 SB 


s'S 

9 SB 


9 e 
C-H 
•H "-H 
M-O 
•o 9 


> A 
A O 
O H 


9- 


O S. 
9*6 


• A 
A O 
O H. 
H. I- 

19 

9X>M 



I 


C M 
O 3 
■HO, 


M 9 <— 

3 C 
O O >• 

H 9 
>iP—• 

M a9. 

o o o o o 


5 ^ P 


9M 
M 9 O.. 
3 C 
0,0 >. 

tH 9 
>>P'H 
MO.^ 


I 


SicQ 


o — H H 

O, - . 

C MM 
X O C 9 9 M 
CQ-H 9’0‘O 9 
9 P 9 C C O' 
H 9m 9 9 9 

M O M M p 

C 3 O 9 9 C 
•H O A O O M 


>«C H 9 
•O 9 H Ip 
OMM p M 

H a-O M 5 
A M (A 9 9 a 
O 9 -H 9 P 8 

H A O O (O M 

rrrri i 

9 S S S S S 
X 9 9 9 9 9 
HasZSEZZ 


P9 09 i 09Aa09AQ.-- 
9*0X-H‘OX—.H-OO 9-H *00 9 h- 
-:caMC«_PC H » M C H.S _ 
|9999’099 ho ® 9 Ko.'O 
SHAZH.ONZ9 iAS9 lO 
-M • I • ► H-H 'XX ' 'XX-H 
PA 9BA 9 MMAH CDBAH 9 M 
0000009-HO 900 99 

- ^ns °:^,^r^rrr^ri 

9M9H99HS I9P999P9S 
C30X XX 9MX90XX909 
9 MPH-t-HH-t-Z 9H O-HHH O-HZ 
XH9 CMS MS 

P 'O'— ^ O'—A H —A H ■— 





♦>*j*^++pp+ + PO 


Cf-H 
9 e 
3 H c 

9 O' O 
3. C -H 
O’ 9 P 
XH 
9 0 9 

P P ^ 


• P 
A M 
0 9 9 

H -OX 
M P 
9 O 
X 9 

P P O* 
O C 
9 9 9 
> MX 
O M O 

8 O 

9 O P 
M O 

9 e 

ox 

p p ce 


9 >1 

3 A -X 

o. ro o 

9 0 9 

•OX H A. 
9 9 M I 
M 9 9 9 
9 H A 3 
■O 19 

M - >• 3 

OA AO, 
^Kf HI 
*0 H 9’0 
O X O 
•H 9 9 -H 
M X 9 M 
9 H H 9 


P M C 9 
M,9 ox 

lA-HH 
IP 


.J 


A A. X CM 


O A 9 
8 102 
9 9 A^ 
BX < 


• X 

9 9 CQ O 
9 -H O H 
M M H M 

X 9*0 9 
9 > O A. 
H H I 
M 9 M C 
9M 9 O 

X 9 9 9 

9XMM 
9X3 3 
H.OT.'O'O 
I 19 9 


S 


•o 3M 
0*0 P 
H 9 0. 
MX I 
9 O >i 
A A M 

• to 

A 9 P 
O O* 9 

^Sl 

Jgs 


M P 9 
9 M P 
9 9-H 
9 9 
9 C Ph 
O-HX 
9 9_ 

C M'O • 
O 9 
9 C -H 3 
•H 9 M 9 




8 

S 

P 

M 

s. 

8 


O' O' o o 

SSVi 

XX 9 9 
O O B B 


t I I t I 


C-34 









3 HJZ 4J a 

C O.O.fr**-',3 M 3 

« I i top. 

JS « 9 I I 

4J C G > 9 9 ta 

■M->* O S i u 

>* fl-W'IH. 

c6 e'O'2 • 

O 9 « « OS I l9 


« 4J 

C 9 •• 

O N 

•H -H 9 

*j-H d 

Ol'H -W 

O *i c 

• D 1 -H 

n 9 

0 0 9 8 
H -H C 9 
re -H OS. 
9 O'H I 
j=-Hre 9 
H h 9 6 
9 9-H 
O. Q H 


-H • rere«< 

(Kf-t 9 9 9 9 9 • 
JSX9 9 9 

'-’'-H H H O O 3 


*4 HO 

S 9^1 

0 9 9 H 
O MX « 
b. H O 


acQ 9 H 
O O H P 
HH, I O 
19 U 
9 9 9 X 
XX U U 
HHbu 


4J 9 re 
9 C 9 O 
X 9 3 -M 
M 9 M 
C U 3 9 
9 3 &0. 

U O I 

9 C • 
9 9X 
UX X Z.9 
CM 19 

9 M re 4J 
X 4J 9 9 

M U 4J X 4J 

O 9^ 9 C 
a«M 9w 9 
e^M cuu 

-M 0^ B u 
-10 3 
re 4J -M o o 
c o 9 

9 C M 9 
«J O X 
9'H Ml 4J 
C<H 9 
-H M 9 

-H > • 9 9 

re >.9 

9 9-4 tJM 
9 3> 9 [9 

re C MX 9 
9 9 U M 
9X:H M 

X ore 9 » 

H 9 0.9 
« I « C 


< H C 9 X 
S.o, hoh 
to. c 
It M — 
a o •• 9 
M2 0 M 
H K ^ 9 9 

B H dCC.O 
p-H H 
U O d 9 (u 
X U -H g 

R 9 • C 

I ce m o 
9 to H 
3 9 9 H M 
M 3 0 19 

9 M -H 9 M 
M 9HX 3 
V) M 'HO 
• CO CO 
CQ > O 
O CO H 


0 9 C 9 

•H 3 0 3 O 

MO. HO. 9 * J< 

-Hi Ml flop O 

9 9 M 9 to 9 

O C 0 9 0 9H, m. 

tt. -M 9 O H « 3 I I 

•MM OuH. 999 9 

ore M • I 3 3X » 3 
3 9 I 9 M O.O.H 0 9 

9 9 9 3 M 113 3 

3 a » 9 9 >9 9'-00 

o. 2 a4JcQcc_ 11 
1-0 ocou-M-Hreoo 


99M MH. • 999<9 
XXM, .9 19 M 9X t 
HH I9re93 *9MHC 

S 3 MX 9 9re 9 
OO H 3 3 M J 
••Oil 0,0,0, _ 

a 9 I -re 

9 9 c c re 9 9 are 

0 aCMH 900Ui9 

•H 'MM M-H-HH • 

H. 9re*d 9HH 19 

I 3 9 9 re I 19 a 

M 999 MMMX9 

M 300 OMMH3 

9 0^ 19 9 O. 

M 9 M M 

CO, re 0 CO .CO, re 

19 H I I 9 

MM H M M M 

9 9 |9 CB 9 

ore M 9 9 re 

MM M M M M 

3 33:! °i 


9 9 9 9 9 ♦ H.H. 
M 9X 9 9 9 II 
9MHQ03MM 

re 9 9 M M 


C-35 








Op 

gs 

•H Cf, 


II 


HjH| 
4J 4J 
« l« 
•P P 
.to.wi. 

n I t 

U P P 

H,ca « 

lo o 

o P P 


bl >ita 

355 
< • ■ 
b< CQ ffi 
U U 

$ C 


tt 
M U 
WH. 


3 H t-* 


C 9 
O « 
O-H 


M 9 
(0 M 

>,o 

IP 


•H CD 

''rS 

>i<« 


OQ S 
O H 

O >■ 

55 


C 

pi2 

...Sy' 

•-^,9 

ay'5 

H 9 • 

3 9 m 
H.U 

0 0 9 
U MX 
b. H 


P P -H 

9 X 
P 9 I 
v> 2 ;x 
. . (0 
CQ CQ 9 
O O H. 
6hH, I 
I |9 '•> 
9 9 0 
XX m«m 
E- H bu -H 


C-H 

O^j 

XTJ 

P 9 

_S 


I bi, 


■ I 

0 P 
3 M 
9 9 
S P 

tj p 
9 9 
b 9 
« 6 P 
O'O 9 


ii-S 

i -H P 9 


S33 


t-'H 
O fl 

c 


•H c 0 e . 

^0^39 
*0 M 9 9 P ill 
9 fau 3 3 M,p *i 
9 « 0,0, IM M C 
0 9 I 19 9 9 9 
3 9 9 > P P M 
'-'OCCOMMM 
3 H -H e I 13 
0 P PO 
P re*0 OK 9 9 
O.'O 9 9 •99—' 
e 9 9 9 9 P P 
W,M Q Q r “ " 

19 ( 

0*0 5 

»-• M C 

• o.a 

_ 0 lo 7 
73 3 9 0< < 

C 9 C • » 

9 3 H 9 < 

Od 3 T 

x_ra 9 » 

973 9 3 < 

9 9 9 0. 

t^.MO^I < 

19 73 i 

P'S ■ 9 
C M •• M t 

S°^S . 

M 9 9 M > 

3 C 9 O f 
O-HH. I * 

H 19 b 
973 P C 
9 9 C -H * 

*i5 2=3 J 


a;*H 

o 3 • 


“3 


P >« 

73 M 

9 O 

P-M 
M M 
9 Ch. 
P I 
U> P 
. 9 
X V> 
9 • 
9 (3> 
H C 
M 

PX 
C 9 
9 9 

M H 
MX. 
3 

o> 



o 


9 9 
3 3 
0 . 0 . 


5: 


II 


9 P C C 

C 9 H 9 

O N CX 

•H M I H p 
P-M 9 % 3 H I- 

a-M 9 S X 9 9 II 

OPC90 33 PP 
• D.-^a.© 0,0. MM 

oa H H II 9 9 
U'739U«00 PP 
7 a ■ OJ C C_ •«.«!. 
r© 0 H M o H -M 3 CP I I 
9 ooHjgfH:H:H-oupP 
X-M • '73 ft3*0i<E-<«9 

HMflacaC9 9 9' 199 

9(JO9X9099PP 
'-'aE-.H-HHOQ 3X 9 9 

t 19 9 (-r >-3 iJ 

P J 9 9 O 3 

9 X X _ O.'-' 

OOE-t-* A73 


lx 

U >1 9 
<0 C 9 

a 03 oa 
o o 
“.^1*^1 

9 9 


. loo 
I X u 
CS 


C 9 
O 9 


•H 9 
H,3 

p's 

9^1 

P73 

OT.9 

|M 
P 9 
9'3 
9 M 

>3 9 
' C 
COM 

19 


M 9 
9 M 
>,o 


CQ S 

O H 
|-|I- 

9 >• 

55 


9 I 

X 9 

ay'5 

f- 9 • 

3 9 CQ 
HO 

0 9 9 
O MX 
b. H 


P P -H 
9X0. 

P ,9 

<n zx 

• • 9 
CD 03 9 
U O H 
HH. I 

S - 

XX Mvm 
H H a -H 


1“ 

§s 

H« 9 

a i* 

a'l 


9P 
P 9 

m-4 

p 

973 

9 g 
X 

9 9 • 

9 c: p 

P -I -M 

>—* 

*073 9 
9 9 > 
P 9 O 

9-0 a 

7} 9 

ao M 

ex 

o P o 
y p 
X 

9 p 9 


*P 9 


•M •—4 
973 
O 9 

“;S 


oco 

30 

73 9 

OX 


°r 

§? 


■ I 
9 P 
3 M 
9 9 
3 P 

0|«j 

73 P 
9 9 


« 9 P 
9*0 9 

^ . 9 M J 

9 a 0 . 0 . 

- ■O'-' 9 II- 
3 M P 9 9 CO 

HH 

s^r,j 

O P PX 
e M M H 

K P P'-' 

' 

9 I I 
3 P P 
9 9 9 
3 9 9 
O.P P 

■o'53 

9 

M 

•s 


'*l°l 

!S 

9 9 9 

a^ss 



P-H 

a-H 9 ex 
o P c 9 u 
• D.M 06.0 
CQ H ‘-• 

O O 73 < 

H-H 9 L_ 

to 9 -H M O H H 73 
O O H 9 H.^^73 
-H . .73 r0 73-< 
HMC0a3CO99 • 
0UU9X990 
— aiHH-IHQQ 3 
I 19 9 

p I 9 9 O 3 

9 X X _ O. 

OO H H A73 I 


Ot I I I I I 9 
_ I I I I I O 


C-36 





no u. 

^ -M 

ca u • » < 

•H • 0»4J £ 

£4*0 0 ( 

» « 3 » 

O'OOO'O + 

Z C 3 « 

O C CQ, £ 

S'-* o I : 

a <a H c -sc 

•H U *j o 

H (0-H^ 

N *J 

9 H )«• 
j3 J9-^ N V 
H'O H-H V 
C V 

O D-H V 
AO 4J V 
A 0 OD.V 
A W-H V 
A • "O O V 
A O H V 
A fll-H-O 
A'O M Ob • 
A C « H 
A « O- 


-« O • 


o 


-g 

8 .!. 
O CP 
i H 9 

I oJa 


JO 

I -tJ M 

3 4J 4J 3 4J 
« 3 3 3 pu 3 3 
X Oi O* Du ' Dt Du 

. ... o • ‘ 

o o o o*-*.© o 

tH »H M IhH t-l 

I I I |4J I I 

4J 4J 9 ni 4J 4J 

>« X e X O X X 
9 9 -H 9 <H 9 9 


TJ 9T5 
O C O 
'H *H *H 
U 

0 |9 

a.,3 A., 
9 

§=;§ 

®i 2 ®i 
*j 14J 
C ^ fi 
-H X -H 
»4 9 H 
CU (H CU 


9 9 

§•§• 

9 0 

0 o 


3 3 

9 9 

3 3 

O'.O'. 


•8-8 


9-0 
O O 
C H 
9 U 
tJ 0 
h a. 


6 9 3 
MS 9 
19 3 
>^3 0. 

I la 


ss 

U,9 


a 3 

u c 

H-H 

UJ 
9 C 
jC O 
H U 




c jia 

0 TJ HH. 
43 O I 
■P -H4< 
>. « 
>• h 9 9 
M O (L H 
O *J • • 

9 OD oa 

JSTJOCJ 
•o C f*.*-. 

|S,, 

• f- H 


9-S 9 

10 O 9 

5**:? 

* 9 ^ 
9 9 -H 
9 -H M 
-<43 9 

^. 2 >i 
-H h 9 
X 9 M 
9>,0 

'’lo'Ji 

“d 04< 
o H Cl 
-H M 9 
M 9 H 
9 Du 


C C0M 
0 9 a,k< 
43X 19 

44 • O,o< 
00 9 > 
C U 3 CQ 
O l-« W) O 
•H \ IH. 
4J 94< I 
943 9 9 
N H 9jC 
•H t-*.!-* 

^ I 

•H 9'-' 

4J 44 O 
D.9-H 44 
-.1® ? * 
9 (fa -H 

U -f (fa 


V o 
•H 
C 44 
O 9 
•H M 
44 -H 
9 -H 
N H 
-H 44 

-H D, 


C-H 
O 44 
-H 9 
44 N 
9h 
H-H 


I 


■»3 

9 9 

3 3 


—1 *4 

I « 9 O, 
o.-Hca a\ 
>• |9 0C».T> 

C O C H io 

o :H o o.'H 

-H ta -H 9 B H 

44 c O 44 ^ 9 9 

■M a, 

243 M73 
2 *4 9*0 
•9 a> < 


♦ on 

•H •• 

C 44 
O 9 c 
•H »« o 

44 -H-H 

9-H 44 


44-O-H 
D.9 44 
IHD. 




f--< CM 
•H 9 9 
9 43 9 
0 44 44 


I 


9 H 
O 9 

•«> e 44 

9 *-• 
■044 • 
O H 9 
-H O 3 

H a9 

9 8 3 


•9 


8 


?SS.-“,S 

S 

•0 

0 

-H 44 )9 9 

Ml-* >.9'0 

44 

M 


Cd ! 

a 1 

u t 

9.Q.01 &* 
0 ^)9 H 

0 &44 9 

o' 

>• 

44 

•H 

-H 

M 

0 

a, • 0 

00 

IC 

0 0 

H-H 

M -H 

9 ■ M 
Oi V 9 

•H 

M 

9 

0 00 M M 

•H 1 19 0, 

*44 4| » 9 > 

0> 9 44 $ 
H 9 

9 43 9 

0 

'H 

M 

0 

•H 

M 

H 

M 

O* 

0 n.o 
H. M 
19 M 

9X 9 

JS 

*44 MT) 

*44 

a 

-H Q. 9 9 9 

• 9 -4 M 0 

*0 •>.00 3 44|i e 

0*44 0 e -H 9 

2 ' 

oo 1 

•His 44-H 
X 9 

M 

9 

“•1 

9 

M 

X H a« 
H 

-H 9 < 

At 

•H 


9 .H t- H M 9 44 
U4 0 M M 


9HUD. g B 
*0 O 

e u 
9 a 


is 

3 C 
0.9 
44 

9 H 

!f 

I 


9 o 

SS 

9 M 
M 9 

C H A. 


C-37 













paOCEDORE Print Periodic Tasks — — PROCEDURE Print_Test_Timee 


o o o 


O. CU Ou 

& & s 


H a.-H -o 

E 

o e e 

—« o* o*z 

^ u I I z 

o ao M M’d^ 
s o -H o 0*0 
* O >4 O* B 

'H o O O I 

Cb,4J V 

u IC C ca 
M-j C M M OB 

0*0 O H 

i* O Z, 

I +j 

- o «g a a ck< c 
pu ,x 04 a • o 
0 I • • • o 
c X - o o M c 

H (Q <H M M K- 

JS I 1^ 

I . c 4J ^ O 4. 

P • H S« X O > 

a*-< o O'H 4 

l4 -nH H U. t- 


a a 
2^2 


a o. a 
^ ^ ^ 


I C *0* • e» O 

I o a o M M *0 ->^'0 
I z O-H o o o o 
I O M O' o^z* S* 

I ^ o o o I i 

i a< 4-* 4-1 4^ 

t u ic c <a a 

I U-^ CfHH* OB ©• 

I 0*0 o (-• H 

» a 02.- 

BB-H I *J 4J 

BB WX4->4-)a4Ja4 

'Ooaaaaas 

a .Z a a ‘a * c 

0 O O I ‘ * *0 *o 

C C C X *00 t-t.O M.C 

■J.K* JZ \ l4J \*i 
I 1 I < C 4^ V O ^ O 4 
S 4 J 4 J ••HXX0X09 

0 a a<H o o^ O'H < 
Baa -rtHt«aE-<at 


|4J I 

4 44 a 
X o X o 
O'H • o 


I T) • • tt B 

I a o k< Ki g { 

I O -H O O O 4 

I O M O'O'ttB 0 

I 'H o O O I 

I a 44 4-> 44 4 

10 IC C O B 

I -H CK-tK-t OB 4 

I "O O H I- 

I O 2. 

Hi *4 * 

>4 X 44 4> a 44 : 

"ooaaaao 
a Z a a ‘a 
0 I • • • o ■ c 
c X *00 K-* p •- 

H O i-H KH K4 ►■4 
-3Z I l4i |4 
i • C 4J 4-> O 4-» «l 

I-) • -H X X O X < 

3>H o 0-> o- 

i* •-‘H H a H ti 


a a a 
^ ^ 


Z 
« D 

g CO * * ^ 


KHOKiO 
|k 4 tK4 
|4J 1*4 ) 

«4-> « *4 a 

0 X0X0 
'H O'H O O •' 
a H a H'H 


B *o- • 

-4 a o M *4 0 

E O-H O OD 

o M O'O'a 

.-4 0 0 0 I 
a o. 4j 44 44 

XU ic C (B 
a -H c M KB o 
( 0*0 o H 
- 

• Hi *4 
»4 X 44 *4 a 

-* o o a a a 
a Z a a • 
0 I • • * o 
c X • o o 

H « rH M KH 
JZ I U4 
t • C *4 4J « 
!■> '-H X X O 
3r-l O O'H 
it iHt-tBa 


ca <e o 

B Ob o C 

H f-*--4 

*4 44 I 

*4 3 *4 a » 
3 a a a o 
a • a • z 
. o • o • 

1*4 1*4 I 

*4 fl *4 O 44 
X O X O X 
O 'H O 'H O 

H a H a (-• 


c c 

00 e c 

•H -H 00 

44 44 -H H 

X O *4 *4 

N N XX 

■.4 N N 

'H 'H 'H 'H 


« M •» h H •» I 

O 0 0 ' 

a.O a a 0 3 

ICB Cb 

>.-H *-* H 

cQi-a.^ j-o 

I I *4 I 

« » 44 3 » 4 

^ o a a o : 
tt z a • z c 

X • • o * 

HPOmoC 

|K-( M K-B K 
*4 I 1*4 I 

C *4 44 X 44 4 
H X X o X : 
it o O'H o ( 
a N {B a H e 


*4 a k 44 3 9 4 
3 a o a a o : 
a • z a *20 
. o • • o * 
O MO O MO c 

M Im »-i H K 

I 1*4 f Ui I 

44 X 44 *j X *4 4 
X O X X O X i 
©M 0 O'H o ( 

(-• a H (-' a H (■ 


3000a 

T rri*4 

|4 44 *4 *4 C 
X X X X-H 
0 0 0 0 ^ 
HH«- H a 


C-38 


















II 

*-• t-* 


CO^ h M Q 
*0 'U O O 
C C tT< lylH 
0 0 9 9 
• .U 4J 4J 

m <q c c 9 

O O H H O 


■wo w 

-I -I 



. § 


X 9 
PU3 • 
U) H 


a a 
2 & 


*0 o 
c o 
O'H 


X a.-H rvH 

M o-"'-' * 

CO O 9 9 Z 

10 -H C O' M 

^ «§35 

-H M M CO • 

I z - Q. 

I Mao» 4 ha.««H>^n 
ISO -'4 000 O O 

I O M O'O'O* Oa U 

I M 9 9 9 I I !•» 
I (0 a. w w w w *J 

I M tj iCCCO (0 oo 

I CMCH «• «• o c 

I flJTJ O ... - 

I H O Z, 


•> H I 


» u a 

9< Q* 


H ^ H ^ H 


• • M K « 
9 a ; 
0 <,S 0 


J WW9W9W9» 
99a.9ai90<9 
o. Ck. • Oj • a< • Z 
W999 l.-.0*0*0* 

CCCX •OOMOMOMO 
kO -H -H -H (0 ft l-l t-l H H H *• 

j j,rj.aB I Iw Iw IW I 
N I I I'awwowowowo 
kWW '-HXKOKOXOKO 
M 9 9 9<M O OM 9M 9M 9 
0 Z Oi D< -- - - - . . - 


0) J3 H. 
CM *J 
9 « O 
ji ocDH 
W H. “O 

la o 

r* O H 
•H M M 

a T) 0 9 


U H 


1 


ISSS-^S 

Z, I I 
_ (WWW 
V W X K X H 
CW (1 9 0 9 0 
9 -H 9 H H'M 

T 3 
fi w 
O-H 


12,=“^, 

9 IW I W 

as w (0 w <• 

_ IC 9 B 9 

•o 

C 'M O M MW I 
9 -'4 0 Ot w -M .w 


*0 o 

B O 
9-« 


T3 
Cw 
9 -* 


•OH 
B M 
0 Cb 


C-39 










PROCEDURE Schedule — — PROCEDURE Soine_Periodics_Optional 


iSS 

<9 S 


O +J 
JS u u 
(0 o 
O. 0. CS 
<+4 0 e ^ 
O J3 •H -H -H 
H O 

0 C W Q 
'O O OT3 
O • H » 
6^ 4J O O 
^ C4*-t 4J 

§r 




i* 

s 


O to T> 

o (0 (0 jio o 

K 4J 4J Q J= 
O M O U 
O 0 -P CO 

o ax: 

x: -POO 

p-i j5 

O CO P 

■P c o o o 

to O <+4 +i 
3-HTJ 
T?-P © O C 

■V ap-H o 

to O to -p 
3 -W P 
O P -ri <0 <0 
P •H'O <0 P 
_ 0-0 0 3 

*0 x: o a'o 


to 3 C P O 
•H O O -H -H 
O-H P 

o X P p a 

P O <0 <0 o 

3 Nx: 

*0 C -H P P • 

o OP 

U O -H O P p 

O p p p <0 

p p o a 

ao lasx: 

x: o (O'H 

« p j o 

■H TJ • o c 

X3 to 0-0 O 
H .X -H o x; H 
CO p3 p p 
<0 O *0 -H Q, 

p a <0 s o 


c c 
o o 

^iS 

MO 

ta o 

O 03 


03 3 

u c 

H -H 

iP 

o c 
x: o 
H O 


<0 «>. 

G >i„ C 
O OT} O 
•H*H 0-P 
C P O -H P 
O O.Q P O 
JS O ^10 N 
P • 0.01-H 
CQ (S 

C U » CQ -H 
O H.to O P 


P 9M^P I 
ox: (0 O'H 

N H O J3 O 
■H IhH G 
'H-*- O 


O 

C -H P <0 

O P'H o o 

-P O O Or fH 

P N c • • 
to -p O CQ CQ 
N ^ -P U O 
P-P p *-• l-i 

>HP o. I I 
■p D.O O O 
p I x:x: 
» t->H 
<0 •• 

O C 


-p 


I O H O O 

_ -p 'O-P'O o 

PPO PCOPOO 
o.«0 PP:P o-pipS^ 
_|0 » lOTlJS PTJ «X3 
•O^H O'Op 0*0 <0 <0 
o(*i ■px: Oico-p 




C P 
O <0 
-p N 
p-p 

to <P 

N-P 
•p p 
*HO, 

•p I 
p w 
D.to 
c 
o o 

•p p 
*0 P 
O P 
-PTJ 
PTJ 

o < 


p -p -p 
(Oep P 
N-P <0 
•P p N 
•H D.-P 

•P^H 

PTJ-P 
D.O P 

^ &;i 

O OTJ 

■p ce o 


u o 
<0 u 
> o 
Ip 
o tn 

-P • 
TJ CO 
O.X 
■P <0 
U <0 

o e-, 

Oi i 

• o 

cq -P 
OTJ 
H,0 
IP 
O P 

x: o 

H O. 


• o 

(BOP 
P 3 O. 

o 

•-t 3-^ 

«o. 

c ) 

OTJ 
•P o 
p p 

g;-8 

tP 

®o, 

..o 


(OTJ O 

•sss 

•«. O P P 
Z.O p 
O ICh o 

3 0 ta 

P;P O 6 
t+TJ CO 
.« OP 
■ -p O 3 

<+4 .. p > O 

-P O <0 c 
_ o o. p 

TJ 3 fci 
C’+4 c P 

o -p -p to o 

_ P 3 P 
TJ C -*-»3 
C OTJTJ 
OOi< g 

TJ O 
C P 

o a 


P <0 

ac 

0,0 

<0 P 

o a 
•p o 
T3 I 
o «l 
•P o 

0-3 

‘^^p 
O P 
to O 

0*^1 



.. I 


C40 












5~ 


• 9 

1" 

So 

«o 


Sc 


u 

• 

*i 

s >* 


•g 

•H 

u 

& 


.-1 

« • 

OS ^ 


•"'8 

mxi 


M 0 9 

s^& 


^ -H 
Ai 4J 4J 
O 

«4 C JJ 



S.S 358- 

i¥. i4 

i/rs 


U 9 a 
««OI 

■S- 





C •' 9 1 ^ 

|4 0) C o P< 1 

r* A A M 9 A 

S « PS 4J 
a 4J CO 



Am V V ^ V 

2 -S 2 < ^ ^ 

£ 2 « lU P 1 

3 O O 1 

J • 

• 

t 1 1 1 £ 

1 1 t • 3 

• 

•§ 



!■§ 


»:-a 

Sffl s 


Vli 




U 9 

“ Ai 

s 

8n I Smma 

^SS 

8 .'...'3:3 

5‘llll 

>1 2 U I I 

*i 0 9 9*t *i 

-H S 9 «0 ■ • 

h 1-4 • U 9 9 

O 0 9 O 4J 

^ 4 i”; 

*4 ■ S t* ? 

.• 9 iS I C 


s 

■s 


I d 
1 



C41 





O V « 4 

04 C > I 

V) « U (d A I 

U > o- II ' 

ecu (H 



C-H, 


■HM I 
> <a^ 
(0 (a 
TJI-i fl 
• \*J 

«-H 

sai 

o a >% 

« » «0 +i, 

3 a 9 i 

C a 

M»-* a 

(t) O'-'.tJ 
•4 a A. 
n«M I 


z a •'H 

•-4 a ov^ 

J> a-H 


a D> 
a a 
a a 
>«-• a 


o ^ a 4J 

a, G > a 

CO a ui A M 

w > A- a 

oc u 


a. c > a 
<0 a u A M 

Ul > A. « '-• 
OC (d 


Q a I 

a.” ■ 


>4 M 
4J 4J 

a a 




P- O A< A. fO 


4J -4 a 

c 4 j,c--.h. 

a Hen I 
> >* 
U) WTJTJZ 
A* a a c ia 

+4 a-H'-' 
*j a-oji^ 
y A- A. O. 4J 





TJ -4 |4J 

O -H 

■O -HtJ l4 O 
c M a a Q. 

• - - *4 B 


IS.-81 


(\. (V. {%. A. A- 


S a *J 
a A- 
CdH 
A- A- M 

a 

4J 4J a 

0 0*4, 

a a I 
hi h a 

^ 4J > 

a a o 

S M M 6 


3 

u 

3 

M 

3 

M 

1 

1 

1 


C-42 











Bibliography 


[AdaLRM, 1983]. Department of Defense. Reference Manual For The Ada Programming Language. 
ANSl/NlIL-STD-1815 A. Washington: Ada Joint Program Office, Office of the Under Secretary 
of Defense Research and Engineering, January 1983. 

[Aldem, 1990]. Aldem, Thomas D., and others. Phase / Final Report of the Pilot's Associate Program, 
Interim Report for Period November 1989-December 19^. Wright Research and Development 
Center Technical Report WRDC-TR-90-7007. Marietta, GA: Lockheed Aeronautical Systems 
Company, December 1990. (Limited Distribution - Distribution authorized to DoD and DoD 
contractors only). 

[Aldem, 1991]. Aldem, Thomas D., and others. Phase 2 Interim Report of the Pilot's Associate Program, 
Interim Report for Period November 1989-December 1990. Wright Labcaatories Technical Report 
WL-TR-91-7()()7. Marietta, GA: Lockheed Aeronautical Systems Company, October 1^1. 
(Limited Distribution - Distribution auAorized to DoD and DoD contractors only). 

[Allen, 1990]. Allen, Arnold O. Probability, Statistics, and Queueing Theory with Computer Science 
Applications (Second Edition). San Diego, CA: Academic Press Inc., 1990. 

[ARTIE, 1989]. Boeing Military Airplanes. Ada Real-Time Inferene Engine (ARTIE) User's Guide. 
Version 1.1. Witchita, K: Avionics Technology, March 1989. 

Panks, 1991]. Banks, Sheila M., Lizza, Carl S., and Whelan, Michael A. “Pilot's Associate: Evolution of a 
Functional Prototype,” AGARD Corference Proceedings Machine Intelligence for Aerospace 
Electronic Systems, pp. 16-1 thru 16-12. 7 Rue Ancelle 92200, NeuiUy sur Seine, France: 
Advisory Group for Aerospace Research & Development, May 1991. 

Paraah, 1991]. Bamah, S., and others. “On-line Scheduling in the Presence of Overload,” Proceedings of 
the 32nd Annual Symposium On Foundations of Computer Science, pp. 100-110. Los Alamitos 
CA: IEEE, IEEE Computer Society Press, 1991. 

Pihari, 1989]. Bihari, Thomas E., Walliser, Thomas M., and Patterson, Mark R. “Ccnitrolling the Adaptive 
Suspension Vehicle,” IEEE Computer, 22,6: 59-95 (Jime 1989). 

Pooch, 1983]. Booch, Grady. Software Engineering with Ada. Menlo Park, CA: The BenjaminA^ummings 
Publishing Company, Inc., 1983. 

Pooch, 1986]. Booch, Grady. Software Components with Ada, Structures, Tools, and Subsystems. Menlo 
Park, CA: The Benjamin/Currunings ^blidiing Company, Inc., 1986. 

Porger, 1989]. Borger, Mark W., Klein, Mark H., and Veltre, Robert A. Real-Time Software Engineering 
in Ada: Observations and Guidlines. Technical Report CMU/SEI-89-TR-22. Carnegie Mellon 
University, Pittsbmgh, PA: Software Engineering Institute, September 1989. 

Prassard, 1988]. Brassard, Gilles and Bratley, Paul. Algorithmics Theory & Practice, Englewood Cliffs, 
NJ: Prentice Hall, 1988. 

[Broger, 1989]. Broger, Mark W. and Rajkumar, Ragunathan. Implementing Priority Inheritance 
Algorithms in an Ada Runtime System. Technical Report CMU/SEI-89-TR-15. Carnegie Mellon 
University, Pittsburgh, PA: Software Engineering Institute, April 1989. 

[ClassicAda, 1989]. Software Productivity SolutioTis.Classic-Ada User's Manual. 1989. 

[CLIPS-Ada, 1991]. NASA. CUPS!Ada Advanced Programming Guide. Version 4.4, Revision 1. Johnson 
Space Center: Infnmation Systems Directorate, Software Technology Branch, October 1991. 


BB-1 




[CLIPSRefMan, 1991a]. NASA. CLIPS Reference Manual, Volume I, Basic Programming Guide. CLIPS 
Version 5.1. Johnson Space Center: Information Systems Directorate, Software Technology 
Branch, September 1991. 

[CLIPSRefMan, 1991b]. NASA. CUPS Reference Manual, Volume II, Advanced Programming Guide. 
Version 5.1. Johnson Space Center: Information Systems Directorate, Software Technology 
Branch, September 1991. 

[CLIPSRefMan, 1991c]. NASA. CW^S Reference Manual, Volume III, Utilities and Interfaces Guide. 
Version 5.1. Johnson Space Center: Information Systems Directorate, Software Technology 
Branch, September 1991. 

[CLIPSUG, 1991]. NASA. CUPS User’s Guide Volume I - Rules. Version 5.1. Johnson Space Center: 
Informtdon Systems Directorate, Software Technology Branch, September 1991. 

[Coffinan, 1976]. Coffman, Edward G. Computer and Job-Shop Scheduling Theory. New York, NY: John 
Wiley & Sons, Inc, 1976. 

[Cohen, 1986]. Cohen, Norman H. Ada as a Second Language. New York, NY: McGraw-Hill Book 
Company, 1986. 

[Cormcn, 1990]. Cormen, Thomas H., I^eiserson, Charles E., and Rivest, Ronald L. Introduction to 
Algorithms. Cambridge, MA: The MTT Press, 1990. 

[Dechter, 1991]. Dechter, Rina, Miri, Itay, and Pearl, Judea “Temporal constraint networks,” Artificial 
Intelligence, 49,1-3 : 61-95 (May 1991). 

[Dodhiawala, 1988]. Dodhiawala, Rajendra and Sridharan, N.S. Real-Time Impact Report (RT-1 Impact 
Analysis). MCAER SDRL 10-1. Santa Clara, CA: EMC Corporation, Central Engineering 
Laboratories, September 1988. 

[Dodhiawala, 1989]. Dodhiawala, Rajendra, Sridharan, N.S., Raulefs, Peter, and Pickering, Cynthia “Real- 
Time AI Systems; A Definition and An Architecture,” Eleventh International Joint Conference on 
Artificial Intelligence, pp. 256-261. San Miieo, CA: The International Joint Conferences on 
ArtiHcial Intelligence, Inc., Morgan Kaufmann Publishers, Inc., August 1989. 

[Fanning, 1990]. Fanning, Franklin Jesse. An Evaluation of an Ada Implementation of the Rete Algorithm 
for Embedded Flight Processors. MS thesis, AFT 17GE/ENG/90D-70. School of Engineering, Air 
Force Institute of Technology (AU), Wright-Patterson AFB OH, December 1990. 

[Klahr, 1986]. Kalhr, Philip and Waterman, Donald A. Expert Systems Techniques, Tools, and 
Applications. Reading, MA: Addison-Wesley Publishing (Tompany, 1986. 

[Klein, 1990]. Klein, Mark H. and Ralya, Thomas. An Analysis of Input/Output Paradigms for Real-Time 
Systems. Technical Report CMU/SEI-90-TR-19. Carnegie Mellon University, Pittsburgh, PA: 
^ftware Engineering Institute, July 1990. 

[Lambert, 1990]. Lambert, R£., and others. Phase I Final Report of the Pilot’s Associate Program, Final 
Report for Period Febuary 1986-December 1990. Wright Laboratories Technical Report WL-TR- 
91-7006. St. Louis, MO: McDoimell Aircraft Compaiiy, December 1990. (Limited Distribution - 
Distribution authorized to DoD and DoD contractors oidy). 

[Lambert, 1991]. l.ambert, R.E., and others. Technical Operating Report - System Design Document. Final 
Report for Period August 1988-December 1990. Wright Laboratory Technical Report WL-TR-91- 
7005. St. Louis, MO; McDonnell Aircraft Company, September 1991. (Limited Distribution - 
Distribution authorized to DoD and DoD contractors only). 

[Lamont, 1991]. Lamont, Gary B. Real-Time Scheduling of Periodic and Aperiodic Tasks. February 1991, 
CSCE686 Class Notes, School of Engineering, Air Force Institute of Technology (AU), Wiight- 
Patterson AFB OH, February 1991. 


BIB-2 



[Liu, 1973]. Liu, C. L. and Layland, James W. “Scheduling Algorithms for Multiprogramming in a Hard- 
Real-Time Environment,” Journal of the Association for Computing Machinery, 20. 1 : 46-61 
(January 1973). 

[Liu, 1991]. Liu, Jane W.S., and others. “Algorithms for Scheduling Imprecise Computations,” IEEE 
Computer, 24.5 : 58-68 (May 1991). 

[Lizza, 1989]. Lizza, Carl S. “Pilot's Associate: A Perspective Demonstration 2 ,” Proceeding of 
Computers in Aerospace Conference.. AIAA, 1989. 

[Locke, 1992]. Locke, C. Douglas'; and Vogel, David R. Ada Real-Time Programming: A Seminar. March 
1992, IBM T" eral Sector Division, Owego, NY 13827. 

[Nii, 1989]. Nii, H. Peimy. The Handbook of Artificial Intelligence, Volume IV. Reading, MA: Addison- 
Wesley Publishing Company, 1989. 

[O’Reilly, 1988]. O’Reilly, Cindy A. and Cromarty, Andrew S. ‘"Fast' is not 'Real-Time'; Designing 
Eflective Real-Time AI Systems,” Applications of Artificial Intelligence II. pp. 249-257. SPIE, 
SPIE, 1988. 

[Payton, 1991]. Payton, David W. and Bihari, Thomas E. “Intelligent Real-Time Control of Robotic 
Vehicles,” Communications of the ACM, 34,8 :48-63 (August 1991). 

[Real-Time, 1984]. U.S. Army Conununications-EIectronics Command. Real-Time Ada Workbook. Fort 
Monmouth, NJ: Center For Tactical Computer Systems, July 1984. 

[Sawyer, 1990]. Sawyer, George Allen. Extraction and Measurement of Multi-Level Parallelism in 
Production Systems. MS thesis, AFT 17GCE/ENG/90D-04. School of Engineering, Air Force 
Institute of Technology (AU), Wright-Patterson AFB OH. December 1990. 

[Scoy, 1989]. Scoy, Roger Van, Bamberger, Judy, and Firth, Robert. An Overview of DARK, Ada-Letters 
(November/Dece nber 1989). 

[Sha, 1989]. Sha, Lui and Goodenou^, John B. Real-Time Scheduling Theory and Ada. Technical Report 
CMU/SEI-89-TR-14. Carnegie Mellon University, Pittsburgh, PA; Software Engineering Institute, 
April 1989. 

[Sha, 1991]. Sha, Lui, Klein, Mark H., and Goodenou^, John B. Rate Monotonic Analysis for Real-Time 
Systems. Technical Report CMU/SEI-91-TR-6. Carnegie Mellon University, Pittsburgh, PA: 
Software Engineering Institute, March 1991. 

[Shamsudin, 1991]. Shamsudin, Annie Z. and Dillion, T.S. NelManager: A Real-Time Expert System for 
Network Traffic Management. Technical Report 15/91. Department of Computer Science and 
Computer Engineering, La Trobe University, Bimdoora, Victoria, Australia 3083: La Trobe 
University, Dumber 1991. 

[Simpson, 1988]. Simpson, Robert L. “DoD Applications of Artificial Intelligence: Successes and 
FYospects,” Applications of Artificial Intelligence VI.. SPIE, SPIE, 1988. 

[Smith, 1990]. Smith, David M. and Broadwell, Martin M. Pilot's Associate System Knowledge Base 
Document, Volume I: Tactics Planner Subsystem, CDRL Sequence No. 32,. Contract F33615-85- 
C-3804. Marietta, GA; Lockheed Aeronautical Systems Company, October 1990. (Distribution 
Limited ' D and DoD contractors only). 

[Sprunt, 1989]. Sprunt, Brinkley, Sha, Lui, and Lehoezky, John. Scheduling Sporadic and Aperiodic 
Events in a Hard Real-Time System. Technical Report CMU/SEI-89-TR-11. Carnegie Mellon 
University, Pittsburgh, PA: Software Engineering Institute, April 1989. 

[Sprunt, 1990]. Sprunt, Brinkley and Sha, l4ii. Implementing Sporadic Servers in Ada. Technical Report 
CMU/SEI-90-TR-6. Carnegie Mellon University, Pittsburgh, PA: Software Engineering Institute, 
May 1990. 


BIB-3 






[Stankovic, 1988], Stankovic, John A. and Ramamritham, Krithi, Tutorial Hard Real-Time Systems, IEEE 
Catalog Number EH0276-6, Cmnputer Society Press Order Number 81, Eebruary 1988. 

[Stockman, 1988], Stockman, Steven P. “ABLE: An Ada-Based Blackboard System,” Proceedings of 
AIDA-88, Fourth International Conference on Artificial Intelligence and Ada. George Mason 
University, George Mason University, 1988. 

[Tindell, 1992]. Tindell, Ken, Bums, Alan, and Wellings, Andy, Allocating Hard Real Time Tasks (An 
NP-Hard Problem Made Easy), e-mail via ftp, 1992, Real Time Systems Research Group, 
Department of Computer Science, University of York, England. 

[VERDIX, 1990]. VERDIX Corporation. VADS Veridx Ada Development System Version 6.0. Sun-4 Sun 
OS. August 1990. 

[Whelan, 1990]. Whelan, Michael A. and Rouse, Doug Pilot's Associate: Approaching Maturity. In 
Seventh Annual Workshop on Command and Control Decision Aiding. Air Eorce Institute of 
Technology, Valusek, J. R. and Duffy, LorRaine, Ch. 3, Air Force Institute of Technology/ENS 
Wright-Patterson AFB, Ohio 45433-6583, Distribution Limited to DoD and DoD contractors only, 
April 1990. 

[Wilber, 1989]. Wilber, George F. “Intelligent Real-Tim, imbedded Systems,” Proceedings of AIDA-89, 
Fifth International Conference on Artificial Intelligence and Ada. pp. 74-82. Washington D.C.: 
Department of Computer Science, George Mason University and The Institute for Defense 
Analyses, George Mason University, November 1989. 

[Wilensky, 1983]. Wilensky, Robert Planning and Understanding A Computational Approach to Human 
Reasoning. Reading, MA: Addison-Wesley Publishing Company, 1983. 

[Wood, 1989]. Wood, William G. Temporal Logic Case Study. Technical Report CMU/SE1-89-TR-24. 
Carnegie Mellon University, Pittsburgh, PA: Software Engineering Institute, August 1989. 


mi 


BIB4 






Vita 


Captain Michael A. Whelan was bom to Dr. William J. Whelan and Barbara A. Whelan on July 25, 
1958. He enlisted in the United States Air Force on February 22, 1977 as an Aircraft Armament Systems 
Specialist. Captain Whelan served enlisted tours at Lowry AFB, Colorado; Cannon AFB, New Mexico; 
RAF Upper Heyford, United Kingdom; and Moody AFB, Georgia. His enlisted positions included 
Weapons Load Crew Chief, Shift Supervisor, and Weapons Controller in Maintenance Control. Captain 
Whelan obtained the enlisted rank of Technical Sergeant before entering into the Airman Education and 
Commissioning program in May of 1985. After graduating with honors from New Mexico State 
University, Captain Whelan attended Officer Training School and was commissioned as a Second 
Lieutenant on April 13, 1988. His flrst officer assignment was to the Cockpit Integration Directorate, 
Wright Laboratories, Wright-Patterson AFB, Ohio, where he served as the project engineer for the Pilot’s 
Associate program from June 1988 until June 1990. Captain Whelan was then assigned as the Chief 
Engineer for Multi-Role Cockpit program. In May 1991, Captain Whelan was accepted into the graduate 
computer engineering program at the Air Force Institute of Technology. Captain Whelan is slated to fill a 
Command Directed Educational Requirement (CDERs) slot at Wright-Patterson AFB after gr»luating. 


Permanent Address: 6370 Cqiper Hieasant Drive 

Dayton, Ohio 45424-4100 
(513) 237-9502 


vrrA-i 



REPORT OOCUIVIENTATION PAGE 



. 1 AGc'NrY liSY OKl.y Y ■ ^T^ Kv,#^;Y'aT I>A'c T1 rTpwkT TYPi AN 3 OATtS COVtnt.D 

I December 1992 j Master's Thesis 

AN INTELLIGENT REAL-TIME SYSTEM 
ARCHITECTURE IMPLEMENTED IN ADA 


Michael A. Whelan, Capt, USAF 

j 

'™"7‘"T"'“'r'or‘“r''-~’oT*TAY?TrOTiT^'TOHT5MEs} ^ ^ ] h . ?fRYOPViNG~:KGANi^’ATiON 

Nuvs';^ 

Air Force Institute of Technology, WPAFB OH 45433-6583 AFnyGCE/ENGy92D-12 


Major Carl Lizza 
WL/FIPA 

WPAFB, OH 45433-6553 


.. BT'A’isu''O'- i t:o:jY 

Approved for public release; distribution unlimited 


Conventional real-time systems are fully deterministic allowing for off-line, optimal, task 
scheduling under all circumstances. Real-time intelligent systems add non-deterministic task 
execution times and non-deterministic task sets for scheduling purposes. Non-deterministic task 
sets force intelligent real-time systems to trade-off execution time with solution quality during 
run-time and perform dynamic task scheduling. Four basic design considerations addressing those 
tradeoffs have been identified: control reasoning, focus of attention, parallelism, and algoritiim 
efficacy. Non-real-time intelligent systems contain an environment sensor, a model of the 
environment, a reasoning process, and a large collection of procedural processes. Real-time 
intelligent systems add to these a model of tiie real-time system’s behavior, and a real-time task 
sched^er. ^ addition, the reasoning process is augmented with a metaplanner to reason about 
timing issues using the system’s behavioral model. Additionally, real-time deadlines force the 
inclusion of pluralistic solution methods in the intelligent system to allow multiple responses 
ranging from reactive to fully reasoned and calculated. This research presents an architecture 
capable of meeting real-time performance goals with on-line scheduling of tasks. 


Artificial Intelligence, Real-Time, Ada, On-line Scheduling, 
Knowledge-bas^ Systems, Expert Systems 


^ I 

„ JUMCLAS5IFIED. 1 _12NCLASSIEIED_i 




__ 








