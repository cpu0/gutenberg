__ "ATION PAGE 

TSSc j&n*AZ I m3 UTV ^1hMT»wiMMnM.Mu«n(tlw«m 

Mn *® _T— — —■ — jtond nwK wgi rtn a thi, i 


Form Approved 
CPU No. 



f 1 hm»pm mtmn, Ornmutm m4m*q tmtfuuorw. «—wNw| —■<»>»a— mw 

Send nn««l » !■§■»*"■ *■>» » * " «*>—** mmyorm upao tt th>i g U wl awi M tlgn . iwiMire 

>fa» ^ »fcr l wti W iaHnO M l l Qai «^W» »»«». 1WJ*wn 0«t» H |h» re . 11M. VA 

MMQmcfll tfd Ulplt WsNflflsni OC SOSOS- 





940325S1.11346, AVF-: 94ddc500_2A 

DDC-I, DACS Sun SPARC/SunOS to 680x0 Bare Ada Cross Compiler 
System (BASIC MO DE), Version 4.6«9_ 


National Institute of Standards and Technology 
Gaithersburg, Maryland 


*m mis.-.mxcTf. jhtvi »i 


BSHafSj iSI^SSSS &6§ tandards and Technology 
Gaithersburg, Maryland 20899 
USA • 




Ada Joint Program Office 
The Pentagon, ftn 3E118 
Washington, DC 20301-3080 


94-15728 




10. arONWJHIhRyMONI IOHING 
AGENCY 



I Ef^.^i;TI:Tnr»T7CT7XrT:l[S 


Approved for Public Release; * distribution unlimited 



Host: Sun SPARCstation IPX (under SunOS, Release 4.1.1) 
Target: Lynwood J435TU (68030) (bare machine) 


DTIC 

C SSSQ 


tn^:T 



17. 

CLASSIFICATION 
UNCLASS FED 


UNCLASSIFIED 


CLASSIFICATION 

UNCLASSIFED 


25 01 ft™ QUALITY INSPECTP’.T' 


UNCLASSIFED 


sunaara porm zm). 
Prescribed by ANSI sm. 
















AVF Control Number: NIST94DDC500_2A_1.11 
DATE COMPLETED 

BEFORE ON-SITE: 94-03-18 
AFTER ON-SITE: 94-03-28 
REVISIONS: 94-04-11 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number 940325S1.11346 
DDC-I 

DACS Sun SPARC/SunOS to 680x0 Bare Ada 
Cross Compiler System (BASICMODE), Version 4.6.9 
Sun SPARCstation IPX => 

Lynwood j435TU (68030) (Bare Machine) 


Prepared By: 

Software Standards Validation Group 
Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


U.S.A. 


Accesron For 

NTIS CRA&I 
DTiC TAB 
Uf-.a.inounced 
Justification 



Availability Co’c'es 

j Avail a*id/or 
) Special 




AVP control Number: NZST94DDC500_2A_1.11 
Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on March 25, 1994. 

Compiler Name and Version: DACS Sun SPARC/SunOS to 680x0 Bare Ada 

Cross Compiler System (BASIC_M0DE), 
Version 4.6.9 

Host Computer System: Sun SPARCstation IPX running under SunOS, 

Release 4.1.1 

Target Computer System: Lynwood j435TU (68030) (Bare Machine) 

See section 3.1 for any additional information about the testing 
environment. 


As a result of this validation effort. Validation Certificate 
940325S1.11346 is awarded to DDC-I. This certificate expires 2 years 
after ANSI/MIL-STD-1815B is approved by ANSI. 


This report has been reviewed and is approved. 



_ _ 

Ada Validatioriz+ac^llilt^ r Ada Validation /Facility 

Dr. David K. JAJfewon Mr. L. Arnold ffdnnson 

Chief, Information Systems Manager, Software Standards 

Engineering Division (ISED) Validation Group 

Computer Systems Laboratory (CSL) 

National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 



Ada V^Rddhcsiff organization 
Director, Vjqjnitei: & Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 



Ada Joint Program Office 
David R. Basel 
Deputy Director, 

Ada Joint Program Office 
Defense Information Systems Agency, 
Center for Information Management 
Washington DC 20301 


U.S.A. 







NIST94DDC500_2A_1.11 

DECLARATION OF CONFORMANCE 

The following declaration of conformance was supplied by the customer. 

Customer: DDC-I 

Certificate Awardee: DDC-I 

Ada Validation Facility: National Institute of Standards and 

Technology 

Computer Systems Laboratory (CSL) 

Software Standards Validation Group 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 

ACVC Version: 1.11 


Ada Implementation: 

Compiler Name and Version: DACS Sun SPARC/SunOS to 680x0 Bare Ada Cross Compiler 

System (BASIC_MODE), Version 4.6.9 

Host Computer System: Sun SPARCstation IPX running under SunOS, Release 

4.1.1 

Target Computer System: Lynwood j435TU (68030) (Bare Machine) 

Declaration: 


I the undersigned, declare that I have no knowledge of deliberate deviations from the 
Ada Language Standard ANSI/MIL-STD-1815A ISO 8652-1987 in the implementation listed 
above. 



Customer Signature 
Company DDC-I 
Title 


Certificate Awardee Signature 
Company DDC-I 


Title 


Date 

Date 




TABLE OF CONTENTS 


CHAPTER 1.1-1 

INTRODUCTION.1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES.2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST MODIFICATIONS.2-3 

CHAPTER 3.3-1 

PROCESSING INFORMATION.3-1 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 


APPENDIX A.A-l 

MACRO PARAMETERS.A-l 

APPENDIX B.B-l 

COMPILATION SYSTEM OPTIONS.B-l 

LINKER OPTIONS.B-2 

APPENDIX C.C-l 

APPENDIX F OF THE Ada STANDARD.C-l 


























CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro92] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to [Pro92]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552). The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield, Virginia 22161 
U.S.A. 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 


Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria, Virginia 22311-1772 

U.S.A. 


1-1 





1.2 REFERENCES 


[Ada83] BfiiSTSflgfi_Manual_£&E_the Ada Programming_ Language . 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro92] Ada Compiler Validation Procedures. Version 3.1, Ada Joint 
Program Office, August 1992. 

[U689] Ada Compiler Validation Capability User's Guide. 21 June 
1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK_FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECKFILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is 
compiled and the resulting compilation listing is examined to 
verify that all violations of the Ada Standard are detected. Some 
of the class B tests contain legal Ada code which must not be 
flagged illegal by the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values—for example, the 


1-2 




largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 
the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [U689]). 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler 


Ada Compiler 
Validation 
Capability (ACVC) 


Ada Implementation 


Ada Joint Program 
Office (AJPO) 


Ada Validation 
Facility (AVF) 


Ada Validation 
Organization (AVO) 

Compliance of an 
Ada Implementation 


The software and any needed hardware that 
have to be added to a given host and target 
computer system to allow transformation of 
Ada programs into executable form and 
execution thereof. 

The means for testing compliance of Ada 
implementations. Validation consisting of 
the test suite, the support programs, the 
ACVC Capability User's Guide and the 
template for the validation summary (ACVC) 
report. 

An Ada compiler with its host computer 
system and its target computer system. 

The part of the certification body which 
provides policy and guidance for the Ada 
certification Office system. 

The part of the certification body which 
carries out the procedures required to 
establish the compliance of an Ada 
implementation. 

The part of the certification body that 
provides technical guidance for operations 
of the Ada certification system. 

The ability of the implementation to pass an 
ACVC version. 


1-3 





Computer System 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable Test 

ISO 

LRM 


Operating System 


Target Computer 
System 


A functional unit, consisting of one or more 
computers and associated software, that uses 
common storage for all or part of a program 
and also for all or part of the data 
necessary for the execution of the program; 
executes user- written or user-designated 
programs; performs user-designated data 
manipulation, including arithmetic 
operations and logic operations; and that 
can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 

Fulfillment by a product, process, or 
service of all requirements specified. 

An individual or corporate entity who enters 
into an agreement with an AVF which 
specifies the terms and conditions for AVF 
services (of any kind) to be performed. 

A formal statement from a customer assuring 
that conformity is realized or attainable on 
the Ada implementation for which validation 
status is realized. 

A computer system where Ada source programs 
are transformed into executable form. 

A test that contains one or more test 
objectives found to be irrelevant for the 
given Ada implementation. 

International Organization for 
Standardization. 

The Ada standard, or Language Reference 
Manual, published as ANSI/MIL-STD-1815A 
-1983 and ISO 8652-1987. Citations from the 
LRM take the form ”<section>.<subsection>; 
<paragraph>." 

Software that controls the execution of 
programs and that provides services such as 
resource allocation, scheduling, 
input/output control, and data management. 
Usually, operating systems are predominantly 
software, but partial or complete hardware 
implementations are possible. 

A computer system where the executable form 
of Ada programs are executed. 


1-4 




Validated Ada 
Compiler 

Validated Ada 
Implementation 


Validation 


Withdrawn Test 


The compiler of a validated Ada 
implementation. 

An Ada implementation that has been 
validated successfully either by AVF testing 
or by registration [Pro92]. 

The process of checking the conformity of an 
Ada compiler to the Ada programming language 
and of issuing a certificate for this 
implementation. 

A test found to be incorrect and not used in 
conformity testing. A test may be incorrect 
because it has an invalid test objective, 
fails to meet its test objective, or 
contains erroneous or illegal use of the Ada 
programming language. 


1-5 





CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 104 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 93-11-22. 


B27005A 

E28005C 

B28006C 

C32203A 

C34006D 

C35507K 

C35507L 

C35507N 

C355070 

C35507P 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

C37310A 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A54B02A 

C55B06A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 






2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Commentaries and commonly referenced in 
the format Al-ddddd. For this implementation, the following tests 
were determined to be inapplicable for the reasons indicated; 
references to Ada Commentaries are included as appropriate. 

The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS; 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 


2-1 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 



C35708L..Y (14 tests) C35802L..Z (15 tests) 

C45241L..Y (14 tests) C45321L..Y (14 tests) 

C45421L..Y (14 tests) C45521L..Z (15 tests) 

C45524L..Z (15 tests) C45621L..Z (15 tests) 

C45641L..Y (14 tests) C46012L..Z (15 tests) 

C24113I..K (3 tests) use a line length in the input file which 
exceeds 126 characters. 

The following 20 tests check for the predefined type LONG_INTEGER; 
for this implementation, there is no such type: 

C35404C C45231C C45304C C45411C C45412C 

C45502C C45503C C45504C C45504F C45611C 

C45613C C45614C C45631C C45632C B52004D 

C55B07A B55B09C B86001W C86006C CD7101F 

C35404D, C45231D, B86001X, C86006E, and CD7101G check for a 

predefined integer type with a name other than INTEGER, 
LONG_INTEGER, or SHORT_INTEGER; for this implementation, there is 
no such type. 

C35713B, C45423B, B86001T, and C86006H check for the predefined 
type SHORT_FLOAT; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with 
a name other than FLOAT, LONGFLOAT, or SHORT_FLOAT; for this 
implementation, there is no such type. 

C45531M..P and C45532M.,P (8 tests) check fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for 
this implementation, MAX_MANTISSA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLOWS is FALSE for floating point types and the results 
of various floating-point operations lie outside the range of the 
base type; for this implementation, MACHINE_OVERFLOWS is TRUE. 

C4A013B contains a static universal real expression that exceeds 
the range of this implementation's largest floating-point type; 
this expression is rejected by the compiler. 

D56001B uses 65 levels of block nesting; this level of block 
nesting exceeds the capacity of the compiler. 

B86001Y uses the name of a predefined fixed-point type other than 
type DURATION; for this implementation, there is no such type. 

C96005B uses values of type DURATION'S base type that are outside 
the range of type DURATION; for this implementation, the ranges are 
the same. 

2-2 



CA2009C and CA2009F check whether a generic unit can be 
instantiated before its body (and any of its subunits) is compiled; 
this implementation creates a dependence on generic units as 
allowed by AI-00408 and AI-00506 such that the compilation of the 
generic unit bodies makes the instantiating units obsolete. (See 
section 2.3.) 

CD1009C checks whether a length clause can specify a non-default 
size for a floating-point type; this implementation does not 
support such sizes. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length 
clauses to specify non-default sizes for access types; this 
implementation does not support such sizes. 

The following 264 tests check operations on sequential, text, and 
direct access files; this implementation does not support external 
files: 


CE2102A..C 

(3) 

CE21026..H 

(2) 

CE2102K 


CE2102N..Y I 

[12) 

CE2103C..D 

(2) 

CE2104A..D 

(4) 

CE2105A..B 

(2) 

CE2106A..B 

(2) 

CE2107A..H 

(8) 

CE2107L 


CE2108A..H 

(8) 

CE2109A..C 

(3) 

CE2110A..D 

(4) 

CE2111A..1 

(9) 

CE2115A..B 

(2) 

CE2120A..B 

(2) 

CE2201A..C 

(3) 

EE2201D..E 

(2) 

CE2201F..N 

(9) 

CE2203A 


CE2204A..D 

(4) 

CE2205A 


CE2206A 


CE2208B 


CE2401A..C 

(3) 

EE2401D 


CE2401E..F 

(2) 

EE2401G 


CE2401H..L 

(5) 

CE2403A 


CE2404A..B 

(2) 

CE2405B 


CE2406A 


CE2407A..B 

(2) 

CE2408A..B 

(2) 

CE2409A..B 

(2) 

CE2410A..B 

(2) 

CE2411A 


CE3102A..C 

(3) 

CE3102F..H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A..C 

(3) 

CE3106A..B 

(2) 

CE3107B 


CE3108A..B 

(2) 

CE3109A 


CE3110A 


CE3111A..B 

(2) 

CE3111D..E 

(2) 

CE3112A..D 

(4) 

CE3114A..B 

(2) 

CE3115A 


CE3119A 


EE3203A 


EE3204A 


CE3207A 


CE3208A 


CE3301A 


EE3301B 


CE3302A 


CE3304A 


CE3305A 


CE3401A 


CE3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A..C 

(3) 

CE3403E..F 

(2) 

CE3404B. .D 

(3) 

CE3405A 


EE3405B 


CE3405C..D 

(2) 

CE3406A,.D 

(4) 

CE3407A..C 

(3) 

CE3408A..C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE3410C..E 

(3) 

EE3410F 


CE3411A 


CE3411C 


CE3412A 


EE3412C 


CE3413A..C 

(3) 

CE3414A 


CE3602A..D 

(4) 

CE3603A 


CE3604A..B 

(2) 

CE3605A..E 

(5) 

CE3606A..B 

(2) 

CE3704A..F 

(6) 

CE3704M..0 

(3) 

CE3705A. .E 

(5) 

CE3706D 


CE3706F..G 

(2) 

CE3804A..P 

(16) 

CE3805A..B 

(2) 

CE3806A..B 

(2) 

CE3806D..E 

(2) 

CE3806G..H 

(2) 

CE3904A..B 

(2) 

CE3905A..C 

(3) 

CE3905L 


CE3906A..C 

( 3 ) 

CE3906E..F 

(2) 


CE2103A, CE2103B, and CE3107A use an illegal file name in an 
attempt to create a file and expect NAME_ERROR to be raised; this 
implementation does not support external files and so raises 
USE_ERROR. (See section 2.3.) 


2-3 










2.3 TEST MODIFICATIONS 


Modifications (see section 1.3) were required for 72 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in 
the way expected by the original tests. 


B22003A 

B35101A 

B38009B 

B61001R 

B83E01D 

B91002C 

B91002J 

B95077A 

BC1109D 


B26001A 

B37106A 

B55A01A 

B61001W 

B83E01E 

B91002D 

B91002K 

B97103E 

BC1202A 


B26002A 

B37301B 

B61001C 

B67001H 

B85001D 

B91002E 

B91002L 

B97104G 

BC1202F 


B26005A 

B37302A 

B61001F 

B83A07A 

B85008D 

B91002F 

B95030A 

BA1001A 

BC1202G 


B28003A 

B38003A 

B61001H 

B83A07B 

B91001A 

B91002G 

B95061A 

BA1101B 

BE2210A 


B29001A 

B38003B 

B61001I 

B83A07C 

B91002A 

B91002H 

B95061F 

BC1109A 

BE2413A 


B33301B 

B38009A 

B61001M 

B83E01C 

B91002B 

B91002I 

B95061G 

BC1109C 


C83030C and C86007A were graded passed by Test Modification as 
directed by the AVO. These tests were modified by inserting 
"PRAGMA ELABORATE (REPORT);" before the package declarations at 
lines 13 and 11, respectively. Without the pragma, the packages 
may be elaborated prior to package Report's body, and thus the 
packages' calls to function REPORT.IDENT_INT at lines 14 and 13, 
respectively, will raise PROGRAMERROR. 

CA2009C and CA2009F were graded inapplicable by Evaluation 
Modification as directed by the AVO. These tests contain 
instantiations of a generic unit prior to the compilation of that 
unit's body; as allowed by AI-00408 and AI-00506, the compilation 
of the generic unit bodies makes the compilation unit that contains 
the instantiations obsolete. 

BC3204C and BC3205D were graded passed by Processing Modification 
as directed by the AVO. These tests check that instantiations of 
generic units with unconstrained types as generic actual parameters 
are illegal if the generic bodies contain uses of the types that 
require a constraint. However, the generic bodies are compiled 
after the units that contain the instantiations, and this 
implementation creates a dependence of the instantiating units on 
the generic units as allowed by AI-00408 and AI-00506 such that the 
compilation of the generic bodies makes the instantiating units 
obsolete—no errors are detected. The processing of these tests 
was modified by re-compiling the obsolete units; all intended 
errors were then detected by the compiler. 


CD2A83A was graded passed by Test Modification as directed by the 
AVO. This test uses a length clause to specify the collection size 
for an access type whose designated type is STRING; eight 


2-4 




designated objects are allocated, with a combined length of 30 
characters. Because of this implementation's heap-management 
strategy and alignment requirements, the collection size at line 22 
had to be increased to 812. 

CE2103A, CE2103B, and CE3107A were graded inapplicable by 
Evaluation Modification as directed by the AVO. The tests abort 
with an unhandled exception when USE ERROR is raised on the attempt 
to create an external file. This Fs acceptable behavior because 
this implementation does not support external files (cf. AI-00332). 


2-5 






CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is 
described adequately by the information given in the initial pages 
of this report. 

For technical information about this Ada implementation, contact: 

Forrest Holemon 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 

Telefax: 602-275-7502 

For sales information about this Ada implementation, contact: 

Mike Halpin 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 

Telefax: 602-275-7502 

Testing of this Ada implementation was conducted at the customer's 
site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro92]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were 
withdrawn because of test errors (item b; see section 2.1), those 
that require a floating-point precision that exceeds the 
implementation's maximum precision (item e; see section 2.2), and 
those that depend on the support of a file system—if none is 
supported (item d). All tests passed, except those that are listed 
in sections 2.1 and 2-2 (counted in items b and f, below). 


3-1 




a) Total Number of Applicable Tests 3542 

b) Total Number of Withdrawn Tests 104 

c) Processed Inapplicable Tests 524 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 0 


f) Total Number of Inapplicable Tests 524 (c+d+e) 

g) Total Number of Tests for ACVC 1.11 4170 (a+b+f' 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 
1.3) was taken on-site by the validation team for processing. The 
contents of the magnetic tape were loaded directly onto the host 
computer. 

After the test files were loaded onto the host computer, the full 
set of tests was processed by the Ada implementation. The DDC-I 
Ada downloader runs on the Sun SPARCstation IPX and is used for 
downloading the executable images to the target Lynwood j435TU 
(68030) (Bare Machine) and to capture the results. The DDC-I Debug 
Monitor runs on the target Lynwood j435TU (68030) (Bare Machine) 
and provides communication interface between the host debugger and 
the executing target Lynwood j435TU (68030) (Bare Machine). The 
two processes communicate via ethemet to download and via RS-232 
to upload. 

The tests were compiled and linked on the host computer system, as 
appropriate. The executable images were transferred to the target 
computer system by the communications link described above, and 
run. The results were captured on the host computer system. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B for 
a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this test 
were: 


-nowarning -list 


The linker options invoked explicitly for validation testing during 
this test were: 


al -cpu 
-fpu 

-ram_base 

-ram 


68030 

68882 

0X1100000 

0X1000000, 0x3fffff 


3-2 






-main 

-tcb 

-ucc 


stack_size~OxlOOOOO 

30 

adalynwood.sib 


Tsst output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. The listings 
examined on-site by the validation team were also archived. 






APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing 
the ACVC. The meaning and purpose of these parameters are 
explained in [UG89]. The parameter values are presented in two 
tables. The first table lists the values that are defined in terms 
of the maximum input-line length, which is the value for 
$MAX_IN LEN—also listed here. These values are expressed here as 
Ada string aggregates, where "V" represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 126 — Value of V 

$BIG_ID1 (1..V-1 'A', V «> '1') 

$BIG_ID2 (1..V-1 -> 'A', V «> '2') 

$BIG_ID3 (1..V/2 -> 'A') & *3' & (1..V-1-V/2 •> 'A') 

$BIG_ID4 (1..V/2 -> *A') & '4* & (1..V-1-V/2 *> 'A') 

$BIG_INT_LIT (1..V-3 => *0') & "298" 

$BIG_REAL_LIT (1..V-5 => *0') & "690.0" 

$BIG_STRING1 & (1..V/2 «> *A') & 

$BIG_STRING2 & (1..V-l-V/2 «> 'A') & '1' & 

$BLANKS (1..V-20 *> ' •) 

$MAX_LEN_INT_BASED_LITERAL 

"2:" & (1..V-5 => *0') & "11:" 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 => »0') & "F.E:" 

$MAX_STRING_LITERAL •""• & (1..V-2 => 'A') & ■«•• 


A-l 





The following table contains the values for the remaining 
macro parameters. 

Macro Parameter Macro Value 

ACC SIZE 

32 

ALIGNMENT 

4 

COUNT LAST 

2 147 483 647 

DEFAULT MEM SIZE 

2#1#E32 

DEFAULT STOR UNIT 

8 

DEFAULT SYS NAME 

DACS 680x0 

DELTA DOC 

2#1.0#E-31 

ENTRY ADDRESS 

FCNDECL.ENTRY.ADDRESS 

ENTRY ADDRESS1 

FCNDECL.ENTRY.ADDRESS1 

ENTRY ADDRESS2 

FCNDECL.ENTRY.ADDRESS2 

FIELD LAST 

35 

FILE TERMINATOR 

1 1 

FIXED NAME 

NO SUCH TYPE 

FLOAT NAME 

NO SUCH TYPE 

FORM STRING 

MH 

FORM STRING2 


CONNO*] 

P RESTRICT FILE CAPACITY" 

GREATER THAN DURATION 

100000.0 

GREATER THAN DURATION BASE LAST 

200000.0 

GREATER THAN FLOAT BASE LAST 

16#1.0#E+32 

GREATER THAN FLOAT SAFE LARGE 

16#5.FFFF F0#E+31 

GREATER THAN SHORT FLOAT SAFE LARGE 

16#5.FFFF F0#E+31 

HIGH PRIORITY 

24 

ILLEGAL EXTERNAL FILE NAME1 

/NODIRECTORY1/FILENAME1 

ILLEGAL EXTERNAL FILE NAME2 

/NODIRECTORY1/FILENAME2 

INAPPROPRIATE LINE LENGTH 

-1 

INAPPROPRIATE PAGE LENGTH 

-1 

INCLUDE PRAGMA1 


PRAGMA INCLUDE ("A28006D1.ADA") 

INCLUDE PRAGMA2 


PRAGMA INCLUDE ("B28006E1.ADA") 

INTEGER FIRST 

-2147483648 

INTEGER LAST 

2147483647 

INTEGER LAST PLUS 1 

2147483648 

INTERFACE LANGUAGE 

AS 

LESS THAN DURATION 

-75000.0 

LESS THAN DURATION BASE FIRST 

-131073.0 

LINE TERMINATOR 

1 1 

LOW PRIORITY 

1 

MACHINE CODE STATEMENT 


AA INSTR'(AA EXIT SUBPRGRM,0,0,0,AA INSTR INTG•FIRST,0); 

MACHINE CODE TYPE 

AA INSTR 

MANTISSA DOC : 31 

MAX_DIGITS : 15 

A-2 











MAXINT 

MAX_INT_PLUS_1 

MININT 

NAME 

NAMELIST 

RAME_SPBCIFICATI0N1 

NAME_SPECIFICATI0N2 

NAME_SPECIFICATI0N3 

NEG_BASED_INT 

NEWMEMSIZE 

NEWSTORUNIT 

NEWSYSNAME 

PAGE_TERM1NATOR 

RECORD_D£FINITION 

RECORD - 


: 2147483647 
: 2147483648 
: -2147483648 
: NO_SU CH_T Y PE_AVAI LABLE 

: DACS_680x0 
• 

/hone/ sun2/ ada/6803 0/test/wrk/X212 0 A 

/home/sun2/ada/68030/test/vrk/X2120B 

/hone/sun2/ada/68030/test/wrk/X3119A 
: 16#F000000E* 

: 2097152 
: 8 

: DACS_680x0 

• I t 

INSTR NO: INTEGER ;ARGO: INTEGER;ARG1: INTEGER; 


ARG2JINTEGER?ARG3:INTEGER?END - RECORD; 


RECORDNAME 
TASK_SIZE 
TASKSTORAGESIZE 
TICK 

VARIABLEADDRESS 
VARIABLEADDRESS1 
VARIABLEADDRESS 2 
YOUR PRAGMA 


AAINSTR 

96 

1024 

2#1.0#E-14 

FCNDECL.VARIABLEADDRESS 
FCNDECL.VARIABLEADDRESS1 
FCNDECL.VARIABLEADDRESS2 
NOFLOAT 


A-3 











APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 


B-l 





5 THE ADA COMPILER 


The Ada Compiler compiles all program units within the specified source file and inserts the 
generated objects into the current sublibrary. Compiler options are provided to allow the user 
control of optimization, run-time checks, and compiler input and output files such as list files, 
configuration files, the program library used, etc. 

The input to the compiler consists of the source file, the configuration file (which controls the 
format of die list file), and die compiler options. Section S.l provides a list of all compiler 
options, and Section 5.2 describes the source and configuration files. 

Output consists of an object placed in the program library, diagnostic messages, and optional 
listings. The configuration file and the compiler options specify the format and contents of the 
list information. Output is described in section 5.3. If any diagnostic messages are produced 
during the compilation, they are output to the diagnostic file and on the current output file. The 
diagnostic file and the diagnostic messages are described in Section 5.3.2. 

The compiler uses a program library during the compilation. The compilation unit may refer to 
units from die prog ram library, and an internal representation of the compilation unit will be 
inHittVrf in die program library as a result of a successful compilation. The program library is 
described in Chapter 3. Section 5.4 briefly describes how the Ada compiler uses the library. 


5.1 The Invocation Command 

Invoke the Ada compiler with the following command to the SunOS shell: 

$ ada {<option>} <source-or-unit> 
where the options and parameters are: 




DACS 680x0 Bare Ada Cross Compiler System - User's Guide 
The Ada Compiler 


OPTION DESCRIPTION 


REFERENCE 


•(uo]auto-inHne 

Automatic inline expansion of local subprograms. 

5.1.1 

•body 

Compile body unit from source saved in library. 

5.1.2 

nhunt 

"CMC* 

Specifies nm-time constraint checks. 

5.1.3 

•configuration—file 

Specifies the configuration file used by the compiler 

5.1.4 

•[nojdebttg 

Generate debug information. 

5.1.5 

-(nolfpu 

Generate code for die floating point co-processors 

5.1.6 

•Mu-ary 

Specifies program library used. 

5.1.7 

•[noJUst 

Writes a source listing on the list file. 

5.1.8 

•mode 

Protection mode. 

5.1.9 

-optimise 

Specifies compiler optimization. 

5.1.10 

-[nojsave-source 

Inserts source text in program library. 

5.1.11 

-specification 

Compile specification unit from source saved in library. 

5.1.12 

•[no]verbose 

Displays compiler progress. 

5.1.13 

•[no]warnings 

Display wanting from the compiler 

5.1.14 

-[nojxref 

Creates a cross reference listing. 

5.1.15 

<source-or-unit> 

The name of the source file or unit to be compiled. 

5.1.16 


Examples: 

$ ada -list tnatprog 

This example compiles the source file testprogjula and generates a list file with the name 
testprogJis. 

$ ada -library say -library tast 

This example compiles die source file testa da into the library myJibrary. 

Default values exist for most options as indicated in the following sections. Options and option 
keywords may be abbreviated (characters omitted from the right) as long as no ambiguity arises. 
Casing is significant for options, but not for option keywords. When conflicting options are given 
on die command line, (e.g. -list and -nolist) the last one is used. 


5.L1 -[nojauto-inline 

•auto-inline LOCAL | GLOBAL 
•noauto -Inline (default) 

This option specifies whether subprograms should be inline expanded. The inline expansion oily 
occurs if the su b pro gram has less than 4 object declarations and less than 6 statements, and if the 
subprogram fulfills the requirements defined for pragma INLINE (see Section B2.3). LOCAL 
specifies that only inline expansion of locally defined subprograms should be done, while 
GLOBAL will cause inline expansion of all subprograms, including subprograms from other 
units. 


36 







DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
The Ada Compiler 

A warning is issued when inline expansion is not achieved. 


5.1.2 -body 
-body 

When using the option -body the Ada compiler will recompile the body of the unit specified as 
panmeter to the Ada compiler (see section 5.1.16) into die current sublibniy. The source code 
saved in the program library at the previous compilation of the body is used as the source code 
to be compiled. If no source code is present or the body for die unit does not exist in the library, 
an error message is issued. This option is primarily for use by the Ada Recompiler (see chapter 
7). 


5.1 J -check 


-check ( <keyword> = ON I OFF { ,<keyword> = ON | OFF } ] 

-check ALL=ON (default) 

•check specifies which run-time checks should be performed. Setting a run-time check to ON 
enables die check, while setting it to OFF disables the check. All run-time checks are enabled by 
default. The following explicit checks will be disabled/enabled by using the name as <keyword>: 


ACCESS 

ALL 

DISCRIMINANT 

ELABORATION 

INDEX 

LENGTH 

OVERFLOW 

RANGE 

STORAGE 


Check for access values being non NULL. 
All checks. 

Checks for discriminated fields. 

Checks for subprograms being elaborated. 
Index check. 

Array length check. 

Explicit overflow checks. 

Checks for values being in range. 

Checks for sufficient storage available. 


5.1.4 -configuration-file 

-configuration-file <flle-speo 
-configuration-file con fig (default) 

This option specifies die configuration file to be used by the compiler in the current compilation. 
The configuration file allows die user to format compiler linings, set error limits, etc. If the 
option is omitted die configuration file config located in die same directory as the Ada compiler 
is used by default Section 5.2.2 contains a description of die configuration file. 


37 



DACS 680x0 Bare Ada Cross Compiler System - User's Guide 
The Ada Compiler 


5.1i -(noldebug 


•debug 

-nodebug (default) 

Generate debug information for the compilation and stem the information in the program library. 
This is necessary if the unit is to be debugged with the DDC-I Ada Symbolic Cross Debugger. 
Note that the program must also be linked with the -debug option, if the program is to be 
debugged with die DDC-I Ada Symbolic Cross Debugger. See Section 6.2.4. 


5.L6 -[no]fpu 

-(km (default) 

•[notfpu 

If the -fpu option is specified die compiler will assume that a floating point co-processor is present 
and generate code accordingly. If die -nofpu option is specified the compiler will assume that a 
floating point co-processor is not present, and will not generate instructions for Jie co-processors. 
Floating point operations are instead implemented by calls to run time library. 


S.I.7 -library 


-library <file-spec> 

-library $ADA_LIBRARY (default) 

This option specifies the current sublibrary that will be used in the compilation and will receive 
the object when the compilation is complete. By specifying a current sublibrary, the current 
progr a m library (current sublibrary and ancestors up to root) is also implicitly specified. 

If this option is omitted, the sublibrary designated by the environmental variable ADA-LIBRARY 
is used as the current sublibrary (see Chapter 3). Section S.4 describes how the Ada compiler uses 
the library. 


5.1.8 -[no]list 


-Hat 

-nolist (default) 

-Hat specifies that a source listing will be produced. The source listing is written to the list file, 
which has die name of the source file with the extension Jis. Section 5.3.1.1 contains a description 
of the source listing. 

If -nollst is active, no source listing is produced, regardless of LIST pragmas in the program or 
diagnostic messages produced. 


38 


DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
The Ada Compiler 


5.1.9 •mode 

•mode ALL | BASIC | SECURE 
•mode ALL (default) 

The compiler generates code to execute in a non-protected BASIC mode, or in a protected 
SECURE mode according to the -mode option. Code can be generated to run in all protection 
modes by specifying ALL, this way protection mode can be decided at link time. The fastest and 
most compact code is generated by selecting the protection mode in which the program shall 
execute. Please refer to chapter 10 for details on protection modes. Mode SECURE is only usable 
if the program will be linked for a Motorola 68030 or 68040 processor. 


5.1.19 -optimize 

-optimize [ <keyword> = ON | OFT { ,<keyword> = ON | OFT } ) 
-optimize ALL=OFT 


This option specifies which optimizations will be performed during code generation. The possible 
keywords are: 


ALL 

CHECK 

CSE 

FCT2PROC 

REORDERING 

STACK-HEIGHT 

BLOCK 


All possible optimizations are invoked. 

Eliminates superfluous checks. 

Performs common subexpression elimination including common address 
expressions. 

Change function calls returning objects of constrained array types or 
objects of record types to procedure calls. 

Transforms named aggregates to positional aggregates and named 
parameter associations to positional associations. 

Performs stack height reductions (also called Aho Ullman reordering). 
Optimize Mock and o*)l frames. 


Setting an optimization to ON enables the optimization, while setting an optimization to OFT 
disables the optimization. All optimizations are disabled by default In addition to the optional 
optimizations, the compiler always performs the following optimizations: constant folding, dead 
code elimination, rod selection of optimal jumps. 


5.1.11 -[nojsavc-aource 

-save-source (default) 

-nosave-source 

When -save-source is specified, a copy of the compiled source code is placed in the program 
library. If -nosave-source is used, source code will not be retained in the program library. 

Using -nosave-source, while helping to keep library sizes smaller, does affect the operation of 
the recompiler, see Chapter 7 for more details. Also, it will not be possible to do symbolic 
debugging at foe Ada source code level with the DACS-680x0 Symbolic Ada Debugger, if the 
source code is not saved in foe library. 


39 





DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
The Ada Compiler 


5.1.12 -specification 
-specifica t i o n 

When using the option -specification the Ada compiler will recompile the specification of the unit 
specified as parameter to the Ada compiler (see section 5.1.16) into the current sublibrary. The 
source code saved in die program library at the previous compilation of die specification is used 
as die source code to be compiled. If no source code is present or die specification for the unit 
does not exist in the library, an error message is issued. This option is primarily for use by the 
Ada Recompiler (see chapter 7). 


5.1.13 -[nolverbose 
•verbose 

-no verbose (default) 

When -verbose is specified, die compiler will output information about which pass the compiler 
is currently running, otherwise no information will be output. 


5.1.14 -[no]wamings 

-warnings (default) 

-nowarnings 

All warnings from the Ada Compiler are displayed when option -warnings is specified. All 
compiler warnings are suppressed when -nowarnings is specified. See Section 5.3.2 for a 
description of how and when warnings are reported from the Ada Compiler. 


5.1.15 -[nolxref 


-xref 

-noxref (default) 

A cross-reference listing can be requested by the user by means of the option -xref. If the -xref 
option is given and no severe or fatal errors are found during the compilation, the cross-reference 
liking is written to die list file. The cross-reference listing is described in Section 5.3.I.3. 


5.1.16 The Source or Unit Parameter 
<source-or-unit> 

This parameter specifies either the text file containing the Ada source text to be compiled or, 
when option -body or -specification is used, the name of the unit to be compiled. When 
interpreted as a file name, the file type ".ada" is assumed by default, if the file type is omitted 
in the source file specification. 


40 





DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
The Ada Compiler 


SJ Compiler Input 

Input to die compiler consists of the command line options, a source text file and, optionally, a 
configuration file. 


5.2.1 Source Text 

The user submits one file containing a source text in each compilation. 

The format of the source text must be in ISO-FORMAT ASCII. This format requires that die 
source text is a sequence of ISO characters (ISO Standard 646), where each line is terminated by 
either one of die following termination sequences (CR means carriage return, VT means vertical 
tabulation, LF means line feed, and FF means form feed): 

• A sequence of one or more CRs, where the sequence is neither immediately preceded nor 
immediately followed by any of the characters VT, LF, or FF. 

• Any of die characters VT, LF, or FI immediately preceded and followed by a sequence 
of zero or more CRs. 

In general, ISO control characters are not permitted in die source text with die following 
exceptions: 

• The horizontal tabulation (HT) character may be used as a separator between lexical units. 

• LF, VT, FF, and CR may be used to terminate lines, as described above. 

The maximum number of characters in an input litre is determined by the contents of the 
configuration file (see Section 5.2.2). The control characters CR, VT, LF, and FF are not 
considered a part of die line. Lines containing more than the maximum number of characters are 
truncated and an error message is issued. 


5JL2 Configuration File 

Certain processing characteristics of the compiler, such as format of input and output and error 
limit, may be modified by the user. These characteristics are passed to die compiler by means 
of a configuration file, which is a standard SunOS text file. The contents of the configuration 
file must be an Ada positional aggregate, written on one line, of the type 
CONFIGURATION-RECORD, which is described below. 

The configuration file (config) is not accepted by die compiler in the following cases: 

• The syntax does not conform with die syntax for positional Ada aggregates. 

• A value is outside the ranges specified. 

• A value is not specified as a literal. 

• LINES-PER -PAGE is not greater than TOP-MARGIN + BOTTOM-MARGIN. 







DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
The Ada Compiler 


• The aggregate occupies more than one line. 

If the compiler is unable to accept the configuration file, an error message is written on current 
output and die compilation is terminated. 

Below is a description of the record whose values must appear in aggregate form within the 
configuration file. The record declaration makes ure of some other types (given below) for the 
sake of clarity. 


type CONFIGURATION-RECORD is 
record 

IN-FORMAT : INFORMATTING; 

OUT-FORMAT ; OUTFORMATTING; 

ERROR-LIMIT : INTEGER RANGE 1..32-767; 
end record; 

type INPUT-FORMATS is (ASCII); 

type INFORMATTING is 
record 

INPUT-FORMAT ; INPUT-FORMATS; 

INPUT-LINELENGTH : INTEGER range 72..250; 
end record; 

type OUTFORMATTING is 
record 

LINES-PER-PAGE ; INTEGER range 30..100; 
TOP-MARGIN ; INTEGER range 4.. 90; 

BOTTOM-MARGIN : INTEGER range 0.. 90; 

OUT-LINELENGTH ; INTEGER range 80..132; 
SUPPRESS-ERRORNO : BOOLEAN; 
end record; 


The outformatting parameters have die following meaning: 

1) LINES_PER_PAGE: specifies the maximum number of lines written on each page 
(including top and bottom margin). 

2) TOP-MARGIN: specifies the number of lines on top of each page used for a standard 
heading and blank lines. The heading is placed in die middle lines of the top margin. 

3) BOTTOM-MARGIN: specifies the minimum number of lines left blank in the bottom of 
die page. The number of lines available for the listing of the program is LINES 
PER-PAGE - TOP-MARGIN - BOTTOM-MARGIN. 

4) OUT-LINELENGTH: specifies the maximum lumber of characters written on each line. 
Lines longer than OUT-LINELENGTH are separated into two lines. 

5) SUPPRESS-ERRORNO: specifies the format of error messages (see Section 5 . 322 ). 


42 









DACS 680x0 Bate Ada Cross Compiler System - User’s Guide 
The Ada Compiler 


The name of a user-supplied configuration file can be passed to the compiler through the 
-configuration_fik option. DDC-I supplies a default configuration file (config) with the following 

((ASCII, 126), (48,5,3,1OOFALSE), 200) 



Figure 5.1: Page Layout 


SJ Compiler Output 

The compiler may produce output to the list file, the diagnostic file, and the current output file. 
It also updates die program library if the compilation is successful The present section describes 
the text output in the three files mentioned above. The updating of the program library is described 
in Section 5.4. 

The compiler may produce die following text output: 

1) A listing of the source text with embedded diagnostic messages is written to the list file, 
if the option -fist is active. 

2) A compilation summary is written to the list file, if -list is active. 


43 







DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
The Ada Compiler 


3) A cross-reference listing is written to the list file, if -xref is active and no severe or fetal 
errors have been detected during the compilation. 

4) If there are any diagnostic messages, a diagnostic file containing die diagnostic messages 
is written. 

5) Diagnostic messages other than warnings are written on the current output file. 


5J.1 The List FUe 

If the user requests any listings by specifying the options -list or -xref, a new list file is created. 
The name of tire list file is identical to the name of the source file except that it has the file type 
"Jis". The file is locmed in the current directory. If any such file exists prior to the compilation, 
the file is deleted. 

The list file may include one or more of the following parts: a source listing, a cross-reference 
listing, and a compilation summary. 

The parts of the list file are separated by page ejects. The contents of each part are described in 
the following sections. 

The format of the output to the list file is controlled by the configuration file (see Section 5.2.2) 
and may therefore be controlled by die user. 


5 J.1.1 Source Listing 

A source listing is an unmodified copy of the source text The listing is divided into pages and 
each line is supplied with a line number. 

The number of lines output in the source listing is governed by die occurrence of LIST pragmas 
and the number of objectionable lines. 

• Parts of the listing can be suppressed by the use of LIST pragmas. 

• A line containing a construct that caused a diagnostic message to be produced is printed 
even if it occurs at a point where listing has been suppressed by a LIST pragma. 


5JJJ Compilation Summary 

At die end of a compilation, die compiler produces a summary that is output on die list file if the 
option -Hst is active. 


The summary contains information about: 

1) The type and name of the compilation unit, and whether it has been compiled successfully 
or not 


44 




DACS 680x0 Bare Ada Cross Compiler System - User's Guide 
The Ada Compiler 


2) The number of diagnostic messages produced for each class of severity (see Section 5.3.2.1). 

3) Which options were active. 

4) The full name of the source file. 

5) The ftiU name of the current sublibnry. 

6) The number of source text lines. 

7) The size of the code produced (specified in bytes). 

8) Elapsed real time and elapsed CPU time. 

9) A "Compilation terminated" message if the compilation unit was the last in the compilation 
or "Compilation of next unit initiated" otherwise. 


SJJJ Cross-Reference Listing 

A cross-reference listing is an alphabetically sorted list of identifiers, operators and character 
literals of a compilation unit The list has an entry for each entity declared and/or used in the 
unit, with a few exceptions stated below. Overloading is evidenced by the occurrence of multiple 
entries for the same identifier. 

For instantiations of generic units, the visible declarations of the generic unit are included in the 
cross-reference listing immediately after the instantiation. The visible declarations are the 
subprogram parameters fix a generic subprogram and the declarations of die visible part of the 
package declaration for a generic package. 

For type declarations, all implicitly declared operations are included in the cross-reference listing. 

Cross-reference information will be produced for every constituent character literal for string 
literals. 

The following are not included in the cross reference listing: 

• Pragma identifiers and pragma argument identifiers. 

• Numeric literals. 

• Record compone nt identifiers and discriminant identifiers. For a selected name whose 
selector denotes a record co m ponent or a discriminant, only the prefix generates 
cross-reference information. 

• A parent unit name (following the keyword SEPARATE). 


45 




DACS 680x0 Bare Ada Cross Compiler System • User's Guide 
The Ada Compiler 


Each entry in the cross-reference listing contains: 

• The identifier with at most IS characters. If the identifier exceeds IS characters, a bar (T) 
is written in the 16th position tend the rest of the characters are not primed. 

• The place of the definition, i.e. a line number if die entity is declared in the current 
compilation unit, otherwise the name of the compilation unit in which the entity is declared 
and the line number of the declaration. 

• The line numbers at which the entity is used. An asterisk (”*") after a line number indicates 
an assignment to a variable, initialization of a constant, assignments to functions, or 
user-defined operators by means of RETURN statements. 


512 The Diagnostic File 

The name of die diagnostic file is identical to the name of die source file except that it has die 
file type ".err". It is located in the current directory. If any such file exists prior to the 
compilation the newest version of the file is deleted. If any diagnostic messages are produced 
during the compilation a new diagnostic file is created. 

The diagnostic file is a text file containing a list of diagnostic messages, each preceded by a line 
showing the number of the line in the source text causing the message, and followed by a blank 
line. There is no separation into pages and no headings. The file may be used by an interactive 
editor to show die diagnostic messages together with the erroneous source text 


512.1 Diagnostic Messages 

The Ada compiler issues diagnostic messages to the diagnostic file. Diagnostics other than 
warnings also appear on standard output If a source text listing is required, the diagnostics are 
also found embedded in die list file (see Section 5.3.1). 

In a source listing, a diagnostic message is placed immediately after the source line causing the 
message. Messages not related to any particular line are placed at the top of the listing. The lines 
are ordered by increasing source line numbers. Line number 0 is assigned to messages not related 
to any particular line. On standard output the messages appear in the order in which they are 
generated by die compiler. 

The diagnostic messages are classified according to their severity and the compiler action taken: 


Wanting: Reports a questionable construct or an error that does not influence the meaning of the 
program. Warnings do not Under the generation of object code. 

Example: A wanting will be issued for constructs for which the compiler detects that 
they will raise CONSTRAINT .ERROR at run time. 


Error Reports an illegal construct in the source program. Compilation continues, but no object 
code will be generated. 


46 





DACS 680x0 But Ada Ones Compiler System - User’s Guide 
The Ada Compiler 


Examples: mom syntax errors; most stalk semantic errors. 


Severe Reports an error which causes the compilation to be terminated immediately. No object 
error code is generated. 

Example: A severe error message will be issued if a library unit mentioned by a WITH 
clause is not present in the current program library. 


Fatal Reports an error in the compiler system itself. Compilation is terminated immediately 

error and no object code is produced. The user may be able to circumvent a fatal error by 

correcting the program or by replacing program constructs with alternatives. Please 
inform DDC-I about die occurrence of fatal errors. 

The detection of more errors than allowed by the number specified by the 
ERROR-LIMIT parameter rtf die configuration file (see section 5.2.2) is also considered a severe 
error. 


L3I2 Format and Content of Diagnostic Messages 

For certain syntactically incorrect constructs die diagnostic message consists of a pointer line and 
a text line. In other cases a diagnostic message consists of a text line only. 

The pointer line contains a pointer (a carat symbol A ) to the offending symbol or to an illegal 
character. 

The text line contains the following information: 

• The diagnostic message identification "***". 

• The message code XY-Z where 
X is the message number 

Y is the severity code, a letter showing the severity of the error. 

W: warning 
E: error 
S: severe error 
F: fatal error 

Z is an integer which together with the message number X uniquely identifies die compiler 
location thru generated the diagnostic message; Z is of importance mainly to the 
compiler maintenance team - it does not contain information of interest to the compiler 
user. 

The message code (with the exception of the severity code) will be suppressed if the 
parameter SUPPRESS_ERROR_NO in the configuration file has the value TRUE (see 
section 5.2.2). 


47 






DACS 680x0 But Ada Cross Compiler System - User’s Guide 
The Ada Compiler 


• The message text; the text may include one context dependent field that contains the name 
of the offending symbol; if the name of the offending symbol is longer than 16 characters 
only the first 16 characters are shown. 


Examples of diagnostic messages: 


*** 18N-3: 

320E-2: 
*** 535E-0: 
*** 1508S-0: 


Warning: Exception CONSTRAINT-ERROR will be raised here 
Naaw OBJ does not denote a type 
Expression in return statement missing 

Specification for this package body not present in the library 


SJJ Retail Status 

The Ada Compiler’s return value will have one of the following values: 

0: The compilation was successful, warnings may have been generated. 

1,2: Fatal internal error in die run-time system. Please contact DDC-I engineers. 

3,4: Errors hi command fine options, compiler generates an error message indicating the 
error. 

5: Fatal internal error in die compiler. Compiler generates an error message indicating the 

error. Please contact DDC-I engineers. 

6: Severe error during compilation, e.g. a unit mentioned by a WITH clause is not present 

in the library. Compiler generates an error message indicating the error. 

7: Error during compilation, e.fc most syntax errors. Compiler generates an error message 

indicating the error. 


5.4 The Prorpam Library 

This section briefly describes how die Ada compiler changes the program library. For a more 
general description of die program library the user is referred to Chapter 4. 

The compiler is allowed to read from all sublibraries constituting the current program library, but 
only die current sublibruy may be changed. 


5.41 Correct Compilations 

In die following examples it is assumed that die compilation units are correctly compiled, i.e. that 
no errors are detected by the compiler. 


48 







DACS 680x0 Bare Ada Cron Compiler System - User’s Guide 
Hie Ada Compiler 


Com p i lat ion of a lfl>rary unit uhkh is a declaration 

If a declaration unit of the same name exists in the current sublibrary, it is deleted together with 
its body unit and possible subunits. A new declaration unit is inserted in the sublibrary, together 
with an empty body unit 


Compilation of a library unit which is a subprogram body 

A subprogram body in a compilation unit is treated as a secondary unit if die current sublibnry 
contains a su b progra m declaration or a generic su b progra m declaration of die same name and this 
declaration unit is not invalid. In all other ernes it will be treated as a library unit, i.e.: 

• When dine is no library unit of that name. 

• When there is an invalid declaration unit of that name. 

• When there is a package declaration, generic package declaration, an instantiated package, 
or subprogram of that name. 


Compilation of a library unit which is an instantiation 

A possible existing declaration unit of that name in the current sublibrary is deleted together with 
its body unit and possible subunits. A new declaration unit is inserted. 

Compilation of a secondary unit which is a library unit body 

The existing body is deleted from the sublibrary together with its possible subunits. The new 
body unit is inserted. 


Compilation of a secondary unit which is a subunit 

If die subunit exists in the sublibrary it is deleted together with its possible subunits. The new 
subunit is insetted. 


5.42 Incorrect Compilations 

If die compiler detects an error in a compilation unit, the program library will remain unchanged. 

Note that if a file consists of several compilation units and an error is detected in any of these 
compilation units, die program library will not be updated for any of die compilation units. 


Si I n sta ntiatio n of Generic Units 

This section describes the order of compilation for generic units and describes situations in which 
an error will be generated during the instantiation of a generic unit 


49 



DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
The Ada Compiler 


SiJ Order of Compilation 

When instantiating a generic unit, it is required that the entire unit, including body and posable 
subunits, be compiled before the first in&antiation. This is in accordance with the [DoD-83] 
Chapter 10.3 (1). 


Sii Generic Formal Private Types 

This section describes the treatment of a generic unit with a generic formal private type, where 
there is some construct in the generic unit that requires that the corresponding actual type must 
be constr ain ed if it is an array type or a type with discriminants, and there exists instantiations 
with such an unconst rain ed type (see [DoD-83] Section 12.3.2(4)). This is considered an illegal 
combination, hi some cases the error is detected when the instantiation is compiled, in other cases 
when a constraint-requiring construct of the generic unit is compiled: 

1) If the instantiation appears in a later compitaion unit than the first constraint-requiring construct 
of die generic unit, die error is associated with die instantiation which is rejected by die 
compiler. 

2) If the instantiation appears in the same compilation unit as the first constraint-requiring 
construction of die generic unit there are two possibilities: 

a) If there is a constraint-requiring construction of the generic unit after the instantiation, an 
error message appears with the instantiation. 

b) If the instantiation appears after all constraint-requiring constructs of the generic unit in that 
compilation unit, an error message appears with the constraint-requiring construct but it will 
refer to die illegal instantiation. 

3) The instantiation appears in an earlier compilation unit than the fust constraint-requiring 
construction of the generic unit, which in that case will appear in the generic body or a 
subunit If die instantiation has been accepted, die instantiation will correspond to die generic 
declaration only, and not include the body. Nevertheless, if the generic unit and die instantiation 
are located in die same sublibrary, then the compiler will consider it an error. An error message 
will be issued with the constraint-requiring construct and will refer to the illegal instantiation. 
The unit containing die instantiation is not changed, however, and will not be marked as 
invalid. 


S.6 Uninitialized Variables 

Use of uninitialized variables is not flagged by the compiler. The effect of a program that refers 
to die value of an uninitialized variable is undefined. A cross-reference listing may help to find 
uninitialized variables. 


50 



DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
The Ada Compiler 


5.7 Program Structure and Compilation lames 

Hie following limitations apply to the DACS-680x0 system: 

• Each source file can contain, at most, 32-767 lines of code. 

• The name of compilation units and identifiers may not exceed the number of characters given 
in the INPUT JJNELENGTH parameter of the configuration file. 

• An integer literal may not exceed the range of INTEGER, a real literal may not exceed die 
range of LONG-FLOAT. 

• The number of formal parameters permitted in a procedure is limited to 64 per parameter 
specification. There is no limit on die number of procedure specifications. For example the 
declaration: 

procedure OVER-LIMIT (INTEGER01, 

INTEGER02, 

* • • • § 

INTEGER66: in INTEGER); 

exceeds the limit, but the procedure can be accomplished with the following: 

procedure UNDER-LIMIT(INTEGER01 : in INTEGER; 

INTEGER02 : in INTEGER; 

• • • 

INTEGER66 : in INTEGER); 

The above limitations are diagnosed by die compiler, in practice these limitations are seldom 
restrictive and may easily be circumvented by using subunits, separate compilation, or creating new 
sublibraries. 


51 






52 




LINKER OPTIONS 


The linker options of this Ada implementation., as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation and 
not to this report. 


B-2 







6 THE ADA LINKER 


The DACS-680x0 linker must be executed to create a program executable in the target 
environment. Linking is a two stage process that includes an Ada link using die information in 
die Ada program library, and a target link to integrate the application code, run-dme code, and 
any additional configuration code developed by the user. The linker performs these two stages with 
a single command, providing options for controlling both the Ada and target link processes. This 
chapter describes the link process, the options to die DACS-680x0 linker, and the configuration 
of the linker. 


6.1 The Link Process 

The linking process can be viewed as two consecutive phases that are automatically carried out 
when issuing the link command al. 

The link process is carried out in die following steps: 

• Determination of Ada compilation units to include in the target program. 

• Checking the validity of the included units according to the Ada rules. 

• Determination of an elaboration order for the target program. 

• Group units and tasks into classes (for security critical applications, see chapter 10). 

• Generation of an object module to invoke the elaboration of the included Ada compilation 
units. This module is called the elaboration module. 

• Determination of attributes of the program being linked (see section 6.7). 

• Generation of an initialization module. 

• Generation of option ftle(s) to the target linker. 

• Invocation of the target linker. 

The tasks of the first three steps are described in chapter 10 of the [DoD-83], die last five steps 
are described in detail in the following sections. 

6J2 The Invocation Command 

Enter the following command to the SunOS shell to invoke die linker 
$ al {<option>} <unitname> 
where the options and parameters are: 


53 






DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


OPTION 

DESCRIPTION REFERENCE 

•[nolboot 

Generate boot module. 

6.2.1 

-[no]class_ffle 

Class file name. 

6.2.2 

•qw 

Select Target board CPU. 

6.2.3 

-[uojdebug 

Generate debug information. 

6.2.4 

•defaults 

Save options as new linker defaults. 

6.2.5 

•[nofeutry 

Alternative program start label. 

6.2.6 

-(aojexceptkxts 

-[no]executable 

Control of exception management 

Name of executable file. 

6.2.7 

6.2.8 

-[nojfpu 

Control of which floating point processor is used. 

6.2.9 

•[nolmp 

Control of memory management 

6.2.10 

-fno]init-flle 

Initialization file name. 

6.2.11 

-Interrupt-stack 

Interrupt stack description 

6.2.12 

-[nojitcb 

Number of Interrupt Task Control Blocks allocated. 

6.2.13 

-[nojkeep 

Do not delete temporary files. 

6.2.14 

-library 

The library used in the link. 

6.2.15 

-(noHog-ffle 

Log file name. 

6.2.16 

-(no]logical-ineinory 

Logical memory specification. 

6.2.17 

-main-task 

Main task specification. 

6.2.18 

-[no]map 

Keep linker map file. 

6.2.19 

-mmu-details 

Setup values for MMU registers. 

6.2.20 

•mode 

Execution mode. 

6.2.21 

-[no]option-flle 

Linker option file name. 

6.2.22 

-ram 

Physical RAM memory specification 

6.2.23 

-ram-base 

Base address for RAM sections. 

6.2.24 

-ram-sections 

Description of RAM memory sections. 

6.225 

-[no]rom 

Physical ROM memory specification 

6.2.26 

•(no]rom-base 

Base address for ROM sections. 

6.227 

-[nojrom-sections 

Description of ROM memory sections. 

6.228 

•rts-stack-use 

Amount of memory used by RTS. 

6.2.29 

-[no|scod 

Supervisor code sections. 

6.2.30 

-[nolsdat 

Supervisor data sections. 

6.2.31 

-[nojstatistics 

Print statistics. 

6.2.32 

-[nojtarget-options 

Options to die target linker. 

62.33 

-task-defaults 

Default values for tasks. 

6.2.34 

-{nojtcb 

Number of Task Control Blocks allocated. 

6.2.35 

-ucc-library 

UCC library name. 

6.2.36 

•(nojucod 

User code sections. 

6.2.37 

•(nojucst 

User constant sections. 

6.2.38 

-[no]udat 

User data sections. 

6.2.39 

•[no]usr_Hbrary 

A user supplied object library. 

6.2.40 

-[nojvector 

Intemipt vector description 

6.2.41 

-(nojvertfy 

Prim information about the link. 

6.2.42 

-[nojwanilnfs 

Prim warnings. 

6.2.43 

<unit-name> 

Name of the main unit. 

6.2.44 


54 




DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


All options and option keywords may be abbreviated (characters omitted from the right) as 
long as no ambiguity arises. Casing is significant for options but not for option keywords. 

For all option values specifying a 32-bit address, 2-complement wrap-around is performed on 
negative numbers, e.g. -rom_base=-l is equivalent to -rom_base=Oxffffffff. 


6JL1 -{nolboot 


•boot 

•noboot (default) 

If -boot is specified an absolute file suited to gain control upon a reset is generated. The first two 
longwofds in the RTS-CODE section contain the start Program Counter and the interrupt stack 
address. If -noboot is specified the absolute file does not contain the reset information, -boot is 
not valid when option -debug is specified, see section 62.4. 


62,2 -[no]dass-fl!e 

•class-file <fHe_name> 

•nodass-file (default) 

Specifies the name of the file containing the class specifications. The syntax of class specifications 
is described in chapter 10, where foe concepts of classes are described as well. This option is 
only legal if option -mode is set to SECURE or SAFE. 


6.2.3 -cpu 

-cpu 68020 | 68030 | 68040 
-cpu <highest licensed> (default) 

Specifies the Motorola Central Processing Unit (CPU) on the target board. The -cpu option must 
match the actual CPU on the target board, as this option directs the Ada Linkers selection of RTS 
and supporting libraries. This option defaults to the highest CPU for which the DACS-680x0 has 
been licensed, with 68020 being the lowest and 68040 being the highest 


62A -[nojdebug 
-debug 

•nodebug (default) 

The -debug option specifies that debug information is generated. The debug information is required 
to enable symbolic debugging. If -nodebug is specified, the Ada linker will skip the generation 
of debug information, thus saving link time, and will not insert the debug information into the 
chosen sublibrary, thus saving disk space. Note that any unit which should be symbolically 
debugged with the DDC-I Ada Symbolic Cross Debugger must also be compiled with foe -debug 


55 






DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


option. See Section 5.1.5. -debug is not valid, when options -boot or -vector IN1T are specified, 
see sections 6.2.1 and 6.2.41. 


i25 -defaults 
-defaults 

Saves the current setting of all options and parameters, except the -defaults option itself, as new 
defaults for the linker. The defaults are saved in die file specified by the environmental variable 
ADA -LINK-DEFAULTS. When this option is present, no actual linking will take place. For a 
complete description of the Ada Linker defaults system, please refer to section 6.3. 


6JL6 -{no Jen try 

-entry <string> 

-noentry 

•entry " Ada JELAB$Entry" (default) 

The -entry option specifies die entry name of the program. If -entry is not specified the entry 
point is die start of die elaboration module. 


6u2,7 -[no {exceptions 

-exceptions (default) 

-noexceptions 

If -exceptions is specified the exception management routines are included in the target program. 
If -noexceptions is specified, the exception management routines are not included in die program, 
and die program will abort if the program raises any exceptions. If -noexceptions is specified 
and the target program has the exception attribute (see section 6.7) a warning is reported, and the 
exception management routines will not be included. 


6JL8 -[nojexecu table 

-executable <fUe-name> 

-noexecutable 

-executable <main_unit>jr (default) 

The -executable option specifies the file name of the absolute file created. <ffle-name> is used 
as name for die absolute file. If -noexecutable is specified the absolute file is not created. 


56 




DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


&2 3 -[nojfpu 

4pu <8881 | 68882 
-fjpu 68882 (default) 

Specifies the floating point co-processor available on the target system. If -cpu 68040 has been 
specified, -fjpu 68881 is not allowed, as the MC68040 FPU emulates the MC68882 coprocessor 
and not die MC68881 coprocessor. If -notyiu is specified and die target p ro gr a m contains any 
floating point instructions an error message is issued. See section 6.7 concerning the float attribute. 
If all compilation units required for execution are compiled with -nofjpu option no floating poim 
instructions are generated and a link with -nofpu will never fail. 


6X10 -{nofoeap 

-heap (default) 

•noheap 

If -heap is specified and the target program has die heap attribute (see section 6.7) then the 
storage management routines are included in die target program. If -noheap is specified die 
storage management routines are not included in the program. When -noheap is specified and 
the target program has die heap attribute, an error is reported and linking terminates. 


6X11 -[no]init_file 

•biit-file <fUe-name> 

-noinit-flle (default) 

The -ink-file option specifies die name of a user supplied initialization file. <file-name> is used 
as name for the initialization file. If -noinit-flle is specified, the linker generates an initialization 
file with the name <prefix>_JniLsrc. It is assumed that die initialization file is an assembler 
source file. 


6X12 -interrupt-stack 

-interrupt-stack (NOSTART | START=<address>]bSIZE=<number>] 

-interrupt-stack NOSTART,SIZE=10240 (default) 

Specifies die creation of the interrupt stack. If START=<address> is specified die interrupt stack 
pointer is initialized to <address>. If NOSTART is specified the linker allocates the interrupt 
stack in die section RTS-DATA. START=<address> is not valid when -mode is set to SECURE 
or SAFE. If SIZE=<number> is specified the <number> bytes is allocated for the interrupt stack. 


57 





DACS 680x0 Bare Ada Cross Compiler System - User's Guide 

The Ada Linker 


iI13 •[noJBcb 
•4td> <auaabcr> 


4tab 5 (default) 

The -Itcb option specifies the number of interrupt control blocks to allocate. If -Mcb <number> 
is specified then <aiuaber> of interrupt control blocks are allocated, where <number> must be 
in the rente 1..32767. If - n ol tcb is specified and the target program has the interrupt attribute (see 
section 6.7) then an error is reported and the absolute file is not created. If the target program 
does not have the interrupt attribute the -Hcb option is ignored. 


. iI14 -{nojkeep 
-keep 

•nokeep (default) 

If -keep is specified temporary linker files are not deleted, otherwise they are deleted. See also 
section iiJ about temporary linker files. 


62.15 -library 

•library <fUe-name> 

-library $ADA_UBRARY (default) 

The -library option specifies die current sublibrary, from which the linking of the main unit will 
udce place. If this option is not specified, the sublibrary specified by die environmental variable 
ADA .LIBRARY is used. 


62.16 -[noVog-flle 

•log_Jlle <flle-naine> 

•nolog-flle (default) 

Specifies that linker information shall be written to a file named <flle-iuune>. Hie log file will 
contain an verification information specified by the -verify option and all statistics specified with 
the -statistics option, plus warnings and errors messages, a listing of the class file (see section 
622), an expanded list of the class file specifications, a detailed description of each compilation 
unit included in the program, and a link sranmary. 


38 



DACS 680x0 Bare Ada Cras Compiler System - User’s Guide 

The Ada Linker 


6X17 -[nojfogical -memory 


(default in BASIC mode) 
folM66N£x7fTfflr (default in SECURE nd SAFE mode) 


The -logiad-memory specifies the logical memory areas available for task stacks and task heaps 
in die p ro gra m, logical memory is only legal when option - m ode is set to SECURE or SAFE. 
The logical memory must be disjoint from the physical memory (see section 6X23). 


6X18 -main_task 

-main-task [PR10RITY=<iiumber>] 

(jNOTIME-SLICE | .TIME_SUCE=<reai>] 

UNOFLOAT | JFLOAT] 

[.NOSTACK-START | ,STACK-START=<address>] 
[,STACK_SIZE=<mimber>] 

[JHEAP_SIZE=<number>] 

-main-task PRIORITY=12JiOTIME_SUCE^LOAT^OSTACK_START,\ 

STACK-SIZE=1024041EAP_SIZE=10240 (default) 

Hie -moin.hrak option specifies priority, time slice, use of floating point co-processor, stack 
stan, stack size and heap size for die main task. If PRIORITY=<mimber> is specified and die 
pragma PRIORITY has not been applied then the main task has die priority <number> which 
must be in die range 1X4, otherwise it has die priority specified in die pragma. If the 
HME-SUCE=<reai> is specified then the main task has the time slice <real> (<real> must be 
in the form <number>.<mimber>). If NOTIME -SLICE is specified die main program does not 
have a time slice. If FLOAT is specified die main program may use the floating point 
co-processor. The state of the co-processor will not be saved as pan of die main task context If 
NQFLOAT is specified die main program must NOT use the floating point coprocessor. If 
STACK-START=<address> is specified die main stack pointer is initialized to <addrem>. If 
NOSTACK-START is specified die linker allocates the stack for die main program in the section 
RTS-DATA, and initializes die stack pointer. STACK-START=<address> is not valid when 
-mode is set to SECURE or SAFE. If STACK_SIZE=<nuniber> is specified then <number> 
of bytes is allocated for the main program stack. If HEAP JSIZE=<number> is specified then 
<mnnber> of bytes is allocated for die main program heap. 


6X19 -{no]map 


-nomap (default) 

-mop directs the linker to keep die map file. The map file contains information about memory 
layout of die program. The name of die map file is <main_unit_naine>JTiap. Please refer to 
[Microtec-a] for a description of the map file. 


59 






DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


A2J8 -[uofrunu details 

mm dsfs [HA mmktr 1UNOT1B | ,TIB=<miiiiber>] 

U40HC | ,HC=<aimsber>M»NOTID | ,nD=<uuniber>] 
[^AGE_SIZE=<ntui)ber>][3EGMENT_SIZE=<nuniber>] 

nmriTi rttfalli (default in BASIC mode) 

— <sfHi TIA=7,TIB=7,TIC=6^0TIDJ*AGE_SIZE=12JSEGMENT_SIZE=25 
(default in SECURE and SAFE mode) 

Specifies values far the MMU Translation Control Registers, -mmu .detidls is only legal when 
-made is set to SECURE or SAFE, -nomnm.detafls is only legal when MODE is set to BASIC. 
The paramet e r values are aU number of bits. TIA to TID specifies the number of bits to use on 
MMU table level A to D. PAGE-SIZE specifies the number of bits used for each page accessed 
by a page des cri ptor entry in the MMU tables. SEGMENT-SIZE specifies die number of bits 
used for a segment of the logical memory assigned to each task group. The segment of a task 
group contains the task group heap and stacks of all tasks of the task group. Please refer to 
[MOTOROLA-a] and [MOTOROLA-b] for a detailed description of die MMU and its registers. 

A number of cons trai nts apply to die keywords of the option: 

• If <pu 68030 is specified, die following values are valid for die keywords of the 
-mmu rtetuBa option: TIA, TIB, TIC and HD must be in die range 2..15; NOTEB, 
NOHC and NOHD can alao be used. PAGE-SIZE must be in the range 8..13 for page 
sizes between 2S6 bytes and 32K bytes. SEGMENT-SIZE must be in die range 9..30 for 
a segment size between S12 bytes mid 1 gigabyte. 

• If -epu 68040 is specified, die following values are valid for die keywords of die 
•mmu-detaib option: HA and TIB must be 7, HC must be 3 or 6, mid NOHD must 
be used. NOHB and NOHC camot be used. PAGE-SIZE must be 12 or 13 for a page 
size of 4K bytes or 8K bytes. SEGMENT -SIZE must be 18 or 25 for a segment size of 
256K bytes or 32M bytes. 

• SEGMENT-SIZE must be equal to PAGE-SIZE + TID or PAGE-SIZE + HD + HC 
or PAGE-SIZE + TID 4- HC + TIB. 

• PAGE-SIZE must be equal to or greater dun each of TIA + 2, TIB 4 2, HC 4- 2, and 
HD 4- 2. 

• If NOHB is specified, both NOHC and NOTID must be specified as well, otherwise if 
NOHC is specified, NOHD must be specified as well. 

• The sum of TIA, TIB, HC, HD and PAGE-SIZE must be equal to 32. 

The default value of -ramu-details in SECURE and SAFE mode defines a four level address 
trandation table tree with each page having a size of 4 Kbytes and each logical segment having 
a size of 32 Mbytes. See section 10.5 for further description of how the values for -mmu-details 
is utilized. 





DACS 680x0 Bae Ada Cnas Compiler System - User’s Guide 

The Ada Linker 


&2J1 -node 


-mode BASIC | SECURE | SAFE 
•mode BASIC (default) 

Specifies how the progam shall execute. BASIC means that all code executes at supervisor 
pdvilefe level Le. there is memory protection of neither code nor data. SECURE mode and SAFE 
mode means dm code and data can be protected using the MMU and specified by use of the 
•dam-file option. If -mode is set to SECURE or SAFE the -daas-ffie option must be specified 
as wdL In SECURE mode all objects allocated by allocators ate allocated on the stack of the task 
executing the allocator, while in SAFE mode they are allocated on the heap of the task executi n g 
the allocator. SECURE and SAFE inodes can only be selected when option -epu is set to 68030 
or 68040. See chapter 10 for a complete description of inodes. 


6.2.22 -[no)optlon_fBe 

-option-file <flle-name> 

-nooption -file (default) 

The -option-file option specifies the name of the target link option file. <fUe-name> is used as 
the name for the target link option file. If -nooption-file is specified the Ada linker generates 
an option file with the name <main_unit-name>.opt. 


6223 -nun 

-ram <atart -add r>,<end-addr>{,<atart-addr>,<end-addr>} 

•ram (hKMhcfffTf (default) 

The -ram specifies the physical RAM memory available for the executable program. 


4224 -nun-base 

-ram-base <address> 

-ram-base 0x10000 (default) 

The -ram-base option specifies the base address for the program placed in RAM memory. The 
program sections specified in option -nun-sections are placed consecutively from the address 
specified with this option, hi SECURE and SAFE modes, the base address will always be page 
aligned. The address must be within the physical RAM memory specified in option -ram. 


61 






DACS 680x0 Bare Ada Crocs Compiler System - User’s Guide 

The Ada Linker 


djjS rm carttnni 


-ram-recto total nam»>Utota. mmt>) 

-ram_mcto SUPER_CODE£UPBR_DATA,USER_CODE,\ 

USER_CONS,USER_DATA (default) 

The -rwuMdow option specifies die sections to be placed in RAM memory. The sections are 
placed in the specified Older from the address specified with option - r a m bear Valid section 
names are SUPER-CODE, SUPER-DATA. USER-CODE, USER-CONS and USER-DATA (see 
section 6.8). 


6X26 -{no]rom 

•ram <reart-addr>,<end-addr>{,<start-addr>,<end_addr>} 

•noram (default) 

The -ram specifies the physical ROM memory available for the executable program. 


kL27 -[no)ram base 


•noramJbase (default) 

Hie -ram-bese option specifies the base address for the program placed in ROM memory. The 
program sections specified in option -ram-sections are placed consecutively from the address 
specified with this option. In SECURE and SAFE modes, the base address will always be page 
aligned by truncating die address with die number of bits specified in option -mmu-details 
keyword PAGE-SIZE, i jt. die base address will be the start of the page appointed by the 
specified address. The address must be within the physical ROM memory specified in option 
•ram. 


6X28 -[no]roin_9ections 

•ram-sections <3ection_name>{,<section-name>} 

•norom-sections (default) 

The -ram aertions option specifies the sections to be placed in ROM memory. The sections are 
placed in die specified order from die address specified with the -ram-base option. Valid section 
names are SUPER-COCKE, USER-CODE and USER-CONS (see section 6.8). By default no 
sections are placed in ROM. 


62 




DACS 680x0 Bare Ada Crocs Compiter System - User’s Guide 

The Ada Linker 


am - w« Mack me 


(default) 


Specifi es th e amount of extra stack space allocated in each task for die use of user supplied code 
in the RTS. If die Ada code interfaces to any externally supplied user code (e.g. by use of die 
•wr_Jbrary option) e x ecu tin g in supervisor mode, -rta stack ..use should be set to the amount 
of stack consum e d by this external code. The Ada Linker determines how much RTS stack space 
it will need for the RTS operations, and wfll automatically allocate the minimum necessary RTS 

irtdr fpf ifif , 


£2-30 -{nojscod 



••cod RTS-CODE (defeult) 

Specifies which program sections are to be placed in the supervisor code space, -noscod indicates 
that no program sections should be placed in the supervisor code space. See section 6.8 about 
p sogram icctions. 


£2J1 -{nojsdat 



-sdat RTS-DATA (default) 

Specifies which program sections are to be pl a ce d in the supervisor data space, -nosdat indicates 
that no program sections should be {diced in the supervisor data space. See section 6.8 about 
program sections. 


6132 -[nojstatistfcs 
•statistics 

•nostatistics (default) 

-st at is ti cs specifies that statistics should be displayed about the compilation units included in Ae 
program and their dependencies, otherwise no statistics is displayed. If option -log-file is specified 
(see section 6.2.16), the statistics will be included int the log file as well. 


63 





DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


[io)lir|it i^iijn i 


(defrult) 


-target-options specifies additional options to the target linker. <string> will be added to die 
options far die target linker when die Ada Linker invokes the target linker. For instance if 
tMrvft eptioua "-f c" is specified, -f c will be added to the target linker options, resulting On 
this case) in the external symbol cross-reference table being included in the linker map file. If 
-not arpt -options is specified no additional options, apart from the options determined by the 
Ada tinker itself, will be added to the options for the target linker 


&2J4 4a*_dcftmks 


-task-deftmits [STACK_SIZE=<miinber>][4*RI0RITY=<number>] 

[.NOTIME-SLICE | ,TIME_SUCE=<real>] 

-fask_defhnhs STACKJSIZE=lti24tiJPRI0RITY=12^0TIME_SUCE (default) 

Sp e dfi es die default values to be used for task creation. The defaults specified will be used when 
creating tasks which do not contain pragma priority or the length clause specifying die stack size. 
If STACK_SIZE=<ntHnbcr> is specified then <number> of bytes is allocated fin' a task stack. 
If IW(HUTY=<nuinber> is specified then <number> is used as the priority of the task. The 
specified priority must be in the range 1 to 24. If TIME_SLICE=<real> is specified then <real> 
specifies the number of seconds to use as the time dice for the task; <real> has die form 
<ntunber>.<nuinber>. If NOTIME_SLICE is specified the task does not have a time slice. If 
die target program does not have die tasking attribute (see section 6.7) the -task-defaults option 
is ignored. 


6JL35 -[nojtcb 
-tcb <number> 

——A — 

-WKCO 

-tcb 10 (defimlt) 

Specifies the number of task control blocks to be allocated. If -tcb 0 or -notch is specified and 
the target program has the tasking attribute the linker reports a error and no absolute file will be 
produced. This option is ignored if the target program does not have die task attribute (see section 
6.7). 


62M -ucc_Ibrary 

-ucc-Jibrary <file-name> 

•ucc-fibrary $ADA_UCC (default) 

The -uccJibrary option specifies die name of the UCC library to include in the target program. 
If the UCC library is not specified the environmental variable ADA-UCC is used as file name. 


64 




DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 

The Ada Linker 


&2J7 -(nojucod 

•need <string>{^<string>} 

-ucod ADA_CODE (default) 

Specifies which program sections are to be placed in the user code space, -noucod indicates that 
no program sections should be placed in the user code space. See section 6.8 about program 


6JL38 -{no]ucst 

•neat <string>{,<string>} 

-noucst 

-ucst ADA-CONS (default) 

Specifies which program sections are to be placed in die user constant space, -noucst indicates 
that no program sections should be placed in the user constant space. See section 6.8 about 
program sections. 


6JL39 -[noludat 

-udat <string>{,<string>} 

-noudat 

-udat ADA-OATA (default) 

Specifies which program sections are to be placed in the user data space, -noudat indicates that 
no program sections should be placed in die user data space. See section 6.8 about program 
sections. 


&2.40 -[no Just- library 

-usr_Hbnury <flle_name>, {<flle_name>} 

-nousr-library (default) 

When specified the object files and object libraries denoted by file-name is included in the link, 
otherwise no user library is included in the link. 


6JL41 -[nojvector 

•vector [NOADDRESS | ADDRESS=<address>][,COPY | 4NIT] 
•vector NOADDRESSyCOPY (default) 


65 



DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


Specifies creation of the interrupt vector If ADDRESS is specified die interrupt vector is placed 
at <address>. When NOADDRESS is specified, the interrupt vector will be placed in the section 
RTS-DATA. If COPY is specified die interrupt vector active when the program was invoked is 
copied. If INIT is specified the interrupt vector is initialized by die routine Ada_UCC_D$InitIV. 
•novector specifies that no initialization of the intenupt vector takes (dace. The program can 
hereby be invoked by an interrupt After program invocation die interrupt vector can potentially 
be modified. INIT is not valid when option -debug is specified, see section 6.2.4. 
ADDRESS=<address> is invalid when -mode is set to SECURE or SAFE. 


6X42 -[nojverify 

-verify [ALL][,ELABORATION_ORDER][,COMMANDS][,PARA METERS) 

-noverify (default) 

Determines the type and amount of information generated. If ELABORATION-ORDER is 
specified die elaboration order is displayed, if COMMANDS is specified the commands executing 
the various subprocesses are displayed, if PARAMETERS is specified die active parameters and 
options are displayed, and if ALL is specified all of die above mentioned information is displayed. 
If option -log-file is specified (see section 6.2.16) the information will be included in the log 
file as well 


6X43 -[nojwamings 


•warnings 

-nowamings (default) 

Specifies whether warnings should be generated or not. Warnings are generated when conflicts 
between target program attributes and specified options are detected, and when a package does 
not have a body. 


6X44 The Main Unit Parameter 
<unit-name> 

The main unit must be a parameterless procedure and must be present in the library. The main 
unit name is a required parameter. 


63 The Linker Defaults System 

As it can be seen from the description of options above, default values exist for all options. 
However, it is possible to change the initial setting of default values and even have several 
configurations of default values for the Ada Linker. The Ada Linker default values are controlled 
by use of the option -defaults and the environmental variable ADA_LINK_DEFAULTS. 


66 









DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

Tire Ada Linker 


The Ada Linker obtains its option and parameter values in the following way: Hist, options are 
initialized with the default values indicated in the above description of options. Second, new 
option and param et er defaults are loaded from the file indicated by the environmental variable 
ADA JLINK_DEFAULTS, if this points to an existing file. And third, options and parameters are 
given the value specified in the invocation command of the Ada Linker. 

When the option -defaults is specified, the current value of options and parameters are saved as 
new defiadts in the file identified by the environmental variable ADA-LINK-DEFAULTS. Note 
that ADAJLINK_DEFAULTS is not defined as a environmental variable when the DACS-680x0 
is distributed by DDC-I, so an explicit definition it necessary. 

Assume that the default value of -itch should be 25 instead of 5, and that the new default settings 
should be saved in die file DEFAULTSJJNK. The following commands could be used: 

$ sntnnv ADA-LIHK-DETAOLTS DEFAULTS.LINK 
$*al -defaults -itch 25 

These commands will create a new file called DEFAULTSiJNK in die current directory (if it 
does not exist already) and save die new linker default values in this file. As long as 
ADA-LINK-DEFAULTS keeps its current value of DEFAULTS.LINK, all linking performed in 
the current directory will have a -itch default value of 25. Note that one should normally assign 
a fully expanded file name, like /home/ada_users/usei2/work/E*FAULTSJLINK, to 
ADA-LINK-DEFAULTS to ensure that the correct default file will be found no matter in what 
directory the linking is performed. 

Several configurations of Ada Linker defaults is possible, simply by changing 
ADAJLINK-DEFAULTS to denote different linker default files depending on the desired 
configuration. By the sane method, different users can have different linker default values, simply 
by having ADA_LINK_DEFAULTS denote different files. 

When option -defaults is specified no actual linking takes place; only die current value of the 
options and parameters are saved as new defaults. Before saving the new defaults, all options are 
checked to have a valid value without consideration of other options. If this is not the case, an 
error is reported and the new values are not saved as defaults. However, no check on 
interdependence between the options are performed when specifying new default values, e.g. it is 
possible to set -mode SECURE as default value without specifying a default value for -class-file. 
The interdependence between option values is checked only when an actual linking will be 
performed, i.e. when -defiuilts is not specified. 

To reset the Ada Linker Defaults to the factory setting, simply use the command: 

$ umtmav ADA_LZMK_DZFAULTS "" 

which will ensure that no linker defaults file will be read when the linker is invoked. If the file 
denoted by ADA_LINK_DEFAULTS will not be used again, the file can be deleted. The current 
linker defaults setting can be viewed with the option -verify PARAMETERS, see section 6.2.42. 


67 








DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 

6.4 Environmental Variables Used by the Ada Linker 

When the Ada linker is execttfed, the following environmental variables are used: 


VARIABLE 

PURPOSE 

ADAJLIBRARY 

Identifies foe default library used by all DACS tods. It is foe lowest 
level sublibrary in foe program library hierarchy. This default may 
be overridden by the -library option. 

ADA-UNKJDEFAULTS 

Identifies the file containing foe Ada Linker defaults. Defaults are 
saved in this file when the option -defaults is used. 

ADA-UCC 

Identifies the library containing the User Configurable Code, e.g. an 
UCC library supplied by DDC-I. This default may be overridden by 
die -ucc-library option. 


6J File Names Used by the Linker 

During the link, the following temporary files are created in the current default directory: 

<prcfix>_init.src 

<prefix>_init.obj 

<prefix>_elab.src 

<prefix>_elab.obj 

<prefix>_end.src 

<prefix>_end.obj 

<prefix>.opt 

<prefix>_<unit_no>.obj 

<main_unit_name>.opt 

<main_unit_name>.cora 

If foe -keep option is used <prefix> is tire main unit name, otherwise <prefix> is the process 
identification (pid). 

If linking for SECURE or SAFE mode (see section 6.2.21), the main unit and each defined class 
will result in the generation of a target linker option file. 


6.6 Return Status 

After a linking the return value of the Ada Linker will reflect if the linking was successfully 
completed. The following return values are possible: 


68 







DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


0: The link was successful. Warnings may have been generated during the link process. 

1: An error occurred during the link process, e.g. the Ada Linker is unable to find the UCC 
file. The Ada Linker wiU generate an error message stating the cause of the error. 

2: An internal error has caused the Ada Linker to abort, please contact DDC-I engineers. 


6.7 Program Attributes 

The linker evaluates the following attributes of the target program: 

• Tasking constructs 

The target program has the task attribute when Ada tasking constructs are used. 

. • Floating point constructs 

The target program has foe float attribute when foe program uses foe floating point 
co-processor. The target program will only use foe co-processor instructions to implement 
operations on floating point types. 

• Interrupts, entries or procedures 

The target program has the interrupt attribute when the program contains address clauses 
for task entries or the PRAGMA INTERRUPT-HANDLER. 

• Exception handlers 

The target program has the exception attribute if the program contains any exception 
handlers. 

• Heap 

The target program has the heap attribute when the program contains allocations or 
deallocations on the heap. 

• Secure execution 

The target program has the secure attribute if the program is compiled with option -mode 
set to SECURE or SAFE. In this case the MC68030/MC68040 on-chip Memory 
Management Unit is used to protect code and data segments and for controlling storage 
checks. • 

The linker uses the attributes to generate the initialization module, to issue warnings if a 
combination of options is in conflict with the attributes of the target program, and to determine 
the proper RTS to include in the target link. 

If a program contains interface calls interfacing to code which requires tasking, uses floating point 
instructions or storage management, the Ada compilation unit must contain a pragma to set the 
appropriate attribute. Please refer to Chapter 12 for details. 


69 











DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


6J Profram Sections 

The compiler uses the following program sections: 


Section 

Contents 

RTS-CODE 

RTS-DATA 

ADA-CODE 

ADA-CONS 

ADA-DATA 

Run-Time System code 

Run-Time System data 

Compiler generated code 

Compiler generated constants 
Compiler generated data 


Table 6.1: Program sections 

The program sections RTS-DATA aid ADA-DATA must be in RAM memory. The program 
sections RTS-CODE, ADA-CODE, and ADA-CONS are not modified by the execution of the 
p ro gra m and may be placed in ROM. All sections must be placed in either RAM or ROM 
memory. 

The linker groups die program sections into S new sections: SUPER-CODE, USER-COW, 
USER-CONS, SUPER-DATA and USER-DATA. COW and CONS sections can be stored in 
ROM if desired. DATA sections must be placed in RAM. In SECURE and SAFE mode die 
SUPER and USER sections can be accessed when executing at supervisor privilege level, while 
only USER sections can be accessed when executing at user privilege level (please refer to 
[MOT ORO LA-a] and [MOTOROLA-b] about supervisor and user privilege level). In BASIC mode 
die SUPER aid USER sections can be accessed both when executing at supervisor privilege level 
and when executing at user privilege level. 

When including user defined sections e.g. modules written in assembler, each of the compilers 
program sections and die user defined sections must be specified to the linker as one of the RTS 
program sections using the options -udat, -sdat, -ucst, -ucod and -scod. 


6.9 The Initialization Module 

The initialization module defines constants, allocates memory, and contains the code for 
initialization of the processor and the RTS. The initialization module for a given target program 
depends on the program attributes and the options given to the linker. The initialization module 
is generated as an assembler file with the name <prefix>_iniLsrc. The assembler is invoked to 
produce the object file with the name <prefix> JniLobj. If the -keep option is used <preflx> is 
the main unit name, otherwise <preflx> is the process identification (pid). 


65.1 The Initialization Constants 

The initialization module defines the following externally visible symbols which are constants used 
by the run-time system. 

Ada_INIT$DispiaySize 

The size of the display vector in bytes. This symbol is always defined. 


70 











DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


Ada_INIT$IntemiptStackSize 

The size of the interrupt stack in bytes. This symbol is defined when the -interrupt .stack option 
is specified. 

Ada_INIT$MainStackSize 

The byte size of die stack for the main task. This symbol is always defined. 
AdaJDMIT$MainHeapSize 

The byte size of die heap for the main task. This symbol is defined when option -mode is 
specified to SECURE or SAFE. 

Ada_INIT$DefiiultTimeSlice 

The default time dice for tasks. The symbol defines an integer, the unit is in SYSTEM.T1CKS. 
The symbol is defined when the target p rogram h as the task attribute. If the NOTIME_SLICE 
is specified, die value of the symbol is OxfffffTTf. 

Ada_INIT$DefaultPriority 

The default priority for tasks. The symbol is defined when the target program has the task 
attribute. 

AdaJMIT$MainPriority 

The priority for die main task. The symbol is defined when the target program has the task 
attribute. 

Ada-INTOMainThneSlice 

The time slice for the main program. Same convention as Ada -INTTSDefeuItTimeSlice. 
Ada_INIT$DefaultStackSize 

The stack size for tasks for which the ’STORAGE-SIZE is not applied. This symbol is only 
defined if die target program has die task attribute. 

Ada-INITSRTSStackUse 

The amount of memory reserved on the stack of each task to be used by the RTS. 
Ada_INIT$Main FPUse 

Specifies whether or not the main task may use the floating point co-processor or die 68040 FPU. 
AdaJNIT$TCBCount 

The number of task control blocks allocated minus one. This symbol is only defined when the 
target program has the task attribute. 


71 







DACS 680x0 Bare Ada Cvofli Compiler Syttem - User’s Guide 

The Ada Linker 


AdaJDHTSITCBCoiint 

The number of interrupt task control blocks si located minus one. This symbol is only defined 
when the target program has the interrupt attribute. 

AdaJraT$SuperStackAreaSixe 

The size of the area to allocate supervisor stacks from, which can be allocated to tasks running 
on user privilege level. This symbol is only defined when option •mode is specified to SECURE 
or SAFE. 

AdaJNITSSuperStackCount 

The ma ximum number of supervisor stacks minus one, which can be allocated to tasks running 
on supervisor privilege level. This symbol is only defined when option •mode is specified to 
SECURE or SAFE. 

Ada-INITSMainSuperStackSbe 

The size of the supervisor stack allocated for the main task. This symbol is only defined when 
option -mode is specified to SECURE or SAFE. 

Ada-ENTTSHeapHeaderCount 

The number of heap headers allocated minus one, A heap header contains a pointer to die heap 
and a heap semaphore Of die program contains tasking). This symbol is only defined when option 
•mode is specified to SECURE or SAFE. 

Ada_INIT$DeffcultHeapSize 

The size of the heap allocated for a task. This symbol is only defined when option -mode is 
specified to SECURE or SAFE. 

AdaJCNlT$PageSize 

The logical/physical page size measured in number of bytes. This symbol is only defined when 
option -mode is specified to SECURE or SAFE. 

Ada_lNIT$PageWidth 

The number of bits used as offset within a page, log 2 of page size. This symbol is only defined 
when option -mode is specified to SECURE or SAFE. 

AdaJDSITSLogSegiiwntWidth 

The number of bits used as offset within a segment. This symbol is only defined when option 
•mode is specified to SECURE or SAFE. 

AdaJNITSMMUTIA 

The Translation Control Register’s Table Index A value. This symbol is only defined when option 
•mode is specified to SECURE or SAFE. 


72 





DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


Ada-nOTSMMUTIB 

The Translation Control Register’s Table Index B value. This symbol is only defined when option 
•node is specified to SECURE or SAFE. 

AdoJDOTOMMUTIC 

The Translation Control Register’s Table Index C value. This symbol is only defined when option 
•node is specified to SECURE or SAFE. 

AdaJWITSMMUTID 

The Translation Control Register’s Table Index D value. This symbol is only defined when option 
•node is specified to SECURE or SAFE. 

Ada-INITSTLMMFreeCottnt 

The sine of a table describing free logical memory within all active task groups. This symbol is 
only defined when option -mode is specified to SECURE or SAFE. 


632 Initialization Code 

The initialization module contains code for initialization of the RTS components included in the 
target program. The initialization steps are executed in the same sequence as they are listed. When 
the initialization code is called, the interrupt priority level (IPL) mask in MC68QxO Status Register 
is assumed to be 7 and the active stack is assumed to be tire interrupt stack. 

Initialization of the Interrupt Stack 

The interrupt stack pointer is initialized. This initialization is only performed when the opuon 
-interrupt-stack is specified. 

Initialization of the Main Stack 

The mode is dunged to use die master stack pointer and the master stack pointer is initialized. 
This initialization is only performed if option -main-task, keyword STACK-SIZE > 0. If option 
•mode is set to SECURE or SAFE the supervisor main stack is initialized instead. 

Initialization of file Interrupt Vector 

The interrupt vector is either copied from the interrupt vector defined by the VBR register, or 
initialized compietdy, depending on the -vector option. If the -novector option is specified the 
interrupt vector is not initialized. 

Initialization of the Virtual Memory Manager 

If option -mode is set to SECURE or SAFE the Virtual Memory Manager is initialized. The 
VMM initialization generates internal data structures concerning free physical RAM memory 
specified by option -ram and free logical memory specified by option -logical-memory. 
Furthermore, MMU tables are created for supervisor code mapping all code as read only, user 


73 




DACS 680x0 Bate Ada Cross Compiler System • User's Guide 

The Ada Linker 


code mapping Ada code as read only, and supervisor data mapping all physical RAM memory as 
specified with option -ram as read/write. 


Initialization of classes is performed if option -mode is set to SECURE or SAFE. For each class 
a uaer data memory mapping table is generated. The table contains constants, stack, heap and 
permanent data for the class itself and data from other desses according to the rights defined in 
the class file in specified with option -dam-file. 

Initialization of the 680x0 Interrupt Vector Entries 

The interrupt vector entries for the 680x0 exceptions that are used by the RTS are initialized by 
calling Ada_.UCCJB$InitMPUIV (aee the Configuration Guide [DDC-b] for more details). This 
initialization is only performed if -noexcepdons has not been specified and the target program has 
the exception handler attribute. 

Initialization of 6B88x Interrupt Vector Entries 

The interrupt vector entries for the 6888x or 68040 FPU exceptions that are used by the RTS are 
initialized by calling Ada_UCC_F$InitFPUIV (see the Configuration Guide [DDC-b] for more 
details). TMs initialization is only performed if - n oexceptions has not been specified, and die 
program has the float and exception handler attributes. 

Initialization of the Storage Manager 

The parameter list defining the memory available to the storage manager is created and the storage 
manager is initialized. The storage manager is only initialized when die target program has die 
heap attribute. 

Initialization of Exception Handler 
Initialization fin- pre-handlers is performed. 

Initialization of the Timer 

If the target program has die task attribute, the timer is initialized by calling 
Ada-UCC-MIiutTuner (see the Configuration Guide [DDC-b] for more details). The timer may 
also be initialized when die package Calendar is included in die program, but that depends on die 
implementation of package Calendar. The implementation supplied by DDC-I will use the timer. 

User Specified Initialization Code 

At this point, user specified initialization code is called. Please refer to Section 6.2.11 for details 
on user specified initialization code. 

Initialization of Frame Heap 

The permanent frame heap headers on die outermost level are initialized. A frame heap header is 
a structure of heap elements at current block level. 

Initialization of the Main Program 


74 



DACS 680x0 Bare Ada Cion Compiler System - User’s Guide 

The Ada Linker 


The ktMaBratkm of the main program allocates and initializes the display vector and initializes 
the frame pointer and the display pointer (A6, AS). 


If the taiga program has the task or the interrupt attribute, the tasking kernel is initialized. The 
Wtialiaation of the tasking kernel creates the main task. The initialization of the tasking kernel 
util also change the 1FL to 0. If the program have neither of the mentioned attributes, the tasking 
hawi ri is not inkializ&d, but the IPL is to 0. 

Invoca ti on of the Haboratiaa Module 

The elaboration module is invoked rod will execute the target program. The elaboration module 
la invoked by a branch and will return by a branch or a trap if linked in SECURE or SAFE 
nipde. 


Termination of the Main Task 

Upon return from die elaboration module, the main program must wait until all tasks have 
terminated. If the target program has the task attribute, the routine in the tasking kernel terminating 
die main program is called. If not, the only task (the main task) is already terminated and no 
action is required. 

Preparation for Termination of the Program 

To ensure proper termination the IPL is raised to 7, the Master Stack will be the active stack 
afterwards. 

Invocation of User Defined Termination Code 

Transfers control to the user supplied termination routine Ada_UCC_B$Exit (see [DDC-b]). Please 
refer to Section F.1.4 for details on user specified termination code (PRAGMA RUNDOWN). 


63J Initialization 

The initialize module allocates memory for the RTS data structures that depends on the target 
program or on options to the linker. The following data areas are defined, and made addressable 
by the symbols: 

Ada_INIT$InterruptVector 

The address of the interrupt vector. This symbol is defined when the option -vector is specified. 
If ADDRESS=<address> is specified an absolute section is created at <address>, die symbol is 
equated to <addreas>, rod 1024 bytes is allocated for the interrupt vector. If -novector is specified 
the symbol is not defined and the memory not allocated. 

Ada_INIT$IntemiptStock 

The start address of the interrupt stack. This symbol is defined when the option -interrupt .stack 
is specified. If START=<address> is specified an absolute section is created at <address>, the 


75 




DACS 680x0 Bare Ada Cross C o mpil e r System - User's Guide 

The Ada Linker 


symbol is equaled to <adtfrtir> and the number of bytes specified with SIZE are reserved. 
Other wise die interrupt stack is allocated in the RTS-DATA section by a DS directive. 


The statt address of the main program stack. The symbol is defined when the option -main_task 
is specified. If STABTs<addras> is specified then the symbol is equsted to <addrees> otherwise 
the main stack is allocated in the RTS-DATA section by a DS directive. 

AdnJDOTtMalnDiapUy 

A pointer to the main display when the program has no tasking. The memory is only allocated 
when the target program has the task attribute. 

Ada_INIT$TCBAddress 

The start address of the memory allocated for the task control blocks. The memory is allocated 
when the target program has the task attribute. 

Ada-JNTT$ITCBAddress 

The stmt address of the memory allocated for interrupt task control Modes. The memory is 
aHocamd when the target program has the interrupt attribute. 

Ada_INIT$CurrITCB<hdimTupt-no> 

One long word is allocated for each interrupt vector entry that the target program references. 
Ada_INIT$SuperStackArea 

The start address of the area from which supervisor stacks are allocated. Only supervisor stacks 
for tasks at user privilege level are allocated in this area. The memory is only allocated when the 
option -mode is set to SECURE or SAFE. 

Ada_INIT$TempHeap 

The address of die memory for Frame heap header for allocation of temporary objects on die 
outermost lexical levd. 

Ada_INIT$HeapHeaderArea 

The start address of die memory allocated for heap headers. The memory is only allocated when 
the option -mode is set to SECURE or SAFE. 

Ada-INITSFdTabie 

The start address of the memory allocated for the Function Code Lookup table used by the MMU. 
The address most be 16 bytes aligned. The memory is only allocated when die option -mode is 
set to SECURE or SAFE. 

Ada_INIT$FreePageCount 


76 



DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


The address of the memory allocated for the number of free physical pages. The memory is only 
allocated when the option •mode is set to SECURE or SAFE. 


The address of a pointer, addressing the list describing the free physical pages for each task group 
(see chapter 10). The memory is only when die option -mode is set to SECURE or 

SAFE. 


The a ddress of the memory pointing at the next free physical memory area in 
AdteJFaTSDredPtepTaMe. The memory is only allocated when the option -mode is set to 
SECURE or SAFE. 

Ada_JNlT$FredPngeTable 

The start address of die memory allocated for the table of physical RAM memory areas used 
initially. The contents of the table is derived from the option -ram. The memory is only allocated 
when the option -mode is set to SECURE or SAFE. 

Ada-JNIT$Fk«eScgmentIhd« 

The a ddress of the memory pointing at die next entry with a free segment in 
Ada.JNIT$FreeSegmeiitTmble. The memory is only allocated when the option -mode is set to 
SECURE or SAFE. 

Ada_INlT$FreeSegnientTable 

The start address of the memory allocated for the table of free logical memory segments. The 
memory Is only allocated when the option -mode is set to SECURE or SAFE. 

AdaJmrr$FreeSegmentTop 

The address of the top of die free segment stack. The memory is only allocated when die option 
•mode is set to SECURE or SAFE. 

Ada-JraT$FreeSegmentStack 

The start address of the memory allocated for the stack of deallocated segments. The memory is 
only allocated when die option -mode is set to SECURE or SAFE. 

Ada_INIT$TLMMFreeArea 

The stmt address of die memory allocated for the table describing the free logical memory within 
all active fade groups. The memory is only allocated when the option -mode is set to SECURE 
or SAFE. 


77 




DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


*!• The Elaboration Module 

The dabontion module is generated as m assembly file, and die amembler is invoked to produce 
die actnal object module. The asmmbly file is named <preflx>_elahjrc and die object file name 

The elaboration module has the entry point Ada_ELAB$Entry, which is invoked from the 
hjuait—tfam module by a branch. 


till BASIC Execution Mode 

The elaboration module has die following structure, when -mode is set to BASIC: 

NAME ADA-ELAB 
CHIP <a«l«cted cpu> 

XDBF Ad«-ELAB$Entry 
XREF Ad*—INIT$E1abBxit 
XREF M$<main_unit_no>_l 
XDEF R$<unit_no_l>-0 
XREF M$<unit_no_l>_0 
XDEF R$<unit_no_2>_0 
XREF M$<unit_ao_2>_0 


SECTION ADA-CODE 


Ada_EIAB$Entry: 

bra.l 

M$<unit_no_l>_0 

R$<unit_no_l>_0: 

bra.l 

M$<unit_no_2>_0 

R$<unit_no_2>_0: 

• • • 



• • • 

bsr.l 

M$<main_unit_no>_l 


rooveq.l 

*0,d0 


bra.l 

Ada_INIT$ElabExit 


END 


The elaooradon module brandies to the elaboration for each of the included compilation units, and 
die elaboration code will branch bade to the elaboration module. The elaboration code for a 
compilation unit will be identified by die label M$<unit_no>_0 where <unit_no> is the unit 
number of die compilation unit The return point is identified by die label R$cunit_no>-0. 


6.1*2 SECURE and SAFE Execution Mode 

When Uniting with option -mode set to SECURE or SAFE, the elaboration module has the 
following structure: 



DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


Ada_ELAB$£ntry: 


R$<unit_no_l>_0: 
R$<unit_no_2>_0: 


NAME 

ADA-ELAB 

CHIP 

<selected cpu> 

XDEF 

Ada_ELAB$Entry 

XREF 

Ada_INIT$ElabBxit 

XREF 

M$<main_unit_no>_l 

XREF 

Ada_TK_X$Elaborate 

XREF 

Ada_TK_X$CallMain 

XREF 

Ada_INIT$MainClass 

XREF 

N$<class_name-1> 

XREF 

• • • 

N$<class-name_2> 

XDEF 

R$<unit_no_l>_0 

XREF 

M$<unit_no_l>_0 

XDEF 

R$<unit_no_2>_0 

XREF 

M$<unit_no_2>_0 

SECTION ADA—CODE 

lea.l 

N$<clas3_name>,aO 

lea.l 

M$<unit-no>-l , al 

bar. I 

Ada_TK_X$Elaborate 

lea.l 

N$<clas3-name>, aO 

lea.l 

M$<unit _no>-l, al 

bsr.l 

• « • 

Ada_TK_X$Elaborate 

• • • 

• • • 

lea.l 

N$<clasa_name>,aO 

lea.l 

M$<main_unit_no>_l 

moveq. 

1 #0,d0 

bar.l 

AdaTK_X$CallMain 

lea.l 

Ada_INIT$ElabExit,aO 

moveq. 

1 #0,d0 

moveq. 

1 #l,d7 

trap 

#13 


R$<unit_no_<u»_0: moveq .1 *0, d7 

trap #13 
END 

Hie elaboration of each compilation unit is handled by Ada_TK_X$Elaborate which takes a class 
nuieiind an elaboration code label M$<unit_no>_0. The return point is identified by the label 
R$<iiiiit-JM»-0. The elaboration of each compilation unit runs at user privilege level, but the 
swop for tile elaboration of each compilation unit must run at supervisor privilege level. To switch 
from user privilege level to supervisor privilege level a trap operation is executed, and the 
elaboration of the ne> unit will proceed. 


79 



DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 

The Ada Linker 


6.1QJ Execution of the Main Program 

When all the compilation units have been elaborated the main program is called. The main 
program is identified by the label M$<main-unH_no>-l. If the main program returns, register 
dO is cleared to signal successful completion, and control is passed back to the initialization 
module. 

Please note that all transfers of control between the initialization module, the elaboration module, 
and die elaboration code is implemented by branch instructions. The branch instructions are used 
because the elaboration code may allocate objects on the stack, and consequently stack balance 
cannot be assumed. 


6.11 Linker Examples 

This section contains a number of linker examples. It is assumed that the compilation unit example 
is compiled into the default program sublibrary, that the environmental variable ADA-LIBRARY 
has been equated to the default sublibrary and that die environmental variable ADA-UCC has 
been equated to an User Configurable Code Library suitable for the target board on which die 
linked program will be executed. DDC-I provides UCC libraries for the Radstone CPU-3A and the 
Motorola MVME133, MVME143 and MVME165 boards. 


Example: I 

$ al -noheap example 

The program will start at address 0x10000, and the heap is not initialized. If the target program 
has the heap attribute an error message is issued. 


Example: 2 

$ al -ram 0x10000, Oxfffff example 

The program will start at address 0x10000, and die heap will be placed within the address range 
0x10000 to Oxfffff. This is the simplest form of a link that will support all Ada constructs. 


Example: 3 

$ al -raa-base 0x4000 -ram 0x0, Oxfffff exaaqple 

The prog ram will start at address 0x4000, and the heap will be placed within the address range 
0x4000 to Oxfffff. Physical memory below address 0x4000 is not used. 


80 








DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


Example: 4 

$ al -rom_sections SUFKR-COOK,USER-COD*,USER-COD*\ 
-ram-sactions SUPER—DATA, US*R_DATA\ 

-rom 0x200000,0x2fffff -rom_bas« 0x200000\ 

-ram 0x0,0xfffff -ram-bass 0x0 axamplm 

The sections SUPER-CODE, USER-CODE aid USER-CONS are placed in ROM from address 
0x200000. The sections SUPER-DATA and USER-DATA are placed in RAM from address 
0x0. The part of the address range 0x0 to Oxfffff not used by the SUPER-DATA section is used 
as heap space. 


Example: S 

$ al -rom-sactions SUFKR-CODB -romJbasa 0x200000\ 

-raa_sections SUPER-DATA -raatJbase 0x0\ 

-SCOd RTS—CODE, ADA—CODE, ADA—COHS\ 

-noucod -noucst -vector INIT -boot\ 

-ram 0x0,0xfffff -rom 0x200000,0x2fffff example 

As example 4 but a module containing reset information is produced. The reset address is 
0x200000. The interrupt vector is completely initialized. The first two long words of section 
RTS-CODE contains die initial PC and die initial interrupt stack pointer, consequently 
RTS-CODE must be the first section to load in order to control the reset address. 


Example: 6 

$ al -ram 0x10000,0xfffff\ 

-vactor ADDRESS-0x70000,COPY\ 

-interrupt-stack START=0x70000,SIZE-0x8000\ 

-main-task STACK_START=0x68000,STACK_SIZK«0x8000,\ 
PRIORITY-3,TIME-SLICE-0.2,FLOAT\ 
-task-defaults STACK_SlZE-0x8000,PRIORITY-4,\ 
TIME-SLICE-0.1 example 

The start address of the program is 0x10000. The interrupt vector has the address 0x70000 and 
is a copy of the interrupt vector defined when the Ada program gains control. The interrupt stack 
has start address at 0x70000 and the size 0x8000. Please note that die first byte used in the stack 
is 0x6ffff and the stack grows by de c reme nti ng the stack pointer (stack grows "down" in memory). 
The main program stack's start address is 0x68000, and the size is 0x8000, the main program 
has a priority of 3 if pragma priority does not apply, the time slice is 0.2 seconds and the main 
program uses the floating point co-processor. The defaults used for task stack size is 0x8000, a 
priority of 4 and a time slice of 0.1 second. 


81 




DACS 680x0 Bane Ada Cross Compiler System - User’s Guide 

The Ada Linker 


Example: 7 

$ al -init_fila By.fila.src -option_filu ay_.fila.opt axaapla 

The linker was not able to generate an adequate initialization and option file, and the user decided 
to use his own. The my-illejrc file contains the assembly source for the initialization module, 
and the my_flfeopt contains the option file for the link. With this form of link the user has full 
control over the option file and the initialization module. 


Example: 8 

$ al -aoda SECURE -olass-fila axaapla.cla\ 

-ram 0x10000,Oxfffff\ 

-amu-dataila SEGMENT_SIZE=16, PAGB_SIZE«10,\ 

TIM, TIB-8, TIC-6 axaapla 

Execution of the program will be in SECURE mode. The class specification is in the file 
examplexls. Heaps and dynamic allocated stacks will be placed in address range 0x10000 to 
Oxfffff. The MMU Translation Control Register is setup with a page size of IK bytes, and TIA 
= 8, TIB = 8, TIC = 6, HD = 0, each class gets 64K bytes of logical memory for heaps and 
stacks. 


82 




APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type SHORT_INTEGER is range -32768 .. 32_767; 

type INTEGER is range -2_147_483_648 .. 2_147_483_647; 

type FLOAT is digits 6 

range -3.4028234666385E-f38 .. 3.4028234666385E+38; 
type LONG_FLOAT is digits 15 

range -1.7976931348623157E+308 .. 1.7976931348623157E+308; 
type DURATION is delta 2#1.0#E-14 range -131_072.0 .. 131071.0; 
end STANDARD; 


C-l 




APPENDIX F - IMPLEMENTATION DEPENDENT CHARACTERISTICS 


This appendix describes the implementation-dependent characteristics of DACS-680x0 required in 
Appendix F of the Ada Reference Manual (ANS1/MIL-STD-1815A). 


F.l Implementation-Dependent Pragmas 

This section describes all implementation defined pragmas. 

FI.l PRAGMA INTERFACE-SPELLING 

Foimat: pragma INTERFACE_SPELLING(<subprogram-name>, <string>) 

Placement: The pragma may be placed as a declarative item. 

Restrictions: Pragma INTERFACE-SPELLING must be applied to the subprogram denoted 
by <subprogram-name>. The <string> must be a string literal. 

This {Magma allows an Ada program to call routines with a name that is not a legal Ada name, 
the <string> provides the exact spelling of the name of the procedure. 


F1.2 PRAGMA INTERFACE-TRAP 

Format: pragma INTERFACE_TRAP(<subprogram-name>, <string>, <integer>) 

Placement: The pragma may be placed as a declarative item. 

Restrictions: The <subprogram-name> must denote a procedure or a function for which pragma 
interface to AS has been applied. The <string> must be a string literal. The 
<integer> must be greater than 3. 

The pragma allows the programmer to implement assembler routines that need access to the run¬ 
time system code or data in a link mode independent manner. The string literal is used as the 
name for a global linker symbol, when the linker implements the call to the user supplied 
subroutine. The string literal must be unique when linking a program containing calls to 
subprograms for which INTERFACE-TRAP is applied. The integer is used as an index to the 
table of entry points in the kernel and must likewise be unique. When the integer is chosen, please 
consult the padcage RTS-TRANSFER-INDICES (see appendix C.8) to avoid conflicts with the 
indices used by the run-time system and support packages. 

When control is passed to the user supplied routine register A4 contains the value of the 
stackpointer prior to the call: A4 is the only way to access parameters for the routine. The routine 
must maintain stack balance and must return by a RTS. 


173 











DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
Implementation Dependent Characteristics 


For a program linked with the SECURE or SAFE mode it is checked that the task executing the 
routine has the "change mode to supervisor" privilege. The check is perfoimed before control is 
passed to the user supplied routine. 


F1J PRAGMA INITIALIZE 

Format: pragma INITIALIZE(<stringJiteral>) 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

-When the pragma is applied the linker will, as part of the initialization code generate a call to the 
subprogram with the name <string_iiteral>. The call will be performed before the elaboration of 
the Ada program is initiated, with the interrupt mask in the Status Register at 7. If several 
pragmas INITIALIZE are applied to the same program the routines are called in the elaboration 
order, if several pragmas INITIALIZE are applied to one compilation unit the routines are called 
in the older of appearance. If several compilation units apply pragma INITIALIZE to the same 
routine the routine is only called tmce. 


F1.4 PRAGMA RUNDOWN 

Format: pragma RUNDOWN(<stringJiterai>) 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Similar to pragma initialize, but the subprogram is called after the main program have terminated 
and in the reverse order of the elaboration order. 


F1.5 PRAGMA TASKS 
Format: pragma TASKS; 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Marks the compilation unit with the task attribute If the code that is interfaced by a pragma 
INTERFACE uses any tasking constructs, the ation unit must be marked such that the 

linker includes the tasking kernel in target progr at reference the compilation unit. 


174 




DACS 680x0 Bate Ada Cross Compiler System - User’s Guide 
Implementation Dependent Characteristics 


FI.6 PRAGMA FLOATS 
Format: pragma FLOATS; 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Maries the compilation unit with the float attribute. If the code that is interfaced by a pragma 
INTERFACE uses any floating point co-processor instructions, the compilation unit must be 
marked such that the 1 ««***• includes initialization of the floating point co-processor in target 
programs that reference the compilation unit 


FI.7 PRAGMA INTERRUPTS 
Format: pragma INTERRUPTS; 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Marks the compilation unit with the interrupt attribute. If the code that is interfaced by a pragma 
INTERFACE uses my interrupts, the compilation unit must be marked such that the linker 
include the interrupt handling in target programs that reference the compilation unit 


FIJI PRAGMA STORAGE m ^AGER 
Format: pragma STORAGE-MANAGER; 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Marks the compilation unit with the heap attribute. If the code that is interfaced by a pragma 
INTERFACE uses the storage manager, the compilation unit must be marked such that the linker 
include initialization of the storage manager in target programs that reference the compilation unit 


FI.9 PRAGMA INTERRUPT-HANDLER 

The pragma INTERRUPT-HANDLER is defined with two formats. 


175 





DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 


Fl.9.1 PRAGMA INTERRUPT-HANDLER for Task Entries 
Format: pragma INTERRUPT-HANDLER; 

Placement: The pragma must be placed as the first declarative item in the task specification that 

it applies to. 

Restrictions: The task for which the pragma INTERRUPT-HANDLER is applied must fulfill 
die following requirements: 

1) The pragma must appear first in the specification of the task and an address clause must 
be given to all entries defined in the task, see below. 

task fih is 

• pragma interrupt-handler; 

entry handler1; 
for handlerl use at 254; 
entry handler2; 
for handler2 use at 255; 
end fih; 

2) All entries of the task must be single entries with no parameters. 

3) The entries must not be called from any tasks. 

4) No other tasks may be specified in the body of the task. 

3) The body of the task must consist of a single sequence of accept statements for each of the 
defined interrupts, see below: 

task body fih is 

— local simple data declaration, no tasks, 
begin 

accept handlerl do 
<statementlist>; 
end handlerl; 
accept handler2 do 
<statementlist>; 
end handler2; 
end fih; 

6) The only tasking construct that may be used from the body of an accept statement is 
unconditional entry calls. Several unconditional entry calls may appear in the body of an 
accept statement but only one entry call must be made during the handling of the interrupts. 

7) Any procedures called from the accept body may not use any tasking constructs at all. 

8) A given entry must only be accepted once within the body of an FIH. 

9) No exceptions may be propagated out of the task body. 

If the restrictions described above are not fulfilled, the program is erroneous and the result of the 
execution unpredictable. The compiler cannot and is not checking all the restrictions, but attempts 
to perform as many checks of the requirements as possible. 


176 




DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
Implementation Dependent Characteristics 


The pragma INTERRUPT-HANDLER with no parameters allows the user to implement 
immediate response to exceptions. 


FI 32 PRAGMA INTERRUPT-HANDLER for Procedures 

Format: pragma INTERRUPT-HANDLER(procedure-name,integer-iiteral); 

Placement: The pragma must be placed as a declarative item, in the declarative part, 

immediately after the procedure specification. 

Restrictions: The procedure for which pragma INTERRUPT -HANDLER applies must fulfill the 
following restrictions: 

1) The pragma must appear before the body of the procedure. 

2) The procedure must not be called anywhere in the application. 

3) No tasks may be declared in the body of the procedure. 

4) The only tasking construct that may be used from the body of the procedure is 
unconditional entry calls. Several unconditional entry calls may appear in the body of the 
procedure, but only one entry call may be made during the handling of the interrupt 

5) Any su b pro gr a m s called from the procedure must not use any tasking constructs at all. 

6) The procedure must have no parameters. 

7) No exceptions may be propagated out of the procedure. 

If the restrictions described above is not fulfilled the program is erroneous and the result of the 
execution unpredictable. The compiler cannot and is not checking all the restrictions, but attempts 
to perform as many checks of the requirements as possible. 

The pragma INTERRUPT-HANDLER for procedures defines the named subprogram to be an 
interrupt handler for die interrupt vector entry defined by the integer-literal. 


F1.10 PRAGMA NO-FLOATING-POINTS 

Format: pragma NO-FLOATING JPOINTS(task-id) 

Placement: The pragma must be placed as a declarative item, in the declarative part, defining 

the task type or object denoted by the task-id. 

Restrictions: The task(s) denoted by the task-id must not execute floating-point co-processor 
instructions. 

This pragma informs the compiler and run-time system that the task will not execute floating point 
co-processor instructions. Consequently the context switch needs not save and restore the state of 
the floating point co-processor yielding improved performance. 


177 





DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 

F1.1I PRAGMA SUPERVISOR-TASK 
Format: pragma SUPERVISOR-TASK 

Placement: The pragma must be placed immediately after the task declaration of the task 

declaring it as a SUPERVISOR-TASK 

Restrictions: The pragma has no meaning if linking with BASIC mode. 

This pragma informs the compiler and nm-time system that the task shall execute at the supervisor 
privilege level, all other tasks will execute at user privilege level when linking with SECURE or 
SAFE mode. In BASIC mode all tasks execute at the supervisor privilege level. 

F1.I2 PRAGMA ACCESS-TYPEJRETAIN-HEAP 
Format: pragma ACCESS_TYPE_RETAIN_HEAP 

Placement: The pragma must be placed as a declarative item in die declarative part, immediately 

after the procedure specification. 

Restrictions: The pragma can only be used when linking in BASIC mode. 

This pragma suppresses garbage collection of access types, when leaving the scope of the access 
type declaration. 

FJ Implementation-Dependent Attributes 
No implementation-dependent attributes are defined. 


178 





DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 


FJ Package SYSTEM 

package SYSTEM is 


type ADDRESS 

is new INTEGER, 


subtype PRIORITY 

ia INTEGER range 1 .. 24; 

type NAME 

ia ( DACS-680X0 

); 

SYSTEM-NAME: 

constant NAME 

- DACS.680X0; 

STORAGE-UNIT: 

constant 

- 8; 

MEMORY-SIZE: 

constant 

- 2#1#E32; 

MIN-INT: 

constant 

- -2-147-483-648; 

MAX _ I NT: 

constant 

- 2-147-483-647; 

MAX-DIGITS: 

constant 

- 15; 

MAX-MANTISSA: 

constant 

- 31; 

PINE-DELTA: 

constant 2#1.0#E-31; 

TICK: 

constant 

2#1.0#E-14; 

type interface-language is (AS,C); 



end SYSTEM; 

The basic dock period SYSTEM.TICK is not utilized by DACS-680x0. The teal time between 
each successive timer tick will be a multiplum of SYSTEM.TICK, but die actual time between 
each timer tick depends on a given target board and is specified in the User Configurable Code 
(UCQ. 


F.4 Representation Clauses 

The DACS-680x0 fully supports the ’SIZE representation for derived types. The representation 
clauses that are accepted for nan-derived types are described in the following subsections. 


F4.1 Length Clause 

Some remarks on implementation dependent behavior of length clauses are necessary: 

• When using the SIZE attribute for discrete types, the maximum value that can be specified 
is 32 bits. 

• SIZE is only obeyed for discrete types when the type is a part of a composite object, e.g. 
arrays or records. 

• Using the STORAGE-SIZE attribute for a collection will set an upper limit on the total 
size of objects allocated in this collection. If further allocation is attempted, the exception 
STORAGE-ERROR is raised. 

• When STORAGE-SIZE is specified in a length clause for a task, die process stack area 
will be of the specified size. 


179 






DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 


P42 Emnnsr atlon Representation Clauses 

Enumera tio n representation clauses may specify representations in the range of INTEGER’FIRST 
♦ lJNTBGER’LAST - 1. 


F4J Record Repremttikn C lau se s 

When representation clauses are applied to records the following restrictions are imposed: 

• If the component is a record or an unpacked array, it must start at a storage unit boundary 
(8 bits). 

• record occupies an integral number of storage units (words) (even though a record may 
have fields that only define an odd number of bytes). 

• A record may take up a maximum of 2 giga bits. 

• A component must be specified with its proper size (in bits), regardless of whether the 
component is an array or not 

• If a nott-airay component has a size which equals or exceeds one storage unit 32-bits the 
component must start on a storage unit boundary. 

• The dements in an array component should always be wholly contained in 32-bits. 

If the record type contains components which are not covered by a component clause, they are 
allocated consecutively after the component with the value. Allocation of a record component 
without a component clause is always aligned on a storage unit boundary. Holes created because 
of component clauses are not otherwise utilized by the compiler. 

Pragma PACK on a record type will attempt to pack the components not already covered by a 
representation clause (perhaps none). This packing will begin with the small scalar components and 
larger components will follow in the order specified in the record. The packing begins at the first 
storage unit after the components with representation clauses. 


F4J.1 Alignment Clauses 

Alignment clauses for records are implemented with the following characteristics: 

• If the declaration of foe record type is done at foe outermost level in a library package, any 
alignment is accepted, otherwise only longword alignments are accepted. 

• Any record object declared at foe outermost level in a library package will be aligned 
according to the alignment clause specified for the type. Record objects declared elsewhere 
can only be aligned on a longword boundary. If foe record type is associated with a 
different alignment, an error message will be issued. 

• If a record type with an associated alignment clause is used in a composite type, the 
alignment is required to be longword; an error message is issued if this is not the case. 


180 


. - l - *, - ' ■ 1 •' " ’ - •■- — ■ ■■ - -- 

' .f .* ■*■ *.' "f. '■ *'■ ■' ■ •‘"N ■ '5^lf 

-■ . " O :’ 1 ' ■ >. • ‘4 i 

DACS 680x0 Bare Ate Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 

WJS Im pl s—lai ion- D ep and e nt Names for I mplem e n t at i on -Dependent Components 
by tli6 compiler. 


This section desc ribes the implementation of address clauses and what types of entities may have 
their address specified by the user. 

Ftt.1 Objects 

Address clauses are supported for scalar and composite objects whose size can be determined at 
compile time if the address is specified. 

F&2 Task Entries 

Address clauses are supported for task entries. The following restrictions applies: 

• The affected entries must be defined in a task object only, not a task type. 

• The entries must be single and paiameteiiess. 

• The address specified must not denote an interrupt index which die processor may trap. 

• If the interrupt entry executes floating point co-processor instructions the state of the 
co-processor must be saved prior to execution of any floating point instructions, and restored 
before the return. 

The address specified in the address clause denotes the interrupt vector index. 

F.7 Unchecked Programming 

Both UNCHECKED-DEALLOCATION and UNCHECKED-CONVERSION are supported as 
indicated below. 

F7.1 Unchecked Deallocation 

Unchecked deallocation is fully supported through the procedure UNCHECKED-DEALLOCATION 
as defined in [DoD-83] 13.10.1. 


181 





DACS 680x0 Bare Ada Cross Compiler System - User's Guide 
implementation Dependent rhanxtfnqirs 


F7 J2 Unchecked Conversion 

Unchecked conversion is fully supported through the procedure UNCHECKED-CONVERSION as 
defined in [DoD-83] 13.10.2. Unchecked conversion is only allowed between objects of the same 
"size". However, if a scalar type have different sizes (packed and unpacked), unchecked conversion 
between such a type and another type is accepted if either the packed or the unpacked size fits 
the other type. 


FA Input/Output Packages 

In many embedded systems, there is no need for a traditional I/O system, but in order to support 
testing and validation, DDC-I has developed a small terminal oriented I/O system. This I/O system 
consists essentially of EXTJLO adapted with respect to handling only a terminal and not file I/O 
(file I/O will cause a USE-ERROR to be raised) and a low level package called 
TERMINAL-DRIVER. A BASIC _IO package has been provided for convenience purposes, 
forming an interface between TEXT-IO and TERMINAL-DRIVER as illustrated in the following 
figure. 




TEXT-IO 



BASIC-IO 

TERMINAL-DRIVER 
(H/W interface) 


Figure F.l: 

The TERMINAL-DRIVER package is the only package that is target dependent, i.e., it is the 
only package that need be changed when changing communications controllers. The actual body 
of the TERMINAL-DRIVER is written in assembly language, but an Ada interface to this body 
is provided. A user can also call the terminal driver routines directly, i.e. from an assembly 
language routine. TEXT-IO and BASIC_IO are written completely in Ada and need not be 
changed. 

BASIC-IO provides a mapping between TEXT-IO control characters and ASCII as follows: 


TEXT-IO 

ASCII Character 

LINE-TERMINATOR 

PAGE-TERMINATOR 

FILE-TERMINATOR 

NEW-LINE 

ASCII.CR 

ASCII.FF 

ASCII.EM (Ctrl Z) 

ASCII.LF 


Table F.l: Mapping between TEXT-IO and ASCII 


182 










DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
Implementation Dependent Characteristics 

The services provided by the terminal driver are: 

1) Reading a character from the communications port 

2) Writing a character to the communications port 


F8.I Package TEXTJO 

The specification of package TEXT-IO: 


pragma page; 
with BASIC-IO; 

with IOJEXCEPTIONS; 
package TEXT-IO is 

type FILE-TYPE is limited private; 

type FILE-MODE is (IN—FILE, OUT-FILE) ; 

type COUNT is range 0 .. INTEGER'LAST; 

subtype POSITIVE-COUNT is COUNT range 1 .. COUNT'LAST; 

UNBOUNDED: constant COUNT:- 0; — line and page length 

— max. size of an integer output field 2#_# 

subtype FIELD is INTEGER range 0 .. 35; 

subtype NUMBER-BASE is INTEGER range 2 .. 16; 

type TYPE-SET is (LOWER-CASE, UPPER-CASE); 


183 




DACS 680x0 Bare Ada Cross Compiler System • User's Guide 
Implementation Dependent 


pragma PAGE; 

— File Management 
procedure CREATE (FILE : in 

MODE : in 

NAME : in 

FORM : in 

); 

procedure OPEN (FILE : in 
MODE : in 

NAME : in 

FORM : in 

); 

procedure CLOSE (FILE : in 
procedure DELETE (FILE : in 
procedure RESET (FILE : in 

MODE : in 

procedure RESET (FILE : in 

function MODE (FILE : in 
function NAME (FILE : in 
function FORM (FILE : in 

function IS_OPEN(FILE : in 

pragma PAGE; 

— control of default input 


out FILE-TYPE; 

FILE-MODE ;-OUT-FILE; 
STRING :-" M ; 

STRING :- MM 


out FILE-TYPE; 
FILE-MODE; 
STRING; 
STRING 


out FILE-TYPE); 
out FILE-TYPE); 
out FILE-TYPE; 

FILE-MODE); 
out FILE-TYPE); 

FILE-TYPE) return FILE-MODE; 
FILE-TYPE) return STRING; 
FILE-TYPE) return STRING; 

FILE-TYPE return BOOLEAN; 


and output files 


procedure SET-INPUT (FILE : in FILE-TYPE); 
procedure SET-OUTPUT (FILE : in FILE-TYPE); 


function STANDARD-INPUT return FILE-TYPE; 
function STANDARD-OUTPUT return FILE-TYPE; 


function CURRENT-INPUT 
function CURRENT-OUTPUT 
pragma PAGE; 

— specification of line and page lengths 


return FILE-TYPE; 
return FILE-TYPE; 


procedure SET-LINE-LENGTH 
procedure SET—LINE-LENGTH 


(FILE : in FILE-TYPE; 

TO : in COUNT); 

(TO : in COUNT); 


procedure SET-PAGE-LENGTH 
procedure SET-PAGE-LENGTH 


(FILE : in FILE-TYPE; 

TO ; in COUNT); 

(TO : in COUNT); 


function LINE-LENGTH 
function LINE-LENGTH 


(FILE : in FILE-TYPE) 
return COUNT; 
return COUNT; 


function PAGE-LENGTH 
function PAGE-LENGTH 


(FILE : in FILE-TYPE) 
return COUNT; 
return COUNT; 


184 




DACS 680x0 Bate Ada Cross Compiler System - User’s Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— Column, Line, and Page Control 

procedure NEW-LINE (FILE : in FILE-TYPE; 

SPACING : in POSITIVE-COUNT 1); 
procedure NEW-LINE (SPACING : in POSITIVE-COUNT 1); 

procedure SKIP-LINE (FILE : in FILE-TYPE; 

SPACING : in POSITIVE-COUNT 1); 

procedure SKIP-LINE (SPACING : in POSITIVE-COUNT 1); 

function END-OF-LINE (FILE : in FILE-TYPE) return BOOLEAN; 

function END-OF-LINE return BOOLEAN; 

procedure NEW-PAGE (FILE : in FILE-TYPE); 
procedure NEW-PAGE; 

procedure SKIP-PAGE (FILE : in FILE-TYPE); 
procedure SKIP-PAGE; 

function END_OF-PAGE (FILE : in FILE-TYPE) return BOOLEAN; 

function END-OF-PAGE return BOOLEAN; 

function END_OF-FILE (FILE : in FILE-TYPE) return BOOLEAN; 

function END-OF-FILE return BOOLEAN; 

procedure SET-COL (FILE : in FILE-TYPE; 

TO : in POSITIVE-COUNT); 
procedure SET-COL (TO : in POSITIVE-COUNT); 

procedure SET-LINE (FILE ; in FILE-TYPE; 

TO : in POSITIVE-COUNT); 

procedure SET-LINE (TO : in POSITIVE-COUNT); 

function COL (FILE : in FILE-TYPE) 

return POSITIVE-COUNT; 
function COL return POSITIVE-COUNT; 

function LINE (FILE : in FILE-TYPE) 

return POSITIVE-COUNT; 
function LINE return POSITIVE-COUNT; 

function PAGE 


function PAGE 


(FILE : in FILE-TYPE) 
return POSITIVE-COUNT; 
return POSITIVE-COUNT; 





DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— Character Input-Output 


procedure 

GET 

(FILE 

: in FILE-TYPE; 

ITEM : 

out 

CHARACTER) ; 

procedure 

GET 

( 




ITEM : 

out 

CHARACTER) ; 

procedure 

PUT 

(FILE 

: in FILE-TYPE; 

ITEM : 

in 

CHARACTER) ; 

procedure 

PUT 

( 




ITEM : 

in 

CHARACTER) ; 

— String 

Input-Output 






procedure 

GET 

(FILE 

: in FILE-TYPE; 

ITEM : 

out 

CHARACTER) ; 

procedure 

GET 

( 

. 



ITEM : 

out 

CHARACTER); 

procedure 

PUT 

(FILE 

: in FILE-TYPE; 

ITEM : 

in 

CHARACTER); 

procedure 

PUT 

( 




ITEM : 

in 

CHARACTER); 

procedure 

GET- 

.LINE 

(FILE 


in FILE. 

.TYPE; 






ITEM 


out STRING; 






LAST 


out NATURAL); 



procedure 

GET. 

.LINE 

(ITEM 

; 

out STRING; 






LAST 

: 

out NATURAL); 



procedure 

PUT. 

.LINE 

(FILE 


in FILE. 

-TYPE; 






ITEM 


in STRING); 



procedure 

PUT_LINE 

(ITEM 


in STRING); 










DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 

pragma PAGE; 

— Generic Package for Input-Output of Integer Types 
generic 

type NUM is range <>; 
package INTEGER-IO is 

DEFAULT-WIDTH : FIELD NUM'WIDTH; 

DEFAULT-BASE : NUMBER-BASE 10; 


procedure GET 

(FILE 


in FILE-TYPE; 


ITEM 


out NUM; 


WIDTH 


in FIELD :• 0); 

procedure GET 

(ITEM 


out NUM; 


WIDTH 


in FIELD 0) ; 

procedure PUT 

(FILE 


in FILE-TYPE; 


ITEM 


in NUM; 


WIDTH 


in FIELD DEFAULT-WIDTH; 


BASE 


in NUMBER-BASE DEFAULT-BASE) 

procedure PUT 

(ITEM 


in NUM; 


WIDTH 


in FIELD DEFAULT-WIDTH; 


BASE 


in NUMBER-BASE DEFAULT-BASE) 

procedure GET 

(FROM 


in STRING; 


ITEM 


out NUM; 


LAST 


out POSITIVE); 


procedure PUT (TO : out STRING; 

ITEM ; in NUM.- 

BASE : in NUMBER-BASE DEFAULT-BASE) ; 


end INTEGER_IO; 


187 








DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— Generic Packages for Input-Output of Real Types 
generic 

type NUM is digits <>; 
package FLQAT-IO is 

DEFAULT_FOR£ : FIELD 2; 

DEFAULT-AFT : FIELD NUM'DIGITS - 1; 

DEFAULT-EXP : FIELD 3; 

procedure GET (FILE : in FILE-TYPE; 

ITEM : out NUM; 

NIDTH : in FIELD :« 0); 

.procedure GET (ITEM : out NUM; 

NIDTH : in FIELD 0); 

procedure PUT (FILE ; in FILE-TYPE; 

ITEM : in NUM.- 

FORE ; in FIELD DEFAULT-FORE; 

AFT ; in FIELD :- DEFAULT-AFT; 

EXP ; in FIELD DEFAULT_EXP) ; 

procedure PUT (ITEM : in NUM.- 

FORE : in FIELD :« DEFAULT-FORE; 
AFT ; in FIELD :« DEFAULT-AFT; 

EXP ; in FIELD DEFAULT_EXP) ; 

procedure GET (FROM : in STRING; 

ITEM : out NUM.- 

LAST : out POSITIVE); 

procedure PUT (TO ; out STRING; 

ITEM : in NUM.- 

AFT ; in FIELD :- DEFAULT_AFT; 

EXP ; in FIELD DEFAULT_EXP); 

end FLOAT-IO; 


1SS 






DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
Implementation Dependent Characteristics 

pragma PAGE; 
generic 

type NUM is delta <>; 
package FIXED-IO is 

DEFAULT_FORE : FIELD NUM'FORE; 

DEFAULT_AFT ; FIELD NUM'AFT; 

DEFAULT_EXP : FIELD 0; 


procedure GET (FILE : in FILE-TYPE; 



ITEM : out NUM.- 
WIDTH ; in FIELD 0); 

procedure GST 

(ITEM : out NUM.- 
WIDTH : in FIELD 0); 

procedure PUT 

(FILE : in FILE-TYPE; 

ITEM : in NUM.- 

FORE ; in FIELD DEFAULT-FORE; 

AFT : in FIELD DEFAULT-AFT; 

EXP : in FIELD DEFAULT-EXP) ; 

procedure PUT 

(ITEM : in NUM.- 

FORE : in FIELD DEFAULT-FORE; 

AFT : in FIELD DEFAULT-AFT; 

EXP : in FIELD DEFAULT-EXP) ; 

procedure GET 

(FROM : in STRING; 

ITEM ; out NUM.- 
LAST ; out POSITIVE); 

procedure PUT 

(TO ; out STRING; 

ITEM : in NUM.- 

AFT ; in FIELD :- DEFAULT-AFT; 

EXP : in FIELD DEFAULT-EXP); 


end FIXED-IO; 






DACS 680x0 Bare Ada Cross Compiler System • User's Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— Generic Package for Input-Output of Enumeration Types 
generic 

type ENUM is (<>); 
package ENUMERATION-10 is 


DEFAULT-MIDTH : FIELD 0; 

DEFAULT-SETTING : TYPE-SET UPPER-CASE; 


procedure 

GET 

(FILE : 

in FILE-TYPE; 

ITEM : out ENUM); 

procedure 

GET 

( 



ITEM : out ENUM); 

procedure 

PUT 

(FILE 

FILE-TYPE; 




ITEM 

in 

ENUM; 




WIDTH 

in 

FIELD 

DEFAULT-WIDTH; 



SET 

in 

TYPE-SET 

DEFAULT-SETTING); 

procedure 

PUT 

(ITEM 

in 

ENUM; 




WIDTH 

in 

FIELD 

DEFAULT-WIDTH; 



SET 

in 

TYPE-SET 

DEFAULT-SETTING); 

procedure 

GET 

(FROM : 

in 

STRING; 




ITEM : 

out 

ENUM; 




LAST : 

out 

POSITIVE) 

0 

procedure 

PUT 

(TO : 

out 

STRING; 




ITEM : 

in 

ENUM; 




SET ; 

in 

TYPE-SET 

DEFAULT-SETTING); 


end ENUMERATION-IO; 


pragma PAGE; 

— Exceptions 


STATUS-ERROR 

: exception 

renames 

MODE-ERROR 

: exception 

renames 

NAME-ERROR 

: exception 

renames 

USE-ERROR 

: exception 

renames 

DEVICE-ERROR 

: exception 

renames 

END-ERROR 

: exception 

renames 

DATA-ERROR 

: exception 

renames 

LAYOUT-ERROR 

: exception 

renames 


IO_EXCEPTIONS.STATUS-ERROR; 
IO-EXCEPTIONS.MODE-ERROR; 
IO-EXCEPTIONS.NAME-ERROR; 
IO_EXCEPTIONS.USE-ERROR; 
IO-EXCEPTIONS.DEVICE-ERROR; 
IO-EXCEPTIONS.END-ERROR; 
IO-EXCEPTIONS.DATA-ERROR; 
IO-EXCEPTIONS.LAYOUT-ERROR; 


pragma page; 
private 


type FILE-TYPE is 
record 

FT : INTEGER -1; 
end record; 


end TEXT-IO; 


1 , 







DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 

f&2 Package IO-EXCEPTIONS 

The specification of the package IO-EXCEPTIONS: 


package IO-EXCEPTIONS is 

STATUS-ERROR : exception; 
MODE-ERROR : exception; 
NAME-ERROR : exception; 
USE-ERROR : exception; 
DEVICE-ERROR : exception; 
END-ERROR : exception; 
DATA-ERROR ; exception; 
LAYOUT-ERROR : exception; 

end IO-EXCEPTIONS; 


F&3 Package BASIC-IO 

The specification of package BASIC-IO: 


with IO-EXCEPTIONS; 
package BASIC-IO is 

type count is range 0 .. integer'last; 

subtype positive-count is count range 1 .. count'last; 


function get-integer return string; 

— Skips any leading blanks, line terminators or page terminators. 

— Then reads a plus or a minus sign if present, then reads according 

— to the syntax of an integer literal, which may be based. 

— Stores in item a string containing an optional sign and an integer 

— litteral. 

— The exception DATA-ERROR is raised if the sequence ofcharacters does 

— not correspond to the syntax described above. 

— The exception END-ERROR is raised if the file terminator is read. 

— (This means that the starting sequence of an integer has not been met) 

— Note that the character terminating the operation must be available 

— for the next get operation. 


191 




DACS 690x0 Bait Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 


function get-real return string; 

— Corresponds to get-integer except that it reads according to the 

— syntax of a real literal, which may be based. 

function get-enumeration return string; 

— Corresponds to get-integer except that it reads according to the 

— syntax of an identifier, where upper and lower case letters are 

— equivalent to a character literal including the apostrophes. 

function get-item(length : in integer).return string; 

-- Reads a string from the current line and stores it in item; 

~ If the remaining number of characters on the current line is 

— less than length then only these characters are returned. 

— The line terminator is not skipped. 

procedure put_item(item : in string); 

-- If the length of the string is greater than the current maximum line 

— linelength the exception LAYOUT-ERROR is raised. 

— If the string does not fit on the current line a line terminator is 

— output. Then the item is output. 


— Line and page lengths - ARM 14.3.3. 


procedure set-line-length(to : in count); 

procedure set-page-length(to : in count); 

function line-length return count; 
function page-length return count; 

— Operations on columns, lines and pages - ARM 14.3.4. 


procedure new-line; 


procedure skip-line; 


function end-of-line return boolean; 


procedure new_page; 


procedure skip-page; 


192 





DACS 680x0 Bw Ada Cross Compiler System - User’s Guide 
Implementation Dependent Characteristics 

function end-of.page return boolean; 

function end.of.file return boolean; 

procedure set-col(to : in positive-count); 
procedure set-line(to : in positive-count); 
function col return positive-count; 
function line return positive-count; 
function page return positive-count; 

— Character and string procedures. 

— Corresponds to the procedures defined in ARM 14.3.6. 
procedure get-character(item : out character); 

procedure get-string(item : out string); 

procedure get-line (item : out string; 

last : out natural); 

procedure put-character(item : in character); 
procedure put-string(item : in string); 
procedure put-line(item : in string); 

— exceptions: 

USE-ERROR : exception renames XO-EXCEPTIONS.USE-ERROR; 
DEVICE-ERROR : exception renames IO-EXCEPTIONS.DEVICE-ERROR; 
END-ERROR : exception renames IO-EXCEPTIONS.END-ERROR; 
DATA-ERROR : exception renames IO-EXCEPTIONS.DATA-ERROR; 
LAYOUT-ERROR : exception renames IO-EXCEPTIONS.LAYOUT-ERROR; 

end BASIC—10; 


193 







DACS 680*0 Bare Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 

IB.4 Package TERMINAL-DRIVER 

The spedficatioa of package TERMINAL-DRIVER: 


package terminal-driver is 

procedure put-character(ch : character); 
procedure flush; 

function get-character return character; 
procedure purge; 
private 

pragma interface (AS, put-character); 

pragma interface-spelling(put-character, M Ada_UCC_G$PutByte"); 
pragma interface (AS, get-character); 

pragma interface-spelling(get-character, M Ada_UCC_G$GetByte H ); 
pragma interface (AS, flush); 

pragma interface-spelling(flush, "Ada-UCC-GSFlushOutput"); 
pragma interface (AS, purge); 

pragma interface-spelling(purge, "Ada_UCC_G$Purgelnput"); 

pragma initialize("Ada_UCC_G$InitI0 M ); 
pragma rundown ("Ada-UCC-GSCloselO"); 

end terminal-driver; 


F8J5 Package SEQUENTIAL-JO 

As files are not supported, the subprograms in this package will raise USE-ERROR or 
STATUS-ERROR. The specification of package SEQUENTIAL-IO: 

— Source code for SEQUENTIAL-IO 

pragma PAGE; 

with IO-EXCEPTIONS; 

generic 

type ELEMENT-TYPE is private; 


194 




DAGS 680x0 Bare Ada Cross Compiler System - User's Guide 
Implementation Dependent Characteristics 


package SEQUENTXAL-io is 

type FILE-TYPE is limited private; 
type FILE-MODE is (IN-FILE, OUT -FILE) ; 


pragma PAGE; 

— rile management 

procedure CREATE(FILE : in out FILE-TYPE; 

MODE : in FILE-MODE 

NAME : in STRING 

FORM : in STRING 

procedure OPEN (FILE : in out FILE-TYPE; 

MODE : in FILE-MODE; 

NAME : in STRING; 

FORM : in STRING —) ; 

procedure CLOSE (FILE : in out FILE-TYPE); 

procedure DELETE(FILE : in out FILE-TYPE); 

procedure RESET (FILE : in out FILE-TYPE; 

MODE : in FILE-MODE); 

procedure RESET (FILE : in out FILE-TYPE); 

function MODE (FILE : in FILE-TYPE) return FILE-MODE; 

function NAME (FILE : in FILE-TYPE) return STRING; 

function FORM (FILE : in FILE-TYPE) return STRING; 

function IS-OPEN(FILE : in FILE-TYPE) return BOOLEAN; 


pragma PAGE; 

— input and output operations 

procedure READ (FILE : in FILE-TYPE; 

ITEM : out ELEMENT-TYPE); 

procedure WRITE (FILE : in FILE-TYPE; 

ITEM : in ELEMENT-TYPE) ; 

function END-OF-FILE(FILE : in FILE-TYPE) return BOOLEAN; 


- OUT-FILE; 

m Nn , 

- 


195 






DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
Implementation Dependent Characteristics 


pragma PAGE; 
— exceptions 


STATUS-ERROR 
MODE-ERROR 
NAME-ERROR 
USE-ERROR 
DEVICE-ERROR 
END-ERROR 
DATA-ERROR 

pragma PAGE; 
private 

type FILE-TYPE is new INTEGER; 
end SEQUENTIAL-IO; 


F&6 Package DIRECT-IO 

As files are not supported, the subprograms in this package will raise USE-ERROR or 
STATUS-ERROR. The specification of package DIRECT-IO: 


pragma PAGE; 
with IO-EXCEPTIONS; 

generic 

type ELEMENT-TYPE is private; 
package DIRECT-IO is 


type FILE-TYPE is limited private; 

type FILE-MODE is (IN-FILE, INOUT-FILE, OUT-FILE); 

type COUNT is range 0..2-147-483-647; 

subtype POSITIVE-COUNT is COUNT range 1..COUNT'LAST; 


: exception renames IO-EXCEPTIONS.STATUS-ERROR; 
: exception renames IO_EXCEPTIONS.MODE-ERROR; 

: exception renames IO-EXCEPTIONS.NAME—ERROR; 

: exception renames IO-EXCEPTIONS.USE-ERROR; 

: exception renames IO-EXCEPTIONS.DEVICE-ERROR; 
: exception renames IO-EXCEPTIONS.END-ERROR; 

; exception renames IO-EXCEPTIONS.DATA-ERROR; 


196 






DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— File management 


procedure CREATE 

(FILE 

: 

in 

out 

FILE-TYPE; 



MODE 

; 

in 


FILE-MODE 

INOUT-FILE; 


NAME 

: 

in 


STRING 

nn i 

9 


FORM 

; 

in 


STRING :■ 

""); 

procedure OPEN 

(FILE 

: 

in 

out 

FILE-TYPE; 



MODE 

: 

in 


FILE-MODE; 



NAME 

: 

in 


STRING; 



FORM 

• 

in 


STRING :« * 

"); 

procedure CLOSE 

(FILE 

: 

in 

out 

FILE-TYPE); 


procedure DELETE(FILE 

: 

in 

out 

FILE-TYPE); 


procedure RESET 

(FILE 


in 

out 

FILE-TYPE; 



MODE 

: 

in 


FILE-MODE); 


procedure RESET 

(FILE 


in 

out 

FILE-TYPE); 


function MODE 

(FILE 

• 

• 

in 

FILE-TYPE) return 

FILE-MODE; 

function NAME 

(FILE 

• 

in 

FILE-TYPE) return 

STRING; 

function FORM 

(FILE 

: 

in 

FILE-TYPE) return 

STRING; 


function IS_OPEN(FILE : in FILE-TYPE) return BOOLEAN; 


197 







DACS 680x0 Bare Ada Cross Compiler System * User’s Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— input and output operations 


procedure READ (FILE : in FILE-TYPE; 

ITEM : out ELEMENT-TYPE; 

FROM : in POSITIVE-COUNT); 

procedure READ (FILE : in FILE-TYPE; 

ITEM : out ELEMENT-TYPE); 

procedure WRITE (FILE : in FILE-TYPE; 

ITEM : in ELEMENT-TYPE; 

TO ; in POSITIVE-COUNT); 
procedure WRITE (FILE : in FILE-TYPE; 

ITEM : in ELEMENT-TYPE); 

procedure SET-INDEX(FILE : in FILE-TYPE; 

TO : in POSITIVE-COUNT); 

function INDEX(FILE : in FILE-TYPE) return POSITIVE-COUNT; 
function SIZE (FILE : in FILE-TYPE) return COUNT; 
function END-OF-FILE(FILE ; in FILE-TYPE) return BOOLEAN; 


pragma PAGE; 
— exceptions 


STATUS-ERROR : exception renames IO-EXCEPTIONS.STATUS-ERROR; 

MODE-ERROR : exception renames IO-EXCEPTIONS. MODE-ERROR; 

NAME-ERROR : exception renames IO-EXCEPTIONS.NAME-ERROR; 

USE-ERROR : exception renames IO-EXCEPTIONS.USE-ERROR; 

DEVICE-ERROR : exception renames IO-EXCEPTIONS.DEVICE-ERROR; 

END-ERROR : exception renames IO-EXCEPTIONS.END-ERROR; 

DATA-ERROR : exception renames IO-EXCEPTIONS.DATA-ERROR; 

pragma PAGE; 
private 

type FILE-TYPE is new INTEGER; 
end DIRECT-IO; 


F.9 Package CALENDAR 

Package CALENDAR is as defined in [DoD-83] section 9.6, except for a new procedure 
SET-TIME, which has been added to the package. SET-TIME allows setting of TIME for the 
duration of the executing program. SET-TIME parameters follow the same conventions as the 
parameters for SPLIT. The specification of package CALENDAR: 


198 







DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
Implementation Dependent Characteristics 


PRAGMA PAGE; 

PACKAGE calendar IS 

TYPE Tine IS PRIVATE; 


SUBTYPE Year-number IS Integer RANGE 1901..2099; 
SUBTYPE Month-number IS Integer RANGE 1..12; 

SUBTYPE Day-number IS Integer RANGE 1..31; 

SUBTYPE Day-duration IS Duration RANGE 0.0..86-400.0; 

FUNCTION clock RETURN Time; 


FUNCTION year(date: Time) RETURN Year-number; 
FUNCTION month(date: Time) RETURN Month-number; 
FUNCTION day(date: Time) RETURN Day-number; 
FUNCTION seconds(date: Time) RETURN Day-duration; 

PROCEDURE split(date: IN Time; 

year: OUT Year-number; 
month: OUT Month-number; 
day: OUT Day-number; 
seconds: OUT Day-duration); 


FUNCTION time-of (yeas: Year-number; 

month: Month-number; 
day: Day-number; 

seconds: Day-duration 0.0) RETURN Time; 


FUNCTION "+" 
FUNCTION "+" 
FUNCTION 
FUNCTION 


(left: Time; 

right: Duration) RETURN Time; 
(left: Duration; 
right: Time) RETURN Time; 
(left: Time; 

right: Duration) RETURN Time; 
(left: Time; 

right: Time) RETURN Duration; 


FUNCTION "<" (left,right: Time) RETURN Boolean; 
FUNCTION (left,right: Time) RETURN Boolean; 

FUNCTION ">" (left,right: Time) RETURN Boolean; 
FUNCTION ">«" (left,right: Time) RETURN Boolean; 


PROCEDURE set-time (year 

month 

day 

seconds 


IN Year-number; 

IN Month-number; 
IN Day-number; 

IN Day-duration) ; 


TIME-ERROR: Exception; 


— ...can be raised by 

— time-of , "+" and 


PRIVATE 
END calendar; 


199 








DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
Implementation Dependent Characteristics 


F.10 Machine Code Insertions 

Machine code insertions are allowed using the instructions defined in package MACHINE-CODE. 
All arguments given in the code statement aggregate must be static. 

The machine language defined in package MACHINE-CODE is not 680x0 assembler, but rather 
Abstract A-code which is an intermediate language used by the compiler. 


200 





