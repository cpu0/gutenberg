Put>iic reponmg burden 
nMO 0 d. and revt«w(ng 
MMdQuan*rs S«<vc«. ^ 
Management and Budg 

1 AGENCY use 


pcDriDT nnr'i iaacMTAxir\|yj p/^Qg 

1J»0 I a iHa 5i II uehng ih« lim» lot ttviewt 

mg nyoinwuocctolm*co 


form Approved 
OPM No. 0704-018S 


uctmg ih« lima Iw lavtawing iiwinjciiona saaictimg axmng dala lourcat gaiharing and mamiairang iha data 
ny oina< asgaa ol m* cotactbn ol intormation. including suggaaiiona lor raducing thia burdan. to Waanmgun 
ay. Suaa 1204. Arlinglon. VA 22202-4302. and to ttia Ollica ot Intormation and Ragulalory Allan. Ollica ol 

3. REPORT Pl'PE AND DATES COVERED 

Final; 28 Jun 1991 to 01 Jun 1993 


4 TITLE AND SUBTITLE 

Ada Compiler Validation Summary Report: Alsys,, AlsyCOMP_057. Version 1.83, 
DECstation 3100 under ULTRIX Version 4.,0 (Host & Target), 91062511.11193 

6 AUTHOR(S) 

lABG-AVF 

Ottobrunn, Fedetal Republic of Germany 

7 PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

IABG-AVF, Industrieanlagen-Betriebsgeselschaft 
Dept. S2T/ Einsteinstrasse 20 
D-8012 Ottobrunn 

FEDERAL REPUBLIC OF GERMANY 

9 SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm 3E114 
Washington, D C. 20301-3081 


I 5. FUNDING NUMBERS 


11 SUPPLEMENTARY NOTES 

^- '3 (. f L L'-.Y I -L. - t '■ ^ 

12a DISTRIBUTION/AVAILABILITY STATEMENT 

Approved for public release: distribution unlimited. 


8. PERFORMING ORGANIZATION 
REPORT NUMBER 

lABG-VSR 097 


10 SPONSORING/MONITORING AGENCY 
REPORT NUMBER 


•; K L iJ I- A (■ < V \ j_> H C . I 1.' Cl 


12b DISTRIBUTION CODE 


13 ABSTRACT (Maximum 200 words) 

Alsys,, AlsyCOMP_057, Version 1 83. Ottobrunn, Germany, DECstation 3100 under ULTRIX Version 4.0 (Host & Target), 
ACVC 1.11. 


^ ’ll I 



.NOV 0 81991 


W t 



91-15333 


lillilH 


14 SUBJECT TERMS 


Ada programming language, Ada Compiler Val Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val Office, Ada Val Facility, ANSI/MIL-STD-1815A, AJPO. 


17 SECURITY CLASSIFICATION 
OF REPORT 

UNCLASSIFIED _ 

NSN 7540-01-280-550 


18 SECURITY CLASSIFICATION 


UNCLASSIFED 


19 SECURITY CLASSIFICATION 
OF ABSTRACT 

UNCLASSIFIED 


91 1108 062 


15 NUMBER OF PAGES 


16 PRICE CODE 


1 20 LIMITATION OF ABSTRACT 


Standard Form 298, (Rev 2-89) 
Prescribed by ANSI Std 239-128 













Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on 91-06-25. 


Compiler Hame and Version: 
Host Computer System: 
Target Computer System: 


AlsyCOMP_057 Version 1.83 

DECstation 3100 under ULTRIX Version 4.0 

same as Host 


See Section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
I910625I1.11193 is awarded to Alsys. This certificate 
expires on 01 March 1993. 

This report has been reviewed and is approved. 




lABG, Abt. ITE 
Michael Tonndorf 
Einsteinstr. 20 
W-8012 Ottobrunn 


Germany 



Ada Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 


Acces.slon For 

hm, - 






AVF Control Number: lABG-VSR 097 
28 June 1991 


Ada COMPILER 

VALIDATION SUMMARY REPORT: 
Certificate Number: 91062511.11193 
Alsys 

Al3yCOMP_057 Version 1.83 
DECstation 3100 under ULTRIX Version 4.0 
Host and Target 


== based on TEMPLATE Version 91-05-08 == 


Prepared By: 
lABG mbH, Abt. ITE 
Einsteinstr. 20 
W-8012 Ottobrunn 
Germany 






Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on 91-06-25. 


Compiler Name and Version: AlsyCOMP_057 Version 1.83 

Host Computer System: DECstation 3100 under ULTRIX Version 4.0 

Target Con^juter System: same as Host 


See Section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
#91062511.11193 is awarded to Alsys. This certificate 
expires on 01 March 1993. 

This report has been reviewed and is approved. 




lABG, Abt. ITE 



Michael Tonndorf 
Einsteinstr. 20 
W-8012 Ottobrunn 



Ada Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 




DECLARATIOK OF CONFORMANCE 



(*j (>> c») r j hj r.> 


TABLE OF CONTENTS 

SHAFTER 1 INTRODUCTION 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1- 

1.2 ACVC TEST CLASSES.1- 

1.4 DEFINITION OF TERMS.1- 

::-:a?ter 2 implementation dependencies 

.1 withdrawn tests.2- 

.2 INA^ILICABLE TESTS . 2- 

.3 TEST MODIFICATIONS.2- 

PROCESSING INFORMATION 

.1 TESTING ENVIRONMENT . 3- 

.2 SUMMARY OF TEST RESULTS.3- 

.3 TEST EXECUTION. 3- 

.-••.rFENDIX A MACRO PARAMETERS 

AF FENDIX 3 COMPIL.ATION SYSTEM OPTIONS 

AFFEN'DIX C APPENDIX F OF THE Ada STANDARD 


CJ fvl CO r-H f-H ^ iH .H r-J 
















CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the Ada 
Validation Procedures (Pro90] against the Ada Standard [Ada83] using the 
current Ada Compiler Validation Capability (ACVC). This Validation Summary 
Report (VSR) gives an account of the testing of this Ada implementation. 

For any technical terms used in this report, the reader is referred to 
;?ro5C' . A detailed description of the ACVC may be found in the current 
•R- v’C w ser ^ s Gurde [UG8 9 ] . 


1.1 USE CF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the computers, operating system.s, and compiler versions identified 
on this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject implementation has no 
nonconfcrm.ities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from; 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

luestions regarding this report or the validation test results should be 
oireoted to the AVF which performed this validation or to: 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

18C1 North Beauregard Street 

Alexandria VA 22311-1772 





rr *^0 


INTRODUCTION 


: .2 REFERENCES 

;Ada9 3; Reference Manual for the Ada Programir.ina Language , 

A-NSI '.MIL-STD-ISISA, February 1983 and ISO 8652-1987. 

;?rc92; Ada Ccnoiler Validation Procedures . Version 2.1, Ada Jcint 
Frograc’. C'^'*^ice, August 1990. 


;V3£9’ .Ada Ccr.ciler Validation Capability User's Guide, 21 June 158 9. 


1.3 ACVC TEST CLASSES 

Ccrr.pliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: 

.A, 5, C, D, E, and L. The first letter of a test name identifies the class 
to which it belongs. Class A, C, D, and E tests are executable. Class B 
and class L tests are expected to produce errors at compile time and link 
tome, respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CKECK_FILE are used for this purpose. The package REPORT 
also provides a set of identity functions used to defeat some compiler 
timizations allowed by the Ada Standard that would circumvent a test 
jective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of 
text files written by some of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is comipiled and the 
resulting compilation listing is examined to verify that all violations of 
t.te -Ada Standard are detected. Some of the class B tests contain legal .Ada 
cede which must not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementaticn-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required tc rem.cve unforeseen conflicts between the tests and 
implementation-dependent c.haracteristics. The modifications required for 
this im.ple.mentation are described in section 2.3. 


-3 




fo o 


INTRODUCTION 


For each Ada implementation, a cuctomized test suite is produced by the 
kVF. This customization consists of making the modifications described 
in the preceding paragraph, removing withdrawn tests (see section 2.1) and, 
possibly some inapplicable tests (see Section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 

.Ada Compiler The software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compiler The means for testing compliance of Ada implementations. 
Validation consisting of the test suite, the support programs, the ACVC 

Capability user's guide and the template for the validation summary 

(ACVC) report. 

•Ada An Ada compiler with its host computer system and its 

Implementation target computer system. 

Ada Joint The part of the certification body which provides policy and 

Program guidance for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification body which carries out the 

Validation procedures required to establish the compliance of an Ada 

Facility (AVF) im.plementation. 

Ads 

Validation 
Organization 
{AVC) 

Compliance of The ability of the implementation to pass an ACVC version, 
an Ada 

Im.plementation 

om.puter 
'/stem 


A functional unit, consisting of one or more computers and 
associated software, that uses common storage for all or 
part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; perform.s 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected units. 


The part of the certification body that provides technical 
guidance for operations of the Ada certification system. 


1-4 






t 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 

ISO 

LRM 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


INTRODUCTION 


Fulfillment by a product, process or service of all 
requirements specified. 

An individual or corporate entity who enters into an 
agreement with an AVF which specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

International Organization for Standardization. 

The Ada standard, or Language Reference Manual, published as 
ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. Citations from 
the LRM take the form "<section>.<subsection>:<paragraph>." 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial 
or complete hardware implementations are possible. 

A computer system where the executable form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 

An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro90]. 

The process of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-5 




> 


CHAPTER 2 

IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for 


withdrawing 

each test is 

available 

from either 

the AVO or 

the AVF. ' 

publication 

date for thi 

s list of 

withdrawn tests is 3 May 

1991. 

E28005C 

B28006C 

C34006D 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

6490083 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

C83026A 

B83026B 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

. CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7 0 0 6E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

3D80C2A 

' BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 




2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevan 
for a given Ada implementation. Reasons for a test's inapplicability may 
be supported by documents issued by the ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
i.m.ple.mentation, the following tests were determined to be inapplicable fo 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 





> 


IMPLEMENTATION DEPENDENCIES 


The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 


C24113L. 

. Y 

(14 

tests) (*) 

C35705L. 

. Y 

(14 

tests) 

C35706L. 

. Y 

(14 

tests) 

C35707L. 

. Y 

(14 

tests) 

C35708L. 

. Y 

(14 

tests) 

C35802L. 

.Z 

(15 

tests) 

C45241L. 

. y 

(14 

tests) 

C45321L. 

. Y 

(14 

tests) 

C45421L. 

_ V 

(14 

tests) 

C45521L. 

. Z 

(15 

tests) 

C45524L. 

. Z 

(15 

tests) 

C45621L. 

. Z 

(15 

tests) 

C45641L. 

. Y 

(14 

tests) 

C46012L. 

. z 

(15 

tests) 


(*) C24113W..Y (3 tests) contain lines of length greater than 255 
characters which are not supported oy this implementation. 


The following 20 tests chec)c for the predefined type LONG_INTEGER; for 
this implementation, there is no such type: 


C35404C 

C45502C 

C45613C 

C55B07A 


C45231C 

C45503C 

C45614C 

B55B09C 


C45304C 

45504C 

C45631C 

B86001W 


C45411C 

C45504F 

C45632C 

C86006C 


C45412C 

C45611C 

B52004D 

CD7101F 


C35713B, C45423B, B86001T, and C86006H check for the predefined type 

SKORT_FLOAT; for this implementation, there is no such type. 

C35713D and 366001Z check for a predefined floating-point type with a 
name other than FLOAT, LONG_FLOAT, or SHORT_FLOAT; for this 
implem.entation, there is no such type. 

C41401A checks that CONSTRAINT_ERROR is raised upon the evaluation of 
various attribute prefixes; this implementation derives the attribute 
values from the subtype of the prefix at compilation time, and thus does 
not evaluate the prefix or raise the exception. (See Section 2.3.) 

C45531M..P and C45532M..P (8 tests) check fixed-point operations for 
types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for this 
implementation, MAX_.MANTISSA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 

MACHINE_CVERFLOWS is FALSE for floating point types and the results of 
various floating-point operations lie outside the range of the base 
’■ype; for this implementation, MACHINE_0'^RFLOWS is TRUE. 

B86001Y uses the name of a predefined fixed-point type other than type 
DURATION; for this implementation, there is no such cype. 

C96005B uses values of type DURATION'S base type that are outside the 
range of type DURATION; for this implementation, the ranges are the 
same . 

CD1009C checks whether a length clause can specify a non-default size 
fcr a floating-point type; this implementation does not support such 
sizes . 


2-2 








IMPLEMENTATION DEPENDENCIES 


CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length clauses 
to specify non-default sizes for access types; this implementation 
does not support such sizes. 

CD2B15B checks that STORAGE_ERROR is raised when the storage size 
specified for a collection is too small to hold a single value of the 
designated type; this implementation allocates more space than was 
specified by the length clause, as allowed by AI-00558. 

BD8001A, 3D80C3A, BD8004A..B (2 tests), and AD8011A use machine code 
insertions; this implementation provides no package MACHINE_CODE. 

The tests listed in the following table check that USE_ERROR is raised 
if the given file operations are not supported for the given 
combination of mode and access method; this implementation supports 
these operations. 


Test 

File Operation Mode 

File Access Method 

CE21C2D 

CREATE 

IN FILE 

SEQUENTIAL 10 

CE21C2E 

CREATE 

OUT FILE 

SEQUENTIAL 10 

CE21C2F 

CREATE 

INOUT FILE 

DIRECT 10 

CE21C2I 

CREATE 

IN FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE2102O 

RESET 

IN_FILE 

SEQUENTIAL_IO 

CE2102? 

OPEN 

OUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE21C2S 

■reset 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE21C2V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

OUT FILE 

DIRECT 10 

CE3102E 

CREATE 

IN FILE 

TEXT 10 

CE3102F 

RESET 

Any Mode 

TEXT 10 

CE3102G 

DELETE 


TEXT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT 10 

CE3102J 

OPEN 

IN FILE 

TEXT 10 

CE3102K 

OPEN 

OUT FILE 

TEXT 10 


CE2107C..D (2 tests), CE2107H, and CE2107L apply function NAME to 
temporary sequential, direct, and text files in an attempt to 
associate multiple internal files with the same external file; 
'JSE_ERROR is raised because temporary files have no name. 

CE2108B, CE2108D, and CE3112B use the names of temporary sequential, 
direct, and text files that were created in other tests in order to 
check that the temporary files are not accessible after the completion 
of those tests; for this implementation, temporary files have no name. 

CE2203A checks that WRITE raises USE_ERROR if the capacity of an 
external sequential file is exceeded; this implementation cannot 
restrict file capacity. 


2-3 









IMPLEMENTATION DEPENDENCIES 


EE2401D uses instantiations of DIRECT_IO with unconstrained array and 
record types; this implementation raises USE_ERROR on the attempt to 
create a file of such types. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of an 

external direct file is exceeded; this implementation cannot restrict 
file capacity. 

CE3111B and CE3115A associate multiple internal text files with the 
same external file and attempt to read from one file what was written 
to the other, which is assumed to be immediately available; this 

implementation buffers output. (See section 2.3.) 

CE32C2A expects that function NAME can be applied to the standard 
input and output files; in this implementation these files have no 
names, and USE_ERROR is raised. (See section 2.3.) 

CE3304A checks that SET_LINE_LENGTH and SET_PAGE_LENGTH raise 
USE_EFiRCR if they specify an inappropriate value for the external 

file; there are no inappropriate values for this implementation. 

CE3413B checks that PAGE raises LAy0UT_ERR0R when the value of the 

page number exceeds COUNT'LAST; for this implementation, the value of 
COUNT'LAST is greater than 150000, making the checking of this 
objective impractical. 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 23 tests. 

The following tests were split into two or more tests because this 
imple.mentation did not report the violations of the Ada Standard in the 
way expected by the original tests. 

B22003A B24009A B29001A B38003A B38009A B38009B 

391CC1H BC2001D BC2001E BC3204B BC3205B BC3205D 

C34007P and C34007S were graded passed by Evaluation Modification as 
directed by the AVO. These tests include a check that the evaluation of 
the selector "all" raises CONSTRAINT_ERROR when the value of the object is 
null. This implementation determines the result of the eqpjality tests at 
lines 207 and 223, respectively, based on the subtype of the object; thus, 
the selector is not evaluated and no exception is raised, as allowed by LRM 
11.6(7). The tests were graded passed given that their only output from 
Report.Failed was the message "NO EXCEPTION FOR NULL.ALL - 2". 

C41401A was graded inapplicable by Evaluation Modification as directed by 
t.he AVO. This test checks that the evaluation of attribute prefixes that 
denote variables of an access type raises CONSTRAINT_ERROR when the value 
of the variable is null and the attribute is appropriate for an array or 
task type. This implementation derives the array attribute values from the 
subtype; thus, the prefix is not evaluated and no exception is raised, as 
allowed by LP1< 11.6(7), for the checks at lines 77, 87, 97, 108, 121, 131, 
141, 152, 165, & 175. 


2-4 





IMPLEMENTATION DEPENDENCIES 




C64103A was graded passed by evaluation modification as directed by the 
AVO. This implementation optimizes the code at compile time on lines 91 
and 119, thus avoiding the operation which would raise CONSTRAINT_ERROR. 

The following REPORT.FAILED mesages were produced by this test 

EXCEPTION NOT RAISED BEFORE CALL -P2 (A) 

EXCEPTION NOT RAISED BEFORE CALL -P3 (A) 

The AVO ruled that this is acceptable behavior. 

3C3204C..D and BC3205C..D (4 tests) were graded passed by Evaluation 
Modification as directed by the AVO. These tests are expected to produce 
compilation errors, but this implementation compiles the units without 
error; all errors are detected at lin)c time. This behavior is allowed by 
AI-00256, as the units are illegal only with respect to units that they do 
not depe.nd on. 

CE3111B and CE3115A were graded inapplicable by Evaluation Modification 
as directed by the AVO. The tests assume that output from one internal 

file is unbuffered and may be immediately read by another file that 

shares the same external file. This implementation raises END_ERROR on 
the attempts to read at lines 87 and 101, respectively. 

CE3202A was graded inapplicable by Evaluation Modification as directed by 
the AVO. This test applies function NAME to the standard input file, which 
in this implementation has no name; USE_ERROR is raised but not handled, so 
the test is aborted. The AVO ruled that this behavior is acceptable 
pending any resolution of the issue by the ARC. 


2-5 





CHAPTER 3 


PROCESSING INFORMATION 


TESTING ENVIRONMENT 


The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact in Germany for technical and sales information about 
this Ada implementation system, see: 

Alsys GmbH & Co. KG 
Am Riippurrer Schlofi 7 
W-7500 Karlsruhe 51 
Germany 

Tel. +49 721 883025 

For a point of contact outside Germany fcr technical and sales information 
about this Ada im.plementation system, see; 

Alsys Inc. 

67 South Bedford Str. 

Burlington MA 

01803-5152 

USA 

Tel. +617 270 0030 

Testing of this Ada implementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Im^plementation passes a given ACVC version if it processes each test 
of the custom.ized test suite in accordance with the Ada Programming 
Language Standard, whether the test is applicable or inapplicable; 
ctherwise, the Ada Implementation fails the ACVC [Pro90]. 

~:r all processed tests (inapplicable and applicable), a result was 
retained that conforms to the Ada Programming Language Standard. 

Tne list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were withdrawn 
necause of test errors (item b; see section 2.1), those that require a 


3-1 




PROCESSING INFORMATION 


floating-point precision that exceeds the implementation's maximum 
precision (item e; see section 2.2), and those that depend on t.he support 
of a file system. -- if none is supported (item d). All tests passed, 
except those that are listed in sections 2.1 and 2.2 (counted in items b 
and f, below). 


a) Total Number of Applicable Tests 3788 

b) Total Number of Withdrawn Tests 94 

c) Processed Inapplicable Tests 87 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 201 

f) Total Number of Inapplicable Tests 288 (c+d+e) 

g) Total Number of Tests for ACVC 1.11 4170 (a+b+f) 


3.3 TEST EXECUTION 

A Magnetic Data Cartridge containing the customized test suite (see section 
1.3) was ta)cen on-site by the validation team for processing. The contents 
of the tape were loaded to a Sun 3/60 computer, from there they were copied 
t.he host computer using the "remote copy"-facility of Unix. 

■After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada implementation. 

Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a complete listing of 
the processing options for this implementation. It also indicates the 
default options. 

Tests were compiled using the command 

ada.c 'file name' 

and linked using the command 

ada.link -o 'file name' 'main unit'. 

The option -o was used to assign a dedicated file name to the generated 
executable image. 

Chapter B tests, the executable not applicable tests, and the executable 
tests of class E were compiled using the full listing option -1. For 
several tests, completer listings were added and concatenated using the 
option -1 'file name'. The completer is described in Appendix B, 
oorr.pilaticr. system, options, chapter 4.2 of the User Manual on page 39. 

Test output, compiler and lin)cer listings, and job logs were captured on a 
Magnetic Data Cartridge and archived at the AVF. The listings examined on- 
■site by the validation team were also archived. 


3-2 






APPENDIX A 


MACRO PARAMETERS 

Tr.is appendix contains the macro parameters used for custom.izing the ACVC. 
Tr.e meaning and purpose of these parameters are explained in [UG69]. The 
parameter values are presented in two tables. The first table lists t.he 
va-ues that are defined in terms of the maximum input-line length, which is 
tr.e value for SMAX_IN_LEN--also listed here. These values are expressed 
.'.ere as Ada string aggregates, where "V" represents the maximum input-line 

■ __ V, 

Macro Parameter Macro Value 


SMAX_IN_I,EN 255 — Value of V 

SBIG_ID1 {1..V-1 -> 'A', V ■=> '1') 

$3IG_ID2 {1..V-1 => 'A', V => '2') 

S3IG_ID3 (1..V/2 ■=> 'A') & '3' & 

(1..V-l-V/2 => 'A') 

SBIG_:D4 (1..V/2 => 'A') & '4' & 

(1..V-l-V/2 => 'A') 

S3IG_:KT_LIT (1..V-3 => '0') & "2C-a" 

SBIG_REAL_LIT (1..V-5 => 'O') & ”690.0” 

SBIG_STRING1 & (1..V/2 => 'A') & 

S3IG_STRING2 S (1..V-l-V/2 => 'A') & '1' & 

S3LANKS (1..V-20 => ' ' ) 

SMAX_LEN_:nT_3ASED_LITCRAL 

”2:" & (1..V-5 => '0') & ”11 :” 

$MAX_LEN_REAL_BASED_LITERAL 

”16:” & (1..V-7 => '0') & "F.E:" 

SyJiX STRING LITERAL & (1..V-2 => 'A') & 


A-i 







MACRO PARAMETERS 


following table lists all of the other macro parameters and their 
pective values. 

Macro Parameter Macro Value 

SACC_SIZE 32 

SALIGNMENT 4 

SCO’JNT_LAST 2_147_483_647 

SOEFA'JLT_MEM_SIZE 2147483648 

SDEFAULT_STOR_aNIT 8 

SDEFAULT_SYS_NAME MIPS_ULTRIX 

SDELTA_DOC 2#1.0#E-31 

$ENTRY_ADDRESS SYSTEM.INTERRUPT_VECTOR(SYSTEM.SIGUSRl) 

S ENTRY_ADDRES S1 SYSTEM.INTERRUPT_VECTOR(SYSTEM.SIGUSR2) 

SENTRY_ADDRESS2 SYSTEM.INTERRUPT_VECTOR(SYSTEM.SIGALRK) 

sf:eld_last 512 

sf:le_terminator ' ' 

SFIXED_NAME NO_SUCH_FIXED_TYPE 

sflcat_name nc_suck_float_type 

SFORM_STRING 

SFCRM_STRING2 "CANNOT_RESTRICT_FXLE_CAPACITY" 

SGREATER_THAN_DURATION 

0.0 

SGREATER_THAN_DURATION_BASE_LAST 

200 _ 000.0 

SGREATER_T.HAN_FLOAT_BASE_LAST 

16#1.0#E+32 

S GRE AIE R_T H AN_F LCAT_S AF E_LARGE 

16#0.8#E+32 

SGREATER_THAN_SHORT_FLOAT_SAFE_LARGE 

0.0 

S.HIGH PRIORITY 15 


A-2 





MACRO PARAMETERS 


SIL L E GAL_E XT E RNAL_FILE_NAME1 

/nodir/filel 

$ILLEGAL_EXTERNAL_FILE_NAME2 

/wrongdir/file2 

s :n’a?propriate_line_length 

-1 

s: nappropr:ate_page_length 

-1 

S:nCL'JOE_PRAGMA1 pragma include ("A28006D1 .ADA") 

SINCLUDE_PRAGMA2 pragma include ("B28006D1.ADA") 

SINTEGER_FIRST -2147483648 

SINTEGER_LAST 2147483648 

SINTEGER_LAST_PLUS_1 2147483648 

$INTERFACE_LANGUAGE C 

SLESS_TKAN_DURATION -0.0 

SLESS_THAN_DURATION_BASE_FIRST 

- 200 _ 000.0 

SLINE_TERMINATOR ASCII.LF 

SLOW_?RIORITY 0 

SMACKINE_CODE_STATEMENT 

NULL; 


SMACKINE_CCDE TYPE 

NC_SUCK_TYPE 

SMA.NTISSA_DOC 

31 

SMAX_DIGITS 

15 

SMAX_INT 

2147483647 

S .MAX_ I NT_P LUS_ 1 

2_147_483_648 

S.MIN I NT 

-2147483648 

SNAME 

SHORT_SHORT_INTEGER 

3NAME_LIST 

MIPS_ULTRIX 


SNAME_SPECIFICATIONl /benl/dl83/acvc11/chape/X212CA 
SNAME_SPECIFICATION2 /ber.l/dl83/acvc 11/chape /X2 12 OB 

A-3 




MACRO PARAMETERS 


SNAME_SPECIFICATION3 

SNEG_BASED_INT 

SNEW_MEM_SIZE 

$NEW_SYS_N’AME 

SPA3E_TERMrNATCR 

SRECCRD_OEFINITION 

SRECCRI)_NAME 

STASK_S:ZE 

STASK_STORAGE_SIZE 

SVAR:A3LE_ADDRESS 

s VAR : AB ee_ai3dpe: s s : 

SVARIABLE ADDRESS2 


/benl/dl83/acvcll/chape/X3119A 

16#FFFFFFFE# 

2147483648 

MIPS_ULTRIX 
/ / 

NEW INTEGER 

NO_SUCH_MACHINE_CODE_TYPE 

32 

10240 
1 - 0 / ^ 5 6 . G 

GET_VARIABLE_ADDR£SS 
GET_VARIA3EE_ADDRESS1 
GET VARIABLE ADDRESS2 


A-4 



APPENDIX B 


COMPILATION AND LINKER SYSTEM OPTIONS 


The ccrr.piler and linker options of this Ada implementation, as described in 
thrs Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
net to this report. 


B-1 






Compiling 


Chapter 4 


4 Compiling 

After a program library has been created, one or more compilation units cam be com¬ 
piled in the context of this library. The compilation units can be placed on different 
source files or they can all be on the same file. One unit, a paxameterless procedure, 
acts as the main program. If 2l11 units needed by the main program and the main 
program itself have been compiled successfully, they can be linked. The resulting code 
can then be executed. 

§4.1 and Chapter 5 describe in detail how to call the Compiler, the Completer, which 
is called to generate code for instances of generic units, and the Linker. 

Chapter 6 explains the information which is given if the execution of a program is 
abanaoned due to an unhandled exception. 

The information the Compiler produces and outputs in the Compiler listing is explained 
in §4.4. 

Finally, the log of a sample session is given in Chapter 7. 


4.1 Compiling Ada Units 

The command ada. c invokes the Compiler, and optionally Completer and Linker of 
the Alsys .A.da System. 


ada.c 


Command Description 


NAME 


ada.c - Alsys Ada System compile command 
SYNOPSIS 

ada.c 'option ...: ffle ...; '-id Idoptl 
DESCRIPTION 

Compilation, Completion and Linking are performed in that order. The Completer 
is called if the -C or the -a option is specified. The Linker is called if the -a option 
is specified. By default, only the compiler runs and compiles the source(s) in the 
given files. 


.\lsys Ada System - User .Manual 


35 






Chapter 4 


CotQpilmg 


The source file may contain a sequence of compilation units (cf. LRM(§10.1)). All 
compilation units in the source file are compiled individually. When a compila¬ 
tion unit is compiled successfully, the program library is updated and the Compiler 
continues with the compilation of the next unit on the source file. If the compi¬ 
lation unit contained errors, they are reported (see §4.4). In this case, no update 
operation is performed on the program library and all subsequent compilation 
units in the compilation are only analyzed without generating code. 

The command delivers a non-zero status code on termination (cf. cxit[2)) if one 
of the compilation units contained errors. 

filt specifies the file(s) to be compiled. The maximum length of lines in file is 255. 
The maximum number of source lines in file is 65534. 

Note; If you specify a file name pattern, which is replaced by one or more file 
names by the shell, the order of the compilation is alphabetical, which is not 
always successful. Thus file name patterns should be used together with the 
option -a. With this option the sources can be processed in any order. 

The generation of listing output is controlled by options -1 amd -L. The default 
listing filename for a compilation is the basename, cf. basename[l), of the source 
file with sufiix . 1; when the source file already has a sufiLx, it is replaced by the 
suffix . 1. When an automatic recompilation is performed through option -R the 
basename is taken tom the original source file name stored in the library. 

-A Controls 'whether automatic inline expansion is performed. A sub¬ 

program S is automatically inlined at a place P where S is called, if 
the following conditions hold: S meets the requirements for explicit 
inlining via PRAGMA inline (cf. §15.1.1); subprogram specification 
and subprogram body of S are in the same compilation unit; and 
the estimated code size of S when expanded inline is not greater (or 
only slightly greater) than the call it replaces. (The estimation of 
size is based on heuristics and is not exact: however, it is designed 
to give a close approximation.) If you specify -A, automatic inline 
expansion is suppressed. 

By default, automatic inline expansion is performed. 

-a Specifies that the Compiler only performs s>Titactical analysis and 

the analysis of the dependencies on other units. The units in file are 
entered 'mto the library if they are syntactically correct. The actual 
compilation is done later. 

Note: .An already existing unit with the same name as the new one is 
replaced and all dependent units become obsolete, unless the source 
file of both are identical. In this case the library is not updated 
because the dependencies are already known. 


36 


.Aisys .Ada System - User .Manual 





Compiling 


Chapter 4 


By default, the normal, full compilation is done. 

-C unitlist Requests the completion of the units in nniilist, which is a white 
space separated list of unit names, unitlist must be a single shell 
argument and must therefore be quoted when it has more than one 
item. Example with two units: 

ada.c -C "our_unit ny-unit" 

The Completer generates code for all instamtiations of generic units 
In the execution closure of the specified unit(s). It also generates 
code for packages without bodies (if necessary). 

If a listing is requested the default filename used is coaplete.l. 
The listing file contains the listing ihformation for all units given in 
unitlist. 

-c Controls whether a copy of the source file is kept in the librairy. The 

copy in the program library is used for later access by the Debugger 
or tools like the Recompiler. The name of the copy is generated by 
the Compiler and need normally not be known by the user. The 
Recompiler and the Debugger know this name. You can use the 
ada. list -1 command to see the file name of the copy. If a specified 
file contains several compilation units a copy containing only the 
source text of one compilation unit is stored in the library for each 
compilation unit. Thus the Recompiler can recompile a single unit. 

if -c is specified, the Compiler only stores the name of the source 
file in the program library. In this case the Recompiler and the 
Debugger are able to use the original file if it still exists. 

-D When linking, the generation of debug information is suppressed. 

-I Controls whether inline expansion is performed as requested by 

PRAGMA inline. If you specify -I these pragmas are ignored. 

By default, inline expansion is performed. 

-1 Generates listing files with default filenames (see above) in the cur¬ 

rent directory (use option -L for redirecting to another directory). 

-L directory Generates listing files with default filenames (see above) in directory 
directory. 

-L file Concatenates all listings onto file fUe. 

-Id Idopt This option can be used to supply options for the call of Idil] wnen 
linking a program by the -s option. -Id followed by the options to 
be passed to Idil) must be the last items of the command. 


.\isys Ada System - User .Manuai 


37 



Chapter 4 


Compiling 


-a unit 


- 0 / 


-0 fUt 


-R 


-S 


Specifies the name of a main program, which must be a parajreter- 
less procedure. This option will cause the completion of any generic 
instantiations in the program; if a listing is requested, the listing 
options have the same meaning as for the complete option; if the 
completer has already been called by the -C option, the fitting out¬ 
put is appended to that completer listing file. If all compilations 
are successful, the linker is invoked to build an executable program; 
if a fisting is requested, the default filename for the linker listing is 
link.l. 

Restricts optimizations to level 1. Level 0 indicates no optimiza¬ 
tions, level 1 indicates partial optimizations, level 2 indicates full 
optimization. Default is full optimization. 

Partial optimizations allows those optimizations that do not move 
code globally. These are: Constant propagation, copy propagation, 
algebraic simplifications, runtime check elimination, dead code elimi¬ 
nation, peephole and pipeline optimizations. This optimization level 
allows easier debugging while maintaining a reasonable code quality. 
Full optimization enforces the following optimizations in addition to 
those done with -01: Global common subexpression elimination and 
keeping local variables in registers. 

When linking is requested by -a this option can be tised to specify 
the name of the generated executable program. By default, the 
name of the unit given with the -a option is used: this value is 
taken literally, i.e. upper and lower case letters are distinguished. 

Indicates that a recompilation of a previously analyzed source is 
to be performed. This option should only be used in commands 
produced by the ada.aake co mm and. 

Suppresses the generation of an executable object file when finking 
is requested. See the -r option of the ada.link command (§5) for 
details. 

Controls whether all run-time checks are suppressed. If you specify 
-S this is equivalent to the use of PRAGMA suppress for all kinds of 
checks. 

By default, no run-time checks are suppressed, except in cases where 
PRAGMA 3uppre33_all appeau^ in the source. 

Controls whether machine code is appended to the listing file, -s 
has no effect if no listing is requested or -a (analyze only) is specified. 

By default, no machine code is appended to the listing file. 


38 


.A.!sys .A.da System - User Manual 



Compiling 


Chapter 4 


-t Suppresses selective liniing. Selective linking means that only the 

code of those subprograms which can actually be called is included 
in the executable image. With “t the code of ail subprograms of 
ail packages in the execution closure of the main procedure is linked 
into the executable image. 

Note: The code of the runtime system and of the predefined units 
is always linked selectively. 

■V Controls whether the ada.c co mman d writes additional information 

onto standard error. 

By default, no additional information is written. 

-y library Specifies the program library the ada. c command works on. It needs 
write access to the library. 

The default library is adalib. 


End of Command Description 


4,2 Completing Generic Instances 

Since the Compiler does not generate code for instances of generic bodies, the Com¬ 
pleter must be used to complete such units before a program using the instances can 
be executed. The Completer must also be used to complete packages in the program 
which do not require a body. This is done implicitly when the Linker is called. 

It is also possible to call the Completer explicitly with the -C option of the ada.c 
command. 


.4.1sys .A.da System - User .Manual 


39 










Chapter 4 


Compiling 


4.3 Automatic Compilation 


The Alsys Ada System offers three different kinds of automatic compilation. It sup¬ 
ports 

• automatic recompilation of obsolete units 

• automatic compilation of mcdifieo. sources 

• automatic compilation of new sources with unknown dependencies 

In the following the term recompilation stands for the recompilation of an obsolete 
unit using the identical source which was used the last time. (This kind of recom¬ 
pilation could alternatively be implemented by using some appropriate intermediate 
representation of the obsolete unit.) This definition is stronger than that of the LRM 
(10.3). If a new version of the source of a unit is compiled we call it compilation, not 
a recompilation. 

The set of units to be checked for recompilation or new compilation is described by 
specifying one or more units and the kind of a closure which is to be built on them. 
In many cases you will simply specify your main program. 

The automatic compilation of modified sources is the default effect of the ada.aake 
command. It determines the set of modified sources and generates and executes a 
command file for calling the Compiler in an appropriate order. Optionally, obsolete 
units can be recompiled subsequently. 

If only the recompilation of obsolete units is desired, this can be specified by the -Rr 
option of the ada .sake command. It determines the set of obsolete units and generates 
and executes a command file for calling the Compiler in an appropriate order. 

The recompilation is performed using the copy of the obsolete units which is (by 
default) stored in the library. (If the user does not want to hold a copy of the sources, 
the ada.zake command can use the original source.) 

The automatic compilation of new sources is supported by the ada.c command to¬ 
gether with the -a option. This command is able to accept a set of sources in any 
order. It makes a syntactical analysis of the sources and determines the dependencies. 
The units "compiled” with this command are entered into the library, but only their 
names, their dependencies on other units and the name of the source files are stored 
in the library. Units which are entered this wny can be automatically compiled using 
the ada.nake command. 

The basis of both the ada.nake command is the information in the library about the 
dependencies of the concerned units. Thus ada.nake cannot handle the compilation 
of units which have not yet been entered in the library. 


40 


.4.1sys .4da System - User .Manual 




Linking 


Chapter 5 


5 Linking 

An Ada program is a collection of units used by a main program which controls the 
execution. The main program must be a parameterless library procedure; any param¬ 
eterless library procedure within a program library can be used as a main program. 

The hTTRIX system linker is used by the Alsys Ada Linker. 


To link a program, call the ada. link command. The Linker can also be called directly 
from the ada.c command and from the ada.make command. 


ada.link 


Command Description 


NAME 

ada. ‘nk - invoke the Alsys Ada System linker 
SYNOPSIS 

ada.link 'option ...! unit ;-ld Idoptj 
DESCRIPTION 

The ada. link command invokes the Alsys Ada Linker. 

The Linker builds an executable file. The default file name of the executable file 

is the unit name of the main program given with the unit parameter. This value 

is taken literally, i.e. upper and lower case letters are distinguished. 

unit specifies the library unit which is the main program. This must be a para- 

meteriess library procedure. 

-A This option is passed to the implicitly invoked Completer. See the 

same option with the ada.c co mman d. 

-c Suppresses invokation of the Completer of the .\isys Ada System 

before the linking is performed. Only specify -c if you are sure 

that there are no instantiations or implicit package bodies to be 

compiled, e.g. if you repeat the ada.link command with different 
linker options. 


Alsvs .Ada Svstem - User Manual 


51 








Chapter 5 


Linking 


-D By default debug information for the Alsys Ada Debugger is gen¬ 

erated and included in the executable file. When the -D option is 
present, debug information is not included in the executable file. If 
the program is to run under the control of the Debugger it must be 
linked without the -D option. 

-I Controls whether inline expansion is performed as requested by 

PRAGMA inline. If you specify -I these pragmas are ignored. 

By default, inline expansion is performed. 

-1 If -1 is specified the Linker of the Afsys Ada System creates a listing 

file containing a table of symbols which etre used for linking the Ada 
units. This table is helpful when debugging an Ada program with 
the ULTRDC debugger. The default name of the listing file is link. 1. 
By default, the Linker does not create a listing file. 

This option is also passed to the implicitly invoked Completer, 
which by default generates a listing file conplete.l if -1 is given. 

-L directory The listing files are created in directory directory instead of in the 
current directory (default). 

The listing files are concatenated onto file fUe. 

This option can be used to supply options for the call of ld(l). -Id 
followed by the options to be passed to /d(l) mtist be the last items 
of the co mm and. 

This option is passed to the implicitly invoked Completer. See the 
same option with the ada.c command. 

Specifies the name of the executable file. 

The default file name of the executable file is the unit name of the 
main program. 

Suppresses the generation of an executable object file. In this case 
the generated object file contains the code of all compilation units 
written in Ada and of those object modules of the predefined lan¬ 
guage environment and of the Ada run time system which are used 
by the main program; references into the Stt.idard C library remain 
unresolved. The generated object module is suitable for further /d(l) 
processing. The name of its entry point is aain. 

This option is passed to the implicitly invoked Completer. See the 
same option with the ada.c command. 


-L file 
-Id Idopt 

- 0 / 

-o file 


.\lsys .Ada System - User Manual 






Linking 


Chapter 5 


-s This option is passed to the implicitly invoked Completer. See the 

same option with the ada. c command. If a listing is requested and 
-3 is specified, the Linker of the Aisys Ada System generates a listing 
with the machine code of the program starter in the file link.l. The 
program starter is a routine which contains the calls of the necessary 
elaboration routines and a call for the Ada subprogram which is the 
main program. 

By default, no machine code is generated. 

-t Suppresses selective linking. Selective linking means that only the 

code of those subprograms which can actually be called is included 
in the e.xecutable file. With -t the code of all subprograms of all 
packages in the execution closure of the main procedure is linked 
into the executable file. 


Note; The code of the runtime system and of the predefined units 
is always linked selectively, even if -t is specified. 

-V Controls whether the ada. link command writes additional informa¬ 

tion onto standard error, and is also passed to the implicitly invoked 
Completer. 

By default, no additional information is written. 

-y library Specifies the program library the commamd works on. The ada. link 
command needs write access to the library unless -c is specified. If 
-c is specified the ada.link command needs only read access. The 
default library is adalib. 


End of Command Description 


The ada. link command implicitly calls the ULTRIX System Linker using the com¬ 
mand 

/bin/ld [-.Vj -o rcsultfiie /usr/lib/cnplrs/cc/crtO. o \ 
oh] rtsiib Id-optwns -Ic 

unless the -r option is specified. When ~r is specified, the Linker is called with the 
command 

/bin/ld [-M] -0 resultfde *r obj rtslib Id-options 

Here, obj denotes the file containing the object module which is produced by the .A.da 
Linker and rtslib the archive library containing the .4.da runtime system. (This may 


Aisys .A-da System - User .Manual 


53 





Chapter 5 


L inkin g 


be librtsdbg.a resp. librts.a if the Alsys Ada Linker is called with option -D. In 
this case the -N option is missing. ) 

If you invoke ld{l] by yourself to link the executable object rather than having the Ada 
Linker doing it automatically, then you must explicitly specify a startup module (see 
below) and any libraries you want linked into the Ada program. Furthermore, the Id 
option -N should be specified to allow the resulting object file to be debugged by the 
Alsys Ada Debugger. (Note that debugging is only possible if the option -D was not 
passed to the Ada Linker.) 

The startup module must satisfy the following requirements: 

• A global variable called environ is defined cont ainin g a pointer to the current 
environment (cf. envtron(7).) 

• The Ada main program is called using the entry point aain. 

• argc and argv are passed as arguments to main. 

Note that instructions following the call of main will never be executed. 

By default, the Standard C startup routine /usr/lib/cmplrs/cc/crtO .o is used. 


54 


.\:sys .A.da System - User Manual 





APPENDIX 


APPENDIX F OF THE Ada STANDARD 


T.-.e cr.ly allowed implementation dependencies correspond to implem.entati 
dependent pragmas, to certain machine-dependent conventions as mentione 
Ir.apter 13 cf the Ada Standard, and to certain allowed restrictions on 
representation clauses. The implementation-dependent characteristics of 
t.tis Ada implementation, as described in this Appendix, are provided by the 
oustomer. Unless specifically noted otherwise, references in this Appendix 
are to ocm.piler documentation and not to this report. Implementation- 
speoifio portions of the package STANDARD, which are not a part cf Appendix 
F, are contained in the following Predefined Language Enviroment (chapter 
13 page 2£5 ff of the compiler user manual). 


O XI 






Predefined Language Environment 


Chapter 13 


13 Predefined Language Environment 


The predefined language environment comprises the package standard, the language- 
defined library units and the implementation-defined library units. 


13.1 The Package STANDARD 

The specification of the package standard is outlined here; it contains all predefined 
identifiers of the implementation. 


PACKAGE standard IS 

TYPE boolean IS (false, true); 

-- The predefined relational operators for this type are as follows: 


-- FUNCTION 

n s n 

(left. 

right 

boolean) 

RETURN 

boolean; 

-- FUNCTION 


(left. 

right 

boolean) 

RETURN 

boolean; 

-- FUNCTION 

n < ti 

(left. 

right 

boolean) 

RETURN 

boolean; 

-- rJNCTION 

r»<-rf 

(left. 

right 

boolean) 

RETJRN 

boolean; 

-- FUNCTION 

« ^ « 

(left. 

right 

boolean) 

RETURN 

boolean; 

-- .-UNCTION 

f! >— « 

(left. 

right 

boolean) 

RETURN 

boolean; 


The predefined logical operators and the predefined logical 


-- negation 

operat 

or are 

as foil 

ows: 



-- FUNCTION 

"AND" 

(left. 

right : 

boolean) 

RETURN 

boolean 

-- FUNCTION 

"OR" 

(left, 

right ; 

boolean) 

RETURN 

boolean 

-- FUNCTION 

"XOR" 

(left, 

right : 

boolean) 

RETURN 

boolean 


-- rUNCTICN ’’MOT" (right : boolean) RETuRN boolean: 

-- The -universal type universal-integer is predefined. 

TYPE i.nteger IS RANGE - 2_1A7_483_548 .. 2_l-;7_483_647; 

-- The predefined operators for this type are as follows: 

-- .-UNCTICN (left, right : integer) RETURN boolean: 

-- FUNCVICN "/»" (left, right : integer) RETURN boolean: 


.A.isys .Ada System - User Manual 


265 










Chapter 13 


Predefined Language Environment 


-- 

FUNCTION 

ri ^ « 

(left. 

right : 

integer) 

RETURN boolean; 

-- 

FUNCTION 

n < — 

(left, 

right ; 

integer) 

RETURN boolean; 

-- 

FUNCTION 

tf II 

(left, 

right ; 

integer) 

RETURN boolean; 

-- 

FUNCTION 

n ^ s M 

(left. 

right : 

integer) 

RETURN boolean; 

-- 

FUNCTION 

n 

(right 

; integer) RETURN integer: 

-- 

FUNCTION 

n . It 

(right 

: integer) RETURN integer: 


FUNCTION 

"ABS" 

(right 

: integer) RETURN integer; 

— 

FUNCTION 

IT ^ 11 

(left, 

right 

integer) 

RETURN integer: 

-- 

FUNCTION 

n . If 

(left. 

right 

integer) 

RETURN int e ge r; 

-- 

FUNCTION 

n « It 

(left, 

right 

integer) 

RETURN int e ge r: 

-- 

FUNCTION 

n In 

(left, 

right 

integer) 

RETURN integer: 

-- 

FUNCTION 

"REM” 

(left, 

right 

integer) 

RETURN integer: 

— 

FUNCTION 

'’MOD” 

(left. 

right 

integer) 

RETURN integer; 

-- 

FUNCTION 

M It 

(left 

: integer: right 

: integer) RETURN 


-- An izplenentation aay provide additional predefined integer types. 
-- It is recosaended that the naaes of such additional types end 
-- with INTZGEH as in SHORT.INTEGE?. or LONG-INTEGER. The 
-- specification of each operator for the type universal-integer, or 
-- for any additional predefined integer type, is obtained by 
-- replacing INTEGER by the naae of the type in the specification 
-- of the corresponding operator of the type INTEGER, except for the 
-- right operand of the exponentiating operator. 


TYPE short-integer IS RANGE - 32-768 .. 32-767; 


TYPE short-short-integer IS RANGE - 128 .. 127; 

-- The universal type universal-real is predefined. 


TYPE float IS DIGITS 6 RANGE 

- 16#0 .FFrF_F~#E32 .. 16#0 . FFFF_FFifE32 ; 
FOR float'sire USE 32; 


The predefined operators for 


FUNCTION 

M ^ n 

(left. 

right 

FUNCTION 

»i y' — ff 

(left. 

right 

FUNCTION 


(left, 

right 

FUNCTION 

»1 < — n 

(left. 

right 

FUNCTION 

n ^ If 

(left. 

right 

FJNCTIuN 


(left. 

right 


FUNCTION (righ 


his type are as follows 

float) RETURN boolean; 
float) RETURN boolean; 
float) RETURN boolean; 
float) RETURN booleem; 
float) RETURN boolean; 
float) RETURN boolean; 

oat) RETURN float; 


266 


.Alsys .Ada System - User Manual 









Predefined Language Environment 


Chapter 13 


-- FUNCTION 

n « n 

(right 

: float) 

RETURN float: 

— FUNCTION 

"ABS" 

(right 

; float) 

RETURN float: 

-- FUNCTION 


(left, 

right : 

float) RETURN float: 

-- FUNCTION 

« « n 

(left. 

right : 

float) RETURN float: 

-- FUNCTION 

n « n 

(left. 

right : 

float) RETURN float: 

— FUNCTION 

w/ti 

(left, 

right : 

float) RETURN float: 

" FUNCTION 


(left 

float: 

right : integer) RETURN float 


-- An iaplementation may provide additional predefined floating 
— point types. It is recommended that the names of such additional 
-- types end with FLOAT as in SHORT-FLOAT or L0NG_FL0AT. 

-- The specification of each operator for the type universal-real, 

-- or for any additional predefined floating point type, is obtained 
-- by replacing FLOAT by the name of the type in the specification of 
-- the corresponding operator of the type FLOAT. 

TYPE long-float IS DIGITS 15 RANGE 

- 16#0.FFFF-FFFF_FFFF-F8#E256 .. 

16#0.FFFF-FFFF-FFFF-F8#E256; 

FOR long-float■size USE 64; 


- In addition, the following operators are predefined for universal 

- types: 


— FUNCTION 

(left 

: UNIVERSAL-INTEGER: right 

: UNIVERSAL-REAL) 


RETURN 

UNIVERSAL-REAL: 


" FUNCTION 

(left 

: UNIVERSAL-REAL; right 

: UNIVERSAL-INTEGER) 


RETURN 

UNIVERSAL-REAL; 


-- FUNCTION 

(left 

: UNIVERSAL-REAL; right 

; UNIVERSAL-INTEGER) 


RErURN 

UNI’/ERSAL-REAL; 



-- The type 

universal 

-fixed is predefined. 



-- The only 

oper 

ators 

declared for this type 

are 


-- rUNCTION 

n A fi 

(left 

: ANY.FIXED_POINT_TYPE; 





right 

: ANY_FIXED_POINT_TYPE) 

RETURN 

UNIVERSAL-FIXED 

-- FUNCTION 

n y n 

(left 

; ANY-FIXED-POINT-TYPE: 





right 

: ANY-FIXED-POINT-TYPE) 

RETURN 

UNIVERSAL-FIXED 

-- The foil 

owing 

char 

acters form the standard 

ASCII 

character set. 


-- Character literals corresponding to control charac' ars are not 
-- identifiers. 

TYPE character IS 

(nul. soh, stx. etx. eot, enq, ack. bel. 


-Aisys Ada 5ys:em - User .Manual 


267 









Chapter 13 


Predefined Language Environment 


bs, 

ht. 

If. 

vt, 

ff. 

cr, 

so. 

si. 

die. 

del. 

dc2. 

dc3. 

dc4. 

nak. 

syn. 

etb, 

can. 

en. 

sub, 

esc. 

fs. 

gs. 

rs. 

us. 


• • 

• n • 



•1’. 

'tc' . 

• 1 I 

t 


■ . 

* * ' 

• ♦ • 

• 

• « 

• • 

$ ^ t 

» 

( t 

■/’. 

‘O’ . 

•1’ . 

'2' . 

■3* . 

•4'. 

'5' , 

’6' . 

'7' . 

•8‘ . 

•9‘ . 

* . * 

J , 


• • • 

t 


'? * 

■®’ . 

•A‘ . 

•B‘ . 

•C‘ . 

•D' . 

‘E* . 

’F' . 

'G' . 

■H‘ . 

•I' , 

‘ J’ . 

'K‘ . 

•L'. 

■M' , 

■N’ , 

‘O' . 

■P‘ . 

•q-. 

‘R’. 

•S' . 

•T' . 

'U' , 

'V , 

'W , 

■x*. 

•y. 

■z*. 




« 

< ( 

* * * 1 

’a' . 

■b‘ . 

•c • . 

'd'. 

■e' . 

'f ’ . 

’g’. 

’h‘ . 

■ i' . 

■ j ’ . 

•k’ . 

•1’ . 

‘a’ . 

‘n’ . 

'o’ . 

’P‘ • 

•q’. 

‘r‘ . 

’s'. 

•t' . 

‘u ■ , 

‘V , 


■x* . 

•y‘. 

■ z ■ , 


•I’. 


» • * 

» 

del) 


FOR character USE -- 128 ascii CHARACTER SET WITHOUT HOLES 

(0. 1, 2. 3. 4. 5. 125, 126, 127) ; 

-- The predefined operators for the type CHARACTER are the same as 
-- for any entiaeration type. 

PACKAGE ascii IS 


Control characters: 


nul 

CONSTANT character 

= nul; 3oh 

CONSTANT character 

= soh; 

stx 

CONSTANT character 

= stx 

etx 

CONSTANT character 

* etx; 

eot 

CONSTANT character 

= eot 

enq 

CONSTANT character 

= enq: 

ack 

CONSTANT character 

= ack; bel 

CONSTANT character 

= bel 

bs 

CONSTANT character 

= bs 


ht 

CONSTANT character 

= ht; 

1 ■£ 

^ A 

CONSTANT character 

= If 


vt 

CONSTANT character 

= Tt: 

ff 

CONSTANT character 

— ** 


cr 

CONSTANT character 

= cr: 

so 

CONSTANT character 

= so 


si 

CONSTANT character 

= si; 

die 

CONSTANT character 

= die 

del 

CONSTANT character 

= del 

dc2 

CONSTANT character 

= dc2 

dc3 

CONSTANT character 

= dc3 

dc4 

CONSTANT character 

= dc4 

nak 

CONSTANT character 

* nak 

syn 

CONSTANT character 

= syn 

etb 

CONSTANT character 

= etb 

can 

CONSTANT character 

= can 

em 

CONSTANT character 

= en; 

sub 

CONSTANT character 

= sub 

esc 

CONSTANT character 

= esc 

fs 

CONSTANT character 

= fs 


g3 

CONSTANT character 

= gs: 

rs 

del 

CONSTANT character 
CONSTANT character 

= rs; 

= del 

us 

CONSTANT character 

* us: 


Other characters: 


exclam 

: CONSTANT 

character := ' ! ’ 

quotation 

■ CONSTANT 

character ' 

sharp 

: CONSTANT 

character := 


268 


Aisys .Ada System - User Manual 






















Predefined Language Environment 


Chapter 13 


dollar 

CONSTANT character 

a •$ ' 

percent 

CONSTANT character 

= 'V 

anpersand 

CONSTANT character 

a 

colon 

CONSTANT character 

= ’: ' 

senicolon 

CONSTANT character 

a • . ' 

query 

CONSTANT character 

a *7 ' 

at.sign 

CONSTANT character 

a -a* 

l_bracket 

CONSTANT character 

a •[’ 

back_slash 

CONSTANT character 

a -V 

r_bracket 

CONSTANT character 

a •]• 

circuzif lex 

CONST!'.. character 


underline 

CONSTANT character 


grave 

CONSTANT character 


l_brace 

CONSTANT character 

a 

bar 

CONSTANT character 

a 

r.brace 

CONSTANT character 

a .}. 

tilde 

CONSTANT character 



lc_a : CONSTANT character ;= ‘a’; 
lc _2 : CONSTANT character :* ’z’; 

END ascii; 

-- Predefined subtypes; 

SUBTYPE natural IS integer RANGE 0 .. integer’last; 
SUBTYPE positive IS integer RANGE 1 integer’last; 

P'.edefined string type: 


TYPE string IS ARRAY(positive RANGE <>) OF character: 


PRAGMA byte_pack(string): 


The predefined operators for 


this type are as follows: 


FUNCT 

TON 

FUNCT 

ION 

rJNCT 

TON 

FUNCT 

ION 

FUNCT 

ION 

FUNCT 

ION 

FJNCT 

ION 

FUNCT 

ION 

FUNCT 

ION 


n «(f 

(left, 

right 

string) 

RETURN boolean; 


ft rt 

(left, 

right 

string) 

RETURN booleam; 


ft < ft 

(left, 

right 

string) 

RETURN boolean: 


ft < s ft 

(left. 

right 

string) 

RETURN boolean; 


ft ^ ft 

(left, 

right 

string) 

RETURN boolean: 


ft ft 

(left. 

right 

string) 

RETURN boolean; 


ft^rt 

(left ; 

string: 

right 

: string) RETURN 

string: 

ft^ft 

(left : 

charact 

er; right 

: string) RETURN 

string: 

"ic" 

(left ; 

string; 

right 

: character) RETURN 

string: 


Aisys Ada System - User Manual 


269 










Chapter 13 


Predefined Language Environment 


— FUNCTION (left : character; right : character) RETURN string: 

TYPE duration IS DELTA 2#1.0#E-14 RANGE 

- 131_C72.0 .. 131_071.999_938_964_843_75; 


— The predefined operators for the tjpe DURATION are the sane 
-- as for any fixed point type. 


the predefined exceptions: 


constraint.error 

nuaeric.error 

progran_error 

storage.error 

tasking.error 


EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 

EXCEPTION 


END standard; 


13.2 Language-Defined Library Units 

The following language-defined library units are included in the master library: 


The package system 
The package calendar 

The generic procedure unchecked-deallocation 

The generic function unchecked-conversion 

The package io.exceptions 

The generic package sequential-io 

The generic package direct-io 

The package text-io 

The package low_level-io 


13.3 Implementation-Defined Library Units 

The master library also contains the implementation-defined library units 

The package collection-manager 
The package timing 
The package command-arguments 
The package text_io_extension 


270 


Alsys Ada System - User Manual 










Appendix F 


Chapter 15 


15 Appendix F 


This chapter, together with the Chapters 16 and 17, is the Appendix required in the 
LRM, in which all implementation-dependent characteristics of an Ada implementation 
are described. 


15.1 Implementation-Dependent Pragmas 

The form, allowed places, and effect of every implementation-dependent pragma is 
stated in this section. 


15.1.1 Predefined Language Pragmas 


The form and allowed places of the following pragmas are defined by the language; 
their effect is (at least partly) implementation-dependent and stated here. 

CO.N'TROLLED 
has no effect. 


EL.IBORATE 

is fully implemented. The .A.lsys Ada System assumes a PRAGMA elaborate, i.e. 
stores a unit in the library as if PRAGMA elaborate for a unit u was given, if the 
compiled unit contains an instantiation of u (or of a generic program unit in u) 
and if it is clear that u must have been elaborated before the compiled unit. In 
this case an appropriate information message is given. By this means it is avoided 
that an elaboration order is chosen which would lead to a PROGRAlvI_£RROR 
when elaborating the instantiation. 


ENLINE 

Inline expansion of subprograms is supported with the following restrictions: 
the subprogram must not contain declarations of other subprograms, tasks, generic 
units or body stubs. If the subprogram is called recursively only the outer call of 
this subprogram will be expanded. 


.Aisys .Ada System - User .Manual 








Chapter 15 


Appendix F 


INTERFACE 

is supported for ASSEMBLER ajid C. PRAGMA interface (asseabler. . . .) 
provides an interface with the intemad calling conventions of the Alsys Ada System. 
See §15.1.3 for further description. 

PRAGMA interface (C. ...) is provided to support the C procedure calling stan¬ 
dard. §15.1.4 describes how to use this pragma. The subprogram mtist not be 
a function returning an unconstrained array type, nor must it have OUT or IN 
OUT parameters that are not passed by reference. If either of these restrictions is 
violated, the program is erroneous. 

PRAGMA interface should always be used in connection with the PRAGMA exter- 
nal_nane (see §15.1.2), otherwise the Compiler will generate an internal name 
that leads to an unsolved reference during linking. These generated names are 
prefixed with an underline; therefore the user should not use names beginning 
with an underline. 

LIST 

is fully implemented. Note that a listing is only generated when one of the listing 
options is specified with the ada.c (or ada.make or ada.link) command. 


MEMORY_SIZE 
has no effect. 


OPTIMIZE 

has no effect; but see also the -0 option with the ada.c command, §4.1. 


PACK 

see §16.1. 


PAGE 

is fully implemented. Note that form feed characters in the source do not cause 
a new page in the listing. They are - as well the other format effectors (horizontal 
tabulation, vertical tabulation, carriage return, and line feed) - replaced by a ” 
character in the listing. 


PRIORITY 

There are two implementation-defined aspects of this pragma; First, the range of 


278 


.\lsys .A.da System - User .Manual 




Appendix F 


Chapter 15 


the subtype priority, and second, the effect on scheduling (Chapter 14) of not 
giving this pragma for a task or main program. The range of subtype priority is 
0 .. 15, as declared in the predefined library package system (see §15.3); and the 
effect on scheduling of leaving the priority of a task or main program undefined by 
not giving PRAGMA priority for it is the same as if PRAGMA priority (0) had 
been given (i.e. the task has the lowest priority). 


SHARED 

is fully supported. 


STORAGE.UNIT 
has no effect. 


SUPPRESS 

has no effect, but see §15.1.2 for the implementation-defined PRAGMA suppress, 
all. 


SYSTEM-NAME 
has no effect. 


15.1.2 Implementation-Defined Pragmas 

BYTE-PACK 
see §16.1. 


C-CALLABLE (<ada_name>) 

this pragma causes the Alsys Ada System to make the subprogram <ada_name> 
obey the C calling conventions (see PRAGMA interface (C. . . .) and §15.1.4), 
so that the subprogram can be called from a C routine. 

See §15.1.5 for further description. 


EXTERNAL-NAME (<string>, <ada_name>) 

<ada—name> specifies the name of a subprogram or of an object declared in a 


Alsys .Ada System - User Manual 


2T9 





Chapter 15 


Appendix F 


library package, <string> must be a string literal. It defines the external name of 
the specified item. 

This pragma is used in connection with PRAGMA interface (see §15.1.1) and 
PRAGMA c-callable (see §15.1.5). If <ada_n 2 une> is the name of a subprogram, 
the Compiler uses the symbol <string> in the call instruction for the subprogram 
Furthermore, in connection with the PRAGMA c-callable, the pragma enables the 
subprogram to be called from a routine written in C using the symbol <string>. 
The subprogram declaration of <ada_name> must precede this pragma. If several 
subprograms with the same name satisfy this requirement the pragma refers to 
that subprogram which is declared last. 

If <ada_name> is the name of an object, this pragma enables the object to be 
accessed from outside the Ada program using the symbol <5tring>, for example 
from a subprogram written in another language. 

Upper and lower cases are distinguished within <string>, i.e. <string> must be 
given exactly as it is to be used by external routines. The user should not define 
external names beginning with an underline because Compiler generated names 
are prefixed with an underline. 


RESIDENT (<ada...name>) 

this pragma causes the value of the object <ada_name> to be held in memory 
(rather than in a register) and prevents assignments of a value to the object 
<ada_name> from being eliminated by the optimizer (see §4.1) of the Aisys Ada 
Compiler. 

PRAGMA resident may be needed to prevent crucial assignments from being elim¬ 
inated by the optimizer in rare cases in which an object is accessed via its address 
using the attribute ’address. In all straightforward cases of this sort, i.e. when¬ 
ever the attribute is used in a way designed to be easily understood by human 
readers, the Compiler will recognize accesses to the object via 'address as such 
and will not allow the opt imi zer to el imin ate crucial assignments of values to the 
object. The following example shows one of the rare cases mentioned above, in 
which PRAGMA resident is necessary. 

In this example, exanine_value_at is a non-local procedure with an IN parameter 
of type systec.address, which reads the value at the address passed as actual 
parameter. 


WITH systes, exanine_value_at; 

PRCCZDUP.E exanple IS 

TYPE tcb^z-rpe IS . . . ; 
fcb : fcb.type; 
fcb_addre3s; systen.address; 


2S0 


.\lsys .Ada System - User Manual 







Appendix F 


Chapter 15 


FUNCTION file_control_block_addre33 RETURN systea.addre3s IS 
BEGIN 

IF ... THEN 

PZTURN f c b’addre 3 s: 

ELSE 

END IF: 

END file_control_block_addres3; 

BEGIN 

fcb_addre33 := file_control_block_address; -- aay be fcb’address 
fcb := . . . : 

exaaine.value_at (fcb.address); -- may read fcb 

fob := ...: 

END exacple; 


If this procedure is compiled by the Alsys Ada Compiler without suppression of 
dead code elimination, i.e. without the -00 option, the first assignment to fcb 
will be eliminated, because the Compiler will not recognize that the value of fcb 
may be read before the next assignment to fcb. Therefore 


PRAGMA resident (fcb); 

should be inserted after the declaration of fcb. 

This pragma can be applied to ail those kinds of objects for which the address 
clause is supported (cf. §16.5). 


SUPPRESS_ALL 

causes all the runtime checks described in the LRM(§11.7) to be suppressed; this 
pragma is only allowed at the start of a compilation before the first compilation 
unit; it applies to the whole compilation. 


.Alsys .Ada System - User Manual 


281 



Chapter 15 


Appendix F 


15.1.3 Pragma Interface (Assembler, ...) 


This section describes the internal calling conventions of the Alsys Ada System, which 
are the same as those \ised for subprograms for which PRAGMA interface (assembler. 

...) is given. Thus the actual meaning of this pragma is simply that the body needs 
and must not be provided in Ada; it is provided in object form using the -Id option 
with the ada.link (or ada.c or ada.make) command. 

In many cases it is more convenient to follow the C procedure calling stan¬ 
dard. Therefore the Alsys Ada System provides PRAGMA interface (c, 

. . .), which supports the standard retxim of the function result and the stan¬ 
dard register saving. This pragma is described in the next section. 

The internal calling conventions are explained in four steps: 

- Parameter passing mechanism 

- Ordering of parameters 

- Tj-pe mapping 

- Saving registers 


Parameter passing mechanism: 

The Alsys Ada System uses three different parameter passing mechanisms, depending 
on the type of a parameter: 

• by value and/or result: The value of the parameter itself is passed. 

• by reference: The address of the parameter is passed (like an IN parameter of type 
system.address, which would be ptissed by value). 

• by descriptor: A descriptor for the parameter is allocated on the caller’s side and 
is itself passed by reference. 

The parameters of a subprogram are passed in registers where possible. The remaining 
parameters, if any, are passed in an area called a parameter block. This area is aligned 
on a word boundary and contains pcirameter values (for parameter of scalar types), 
parameter addresses or descriptor addresses (for parameter of composite types) and 
alignment gaps. 

For a function 3ubprogr2uii an extra register ($r4 or $f0) is assigned to contain the 
function result upon retiim. Thus the return value of a function is treated like an 
anonymous parameter of mode OUT. No special treatment is required for a function 
result except for return values of an unconstrained array type (see below). 

.A, subprogram is called using the JAL instruction. The address of the parameter block 
is passed in $r3, if necessary. The static link of a subprogram is passed in $r2, if 
necessary. 


282 


Alsys .Ada System - User Manual 


Appendix F 


Chapter 15 


In general, the ordering of the parameter values within the parameter block does not 
agree with the order specified in the Ada subprogram specification. When determining 
the position of a paxameter within the parameter block, the calling mechanism and 
the size and alignment requirements of the parameter type are considered. The size 
and alignment requirements and the passing mechanism are as follows: 

Scalar parameters and parameters of access types are passed by value, i.e. the values 
of the actual parameters of modes IN or IN OUT are copied into the parameter register 
or into the parameter block before the call. Then, after the subprogram has returned, 
values of the actual pajameters of modes IN OUT and OUT axe copied out of the pa¬ 
rameter register or the parameter block into the associated actual parameters. The 
parameters are aligned within the parameter block according their size: A parameter 
with a size of 8, 16 or 32 bits has an alignment of 1, 2 or 4 (which means that the object 
is aligned to a byte, halfword or word boundary within the paxtimeter block). If the 
size of the parameter is not a multiple of 8 bits (which may be achieved by attaching 
a size specification to the parameter’s type in case of an integer, enumeration or fixed 
point type) it will be byte aligned. Parameters of access types are always aligned to a 
word boundary. 

Parameters of composite types are passed by reference or by descriptor. The descrip¬ 
tors are allocated by the caller and are themselves passed by reference. A descriptor 
contains the address of the actual parameter object and further information depen¬ 
dent on the specific parameter type. The following composite parameter types are 
distinguished: 

• A parameter of a constrained array type is passed by reference for all parameter 
modes. 

• For a parameter of an unconstrained array type, the descriptor consists of the 
address of the actual array parameter followed by the bounds for each index range 
in the array (i.e. FIRST(l), LAST(l), rIRST(2), LAST(2), ...). The space adlo- 
cated for the bound elements in the descriptor depends on the type of the index 
constraint. This descriptor is itself passed by reference. 

• For functions whose return ’/ulue is an unconstrained array type, a reference to 
a descriptor for the array is passed in the parameter block as for parameters of 
mode OUT. The fields for its address and ail array index bounds are filled up by 
the function before it returns. In contrast to the procedure for an OUT parameter, 
the function allocates the array in its own stack space. The function then returns 
without releasing its stack space. After the function has returned, the calling 
routine copies the array into its own memory space and then deallocates the stack 
memory of the function. 

• -A. constrained record parameter is passed by reference for all parameter modes. 

• For an unconstrained record parameter of mode IN, the parameter is passed by 
reference using the address pointing to the record. If the pcirameter has mode 
OUT or IN OUT, the value of the CONSTRAINED attribute applied to the actual 
parameter is passed as an additional boolean IN parameter (which, when not 
passed in a register, occupies one byte in the parameter block and is aligned to 
a byte boundary). The boolean IN parameter and the address are treated like 


.Alsys Ada System - User Manual 


233 





Chapter 15 


Appendix F 


two consecutive parzoneters in a subprogram specification, i.e. the positions of the 
two parameters within the pajatmeter block aire determined independently of each 
other. 


For all kinds of composite pau’ameter types, the pointer pointing to the actual para¬ 
meter object is represented by a 32 bit address, which is always aligned to a word 
boundary. 


Ordering of parameters: 

The ordering of the parameters is determined as follows: 

The parameters are processed in the order they are defined in the Ada subprogram 
specification. For a function, the return value is treated as an anonymous parameter of 
mode OUT at the start of the parameter list. The registers $r4. .$r22 and $f0. .5f31 
are available for parameter passing. A parameter block is only used when there are 
more parameters than registers of the appropriate class. Registers are used from low 
numbers to high numbers, the parameter block starts at offset zero and grows to higher 
offsets. Each parameter is handled as follows: 

• A float parameter is allocated the next free even numbered floating point register 
(the corresponding odd numbered floating point register is not used for parameter 
passing). If there is no free floating point register, one word is allocated in the 
parameter block (see below). 

• .\ long_float parameter is allocated the next free floating point register pair. 
If there is no free floating point register pair, a double word is allocated in the 
parameter block (see below). 

• All other parameters (or their idescriptor; addresses, respectively) are allocated the 
next free general purpose register from $r4. . $r22. If not enough general purpose 
registers are available for parameter passing, space is allocated in the parameter 
block depending on the representation of the parameter u-pe (see below). 

• If a parameter cannot be passed in a register, space is allocated in the parameter 
block as follows: 

Because of the size and alignment requirements of a parameter it is not always 
possible to place parameters in such a way that two consecutive parameters are 
densely located in the parameter block. In such a situation a gap. i.e. a piece 
of memory space which is not associated with a parameter, exists between two 
adjacent parameters. Consequently, the size of the parameter block can be larger 
than the sum of the sizes of ail the parameters. 

In order to minimize the size of the gaps in a parameter block, an attempt is made 
to fill each gap with a parameter that occurs later in the parameter list. If during 
the allocation of space within the parameter block a parameter is encountered 


234 


.\lsys Ada. System - User .Manual 




Appendix F 


Chapter 15 


whose size and alignment fit the characteristics of an available gap, then this gap 
is allocated for the parameter instead of appending it at the end of the parameter 
block. As each parameter will be aligned to a byte, halfword or word boundary 
the size of any gap may be one, two or three bytes. Every gap of size three bytes 
can be treated as two gaps, one of size one byte with an alignment of 1 and one 
of size two bytes with an alignment of 2. So if a parameter of size two is to be 
allocated, a two byte gap, if available, is filled up. A parameter of size one will 
fill a one byte gap. If none exists but a two byte gap is available, this is used as 
two one byte gaps. By this first fit algorithm all parameters are processed in the 
order they occur in the Ada program. 


A called subprogram accesses each parameter for reading or writing using the para¬ 
meter register or using the parameter block address incremented by an offset from the 
start of the parameter block suitable for the parameter. So the value of a parameter of 
a scalar type or an access type is read (or written) directly from (into) the parameter 
register or parameter block. For a parameter of a composite type passed by reference 
the actual parameter value is accessed indirectly via the parameter address passed in 
a parameter register or in the parameter block. For a parameter of a composite type 
passed by descriptor the actual parameter value is accessed via the descriptor whose 
address is passed in a parameter register or in the parameter block. The descriptor 
contains a pointer to the actual object. When stzindard entry code sequences are used 
within the assembler subprogram (see below), the parameter block address is accessible 
at address -12($r30). 


Type mapping: 

To access individual components of array or record types, knowledge about the type 
mapping for array and record types is required. An array is stored as a sequential con¬ 
catenation of all its components. Normally, pad bits are used to fill each component 
to a byte, halfword, word or a multiple thereof, depending on the size and ali g nment 
requirements of the components’ subtype. This padding may be influenced using one 
of the PRAGM.As pack or byt;e_pack (cf. §16.1). The offset of an individual array 
component is then obtained by multiplying the padded size of one array component by 
the number of components stored in the array before it. This number may be deter¬ 
mined from the number of elements for each dimension using the fact that the array 
elements are stored row by row. (For unconstrained arrays the number of elements for 
each dimension can be found in the descriptor, which is passed by reference.) 

.A. record object is implemented as a concatenation of its components. Initially, loca¬ 
tions are reserved for those components that have a component clause applied to them. 
Then locations for ail other components are reserved. .Any gaps large enough to hold 
components without component clauses are filled, so in general the record components 
are rearranged. Components in record variants are overlaid. The ordering mechanism 
of the components within a record is in principle the same as that for ordering the 
parameters in the parsmeter block. 


.Aisys .Ada Svsiem - User Manual 


285 



Chapter 15 


Appendix F 


A recor'i anay hold implementation-dependent components (cf. §16.4). For a record 
component whose size depends on dbcriminants, a generated component holds the 
offset of the record component within the record object. If a record type includes 
variant parts there may be a generated component (cf. §16.4) holding the size of the 
record object. This size component is allocated as the first component within the record 
object if this location is not reserved by a component clause. Since the mapping of 
record types is rather complex, record component clauses should be introduced for each 
record component if an object of that type is to be passed to a non Ada subprogram 
in order to ensure correct access to the components. 


Saving registers: 

The last aspect of the calling conventions discussed here is that of saving registers. The 
calling subprogram assumes that the values of the registers $rl. .$r22, $r24. .$r25 
will be destroyed by the called subprogram, and therefore saves them of its own accord. 
The stack pointer $r29 will have the same value after the call as before except for 
functions returning unconstrained arrays. The stack limi t register ($r23) will have the 
same value after the call as before xinless the stack of the main task was extended. If 
the called subprogram wants to modify further registers it has to ensure that the old 
values are restored upon return from the subprogram. Note that these register saving 
conventions differ from the C calling standard. 

Finally we give the appropriate code sequences for the subprogram entry and for the 
return, which both obey the rules stated above. 

A subprogram for which .^RAGI^A interface (assenbler, . . .) is specified is - in 
effect - called with the subprogram calling sequence 


aove 

aove 

54. . . . 

5f0. . . . 

1 assign IN paraaeters. 

, if any 

jai 

nop 

<3ubprogra2 

addre33> 


nove 

.... $*4 

1 read OUT paraaetera, 

if any 


286 


.\lsys .\da System - User Manual 



Appendix F 


Chapter 15 


Thus the appropriate entry code sequence is 

addiu $sp,$sp.-12 

sw $0.0($sp) 

sw $fp.4($sp) 

sw $3l,8($sp) 

addiu $15.$ 3 p.-<frane_3i2e-4> 

addiu $fp.$3p.4 

3lt $1.$23.$15 

bne $1.$0.L1 

nop 

jal -EXTSTCK I Storage check 

aove $24, $15 

LI; 

move $3p,$l5 

I The field at addrese -4($fp) is reserved 
I for use by the Ada runtime system 


The return code sequence is then 

move $sp.$fp 
Iw $31.4($sp) 

Iw $fp,0($sp) 

jr $31 

addiu $sp,$sp,8 


15.1.4 Pragma Interface (C, ...) 

The Aisys Ada System supports PRAGMA interface (C. . . 

With the help of this pragma and by obeying some rules (described below) subprograms 
can be called which follow the C procedure calling standard. As the user must know 
something about the internal calling conventions of the Aisys Ada System we recom¬ 
mend reading §15.1.3 before reading this section and before using PRAGMA interface 
(C. ...). 

For each .A.da subprogram for which 


Aisys Ada System - User Manual 


287 






Chapter 15 


Appendix F 


PRAGMA interface (C, <ada_naEe>); 

is specified, a routine implementing the body of the subprogram <ada_name> must be 
provided, written in any language that obeys the C calling conventions - cf. ULTRDC 
Documentation Set, Programmer’s Manual, in particular: 


- Saving registers 

- Calling mechanism 

- C stack frame format. 


ULTREX system calls or subroutines are allowed too. 


The following parameter and result types are supported: 

C Type Ada Type 


int standard.integer 

float standard.float 

double standard.long-float 
pointer systen. address 


The calling mechanism for all parameter types is call by value. The type address 
may serve to implement all kinds of call by references: The user may build ail kinds 
of objects and pass their addresses to the C subprogram or ULTRDC system routine. 

The name of the routine which implements the subprogram <ada_name> should be 
specified using PRAGMA extemal_na=e (see §15.1.2), otherwise the Compiler will gen¬ 
erate an internal name that leads to an unsolved reference during linking. These 
generated names are prefixed with an underline; therefore the user should not define 
names beginning with an underline. 

The following example shows the intended usage of PRAGMA interface (C) to call a 
ITLTRIX system routine. The given procedure serves to open a file with a fixed name. 
It is called in the body of the main program. 


WITH system: 


PROCEDimZ unix-call IS 


read_aode 

file-name 


C3NSTANT integer := 8#0#; 

CONSTANT string :* "/benl/test/f 1" tc ascii.nul: 


288 


.Alsys .\da System - User Manual 




Appendix F 


Chapter 15 


PRAGMA resident (f ile_n.aiae) ; 
ret_code : integer: 
use.error : EXCEPTION: 

FUNCTION unix_open (path : system.address: 

oflag : integer) RETURN integer: 
PRAGMA interface (C. unix-open): 

PRAGMA extemal_naaie ("open". unix_open) : 

BEGIN 

ret_code ;= nnix_open (file_naae* address, read-mode); 
IF ret_code = -1 THEN 
RAISE use-error: 

END IF: 

END unix-call: 


15.1.5 Pragma C_callable(...) 

Like PRAGMA interface (C. . . .), PRAGMA c_callable enforces the use of C calling 
conventions (cf. §15.1.4). The body of a subprogram for which 

PRAGMA c_callable (<ada_naae>): 

is specified must still be provided in Ada. The subprogram can be called from .4da 
without any restriction: the purpose of this pragma is to enable a C routine (called 
from the .4da program) to call back an Ada subprogram. 

The name of the subprogram which is to be called by C should be specified using the 
PRAGMA external-name (see §15.1.2), and this external name is to be used in the C 
routine to call back the .A.da subprogram. If no external name is specified, the Compiler 
will generate an internal name that leads to an unsolved reference during linking. 

The PRAGMA c_callable is allowed at the place of a declarative item of a library 
package body or library package specification and must apply to a subprogram declared 
by an earlier declarative item of the same declarative part or package specification. The 
pragma is also allowed for a library unit; in this case the pragma must appear after 
the subprogram declaration, and before any subsequent compilation unit. 

A. c_callabie subprogram must not be a function returning an unconstrained array 
t>'pe, nor must it have OUT or IN OUT parameters that are not passed by reference. 


-Alsys .Ada System - User Manual 


289 



Chapter 15 


Appendix F 


Furthennore, it mtist not propagate any exception to its caller because the exception 
cannot be handled correctly if the caller is a C routine. For this reason, a c_cailable 
Ada subprogram does not make a storage check upon subprogram entry (cf. §15.1.3). 

If either of these restrictions is violated, the program is erroneous. 


15.2 Implementation-Dependent Attributes 

The name, type and implementation-dependent aspects of every implementation-de¬ 
pendent attribute is stated in this section. 


15.2.1 Language-Defined Attributes 


The name and type of all the language-defined attributes are as given in the LRM. We 
note here only,the implementation-dependent aspects. 


ADDRESS 

If this attribute is applied to an object for which storage is allocated, it yields the 
address of the first storage unit that is occupied by the object. 

If it is applied to a subprogram or to a task, it yields the address of the entry 
point of the subprogram or task body. 

If it is applied to a task entry for which an address clause is given, it yields the 
address given in the address clause. 

For any other entity this attribute is not supported and will return the value 
systes.addre3s_2ero. 


IMAGE 

The image of a character other than a graphic character (cf. LRM(§3.5.5(11))) 
is the string obtained by replacing each italic character in the indication of the 
character literal (given in the LRM(Annex C(13))) by the corresponding upper¬ 
case character. For e.xample, character’iaageCnuO = "NUL". 


.\LA.CHI>'E-OVTRFLOWS 

Yields true for each real type or subtype. 


290 


.\lsys .-Vda System - User Manual 




Appendix F 


Chapter 15 


MACHINE-ROUNDS 

Yields true for each real type or subtype. 


STORAGE-SIZE 

The value delivered by this attribute applied to an access type is as follows: 

If a length specification (STORAGE-SIZE, see §16.2) has been given for that type 
(static collection), the attribute delivers that specified value. 

In case of a dynamic collection, i.e. no length specification by STORAGE-SIZE given 
for the access type, the attribute delivers the number of storage units currently 
allocated for the collection. Note that dynamic collections are extended if needed. 
If the collection manager (cf. §13.3.1) is used for a dynamic collection the attribute 
delivers the number of storage units currently allocated for the collection. Note 
that in this case the number of storage units currently allocated may be decreased 
by release operations. 

The value delivered by this attribute applied to a task type or task object is as 
follows: 

If a length specification (STORAGE-SIZE, see §16.2) has been given for the task 
type, the attribute delivers that specified value; otherwise, the default value is 
returned. 


15.2.2 Implementation-Defined Attributes 


There are no implementation-defined attributes. 


.Aisys .Ada System - User .Manual 


291 




Chapter 15 


Appendix F 


15.3 Specification of the Package SYSTEM 

The package system as required in the LRM(§13.7) is reprinted here with all imple- 
.nentation-dependent characteristics and extensions filled in. 


PACKAGE system IS 

TYPE address IS PRIVATE; 
addre3s_zero : CONSTANT address; 


FUNCTION 

(left : 

: address; right 

: integer) 

RETURN 

address 

FUNCTION "♦" 

(left ; 

: integer; right ; 

: address) 

RETURN 

address 

FUNCTION 

(left ; 

; address; right : 

: integer) 

RETURN 

address 

FUNCTION 

(left : 

; address; right ; 

: address) 

RETURN 

integer 


FUNCTION symbolic.address (symbol : string) RETURN address; 

SUBTYPE extemal.address IS STRING; 

-- E:ctemal addresses use hexadecimal notation with characters 

-- ’O’.-’Q'. ■a’..'f' and ’A'..'F’. For instance; 

__ "7FFFFFFF" 

"80000000" 

"8" represents the sane address as "00000008" 

FUNCTION convert-address (addr ; extemal_address) RETURN address; 
-- convert-address raises CONSTRAINT-EP.ROR if the external 
-- address addr is the empty string, contains characters other 
-- than ’a’..’f’. 'A'..’F' or if the resulting address 

-- value cannot be represented with 32 bits. 

Function convert-address (addr : address) RETURN external-address; 
-- The resulting external address consists of exactly 3 
-- characters '0'..’9’, 

TYPE name IS (mips-ultricc) ; 

systen_name ; -CONSTANT name ;= mips-ultrix; 


292 


.Alsys .Ada System - User .Manual 












Appendix F 


Chapter 15 


storage-unit 

CONSTANT 

= 8: 

memory-size 

CONSTANT 

= 2 *• 31: 

min_int 

CONSTANT 

= - 2 «• 31: 

max-int 

CONSTANT 

= 2 ** 31 - 1: 

max-digits 

CONSTANT 

= 15: 

max—mantissa 

CONSTANT 

= 31: 

fine-delta 

CONSTANT 

= 2.0 ** (-31) 

tick 

CONSTANT 

= 1.0 / 256.0: 


SUBTTPE priority IS integer RANGE 0 .. 15: 

TYPE interrupt_nunber IS RANGE 1 .. 31; 

interrapt_vector : ARRAY (interrupt-number) OF address: 

-- The mapping of signal numbers to interrupt addresses is 
-- defined by this array. 


sighup 

CONSTANT 

= 1: 

sigint 

CONSTANT 

= 2: 

sigquit 

CONSTANT 

= 3i 

sigill 

CONSTANT 

= 4: 

sigtrap 

CONSTANT 

= 5: 

sigiot 

CONSTANT 

= 6: 

sigabrt 

CONSTANT 

= 3ig 

sigemt 

CONSTANT 

= 7: 

sigfpe 

CONSTANT 

= 8: 

sigkill 

CONSTANT 

= 9: 

sigbus 

CONSTANT 

= 10 

sigsegv 

CONSTANT 

= 11 

sigsys 

CONSTANT 

= 12 

sigpipe 

CONSTANT 

= 13 

sigalrm 

CONSTANT 

= 14 

sigterm 

CONSTANT 

= 15 

sigurg 

CONSTANT 

= 16 

sigstop 

CONSTANT 

= 17 

sigtst? 

CONSTANT 

= 18 

sigcont 

CONSTANT 

= 19 

sigchld 

CONSTANT 

= 20 

sigttin 

CONSTANT 

= 21 

SlgttOU 

CONSTANT 

= 22 

sigio 

CONSTANT 

= 23 

sigrccpu 

CONSTANT 

= 24 

sigrcf sz 

CONSTANT 

» 25 

sigvtalrm 

CONSTANT 

= 26 

sigprof 

CONSTANT 

- ^ / 

sigwinch 

CONSTANT 

= 28 


Alsys .Aca Sys'.em - User .Manual 


293 








Chapter 15 


Appendix F 


siglost 

: CONSTANT 

;= 2S: 

sigusrl 

: CONSTANT 

;= 30; 

sigusrO 

; CONSTANT 

:= 31; 


non_ada_error : EXCEPTION: 

-- non_ada_error is raised, if some event occurs which does not 
-- correspond to any situation covered by Ada, e.g.: 
illegal instruction encountered 
error during address translation 
illegal address 

TYPE exception-id IS NEW address; 

no_exception_id : CONSTANT exception-id := NULL; 

-- Coding of the predefined exceptions; 

FUNCTION constraint_error_id RETURN exception-id; 

FUNCTION nuneric_error_id RETURN exception-id; 

.njNCTION prograa_error_id RETURN exception-id; 

FUNCTION storage_error_id RETURN exception-id; 

FUNCTION tasking-error-id RETURN exception-id; 

FUNCTION non_ada-error_id REFJRN exception-id; 

FUNCTION status-error-id RETURN exception-id; 

FUNCTION mode-error_id RETURN exception-id; 

FUNCTION aame-error-id RETURN exception-id; 

FUNCTION use-error-id RETURN exception-id; 

FUNCTION device-error-id RETURN exception-id; 

FUNCTION end_error_id RETURN exception-id; 

FUNCTION data-error-id RETURN exception-id; 

FUNCTION layout-error-id REFURN exception-id; 

FUNCTION time-error-id REFURN exception-id; 

no_error-code : CONSTANT ;= 0; 

TYPE exception-information 
IS RECORD 

excp-id : exception-id; 

-- Identification of the exception. The codings of 

-- the predefined exceptions are given above, 
code-addr : address; 

-- Code address where the exception occured. Depending 


294 


Aisys .\da System - User Manual 









Appendix F 


Chapter 15 


-- on the kind of the exception it may be the address of 
-- the instruction which caused the exception, or it 
-- nay be the address of the instruction which would 
-- have been executed if the exception had not occured. 
error_code : integer; 

END RECORD; 

PROCEDURE get_exception_inforaation 

(excp_info : OUT exception-information): 

-- The subprogram get_exception_inforaation must only be called 
-- from within an exception handler BEFORE ANY OTHER EXCEPTION 
-- IS RAISED. It then rettums the information record about the 
-- actually handled exception. 

-- Otherwise, its result is undefined. 

PROCEDURE raise_exception_id 

(excp_id : exception-id); 

PROCEDURE raise-exception-info 

(excp-info : exception-information); 

-- The subprogram raise-exception-id raises the exception 
-- given as parameter. It corresponds to the RAISE statement. 

-- The subprogram raise-exception_iafo raises the exception 
-- described by the inforaation record supplied as parameter. 

— In addition to the subprogram raise-exception-id it allows to 
-- explicitly define all components of the exception information 
-- record. 

-- IT IS INTENDED THAT BOTH SUBPROGRAMS ARE USED ONLY WHEN 
-- INTERFACING WITH THE OPERATING SYSTEM. 


TYPE exit-code IS NEW integer: 

error : CONSTANT exit-code ;= 1; 

success : CONSTANT exit-code := 0; 


errmo : integer; 

FOR ermo USE AT symbolic-address ("ermo") ; 

-- Allows access to the ermo set by the last system call. C, or 
-- assembler routine call that was made on behalf of the calling 
-- task. 

PROCEDUR.E 3et_exit_code (val ; exit-code) ; 

-- Specifies the exit code which is returned to the 


.\Isys Ada System - User .Manual 


295 



Chapter 15 


Appendix F 


operating system if the Ada program terminates normally. 
The default exit code is ’success’. If the program is 
abandoned because of an exception, the exit code is 
’error’. 


PRIVATE 

— private declarations 
END system; 


15.4 Restrictions on Representation Clauses 

See Chapter 16 of this manual. 


15.5 Conventions for Implementation-Generated Names 

There aire implementation generated components but these have no names, (cf. §16.4 
of this manual). 

15.6 Expressions in Address Clauses 

See §16.5 of this manual. 


15.7 Restrictions on Unchecked Conversions 

The implementation supports unchecked type conversions for ail kinds of source and 
target types with the restriction that the target type must not be an unconstrained 
array type. The result value of the unchecked conversion is unpredictable, if 

target_t}rpe ■ SIZE > 3ource_type’SIZE 


2Q6 


■Aisys .Ada System - User Manual 





Appendix F 


Chapter 15 


15.8 Characteristics of the Input-Output Packages 

The implementation-dependent characteristics of the input-output packages as defined 
in the LRM(Chapter 14) are reported in Chapter 17 of this manual. 


15.9 Requirements for a Main Program 

A main program must be a parameterless library procedure. This procedure may be 
a generic instantiation; the generic procedure need not be a librany unit. 


15.10 Unchecked Storage Deallocation 

The generic procedure unchecked-deallocation is provided; the effect of calling an 

instance of this procedure is as described in the LRM(§13.10.1). 

The implementation also provides an implementation-defined package collection- 

nanager, which has advantages over unchecked deallocation in some applications (cf. 

§13.3.1). 

Unchecked deallocation and operations of the collectior.-nanager can be combined 

as follows; 

• collection_nanager.reset can be applied to a collection on which unchecked 
deallocation has also been used. The effect is that storage of all objects of the 
collection is reclaimed. 

• After the first unchecked-deallocation (release) on a collection, all following 
calls of release (unchecked-deallocation) until the next reset have no effect, 
i.e. storage is not reclaimed. 

• after a reset a collection can be managed by nark and release (resp. unchecked- 
deallocation) with the normal effect even if it was managed by unchecked- 
deallocation (resp. nark and release) before the reset. 


15.11 Machine Code Insertions 


A package nachine_code is not provided and machine code insertions are not sup¬ 
ported. 


.\isy3 .A.da System - User Manual 


297 





Chapter 15 


Appendix F 


15.12 Numeric Error 

The predefined exception n.uaeric_error is never raised implicitly by any predefined 
operation; instead the predefined exception constraint-error is raised. 


298 


.\lsys .\da System - User Manual 










Appendix F: Representation Clauses 


Chapter 16 


16 Appendix F: Representation Clauses 


In this chapter we follow the section numbering of Chapter 13 of the LRM and provide 
notes for the use of the features described in each section. 


16.1 Pragmas 

PACK 

As stipulated in the LRM(§13.1), this pragma may be given for a record or array 
type. It causes the Compiler to select a representation for this type such that gaps 
between the storage areas allocated to consecutive components axe minimized. For 
components whose type is an array or record type PRAGMA pack has no effect on 
the mapping of the component type. For all other component types the Compiler 
will choose a representation for the component type that needs minimal storage 
space (packing down to the bit level). Thus the components of a packed data 
structure will in general not start at storage unit boundaries. 


3YTZ_?ACX 

This is an Implementation-denned pragma which takes the same argument as 
the predefined language PRAGMA pack and is allowed at the same positions. For 
components whose type is an array or record type PRAGMA byT:e_pack has no 
effect on the mapping of the component type. For all other component types the 
Compiler will try to choose a more compact representation for the component type. 
But m contrast to PRAGMA pack all components of a packed data structtire will 
start at storage unit boundaries and the size of the components will be a multiple 
of systea. storage _unit. Thus. PRAGMA byte_pack does not effect packing down 
to the bit level (for this see PRAGMA pack). 


.Alsys .Ada System - User Manual 


299 





Chapter 16 


Appendix F: Representation Clauses 


I 


16.2 Length Clauses 

SIZE 

for ail integer, fixed point and enumeration types the value must be <= 32; 
for fl-iat types the value must be = 32 (this is the amount of storage which is 
associated with these types anyway). 

for long-float types the value must be = 64 (this is the amount of storage which 
is associated with these types anyway); 

for access types the value must be = 32 (this is the amount of storage which is 
associated with these types anyway). 

If any of the above restrictions are violated, the Compiler responds with a RE¬ 
STRICTION error message in the Compiler listing. 

STORAGE-SIZE 

Collection size; If no length clause is given, the storage space needed to contain 
objects designated by values of the access type and by values of other types derived 
from it is extended dynamically at runtime as needed. If, on the other hand, a 
length clause is given, the number of storage units stipulated in the length clause 
is reserved, and no dynamic extension at runtime occurs. 

Storage for tasks: The memory space reserved for a task is lOK (-^ 2K) bytes if no 
length clause is given (cf. Chapter 14). If the task is to be adlotted either more or 
less space, a length clause must be given for its task type, and then all tasks of this 
type will be allotted the amount of space stipulated in the length clause. Whether 
a length clause is given or not, an additional 2K bytes are allotted for runtime 
activities and the total space allotted is not extended dyn ami cally at runtime. 


SMALL 

there is no implementation-dependent restriction. Any specification for SMALL 
that is allowed by the LRM can be given. In particular those values for SMALL are 
also supported which are not a power of two. 


16.3 Enumeration Representation Clauses 


The integer codes specified for the enumeration type have to lie inside the range of the 
largest integer t>pe which is supported: this is the type integer defined in package 
standard. 


300 


.Alsys .Ada System - User Manual 





Appendix F: Representation Clauses 


Chapter 16 


16.4 Record Representation Clauses 

Record representation clauses are supported. The value of the expression given in an 
alignment clause must be 0, 1, 2 or 4. If this restriction is violated, the Compiler 
responds with a RESTRICTION error message in the Compiler listing. If the value is 
0 the objects of the corresponding record type will not be aligned, if it is 1, 2 or 4 the 
starting address of an object will be a multiple of the specified alignment. 

The number of bits specified by the range of a component clause must not be greater 
than the amount of storage occupied by this component. (Gaps between components 
can be forced by leaving some bits unused but not by specifying a bigger ramge than 
needed.) Violation of this restriction will produce a RESTRICTION error message. 

There are implementation-dependent components of record types generated in the 
following cases : 

• If the record type includes variant parts and the difference between the TnayiTnii-m 
and the minimum sizes of the variant is greater than 32 bytes, and, in addition, 
if it has either more than one discriminant or else the only discriminant may 
hold more than 256 different values, the genera^d component holds the size of 
the record object. (If the second condition is not fulfilled, the number of bits 
allocated for any object of the record type will be the value delivered by the size 
attribute applied to the record type.) 

• If the record type includes array or record components whose sizes depend on dis¬ 
criminants, the generated components hold the offsets of these record components 
(relative to the corresponding generated component) in the record object. 

But there are no implementation-generated names (cf. LRM(§13.4(8))) denoting these 
components. So the mapping of these components camnot be influenced by a represen¬ 
tation clause. 


16.5 Address Clauses 


Address clauses are supported for objects declared by an object declaration and for 
single task entries. If an address clause is given for a subprogram, package or a task 
unit, the Compiler responds with a RESTRICTION error message in the Compiler 
listing. 

If an address clause is given for an object, the storage occupied by the object starts at 
the given address. .4ddress clauses for single entries are described in 516.5.1. 


.4isys .4da System - User .Vlanuai 


301 





Chapter 16 


Appendix F: Representation Clauses 


16.5.1 Interrupts 

Under ULTRDC it is not possible to handle hardware interrupts directly within the Ada 
program; all hardware interrupts are handled by the operating system. In ULTRDC, 
asynchronous events are dealt with by signals (cf. sigvec{2)). In the remainder of this 
section the terms signal and interrupt should be regarded as synonyms. 

An address clause for an entry associates the entry with a signal. When a signal 
occurs, a signal catching handler, provided by the Ada runtime system, initiates the 
entry call. 

By this mechanism, an interrupt acts as an entry call to that task; such an entry is 
called an interrupt entry. 

The interrupt is mapped to an ordinary entry call. The entry may also be called by an 
Ada entry call statement. However, it is assumed that when an interrupt occurs there 
is no entry call waiting in the entry queue. Otherwise, the program is erroneous and 
behaves in the following way: 

• If an. entry call stemming from an interrupt is already queued, this previous entry 
call is lost. 

• The entry call stemming from the interrupt is inserted into the front of the entry 
queue, so that it is handled before any entry call stemming from an .Ada entry 
call statement. 


16.5.1.1 Association between Entry and Interrupt 

The association between an entry and an interrupt is achieved via an interrupt number 
(type systen. interrupt-nuaber), the range of interrupt numbers being 1 .. 31 (this 
means that 31 single entries can act as interrupt entries). The meaning of the interrupt 
(signal) numbers is as defined in sigvec{2). A single parameter less entry of a task can be 
associated with an interrupt by an address clause (the Compiler does not check these 
conventions). Since an address value must be given in the address clause, the interrupt 
number has to be converted into type system, address. The array system.interrupt_ 
vector is provided for this purpose; it is indexed by an interrupt number to get the 
corresponding address. 

The following example associates the entry ir with signal SIGINT. 


302 


Alsys Ada System - User Manual 


Appendix F; Representation Clauses 


Chapter 16 


TASK handler IS 
ENTRY ir; 

FOR ir USE AT system.interrupt-vector (system.sigint); 
END: 


The task body contains ordinary accept statements for the entries. 


16.5.1.2 Important Implementation Information 

There are some important facts which the user of interrupt entries should know about 
the implementation. First of all, there are some signals which the user should not 
use within address clauses for entries. These signals sigfpe, sigsegv, sigbus, 
sigill, sigtrap and sigalrm; they are used by the Ada Runtime System to implement 
exception handling and delay statements (sigalrm). Programs containing address 
clauses for entries with these interrupt numbers are erroneous. 

Moreover, the Debug Runtime System establishes a signal catching handler for the 
signal sig’jsrl; hence, during debugging of any program containing an address clause 
for an entry with this interrupt number, the break-in and connect commands (described 
in §8.7.2 and §8.5.1 respectively) cannot be used as described. 

In the absence of address clauses for entries, the Ada Runtime System establishes signal 
catching handlers only for the signab mentioned above, so all other signab will lead 
to program abortion as specified'm the ULTRIX documentation. 

A signal catching handler for a specific signal b established when a task which has an 
interrupt entry for thb signal is activated. The signal catching handler b deactivated 
and the previous handler is restored when the task has been completed. Several tasks 
with interrupt entries for the same signal may exist in parallel; in this case the signal 
catching handler b established when the first of these tasks is activated, and deactivated 
when the last of these tasks has been completed. 


16.6 Change of Representation 

The implementation places no additional restrictions on changes of representation. 


Abys Ada System - User Manual 


303 


Chapter 16 


Appendix F; Representation Clauses 





Appendix F: Input-Output 


Chapter 17 


17 Appendix F: Input-Output 

In this chapter we follow the section numbering of Chapter 14 of the LRM and provide 
notes for the use of the features described in each section. 


17.1 External Files and File Objects 

.An external file is identified by a string that denotes a ULTREX file name. It may 
consist of up to 1023 characters. 

The form string specified for external files is described in §17.2.1.1. 


17.2 Sequential and Direct Files 

Sequential and direct files are ordinary files which are interpreted to be formatted with 
records of fixed or variable length. Each element of the file is stored in one record. 

In case of a fixed record length each file element has the same size, which may be 
specified by a form parameter (see §17.2.1.1); if none is specified, it is determined to 

be [eUmentSIZE t syatem.storage^umt — l)/jyjC«m.jforage_um£. 

In contrast, if a variable record length is chosen, the size of each file element may 
be different. Each file element is wTixten with its actual length. When reading a file 
element its size is determined as follows: 

• If am object of the elenent.tjpe has a size component (see §16.4) the element 
size is determined by first reading the corresponding size component from the file. 

• If eleaent-tvpe is constrained, the size is the minimal number of bytes needed 
to hold a constrained object of that type. 

• In all other cases, the size of the current file element is determined by the size of 
the variable given for reading. 


17.2.1 File Management 


Since there is a lot to say about this section, we shall introduce subsection numbers 
which do not exist in the LRM. 


.Alsys .Ada System - User Manual 


305 



Chapter 17 


Appendix F: Input-Output 


( 


17.2.1.1 The NAME and FORM Parameters 

The naae parameter must be a ULTRDC hJe name. The function nane will return a 
path name string which is the complete file name of the file opened or created. Each 
component of the file name (separated by ”/”) is truncated to 255 characters. Upper 
and lower case letters within the file name string are distinguished. 

The syntax of the fora parameter string is defined by: 

fora.paraaeter ;;= [ fora-specification { , fora_specification } ] 
fora_3pecification ::= keyword [ => value ] 
keyword ;:= identifier 

value :;= identifier I numeric.literal 


For identifier and numeric .literal see LIlM(Appendix E). Only an integer literal 
is allowed as numeric.literal (see LRM(§2.4)). In an identifier or numeric, 
literal, upper and lower case letters are not distinguished. 

In the following, the form specifications which are allowed for all files are described. 


MODE => numeric.literal 


This value specifies the access permission of an external file; it only has an effect in 
a create operation and is ignored in an open. .Access *ights can be specified for the 
owner of the file, the members of a group, and for all other users, numeric.literal 
has to be a three digit octal number. 

The access permission is then interpreted as follows; 


8#40C# 

8 # 200 # 

a#ioo# 

8#040# 

8#004# 


read access by owner 
write access by owner 
execute access by owner 
read access by group 

write/execute access by group, analogously 
read access by all others 

write/execute access by others, analogously 


306 


.•\.lsys .A.da System - User Manual 






Appendix F: Input-Output 


Chapter 17 


Each combination of the values specified above is possible. The default value is 
855 = 666 #. 

The definitive access permission is then determined by the ULTRIX System. It will be 
the specified value for MODE, except that no access right prohibited by the process’s 
file mode creation mask (which may be set by the ULTRIX uaask command, cf. 3 / 1 ( 1 ) 
and umask(2)) is grtinted. In other words, the value of each "digit” in the process’s 
file mode creation mask is subtracted from the corresponding "digit" of the specified 
mode. For example, a file mode creation mask of 8#022# removes group and others 
write pe rmis sion (i.e. the default mode 8#666# would become mode 8#644#). 

The following form specification is allowed for sequential, direct and text files: 


SYNCHRO => OFF I ON I 0N_WAIT 


It allows reader/wTiter synchroni 2 ation of parallel file accesses by different processes, 
such that only one process may write to a file (and no other process may read from 
or write to the same file in parallel) or multiple processes may read a file m parallel. 
This synchronization is achieved through the system call fcntl{2). 

By default parallel accesses are not synchronized (SYNCHRO => OFF). 

If the form specification SYNCHRO ®> OK is given, USE-ERROR is raised when the 
access is not possible (because other processes ara accessing the file when write access is 
requested, or because another process is writing the file when read access is requested). 
If the form specification SYNCHRO *> QN.WAIT is given, the process is blocked when the 
access is not possible for one of the above reasons. When the access becomes possible, 
the process is unblocked. USE-ERROR is not raised with SYNCHRO => 0N_WAIT. 

The following form specification is allowed for sequential and direct files: 


R£COPd)_SIZE => nuneric-literal 


This value specifies the size of one element on the file (record size) in bytes. This form 
specification is only allowed for files with fixed record format. If the value is specified 
for an existing file it must agree with the value of the external file. 

By default, {element^:ype'SIZE — sy3tern.3torage^unit — l)/system.jtorage^unit will be chosen 
as record size, if the evaluation of this expression does not raise an exception. In this 
case, the attempt to create or open a file will raise USE-ERROR. 

If a fixed record format is used, all objects written to a file which are shorter than the 
record size are filled up. The content of this extended record area is undefined. .An 
attempt to write an element which is larger than the specified record size will result 
in the exception use-error being raised. This can only happen if the record size is 
specified explicitly. 


.Alsys .Ada System - User .Manual 


307 



Chapter 17 


Appendix F: Input-Output 


17,2.1.2 Sequential Files 

A sequential 5.1e is represented by an ordinary file that is interpreted to be formatted 
with either fixed-length or variable-length records (this may be specified by the form 
parameter). 

If a fixed record format is used, all objects written to a file which are shorter than 
the maximtim record size are filled up. The content of this extended record area is 
undefined. 


RECQRD.FQRMAT => VARIABLE I FIXED 


This form specification is used to specify the record format. If the format is specified 
for an existing file it must agree with the format of the external file. 

The default is variable record size. This means that each file element is written with 
its actual length. A read operation transfers exactly one file element with its actual 
length. 

Fixed record size means that every record is written with the size specified as record 
size. 


APPEND => FALSE I TRUE 


If the form specification APPEND => TRUE is given for an existing file in an open for an 
output file, then the file pointer will be set to the end of the file after opening, i.e. the 
existing file is extended and not rewritten. This form specification is only allowed for 
an output file; it only has an effect in an open operation and is ignored in a create. By 
default the value FALSE is chosen. 


TRUNCATE *> FALSE I TRUE 


If the form specification TRUNCATE => TRUE is given for an existing file in an open for 
an output file, then the file length is truncated to 0, i.e. the previous contents of the 
file are deleted. Otherwise the file is rewritten, i.e. if the amount of data written is 
less than the file size, data previously written will remain at the end of the file. This 
form specification is only allowed for an output file; it only has an effect in an open 
operation and is ignored in a create. By default the value TRUE is chosen. 


308 


.\lsys Ada System - User Manual 




Appendix F: Input-Output 


Chapter 17 


The default form string for a sequentisJ file is : 

"RECORD-FORMAT => VARIABLE. APPEND *> FALSE. " & 
"TRUNCATE =•> TRUE. MODE => 8#666# " & 

"SYNCHRO => OFF" 


IT.2.1.3 Direct Files 

The implementation dependent type count defined in the package specification of 
direct_io has an upper bound of : 

COUNT'LAST = 2_147_483_647 (= INTEGER'LAST) 

A direct file is represented by an ordinary file that is interpreted to be formatted 
with records of fixed length. If not explicitly specified, the record size is equal to 
[tUmcnt^typt' SIZ E — system.itorage-unit — 1) / system.stor age-unit. 


The default form string for a direct file is : 

"RECORD-SIZE => _ MODE => 8#666#. SYNCHRO => OFF" 


17.3 Text Input-Output 


Text files are sequential character files. 

Each line of a text file consists of a sequence of characters terminated by a line termi¬ 
nator, i.e. an ASCII.LF character. 

.A. page terminator is represented by an .ASCII.FF character and is always preceded by 
a line terminator. 

A file terminator is not represented explicitly in the external file; the end of the file is 
taxen as a file terminator. .A page terminator is assumed to precede the end of the file 
If there is not explicitly one as the last character of the file. 

Output to a file and to a ter min al differ in the following way: If the output refers to 
a terminal it is unbuffered, which means that each write request in an .Ada program 


.Alsys .Ada System - User .Manual 


309 






Chapter 17 


Appendix F; Input-Output 


will appear on the terminal imm ediately. Output to other files is buffered, i.e several 
characters are saved up and written as a block. 

Terminal input is always processed in units of lines. 


17.3.1 File Management 

Besides the mode specification (cf. §17.2.1.1) the following form specification is allowed: 
APPEllD => FALSE I TRUE 


If the form specification APPEND => TRUE is given for an existing file in an open for an 
output file, then the file pointer will be set to the end of the file after opening, i.e. the 
existing file is extended and not rewritten. This form specification is only allowed for 
an output file; it only has an effect in an open operation and is ignored in a create. By 
default the value FALSE is chosen. 

The default form string for a text file is : 

"APPEND => FALSE. MODE => 8#666#. SYNCHRO => OFF" 


17.3.2 Default Input and Output Files 

The standard input (resp. output) file is associated with the standard L^XTRIX files 
stdin resp. stdout. 

Writing to the ULTRIX standard error file stderr may be done by using the package 
text_io_exten3ion (cf. §13.3.4). 


310 


.\lsys .Ada System - User Manual 




Appendix F; Input-Output 


Chapter 17 


17.3.3 Implementation-Defined Types 

The implementation-dependent types count and field defined in the package specifi¬ 
cation of text_io have the following upper bo\inds : 


COUNT•LAST 


2_147_483_647 


INTEGER’LAST) 


FIELD-LAST - 512 


17.4 Exceptions in Input-Output 

For each of narie_error, use.error, device.error and data_error we list the condi¬ 
tions under which that exception can be raised. The conditions under which the other 
exceptions declared in the package io.exceptions can be raised are as described in 
LRM(§14.4). 

NAME-ERROR 

• in an open operation, if the specified file does not exist; 

• if the nane parameter in a call of the create or open procedure is not a legal 
ULTRDC file name string; i.e, if a component of the path prefix is not a directory. 


USE-ERROR 

• whenever an error occurred during an operation of the underlying ULTRDC system. 
This may happen if an internal error was detected, an operation is not possible for 
reasons depending on the file or device characteristics, a capacity limit is exceeded 
or for similar reasons; 

• if the function nane is applied to a temporary file or to the standard input or 
output file; 

• if an attempt is made to write or read to/from a file with fixed record format a 
record which is larger than the record size determined when the file was opened 
(cf. §17.2.1.1); in general it is only guaranteed that a file which is created by an 
Ada program may be reopened and read successfully by another program if the 
file types and the form strings are the same; 

• in a create or open operation for a file with fixed record format (direct file or 
sequential file with fora parameter RECORD-FORMAT => FIXED) if no record size is 
specified and the evaluation of the size of the element type will raise an exception. 


.\lsys Ada System - User Manual 


311 




Chapter IT 


Appendix F: Input-Output 


(For example, if direct_io or sequential_io is instantiated with an unconstrained 
array type.) 

if a given f om patrauneter string does not have the correct syntax or if a condition 
on an individual form specification described in §§17.2-3 is not fulfilled; 
in a create or open operation with form specification SYNCHRO »> ON when the 
requested access is currently not possible; see §17.2.1.1 for the exact conditions. 


DE\1CE_ERR0R 

is never raised. Instead of this exception the exception use_error is raised when¬ 
ever an error occurred during an operation of the underlying ULTREC system. 


DATA_ERR0R 

the conditions under which data_error is raised by text_io are laid down in the 
LRM. 

In general, the exception data_error is not usually raised by the procedure read 
of sequential.io and direct.io if the element read is not a legal value of the 
element type because there is no information about the file type or form strings 
specified when the file was created. 

•An illegal value may appear if the package sequential>io or direct.io was 
instantiated with a different element_t:ype or if a different form partuneter string 
was specified when creating the file. It may also appear if reading a file element 
is done with a constrained object and the constraint of the file element does not 
agree with the constraint of the object. 

If the element on the file is not a legal value of the element t^-pe the effect of 
reading is undefined. .An access to the object that holds the element after reading 
may cause a constrained-error, 3torage_error or non_ada_error. 


17.5 Low Level j.nput-Output 


We give here the specification of the package low_level_io: 


?AC:iAGE lov*_level_io IS 


TYPE device-type IS (null-device); 

TYPE data-type IS 
RES3RD 
.NULL; 


312 


.Alsys .Ada System - User Manual 




Appendix F: Input-Output 


Chapter IT 


END RECORD: 


PROCEDUIIE 

send-control 

(device 

: device-type; 



data 

: IN OUT data_type) 

PROCEDURE 

receive-control 

(device 

; device-type; 



data 

: IN OUT data_type) 


END low_level_io: 


Note that the enumeration type device-type has only one enumeration value, null- 
device; thus the procedures send-control and receive_control can be called, but 
send-control will have no effect on any physical device and the value of the actual 
parameter data after a call of receive_control will have no physical significance. 


Alsys Ada System - User Manual 


313 


% 



314 


Alsys Ada System - User Manual 






