AD-A215 280 


_ UNCLASSIFIED _ 

SEC'U»: t y ClASSI flCAMQN Of This PAG( Qjtj 


Jill riix CG'rJ 


REPORT DOCUMENTATION PAGE 


*i*c wnJL'CnoM 
ITT- ,cv\ r *r- - rtv. 


t. rePori number 


j 2. SQvT Accession NO. 


3. RECIPIENT S CAIALOG NUMBER 


A. T 1 K[ i*naivbvur! 

Ada Compiler Validation Summary Report: tartan 
LABORATORIES INCORPORATED, SUN Ada960MC Compiler V^.O, Sun 
3/50 (Hose) to Intel 80960MC (Target), ACVC 1-10, 
son*-?'TI.10151 __ 


S. TYPE Of REP0R1 1 PERIOD COVERED 
21 June 1989 to 21 June 1990 


6. PERFORMlNG-ORG. REPORT NUMBER 


7. All!NORM 
IABCL* 

Ottobrunn, Federal Republic of Germany. 


t. CON 7 RAC 1 OR ORAN 1 NUMSER(J) 


a. PERFORMING ORGAN 1ZATION AND ADDRESS 
IABG, 

Ottobrunn, Federal Republic of Germany. 


10. PROGRAM ElEmCni, project. TaSi 
AREA A nORl unit Numbers 


'll. CONTRO.UNG Office NAM£ and address 
Ada Joint Program Office 
United States Department of Defense 
Washington, DC 20301-3081 


U. REPORT DATE 


IT . B OHFlR ' DV ' P ius 


14. MONITORING AGENCT NAME A AD0R£SS(/f OiHtrtnt from Controlling Other) 
IABG, 

Ottobrunn, Federal Republic of Germany. 


IS. SECURITY CLASS (of ton report) 

UNCLASSIFIED 


ISi. g^lAS^riCATION.'OOMNGRAOlNG 

N/A 


16. DISTRIBUTION STATEMENT (of tfwj A»porT) 

Approved for public release; distribution unlimited. 


. DISTRIBUTION STAT£Mi.NT (of the sbrtrsct enxerfd m Block 20 If ditter? nr from Report; 

UNCLASSIFIED 


DT1C 


16. SUPPLEMENTARY NOTES 



ELECTE 
DEC041989 


-B 



IB . KEYWORDS (Continue on reverse ude ifneceuey end identify by block number) 

Ada Programming language, Ada Compiler Validation Summary Report; Ada 
Compiler Validation Capability, ACVC, Validation Testing, Ada 
Validation Office, AVO, Ada Validation Facility, AVF, ANSI/KIL-STD- 
1815A, Ada Joint Program Office, AJPO 


20 . ABSTfcAC T (Continue on re*ene sid* if nectary end identity by block number) 

TARTAN LABORATORIES INCORPORATED, SUN Ada960MC Compiler V2.0, Ottobrunn, West Germany, 
Sun-3/50 under Sun OS 3.50 (Host) to Intel 80960MC on Intel EXV960MC board (bare machinej) 

ACVC 1.10. 


DO nJS5 1473 EDITION Of 1 NOV 66 IS OBSOLETE 
1 JAN 71 S/N 0107-Lf•014-6801 


UNCLASSIFIED 


Sf 


// 




SECURITY C l ASS I f 1C AT 1 ON Of TmIS fAGE (W/v*n Dm f Mr 't O) 



Ada Compiler Validation Summary Report: 


Compiler Name: SUN Ada960MC Compiler V2.0 
Certificate Number: #89062111.10151 
Host: Sun 3/50 under SunOS 3.5 

Target: Intel 80960MC on Intel EXV960MC board (bare machine) 
Testing completed 21 June 1989 using ACVC 1.10. 


This report has been reviewed and is approved. 

Dr. S. ileilbrunner 
IABG mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 
West Germany 


^zzm_ 

Ada Validation Organization 
Dr. John F. Kramer 
Institute for Defense Analyses 
Alexandria VA 22311 


Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 


J 







AVF Control Number: AVF-IABG-042 


Ada COMPILER 

VALIDATION SUMMARY REPORT: 
Certificate Number: #89062111.10151 
TARTAN LABORATORIES INCORPORATED 
SUN Ada960MC Compiler V2.0 
Sun 3/50 to Intel 80960MC 


Completion of On-Site Testing: 
21 June 1989 


Prepared By: 
IABG mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 
West Germany 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 


TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION . 1 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.2 

1.3 REFERENCES.3 

1.4 DEFINITION OF TERMS . 3 

1.5 ACVC TEST CLASSES.4 

CHAPTER 2 CONFIGURATION INFORMATION . 7 

2.1 CONFIGURATION TESTED . 7 

2.2 IMPLEMENTATION CHARACTERISTICS . 8 

CHAPTER 3 TEST INFORMATION.13 

3.1 TEST RESULTS.13 

3.2 SUMMARY OF TEST RESULTS BY CLASS.13 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.14 

3.4 WITHDRAWN TESTS.14 

3.5 INAPPLICABLE TESTS . 14 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . 18 

3.7 ADDITIONAL TESTING INFORMATION 

3.7.1 Prevalidation.19 

3.7.2 Test Method.19 

3.7.3 Test Site.20 


APPENDIX 

A 

DECLARATION OF CONFORMANCE 

APPENDIX 

B 

APPENDIX F OF THE Ada STANDARD 

APPENDIX 

C 

TEST PARAMETERS 

APPENDIX 

D 

WITHDRAWN TESTS ( 

APPENDIX 

D 

COMPILER AND LINKER OPTIONS 



Accession For 


NTIS GFAil 
DTIC TAB 
U:mrn ounced 
Just. If '.oat lon_ 




Rv 



| Distribution/ 

Aval 

lability Codes 

Dlat 

I 

Avail aod/or 
Speoinl 





i 


□ □ 



























INTRODUCTION 


CHAPTER 1 
INTRODUCTION 


This Validation Summary Report '--fVStl' describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results of —tesJting this compiler using the Ada Compiler 
Validation Capability # (ACVC). * An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that is 
not in the Standard. 

Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between implementations. 
The Ada Standard permits some implementation dependencies—for example, the 
maximum length of identifiers or the maximum values of integer types. 
Other differences between compilers result from the characteristics of 
particular operating systems, hardware, or implementation strategies. All 
the dependencies observed during the process of testing this compiler are 
given in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. The purpose of validating is to ensure conformity 
of the compiler to the Ada Standard by testing that the compiler properly 
implements legal language constructs and that it identifies and rejects 
illegal language constructs. The testing also identifies behavior that is 
implementation dependent, but is permitted by the Ada Standard. Six 
classes of tests are used. These tests are designed to perform checks at 
compile time, at link time, and during execution. 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 

This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 


1 












INTRODUCTION 


To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by IABG mbH, Ah f SZT according to 
procedures established by the Ada Joint Program Office and administered by 
the Ada Validation Organization (AVO). On-site testing was competed 21 
June 1989 at Tartan Laboratories Inc., Pittsburgh, Pa. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO may 
make full and free public disclosure of this report. In the United States, 
this is provided in accordance with the "Freedom of Information Act" 
(5 U.S.C. #552) . The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject compiler has no nonconformities 
to the Ada Standard other than those presented. Copies of this report are 
available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3031 

or from: 

IABG mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 

Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 





INTRODUCTION 


1.3 REFERENCES 


1. Reference Manual for the Ada Programming Language, 
ANSI/MIL-STD-1815A, February 1983 and ISO 3652-1987. 

2. Ada Compiler Validation Procedures and Guidelines. Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers’ Guide, SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User’s Guide, December 1986. 


1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to the 
Ada programming language. 

An Ada Commentary contains all information relevant to the 
point addressed by a comment on the Ada Standard. These 
comments are given a unique identification number having the 
form Al-ddddd. 

Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

Applicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines. 

AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and technical 
support for Ada validations to ensure consistent practices. 

Compiler A processor for the Ada language. In the context of this 

report, a compiler is any language processor, including 
cross-compilers, translators, and interpreters. 

Failed test An ACVC test for which the compiler generates a result that 

demonstrates nonconformity to the Ada Standard. 


Ada 

Commentary 


Host 


The computer on which the compiler resides. 





INTRODUCTION 


Inapplicable An ACVC test that uses features of the language that a 

test compiler is not required to support or may legitimately 

support in a way other than the one expected by the test. 

Passed test An ACVC test for which a compiler generates the expected 

result. 

Target The computer which executes the code generated by the 

compiler. 

Test A program that checks a compiler's conformity regarding a 

particular feature or a combination of features to the Ad? 
Standard. In the context of this report, the term is used to 
designate a single test, which may comprise one or mors 
files. 

An ACVC test found to be incorrect and not used to check 
conformity to the Ada Standard. A test may be incorrect 
because it has an invalid test objective, fails to meet its 
test objective, or contains illegal or erroneous use of the 
language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name identifies 
the class to which it belongs. Class A, C, D, and E tests are executable, 
and special program units are used to report their results during 
execution. Class B tests are expected to produce compilation errors. 
Class L tests are expected to produce errors because of the way in which a 
program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal Ada 
programs with certain language constructs which cannot be verified at run 
time. There are no explicit program components in a Class A test to check 
semantics. For example, a Class A test checks that reserved words of 
another language (other than those already reserved in the Ada language) 
are not treated as reserved words by an Ada compiler. A Class A test is 
passed if no errors are detected at compile time and the program executes 
to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is compiled and 
the resulting compilation listing is examined to verify that every syntax 
or semantic error in the test is detected. A Class B test is passed if 
every illegal construct that it contains is detected by the compiler. 


Withdrawn 

test 





INTRODUCTION 


Class C tests check the run time system to ensure that legal Ada programs 
can be correctly compiled and executed. Each Class C test is self-checking 
and produces a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when it is executed. 

Class D tests check the compilation and execution capacities of a compiler. 
Since there are no capacity requirements placed on a compiler by the Ada 
Standard for some parameters—for example, the number of identifiers 
permitted in a compilation or the number of units in a library—a compiler 
may refuse to compile a Class D Lest and still be a conforming compiler. 
Therefore, if a Class D rest fails to compile because the capacity of the 
compiler is exceeded, the test is classified as inapplicable. If a Class D 
test compiles successfully, it is self-checking and produces a PASSED or 
FAILED message during execution. 

Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the Ada 
Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is rejected 
by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is attempted. 
A Class L test passes if it is rejected at link time—that is, an attempt 
to execute the main program must generate an error message before any 
declarations in the mam program or any units referenced by the main 
program are elaborated. In some cases, an implementation may legitimately 
detect errors during compilation of the test. 

Two library units, the package REPORT and the procedure CHECK_FILE, support 
the self-checking features of the executable tests. The package REPORT 
provides the mechanism by which executable tests report PASSED, FAILED, or 
NOT APPLICABLE results. It also provides a set of identity functions used 
to defeat some compiler optimizations allowed by the Ada Standard that 
would circumvent a test objective. The procedure CHECK_FTLE is used to 
check the contents of text files written by some of the Class C tests for 
Chapter 14 of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. These tests produce messages that 
are examined to verify that the units are operating correctly. If these 
units are not operating correctly, then the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended to 
ensure that the tests are reasonably portable without modification. For 
example, the tests make use of only the basic set of 55 characters, contain 
lines with a maximum length of 72 characters, use small numeric values, and 
rests. However, some tests contain values that require the test to be 



INTRODUCTION 


cus* - :ed according to implementation-specific values--for example, an 
ill - file name. A list of the values used for this validation is 
provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the tesc or by showing that the test is inapplicable to 
the implementation. The applicability of a test to an implementation is 
considered each time the implementation is validated. A test that is 
inapplicable for one validation is not necessarily inapplicable for a 
subsequent validation. Any test that was determined to contain an illegal 
language construct or an erroneous language construct is withdrawn from the 
ACVC and, therefore, is not used in testing a compiler. The tests 
withdrawn at the time of this validation are given in Appendix D. 






CONFIGURATION INFORMATION 


CHAPTER 2 

CONFIGURATION INFORMATION 


2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under 
following configuration: 


Compiler: SUN Ada960MC Compiler V2.0 
ACVC Version: 1.10 
Certificate Number: #30062111.10151 
Host Computer: 

Machine: Sun 3/50 

Operating System: SunOS 3.5 

Memory Size: 4 MB 


Target Computer: 

Machine: Intel 30960KC on Intel EXV960MC board 
Operating System: bare machine 

Memory Size: 4 MB 


the 







CONFIGURATION INFORMATION 


2.2 IMPLEMENTATION CHARACTERISTICS 

One of the purposes of validating compilers is to determine the behavior of 
a compiler in those areas of the Ada Standard that permit implementations 
to differ. Class D and E tests specifically check for such implementation 
differences. However, tests in other classes also characterize an 
implementati< . 1 . The tests demonstrate the following characteristics: 


a. Capacities. 

1) The compiler correctly processes a compilation containing 
723 variables in the same declarative part. (See test 
D25002K.) 

2) The compiler correctly processes tests containing loop 

statements nested to 65 levels. (See tests D55A03A..H (8 
tests).) 

3) The compiler conectly processes tests containing block 

statements nested to 65 levels. (See test D56001B.) 

4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tests D64005E..G (3 tests).) 

b. Predefined types. 

1) This implementation supports the additional predefined types 
SHORT_INTEGER, BYTE_INTEGER, EXTENDED_FLOAT, and LONG_FLOAT in 
the package STANDARD. (See tests B86001T..Z (7 tests).) 

z. Expression evaluation. 

The order in which expressions are evaluated and the time at which 

constraints are checked are not defined by the language. While 

the ACVC tests do not specifically attempt to determine the order 

of evaluation of expressions, test results indicate the following: 

1) None of the default initialization expressions for record 
components are evaluated before any value is 
checked for membership in a component’s subtype. (See test 
C32117A.) 

2) Assignments for subtypes are performed with the same precision 
as the base type. (See test C35712B.) 

3) This implementation uses no extra bits for extra precision 
and uses all extra bits for extra range. (See test C3 d903A.) 





CONFIGURATION INFORMATION 


4) NUMERIC_ERROR is raised for predefined and largest integer and 
no exception is raised for smallest integer -hen an integer 
literal operand in a comparison or membership test is outside 
the range of the base type. (See test C45232A.) 

5) No exception is raised when a literal operand in a fixed- 

point comparison or membership test is outside the range of 

the base type. (See test C45252A.) 

6) Underflow is gradual. (See tests C45524A..Z (26 

tests).) 

d. Rounding. 

The method by which values are rounded in type conversions is not 
defined by the language. While the ACVC tests do not specifically 

attempt to determine the method of rounding, the test results 

indicate the following: 

1) The method used for rounding to integer is round to even. 

(See tests C46012A..Z (26 tests).) 

2) The method used for rounding to longest integer is round 

to even. (See tests C46012A..Z (26 tests).) 

3) The method used for rounding to integer in static universal 
real expressions is round to even. (See test C4A014A.) 

e. Array types. 

An implementation is allowed to raise NUMERIC_ERROR or 

CONSTRAINT_ERROR for an array having a 'LENGTH that exceeds 
STANDARD.INTEGER'LAST and/or SYSTEM.HAX_INT. For this 
implementation: 

1) Declaration of an array type or subtype declaration with more 

than SYSTEM.MAX_INT components raises NUMERIC_ERROR or 

CONSTRAINT_ERROR for one dimensional array types, two 

dimensional array types and two dimensional array subtypes, 
and no exception for one dimensional array subtypes. (See 
test C36003A.) 

2) CONSTRAINT_ERROR is raised when an array type with 

INTEGER'LAST + 2 components is declared. (See test 

C36202A.) 

3) CONSTRAINT_ERROR is raised when an array type with 

SYSTEM.MAX_INT + 2 components is declared. (See test 

C36202B .) 







CONFIGURATION INFORMATION 


4) A packed BOOLEAN array having a 'LENGTH exceeding INTEGER'LAST 
raises CONST*AINT_ERROR when the array type is declared. (See 
test C52103X.) 

5) A packed two-dimensional BOOLEAN array with more than 

INTEGER'LAST components raises CON^T?.AINT_ERROP when the array 
type is declared and exceeds INTEGER’LAST. (See test 

C52104Y.) 

6) In assigning one-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

7) In assigning two-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression’s subtype is 
compatible with the target's subtype. (See test C52013A.) 

8) A null array with one dimension of length greater 

than INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAINTJERROR 
either when declared or assigned. Alternatively, an implemen¬ 
tation may accept the declaration. However, lengths must 
match in array slice assignments. This implementation raises 
NUMERIC_ERROR when the array type is declared. (See 
test E52103Y.) 

f. Discriminated types. 

1) In assigning record types with discriminants the expression 
is evaluated in its entirety before CONSTRAINT_ERROR is raised 
when checking whether the expression's subtype is compatible 
with the target's subtype. (See test C52013A.) 

g. Aggregates. 

1) In the evaluation of a multi-dimensional aggregate, the test 
results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 

2) In the evaluation of an aggregate containing subaggregates, 
not all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 

3) CCNSTRAINT_ERROR is raised after all choices are 

evaluated when a bound in a non-null range of a non-null 
aggregate does not belong to an index subtype. (See test 

E43211B.) 


17 










CONFIGURATION INFORMATION 


h. Pragmas. 

1) The pragma INLINE is supported for functions and 
procedures but not when applied across compilation units. 
(See tests LA3004A..B (2 tests), EA3004C..D (2 tests), and 
CA3004E..F (2 tests) .) 


i. Generics. 


This compiler enforces the following 
declarations and proper bodies which are 
units: 


two rules concerning 
individual compilation 


o generic bodies must be compiled and completed before their 
instantiation. 

o recompilation of a generic body or any of its transitive 
subunits makes all units obsolete which instantiate that 
generic body. 


These rules are enforced whether the compilation units are in 
separate compilation files or not. AI408 and AI506 allow this 
behaviour. 


1) Generic specifications and bodies can be compiled 

in separate compilations. (See tests CA1012A, CA2009C, 

CA2009F, BC3204C, and BC3205D.) 

2) Generic subprogram declarations and bodies can be 

compiled in separate compilations. (See tests CA1012A and 
CA2009F.) 

3) Generic library subprogram specifications and bodies can be 
compiled in separate compilations. (See test CA1012A.) 

4) Generic non-library package bodies as subunits can 

be compiled in separate compilations. (See test CA2009C.) 

5) Generic non-library subprogram bodies can be 
compiled in separate compilations from their stubs. (See test 
CA2009F.) 

6) Generic unit bodies and their subunits can be 
compiled in separate compilations. (See test CA3011A.) 

7) Generic package declarations and bodies can be 
compiled in separate compilations. (See tests CA2009C, 
BC3204C, and BC3205D.) 


8) Generic library package specifications and bodies can be 


: l 












CONFIGURATION INFORMATION 


compiled in separate compilations. (See tests 

BC3204C and BC3205D.) 

9) Generic unit bodies and their subunits can be 
compiled in separate compilations. (See test CA3011A.) 

Input and output. 

1) The package SEQUENTIAL_IO can be instantiated with 

unconstrained array types and record types with 

discriminants without defaults. (See tests AE2101C, EE2201D, 

and EE2201E.) 

2) The package DIRECT_IO can be instantiated with 

unconstrained array types and record types with 

discriminants without defaults. (See tests AE2101H, EE2401D, 

and EE2401G.) 

3) The director, AJPO, has determined (AI-00332) that every call 
to OPEN and CREATE must raise USE_ERROR or NAME_ERROR if file 
input/output is not supported. This implementation exhibits 
this behavior for SEQUEN?IAL_IO, DIRECT_IO, and TEXT_IO. 











TEST INFORMATION 


CHAPTER 3 
TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 475 tests were inapplicable to this implementation. 
All inapplicable tests were processed during validation testing except for 
159 executable tests that use floating-point precision exceeding 
that supported by the implementation, and for 238 executable tests 
that use file operations not supported by the implementation. 
Modifications to the code, processing, or grading for 79 tests were 
required to successfully demonstrate the test objective. (See section 
3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS 
RESULT 

BY 

A 

CLASS 

B 

TEST 

C 

CLASS 

D 

E 

L 

TOTAL 

Passed 

129 

1133 

1861 

17 

14 

44 

3198 

Inapplicable 

0 

5 

454 

0 

14 

2 

475 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 


TOTAL 


130 1140 2350 17 34 46 3717 










TEST INFORMATION 


3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 

2 

3 

4 

5 

6 

CHAPTER 
7 8 

9 

10 

11 

12 

13 

14 

TOTAL 

Passed 

201 

592 

569 

245 

172 

99 

163 

332 

127 

36 

252 

334 

76 

3198 

M/A 

11 

57 

111 

3 

0 

0 

3 

0 

10 

0 

0 

35 

245 

475 

Wdrn 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

630 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 

The following 44 tests were withdrawn from ACVC Version 1.10 
at the time of this validation: 


E28005C 

A39005G 

B97102E 

C97116A 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A84N 

CD2A84M 

CD5011O 

CD2B15C 

CD7205C 

CD2D11B 

CD5007B 

ED7004B 

ED7005C 

ED7005D 

ED70O6C 

ED7006D 

CD7105A 

CD7203B 

CD7204B 

CD7205D 

CE2107I 

CE3111C 

CE3301A 

CE3411B 






See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of features 
that a compiler is not required by the Ada Standard to support. Others may 
depend on the result of another test that is either inapplicable or 
withdrawn. The applicability of a test to an implementation is considered 
each time a validation is attempted. A test that is inapplicable for one 
validation attempt is not necessarily inapplicable for a subsequent 
attempt. For this validation attempt, 475 tests were inapplicable for the 
reasons indicated: 

a. The following 159 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAX_DIGITS: 

C241130..Y (11 tests) C357050..Y (11 tests) 

C357060..Y (11 tests' C357070..Y (11 tests) 


U 












TEST INFORMATION 


C357080..Y (11 tests) C358020..2 (12 tests) 

C457410..Y (11 tests) C453210..Y (11 tests) 

C454210..Y (11 tests) C455210..Z (12 tests) 

C455240..Z (12 tests) C456210..Z (12 tests) 

C456410..Y (11 tests) C46012O..Z (12 tests) 

b. C35702A and B86001T are not applicable because this implementation 
supports no predefined type SHORT_FLOAT. 

c. The following 16 tests are not applicable because this 
implementation does not support a predefined type LONG_INTEGER: 

C45231C C45304C C45502C C45503C C45504C 

C45504F C45611C C45613C C45614C C45631C 

C45632C B52004D C55B07A B55B09C B86001V 

CD7101F 

d. C45531M..P (4 tests) and C45532M..P (4 tests) are not applicable 
because the value of SYSTEM.MAX_MANTISSA is less than 32. 

e. B86001Y is not applicable because this implementation supports no 
predefined fixed-point type other than DURATION. 

f. CA2009A, CA2009C, CA2009F and CA2009D are not applicable because 

this compiler creates dependencies between generic bodies, and 
units that instantiate them (see section 2.2i for rules and 
restrictions concerning generics) . 

g. LA3004A, LA3004B, EA3004C, EA3004D, CA3004E, and CA3004F are not 
applicable because this implementation does not support pragma 
INLINE when applied across compilation units (See Appendix F of 
the Ada Standard in Appendix B of this report, and Section 2.2.h 
( 1 >>. 

h. CD1009C, CD2A41A..E (5 tests), and CD2A42A..J (10 tests) are not 
applicable because this implementation imposes restrictions on 
'SIZE length clauses for floating point types. 

i. CD2A61I is not applicable because this implementation imposes 
restrictions on 'SIZE length clauses for array types. 

j. CD2A84B..I (8 tests) and CD2A84K..L (2 tests) are not applicable 
because this implementation imposes restrictions on 'SIZE length 
clauses for access types. 

k. CD2A91A..E (5 tests) are not applicable because 'SIZE length 
clauses for task types are not supported. 


1. CD2B11G is not applicable because 'ST0RAGE_SIZE representation 


15 










TEST INFORMATION 


clauses are not supported for access types where the designated 
type is a task type. 


CD2B15B is not applicable because a collection size larger than 
the size specified was allocated. 

The following 238 tests are inapplicable because sequential, text, 
and direct access files are not supported: 


CE2102A..C 

(3 

tests) 

CE2102G..H 

(2 

tests) 

CE2102K 



CE2102N..Y 

(12 tests) 

CE2103C. . D 

(2 

tests) 

CE2104A..0 

(4 

tests) 

CE2105A..B 

(2 

tests) 

CE2106A..B 

(2 

tests) 

CE2107A..H 

(8 

tests) 

CE2107L 



CE2108A..B 

(2 

tests) 

CE2108C..H 

(6 

tests) 

CE2109A..C 

(3 

tests) 

CE2110A..D 

(4 

tests) 

CE2111A..1 

(9 

tests) 

CE2115A..B 

(2 

tests) 

CE2201A..C 

(3 

tests) 

CE2201F..N 

(9 

tests) 

CE2204A..D 

(4 

tests) 

CE2205A 



CE2208B 



CE2401A..C 

(3 

tests) 

CE2401E..F 

(2 

tests) 

CE2401H..L 

(5 

tests) 

CE2404A..B 

(2 

tests) 

CE2405B 



CE2406A 



CE2407A..B 

(2 

tests) 

CE2408A..B 

(2 

tests) 

CE2409A..B 

(2 

tests) 

CE2410A..B 

(2 

tests) 

CE2411A 



CE3102A..B 

(2 

tests) 

EE3102C 



CE3102F..H 

(3 

tests) 

CE3102J..K 

(2 

tests) 

CE3103A 



CE3104A..C 

(3 

tests) 

CE3107B 



CE3108A..B 

(2 

tests) 

CE3109A 



CE3110A 



CE3111A..B 

(2 

tests) 

CE3111D..E 

(2 

tests) 

CE3112A..D 

(4 

tests) 

CE3114A..B 

(2 

tests) 

CE3115A 



EE3203A 



CE3208A 



EE3301B 



CE3302A 



CE3305A 



CE3402A 



EE3402B 



CE3402C..D 

(2 

tests) 

CE3403A..C 

(3 

tests) 

CE3403E..F 

(2 

tests) 

CE3404B. .D 

(3 

tests) 

CE3405A 



EE3405B 



CE3405C..D 

(2 

tests) 

CE3406A..D 

(4 

tests) 

CE3407A..C 

(3 

tests) 

CE3408A..C 

(3 

tests) 

CE3409A 



CE3409C..E 

(3 

tests) 

EE3409F 



CE3410A 



CE3410C..E 

(3 

tests) 

EE3410F 



CE3411A..B 

(2 

tests) 

CE3412A 



EE3412C 



CE3413A 



CE3413C 



CE3602A..D 

(4 

tests) 

CE3603A 



CE3604A..B 

(2 

tests) 

CE3605A..E 

(5 

tests) 

CE3606A..B 

(2 

tests) 

CE3704A..F 

(6 

tests) 

CE3704M..0 

(3 

tests) 

CE3706D 



CE3706F. .G 

(2 

tests) 




Tvs? I NFC PM?. 7 " TOM 


CE38C4A..P (16 tests) 
CE3806A..8 (2 tests) 
CE3806G..H (2 tests) 
CE3905L 

CE3906E..F (2 tests) 


CE3S05A..B (2 tests) 
CE3806D..E (2 tests) 
CE3905A..C (3 tests) 
CE3906A..C (3 tests) 


These tests were not processed because their inapplicability can 
be deduced from the result of other tests. 


o. Tests CE2103A..B (2 tests) and CE3107A raise USE_ERROR although 
NAME_ERROR is expected. These tests report FAILED but they were 
graded not applicable as permanent files are not supported by this 
implementation, and no illegal file names exist. 

p. EE2201D, EE2201E, EE2401D, EE2401G are inapplicable because 

sequential, text, and direct access files are not supported. 






TEST INFORMATION 


3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases where 
legitimate implementation behavior prevents the successful completion of an 
(otherwise) applicable test. Examples of such modifications include: 
adding a length clause to alter the default size of a collection; splitting 
a Class B test into subtests so that all errors are detected; and 
confirming that messages produced by an executable test demonstrate 
conforming behavior that was not anticipated by the test (such as raising 
one exception instead of another) . 

Modifications were required for 79 tests. 

a. The following tests were split because syntax errors at one point 
resulted in the compiler not detecting other errors in the test: 


B22003A 

B24007A 

B24009A 

B25002B 

B32201A 

B34005N 

B34005T 

B34007H 

B35701A 

B36171A 

B 3 6 2 01A 

B37101A 

B37102A 

B37201A 

B37202A 

B37203A 

B37302A 

B38003A 

B38003B 

B38008A 

B38008B 

B38009A 

B38009B 

B33103A 

B38103B 

B38103C 

B38103D 

B38103E 

B43202C 

B44002A 

B48002A 

B48002B 

B48002D 

B48002E 

B43002G 

B43003E 

B49003A 

B49005A 

B49006A 

B49007A 

B49009A 

B4A010C 

B54A20A 

B54A25A 

B58002A 

B58002B 

B59001A 

B59001C 

B59001I 

B62006C 

B67001A 

B67001B 

B67001C 

B67001D 

B74103E 

B74104A 

B85007C 

B91005A 

B95003A 

B95007B 

B95031A 

B95074E 

BC1002A 

BC1109A 

3C1109C 

BC1206A 

BC2001E 

BC3005B 

BC3009C 

BD5005B 




b. For the two tests BC3204C and BC3205D, the compilation order was 
changed to 

BC3204C0, Cl, C2, C3M, C4, C5, C6, C3M 
and 

BC3205D0, D2, DIM 

respectively. This change was necessary because of the compiler's 
rules for separately compiled generic units (see section 2.2i for 
rules and restrictions concerning generics) . When processed in 
this order the expected error messages were produced for BC3204C3M 
and BC3205D1M. 

c. The two tests BC3204D and BC3205C consist of several compilation 
units each. The compilation units for the main procedures are 
near the beginning of the files. When processing these files 
unchanged, a link error is reported instead of the expected 
compiled generic units. Therefore, the compilation files were 
modified by appending copies of the main procedures to the end of 


13 











TEST INFORMATION 


these files. When processed, the expected error messages were 
generated by the compiler. 

d. Tests C39005A, CD7004C, CD7005E and CD7006E wrongly presume an 

order of elaboration of the library unit bodies. These tests were 
modified to include a PRAGMA ELABORATE (REPORT); 

e. Test E28002B checks that predefined or unrecognized pragmas may 
have arguments involving overloaded identifiers without enough 
contextual in+ormation to resolve the overloading. It also checks 
the correct processing of pragma LIST. For this implementation, 
pragma LIST is only recognised if the compilation file is compiled 
without errors or warnings. Hence, the test was modified to 
demonstrate the correct processing of pragma LIST. 


For this implementation, the required support package specification, 
SPPRT13SP, was rewritten to provide constant values for the function names. 

For this implementation the tests CE2103A..B (2 tests) and CE3107A raise 
USE_ERROR although NAME_ERROR is expected. These tests report FAILED but 
they were graded PASSED in accordance with the above mentioned ruling of 
the AJPO for implementations which do not support permanent files. 


3.7 ADDITIONAL TESTING INFORMATION 

3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 produced 
by this implementation was submitted to the AVF by the applicant for 
review. Analysis of these results demonstrated that the compiler 
successfully passed all applicable tests, and the compiler exhibited 
the expected behavior on all inapplicable tests. 

3.7.2 Test Method 

Testing of the SUN Ada960MC Compiler V2.0 using ACVC Version 1.10 was 
conducted by IABG on the premises of TARTAN. The configuration in which 
the testing was performed is described by the following designations 
of hardware and software components: 


Host Computer: 

Machine: Sun 3/50 

Operating System: SunOS 3.5 

Memory Size: 8 MB 





TEST INFORMATION 


Target Computer: 

Machine: Intel 30960MC on Intel EXV960MC board 

Operating System: bare machine 

Memory Size: 4 MB 


Compiler: 

SUN Ada960MC Compiler V2.0 

The original ACVC was customized prior to the validation visit in order to 
remove all withdrawn tests and tests requiring unsupported floating point 
precisions. Tests that make use of implementation specific values were 
also customized. Tests requiring modifications during the prevalidation 
testing were modified accordingly. 

A tape containing the customized ACVC was read on a VAXstation and compared 
against the ACVC present on the host computer making use of an Ethernet 
connection and a comparison program. 

The full set of tests was compiled and linked. All executable tests were 
transferred via an RS232 line to the target computer where they were run. 
Results were transferred to the host computer in the same way. Results were 
then transfered via an Ethernet connection to another Sun 3/50, where they 
were evaluated and archived. 

The compiler was tested using command scripts provided by TARTAN 
LABORATORIES INCORPORATED and reviewed by the validation team. The 
compiler was tested using the option setting -q. All chapter B tests were 
compiled with the listing option on (i.e. -la). The linker was called with 
the command 

alib link <testname> 

A full list of compiler and linker options is given in Appendix E. 


3.7.3 Test Site 

Testing was conducted at TARTAN LABORATORIES INCORPORATED, Pittsburgh and 
was completed on 21 June 1989. 


■>n 



DECLARATION OF CONFORMANCE 


APPENDIX A 

DECLARATION OF CONFORMANCE 


TARTAN LABORATORIES INCORPORATED has submitted the following 
Declaration of Conformance concerning the SUN Ada960MC Compiler 
V2.0. 



DECLARATION OF CONFORMANCE 


Compiler Implementor: Tartan Laboratories Incorporated 

Ada Validation Facility: IABG mbH, Dept. SZT 

Ada Compiler Validation Capability (ACVC) Version: 1.10 


Base Configuration 


Base Compiler Name: 
Host Architecture: 

Host OS and Version: 
Target Architecture: 

Target OS and Version: 


SUN £da960MC Compiler V2.0 
SUN 3/50 
SUN OS 3.5 

Intel 80960MC on an Intel EXV80960MC board 
(bare machine) 

Bare Machine 


Implementor's Declaration 

I, the undersigned, representing Tartan Laboratories Incorporated, 
have implemented no deliberate extensions to the Ada Language 
Standard ANSI/MIL-STD-1815A in the compiler listed in this 
declaration. I declare that Tartan Laboratories Incorporated is 
the owner of record of the Ada Language compiler listed above and, 
as such, is responsible for maintaining said compiler in conform¬ 
ance to ANSI/MIL-STD-1815A. All certificates and registrations 
for Ada Language compiler listed in this declaration shall be made 
only in the owner's corporate name. 



Tartan Laboratories Incorporated 
D. L. Evans, President 


Date: ^ -c?3~S7 


Owner's Declaration 

I, the undersigned, representing Tartan Laboratories Incorporated, 
take full responsibility for implementation and maintenance of the 
Ada compiler listed above, and agree to the public disclosure of 
the iinal Validation Summary Report. I declare that all of the 
Ada Language compilers listed, and their host/target performance, 
are in compliance with the Ada Language Standard ANSI/MIL-STD- 
1815A. 



Tartan Laboratories Incorporated 
D. L. Evans, President 


Date: 


6 - 0 ? 3-£9 




CJ CJ 


UT 


? -a 


APPENDIX B 

APPENDIX F OF THE Ad?. STANDARD 

The only allowed implementation dependencies correspond to 
implements': ion-dependent pragmas, *o certain machine-dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain alleged restrictions on representation clauses. The 
implement at i-r.-dependent characteristics of the SUN Ada960NC 
C'—piler ,; 2.9, as described in r his Appendix, are provided by 
TARTAN LABORATORIES INCORPORATED. Unless specifically noted 
other’? i^e. references in this a o o s n d i x are to .remailer 
documentation and net to this report. Implementation-specific 
portions of the package STANDARD.. *?hich are not part of Appendix 
F, are: 


package 




type BYTE INTEGER is rang- -123 .. 127; 
type SHORT_INT£OEP. is range -32"63 .. 32767; 
type INTEGER is range -2147433643 .. 2147483*47; 

type FLOAT is digits 6 range 

-2al.11111111111111111111111#e126 . . 2 # 1.111111111111111llllllll#el26; 

type LONG_FLOAT is digits 15 range 
31.llllllllllllt1111111111111111111111111111111111111lle^l022 
#1.1111111111111111111111111111111111111111111111 111 1lie#1022; 

type EXTENDED_FLOAT is digits 13 range 
-2#1.1111111111111111111111111111111111111111111111111111lllllllllll#el5332 
2#l.11111111111111!111111111111111111111111111111111111111111 llllllt-16332 

type DURATION is delta 0.0001 range -S6400 .. 86400; 


end STANDARD; 












Chapter 5 

Appendix F to MIL-STD-1815A 


This chapter contains the required Appendix F to Military Standard, Ada Programming Language , 
ANSI/MIL-STD-1815A (American National Standards Institute, Inc., February 17, 1083V 

5 . 1 . PRAGMAS 

5.1.1. Predefined Pragmas 

This section summarizes the effects of and restrictions on predefined pragmas. 

• Access collections are not subject to automatic storage reclamation so pragma CONTROLLED has no effect 
Space deallocated by means of UNCHECKED_DEALLOCATiON will be reused by the allocation of new 
objects. 

• Pragma elaborate is fully supported. 

• Pragma inline is supported. 

• Pragma interface is not supported. The implementation-defined pragma foreign_body (see Sec¬ 
tion 5.1.2.2) can be used to interface to subprograms written in other languages. 

• Pragma LIST is supported but has the intended effect only if the command line option -La was supplied 
for compilation, and the listing generated was not due to the presence of errors and/or warnings. 

• Pragma MEMORY_Sl ze is supported. 

• Pragma OPTIMIZE is supported, but on a routine basis only. It does not affect code at the block level 

• Pragma PACK is fully supported. 

• Pragma PAGE is supported but has the intended effect only if the command line option -La was supplied 
for compilation, and the listing generated was not due to the presence of errors and/or warnings. 

• Pragma priority is fully supported. 

• Pragma SUPPRESS is fully supported as required by Ada LRM 11.7. 

• Future releases of the compiler will support the following pragmas: SHARED, STORAGE_UNIT and 
SYSTEM_NAME. 

A warning message will be issued if an unsupported pragma is supplied. 

5.12. Implementation-Defined Pragmas 

Implementation-defined pragmas provided by Tartan are described in the following sections. 

5.12.1. Pragma LINKAGE_NAM£ 

The pragma Li:;*'.-." JTAME associates an Ada entity with a string that is meaningful externally; c.g., to a 
linkage editor. It takes the form 

pragma LINKAGE_NAME t Ada-simple-name. string-constant) 

The Ada-simple-name must be the name of an Ada entity declared in a package specification. This entity must be 


5-1 










V 'H ■Sl.N VDA960MC 


one ’hat has a runtime representation: e.g., a subprogram, exception n object. It may not be a named number or 
string eonstanL The pragma must appear after the declaration of die entity m the same package specification. 

The effect of the pragma is to cause the string-constant to be used in the generated assembly code as an 
extemai name for the associated Ada entity. It is the responsibility of die user to guarantee that this string 
constant is meaningful to the linkage editor and that no illegal linkname clashes arise. 

5.1.2.2. Pragma FOREIGN_BODY 

A subprogram written in another language can be called from an Ada program. Pragma fcrzign_bcdy is 
used to indicate that the body for a non-generic top-level package specification is provided in the form of an 
object module. The bodies for several subprograms may be contained in one object module. 

Use of the pragma FOR£IGN_BODY dictates that all subprograms, excepuons and objects in the package are 
provided by means of a foreign object module. In order to successfully link a program including a foreign body, 
the object module for that body must be provided to the library using the aicb £ a reegr. command described 
in Section 4.7. 

The pragma is of the form: 

pragma FOREIGN_BODY {languagejiame [, elaboration_rouiine name 1) 

The parameter language name is a string intended to allow the compiler to identify the calling convention used 
by the foreign module (but this functionality is not yet in operation). Currently, the programmer must ensure that 
the calling convention and data representation of the foreign body procedures are compatible with those used by 
the Tartan Ada compiler. Subprograms called by tasks should be reentrant. 

The optional elaboration routine name string argument provides a means to initialize the package. The 
routine specified as the elaboration routine name, which will be called for the elaboration of this package body, 
must be a global routine in the object module provided by the user. 

A specification that uses this pragma may contain only subprogram declarations, object decorations that use 
an unconstrained type mark, and number declarations. Pragmas may also appear in the package. The type mark 
for an object cannot be a task type, and the object declaration must not have an initial value expression. The 
pragma must be given prior to any declarations within the package specification. If the pragma is not located 
before the first declaration, or any restriction on the declarations is violated, the pragma is ignored and a warning 
is generated. 

The foreign body is entirely responsible for initializing objects declared in a package utilizing pragma 
FORElGN_BODY. In particular, the user should be aware that the implicit initializations described in LRM 3.2.1 
are not done by the compiler. (These implicit initializations are associated with objects of access types, certain 
record types and composite types containing components of the preceding kinds of types.) 

Pragma LINKAGE__NAME should be used for all declaration® in the package, including any declarations in a 
nested package specification to be sure that there are no conflicting link names. If pragma linkage_name is 
not used, the cross-reference qualifier, -x, (see Section 3.2) should be used when invoking the compiler and the 
resulting cross-reference table of linknames inspected to identify the linknames assigned by the compiler and 
determine that there are no conflicting linknames (see also Section 3.5). 

In the following example, we want to call a function plmn which computes polynomials and is written in C. 











.::: :o \m. std-isua 


package MATH_F r JNCS is 

pragma FOREIGN_BODY <"C"); 

function POLYNOMIAL (X: INTEGER) return INTEGER; 

—Ada spec matching the C routine 
pragma LINKAGE_NAME (POLYNOMIAL, "plmn"); 

—Force compiler to use name "plmn" when referring to this 
-- function 
end MATH_FUNCS; 

with MATH_FUNCS; use MATH_FUNCS 
procedure MAIN is 

X:INTEGER := POLYNOMIAL(10); 

— Will generate a call to "plmn" 
begin . . . 
end MAIN; 

To compile, link and run the above program, you do the following steps: 

1. Compile MATH_FUNCS 

2. Compile MAIN 

3. Obtain an object module (e.g. math. 0) containing the compiled code for plmn. 

4. Issue the command 

alib foreign math_funcs math.O 

5. Issue the command 

alib link main 

Without Step 4, an attempt to link will produce an error message informing you of a missing package body for 
MAT H_FUNC S, 

Using an Ada body from another Ada program library. The user may compile a body written in Ada for a 
specification into the library, regardless of the language specified in the pragma contained in the specification. 
This capability is useful for rapid prototyping, where an Ada package may serve to provide a simulated response 
for the functionality that a foreign body may eventually produce. It also allows the user to replace a foreign body 
with an Ada body without recompiling the specification. 

The user can either compile an Ada body into the library, or use the command alib foreign (See Section 
4.7) to use an Ada body from another library. The Ada body from another library must have been compiled 
under an identical specification. The pragma linkage_name must have been applied to all entities declared in 
the specification. The only way to specify the linkname for the elaboration routine of an Ada body is with the 
pragma FOREIGN_BODY. 

Using Calls to the Operating System. In some cases, the foreign code is actually supplied by the operating 
system (in the case of system calls) or by runtime libraries for other programming languages such as C. Such 
calls may be made using a dummy procedure to supply a file specification to the alib foreigncommand. 
You need a dummy . 0 file which may be obtained in a number of ways. One way is to compile the procedure 

procedure dummy is 
begin 
null; 
end; 

Then, use the library command 

alib foreign pkg dummy.O 

where pkg is the name of the package that contains the pragma LINKAGE_name for the operaung system call. 
For example to use the UNIX system call _3brk in the program TEST: 


5-3 









•S3 MANUAL /'OR SUN \DA%OMC 


Package MEMORY is 

pragma F0REIGN_3CDY { "ASM"); 
procedure get_virtual_memgry (mem: integer.) ,• 
pragma linkage_name (GET_vxrt t jal_memory ( 
end MEMORY; 

with MEMORY; 
procedure TEST is 


begin 

GET_VIRTUAL_MEMORY(MEM); 
end TEST; 

Obtain the ftie dummy . 0 . Then use 

alib foreign memory dummy.0 
to include the body for the system call in the library. 


5 . 2 . IMPLEMENTATION-DEPENDENT ATTRIBUTES 

No implementation-dependent attributes are currently supported. 


5.3. SPECIFICATION OF THE PACKAGE SYSTEM 

The parameter values specified for the 80960MC in package system [LRM 13.7.1 and Appendix C] are: 

package SYSTEM is 

type ADDRESS is address; 

type NAME is (I960KA, I960KB, I960MC) ; 


SYSTEM_NAME 
STORAGE_UNIT 
MEMO RY_SIZE 
MAX_INT 
MIN INT 


constant name : = 19 6 0 MC ; 
constant : » 8 ; 
constant := 4_194_304; 
constant := 2_14 7_4 8 3_64 7; 
constant := -MAX INT - 1; 


MAX DIGITS 


constant := 18; 


MAX_MANT IS SA : constant := 31; 

FINE_DELTA : constant := 2*1.3#e-31; 

TICK : constant := 0.01562 5; 

subtype PRIORITY is INTEGER range 1 . . 16; 
DEFAULT_PRIORITY : constant PRIORITY := PRIORITY'FIRST; 
RUNTIME_ERROR : exception; 
end SYSTEM; 


5 . 4 . RESTRICTIONS ON REPRESENTATION CLAUSES 

The following sections explain the basic restrictions tor representation specifications followed by additional 
restrictions applying to specific kinds of clauses. 


5-4 














\PPENDDC P TO MIL STD- 


5.4.1. Basic Restriction 

The basic restriction on representation specifications [LRM 13.1] that they may be given only for types 
declared in terms of a type definition, excluding a generic_type_defir.ition (LRM 12.1) and a 
private_type_def inition (LRM 7.41. Any representation clause m violation of these rules is not obeyed 
by the compiler, a diagnostic message is issued. 

Further restrictions are explained in the following sections. Any representation clauses violating those restric¬ 
tions are not obeyed but cause a diagnostic message to be issued. 

5.42. Length Clauses 

Length clauses [LRM 13.2] are. in general, supported. For details, refer to the following sections. 

5.42.1. Size Specifications for Types 

The rules and restrictions for size specifications applied to types of various classes are described below. 

The following principle rules apply: 

1. The size is specified in bits and must be given by a static expression. 

2. The specified size is taken as a mandate to store objects of the type in the given size wherever feasible. 
No attempt is made to store values of the type in a smaller size, even if possible. The following rules 
apply with regard to feasibility: 

• An object that is not a component of a composite object is allocated with a size and alignment that 
is referable on the target machine; that is, no attempt is made to create objects of non-referable size 
on the stack. If such stack compression is desired, it can be achieved by the user by combining 
multiple stack variables in a composite object; for example 

type My_Enuirv is (A, B) ; 
for My_enum'size use 1; 

V,W: My_enum; — will occupy two storage 

— units on the 3tack 

— (if allocated at all) 
type rec is record 

V,W: My_enum; 
end record; 
pragma Pack(rec); 

O: rec; — will occupy one storage unit 

• A formal parameter of the type is sized according to calling conventions rather than size 
specifications of the type. Appropriate size conversions upon parameter passing take place 
automatically and are transparent to the user. 

• Adjacent bits to an object that is a component of a composite object, but whose size is 
non-referable, may be affected by assignments to the object, unless these bits are occupied by other 
components of the composite object; that is, whenever possible, a component of non-referable size 
is made referable. 

In all cases, the compiler generates correct code for all operations on objects of the type, even if they are 
stored with differing representational size in different contexts. 

Note: A size specification cannot be used to force a certain size in value operations of the type: for 
example 

type my_int is range 0..65535; 
for my_int'size use 16; -- o.k. 

A,3: my_int; 

. . . A +■ B. . . -- this operation will generally be 
-- executed on 32-bit values 


5-5 




USER MANUAL FOR SUN ADA 


3. A size specification for a type specifies she size for objects of this type and of ail its subtypes. For 
components of composite types, whose subtype would allow a shorter representation of the component, 
no attempt is made to take advantage of such shorter representations. In contrast, for types without a 
length clause, such components may be represented in a lesser number of bits than the number of bits 
required to represent ail values of the type. Thus, in the example 

type MY_INT is range 0 . . 2**15-1; 
for MY_INT'SIZE use 16; — (1) 
subtype SMAL T ,_MY_INT is MY_TNT range 0..255; 
type R us record 

X: SMALL_MY_INT; 
end record; 

the component R.X will occupy 16 bits. In the absence of the length clause at (1), R.X may be represented 

in 8 bits. 

For the following type classes, the size specification must coincide with the default size chosen by the compiler 
for the type: 

• access types 

• floating-point types 

• task types 

No useful effect can be achieved by using size specifications for these types. 

5.433. Size Specification for Scalar Types 

The specified size must accommodate all possible values of the type including the value 0 (even if 0 is not in 
the range of the values of the type). For numeric types with negative values the number of bits must account for 
the sign bit No skewing of the representation is attempted. Thus 
type my_int i.3 range 100.. 101; 
requires at least 7 bits, although it has only two values, while 
type my_int is range -101..-100; 
requires 8 bits to account for the sign bit. 

A size specification for a real type does not affect the accuracy of operations on the type. Such influence 
should be exerted via the accuracy_def inition of the type (LRM 3.5.7, 3.5.9). 

A size specification for a scalar type may not specify a size larger than the largest operation size supported by 
the target architecture for the respective class of values of the type. 

5.433. Size Specification for Array Types 

A size specification for an array type must be large enough to accommodate all components of the array under 
the densest packing strategy explained below in adherence to any alignment constraints on the component type 
(see Section 5.4.7). 

The size of the component type cannot be influenced by a length clause for an array. Within the limits of 
representing all possible values of the component subtype (but not necessarily of its type), the representation of 
components may, however, be reduced to the minimum number of bits, unless the component type cames a size 
specification. 

If there is a size specification for the component type, but not for the array type, the component size is 
rounded up to a referable size, unless pragma PACK is given. This applies even to boolean types or other types 
that require only a single bit for the representauon of all values. 


5-6 











APPENDIX F TO MIL-STT- 


5.42.4. Size Specification for Record Types 

A size specification for a record type does not influence the default type mapping of a record type. The size 
must be at least as large as the number of bits determined by type mapping. Influence over packing of com¬ 
ponents can be exerted by means of (partial) record representation clauses or by Pragma PACK. 

Neither the size of component types, nor the representation of component subtypes can be influenced by j 
length clause for a record. 

The only implementation-dependent components allocated by Tartan Ada in records contain dope information 
for arrays whose bounds depend on discriminants of the record or contain relative offsets of components within a 
record layout for record components of dynamic size. These implementation-dependent components cannot be 
named or sized by the user. 

A size specification cannot be applied to a record type with components of dynamically determined size. 

Note: Size specifications for records can be used only to widen the representation accomplished by padding at 
the beginning or end of the record. Any narrowing of the representation over default type mapping must be 
accomplished by representation clauses or pragma pack. 

5.42.5. Specification of Collection Sizes 

The specification of a collection size causes the collection to be allocated with the specified size. It is 
expressed in storage units and need not be static: refer to package SYSTEM for the meaning of storage units. 

Any attempt to allocate more objects than the collection can hold causes a storage_error exception to be 
raised. Dynamically sized records or arrays may cany hidden administrative storage requirements that must be 
accounted for as part of the collection size. Moreover, alignment constraints on the type of the allocated objects 
may make it impossible to use all memory locations of the allocated collection. Furthermore, some administra¬ 
tive overhead for the allocator must be taken into account by the user (currently 1 word per allocated object). 

In the absence of a specification of a collection size, the collection is extended automatically if more objects 
are allocated than possible in the collection originally allocated with the compiler-established default size. In this 
case, STORAGE_ERROR is raised only when the available target memory is exhausted. If a collection size of 
zero is specified, no access collection is allocated. 

5.42.6. Specification of Task Activation Size 

The specification of a task activation size causes the task activation to be allocated with the specified size, it 
is expressed in storage units: refer to package SYSTEM for the meaning of storage units. 

If the storage specified for a task activation (T' Storage_Size) is not a multiple of 40% (one page), the 
compiler allocates the next higher multiple of 4096, as permitted by the language. 

Any attempt to exceed the activation size during execution causes a 3TORAGE_ERROR exception to be 
raised. Unlike collections, there is generally no extension of task activations. 

5.42.7. Specification of ' SMALL 

Only powers of 2 are allowed for ' SMALL. 

The length of the representation may be affected by this specification. If a size specification is also given for 
the type, the size specification takes precedence: the specification of ' small must then be accommodatable 
within the specified size. 

5.4.3. Enumeration Representation Clauses 

Forenumeration representation clauses [LRM 13.31, the following restrictions apply: 

• The internal codes specified for the ’iterais 'he enumeration type may be any integer value between 
INTEGER' EIRST and INTEGER' LAST, it is ^trongiy advised to not provide a representation clause that 
merely duplicates the default mapping of enumeration types, which assigns consecutive numbers in as¬ 
cending order starting with 0, since unnecessary runtime cost is incurred by such duplication. It should be 
noted that the use of attri fcutes on enurr.ernEvM -"T*uj ^ mi -Lacr■ specified encodings is costly at run time. 










VSF.R MAVr \L70RSO: '.DA' 1 - ' 


• Array types, whose index type ;s an enumeration type with non-contiguous value encodings, consist of a 
contiguous sequence of components. Indexing into the array involves a runtime translation of the index 
value into the corresponding posidon value of the enumeration type. 

5.4.4. Record Representation Clauses 

The alignment clause of record representation clauses [LRM 13.4] is observed. The specified expression 
must yield a target-dependent value. 

Static objects may be aligned at powers of 2 up to a page boundary. The specified alignment becomes the 
minimum alignment of the record type, unless the minimum alignment of the record forced by the component 
allocation and the minimum alignment requirements of the components is already more stringent than the 
specified alignment 

The component clauses of record representation clauses are allowed only for components and discriminants 
of statically determinable size. Not all components need to be present Component clauses for components of 
variant parts are allowed only if the size of the record type is statically determinable for every variant 

The size specified for each component must be sufficient to allocate all possible values of the component 
subtype (but not necessarily the component type). The location specified must be compatible with any alignment 
constraints of the component type; an alignment constraint on a component type may cause an implicit alignment 
constraint on the record type itself. 

If some, but not all, discriminants and components of a record type are described by a component clause, then 
the discriminants and components without component clauses are allocated after those with component clauses; 
no attempt is made to utilize gaps left by the user-provided allocation. 

5.4.5. Address clauses 

Address clauses [LRM 13-5] are supported with the following restrictions; 

• When applied to an object, an address clause becomes a linker directive to allocate the object at the given 
address. For any object not declared immediately within a top-level library package, the address clause is 
accepted but meaningless. Address clauses applied to local packages are not supported by Tartan Ada. 
Address clauses applied to library packages are prohibited by the syntax; therefore, an address clause can 
be applied only to a package if it is a body stub. 

• Address clauses applied to subprograms and tasks are implemented according to the LRM rules. When 
applied to an entry, the specified value identifies an interrupt in a manna customary for the target. 
Immediately after a task is created, a runtime call is made for each of its entries having an address clause, 
establishing the proper binding between the entry and the interrupt. 

• Specified addresses must be constants. 

• Address clauses specify virtual, not physical, addresses. 

5.4.6. Pragma PACK 

Pragma pack [LRM 13.1] is supported. For details, refer to the following sections. 

5.4.6.1. Pragma PACK for Arrays 

If pragma pack is applied to an array, the densest possible representation is chosen. For details of packing, 
refer to the explanation of size specifications for arrays (Section 5.4.Z.3). 

If, in addition, a length clause is applied to 

1. the array type, the pragma has :io effect, .since such a length clause already uniquely determines the array 
packing method. 

2. the component type, the array is packed densely, observing the component’s length clause. Note that the 
component length clause may iiave the effect of preventing die compiler from packing as densely as 


5-8 










vPPENDIX r TO MIL-iTE- 


would be ihc default if pragma PACK is applied where there was no length clause given for the com¬ 
ponent type. 


5.4.6.2. The Predefined Type Sirin? 

Package Stacie arc applies Pragma PACK to the type 3t ring. However, when applied to character arrays, 
this pragma cannot be used to achieve denser packing than is the default for the target; 4 characters per 32-bit 
word. 

5.4.6.3. Pragma PACK for Records 

If pragma PACK is applied to a record, the densest possible representation is chosen that is compatible with 
the sizes and alignment constraints of the individual component types. Pragma PACK has an effect only if the 
sizes of some component types are specified explicitly by size specifications and are of non-referable nature. In 
the absence of pragma PACK, such components generally consume a referable amount of space. 

It should be noted that default type mapping for records maps components of boolean or other types that 
require only a single bit to a single bit in the record layout, if there are multiple such components in a record. 
Otherwise, it allocates a referable amount of storage to the component. 

If pragma PACK is applied to a record for which a record representation clause has been given detailing the 
allocation of some but not all components, the pragma PACK affects only the components whose allocation has 
not been detailed. Moreover, the strategy of not utilizing gaps between explicitly allocated components still 
applies. 

5.4.7. Minimal Alignment for Types 

Certain alignment properties of values of certain types are enforced by the type mapping rales. Any represen¬ 
tation specification that cannot be satisfied within these constraints is not obeyed by the compiler and is ap¬ 
propriately diagnosed. 

Alignment constraints are caused by properties of the target architecture, most notably by the capability to 
extract non-aligned component values from composite values in a reasonably efficient manner. Typically, restric¬ 
tions exist that make extraction of values that cross certain address boundaries very expensive, especially in 
contexts involving array indexing. Permitting data layouts that require such complicated extractions may impact 
code quality on a broader scale than merely in the local context of such extractions. 

Instead of describing the precise algorithm of establishing the minimal alignment of types, we provide the 
general rale that is being enforced by the alignment rules: 

• No object of scalar type including components or subcomponents of a composite type, may span a target- 
dependent address boundary that would mandate an extraction of the object’s value to be performed by two 
or more extractions. 

53. IMPLEMENTATION-GENERATED COMPONENTS IN RECORDS 

The only implementation-dependent components allocated by Tartan Ada in records contain dope information 
for arrays whose bounds depend on discriminants of the record. These components cannot be named by the user. 

5.6. INTERPRETATION OF EXPRESSIONS APPEARING IN ADDRESS CLAUSES 

Section 13.5.1 of the Ada Language Reference Manual describes a syntax for associating interrupts with task 
entries. Tartan Ada implements the address clause 

for TOENTRY use at intTE; 

by associating the interrupt specified by incIE with the coentry entry of the task containing this address 
clause. The interpretation of intID is both machine and compiler dependent. 

The Ada runtimes provide interrupts that may be associated with task entries. These interrupts are of type 
System .Address in the ranges 8..243, 252..2S5 , 264..499, and 508..511. Refer to section 8.S.4.4 for further 
explanauon. If the argument is outside those ranges, the program is erroneous. 


5-9 







V •••'• • \ .*v\(C 


5 ."’. RESTRICTIONS ON UNCHECKED CONVERSIONS 

Tartan supports UNCKECKED_CONVERSION with a icstnction that requires the sizes of boih source end 
target types to be known at compile time. The sizes need not be the same. If the value in the source is w ider than 
that in the target, the source value will be truncated. If narrower, it will be zero-extended. Calls on instantiations 
of UNCHEIXSD-OCNVSRSICN are made inline automatically. 

5 . 8 . IMPLEMENTATION-DEPENDENT ASPECTS OF INPUT-OUTPUT PACKAGES 

Tartan Ada supplies the predefined input/output packages DIR£CT_I0, SEQUENTIAL_I0, TEXT_IC, and 
LIW_lsvsl_IC as required by LRM Chapter 14. However, since 80960MC is used in embedded applications 
lacking both standard I/O devices and file systems, the functionality of DIRECT_IC, SEQUENTIAL_I0, and 
TEXT_I I is limited. 

I ;?EIT_II and SEQUENT I AL_IO raise USE_ERROR if a file open or file access is auempted. TEXT_IO 
is supported to CUR.RENT_OUTPUT and from C T JRR£NT_INPUT. A routine that takes explicit file names raises 
U3E_ERRCR. LCW_LEVEL_IO for 80960MC provides an interface by which the user may read and write from 
memory mapped devices. In both the SEND_CONTROL and R£CEIVE_CONTROL procedures, the device 
parameter specifies a device address while the data parameter is the single word of data transferred. 

5 . 9 . OTHER IMPLEMENTATION CHARACTERISTICS 

The following information is supplied in addition to that required by Appendix F to MIL-STD-1815A. 

5.9.1. Definition of a Main Program 

Any Ada library subprogram unit may be designated the main program for purposes of linking (using the 
a lab command) provided that the subprogram has no parameters. 

Tasks initiated in imported library units follow the same rules for termination as other tasks [described in 
LRM 9.4 (6-10)]. Specifically, these tasks are not terminated simply because the mam program has terminated. 
Terminate alternatives in selective wait statements in library tasks are therefore strongly recommended. 

5.9.2. Implementation of Generic Units 

All instantiations of generic units, except the predefined generic unchecked_cqnversion and 
UNCHECXED_DEALLOCATION subprograms, are implemented by code duplications. No attempt at sharing 
code by multiple instantiations is made in this release of Tartan Ada. (Code sharing will be implemented in a 
later release.) 

Tartan Ada enforces the restriction that the body of a generic unit must be compiled before the unit can be 
instantiated. It does not impose the restriction that the specification and body of a generic unit must be provided 
as part of the same compilation. A recompilation of the body of a generic unit will obsolete any units that 
instantiated this generic unit 

5.9.3. Attributes of Type Duration 

The type DURATION is defined with the following characteristics: 

DURATION' DELTA is 0.0001 sec 
DURATION' SMALL is 0.000061 sec 
DURATION' FIRST IS -86400.0 sec 
DURATION'LAST is 86400.0 sec 


5-10 







5.9.4. Values of Integer. [ttributes 

Tartan Ada supports the predefined integer type INTEGER. The range hounds of the predefined type 
INTEGER are: 



3 HC?.T_ I NTS GER' FIRST is -2**15 
SHORT_INTEGER' LAST is 2** 15-1 

3YTE_INTEGER' FIRST is -128 
3YTS_INTEGER' LAST is 127 

The range bounds for subtypes declared in package TEXT_IO are: 

COUNT' FIRST is 0 

COUNT' LAST is INTEGER' LAST - 1 

P0SITI7E_C0UNT' FIRST IS 1 
POSITIVE_COUNT' LAST is INTEGER' LAST - I 

FIELD' FIRST is 0 
FIELD' LAST is 20 

The range bounds for subtypes declared in packages DIRECT_I0 are: 

COUNT'FIRST is 0 

COUNT' LAST is INTEGER' LAST 

POSITIVE__COUNT' FIRST is 1 
POSITIVE COUNT'LAST is COUNT'LAST 


5-11 






5.9.5. Virtues of Floating-Point Attributes 

Tartan Ada supports the predefined floating-point types 
Attribute 

MANTISSA 

EMAX 

EPS! LON’ 

approximately 

SMALL 

approximately 

LARGE 

approximately 

SAFS_EMAX 

SAFE_5MALL 

approximately 

SAFE_LARGE 

approximately 

FIRST 

approximately 

LAST 

approximately 
MACHINE_RADIX 
MACHINE_MANTIS SA 

mach:ne_emax 

MACHINE EMIN 
MACHINE ROUNDS 


: LCAI, HAT. and a:\TENEED_FLCAT 

Value :.t EL L-.I 

6 

21 

84 

lftal). |(K'( MHHVsE-1 
9.53h~4'E-07 

16iO.S(X'()_00C>RE-:i 

2.584<UE-26 

16»0.FFFF_FS0*E+21 

1.9342SE+25 

126 

I6#0.2(XX)_000#E-31 

5.87747E-39 

16#0.3FFF_FE0#E+32 

8.50706+37 

-!6#0.7FFF_FFC#E+32 

-1.70141E+38 

16#0.7FFF_FFC#E+32 
1.70141E+38 

■» 

24 
126 
-126 
TRUE 


5-i: 


MACHINE OVERFLOWS 


TRUE 







Attribute 


D ±. GZ ^ 3 
mantissa 

ZMAX 

EPSILON 

approximately 

SMALL 

approximately 

LARGE 

approximately 

SAFE_EMAX 

3AFE_SMALL 

approximately 

SAFE_LARGE 

approximately 

FIRST 

approximately 

LAST 

approximately 
MACHINE_RADIX 
MACHINE_MANTISSA 
MACHINE_EMAX 
MACHINE_SMIN 
MACHINE_ROUNDS 
MACHINE OVERFLOWS 


lor 1 


15 


204 

16^0.4000 JXXX) J)0()<)_(X )0*E -12 
8.X81784197(XH3E-to 


|r>»0 8000 tX)0()_0()()0j)O(wE-51 
!.,u4lq2;'4?3ioe-o; _ 

16?8).FFFF_FFFF_FFFF_E00#E+51 
2.571 KX)X708143E~61 


1022 

16#0.2000_0000_0000J)00#E-255 
1.1125369292536-308 

16#0.3 FFF_FFFF_FFFF_F80#E+256 
4.4°>42328371557E+307 

-16#0.7FFF_FFFF FFFF_FE#E+256 
-8.988465674312E+307 

16#0.7FFF_FFFF_FFFF_FE0#E+256 
8.9884656743115E+307 


51 

1022 

-1022 


TRUE 


5-13 





Attribute 


IN 


MANTISSA 

EMAX 

EPSILON 

approximately 

SMALL 

approximately 

LARGE 

approximately 

SAFE_EMAX 

SAFE_SMALL 

approximately 

3AFE_LARGE 

approximately 

FIRST 

approximately 

LAST 

approximately 
MACHINE_RADIX 
MACHINE_MANTISSA 
MACHINE_EMAX 
MACHINE_SMIN 
MAC HINE_RCUND S 
MACHINE OVERFLOWS 


til 


i (i=0. OXX) JXXIOJXKX) _0000_0#E-14 
X.h-5M"379884035-17E-19 

:o=o..m/oojk>x)j)ooojxxx)j)#e-6i 

I .'bs6S-3:0()«334226E-74 


! 6=( '.FFFF_FFFF_FFFF_FFF8_0#E+61 
2.82695530364541493E+73 

16382 

16X0.2000_0000_0000_0000_0#E-4096 
1.68105157155604675E-4932 

16#0.3 FFF_FFFF_! 7 FFF_FFFF_0#E-t-4096 
2.97432873339307941E+4931 

-16X0.7FFF FFFF_FFFF_FFFF 8XE+4096 
-5.94865747678615883E+4931 

16X0.7FFF_FFFF_FFFF_FFFF_8#E+4096 
5.94865747678615883E+4931 


63 

16382 

-16382 


• 14 







APPENDIX FTO MIL-$7D-:»i5.\ 


5 . 10 . SUPPORT FOR PACKAGE \1ACHI\E_C0DE 

Package MACHINE_CODE provides die programmer with an interlace through which to request the genera¬ 
tion of any instruction that is available or. the 80960. The ADA960 implementation of package 
MACHINE_C0DE is similar to that described in Secuon 13.8 of the Ada LRM, with several added features. 

5.10.1. Basic Information 

As required by LRM, Section 13.8, a routine which contains machine code inserts may not have any other 
kind of statement, and may not contain an exception handler. The only allowed declarative item is a use clause. 
Comments and pragmas are allowed as usual. 

5.103. Instructions 

A machine code insert has the form :y?£_MAAX' ?.ZZZ ?D_A3G RE GATE, where the type must be one of the 
records defined in package MACHINE_2CDE. Package MACKIN'E_CCDE defines four types of records. Each 
has an opcode and zero to 3 operands. These records are adequate for the expression of all instructions provided 
by the 80960. 

5.10.3. Operands 

An operand consists of a record aggregate which holds all the information to specify it to the compiler. All 
operands have an address mode and one or more other pieces of information. The operands correspond exactly to 
the operands of the instruction being generated. 

5J0J.1. Address Modes 

Each operand in a machine code insen must have an Address J4ode_Name. The address modes provided in 
package MACHlNE_CODE provide access to all address modes supported by the 80960. 

In addition, package MACHINE_CODE supplies the address modes Symbolic_Address and 
Symbol ic_Value which allow the user to refer to Ada objects by specifying object' ADDRESS as the value 
for the operand. Any Ada object which has the 'ADDRESS attribute may be used in a symbolic operand. 
Symbolic_Address should be used when the operand is a true address (that is, a branch target or the source 
of an LDA instruction). Symbolic_Value should be used when the operand is actually a value (that is, one of 
the source operands of an ADD instruction). 

When an Ada object is used as a source operand in an instruction (that is, one from which a value is read), the 
compiler will generate code which fetches the value of the Ada object. When an Ada object is used as the 
destination operand of an instruction, the compiler will generate code which uses the address of the Ada object as 
the destination of the instruction. See secuon 5.10.9 for further details. 

5.10.4. Examples 

The ADA960 implementation of package MACHlNE_CODE makes it possible to specify both simple machine 
code inserts such as 

two_£ormat'(MOV, (Reg_Lit, 5), (Reg, R5)) 
and more complex inserts such as 
three_format' (MULI, 

(Symbolic_Value, Array_Var(X, Y, 27)'ADDRESS), 

(Lit, 123456), 

(Symbolic_Address, Parameter_l'ADDRESS)) 

In the first example, the compiler will emit the instrucuon mov 5, r5. In the second example, the compiler 

wiil first emit whatever tnstrucuons are needed to form the address of Array_var (X, Y, 27), load the 
value found at that address into a register, load 123456 into a register, and then emit the muli instruction. If 
?arametei:_l is not found in a register, the compiler will put the result of the multiplication in a temporary 
register and then store it to ?arameter_I' ADDRESS. Note that the destination operand of the MULI instruc- 


5-15 








USER MANUAL FOR SUN’ AD 


tion is given as a SymboiiC_Addres3. Tins hoids true for all destination operands. The various error checks 
specified in the LRM will be performed on ail compiler-? rated code unless they are suppressed by the 
programmer (either through pragma SUPPRESS, or through a r mand qualifiers). 

5.1U.5. Incurred O per amis 

Two modes of operation are supplied for package machine_CODE: Fixup mode and No_Fixup mode. 
The choice of mode is made with the qualifier /Fixup_Machme_Code or its negation 
/ No__F i x u p_Ma c hi n e_C o de . 

In No_Fixup mode, the specification of incorrect operands for an instruction is considered to be a fatal 
error. In this mode, the compiler will not generate any extra instructions to help you to make a machine code 
insertion. Note that it is still legal to use ' ADDRESS constructs as long as the object which is used meets the 
requirements of the instruction. 

In Fixup mode, if you specify incorrect operands for an instruction, the compiler will do its best to fix up the 
machine code to provide the desired effect. For example, although it is illegal to use a memory address as the 
destination of an ADD instruction, the compiler will accept it and try to generate correct code. In this case, the 
compiler will allocate a temporary register to use as the destination of the ADD, and then store from that register 
to the desired location in memory. 

The compiler will always emit the instruction named in the machine code insert - even if it was necessary to 
fix up all of its operands. In extreme cases this can lead to surprising code sequences. Consider, for example, the 
machine code insert 

Two_Format'(MOV, (Reg_Ind, GO), (Reg_Ind_Di3p, Gl, 128)) 

The MOV instruction requires two registers, but both operands are memory addresses. The compiler will generate 
a code sequence like 

Id (gO), gl2 

mov gl2, gl3 

st gl3, 128(gl) 

Note that the MOV instruction is generated even though a LD ST combination would have been sufficient As a 
result of always emitting the instruction specified by the programmer, the compiler will never optimize away 
instructions which it does not understand (such as SENDSERV), unless they are unreachable by ordinary control 
flow. 

5.10.6. Register Usage 

Since the compiler may need to allocate registers as temporary storage in machine code routines, there are 
some restrictions placed on your register usage. The compiler will automatically free all the registers which 
would be volatile across a call for your use (that is, g0..g7, gl3, and g 14). If you reference any other register, the 
compiler will reserve it for your use until the end of the machine code routine. The compiler will not save the 
register automatically. This means that the first reference to a register which is not volatile across calls should be 
an instruction which saves its value in a safe place. The value of the register should be restored at the end of the 
machine code routine. This rule will help ensure correct operation of your machine code insert even if it is inline 
expanded in another routine. 

The compiler may need several registers to generate code for operand fixups in machine code inserts. If you 
use all the registers, fixups will not be possible. If a fixup is needed, the compiler may require up to three 
registers to guarantee success. In general, when more registers are available to the compiler it is able to generate 
better code. 

5.10.7. Inline Expansion 

Rouunes which contain machine code inserts may be inline expanded into the bodies of other routines. This 
may happen under programmer control through the use of pragma INLINE, or at Optimization Level 3 when the 
compiler selects that optimization as an appropriate action for the given situation. The compiler will treat the 
machine code insert as though it was a call; volaule registers will be saved and restored around it, etc. 


5-16 







APPENDIX F TO .VOL STD-; 


5.10.8. Unsafe Assumptions 

There are a variety of assumptions which should not be made when writing machine code inserts. Violation 
of these assumptions may result in the generation of code which does not assemble or which may not function 
correctly. 

• Do not assume that a machine code insert routine has its own set of local registers. This may not be true if 
the routine is inline expanded into anoiher routine. Explicitly save and restore any registers which are not 
volatile across calls. If you wish to guarantee that a routine will never be inline expanded, you should use 
an Ada separate body for the routine and make sure that there is no pragma INLINE for it. 

• Do not attempt to move multiple Ada objects with a single long instruction such as MCVL or stt. 
Although the objects may be contiguous under the current circumstances, there is no guarantee that later 
changes will permit them to remain contiguous. If the objects are parameters, it is virtually certain that 
they will not be conuguous if the routine is inline expanded into the body of another routine. In the case of 
locals, globals, and own variables, the compiler does not guarantee that objects which are declared tcx- 
tually “next” to each other will be contiguous in memory. If the source code is changed such that it 
declares additional objects, this may change the storage allocation such that objects which were previously 
adjacent are no longer adjacent. 

• The compiler will not generate call site code for you if you emit a call instruction. You must save and 
restore any volatile registers which currently have values in them, etc. If the routine you call has out 
parameters, a large function return result, or an unconstrained result, it is your responsibility to emit the 
necessary instructions to deal with these constructs as the compiler expects. In other words, when you emit 
a call, you must follow the linkage conventions of the routine you are calling. For further details on call 
site code, see Sections 6.4,6.5 and 6.6. 

• Do not assume that the 'ADDRESS on Symbolic_Addre33 or Symbolic_Value operands means 
that you are getting an ADDRESS to operate on. The Address- or Value-ness of an operand is determined 
by your choice of Symbol!c_Addre3 3 or Symbolic_Value. This means that to add the contents of 
X to r3, you should write 

Three_Format'(ADDI, (Symbolic_Value, X'ADDRESS), 

(Reg, R3), (Reg, R3)); 

but to add the address of X to r3, you should write 

Three_Format'(ADDI, (Symbolic_Address, X'ADDRESS), 

(Reg, R3), (Reg, R3)); 

• The compiler will not prevent you from writing register r3 (which is used to hold the address of the current 
exception handler). This provides you the opportunity to make a custom exception handler. Be aware, 
however, that there is considerable danger in doing so. Knowledge of the details on the structure of 
exception handlers will help; see the Tartan Ada Runtime Implementor's Guide. 

5.10.9. Limitations 

The current implementation of the compiler is unable to fully support automatic fixup of certain kinds of 
operands. In particular, the compiler assumes that the size of a data object is the same as the number of bits 
which is operated on by the instruction chosen in the machine code insert. This means that the insert: 

Three_Format' (ADDO, (Symbolic_Value, Byte_Vanable'ADDRESS), 

(Reg, RO) , (Reg, Rl) ) 

will not generate correct code when Byte_variable is bound to memory. The compiler will assume that 
Byte_Vanable is 32 bits, when in fact it is oniv S. and will emit an LD instruction to load the value of 
Byte_Vanable into a register. If, on the other hand. BytaJ/anacle was bound to a register the insertion 
will function properly, as no fixup is needed. 

The compiler generates incorrect code when the BAD and 3ALX instructions are used with symbolic operands 
which are not of the form Routine' ADDRESS To j.*i he effect of an unconditional branch, use the 9 or BX 
instructions instead. 


5-17 









USER MANUAL TOR SUN ADA9MUMC 


Nute that the use of X' ADDRESS in a machine code insert does not guarantee that X will be bound to 
memory. This is a result of the use of ' address to provide a "typeless” method for naming Ada objects in 
machine code inserts. For example, it is legal to say to (Symbolc_Value, X' ADDRESS) in an insert even 
when x is a formal parameter of the machine code routine (and is thus found in a register). 

5.10.10. Package MACHINE CODE 

with system; 
package Machme_Code is 
a 5 bit literal 
type Literal is range D. .31; 

type Mnemonic is 

— includes everything for variants up to 80960MC. The trailing 'p' avoids 

— collision with Ada reserved words. 

(LDOB, LDI3, LDOS, LDIS, LD, LDL, LDT, LDQ, — 0..7 
STOB, STI3, STOS, STIS, ST, STL, STT, STQ, — 8..15 
MOV, MOVL, MOVT, MOVQ, MOVR,MOVRL, MOVRE, — 16..22 
LDA, — 23 

ADDO, ADDI, ADDC, ADDR, ADDRL, — 24..28 

SUBO, SUBI, SUBC, SUBR, SUBRL, — 29..33 

MULO, MULI, EMUL, MULR, MULRL, — 34.. 38 

DIVO, DIVI, EDIV, DIVR, DI'/RL, — 39.. 43 

REMO, REMI, REMR, REMRL, MODI, — 44.. 48 

SHLO, SHRO, SHLI, SHRI, SHRDI, ROTATE, — 49..54 
SCALER, SCALERL, ROUNDR, ROUNDRL, — 55..58 
SQRTR, SQRTRL, SINR, SINRL, — 59..62 
COSR, COSRL, TANR, TANRL, — 63..66 
EXPR, EXPRL, — 67..68 

LOGBNR, LOG8NRL, LOGR, LOGRL, LOGEPR, LOGEPRL, — 69..74 
ATANR, ATANRL, CLASSR, — 75..77 

CLASSRL, CPYSRE, CPYRSRE, — 78..80 
ANDi, NOTAND, ANDNOT, XORi, ORi, — 81.. 85 
NOR, XNOR, NOTi, NOTOR, ORNOT, NAND, — 86..91 
CMPO, CMPI, CMPR, CMPRL, CMPOR, CMPORL, -- 92..97 
CONCMPO, CONCMPI, — 98..99 

CMPINCO, CMPINCI, CMPDECO, CMPDECI, — 100..103 

CVTRI, CVTRIL, CVTZRI, CVTZRIL, CVTIR, CVTILR, — 104..109 
MOVSTR, MOVQSTR, FILL, CMPSTR, — 110..113 

SCANBYTE, — 114 


SETBIT, CLRBIT, NOTBIT, 

CHKBIT, ALTERBIT, 

— 115..1119 

SCANBIT, SPANBIT, 


— 120 

. . 121 

EXTRACT, MODIFY, 


— 122 

. . 123 

3, BX, 


— 124 

. . 125 

3AL, 3ALX, 


— 126.. 127 


BE, BNE, 3L, BLE, 


— 128.. 131 


3G, 3GE, BO, 3NO, 


— 132..135 


CMPOBE, CMPOBNE, 

CMPOBL, 

CMP03LE, CMPOBG, 

CMPOBGE, — 136..141 

CMPIBE, CMPIBNE, 

CMPI3L, 

CMPIBLE, CMPI3G, 

CMPI3GE, — 142..147 

CMPI30, CMPI3NO, 



-- 148 

3BS, BBC, 


— 149 

. . 150 

FAULTE, FAULTNE, 

FAULTL, 

FA’JLTLE, — 151.. 

154 

FAULTG, FACJLTGE, 

FAULTO, 

FAULTNO, — 155.. 

158 

TESTE, TESTNE, TESTL, TESTLE, — 159 

. .162 

TESTG, TESTGE, TESTO, TESTNO, — 163 

. . 166 

MODAC, FLUSHREG, 

SYNCF, 

— 167 

. . 169 


CALL, CALLX, CALLS, RET, — 170.. 173 

— the compiler does not understand the following instructions 

— and will not attempt to ~odify the'-. 

ATADD, ATMOD, " ” — 1 4 .. 17£ 

CONDREC, CONDWAIT, DADDC, -- 175..178 

DMOVT, DSU3C, FMARK, -- 179..181 

INSPACC, LDPHY, LDTIME, — 182..184 

MARX, MODPC, MODTC, — 195. . 19" 

RECEIVE, RESUMPRCS, SAYEPP.C3. 


198..190 







LiER MAN LA J, LOR iLN aDA'JoOM C 


— It has been coordinated with Coder's notion of what -,akes an Operand 
case AN! is 
when Lit = > 

X: Integer; 
when Abs_Addr => 

Addr: System.Address; 
when Reg => 

R_Reg: General_Purpose_Regiater; 
when Reg_Lit => 

Rl_Lit; Literal; 
when Reg_Ind => 

Ri_Reg; General_Purpo3e_Register; 

— For any instruction in which an Addressing_Mode 13 used which has 

— an Offset, the compiler will select either MEMA or MEMB format 

— for the instruction based on the size of the Offset, 
when Reg_Ind_Offset => 

Rid_Reg: General_Purpose_Register; 

Rid_Offset; Integer; 
when Index_Offset => 

Id_Index: General_Purpose_Register; 

Id_Scale: Integer; — Must be 1, 2, A, 8, or 16 

Id_Offset; Integer; 
when Reg_Ind_Index => 

Rii_Reg: General_Purpose_Register; 

Rn_Index: General_Purpose_Register; 

Rii_5cale: Integer; — Must be 1, 2, A, 8, or 16 

when Reg_Ind_Index_Offset => 

Riid^Reg: General_Purpose_Register; 

Riid_Index: General_Purpose_Register; 

Riid_Scale: Integer; — Must be 1, 2, A, 8,or 16 

RildjOffset: Integer; 
when Fp_Reg => 

Fr_Reg: Floating_Point_Register; 
when Flt_Lit => 

Fl_Lit; Floating_Poinf_~-teral; 
when Label => 

L_Addr: System.Address; — Should be the 'ADDRESS of an Ada label 
when Symbolic_Address => 

S_Addr: System.Address; 
when Symbolic_Value => 

S_Value: System.Address; 
end case; 
end record; 

type Zero_Format is 
Record 

Operation: Mnemonic; 
end Record; 

type One_Format is 
Record 

Operation: Mnemonic; 

Operand_l: Operand; 
end Record; 

type Two_Format is 
Record 

Operation: Mnemonic; 

Operand_l: Operand; 

0perand_2: Operand; 
end Record; 

type Three_Format is 
Record 

Operation: Mnemonic; 


5-20 








APPENDIX F TO MEL-STD-1815A 


Operand_l: Operand; 
Operand_2; Operand; 
0perand_3: Operand; 
end Record; 


end Machine Code; 


5-21 



TEST PARAMETERS 


APPENDIX C 
TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, such 
as the maximum length of an input line and invalid file names. A test that 
makes use of such values is identified by the extension .TST in its file 
name. Actual values to be substituted are represented by names that begin 
with a dollar sign. A value must be substituted for each of these names 
before the test is run. The values used for this validation are given 
below. The use of the operator signifies a multiplication of the 
following character, and the use of the character signifies 
concatenation of the preceeding and following strings. The values within 
single or double quotation marks are to highlight character or string 
values: 


Name and Meaning 


Value 


$ACC_SIZE 32 

An integer literal whose value 
is the number of bits sufficient 
to hold any value of an access 
type. 


$BIG_ID1 239 * ’A' & •1* 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID2 except 
for the last character. 

$BIG_ID2 239 * 'A' & '2' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID1 except 
for the last character. 


$BIG_ID3 120 * ’A’ & ’3’ & 119 * ’A’ 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID4 except 
for a character near the middle. 





TEST PARAMETERS 


Marne and Meaning Value 

$BIG_ID4 120 * 'A' & ’4’ & 119 * 'A' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID3 except 
for a character near the middle. 

$BIG_INT_LIT 237 * '0 1 & "298" 

An integer literal of value 298 
with enough leading zeroes so 
that it is the size of the 
maximum line length. 

$8IG_REAL_LIT 235 * ’0’ & "690.0" 

A universal real literal of 
value 690.0 with enough leading 
zeroes to be the size of the 
maximum line length. 

$BIG_STRING1 & 120 * 'A' & "" 

A string literal which when 
catenated with BIG_STRING2 
yields the image of BIG_ID1. 

$BIG_STRING2 "" & 119 * ’A’ 4 '1' & "" 

A string literal which when 
catenated to the end of 
BIG_STRING1 yields the image of 
BIG_ID1. 

SBLANKS 220 * ’ ’ 

A sequence of blanks twenty 
characters less than the size 
of the maximum line length. 

$C0UNT_LAST 2_147_483_646 

A universal integer literal 
whose value is TEXT_I0.COUNT’LAST. 

$DEFAULT_MEM_SIZE 4_194_304 

An integer literal whose value 
is SYSTEM.MEMORY_SIZE. 

SDEFAULT_STOR_UNIT 8 

An integer literal whose value 
is SYSTEM.STORAGE UNIT. 







TEST PARAMETERS 


ffame and Meaning 

Value 

$DEFAULT_SYS_NAME 

The value of the constant 

SYSTEM.SYSTEM_NAME. 

I960MC 

$DELTA_DOC 

A real literal whose value is 
SYSTEM.FINE JJELTA. 

2#1.0#E-31 

$FIELD_LAST 

A universal integer 
literal whose value is 
TEXT_IO.FIELD'LAST. 

20 

$FIXED_NAME 

The name of a predefined 
fixed-point type other than 
DURATION. 

NO_SUCH_FIXED_TYPE 

$FLOAT_NAME 

The name of a predefined 
floating-point type other than 
FLOAT, SHORT_FLOAT, or 
LONG_FLOAT. 

EXTENDED_FLOAT 

$GREATER_THAN_DURATION 

A universal real literal that 
lies between DURATION'BASE'LAST 
and DURATION'LAST or any value 
in the range of DURATION. 

100J300.0 

$GREATER_THAN_DURATION_BASE_LAST 

A universal real literal that is 
greater than DURATION'BASE'LAST. 

100_000_000.0 

$HIGH_PRIORITY 

An integer literal whose value 
is the upper bound of the range 
for the subtype SYSTEM.PRIORITY. 

16 

$ILLEGAL_EXTERNAL_FILE_NAME1 

An external file name which 
contains invalid characters. 

BAD_FILENAME_1* * 

$ILLEGAL_EXTERNAL_FILE_NAME2 

An external file name which 

BAD_FILENAME_2* * 


is too long. 




TEST PARAMETERS 


Name and Meaning 
$INTEGER_EIRST 

A universal integer literal 

whose value is INTEGER’FIRST. 

$INTEGER_LAST 

A universal integer literal 

whose value is INTEGER'LAST. 

$INTEGER_LAST_PLUS_1 

A universal integer literal 

whose value is INTEGER'LAST + 1. 

$LES S_THAN_DURATION 

A universal real literal that 
lies between DURATION’BASE’FIRST 
and DURATION'FIRST or any value 
in the range of DURATION. 

$LESS_THAN_DURATION_BASE_FIRST 

A universal real literal that is 
less than DURATION'BASE'FIRST. 

$LOW_PRIORITY 

An integer literal whose value 
is the lower bound of the range 
for the subtype SYSTEM.PRIORITY. 

$MANTISSA_DOC 

An integer literal whose value 
is SYSTEM.MAX_MANTIS3A. 

$MAX_DIGITS 

Maximum digits supported for 
floating-point types. 

$MAX_IN_LEN 

Maximum input line length 
permitted by the implementation. 

$MAX_INT 

A universal integer literal 
whose value is SYSTEM.MAX_INT. 

$MAX_INT_PLUS_1 

A universal integer literal 
whose value is SYSTEM.MAX_INT+l. 


Value 

-2147483648 

2147483647 

2 _ 147 _ 4 3 3 _ 3 4 8 

- 100 _ 000.0 

- 100 _ 000 _ 000.0 

1 

31 

18 

240 

2147433647 

2 147 483 648 





Name and Meaning 

$MAX_LEN_INT_BASED_LITERAL 

A universal integer based 
literal whose value is 2 #11# 
with enough leading zeroes in 
the mantissa to be MAX_IN_LEN 
long. 

$MAX_LEN_REAL_BASED_LITERAL 

A universal real based literal 
whose value is 16:F.E: with 
enough leading zeroes in the 
mantissa to be MAX_IN_LEN long. 

$MAX_STRING_LITERAL 

A string literal of size 
MAX_IN_LEN, including the quote 
characters. 

$MIN_INT 

A universal integer literal 
whose value is SYSTEM.MIN_INT. 

$MIN_TASK_SIZE 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
no entries, no declarations, and 
"MULL;" as the only statement in 
its body. 

SNAME 

A name of a predefined numeric 
type other than FLOAT, INTEGER, 
SHORT_FLOAT, SHORT_INTEGER, 

LONG_FLOAT, or LONG_INTEGER. 

$NAME_LIST 

A list of enumeration literals 
in the type SYSTEM.NAME, 
separated by commas. 

$NEG_BASED_INT 

A based integer literal whose 
highest order nonzero bit 
falls in the sign bit 
position of the representation 
for SYSTEM.MAX INT. 


TEST PARAMETERS 

Value 

”2:” 4 235 * 'O' 4 "11:" 


"16:” & 233 * 'O' 4 "F.E:” 

"" & 238 * 'A' & "" 

-2147433648 

32 


BYTE_INTEGER 

I960KA, I960KB, I960MC 

81777777777776# 






TEST 


Name and Meaning 
$NEV_MEM_SIZE 

An integer literal whose value 
is a permitted argument for 
pragma MEMORY_SIZE, other than 
SDEFAULT_MEM_SIZE. If there is 
no other value, then use 
$DEFAULT_MEM_SIZE. 

$NEW_STOR_UMIT 

An integer literal whose value 
is a permitted argument for 
pragma STORAGEJJHIT, other than 
$DEFAULT_STOR_UNIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGEJJHIT. 

$NEV_SYS_NAME 

A value of the type SYSTEM.NAME, 
other than $OEFAULT_SYS_NAME. If 
there is only one value of that 
type, then use that value. 

$TASK_SIZE 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
a single entry with one 'IN OUT' 
parameter. 

STICK 

A real literal whose value is 
SYSTEM.TICK. 


PARAMETERS 

Value 
4 194 304 


S 


I960KA 

96 


0.015625 




WITHDRAWN 


N 


APPENDIX D 
WITHDRAWN TESTS 

Some tests are withdrawn from the ACVC because they do net conform to the 
Ada Standard. The following 44 tests had been withdrawn at the time of 
validation testing for the reasons indicated. A reference of the form 
Al-ddddd is to an Ada Commentary. 

a. E28005C This test expects that the string TOP OF PAGE. 

63" of line 204 will appear at the top of the listing page due 
to a pragma PAGE in line 203; but line 203 contains text that 
follows the pragma, and it is this that must appear at the top 
of the page. 

b. A39005G This test unreasonably expects a component clause to 

pack an array component into a minimum size (line 30). 

c. B97102E This test contains an unitended illegality; a select 

statement contains a null statement at the place of a selective 
wait alternative (line 31) . 

d. C97116A This test contains race conditions, and it assumes that 
guards are evaluated indivisibly. A conforming imp 1 ementation 
may use interleaved execution in such a wav that the evaluation 
of the guards at lines 50 & 54 and the execution of task CHANGING- 
_OF_THE_GUARD results in a call to REPORT.FAILED at one of 
lines 52 or 56. 

e. BC3009B This test wrongly expects that circular instantiations 
will be detected in several compilation units even though none of 
the units is illegal with respect to the units it depends on; by 
AI-00256, the illegality need not be detected until execution is 
attempted (line 95) . 

f. CD2A62D This test wrongly requires that an array object's size 
be no greater than 10 although its subtype's size was specified 
to be 40 (line 137) . 

g. CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] These 
tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them 
to a derived subprogram (which implicitly converts them to the 
parent type (Ada standard 3.4:14)). Additionally, they use the 
'SIZE length clause and attribute, whose interpretation is 
considered problematic by the WG9 ARG. 



VITHDR.V-u! TESTS 


h. CD2A81G, CD2A83G, CD2A84N & M, & CD50110 [5 tests] These tests 

assume that dependent tasks will terminate while the main pro¬ 
gram executes a loop that simply tests for task termination; this 

is not the case, and the main program may loop indefinitely 

(lines 74, 85, 86 & 96, 36 & 96, and 58, resp.). 

i. CD2B15C & CD7205C These tests expect that a 'STORAGE_SIZE 

length clause provides precise control over the number of 

designated objects in a collection; the Ada standard 13.2:15 
allows that such control must not be expected. 

j. CD2D11B This test gives a SHALL representation clause for a 

derived fixed-point type (at line 30) that defines a set of 
model numbers that are not necessarily represented in the 
parent type; by Commentary AI-00099, all model numbers of a 

derived fixed-point type must be representable values of the 
parent type. 

k. CD5007B This test wrongly expects an implicitly declared sub¬ 

program to be at the the address that is specified for an un¬ 
related subprogram, (line 303) . 

l. ED7004B, ED7005C & D, ED7006C & D [5 tests] These tests check 

various aspects of the use of the three SYSTEM pragmas; the AVO 
withdraws these tests as being inappropriate for validation. 

m. CD7105A This test requires that successive calls to CALENDAR.- 

CLOCK change by at least SYSTEM.TICK; however, by Commentary 

AI-00201, it is only the expected frequency of change that must 
be at least SYSTEM.TICK—particular instances of change may be 
less (line 29). 

n. CD7203B, & CD7204B These tests use the 'SIZE length clause and 
attribute, whose interpretation is considered problematic by 
the VG9 ARG. 

o. CD7205D This test checks an invalid test objective: it treats 

the specification of storage to be reserved for a task's 
activation as though it were like the specification of storage 
for a collection. 


p. CE2107I This test requires that objects of two similar scalar 
types be distinguished when read from a file—DATA_ERR0R is 
expected to be raised by an attempt to read one object as of 
the other type. However, it is not clear exactly how the Ada 
standard 14.2.4:4 is to be interpreted; thus, this test objective 
is not considered valid. (line 90) 






WITHDRAWN TESTS 


q. CE3111C This lest: requires certain behavior, when two files are 

associated with the same external file, that is not required by 
the Ada standard. 

r. CE3301A This test contains several calls to END_OF_LINE & 
END_OF_PAGE that have no parameter: these calls were intended 
to specify a file, not to refer to STANDARDJCNPUT (lines 103, 
107, 113, 132, & 136). 

s. CE3411B This test requires that a text file's column number be 

set to COUPIT’LAST in order to check that LAYOUT_ERROR is raised 
by a subsequent PUT operation. But the former operation will 
generally raise an exception due to a lack of available disk 

space, and the test would thus encumber validation testing. 








Chapter 3 

Compiling Ada Programs 


The tada command is used to compile and assemble Ada compilation units. 

3.1. THE tada COMMAND FORMAT 

The cada command has this format 

tada [option...] file... [option...] 

Arguments that start with a hyphen are interpreted as options; otherwise, they represent filenames. There 
must be at least one filename, but there need not be any options. Options and filenames may appear in any order, 
and all options apply to all filenames. 

For an explanation of the available options, see Section 3.2. 

If a source file does not reside in the directory in which the compilation takes place, file must include a path 
sufficient to locate the file. It is recommended that only one compilation unit be placed in a file. 

Files are processed in the order in which they appear on the command line. The compiler sequentially 
processes all compilation units in each file. Upon successful compilation of a unit: 

• the Ada program library ada. db is updated to reflect the new compilation time and any new dependencies 

• one or more separate compilation files and/or object files are generated 

If no errors are detected in a compilation unit, tada produces an object module and updates the library. If any 
error is detected, no object code file is produced, a source listing is produced, and no library entry is made for 
that compilation unit. If warnings are generated, both an object code file and a source listing are produced. For 
further details about the process of updating the library, files generated, replacement of existing files, and 
possible error conditions, see Sections 3.3 through 3.6. 

The output from tada is a file with type . o containing object code. Some other files are left in the directory 
as well. TTiey include a file having an extension of . s, containing the compiled code as it is input to the 
assembler and a file having the extension . di, which is a representation of a compilation unit specification. A 
list of the extensions for other files that are left on the directory is given in Section 3.4. 

3.2. OPTIONS 

Command line options indicate special actions to be performed by the compiler or special output file 
properties. 

The following command line options may be used: 

-a Retain the assembly code file. The assembly code file has an extension . s or . ss (see 

Section 3.4). 

-i Cause compiler to omit data segments with the text of enumeration literals. This text is 

normally produced for exported enumeration types in order to support the ' image 
attribute. You should use -i only when you can guarantee that no unit that will import 
the enumeration type will use ' IMAGE. However, if you are compiling a unit with an 
enumeration type that is not visible to other compilation units, this opdon is not needed. 
The compiler can recognize when ' IMAGE is not used and will not generate the sup¬ 
porting strings. 


3-1 






USER MANUAL FOR SUN ADA960MC 


-La Generate a listing, even if no errors were found. The default is to generate a listing only 

if an error is found. 

-Ln Never generate a listing. The default is to generate a listing only if an error is found. 

-Opn Control die level of optimization performed by the compiler, requested by n. The 

optimization levels available are: 

n = 0 Minimum - Performs context determination, constant folding, al¬ 
gebraic manipulation, and short circuit analysis. 

n = 1 Low - Performs level 0 optimizations plus common subexpression 
elimination and equivalence propagation within basic blocks. It also 
optimizes evaluation order. 

n = 2 Space - This is the default if none is supplied. Performs level 1 
optimizations plus flow analysis which is used for common sub¬ 
expression elimination and equivalence propagation across basic 
blocks. It also performs invariant expression hoisting, dead code 
elimination, and assignment killing. Level 2 also performs lifetime 
analysis which is used to improve register allocation. It also performs 
inline expansion of subprogram calls indicated by Pragma INLINE 
which appears in the same compilation unit. 

n - 3 Time - Performs level 2 optimizations plus inline expansion of sub¬ 

program calls which the optimizer decides are profitable to expand 
(from an execution time perspective). Other optimizations which 
improve execution time at a cost to image size arc performed only at 
this level. 

-v Print out compiler phase names. The compiler prints out a short description of each 

compilation phase in progress. 

-q Do not print out compiler phase names. 

-S[ACDEILORSZ] 

Suppress the given set of checks: 

A ACCESS_CHECK 

C CONSTRAINT_CHECK 

D DISCR1 :-<INANT_CHECK 

E ELABORATION_CHECK 

I INDEX_CHECK 

L LENGTH_CHECK 

0 OVERFLOW_CHECK 

R RANGE_CHECK 

S STORAGE_CHECK 

Z "ZERO"DIVISION_CHECK 

The -S option has the same effect as a global pragma SUPPRESS applied to the source 
file. If the source program also contains a pragma SUPPRESS, then a given check is 
suppressed if either the pragma or the switch specifies it; that is, the effect of a pragma 
SUPPRESS cannot be negated with the command line option. See LRM 11.7 for further 
details. Examples are: 

-soz Suppress overflow_check and "zero"division_check. 

-S Suppress all checks. 

-SC Suppress CONSTRAINT_ERROR, equivalent to -sadilr. 


3-2 






COMPILING ADA PROGRAMS 


-x Cause the compiler to generate a cross reference file containing entries of the form 

Ada-name=>linkname at line 

This option will allow users to find the iinkname generated for the given Ada-name, and 
use Iinkname to set breakpoints in debuggers. The file will have the extension . xrf 
(See Section 3.5). 

-000000000 when package MACHINE_CODE is used, possibly generate extra instructions to fix 
incorrect addressing modes in the machine code insertion by altering operand address 
modes when those address modes are used incorrectly. 

-000000200 when package MACHINE_CODE is used, the specification of incorrect operands for an 
instruction is considered to be an error; no code is generated and a listing is produced. 

-000000070 Generate all short calls in the compiled code. Inappropriate use of this switch will cause 
a failure at link time. 

-000000080 Generate short calls within application code and long calls from applications to runtime 
routines. This option is the default 

-000000090 Generate all long calls in the compiled code. 

In addition, the output from the compiler may be redirected using the redirection facility including V for 
stderr; for example 

% tada tax_jpec.ada >4 tax_spec.txt 


3-3 







Chapter 4 

The Ada Program Library 


The Sun Ada960MC Program Librarian, alib, implements the Ada Language requirement for separate 
compilation and dependency control. The program library directory holds ail necessary compilation units, 
including packages that are part of the application under development and any standard packages such as those 
for I/O. 

It also holds a library administration file which is a single database file, ada. db, that records the depen¬ 
dencies among these units and their compilation history. The program library in effect during a compilation may 
be specified explicitly by connecting to the directory containing the library administration file name. 

The term Ada program librarian refers to executable code that manipulates the library; that is, subcommands 
of the library command alib that are discussed in this chapter. 

A compilation unit in a library (library unit or secondary unit) is identified by its Ada-name , which is either a 
simple name (an identifier) or the simple name of a subunit and the name of its ancestor. More information about 
Ada compilation units and program libraries is given in Chapter 10 of the Ada Language Reference Manual. The 
library administraton file does not contain the text of compilation units; it contains only references to files that 
contain the compilation units in their source and compiled forms. 

4.1. THE alib COMMAND 

The alib command invokes the Ada Program Librarian to perform the following operations: 

• Create an Ada program library 

• Delete unit(s) from an Ada library or delete the entire library 

• Check the closure of a library unit 

• Describe the status of a library unit by generating a dependency graph 

• Insert a non-Ada object into die library as the body of a package. 

• Link an executable image. 

The format of the alib command is 
alib subcommand [option...] [argument...] [option...] 

Each operation is requested through a subcommand. All alib subcommands except mklib assume that the 
user’s Ada library exists in the current directory. The following sections discuss the subcommands and their 
appropriate options and arguments. 

The output from the library command may be redirected using the redirection facility including V for 
stderr; for example 

% alib closure stack_package >& stack_package.txt 


4.2. THE mklib SUBCOMMAND 

The mklib command creates an initialized Ada library database file, ada. db, and places it in a directory 
that has been created to hold the library database file and fries required by the library, i.e., separate compilation 
and all compiler-generated files. Standard system and Ada I/O packages are placed in the library directory and 
references to them are recorded in ada. db. 

The format of the mklib command is 
alib mklib [directory] 


4-1 







USER MANUAL FOR SUN ADA960MC 


4.8. THE link SUBCOMMAND 

The link command checks that the unit within the library specified by the user has the legal form for a main 
unit, checks that all its dependencies are consistent, finds all required object files, and links the main program 
with its full closure (See Section 4.5) producing an executable image. The format of the link command is 

alib link [option...] Ada-name [option...] 

where the Ada-name specifies the unit in the library to be made the main program. 

The following options may be used: 

-t Provide a trace of the load command indicating what files are being loaded 

-K Create a shell script file that may be redirected to sh to cause the Ada program to be linked. The 
user assumes full responsibility for the consistency of the program when this script is run instead 
of using the alib link command. 

-M Provide a load map 

-o filename 

Name the final output file from the loader filename 


4-10 





