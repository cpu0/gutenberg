G file copy 


REPORT DOCUMENTATION PAGE 





AD-A223 736 PORT DATE 


S. REPORT TYPE AND DATE* COVE BED 

Final 27 Oct. 1989 to 27 Oct. 1990 


4|llllMOUlllLE Ada Compiler Validation Summary Report :DDC INTER 4-FVP€3P«J 
NATIONAL A/S DACS-386/UNIX, Version 4.4, ICL DRS300 (Host) to ~ 

ICL DRS 300 (Target), 891027S1.10185 

•.AUTHOR'S) 

National Institute of Standards and Technology 

Gaithersburg, MD 

USA 


T. PERFOHHMQ ORQAMZKnON NAVE'S) ANOAOORESS(ES) 

National Institute of Standards and Technology 
National Computer Systems Laboratory 
Bldg. 255, Rm. A266 
Gaithersburg, MD 20899 

USA 


SPOmORMOMONnORMQ AGENCY NAVE'S) AND AOORESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Washington, D.C. 20301-3081 


.PERFORMMQ ORGANIZATION 
REPORT NUMBER 


10. SPONSORMG/MONITORMG AGENCY 
REPORT NUMBER 



!2a. DeTRaunON/AVtALABUTY STATE VC NT 

Approved for public release; distribution unlimited. 


m. MsnmmoN cooe 


IS. ABSTRACT ptodmmJOOaan*; 

DDC INTERNATION A/S DACS-386/UNIX, Version 4.4, Gaithersburg, MD, ICL DRS300 under DRS/NX 
Version 3,Level 1 (Host & Target), ACVC 1.10. _ 


_DTIC 

ftELECTE** 
JUN27.199fll I 

V, a U 




m.mjecttermb Ada programming language, Ada Compiler Validation 
Summary Report, Ada Compiler Validation Capability, Validation 
Testing, Ada Validation Office, Ada Validation Facility, ANSI/MIL 
STD-1815A. Ada Joint Program Office 




CLASSIFIED 


90 0t> 25 122 






















AVF Control Number: NIST89DDC580_3 1.10 
DATE COMPLETED BEFORE ON-SITE: 10-02-89 
DATE COMPLETED AFTER ON-SITE: 10-30-89 

Ada Compiler Validation Summary Report: 

Compiler Name: DACS-386/UNIX, Version 4.4 

Certificate Number: 891027S1.10185 


Host: ICL DRS300 under DRS/NX, Version 3, Level 1 

Target: ICL DRS300 under DRS/NX, Version 3, Level 1 


Testing Completed October 27, 1989 Using ACVC 1.10 


This report has been reviewed and is approved. 




Ada Validation Fabfili 
Dr. David K. JeffWrso 
Chief, Information Systems 
Engineering Division 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 



Ada Validation Fac 
Mr. L. Arnold Jot 
Manager, Software 
Validation Group 
Engineering Division 
National Computer Systems 
Laboratory (NCSL) 
National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


- \ ii - 

Ada Validation Organization 

^ Dr. John F. Kramer 

Institute for Defense Analyses 
Alexandria VA 22311 


' ( 1 

i 

Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 




Accession For_ . 

"ntis CRA&I \S^ 

DTiC TAB □ 

Unannounced Q 

lc«t. Ion- 


By- 

Distr 


.But 1 on,’ 

AvaU./jMHt 

y CoJss 

Diet. 

(H 

A i 1 

uQ-1 / cr 

ua 






AVF C ontr ol Number: NIST89DDC580_3_1.10 
DATE VSR CCMPIETED BEFORE CN-SITE: 10-02-89 
DATE VSR COMPLETED AFTER ON-SITE: 10-30-89 
DATE VSR MO DIFIED PER AVO OCMMENES: 12-14-89 
DATE VSR MODIFIED PER AVO COMMENTS: 04-30-90 


Ada OCMPHER 
VALEDAJTCN SUMMARY REPORT: 
Certificate Number: 891027S1.10185 
DOC INTERNATIONAL A/S 
DACS-386/UNIX, Version 4.4 
ICL ERS300 Host and ICL ERS300 Target 


Ccnpletion of On-Site Testing: 
27 October 1989 


Prepared By: 

Software Standards Validation Group 
National Ccoputer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Roan A266 
Gaithersburg, Maryland 20899 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 






AVF Control Number: NIST89DDC580_3_1.10 
DATE COMPLETED BEFORE ON-SITE: 10-02-89 
DATE COMPLETED AFTER ON-SITE: 10-30-89 

Ada Compiler Validation Summary Report: 

Compiler Name: DACS-386/UNIX, Version 4.4 

Certificate Number: 891027S1.10185 


Host: ICL DRS300 under DRS/NX, Version 3, Level 1 

Target: ICL DRS300 under DRS/NX, Version 3, Level 1 


Testing Completed October 27, 1989 Using ACVC 1.10 


This report has been reviewed and 


A 

1 


V 1 

K ■ . 


L 


Aoa ~ 
Dr. 1 

Validation Fad 
David K. JeffV 

mi 

rsori 

i 



Chief, Information Systems 
Engineering Division 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


is approved. 



Validation Group 
Engineering Division 
National Computer Systems 
Laboratory (NCSL) 
National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


ST) 


Ada Validation Organization 
Dr. John F. Kramer y 

Institute for Defense Analyses 
Alexandria VA 22311 / 


\ 


Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 









TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1-2 

1.2 USE OF THIS VALIDATION SUMMARY REPORT. .1-2 

1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-3 

1.5 ACVC TEST CLASSES.1-4 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED . 2-1 

2.2 IMPLEMENTATION CHARACTERISTICS . 2-2 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.3-1 

3.2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 WITHDRAWN TESTS.3-2 

3.5 INAPPLICABLE TESTS . 3-2 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . .3-6 

3.7 ADDITIONAL TESTING INFORMATION . 3-7 

3.7.1 Prevalidation.3-7 

3.7.2 Test Method.3-7 

3.7.3 Test Site.3-8 

APPENDIX A CONFORMANCE STATEMENT 

APPENDIX B APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 

APPENDIX E COMPILER OPTIONS AS SUPPLIED BY 

DDC INTERNATIONAL A/S 




















CHAPTER 1 


INTRODUCTION 



This Validation Summary Report (VSR) describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results nf frectjng this compiler using the Ada Compiler 
Validation Capability 9 (ACVCj>- An Ada compiler must be implemented 
according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that 
is not in the Standard. ) 


Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between 
implementations. The Ada Standard permits some implementation 
dependencies--for example, the maximum length of identifiers or the 
maximum values of integer types. Other differences between compilers 
result from the characteristics of particular operating systems, 
hardware, or implementation strategies. All the dependencies observed 
during the process of testing this compiler are given in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. \ The purpose of validating is to ensure 
conformity of the compiler to the Ada Standard by testing that the 
compiler properly implements legal language constructs and that it 
identifies and rejects illegal language constructs. The testing also 
identifies behavior that is implementation dependent, but is permitted 
by the Ada Standard. Six classes of tests are used. These tests are 
designed to perform checks at compile time, at link time, and during 
execution. 








1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 


This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 

. To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

. To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

. To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by the AVF according to 
procedures established by the Ada Joint Program Office and administered 
by the Ada Validation Organization (AVO). On-site testing was completed 
27 October 1989 at Lyngby, Denmark. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO 
may make full and free public disclosure of this report. In the United 
States, this is provided in accordance with the "Freedom of Information 
Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do 
not represent or warrant that all statements set forth in this report 
are accurate and complete, or that the subject compiler has no 
nonconformities to the Ada Standard other than those presented. Copies 
of this report are available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 


Software Standards Validation Group 
National Computer Systems Laboratory 
National Institue of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 





Questions regarding this report or the validation test results should be 

directed to the AVF listed above or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.3 REFERENCES 


1. Reference Manual for the Ada Programming Language, 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide, December 1986. 


1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to 
the Ada programming language. 

Ada Commentary An Ada Commentary contains all information relevant 

to the Commentary point addressed by a comment on 
the Ada Standard. These comments are given a 
unique identification number having the form 
Al-ddddd. 

Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

Applicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines . 

AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and 


1-3 






technical support for Ada validations to ensure 
consistent practices. 

Compiler A processor for the Ada language. In the context of 

this report, a compiler is any language processor, 
including cross-compilers, translators, and 
interpreters. 

Failed test An ACVC test for which the compiler generates a result 
that demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 


Inapplicable An ACVC test that uses features of the language that a 
test compiler is not required to support or may legitimately 

support in a way other than the one expected by the 
test. 


Passed test An ACVC test for which a compiler generates the expected 
result. 


Target 


Test 


Withdrawn 


The computer which executes the code generated by the 
compiler. 

A program that checks a compiler's conformity regarding 
a particular feature or a combination of features to the 
Ada Standard. In the context of this report, the term 
is used to designate a single test, which may comprise 
one or more files. 

An ACVC test found to be incorrect and not used to check 
test conformity to the Ada Standard. A test may be 
incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains illegal or 
erroneous use of the language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, 0, E, and L. The first letter of a test name 
identifies the class to which it belongs. Class A, C, D, and E tests 
are executable, and special program units are used to report their 
results during execution. Class B tests are expected to produce 
compilation errors. Class L tests are expected to produce errors 
because of the way in which a program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal 
Ada programs with certain language constructs which cannot be verified 
at run time. There are no explicit program components in a Class A test 


1-4 




to check semantics. For example, a Class A test checks that reserved 
words of another language (other than those already reserved in the Ada 
language) are not treated as reserved words by an Ada compiler. A Class 
A test is passed if no errors are detected at compile time and the 
program executes to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 

Class B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that every 
syntax or semantic error in the test is detected. A Class B test is 
passed if every illegal construct that it contains is detected by the 
compiler. 

Class C tests check the run time system to ensure that legal Ada 
programs can be correctly compiled and executed. Each Class C test is 
self-checking and produces a PASSED, FAILED, or NOT APPLICABLE message 
indicating the result when it is executed. 

Class D tests check the compilation and execution capacities of a 
compiler. Since there are no capacity requirements placed on a compiler 
by the Ada Standard for some parameters--for example, the number of 
identifiers permitted in a compilation or the number of units in a 
library--a compiler may refuse to compile a Class D test and still be a 
conforming compiler. Therefore, if a Class D test fails to compile 
because the capacity of the compiler is exceeded, the test is classified 
as inapplicable. If a Class D test compiles successfully, it is 
self-checking and produces a PASSED or FAILED message during execution. 


Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the 
Ada Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is 
rejected by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is 
attempted. A Class L test passes if it is rejected at link time--that 
is, an attempt to execute the main program must generate an error 
t ess age before any declarations in the main program or any units 
referenced by the main program are elaborated. In some cases, an 
implementation may legitimately detect errors during compilation of the 
test. 

Two library units, the package REPORT and the procedure CHECK_FILE, 
support the self-checking features of the executable tests. The package 
REPORT provides the mechanism by which executable tests report PASSED, 


1-5 






FAILED, or NOT APPLICABLE results. It also provides a set of identity 
functions used to defeat some compiler optimizations allowed by the Ada 
Standard that would circumvent a test objective. The procedure 
CHECK_FILE is used to check the contents of text files written by some 
of the Class C tests for Chapter 14 of the Ada Standard. The operation 
of REPORT and CHECK_FILE is checked by a set of executable tests. These 
tests produce messages that are examined to verify that the units are 
operating correctly. If these units are not operating correctly, then 
the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended 
to ensure that the tests are reasonably portable without modification. 
For example, the tests make use of only the basic set of 55 characters, 
contain lines with a maximum length of 72 characters, use small numeric 
values, and place features that may not be supported by all 
implementations in separate tests. However, some tests contain values 
that require the test to be customized according to 
implementation*specific values-*for example, an illegal file name. A 
list of the values used for this validation is provided in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable 
to the implementation. The applicability of a test to an 
implementation is considered each time the implementation is validated. 

A test that is inapplicable for one validation is not necessarily 
inapplicable for a subsequent validation. Any test that was determined 
to contain an illegal language construct or an erroneous language 
construct is withdrawn from the ACVC and, therefore, is not used in 
testing a compiler. The tests withdrawn at the time of this validation 
are given in Appendix D. 






CHAPTER 2 


CONFIGURATION INFORMATION 


2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under 
the following configuration: 


Compiler: DACS-386/UNIX, Version 4.4 

ACVC Version: 1.10 

Certificate Number: 891027S1.10185 

Host Computer: 

Machine: ICL DRS300 

Operating System: DRS/NX, Version 3, Level 1 
Memory Size: 8 MBytes 

Target Computer: 

Machine: ICL DRS300 


Operating System: DRS/NX, Version 3, Level 1 
Memory Size: 8 MBytes 

Communications Network: VAX-8530 via Ethernet (using DNICP net 

software utility) via SUN-3/60 
Workstation via streamer tape to the ICL 
DRS300. 


2-1 




2.2 IMPLEMENTATION CHARACTERISTICS 


One of the purposes of validating compilers is to determine the behavior 
of a compiler in those areas of the Ada Standard that permit 
implementations to differ. Class D and E tests specifically check for 
such implementation differences. However, tests in other classes also 
characterize an implementation. The tests demonstrate the following 
characteristics: 


a. Capacities. 

(1) The compiler correctly processes a compilation containing 
723 variables in the same declarative part. (See test 
D29002K.) 

(2) The compiler correctly processes tests containing loop 
statements nested to 65 levels. (See tests D55A03A..H (8 
tests).) 

(3) The compiler rejects tests containing block statements 
nested to 65 levels. (See test D56001B.) 

(4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tests D64005E..G (3 tests).) 


b. Predefined types. 

(1) This implementation supports the additional predefined 
types SHORT_INTEGER, LONG_FLOAT, and LONG_INTEGER in the 
package STANDARD. (See tests B86001T..Z (7 tests).) 


c. Expression evaluation. 

The order in which expressions are evaluated and the time at 
which constraints are checked are not defined by the language. 
While the ACVC tests do not specifically attempt to determine 
the order of evaluation of expressions, test results indicate 
the following:' 

(1) All of the default initialization expressions for record 
components are evaluated before any value is checked for 
membership in a component's subtype. (See test C3211' , A.) 


(2) Assignments for subtypes are performed with the same 
precision as the base type. (See test C35712B.) 


2-2 








(3) This implementation uses no extra bits for extra precision 
and uses all extra bits for extra range. (See test 
C35903A.) 

(4) NUMERIC_ERROR is raised when an integer literal operand in 
a comparison or membership test is outside the range of the 
base type. (See test C45232A.) 

(5) NUMERIC_ERROR is raised when a literal operand in a 
fixed-point comparison or membership test is outside the 
range of the base type. (See test C45252A.) 

(6) Underflow is gradual. (See tests C45524A..K (11 tests).) 


d. Rounding. 

The method by which values are rounded in type conversions is 
not defined by the language. While the ACVC tests do not 
specifically attempt to determine the method of rounding, the 
test results indicate the following: 

(1) The method used for rounding to integer is round to even. 
(See tests C46012A..K (11 tests).) 

(2) The method used for rounding to longest integer is round to 
even. (See tests C46012A..K (11 tests).) 

(3) The method used for rounding to integer in static universal 
real expressions is round away from zero. (See test 
C4A014A.) 


e. Array types. 

An implementation is allowed to raise NUMERIC_ERROR or 
CONSTRAINT_ERROR for an array having a 'LENGTH that exceeds 
STANDARD. INTEGER'LAST and/or SYSTEM. MAX_INT. For this 
implementation: 

(1) Declaration of an array type or subtype declaration with 
more than SYSTEM.MAX_INT components raises NUMERIC_ERROR. 
(See test C36003A.) 

(2) NUMERIC_ERROR is raised when 'LENGTH is applied to an array 
type with INTEGER'LAST + 2 components. (See test C36202A.) 


(3) NUMERIC_ERROR is raised when 'LENGTH is applied to an array 
type with SYSTEM.MAX INT + 2 components. (See test 
C36202B.) 


2-3 





(4) A packed BOOLEAN array having a 'LENGTH exceeding 
INTEGER'LAST raises NUMERIC_ERROR when declaring two packed 
Boolean arrays with INTEGER'LAST + 3 components. (See test 
C52103X.) 

(5) A packed two-dimensional BOOLEAN array with more than 
INTEGER'LAST components raises NUMERIC_ERROR when the array 
type is declared. (See test C52104Y.) 

(6) A null array with one dimension of length greater than 
INTEGER'LAST may raise NUMERIC_ERROR or , CONSTRAINT_ERROR 
either when declared or assigned. Alternatively, an 
implementation may accept the declaration. However, 
lengths must match in array slice assignments. This 
implementation raises NUMERIC_ERROR when the array type is 
declared. (See test E52103Y.) 

(7) In assigning one-dimensional array types, the expression is 
evaluated in its entirety before CONSTRAINT_ERROR is raised 
when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

(8) In assigning two-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 


f. Discriminated types. 

(1) In assigning record types with discriminants, the 
expression is evaluated in its entirety before 
CONSTRAINT_ERROR is raised when checking whether the 
expression's subtype is compatible with the target's 
subtype. (See test C52013A.) 


g. Aggregates. 

(1) In the evaluation of a multi-dimensional aggregate, the 
test results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 

(2) In the evaluation of an aggregate containing subaggregates, 
not all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 

(3) CONSTRAINT_ERROR is raised before all choices are evaluated 
when a bound in a non-null range of a non-null aggregate 
does not belong to an index subtype. (See test E43211B.) 


2-4 





h. Pragmas. 


( 1 ) 


The pragma INLINE is supported for functions 
(See tests LA3004A..E (2 tests), EA3004C..D 
CA3004E..F (2 tests).) 


or procedures. 
(2 tests), and 


i. Generics. 

(1) Generic specifications and bodies cannot be compiled in 

separate compilations. (See tests CA2009C, CA2009F, 

BC3204C, and BC3205D.) 

Generic package declarations and bodies can be compiled in 
separate compilations so long as no instantiations of those 
units precede the bodies. This compiler requires that a 
generic unit's body be compiled prior to instantiation, and 
so the unit containing the instantiations is rejected. 

(2) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 

(3) Generic subprogram declarations and bodies can be compiled 
in separate compilations. (See test CA1012A.) 

(4) Generic library subprogram specifications and bodies can be 
compiled in separate compilations. (See test CA1012A.) 

(5) Generic non-library subprogram bodies cannot be compiled in 
separate compilations from their stubs. (See test 
CA2009F.) 

(6) Generic package declarations and bodies cannot be compiled 
in separate compilations. (See tests CA2009C, BC3204C, and 
BC3205D.) 

(7) Generic library package specifications and bodies cannot be 
compiled in separate compilations. (See tests BC3204C and 
BC3205D.) 

(8) Generic non-library package bodies as subunits cannot be 
compiled in separate compilations. (See test CA2009C.) 

(9) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 


j. Input and output. 

(1) The package SEQUENTIAL_IO can be instantiated with 


2-5 






unconstrained array types and record types with 
discriminants without defaults. (See tests AE2101C, 
EE2201D and EE2201E.) 

(2) The package DIRECT_IO can be instantiated with 
unconstrained array types but only if the maximum element 
size supported for DIRECT_IO is 2_147_483_647 bits; 
otherwise, USE_ERROR is raised. (See tests AE2 1 Q1H and 
EE2401D.) 

(3) The package DIRECT_IO can be instantiated with record types 
with discriminants without defaults.' (See test EE2401G.) 

(4) USE_ERROR is raised when Mode IN_FILE is not supported for 

the operation of CREATE for SEQUENTIAL_IO. (See test 

CE2102D.) 

(5) USE_ERROR is raised when Mode IN_FILE is not supported for 
the operation of CREATE for DIRECT_IO. (See test CE2102I.) 

(6) USE_ERROR is raised when Mode IN_FILE is not supported for 

the operation of CREATE for text files. (See test 

CE3102E.) 

(7) Modes IN_FILE and OUT_FILE are supported for text files. 
(See test CE3102I..K). 

(8) RESET and DELETE operations are supported for 
SEQUENTIAL_IO. (See tests CE2102G and CE2102X.) 

(9) RESET and DELETE operations are supported for DIRECT_IO. 
(See tests CE2102K and CE2102Y.) 

(10) RESET and DELETE operations are supported for text files. 
(See tests CE3102F..G (2 tests), CE3104C, CE3110A, and 
CE3114A.) 

(11) Overwriting to a sequential file truncates to the last 
element written. (See test CE2208B.) 

(12) Temporary sequential files are given names and deleted when 
closed. (See test CE2108A.) 

(13) Temporary direct files are given names and deleted when 
closed. (See test CE2108C.) 

(14) Temporary text files are given names and deleted when 
closed. (See test CE3112A.) 

(15) More than one internal file can be associated with each 
external file for sequential files when writing or reading. 
(See tests CE2107A..E (5 tests), CE2102L, CE2110B, and 


2-6 





CE2111D.) 


(16) More chan one inCernal file can be associated with each 
external file for direct files when writing or reading. 
(See tests CE2107F..H (3 tests), CE2110D and CE2111H.) 

(17) More than one internal file can be associated with each 
external file for text files when writing or reading. (See 
tests CE3111A, CE3111D..E (2 tests), and CE3114B.) 


2-7 







CHAPTER 3 


TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 433 tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing except for 
201 executable tests that use floating-point precision exceeding that 
supported by the implementation. Modifications to the code, processing, 
or grading for 74 tests were required to successfully demonstrate the 
test objective. (See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 

A 

B 

TEST 

C 

CLASS 

D 

E 

L 

TOTAL 

Passed 

123 

1132 

1897 

16 

26 

46 

3240 

Inapplicable 

6 

6 

418 

1 

2 

0 

433 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 




3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT CHAPTER TOTAL 


Passed 

195 

572 

554 

247 

172 

99 

161 

331 

135 

36 

250 

191 

297 

3040 

Inapplicable 

17 

77 

126 

1 

0 

0 

5 

1 

2 

0 

2 

178 

24 

433 

Wdm 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 

The following 44 tests were withdrawn from ACVC Version 1.10 at the time 
of this validation: 


A39005G 

B97102E 

C97116A 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A84M 

CD2A84N 

CD2B15C 

CD2D11B 

CD5007B 

CD50110 

CD7105A 

CD7203B 

CD7204B 

CD7205C 

CD7205D 

CE2107I 

CE3111C 

CE3301A 

ED7006C 

CE3411B 

ED7006D 

E28005C 

ED7004B 

ED7005C 

ED7005D 

See Appendix 

D for the 

reason ! 

that each 

of these 

tests was withdrawn 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of 
features that a compiler is not required by the Ada Standard to support. 
Others may depend on the result of another test that is either 
inapplicable or withdrawn. The applicability of a test to an 
implementation is considered each time a validation is attempted. A 
test that is inapplicable for one validation attempt is not necessarily 
inapplicable for a subsequent attempt. For this validation attempt, 433 
tests were inapplicable for the reasons indicated: 


a The following 201 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAX_DIGITS: 

C24113L..Y (14 tests J C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 


3-2 





C35708L..Y (14 
C45241L..Y (14 
C45421L..Y (14 
C45324L..Z (15 
C45641L..Y (14 


tests) 

tests) 

tests) 

tests) 

tests) 


C35802L,.Z 
C45321L..Y 
C45521L..Z 
C45621L..Z 
C46012L..Z 


(15 tests) 
(14 tests) 
(15 tests) 
(15 tests) 
(15 tests) 


b. 


C24113I..K (3 tests) are not applicable because the line length of 
the input file must not exceed 126 characters. 


c. 


C35508I, 
AD3015H, 
CD2A24C, 
CD3015E, 
CD4051C, 


C35508J, 
AD3015K, 
CD2A24D, 
CD3015G, 
CD4051D 


C35508M, 
CD1C04B, 
CD2A24G, 
CD3015I, 


C35508N, 
CD1C04C, 
CD2A24H, 
CD3015J, 


AD1C04D, 

CD1C04E, 

CD3015A, 

CD3015L, 


AD3015C, 
CD2A23C, 
CD3015B, 
CD4051A, 


AD3015F, 
CD2A23D, 
CD3015D, 
CD4051B, 


(30 tests) are not applicable because this 


implementation does not support the specified change in 
representation for derived types. 


d. C35702A and B86001T are not applicable because this implementation 
supports no predefined type SH0RT_FL0AT. 

e. A39005E, C87B62C, CD1009L, CD1C03F, CD2D11A, CD2D13A, ED2A56A (7 

tests) are not applicable because 'SMALL clause is not supported. 

f. C45231D, CD7101G, and B86001X, are not applicable because this 

implementation does not support any predefined integer type with a 
name other than INTEGER, LONG_INTEGER, or SHORT_INTEGER. 

g. C45531M, C45531N, C45532M, and C45532N use fine 48 bit fixed point 
base types which are not supported by this compiler. 

h. C455310, C45531P, C455320, and C45532P use coarse 48 bit fixed 

point base types which are not supported by this compiler. 

i. C4A013B is not applicable because the evaluation of an expression 
involving ’MACHINE_RADIX applied to the most precise floating-point 
type would raise an exception; since the expression must be static, 
it is rejected at compile time. 

j. 056001B uses 65 levels of block nesting which exceeds the capacity 
of the compiler. 


k. B86001Z is not applicable because this implementation supports no 
predefined floating-point type with a name other than FLOAT, or 
LONG FLOAT. 


l. B86001Y is not applicable because this implementation supports no 
predefined fixed-point type other than DURATION. 

m. C96005B is not applicable because there are no values of type 
DURATION'BASE that are outside the range of DURATION. 

n. CA2009C is not applicable because this implementation does not 


3-3 




permit compilation of generic non-library package bodies in 
separate files from their specifications. 

o. CA2009F is not applicable because this implementation does not 
permit ccnpilation of generic non-library subprogr a m bodies in 
separate files from their specifications. 

p. BC3204C and BC3205D are not applicable because this inplementatian 
does not permit ccnpilation of generic library package bodies in 
separate files from their specifications. 

q. CD1009C, CD2A41A. .B, CD2A41E, and CD2A42A.. J (14 tests) are not 
applicable because this inplementation does not support the 'SIZE 
clause for floating-point types. 

r. CD2A51C, CD2A52A. .D, CD2A52G..J, CD2A53A. .E, CD2A54A..D, 
CD2A54G. .J (22 tests) are not applicable because this 
implementation does not support the 'SIZE clause for a fixed-point 
types. 

S. CD2A61A..L, CD2A62A..C, CD2A64A. .D, CD2A65A. .D, CD2A71A. .D, 

CD2A72A. .D, CD2A74A. .D, CD2A75A. .D (39 tests) are not applicable 
because this implementation does not support the 'SIZE clause for 
an array type which does not imply compression of inter-conponent 
gaps. 

t. CD2A84B. .1 and CD2A84K. .L (10 tests) are not applicable because 
this implementation does not support the SIZE clause other than the 
default size for an access type. 

u. CD4041A is not applicable because this implementation does not 

support the alignment clauses for alignments other than 
SYSTEM.STORAGE_UNIT for record representation clauses. 

v. CD5003B..I, CD5011A, CD5011C, CD5011E, CD5011G, CD5011I, CD501IK, 

CD5011M, CD5011Q, CD5012A. .B, CD5012E. .F, CD5012I, CD5012M, 

CD5013A, O35013C, CD5013E, CD5013G, 0350131, O35013K, CD5013M, 

0350130, Q35014T, 035014V. .Z (36 tests) are not applicable because 
this implementation does not support non-static address clauses for 
a variable. 

w. O35011B, 0350110, O35011F, O35011H, O35011L, CD5011N, O3501IR, 

O35011S, O35012C. .D, CD5012G. .H, O35012L, CD5013B, CD5013D, 

O35013F, O35013H, O35013L, CD5013N, O35013R, O35014U (21 tests) are 
not applicable because this implementation does not support 
non-static address clauses for a constant. 

x. O35012J, CD5013S, O35014S (3 tests) are not applicable because this 
implementation does not support non-static address clauses. 

y. CE2102E is inapplicable because this inplementation supports OlEATE 
with OUr_FILE mode for SEQUENITAL_IO. 


3-4 




z. CE2102F is inapplicable because this implementation supports CREATE 
with INCUT_FH£ mode for DIRECT_IO. 

aa. CE2102J is inapplicable because this implementation supports CREATE 
with OUT_FHE mode for DIRECTJEO. 

ab. CE2102N is inapplicable because this implementation supports OPEN 
with m_FUE mode for SEQUENTIAL_IO. 

ac. CE21020 is inapplicable because this implementation supports RESET 
with IN_FHE mode for SEQUENITAL_IO. 

ad. CE2102P is inapplicable because this implementation supports OPEN 
with OOT_FHE mode for SEX2UENnAL_I0. 

ae. CE2102Q is inapplicable because this implementation supports RESET 
with OOT_FHE mode for SEQUENTIAL_IO. 

af. CE2102R is inapplicable because this implementation supports OPEN 
with IN0OT_FI1E mode for DIRECr_IO. 

ag. CE2102S is inapplicable because this implementation supports RESET 
with INOOTJFTIE mode for DIRECT_IO. 

ah. CE2102T is inapplicable because this implementation supports OPEN 
with IN_FTIE mode for DIRECr_IO. 

ai. CE2102U is inapplicable because this implementation supports RESET 
with IN_FHE mode for DIRECT_IO. 

aj. CE2102V is inapplicable because this implementation supports OPEN 
with OUT_FIIE mode for DIRECr_IO. 

ak. CE2102W is inapplicable because this implementation supports RESET 
with OUT_FILE mode for DIRECr_IO. 

al. CE2105A is inapplicable because CREATE with IN_FII£ mode is not 
supported by this implementation for SEQUENITAL_I0. 

am. CE2105B is inapplicable because CREATE with IN_FILE mode is not 
supported by this implementation for DTRECT_IO. 

an. CE3102F is inapplicable because text file RESET is supported by 
this implementation. 

ao. CE3102G is inapplicable because text file deletion of an external 
file is supported by this implementation. 

ap. CE3102I is inapplicable because text file CREATE with CUT_FI1E mode 
is supported by this implementation. 


3-5 






aq. CE3102J is inapplicable because text file OPEN with IN_FIIE mode is 
supported by this implementation. 

ar. CE3102K is inapplicable because text file OPEN with OOT_FILE mode 
is supported by this iaplementation. 

as. CE3109A is inapplicable because text file CREATE with IN_FHE mode 
is not supported by this implementation. 

at. CE3111B and CE3115A simultaneously associate irput and output 
files with the same external file, and expect that output is 
immediately written to the external file and available for reading; 
this iaplementation buffers files, and each test's attempt to read 
such output (at lines 87 & 101, respectively) raises END_ERROR. 

au. EE2401D is inapplicable because the maximum element size supported 
for DIRECT 10 is 2 147 483 647 bits. USE ERROR is raised. 


3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that same tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
iaplementation behavior. Modifications are made by the AVF in cases 
where legitimate iaplementation behavior prevents the successful 
completion of an (otherwise) applicable test. Examples of such 
modifications include: adding a length clause to alter the default size 
of a collection; splitting a Class B test into subtests so that all 
errors are detected; and confirming that messages produced by an 
executable test demonstrate conforming behavior that was not anticipated 
by the test (such as raising one exception instead of another). 

Modifications were required for 74 tests. 

The following 65 tests were split because syntax errors at one point 
resulted in the compiler not detecting other errors in the test: 


B22003A 

B26001A 

B26002A 

B26005A 

B28001D 

B28003A 

B29001A 

B2A003A 

B2A003B 

B2A003C 

B33301A 

B35101A 

B37106A 

B37301B 

B37302A 

B38003A 

B38003B 

B38009A 

B38009B 

B51001A 

B53009A 

B54A01C 

B54A02H 

B55A01A 

B61001C 

B61001D 

B61001F 

B61001H 

B61001I 

B6100IM 

B61001R 

B61001S 

B61001W 

B67001H 

B91001A 

B91002A 

B91002B 

B91002C 

B91002D 

B91002E 

B91002F 

B91002G 

B91002H 

B91002I 

B91002J 

B91002K 

B91002L 

B9503QA 

B95061A 

B95061F 

B95061G 

B95077A 

B97103E 

B97104G 

BA1101B 

BC1109A 

BC1109C 

BC1109D 

BC1202A 

BC1202B 

BC1202E 

BC1202F 

BC1202G 

BC2001D 

BC2001E 







The following 9 tests contain modifications to their respective source 
code files: 

AD7006A wrongly assumes that an expression in an assignment 


3-6 





statement is of type universal integer, and so should deliver a 
correct result that is in the range of type INTEGER. This 
implementation is correct in treating the expression a being of 
type INTEGER; an exception is raised because the operand 
SYSTEM.MEM3KY_SIZE exceeds INTEGER'IAST. 

The inpleraeriter's modification of this test (declaring the assigned 
— variable I to be of type 1CNG_INIEGER) is ruled to be an 
acceptable means to passing this test by the AVO. 

C34007A, C34007D, C34007G, C34007J, C34007M, C34007P, C34007S, and 
C87B62B (8 tests) The AVD accepts the inplementer's argument that, 
without there being a STORAGEJ3IZE length clause for an access 
type, the meaning of the attribute 'STORAGE_SIZE is undefined for 
that type. Therefore, a length clause has been added in these 
tests in order to alter the default size of a collection. 1024 was 
used for all of the above tests except for C34007D and C34007G 
which used 2048. 

3.7 ADDITIONAL TESTING INFORMATION 
3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 
produced by the DAGS—386/UNIX, Version 4.4 compiler was submitted to 
the AVF by the applicant for review. Analysis of these results 
demonstrated that the compiler successfully passed all applicable tests, 
and the compiler exhibited the expected behavior on all inapplicable 
tests. 


3.7.2 Test Method 


Testing of the DACS-386/UNXX, Version 4.4 compiler using ACVC Version 
1.10 was conducted on-site by a validation team from the AVF. The 
configuration in which the testing was performed is described by the 
following designations of hardware and software components: 


Host computer: 

Host operating system: 
Target computer: 

Target operating system: 
Compiler: 


ICL ERS300 

ERS/NX, Version 3, Level 1 
ICL ERS300 

DRS/NX, Version 3, Level 1 
DACS-386/UNIX, Version 4.4 


The ACVC Test Suite was loaded onto a VAX-8350 from the magnetic tape. 
The ACVC Test Suite was then downloaded onto the ICL ERS330 from the 
VAX-8530 via Ethernet (using ENICP net software utility) via SUN-3/60 
Workstation via streamer tape to the ICL ERS300. 

A magnetic tape containing all tests exempt for withdrawn tests was 
taken on-site by the validation team for processing. Tests that make 
use of implementation-specific values were customized on-site. Tests 


3-7 







requiring modifications during tfie prevalidation testing were modified 
on-site. 


TEST INFORMATION 

The contents of the magnetic tape were loaded onto a VAX-8350 and 
transferred to the tost c omputer, ICL EFS300, via Ethernet (using ENICP 
net software utility) via SDN-3/60 Workstation via streamer tape. 

After the test files were loaded to disk, the full set of tests was 
compiled and linked on the ICL ERS300, and all executable tests were run 
an the ICL ERS300. Results were transferred from the ICL ORS300 to the 
VAX-8530 via Ethernet (using ENICP net software utility) via SUN-3/60 
Workstation via streamer tape. The results were then printed from the 
VAX-8350 ccnputer. 

The compiler was tested using command scripts provided by DDC 
INTERNATIONAL A/S and reviewed by the validation team. The compiler was 
tested using the following option settings. See Appendix E for a 
complete listing of the compiler options for this implementation. 


-L 


-/s 


Tests were compiled, linked, and executed (as appropriate) using a 
single host and target computer. Test output, compilation listings, and 
job logs were captured on magnetic tape and archived at the AVF. 
Selected listings examined on-site by the validation team were also 
archived. 


3.7.3 Test Site 

Testing was conducted at Lyngby, Denmark and was completed on 27 October 
1989. 


3-8 





APPENDIX A 


DECLARATION OF CONFORMANCE 


DDC INTERNATIONAL A/S has submitted the following 
Declaration of Conformance concerning the DACS-386/UNIX, 
Version 4.4. 


A-1 





DECLARATION OF CONFORMANCE 


Compiler Implementor: DDC International A/S 

Gl. Lundtoftevej IB 
2800 Lyngby, Denmark 

Ada Validation Ada Validation Facility 

Facility: National Computer Systems Laboratory (NCSL) 

National Institute of Standards and Technology 
Building 225, Room A266 
Gaitherburg, MD 20899, U.S.A. 


Ada Compiler Validation Capability (ACVC) Version: 1.10 


Base Configuration 


Base Compiler Name: 
Host Architecture: 

Host OS and Version: 
Target Architecture: 
Target OS and Version: 


DACS-386/UNIX, Version 4.4 
ICL DRS300 

DRS/NX, Version 3, Level 1 
Same as host 
Same as host 


Implementor's Declaration 

I, the undersigned, representing DDC International A/S, have implemented no 
deliberate extensions to the Ada Language Standard ANSI/MIL-STD-1815A in the 
compiler(s) listed in this declaration. I declare that DDC International A/S 
is the owner of record of the Ada language compiler(s) listed above, and as 
such, is responsible for maintaining said compiler(s) in conformance to 
ANSI/MIL-STD-1815A. All certificates and registrations for Ada language 
compiler(s) listed in this declaration shall be made only in the owner's 
corporate name. 


Dat * : 2S 

DDC International A/S 

Hasse Hansson, Department Manager 

Owner's Declaration 



I, the undersigned, representing DDC International A/S, take full 
responsibility for implementation and maintenance of the Ada compiler(s) 
listed above, and agree to the public disclosure of the final Validation 
Summary Report. I declare that all of the Ada language compilers listed, and 
their host/taget performance, are in compliance with the Ada Language 
Standard ANSI/MIL-STD-1815A. 



DDC International A/S 

Hasse Hansson, Department Manager 


Dat#: rtt* 


DOC International A/S 


Gl Lundtoftevei 18 
DK-2800 Lyngby 


Telephone: 

♦45 


Telex: 


Telefax: 

+45 





APPENDIX B 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation*dependent pragmas, to certain machine-dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of the DACS-386/UNIX, Version 
4.4 compiler, as described in this Appendix, are provided by DDC 
INTERNATIONAL A/S. Unless specifically noted otherwise, references in 
this appendix are to compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are not 
a part of Appendix F, are: 


package STANDARD is 


type SHORT_INTEGER is range -32_768 .. 32_767; 

type INTEGER is range -2_147_483_648 .. 2_147_483_647; 

type LONG_INTEGER is range -2**63 .. 2**63 - 1; 

type FLOAT is digits 6 range 

-3.40282366920938E+38 .. 1.93428038904620E+38; 
type LONG_FLOAT is digits 15 range 

-1.7976931348623157E+308 .. 1.7976931348623157E+308; 

type DURATION is delta 2**(-14) range 

-131_072.00000 .. 131_071.00000 ; 


end STANDARD; 


B-l 


* 


* 







Appendix F 

Implementation-Dependent Characteristics 


F Implementation-Dependent Characteristics 

This appendix describes the implementation-dependent characteristics 
of DACS-386®/UNIX® as required in Appendix F of the Ada Reference 
Manual (ANSI/MIL-STD-1815A). 


F.1 Implementation-Defined Pragmas 

This section describes all implementation-defined pragmas. 


F.1.1 Pragma INTERFACE-SPELLING 

This pragma allows an Ada program to call a non-Ada program whose 
name contains characters that would be an invalid Ada subprogram 
identifier. It can also be used when subprogram names are case sen¬ 
sitive, e.g. C routines. This pragma must be used in conjunction 
with pragma INTERFACE, i.e. pragma INTERFACE must be specified for 
the non-Ada subprogram name prior to using pragma 
INTERFACE_SPELLING. 

The pragma has the format: 

pragma INTERFACE_SPELLING (subprogram name, string literal); 

where the subprogram name is that of one previously given in pragma 
INTERFACE and the string literal is the exact spelling of the inter¬ 
faced subprogram in its native language. 


F.1.2 Pragma INTERRUPT-HANDLER 

The DACS-386®/UNIX® allows the use of pragma INTERRUPT_HANDLER for 
compatibility with other DACS compiler systems. In this implementa¬ 
tion this pragma does not have any affect in the Ada program. The 
following information is reference only. It has the format: 

pragma INTERRUPT_HANDLER; 

The pragma must appear as the first thing in the specification of 
the task object. The task must be specified in a package and not 
a procedure. 


F-l 


DOC International A/S 






Appendix F 

Implementation-Dependent Characteristics 


"W 


F. 1.3 Pragma LT.STACK.SPACE 

DACS-386®/UNIX® allows use of the pragma LT_Stack_Space for com¬ 
patibility with other DACS compiler systems. In this 
implementation, the pragma does not have any effect on the Ada 
program. The following information is for reference only* 

This pragma sets the size of a library task stack segment. The 
pragma has the format: 

pragma LT_STACK_SPACE (T, N); 

where T denotes either a task object or task type and N designates 
the size of the library task stack segment in words. 

The size of the library task stack is normally specified via the 
representation clause: 

for T'STORAGE_SIZE use N; 

The size of the library task stack segment determines how many tasks 
that can be created which are nested within the library task. All 
tasks created within a library task will have their stacks allocated 
from the same segment as the library task stack. Thus, pragma 
LT_STACK_SPACE must be specified to reserve space within the library 
task stack segment so that nested tasks’ stacks may be allocated. 

The following restrictions are placed on the use of LT_STACK_SPACE: 

1) It must be used only for library tasks. 

2) It must be placed immediately after the task object or type 
name declaration. 

3) The library task stack segment size (N) must be greater 
than or equal to the library task stack size. 


F.2 Implementation-Dependent Attributes 
No implementation-dependent attributes are defined. 


F-2 


00C International A/S 





Appendix F 

Implementation-Dependent Characteristics 


'•V' 


F.3 Package System 

The package System for DACS-386®/UNIX® is: 
package System is 


type 

Word 




is 

new Short_Integer; 

type 

DWord 



is 

new Integer; 

type 

QWord 



is 

new Long_Integer 

type 

UnsignedWord 



is 

range 0..65535; 

for 

UnsignedWord’SIZE 


use 16; 

type 

UnsignedDword 



is 

range 0..16#FFFF FFFF# 

for 

UnsignedDword’SIZE 


use 32; 

type 

Byte 




is 

range 0..255; 

for 

Byte’SIZE 



use 8; 

subtype 

Segmentld 



is 

UnsignedWord; 

type 

Address is record 





offset 



i 

UnsignedDword; 

end record; 






subtype 

Priority 



is 

integer range 0..31; 

type 

Name 




is 

(iapx386_FM); 

System_ 

Name 

constant 

Name 

= 

iapx386 FM, 

Storage 

Unit 

constant 



s 

16; 

Memory Size 

constant 



s 

16#1 0000 0000#; 

Min_Int 


constant 



= - 

16#8000 0000 0000 0000# 

Max Int 


constant 



= 

16#7FFF FFFF FFFF FFFF# 

Max_Digits 

constant 



= 

15 

Max_Mantissa 

constant 



= 

31 

Fine Delta 

constant 



as 

2#1.0#E-31 

Tick 


constant 



S 

0.000_000_062_5 






- 

-machine dependent 

type 

Interface_Language 

is 

(ASM86 

, PLM86, C86, 


C86_REVERSE, ASM_ACF, 

PLM_ACF, C_ACF, 

C_RESERVE__ACF, ASM_NOACF, 

PLM_NOACF, C_NOACF, 

C_REVERSE_NOACF); 

type Exceptionld is record 

unit_number : UnsignedDWord; 
unique_number : UnsignedDWord; 
end record; 

type TaskValue is new Integer; 

type AccTaskValue is access TaskValue; 


F-3 


DOC International A/S 







Appendix F 
Implamentation-Dependent Characteristics 


type Semaphore is record 
counter : integer; 

first : TaskValue; 

last : TaskValue; 

end record; 

InitSemaphore ; constant Semaphore’(1, 0, 0) 

end SYSTEM; 


F- 4 


ODC Intamjitional A/S 












Appendix F 

Implementation-Dependent Characteristics 


F.4 Representation Clauses 


F.4.1_Length Clause 


A size attribute for a type T is accepted in the following cases: 

If T is a discrete type then the specified size must be greater 
than 9 tn or equal to the number of bits needed to represent a value 
of the type, and less than or equal to 32. 

If T is a fixed point type, a floating point type, an access type 
or a task type the specified size must be equal to the number of 
bits used to represent values of the type. 

If T is a record type that is not derived then the specified size 
must be greater than or equal to the number of bits used to rep¬ 
resent value of the type. 

If T is an array type that is not derived, and has a size known 
at compile time then the specified size must be equal to the num¬ 
ber of bits used to represent values of the type. In all other 
cases the size attribute is not accepted. 

Furthermore, the size attribute has only effect if the type is part 
of a composite type. 


Using the STORAGE_SIZE attribute for a collection will set an up¬ 
per limit on the total size of objects allocated in this collec¬ 
tion. If further allocation is attempted, the exception 
STORAGE_ERROR is raised. 

When STORAGE_SIZE is specified in a length clause for a task, the 
process stack area will be of the specified size. The process 
stack area will be allocated inside the "standard" stack segment. 


F.4.2 Enumeration Representation Clause 

Enumeration representation clauses may specify representations in 
the range of INTEGER'FIRST + 1..INTEGER'LAST - 1. 

Enumeration representation clauses are not supported for derived 
types. 


F-5 


00C International A/S 









Appendix F 

Implementation-Dependent Characteristics 


F.4.3 Record Representation Clauses 

When representation clauses are applied to records the following 
restrictions are imposed: 

- the component type is a discrete type different from 
LONG_INTEGER, 

the component type is an array with a discrete element type dif¬ 
ferent from LONG_INTEGER, 

if the component is a record or an unpacked array, it must start 
on a storage unit boundary, a storage unit being 16 bits, 

a record occupies an integral number of storage units, 

- a record may take up a maximum of 32K storage units, 

« 

- a component must be specified with its proper size (in bits), 
regardless of whether the component is an array or not, 

- if a non-array component has a size which equals or exceeds one 
storage unit (16 bits), the component must start on a storage 
unit boundary, i.e. the component must be specified as: 

component at N range 0 -.16 * M - 1; 

where N specifies the relative storage unit number (0,1,—) from 
the beginning of the record, and M the required number of storage 
units (1,2,...) 

the elements in an array component should always be wholly con¬ 
tained in one storage unit, 

if a component has a size which is less than one storage unit, it 
must be wholly contained within a single storage unit: 

component at N range X .. Y; 

•where N is as in the previous paragraph, and 0 <= X <=• Y < = 15 

If the record type contains components which are not covered by a 
component clause, they are allocated consecutively after the com¬ 
ponent with the value. Allocation of a record component without a 
component clause is always aligned on a storage unit boundary. 
Holes created because of component clauses are not otherwise util¬ 
ized by the compiler. 


F-6 


DOC International A/S 







Appendix F 

Implementation-Dependent Characteristics 


F.4.3.1 _ Alignment Clauses 

Alignment clauses for records are implemented with the following 
characteristics: 

- If the declaration of the record type is done at the outermost 
level in a library package, any alignment is accepted. 

- If the record declaration is done at a given static level 
(higher than the outermost library level, i.e. the permanent 
area), only word alignments are accepted. 

- Any record object declared at the outermost level in a library 
package will be aligned according to the alignment clause 
specified for the type. Record objects declared elsewhere can 
only be aligned on a word boundary. If the record type has been 
associated a different alignment, an error message will be 
issued. 

- If a record type with an associated alignment clause is used in 
a composite type, the alignment is required to be one word: an 
error message is issued if this is not the case. 


F.5 Implementation-Dependent Names for Implementation-Dependent 
Opponents 


None defined by the compiler. 


F.6 Address Clauses 


In the Dacs-386®/UNIX® implementation only static address clauses 
are allowed, i.e. either a literal or a static expression. 


F.7 Unchecked Conversions 

Unchecked conversion is only allowed between objects of the same 
size. 


F.8 Input/Output Packages 

The implementation supports all requirements of the Ada language. It 
is an effective interface to the UNIX file system, and in the case 
of the text I/O also an effective interface to the UNIX standard in¬ 
put, standard output, and standard error streams. 


00C International A/S 


F-7 






Appendix F 

Implementation-Dependent Characteristics 


This section describes the functional aspects of the interface to 
the UNIX file system, including the methods of using the interface 
to take advantage of the file control facilities provided. 

The Ada input-output concept as defined in Chapter 14 of the ARM 
does not constitute a complete functional specification of the 
input-output packages. Some aspects of the I/O system are not 
described at all, with others intentionally left open for implemen¬ 
tation. This section describes those sections not covered in the 
ARM. 

The UNIX operating system considers all files to be sequences of 
characters. Files can either be accessed sequentially or randomly. 
Files are not structured into records, but an access routine can 
treat a file as a sequence of records if it arranges the record 
level input-output. Two restrictions that apply are: 

If a direct access (using lseek(2)) to standard input, standard 
output, or standard error will cause a USE_ERROR to occur. 

Attempting to direct access (using lseek(2), open(2), 
mknod(2), or pipe(2)) a UNIX pipe or FIFO will cause a 
USE_ERROR to occur. 

Note that for sequential or text files (Ada files not UNIX external 
files) RESET on a file in mode OUT_FILE will empty the file. Also, a 
sequential or text file opened as an OUT_FILE will be emptied. 


F.8.1 _ External Files 

An external file is either a UNIX disk file, a UNIX FIFO, a UNIX 
pipe, or any device defined in the UNIX directory. The use of 
devices such as a tape drive or communication line may require spe¬ 
cial access permissions or have restrictions. If an inappropriate 
operation is attempted on a device, the USE_ERROR exception is 
raised. 

External files created within the UNIX file system shall exist after 
the termination of the program that created it, and will be acces¬ 
sible from other Ada programs. A form created with the FORM 
parameter will also exist after program termination. However, pipes 
and temporary files will not exist after program termination. 

Creation of a file with the same name as an existing external file 
will cause the existing file to be overwritten. 

Creation of files with mode IN_FILE will cause USE_ERROR to be 
raised. 


F-8 


00C International A/S 








Appendix F 

Implementation-Dependent Characteristics 


The name parameter to the input/output routines must be a valid UNIX 
file name. If the name parameter is empty, then a temporary file is 
created in the /tmp directory. This file- is automatically deleted 
when the program that created it terminates. 


F.8.2 File Management 


This section provides useful information for performing file manage¬ 
ment functions within an Ada program. 

The only restrictions in performing Sequential and Direct I/O are: 

The maximum size of an object of ELEMENT_TYPE is 2_147_483_647 
bits. ~ 

If the size of an object of ELEMENT_TYPE is variable, the maximum 
size must be determinable at the point of instantiation from the 
value of the SIZE attribute. 


The NAME parameter 

The NAME parameter must be a valid UNIX pathname (unless null). If 
any directory in the pathname is inaccessible, a USE_ERROR is 
raised. 

The UNIX names "stdin", "stdout", and "stderr" can be used with 
TEXT_IO.OPEN. No physical opening of the external file is performed 
and the Ada file will be associated with the already open external 
file. These names have no significance for other packages. 

Temporary files (NAME ■ null string) are created using tmpname(3) 
and are deleted when CLOSED. Abnormal program termination may leave 
temporary files in existence. 


The FORM parameter 

The FORM parameter has the following facilities: 

- A FIFO special file can be opened using the open(2) system call. 
This is achieved with the "FIFO" string. Note that this cannot 
be used with CREATE. 

The default value for this facility is "ORDINARY", which desig¬ 
nates the creation of an ordinary file. 


F-9 


00C International A/S 





Appendix F 

Implementation-Dependent Characteristics 




An additional flag associated with FIFO specials is provided to 
allow waiting or immediate return. This flag, and its status, is 
specified with the additional strings, "0_NDELAY=ON" for ON and 
"0_NDELAY*0FF" for OFF. Default is "0_NDELAY*0FF". 

- The "APPEND" string can be used to open text files without empty¬ 
ing the file. This parameter cannot be used with CREATE. The 
default condition is "NOAPPEND". 

Access rights to a file can be controlled by using a 

"MODE=<mode>" string in the CREATE procedure. <mode> is an octal, 
decimal, or hexadecimal integer in the standard UNIX format. 
Default mode is 0644. This facility can also be used by OPEN to 
change access permissions on existing files by means of the 
chmod(2) system call. 

If more than one of the three options (FIFO, APPEND, and MODE) are 
included, the rightmost option is selected. Blanks are not sig¬ 
nificant within any part of the string. The syntax of the FORM 
parameter provides all default options as required in the Ada 

Reference Manual: 

<form_parameter> := [<option> ,...] 

where <option> :* <access rights> | <fifo> | <append> 

<access_rights> is MODE*<mode #>. The mode number can be in 
decimal, octal (0###), or hexadecimal (0##). 

<fifo> is either "FIFO [0_NDELAY= ON|OFF] M or "ORDINARY" 

<append> is either "APPEND" or "NOAPPEND" 


File Access 

The following guidelines should be observed when performing file I/O 

operations: 

- At a given instant, any number of files in an Ada program can be 
associated with corresponding external files. 

- When sharing files between programs, it is the responsibility of 
the programmer to determine the effects of sharing files. 

- The RESET and OPEN operations to files of mode 0UT_FILE will 
empty the contents of the file in SEQUENTIAL_IO and TEXT_I0. 

- Files can be interchanged between SEQUENTIAL_IO and DIRECT_I0 
without any special operations if the files are of the same ob¬ 
ject type. 


F-10 


00C International A/S 


A 





Appendix F 

Implementation-Dependent Characteristics 


"W 


F.8.3 Package TEXT-10 


The specification of package TEXT_IO: 

with BASIC_10_TYPES; 

with IO_EXCEPTIONS; 
package TEXT_IO is 

type FILE_TYPE is limited private; 

type FILE_MODE is (IN_FILE, OUT_FILE); 

type COUNT is range 0 .. LONG_INTEGER'LAST; 

subtype POSITIVE_COUNT is COUNT range 1 .. COUNT'LAST; 

UNBOUNDED; constant COUNT;* 0; — line and page length 

— max. size of an integer output field 2#....# 
subtype FIELD is INTEGER range 0 .. 35; 


subtype NUMBER_BASE is INTEGER range 2 .. 16; 
type TYPE_SET is (LOWER_CASE, UPPER_CASE); 

— File Management 


procedure 

CREATE 

(FILE 

• 

• 

in 



MODE 

• 

• 

in 



NAME 

• 

• 

in 



FORM 

); 

• 

* 

in 

procedure 

OPEN 

(FILE 

* 

• 

in 



MODE 

• 

• 

in 



NAME 

• 

in 



FORM 

); 

• 

• 

in 

procedure 

CLOSE 

(FILE 

• 

• 

in 

procedure 

DELETE 

(FILE 

: 

in 

procedure 

RESET 

(FILE 

• 

• 

in 

procedure 

RESET 

(FILE 

• 

• 

in 

function MODE 

(FILE 

• 

• 

in 

function NAME 

(FILE 

♦ 

• 

in 

function FORM 

(FILE 

• 

in 

function IS_0PEN 

(FILE 

• 

• 

in 


MODE: in FILE MODE) 


in FILEJTYPE return BOOLEAN; 
-- control of default input and output files 


OOC International A/S 


F-11 





Appendix F 

Implementation-Dependent Characteristics 


'•IIS* 


procedure SET_INPUT (FILE : in FILE_TYPE); 
procedure SET_OUTPUT (FILE : in FILE_TYPE); 

function STANDARD_INPUT return FILE_TYPE; 

function STANDARD_OUTPUT return FILE_TYPE; 

function CURRENT_INPUT return FILE_TYPE; 

function CURRENT_OUTPUT return FILE~TYPE; 

-- specification of line and page lengths 

procedure SET_LINE_LENGTH (FILE : in FILE_TYPE; TO : in COUNT); 
procedure SET_LINE_LENGTH (TO : in COUNT); 

procedure SET_PAGE_LENGTH (FILE : in FILE_TYPE; TO : in COUNT); 
procedure SET_PAGE_LENGTH (TO : in COUNT); 

function LINE_LENGTH (FILE ; in FILE_TYPE) return COUNT; 

function LINE_LENGTH return COUNT; 

function PAGE_LENGTH (FILE : in FILE_TYPE) return COUNT; 

function PAGE LENGTH return COUNT; 


— Column, Line, and Page Control 


procedure 

NEW_ 

LINE 

(FILE 


in 

FILE TYPE; 





SPACING 


in 

POSITIVE COUNT 

:= l); 

procedure 

NEW_ 

LINE 

(SPACING 


in 

POSITIVE_COUNT 

:= l); 

procedure 

SKIP 

_LINE 

(FILE 


in 

FILE TYPE; 





SPACING 


in 

POSITIVE COUNT 

:= 1); 

procedure 

SKIP 

_LINE 

(SPACING 


in 

POSITIVE COUNT 

:= l); 


function END_OF_LINE (FILE : in FILE_TYPE) return BOOLEAN; 
function END OF_LINE return BOOLEAN; 


procedure NEW_PAGE (FILE : in FILE_TYPE); 
procedure NEW_PAGE; 

procedure SKIP_PAGE (FILE ; in FILE_TYPE); 
procedure SKIP_PAGE; 

function END_OF_PAGE (FILE : in FILE_TYPE) return BOOLEAN; 

function END_OF_PAGE return BOOLEAN; 

function END_OF_FILE (FILE : in FILE_TYPE) return BOOLEAN; 

function END_OF_FILE return BOOLEAN; 

procedure SET_COL (FILE : in FILE_TYPE;TO :in POSITIVE_COUNT) 

procedure SET_COL (TO : in POSITIVE_COUNT); 

procedure SET LINE (FILE : in FILE TYPE;TO :in POSITIVE COUNT) 


F-12 


ODC International A/S 




Appendix F 
Implementation-Dependent Characteristics 


procedure 

SET_LINE 

(TO 

• 

• 

in 

POSITIVE_COUNT); 



function 

COL 

( FILE 

• 

in 

FILE_TYPE) 

return 

POSITIVE 

COUNT; 

function 

COL 





return 

POSITIVE' 

]COUNT; 

function 

LINE 

(FILE 

• 

• 

in 

FILE_TYPE) 

return 

POSITIVE 

COUNT; 

function 

LINE 





return 

POSITIVE] 

]COUNT; 

function 

PAGE 

(FILE 

• 

• 

in 

FILE_TYPE) 

return 

POSITIVE 

COUNT; 

function 

PAGE 





return 

positive' 

"COUNT; 


— Character Input-Output 

procedure GET (FILE : in FILE_TYPE; ITEM : out CHARACTER); 

procedure GET (ITEM : out CHARACTER); 

procedure PUT (FILE : in FILE_TYPE; ITEM : in CHARACTER); 

procedure PUT (ITEM : in CHARACTER); 

— String Input-Output 

procedure GET (FILE : in FILE_TYPE; ITEM : out CHARACTER); 

procedure GET (ITEM : out CHARACTER); 

procedure PUT (FILE : in FILE_TYPE; ITEM ; in CHARACTER); 

procedure PUT (ITEM : in CHARACTER); 

procedure GET_LINE (FILE : in FILE_TYPE; 

ITEM : out STRING; 

LAST : out NATURAL); 


procedure GET_LINE (ITEM ; out STRING; LAST : out NATURAL); 

procedure PUT_LINE (FILE ; in FILE_TYPE; ITEM : in STRING); 

procedure PUT LINE (ITEM : in STRING); 


00C International A/S 


F-13 






Appendix F 

Implementation-Dependent Characteristics 


— Generic Package for Input-Output of Integer Types 
generic 

type NUM is range <>; is 


DEFAULT_WIDTH : FIELD 

DEFAULT_BASE : NUMBER_BASE 

procedure GET (FILE 
ITEM 
WIDTH 

procedure GET (ITEM 
WIDTH 

procedure PUT (FILE 

ITEM 

WIDTH 

BASE 

procedure PUT (ITEM 
WIDTH 
BASE 

procedure GET (FROM 
ITEM 
LAST 

procedure PUT (TO 

ITEM 

BASE 

end INTEGER 10; 


NUM*WIDTH; 

10 ; 

in FILE_TYPE; 
out NUM; 
in FIELD := 0); 

out NUM; 
in FIELD ;= 0); 

in FILE_TYPE; 
in NUM; 

in FIELD DEFAULT_WIDTH 

in NUMBER_BASE ;= DEFAULT_BASE) 

in NUM; 

in FIELD : = DEFAULT_WIDTH 

in NUMBER_BASE := DEFAULTJBASE) 

in STRING; 

out NUM; 

out POSITIVE); 

out STRING; 
in NUM; 

in NUMBER BASE := DEFAULT BASE) 


F-14 


OOC International A/S 




Appendix F 

Implementation-Dependent Characteristics 


— Generic Packages for Input-Output of Real Types 
generic 

type NUM is digits <>; 
package FLOAT_IO; is 


DEFAULT FORE : 

FIELD := 

2; 

DEFAULT AFT ; 

FIELD :» 

HUM'DIGITS - 1; 

DEFAULT_EXP : 

FIELD := 

3; 

procedure GET 

(FILE 

ITEM 

WIDTH 

; in FILE_TYPE; 

: out NUM; 

; in FIELD := 0); 

procedure GET 

(ITEM 
WIDTH 

: out NUM; 

; in FIELD := 0); 

procedure PUT 

(FILE 

ITEM 

FORE 

; in FILE_TYPE; 

: in NUM; 

; in FIELD := DEFAULT FORE; 


AFT 

EXP 

: in FIELD := DEFAULT AFT; 

: in FIELD := DEFAULT EXP); 

procedure PUT 

(ITEM 

FORE 

AFT 

EXP 

: in NUM; 

; in FIELD := DEFAULT FORE; 

: in FIELD :* DEFAULT AFT; 

; in FIELD :=* DEFAULT_EXP); 

procedure GET 

(FROM 

ITEM 

LAST 

: in STRING; 

: out NUM; 

; out POSITIVE); 

procedure PUT 

(TO 

ITEM 

AFT 

EXP 

: out STRING; 

: in NUM; 

: in FIELD := DEFAULT AFT; 

; in FIELD := DEFAULT EXP) 


end FLOAT 10; 


00C International A/S 


F-15 











Appendix F 
Implementation-Dependent Characteristics 


generic 

type NUM is delta <>; 
package FIXED_IO is 


DEFAULT FORE 

: FIELD 

:* NUM'FORE; 

DEFAULT AFT 

: FIELD 

;» NUM'AFT; 

DEFAULT_EXP 

: FIELD 

:» 0; 

procedure GET 

(FILE 

; in FILE_TYPE; 


ITEM 

: out NUM; 


WIDTH 

: in FIELD := 0); 

procedure GET 

(ITEM 

: out NUM; 


WIDTH 

: in FIELD := 0); 

procedure PUT 

( FILE 

: in FILE TYPE; 


ITEM 

: in NUM; 


FORE 

: in FIELD := DEFAULT FORE; 


AFT 

: in FIELD := DEFAULT AFT; 


EXP 

: in FIELD := DEFAULT EXP); 

procedure PUT 

( ITEM 

; in NUM; 


FORE 

; in FIELD := DEFAULT FORE; 


AFT 

: in FIELD := DEFAULT AFT; 


EXP 

: in FIELD := DEFAULT_EXP); 

procedure GET 

(FROM 

; in STRING; 


ITEM 

: out NUM; 


LAST 

: out POSITIVE); 

procedure PUT 

(TO 

; out STRING; 


ITEM 

; in NUM; 


AFT 

; in FIELD := DEFAULT AFT; 


EXP 

; in FIELD ;= DEFAULT EXP) 

I FIXED_IO; 



F-16 


00C International A/S 










Appendix F 

Implementation-Dependent Characteristics 


— Generic Package for Input-Output of Enumeration Types 
generic 

type ENUM is (<>); 
package ENUMERATION 10 is 


DEFAULT WIDTH 


; FIELD ; - 

0; 

DEFAULT_SETTING 

t TYPE_SET : = 

UPPER_CASE; 

procedure 

GET 

(FILE : 

in FILE TYPE; ITEM 

: out ENUM); 

procedure 

GET 

(ITEM : 

out ENUM); 


procedure 

PUT 

( FILE 

: FILE TYPE; 




ITEM 

: in ENUM; 




WIDTH 

: in FIELD ;= 

DEFAULT WIDTH; 



SET 

; in TYPE SET : = 

DEFAULT_SETTING); 

procedure 

PUT 

(ITEM 

: in ENUM; 




WIDTH 

: in FIELD := 

DEFAULT WIDTH; 



SET 

: in TYPE_SET :=* 

DEFAULT_SETTING); 

procedure 

GET 

(FROM 

; in STRING; 




ITEM 

: out ENUM; 




LAST 

; out POSITIVE); 


procedure 

PUT 

(TO 

: out STRING; 




ITEM 

: in ENUM; 




SET 

; in TYPE SET := 

DEFAULT_SETTING); 


end ENUMERATION 10; 


— Exceptions 

STATUS_ERROR; : exception renames IO_EXCEPTIONS.STATUS_ERROR; 

M0DE_ERR0R; ; exception renames IO_EXCEPTIONS.MODE_ERROR; 

NAME_ERROR; ; exception renames IO_EXCEPTIONS.NAME_ERROR; 

USE_ERR0R; ; exception renames IO_EXCEPTIONS.USE_ERROR; 

DEVICE_ERROR; : exception renames IO_EXCEPTIONS.DEVICE_ERROR; 

END_ERR0R; ; exception renames IOJEXCEPTIONS.END_ERROR; 

DATA_ERROR; ; exception renames IO_EXCEPTIONS.DATA_ERROR; 

LAY0UT_ERR0R; ; exception renames I0_EXCEPTI0NS.LAY0UT_ERR0R; 

private 

type FILEJTYPE is new BASIC_IO_TYFES.FILEJTYPE; 
end TEXT 10; 


DOC International A/3 


F-17 







Appendix F 
Implementation-Dependent Characteristics 


F.8.4 Package LOW_LEVEL_IO 

The specification of L0W_LEVEL__I0 is: 

with System; 

package LOW_LEVEL_IO is 

subtype port_address is System.UnsignedWord; 


type ll_io_8 is new short__integer range -128.. 127; 

type ll_io_16 is new short_integer; 

type ll_io_32 is new integer; 


procedure send_control(device 

data 

— unsigned 8 bit entity 

procedure send_control(device 

data 

— unsigned 16 bit entity 

procedure send_control(device 

data 

— unsigned 32 bit entity 

procedure send_control(device 

data 

— signed 8 bit entity 

procedure send_control(device 

data 

— signed 16 bit entity 

procedure send_control(device 

data 

— signed 32 bit entity 


in port_address; 
in System.Byte); 


in port_address; 
in System.UnsignedWord); 


in port_address; 
in System.UnsignedDWord); 


in port_address; 
in 11 io 8); 


in port_address; 
in 11 io 16); 


in port_address; 
in 11 io 32); 


procedure receive_control(device 

data 

— unsigned 8 bit entity 


in port_address; 
out System.Byte); 


procedure receive_control(device 

data 

— unsigned 16 bit entity 


in port_address; 

out System.UnsignedWord); 


procedure receive_control(device 

data 

— unsigned 32 bit entity 


in port_address; 

out System.UnsignedDWord) 


procedure receive_control(device 

data 


in port_address; 
out 11 io 8); 


F-18 


00C International A/S 






Appendix F 

Implementation-Dependent Characteristics 


— signed 8 bit entity 

procedure receive_control(device : in port_address; 

data : out ll_io_16); 

— signed 16 bit entity 

procedure receive_control(device : in port_address; 

data : out ll_io_32); 

— signed 32 bit entity 


private 

pragma inline(send_control, receive_control); 
end LOW LEVEL 10; 


F. 8.5 Package SEQUENTIAL_I0 

In SEQUENTIAL_IO, type checking for DATA_ERROR has been excluded for 
elements of an unconstrained type. 

— Source code for SEQUENTIAL_IO 
with IO_EXCEPTIONS; 

generic 

type ELEMENT_TYPE is private; 
package SEQUENTIAL_IO is 

type FILE_TYPE is limited private; 
type FILE_M0DE is (IN_FILE, 0UT_FILE); 

— File management 


procedure 

CREATE(FILE 

• 

• 

in 

out 

FILE TYPE; 




MODE 

• 

• 

in 


FILE~M0DE :» 

OUT FILE; 



NAME 

• 

• 

in 


STRING ;- 

*• n m 

9 



FORM 

• 

• 

in 


STRING :■ 


procedure 

OPEN 

(FILE 

• 

9 

in 

out 

FILE TYPE; 




MODE 

9 

• 

in 


FILE~M0DE; 




NAME 

9 

• 

in 


STRING; 




FORM 

• 

• 

in 


STRING 

); 

procedure 

CLOSE 

( FILE 

• 

• 

in 

out 

FILE_TYPE); 



F-19 


00C International A/S 






Appendix F 

Implementation-Dependent Characteristics 


procedure DELETEC FILE : in out FILEJTYPE); 

procedure RESET (FILE : in out FILE_TYPE; MODE : in FILE_MODE) 

procedure RESET (FILE : in out FILEJTYPE); 

function MODE (FILE : in FILEJTYPE) return FILE_MODE; 

function NAME (FILE : in FILEJTYPE) return STRING; 

function FORM (FILE : in FILEJTYPE) return STRING; 

function IS_OPEN(FILE : in FILEJTYPE) return BOOLEAN; 

-- input and output operations 

procedure READ (FILE : in FILE TYPE; 

ITEM : out ELEMENTJTYPE); 

procedure WRITE (FILE ; in FILEJTYPE; 

ITEM ; in ELEMENTJTYPE); 

function END_OF_FILE 

(FILE ; in FILEJTYPE) return BOOLEAN; 

— exceptions 

STATUS_ERROR 
MODE_ERROR 
NAME_ERROR 
USE_ERROR 
DEVICE_ERROR 
END_ERROR 
DATA_ERROR 

private 

type FILEJTYPE is new BASIC_IO_TYPES.FILE_TYPE; 
end SEQUENTIAL 10; 


F-20 


; exception renames IO_EXC£PTIONS.STATUS_ERROR; 
; exception renames lo'EXCEPTIONS.MODE_ERROR; 

; exception renames IQ_EXCEPTI0NS.NAME_ERROR; 

: exception renames I0_EXCEPTI0NS.USE_ERR0R; 

; exception renames I0_EXCEPTI0NS.DEVICE_ERR0R; 
; exception renames I0_EXCEPTI0NS.END_ERR0R; 

: exception renames I0_EXCEPTI0NS.DATA_ERR0R; 


00C International A/S 





Appendix F 

Implementation-Dependent Characteristics 

F.8.6 Package DIRECT-IP 

In DIRECT_IO, type checking for DATA_ERROR has been excluded for 
elements of an unconstrained type. 

with BASIC_IO_TYPES; 
with IO_EXCEPTIONS; 

generic 

type ELEMENT JTYPE is private; 
package DIRECT_IO is 

type FILE_TYPE is limited private; 

type FILE_MODE is (IN_FILE, INOUT_FILE, OUT_FILE); 

type COUNT is range 0..LONG_INTEGER'LAST; 

subtype POSITIVE_COUNT is COUNT range 1..COUNT'LAST; 

— File management 


procedure CREATE(FILE 

: in 

out FILE TYPE; 


MODE 

; in 

FILE~M0DE :* INOUT FILE; 


NAME 

; in 

STRING := " H ; 


FORM 

: in 

STRING : =* " " ); 

procedure OPEN 

(FILE 

: in 

out FILE TYPE; 


MODE 

: in 

FILE MODE; 


NAME 

: in 

STRING; 


FORM 

: in 

STRING ;= "" ); 

procedure CLOSE 

(FILE 

: in 

out FILEJTYPE); 

procedure DELETE(FILE 

; in 

Out FILEJTYPE); 

procedure RESET 

(FILE 

: in 

out FILE TYPE; 


MODE 

: in 

FILE_MODE); 

procedure RESET 

(FILE 

: in 

Out FILEJTYPE); 

function MODE 

(FILE 

: in 

FILEJTYPE) return FILE_MODE 

function NAME 

(FILE 

: in 

FILEJTYPE) return STRING; 

function FORM 

(FILE 

: in 

FILEJTYPE) return STRING; 

function IS__0PEN( FILE 

: in 

FILEJTYPE) return BOOLEAN; 


F-21 


DOC International A/S 







Appendix F 

Implementation-Dependent Characteristics 


"XF 


— input and output operations 

procedure READ (FILE : in FILEJTYPE; 

ITEM : out ELEMENT JTYPE; 

FROM : in POSITIVE_COUNT); 

procedure READ (FILE : in FILEJTYPE; 

ITEM : out ELEMENT JTYPE); 

procedure WRITE (FILE : in FILEJTYPE; 

ITEM : in ELEMENT JTYPE; 

TO : in POSITIVE_COUNT); 

procedure WRITE (FILE : in FILEJTYPE; 

ITEM : in ELEMENT_TYPE); 

procedure SET_INDEX 

(FILE : in FILEJTYPE; 

TO : in POSITIVE_COUNT); 

function INDEX (FILE : in FILEJTYPE) return POSITIVE_COUNT; 

function SIZE (FILE : in FILEJTYPE) return COUNT; 

function END_0 F_FILE 

(FILE : in FILE_TYPE) return BOOLEAN; 

— exceptions 

STATUS_ERROR : exception renames IO_EXCEPTiONS.STATUS JERROR 

MODE_ERROR : exception renames I0_EXCEPTI0NS.MODE_ERROR; 

NAME_ERROR : exception renames IO_EXCEPTlONS.NAME_ERROR; 

USE_ERROR : exception renames IO_EXCEPTlONS.USE_ERROR; 

DEVICE_ERROR ; exception renames IO_EXCEPTIONS.DEVICE_ERROR 

END_ERROR : exception renames I0_EXCEPTI0NS.END_ERROR; 

DATAJERROR : exception renames IO_EXCEPTlONS.DATA_ERROR; 

private 

type FILE_TYPE is new BASIC_IO_TYPES.FILEJTYPE; 
end DIRECT 10; 


F-22 


DOC Intamattonal A/S 




Appendix F 

Implementation-Dependent Characteristics 



F.9 Machine Code Insertions 


The reader should be familiar with the code generation strategy and 
the 80386 instruction set to fully benefit from this section. 

As described in chapter 13.8 of the ARM [ 83] it is possible to 
write procedures containing only code statements using the 
predefined package MACHINE_C0DE. The package MACHINE_C0DE defines 
the type MACHINE_INSTRUCTION which, used as a record aggregate, 
defines a machine code insertion. The following sections list the 
type MACHINE_INSTRUCTION and types on which it depends, give the 
restrictions, and show an example of how to use the package 
MACHINE CODE. 


F.9.1 _ Predefined Types for Machine Code Insertions 

The following types are defined for use when making machine code in¬ 
sertions (their type declarations are given in the following pages): 

type opcode_type 
type operand_type 
type register_type 
type segment_register 
type machine_instruction 


The type REGISTER_TYPE defines registers and register combinations. 
The double register combinations (e.g. BX_SI) can be used only as 
address operands (BX_SI describing [BX+SI]). The registers STi 
describe registers on the floating stack. (ST is the top of the 
floating stack). 

The type SECT4ENT_REGISTER defines the four segment registers that 
can be used to overwrite default segments in an address operand. 

The type MACHINE_INSTRUCTION is a discriminant record type with 
which every kind of instruction can be described. Symbolic names 
may be used in the form 

name'ADDRESS 

type opcode__type is ( 

— 8086 instructions: 


m AAA, 

m AAD, 

m AAM, 

m_AAS, 

m~ADC, 

m_ADD, 

m_AND, 


hTcall , 

m_CALLn, 



m_CBW, 

m CLC, 

m CLD 

m CLI, 

m_CMC, 

ra~CMP, 

m_CMPS, 

m_CWD, 

m DAA, 

m DAS, 



m DEC, 

hTdiv, 

m_HLT, 



00C International A/S 


F-23 




ir 


Appendix F 

Implementation-Dependent Characteristics 


ra IDIV, 

m IMUL, 

ra_INT, 

m_INT0, 

m_JA, 

m JAE, 

ra_JC, 

m“jCXZ, 

m JGE, 

m JL, 

m~JNAE, 

m JNB, 

m JNE, 

m JNG, 

m JNLE, 

ra_ JNO, 

m JNZ, 

m_J0, 

m JPO, 

m_JS, 

m LAHF, 

m_LDS, 

m LOCK, 

m LOOS, 

m LOOP, 

m LOOPE 

m LOOPZ, 

m MOV, 

m NEG, 

m NOP, 

m OUT, 

m_P0P, 

m_PUSHF, 


m_RCL, 

m RCR, 

m REP, 

m REPE, 

m RET, 

m_RETP, 

m_SAHF, 


m_SAL, 

ra_SAR, 

m SBB, 

m SCAS, 

m STC, 

m_STD, 

m SUB, 

m TEST, 

m XLAT, 

m XOR, 


m IN, 

m_INC, 

m”lRET, 


m~JB, 

ra_JBE, 

m_JE, 

m_JG, 


m_ JL E, ra_JNA, 

m JNBE, m JNC 


m JNGE, 

m JNL, 

m JNP, 

m JNS, 

m JP, 

m JPE, 


m_JZ, m_JMP, 

m LES, m LEA, 


m LOOPNE, 

m LOOPNZ 

m_MOVS, 

m_MUL, 

m NOT, 

m OR, 

m_POPF, 

m_PUSH, 

m ROL, 

m ROR, 

m REPNE, 


m_RETN, 

m_RETNP, 

ra_SHL, 

m_SHR, 

m STI, 

m STOS, 

m_WAIT, 

m_XCHG, 


8087/80187/80287 Floating Point Processor instructions 


m FABS, 

m FADD, 

m FADDD, 

m FADDP, 

m FBLD, 

m FBSTP, 

m FCHS, 

m FNCLEX, 

m FCOM, 

m FCOMD, 

m FCOMP, 

m FCOMPD, 

m FCOMPP, 

m FDECSTP, 

m FDIV, 

m FDIVD, 

m FDIVP, 

ra FDIVR, 

ra FDIVRD, 

m FDIVRP, 

m FFREE, 

ra FIADD, 

m FIADDD, 

m FICOM, 

m FICOMD, 

ra”FICOMP, 

m FICOMPD, 

m_FIDIV, 

m FIDIVD, 

ra~FIDIVR, 

ra FIDIVRD, 


m FILD, 

ra FILDD, 

m FILDL, 

m FIMUL, 

m FIMULD, 

m FINCSTP, 

ra FNINIT, 

m_FIST, 


m_FISTD, m_FISTP, m_FISTPD, m_FISTPL, 

m FISUB, 


m_FISUBD, 

ra FISUBR, 

ra FISUBRD, 

ra_ 

FLD, 

m FLDD, 

ra FLDCW, 

n FLDENV, 

m_ 

FLDLG2, 

m_FLDLN2, 

n FLDL2E, 

m_FLDL2T, 

m_ 

FLDPI, 

m_FLDZ, 

m FLD1, 

IQ FMUL, 

ra_ 

FMULD, 

ra FMULP, 

ra FNOP, 

m FPATAN, 

m_ 

FPREM, 

m FPTAN, 

ra FRNDINT, 

m FRSTOR, 

m_ 

FSAVE, 

m FSCALE, 

m“FSETPM, 

ra_FSQRT, 



m FST, 

ra FSTD, 

ra_FSTCW, 




F-24 


DOC International A/S 




Appendix F 

Implementation-Dependent Characteristics 


m_FSTENV, 
m_FSTSWAX, 
m_FSUBR, 
m FWAIT, 
ra~FYL2X, 


m FSTP, 
m~FSUB, 
ra~FSUBRD, 
m~FXAM, 
m~FYL2XPl, 


m_FSTPD, 
m FSUBD, 
m~FSUBRP, 
m_FXCH, 
ra F2XM1, 


m_FSTSW, 
m_FSUBP, 
m_FTST, 
m_FXTRACT, 


-- 80186/80286/80386 instructions: 

— Notice that some immediate versions ot the 8086 instructions 

— only exist on these targets (shifts, rotates, push, imul, 


m_B0UND, 
m_LAR, 
m LSL 
m“SGDT, 
m_ARPL, 
ra_SLDT, 
ra VERW, 


m CLTS, 

ra~LEAVE, 

nfoUTS 

nTsiDT, 

oTlLDT, 

rnTSMSW, 


m_ENTER, 
m_LGDT, 
m_POPA, 

m_LMSW, 
m STR, 


m_INS, 
m_LIDT 
m_PUSHA 

m_LTR, 
m VERR, 


— the 80386 specific instructions: 


m SETA, 

m SETAE, 

m SETB, 

m_ 

SETBE, 

ra SETC, 

ra'SETE, 

m SETG, 

m 

SETGE, 

m SETL, 

m'SETLE, 

m SETNA, 

m_ 

‘SETNAE 

ra SETNB, 

m~SETNBE, 

m SETNC, 

ra 

"SETNE, 

ra SETNG, 

m'SETNGE, 

m SETNL, 

m 

"SETNLE 

ra SETNO, 

m~*SETNP, 

in SETNS, 

m 

SETNZ, 

ra SETO, 

itfSETP, 

m SETPE, 

m 

"SETPO, 


m SETS, ra SETZ, 


m BSF, 

ra__BSR, 



m BT, 

m~BTC, 

m_BTR, 

m_BTS, 

m LFS, 

ra~LGS, 

ra_LSS, 


ra MOVZX 

ra~M0VSX, 



m MOVCR, 

m'MOVDB, 

ra_MOVTR, 


m SHLD, 

m'shrd. 




— the 80387 specific Instructions 


m_FUC0M, 
n FPREM1, 


ra FUCOMP, 
■TfSIN, 


m_FUC0MPP 
m FCOS, 


m FSINCOS 


DOC International A/S 


F-25 




Appendix F 

Implementation-Dependent Characteristics 


— byte/word/dword variants (to be used, when not deductible from 

— context) 


m_ADDCB, 

m ADCW, 

m_ADCD, 

m ADDB, 

m ADDW, 

m ADDD, 

m ANDB, 

m_ANDW, 

m_ANDD, 

m_BTW, 

m BTD, 


m BTCW, 

m_BTCD, 


m BTRW, 

ra BTRD, 


m BTSW, 

m_BTSD, 



m_CBWW, m_CWD E, 

m_CWDW m_CDQ, 


m CMPB, 

ra CMPW, 

m CMPD, 

m CMPSB, 

m_CMPSW, 

m CMPSD, 

m DECB, 

m DECW, 

m DECD, 

m DIVB, 

ra DIVW, 

m DIVD, 

m IDIVB, 

m IDIVW, 

ra IDIVD, 

m IMULB, 

m IMULW, 

m IMULD, 

m INCB, 

m INCW, 

ra INCD, 

m_INSB, 

m INSW, 

m_INSD, 

m LODSB, 

m LODSW, 

m LODSD, 

m MOVB, 

ra MOVW, 

m MOVD, 

m MOVSB, 

m MOVSW, 

m_MOVSD, 

m MOVSXB, 

m MOVSXW, 


m MOVZXB, 

m MOVZXW, 


ra MULB, 

m MULW, 

m MULD, 

m NEGB, 

m NEGW, 

m NEGD, 

m_NOTB, 

ra NOTW, 

ra_NOTD, 

m ORB, 

m ORW, 

m ORD, 

m OUTSB, 

ra_OUTSW, 

m_OUTSD, 

m POPW, 

m POPD, 


m_PUSHW, 

m PUSHD, 


m_RCLB, 

m RCLW, 

ra_RCLD, 

m_RCRB, 

m RCRW, 

m_RCRD, 

ra ROLB, 

ra ROLW, 

ra_ROLD, 

m_RORB, 

ra RORW, 

ra_RORD, 

ra_SALB, 

m SALW, 

m_SALD, 

ra SARB, 

ra SARW, 

m SARD, 

ra SHLB, 

m~SHLW, 

ra SHLDW, 

m_SHRB, 

ra SHRW, 

m_SHRDW, 

ra_SBBB, 

ra_SBBW, 

m_SBBD, 

m SCASB, 

ra~SCASW, 

ra SCASD, 

m STOSB, 

ra STOSW, 

m_STOSD, 

m_SUBB, 

m~SUBW, 

ra_SUBD, 

m TESTB, 

ra~TESTW, 

m TESTD, 

m XORB, 

ra~XORW, 

m_XORD, 

m DATAB, 

ra~DATAW, 

in DATAD 


— Special 'instructions' 

m label, m reset); 


F-26 



DOC International A/S 






Appendix F 


▼ 


Implamentation-Dependent Characteristics 


type operand_type is ( none. 


no operands 


immediate, 
register, 
address, 
system_address, 
name, 

register_immediate, 


register_register, 
register_address, 


address_register, 


register_system_address, 


system_address_register, 


address_immediate, 


system_address immediate. 


immediate_register. 


immedlate_imraediate, 
register_register_immediate, 


register_address_immediate 

register_system_address_immediate 

address_register_immediate 

system_address_register_immediate 


); 


1 immediate operand 
1 register operand 
1 address operand 

1 'address operand 
CALL name 

2 operands: dest is 
register, source is 
immediate 

2 register operands 
2 operands: dest 
is register, 
source is address 
2 operands: dest is 
address, 

source is register 
2 operands: dest is 
register, 

source is 'address 
2 operands: dest is 
'address, 

source is register 
2 operands: dest is 
'address, 

source is immediate 
2 operands: dest is 
'address, 

source is immediate 

only allowed for OUT port 

is 

immediate source is 
register 

only allowed for ENTER 
allowed for 
IMULimm,SHRDimm, and 
SHLDimm 

allowed for IMULimm 
allowed for IMULimm 
allowed for SHRDimm, 
SHLDimm 

allowed for SHRDimm, 
SHLDimm 


type register type is (AX, CX, DX, BX, 

— word 

registers 

SP, BP, SI, DI, 

— 


AL, CL, DL, BL, 

— byte 

registers 

AH, CH, DH, BH, 

-- 



DOC International A/S 


F-27 








Appendix F 

Implementation-Dependent Characteristics 


EAX, ECX, EDX, 

EBX 

— dword registers 

ESP, EBP, ESI, 

EDI 


ES, CS, SS, DS 
FS, GS 

t 

-- selector registers 

BX SI, 

BX DI, 


— 8086/80186/80286 

BP~SI, 

BP_DI, 


— combinations 

ST, ST1, ST2, 

ST3, 

— floating stack 

— registers 

ST4, ST5, ST6, 
nil ); 

ST7, 



type segment_register is ( ES, CS, SS, DS, FS, GS, nil ); 
subtype machine_string is string (1..100); 
pragma page; 

type machine_instruction (operand_kind : operand_type is record 
opcode : opcode_type; 


case operand_kind is 

when immediate => 
immediate 

when register => 
r_register 

when address => 
a_segment 
a_address_reg 
a_of£set 

when system_address => 
sa_address 

when name »> 
n_string 

when register_immediate => 
r_i_register 
r_i_immediate 

when register_register «> 
r_r_register_to 
r_r_register_frora 

when register_address »> 
r_a_register_to 
r_a_segment 
r_a~address_reg 


integer; 
register_type; 


register_type; 
register_type; 
integer; 


system.address; 
machine_string; 


register_type; 
integer; 


register_type; 
register_type; 


register_type; 
segment_register; 
register type; 


00C International A/S 


F-28 









Appendix F 

Implementation-Dependent Characteristics 


r a offset 


integer; 


when address_register *> 
a_r_segment 
a_r_address_reg 
a_r_offset 
a_r_register_from 


segment_register; 
register_type; 
integer; 
register_type; 


when register_system_address 
r_sa_register_to 
r sa address 


-> 

: register_type; 
; system.address 


when system_address_register 
sa_r_address 
sa_r_reg_from 


= > 

; system.address; 
: register_type; 


when address_immediate = > 
a_i_segment 
a_i_address_reg 
a_i_offset 
a i immediate 


segment_register; 
register_type; 
integer; 
integer; 


when system_address_immediate *> 

sa_i_address : system.address; 

sa_i~imraediate : integer; 


when immediate_register *> 
i_r_register 
i_r_register 

when immediate_immediate => 
i_i_immediatel 
i i inunediate2 


integer; 
register_type; 


integer; 

integer; 


when register_register_imraediate *> 

r_r_i_registerl : register_type; 
r_r_i_register2 ; register_type; 
r_r_i_immediate2 ; integer; 


when register_address_immediate 
r_a_i_register ; 

r_a_i_segment : 

r_a_i_address_reg ; 

r_a_i_offset ~ ; 

r a i immediate : 


register_type; 
register_type; 
register_type; 
integer; 
integer; 


when register_system_address_immediate ■> 

r_sa_i_register : register_type; 

addrlO ; system.address; 

r_sa_i_immediate ; integer; 


DOC International A/S 


F-29 







Appendix F 

Implementation-Dependent Characteristics 


when address_register__immediate 
a_r_i_register ~ : 

a_r_i_segment : 

a_r_i_address_reg : 

a_r_i_offset : 

a r i immediate : 


register_type; 
register_type; 
register_type; 
integer; 
integer; 


when system_address_register_immediate ■> 

sa_r_i_address : system.address; 

sa_r_i_register : register_type; 

sa r i immediate : integer; 


when others => 
null; 
end case; 
end record; 


F. 9.2 _ Restrictions 

Only procedures, and not functions, may contain machine code inser¬ 
tions. Also procedures that use machine code insertions must be 
specified with PRAGMA inline. 

Symbolic names in the form x'ADDRESS can only be used in the follow¬ 
ing cases: 

1) x is an object of scalar type or access type declared as an 
object, a formal parameter, or by static renaming. 

2) x is an array with static constraints declared as an object 
(not as a formal parameter or by renaming). 

3) x is a record declared as an object (not a formal parameter 
or by renaming). 

All opcodes defined by the type OPCODE_type except the m_CALL can be 
used. 

Two opcodes to handle labels have been defined: 

m_label: defines a label. The label number must be in the range 

1 <■ x <■ 25 and is put in the offset field in the first 
operand of the MACHINE_INSTRUCTION. 

m_reset: used to enable use of more than 25 labels. The label num¬ 

ber after a m_RESET must be in the range 1 <* x <>25. To 
avoid errors you must make sure that all used labels have 
been defined before a reset, since the reset operation 
clears all used labels. 


F-30 


00C International A/S 





"Iff 


Appendix F 

Implementation-Dependent Characteristics 


All floating instructions have at most one operand which can be any 
of the following: 

a memory address 

- a register or an immediate value 

- ’an entry in the floating stack 


The following section contains examples of how to use the machine 
code insertions and lists the generated code. 


F.9.3.1 _ Example Using Labels 

The following assembler code can be described by machine code inser¬ 
tions as shown: 

MOV AX, 7 

MOV CX,4 

CMP AX,CX 

JG 1 

JE 2 

MOV CX, AX 

1: ADD AX,CX 

2: MOV SS: [BP+DI], AX 

with MACHINE_CODE; use MACHINE_CODE; 
package example_MC is 

procedure test_labels; 
pragma inline (test_labels); 

end example_MC; 

package body example_MC is 


procedure test_labels is 
begin 

MACHINE_INSTRUCTION’(register_immediate, m MOV, AX, 7); 
MACHINE_INSTRUCTION'(register_immediate, m~MOV, CX, 4); 
MACHINE_INSTRUCTI0N'(register register, m_CMP, AX, CX); 
MACHINE INSTRUCTION’(immediate, ra_JG, 1); 
MACHINE-INSTRUCTION'(immediate, ra JE, 2); 
MACHINE”lNSTRUCTION'(register_reglster, m_MOV, CX, AX); 
MACHINE”lNSTRUCTION’(immediate, m label, 1); 


DOC International A/S 


F-31 






'11^ Appendix F 

Implementation-Dependent Characteristics 


MACHINE_INSTRUCTION’(register_register, m ADD, AX, CX); 
MACHINE_INSTRUCTION'(immediate, m_label, 2); 
MACHINE_INSTRUCTION *(address_register,ra_MOV,SS,BP_DI,0,AX); 

end test_labels; 

end example MC; 


F.10 Package Tasktypes 

The TaskTypes package defines the TaskControlBlock type. 


with System; 


package TaskTypes is 

subtype Offset is System.UnsignedDWord; 
subtype Blockld is System.UnsignedDWord; 


TaskEntry 
EntryIndex 


type 
type 
type 

type Ticks 

type Bool 

for Bool'size 

type Ulntg 


is new System.UnsignedDWord; 
is new System.UnsignedDWord; 
Altemativeld is new System.UnsignedDWord; 

is new System.UnsignedDWord; 
is new Boolean; 
use 8; 

is new System.UnsignedDword; 


type Semaphore is record 

counter : Integer; 

first, last : System.TaskValue; 

end record; 

type TaskState is (Initial, 

-- The task is created, but activation 

— has not started yet. 

Engaged, 

— The task has called an entry, and the 

— call is now accepted, ie. the rendezvous 

— is in progress. 

Running, 

— Covers all other states. 


Delayed, 

— The task awaits a timeout to expire. 
EntryCallingTimed, 

— The task has called an entry which 

— is not yet accepted. 


F-32 


00C International A/S 







Appendix F 




Implementation-Dependent Characteristics 


EntryCallingUnconditional, 

— The task has called an entry 

— unconditionally, 

— which is not yet accepted. 

SelectingTimed, 

— The task is waiting in a select 

— statement with an open delay 

— alternative. 

SelectingUnconditional, 

-- The task waits in a select statement 

-- entirely with accept statements. 

SelectingTerminable, 

— The task waits in a select statement 

— with an open terminate alternative. 

Accepting, 

— The task waits in an accept statement. 

Synchronizing, 

— The task waits in an accept statement 

— with no statement list. 

Completed, 

— The task has completed the execution of 

— its statement list, but not all 

— dependent tasks are terminated. 

Terminated ); 

— The task and all its descendants 

-- are terminated. 

for TaskState use (Initial *> 16#00# , 

Engaged »> 16#08# , 

Running ■> 16#10# , 

Delayed -> 16#18# , 

EntryCallingTimed *> 16#20# , 
EntryCallingUnconditional *> 16#28# , 
SelectingTimed *> 16#31# , 
SelectingUnconditional *> 16#39# , 
SelectingTerminable ■ > 16#41# , 
Accepting *> 16#4A# , 

Synchronizing -> 16#53# , 

Completed -> 16#5C# , 

Terminated »> 16#64#); 

for TaskState'size use 8; 

type TaskTypeDescriptor is 
record 


00C International A/S 


F-33 








Appendix F 




Implementation-Dependent Characteristics 


priority 

entry_count 

block_id 

first_own_address 

module_number 

entry_number 

code_address 

stack_size 

dummy 

stack_segment_size 
end record; 


System.Priority; 
Ulntg; 

Blockld; 

System.Address; 
Ulntg; 

Ulntg; 

System.Address; 
System.DWord; 
Integer; 

Ulntg; 


for TaskTypeDescriptor use 
record 


priority 

at 

0 

range 

0 . 

.31; 

entry_count 

at 

2 

range 

0 . 

.31; 

block_id 

at 

4 

range 

0 . 

.31; 

first own address 

at 

6 

range 

0 . 

.31; 

module_number 

at 

8 

range 

0 . 

.31; 

entry_number 

at 

10 

range 

0 . 

.31; 

code_address 

at 

12 

range 

0 . 

.31; 

stack_size 

at 

14 

range 

0 . 

.31; 

dummy 

at 

16 

range 

0 . 

.31; 

stack_s egme nt_siz e 

at 

18 

range 

0 . 

.31; 


end record; 


type AccTaskTypeDescriptor is access TaskTypeDescriptor; 
type NPXSaveArea is array(1..54) of System.UnsignedWord; 
pragma page; 

type TaskControlBlock is 
record 

sem ; Tasktypes.Semaphore; — Should be system.semaphore 

— but 4.2 version of 

— system is still used 

— Delay queue handling 


dnext 

dprev 

ddelay 


; System.TaskValue ; 
: System.TaskValue ; 
: Ticks ; 


— Saved registers 


: System.UnsignedWord ; 
; Offset ; 


— Ready queue handling 


next 


: System.TaskValue ; 


F-34 


00C International A/S 






Appendix F 




Implementation-Dependent Characteristics 


-- Semaphore handling 

semnext : System.TaskValue ; 

— Priority fields 

priority : System.Priority; 

saved_priority : System.Priority; 

— Miscelleanous fields 

time_slice : System.UnsignedWord; 

NPXFlag : Bool; 

InterruptFlag : Bool; 

ReadyCount : System.Word; 

— Stack Specification 

stack_start : Offset; 

stack_end ; Offset; 

— State fields 

state ; Taskstate; 

is_abnormal : Bool; 

is_act±vated : Bool; 

failure ; Bool; 

— Activation handling fields 

activator ; System.TaskValue; 

act_chain : System.TaskValue; 

next_chain : System.TaskValue; 

no_not_act : System.Word; 

act_block ; Blockld; 

-- Accept queue fields 

partner ; System.TaskValue; 

next_partner ; System.TaskValue; 

-- Entry queue fields 

next_caller : System.TaskValue; 

— Rendezvous fields 

called_task : System.TaskValue; 

task_entry ; TaskEntry; 

entry_index ; EntryIndex; 

entry_assoc ; System.Address; 

call_params : System.Address; 


F-35 


DOC International A/S 






Appendix F 

Implementation-Dependent Characteristics 




alt_id : Alternativeld; 

excp_id : System.Exceptionld; 

— Dependency fields 


parent_task : 
parent”block : 
child_task : 
next_child : 
first__child : 
prev_child : 
child_act : 
block_act : 
terminated task: 


System.TaskValue; 
Blockld; 

System.TaskValue; 
System.TaskValue; 
System.TaskValue; 
System.TaskValue; 
System.Word; 
System.Word; 
System.TaskValue; 


Abortion handling fields 


busy : System.Word; 

-- Auxiliary fields 


ttd : AccTaskTypeDescriptor; 

FirstCaller : System.TaskValue; 


— Run-Time System fields 

ACF : System.UnsignedWord; — cf. User's Guide 

— 9.4.2 

collection : System.Address; 


-- NPX save area 


— When the application is linked with /NPX, a special 

— save area for the NPX is allocated at the very end 
-- of every TCB. 

— ie: 


case NPX_Present is 

when TRUE => NPXsave : NPXSaveArea; 

when FALSE -> null; 
end case; 

end record; 

for TaskControlBlock use 
record 


sem 

at 

0 

range 

0 . 

.95; 

dnext 

at 

6 

range 

0 . 

.31; 

dprev 

at 

8 

range 

0 . 

.31; 

ddelay 

at 

10 

range 

0 . 

.31; 

SS 

at 

12 

range 

0 . 

.15; 

SP 

at 

13 

range 

0 . 

.31; 


F-36 


DOC International A/S 



Appendix F 

Implementation-Dependent Characteristics 


next 

at 

15 

range 

0..31; 

semnext 

at 

17 

range 

0..31; 

priority 

at 

19 

range 

0. .31; 

saved_priority 

at 

21 

range 

0..31; 

time slice 

at 

23 

range 

0..15; 

NPXFlag 

at 

24 

range 

0. .7; 

InterruptFlag 

at 

24 

range 

8..15; 

ReadyCount 

at 

25 

range' 

0..15; 

stack_start 

at 

26 

range 

0..31; 

stack end 

at 

28 

range 

0. .31; 

state 

at 

30 

range 

0. . 7; 

is_abnormal 

at 

30 

range 

8. .15; 

is activated 

at 

31 

range 

0. . 7; 

failure 

at 

31 

range 

8. .15 

activator 

at 

32 

range 

0. .31 

act chain 

at 

34 

range 

0. .31 

next chain 

at 

36 

range 

0. .31 

no_not_act 

at 

38 

range 

0. .15 

act block 

at 

39 

range 

0. .31 

partner 

at 

41 

range 

0. .31 

next_partner 

at 

43 

range 

0. .31 

next_caller 

at 

45 

range 

0. .31 

called_task 

at 

47 

range 

0. .31 

task_entry 

at 

49 

range 

0. .31 

entry_index 

at 

51 

range 

0. .31 

entry_assoc 

at 

53 

range 

0. .31 

call params 

at 

55 

range 

0. .31 

alt_id 

at 

57 

range 

0. .31 

excp_id 

at 

59 

range 

0. .63 

parent_task 

at 

63 

range 

0. .31 

parent_block 

at 65 

range 

0. .31 

child_task 

at 

67 

range 

0. .31 

next_child 

at 

69 

range 

0. .31 

first_child 

at 

71 

range 

0. .31 

prev_child 

at 

73 

range 

0. .31 

child_act 

at 

75 

range 

0. .15 

block_act 

at 

76 

range 

0. .15 

terminated_task 

at 

77 

range 

0. .31 

busy 

at 

79 

range 

0. .15 

ttd 

at 

80 

range 

0. .31 

FirstCaller 

at 

82 

range 

0. .31 

ACF 

at 

84 

range 

0. .31 

collection 

at 

86 

range 

0. .31 


end record; 
end TaskTypes; 


DOC International A/S 


F-37 





APPENDIX C 


TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, 
such as the maximum length of an input line and invalid file names. A 
test that makes use of such values is identified by the extension .TST 
in its file name. Actual values to be substituted are represented by 
names that begin with a dollar sign. A value must be substituted for 
each of these names before the test is run. The values used for this 
validation are given below. 


$ACC_SIZE 32 

An integer literal whose value 
is the number of bits sufficient 
to hold any value of an access 
type. 

$BIG_ID1 1..125 -> 'A', 126 -> '1' 

Identifier the size of the 

maximum input line length with 

varying last character. 

$BIG_ID2 1..125 -> 'A', 126 -> '2' 

Identifier the size of the 

maximum input line length with 

varying last character. 

$BIG_ID3 

Identifier the size of the 

maximum input line length with 

varying middle character. 

$BIG_ID4 

Identifier the size of the 

maximum input line length with 

varying middle character. 

$BIG_INT_LIT 1..123 -> 0, 124..126 -> 298 

An integer literal of value 298 
with enough leading zeroes so 
that it is the size of the 
maximum line length. 

$BIG_REAL_LIT 1..121 -> 0, 122..126 -> 690.0 

A universal real literal of 
value 690.0 with enough leading 
zeroes to be the size of the 


1.. 63 -> 'A', 64 -> '4', 

65.. 126 -> 'A' 


1.. 63 -> 'A', 64 -> '3', 

65.. 126 -> 'A' 


C-l 






maximum line length. 

$BIG_STRING1 1..63 -> 'A' 

A string literal which when 

catenated with BIG_STRING2 
yields the image of BIG_ID1. 

$BIG_STRING2 1..62 -> 'A', 

A string literal which when 

catenated to the end of 
BIG_STRING1 yields the image of 
BIG ID1. 


$BLANKS 1..106 -> ' ' 

A sequence of blanks twenty 
characters less than the size 
of the maximum line length. 

$COUNT_LAST 2147483647 

A universal integer 

literal whose value is 
TEXT_I0.COUNT'LAST. 

$ D E FAULT_MEM_SIZE 16#100000000# 

An integer literal whose value 
is SYSTEM.MEMORY SIZE. 


$DEFAULT_STOR_UNIT 16 

An integer literal whose value 
is SYSTEM.STORAGE UNIT. 


$ D E FAULT_SYS_NAME 

The value of the 

SYSTEM.SYSTEM_NAME. 

$DELTA_D0C 

A real literal whose 
SYSTEM.FINE_DELTA. 

$FIELD_LAST 

A universal 

literal whose 
TEXT_I0.FIELD'LAST. 

$FIXED_NAME 

The name of a 

fixed-point type 
DURATION. 


IAPX386_FM 

constant 


2#1.0#E-31 

value is 


35 

integer 
value is 


NO_SUCH_TYPE 

predefined 
other than 


$FLOAT_NAME NO_SUCH_TYPE 

The name of , a predefined 
floating-point type other than 


63 -> '1' 


C-2 




FLOAT, SHORT_FLOAT, or 

LONG_FLOAT. 

$GREATER_THAN_DURATION 

A universal real literal that 
lies between DURATION'BASE'LAST 
and DURATION'LAST or any value 
in the range of DURATION. 

$ GREATER_THAN_DURATION_BASE_LAST 

A universal real literal that is 
greater than DURATION'BASE’LAST. 

$HIGH_PRIORITY 

An integer literal whose value 
is the upper bound of the range 
for the subtype SYSTEM.PRIORITY. 

$ILLEGAL_EXTERNAL_FILE_NAME1 

An external file name which 
contains invalid characters. 

?ILLEGAL_EXTERNAL_FILE_NAME2 

An external file name which 
is too long. 

$INTEGER_FIRST 

A universal integer literal 
whose value is INTEGER'FIRST. 

$INTEGER_LAST 

A universal integer literal 
whose value is INTEGER'LAST. 

$INTEGER_LAST_PLUS_1 

A universal integer literal 
whose value is INTEGER'LAST + 1. 

$LESS_THAN_DURATION 

A universal real literal that 
lies between DURATION'BASE'FIRST 
and DURATION'FIRST or any value 
in the range of DURATION. 

$LESS_THAN_DURATION_BASE_FIRST 

A universal real literal that is 
less than DURATION’BASE'FIRST. 

$LOW_PRIORITY 

An integer literal whose value 
is the lower bound of the range 
for the subtype SYSTEM.PRIORITY. 


100000.0 


200000.0 


31 


ILLEGAL/!*/@#$% A 


ILLEGAL&(*/)_+- 


-2147483648 


2147483647 


2147483648 


- 100000.0 


- 200000.0 


0 


C-3 








31 


$MANTISSA_DOC 

An integer literal whose value 
is SYSTEM.MAX_MANTISSA. 

$MAX_DIGITS 15 

Maximum digits supported for 
floating-point types. 

$MAX_IN_LEN 126 

Maximum input line length 
permitted by the implementation. 

$MAX_INT 9223372036854775807 

A universal integer literal 
whose value is SYSTEM.MAX_INT. 

$MAX_INT_PLUS_1 9223372036854775808 

A universal integer literal 
whose value is SYSTEM.MAX_INT+1. 

$MAX_LEN_INT_BASED_LITERAL 1..2 -> '2:', 3..123 -> '0' 

A universal integer based 124..126 -> '11:' 
literal whose value is 2#11# 
with enough leading zeroes in 
the mantissa to be MAX_IN_LEN 
long. 

$MAX_LEN_REAL_BASED_LITERAL 1..3 -> '16:', 4..122 -> '0 

A universal real based literal 123..126 -> 'F.E:' 
whose value is 16:F.E: with 
enough leading zeroes in the 
mantissa to be MAX_IN_LEN long. 

$MAX_STRING_LITERAL 1 -> , 2..125 -> 'A', 

A string literal of size 126 -> 

MAX_IN_LEN, including the quote 
characters. 

$MIN_INT -9223372036854775808 

A universal integer literal 
whose value is SYSTEM.MIN_INT. 

$MIN_TASK_SIZE 32 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
no entries, no declarations, and 
"NULL;" as the only statement in 
its body. 

$NAME NO SUCH TYPE 


C-4 





A name of a predefined numeric 
type other than FLOAT, INTEGER, 

SHORT_FLOAT, SHORT_INTEGER, 

LONG_FLOAT, or LONG_INTEGER. 

$NAME_LIST IAPX386_FM 

A list of enumeration literals 
in the type SYSTEM.NAME, 

separated by commas. 

$NEG_BASED_INT 16#FFFFFFFFFFFFFFFF# 

A based integer literal whose 
highest order nonzero bit 

falls in the sign bit 
position of the representation 

for SYSTEM.MAX_INT. 

$NEW_MEM_SIZE 16#100000000# 

An integer literal whose value 
is a permitted argument for 

pragma memory_size, other than 
$DEFAULT_MEM_SIZE. If there is 
no other value, then use 
$DEFAULT_MEM_SIZE. 

$NEW_STOR_UNIT 16 

An integer literal whose value 
is a permitted argument for 

pragma storage_unit, other than 
$DEFAULT_STOR_UNIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGEJJNIT. 

$NEW_SYS_NAME IAPX386_FM 

A value of the type SYSTEM.NAME, 
other than $DEFAULT_SYS_NAME. If 
there is only one value of that 
type, then use that value. 

$TASK_SIZE 32 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
a single entry with one inout 
parameter. 

$TICK 0.000_000_062_5 

A real literal whose value is 
SYSTEM.TICK. 


C-5 



APPENDIX D 


WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to 
the Ada Standard. The following 44 tests had been withdrawn at the time 
of validation testing for the reasons indicated. A reference of the 
form Al-ddddd is to an Ada Commentary. 

A39005G 

This test unreasonably expects a component clause to pack an array 
component into a minimum size (line 30). 

B97102E 

This test contains an unintended illegality: a select statement 
contains a null statement at the place of a selective wait alternative 
(line 31). 

C97116A 

This test contains race conditions, and it assumes that guards are 
evaluated indivisibly. A conforming implementation may use interleaved 
execution in such a way that the evaluation of the guards at lines 50 & 
54 and the execution of task CHANGING_OF_THE_GUARD results in a call to 
REPORT.FAILED at one of lines 52 or 56. 

BC3009B 

This test wrongly expects that circular instantiations will be detected 
in several compilation units even though none of the units is illegal 
with respect to the units it depends on; by AI-00256, the illegality 
need not be detected until execution is attempted (line 95). 

CD2A62D 

This test wrongly requires that an array object's size be no greater 
than 10 although its subtype's size was specified to be 40 (line 137). 

CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] 

These tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them to a 
derived subprogram (which implicitly converts them to the parent type 
(Ada standard 3.4:14)). Additionally, they use the 'SIZE length clause 
and attribute, whose interpretation is considered problematic by the WG9 
ARG. 

CD2A81G, CD2A83G, CD2A84M & N, & CD50110 

These tests assume that dependent tasks will terminate while the main 
program executes a loop that simply tests for task termination; this is 
not the case, and the main program may loop indefinitely (lines 74, 85, 
86 & 96, 86 & 96, and 58, resp.). 


D-l 




A, 






CD2B15C & CD7205C 

These tests expect that a 'ST0RAGE_SI2E length clause provides precise 
control over the number of designated objects in a collection; the Ada 
standard 13.2:15 allows that such control must not be expected. 

CD2D11B 

This test gives a SMALL representation clause for a derived fixed-point 
type (at line 30) that defines a set of model numbers that are not 
necessarily represented in the parent type; by Commentary AI-00099, all 
model numbers of a derived fixed-point type must be representable values 
of the parent type. 

CD5007B 

This test wrongly expects an implicitly declared subprogram to be at the 
address that is specified for an unrelated subprogram (line 303). 

ED7004B, ED7005C & D, ED7006C & D [5 tests] 

These tests check various aspects of the use of the three SYSTEM 
pragmas; the AVO withdraws these tests ac being inappropriate for 
validation. 

CD7105A 

This test requires that successive calls to CALENDAR.CLOCK change by at 
least SYSTEM.TICK; however, by Commentary AI-00201, it is only the 
expected frequency of change that must be at least SYSTEM.TICK -- 
particular instances of change may be less (line 29). 

CD7203B, & CD7204B 

These tests use the 'SIZE length clause and attribute, whose 
interpretation is considered problematic by the WG9 ARG. 

CD7205D 

This test checks an invalid test objective: it treats the specification 
of storage to be reserved for a task's activation as though it were like 
the specification of storage for a collection. 

CE2107I 

This test requires that objects of two similar scalar types be 
distinguished when read from a file--DATA_ERROR is expected to be raised 
by an attempt to read one object as of the other type. However, it is 
not clear exactly how the Ada standard 14.2.4:4 is to be interpreted; 
thus, this test objective is not considered valid. (line 90) 

CE3111C 

This test requires certain behavior, when two files are associated with 
the same external file, that is not required by the Ada standard. 

CE3301A 

This test contains several calls to END_OF_LINE & END_OF_PAGE that have 
no parameter: these calls were intended to specify a file, not to refer 
to STANDARD_INPUT (lines 103, 107, 118, 132, & 136). 


D-2 




CE3411B 

This test requires that a text file's column number be set to COUNT'LAST 
in order to check that LAYOUT_ERROR is raised by a subsequent PUT 
operation. But the former operation will generally raise an exception 
due to a lack of available disk space, and the test would thus encumber 
validation testing. 

E28005C 

This test expects that the string "-- TOP OF PAGE. --63" of line 204 
will appear at the top of the listing page due to a pragma PAGE in line 
203; but line 203 contains text that follows the pragma, and it is this 
that must appear at the top of the page^ 


D-3 





APPENDIX E 


COMPILER OPTIONS AS SUPPLIED BY 
DOC-I, Inc 


Compiler: 


DACS-386/UNIX, Version 4.4 


ACVC Version: 


1.10 


OPTION _ EFFECT _ 

One invokes the Ada compiler at the UNIX shell with the following 
command: 


$ ada (<option>) <source-file> 
where <option> is: 


-c <file> 
-d 


-e <file> 
l<library> 
-L 
-n 
-s 


-/s 

-X 


Specifies the configuration file. 

Generates information for the DDC-I Symbolic Ada 
Debugger. 

Directs error messages to specified file. 

Specifies program library used. 

Generates list file. 

Suppresses run-time checks. 

Copies Ada source text to program library 
(default). 

Does not copy Ada source text to program library. 
Creates a cross reference listing. 





