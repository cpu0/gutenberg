\ / rJ / / ftJ s 5 O pJ 




/tAJ* 


... /... S* 

J As — & / " C ^ 


3 O % <3: 

(NA5A-CR-18726G ) THE iqGAl.Os A COMMON LISP N91-13G84 

IMPLEMENTATION OF A MESSY GENETIC ALGORITHM 
(Houston Unlv.) 52 p CSCL 09S 

Unci js 

G3/61 03082*5 


mGAl.O: A Common LISP Implementation 
of a Messy Genetic Algorithm 


D avid E. Go ldbe rg 
T ravis Kerzic 


University of Alabama 


May 1990 


Cooperative Agreement NCC 9-16 
Re se arch Activity AI.12 


NASA Johnson Space Center 
Mission Support Directorate 
Mission Planning and Analysis Division 



Research Institute for Computing and Information Systems 
Universi ty of Houston - Clear Lake 


TECHNICAL REPORT 



The 

RICIS 

Concept 


The University of Houston-Clear Lake established the Research Institute for 
Computing and Information systems in 1986 to encourage NASA Johnson Space 
Center and local industry to actively support research in the computing and 
information sciences. As part of this endeavor, UH-Clear Lake proposed a 
partnership with JSC to jointly define and manage an integrated program of research 
in advanced data processing technology needed for JSC’s main missions, including 
administrative, engineering and science responsibilities. JSC agreed and entered into 
a three-year cooperative agreement with UH-Clear Lake beginning in May, 1 986, to 
jointly plan and execute such research through RICIS. Additionally, under 
Cooperative Agreement NCC 9-16, computing and educational facilities are shared 
by the two institutions to conduct the research. 

The mission of RICIS is to conduct, coordinate and disseminate research on 
computing and information systems among researchers, sponsors and users from 
UH-Clear Lake, NASA/JSC, and other research organizations. Within UH-Clear 
Lake, the mission is being implemented through interdisciplinary involvement of 
faculty and students from each of the four schools: Business, Education, Human 
Sciences and Humanities, and Natural and Applied Sciences. 

Other research organizations are involved via the “gateway” concept. UH-Clear 
Lake establishes relationships with other universities and research organizations, 
having common research interests, to provide additional sources of expertise to 
conduct needed research. 

A major role of RICIS is to find the best match of sponsors, researchers and 
research objectives to advance knowledge in the computing and information 
sciences. Working jointly with NASA/JSC, RICIS advises on research needs, 
recommends principals for conducting the research, provides technical and 
administrative support to coordinate the research, and integrates technical results 
into the cooperative goals of UH-Clear Lake and NASA/ JSC. 


mGAl.O: A Common LISP Implementation 
of a Messy Genetic Algorithm 


Preface 


This research was conducted under the auspices of the Research Institute for 
Computing and Information Systems by David E. Goldberg and Travis Kerzic, both 
of the Department of Engineering Mechanics at the University of Alabama. Dr. 
Terry Feagin, Professor of Computer Science at the University of Houston-Clear 
Lake, served as RICIS technical representative for this activity. 

Funding has been provided by the Mission Planning and Analysis Division 
within the Mission Support Directorate, NASA/JSC through Cooperative Agreement 
NCC 9-16 between NASA Johnson Space Center and the University of 
Houston-Clear Lake. The NASA technical monitor for this activity was Robert 
Savely, Head, Artificial Intelligence Section, Technology Development and 
Applications Branch, Mission Support Directorate, NASA/JSC. 

The views and conclusions contained in this report are those of the author and 
should not be interpreted as representative of the official policies, either express or 
implied, of NASA or the United States Government. 


mGAl.O: A Common LISP Implementation 
of a Messy Genetic Algorithm 


David E. Goldberg & Travis Kerzic 
Department of Engineering Mechanics 
University of Alabama 
Tuscaloosa, AL 35487 

TCGA Report No. 90004 
May 1990 


The Clearinghouse for Genetic Algorithms 
Department of Engineering Mechanics 
University of Alabama 
Tuscaloosa, AL 35487-0278 



mGAl.O: A Common LISP Implementation of a 
Messy Genetic Algorithm 


David E. Goldberg &: Travis Kerzic 
The University of Alabama 
Tuscaloosa, AL 35487 


1 Introduction 

Genetic algorithms (GAs) are search and optimization procedures based on the mechanics 
of natural selection and natural genetics (Goldberg, 1989a; Holland, 19(5). As we turn the 
- corner on the 1990s, GAs are finding increased application in difficult search, optimization, and 
machine learning problems in science and engineering. As more celebrants come to the party, 
increasing demands are being placed on algorithm performance, and the remaining challenges 
of genetic algorithm theory and practice are becoming increasingly unavoidable. Perhaps the 
most difficult of these challenges is the so-called linkage problem. Simply stated, the simple 
genetic algorithms most prominent in current practice assume that building blocks highly 
fit combinations of features or alleles— are physically compact to prevent their separation by 
the action of crossover. When this assumption is met m^when the problem-coding under 
consideration is not deceptive (Goldberg, 1989b, 1989c), simple GAs work quite well; if the 
needed linkage is loose and the function-coding is sufficiently difficult, then simple GAs can be 
misled toward local optima far away from the best point. Standard suggestions to get around , 
this difficulty, such as reordering operators, have not worked well in the past, and there are 
good theoretical reasons why they may never work well enough to be of timely use. (Goldberg 
& Bridges, 1990)> 

It is against this backdrop that messy genetic algorithms (mGAs) were developed (Goldberg, 
Deb, & Korb, 1990; Goldberg, Korb, & Deb, 1989), Messy GAs overcome the linkage prob- 
lem of simple genetic algorithms by combining variable-length strings, gene expression, messy 
operators, and a nonhomogeneous phasing of evolutionary processing. Results on a number of 
difficult deceptive test functions have been encouraging with the mGA always finding global 
optima in a polynomial number of function evaluations. Theoretical and empirical studies are 
continuing, and a first version of a messy GA is ready for testing by others. The purpose of 
this report is to document a Common LISP implementation called mGAl.O, 'and relate i(^to the . 
basic principles and operators developed by Goldberg et al. (1989, 1990). Although the code 
has f>£en, prepared with care, it is not a general-purpose code, only a research version. This first 
release contains the basic mGA as well as the thresholding mechanism discussed in Goldberg 
et al. (1990). It does not contain the tie-breaking mechanism with null bits; this feature will 
be released in the first update. 

In the remainder of this report, important data structures and global variables are described. 
Thereafter brief function descriptions are given, and sample input data are presented together 
with sample program output. A source listing with comments is also included. 


icc V.. mr rvw 

\ rr i.ofrcl 


1 


1.1 Programming and typing conventions 

A number of conventions were adopted in programming mGAl.O, and a number of typing 
conventions have been adopted in writing this report. 

All mGAl.O multiple- word user-defined functions and variables use an underscore between 
words instead of a hyphen. This makes them easier to distinguish from Common LISP standard 
functions. All function names are typed in all capital letters (e.g., OBJFUNC). All variable names 
are typed in all lower-case letters (e.g., bit_specif ier). 

All references to function or data names within the text are typed using the typeface font 
(e.g., ...when the bit_specif ier variable changes value...). 

2 Data Structures and Global Variables 

The processing in any GA may be viewed as a battle between the members of a population of 
artificial individuals or organisms set in the context of some environment or objective function. 
Thus, at least two types of data structure are necessary for mGA processing: those related to 
individuals and populations and those related to the objective function. In the remainder of this 
section, population and objective-function data structures and their components are described. 
In addition, a number of other global variables are detailed. 

2.1 Populations and individuals 

The program mGAl.O uses two nonoverlapping populations newpop and oldpop to coordinate 
genetic processing. Each generation, the new population, newpop, is created by selecting and 
perhaps recombining and mutating individuals within the old population, oldpop. Each popu- 
lation is a list containing popsize structures of the type populationjnember. Each individual 
(each an instance of the structure type populationjnember) carries the essential information 
about an individual required for genetic and objective-function processing. A schematic of the 
population and the information carried by each individual is shown in figure 1. The three 
components of the structure type populationjnember are as follows: 

chrom The variable chrom is a list of genes (ordered pairs), where each gene 
specifies a gene’s name (its number) and its value (a 1 or a 0). For ex- 
ample, the chrom ((2 0) (3 0) (1 1)) specifies the three-bit string 
001 in the usual fixed-position simple GA. The chrom lists are pro- 
cessed by cut, splice, and mutation operators. Gene redundancies and 
missing genes are handled in the decoding process. For example, the 
underspecified string in a three-bit problem ((2 1) (3 1)) with an 
all-zero competitive template would decode to the string 110, because 
the zero of the competitive template would fill in the missing position 
of the messy string. The overspecified string (in a three-bit problem) 
((2 0) (3 1) (1 1) (2 1)) would decode to the string 101, because 
the first instance of the second gene governs decoding on a left-to-right 
scan. After the decoding process, the objective function calculates a 
function value through one or more table look-up subfunctions. 

fitness The floating-point variable fitness stores the objective function value 
of chrom. mGAl.O assumes that fitness is a function to be maximized. 


2 



Figure 1: A schematic of the population structure shows the array of individuals together with 
a sample of the contents of a single individual. 


3 





subf_list The list of floating-point values subfJList stores the individual sub- 
function values for the objective function. For example, in a three- 
subfunction problem, if subfunction one has value 30, subfunction two 
has value 21, and subfunction three has value 22.3, the subf JList would 
have value (30 21 22.3). This storage is used for statistical recordkeep- 
ing. It is not used to aid in the genetic processing of mGAl.O (mGAl.O 
is a pure blind GA). 

2.2 Data structures associated with the objective function 

The objective function in mGAl.O takes the scaled sum of one or more table look-up subfunc- 
tions. This choice of objective function was dictated by the need to test the mGA on test 
functions that were composed of sums of deceptive functions of different size (order) and scale. 
In practical applications, the objective function and its data structures will require modification. 

To coordinate the summation of the separate subfunctions, a list bit_spec of structures of 
type bit_cluster is used to store the subset of bits to be used, the scale factor, and the look-up 
table number in the following three components: 

The list of integers bit .specifier names the genes (by number) required 
by the current subfunction. For example, the bit_specif ier (12 3) 
indicates that genes 1, 2, and 3 are used in that order by the current 
subfunction. 

The floating-point variable scale_f actor is a scale factor that multiplies 
the value of the subfunction found in the look-up table. It may be used to 
strengthen or weaken the relative contribution of the current subfunction 
to the total objective function value. 

The integer value table.speci.fier specifies the look-up table number 
to use when decoding current a subfunction. 

The other structures required for objective function processing are the look-up tables them- 
selves. The variable lookup .table contains a list of size numjtables where each element spec- 
ifies a full n-bit look-up table. The storage format is as follows: 

lookup .table The variable lookup.table is a list of lists, where each component list 
is a separate table. Each table is itself a list of lists where the separate 
entries contain the set of argument bits and their value. For example, 
the table entry for the bits 00 with value 5 would be stored as ((0 0) 5). 
An entire table with four entries would be written as 

(((0 0) 5) ( (0 1) 7.3) ((i 0) 9) ( (1 1) 12)) 

where the bit combinations 00 ,01 ,10, and 11 have values 5, 7.3, 9 
and 12, respectively. An entire example with two tables is given below: 

lookup.table = ((((0 0) 5)((0 1) 7.3)((1 0) 9) ( ( 1 1)12)) 
(((0 0) 1)((0 1) 2)((1 0) 0)((1 1) 5))). 


bit.specif ier 


scale factor 


table .specifier 


4 


Here the first table is the one discussed above, and the second is of the 
same size with values 1 , 2, 0 , and 5 . The table look up is done without 
regard to the ordering of entries. The look up is performed in a linear 
fashion, the first matching entry determining the returned value. If no 
match is found the value subfunction is set to 0. 

2.3 Global variables and data structures 

This subsection presents an alphabetized list of mGAl.O global variables and data structures 
together with brief descriptions of their purpose. A number of global variables are initialized 
during the setup process; detailed input data file description is presented later in this documen- 
tation. 


avgjf itness 
bits_per_chrom 
bit_spec 


bldg_blk^ize 


cookgen 

cut.prob 


cutpopgen 

data 


f irst.time 


garbage_collect 


indata 


The floating-point variable avg_fitness contains the average chromo- 
some fitness taken across the entire population. 

The integer variable bits_per_chrom specifies the total number of binary 
variables in the current objective function. 

This variable is a list of structures of type bit_cluster. Each structure 
specifies the realationship between sets of bits and look-up tables to 
permit objective function evaluation. See section 2.2 for a more detailed 
description. 

The integer variable bldg Jblk_size specifies the minimum building block 
size to be generated by MAKE JJEWJPOP. It represents the variable k in the 
population sizing equation 2* 

The integer variable cookgen specifies the number of generations in the 
primordial phase (the number of generations to cook the population). 

The floating-point variable cut_prob specifies the per-bit cut probabil- 
ity. This value is multiplied by a string’s raw length to determine the 
chromosomal cut probability. 

During the primordial phase, the population is cut in half every other 
generation through generation cutpopgen. 

The stream data specifies an output file for raw setup and generational 
data. The file has a header written at the beginning to specify the order 
of written information, and is intended for easy incorporation into a 
package with graphing abilities (e.g., MATLAB). 

The flag f irst.time is set to t prior to the first pass through the file 
setup routine. Thereafter the flag is nil. 

The integer variable garbage_collect specifies the number of generation 
between garbage collections. This number depends on the amount of 
memory a system has and on the population size. 

The variable indata is used as an input buffer for the setup file. 


5 



init select _gen 


instream 


lookupjtable 


loopvar 
max jiumgood 


maxfitness 


maxgen 


member_copies 


minf itness 


mut_prob 


newpop 


subf _pos jnax 


num_subfunctions 


numjtables 


numgood 


oldpop 


The integer variable init_select^gen specifies the number of genera- 
tions INIT_SELECTION will be used. 

The stream name instream defines the input stream and is used to read 
from the setup file. 

This variable is a list of look-up tables for objective- function processing. 
See section 2.2 for a more detailed description. 

The integer variable loopvar is used to count the number of generations. 

The integer variable max jiumgood is used to keep track of the maximum 
number of optimum building blocks in any single population member 
across the the current population. The optimum value is set by scanning 
individuals and the look-up tables in SETUP -SUBFUNC.MAX. 

The floating-point variable maxfitness contains the value of the maxi- 
mum fitness across the current population. 

The integer variable maxgen specifies the total number of generations 
that will be executed. 

The integer variable member_copies specifies how many copies of each 
population member will be made in the MAKE_NEW_POP function. 

The floating-point variable minf itness contains the value of the mini- 
mum fitness value across the current population. 

The floating-point variable mut_prob specifies the probability that a sin- 
gle bit will be mutated from a 1 to a 0 or vice versa by the MUTATION 
operator 

The variable newpop is a list of structures of type populationjnember. It 
contains the current population which is created from the old population 
via mGA operators every generation. See previous description in section 
2 . 1 . 

The floating point list subf _posjnax contains a list of the maximum 
values that each of the subfunctions can obtain. It is used by the function 
UPDATE-STATS to count the number of optimal building blocks. 

The integer variable num-subf unctions specifies the number of subfunc- 
tions in the current objective function. 

The integer variable num_tables specifies the total number of look-up 
tables. 

The integer variable numgood counts the the total number of optimal 
building blocks in the population. 

The list oldpop of structure type populationjnember contains the old 
population. See previous description in section 2.1. 


6 



pick 


popsize 

pspe 


screenfef ile 

seed 

setup .file 
shuffle 

shufnum 

splice^rob 

stack 

stat 
std_f ill 

sumf itness 

thres 

vertnum.spot 


The integer variable pick is used as a position marker and indexes into 
a population selection array shuffle used by the selection routines. 

The integer variable popsize specifies the current population size. 

The flag pspe is set to t to activate the partial-string-partial-evaluation 
mode within mGAl.O. When the flag is true, only fully specified subfunc- 
tions will be given a value other than zero. Otherwise, the std _f ill array 
(the competitive template) is used to fill the unspecified bit positions so 
that underspecified chromosomes can be decoded (see UPDATEJ3TATS). 

The stream name screen&file specifies statistical output that is di- 
rected to both the screen and the statistics file. 

The floating-point variable seed is used to seed the random number 
generator when the program is first initialized. 

The character string setupjf ile specifies the pathname of the setup file. 

The integer array shuffle contains a randomly generated permutation 
of the numbers ranging from one to popsize. 

The integer variable shufnum determines the subpopulation size searched 
to try to satisfy the requirement for having the threshold number of bits 
in common in the THRESH.SELECTION routine. 

The floating-point variable splice_prob specifies the probability that 
two chromosome pieces will be spliced together by the SPLICE operator. 

The list stack is where CUT -AND .STACK places its list of chromosome 
pieces (see figure 2). 

The file stream name stat is used to specify output to the statistics file. 

The array of integers std_fill is used to fill in unspecified positions 
during chromosome decoding. 

The floating-point variable sumf itness holds the sum of the fitness val- 
ues of all members of the current population and is used to calculate the 
population average fitness. 

The flag thres is set to t to dictate the use of thresholding through the 
selection function THRES HJ3 ELECT. 

The integer array vertnum^pot counts the number of optimal building 
blocks in each subfunction position across the population. 


3 Brief Function Descriptions 

This section presents an alphabetized list of brief function descriptions for primary routines 
called in the execution of mGAl.O. The functions are placed in seven separate files according 
to function: aux.lisp, decode. lisp, mga.lisp, objfunc.lisp, ops. lisp, setup. lisp, 


7 


and stats. lisp. The file aux . lisp contains utility and auxiliary code. The file decode. lisp 
contains code responsible for decoding a raw chromosome, thereby generating a processed chro- 
mosome. The file mga.lisp contains global variable declarations, the mGA function, and impor- 
tant phase coordination functions. The file objfunc.lisp contains functions related to sub- 
function look up, scaling, and summation. The file ops. lisp contains the genetic operators. 

The file setup. lisp contains initialization code, and the file stats. lisp contains statistical 
and reporting code. Each of the functions descriptions is followed by its corresponding file 
name. 

(CHOOSE nl n2) The function CHOOSE calculates the number of combinations of nl objects 
taken n2 at a time. (aux. lisp) 

(COMBINATION max_number num.places comb .list) The COMBINATION operator generates the 

next combination of max-number things taken num.places at a time in 
lexicographical order given the current combination in the list comb -list, 
(aux. lisp) 

(COMPLEMENT-BIT bit) The function COMPLEMENT-BIT changes a bit from a one to a zero or 

vice versa, (aux. lisp) 

(CROSSOVER matel mate2 cut.prob splice_prob) The function CROSSOVER takes two chro- 
mosomes mat el and mate2 and specified cut and splice probabilities 
cut_prob and splice _probl and returns a list of between one and four 
offspring chromosomes through coordinated invocation of the cut and 
splice operators. CROSSOVER executes calls to the functions CUT_AND .STACK 
and SPLICE-TESTER, (ops. lisp) 

(CUT chromosome) A chromosome is passed to the function CUT, whereupon a random cut 
point within the chromosome is selected, the chromosome is cut, and the 
two pieces are returned as a list. (ops. lisp) 

(CUT-AND -STACK matel mate2 cut_prob) Two chromosomes are passed to the function 

CUT _AND .STACK together with their cut probability cut-prob. The pieces 
are CUT and the pieces are stacked in an order appropriate for subse- 
quent splicing, and the resulting stack of between two and four pieces 
is returned. The operation of CUT-AND.STACK is shown in in figure 2. 
(ops. lisp) 

(DET .SELECTION) This function performs binary tournament selection without replace- 
ment. For init_select-gen generations, the function INIT-SELECTION 
is called. Then, if the value of the flag thres is t, the thresholding selec- 
tion function THRESH-SELECTIQN is called. Otherwise, NORM-SELECTION 
performs simple binary tournament selection, (ops. lisp) 

(EXTRACT chrom) The raw chromosome chrom is passed to the function EXTRACT. The chro- 
mosome is scanned from left to right, constructing a processed string us- 
ing the first gene value encountered during the scan. In a five-bit exam- 
ple, if the chromosome ((10) (2 1) (5 0)) were passed to EXTRACT, 
the returned result would be (0 1 nil nil 0). (decode . lisp) 

(FACTORIAL n) The function (FACTORIAL) implements a factorial operator as n!. (aux . lisp) 


8 


variable STACK 


Arguments to CUT_AND_STACK 


strings 

cut point 

i 

matel ((1 0X1 2X0 3X1 2) ! (1 5)(1 4)) 


mate2 ((1 1X0 3) \ (0 4X0 2X1 3X1 5X1 6)) 
| 

0<=cut_prob<= 1 .0 


top of stack 

((1 0X1 2X0 3)0 2)) 
((0 4X0 2X1 3X1 5X06)) 
(d 1X0 3)) 

(d 5X1 4)) 


returned value is a list of these pieces 


Figure 2: CUTJIND_STACK detail 


(FILL_NIL_P0SITI0NS listl) The function FILLJHL_P0SITI0NS takes a processed string 

listl and fills in any unspecified positions with the corresponding values 
in the standard fill array stdjfill. For example, the processed string 
(0 1 nil nil 0) passed toFILL_NIL_P0SITI0NS with std_fill=#(0 0 
0 0 0) would return the filled-in string (0 1 0 0 0). (decode. lisp) 

(FLIP probability) The function FLIP randomly returns t with the specified probability; 

otherwise, it returns nil. (aux.lisp) 

(GET.CHR0M0S0ME pop loc) The index number and population are passed to GET .CHROMOSOME 

and the chromosome of the loeth population member from the popula- 
tion pop is returned, (aux.lisp) 

(GET .FITNESS pop loc) The index number and population are passed to GET .FITNESS and 

the population member’s fitness value is returned, (aux.lisp) 

(GET_SUBFUNCTI0N_LIST pop loc) The index number and population are passed to 

GET_SUBFUNCTI0N_LIST, and the member’s subfunction list is returned, 
(aux.lisp) 

The function INITJSELECTION selects and compares the fitness values 
of population members in their original order. This is useful in the 
early stages of a run to maintain tournaments among competing building 
blocks without additional thresholding, (ops. lisp) 

The setup parameters read from the setup file are displayed through a 
call to INITIAL .OUTPUT, (stats, lisp) 

The processing of the juxtapositional phase is coordinated by a call to 
JUXTAP0SITI0NAL. (mga.lisp) 

(MAKE_NEW_P0P num_positions max_length Jtoptional copies) A new population consist- 
ing of all possible building blocks of length num_positions with values 
ranging to max_length are created by the function MAKE_NEW_POP. All 


(INIT3ELECTI0N) 

(INITIAL JOUTPUT) 
(JUXTAPOSITIONAL) 


9 



2* building blocks are generated, running through the population so 
that competing building blocks are adjacent- (setup. lisp) 

(mGA) The mGA function coordinates the overall processing of the messy genetic 
algorithm. It is responsible for controlling the primordial and juxtapo- 
sitional genetic phases as well as cutting the populations size. On start 
up, it calls the setup file load routine and executes calls to initialize the 
population, (mga.lisp) 

(MUTATE gene probability) The gene value gene is changed from a zero to a one or vice 

versa with the specified probability, (ops. lisp) 

(MUTATION chrom) A raw chromosome is passed to MUTATION. Each bit is mutated or not 
via successive calls to MUTATE, returning the mutated chrom. (ops .lisp) 

(N-ARY -COUNT n_aryj.ist maximum position) The function N-ARY -COUNT increments the 

position of n.aryJList by one. The position specifier starts with 
zero indicating the farthest right input list position and the length of 
the list minus one for the farthest left input list position. The func- 
tion implements carry-over when a lower position is filled. In the mGA 
program N.ARY -COUNT is used to implement a binary counter. An exam- 
ple of a three bit binary counter implementation is as follows: Initialize 
the counting list to (0 0 0). Call the the function with the following 
arguments (N-ARY_COUNT ’(0 0 0) 2 0). This specifies that position 
zero (the least significant bit) of the list will be incremented in a bi- 
nary 2 mode. The result of the call would be (0 0 1). Now if the 
process is repeated using the result of the last call as the input list, 
the resulting returned sequence of lists would be: (0 10), (0 11), 

(10 0), (10 1),..., (111). When aD the values are at their 
maximum the list should be reset to (0 0 0) before another call is ini- 
tiated. (aux.lisp) 

(NORM-SELECTION) This function compares the next two individuals indexed in the permu- 
tation shuffle, returns the index number of the better individual, and 
increments the pick index by two. (ops. lisp) 

(0BJFUNC ^optional calc-val-f lag) Objective function values are assigned to the new pop- 
ulation newpop by the function OB JFUNC through successive calls to EXTRACT , 
FILL-NIL-POSITIONS , SUBFUNCTION-DECODE, and SET-SUBFUNCT.VALUE. 
When calc_val-flag is t, table look up is performed. When calc_val_f lag 
is nil, the evaluation is bypassed. This feature is used during the pri- 
mordial phase to prevent unnecessary reevaluation of function values, 
(objfunc.lisp) 

(PRIMORDIAL) The primordial phase of the mGA is coordinated by the function PRIMORDIAL. 

Only selection is performed during this phase; cut, splice, and other op- 
erators are postponed to the juxtapositional phase. With deterministic 
fitness functions, no reevaluation of a string’s fitness is necessary during 
this phase. The primary purpose of this phase is to dope the population 
with the best building blocks, enabling their useful recombination during 
the juxtapositional phase, (mga.lisp) 


10 


(RESET _POP respop) This function creates a nil initialized population of size popsize in the 

population respop. (aux.lisp) 

(RESET_STAT_INFO) The function ( RESET -STATJNFO) resets various statistical counters and 
variables. It is executed prior to the evaluation of objective function 
values across the population in OBJFUNC. (stats. lisp) 

(RND lo hi) A uniformly distributed random integer between low and high limits of 
lo and hi is calculated by the function RND. (aux.lisp) 

(SET_ASC_LIST list start) The function SET_ASC_LIST sets the first element of list to 

the integer start. The following list positions are set to start+1, 
start+2,.., start + list-length -1. (aux.lisp) 

(SET_LIST list value) This function initializes the elements of list to value, (aux.lisp) 

(SET J3UBFUNC .VALUE sub JLnfo .list) This function takes the list of subfunction table num- 
bers, scale factors, and bit lists generated by SUBFUNCTIONJ)ECODE and 
returns the subfunction fitness values as a list. The fitness values are set 
by finding a match in the corresponding look-up table, (objfunc.lisp) 

(SETUP _GA) This function is responsible for picking out the various fields in the setup 
file and issuing calls to the other setup functions, (setup. lisp) 

(SETUP .METER) This function sets up a meter that is 20 characters wide. It is used in 
the objective function to show how much of the population has been 
processed, (aux.lisp) 

(SETUP JDBJ) This function uses the setup file to set up the look-up tables by issuing 
calls to SETUP .TABLES. It also sets up the bit .spec subfunction specifier, 
(setup. lisp) 

(SETUP .POP) This function accesses the setup file to set up all the population and 
global parameters, (setup. lisp) 

(SETUP _SUBFUNC_MAX) This function sets up a list of maximum possible values for the sub- 
functions by accessing the lookup tables and applying the appropriate 
scale factor. It is used to count optimal building blocks in the function 
UPDATE.STATS. (stats. lisp) 

(SETUP .TABLE) This function is responsible for setting up a single look-up table specified 
in the setup file, (setup. lisp) 

(SETUP .TEMPLATE) This function uses the setup file to set the default fill-in values of the 
std_fill array, (setup. lisp) 

(SHUFFLE.P0P shuffle) This function creates a shuffled array shuffle of the population 

member numbers, (aux.lisp) 

(SPLICE chroml chrom2) Two chromosomes chroml and chrom2 are spliced together by 

SPLICE, returning a single chromosome, (ops. lisp) 


11 


(SPLICE.TESTER splico.prob) The stack generated by the function CUTJtND .STACK is used 

by SPLICE.TESTER to coordinate splicing. Pieces are successively popped 
off the stack, and tests are performed for possible splicing of each piece 
to the next. A successful splice results in the placement of the result in 
a list of offspring that are subsequently placed in the new population, 
(ops . lisp) 

(STATISTICS) This function writes various statistics values to the screen and to a file, 
(stats .lisp) 

(SUBFUNCTI 0 N .DECODE bit .list) This function takes the processed string bit .list and gen- 
erates a list of look-up table numbers, scale factors, and bit values 
for each subfunction. This list of lists is passed on to the function 
SETJ3UBFUNC .VALUE, which performs the required table accesses, 
(objfunc.lisp) 

(THRESH.SELECTION) Tournament selection with thresholding (genic selective crowding) is 

performed by the function THRESH.SELECTION. This function selects the 
first participant as the next individual mentioned in the shuffle fist as 
indicated by the pick index. A threshold value is calculated to determine 
how many genes two individuals must have in common to be compared, 
and the next shufnum individuals in the shuffle list are checked for the 
requisite gene commonality. The first individual with sufficient common- 
ality is compared to the individual chosen earlier, and the index number 
of the fitter is returned. If no individual with the required commonality is 
found, the index number of the first participant is returned, (ops .lisp) 

(UPDATE .STATS pop .member) The function UPDATE.STATS updates statistics for population 

subfunction fitness maxima and averages, (stats. lisp) 


4 Example Input and Output 

T his section provides an example run with setup file and output from the program. The example 
is included to exercise many features of mGAl.O, thereby permitting the user to easily create 
his own files. 

4.1 The problem 

The example problem is to find the optimum solution for a function composed of eight sub- 
functions. The subfunctions are all deceptve and are decoded from two different look-up tables. 
The first subfunction (subfunction 0) was designed using guidelines outlined in (Liepens & Vose, 
1989). The second subfunction (subfunction 1) was designed by Goldberg (1989b). Three of 
the subfunctions use subfunction 0 and the other five use subfunction 1 (see figure 3). 

4.2 Setup file 

The setup file is used to set the population variables, look-up tables, and decoding parameters. 
The user is prompted for this file name when the mGA program is started. The file is composed 
of two primary fields, the POPULATION and OBJ fields. The setup file requires that the OBJ field 


12 




13 







follow the POPULATION field, because some of the subfunction variables are set in the POPULATION 
setup section. The setup file for the this example is as follows: 

POPULATION; ; example 1 - two deceptive lookup table problem 

maxgen 30 
cookgen 14 
cutpopgen 12 
init.select.gen 3 
num. sub functions 8 
chrom.length 24 
bldg.blk.size 3 
seed 3 

cut.prob .0208333 
splice.prob 1 
mut.prob 0 
thres 1 
shufnum 24 
garbage. collect 2 
*** 

OBJ 

subfunction.bits 012 ltable 0 scale 1 

subfunction.bits 345 ltable 1 scale 1 

subf unction.bits 678 ltable 1 scale 1 

subf unction.bits 9 10 11 ltable 0 scale 1 

subfunction.bits 12 13 14 ltable 0 scale 1 

subfunction.bits 15 16 17 ltable 1 scale 1 

subfunction_bits 18 19 20 ltable 1 scale 1 

subf unction. bits 21 22 23 ltable 1 scale 1 

table 0 

bvalue 000 dvalue 2 
bvalue 001 dvalue 0 
bvalue 010 dvalue 5 
bvalue 011 dvalue 2 
bvalue 100 dvalue 0 
bvalue 101 dvalue 6 
bvalue 110 dvalue 2 
bvalue 111 dvalue 0 
end.table 

table 1 

bvalue 000 dvalue 28 
bvalue 001 dvalue 26 
bvalue 010 dvalue 22 
bvalue Oil dvalue 0 


14 


bvalue 100 dvalue 14 
bvalua 101 dvalue 0 
bvalue 110 dvalue 0 
bvalue 111 dvalue 30 
end_table 

012345678 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 

template 0100000000 100 1000000000 0 

*** 
end 

There are a few conventions that should be noted in this file. A comment (anything that 
follows a semicolon) is ignored. Anything that does not follow a valid label is ignored, so 
comments, such as the bit location marker placed above template can be used rather freely. 
The field name is not case sensitive, but the spelling of each field is important. The end of the 
file is specified by the marker end. The POPULATION field is used to set up the population and 
phase parameters. The parameters settings in this example are as follows: 

maxgen 30 The mGA program will execute 30 generations total (see figure 4). 

cookgen 14 The primordial phase will be executed for 14 generations, after this gen- 
eration (generation 15 and on), juxtapositional processing will be used 
(see figure 4). 

cutpopgen 12 Starting from generation 1 and up to generation 12, the population will 
be cut in half every other generation (see figure 4). 

init_select^gen 3 Starting from generation zero and up to and including generation three, 
the function INIT.SELECTION will be used for selection, (default = 1) 

num_subfunctions 8 There are eight subfunctions in the problem. 

chromJ.ength 24 Since there are eight subfunction each of length three, the decoded chro- 
mosome length is 24. 

bldg_blk_size 3 When the initial population is created, the function MAKE_NEWJ>0P will 
create building blocks of size three. 

seed 3 The random number generator is seeded with the value 3, 

cut_prob .0208333 The cut probability is set to one divided by twice the problem length, 
(default = 0) 

splice.prob 1 The splice probabilty is set to 1 so that all splices will be successful. 
(default= 1) 

mut.prob 0 Mutation is turned off in this example, (default = 0) 

thres t Since the subfunctions lookup tables use two different scales (one is five 
times the other), thresholding selection is used to preserve the weaker 
building blocks. 


15 



16 






shufnum 24 The shuffle number used by thresholding mechanism is set to the chro- 
mosome length (Golberg, Deb, & Korb, 1990). 

garbage-collect 2 Garbage collection will be done every other generation, (default = l) 

Some setup parameter of interest that are not used in this example are: 

pspe If the value following this field is set to t, the partial-string-partial - 
evaluation mode will be activated. When in this mode, the objective 
function will only give values other than zero to fully specified strings. 
Otherwise, the std_f ill array is used to fill the unspecified bit positions 
os that unsderspecified chromsomes can be decoded, (default = nil) 

member-copies The number following this label will set the number of copies of each 
population member to be created by the function MAKE JfEW_P0P, (default 
= 1 ) 

The OBJ field is composed of three subfields: subfunction setup, look-up table setup, and 
the template field. The field is ended with the *** pattern. The first subfield, subfunction 
setup, is specified by the following labels: 

subf unction-bits This label should be followed by the position numbers that should be 
accessed in decoding the subfunction. For example if the bits (3 4 5) 
are specified, the subfunction decode section of the program accesses the 
bits in third, fourth, and fifth position to be used to find a match in the 
look-up table. 

ltable This label is followed by the lookup table that should be used in decoding 
the subfunction. 

scale This label is followed by a scale factor that is multiplied by the table 
value. This parameter can be used to either strengthen or weaken the 
subfunction. 

The second subfield, used to setup the look-up table, is specified by the following labels: 

table This label specifies the look-up table number that identifies the look-up 
table. This number can be any value, as long as it matches one specified 
in the subfunction definition. It is suggested that the table numbering 
start from zero and proceed sequentially for clarity. 

bvalue This label specifies the bit pattern that is to be matched during table 
look up. 

dvalue This label specifies the value that will be assign to the subfunction when 
the preceeding bit pattern is matched. 

end-table This label is used to mark the end of a look-up table. 

These tables have been set up to implement table lookup for the two subfunctions shown in 
figure 3. 

The final subfield is the template field. This label is followed by the default fill-in values 
for unspecified bit positions. This problem intentionally sets the default fill-in valus to the 


17 


complement of the optimal subfunction. Observe subfunction 0 (see figure 3) which uses bits 
(0 1 2) and has optimal value with bits set to ( 1 0 1) . It has a default fill in for those positions 
of (0 1 0), which is the complement of the optimum. The other default fill-in postions are set 
in the same manner. The reason for doing this is so the mGA has to do all the work in finding 
the optimum values and is not given the help of having optimum values filled in by default. 

4.3 Off to the program 

The program is started by typing (mGA) <cr>. It will then prompt the user for the filename; 
this example uses examplel . asc. The program will then display the setup parameters read 
from the file, and create the initial population. Once the initial population is created the 
program starts execution. The objective function will first be executed and the program will 
print the following: 

OBJFUNC/STATISTICS (set fitnesses & update stats) 
percent population processed 
07. 1007. 

********** 

The meter shows how much of the population has been processed. The objective function 
is first run so that the initial population fitnesses and statistics can be calculated. After this 
phase the initial statistics will be output as follows: 

Generation# 0 
Popsize = 16192 
Minfitness = 113 
Maxfitness = 157 
Average fitness = 145.93954 
Maximum number of optimal subfunctions * 1 
Total number of optimal subfunctions = 8 
Average number of optimal subfunctions = 4.9407115e-4 
Total and Average Number of optimal subfunctions in position 1=1 and 

Total and Average Number of optimal subfunctions in position 2=1 and 

Total and Average Number of optimal subfunctions in position 3=1 and 

Total and Average Number of optimal subfunctions in position 4=1 and 

Total and Average Number of optimal subfunctions in position 5=1 and 

Total and Average Number of optimal subfunctions in position 6=1 and 

Total and Average Number of optimal subfunctions in position 7=1 and 

Total and Average Number of optimal subfunctions in position 8=1 and 

Best solution so far =(0 101 1 1000010010000000000) 

The statistics are written each generation both to the screen and to a file (statoutrd.dat). 
Initially there is only one optimal building block in each subfunction position and ten optimal 
building blocks in the entire population. Once the initial statistics are printed out the program 
executes the primordial phase and objective function as follows: 

PRIMORDIAL 

percent populatioi processed 


6 . 1758895e-5 
6 . 1758895e-5 
6.1758895e-5 
6 . 1758895e-5 
6 . 1758895e-5 
6.17588959-5 
6.1758895e-5 
6.17588956-5 


18 


1007. 


07. 

******************** 

OBJFUNC/STATISTICS (update stats only) 
percent population processed 

07, 1007 

^****************** 


Generation# 1 

Popsize - 16192 

Minfitness = 127 

Maxfitness - 157 

Average fitness ® 149.33684 

Maximum number of optimal subfunctions = 1 

Total number of optimal subfunctions = 16 

Average number of optimal subfunctions = 9.881423e-4 

Total and Average Number of optimal subfunctions in position 

Total and Average Number of optimal subfunctions in position 

Total and Average Number of optimal subfunctions in position 

Total and Average Number of optimal subfunctions in position 

Total and Average Number of optimal subfunctions in position 

Total and Average Number of optimal subfunctions in position 

Total and Average Number of optimal subfunctions in position 


Total and Average Number of optimal subfunctions in position 8 


2 and 1.2351779e-4 
2 and 1.2351779e-4 
2 and 1.2351779e-4 
2 and 1.2351779e-4 
2 and 1.2351779e-4 
2 and 1.2351779e-4 
2 and 1.2351779e-4 
2 and 1.2351779e-4 


Best solution so far =(010111000010010000000000) 
Fitness = 157 


The primordial phase creates copies of individuals with highest fitness. Since the structures 
with optimal building blocks have highest fitness they will be allocated an increasing number 
of copies at each generation, and hence the population will be doped with good building blocks 
by the juxtapositional phase . The program will continue in this manner until generation 15 
(the generation after cookgan). Here the program begins the juxtapositional phase by using 
the cut and splice operators. The maximum number of subfunctions in a single individual 
immediately jumps to two and the maximum fitness increases. The number of optimal building 
then increases in each subsequent generation until an optimal solution is found in generation 18 
(see Figure 5). From this point on the mGA creates more and more optimal solutions until at 
generation 30 almost every population member has optimal building blocks in all 8 positions. 
The final statistical output is as follows: 

Generation# 30 

Popsize » 253 

Minfitness 3 100 

Maxfitness * 168 

Average fitness * 166.09882 

Maximum number of optimal subfunctions 3 8 

Total number of optimal subfunctions = 1979 


19 


Average number of 
Total and Average 
Total and Average 
Total and Average 
Total and Average 
Total and Average 
Total and Average 
Total and Average 
Total and Average 


optimal subfunctions - 7.8221345 
Number of optimal subfunctions in position 1 
Number of optimal subfunctions in position 2 
Number of optimal subfunctions in position 3 
Number of optimal subfunctions in position 4 
Number of optimal subfunctions in position 5 
Number of optimal subfunctions in position 6 
Number of optimal subfunctions in position 7 
Number of optimal subfunctions in position 8 


244 and 

248 and 

245 and 

249 and 

246 and 

249 and 
248 and 

250 and 


.9644269 

.9802371 

.96837944 

.98418975 

.972332 

.98418975 

.9802371 

.9881423 


Best solution so far =(1 0111 i 111101101111111111) 

Fitness = 168 

This case is typical for the mGA. The number of function evaluations can be calculated as 
follows: 


n o + nj -tj, 

where no is the initial population, nj is the juxtapositional population size, and tj is the number 
of generations in the juxtapositional phase to optimality. In the example run, the program 
required 

16192 + 253*4 = 17,204 function evaluations. 

The mGA program writes a data file (DATA.DAT) which contains raw numerical data useful 
for plotting. The plot of this example shows the convergence of the mGA in figure 5. The 
file has a header for data reference at the top of the file and statistical data written for each 
generation. As an example, the file for this problem starts as follows: 

Generation Popsize Maximum.Fitness Average.Fitness 

0 16192 157 145.93954 

1 16192 157 149.33684 

2 16192 157 152.36339 

3 8096 157 154.07239 

4 8096 157 154.8398 

5 4048 157 155.01631 

6 4048 157 155.05188 

7 2024 157 155.10178 

8 2024 157 155.20207 

9 1012 157 155.37846 

10 1012 157 155.72035 


5 Conclusions 

This report has presented brief documentation for the data structures and functions of a Com- 
mon LISP implementation of a messy genetic algorithm. This implementation, mGAl.O, is 
available as a research code for investigation of messy genetic algorithm theory and application. 


20 



FITNESS 



0 5 10 




Figure 5: Optimal results are 


2 



In its present state, the code includes the phased (primordial/justapositional) processing of 
a messy G A, messy binary strings, messy cut and splice operators, and genic selective crowding. 
The code does not currently include null bits or tie breaking, although these features will be 
implemented soon. 

Although mGA efforts are just beginning, because of their rapid convergence to global 
optima in difficult combinatorial problems, these techniques are ready for additional scrutiny 
and testing. Making this research code available is a first step in this direction. 


Acknowledgments 

This material is based upon work supported by NASA Cooperative Agreement NCC9-16, RICIS 
Research Activity No. AI.12, Subcontract No. 045 and by the National Science Foundation 
under Grant CTS-8451610. The authors also acknowledge equipment support provided by 
Texas Instruments Incorporated and the Digital Equipment Corporation. 


References 

Goldberg, D. E. (1989a). Genetic algorithms in search , optimization, and machine learning. 
Reading, MA: Addison- Wesley. 

Goldberg, D. E. (1989b). Genetic algorithms and Walsh functions: Part I, a gentle introduc- 
tion. Complex Systems , 5, 129-152. 

Goldberg, D. E. (1989c). Genetic algorithms and Walsh functions: Part II, deception and its 
analysis. Complex Systems, 5, 153-171. 

Goldberg, D. E., k Bridges, C. L. (1990). An analysis of a reordering operator on a GA-hard 
problem. Biological Cybernetics , 62( 5), 397-405. 

Goldberg, D. E., Deb, K., k Korb, B. (1990). An investigation of messy genetic algorithms 
(TCGA Report No. 90005). Tuscaloosa: University of Alabama, The Clearinghouse for 
Genetic Algorithms. 

Goldberg, D. E., Korb, B., k Deb, K. (1989). Messy genetic algorithms: Motivation, analysis, 
and first results. Complex Systems, 3. 

Leipens, G.E.,& Vose, M.D.(1989). Representational issues in genetic optimization. Manuscript 
submitted for publication. 



A Appendix 

A.l File: aux.lisp 

The file aux.lisp contains utility and auxiliary code for mGAl.O. 


=This file contains the auxilliary operators that accomplish some of the- 
=low level and irregular functions = 


; accesses the structure of a population member and returns the chromosome 
(defun GET.CHROMOSOME (pop loc) 

(population_member-chrom (aref pop loc))) 

; accesses the structure of a population member and returns the fitness 
(defun GET.FITNESS (pop loc) 

(population_member-f itness (aref pop loc))) 

;===================GET_SUBFUNCTION_LIST s ==== == = =====ss===:s== ® =========s== 

; accesses the structure of a population member and returns the subfunction 
(defun GET_SUBFUNCTION_LIST (pop loc) ; value list 
(population_member-subf .list (aref pop loc))) 

(defun RND (lo hi) ; generates a random number from lo to hi 
(+ lo (random (+ (- hi lo) 1)))) 

;====*=======s============**===C0MBINATI0N=============«=======®==== = ==== 

; creates a combination list of max.number items taken num.places fi a time 
(defun COMBINATION (max.number num.places comb.list Aaux exit) 

(setf max.number (1- max.number)) ; adjust for list index 0 to n-1 

(setf num.places (1- num_places)) ; instead of 1 to n 

(if (< (nth num.places comb.list) max.number) 

; if low val (farthest right) is less than 
; max.number then inrement by one 

(setf (nth num.places comb.list) (1+ (nth num_places comb.list))) 
(progn ; otherwise 

(do ((j num.places (1- j))) ; check the rest of the positions 

((or (< j 1) exit)) 

(if (< (nth (1- j) comb.list) 

(+ max.number (* -1 num.places) j -1)) 

;look for one that cam be inremented 
(progn 

(setf (nth (1- j) comb.list) (1+ (nth (1- j) comb.list))) 

; increment the next highest value that 


23 


;can be incremented 
(do ((s j (1+ s))) 

((> s num.places)) 

;and set all following vals one 
jhigher than the value to its left 
(setf (nth s comb_list) 

(+ (nth (1- j) comb.list) s (- 1 j))) 
(setf exit ’t))) ;then exit 
))))) 


; resets all population parameters to nil by recreating the structure 
(defun RESET.POP (respop) 

(do (Ci 0 (1+ i))) 

((>= i popsize)) 

(setf (aref respop i) (make-population_member)))) 

; simulates the flip of a weighted coin 
(defun FLIP (probability ftaux tbase) 

(setq tbase 1000000) 

(>= (* probability tbase) (random tbase))) 

;=M============= s ====COMPLEMENT_BIT =s == a =*=*= a =”==== ===!SS!S=B== " ========= 

(defun C0MPLEMENT_BIT (bit 4aux bit_ret) ; changes a 1 to 0 or a 0 to 1 
(setq bit.ret 1) 

(cond 

((= bit 1) 

(setq bit.ret 0))) 
bit_ret) 


jxsaaxaaaxxxxxaaaMasaaaaSHUFFLE.POP®®"*® 333 ®®®" 33 ”®**”® 3 ""””* 3 ® 3 * 
; creates a shuffled array of size popsize 
(defun SHUFFLE_POP (shuffle ftaux count num other) 

(do ((i 0 (1+ i))) 

((>* i popsize)) 

(setf (aref shuffle i) i)) 

(setf count (1- popsize)) 

(do ((j 0 (1+ j))) 

((>= j count)) ;swap entire population around 
(setf num (RND j count)) ; determine random swap position 
(setf other (aref shuffle num)) 

(setf (aref shuffle num) (aref shuffle j)) ;swap one to the other 
(setf (aref shuffle j) other)) 

;and the other back to the original place 
shuffle) 


24 


;sets up meter to show how much of the pop has been processed by OBJFUBC 
(defun SETUP.METER () 

(format t "percent population processed"'/,") 

(format t "O'/, 100'/, ”7," )) 


; counts a list in n-ary mode where n is maximum value of count 
(defun N_ARY_C0UNT (n_ary_list maximum position ftaux len) 

(if (and (>= (nth (1- position) n_ary_list) maximum) 

; if the position above is maxed out 
(>= (nth position n.ary.list) maximum)) 

;and the current positon is maxed out 

(N.ARY.COUNT n_ary_list maximum (1- position)) 

;then check next positon up with this subroutine 
(progn 

(if (>= (nth position n_ary_list) maximum) 

; otherwise if just positon is maxed out but there 
;is room above it for incrementation 
(progn 

(setf len (list-length n.ary.list)) 

(do ((i position (1+ i))) 

((>= i len)) 

;set everything below the position to zero 
(setf (nth i n.ary.list) 0)) 

;incremenmt the next higher positon 

(setf (nth (1- position) n.ary.list) 

(1+ (nth (1- position) n.ary.list)))) 

(setf (nth position n.ary.list) (1+ (nth position n.ary.list)))) 
; if neither of these conditions are met, 

;just increment the current position 
)) * 

n.ary.list) ; return the incremented n.ary list 

(defun CHOOSE (nl n2) ; statistical operator nl choose n2 

(/ (factorial nl) (* (factorial n2) (factorial (- nl n2))))) 


;==================== 3 ==========FACTORIAL========"® ==3333333333333333333= 

(defun FACTORIAL (n ftaux ret.val) ; standard stat factorial operator 
(setf ret.val 1) 

(do ((i 1 (1+ i))) 

((> i n)) 

(setf ret.val (* i ret.val))) 
ret.val) 


j=====3=3*K====MaK3==s»»SET_ASC_LIST== 3 === 33 = 333a=!B333333333333333333333 
;sets up an ascending list starting at start and ending with start+length 


25 


(defun SET_ASC_LIST (list start) 
(do ((i start (1+ i))) 

((>= i (list-length list))) 
(setf (nth i list) i))) 


;===============®==============SET_LIST===~ 

;sets all the elements of a list to a value 
(defun SET.LIST (list value) 

(do ((i 0 (1+ i))) 

((>= i (list-length list))) 

(setf (nth i list) value))) 


26 


A. 2 File: decode. lisp 

The file decode. lisp contains the code necessary to compute a processed string from a raw 
string. 


=============«==========FILE-DECODE.LISP============«=====™==®======= 

=This file contains functions responsible for decoding a raw chromosome * 
=thereby generating a processed chromosome = 


; EXTRACT takes a position/value list mGA coding and puts the bits in their 
; proper positions example — (EXTRACT ((2 0)(1 1)(3 1)....)) 

; would return (nil 1 0 1...) 

(defun EXTRACT (chrom ftaux ret.list pos val pos.val no.duplicate length) 
(setf ret_list (make-list bits_per_chrom)) 

;setup list to copy bits into 

(setf no.duplicate (remove-duplicates chrom :key ’car :from-end ’t)) 

jremove overspecified positions 

(setf length (list-length no.duplicate)) 

;get # of positions to be set 
(do ( (i 0 (1+ i))) 

((>= i length)) 

(setf pos.val (nth i no.duplicate)) 

(setf pos (nth 0 pos.val)) ;get position 
(setf val (nth 1 pos.val)) ;get value 
(setf (nth pos ret.list) val)) 

;set ret.list pos(ition) to val(ue) 
ret.list) 


; ===================FILL_NIL_POSITIONS======™========””============= 5S = 

;fills unspecified positions with std.fill array vals 
(defun FILL.NIL.POSITIONS (listl) 

(do ((pos 0 (1+ pos))) 

((>= pos (list-length listl))) 

(if (equal (nth pos listl) nil) 

;look for positions w/ nil value 

(setf (nth pos listl) (nth pos std.fill)))) 
fill them w/ std.fill array 
listl) 


27 


A. 3 File: mga.lisp 

The file mga.lisp contains data declarations, the main program, and major coordination func- 
tions. 

;=This file contains the global variable declarations, the mGA function, * 
;=and important phase coordination functions 31 

(defstruct population. member chrom fitness subf.list) 

; structure used for each member of a population 


(defstruct bit. cluster table. specif ier scale.factor bit.specif ier) 


; structure used for bit 
(defvar avg.fitness) 

(defvar bit. spec) 

(defvar bits.per.chrom) 
(defvar bldg.blk.size) 

(defvar cookgen) 

(defvar cut.prob) 

(defvar cutpopgen) 

(defvar data) 

(defvar first. time) 

(defvar garbage. collect) 

(defvar indata) 

(defvar init. select. gen) 
(defvar instream) 

(defvar lookup. table) 

(defvar loopvar) 

(defvar max.numgood) 

(defvar maxfitness) 

(defvar maxgen) 

(defvar member. copies) 

(defvar minfitness) 

(defvar mut.prob) 


specifier decoder 

; statistical variable which specifies the 
; population average fitness 
; specifies for each subfunction bits, scale 
; factor and lookup table 

; specifies the length of decoded chromosome 
set in setup file is used to generate initial 
; population 

;the # of generations in the primordial phase 
;prob that a chrom will be cut into two pieces 
;by CUT 

; the # of generations up to that the pop will 
;be cut in half 

; stream to output data for plotting or analysis 
;flag used by SETUP.GA to mark first time 
; through setup routine 

;set number of generation between garbage 
; collections 

;temp variable used to read from file 
; (see SETUP.GA) 

;# of generations to use INIT. SELECTION 
; a stream used to read from the setup file 
; specifies the bit strings and their 
; coresponding decoded values 
;is the generation counter 
; statistical variable which keeps track of 
;max # of optimum building blocks 
; statistical variable which holds the maximum 
; decoded chrom fitness 

;the total # of generations that will be executed 
;# of building block copies to be made in initial 
population 

statistical variable which holds the maximum 
; decoded chrom fitness 

probability that s single bit will be mutated 
;by MUTATION 


28 



(defvar newpop) 

(defvar num_ subfunctions) 
(defvar num.tables) 
(defvar numgood) 

(defvar oldpop) 

(defvar pick) 

(defvar popsize) 

(defvar pspe) 

(defvar screen&file) 
(defvar seed) 

(defvar setup. file) 

(defvar shuffle) 

(defvar shufnuin) 

(defvar splice. prob) 

(defvar stack) 

(defvar stat) 

(defvar std.fill) 

(defvar subf .pos.max) 
(defvar sumfitness) 

(defvar thres) 

(defvar vertnum.spot) 


array of structure population.member 
specifies the # of subfunctions 
specifies the # of lookup tables 

stat variable which keeps track of the total # of 

(111) building blocks 

array of structure population.member 

postion marker for selection routines 

THRESH. SELECT, NORM.SELECTION ft DET.SELECT 

the size of the population 

flag for partial string partial evaluation 

output stream for both screen and file 

random # generator seed 

name of the file that the setup parameters 
are read from 

shuffle array used in selection routines 

max # of pop members that will be looked at in 

THRESH.SELECT 

prob that two chroms will be spliced together 
by SPLICE 

global, stack for subsequent calls to stack 
output statistical file path vairable 
array used for filling in unspecified positions 
during chrom decode 

list used to count optimal building blocks 
stat variable which holds the sum of all the 
fitnesses in the pop 

is a flag when set true the program will use 
THRESH.SELECT for selection 
stat counter that countes the # of optimal 
building blocks for each subfunction position 


;this is the main control structure of the program that is in charge 
;of overall program flow 
(defun mGA ( ftaux max. gene) 

(format t "MGA-/.") 

(setq w: more-processing-global-enable nil) 

; keeps **M0RE from waiting for key hit 

(setq stat (open "statoutrd.dat" :direction routput)) 

;open data file for stats 

(setq screen&file (make-broadcast-stream * standard- output* stat)) 

;sets up output screen ft file streams 
(setq data (open "data.dat" rdirection : output) ); sets up data file 
(setf loopvar 0) 

(SETUP. GA) ; program which loads setup file 

(INITIAL. OUTPUT) ; output initial information 

(setf subf .pos.max (SETUP.SUBFUNC.MAX) ) ;setf up subfunction maxim 
;for statistics optimium bldg block counting 


29 


(setq *random-state* (system: random-create-array 71. 35. seed)) 

;seed random # generator 

(setf max_gene (1- bits_per_chrora) ) ;set array max number 
(MAKE_NEW_POP bldg_blk_size bits_per_chrom aember_copies) 

; generate every useful building block 
;of size building_blk_size 

(OBJFUNC t) ; calculate initial objective function vals 

(STATISTICS) ; print out statistics 

(do ((gen.count 1 (1+ gen.count))) ; generation loop 
((> gen.count maxgen)) 

(setf pick 0) ; reset shuffle array pointer 

(setf loopvar gen.count) ;sets global loopvar to local gen.count 
(if (= (rem gen_count garbage.collect) 0) 

(progn 

(format t "collecting garbage"'/,") ; collect garbage 
(gc-immediately : silent t) 

(format t "finished collecting garbage"/,"))) 

(if (<= gen_count cookgen) 

; check for primordial phase or juxtapos phase 


(progn 

(setf shuffle (make-array popsize)) ;create shuffle array 

(SHUFFLE.POP shuffle) ; initialize shuffle array 

(PRIMORDIAL) ; execute primordial phase 

(STATISTICS) ;print out statistics 

(if (and (<= gen_count cutpopgen) (evenp gen_ count)) 

; start cutting population in half from 2nd 
; generation up to and including cutpopgen 

(setf popsize (round (/ (float popsize) 2))))) 

; cut population in half 

(progn 

(SHUFFLE_POP shuffle) ; initialize shuffle array 
(JUXTAPOSITIONAL) ; execute juxtapositional phase 
(STATISTICS)))) ; print out statistics 
(close data) 

(close stat)) ; close the statistical and data files 


;=============*============PRIMORDIAL===== SB = Baxx ====== s= == ==B===B=== ” = 

;uses deterministic selection to reproduce a new pop (no cut or splice) 
(defun PRIMORDIAL (ftaux position step) 

(format t " PRIMORDIAL"'/,") ;print out wht phase the program is in 
(setf oldpop (copy newpop)) ;copy over all pop info to oldpop 
(setf newpop (make-array popsize)) 

(SETUP.METER) 

(setf step (round (/ (float popsize) 20))) 

; setup disp meter steps ize-meter is 20 chars wide 
(do ((i 0 (1+ i))) 

((>= i popsize)) 

(if (= (rem i step) 0) ; if even multiple of step, then 


30 


(princ "*")) ; print a mark for l/20th of population processed 

(setq position (DET.SELECTION)) ; select individual 
(setf (aref newpop i) (aref oldpop position))) 

;set newpop to the individual 

(OBJFUNC) ) ;call short objective function 

; =========================== JUXTAPOSITIONAL=============================== 

;uses deterministic selection and cut and splice to produce new population 
(defun JUXTAPOSITIONAL (&aux positionl position2 matel mate2 cross count 
num.of .children step) 

(format t "-/.-/.JUXTAPOSITIONAL'’/.") ;print out what phase the program is in 
(setf oldpop (copy newpop)) ;copy over all pop info to oldpop 
(SETUP.METER) 

(setf step (round (/ (float popsize) 20))) 

; setup disp meter stepsize-meter is 20 chars wide 
(RESET.POP newpop) ; reset shuffle array 
(setf count 0) ;reset counter 

(do () ;add # of children each time through the loop 
((>= count popsize)) 

(setf positionl (DET.SELECTION) ) ; select positionl 

(setf position2 (DET.SELECTION)) ; select position2 

(setq matel (GET.CHROMOSOME oldpop positionl)) 

;get chromosome of matel © positionl 

(setq mate2 (GET.CHROMOSOME oldpop position2)) 

;get chromosome of mate2 © position2 

(setf cross (CROSSOVER matel mate2 cut.prob splice.prob)) 

; perform crossover of the two 

(setf num.of .children (list-length cross)) 

;get # of children from resulting cross 
(do ((k 0 (1+ k))) 

((or (>= k num.of .children) (>= count popsize))) 

;copy over children to newpop 

(setf (population.member-chrom (aref newpop count)) 

(MUTATION (nth k cross))) 

(if (= (rem count step) 0) ; if even multiple of step, then 

(princ "*")) ;print a mark for l/20th of population processed 
(setf count (1+ count)))) 

(OBJFUNC t)) ;use long objectve function-lookup table for 
;new chromosomes formed 


31 


A. 4 File: objfunc.lisp 

The file objfunc.lisp contains the code to perform subfunction table look up. 

;=This file contains functions related to subfunction look-up, sacaling = 
;=and summation as well as setting the overall member fitnesses = 

t “ *“ "" "" “ — — — — — — — — — — — — — — — — —— 

; is responsible for accessing and decoding population members fitness via 
; decode operators and set the overall population member’s fitness 
(defun OBJFUNC (&optional calc. val. flag *aux chromosome step) 
(RESET.STAT.INFO) 

(format t "~V% OBJFUNC/STATISTICS ") ;let user know whether 
(if calc.val.flag 

(format t M (set fitness & update stats) ~X M ) 

;long lookup table is being used or 

(format t "(update stats only) *'/♦")) 

; short no lookup table is being used 

(SETUP. METER) ;sets up to display ammount of pop processed 

(setf step (round (/ (float popsize) 20))) 

; setup disp meter stepsize-meter is 20 chars wide 
(do ((i 0 (1+ i))) 

((>= i popsize)) 

(if (= (rem i step) 0) ; if even multiple of step, then 

(princ "*")) ; print a mark for l/20th of population processed 

(if calc. val. flag ;this flag is set if decode is to be used 
(progn 

(setf chromosome (GET.CHROMOSOME newpop i)) 

(setf chromosome (EXTRACT chromosome)) 

(if (not pspe) ;is pspe flag is not set then 

(setf chromosome (FILL.NIL.POSITIONS chromosome))) 

;fill in unspecified positions w/ std.fill array 
(setf chromosome (SUBFUNCTION. DECODE chromosome)) 

;get bits & decode info for subfunctions 
(setf chromosome (SET.SUBFUNC.VALUE chromosome)) 

; generate subfunction value list 

(setf (population.member-subf .list (aref newpop i)) chromosome)) 

;save subfunction list as part of chromosome 
(progn ;if value does not need to be calculated 
(setf chromosome (GET.SUBFUNCTION.LIST newpop i)) 

;get just update the statistics 

)) 

(setf (population.member-f itness (aref newpop i)) 

(eval (push ’+ chromosome))) 

;calc overall fitness (add up all subfunc vals) 

(UPDATE.STATS i)) update stats with them 

(fresh-line)) 


32 


; ========sss================SET_SUBFUNC - VALUE===-=== s: === s = ===ss=s======== * 

;table lookup for list of subfunctions the list resembles the following 

; ((lookup.table# scale factor (subfunc bits) ) (lookup. table# ())...*()) 

(defun SET.SUBFUNC. VALUE (sub.inf o.list ftaux subf. string subfunct.table 
scale. factor subfunct. table# ret. val. list 
num. of .decode) 

(setf num.of. decode (list-length sub. info. list)) 

;get # of subfunctions to decode 

(setf ret. val. list (make-list num.of .decode) ) 

; setup list to be returned of subfunction 
; decoded values 

(do ((subf .num 0 (1+ subf.num))) 

((>= subf.num num.of .decode) ) ;run through all the input list 

(setf subf unct.table# (nth 0 (nth subf.num sub. inf o.list) ) ) 

;get lookup table# 

(setf scale.f actor (nth 1 (nth subf.num sub. inf o.list) ) ) 

;get lookup table# 

(setf subf .string (nth 2 (nth subf.num sub. info. list) ) ) 

;get string to be matched 

(setf subf unct.table (nth subfunct. table# lookup.table) ) 

; access the lookup table specified by subfunct. table# 

(do ((i 0 (1+ i))) 

((>= i (list-length subfunct.table))) 

;go through all the lookup table entries 

(if (equal (nth 0 (nth i subfunct.table)) subf. string) 

; check for a match of decoded lists 
(setf (nth subf.num ret. val. list) 

; if there is a match set the subfunction to 
;the coresponding table value 
(* (nth 1 (nth i subfunct.table)) scale.factor))) 

(if (equal (nth subf.num ret.val.list) nil) 

(setf (nth subf.num ret.val.list) 0)))) 

;no match in table means string not fully specified 
ret.val.list) ;or not specified in table, so fitness is zero 

;= = = = = s== = = = * ==»= = ;====SUBFUNCTION_DECODE :s = s ”====== s === = == = = = = = = = = c ~ = = === = 

; given the bit list will decode from the lookup table the subfunction 
; values final list resembles-- 

; ( (lookup.table#, scale factor, (subf .bit. list) ,(....),(....) (....)) 

(defun SUBFUNCTION. DECODE (bit. list ftaux subf. info scale.factor 
bit. specif ier table.specif ier temp.list 
bit. value subf .inf ormation) 

(setf subf .information ’ ()) ; clear list 

(do ((subf.num 0 (1+ subf.num))) 

;bit_spec specifies subfunction bits, scale factor 
;& lookup table for each subfunction 

((>= subf.num (list-length bit.spec))) 


33 


(setf subf.info (nth subf.num bit. spec)) 

;get single subfunction specifier off bit. spec 

(setf scale.factor (bit.cluster-scale.factor subf.info)) 

;get scale factor 

(setf bit.specif ier (bit. cluster-bit. specif ier subf.info)) 

; get bit specifier (position numbers) 

(setf table. specif ier (bit. cluster-table. specif ier subf.info)) 
;get table specifier 
(setf temp.list * ()) 

(do ( (i 0 (1+ i))) ;get all specified bits & put them in a list 
((>= i (list-length bit. specifier))) 

(setf bit. value (nth i bit.specif ier)) ;get bit value 
(push (nth bit. value bit.list) temp.list)) ;put it on list 
(setf temp.list (list (reverse temp.list))) 

(push scale.factor temp.list) ;put scale factor on list 

(push table.specif ier temp.list) ;and table specifier 
(push temp.list subf .information) ) 

;put all this on the subfunction information list 
(reverse subf .information) ) 


34 


A. 5 File: ops. lisp 

The file ops. lisp contains the various selection functions and the genetic operators. 
;=This file contains all the mGA genetic operators. = 


; takes chromosome cuts it & returns the 2 pieces 
(defun CUT (chromosome &aux rd len) 

(setf len (list-length chromosome)) ; cut position is random 
(if (> len 1) 

(setf rd (RND 1 (1- len)))) 

(cond 

((<= len 1) (list chromosome ’ ())) 

((list (subseq chromosome 0 rd) (subseq chromosome rd len))))) 


; takes 2 pieces puts them together and returns the result 
(defun SPLICE (chroml chrom2) 

(append chroml chrom2)) 

; changes a single bits value 1 to 0 or vice versa at a rate of probability 
(defun MUTATE (gene probability) 

(cond 

((FLIP probability) (setf gene (COMPLEMENT.BIT gene)))) 
gene) 

; takes a chromosome and checks for a mutation at each bit 
(defun MUTATION (chrom &aux len) 

(cond 

((not (zerop mut.prob)) 

; if mutation rate is not zero 
(setf len (list-length chrom)) 

; mutation is determined by mut.prob 

(do ((i 1 (1+ i))) 

((> i len)) ;run through entire chrom 

(setf (nth 1 (nth (1- i) chrom)) 

(MUTATE (nth 1 (nth (1- i) chrom)) mut.prob) ) ) ) ) 
chrom) ; return chrom 

; takes 2 strings matel and mate2 cuts them and returns list of cut pieces 
(defun CUT. AND. STACK (matel mate2 cut.prob &aux loc. stack) 

(cond 

((FLIP (* cut.prob (list-length matel))) ; check for cut 
(setq matel (CUT matel)) 


35 


;if so then cut matel 
(push (cadr matel) loc. stack) 

;put second piece of matel on stack 
(setq matel (pop matel)))) 

;set matel to first piece 

(cond 

((FLIP (* cut. prob (list-length mate2))) ;check for cut 
(progn 

(setq mate2 (CUT mate2)) 

;if so then cut mate2 
(push (cadr mate2) loc. stack) 

;put second piece of mate2 on the stack 
(push (pop mate2) loc.stack))) 

;put first piece of mate2 on the stack 
((push mate2 loc.stack))) 

; otherwise put mate2 (uncut) onto the stack 
(push matel loc.stack)) ;put matel (cut or uncut) onto the 

; stack k return it 

(defun CROSSOVER (matel mate2 cut.prob splice.prob &aux childl child2 
child3 child4 cross) 

(setf stack (CUT. AND. STACK matel mate2 cut.prob)) 

; generate stack of cut pieces 
(setf childl (SPLICE.TESTER splice.prob )) 

; check for splice on childl 
(setf child2 (SPLICE.TESTER splice.prob )) 

; check for splice on child2 
(setf child3 (SPLICE.TESTER splice.prob )) 

; check for splice on child3 
(setf child4 (SPLICE.TESTER splice.prob )) 

; check for splice on child4 
(setf cross (list childl child2 child3 child4 )) 

; return list of children 

(remove nil cross)) 


; =s = = = = = = = = m = = ====3:x== = 3SPLICE_TESTER" = ==== 3= ”= = * ss *” s " = = = = = x ” = = " 
; tests for splice between CUT.AND.STACK(ed) pieces list name -stack 
; example stack (resembles) — > * ((a b c) (d e f) (h i) (j k 1)) execute 
; (SPLICE.TESTER 1.0) (100 '/. prob) (a b c d e f) (top two members spliced) 
; (SPLICE.TESTER 0) (0 # / # prob) (abc) (top member no splice) 

(defun SPLICE.TESTER (splice.prob) 

(cond ;make sure stack is not empty 
(stack (cond 

((FLIP splice.prob) 

; if splice then splice two pieces of stack 
(SPLICE (pop stack) (pop stack))) 


36 


((pop stack)))) ; otherwise return top member of stack 

)) 


;===========================INIT_SELECTION========®==-== = === ============ 

; compares successive shuffled population members amd returns the fittest 
(defun INIT.SELECTION (fcaux first second fittest) 

(if (>= pick popsize) ;if array has been gone through just reset 
(setf pick 0)) ;the pointer to zero 

(setf first pick) ;get the first 

(setf second (1+ pick)) ;get the second 
(setf pick (+ pick 2)) ; inrement location +2 

(if (>= (GET.FITNESS oldpop first) 

(GET_FITNESS oldpop second)) ;compare fitnesses 
(setf fittest first) ;& return fittest 

(setf fittest second)) 
fittest) 


; controls type of selection routine to be used 
(defun DET.SELECTION (ftaux fittest) 

(if (< loopvar init_select_gen) 

(setf fittest (INIT.SELECTION)) 

;use INIT.SELECTION for first three generations 

(progn 

(if (equal thres nil) ; check thres flag 
(setf fittest (NORM.SELECTION shuffle)) 

; thres flag is not set use normal selection 
(setf fittest (THRESH.SELECTION) ) ) ) ) 

; if it is set use thres selection 

fittest) 


;============================N0RM.SELECTI0N====«=========»==== s ==== 

(defun NORM.SELECTION (shuffle ftaux first second fittest) 

(if (>= pick (1- popsize)) 

(progn 

(setf pick 0) ;when you reach the end of the array then, 

(SHUFFLE.POP shuffle))) ; re-shuffle it 
(setf first (aref shuffle pick)) ; select two guys from it 
(setf second (aref shuffle (1+ pick))) 

(setf pick (+ pick 2)) ; increment pointer 

(if (< (GET.FITNESS oldpop first) (GET.FITNESS oldpop second)) 

; compare the fitnesses of the two 
(setf fittest second) 

(setf fittest first)) 

fittest) ; return the fittest 


;=== S s SS ========m==«=««»THRESH_SELECTION=«“==™=====”============= 3 " 

(defun THRESH.SELECTION (ftaux first second chroml chrom2 fittest threshold 


37 



flag stop.position position pts.alike lengthl length2) 

(if (>= pick (- popsize shufnum)) 

; if there’s not enough room at the end of the pop 
(progn ;to run through shufnum# members, then reset the 

(setf pick 0) ;pick and the shuffle array 

(SHUFFLE.POP shuffle))) 

(setf stop. position (+ pick shufnum)) 

(setf first (aref shuffle pick)) 

(setf fittest first) 

(setf chroml (copy (GET.CHROMOSOME oldpop first))) 

;get chrom with removed duplicates 
(setf chroml (remove-duplicates chroml :key ’car :from-end ’t)) 

(setf lengthl (list-length chroml)) 

(setf position (1+ pick)) 

(do ( Ci 1 (1+ i) ) ) ( (or flag (>= position stop.position))) 

(setf position (+ i pick)) 

;exit if thres(hold) is reached or if shufnum 
; members have been looked at 
(setf second (aref shuffle position)) 

(setf chrom2 (copy (GET.CHROMOSOME oldpop second))) 

;get chrom with removed duplicates 
(setf chrom2 (remove-duplicates chrom2 :key ’car :from-end ’t)) 

(setf length2 (list-length chrom2)) 

(setf threshold (/ (* lengthl length2) shufnum)) 

; calculate threshold value 

(setf pts. alike (list-length (intersection chroml chrom2 :key ’car))) 

(cond ((>= pts. alike threshold) 

; calculate the # of common points 
(progn ; if # of common pts > threshold value 

(setf flag ’t) 

(if (>= (GET.FITNESS oldpop first) (GET.FITNESS oldpop second)) 

; compare fitnesses 

(setf fittest first) return most fit member 

(setf fittest second)) 

(setf (aref shuffle (+ pick i)) (aref shuffle (1+ pick))) 

;swap the two positions 
(setf (aref shuffle (1+ pick)) second))))) 

(setf pick (+ pick 2)) ; increment pointer 

fittest) ; return the fittest 


38 


A. 6 File: setup. lisp 

The file setup. lisp contains the initialization code for mGAl.O. 

;=This file contains the clode for setting up all the parameters od the = 
;=mGA via a user specified setup file. The routines are primarily = 

;=involved with accesssing the file, pattern matching and the setting = 

;=the specified parameter. The exeption is MAKE_NEW_POP (see below) ■ 

(defun MAKE.NEW.POP (num.positions max.length ftoptional copies ftaux count 
bit.positions position_list bit_list bits max_size) 

(format t ""‘/.Making Population of building block size "A" num.positions) 
(format t ""7, and chromosome length "A" max.length) 

(cond ((not copies) 

(setf copies 1))) 

(setf bit.positions (expt 2 num.positions)) 

;calc bit position counter 
(setf max.size 

(* copies (* bit.positions (CHOOSE max.length num_positions)))) 

;calc pop size for blocks 

(setf newpop (make-array max.size)) 

; create newpop array 

(setf position.list (make-list num.positions)) 

; create position list 
(SET.ASC.LIST position.list 0) 

; initialize to (0 1 2 . . . num_positions-l) 

(setf bit.list (make-list num.positions)) ; create bit.list 

(setf count 0) 

(do () 

((>= count (1- max.size))) ; generate every block 
(SET.LIST bit.list 0) ; reset bit.list to all zeros 
(do ((j 0 (1+ j))) ;run through all bit combinations 
((>= j bit.positions) ) 

(setf bits nil) ;reset temporary bit/value holder 
(if (/= j 0) ;on second and subseq passes increment bit.list 
(N.ARY.C0UNT bit.list 1 (1- num_positions))) 

(do ((k 0 (1+ k))) 

((>= k num.positions)) ; create pos/value list 

(push (list (nth k position.list) (nth k bit.list)) bits)) 

(do ((m 0 (1+ m))) 

((>= m copies)) ;make copies if specified 
(setf (aref newpop count) (make-population_member)) 

; create structure population.memeber 
(setf (population.member-chrom 
(aref newpop count)) (reverse bits)) 

;set member to the bit/val list 
(setf cotint (1+ count))) 


39 


) 

(COMBINATION max. length num.positions position.list )) 

; increment to next position 

(format t ""'/Population Size is now "A"'/,' 1 count) 

(setf popsize count)) ; return population size created 

.... »>>>>>»L0AD PROGRAM STARTS HERE<<<<<<<<<<<<<< 

;the purpose is to setup all the global variables given a setup file 

(defun SETUP.GA () 

(setf first.time 1) 

(fresh-line) 

(format t "enter name of setup file--") ; 

(setf setup. file (read)) ;get name of setup file from user 
(fresh-line) 

(setf instream (open setup. file idirection : input)) 

;open setup file for reading 

(setf indata (read instream)) ;read from setup file 

(do () ((equal indata ’end)) ;read until end marker is reached 

(if (equal indata 5 OBJ) ;if OBJ marker is reached go to SETUP. OBJ 
(SETUP. OBJ) ) 

(if (equal indata } POPULATION) ;population setup marker 
(SETUP. POP) ) 

(setf indata (read instream)) 

) 

(close instream) ; close setup file 

(format t "setup file "A is loaded"'/" setup. file)) 

; inform that setup file has been loaded 


;sets up objective function parameters 

(defun SETUP. OBJ (&aux inlist table# scale subfunction) 

(setf subfunction 0) 

(setf num.tables 0) 

(setf bit. spec (make-list num. subfunctions)) 

; create bit specifier array 

(format t "setting up objective function"'/") 

;tell user what’s being set up 

(setf indata (read instream)) ;read from file 

(do () ((equal indata ’***)) ;read until *** patterm is found 

(if (equal indata ’ subfunction.bits) ; if setup for subfunction bits 
(progn 

(setf inlist nil) ;reset all parameters 
(setf table# nil) 

(setf scale nil) 

(setf indata (read instream)) ;read next data item from file 
(do () ((not (numberp indata))) ;read until a # is not encountered 


40 


(push indata inlist) 

;make it into a list of numbers 
;(the subfunction bits) 

(setf indata (read instream))) ;read next 
(if (equal indata ’Itable) ;if lookup table label then, 

(progn 

(setf indata (read instream)) ;read next value 
(setf table# indata) ;get lookup table number 
(if (> table# num.tables) ;keep track of # of lookup tables 
(setf num.tables table#)) 

(setf indata (read instream)) ;read next file data 

)) 

(if (equal indata 7 scale) ; if scale factor 
(progn 

(setf indata (read instream)) ;read in data 
(setf scale indata))) ; assign it to scale 
;nov that all data has been gotten for 1 
; subfunction setup bit. spec structure for it 
(setf (nth subfunction bit.spec) 

(make-bit. cluster :bit_specif ier (reverse inlist) 

: table. specifier table# 

: scale.f actor scale)) 

(fresh-line) 

(setf subfunction (1+ subfunction)))) 

; increment subfunction counter 

(if (equal indata ’table) 

; if lookup table then go to lookup table setup routine 
(SETUP. TABLE) ) 

(if (equal indata ’template) 

; if template then go to template setup section 
(SETUP.TEMPLATE) ) 

(setf indata (read instream)) ;read next data 

)) 

jss====xssa5a===*=*»==SETUP.TEMPLATE=== s ^- s === === == =ssa=ss==5===!!!===SS! 

;sets up competitive template 
(defun SETUP.TEMPLATE () ; 

(setf std_fi.il (make-list bits_per_chrom) ) 

; setup size of standard fill array 
(do ( (i 0 (1+ i))) 

((>= i bits_per_chrom) ) ;get all the bits 
(setf (nth i std.fill) (read instream)))) ;set the bits 

;===*============*====SETUP_TABLE=== B ==== a =====*®=== ====5!X5,==S!=as!== 

; sets up lookup table made of two parts-bits and coresponding value 
(defun SETUP_TABLE (ftaux table.number inlist data.value) 

(format t "setting up lookup table'X") 


41 


(cond 

(first. time ;if the first time through then create 
;the lookup table 

(setf lookup.table (make-list (1+ num.tables))) 

(setf first. time nil))) 

(setf table. number (read instream)) ;get table number 
(setf indata (read instream)) ;read next file data 

(do () ((equal indata "end. table)) ;read until the end of that table 
(setf inlist nil) 

(setf data.value nil) ;get data value from file 

(if (equal indata ’bvalue) ; if bit value 
(progn 

(setf indata (read instream)) 

(do () ((not (numberp indata))) 

(push indata inlist) 

(setf indata (read instream))) ; assign to bit list 
(if (equal indata J dvalue) ; if data value 

(progn 

(setf indata (read instream)) 

(setf data.value indata) ; assign data value 
(setf indata (read instream)))) 

(push (list (reverse inlist) data.value) 

(nth table. number lookup.table)) 

;put bits & coresponding value on lookup table 

)))) 


;this routine sets up population parameters 
(defun SETUP. POP () 

(format t "setting up population parameters'^") 

(setf bits.per.chrom nil) 

(setf maxgen nil) 

(setf num.subfunctions nil) 

(setf cookgen nil) 

(setf shufnum nil) 

(setf seed nil) 

(setf cutpopgen nil) 

(setf cut.prob 0) 

(setf splice. prob 0) 

(setf mut.prob nil) 

(setf pspe nil) 

(setf thres nil) 

(setf garbage. collect 1) 

(setf bldg.blk.size nil) 

(setf member.copies 1) 

(setf init. select. gen 1) 

(setf indata (read instream)) 

(do () ((equal indata ’***)) ;read until star pattern is encountered 


42 


(cond ((equal indata * chrom.length) 
(setf indata (read instream)) 

(setf bits.per.chrora indata)) 

((equal indata ’maxgen) 

(setf indata (read instream)) 

(setf maxgen indata)) 

((equal indata ' num.subf unctions) 
(setf indata (read instream)) 

(setf num.subfunctions indata)) 
((equal indata ' cookgen) 

(setf indata (read instream)) 

(setf cookgen indata)) 

((equal indata ' shufnum) 

(setf indata (read instream)) 

(setf shufnum indata)) 

((equal indata 'seed) 

(setf indata (read instream)) 

(setf seed indata)) 

((equal indata 1 cutpopgen) 

(setf indata (read instream)) 

(setf cutpopgen indata)) 

((equal indata ' cut.prob) 

(setf indata (read instream)) 

(setf cut.prob indata)) 

((equal indata ’ splice. prob) 

(setf indata (read instream)) 

(setf splice.prob indata)) 

((equal indata 'mut.prob) 

(setf indata (read instream)) 

(setf mut.prob indata)) 

((equal indata 'pspe) 

(setf indata (read instream)) 

(setf pspe indata)) 

((equal indata ' thres) 

(setf indata (read instream)) 

(setf thres indata)) 

((equal indata 'bldg.blk.size) 

(setf indata (read instream)) 

(setf bldg.blk.size indata)) 

((equal indata 1 init.select.gen) 

(setf indata (read instream)) 

(setf init.select.gen indata)) 
((equal indata 'member.copies) 

(setf indata (read instream)) 

(setf member. copies indata)) 

((equal indata 'garbage. collect) 

(setf indata (read instream)) 

(setf garbage. collect indata))) 


43 


(setf indata (read instream)))) ;get next data 


44 


A. 7 File: stats. lisp 

The file stats. lisp contains statistical and reporting functions for mGAl.O. 

;=This file contains the statistical and reporting related code = 


;= ============: S ===INmAL_OUTPUT================== = ===" = === ==s== = == = = == == 

; writes out initial data to data file, statistics file and screen 


(defun INITIAL. OUTPUT () 

(format screen&file ,, ~3XRUN PARAMETERS 
(format screen&file “Maxgen = *A~X“ maxgen) 

(format screen&file “Cookgen = ~A~'/, “cookgen) 

(format screen&file "Cutpopgen = 'A - '’/," cutpopgen) 

(format screen&file n Init. select. gen « A X" init.select.gen) 

(format screen&file "Threshold * ~A~ # /*“ thres) 

(format screen&file “Shuffle-Down Number = 'A~X M shufnum) 

(format screen&file “Random Seed = "A~ , /,“ seed) 

(format screen&file "pspe = ~A~y,“ pspe) 

(format screen&file “Competitive Template- ~A'3X" std.fill) 

(format data "Generation Popsize Maximum.Fitness Average. Fitness' -/.")) 


(defun UPDATE.STATS (pop.member &aux good.count subf.list total.f itness) 
(setf total.f itness 0) ; reset counter variables 

(setf good_count 0) 

(setf subf.list (GET.SUBFUNCTION.LIST newpop pop.member)) 

(setf total.f itness (GET.FITNESS newpop pop.member)) 

(do ((j 0 (1+ j))) 

((>= j (list-length subf.list))) 

;run through all the subfunctions for the subf.list 

(if (>= (nth j subf.list) (- (nth j subf.pos.max) .01)) 

; check for max subfunctions 
(progn 

(setf good.count (1+ good.count)) 

; local counter to keep track of max # of optimal 
; subfunctions in single chrom 

(setf (aref vertnum_spot j) (1+ (aref vertnum_spot j))) 

; keeps track of max# of optimal subfunctions on 
;a per subfunction basis 
(setf numgood (1+ numgood))))) 

; count total number of optimal subfunctions 
(setf sumf itness (+ sumf itness total.f itness)) 

;keep track of the total sum fitness 
(if (> total.f itness (nth 0 maxfitness)) 

;keep track of max fitness in population 
(progn 

(setf (nth 0 maxfitness) total.f itness) 


45 


(setf (nth 1 maxfitness) pop. member) 

)) 

(if (< total. fitness minfitness) 

(setf minfitness total.f itness)) 

;keep track of min fitness in population 
(if (> good. count max.numgood) 

*;keep track of max# of optimal subfunctions 
; in single population member 

(setf max.numgood good. count) ) ) 

(defun RESET. STAT. INFO 0 ;resets all statistical counters 
(setf vertnum.spot (make-array num. subfunctions ) ) 

(setf maxfitness (make-list 2)) 

(setf (nth 0 maxfitness) 0) jmaxiraum fitness in the population 
(setf (nth 1 maxfitness) 1) 

(setf minfitness subf .pos.max) 

(setf minfitness (eval (push *+ minfitness))) 

jminimum fitness in the population 

(setf sumf itness 0) ; total fitness of population 

(setf numgood 0) ; total number of optimal optimal subfunctions 

;in population 

(setf max.numgood 0) ;max optimal subfunctions in a single chromosome 
(array-initialize vertnum.spot 0)) 

; number of optimal subfunctions in each 
; subfunction position 


;prints out population statistics to file and screen each generation 
(defun STATISTICS () 

(format t /.running STATISTICS-/*") 

(setf avg.fitness (float (/ sumfitness popsize))) 

;calc average fitness 

(format screen&file "Generation# ~A~X" loopvar) 

;print out various statistics 

(format screen&file "Popsize ® 'A*'/," popsize) 

(format screen&file "Minfitness * 'AT* minfitness) 

(format screen&file "Maxfitness * 'A~X" (nth 0 maxfitness)) 

(format screen&file "Average fitness * "’A^X 11 avg.fitness) 

(format screen&file "Maximum number of optimal subfunctions = 'A“ # 
max.numgood) 

(format screen&file "Total number of optimal subfunctions = 'A"'/*" 
numgood) 

(format screen&file "Average number of optimal subfunctions » A '/," 
(float (/ numgood popsize))) 

(format data "~A" loopvar) 

(format data " 'A 'A "A — popsize (nth 0 maxfitness) avg.fitness) 
(do ((i 0 (1+ i))) ;prints out information per subfunctional 


46 



((>= i num.subf unctions) ) 

(format screen&file 

"Total and Average Number of optimal subfunctions in position ~A = ~A and ~A” , / t " 
(1+ i) (aref vertnum.spot i) 

(/ (float (aref vertnum.spot i)) popsize))) 

(format screen&file ""'/.Best solution so far =~A~'/," 

(FILL.NIL.POSITIONS 

(EXTRACT (GET.CHROMOSOME newpop (nth 1 maxf itness) ) ) ) ) 

(format screen&file "Fitness - ~ k~V' (nth 0 maxf itness))) 


;================se=s=s=======setup _SUBFUNC.HAX=======««============== S ===== 

;this function sets up a list that has the maximum value each subfunction 
;in that position can obtain (scale factor applied) 

(defun SETUP. SUBFUNC. MAX (&aux ret. list subf.max subf.info 
scale. factor table.specif ier subfunct. table) 

(setf ret. list *()) initialize return list 
(do ((i 0 (1+ i))) ;run through all the subfunctions 
((>= i (list-length bit. spec))) 

(setf subf.max 0) ;set max to lowest possible val 
(setf subf.info (nth i bit. spec)) 

;get subfunction specifier 

(setf scale. factor (bit. cluster-scale. factor subf.info)) 

;get scale factor from list 

(setf table.specif ier (bit. cluster-table. specif ier subf.info)) 

;get lookup table specifier off list 

(setf subfunct. table (nth table.specif ier lookup.table) ) 

; access the single lookup table 

(do ((j0(l+j))) ;go through entire lookup table 
((>= j (list-length subfunct.table) ) ) 

;and find the highest value in the table 

(if (> (nth 1 (nth j subfunct.table)) subf.max) 

(setf subf.max (nth 1 (nth j subfunct.table))))) 

(push (* scale. factor subf.max) ret. list)) 

;put it on the list 

(reverse ret.list)) ;set returned lists to proper order 


