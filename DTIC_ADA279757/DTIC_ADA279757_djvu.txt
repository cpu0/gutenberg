•MNtMianskf 


AD-A279 757 »ON PAGE 


FofmApfimvad 

OPMNo. 


f Mr KMpanM. Murfins III* Him tar kiMiMliOfM. Mwohing Mtiilipig d«a HU)DM 

MimMta uptnlifin titta kuiMn aMiniM m tun tatiar m p t a el iMs otltaalien el Memmien. inrtiirtiiMi 
!• tar I n tar w i l tar i Op—tioni and Raporta. 12lt JeUenen OMta HglMair. SuM 12M, Artir^tan, VA 
Ml— and ludgal. WaaMngtan. DC lOWS._ 





940325S1.11343, AVF: 94ddc500_lA 

DDC-I, DACS Sun SPARC/Solarls to 80186 Bare Ada Cross Compllei 
System, Version 4.6.4 




National Institute of Standards and Technology 
Gaithersburg, Maryland 


Technology 

Gaithersburg, Maryland 20899 


Ada Joint Program Office 
The Pentagon, Rm 3E118 
Washington, DC 20301-3080 





1 





Approved for Public Release; .distribution unlimited 


Imumsoo 

Host: Sun SPARCclasslc (under Solaris, Release 2.1) 
Target: Intel ISBC 186/100 (bare machine) 






CtASWPICATION 

UNCLAS8IFED 


UNCLASSIFED 


CLASSrCATION 

UNCLASSIFED 


M 5 25 015 


^^^■irYmFiVV’rrrry^t 


Cl nty 


20 . 

UNCLASSEED 


r0fni2vB«' 
PrMcftoad ty ANSI Sid. 





















AVF Control Number: NIST94DDC500_lB_l.ii 
DATE COMPLETED 

BEFORE ON-SITE: 94-03-18 
AFTER ON-SITE: 94-03-28 
REVISIONS: 94-04-11 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 940325S1.11343 
DDC-I 

DACS Sun SPARC/Solaris t6 80186 Bare Ada 
Cross Compiler System, Version 4.6.4 
Sun SPARCclassic => Intel iSBC 186/100 (Bare Machine) 


Prepared By: 

Software Standards Validation Group 
Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 



Accesion For 1 


NTIS CRA&I j|P 1 

OTIC TAB E 1 

Unannounced □ 1 

iiictifir.ation _ --1 



Distribution! 1 

Availability Codes 1 

1 Avail and/or 1 

Dist 1 Special 1 

1 





AVF Control Niamber: NIST94DDC500_1B_1.11 
Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on March 25 , 1994. 

Compiler Name and Version: OACS Sun SPARC/Solaris to 80186 Bare Ada 

Cross Compiler System, Version 4.6.4 

Host Computer System: Sun SPARCclasslc running under Solaris, 

Release 2.1 

Target Computer System: Intel iSBC 186/100 (Bare Machine) 

See section 3.1 for any additional Information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
940325S1.11343 is awarded to DDC-*!. This certificate expires 2 years 
after ANSI/MIL-STD-1815B is approved by ANSI. 


This report has been reviewed and is approved. 



Ada Validation :Maci|litiy Ada Validation Facility 

Dr. David K. Jeffex^oi^ Mr. L. Arnold Johnson 

Chief, Information Systems Manager, Software Standards 

Engineering Division (ISED) Validation Group 

Computer Systems Laboratory (CSL) 

National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 
















NIST94DDC500 IB 1.11 


DECLARATION OF CONFORMANCE 

The following declaration of conformance was supplied by the customer. 
Customer: DDC-I 

Certificate Awardee: DDC-I 

Ada Validation Facility: National Institute of Standards and 

Technology 

Confjuter Systems Laboratory (CSL) 

. Software Standards Validation Group 

Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 

ACVC Version: 1.11 


Ada Implementation: 

Compiler Name and Version: DACS Sun SPARC/Solaris to 80186 Bare Ada Cross 

Compiler System, Version 4.6.4 

Host Computer System: Sun SPARCclassic running under Solaris, Release 2.1 

Target Computer System: Intel iSBC 186/100 (Bare Machine) 

Declaration: 

I the undersigned, declare that I have no knowledge of deliberate deviations from the 
Ada Language Standard ANSI/MIL-STD-1815A ISO 8652-1987 in the implementation listed 
above. 



Ce^if'icate^ Awardee Signature 

Company DDC-I 

Title 


Date 













TABLE OF CONTENTS 


CHAPTER 1.1-1 

INTRODUCTION.1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES.2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST MODIFICATIONS.2-3 

CHAPTER 3..................................................3—1 

PROCESSING INFORMATION.! !.! 3-1 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A.A-1 

MACRO PARAMETERS.A-1 

APPENDIX B.B-1 

COMPILATION SYSTEM OPTIONS.B-1 

LINKER OPTIONS.B-2 

APPENDIX C.C-1 

APPENDIX P OF THE Ada STANDARD.C-1 





























CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro92] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada Implementation. For any technical terms used in this 
report, the reader is referred to [Pro92]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552). The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada standard other 
than those presented. Copies of this repoxrt are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield, Virginia 22161 
U.S.A. 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 


Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria, Virginia 22311-1772 

U.S.A. 


1-1 









1.2 REFERENCES 


[Ada83] Reference _ Manual __ the Ada Proaranroing _ Language . 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro92] Ada CompiLsr- Yfl Udation Pr9Se d^ E, gg > version 3 . 1 , Ada joint 
Program Office, August 1992. 

[UG89] Ada Compiler Validation Capability User’s Guide . 21 June 
1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK__FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is 
compiled and the resulting compilation listing is examined to 
verify that all violations of the Ada Standard are detected. Some 
of the class B tests contain legal Ada code which must not be 
flagged illegal by the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values—for example, the 


1-2 










largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 
the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdravm tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [U689]). 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler The software and any needed hardware that 

have to be added to a given host and target 
computer system to allow transformation of 
Ada programs into executable form and 
execution thereof. 


Ada Compiler 
Validation 
Capability (ACVC) 


Ada Implementation 


Ada Joint Program 
Office (AJPO) 


Ada Validation 
Facility (AVF) 


Ada Validation 
Organization (AVO) 

Compliance of an 
Ada Implementation 


The means for testing compliance of Ada 
Implementations, Validation consisting of 
the test suite, the support programs, the 
ACVC Capability User's Guide and the 
template for the validation summary (ACVC) 
report. 

An Ada compiler with its host computer 
system and its target computer system. 

The part of the certification body which 
provides policy and guidance for the Ada 
certification Office system. 

The part of the certification body which 
carries out the procedures required to 
establish the compliance of an Ada 
implementation. 

The part of the certification body that 
provides technical guidance for operations 
of the Ada certification system. 

The ability of the implementation to pass an 
ACVC version. 


1-3 






Computer System 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable Test 

ISO 

LRH 


Operating System 


Target Computer 
System 


A functional unit, consisting of one or more 
computers and associated software, that uses 
common storage for all or part of a program 
and also for all or part of the data 
necessary for the execution of the program; 
executes user- written or user-designated 
programs; performs user-designated data 
manipulation, including arithmetic 
operations and logic operations; and that 
can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 

Fulfillment by a product, process, or 
service of all requirements specified. 

An individual or corporate entity who enters 
into an agreement with an AVF which 
specifies the terms and conditions for AVF 
services (of any kind) to be performed. 

A formal statement from a customer assuring 
that conformity is realized or attainable on 
the Ada implementation for which validation 
status is realized. 

A computer system where Ada source programs 
are transformed into executable form. 

A test that contains one or more test 
objectives found to be irrelevant for the 
given Ada implementation. 

International Organization for 
Standardization. 

The Ada standard, or Language Reference 
Manual, published as ANSI/MIL-STD-1815A 
-1983 and ISO 8652-1987. Citations from the 
LRM take the form "<section>.<subsection>: 
<paragraph>.” 

Software that controls the executio.. of 
programs and that provides services such as 
resource allocation, scheduling, 
input/output control, and data management. 
Usually, operating systems are predominantly 
software, but partial or complete hardware 
implementations are possible. 

A computer system where the executable form 
of Ada programs are executed. 


1-4 








Validated Ada 
Compiler 

Validated Ada 
Implementation 


Validation 


Withdrawn Test 


The compiler of a validated Ada 
implementation. 

An Ada implementation that has been 
validated successfully either by AVF testing 
or by registration [Pro92]. 

The process of checking the conformity of an 
Ada compiler to the Ada programming language 
and of issuing a certificate for this 
implementation. 

A test found to be incorrect and not used in 
conformity testing. A test may be incorrect 
because it has an invalid test objective, 
fails to meet its test objective, or 
contains erroneous or Illegal use of the Ada 
programming language. 


1-5 







CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are vithdra%m by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 104 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 93-11-22. 


B27005A 

E28005C 

B28006C 

C32203A 

C34006D 

C35507K 

C35507L 

C35507N 

C355070 

C35507P 

C35508I 

C35508J 

C35508H 

C35508N 

C35702A 

C35702B 

C37310A 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A54B02A 

C55B06A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

C02A41E 

C02A87A 

CD2B15C 

BD3006A 

BD4008A 

C04022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

C09005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 






2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Commentaries and commonly referenced in 
the format Al-ddddd. For this implementation, the following tests 
were determined to be inapplicable for the reasons indicated; 
references to Ada Commentaries are included as appropriate. 

The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 

C24113L..Y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L,.Y (14 tests) 


2-1 









C35708L..Y (14 tests) C35802L..Z (15 tests) 

C45241L..Y (14 tests) C45321L..Y (14 tests) 

C45421L. .Y (14 tests) C45521L. .Z ^5 tests) 

C45524L..Z (15 tests) C45621L..Z (15 tests) 

C45641L..Y (14 tests) C46012L..Z (15 tests) 

C24113I..K (3 tests) use a line length in the input file which 
exceeds 126 characters. 

C35404D, C45231D, B86001X, C86006E, and CD7101G check for a 

predefined integer type with a name other than INTEGER, 
LONG_INTEGER, or SHORT_INTEGER; for this implementation, there is 
no such type. 

C35713B, C45423B, B86001T, and C86006H check for the predefined 
type SHORT_FLOAT; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with 
a name other than FLOAT, LONG_FLOAT, or SHORT_FLOAT; for this 
implementation, there is no such type. 

C45S31M..P and C45532M..P (8 tests) check fixed-point operations 
for types that require a SYSTEM.MAX MANTISSA of 47 or greater; for 
this implementation, MAX_MANTISSA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFIXDWS is FALSE for floating point types and the results 
of various floating-point operations lie outside the range of the 
base type; for this implementation, MACHINE_OVERFLOWS is TRUE. 

C4A013B contains a static universal real expression that exceeds 
the range of this implementation's largest floating-point type; 
this expression is rejected by the compiler. 

D56001B uses 65 levels of block nesting; this level of block 
nesting exceeds the capacity of the compiler. 

B86001Y uses the name of a predefined fixed-point type other than 
type DURATION; for this implementation, there is no such type. 

C96005B uses values of type DURATION'S base type that are outside 
the range of type DURATION; for this implementation, the ranges are 
the same. 

CA2009C and CA2009F check whether a generic unit can be 
instantiated before its body (and any of its subunits) is compiled; 
this implementation creates a dependence on generic units as 
allowed by AI-00408 and AI-00506 such that the compilation of the 
generic unit bodies makes the instantiating units obsolete. (See 
section 2.3.) 


2-2 






<'D1009C checks whether a length clause can specify a non-default 
size for a floating-point type; this implementation does not 
support such sizes. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length 
clauses to specify non-default sizes for access types; this 
Implementation does not support such sizes. 

The following 264 tests check operations on sequential, text, and 
direct access files; this implementation does not support external 
files: 


CE2102A..C 

(3) 

CE21026..H 

(2) 

CE2102K 


CE2102N..Y 1 

(12) 

CE2103C..D 

(2) 

CE2104A..D 

(4) 

CE2105A..B 

(2) 

CE2106A..B 

(2) 

CE2107A..H 

(8) 

CE2107L 


CE2108A..H 

(8) 

CE2109A..C 

(3) 

CE2110A..D 

(4) 

CE2111A..1 

(9) 

CE2115A..B 

(2) 

CE2120A..B 

(2) 

CE2201A..C 

(3) 

EE2201D..E 

(2) 

CE2201F..N 

(9) 

CE2203A 


CE2204A..D 

(4) 

CE2205A 


CE2206A 


CE2208B 


CE2401A..C 

(3) 

EE2401D 


CE2401E..F 

(2) 

EE2401G 


CE2401H..L 

(5) 

CE2403A 


CE2404A..B 

(2) 

CE2405B 


CE2406A 


CE2407A..B 

(2) 

CE2408A..B 

(2) 

CE2409A..B 

(2) 

CE2410A..B 

(2) 

CE2411A 


CE3102A..C 

(3) 

CE3102F..H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A..C 

(3) 

CE3106A..B 

(2) 

CE3107B 


CE3108A..B 

(2) 

CE3109A 


CE3110A 


CE3111A..B 

(2) 

CE3111D..E 

(2) 

CE3112A..D 

(4) 

CE3114A..B 

(2) 

CE3115A 


CE3119A 


EE3203A 


EE3204A 


CE3207A 


CE3208A 


CE3301A 


EE3301B 


CE3302A 


CE3304A 


CE3305A 


CE3401A 


CE3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A..C 

(3) 

CE3403E..F 

(2) 

CE3404B..D 

(3) 

CE3405A 


EE3405B 


CE3405C..D 

(2) 

CE3406A..D 

(4) 

CE3407A..C 

(3) 

CE3408A..C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE3410C..E 

(3) 

EE3410F 


CE3411A 


CE3411C 


CE3412A 


EE3412C 


CE3413A..C 

(3) 

CE3414A 


CE3602A..D 

(4) 

CE3603A 


CE3604A..B 

(2) 

CE3605A..E 

(5) 

CE3606A..B 

(2) 

CE3704A..F 

(6) 

CE3704M..0 

(3) 

CE3705A..E 

(5) 

CE3706D 


CE3706F..G 

(2) 

CE3804A..P 

(16) 

CE3805A..B 

(2) 

CE3806A..B 

(2) 

CE3806D..E 

(2) 

CE3806G..H 

(2) 

CE3904A..B 

(2) 

CE3905A..C 

(3) 

CE3905L 


CE3906A..C 

(3) 

CE3906E..F 

(2) 


CE2103A, CE2103B, and CE3107A use an illegal file name in an 

attempt to create a file and expect NAME_ERROR to be raised; this 
implementation does not support external files and so raises 
USE_ERROR. (See section 2.3.) 

2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 71 tests. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in 


2-3 


4 










the way expected by the original tests. 


B22003A 

B35101A 

B38009B 

B61001R 

B83E01C 

B91002C 

B91002J 

B95077A 

BC1109D 


B26001A 

B37106A 

B55A01A 

B61001W 

B83E01E 

B91002D 

B91002K 

B97103E 

BC1202A 


B26002A 

B37301B 

B61001C 

B67001H 

B85001D 

B91002E 

B91002L 

B97104G 

BC1202F 


B26005A 

B37302A 

B61001F 

B83A07A 

B85008D 

B91002F 

B95030A 

BAIOOIA 

BC1202G 


B28003A 

B38003A 

B61001H 

B83A07B 

B91001A 

B91002G 

B95061A 

BAllOlB 

BE2210A 


B29001A 

B38003B 

B61001I 

B83A07C 

B91002A 

B91002H 

B95061F 

BC1109A 

BE2413A 


B33301B 

B38009A 

B61001M 

B83E01C 

B91002B 

B91002I 

B95061G 

BC1109C 


C83030C and C86007A were graded passed by Test Modification as 
directed by the AVO. These tests were modified by inserting 
"PRAGMA ELABORATE (REPORT);" before the package declarations at 
lines 13 and 11, respectively. Without the pragma, the packages 
may be elaborated prior to package Report's body, and thus the 
packages' calls to function REPORT.IDENT_INT at lines 14 and 13, 
respectively, will raise PROGRAM__ERROR. 

CA2009C and CA2009F were graded inapplicable by Evaluation 
Modification as directed by the AVO. These tests contain 
instantiations of a generic unit prior to the compilation of that 
unit's body; as allowed by AI-00408 and AI-00506, the compilation 
of the generic unit bodies makes the compilation unit that contains 
the instantiations obsolete. 

BC3204C and BC3205D were graded passed by Processing Modification 
as directed by the AVO. These tests check that instantiations of 
generic units with unconstrained types as generic actual parameters 
are illegal if the generic bodies contain uses of the types that 
require a constraint. However, the generic bodies are compiled 
after the units that contain the instantiations, and this 
implementation creates a dependence of the instantiating units on 
the generic units as allowed by AI-00408 and AI-00506 such that the 
compilation of the generic bodies makes the instantiating units 
obsolete—no errors are detected. The processing of these tests 
was modified by re-compiling the obsolete units; all intended 
errors were then detected by the compiler. 

CE2103A, CE2103B, and CE3107A were graded inapplicable by 
Evaluation Modification as directed by the AVO. The tests abort 
with an unhandled exception when USE ERROR is raised on the attempt 
to create an external file. This Fs acceptable behavior because 
this implementation does not support external files (cf. AI-00332). 


2-4 







CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is 
described adequately by the information given in the initial pages 
of this report. 

For technical information about this Ada implementation, contact: 

Forrest Holemon 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 

Telefax: 602-275-7502 

For sales information about this Ada implementation, contact: 

Mike Halpin 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 
Telefax: 602-275-7502 

Testing of this Ada implementation was conducted at the customer's 
site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro92]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the nximber of ACVC tests in various 
categories. All tests were processed,; except those that were 
withdrawn because of test errors (item b; see section 2.1), those 
that require a floating-point precision that exceeds the 
implementation's maximum precision (item e; see section 2.2>, and 
those that depend on the support of a file system—if none is 
supported (item d). All tests passed, except those that are listed 
in sections 2.1 and 2.2 (counted in items b and f, below). 


3-1 










a) Total Number of Applicable Tests 

b) Total Number of Withdrawn Tests 

c) Processed Inapplicable Tests 

d) Non-Processed I/O Tests 

e) Non~Processed Floating-Point 

Precision Tests 

f) Total Number of Inapplicable Tests 
9 ) Total Number of Tests for ACVC 1.11 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 
1.3) was taken on-site by the validation team for processing. The 
contents of the magnetic tape were loaded directly onto the host 
computer. 

After the test files were loaded onto the host computer, the full 
set of tests was processed by the Ada implementation. The DDC-I 
Ada downloader mns on the Sun SPARCclassic and is used for 
downloading the executable images to the target Intel '""iC 186/100 
(Bare Machine). The DDC-I Debug Monitor runs on the tc jget Intel 
iSBC 186/100 (Bare Machine) and provides communication interface 
between the host downloader and the executing target Intel iSBC 
186/100 (Bare Machine). The two processes communicate via 
ethernet. 

The tests were compiled and linked on the host computer system, as 
appropriate. The executable images were transferred to the target 
computer system by the communications link described above, and 
run. The results were captured on the host computer system. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B for 
a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this test 
were: 

-list 

Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. The listings 
examined on-site by the validation team were also archived. 


3562 

104 

504 

0 

0 

504 (c+d+e) 

4170 (a+b+f) 


3-2 









APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing 
the ACVC. The meaning and purpose of these parameters are 
explained in [U689]. The parameter values are presented in two 
tables. The first table lists the values that are defined in terms 
of the maximum input-line length, which is the value for 
$MAX_IN LEN—also listed here. These values are expressed here as 
Ada strrng aggregates, where "V represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 126 — Value of V 

$BIG_ID1 (1..V-1 => 'A', V «> 'I*) 

$BIG_ID2 (1..V-1 »> ‘A*, V «> '2') 

$BIG_ID3 (1..V/2 -> 'A') & '3' & (1..V-1-V/2 «> 'A') 

$BIG_ID4 (1..V/2 => 'A') & '4' & (1..V-1-V/2 => 'A') 

$BIG_INT_LIT (1..V-3 => '0') & "298" 

$BIG_REAL_LIT (1..V-5 *> 'O*) & "690.0" 

$BIG_STRING1 & (1..V/2 »> 'A') & 

$BIG_STRING2 & (1..V-1-V/2 => 'A') & '1* & 

$BLANKS (1..V-20 *> ' ') 

$MAX_IiEN_INT_BASED_LITERAL 

"2:" & (1..V-5 => 'D') & "11;" 

$MAX_LEN_REAL_BASED_LITERAL 

"16;" & (1..V-7 => '0') & "F.E;" 

$MAX_STRING_LITERAL & (1..V-2 *> 'A') & •""• 


A-1 










The following table contains the values for the remaining 
macro parameters. 


Macro Parameter 


Macro Value 


ACC_SIZE 

ALIGNMENT 

COUNT_IiAST 

DEFAULT__MEM_SIZE 

DEFAULT_STOR_UNIT 

DEFAULT_SYS_NAME 

DELTA_DOC 

ENTRy_ADDRESS 

ENTRy_AODRESSl 

ENTRy_ADDRESS2 

FIELD_LAST 

FILE_TERMINATOR 

FIXED_NAME 

FLOAT_NAME 

FORM_STRING 

FORM STRING2 


32 

1 

32767 

1_048_576 

16 

IAPX186 

2#1.0#E-31 

(140,0) 

(141,0) 

(142,0) 

35 

ASCII.SUB 

NO_SUCH_FIXED_TyPE 

SH0RT_SH0RT_FL0AT 

Mil 


••CANNOT_RESTRICT_FILE_CAPACITy“ 
GREATER_THAN_DURATION : 75_000.0 

GREATER_THAN_DURATION_BASE_LAST : 131_073.0 

GREATER_THAN_FLOAT_BASE_LAST : 16#1.0#E+32 

GREATER_THAN_FLOAT_SAFE_LARGE : 16#5.FFFF_F0#E+31 

GREATER_THAN_SHORT_FLOAT_SAFE_LARGE: 1.0E308 
HIGH_PRIORITy : 31 

ILLEGAL_EXTERNAL_FILE_NAME1 : \NODIRECTORy\FILENAME 

ILLEGAL_EXTERNAL_FILE_NAME2 : 

THIS-FILE-NAME-IS-TOO-LONG-FOR-My-SySTEM 
INAPPROPRIATE_LINE_LENGTH : -1 

INAPPROPRIATE_PAGE_LENGTH : -1 

INCLUDE PRAGMAl : 


INCLUDE PRAGMA2 


PRAGMA INCLUDE ('•A28006D1.ADA") 


PRAGMA 

INTEGER_FIRST : 
INTEGER_LAST : 
INTEGER_LAST_PLUS_1 : 
INTERFACE_LANGUAGE : 
LESS_THAN_DURATION : 
LESS_THAN_DURATION_BASE_FIRST : 
LINE_TERMINATOR ; 
LOW_PRIORITy : 
MACHINE CODE STATEMENT : 


INCLUDE ("B28006E1.ADA") 
-32768 

32767 

32768 
ASM86 
-75_000.0 
-131_073.0 
ASCII.CR 

0 


MACHINE_CODE_TyPE 
MANTISSA DOC 


MACHINE_INSTRUCTION' (NONE,m_NOP) ; 
: REGISTERTypE 
: 31 


A-2 














MAX_DIGITS 
MAX_INT 
MAX_INT_PLUS_1 
MIN_INT 
NAHE 

NAME_LIST 

NAME_SPECIFICATI0N1 

DISK$AWC 2 
NAME_SPECIFICATI0N2 

DISK$AWC 2 
NAME_SPECIFICATI0N3 

DISK$AWC_2 
IIE6_BASED_IIIT 
NEW_MEM_SIZE 
MEW_STOR_UNIT 
NEW_SYS_NAME 
PA6E_TERNINAT0R 
RECORp_DEFINITION 
R£CORD_NAME 
TASK_SIZE 
TASK_ST0RA6E_SIZE 
TICK 

VARIABLE.ADDRESS 
VARIABLE_ADDRESS1 
VARIABLE_ADDRESS2 
YOUR PRAGMA 


15 

2147483647 

2147483648 

-2147483648 

SHORT_SHORT_INTEGER 

IAPX186 


:_2: [CROCKETTL.ACVCll. DEVELOPMENT] X212OA 

:_2:[CROCKETTL.ACVCll.DEVELOPMENT]X2120B 

« 

• 

[ CROCKETTL.ACVCll. DEVELOPMENT] X3119A 
16#FFFPFFFF# 

1_048_576 
16 

IAPX186 
ASCII.FF 

RECORD NULL;END RECORD; 
NO_SUCH_MACHINE_CODE_TYPE 
16 

1024 

0.000_000_125 
(16#0#,16#1FF9#) 
(16#4#,16#1FF9#) 
(16#8#,16#1FF9#) 

EXPORT OBJECT 


j 

I 

1 


A-3 









APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 


B-1 









5 THE ADA COMPILER 


The Ada Compiler compiles all program units within the qiecified source Hie and inserts the 
generated objects into the currem program library. Compiler options are provided to allow the 
user control of optimization, nm-time checks, and compiler input and output options such as list 
(lies, configuration files, the program library used, etc. 

The input to the compiler consists of the source file, the configuration file (which controls the 
format of the list file), and the compiler options. Section S.l provides a list of aU compiler 
options, and Section 52 describes the source and configuration files. 

If any diagnostic messages ate produced during the compilation, they are output on the diagnostic 
file and on the current output file. The diagnostic file and the diagnostic messages ate described 
in Section S.3.2. 

Ou^t consists of an objea placed in the program library, diagnostic messages, and optional 
listings. The configuration file and the compiler opdtms specify the format and contents of the 
list ittfbrmadon. Output is described in Section S.3. 

The compiler uses a program library during the compilation. The compilation unit may refer to 
units from the program library, and an internal representation of the compilation unit will be 
included in the program library as a result of a successful compilation. The program library is 
described in Qtapter 3. Section 3.4 briefly describes how the Ada compiler uses the library. 


5.1 Invoking the Ada Compiler 

Invoke the Ada compiler with the following command to the SunOS shell: 

$ ada {<option>} <source-flIe'natne> 
where the options and parameters ate: 


35 









DACS-80X86 User's Guide 
Ada Compiler 


OPTION 

DESCRIPTION REFERENCE 

•[rwlautojnline 

Specifies whether local subprograms should be 
inline expanded. 

5.1.1 

-■-■ 

•cmck 

Controls run-time cnedcs. 

5.1.2 

•conflguration^flle 

Specifies the configuration file used by the 
coogiiler. 

5.1.3 

•[noKlebug 

Includes symbolic debugging information in 
program Ubrary. Does not include symbolic 
information. 

5.1.4 

•[no]flxpoiiit_rounding 

Generates fixed poim tourxUng code. Avoids fixed 
poim rounding code. 

5.1.5 

•[nolfloat allowed 

Flap generation of float instructkms as 

5.1.6 

•(noPlbrary 

error if selected. 

Speafies program library used. 

5.1.7 

•[nollist 

Writes a source listing on the list file. 

5.1.8 

•[no]optimiae 

Specifies compiler optimization. 

5.1.9 

•(rwjprofcss 

Dis|days comber progress. 

5.1.10 

•(no]xref 

Creates a cross reference listing. 

5.1.11 

•inojsavc_soarce 

Copies source to program library. 

5.1.12 

•(nojtarget^dcbug 

IrKludes Intel debug mformation. Does not include 
Intel debug information. 

5.1.13 

•unit 

Assigns a specific unit number to the compilation 
(must be frM and in a subiforary). 

5.1.14 

•recompile 

Interpret the file name as a compilation unit body 



that must be recompiled from library. 

5.1.15 

•specification 

With •recompile interpret file name as a 



compilation unit specification rather than body. 

5.1.16 


Examples: 

S ada -lia't tastprog 

This example compiles (he source file tcstprog^da and generates a list file with the name 
tcstprofJis. 

$ ada -libsaxy ay^llbxazy taat 

This example compiles the source file tcstada into the library my_librar 7 . 

Default values exist for most options as indicated in the following sections. Optkm names may 
be abbreviated (characters omitted from the right) as long as no ambiguity arises. 


36 









DACd*80x86 User's Guide 
Ada Ompiter 


<sottrce>file4UUiie> 

The Ada compiler has one mandatory parameter that ^uld specify the Ada source file. 

This parameter specifies the text file containing the source text to be compiled. If the flle type 
is omitted in the source file specificadoa the file type ".ada* is assumed by default 

The allowed format of the source text is described in Section S.2.1. 


Below follows a description of each of the avail^rle options to the invocation of the Ada 
compiler. 


5.1.1 •[no]auto_inline 

•auto_inliiie local | global 
•noai^^inlinc (default) 

This option specifies whether subprograms riiould be inline expanded. The inline expansion only 
occurs if the subprogram has less than 4 objea declarations and less than 6 statements, and if the 
subprogram fulfills the requirements defined for pra^a INLINE (see Section C.2.3). LOCAL 
specifies that only inline expansion of locally defined subprograms should be done, while 
GLOBAL will cause inline expansion of all sub^grams. including subprograms from other units. 


S.U -check 


•check { <kcyword> « ON | OFF { .<keyword> « ON | OFF } ] 
•check ALLsON (default) 


•check specifies which run-time chedts should be performed. Setting a run-time check to ON 
enables the chedt, while setting it to OFF disables the check. All nm-time checks are enatded by 
defoulL The following explicit checks will be disabled/enabied by using the name as <keywonl>: 


ACCESS 

ALL 

DISCRIMINANT 

ELABORATION 

INDEX 

LENGTH 

OVERFLOW 

RANGE 

STORAGE 


Check for access values being non NULL. 
All checks. 

Checks for discriminated fields. 

Checks for subprograms being daborated. 
Index check. 

Array length check. 

Explidt overflow checks. 

Chedts for values being in range. 

Checks for suffidem storage available. 


37 





DACS>803i 86 User's Guide 
Ada OMnpiler 


5.1J •CQnllfuraUoii_(Uc 


•configuratkni-file <filc-speo 
•eonflguration Jlie config (default) 

This option specifies the configuration file to be used by the compiler in the current cominlation. 
The configumum file allows the user to fonnat cooler listings, set error limits, etc. If the 
option is omitted the configuration file config located in the same directory as the Ada compiler 
is used by defuilL Section 522 contains a description of the configuration file. 


5.1.4 •[noldcbug 
-debug 

•nodebug (default) 

Generate debug information for the compilation and store the information in the program library. 
This is necessary if the unit is to be debugged with the DE)C-I Ada Symbolic Cross Debugger. 
Note that the program must also be linked with the -debug option, if the program is to be 
debugged with the DDC-I Ada Symbolic Cross Debugger. See Section 6.5.11. 


S.lJi -(no]flxpoint_rounding 

-flxpoint_rounding (defuilt) 

-noflxpoint.rounding 

Normally all inline generated code for fixed poim MULTIPLY and DIVIDE is rounded, but this 
may be avoided with -noflxpoint^rounding. Inline code is generated for all 16 bit fixed poiru 
types and for 32 bit fixed poim types, when the target is 80386PM or 80486PM. 


5.1.6 -(noinoat_alIowcd 

-lloat.allowcd (default) 

-nofloat^allowed 

Float instruction generation may be flagged as errors, if -nofloat is selected. This is for use in 
systems, where no floating poim processor (nor emulator) is available. Notice that TETCTJO uses 
floats in connection with FLOAT JO and FIXED JO. 


38 









DACS-80x 86 User’s Guide 
Ada Compiler 


5.1.7 ^brary 

•Htirary <lll»4peo 

•library $ada-library (default) 

This option specifies the cunent sublibrary that will be used in the compilatimi and will receive 
the objea when the compilation is complete. By specifying a cunent sublibrary, the current 
program library (current sublibrary and ancestors up to root) is also implicitly spedfied. 

If this option is omitted, the sublibrary designated by the environmental variable ada-library is 
used as the cunent suUibraty. Section 5.4 describes how the Ada compiler uses the library. 


5.U •[nollist 


•list 

•rwlist (default) 

•list specifies that a source listing will be produced. The source listing is written to the list file, 
which has the name of the source Ole with the extension Jis. Section 5.3.1.1 comains a description 
of the source listing. 

If •nolist is active, no source listing is produced, regardless of LIST pragmas in the program or 
diagnostic messages produced. 


5.U -optirttiae 

•optimize ( <keyword> s on | off { ,<keyword> s on | off} ] 

•optimize allsoff 

This option specifies which opiimizatitms will be performed during code generation. 'The possible 
keywords are: (casing is irrelevant) 


aU 

All possible optimizations are invoked. 

check 

Eliminates sup^fluous checks. 

cse 

Performs common subexpresskm elimination including common 
address expressions. 

fctlproc 

Change function calls returning objects of constrained array types 
or objects of record types to procedure calls. 

reordering 

Transforms named aggregates to positional aggregates and named 
parameter associations to positional associations. 

stack-height 

Performs stack hd^ reductions (also called Abo Ullman 
reordering). 

block 

Optimize block and call frames. 


Setting an optimization to on enables the optimization, while setting an optimization to off disaUes 
the optimization. All optimizations ate disaUed by de£uilL In addition to the optional 
optimizations, the compiler always performs the foUov^ optimizations: constam folding, dead 
code elimination, and selectfon of optiirtal jumps. 


39 






OACS*80x86 User’s Guide 
Ada Compiler 


5.1.10 •{no]progress 


•progress 

•noprogress (default) 

When this option is given, the compiler will output dau about which pass the compiler is 
currently tunning. 


5.1.11 •[no]xref 
-xref 

•noxref (default) 

A cross-reference listing can be requested by the user by means of the option ‘xref. If the -xref 
option is given and no severe or fatal errots are found during the compilation, the cross-reference 
listing is written to the list file. The cross-reference listing is described in Section ?. 


5.1.12 -(nolsave-source 

•save^source (default) 

•nosa^_aource 

When -save-source is spedfied. a copy of the comfriled source code is placed in the program 
library. If -nosave^suurce is used, source code will not be retained in the program library. 

Using •nosave-source. while helping to k'cp library sizes smaller, does affea the operation of 
the tecompiler, see Chapter 7 for more tSetails. Also, it will not be possible to do symbolic 
debugging at the Ada source code level with the DACS-80x86 Symbolic Ada Debugger, if the 
source code is not saved in the library. 


5.1.13 -[noltarget-debug 

-target_debug 
•notar^_debug (default) 

Specifies whether symbolic debug information on standard OMF is included in the objea file. 
Currently the linker does not siqiport the OMF debug information. 

This option may be used when debugging with standard OMF tools G-c.. PICE). 


40 








DACS*80x86 User’s Guide 
Ada Compiler 


5.U4 Minit 

•unit s <unit_nuinbcr> 

The specified unit number will be assigned to the compilation unit if it is free and it is a legal 
unit number for the library. 


S.1.15 'reconipile 
•rcctmipile 

'The file name (source) is interpreted as a compilation unit name which has its source saved from 
a previous compilation. If •spedflcation is not specified, it is assumed to be body which must be 
recompiled. 


5.1.16 •spedfication 
•specification 

Works only together with •recoR'piie. see Section S.1.15. 


52 Compiler Input 

Input to the compiler consists of the command line qHiims. a source text file and. optiortalJy. a 
co^guraiion file. 


5.2.1 Source Text 

The user submits one file containing a source text in each compilation. The source text may 
consist of one or more compilation units (see ARM Section 10.1). 

The format of the source text must be in ISO-FORMAT ASCn. This format requires that the 
source text is a sequence of ISO characters (ISO standard 646), where each line is terminated by 
either one of the following termination sequences (CR means carriage return, VT means vertical 
tabulation, LF means line feed, and FF means form feed): 

• A sequence of one or more CRs. where the sequence is neither immediately preceded nor 
immediately followed by any of the characters VT, LP. or FF. 

• Any of the duracters VT. LF, or FF, immediaiely preceded and followed by a sequence of zero 
or more CRs. 

In general, ISO control characters are not permitted in the source text with the following 
exceptions: 


41 







DACS*80x86 User’s Guide 
Ada Compiler 


• The horizontal tabulation (HT) character may be used as a separator between lexical units. 

• LF. VT. FF, and CR may be used to terminate lines, as described above. 

The maximum number of characters in an input line is determined by the contents of 
configuration file (see section S.1.3). The control charaaers CR. VT, LF, and FF are 
considered a pan of the line. Lines containing more than the maximum number of characters 
truncated and an error message is issued. 


5,12 Configuration File 

Certain processing characteristics of the compiler, such as format of input and output and error 
limit, may be modified by the user. These characteristics are passed to the compiler by means 
of a coi^gutation file, which is a standard SPARC/SunOS text fik. The contents of the 
configuration file must be an Ada positional aggregate, written on one line, of the type 
CONFIGURATION_RECORO, which is described below. 

The configuration file (config) is not accepted by the compiler in the foUowing cases: 

• The syntax does not confonn with the syntax for positional Ada aggregates. 

• A value is outside the ranges specified. 

• A value is not specified as a literal. 

• LINES_PER_PAGE is not greater than TOP_MARGIN + BOTTOM_MARGIN. 

• The aggregate occupies mote than one line. 

If the compiler is unable to accept the configuration file, an error message is written on the 
current output file and the compilation is terminated. 

This is the record whose values must appear in ^gregate fonn within the configuration file. The 
record declaration makes use of some other types (given below) for the sake of clarity. 


42 





DACS-80xg6 User’s Guide 
Ada Comi^er 


eyp« C0NFZ6URATX0M_REC0RD is 
record ” 

IN_rORMAT; INFORMATTING; 

OUT FORMAT: OUTFORMATTZNG; 

ERROR_LZMZT; INTEGER; 

•nd record; 

type INPUT_FORMATS is (ASCII); 

type INFORMATTING is 
record 

INPUT FORMAT: INPUT FORMATS; 

INPUT~LINELENGTH: INTEGER range 7Q..2S0; 
end record; 

type OUTFORMATTING is 
record 

X.INES_PER PAGE 
TOP MARGIN 
BOTTOM MARGIN 
OUT tlNELENGTH 
SUPPRESS_ERRORNO 
end record; 

The outformaoing parameteis have the following meaning; 

1) LINES.PER.PAGE: q)ecifies the maximum number of line whaen on each page 
(including top and bottom margin). 

2) TOP.MARGIN: spedlies the number of lines on top of each page used for a standard 
heading and blank lines. The heading is placed in the middle lines of the top margin. 

3) BOTTOM.MARGIN: specifies the minimum number of lines left blank in the bottom of 
the page. The number of lines available fm the listing of the program is LINES 
PER_PAGE - TOP_MARGIN - BOTTOM.MARGIN. 

4) OUT.UNELENGTH: spedftes the maximum number of characters written on each line. 
Lines longer than OUT.LINELENGTH are separated into two lines. 

5) SUPPRESS.ERRORNO: specifies the foimat of error messages (see Section S.3.S.1). 

The name of a user-supplied configuration file can be passed to the compiler through the 
conriguration_ftle optioa DDC-I supplies a default configuration ftle (config) with the foUowing 
content: 


INTEGER range 30..100 
INTEGER range 4.. 90 
INTEGER range 0.. 90 
INTEGER range 80..132 
BOOLEAN; 


43 








DACS*80x86 User's Guide 
Ada Compiler 


((ASCn. 126). (48.53.100JALSE). 200) 


Top 

Mtptn 




LXumu 

pag* 


Bottoa 

■argin 





Outjine.length 


Figure 5-1. Page Layout 


5 J Compiler Output 

The compiler may produce output in the list file, the diagnostic file, and the cunent output file. 
It also updates the program library if the compilation is successful The presem section describes 
the text output in the three files mentioned above. The updating of the program library is 
described in Section 5.4. 


The compiler may produce the following text output: 

1) A listing of the source text with embedded diagnostic messages is written on the list file, 
if the option 'ilst is active. 

2) A compilation summary is written on the list file, if •list is active. 

3) A cross-reference listing is written on the list file, if -xref is active and no severe or fatal 
errors have been detected during the compilatitm. 

4) If there are any dii^nostic messages, a diagnostic file containing the diagnostic messages 
is wrineiL 

5) Diagnostic messages other than warnings ate written on the current output file. 


44 









DACS*80x86 User’s Guide 
Ada Compiler 


5J.1 The List FOe 

The name of the list file is identical to the name of the source file except that it has the file type 
".lis". The file is located in the current (default) directory. If any such file exists pilor to the 
compilation, the newest version of the file is deleted. If the user requests any listings by 
specifyirtg the options 'list or 'Sref. a new list file is created. 

The list file may include one or more of the following parts; a source listing, a cross-reference 
listing, and a compilation summary. 

The parts of the list file are separated by page ejects. Hie contents of each part are described in 
the following sections. 

The format of the output on the list file is controlled by the configuration file (see Section 522 ) 
and may therefore be controlled by the user. 


5J.1.1 Source Listing 

A source listing is an unmodified copy of the source text The listing is divided into pages and 
each line is supplied with a line number. 

The number of lines output in the source listing is governed by the occurrence of LIST pragmas 
and the number of objectionaUe lines. 

• Parts of the listing can be suppressed by the use of the LIST pragma. 

• A line containing a construa that caused a diagnostic message to be produced is printed even 
if it occurs at a point where listing has been supprosed by a LIST pragma. 


5J.1,2 Compilation Summary 

At the end of a compilation, the compiler produces a summary that is output on the list file if the 
option -list is active. 

The summary contains information about: 

1) The type and name of the compilation unit, and whether it has been compiled successfully 
or not 

2) The mimber of diagno;^Iic messages produced far each class of severity (see Section 
5.32.1). 

3) Which options were active. 

4) The fiiQ name of the source file. 

5) The full name of the cunem sublibraiy. 

6) The number of source text lines. 


45 






DACS-80X86 User's Guide 
Ada Compiler 


7) The size of the code produced (specified in bytes). 

8) Elapsed teal time and elapsed CPU time. 

9) A "Compilation lenninaied" message if the compilation unit was the last in the compilation 
or "Compilation of next unit initiated" otherwise. 


5 J.U Crosi*RcfcrenGe Listing 

A cross-reference listing is an alphabetically sorted list of the idendlieis. operators, and character 
literals of a compilation unit The list has an entry for each entity declared and/or used in the 
unit, with a fisw exceptions stated below. Overloading is evidenced by the occuirence of multiple 
entries for the same identifier. 

Fbr instantiations of generic units, the visible declaradmis of the generic unit are included in the 
cross-reference listing as declared immediately after the instantiation. The visible declarations are 
the subprogram paiameten for a generic subprogr a m and the declarations of the visible pan of the 
package declaration for a generic package. 

For type declarations, all implicitly declared operations are included in the cross-reference listing. 

Cross-reference information will be produced for every constituent character literal for string 
literals. 

The following are not included in the cross reference listing: 

• Pragma identiflers and pragma argumem identifiers. 

• Numeric literals. 

• Record component identifiers and discriminant ideruifiers. FOr a selected name whose selector 
denotes a record componem or a discriminant, only the prefix generates cross-reference 
information. 

• A parem unit name (following the keyword SEPARATE). 


Each enny in the cross-reference listing contains: 

• The ideniirier with, at most. IS characters. If the identifier exceeds IS characters, a bar ("P) 
is written in the 16th position and the rest of the dtaractets are not printed. 

• The plan of the definition. Le.. a line number if the entity is declared in the cuirem 
compilation unit, otherwise the name of the comirilatian unit in which the entity is declared 
and the line number of the declaration. 

• The numbers of the lines in which the entity is used. An asterisk f*") after a line mimber 
indicates an assignmem to a variable, initialization of a constant, assignmems to functions, or 
user-defined operaton by means of RETURN statements. Please refer to Appendix B.3 for 
examples. 


46 









DACS-80k 86 User’s Guide 
Ada compiler 


5JJ The Diagnostic File 

The name of the diagnostic nie is identical to the name of the source Hie except that it has the 
file type ".err”. It is located in the cunent (default) directory. If any such file exists prior to the 
comi^laiion. the newest version of the file is deleted. If any diagnostic messages are produced 
duri^ the compilation a new diagnostic file is created. 

The diagnostic file is a text file containing a list of diagnostic messages, each followed by a line 
showing the number of the line in the source text causing the message, and a blank line. There 
is no separation iruo pages and no headings. The file may be used by an interactive editor to 
show the diagnostic messages together with the erroneous source text 


5J.2J Diagnostic Messages 

The Ada compiler issues diagnostic messages on the diagnostic file. Diagnostics other than 
warnings also appear on the current output file. If a source text listing is required, the diagnostics 
are also found embedded in the list file (see Section S.3.1). 

In a source listing, a diagnostic message is placed immediately after the source line causing the 
message. Messages not related to ^ particular line are plat^ at the top of the listing. Every 
diagnostic message in the diagnostic file is followed by a line stating the line number of the 
objecdonal line. The lines ate ordered by increasing source line numbers. Line number 0 is 
assigned to messages not related to any particular line. On the currem output file the messages 
appear in the order in which they ate genemed by the compiler. 

The diagnostic messages ate classified according to their severity and the compiler action taken: 


Warning: Reports a questionable construa or an error that does not influence the meaning of the 
program. Warnings do not hinder the generation of object code. 

Example: A warning will be issued fm constructs for which the compiler detects will 
raise CONSTRAlNT_ERROR at nm time. 


Error Reports an illegal construct in the source program. Compilation continues, but no object 
code will be generated. 

Examples: most syntax errors; most static semantic errors. 


Severe Reports an error which causes the compilation to be terminated immediately, 
error. Mb objea code is ge n erated. 

Example: A severe error message will be issued if a library unit mentioned by a 
WITH clause is not presem in the currem program library. 


47 








DACS-80X86 User’s Guide 
Ada Compiler 




Fatal Reports an error in (he compiler sysmm itself. Compilation is terminated immediately 

error and no objea code is produced. The user may be aUe to ciroimvem a fatal error by 

correcting the program or by replacing program constructs with alternatives. Please 
inform DDC-I about the occurrence of fatal errors. 


The detection of mote errors thn allowed by the number specified by the ERROR_LJMIT 
parameter of the configuration file (see section 522 ) is considered a severe error. 


5222 Format and Contcm of Diaghostk Messages 

For certain syntactically incorrea consmtos. the diagnostic message consists of a pointer line md 
a text line. In other cases a diagnostic message consists of a text line only. 

The pointer line contains a poiner (a carat symbol to the offending symbol or to an illegal 
character. 

The text line contains the following information: 

• the diagnostic message identification '‘• * ***‘‘ 

• the message code XY-Z where 

X is the message number 

Y is the severity code, a letter showing the severity of the error. 

W: warning 
E: error 
S: severe error 
F: fatal error 

Z is an integer which, together with the message number X, uniqudy identifies the compiler 
location that generated the diagnostic message; Z is of importance mainly to the compiler 
maintenance team - it does not contain infotmadon of interest to the compiler user. 

The message code (with the exception of the severity code) will be su p pre sse d if the 
parameter SUPPRESS.ERRORJ^O in the configurai^ file has the value TRUE (see 
section 522 ). 

• the message text: the text may include one comext dependent field that contains the name of 
the offent^ symbol: if the name of the offending symbol is longer than 16 characters only 
the first 16 characters are showrt 

Exanqiles of diagnostic messages: 

18N-3: Naening: Exception CONSTKAZNTJEiUtOlt will be raised here 
**■ 320E-2: Nam OBJ does not denote a type 

*** 53SE-0: Expression in return statemnt sdssing 


48 









DACS-80x86 User's Guide 
Ada Compiler 


•• 

*** 1508S-0: Specification for this package body not present in the library 


5.4 The Program Library 

This section briefly describes how the Ada compiler changes the program library. For a mote 
general description of the progiam library, the user is referred to Chapin 3. 

The cmnpiler is allowed to read ftom all subllbraries constituting the current program library, but 
(mly the current suUibrary may be changed. 


5.4.1 Correct Compilations 

In the following examples it is assumed that the compilation units are correctly compiled, i.e.. that 
no errors are detected by the compiler. 


Compilation of a library unit which is a dedaratkm 

If a declaration unit of the same name exists in the currem sublibrary, it is deleted together with 
its body unit and possible subunits. A new dedaradon unit is insetted in the suUibrary. together 
with an empty body unit. 

Compilation of a library unit which is a subprogram body 

A subprogram body in a compilation unit is treated as a secondary unit if the current subiibrai^ 
contains a subprogram declaration or a generic subprogram declaration of the same name and this 
declaration unit is not invalid. In aU other cases it will be treated as a library iniL i.e.: 

• when there is no library unit of that name 

• when there is an invalid declaration unit of that name 

• when there is a package declaration, generic package declaration, an instantiated package, or 
subprogram of that name 


Compilation of a library unit which is an instantiation 

A possiUe existing declaration unit of that name in the current sublibtary is deleted together with 
its body imit and possible subunits. A new declaration unit is inserted. 


Compilation of a secondary unit which is a library unit body 

The existing body is deleted from the subUbrary together with its possible subunits. A new body 
unit is inserted. 


49 








DACS'80x86 User's Guide 
Ada Compiler 


Compilation of a secondary unit which is a subunit 

If the subunit exists in the subiibrary it is deleted together with its possible subunits. A new 
subunit is insened. 


5.4J Incorrect Compilations 

If the compiler detects an error in a compilation unit, the program library will remain unchanged. 

Note that if a file consists of several compilation units and an error is detected in any of these 
compilation uniis. the program library will not be updated for any of the compilation units. 


Instantiation of Generic Units 

This section describes the rules after which generic instantiation is performed. 


5 J.1 Order of Compilation 

When instantiating a gerteric unit, it is requited that the entire unit, including body and possiUe 
subunits, be compiled before the first instantiation. This is in accordance with the ARM Chapter 
10.3 (1). 


SJJ Generic Formal Private Types 

The present section describes the treatmem of a generic unit with a generic fonnal private type, 
where there is some construa in the generic unit thm requires that the coti es pon d ing actual 
must be constrained if it is an array type or a type with discriminants, and there exists 
instantiations with such an unconstrained t]^ (see ARM. Section 12.3.2(4)). This is considered 
an illegal combination. In some cases the error is detected when the instantiation is compiled, in 
other cases when a constraint-requiring construa of the genetic unit is compiled: 

1) If the instantiation appears in a later compilation unit than the first consiraim-ieqmting 
construa of the generic unit, the error is associated with the instantiation which is rejected 
by the compiler. 

2) If the instantiation appears in the same compilmion unit as the first constraim-requiring 
construction of the generic unit, there are two possibilities: 

a) If there is a constraim-requiring constructioo of the generic unit after the instantiation, 
an error message appears with the instantiaiiofL 

b) If the instandmion appears after all constraim requiting constructs of the generic unit 
in that compilation unit, an error message appears with the constraim-requirir^ 
construct, but will refer to the illegal instamiatioa 


SO 







OACS*80x 86 User’s Guide 
Ada Compiler 


3) The instamiaiion appean in an earlier compUadon unit than the ffist constraint-requiring 
construction of the generic unit, which in that case will appear in the generic body or a 
subuniL If the instandatiQn has been accepted, the instantiation will correspond to the 
generic declaration only, and not include the body. Nevenheless, if the generic unit and 
the instantiation ate located in the same sublibrary, then the compiler will consider it an 
error. An error message will be issued with the constrairu-requiring consttua and will refer 
to the illegal instaniiatian. The unit containing the instandaiion is not changed, however, 
and will not be marked as invalid. 


5.6 Uninitialized Variables 

Use of uninitialized variables is not flagged by the compiler. The effect of a inogram that refers 
to the value of an uninitialized variable is undefined. A cross-reference listing may help to find 
uttinitialized variables. 


5.7 Program Structure and Compilation Issues 

The following limitations apply to the OACS-80x86 Ada Compiler Systems for the Real Address 

Mode and 286 protected mode only: 

• The Ada compiler supports a "modified memory model for dau references. The 

"modified large" memory model associates one dau segmem for each hierarchical sublibrary in 
the Ada program libr^. All package dau declared within a sublibraty is efficiently referenced 
from Ada code compiled into the same sublibrary. A slight increase in code size results from 
referencing package dau compiled into a different hierarchical level. Intel’s medium memory 
model can thus be obtained by utilizing only one level of Ada program library, the toot 
sublibrary. 

• The Ada compiler supports a large memory model for executable code. Although the size of 
a single complation unit is restricted to 32K words, the total size of the code portion of a 
program is tx>t restricted. 

• The space available for the static dau of a compilation unit is 64K • 20 bytes. 

• TIk space available for the code generated for a compilation unit is limited to 32K words. 

• Any single objea cannot exceed 64K - 20 bytes. 

The following limitations ap|riy to all DACS-80x86 products: 

• Each source file can contain, at most, 32,767 lines of code. 

• ’The name of compilation units and identifiets may not exceed the number of characters given 
in the INPUT_LINELENGTH parameter of the configuration file. 

• An imeger literal may not exceed the range of LONQ.INTECER. a teal literal may not exceed 
the range of LONG.FLOAT. 


51 



DACS>80x86 User's Guiite 
Ada Gxnpiler 


• Tile number of fonnal parameters penniited in a procedure is limited to 127 per parameter 
qiedficadon. There is no limit on the number of procedure specifications. For example, the 
dedaniion: 

procedure OVER LIMIT (INTEGEROl, 

” INTEGER02, 

INTEGER166: in INTEGER); 

exceeds the limit, but the procedure can be accmnplished with the following: 

procedure UNDER LIMIT (INTEGEROl : in INTEGER; 

INTEGER02 : in INTEGER; 

INTEGER166 : in INTEGER); 

The above limitations are diagnosed by the compiler. In practice these limitadmis are seldom 
restrictive and may easily be circumvent^ by using subunits, separate compilation, or creating new 
sublibraries. 


5.8 Compiler Code Optimizations 

DDC-I’s Ada compiler for the iAPX 80x86 microprocessor funily generates compao, efficient 
code. This efficiency is achieved, in part, by the cmnpiler’s global optimizer. Optimizations 
perfonned include: 

• Common sub-expression elimination 

• Elimination of redundam constraint checks 

• Elimination of redundam elaboration checks 

• Constam folding 

• Dead code elimination 

• Optimal register allocation 

• Selection of optimal jumps 

• Optional run-time check suppression 


52 







LINKER OPTIONS 


The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker documentation and 
not to this report. 


B-2 











6 THE ADA LINKER 


The DACS linker must be executed to create an executable program in the target environment 
Linking is a two stage process that includes an Ada link using the compilation units in the Ada 
program library, and a target link to integrate the application code, run-time code, atxl any 
additional conflguration code developed by the user. The linker performs these two suges with a 
single command, providing options for controlling both the Ada and targm link processes. 

This chapter describes the link process, except for those options that configure the Run-Time 
System, which is described in detail in Oiapier 7. 


6.1 Invoking the Linker 

Enter the following command at the shell to invoke the linker 
S ada-link {<option>} <unit-name> 
where the options and parameiers are: 

Ada Linker Options 


OPTION DESCRIPTION REFERENCE 


•[noldebug Links an application for use with the 6.S.11 

DACS-80x86 Symbolic Cross Debugger. 

•«nablc_task_trace Enables trace when a task terminates in 6.528 

unhandled exception. 

•cxccpth>n_space Defines area for exception handling in task stack. 6.529 

•[no]extrad Extracts Ada Objea modules 6J.14 

-interrupt_enU 7 _table Range of interrupt entries. 6.5.27 

•library ~ The library used in the link. 6.5.7 

•[nojiog Specifies creation of a log file. 6.5.9 

•lt_seginent_size Library task default segment size. 6.523 

•lt~st^_siaie Library task default stack size. 6.522 

•inp_seginent_size Main program segment size. 6J.25 

•rop~st^_size Main program stack size. 6J24 

•(nolhpx ~ Use of the 80x87 numeric coprocessor. 6.5.16 

-options Specifies target link options. 6.5.6 

•priority De^t task priority. 6.5.18 

•reserve_stack Size of reserve stack. 6J21 

•tins Select Rate Monoionic Scheduling Run-Time 6.5.13 

Kernel (optional). 

•[no}root_ectract Using nrm-DDC-I units in the root lilnary. 6J.10 


53 





DACS-80X86 User’s Guide 
The Ada Linker 


•(no]rts 

Includes or excludes the nm-time system. 

6.5.12 

•seaiehiib 

Target libraries or objea modules to include 
in target link. 

6.5.4 

•selectivcJink 

Removes uncalled code from final program. 

6.5.8 

•aign_on 

Produce sign on and sign off messages. 

6.5.30 

•stopibcfore-link 

Performs Ada link only. 

6.5.5 

•tasks 

Maximum number of tasks or non-tasking 
appiicadon. 

6.5.17 

•Usk_storage_size 

Tasks default storage size. 

6.526 

•template 

Specifies template file. 

6.5.15 

•timer 

Tuner resolution. 

6.520 

•time_slice 

Task time slicing. 

6.5.19 


All options may be abbreviated (characters omitted from the right) as long as no ambiguity arises. 
Casing is significant for options but not for options keywords. 

Note: Several simultaneous links of the same program should not be performed in the same 
direaory. 


6.1.1 Diagnostic Messages 

Diagnostic messages from the Ada Linker are output on the curient output file and on the optional 
log file. The messages ate output in the order they are generated by the linker. 

The linker may issue two kinds of diagnostic messages: warnings and severe errors. 

A warning repons something which does not prevent a successful linking, but which might be an 
error. A warning is issued if there is something wrong with the body unit of a program unit 
which formally does not need a body unit. e.g. if the body unit is invalid or if there is no objea 
code container for the body unit. Warnings ate only output on the log file, not on the current 
output file. The linking summary on the log file will contain the total number of warnings issued, 
even if the issued warnings have ix>t been output. 

A severe error message reports an error which prevents a successful linking. Any inconsistency 
detected by the linker wiU, for instance, cause a severe error message, e.g. if some required unit 
does not exist in the library or if some time stamps do not agree. If the linker is used for 
consequence examination, all inconsistencies introduced by the hypothetical recompilations ate . 
reported as errors. 

A unit not marlced as invalid in the program library may be repotted as being invalid by the 
linker if there is something wrong with the unit itself or with some of the units it depetxis oa 


62 The Linking Pi’ocess 

The linking process can be viewed as two consecutive processes. Both ate autmnatically carried 
out when issuing the link commatxl adaJink. 


54 








DACS-80x86 User’s Guide 
Tlx Ada Linker 


The fiist process constioites the Ada link process and the second ctmstitutes the target link 
process. 

The Ada link process 

• retrieves the required Ada objea modules from the program library, 

• dexrmines an elaboration order for all Ada units. 

• creates a module comaining the User Configurable Data (UCD) from the specified configuiaiion 
options to the linker and 

• creates a shell script that carries out the target link process (i.e.. dlnkbldx86). The locate/build 
phase is an integral pan of the target link. 


If the option •stop-before-link is NOT qxcified (default), the above script is executed 
automaticaUy. Otherwise the linking process is halted at this point. 

When •stop.bcforeJink is specified, all xmporary files are retrieved for inspection or 
modification. The target linker is invoked by executing the shell script. 


6.2.1 Temporary Files 

The following temporary files are in use during the link phase: 

<main^rogram>.link.com The shell script which invokes the target linker. 

<main_progTam>_elabcode.o The objea code for the calling sequence of the elaboration 

code. 

<main_progTam>_ucd.o The objea code generated from the RTS configuration 

options (see Section 7.2). 

<main_program>_uxxxxx.o The Ada objea modules which have been extracted from the 

program library, xxxxx is the unit number of the Ada unit 


55 






DACS-80I186 User's Guide 
The Ada Linker 



Figure 6-3. The Linking Process 


The following components make up the run-dme system: 

1) User configurable portion of the RTS 

a) User configurable data (UCD) and 

b) User configurable code (UCQ 

2) Pennanem pan of the RTS 

a) Non-tasking RTS (rl 1 Jib) or 

b) Tasking RTS (rl2Jib) 

c) RMS Tasking RTS (rl3Jib) 

The User Configurable Cbde defined by the envirtmmemal variable ada_uccjib is included in the 
link. If no tasking has been specified, then the RTS non-tasking libraiy~(rllJib) will be included. 
If taricing has been specified, then suppon for tasking will be included (rl2Jib or, when -rms, 
rl3.Ub). 


36 








DACS-80x86 User’s Guide 
The Ada Linker 


The output of the linker step is an absolute executable object file with the extension ".dat" and 
a map file with the extension ".mpS". 


6.12 Environmental Variables 

When a link is executed, a number of files are tefened to and most are accessed through 
environmental variaUes. The locateAxiild phase uses the control file Sada_ucc.dir/config.bld_ddci, 
the remaining variables are: 


VARIABLE 

PURPOSE 

ada_system_Ubrary 

Identifies the root library where the system compilation units reside. 

adajibrary 

Identifies the default library used by all DACS-80x86 tools. It is the 
lowest level sublibrary in the program library hierarchy. 

ada_rootJib 

Identifies the OMF library where the system library units have been 
extracted horn the system library. By having a separate Library for the 
root compilation units, the link process is much faster than otherwise 
having to extract each unit from the system library for each link. 

ada_rll_lib 

Idendhes the OMF library for the Permanem Part of the non-tasking 
version of the Run-Time System. 

ada_rl2Jib 

Idendfies the OMF library for the Pennanent Part of the tasking version 
of the Run-Tune System. 

ada_rl3_lib 

Identifies the OMF library for the Permanent Part of the optional Rate 
Monotonic scheduling Run-Tune System. 

ada.cccjib 

Identifies the OMF library for the User Configurable Code portion of 
the Run-Time System. 

ada-template 

Identifies the template file for the Linker. 

ada_ucc-dir 

Idendfies the directory of the currem UCC. 


With each of these environmental variables, the name will differ depending on how the system 
was installed (ada86, adal86 etc). Throu^ut this documem ada is assumed. For example, the 
environmental variables for the root library for the 80186 version of the compiler would be 
adal86_root_lib, and the RTS UCC library environmental variaUes for the 8086 veisicm would 
be ada86_iioc_lib. 


57 










DACS>80x86 User's Guide 
The Ada Linker 


63 Run'Time System Overview 

The Run-Time System for DACS-8Qx86 is defined as all code and data, other than the code and 
dau produced by the code generator, required to make an embedded system application operate 
properly on a specific hardware system. 

In general, there are two major components that make up the Run-Tmw System. 

1) Code and dau assumed to exist by the code generator. This is hardware independoit and 
known as the RTS Permanent Part 

2) Code and dau tailoring the application with respect to the characteristics of the hardware 
and other requirements of the embedded systems developer. This code is called the RTS 
User Configurable Part 

Both of the above componems ctmsist of modular OMF libraries. The modules are only included 
in the user program if they are needed. i.e.. if a call or reference is made to the module. This 
ensures a compact RTS (typical applications are 4 KB to 10 KB). 

The RTS Permanem Part does not make any assumptions about the hardware other than an 80x86 
and some amount of memory available. 

There are several versions of the RTS User Configurable Part available for difierent development 
targets. Also, the source code is provided to allow the modification of the User Configunble 
Code (UCC) to operate on other utgeu. Refer to the RTS Configuration Guide for complete 
information on minifying the UCC. 

DDC-I has carefiiUy analyzed and selected the parts of the Run-Time System that must be 
configurable for hardware independence, freeing the user from major rewrites whenever the 
Run-Time System is retargeted while, still allowing for almost unlimited adaptability. 

Four important features of the run-time system are: 

• It is small 

• It is completely ROMable 

• It is configurable 

• It is efiicient 


Ctmceptually. an Ada run-dme system can be viewed as consisting of the following comptmeus: 

• Executive. i.e.. the start-up mechanism 

• Storage Management 

• Tasking Management 

• Input/Output 

• Excqxion Handling 


58 






DACS>80x86 User’s Guide 
The Ada Linker 


• Run-Time Library Routines 

• Package CALENDAR support routines 


The tun-time system (RTS) can be configured by the user through Ada Linker command options. 
The Ada Linker will generate appropriate dau structures to represem the configured characteristics 
(UCD). 

Two verskms of the RTS are supfdied. one includii^ tasking and one excluding tasking. The 
linker selects the RTS veiskm including tasking only if the opdon -tasks is piesem or -tasks n 
is ptesem and n > 0. Otherwise, the linker selects the R'TS vetsim excluding tasking. 


6.4 Linker Elaboration Order 

The elatoration order is pimarily given by the unit dependencies, but this leaves some freedom 
here arxl there to aibitrarily choose between two or more alternatives. ‘This arbitrary is in the 
DACS-80x86 linker controUed by the spelling of the involved library units, in order for "free" 
units to become alphabetically sotted. 

Recompiling from scratch, an entire system may thus zfteci the allocation of unit numbeis, but the 
elaboration order remains the same. 

It is also anempted to elaborate "body after body", so that a body having a with to a specification, 
will be attempted elaborated (tfter the body of this specification. 

Also elaboration of units from different library levels is anempted to complete elaboration of a 
father-level prior to the son-leveL 

This strategy should in many cases reduce the need for resetting pragma ELABORA’TE. 


Ada Linker Options 

‘This section describes in detail the Ada linker opion aid parameters. 


63.1 The Parameter <unit-naiiie> 

<unit-naine> 

The <unit_name> must be a library unit in the cutrem program library, but not necessarily of the 
current sublibrary. 

Note that a main program must be a procedure without parameters, and that <unit-nane> is the 
identifier of the procedure, not a file specification, liie main procedure is not disced for 
parameters, but the execution of a program with a main procedure with parameters is undefined. 


59 






DACS>80x86 User’s Guide 
The Ade Linker 


&S J The Pii^metcr <reco mp ilation-spco 
The syntax of <rccompilation*spco is: 

<unit_spco[<body|<spedflcation](^] 

This paruneter tells the linker to perfom a consistency check of the entire program using the 
hypodietical recompilation of all units designated in the <recompilation-spec>. Tlie link process 
in this instance is not actuaUy p erfo n ned. 

The <unit_speo is a list of umt-names (wildcards are allowed), separated by comma (.) or plus 
(•f). Each unit-name should include an option to tnd«c»»^ if the body or specification is to be 
hypothetically compiled (-spec is the default). 


6JJ Required Recompilations 

If the consistency check found that recompilations are required, a list of required recompilations 
is written to the cuirem ouput file or to a text file if the -log option is qtedfied (the name of 
the text file is indicated in the log file, line 8). The list will include any inconsistencies detected 
in the library and recompilations required by the hypothetical recompilations specified with the 
options -declaration and -body. 

The entries in the list contain: 

1) The unit name. 

2) Indication of what type of unit (declaration unit, body unit, or subunit). 

3) If the unit is specified as recompiled with the -declaration or -body option, it is marked 
with "-R-". 

4) The environmental variable of the subiibrary containing the unit. 

In the recmnpilation list the units are listed in a recommended recompilation order, consistem with 
the dependencies among the units. 


<L5.4 -scarchlib 

•aearchlib <fUc_name> {,<flle,jianie>} 

The -scarchlib option directs the Ada Linker to search the specified 80x86 target libraries for 
objea modules in order to resolve symbol references. The 80x86 target libraries for otgea files 
will be searched before the DAGS Run-Ume System (RTS) library normally searches for run-dme 
routiner, in this way one can replace the standard DACS RTS routines wife custom roudnes. 

The -aear chlib option is also intended to specify libraries of modules referenced fiom Ada via 
pragma INTERFACE 


60 






DACS-80x86 User's Guide 
Tile Ada Linker 


Examples: 

$ adaJink •seardUib interfbcc^Ub p 

Links the su b program p. resolving referenced symbols fiist with the target library interface.lib 
and then with the standard RTS target library. 


6JJ •stopJrclbrcJUiik 


•stop^bclbrc^link 

The •stop.bcforejink option allows the user to introduce assemblers and linkers from third 
parties orlo othnwise configure the link to suit the application. The link is halted with the 
following conditions: 

lie user omfigurable dau file. <main>-ucd.o. is produced with the default or user specified 
inker option values included. 

• The ddioration code is contained in the <main>_eld)Code.o file. 

• The shell script file that contains the link commreid is present and has not been executed. The 
file’s name is <main>_link.com. 

• The temporary Ada object file(s) used by the target linker are produced. These objects are 
linked arid ddeted when <main> Jink.com is executed. 

• With ’Sdectivc^link the objea files comprise all Ada units indudtng those fiom the root 
library. At this poim it is possible to disasaemUe the "cut” object files using -objea with the 
disassemtder. 

To comidete the link, the <main>-link.com script must be exec u ted. To use third patty tools, this 
file may have to be modified. 


6J^ -options 
•options <paraiiietcr> 

•options allow the user to pass options onto the targa linker. 


61 




DACS-80x86 User’s Guide 
Riuv-Tliae Systtm 


6J.7 •Ubrar; 

•Ubrtry <fllc-iiaiae> 

•ttbrary SadeJibrary (deteilt) 

The 'Ubrary opdon specifies the current sublibnry. frem which the linking of the main unit will 
take place. If this option is not specified, the sublibniy specified by the environmental variable 
ada Jibrary is used. 


dJJ •aelcetive_liiik 
•sriecdveJUiik 


This extracts all required objea modules from die Ada library (including the root library) and cuts 
out exactly those parts that art actually called, in order to make the resulting target program 
considerably smaller. If a program uses e.g. PUT.L1NE as the only routine from TEXT JO, the 
contribution fiom the TEXT JO objea module will orriy contain PUT_L1NE (and whatever that 
needs). Note that disassemblies of units used in a sdective link normally will not match what is 
linked, because of the cutting. Such disassemblies may though be obtained by disassembling 
directly those units that made up the selective link, by stopping the linking before the targa link 
phase (•stop^beforejink), making disassemblies using •object and then resuming the link. 

Note also that unused constants and pennanem variables are not removed. 

Only "level 1" subprogr a ms may be removed. Nested subprograms (that are not called) ate to be 
removed during compilaiion using the •optimlxc optkm. Nested subprograms are only removed, 
if the routine in which the nesting occurs is removed. 


6JS3 •(nollog 

•log [<fllc^spco] 

•nolog (default) 

The option specifies if a log file will be produced from the from end linker. As default, no log 
file is piodui^ If cfile-speo is not entered with -log the default file name for the log file will 
be linkJog in the cunem directory. 

The log file contains extensive information on the results of the link. The file includes: 

• An elaboration order list with an entry for each imit included, showing the order in which the 
uniu will be elaborated. For each unit, the unit type, the time stamp, nd the dependencies are 
shown. Furthamote. any elaboration inconsistendes will be rqxm^ 

• A linking summary wid; the foDowing information: 

• Parameters and active options. 

• The fill! name of the program library (the cunem sublibrary and its ancestor suUibraries). 


62 




DACS*80x86 User's Guide 
Tbe Ada Linker 


• The number of each type of diagnosnc message. 

• A termination message, stating if die Unking was terminated successfiiUy or unsuccessfuUy or 
if a consequence examination was terminated. 

• Diagnostic messages and warnings are written on the log file. 


If recompilations are required (as a result of the consistency check) a text file is produced 
containing excerpu of the log file. The name of this text file is written in the log file, line 8. 


The log file consists of: 

• Header consisting of the Unker name, the linker version number, and tbe Unk time. 

• The elaboration order of the compilation units. The units are displayed in the order elaborated 
with the unit number, compilation time, unit type, dependencies, and any Unking errors. 

• If recompilations are required, the units that must be recompUed are listed along with its unit 
type and subUbrary level 

> The linking summary that includes the main unit name, the program Ubrary, any recompilations 
that are re^iired, and if any errors or warnings occurred. 


6J.10 •(nolroot-.cxtract 
•root-extract 

•noroot^extract (default) 

The units contained in the Ada system Ubrary suppUed by DDC>I have been extracted aixl inserted 
into the $ada.root_lib OMF Library, thus eUminating extractions from tbe system Ubrary at link 
time and improving Unk performance. 

The user should notmaUy not modify or compile into the Ada system library supplied by DDC-I. 
If however, a unit is compUed into the Ada system library, the Sada.rootjib wiU no longer 
match the Ada system Ubrary and -root_extract must be specified in order to Unk fiom the Ada 
system Ubrary. 


&5.11 '[noldebug 
•debug 

•nodebug (default) 

The -debug option specifies that debug information is geiierated. The debug information 
required to enaUe symbolic debugging. If •nodebug is specified, the Ada Unker wiU skip 
generation of debug information, thus saving link Ume, and wUl not insert the debug informat 


63 


l^ts- 






DACS-80X86 User's Guide 
The Adi Linker 


imo the chosen sublibrary, thus saving disk space. Note that any unit which should be 
symbolically debugged with the DDC-1 Ada Symbolic Cross Debugger must also be compiled with 
the odebug option. 


6^.12 •{nolrts 

•rts (default) 

•norts 

The <111 option directs the Ada Linker to include the appropriate Run*Time System (RTS) in the 
link. *110113 directs the Ada Linker to exclude the RTS in the link. 

The ability to exclude the Run-Tune System from the link allows the user to do an additional link 
with a private copy of a custom RTS. The Ada Linker may tepon urutsolved references to RTS 
routines, but will still produce a relocatable objea file. 


6J.13 -rms 


•nns 

This option selects the Rate Monotontc Scheduling Tasking Kernel (if tasking is selected). The 
default is to use the Standard Tasking Kernel. This feature is suppli^ as an option. 


6l 5.]4 •[aojextract 

•extract (default) 

•nocxtract 

This option to the linker allows the user to specify that program unit objects should not be 
extracted from the Ada program library. This option would be used if the user knows that many 
objects have not changed since the last link and does not want the linker to waste time extracting 
them. 

To use this feature, the user should modify the template to not delete unit objea files after a 
targa link is performed. This way the objea files remain in the curreitt directory (or whereeva 
the user decides to put them). On sub^uent links the user can exiraa objra modules of 
modified units from the Ada library using the standalone DACS extraa looL A new targa link 
can then be perforated using a combination of newly extracted objects and the objea files bom 
previous links that have gone unchanged. This coi^ ngnificantly improve linker speed when 
linking programs that share common and rarely modified libraries and when relinking programs 
that have had only a few units modified. 


64 




DACS>80x86 User's Guide 
The Ada Linker 


<J.15 •tenplaie 

•template <lUe-naiiie> 

•leniplate $ada.iempU(e (defailt) 

Hie lemplaie file is known to the linker via the environmental variable adajen^riate. DDC-I 
supi^ a default template file as part of the standard release system, nease refer to appendix H 
for detailed information. 


6J46 •npx 


•npx (definilt) 

•Bonpx 

The 'npx option specifies that the 80x87 (8087. 80287, or 80387) numeric coprocessor is used 
by the Ada prosnim. When •npx is specified, the 80x^ is initialized by the task initializaiitm 
routine, the flo^g poim stack is reset during exception conditions, and the 80x87 context is 
saved during a task switch. 


Configurable Data 


A 16 bit boolean constaiu is generated by the Ada Linimr 


CO NPX USED 


boolean 


« 0 • 80x87 is not used 

» 1 • 80x87 is used 


64.17 -tasks 
•tasks [n] 

(delkult is no tasking) 

This option specifies the maximum number of tasks allowed by the RTS. If specified, n must be 
greater than zero. If -tasks is specified without a value for n, n defaults to 10. If -tasks is not 
specified, the RTS used will not include support for tasking. If -tasks is specified, the RTS used 
will include support for tasking. 

Ada Interrupt identified with pragma INTERRUFT_HANIX.ER need not be induded in the 
coum of maximum number of tasks. The main piogrm must be counted in the maximum number 
of tasks. Note that the main program, whidt may implidtly be consMtered a task, will not tun 
imder control of the tasking ketnd when -notasks is qxdfied. See also -rms option. 


Configurable Data 

For -tasks, the linker generates the following configurable data: 


65 







DACS-SOxM User’s Guide 
The Ada Linker 


CD Max xasxs 


T9nam - u 


CO Teas 


M TMk 

Control 

■leeka 

(Tcas) 

If -opt la 
aettvo. M 
ntaMCie eo- 
proeoaaor 


Example: 

$ adaJink Hasks 3 p 

• Link the program P. which has at most 3 tasks, including the main program. 


6,5.18 •priority 


•priority n 

•priority 15 (default) 

The •priority option spediles the default priority for task execution. The main program will nm 
at this priority, as well as tasks which have had no priority level defined via pragma PRIORITY. 
The range of priorities is from 0 to 31. 

Priorities can be set on a per task basis dynamically at nm time. See section E.1 (Package 
RTS.EntryPoints) for mote details. 


Configurable Data 

The Ada Linker generates the following constam data: 


CD raioRirr I conocont - m 


Examine: 

$ adaJink •tasks •priority 8 p 

• Link the subprogram P which has the main program and tasks ninning at 
defiuilt priority 8. 


66 




DACS-80x86 User’s Guide 
The Ada Linker 


•time-slice 

•time.slke [r] (default no time slicing is active) 

The •time_slice options specifies whether or not time slicing will be used for tasks. If spedfied, 
R is a dedmal number of seconds lepiesenting the default time slice to be used. If R is not 
specified, the default time slice will be 1/32 of a second. R must be in the range Duration’Small 
:S R S 2.0 and must be greater than or equal to the •timer linker option value. Time slicing only 
applies to tasks running at equal priority. Because the RTS is a preemptive priority scheduler, the 
highest priority task wtil always itm before any lower priority task. Oiily when two or more tasks 
are running at the same priority is time slicing apidied to e^ task. 

Tune slicing can be spedfied on a per task baas dynamically a run-time. See Section El 
(Package RTS.EntiyPoints) for more details. 

Time slidng is not applicable unless tasking is being used. This means that the -tasks option 
mua be used for •time^slice to be effective. 


Configurable Data 

The Ada Linker generates the following data: 


_CB_Tl>«_StICEJOaSO 

• 0 - No tlao aXletnq 

■ 1 - TIim allela^ 


_CD_Tim.suac 


■oomai 


_^2a^uta_lntoso£_ 


• representing the number Y that satisfies Y * DURATTON’SMALL « R 


Example: 

$ ada-link -tiiiK^slice 0.125 -tasks p 

• Spedfies tasks of equal priority to be time sliced each eighth of a second. 


6JJ0 -timer 
•timer R 

•timer 0.001 (default) 

The •timer option spedfies the resolution of calls to the Run-Tune System routitK TIMER (see 
the Run-Tune System Configuration Guide for DACS-80x86 for more information). The number, 
R, spedfies a dedmal number of seconds which have elapsed for every call to TIMER. The 
default TIMER resolution is one millisecond. R must be in the range DURA'nON'SMALL< R 
< 2 . 


67 








DACS-80X86 User's Guide 
The Ada Linker 


Conflgunibie Data 


The Ada Linker generates the following 16 bit constant: 


CO Tim 




• representing the number Y that satisfies Y * DURATION’SMALLsR 


6JJ1 •reserve-stack 
•reserve stack [n] 


The •reserve^stack option designates how many words are reserved on each task stack. This 
space is rese^ed for use by the RTS, which does no checking for stack overflow. This reserved 
space also allows the RTS to function in situations si^h as handling a storage error exception 
arising from stack overflow. 

The •reserve_stack option also reserves part of the main program suck size, specified by the 
linker option •mp_stack_size. 


Configurable Data 


The Ada Linker generates the following integer constant' 


co.xesnvt stack 


imZGCT 


Examples: 

S ada-link •reserve_stack 200 •tasks p 

• Reserve 200 words from each stack for use by the RTS. 


6,1 J2 -lustack-sizc 

•lt_stack_size n 
•lt-stack.jiK S00(default) 

The •lt_stack__^size option designates the library task default size in words. A library task is 
formed~whenli task objea is declared at the outermost level of a package. Library tasks are 
created and activated during the initial main program elaboration. (See the Ada Reference Manual 
for mote details). 


68 







DACS-80x86 User's Guide 
The Ada Linker 


Fbr each library task, the rqyresentaiion spec: 

FOR Task_object'STORAGE_SIZE USE N; 

can be used to specify the library task stack size. However, if the representation spec is not used, 
the default library task size specified by 'It^stack^size will be used. 

For efficiency reasons, all tasks created within library tasks will have stacks allocated within 
same segment as the library task stack. Normally, the segmem which contains the library 
stack is allocated just large enough to hold the default library task stack. Therefore, tme must 
the option •It-stack.option or the pragma LT_SEGMENT_SIZE to reserve more space withir 
segment that may be used for ne^ tasks’ stacks. (See the imi^ementatian dependem pra 
LT.SEGMENT.SIZE in Section F.l for more information). 

The range of this parameter is limited by physical memory size, task stadt size allocated during 
the build phase of the link, and the maximum segmem size (64K for all except the 386/486 
protected mode, which is 4 GB). 

Configurable Data 

The Ada Linker generates the following integer constant: 


CD Lt STACK Size 


iwreceK 


Example: 

S adaJink •It.stack^^size 2048 'tasks p 

• Link the subprogram P using a 2K words default library stack size. 


6J,23 •lt.5tack_size 
•lt_seginent_size n 

(It-stack-size 20 exce{Xion_stack_space) (default) 

This parameter defines in words the size of a library task segment. The library task segmem 
contains the task stack and the stacks of all its nested tasks. 

The default value is only large enough to hold one default task suck. If •lt_stack_size is used and 
specifies a value other than the default value, •lt_seginent_size should also be specified to be the 
size of <task_stack_size> + ” ” 

<totaljof_nested_tasks_sizes> 

<20_words_overhead> + 
exceptionLStack.spaoe. 

Note that the task stack size specified by the 'STORAGE_size can be rep rese n t a tion spec or by 
the option 'It-stack-size. 

Dynamically allocated tadcs receive their own segmem equal in size to the mp_segmem_size. 


69 










DACS-80x86 User's Guide 
The Ada Linker 


The lange of this parameter is limited by physical memory size, task size during 

the build phase, and the maximum segmem size (64K for all except the 386/486 protected mode, 
which is 4 GB). 


Configurable Data 

The Ada Linker generates the following data structure: 


COLT 


szu 


nTOiZK 


Exami^: 

$ adaJink •lt_segiiient_size 2048 -tasks p 

• Link the program P using a library task segmem size of 2K words. 


6JJ4 •mp.stack.size 


•mp_stack_size n 
-mpZstacklsize 8000 (default) 

The -mp^suck^size option specifies the main program stack size in words. 

The range of this parameter is limited by physical memory size, task stack size allocated during 
the build phase (in tasking piopams only), the maximum segmem size (64K for all except the 
386/486 protected mode, which is 4 GB). and the size of mp_segmem_size. 

Configurable Data 

The Ada Linker generates the following data stnictures for nomasking programs: 


CD Mr STACK SZZZ 


mreszK 


CD W STACK 


Mr_STACK szas 
werda of~ 
ttotaQm _ 


CD l» STACK STAKT 


aiylMat «ddr. 
of MS «t«efc 


For tasking programs, the Ada Linker generates the same structures but limits the size to 1024 
words. This stack is only used for the execution of the system startup code and elaboration. 
At main program activation, a segmem for the main program equal to the size specified by • 
•mp^segiiwm^size will be allocated from the dynamic memory pool and a stadt for the main 
program equal to the size specified by -mpjstack.siac win be allocated from the memory 
pool. 


70 








DACS-80x86 User's Guide 
The Ada Linker 


Example: 

$ ada-link •inp_stack_sixc 1000 p 

• Link the subprogram P with a stack of 1000 words. 


6JJS •mp-segment-size 


•mp^segment^slM n 
•mpIsefinenLlsize 8100 (Default) 

The •mp_segiimt_sue option specifies the size, in words, of the segmem in which the main 
program stack is aiiocated. The default setting can be calculated from the formula: 

mp_segmem_size » mp_stack_size * 

overhead ••• (tasks • 1) * 

(overhead task_storage_size) 

Normally, the main program segmem size can be set to the size of the main program stack. 
However, when the main program contains nested tasks, the stacks for the nested will be 
allocated from the data segmem which ootuains the main program stack. Therefore, when the 
main program contains nested tasks, the main program stack segmem must be extetxled via the 
•mp_segment_size optioa 

The range of this parameter is limited by physical memory size, task stack size allocated during 
the build phase (in tasking programs cmly), and the maximum segmem size (64K for all except 
the 386/486 protected mode, which is 4 GB). 

Note: Dynamically allocated tasks receive their own segmem equal in size to mp_$egmem_size. 


Configurable Datt 

The Ada Linker allocates the .(rD_MP_STACK (see the 'mp^stack^size option) within a datt 
segment called _CD_MP_STACK_SEGMENT: 


_CO_Hf_StACK_SEOMEIIT 


Me STACK 


MV szacx STJUtZ 


tm sracx size 


SIZE 


Example: 

S adaJink 'tasks •inp_segmcnt_size 32000 prograin_a 

Links the subprogram PROGRAM_A, which contains tasks nested in the main program 
allocating 32,000 words for the main program stadt segment 


71 











DACS<80x86 User’s Guide 
The Ada Linker 


6J5J6 »task -storage-sfate 


•task_storage_siae n 
•usklstoragelaiae 1024 (default) 

This option sets the default storage size in words for stacks of tasks that are not library tasks. 
This value can be overridden with a represeruaiion clause. 

The range is limited by the size of the lt.segiiient_size Qf it is a subtask to a library task), or by 
mp.segmem_size (if it is a subtask to the main program). 


Configurable Data 

The Ada Linker generates the following dam structure: 


CD TASK STOUUZ SZZZ 


n rr eaKK 


6J21 •interrupt-entry_table 
•intemipt_entry_tabie L4i 

The •intcrrupt^cntry^table option specifies the range of interrupt vector numbers used by the 
Ada program in interrupt tasks. 

The number. L. specifies the lowest numbered interrupt handler. The number, H, specifies the 
highest numbered interrupt handler. The range for low and high interrupts is 0 to 255. 


Configurable Data 


If •intemipt_entry_tabie is specified, the Ada Linker will generate the foUowii^ data structure; 


CD UH URXMUIPT 


CO ■sea mTEMOVT 


CD mt eWID W VECTOR 


COW8TMIT 


COMTMIT 


(■-l+D'S 
vetds rMRCwd 
fOE XntREEupc 
Vvetor_ 


(1) 


(■) 


If the user ever detects umesolved references to the symbols; 

_CD LOW_INTERRUPT 
_CD HIGH_INTERRUPT 
_CD_INTERRUPT_VECTOR 


72 




DACS-80x86 User's Guide 
The Ada Linker 


the Ada program contains standard interrupt tasks for which the RTS requires the above data 
structure. You must relink the Ada program specifying the •intetTupt_entry_table option. 

Examine: 

$ adaJink 'tasks •interrupt_cntry_table S3 p 

• Links the subprogram P, which has standard Ada interrupt entries numbered S 
through 20. 


643 -(nolemble^task-trace 

•cnable_t8sk_trace 
-nocnaMc_ta^__traoe (default) 

This option instructs the exception handler td produce a stack trace when a task terminates because 
of an unhandled exception. 


Configurable Data 


CO TKACS XMABIXD 


BOOUMl 


• task traea disablad 
- taak trae* aaablad 


643 •exccption^space 

•exception-space n 
•exception-space OaOh (default) 

Each stack will have set its top area aside for exception space. When an exception occurs, the 
exception handler may switch stack to this area to avoid acddemal overwrite below the stack 
bottom (which may lead to protection exceptions) if the size of the remaining part of the stack 
is smaller than the N value. Specifying a value >0 will never cause stack switching. Otherwise an 
N value below the default value is not recommended. 


Configurable Data 


CD EXCZPTZOII SZMX_S*ACE SZSX 


m T t c xa 


Note that this value is added to ail teques^^ for task stack space, thus requitit^ an increase in the 
requirements of the apiHOptiate segm^'s size 


73 









DACS*80xS6 User's Guide 
The Ada Linker 


6JJ0 -aipiijm 
•si^^on [<strfaig>] 

When this opdon is specified the linker will fenersie code to output a sign on message, before 
the Ada elaboration is initialed and a sign off message when the target program has terminated 
succesrihlly. If the program terminates with an uncaught exception, the sign off message is not 
printed. 

The sign on message consists of: 

START (<siiing^) <piogiam nemo 
and the sign off message 
STOP (<siiini^] ^nogram name> 

The <sinng> may contain spaces, e.g. 

•aign.jon Test 3" (remember the quotes). 

This facility is very useful to separate output from several target programs nm after each other, 
and to verify that a program that produces little or no output has actually been loaded and nm 
successftiUy. 


74 







APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed Inplementation dependencies correspond to 
iinplementation*-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type SHORT_INTEGER is range -128 .. 127; 

type INTEGER is range -32_768 .. 32_767; 

type LONG_INTEGER is range -2_147_483_648 .. 2_147_483_647; 

type FLOAT is digits 6 

range -16#0.FFFF_FF#E32 .. 16#0.FFFF_FF#E32; 

type LONG_FLOAT is digits 15 

range -16#0.FFFF_FFFF_FFFF_F8#E256 .. 16#0.FFFF_FFFF_FFFF_F8#E256; 

type DURATION is delta 2#1.0#E-14 range -131_072.0 .. 131_071.0; 

end STANDARD; 


C-1 










APPENDIX F - IMPLEMENTATION-DEPENDENT CHAFnACTERISTICS 


This appendix describes the implementation-dependent characteristics of DACS-80X86^ as required 
in App^ix F of the Ada Reference Manual (ANSI/MIL-STD-181SA). 


F.l Implcinentation-Dependent Pragmas 

This section describes all implementation defined pngmas. 


F.1.1 Pragma INTERFACE^PELUNG 

This pragma allows an Ada program to call a non-Ada program whose name contains characters 
that are invalid in Ada subprogram identifiers. This pragma must be used in conjunction with 
pragma INTERFACE. i. e.. pra gma INTERFACE must be specified for the Ada subprogram name 
prior to using pragma INTERFACE.SPELLING. 

The pragma has the format: 

pragma INTERF.^CE.SPELUNC (subprogram name, string literal): 

where the subprogram name is that of one previously given in pragma INTERFACE and the string 
literal is the exaa spelling of the interfaced subprogram in its native language. This pragma is 
only required when the subprogram name comains invalid characters for Ada identifiers. 

Example: 

function RTS^GetOataSc^ment return Integer; 
pragma INTERFACE (ASM86, RTS_GetDataSegaent); 

pragma INTERFACE_SPELLING (RTS_GetOataSegment, ''RlSMGS?GetOataSegment''); 

The string literal may be appended 'NEAR (or ’FAR) to specify a particular method of call The 
default is 'FAR. This suffix should only be used, when the called routines require a near call 
(writing 'FAR is however harmless). If 'NEAR is added, the routine must be in the same segmem 
as the caller. 


F.12 Pragma LT-SEGMENT^ZE 

This pragma sets the size of a library task stack segment 
The pragma has the format: 

pragma LT_SEGMENT_SIZE (T. N); 

where T denotes either a task objea or task type and N designates the size of the library task 


193 






OACS*80x86 User’s Guide 
tmpiememstion-DepeiKtem Chancteristics 


suck segmett in words. 


The library usk's suck segment defaults to the size of the library task stack. The size of the 
library task suck is normally specified via the representation clause (note that T must be a task 
type) 


for T’STORAGE.SIZE use N; 

The size of the library task suck segmem determines how many tasks can be created whidi are 
nested within the library task. All created within a library task will have their stacks 
allocated from the same segmem as the library task stack. Thus, pragma LT.SEGMENT.SIS 
must be specified to reserve space within the library task suck segmem so that nested tasks* 
stacks may be allocated (see section 7.1). 

The following restrictions ate places on the use of LT^SEGMENT.SIS: 

1) It must be used only for library tasks. 

2) It must be placed immediately after the task objea or type name declaration. 

3) The library task stack segmem size (N) must be greater than or equal to the library task 
stack size. 


F.IJ Pragma EXTERNALJ4AME 


F.1J.1 Function 

The pragma EXTERNAL.NAME is designed to make pennanem Ada objects and subprograms 
externally available using names supplied by the user. 


F.U.2 Fomat 

The format of the pragma is: 

pragma EXTERNALJ4AME(<ada_entity>.<extemal name>) 
where <ada_eniity> should be the tome of: 

• a pennanem object. i.e. an objea placed in the permanem pool of the compilation unit - such 
objects originate from package specifications and bodies only, 

• a constam object, i.e. an objea placed in the constam pool of the compilation unit • please 
note that scalar constants are embedded in the code, and composite constants are not always 
placed in the constam pool, because the cmisum is nm considered constam by the compiler. 


194 






DACS*80)i86 User’s Guide 
Impleniemation-Dependera Characteristics 


• a subprogrun name. i.e. a name of a subprognun defined in this compilation unit • please 
notice that separate subprogram specifications cannot be used, the code for the sut^iogi^ 
must be pitsm in the compilation unit code, and where the <extenial name> is a string 
specifying the external mane associated the <ada_entity>. The <exieinal names> should be 
unique. Specifying identical spellings for diflerent <ada_entities> will generue errors at compile 
and/or lir^ time, and the responsibility for this is left to the user. Also the user should avoid 
spellings similar to the spellings generated by the compiler, e.g. E.xxxxx^yyy. P.xxxxx. 
C.xxxxx and other internal identifications. The target debug type information Ksociated with 
such external names is the null type. 


F.UJ Restrictions 

Objects that are local variables to subprograms or blocks cannot have external names associated. 
The entity being made external (’’public”) must be defined in the compilatitm unit itself. Attempts 
to name entities from other compilation units will be rejected with a warning. 

When an entity is an object the value associated with the symbol will be the telocauble address 
of the first byte assigned to the object 


F.U.4 Example 

Consider the following package body fragment: 

package body exanple is 

subtype stringlO is string(1..10}; 

type s is 
record 

len : integer; 
val .* StringlO; 
end record; 

global_s : s; 

const_s ; constant stringlO :■ "1234567890"; 

pragma EXTERNAL NAME(global_s, "GLOBAL S OBJECT"); 
pragma EXTERNALJ<AME(const_s, "C0NST_S"T; 

procedure handle (...) is 

end handle; 

pragma EXTERNALJtAME(handle, "HAMDLE_PROC"); 


end example; 

The objects CLOBAL.S and CONST.S will have associated the names ”CLOBAL_S_OBJECr 
and ”CONST_S". The procedure HANDLE is now also kmwn as "HANDLE.PROC. It is 


195 






DACS*80x86 User’s Guide 
Inq>leineiiiation-Dependeiu Characteristics 


allowable to assign more than one external name to an Ada entity. 


F.IJJ Object Layouts 

Scalar objects are laid out as described in Chapter 9. For arrays the objea is described by the 
address of the first element: the array consuaintfs) arc NOT pass^, and therefore it is 
recommended only to use arrays with known constraints. Non- discriminated records take a 
consecutive number of bytes, whereas discriminated records may contain pointers to the heap. Such 
complex objectt should be made externally visiUe. only if the user has thorough knowledge about 
the layout 


F.l J,6 Parrameter Passing 

The following seoion describes briefly the fundameruals regarding parameter passing in connection 
with Ada subprograms. For mote detail, refer to Chapter 9. 

Scalar objects are always passed by value. For OUT or IN OUT scalars, code is generated to 
move the modified scalar to its dtttinatiort In this case the stack space for parameters is not 
removed by the procedure itself, but by the caller. 

Composite objects are passed by reference. Records are passed via the address of the first byte 
of the record. Constrained arrays ate passed via the address of the first byte (plus a bitoffset when 
a packed array). Unconstiain^ arrays ate passed as consoained arrays plus a poimer to the 
constraints for each index in the array. These ctmstraints consist of lower and upper bounds, plus 
the size in words or bits of each elemem depending if the value is positive or negative 
respectively. The user should study an appropriate disassembler listing to thoroughly understand 
the compiler calling conventions. 

A function (which can only have IN parameters) returns its result in register(s). Scalar results are 
registers/float registers only; composite results leave an address in some registers arxi the rest, if 
any. are placed on the stack top. The stack still contains the parameters in this case (since the 
function result is likely to be on the stack), so the caller must restore the stack poimer to a 
suitable value, when die fimetion call is de^t with. Again, disassemblies may guide the user to 
see how a particular function call is to be handled. 


F.1.4 Pragma INTERRUPT-HANDLER 

This pragma wiO cause the compiler to generate fast interrupt hatxUer entries instead of the normal 
task calls for the entries in the task in which it is specified. It has the format: 

pragma INTERRUPT.HANDLER: 

The pragma must appear as the first thing in the specification of the task object The task must 
be specified in a package and not a procedure. See ^tion F.6.2.3 for more details and restrictions 
on ^tecifying address clauses for task entries. 


196 







OACS-80x86 User's Guide 
Iniplememauon*Dependera Chancteristics 


F.U Pragma MONITOR_TASK 


F.1JS.1 Function 

The pragma MONITORJTASK is used to specify that a task with a certain stnicture can be 
handled in a special way by the Run-Time System, enabling a very efTicient context switch 
qieration. 


F.1.5J Format 
The foimai of the pragma is 
pragma MONTTORJTASK; 

The pragma must be given in a task specification before any entry declarations. 


F.13J Restrictions 


The following restrictions apply on tasks containing a pragma MON1TOR_TASK : 

• Only single anonymous tasks can be “monitor tasks”. 

• Entries in “monitor tasks" must be single entries O-c- not family entries). 

• The task and entry attributes are not allowed for “monitor tasks” and “monitor task” entries. 

• The <declarative pari> shouTld only contain declaration of objects: no types or nested sturcmres 
must be used. 

• The structure of the task body must be one of the following: 

1 . 

CMk body NON_tasx it 
<doclar«ei^ p«re> 
bogln 

<st«t«twnc lito 
loop 

toloet 

tecopc EimY l<p«raMtot_lltt> (do 
Md); ~ 

or 

aeeopt BimY_2<p«raMeor_llit> (do 

•ftd]; ” 

or 

tomlMto 
ond toloet; 
ond loop; 
ond; 


where each entry declared in the specification must be accepted unconditionally exactly once. 


197 





DACS*80x86 User's Cuide 
Imi^ememaiion-Oependem Characteristics 


2. 

tMk body MOH.TAax is 
<dsei«raci^ p«ct> 
b«9la 

<sescsMiic ilso 
loop 

see^>c HON_cmiy<p«raMeor_lise>[do 
<stacaMnt_ltsc> ~ 

andl ; 
and loop; 
ond; 

wheie the task only has one entry. 

In both cases the declarative parts, the statement lists and the parameter lists may be empty. 
The statemem list can be arbitrarily complex, but no nested selea or accept sutements are 
allowed. 

No exception handler in the monitor task body can be given. 

The user must guarantee that no exceptions are propagated out of the accepts. 


F.1,5.4 Example 


The foUowing tasks can be defined 

tnsk LIST BAMOLn is 

pcspms HONXTOR TASK; 
oncty lItSXRT(xIlM:XLBM TTPK) ; 
ontry lUMOVK(ELIM:out IlXH met; 
ontry IS mSDIT(XLtM:eUEM~TTVC; 

NCSUIX: ouc''bOOLIM>I ; 

•nd LXS7_iailDUCR.- 

t«sk body LIST BAMOUm is 
*doeino list* 

bodio 

’inicisllxo list* 
soloct 

seeopt IMSnT(ELeM:eLeM_TTPe)do 
‘insort in list* ~ 
ond ZMSKRT; 
ot 

seeopt REMOVE (SUM; out ELIM_TYPE)do 
*{ind in list snd toaovo Iroa list* 
ond REMOVE 
or 

seeopt IS_PRESeMT(ELEM:ELEM TTFE 

RES: out ioOLEAMIde 

*sesn list* 
ond IS.PRESEMT; 
or "* 
toxaUnsto, 
ond soloet 
ond MOM TASK; 


The task can be used 

tssk typo LZSTJOSER is 

ond LZSTJOSER; 

tssk body LZST_oser is 


198 






DACS-80x86 User's Guide 
Iinplememation<Dependem Charaoetistics 


ba«ln 

LIST aANDLKX.IMSUT(rZ)tST ELCM) ; 

•la« 

rala« XHSCRT.miOR; 
and aalaet; 
loop 

LIST_BAI>DLER. IMSCXT (NSXT_EL£M) : 
and loop; 
and LIST OSSR; 


F.U Pragma TASK_ST0RAGE_SIZE (T, N) 

This pragma may be used as an altenutive to the attribute TASK.STORAGE.SIZE to designate 
the storage size (K) of a panicular task object (T) (see section 7.1). 


Impleinentation*Dependent Attributes 
No implementation-dependent attributes are defined. 


F3 Package SYSTEM 

The specifications of package SYSTEM for all OACS-80x86 in Real Address Mode and 
DACS-8C286PM systems are identical except that type Name and constam System.Name vary: 


Compiler System 


System Name 


DACS-8086 iAPX86 

DACS-80186 iAPX186 

DACS-80286 Real Mode iAPX286 

DACS-80286 Proteaed Mode iAPX286^PM 


Below is package system for DACS-8086. 

packn?* Systaa 1* 

typ« Word Is n«w Incngar; 

eypa ONord is naw Lan 9 _inc« 9 «s; 

typa OnslpnadHerd is rang* 0..CSS3S; 

for OnslgnadWord'SIZE usa 1<; 

typa byta Is sanga 0..2SS; 

for byea'SIZE usa 8; 

subcypa SagsMntld is OnsignadNord; 

typa Addrass is 

racord 

offsat : OnaignadMord; 
sagmanc : Sagaancld; 
and racord; 

subtypa Priority is Intagar ranga 0..31; 


199 




DACS-80x86 User’s Guide 
Implementaiion-Dependeiu Characteristics 


typ* M«m la <litfXt<); 


STSm RMS 
STOMta OMIT 
MEMORT SIZE 
HIM IRT 
HAX~iirr 
NM(~DX6XTS 
HkX MMITXSSA 

rzn DUTA 

tick" 


cenatMC Ma— 

cenataAt 

eenatanc 

cQnatant 

eenatut 

eenatanc 

eenatanc 

eenatanc 

eenatanc 


Utfxac; 

1 <: 

1 041 SlC; 

-2 14? 4t3 441-1; 

2 147 4S3 447; 

IS; 

31; 

241.04E-31; 

0.000 000 12S; 


type Xncecfaea languaoe la 

(AaMS4, fLm4. es4. 

ASM ACT, ttJf ACT. C ACT. 
ask'hoacf, PiM"inAcr. c"MQAcr, 


ea4 KEVEKSE. 
e nVEME ACT. 
C~IIXVXASE~M3ACr) ; 


type ExeeptlenXd la caeeed 

unic_maiber : OnalpnedHecd; 
ualque_nuiib«r : onalgnadHerd; 
end reeecd; 

type taakValue la new Integer; 

type AeeTaakValue la aeeeaa TaakValue; 
type SemaphereValue la new integer; 

type Seawphere la recerd 

eeunCer 
rirac 

laat 

SOMext 

end reeerd; 

XnlCSeaiaphere : eenatanc Senaphere :m seaaphore'(1.0.0,01; 


: Intagar; 

: TaakValue; 

: TaakValue; 

: SeMpheeeValue; 

— enly used In EOS. 


end syace«; 


The package SYSTEM specification for DACS«80386PM package system is: 

paekage Syateai la 

type Nerd la new SI>ert_XnCeger; 

type ONord la new Integer; 

type QNord la new Leng_Xntegac; 

type Onalgnedwerd la range 0..4SS3S; 

fer UnaIgnedHerd'SIZE uae 14; 

type OnalgnedDHerd la range 0. .144FnT_rnT4; 

far DnalgnedDNord'SXZE uae 32; " 

type Byte la range 0..2S5; 

fer Byte'SIZE uae •; 

autotype SegaencXd la OnalgnedHerd; 

type Addreaa la 

reeerd 

effaec : OnalgnedDNerd; 
aegaent : SegaMntXd; 
end reeerd; 


fer Addreaa uae 
reeerd 

effaec at 0 range 0..31; 
ae^Mnt at 2 range 0..1S; 
end reeerd; 


autotype Prlerlcy la integer range 0..31; 


200 









DACS-80x8<5 User's Guide 
Implememation-Dependem Charaaeristics 


cyp« Hm* la (1A»X3««_»M); 


sYsreujum 
ST0M8B OMIT 
WMOKY Size 
HX» ZKI 

iax~zm 

hmc'disits 

lttx''MMITZSSA 


: eenatant llaaM 
; eenatant 
: eenatant 
: eenatant 
; eenatant 
; eenatant 
: eenatant 


raiS_OSLXA : eenatant 
ncx~ : eenatant 


uaxaac nt: 

1 €; 

1C«1 0000 0000*; 

-ic«i000 0000 0000 OOOO*; 
i«*7r*T rrrr frrr rrrri; 
IS; 

31; 

2*1.0*E-31; 

0.000 000 0C2 S; 


type Intatface^languafe la 


(ASMSt, aiMC. 

ASM ACT. rut ACT, 

AaM~NQACr, PUt'MOACr, 


esc. CSC RCVXR5E, 

C ACT, C SXVEME ACT, 
c'tlOACF, C~ RXVnSE~NOACr> ; 


type Exeaptlenid la reeecd 

unlt_nua[ber : OnalgnedSNord; 
unlque_nuaber ; OnalgnedSMerd; 
and reeerd; 


type laakValue la new Integer; 

type AceTaakValvie la acceaa TaakValue; 
typa SeaaphoeaValue la new Intager; 

typa Seaaphora la reeotd 

eountar : Integer; 

Clrat, laat : TaakValue; 

SQNext : .laiaaphorevalue; 

-• only uaed In BOS. 

end reenrd; 


ZnltSeaaphere : eenatant Sa i aa p here SeaMphore'd.O.O.O); 


end Syatea; 


F.4 Representation Clauses 

The DACS-80x86''^ fully supports the 'SIZE lepieseiuation for derived types. The representation 
clauses that are accepted for non-derived opes are described in the following subsections. 


F.4.1 Length Clause 

Some remarks on implementation dependent behavior of length clauses are necessary: 

• When using the SIZE attribute for discrete types, tte maximum value that can be specified is 
16 bits. For DACS-80386PM/80486PM the maximum is 32 bits. 

• SIZE is only obeyed for discrete types when the type is a part of a composite object, e.g. 
arrays or record.^, for example: 

type byte is range 0..255; 
for byte'size use 8; 

sixteen_bits_allocated : byte; — one word allocated 


201 







DACS-80x86 User's Guide 
Implementaiion-Dependem Characteristics 


•ight_bit_p«r_«l«iMnt : array(0..7) of byte; — four words allocated 
type rec is 
record 

cl,c2 : byte; — eight bits per component 

end record; 


• Using the STORAGE.SIZE attribute for a collection will set an upper limit on the total size 
of objects allocated in this coUectioa If further allocation is attempted, the exception 
STORAGE_ERROR is raised. 

• When STORAGE.SIZE is specified in a length cluise for a task type, the process stack area 
will be of the specified size. The process stack area will be allocated inside the ‘‘standard” stack 
segment Note that STORAGE.SIZE may not be specified for a task object 


F.4J Enumeration Representation Clauses 

Enumeration representation clauses may specify representations in the range of -32767..•»-32766 (or 
-16#7FFF..16#7FFE). 


F.4J Record Representation Clauses 

When tepresentatirm clauses ate applied to records tte following restrictions ate imposed: 

• if the component is a record or an unpacked array, it must sian on a storage unit boundary 
(16 bits) 

• a record occupies an integral number of storage units (words) (even though a record may have 
fields that only define an odd number of bytes) 

• a record may take up a maximum of 32K bits 

• a component must be specified with its proper size (in bits), regardless of whether the 
componem is an array or not (Please note that record and unpacked array components take up 
a number of bits divisibie by 16 (sword size)) 

• if a non-array conponem has a size which et^als or exceeds one storage unit (16 bits) the 
component must start on a storage unit bound^. i.e. the componem must be ^cified as: 

component at N range 0..16 * M • 1; 

where N specifies the relative storage unit number (0.1.„.) from the beginning of the record, and 

M the required number of storage units 

• the elements in an array componem should always be wholly contained in one storage unit 

• if a componem has a size which is less than one storage unit, it must be wholly contained 
within a single storage unit: 


202 



DACS-8Qx86 User’s Guide 
Imptementaiion-Dependem Characteristics 


c o mponent at N range X .. Y; 

where N is as in previous paragraph, and 0 <« X <xe Y <» IS. Note that for this restriction 
a component is not requited to start in an integral number of storage units from the beginning 
of the record. 

If the record type contains components which are not covered by a component clause, they are 
allocated consecutively after the component with the value. Allocation of a record component 
without a componem clause is always aligned on a storage unit boundary. Holes created because 
of componem clauses are rx)t otherwise utilized by the cmnpiler. 

Pragma pack on a record type win attempt to pack the componerus not already coveted by a 
teptesenution clause (perhaps none). This packing will begin with the small scalar components and 
larger components will follow in the order specified in the record. The packing begins at the first 
storage unit after the componerus with tepresencatitm clauses. 


F.4J.1 Alignment Clauses 

Alignmem clauses for records are implemented with the following characteristics: 

• If the declaration of the record type is done at the outermost level in a library package, any 
alignmem is accepted. 

• If the record declaration is done at a given static level higher than the outermost library level. 
i.e.. the permanem area), only word alignments are accepted. 

• Any record objea declared at the outermost level in a library package will be aligned according 
to the alignment clause specified for the type. Record objects declared elsewhere can only be 
aligned on a word boundary. If the record type is associated with a differem alignment, an 
error message will be issued. 

• If a record type with an associated alignment clause is used in a composite type, the alignmem 
is required to be one word; an error message is issued if this is not the case. 


FJ Iroplcmentation*Dcpendent Names for Implementation Dependent Components 
None defined by the compiler. 


F.tf Address Qauses 

This section describes the implementation of address clauses and what types of entities may have 
their address specified by the user. 


203 




DACS*80x86 User’s Guide 
Implemenuiion-Dependem Characteristics 


F.6.1 Objects 

Address clauses are suppoited for scalar and composite objects whose size can be determined at 
ctmipile time. The address clause may denote a dynamic value. 


F.6J Task Entries 

The implemetuation supports two methods to equate a task entry to a hardware interrupt through 
an address clause: 

1) Direa transfer of control to a task accept statement when an intermpt occurs. This fonn 
requires the use of pragma INTERRUPT.HANDLER. 

2) Mapping of an interrupt onto a normal conditional entry call. This form allows the interrupt 
entry to be called from other tasks (without special actions), as well as being called when 
an iruerrupt occurs. 


F.6J.1 Fast Interrupt Tasks 

Directly transferring control to an accept statement when an interrupt occurs requires the 
implementation deperxlent pragma INTERRUPT.HANDLER to tell the compiler that Uk' task is 
an iruerrupt handler. 


F.dJL2 Features 

Fast interrupt tasks provide the following features: 

• Provide the fastest possible response time to an interrupt 

• Allow entry calls to other tasks during interrupt servicing. 

• Allow procedure and function calls during interrupt servicing. 

• Does not require its own stack to be allocated. 

• Can be coded in packages with other declarations so that desired visiblity to appropriate parts 
of the program can be achieved. 

• May have multiple accept statements in a single fast ituenupt task, each mapped to a diffetem 
interrupt If more than one interrupt is to be serviced by a single fast iruetit^ task, the accept 
statemerus should simply be coded consecutively. See examine 2 how this is done. Note that 
no code outside the acc^ statemerus will ever be executed. 


204 







DACS-80X86 User’s Guide 
Impiementtfion'Oependem Qiancteiistics 


F.6^ LimiUltoiis 

By using the fast interrupt feature, the user is agreeing to place certain restrictions on the task in 

order to speed up the software response to the interrupt Consequently, use of this method to 

capture iruerrupts is much faster than the nonnal method. 

The following limitations are placed on a fast intermix task: 

• It must be a task object not a task type. 

• The pragma must appear first in the specification of the task object 

• All entries of the task objea must be single entries (no families) with no parameters. 

• The entries must not be called from any task. 

• The body of the task must not contain any statements outside the accept statement(s). A loop 
statemeru may be used to enclose the accej^s), but this is meaningless because no code outside 
the accept statements will be executed. 

• The task may make one entry call to arwther task for every handled imermpt, but the call must 
be single and parameteiiess and must be made to a nonnal tasks, not another fast interrupt 
task. 

• The task may only reference global variables; no data local to the task may be defined. 

• The task must be declared in a library package. i.e.. at the outermost level of some package. 

• Explicit saving of NPX sute must be performed by the user within the accept sutement if such 
state saving is required. 


F.6,2.4 Making Entry Calls to Other Tasks 

Fast interrupt tasks can make entry calls to other nonna as long as the entries are single (no 
indexes) and parameterless. 

If such an entry call is made and there is a possibility of the rmrmal task not being ready to 
accept the call, the entry call can be queued to the nonnal task’s entry queue. This can be forced 
by using the normal Ada conditional entry call construct shown below; 

accept E do 
selea 
T.E; 
else 

null; 

end select; 
end E; 

Normally, this code sequence means make the call and if the task is not waiting to accept it 
immediately, cancel the call and continue. In the context of a fast interrupt task, however, the 
semantics of this construa are modified slightly to force the queuing of the entry call. 


20S 





DACS-80xt6 User's Guide 
Impiemenniion-Dependem Quncterisdcs 


If an unconditional entry call is made and the called task is not waiting at the corresponding 
accept sutement. then the interrupt task will wait at the entry call. Alternatively, if a timed entry 
call is made and the called task does not accept the call before the delay expires, then the call 
will be dropped. The conditional entry call is the preferred method of making task entry calls 
from fast interrapt handlers because it allows the internipt service routine to complete straight 
through and it guarantees cpieueing of the entry call if the called task is not waiting. 

When using this method, make sure that the interrupt is included in the •intetTtipt_entry_tabie 
specified at link time. See Section 7.2.15 for more details. 


F.6JJ Implementation of Fast Interrupts 

Fast iruernipt tasks are not actually implemented as true Ada tasks. Rather, they can be viewed 
as procedures that consist of code simply waititig to be executed when an iiuenupt occurs. They 
do not have a state, priority, or a task control block associated with them, and are not scheduled 
to "tun" by the run*time system. 

Since a fast iiuenupt handler is not really a task, to code it in a loop of somekind is meaningless 
because the task will never loop; it will simply execute the body of the accept statemem whenever 
the interrupt occurs. However, a loop constiua could make the source code more easily understood 
and has no side effects except for the generation of the executable code to implement to loop 
construct. 


F.<UL6 Flow of Control 

When an iruernipt occurs, control of the CPU is transferred directly to the accept statemem of the 
task. This means that the appropriate slot in the interrupt vector table is modified to contain the 
address of the corresponding fast interrupt accept statement. 

Associated with the code for the accept satement is 

at the very beginning: 

code that saves registers and sets (E)BP to look like a ffame where the interrupt renun 
address works as lemm address. 

at the very end: 

code that restores registers followed by an IRET insmiction. 

Note that if the iiuenupt handler makes an entry call to mother task, the iiuenupt handler is 
completed through the IRET before the rendezvous is actually completed. After the rendezvous 
completes, normal Ada task priority rules will be obeyed, and a task context switch may occur. 

NoimaUy. the interrupting device must be reenabled by receiving End^Mrueirupt messages. These 
can be sem from machine code insertion statements as demonstrated in Example 7. 


206 






DACS*80x86 User's Cuide 
Imptenenmioo-Dependem Characteristics 


F^7 Saviii,> NPX State 

If the iiuemipt handler will perfonn flowing poim calculations and the state of the NPX must be 
saved because other tasks also use the numeric coprocessor, calls to the appropriate save/restore 
routines must be made in the statement list of the accept statement These routines art located 
in package RTS.EntryPoints and are called RTS_Store_NPX_State and RTS.Restore.NPX.State. 
See example 6 for more infonnatitm. 


F.6J.8 Storage Used 

This section details the storage requirements of fast interrupt handlers. 


F.6J.9 Stack Space 

A fast interrupt handler executes off the stack of the task executing at the time of the interrupt 
Since a fast interrupt handler is not a task it does not have its own stack. 

Since no local dau or parameters are pennitted. use of stack space is limited to procedure and 
function calls from within the interrtipt haixller. 


F.6J.10 Run-Time System Data 

No task control block (TCB) is created for a fast interrupt handler. 

If the fast interrupt handler makes a task entry call, an emy in the .CD.INTERRUPT.VECTOR 
must be made to allocate storage for the queuing mechanism. This table is a nm*time system dau 
structure used for queuing interrupu to nonnal tasks. Each entry is only 10 words for 80386/80486 
protected mode compilers and S wonts for all other compiler systems. This table is created by 
the linker and is constrained by the user through the linker option •intetTupt_entry_table. For 
more information, see Section F.6.2.1 on linking an application with fast interrupts. 

If the state of the NPX is saved by user code (see Section F.6Z7), it is done so in the NPX save 
area of the TCB of the task executing at the time of the interrupt This is appropriate because it 
is that task whose NPX state is being saved. 


F.6J Building an Application with Fast Interrupt Tasks 

This section describes certain steps that must be followed to build an application using one or 
more fast imerrupt handlers. 


207 






DACS-80X86 User's Guide 
I]nplemenutian*Dependetu Characteristics 


F4L3.1 Source Code 

The pragma INTERRUFT.HANDLER which indicates that the interrupt handler is the fast form 
of intenupt handling and not the nonnai type, must be placed in the task specification as the first 
stmement. 

When specifying an address clause for a fast interrupt handler, the offset should be the interrupt 
number, not the offset of the interrupt in the interrupt vector. The segment is not applicable 
(although a zero value must be specified) as it is not u^ by the compiler for interrupt addresses. 
The compiler wUl place the interrupt vector into the INTERRUFTVECTORTABLE segrnem. For 
real address mode piograms, the interrupt vector must always be in segrnem 0 at execution time. 
For protected mode programs, the user specifies the interrupt vector locadmi at build time. 

Calls to RTS.Store.NPX.State and RTS.RestOfe_NPX.State must be included if the state of the 
numeric coprocessor must be saved when the fast intenupt occrus. These routines are located in 
package RTS.EntryPoints in the toot library. See example 6 for more infbnnation. 


Compiling the Program 
No special compilation options are required. 


F.6JJ Linking the Program 

Since fast interrupt tasks are not real tasks, they do not have to be accounted for when using the 
•tasks option at link time. In fact, if there are no normal tasks in the application, the program 
can be linked without •tasks. 

This also means that the linker options •lt_stack_size, •lt_segment_sizc, 'mp_scgmcnt_size. and 
•task_storage_size do not apply to fast interrupt tasks, exo^ to note that a fan imetrupT task will 
execuK off the stack of the ta^ running at the dme of the imerrupL 

If an entry call is made by a fast interrupt handler the intenupt number must be included in the 
•interrupt_entry_table option at link time. This option builds a table in the run-time system dau 
segment uT handle entry calls of interrupt handlers. The table is indexed by the interrupt number, 
which is bounded by the low and high interrupt numbers specified at link dme. 


F.6J.4 Locating/Building the Program 

For real-address mode programs, no special actions need be performed at link time; the compiler 
creates the appropriate entry in the INTERRUPTVECTORTABLE segment This segrnem must be 
at segrnem 0 before the first interrupt can occur. 

For proteaed mode programs no special actions need be performed. The Ada Link automadcaily 
recognizes Ada interrupt handlen and adds them to the IDT. 


208 








DACS-80X86 User's Guide 
Implemeniation-Dependeiu Characteristics 


F.6.4 Examples 

These examples Ulustnie how to write fast interrupt tasks and then how to build the application 
using the fast interrupt tasks. 


F.6.4.1 Example 1 

This example shows how to code a fast interrupt handler that does not make any task erury calls, 
but simply performs some interrupt handling code in the accept body. 

Ada source: 

with System: 
package P is 

<potentially other declaraiions> 

task FastJntenupt.Handler is 

pragma INTERRUPT.HANDLER; 
entry E; 

for E use at (segmem » 0. offset »> 10): 

end: 


<potentially other declarations> 


end P: 

package body P is 

<poientially other declarations> 

task body Fast_Iiuenupt_Handler is 
begin 

accept E do 

<handle intetrupt> 
end E: 

end: 


<potemially other declatations> 


end P: 


with P: 

procedure Example.! is 
begin 

<main progiam> 
end Example.l: 


Compilation and Linking: 


209 







DACS-80xS6 User’s Guide 
IiBplementttion>Dependeiu Qiaractenstics 


$ ada Exainpie_l 

$ ada-link Exain^_l ! Note: no other tasks in the system in this example. 


F.6.4J Example 2 

This example shows how to write a fast inienupt handler that services mote than one intenupL 


Ada source: 

with System; 
package P is 

task FastJntemipt.Handler is 
pragma INTERRUPT.HANDLER: 

entry El; 
entry E2: 
entry E3; 

for El use at (segmem «> 0, offset >> S): 

for E2 use at (segment «> 0, offset s> 9); 

for E3 use at (segment s> o, offset » 11); 

end; 

end P; 

package body P is 

task body Fast_InterTupt_Handler is 
begin 

accept El do 

<service interrupt 5> 
end El; 

accept E2 do 

<service interrupt 9> 
end E2; 

accept E3 do 

<service interrupt 11> 
end E3; 
end; 

end P; 


Compilation and Linking: 


210 











DAC:S-80x86 User's Guide 
Impiememation-Oependent Characteristics 


$ ada Exainple_2 

S ada-Iink 'tasks • Exainpic_2 # assumes application also has normal tasks (not shown) 


F.6.4J Example 3 

This example shows how to access global dau and make a procedure call from within a fast 
imenupt handler. 


Ada source: 

with System: 
package P is 

A : Integer 

task Fast.InierTupt_Handler is 
pragma INTERRUPT.HANDLER; 
entry E; 

for E use at (segmem »> 0. offset «> 16#127#); 
end: 

end P: 

package body P is 
B : Integer 

procedure P (X : in out Integer) is 
begin 

X :a X + 1: 

end: 

task body Fast_Interrupt_Handler is 
begin 

accept E do 
A := A + B: 

P (A): 
end E: 

end: 
end P: 


Conqrilation and Linking: 

$ ada Example's 
$ ada-link Exainple_3 


211 





DACS-80x86 User's Guide 
Implememation-Dependem Characteristics 


FA.4.4 Example 4 

This example shows how to make a task entry call and fonx it to be (pwued if the called task 
is not wailing at the accept at the time of the call. 

Note that the application is linked with •tasks=2. where the tasks are T and the main program. 
Since the fast intenupt handler is making an entry call to T, the techniques used guarantee that 
it will be queued, if necessary. This is accomplished by using the conditional call construa in 
the accept body of the fast interrupt handler and by including the interrupt in the - 
iiitciTupt_cnti7_table at link time. 


Ada source: 

with System; 
package P is 

task Fastjmerrupt Handler is 
pragma INTEIU<UPT_HA>'DLER; 
entry E; 

for E use at (segment «> 0. offset «> g); 
end; 

task T is 
entry E; 
end; 

end P; 

package body P is 

task body Fast.lnterrupt.Handler is 
begin 

accept E do 
selea 
T.E; 
else 

null; 

end selea; 
end E; 
end; 

task body T is 
begin 
loop 
selea 
accept E; 
or 

delay 3.0; 
end select; 
end loop; 
end; 

end P; 


212 






DACS*80x86 User's Guide 
Implemenution-Dependem Characteristics 


Compilation and Linking: 

$ ada Exampie_4 

S adaJink -taslu 2 •interrupt_entry_table 8,8 Example_4 


F.d.4J Example 5 

This example :ihows how to build an application for 80386/80486 protected mode programs using 
fast interrupt handlers. 


Ada source: 

with System; 
package P is 

task FastJnterrupt.Handler is 
pragma INTERRUPT_HANDLER; 
entry E; 

for E use at (segment *> 0, offset => 17); 
end; 

end P. 

package body P is 

task body Fast.Interrupt.Handler is 
begin 

accept E do 
null; 
end E; 
end; 

end P; 


Compilation and Linking: 

S ada Example_5 
$ adaJink 'tasks • Example_S 


213 










DACS-80X86 User's Guide 
Implememadon-Dependent Characteristics 


Example 6 

This example shows how to save and restore the state of the numeric coprocessor from within a 
fast intern^ handler. This would be required if other tasks are using the coprocessor to perform 
floating poim calculations and the fast imemipt handler also will use the coprocessor. 

Note that the state of the NPX is saved in the task control block of the task executing at the time 
of the intemipL 

Ada source: 

with System; 
package P is 

task FastJnterrupi.Haruller is 
pragma INTHIRUPT.HANDLER: 
entry E; 

for E use at (segment s> 0. offset s> 22); 
end; 

end P; 

with RTS.EntryPoints; 
package body P is 

task body Fast.Intemipt.Handler is 
begin 

accept E do 

RTS_EntryPoints.Store.NPX_State; 

<user code> 

RTS_EiuryPoints.Restore_NPX_Staic; 
end E; 
end; 

end P; 

Compilation and Linking: 

S ada Exampic_6 

$ ada-link ^npx -tasks • Exampie_6 


F.d.4.7 Example 7 

This examine shows how to send an End-Of-lntemipt message as the last step in servicing the 
interrupL 


Ada source: 


214 



DACS*80x86 User's Guide 
Unplememation-Dependent Characteristics 


with System: 
package P is 

task FasOntenupt.Handler is 

pragma INTERRUPT_HANDLER; 
entry E; 

for E use at (segment s> o, offset S); 
end; 

end P; 

with Machine.Code; use Machine.Code; 
package body P is 

procedure Send.EOI is 
begin 

machine Jnsmiction' 

(registerjmmediate, m_MOV. AL, 16#66#); 
mac (line Jnsmiction’ 

ummediate_register. m_OUT. 16#0e0#. AL); 
end; 

pragma inline (Send.EOI); 

task body Fast.Intemipt.Handler is 
begin 

accept E do 
<user code> 

Send_EOI: 
end E: 
end: 

end P. 

Compilation and Linking: 

S ada Example_7 
S ada-Iink -tasks • Example_7 


F.63 Normal Interrupt Tasks 

"Noimal" intemipt tasks are the standard method of servicing interrupts. In this case the irueiiupt 
causes a conditicmal entry call to be made to a normal task. 


F.6J.1 Features 

Normal intemipt tasks provide the following features: 

I) Local dau may be defined and used by the imenupt tadc. 


215 







DACS-80x86 User's Guide 
Implementaiion-Dependent Characteristics 


2) May be called by other tasks with no restrictions. 

3) Can call other normal tasks with no restrictions. 

4) May be declared anywhere in the Ada program where a normal task declaration is allowed. 


F..6JJ LimiUtioiu 

Mapping of an iruemipt onto a normal conditional entry call puts the following constraints on the 
involved entries and tasks: 

1) The affected entries must be defined in a task object only, not a task type. 

2) The entries must be single and parameterless. 


F.6JJ Implementation of Normal Interrupt Tasks 

Normal interrupt tasks are standard Ada tasks. The task is ^ven a priority and nuts as any other 
task, obeying the normal priority rules and any time-slice as configured by the user. 


F.6S.4 Flow of Control 

When an imerrupt occurs, control of the CPU is transferred to an interrupt service routine 
generated by the specification of the interrupt cask. This routine preserves the registers and calls 
the nin-time system, where the appropriate interrupt task and entry are determined from the 
information in the _CD_INTERRUPT_VECTOR table arxl a condidc^ entry call is made. 

If the interrupt task is waiting at the accept statement that corresponds to the imerrupt, then the 
interrupt task is scheduled for execution upon return from the interrupt service routine and the call 
to the run-time system is completed. The imenupt service routine will execute an IRET. which 
reenables interrupts, and execution will continue with the interrupt task. 

If the interrupt task is not waiting at the accept statement that corresponds to the imerrupt. and 
the interrupt task is not in the body of the accept statemem that corresponds to the interrupt, then 
the entry call is automatically queued to the task, and the call to the nm-time system is 
complet^. 

If the interrupt task is not waiting at the accept statemem that corresponds to the interrupt and 
the imerrupt task is executing in the body of the accept statemem that corresponds to the interrupt 
then the interrupt service routine will NOT complete until the imerrupt task has exited the body 
of the accept statement During this period, the interrupt wiU t»t be serviced, and execution in 
the accept body wiU continue with interrupts disabled. Users are cautioned that if from within 
the body of the accept statemem corresponding to an interrupt vi unconditional entry call is made, 
a delay sutement is exonited, or some other non-detenninistic action is invoked, the result will 
be erratic and wiU cause non-deterministic interrupt response. 

Example 4 shows how End-Of-lmerrupt messages may be sem to the interrupting device. 


216 



DACS*80x86 User's Guide 
Implemenution-Dependeiu Chancteristics 


J Saving NPX Sute 

Because nonnal interrupt tasks are standard tasks, the sute of the NPX numeric coprocessor is 
saved automatically by the nin-time system when the task executes. Therefore, no special actions 
ate necessary by the user to save U» state. 


Storage Used 

This section describes the storage requirements of standard interrupt tasks. 

F.6J.7 Stack Space 

A normal interrupt task is allocated its own stack and executes off that stack while servicing an 
interrupt See the appropriate sections of this User's Guide on how to set task stack sizes. 


F.6^,8 Run«Tinw System Data 

A task control block is allocated for each normal interrupt task via the 'tasks option at link time. 

During task elaboratiott an entry is made in the run-time system .CDJNTERRUFT.VECTOR 
table to "define" the standard interrupt This mechanism is used by the run-dme system to make 
the conditional entry call when the interrupt occur. This means that the user is responsible to 
include all imerrupts serviced by interrupt tasks in the -intemipt^entry^table option at link time. 


F.6.6 Building an Application with NoiTnal Interrupt Tasks 

This section describes how to build an application that uses standard Ada tasks to service 
interrupts. 


F.6,6.1 Source Code 

No special pragmas or other such directives ate required to specify that a task is a nonnal interrupt 
task. If it contains imerrupt entries, then it is a normal interrupt task by default 

When specifying an address clause for a noimal interrupt handler, the offset should be the 
imerrupt number, not the offset of the interrupt in the interrupt vector. The segmem is not 
applicable (although some value must be specified) because it is not used by the compiler for 
in terrup t addresses. The compiler will ^ace the interrupt vector into the 
INTERRUFTVECTORTABLE segmem. For teal address mode programs, the interrupt vector 
must always be in segmem 0 at execution time. This placemem can be accomplished by specifying 


217 









DACS*80x86 User’s Guide 
Imirieinemadoii-Oependem Characteristics 


the address to locate the INTERRUPTVECTORTABLE segment with the loc86 command, or at 
ru n ti me, by having the startup code routine of the UCC copy down the 
INTERRUPTVECTORTABLE segment to segment 0 and the compiler will put it there 
automatically. For protected mode programs, the user specifies the interrupt vector location at 
build time. 


f,6jS2 Compiling the Program 
No special compilation options are requited. 


F.d.6J Linking the Program 

The interrupt task must be included in the "tasks option. The link options -lt_stack_size. — 
lt_segment_siae. •mp_segment_si 2 e. and -task_storage_si 2 e apply to nonnal interrupt usks and 
must be sef to appropriate valt^ for your appUcation. ~ 

Every interrupt task must be accounted for in the •inteiTupt_entry_table option. This option 
causes a table to be built in the run-time system dau segmera to ha^e interrupt enuies. In the 
case of standard interrupt tasks, this table is used to map the interrupt onto a normal conditional 
entry call to another task. 


F.6.7 Examples 

These examples illustrate how to write normal interrupt tasks and then how to build the qiplication 
using them. 

F.6.7.1 Example 1 

This example shows how to code a simple normal interrupt handler. 

Ada source: 

with System; 
package P is 

task Normal_Intertupt_Handler is 
entry E; 

for E use at (segmem s> o. ofEset «> 10): 

end; 
end P; 

package body P is 

task body Normal.Interrupt.Handler is 


218 








DACS>80x86 User's Guide 
Implcmenianon-Dependem Characteristics 


begin 

accept E do 

<handle intenupo 
end E; 
end: 

end P; 

with P; 

procedure Example.l is 
begin 

<inain program> 
end Exam[de_l; 


Compilation and Linking; 

$ ada Examplc^l 

S ada-Iink -tasks 2 -intcmipt^cntry^uble 10,10 Example_l 


F.6.7J Example 2 

This example shows how to write a normal iiuetiupt lumdler that services more than one interrupt 
arid has other standard task entries. 

Ada source: 

with System: 
padtage P is 

task Normal.Task is 

entry El: 

entry E2: - standard entry 

entry E3; 

for El use at (segmem s> 0. offset •> 7): 
for E3 use at (segmem »> 0, of&et s> 9): 

end: 

end P: 

package body P is 

task body Normal_Task is 
begin 
loop 
selea 

accept El do 

<service imenept 7> 


219 









DACS-80x86 User's Guide 
Imptenemaiion-Dependem Chanaeristics 


end El; 
or 

accept E2 do 

<sundanl rende 2 vous> 
end E2: 
or 

accept E3 do 

<service miemipt 9> 
end E3; 
end select; 
end loop; 

end Nonnaljrask; 
end P, 

Compilation and Linking: 

$ ada Example^! 

$ ada-link ‘tasks 'interrupt_cntt 7 _table 7^ Exainpie_2 


F.6.7J Example 3 

This example shows how to build an application for 80386 protected mode programs using noimal 
interrupt handlers. 


Ada source: 

with System; 
package P is 

task Notmal_Interrupt_Handler is 
entry E; 

for E use at (segment «> 0. offset »> 20); 
end; 

end P. 

package body P is 

task body Noimal_Iniemipt_Handler is 
begin 

accept E do 
null; 
end E; 
end; 

end P 


220 




OACS-80x86 User’s Guide 
lmpiememsiion»Dependeiu Chsiacteiisdcs 


CompilaUoii and Linking: 

$ ada Exainple_3 

$ adaJink 'tasks •intemipt_entry_Tablc 20*20 Example_3 


F.6.7.4 Example 4 

This example shows how an End-Of-Imenupt message may be sent to the ixuenupting device. 

Ada source: 

with System; 
peckege P is 

task NonBel_Interrupt_Handler is 
entry E; 

for E use at (segment ■> 0, offset ■> 7); 

end; 


end P ; 

with Machine_Code; use Machine_Code; 
package body P is 

procedure Send_EOZ is 
begin 

machine_instruction' 

”(register^iramediate, m_MOV, AL, 16#66#); 
machine_inst ruction' 

”’(iramediate_register, m__OUT, 16#0e0#, AL) ; 
end; ” 

pragma inline (Send_EOZ); 

task body Normal_Xnterrupt^Handler is 
begin 

accept E do 
<user code> 

Send_E01; 
end E; 

end; 


end P; 


Compilation and Linking: 

$ ada Example_4 

$ ada-link -tasiu •intemipt_entr 7 _tablc 7,7 Example_4 


221 



DACS-80x86 User's Guide 
Imptemenution-Depenilem Characteriaics 


F.&.8 Interrupt Queuing 

DDC'I provides a useful feature that allows usk entry calls made by inienupt handlers (fast and 
nonnal variant) to be queued if the called task is not waiting to accept the call, enabling the 
interrupt handler to comfriete to the IRET. What may not be clear is that the same interrupt may 
be queued only once at any given time in DDC-I’s implementation. We have made this choice 
for two reasons: 

a) Queuing does not come for free, and queuing an iruerrupt more than once is considerably 
mote erqrensive than queuing just one. DDC-1 feels that most customers prefer their 
interrupt handlers to be as fast as possible and that we have chosen an implementation that 
balances performance with functionality. 

b) In most applications, if the servicing of an interrupt is not performed in a relatively short 
period of time, there is an unacceptable and poteniiaily dangerous situatioa Queuing the 
same interrupt mote than once represerus this siniadon. 

Note that this note refers to queuing of the same interrupt mote than once at the same time. 
Different interrupts may be queued at the same time as well as the same interrupt may be queued 
in a sequential manner as long as there is never a sinration where the queuing overlaps in dme. 

If it is acceptable for your application to queue the same iruerrupt mote than once, it is a 
relatively simple procedure to implement the mechanism yourself. Simply implement a high 
priority agent task that is called from the interrupt handler. The agent task accepts calls from the 
interrupt task and makes the call on behalf of the interrupt handler to the originally caUed task. 
By careful design, the agent task can be made to accept all calls from the interrupt task when they 
are made, but at the very least, must guarantee that at most one will be queued at a time. 


F.6.9 Recurrence of Interrupts 

DDC'I recommends the following techniques to ensure that an intemipt is completely haixUed 
before the same interrupt recurs. There are two caxs to consider. i.e. the case of fast interrupt 
handlers and the case of nonnal intemipt handlers. 


F.6.9.1 Fast Interrupt Handler 

If the fast interrupt handler makes an etury call to a nonnal task, then place the code that 
reenables the interrupt at the end of the accept body of the called task. When this is done, the 
interrupt will not be reenabled before the rendezvous is actually completed between the fast 
interrupt handler and the called task even if the call was queued. Note that the iruerrupt task 
executes all the way through the IRET before the rendezvous is completed if the entry call was 
queued. 

Normally, end-of-interrupt code using Low_LeveUO will be presem in the accept body of the fost 
interrupt handler. This implies that the end-of-iraetrupt code will be executed before the 
rendezvous is completed, possibly allowing the interrupt to come in again before the application 
is ready to handle it 

If the fast interrupt handler does not make an entry caU to another task, then placing the 


222 



DACS>80x86 User's Guide 
Inplementanon-Dependem Characteristics 


end-of-ituemipt code in the accept body of the fast interrupt task will guarantee that the interrupt 
is completely serviced before another interrupt happens. 


F.6JJ Normal Interrupt Handler 

Place the code that reenables the interrupt at the end of the accept body of the normal interrupt 
task. When this is done, the imenupt will not be reenabled before the rendezvous is aaually 
completed between the normal ituenupt handler and the called task even if the call was qi^ed. 
Even though the interrupt "completes" in the sense that the IRET is executed, the interrupt is not 
yet reenabled because tte rend^ous with the normal task’s interrupt entry has not been made. 

If these techniques are used for either variam of interrupt handlers, caution must be taken that 
other tasks do not caU the task entry which reenables interrupts if this can cause adverse side 
effects. 


F.7 Unchecked Conversion 

Unchecked conversion is only allowed between objects of the same "size”. However, if scalar type 
has different sizes (packed and unpacked), utKhecked conversion between such a type and another 
type is accepted if either the packed or the unpacked size fits the other type. 


F.8 Input/Output Packages 

In many embedded systems, there is no need for a traditional I/O system, but in order to support 
testing and validation. DDC-I has developed a small terminal oriented I/O system. This I/O system 
consists esseiuially of TEXT JO adapted with respea to handling only a terminal and not file I/O 
(file I/O will cause a USE error to be raised) and a low level package called 
TERMINAL.DRIVER. A BASICJO package has been provided for convenience purposes, 
forming an interface between TEXTJO and TERMINAL.DRIVER as illustrated in the following 
figure. 



The TERMINAL.DRIVER package is the only package that is target dependent, i.e., it is the only 


223 







DACS-SOxSa User’s Guide 
Iraptonenation-Dependetu Quracieristics 


package that need be changed when changing commimications controllers. The actual body of the 
TER>^AL.DR1VER is written in assembly language attd is pan of the UCC modules DlIPUT 
and OllGET. The user can also call the terminal driver routines directly, i.e. from an assembly 
language routine. TEXT.IO and BASICJO are written comfdetely in Ada and need not be 
chan^d. 


BASICJO provides a mapping between TEXT JO ctxurol characters and ASCI as follows: 


TEXTJO 

ASQI Character 

UNE.TERMINATOR 

ASai.CR 

PAGE.TERMINATOR 

ASaiJT 

RLE.TERMINATOR 

ASOISUB (CTRL/Z) 

NEW_LINE 

ASaiiF 


The services provided by the terminal driver are; 


1) Reading a character from the communications port, Get.Character. 

2) Writing a character to the communications pon. Put.Character. 


FAl Package TEXTJO 

The specification of package TEXT JO: 

pc« 9 M p*qm; 
with 1ASIC_I0; 

with 10 EXCCPtlORS; 
p«eka9«~IEXT_X0 Is 

cyp« rZLtJTTfZ IS llsiltad prlvscs; 

cyp« riU_HODE is (IN_riLE, QOT.nLE); 

typ« COUNT is r«n«« 0 .. XNTESSK' lAST; 

subcyp* POSXTXve_COUNT Is C OUNT ranq* 1 .. COUNT'last; 

UNIOUNDES: constant COUNT:- 0; " lino ond p «90 longth 

" suoc. slso of on Intouoc output fluid 2*-• 

subtypo rXEIS Is XNTESCR rango 0 .. 3S; 

subtypo N0M8eR_aASE Is XNTEGEX tango 2 .. 1<; 

typo TntJStt Is (LOHER_CASS, UPPER.CASEI ; 

ptagaa PAiSE; 

— rilo Managoaont 


ptocoduco CKEATE 

(PILE 

: in out 

PXLE TTPE; 


MOOE 

: in 

rXLE~NOOE -.-OUT rxiE; 


NAME 

: in 

STRm 


PONM 

); 

: in 

STHXMO 

peeeaduto OPEN 

CnLE 

: in out 

FILE TYPE; 


MODE 

: in 

FILE MOOE; 


NAME 

: in 

SnUNG; 


224 






DACS*80x86 User’s Guide 
Impletnemation-Dependem Charaoehsucs 


FOm : In SmXIK 

); 


preenduc* Cioat (FXU 
preendur* OEUTK (FILE : 
pcoeaduz* RESET (FILE : 

MODE : 

preeadur* RESET (FILE 

function HOOE (FILE 
function HRHE (FILE 
function FORM (FILE 

function IS_OPEM(FILE : 

prapM FAdE; 

— control of dofault in 


In out FILE TTVE); 

In out FILE^TYPE); 

In out FILe'tTTB; 

In FILE HOOE); 

In out FILE_TTPE); 

In FILE TTPE) COtum FILE MOOE; 
In FILE'tTTE) cotuzn STRiSs; 

In FILE^TYFB) rotuzn STRING; 

In FILE TTFB rotuzn BOOLEAN; 


and output fllaa 


proeaduro SET IMPOT (FILE : In FILE TTPE): 
proeadura SET~OOTFOT (FILE : In FILE'tYPE); 


function STAMBARD.INPOT ratum FILE.TTFE; 
function STAMOARD~OOTFOT raturn FILE~TTtE; 


function CORRENT_INFOT zotuzn FILE_TTFE; 
functlon CORREIIT~OOIFOT ratum FILi.~TTFE; 


praqna FA3E; 

ipaclflcatlon of llna and paca iancths 


proeadura SET^LIllE_LEMaTB 
proeadura SET_LIHE_LENGTB 


(FILE ; In FILE TYPE; 

TO : In COONT); 

(TO : In COONT); 


proeaduro SST^PAGE.LEMGTR 
proeadura SET_PAaE_LEMGTB 


(FILE : In FILE TYPE; 

TO : In COONT); 

(TO : in COONT); 


function LXME_LEMCTB 
function LIME LENGTR 


(FILE : In FILE_TYPE) 
ratum COOMT; 
ratum coonT; 


function PAGE.LEMGTB 
function PAGE^LIVGTB 


(FILE : in FILE.TYPE) 
ratum COORT; ~ 
rotuzn COONT; 


praqaa PAGE; 

" Colunui, Lina, and Paqa Control 

proeaduro MEW LIME (FILE : In FILE TYPE; 

~ SPACING : In POSITIVE_COOMT ;• 1); 

proeadura MEM LIME (SPACING : in POSITIVe'cOONT ;• 1); 


proeaduro SKIP LIME (FILE : In FILE TTPE; 

SPACING : In POSITIVE COONT :• 1); 
preeaduza SKIP LINE (SPACING : in POSITIVE~COOMT :• 1); 


furetlon 

function 

END OF LIME 
EMD~OF~LINE 

(FILE : 

In 

PILE_rTE) 

rntuRi 

rntuen 

BOOLEAN; 

BOOLEAN; 

proeadura MEH_pagE 
proeadura MEN~PAGE; 

(FILE : 

In 

FILE_TYPE); 



procadura SXIP_PA6B 
proeadura SXIP~PACE; 

(FILE : 

; In 

FILE_TYPE); 



function 

function 

END OF PAGE 
EMO'OFJPAGE 

(FILE : 

: in 

FILE_TYPE) 

ntum 

return 

BOOLEAN; 

BOOLEAN; 

function 

function 

END OF PILE 
emd'of'file 

(FILE ! 

; in 

FILE_TYPE) 

rncttim 

rntum 

BOOLEAN; 

BOOLEAN; 





DACS-80x86 User's Guide 
Implememation-Dependem Quuactenstics 


procedure 

seT_cot 

(FILE : 
TO 

In FILE TYPE; 

: la POSITIVE COOMT); 

procedure 

SK_COL 

(TO ; la POSITlVe_COOHT> ; 

procedure 

SET_L1ME 

(FILE : In FILE TYPE; 

TO : In POSITIVE COOMT); 

procedure 

SCT_LINE 

(TO ; In POSITIVE~COCarr); 

function 

COL 

(FILE : 
return 

: In FILE TYPE) 
POSIT1VE~COOMT; 

function 

COL 

return 

positive“coomt; 

function 

LIME 

(FILE 

return 

: la FILS TYPE) 
positive”COOMT; 

function 

LIME 

return 

POSinVE^COOMT; 

function 

PAOE 

(FILE 

return 

: In PILE TYPE) 
POSITIVe“COOMT; 

function 

PAGE 

return 

POSITIVE“cOOMI; 


pr«4M PAfiB; 

" Character Input-Output 


procedure 

SET 

(FILE : 

in 

FILE TYPE; ITEM : 

out 

CSARACTEX) ; 

procedure 

SET 

( 


ITEM : 

out 

CBARACTEA) ; 

procedure 

POT 

(FILE ; 

in 

FILE TYPE; ITEM : 

In 

CEASACTEA); 

procedure 

POT 

( 


ITEM : 

in 

CBAPACTEA) ; 

— String 

Input-Output 





procedure 

SET 

(FILE : 

in 

FILE TYPE; ITEM : 

out 

CBAJtACTEX); 

procedure 

SET 

( 


ITEM : 

out 

ClAAACTEll); 

procedure 

POT 

(FILE : 

in 

PILE TYPE; ITEM ; 

in 

CBAAACTEA); 

procedure 

POT 

( 


ITEM : 

in 

CEAXACTEP); 


procedure SET_LIMC 

procedure GCT^Iim 

procedure POT_I.Ilie 
procedure rOT_LItns 


(FILE : 

In FILE TYPE; 

ITEM ; 

; out 

STEIMS; 

LAST : 

: out 

HATOEAL); 

(ITEM : 

out 

STEINS; 

LAST : 

: out 

HATOEAL); 

(FILE 

: In FILE TYPE; 

ITEM 

in 

STEIMS); 

(ITEM 

in 

STEIMS); 


praqnia PACE; 

" Generic Package for Input-Output of Integer Typee 


generic 

type mm la range o; 
package IirrEGUl_IO la 


DEFAOLT HIDTE 

: FIELD 

MOM'HIDTE; 

OEFAOLT~BASE 

: MOMBEE, 

_BASE ;• 10; 

procedure SET 

(FILE 

ITEM 

HIDTE 

: In FILE_TYPE; 

: out MDmT 
; in FIELD 0); 

procedure SET 

(ITEM 

HIDTE 

: out MOM; 

: la FIELD :• 0); 

procedure POT 

(FILE 

ITEM 

HIDTE 

BASE 

In FILE TTPE; 
la MOmT 

la FIELD :• DEFAOLT HIDXE; 

In HOIBEE BASE ;• DEPAOLT_BASE); 

procedure POT 

(ITEM 

HIDTE 

BASE 

in MOM; 

la FIELD :> DEFAOLT HIDTB; 
la NOMBEE.BASE DEFAOLT.BASE) ; 

procedure SET 

(FEOM 

ITEM 

: In STEIMS; 

: out MOM; 


226 







DACS*80x86 User's Guide 
Implemenution-Dependem Characteristics 


LAST : out rOSXTIVX); 

prcsoUuro POT (TO : out STRIMG,- 
ITCM ; tn mM; 

BMC : In IIO»aEll_>MS :« OerMU_BASE) ; 

ond IMTSOeil 10; 


prnpM PASS; 

—• Oonocie Paekagoa foe Input-Output of Haal typaa 
ganorle 

typo MOH la digits o; 
paekago rtiOU_IO Is 

DETAOLT POPS : FIZLO :« 2; 

OirAOLT~'ArT : FXSLB :> HOM'DISZTS - 1; 

OSFAOLTJEXP : FIELD 3; 

proeoduro SET (FILE : in FILE TYPE; 

ITEM : out MOmT 
non : In FIELD 0) ; 
proeoduro <aT (ITEM : out MOM: 

non : In FIELD :• 01; 

proeoduro POT (FILE ; la FILE TYPE; 

ITEM ; la MOM;* 

FOPE : la FIELD MFAOLT FOPE; 

AFT ; la FIELD OEFAOLT~AFT; 

E» : In FIELD DEFAOLT~E») ; 

proeoduro POT (ITEM ; in MOM; ~ 

FOPE : In FIELD :• DEFAOLT FME; 
AFT : In FIELD :■ DEFAOLI~AFT; 
E» : In FIELD :• OirAOLT~eXP>; 

proeoduro OBT (FPOH : In STPIMQ; 

ITEM : out POM; 

LAST ; out POSITIVE); 

proeoduro POT (TO : out STPIMG; 

ITEM : in MOM; 

AFT ; in FIELD ;> OEFADLT AFT; 

E» ; in FIELD DEPAOLT^En); 

ond FLOAT lO; 


pragsw PAGE; 
goaorle 

typo MOM Is dolta O; 
paekago FXXED_XO is 

DEFAOLT fmX : FIELD :> NON'FOPE; 

DEFA0LT~AFT : FIELD MOM'AFT; 

DEFAOLT~EXP : FIELD 0; 

proeoduro (SET (FILE : In FILE.TYPE; 

ITEM : out MOmT 
nDn : in FIELD :• 0) ; 
proeoduro GET (ITEM : out NON; 

NXOn : In FIELD 0) ; 

proeoduro POT (FILE : In FILE TYPE; 

ITEM : la HOM;~ 

FOPE : In FIELD DEFAULT FOPE; 
AFT : In FIELD ;> DEFAOLT~AFT; 
EXP ; la FIELD :« OEFAOLTJEXF); 

proeoduro POT (ITEM : In MOM; 

FOPE : la FIELD DEFAULT FOPE; 
AFT : la FIELD :> OEFaiOLT~API; 


227 















DACS*80x 86 User’s Guide 
Implemenution*Dependeru Quncteristics 


t» ; in riCU OCrAOtT tXf): 


ptocaUttr* OCT (fMM 
ItCM 
LAST 

pceeadut* POT (TO 

ITZM 

ATT 

exp 


in STPZP6; 
out IRMi 
out POSITZVE); 

OUL SnUMO; 

In mm; 

in riZLO :• OITAOLT AIT: 
In riCLO ;> DerAOLT~CXS); 


•nd rZXEO.IO; 


pCAq«A PAOE; 

" OMintle Packapn for Znput-Output of entoMCAttan Typna 
g«n«rle 

typ* Smm 1 * (o); 

pAckap* emmeiuTzoM^zo la 

DCTAOLT wzora : ITCLS :> 0: 

DBrAOLT~SBTTUK: : TTPC.SCT ;> OPPCA CASE; 


proeadura SET 

(FILE : 

In rXLE_TTPE; 

ITEM ; out EMOM); 

precadnra SET 

< 



ITEM : out EMOM); 

preeaduxa POT 

(FXU 

: rXLE TYPE; 



ITEM 

; in 

EMOM; 



WXOTE 

: in 

rXELO 

OETAOLT NZOTR; 


SET 

: in 

TYPE^SET 

!- OETAOLT'sETTIMS); 

preeadura POT 

(ITEM 

: in 

EMOM; 



HXOTB 

: in 

rXELO 

:• OETAOLT MZSTB; 


SET 

: in 

TYPE_SET 

OETAOLT^SETTINS'; 

precadura SET 

(FROH : 

in 

STRXMS; 



ITEM ; 

out 

EMOM; 



LAST : 

out 

POSITIVE) 

<• 

psoeadttra POT 

(TO 

out 

STRZRS; 



ITIM 

in 

EMOM; 



SET 

in 

TYPE SET 

!- detaolt^setthio) ; 


•nd EmmERATZOR.ZO; 
pragM tMt; 


— Excapeiona 


STATOS EMUK 
HOOE dwOR 
hame'eupok 
OSE EPPOR 
OEviCE ERROR 
END ERROR 
OATA ERROR 
LATOOr ERROR 


•xcnpclen rnnaaiaa 
•xenpelen canaiMa 
•xenptlon nnaaaa 
•senptlen r«naa*a 
•xeapclen tanaawa 
•xenpclon r*n«BMa 
•xenpclon ranaawa 
•xenptlen ranaaMa 


10 EXCEPTIONS.STATOS ERROR; 
lo'EXCEPtlONS.MODE ERROR; 
XO~EXCEPTIOHS .RAmTERROR; 
IO~EXeePTZOHS.QSE BIROR; 
IoTeXCEPTIONS.DEVICE ERROR; 
zo'‘exeePTzaNS.EiiD error; 
io'’excxnxoNS.OAZA error,- 
XO~eXCEPTXOHS.LATQOT ERROR; 


pragM pag«; 
prtvat* 


typ* rXLE_TTPE la 
raeetd 

rt : XMTEiaR >1; 

•nd neerd; 


•nd TEXT_XO; 


228 






DACS*80x86 User’s Guide 
Implemenution-Oependem Characteristics 


FA2 Packafe lO-EXCEPTIONS 

The specification of the package lO.EXCEFTIONS: 


lO^SXCBSTXOMS la 

stkns SmOR : •xeaptlen,- 
MOOB cmOR : Axeaptlea; 
MMs'eaitOR : •xeaptlen; 
oaa CMOR ; Mcaptleii; 
OCnCB.XiUlOa : MCeaptlea; 
IIID_BaMR : Mceaptloa; 
oan BHaOR ; axeaptlea: 
lAYOSr.EinOR : Meaptlea; 

•ad ZO exCBmOHS: 


fJU Package BASIC JO 

The specification of package BASICJO: 


with IO_EXCt»TICNS; 
packag* USIC_ZO la 

eyp« eouat la ranp* 0 .. lat«9«r‘laat; 

autotyp* poalciv«_eouat la eouat taa«« 1 .. eouat'laac; 


fuaetloa 90t_lato««r cotum atrlag; 

•• Sklpa any loadlay tolaaka, llao t«xalaatora oc pa90 

— totalaatota. thoa taada a plua or a aUaua alya IS 
-- peoaaat, tboa nada aeeordlag to tho ayntax of aa 

— lat09«t litoral, vhleh My b« baaod. storoa la ItM 
•> a atrlad eeatalnlay aa optional alyn and an latagar 
~ lltatal. 

~ 7 h« oxeaption mTA_tlWOR la ralaad if tho aoquoneo 
'» of eharaetora dooa~aot eorroapond to tho ayntax 

— doaetlbod abooo. 

— Tho oxeoptlen ll)D_eRROR la calaod If tho fllo totmlaator 

— la road. Thla Maaa that tho atartlnp aoquoneo of an 
~ latoqor haa not boon Mt. 

>• Moto that tho eharaetor tonalnatlag tho oporatloa auat 

— bo avallablo for tho aoxt got oporatloa. 

funetlon got_roal rotum string; 

— Corrospoads to got_lntogor axeopt that It roads aecordlag 
>• to tho syntax of a~roal litoral, whleh a>ay bo basod. 


fuaetloa got^onusMratlon rotura string; 

~ Corrospoads to got_lneogor oxeopt that It roada aeeordlag 

— to tho syntax of m Idoatlflor. ohoro uppor aad looor 

— easo lottors aro oqnlvalont to a eharaetar litoral 
~ laeludlag tho apostrophoa. 


229 







DACS-80x86 User’s Guide 
ImpiemenoKion-OepenKteu Quncteristics 

Svnetloa 9«C_lC«t (l«n«th : in Incngnt) MCutn string; 

— RMda • string fro* tha currant llna and staras It in 

— ItsB. X< tha rsMlnlng nuabar at eaaraetacs an tha 
•> currant llna is lass than langth than only thasa 

~ charaetars ara ratumad. Tha llna tasalnator Is not 

— sklppad. 

proeadura put_ltaB (Itaa : in string): 

~ If tha langth o< tha string la graatar than tha currant 
naxlins llna (linalaagth), tha aseaptioa tATOOT Emm 

— Is ralsad. 

— It tha string doas oat fit on tha currant llna a llna 

— tatBinator la output, than tha Itan is output. 

— llna and page langths - MM 14.3.3. 

proeadura aat_llna_langth (to : in count): 

proeadura sat_paga_langth (to ; la count); 

function llaa_langth ratum count: 
function pago_longth return count: 

— Operations on eoluaas, linos and pages - MM 14.3.4. 

proeadura naw_lina: 

proeadura slUp.llna; 

function aad_ef_llna ratum boolean; 

precodura aoujMga: 

proeadura sklp_paga; 

funetlen and_ef,^ago return boolean: 

function and^ef^flla return boolean: 

proeadura satjcol (to : In positlvajcouat): 

proeadura sat_lina (to : In pealtlva_eeuat): 

funetlen col ratum posltlva_eount: 

funetlen llna return posltlva_eettnt; 

function page ratum posltlva^eount; 

» Charaetar and string proeaduras. 

— Cerraspends to tha precoduroa defined In MM 14.3.C. 

procedure gat_eharaetor (Itaa : out ehametor); 

proeadura gac_atrlag (Itoa : out string); 

proeadura gat_llaa (Itaai : out string; 

last : out natural); 

proeadura put_eharaetar (Itaai : la character); 
proeadura put_strlng (Itaa ; la string); 


230 








OACS*80x86 User’s Guide 
bniilenienutioa-Dependem Characteristics 


ptoeadur* pue_lla« (Itaa : in attliif); 


— wieapelona: 

lo.ixctrnoMs. osx.cmoit: 
xo Bxcsrtioiis.oKvxez OWOR; 
lo'BxcsraoMs.ae taiox; 
lO CXCSFTIOMt.Oan CMML: 
lO^CXaPTIOHS. lATOOT.aWOP; 

•nd Basic XO; 


USB xmoR 
osvfcK cmop 
ao mm 
oaxa moK 
ixtem mm 


•xeapcioa 
•xeaption 
•xeapetan 
•xeapcioa 
•xeapcioa » 



FJ.4 Package TERMINAL.ORIVER 

‘The specification of package TERMINAL.IMUVER: 


poeka^a TSMIZKAL_OKXVBK la 

proeoduro puc^eharaecor (ch : la eharaecor); 
pceeoduca 9 ac_eharaecar (eh : ouc ehaxaecar); 
pclvaca 

pcaqpa lncac£aea (ASHtC, pucjehaeaecar); 

prapaia laCorraeo_spallla 9 (puc_ehacaecac. *01IP0T?pttC_ehacaecoc*) ; 
pcapM incacfaea (ASMSC, sac^ehacaecac) ; 

pcapM incar<aea^apaXlln«(pa?_eharaecae, *01xaR?«aCjehaxaecar*) ; 
aad TnMZiaa.OflXVn; 


Packages SEQUENTIAL-IO and DIRECT JO 

The specifications of SEQUENTIALJO and DIRECT JO are specified in the ARM: 

Since files are not supponed the subprograms in these units reaise USE_ERROR or 
STATUS_ERROR. 


231 






DACS-80x86 User’s Gukk 
Inplenienution-Dependem Cbanaensiics 

FA6 Packafc LOW-LEVEL-10 

Tbe specification of LOW.LEVELJO (16 bits) is: 


with SyaCMi; 

p«eka«« LOH^lSVXi_io 1* 

*ubcyp« port_addrMa in SyatM.OnalvaadMexd; 


typm ll^io_S 
typ* 


la a«M lat« 9 «c rM«« •12S..127; 
la iMw incagar; 


pcoeaduca aand^eoatrel<4avte« : 

~ d«c« 

~ unalgaad t bit aacity 

proeaduc* aand^eonctel(davtea : 

~ data 

" unalpnad IS bit aatlcy 

proeadura aaad^eantral(davlea : 

** data 

•• algaad • bit aatlcy 

pcaeadura aand_eantral(davlca : 

~ data 

— algnad l« bit ancity 

pcaeaduca caealva_eantral(daviea 
~ data 

— unaignad • bit aatlty 

pcaeaduca caeaiva^eaatcal(daviea 
*’ data 

•• uaalgaad 1< bit aacity 


pcaeaduca caealva_eantcel(daviea 
~ data 

•• algnad t bit aacity 

pcaeaduca caealva^eaatcal(daviea 
“ data 

— sigaad 1C bit ancity 


la pact_addcaaa; 
la Systaa.byta); 


la pact^addcaaa; 
la SytCM.aaalgaadMacd); 


la pact addcaaa; 
la ll_la_t); 


la pact addcaas; 
in U la ICJ; 


la pact_addcaaa; 
auc Syataa-byta); 


la pact_addraas; 

auc SyaCaa.OnslgnadNacd); 


la part_addraaa; 
aut ll_ia_S»; 


la pact addcass; 
aut ll_la_lCj; 


pclvata 

pcagaa lnllna(sand_eaaccal, caealva_eaaCcel); 
and LON LCVKL 10; 


Tha apaelCleacian aC 10N_LKVCL_Z0 (32 blta) la: 

with SYSTEM; 

paekaga lemjumLJlO la 

aubcypa pact_addcaaa la Syataa.aaalgaadMacd; 

cypa ll_la_B la aaw abacc_latagac caaga -US..127; 
type ll3la_lS la aaw abect^latagar; 

typa ll3la_32 la aaw latagec; 

pcaeaduca aaad_eaatral(daviea : la pacc_addcaas; 

~ data : la SjraCM.Syte); 

— unaignad • bit aatlty 

pcaeaduca aand_eantcal(daviea : la pact_addcaas; 

^ data ; la Syacaa.gaal gn adWacdt; 


232 





DACS*80x86 User's Guide 
Implemeiiution-Dependem Quncieristics 


— UMlgnatf 1< bit Mtity 

pcoMdut* •Md^eentrel (d*vte« : la port_addtasa; 

daea : la SyatM.OaalgnadDHord) ; 

—' ttaaignad 32 bit aacity 

preeaduca saad^ceatreKdavtca : ta pect_addraaa: 

data : la ll_io_tl; 

— algnad t bit antlcy ~ ~ 

ptoeaduta saad_eeatrol (daviea : la pan_addzaas; 

data : la ll_lo_l<) ; 

~ al«nad 1< bit aaeity " ~ 

pcoeaduta aaad^eeatxol(daviea : la part_addraaa; 

data : la ll_le_32); 

— alpnad 32 bit aatlty ~ 

proeaduta raealva_eontral(davlea : la poct^addcaaa; 

~ data : ottt Syataa.Byta); 

~ uaalpnad • bit aatlty 

preeaduca caealva_eoatcel(da«lea : la poct_addrasa: 

^ data : out Syataa.OaslqnadMecd): 

— uaalpnad 1C bit aatlty 

preeaduca caealva_eentrel(davlea : la pert^addraaa; 

~ data : eut Syataa.UaalgaadOWerd); 

~ uealpnad 32 bit aatlty 

preeaduca raealva_eeatral(davlea : la pert_addraas; 

~ data : out llJIe_C); 

— algnad • bit aatlty ~ ~ 

preeaduca raealva^eentrel(davlea : la pert_addraat; 

" data : out llJIo_lS>; 

algnad 1C bit antlty ~ " 

preeaduca caealva^eontrel(davlea : la pert.addraaa; 

data : out ll_le_32); 

•• algnad 32 bit aatlty 


prlvata 

pragaw lnllna(aand_eentrel, raealva^eeatrel); 
and UN XXVU. 10; 


FJ Machine Code Insertions 

The reader should be familiar with the code generation strategy and the 80x86 instruction set to 
fully benefit from this section. 

As described in diapter 13.8 of the APM (DoD 83] it is possible to write procedures containing 
only code statements using the predefined pack^ MACHINE.CODE The package 
MACHINE.CODE defines the type MACHINE_INST11U^0N wducb, used as a record a^regate, 
(tefrnes a machine code insertion. The following sections Ust the type MACHINE_INSTRUCnON 
and types on which it depends, give the restrictions, and show an example of how to use the 
package MACHINE.CODE 


233 




DACS*80x86 User’s Guide 
ImpteBcn mioiHDependem Chanaeristics 


F.9.1 Predefined Types for Machine Code Inserthms 

The following types are defined for use when making machine code inseitions (their type 
declaiaiions are given on the following pages): 

type opcodejype 
type operand.!^ 
type register.t;^ 
type seginent_r^ster 
type maclune.instnictioa 

The type REGISTER.TYPE defines registers. The registers STi describe registers on the floating 
suck. (ST is the top of the floating suck). 

The type MACH1NE.INSTRUCTION is a discriminant record type with which every kind of 
instruction can be described. Symbolic names may be used in the form 

name'ADDRESS 


Restrictions as to symbolic names can be found in section F.9.2. 

It should be mentioned that addresses are specifled as 80386/80486 addresses. In case of other 
targets, the scale factor should be set to "scale.r. 


typ« apced«_cyp« is ( 

— tote lasttueeIona: 


a AAA, 

ai.AAO, 

a_AAM. 

•JUS. 

a_AOC. a_ADD, aJUID, 

a_CALL, 

a CAX.UI. 






“a esM, 

a CLC, 

a CLO, 

a CLZ, 

a CMC, a CW, a CMPS, 

a CMD, aOR 

a^OAS, 

a^OXC, 

a"0ZV, 

a“At, 

a^ZOZV, a~IMOL, a'ZM, 

a^ZMC, aAC 

a“zilTO, 

a~ziun. 

a~JA. 

a JAC, 

a'A, a~JBS. a'A, 

a OCXS, Wa 

a'jQ, 

tTxt, 

a^A, 


a'~JMA. a^JIlAB. a'jMB, 

a JMIS, aJC 

a Mt. 

a JH6, 

a JNSS, 

a Jm. 

a'jRtX, a^JMO. a.J», 

a JMS, aJK 

m~JO, 

a“j*. 

a AC. 

•_JfO. 

a iTS, a JZ, a JMB, 

a^Uir, i^oc 

m~tZS. 

a LSA, 

■.LOCK, 

a^LOOS. 

ajMOr. a'toorc. 


a IpOOMC, 

a LOOfRZ, 





a Loorz, 

a MOV, 

a HOVS, 

mjnt. 

a MBS, a MOP, a NOT, 

a_OR, apcc 

a"»o». 

a“FOfr, 

a rosB. 

a^rosar. 

a^RA. a~RCR, a ROL, 

■.Ren, 

a KKP. 

a ROC, 

a RCra, 

a ACT, 

a'RCtP, a^RCZM, a~RBIMr 


a SAL, 

a~SAR, 

a~SBL, 

a SIR, 

a~SBB. a'SCAS, a STC, 

a_STD, aJBL 

a"sTOS, 

a^soB, 

a TCST, 

a^NAZT, 

a'xCBC, a^XlAZ, a XOR, 



~ •0a7/S0Xt7/S02S7 rloatlaf retat Preeaaaet laatauetleaa: 


■ r«as, 

■ meux, 
aTroiv, 
■~rSADO, 

■~rZMDLO, 

■~rss»i., 

mjnDOl, 

m_not, 

■jmoM. 

■ rsoRz, 

■ rSTSN, 

■~rsaam. 

a~m2XPl. 


■ raoo. 
•"rcoM, 
■“roivo, 

■ riADOO. 
■“rioxva, 
■“rnicsTf, 
■'rssoB, 
aTnocMv, 
fTnoi, 

m rram, 
m~rst, 

■ rsssmx, 

■ rrsT, 

■ raxMi. 


• rwoo, 
■"roow, 
■”roiv», 
aTrzoaN, 
■'‘rZDZVN), 
aTmiinT. 
aTrzsoao, 
tT noi ez. 
nwi*. 

aTnuezn. 
■ ran. 
■~rsiia. 
s'mazT, 


anrasor. aj 


a rozvR,a 
•Tncam,' 
a rzLO. 
a rzsT. 
a nstnm. 
a'ruua. 
a nmo. a 
a ntSZOK,' 
a mcN, a 


.rau, 
rCOHfD. 
'rDZVMD, a 
' a rzeOMT,' 
a~rzi 00 ,a 
a rzsn.a 
a rZSUMO, 
a~nOL2S. 
fWnr. a 

' a rSAVE.a 
rsRUV. a. 


a^nOM, 


nsT?, a reu, 

’rcovr, a.roecsCT, 
'rDzvRP, a rmt, 
a rzccmiT a Fzozv, 
rzm. a rzim. ~ 

'rzsCT, a rzmo. 

a ns, a~rtM. 
a''rUL27.~ a nOTZ, 
a rvATJUir 
rscAZX, a~rsBS*M, 
rsT», m_rnn. 
rsoBR, a rsoBAD. 
a rxsiMcf'. a rmx. 


— •01SC/M2SS/M3SS iMtxvetlons: 

— Meeiea that temm laaadlac* vacslOM ot Cha SOSC 
—• instniettena only axlsc on thooo taxqaca 

— (ahlCts,rotacoa.puah,laaZ....) 


a aoOMO, a CLtS. a URSA. 
a^LZOT, a'LSl., a~OOTS. 


a^ZlIS. a_lAA. a.UAVE, a UOT. 

a^_rWA, a_r0SHA, a_S6DT. »_SZDT, 


234 




DACS*80x86 User's Guide 
Imptenemition-Depemteu Characteristics 


•JU»L. ■_UST, a.uaM. ■_i.ni, 

— 1( bit aliwya... 

■_ 1 UT, ■_SMSM. ■_ST», ■_veiui, ■_VXM>, 

— th« SOSac •pacific Instcttctloaa; 


■ StXA, 

■ SBIAS. 

■ sen. 

■_nTU. ■_SETC. 

■ sen. 

■'sera. 

■'’SKTSK. 

■"sen., 

■ sene, ■" sctna. 

■^seniAe. 

■"smiB, 

■’‘senuB, 

■"seme. 

■~snm. ■^stna. 


■_ssnMS. 

■~stnn.. 

■~SBXMU, 

■_SCtMO, ■_!£»». 

■ SBTMS, 

n sum. 

■ SBTO, 

■"sen. 

■ SetPK, ■ SBTPO. 

■~SBTS. 

T~svtz, 

■'’ssr. 

■~ase. 

■_BT, ■ nc. 

■ IW, 

r“3tS. 

mjLra. 

■"lss. 

■_i,sa, ■~HOvzx, 

,■ Hovm, 

s~MOvai. 

■'hovob. 

■"lovni. 

■_siu. ■" saw. 



— eh* S03S7 specific Inacccccleaa: 


■_nieoM, m_neam, ■ ncomr. ■ rvMMi, ■ rsn. ■ rcos, 

■_rsiscos. ~ ~ “ 

— byta/n ced/dMord variants (to ba used, whan 

— net dadaeeibl* ftea context): 


■ ABCS, 

a ADCN, 

a ABCS, 

a ABBS, 

a ASON, a ABBB, 

■"AMDS, 

■~AMDN, 

a~AMDO, 

■“bw. 

a BTD, ■"bTCN, 

■“STCO, 

a~Bnix, 

a~BntO, 

■~btsn. 

■"btsd, ■"esaa. 

■"CNDX, 

■~CHDW, 

■“CDO. 

■~cmbb. 

m~aOH, m~ OJPB, 

■"CMTSB, 

■~cwsm, 

a CMPSB, 

■~obcb. 

■"oeca, ■~DECD, 

■“divb. 

■~oivn. 

a~OIVD, 

■"IDITB. 

■_IOim, a lOITO, 

a~XHDU, 

■"xmolm. 

■~IMDU), 

■“ nicB, 

a IMCa, ~ a taco. 

■"XSSB, 

a~XHSH, 

a'lMSO, 

■_LCSSB. 

rn^uSSH, ■_10DS&, 

a~MOVB, 

■"movn. 

■"movd. 

a MC’/SB. 

■_MOVSa. ■~HOVSB, 

■~HOVSXB. 

■"movsxn, 

■~MOvzn, 

■"mcvzxn 

a MDIB, ~ a MDia, 

■~MDU, 

■"mbcs. 

tTmas. 

■"mccs. 

■~aoTB, ■~HOia, 

■“koto. 

■"oss. 

■~osn. 

a”o«e. 

■~ooTSB,a omm. 

a OOTSD, 

■~rosN, 

■~MtO. 

a POSBN, 

■_BBiBS, a"SCLB, 

■~seiH, 

■~acto, 

■"sen, 

■~ncim. 

a RCSB, ~ a MOLB, 

■"miH, 

■"sou. 

■"sms. 

■~nom. 

■JtOBB, ■"SALB, 

m’sUM, 

■"sAU3, 

■"SAKS, 

■"sasm. 

a BABB, a SBLB, 

■"satM, 

a saiow. 

■_sbiui. 

■"xasK, 

a SSKM.a SBBS, 

a SSBH, 

a ssso. 

■_scass, 

■"scasm. 

■_SCASB, a"S1QSB, 

a STQSM, 

a SToao, 

a soil. 

a^SOBN, 

■_snBD, a TBStB 

■“tbstw, 

a OATAN, 

■"testo, 

a OATAD, 

a.eon. 

tTxoni, 

■_XOItB, a BAXAB 


-- Special 'inaerueeions*: ■_lab*l. m_twt, 

~ SOSl tasip seal lead/steca_and_pap: ■_nDT, ■jrsWT); 


cracna naca; 

type op*cand_cyp* la ( nona, — 

1—adtata, 
caglatac, 
addcaaa, 
syataa_addxaas. 
nammr 

r*platar_1 ms di ate. 


ra«latac_ra 9 lseac. 
ra9lacar_addcass, 


•ddrass_ra 9 lacar. 


no opaeands 

-- on* Inaadlat* epacand 

— an* caglatar operand 

— on* address epacand 

— an* 'addraas operand 
-* OkU. naa* 

— two eparanda : 

— daaciaacian la 
•— caglatac 

" aoarea la t—a(Mat* 

— two raglscar operands 

— two eparanda : 

— dsatlnaciea la 

— caglatac 

— sottcea la addcaaa 

— two eparanda : 


235 






DACS>8Qx86 User's Cukk 
ImplenenutioiioDepenlem Cbancteristics 


c«9l*c«r_«y«e«a_«edr«a«, 

aysc«i_«ddr«*a_ta«tacae, 

addtaaa_taM(Uata, 

ayataai^aedtaaa ^ twad l ata, 

laiadlata^taglatat. 

laMdlata.laMdtata. 

ca«iaear_r*«latat_laMdiata, 

ta«tatat_ad4x«aa_iaMdlata, 
raqlata^ayataai_addtaaa_^1 aaiaftl ata. 
ad«ttaaa_Aglata^faiHaca, 

ayataM_addraaa_ca 9 latar_ianadlata 


— daatlMtlen la 

— addraaa 

>- aourea la taglaear 
•- tMo apacaada : 

— daaciaatlon la 
•• taylatar 

•• aourea la 'addxaaa 
two operanda : 

— daaciaaclen la 

— ‘addraaa 

— aourea la raglacar 
•- tue oparanda : 

— deaClaatloB la 

— addraaa 

aourea la la«adlaca 

— tue oparaada : 
daatlaatiea la 

» 'addraaa 

•« aourea la IfMdlata 

— oaly allauad far OUT 

— part la laaadlata 
•• aourea la raplatar 

aaly allauad ter 
— DROt 

— allauad far XMOLlai, 

«• sneiaH, snoiaa 

-- allauad far XMDllaa 
— allauad tar nmiaa 

allauad far SlSDlaai, 

•- stlBtm 

— allauad far SISDlaa, 

>• jncias 


type rapiatar typo la (AX. CX, OX. SX. SS, SS. SI. Ui, — uard ra«a 
' ai. a. OL. SL. AX. CH. OS. SB. byta ta«a 

XAX,cex.IDX.nx.BSS.CSr.BSZ.eBZ,— dMrd ra«a 
BS. es, SB. OS. rs. ss. — aalaetera 

BX.SZ. SX_OZ. asjsz, BSJDZ. — SOSC/SOltC/SOZSC eeablaatlaoa 
ST. STl, SS2. ST3, ~ floatlny raplatara (ataek) 

ST4. STS. STS. ST?, 

all); 

•• the aatandad royiatara (]EAX .. OZ) plua rs and (U are only 
•• allauad in S03SS tarsata 

typo aealo_eypa la (aeala_l, aealo_2, aeala_4. aealo_S); 
aubtypa aweblaa_atrlns la atrlngd. .100) ; 


pragaw papa; 

type ■aahlao.laatruetlon (oparand_)ilad : oparand_typa) la 
roeard ~ 

opeeda : opeada^typa; 

eaaa eparaad^klnd la 
uhan laoMdlato •> 

laPMdlatal ; intagar; •- laMdlata 


uhan raglatar >> 

r_ra«lator : raglator^typo; 


aourea and/or daatlaatlen 


uhan addraaa » 

a.aopMnt : eaglatar_typa; — aourea ud/ec daatlaatlon 
a^addraaa^baaa : saglatar_typa; 

a^addraaa^ladax : saglatar^typa; 

a'addraaa_aeala : aeala^ty^; 

a~addraaa_affaat : Intagar; 


uhan ayatoa(_addraaa ■> 

aa_addraaa : ayata«.addraaa; 


daatlaatlen 


236 



OACS*80xiio User's CuiUe 
liwplCBcomioo-Dependeiu Characteristics 


«iM« MM «> 

ii_*trlim : MiehtM_*crlii«: ~ Cku, daatlaMlon 


whM r««*ac*r_lHM41*ta ■> 

; r«9l«cac typa; 
r_l_tMadl«t« : tnca 9 «r;~ 


whan ca«tatar_ragiatar » 
t_r_ca9iatar_to 
tjejcmqlMftJtnm 


ca9latar_typa; 

taglatar~cypa; 


whan raglatac_^addraaa 
r^a_taglatar_tB 
g_a_aa9M B t “ 
r_a~addxaaa_baaa 
c_a~addxaaa~la4ax 
r_a_ad(iraaa_aeaXa 
r_a~aMraaa~ee{act 


caglatar_typa; 

raglatac~typa: 

raglatac^typa; 

^'aglatar^typa; 

aeala^ty^; 

tatayar; 


whan addraaa_ra«latar 
a_r_aa9aanc 
a_r_ad(lraaajbaaa 
a^r^adilraaa^lndax 
a_..'2*^*traaa2aeaXa 
a_r~addraaa~eefaat 
a_t_ragiatat_fro« 


: ra«latac_typa; 
: caglatar~eypa; 
! taglatat“eypa; 
: aeala_ty^; 

: Intagar: 

: ra9tatat_typa; 


whan ta«iatrc_ayat*n_addzaaa •> 

*'.,M_ta9latar_to ~ : ragiatar cypa; 

t^aa^addraaa : aya\.aai.addraaa; 


whan ayaciai_adidtaaa_ra«iatar •> 

a«_r_addraaa : ayataa.addraaa; 

: ta9latat_typa; 


whan addxaaa^lMadlata 
a_l_aagBMnt 
a^l~addraaa^baaa 
a^l^addraaa^lnhax 
a^l^addraaa_aeat.a 
a_i_addraan~of{aat 
a^t^ lM adtata 


: raglatar.typa; 
: ca9taear~typa; 
! ra«latas~cypa.- 
: ae«la_typa; 

; latagar; 

: latagat; 


whaa ayataa_addtaaa lamadlata » 

aa.l.addraaa : ayataai.addraaa; 

aa^l^laMdlata : latagac; 


whan 1 Madlaca^taglatar •> 

l_c_lMadtata : lacagar; 

l_f_P««laear : raglatar_eypa; 

whaa laaMdlata_lMadlata •> 

l_l_lanMdtatal : incagac; 

l_l_iaMdlata3 : tacagar; 


whaa tagiatac_gagiacarj,aaia(liata •» 

: taglatat typa; 
*_e_i_*««i*ta*2 : caglatac~typa; 

g_r_t_ 1w aa d lata : intagar; ” 

whaa ~T«--_•-— - » 

“ : raglatat_typa; 

g_a_l_aagMBt : ragiatM_typa; 

g_h_t_addraaa_baaa ; cagiatM_typa; 
g_h_l_addraaa_ladax : eagiacar typa; 
r_a_t_addxaaa_aeala : aeala t]^; 
c_a_l_addsaaa^oe<aat: Intagac; 
g_a,l_ 1a wa rtt ata : intagar; 

whan raglatar_ayataai_addraaa_laiBadlata -> 

g«*h_t_raglatar T raglatar_typa; 

addrlO : ayataa.addraaa; 

K aa_t_l M a d iata : intagar; 


—' daatlnatloe 
—* aourea 


" daatlnatlon 
— aourea 


— daatl.iatlon 

— aourea 


— daatlnatlon 


— aourea 


— daatlnation 
““ aourea 


— daaeiaation 

— aourea 


— daatlnatlon 


— aourea 


daatlnaeion 
•- aourer 


daatlnatlon 

aourea 


laMdlatal 

lMadlata2 


— daatlnatlon 

— aourcol 
o- aoureaS 


daatlnatlon 
•• aoureal 


— aoureaS 


— daatlnatlon 

— aoureal 
— aourea2 


237 





OACS*80x86 User’s Guide 
Implemenuaon'Dependent Quncteristics 


whm 4ddr«a*_r«4i«tac_laMdlat« •> 

•_r_r ” ■■ — Uaatlaaclon 

a_t_l_addraaajMaa : ra 9 iJt«r,typa; 

a^c^l^**^***-^**^* ■ taqlatar'eypa; 

a_t~l~a<ldr«aa3aeala : aeala_ty^; 

a3r~l~addraaa~a(faac; Intaqat; 

a 30 ~ta 4 tacat : ra 9 latar_typa; — aourcal 

*-^3 3—** -*^* ' Intagar; ~ — aouteal 

whan ayataai_ad4raaa,ra9tatar_laBadlata •> 

aa_^l_addraaa ~ ayaeaa.addraaa; — daacinaeton 

aa_r_l_ra«lacac : raqtatar^typa; — aaureal 

aa_c_l_,iaaMdlata : Intafar; ^ — aouteaS 

whan echasa ••> 
hull; 

and eaaa; 

and racord; 

and BMChlna eeda; 


J Restrictions 

Only procedures, and not functions, may contain machine code inseitions. 

Symbolic names in the form x’ADORESS can only be used in the following cases: 

1) X is an object of scalar type or access type declared as an object, a formal paramerer, or 
by static renaming. 

2) X is an array with sudc constraints declared as an objea (not as a formal parameter or by 
renaming). 

3) X is a record declared as an objea (not a formal parameter or by renaming). 


The m.CALL can be used with "name" to call (for) a routine. 

Two opcodes to harKlle labels have been defined: 

m.label: defines a label. The label number must be in the range i <s x <s 999 and is put 

in the offset field in the first operand of the MACHINE_INSTRU(mON. 

m.reset: used to enable use of more than 999 labels. The label number after a m.RESET 

must be in the range l<s x <» 999. To avoid errors you must make sure that all 
used labels have been defined before a reset, since the reset operation clears all used 
labels. 

All floating instructions have at most one operand which can be any of the following: 

• a memory address 

• a register or an immediate value 

• an entry in the floating stack 


238 








OACS-80xii6 User’s Cuide 
Unplemenution-Dqxndem Characteristics 


FJJ Examples 

kite following section contains examples of how to use the machine code insertions and lists the 
generated code. 


F.9.4 Example Using Labels 

The following assembler code can be described by mac hi ne code inseitions as shown: 

HOV NC,1 
MOV CX,4 

CNT ax.ex 
J6 1 
JE 2 
MOV CX.AX 
1: ADO AX.CX 
2: MOV SS: [aP+DI], AX 

pAckAV* AXMaplajK la 

proeadur* taat_lAbala,- 
praqu Inlina Ttaat_labala) ; 

and axaiapla_MC; 

Hlth HACaitIE_COOe; uaa HACBIKZ_CaOE; 
packaga body"axaavla_MC la ~ 


procadura taac_labala la 
basin 


MACaiME IMSTKOCTIOM' 
HAcaiME* msntoctiON' 
MACBXllE'‘niSt1U>C:tOH' 
HhcnnaTzasTKacTzaif 
HAcazHE'zMsntoctzaN* 
MACHine XHSTROCXXOH' 
MAdlSE ZHSTROCTZOI' 
NACaZHE.ZHSTKOCTION' 
macbine'histxoction' 

MACBZME''iiISTE0C7I0N' 


(gaglacar^lawadlata. 

m MOV, 

AX, 

7); 

(gaylatar^latadl aca. 

•~MOV, 

OC. 

41; 

(raslacac^raslatac. 

■~CW. 

AX, 

CX); 

(t—artlaca. 

*_JS. 

!».• 


(iJMdlata. 

■_ae. 

2); 


(ra«latar_raslatar, 

•_MOV, 

cx. 

AX); 

(iBMdlata, 

■_tabal, 1); 

(ra«latax_ra 9 latar, 

a ADO, 

AX, 

CX); 

(loMdlata, a.labal, 

2T; 



(addraaa_ca 9 latar, 

a MOV, 

as. 

W, 


DI, aeala_ 

I, 0, 


AX); 


and taac_labala; 
and axaBvla_MC; 


F.9£ Advanced Topics 

This section describes some of the more imricaie details of the workings of the madiine 
code insertion facility. Special attention is paid to the way the Ada objects are referenced in 
the machine code body, and various alternatives are rinwn. 


239 








DACS-gOx86 User's Guide 
Implemenution-Dependeru Characteristics 


F.93.1 Address Spcdllcations 

Package MACHINE.CODE provides two alternative ways of specifying an address for an 
instruction. The first way is referred to as SYSTEM.ADDRESS and the parameter associated 
this one must be specified via OBJECT'ADDRESS in the actual MACHINE.CODE insertion. The 
second way closely relates to the addressing which the 80x86 machines employ: an address has 
the general form 

segment:[base-t>index*scale-K>fC5et] 

The ADDRESS type expects the machine insertion to contain values for ALL these fields. The 
default value NIL for segment, base, and index may be selected (however, if base is NIL, so 
should index be). Scale MUST always be specified as scale.l, scale_2. scale_4, or scale_8. For 
16 bit targets, scale.l is the only legal scale choice. The offset value must be in the range of 
-32768 .. 32767. 


F.9,5,2 Referencing Procedure Parameters 

The parameters of the procedure that consists of machine code insertions may be 
referenced by the machine insertions using the SYSTEM.ADDRESS or ADDRESS formats 
explained above. However, there is a great difference in the way in which they may be specified; 
whether the procedure is specified as INLINE or not. 

INLINE machine insertions can deal with the parameters (and other visible variables) using the 
SYSTEM.ADDRESS form. This will be <^t with correctly even if the actual values are 
constants. Using the ADDRESS form in this context will be the user's responsibility since the 
user obviously attempts to address using register values obtained via other machine insertions. It 
is in general not p^ble to load the address of a parameter because an address' is a two 
component structure (selector and offset), and the only instruction to load an inunediate address 
is the LEA, which will only give the offset If coding requires access to addresses like this, one 
cannot INLINE expand the machine insertions. Care should be taken with references to objects 
outside the cunem block since the code generator in order to calculate the proper frame value 
(using the dis{riay in each frame) will apply extra registers. The parameter addresses will, 
however, be calculated at the entry to the INLINE expanded routine to minimize this problem. 
INLINE expanded routines should NOT emfdoy any RET instructions. 

Pure procedure machine insertions need to know the layout of the parameters presented to, in this 
case, the called procedure. In particular, careful knowledge about the way parameters are passed 
is required to achieve a succesful machine procedure. When not INLINE a block is created around 
the call which allows addressing of parameters, and code for exiting the procedure is also 
automatic. 

The user takes over the resptmsibility for correa parameter addressing. The niles of Ada 
procedure calls must be followed. The calling conventions are summarized below. 






DACS*80x86 User's Guide 
Implemeniauon-Oependem Characteristics 


J Parameter Transfer 

It may be a problem to figure out the correa number of words which the paiameieis take up on 
the stack (the x value). The following is a shon description of the transfer method: 

INTEGER types take up at least 1 storage unit 32 bit integer types take up 2 words, and 64 bit 
integer types take up 4 words. In 32 bit targets, 16 bit integer types take up 2 words the low 
word being the value and the high word being an alignment word. TASKs are transferred as 
INTEGER. 

ENUMERATION types take up as 16 bit INTEGER types (see above). 

FLOAT types take up 2 words for 32 bit floats and 4 words for 64 bit floats. 

ACCESS types are considered scalar values and consist of a 16 bit segment value and a 16 or 
32 bit offset value. When 32 bit offset value, the segment value takes up 2 words the high word 
being the aligmem word. The offset word(s) are the lowest, and the segment word(s) are the 
highest. 

RECORD types are always transferred by address. A record is never a scalar value (so no 
post-procedure action is carried out whm the record parameter is OUT or IN OUT). The 
representation is as for ACCESS types. 

ARRAY values are transferred as one or two ACCTSS values. If the array is constrained, only 
the array data address is transferred in the same manner as an ACCESS value. If the array is 
unconstrained below, the data address will be pushed by the address of the constraint. In this 
case, the two ACCESS values will NOT have any alignmem words in 32 bit targets. 

Packed ARRAY values (e.g. STRING types) are transferred as ARRAY values with the addition 
of an INTEGER bit offset as the highest word($); 

+H: BIT_OFFSET 
+L.- DATA_ADDRESS 

<f0: CONSTRAINT.ADDRESS - may be missing 

The values L and H depend on the presence/absence of the consiraim address and the sizes of 
constraint and data addresses. 

In the two latter cases, the form parameter'address will always yield the address of the data. If 
access is required to constraint or bit offset, the instructions must use the ADDRESS form. 


F.9,5.4 Example 

A small example is shown below (16 bit target): 
procedure unsigned.add 


(opl 

: in 

integer; 

op2 

: in 

integer. 

res 

: out 

integer); 


241 







DACS-80x86 User's Guide 
Iraptememadon'Oependem Characteristics 


Notice that machine subprograms cannot be functions. 
The parameters take up: 


opl : integer 1 word 

op2 : integer 1 word 

res : integer 1 word 


Total 3 words 


The body of the precedute might then be the following assuming that the procedure is 
defined at outermost package level: 


preeadur* unaignad^add 

(o^ : la lne*««r; 

ap2 : la latapar; 

raa out latayarl la 


baqla 

pragma abstraet_aeoda_iaaartloaa (trua); 
aa_laacr'(aa_Craata_aieek.3,l,0,0,0t; — 
aa^laacr' <aa~Cad_ef~daelpart, 0,0,0.0,Qt ; 
pragM abacraet_aeoda_laaartleaa(falaa); 


X • 3. y 


1 


maehlaa^laattuetioa' (raglatar_ayacaB_addrasa, 
" ax7 opl'aiddreaa); 

aaehlaa_laatruetlea' (raglatar^ayaeam.addraaa, 
~ rur. epS'addsaaa); 

■achlaa^laatruetloa' (I m mai i lata, 
MChlaa'laattuctloa' <1—arllata, 
Mchlaa^laattuetioa' ( 1— a rtla ta, 
maehlaa^laatnetloa' (ayataai^addraaa^raglsear. 

raa'addtasa. AX); 


•.MOV, 

■_AOD, 

• JMC, 1); 

•~I«r, 5); 

• latoal.l); 
■_MOV, 


pragaM atogcraet.aeada.laaartlaaarenia).’ 
aa.laatr' (aa.tiat.attbprgzM, 0,0,0, all.acg, ali^arg),- — (2) 
aa.laatr'(aa_Sat_blaele.laval,0,0,0,0,0); — yl ■ 0 

pc»5m* al>atraet_aeeda_iaaarcioaa<ealaa); 
aad gnalgaad_add; ~ 


A routine of this complexity is a candidate for INLINE expansion. In this case, no changes to the 
above 'machinejnstiuction' statements are required. Please notice that there is a difference between 
addressing record fields when the routine is INLINE and when it is not: 


type tec is 


record 


low 

: integer. 

high 

end record: 

: imeger. 

procedure add_32 is 


(opl 

: in int^r. 

op2 

: in imeger; 

res 

: out rec); 


The parameters take up 1 * 1 +2 words » 4 words. The RES parameter will be 
addressed directly when INLINE expanded, ix. it is possible to write: 


242 






DACS-80x86 User's Guide 
Im|demenution>Dependem Chancteristics 


inachiiieJiistniction'(system_address_iegister. m^MOV. 

les’address, AX); 

This would, in the not INUNED version, be the same as updating that place on the stack where 
the address of RES is i^aced. In this case, the insenion must read; 

machineJnsuuction'(register_system_address, m_LES, 

SI, res’address): 

~ LES SI,IBP+...] 

machineJnstiuction'(address_register, m_MOV, 

ES. SI, nil, scale.l, 0. AX); 

- MOV ES:[SI+0],AX 


As may be seen, great care must be taken to ensure correa machine code insertions. A help 
could be to first write the routine in Ada, then disassemble to see the involved addressings, and 
finally write the machine procedure using the collected knowledge. 

Please notice that INUNED machine insertions also generate code for the procedure itself. This 
code will be removed when the •oocheck option is applied to the compilation. Also not 
INUNED procedures using the AA.INSTR insertion, which is explained above, will automatically 
get a storage.check call (as do all Ada subprograms). Cn top of that, 8 bytes are set aside in the 
created frame, which may freely be used by the routine as temporary space. The 8 bytes are 
located just below the display vector of the fnune (from SP and up). The storage.check call wiU 
not be generated when the compiler is invoked with •nochcck. 

The user also has the option NOT to create any blocks at all but then he should be certain that 
the return from the routine is made in the proptf way (use the RETP instruction (return and pop) 
or the RED- Again it will help first to do an Ada version and see what the compiler expects to 
be done. 

Symbolic fixups are possible in certain instructions. With these you may build ’symbolic’ 
instructions byte for byre. The instructions involved all require the operand type NAME Oike used 
with CAU.), and the interpretation is the following: 

(name. m.DATAD, "MYNAME”) a full virtual address (offset and selector) of the 

symbol MYNAME (no additional of&et is possiWe). 

(name. m.DATAW, "MYNAME") the offret part of the symbol MYNAME (no additional 

offset is possible). 

(name. m.DATAB, "MYNAME") the selector value of symbol MYNAME 

In inlined machine instructions it may be a problem to obtain the address of a paiameter (rather 
than the value). 'The LEA instruction may be used to get the ofCret part, but now the ftdlowing 
form allows a way to load a selector value as well: 

(system.address, LES. paiam’address) ES is loaded with the sdecnr of PARAM. If this 

sdector was e.g. SS, it would be pushed and popped 
into ES. LES may be subsdiuted for LFS and LGS 
for 80386. 






DACS*80x 86 User’s Guide 
Implementaiion-Depaideiu Characteristics 


F.IO Packafe Taaktypcs 

The TaskTypes packages defines the TaskConoolBlock type. This dau structure could be useful 
in debugging a tasking program. The following package Tasktypes is for all DACS-80x86 except 
for DACS<80386PM/DACS-80486PM. 

with aystw; 
paekAf* TukTypM la 

aubcypa OSSaat la Syataa.OaalgaadMerd; 
anbcyp* aioekXd la Syataa.OaalgaadMord; 

typ* Taakantty la nao Syataa.OaalfiiadNerd; 

typa XatcyXodax la a«w Syataa.OnalpnadMatd; 

typa kltaziMtlvaXd la naw Syataa.OaalgnadMerd; 

typa Tleka la aaa Syataa.tWard; 

eypa Bool la naw ■oelaan: 

fee Bool'alaa uaa S; 

typa OXatg la naa Syataa.OnalgnadMatd; 

typa TaakStata la (Initial, 

— tha caak la ctaatad, but activation 

— haa not atartad yat. 

Xngagad, 

Tha taak haa eallad an antiy, and tha 

— call la now aceaptad, la. tha randaavoua 
—> la In pregraaa. 

Running, 

•- Covata all othat atataa. 

Oalayad, 

Tha taak avalta a tlaMout to aaplta. 

XatxyeallingTlMd. 

Tha taak haa eallad an antcy which 
•> la net yat aeeaptad. 

KatxyCalllngOncondltlonal. 

Tha taak haa eallad an antry unconditionally, 

•• which la net yat aeeaptad. 

Salaetlngtlaod, 

— Tha taak la waiting la a aalaet atataaant 
•> with an epan dalay altacnatlva. 

SalaetlngOneondltlenal, 

Tha taak walta la a aalaet atatwMnt 
aatlealy with aeeapt atataaanta. 

SalaetlngTaralnabla, 

— Tha taak walta In a aalaet atataaant 
•> with an open taiMnata altacnatlva. 

Aeeaptlag. 

Tha taak walta la an aeeapt atataamit. 

Synehcealslag, 

—' Tha taak walta la aa aeeapt atatoaMt 
with no atataoMat Hat. 

Ceaplatad, 

Tha taak haa eaaplatad tha axaeutioa eS 
•• lea atataaant llat, but aet all dapa a daat 
taaka aca taxalaatad. 

Tanalaatad ); 

Tha taak aad all ita daaeaadaata 
—• aca tacaUaatad. 


244 



DACS-80X86 User's Guide 
Imi^emenution-Dependem Chincterisdcs 


(oc TMkSt«e« ua* (Xalelal «> IMOO* . 

Cafayart ••> . 

Ruaalag «> 1S*10« . 

Oalayad ■> ISIlSt , 

SaczyCalllagtlMd •> l<«20« , 
BacryCalllafOneoadlcioaal -> ic«2t* . 
SalaetlaqTlMd » . 

SalaetlafOaeoadltloaal •> 1S«39« , 
SalactiagtaiBlaabla »> 1C«41* , 
Aeeaptlag » 1C94A* , 

Syaehroalalng » 1<«S3« , 

Cea^latad -> 1C9SCI , 

TaciUaatad -> 

(or TaakStaca'sXia oaa t; 


cypa TaakTypaOaaexlpcor la 
raeocd 

priority 
aatry eouaC 
bloek^ld 

(lrat^oMB_addraaa : 

■edula^aiadbar 

aatty^aiMbar 

eoda_addraaa 

ataek^alta 

dusaqf 

ataek^aapaaac_alta: 
aad raeord; ~ 


SyaeoM.Priority; 
OZatg; 

BloekXd; 

Syataat.kddroaa; 

OZatg; 

OXatg; 

Syataai.Addraaa; 

Syata«.ONord; 

Xatogar; 

OXatg; 


typa kccTaaklypa O aaerlptor la aeeaaa TaakTypoOaaerlptor; 
typa VPXSavakraa la array(1..4S) at Syataa.OaaigaadMord; 


typa riagafypa la 
raeord 

lltxrXag : Bool; 

Xatarmptriag : Bool; 
and raeord; 

pragaa pack(FlagaTypat; 


typa Stataatypa la 
raeord 

atata : ZaakJtato; 

ia_abnoxBal : Bool; 

la~aetlvatod : Bool; 

(ailura : Bool; 

aad raeord; 

pragaw paek<StataaTypa); 


typa aer_typa la 
raeord 

kp ; 0((aat; 

addr : Syataa.Addraaa; 

and roeord; 

pragaia paekikcrjcypa) ; 


prag«a paga; 

typa TaakCoatrelBleek la 
raeord 


laMoeltor 


: lyatf. laeaphera; 
; Integer; 


~ Delay goaua handling 

dnoKt ; Syacod.yaakValna ; 
^rew : Syatoa.TaakValoa ; 
ddolay : tleka ; 


— Saved raglatan 


ss 


Syataa.onalgnadNord ; 






DACS-80x86 User's Cukk 
Imp te m c m atioo-Depenitem Ounctehstics 


St : Offaae ; 

— SMdy qnatM lundllay 

naxt : SysCM.tukValu* ; 

.. t—iphora handling 

•«n*xt : syseaa.TMkvaliM ; 

—* trtertty tialda 

priority : Syotaa.priority; 

•«vod_prlonty : Systaa. Priority; 

Mlaeolloaooua riolda 


ciM_tlleo : Syato«.oaal«nodMord; 

riaya : riagstypo; 

RoatfyCooat ; Syataa.iiord; 

~ Stack Spoelfleatlon 


ataek_atart : Offaat; 
ataek_oii4 : Offaat; 

—' Stato riol4a 


atataa 


StatoaTypo; 


—■ Aetlvatloa haadllap flolda 


activator 
aet^ehala 
aoxt_ehaia 
ao_act_aet 
act block 


Syataai. TaakValua; 
Syataai. TaakValuo; 
Syatoa.TaakValua; 
Syataai. Mord.- 
SloekId; 


— Aeeapt quouo tlolda 


partaor : Syataa.TaakValua; 

nmxtjfettMt : Syatoa.TaakValuo; 

•• Satry quouo flolda 

aoxt_callor ; Syatoa.TaakValuo; 

Koadoavoua flolda 


: Syatoa.TaakValuo, 
latogor; 


eallod_taak 

lakayaelT 
taak_aatry 
oatty_ladax 
o«tty~asaoe 
eall.^raaa 
alt_id 
ojiq)_ld 

> Da p oado a cy flolda 

paroatjtaak 
paraatjkloek 
ehlld^task 
aoxt_ehlld 
flratjoblld 
prov eiaid 
ehll3_aet 
blockJMt 
tooBlaatod taak 


TaakCatry; 

■atryladax; 

Syataa.kddroaa; 

Syataa.Addcoaa; 

AltoraatlvaSd; 

Syataa.Sxeoptloald, 


Syatoa.TaakValuo; 

SloekTd; 

Syatoa.TaakValuo; 
Syatoa.TaakValuo; 
Syatoa. Taakvaluo; 
Syataa.Taakvaluo; 
syatoa.aord; 
Syatoa. Hoed; 
Syatoa.TaakValuo; 


Abortloa baadlla« flolda 
buay : Syatoa.Moidi 


246 









DACS-SOxSe User's Guide 
Imptemeiuation-Dependem Quracteristics 


— JUwtllMy tlclda 

ttdi : AecTukTypaOMCtlptoc; 

rtrstCAllae : SyatM.TMkValu*; 

— Run-Tlaa syktai flalda 

ACT : Aer_typ«; — ct- Qs«r'* gulda 9.4.2 

Sorirse ; lnt*g«r; Only uand in IMS 

Snmrirat : Xacngnt: — Only uMd In IMS 

IBleeklnytMk : Systaa.XkakVaiiun; '*■* Only uand la nts 

fSloeklagTaak : SyataB.TaakVaiua; — only aaad la IMS 

eollaetlen : syataa.Mdraaa; 
partltlea : Intaqar; 

TaakCkackLlaUt : Offaat: — to aaauca lallno atocaga ehack 

taatSkcopeioa : Syacaa.OMord; — 2 * IS blta 

SavodAdaMdr : OfSaot; — to iaptevo taadataeua'a 

— RPX aaoo aroa 

— Nhaa cha application la linked with -apK, a apaelal 

— aava axaa foe tba SPX la alloeatad at tha vacy and 

— of ovaey TCB. 

-- la: 

— eaaa iiPX_Praaanc la 

— whan xSoC ■> ffiXaava : MPXSavaaxaa; 

— whan fAX^ •> null; 

" and eaaa; 

and eaeord; 

Tha following la to aaauea that tha TCB haa tha aapaetad alxa: 

TCB^alsa : eonatant IMTXGCR ;■ TaakConteolBloek*alto / S; 

a^lbtypa Tca_ok_'*alua la nntOOR ranga 13S .. 13S; 

TCB_ok r eonatant TCB.ekjralua :> TaakConteolBloek'also / •; 

and TaakTypaa; 


F.11 RMS Tasking (OPTIONAL) 

The DACS-80x86 systems may tun tasking api^cations by means of Rate Monoionic Scheduling 
(RMS). RMS capability is purchased optionally, and is thus not included by defuilt Please contaa 
DDC'I for more infonnaiion regarding RMS and your system. RMS allows the programmer to 
guarantee propenies of a tasking system, i.e. that tasks will meet their hard deadlines. The RMS 
tasking is selected by specifying Hins to the Ada link command. 







