UNCLASSIFIED 


3**a .^r trtd) 


AD-A215 201 


Ada Compiler Validation Summary, Report: Concurrt 

Computer Corporation MC-Ada Version Liz, Concurrent 6600 
with MC68030 CPU, MC68882 Floating Point (Host & Target) 

890818S1■ 10130 _ 

}. AUTHORS) 

National Institute of Standards and Technology 
Gaithersburg, liaryland, USA 

t. ft«FORKING ORGAN 1ZAT ION AMO ADDRESS “ ™ “~“ 

National Institute of Standards and Technology 
Gaithersburg, Maryland, USA 


TflN Ptr,F 11*3 wmumoNS 

1 ___ ttroni co.yp.tToc r ov» 

12. 60 VT ACCESSION NO. 3 RECIPIENTS CATALOG NUMBER 


B TYPE Of REPORT 6 Pi A100 COVERED 

: Concurrent 18 Aug. 1989 to 18 Aug. 1990 


ie. PERfORMlNG^RG. REPORT NUMEtR 


! CONTRACT OP 6PANt NjMEi R(j) 


10. PROGRAM ELEMENT. PROJECT. TASa 
AREA i kOR* UNIT NUMBERS 


II. CON'RO.LING OffICE NAME AND AD0RESS 

Ada Joint Program Office 

United States Department of Defense 

Washington, DC 2D301-3081 

14. MONITORING AGENCr NAME 6 A0DRESS(/f d.fferent from Controlling OH.it) 

National Institute of Standards and Technology 
Gaithersburg, Maryland, USA 

16. 0ISTRIBJTI0N STATEMENT (of thu Report) 


12. REPORT date 


IS. SECtRITt CLASS (Oft^(A report; 

UNCLASSIFIED _ 

IS. ICAT10S OCmngRaoing 

N/A 


Approved for public release; distribution unlimited. 


17. OIS’RIB^TION STA’E“ES' (of tne .brtr.rr e nte ed m B ocfc JO If t) me 't nr from RepolJ 


UNCLASSIFIED 


18. SlAP.Em-N'AS* NG'ES 


DT1C 


DECO 4 13891 


IB . tE ’Nj a GS (Continue on rft’it I Of fnf(fm') *r*d idr niify by block number) 

Ada Programming language, Ada Compiler Validation Summary Report, Ada 
Compiler Validation Capability, ACVC, Validation Testing, Ada 
Validation Office, AVO, Ada Validation Facility, AVF, ANSI/KIL-STD- 
1815A, Ada Joint Program Office, AJPO 

20 ABSTRAC T (Continue on re.erie jibe if neceu.r, «n<j .bentif) by block number) 

Cutveur rent Computer Corporation, MC-Ada Version 1.2, (.aithersnurg, MD Concurrent 6600 
with MC68030 CPU, M.C68882 Floating Point (Host & Target), ACVC 1.10. 


DD >UK * 1473 EDITION O' 1 NOv 6S 15 06SO*E"* 

t JAN 73 SfN 0102-tf-014-6601 


UNCLASSIFIED _ 

SECURITY ClASSW ICAT 10 N or IMIS page (JVnenO.r. fnte'eb) 


%<? // 3 ^ 








Ada Compiler Validation Summary Report: 

Compiler Name: MC-Ada Version 1.2 
Certificate Number: 890818S1.10130 


Host: Concurrent 6600 with MC68030 CPU, MC68882 Floating Point 

under RTU Version 5.0 


Target: Concurrent 6600 with MC68030 CPU, MC68882 Floating Point 

under RTU Version 5.0 

Testing Completed August 18, 1989 Using ACVC 1.10 


This report has been reviewed and i 





Chief, Information Systems 
Engineering Division 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 


approved. 



Ada Validation Facility 
Mr. L. Arnold Johnson 
Manager, Software Standards 
Validation Group 
Engineering Division 
National Computer Systems 
Laboratory (NCSL) 

National Institute of 
Standards and Technology- 
Building 225, Room A266 
Gaithersburg, MD 20899 



/?da Validation Organization 
Dr. John F. Kramer 
Institute for Defense Analyses 
Alexandria VA 22311 



Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 






AVF Control Number: N1ST89CON570_1_1.10 
DATES COMPLETED PRE-VAL 07-13-89 
DATES COMPLETED ON-SITE 08-18-89 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 890818S1.10130 
Concurrent Compute Corporation 
MC-Ada Versior. 1.2 

Concurrent 6600 with MC68030 CPU, MC68882 Floating Point Host 

and 

Concurrent 6600 with MC68030 CPU, MC68882 Floating Point Target 


Completion of On-Site Testing: 
August 18, 1989 


Prepared By: 

Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 










CHAPTER 1 


INTRODUCTION 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1-2 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.1-2 

1.3 REFERENCES.1-3 

1.4 DEFINITION OF TERMS.1-3 

1.5 ACVC TEST CLASSES.1-4 

ru\prva 2 CONFTGURATTn\ T tnfosmatton 

2.1 CONFIGURATION TESTED . 2-1 

2.2 IMPLEMENTATION CHARACTERISTICS.2-2 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.3-1 

3.2 SUMMARY OF TEST RESULTS BY CLASS.3-1 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.3-2 

3.4 WITHDRAWN TESTS.3-2 

3.5 INAPPLICABLE TESTS . 3-2 

3.6 TEST PROCESSING, AMD EVALUATION MODIFICATIONS . .3-5 

3.7 ADDITIONAL TESTING INFORMATION . 3-5 

3.7.1 Prevalidation.3-6 

3.7.2 Test Method.3-6 

3.7.3 Test Site .3-7 


APPENDIX A CONFORMANCE STATEMENT 

APPENDIX B APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 


APPENDIX D 


WITHDRAWN TESTS 


APPENDIX E 


COMPILER OPTIONS AS 
Concurrent Cor.tuter 


SUPPLIED BY 
. l r p o r s. tion 



< Accession For 

u - - -- 

I NTIS OPAil 
DTIC TAB 
Un.um Juucnd 
JuS'. ' T on ' 1 >n 

' By . _ 

^ Distribution/ 

j Avn11 h( 111ty Codss 
,Avail and/or 
Special 



Dlst 


□ □ 

















CHAPTER 1 


INTRODUCTION 


This Validation Summary Report (VSR) describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD -1815A. 
This report explains all technical terms used within it and thoroughly 
reports the results of testing this compile. using the Ada Compiler 
Validation Capability (ACVC). An Ada compiler must be implemented 
according to the Ada Standard, and anv implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 

must be implemented in its entirety, and nothing can be implemented that 

is not in the Standard. 

Even though all validated Ada compilers conform to the Ada Standard, it 

must be understood 'that some differences do exist between 

implementations. The Ada Standard permits some implementation 
dependencies--for example, the maximum length of identifiers or the 
maximum values of integer types. Other differences between compilers 
result from the characteristics of particular operating systems, 
hardware, or implementation strategies. All the dependencies observed 
during the process of testing this compiler are given in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating r he results. The purpose of validating is to ensure 
conformity of the compiler to the Ada Standard by testing that the 
compiler properly implements legal language constructs and that it 
identifies and rejects illegal language constructs. The testing also 
identifies behavior that is implementation dependent, but is permitted 
by the Ada Standard. Six classes of tests are used. These tests are 
designed to perform checks at compile time, at link time, and during 
execution. 


1-1 







1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 


This VSR documents the results of the validation testing performed on an 

Ada compiler Testing was carried out for the following purposes: 

. To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

. To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

. To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 

On-site testing was completed August IS, 1989 at Westford, MA. 

1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO 
may make full and free public disclosure of this report. In the United 
States, this is provided in accordance with the "Freedom of Information 
Act" (5 U.S.C. *552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do 
not represent or warrant that all statements set forth in this report 
are accurate and complete, or that the subject compiler has no 
nonconformities to the Ada Standard other than those presented. Copies 
of this report are available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Pur 3D-139 (Fern Street) 

Washington DC 20301-3081 

or from: 

Software Standards Validation Group 
National Computer Systems Laboratorv 
National Institute of Standards and Technology 
Building 225, R.oom A266 
Gaithersburg, Maryland 20899 

Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 


1-2 




Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.3 REFERENCES 


1. Reference Manual for the Ada Programming Language, 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1586. 

4. Ada Compiler Validation Capability User's Guide, December 1986. 

1.4 DEFINITION OF TERMS 


ACVC The Ada r ompiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to 
the Ada programming language. 

Ada An Ada Commentary contains all information relevant to 

the Commentary point addressed by a comment on the Ada 
Standard. These comments are given a unique 
identification number having the form Al-ddddd. 

Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

Applicant The agency' requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines. 


AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and 
technical support for Ada validations to ensure 
consistent practices. 

Compiler A processor for the Ada language. In the context of 


1-3 







this report, a compiler is any language processor, 
including cross-compilers, trail slators, and 
interpreters. 

Failed test An ACVC test for which the compiler generates a result 

that demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 

Inapplicable An ACVC test that uses features of the language that a 

test compiler is not required to support or may legitimately 

support in a way other than the one expected by the 
test. 

Passed test An ACVC test for which a compiler generates the expected 

result. 

Targer The computer which executes the code generated by the 

compiler. 

Test A piogLam that checks a compiler's conformity regarding 

a particular feature or a combination of features to the 
Ada Standard. In Che context of this report, the term 
is used to designate a single test, which may comprise 
one or more files. 

Withdrawn An ACVC test found to be incorrect and not used to check 

test conformity to the Ada Standard. A test may be 
incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains illegal or 
erroneous use of the language. 

1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name 
identifies the class to which it belongs. Class A, C, D, and F. tests 
are executable, and special program units are used to report their 
results during execution. Class B tests are expected to produce 
compilation errors. Class L tests are expected to produce errors 
because of the way in which a program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal 
Ada programs with certain language constructs which cannot be verified 
at run time. There are no explicit program components in a Class A test 
to check semantics. For example, a Class A test checks that reserved 
words of another language (other than those already reserved in the Ada 
language) are not treated as reserved words by an Ada compiler. A Class 
A test is passed if no errors are detected at compile time and the 


1-4 



program executes to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 

Class B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that every 
syntax or semantic error in the test is detected. A Class B test is 
passed if every illegal construct that it contains is detected by the 
compiler. 

Class C tests check the run time system to ensure that legal Ada 
programs can be correctly compiled and executed. Each Class C test is 
self-checking and produces a PASSED, FAILED, or MOT APPLICABLE message 
indicating the result when it is executed. 

Class D tests check the compilation and execution capacities of a 
compiler. Since there are no capacitv requirements placed on a compiler 
by the Ada Standard for some parameters--for example, the number of 
identifiers permitted in a compilation or the number of units in a 
library--a compiler may refuse to c amp Lie a Class D test and still be a 
conforming compiler. Therefore, if a Class D test fails to compile 
because the capacity of the compiler is exceeded, the test is classified 
as inapplicable. If a Class D test compiles successfully, it is 
self - checking and produces a PASSED or FAILED message during execution. 

Class E tests are expected to execute successfully and check 
implementation-dependent options end resolutions of ambiguities in the 
Ada Standard. Each Class E test is self - checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PA.SSED message, or if it is 
rejected by the compiler for an allowable reason. 

riaad L uuotw _l.~wk that lr. -y i 1 legal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is 
attempted. A Class L test passes if it is rejected at link time--that 
is, an attempt to execute the main program must generate an error 
uiessage before anv declarations in the main program or any units 
referenced by the main program ...re jiabo-ated. In some cases, an 
implementation may legitimately detect errors during compilation of the 
test. 


Two library units, the package ■-EI'.-FT and the procedure CHECK_FILE, 
support the se1f-checking features of the executable tests. The package 
P.FPGRT provides the mechanism 1 y which executable tests report PASSED, 
FAILED, or NOT APPLICABLE results. It also provides a set of identity 
functions used to defeat some compiler optimizations allowed by the Ada 
Standard that would circumvent a test objective. The. procedure 
CHECK FILE is used to check the contents of text files written by some 








of the Class C tests for Chapter 14 of the Ada Standard. The operation 
of REPORT and CHECK FILE is checked bv a set of executable tests. These 
tests produce messages that are examined to verify that the units tie 
operating correctly. If these units are not operating correctlv, then 
the validation is not attempted. 


The text of each test in the ACVC follows conventions that are intended 
to ensure that the tests are reasonably portable without modification. 
For example, the tests make use of only the basic set of 55 characters, 
contain lines with a maximum length of 72 characters, use small numeric 
values, and place features that mav not be supported bv all 
implementations in separate tests. However, some tests contain values 
that require the test to be customized according to 
implementation-specific values--for example, an illegal file. name. A 
list of the values used for thus validation is provided in Appendix 0. 


A compiler must correctly process each of the tests 
demonstrate conformity to the Ada Standard bv either 
criteria given for the test or by showing that the res! 
to the i m pleraenta c i o n . Th e a p p 1 i c a bil itv of 

implementation is considered each time the imp 1ementat i 
A test that is inapplicable for one validation is 

*- P« ti p p 1C «i D a 0 ^ 01 cl S U t> S e ^ U C Pi Cl V ii i. iJiiC COP. . t \ I t C- S Z Z1 1 C 

to contain an illegal language construct or an er 
construct is withdrawn from the ACVC ar.d, therefore, 
testing a compiler. The tests withdrawn at the time o : 


in the suite and 
meeting the pass 
t is inapplicable 

cl t. b S t C O cl P. 

Lon is validated, 
not necessarily 

I t Wci S Cl c 1 till"i. Pit: d 

r o p. a ous 1 a r. gu a r, e 
is not used in 
t this validation 


are piven 


pendix D. 


i. - D 













IMPLEMENTATION CHARACTERISTICS 


2 2 

One of the purposes of validating compilers is to determine the behavior 
of a compiler in those areas of the Ada Standard that permit 
implementations to differ. Class D and E tests specifically check for 
such implementation differences. However, tests in other classes also 
characterize an implementation. The tests demonstrate the following 
characteristics : 


a. Capacities . 


<’ 1) The compiler correctly processes a compilation containing 
123 variables in the same declarative part (See test. 
D29002K.) 

(2; The compiler correctly processes tests containing loop 
statements nested to 63 levels. (See tests D55A03A..H (3 
tests) . ) 

(3; The compiler correctly processes tests containing block 
statements nested to 65 levels, (See test D56001B.) 

(4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 
levels. (See tests D64005E..G (3 tests).) 

b. Universal integer calculations. 

(1) An implementation is allowed to reject universal integer 
calculations having values that exceed SYSTEM. MAX_INT. 
This implementation processes 64-bit integer calculations. 
(See tests D4A002A, D4A002B, D4A004A, and D4A004B.) 


Predefined types. 


This implementation supports the additional predefined 
types SHORT_I N'TEGER, T INY_INTEGER, SHORT_FLOAT in the 
package STANDARD. (See tests B86001T..Z (7 tests).) 


Express ion evaluation. 


The order in which expressions are evaluated and the time at 
which constraints are checked are not defined by the language, 
khile the ACVC tests do not specifically attempt to determine 
the order of evaluation of expressions, test results indicate 
the following: 


2-2 






(1) 


All of the default initialization expressions for record 
components are evaluated before any value is checked for 
membership in a component’s subtype. ^See rest C32117A.) 


(2) Assignments for subtypes are performed with the same 
precision as the base tvpe. (See test C35712B.) 

■3) This implementation uses no extra bits for extra precision 
and uses all extra bits for extra range. (See ‘n_5t 

C33903A.) 

<U) NUMERIC_ERROR is raised ‘or pre- defined integer comparison, 
pre-defined integer membership, LARGE_INT comparison, 
LARCE_INT membership and SKALL_INT comparison and no 
exception is raised for SMALL_1NT membership when an 
integer literal operand in a comparison or membership test 
is outside the range of the base type. (See test C452 j2A.) 

(5) NUMERI C_ERROR is raised by membership test "1.0E19 in 
LIKE_DURAT10K_M23'' aid "2 2EC in MIDDLE_M3" when a 1 iteral 
operanu in a fixed-point comparison or membership test is 
outside the range of the 'ase type. ( r ee test C45252A.) 

(6) Underflow is not gradual. (See tests C45524A..K (11 

tests) . ) 


e. Rounding. 

The method by which values are rounded in type conversions is 
not defined by the language. Wn i 1 e the ACVC tests do not 
specifically attempt to determine the method of rounding, the 
test results indi . _ the following: 


(1) The method used tor rounding to integer is round to even. 
(See tests C46012A..K (11 tests).) 

(2) The method u r ad for rounding to longest integer is round to 
even. (See tests C46012A..K til tests).) 


The method used for rounding to integer in static universal 
real expressions is round to even. (See test C4A014A.) 


f. Array types. 

An implementation is allowed to raise NUMERI C_EE.ROR or 
CQNSTRaINT_ERROR for an array having a 'LENGTH that exceeds 
STANDARD . INTEGER ’ LAST and/or SYSTEM . MAX_INT . Lor this 
implementation: 

d) Declaration of an array type or subtype declaration with 


2-3 







more chan SYSTEM.MAX_INT components raises no exception. 
(.See test C36003A.) 

(2) NUMERIC_ERROR is raised when 'LENGTH is applied to an array 
type with INTEGER'LAST + 2 components. (See test C36202A.) 

(3) NTMERIC_ERROR is raised when 'LENGTH is applied to an array 

type with SYSTEM. MAX_INT + 2 components. (See test 

C36202B.) 

(4) A packed BOOLEAN array having a 'LENGTH exceeding 
INTEGER’LAST raises NUMERIC_ERROR when the array type is 
declared. (See test C52103X.) 

(3) A packed two-dimensional BOOLEAN array with more than 
INTEGER’LAST components raises NUMERIC_ERROR when the array 
type is declared. (See test C52104Y.) 

6) A null array with one dimension of length greater than 
INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAINT_ERROR 
either when declared or assigned. Alternatively, an 
implementation may accept the declaration. However, 
lengths must match in array slice assignments. This 
implementation raises NTMERIC_ERROR when the array type is 
declared. (See test E52103Y.) 

(7) In assigning one-dimensional array types, the expression is 
evaluated in its entirety before COKSTRAINT_ERROR is raised 
when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

(6) In assigning two-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtvpe. (See test C52013A.) 

Discriminated types. 

'1) During compilation, an implementation is allowed to cither 
accept or reject an incomplete type with discriminants that 
is used in an access type definition with a compatible 
discriminant constraint. This implementation accepts such 
subtype indications See test E38104A.) 

•■2) In assigning record types with discriminants, the 
expression is evaluated in its entirety before 
CO.NSTRAI NT_ERROR is raised when checking whether the 
expression's subtvpe is compatible with the target’s 
subtvpe. (See test C.b 2012k.) 








Aggregates. 


(1) In the evaluation of a mul ti - dimens ional aggregate, the 
test results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 

( 2) In the evaluation of an aggregate containing subaggregates, 
all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 

(3) CONSTRAINT_ERROR is raised after all choices are evaluated 
when a bound in a non-null range of a non-null aggregate 
does not belong to an index subtvpe. (See test E43211B.) 

Pragmas. 


(1; The pragma INLINE is supported for functions or procedures. 
(See tests LA3004A..B (2 tests), EA3004C..D (2 tests), and 
CA3004E. .F (2 tests) . ) 

Generics. 

(1) Generic specifications and bodies can be compiled in 

separate compilations. (See tests CA1012A, CA2009C, 

CA2009F, 3C3204C, and BC3205D.) 

(2) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 

(3) Generic subprogram declarations and bodies can be compiled 
in separate compilations. (See tests CA1012A and CA2009F.) 

(4) Generic library subprogram specifications and bodies can be 
compiled in separate compilations, (See test CA1012A.) 

(5) Generic non-library subprogram bodies can be compiled in 
separate compilations from their stubs. (See test 
CA2009F.) 

(6) Generic package declarations and bodies can be compiled in 

separate compilations. (See tests CA2009C, BC3204C, and 

BC3205D.) 

H) Generic library package specifications and bodies can be 
compiled in separate compilations. (See tests BC3204C and 
BC3205D.) 

(8) Generic non-library package bodies as subunits can be 
compiled in separate compilations. (See test CA2009C.) 









(9) Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 

k. Input and output. 

(1) The package SEQUENTIAL_IO can be instantiated with 
unconstrained array tvpes and record types with 
discriminants without defaults. (See tests AE2101C, 
EE2201D, and EE2201E.) 

(2) The package DIRECT_IO can be instantiated with 
unconstrained array types and record types with 
discriminants without defaults. (See tests AE2101H, 
EE2401D, and EE2401G.) 

(3) Modes IN_FILE and OUT_FILE are supported for SEQUENTIAL_IO. 
(See tests CE2102D..E, CE2102N, and CE2102P.) 

(4) Modes IN_FILE, OUT_FILE, and IN'OUT_FILE are supported for 

DIRECT_IO. (See tests CE2102F, CE2102I..J (2 tests), 

CE2102R, CE2102T, andCE2102V.) 

(5) Mode IN_FILE is supported for the operation of CREATE for 
text files. (See test CE3102E.) 

(6) Modes IN_FILE and OUT_FILE are supported for text files. 
(See tests CE3102E and CE3102I..K (3 tests).) 

(7) RESET and DELETE operations are supported for 
SEQUENTIAL_IO. (See tests CE2102G and CE2102X.) 

(8) P-ESET and DELETE operations are supported for DIRECT_IO. 
(See tests CE2102K and CE2102Y.) 

(9) RESET and DELETE operations are supported for text files. 

(See tests CE3102F..G (2 tests), CE3104C, CE3110A, and 

CE3114A.) 

(10) Overwriting to a sequential file truncates to the last 

element written. (See test CE2208B.) 

(11) Temporary sequential files are given names and deleted when 
closed. (See test CE2108A.) 

(12) Temporary direct files are given names and deleted when 

closed. (See test CE2108C.) 

(13) Temporary text files are given names and deleted when 

closed. (See test CE3112A.) 

( 14 ) More than one internal file can be associated with each 


2-6 








external file for sequential files when writing or reading. 
(See tests CE2107A..E (5 tests), CE2102L, CE2110B, and 

CE2111D.) 

(15) More than one internal file can be associated with each 
external file for direct files when writing or reading. 
(See tests CE2107F..H (3 tests), CE2110n and CE2111H.) 

(16) More than one internal file can be associated with each 

external file for text files when writing or reading. (See 
tests CE3111A..B (2 tests), CE3111D..E (2 tests), and 

CE3114B.) 


2-7 








CHAPTER 3 


TEST INFORMATION 


3.1 TEST RESULTS 

Version 1. 10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 329 tests were inapplicable to this implementation. All 
inapplicable tests were processed during validation testing except for 
201 executable tests that use floating-point precision exceeding that 
supported by the implementation. 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 

A 

B 

TEST 

C 

CLASS 

D 

E 

L 

TOTAL 

Passed 

129 

1132 

1992 

17 

28 

46 

3344 

Inapplicable 

0 

6 

323 

0 

0 

0 

329 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 


3-1 







3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 

2 

3 

4 

5 

6 

7 

CHAPTER 
8 9 

10 

11 

12 

13 

14 

TOTAL 

Passed 

198 

57? 

545 

245 

172 

99 

161 

331 

137 

36 

252 

292 

299 

3344 

Inapplicable 

14 

72 

135 

3 

0 

0 

5 

1 

0 

0 

0 

77 

22 

329 

Wdrn 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

371/ 


3.4 WITHDRAWN TESTS 

The following 44 tests were withdrawn from ACVC Version 1.10 at the time 
of this validation: 


A39005G 

B97102E 

C97116A 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A84M 

CD2A84N 

CD2B15C 

CD2D11B 

CD5C07B 

CD50110 

CD7105A 

CD7203B 

CD7204B 

CD7205C 

CD7205D 

CE2107I 

CE3111C 

CE3301A 

ED7006C 

CE3411B 

ED7006D 

E28005C 

ED7004B 

ED7005C 

ED7005D 

Appendix 

D for the 

reason 

that each 

of these 

tests was withdrawn 


3.3 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of 
features that a compiler is not required by the Ada Standard to support. 
Others may depend on the result of another test that is either 
inapplicable or withdrawn. The applicability of a test to an 
implementation is considered each time a validation is attempted. A 
test that is inapplicable for one validation attempt is not necessarily 
inapplicable for a subsequent attempt. For this validation attempt, 329 
tests were inapplicable for the reasons indicated: 

a. The following 201 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAXJ)IGITS: 

C24113L. .Y (14 tests > 

C35706L..Y (14 tests; 

C35708L..Y (14 tests; 


3-2 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 








C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


b. C35702B and B86001U are net applicable because this implementation 
supports no predefined type LON’G_FLOAT. 

c. The following 16 tests are not applicable because this 
implementation does not support a predefined type LONG_INTEGER: 


C4:-i:-lC 

C45504F 

C45632C 

CD/101F 


C4^ ^ n a r 

C45611C 

B52004D 


C45502C 

C45613C 

C55B07A 


C45503C 

C45614C 

B55B09C 


F45504C 

C45631C 

B86001W 


d. C455 31M..P (4 tests), C45532M..P (4 tests) are not applicable 

because this implementation does not support a 48 bit integer 
machine size. 


e. B86001Y is not applicable because this implementation supports no 
predefined fixed-point type other than DURATION. 

f. B86001Z is not applicable because this implementation supports no 
predefined floating-point type with a name other tnan FlOAT or 
SHORT__FLOAT. 

g. CS6G01F is not applicable because, for this implementation, the 

package TEXT_TO is dependent upon package SYSTEM. This test 

recompiles package SYSTEM, making package TEXT_IO, and hence 
package REPORT, obsolete. A link-time error is generated. 

h. C96005B is not applicable because there are no values of type 

DURATION'BASE that are outside the range of DURATION. 

i. CD1009C, CD2A41A, CD2A41B, CD2A41E, CD2A42A, CD2A42B, CD2A42C, 

CD2A42D, CD2A42E, CD2A42F, CD2A42G, CD2A42H, CD2A42I, CD2A42J (14 
tests) are not applicable because this implementation does not 

support 'SIZE representations for floating-point types. 

j. CD2A61I..J (2 tests) are not applicable because this implementation 
does not support size specifications for array types that imply 
compression of component type when the component type is a 
composite or floating point type. This implementation requires an 
explicit size clause on the component type. 

k. CD2A84B..I (8 tests) and CD2A84K..L (2 tests) are inapplicable 

because this implementation does not support size clauses for 
access types. Access types are represented by machine addresses 
which are 32 bits. 


1. CD2A91A..E (5 tests) are not applicable because this implementation 


3-3 








does not support the 'SIZE representation clauses for task types. 

m. CD5003B, CD5003C, CD5003D, CD5003E, CD5003F, CD5003G, CD5003H, 

CD 5011A, CD5011B, CD5011C, CD5011D, CD5011E, CD5011F, CD5011G, 

CD5011H, CD5011L, CD5011M, CD5011N, CD5011Q, CD5011R, CD5012A, 

CD5012B, CD5012C, CD5012D, CD5012E, CD50I2F, CD50I2G, CD50I2H, 

CD5012I, CD5012L, CD5013B, C05O13D, CD5013F, CD5013H, CD50131 

CD50I3N. CD5013R, CD5014T, CD5014U, CD5014V, CD5014W, CD5014X 

(42 tests) are not applicable because this implementation does not 
support 'ADDRESS clauses where a dynamic addresses is applied to a 
variable requiring an initialization. The AVO has ruled that these 
tests may declared to be inapplicable. 

n. CD5012J, CD5013S, CD5014S are not applicable because this 

implementation does not support 'ADDRESS clauses for tasks. The 
host system linker does not support location of object segments or 
of data items. 

o. CE2102D is inapplicable because this implementation supports CREATE 
with IN_FILE mode for SEQUENTIAL_10. 

p. CE2102E is inapplicable because this implementation supports CREATE 
with 0UT_FILE mode for SEQUENTIAL_I0. 

q CF?]0 ?f is -inapplicable because this implementation supports CREATE 
with mode INOUT_FILE for direct access files. 

r. CE2102I is inapplicable because this implementation supports CREATE 
with IN_FILE mode for DIRECT_I0. 

s. CE2102J is inapplicable because this implementation supports CREATE 
with 0UT_FILE mode for DIRECT_I0. 

t. CE2102N is inapplicable because this implementation supports OPEN 
with IN_FILE mode for SEQUENTIAL_IO. 

u. CE2102O is inapplicable because this implementation supports RESET 
with IN_FILE mode for SEQUENTIAL_10. 

CE21C2? is inapplicable because this implementation supports OPEN 
with 0UT_FILE mode for SEQUENTIAL_I0. 

w. CE2102Q is inapplicable because this implementation supports RESET 
with 0UT_FILE mode for SEQUENTIAL_10. 

x. CE2102R is inapplicable because this implementation supports OPEN 
with mode IN0UT_FILE for direct access files. 

V. CE2102S is inapplicable because this implementation supports RESET 
with IN0UT_FILE mode for DIRECT_I0. 

2 . CE21G2T is inapplicable because this implementation supports OPEN 


3-4 











with IN_FILE mode for DIRECT_IO. 

aa. CE2102" is inapplicable because this implementation supports RESET 
with 1N_FILE mode for DIRECT_IO. 

ab. CE2102V is inapplicable because this implementation supports OPEN 
with OUT_FILE mode for DIRECT_IO. 

ac. CE2102W is inapplicable because this implementation supports RESET 
with OUT_FILE mode for DIRECT_IO. 

ad. CE3102E is inapplicable because text file CREATE with IN_FILE mode 
is supported by this implementation. 

ae. CE3102F is inapplicable because text file RESET is supported by 
this implementation. 

af. CE3102G is inapplicable because text file deletion of an external 
file is supported by this implementation. 

ag. CE3102I is inapplicable because text file CREATE with Ol’T_FILE mode 
is supported bv this implementation. 

ah. CE3102J is inapplicable because text file OPEN with IN_FILE mode is 
supported by this implementation. 

ai. CE3102K is inapplicable because text file OPEN with OUT_FILE mode 
is not supported by this implementation. 

aj . CE3115A is inapplicable because this implementation does not 

support RESET to mode OUT_FILE when another internal file is 
associated with the same external file which is opened to mode 
IN FILE. 


3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases 
where legitimate implementation behavior prevents the successful 
completion of an (otherwise) applicable test. Examples of such 
modi, .cations include: adding a length clause to alter the default size 
of a c/.lection; splitting a Class B test into subtests so that all 
errors are detected; and confirming that messages produced by an 
executable test demonstrate conforming behavior that was not anticipated 
by the test (such as raising one exception instead of another). 

No modifications were required for any tests. 

3.7 ADDITIONAL TESTING INFORMATION 


3-5 








3.7.1 Prevalidacion 


Prior co validation, a set of test results for ACVC Version 1.10 
produced by the MC-Ada Version 1.2 was submitted to the AVF by the 
applicant for review. Analysis of these results demonstrated that the 
compiler successfully passed all applicable tests, and the compiler 
exhibited the expected behavior on all inapplicable tests. 


3.7.2 Test Method 


Testing of the MC-Ada Version 1.2 compiler using ACVC Version 1.10 was 
conducted on-site by a validation team from the AVF. The configuration 
in which the testing was performed is described by the following 
designations of hardware and software components: 


Host computer: 

Host operating system: 
Target computer: 

Target operating system: 
Pre-linker: 

Linker: 


Concurrent 6600 with MC68030 CPU, 
MC68882 Floating Point 
RTU Version 5.0 

Concurrent 6600 wiun MC68030 CPU, 
MC68882 Floating Point 
RTU Version 5.0 
a. Id 
Id 


A magnetic tape containing all tests except for withdrawn tests and 
tests requiring unsupported floating-point precision was taken on-site 
by the validation team for processing. Tests that make use of 
implementation-specific values were customized before being written to 
the magnetic tape. 


TEST INFORMATION 

The contents of the magnetic tape were loaded directly onto the host 
computer. 

After the test files were loaded to disk, the full set of tests was 
compiled and linked on the Concurrent 6600 with MC68030 CPU, MC68882 
Floating Point, and all executable tests were run on the Concurrent 6600 
with MC68030 CPU, MC68882 Floating Point. Results were printed from the 
host/target computer. 

The compiler was tested using command scripts provided by Concurrent 
Computer Corporation and reviewed by the validation team. See Appendix 
E for a complete listing of the compiler options for this 
implementation. The compiler options invoked during this test were: 

-M -01 (invoked by default) 

Tests were compiled, linked, and executed (as appropriate) using a 


3-6 












single computer. Test output, compilation listings, and job logs were 
captured on magnetic tape and archived at the AVF. 


3.7.3 Test Site 

Testing was conducted at Westford, MA and was completed on 
1989. 


August 18, 


3-7 








Appendix A 

Declaration of Conformance 

Compiler Lmplementer: 

Concurrent Computer Corporation 

Ada Validation Facility: 

U.S. Department of Commerce 

National Institute of Standards and Technology 

Gaithersburg, MD 20899 

ACVC Version: 

1.10 


Base Configurations 

Base Compiler Name' 

MC-Ada Version 1.2 

Host .Architecture: 

Concurrent 6600 with MC68030 CPU. 

Lightning Floating Point, running 

RTU Version 5.0 

Target Architecture: 

Same 


Babe Compiler Name: MC-Ada Version 1.2 

Host Architecture: Concurrent 6600 with MC68030 CPU, 

MC6S882 Floating Point, running 
RTU Version 5.0 


Taraet Architecture: 


Same 









Derived Compiler Registration 


Base Compiler Name: 
Host Architecture: 


Target Architecture: 


MC-Ada Version 1.2 

Concurrent 6000 series with MC68030 CPU, 
Lightning Floating Point, running 
RTU Version 5.0 

Same 


Base Compiler Name: 

MC-Ada Version 1.2 

Host .Architecture: 

Concurrent 6000 series with MC68030 CPU, 
MC68882 Floating Point, runni: g 

RTU Version 5.0 

Target .Architecture: 

Same 

Base Compiler Name: 

MC-Ada Version 1.2 

Host Architecture: 

Concurrent 5000 series with MC68020 CPU, 
Lightning Floating Point, running 

RTU Version 5.0 

Target Architecture: 

Same 


Base Compiler Name: MC-Ada Version 1.2 

Host Architecture: Concurrent 5000 senes with MC68020 CPU, 

MC68881 Floating Point, running 
RTU Version 5.0 


Tanzet Architecture: 


Same 













Implemented s Declaration 


We, the undersigned, representing Concurrent Computer Corporation have implemented 
no deliberate extensions to the Ada Language Standard ANSI/MIL-STD-1815A in the compiler 
listed in this declaration. We declare that Concurrent Computer Corporation is the owner of 
record of the Ada language compiler listed above and, as such, is responsible for maintaining 
said compiler in conformance to ANSI/MIL-STD-1815A. All certificates and registrations for 
the Ada language compiler iisted in this declaration shall be made only in the owner’s name. 

c/fh 

Clark D’Hlia 

Director, Software Development 



_ _X. /_ 

Bruce Lutz 
Senior Engineer 
Languages 



Owner's Declaration 


We, the undersigned, representing Concurrent Computer Corporation take full responsi¬ 
bility for implementation and maintenance of the Ada compiler listed above, and agree to the 
public disclosure of the final Validation Summary Report. We further agree to continue to com¬ 
ply with the Ada trademark policy, as defined by the Ada Joint Program Office. We declare that 
all of the Ada language compiler listed, and their host/target are in compliance with the Ada 
Language Standard ANSI/MIL-STD-1815A. We have reviewed the Validation Summary 
Report for the compiler and concur with the contents. 

Clark D’Elia 

Director, Software Development 



Bruce Lutz 
Senior Engineer 
Languages 
















APPENDIX B 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of the MC-Ada Version 1.2 
compiler, as described in this Appendix, are provided by Concurrent 
Computer Corporation. Unless specifically noted otherwise, references in 
this appendix are to compiler documentation and not to this report. 
Implementation-spec ific portions of the package STANDARD, which are not 
a part of Appendix F, are: 


package STANDARD is 


type INTEGER is range -21474S3648 .. 2147483647; 
type SKORT_INTEGER is range -32768 .. 32767; 
type TINY_INTEGER is range -123 .. 127; 
type FLOAT is digits 15 range 

-1.79769313486232E308 .. 1.79769313486232E308; 
type SHORT_FLOAT is digits 6 range -3.40282E38 .. 3.40282E38; 

type DURATION is delta 1.0E-3 range -2.147483648E6 .. 2.147483648E5; 


end STANDARD; 


3-1 











ATTACHMENT I 


APPENDIX F. Implementation-Dependent Characteristics 


1. Implementation-Dependent Pragmas 
1.1. INLINEONLY Pragma 

The INLINE_ONLY pragma, when used in the same way as pragma INLINE, indicates to the compiler 
that the subprogram must always be mimed. This pragma also suppresses the generation of a callable ver¬ 
sion of the routine which save code space. 

I .2 . BUILTJN Pragma 

The BLTLT_IN pragma is used in the implementation of some predefined Ada packages, but provides no 
user access. It is used only to implement code bodies for which no actual Ada body can be provided, for 
example the MaCHINE_CODE package. 

1 J . SHaRE CODE Pragma 

The SHARE_CODE pragma takes the name of a generic instantiation or a generic unit as the first argument 
and one of the identifiers TRUE or FALSE as the second argument. This pragma is only allowed immedi¬ 
ately at the place of a declarative item in a declarative part or package specification, or after a library unit 
in a compilanon, but before any subsequent compilation unit 

When the first argument is a generic unit the pragma applies to all instantiations of that generic. When the 
first argument is the name of a generic instantiation the pragma applies only to the specified instantiation, 
or overloaded instantiations. 

If the second argument is TRUE the compiler will try to share code generated for a genenc instantiation 
with code generated for other instantiations of the same generic. When the second argument is FALSE 
each instanuation will get a unique copy of the generated code. The extent to which code is shared 
between instantiations depends on this pragma and the kind of genenc formal parameters declared for the 
genenc unit. 

The name pragma SHARE_BODY is also recognized by the implementation and has the same effect as 
SHARE_CODE. It is included for comparability with earlier versions of V ADS. 

I .4 . NOJMAGE Pragma 

The pragma suppresses the generation of the image array used for the IMAGE attnbute of enumerauon 
types. This eliminates the overhead required to store the array in the executable image. 

1 .5 . EXTERNAL_NAME Pragma 

The EXTERNAL_NAME pragma takes the name of a subprogram or variable defined in Ada and allows 
the user to specify a different external name that may be used to reference the enuty from other languages. 
The pragma is allowed at the place of a declarative item in a package specification and must apply to an 
object declared earlier in the same package specification. 

1 .6 . INTERFACE_NAME Pragma 

The INTERFACE_NAME pragma takes the name of a variable defined in another language and allows it 
to be referenced directly in Ada. The pragma will replace all occurrences of the variable name with an 
external reference to the second, link_argument The pragma is allowed at the place of a declarauve item 
in a package specification and must apply to an object declared earlier in the same package specification. 
The object must be declared as a scalar or an access type. The object cannot be any of the following: 
a loop variable, 










a constant, 

an initialized variable, 
an array, or 
a record. 

1.7 . IMPLICITCODE Pragma 

Takes one of the identifiers ON or OFF as the single argument. This pragma is only allowed within a 
machine code procedure. It specifies that implicit code generated by the compiler be allowed or disal¬ 
lowed. A warning is issued if OFF is used and any implicit code needs to be generated. The default is ON. 

2 . Implementation of Predefined Pragmas 
2 .1. CONTROLLED 

This pragma is recognized by the implementation but has no effect. 

22. ELABORATE 

This pragma is implemented as described in Appendix B of the Ada RM. 

2 J . INLINE 

This pragma is implemented as described in Appendix B of the Ada RM. 

2 .4 . INTERFACE 

This pragma supports calls to ’C’ and FORTRAN functions. The Ada subprograms can be either functions 
or procedures. The types of parameters and the result type for functions must be scalar, access or the 
predefined type ADDRESS in SYSTEM. Record and array objects can be passed by reference using the 
ADDRESS attribute. 

2i. LIST 

This pragma is implemented as described in Appendix B of the Ada RM. 

2 .6 . MEMORY_SIZE 

This pragma is recognized by the implementation. The implementauon does not allow SYSTEM to be 
modified by means of pragmas, the S YSTEM.package must be recompiled. 

2 .7 . OP1TMIZE 

This pragiT a is recognized by the implementation but has no effect 
2 .3 . PACK 

This pragma will cause the compiler to choose a non-aligned representauon for composite types. It wiil not 
causes objects to be packed at the bit level. 

2 .9 . PAGE 

This pragma is implemented as described in Appendix B of the Ada RM. 

2 .10 . PRIORITY 

This pragma is implemented as described in Appendix B of the Ada RM. 

2 .11 . SHARED 

This pragma is recognized by the implementauon but has no effccL 












2.12. STORAGE_UMT 

This pragma ls recognized by the implementation. The implementation does not allow SYSTEM to be 
modified by means of pragmas, the SYSTEM package must be recompiled. 

2 .13 . SUPPRESS 

This pragma is Implemented as described, except that RANGE_CHECK and D1VISI0N_CHECK cannot 
be suprcssed. 

2.14. SYSTEM_NAME 

This pragma is recognized by the implementation, rhe implementation does not allow SYSTEM to be 
modified by means of pragmas, the SYSTEM package must be recompiled. 

3. Implementation-Dependent Attributes 

3 .1 . P’REF 

For a prefix that denotes an object, a program unit, a label, or an entry: 

This attribute denotes the effective address of the first of the storage units allocated to P. For a subpro¬ 
gram, package, task unit, or label, it refers to the address of the machine code associated with the 
corresponding body or statement. For an entry for which an address clause has been given, it refers to the 
corresponding hardware interrupt. The attribute is of the type OPERAND defined in the pxkace 
MACHINE_C^DE. The attribute is only allowed within a machine code procedure. 

See section F.4.8 for more information on the use of this attribute. 

(For a package, task unit, or entry, the ’REF attribute is not supported.) 









4 . Specification Of Package SYSTEM 


packag* SYSTEM 
i a 

type SMC ib ( exm i» camp.ua i * ); 


SYSTHM^SMC 


coni tint SMC • a* a ■ cora*_un i a ; 


STORAGE.UNIT 
NCNORY.S IZE 


com i mt : • 8 ; 

com not : m 16_777_216; 


-• Syatera-Dapandent Named Number a 


MIS 1ST 
MOC.JVT 
MOC.DIOITS 
MCC .MANTISSA 
PISE DELTA 
TICK 


com t bo 

COBB t BD 

com t BO 
com x an 

COBB IBS 

coqb tin 


• 2_147>«3_64* ; 
2_147_4I3_647; 
15: 

31; 

2.<>••( -31 ) ; 
0.0166666; 


-• Otbar Syitcm-depondent Decltrillorn 


aubtypa WtlQRITY it INTEGER rani* 0 . 99; 


M*JC_R£C_$|Z£ ; iat• |«r « 64-1024; 


typi ADDRESS ts pn«ita; 
ND.aDOR : com tint ADDRESS ; 


fuaeiion PHYS I CAL .ADDRESS ( l : INTEGER) rouin ADDRESS ; 

f one t ton ADDR_GT( A, B: ADDRESS) rturn BOOLEAN; 

fuoction ADOR_LT(A. B: ADDRESS) retsrn BOOLEAN; 

function ACDR_GE(A. B: ADDRESS) return BCDLEAN; 

function ADDR_LB (A. B: ADDRESS ) return BOOLEAN; 

function ADOR_DIFP(A, B: ADDRESS) return INTEGER; 

function !NCR_ADCR( A: ADDRESS; INCR: INTEGER) return ADDRESS; 

f*!nr» ton DSCRJCCR'A: ADDRESS; D€<R: INTEGER) return ADDRESS; 

function •>’(A, B: ADDRESS) return BOOLEAN rsouva ADDR.QT; 

function *<*(A. B; ADDRESS) return BOOLEAN rename a MX)R_LT; 

function ’>«*(A t B; ADDRESS) retarn BOOLEAN rooitDBi ADDR.GE; 

function B: ADDRESS) return BOOLEAN renames ADDR.LE; 

function •-•(A, B: ADDRESS) rotorn INTEGER rename s aCOR_DIFP; 

function •♦ , (A: ADDRESS; I N>CR: INTEGER) return ADDRESS rename a INCR.ADDR: 

function '-’fA: ADDRESS; DECR; INTEGER) return ADDRESS renames DEGR.aDDR; 

pr a pna ml me ( PHYS ICAL.ACDRESS ) ; 
pragma in1 ino(ADOR.GT) ; 
pragma ml ine(ADOR.LT) ; 
p r a gxm ml i no ( ADOR.GE) ; 
p r a gme i n I i ue (ADDR.LE) ; 
pragzne inli do(ADDR.DIPF); 
pragma ml ine( INCR.ADOR) ; 
pragma ml ino(DECR. aOCR) ; 

private 


type ADDRESS ia new integer; 
NO.ADCR conatant ADDRESS :■ 0; 
end SYSTEM; 


5 . Restrictions On Representation Clauses 
5 .1 . Pragma PACK 

In the absence of pragma PACK record components are padded so as to provide for efficient access by the 
target hardware, pragma PACK applied to a record eliminate the padding where possible. Pragma PACK 
has no other effect on the storage allocated tor record components a record representation is required. 

5 .2 . Record Representation Clauses 

For scalar types a represenauon clause will pack to the number of bits required to represent the range of the 
subtype. A record representation applied to a composite type will not cause the object to be packed to fit in 
the space required. An explicit representauon clause must be given for the component type. .An error will 
be issued if there is insufficient space allocated. 


















5 J . Address Clauses 

Address clauses are supported for variables and constants. 

5 .4. Interrupts 

Interupt entries are not supported. 

5 -5 . Representation Attributes 

The ADDRESS attribute is not supported for the following entities: 

Packages 

Tasks 

Labels 

Entries 

5 6 . Machine Code Insertions 
Machine code insertions are supported. 

The general definition of the package MACH1NE_C0DE provides an assembly language interface for the 
target machine. It provides the necessary record type(s) needed in the code statement, an enumeration type 
of ail the opcode mneumorfics, a set of register definitions, and a set of addressing mode functions. 

The general syntax of a machine code statement is as follows: 

CODE_n’( opcode, operand [.operand] ); 

where n indicates the number of operands in the aggregate. 

A special case arises for a variable number of operands. The operands are listed within a subaggregate. 
The format is as follows: 

CODE_N’( opcode, (operand (, operuna\) y. 

For those opcodes that require no operands, named notation must be used (cf. RM 4.3(4)). 

CODE_0’( op => opcode ); 

The opcode must be an enumeration literal (i.e. it cannot be an object, attribute, or a rename). 

An operand can only be an entity defined in MACHINE_CODE or the 'REF attribute. 

The arguments to any of the functions defined in MACH3NE_CODE must be stauo expressions, string 
literals, or the funcuons defined in MACHINE_CODE. The 'REF attribute may not be used as an argu¬ 
ment in any of these functions. 

Inline expansion of machine code procedures is supported. 










6 . Conventions for Implementation-generated Names 
There are no implementation-generated names. 


7 . Interpretation of Expressions in Address Clauses 
Address clauses are supported lor constants and variables. 

8 . Restrictions on Unchecked Conversions 
None. 

9 . Restrictions on Unchecked Deallocations 
None. 


10 . Implementation Characteristics of I/O Packages 

Instantiations of DERECTJO use the value MAX_REC_S IZE as the record size (expressed in 
STORAGE_UNTTS) when the size of ELEMENT_TYPE exceeds that value. For example for uncon¬ 
strained arrays such as string where ELEMENT_TYPE*SIZE is very large, MAX_R£C_SIZE is used 
instead. MAX_RECORD_SIZE is defined in SYSTEM and can be changed by a program before instan¬ 
tiating DIRECT_IO to provide an upper limit on the record size. In any case the maximum size supported 
is 1024 x 1024 x STORAGE_UNIT bits. DIRECT JO will raise USE_ERROR if MAX_REC_SIZE 

~.4~ i:—;♦ 

crtuvwo uuj uuot/ituu utiuu 

Instantiations of SEQUENTLALJO use the value MAX_REC_SIZE as the record size (expressed in 
STORAGE_UNITS) when the size of ELEMENT_TYPE exceeds that value. For example for uncon¬ 
strained arrays such as string where ELEMENTJTYPE’SIZE is very large, MAX_REC_SIZE is used 
instead. MAX_RECORD_SIZE is defined in SYSTEM and can be changed by a program before instan¬ 
tiating INTEGER JO to provide an upper limit on the record size. SEQUENTIALJO imposes no limit on 
MAX_REC_SIZE. 


11 . Implementation Limits 

The following limits are actually enforced by the implementation. It is not intended to imply that resources 
up to or even near these Limits are available to every program. 


11.1. Line Length 

The implementation supports a maximum line length of 500 characters including the end of line character. 

11 .2 . Record and Array Sizes 

The maximum size of a stancaily sized array type is 4,000,000 x STORAGE JJNTTS. The maximum size 
of a statically sized record type is 4.000,000 x STORAGE JJNITS. A record type or array type declarauon 
that exceeds these limits will generate a warning message. 

11-3. Default Stack Size for Tasks 

In the absence of an explicit STORAGEJ5IZE length specification every task except the main program is 
allocated a fixed size stack of 10,240 STORAGEJJNITS. This is the value returned by 
T’STORAGE_SIZE for a task type T. 

11 .4 . Default Collection Size 

In the absence of an explicit STORAGE JilZE length attribute the default collection size for an access type 
is 100 times the size of the designated type. This is the value returned by T’STORAGE JSIZE for an 











access type T. 


11 _5. Limit on Declared Objects 

There is an absolute Limit of 6,000,000 x STORAGE_UNTTS for objects declared statically within a compi¬ 
lation unit. If this value is exceeded the compiler will terminate the compilation of the unit with a FATAL 
error message. 











APPENDIX C 
TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, 
such as the maximum length of an input line and invalid file names. A 
test that makes use of such values is identified by the extension ,TST 
in its file name. Actual values to be substituted are represented by 
names that begin with a dollar sign. A value must be substituted for 
each of these names before the test is run. The values used for this 
validation are given below. 


C-l 









ATTACHMENT III 

Values Needed as Parameters for the “* .TST” Tests 


-- MACRO.DEFS 

-- THIS FILE CONTAINS TIE MACRO DEFINITION'S USED IN TIE ACYC TESTS. 

-- THESE DEFINITION'S .ARE FOR. 

- - .VC-Ad» Version 1.2 

- - SMAX IN LEN 

-- AN INTEGER LITERAL GIVING TIE MAXIMUM LENGTH PERMITTED BY TIE 
-• OEMPILER FOR A LINE OF ADA SOURCE CODE (NOT INCLUDING AN END-OF-LINE 

• • CHARACTER). 

-- USED IN: A26007A 
MAX.IN_LEN 499 

• - SBIG ID1 

-- AN IDENTIFIER IN WHIOI THE NUMBER OF CHARACTERS IS SMAX. IN_LEN. 

•• USED IN: C23003A C23003B C23003C B23003D B23003E C23003G 

C23003H C23003I C23003J C33502D C35502F 

BIG_ID1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
'.AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 

VwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAA 1 

-- SBIG_ID2 

-- AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS SMAX IN LEN. 

-- DIFFERING FRCM SBIG ID1 ONLY IN THE LAST CHARACTER. 

-• USED IN: C23003A C23003B C23003C 323003F C23003G C23003H 

C23003I C23003J 

BI G_ ID2 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

4 4 aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\ 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAA2 

-- SBIG_ID3 

-- AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS SMAX. IN.LSN. 

-- USED IN: C23003A C23003B C23003C C23003G C23003H C23003I 

C23003J 

B IG_ ID3 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVAAAAAA 

AAAAAAAAAAAAXAAAAAAAAAAAAAAAAAAAAAAAAWVWv-V. lAfV •_-VA-wC.. ^ AAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAWUMkAAAAAAAAAAAAAAAAAAAAVAAAAUAA 
AAAAAAAAAAAAAAAAA 3 AAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVAAVAV\AAAAV\AAAAAAAAAAAAAAAAAAAAAAAAAAXA\AAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVAVAAAAAAAAAAAAAAAVAAAAAAAVAAAAAVAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAA 

■- SBIG.ID4 

AN IDENTIFIER IN WHICH THE NUMBER OF CHARACTERS IS SMAX. IN.LEN. 

DIFFERING FRCM S3IG.ID3 ONLY IN HIE MIDDLE CHARACTER. 

•• USED IN: C23003A C23003B C23003C C23003G C23003H C23003I 

C23003J 

3IG.ID4 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAMAVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAA.AAAA 4 AAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'AUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 




AAAAAAAAAAAAAAAAAAA 


SBIG.STRINGl 

■ A STRING LITERAL CWITH QUOTES) WHOSE CATENATION WITH SBIG STRING: 

• i SBIG STRING I i SBIG.STRINGZ) PRODUCES TIE IMAGE OF SBIG ID!. 

■- USED IN C3550:D C3550IF 

3 IG_STR ING1 taaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa " 


-■ SBIG string: 

-- A STRING LITERAL ['WITH QUOTES) WHOSE CATENATION WITH SBIG.STRINGl 
- - ( SBIG_STRING1 & SBIG STRING2) PRODUCES THE IMAGE OF SBIG IDl. 

■- USED IN: C35502D C35502F 

3IG_STRING2 " AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 
.AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 1 " 

-- SMAX.STRING.LITERAL 

•- A STRING LITERAL OCNSISTING OF SMAX.TN.LEN GIARACTERS ; INCLUDING THE 
• - QUOTE CHARACTERS ) . 

■ - USED IN: A26007A 

MAX _ S TRING _ LITERAL ” AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA-UAAAAAAAAAAAAAA-VAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAA.AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'AAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 

AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA " 

-- SNEG.BASED.INT 

-- A BASED INTEGER LITERAL [ PREFERABLY BASE S OR 16) WHOSE HI CHEST 'ORDER 
-• NON-ZERO BIT WOULD FALL IN THE SICN BIT POSITION OF THE 
-- REPRESENTATION FOR SYSTEM.MAX. I NT. T.E.. AN ATTEMPT TO WRITE A 
-- NEGATIVE VALLED LITERAL SUCH AS -2 BY TAKING ADVANTAGE OF THE 
3IT REPRESENTATION. 

-- USED IN: E24201A 
NEG.3ASED.INT 16<»FFFFrFFD# 

SBIG.INT LIT 

-- AN INTEGER LITERAL WHOSE VALLE IS 29 8. BUT WHIOI HAS 
-- ( SMAX. IN.LEN - 3) LEADING ZEROES. 

USED IN: C24003A 

3 IG_INT.LIT 0000000000000000000000000000000000000000000000000000000000000000.3000 
30000000000000000000000000000000000000000000000000000000000000000000000000000000 
30000000000000000000000000000000000000000000000000000000000000000000000000000000 
00000000000000000000000000000000000000000000000000000000000000000000000000000000 
lOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOCOOOOOOCOOOOOOOOOOOOOOOOOOOO 
OOCCOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO 
ooor 00000000000300000000000029 8 

IBIG.RF.AL.LIT 

- a UNIVERSAL.REAL LITERAL WHOSE VALUE IS 690 J. BUT WHIG! HAS 
-- SMAX.IN.LEN - 5) LEADING ZEROES. 

-- USED ?N■ C24003B C24003C 

3IG_REAL_„IT 

oooooooooooooooooooooooooooouoooooooooocoooooooooooooooooooooooooooooooooooooooo 
oonooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooc .000000000 
oooocooooooooooooooooooonoooooooooooooooooooooooooooooooooooooooooooooooooooooo 
Tooooooooooooooooooooooooocooonooooooooooooooooooooooooooooooooooooonoooooooooo 

10000000000000000000000000000000000000000000000000000000000000000000000000000009 

■ '030003000000000000000000000000000000000000000000000000000000000000000000000000 
300000000000069.0E1 

-- SMAX.LEN.INT.BASED.LITERAL 

■ A BASED INTEGER LITERAL 'USING COLON’S) WHOSE VALLE IS Ill. . HAVING 

- 'SMAX. IN.LEN - 5) ZEROES BETWEEN THE FIRST COLON AND HIE FIRST I 
USED IN: C2A009A 

MAX.LEN.INT.BASED.LITERAL 2 :OOOOOOOOOOOOOOOOOOOOOOCCOOOOOOOOOOOOOOOOOOOOOOOOOOOO 

OOOOOOOOOOOOOOOOOOOOOOOCOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO 









ooooooooooooonooooooooooooooooooooofiooooooooonooooooooooooooooooonoooooooooooooo 

OOOOOOOOOOQOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOQOOOOO 
0000000000o000000000000000000000000000000000000000000000000000000000000000000000 
OOOOOOUOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOUOOOOOOOO 00000000000000 
00000000000000000000000000000000000000000011. 

- SMAX.LEN REAL.BASED LITERAL 

A BASED REAL LITERAL 'USING COLON'S) WHOSE VALUE IS ! 6 F V. : . HAVING 
-- {SMAX. IN LEN - 7) THROES BETWEEN THE FIRST COLON’ AND THE F. 

-- USED IN: C2A009A 

MAX LEN_REAL BASED.LITERAL 16:00000000000000000000000000000000000000000000000000 

oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo 
00000000000000000000000000000000000000000000000000000000000000000000000000000000 
00000000000000000000000000000000000000000000000000000000000000000000000000000000 
OOGOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOCOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO 
0000000000000000000000000000000000000000000000000000000 CO 00000000000000000000000 
0000000000000000000000000000000OOOOOOOOOOOF E: 

- - SBLANKS 

•• A SEQUENCE OF fSMAX.IN_LEN - CO) BLANKS. 

-• USED IN: BT2001A B22001B B2200IC 322001D 322001E 322001F 

B22001G 3CC001 I B22001J 32200IK: 322001L 322001M 

32200 IN 

< limits of sample shown by angle brackets > 

BLANKS 


- - SMAX DIGITS 

•• AN INTEGER LITERAL WHOSE VaL’JE IS SYSTEM.MAX DIGITS. 

•• USED IN': 33 5701A CD’ 1023 
MAX.DIGITS 15 

• • SN'AME 

TIE NAME OF A PREDEFINED INTEGER TYPE OTHER THAN INTEGER. 

SHORT.INTEGER. UR LONG INTEGER, 

■■ ( IMPLEMENTATIONS WHIG! HAVE NO SUCH TYPES SHOULD USE AN UNDEFINED 
IDENTIFIER SUGi AS NO SUGf.TYPE AVAILABLE.) 

USED IN. AVAT007 C4623ID 3S600fx 
NAME TINY.INTEGER 

• SF.OAT.NAME 

• TIE NAVE OF A PREDEFINED FLOATING POINT TYPE OTHER TUN FLOAT. 

SHORT FuOAT. OR LONG .FLOAT. IMPLEMENTATIONS WH!Gl HAVE NO SUCH 

TYPES SHOULD USE AN UNDEFINED IDENTIFIER SLGI vS NO. SUG! .TYPE. 
"SED IN \v\TCI? 3S600IY 

T.'.'AT.n AMS NO.SUGI.FIXED.TYPE 


LIE N\MK ,'F \ PREDEFINED FIXED POINT TYPE OTHER THAN DURATION 
IMP I. IMENTa T ’ ON 3 WHIG-: HAVE NO SUG! TYPES SHOULD USE AN UNDEFINED 
I DEN” I F! ER SUG: \S NO.. SUG:.TYPE , 

USED IN AVATCJO 3.«6-.:0!Z 

-IXED.NAVE NO.SUCI.TYPE 

S INTEGER .FIRST 

AN INTEGER UITIRa:.. WITH SIGN. '■'•HOSE VALUE IS INTEGER 1 FIRST 
USED IN "NT? 35 430 13 

I NT.'.I ER .FIRST 2.'. 4~.J13.64s 

■■ $ INTEGER LAST 

AN INTEGER LITERAL 'MtOSF. VALUE IS INTEGER'LAST 
USED IN QiiuJF 34 5 22 2 A 34 <30 IB 
IVTT.GER.LAST 2.'. 4~.483.647 

• SINTEGER .LAST.PLUS.I 

- AN INTEGER LITERAL WHOSE VALUE IS INTEGER' i. A ST - ! 















-- USED IN: C45232A 
INTEGER.LAST.PLL'S. 1 2.1 47.483.648 

• • S.VHN INT 

• - AN INTEGER LITERAL. WITH Slav. WHOSE value IS SYSTEM.MIN' INT 

-- THE LITERAL MIST NOT CONTAIN UNDERSCORES OR LEADING OR TRAILING 

- - BLANKS. 

-- USED IN: C35503D C35503F CD7101B 

.VON_ INT - 2147483648 

- - SMAX I NT 

-- AN INTEGER LITERAL WHOSE VALLE IS SYSTEM.MAX INT. 

- - THE LITERAL MJST NOT INCLUDE UNDERSCORES OR LEADING OR TRAILING 

• - BLANKS. 

-- USED IN: C35503D C3J503F C4A007A CD7101B 

MAX.INT 2 147483647 

-- iMAX INT.PLUS 1 

-- AN' INTEGER LITERAL WHOSE VALUE IS SYSTEM MAX. I NT ♦ I. 

- - USED IN: C45232A 

MAX.INT.FLUS.! 2.147.483.648 

- - SLESS THAN DURATION 

-- A REAL LITERAL (WITH SIGN! WHOSE VALUE CNOT SUBJECT TO 
-- ROUND-OFF ERROR IF POSSIBLE) LIES BETWEEN DURATION'3ASE'FIRST AND 
-- DURATION'FIRST. IF NO SUCH VALUES EXIST, USE A VALLE IN' 

-- DURATION'RANGE. 

- - USED IN: C96005B 

LESS.THAN.DURATION -100.000.0 

.. SGRPATFR.THAN DURATION 

- - A REAL LITERAL WHOSE VALUE (NOT SUBJECT TO ROUND-OFF ERROR 

-- IF POSSIBLE) LIES BETWEEN DURATION' BASE’ LAST AND DURA'l ION' LAST. IF 
-- NO SUCH VALUES EXIST. USE A VALUE IN DURATION" RANGE. 

-- USED IN: C96005B 
GREATER.THAV.DURAT I ON 100.000.0 

• - SLESS THAN DURATION 3aSE FIRST 

-- A REAL LITERAL (WITH SIGN) WHOSE VALUE IS LESS THAN 
-- DURATION'BASE'FIRST. 

-- USED IN: C96005C 

LESS .THAN.DURAT I QN'.BASE _F IRST • 'O.OOO.VOO 

- - SGREATER THAN DURATION BASE LAST 

-- A REAL LITERAL 'WHOSE VALUE IS GREATER THAN DURATION" 3ASE ' LAST. 

-- USED IN: C96005C 

CREATER.THAN'.DLRATION.BASE.LAST 10.000.000 

- - S COUNT LAST 

-- AN INTEGER LITERAL WHOSE VALUE IS TEXT IO. COUNT' LAST. 

-- USED IN: CE3002B 
COUNT.LaST 2.147.483.647 

-- SFIELD.LAST 

-- AN INTEGER LITERAL WHOSE VALUE IS TEXT IO. FI ELD' LAST 
-- USED IN: CE3002C 
FIELD.LAST 2.147.483.647 

- - SI LLEGAL .EXTTRN'AL.F i LE .NAME 1 

-- aN ILLEGAL EXTERNAL FILE NAME 'E.G.. TOO LONG, CONTAINING INVALID 
-- GIARaCTERS. CONTAINING wild-CVRD GIARACTERS . OR SPECIFYING A 
-- NONEXISTENT DIRECTORY). 

-- USED IN: CE2103A CE2102C CE2102H CE2I03B CE31023 CE3107A 

ILLEGAL_EXTERV'VL_ C ILE_NAME1 " / i 1 1 eg* 1 / f i 1 e.ntme / 2 ( ) S%21 02C DAT" 

-- S ILLEGAL.EXTERNAL.FILE ..NAME 2 

-- AN ILLEGAL EXTERNAL FILE NAME. DIFFERENT FROM SEXTERNAL FILE NAME 1 

-- USED IN: CE2102C CE2102H CE2I03A CE2103B 

ILLEGAL_EXTERNAL_FILE_NAVE2 "/illeg.l/file.nunt/CE21C2C* DAT" 

- SACC.SIZE 












AN INTEGER LITERAL WHOSE VALUE IS THE MINIMM NUNBER OF BITS 


SUFFICIENT TO HOLD 
USED IN: CD1C03C 
CD2A81F 
CD2A83F 
ACC SIZE 32 


ANT VALUE of .an access type. 

CD2A81A CD2A81B CD2A8IC CD2A81D CD2A81E 

CD2A81G CD2A83A CD2A83B CD2A83C CD2A83E 

G32A8 3G ED2A8 6A CD2A87A 


-• STASK.SIZE 

-■ AN INTEGER LITERAL WHOSE VALLE IS THE NUMBER OF BITS REQUIRED TO 

• - HOLD A TASK OBJECT WHICH HAS A SINGLE ENTRY WITH ONE INOUT PARAMETER. 

-- USED IN: CD2A91A CD2A91B CD2A9 1C CD2A9ID CD2A9lE 
TASK_S IZE 32 

-- SMI N’.TASK. SIZE 

-- AN INTEGER LITERAL WHOSE VALLE IS THE NUMBER OF BITS REQUIRED TO 

-- HOLD A TASK OBJECT WHICH HAS NO ENTRIES. .NO DECLARATION’S. AND “NULL: " 

-- AS THE ONLY STATEMENT IN’ ITS BCOY. 

-- USED IN: CD2A95A 
\CN_TASK_SIZE 32 


■- SNAME.LIST 

-- A LIST OF THE ENUMERATION LITERALS IN THE TYPE SYSTEM.NAME, SEPARATED 
- • BY COMMAS . 

-- USED IN: CD7003A 

NAME _ LI ST MASS COMP _UN IX 


•• SDEFAULT_SYS_NAN€ 

- - THE VALUE OF THE CONSTANT SYSTEM. SYSTEM.NAME. 
-- USED IN: CD7004A CD7004C CD7004D 

DEr'AULT.SYS NAME MASSCOMP UNIX 


- • SNEW.SYS.NAME 

• • a value of the type system.name. other than sdefault.sys name, if 

- - THERE IS ONLY ONE VALUE OF THE TYPE. THEN USE THAT VALUE. 

• - NOTE: IF THERE .ARE MORE THAN TWO VALUES OF THE TYPE. THEN THE 

PERTINENT TESTS ARE TO BE RUN CNCE FOR EACH ALTERNATIVE. 

-• USED IN: 2D7004BI 

new.sys.name .massccmp.unix 

- - SDEFAULT STOR UNIT 

-- AN INTEGER LITERAL WHOSE VALUE IS SYSTEM, STORAGE UNIT. 

-- USED IN; CQ7005B ED7005D3M CD7005E 

OEFAULT.STOR.UNIT 8 

• - SNTW’. STOR .UNIT 

AN INTEGER LITERAL WHOSE VALUE IS A PERMITTED ARGUMENT FOR 
-- PRACMA STORAGE .UNIT, OTHER THAN SDEFAULT STOR UNIT. IF THERE 
-- IS NO OTHER PERMITTED VALLE, THEN USE THE VALUE OF 
-- SSYSTEM. STORAGE UNIT. IF THERE IS NDRE THAN ONE ALTERNATIVE. 

-■ THEN THE PERTINENT TESTS SHOULD BE RUN ONCE FOR EACH ALTERNATIVE. 

- - USED IN. ED700JCI SD70T5D1 CD7005E 
NEW STOR UNIT 8 


•■ SDEFaULT_MEM_S ize 

■■ AN INTEGER LITERAL WHOSE VALLE IS SYSTEM.MEMORY SIZE. 

-• USED IN: CD7006B ED7006D3.M CD7006E 
DErAU L r_MEM_ SI ZE 16_~77_z 1 6 

-- SNBV.MEM.SIZE 

-• AN INTEGER LITERAL WHOSE VALUE IS A PERMITTED ARGUMENT FOR 
•• PRAGMA MENORY.SIZE. OTHER THAN SDEFAULT..MEM SIZE. IF THERE IS NO 
•• OTHER VALLE. THEN' USE SDEFAULT.MEM.S I ZE. IF THERE IS NDRE THAN 
■■ ONE ALTERNATIVE. TIEN' TIE PERTINENT TESTS SHOULD BE RUN ONCE FOR 
EAGI ALTERNATIVE. IF TIE NUMBER CE PERMITTED VALUES IS LARGE, TIEN' 
- - SEVERAL VALUES SHOULD BE USED, COVERING A WIDE RANGE OF 
POSSIBILITIES. 

USED IN': ED7006C1 ED7006DI CD7006E 
NJW'.MEM.S IZE 16.777.216 

-- SLCW.PR IORITY 

-- AN INTEGER LITERAL WHOSE VALUE IS TIE LCWER BOUND OF TIE RANGE 









-- TOR THE SUBTYPE SYSTEM. PRIORITY. 

-- USED IN: CD7007C 
LOV.PRIORITY 0 

-■ SHIGH.PRIORITY 

-- AN INTEGER LITERAL WHOSE VALUE IS THE UPPER BOUND OF THE RANGE 
-■ FOR THE SUBTYPE SYSTEM.PRIORITY. 

-• USED IN: CD7007C 
HIGH_PRIORITY 99 

- SMANTISSA^DOC 

-- AN INTEGER LITERAL WHOSE VALUE IS SYSTEM.MAX MANTISSA AS SPECIFIED 
-- IN THE LMPLEMENTOR'S DOCUMENTATION. 

-- USED IN: CD7I03B CD7103D 
MANTISSA.DOC 31 

-- STICK 

-- A REAL LITERAL WHOSE VALUE IS SYSTEM. TICK AS SPECIFIED IN THE 
■ - IMPLEMENTOR' S DOCUMENTATION. 

-- USED IN: CD7104B 
TICK 0.0166666 






APPENDIX D 


WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to 
the Ada Standard. The following 44 tests had been withdrawn at the time 
of validation testing for the reasons indicated. A reference of the 
form Al-ddddd is to an Ada Commentary. 

A39005G 

This test unreasonably expects a component clause to pack an array 
component into a minimum size (line 30). 

B97102E 

This test contains an unintended illegality: a select statement 
contains a null statement at the place of a selective wait alternative 
(line 31). 

C97110A 

This test contains race conditions, and it assumes that guards are 
evaluated indivisibly. A conforming implementation may use interleaved 
execution in such a way that the evaluation of the guards at lines 50 & 
54 and the execution of task CHANGING_OF_THE_GUARD results in a call to 
PvEPGPvT. FAILED at one of lines 52 or 56. 

BC3009B 

This test wrongly expects that circular instantiations will be detected 
in several compilation units even though none of the units is illegal 
with respect to the units it depends on; by AI-00256, the illegality 
need not be detected until execution is attempted (line 95) . 

CD2A62D 

This test wrongly requires that an array object’s size be no greater 
than 10 although its subtype's size was specified to be 40 (line 137). 

CD2A62A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] 

These tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them to a 
derived subprogram (which implicitly converts them to the parent type 
(Ada standard 3.4:14)). Additionally, they use the ’SIZE length clause 
and attribute, whose interpretation is considered problematic by the WG9 
ARG. 

CD2AS1G, C02A83G, CD2AS4M & N, & CD5C110 

These tests assume that dependent tasks will terminate while the main 
program executes a loop that simply tests for task termination; this is 
not the case, and the main program may loop indefinitely (lines 74, 85, 
86 & 96, 86 d 96, and 58, resp.). 


D-2 





CD2B15C & CD7205C 

These cests expect that a ' STORAGE_SI2E length clause provides precise 
control over the number of designated objects in a collection; the Ada 
standard 13.2:15 allows that such control must not be expected. 

CD2D11B 

This test gives a SMALL representation clause for a derived fixed-point 
type (at line 30) that defines a set of model numbers that are not 
necessarily represented in the parent type; by Commentary AI-00099, all 
model numbers of a derived fixed-point type must be representable values 
of the parent type. 

CD5007B 

This test wrongly expects an implicitly declared subprogram to be at the 
address that is specified for an unrelated subprogram (line 303). 

ED7004B, ED7005C & D, ED7006C & D [5 tests] 

These tests check various aspects of the use of the three SYSTEM 
pragmas; the AVO withdraws these tests as being inappropriate for 
validation. 

CD7105A 

This test requires that successive calls to CALENDAR.CLOCK change by at 
least SYSTEM.TICK; however, by Commentary AI-00201, it is only the 
expected frequency of change that must be at least SYSTEM.TICK -- 
particular instances of change may be less (line 29). 

CD7203B, & CD7204B 

These tests use the 'SIZE length clause and attribute, whose 
interpretation is considered problematic by the VC9 AJR.G. 

CD7205D 

This test checks an invalid test objective: it treats the specification 
of storage to be reserved for a task's activation as though it were like 
the specification of storage for a collection. 

CE2107I 

This test requires that objects of two similar scalar types be 
distinguished when read from a file--DATA_ERROR is expected to be raised 
by an attempt to read one object as of the other type. However, it is 
not clear exactly how the Ada standard 14.2.4:4 is to be interpreted; 
thus, this test objective is not considered valid. (line 90) 

CE3111C 

This test requires certain behavior, when two files are associated with 
the same external file, that is not required by the Ada standard. 

CE3301A 

This test contains several calls to END_OF_LINE & END_OF_PAGE that have 
no parameter: these calls were intended to specify a file, not to refer 
to STANDARD INPUT (lines 103, 107, 118, 132, & 136). 


D - 3 







CE3411B 

This test requires that a text file's column number be set to COUNT'LAST 
in order to check that LAYOUT_ERROR is raised by a subsequent PUT 
operation. But the former operation will generally raise an exception 
due to a lack of available disk space, and the test would thus encumber 
validation testing. 


E2S005C 

This test expects that the string TOP OF PAGE. --63" of line 204 
will appear at the top of the listing page due to a pragma PAGE in line 
203; but line 203 contains text that follows the pragma, and it is this 
that must appear at the top of the page. 


D - 4 








APPENDIX E 


COMPILER OPTIONS AS SUPPLIED BY 
Concurrent Computer Corporation 

Compiler: Mu nua veru-ui. i . e. 

ACVC Version: 1.10 


E-l 



>w 


Ada Command Directives 

The only option used with the Ada command during the validation was the -M option. 

Ada Library Info Directives 

Two different INFO directives were used to prepare the validation results. The directives, specified 
in the ada-lib file, are used to control the type of Seating point instructions generated. 

The following directive generares floating point instructions that are executed on the MC68881 co¬ 
processor. 


FL0ATTNG_P0INT_SUPP0RT:ENi'0:MC68881: 


To generate floating point instructions that are executed on the LIGHTNING co-processor, the fol¬ 
lowing directive was placed In the ada.lib file. 

FLOATING_POLNT_SUPPORT:INFO:LIGHTNING: 


July 18. 1989 



ada — Ada compiler 
Syntax 


ad* [options] [ada jourct.a ] , . . [Id^opttons] [objectJilt. 0 ] 


Description 


The command ada executes the Ada compiler and compiles the named Ada 
source file, ending with the .a suffix. The file must reside in a VaDS library 


ut.wwiui y, 


Ci A w JWL1* i W ii3S lOl ii* 3«, 


library directory. The ada.llb file in this directory is modified after each Ada 
unit is compiled. 


All files created and modified are located in subdirectories of the directory that 
contains the ada_source.a file. The object program is left in a file with the 
same name as that of the source with .0 substituted for .a unless the -o option 
is used. The object file is written to the .objects subdirectory of the VaDS 
library. 


Bv default, ada produces only object and net files. If the -M option is used, the 
compiler automatically invokes a.ld and builds a complete program with the 
named iibrary unit as the main program. 

Non-Ada object files (e.g., .0 files produced by the C or FORTRAN compiler) 
may be given as arguments to ada. These files will be passed on to the linker 
and will be linked with the specified Ada object files. 

Command line options may be specified in any order, but the order of 
compilation and the order of the files to be passed to the linker can be 
significant. 

Options 

-a filename (archive) Treat fiie_name as an ar file. Since archive files end 
with .a, -a is used to distinguish archive fiies from Ada 
source files. 

-<i (dependencies) Analyze for dependencies only. Do not do 

semantic analysis or code generation. Update the library, 
marking any defined units as uncompiied. The -d option is 
used by a.make to establish dependencies 3mong new files. 

-e (error) Process compilation error messages using a.error and 

direct it to stdout. Only one -e or -E option should be used. 







-E file 

-E directory (error output) Without a file or directory argument, ada 
processes error messages using a.error and directs the output 
to stdout; the raw error messages are left in source.err. If a 
file pathname is given, the raw error messages are placed in 
that file. If a directory argument is supplied, the raw error 
output is placed in dir/source.err. Only one -e or -E option 
should be used. 

-el (error listing) Intersperse error messages among source lines 

and direct 10 stdouL 


-El 

-El file 

-El directc-y (error listing) Same as the -E option, except that source 
listing with errors is produced. 

-ev (error vi) Frocess the rew error messages using a.error, 

embed them in the source file, and call vi on the source file. 

-Ifltejibbreviation 

(link) Link this library file. (Do not space between f he -1 and 

a akkf>airiA*«A«* Can 1 <1 (1 N 

U4U tilv M W« •> • y WWW / • 

-M (main) Produce an executable program using the named unit 

as the main program. The unit must be either a parameterless 
procedure or a parameterless function returning an integer 
The executable program will be left in the file a.out unless 
overridden with the -o option. 

-M ada_source. a 

(main) Like -M unit_name, except that the unit name is 
assumed to be the root name of the .a file (e.g., for foo.a the 
unit is foo). Only one .a file may be preceded by -M. 

-o executable Jile 

(output) This option is to be used in conjunction with the -M 
option, executable Jile is the name of the executable rather 
than the default a.out. 

-0(1-9] (optimize) Invoke the code optimizer. An optional digit limits 

the number of optimization passes. The default, 0, optimizes 
as far as possible. 

-R VADSJibrary 

(recompile instantiation) Force analysis of ail generic 
instantiations, causing reinstantiation of any that are out of 
date. 






ada 


-S (suppress) Apply pragma SUPPRESS to the entire 

compilation. 

-T (timing) Print uming information for the compilation. 

-u (update) Cause library status to reflect the current program 

source. Unless the source is syntactically incorrect, the 
compiler updates the library ada.Iib. Normally, the library is 
changed only if the unit compiles without errors of any land. 

-v (verbose) Print compiler version number, date and time of 

compilation, name of file compiled, command input line, total 
compilation time, and error summary line. 

-w (warnings) Suppress warning diagnostics. 


Files 
file.a 

/tmp/file.SS 
ada.lib 
gnrx.lib 
GVAS_table 
ada.lock 
gnrx.lock 

GVAS table.LOCK 


Ada source input file 
Ll. code file created by front end 
VADS directory information file 
VaDS generics library information file 
GVAS table in the current VADS project 
lock link to •vAineiQfi 

lock generics library, for mutual exclusion 
lock link to GVAS_table, for mutual exclusion 


Sec Also 

a.db, a.error, a.la, a.mklib. la(l) 

Diagnostics 

The diagnostics produced by the VADS compiler are in'“nded to be 
seif-explanatory. Most refer to the RM. Each RM reference incluaes a section 
number and optionally, a paragraph number enclosed in parentheses. 







