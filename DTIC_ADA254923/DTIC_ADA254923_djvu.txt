V 


r AD-A254 923 jtation page 

L lOlilllllllllllliliilllillli • 1« 1 ivM 

Form Approved 

OPM No. 0704-01$a 

^ IHB WmiWHlHWIMillll mx par fMooriM. including th«tim*lo( i*vi*wlnglratruction(,nvchlng*iilMing data sowcMguhwInB and nwMMngtwdtfi 

n 1 HH H wH W IHI "IH UH IH ni e burdan astimata or any olhar aapaO ol thia collactlon o( Mormation, Including tuggatllont tor radudng Ma biadan, to Waahkigam 

h laflarson Oavis Highway, Su8o 1204. Arlington, VA 22202-4302. and to lha OSIca of kitotmallan and Ragulaloty ARiiia, Odea ol 

b 

1. AGENCY USE ONLY (Leave Blank) 2. REPORT DATE 3. REPORT TYPE AND DATES COVERED 

Rnal:20 May 1992 

4. TITLE AND SUBTITLE 

Validation Summary Report: Irvine Compiler Corporation ICC Ada v7.4.0, VAXstation 
3100 Model M38/VMS Version V5.3-1(Host) Intel i960MX in Hughes OMV running in 
tagged mode (bare machine with CHKSYS kernel version 104){T)92052011.11260 

5. FUNDING NUMBERS S. 

6. AUTHOR(S) 
lABG-AVF 

Ottobrunn, Federal Republic of Germany 

7. PERFORMING ORGANIZATION NAME{S) AND ADDRESS{ES) 

IABG-AVF, Industriear.lagen-Betriebsgeselschaft 

Deot. SZT/ Einsteinstrasse 20 

D-8012 Ottobrunn 

FEDERAL REPUBLIC OF GERMANY 

8. PERFORMING ORGANIZATION 

REPORT NUMBER 

lABG-VSR 106 

9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Pentagon, Rm 3E114 

Washington, D.C. 20301-3081 ^ ^ay 

10. SPONSORING/MONITORING AGENCY 
REPORT NUMBER 

11. SUPPLEMENTARY NOTES 

$ 


1 

12a. DISTRIBUTION/AVAILABILITY STATEMENT ■■ M ggj 

Approved for public release; distribution unlimited. M 

Pb. DISTRIBUTION CODE 

13. ABSTRACT (Maximum 200 words) 

Irvine Compiler Corporation, ICC Ada v7.4.0, VAXstation 3100 Model M38/VMS Version V5.3-1 (Host) Intel i960MX in 
Hughes DMV running in tagged mode (bare machine with CHKSYS kernel version 104) (Target), 92052011.11260 

92-23164 

^2 8 19 89 iiiiliilll 

14. SUBJECT TERMS 

Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSi/MIL-STD-1815A, AJPO. 

15. NUMBER OF PAGES 

16. PRIC^ CODE 

17. SECURITY CLASSIFICATION 18. SECURITY CLASSIFICATION 

OF REPORT 

UNCLASSIFIED UNCLASSIFED 

19 SECURITY CLASSIFICATION 

OF ABSTRACT 

UNCLASSIFIED 

20. UMITATION OF ABSTRACT 


MSN 7540-01-280-550 


Standard Form 298, (Rev. 2-89) 
Prescribed by ANSI Std. 239-128 
















AVF Control Nunbor: ZABG-VSR 106 
20 May 1992 


f/tm COMPILER 

VRLZOATZON StmMARY REPORT: 

Cartifleat* Nuidiar: 92052011.11260 
Irvin* Co*pil*r Corporation 
ICC Ada r7.4.0 

VAXstation 3100 Modal M38/VNS Varsion VS.3-1 «> 
Zntal i960NZ in Hngha a PM V running in taggad aoda 
(bar* aacbin* with CBXSTS kamal varsion 104) 


^0 quality ik^egted 9 


Accesion For 

. 

NTiS CRAi^l 

s 

DTIC 

lAB 

□ 

Ur.annou.'ced 

lJ 

Justificatio:! 


By 



Diitiibi 

.tion / 


Aveiiab;!!'/ 

Ccd:-s 


Avail 1' 

1 ■ ;■ or 

Di 3 t 

Spc- 

i 



! 

I 

1 

1 I 



Praparad By: 
lABO mbH, Abt. ITS 
Einstainstr. 20 
M-8012 Ottobrunn 
Garmany 







Certificate Inforeation 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on May 20 , 1992. 


Compiler Name and Versiont ICC Ada v7.4.0 

Host Computer System: VAZstation 3100 Model N38/VMS Version VS.3-1 


Target Computer System: Intel i960MZ in Hughes NIV running in tagged 

SKide (bare machine with CHKSYS kernel version 
104) 


See Section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort, Validation Certificate 
#92052011.11260 is awarded to Irvine Compiler Corporation. This certificate 
expires 24 months after ANSI approval of MIL-STD 181SB. 

This report has been reviewed and is approved. 

IAB6, Abt. ITS 
Michael Tonndorf 
Einsteinstr. 20 
W-8012 Ottobrunn 
Germany 



Ada Val/ii3a?lx>n Organization 

Dir^to^ ^omputer S Software Engineering Division 
Instxtut^for Defense Analyses 
Alexandria VA 22311 



Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 





OECLARATZON OF CONFORMANCE 


The following declaration of conformance was supplied by the 
customer. 


Declaration of Conformance 


Customer: Irvine Compiler Corporation 

Ada Validation Facility: lABG mbH 

ACVC Version: 1.11 

Ada Implementation: 

Ada Compiler Neuae and Version: ICC Ada v7.4.0 

Host Computer System: VAXstation 3100 Model M38 

under VMS 5.3-1 

Target Computer System: Intel i960MX in Hughes DMV 

running in tagged mode (bare 
machine with CHKSYS kernel 
version 104) 

Declaration: 


I, the undersigned, declare that I have no knowledge of 
deliberate deviations from the Ada Language Standard 
ANSI/MIL-STD-1815A ISO 8652-1987 in the implementation listed 
eUaove. 



Customer Signature 


Dat 


rTj 



TABLE OP CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 USE OP THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REPERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEPINITION OP TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIPICATIONS.2-5 

CHAPTER 3 PROCESSING INPORMATION 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUMMARY OP TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX P OP THE Ada STANDARD 














CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro90] against the Ada Standard [Ada83] using the 
current Ada Compiler Validation Capability (ACVC). This Validation Summary 
Report (VSR) gives an account of the testing of this Ada implementation. 

For any technical terms used in this report, the reader is referred to 
[ProSO]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 
In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply 
only to the computers, operating systems, and compiler versions identified 
in this report. 

The organisations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject implementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this report are available to the public from the AVF which performed this 
validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1-1 




INTRODUCTION 


1.2 REFERENCES 

[Ada83] Bafarance Manual for the Ada Prooram mlno Language . 

ANSI/MII.-STD-181SA, February 1983 and ISO 8652-1987. 

tPro90] Ada Compiler Validation Procedures. Version 2.1, Ada Joint 
Program Office, August 1990. 

(UG89] Ada Compiler Validation Capability User's Guide . 21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of teat programs structured into six test classes: 

A, B, C, D, E, and L. The first letter of a test name identifies the class 
to which it belongs. Class A, C, 0, and E tests are executable. Class B 
and class L tests are expected to produce errors at compile time and link 
time, respectively. 

The executable teats are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK_FILE are used for this purpose. The package REPORT 
also provides a set of identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_^FILE is used to check the contents of 
text files written by sone of the Class C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT and CHECK^FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

class B tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which oiust not be flagged illegal by the compiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled units. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implesientation-specific values — for example, the largest integer. A list 
of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts bet%«een the tests and 
implementation-dependent characteristics. The modifications required for 
this implementation are described in section 2.3. 


1-2 



INTRODUCTION 


For oach Ada inplamentation, a customizad test suite is produced by the 
AVF. This customization consists of making the modifications described 
in the preceding paragraph, removing withdrawn tests (see section 2.1) and, 
possibly some inapplicable testa (see Section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 

Ada Compiler The software and any needed hardwaure that have to be added 
to a given host and target computer system to allow 
transfoi'mation of Ada programs into executaUsle form and 
execution thereof. 

Adc Compiler The means for testing compliance of Ada implementations. 
Validation consisting of the test suite, the support programs, the ACVC 

Capability user's guide and the template for the validation summary 

(ACVC) report. 

Ada An Ada compiler with its host computer system and its 

Implementation target computer system. 

Ada Joint The part of the certification body which provides policy and 

Program guidance for the Ada certification system. 

Office (AJPO) 

Ada The part of the certification body which carries out the 

Validation procedures required to establish the compliance of an Ada 
Facility (AVF) implementation. 

Ada The part of the certification body that provides technical 

Validation guidance for operations of the Ada certification system. 

Organization 
(AVO) 

Compliance of The ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer 
System 


A functional unit, consisting of one or more cooiputers and 
associated software, that uses common storage for all or 
part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
cooiputer system may be a stand-alone unit or may consist of 
several inter-connected units. 


1-3 




INTRODUCTION 


Conformity 


Customer 


Declauration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 

ISO 

Operating 

System 


Target 

Computer 

Systm 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

test 


Fulfillment by a product, process or service of all 
requirements specified. 

An individual or corporate entity who enters into an 
agreement with an AVF which specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source programs are transformed 
into executaUsle form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada implementation. 

International Organization for Standardization. 

Software that controls the execution of progreuns and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial 
or complete hardware implementations are possible. 

A computer system where the executcUale form of Ada programs 
are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro90]. 

The process of checking the conformity of an Ada compiler to 
the Ada programning language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to o>eet its tost objective, or 
contains erroneous or illegal use of the Ada programming 
language. 


1-4 



CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Th« following t««ta hava baan withdravm by tha AVO. Tha rationala for 
withdrawing aach taat is availabla from aithar tha AVO or tha AVF. Tha 
publication data for this list of withdrawn tasts is 02 August 1991. 


B2800SC 

B28006C 

C32203A 

C34006D 

C3S508I 

C35508J 

C3S508M 

C35508N 

C3S702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C4S612C 

C4S651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B8302SB 

B830250 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

A01B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

B04008A 

CD4022A 

C04022D 

CD4024B 

CD4024C 

CD40240 

C04031A 

C04051D 

CD5111A 

CD7004C 

ED7005D 

CD7005B 

AD7006A 

C07006E 

AD7201A 

A07201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CB2119B 

CE220SB 

CE2405A 

CB3111C 

CB3116A 

CE3118A 

CS3411B 

CE3412B 

CE3607B 

CB3607C 

CB3607D 

CE3812A 

CB3814A 

CB3902B 



2.2 INAPPLICABLE TESTS 

A tsst is inapplicabla if it contains tast objactivas which ara irralavant 
for a givan Ada iatplamantation. Raasons for a tast's inapplicability may ba 
supportad by documants issuad by tha ISO and tha AJPO known as Ada 
Coomantarias and comnonly rafarancad in tha format Al-ddddd. For this 
implaoiontation, tha following tasts wars datarminad to ba inapplicabla for 
tha raasons indicatad; rafarancas to Ada Coanantarias ara includad as 
appropriata. 


2-1 



IMPLEMENTATICm DEPENDENCIES 


Th» tollowlng 201 taats hava floating-point typa daclarations raquiring mora 
digits than SYSTEM.MAX_0I6ZTS: 


C24113L..Y (14 tasts) 
C35706L..y (14 tasts) 
C35708L..y (14 tasts) 
C4S241L..Y (14 tasts) 
C45421L..y (14 tasts) 
C45524L..Z (15 tasts) 
C45641L..Y (14 tasts) 


C3570SL..y (14 tasts) 
C3S707L..y (14 tasts) 
C35802L..Z (15 tasts) 
C45321I...y (14 tasts) 
C45521L..Z (15 tasts) 
C45621L..Z (15 tasts) 
C46012L..Z (15 tasts) 


Tha following 20 tasts chac)c for tha pradafinad typa LONG_INTEGER; for this 


implomantation. 

thara is no 

such typat 



C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C4S503C 

C45504C 

C45504F 

C45611C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001W 

C86006C 

CD7101F 


C35713C, B86001U, and C86006G chack for tha pradafinad typa LONG_FLOAT; for 
this inplantantation, thara is no such typa. 

C35713D and B86001Z chack for a pradafinad floating-point typa with a nana 
othar than FLOAT, LONG_FLOAT, or SHORT_FLOAT; for this inplamantation, thara 
is no such typo. 

A35801E chocks that FLOAT'FIRST. .FLOAT'LAST may ba usad as a ranga constraint 
in a floating-point typo daclaration; for this implomantation, that ranga 
axcaads tha ranga of safa numbars of tha largast pradafinad floating-point 
typa and must ba rajoctad. (Saa saction 2.3.) 

C45423A..B (2 tosts), C45523A, and C45622A chack that tha propar axcaption 
is raisad if MACHINS_OVERFLOWS is TRUE and tha rasults of various 
floating-point oparations lio outsida tha ranga of tha basa typa; for this 
implomantation, NACHINE_OVBRFLOWS is FALSE. 

C45531M..P and C45532M..P (8 tasts) chack fixod-point oparations for typos 
that roquiro a SYSTEM.MAX_NANTISSA of 47 or graator; for this implsmantation, 
MAX_MANTZSSA is loss thaiT 47. 

C45536A, C46013B, C46031B, C46033B, and C46034B contain langth clausas that 
spacify valuas for 'SMALL that ara not powars of two or ton; this 
implasiontation doas not support such valuas for 'SMALL. 

B8600iy chocks for a pradafinad fixad-point typa othar than DURATION; for 
this implomantation, thara is no such typa. 

CD1009C usos a roprosantation clausa spacifying a non-dafault siza for a 
floating-point typo; this implaswntation doas not support such sisas. 

CD2A53A chocks oparations of a fixod-point typa for which a langth clausa 
spacifios a powar-of-ton TYPE'SMALL; this implomantation doas not support 
docimal 'SMALLs. (Saa saction 2.3.) 


2-2 




IMPLEMENTATION DEPENDENCIES 


CD2A84A, CD2A84E, CD2A84I..J (2 tastis), and CD2A840 ua* raprasantation 
clauaaa spacifying non-dafault sizas tor acrass typas; this implamantation 
doaa not support such sizas. 

BD8001A, BD8003A, BD8004A..B (2 tasts), and AD8011A usa machina coda 
insartions; this implamantation providas no packaga MACHINE_CODE. 

AE2101C and EB2201D..E (2 tasts) usa instantiations of packaga SEQUENTIAL lO 
with unconstrainad array typas and racord typas with discriminants without 
dafaults; thasa instantiations ara rajactad by this compilar. 

AE2101H, BE2401D, and EE2401G usa instantiations of packaga DIRECT_IO with 
unconstrainad array typas and racord typas with discriminants without 
dafaults; thasa instantiations ara rajactad by this compilar. 

Tha tasts listad in tha following table chack that USE_ERROR is raisad if tha 
givan fila oparations ara not supportad for tha givan combination of moda and 
accass mathod; this implamantation supports thasa oparations. 


Tast 

Fila Oparation Moda 

Fila Accass Mathod 

CE2102D 

CREATE 

IN FILE 

SEQUENTIAL lO 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL lO 

CE2102F 

CREATE 

INOUT FILE 

DIRECT lO 

CE2102I 

CREATE 

IN FILE 

DIRECT lO 

CE2102J 

CREATE 

OUT FILE 

DIRECT lO 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL lO 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL lO 

CB2102P 

OPEN 

OUT FILS 

SEQUENTIAL_IO 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL lO 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FIIB 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT lO 

CE2102U 

RESET 

IN FILE 

DIRECT lO 

CE2102V 

OPEN 

OUT FILS 

DIRECT 10 

CE2102W 

RESET 

OUT FILE 

DIRECT lO 

CE3102E 

CREATE 

IN FILE 

TEXT lO 

CE3102F 

RESET 

Any Mode 

TEXT 10 

CE3102G 

DELETE 


TEXT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT lO 

CE3102J 

OPEN 

IN FILE 

TEXT lO 

CE3102K 

OPEN 

OUT_FILE 

TEXT_IO. 


CE2108B, CE2108D, CE2108F, CE2108H, CE3112B, CE3112D (6 tasts) maka chacks 
that raquira tha usa of parmanant filas; this implamantation doas not support 
parmanant filas and so raisas NAME__E!UlOR on tha attampt to opan a fila 
craatad by an aarliar-run tast. " 

CE2203A chacks that WRITE raisas DSE_ERROR if tha capacity of an 
axtarnal saquantial fila is axcaadad; this implamantation cannot 
rastrict fila capacity. 

CB2403A chacks that WRITE raisas USE^ERROR if tha capacity of an 
axtarnal diract fila is axcaadad; this implamantation cannot rastrict fila 
capacity. 





implementation dependencies 


CE3304A checks that SET_LINE_LENGTH and SET_PAGE_LENGTH raise USE_ERROR if 
they specify an inappropriate value for the external file; there are no 
inappropriate values for this implementation. 

CE3413B checks that PAGE raises LAYOUT^ERROR when the value of the page 
number exceeds COUNT'LAST; for this implementation, the value of COUNT'LAST 
is greater than 150000, making the checking of this objective impractical. 


2-4 



implementation dependencies 


2.3 TEST MODIFICATIONS 

Modifications (sso section 1.3) were required for 50 tests and 2 support 
packages. 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the way 
expected by the original testa. 

B24009A BS3001A BS9001E BS9001F B83033B 

C34009D and C34009J %fere graded passed by Evaluation Modification as directed 
by the AVO. These test check that 'SIZE for a composite type is greater than 
or equal to the sum of its components' 'SIZE values; but this issue is not 
addressed by AI~0082S, which has not been considered; there is not an obvious 
interpretation. This implementation represents array components whose length 
depends on a discriminant with a default value by implicit pointers into the 
heap space; thus the 'SIZE of such a record type might be less than the sum 
of the components' 'SIZES, since the heap space that is used by the varying- 
length array components is not counted as part of the 'SIZE of the record 
type. These tests were graded passed given that the Report.Result output was 
"FAILED" and the only Report.Failed output was "INCORRECT 'BASE'SIZE", from 
line 19S of C34009D and line 193 in C34009J. 

A3S801E was graded inapplicable by Evaluation Modification as directed by the 
AVO. The compiler rejects the use of the range FLOAT'FIRST..FLOAT'LAST as 
the range constraint of a floating-point type declaration because the bounds 
lie outside of the range of safe numbers (cf. (Ada83] 3.5.7tl2). 

LA3004A and LA3004B were graded passed by Processing and Evaluation 
Modification as directed by the AVO. These tests check that whan the bodies 
of library units (a procedure, function, and package) are made obsolete, the 
implementation will detect the missing bodies at link time. This 
implementation detects the missing bodies at link time, but it also issues 
error messages that indicate that the main procedure (reap.) must be 
recompiled. This behavior violates (Ada83) 10.3t6 S 8. To verify that the 
implementation does not in fact require recompilation of the main procedures, 
the obsolete bodies were recompiled (files LA3004A2..4 and LA3004B2..4 were 
modified to contain only the bodies) and the tests were then linked and 
executed. Report.Result output "NOT APPLICABLE" as expected. 

The taste below were graded passed by Test Modification as directed by the 
AVO. These tests all use one of the generic support procedures Langth_Check 
or Enum_Cheek (in the support files LENCHECK.ADA 6 ENUMCHBK.ADA), which usd 
the generic procedure Unchecked_Conversion. This implmientation rejects 
instantiations of Unchecked^Conversion with array types that have non-static 
index ranges. The AVO ruled that since this issue was not addressed by AI- 
00590, which addresses required support for Unchecked_Conversion, and since 
AI-00590 is considered not binding under ACVC 1.11, the support 
procedures were modified to remove the use of Unchecked__^Conversion. Lines 
40..43, SO, and 56..58 in LENCHECX and lines 42, 43, and 58..63 in ENUMCHEK 
were commented out. 


2-5 





implbmehtation dependencies 

CD1009A CD1009I CD1009M CD1009V CD1009W CD1C03A 

CD1C04D CD2A21A..C CD2A22J CD2A23A..B CD2A24A CD2A31A..C 

CD2A81A CD3014C CD3Q14F CD3015C CD3015E..F CD3015H 

CD3015K CD3022A CD4061A 

CD2A53A was graded inapplicable by Evaluation Modification as directed by the 
AVO. The test contains a specification of a powar**of-10 value as 'SHALL for 
a fixed-point type. The AVO ruled that, under ACVC 1.11, support of deciraal 
'SMALLs may be omitted. 

CE2102C, CE2102H, CE2103A..B, CE3102B, and CE3107A (6 tests) were graded 
passed by Evaluation Modification as directed by the AVO. Each of these 
tests contains a check that requires an illegal file name; but for this 
implementation, there are no illegal filenames. These tests are ruled to 
have been passed, since all of their applicable checks were indeed passed. 
The following Report.Failed output was generated: 

CE2102C, 

CE2102H: NAME ERROR NOT RAISED - CREATE [respectively: SEQ | DIR] 1 

NAME~ERROR NOT RAISED - CREATE (respectively: SEQ | DIR] 2 

CE2103A, 

CE2103B, 

CE3107A: NAME_ERROR NOT RAISED - UNSUCCESSFUL CREATE 

CE3102B: NO EXCEPTION RAISED FOR (some file name] - CREATE 

NO EXCEPTION RAISED FOR (some file name] - CREATE 

OTHER EXCEPTION RAISED FOR (some file name] - OPEN 
OTHER EXCEPTION RAISED FOR (some file name] - OPEN 

CE2108B, CE21080, CE2108F, CE2108H, CE3112B, and CB3112D %#ere graded 

inapplicable by Evaluation Modification as directed by the AVO. These tests 
each depend on the contents of a file that was created by a previously 
executed test (e.g., CE2108B depends on a file created by CE2108A); but this 
implementation uses a file system that is implemented in the target 
computer's memory and does not support permanent files. The execution of 
tests CE2108F, CE2108H, and CE3112D results in a run-time system error report 
since NAME^ERROR is raised by the attempt to open the file from the previous 
test and is not handled. For tests CE2108B, CB2108D, and CE3112B, NAME_ERROR 
is similarly raised; it is handled anonymously and the following 
Report.Failed output is generated: 

UNEXPECTED EXCEPTION RAISED ON OPENING OF TEXT FILE, WHICH SHOULD 
HAVE BEEN CREATED BY TEST (respectively: CE2108A | CX2108C | CE3112A] 


2-6 





CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

Th« Ada implamentation tested in this validation <effort is described 
adequately by the information given in the initial pages of this report. 


For technical and sales information about this Ada implementation, 
contact: 


Joe Kohli 

Irvine Compiler Corporation 
34 Executive Park, Suita 270 
Irvine, California 92714 USA 
Tel. (714) 2S0-1366 
Fax. (714) 250-0676 


Testing of this Ada implementation was conducted at the customer's site by a 
validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 


An Ada Impleowntation passes a given ACVC version if it processes each test 
of the customized test suite in accordance with the Ada Programming Language 
Standard, whether the test is applicable or inapplicable; otherwise, the Ada 
Implamentation fails the ACVC (Pro90]. 

For all processed tests (inapplicable and applicable), a result was obtained 
that conforms to the Ada Programming Lanqpiage Standard. 

The list of items below gives the nusiber of ACVC tests in various categories. 
All tests were processed, except those that vmv withdrawn because of test 
errors (item b; see section 2.1), those that require a floating-point 
precision that exceeds the implementation's maximum precision (item e; see 
section 2.2), and those that depend on the support of a file system — if 
none is supported (item d). All tests passed, except those that are listed 
in sections 2.1 and 2.2 (counted in items b and f, below). 


3-1 




PROCESSING INFORMATION 


a) Total Numbar of Applicable Testa 3783 

b) Total Number of Withdrawn Tests 95 

c) Processed Inapplicable Testa 91 

d) Non-Processed I/O Tests 0 

a) Non-Proceased Floating-Point 

Precision Tests 201 


f) Total Number of Inapplicable Tests 292 (c-^-d-t-e) 

g) Total Number of Tests for ACVC 1.11 4170 (a-t-b+f) 


3.3 TEST EXECUTION 


A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the validation team for processing. The contents of the 
magnetic tape were loaded onto the host computer via ETHERNET (DEC DRQ3). 

After the teat files were loaded onto the host computer, the full set of 
tests except 159 Floating-Point Precision Tests were processed by the Ada 
implementation. 


The teats t«ere compiled and linked on the host computer syst«n, as 
appropriate. The executable images tuere transferred to the target computer 
system by the communications link described ed)ove, and run. The results were 
captured on the host computer system. 

Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a coo^lete listing of 
the processing options for this implementation. It also indicates the 
default options. The options invoked explicitly for validation testing were 


-stsck_check 

-numeric__check 

-elaboration__check 

-noinfo 

-quiet 

-link- 

-listing 

-maximum_errors-0 

-nopreprocesa 

-nowarnings 

-opt 


enable stack overflow checking 

enable arithmetic overflow checking 

enable elaboration checking 

suppress informational messages 

suppress compiler banners 

link the provided subprogram 

generate a cooipilation listing . 

sat maximum number of errors before abort to 

unlimited 

disable compilation of preprocessor directives 
suppress warnings 
optimize coda 


Test output, compiler and linker listings, and job logs tmre captured on a 
magnetic tape and archived at the AVF. The listings examined on-site by the 
validation team were also archived. 


3-2 



APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_^LEN—also listed here. These values are expressed 
here as Ada string aggregates, where **V” represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 

254 ~ Value of V 

SBIG__ID1 

(1..V-1 ■> 'A', 

V ■> '1') 

$BIG_ID2 

(1..V-1 -> 'A', 

V -> '2') 

SBIG__ID3 

(1..V/2 -> 'A') 
(1..V-l-V/2 

fi '3' fi 
«> 'A') 

$BIG_ID4 

<l..V/2 -> 'A') 
(1..V-l-V/2 

fi '4' fi 
«> 'A') 

$B1G_INT__L1T 

(1..V-3 -> '0') 

fi "298" 

SBIG_REAL_LIT 

<l..V-5 -> '0') 

fi "690.0" 


SBIO_STRINGl & (1..V/2 «> 'A') 6 

$BIG_STR1NG2 & (1..V-l-V/2'■> 'A') 6 '1' fi 


$BLANKS (1..V-20 ) 

$MAX_LEN INT BASED LITERAL 

-2*- fi (1..V-5 -> '0') fi -lli- 

$MAX_LEN_REAL_BASEO_LITERAL 

"16;" fi (1..V-7 -> '0') fi -P.E:" 

SMAX_STRING_LITERAL fi (1..V-2 «> 'A') fi 


A-1 






MACRO PARAMETERS 


The following table Hate all of the other macro parameters and their 
respective values. 

Macro Parameter Macro Value 


$ACC_SXZE 

96 

$ALXGNMENT 

4 

SCOONT_LAST 

2147483647 

$DEFAOLT_MEM_SX ZE 

2097152 

SDEFAULT__STOR_UNXT 

8 

SDEFAOLT__SYS_NAME 

X960MX 

SDELTA_DOC 

2#1.0#E-31 

$ENTRy_ADDRESS 

address_of_entryl 

$ENTRy_AOORESSl 

address__of_entry2 

$ENTRY_AODRESS2 

address_of_entry3 

SFXELD_LAST 

2147483647 

$FXLE_TERMXNATOR 


$FXXED_NAME 

NO_SDCH_FXXED_TyPE 

$FLOAT_NAME 

NO_SDCH_FLOAT_NAME 

$FORM_STRXNG 

ft ft 

$FORM_STRXNG2 

"CANNOT_RESTRXCT__FXLE_CAPACXTY 

$GREATER THAN DURATION 

524287.5 


$6REATER THAN DURATION BASB_LAST 

looooooo.o 

SGREATER THAN FLOAT BASE LAST 

l.OB+309 

$GREATER_THAN FLOAT SAFE LARGE 

l.OE+308 

SGREATER THAN SHORT FLOAT SAFE LARGE 

l.OE+38 ~ 

$HIGR_PRXORXTY 15 

$XLLBGAL EXTERNAL FILE NAMEl 





MACRO PARAMETERS 


/NODIRECTORY/FILENAME 

$ILLEGAL_EXTERNAL_FILE_NAME2 

/NODIRECTORY/THIS-FILENAME-IS-ILLEGAL 

SINAPPROPRI ATE__LINE_LENGTH 

-1 

$INAPPROPRIATE_PAGE LENGTH 

“ -1 


$INCLUDE_PRAGMA1 

PRAGMA INCLUDE 

(”a28006dl.tst”) 

$INCLUOE_PRAGMA2 

PRAGMA INCLUDE 

("b28006dl.t8t”) 

SINTEGER_FIRST 

-2147483648 


$INTEGER_LAST 

2147483647 


$ INTEGER_LAST__PLOS_l 

2147483648 


$INTERFACE_LANGUAGE 

C 


$LESS_THAN_DURATION 

-524287.5 

, 

$LESS_THAN_OURATION BASE FIRST 

-10000000.00 


$LINE_TERMINATOR 

ASCII.LF 


$LOW_PR10RlTy 

0 


$MACHINE_CODE_STATEMENT 

” ” NULL; 


SMACHINE_CODE_TYPE 

NO_SUCH_TyPE 


$MANTISSA_OOC 

31 


$MAX_DIGITS 

15 


$MAX_INT 

2147483647 


SMAX_INT_PLUS_1 

2147483648 


$MIN_INT 

-2147483648 


$NAME 

SHORT_SHORT_INTEGER 

$NAME_LIST 

I960,I960KA,I960KB,I960NC,I960CA, 
I960SA,I960SB,I960MM,I960XA,I960MX 

$NAMX__SPECIFICATI0N1 

X2120A 


$NAME_SPBCIFICATION2 

X2120B 



A-3 





MACRO PARAMETERS 


$NAME_SPECIFICATION3 

X3119A 

$NE6_BASE0_INT 

16#FFFFFFFE# 

$MEW_MEM_SIZE 

2097152 

$NEW_STOR_ONIT 

8 

$NEW_SYS_NAME 

Z960MC 

$PA6E_TERMZNATOR 

ASCZZ.FF 

$RECORD_OEFINITION 

NEW ZNTEGER; 

$RECORO_NAME 

NO_SOCH_MACHZNE_CODE__TYPE 

$TASK_SZZE 

32 

$TASK_STORAGE_SZ ZE 

16383 

STZCK 

(1.0/4096.0) 

$VARZABLE_AODRESS 

address_o£_varl 

$VARZABLE_A0DRESS1 

address_of_var2 


SVARIABLE AD0RESS2 


address of var3 




APPENDIX B 


COMPILATION SYSTEM AND LINKER OPTIONS 


Th« compilar and llnkar options of this Ads implementation, as described in 
this Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and not 
to this report. 


B-1 






IOC O'—w u ri Interpreter [v7.3.13 Apr 24, 1992] Help 


Paeelve ICC Qualifiers 
/AJiGCMBNTS /ARCS 
/PISPL AY 

/Bm BiOMIlEMT«<arg> 

/HBLPAII. /ALL 
/HIDB 


Display all arguments to the ICX! cflBnnntirt 
Display all actions as they are pexrfoxned 
Set the environment variable prefix 
List conanonly used qualifiers 
List all available qualifiers 
Sippress naming ICC subprocesses CVMS only) 


/ZGUQRS_CGNFZGOSATZGN /ZCFG /IGNQHB_CF6 

Ignore configuration file qualifiers 
/ZaiOBB_BIIVZSONNEMT /ZENV /ZOIQRB^BIV 

_ Ignore environment variable qualifiers 

/HOBMAL Coaplle with ^normal' messages 

/QUIET Conplle quietly 

/SAVB_PAS2 Save temporary files generated by pas2 

/SAVB_TEMPS /SAVE Save all intermediate files 

/SUCCEED Always return the success status 

/SYMBOLS /SYMS Show current value of ICC coPEomand's syndbols 

/TEMP Use teap ora ry directory for intermediate files 

/YKPa<arg> Use <arg> as the tenporary directory 

/UHi gPE Use unique file names for intermediate files 

/VERBOSE /V Gcnpile with verbose messages 


Active ICC Qualifiers 
/ASCHlTECfURE-<arg> 
/ASH 

/ASM_FLAG /ASMF-<arg> 
/ASM NAME /ASMN«<arg> 

/CC^FLAO /CCF-<arg> 
/CC NAME /CQr-<arg> 


Specify i960 architecture EA,XB,MC,CA,SA,SB,M1 
Stop at the generated assaobly file 
Siqplicitly a^ flag(s) for the assasAdler 
Use <arg> as the assaigbler 
Stop at the genonted C source file 
Siqplicitly add flag(s) for the C compiler 
Use <arg> as the C cospiler 


/SZBCDTB_FLA6 /BZBCP-<arg> 
/ADA_EZTxarg> 

/ASM EZTxarg> 

/Cja5cr»<a rg> 

/^bjDCTxarg> 

/ZNT_EXT-<arg> 

/LIB_ Errx arg> 

/MRG _EXT xarg> 

/OBJ JEIT xarg> 

/OPT_BSrxarg> 

/WT 


/CGDE.GBNBRATORJCDE /OGMQDE-<arg> 

~ <arg> specifies the code gsnerator mode 

/C0PT 3MIZE Invoke the C optiadser 

/EYE Link a nan>Ada program 

/EXECUTE Exmcute and delete executable after linking 

/SXBCUTB_FLA6 /BZBCPxarg> Siqplicitly add flag(s) for the executable 
/ADA_SXTxarg> Set Ada file extension 

/ASM HXrxarg> Set assembly file extension 

/CtiCTxarg> Set C file extension 

/i&JDnxarg> Set executable file extension 

/INT_HXTxarg> Set IFOBM file extension 

/LZB_SXTxarg> Set abject archive/library file extension 

/MRG JPCT xarg> Set list merge file extension 

/OBJJBXTxarg> Set object file extension 

/OPT_BXrxarg> Set optimised ZPQBM file extension 

/INT, Stop at the generated Iform file 

/OBP_TBMPSa<arg> Save flle(s) with extension (s) in <arg> 

/LIBRAKY /LZB><arg> Set the coepllatlon library directory 

/LINXFILB MAMBxarg> Set the linker directive file to <arg> 

/LZNKBR SACB /LZMKSR /LOADER NAME /LGADER«<axg> 

€ise <axg> as the linker 

/XJMXBR^PRBFLAfl /LZNXPRSF /LOADER PRSFLAO /LQADPRBF-<arg> 

Sxplicitly add pira>flag(s) for linker 
/LINXER POSTPLAG /LZNXPSTF /LOADER POSTFLAO /LOADPSTF-<axg> 

Explicitly add post-flag (s) for linker 
/MAP«<arg> Oenerate a link map file (ICC linker only) 

^MBROl invoke the IOC list m e r g e r 

/MRO Stop at the generated list merge file 

/OBJ St^ at the generated object file [default] 

/OBJLZBxarg> Install the object file in library <arg> 

/OBJLIB FLAG /GBJLIBF-<axg> ftpllcitly add flag(s) for object librarian 
/OBJLZB'llAMB /GBJLI»b<arg> Use <arg> as the abject librarian 
/QNT ~ Stop at the optimizer iform file 

/OPTIMZZB_OPTZCMS /OfTjOPT /OPTO«<azg> 


/LIBRARY /LZB-<arg> 
/LINKFILB MAMBxarg> 







_ Specify optiaizatloa options 

/OPTHCZ B /o pt Xovoke tbs Ada cptladzer 

/PAGB _lBWS IH»<arg> Sat globally applicable page length 

/PRETiH IKBR /PRZLQADBR*i<azg> Execute <azg> before linlrlng 
/PmiINinat_PLAG /PBELIHKF /FBELGADSR flag /PBELGADF-<axg> 

EiqplicltTy add flag(s) for prellnker 
/FOSTLHSCER /P06IIiQADER*<arg> 

_ Execute <arg> after linking 

/P06TL11I1QSR_FLA6 /PSTLIEXF /POSTLQADER._FLAG /PSTLQADF-<arg> 

E)q)llcltly add flag(8) for postlinker 
/SANLlB_10ttSB /SANLZBNB<arg> Use <arg> as the ranllb library processor 


/BELEASEa<arg> 
/ SHOWf_C MLY 
/SXSTEMM<arg> 
/tOQL_VERSION-<arg> 

Ada Qualifiers 
/ADVISE 
/CHECKS 

/CCMPATZBLE__CAIJiS 
/CSOSSJtBFBKEMCE /ZREF 
/tnCLABB«<arg> 


/ELABQBATZGNjCBBCX /ELAB_CBBCX 


Set the release directory 
Dlq)lay all actions to be performed 
Set the system library dlz^tozy 
Specify the ICC toolset version 


Bbable advisory namings [default] 
liable all runtime checks [default] 
Generate calls cospatlble with C calls 
Generate cross-reference file (.xrf) 
Declare an Identifier 
Oosplle for the Ada synbollc debugger 


/EXCEPTION IMFO 

/nSFCSMATI^N 

/LISTINQ 

/LISTIllG_OPnONS /LISTjOPT 

/lliAXll(nM_E8R0BS«<arg> 

/PBEPSOCBSS 

/SASK 

/ vanj u at 

/SIACK CMIftrX 
/STATlS^ELABORATIGN 
/SXNTAZ ONLY 
/TSIM 

/NABHINGS /N 

/NSAP 

/ZERO 


Generate ETAW OPATICN checking 
Enable extra EXCEPTION Information [default] 
Boable Informational warnings [default] 
Generate list file (.let) 

/LISTOB<arg> 

l^peclfy list file options 

Set mairlauin nuaber of errors reported 

Generate conawnted preprocess file (.app) 

Sate code efficiency 

Generate Ada runtlsw calls [defaiilt] 

Generate stack checking code 

Pe rfor m static elaboration [default] 

Syntax check only 

Generate trlmned pr e process file (.app) 


sages [defatilt] 


Enable auto-wrapplng error 
Zero all records [default] 


ICC CrKl e Generator Quallflera 

/BRASCB BELATIVB Use relative branches (BSO only) 

/COmrSv CODE Place constant aggregates in CODE 

/EOSTDlBC^iQBR /DEX /CDS /XDBGenerate host debugger Information 
/ EXTIBIDKD _IiISTIHG /BXL /ASL Generate extended coda listing output 
/Em Bn3K D _IiISTlMGj0PTI0NS /BXLjOPT /SXLOi»carg> 

~ Specify extended code listing opti ons 

Generate Inline hardware FPA co^ (EPOZ only) 
Generate LEAF procs when possible (I960 only) 
Generate runtlM *gprof' profiling 
Generate extended local Infcrmatlcn 
Generata Inline hardware floating-point code 
Genmmte frame size for each subp (1960 only) 
Generate namelist file (.n) 

Generate overflow detec t i o n code 
Generate stack probes 
Generate runtime profiling 
Dse real nmme 

Static eode (C code generator only) 


/FPA 

/LEAF PSOCBDOSSS 
/GPEOflLB 
/LOC m FO 

/FPD'/)I88881 /1I68882 
/FSAMI SIZE 


/PSOBB SSkCX 

/nuoF^ 
/SEAL 
/C STATIC 


ICC Prallnker QuaUflc 
/CONSLIEK /CL-<azg> 


Force link, even if dependency errors 
Allocate <arg> bytes of beep (1960 only) 


link <arg> Into one file 
‘ If dependency errors 



/l]IPLZCZT_BMDLE3l 
/time /Ii«<«rg> 

/OOTPOT /0-<arg> 
/STMX_SZZB /STlU3C-<arg> 
/tSAP 

/VMSDBBQG6BR 


Link main l]it>liclt exception table 
Ada link eonpllatlon tmit <arg> 

Use <axg> aa tba executable file name 
Allocate <arg> bytea of tiaer atack (1960 only) 
Batabllah numeric fault trap handler 
Link with VJJL/VtSS Debugger 



APPENDIX C 


APPENDIX P OP THE Ada STANDARD 


Thtt only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this Appendix are to conpiler documentation and not to this 
report. Implementation-specific portions of the package STANDARD, which 
are not a part of Appendix P, are given on the following lines. 


package STANDARD is 

type SHORT^SHORT^INTEGER is range -128 .. 127; 

type SHORT^INTEGER is range -32768 .. 32767; 

type INTEGiR is range -2147483648 .. 2147483647; 

type FLOAT is digits IS range 

-1.79769313486232E+308 .. 1.79769313466232E-^308 

type SHORT FLOAT is digits 6 range 
-3.40282E->-38 .. 3.40282E-»-38 

type DURATION is delta 2.0**<-12) range -524287 .. 524287; 


end STANDARD; 







Appendix F 
ICC Ada Version 7.4 
VAX / VMS to Intel i960™ MX / Bare 


Irvine Compiler Corporation 
34 Executive Park, Suite 270 
Irvine, CA 92714 
(714) 250-1366 

May 20, 1992 


1 ICC Ada Implementation 

The Ada language definition leaves implementation of certain features to 
the language implementor. This appendix describes the implementation- 
dependent characteristics of ICC Ada. 


2 Pragmas 

The following predefined pragmas are implemented in ICC Ada as described 
by the Ada Reference Manual (LRM): 


Elaborate This pragma allows the user to modify the elaboration order of 
compilation units. 

Inline Subprogram inlining is implemented. Inline substitutions are per¬ 
formed by the ICC optimizer. This pragma is not supported for generic 
subprograms or subprograms which contain nested subprograms. 

List This pragma enables or disables writing to the output list file. 


1 







2 


Optimize is a predefined pragma which has been implemented for both 
SPACE and TIME. Specifying this pragma currently does not control 
whether the ICC optimizer is called; however, it does impact which 
optimizations are performed. 

Pack Packing on arrays and records is implemented to the bit level. Slices 
of packed arrays are not implemented, except boolean arrays. 

Page This pragma ejects a new page in the output list file (if enabled). 

Priority This pragma sets the priority of a task or main program. The 
range of the subtype priority is 0..15. 

The following predefined pragmas have been extended by ICC: 

Interface This pragma is allowed to designate variables in addition to sub¬ 
programs. It is also allowed to have an optional third parameter which 
is a string designating the name for the linker to use to reference the 
variable or subprogram. The third parameter has the same effect as 
pragma Interface-name. 

Suppress In addition to suppressing the standard checks, ICC also permits 
suppressing the following: 

Assertion-check Suppressing Assertion-check suppresses the gen¬ 
eration of assertion checking code that is emitted when using the 
ICC-defined package ASSERTION. 

Exception-info Suppressing Exception-info improves run-time per¬ 
formance by reducing the amount of information maintained for 
messages that appear when exceptions are propagated out of the 
main program or any task. 

AU.xhecks Suppressing All-checks suppresses all of the standard 
checks as well as ExceptionJnfo and Assertion-check. 

The following predefined pragmas are currently not implemented by ICC: 

Controlled 
Memory jize 
Shared 





3 


Storage-unit 

Systemjiame 

The following additional pragmas have been defined by ICC: (For further 

details on these pragmas refer to the ICC Ada User's Reference Guide.) 

Access^ddress This pragma allows the user to indicate how an access 
type will be physically represented. The first parameter specifies the 
name of an access type. The second parameter specifies the type of 
address. Valid types are linear, virtual, and ad. Linear addresses 
are 32-bits wide. Virtual addresses are 64-bits wide and consist of an 
access descriptor (AD) and an offset. AD addresses are 32-bits wide 
and consist of an access descriptor with an implicit offset of zero. 

Compatible-calls This pragma is used to specify that pass-by-reference 
parameter passing should be used for OUT and IM OUT scalar param¬ 
eters. By default some of the ICC code generators use copy-in/copy- 
back for scalar OtTT and IH OUT parameters. This pragma allows pass- 
by-reference calls to be performed (primarily for downward compati¬ 
bility). 

Compress This pragma reduces the storage required for discrete subtypes 
in structures (arrays and records). Its single argument is the name 
of a discrete subtype. It specifies that the subtype should be repre¬ 
sented as compactly as possible (regardless of the representation of the 
subtype’s base type) when the subtype is used in a structured type. 
The storage requirement for variables and parameters is not affected. 
Pragma Compress must appear prior to any reference to the named 
subtype. 

Export This pragma is a complement to the predefined pragma Inter¬ 
face. It enables subprograms written in Ada to be called from other 
languages. It takes two or three arguments. The first is the language 
to be called from, the second is the subprogram name, and the third 
is an optional string designating the actual subprogram name to be 
used by the linker. Pragma Export must appear prior to the body of 
the designated subprogram. 

ExternaLname This pragma is equivalent to the ICC pragma Export 
with an implicit language type of “Ada” and a required external name. 




4 


This pragma allows the user to specify the exact name of the subpro¬ 
gram that will be used in the generated object file. This pragma is 
provided for compatibility with easting Ada source files. 

Foreign This pragma is used to add an object file or an object library file 
to the link command line used when linking the current compilation 
unit. Pragma Foreign is most frequently used in conjunction with 
pragma Interface so that foreign object files may be automatically 
included when the Ada compilation unit is linked. This pragma ac¬ 
cepts two parameters. The first pairameter indicates the location of 
the foreign object name on the link command line. It must be either 
Moxmal or Post. The second parameter is a string denoting the foreign 
object. This string is passed unmodified to the linker, so it should be 
a complete filename. If the location is Normal, then the foreign object 
is included immediately after the current Ada compilation unit on the 
link command line. If the location is Post, then the foreign object 
naime is included at the end of the link command line. When multiple 
Foreign Post pragmas are used in a single program, the order of the 
foreign objects on the link command line is not defined. 

Interiacexonstant allows access to externally defined constant values. It 
can only be applied to scalar variables and is similar to pragma In¬ 
terface except that it interfaces to a constant or address rather than 
to a value. 

Interface-Name This pragma takes a variable or subprogram name and 
a string to be used by the linker to reference the VEuiable or subpro¬ 
gram. It has the same effect as the optional third parameter to pragma 
Interface. 

Interrupt-handler This pragma is used when writing procedures that will 
be invoked as interrupt handlers (independent of the tasking runtime). 
It does not have any parameters and must appear immediately within 
the declarative part of a procedure. The presence of this pragma causes 
the code generator to produce additional code on procedure entrance 
and exit which preserves the values of all global registers. This pragma 
has no other effect. 

Noinline allows the programmer to specify that a subprogram never be 
inlined. This suppresses auto-inlining for the named subprogram. The 
parameter to pragma Noinline is a list of subprogram names. This 





5 


pragma is useful for machine code insertions where a call must always 
be performed. 

No^ero The single parameter to No-zero is the name of a record type. 
If the named record type has holes (or gaps) between fields that are 
normally initialized with zeroes, this pragma will suppress the clearing 
of the holes. If the named record type has no holes this pragma has 
no effect. When zeroing is disabled, comparisons (equality and non¬ 
equality) of the named type are disallowed. The use of this pragma 
can significantly reduce initialization time for record objects. The 
ICC Command Interpreter also has the qualifier /NO-ZERO which has 
the effect of implicitly applying pragma No.zero to all record types 
declared in the file. 

Optimize^ptions allows the user to modify optimization defaults. This 
allows better control of the options used in various portions of a com¬ 
pilation unit. This pragma has two parameters, a conuna-separated 
list of subprograms (optional), and a list of optimization options. The 
options are specified in named association format (i.e., option.najDia 
■> value). The option(s) are applied only within the scope of the 
enclosing declarative refpon and any nested re^ons. If a list of sub¬ 
programs is not supplied, the option(s) apply to all subprograms in the 
current compilation unit. Note that, like pragma Suppress, options 
specified by this pragma in a package specification are inherited by the 
package body. 

The following table summarizes the available options and their values: 


Hama 

Value 

Description 

Space 

Boolean 

Optimize for space 

Time 

Boolean 

Optimize for time 

Autoinline 

Boolean 

Enable/disable autoinlining 

Peephole 

All.xode 

Enable peephole optimizations for 
all code generated 


Nachina.code 

Enable peephole optimizations only 
for machine code insertions 

Ropeephole 

All-code 

Disable peephole optimizations 


Machine-code 

Disable peephole optimizations only 
for machine code insertions 

Inline 

Boolean 

Enable/disable explicit inlining 






6 


Protect- registers Tliis pragma is used with the I960.NACHIIIE jCOOE pack¬ 
age to specify a list of machine registers which should be saved on en¬ 
trance to the current subprogram and restored on exit. This pragma 
is used primarily for low-level interrupt handlers. 

Put, Put-line These pragmas take any number of arguments and write 
their value to standard output at compile time when encountered 
by the compiler. The arguments may be expressions of any string, 
enumeration, or integer type whose value is known at compile time. 
Pragma Put Jine adds a carriage return after printing all of its argu¬ 
ments. These pragmas are often useful in conjunction with conditional 
compilation. They may appear anywhere a pragma is allowed. 

Reserve-registers This pragma is used with the 1960-HACHINEjCODE 
pau:kage to reserve a list of registers for machine code insertions. The 
listed registers will not be used by the ICC Optimizer or ICC Code 
Generator so that the programmer can use them in machine code in¬ 
sertions. Note: Do not attempt to reserve the i960 special registers 
(i.e., rO, rl, r2, and gl5). This may cause error messages in the code 
generator. Reserving a large number of registers may cause the code 
generator to run out scratch registers and will cause the compilation 
to fail. 

Simple-task is used to eliminate the normal dynamic tasking runtime as¬ 
sociated with a task and request that the taisk be elaborated statically 
by the ICC i960 Initial Memory Image Builder. This pragma must 
appear within an entryless specihcation of a top-level task. Use of 
pragma Simple-task requires that there not be any operations per¬ 
formed that would require importing of the tasking nmtime. 

Simple tasks (i.e., those to which pragma Simple-task has been ap¬ 
plied) may not declare entries and may not perform entry calls. The 
pragmas Time-slice and Time-slice-attributes may be applied to 
simple tasks to modify their runtime behavior. 

Static-elaboration This pr^ma is used immediately within a package 
specihcation to state that all elaboration for the package is intended to 
be static. NOTE: This pragma does not modify the behavior operation 
of the Ada compiler; in particular, it does not enable static exceptions. 
This pragma only conveys information to the compiler that the user’s 
intention is that all elaboration for the package be static. Warnings 





7 


will be generated for all objects within the package specification or 
corresponding body which require dynamic elaboration; however, the 
compiler will still compile those packages statically. 

Time-slice may be used oidy in a task which has pragma Simple-Task 
applied to it. Pragma Time-Slice accepts one parameter: the period 
of a time slice. This parameter is of the predefined type Duration. 

Time-slice-attributes may be used only in a task which has pragma Sim¬ 
ple-Task applied to it. This pragma accepts one parameter: a list of 
initial values to be applied to the task’s Process Controls. 

Unsigned-Literal This pragma, when applied to a 32-bit signed integer 
type, affects the interpretation of literals for the type. Literals between 
2**31 and (2**32)-l are accepted for the type and are represented as 
if the type were unsigned. Operations on the type are unaffected. 
Note that (with checking suppressed) signed addition, subtraction, 
and multiplication are equivalent to the corresponding unsigned op¬ 
erations. However, division and relational operators are different and 
should be used with caution. 

Uselib This pragma is used within a context clause to explicitly add a 
list of named search libraries to the library search list of the current 
compilation. The specified libraries are searched first in all following 
WITH clauses. 

Volatile notifies the ICC Optimizer and Code Generator peepholer that a 
scalar variable’s value may change outside the scope of the program. 
Pragma Volatile accepts one parameter: the global scalar variable 
to be considered volatile. The use of this pragma suppresses value¬ 
following so that every reference to the specified variable always gen¬ 
erates a memory load or store instruction. This is useful for memory 
mapped I/O devices where a global variable may be mapped directly 
to a device address. 


3 Preprocessor Directives 

ICC Ada incorporates an integrated preprocessor whose directives begin 
with the keyword Pragma. They are as follows: 




8 


Abort This pragma causes the current compilation to be immediately 
halted. It is useful when unexpected circumstances arise inside condi¬ 
tionally compiled code. 

If, Elsif, Else, End These preprocessor directives provide a conditional 
compilation mechanism. The directives If and Elsif take a boolean 
static expression as their single argument. If the expression evaluates 
to Fabe then all text up to the next End, Elsif or Else directive is 
ignored. Otherwise, the text is compiled normally. The usage of these 
directives is identical to that of the similar Ada constructs. These di¬ 
rectives may appear anywhere pragmas are allowed and can be nested 
to any depth. 

Include This preprocessor directive provides a compile-time source file in¬ 
clusion mechanism. It is integrated with the library management sys¬ 
tem and the automatic recompilation facilities. 

Include..file is used to distinguish include Ales from normal Ada compi¬ 
lation units. If the Ada frontend encounters this pragma in a source 
file which has not been included (via Pragma Include), compilation is 
aborted immediately. NOTE: This pragma does not modify the behav¬ 
ior of the Ada compiler. It only conveys information to the compiler 
that the source file is intended as an include file. Specification of this 
pragma in include files is optional; however, ICC recommends this 
pragma be included in all include files to assist the ICM make facility. 

The results of the preprocessor pass, with the preprocessor directives 
deleted and the appropriate source code included, may be output to a 
Ale at compile-time. The preprocessor may be disabled by using the 
/HOPREPROCESS command-line qualiAer, in which case the above directives 
are ignored. 


4 Attributes 

ICC Ada implements all of the predefined attributes, including the Repre¬ 
sentation Attributes described in section 13.7 of the LRM. 

Limitations of the predefined attributes are: 






9 


Address This attribute cannot be used with a statement label or a task 
entry. 

The implementation-defined attributes for ICC Ada are: 

Alignment This attribute returns the bit alignment for the prefix type. 
The value returned is a universal integer. 

Architecture This attribute is for internal use within the ICC runtime and 
returns a value depending on the i960 architecture being targeted. 

Declared This attribute is used to test the state of a value that may have 
been provided on the command-line when the compiler was invoked. 
Declstred is used primarily in conditional compilation code (in con¬ 
junction with the preprocessor directive If) to modify how the source 
is compiled based on a compile-time option. The prefix to Declared 
must be a discrete type. Its result is a value of this discrete type. 

Linear- address This attribute is currently identical to the predefined at¬ 
tribute Address. In the future Linear.address wiE return the 32-bit 
linear address for i960 targets and Address will return a full 64-bit 
virtual address. 

Version, System, Target, CG.mode These attributes are used by ICC 
for conditional compilation. The prefix must be a discrete type. The 
values returned vary depending on the target architecture and oper¬ 
ating system. 


5 Input/Output Facilities 

Standard Input and Output for embedded targets is implemented through 
the serial communications link between the host and embedded system. The 
normal TEXT-10 calls PUT and GET can be used for console I/O. 

5.1 Virtual File System 

Since embedded systems typically do not have access to disk storage, file 
I/O operations are simxtlated through a BAM-based virtual file system im¬ 
plemented by a low-level runtime support package. This virtual file system 




10 


behaves like a disk-based file system, except that fiks do not persist be¬ 
tween program executions. Therefore, it is not possible to write a virtual 
file with one program and then to read it using another one. Also, the vir¬ 
tual hie system never raises the exception NAME-ERROR since all hie names 
are considered legal. 

The implementation-dependent specihcations from TEXT. 10 and DIRECT-10 
are: 


type COUNT it rang* 0 .. INTEGER'LAST; 

sabtyp* FIELD is INTEGER rang* 0 .. INTEGER'LAST; 


5.2 FORM Parameter 

ICC Ada implements the FORM parameter to the procedures OPEN and CREATE 
in DIRECT.IO, SEQUENTIAL-10, smd TEXT.IO to perform a variety of ancil¬ 
lary functions. The FORM parameter is a string literal containing parameters 
in the style of named parameter notation. In general the FORM parameter 
has the following format; 


fieldi ■> valuei (, fieldn ■> mlucn ] 
where fieldi va/ue,- can be 


OPTION 

■> 

NORMAL 

OPTION 

■> 

APPEND 

PAGE-MARKERS 

■> 

TRUE 

PAGE.MARKERS 

•> 

FALSE 

READ.INCOMPLETE 

•> 

TRUE 

READ.INCOMPLETE 

■> 

FALSE 

MASK 

■> 

<9 character protection mask> 


Each field is separated from its value by and each field/value pair 
is separated by a comma. Spaces may be added anywhere between tokens 
and case is insignihcant. For example: 

er*at*( f, out.fil*, "list.data”. 

"option «> app«nd, PA6B_NAHKERS «> FALSE, Mask •> xvxxvx*—"); 





11 


The interpretation of the fields and their values is presented below. 

OPTION Files may be opened for appending. This causes data to be ap¬ 
pended directly onto the end of an existing file. The default is NORMAL 
which overwrites existing data. This field applies to OPEN in all three 
standard I/O packages. It has no effect if applied to procedure CREATE. 

PAGE-MARKERS If FALSE then all TEXT. 10 routines dealing with page termi¬ 
nators are disabled. They can be called, however they will not have 
any effect. In addition the page terminator character ("L) is allowed to 
be read with GET and GET. LINE. The default is TRUE which leaves page 
terminators active. Disabling page terminators is particularly useful 
when using TEXT. 10 with an interactive device. For output files, dis¬ 
abling page terminators will suppress the page terminator character 
that is normally written at the end of the file. 

READ.INCOMPLETE This field applies to DIRECT. 10 and SEQUENTIAL.IO and 
dictates what will be done with reads of Incomplete records. Normally, 
if a READ is attempted and there is not enough data in the file for a 
complete record, then END.ERROR or DATA.ERROR will be raised. By 
setting READ. INCOMPLETE to TRUE, an incomplete record will be read 
successfully and the remaining bytes in the record will be zeroed. At¬ 
tempting a read after the last incomplete record will raise END.ERROR. 
The SIZE function will reflect the fact that there is one more record 
when the last record is incomplete and READ. INCOMPLETE is TRUE. 

MASK Set a protection mask to control access to a flle. The mask is the 
standard nine character string notation used by Unix. The letters 
cannot be rearranged or deleted so that the string is always exactly 
nine characters long. This applies to CREATE in all three standard 
I/O packages. The default is determined at runtime by the user’s 
environment settings. 

The letters in the Mask are used to define the Read, Write, and 
execute permissions for the User, Group, and World respectively. 
Wherever the appropriate letter exists, the corresponding privilege 
is granted. If a (dash) is used instead, then that privilege is de¬ 
nied. For example if Mask were set to "rw-rw-—” then read and 
write privileges are granted to the file owner and his/her group, but 
no world rights are given. 




12 


If a syntax error is encountered within the FORM parameter then the 
exception USE-ERROR is raised at the OPEN or CREATE call. Also, the stan¬ 
dard function TEXT-10.FORM returns the current setting of the form fields, 
including default values, as a single string. 


6 Package SYSTEM 


package SYSTEM is 

type SHORT.SHORT.OROIIAL is range 0..(2*e8)-l; 
lor SBORT.SHORT.OROIIAL'size use 8; 

type SHORT.OROIIAL is range 0..(2e*16}-l; 
lor SHORT.OROIIAL’size use 16; 


type OROIIAL is range 0..(2**32)-1; 
lor OROIIAL’size use 32; 

type lAME is (I960, 

Z960KA. I960KB, I960MC, 
Z9eOCA. I960SA. Z960SB, 
1960MN. I960XA, I960MX): 


STSTEM_IAME 

ST0RA6E_UIIT 

MEMORT.SZZE 

MII.IIT 

NAI_I1T 

MAX_DICITS 

NAX.NAITISSA 

FI1E_DELTA 

TICK 


constant 

constant 

constant 

constant 

constant 

constant 

constant 

constant 

constant 


lAME :* i960NZ: 

:* 8 ; 

:» 2 *( 2 ** 20 ); 

:* -2**31; 

:» 2**31-1; 

:» 15; 

:« 31; 

:■ 2.0**(-31); 
:« 1.0/4096.0; 


— Storage unit size in bits. 

— Bytes. 


— This is naz lor type 

— DORATIOI. 


type LIIEAR.AODRESS is range 0..(2**32)-1; 
lor LI1EAR_A00RESS’SIZE us* 32; 

type MIXED.VORD is range 0..(2**32)-l; 
lor MIIED-HORO'SIZS us* 32; 

subtype PRIORITY is ZITE6ER range 0 .. 15; — 0 is delault priority. 





13 


ELABORATIOI.PRIORITT: constant PRIORITY PRIORITY'LAST; 

— Constants for ths STIEEAP package 

BITS.PBR.BMtJ : constant :* 8; — Bits par basic aaebine unit 

MAX.iLIGDIEIT : constant :« 4; — Naziaiui alignnant rsqairsd. 

MIl_IfEM_BLOCK : constant :• 1024; — Miniana chunk raqnsst size. 

— Constants for the HOST package 

— H0ST_CL0CK_RES0Ltm01 changed to 128 aicrosaconds to support any 

— clock rate (16.2S.33Mh2) for the i960. See GET.TIME in HOST 

— for hov actual tiae is loaded. 

B0ST.CLQCK_RES0LUTI01 : constant 128; — 128 aicrosaconds 

BiSE_DiTE_CORRECTIOI ; constant :* 25.202; ~ Unix base data is 1/1/1970. 

IULL_LIIEiR_ADDRESS : constant LIIEAR_ADDSESS 0; 

subtype ADDRESS is LIIEAR.ADDRESS; 

pragaa P0T.LI1E ("Systea name is ", SYSTEM.IAME); 

IOLL_ADDRESS : constant ADDRESS 0; — Value of type ADDRESS 

equal to BULL. 


end SYSTEM; 


7 Limits 

Most data structures held within the ICC Ada compiler are dynamically 
allocated and, hence, have no inherent limit (other than available memory). 
Some limitations are: 


The maximum input line length is 254 characters. 

The maximum number of tasks abortable by a single abort state¬ 
ment is 64. 

Include files can be nested to a depth of three. 






14 


The number of packages, subprograms, tasks, variables, aggre¬ 
gates, types, or labels which can appear in a compilation unit is 
unlimited. 

The number of compilation units which can appear in one file is 
unlimited. 

The number of statements per subprogram or block is unlimited. 

Packages, tasks, subprograms, and blocks can be nested to any 
depth. 

There is no maximum number of compilation units per library, 
nor any maximum number of libraries per library system. 

There is no limit on the range of numeric literal values. 

There is no limit on the accuracy of floating point literal expres¬ 
sions. 

There are no limits on the depth, levels of parentheses, or the 
number of terms in an expression. 

All compile-time computations are done using exact integer or 
rational arithmetic. 


8 Numeric Types 

8.1 Integer Types 

ICC Ada supports three predefined integer types: 


Type 

Value Range 

Width 

SHORT.SHORT.IHTEGER 

-128..127 

8 bits 

SHORT. IllTEGER 

-32768..32767 

16 bits 

IITEGER 

-2147483648..2147483647 

32 bits 


In addition, unsigned 8-bit, 16-bit, and 32-bit integer types can be de¬ 
fined by the user via the SIZE length clause. Storage requirements for types 
can be reduced by using pragma Pack and record repr^eutation clauses; 
for subtypes, by using the ICC pragma Compress. 


15 


8.2 Ordinal Types 

ICC Ada supports the declaration of ordinal types using the size length 
clause. The following ordinal types are defined in package SYSTEM: 


Type 

Value Range 

Width 

SYSTEM.SHORT-SHORT-ORDINAL 

0..255 

8 bits 

SYSTEM.SHORT-ORDINAL 

0..65535 

16 bits 

SYSTEM.ORDINAL 

0..4294967295 

32 bits 


All predefined operators for signed integers are also defined for the ordi¬ 
nal types. 


8.3 Floating and Fixed Point Types 

Type Float and type Short .float are implemented and have the following 
attributes: 


Attribute 

Value 


type FLOAT 

type SHORT-FLOAT 

Machina.rounds 

FALSE 

FALSE 

Machine.overflows 

FALSE 

FALSE 

Machine.radiz 

2 

2 

Machine.mantissa 

52 

23 

Machine, einaz 

1020 

124 

Machine.emin 

-1021 

-125 

Mantissa 

51 

21 

Digits 

15 

6 

Size 

64 

32 

First 

-1.79769313486232£; -I- 308 

-3.40282F + 38 

Last 

1.79769313486232F-I- 308 

3.40282F-I-38 

Base’First 

-1.79769313486232£; + 308 

-3.40282F-I-38 

Base’Last 

1.79769313486232£; + 308 

3.40282f;-i-38 

Emaz 

204 

84 

Safe-Emaz 

1020 

124 

Epsilon 

8.88178419700125£; -16 

9.53674316406250f?-07 

Small 

1.94469227433161F - 62 

2.58493941422821f; - 26 

Safe.small 

4.45014771701440F- 308 

2.35098870164458£ - 38 

Large 

2.57110087081438F -1- 61 

1.93428038904620£;-t-25 

Safe.large 

1.12355820928895F+307 

2.12676377913539F-I-37 












16 


Fixed point types automatically assume the smallest storage size nec¬ 
essary to represent all of the model numbers with the indicated delta and 
range. The size of a fixed point type may be changed via the SHALL rep¬ 
resentation clause and the SIZE length clause. Unsigned fixed point types 
may be defined using the SIZE length clause. 

NOTE: ICC Ada rounds fixed point values away from zero at the mid¬ 
point between integral values. On the i960, ICC Ada uses round-to-nearest- 
even for floating point types. This means that the same value will round 
to an integer differently depending on whether it is a fixed or floating point 
value. The following table details the rounding behavior of fixed and floating 
point types on the i960. 


Value 

Fixed Round 

Float Round 

1.00 

1 

1 

1.25 

1 

1 

1.50 

2 

2 

2.50 

3 

2 

2.75 

3 

3 

3.50 

4 

4 

-1.25 

-1 

-1 

-1.50 

-2 

-2 

-1.75 

-2 

-2 

-2.50 

-3 

-2 


8.4 Other Numeric Types 

The ICC-defined type SYSTEM.ADDRESS is represented as a 32-bit unsigned 
integer. This allows address calculations to be performed as unsigned values 
and also allows the use of unsigned 32-bit literals. 

The ICC-defined type SYSTEM.MIXED-WORD is a special 32-bit ordinal 
type which preserves the tag (33rd) bit on the i960 processor. 


9 Tasks 


The type DURATIOI is defined with the following characteristics: 



17 


Attribute 

Value 

Delta 

2.44140625£; - 04 sec 

Small 

0.0002 sec 

First 

-524287.0 sec 

Last 

524287.0 sec 


The subtype SYSTEM.PRIORITY a£ defined provides the following range: 


Attribute 

Value 

First 

0 

Last 

15 


Higher numbers correspond to higher priorities. If no priority is specified 
for a task, PRIORITY’FIRST is assigned during task creation. 


10 Representation Clauses 

10.1 Type Representation Clauses 

10.1.1 Length Clauses 

The amount of storage to be associated with an entity is specified by means 
of a length clause. The following is a list of length clauses and their imple¬ 
mentation status: 

• The SIZE length clause is implemented. When applied to integer-range 
types this length dause can be used to reduce storage requirements, 
induding storage of unsigned values. It moy be used to dedare an 
unsigned 32-bit type. Length dauses are allowed for float and fixed 
point types, however the storage requirements for these types cannot 
be reduced below the smallest applicable predefined type available. 

• The STORAGE.SIZE length dause for task types is implemented. The 
size specified is used to allocate both the task’s Task Information Block 
(TIB) and its stack. 

• The STORAGE-SIZE length dause for access types is implemented. 
When a length dause is encountered for an access type, a block of 





18 


memory is reserved in the user’s heap space. This block of memory 
cannot be expanded beyond the bounds specified in the length clause. 
When the memory in this block is exhausted, STORAGE.ERROR is raised. 
Due to heap management overhead, the full amount of memory indi¬ 
cated in the length clause may not be available for allocation. 

• The SMALL length clause for fixed point types is implemented for pow¬ 
ers of two. ICC Ada does not support SHALL values that are not 
integral powers of two. 

10.1.2 Enumeration Representation Clauses 

Enumeration representation clauses are implemented. The use of enumera¬ 
tion representation clauses can greatly increase the overhead associated with 
their reference. In particular, FOR loops on such enumerations are very ex¬ 
pensive. Representation clauses which define the default representation (i.e., 
the first element is ordinal 0, the second 1, the third 2, etc.) are detected 
and cause no additional overhead. 

10.1.3 Record Representation Clauses 

Record representation clauses are implemented to the bit-level. Records con¬ 
taining discriminants and dynamic arrays may not be organized as expected 
because of unexpected changes of representation. There are no implemen¬ 
tation generated names that can be used in record representation clauses. 

Record representation clauses allow more precise packing than pragma 
Pack. Record representation clauses allow the user to specify the exact 
location of fields within a record to the bit-level. The ICC Ada compiler 
implements bit-level record representation clauses including nested records 
starting on bit-boundaries. Since the user specifies the exact bit location, 
overhead for extracts and stores may be very high, so record representation 
clauses should be applied very carefully. Record representation clauses are 
implemented using the following rules: 

• Fidds of records may be allocated to the nearest bit for elements 
which are smaller than 32-bits. This includes small nested records. 
Elements which are 32-bits or larger (and all arrays) must be placed 
on byte boundaries. 





19 


• If the specified storage space for an element is not adequate using its 
default allocation, it will automatically be packed in two stages: (1) 
normal packing will be attempted using the default alignment rules. If 
this does not adequately reduce storage then (2) bit-level packing will 
be attempted with aU fields aligned on 8-bit or smaller boundaries. If 
this bit-level packing still does not meet the storage requirement, an 
error message will be generated. 

• The optional alignment clause may be used to specify an alignment 
up to 8192 bytes. However, records can only be aligned to 16 bytes 
when used within a local stack frame. If a record with an alignment 
larger than 16 is allocated in the local frame of a subprogram, an error 
message will be generated. 

• AU fields of a record representation clause which are left unspecified 
wiU be aUocated at the end of the record using the default alignment 
rules for each element. 

• The fields of a record representation clause may be specified in any 
order and the storage order of the fields does not need to be the same 
as the order in which they were declared. 

• If no alignment clause is specified, the aligiunent requirement for the 
record is equivalent to the largest aUgnment requirement of its ele¬ 
ments. 

10.2 Address Clauses 

Address clauses are implemented for variables. Address clauses for local 
variables using dynamic values are implemented. The use of a dynamic ad¬ 
dress can faciUtate overlaying since the address specified may be the value of 
a variable of type System. Address or may be the result of an expression us¬ 
ing the predefined Address attribute. Address clauses are not implemented 
for subprograms, packages, tasks, constant objects, or statement labels. 


11 Interface to Other Languages 

Pragma Inter&ce aUows Ada programs to interface with (i.e., caU) subpro¬ 
grams written in another language (e.g.. Assembly); pragma Export aUows 




20 


programs written in another language to interface with programs written 
in Ada. The accepted languages are: Intrinsic, Ada, C, and Assembly. 
The aliases Assembler and ASK can be used instead of Assembly. The 
alias Builtin can be used instead of Intrinsic. The language Intrinsic 
should be used with extreme care—^it is used by ICC for internally handled 
operators. 

12 Unchecked Type Conversion 

The generic function Unchecked-conversion is implemented. In general. 
Unchecked-conversion can be used when the underlying representations of 
values are similar. 

Acceptable conversions are: 

• Conversion of scalars. Unchecked-conversion can be used to change 
the type of scalar values without restriction. In most circumstances 
the unchecked conversion produces no additional code. 

• Conversion of static constrained structures. Constrained static arrays 
and records are represented as contiguous areas of memory and, hence, 
can be converted using unchecked-conversion. 

• Conversion of scalars to static constrained structures. Scalar objects 
may be converted to static constrained structures with no ad^ditional 
overhead. If a scalar value is converted to a structure, an aggregate 
is first built to hold the scalar value and its address is used as the 
address of the resulting structure. 

Because the representation of dynamic structures uses implicit pointers 
and dope*vectors, ICC Ada does not allow unchecked conversions to or from 
dynamic or unconstrained structures (arrays or records). A compile-time 
error message will be generated for such instantiations. 

Although the Ada compiler does not produce errors for the following 
unchecked conversions, they should be avoided since their results are not 
obvious: 

• Conversion from constrained discriminant records. Conversion from 
discriminant records can cause unpredictable behavior because of un- 
deriying representation changes. Ihichacked-conversion will use the 



21 


same rules as described above for performing the copy; however, the 
results of this operation may not be what the user desires since ICC 
Ada does not place arrays constrained by the discriminant in-line with 
the other fields in a discriminant record. In place of the array only a 
pointer is used and the array is allocated dynamically from the inter¬ 
nally maintained heap. 

• Con version to or from pointers to unconstrained arrays. Unconstrained 
array pointers are implemented as special dope-vectors in ICC Ada. 
Conversions to or from these dope-vectors are not recommended. 

• Conversion to or from any type or object declared in a generic. Gener¬ 
ics can cause hidden representation changes. Unchecked, conversions 
of any object or type declared in a generic shotild be avoided. 


ICC Ada does not require that the sizes of the parameters to an 
unchecked, conversion be identical. The size of the target type is used 
to determine the number of bytes to copy. The size of the target type (in 
bytes) is determined by the Ada frontend and exactly that many bytes are 
copied from the source address to the ta^et address. This can cause prob¬ 
lems (e.g., memory faults) when the source object is smaller than the target 
object. For example, using imchsckad. conversion to convert a character 
into an integer will cause four bytes to be copied starting from the address 
of the character. The first byte copied will be the value of the character, 
but the values of the remaining three bytes cannot be predicted since they 
depend on values of variables or fields immediately after the character in 
memory. If the source object is larger than the target object then only the 
bytes that will fit in the target object are copied from the source starting at 
the address of the first byte of the source. 


13 Unchecked Storage Deallocation 

Uhchecksd.deallocation is implemented. Iftichacked-deallocation of 
structures contsdning dynamic dements (such as discriminant records with 
dynamic arrays) should not be performed nnce these nested structures are 
not automatically deallocated. 





V 


22 

14 Machine Code Insertion 

The package MACHIHEjCODE described in the LRM is not provided or sup¬ 
ported. Instead, machine code insertion is implemented using the ICC- 
defined package I960 -MACHINEjC 00E. This package defines a variable for 
each machine register (GO, Gl, RO. FPO, etc.) and a procedure for each 
instruction (ADOI, AODO, CALL, LDL, etc.). References to these special 
variables and calls to these special procedures axe trapped by the ICC Na¬ 
tive Code Generator and converted into the appropriate machine object 
(register or instruction). This allows machine code to be inserted in any 
context, including interspersed within Ada statements. 

For example, to perform an FMARK instruction in the middle of a subpro¬ 
gram, the following could be written: 

with i960_uchin«.coda; 
oww i960_Bachin«_eod«: 

procwdurw fore«_aark.il^««d«d(twst.condition: boolean: 

val: integer) is 

begin 

a test.condition then —* II we're supposed to FMARK... 

■ovfval, gO): Novo VAL paraaoter into GO. 

faark; — Force Nark, 

end if; 
end; 

In addition, the following subprograms are declared in . package 
ISeO-NACHIHEJCODE: 

address.index This function can be used to explicitly build complex addressing modes 
with an ofiset of type Sjstes. Address for use in the LOAD and STORE 
instructions. The Base, Offset, Index-register, and Scaling-factor can 
all be explicitly provided. 

integer, index This function can be used to explicitly build complex addressing modes 
with an offset of type Integer for use in the LOAD and STORE instruc¬ 
tions. The Base, Offset, Index-re^ster, and Scaling-factor can all be 
explicit^ provided. 

index This function is identical to address.index. 




23 


labsl This subprogram is overloaded as both a procedure and a function. 
When called as a procedure it will emit a label with the corresponding 
integer ordinal value into the output code. When called as a function 
it will reference the corresponding label. These subprograms are used 
primarily for branches and loops. 







