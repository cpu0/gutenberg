

nor.i (MENTATION PAGE 


FomAppfov*d / 

Of>UNo. 07044*$ ( £X, 


AD-A226 897: 


Sit tm w 5SS M EStyjf SS Tujt SLm d2*f*p*** im*.**^*.** 




mtomoATt 


l NCPO*T TYfC AMD DATES COS* PCD 

Fina) U June 1990 to il June 1991 


^mEAWDMTmjE Ada Compiler Validacion Summary Rcporc: Telcsofc *.*»»«**•*« 
reletten2 Sun-3 Ada Development System, Sun-3 Clfosc 5 Target), 

900525X1.11012 

•.Aimovsj 

IABG-AVF 

Occobrunn, FEDERAL REPUBLIC OF GERMANY 


7.KRFORM*«CWGANaATONHA1b*(S)AWAOOflES3<ES) * , , 

IABG-AVF, Induscricanlagen-Becriebsgcselschafc 

Depc. S2T 
Einsceinscrassc 20 
D-8012 Occobrunn 

FEDERAL REPUBLIC OF-GERMANY _ 

t. a^cmontwJOH(von»*a agency namE(S) and acoaess<es) 

Ada Joinc Program Office 

United Scaces Deparctsenc of Defense 

Washington, D.C. 20301-3081 


*. KlfOWIC ORGANIZATION 

report number 

AVF-IABG-07Q 


10, VOKSOnwOAOCTOflWG AGENCY 
REPORT NUMKB 


11. «UffL£ ME NTARY NOTES 


12*. DCSTR»UTCNAVALA1UTY STATEMENT 


Approved for public release; distribution unlimited. 


12*. DtSTRBUTlON COOE 


CL. 13. ABSTRACT (kkarntnlCOwcnk) 

o 

CL TeleSoft, TeleGcn2 Sun-3 Ada Development System, Ottobrunn, West Cermany, Sun Microsystems 
Sun-3 Workstation (68020 based Sun-3/280) under Sun UNIX A.2, Release A.0.3, ACVC 1.11. 

, p, t - p 

' 't-J fl Ji K 


»r; , r 


SEP 2 5 1900J fj 

m'/i y 

to Cb us& 


14. SUBJECT TERMS Ada programming language, Ada Compiler Validation 
Summary Report, Ada Compiler Validation Capability, Validation 
Testing, Ada Validation Office, Ada Validation Facility, ANSI/MIL- 
STD-1815A, Ada Joint Program Office_•_ 


Of REPORT 

UNCLASSIFIED 
NSN 7840-01>290-5500 


1«. SECURITY CLASS# 
Of THIS RAGE 
UNCLASSIFIED 


90 01; 


il. SEwJRJTY CLASsFl 
OF ABSTRACT 

UNCLASSIFIED 


(i,i 


11. NUMBER OF RAGES 


W.RfUCEOOOE 

20. UMfTATION Of ASSTHAcf 


SuntMrt Hyrm JsMfjyv- 2-59) 

Fi**afc«4*AN»l **.»»■'* 






r 


CHAPTER 1 
INTRODUCTION 


\ji / (\ 

■"This Validation Summary Report (#SR*r describes the extent to vhich a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. 
This report explains all technical terns used within it and thoroughly 
reports the results of^_tcsting this compiler using the Ada Compiler 
Validation Capability An Ada compiler must be implemented 

according to the Ada Standard, and any implementation-dependent features 
must conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that is 
not in the Standard. , 


c 

Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between implementations. 
The Ada Standard permits some implementation dependencies—for example, the 
maximum length of identifiers or the maximum values of integer types. 
Other differences between compilers result from the characteristics of 
particular operating systems, hardware, or implementation strategies. All 
the dependencies observed during the process of testing this compiler are 
given Jn_l his report, 'y 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results.''.The purpose of validating is to ensure conformity 
of the compiler to the Ada Standard by testing that the compiler properly 
implements legal language constructs and that it identifies and rejects 
illegal language constructs. The testing also identifies behavior that is 
implementation-dependent blit is permitted by the Ada Standard. Six classes 
of tests are used. These\tests are designed to perform checks at compile 
time, at link time, and during execution. 


■fk'R ) (f 


1-1 




AVF Control Number: AVF-IABG-Q7Q 
11 June 1990 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: #90052511.11012 
Telesoft 

TeleGen2 Sun-3 Ada Development System 
Sun-3 Host and Target 


Prepared By: 
IABG mbH, Abt. ITE 
Einsteinstrass® 20 
D-8012 Ottobrunn 
West Germany 







Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing wa3 completed on 25 May 1990. 

Compiler Name and Version: TeleGon2 Sun-3 Ada Development 

System, Version 4.01 

Host Computer System: Sun Microsystems Sun-3 Workstation 

(68020 based Sun-3/280) 

under Sun UNIX 4.2, Release 4.0.3 

Target Computer System; Same as host 


A more detailed description of this Ada implementation is found in section 
3.1 of this report. 

As a result of this validation effort. Validation Certificate 
is awarded to Tolesoft. This certificate 
expires on 01 June 1992. 


This report nas been reviewed and is approved. 


cJ. ) 


IABG mbH, Abt. ITE 
Michael Tonndorf 
Einstein3trasse 20 
D-8012 Ottobrunn 
West Germany 




Ada Validation Organization 
f ' Director, Computer £ Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 


Ada Joint Program Office 
Dr. John Solomond 
Director 


Department of Defense 
Washington DC 20301 







DECLARATION OF CONFORMANCE 


Customer: TcleSoft 

Adit Validation Facility: IADG, Dept. S2T, D-8QI2 Ottobrunn 
AC VC Version: 1.11 
Ada Implementation: 

Compiler Name and Version: TcleGcn2™ Sun-3 Ada Development System, Version *1.01 

Host Computer System: Sun Microsystems* Sun-3 Workstation 

(68020 based Sun-3 < 280} 

Sun™ UNIX™ 4.2, Release 4.0.3 Operating System 
Target Computer System: same as Host Computer System 

Customer’s Declaration 

1, the undersigned, representing TelcSoft, declare that TeleSoft has no knowledge of deliberate 



Raymond A. Parra, Vice President and General Counsel 


Sun .Microiyitemi it a regiitcrcd trademark of Sun Microiyitemi, Inc. Sun ii a trademark of Suo Microiyatcmi, Inc. UNIX It a 
trademark of ATiT/Ball Laboratoriei. 





CONTENTS 


CHAPTER 1 TEST INFORMATION. 1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT .... 1 

1.2 REFERENCES ..2 

1.3 ACVC TEST CLASSES.2 

1.4 DEFINITION OF TERMS . 3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES . 5 

2.2 WITHDRAW} TESTS...5 

2.2 INAPPLICABLE TESTS...5 

2.3 TEST MODIFICATIONS.8 

CHAPTER 3 PROCESSING INFORMATION . 9 

3.1 TESTING ENVIRONMENT . 9 

3.2 TEST EXECUTION.10 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 















CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the ,\da 
Validation Procedures (Pro89) against the Ada Standard (Ada83) using the 
current Ada Compiler Validation Capability (ACVC), This Validation Summary 
Report (VSR) gives an account of the testing of this Ada implementation. For 
any technical terms used in this report, the reader is referred to [Pro89). A 
detailed description of the ACVC may be found in the current ACVC User's Guide 
(UG891 . 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 

In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply only 
to the computers, operating systems, and compiler versions identified in this 
report. 

The organisations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are accurate 
and complete, os. that the subject implementation has no nonconformities to the 
Ada Standard other than those presented. Copies of this report are available 
to the public from the AVF which preformed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 


Questions regarding this report or the validation test results should be 
directed to the AVF which performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1 







1.2 REFERENCES 


(Ada83] Reference Manual for the Ada Programming Language , 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987, 

(Pro89) Ada Compiler Validation Procedures , Version 2.0, Ada Joint Program 
Office, May 1989. 

(UG89] Ada Compiler Validation Capability User*s Guide, 21 June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: A, B, 
C, D, E, and L. The first letter of a test name identifies the class to which 
it belongs. Class A, C, D, and E tests are executable. Class B and class L 
tests are expected to produce errors at compile time and link time, 
respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they are 
executed. Three Ada library units, the packages REPORT and SPPRT13, and the 
procedure CHECK_FIL£ are used for this purpose. The package REPORT also 
provides a set of identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK__FILE is used to check the contents of text 
files written by 3oma of the Class C tests for Chapter 14 of the Ada Standard. 
The operation of REPORT and CHECK__FILE is checked by a set of executable 
tests. If these units are not operating correctly, validation testing is 
discontinued. 

Class B tests check that a compiler detects illegal language usage. Class 3 
tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of the 
Ada Standard are detected. Some of the class B tests contain legal Ada code 
which must not be flagged illegal by the compiler. This behavior is also 
verified. 

Class L tests check that an Ada implementation correctly detects violation of 
the Ada Standard involving multiple, separately compiled units. Errors are 
expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list of 
the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen conflicts between the tests and implementation- 
dependent characteristics. The modifications required for this implementation 
are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by the AVF. 
This customization consists of making the modifications described in the 
preceding paragraph, removing withdrawn tests (see section 2.1) and, possibly 
some inapplicable tests (see Section 3.2 and (UG89)). 


2 






In order to pass an ACVC an Ada implementation must process each teat of tho 
customised test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 

Ada Compiler The software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compiler The moans for testing compliance of Ada implementations, 
Validation consisting of the test suite, the support programs, the ACVC 

Capability user's guide and the template for the validation summary 

(ACVC) report. 

Ada An Ada compiler with its host computer system and its 

Implementation target computer system. 

Ada The part of the certification body which carries out the 

Validation procedures required to establish the compliance of an Ada 
Facility (AVF) implementation. 

Ada The part of the certification body thet provides technical 

Validation guidance for operations of the Ada certification system. 

Organization 
(AVO) 

Compliance of The ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Computer A functional unit, consisting of one or more computers and 

System associated software, that uses common storage for all 

or part of a program and also for all or part of the data 
necessary for the execution of the program; executes user- 
written or user-designated programs; performs user-designa¬ 
ted data manipulation, including arithmetic operations and 
logic operations; and that can execute programs that modify 
themselves during execution. A computer system may be a 
stand-alone unit or may consist of several inter-connected 
units. 

Conformity Fulfillment by a product, process or service of all 

requirements specified. 

Customer An individual or corporate entity who enters into an 

agreement with an AVF which specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

Declaration of A formal statement from a customer assuring that conformity 
Conformance is realized or attainable on the Ada implementation for 
which validation 3tatus i3 realized. 

Host Computer A computer system where Ada source programs are transformed 


3 






Syatem 


into executable farm. 


Inapplicable 

teat 

■Operating 

Syatem 


Target 

Computer 

Syatem 

Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn 

teat 


A teat that containa one or more teat objoctivea found to bo 
irrelevant for the given Ada implementation. 

Software that controla the execution of programa and that 
providea aervicea auch aa reaource allocation# acheduling, 
input/output control, and data management. Uaualiy, 
operating ayatema are predominantly aoftware, but partial or 
complete hardware implementatlona are poaaible. 

A computer ayatem where the executable form of #\da programa 
are executed. 


The compiler of a validated Ada implementation. 


#\n Ada implementation that haa been validated aucceaafully 
either by AVF tearing or by regiatration (Pro89). 

The proceaa of checking the conformity of an Ada compiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A teat found to be incorrect and not uaed in conformity 
tearing. A teat may be incorrect becauae it haa an invalid 
teat objective, faila to meet ita teat objective, os 
containa erroneoua or illegal uae of the Ada programming 
language. 


4 





CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some costs are withdrawn from die ACVC because they do not conform to the Ada 
Standard. The following 55 testa had been withdrawn by the Ada Validation 
Organization (AVO) when preparing for validation testing. The rationale for 
withdrawing each teat is available from either the AVO or the AVF. The publi¬ 
cation date for this list of withdrawn tests if; 90-03-23. 


E2900SC 

C34006D 

B41308B 

C45114A 

C456123 

C45S51A 

C46022A 

B4900BA 

A74006A 

B83022B 

383022H 

3830253 

B83025D 

B83026B 

C93026A 

C83041A 

C97116A 

C98003B 

3A2011A 

CB7001A 

CB70018 

CB7004A 

CC1223A 

BC122GA 

CC1226B 

BC3009B 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B1SC 

BD3006A 

CD4022A 

CD4022D 

CD4024S 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD1B08A 

AD7005A 

CD7005E 

AD7201A 

AC7201E 

CD7204B 

BD8002A 

BD8004C 

CD9005A 

CD90053 

CDA201E 

CE2107I 

CE2119B 

CE3111C 

c; 9A 

CS3411B 

CE3412B 

CE3812A 

CE3814A 

CE3902B 



Tests B28006C and C43004A were withdrawn before the start of valie^ .ron. The 
tests were processed and the results were ignored. 

2.2 INAPPLICABLE TESTS 

A test is inapplicable, if it contains test objectives which are irrelevant for 
a given Ada implementation. The inapplicability criteria for 3ome te3t3 are 
explained in documents issued by ISO and the AJPO known a 3 Ada Issues and 
commonly referenced in the format Al-dddd. For this implementation, the 
following tests were inapplicable for the reasons indicated; references to Ada 
Issues are included as appropriate. 


The following 201 tests have floating-point type declara.ions requiring 
more digits than SYSTEM.MAX_DIGITS: 

C24113L..Y (14 test3) C35705L..Y (14 test3) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 


5 








C357Q8L, .Y (\4 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tasts) 
C45524L..Z (15 testa) 
C45641L,. Y (14 testa) 


C35802L..Z (IS teats) 
C4S321L.«Y (14 teats) 
C45521L..Z (15 teats) 
C4S621L.»Z (15 tests) 
C46012L.,Z (15 tests) 


C35404D, C45231D, B86QQ1X, C9600SE, and CD7101G check for a predefined 
integer type with a name other than INTEGER, LONG_INTEGER, or 
SHQRT_INT£GER. 

C355Q8I, C35508J, C3S508M, and C35508N include enumeration representation 
clauses for BOOLEAN types in which the representation values are other 
than (FALSE *•> 0, TRUE -> 1). Under the terms of AI-00325, this 
implementation is not required to support such representation clauses. 

C35702A, C35713B, C454233, B86001T, and C06006H check for the predefined 
type SHORT_FLOAT. 

C3S713D and B860012 check for a predefined floating-point type with a name 
other than FLOAT or LQNG_FLOAT. 

C45531M..P (4 tescs) and C45532M..P (4 tests) are not applicable because 
they require a value of SYSTEM.MAX_MANTISSA greater than 32. 

C45624A checks that the proper exertion is raised if MACHINS_OVERFLOWS is 
FALSE for floating point types with digits 5. For this implementation, 
MACHINE OVERFLOWS is TRUE. 


C45624B checks that the proper exception is raise** if MACHINE_OVERFLOWS is 
FALSE for floating point typos with digits 6. For thi3 implementation, 
MACHINE OVERFLOWS is TRUE. 


C86001F recompiles package SYSTEM, making package TEXT_IO, and hence 
package REPORT, obsolete. For this implementation, the package TEXT^IO i3 
dependent upon package SYSTEM. 

B86001Y checks for a predefined fixed-point type other than DURATION. 

CA2009C, CA2009F, BC3204C and BC3205D make use of certain separate 
compilation features for generic units which are not supported by this 
implementation. This implementation creates a dependence between a generic 
body and those unit3 which instantiate it. As allowed by AI-408/11, if the 
body is compiled after a unit that instantiates it, then that unit becomes 
obsolete. 


CD10C9C uses a representation clause specifying a non-default 3ize for a 
floating-point type. 

CD2A84A, CD2A84E, CD2A84X..J (2 tests), and CD2A840 use representation 
clauses specifying non-default sizes for access types. 

The tests listed in the following table are not applicable because the 
given file operations are supported for the given combination of mode and 
file access method. 


6 






Test 


File Operation Mode 


File Access Method 


CE2102D 

CREATE 

IN_F'LE 

SEQUENTIAL_IO 

CE2102E 

CREATE 

QUT_FILS 

SEQUENTIAL_IO 

CE2102F 

CREATE 

1N0UT_FILE 

DIRECT JR) 

CE2102I 

CREATE 

IN_FXLE 

DIRECT_IO 

CE2102J 

CREATE 

OUTJFILE 

DIRECT_IO 

CE2102N 

OPEN 

inJFils 

SEQU£NTIAL_IO 

CE2102O 

RESET 

IN_FILE 

SEQUENTIAL_IO 

CE2102P 

OPEN 

OUT_FILE 

SEQUENTIALJO 

CS2102Q 

RESET 

OUT_FILE 

SEQUENTIAL_IO 

CE2102R 

OPEN 

INQUT_FILE 

DIRECTJTO 

CE2102S 

RESET 

XNOUT_FILE 

DXR£CT_XO 

CE2102T 

OPEN 

IN_FILE 

DIRECT JR) 

CE2102U 

RESET 

IN_FILE 

DIR£CT_IO 

CE2102V 

OPEN 

OUT_FILE 

DIRECT_IO 

CE2102W 

RESET 

OUT_FILE 

DIRECT_IC 

CE3102E 

CREATE 

:n_f ILE 

TEXTJO 

CE3102F 

RESET 

Any Mode 

TEXTJEO 

CE3102G 

DELETE 


T£XT_IO 

CE3102I 

CREATE 

OUT_FIIiE 

TEXT_IO 

CE3102J 

OPEN 

IN_FILE 

TEXT_IO 

CE3102K 

OPEN 

OUT FILE 

TEXT 10 


CE2107B..5 (4 tests), CE2107L, and CE2110B attempt to associate multiple 
internal files with the same external file when one or more files is 
writing for sequential files. The proper exception is raised when 
multiple access is attempted. 

CE2107G..H (2 tests), CE2110D, and CE2111H attempt to associate multiple 
internal files with the same external file when one or more files i3 
writing for direct files. The proper exception is raised when multiple 
access is attempted. 

CE2111D checks the resetting of an external file from IN_FILE to OUT_J*XLE. 

CE2203A checks that WRITE raises USE_ERROR if the capacity of the external 
file is exceeded for SEQUENTIAL_I0. This implementation does not restrict 
file capacity. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of the external 
file is exceeded for DIRECT_IO. This implementation doos not restrict 
file capacity. 

CE3111B, CE3111D..E (2 tests), CE3114B, and CE3115A attempt to associate 
multiple internal files with the same external file when one or more files 
is writing for text files. The proper exception is raised when multiple 
access is attempted. 

CE3304A checks that USE_ERROR i3 raised if a call to SET_LINE_LENGTH or 
SET_PAGE_LENGTH specifies a value that is inappropriate for the external 
file. This implementation does not have inappropriate values for either 
line length or page length. 

CE3413B checks that PAGE rai3e3 LAYOUT_ERROR when the value of the page 


7 









number exceed3 COUNT'LAST. For this implementation, the value of 
COUNT'LAST ia greater than 150000 making the checking of thia objective 
impractical. 


2.3 TEST MODIFICATIONS 

Modificationa (aee aection 1.3) were required for 21 teaca. 

The following teaca were aplit into two or moro ceata becauae thia 
implementation did not report the violaciona of the Ada Standard in the way 
expected by the original teaca, 

BA1001A BA2001C 8A2Q01E BA3006A BA3006B 

BA30073 BA3008A BA3008B BA3013A 

The following 4 teaca cauae errora at bind time inatead of at compile time. 

BC3204C BC3205D CA2009C CA2009F 

CD1009A, CD1009I, CD1C03A, CD2A21C, CD2A24A, CD2A31A..C (3 teata), uae 
inatantiaciona of the aupport procedure LengthjCheck, which uaea 
UnchackedjConveraion according to the interpretation given in AI-00590. The 
AVQ ruled that thia interpretation ia not binding under ACVC 1.11; the teaca 
are ruled to be paaaed if they produce Failed meaaagea only from the 
inatantiaciona of LengthjCheck -- ie, the allowed Report.Failed meaaagea have 
the general form: 

" * CHECK ON REPRESENTATION FOR CTYPE ID> FAILED." 


8 






CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 


The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact for both technical and sales information 
about this Ada implementation system, see: 

Telesoft 

5959 Cornerstone Court Nest 
San Diego, CA 92121-9819 
(619) 457-2700 


Testing of this Ada implementation wa3 conducted at the customer's 3ite by 
validation team from the AVF. 


9 












3.2 TEJT EXECUTION 

Version 1.11 of the ACVC comprises 46Q6 tests. When this compiler was tested, 
the tests listed in section 2.1 had been withdrawn because of test errors. 

The AVF determined that 28Q tests were inapplicable to this implementation. 

All inapplicable tests were processed during validation testing except for 201 
executable tests that use floating-point precision exceeding that supported by 
Che implementation. In addition, the modified tests mentioned in section 2.3 
wore also processed. 

A cape cartridge containing the customized test suite (see section 1.3) was 
taken on-site by the validation team for processing. The contents of the tape 
cartridge wore loaded onto an auxiliary computer and then transferred via 
Ethernet to the host computer. 

After the test files were loaded onto the host computer, the full set of tests 
was processed by the Ada implementation. 


Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See Appendix B for a complete listing of the 
processing options for this implementation. It also indicates the default 
options. 

Tests were compiled using the command 
ada -0 2 <file name> 

Tests were linked using the command 
aid <main unit> 

The -L qualifier was added to the compiler call for class B, expanded and 
modified tests. The -m <main unit> qualifier was added to the compiler call 
for single non class B tests. 

Test output, compiler and linker listings, and job logs were captured on tape 
cartridge and archived at the AVF. The listings examined on-site by the 
validation team were also archived. 


10 



APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing cho ACVC. 
The meaning and purpose of these parameters are explained in (UG89). The 
following macro parameters are defined in terms of the value V of 
$MAX_IN_LEN which is the maximum input line length permitted for the tested 
implementation. For those parameters, Ada string expressions are given 
rather chan the macro values themselves. 


Macro Pararu it 

Macro Value 

SBIGJCDl 

(1..V-1 -> 'A', 

V -> '1') 

SBIG_ID2 

(1..V-1 -> 'A', 

V «> '2') 

$BIG_ID3 

(1..V/2 -> 'A') 
(1..V-1-V/2 

£ '3' £ 

-> 'A') 

$BIG_ID4 

(1..V/2 «> 'A') 
(1..V-l-V/2 

£ '4' £ 

-> 'A') 

$BIG_INT_LIT 

(1..V-3 -> '0') 

£ "298" 

$BIG_REAL_LIT 

{1..V-5 -> '0') 

£ "690.0" 

$BIG_STRING1 

£ {1..V/2 «> 

'A') £ '"' 

$BIG_STRING2 

'"' £ (1..V-l-V/2 -> 'A') £ 

SBLANKS 

(1..V-20 -> ' ') 



SMAX_LEN__INTJ3ASED_LITERAL 

"2:" t (1..V-5 -> 'O') £ "11:" 

$max_len_real_based_literal 

"16:" £ (1..V-7 -> '0') £ "F.E:" 
SMAX_STRING_LITERAL '"' £ (1..V-2 -> 'A') £ '"' 










The following table contains the values for the remaining macro parameters. 


Macro Parameter Macro Value 

$MAX_XN__LEN 200 

$ACC_SXZE 32 

SALIGNMENT 4 

SCOUNT_LAST 2_14 7_4 83^646 

$D£FAULT_MEM_SIZE 2147483647 

$D£FAULT_STOR_UNIT 8 

5DEFAULT_SYS__NAME TELEGEN2 

$DELTA_DOC 2I1.0IE-31 

$ENTRY_ADDRSSS ENT.ADDRESS 

$ENTRY_ADDRESS1 ENT_ADDRESS1 

$ENTRY_ADDR£SS2 £NT_ADDRESS2 

$FIELD_LAST 1000 

SFILE_TERMINATOR * 1 

$FIXED_NAME NO_SUCHjTYPE 

SFLOATJiAME NO_SUCH_TYPE 

$FORM_STRING 

$FORM__STRING2 "CANNOT_RESTRICT_FILE_CAPACITY” 

$GREATER_THAN_DURATION 

100J)00.0 

5GREATER_THAN_DURATION_BASE_LAST 

131_073.0 

$GREATERJXHAN_FLOAT_BASE_LAST 

1.80141E+38 

$GREATER_THAN_FLOAT_SAFE_LARGE 

1.80141E+38 

S G RE AT E R_T H AN_S H O RT_F LOAT_S AF E_LARG E 

0.0 






vitjUin * i 


SI LLEGAL_EXT£RNAL_FILS_NAME 1 

BADCHAR**/* 

C'ILLEGAL_EXT£RNAL_FILE__NAME2 

NONAME/DIRECTORY 

$INA?PROPRIATE_LINE_LENGTH 

-1 

$INAPPROPRIATE PAGE LENGTH 



-1 


$INCLUDE_PRAGMA1 

PRAGMA INCLUDE 

{"A28006D1.TST") 

SXNCLUD£_PRAGMA2 

PRAGMA INCLUDE 

( H B28006F1.TST M ) 

$INT£GER_FIR$T 

-32768 


$INTEGER_LAST 

32767 


$INTEGER_LAST_P LUS_1 

32768 


SINTERFACE_LANGUAGS 

C 


S LES S_THAN_DURATION 

-lOOJJOO.O 


$LESS_THANJ>URATION__ 

BASE_FIRST 



-131_073,0 


SLINEJfERMINATOR 

ASCII.LF 


SLOW_PRIORITY 

0 


SMACHINE_CODE_STATEMENT 



MCI'(OP~>NOP): 


$MACHINE_CODE_TYPE 

Opcodes 


SMANTISSA_DOC 

31 


SMAXJJIGITS 

IS 


5MAX_INT 

2147483647 


$MAX_INTJ?LUS_1 

2147483648 


SMINJCNT 

-2147483648 



SNAME NO SUCH TYPE AVAILABLE 


SNAME LIST 


TELEGEN2 






SNAM£_5PSC2FXCATX*3Nl 

SNAMSJ5PSCXFXCATXQN2 

SNAMS_SPECXFXCA7X0N3 

SNEG_JASED_I!iT 

SNEWJM£M_5X2S 

SNEWJSTORJWXT 

SHEK_.SYSJJA.ME 

SPAGSjSRMXNATOR 

SREC0RDJ3EFXNITXQN 

$ RECORD JJAME 

STASK SX2E 

> j* 

$TASK_ST0RAGE__SX2£ 

STICK 

5VARIASLE__ADDR£SS 
$VARXABLE_ADDR£SS1 
SVARXABLE_ADDRESS2 
SYOUR PRAGMA 


/uacSwayvacd/ginc/rh4 .91_ti.lJ.£_val/cete^ "AZlZZh 
/u3c6wayward/ginc/rh4,01__IlXjL2,_val/ceb/:<2X20B 
/uacowayuard/ginc/rh-i ,01_iU_12_v-\X/cec/:<31l5A 
16IFFFFFFFE* 

2147*483647 


TELEGEH2 


ASCIX.FF 

RECORD HULL.* END RECORD; 

NOJUCH_MACHINE_CODE_7Y?E 

32 

2048 

0.02 

VAR_ADDR£SS 

VAR_ADDR£SS1 

VAR_ADDRESS2 

COMMENT 

EXPORT 

IMAGES 

XNTERFACEJNFORMATXON 

interrupt"" 

LINKNAME 

NO_SUPPR£SS 

PRESERVEJLAYOUT 

SUPPRESS__ALL 

TASK_INFORMATION 

TASK TRANSFORMATION 






APPENDIX D 


COMPILATION SYSTEM OPTIONS 


Tho. compiler options of this Ada implementation, as described in thia 
Appendix, are provided by the customer. Unless specifically noted otherwise, 
references in this appendix are to compiler documentation and not to this 
report. 


LINKER OPTIONS 

Tho linker options of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, references 
in this appendix are to linker documentation and not to this report. 






2 

Compilation Tools 


This chapter discusses the commands to invoke the Te!eGen2 components that are associated 
with the process of compilation. The components are the compiler (invoked by the ada 
command; see Section 2,1) and the linker (invoked bv the aid command; see Section 2.2). 

Optimization is part of the compilation process as well. In the Te!eGen2 documentation set, 
however, optimization is discussed separately from compilation. In this volume, the 
commands associated with optimization (otta • O ; aopt) are Jiscussed in the “Other Tools" 
chapter. (One exception is the Option Summary table below, where Mpt options are included 
for comparison.) 

Table 2-1 summarizes the options that are used by the compilation tools. Note that several 
options are common to the commands shown. 


OIMAYOO 


2-1 





TeIeGen2 Reference Information for UNIX/68K Hosts 


Tabic 2-1. Compilation Tools Option Summary 


Option 


Command 


ada 

old 

aopt 

-l( to tile 

X 

.X 

X 

-t(cmpiib 

X 

X 

.X 

•V(space_size 

X 

X 

.X 

-vferbose 

X 

.X 

X 

-bfincLonly 


X 


-C(ontext 

X 



-d(ebug 

X 



-E(rror_abort 

' x 

1 

' 

-e(rrors_only 

X 



-F(ild_only_errs 

X 



-G(raph 

X 


.X 

-I(nline 

X 


.X 

-i(nhibit 

X 



•j(oin 

X 



-k(eep 

X 


X 

-K(eep 

X 



-L(ist 

X 



-m(ain 

X 



-n(on_ada_bind 


.X 


-Nfame 



X 

-Ofptimize 

X 


X 

-OfUtpUt 


X 


- R( ecomp_minimizau'on 

.X 



-S^ 

.X 

.X 

X 

-utpdateJib 

.X 



•w(“timeslice" 


.X 


-X{ception_show 


.X 


-\tecution_profile 

X 

.X 

X 

-V 


X 



.Vote 

The functionality of the -S option of ada and the -S option 
ofi/W is somewhat different. Rotor to the text. 




REF-163I)N-V1.1(U/6«S) 



Compilation Tools 


2.1. The Ada Compiler (“ada”) 

The TeleGen2 Ada Compiler is invoked by the ada command. Unless you specify 
otherwise, the front end. middle pass, and code generator are executed each time 
the compiler is invoked 

Before you can compile, you must (1) make sure you have access to TeleGenZ (') 
create a library file, and (3) create a sublforary. These steps were explained in the 
Getting Started section of the Overview. We suggest you review that section, and 
then compile, link, and execute the sample program as indicated before you 
attempt to compile other programs. 

This section focuses specifically on command-level information relating to 
compilation, that is, on invoking the compiler and using the various options to 
control the compilation process. Details on the TeleGen2 compilation process 
and guidelines for using the compiler most effectively are in the Compiler chapter 
of the User Guide volume. (You might want to look at Figure 3-1 in that volume 
right now, to give you insight into the TeleGen2 compilation process and to see 
how the options mentioned in this Command Summary volume relate to the actual 
compilation process.) 

The syntax of the command to invoke the Ada compiler is: 


ada {<“comm()n_optlon ,, >) {<option>} <input_spec> ‘ 


where: 


01MAY9I) 


2-3 






TeleGen2 Reference Information for UNIX/68K Hosts 


< "common-option" > None or more of the following set of options that are common 

to many Te!eGen2 commands: 

-If ibfile or -tfemplib 

-V(space_size 

-vferbose 

j 

These options were discussed in Chapter 1. 

<option > ; None or more of the comoiler-specific options discussed 

_ ; below. _ 

<input_spcc> : The Ada source file(s) to be compiled. It may be: 

I 

• One or more Ada source files, for example: 

; /user/john/example 

Prog_A.text 
ciosrc/calc_mem.ada 
calcio.ada myprog.nda 
*.ada 


• A file containing names of tiles to be com¬ 
piled. Such a tile must have the extension 
’\ilP\ You can find details for using input-list 
files in the User Guide portion of your 
TeleGerC documentation set. 

• A combination of the above. 


Please note that the compiler defaults are set for your convenience. In most cases 
you will not need to use additional options; a simple "ada < input-spec>" is 
sufficient. However, options are included to provide added flexibility. You can, 
for example, have the compiler quickly check the source for syntax and semantic 
errors but not produce object code (-efrrcrs-onlv) or you can compile, bind, and 
link an main program with a single compiler invocation t-mtain). Other options 
are provided for other purposes. 

The options available with the ada command, and the relationships among (hem. 
are illustrated in the following figure. Remember that each of the options listed is 
identified by a dash followed by a single letter (e.g.. “-e'T The parenthesis and 
the characters following the option are for descriptive purposes oniv; they are not 
part of the option. 




REF-Ift3tlN.VT.UU/6S) 













Compilation Tools 


ada 

-Uibfile <libnnme> -tlemplib <sublib>{....} 

-V(space-si Z&26QQ 
-v(erbose 

•e(rrors_only compile :o'o kkc: 

-d(ehug 

-itnhibk <kev>t 
-j(oin 
-kceep 
-Kfeep 

-Otpumize <kev>f 
*R{ ecomp_minimintion 
-Stourceussm <kev>t 
-u(pdate_lib <kev>f 
-x(ecuiion_profile 

•Cfontext 1 
-E(rror_nborc W 

- L( 1st - F( ile_only_errs 

-m(ain <unit> 

<input_spric> 


t (!) <key> ior-c>' Kienottopi, (2) «rl;cy> ior-« iors; visihc Jcuuii O) kc\ !or i .1 orccrum combinations 
*!) Inc ij) <Vcy> for •5 t or n: n is the default. 


(HMAY'JO 


2-5 




TeIeGen2 Reference Information for UNIX/68K Hosts 


The options available with the ada command are summarized in Table 2-2. The 
default situation (that is, what happens if the option is not used) is explained in the 
middle column. Each option is described in the paragraphs that follow the table. 


Table 2*2. Summary of Compiler Options 


Option 

Default 

Discussed 

In Section 

Common options: 

-l(ibfile <libname> 

Use liblst-nib as the library file. 

l.-U 

-tfemplib <sublib...> 

! None 

1.4.1 

j -V(space_size <value> 

J Set size to 2000 Kbytes. 

1.4.2 

-v(erbose 

Do not output progress messages. 

1.4.3 

-d(ebug 

' Do not include debug information in 

2.1.1 

-E(rror_abort <value> 

object code. (•</ sets -k( eep.) 

Abort compilation after 999 errors. 

2.1.2 

-e(rrors_only 

Run middle pass and code generator. 

2.1.3 

-i(nhibit <key>f 

not just front end. 

Do not suppress run-time checks, source 

11.4 

-j(oin 

line references, or suboroernm name 

a, • 

information in object. 

Do not join the errors with the 

2.1.5 

-k(eep 

1 source file. 

Discard intermediate representations of 

2-1.6 

-K(eep 

secondary units. 

* 

Discard the source file and do not 

2.1.7 

-m(ain <unit> 

! store it in the library. 

; Do not produce executable code 

2.1.S 

-0(ptimize <kev>f 

(binder/linker not executed). 

Do not optimize code. 

11.9 

-R(ecomp_minimization 

Recompile completely: dependent units 

2.1.10 

-utpdateJib <kev>f 

may become obsolete. 

Do not update library when errors are 

11.11 

-x(ecution_profiIe 

found (multi-unit compilations). 

Do not generate execuiion-protile code. 

11.12 


* 1 1) <kcv> lorreier 10 aopt. i2) <Uv> loriorv < ■'iltc JcijiiIi i5i lor i a»>r .cnum vombinations 

oi Inc. 


2-6 


REF-1630N-VI. I (U / 68) 















Compilation Tools 


Table 2-2. Summary of Compiler Options (Continued) 


Option 

Default 

Discussed . 
In Section 

Listing options: 

-C(ontexi <value> 

Include I line of context with error 

' 2.1.13.1 

-L(ist 

message. 

Do not generate a source-error listing. 

1 2.1.13.2 

-F(ile_only_errs 

Do not generate an errors-onlv listing. 

1 2.1.13.3 1 

-S(ource_cism <key>f 

only. 

Do not generate assembly listing. 

1 

! 

! 2.1.13.4 { 


2.1.1. -d(ebug - Generate Debugger Information 

The code generator must generate special Information for any unit that Is to be 
used with the Te!eGen2 symbolic debugger. The generation of this information is 
enabled by use of the -d option. The use of ■d automatically sets the -k(eep 
option. This to make sure that the High Form, Low Form, and debugger 
information for secondary units are not deleted. 

To see if a unit has been compiled with the -d(ebug option, use the als command 
with the -X(tended option. Debugger information exists for the unit if the 
‘*dbg_info” attribute appears in the listing for that unit. The default situation is 
that no debugger information is produced 

Performance note. While the compilation time overhead generated by the use of 
-dlebug is minimal, retaining this optional information in the Ada library increases 
che space overhead. 

2.1.2. -E(rror_abort - Set an Error Count for Aborting 
Comoilation 

4 

The compiler maintains separate counts of all syntactic errors, semantic errors, 
and warning messages detected by the front end during a compilation. 

A large number of errors generally indicates that errors in statements appearing 
earlier in the unit have “cascaded" through the rest *'f the code. A classic example 
is an error occurring in a statement that declares a type. This causes subsequent 
declarations that use the type to be in error, which further causes all statements 
using the declared objects to be in error. In such a situation, only the first error 
message is useful. Aborting the compilation at an early stage is therefore often to 
your advantage: the -£ option allows you to do it. 


f 1 1 ) v kev> lor J: < or n: n is the Jclauli. 


0IMAY90 


2-7 








Te!eGen2 Reference Information for UNIX/68K Hosts 


The format of the option Is: 

-E <value> 

where <value > Is the number of errors or warnings allowed The default value Is 
999. The minimum value is 1. Caution: If you do not use the -£ option, it Is 
p^sible to have 999 warning messages plus 999 syntax errors plus 999 semantic 
errors without aborting compilation, since each type of error is counted 
separately. 

2.1.3, -e(rrors_only - Check Source But Don’t Generate Code 

This option instructs the compiler to perform syntactic and semantic analysis of 
the source program without generating Low Form and object code. That is, it 
calls the front end only, not the middle pass and code generator. (This means, of 
course, that onlv front end errors are detected and that onlv the Hich Form 
intermediates are generated.) This option is typically used during early code 
development where execution is not required and speed of compilation is 
important. 

Note: Although High Form intermediates are generated with the *e option, these 
intermediates are deleted at the end of compilation. This means that the library is 
not updated. 

The -e option cannot be used with -SfourceLJsm. since the latter requires the 
generation of object code. If -c is not used (the default situation), the source is 
compiled to object code (if no errors are found). The -e option is also 
incompatible with -k(eep, -d(ebug, -Ofptimize. and other options that require 
processing beyond the front end phase of compilation. 

2.1.4. -i(nhibit - Suppress Checks and Source Information 

The -ifnhibit option allows you to suppress, within the generated object code, 
certain run-time checks, source line references, and subprogram name 
information. 

The Ada language requires a wide variety of nut-tune checks to ensure the validity 
of operations. For example, arithmetic overflow checks are required on all 
numeric operations, and range checks are required on all assignment statements 
that could result in an illegal value being assigned to a variable. While these 
checks are vital during development and are an important asset of the language, 
they introduce a substantial overhead. This overhead may be prohibitive in time- 
critical applications. 

Although the Ada language provides pragma Suppress to selectively suppress 
classes of checks, using the pragma requires you to modify the Ada source. The 
-ifnhibit option provides an alternative mechanism. 


REF-1630N-VI.KU/68) 






Compilation Tools 


The compiler by default stores source line and subprogram name information in 
the object code. This information is used to display a source level traceback when 
an unhandled exception propagates to the outer level of a program; it is 
particularly valuable during development, since it provides a direct indication of 
the source line at which the exception occurs and the subprogram calling chain 
that led to the line generating the exception. 

T t inclusion of source line information in the object code, however, introduces 
an overhead of 6 bytes for each line of source that causes code to be generated 
Thus, a lOCO-line package may have up to 6000 bytes of source line information. 
For one compilation unit, the extra overhead (in bytes) for subprogram name 
information is the total length of ail subprogram names in the unit (including 
middle pass-generated subprograms), plus the length of the compilation unit 
name. For space-critical applications, this extra space may be unacceptable; but 
it can be suppressed with the -i(nhibit option. When source line information is 
suppressed the traceback indicates the offset of the object code at which the 
exception occurs instead of the source line number. When subprogram name 
information is suppressed, the traceback indicates the offsets of the subprogram 
calls in the calling chain instead of the subprogram names. (For more information 
on the traceback function, refer to the Programming Guide chapter in your 
Reference Information volume.) 

The format of the -i(nhibit option is: 

-i <suboption> {<suboption>) 

where <suboption> is one or more of the single-letter suboptions listed below. 
Combinations of suboptions are possible. When more than one suboption is used, 
the suboptions appear together with no separators. For example, “-i Inc”. 


. l(line_info] 

Suppress source line information in object code. 1 

n[nme_info] 

Suppress subprogram name information in object, 
code. 

c[hecks] 

Suppress run-time checks - elaboration, overflow, 
storage access, discriminant, division, index, length, i 
and range checks. 

m 

Suppress source line information, subprogram name 
information, and run-time checks. In other words, a 
l = inhibit all) is equivalent to Inc. 


0IMAY90 


2-9 



TeleGsn2 Reference Information for UNIX/68K Hosts 


As an example of use, the command... 
ada -v -i 1c my_filc-ada 

...inhibits the generation of source line information and run-time checks in the 
object code of the units myJiktuia. 

2.1.5. -j(oin - Join Errors with Source Code 

This option joins the any errors that are generated with the source file. The 
u tubing file is written back to the source file. The errors appear in the file as 
Ada comments. This option allows you to comment the source file with the errors 
that are generated at compile time. These comments can help facilitate debugging 
and commenting your code. 

Unlike the -L and -F options, the -j option does not produce a listing. 

2.1.6. -k(eep - Retain Intermediate Forms 

As a default, the compiler deletes the High Form and Low Form intermediate 
representations of ail compiled secondary units from the working sublibrary. 
Deletion of these intermediate forms can significandy decrease the size of 
sublibraries - typically 50^ to S0S> for multi-unit programs. On the other hand, 
some of the information within the intermediate forms may be required later. For 
example. High Form is required if the unit is to be referenced by the Ada Cross- 
Referencer (axr). In addition, information required by the debugger and the 
Global Optimizer must be saved if these utilities are used. For these, reasons, the 
•k option is provided with the ada command. The -k option: 

• Must be used if the compiled unit is to be optimized later with aopt ; 
otherwise, aopt issues an error message and the optimizer aborts. 

• Should be used if the unit is to be cross-referenced later: otherwise, an 
error message is issued when the Ada Cross-Referencer attempts to 
cross-reference that unit. 

• Need not be used with -dfebug. since -k is set automatically whenever <i 
is used. 

To verily that a unit has been compiled with the -k(eep option (has not been 
"squeezed"), use the als command with the -X( tended option. A listing will be 
generated that shows whether the intermediate forms for the unit exist. A unit has 
been compiled with -k(eep if the attributes highJ'orm and lowj'orm appear in the 
listing for that unit. 

2.1.7. -K(eep - Keep Source File in Library 

This option tells the compiler to take the source tile and store it in the Ada 

librarv. When vcu later need to retrieve vuur source file, vou mav use the aco 

• * • • » 


Mil 


REF-1630N-Vl.l(U/68) 





Compilation Tools 


command. 

2.1.8. -m(ain - Compile a Main Program 

Tills option tells the compiler that the unit specified with the option is to be used 
as a main program. After all files named in the input specification have been 
compiled the compiler invokes the prelinker (binder) and the native linker by 
calling aid to bind and link the program with its extended family. An executable 
file named <unit> is left in the current directory. The (inker may also be invoked 
directly by the user with the aid command. 

The format of the option is: 

-m <unit> 

where <unit> is the name of the main unit for the program. If the main unit has 
already been compiled, it does not have to be in the input file. However, the body 
of the main unit, if previously compiled, must be present in the current working 
sublibrary. 

Note: Options specific to the linker (invoked via aid) may be specified on the 
ada command line when the -m option is used. With •/«, the compiler will call aid 
when compilation is complete, passing to it cW-specific options specified with the 
ada command. For example... 

ada -m welcome -o new sampleuida 

...instructs the compiler to compile the Ada source file sample.ada. which 
contains the main program unit Welcome. After the file has been compiled, the 
compiler calls the linker, passing to it the -o option with its respective arguments. 
The linker produces an executable version of the unit, placing it in file new as 
requested by the *o option. 

2.1.9. -0(ptimize - Optimize Object Code 

This option causes the compiler to invoke the global optimizer tc optimize the 
Low Form generated by the middle pass for the unit being compiled. The code 
generator takes the optimized Low Form as input and produces more efficient 
object code. The format of this option is: 

-0 <key> 

where <kev> is at least one of the optimizer suboption keys discussed in the 
Global Optimizer chapter. Please refer to that chapter for all information 
regarding the use of the optimizer. The chapter discusses using the optimizer as a 
standalone tool for collections of compiled but unoptimized units and using the 
-Ofptimize option with the<«/« command The latter topic includes a definition of 
the -0(ptimize suboption key values plus a presentation of two other ada options 
t-G(rnph and -[(nlineJist. not shown on the ada chart) that may be used in 
conjunction with the -Optimize option. .Vow: We strongly recommend that you 
do not attempt to use the optimizer until the code being compiled has been fully 


0IMAY90 


2-11 


TeleGen2 Reference Information for UNIX/68K Hosts 


debugged and tested. 

2.1.10. -R(ecomp_minimizaticn • Minimizing Recompilation 

This option has the Mowing function eliminates the need for recompilation of 
dependent units when an "insignificant” change is made to another unit. An 
“insignificant” change has been defined as one of the following: 

1. Adding/Deleimg/Moditying a comment. 

2. Changing case of identifiers, including reserved words. NOTE: 
Changing the case of string or character literals including operators is 
NOT allowed. 

3. Changing case of letters within numeric literals, equivalent numeric 
literals. 

4. Reformatting changes (white space). 

A restriction of the current imolementation is that units deoendem uoon a unit 

* • « 

with an insignificant change that contains inline or instantiation dependencies 
must always be recompiled. 

A dependency of the current implementation is that the source of the compiled 
unit be stored in the library. This is necessary in order to determine the level of 
change to the unit being recompiled. 

2.1.11. -u(pdate_lib - Update the Working Sublibrary 

The -u(pdate_iib option tells the compiler when to update the library. It is most 
useful for compiling multiple source files. The format of the option is: 

•u <key> 

where <kev> is either “s” (source) or “i” (invocation). 

i *T tells the compiler to update the working sublibrary after all files 
submitted in that invocation of ado. have compiled successfully. If an 
error is encountered the library is not updated even for source files 
that compile successfully. In addition, till remaining source files will 
be compiled for syntactic and semantic errors only. Implications: (1) 
If an error exists in any source file you submit, the library will not be 
updated, even if all other files are error free. (2) Compilation is 
faster, since the library' is updated only once, at the end of 
compilation. 


2-12 


REF-163()N-Vl.l(U/68) 





Compilation Tools 


s (This is ihe default; it is equivalent to not using the -u(pdateJib 

option at all.) "s" tells the compiler to update the library after all 

units within a single source file compile successfully. If the compiler 

encounters an error in any unit within a source file, all changes to the 

working sublibrary for the erroneous unit and for ail other units in the 

file are discarded. However, library updates for units in previous or 

remaining source files are unaffected. Implications: (1) You can 

submit files containing possible errors and still have units in other 

files compile successfully into the library. (2) Compilation is slightly 

slower, since the librarv is undated once for each file. 

* • 


Therefore: 

Use *‘u s" (or no -u(pdate option) when: 

You’re not sure all units will comoile successfully. 

• • 

Compilation speed is not especially important. 


Use “u i” when: 

You are reasonably certain your files will compile successfully. 

Fast compilation is important. 

2.1.12. -x(eeution_profile - Generate Profile Information 

The -.x(ecution_profile option uses the code generation phase of compilation to 
place special information in the generated code that can be used to obtain a 
“profile" of a program’s execution. This information is generated by a facility 
known as “the profiler." Refer to your User Guide volume for information on 
how to use the profiler to obtain execution timing and subprogram call 
information for a program. 

Important : If any code in a program has been compiled with the 

-.x(ecution_profile option, that option must also be used with aid when the 
program is bound and linked. Otherwise, linking aborts with an error such as 
"Undefined RECORDSSCURRENT". 

2.1.13. Listing Options 

The listing options specify the content and format of listings generated by the 
compiler. Assembly code listings of the generated code can also be generated. 

2.1.13.1. -C(ontext - Include Source Lines Around the Error 

When an error message is sent to srderr. it is helpful to include the lines of the 
source program that surround the line containing the error. These lines provide a 
context for the error in the source program and help to clarify the nature of the 
error. The -C option controls the number of source lines that surround the the 
error. 


01MAY90 


2-13 




TeleGen2 Reference Information for UNIX/68K Hosts 


The format of the option is; 
-C <vaiue> 


where <vaiue> is the number of source context lines output for each error. The 
default for <value> is 1. This parameter specifies the total number of lines 
output for each error (including the source line that contains the error). The first 
context line is the one immediately before the line in error; other context lines are 
distributed before and after the line in error. Let's say that irialprog.ada, which 
consists of the following text... 


package ? is 

type Tl is range I..10; 

type T2 is digits 1; 

type Arr is array (1..2) of integer; 

type T3 is new Arr; -- OK. 


package Inner is 
eype Ini Is new Tl; 
cype In2 is new T2; 
type In3 is new T3; 
cype Inarr is new Arr; 


-- ERROR: Tl DERIVED. 
-- ERROR: T2 DERIVED, 
-- ERROR: T3 DERIVED. 
-- OK. 


end Inner; 


end P; 


...were compiled as follows: 

ada -e -C2 trblprogaida 

(The -e option here is used for error checking and -Qontext is set to 2 to display 
two lines of source.) The output produced would look like this; 


2-14 


REF-l<i30N-Vl.I(U/68) 










Compilation Tools 


7: package Inner is 

8: cype Ini is nev Tl; — ERROR: T1 DERIVED. 

»> Illegal parenc cype for derivation <3.4;15,7,4.1:4> 

8: cype Ini is nev Tl; -- ERROR: Tl DERIVED. 

9* cype In2 is nev T2; -- ERROR: T2 DERIVED. 

>» Illegal parenc cype for derivation <3.4;15,7.4.1:4> 

9: cype In2 is nev T2; -- ERROR: T2 DERIVED. 

10: cype In3 is nev T3; -- ERROR: T3 DERIVED. 

>» Illegal parenc cype for derivation <3,4:15,7.4.1:4> 


2.1.13.2. -L(ist - Generate a Source Listing 

This option instructs the compiler to output a listing at the source being compiled, 
interspersed with error information (if any). The listing is output to 
<file_spec>.l. where <ftle_spec> is the name of the source file (minus the 
extension). If <file.spec>.l already exists, it is overwritten. 

If input to the ada command is an input-list file (<file_spee>,ilf), a separate 
listing file is generated for each source file listed in the input file. Each resulting 
listing file has the same name as the parent file, except that the extension *M" is 
appended. Errors are interspersed with the listing, ff you do not use -L (the 
default situation), errors are sent to sidotu only; no listing is produced. -L is 
incompatible with -F. 

2.1.13.3. -F(ile_only_errs - Put Only Errors in Listing File 

This option is used to produce a listing containing only the errors generated 
during compilation: source is not included. The output is sent to <fiJe_spec>.l. -F 
is incompatible with -L 

2.1.13.4. -S(ource_asm - Generate a Source/Assembly Listing 

This option instructs the compiler to generate an assembly listing and send it to a 
file named <unit>.s. where <unit> is the name of the unit in the user-supplied 
source file. (The file extension mav be different on vour svstem.) The listing 
consists of assembly code intermixed with source code as comments. If input to 
thettfir/ command is an input-list file (<file_spec>.ilf). a separate assembly listing 
file is generated for each unit contained in each source file listed in the input file. 
If -S is not used (the default situation), an assembly listing is not generated. 


01MAY90 


2-15 





TeieGen2 Reference Information for UNIX/68K Hosts 


The format of this option is: 

-S <key> , 

where <key> is either V’ (extended) or "n” (normal). The argument to the *S 

option, <key>, is mandatory. 

e "e' 1 tells the compiler to generate a paginated, extended assembly 
listing which wiU include code offsets and object code. 

n “n” tells the compiler to generate a normal assembly listing. This 
listing can later be used as input to the Sun assembler. 


2*16 


REF-1630N-Vl.l(U/68) 






(~*\ *•*!*>+* 


Compilation Tools 


2.21, The Ada Linker (“aid”) 

The Te!eGen2 Ada Compiler produces object code from Ada source code. The 
TeleGen2 Ada Linker takes the object (of a main program) that is produced by 
the compiler and produces a UNIX executable module. The Te!eGen2 Ada 
Linker will be called “the linker” in the remainder of this manual. 

To produce executable code, the linker (l) generates elaboration code and a link 
script (this is called “binding*' or “prelinking") then (2) calls the UNIX link editor 
(Id) to complete the linking process. 

The linker is invoked with the old command; it can also be invoked with the 
-m(ain option of the ada command. In the latter case the compiler passes 
appropriate options to the linker, to direct its operation. 

In the simplest case, the aid command takes one argument - the name of the main 
unit of the Ada program structure that is to be linked - and produces one output 
file - the executable file produced by the linking process. The executable file is 
placed in the directory where aid was executed, under the name of the main unit 
used as the argument to aid. (For System V versions of UNIX: if the name is 
longer than 14 characters, it is truncated.) For example, the command 

aid main 

links the object modules of all the units in the extended family of the unit Main. 
The name of the resulting executable file will simply be '‘main”. Important: 
When using the aid command, the body of the main unit to be prelinked must be 
in the working sublibrary. 

The general syntax of the aid command is: 


aid {<“common_joption , ’>} {<option>} <unit> 


where: 


01MAY90 


2-17 






TejeGen2 Reference Information for UN1X/68K Hosts 


r 


<"common-.opiion’’ > 


J 

t 

I 

i 


j <option* 


<umt> 


1 None or more of the following set of options that are eom- 
’ mon to many TdeGen2 commands: 

j *l(ibfi!e or -tfempifo 

| *V($paee_size 

•vferbose 


i 


These options were discussed in Chapter 


I None or more of the options discussed in the following 
I sections. 



The options available with the aid command and the relationships among them 
arc illustrated below. 

]&[ 

-l(ibfile <libname> -tfemplib <sublib> 

-Vfspace^size 2000 
-vjerbose 
*b(indLcniy 
-n(on_ada_bind 
•o(utput <file_spec> 

-P(ass-options ’string:' 

*p(nss_objects ’string' 

-Sr'asmJisting’ -e 1 
-wftimeslice” 

-x(ecution_profile 
-X(ception_show 
-Y 8192 >M«*ionsi 
<unit> 


2-18 


REF-I630N-V1.KU/68) 









Compilation Tools 


2.2.1. -b(ind_only - Produce Elaboration Code Only 

To provide you with more control over the linking process, the -b option causes 
the linker to abort after it has created the elaboration code and the linking order, 
but before invoking the UNIX link editor. This option allows you to edit the link 
order for special applications and then invoke the link editor directly. The link 
order is contained in an executable script that invokes the link editor with the 
appropriate options and arguments. Tne name of the script produced is 
<unit>.Ink. which is placed in your working directory. To complete the link 
process, enter" <unit>,lnk". 

The name of the file containing the elaboration code is <unit>.obm, which is 
placed in the object directory of the working sublibrary. 

For System V versions of UNIX, the file names generated as a result of linking 
are created by appending the 3-!etter extension to the unit name and truncating 
the result to 14 characters. 

2.2.2. -n(on_ada_bind - Non-Ada Main Binding 

The -n option causes the binder to produce elaboration code and a link script 
appropriate for making non-Ada code a main program. Non-Ada object modules 
can simply be prepended to the Ada object modules and the script can then be 
executed to produce an image executable under a non-Ada environment. 

The format of the option is: 

-n 

This is similar to the -b switch which causes the binder to produce elaboration 
code and a link script appropriate for making Ada code a main program. 

2.2.3. -o(utput - Name the Output File 

This option allows you to specify the name of the output file produced by the 
linker. For example, the command... 

aid -o yorkshire main 

...causes the linker to put the executable module in the fil z Yorkshire. 

2.2.4. -P(ass_Opiions - Pass Options to the Linker 

This option allows you to pass a string of options directly to the UNIX link editor. 
For example, the command 

aid -P *-t -r’ main 

adds the string “-t -r" to the options of the link editor when it is invoked. The 
options must be quoted (double or single quotes). 


0IMAY90 


2-19 




Te(eGen2 Reference Information for UNIX/68K Hosts 


2.2.5. -p(ass_objects - Pass Arguments to the Linker 

This option allows you to pass a string of arguments directly to the UNIX link 
editor. For example, the command 

aid -p ’costnc.o /usr/lib/Ubmj’ main 

causes the link editor to link the object file c osine.o (which it expects to find in the 
current working directory), and to search the library /usr/lib/libma for 
unresolved symbol references. (The location of the libma horary may be different 
on your system.) Remember that the link editor searches a horary exaedy once at 
the point it is encountered in the argument list, so references to routines in 
libraries must occur before the library is searched. That is. files that include 
references to library routines must appear before the corresponding libraries in 
the argument list. Objects and archives added with the •p option will appear in the 
linking order after Ada object modules and run-time support libraries, but before 
the standard C library (/lib/libc.a). This horary is always the last element of the 
linking order. 

You can also use the •/? option to specify the link editor’s •/ option, which causes 
the link editor to search libraries whose names have the form ‘Vlib/lib/ifime.a" or 
"fust, lib/lifc/WM<.*.a’\ For example, the command 

aid -p ’-Lxyz' 

causes the link editor to search the directories / lib and ,tisr/Hb (in that order) for 
file libxyza. 

2.2.6. -S(“asmJisting" - Produce an Assembly Listing 

The -S option is used to output an assembly listing from the elaboration process. 
The output is put in a file, <file>.obm.s. where <file> is the name of the main 
unit being linked. (The file extension may be different on your system.) 

The format of this option is: 

-S <key> 

where <kev> is either "e” (extended) or “n” (normal). The argument to the -S 
option. <key>, is mandatory. 

e “e" tells the compiler to generate a paginated extended assembly 
listing which will include code offsets and object code. 

n “n” tells the compiler to generate a normal assembly listing. This 
listing can later be used as input to the Sun assembler. 

2.2.7. -s(oftware_float - Use Software Floating-Point Support 

This option may not he available on your TeleCen2 system. Please consult the 
Overview portion of this volume to see if it is provided. The Ada linker currendy 
selects hardware floating-point support by default. This default situation is 
provided for users of systems with an arithmetic coprocessor. If you do not have 


2-20 


REF- 1630N-VI.1 (U/68) 








Compilation Tools 


hardware floating point support or if you wish to generate code compatible with 
such machines, use the -s option. In addition: if you use the -s option, the library 
file you use for compiling and linking must contain the name of the software 
floating point run-lime sublibrary, .sub. Refer to the Library Manager chapter in 
your User Guide volume for more information on the run-time sublibrary. 

2.2.8. -x(ecution_profile - Bind and Link for Profiling 

This option is used for units that have been compiled with the -,t option. Use of -.r 
with ada causes the code generator to include, in the object, special code that will 
later be used to provide a profile of the program's execution. 

If *.t is used with ada, it must be used with aid as well. The *.t option of aid 
instructs the linker to link in the profiling run-time support routines and generate 
a subprogram dictionary, profUe.dk , for the program. The dictionary is a text file 
containing the names and addresses of all subprograms in the program. The 
dictionary' can be used to produce a listing showing how the program executes. 

Refer to the Ada Profiler chapter in your User Guide volume for a full discussion 
of the profiler. 

2.2.9. Tasking Options 

The following aid options are binding options used for task execution. They are 
therefore useful only for linking programs that contain tasking code. 

2.2.9.1. -w( ,l timesllce” - Umit Task Execution Time 

The .w option allows you to define the maximum time a task may execute before it 
is rescheduled. The format of the option is: 

-w <value> 

where <value> is the maximum time the task is to execute, in milliseconds, 
before a task switch occurs between it and a task having the same or higher 
priority. The default value is 0 (no timeslice). If you choose a value greater than 
0. it must be at least as great as the clock interval time 

Since rescheduling of tasks is incompatible w. \ jm.,yupt-scheduling, -tv is 
incompatible with -Dfelay-NonPreempt isee above«. 

2.2.9.2. -X(ception_show - Report Unhandled Exceptions 

By default, unhandled exceptions that occur in tasks are not reported: instead, the 
task terminates silently. The *.Y option allows you to specify that such exceptions 
are to be reported. The output is similar to that displayed when an unhandled 
exception occurs in a main program. 


01MAY90 


2-21 




TeieGen2 Reference Information for UNIX/68K Hosts 


2,2.9.3. -Y - Alter Stack Size 

In the absence of a representation specification for task storage_size, the run time 
will allocate $192 bytes of storage for each executing task. You can change the 
amount of space allocated for tasking by using the -Y option. 

-Y specifies the size of the basic task stack. The format of the option is: 

-Y < value > 

where <value> is the size of the task stack in 32-bit (long_integer) bytes. The 
default is S192. 

A representation specification for task storage size overrides a value supplied with 
this option. 


2*22 


REF-1630N-V1.KU/68) 








APPENDIX C 


APPENDIX P Of THE Ada STANDARD 


The only allowed implementation dependencies correspond to implementation- 
dependent pragmas, co cercain machine-dependent conventions as mentioned in 
Chapter 13 of che Ada Standard, and to certain allowed restrictions on 
representation clauses. The implementation-dependent characteristics of this 
Ada implementation, as described in this Appendix, are provided by the 
customer. Unless specifically noted otherwise, references in this Appendix 
are to compiler documentation and not to this report. Implementation-specifi 
portions of the package STANDARD which are not a part of Appendix F, are 


package STANDARD is 


type INTEGER is range -32762 .. 32767; 

type SKORT — INTEGER is range -128 .. 127; 

type LONGJCNTEGER is range -2147483648 .. 2147483647; 

type FLOAT is digits 6 range -1.70141E+38 .. 1.70141E+38; 

type LONG__FLOAT is digits 15 range -1.79769E+308 .. 1.79769E+308; 

type DURATION is delta 2I1.0IE-14 range -86400.0 .. 86400.0; 


end STANDARD; 







3 

LRM Annotations 


TeleGen2 compiles the full ANSI Ada language as defined by the Reference Manual for the 
Ada Programming Language (LRM) (ANSI/MBL-STD-IS15A). This chapter describes the 
portions of the language that are designated by the LRM as implementation dependent for the 
compiler and run-time environment. 

The information is presented in the order in which it appears in the LRM. In general, howev¬ 
er, only those language features that are not fully implemented by the current release of 
Te!eGert2 or that require clarification are included. The features that are optional or that are 
implementation dependent, on the other hand, are described in detail. Particularly relevant 
are the sections annotating LRM Chapter 13 (Representation Clauses and Implementation- 
Dependent Features) and Appendix F (Implementation-Dependent Characteristics). 

3.1. LRM Chapter 2 - Lexical Elements 

[LRM 2.1] Character Set The host and target character set is the ASCII char¬ 
acter set. 

[LRM 2.2] Lexical Elements, Separators, and Delimiters. The maximum 
number of characters on an Ada source line is 200. 

[LRM 2.8] Pragmas. TeleGen2 implements all language-defined pragmas ex¬ 
cept pragma Optimize. If pragma Optimize is included in Ada source, the pragma 
will have no effect. Optimization is implemented by using pragma Inline and the 
optimizer. Pragma Inline is not supported for library-level subprograms. 

Limited support is available for pragmas Memory-Size. Storage-Unit, and 
System-Name: that is. these pragmas are allowed if the argument is the same as 
the value specified in the System package. 

Pragmas Page and List are supported in the context of source/error listings: refer 
to the Compiler/Linker chapter of the TeleGenZ User Guide for more informa¬ 
tion. 


OIMAY'JO 


3-1 







TeleGen2 Reference Information for UNIX/68K Hosts 


3.2. LRM Chapter 3 - Declarations and Types 

[LRM 3.2.1] Object Declarations. 

TeIeGen2 dees not produce warning messages about the use of uninitialized vari¬ 
ables. The compiler will not reject a program merely because it contains such 
variables. 

[LRM 3.5.1] Enumeration Types. The maximum number of elements in an 
enumeration type is 32767. This maximum can be realized only if generation of 
the image table for the type has been deferred, and there are no references in the 
program that would cause the image table to be generated. Deferral of image 
table generation for an enumeration type, P, is requested by the statement: 

pragma Images (P, Deferred); 

Refer to “Implementation-Defined Pratrmas.‘’ in Section 3.8.1. for more informa- 

r » 

lion on pragma Images. 

[LRM 3.5.4] Integer Types. There are three predefined integer types: 
ShortJnieger. Integer, and LongJnteger. The attrfoutes of these types are shown 
in Table 3-1. Note that using explicit integer type definitions instead of predefined 
integer types should result in more portable code. 

Table 3-1. Attributes of Predefined Types ShortJnteger. Integer, and LongJnteger 


i 

Attribute 


Type 


ShortJnteger 

Integer 

LongJnteger 

’First 

-12S 

-3276S 

-21474S364S 

i 'Last 

127 

32767 

2147433647 

: 'Size 

S 

16 

32 

’Width 

4 

6 

11 


[LRM 3.5.8] Operations of Floating Point Types. There are two predefined 
floating point types: Float and LongJrloat. The attributes of types Float and 
LongJToat are shown in Table 3-2. This floating point facility is based on the 
IEEE standard for 32-bit and 04-bit numbers. Note that using explicit real type 
definitions should lead to more portable code. 

The type Short-Float is not implemented. 


3.; 


REF-1630N-VI.KL76H) 










LRM Annotations 


Table 3-2. Attributes .»f Predefined Types Float and Long-Float 


Attribute 


Type 

Float 

LongJRoat 

'Machine-Overflows 

TRUE 

TRUE 

‘Machine-Rounds 

TRUE 

TRUE 

'Machine-Radix 

2 

n 

'Machine-Mantissa 

24 

53 

'MachineJEmax 

127 

1023 

'MachineJEmin 

-125 

-1021 

'Mantissa 

21 

-"1 : 

! 'Dirits 

6 

15 

'Size 

32 

64 

'Emax 

$4 

204 

'SafeUEmax 

125 

1021 

'Epsilon 

9.53074E-07 

S.SS17SE-16 

'SafeJLarge 

4.25253E-r37 

2.2471164 lS577S9Er307 

Safe-Small 

1.17549E-3S 

2.225073S5S50721E-30S 

'Large 

1.9342SE-r25 

2.571100S70S143SE -r 61 

; 'Small 

2.5S494E-26 

1.99469227433161E-62 i 


3.3. LRM Chapter 4 - Names and Expressions 

[LRM 4.10] Universal Expressions. There is no limit on the accuracy of real 
literal expressions. Real literal expressions are computed using an arbitrary- 
precision arithmetic package. 


3.4. LRM Chapter 9 - Tasks 

[LRM 9.6] Delay Statements, Duration, and Time. This implementation 
uses 32-bic fixed point numbers to represent the type Duration. The attributes of 
the type Duration are shown in Table 3-3. 

Table 3-3. Attributes ol'Type Duration 


Attribute 

Value 

‘Delta 

0.10352E-05 

‘First 

-86400.0 

‘Last 

86400.0 


3-3 


01MAY90 












TeleGen2 Reference Information for UNIX/68K Hosts 


(LRM 9.8] Priorities, Sixty-four levels of priority are available to associate with 
tasks through pragma Priority. The predefined subtype Priority is specified in the 
paekage System as 

subcype Priori”/ is Integer range 0..63; 

Currently the priority assigned to tasks without a pragma Priority specification is 
31; that is: 

(Systcm.PrioritVFirst + System.Priority'LasO / 2 

[LRM 9.11] Shared Variables. The restrictions on shared variables arc only 
those specified in the LRM. 

3.5. LRM Chapter 10 - Program Structure and Compilation Issues 

[LRM 10.1] Compilation Units - Library Units. All main programs are as¬ 
sumed to be parameterless procedures or functions that return an integer result 
type. 

3.6. LRM Chapter 11 - Exceptions 

[LRM 11,1] Exception Declarations. Numeric..Error is raised for integer or 
floating point overflow and for divide-by-zero situations. Floating point underflow 
yields a result of zero without raising an exception. 

Program-Error and Storage-Error are raised by those situations specified in 
LRM Section 11.1. Exception handling is also discussed in the Programming 
Guide chapter. 


3-1 


REF-163UN-V1.KU/68) 











LRM Annotations 


3.7. LRM Chapter 13 - Implementation-Dependent Features 

As shown in Table 3-4, the current release of TeleGen2 supports most LRM 
Chapter 13 facilities. The sections below the table document those LRM Chapter 
13 facilities that are either not implemented or that require explanation. Facilities 
implemented exactly as described in the LRM are not mentioned. 


0IMAY90 


3-5 







Te!eGen2 Reference Information for UNIX/68K Hosts 


Table 3-4. Summary of LRM Chapter 13 Features for TeleCen2 


13.1 Representation Clause Supported, except as indicated below (LRM , 

13.2 - 13.5). Pragma Pack is supported, except 
for dynamically sized components. For details ; 
on the TeleGen2 implementation of pragma j 
Pack, see Section 3.7.1. ; 


j 13.2 Length Clauses 

Supported: 

' 'Size 

'Storage-Size for collections 

'Storage-Size for task activation 

'Small for fixed-point types j 

i 

i 

See Section 3.7.2 for more information. 

: 13.3 Enumeration Rep. Clauses 

1 

I 

i 

! 

Supported, except for ope Boolean or types | 

, derived from Boolean. (Note: users can easily j 
define a non-Boolean enumeration type and 
' assign a representation clause to it.) 

[ 

| 13.4 Record Rep. Clauses 

i 

Supported except for records with dynamically 
sized components. See Section 3.7.4 for a full 
discussion of the TeleGen2 implementation. 

13.5 Address Clauses 

Supported for: objects (including task objects). 
Not supported for: packages, subprograms, or 
task units. 

See Section 3.7.5 for more information. 

13.5.1 Interrupts 

For interrupt entries, the address of a 


TeleGen2-defined interrupt descriptor can be 
given. See "Interrupt Handling"' in the Pro¬ 
gramming Guide chapter for more informa¬ 
tion. 


13.0 Change of Representation Supported, except for types with record 

representation clauses. 

- Continued on the next pui>e — 


3-ft 


REF-163().N-V‘1.1(U/6»S) 















LRM Annotations 


Table 3-4. Summary of LRM Chapter J3 Features forTeieCen2 (Contd) 


Continued from the previous ptt$e 


13.7 Package System Conforms closely to LRM model Refer to 

! , Section 3.7.7 for details on the TeleGen2 im¬ 

plementation. 


13.7.1 System-Dependent Named Refer to the specification of package System 

;_ Numbers _ (Section 3.7.7).’ \ 

I i 

13.7.2 Representation Attributes Implemented as described in LRM except dint ; ■ 

; 'Address for packages is unsupported. 

'Address of a constant yields a null address. 


13.7,3 Representation Attributes of See Table 3-2. 
Real Types 


j 13.S Machine Code Insertions , Fully supported. The Te!eGen2 implementa- ! 
I lion defines an attribute. "Offset, that, along ' 

j with the language-defined attribute 'Address, j 

allows addresses of objects and offsets of data I 
! items to be specified in stack frames. Refer to ; 

"Using Machine Code Insertions" in the Pro- ; 
gramming Guide chapter for a full description 
on the implementation and use of machine ; 
code insertions. ! 


13.9 Interface to Other Languages Pragma Interface is supported for Assembly, 

C. UNIX, and Fortran. Refer to "Interfacing 
to Other Languages" in the Programming 
Guide chapter for a description of the imple¬ 
mentation and use of pragma Interface. 


13.10 Unchecked Programming Supported except as noted below (LRM 

13.10.21. 


13.10.1 Unchecked Storage Deallcca- Supported, 
tion 


13.10.2 Unchecked Type Conversions Supported exiept tor unconstrained record or 

array types. 









TeIeGen2 Reference Information for UNIX/68K Hosts 


3.7.1. Pragma Pack. 

This section discusses how pragma Pack is used in the TeleGen2 implementation. 

a. With Boolean Arrays. You may pack Boolean arrays by the use of pragma 
Pack. The compiler allocates S bits for a single Boolean, S bits for a component of 
an unpacked Boolean array, and l bit for a component of a packed Boolean array. 
The first figure illustrates the layout of an unpacked Boolean array; the one below 
that illustrates a packed Boolean array: 

-Unpacked Boolean array:- 

Unpacked_Bool_Arr_Type Is array (Natural range 0..1) of 3ooIean 
U_B_Arr: Unpackcd_3ool_Ar r_Tvpe (True,False); 

MSB LSB 

7 0 

11111111 Element 0 

0 0 Element 1 


--———- Packed Boolean array.- 

Packed_Bool_Arr_Type Is array (Natural range 0..S) of Boolean; 
pragaa Pack (?acked_3ool_Arr_Type); 

?_3_Arr: ?acked_Bool - Arr_Type :« (?_3_Arr( () -> True, 
P_3_Arr(5) -> True, ochers -> False): 


Bit: 


Element: 


MSB 

15 

l 0 0 0 d 1 0 

0 12 5 4 5 o 


tunused) 


LSB 

0 


b. With Records. You may pack records by use of pragma Pack. Packed records 
follow these conventions: 

1. The total size of the record is a multiple ot S hits. 

2. Packed records may cross word boundaries. 

3. Records are packed to the bit le’.el i*' the elements are themselves 
packed. 


3-8 


REF-lfi30N-Vi.HU/68) 






LflM Annotations 


Below is an example of packing in a procedure. Rcp_Prce, that defines three 
records of different lengths. Objects of these three packed record types are com¬ 
ponents of the packed record Rec, The storage allocated for Rec is 16 bits; that 
is. it is maximally packed. 

procedure Rep_?rec is 

cype Al Is array (Natural range 0 .. 3) of 3aolean; 
pragsa Pack (Al); 

cype A2 Is array (Natural range 0 ., 3) of Boolean; 
pragaa Pack (a2): 

cype A3 Is array (Natural range 0 ., 2) of 3oolean; 
pragna Pack (A3); 

cype A—Rec is 
record 

One Al; 

Two : A2; 

Three : A3; 
end record; 
pragaa Pack (A_Rec); 

Rec : A~Rac; 

begin 

Rec.One ( 0 »> True, 1 -> False, 2 »> False, 

3 «> False, 4 «•> True, 5 «> False, 

6 *> False, 7 -> False, 8 ■»> True ); 

Rec.Two (3) :« True; 

Rec.Three (1) True; 
end Rep_?roc; 

3.7.2. [LRM13.2] Length Clauses. 

A length clause specifies an amount of storage associated with a type. The sec¬ 
tions below describe how length clauses are supported in this implementation of 
Te!eGen2 and how to use length clauses effectively within the context of 
TeleGen2. 

3.7.2.1. (a) Specifying Size: TSize. 

Tiie prefix T denotes an object. The size specification must allow for enough 
storage space ic accrnmodaie every allowable value of these objects. The con¬ 
strain- ■ or. ■ ?sm wL,r» • on its subcomponents i ifanyi must be static. For an un¬ 
constrained mi '-,' Uw index subtypes must also be static. 

For this implementation. ,Mio_Size ; s the smallest number of bits logically re¬ 
quired to hold any value in the range: no sign bit is allocated for non-negative 
ranges. Biased representations are noi supported: e.g.. a range of 100 .. 101 re¬ 
quires " bits, not I. Warning: in the current release, using a size clause for a 
discrete type may cause inefficient code to be generated. For example, given... 


Ill MAY!)!) 


3-9 












TeleGenS Reference Information for UNIX/68K Hosts 


type Nibble is range 0 .. IS; 
for Nibble'Sire use 4; 

...each object of type Nibble will occupy only 4 bits, and relatively expensive bit¬ 
field instructions will be used for operations on Nibbles. (A single declared object 
of type Nibble will be aligned on a storage-unit boundary, however.) 

For floating-point and access types, a size elause has no effect on the representa¬ 
tion. (Task types are implemented as access types). 

For composite (array or record) types, a size clause acts like an implicit pragma 
Pack, followed by a check that the resulting size is no greater than the requested 
size. Note that the composite type will be packed whether or not it is necessary to 
meet the requested size. The size clause for a record must be a multiple of storage 
units. 

3.7.2.2. (b) Specifying Collection Size: TStorage_Slze. 

A collection is the entire set of objects created by evaluation of allocators for an 
access type. 

The prefix T denotes an access type. Given an access type Aec_Type, a length 
clause for a collection allocated using Aec_Type objects might look like this: 

for Acc-Type'Storage-Size use 64; 

In Te!eGen2. the above length clause allocates from the heap 64 bytes of contigu¬ 
ous memory for objects created by Acc-Type allocators. Every time a new object 
is created, it is put into the remaining free part of the memory allocated for the 
collection, provided there is adequate space remaining in the collection. Other¬ 
wise. a storage error is raised. 

Keeping the objects in a contiguous span of memory allows system storage recla¬ 
mation routines to deallocate and manage the space when it is no longer needed. 
Pragma Controlled can prevent the deallocation of a specified collection of ob¬ 
jects. Objects can be explicitly deallocated by calling the Unchecked-Deallocation 
procedure instantiated for the object and access types. 

Given an access type which does not have a length clause specified, the 
’Storage-Size attribute will return a value ofO. 


Header Record 


in this configuration of TeleGenZ. intormation needed to manage storage blocks 
in a collection is stored in a collection header that requires 20 bytes of memory, 
adjacent to the collection, in addition to the value specified in the length clause. 


3-l» 


REF-IW0N-V1.KU/68) 








LRM Annotations 


Minimum Size 


When an object is deallocated from a collection, a record containing link and size 
information for the space is put in the deallocated space as a placeholder. This 
enables the space to be located and reallocated. The space allocated for an object 
must therefore have the minimum size needed for the placeholder record. For 
this TeleGen2 configuration, this minimum size is the sum of the sizes of an access 
type and a integer type, or 6 bytes. 


Dynamically Sized Objects 

When a dynamically-sized object is allocated, a record requiring 2 bytes accom¬ 
panies it to keep track of the size of the object for when it is put on the free list. 
The record is used to set the size field in the placeholder record since compaction 
may modify the value. 


Size Expressions 


Instead of specifying an integer in she length clause, you can use an expression to 
specify storage for a given number of objects. For example, suppose an access 
type Dict_Ref references a record SymboLRec containing five fields: 

cype Tag is Scringfl..3); 

cype Syabol_Rec; 

cype Dicc_Re£ is access Syrsbol-Rec; 

cype SynboL-Rec is 
record 

Le£c : Dicc_Re£; 

Righc : Dicc_Ref: 

Parenc : Dicc_Re£; 

Value : Inccger; 

Rev : Tag; 
end record; 

To allocate 10 SymboLRec objects, you could use an expression such as: 

for Diec_Re£'Scorage-Size use ((Synbol-Rec'Sise * 10)+20); 


where 20 is the extra space °eeded for the header record. (SymboLRec is obvi¬ 
ously larger than the minimum size required, which is equivalent to one access 
type and one integer.) 

In .mother implementation. SymboLRec might be .t variant record that uses a 
variable length for the string Key: 

cype SymboL_Rec(Lasc : Nacurai :*»0) is 
record 

Lefc : Di.cc_Re£; 


01MAY90 


3-11 







TeieGen2 Reference Information for UN1X/68K Hosts 


Right : Dict_Re£; 

Patrenc : Dict_Rcz; 

Value : Integer; 

Key : String(l,.Last); 
end record; 

In this case, SymboLRec objects would be dynamically sized depending on the 
length of the string for Key. Using a length clause for DicuRef as above would 
then be illegal since SymboLRcc'Size cannot be consistently determined. A 
length clause for SymboLRec objects, as described in (a) above, would be illegal 
since not all components of SymboLRec are static. As defined, a SymboLRec ob¬ 
ject could conceivably have a Key string with Integer Last number of characters, 

3.7.2.3. (c) Specifying Storage for Task Activation; TStorage_Slze. 

The prefix T denotes a task type, A length clause for a task type specifies the 
number of storage units to be reserved for an activation of a task of the type. The 
TeleGen2 default stack size is 4000 bytes. 

3.7.2.4. (d) Specifying 'Small for Fixed Point Types: T'Small. 

Small is the absolute precision (a positive real number) while the prefix T denotes 
the first named subtype of a fixed point type. Elaboration of a real type defines a 
set of model numbers. T'Small is generally a power of 2, and model numbers are 
generally multiples of this number so that they can be represented exactly on a 
binary machine. All other real values are defined in terms of model numbers hav¬ 
ing explicit error bounds. 

Example: 

type Fixed is deica 0.25 range -10.0 .. 10.0; 


Here... 

Fixed’Small = 025 -.4 power of 2 

3.0 = 12 * 025 - .4 model number but not a power of 2 

The value of the expression of (he length clause must not be greater than the delta 
of the first named subtype. The effect of the length clause is to use this value of 
‘Small for the representation of values of the fixed point base type. The length 
clause thereby also affects the amount of storage for objects that have this type. 

If a length clause is not used, for model numbers defined by a fixed point con¬ 
straint. the value of Small is Jetined as the largest power of two that is not greater 
than the delta of the fixed accuracy definition. 

If a length clause is used, the model numbers are multiples of the specified value 
for Small. For this configuration of TeleGen2. the specified value must be 
( mathematically) equal to either an exact integer or the reciprocal of an exact in¬ 
teger. 


3-12 


REF-l630N-Vl.l(U/68) 









LRM Annotations 


Examples: 

1.0, 2,0, 3.0, 4.0, . . . are legal 
0,5, 1.0/3.0, 0.25, 1.0/3600.0 are legal 
2.5, 2.0/3.0, 0.3 are illegal 

3.7.3. [LRM 13.3] Enumeration Representation Clauses. 

Enumeration representation elauses are supported, except for Boolean types. 

Performance note: Be aware that use of such clauses will introduce considerable 
overhead into many operations that involve the associated type. Such operations 
include indexing an array by an element of the type, or computing the ‘Pos, 'Pred, 
or ’Succ attributes for values of the type. 

3.7.4. [LRM 13.4] Record Representation Clauses. 

Since record components are subject to rearrangement by the compiler, you must 
use representation clauses to guarantee a particular layout. Such clauses are sub¬ 
ject to the following constraints: 

• Each component of the record must be specified with a component 
clause. 

• The alignment of the record is restricted to mods 1.2, and 4; byte, word, 
and long-word aligned, respectively. 

• Bits are ordered right to left within a byte. 

• Components may cross word boundaries. 

Here is a simple example showing how the layout of a record can be specified by 
using representation clauses: 

package Repspec—Exanple is 
Bits : conscanc :■* 1; 

Word : conscanc :«* 4; 

f 

cype Five is cange 0 ., 16f/lF$; 

cype Sevenceen is range 0 .. lotflFFF?#; 

cype Nine is range 0 .. 511; 

cype Record_Layouc_Type is record 
Elenentl : Sevenceen: 

Elemenc2 : Five: 

Elenenc3 : Boolean: 

Elenenc4 : Nine; 
end record; 

for Record_Layouc_Type use record ac nod 2; 

Elenencl ac 0*Uord range 0 .. 16; 

Elenenc2 ac 0*Word range 17 .. 21; 


OIMAV'JO 


3-13 

















TeleGen2 Reference Information for UNIX/68K Hosts 


Eleaent3 ac 0*Vord range 22 22; 

Elesenc4 ac Q*Vord range 23 .. 31; 
end record; 

Record-Layout : Record-Layout-Type; 
end Repspec—Example; 


3.7.5, [LRM13.5] Address Clauses. 

The Ada compiler supports address clauses for objects and entries. Address 
clauses for packages and task units are not supported. 

Address clauses for objects may be used to access hardware memory registers or 

other known memorv locations. The use of address clauses is affected bv the fact 
* * 

that the System-Address type is private. For the MC6S0xO target, literal addresses 
are represented as integers, so an unchecked conversion must be applied to these 
literals before they can be passed as parameters of type System-Address. For ex¬ 
ample, in the examples in this document the following declaration is often as¬ 
sumed; 

function Addr is new Unchecked-Conversion (Long-Integer, 

System.Address); 

This function is invoked when an address literal needs to be converted to an Ad¬ 
dress type. Naturally, user programs may implement a different convention. 
Below is a sample program that uses address clauses and this convention. Pack¬ 
age System must be explicitly withe d when using address clauses. 

with Systen; 

with Unchecked-Conversion; 
procedure Hardware-Access is 

function Addr is new Unchecked—Conversion (Long-Integer, 

System.Address); 

Hardware-Register : integer; 

for Hardware-Register use ac Addr (16#FF0000#); 
begin 

end Hardware—Access; 

When using an address clause for an object with an initial value, the address 
clause should immediately follow the object declaration: 

Ob j: Some-Type <inic_expr>; 
for Obj use ac <addr-expr>; 

This sequence allows the compiler to perform an optimization wherein it gen¬ 
erates code to evaluate the <addr_expr> as part of the elaboration of the declara¬ 
tion of the object. The expression <init_e.\pr> will then be evaluated and as¬ 
signed directly to the object, which is stored at <addr_expr>. If another declara¬ 
tion had intervened between the object declaration and the address clause, the 
compiler would have had to create a temporary object to hold the initialization 
value before copying it into the object when the address clause is elaborated. If 


3-N 


REF-I630N-Vl,l(U/fi8) 







LRM Annotations 


the ooject were a large composite type. the need to use a temporary could result 
in considerable overhead in both time and space. To optimize your applications, 
therefore, you are encouraged to plaee address clauses immediately after the 
relevant object declaration. 

As mentioned above, arrays containing components that can be allocated in a 
signed or unsigned byte (S bits) are packed, one component per byte. Further¬ 
more, such components are referenced in generated code by MCfiSOxO byte in¬ 
structions. The following example indicates how these facts allow access to 
hardware byte registers: 

with Svscea; 

vich Unchecked-Conversion; 

procedure Main is 

function Addr is nevr Unchecked-Conversion (Long-Incegcr, 

Systeo.Address); 

type Byre is range -128,,127; 

HVJRegs : array (0..1) of Byce; 

for HV-Regs use ac Addr (160FFF31O#); 

- -S_3yce : conscane integer 0; 

Nexc_31ock_Requesc: conscanc integer :« 1; 

Requesc_3yce : Byte 119; 

Status : Byce; 

begin 

Status :« KV_Jtegs(Scacus_3yce); 

HW_Regs(Nexc_Block_Rcquesc) Request-Byte; 

end Main; 


Two byte hardware registers are referenced in the example above. The status byte 
is at location 16#FFF310# and the next block request bvte is at location 
16#FFF311#. 

Function Addr takes a long Integer as its argument. LongJnteeer'Last is 
16#7FFFFFFF#, but there are certainly addresses greater than 
LongJnteeer'Last. Those addresses with the high bit set. such as FFFAOOOO, can¬ 
not be represented as a positive long integer. Thus, for addresses with the high bit 
set. the address should be computed as the negation of the 2’s complement of the 
desired address. According to this method, the correct representation of the sam¬ 
ple address above would be Addrt -16#00060000# 1. 

3.7.6. [LRM 13.6] Change of Representation. 

TdeGenZ supports changes of representation, except for types with record 
representation clauses. 


OIMAYUO 


3-15 














TeleGen2 Reference Information for UNIX/68K Hosts 


3.7.7. [LRM 13,7] The Package System. 

The specification of TelcGen2'$ implementation of package System is presented in 
the LRM Appendix F section at the end of this chapter. 

3.7.8. [LRM 13.7.2] Representation Attributes. 

The compiler does not support 'Address for packages. 

3.7.9. [LRM 13.7.3] Representation Attributes of Real Types. 

The representation attributes for the predefined floatinc point tvpes were present¬ 
ed in Table 3-2. 

3.7.10. [LRM 13.8] Machine Code Insertions. 

Machine code insertions, an optional feature of the Ada language, are fully sup¬ 
ported in Te!eGen2. Refer to the “Using Machine Code Insertions" section in the 
Programming Guide chapter for information regarding their implementation and 
for examptes on their use. 

3.7.11. [LRM 13.9] Interface to Other Languages. 

In Te!eGen2, pragma Interface is supported for Assembly, C, UNIX and Fortran. 
Refer to “Interfacing to Other Languages" in the Programming Guide chapter for 
for information on the use of pragma Interface. Te!eGen2 does not currently al¬ 
low pragma Interface for library units. 

3.7.12. [LRM 13.10] Unchecked Programming. 

UnchecketLConversion is allowed except when the target data subtype is an un¬ 
constrained array or record type. If the size of the source and target are static and 
equal, the compiler will perform a bitwise copy of data from the source object to 
the target object. 

Where the sizes of source and target differ, the following rules will apply. 

• If the size of the source is greater than the size of the target, the high ad¬ 
dress bits will be truncated in the conversion. 

• If the: ize of the source is less than the size of the target, the source will 
be moved into she low address bits of the target. 

The compiler will issue a warning when UnchecketLConversion is instantiated 
with unequal sizes for source and target subtype. UnchecketLConversion 
between objects of different or non-static sizes will usually produce less efficient 
code and should be avoided, if possible. 


3-lfi 


REF-!fc3()N-VT.l(U/6R) 


















LRM Annotations 


3.8. LRM Appendix F for TeleGen2 

The Ada language definition allows for certain target dependencies. These 
dependencies must be described in the reference manual for each implementation, 
in an ‘‘Appendix P* that addresses each point listed in LRM Appendix F. Table 
3-5 constitutes Appendix F for thir implementation. Points that require further 
clarification are addressed in sections referenced in the table. 


0IMAY90 


3-17 








TeleGer?2 Reference Information for UNIX/6SK Hosts 


Table 3-5. LRM Appendix F for TelcGen2 


(l) Implementation-Dependent Prag- J (a) Implementation-defined pragmas: | 
mas . Comment, Images. Interrupt j 

, t Interface-Information, Linkname, j 

i * No_Suppre$$, PreserveJLayout and j 

; Suppress_All (Section 3.3.1). j 

. ■ I 

(b) Predefined pragmas with j 
| implementation-dependent characteris- 

{ tics: 

1 t 

'■ j 

, ] • Interface (assembly, UNIX. C, and j 

‘ Fortran- see “Interfacing to Other j 
i Languages." Not supported for library 

1 units. 

j i 

• List and Page (in context of source/error 
| j compiler listings.) (See the User Guide.) ! 

| • Pack. See Section 3.7.1. 

| i 

1 j • Inline. Not supported for library-level : 

| 1 subprograms. 

! i • Priority. Not supported for main pro- 

! grams. 

j ' 

! ] Other supported predefined pragmas: 

| . Controlled Shared Suppress Elaborate j 

: ’ j 

! Predefined pragmas partly supported i 

(see Section 3.1): Memory-Size 1 
Storage-Unit System-Name 

Sot supported: Optimize 
- Continued on the next page - 


REF-ifi30N-Vl.l(U/68) 














LRM Annotations 


Tabic 3-5. LRM Appendix F forTeleGen2 (Contd) 


-4. : -ssassssass a ssaes gcsasas5Bes5gas»gsass=s ssssacssas sasagassssasasg ar 

Continued from the previous page *- 


| (2) Implementation-Dependent Attri- 

• butes 

i 

j 

f 

! 

* 

i 

I 

t 

i 

i 

! 

i 


'Offset. Used for machine code insertions. 
The predefined attribute ’Address is not 
supported for packages. See “Using 
Machine Cede Insertions” earlier in this 
chanter for information on 'Offset and 'Ad- 
dress. 

'Extended-Image 

'EttendctL.Value 

'Extended-Width 

'ExtcndcdLAft 

'Extended-Digits 

'Extended-Fore 

Refer to Section 3.S.2 for information on the 
implementation-defined extended attributes 
listed above. 


(3) Package System ’ See Section 3.7.7. 


(4) Restrictions on Representation Summarized in Table 3-4. 
Clauses 


(5) Implementation-Generated Names None 


(6) Address Clause Expression In- An expression that appears in an object ad- 
terpretation dress clause is interpreted as the address of 

the first storage unit of the object. 


! (7) Restrictions on Unchecked Conver- Summarized in Table 3-4. 
• sions 


Continued on the next pr/ge 


DlMAYDl) 


3-19 

























TeIeGen2 Reference Information for UN1X/68K Hosts 



! (8) Implementation-Dependent Charae- I. In Text_IO. the type Count is defined 1 
teristics of the I/O Packages, as follows: 

type Count is range 0..{2 ** 31)-- 

2. In Text_IO, the type Field is defined as 
follows: 

subtype Field is integer range 0..1Q00 j 

3. In Text-IO, the Form parameter of 
procedures Create and Open is not 
supported. (If you supply a Form 
parameter with either procedure, it is 
ignored.) 

4. SequentiaLIO and DirectJO cannot 
be instantiated for unconstrained array 
types or discriminated types without de¬ 
faults. 

5. The standard library contains prein¬ 
stantiated versions of j 

Text_IO.Integer_IO for types Integer 
and Long-Integer and of 
Text-iO.FloatJO for types Float and 
Long_Float. We suggest that you use 
the following to eliminate multiple in- j 
stamiaiions of these packages: j 

Short-Intcger-Text-IQ J 

Imcger-Text-IO 1 

Long_Inieger_Texi_IO 
FloauTesuIO 
Long_Float_To.\t_10 


3.8.1. Implementation-Defined Pragmas. 

There are eight implementation-defined pragmas in TeleGen2: pragmas Com¬ 
ment. Images. Interface-information. Interrupt. Linkname. NoJSuppress. 
Preserve-Layout, and Suppress_All. 





REF-Ifi3(l«N-VI.l(U/68) 

















LRM Annotations 


3.8.1.1. Pragma Comment. 

Pragma Comment is used for embedding a comment into the object code. Its syn¬ 
tax is: 


pragma Comment t <$tring_literai> ); 

where *'< string-literal >" represents the characters to be embedded in the object 
code. Pragma Comment is allowed only within a declarative part or immediately 
within a package specification. Any number of comments may be entered into the 
object code by use of pragma Comment. 

3.8.1.2. Pragma Images. 

Pragma Images controls the creation and allocation of the image and index tables 
for a specified enumeration type. The image table is a literal string consisting of 
enumeration literals catenated together. The index table is an array of integers 
specifying the location of each literal within the image table. Tne length of the in¬ 
dex table is therefore the sum of the lengths of the literals of the enumeration 
type; the length of the index table is one greater than the number of literals. 

The syntax of this pragma is: 

pragma Imagest <cnumeration_type>, Deferred); 

- or - 

pragma rmagest<enumeration-type>, Immediate); 

The default. Deferred, saves space in the literal pool by not creating image and in¬ 
dex tables for an enumeration type unless the 'Image. 'Value, or 'Width attribute 
for the type is used. If one of these attributes is used the tables are generated in 
the literal pool of the compilation unit in which the attribute appears. If the attri¬ 
butes are used in more than one compilation unit, more than one set of tables is 
generated, eliminating the benefits of deferring the table. In this case, using 

pragma Imagest <enumeraclon_type>, Immediate!; 

will cause a single image table to be generated in the literal pool of the unit de¬ 
claring the enumeration type. 

For a very large enumeration type, the length of the image table will exceed 
Integer'Last i the maximum length of a string!. In this case, using either 

pragma Imagest <enumeration_type>. I mined late i; 

or the 'Image. 'Value, or 'Width attribute for the type will result in an error mes¬ 
sage from the compiler. 

3.8.1.3. Pragma Interface-Information. 

The existing Ada interface pragma only allows specification of a language name. 
In some cases, the optimizing code generator will need more information than can 


0IMAY90 


3-2! 











TeleGen2 Reference Information for UNIX/68K Hosts 


be derived Orem the language name. Therefore there is a need for an 
implementation-specific pragma. Interface-information. 

There is an extended usage of this pragma for Machine Code Insertion pro¬ 
cedures which does not use a preceding pragma Interface. Other than that case, a 
pragma Interface-Information is always associated with a Pragma Interface, The 
syntax is: 

pragma Incarface-Inforaaclon (Nase, 

Link-Jtaae, 

Mechanisa, 

Paraaecers, 

Clobber ed_?.eg 2 ); 


— ada-subprograa-idencifier, required 
string, default: * 

— string, default - "PROTECTED” 

— string, default *• "" 

— string, default - "" 


where: 

nase 

link-naae 

aechanisa 

paraaeters 

clobbered—regs 


Scope. 

Pragma InterfaceJfnformation is allowed wherever the standard pragma Interface 
is allowed, and must be immediately preceded by a pragma Interface purporting 
to the same Ada subprogram, in the same declarative part or package 
specification: no intervening declaration is allowed between the Interface and 
InterfaceJfnformation pragmas. Contrary to pragma Interface, this pragma is not 
allowed for overloaded subprograms (it specifies information that pemin to one 
specific body of non-Ada code). If the user wishes to use overloaded Ada names, 
the Interface and InterfaceJnformation pragmas may be applied to unique 
renaming declarations. 

The pragma is also allowed for a library unit: in that case, the pragma must occur 
immediately after the corresponding Interface pragma, and before any subsequent 
compilation unit. 

This pragma may be applied to any interfaced subprogram, regardless of the 
language or system named in the interface pragma. The code generator is respon¬ 
sible for rejecting or ignoring illegal or redundant interface information. The op¬ 
timizing code generator will process and check the legality of such interfaced sub¬ 
programs at the time of the spec compilation, instead of waiting for an actual use 
of the interlaced -'Ubprogram. This will save the user from extensive recompila¬ 
tion of the offensive specification and all its dependents should an illegal pragma 
have been used. 

This pragma is also used for Machine Code Insertion (MCI) procedures. In that 
ease, the "mechanism" should he set to ”mci.“ This allows the user to specify de¬ 
tailed parameter characteristics tor the call and inlined call to the MCI procedure. 


3-22 


REF-1630N-V1.1 (U/68) 







LflM Annotations 


When used in conjunction with pragma Inline, this allows the user to directly in¬ 
sert a minimal set of instructions into the call location. 

Parameters. 

Name; Ada subprogram identifier. The rule detailed in LRM 13.9 for a subpro¬ 
gram named in a pragma Interlace apply here as well. As explained above, the 
subprogram must have been named in an immediately preceding Interface prag¬ 
ma. 

This is the only required parameter. Since the other parameters arc optional, po¬ 
sitional association may only be used if all parameters are specified, or only the 
rightmost ones are defaulted. Named association must be used otherwise: this re¬ 
quires that the front-end supports it in pragmas. 

Link-Name; string literal. When specified, this parameter indicates the name the 
code generator must use to reference the named subprogram. This string name 
may contain any characters allowed in an Ada string and must be passed un¬ 
changed (in particular, not case-mapped) to the *ode generator. The code gen¬ 
erator will reject names that are illegal in the particular language or system being 
targeted. 

If this parameter is not specified, it defaults to a null string. The code generator 
will interpret a default link-name differently, depending on the target 
language/system (the default is generally the Ada name, or is derived from it, for 
example. “'_Ada_name M for 'C calls). 

Mechanism; siring literal. The only mechanism currently implemented is the 
"mci" mechanism used strictly in conjunction with Machine Code Insertion pro¬ 
cedures. 

A future mechanism will include "protected" where the code generator will protect 
the Ada exception model on calls to that external subprogram. Unfortunately, 
such protection is cosdy, which means that it should be applied only when neces¬ 
sary, as most interfaced subprograms do not raise exceptions or traps. Until this 
mechanism is implemented, external code which causes traps will cause unpredict¬ 
able unhandled exception tracebacks. 

Parameters: strinu literal. This string, when present, tells the code generator that 
some parameters are to be passed in registers (instead of on the stack, which is 
the default). The siring is passed as is bv the front-end. and is decoded by the 
code generator. 

The code generator interprets the string as a positional aggregate, where each po¬ 
sition reters to a parameter of the interfaced subprogram. Each position of the 
aggregate may either be null, or one of the following identifiers: “DO. Dl. AO. Al. 
FPO. or FPL" which specify that the corresponding parameter be passed in the 
named register. Thus the siring "A()..Di)“ specifies that the first parameter be 
passed in At), the second in the stack, the third in DO. and any other parameters in 


0IMAY90 


3-23 









TeleGen2 Reference Information for UNIX/68K Hosts 


the stack. 

A register identifier may be used, at most, once in the parameter passing descrip¬ 
tion string, except for function return value, as explained below. The code genera¬ 
tor will also enforce some semantic restrictions; for example, a floating point re¬ 
gister can only be used to pass a float type parameter, although a float parameter 
can be passed in a regular data register. Only scalar values and addresses may be 
passed directly in registers; composites must be passed in the stack (by reference 
or by value, dictated by the code generator model for the target language/system). 
Explicit passing of the ’Address of a composite in a register is allowed (the param¬ 
eter must be of type System Address). 

The parameters string can also be used to specify the register in which a function 
return value will be passed back. The parameters registers string may in that case 
have one position more than the number of parameters; this position describes the 
return value. The register used for the return value may have been used for an in¬ 
put parameter. This is the only case where a register may occur twice in the same 
string. If not specified for a given function, the code generator uses the register 
normally used for the target language/system (that is. ”C’ returns all in DO or 
D0/D1, whereas “Assembly" returns in DO. DQ/D1, AO, or FPO depending on the 
return value type). 

ClobberecLRegs. These are the registers (comma-separated list) that are des¬ 
troyed by this operation. The code generator will keep anything valuable in these 
registers at the point of the eall. 

A simple example of the use of pragma Interface-Information is: 

procedure Do-Something (Addr: System.Address; Lent Integer); 

pragaa Interface (Assembly, Do-Soaething); 

pragma Interface-Information ( Nane -> Do Something, 

Link-Mane -> "CGS$$DOIT", 
Mechanism -> "UNPROTECTED", 
Parameters »> "AO,DO"); 


3.8.1.4. Pragma Interrupt 

Pragma Interrupt is describee in this reference volume in Chapter 2. Please refer 
to the section "Optimized fnr.rrupt Entries." subsection "Function-Mapped Op¬ 
timizations." 


3.8.1.5. Pragma Linkname. 

Pragma Linkname is used to provide interface to any routine whose name can be 
Npecified by an Ada string literal. This allows access to routines whose identifiers 
do nut conform to Ada identifier rules. 


304 


REF-1630N-Vl,l(U/68) 








LRM Annotations 


Pragma unkname takes two arguments. The first is a subprogram name that has 
been previously specified in a pragma Interface statement. The second is a string 
literal specifying the exact link name to be employed by the code generator in em¬ 
itting calls to the associated subprogram. The syntax is*. 

pragma Interface f assembly, <subpn)gram_nnme> ); 
pragma Linkname ( <subprogram_name>, <stringjiteral> }; 

If pragma Unkname does not immediately follow the pragma Interface for the as¬ 
sociated program, a warning win be issued saying that the pragma has no effect, 

A simple example of the use of pragma Unkname is: 

procedure Duray—Access( Dur.ny_A.rg : Syscea.Address ); 
pragaa Interface (assembly, Dummy-Access ); 
pragaa Linlmaoe (Dummy-Access, "—access"); 

Notes: (1) It is preferable that the user use pragma Interface-Information for 

this functionality. 

(2) In the example above, the link name generated may be “_access’* 

instead of “-access” if your native C compiler prepends an underscore 
to the specified link name. 

3.8.1.6. Pragma No.Suppress. 

No_Suppre$s is a TeleGen2-defined pragma that prevents the suppression of 
checks within a particular scope. It can be used to override pragma Suppress in 
an enclosing scope, No-Suppress is particularly useful when you have a section of 
code that relies upon predefined checks to execute correctly, but you need to 
suppress checks in the rest of the compilation unit for performance reasons. 

Pragma No-Suppress has the same syntax as pragma Suppress and may occur in 
the same places in the source. The syntax is: 

pragma No_Supprcss (<identincr> [, [ON =>] <name>]); 

where < Identified is the type of check you do not want to suppress (e.g., 
access-check: refer to LRM 11.7) 

<name> is the name of the object, type/subcvpe. task unit, generic unit, or 
subprogram within which the check is not to be suppressed: <name> is op¬ 
tional. 

If neither Suppress nor No_Suppress is present in a program, checks will not be 
suppressed. You may override this default at the command level, by compiling the 
file with the -itnhibit option and specifying with that option the type of checks you 
want to suppress. For more information on -i(nhibit. refer to your Te!eGen2 
Chwiew and Command Summary document. 


OiMAY'JO 


3-25 















Te!eGen2 Reference Information for UNIX/68K Hosts 


If either Suppress or No-Supprcss are present, the compiler uses the pragma that 
applies to the specific check in order to determine whether that check is to be 
made. If both Suppress and No-Suppress are present in the same scope, the prag¬ 
ma declared last takes precedence, The presence of pragma Suppress or 
No-Suppress in the source takes precedence over an -it nhibit option provided 
during compilation. 

3.8.1.7. Pragma PreserveJLayout. 

The TeleGen2 compiler reorders record components to minimize gaps within 
records. Pragma Preserve-Layout forces the compiler to maintain the Ada source 
order of components of a given record type, thereby preventing the compiler from 
performing this record layout optimization. 

Tne syntax of this pragma is: 

Pragma Prescrve_i ayout ( ON = > RecorcL'I\pe_Name) 

Preserve-Layout must appear before any forcing occurrences of the record type 
and must be in the same declarative part, package specification, or task 
specification. This pragma can be applied to a record type that has been packed. 
If PreserveJLayout is applied to a record type that has a rec- J representation 
clause, the pragma only applies to the components that do no; nave component 
• clauses. These components will appear in Ada source order after the components 
with component clauses. 

3.8.1.8. Pragma Suppress_Ail. 

Suppress_All is a TeleGen2-defined pragma that will suppress all checks in a 
given scope. Pragma Suppress_AU contains no arguments and can be placed in 
the same scopes as pragma Suppress. 

In the absence of pragma Suppress_Ail or any outer suppress pragma, the scope 
which contains the pragma will have checking turned off. This pragma should be 
used in a safe piece of time critical code to allow for better performance. 

3.8.2. Implementation-Dependent Attributes. 

3.8.2.1. 'Address and'Offset. 

These were discussed within ’he context of using machine code insertions, in the 
Programming Guide chapter, 

3.8.2.2. Extended Attributes for Scalar Types. 

The extended attributes extend the concept behind the Te.xL.IO am ibutes ’Image. 
’Value, and 'Width to give the user more power and flexibility' when displaying 
values of scalars. Extended attributes differ in two respects from their predefined 
counterparts: 


3-26 


REF-I630N-VI.KU/6&) 












LRM Annotations 


1, Extended attributes take more parameters and allow control of the for¬ 
mat of the output string. 

2. Extended attributes are defined for all scalar types, including fixed and 
floating point types. 


Extended versions of predefined attributes are provided for integer, enumeration, 
floating point, and fixed point types: 


Integer: 
Enumeration: 
Floating Point: 
Fixed Point: 


'Extended-Image, 

'Extended-Image, 

'Extended-Image, 

'Extended-Image, 

'ExtendedLAft 


'Extended-Value, 

‘Extended-Value. 

'Extended-Value, 

'Extended-Value. 


'Extended-Width 

'Extended-Width 

'Extended-Digits 

'Extended_Fore, 


The extended attributes can be used without the overhead of including TextJO in 
the linked program. Below is an example that illustrates the difference between 
instantiating Text-IO.Floai-IO to convert a float value to a string and using 
Float'ExtendedLimage: 

with Text_IO; 

function Convert_To_Scring ( FI : Float ) return String is 
Temp_Str : String ( 1 .. 6 + Float'Digics ); 
package Flc_IO is new Texc_IO.Floac_IO (Float); 
begin 

Flt-IO.Put ( Teop-Str, FI ); 
return Teop_Scr; 

end Convert_To_Scring; 

function Convert-To_String_No_Text_IO( FI : Float ) return String is 
begin 

return Float'Excended-Inage ( FI ); 
end Convert-To_S cring-No_Texc_IO; 


0IMAY90 


3-27 

















TeleGen2 Reference Information for UNIX/68K Hosts 


vich Texc_IO, Coaverc_To_Scring, Converc-To-Scring-Jo-Texc-IO; 
procedure Shov_JDi£ferenc_Conversions is 

Value ; Float 10.03376; 

begin 

Text-10.Puc_Line < "Using she Convcrc_.To_Sering, che value of che variable 
is : " & Converc_To_Scring < Value ) ); 

Texe_I0.?uc_Line ( "Using che Gonverc_To_Scring-Jo_Texc_IO, che value 
is : " & Convert-To-Scring-N’o-Texc-IO < Value ) ); 

end Shov_Differenc_Conversions; 


3.8.2.2.I. Integer Attributes 
’ExtendedJmane 


Usage : 

X’ExtendedUmageUtem.Width.Basc.Based.SpaceJiFJPositive) 

Returns the image associated with Item as defined in TextJO.Integer.JO. The 
TextJO definition states that the value of Item is an integer literal with no under¬ 
lines, no exponent, no leading zeros (but a single zero for the zero value), and a 
minus sign if negative. If the resulting sequence of characters to be output has 
fewer than Width characters, leading spaces are first output to make up the 
difference. (LRM 14.3.7:10,14.3.7:11) 

For a prefix X that is a discrete type or subtype; this attribute is a function that 
may have more than one parameter. The parameter Item must be an integer 
value. The resulting string is without underlines, leading zeros, or trailing spaces. 


3-2X 


REF-1A3UN-V1.UL768) 







LRM Annotations 


Parameter Descriotiens: 


Item 

The item for which you want the image; it is passed to the 
function. Required 

Width 

The minimum number of characters to be in the string that is 
returned. If no width is specified, the default (0) is assumed. 
Optional 

Base 

The base in which the image is to be displayed. If no base is 
specified, the default (10) is assumed. Optional 

Based 

An indication of whether you want the string returned to be in 
base notation or not. If no preference is specified, the default 
(false) is assumed. Optional { 

; SpaceJfLPositive 

An indication of whether or not the sign bit of a positive in-, 
teger Is included in the string returned If no preference is | 
specified, the default (false) is assumed. Optional 


Etamoles: 


Suppose the following subtype were declared: 

subtype X is Integer Range -10..16; 


Then the following would be true: 

X*Extended-Iaage(5) 

X'Extended-Iaage(5,0) 

X'Extended-Iaage(5,2) 

X'Excended—Iaage(5,0,2) 

X'Extended-Iaage(5,4,2) 

X'Extended-Iaage(5,0,2,True) 

X'Extended-Iaage(5,0,10,False) 

X' Extended-Image ( 5,0,10, False, True) 

X' Extended-Image(-1,0,10,False,False) 
X'Extended_Iaage(-1,0,10,False,True) 
X'Extended-Image(-1,1,10,False,True) 
X ' Extended-Iaage(-l,0,2,True,True) 

X'Extended-Image(-1,10,2,True,True) 


- M 5« 

M «5» 

« " 5" 

- " 101 " 

- " 101 " 

- "2//101#" 

- "5*» 
x » 5» 

X »-l" 

X «.1« 

X tt »l« 

- "-2W 

- •• -mn n 


'Extended-Value 


Usage : 

X* Extended-Valuet I term 

Returns the value associated with item as defined in Text—IO.Integer_IO. The 
Text_iO definition states that given a string, it reads an integer value from the be- 


IHMAY90 


3-29 




TeleGen2 Reference Information for UNIX/68K Hosts 


ginning of the string. The value returned corresponds to the sequence input. 
(LRM 14.3.7:14) 

For a prefix X that is a discrete type or subtype, this attribute is a function with a 
single parameter. Tne actual parameter Item must be of predefined type string. 
Any leading or trailing spaces in the string X are ignored. In the case where an 
illegal string is passed, a Constraint-Error is raised. 


Parameter Descriotion: 


I Item A parameter of the predefined type string; it is passed to the • 

function. The type of the returned value is the base type X. j 
i Required | 


Examples: 


Suppose the following subtype were declared: 

Subtype X is Integer Range -10.,16; 


Then the following would be true: 

X'Extended_Value("5") - 5 

X'Extended_Value<" 5") - 5 

X' Extended-Value <"2//lO10") - 5 

X*Extended-Value("-l”) - -1 

X'Extende<L_Value(" -1") - -1 


’ExtendecLWidth 


Usage : 

X’Extended_Width(Base ; Based.Space.JLPositive) 

? ’emrns the width for subtype of X. 

For a prefix X that is a discrete subtype: this attribute is a function that may have 
multiple parameters. This attribute yields the maximum image length over all 
values of the type or subtype X. 


3-30 


REF-163IIN-Vt.I(U/68) 









LRM Annotations 


Parameter DescriDtions: 


Base Hie base for which the width will be calculated. IE no base is 

specified, the default (10) is assumed. Optional 

' Based An indication of whether the subtype is stated in based nota- 

, tion. If no value for based is specified, the default (false) is as- 

. sumed. Optional 

: SpaceJLPositive An indication of whether or not the sign bit of a positive in¬ 
teger is included in the string returned. If no preference is 
specified, the default (false) is assumed. Optioml 


Examoles: 


Suppose the following subtype were declared: 

Subtype X is Integer Range -10..IS; 


Then the following would be true: 

X* Extended-Width 
X'Extended_WIdth(10) 
X'Extended_57idth(2) 

X'ExtendedLWidth(10,True) 

X' Extended_.Vidth( 2, True) 
X'Exconded_W'idth(10, False, True) 
X'Extended-tfidthClO.True,False) 
X'Extended-WIdth(10,True,True) 
X'ExtendecL.Width(2 .True .True) 
X'Extended_Width(2,False.True) 



3 

- "-10" 


3 

- V0* 


5 

- "ioooo" 


7 

- *-10#10#" 


8 

2*10000 $- 


3 

-"16" 


7 

-"-10*10*" 

- 

7 

-"10*16*" 

m 

9 

- * 2*10000#' 

m 

6 

- " 10000" 


01MAY90 


3-31 












TeIeGen2 Reference Information for UNIX/68K Hosts 


3.B.2.2.2. Enumeration Type Attributes 


’E.xtcndctUmnue 

Usage: 

X*Extcnded_Imagc(Item,Width.Upperca$cj 

Returns the image associated with Item as defined in Text_IO.EnumerationJO, 
The Text-IO definition states that given an enumeration literal, it will output the 
value of the enumeration literal (either an identifier or a character literal). The 
character case parameter is ignored for character literals. (LRM 14.3.9:9) 

For a prefix X that is a discrete type or subtype; this attribute is a function that 
may have more that one parameter. The parameter Item must be an enumeration 
value. The image of an enumeration value is the corresponding identifier, which 
may have character case and return string width specified. 


Parameter Descriotions: 


Item The item for which you want the image: it is passed to the 

function. Required 

; Width The minimum number of characters to be in the string that is 

returned. If no width is specified, the default (0) is assumed. 
If the Width specified is larger than the image of Item, the re¬ 
turn string is padded with trailing spaces. If the Width 
specified is smaller than the image of Item, the default is as¬ 
sumed and the image of the enumeration value is output com¬ 
pletely. Optional 

, Uppercase An indication of whether the returned string is in uppercase 
characters. In the case of an enumeration type where the 
enumeration literals are character literals. Uppercase is ig¬ 
nored and the case specified by the type definition Is taken. If 
no preference is specified, the default (true) is assumed. Op' 
tionat 


3-32 


REF4630N-Vl.HU/68) 
















LRM Annotations 


Examoles: 


Suppose the following types were declared: 

cype X is (red, green, blue, purple); 
cype Y Is ('a', '3'. 'c', 'D'); 

Then the following would be true: 

X'Excended_Iaag*(red) 
X’Excended_Iaage(red, 4) 
X'Excended_Iaage(red,2) 

X*Excended-Isagefred,0,false) 
X'Excended-Iaagefred,10,false) 

Y'Escended_Iaage< * a') 

Y'Excended-Iaage('B') 
Y'Excended_Iaage('a' ,6) 
Y'Excended_Iaage('a',0,crue) 


- "RED" 

- "RED " 

- "RED" 

*■ "red" 
m "red 
M "'a'" 

- "' 9 *" 

» «' a * " 
m " * a'" 


M 


’Extended-Value 


Usage: 

X’E.xtendedLValue(Item) 

Returns the image associated with Item as defined in Text_IO.Enumeration_IO. 
The Text_IO definition states that it reads an enumeration value from the begin¬ 
ning of the given string and returns the value of the enumeration literal that 
corresponds to the sequence input. (LRM 14.3.9:11) 

For a prefix X that is a discrete type or subtype: this attribute is a function with a 
single parameter. The actual parameter Item must be of predefined type string. 
Any leading or trailing spaces in the string X are ignored. In the case where an 
illegal string is passed, a Constraint-Error is raised. 


OI.MAYW 


3-33 









TeleGen2 Reference Information for UNIX/68K Hosts 


Parameter Descriptions; 

: Item A parameter of the predefined type string; it is passed to the 

function. The type of the returned value is the base type of X < 
Required 


Examples : 

Suppose the following type were declared: 

type X is (red, green, blue, purple); 

Then the following would be true: 

X'Excended_Value('‘red") - red 

X'Extended-Valuef" green") *• green 

X*Extended-Value(" Purple") - purple 
X'Extended—Value(" GrcEn ") - green 


’Extended-Width 

Usage : 

X*Extended-Width 
Returns the width for subtype of X 

For a prefix X that is a discrete type or subtype; this attribute is a function. This 
attribute yields the maximum image length over all values of the enumeration type 
or subtype X. 

Parameter Descriptions : 

There are no parameters to this function. This function returns the width of the 
largest (width) enumeration literal in the enumeration type specified by X 

Examples : 

Suppose the following types were declared: 

type X is (red, green, blue, purple); 
type 2 is (XI. X12, X123, X1234); 

Then the following would be true: 

X' Extended-'* Ldch »■ 5 purple' 

Z'Extended-Width » 5 - ".V/Pj-T 


3-34 


REF-l630N-Vl.HU/68) 












LRM Annotations 


3.S.2.2.3. Floating Point Attributes 
'ExtendcdUmagc 


Csace : 

X’Extended-Imagedtcm.Fore-Aft.Exp.Base.Based’j 

Returns the image associated with Item as defined in Text-JO. Float_IO. The 
Text_IO definition states that it outputs the value of the parameter Item as a de¬ 
cimal literal with the format defined by the other parameters. If the value is nega¬ 
tive, a minus sign is included in the integer part of the value of Item. If Exp is 0, 
the integer part of the output has as many digits as arc needed to represent the in¬ 
teger part of the value of Item or is zero if the value of Item has no integer part 
(LRM 14.3.3:13, 14.3.3:15) 

Item must be a Rea! value. The resulting string is without underlines or trailing 
spaces. 

Parameter Descriptions: 


J Item 

! 

! The item for which you want the image: it is passed to the 
| function. Required j 

i Fore 

j 

j The minimum number of characters for the integer part of the J 
i decimal representation in the return string. Tliis includes a ; 

minus sign if the value is negative and the base with the ’#* if * 
i based notation is specified. If the integer part to be output has 
; fewer characters than specified by Fore, leading spaces are j 
; output first to make up the difference. If no Fore is specified, * 

, the default value (2) is assumed. Optional j 

' Aft 

; The minimum number of decimal digits after the decimal 
j point to accommodate the precision desired. If the delta of 1 

I the type or subtype is greater than 0.1, then Alt is l. If no Aft 
is specified, the default (X’Digits- 1) is assumed. If based nota¬ 
tion is specified, the trailing is included in Aft. Optional 

Exp 

The minimum number of digits in the exponent. The exponent 
consists of a sign and the exponent, possibly with leading 
zeros. If no Exp is specified, the default (3) is assumed. If 
Exp is 0. no exponent is used. Optional 

Base 

The base that the image is to be displayed in. If no base is 
specified, the default ( 10) is assumed. Optional 

Based 

An indication of whether you want the string returned to be in 
based notation or not. If no prelerenee is specified, the de¬ 
fault t false) is assumed. Opnottul 


01MAY90 


3-35 












Te!eGen2 Reference Information for UNIX/68K Hosts 


Examples: 


Suppose the following type wore declared: 

cype X is digics 5 range -LQ.0 .. 16,0; 


Then the following would be true: 

X'Excended-Isage(5,0) 

X'Excended_Ic:age(5.0,1) 

X f Exnended-Iaage(-5,0,1) 
X'£xcended_Iaage<5,0,2,0) 
X'Excended_Iaage(5.0,2,0,0) 

X'Excended_Iaage(5.0,2,0,0,2) 

X'ExcendetL-Iaage(5.0,2,0,0,2.True) 
X'Excended_Iaage(5.0,2,2,3,2,True) 


•• 5.0000E+00" 
"5.0000E+00" 
"-5.OOOOE+OO" 
" 5.0E+00" 

” 5.0" 

” 101 . 0 " 

" 20101 . 00 " 

"201.10E+O2” 


’Extended-Value 


Usage: 

X’ExtcndecLVnluct Item) 

Returns the value associated with Item as defined in TexLiO.FloatJO. The 
TexuIO definition states that it skips any leading zeros, then reads a plus or 
minus sign if present then reads the string according to the syntax of a real literal. 
The return value is that which corresponds to the sequence input. (LRM 143.8:9, 
143.8:10) 

For a prefix X that is a discrete type or subtype; this attribute is a function with a 
single parameter. The actual parameter Item must be of predefined type string. 
Any leading or trailing spaces in the string X are ignored. In the case where an 
illegal string is passed, a Constraint-Error is raised. 

Parameter Descriptions: 


Item A parameter of the predefined type string; it is passed to the i 

function. The type of the returned value is the base type of the ' 
input string. Required • 


Examples: 

Suppose the following type were declared: 

cype X is digics 5 range -10.0 16.0; 

Then the following would be true: 

X'Excended_Vaiue("5.0") - 5.0 

X'Excended_Value("0.5E1") =5.0 

X'Excended_Value("201- 01iVE2") = 5.0 


3-36 


REF-163UN-Vl.HU/68) 



LRM Annotations 


'ExtendcdJDitiits 


Usage: 

X’E.xtended-DigitstBasei 

Returns the number of digits using base in the mantissa of model numbers of the 
subtype X 

Parameter Descriptions: 

Base The base that the subtype is defined in. If no base is specified, 

the default (10) is assumed. Optional 


Examoles: 

Suppose the following type were declared: 

cype X la dlgics 5 range -10.0 .. 16.0; 
Then the following would be true: 
X'Excended-Digics *• 5 

3.8.Z2.4. Fixed Point Attributes 
? Extended-image 


Usage: 

X ! Extended-Jmage(Item,Fore,Aft.E.xpjBase.Based) 

Returns the image associated with item as defined in Text_JO.FLxed_IO. The 
TextiO definition states that it outputs the value of the parameter Item as a de- 
cimal literal with the format defined by the other parameters, (f the value is nega¬ 
tive, a minus sign is included in the integer part of the value of Item. If Exp is 0, 
the integer part of the output has as many digits as are needed to represent the in¬ 
teger part of the value of Item or is zero if the value of Item has no integer part. 
tLRM 143.3:13. 14.3.8:15) 

For a prefix X that is a discrete type or subtype: this attribute is a function that 
may have more than one parameter. The parameter Item must be a Real value. 
The resulting string is without underlines or trailing spaces. 


IHMAYDO 


3-37 









TeteGen2 Reference Information for UNIX/63K Hosts 


T 


Parameter Descriotions: 


Item 

The item for which you want the Image: it is passed to the J 

function, featured ~ « 

• 

Fore 

The minimum number of characters for the integer part of the 
decimal representation in the return string. This includes a * 
minus sign if the value is negative and the base with the '#* if' 
based notation is specified If the integer part to be output has ; 
fewer characters than specified by Fore, leading spaces are ■ 
output first to make up the difference. If no Fore is specified, i 
the default value {2) is'assumed. Optional | 

Aft 

{ 

r 

The minimum number of decimal digits after the decimal 1 
j point to accommodate the precision desired. If the delta of j 
i the type or subtype is greater than 0.1. then Aft is 1. If no Aft! 
t is specified, the default (X’Digits-l) is assumed. If based no-; 
; tation is specified, the trailing “#’ is included in Aft. Optional ; 

i Exp 

The minimum number of digits in the exponent; the exponent j 
consists of a sign and the exponent, possibly with leading ! 

, zeros. If no Exp is specified, the default {3 ) is assumed. If 
: Exp is 0, no exponent is used. Optional 

Base 

j 

The base in which the image is to he displayed. If no base is 
t specified, the default (10) is assumed. Optioml \ 

| Based 

! 

\ 

i 

: .An indication of whether you want the string returned to be in 

1 based notation or not. If no preference is specified, the de- ! 
fault (false) is assumed. Optional 1 


Examples: 


Suppose the following type were declared: 


eype X is delca 0.1 range -10.0 ., 17.0; 
Then the following would be true: 


X'ExEended_Inage(5,0) 

X* Excended-Iaage<5.0,1) 

X'Extended-Image(-5.0,1) 

X'Extended-Image(5.0,2,0) 

X* Extended_Image(5.0,2,0,0) 

X'Extended-Image(5.0,2,0,0.2) 

X' Extended_Image(5.0,2,0,0,2.True) 
X'Extended—Image(5.0,2,2,3,2.True) 


- " 5.00E+00" 

- "5.00E+00" 

- "-5.00E+00" 

- - 5.0E+00" 

- *• 5.0” 

- "101 0 " 

- "2tflG1.0#" 

- "2t/l.lf/E+02" 


3-3X 


REF-UG0N-VI.KU/6R) 








LRM Annotations 


'Extended-Value 


Usage : 

X* ExtcndedLValuetImage) 

Returns the value associated with Item as defined in TextJO.FLxccLIO. The 
Text-IO definition states that it skips any leading zeros, reads a plus or minus sign 
if present, then reads the string according to the syntax of a real literal. The re¬ 
turn value is that which corresponds to the sequence inout. (LRM 14.3.8:9, 
14.3.8:10} 

For a prefix X that is a discrete type or subtype; this attribute is a function with a 
single parameter. The actual parameter Item must be of predefined type string. 
Any leading trailing spaces in the string X are ignored. In the case where an 
illegal string is p v'sed, a Constraint-Error is raised. 


Parameter Descriotions: 


Image Parameter of the predefined type string. The type of the re¬ 

turned value is the base type of the input siring. Reqtiired 


Examples: 

Suppose the following type were declared: 

eype X is delea 0.1 range -10.0 .. 17.0; 

Then the following would be true: 

X'Exccndec2_Value("5.0") - 5.0 

X'Excended_Value("0.5E1") - 5.0 

X'Excended_Value("2#i'01//E2") - 5,0 


’Extended-Fore 


Usa ge: 

X’ExtendedJForet Base.Based} 

Returns the minimum number of characters required for the integer part of the 
based representation of X. 


UIMAY90 


3-39 




TeleGen2 Reference Information for UNIX/68K Hosts 


Parameter Descriotions; 


Base The base in which the subtype is to be displayed. If no base is \ 

specified the default (10) is assumed. Optional _j 

Based An indication of whether you want the string returned to be in ; 

based notation or not. If no preference is specified, the de- j 
_fault (false) Is assumed. Optional _ 


Examples: 

Suppose the following type were declared: 

type X is delta 0.1 range -10.0 17.1; 

Then the following would be true: 

X'Extended-Fore - 3 -- ”-10" 

X'Excended—Fore(2) “6 -- " 10001” 


’Extended-Aft 


Usage: 

X’Extended—AtlfBasc, Based) 

Returns the minimum number of characters required for the fractional part of the 
based representation of X. 


Par ameter Descriptions: 


Base 


I Based 


* 


i The base in which the subivpe is to be displayed. If no base is t 

! specified, the default (lO) is assumed. Optional | 

' - - - - - - — 

| An indication of whether you want the string returned to be in t 
• based notation or not. If no preference is specified, the de- ‘ 
fault (false) is assumed. Optional • 


Examples : 

Suppose the following type were declared: 

cype X is delta 0.1 range -10.0 .. 17.1; 

Then the following would be true: 

X'Extended—Aft - 1 -"1"from 0.1 

X'Excended_A£t:(2) - 4 -"0001"from 2M.OOOW 


3-40 


REF-163lhN-VU(U/68.) 





LRM Annotations 


3.8.3. Package System. 

The current specification of package Astern is provided below, 

with Unchecked^Conversion; 

package System is 


— CUSTOMIZABLE VALUES 


cype Name is (TeleGen2); 


Syscera_Nane : conscanc nane TeleGen2; 


Meaory_Size : conscanc :» <2 ** 31) -1; --Available aenory, In scorage unic 
Tick : conscanc :** 2.0 / 100.0; --Basic clock race, in seconds 


cype Task_Daca is --Adapeaclon specific customisation for cask objeccs 
record 
null; 

end record; 


-- NON-CUSTOMIZABLE, IMPLEMENTATION-DEPENDENT VALUES 


- See Table 3-2 for the values for attributes of 

- tvpes Float and Long-Float 


Scorage_Unic ; conscanc :» 8; 

Min_Inc ; conscanc : 

Max Inc ; conscanc : 


Max_Digics 
Max_Mancissa 
Fine Delca 


: conscanc :«■ 
: conscanc :«■ 
: conscanc :« 


-<2 ** 31); 

(2 ** 31 ) - 

15; 

31; 

1.0 / (2 ** 


i; 

Max Mancissa); 


subcype Priority is Integer Range 0 .. 63; 


ADDRESS TYPE SUPPORT 


cype Memory is private; 
cype Address is access Memory; 

-- Ensures compatibility between addresses and access types. 
-- Also provides implicit NULL initial value. 


0IMAY90 


3-41 






TeleGen2 Reference Information for UNIX/68K Hosts 


Null_Address: conscanc Address null; 

-« Xnicial value for any Address object 


type Address_Value is range -<2**31).. (2**31)-1; 


-- A numeric representation of logical addresses for use in address clause 


Hex 30000000 
Hex~90000000 
Hex~A0Q00G00 
Hex~30000Q00 
Hex“c0000000 
Hex~DOGOOOOO 
Hex~EQ000000 
Hex~FG000000 


conscanc Address_Value 
conscanc Address_Value 
conscanc Address_Value 
conscanc Address_Value 
conscanc Address_Value 
conscanc Address_Value 
conscanc Address__Value 
conscanc Address Value 


:» - 16030000000#; 

- 160700000000; 
;» - 16060000000#; 
;« - 1605OOOOOOO0; 
:- - 160AOOOOOOO0; 
:~ - 1603OOOOOOO0; 
:- - 160200000000; 
:«• - 160100000000; 


-- Define numeric offsets co aid In Address calculations 
-- Example: 

for Hardware use ac Location (Hex_F0000000 16023456730); 


funccion Locacion is new Unchecked_Conversion (Address_Value, Address); 
-- May be used in address clauses: 

Object: Some_Type; 

-- for Objecc use ac Locacion (16040000); 


funccion Label (Name: String) recum Address; 
pragma Incerface (META, Label); 

-- The LABEL r.:eea-funccion allows a link name co be specified as address 
-- for an imported objecc in an address clause: 

-- Objecc: Sooe_Type; 

-- for Objecc use ac Label("CBJECT?SLINK_NAME"); 

-- Syscem.Label returns Null__Address for non-literal parameters. 


-- ERROR REPORTING SUPPORT 


procedure Reporc_Error; 

pragma Incerface (Assembly, Reporc_Error); 

pragma Incerface_Informacion (Reporc_Error, "REP0RT_ERR0R"); 


3-42 


REF-l630N-Vl.](U/68) 
















LRM Annotations 


- Reporejirror can only be called in an exception handler and provides 

an exception traceback like tracebacka provided for unhandled 

- exceptions 


-- CALL SUPPORT 


type Subpregrao_Value IS 
record 

Proc_addr : Address; 
Parent_frane : Address; 
end record; 


-- Value returned by the iaplenencation-dcfined 'Subprograa_Value 
-- attribute. The attribute is not defined for subprograms vith 
-- parameters, or functions. 


private 

type Memory Is 
record 
null; 

end record; 
end System; 


3.8.3.1. System.Label 

The System.Label meta-function is provided to allow users to address objects by a 
linker-recognized label name. This function takes a single string literal as a 
parameter and returns a value of Svstem.Address. The function simply returns 
the run-time address of the appropriate resolved link name, the primary purpose 
being to address objects created and referenced from other languages. 

• When used in an address clause. System.Label indicates that the Ada ob¬ 
ject or subprogram is to be referenced by a label name. The actual ob¬ 
ject must be created in some other unit (normally by another language), 
and this capability simply allows the user to import that object and refer¬ 
ence it in Ada. 

* When used in an expression. System.Label provides the link rime ad¬ 
dress of any name; a name that might be for an object a subptogram, 
etc. 


01MAY90 


3-43 











TeleGen2 Reference Information for UNIX/68K Hosts 


3.8,3.2. System.Report-Error 

ReportJSrror can only be called from within an exception handler. This routine 
displays the normal exception tracebaek information to standard output. It is 
essentially the same tracebaek that could be obtained if the exception were unhan¬ 
dled and propagated out of the program, but the user may want to handle the ex¬ 
ception and still display this information. The user may also want to use this capa¬ 
bility in a user handler at the end of a task (since those exceptions will not be pro¬ 
pagated to the main program). Note that the user can also get this capability for 
all tasks using the -X binder switch. 

For details on the output, see the programming guide chapter in this volume, sec¬ 
tion "Exception Handling." 


3-44 


REF-lfi30N-Vl.l(U/68) 







