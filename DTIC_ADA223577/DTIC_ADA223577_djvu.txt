’ u ■:0 12:34 


I 1 7 RESEARCH I ‘ 1 ST 


jmm.LE copy 


p. 22 


HDT nrxoi iiac-ait-a 


TION PAGE 


&ut&7nitm 




u 


IMinru • 
mvkxi' 


AGENCY 1 


AD-A223 577 





■.PEPQRT TYPE AND OATES OOWESED 

Final 


,£?a Compiler Validation Summary Report: Tartan 
•stories Incorporated, Tartan Ada Sun/CoO, Version Z.Z 

60 (Host) to 320C30 on TI Applications Board (Target), 

t.10263 


* authors) 

' B •- AVF 


ibrotrn, FEDERAL REPUBLIC OF GERMANY 


7 .flEfVQAMMCORMMZAnONNA)C(f)ANDADOflES3(E5) 

1ABG-AVF , Indust.rieanlagen-Betrieb sgesel schaft 

Dept SZT 

Eir i.elnstrasse 20 

D-8012 Ottobrunn 

FEDERAL REPUBLIC OF-GERMAN!’ 

‘jEgraagr*""" 

AVF-IABG-061 

t fPtXMORMQMONnORVlQ AGENCY NAME(S) ANO AZXMES3(E$) 

Ada Joint Program Office 

United States Department of Defense 

Washington, D.C. 20301-3081 


f ANUiCs a AY NOTES 

1 

i 

1 

urn. OOTwunoNfAWAtaavnr swteacnt 

Approv- for public release; distribution unlimited 

1». OSTHBUTCN 00OE 


tt. AGSTHACT (UutnutOOmtrtt) 

Tartan Laboratories Incorporated, Tartan Ada Sun/C30 Version 2.2, Ottobrunn West Ge* 
Sun 3/60 (Host) to 320C30 on TI Application Board (Target), ACVC 1.10. 

r DT1C 

S electe 
JUN271990 

& E 


14.summer terms Ada programming language, Ada Compiler Validation 

Summary Report, Ada Compiler Validation Capability, Validation 
Testing, Ada Validation Office, Ada Validation Facility, ANSI/MIL- 
STD-1815A. Ada Joint Program Office 

1|.IM*E*0FRM*S 

MFWCtOOCE 

|iA 

*WiSRSK umLri 

UNCLASSIFIED 





















AVF Control Number: AVF-IABG -061 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: #89120511.10263 
TARTAN LABORATORIES INCORPORATED 
Tartan Ada Sun/C30 Version 2.2 
Sun 3/60 to 320C30 on TI Application Board 


! 

Completion of On-Site Testing: j 

5 December 1989 j 


I 


Prepared By: 
IABG rabH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 
Vest Germany 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 


•0 06 25 129 




Ada Compiler Validation Summary Report: 


Compiler Name: Tartan Ada Sun/C30 Version 2.2 

Certificate Number: #89120511.10263 

Host: Sun 3/60 under Sun OS 3.5 

Target: 320C30 on TI Application Board 

Testing completed 5 December 1989 using ACVC 1.10. 


This report has been reviewed and is approved. 




Dr. S. Heilbrunner 
IABG mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 
West Germany 


!.»r- 


Ada VaiTdap:$n/Organization 


Lj Dr. John F. 

Institute f 
1/ Alexandria 


for Defense Analyses 
VA 22311 


Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 


Accesiou For \ 

INTIS CRA.il 0 

DUO 1 Ab □ 

Uiijfinoii >ced Q 

JdStlhCdtOO ^ _ 

By_ 

Distribution / 

AvtHub'i. :v Codes 

i A'..ill .!■ 1 . cr 
I Dist i riueC'.il 





TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION . 1 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT .... 1 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.2 

1.3 REFERENCES.3 

1.4 DEFINITION OF TERMS . 3 

1.5 ACVC TEST CLASSES.4 

CHAPTER 2 CONFIGURATION INFORMATION . 7 

2.1 CONFIGURATION TESTED . 7 

2.2 IMPLEMENTATION CHARACTERISTICS . 3 

CHAPTER 3 TEST INFORMATION.13 

3.1 TEST RESULTS.13 

3.2 SUMMARY OF TEST RESULTS BY CLASS.13 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.14 

3.4 WITHDRAWN TESTS.14 

3.5 INAPPLICABLE TESTS . 14 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS . 13 

3.7 ADDITIONAL TESTING INFORMATION 

3.7.1 Prevalidation.19 

3.7.2 Test Method.19 

3.7.3 Test Site.20 


APPENDIX A DECLARATION OF CONFORMANCE 

APPENDIX B APPENDIX F OF THE Ada STANDARD 

APPENDIX C TEST PARAMETERS 

APPENDIX D WITHDRAWN TESTS 


APPENDIX E 


COMPILER AND LINKER OPTIONS 






















CHAPTER 1 


INTRODUCTION 




This Validation Summary Report (VSR) describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1315A. 
This report explains all technical terms 
reports the results of testing this 
Validation Capability (ACVC). An Ada 
according to the Ada Standard, and any implementation-dependent features 
roust conform to the requirements of the Ada Standard. The Ada Standard 
must be implemented in its entirety, and nothing can be implemented that is 
not in the Standard. 


used within it and thoroughly 
compiler using the Ada Compiler 
compiler must be implemented 


Even though all validated Ada compilers conform to the Ada Standard, it 
must be understood that some differences do exist between implementations. 
The Ada Standard permits some implementation dependencies—for example, the 
maximum length of identifiers or the maximum values of integer types. 
Other differences between compilers result from the characteristics of 
particular operating systems, hardware, or implementation strategies. All^ 
the dependencies observed during the process of testing this compiler are 
given in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. The purpose of validating is to ensure conformity 
of the compiler to the Ada Standard by testing that the compiler properly 
implements legal language constructs and that it identifies and rejects 
illegal language constructs. The testing also identifies behavior that is 
implementation dependent, but is permitted by the Ada Standard. Six 
classes of tests are used. These tests are designed to perform checks at 
compile time, at link time, and during execution. 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 

This VSR documents the results of the validation testing performed on an 
Ada compiler. Testing was carried out for the following purposes: 






INTRODUCTION 


To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

To attempt to identify any language constructs not supported by 
the compiler but required by the Ada Standard 

. To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by IABG mbH, Abt SZT according to 
procedures established by the Ada Joint Program Office and administered by 
the Ada Validation Organization (AVO). 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO may 
make full and free public disclosure of this report. In the United States, 
this is provided in accordance with the "Freedom of Information Act" 
(5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject compiler has no nonconformities 
to the Ada Standard other than those presented. Copies of this report are 
available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rra 3D—139 (Fern Street) 

Washington DC 20301-3081 

or from: 


IABG mbH, Abt SZT 
Einsteinstr 20 
D8012 Ottobrunn 

Questions regarding this report or the validation test results should be 
directed to the AVF listed above or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


2 





INTRODUCTION 


1.3 REFERENCES 


1. Reference Manual for the Ada Programming Language, 
ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines, Ada Joint 
Program Office, 1 January 1987. 

3. Ada Compiler Validation Capability Implementers' Guide, SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide, December 1986. 


1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to the 
Ada programming language. 

Ada An Ada Commentary contains all information relevant to the 

Commentary point addressed by a comment on the Ada Standard. These 

comments are given a unique identification number having the 
form Al-ddddd. 

Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

Applicant The agency requesting validation. 

AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines. 

AVO The Ada Validation Organization. The AVO has oversight 

authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and technical 
support for Ada validations to ensure consistent practices. 

Compiler A processor for the Ada language. In the context of this 

report, a compiler is any language processor, including 
cross-compilers, translators, and interpreters. 

Failed test An ACVC test for which the compiler generates a result that 

demonstrates nonconformity to the Ada Standard. 

Host The computer on which the compiler resides. 


3 







INTRODUCTION 


Inapplicable An ACVC test that uses features of the language that a 

test compiler is not required to support or may legitimately 

support in a way other than the one expected by the test. 

Passed test An ACVC test for which a compiler generates the expected 

result. 

Target The computer which executes the code generated by the 

compiler. 

Test A program that checks a compiler's conformity regarding a 

particular feature or a combination of features to the Ada 
Standard. In the context of this report, the term is used to 
designate a single test, which may comprise one or more 
files. 

An ACVC test found to be incorrect and not used to check 
conformity to the Ada Standard. A test may be incorrect 
because it has an invalid test objective, fails to meet its 
test objective, or contains illegal or erroneous use of the 
language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes: A, B, C, D, E, and L. The first letter of a test name identifies 
the class to which it belongs. Class A, C, D, and E tests are executable, 
and special program units are used to report their results during 
execution. Class B tests are expected to produce compilation errors. 
Class L tests are expected to produce errors because of the way in which a 
program library is used at link time. 

Class A tests ensure the successful compilation and execution of legal Ada 
programs with certain language constructs which cannot be verified at run 
time. There are no explicit program components in a Class A test to check 
semantics. For example, a Class A test checks that reserved words of 
another language (other than those already reserved in the Ada language) 
are not treated as reserved words by an Ada compiler. A Class A test is 
passed if no errors are detected at compile time and the program executes 
to produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is compiled and 
the resulting compilation listing is examined to verify that every syntax 
or semantic error in the test is detected. A Class B test is passed if 
every illegal construct that it contains is detected by the compiler. 


Withdrawn 

test 









INTRODUCTION 


Class C tests check the run time system to ensure that legal Ada programs 
can be correctly compiled and executed. Each Class C test is self-checking 
and produces a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when it is executed. 

Class D tests check the compilation and execution capacities of a compiler. 
Since there are no capacity requirements placed on a compiler by the Ada 
Standard for some parameters—for example, the number of identifiers 
permitted in a compilation or the number of units in a library—a compiler 
may refuse to compile a Class D test and still be a conforming compiler. 
Therefore, if a Class D test fails to compile because the capacity of the 
compiler is exceeded, the test is classified as inapplicable. If a Class D 
test compiles successfully, it is self-checking and produces a PASSED or 
FAILED message during execution. 

Class E tests are expected to execute successfully and check 
implementation-dependent options and resolutions of ambiguities in the Ada 
Standard. Each Class E test is self-checking and produces a NOT 
APPLICABLE, PASSED, or FAILED message when it is compiled and executed. 
However, the Ada Standard permits an implementation to reject programs 
containing some features addressed by Class E tests during compilation. 
Therefore, a Class E test is passed by a compiler if it is compiled 
successfully and executes to produce a PASSED message, or if it is rejected 
by the compiler for an allowable reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to 
execute. Class L tests are compiled separately and execution is attempted. 
A Class L test passes if it is rejected at link time—that is, an attempt 
to execute the main program must generate an error message before any 
declarations in the main program or any units referenced by the main 
program are elaborated. In some cases, an implementation may legitimately 
detect errors during compilation of the test. 

Two library units, the package REPORT and the procedure CHECK_FILE, support 
the self-checking features of the executable tests. The package REPORT 
provides the mechanism by which executable tests report PASSED, FAILED, or 
NOT APPLICABLE results. It also provides a set of identity functions used 
to defeat some compiler optimizations allowed by the Ada Standard that 
would circumvent a test objective. The procedure CHECK_FILE is used to 
check the contents of text files written by some of the Class C tests for 
Chapter 14 of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. These tests produce messages that 
are examined to verify that the units are operating correctly. If these 
units are not operating correctly, then the validation is not attempted. 

The text of each test in the ACVC follows conventions that are intended to 
ensure that the tests are reasonably portable without modification. For 
example, the tests make use of only the basic set of 55 characters, contain 
lines with a maximum length of 72 characters, use small numeric values, and 
tests. However, some tests contain values that require the test to be 







INTRODUCTION 


customized according to implementation-specific values—for example, an 
illegal file name. A list of the values used for this validation is 
provided in Appendix C. 


A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable to 
the implementation. The applicability of a test to an implementation is 
considered each time the implementation is validated. A test that is 
inapplicable for one validation is not necessarily inapplicable for a 
subsequent validation. Any test that was determined to contain an illegal 
language construct or an erroneous language construct is withdrawn from the 
ACVC and, therefore, is not used in testing a compiler. The tests 
withdrawn at the time of this validation are given in Appendix D. 





CONFIGURATION INFORMATION 


CHAPTER 2 

CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under the 
following configuration: 

Compiler: Tartan Ada Sun/C30 Version 2.2 
ACVC Version: 1.10 
Certificate Number: #89120511.10263 
Host Computer: 

Machine: Sun 3/60 

Operating System: Sun OS 3.5 

Memory Size: 8 MB 

Target Computer: 

Machine: 320C30 on TI Application Board 
Operating System: bare machine 

Memory Size: 512K x 32 bit words 


7 






2.2 IMPLEMENTATION CHARACTERISTICS 


One of the purposes of validating compilers is to determine the behavior of 
a compiler in those areas of the Ada Standard that permit implementations 
to differ. Class D and E tests specifically check for such implementation 
differences. However, tests in other classes also characterize an 
implementation. The tests demonstrate the following characteristics: 


a. Capacities. 

1) The compiler correctly processes a compilation containing 
723 variables in the same declarative part. (See test 
D29002K.) 

2) The compiler correctly processes tests containing loop 

statements nested to 65 levels. (See tests D55A03A..H (8 
tests).) 

3) The compiler correctly processes tests containing block 

statements nested to 65 levels. (See test D56001B.) 

4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 10 
levels. (See tests D64005E..G (3 tests).) 


b. Predefined types. 

1) This implementation supports the additional predefined type 
LONG_FLOAT in the package STANDARD. (See tests 386001T..Z (7 
tests) .) 


c. Expression evaluation. 

The order in which expressions are evaluated and the time at which 
constraints are checked are not defined by the language. Vhile 
the ACVC tests do not specifically attempt to determine the order 
of evaluation of expressions, test results indicate the following: 

1) None of the default initialization expressions for record 
components are evaluated before any value is 
checked for membership in a component's subtype. (See test 
C32117A.) 

2) Assignments for subtypes are performed with the same precision 
as the base type. (See test C35712B.) 






CONFIGURATION INFORMATION 


3) This implementation uses no extra bits for extra precision 
and uses all extra bits for ex.ra range. (See test C35903A.) 

4) NUHERIC_ERROR is raised when an integer literal operand in a 
comparison or membership test is outside the range of the base 
type. (See test C45232A.) 

5) No exception is raised when a literal operand in a fixed- 
point comparison or membership test is outside the range of 
the base type. (See test C45252A.) 

6) Underflow is not gradual. (See tests C45524A..Z (26 

tests).) 


d. Rounding. 

The method by which values are rounded in type conversions is not 
defined by the language. Vhile the ACVC tests do not specifically 
attempt to determine the method of rounding, the test results 
indicate the following: 

1) The method used for rounding to integer is round towards 
positive infinity . (See tests C46012A..Z (26 tests).) 

2) The method used for rounding to longest integer is round 
towards positive infinity. (See tests C46012A..Z (26 tests).) 

3) The method used for rounding to integer in static universal 
real expressions is round towards positive infinity. (See 
test C4A014A.) 


e. Array types. 

An implementation is allowed to raise NUMERIC_ERROR or 
CONSTRAINT ERROR for an array having a 'LENGTH that exceeds 
STANDARD.INTEGER'LAST and/or SYSTEM.MAX.INT. For this 

implementation: 

1) Declaration of an array type or subtype declaration with more 
than SYSTEM.MAX_INT components raises NUMERIC_ERROR for 
one dimensional array types and two dimensional array types , 
and no exception for one dimensional array subtypes and two 
dimensional array subtypes. (See test C36003A.) 

2) NUMERIC_ERROR is raised when an array type with 

INTEGER'LAST + 2 components is declared. (See test 

C36202A.) 


3 







3) NUMERICJ3RR0R is raised when an array type with 

SYSTEM.MAX_INT + 2 components is declared. (See test 

C36202B.) 

4) A packed BOOLEAN array having a 'LENGTH exceeding INTEGER'LAST 

raises NUMERIC_ERROR when the array type is declared. (See 

test C52103X.) 

5) A packed two-dimensional BOOLEAN array with more than 

INTEGER'LAST components raises NUMERIC_ERROR when the array 

type is declared and exceeds INTEGER’LAST. (See test 

C52104Y.) 

6) In assigning one-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 

7) In assigning two-dimensional array types, the expression is 
not evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is 
compatible with the target's subtype. (See test C52013A.) 


8) A null array with one dimension of length greater 
than INTEGER'LAST may raise NUMERIC_ERROR or CONSTRAINTJSRROR 
either when declared or assigned. Alternatively, an implemen¬ 
tation may accept the declaration. However, lengths must 
match in array slice assignments. This implementation raises 
NUMERIC ERROR when the array type is declared. (See 
test E52103Y.) 


f. Discriminated types. 

1) In assigning record types with discriminants, the expression 
is evaluated in its entirety before CONSTRAINT_ERROR is raised 
when checking whether the expression's subtype is compatible 
with the target's subtype. (See test C52013A.) 


g. Aggregates. 

1) In the evaluation of a multi-dimensional aggregate, the test 
results indicate that all choices are evaluated before 
checking against the index type. (See tests C43207A and 
C43207B.) 

2) In the evaluation of an aggregate containing subaggregates, 
not all choices are evaluated before being checked for 
identical bounds. (See test E43212B.) 


ID 













CONFIGURATION INFORMATION 


3) CONSTRAINT_ERROR is raised after all choices are 
evaluated when a bound in a non-null range of a non-null 
aggregate does not belong to an index subtype. (See test 

E43211B.) 


h. Pragmas. 

1) The pragma INLINE is supported for functions and 
procedures. (See tests LA3004A..B (2 tests), EA3004C..D (2 

tests), and CA3004E..F (2 tests).) 


i. Generics. 

This compiler enforces the following two rules concerning 
declarations and proper bodies which are individual compilation 
units: 

o generic bodies must be compiled and completed before their 
instantiation. 

o recompilation of a generic body or any of its transitive 
subunits makes all units obsolete which instantiate that 

generic body. 

These rules are enforced whether the compilation units are in 
separate compilation files or not. AI408 and AI506 allow this 
behaviour. 

1) Generic specifications and bodies can be compiled 

in separate compilations. (See tests CA1012A, CA2009C, 

CA2009F, BC3204C, and BC3205D.) 

2) Generic subprogram declarations and bodies can be 

compiled in separate compilations. (See tests CA1012A and 

CA2009F.) 

3) Generic library subprogram specifications and bodies can be 

compiled in separate compilations. (See test CA1012A.) 

4) Generic non-library package bodies as subunits can 

be compiled in separate compilations. (See test CA2009C.) 

5) Generic non-library subprogram bodies can be 
compiled in separate compilations from their stubs. (See test 
CA2009F.) 


6) Generic unit bodies and their subunits can be 
compiled in separate compilations. (See test CA3011A.) 


11 




CUNf I ijUKrtTiUN Hit UKiiA'l IUU 


7) 

Generic 

package declarations and 

bodies 

can be 


compiled 

in separate 

compilations. 

(See 

tests 

CA2009C, 


BC3204C, 

and BC3205D.) 





8) 

Generic 

library package 

specifications 

and 

bodies 

can be 


compiled 

in separate compilations. 

(See 

tests 


8C3204C 

and BC3205D.) 





9) 

Generic 

unit bodies 

and their 

subunits 

can be 


compiled 

in separate compilations. (See 

test 

CA3011A 

.) 


j. Input and output. 

1) The package SEQUENTIAL_IO can be instantiated with 

unconstrained array types and record types with 

discriminants without defaults. (See tests AE2101C, EE2201D, 

and EE2201E.) 

2) The package DIRECT_I0 can be instantiated with 

unconstrained array types and record types with 

discriminants without defaults. (See tests AE2101H, EE2401D, 

and EE2401G.) 

3) The director, AJPO, has determined (AI-00332) that every call 
to OPEN and CREATE must raise USEJSRROR or NAME_ERROR if file 
input/output is not supported. This implementation exhibits 
this behavior for SEQUENTIAL_IO, DIRECT_IO, and TEXT_IO. 






TEST INFORMATION 


CHAPTER 3 
TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 44 tests had been withdrawn because of test errors. The AVF 
determined that 619 tests were inapplicable to this implementation. 
All inapplicable tests were processed during validation testing except for 
285 executable tests that use floating-point precision exceeding 
that supported by the implementation, and for 238 executable tests 
that use file operations not supported by the implementation. 
Modifications to the codo, processing, or grading for 79 tests were 
required to successfully demonstrate the test objective. (See section 
3.6.) 


The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 

A 

B 

TEST 

C 

CLASS 

D 

E 

L 

TOTAL 

Passed 

129 

1128 

1719 

16 

16 

46 

3054 

Inapplicable 

0 

10 

596 

1 

12 

0 

619 

Withdrawn 

1 

2 

35 

0 

6 

0 

44 

TOTAL 

130 

1140 

2350 

17 

34 

46 

3717 







3.3 SUMMARY OF TEST RESULTS BY CHAPTER 


RESULT 

2 

3 

4 

5 

6 

CHAPTER 
7 8 

9 

10 

11 

12 

13 

14 

TOTAL 

Passed 

192 

547 

485 

242 

171 

99 

159 

332 

133 

36 

252 

330 

76 

3054 

N/A 

20 

102 

195 

6 

1 

0 

7 

0 

4 

0 

0 

39 

245 

619 

Wdrn 

1 

1 

0 

0 

0 

0 

0 

2 

0 

0 

1 

35 

4 

44 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 

The following 44 tests were withdrawn from ACVC Version 1.10 
at the time of this validation: 


E28005C 

A39005G 

B97102E 

C97116A 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A84N 

CD2A84M 

CD50110 

CD2B15C 

CD7205C 

CD2D11B 

CD5007B 

ED7004B 

ED7005C 

ED7005D 

ED7006C 

ED7006D 

CD7105A 

CE3301A 

CD7203B 

CE3411B 

CD7204B 

CD7205D 

CE2107I 

CE3111C 


See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of features 
that a compiler is not required by the Ada Standard to support. Others may 
depend on the result of another test that is either inapplicable or 
withdrawn. The applicability of a test to an implementation is considered 
each time a validation is attempted. A test that is inapplicable for one 
validation attempt is not necessarily inapplicable for a subsequent 
attempt. For this validation attempt, 619 tests were inapplicable for the 
reasons indicated: 

a. The following 285 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
SYSTEM.MAX_DIGITS: 

C24113F..Y {20 tests) C35705F..Y (20 tests) 

C35706F..Y (20 tests) C35707F..Y (20 tests) 


U 








TEST INFORMATION 


C35708F..Y (20 tests) 
C45241F..Y (20 tests) 
C45421F..Y (20 tests) 
C45524F..Z (21 tests) 
C45641F..Y (20 tests) 


C35802F..Z (21 tests) 
C45321F..Y (20 tests) 
C45521F..Z (21 tests) 
C45621F..Z (21 tests) 
C46012F..Z (21 tests) 


b. C35702A and B86001T are not applicable because this implementation 
supports no predefined type SHORT_FLOAT. 


c. 

The 

following 

16 tests 

are not 

applicable 

because this 


implementation 

does not support a predefined type 

SHORT_INTEGER: 



C45231B 

C45304B 

C45502B 

C45503B 

C45504B 



C45504E 

C45611B 

C45613B 

C45614B 

C45631B 



C45632B 

CD7101E 

B52004E 

C55B07B 

B55B09D 

B86001V 

d. 

The 

following 

16 tests 

are not 

applicable 

because this 


implementation 

does not support a predefined type 

LONG_INTEGER: 



C45231C 

C45304C 

C45502C 

C45503C 

C45504C 



C45504F 

C45611C 

C45613C 

C45614C 

C45631C 



C45632C 

CD7101F 

B52004D 

C55B07A 

B55B09C 

B86001W 

e. 

C45531M..P (4 

tests) and 

C45532M..P 

(4 tests) are 

: not applicable 


because the value of SYSTEM.MAX_MANTISSA is less than 32. 

f. D64005G is not applicable because this implementation does not 
support nesting 17 levels of recursive procedure calls. 

g. C86001F is not applicable because, for this implementation, the 
package TEXT_IO is dependent upon package SYSTEM. This test re¬ 
compiles package SYSTEM, making package TEXT_IO, and hence 
package REPORT, obsolete. 

h. B86001X, C45231D, and CD7101G are not applicable because this 

implementation supports no predefined integer type with a name 
other than INTEGER, LONG_INTEGER, or SHORT_INTEGER. 

i. B86001Y is not applicable because this implementation supports no 
predefined fixed-point type other than DURATION. 

j. B86001Z is not applicable because this implementation supports no 
predefined floating-point type with a name other than FLOAT, 
LONG_FLOAT, or SHORT_FLOAT. 

k. CA2009A, CA2009C, CA2009F and CA2009D are not applicable because 

this compiler creates dependencies between generic bodies, and 
units that instantiate them (see section 2.21 for rules and 
restrictions concerning generics). 


15 











Ifiil ll'Jf UKWAIiUW 


l. CD1009C, CD2A41A..E (5 tests), and CD2A42A..J (10 tests) are not 
applicable because this implementation imposes restrictions on 
'SIZE length clauses for floating point types. 

m. CD2A61E, CD2A61G, and CD2A61I are not applicable because this 
implementation imposes restrictions on 'SIZE length clauses for 
array types. 


n. CD2A84B..I (8 tests) and CD2A84K..L (2 tests) are not applicable 
because this implementation imposes restrictions on 'SIZE length 
clauses for access types. 

o. CD2A91A..E (5 tests) are not applicable because 'SIZE length 
clauses for task types are not supported. 

p. CD2B11G is not applicable because 'STORAGE_SIZE representation 
clauses are not supported for access types where the designated 
type is a task type. 

q. CD2B15B is not applicable because a collection size larger than 
the size specified was allocated. 

r. The following 238 tests are inapplicable because sequential, text, 
and direct access files are not supported: 


CE2102A..C 

(3 

tests) 

CE2102G..H 

(2 

tests) 

CE2102K 



CE2102N..Y 

(12 

; tests) 

CE2103C..D 

(2 

tests) 

CE2104A..0 

(4 

tests) 

CE2105A..B 

(2 

tests) 

CE2106A..B 

(2 

tests) 

CE2107A..H 

(8 

tests) 

CE2107L 



CE2108A..B 

(2 

tests) 

CE2108C..H 

(6 

tests) 

CE2109A..C 

(3 

tests) 

CE2110A..D 

(4 

tests) 

CE2111A..I 

(9 

tests) 

CE2115A..B 

(2 

tests) 

CE2201A..C 

(3 

tests) 

CE2201F..N 

(9 

tests) 

CE2204A..D 

(4 

tests) 

CE2205A 



CE2208B 



CE2401A..C 

(3 

tests) 

CE2401E. .F 

(2 

tests) 

CE2401H..L 

(5 

tests) 

CE2404A..8 

(2 

tests) 

CE2405B 



CE2406A 



CE2407A..B 

(2 

tests) 

CE2408A..B 

(2 

tests) 

CE2409A..B 

(2 

tests) 

CE2410A..B 

(2 

tests) 

CE2411A 



CE3102A..B 

(2 

tests) 

EE3102C 



CE3102F..H 

(3 

tests) 

CE3102J ..K 

(2 

tests) 

CE3103A 



CE3104A..C 

(3 

tests) 

CE3107B 



CE3108A..B 

(2 

tests) 

CE3109A 



CE3110A 



CE3111A..B 

(2 

tests) 

CE31110..E 

(2 

tests) 

CE3112A..D 

(4 

tests) 

CE3114A..B 

(2 

tests) 

CE3115A 



EE3203A 




16 












CE3208A 



EE3301B 



CE3302A 



CE3305A 



CE3402A 



EE3402B 



CE3402C..D 

(2 

tests) 

CE3403A..C 

(3 

tests) 

CE3403E..F 

(2 

tests) 

CE3404B. .D 

(3 

tests) 

CE3405A 



EE3405B 



CE3405C. .D 

(2 

tests) 

CE3406A..D 

(4 

tests) 

CE3407A..C 

(3 

tests) 

CE3408A..0 

(3 

tests) 

CE3409A 



CE3409C..E 

(3 

tests) 

EE3409F 



CE3410A 



CE3410C..E 

(3 

tests) 

EE3410F 



CE3411A 



CE3411C 



CE3412A 



EE3412C 



CE3413A 



CE3413C 



CE3602A..D 

(4 

tests) 

CE3603A 



CE3604A..B 

<2 

tests) 

CE3605A..E 

(5 

tests) 

CE3606A..B 

(2 

tests) 

CE3704A..F 

(6 

tests) 

CE3704M..0 

(3 

tests) 

CE3706D 



CE3706F..G 

(2 

tests) 

CE3804A..P 

(16 

1 tests) 

CE3805A..B 

(2 

tests) 

CE3806A..B 

(2 

tests) 

CE3806D..E 

(2 

tests) 

CE3806G..H 

(2 

tests) 

CE3905A..C 

(3 

tests) 

CE3905L 



CE3906A..C 

(3 

tests) 

CE3906E..F 

(2 

tests) 


These tests were not processed because their inapplicability can 
be deduced from the result of other tests. 

s. Tests CE2103A..B (2 tests) and CE3107A raise USE_ERROR although 
NAME_ERROR is expected. These tests report FAILED but they were 
graded not applicable because this implementation does not support 
permanent files. 

t. EE2201D, EE2201E, EE2401D, EE2401G are inapplicable because 

sequential, text, and direct access files are not supported. 


17 













* -- riwi. 


3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases where 
legitimate implementation behavior prevents the successful completion of an 
(otherwise) applicable test. Examples of such modifications include: 
adding a length clause to alter the default size of a collection; splitting 
a Class B test into subtests so that all errors are detected; and 
confirming that messages produced by an executable test demonstrate 
conforming behavior that was not anticipated by the test (such as raising 
one exception instead of another). 

Modifications were required for 79 tests. 

a. The following tests were split because syntax errors at one point 
resulted in the compiler not detecting other errors in the test: 


B22003A 

B24007A 

B24009A 

B25002B 

B32201A 

334005N 

B34005T 

B34007H 

B35701A 

B36171A 

B3S201A 

B37101A 

B37102A 

B37201A 

B37202A 

B37203A 

B37302A 

B38003A 

B38003B 

B38008A 

B38003B 

B38009A 

B33009B 

B38103A 

B38103B 

B38103C 

B38103D 

B38103E 

B43202C 

B44002A 

B48002A 

B48002B 

B48002D 

B48002E 

B48002G 

B43003E 

B49003A 

B49005A 

B49006A 

349007A 

B49009A 

B4A010C 

B54A20A 

B54A25A 

B58002A 

B58002B 

B59001A 

B59001C 

B59001I 

B62006C 

B67001A 

B67001B 

B67001C 

B67001D 

B74103E 

B74104A 

B85007C 

B91005A 

B95003A 

B95007B 

B95031A 

B95074E 

BC1002A 

BC1109A 

BC1109C 

BC1206A 

BC2001E 

BC3005B 

BC3009C 

BD5005B 




b. For the two tests BC3204C and BC3205D, the compilation order was 
changed to 

BC3204C0, Cl, C2, C3M, C4, C5, C6, C3M 

and 

BC3205D0, D2, DIM 

respectively. This change was necessary because of the compiler's 
rules for separately compiled generic units (see section 2.2i for 
rules and restrictions concerning generics). When processed in 
this order the expected error messages were produced for BC3204C3H 
and BC3205D1M. 

c. The two tests BC3204D and 3C3205C consist of several compilation 
units each. The compilation units for the main procedures are 
near the beginning of the files. When processing these files 
unchanged, a link error is reported instead of the expected 
compiled generic units. Therefore, the compilation files were 
modified by appending copies of the main procedures to the end of 


1 .5 






TEST INFORMATION 


these files. When processed, the expected error messages were 
generated by the compiler. 

d. Tests C39005A, CD7004C, CD7005E and CD7006E wrongly presume an 

order of elaboration of the library unit bodies. These tests were 
modified to include a PRAGMA ELABORATE (REPORT); 

e. Test E28002B checks that predefined or unrecognized pragmas may 
have arguments involving overloaded identifiers without enough 
contextual information to resolve the overloading. It also checks 
the correct processing of pragma LIST. For this implementation, 
pragma LIST is only recognised if the compilation file is compiled 
without errors or warnings. Hence, the test was modified to 
demonstrate the correct processing of pragma LIST. 


For this implementation, the required support package specification, 
SPPRT13SP, was rewritten to provide constant values for the function names. 


3.7 ADDITIONAL TESTING INFORMATION 

3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 produced 
by the Tartan Ada Sun/C30 Version 2.2 compiler was submitted to the AVF 
by the applicant for review. Analysis of these results demonstrated that 
the compiler successfully passed all applicable tests, and the 
compiler exhibited the expected behavior on all inapplicable tests. 

3.7.2 Test Method 

Testing of the Tartan Ada Sun/C30 Version 2.2 compiler using ACVC 
Version 1.10 was conducted by IABG on the premises of TARTAN. The 
configuration in which the testing was performed is described by the 
following designations of hardware and software components: 

Host Computer: 

Machine: Sun 3/60 

Operating System: Sun OS 3.5 

Memory Size: 8 MB 


Target Computer: 

Machine: 320C30 on TI Application Board 
Operating System: bare machine 

Memory Size: 512K x 32 bit words 

Compiler: 

Tartan Ada Sun/C30 Version 2.2 







TEST TNr UKnAiIUN 


The original ACVC was customized prior to the validation visit in order to 
remove all withdrawn tests, inapplicable I/O tests and tests requiring 
unsupported floating point precisions. Tests that make use of 
implementation specific values were also customized. Tests requiring 
modifications during the prevalidation testing were modified accordingly. 

A tape containing the customized ACVC was read by the host computer. 

After the test files were loaded to disk, the full set of tests was 
compiled and linked. All executable tests were transferred via an RS232 
line to the target computer where they were run. Results were transferred 
to the host computer in the same way, where they were evaluated and 
archived. 

The compiler was tested using command scripts provided by TARTAN 
LABORATORIES INCORPORATED and reviewed by the validation team. The 
compiler was tested using no option settings. All chapter B tests were 
compiled with the listing option on (i.e. -La). The linker was called with 
the command 

alib link <testname> 

The compiler was called with the command 
tada -q <testname> 


3.7.3 Test Site 

Testing was conducted at TARTAN LABORATORIES INCORPORATED, Pittsburgh and 
was completed on 5 December 1989. 


20 










APPENDIX A 

DECLARATION OF CONFORMANCE 


TARTAN LABORATORIES INCORPORATED has submitted the following 
Declaration of Conformance concerning the Tartan Ada Sun/C30 
Version 2.2 compiler. 




DECLARATION OF CONFORMANCE 

Compiler Implementor: Tartan Laboratories Incorporated 

Ada Validation Facility: IABG mbH, Dept. SZT 

Ada Compiler Validation Capability (ACVC) Version: l.io 


Base Configuration 

Base Compiler Name: Tartan Ada Sun/C30 

Base Compiler Version: Version 2.2 

Host Computer: Sun 3/60 under Sun OS 3.5 

Target Computer: 320C30 on TI Application Board (bare target) 

Implementor's Declaration 

I, the undersigned, representing Tartan Laboratories Incorporated, 
have implemented no deliberate extensions to the Ada Language 
Standard ANSI/MIL-STD-1815A in the compiler(s) listed in this 
declaration. I declare that Tartan Laboratories Incorporated is the 
owner of record of the Ada Language compiler(s) listed above and, as 
such, is responsible for maintaining said compiler(s) in conformance 
to ANSI/MIL-STD-1815A. All certificates and registrations for Ada 
Language compiler(s) listed in this declaration shall be made only in 
the owner's corporate name. 

-7 ^ 


Owner's Declaration 

I, the undersigned, representing Tartan Laboratories Incorporated, 
take full responsibility for implementation and maintenance of the 
Ada com-piler(s) listed above, and agree to the public disclosure of 
the final Validation Summary Report. I declare that all of the Ada 
Language compilers listed, and their host/target performance, are in 

ANSI/MIL-STD-1815A. 

_~7 £f _ 

Tartan Laboratories Incorporated 
D. L. Evans, President 


compliance with the Ada Language Standard 


Date: 




Date: 


Tartan Laboratories Incorporated 
D. L. Evans, President 









APPENDIX B 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies corres¬ 
pond to implementation-dependent pragmas, to certain machine- 
dependent conventions as mentioned in chapter 13 of the Ada Stan¬ 
dard, and to certain allowed restrictions on representation 
clauses. The implementation-dependent characteristics of the 
Tartan Ada Sun/C30 Version 2.2 compiler, as described in this 
Appendix, are provided by TARTAN LABORATORIES INCORPORATED. 
Unless specifically noted otherwise, references in this appendix 
are to compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which 
are not a part of Appendix F, are: 

package STANDARD is 


type INTEGER is range — 2 141 4 33 5 43 .. 2 14 V 433 64T; 

type FLOAT is digits 6 range -16#0.1000_00#E+33 .. 
16#0.FFF?_FF»E+32; 

type LONG FLOAT is digits 3 range 
-16§0.1000_0000_0#E+33 .. 15*0.FFFF_FFFF_0«E+32; 

type DURATION is delta 0.0001 range -86400.0 .. 36400.0; 


end STANDARD; 







Chapter 5 

Appendix F to MIL-STD-1815A 


This chapter contains the required Appendix F to Military Standard ., Ada Programming Language, 

ANSI/MEL-STD-1815A (American National Standards Institute, Inc., February 17, 1983). 

5 . 1 . PRAGMAS 

5.1.1. Predefined Pragmas 

This section summarizes the effects of and restrictions on predefined pragmas. 

• Access collections are not subject to automatic storage reclamation so pragma CONTROLLED has no effect. 
Space deallocated by means of UNCHECXED_DEALLOCATION will be reused by the allocation of new 
objects. 

• Pragma ELABORATE is supported. 

• Pragma INLINE is supported. 

• Pragma INTERFACE is now supported. Hie language_name is ignored by the compiler that is. the 
standard Ada calling convention is used for every call to a subprogram to which this pragma is applied. 

• Pragma LIST is supported but has the intended effect only if the command qualifier LIST*ALWAYS was 
supplied for compilation, and the listing generated was not due to the presence of errors and/or warnings. 

• Pragma MEMORY_SIZE is accepted but no value other than that specified in Package SYSTEM (Section 

5.3) is allowed. 

• Pragma OPTIMIZE is supported except when at the outer level (that is, in a package specification or 
body). 

• Pragma pack is fully supported. 

• Pragma PAGE is supported but has the intended effect only if the command qualifier list-always was 
supplied for compilation, and the listing generated was not due to the presence of errors and/or warnings. 

• Pragma PRIORITY is supported. 

• Pragma STORAGE_UNIT is accepted but no value other than that specified in Pxkage SYSTEM (Section 

5.3) is allowed. 

• SHARED is not supported. No warning is issued if it is supplied. 

• Pragma SUPPRESS is supported. 

• Pragma SYSTEM_NAME is accepted but no value other than that specified in Package SYSTEM (Section 

5.3) is allowed. 

5.1.2. Implementation-Defined Pragmas 

Implementation-defined pragmas provided by Tartan are described in the following secuons. 


5-1 






USER MANUAL FOR TARTAN ADA VMS C30 


5.12.1. Pragma L INKAG E_NAME 

The pragma LINKAGE_NAME associates an Ada entity with a string that is meaningful externally; e.g., to a 
linkage editor. It takes the form 

pragma LINKAGE_NAME (Ada-simple-name, string-constant) 

The Ada-simple-name must be the name of an Ada entity declared in a package specification. This entity must be 
one that has a runtime representation; e.g., a subprogram, exception or object It may not be a named number «r 
string constant The pragma must appear after the declaration of the entity in the same package specification. 

The effect of the pragma is to cause the string-constant to be used in the generated assembly code as an 
external name for the associated Ada entity. It is the responsibility of the user to guarantee that this string 
constant is meaningful to the linkage editor and that no illegal linkname clashes arise. 

This pragma has no effect when applied to a library subprogram or to a renames declaration; in the latter case, 
no warning message is given. 

When determining the maximum allowable length for the external linkage name, keep in mind that the 
compiler will generate names for elaboration flags simply by appending the suffix #GOTO. Therefore, the 
external linkage name has 5 fewer significant characters than the lower limit of other tools that need to process 
the name (e.g., 40 in the case of the Tartan Linker). 

5.122. Pragma F0REIGN_30DY 

In addition to Pragma interface. Tartan Ada supplies Pragma F0REIGN_30DY as a way to access 
subprograms in other languages. 

Unlike Pragma INTERFACE, Pragma FOREIGN_BODY allows access to objects and exceptions (in addition 
to subprograms) to and from other languages. 

Some restrictions on Pragma FQREIGN_BODY that are not applicable to Pragma INTERFACE are: 

• Pragma F0REIGN_30DY must appear in a top-level non-generic package specification. 

• All objects, exceptions and subprograms in such a package must be supplied by a foreign object module. 

• Types may not be declared in such a package. 

Use of the pragma F0REIGN_3ODY dicutes that all subprograms, exceptions and objects in the package are 
provided by means of a foreign object module. In order to successfully link a program including a foreign body, 
the object module for that body must be provided to the library using the ALBC30 foreign_ 30DY command 
described in Section 4.7. 

The pragma is of the form: 

pragma FOR£IGN_BODY (languagejiame [, elaboration_routine_name\) 

The parameter language_name is a string intended to allow the compiler to identify the calling convention used 
by the foreign module (but this functionality is not yet in operation). Currently, the programmer must ensure that 
the calling convention and data representation of the foreign body procedures are compatible with those used by 
the Tartan Ada compiler. Subprograms called by tasks should be reentrant. 

The optional elaboration joutinejiame string argument provides a means to initialize the package. The 
routine specified as the elaboration joutine_name, which will be called for the elaborauon of this package body, 
must be a global routine in the object module provided by the user. 

A specification that uses this pragma may contain only subprogram declarations, object decorations that use 
an unconstrained type mark, and number declarations. Pragmas may also appear in the package. The type mark 
for an object cannot be a task type, and the object declaration must not have an initial value expression. The 
pragma must be given prior to any declarations within the package specification. If the pragma is not located 
before the first declaration, or any restriction on the declarauons is violated, the pragma is ignored and a warning 
is generated. 

The foreign body is entirely responsible for initializing objects declared in a package utilizing pragma 
F0REIGN_30DY. In particular, the user should be aware that the implicit initializations described in LRM 3.2.1 
are not done by the compiler. (These implicit initializations are associated with objects of access types, certain 
record types and composite types containing components of the preceding kinds of types.) 


5-2 







APPENDIX F TO MIL-STD-1815A 


Pragma LINKAGE_NAME should be used for all declarations in the package, including any declarations in a 
nested package specification to be sure that there are no conflicting link names. If pragma linkage_name is 
not used, the cross-reference qualifier, / CROSS_REFERENCE, (see Section 3.2) should be used when invoking 
tl~ compiler and the resulting cross-reference table of linknames inspected to identify the linknames assigned by 
the compiler and determine that there are no conflicting linknames (see also Section 3.3). 

In the following example, we want to call a function plain which computes polynomials and is written in C. 

package MATH_FUNCS is 

pragma F0REIGN_30DY ("C"); 

function POLYNOMIAL tX: INTEGER) return INTEGER; 

—Ada spec matching the C routine 
pragma LINKAGE_NAME (POLYNOMIAL, ••plain'*); 

—Force compiler to use name "plain" when referring to this 
— function 
end MATH_FUNCS; 

with MATHJFUNCS; use MATH_FUNCS 
procedure MAIN is 

X:INTEGER POLYNOMIAL(10) ; 

— Will generate a call to ’’plain" 
begin . . . 
end MAIN; 

To compile, link and run the above program, you do the following steps: 

1. Compile MATH_FUNCS 

2. Compile MAIN 

3. Obtain an object module (e.g. math. TOF) containing the compiled code for plain. 

4. Issue the command 

ALEC30 F0REIGN_30DY math_funcs MATH.TOF 

5. Issue the command 

ALBC30 LINK MAIN 

Without Step 4, an attempt to link will produce an error message informing you of a missing package body for 
MATH_FUNCS. 

Using an Ada body from another Ada program library. The user may compile a body written in Ada for a 
specification into the library, regardless of the language specified in the pragma contained in the specification. 
This capability is useful for rapid prototyping, where an Ada package may serve to provide a simulated response 
for the functionality that a foreign body may eventually produce. It also allows the user to replace a foreign body 
with an Ada body without recompiling the specification. 

The user can either compile an Ada body into the library, or use the command AL3C30 F0R£IGN_30DY 
(See Section 4.7) to use an Ada body from another library. The Ada body from another library must have been 
compiled under an identical specification. The pragma LINKAGE_NAME must have been applied to all endues 
declared in the specification. The only way to specify the linkname for the elaboration routine of an Ada body is 
with the pragma F0REIGN_30DY. 

Using Calls to the Operating System. In some cases, the foreign code is actually supplied by the operating 
system (in the case of system calls) or by runtime libraries for other programming languages such as C. Such 
calls may be made using a dummy procedure to supply a file specification to the AL3C3 0 FCREIGN_3CDY 
command. You need a dummy . TOF file which may be obtained in a number of wavs. One way is to compile 
the procedure - 

procedure DUMMY is 
begin 
null; 
end; 

Then, use the library command 


5-3 





USER MANUAL FOR TARTAN ADA VMS GO 


AL3C30 FOREIGN pkg DUMMY.TOF 

where pkg is the name of the package that contains the pragma linkage_name for the operating system calL 
For example to use the VMS system service LI3SGET_VM in the program TEST: 

Package memory is 

pragma FOREIGN SODY ("ASM") ; 
procedure GET_vFRTUAL_M£MORY(MEM:INTEGER) ; 
pragma LINKAGE_NAM£ (GET_VIRTUAL_MEMORY, "LIBSGETJ/M '*); 
end MEMORY; 

with MEMORY; 
procedure TEST is 


begin 

GET_VIRTUAL_MEMORY(MEM); 
end TEST; 


Obtain the file dummy. TOF. Then use 

ALBC30 FOREIGN pkg DUMMY.TOF 
to include the body for the system call in the library. 


5.2. IMPLEMENTATION-DEPENDENT ATTRIBUTES 

No implementation-dependent attributes are currently supported. 


5J. SPECIFICATION OF THE PACKAGE SYSTEM 

The parameter values specified for the TT320C30 target in package SYSTEM [LRM 13.7.1 and Annex C] are: 

package SYSTEM is 

type ADDRESS is new INTEGER; 
type NAME is (TI320C30); 

SYSTEM NAME : constant NAME TI320C3Q; 

STORAGE UNIT : constant 32; 

MEMORY_SIZE : constant : - 1S_777 216; 

MAX_INT : constant :- 2 147 '463 647; 

MIN_INT : constant : - -MAX_INT - 1; 

MAX_DIGITS : constant : - 9; ~ 

MAX_MANTIS 5A : constant : - 31; 

FINE__DELTA : constant 2#1.0#e-31; 

TICK~ : constant :- 0.0001; 

subtype PRIORITY is INTEGER range 10 .. 100; 

DEFAULT PRIORITY : constant PRIORITY PRIORITY'FIRST; 

RUNTIME'eRROR : exception; 

end SYSTEM ~ 


5.4. RESTRICTIONS ON REPRESENTATION CLAUSES 

The following sections explain the basic restrictions for representation specifications followed by additional 
restrictions applying to specific kinds of clauses. 


5-4 









APPENDIX FTO MEL-STD-1815A 


5.4.1. Basic Restriction 

The basic restriction on representation specifications [LRM 13.1] that they may be given only for types 
declared in terms of a type definition, excluding a generic_type_definition (LRM 12.1) and a 
private_type_def inition (LRM 7.4). Any representation clause in violation of these rules is not obeyed 
by the compiler; a diagnostic message is issued. 

Further restrictions are explained in the following sections. Any representation clauses violating those restric¬ 
tions are not obeyed but cause a diagnostic message to be issued. 

5.42. Length Clauses 

Length clauses [LRM 13.2] are, in general, supported. For details, refer to the following sections. 

5.42.1. Size Specifications for Types 

The rules and restrictions for size specifications applied to types of various classes are described below. 

The following principle rales apply: 

1. The size is specified in bits and must be given by a static expression. 

2. The specified size is taken as a mandate to store objects of the type in the given size wherever feasible. 
No attempt is made to store values of the type in a smaller size, even if possible. The following rales 
apply with regard to feasibility: 

• An object that is not a component of a composite object is allocated with a size and alignment that 
is referable on the target machine: that is, no attempt is made to create objects of non-referable size 
on the stack. If such stack compression is desired, it can be achieved by the user by combining 
multiple stack variables in a composite object: for example 

type My_Enum is (A,3); 
for My_enum'size use 1; 

V,W: My_enum; — will occupy two storage 

— units on the stack 

— (if allocated at all) 
type rec is record 

V,W: My_enum; 
end record; 
pragma Pack(rec); 

0: rec; — will occupy one storage unit 

• A formal parameter of the type is sized according to calling convenuons rather than size 
specifications of the type. Appropriate size conversions upon parameter passing take place 
automatically and are transparent to the user. 

• Adjacent bits to an object that is a component of a composite object, but whose size is 
non-referable. may be affected by assignments to the object, unless these bits are occupied by other 
components of the composite object: that is. whenever possible, a component of non-referable size 
is made referable. 

In all cases, the compiler generates correct code for all operations on objects of the type, even if they are 
stored with differing representational size in different contexts. 

Note: A size specification cannot be used to force a certain size in value operauons of the type: for 
example 

type mv_int is range 0..65535; 
for my_inc'3ize use 16; — o.k. 

A,3: my_int; 

. . .A~+- B. . . — this operation will generally be 
— executed on 32-bit values 


5-5 








USER MANUAL FOR TARTAN ADA VMS C30 


3. A size specification for a type specifies the size for objects of this type and of ail its subtypes. For 
components of composite types, whose subtype would allow a shorter representation of the component, 
no attempt is made to take advantage of such shorter representations. In contrast, for types without a 
length clause, such components may be represented in a lesser number of bits than the number of bits 
required to represent ail values of the type. Thus, in the example 

type MY INT is range 0..2**15-1; 
for MY_TNT'SIZE use 16; — (1) 
subtype SMALL_MY_INT is MY_INT range 0..255; 
type R is record 

X: SMALL_MY_INT; 
end record; 

the component R.X will occupy 16 bits. In the absence of the length clause at (1), R.X may be represented 
in 8 bits. 

For the following type classes, the size specification must coincide with the default size chosen by the compiler 
for the type: 

• access types 

• floating-point types 

• task types 

No useful effect can be achieved by using size specifications for these types. 

5.42.2. Size Specification for Scalar Types 

The specified size must accommodate all possible values of the type including the value 0 (even if 0 is not in 
the range of the values of the type). For numeric types with negative values the number of bits must account for 
the sign biL No skewing of the representation is auempted. Thus 
Type ny_mt 13 range 100.. 101; 
requires at least 7 bits, although it has only two values, while 
type my_int is range -101..-100; 
requires 8 bits to account for the sign bit. 

A size specificauon for a real type does not affect the accuracy of operations on the type. Such influence 
should be exerted via the accuracy_defini.ci.on of the type fLRM 3.5.7. 3.5.9). 

A size specificauon for a scalar type may not specify a size larger than the largest operation size supported by 
the target architecture for the respective class of values of the type. 

5.422. Size Specification for Array Types 

A size specification for an array type must be large enough to accommodate all components of the array under 
the densest packing strategy explained below in adherence to any alignment constraints on the component type 
(see Secuon 5.4.7). 

The size of the component type cannot be influenced by a length clause for an array. Within the limits of 
representing all possible values of the component subtype (but not necessarily of its type), the representauon of 
components may, however, be reduced to the minimum number of bits, unless the component type carries a size 
specification. 

If there is a size specificauon for the component type, but not for the array type, the component size is 
rounded up to a referable size, unless pragma PACK is given. This applies even to boolean types or other types 
that require only a single bit for the representation of all values. 


5-6 








APPENDIX F TO MIL STD-1815A 


5.42.4. Size Specification for Record Types 

A size specification few a record type does not influence the default type mapping of a record type. The size 
must be at least as large as the number of bits determined by type mapping. Influence over packing of com¬ 
ponents can be exerted by means of (partial) record representation clauses or by Pragma pack. 

Neither the size of component types, nor the representation of component subtypes can be influenced by a 
length clause for a record. 

The only implementation-dependent components allocated by Tartan Ada in records contain dope information 
for arrays whose bounds depend on discriminants of the record or contain relative offsets of components within a 
record layout for record components of dynamic size. These implementauon-dependent components cannot be 
named or sized by the user. 

A size specification cannot be applied to a record type with components of dynamically determined size. 

Note: Size specifications for records can be used only to widen the representation accomplished by padding at 
the beginning or end of the record. Any narrowing of the representauon over default type mapping must be 
accomplished by representation clauses or pragma ?ACX. 

5.42 J. Specification of Collection Sizes 

The specification of a collection size causes the collection to be allocated with the specified size. It is 
expressed in storage units and need not be static; refer to package SYSTEM for the meaning of storage units. 

Any attempt to allocate more objects than the collection can hold causes a STORAGE_ERROR exception to be 
raised. Dynamically sized records or arrays may carry hidden admmisuauve storage requirements that must be 
accounted for as part of the collection size. Moreover, alignment constraints on the type of the allocated objects 
may make it impossible to use all memory locations of the allocated collection. Furthermore, some administra¬ 
tive overhead for the allocator must be taken into account by the user (currently 1 word per allocated object). 

In the absence of a specification of a collection size, the collection is extended automatically if more objects 
are allocated than possible in the collection originally allocated with the compiler-established default size. In this 
case, STC RAGE_E rro R is raised only when the available target memory is exhausted. If a collection size of 
zero is specified, no access collection is allocated. 

5.42.6. Specification of Task Activation Size 

The specification of a task activation size causes the task acuvation to be allocated with the specified size. It 
is expressed in storage units; refer to package SYSTEM for the meaning of storage units. 

Any attempt to exceed the activation size during execution causes a 5TCRAGE_ERROR exception to be 
raised. Unlike collections, there is generally no extension of task activations. 

5.42.7. Specification of' SMALL 

Only powers of 2 are allowed for' SMALL. 

The length of the representation may be affected by this specification. If a size specification is also given for 
the type, the size specification takes precedence: the specification of ' SMALL must then be accommodatable 
within the specified size. 

5.4.3. Enumeration Representation Clauses 

For enumeration representauon clauses (LRM 13.3], the following restncuons apply: 

• The internal codes specified for the literals of the enumeration type may be any integer value between 
INTEGER' FIRST and INTEGER' LAST. It is strongly advised to not provide a representauon clause that 
merely duplicates the default mapping of enumcrauon types, which assigns consecuuve numbers in as¬ 
cending order starting with 0, since unnecessary runume cost is incurred by such duplication. It should be 
noted that the use of attributes on enumeration types with user-specified encodings is cosily at run ume. 

• Array types, whose index type is an enumeration type with non-contiguous value encodings, consist of a 
contiguous sequence of components. Indexing into the array involves a runume translation of the index 
value into the corresponding position value of the enumeration type. 


5-7 






USER MANUAL FOR TARTAN ADA VMS <20 


5.4.4. Record Representation Clauses 

The alignment clause of record representation clauses [LRM 13.4] is observed. The specified expression 
must yield a target-dependent value. 

Static objects may be aligned at powers of 2 up to a page boundary. The specified alignment becomes the 
minimum alignment of the record type, unless the minimum alignment of the record forced by the component 
allocation and the minimum alignment requirements of the components is already more stringent than the 
specified alignmenL 

The component clauses of record representation clauses are allowed only for components and discriminants 
of statically determinable size. Not all components need to be present Component clauses for components of 
variant parts are allowed only if the size of the record type is statically determinable for every variant 

The size specified for each component must be sufficient to allocate all possible values of the component 
subtype (but not necessarily the component type). The location specified must be compatible with any alignment 
constraints of the component type; an alignment constraint on a component type may cause an implicit alignment 
constraint on the record type itself. 

If some, but not all, discriminants and components of a record type are described by a component clause, then 
the discriminants and components without component clauses are allocated after those with component clauses; 
no attempt is made to utilize gaps left by the user-provided allocation. 

5.4.5. Address clauses 

Address clauses [LRM 13.5] are supported with the following restrictions: 

• When applied to an object an address clause becomes a linker directive to allocate the object at the given 
address. For any object not declared immediately within a top-level library package, the address clause is 
meaningless. Address clauses applied to local packages are not supported by Tartan Ada. Address clauses 
applied r. library packages are prohibited by the syntax: therefore, an address clause can be applied only to 
a package if it is a body stub. 

• Address clauses applied to subprograms and tasks are implemented according to the LRM rales. When 
applied to an entry, the specified value identifies an interrupt in a manner customary for the target. 
Immediately after a task is created, a runtime call is made for each of its entries having an address clause, 
establishing the proper binding between the entry and the interrupt. 

• Specified addresses must be static. 


5.4.6. Pragma PACK 

Pragma pack [LRM 13.1] is supported. For details, refer to the following sections. 

5.4.6.1. Pragma PACK for Arrays 

If pragma pack is applied to an array, the densest possible representauon is chosen. For details of packing, 
refer to the explanation of size specificauons for arrays (Section 5.4.2.3). 

If, in addition, a length clause is applied to 

1. the array type, the pragma has no effect, since such a length clause already uniquely determines the array 
packing method. 

2. the component type, the array is packed densely, observing the component's length clause. Note that the 
component length clause may have the effect of preventing the compiler from packing as densely as 
would be the default if pragma PACK is applied where there was no length clause given for the com¬ 
ponent type. 


5-8 








APPENDIX F TO MH.-STD-1815A 


5.4.62. The Predefined Type String 

Package STANDARD applies Pragma PACK to the type string. However, when applied to character arrays, 
this pragma cannot be used to achieve denser packing than is the default for the target; 1 character per 32-bit 
word. 

5.4.63. Pragma PACK for Records 

If pragma PACK is applied to a record, the densest possible representation is chosen that is compatible with 
the sizes and alignment constraints of the individual component types. Pragma PACK has an effect only if the 
sizes of some component types are specified explicitly by size specifications and are of non-referable nature. In 
the absence of pragma PACK, such components generally consume a referable amount of space. 

It should be noted that default type mapping for records maps components of boolean or other types that 
require only a single bit to a single bit in the record layout, if there are multiple such components in a record. 
Otherwise, it allocates a referable amount of storage to the component. 

If pragma PACK is applied to a record for which a record representation clause has been given detailing the 
allocation of some but not all components, the pragma PACK affects only the components whose allocation has 
not been detailed. Moreover, the strategy of not utilizing gaps between explicitly allocated components still 
applies. 

5.4.7. Minimal Alignment for Types 

Certain alignment properties of values of certain types are enforced by the type mapping rules. Any represen¬ 
tation specification that cannot be satisfied within these constraints is not obeyed by the compiler and is ap¬ 
propriately diagnosed. 

Alignment constraints are caused by properties of the target architecture, most notably by the capability to 
extract non-aligned component values from composite values in a reasonably efficient manner. Typically, restric¬ 
tions exist that make extraction of values that cross certain address boundaries very expensive, especially in 
contexts involving array indexing. Permitting data layouts that require such complicated extractions may impact 
code quality on a broader scaie than merely in the local context of such extractions. 

Instead of describing the precise algorithm of establishing the minimal alignment of types, we provide the 
general rule that is being enforced by the alignment rules: 

• No object of scalar type including components or subcomponents of a composite type, may span a target- 
dependent address boundary that would mandate an extracuon of the object’s value to be performed by two 
or more extractions. 

53. IMPLEMENTATION-GENERATED COMPONENTS IN RECORDS 

The only implementation-dependent components allocated by Tartan Ada in records contain dope information 
for arrays whose bounds depend on discriminants of the record. These components cannot be named by the user. 

5.6. INTERPRETATION OF EXPRESSIONS APPEARING IN ADDRESS CLAUSES 

Section 13.5.1 of the Ada Language Reference Manual describes a syntax for associating interrupts with task 
entries. Tartan Ada implements the address clause 

for TCENTRY use at intID; 

by associaung the interrupt specified by intID with the coentry entry of the task containing this address 
clause. The interpretation of intID is both machine and compiler dependent. 


5-9 







USER MANUAL FOR TARTAN ADA VMS C30 


5.7. RESTRICTIONS ON UNCHECKED CONVERSIONS 

Tartan supports UNCHECKED_CONVERSION with a restriction that requires the sizes of both source and 
target types to be known at compile time. The sizes need not be the same. If the value in the source is wider than 
that in the target, the source value will be truncated. If narrower, it will be zero-extended. Calls on instantiadons 
of UNCHECXED_C0NVERSI0N are made inline automaricaily. 

5.8. IMPLEMENTATION-DEPENDENT ASPECTS OF INPUT-OUTPUT PACKAGES 

Tartan Ada supplies the predefined input/output packages 0IRECT_IG, SEQUENTIAL_io, text_io, and 
L0W_LEVEL_I0 as required by LRM Chapter 14. However, since TD20C30 is used in embedded applicadons 
lacking both standard I/O devices and file systems, the funcdonality of DIR£CT_I0, 3 EQUENTIAL_io, and 
TEXT_IO is limited. 

DIR£CT_I0 and SEQUENT I AL_10 raise USE_SRR0R if a file open or file access is attempted. ?EXT_I0 
is supported to CURRENT_0UTPUT and from CURRENT_INPUT. A routine that takes explicit file names raises 
USE_ERROR. 

5.9. OTHER IMPLEMENTATION CHARACTERISTICS 

The following informadon is supplied in addiuon to that required by Appendix F to MIL-STD-1815A. 

5.9.1. Definition of a Main Program 

Any Ada library subprogram unit may be designated the main program for purposes of linking (using the 
AL3C3 0 command) provided that the subprogram has no parameters. 

Tasks initiated in imported library units follow the same rules for terminadon as other tasks [described in 
LRM 9.4 (6-10)]. Specifically, these tasks are not terminated simply because the main program has terminated. 
Terminate aitemadves in selective wait statements in library tasks are therefore strongly recommended. 

5.9.2. Implementation of Generic Units 

All instantiadons of generic units, except the predefined generic UNCHECXED_CCNVERSICN and 
UNCHECXED_DEALLOCATION subprograms, are implemented by code duplications. No attempt ax sharing 
code by multiple instantiadons is made in this release of Tartan Ada. (Code sharing will be implemented in a 
later release.) 

Tartan Ada enforces the restriction that the body of a generic unit must be compiled before the unit can be 
instantiated. It does not impose the restriction that the specification and body of a generic unit must be provided 
as part of the same compilation. A recompilation of the body of a generic unit will obsolete any units that 
instantiated this generic unit. 

5.9.3. Attributes of Type Duration 

The type DURATION is defined with the following charactensucs: 

DURATION' DELTA IS 0.0001 sec 
DURATION' SMALL is 6.103516E' 5 sec 
DURATION' EIRST is -86400.0 sec 
DURATION' LAST is 86400.0 sec 

5.9.4. Values of Integer Attributes 

Tartan Ada supports the predefined integer type INTEGER. The range bounds of the predefined type 
integer are: 

INTEGER' FIRST = -2**31 
INTEGER' LAST = 2**31-1 


5-10 






APPENDIX F TO MIL-STD-1815A 


The range bounds for subtypes declared in paclcage TEXT_I0 are: 

COUNT'FIRST =0 

COUNT'LAST = INTEGER'LAST - 1 

POSITIVE_COUNT'FIRST = 1 

POSITIVE_COUNT' LAST = INTEGER' LAST - 1 

FIELD' FIRST =0 
FIELD' LAST =20 

The range bounds for subtypes declared in packages direct_io are: 

COUNT'FIRST =0 

COUNT'LAST = INTEGER' LAST 

POSITIVE_COUNT'FIRST = 1 
POSITIVE COUNT'LAST=COUNT'LAST 


5-11 











USER MANUAL FOR TARTAN ADA VMS C30 


5.9.5. Values of Floating-Point Attributes 


5-12 




Tartan Ada supports the predefined floating-point types 
Attribute 

DIGITS 

MANTISSA 

EMAX 

EPSILON 

approximately 

SMALL 

approximately 

LARGE 

approximately 

SAFS_EMAX 

SAFE_SMALL 

approximately 

SAFS_LARGE 

approximately 

FIRST 

approximately 

LAST 

approximately 
MACHINE_RADIX 
MACHINE_MANTISSA 
MACHINE_EMAX 
MACHINE_EMIN 
MACHINE_ROUNDS 
MACHINE OVERFLOWS 


APPENDIX F TO MIL STD-1815A 


FLOAT and LONG_FLOAT. 
Value for float 

6 

23 
92 

16#0.1000 00#E-4 
9.53674E-07 

16#0.8000_00#E-21 

2.58494E-26 

16#0.FFFF_F8#E+21 
1.93428E+25 

126 

16#0.2000_00#E-31 
5.87747E-39 

16#0.3FFF FE#E+32 
S.50706E+37 

-16#0.1000_00#E-t-33 
-3.40282E+38 

16#0.FFFF FF#E+32 
3.40282E+38} 

2 

24 
128 
-126 
FALSE 
TRUE 


5-13 










USER MANUAL FOR TARTAN ADA VMS C30 


Attribute 

DIGITS 

MANTISSA 

EMAX 

EPSILON 

approximately 

SMALL 

approximately 

LARGE 

approximately 

SAFE_EMAX 

5AFE_5MALL 

approximately 

SAFE_LARGS 

approximately 

FIRST 

approximately 

LAST 

approximately 
MACHINE^RADIX 
MACHINE_MANTISSA 
MACHINE_EMAX 
MACHINE_EMIN 
MACHINE_ROUNDS 
MACHINE OVERFLOWS 


Value for long float 

9 

31 

124 

16#0.4000_0000_0#E-7 

9.31322575E-10 

16*0.8000 0000 Q#E-31 
2.35098870E-38 

I6*0.FFFF FFFE 0#E+31 
2.12676479E+37 
1022 

16*0.2000 0000 0#E-31 
5.87747175E-39 

16#0.3FFF_FFFF_8#E+32 
8.50705917E+37 

-16*0.1000 0000 0#E+33 
-3.40282367E+38 

16*0.FFFF FFFF_0#E+32 
3.40282367E+38 

A 

32 
128 
-126 
FALSE 
TRUE 


5-14 




APPENDIX r TO MTL-STD-I815A 


5.10. SUPPORT FOR PACKAGE MACHINE JCODE 

Package MACHINE_CODE provides the programmer with an interface through which to request the genera¬ 
tion of any instruction that is available on the C30. The ADAC30 implementation of package MACHINE_C0DE 
is similar to that described in Section 13.8 of the Ada LRM, with severai added features. 

5.10.1. Basic Information 

As required by LRM, Section 13.8, a routine which contains machine code inserts may not have any other 
kind of statement, and may not contain an exception handler. The only allowed declarative item is a use clause. 
Comments and pragmas are allowed as usual. 

5.102. Instructions 

A machine code insert has the form TY?£_MARK' AECORD_AGGR£GATS, where the type must be one of the 
records defined in package MACHINE_CODE. Package MACHINE_CODE defines seven types of records. Each 
has an opcode and zero to 6 operands. These records are adequate for the express.cn of ail instructions provided 
by the C30. 

5.10.3. Operands 

An operand consists of a record aggregate which holds all the information to specify it to the compiler. .All 
operands have an address mode and one or more other pieces of information. The operands correspond exactly to 
the operands of the instruction being generated. 

5.103.1. Address Modes 

Each operand in a machine code insen must have an Address J4ode_Same. The address modes provided in 
package MACHINE_CODE provide access to all address modes supported by the C30. 

In addition, package MACHINE_CCDE supplies the address modes 5ymbo 1 a c_Address and 
SymboliC_Value which allow the user to refer to Ada objects by specifying Cb ^ecc.' ADDRESS as the value 
for the operand. Any Ada object which has the 'ADDRESS attribute may be used in a symbolic operand. 
SymboJUc_Addre3s should be used when the operand is a true address ( that is. a branch target for example). 
Symbolic_Value should be used when the operand is actually a value (that is, one of the source operands of 
an ADD I instruction). 

When an Ada object is used as a source operand in an instruction (that is. one from which a vaiue is read), the 
compiler will generate code which fetches the value of the Ada object. When an Ada object is used as the 
destination operand of an instruction, the compiler will generate code which uses the address of the Ada object as 
the destination of the instruction. 

5.10.4. Examples 

The ADAC30 implementation of package viACHlNE_CODE makes it possible to specify both simple machine 
code inserts such as 

cwo__formac' (EDI, (lam, 5), (Reg, AO) ) 
and more complex inserts such as 

chree_format'(ADDI3, 

(lam, 10), 

(Syrnbolicj/alue, Array_Var(X, Y, 2") ' ADDRESS) , 

(Symboiic_Address, ?aramecsr_i'ADDRESS)) 

In the first example, the compiler will emit the instrucuon ID I 5, AO. In the second example, the compiler 
will first emu whatever instructions are needed to form the address of Array_var (X, Y, 27) and then emu 
the ADDI3 instruction. If ?arameter_i is not found in a register, the compiler will put the result of the 
addition in a temporary register and then store it to ?ararr.ecer_l' ADDRESS. Note that the destination 
operand of the add 13 instruction is given as a Symboiic_Address. This holds true for all destination 


5-15 







USER MANUAL FOR TARTAN ADA VMS C30 


operands. The various error checks specified in the LRM will be performed on ail compiler-generated code 
unless they are suppressed by the programmer (either through pragma SUPPRESS, or through command 
qualifiers). 

5.1 OJ. Incorrect Operands 

Two modes of operation are supplied for package MACHINE_CODE: Fixup mode and No_?ixup mode. 
The choice of mode is made with the qualifier /Fixup_Machine_Code or its negation 
/No_Fixup_Machine_Code. 

In No_Fixup mode, the specification of incorrect operands for an instruction is considered to be a fatal 
error. In this mode, the compiler will not generate any extra instructions to help you to make a machine code 
insertion. Note that it is still legal to use ' ADDRESS constructs as long as the object which is used meets the 
requirements of the instruction. 

In Fixup mode, if you specify incorrect operands for an instruction, the compiler will do its best to fix up the 
machine code to provide the desired effect. For example, although it is illegal to use a memory address as the 
destination of an ADD I instruction, the compiler will accept it and try to generate correct code. In this case, the 
compiler will load the value found at the memory address indicated into a register, use this register in the ADD I 
instruction, and then store from that register back to the desired memory location. 

Two_Opnds'(ADDI, (Imm, 10), (ARI, AR1)) 

will produce a code sequence like 

LDI *AR1, R0 

ADDI 10, R0 

STI R0, *AR1 

The next example illustrates the fix up required when the displacement is out of range for the first operand of an 
ADD 13 instruction. The displacement is first loaded into one of the index registers. 

Three_Opnd3'(ADDI3, (IPDA, AR3, 2), (Reg, RC), (Reg, Rl)) 

will produce a code sequence like 

LDI 2, IRO 

ADDI3 AR3 (IRO) , R0, Rl 

5.10.6. Register Usage 

Since the compiler may need to allocate registers as temporary storage in machine code routines, there are 
some restrictions placed on your register usage. The compiler will automatically free all the registers which 
would be volatile across a call for your use (that is, R0..R3, AR0..AR2, IRO. IR1, and DP). If you reference any 
other register, the compiler will reserve it for your use until the end of the machine code routine. The compiler 
will not save the register automatically if this routine is inline expanded. This means that the first reference to a 
register which is not volatile across calls should be an instruction which saves its value in a safe plxe. The value 
of the register should be restored at the end of the machine code routine. This rule will help ensure correct 
operation of your machine code insen even if it is inline explaned in another routine. However, the compiler will 
save the register automatically in the prolog code for the routine and restore it in the epilog code for the routine if 
the routine is not inline expanded. 

The compiler may need several registers to generate code for operand fixups in machine code inserts. If you 
use ail the registers, fixups will not be possible. In general, when more registers are available to the compiler it is 
able to generate better code. 


5-16 







APPENDIX FTO MU.-STD-I8IJA 


5.10.7. Inline Expansion 

Routines which contain machine code insens may be inline expanded into the bodies of other routines. This 
may happen under programmer control through the use of pragma INLINE, or at Optimization Level 3 when the 
compiler selects that optim izati on as an appropriate action for the given situation. The compiler will treat the 
machine code insen as though it was a call; volatile registers will be saved and restored around it, etc. 

5.10.8. Unsafe Assumptions 

There are a variety of assumptions which should not be made when writing machine code inserts. Violauon 
of these assumptions may result in the generation of code which does not assemble or which may not function 
correctly. 

• The compiler will not generate call site code for you if you emit a call instruction. You must save and 
restore any volatile registers which currently have values in them, etc. If the routine you call has out 
parameters, a large function return result, or an unconstrained result, it is your responsibility to emit the 
necessary instructions to deal with these constructs as the compiler expects. In other words, when you emit 
a call, you must follow the linkage conventions of the routine you are calling. For further details on call 
site code, see Sections 6.4,6.5 and 6.6. 

• Do not assume that the 'ADDRESS on Symbolic_Address or 5ymbolic_Vaiue operands means 
that you are getting an ADDRESS to operate on. The Address- or Value-ness of an operand is determined 
by your choice of Symbolic_Addre33 or Symbolic_Vaiue. This means that to add the contents of 
X to R3, you should write 

Three Format'(ADDI, (Symbolic_Value, X'ADDRESS), 

(Reg, R3n 

but to add the address of X to R3, you should write 

Three_Format'(ADDI, (Symbolic Address, X'ADDRESS), 

(Reg, R3)“; 


5.10.9. Package MACHINE_CODE 

with system; — aaa 

pacxage Machir.e_Coce is 

type Instruct ton _Mnemonic ts 

— the character "i" t.as oeen apper.aec to -r.structions t.tat 

— conflict with Ada reserved woras. 

(ABSF, ABSF 3TF, ABSI, 

ABSI 371, AODC, ADDC3, 

ADDC3_3TI, ADDF, AD0F3, 

A0CF3_37F, ADOI, ADDI3, 

ADDI3_3TI, ANDi, AND3 , 

A ND3j??:. ANDN, ANCN3, 

ASH, ASH3, 

ASH3_37I, 3D, 3L3, 

3HI, 3LD, 3H3, 

3 EQ, 3NE, 31c., 

3GT, 3LT, 3GE, 

32, 3NZ, 3NP, — 3N? .s anct.ter .tare for 311 

3P, 3N, 3NN, 

3NV, 3V, 3NDF, 

3DF, 3NC, 3C, 

3 N17, 317, 3Nl~r, 

3IDF, 3ZDF, 3DD, 

313D, 3HID, 3LCD, 

3HSD, 3EGD, 3NED, 

3LED, 3G7D, 3LTD, 

3GED, 3ZD, 3NZ0, 

3NPD, 3PD, 3ND, — 3NPD _s anot.-.er tare for BLED 


5-17 



USER MANUAL FOR TARTAN ADA VMS C30 


3NND, 3NVD, 3VD, 
3NUFD, 3UFD, 3NCD, 
3C0, 3NLVD, 3LVD, 
3NLUFD, 3LUFD, 3ZUFD, 
3R, 3RD, CALL, 


CALL_noret, 

— Another name for CALL. 

— Use this wnen oaii never returns 

CALLU, CALLL3, 

CALLHI, CALLLO, 

CALLHS, 

CALLED, CALLXE, 

CALLLc,, 

CALLGT, CALLLT, 

CALLGE, 

CALLZ, CALLNZ, 

CALLNP, — CALLNP is another name for 

CALL?, CALLS, C 

ALLNN, 

CALLNV, CALLV, 

CALLNUF, 

CALLUF, CALLNC, 

CALLC, 

CALLNLV, CALLLV 

, CALLNLUF, 

CALLLUF, CALLZU 

F, 

oase_jump, 

CMP F, CMPF3, 

CMP I, CMP 13, 

— Another name for 3U. 

— use this wnen buiiaing a 


D3U, DBL3, DBHI, 

D3L0, DBHS, DBEQ, 

D3NE, DBLE, D8GT, 

D3LT, DBGE, OBZ, 

D3NZ, DBNP, DBP, 

D3N, DBNN, D3NV, 

D3V, DBNUF, DBUF, 

D3NC, DBC, DBNLV, 

D3LV, DBNLUF, DBLUF, 

:3ZUF, D3UD, DBLSD, 

D3HID, DBLOD, D3HSD, 

D3EQD, DBNED, OBLED, 

D3GTD, DBLTD, DBGED, 

D3ZD, DBNZD, DBNPD, 

D3PD, DBND, DBNND, 

D3NVD, DBVD, D3NUFD, 

D3UFD, DBNCD, D3CD, . 

D3NLVD, DBLVD, DBNLUFD, 

D3LUFD, DBZUFD, FIX, 

FIX_STI, FLOAT!, FLOAT_STF, 

IACX, IDLE, LDE, 

IDF, LDFU, LDFLS, 

LDFHI, LDFLO, LDFHS, 

1DFEQ, LDFME, LDFLE, 

LDFGT, LDFLT, LDFGE, 

LDFZ, LDFNZ, LDFNP, — LDFNP .s arcci-.er name for LD 

IDF?, IDEM, LDFNN, 

LDFNV, LDFV, LDFNUF, 

LDFLT, LDFNC, LDFC, 

LDFNLV, LDFLV, LDFNLUF, 

LDFLUF, LDFZUF, LDFI, 

LDFLDF, LDF_STF, LDI, 

LDIU, LDILS, LDIHI, 

LDILO, LDIHS, LDIEQ, 

LDINE, LDILE, LDIGT, 

LDILT, LDIGE, LDIZ, 

LDIMZ, LDINP, LDIP, — LDINP rs another name for LD 

LDIN, LDINN, LDINV, 

LDIV, LDINUF, LDIUF, 

LDINC, LDIC, LDINLV, 

LDILV, LDINL'JF, LDILUF, 


— DBNP is another name for D3LE 


D3NPD is another name for D3L 


atement 


5-18 






APPENDIX F TO MIL-STD-1815A 


LDIZUF, LDII, LDILDI, 
LDI_STI, LDM, LSH, 
LSH3, LSH3_STI, MPYF, 
MPYF3, MPYF3 STF, 





— 

XPYF3_ADDF3 srcA, srcS, 

dstl, srcC, srcG 

, dst2 


MPYF3 

ADDF3 

1. 

— 

srcA: 

indirsc - ; src3 : in 

direct; dsti: FO 

cr 

FI 





— 

srcC: 

An Fegister; srcG: 

Fn Fegister; as 

t2 ; 

F2 or F3 

MPYF3 

ADDF3 

2, 

— 

srcA: 

Fn Fegister; src3: 


FO 

or 

FI 




— 

srcC: 

Fn Fegister; srcG: 

inairect; cst2: 

F2 

or 

F3 

MPYF3 

AC0F3 

3, 

— 

srcA: 

Fn Fegister; src3: 

Fn Fegister; as 

C 1 * 

FO 

or F 




— 

srcC: 

indirect; srcG: m. 


or 

F3 


MPYF3 

ADDF3 

4, 

— 

srcA: 

Fn Fegister; src3: 

indirect; dstl: 

FO 

or 

FI 





srcC: 

indirect; srcG: Fn 

Fegister; dst2: 

F2 

or 

F3 

MPYF3 

ADDF3 

5, 

— 

srcA: 

indirect; src3: Fr. 

Fegister; dstl: 

FC 

or 

FI 




— 

srcC: 

Fn Fegister; srcG: 


F2 

or 

F3 

MPYF3 

ADDF3 

6 , 

— 

srcA: 

indirect; src3: Fn 

Fegister; dstl: 

FC 

or 

FI 




— 

srcC: 

indirect: srcG: Fn 

Fegister; dst2: 

F2 

or 

F3 




— 

MPYF3 

_SU3F3 srcA, src3. 

astl, srcC, srcG 

, dst2 


MPYF3 

5UBF3 

/ 

— 

srcA: 

inairect; src3: in 

cirect: astl: FC 

or 

FI 





— 

srcC: 

Fn Fegister; srcG: 

Fn. Fegister; as 

t2 : 

F2 : 

or F3 

MPYF3 

SUB? 3 

2, 

— 

srcA: 

Fn Fegister; src3: 

ir.airecc; escl: 

FO 

or 

FI 




— 

srcC: 

Fn Fegister; srcG: 


F2 

or 

F3 

MPYF3 

3UBF3 

3. 

— 

srcA: 

Fn Fegister; src3: 

Fn Fecister; as 


FC 

or F 




— — 

srcC: 

indirect; srcC: rn 

airect; ast2: F2 

or 

F3 


MPYF3 

3C3F3 

4, 

— 

srcA: 

Fn Fegister; src3: 

inairect; astl: 

FO 

or 

FI 




— 

srcC: 

indirect; srcC: Rr. 

Feg.ster; cst2: 

F2 

or 

F3 

MPYF3 

3U3F3 

3, 

— 

srcA: 

indirec*: rrc3: Rr. 

Fegister; astl: 

FC 

or 

P 1 




— 

srcC: 

Fn Fegister; srcG: 

inairect; dst2: 

F2 

or 

F3 

MPYF3 

SU8F3 

o, 

— 

srcA: 


?.9c;s:ar; esc 1: 

FC 

or 

FI 




— 

srcC: 

indirect: srcG: Fn 

Fegister; ast2: 

F2 

or 

F3 

*PYI, 

MP Y : 3 

t 








MPYI3 

_372, 


__ 

MPY13 

ACw-j srcA# srca. 

-sc., srcC, srcC 


sc2 


MPY13 

ago: 3 


— 

srcA' 

—. 



FI 





— 

srcC: 

Fn Fegister; srcG: 

Rr. Rec.scer; cs 

-2 

F2 

cr R2 

MPYI3 

ago: 3 

7 

— 

srcA: 

Fn Fegister; srcS: 

.rc^recc; esc 1: 

FC 

or 

FI 




-- 

srcC: 

Fn Fegister; srcG: 


F2 

or 

F3 

MPYI3 

agg:3 

1 

— 

srcA: 

Fn Fegister; src3: 

Rr. Reczszs r; cs 


FC 

or R 




— 

srcC: 


cirect; ast2: F2 

or 

F3 


MPYI3 

ACOI3 

4, 

— 

srcA: 

Fn Fegister; src3: 

ir.Gcrscc; esc 1: 

FC 

or 

FI 




— 

srcC: 

inairect; srcG: Fn. 

Fegister; ast2: 

F2 

or 

F3 

MPYI3 

ADO 13 

5, 

— 

srcA: 

indirect; src3: Fn 

Fegister; astl: 

FC 

or 

FI 




— 

srcC: 

Fn Fegister; srcG: 

.nairect; ast2: 

F2 

or 

F3 


5-19 























USER MANUAL FOR TARTAN ADA VMS C30 


MPYI3 

ADD 13 


— 

srcA: 

indirect; src3: 

Rn 

Register; 

dst 1: 

R0 

or 

R1 




— 

srcC: 

indirect: srcD: 

Rn 

Register; 

dst 2 : 

R 2 

or 

R3 




— 

MPYI3 

_3U3I3 srcA, src 

3, 

dsti, srcC 

, srcC 

, dst 2 


MPYI3 

SUBI3 


— 

srcA: 

indirect; srcB: 

; 

direct; ds 

tl: RC 

or 

R1 





— 

srcC: 

Rn Register; sr 

cC: 

Rn Register; cst2 ; 

R 2 or R3 

md y r 3 

3UBI3 

2 , 

— 

srcA: 

Rn Register; sr 

c3: 

indirect; 

dsti ; 

R 0 

or 

Ri 




—— 

srcC : 

Rn Register; sr 

cC: 

indirect; 

cst 2 : 

R 2 

or 

R3 

MPYI3 

SUB 13 

3, 

— 

srcA: 

Rn Register; sr 

c3: 

Rn Regist 

er; os 

t i ! 

R0 

or R 





srcC: 

indirect; srcC: 

in. 

direct; ost2: R2 

or 

R3 


MPYI3 

SUB 13 

4 r 

— 

srcA: 

Rn Register; sr 

c3: 

indirect; 

dsti : 

RC 

or 

r: 




— 

srcC: 

indirect; srcC: 

Rn 

Register; 

dst 2 : 

R2 

or 

R3 

mo y 33 

SUB 13 

5, 


srcA: 

indirect; sro3: 

Rn 

Register; 

dst i : 

R0 

or 

RI 




—— 

srcC: 

Rn Register; sr 


indirect; 

cst 2 : 

R2 

or 

R3 

XPYI3 

SUB 13 

o, 

— 

srcA: 

indirect; sro3: 

Rn 

Register; 

cst i : 

RC 

or 

RI 




— 

srcC: 

indirect: src 2 : 

Rn 

Register; 

cst 2 : 

R 2 

or 

R3 


MEGS, MEGF, 

NEGF_3TF, MEG I, NEGI 3T I , 
MO?, NORM, NORM 3TF,~ 

NCTi, NOT 3TI, ORi, 

GR3, 0R3 371, POP, 

POP", PUSH, PUSH?, 

ret:u, ret:ls, retihi, 
ret: 10 , ret:hs, retieq, 

RETINE, RETILE, RETIGT, 
RETILT, RETIGE, RETI2, 
RETINZ, RETINP, RETIP, 
RETIN, RETINN, RETINV, 
RETI7, RETINUE, RETIUF, 
RETIMC, RETIG, RETINLV, 
RETILV, RETINLUF, RETILUF, 
RETIZUF, RETSU, RETSL3, 
RETSHI, RETSLO, RETSHS, 
RETSEQ, RETSNE, RETSLE, 
RETSGT, RETSLT, RETSGE, 
RETSZ, RETSNZ, RETSNP, 
RETS?, RETSN, RET3NN, 
RETSNV, RETSV, RETSNUF, 
RET3UF, RETSNC, RETSC, 
RETSNL7, RETSL7, RET3NLUF, 
RETSLUF, RET3ZUF, RNO, 

RCL, 

RCLC, RCR, 

RCRC, 

RPTB, RPT3, 3IGI, 


3TF, 3TFI, 3TF 3TF, 

3TI, 3TII, 3TI_3TI, 
3U33, 3U333, 

3U3C, 3U3F, 3U3F3, 
3U3F3_3TF, 3U3I, 3U3I3, 
31313 3TI, 3U3R3, 

3U3RF, 

3U3RI, 

SWI, TRAP U, 


TRAPLS, 

TRAPHI, 

TRAPLO 

TRAPHS, 

TRAPES, 

TRAPNE 

TRA?LE, 

TRAPGT, 

TRAPLT 

7RA?GE, 

TRAPZ, 

TRAPNZ, 

TRAPN?, 

TRAPP, 

TRAPN, 


RETIN? is ar.otner name for RETI1E 


RETSN? .s ar.otner name for PET31Z 


TRAPN? .s ar.otner name for TRAP IE 


5-20 










APPENDIX F TO MTL-STD-1815A 


TRAPNN, TRAPNV, TRAP'/, 

TRAPNOF, TRAPOF, TRAPNC, 

TRAPC, TRAPNLV, TRAPLV, 

TRAPNLOF, TRAPLUF, TRAPZOF, 

TS73, TST33, 

XORi, XOR3, XOR3_STI); 

type Reaister is 

( RO, Rl, R2, R3, R4, R5, R6, RT, 
ArO, AR1, AR2, AR3, AR4, AR5, AR6, ART, 
OP, 

XRO, XRI, 


3K, 3P, 

37, 







IFiags, 

— 

expanded name 

~o avoid conflict 

wit a ADA r 

eserved wo 

rd "IF" 

XOF, 

RS, RE, 

RC) 

; 






type Float! 

-- 

•s digits 9; 






subtype Auxi 

liary Register 

is Registe 

r range ARC 

. . AFT 

. 


subtype Index Register 

is Registe 

r range IRC 

. . IRl; 


subtype Data 

_?age_?ointer 

is Regises 

r range 3? 

c? 



subtype Data 

_?age_Offset 

is integer 

range I .. 

1 o “ t 

15; 


suotype Diso 

laeement 

is integer 

range I .. 

255 ; 



type Address 

_Mode is 






(I mm, 

— 

snort Immediate 





Longlmm, 

— 

longe Immediate 





FloatImm, 

— 

snort float immeaiata 





Direct, 

— 

Direct 






Reg, 

— 

Register 






ar :, 

— 

Auxiliary Reg: 

ster Indirect 





XPOA, 

— 

Indirect with 

Pre —Displacement 

Ada 




IPOS, 

— 

Indirect with 

Pre -Displacement 

Suocract 




XPrOAM, 

— 

Inairect with 

Pre -Displacement 

Aad 3 

Mcaif 

/ 


IPrDSM, 

— 

Indirect with 

Pre —Displacement 

Suotract i 

Mcaif 



IPoDAM, 

— 

Indirect with 

Post—Displacement 

Ago i 

Mcaif 



IPoOSM, 

— 

Indirect with 

Post-Displacement 

Suotract i 

Mcaif 



XPoOACM, 

— 

Indirect with 

Post-Disolaeement 

Ago i 

C.rcu 

.ar 

Modify 

XPoDSCM, 

— 

Indirect wire 

Post—Displacement 

3jetract i 

Circu 

.ar 

Modify 

XPrXA, 

— 

Indirect with 

Pre -Index 

Acd 




XPrXS, 

— 

Inairect with 

Pre -Index 

Suotract 




XPrXAM, 

— 

Indirect with 

Pre -Index 

Agg s 

Modify 


IPrISM, 

— 

Indirect with 

Pre -Index 

Suotract i 

Modify 


IPoXAM, 

— 

Indirect with 

Post-Index 

Agg 3 

Mcaif* 

f 


IPoISM, 

— 

Indirect with 

Post-Inoex 

Suotract i 

Mcaify 


XPoIACM, 

— 

Indirect with 

Post-Index 

Agg i 

3 ireuiar 

Modify 

IPcISCM, 

— 

Indirect with 

Post-Index 

Suotract 3 

3 ireu. 

.ar 

Modify 

:?oXA3RM, 

— 

Indirect with 

Posc-In.cex 

AG G 3i 

Bit-Rever 

se Modify 

PcRe., 

— 

?c-reiative (a Use., for exams 

.e) 





5ymcoiic_Aodress, — special 

use :c express 

me 

actress 

*■ i 

o 

a n AC A 

3ymooiic_'/aiuei ; — specia- 

use to express 

me 

va.je 

o i 

an ADA 

fpe Operand{AM : Aooress_Mooe 

:* Zm — cefau. 

i e c 

:: <eeo 

Aaa 

Happy 


.s 

record 


— This record cescnces me ?oss.s.e recreserzat.ors of an opera.no. 

— It •.us; oe coordinated me ;:;e generator's -cae.. 

case AM -s 

wr.ec I mm ■> 

— Shore Immediate 
K: Integer; 

wrier, lonqlmm =>> 


5-21 


*41 u i u * m 












USER MANUAL FOR TARTAN ADA VMS CO 


— ionge Immediate 
Address : System.Address; 

when FloatImm »> 

— Short Float Immediate 
F: FloatLit; 

when Direct »> 

— Direct 

?age_Address : Data_?age_OEfset; 

when Reg 

— Register 
R_Reg : Register; 

when ARI »> 

— Auxiliary Register Inairect 
ARI_Ar : Auxiiiary_Register; 

when I?DA *> 

— Indirec 
I?0A_Ar 
I?DA_disp 

when IPOS => 

-- Indirect with Pre-Displacement Suotract 
I?DS_Ar : Auxiliary_Register; 

I?DS_disp : Displacement; 

when IPrDAM => 

— Indirect with Pre-Displacement Add * Mccify 
I?rDAM_Ar : Auxiliary ^Register; 

I?rDAM_sisp : Displacement; 

when IPrDSM => 

— Indirect with Pre-Displacement Suotract i Mocify 
I?rDSM_Ar : Auxiliary_Register; 

I?rDSM_disp : Displacement; 

when IPoOAM *> 

— Indirect with Post-Displacement Acd » Mccify 
I.?oDAM_Ar : Auxiliary_Register; 

I?oDAM_disp ; Displacement; 

wnen IPoDSM »> 

— I.ncirect with Post-Displacement Suotract » Mccify 
I?oOSM_Ar : Auxiliary_Register; 

I?oOSM_disp : Displacement; 

when IPcOACM => 

— Inairect with Post-Displacement Acc > Dircu~ar Mccify 
I?oDACM_Ar ; Auxiliary_Register; 

I?oOACM_disp : Displacement; 

wnen IPoJSCM *> 

— Indirect with ?ost-Displ.acemenc Suotract i D.rcu.ar Mccify 
I?oOSCM_Ar : Auxiiiary_Regiscer; 

I?oDSCM_disp ; Displacement; 

wnen IPrIA *> 

-- Inairect with Pre-I.naex Aad 
I?rIA_Ar : Auxi1ia ry_Regist er; 

I?rIA_Ir ; Incex_Register; 


wnen IPrIS *> 


t with Pre-Displacement Add 
: Auxiliary_Register; 

: Displacement; 


5-22 








APPENDIX F TO .VOL-STD- 1815a 


— Indirect with Pre-Index Subtract 
I?rIS_Ar : Auxiiiary__Register; 

IPrIS_Ir : Index_Register; 

when IPrIAM *> 

— Indirect with Pre-Index Add i Modify 
I?rIAM_Ar : Auxiliary_Register; 

IPrIAM_Ir : Index_Register; 

when IPrISM =•> 

— Indirect with Pre-Index Subtract i Modify 
I?rISM_Ar : Auxiliary_Registar; 

I?rISM_Ir : Inaex_Register; 

when IPoIAM =»> 

— Indirect with Post-Incex Aao i Modify 
IPoIAM_Ar : Auxiliary_Reaister; 

I?oIAM_Ir : I.ndex_Pegister; 

when IPoISM =*> 

— Indirect with Post-Index Subtract * Modify 
I?oISM_Ar : Auxiliary_Register; 

IPoISM Ir : Irdex__Register; 

when IPoIACM => 

— Indirect with Past-Index Ada i Circular Modify 
I?oIACM_Ar : AuxiIiary_Register; 

I?oIACM_Ir : Index_Register; 

when IPoISCM *> 

— Indirect with Post-Index Szccracz * Circular Modify 
I?oISCM_Ar : Auxiliary_Register; 

I?oISCM_Ir : Inaex_Regiscar; 

when IPoIABRM *> 

— Indirect with Post-Index Add i Sit-Reverse Modify 
I?oIABRM_Ar : Auxiliary_Recister; 

I?oIABRM_Ir : Ir.dex_Register; 

when PcRei =*> 

— Pc-relative (a label, for example) 

L_Addr: System.Address; — 'ADDRESS of an Ada .aoei 

when 3ymooiic_Address *> 

— special use to express tr.e address of an ADA oolect 
S_Addr: System.Address; 

wr.en 3ymoolic_Value => 

— special use to express tr.e value of an ADA object 
S_Vaiue: System.Address; 

end case; 
end record; 


ype ZerojDpnos is 
Record 

Operation: Instruction_Mnemonic; 
end Record; 

ype One_Cpnas is 
Record 

Operation : Instruccton_Mnemcr.ic; 
Operand_l: Operand; 
end Record; 






USER MANUAL FOR TARTAN ADA VMS CJO 


type Two_Opnds is 
Record 

Operation: Instruction_Mnemonic; 

Operand_l: Operand; 

0perand_2: Operand; 
end Record; 

type Three_Opnds is 
Record 

Operation; Instruction_Mnemonic; 

Operand_i: Operand; 

0perand_2: Operand; 

0perand_3: Operand; 
and Record; 

type ?our_Opnds is 
Record 

Operation: Instruction_Mnemanic; 

Operand^!: Operand; 

0perand_2: Operand; 

Operand^!: Operand; 

Operand_4: Operand; 
end Record; 

type ?ive_0?nds is 
Record 

Operation: Instruction_Mnenonic; 

Operana_l: Operand; 

Coerafri_2: Operand; 

0perand~3: Operand; 

0oerana_4: Operand; 

0?erand_5: Operand; 
and Record; 

type 3ix_0pnds is 
Recaro 

Operation: Instruction_Mnemonic; 

Operand_I: Operand; 

Operand_2: Operand; 

0oerand_3: Operand; 

0perand_4: Operand; 

Operand_5; Operand; 

Operand_S: Operand; 
end Record; 


end Machine_Code; 

5.10.10. Example 

with Tiacnine_coae; use -nac.-une_coae; 
proceaure nach_example is 

type ary_type is new string(I..5 ) ; 
sti,st2: ary_tyoe; 

orocedure move_str ing (length: in integer; 3.: -r. ary_type; 

s2: out ary_type) .s 

— -nove string si, which is length characters, to string s2 

— if this routine was inline expanded, instructions s.-.ou.a oe present 

— to save ana restore any non-volatile registers, 
begin 

Two Opnds' 'LOT, (SymbolicJ/aiue, length'Address 1 , (Reg, R3)»; 


5-24 




APPENDIX FTO MIL-STD-1815A 


Two_Opnds'(LDI, (Symbolic_Address, sl'Addressl, (Peg, 
Two Opnds'(LDI, (Symbolic_Address, s2'Address), (Reg, 
Two~OpndsMLDI, (IPoDAM, ArO, 1), (Reg, R 4) ) ; 

One Opnds'(RPTS, (Reg, R3)); 

FourJOpnds'(LDI STI, (IPoDAM, ArO, 1), (Reg, R4), 
(Reg7 R4) , (IPoDAM, Arl, U); 

7wo_0pnds' (STI, (Reg, R4), (IPoDAM, Arl, I)> ; 

end move_scring; 

begin 

scl := "hello"; 
move_scring(5, scl, sc2); 

end nach example; 


ArO) ) ; 
Arl) ) ; 


5-25 









USER MANUAL FOR TARTAN ADA VMS C30 


Assembly code output: 

.global mach_example 

; mach__example . tmp from src/mach_exampie.ada 

; Ada 3un/C30 Version Vll.466293001 CoDyrignt 1989, Tarran Laboracor 
; 1986 

.global xxml002 

.ref ARTSTACKPROLOG 

. next 

xxml002: PUSH AR3 

LDI S? , AR3 

PUSH AR3 

LDI 20,ARO 

CALL ARTSTACXPROLCG 

ADDI 14,S? 

PUSH RS 

PUSH RE 

PUSH RC 

LD I 1DEF1,ARO 

ST! ARO, '*AR3 (1) 

ld: i,ri 

3T1 Rl,'-AR3(2) 

ST: R1,'*AR3<3) 

LDl 5,R0 

ST: R0 , '*AR3 (4 ) 

STI R0,* *AR3(5) ; line 5 

LDI 3,RC ; line 26 

LDI 30EF2,ARO 

L0: AR3,AR1 

ado: s,ar: 

ld: 'ARC*-(1),R2 

RPT3 L3 

13: LDI 'ARC— (1),R2 

* STI R2, 'ARi— (1) 

ST: R2,'AR1— (1) 

ld: 3,RO ; line 27 


LDI 

AR3,ARO 

ADDI 

2, ARO 

LDI 

AR3,ARI 

ADDI 

2, ARI 

* T 

mdU i. 

4,R1 

LDI 

'ARO**(1),R2 

CMP I 

•ARI —(1> , R2 

3EQ 

• - 

gl V 

LDI 

0 , R1 

3R 

L12 

SUB I 

1, Rl 

3GT 

L9 

LDI 

1 , R1 

cnp : 

:, r: 

3NE 

Li 3 

I 

AR3,Rl 

ado: 

5, Rl 

• ■** * 

~tU j. 

AR3,ARO 

add: 

2, ARO 

ld: 

AR3,ARI 

add: 

2, AR1 

LDI 

4, R2 

LDI 

'ARO— (1) , R3 

cnp: 

'ARI—(1) ,R3 

3EQ 

LI 5 

ld: 

0, R2 

3R 

Li 7 

sub: 

1,R2 


5-26 











APPENDIX F TO MIL-STD-181SA 


3GT 

L14 

101 

1, R2 

CMP I 

1,R2 

3NE 

L13 

ID I 

AR3.R2 

AD0I 

11, R2 

C A T. i. 

move_stringS00 

101 

*wAR3(16) ,RS 

101 

**AR3117) ,RS 

101 

**AR3(19),RC 

- T 

AR3,S? 

POP 

AR3 

RETS'J 

TRAPU 

15 


; Tocal words of code in che above routine = 33 


. aaca 


0EF1 : 


17 


.text 

move strir.saCO: PUSH 


119: 


AR3 


' ^ r 

w. 

SP,AR3 


PUSH 

AR3 


PUSH 

R4 


PUSH 

R6 


•wl/ a. 

3DEF3,ARO 


st: 

AR0, •-AR3/1) 


- -> • 

R0,R3 

. ; ••a *5 

* T 

•wJ a. 

Rl,ARO 

; lir.e 1** 

MlW » 

R2,AR1 

; 1. r.e 13 

• ^ * 

•ARC— (1) , R4 

; -ir.e 15 

RPTS 

R3 

; line 1" 

io r 

•ARO— (1) , R4 


371 

R4 , 'AR1 — 1) 

; line 13 

371 

R4,*AR1-*(1) 

; ..ne 20 

POP 

R2 

• ' n 0 13 

POP 

Rl 


PC? 

R0 


131 

•-AR3(2),R4 


101 

•+AR3(3),RS 


io: 

AR3 t 3? 


POP 

AR3 


RETSU 



words 

of coce in che 

aoove roucine * 22 


3EF3 : 


. aaca 
. wore 


IIP 


1EF2: 
3EF4 : 


cexc 

daca 

word 

byte 

byte 

byte 


OE? 4 
105,101 
108, 108 


ne 

o 


Tocal words of code =* 90 
Total words of daca » 8 


.end 


5-27 











APPENDIX C 


TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, such 
as the maximum length of an input line and invalid file names. A test that 
makes use of such values is identified by the extension .TST in its file 
name. Actual values to be substituted are represented by names that begin 
with a dollar sign. A value must be substituted for each of these names 
before the test is run. The values used for this validation are given 
below. The use of the operator signifies a multiplication of the 
following character, and the use of the character signifies 

concatenation of the preceeding and following strings. The values within 
single or double quotation marks are to highlight character or string 
values: 

Name and Meaning Value 

SACC_SIZE 32 

An integer literal whose value 
is the number of bits sufficient 
to hold any value of an access 
type. 

$BIG_ID1 239 * 'A' & '1' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID2 except 
for the last character. 

$BIG_ID2 239 * ’A' & ' 2 ' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID1 except 
for the last character. 

$BIG_TD3 120 * 'A' & '3' & 119 * 'A' 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID4 except 
for a character near the middle. 








Name and Meaning 
$BIG_ID4 

An identifier the size of the 
maximum input line length which 
is identical to $BIG_ID3 except 
for a character near the middle. 

$8IG_INT_LIT 

An integer literal of value 298 
with enough leading zeroes so 
that it is the size of the 
maximum line length. 

$BIG_REAL_LIT 

A universal real literal of 
value 690.0 with enough leading 
zeroes to be the size of the 
maximum line length. 

$BIG_STRING1 

A string literal which when 
catenated with BIG_STRING2 
yields the image of BIG_ID1. 

$BIG_STRING2 

A string literal which when 
catenated to the end of 
BIG STRING1 yields the image of 
3IG”lDl. 

SBLANKS 

A sequence of blanks twenty 
characters less than the size 
of the maximum line length. 

$COUNT_LAST 

A universal integer literal 
whose value is TEXT_I0.COUNT'LAST. 

$DEFAULT_MEM_SIZE 

An integer literal whose value 
is SYSTEM.MEMORY_SIZE. 

$DEFAULT_STOR_UNIT 

An integer literal whose value 
is SYSTEM.STORAGE UNIT. 


TEST PARAMETERS 

Value 

120 * ’A’ £ '4' & 119 * 'A' 

237 * ’O’ & ”298" 

235 * ’0’ £ "690.0" 

"" £ 120 * 'A' £ 

”” £ 119 * ’A' £ ’1’ £ 

220 * ' ’ 

2147483646 

16777216 

32 







Name and Meaning 


Value 


$DEFAULT_SYS_NAME TI320C30 

The value of the constant 
SYSTEM.SYSTEM JIAME. 

$DELTA_DOC 2#1.0#E-31 

A real literal whose value is 
SYSTEM.FTNE_DELTA. 

$FIELD_LAST 

A universal 

literal whose 
TEXT_IO.FIELD’LAST 

$FIXED_NAME NO_SUCH_FIXED_TYPE 

The name of a predefined 
fixed-point type other than 
DURATION. 

$FLOAT_NAxME NO_SUCH_FLOAT_TYPE 

The name of a predefined 
floating-point type other than 
FLOAT, SHORT_FLOAT, or 

LONG_FLOAT. 

$GREATER_THAN_DURATION 100_000.0 

A universal real literal that 
lies between DURATION’BASE'LAST 
and DURATION’LAST or any value 
in the range of DURATION. 

$GREATER_THAN_DURATION_BASE_LAST 131_073.0 

A universal real literal that is 
greater than DURATION’BASE’LAST. 

$HIGH_PRIORITY 100 

An integer literal whose value 
is the upper bound of the range 
for the subtype SYSTEM.PRIORITY. 

$ILLEGAL_EXTERNAL_FILE_NAME1 /N0N_EXISTENT_DIRECT0RY1/FILE1 

An external file name which 
contains invalid characters. 

$ILLEGAL_EXTERNAL_FILE_NAME2 /NON_EXISTENT_DIRECTORY2/FILE2 

An external file name which 
is too long. 


20 

integer 
value is 









Name and Meaning 


Value 


$INTEGER_FIRST 

A universal integer literal 

whose value is INTEGER'FIRST. 

$INTEGER_LAST 

A universal integer literal 

whose value is INTEGER'LAST. 

$INTEGER_LAST_?LUS_1 

A universal integer literal 

whose value is INTEGER'LAST + 1. 

SLESS_THAN_DURATION 

A universal real literal that 
lies between DURATION'BASE’FIRST 
and DURATION’FIRST or any value 
in the range of DURATION. 

$LESS_THAN_DURATION_BASE_FIRST 

A universal real literal that is 
less than DURATION'BASE’FIRST. 

$LOW_PRIORITY 

An integer literal whose value 
is the lower bound of the range 
for the subtype SYSTEM.PRIORITY. 

$MANTISSA_DOC 

An integer literal whose value 
is SYSTEM.MAX_MANTISSA. 

$MAX_DIGITS 

Maximum digits supported for 
floating-point types. 

SMAX_IN_LEN 

Maximum input line length 
permitted by the implementation. 

$MAX_INT 

A universal integer literal 
whose value is SYSTEM.MAX_INT. 

$MAX_INT_PLUS_1 

A universal integer literal 
whose value is SYSTEM.MAX INT+1. 


-2147483643 


2147483647 


2147483648 


-100 000.0 


-131 073.0 


10 


31 


9 


240 


2147483647 


2147483648 








TEST PARAMETERS 


Name and Meaning Value 

$HAX_LEN_INT_BASED_LITERAL ”2:" « 235 * 'O' & "11:" 

A universal integer based 
literal whose value is 2 #11# 
with enough leading zeroes in 
the mantissa to be MAX_IN_LEN 
long. 

$MAX_LEN_REAL_BASED_LITERAL "16:" & 233 * 'O' & "F.E:” 

A universal real based literal 
whose value is 16:F.E: with 
enough leading zeroes in the 
mantissa to be MAX_IN_LEN long. 

$MAX_STRING_LITERAL "" & 238 * 'A' & "" 

A string literal of size 
MAX.IN.LEN, including the quote 
characters. 

$MIN_INT -2147483648 

A universal integer literal 
whose value is SYSTEM.MIN_INT. 

$MIN_TASK_SIZE 32 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
no entries, no declarations, and 
"NULL;" as the only statement in 
its body. 

SNAME NO_SUCH_TYPE_AVAILABLE 

A name of a predefined numeric 
type other than FLOAT, INTEGER, 

SHORT_FLOAT, SHORT.INTEGER, 

LONG.FLOAT, or LONG.INTEGER. 

$NAME_LIST TI320C30 

A list of enumeration literals 
in the type SYSTEM.NAME, 

separated by commas. 

$NEG_BASED_INT 16#FFFFFFFE# 

A based integer literal whose 
highest order nonzero bit 

falls in the sign bit 
position of the representation 

for SYSTEM.MAX INT. 








Name and Meaning 


Value 


$NEW_MEM_SIZE 

An integer literal whose value 
is a permitted argument for 
pragma MEMORY_SIZE, other than 
$DEFAULT_MEM_SIZE. If there is 
no other value, then use 
$DEFAULT_MEM_SIZE. 

$NEV_STOR_UNIT 

An integer literal whose value 
is a permitted argument for 
pragma STORAGE_UNIT, other than 
$DEFAULT_STOR_UNIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGEJJNIT. 

$NEV_SYS_NAKE 

A value of the type SYSTEM.NAME, 
other than $DEFAULT_SYS JJAME. If 
there is only one value of that 
type, then use that value. 

$TASK_SIZE 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
a single entry with one 'IN OUT' 
parameter. 

STICK 

A real literal whose value is 
SYSTEM.TICK. 


16777216 


32 


TI320C30 


96 


0.0001 











WITHDRAWN TESTS 




APPENDIX D 
WITHDRAWN TESTS 

Some tests are withdrawn from the ACVC because they do not conform to the 
Ada Standard. The following 44 tests had been withdrawn at the time of 
validation testing for the reasons indicated. A reference of the form 
Al-ddddd is to an Ada Commentary. 

a. E28005C This test expects that the string "— TO? OF PAGE. 

63" of line 204 will appear at the top of the listing page due 
to a pragma PAGE in line 203; but line 203 contains text that 
follows the pragma, and it is this that must appear at the top 
of the page. 

b. A39005G This test unreasonably expects a component clause to 

pack an array component into a minimum size (line 30) . 

c. B97102E This test contains an unitended illegality: a select 

statement contains a null statement at the place of a selective 
wait alternative (line 31) . 

d. C97116A This test contains race conditions, and it assumes that 
guards are evaluated indivisibly. A conforming implementation 
may use interleaved execution in such a way that the evaluation 
of the guards at lines 50 & 54 and the execution of task CKANGING- 
_OF_THE_GUARD results in a call to REPORT.FAILED at one of 

< lines 52 or 56. 

e. BC30093 This test wrongly expects that circular instantiations 
will be detected in several compilation units even though none of 
the units is illegal with respect to the units it depends on; by 
AI-00256, the illegality need not be detected until execution is 
attempted (line 95) . 

f. CD2A62D This test wrongly requires that an array object's size 
be no greater than 10 although its subtype’s size was specified 
to be 40 (line 137) . 

g. CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] These 
tests wrongly attempt to check the size of objects of a derived 
type (for which a 'SIZE length clause is given) by passing them 
to a derived subprogram (which implicitly converts them to the 
parent type (Ada standard 3.4:14)). Additionally, they use the 
'SIZE length clause and attribute, whose interpretation is 
considered problematic by the WG9 ARG. 







h. CD2A31G. CD2A33G, CD2A34N * H, £ CD50110 [5 tests] These tests 

assume that dependent tasks will terminate while the main pro¬ 
gram executes a loop that simply tests for task termination; this 
is not the case, and the main program may loop indefinitely 

(lines 74, 85, 36 & 96, 36 & 96, and 53, resp.). 

i. CD2B15C & CD7205C These tests expect that a 'STORAGE_SIZE 
length clause provides precise control over the number of 
designated objects in a collection; the Ada standard 13.2:15 
allows that such control must not be expected. 

j. CD2D11B This test gives a SMALL representation clause for a 

derived fixed-point type (at line 30) that defines a set of 
model numbers that are not necessarily represented in the 
parent type; by Commentary AI-00099, all model numbers of a 
derived fixed-point type must be representable values of the 
parent type. 

k. CD5007B This test wrongly expects an implicitly declared sub¬ 

program to be at the the address that is specified for an un¬ 
related subprogram (line 303). 

l. ED7004B, ED7005C & D, ED7006C & D [5 tests] These tests check 

various aspects of the use of the three SYSTEM pragmas; the AVO 
withdraws these tests as being inappropriate for validation. 

m. CD7105A This test requires that successive calls to CALENDAR.- 

CLOCK change by at least SYSTEM.TICK; however, by Commentary 

AI-00201, it is only the expected frequency of change that must 
be at least SYSTEM.TICK—particular instances of change may be 
less (line 29) . 

n. CD7203B, & CD7204B These tests use the 'SIZE length clause and 
attribute, whose interpretation is considered problematic by 
the VG9 ARG. 

o. CD7205D This test checks an invalid test objective: it treats 

the specification of storage to be reserved for a task's 
activation as though it were like the specification of storage 
for a collection. 

p. CE2107I This test requires that objects of two similar scalar 
types be distinguished when read from a file—DATA_ERR0R is 
expected to be raised by an attempt to read one object as of 
the other type. However, it is not clear exactly how the Ada 
standard 14.2.4:4 is to be interpreted; thus, this test objective 
is not considered valid, (line 90) 

q. CE3111C This test requires certain behavior, when two files are 

associated with the same external file, that is not required by 






WITHDRAWN TESTS 


the Ada standard. 

r. CE3301A This test contains several calls to END_OF_LINE i 
END_OF_PAGE that have no parameter: these calls were intended 
to specify a file, not to refer to STANDARD_INPUT (lines 103, 
107, 118, 132, & 136) . 

s. CE3411B This test requires that a text file's column number be 

set to COUNT'LAST in order to check that LAYOUT_ERROR is raised 
by a subsequent PUT operation. But the former operation will 
generally raise an exception due to a lack of available disk 

space, and the test would thus encumber validation testing. 






APPENDIX E 


COMPILE?. AND LINK'S? OPTIONS 





Chapter 3 

Compiling Ada Programs 


The tada command is used to compile and assemble Ada compilation units. 

3.1. THE tada COMMAND FORMAT 
The cada command has this format: 

tada [ option ... ] file... [option...] 

Arguments that start with a hyphen are interpreted as options; otherwise, they represent filenames. There 
must be at least one filename, but there need not be any options. Options and filenames may appear in any order, 
and all options apply to all filenames. For an explanation of the available options, see Section 3.2. 

If a source file does not reside in the directory in which the compilation takes place, file must include a path 
sufficient to locate the file. It is recommended that only one compilation unit be placed in a file. 

Files are processed in the order in which they appear on the command line. The compiler sequentially 
processes all compilation units in each file. Upon successful compilation of a unit: 

• the Ada program library ada. db is updated to reflect the new compilation time and any new dependencies 

• one or more separate compilation files and/or object files are generated 

If no errors are detected in a compilation unit, cada produces an object module and updates the library. If any 
error is detected, no object code file is produced, a source listing is produced, and no library entry is made for 
that compilation unit. If warnings are generated, both an object code file and a source listing are produced. For 
further details about the process of updating the library, files generated, replacement of existing files, and 
possible error conditions, see Sections 3.3 through 3.6. 

The output from tada is a file of type . stof or . tof, for a specification or a body unit respectively, 
containing object code. Some other files are left in the directory as well. See Section 3.4 for a list of extensions 
of files that may be left in the directory. 

3.2. OPTIONS 

Command line options indicate special actions to be performed by the compiler or special output file 
properties. 

The following command line options may be used: 

-a Generate an assembly code file. The assembly code file has an extension . s or . ss 

(see Section 3.4). 

-g Output debugging information. 

-i Cause compiler to omit data segments with the text of enumeration literals. This text 

is normally produced for exported enumeration types in order to support the 
' IMAGE attribute. You should use -i only when you can guarantee that no unit 
that will import the enumeration type will use ' IMAGE. However, if you are 
compiling a unit with an enumeration type that is not visible to other compilation 
units, this option is not needed. The compiler can recognize when ' IMAGE is not 
used and will not generate the supporting strings. 


3-1 










USER MANUAL FOR TARTAN ADA VMS C30 


-La Generate a listing, even if no errors were found. The default is to generate a listing 

only if an error is found. 

-Ln Never generate a listing. The default is to generate a listing only if an error is found. 

-n=n Stop compilation after n errors have been detected. 

-Opn Control the level of optimization performed by the compiler, requested by n. The 

optimization levels available are: 

n = 0 Minimum - Performs context determination, constant folding, al¬ 
gebraic manipulation, and short circuit analysis. 

n = 1 Low - Performs level 0 optimizations plus common subexpression 
elimination and equivalence propagation within basic blocks. It 
also optimizes evaluation order. 

n = 2 Space - This is the default if none is supplied. Performs level 1 
optimizations plus flow analysis which is used for common sub¬ 
expression elimination and equivalence propagation across basic 
blocks. It also performs invariant expression hoisting, dead code 
elimination, and assignment killing. Level 2 also performs lifetime 
analysis which is used to improve register allocation. It also per¬ 
forms inline expansion of subprogram calls indicated by Pragma 
INLINE which appears in the same compilation unit. 

n = 3 Time - Performs level 2 optimizations plus inline expansion of 
subprogram calls which the optimizer decides are profitable to ex¬ 
pand (from an execution time perspective). Other optimizauons 
which improve execution time at a cost to image size are per¬ 
formed only at this level. 

-v Print out compiler phase names. The compiler prints out a short description of each 

compilation phase in progress. 

-q Do not print out compiler phase names. 

-w Suppress warning messages. 

-5 [ acdeilorSZ 1 Suppress the given set of checks: 

A ACCES S_CHECK 

C CONSTRAINT_CHECK 

D DISCRIMINANT_CHECK 

E ELABORATION_CHECK 

I INDEX_CHECK 

L LENGTH_CHECK 

0 OVERFLOW_CHECK 

R RANGE_CHECK 

S STORAGE_CHECK 

Z "ZERO"DIVISION_CHECK 

The -S option has the same effect as a global pragma SUPPRESS applied to the 
source file. If the source program also contains a pragma SUPPRESS, then a given 
check is suppressed if either the pragma or the switch specifies it: that is, the effect 
of a pragma SUPPRESS cannot be negated with the command line option. See 
LRM 11.7 for further details. Examples are: 

-SOZ Suppress OVERELOW_CHECK and "ZERO"DIVI3ICN_CHECK. 

-S Suppress all checks. 


3-2 












COMPILING ADA PROGRAMS 


-SC Suppress CONSTRAlNT_ERROR, equivalent to -SADILR. 

-x Cause the compiler to generate a cross reference file containing entries of the form 

Ada-name=>linkname at line 

This option will allow users to find the linkname generated for the given Ada-name, 
and use linkname to set breakpoints in debuggers. The file will have the extension 
. xrf (See Section 3.5). 

In addition, the output from the compiler may be redirected using the redirection facility including 's’ for 
scderr; for example 

I tada tax_spec.ada >& tax_spec.txt 

3 . 3 . WHAT UPDATES ARE MADE TO THE PROGRAM LIBRARY 

Simply stated, upon successful compilation of a unit, 

• the Ada program library a da . db is updated to reflect the new compilation time and any new dependencies 

• one or more separate compilation files and/or object files are generated. 

However, more complicated situations can arise. The following items list the types of compilation unit and 
address the range of situations that can arise. 

• In all cases the transitive closure of the dependencies of a compilation unit in the library must be consis¬ 
tent; that is, the unit must be compiled consistently as defined in section 10.3 of the LRM. A secondary 
unit can have its specification in its context clause, although it is redundant For a more complete 
discussion of closure, see Section 4.5. 

• A package specification replaces any library unit in the library with the same name, or is simply added if 
no such library unit exists. 

• A package body replaces any existing body of a package specificauon with the same name. If no such 
specification exists, an error message is issued. If such a specification exists, but the body does not match 
the specification in the sense of Section 7.1 of the LRM, error messages are issued. 

• A subprogram specification replaces any library unit in the library with the same name, or is simply 
added if no such library unit exists. 

• A subprogram body replaces any existing body of a (generic or non-generic) subprogram specification 
with the same name. If no such specification exists, an implicit specification is derived from the body and 
entered into the library as noted above for subprogram specification. If a specification exists, but the body 
does not matcu the specification in the sense of Section 6.3 of the LRM, error messages are issued. If any 
library unit other than a subprogram specification exists with the same name, the new implicit specification 
replaces that library unit 

• Generic package specifications and subprogram specifications act as explicit specifications, i.e., cor¬ 
responding bodies must match their specifications. If a generic unit is instantiated, a dependency is created 
on the generic body. 

• Generic instances compiled as library units are treated in the same way as their non-genenc counterparts. 

• When an instantiation replaces the body of a library unit, all secondary units of that library unit are now 
obsolete and are deleted. 

• A subunit with a parent unit containing an appropriate body stub existing in the library replaces any 
subunit with the same subunit name, comprised of the stub’s name and the name of the ancestor unit, or is 
simply added, if no such subunit exists. A unit containing stubs will only be entered into the library if the 
simple names of all its stubs are unique for all stubs derived from its common ancestor. An error message 
is issued if no parent unit exists in the library, the parent unit exists but does not have a relevent stub, or the 
parent unit and body stub exist but the subunit does not match the stub or its specification. 


3-3 








USER MANUAL FOR TARTAN ADA VMS C30 


• When the parent unit of a subunit is recompiled and the parent no longer contains a stub for the subunit, 
the subunit, which is now obsolete, is deleted. 

3 . 4 . FILES PRODUCED OR USED BY THE COMPILATION SYSTEM 

Files with the following extensions are contained in the standard packages directories or can be created by 
compiling or linking an Ada program; the file name is the name of a compilation unit, but may be compressed to 
conform to length limitations. 

bod Representation of the body of a generic, and/or the visibility information available to 

any subunits or generic bodies, body-name. bod is read when compiling a program that 
instantiates body-name or a generic contained in a body-name, or is a subunit of 
body-name. 

di Representation of a unit specification, unit-name . di is read during the compilation of a 

program that does a "with unit-name". 

1st A listing produced by the Ada compiler. I 

map A link file produced by the Tartan linker. 

asm The assembly language file produced by compiling an Ada unit body when the -a 

option is given. 

s t o f The object file produced by compiling an Ada unit specification, 

t o f The object file produced by compiling an Ada unit body. 

xrf Cross reference files that relate Ada names with compressed and disambiguated names 

used in the object or assembly language file. 

xt o f An executable image created by linking a mam program. 

The following are the extensions used for files that are created temporarily during the linking process: 

etof The elaboration script generated by the library 

1 x s List of all object files to be linked by the linker 

1 c f Control file for the linker. 

Additionally, temporary files are created during compilation that have the same file extensions listed above, but 
also have a unique 8 digit hexadecimal number concatenated to the extension. Any of the above files will appear 
in the directory only if a link or compilation is abnormally terminated. These files should then be deleted by the 
user. 

Files having the following extensions are controlled by the librarian and compiler: dx, bod, tof and scof. 

The user should not use these extensions for any other purpose. The alxb delete command will automati¬ 
cally delete these files, when the respective unit is deleted from the library. If the user deletes these files in any 
other way, subsequent invocations of the compiler or librarian will have unpredictable results, including fatal 
crashes. We therefore advise that the user never delete these files by operating system commands. 

3 . 5 . THE CROSS REFERENCE MAP OF LINKNAMES 

A cross reference of symbolic names to linknames is generated with the option -x to the tada command. 

The cross-reference file has the extension .xrf; the file name is that of the compiled unit, but possibly 
compressed to match restrictions, as shown in the example below. 

For longer unit-names, the cross reference file generated may not have an immediately obvious name, in 
order to find it, it may be necessary to search the current working directory for a recently produced file with 
extention xrf. 


3-4 






Marne and Meaning 
SINTEGER_FIRST 

A universal integer literal 

whose value is INTEGER'FIRST. • 

$INTEGER_LAST 

A universal integer literal 

whose value is INTEGER'LAST. 

$INTEGER_LAST_?LUS_1 

A universal integer literal 

whose value is INTEGER'LAST + 1. 

$LESS_THAN_DURATION 

A universal real literal that 
lies between DURATION'BASE'FIRST 
and DURATION'FIRST or any value 
in the range of DURATION. 

$LESS_THAN_DURATION_BASE_FIRST 

A universal real literal that is 
less than DURATION'BASE'FIRST. 

$LOV_PRIORITY 

An integer literal whose value 
is the lower bound of the range 
for the subtype SYSTEM.PRIORITY. 

$MANTISSA_DOC 

An integer literal whose value 
is SYSTEM.MAXJIANTISSA. 

$MAX_DIGITS 

Maximum digits supported for 
floating-point types. 

$MAX_IN_LEN 

Maximum input line length 
permitted by the implementation. 

$MAX_INT 

A universal integer literal 
whose value is SYSTEM.MAX_INT. 

$MAX_INT_PLUS_1 

A universal integer literal 
whose value is SYSTEM.MAX INT+1. 


TEST PARAMETERS 

Value 

-2147433643 

2147433647 

2147433643 

- 100 _ 000.0 

-131_07 3.0 

10 

31 

9 

240 

2147433647 


2147483648 











Name and Meaning 

$MAX_LEN_INT_3ASED_LI7ERAL 

A universal integer based 
literal whose value is 2 #11# 
with enough leading zeroes in 
the mantissa to be MAX_IN_LEM 
long. 

$MAX_LEN_R£AL_BASED_LITERAL 

A universal real based literal 
whose value is 16:F.E: with 
enough leading zeroes in the 
mantissa to be MAX_IN_LEN long. 

$MAX_STRING_LITERAL 

A string literal of size 
MAX_IN_LEN, including the quote 
characters. 

$MIM_INT 

A universal integer literal 
whose value is SYSTEM.MIN_INT. 

SMIN_TASK_SIZE 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
no entries, no declarations, and 
"NULL;" as the only statement in 
its body. 

SNAKE 

A name of a predefined numeric 
type other than FLOAT, INTEGER, 
SHORT_FLOAT, 3H0RT_INTEGER, 

L0NG_FL0AT, or LONG_INTEGER. 

$NAME_LIST 

A list of enumeration literals 
in the type SYSTEM.NAME, 
separated by commas. 

$NEG_8ASED_INT 

A based integer literal whose 
highest order nonzero bit 
falls in the sign bit 
position of the representation 
for SYSTEM.MAX TNT. 


Value 


"2:" £ 235 * 'O' £ "11:" 


"16:" £ 233 * 'O' £ "F.E:" 


" £ 233 * ’A' £ 


-2147483643 


NO SUCH TYPE AVAILABLE 


TI320C30 


16#FFFFFFFE# 





TEST PARAMETERS 


Name and Meaning 
$NEV_MEH_SIZE 

An integer literal whose value 
is a permitted argument for 
pragma MEMORY_SIZE, other than 
$DEFAULT_MEM_SIZE. If there is 
no other value, then use 
$DETAULT_MEM_SIZE. 

$NEW_STOR_UNIT 

An integer literal whose value 
is a permitted argument for 
pragma STORAGE_UNIT, other than 
$DEFAULT_STOR_UNIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGE JJNIT. 

$NEW_SYS_NAME 

A value of the type SYSTEM.NAME, 
other than $DEFAULT_SYS_NAME. If 
there is only one value of that 
type, then use that value. 

$TASK_SIZE 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
a single entry with one 'IN OUT' 
parameter. 

STICK 

A real literal whose value is 
SYSTEM.TICK. 


Value 

16777216 


TI320C30 

96 


0.0001 





WITHDRAW TESTS 


APPENDIX D 
WITHDRAWN TESTS 

Some tests are withdrawn from the ACVC because they do not conform to the 
Ada Standard. The following 44 tests had been withdrawn at the time of 
validation testing for the reasons indicated. A reference of the form 
Al-ddddd is to an Ada Commentary. 

a. E28005C This test expects that the string "— TOP OF PAGE. 

63" of line 204 will appear at the top of the listing page due 
to a pragma PAGE in line 203; but line 203 contains text that 

follows the pragma, and it is this that must appear at the top 
of the page. 

b. A39005G This test unreasonably expects a component clause to 

pack an array component into a minimum size (line 30). 

c. B97102E This test contains an unitended illegality: a select 

statement contains a null statement at the place of a selective 
wait alternative (line 31) . 

d. C97116A This test contains race conditions, and it assumes that 
guards are evaluated indivisibly. A conforming implementation 
may use interleaved execution in such a way that the evaluation 
of the guards at lines 50 & 54 and the execution of task CKANGING- 
_OF_THE_GUARD results in a call to REPORT.FAILED at one of 

4 lines 52 or 56. 

e. BC3009B This test wrongly expects that circular instantiations 
will be detected in several compilation units even though none of 
the units is illegal with respect to the units it depends on; by 
AI-00256, the illegality need not be detected until execution is 
attempted (line 95) . 

f. CD2A62D This test wrongly requires that an array object's size 
be no greater than 10 although its subtype's size was specified 
to be 40 (line 137) . 

g. CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] These 
tests wrongly attempt to check the size of objects of a derived 
type (for which a ‘SIZE length clause is given) by passing them 
to a derived subprogram (which implicitly converts them to the 
parent type (Ada standard 3.4:14)). Additionally, they use the 
'SIZE length clause and attribute, whose interpretation is 
considered problematic by the WG9 ARG. 










h. CD2A31G. CD2A33G, CD2A34N 5 A, 5 CD50110 o tests] These tests 

assume that dependent tasks will terminate while the main pro¬ 
gram executes a loop that simply tests for task termination; this 
is not the case, and the main program may loop indefinitely 

(lines 74, 85, 36 & 96, 36 5 96, and 53, resp.). 

i. CD2B15C & CD7205C These tests expect that a 'STORAGE_5IZE 
length clause provides precise control over the number of 
designated objects in a collection; the Ada standard 13.2:15 
allows that such control must not be expected. 

j. CD2D11B This test gives a SMALL representation clause for a 

derived fixed-point type (at line 30) that defines a set of 
model numbers that are not necessarily represented in the 
parent type; by Commentary AI-00099, all model numbers of a 
derived fixed-point type must be representable values of the 
parent type. 

k. CD5007B This test wrongly expects an implicitly declared sub¬ 

program to be at the the address that is specified for an un¬ 
related subprogram (line 303). 

l. ED7004B, ED7005C & D, ED7006C & D [5 tests] These tests check 

various aspects of the use of the three SYSTEM pragmas; the AVO 
withdraws these tests as being inappropriate for validation. 

m. CD7105A This test requires that successive calls to CALENDAR.- 

CLOCK change by at least SYSTEM.TICK; however, by Commentary 

AI-00201, it is only the expected frequency of change that must 
be at least SYSTEM.TICK—particular instances of change may be 
less (line 29). 

n. CD7203B, & CD7204B These tests use the ’SIZE length clause and 
attribute, whose interpretation is considered problematic by 
the VG9 ARG. 

o. CD7205D This test checks an invalid test objective: it treats 

the specification of storage to be reserved for a task’s 
activation as though it were like the specification of storage 
for a collection. 

p. CE2107I This test requires that objects of two similar scalar 
types be distinguished when read from a file—DATA_ERR0R is 
expected to be raised by an attempt to read one object as of 
the other type. However, it is not clear exactly how the Ada 
standard 14.2.4:4 is to be interpreted; thus, this test objective 
is not considered valid. (line 90) 

q. CE3111C This test requires certain behavior, when two files are 

associated with the same external file, that is not required by 








WITHDRAWN TESTS 


the Ada standard. 

r. CE3301A This test contains several calls to END_OF_LINE « 
END_OF_PAGE that have no parameter: these calls were intended 
to specify a file, not to refer to STANDARD_INPUT (lines 103, 
107, 118, 132, & 136) . 

s. CE3411B This test requires that a text file's column number be 

set to COUNT’LAST in order to check that LAYOUT_ERROR is raised 
by a subsequent PUT operation. But the former operation will 

generally raise an exception due to a lack of available disk 

space, and the test would thus encumber validation testing. 








APPENDIX E 


COMPILE? AND LINKER OPTION 






Chapter 3 

Compiling Ada Programs 


The tada command is used to compile and assemble Ada compilation units. 

3 . 1 . THE tada COMMAND FORMAT 

The t ada command has this format: 

cada [ option ...] file... [option...] 

Arguments that start with a hyphen are interpreted as options; otherwise, they represent filenames. There 
must be at least one filename, but there need not be any options. Options and filenames may appear in any order, 
and all options apply to all filenames. For an explanation of the available options, see Section 3.2. 

If a source file does not reside in the directory in which the compilation takes place, file must include a path 
sufficient to locate the file. It is recommended that only one compilation unit be placed in a file. 

Files are processed in the order in which they appear on the command line. The compiler sequentially 
processes all compilation units in each file. Upon successful compilation of a unit: 

• the Ada program library ada . db is updated to reflect the new compilation ume and any new dependencies 

• one or more separate compilation files and/or object files are generated 

If no errors are detected in a compilation unit, tada produces an object module and updates the library. If any 
error is detected, no object code file is produced, a source listing is produced, and no library entry is made for 
that compilation unit. If warnings are generated, both an object code file and a source listing are produced. For 
further details about the process of updating the library, files generated, replacement of existing files, and 
possible error conditions, see Sections 3.3 through 3.6. 

The output from tada is a file of type .stof or . tof, for a specification or a body unit respectively, 
containing object code. Some other files are left in the directory as well. See Section 3 A for a List of extensions 
of files that may be left in the directory. 

3 . 2 . OPTIONS 

Command line options indicate special actions to be performed by the compiler or special output file 
properues. 

The following command line options may be used: 

-a Generate an assembly code file. The assembly code file has an extension . s or .as 

(see Section 3.4). 

-g Output debugging information. 

- 1 Cause compiler to omit data segments with the text of enumeration literals. This text 

is normally produced for exported enumeration types in order to support the 
' IMAGE attribute. You should use -i only when you can guarantee that no unit 
that will import the enumeration type will use ' IMAGE. However, if you are 
compiling a unit with an enumeration type that is not visible to other compilation 
units, this option is not needed. The compiler can recognize when ' IMAGE is not 
used and will not generate the supporting strings. 


3-1 





USER MANUAL FOR TARTAN ADA VMS C30 


-La Generate a listing, even if no errors were found. The default is to generate a listing 

only if an error is found. 

-Ln Never generate a listing. The default is to generate a listing only if an error is found. 

-n=n Stop compilation after n errors have been detected. 

-Op n Control the level of optimization performed by the compiler, requested by n. The 

optimization levels available are: 

n = 0 Minimum - Performs context determination, constant folding, al¬ 
gebraic manipulation, and short circuit analysis. 

n = 1 Low - Performs level 0 optimizations plus common subexpression 
elimination and equivalence propagation within basic blocks. It 
also optimizes evaluation order. 

n = 2 Space - This is the default if none is supplied. Performs level 1 
optimizations plus flow analysis which is used for common sub¬ 
expression elimination and equivalence propagation across basic 
blocks. It also performs invariant expression hoisting, dead code 
elimination, and assignment killing. Level 2 also performs lifetime 
analysis which is used to improve register allocation. It also per¬ 
forms inline expansion of subprogram calls indicated by Pragma 
INLINE which appears in the same compilation unit. 

n = 3 Time - Performs level 2 optimizations plus inline expansion of 
subprogram calls which the optimizer decides are profitable to ex¬ 
pand (from an execution time perspective). Other optimizations 
which improve execution time at a cost to image size are per¬ 
formed only at this level. 

Print out compiler phase names. The compiler prints out a short description of each 
compilation phase in progress. 

-q Do not print out compiler phase names. 

-w Suppress warning messages. 

-5 [acdezlorsz] Suppress the given set of checks: 

A ACCESS_CHECK 

C CONSTRAINT_CHECK 

D DISCRIMINANT_CHECK 

E ELABORATION_CHECK 

I INDEX_CHECK 

L LENGTH_CHECK 

0 OVERFLCW_CHECK 

R RANGE_CHECK 

S STORAGE_CHECK 

Z "ZERO"DIVISION_CHECK 

The -S option has the same effect as a global pragma SUPF 'ESS applied to the 
source file. If the source program also contains a pragma SUPPRESS, then a given 
check is suppressed if either the pragma or the switch specifies it: that is, the effect 
of a pragma SUPPRESS cannot be negated with the command line option. See 
LRM 11.7 for further details. Examples are: 

-SOZ Suppress OVEAFLOW_CHECK and "ZERO"DIVISICN_CHECK. 

-S Suppress all checks. 


3-2 






COMPILING ADA PROGRAMS 


-SC Suppress CONSTRAINT_ERROR, equivalent to -SADILR. 

-x Cause the compiler to generate a cross reference file containing entries of the form 

Ada-name*‘>linkname at line 

This option will allow users to find the linkname generated for the given Ada-name, 
and use linkname to set breakpoints in debuggers. The file will have the extension 
. xrf (See Section 3.5). 

In addition, the output from the compiler may be redirected using the redirection facility including for 
stderr; for example 

% tada tax_spec.ada >& tax_spec.txt 

3.3. WHAT UPDATES ARE MADE TO THE PROGRAM LIBRARY 

Simply stated, upon successful compilation of a unit, 

• the Ada program library ada. db is updated to reflect the new compilation time and any new dependencies 

• one or more separate compilation files and/or object files are generated. 

However, more complicated situations can arise. The following items list the types of compilation unit and 
address the range of situations that can arise. 

• In all cases the transitive closure of the dependencies of a compilation unit in the library must be consis¬ 
tent; that is, the unit must be compiled consistently as defined in section 10.3 of the LRM. A secondary 
unit can have its specification in its context clause, although it is redundanL For a more complete 
discussion of closure, see Section 4.5. 

• A package specification replaces any library unit in the library with the same name, or is simply added if 
no such library unit exists. 

• A package body replaces any existing body of a package specification with the same name. If no such 
specification exists, an error message is issued, if such a specification »xists, but the body does not match 
the specification in the sense of Section 7.1 of the LRM, error message, re issued. 

• A subprogram specification replaces any library unit in the library with the same name, or is simply 
added if no such library unit exists. 

• A subprogram body replaces any existing body of a (generic or non-generic) subprogram specification 
with the same name. If no such specification exists, an implicit specification is derived from the body and 
entered into the library as noted above for subprogram specification. If a specification exists, but the body 
does not match the specification in the sense of Section 6.3 of the LRM. error messages are issued. If any 
library unit other than a subprogram specification exists with the same name, the new implicit specification 
replaces that library unit 

• Generic package specifications and subprogram specifications act as explicit specifications, i.e., cor¬ 
responding bodies must match their specifications. If a generic unit is instantiated, a dependency is created 
on the generic body. 

• Generic instances compiled as library units are treated in the same way as their non-generic counterparts. 

• When an instantiation replaces the body of a library unit, all secondary units of that library unit are now 
obsolete and are deleted. 

• A subunit with a parent unit containing an appropriate body stub existing in the library replaces any 
subunit with the same subunit name, comprised of the stub’s name and the name of the ancestor unit, or is 
simply added, if no such subunit exists. A unit containing stubs will only be entered into the library if the 
simple names of all its stubs are unique for all stubs derived from its common ancestor. An error message 
is issued if no parent unit exists in the library, the parent unit exists but does not have a relevent stub, or the 
parent unit and body stub exist but the subunit does not match the stub or its specification. 


3-3 







USER MANUAL FOR TARTAN ADA VMS C30 


• When the parent unit of a subunit is recompiled and the parent no longer contains a stub for the subunit, 
the subunit, which is now obsolete, is deleted. 

3.4. FILES PRODUCED OR USED BY THE COMPILATION SYSTEM 

Files with the following extensions are contained in the standard packages directories or can be created by 
compiling or linking an Ada program; the file name is the name of a compilation unit, but may be compressed to 
conform to length limitations. 

bod Representation of the body of a generic, and/or the visibility information available to 

any subunits or generic bodies, body-name. bod is read when compiling a program that 
instantiates body-name or a generic contained in a body-name, or is a subunit of 
body-name. 

di Representation of a unit specification, unit-name . di is read during the compilation of a 

program that does a "with unit-name''. 

1st A listing produced by the Ada compiler. 

map A link file produced by the Tartan linker. 

asm The assembly language file produced by compiling an Ada unit body when the -a 

option is given. 

s t o f The object file produced by compiling an Ada unit specification, 

to f The object file produced by compiling an Ada unit body. 

xrf Cross reference files that relate Ada names with compressed and disambiguated names 

used in the object or assembly language file. 

:<t o f An executable image created by linking a main program. 

The following are the extenstions used for files that are created temporarily during the linking process: 

etof The elaboration script generated by the library 

lis List of all object files to be linked by the linker 

1 c f Control file for the linker. 

Additionally, temporary files are created during compilation that have the same file extensions listed above, but 
also have a unique 8 digit hexadecimal number concatenated to the extension. Any of the above files will appear 
in the directory only if a link or compilation is abnormally terminated. These files should then be deleted by the 
user. 

Files having the following extensions are controlled by the librarian and compiler: di, bod. cof and stof. 
The user should not use these extensions for any other purpose. The aiib delete command will automati¬ 
cally delete these files, when the respective unit is deleted from the library. If the user deletes these files in any 
other way, subsequent invocations of the compiler or librarian will have unpredictable results, including fatal 
crashes. We therefore advise that the user never delete these files by operating system commands. 

3.5. THE CROSS REFERENCE MAP OF LINKNAMES 

A cross reference of symbolic names to linknames is generated with the option -x to the tada command. 
The cross-reference file has the extension .xrf; the file name is that of the compiled unit, but possibly 
compressed to match restrictions, as shown in the example below. 

For longer unit-names, the cross reference file generated may not have an immediately obvious name, in 
order to find it, it may be necessary to search the current working directory for a recently produced file with 
extenuon xrf. 


3-4 









COMPILING ADA PROGRAMS 


Example: 

File crexample_spec. ada 

package thi s_i s_a_long_package_mame is 
package ANOTHER_LONG_PACKAGE_NAME is 

procedure LONG_PROCEDURE_NAME_THAT_WILL_HAVE_SHORT_LINKNAME; 
end ANOTHER_LONG_PACKAGE_NAME; 
end THIS_IS_A_LONG_PACKAGE_NAME; 

File crexample_body. ada 

package body THIS_IS_A_LONG_PACXAGE_NAME is 

package body ANOTHER_LONG_?ACKAGE_NAME is separate; 
end THIS_IS_A_LONG_?ACKAGE_NAME; 

File crexample. sep 

separate (This_is_a_long_package_name) 
package body another_long_packag'e_name is 

procedure LONG_PROCEDURE_NAME_THAT_WILL_HAVE_SHORT_LINKNAME is 

begin 

null; 

end lcng_procedure_name_that_will_have_shcrt_l:nkname; 

end ANOTHER_LONG_PACKAGE_NAME; 

The commands: 

tada crexample_spec.ada 
tada crexample_body.ada 
tada -x crexample.sep 

produce the file thsslngpckgnm. nthrlngpckgnmeOOl .xrf which appears below: 

- Linkname Cross Reference Map thsslngpckgnm.nthrlngpckgnmeOOl - 

this_rs_a_long_package_name=>>xxthsskgnm001 at 0 

thj.s_is_a_long_package_nameythrs_is_a_long_package_name=>thrs_rs_a_long 
_package_nameYOO at 1 

this_is_a_long_package_nameYanother_long_package_nameYanother_iong_package 
_name«>another_long_package_nameYOO at 2 

chis_is_a_long_package_nameYanother_long_package_nameYlong_procebure_name 
_that_will_have_short_linkname=>xxths3kgnm001YlngprcdtlnknmY00 at 3 

In the above cross reference file: 

• The first line represents the name for the elaboration code for the package 

THIS_IS__A_LONG_PACKAGE_NAME. The symbols representing the specification and body have 
respectively YDECLARE and YBODY postpended. 

• The second line is the name of the data segment for the package THIS_is_A_lgng_?ackage_name. 

• The third line is the name of the data segment for the package ancther_long_?ackage_name. 

• The name for the long_?ROCEDURE_name_that_will_have_5hcrt_linkname procedure is on 
the fourth line. 

• The fifth line is the name for the elaboration variable for the procedure 

LONG_PROCEDURE_NAME_THAT_wlLL__HAVE_SHORT_LINKNAME. Ada rules require that the body 
of a subprogram is already elaborated before it can be called. If it is not already elaborated the exception 
?ROGRAM_ERROR must be raised. For each subprogram that may require an elaborauon check the 
compiler generates a variable that is used to record that the body of the subprogram has been elaborated. 
The name of the elaboration variable is generated by postpending YGOTO to the name of the subprogram. 
The elaboration variable name is then subject to the same compression algorithms as the rest of the 
symbols in the program. 


3-5 







USER MANUAL FOR TARTAN ADA VMS C30 


The SunOS command 
Is -It *.xrf 

will help you locate the cross reference listing. In order to view the contents of the cross reference File, make 
sure that your terminal is set to wrap around mode. The identifier appearing at the left is the identifier that 
appears in the Ada source code. The name to the right of the *=>’ is the linkname that is supplied for that 
identifier to Id. The “at <number>" gives the line number in the source code where the identifier is found. 
A Cross Reference Map can be used to verify that there are no conflicting linknames in a program library that 
uses subprograms written in another language (see Section 5.1.2.2 that discusses the pragma ? OREIGN_BCDT). 
It is also useful for assembly-level debugging. 

3.6. COMPILER DIAGNOSTIC MESSAGES 

The compiler and library issue diagnostic messages that appear at your terminal and in the optional compiler- 
generated listing. Most messages issued by Tartan Ada VMS C30 contain a reference to the Ada LRM section 
and paragraph relevant to the error. This section explains the kinds of diagnostic messages that are generated, 
how the compiler attempts to deal with problems that caused the messages and how you should go about 
correcting a program. 

A comprehensive listing of all the messages the compiler can issue is contained in Appendix Section A.l. A 
similar listing of all the messages the library can issue is contained in Appendix Section A.2. 

3.6.1. Message Severity Levels 

Every message issued by the compiler is assigned a severity level that indicates how serious the problem is. 
There are four message categories. 

1. A fatal error is serious enough to suspend compilation immediately after the error is discovered. This is 
the only class of error that inhibits further analysis of the source program. An example of a fatal error 
message (in this case from the library) is: 

Fatal 6801: <library administration file name> is mcompatioie 
with this version of the library. 

2. An error is serious enough to prevent the generation of object code, but the compiler attempts to recover 
from the error and continues checking the source for additional errors. An example of an error is: 

Error 2060: This record field has already been assigned 
in the aggregate (4.3 (6)) 

3. A warning does not stop the compiler from generating object code, but may still be an indication of a 
programming error. When a warning occurs, the code generated may not be what you intended. An 
example of a warning is: 

Warn 4001: Elaboration of this subtype will raise constramt_error 
at runtime (3.3.2). 

4. An informational message provides you with additional information when you use some library com¬ 
mands (see, for example. Section 4.6). Informational messages are issued only by the library, not by the 
compiler. An example of an informational message is: 

Info 6011: The files required for linking by <unitjdnd> 

<unit_name> are consistent (10.3). 

3.6.2. Message Formats 

The format of messages appearing on the standard error output and in the listing file is similar. Here is 3n 
example: 


3-6 









COMPILING ADA PROGRAMS 


51 si : string(1 .. discrim); 

6! s2 : string(1 .. 2 * discrim); 

"1 

*** l Error 2204: A discriminant may not be used in this 
*** expression (3.7.1 (6)) 

7| end record; 

The numbered lines in the example are lines from the source program. The source line in question is followed by 
the messages and pointers to the exact location of the problem. 

On the terminal, horizontal lines are used to separate messages coming from different parts of the source 
program, for example: 

5 1 si : stringd .. discrim) ; 

') s2 : stringd . . 2 * discrim) ; 

n 

*** 1 Error 2204: A discriminant may not be used 

*** in this expression (3.7.1 (6)) 


7 1 

end record; 



14 1 

null; 



15! 

when numenc_ 

_error 

1 const ramt_error => 

/N 1 

★ * * ^ 

Error 3112: A 

given 

exception may only appear once 

★ * * 

in a handler 

(11.2 

(5) ) 

161 

null; 




In a listing file, a message chain accompanies each diagnostic message. The message chain indicates where 
in the program the next and previous messages occur, for example: 


3-7 



USER MANUAL FOR TARTAN ADA VMS C30 


Ada C30 Copyright 1986, 1989, Tartar. Laboratories Incorporated 
*** First diagnostic is on line 6 

1|procedure samp!e_program is 

21 subtype small_int is integer range 1 . . 10; 

31 

4| type rec(discrim ; small_int) is record 

5! si ; string(1 .. discrim) ; 

61 s2 : string(1 . . 2 ’ discrim); 

»** 1 Error 2204: A discriminant may not be used m this 

*** expression (3.7.1 (6)) 

*** Next diagnostic is on line 15 

7| end record; 

81 

9 I x : rec (5); 

10ibegin 

111 x := (6, "12345”, "abode”); 

12iexception 

13 I when constraint_error => 

14| null; 

151 when numenc_error | constramt_error => 

A 1 

Previous diagnostic was on line 6 
*** 1 Error 3112: A given exception may only appear once 

*** in a handler (11.2 (5)) 

16| null; 

17 : end sarriDle_program; 

13 1 

Last diagnostic was on line 15 

*” Errors: 2, Warnings: 0 
The message chain is especially helpful when working with large listings. 

Whether on the standard error output or in a listing file, the list of messages is followed by a summary line 
containing a count of the number of errors in each seventy class, for example: 

? Errors: 2, Warnings: 1 

3.6.3. Message Generation 

Tartan Ada VMS C30 has many internal phases, any one of which can issue diagnostic messages. Messages 
are collected in memory until the time comes to generate the message listing. At that time, all the messages are 
sorted by their position in the source program and are pnnted. 

When you examine a program listing containing many messages, remember that the order in which the 
messages appear in the listing is not necessarily the order in which the messages were generated. This fact may 
be important when one error causes another. It is advisable to start correcung your program according to the 
messages having the lowest numbers and work towards the higher numbers, making an intermediate compilation 
:f necessary. 

3.6.4. About Syntax Errors and Recovery 

Tartan Ada VMS C30 incorporates a parser which is capable of analyzing and correcting ail syntactic errors 
in the source program. This section describes the various enor messages that may be issued by the parser. When 
a syntax error is detected, no object code is generated. 

The parser divides the source program text into lexical elements, or tokens, such as ldenufiers, reserved 
words, constants, etc. When the parser encounters a token that it does not expect, it issues an error message that 


3-8 










COMPILING ADA PROGRAMS 


indicates the position at which the error was detected and the acrion that was taken to correct the error. Here are 
some examples of the recovery actions: 

In the example below, the trailing does not match any of the valid tokens of Ada and so the parser 
deletes it. 

11 procedure bad_syntax is 

21 subtype byte is integer range 0 .. 255; 3 

*** 1 Error 104: Ill-formed token deleted. 

31 x : integer; 

The compiler also deletes a token occupying an inappropriate place. In the following example, it deletes the 
superfluous token “while". 

5 I begin 

61 for while i in 1 10 Iood 

-'l 

*** 1 Error 121: Parse error; token deleted. 

71 x x + 1; 

In the following example, the missing symbol is inserted, and parsing continues undisturbed. 

41 i : integer 

51 b : boolean; 

"1 

*** 1 Error 120: Parse error; token ";" inserted. 

6 I begin 

In the following example, the syntactically incorrect symbol is replaced by the proper symbol 

17| end loop; 

13 1 x :=■ 15: 

"1 

*** 1 Error 122: Parse error; this token deleted, inserted. 

191 

3.6.4.1. Multi-Token Insertion 

The parser may also insert several tokens in an attempt to repair the constructs whose closing tokens (e.g., 
“end if ;”) are missing. An example of this recovery is: 

10i end if; 

111 end loop; 

"1,2,3 

*** 1 Error 120: Parse error; token ''if" inserted. 

*** 2 Error 120: Parse error; token inserted. 

*** 3 Error 120: Parse error; token "end" inserted. 

12 I end bad_proc; 

In this example an additional “end if; ” was missing. Note, however, that the maximum number of 
tokens that can be inserted in succession is limited. 

3.6.4.2. Complex Recovery Strategy 

If all the simple fix-up and multi-token insertion techniques above are unsuccessful, the parser attempts a 
more massive correcuon by deleung many successive or preceding phrases of the program. For example. 


5 i 

y : = 6 ; 

case bad_case is 

6* 


where x=y 

=» > x : = 3; 

7* 

Error 123: 

Parse error; 
when 2 := 

ill-formed "<stauement>' 
x * 5; 


The caret ( A ) locates the place where the parser detects an error. The compiler indicn'c^ the elided portion of 
the source program by underlining with asterisks. In the first (and possibly the last line), only the tokens deleted 


3-9 








