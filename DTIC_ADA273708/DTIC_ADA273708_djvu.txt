REPORT DOCUMENTATION PAGE 


Form Approved 
OPMNo. 


Public reporting burden tor thie collection of intormation is estimated to average 1 hour per response, including the time tor reviewing instructions, searchrig existing data sourcaS*gfllfenng 
and maintaining the data needed, arxi reviewing the collection of intormation. Send comments regarding this burden estimate or any other aspect of this collection of information, including 
suggestions tor reducing this burden, to Washington Headquarters Service, Directorate tor Information Operations and Reports, t2t5 Jefferson Davis Highway, Suite 1204, Arlington, VA 
22202-4302, and to the Office of Information and Regulatory Affairs, Oflioe of Management and Budget, Washington, DC 20S03, 


1. AGENCY USE 


I 4. TITLE AND 


(Leave 


I 2. REPORT 


3. REPORT TYPE AND DATES 

Final: 15 October 1993 to 15 October 1995 


15. FUNDING 


TLD Comanche VAX/MIL-STD-1750 A Ada Compiler System, Version 
3.4.C Digital VAXstation 4000 Model 60 under VMS, 5.5 =) 

TLD MIL-5TD-1750A Multiple Processor Simulator (TLDmps) under 
6. I LU Rd Tr rVme Lx~tT v e ( I LUrtx), J.4.C, 9310121^1. - 

Authors: 

Wright-Patterson AFB OH 45433-6503 

7. PERFORMING ORGANIZATION NAME(S) AND 

Ada Validation Facility, Control Facility ASD/SCEL 
Bldg. 676, Rm 135 

Wright-Patterson AFB, Dayton, OH 45433 


AD-A273 708 

I Ilfcllll llli Hill rr... — * 


8. PERFORMING 
ORGANIZATION 

AVRaVSR-575.0993 


9. SPONSORING/MONITORING AGENCY NAME{S) AND 

Ada Joint Program Office 
The Pentagon, Rm 3E118 
Washington, DC 20301-3080 


10. SPONSORING/MONITORING 
AGENCY 


11. SUPPLEMENTARY 


12a DISTRIBUTION/AVAILABILITY 


App’oved for public release; distribution unlimited. 


112b. DISTRIBUTION 


3. (Maximum 200 

TLD Comanche VAX/MIL-STD-1750A Ada Compiler System, Version 3,4.C 
Host: Digital VAXstation 4000 Model 60 under VMS, 5,5 

Target: TLD MIL-STD-1750A Multiple Processor Simulator (TLDmps) under TLD Real Time 
Executive (TLDrtx), 3.4.C 


CdEC141903| 


14. SUBJECT 


115. NUMBER OF 


Ada progranming language, Ada Compiler Val. Summary Report, Ada c . 

Compiler, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-18I5A, AJPO 


17. SECURITY 

CLASSIFICATION 

UNCLASSIFIED 


118. SECURITY 


UNCLASSIFIED 


19. SECURITY 
CLASSIFICATION 

UNCLASSIFIED 


20. LIMITATION OF 

UNCLASSIFIED 

Standard Form 298, (Rev. 2-89) 
Prescribed by ANSI Std. 









AVF Ccmtrol NiflBber: AVF-VSR-575.0993 
Date VSR Conpleted: 15 October 1993 

93-08-17-TLD 


Ada COMPILER 
VALIDATION SUMMARY REPORT! 

Certificate Number: 931012W1.11329 
TLD Systems, Ltd. 

TLD Comanche VAX/MIL-STD-1750A Ada Compiler System, Version 3.4.C 
Digital VAXstation 4000 Model 60 \jnder VMS, 5.5 ■> 

TLD MIL-STT>-1750a Multiple Processor Simulator (TLDmps) 
under TLD Real Time Executive (TLDrtx), 3.4.C 


(Final) 


Prepared By: 

Ada Validation Facility 
645 CCSG/SCSL 

Wright-Patterson AFB CXI 45433-6503 


^ 3""30259 

■nil iiiu ««• ^ ^ 


!l 


i 


93 i2 13 076 









Certificate Znfomation 


The following Ada inplementation was tested and determined to pass ACVC 1.11. 

Testing was completed on 12 October 1993. 

Compiler Name and version: TID Comanche V2OC^I^STT>-1750A Ada Compiler System, 

Version 3.4.C 

flost Computer System: Digital ViOCstation 4000 Model 60 

un^r VMS, 5.5 

Target Computer System: TLD H1L-STO-1750A Multiple Processor Simulator (TLDops) 

imder TIi> Real Time Executive (TLDrtx), 3.4.C 

Customer Agreement Nuiaber: 93-08-17-TLD 


See sectim 3.1 for any additional information about the testing environment. 

As a result of this validation effort, Validation Certificate 931012W1.11329 
is awarded to TLD Systems, Ltd. This certificate expires two years after 
HIL-STD-ISISB is approved by ANSI. 


This report has been reviewed and is approved. 



Dale E. Lange 
AVF Manager 
645 CCSG/SCSL 

Wright-Patterson AFB OH 45433-6503 


DTIC QUALITY INSPECTED 3 


Ada Valid^onf Organization 

Director, Compter and Software Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 



M. Dirk Rogers, Major, USAF 


Acting Director 
Department of Defense 
Washington DC 20301 





i , 


.1. 






DECLARATION OP CONFORMANCE 


Customer: TLD Systems, Ltd. 

Ada Validation Facility: 645 C-CSG/SCSL 

Wright-Patterson AFB OH 45433-6503 

ACVC Version: 1.11 


Ada Inplamentation: 


Conpiler Name and Version: TLD Comanche VAX/MIL-STD-1750A Ada 

Compiler System, Version 3.4.C 


Host Con^uter System: 

Target Computer System: 


Digital VAXstation 4000 Model 60 
executing VAX/VMS 5.5. 

TLD MIL-STD-1750A Multiple Processor 
Simulator (TLDmps) under TLD Real Time 
Executive (TLDrtx), Version 3.4.C 


Customer's Declaration 

I, the undersigned, representing TLD Systems, Ltd., declare that TLD 
Systems, Ltd. has no knowledge of deliberate deviations from the Ada 
Leuiguage Standard ANSI/MIL-STD-1815A in the implementation listed in this 
declaration executing in the default mode. The certificates shall be 
awarded in TLD Systems, Ltd.'s corporate neune. 


Date: 11 October 1993 

TLD Sy^ems; Ltd. 

Terry L. Dunbar, President 



VAX/175OA/TLDmps 


Page 1 








TABLE OF CC3NTENTS 


CHAPTER 1 INTROTUCnON 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFEREITCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST MC»IF1CATI0NS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 

APPENDIX C APPENDIX F OF THE Ada STANDARD 
















CHAPTER 1 


INTR(»UCnON 


The Ada implementation described above was tested according to the Ada 
Validation Procedures [Pro92) against the Ada Standard [Ada83] using the 
current Ada Conpiler Validation Capability (ACVC). This Vali^tion Summary 
Report (VSR) gives an account of the testing of this Ada implementation. For 
any technical terms xised in this report, the reader is referred to (Pro92]. A 
detailed description of the ACVC may be found in the current ACVC User's Guide 
[UG89]. 


1.1 USE OF THIS VALIOATIGN SUMMARY REPORT 

Consistent with the national laws of tM originating country, the Ada 
Certification Body may make full and free public disclosure of this report. 

In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply only 
to the computers, operating systems, and compiler versions identified in this 
report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are accurate 
and complete, or that the subject inplementation has no nonconformities to the 
Ada Standard other than those presented. Copies of this report are available 
to the public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results should be 
directed to the AVF vdiich performed this validation or to: 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1-1 






INTRODUCTION 


1.2 REFERENCES 

[AdaSB] Reference Manu al fo r t he Ada Progranminq Language , ANS1/MIL-STD-1815A, 
February 1983 and ISO 0652-1987. ^ 

(Pro92] Ada Compiler Validation Procedures > Version 3.1, Ada Joint 
Program Office, August 1992. 

(UG891 Ada Compiler Validation Capability User*s Guide , 21 Jxme 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC 
cwtains a collection of test programs structured into six test classes: A, B, 
C, D, E, and L. The first letter of a test naune identifies the class to which 
it belongs. Class A, C, D, and E tests are executable. Class B and class L 
tests are expected to produce errors at compile time and link time, 
respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result when they are 
executed. Three Ada library units, the packages REPORT and SPPRT13, and the 
procedure CHECR_FILE are used for this purpose. The package REPORT also 
provides a set of identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK_FILE is used to check the contents of text 
files written by some of the Class C tests for Chapter 14 of the Ada Standard. 
The operation of REPORT and CHBCK_FILE is checked by a set of executable 
tests. If these units are not operating correctly, validation testing is 
discontinued. 

Class B tests check that a compiler detects illegal language usage. Class B 
tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of the 
Ada Stan^rd are detected. Some of the class B tests contain legal Ada code 
which must not be flagged illegal by the compiler. This behavior is also 
verified. 

Class L tests check that an Ada implementation correctly detects violation of 
the Ada Standard involving multiple, separately compiled units. Errors are 
expected at link time, and execution is attempted. 

In somie tests of the ACVC, certain macro strings have to be replaced by 
inplementation-specific values — for example, the largest integer. A list of 
the values used for this implementation is provided in ^pendix A. in 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen ccmflicts between the tests and 
implementation-dependent characteristics. The modifications required for this 
implementation are described in sectim 2.3. 


1-2 








INTROXJCTICN 


For each Ada implementation, a customized test suite is produced by the AVF. 
This customization consists of making the modifications described in the 
preceding paragra^^, removing withdrawn tests (see section 2.1), and possibly 
removing seme inapplicable tests (see section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of the 
customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 

Ada Ccmopiler Ihe software and any needed hardware that have to be added to a 
given host and target emputer system to allow tremsformation 
of Ada programs into executable form and execution thereof. 

Ada Conpiler The meauis for testing compliance of Ada inplementations, 
Validation consisting of the test suite, the support programs, the ACVC 
Capability user's guide and the tenplate for the validation summary 

(ACVC) report. 

Ada An Ada compiler with its host computer system and its 

Inplementation target conputer system. 

Ada Joint The part of the certification body which provides policy and 
Program guid^ce for the Ada certification system. 

Office (AJPO) 

Ada Ihe part of the certification body vhich carries out the 

Validation procedures required to establish the conpliance of an Ada 
Facility (AVF) implementation. 

Ada Ihe part of the certification body that provides technical 

Validation guidauice for operations of the Ada certification system. 

Organization 
(AVO) 

Conpliance of The ability of the inpleroentation to pass an ACVC version, 
an Ada 

Implementation 

Computer A functional unit, consisting of one or more conputers and 

System associated software, that uses common storage for all or part 

of a program and also for all or part of the data necessary for 
the execution of the program; executes user-written or 
user-designated programs; performs user-designated data 
manipulation, including arithmetic operations and logic 
operations; and that can execute programs that modify 
themselves during execution. A computer system may be a 
stand-alone unit or may consist of several inter-connected 
xtfiits. 

Conformity Fulfillment by a product, process, or service of all 


1-3 






INTRCX30CTIGN 


requirements specified. 

Customer An individual or corporate entity who enters into an agreement 

with an AVF which specifies the terms emd conditions for AVF 
services (of any kind) to be performed. 

Declaration of A formal statement from a customer assuring that conformity 
Conformance is realized or attainable on the Ada implementation for which 
validation status is realized. 

Host Conputer A cooputer system v^ere Ada source programs are transformed 
System into executable form. 

Ina^licable A test that contains one or more test objectives found to be 
test irrelevant for the given Ada inplementation. 

ISO International Organization for Standardization. 

LRN The Ada standard, or Language Reference Manual, published as 

ANSI/MIL-STO-1815A-1983 and ISO 8652-1987. Citations from the 
LRM teike the form ''<6ection>.<s\jb8ection>:<paragraph>." 

Operating Software that controls the execution of programs and that 
System provides services such as resource allocation, scheduling, 

input/output control, and data management. Usually, operating 
systems are predominantly software, but partial or complete 
hardware inplementations are possible. 

Target A conputer system vdiere the executable form of Ada programs 

Ccmputer are executed. 

System 

Validated Ada The compiler of a validated Ada implementation. 

Conpiler 

Validated Ada An Ada implementation that has been validated successfully 
Inplementation either by AVF testing or by registration [Pro92]. 

Validation The process of checking the conformity of an Ada conpiler to 
the Ada programming language and of issuing a certificate for 
this inplementation. 

Withdrawn A test found to be incorrect and not used in conformity 

test testing. A test may be incorrect because it has an invalid 

test objective, fails to meet its test objective, or contains 
erroneous or illegal use of the Ada programning language. 


1-4 









CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 NIIHDBANN TESTS 

Itie follovring tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is available from either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 2 August 1991. 


E28005C 

B28006C 

C32203A 

C34006D 

C35508I 

C35508J 

cassosM 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

C83026A 

B83026B 

C8304IA 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA201IA 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD900SA 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 



2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant for 
a given Ada inplementation. Reasons for a test's inapplicability may be 
supported by documents issued by the ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this 
in^lementation, the following tests were determined to be ina{^licable for the 
reasons indicated; references to Ada Cotcnentaries are included as appropriate. 


2-1 







IMPLEHENmTZON DEPENDENCIES 


Tile following 285 tests have floating-point type declarations requiring 
more digits than SYSTEM.MAX_DIGITS: 


C24113F..Y (20 tests) 
C35706F..Y (20 tests) 
C35708F..Y (20 tests) 
C45241F..Y (20 tests) 
C45421F,.Y (20 tests) 
C45524F..Z (21 tests) 
C45641F..Y (20 tests) 


C35705F..Y (20 tests) 
C35707F..Y (20 tests) 
C35802F..Z (21 tests) 
C45321F..Y (20 tests) 
C45521F..Z (21 tests) 
C45621F..Z (21 tests) 
C46012F..Z (21 tests) 


The following 21 tests check for the predefined type SHORr_lNTEGER; for 
this iioplementation, there is no such type: 


C35404B 

B36105C 

C45231B 

C45304B 

C45411B 

C45412B 

C45502B 

C45503B 

C45504B 

C45504E 

C45611B 

C45613B 

C45614B 

C45631B 

C45632B 

B52004E 

C55B07B 

B55B09D 

B86001V 

C86006D 


CD7101E 

C35404D, C45231D, B86001X, C86006Ef and CD7101G check for a predefined 
integer type with a name other than INTEGER, LONG_INTEGER, or 
SHORT_INTEGER; for this inqplementation, there is no such type. 

C35713B, C45423B, B86001T, and C86006H check for the predefined type 
SHORT_FLQAT; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with a 
name other than FLOAT, L0NG_FLQAT, or SHORT_FLCAT; for this 
implementation, there is no such type. 

A35801E checks that FLOAT'FIRST..FLOAT'LAST may be used as a range 
constraint in a floating-point type declaration; for this implementation, 
that range exceeds the range of safe numbers of the largest predefined 
floating-point type and must be rejected. (See section 2.3.) 

C45531N..P and C45532M..P (8 tests) check fixed-point operations for 
types that require a SYSTEM.NAX_MANTISSA of 47 or greater; for this 
inplementation, 11AX_NANTISSA is less than 47. 

C45536A, C46013B, C46031B, C46033B, eni C46034B contain length clauses 
that specify values for 'SMALL that are not powers of two or ten; this 
implementation does not support such values for 'SMALL. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINEjCVERFLCMS is FALSE for floating point types and the results of 
various floating-point operations lie outside the range of the base type; 
for this inplementation, MACHINEjOVERFLOWS is TRUE. 

D64005F..G (2) tests use 10 levels of recursive procedure calls nesting; 
this level of nesting for procedure calls exceeds the capacity of the 
conpiler. 


2-2 







IMPLEMENTATION DEPENDENCIES 


B86001Y uses the name of a predefined fixed-point type other than type 
DURATION; for this inplementation, there is no such type. 

CA3004E..F (2 tests) check that a program will execute when an optional 
body of one of its library packages is made obsolete; this inplementation 
introduces additional dependences of the package declaration on its body 
as allowed by LRM 10.3(8), and thus the library unit is also made 
obsolete. (See Section 2.3.) 

LA5007S..T (2 tests) check that a program cannot execute if a needed 
library procedure is made obsolete by the recompilation of a library unit 
named in that procedure's context clause; this inplementation determines 
that the reconciled unit's specification did not change, and so it does 
not make the dependent procedure obsolete. (See Section 2.3.) 

CD1009C checks whether a length clause cam specify a non-default size for 
a floating-point type; this inclementation does not support such sizes. 

CD2A53A checks operations of a fixed-psoint type for which a length clause 
specifies a power-of-ten TYPE'SMALL; this implementation does not support 
decimal 'SMALLs. (See section 2.3.) 

Q)2A84A, CD2A84E, Q)2A84I..J (2 tests), amd Q>2A840 use length clauses to 
specify non-default sizes for access types; this inclementation does not 
support such sizes. 

The following 264 tests check operations on sequential, text, and direct 
access files; this implementation does not support external files (See 
Section 2.3 regarding EE3412C): 


CE2102A..C 

(3) 

CE2102G..H 

(2) 

CE2102K 


CE2102N..Y 

(12) 

CE2103C..D 

(2) 

CE2104A..D 

(4) 

CE2105A..B 

(2) 

CE2106A. .B 

(2) 

CE2107A. .H 

(8) 

CE2107L 


CE2108A..H 

(8) 

CE2109A..C 

(3) 

CE2110A. .D 

(4) 

CE2111A..1 

(9) 

CE2115A..B 

(2) 

CE2120A. .B 

(2) 

CE2201A..C 

(3) 

EE2201D. .E 

(2) 

CE2201F. .N 

(9) 

CE2203A 


CE2204A. .D 

(4) 

CE2205A 


CE2206A 


CE2208B 


CE2401A. .C 

(3) 

EE2401D 


CE2401E..F 

(2) 

EE2401G 


CE2401H..L 

(5) 

CE2403A 


CE2404A. .B 

(2) 

c:e2405b 


CE2406A 


CE2407A..B 

(2) 

CE2408A. .B 

(2) 

CE2409A..B 

(2) 

CE2410A..B 

(2) 

CE2411A 


CE3102A. .C 

(3) 

CE3102F..H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A. .C 

(3) 

CE3106A..B 

(2) 

CE3107B 


CE3108A..B 

(2) 

CE3109A 


CE3110A 


CE3111A..B 

(2) 

CE3111D..E 

(2) 

CE3112A..D 

(4) 

CE3114A..B 

(2) 

CE3115A 


CE3119A 


EE3203A 


EE3204A 


CE3207A 


CE3208A 


CE3301A 


EE3301B 


CE3302A 


CE3304A 


CE3305A 


CE3401A 


CE3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A..C 

(3) 

CE3403E..F 

(2) 

CE3404B..L 

»i) 

CE3405A 


EE3405B 


CE3405C..D 

(2) 

CE3406A..D 

(4) 

CE3407A..C 

(3) 

CE3408A..C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE3410C..E 

(3) 

EE3410F 


CE3411A 


CE3411C 


CE3412A 


EE3412C 


CE3413A..C 

(3) 

C:E3414A 


CE3602A..D 

(4) 

CE3603A 


CE3604A..B 

(2) 

CE3605A..E 

(5) 


2-3 








IMPLEKENIATION DEPENDENCIES 


CE3606A..B (2) 
CE3706D 
CE3806A..B (2) 
CE3905A..C (3) 


CE3704A..F (6) 
CE3706F..G (2) 
CE3806D..E (2) 
CE3905L 


CE3704M..O (3) 
CE3804A..P (16) 
CE3806G..H (2) 
CE3906A..C (3) 


CE3705A..E (5) 
C:e3805A..B (2) 
CE3904A..B (2) 
CE3906E..F (2) 


CE2103A, CE2103B, and CE3107A use an illegal file name in an attempt to 
create a file and expect NftME_ERROR to be raised; this implementation 
does not support external files and so raises USE ERROR. (See section 
2.3.) 


2.3 TEST MC»1FICATI0NS 

Modifications (see section 1.3) were required for 59 tests. 

Nb! CD2A81A is s\;ibject to two, distinct modifications as described below (the 
test name is marked with an asterisk). 

The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the way 
expected by the original tests. 

B22005Z B24009A B25002A B26005A B27005A B44004D 
B59001E B73004B B83012A B83033B BA2001E BA3006A 
BA3013A 

C34009D and C34009J were graded passed by Evaluation Modification as directed 
by the AVO. These tests check that 'SIZE for a cexnposite type is greater than 
or equal to the sum of its ccxtponents' 'SIZE values; but this issue is 
addressed by Al-00825, \4iich has not been considered; there is not an obvious 
interpretation. This implementation represents array components whose length 
depends on a discriminemt with a default value by implicit pointers into the 
heap space; thus, the 'SIZE of such a record type might be less than the sum 
of its conponents 'SIZES, since the size of the heap space that is used by the 
varying-length array conponents is not counted as part of the 'SIZE of the 
record type. These tests were graded passed given that the Report.Result 
output was "FAILED" and the only Report.Failed output was "INCORRECT 
'BASE'SIZE", frcxn line 195 in C34009D and line 193 in C34009J. 

A35801E was graded inapplicable by Evaluation Modification as directed by the 
AVO. The cortpiler rejects the use of the range FLOAT'FIRST. .FLOAT'LAST as the 
range constraint of a floating-point type declaration because the bounds lie 
outside of the range of safe numbers (cf. LRM 3.5.7:12). 

CA3004E..F (2 tests) were graded inapplicable by Evaluation Modification as 
directed by the AVO. These tests check that a program will execute when an 
optional body of one of its library packages is made obsolete. This 
implementation, for optimization purposes, compiles all conpilation units of a 
compilation into a single object module with a single set of control sections, 
collectively pooled constants, with improved addressing. As a consequence, 
the optional package body of these tests and its corresponding library unit 
have a mutual dependence, and thus the library unit is also made obsolete. 
This implementation-generated dependence is allowed by LRM 10.3(8). 


2-4 






IHPLENEMTMION DEPENDENCIES 


LA5007S..T (2 tests) were graded inapplicable by Evaluation Modification as 
directed by the AVO. These tests check that a program cannot execute if a 
needed library procedure is made obsolete by the recompilation of a library 
unit named in that procedure's context clause. This implementation determines 
that the reconciled unit's specification did not change, and so it does not 
make the dependent procedure obsolete; the program executes, calling 
Report.Failed. The AVO ruled that this behavior is acceptable, in light of 
the intent for the revised Ada standard to permit such accommodating 
recompilation; further deliberation by the AVO and ARC will determine whether 
these (and many related) tests will be withdrawn. 


The tests below were graded passed by Test Modification as directed by the 
AVO. These tests all use one of the generic support procedures, Length_Check 
or Enum_Check (in support files L£34CHEG(.ADA & ENUMCHEK.ADA), which use the 
generic procedure Onchecked_Conversion. This inclementation rejects 
instantiations of Unchecked Conversion with array types that have non-static 
index ranges. The AVO ruled that since this issue was not addressed by 
AI-00590, ^ich addresses required support for Unchecked Conversion, and since 
AI-00590 is considered not binding under ACVC 1.11, the support procedures 
could be modified to remove the use of Unchecked_Conversion. Lines 40..43, 
50, and 56..58 in LENCHECK and lines 42, 43, and 58..63 in ENUMCHEK were 
commented out. 


CD1009A 

CD1C04D 

*CD2A81A 

CD3015K 


CD1009I CD1009M 
CD2A21A..C CD2A22J 
CD3014C CD3014F 
CD3022A CD4061A 


CD1009V 
CD2A23A. .B 
CD3015C 


CD1009W 

CD2A24A 

CD3015E..F 


CD1C03A 
CD2A31A. .C 
CD3015H 


♦CD2A81A, CD2A81B, CD2A81E, CD2A83A, CD2A83B, CD2A83C, and CD2A83E were graded 
passed by Test Modification as directed by the AVO. These tests check that 
operations of an access type are not affected if a 'SIZE clause is given for 
the type; but the standard customization of the ACVC allows only a single size 
for access types. This in?)lementation uses a larger size for access types 
whose designated object is of type STRING. The tests were modified by 
incrementing the specified size $ACC_SIZE with '+ 32'. 

CD2A53A was graded inapplicable by Evaluation Modification as directed by the 
AVO. The test contains a specification of a power-of-10 value as 'SMALL for a 
fixed-point type. The AVO ruled that, under ACVC 1.11, support of decimal 
'SMALLS may be omitted. 


CE2103A, CE2103B, and CE3107A were graded inapplicable by Evaluation 
Modification as directed by the AVO. The tests abort with an xonhandled 
exception when USE_ERROR is raised on the attenpt to create eur» external file. 
This is acceptable behavior because this inplementation does not support 
external files (cf. AI-00332). 


EE3412C was graded inapplicable by Evaluation Modification as directed by the 
AVO. This test checks the operation of TEXT_I0.LINE, and it assumes that 
package Report uses TEXT_IO. For this validation, package Report was modified 
to use a more efficient character output procedure. As a consequence of the 
modification to Report, a call to a Report procedure doesn't increment the 


2-5 







INPLE31EN1ATIGN DEPENDEITCIES 


line count, emd the check at line 46 fails. Ihe AVO ruled that this test be 
graded inapplicable, and that it remain in the set of I/O tests that is 
normally not processed during on-site testing for implementations that do not 
support file systems. 

CE3413B was graded inapplicable by Evaluation Modification as directed by the 
AVO. This test includes the expression "COONT'LAST > 150000", which raises 
CONSTRAINT_EKE«JR on the inplicit conversion of the integer literal to typ>e 
COUNT since COUNT'LAST - 32,767; there is no heuidler for this exception, so 
test execution is terminated. The AVO ruled that this behavior was 
acceptable; the AVO ruled that the test be graded inapplicable because it 
checks certain file operations and this inplementation does not support 
external files. 

Many of the Class A and Class C (executable) test files were combined into 
single procedures ("bundles") by the AVF, according to information supplied by 
the customer emd guidance from the AVO. This bundling was done in order to 
reduce the processing time—compiling, linking, and downloading to the target. 
For each test that was bundled, its context clauses for packages Repx)rt and 
(if present) SYSTEM were ccxomented out, and the modified test was inserted 
into the declarative pjart of a block statement in the bundle. The general 
structure of each bundle was: 

WITH REPORT, SYSTEM; 

PROCEDURE <BUNDLE_NAME> IS 

— rep>eated for each test 

DECLARE 

<TEST FILE> [a modified test is inserted here, ...) 

BEGIN 

<TEST NAME>; [...and invoked here] 

EXCEPTION —test is not expiected to reach this exception handler 

WHIN OTHERS ■> REPORT.FAILED("unhandled exception "); 

REPORT.RESULT; 

END; 

— (... repeated for each test in the bundle) 

END <BUNDLE_NAME>; 

The 1293 tests that were processed in bundles are listed below; each bundle is 
delimited by '<' and '>'. 


<A21001A 

A22002A 

A22006B 

A26004A 

A26007A 

A27003A 

A27004A 

A29002A 

A29002B 

A29002C 

A29002D 

A29002E 

A29002F 

A29002G 

A29002H 

A29002I 

A29002J 

A29003A 

A2A031A> 

<A32203B 

A32203C 

A32203D 

A33003A 

A34017C 

A35101B 

A35402A 

A35502Q 

A35502R 

A35710A 

A35801A 

A35801B 

A35801F 

A35902C 

A38106D 

A38106E 

A38199A 

A39005B 

A39005C 

A39005D 

A39005E 

A39005F> 

<A39005G 

A54B01A 

A54B02A 

A55B12A 

A55B13A 

A55B14A 

A62006D 

A71002A 

A71004A 

A72001A 

A73001I 

A73001J 

2-6 

A74105B 

A74106A 

A74106B 






IMPLEMENTATION DEPENDENCIES 


A74106C 

A83041D 

A83C01E 

A85013B 

<AD1A01A 

AD7102A 

C23003A 

C24003C 

<C2420U 

C24211A 

<C26008A 

C2A008A 

C32111A 

C34001C 

<C34004A 

C34005I> 

C34005S 

C34007A 

C34007P> 

C34011B 

C34014J 

C34014W 

C35003D 

C35503B 

C35503K> 

C35505B 

<C35507C 

C35507L> 

C35707B 

C35708D 

C35713A 

C35802E> 

C35A03A 

<C35A03Q 

C35A04P> 

C35A06B> 

C35A06S 

C35A07P 

C36105B 

C36202B 

C36205B 

<C36205I 

C36304A 

C37007A 

C37012A 

C37207A 

C37211B 

C37213D> 

C37213L 

C37215P 

<C37304A 

C37402A 

C38002A 

C38006A 


A74205E 

A83A02A 

A83C01F 

A87B59A> 

ADIAOIB 

AD7103A 

C23006A 

C24106A 

C24202A 

C25001A 

C27001A 

C2A009A 

C32111B> 

C34001D 

C34004C 

<C34005J 

C34005U 

C34007D 

<C34007R 

C34012A 

C34014L 

C34014Y 

C35003F 

C35503C 

<C35503L 

€355050 

C35507E 

<C35706A 

C35707C 

C35708E> 

€357130 

<C35902A 

C35A03B 

C35A04A 

<€35A04Q 

<€35A06D 

C35A07A 

C35A07Q 

C36172A 

C36202C 

C36205C 

C36205J 

C36305A> 

C3700aA 

C37102B 

C37208A 

C37211C 

<€37213E 

C37214A> 

€372150 

C37305A 

€37403A> 

C38002B 

C38102A 


A74205F> 

A83A02B 

A83C01G 

<AB7006A 

ADIDOIE 

AD7103O 

C24002A 

C24113A 

C24202B 

C25001B 

C2A001A 

€2A021B> 

<€32114A 

C34001F 

C34005A 

C34005L 

C34006A 

C34007F 

€34007S> 

C34014A 

C34014N 

C34015B 

C35102A 

C35503D 

€355030 

<€35505D 

C35507G 

O35706B 

C35707D 

<C35711A 

<C35801D 

C35902B 

C35A03C 

O35A04B 

O35A05A 

O35A06N 

C35A07B 

035A08B 

036172B 

C36203A 

036205D 

036205K 

<C37002A 

C37008B> 

037103A 

C37208B 

037211D 

037213F 

<€37215A 

C37215H 

C37306A 

<€37404A 

C38004A 

C38102B 


<A83009a 
A83A06A 
A83C01H 
AO1015B 
AD7001B 
<AD7104A 
024002B 
C24113B 
O24202C 
C25003A 
C2A001B 
<€32107A 
C32115A 
C34002A 
€340050 
C34005M 
C34006F 
€34007G> 
<€34009A 
€340140 
C34014P 
C34016B 
C35106A 
C35503E 
C35503P 
C35505E 
C35507H 
€357060 
C35707E 
C35711B 
C35802A 
C35902D 
€35A03D> 
C35A04O 
C35A05D 
€35A06O> 
C35A07O 
€36003A> 
€361720 
C36204A 
C36205E 
C36301A 
C37003A 
<€370080 
C37105A 
037209A 
037211E 
037213G 
€37215B> 
037216A 
037307A 
O37404B 
038004B 
C38102C 


A83009B 

AB3A08A 

A83C01I 

AC3106A 

AD7005A 

AD7203B 

024002C 

€241130 

C24203A 

025004A 

02A001C 

O32107C 

€32115B> 

€340020 

<€34005D 

€340050> 

034006G 

<0340071 

034009F 

<O34014E 

O34014R 

O34018A 

035404A 

O35503F 

O35504A 

035505F 

0355071 

O35706D 

O35708A 

035712A 

O35802B 

035904A 

<035A03N 

<O35A04D 

O35a05N> 

<035A06P 

<035A07D 

<036004A 

<036174A 

036204B 

036205F 

O36301B 

037003B 

037009A 

O37107A 

O37209B 

037213A 

037213H> 

<0372150 

037217A 

O37309A 

O37405A 

038005A 

O38102D 


A83041B 

A83O01O 

A83001J 

AO3206A 

AD7101A 

AD7205B> 

024003A 

024113D 

O24203B 

026002B 

02A002A 

O32108A 

<032117A 

034003A 

034005F 

<034005P 

034006J> 

034007J 

034009G 

O34014G 

034014T> 

O35003A 

O35404O> 

035503G 

O35504B 

O35507A 

O35507J> 

035706E> 

O35708B 

035712B 

0358020 

O35904B 

O35A03O 

035A04N> 

<O35A05O 

O35A06Q 

O35A07N 

O36104A 

O36180A 

O36204O> 

036205G 

O36302A 

O37005A 

037010A 

037108B 

O37210A> 

037213B 

<037213J 

037215D 

037217B 

O37310A 

O37409A 

038005B 

O38102E 


A83041O 

A83O01D 

A85007D 

A€3207A> 

AD7101O 

<023001A 

024003B 

024113E> 

O24207A 

€26006A> 

02A006A 

O32108B 

O34001A 

0340030 

034005G 

034005R 

<O34006L 

034007M 

034009L 

O34014H 

<O34014U 

035003B 

<O35503A 

035503H 

O35505A 

O35507B> 

<O35507K 

<O35707A 

0357080 

0357120 

O35802D 

035A02A 

O35A03P> 

<O35A04O 

O35A06A 

O35A06R 

O35A07O 

O36104B 

O36202A 

<O36205A 

O36205H> 

O36303A 

037006A 

037010B 

O37206A 

<€37211A 

0372130 

037213K 

037215E 

€372170 

037312A 

037411A 

€380050 

O38104A 


2-7 



IHPLENENTA.TIGN DEPENDENCIES 


C38107A 

C39006D 

C39008C> 

C41107A 

C41206A 

C41303F 

C41303O 

C41304A> 

C41307D 

C41322A 

<C4140U 

C42007B> 

C42007l> 

C43104A> 

C43204C 

C43205B 

C43205I 

<C43207D 

C43212C 

C43214F 

C44003E 

C45101G 

C45111C> 

C45122A 

<C45201A 

C45220B 

<C45232A 

<C45242A 

<C45272A 

C45282B 

C45321C 

C45342A 

<C45347A 

C45412A 

C45421E> 

<C45504A 

C45521C 

C45524D 

C45532F 

<C45534A 

C45621A 

C45624B 

C45641C 

C46011A 

C46014A 

<C46041A 

C46051B 

C47002C 

<C47008A 

C48004E 

<C48007A 

C48009A 

<C48009H 

C49021A 


C38107B> 

C39006E 

<C41101D 

C41108A 

C41207A 

C41303G 

C41303Q 

<C41304B 

C41308A 

C41323A 

C41402A 

<C42007C 

<C42007J 

<C43105A 

C43204E 

C43205C 

C43205J 

C43208A 

C43213A> 

C43215A 

C44003F 

C45101H 

<C45111D 

C45122B 

C45201B 

C45220C 

C45232B 

C45242B 

C45273A 

C45291A 

C45321D 

C45343A 

C45347B 

€454120 

<C45423A 

C45504C 

C45521D 

C45524E> 

C45532G 

C45611A 

C45621B 

C45631A 

C45641D 

C46012A 

C46021A 

C46042A 

C46051C> 

C47002D 

C47009A 

C48004F 

C48007B 

C48009B 

C48009I 

C49022A 


<C38108A 

C39006G 

C41103A 

C41201D 

C41301A 

C41303I 

C41303R 

C41306A 

C41308C 

C41324A 

C41403A 

C42007D 

C42007K 

C43105B 

C43204F> 

C43205D 

C43205R 

C43208B 

<C43214A 

C43215B 

C44003G 

C45101I 

C45111E 

C45122C 

C45202A 

C45220D 

C45241A 

C45251A 

C45274A 

C45303A 

C45321E> 

C45344A 

C45347C 

<C45413A 

C45431A 

C45504D 

C45521E> 

<C45532A 

C45532H 

C45611C 

C45621C 

C45631C 

C45641E> 

C46012B 

C46023A 

C46043A 

<C46052A 

C47003A 

C47009B 

C48005A 

C48007C 

C48009C 

C48009J 

C49022B 


C38201A 

C39007A 

C41103B 

C41203A 

C41303A 

C41303J 

C41303S 

C41306B 

C41308D 

C41325A 

C41404A 

C42007E 

C43003A 

C43106A 

<C43204G 

C43205B 

C43206A 

C43209A 

C43214B 

C43222A> 

C45101A 

C45101K 

C45112A 

C45122D 

C45202B 

C45220E 

C45241B 

C45252A 

C45274B 

C45304A 

<C45323A 

C45345A 

C45347D 

C45421A 

C45502A 

C45504F> 

<C45523A 

C45532B 

C455321 

C45613A 

C45621D 

C45632A 

C45652A 

C46012C> 

C46024A 

C46043B> 

C46053A 

C47004A 

C48004A 

C48005B 

C48008A 

C48009D 

C48010A 

C49022C 


C38202A 

C39007B 

C41104A 

C41203B> 

C41303B 

C41303K 

C41303U 

C41306C 

C41309A> 

C41326A 

C42005A 

C42007F 

C43004B 

C43107A 

C43204H 

C43205F 

C43207A 

C43210A 

C43214C 

<C43224A 

C45101B 

C45104A 

C45112B 

C45123A 

C45210A 

C45220F 

C45241C 

C45252B 

C45274C 

€453040 

C45331A 

C45345B 

C45411A 

C45421B 

C45502C 

<€45505A 

C45524A 

C45532C 

C45532J 

C45613C 

€45621E> 

C45632C 

C45662A 

<€46012D 

C46031A 

<€46044A 

C46054A 

C47005A 

C48004B 

C48005C 

C48008B 

C48009E 

C48011A 

C49023A 


C39006A 

C39008A 

C41105A 

<€41204A 

C41303C 

C41303M 

C41303V 

C41307A 

<€41320A 

C41327A 

C42006A 

C42007G 

C43103A 

C43108A 

€432041 

C43205G 

C43207B 

C43211A 

C43214D 

C44003A 

C45101C 

C45111A 

€45113A> 

C45123B 

C45211A 

C45231A 

C45241D 

C45253A 

C45281A 

<€45321A 

C45331D 

C45345C 

C45411C 

C45421C 

C45503A 

C45521A 

C45524B 

C45532D 

C45532K 

C45614A 

<€45622A 

C45641A 

C45662B 

€46012E> 

C46032A 

C46044B 

C47002A 

C47006A 

C48004C 

C48006A 

C48008C 

C48009F 

C48012A 

C49024A 


C39006B 
C39008B 
C41106A 
C41205A 
C41303E 
C41303N 
C41303W 
C41307C 
C41321A 
€41328A> 
C42007A 
C42007H 
C43103B 
C43204A 
C43205A 
C43205H 
€432070 
C43212A 
C43214E 
C44003D 
C45101E 
C45111B 
<€45114B 
€451230 
C45220A 
€452310 
€45241E> 
€45262A> 
C45282A 
C45321B 
C45332A 
€45345D> 
C45411D 
C45421D 
€455030 
C45521B 
C45524C 
C45532E 
€455320 
C45614C 
C45624A 
C45641B 
C45672A 
<€46013A 
€46033A> 
C46051A 
C47002B 
€47007A> 
C48004D 
€48006B> 
C48008D 
€480090 
C49020A 
C49025A 


2-8 




IMPLEMENTATION DEPENDENCIES 


C49026A> <C4A005A 
C4A010D C4A011A 

<C51002A C51004A 

C52005C C52005D 

C52009A C52009B 

C52013A> <C52103B 
C52103L> <C52103M 
C52104A C52104B 

C52104L C52104M 

<C53004B C53005A 

C54A03A C54A04A 

C54A13C> <C54A13D 
C54A27A C54A41A 

C54A42F C54A42G 

C55B07A> <C55B08A 
C55B16A C55C01A 

C56002A C57002A 

<C58004A C58004B 

C58005B C58005H 

C59002C> <C61008A 
C62004A C62006A 

C64005B C64005C 

C64103F> <C64104A 
C64104G C64104H 

C64104N C64104O 

C64105F> <C64106A 
C64109A C64109B 

C64109H C64109I 

C64202A C65003A> 

C66002E C66002F 

C67002E> <C67003A 
C67005B C67005C 

C74004A C74203A 

C74210A C74211A 

C74306A C74307A> 

C74402B C74406A 

C83023A C83024A 

C83030A> <C83031A 
C83B02A C83B02B 

C83F03A C84002A 

C85005B C85005C 

<C85006F C85006G> 

C87B04A C87B04B 

<C87B07C C87B07D 

C87B10A C87B11A 

C87B14D> <C87B15A 
C87B23A C87B24A> 

C87B30A C87B31A 

CB1005A CBlOlOA 
CB2006A CB2007A 

CB4003A CB4004A 

CB4013A CB5002A 

<CC1010B CC1018A 

CC1220A CC1221A 


C4A005B C4A006A 

C4A012A C4A012B 

C52001A C52001B 

C52005E C52005F> 

C52010A C52011A 

C52103C C52103F 

C52103P C52103Q 

C52104C C52104F> 

C52104P C52104Q 

C53005B C53006A 

C54A06A C54A07A 

C54A22A C54A23A 

C54A42A C54A42B 

C55B03A C55B04A 

C55B09A C55B10A 

C55C02A C55C02B 

C57003A C57004A 

C58004C C58004D 

C58006A C58006B 

C61009A C61010A 

C62009A C63004A 

C64103A C64103B 

C64104B C64104C 

C64104I C64104J 

C64105A C64105B 

C64106B C64106C 

C64109C C64109D 

C64109J C64109K 

<C65003B C65004A 

C66002G C67002A 

C67003B C67003C 

C67005D> <C72001B 
C74206A C74207B 

C74211B C74302A 

<C74401D C74401E 

C74407B C74409B> 

C83025A> <C83027A 
C83031C C83031E 

C83E02A C83E02B 

C84005A C84008A 

C85005D> <C85005E 
<C87A05A C87A05B 

C87B04C C87B05A 

C87B07E C87B08A 

C87B11B C87B13A 

C87B16A C87B17A 

<C87B24B C87B26B 

C87B32A> <CB1001A 
CBlOlOB CBIOIOC 
CB3003A CB3003B> 

CB4005A CB4006A 

CB7003A CB7005A> 

CC1104C CC1107B 

CC1221B CC1221C 


C4A007A C4A010A 

C4A013A C4A013B 

C52001C C52005A 

<C52007A C5200aA 

C52011B C52012A 

C52103G C52103H 

C52103R C52103S 

<C52104G C52104H 

C52104R C52104X 

C53006B C53007A 

C54A11A C54A13A 

C54A24A C54A24B 

C54A42C C54A42D 

C55B05A C55B06A 

C55B11A C55B11B 

C55C03A C55C03B 

C57004B C57004C 

C58004F C58004G 

C59001B C59002A 

C62002A C62003A 

C64002B> <C64004G 
C64103C C64103D 

C64104D C64104E 

C64104K C64104L 

C64105C C64105D 

C64106D C64107A 

C64109E> <C64109F 
C64109L> <C64201B 
C66002A C66002C 

C67002B C67002C 

C67003D C67003E 

C72002A C73002A 

C74208A C74208B 

C74302B C74305A 

C74401K C74401Q 

<C83007A C83012D 

C83027C C83028A 

C83032A C83033A 

C83E03A C83E04A 

C84009A C85004B 

C85005F C85005G 

C87B02A C87B02B 

C87B06A C87B07A 

C87B09A C87B09B 

C87B14A C87B14B 

C87B18A C87B18B 

C87B27A C87B28A 

CB1002A CB1003A 

CB1010D> <CB2004A 
<CB3004A CB4001A 

CB4007A CB4008A 

<CC1004A CC1005C 

CCllllA CC1204A 
CC1221D> <CC1222A 


C4A010B 

C4A014A> 

C52005B 

C52008B 

C52012B 

C52103K 

C52103X 

C52104K 

C52104Y> 

C53008A 

C54A13B 

C54A26A 

C54A42E 

C55B06B 

C55B15A 

C55D01A 

C57005A> 

C58005A 

C59002B 

C62003B 

C64005A 

C64103E 

C64104F 

C64104M 

C64105E 

''64108A 

C64109G 

C64201C 

C66002D 

C67002D 

C67005A 

C73007A 

C74209A 

C74305B 

C74402A 

C83022A 

C83029A 

C83051A 

C83F01A 

C85005A 

C85006A> 

C87B03A 

C87B07B> 

C87B09C 

C87B14C 

C87B19A 

C87B29A 

CB1004A 

CB2005A 

CB4002A 

CB4009A 

CC1010A> 

CC1207B 

CC1224A 


2-9 




IMPLEMENTATION DEPENDENCIES 


CC1225A> <CC1304A CC1304B CC1305B CC1307A CC1307B CC1308A 

CC1310A> <CC131lA CC1311B CC2002A CC3004A CC3007A CC3011A 

CC3011D CC3012A CC3015A CC3106B> <CC3120A CC3120B CC3121A 

CC3123A CC3123B CC3125A CC3125B CC3125C CC3125D> <CC3126A 

CC3127A CC3128A CC3203A CC3207B CC3208A CC3208B> <CC3208r 

CC3220A CC3221A CC3222A CC3223A CC3224A CC3225A> <CC3230A 

CC3231A CC3232A CC3233A CC3234A CC3235A CC3236A CC3240A 

CC3305A CC3305B CC3305C CC3305D CC3406A CC3406B CC3406C 

CC3406D CC3407A CC3407B CC3407C CC3407D CC3407E CC3407F> 

<CX:3408A CC3408B CC3408C CC3408D CC3504A CC3504B CC3504C 

CC3504D CC3504E CC3504F> <CC3504G CC3504H CC3504I CC3504J 

CC3504K> <CC3601A 0036010 <003603A OO3606A 003606B 003607B> 


2-10 



CHAPTER 3 


PRCXXSSIN8 INFORMATION 


3.1 TESTING Q^RCNMEirr 

The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For technical euid sales information about this Ada inplementation, contact: 

Robert R. Risinger 
TLD Systems, Ltd. 

3625 Del Amo Boulevard, Suite 100 
Torrance, CA 90503 

Testing of this Ada implementation was conducted at the custcxner's site by a 
validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada implementation passes a given ACVC version if it processes each test of 
the custOTiized test suite in accordance with the Ada Progranining Language 
Standard, whether the test is applicable or inapplicable; otherwise, the Ada 
Implementation fails the ACVC [Pro92]. 

For all processed tests (inapplicable and applicable), a result was obtained 
that conforms to the Ada Programming Language Standard. 

Ihe list of items below gives the nui^r of ACVC tests in various categories. 
All tests were processed, except those that were withdrawn because of test 
errors (item b; see sectim 2.1), those that require a floating-point 
precision that exceeds the implementation's maximum precision (item e; see 
section 2.2), and those that depend on the support of a file system — if none 
is sipported (item d). All tests passed, except those that are listed in 
sections 2.1 and 2.2 (counted in items b and f, below). 


3-1 






PROCESSING INFORMATION 


a) Total Number of J^licable Tests 3461 

b) Total Number of Withdravm Tests 95 

c) Processed Inapplicable Tests 65 

d) Non-Processed I/O Tests 264 

e) Non-Processed Floating-Point 

Precision Tests 285 

f) Total Number of Inapplicable Tests 614 (c4d-he) 


g) Total Number of Tests for ACVC 1.11 4170 (a+b+f) 


3.3 TEST EXECUTION 


A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the vali^tion team for processing. The contents of the 
magnetic tape were loaded directly onto the host ccmputer. 

After the test files were loaded onto the host computer, the full set of tests 
was processed by the Ada implementation. 

The tests were con^iled and linked on the host computer system, as 
appropriate. The executable images were loaded into the simulator on the host 
coiqputer system, and run. The results were captured on the host computer 
system. 

Testing was performed using command scripts provided by the customer and 
reviewi^ by the validation team. See Afipendix B for a complete listing of the 
processing options for this iiqplementation. It also indicates the default 
options. The following options were used for testing this inpleroentation: 


Compiler 

Option / Switch Effect 


NoPhase 

NoLog 


SuE^ress displaying of phase times during 
ccmfiilation. 

To cause command line to be echoed on log 
file. 


NoDebug 

List 


To suppress generation of debug symbols to 
speed compilation and linking. 

TO cause listing file to be generated. 


Target-1750A 


Selects the TLD M1L-STD-1750A target 
architecture. 


3-2 






PROCESSINQ INFORMATION 


Linker 

Option / Switch Effect 

NoDebug Suppresses generation of Debugger symbol 

files. 

NoVersion Siij^resses announcement banners that 

contain timestamp and version information 
to facilitate file cornering. 

All tests were executed with Code Straightening, Global 
Optimizations, and autcxnatic Inlining options enabled. Where 
optimizations are detected by the optimizer that represent deletion 
of test code resulting frcxn unreach^le paths, deleteable 
assignments, or relational tautologies or contradictions, such 
optimizations are reflected by informational or warning diagnostics 
in the compilation listings. 


Test output, conf)iler euid linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by the 
validation team were also archived. 


3-3 





APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 

Ihe meaning and purpose of these parameters are explained in [UG89]. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the nmximum input-line length, vhich is 
the value for $MAX_IN_LE3)—also listed here. These values are expressed here 
as Ada string aggregates, vriiere "V" represents the nmximum input-line length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 

120 — Value of V 

$B1G_ID1 

(1..V-1 -> 'A', V -> '1') 

$BIG_ID2 

(1..V-1 -> 'A', V -> '2') 

$BIG_ID3 

(1..V/2 -> 'A') & '3' & 
(1..V-1-V/2 -> 'A') 

$BIG_ID4 

(1..V/2 -> 'A') & '4' & 
(1..V-1-V/2 -> 'A') 

$BIG_INT_LIT 

(1..V-3 -> '0') & "298" 

$BIG_REAL_LIT 

(1..V-5 -> '0') & "690.0" 

$BIG_SraiNGl 

& (1..V/2 -> 'AM & 

$BIG_STRING2 

& (1..V-1-V/2 -> 'A') & 

$BLANKS 

(1..V-20 


$MAX_LEN_INT_BASED_LITERAL 

"2:" & (1..V-5 -> '0') & "11:” 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 -> '0') & "F.E:" 


A-1 








MACRO PARAMETERS 


$MAX_STRING_LITERAL & (1..V-2 -> 'A') & 

The following table lists all of the other macro parameters and their 
respective values. 

Macro Parameter Macro Value 


$ACC_S1ZE 

16 (48 for access to STRING) 

$ALIGNMENT 

4 

$CXXJNT_LAST 

511 

$DEFAULT_MEM_SI2E 

65536 

$DEFAULT_STOR_UNIT 

16 

$DEFAULT_SYS_NAME 

AF1750 

$DELTA_DOC 

2.0**(-31) 

$ENTRY_AM)RESS 

15 

$EUTRY_Ar»RESSl 

17 

$ENTRY_AI»RESS2 

19 

$F1ELD_LAST 

127 

$FILE_TERMINATOR 

ASCII.FS 

$FIXED_NAME 

NO SUCH FIXED TYPE 

$FLOAT_NAME 

NO SUCH_i'LOAT_TYPE 

$FORM_STRING 

fill 

$FORM_STRING2 

CANNOT_RESTRICT_FILE_CAPACn 

$GREATER THAN DURATION 



90000.0 

$GREATER THAN DURATION BASE LAST 

131073.0 

$GREATER THAN FLOAT BASE LAST 

~ 1T71000E+38 

SOFTER THAN FLOAT SAFE LARGE 

" ~ “ 2T13000E+37 




MACRO PARAMETERS 


$GREATER_THAN_SHORT_FLQAT_SAFE_LARGE 

WjSlXM~SHCm'_FLOATjrYPE 

$HIGH_PRIORITY 64 

$ILLEGAL_EXTERNAL_FII£_NftMEl 

BA£)CHAR@.l 

$ILLEGMjJEXTERNAL_FILE__NAME2 

“TOISFILDttMEWOULDBEPREFECTLYLEGAL" & 
" IFITWERHIOTSOLONG. SOTHERE" 

$ INAPPROPRIATE_LINE_LENGTH 

-1 

S inappropriate_page_lbngth 

-1 

$INCLUDE_PRAGMAl PRAGMA INCLUDE ("A28006D1.TST") 

$INCLUDE_PRAGMA2 PRAGMA INCLUDE ("B28006D1.TST") 

$INTEGER_FIRST -32768 

$INTEGER_LAST 32767 

$INTBQER_LAST_PLUS_1 32768 

$INTERFACE_LANGUAGE ASSEMBLY 

$LESS_THAN_DURATION -90000,0 

$LESS THAN_DUFATION_BASE FIRST 

-T31073.0 

$LINE_TERMINATOR ASCII.CR 

$LCIM_PRI0RI'IY 1 

$MACHINE_CODEJSTATEMENT 

R_FMT^ (OPCC»E»>LR,RA->RO,RX->R2); 

$MACHINE_OODE_TXPE ACOWULATOR 

$MANTISSA__DOC 31 

$MAX_DIGITS 9 

$MAX_INT 2_147_483_647 

$MAX_INT_PLUS_1 2_147_483 648 

$MIN_INT -2_147_483_648 

A^3 




MACRO PARAMETERS 


$NAME 

$NAME_LIST 


$NAME_SPECIFICATIONl 

$NAME_SPECIFICATI0N2 

$NAME_SPEC1FICATION3 

$NEG_BASEp_INT 

$NEW_MEM_SIZE 

$NEW_STOR_UNIT 

$NEW_SYS_NAME 

$PAGE_TERMINATOR 

$RECORD_DEFINITION 

$RECORD_NAME 

$TASK_SIZE 

$TASK_STORAGE_SIZE 

$TICK 

$VARIABLE_ADDRESS 

$VARIABLE_At»3RESSl 

$VARIABLE_AIX)RESS2 

$YOUR_PRAGMA 


NO_SUC:H_INTEGER_TyPE 

NONE, NS16000, VAX, AF1750, Z8002, Z8001, 
GOULD, PDPll, M68000, PE3200, CAPS, 

AMDAHL, 18086, I80286, I80386, Z80000, 
NS32000, IBMSl, M68020, NEBULA, NAME_X, HP 

Not supported 

Not su^Jorted 

Not supported 

16#FFFFFFFE# 

65535 

16 

AF1750 

ASCII.CR & ASCII.FF 
Withdravm 
Withdrawn 
16 

2000 

1.0/10_000.0 

16#8000# 

16#8020# 

16«8040# 

Withdrawn 


A-4 


APPENDIX B 


OOMPILATZCN SYSTEM OPTIGNS 


The cooipiler options of this Ada isplenentation, as described in this 
^^ndix, are provided by the customer. Unless specifically noted otherwise, 
references in this appendix are to ccanpiler documentation and not to this 
report. 


B-1 





TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3-9 


3.7 Compiler Option Switches 

Conpiler opcion swicches p r o vi de concrol over various processing and 
oucpu.. feacures of the conpiler. These features include several 
varieties of listing output, the level and kinds of optimizations 
desired, the choice of target ccngniter, and the operation of the 
conpiler in a syntax checlcing mode only. 

Keywords are used for selecting variotis compiler options. The 
complement keyword, if it exists, is tised to disable a compiler opcion 
and is formed by prefixing the switch keyword with "NO" . 

Switch natMs may be truncated to the least nisnber of characters 
required to uniquely identify the switch. For example, the switch 
"CROSSREF" (explained in the list below) may be uniquely identified by 
the abbreviation "CR" or any longer abbreviation. In the list of 
switches on the following pages, the abbreviations are in bold and thi» 
optional extra characters are not bolded. 

If an opcion is not specified by the user, a defatilt setting is 
assumed. All specified compiler options apply to a single invocation 
of the compiler. 

The default setting of a switch and its meaning are defined in the 
table below. The meaning of the enmplestenc form of a switch is 
normally the negation of the switch. For some swicches, the complement 
meaning is not obvious; these complement switch keywords are listed 
separately. 

In the description of the switches, the target dependent name target is 
used. The value of this symbol is dscerminsd by the value of the 
TARGET switch. 

Compiler-generated file specifications generally conform to host 
conventions. Thus, any generated filename is the source filenasie 
appended with the default file type. The output file name can be 
completely or partially specified. 


B-2 


rasa ltd 







TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3-10 


SWITCH NAME 


MEANING 


IfiBADOR 

NOlfiBADDR •• defaxxic 

33EAOOR •• dafaulc 

N032BAOOR 

Tha 32BAOOR svicch calls £sr address canpucacions using 1750A 
double precisian fixed pome daca words, when 16BASOR is seleceed, 
address coeipucacions are perfoxaed using single precisian fixed 
poinc daea words ignoring che possibility of a I7S0A Fixed Point 
Overflow Interrupt due to cosipucation of an address greater than 
7FFF hex. 

ABsoldte_listiiig 

N0ABsOLITrE_L:STING 

This switch produces a ".LIX* file with a list of control sections 
and isports and control section and import nxr&bers with references 
CO Che macro listing file (i.e., che line number and column number 
where a relocatable address appears in che macro listing). This 
file along with a coogjiler*generated source listing file and a 
linher*generated ” .MIX" file (containing che absolute addresses of 
these control sections and imports) are used by the TLD Absolute 
Listing atilicy to produce a macro listing * .ABS* file contai n in g 
absolute rather than relative addresses. Refer to the Compiler 
LIST and MACRO switches, to che Reference Document for the TIC 
Linker for che ABS0LUTE_L1STI2IG switch that produces che ” .mix" 
file, and to the Reference Document for the TLD MIL-STD-175OA 
utilities for further information regarding che macro listing 
containing edssoluce addresses rather chan relative addresses which 
are normally created by che Compiler MACRO and LIST switches. 
(Also, the ABSOLOTE^LISTIRG. MACRO, and LIST switches may be 
specified for assembly language coda in che assesibly to produce che 
same files as created by the Compiler to produce the absolute macro 
listing. Refer to the Reference Document for the TLD Macro 
Assembler for further information.) 

The MACRO and LIST switches must be specified with this switch. 




B-3 





TLO ADA COMPILER 

Compiler Usage 


1750A-A0A-2B 

3 - U 


CAll tkse 

NOCAlLJTSEE -• defaulc 

•nii* svxccti is uasd in conjunccion witli BLABORATOR an d XiXST co 
catise aai .C7X files (corresponding co cde complece sec of objecc 
files being linked for cbis p r og ra m) co be read in and a closure of 
all calls in che p r ogr a m co be compuced. Tlie results of this 
analysis is foraacced into a subprogram call tree report and output 
in the listing file. Tliia swiceb has no effect without the 
SLABORATOR and LIST sviccbes. 

NOTE; The call tree is incomplete if any required congjilacion 
unit's .cn files are missing. 

CHbOCS -• default 
CHecKS{« (cbecJc_idencifier{ 

N0CHBacs{> (cbee)e_identifier{ 

When che CHECKS switch is used, zero or more checJc_idencifiers are 
specified aud che run time checks are enabled. The status of run 
time checks associated with unmentioned check_idencifiors is 
unchanged. 

Without any cheek^ideacifiers, che NOCHEOCS switch omits all nm 
time checks. If one or more check^idencifiers are specified, che 
specified run time checks aure omitted. The status of run ciaie 
checks associated with unmentioned cbeck^identifiers is unchanged. 

Chocks can be eliminated selectively or completely by source 
statement pragma Suppress. Pragma Suppress overrides che CHECKS 
switch. 

Cbeck_idencifiers are listed below and are described in che LPH, 
Section 11.7. 


ALL CHECKS -- default (consists of aill che checks below) 


ACCESS_CHECK DISCRIMINAMT_CHECK 

SLABORATION.CHECK INDSZ_CHEac ~ 
OVERELOW_CBicK RANGs'cHECK 

CONFIGURAnONBConfigurac^on-identi^ier 
NOCONpICaURATIONaccaifiguracion • identifier 


DIVIS10N_CHECK 
LENSTH.CHSCK 
STORAGE CHECK 


This switch provides a conditional compilation (configuration) 
capability by determining whether or not source line(a) marked with 
a special cosnent, are compiled. If che CONFIGURATION switch is 
used, che specially coemiented source line(s) are included in che 
compilation. If neither of these switches or the NOCONFIGURATION 
switch IS used, the specially conmented source line is) are treated 
as regular Ada comnents and are ignored. 



TLO ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3-12 


Formac 

Conditional sovirce line* can ba spaciaJLly cosBianted in one of two 
ways: 1) by beginning all conditional source lines with 
--/configuracian-identifier or 2) by placing 

•-{canfiguration-identifier on a line by itself, placing 
conditional source on the following linea, and by placing 

configuration-identifier on a line by itself after the last 
conditional source line. See the exanples below: 

For a single line; 


- - / conf i gura ti on • i den tif i er 
or: 

- - {configuracion-identifier 
conditional-source•line 

- -} configuration - identifier 

For multiple lines: 

.. /configuracion-ideacifier 
••/configura ti on-identifier 
--/conf iguracion - identifier 


--/configuration-identifier 

or: 

- - {configuracion-ideacifier 
condi cional - source - line -1 
conditional -source-line -2 
condi cional - source • line • 3 


condi cional - source - line 


condi cional - source - line • 1 
candl cional • source • line • 2 
condi cional - source • line • 3 


condi cional • source • liae-n 


condi cional • source - line-n 
- -} conf igura cion - identifier 


The conditional-source-line (8) beginning with --/ or between 
and --} are compiled only if CONFIGDIIATION- 
configuracion-identifier is specified. 

The special cotmenc characters --/ or - -{ and - -} must be entered 
as shown; no spaces are allowed between the dashes and the slash or 
between the dashes and a brace. 


fTLiOJ 


B-5 










TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3 - U 


Also, rha can£igujrBLC 2 .an-idencj.£ler siusc inanediacely follow che 
special coBBanc characters; no space is allowed between the special 
coBBenc characters and the caB^iguration-idenei^fief. 

NOTE: Any conditional source placed on the saaie line as the 
••{configuration-identifier and/or the >-} 

canfiguracion*idencidier, will be considered c ondi tio nal source 
will be included in or exclitded frcBi the coBipilation as 
detessiined by this switch setting, however, the previously 
described foxsiac is preferred. 


Nanina Constraint 

By default, a /CONFIG>1750A setting is created for the target 
ccBiputer and model (by the /TARGET and the /MODEZ, CoBipiler 
switches). Therefore, 1750A is not a valid 

configuxacion-identifier for conditional cosipilation. If used, 
conditional source with that naae will always be included in the 
coBipilation whether or not this switch is specified (since that 
name is already specified for the target and model, by default) . 


WtBtinq 

Conditional source lines may be nested, but must be properly 
nested; a conditional conpilation (configuration) must be 
coBipletely nested within another as shown below: 

For braces nested within braces: 


--{A 

condicionai•source•line • AI 
condi eional • source - line • A2 
--{B 

condi cianal • source - line ~B2 


conditions i • source - line - Ba 

condi ci anal - source -line-A3 
--}A 

If CONFIGURATIONsA is used, conditional-source-Al, -A2, euid -AS 
will be included, if CONFIGORATZONaB is used, 
conditional-source-51 t.hrough -Sn will be included. If 
CONFIGURATIONbAB is used, condi cionai - source-Al, -A2, -A3 amd -SI 

through -Sn will be included. 





TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3-14 


TVi» follovxng example fozaac is also valid: 

--{A 

--{B 

*-{c 

--{D 

..}D 

--}C 

-.}A 


However, ghe following example format is invalid, since "B* is not 
completely nested within "A": 

--{A 

--{B 

-.}A 

..}B 

and two warning messages will appear: "Unmatched configuration 
switch" will appear for the second "A" and "Missing configuration 
switch* will appear for the second *B*. 


For slashes nested within braces: 

-.{A 

condi tional • source • line-AI 
condi cional • source • line - A2 
-•/B candicional-source>line>B 
--/C candicional-source>Iine>C 
-•/D condicianal-source-line>P 
condi tional • source • line • A3 
--}A 

If COHFIGORATIOR-A is used, conditional-source-Al, -A2, and -A3 
will be included. If CONFIGDRATIOH-B is used, condi cional-source- 
will be included. If CONFZGDRATION-ABO is used, 
condi cional-source-Al, -A2, -A3, -fl, and -D will be included. 







TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3-15 


CRossref 

NOCRosSSEF -- default 

This switch geaerates a cross reference listing that contains nasies 
referenced in the source code. The cross reference listing is 
included in the liattng file; therefore, the LIST switch must be 
selected or CROSSREF has no effect. 

CSbg -• default 
NOCSsg 

This switch indicates chat conscancs and data are to be allocated 
in different control sections. 

CTi 

NOCTi default 

This switch generates a CASE cools interface file. The default 
filename is derived from the object filename, with a .CTZ 
extension. ‘The .CTI file is required to support the 
STACK_A11ALYS1S, CALL_TREE, FnLL_CALL_TREE, and I1IVERTED_CALL_TREE 
switches. 

DEBog •• default 
NODEBug 

This switch selects the production of symbolic debug tables in the 
relocatable object file. 

Alternate abbreviation: DBg, NODBg 

diagnostics 

NODIaGNOSTICS default 

This switch produces a diagnostic message file compatible with 
Digital's Language Sensitive Editor axsd XinoTech Editor. See 
Digital's documentation for the Language Sensitive Editor for a 
detailed explanation of the file produced by this switch. 

DOcDUENTATIONadocumenca tl on • filename 
NODOcDhENTATTON -• default 

This switch causes information collected during compilation to be 
saved in a specified data base file or a default file nasMd 
1750A.DOC in Che compilation directory. This information includes 
Che compilation units, the concained scopes, the local declarations 
of objects and types and their descriptions, extemaLl references, 
callers, calls, program design language (FDD which is extracted 
from stylized Ada conraents embedded in the source code, and any 
ocher information extracted frcn similar stylized Ada casraencs. 
The TLD Ada Info Display (TLDaid) permits the user to browse this 





TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3-16 


base to excxacc selecxed data base infoxaation to support 
tha Mririo ^u mriris n g of s pro^Tss or to producs docustestacioa 
describing the prograa. 

NOTE: Although the TUaid utility is not yet available, users may 
want to begin creating documentation data base(s) by using this 
switch when performing caopilations. When TLDaid becooee 
available, it may than be used on already existing data baaa(s) 
without having to generate them through recompilation. 

ELaborator 

NOELabORATOR -- defatilt 

This switch generates a setup p ro g ra m (in uni c - nam es EL AB. OBJ (and a 
listing file in iinif-.ri«m«»«vT.&n t.tc if the LIST switch was 
specified)) that elaborates all compilation units on which the 
specified library unit procedure (main program) depends and t h e n 
calls the procedure (main program) . When the EZABORATOR switch is 
used. The unit name of a previously compiled procedure must be 
specified instead of a source file. It is not necessary to 
distinguish a main program from a libraury unit when it is compiled. 

EXcEPTlC3N__IIirO 
NOEXception.IIIFO -- default 

This switch generates a string in the relocatable object code that 
is the full pathname of the file being compiled and generates the 
extra instruotions required to identify the Ada source location at 
which an unhandled exception occurred. The N0E3CCEPTX0N_INF0 switch 
suppresses the generation of the string and the extra 
instructions. At run time, when an unhandled exception occurs, the 
source file and Ada source location information, if collected by 
the EZCEPnOR_INFO switch, is displayed in an error message. 

NOTE: Because the Symbolic Debugger does not use information 
generated by EZCEPTION_INFO and it increases program size, this 
switch should not be used ordinarily. The aCE?TION_INFO switch 
should be used only if you need to locate the unhandled exception 
when the sotirce is not running under the debugger. 

Foll_call_tree 

NOFuLL_CALL_TREE -- default 

When the rT7LL_CALL_TREE swicch is used, the compiler listing 
includes all calls including all nested calls in every call. The 
NOFnLL_CALL_TR£E swicch shows all nested calls in the first 
instance only and all subsequent calls are referred to the first 
instance. This swicch has no effect without the ELABORATOR and 
LIST switches. 



LTD 


B-9 







TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3-17 


INDEhtation-xi 

indentation- 3 -• default 

Tliis switch controis the indentation width in a reformatted source 
listing (see the REFORMAT switch description) . This swxtch assigns 
a value to number of columns used in indentation; the value n 
range from 1 to 8. 

INDIhect_call 
NOINDIrsct_CALL •- defaiiLt 

If Che INDZR£CT_CALLS switch is used, all subprograms declared in 
the compilation are called with indirect calls. This allows the 
user to replace a subprogram body at execution time by changing the 
pointer to the subprogram in the indirect call vector. 

INFo -- default 
NOINFo 

The INFO switch produces aill diagnostic messages including 
infocmation*level diagnostic massages. The NOINFO switch 
sxxppresses the production of information*level diagnostic messages 
only. 

INTsl 

NOINTsl - • default 

This switch intersperses lines of source code with the assembly 
code generated in the macro listing. This switch is valid only if 
the LIST and MACRO switches are selected. It may be helpful in 
correlating Ada source to generated cods, but it increases the size 
of the listing file. 

INVerted_call_treb 
NOINVERTED_C;iL_TREE -- default 

This switch determines which calls led to the present one. A 
reversed order call tree is generated. This switch has no effect 
without the ELABORATOR and UST switches. 

LISt( mllszing-file- spec} 

NOLISt •• default in interactive mode 
LISt -- default for baeJcground processes 

This switch generates a listing file. The default filename is 
derived from the source filename, with a .LIS extension. The 
listing-file-spec can be optionally specified. 






TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3-18 


LOg 

NOLOg •• default 

Ttiis svicch causes the coe^iler to write in the coB^ilatioa log, 
conananri line optiona and the file specification of the Ada source 
file being conpiled which ia written to to SYS$onTPTTr (the 
operating system' a standard output) . This switch ia useful in 
examining batch output logs because it aJ.lowB the user to easily 
dstezmine which files are being compiled. 

MACro 

NOMACro - * default 

This switch produces an assembly like object code listing appended 
to the source listing file. The LIST switch must be enabled or 
this switch has no effect. 

MAIN £LAB 

N0MAIN_E1AB -- default 

This switch makes the cosgsiler treat the compilation unit being 
compiled as a user-defined elaboration or setup program which is 
used instead of that normally produced by the ELABORATOR switch. 
The source file must be specified instead of a unit name of a 
previously compiled procedure. Usually, the source file is 
modified by the user, starting from the version produced by the 
WRITE_ELAB switch. 

MAXerrors-o 

MAXeRRORS« 500 -• defaxilt 

This switch assigns a value limit to the nxmber of errors forcing 
30 b ter m i n ation. Once this value is exceeded, the compilation is 
ter mina ted. Information-level diagnostic messages are not included 
in the count of errors forcing termination. The specified value's 
range ia from 0 to 500. 





TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3 - 19 


MOpELainodeJ - name 


where model-name is one of Che following: 


NOdel-stasdakd 


MOoez^vahp 

MOdei.«ibm_gvsc 

MOoez,.hhe£i._svsc 

MC}del«hmsll~gvsc_fpp 

MODEL-RWELL.EOi 

MOoEI,>RZ1750A 

MOoEL«RI1750AB 

M0oEL-MA317S0 

MOoEL«PACE_1750AE 

M0dEL«MS_17S0B_II 

M0dE1.«MS~175 

M0dEL«MDC281 


-- default 

•- Piroridee coopilacion c a pa bilities chat are 
.. ccennon to all models of the target. 

- - IBM_GVSC target 
-• Honeywell_GVSC target 
-- Haneywell_(jVSC target (with 
floating point processor) 

-• Roclcwell Embedded Compi-ler zurchicecture 
-• Rocicwell International 1750A architecture 
•• Rocicwell International 17S0A/B architecture 
Marconi 31750 aurchiteccture 
•• PACE 17S0AE zirchiceccure 
•- MIL-STD-17S0B, Type II 
-- KIL-STO-1750B. Type III 
Marconi MDC281 


By default, the compiler produces code for the generic or standard 
target. The model switch allows the user to specify a nonstandard 
model for the target; the possible models are indicated in the 
list, above. 

For example, the MDC281 switch selects the MDC281 (MRS 281) 
impl emen tation of MZL-S7D-1750A. 

NEW LIBRARY 

N0NEW_LIBRARY •• default 

The NEH_LIBIiARY switch creates a 175OA subdirectory in your current 
wor)cing directoiry and a 175OA.LIB library in that subdirectory, 
replacing the concents of the prior subdirectory and librairy, if 
they existed. 

The NOIIEW_^LIBRARY switch checics if a 1750A subdirectory exists in 
your current wor)cing directory and if it does not already exist, it 
will create the 1750A subdirectory and a 1750A.LIB library in chat 
subdirectory. 

NOTE: This switch along wish the PARSZn'_LIBRARY switch replaces 

the MAIS LIB switch. 



B-12 






TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3-20 


Object { motj ecs-file - spec} 
Object •* d«£auic 
NOObject 


Tbia swiccti produce* a reloeacable objecc file in the 175QA 
eubdireccory in cn* cuxrenc cocBpilacaon direcrory. Tb* defaulc 
fllenaaa is derived frem cb* source filenasie, wicb a ”.OBJ*. 
exeension. 


OPt -- defaulc 


0Pt(«(p 

NOOPt 


ara8MC*r{ 


N00Pt{ m (parainecer{ 


} 


Tbis swicch enables the specified global opcioizacion of the 
ccetpiled code. The negacxon of this svzcch disables the specified 
global opcimizacion of the compiled code. Certain parameters nay 
be turned on or off as listed below. 


When the OPT switch is entered, without any parameters, all 
optimizations listed below are tiumed on except for those which 
cannot be turned on. When it is entered with parasieters, only the 
specified parameters are turned on. if they can be turned on. This 
restores the parameters to their defaults. 

When the NOOPT switch is entered, without any parameters, all 
optimizatiozui listed below are turned off except for those which 
cannot bo turned off. When it is entered with parasieters, only the 
specified parameters are tximed off, if they czua be turned off. 

Defaulc optimizations shoxild not be changed for normal use. Dsers 
may wish to change these optimizations for ccnfiguracion or testing 
purposes, however, TZJ) Systems recoeanends that they not be 
changed. These default optimizations should be changed only when 
there is an ab n ormal situation with data or the pr o gram or a bad, 
TZJ}' or user-created algorithm. For exasiple, if the p r ogr a m has an 
unused procedure the defaulc opcimizacion parameter OEAD_SDBPROGIUU( 
dafaiilt will delete it for production improvesienc, however, the 
user may not want the unused procedure deleted for Debugger 
purposes. If users are finding a need to change these 
optimizations, pleas* notify TZJ} Syscesis so that wa can resolve the 
problem more efficiently. 


B-13 








TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3-21 



switehea: 


CODE.Moveueitt 

Ibis paxaiurer movaa coda co i a p r o v e execucion cine. (For 
example, moves isvarianc code ouc ot a loop) . Tliis paramecer 
is cuxned on by default and can be cuxned off or on. 

CODE_Straigrterizig 

mis parameter ensures cbac p r ogr a m flow is well formed by 
performing rearrangement of segments of code. Tbis parameter 
is turned on by defaiU.t and be turned off or on. 

C0MMON_SaBEZPRESSION 

Expressions with the same operands are not computed a second 
time. (For example, if an esqsression uses ”A B* and another 
expressions uses "X * B*, the Compiler does not compute the 
second expression, since it )oiows it has already computed Che 
value) . This paramecer is turned on by default and cannot be 
turned off. 

CONsTWrr^ARTTHMETlC 

This parameter performs conscanc arithmetic. This parameter 
is turned on by default anrf cannot be turned off. 

DEAD_Cooe 

This paramecer removes code that cannot be reached such as 
unlabeled code following am unconditional branch. This 
paramecer is turned on ]3y defaxilt and cannot be turned off. 

DEAD_Subprograu 

This paramecer reaioves subprograsia that aire not referenced. 
This paramecer is turned on by default amd can be turned off 
or on. 

D EAD_Variable 

This pauramecer removes local temporary variables that ame not 
used dxiring execucion. This paramecer is turned on tiy default 
and can be turned off or on. 


B-14 







TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3 - 22 


DELassign 

Tbis paraiucer opcimizss code by dalecing reduxidanc 
aaaiqxanencs. It oaly performs deletioos allowed by the 
••nancies of Ada. This parameter is turned on by defaiilt and 
can be turned off or on. 

laLTWE 

By default, the compiler automatically i n lin es 8\ibp re gr a aui 
that are not visible in a package spec and if the estimated 
code size is saialler than the actual call, it will inline it. 
This parameter is turned on by default and can be turned off 
or on. 

LIteral_pool 

This parameter overrides the Compiler's optimization 
separation of compile time constants into a separate memory 
pool. This parameter enables the user to exercise complete 
control over data allocation. This paraaieter is turned on by 
dafaxxlt and can be turned off or on. 

LOop_dhrollihg 

This parameter applies to register memory only. It causes an 
expression computed at the end of a loop to be remembered at 
the top of the next iteration. This paraaieter is turned on by 
default and can be turned off or on. 

Peephole 

This parameter performs optimization in very limited 
contexts. This paurameter is turned on by default and cannot 
be turned off. 

Rbgzster_dedicaxion 

This parameter allows dedication of a register to an object or 
expression value. This paraaieter is turned on by default and 
cannot be tximed off. 

SlNGLS.MOCnLE 

This paraaieter creates one object module per compilation unit 
rather than one for each top-level subprogram. If this 
parameter is not used, and the coatpilation imit spec and body 
are in separate files, the extension ".b" is added to the 
package name in the object file name of the package body 
(i.e., package-name_b.ob^) to differentiate between the 


ura 


B-15 







TLD ADA COMPILER 

Compiler Usage 


1750A-A0A-2B 

3-23 


paclcage body cuid spec. The user aay locace cseecs fron only 
the body or spec by specifylsg the xinique objecc filename ( 
pacJcage-name^b for the body or package-name for the spec) 
followed by the control section name. This parameter is 
turned off by default and cannot be turned on. 

ST RENC3TH_REDDCnOH 

This parameter selects operators that execute faster. This 
parameter is turned on by <^fault and cannot be turned off. 

VALnE_FOLDING 

Substitutions of operands loiown to have the same value eire 
performed before expression aiud.yB3.8 optimization. (For 
example, if B and C have the saaie value, the expression ”A 
C* is used and "A t- B" will be recognized as catmnon emd the 
Compiler will not compute the second expression, since it 
)aiows it has the same value as the first) . This paraaieter is 
turned on by default and cannot be turned off. 


PAGsun 

page ■60 -• default 

This switch assigns a value to the number of lines per page for 
listing. The value can range from 10 to 99. 

PAREot ^LIBRARY spar en c • I ihrary .spec 
NOPAR&r_LIBRARY -- default 

The PAR£in'_HBRARY switch uses the specified library as the parent 
library for the library to be created. 1750A must be included at 
the end of the parent •library-spec. This switch may only be used 
with the NSW_LIBRARY switch. 

If the HOPARSin'_LZBRARY switch is used, the library created by the 
NSH_LIBRARY switch will have no parent library. 

NOTE: This switch along with the NSW_LIBRARY switch replaces the 

MAICS_LIB switch. 

PARMs 

NOPARMs -- default 

This PARAMETER switch causes all option switches governing the 
campilation, including the defaulted option switches, to be 
included in the listing file. The LIST option switch must also be 
selected or this switch has no effect. User specified switches are 
preceded in the listing file by a leading asterisic (*). This 
switch adds approximately one page to the listing file. 


~ —^- 


LTD 


B-16 








TLO ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3-24 


PHase -• daf&uit 
NOPHase 

nils Bwiech suppresB** th« display of phase nanes duxiag 
coapilacioa. This sviech is useful in bacch jobs because it: 
reduces che verbosicy of the batch log file. 

REF Xd CASEappcioo 
NOREFJId. CASEaopciflo -- default 

This is a reformatting option, under the control of the REFORMAT 
svitch. This switch determines how varitUale names appear in the 
compiler listing. The options for this switch are: 

ALL_LOWER •• All variable names are in lower case. 

ALL_UNDERLIKED -• All variable names are underlined. 

ALL_UPPER •• All variable names are in upper case. 

AS_IS -- All variable naaies appear as is. 

1MIT1AL_CAPS •• All variable names have initial caps. •• default 

IBSERT_DHDERSCORE •• All variable naaies have underscores. 

REF Key ^CASEaopeion 
NOREF_KsY_CASE>opeioc default 

This is a reformatting option, under the control of the REFORMAT 
switch. This switch determines how Ada Icey words appear in the 
compiler listing. The options for this switch are: 

AXiL_LOWSR •• All Ada hey words are in lower case. -- def a u lt 

AZ1,_UMDER1,IIIED •• All Ada hey words are underlined. 

AZ<Ii_nPPSR •• All Ada key words are in upper case. 

AS_ZS -• All Ada key words appear as is. 

InlTiAL^CAPS -- All Ada key words have initial caps. 

UTSERT^DRDERSCORE - • All Ada key words have underscores. 

reformat {areformac • file-spec} 

NOREFOrmAT -- default 

This switch causes the coogiiler to reformat the source listing in 
the listing fils (if no refoxmat-file-spec was p r o v ided) or 
generate a reformatted source file, if a refocoac-file-spec is 
present. The default file extension of the reformatted source file 
is ”.RFM" . Reformatting consists of uniform indentation and retains 
nisneric literals in their original source form. This switch 
performs zhe reformatting as specified by the RSF_ID_CASE. 
REF_KEY_CASE, and INDENTATION switches. 


LTO 


B-17 







TLO ADA COMPILER 

Compiler Usase 


1750A-ADA-2B 

3 - 25 


SOdrcs •- d«£ault 
NOSOurce 

Ibis svicc& cauaes die ispuc source progcaa to be inc lud e d in the 
listing file. Unless they are suppressed, diagnostic messages are 
always included in the listing file. 

STACK Abirlysis 
NOSTAlK.AioiLYSIS -- default 

This switch is used with the SIABORATOR and LIST switches to read 
in .cn files (corresponding to the cooplete sec of object files 
being linJced for the program) . The subp r ogr a m call tree is 
analyzed to compute scacic reguiremencs for the main program axid 
each dependent taaic and writes the scacic requireswncs to the .LZ5 
file, without the ELRBORATOR switch, at compile time, it records 
the call information and stacic information for each subp r og ra m and 
for any casic, the tas)c is allocated with an undefined storage 
size. The storage size is defined by either the STACKEDIRECTZVES 
switch or default value at link time. 

MOTES: The tree is incomplete if any required cosipilacion unit's 
.CTZ files axe missing. 

Recursion cannot be accounted for because this is a scacic 
analysis. 

STACK Directives 
NOSTACK_DlRECnVES -- default 

This switch determines the amanmc of stack space chat must be 
allocated for a cask, based on the stack size previously calculated 
by S'tRCX_AMALYSIS. (Stack must be used in conjimction with the 
STACEJUZRLYSIS switch) . 

STATIC iHiT 

NOSTAHC, JNn •• default 

For statically aaiocaced objects chat are initialized with constant 
values, the STAnc_IMIT switch causes the memory location of 
statically allocated objects to be loaded with their conscanc 
values at load time instead of generating the instructions to score 
the conscanc values at sscecution time. 

MOTE: The XTRA switch is required when using the STAT1C_IMXT 

switch. 





TLD ADA COMPILER 

Compiler Usage 


1750A-ADA-2B 

3 - 26 


SYNtwc ohly 

N0SYN^_ pi9Z.T •• defaulc 

This sviech perlonna syntax and samancic chacJcing on the sourca 
p r ogr a m. No object fila is produead and tha MACRO svicch is 
ignorad. Tha Ada P r og ra m Library is not tipdaced. 

Target- 175 OA •• dafaiiic 

This svicch salaces cha cargec cocqmcar for which coda is to ba 
ganaraead for chis eoo^ilacion. ”17S0A” salaccs cha MIL*STD-1750A 
Inscruccxon Sac Archiceecure. 

warnings dafauic 

NOWArnings 

The WARNINGS swrcch oucpucs warning and higher level diagnoscic 

messages. 

The NOWARNINGS swicch suppresses Che oucpuc of both warning-level 
and informacion-level diagnoscic messages. 

WIoTH-n 

WIoTH-110 •• dafatilc 

This swicch secs the number of charaecers per line (80 co 132) in 
cha listing file. 

WRite_slrb 

NOWRitS.ELAB •• default 

The WRZTE_ELAB switch ganeraces an Ada source file which 
represents cha main elaboration "setup” p r og ra m created by the 
costlier. The unit name of a previously compiled procedure muse 
be specified instead of a soxirce file. The WRZTS^ELAB switch may 
not ba used at the same cima as the SZABORATOR svicch. 

Xtra 

NOXtRA -- dafaiilc 

This svicch is used co access features under development or with 
Che STAnc_lNlT swicch. See che description of this switch in 
Section 3.12. 







CCHPIIAnON SYSIEN OPTIGNS 


LINKER OPTIONS 

The linker options of this Ada implementation, as described in ^is Appendix, 
are provided by the customer. Unless specifically noted otherwise, references 
in this appendix are to linker documentation emd not to this report. 


B-20 






Tin EXTENDED MEHORY LINKER 

Host Oepehoencxes 


1750A-LNK-3F 

5 - 3 


5.1.1 String Substitution 

string subscicucion allows the user co specify strings on the cocsnand 
line which aire substituted for forael parameters in the directive file. 
This capability allows the user co create model directive files which 
are tailored by string subscicucion at each execution of TLDlnJc. 

A formal parameter in the directive file is a n a me or number sxirrounded 
by braces ({ }) . The strings on the gjii i iiian d line are indicated by the 
switch ST RIWB S and/or by the switch PROGRAM. (See Section 5.1.2 for the 
STRZ2IG and PROGRAM switches and Sections 5.2.2 and 5.3.2 for examples of 
string replacement.) 


5.1.2 Switches 

The switch-list consists of an optional series of switches. 
swicch{svicch...} 

“me switch format consists of a prefix of "/" for VAX hosted systems or 
" •" for UNIX hosted systesis followed by an identifying )cey word and an 
optional value or list of values. This section provides descriptions of 
the switch key words. 



ura 


B-21 




TLD EXTENDED MEMORY LINKER 

Host Dependencies 


1750A-LNK-3F 

5 - 4 


SWITCH NAME 


MEANING 


ABSOLnTE_LlSTIira 

NOftBSOLOTE^LI S T IMG 

Tliis swicch produces a .aiix file eonca in i n g che absoluce 
addresses of control sections and iaports. Ttiis file along 
with a caBipiler*generated or aasefflbler*generated .lix file 
(containing a list of control sections and iaports and control 
section and iaport numbers with references to the macro 
listing file) and source listing file, .1st on UNIX hosted 
systems or .lis on VAX hosted systems, axe used by the TZS 
Absolute Listing Utility to produce a macro listing . 2 Lbs file 
containing absolute rather than relative addresses. Refer to 

the Reference Document for the TLD__ggWPiaier or the 

Reference_Document for the TLD__ftffggmPler -or the 

ABSOLUTE_LISTTNG switch that produces the .lix file and MACRO 
and LIST switches that produce the .1st or .lis file and to 
the Reference Document for the TLD MIL-STP-17S0A Utilities for 
fiirther information regarding the macro listing containing 
absolute addresses rather than relative addresses which are 
normally created by the TLD Ada Compiler or TID Macro 
Assembler MACRO and LIST switches. 

ALOCMAP 

NQALOCMAP 


The AXiOCMAP switch, if used, must be used in combination with 
the MAP switch to produce a map file. The contents of the map 
file depends on the other map file switches used in 
combination with this switch and the MAP switch. 3y default', 
this switch will produce a map file consisting of: l) a list 
of input switches and directives, 2) an allocation map 
(containing nodes, modules, control sections, and external 
symbols) , and 3) an alphabetical symbols listing (containing 
external symbols sorted in alphabetical order) . The name of 
the map file is derived according to the process explained in 
the MAP switch description (below) . 

The NQALOQIAP switch, will not produce an allocation map 
listing in the map file. 

The other map file switches are: SYMBMAP, NOSYMBMAP, NODCMAP, 
NOMODEMAP, MOOMAP, and NOMODMAP. 


ASan 


This switch specifies the number of address states to be used 
by the program being linhed. 







TLD EXTENDED MEMORY LINKER 

Host Dependencies 


1750A-LNK-3F 

5 - 5 


This switch has ths saoie fviaccionality as the linker directive 
ADDRESS STATES described in Chapter 4. 

DEBUG{sfile• spec) 

When DEBUG is used the linker creates a debug file containi n g 
symbols and their values for the symbolic debugger and a 
traceback file containing call and branching information. If 
DEBUG is not specified, the linker does not produce the debug 
file and traceback file. The linker puts symbols which were 
included in the relocatable object file in the debug file and 
traceback information eilso in the relocatable object file in 
the traceback file. If no file-spec is specified, the name of 
the debug file and traceback file is derived according to the 
process described in the MAP switch description (below) , but 
by default, they will have .dbg and .trb file nasie extensions, 
respectively. The format of the debug and traceback files is 
described in Appendix A. 

This switch has the same functionality as the linker directive 
DEBUG described in Chapter 4. 

When DEBUG is used, TLD symbol files (.dbg and .trb) are 
generated if LDNTTPE * HSU or 113S. is specified. The HP linker 
symbol file (.1} and an assembler symbol file !.a) axe 
produced whenever LDHTTPE«HP is specified. 

DIRECTIVE {■file - spec) 

The DIRECTIVE switch lets TLDlnk know that a directive file 
provides linker directives in addition to those provided on 
the command line. The coonsand line switches override those in 
the directive file in case of conflicting directives. If no 
file-spec is supplied, the directive file is named 
<input_f ile_spec>. Ink. If the DIRECTIVE switch is not 
supplied, there is no directive file. The directive file name 
must be specified if no input-file-spec is provided on the 
coBsnand line. 

EHTRy{■file-spec) 

When KWruv is used, the entry module file is produced. If no 
file-spec is specified, the name of the entry module file is 
derived according to the process explained in the MAP switch 
description (below) . The default file extension of the entry 
module file is .ent. If no ENTRY switch is supplied, the 
entry module file is not produced. 

The ENTRY MODULE directive, described in Chapter 4, may be 
used in the directive file to restrict the entry points that 
are defined in the entry module file. 







TLD EXTENDED MEMORY LINKER 

Host Oependenczes 


1750A-LNK-3F 

5-6 


ERROR 

ROERROR 


This switch lists or svippresses error massages. ROERROR 
stippresses errors, warnings, and information massages. 

IRFORMRTIOR 

NOZRFORUATIOII 

This switch lists or suppresses informational massages. 
ROIRFORllATZOR suppresses only information massages. 

LOH{ afile-spec) 

HOLDM 

The load module file is produced by default, unless the switch 
KOLDM IS explicitly provided. Therefore, this switch is 
normally used with a file*spec frcm which the name of the load 
module file is to be derived. If no file extension is 
provided, .1dm is used. If the file>spec is not provided, the 
n a me of the load module file is derived according to the 
process explained in the MAP switch description (below) . 

LOtflTPEaformac(, format...} 

USMnrPEaLSM •• default 

LDtCTTPE-LLM 

U3tfnrPE-HF 


IdCZTPE specifies the format of the load module and symbol 
file<s) TLDlnh is to produce. Three formats eire currently 
available. Only one format may be specified for a linh. See 
DEBUG for related information. 

o LDM (file extension .1dm), the default, specifies-:Che TLD 

load module format. 

o LX^ (file extension .11m) specifies a format that is 

sisulax to the TZJ3 load module format, but with logical 

addresses instead of physical addresses. 

o HP (file extension .x) specifies the Hewlett-Pacieard 

HP64000 absolute file format. 

This switch has the same functionality as the linlcer directive 
LDMTypE described in Chapter 4. 







TID EXTENDED MEMORY LINKER 

Host Dependencies 


1750A-LNK-3F 

5 - 7 


On DHIZ hoaced syscems: 


l9t.msymbolMsymbol{ , ...} 


On V3UC hosced syscams: 


LET* (symbolrnsymbol ( 

This svicch cauass the givan symbols co be defined. 

This svicch has cha same fmccionalicy as che linker direccive 
IXT described in Chapter 4. 

MAP{«file•spec} 

This svicch controls che generation of a map discing) file. 
If this switch is noc specified, che linker does not produce a 
map file. The concents of the map file depends on che ocher 
map file svitches used in combination with this svicch. By 
default, this svicch will produce a map file consiscing of: 1) 
a list of iz^uc switches and directives, 2) an allocation map 
(containing nodes, modules, control sections, and external 
systiools) , and 3) an alphabetical symbols listing (containing 
external symbols sorted in alphabetical order) . If a full 
file-spec is provided, then chat is che file specification for 
the map file. If a file-spec with no file extension is 
provided, then TLDlnk uses the default file extension of 
.map. If che file-spec is noc provided, che file name for the 
map file is derived from: 1) the name of the first object file 
on the co mma nd line, or 2) the name of the direccive file if 
no object file is provided on the command line. 

The other map file switches are: ALOOSAP, NQALOOSAP, STMBMAP, 
HOSTKBtlAP, NOOEMAP, NC3IIODEUAP, MODMAP, and NDMODNAP. 

MAXADR«address 

This switch sacs the maximum physical address to be used by 
che program being linked. If che MAXADR switch is noc 
provided, TI,Dlnk uses a maximum address of FFFF. 

This switch has che saaie functionality as che linker directive 
MAXADR described in Chapter 4 . 

MODCL>modeI- type 

This switch indicates whether the processor uses non-standard 
ROM where c.he startup ROM enable bit is used as a pseudo 
address state. The argument model-type is standard or 
Ih* default is standard. The sur_as argument is used 
for non-standard ROM. ” 









TU) EXTENDED MEMORY LINKER 

Host Dependencies 


1750A-LNK-3F 

5 - 8 


mqdmap 

NC3tS3D£mP 


Hie MOOMJVF swirch, if xiacid. muse be used in coBbinacios vicb 
Cbe MAP switch to produce & map file. The concents of the map 
file depends on the ocher map file switches used in 
coBabinacion with this switch and the MAP switch. By default, 
this switch will produce a map file consisting of: 1) a list 
of input switches and directives, 2) an allocation map 
(concaining nodes, modules, control sections, and external 
symbols) , 3) an alphabetical symbols listing (containing 
external symbols sorted in alphabecrcal order) , and 4) eui 
alphabetical modules listing (containing modules sorted in 
alphabetical order) . The name of the map file is derived 
according to the process explained in the MAP switch 
description (above). 

The NOMOOMAP switch, will not produce an alphabetical modules 
listing in the map file. 

The ocher map file switches are: ALOCMAP, UQALOCMAP, NODEMAP, 
NONODEMAP, STMBMAP, and NQSTMBMAP. 

NODE{•name) 

This switch names the first node of the linh. If this switch 
is not included, TTDlnh names the first node ROOT. 

The linher NODE directive, described in Chapter 4, may be used 
to group modules or selected control sections from modules. 


NODEMAP 

NONODEMAP 


The NODQIAP switch, if used, must be used in combination with 
Che MAP switch to produce a map file. The concents of the map 
file depends on the other map file switches used in 
combination with this switch and the MAP switch. By default, 
this switch will produce a map file consisting of: 1) a list 
of input switches and directives, 2) a node structure listing 
(containing the address state of each node) , 3) an allocation 
map (containing nodes, modules, control sections, euid external 
symbols) , and 4) an alphabetical symbols listing (concaining 
external symbols sorted in alphabetical order) . The name of 
the map file is derived according to the process ei^lained in 
the MAP switch description (above). 




TLD EXTENDED MEMORY LINKER 

Host Dependencies 


1750A-LNK-3F 

5 - 9 


ITi* NONODEMAP swiccH. will not produco a node structure 
listing in the map file. 

■Ihe other map file switches are: ALOQOLP. NOALOOBIP, smSHAP, 
NOSYMBMAP. MODMAP, and NOHODMAP. 


PROGRAMS s tring 

This switch specifies a single string which is a n a me d entry 
with the nasie "PROGRAM", and which also overrides the 
directive file naaie as the default name of the files produced 
by the linher. If "PROGRAM*string is entered, then string 
replaces all occurrences of the formal parameter {program} in 
gh* directive file. In addition, string becomes the default 
name for the files produced by the linker (i.e., the map file, 
load module file, debug file, and traceback file). 

(See Sections S.2.2 and 5.3.2 for an example of program name 
string replacement on the host system.) 

RESERVE-{addrl, addr2} 

This switch reserves meaiory space. Multiple RESERVE switches 
are allowed. 

This switch has the same functionality as the linker directive 
RESERVE described in Chapter 4. 

On UNIE hosted systems: 

search(«file>spec{, file-spec ...}} 

On VAX hosted systems: 

SEARCH{-(file-spec{, file-spec ...})} 

On '/AX hosted systems, the parentheses may be omitted if only 
one file-spec is provided. When this switch is used, TLDlnk 
searches the specified files in the pattern described for the 
SEARCH directive. Multiple SEARCH switches are allowed. No 
default file extension is assumed for this switch. 

This switch has the same fiuctionality as the linker directive 
SEARCH described in Chapter 4. 


B-27 






TLD EXTENDED MEMORY LINKER 1750A-LNK-3F 

Host Dependencies 5-10 


On OITIZ hoscad syscems: 

strings* {scriagrl, .••}{.} {n«mft2*scring2, —} 

On VAX hosted systems: 

STRIiras*{ (} {stringl-} {, } {name2»scring2....}{)} 

The comma, between the two types of strings is required to 
separate them only if both typee are used. On VAX hosted 
systaais. if only one string is specified, the parenthesis are 
not required. 

The strings specified in this switch are substituted for 
formal parameters in the directive file. This c apab ility 
allows the creation of model directive files with are tailored 
by string substitution at each execution of TLDlnJt. A formal 
parameter in the directive file is a name or number surrounded 
by braces ({}). 

Strings of the form scringl are positional entries. The first 
such entry replaces aill occurrences of the formal parameter 
{1} in the directive file, the second such entry replaces all 
occurrences of the formal parameter {2}, etc. Strings of the 
form aame2mscrzn^2 are named entries. The string stxia^2 
replaces all occxirrences of the formal parameter {name!} in 
the directive file. 

If both positional entries and named entries appear, then all 
Che positional entries must precede the named entries. 

If there is no string specified for a formal parameter, then 
the null string is substituted for the formal parasieter. 

(See Sections 5.2.2 and 5.3.2 for an example of formal 
parameter string replacement on the host system.} 


STUBMAP 

tfOS'nSMAP 


The SYMBMAP switch, if used, must be used in combination with 
the MAP switch to produce a map file. The contents of the map 
file depends on the other map file switchee ueed in 
combination with this swicch and the MAP switch. By default, 
this switch will produce a map file consisting of: 1) a list 
of input switches and directives, 2) an allocation map 
(containing nodes, modules, control sections, and external 
symbols), amd 3) an alphabetical symbols listing (containing 
external symbols sorted in alphabetical order) . The name of 
the map file is derived according to the process es^lained in 
the MAP swicch description (above). 


B-20 







TLD EXTENDED HEHORY LINKER 

Host Dependencies 


1750A-LNK-3F 

5-11 


The NOSVlfflUAP swicch, will noc produce an alphaLbecical symbols 
liscing in the map file. 

‘Hie other "'■p file svitches aure: .RLOCMRP, NOAIO QI A P , NODgMAP. 
tOTODEHAP, MODMAP. and NOfiCOMAP. 


WARNIKG 

NOUARNXNG 


This switch lists or suppresses warning messages. NOHASMINU 
stippresses warning and information massages. 


5.2 VAX (VMS) Host 


This section provides descriptions for all host dependencies except for 
Directive File host dependencies. They are discussed in Chapter 4 . 


5.2.1 VAX (VMS) Execution 

TLDlnh running under the VAX/VMS operating system is invoked by issuing 
the following command. 

$ unCTLD{fiIe<svicch-lisc} 
or 

S INK.{ file-swxcch-list) 
if the abbreviated form is supported. 

The syntax of a switch is a slash (/) followed by an option switch name 
and, for certain switches, an equal sign (>), or interchangeably a colon 
(:}, followed by a value or list of values. Zf a list of values is 
used, the list is enclosed in parentheses emd the individual values are 
separated by cossnas. 

/svicch-aamei *vaiue(, ...]] 
or 

/s*ficeli-tume{ : value. . ..) } 


B-29 









APPWDIX C 


APPENDIX F OF TOE Ada SOANCARD 


The only allowed Isplementation dependencies correspond to 
inpleinentation-dependent pragmas, to certain machine-dependent conventions as 
mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The implementation-dependent 
characteristics of this Ada implementation, as described in this Appendix, are 
provided by the customer, unless specifically noted otherwise, references in 
this J^jpendix are to conpiler documentation and not to this report. 
Inplementation-specific portions of the package STANDARD, vhich are not a part 
of ^>pendix F, are: 


package STANDARD is 


type INTEGER is range -32768 .. 32767 ; 

type LaNG_INTBGER is range -2_147_483_648 .. 2_147_483_647 ; 
type FLOAT is digits 6 range -1.70141E+38 .. 1.70141E+38; 
type LONG_FLQAT is digits 9 range -1.70141183E+38 .. 1.70141183E+38; 
type DURATION is delta 2.0**(-14) range -86400.0 .. 86400.0 ; 


end STANDARD; 


C-1 





APPENDIX F 


The Ada language definition allovs for certain machine_dependencieB in a 
controlled manner. No machine-dependent syntuc or semantic extensions or 
restrictions are allowed. The only allowed implementation-dependencies 
correspond to implementaton-dependent pragmas and attributes, certain 
machine-dependent conventions, as mentioned in chapter 13 of the 
MZL-STD-1815A; and certain allowed restrictions on representation 
clauses. 

The full definition of the implementation-dependent characteristics of 
the TLD VAX/MIL - STD-1750A Ada Con?3iler System is presented in this 
section. 


C-2 







TLD ADA COMPILER 1750A-ADA-2C 

Mil-Std-1750A Bare Machine Target Compiler 5-6 


STACK= s cack_size 
STACK=2000 -- default 

The number of words reserved for the progreun's stack is provided by 
the STACK switch. The parameter scack_size is a hexadecimal 
number. Stack space is allocated from the heap. 

ALK also produces the files described below. 

o inain_prog.lNC 

This file is created by the Ada Con^iler during the el«d3oration 
step. Each line specifies an object file to be "included" in the 
linker directive file. (Run time library xonits are not included). 

o main_prog^ EliAB. OBJ 
o main_prog$ EliAB .LIS 

These files contain the relocatcJsle object euid listing for the 
elaboration subprogram. The file name is formed from the main 
program name appended by the string "SELAB". However, if the 
length of the meucimiom host file name is exceeded by appending this 
string, then the string replaces characters at the end of the main 
program name. 

For example: 

$ ALK TEST/STACK=4000/1NC=MY_ASM.OBJ 

ALK invokes the Ada Compiler with the "/ELABORATE" switch to cotr^ile 
eleiborations auid generate the .INC emd .OBJ files. After successful 
con^letion of the eledroration step, ALK generates a linker directive 
file from data specified by the STACK switch, the .INC file, euid files 
specified by the INCLUDE switch. ALK will then invoke the linker to 
produce the program load module (.LDM), the progreun map file (.MAP), 
and the debugger information files (.DBG, .TRB, and .SYM) . 


5 . 2 LRM Correspondence 

This section identifies correspondences between features of the TLDacs 
and sections of the Ada Language Reference Manual (LRM). 


5.2.1 LRM CH.l - Introduction 

The formal standards for the Ada Progrzunming Lemguage are provided in 
the Ada Language Reference Manual (LRM), ANSI/MIL-STD-1815A. TLD 
Systems has developed TLDacs in the spirit of those standards. 


C-3 




TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5 - 7 


The machine dependencies permitted by the Ada language are identified 
in LRM Appendix F. No machine dependent syntax, semantic extensions, 
or restrictions are allowed. The only acceptable in^lementation 
dependencies are pragmas and attributes, the machine dependent 
conventions explained in LRM Chapter 13, and some restrictions on 
representation clauses. 


TLD Systems has developed ixt 5 >lementation-dependent software to 
specifically conform to these restrictions emd has developed 
inplementation-independent pragmas and attributes in the spirit of the 
LRM. This software is described, below, in individual discussions that 
follow the topical order (within chapters auid appendices) of the LRM. 
For a detailed description of the Run Time environment, refer to the 
Reference Document for the tt.d Run Time System 


5.2.2 LRM CH.2 - Lexical Elements 

The items described in this section correspond to the stemdards in 
Chapter 2 of the LRM. 

The following limits, capacities, and restrictions are inposed by 
the Ada compiler implementation: 

The maximum number of nesting levels for procedures is 10. There 
is no limit to nesting of ifs, loops, cases, declare blocks, select 
and accept statements. 

The mcocimum number of lexical elements within a language statement, 
declaration or pragma is not explicitly limited, but limited 
depending on the combination of Ada constructs coded. 

The meocimum number of procedures per conpilation unit is 500. 

The maximum ntimber of levels of nesting of INCLUDE files is 10. 
There is no limit on the total number of INCLUDEd or WITHed files. 

approximately 2000 user-defined elements are allowed in a 
conpilation unit. The exact limit depends upon the characteristics 
of the elements. 

A maximum of 500 severe (or more serious) diagnostic messages are 
allowed for a compilation. 

The reinge of status values allowed is the same as the range of 
integer values, -32_768 .. 32_767. 

The maocimiom number of parameters in a procedure call is 20. 


C-4 








TLD ADA COMPILER 1750A-ADA-2C 

Hil-Std-1750A Bare Machine Target Compiler 5-8 


The mBucimum number of characters in a name is 120. 

The maximum source line length is 120 characters. 

The maiximum string literal length is 120 characters. 

The source line terminator is determined by the editor used. 
Name characters have external representation. 


5.2.3 LRM CH.3 - Declarations and Types 

The items described in this section correspond to the standards in 
Chapter 3 of the LRM. 

Number declarations are not assigned addresses euid their names are 
not permitted as a prefix to the 'address attribute. 

Objects are allocated by the cc^qpiler to occupy one or more 16 bit 
words. Only in the presence of pragma Pack or record representation 
clauses are objects allocated to less than a word. 

'Address can be applied to a constant object to return the address 
of the constant object. 

Except for access objects, uninitialized objects contain an 
undefined value. An attempt to reference the value of an 
uninitialized object is not detected. 

The meocimum number of enumeration literals of all types is limited 
only by available symbol table space. 

The predefined integer types are: 

Integer rBuige •32_768 .. 32_767 and is implemented as single 
precision fixed point data. 

Ijong_Integer range -2_147_483_648 .. 2_147_483_647 and 

inqplemented as double precision data. 

Short_Integer is not supported. 

System.Min_Int is -2_147_483_648. 

System.Max_Int is 2_147_483_647. 


C-5 






TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


17S0A-ADA-2C 

5 - 9 


The predefined real types are: 

Float digits 6. 

Long_Float digits 9. 

Short_Float is not presently supported. 

System.Max_Digits is presently 9 and is in^lemented as 48-bit 
floating point data. 

There is no predefined fixed point type name. Fixed point types 
are inplemented as single or double precision data depending upon 
the rcuige of values by which the type is constrained. 

Index constraints and other address values (e.g., access types) are 
limited to an unsigned range of 0 .. 65_535 or a signed range of 
-32_768 .. 32_767. 

The maiximum array size is limited to the size of virtual 
memory: 64K words. 

The maximum string length is 32_767. 

Access objects are implemented as an unsigned 16 bit integer. The 
access literal Null is implemented as one word of 0. 

There is no limit on the number of dimensions of an array type. 
Array types are passed as parameters opposite vinconstrained formal 
parameters using a 3 word dope vector illustrated below: 

+ _ + 

I Word address of first element | 

I Lower boimd value of first dimension | 

I Upper bound value of first dimension | 

+ _ + 

Additional dimension bounds follow immediately for arrays with more 
them one dimension. 

Packed strings are generated instead of vmpacked strings. 


C-6 







TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5-10 


5.2.4 LRM CH.4 - Names and Expressions 

The items described in this section correspond to the standards in 
Chapter 4 of the LRM. 

Machine_Overflows is True. 

Pragma Controlled has no effect since garbage collection is never 
performed. 


5.2.5 LRM CH.5 - Statements 

The items described in this section correspond to the standards in 
Chapter 5 of the LRM. 

The maximiam number of statements in aui Ada source program is 
undefined and limited only by symbol tadsle space. 

Unless they are quite sparse. Case statements are allocated as 
indexed junp vectors auid therefore, are very fast. 

Loop statements with a "for" inqplementation scheme are inplemented 
most efficiently if the range is in reverse and down to zero. 

Data declared in block statements is elaborated as part of its 
containing scope. 


5.2.6 LRM CH.6 - Subprograms 

The items described in this section correspond to the steuidards in 
Chapter 6 of the LRM. 

Arrays, records, euid task types are passed by reference. 


5.2.7 LRM CH.7 - Packages 

The items described in this section correspond to the standards in 
Chapter 7 of the LRM. 

Package elaJboration is performed dynaunically, permitting a warm 
restart without reloading the progreun. 


C-7 









TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5 - 11 


5.2.8 LRM CH.8 - Visibility Rules 

Not applicable. 

NOTE: TLD has not produced a modification of the item(s) described in 
this LRM section or documentation parallel to the information in this 
LRM section. 


5.2.9 LRM CH.9 - Tasks 

The items described in this section correspond to the standards in 
Chapter 9 of the LRM. 

Task objects are implemented as access types pointing to a Process 
Control Block (PCB). 

Type Time in package Calendar is declared as a record containing 
two double precision integer values: the date in days and the real 
time clock. 

Pragma Priority is supported with a range defined in System_.Ada. 
Pragma Shared is supported for scalar objects. 

Package Calendar is described in the Reference Document for the TLD 
Ada Run Time System, 1750A Target. 


5.2.10 LRM CH.IO - Program Structure/Compilation 

Ada Program Library processing is described in The Reference Document 
for the T LD Ada L ibrary Manager. 1750A Target. 

Multiple Ada Program Libraries are supported with each library 
containing an optional ancestor library. The predefined packages are 
contained in the TLD standard library, 1750A.LIB 


5.2.11 LRM CH.ll - Exceptions 

Exception handling is described in the Reference Document for the TLD 
Ada Run Time System, 1750A Target. 


C-8 











TLD ADA COMPILER 

Mil-Std>1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5 - 12 


Exception objects are allocated access objects to the exception name 
string. The in^lementation of exceptions is described in the Reference 
Document for the TLD Ada Run Time System. 1750A Target. 

Exceptions are implemented by the TLD Ada Conpiler System to t 2 Uce 
advantage of the normal policy in real time computer system design to 
reserve 50% of the duty cycle. By executing a small number of 
instructions in the prologue of a procedure or block containing an 
exception heuidler, a brauich may be t6dcen, at the occurrence of eui 
exception, directly to a handler rather than performing the time 
consuming code of unwinding procedure calls cUid stack frames. The 
philosophy taken is that an exception signals an exceptional condition, 
perhaps a serious one involving recovery or reconfiguration, and that 
quick response in this situation is more inportant and worth the small 
throughput tradeoff in a real time environment. 


5.2.12 LRM CH.12 - Generic Units 

Generic implementation is described in the Reference Document for the 
TLD Ada Run Time System. 1750A Target. 

A single generic instance is generated for a generic body, by default. 
Generic specifications and bodies need not be conpiled together nor 
need a body be compiled prior to the conpilation of an instantiation. 
Because of the single expemsion, this implementation of generics tends 
to be more favorable of space savings. To achieve this tradeoff, the 
instantiations must, by nature, be more gener..i and are, therefore, 
somewhat less efficient timewise. Refer to pragma INSTANTIATE for more 
information on controlling instantiation of a generic. 


5.2.13 LRM CH.13 - Clauses/Implementation 

Package System definitions are described in Section 5.2.B of this 
manual. 

Representation clause support and restrictions are generally described 
in Section 5.2.F. 


C-9 








TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5-13 


Additional Information 

A con^rehensive Ilachine_Code package is provided emd supported. 

Dnchecked_Deallocation euid Unchecked_Conversion are supported. 

The inplementation-dependent attributes are all supported except 
'Storage_Size for an access type. 

Procedure Unchecked_Deallocation {LRM 13.10.1) 

Function Unchecked_Conversion (LRM 13.10.2) 


5.2.14 LRM CH.14 - Input/Output 

The items described in this section correspond to the steuidards in 
Chapter 14 of the LRM. 

File I/O operations are not supported. 

Input/output packages and associated operations are explained in 
Section 5.2.F of this manual. 


5.2.A LRM App.A - Predefined Language Attributes 

The items referenced in this section correspond to the steuidards in 
i^pendix A of the LRM. 

All LRM-defined attributes are supported by the TLDacs. 


5.2.B LRM App.B - Predefined Language Pragmas 

The items described in this section correspond to the standards in 
i^pendix B of the LRM. Any differences from the inplementation 
described in the LRM are listed below. 

PRAGMA CONTROLLED 

This pragma is not supported. 


C-10 










TLD ADA COMPILER 1750A-ADA-2C 

Mil-Std-1750A Bare Machine Target Compiler 5-14 


PRAGMA ELABORATE 

This pragma is implemented as described in the LRM. 


PRAGMA INLINE 

This pragma is inplemented as described in the LRM. 


PRAGMA INTERFACE 

pragma interface (languags_name, Adla_entity_name{, string}) ; 

pragma interface (system, Ada_entity_name, BEX_nuinber, Jt2_value) ; 

pragma interface (indirect, name ); 

pragma interface (direct, name ); 

pragma interface (MIC, subprogram_name ); 

Pragma Interface allows references to subprogreuns and objects that 
are defined by a foreign module coded in a leuiguage other them Ada. 

The following interface languages are supported: 

o System for producing a call obeying the standard calling 
conventions except that the BEX instruction is used to produce a 
software interrupt into the kernel supervisor mode, 
o Assembly for calling Assembly language routines; 
o MIL-STD-1750A for defining built-in instruction procedures, 
o C for calling C coded routines. 

If the Ada_entiCy_name is a subprogram, LRM rules apply to the 
pragma placement. Pragma Interface may be applied to overloaded 
subprogram ncunes. In this case, pragma Interface applies to all 
preceding subprogram declarations if those declarations are not the 
target of ^Lnother pragma Interface. 

For example: 

package Test is 
procedure PI; 

pragma Interface (Assembly, PI, "Asm_Routine_l"); 
procedure PI (x:Long_Float); 

pragma Interface (Assembly, PI, "A8m_Routine_2"); 
end Test; 

In the exan^le above, the first pragma Interface applies to the 
first declaration of procedure PI. The second pragma Interface 
applies to only the second declaration of procedure PI because the 
first declaration of PI has already been the object of a preceding 
pragma Interface. 







TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5 - 15 


If the Ada_EnCity_Name is an object, the pragma must be placed 
within the same declarative region as the declaration, after the 
declaration of the object, cuid before euiy reference to the object. 

If the third parameter is omitted, the Ada neune is used as the name 
of the external entity 2 uid the resolution of its address is assumed 
to be satisfied at link time by a corresponding named entry point 
in a foreign language module. 

^If the optional string parameter is present, the external name 
provided to the linker for address resolution is the contents of 
the string. Therefore, this string must represent eui entry point 
in another module and must conform to the conventions of the linker 
being used. 

An object designated in an Interface pragma is not allocated euiy 
space in the compilation lonit containing the pragma. Its 
allocation and location are assumed to be the responsibility of the 
defining module. 

When pragma Interface has the system parameter, it tells the 
compiler what values apply to BEX and R2 when the ada_entity_name 
is used. 

When the /INDIRECT option is used, the specified procedure, 
function, or package is called indirectly. 

When the /DIRECT option is used, the specified procedure, function, 
or package elaboration code is called directly. This pragma 
overrides the /INDIRECT switch. 

Pragma Interface with the MIC option is ignored unless the command 
line switches /TARGET=1750A and /MODEL*VAMP appear. The Ada 
Compiler marks the subprogram name specified as a VAMP microcode 
subprogram. If a call is made to a subprogram of this type, a 
diagnostic is issued. An attribute reference may be made to these 
subprograms with the attribute designator 'ADDRESS. This reference 
is implemented as a reference to an import symbol whose value is to 
be satisfied by TLDlnk. 


PRAGMA LIST 

pragma List (on | off); 

Conpiler switch /LIST must be selected for the pragma List to be 
effective. 


C-12 





TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5 - 16 


PRAGMA MEMORY.SIZE 

pragma Memory_Size (numeric_liCeral ); 

This pragma is not supported. This number is declared in package 
System. 

PRAGMA OPTIMIZE 

This pragma is not supported. Compiler switches control conpiler 
optimization. 


PRAGMA PACK 

This pragma is implemented as defined in the LHM. 

PRAGMA PAGE 

This pragma is implemented as defined in the LRM. 


PRAGMA PRIORITY 

This pragma is implemented as defined in the LRM. Priority 
contains a range defined in System_.Ada. 


PRAGMA SHARED 

This pragma is inplemented as defined in the LRM. This pragma may 
be applied only to scalar objects. 


PRAGMA STORAGE_UNIT 

pragma Storage_Unit {numeric_literal); 

This pragma is not supported. This number is declared in package 
System auid has 16 bits per word. 


C-13 




TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5 - 17 


PRAGMA SUPPRESS 

pragma Suppress (access_check); 
pragma Suppress (all_checks); 

The all_checks parameter eliminates all run time checks with a 
single pragma. In addition to the pragma, a cotrpiler switch 
permits control of run time check suppression by commeuid line 
option, eliminating the need for source chauiges. 

pragma Suppress (discriminant_check); 
pragma Suppress (division_check); 
pragma Suppress (elaboration_check); 
pragma Suppress (exception_info); 

Suppressing exception_info eliminates data euid code used to provide 
symbolic debug information in the event of em unhemdled exception. 

pragma Suppress (index_check); 
pragma Suppress (length_check); 
pragma Suppress (range_check); 
pragma Suppress (overflow_check); 
pragma Suppress (storage_check); 

PRAGMA SYSTEM_NAME 

pragma System_Name (enumeration_literaI); 

This pragma is not supported. Instead, compiler option is used to 
select the target system euid target Ada library for conqpilation. 


5.2.C LRM App.C-Predefined Language Environment 

The items described in this section correspond to the standards in 
i^pendix C of the LRM. 

PACKAGE STANDARD 

The following are predefined types of package Standard that are 
intrinsic to the con^iler: 

type Boolean is (False, True); 


C-14 








TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5 - 18 


-- The predefined relational operators for this type are as follows 

function "=" (Left, Right : Boolean) return Boolean; 

function "/=" (Left, Right : Boolean) return Boolezui; 

function "<" (Left, Right : Booleaui) return Boolean; 

function "<=" (Left, Right : Booleeui) return Booleeui; 

function (Left, Right : Boolean) return Boolean; 

function ">=" (Left, Right : Boolean) return Boolean; 

-- The predefined logical operators and the predefined logical 
-- negation are as follows: 

function "and" (Left, Right : Boolean) return Boolean; 

function "or" (Left, Right : Boolean) return Boolean; 

function "xor" (Left, Right : Boolean) return Boolean; 

fmotion "not" (Right : Boolean) return Boolean; 

-- The miversal type miversal_integer is predefined. 

-- type Short_Integer is not in?3lemented for 1750A. 

type Integer is range -2**15 .. 2**15-1; 

: range -32768 .. 32767 

-- The predefined operators for this type are as follows; 

fmotion " = " (Left, Right : Integer) return Boolean; 

fmotion "/=" (Left, Right : Integer) return Boolean,- 

fmction "<" (Left, Right : Integer) return Boolean; 

fmction "<=" (Left, Right : Integer) return Boolean; 

fmction ">" (Left, Right : Integer) return Boolean; 

fmction ">=" (Left, Right : Integer) return Boolean; 

fmotion " + " (Right : Integer) return Integer; 

fmction (Right : Integer) return Integer; 

fmction "adss" (Right : Integer) return Integer; 

fmction " + " (Left, Right ; Integer) return Integer; 

fmction (Left, Right : Integer) return Integer; 

fmction "*" (Left, Right : Integer) return Integer; 

fmction "/" (Left, Right : Integer) return Integer; 

fmction "rem" (Left, Right : Integer) return Integer; 

fmction "mod" (Left, Right : Integer) return Integer; 

fmction "**" (Left : Integer, Right : Integer) return Integer; 

type Long_Integer is range -2**31 .. 2**31-1; 

: range -2,147,483,648 .. 2,147,483,647 

-- The predefined operators for this type are as follows; 


C-15 






TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5 - 19 


function 

ti ^ n 

(Left, 

Right 

: Long_Integer) 

return 

Boolean; 

function 

•1 / s ” 

(Left, 

Right 

: Long_Integer) 

return 

Booleem ; 

function 

M ^ tl 

(Left, 

Right 

: Long_Integer) 

return 

Booleam ; 

fiinction 

II < « H 

(Left, 

Right 

: Long_Integer) 

return 

Boolecui; 

function 

II ^ II 

(Left, 

Right 

: Long_Integer) 

return 

Booleem ; 

function 

" >s " 

(Left, 

Right 

: Long_Integer) 

return 

Boolean; 

function 

II ^ II 

(Right 

: Long 

_Integer) return Long_Integer; 

function 

II . II 

(Right 

: Long 

^Integer) return Long_: 

Integer; 

function 

" abs *' 

(Right 

: Long 

_Integer) return Long_Integer; 

function 

n ^ II 

(Left, 

Right 

: Long_Integer) 

return 

Long_Integer; 

function 

1! . n 

(Left, 

Right 

: Long_Integer) 

return 

Long_Integer ; 

function 

It * n 

(Left, 

Right 

: Long_Integer) 

return 

Long_lnteger ; 

function 

II ! II 

(Left, 

Right 

: Long_Integer) 

return 

Long_Integer ; 

fiinction 

" rem" 

(Left, 

Right 

: Long_Integer) 

return 

Long_Integer; 

function 

"mod" 

(Left, 

Right 

: Long_Integer) 

return 

Long_Integer; 

function 

II « * n 

(Left 

: Long_ 

Integer, Right 

: Integer) 


return Long_Integer; 

-- The universal type universal_real is predefined. 

-- type Short_Float is not implemented for 1750A. 

type Float is digits 6 range -1.70141E+38 .. 1.70141E+38; 

-- The predefined operators for this type are as follows: 


function 

11 „ II 

(Left, 

Right : 

Float) 

return BoolecUi; 

function 

" / = ” 

(Left, 

Right : 

Float) 

return Boolean; 

function 

M ^ 11 

(Left, 

Right : 

Float) 

return Booleeui; 

function 

II < — II 

(Left, 

Right : 

Float) 

return Boolean; 

function 

II ^ 11 

(Left, 

Right : 

Float) 

return Booleem; 

function 

*' >S 

(Left, 

Right : 

Float) 

return Booleem; 

function 

II ^ It 

(Right 

: Float) 

return Float; 

function 

II . n 

(Right 

: Float) 

return Float; 

function 

"abs ” 

(Right 

: Float) 

return Float; 

function 

II ^ II 

(Left, 

Right : 

Float) 

return Float; 

function 

II . n 

(Left, 

Right : 

Float) 

return Float; 

function 

II ♦ n 

(Left, 

Right : 

Float) 

return Float; 

function 

11 j II 

(Left, 

Right : 

Float) 

return Float; 

function 

II ** H 

(Left 

: Float, 

Right 

: Integer) return Float; 

type Long_Float 

is digits 9 reuige -1. 

70141183E+38 .. 1.70141183E+38; 


C-16 




TLD ADA COMPILER 1750A-ADA-2C 

Mil-Std-1750A Bare Machine Target Compiler 5-20 


-- The predefined operators for this type are as follows: 


function 

« «rr 

(Left, 

Right 

Long_Float) 

return 

Boolefui; 

function 

” / s ** 

(Left, 

Right 

Long_Float) 

return 

Boolean; 

function 

It ^ ti 

(Left, 

Right 

Long_Float) 

return 

Boolean; 

fvinction 

” <s " 

(Left, 

Right 

Long_Float) 

return 

Boolean; 

fiuiction 

II ^ II 

(Left, 

Right 

Long_Float) 

return 

Boole^Ln; 

function 

** >s " 

(Left, 

Right 

Long_Float) 

return 

Boolean; 

function 

n ^ n 

(Right 

: Long_ 

_Float) return Long_Float; 

function 

II « n 

(Right 

: Long_ 

_Float) return Long_Float; 

function 

"abs" 

(Right 

: Long_ 

_Float) return Long_Float; 

function 

II ^ II 

(Left, 

Right 

Long_Float) 

return 

Long_Float; 

function 

II . II 

(Left, 

Right 

Long_Float) 

return 

Long_Float; 

function 

11 * 11 

(Left, 

Right 

Long_Float) 

return 

Long_Float; 

function 

11 ! II 

(Left, 

Right 

Long_Float) 

return 

Long_Float; 

function 

11 * * II 

(Left 

: Long_Ploat, Right 

Integer) 


return Long_Float; 

-- The following operators are predefined for universal types: 

function (Left : universal_integer. Right : universal_real) 
return iiniversal_real ; 

function (Left : \iniversal_real, Right : univerBal_integer) 
return universal_real; 

fxinction "/" (Left : universal_real. Right : universal_integer) 
return univerBal_real; 

-- The type universal_fixed is predefined. The only operators 

-- for this type are: 

function (Left : any_fixed_point_type, 

Right : any_fixed_point_type) return univerBal_fixed; 

function "/" (Left : cUiy_fixed_point_type, 

Right : auiy_fixed_point_type) return universal_fixed; 

type Character is 


nul. 

soh. 

stx, etx. 

eot. 

enq. 

ac]c. 

bel , 

bs. 

ht. 

If, vt. 

ff. 

cr. 

o 

m 

si. 

die. 

del. 

dc2, dc3, 

dc4. 

nak. 

syn. 

etb. 

can. 

em. 

sub, esc. 

fs. 

gs. 

rs. 

us. 

t t 

t 

' 1 ’ 

• t 

t f r t 

/ tT ^ 




9 n 9 

9 

' (' , 

')• . 

• 'k * • 

f ^ t 

9 f 

9 

t ^ 9 

9 

9 9 

9 ♦ 


'0' , 

'1' , 

$2* ' 3 ' 

^9 ^9 

'4', 

'5', 

'6', 

'7' , 

'8' , 

'9' , 

9,9 9,9 

•9 9 1 


9^9 

# 




C-17 








TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A>ADA-2C 

5-21 



'A', 

'B', 

'C', 

'D' , 

'E', 

'F', 

'G', 

'H', 

'I' , 

' J' , 

'K' , 

'L', 

'M'. 

'N' , 

'O' , 

'P' , 

'Q', 

'R' , 

'S', 

'T', 

'U', 

'V' , 

'W' , 

'X', 

'Y' , 

'Z' , 

' [', 

0 0 

0 


0 ^ $ 

0 

0 0 
_ 0 

0 

0 0 

'a' , 

'b'. 

'c' , 

'd'. 

'e', 

'f'. 

'g' / 

'h' , 

'i' . 

'j'. 

'k' , 

'1'. 

'm', 

'n', 

'o' , 

'P' . 

'q'. 

'r' , 

's' , 

't', 

'u' , 

'V' , 

'w' , 

'X' , 

'y'. 

'2' , 


'1'. 


0 •»0 

0 

del) 

for Character use 
nul, soh, stx, etx. 

eot. 

enq. 

ack. 

bel. 

( 0, 

1. 

2, 

3, 

4, 

5, 

6, 

7, 

bs. 

ht. 

If, 

vt. 

ff. 

cr. 

so. 

si, 

8. 

9, 

10, 

11, 

12, 

13, 

14, 

15, 

die. 

del. 

dc2, 

dc3. 

dc4. 

nsLk, 

syn. 

etb. 

16, 

17, 

18, 

19, 

20, 

21, 

22, 

23, 

cam. 

em. 

sub. 

esc. 

fs. 

gs. 

rs. 

us. 

24. 

25, 

26, 

27, 

28, 

29, 

30, 

31, 

0 

' !' , 

0 0 

0 


'$' , 

'»' , 

'&'. 

0^0 

0 

32, 

33, 

34, 

35, 

36. 

37, 

38, 

39, 

' (' , 


t * 0 

0 

'+' , 

0 / 

0 

0 * 

, '/' 

40, 

41, 

42, 

43, 

44, 

45, 

46, 

47, 

'0' , 

'1' , 

'2' , 

'3', 

'4' , 

'5' , 

'6', 

'7', 

48, 

49, 

o 

in 

51, 

52, 

53, 

54, 

55, 

'8' , 

'9' , 

0 * 

0 


' <' , 

'«' , 



56, 

57, 

58, 

59, 

60, 

61, 

62, 

63, 

' ®' , 

'A' , 

'B' , 

'C' , 

'D' , 

'E' , 

'F' , 

'G' , 

64, 

65, 

66, 

67, 

68, 

69, 

70, 

71, 

'H' , 

'I' , 

’ J' , 

'K' , 

'L' , 

'M' , 

'N', 

'O' , 

72, 

73, 

74, 

75, 

76, 

77, 

78, 

79, 

'P' , 

'Q' , 

'R' , 

'S' , 

0^0 

'U' , 

'V', 

'W' , 

80, 

81, 

82, 

83, 

84, 

85, 

86, 

87, 

'X' , 

'Y' , 

'Z' , 

' [', 

0 0 

'] ', 

0^0 

0 

0 0 
_ 0 

88, 

89, 

90, 

91, 

92, 

93, 

94, 

95, 

0 0 

0 # 

'a' , 

'b' , 

'c' , 

'd', 

'e', 

'f'. 

'g' r 

96, 

97, 

98, 

99, 

100, 

101, 

102, 

103, 

'h' , 

'i' . 

'j'. 

'k' , 

'1' , 

'm' , 

'n'. 

'o' , 

104, 

105, 

106, 

107, 

108, 

109, 

110, 

111, 

'P' , 

'q' , 

'r' , 

'S' , 

't' , 

'u' , 

'V', 

'w' , 

112, 

113, 

114, 

115, 

116, 

117, 

118, 

119, 

'X' , 

'y'. 

'2' , 


'1', 


0 •0 0 

f 

del 

120, 

121, 

122, 

123, 

124, 

125, 

126, 

127 ) 


- - The predefined operators for the type Character are the 

- - same as for amy enumeration type. 


C-18 















TLD ADA COMPILER 1750A-ADA-2C 

Hil-Std-1750A Bare Machine Target Compiler 5-22 


The following are in^lementation-defined types of package Standard: 
-- The following are control characters: 


NDL: consteint Character 
SOH: constant Character 
STX: constant Character 
ETX: constant Character 
EOT: constant Character 
ENQ: consteint Character 
ACK: constant Character 
BEL: constant Character 
BS : constant Character 
HT : constant Character 
LF : constant Character 
VT : constant Character 
FF : constant Character 
CR : const 2 uit Character 

50 : constant Character 

51 : constant Character 
DLE: consteint Character 
DCl: constamt Character 
DC2: constant Character 
DC3: constant Character 
0C4: constant Character 
NAK: constant Character 
SYN: constant Character 
ETB: constant Character 
CAN: constant Character 
EM : constant Character 
SUB: constant Character 
ESC: consteuit Character 
FS : constant Character 
GS : consteuit Character 
RS : consteuit Character 
US : consteuit Character 
DEL: constant Character 


= Character'Val(0); 

= Character'Val(1); 

= Character'Val(2); 

= Character'Val(3); 

= Character'Val(4); 

= Character'Val(5); 

= Character'Val(6); 
a Character'Val(7); 
a Character'Val(8) ; 
a Character'Val(9); 
a Character'Val(10); 
a Character'Val(11); 
a Character'Val(12); 
a Character'Val(13); 
a Character'Val(14); 
a Character'Val(15); 
a Character'Val(16); 
a Character'Val(17); 
a Character'Val(18); 
a Character'Val(19); 
a Character'Val(20); 
a Character'Val(21); 
a Character'Val(22); 
a Character'Val(23); 
a Character'Val(24); 
a Character'Val(25); 
a Character'Val(26); 
a Character'Val(27); 
a Character'Val(28); 
a Character'Val(29); 
a Character'Val(30); 
a Character'Val(31); 
a Character'Val(l27); 


-- The following are other characters: 


Exclam 

: consteuit 

Character :a '»'; 

Quotation 

: consteuit 

Character :a ' " ' ; 

Sharp 

: constant 

Character :a 

Dollar 

: consteuit 

Character :a ' $' ; 

Percent 

: consteuit 

Character :a 

Anpersand 

: constant 

Character :a 

Colon 

: constant 

Character :a ':'; 

Semicolon 

: consteuit 

Character :a ';'; 

Query 

: constant 

Character :a '7' ; 


C-19 












TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5-23 


At_Sign : consteint Character '0' 

L_Bracket : consteuit Character := ' t'; 
Back^Slash : constant Character := ' ' 
R_Bracket : constemt Character := ']'; 
Circumflex : constant Character := 
Underline : constant Character := ; 

Grave : constaint Character : = ' ‘' 

L_Brace : constant Character := '{'; 
Bar ; constant Character := '|' 

R_Brace : constant Character := '}'; 
Tilde : constant Character := 


Lc_A 

constant Character 

= 'a' 

Lc_N 

conBt2uit Character 

= 'n' 

Lc_B 

constant Character 

= 'b' 

Lc_0 

constant Character 

= 'o' 

Lc_C 

constant Character 

= 'C' 

Lc_P 

consteuit Character 

= 'P' 

Lc_D 

consteuit Character 

s 'd' 

Lc_Q 

constant Character 

= 'q' 

Lc_E 

constant Character 

_ .g/ 

Lc_R 

constant Character 

= 'r' 

Lc_F 

consteint Character 

= 'f' 

Lc_S 

constant Character 

= 's' 

Lc_G 

consteint Character 

= 'g' 

Lc_T 

constant Character 

= 't' 

Lc_H 

constant Character 

= 'h' 

Lc_U 

consteuit Character 

= 'u' 

Lc_I 

constant Character 

= 'i' 

Lc_V 

constant Character 

= 'V' 

Lc_J 

constant Character 

= 'j' 

Lc_W 

consteuit Character 

= ' w' 

Lc_K 

constant Character 

= 'k' 

Lc_X 

constemt Character 

= 'X' 

Lc_L 

constant Character 

= '1' 

Lc~Y 

constant Character 

= 'y' 

Lc~M 

const 2 uit Character 

= 'm' 

LC_Z 

constant Character 

s 'z' 


-- The following are predefined subtypes: 


subtype Natural is Integer range 0..Integer'LAST; 
sxibtype Positive is Integer remge 1..Integer'LAST; 

-- The following is a predefined string type: 

type String is array(Positive range <>) of Character; 
pragma Pack(String); 

-- The predefined operators for this type are as follows: 

function (Left, Right : String) return Booleeui; 

function "/=" (Left, Right : String) return Boolean; 

function "<" (Left, Right : String) return Boolean; 

fvinction "<s" (Left, Right : String) return Boolean; 

function ">" (Left, Right : String) return Boolean; 

function ">>" (Left, Right : String) return Booleeui; 

function (Left, Right : String) return Boolean; 

function (Left, Right : String) return Boolean; 

function (Left, Right : String) return Boolean; 

function (Left, Right : String) return Boolean; 


C-20 

















TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5-24 


type Duration is delta 2.0**(-14) range -86_400.0..86_400.0; 

: 32 bits with 12 bits for fractional part. 


-- The predefined operators for type Duration are the same as for any 
-- fixed point type. 

-- The following are predefined exceptions: 


Constraint_Error 

Numeric_Error 

Program_Error 

Storage_Error 

Tasking_Error 


exception; 
exception; 
exception; 
exception; 
exception; 


5.2.D LRM 

App.D - 

Glossary 

Not applicable. 



5.2.E LRM 

App.E - 

Syntax Summary 

Refer to "Appendix B. Ada Language Synteuc Cross Reference" for the TLD 
cross-referenced expression of this information. 


5.2.F LRM App.F - Implementation Characteristics 


The items described in this section correspond to the standards in 
l^pendix F of the LRM. 

Implementation-Dependent Pragmas 

PRAGMA ATTRIBUTE 

pragma Attribute {Attribute-Naine->Attribute-Value, - 
Item-Name{,...)); 


This pragma allows grouping of control sections with the specified 
attribute. 

If Item-Name is (xnitted, the specified attribute applies to all 
control sections in the current module. 

If Item-Name is Name'csect, the specified attribute applies to the 
control section of the module containing Name. Nsme may be a 
ladsel, procedure, or data object. 


C-21 







TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5-25 


If Item-Ncune is iVame'code, the specified attribute applies to the 
code control section of the module containing Name. 

If Item-Name is Ifazne'data, the specified attribute applies to the 
data control section of the module containing Name. 

If Item-Name is itf’ame'const 2 uit, the specified attribute applies to 
the consteuit control section of the module containing Name. 

No other form of Itern-Name is allowed. 

The linker directives GROUP auid SET, described in Chapter 4 of the 
Reference Document for the TLD Linker can refer to attributes in 
pragma Attribute in the source file. 


PRAGMA AUDIT 

pragma Audit (Ada-name{ 

This pragma causes an error message to be generated for the 
conpilation in which an Ada name, that is specified by this pragma, 
is referenced. The Ada name may be a package, scope, data, etc. 


PRAGMA COLLECT 

pragma Collect (type_name, attribute); 

The only value presently permitted for attribute is "unmapped", 
which tells the conpiler to collect all objects and subtypes of 
type_name into unmapped control sections. An unmapped control 
section is allocated a physical memory not covered by a page 
register. Unmapped control sections are accessed from a device by 
DMA or by IBM GVSC extended instructions. See Section 3.2.3.1, 
"Unmapped Control Sections," in the Reference Document for the TLD 
Extended Memory Linker. 


PRAGMA COMPRESS 

pragma Compress {subtype_mune) ; 

This pragma is similar to pragma Pack, but has subtly different 
effects. Pragma Compress accepts one parameter: the neune of the 
subtype to compress. It is itrplemented to minimize the storage 
requirements of subtypes when they are used within structures 
(arrays emd records). Pragma Compress is similar to pragma Pack in 
that it reduces storage requirements for structures, and its use 


C-22 







TLD ADA COMPILER 1750A-ADA-2C 

Mil-Std-1750A Bare Machine Target Compiler 5-26 


does not otherwise affect program operation. Pragma Compress 
differs frcmi pragma Pack in the following ways: 

o Unlike pragma Pack, pragma Conpress is applied to the subtypes 

that are later used within a structure. It is not used on the 

structures themselves. It only affects structures that later 
use the subtype; storage in stack frames and global data are 
unaffected. 

o Pragma Ccstpress is applied to discrete subtypes only. It 

cannot be used on types. 

o Pragma Ccm^ress does not reduce storage to the bit-level. It 

reduces storage to the nearest "natural machine size". This 
increases total storage requirements, but minimizes the 
performance inqpact for referencing a value. 

For exanple: 

subtype Small_Int is Integer range 0 .. 255; 

pragma Compress{Small_Int); 

type Num_Array is array (1 .. 1000) of Small_Int; 

In this example, Small_Int will be reduced from a 16-bit object to 
an unsigned 8-bit object when used in Num_Array. 

If pragma Congress had not been used then Small_Int would be the 
same size as Integer. This is because a subtype declaration should 
not chainge the underlying object representation. A subtype 
declaration should only inpose tighter constraints on bounds. In 
this manner a subtype does not incur any extra overhead (other than 
its range checking), when compared with its base type. Pragma 
Compress is used in those cases where the underlying representation 
should change for the subtype, therefore: 

o Small_Int is compatible with Integer. It may be used anywhere 
an integer is allowed. This includes out and in out parameters 
to subprogreuns. 

o A Small_Int object is the same size as Integer when used by 
itself. This minimizes run time overhead requirements for 
single objects allocated in the stack or as global data. 

o Small_Int is 8 bits when used within a record or an array. 
This cam dramatically reduce storage requirements for large 
structures. The access performance for compressed elements is 
very near that of the un-conpressed elements, but a slight 
performance cost is incurred when the conpressed value is 
passed as an out or in out parameter to a subprogram. 


C-23 







TLD ADA COMPILER 1750A-ADA-2C 

Hil-Std-1750A Bare Machine Target Compiler 5-27 


NOTE; Small_Int's Storage requirements could be reduced by 
declaring it as a type rather than a subtype, however, Small_Int 
would not be coo^atible with Integer, and this could cause 
considerable problems for some users. 


PRAGMA CONTROL_SECTION 

pragma Control_Section (usect,unmapped,object_name ~ 

{, object_name 

This pragma identifies data objects that are to be put into 
unmapped control sections. The first two parameters must be 
"usect" and "unmapped." The remaining parameters are names of Ada 
objects. An unmapped control section is allocated a physical 
memory location not covered by page register. Unmapped control 
sections are accessed from a device by DMA or by IBM GVSC extended 
instructions. See Section 3.2.3.1, "Unmapped Control Sections," in 
the Reference Document for the tt.tt Rvt -.ended Memory Linker. 


PRAGMA CONTIGUOUS 

pragma Contiguous (type_name | object_name ); 

This pragma is used as a query to determine whether the compiler 
has allocated the specified type of object in a contiguous block of 
memory words. 

Ihe conpiler generates a warning message if the allocation is 
noncontiguous or is undetermined. The allocation is probably 
noncontiguous when data structures have dynamically sized 
components. The allocation is prob6d>ly undetermined when 
unresolved private types are forward type declarations. 

This pragma provides information to the programmer about the 
allocation scheme used by the c<xnpiler. 


PRAGMA EXPORT 

pragma Esport (Ianguage_name, ada_entit:y_name, {string}) ; 

Pragma Export is a complement to pragma Interface. Export directs 
the conpiler to maJce the ada_entity_name available for reference by 
a foreign language module. The language_name parameter identifies 
the lauiguage in which the module is coded. 

Assembly is presently supported by Export. Ada auid JOVIAL are 
permitted and presently mean the same as Assembly. The semantics 


C-24 









TLD ADA COMPILER 1750A-ADA-2C 

Mil-Std-1750A Bare Machine Target Compiler 5-28 


of their use are subject to redefinition in future releases of 
TLDada. Void may be used as the laiiguage_name to specify the 
user's language convention. As a result of specifying Void, the 
Compiler will not allocate local stack space, will not perform a 
stack check, sind will not produce prologue and epilogue code. If 
the optional third parameter, string, is used, the string provides 
the nzune by which the entity may be referenced by the foreign 
module. The contents of this string must conform to the 
conventions for the indicated foreign language and the linker being 
used. TLDada does not make any checks to determine whether these 
conventions are obeyed. 

Pragma Export supports only objects that have a static allocation 
and subprograms. If the ada_entity_name is a subprogram, this 
Export must be placed in the same scope within the declarative 
region. If it is an object, the ada_entity_name must follow the 
object declaration. 

NOTE: The user should be certain that the subprogram Buid object 

are eleiborated before the reference is made. 


PRAGMA IF 

pragma If {coi[^ile_time_expression) ; 
pragma Elsif {compile_time_expression); 
pragma Else; 
pragma End{ if}; 

These source directives may be used to enclose conditionally 
conpiled source to enhance program portability and configuration 
adaptation. These directives may be located where lamguage defined 
pragmas, statements, or declarations are allowed. The source code 
following these pragmas is cotipiled or ignored (similar to the 
semeuitics of the corresponding Ada statements), depending upon 
whether the cowpile_time_expression is true or false, 
respectively. The primary difference between these directives and 
the corresponding Ada statements is that the directives may enclose 
declarations euid other pragmas. 

NOTE: To use the pragma IF, ELSEIF, ELSE, or END, the /XTRA 

switch must be used. 







TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5-29 


PRAGMA INCLUDE 

pragma Include (file_path_name_string); 

This source directive in the form of a language pragma permits 
inclusion of another source file in place of the pragma. This 
pragma may occur any place a language defined pragma, statement, or 
declaration may occur. This directive is used to facilitate source 
prograun portability and configurability. If a partial 
file_path_name_string is provided, the current default pathname is 
used as a tenplate. A file name must be provided. 

NOTE: To use the pragma INCLUDE, the /XTRA switch must be used. 


PRAGMA INSTANTIATE 

pragma Instantiate {option{, name}); 

This pragma is used to control instantiation of a particular 
generic. 

To establish a default mode of insteuitiation for all generic 
instantiations within the con^silation, the following switch may be 
entered on the TLDada command line and used instead of this pragma: 

/instantiatespption 

In either the pragma or switch, option instructs the Coinpiler to 
instcuitiate generics in the manner specified, as described below: 

single_body - a single body is used for all instemtiations 

macro - each instantiation produces a different body 

In this pragma, name is the name of the generic to which this 
pragma applies. 

There are two basic forms for this pragma. The first form omits 
the second parameter, is associated with a generic declaration, and 
is permitted to occur only within a generic formal part (i.e., 
after "generic" but before "procedure", "function", or "package"). 
In this form, the pragma establishes the default mode of 
instantiation for that particular generic. 

The second form uses the second parameter, is associated with the 
instantiation, euid may appear anywhere in a declarative part except 
within a generic formal part. This form specifies what mode is to 
be used for the instantiation of the named generic which follows in 
the scope in which the pragma appears. This form of the pragma 
taJces precedence over the first form. 


C-26 











TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5 - 30 


In the following exaitple, assume the following definiton: 
generic 

pragma insteuitiate(single_body); -- pragma 1 

package G ... 
end G; 

generic 

pragma instantiate(macro); - - pragma 2 

package H ... 
end H; 


package A 

is 

new 

G(. . 

.) 

package 

B 

is 

new 

G(. . 

.) 

package 

C 

is 

new 

H(. . 

.) 

package 

D 

is 

new 

H(.. 

.) 


pragma instantiate(macro, G); -- pragma 3 

package E is new G(...); 

package F is new G(...); 

In the aibove example, packages A and B share the same body, due to 
pragma 1. Packages C, D, E, and F will be treated as macro 
instantiation C and D because macro insteuitiation is the default 
for H (due to pragma 2) aind for E and F because they follow pragma 
3 . 

In both the pragma and switch: 

o Nested instantiations and nested generics are supported and 
generics defined in library units are permitted. 

o It is not possible to perform a macro instantiation for a 
generic whose body has not yet been compiled. 

In this pragma: 

o It is also not possible to perform a macro instantiation 
from inside a single-bodied instantiation, because the 
macro instantiation requires information at compile time 
which is only available to a single-bodied generic at 
execution time. 


C-27 





TLD ADA COMPILER 

Nil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5 - 31 


In the event of a conflict between the pragma and switch, the 
switch takes precedence. 


PRAGMA INTERFACE_NAME 

pragma Interface_Name (Ada_encity_name, string) ; 

This pragma takes a variable or subprogram name and a string to be 
used by the Linker to reference the varieOsle or subprogram. It has 
the same effect as the optional third parameter to pragma 
Interface. 


PRAGMA INTERRUPT.KIND 

pragma Interrupt_Kind (entry_neune, entry_type{, duration}); 

An interrupt entry is treated as 2 m "ordinary" entry in the absence 
of pragma Interrupt_Kind. When pragma Interrupt_Kind is used, an 
interrupt entry may be treated .*'s a "conditional" or "timed" entry. 

This pragma must appear in the task specification containing the 
entry named and after the entry_name is declared. Three 
enti:y_types are possible: ordinary, timed, and conditional. The 
optional parameter duration is applicable only to timed entries and 
is the maximum time to wait for an accept. 

For an ordinary entry, if the accept is not ready, the task is 
queued. For a conditional entry, if the accept is not ready, the 
interrupt is ignored. For a timed entry, if the accept is not 
ready, the program waits for the period of time specified by the 
duration. If the accept is not ready in that period, the interrupt 
is ignored. 


PRAGMA LOAD 

pragma Load (literal_string); 

This pragma makes the Ccopiler TLDada include a foreign object 
(identified by the literal_string) into the link comnumd. 


C-28 







TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5-32 


PRAGMA MONITOR 

pragma Monitor; 

The pragma Monitor can reduce tasking context overhead by 
eliminating context switching. This pragma identifies invocation 
by the conpiler. With pragma Monitor, a sinple procedure call is 
used to invoke task entry. 

Generally, pragma Monitor restricts the syntauc of an Ada task, 
limiting the number of operations the task performs and leading to 
faster execution. 

The following restrictions pertain to Ada constructs in monitor 
tasks: 

o Pragma Monitor must be in the task specification. 

o Monitor tasks must only be declared in library-level, 

non-generic packages. 

o Monitor tasks may contain data declarations only within the 
accept statement. 

o A monitor task consists of an infinite loop containing one 
select statement. 

o The "when condition" is not allowed in the select alternative of 
the select statement. 

o The only selective wait alternative allowed in the select 
statement is the accept alternative. 

o All executcdile statements of a monitor task must occur within an 
accept statement. 

o Only one accept statement is allowed for each entry declared in 
the task specification. 

If a task body violates restrictions placed on monitor tasks, it is 
identified as erroneous wd the conpilation fails. 


C-29 








TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5-33 


PRAGMA NO_DEFAULT_INITIALIZATION 

pragma No_De£aulC_Initialiration; 

pragma No_Default_Initiali 2 ation (typename {,... }); 

The LRM requires initialization of certain Ada structures even if 
no explicit initialization is included in the code. For exanple, 
the LRM requires access_type objects to have an initial value of 
"NOLL." Pragma No_Default_Initialization prevents this default 
initialization. 

In addition, initialization declared in a type statement is 
suppressed by this pragma. 

TLD implementation of packed records or records with representation 
clauses includes default initialization of filler bits, i.e., bits 
within the allocated size of a variant that are not associated with 
a record component for the variant. No_Default_Initialization 
prevents this default initialization. 

This pragma must be placed in the declarative region of the 
package, before any declarations that require elciboration code. 
The pragma remains in effect lantil the end of the conpilation unit. 

NOTE: To use the pragma, NO_DEFAULT_INITIALIZATION, the /XTRA 
switch must be used. The use of this pragma may affect the 
results of record comparisons and assignments. 


PRAGMA NO.ELABORATION 

pragma no_elaboration; 

Pragma No_Elaboration is used to prevent the generation of 
elaboration code for the containing scope. This pragma must be 
placed in the declarative region of the affected scope before any 
declaration that would otherwise produce elaboration code. 

This pragma prevents the unnecessary initialization of packages 
that are initialized by other non-Ada operations. Pragma 
No_Elaboration is used to maintain the Ada Rijn Time Library 
(TLDrtl). 


C-30 










TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5 - 34 


For exanple: 

package Test is 

Pragma No_EleQ3oration; 
for Program_Statua_Word use 
record at mod 8; 

System_Mask at 0*WORD rauige 0. . 7 ; 

Protection_Key at 0*WORD rauige 10 .. 11; -- bits 8,9 unused 

end record; 
end Test; 

In the 2 d>ove exanple, the No_El2d3oration pragma, prevents the 
generation of elcUooration code for package Test since it contains 
unused bits. 

NOTE: To use the pragma, NO_ELABORATION, the /XTRA switch must 

be used. The use of this pragma may affect the results of record 
comparisons and assignments. 


PRAGMA NONZERO 

pragma No_Zero {record_type_name) ,- 

If the named record type has "holes" between fields that are 
normally initialized with zeroes, this pragma will suppress the 
clearing of the holes. If the named record type has no "holes", 
this pragma has no effect. When zeroing is diseOsled, conparisons 
(equality and non-equality) of the named type are disallowed. The 
use of this pragma can significantly reduce initialization time for 
record objects. 


PRAGMA PUT 

pragma Put (value{, ...}); 

Pragma Put takes any number of arguments and writes their value to 
stemdard output at con^ile time when encountered by the Con^iler. 
The argtunents may be expressions of euiy string, enumeration, 
integer type, or scalar expression (such as integer'size) whose 
value is )uiown at compile time. This pragma prints the values on 
the output device without an ending carriage return; pragma 
Put_Line is identical to this pragma, but adds a carriage return 
after printing all of its arguments. 


C-31 








TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 
5 • 35 


This pragma is useful in conditionally-conpiled code to alert the 
programmer to problems that might not otherwise come to his 
attention via an exception or a compile-time error. 

This pragma may appear anywhere a pragma is allowed. 


PRAGMA PUT_LINE 

pragma Put_Line (value{, ...}); 

Pragma Put_Line takes any number of arguments amd writes their 

value to standard output at compile time when encountered by the 
Compiler. The argxaments may be expressions of any string, 

enumeration, integer type, or scalar expression (such as 
integer'size) whose value is known at compile time. This pragma 
prints the values on the output device euid adds a carriage return 
after printing all of its arguments; pragma Put is identical to 
this pragma, but prints the values without sui ending carriage 

return. 

This pragma is useful in conditionally-conpiled code to alert the 
programmer to problems that might not otherwise come to his 

attention via an exception or a compile-time error. 

This pragma may appear anywhere a pragma is allowed. 

PRAGMA REGISTER 

pragma Register (object_name, register_number); 

This pragma allows limited register dedication to em object for the 
purpose of loading registers with conplex Ada esqjressions or 
storing registers into complex operands within machine code 
insertion subprograms. The Compiler dedicates the specified 
register to the specified object until the end of the scope is 
reached or until it is released through a call to the subroutine. 
Unprotect, in the Machine_Code package. The object_naine is the 
name of the object to be dedicated to the register and 
regiscer_nutnber is the register number (without the "R" prefix that 
is valid for the particular target). 

These objects may be used on the left or right side of an 
assignment statement to load or store the register, respectively. 


C-32 







TLD ADA COMPILER 1750A-ADA-2C 

Mil-Std-1750A Bare Machine Target Compiler 5-36 


PRAGMA TCB.EXTENSION 

pragma TCB_Extension (value); 

This pragma is used to extend the size of the Task Control Block on 
the stack. It can be used only within a task specification. The 
parameter passed to this program must be static and represents the 
size to be extended in bytes. 


PRAGMA WITHIN.PAGE 

pragma Within_Page {type_name \ object^mune) ; 

NOTE: The type_name or object_neune must have been previously 
declared in the current declaration region euid these declarations 
must be in a static data context (i.e., in a package 
specification or body that is not nested within any procedure or 
function). 

This pragma instructs the compiler to allocate the specified 
object, or each object of the specified type, as a contiguous block 
of memory words that does not spam any page boundaries (a page is 
4096 words). 

The compiler generates a warning message if the allocation is 
noncontiguous or not yet determined (see the description of pragma 
Contiguous, above). Additionally, the compiler generates a warning 
message if the pragma is in a nonstatic declarative region. If em 
object exceeds 4096 words, it is allocated with an address at the 
beginning of a page, but it spans one or more succeeding page 
boundaries and a warning message is produced. 


PRAGMA VOLATILE 

pragma Volatile {variable_simple_name); 

This pragma performs the same fiuiction as Pragma Shared, however, 
it also applies to composite types as well as scalar types or 
access types. 


C-33 







TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 
5 - 37 


Implementation-Dependent Attributes 


TASK_ID 

The attribute 'Task_ID is used only with task objects. This 
TLD-defined attribute returns the actual system address of the task 
object. 

PACKAGE SYSTEM SPECIFICATION 

The following declarations are defined in package System: 

type operating_sy8tems is ( unix, netos, vms, os_x, msdos, bare); 

type name is (none, nsieooo, vax, afl750, z8002, z8001, gould, 
pdpll, m68000, pe3200, caps, amdahl, i8086, i80286, i80386, 

zSOOOO, ns32000, ibmsl, m68020, nebula, name_x, hp); 

eystem_name: constant name := name'target; 

os_name: constant operating_systems operating_sy8tems'system; 

subtype priority is integer rauige 1..64; -- 1 is default 

priority. 

type address is range 0 .. 65535; 
for address'size use 16; 

type unsigned is range 0 .. 65535; 
for address'size use 16; 

type long_address is rauige 0 .. 16#007FFFFF#; 

pragma put_line ('>', '>', '>', ' ', Bystem_name, ' ', '/', ' ', 
os_n2une, ' ' , ' <' , ' <', ' <') ; 

-- L 2 uiguage Defined Constants 

storage_unit: constant :s 16; 
memory_size: constant :■ 65_536; 

min_int: constant :« -2**31; 

max_int: constant :x 2**31-1; 

max_digitB: constamt :* 9; 

max^mauitissa: constant :> 31; 
fine_delta: constant 2.0**(-31); 

ticksjper_second: constant :> 10_000.0 -- Clock ticks ■ 100 msecs, 

tick: constant :■ l.P/tick8_per_8econd; 

ticksjper_rtc: constant :■ 65_536; 

null_address: constant address :> 0; 


C-34 







TLD ADA COMPILER 

Nil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5-38 


Representation Clauses 

Record representation clauses are supported to arreuige record 
conponents within a record. Record conponents may not be specified 
to cross a word boundary xinless they are arranged to enconpass two 
or more whole words. A record component of type record that has 
record representation clause applied to it may be allocated only at 
bit 0. Bits are numbered from left to right with bit 0 indicating 
the sign bit. 

When there are holes (unused bits in a record specification), the 
compiler initializes the entire record to permit optimum assignment 
and conpares of the record structure. A one-time initialization of 
these holes is beneficial because it allows block compares and/or 
assignments to be used throughout the program. If this 
"optimization" is not performed, record assignments and conpares 
would have to be performed one conponent at a time, degrading the 
code. 

To avoid this initialization, the user should check to be certain 
that no holes are left in the record structure. This may be done 
by increasing the size of the objects adjacent to the hole or by 
defining dummy record coitponents that fill the holes. If the 
latter method is used, euiy aggregates for the structure must 
contain values for the holes as well as the "real" components. 
Even with the extra cooponents, this approach should optimize space 
and speed in comparison to processing one component at a time. 

If the component_clause of a record representation specification is 
not in the same order as the conponent_list of the record 
specification, the entire record is initialized, as indicated 
above. 

Address clauses are supported for variable objects and designate 
the virtual address of the object. The Compiler System uses 
address specification to access objects allocated by non-Ada means 
euid does not hauidle the clause as a regfuest to allocate the object 
at the indicated address. Address clauses are not supported for 
subprograms, packages, tasks, or task entries. 

The Ada Ccmpiler supports a representation specification to 
indicate a memory type attribute for user types and objects. The 
new specification: 

for Ada_type_or_object'memory_type use { APC | MIXR ( 

GIXR I GLOK I SPE | LUT | PBM | PBMC}; 

may be used to identify Ada types or objects that are to be 
allocated to particular memory types. 

For addresses greater them 64K, logical addresses must be used. 


C-35 







TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5-39 


NOTE: Length clauses are supported for 'Size applied to objects 
other th5ui task and access type objects euid denote the number of 
bits allocated to the object. 

Length clauses are supported for 'Storage_Size when applied to a 
task type and denote the number of words of stack to be allocated 
to the task. 

Enumeration types that have an associated representation clause 
cannot be passed as actual generic parameters for a generic 
instantiation. 

Enumeration representation clauses are supported for value ranges 
of Integer'First to Integer'Last. 


PACKAGE MACHINE_CODE (LEM 13.8) 

The specification for this package is included in the 
MACHINE_CODE_.ADA file. 

Conventions for Implementation-Generated 
Names Denoting Implementation-Dependent 
Components 

The Compiler System defines no implementation dependent names for 
compiler generated record components. 

Two naming conventions are used by TLDacs. All visible run time 
library subprograms emd kernel services begin with the character 
"A_". Global Run Time System data names begin with the characters 
"AS". The unique name created by the compiler for overload 
resolution is conposed of the user name appended with plus 

the first three characters of the compilation unit name, followed 
by three digits representing the ordinal of the visible name within 
the ccmrpilation unit. The maximimn length of this name is 128 
characters. 







r 


TLD ADA COMPILER 1750A-ADA-2C 

Mil-Std-1750A Bare Machine Target Compiler 5-40 

Interpretation for Expressions Appearing 
IN Address Clauses 

Address eiqjression values eind type Address represent a location in 
logical memory (the contents of the page register is not included 
in the address). For objects, the address specifies a location 
within the 64K word logical operand space. The 'Address attribute 
applied to a subprogram represents a 16-bit word address within the 
logical instruction space. 


Restrictions on Unchecked Conversions 

Conversion of generic formal private types is not allowed. 

Implementation-Dependent Characteristics 
OF Input-Output Packages 

PACKAGE DIRECT_IO (LHM 14.2.5) 

PACKAGE I0_EXCEPTI0NS (LRM 14.5) 

PACKAGE L0W_LEVEL_I0 (LRM 14.6) 

PACKAGE SEQUENTIAL_IO (LRM 14.2.3) 

Input-Output pac)tages are described in the Reference Document for 
the TLD Ada 1750A Run Time System. 

PACKAGE TEXT_IO (LRM 14.3.10) 

The following implementation-defined types are declared in Text_Io: 

type Count is integer range 0 .. 511; 
subtype Field is Integer reuige 0 .. 127; 


C-37 








TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5-50 


5.6.1 1750A Parameter Values 

This chart provides sizes and values for 1750a parameters. 


Parameter 

Size 

Value {Range) 

Integer 

16 bits 

-32768..32767 

Long_Integer 

32 bits 

-2,147,483,648.. 

Float 

32 bits 

-f2,147,483,648 

Binary Exponent 

8 bits 


Mantissa 

23 bits 


Signed Bit 

1 bit 

6 decimal digits 

Long_Float 

48 bits 


Binary Es^onent 

8 bits 


Mantissa 

39 bits 


Signed Bit 

1 bit 

9 decimal digits 

Fixed Point; 

(single precision) 

16 bits 


(double precision) 

32 bits 


Access (Logical) 

16 bits 


(Physical) 

23 bits 


Boolean 

1 bit 

(LSB of 16 bits) 

Character 

8 bits 



String 


Array Descriptor 
Address 

Unsigned Integer 
Float'first 
Float'last 
Float'small 
Float'safe_small 
Float'large 
Float'safe_large 
Float'epsilon 
Float'digits 
Float'mantissa 
Float' emeuc 
Float' safe_em 2 uc 
Long_float'first 
Long_float'last 
Long_float'small 
Ijong_f loat' saf e_small 
Ijong_f loat' large 
Long_float'safe_large 


Unconstrained array of 
characters where a character 
is 1 byte of data 
48 bits 
16 bits 
16 bits 
-1.70141E+38 
1.70141E-t-38 
2.58494E-26 
2.35099E-38 
1.93428E-«-25 
2.12676E-*-37 
9.53674E-07 
6 

21 

84 

124 

-1.70141183E-t-38 

1.70141183E'f38 

2.35098870E-38 

2.35098870E-38 

2.12676479E+37 

2.12676479E+37 


C-38 









TLD ADA COMPILER 

Mil-Std-1750A Bare Machine Target Compiler 


1750A-ADA-2C 

5-51 


Parameter 

Size 

Value (Rang 

Long_float'epsilon 

9. 

.31322575E-10 

Iiong_float' digits 

9 



Long_f1oat'mantissa 

31 



Long_float'emax 

124 



liong_float' safe_emax 

124 



Duration'Small 



1/16384 sec. 

Allocation Unit 

16 

bits 


Stack Pointer Register 

16 

bits 

RF 

Instruction Pointer Register 

16 

bits 

IC 

Volatile Registers 

16 

bits 

RO - R14 

Non-Volatile Register 

16 

bits 

R15 

RTS Default Task Stack 

1024 

words 


RTS Size (minimum) 

1200 

words 


Pull Tasking Size 

5800 

words 



(NOTE: word size = 16 bits) 


C-39 













