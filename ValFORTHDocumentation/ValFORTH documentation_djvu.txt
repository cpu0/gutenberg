
»>ior>< 





^VALPART 
INTERNATIONAL 

3801 E. 34™ STREET 
TUCSON, ARIZONA B57T3 
S02-7S0-71A1 



r 


1 ralFORTH 

T.M. 

SOFTWARE SYSTEM 

for ATARI* 


GENERAL UTILITIES AND UIDEO EDITOR 


* Atari is a trademark o( Atari, Inc., a division ot Warner Communications. 


Software and Documentation 
©Copyright 1982 
Vaipar International 


o 


o 


u 


valFORTH 

T.M. 


Screen Oriented Video Editor 


Version 1.1 
March 1982 


The FORTH language is a very powerful addition to the Atari home computer. 
Programs which are impossible to write in BASIC (usually because of limitations 
in speed and flexibility) can almost always be written in FORTH. Even when one 
has mastered the BASIC language, making corrections or additions to programs 
can be tedious. The video editor described here removes this problem from 
the FORTH environment. Similar to the MEMO PAD function in the Atari operating 
system, this editor makes it possible to insert and delete entire lines of code, 
insert and delete single characters, toggle between insert and replace modes, 
move entire blocks of text, and much more. 


Software and Documentation 
©Copyright 1982 
Vatpar international 


0 


o 


J 


valFORTH 

T.M. 

SOFTWARE SYSTEM 
GENERAL UTILITIES AND UIDEQ EDITOR 

Stephen Maguire 
Evan Rosen 

Software and Documentation 
©Copyright 1982 
Valpar International 

Purchasers of this software and documentation package are 
authorized only to make backup or archival copies of the 
software, and only for personal use. Copying the accompanying 
documentation is prohibited. 

Copies of software for distribution may be made only as speci- 
fied in the accompanying documentation. 


Q 


O 


VALPAR INTERNATIONAL 


Disclaimer of Warranty 
on Computer Programs 


All Valpar International computer programs are distributed 
on an "as is" basis without warranty of any kind. The total 
risk as to the quality and performance of such programs is with 
the purchaser. Should the programs prove defective following 
their purchase, the purchaser and not the manufacturer, distributor, 
or retailer assumes the entire cost of all necessary servicing or 
repai r. 


Valpar International shall have no liability or responsibility 
to a purchaser, customer, or any other person or entity with 
respect to any liability, loss, or damage caused directly or 
indirectly by computer programs sold by Valpar International. 

This disclaimer includes but is not limited to any interruption 
of service, loss of business or anticipatory profits or conse- 
quential damages resulting from the use or operation of such 
computer programs. 

Defective media (diskettes) will be replaced if diskette(s) 
is returned to Valpar International within 30 days of date of sale 
to user. 

Defective media (diskettes) which is returned after the 30 day 
sale date will be replaced upon the receipt by Valpar of a $12.00 
Replacement Fee. 




o 


1 


GENERAL UTILITIES and VIDEO EDITOR 


~) 


o 


o 


val FORTH UTILITIES/EDITOR USER'S MANUAL 


Table of Contents 


Page 

XI. val FORTH 1.1 DISPLAY-ORIENTED VIDEO EDITOR 
A user's manual for the val FORTH video editor 

a) OVERVIEW 

b) ENTERING THE EDIT MODE . . . , 

c) CURSOR MOVEMENT 

d) EDITING COMMANDS 

e) STORAGE BUFFER MANAGEMENT 

f) CHANGING SCREENS; SAVING; ABORTING . . . 

g) SPECIAL COMMANDS 

h) SCREEN MANAGEMENT 

i) EDITOR COMMAND SUMMARY 


XII. STRINGS, ARRAYS, CASE STATEMENTS, DOUBLE NUMBER EXTENSIONS 

a) STRING PACKAGE 

b) ARRAYS, TABLES, VECTORS 

c) CASE:, CASE, SEL, COND 

d) DOUBLE NUMBER EXTENSIONS 


XIII. HI-RES TEXT, MISC. UTILITIES, TRANSIENTS 

a) HI-RESOLUTION ( 8 GR. ) TEXT OUTPUT . . 

b) MISCELLANEOUS UTILITIES 

c) TRANSIENTS ( DISPOSABLE ASSEMBLERS, ETC.) 


XIV. UTILITIES/EDITOR SUPPLIED SOURCE LISTING 


1 

2 

5 

6 
8 

13 

14 
16 
18 


~) 


o 


o 


val FORTH Video Editor 1.1 


Overview 

This editor is a powerful extension to the valFORTH system designed 
specifically for the Atari 400/800 series of microcomputers. The main purpose 
for this editor is to give the FORTH programmer an easy method of text entry to 
screens for subsequent compilation. The editor has four basic modes of opera- 
tion: 

1) It allows entering of new text to a FORTH screen as though 
typing on a regular typewriter. 

2) It allows quick, painless modification of any text with a 
powerful set of single stroke editing commands. 

3) It pinpoints exactly where a compilation error has occurred 
and sets up the editor for immediate correction and 
recompilation. 

4) Given the name of a precompiled word, it locates where the 
original text definition of the word is on disk, if the 
"LOCATOR" option had been selected when the word was compiled. 

The set of single stroke editing commands is a superset of the functions 
found in the MEMO PAD function of the standard Atari operating system. In 
addition to cursor movement, single character insertion/deletion, and line 
insertion/deletion, the editor supports a clear- to-end-of-1 ine function, a 
split command which separates a single line into two lines, and a useful insert 
submode usually found only in higher quality word processors. 

In addition, there are provisions for scrolling both forwards and backwards 
through screens, and to save or "forget" any changes made. This is useful at 
times when text is mistakenly modified. 

Also provided is a visible edit storage buffer which allows the user to 
move, replace, and insert up to 320 lines of text at a time. This feature alone 
allows the FORTH programmer to easily reorganize source code with the added 
benefit of knowing that re-typing mistakes are avoided. Usage has shown that 
once edit-buffer management is learned, significant typing and programming 
time can be saved. 

For those times when not programming, the editor can double as a simple 
word processor for writing letters and filling other documentation needs. 

The best method for learning how to use this powerful editor is to enter the 
edit mode and try each of the following commands as they are encountered in 
the reading. 

As stated above, there are four ways in which to enter the video editor. 

The following four commands explain each of the possibilities. Note that the 
symbol "<ret>" indicates that the "RETURN" key is to be typed. 


XI- 1 


val FORTH Video Editor 1.1 


V view screen ( scr# — ) 

To edit a screen for the first time, the "View" command is to be 
used. The video display will enter a 32 character wide mode and will 
be broken into three distinct sections. For example, 

50 V <ret> 

should give something like the display shown in fig. 1. 


Screen #50 U 

#Bufs: 5 




TEST1 
10 0 
DO 

I CR . 

LOOP ; 

OCTAL 
8 BASE ! : 

+C! 

DUP CO ROT -i 
SWAP C! ; 


( 1 i ne 2 ) 


( — ) 


( bottom line ) 


Fig. 1 


The top window, composed of a single line, indicates in decimal 
which screen is currently being edited. One should always make a 
practice of checking this screen number to insure that editing will be 
done on the intended screen. Often times, when working with other 
number bases, the wrong screen is called up accidentally and catching 
this mistake early can save time. Also shown is the size of the edit 
buffer (described later). In this example, the buffer is five lines in 
length. This window is known as the heading window. 


XI -2 


val FORTH Video Editor 1.1 


FORTH screens typically are IK (1024 characters) long. Since it is 
impossible to see an entire screen simultaneously, this editor reveals 
only half a screen at a time. There is an "upper" half and a "lower" 
half. In the center of the heading window, either a "U" or an "L" 
is displayed indicating which half of the current screen is being viewed. 
If the valFORTH system is in the half-K screen mode, neither "U" nor "L" 
is displayed since an entire half-K screen can be viewed at one time. 

In figure 1, the upper half of a full-K screen is being viewed. 

The second window (the text window) contains the text found on the 
specified screen. This window is 32 characters wide and 16 lines high. 
The white cursor (indicated by the symbol "■") will be in the upper- 
lefthand corner of the screen awaiting editing commands. 

The final five-line window found at the bottom of the screen is 
known as the buffer window. This is used for advanced editing and is 
described in greater detail in the section entitled "Buffer Management." 


L re-edit last screen ( — ) 

This command is used to re-edit the "Last" screen edited. It 
functions identically to the "V" command described above, except no 
screen number is specified. 

Example: L <ret> (re-edit screen 50) 


WHERE find location of error ( — ) 

If, when compiling code, a compilation error occurs, the WHERE 
command will enter the edit mode and position the cursor over the last 
letter of the offending word. The word can then be fixed and the screen 
can be re-compiled. Bear in mind that using the WHERE command prior to 
any occurrence of an error could give strange results. 


LOCATE locate definition cccc ( — ) 

Once source text has been compiled into the dictionary, it loses 
easy readability to all but experts of the FORTH language. Often times, 
though, it is helpful to see what the original source code was. The 
DECOMP command found in the debugger helps tremendously in this regard, 
however, some structures such as IF and DO are still difficult to follow. 
For this reason, the LOCATE command is included with the editor. 

This command accepts a word name, and if at all possible it will 
actually direct the editor to load in the screen where that word was 
defined. This is very helpful at times when one cannot remember where 
the original text was. If the screen shown in figure 1 were loaded and 
the command 

LOCATE +C ! <ret> 

were given, the editor would call up screen 50 and position the cursor 
over the word which is the beginning of the definition for "+C! M . 
Typically, the LOCATE command will point to , "CODE" , "CONSTANT" , 
and other defining words. 


XI -3 


Val FORTH Video Editor 1.1 


There is a drawback to this feature, however. In order to call up 
any word, the LOCATE command must know where the word actually is. 
Normally, when a word is compiled, there is no way of knowing where it 
was loaded from. Thus for the LOCATE command to work, each time a word 
is entered into the dictionary, three extra bytes of memory must be used 
to store this lookup information. For an application with many words, 
these extra bytes per word add up quickly, and this is not always 
desirable. For this reason, the LOCATOR command (described below) 
allows the user to enable or disable the storage of this lookup informa- 
tion. Only words that were compiled with the LOCATOR option selected 
can be located. If a word cannot be located, the user is warned, or if 
the DEBUGGER is loaded, the word is DECOMPed giving pseudo original code. 


LOCATOR enable/disable location ( ON/OFF — ) 

In order for a word to be locatable using LOCATE, the LOCATOR option 
must have been selected prior to compiling the word. The LOCATOR option 
is selected by executing "ON LOCATOR" and deselected by executing "OFF 
LOCATOR". For example: 

ON LOCATOR 

: PLUS ; (partial view of a screen) 

: STAR 42 EMIT ; 

OFF LOCATOR 
: NEGATE MINUS ; 


Only the words PLUS and STAR can be located. NEGATE cannot be located 
since the LOCATOR option was disabled. If the DEBUGGER were loaded, 
NEGATE would be decompiled (see the debugger), otherwise, the user would 
be given a warning. The default value for LOCATOR is OFF. 


#BUFS set buffer length ( #lines — ) 

The #BUFS command allows the user to specify the length (in terms of 
number of lines) of the special edit storage buffer. The power of the 
edit buffer lies in the number of lines that can be stored in it. 

Although the default value is five, practice shows that at least 16 
lines should be set aside for this buffer. The maximum number of lines 
allowable is 320which is enough to hold 20 full screens simultaneously. 


XI- 4 


val FORTH Video Editor 1.1 


The following sections give a detailed description of all commands which 
the video editor recognizes. A quick reference command list can be found 
following these descriptions. 

Cursor Movement 

When the edit mode is first entered via the "V" command, a cursor is placed 
in the upper lefthand corner of the screen. It should appear as a white block 
and may enclose a black letter. Whenever any key is typed and it is not recog- 
nized as an editor command, it is placed in the text window where the cursor 
appears. Likewise, any line functions (such as delete line) work on the line 
where the cursor is found. 


Ctrl a , Ctrl v , Ctrl < , Ctrl > move-cursor commands 

To change the current edit line or character, one of four commands 
may be given. These are known as cursor commands. They are the four 
keys with arrows on them. These keys move the cursor in the direction 
specified by the arrow on the particular key pressed. There are times, 
however, when this is not the case. 

If the current cursor line is the topmost line of the text window, 
and the "cursor-up" command is issued (by simultaneously typing "ctrl" 
and “up-arrow"), the cursor will move to the bottom line of the text 
window. Likewise, a subsequent "cursor-down" command would return the 
cursor to the topmost line of the window. Similarly, if the cursor is 
positioned on the leftmost edge and the "cursor-left" command is given, 
the cursor will "wrap" to the rightmost character ON THE SAME LINE. 

Issuing "cursor-right" will wrap back to the first character on that line. 


RETURN next-line command 

Normally, the RETURN key positions the cursor on the first character 
of the next line. If RETURN is pressed when the cursor is on the last 
line of the text window (i.e., when the last text line of the screen is 
current), the cursor is positioned in the upper lefthand corner of the 
screen. 


TAB tabulate command 

The TAB key is used to tabulate to the next fixed four column 
tabular stop to the right of the current cursor character. TABbing off 
the end of the current line simply places the cursor at the beginning of 
that same line. 


NOTE: 


Many commands in the editor will "mark" a current FORTH screen as updated 
so that any changes made can be preserved on disk. As simple cursor movement 
does not change the text window in any way, these commands never mark the 
current FORTH screen. See the section on screen management for more informa- 
tion. 


XI-5 


val FORTH Video Editor 1.1 


Editing Commands 

Editing commands are those commands which modify the text in some 
predefined manner and mark the current FORTH screen as updated for later 
saving. 


Ctrl INS character insert command 

When the "insert-character" command is given, a blank character 
is inserted at the current cursor location. The current character and 
all characters to the right are pushed to the right by one character 
position. The last character of the line "falls off" the end and is 
lost. The inserted blank then becomes the current cursor character. 
This is the logical complement to the "delete-character" command 
described below. 


Ctrl DEL delete character command 

When the "delete-character" command is issued, the current cursor 
character is removed, and all characters to the right of the current 
cursor character are moved left one position, thus giving a "squeeze" 
effect. This is normally called "closing" a line. The rightmost 
character on the line (which was vacated) is replaced with a blank. 

This serves as the logical complement to the "insert-command" described 
above. 


shift INS line insert command 

The "line-insert" command inserts a blank line between the current 
cursor line and the line immediately above it. The current line and all 
lines below it are moved down one line to make room for the new line. 

The last line on the screen falls off the bottom and is lost. If this 
command is accidentally typed, the "oops" command (ctrl-0) described 
later can be used to recover from the mistake. Also see the "from buffer" 
command described in the section on buffer management for a similar command. 
This command serves as the logical complement to the "line-delete" command 
described below. 


shift DEL line delete command 

The "line-delete" command deletes the current cursor line. All 
lines below the current line are brought up one line and a blank line 
fills the vacated bottom line of the text window. The deleted line is 
lost. If this command is accidentally issued, recovery can be made by 
issuing the "oops" command (ctrl-0) described later. Also see the 
"to-buffer" command described in the section on buffer management for a 
similar command. The "delete-line" command serves as the logical comple- 
ment to the "line-insert" comnand. 


XI-6 


valFORTH Video Editor 1.1 


Ctrl H erase to end of line 

The "Hack" command performs a clear- to-end-of-1 ine function. The 
current cursor character and all characters to the right of it on the 
current line are blank filled. All characters blanked are lost. The 
"oops" command described later can be used to recover from an accidentally 
hacked line. 


Ctrl I insert/replace toggle 

In normal operation, any key typed which is not recognized by the 
editor as a control command will replace the current cursor character 
with itself. This is the standard replace mode. Normally, if one 
wanted to insert a character at the current cursor location, the insert 
character command would have to be issued before any text could be 
entered. If inserting many characters, this is cumbersome. 

When active, the insert submode automatically makes room for any 
new characters or words and frees the user from having to worry about 
this. When the editor is called up via the "V" command, the insert mode 
is deactivated. Issuing the insert toggle command will activate it and 
the cursor will blink, indicating that the insert mode is on. Issuing 
the command a second time will deactivate the insert mode and restore 
the editor to the replace mode. Note that while in the insert mode, all 
edit commands (except BACKS, below) function as before. 


BACKS delete previous character 

The BACKS key behaves in two different ways, depending upon whether 
the editor is in the insert mode or in the replace mode. When issued 
while in the replace mode, the cursor is backed up one position and the 
new current character is replaced with a blank. If the cursor is at the 
beginning of the line, the cursor does not move, but the cursor character 
is still replaced with a blank. 

If the editor is in the insert mode, the cursor backs up one 
position, then deletes the new current cursor character and then closes 
the line. If the cursor is at the beginning of the line, the cursor 
remains in the same position, the cursor character is deleted and the 
line closed. 


NOTE: 


As all of the above commands modify the text window in some manner, the 
screen is marked as having been changed. This is to be sure that all changes 
made are eventually saved on disk. The "quit" command described in the section 
on changing screens allows one to unmark a screen so that major mistakes need 
not be saved. 


XI -7 


valFORTH Video Editor 1.1 


Buffer Management 

Much of the utility of the valFORTH editor lies in its ability to tempo- 
rarily save text in a visible buffer. To aid the user, it is possible to 
temporarily send text to the buffer and to later retrieve it. This storage 
buffer can hold as many as 320 1ines of text simultaneously. This buffer is 
viewed through a 5 line "peephole" visible as the last window on the screen. 
Using this buffer, it is possible to duplicate, move, and easily reorganize 
text, in addition to temporarily saving a line that is about to be edited so 
that the original form can be viewed or restored if necessary. The following 
section will explain exactly how to accomplish each of these actions. 


Ctrl T to buffer command 

The "to-buffer" command deletes the current cursor line, but 
unlike the "delete-line" command where the line is lost, this command 
moves the "peephole" down and copies the line to the bottom line of the 
visible buffer window. This line is the current buffer line. The buffer 
is rolled upon each occurrence of this command so that it may be used 
repeatedly without the loss of stored text. 

For example, if the cursor is positioned on line eight of the display 
shown in figure 1 and the "to-buffer" command is issued twice, the final 
result will be as shown in figure 2. 


c trl F from buffer command 

The "from-buffer" command does exactly the opposite of the "to- 
buffer" command described above. It takes the current buffer line and 
inserts it between the current cursor line and the line above it. The 
cursor line and all lines below it are moved down one line with the last 
line of the text window being lost. If the cursor were placed on line 14 
of the above screen display and the "from-buffer" command were issued once, 
the display in figure 3 would result. 


X I -8 


val FORTH Video Editor 1.1 


Screen #50 U #Bufs: 5 


Current: 


( Example screen ) ( line 0 ) 

: TEST1 ( line 2 ) 

10 0 
DO 

I CR . 

LOOP ; 


: +C! 

DUP C@ ROT + 

SWAP C! ; 

( bottom line ) 


Current: 


: OCTAL 

( — ) 

8 BASE ! ; 



fig. 2 


XI- 9 


valFORTH Video Editor 1.1 


Screen #50 U #Bufs: 5 


Current: 


( Example screen ) ( line 0 ) 

: TEST1 ( line 2 ) 

10 0 
DO 

I CR . 

LOOP ; 


: +C ! 

DUP CG> ROT + 

SWAP C! ; 

■ 8 BASE ! ; 

( bottom line ) 


line was 

8 BASE 



rolled to 




the top 




Current: 

: OCTAL 


( — ) 


fig. 3 


If the "from-buffer" command is issued again, then lines 13 
through 15 of the text window would look like: 


Current: 


: OCTAL ( — ) 

8 BASE ! ; 

( bottom line ) 


fig. 4 


Note that a block of text has been moved on the screen. Larger 
blocks of text can be moved in the same manner. 


XI- 10 


va 1 FORTH Video Editor 1.1 


Ctrl K copy to buffer command 

The "copy-to-buffer" command takes the current cursor line and 
duplicates it, sending the copy to the buffer. This commands functions 
identically to the “to-buffer" command described above, except that the 
current cursor line is NOT deleted from the text window. 


Ctrl U copy from buffer 

The "copy-from-buffer" command replaces the current cursor line with 
the current buffer line. This command functions identically to the "from- 
buffer" command described above, except that the buffer line is not inserted 
into the text window, it merely replaces the current cursor line. The 
"oops" command described below can be used to recover from accidental 
usage of this command. 


Ctrl R roll buffer 

The "roll-buffer" command moves the buffer "peephole" down one line 
and redisplays the visible window. If the buffer were the minimum five 
lines in length, the bottom four lines in the window would move up a line 
and the top line would "wrap" to the bottom and become the current buffer 
line. If there were more than five buffer lines, the bottom four lines 
would move up a line, the topmost line would be pushed up behind the 
peephole, and a new buffer line coming up from below the peephole would 
be displayed and made current. For example, if the buffer were five lines 
long and contained: 


Current: 


( 

Who? 

) 

( 

What? 

) 

( 

When? 

) 

( 

Where? 

) 

( 

Why? 

) 


Fig. 5 


the "roll -buffer" command gives: 


Current: 


( What? ) 

( When? ) 

( Where? ) 

( Why? ) 

( Who? ) 


Fig. 6 


XI- 11 


val FORTH Video Editor 1.1 


Ctrl B back-roll -buffer command 

The "back-roll-buffer" does exactly the opposite of the "roll- 
buffer" command described above. For example, if given the buffer in 
figure 6 above, the "back-roll" command would give the buffer shown in 
figure 5. 


Ctrl C clear buffer line command 

The "clear-buffer-line" command clears the current buffer line and 
then "back-rolls" the buffer so that successive clears can be used to 
erase the entire buffer. 


NOTE: 


Any of the above commands which change the text window will mark the 
current screen as updated. Those commands which alter only the buffer window 
(such as the "roll" command) will not change the status of the current screen. 


XI- 12 


val FORTH Video Editor 1.1 


Changing Screens 

There are four ways in which to leave a FORTH screen. These four methods 
are: moving to a previous screen, moving to a following screen, saving the 

current screen and exiting, or simply aborting the edit session. The four 
commands allowing this are now described: 


Ctrl P previous screen command 

The "previous-screen" command has two basic functions. If the lower 
part of the current screen is being viewed in the text window, this 
command simply displays the upper portion of the screen. If the upper 
portion is already being viewed, then the "previous-screen" command saves 
any changes made to the current screen and then loads in the screen 
immediately before the current screen. The lower part of the screen 
will then be displayed. If in the half-K screen mode, however, this 
command simply changes screens. 


Ctrl N next screen command 

Like the "previous-screen" command described above, the "next-screen" 
command also has two basic functions. If the upper part of a screen is 
being viewed, this command simply displays the lower portion. If, on the 
other hand, the lower part of the screen is being edited, any changes made 
to the current screen are saved and the next screen is loaded. 


Ctrl S save command 

The "save" command saves any changes made to the current screen and 
exits the edit mode. The video screen is cleared, and the number of the 
screen just being edited is displayed for reference. Note that it is 
usually a good idea to immediately FLUSH (described in the section on 
screen management below) any unsaved screens. 


Ctrl Q quit command 

The "quit" command aborts the edit session "forgetting" any changes 
made to the text visible in the text window. Changes made on previously 
edited screens will NOT be forgotten. The "quit" command is usually 
used when either the wrong screen has been called up, or if it becomes 
desirable to start over and re-edit the screen again. 


XI - 1 3 


val FORTH Video Editor 1.1 


Special Commands 

There are four special commands in this editor which allow greater flexi- 
bility in programming on the val FORTH system: 



ESCAPE special key command 

The "special-key" command instructs the video editor to ignore 
any command function of the key typed next and force a character to the 
screen. For example, normally when "ctrl >" is typed, the cursor is 
moved right. By typing “ESCAPE Ctrl >" the cursor is not moved -- 
rather, the right-arrow is displayed. 


Ctrl A arrow command 

When dealing with FORTH screens, it is often necessary to put the 
FORTH word (pronounced "next screen") or the Val FORTH word "==>" 

(pronounced "next screen") or the ValFORTH word "==>" (pronounced "next 
half-K screen") at the end of a screen for chaining a long set of words 
together. This command automatically places, or erases, an arrow in the 
lower right hand corner of the text window. If " — >" is already there, 
it is replaced with “==>". If "==>" is found, it is erased. (This 
command marks the screen as updated. ) 


Ctrl J 


split line command 


o 


Often times, for formatting reasons, it is necessary to "split" a 
line into two lines. The split line command takes all characters to the 
left of the cursor and creates the first line, and with the remaining 
characters of the original line, a second line is created. Graphically, 
this looks like: 

before: | The quick*brown fox jumped. | 


after: | The quick* 1 

I brown fox jumped. I 

Since a line is inserted, the bottom line of the text window is lost. 
Using the "oops" command below, however, this can be recovered. 



X 1-14 


valFORTH Video Editor 1.1 


u oops command 

Occasionally, a line is inserted or deleted accidentally, half a 
line cleared by mistake, or some other major editing blunder is made. 
As the name implies, the "oops" command corrects most of these major 
editing errors. The "oops" command can be used to recover from the 
following commands: 


1) insert line command (shift INS) 

2) delete line command (shift DEL) 

3) hack command (ctrl H) 

4) to buffer command (ctrl T) 

5) from buffer command (ctrl F) 

6) copy from buffer command (ctrl U) 

7) split line command (ctrl J) 


XI - 15 


val FORTH Video Editor 1.1 


Screen Management 

In addition to the conniands available while in the edit mode, there are 
several other commands which are for use outside of the edit mode. Typically, 
these commands deal with entire screens at a time. 


FLUSH ( — ) 

When any changes are made to the current text window, the current 
screen is marked as having been changed. When leaving the edit mode 
using the "save" command, the current screen is sent to a set of internal 
FORTH buffers. These buffers are not written to disk until needed for 
other data. Thus, if no other screen is ever accessed, the buffers will 
never be saved to disk. The FLUSH command forces these buffers to be 
saved if they have been marked as being modified. 

Example: FLUSH <ret> 


EMPTY-BUFFERS ( — ) 

Occasionally, screens are modified temporarily or by accident, and 
get marked as being modified. The EMPTY-BUFFERS command unmarks the 
internal FORTH buffers and fills them with zeroes so that "bad" data are 
not saved to disk. Zero filling the buffers ensures that the next access 
to any of the screens that were in the buffers will load the 
unadulterated copy from disk. The abbreviation MTB is included in the 
valFORTH system to make the use of this command easier. 

Examples: EMPTY-BUFFERS <ret> 

MTB <ret> 


COPY ( from to — ) 

To duplicate a screen, the COPY command is used. The screen "from" 
is copied to the screen "to" but not flushed. 


Example: 51 60 COPY <ret> 

(Copies screen 51 to screen 60.) 


CLEAR ( scr# — ) 

The CLEAR command fills the specified screen with blanks so that a 
clean edit can be started. The screen is then made current so that the 
L command can be used to enter the edit mode. 

Example: 50 CLEAR <ret> 

(Clears screen 50 and makes it current.) 


XI- 16 


val FORTH Video Editor 1.1 


CLEARS ( sc r# ^screens — ) 

The CLEARS command is used to clear blocks of screens at a time. 
After user verification, it starts with the specified screen and clears 
the specified number of consecutive screens. The first screen cleared 
is made current so that the L command can be used to enter the edit mode. 

Example: 25 3 CLEARS <ret> 

Clear from SCR 25 

to SCR 27 <Y/N> Y 

(Screens 25-27 are cleared. Screen 25 is made current.) 


SHOVE ( from to # screens — ) 

The SHOVE command is a multiple screen copy command used for copying 
large numbers of consecutive screens at a time. User verification is 
required by this command to avoid disastrous loss of data. All screens 
to be copied are read into available memory and the user is prompted 
to initiate the copy. This allows the swapping of disks between moves 
to make disk transfers possible. The number of screens the SHOVE command 
can copy at a time is limited only by available memory. 

Example: 50 60 5 SHOVE <ret> 

SMOVE from 50 thru 54 

to 60 thru 64 <Y/N> Y 
Insert source <RETURN> <ret> 

Insert dest. <RETURN> <ret> 

(Transfers the specified screens.) 


XI -17 


val FORTH Video Editor 1.1 


Editor Command Summary 

Below is a quick reference list of all the commands which the video editor 
recognizes. 

Entering the Edit Mode: (executed outside of the edit mode) 


V 

( scr# — ) 

Enter the edit mode and view the 
specified screen. 

L 

( — ) 

Re-view the current screen. 

WHERE 

( — ) 

Enter the edit mode and position the 
cursor over the word that caused a 
compilation error. 

LOCATE cccc 

( — > 

Enter the edit mode and position the 
cursor over the word defining "cccc". 

LOCATOR 

( ON/OFF --- ) 

When ON, allows all words compiled until 
the next OFF to be locatable using the 
LOCATE command above. 

#BUFS 

( #lines --- ) 

Sets the length (in lines) of the storage 
buffer. The default is five. 


XI- 18 


val FORTH Video Editor 1.1 


Cursor Movement: 

(issued within the edit mode) 

Ctrl a 

Move cursor up one line, wrapping to the bottom 
line if moved off the top. 

Ctrl v 

Move cursor down one line, wrapping to the top 
line if moved off the bottom. 

Ctrl < 

Move cursor left one character, wrapping to the 
right edge if moved off the left. 

Ctrl > 

Move cursor right one character, wrapping to the 
left edge if moved off the right. 

RETURN 

Position the cursor at the beginning of the next 
line. 

TAB 

Advance to next tabular column. 

Editing Commands: 

(issued within the edit mode) 

Ctrl INS 

Insert one blank at cursor location, losing the 
last character on the line. 

Ctrl DEL 

Delete character under cursor, closing the line. 

shift INS 

Insert blank line above current line, losing the 
last line on the screen. 

shift DEL 

Delete current cursor line, closing the screen. 

Ctrl I 

Toggle insert-mode/ replace-mode, (see full 
description of ctrl-I). 

BACKS 

Delete last character typed, if on the same line 
as the cursor. 

Ctrl H 

Erase to end of line (Hack). 


XI-19 


val FORTH Video Editor 1.1 


Buffer Management: 

(issued within the edit mode) 

Ctrl T 

Delete current cursor line sending it to the 
edit buffer for later use. 

Ctrl F 

Take the current buffer line and insert it 
above the current cursor line. 

Ctrl K 

Copy current cursor line sending it to the 
edit buffer for later use. 

Ctrl U 

Take the current buffer line and copy it to the 
current cursor line. 

Ctrl R 

Roll the buffer making the next buffer line 
current. 

Ctrl B 

Roll the buffer backwards making the previous 
buffer line on the screen current. 

Ctrl C 

Clear the current buffer line and perform 
a ctrl-B. 


Note: The current buffer line is last line visible on the video display 


Changing Screens: 

(issued within the edit mode) 

Ctrl P 

Display the previous screen saving all changes 
made to the current text window. 

Ctrl N 

Display the next screen saving all changes made 
to the current text window. 

Ctrl S 

Save the changes made to the current text window 
and end the edit session. 

Ctrl Q 

Quit the edit session forgetting all changes 
made to current text window. 

Special Keys: 

(issued within the edit mode) 

ESC 

Do not interpret the next key typed as any of 
the commands above. Send it directly to the 
screen instead. 

Ctrl A 

Put "==>", or erase the lower right-hand 

corner of the text window. 

Ctrl J 

Split the current line into two lines at the 
point where the cursor is. 

Ctrl 0 

Corrects any major editing blunders. 


XI- 20 


val FORTH Video Editor 1.1 


Screen Management: 

(executed outside of the edit mode) 

FLUSH 

( — ) 

Save any updated FORTH screens to disk. 

EMPTV-BUFFERS 

( — ) 

Forget any changes made to any screens not 
yet FLUSHed to disk. Used in "losing" major 
editing mistakes. The abbreviation MTB is 
more commonly used. 

COPY 

( from to — ) 

Copies screen #from to screen #to. 

CLEAR 

( scr# --- ) 

Blank fills specified screen. This performs 
the same functions as "WIPE" in Leo Brodie's 
book. 

CLEARS 

( scr# ^screens — ) 
Blank fills the specified number of screens 
starting with screen scr#. 

SMOVE 

( from to #screens — ) 

Duplicate the specified number of screens 
Starting with screen number "from". Allows 
swapping of disks before saving screens to 
screen number "to". 


XI- 21 


~) 


o 




o 


STRING UTILITIES 


The following collection of words describes the string utilities of the 
valFORTH Utilities Package. Strings have been implemented in the FORTH 
language in many different ways. Most implementations set aside space for a 
third stack — a string stack. As strings are entered, they are moved (using 
CMOVE) to this stack. When strings are manipulated on this stack, many long 
memory moves are usually required. This method is typically much slower than 
the method implemented in valFORTH. 

Rather than waste memory space with a third stack, valFORTH uses the 
already existing parameter stack. Unlike the implementation described above, 
valFORTH does not store strings on the stack. Rather, it stores the addresses 
of where the strings can be found.* Using this method, words such as SWAP , 
DUP , PICK , and ROLL can be used to manipulate strings. Routines such as 
string sorts which work on many strings at a time are typically much faster 
since addresses are manipulated rather than long strings. In practice, we 
have found few if any problems using this method of string representation. 


String Glossary 

For the purposes of this section, a string is defined to be a sequence 
of up to 255 characters preceded by a byte indicating its length. The first 
character of the string is referenced as character one. If the length of the 
string is zero, it has no characters and is called the "null" string. In 
stack notation, strings are represented by the symbol $ and the address of the 
string is stored on the stack rather than the string itself*. 


-TEXT addrl n addr2 -- flag 

The word -TEXT compares n characters at addressl with n characters 
at address2. Returns a false flag if the sequences match, true. if they 
don't. Flag is positive if the character sequence at addressl is alpha- 
betically greater than the one at address2. Flag is zero if the 
character sequences match, and is negative if the character sequence at 
addressl is alphabetically less than the one at address2. 

-NUMBER addr — d 

-NUMBER functions identically to the standard FORTH word NUMBER 
with the only difference being that -NUMBER does not abort program 
execution upon an illegal conversion. -NUMBER takes the character string 
at addr and attempts to convert it to a double number. On successful 
conversion, the value d is returned with the status variable NFLG set 
to one. On unsuccessful conversion, a double number zero is returned 
with the variable NFLG set to zero. -NUMBER is pronounced "not number". 


*Representing strings on the stack by their addresses is a very useful concept 
borrowed from MMS Forth (TRS-80), authored by Tom Dowling, and available from 
Miller Microcomputer Services, 617-653-6136. 


XII-1 


NFLG 


— addr 

A variable used by -NUMBER that indicates whether the last conversion 
attempted was successful. NFLG is true if the conversion was successful; 
otherwise, it is false. 

UMOVE addrl addr2 n -- 

UMOVE is a "universal" memory move. It takes the block of memory 
n bytes long at addrl and copies it to memory location addr2. UMOVE 
correctly uses either CMOVE or <CM0VE so that when a block of memory is 
moved onto part of itself, no data are destroyed. 

" cccc" — (at compile time) 

cccc; — addr (at run time) 

If compiling, the sequence cccc (delimited by the trailing ") is 
compiled into the dictionary as a string: 

I len lc| cl cl... I cl 

All valFORTH strings are represented in this fashion. Since a single 
byte is used to store the length, a maximum string length of 255 is 
allowed. A string with 0 length is called a "null" string. At 
execution time, " puts the address in memory where the string is 
located onto the stack. 

Note that " is IMMEDIATE. When executed outside of a colon 
definition, the string is not compiled into the dictionary, but 
is stored at PAD instead. 

Example: " This is a string" 

$ CONSTANT cccc $ — (at compile time) 

cccc: — $ (at execution time) 

Takes the string on top of the stack and compiles it into the 
dictionary with the name cccc. When cccc is later executed, the 
address of the string is pushed onto the stack. 

Example: " Ready? <Y/N> " SCONSTANT VERIFY 

$VARIABLE cccc n -- 

cccc: -- $ 

Reserves space for a string of length n. When cccc is later 
executed, the address of the string is pushed onto the stack. 

Example: 80 $VARIABLE TEXTLINE 

$. $ — 

Takes the string on top of the stack and sends it to the current 
output device. 

Example: " Hi there" $. <ret> Hi there 

$! $ addr — 

Takes the string at second on stack and stores it at the address 
on top of stack. 

Example: " Store me!" TEXTLINE $! 


XI 1-2 


$+ $1 $2 — $3 

Takes $2 and concatenates it with $1, leaving $3 at PAD. 

Example: " Santa " $C0NSTANT 1ST 

" Claus" $ CON ST ANT LAST 
1ST LAST $+ 

$. <ret> Santa Claus 

LEFTS $1 n — $2 

Returns the leftmost "n" characters of $1 as $2. $2 is stored 

at PAD. 

Example: " They" 3 LEFTS S- <ret> The 

RIGHTS $1 n — $2 

Returns the rightmost "n" characters of $1 as $2. S2 is stored 
at PAD. 

Example: " mother" 5 RIGHTS $• <ret> other 

MID$ $1 n u — S2 

Returns $2 of length u starting with the nth character of $1. 
Recall that the first character of a string is numbered as one. 

Example: " Timeout" 3 2 MI D$ $. <ret> me 

LEN $ — len 

Returns the length of the specified string. 

ASC $ — c 

Returns the ASCII value of the first character of the specified 
string. 

SCOMPARE SI $2 — flag 

Compares $1 with $2 and returns a status flag. The flag is 

a) positive if Si is greater than $2 or is equal to $2, but longer, 

b) zero if the strings match and are the same length, and c) negative 
if $1 less than $2 or if they are equal and $1 is shorter than $2. 

$= $1 $2 - flag 

Compares two strings on top of the stack and returns a status 
flag. The flag is true if the strings match and are equal in length, 
otherwise it is false. 

$< Si $2 -- flag 

Compares two strings on top of the stack and returns a status 
flag. The flag is true if $1 is less than $2 or if $1 matches $2 but 
is shorter in length. 

S> $1 $2 — flag 

Compares two strings on top of the stack and returns a status 
flag. The flag is true if $1 is greater than $2 or if Si matches $2 
but is longer in length. 

SAVES $1 -- $2 

As most string operations leave resultant strings at PAD, the word 
SAVES is used to temporarily move strings to PAD+512 so that they can 
be manipulated without being altered in the process. 

Example: " Wash" SAVES " ington" $+ 


XI 1-3 


INSTR 


$1 $2 — n 

Searches $1 for first occurrence of $2. Returns the character 
position in $1 if a match is found; otherwise, zero is returned. 

Example: " FDCBA" SCONSTANT GRADES 

GRADES " A" INSTR 1- . <ret> 4 

CHR$ c -- $ 

Takes the character "c" and makes it into a string of length one 
and stores it at PAD. 

DVAL $ - d 

Takes numerical string $ and converts it to a double length number. 
The variable NFLG is true if the conversion is successful, otherwise it 
is false. See -NUMBER above. 

Example: " 123" DVAL D. <ret> 123 


VAL $ - n 

Takes the numerical string $ and converts it to a single length 
number. The variable NFLG is true if the conversion is successful, 
otherwise it is false. See -NUMBER above. 

DSTRS d — $ 

Takes the double number d and converts it to its ASCII representa- 
tion as $ at PAD. 

Example: 123 DSTR$ $. <ret> 123 

STR$ n — $ 

Takes the single length number n and converts it to its ASCII 
representation as $ at PAD. 

STRINGS n $1 - $2 

Creates $2 as n copies of the first character of $1. 

#IN$ n -- $ 

#IN$ has three similar but different functions. If n is positive, 
it accepts a string of n or fewer characters from the terminal. If n is 
zero, it accepts up to 255 characters from the terminal. If n is nega- 
tive, it returns only after accepting -n characters from the terminal. 
The resultant string is stored at PAD. 

INS — $ 

Accepts a string of up to 255 characters from the terminal. 

S-TB $1 -- $2 

Removes trailing blanks from $1 leaving new $2. 

SXCHG $1 - $2 

Exchanges the contents of $1 with $2. 


XII-4 


ARRAYS and their COUSINS 

All of the words described below create structures that are accessed in the 
same way, i.e., by putting the index or indices on the stack and then typing 
the structure's name. The differences are in the ways the structures are 
created. 

The concept of the array should be known from BASIC. _ While in fig-FORTH 
there is no standard way to implement arrays and similar structures, there 
does exist a general consensus about how this should be done. 


The point on which there is the most divergence of opinion is whether the 
first element in an array should be referred to by the index 0 or 1. We 
select 0 for the first index since this gives much cleaner code and makes 
more sense than 1 after you get used to it. (We've worked with it both ways., 


ARRAY and CARRAY, and 2ARRAY and 2CARRAY 

The size of an array, specified when it is defined, is the number of elements 
in the array. In other words, an array defined by 


8 ARRAY BINGO 


will have 8 elements numbered 0-7. 
To access an element of an array, do 


n array-name 


to qet the address of the nth element on the stack. (You will not be told 
if the number n is not a legitimate index number for the array.) For example, 


5 BINGO 


will leave the address of element number 5 in BINGO on the stack. You can 
store to or fetch from this address as you require. 


The word CARRAY defines a byte or character array. A c-array works the same 
as an array, except that you must use CO and C! to manipulate single element , 

rather than 0 and !. 

T , , c ,,ppn V and 2CARRAY each take two numbers during definition of a 

“ ssTit-irsss tiszix ssas.’s: s-™ 

named ROOK, the two phrases 


ROOK 4 6 CHESSBOARD C! 

and 

ROOK 6 4 CHESSBOARD C! 

don't do the same thing. Also note that the phrase 


XI 1-5 


8 8 2CARRAY CHESSBOARD 

defines a 2CARRAY of 8 x 8 = 64 elements, with both indices running from 0 to 
7. 

When an ARRAY or a CARRAY is defined, the initial values of the elements 
are undefined. 

TABLE AND CTABLE 

A cousin of ARRAY is TABLE. Example: The phrase 

TABLE THISLIST 14 , 18 , -34 , 16 , 

defines a table THISLIST of 4 elements. (The commas above are part of the 
code and must be included.) The number of elements does not have to be 
specified. The elements in THISLIST are accessed using the indices 0-3, 
the same as if it had been defined as an array. The word CTABLE works 
similarly, though using C, instead of , to compile in the numbers. Note that 
negatives won't be compiled in by a C, since in two's complement representation 
negative numbers always occupy the maximum number of bytes. 

VECTOR and CVECTOR 

The last array-type words in this package are CVECTOR and VECTOR. Vector is 
just another name for a list. These words are used when the elements of the 
array you want to create are on the stack, with the last element on top of the 
stack. You just put the number of elements on the stack and the VECTOR or 
CVECTOR, and the name you want to use. Example: 

-3 8 127 899 -43 5 VECTOR POSITIONS 

creates an array named POSITIONS with 5 elements 0-4 with -3 in element 0 
and -43 in element 4. CVECTOR works in a similar way. 


EXAMPLES: 


2 3 BINGO ! 

Stores the value 2 into element 3 of array BINGO. 


2 THISLIST @ 

Will leave the value in element 2 of table THISLIST. 
According to the definition of THISLIST above, this value 
wi 11 be - 34 . 


3 POSITION @ . <cr> 899 


XI 1-6 


ARRAY WORD GLOSSARY 


ARRAY cccc, n -- (compiling) 

cccc: m — addr (executing) 

When compiling, creates an array named cccc with n 16-bit elements numbered 0 
thru n-1. Initial values are undefined. When executing, takes an argument, 
m, off the stack and leaves the address of element m of the array. 

CARRAY cccc, n -- (compiling) 

cccc: m — addr (executing) 

When compiling, creates a c-array named cccc with n 8-bit elements numbered 
0 thru n-1. Initial values are undefined. When executing, takes an argument, 
m, off the stack and leaves the address of element m of the c-array. 

TABLE cccc, -- (compiling) 

cccc: m -- addr (executing) 

When compiling, creates a table named cccc but does not allot space. Elements 
are compiled in directly with , (comma). When executing, takes one argument, 
m off the stack and, assuming 16-bit elements, leaves the address of element 
m of the table. 

CTABLE cccc, — (compiling) 

cccc: m — addr (executing) 

When compiling, creates a c-table named cccc but does not allot space. Elements 
are compiled in directly with C, (c-comma). When executing, takes one argument, 
m off the stack and, assuming 8-bit elements, leaves the address of element m 
of the c-table. 

X! nO ... nN count addr — 

Stores count 16-bit words, nO thru nN into memory starting at addr, with nO 
going into addr. Pronounced "extended store." 

XC! bO . . . bN count addr — 

Stores count 8-bit words, bO thru bN into memory starting at addr, with bO 
going into addr. Pronounced "extended c-store." 

VECTOR cccc, nO ... nN count -- (compiling) 

cccc: m — addr (executing) 

When compiling, creates a vector named cccc with count 16-bit elements 
numbered 0-N. nO is the initial value of element 0, nN is the initial value 

of element N, and so on. When executing, takes one argument, m, off the stack 

and leaves the address of element m on the stack. 

CVECTOR cccc, bO . . . bN count — (compiling) 
cccc: m -- addr (executing) 

When compiling, creates a c-vector named cccc with count 8-bit elements 
numbered 0-N. bO is the initial value of element 0, bN is the initial value 

of element N, and so on. When executing, takes an argument, m, off the stack 

and leaves the address of element m on the stack. 


XI 1-7 


CASE STRUCTURES 


It often becomes necessary to make many tests upon a single number. 
Typically, this is accomplished by using a series of nested "DUP test IF" 
statements followed by a series of ENDIFs to terminate the IFs. This is 
arduous and very wasteful of memory, val FORTH contains four very powerful 
Pascal-type CASE statements which ease programming and conserve memory. 


The CASE: structure 


Format: 


CASE: wordname 

wordO 
wordl 

wordN ; 


The word CASE: creates words that expect a number from 0 to 
N on the stack. If the number is zero, wordO is executed; if the 
number is one, the wordl is executed; and so on. No error checks are 
made to ensure that the case number is a legal value. 

Example: 

: ZERO ." Zero" ; 

: ONE ." One" ; 

: TWO ." Two" ; 

CASE: NUM 

ZERO 
ONE 

TWO ; 

0 NUM <ret> Zero 

1 NUM <ret> One 

2 NUM <ret> Two 

Note that any other number (e.g. 3 NUM) will crash the system. 


XI 1-8 


The CASE Structure 


Format: 

: wordname 

CASE 

wordO 

wordl 

wordN 

( NOCASE wordnone ) (optional) 

CASEND 


The CASE. .. CASEND structure is always used within a colon 
definition. Like CASE: above, it requires a number from 
0 and N. However, unlike CASE: above, boundary checks are made 
so that an illegal case will do nothing. If the optional NOCASE 
clause is included then wordnone is executed if an "out of bounds" 
number is used. 

Examples: 

I) : ZERO 

: ONE 

: TWO 

: CHECKNUM 

CASE 
ZERO 
ONE 
TWO 

CASEND ; 

0 CHECKNUM <ret> Zero 

1 CHECKNUM < r et> One 
999 CHECKNUM <ret> (nothing happens) 

2 CHECKNUM <ret> Two 


" Zero" ; 

" One" ; 

" Two" ; 

( n -- ) 


XI 1-9 


: GRADEA 

A" ; 

: GRADEB 

B" ; 

: GRADEC 

C" ; 

: GRADED 

D" ; 

: OTHER 

Failed" 


DECIMAL 

: GETGRADE { — ) 

KEY 65 - (Convert A to 0, B to 1, etc) 

CASE 
GRADEA 
GRADEB 
GRADEC 
GRADED 

NOCASE OTHER 
CASEND ; 


GETGRADE creturn and press A> A 
GETGRADE creturn and press B> B 
GETGRADE creturn and press F> Failed 
GETGRADE Creturn and press D> D 


The SEL Structure 
Format: 


wordname 


SEL 

nl -> wordO 
n2 -> wordl 

(Select) 

nN > wordN 
NOSEL wordnone ) 

(optional ) 


SELEND 


XII-10 


The SEI SELEND structure is used when the "selection" numbers 

(nl etc.) are not sequential. This structure is somewhat slower than 
either CASE or CASE: , but is much more general. SEL is typically 

used in operations such as table driver menus where single keystroke 
commands are used. The valFORTH video editor uses the SEL structure 
to implement the many editing keystroke commands. 


Example: 


I) 


NICKEL 

nickel." ; 

DIME 

." dime." ; 

QUARTER 

." quarter." ; 

4BITS 

fifty cent piece." 

SUSANB 

." dollar" ; 

BAD$$$ 

wooden nickel." ; 


: MONEY-NAME ( n — ) 

." That is called a " 

SEL 

5 -> NICKEL 
10 -> DIME 
25 -> QUARTER 
50 -> 4BITS 
100 -> SUSANB 

NOSEL BAD$$$ ( this line is optional ) 

SELEND ; 


5 MONEY-NAME <ret> That is called a nickel. 

33 MONEY-NAME <ret> That is called a wooden nickel. 

25 MONEY-NAME <ret> That is called a quarter. 


The COND Structure 


Format: 

: wordname 

COND 


conditionO 

« 

wordsO 

» 

condi tionl 

« 

words 1 

» 

condi tionN 

« 

wordsn 

» 


( NOCOND wordsnone ) (optional) 

CONDEND 


XI I- 11 


Unlike the three previous CASE structures which test for equality, 
the COND structure bases its selection upon any true conditional test 
(e.g. if n > 0 then...) COND can also be used for range cases. The 
NOCOND clause is optional and is only executed if no other condition 
passes. Only the code of the first condition that passes will be 
executed. 

Example: 

: EXAM ( score -- grade ) 

COND 


90 

>= 

« 

II 

Grade 

of A" 

4 

» 

80 

>= 

« 

II 

Grade 

of B" 

3 

» 

70 

> = 

« 

II 

Grade 

of C" 

2 

» 

60 

>= 

« 

II 

Grade 

of D" 

1 

» 

NOCOND 

II 

Not 

too 

good" 

0 




CONDEND ; 

Note that neither « nor » are needed (nor allowed) around the 
"NOCOND" case. Also note that more than one word can be executed 
between the « and » . 


1 


o 


) 


XI I- 12 




(intentionally left blank) 


D 


) 


XI 1-13 


DOUBLE NUMBER EXTENSIONS 


o 

The following words extend the set of double number words to be as nearly 
identical as possible to the set in the book Starting FORTH . The exceptions 
are DVARIABLE and DCONSTANT which conform to the FIG standard by expecting 
initial values on the stack. 

All of the single number operations comparable to the double number operations 
below were machine coded; all of the words below (with the exception of DVARIABLE) 
have high-level run time code and so are considerably slower than their single 
number counterparts. 


DOUBLE NUMBER EXTENSION GLOSSARY 


DVARIABLE cccc d - 

cccc; — addr 

At compile time, creates a double number variable cccc with the initial value d. 
At run time, cccc leaves the address of Its value on the stack. 

DCONSTANT cccc d — 

cccc: -- d 

At compile time, creates a double number constant cccc with the initial value d. 
At run time, cccc leaves the value d on the stack. 


0 , - 0 . 

A double number constant equal 

1- - 1. 

A double number constant equal 

D- dl dZ - d3 
Leevet dl-dl=d3. 


to double number zero, 
to double number one. 


00= d -- flag 

If d i§ equal to 0. leaves true flag; otherwise, leaves false flag. 
0= dl dZ - flag 

If dl equals dZ, leaves true flag; otherwise, leaves false flag. 


00«S d — flag 

If d Is negative, leaves true flag; otherwise, leaves false flag. 

0< dl dZ -- flag 

If dl is less than dZ, leaves true flag; otherwise, leaves false flag. 

D» dl dZ — flag 

If dl is greater than dZ, leaves true flag; otherwise, leaves false flag. 


o 


) 


XII-14 


DMIN dl dZ — d3 

Leaves the minimum of dl and d2. 

DMAX dl d2 — d3 

Leaves the maximum of dl and d2. 

D>R d — 

Sends the double number at top of stack to the return stack. 

DR> — d 

Pulls the double number at top of the return stack to the stack. 

D, d -- 

Compiles the double number at top of stack into the dictionary. 

DU< udl ud2 -- flag 

If the unsigned double number udl is less than the unsigned double number ud2, 
leaves a true flag; otherwise, leaves a false flag. 

M+ dl n — d2 

Converts n to a double number and then sums with dl. 


XI I- 15 


o 


o 


3 


HIGH RESOLUTION TEXT OUTPUT 


Occasionally, the need arises to print text in high resolution graphic 
displays (8 GR. ). The following set of words explains how Graphic Characters 
can be used in val FORTH programs. The Graphic-Character output routines are 
designed to function identically to the standard FORTH output operations. 
There is an invisible cursor on the high resolution page which always points 
to where the next graphic-character will be printed. As with normal text 
output, this cursor can be repositioned at any time and in various ways. 
Because of the nature of hi-res printing, this cursor can also be moved 
vertically by partial characters. This allows for super/subscripting, over- 
striking, and underlining. Multiple character fonts on the same line are 
also possible. 


GC IN I T 

Initializes the graphic character output routines. This must be 
executed prior to using any other hi-res output words. 

GC. n — 

Displays the single length number n at the current hi-res cursor 
location. 

GC.R nl n2 -- 

Displays the single length number nl right-justified in a field 
n2 graphic characters wide. See .R . 

GCD.R d n — 

Displays the double length number d right-justified in a field n 
graphic characters wide. See D.R . 

GCEMIT c — 

Displays the text character c at the current hi-res cursor location. 
Three special characters are interpreted by GCEMIT . The up arrow {'?') 
forces text output into the superscript mode; the down arrow (-» forces 
the text into the subscript mode; and the left arrow (<-) performs a 
GCBKS command (described below). See OSTRIKE below; also see EMIT. 

GCLEN addr n -- Ten 

Scans the first n characters at addr and returns the number of 
characters that will actually be displayed on screen. This is typically 
used to find the true length of a string that contains any of the non- 
printing special characters described in GCEMIT above. Used principally 
to aid in centering text, etc. 


GCR 


Repositions the hi-res cursor to the beginning of the next hi-res 
text line. See CR . 


GCLS 

Clears the hi-res display and repositions the cursor in the upper 
lefthand corner. 


XIII-1 


GCSPACE 


Sends a space to the graphic character output routine. See SPACE . 

GCSPACES n — 

Sends n spaces to the graphic character output routine. See SPACES . 

GCTYPE addr n — 

Sends the first n characters at addr to the graphic character output 
routine. See TYPE . 

GC" cccc" 

Sends the character string cccc (delimited by ") to the graphic 
character output routine. If in the execution mode, this action is 
taken immediately. If in the compile mode, the character string is 
compiled into the dictionary and printed out only when executed in 
the word that uses it. See ." . 


GCBKS 

Moves the hi-res cursor back one character position for overstriking 
or underlining. 

GCPOS horz vert -- 

Positions the hi-res cursor to the coordinates specified. Note 
that the upper lefthand corner is 0,0. 

GC$. addr — 

Sends the string found at addr and preceded by a count byte to the 
graphic character output routine. See $. . 

SUPER 

Forces the graphic character output routine into the superscript 
mode (or out of the subscript mode). See VMI below. May be performed 
within a string by the * character. 

SUB 

Forces the graphic character output routine into the subscript 
mode (or out of the superscript mode). See VMI below. May be performed 
within a string by the * character. 

VMI n — 

Each character is eight bytes tall. The VMI command sets the number 
of eighths of characters to scroll up or down when either a SUPER or SUB 
command is issued. Normally, 4 VMI is used to scroll 4/8 or half a 
character in either direction. 

VMI# -- addr 

A variable set by VMI. 

OSTRIKE ON or OFF — 

The GCEMIT command has two separate functions. If OSTRIKE (overstrike) 
option is OFF, the character output will replace the character at the 
current cursor position. This is the normal method of output. If the 
OSTRIKE option is ON, the new character is printed over top of the previous 
character giving the impression of an overstrike. This allows the user to 
underline text and create new characters: Example: To do underline, a 

value of, say, 2 should be used with VMI, and then the * character added 
in the string before the underline character. 


XI 1 1—2 


GCBAS 


-- addr 

A variable which contains the address of the character set displayed 
by GCEMIT. To change character sets, simply store the address of your 
new character set into this variable. 

GCLFT — addr 

A variable which holds the column position of the left margin. 
Normally two, this can be changed to obtain a different display window. 


GCRGT — addr 

A variable which holds the column position of the right margin. 
Normally 39, this can be changed to obtain a different display window. 


XI 1 1-3 


0 


(intentionally left blank) 


o 


J 


XI 1 1-4 


MISCELLANEOUS UTILITIES 


This is a grab-bag of useful words. Here they are... 


XR/W #secs addr blk flag — 

"Extended read-write." The same as R/W except that XR/W accepts a sector 
count for multiple sector reads and writes. Starting at address addr and 
block blk, read (flag true) or write (flag false) #secs sectors from or to 
disk. 

SMOVE org des count — 

Move count screens from screen # org to screen # dest. 

The primary disk rearranging word, also used for moving sequences of screens 
between disks. This is a smart routine that uses all memory available below 
the current GR. -generated display list, with prompts for verification and 
disk swap if desired. See val FORTH Editor 1.1 documentation for further details. 

LOADS start count — 

Loads count screens starting from screen # start. This word is used if you 
want to use words that are not chained together by --> ‘s. It will stop 
loading if a CONSOLE button is held down when the routine finishes loading 
its present screen. 

THRU start finish -- start count 

Converts two range numbers to a start-count format. Example: 

120 130 THRU PLISTS 
will print screens 120 thru 130. 

SEC n — 

Provides an n second delay. Uses a tuned do-loop. 

MSEC n — 

Provides an n millisecond delay, (approx) 

Uses a tuned do-loop. 

H->L n -- b 

Moves the high byte of n to the low byte and zero's the high byte, creating 
b. Machine code. 


L->H nl — n2 

Moves the low byte of nl to the high byte and zero's the low byte, creating 
n2. Machine code. 

H/L nl — nl(hi) nl(lo) . . _ . . . 

Split top of stack into two stack items: New top of stack is low byte of old 
top of stack. New second on stack is old top of stack with low byte zeroed. 
Example: HEX 1234 H/L .S <cr> 1200 0034 


XI 1 1-5 


BIT b — n 

Creates a number n that has only its bth bit set. The bits are numbered 0-15, 
with zero the least significant. Machine code. 

?BIT n b — f 

Leaves a true flag if the bth bit of n is set. Otherwise leaves a false flag. 
TBIT nl b — n2 

Toggles the bth bit of nl, making n2. 

SBIT nl b — n2 

Sets the bth bit of nl, making n2. 

RBIT nl b — n2 

Resets the bth bit of nl, making n2. 

STICK n — horiz vert 

Reads the nth stick (0-3) and resolves the setting into horizontal and 
vertical parts, with values from -1 to +1. -l -l means up and to the left, 

PADDLE nl — n2 

Reads the nlth paddle (0-7) and returns its value n2. Machine code. 

ATTRACT f -- 

If the flag is true, the attract mode is initiated. If the flag is false, 
the attract mode is terminated. 

NXTATR — 

If the system is in the attract mode, this command cycles to the next color 
setup in the attract sequence. Disturbs the timer looked at by 16TIME. 

HLDATR — 

If the system is in attract mode, zero's fast byte of the system timer so 
that attract won't cycle to next color setup for at least four seconds 
or until system timer is changed, say by NXTATR. Disturbs the timer looked 
at by 16TIME. 

16TIME — n 

Returns a 16 bit timer reading from the system clock at locations 19 and 20, 
decimal. This clock is updated 60 times per second, with the fast byte in 
20. Machine code, not fooled by carry. 

8RND - b 

Leaves one random byte from the internal hardware. Machine code. 

16RND — n 

Leaves one random word from the internal hardware. Machine code with 20 
cycle extra delay for rerandomization. 

CHOOSE ul — u2 

Randomly choose an unsigned number u2 which is less than ul. 


XI 1 1-6 


CSHUFL addr n — 

Randomly rearrange n bytes in memory, starting at address addr. 

Pronounced "c-shuffle." 

SHUFL addr n — 

Randomly rearrange n words in memory, starting at address addr. Pronounced 
"shuffle." SHUFL may also be used to shuffle items directly on the stack by 
doing SP@ n SHUFL. 


H. n - 

See DEBUG Glossary. 

A. addr — 

Print the ASCII character at addr, or if not printable, print a period. 

(Used by DUMP). 

DUMP addr n -- 

Starting at addr, dump at least n bytes (even multiple of 8) as ASCII and 
hex. May be exited early by pressing a CONSOLE button. 

BLKOP system use only 

BXOR addr count b -- 

Starting at address addr, for count bytes, perform bit-wise exclusive or 
with byte b at each address. Useful for toggling an area of display memory 
to inverse video or a different color, and for other purposes. For instance, 
in 0 GR. , do 


DCX 88 0 280 128 BXOR 

Then do Shift-Clear to clear the screen. Pronounced "block ex or." 


BAND addr count b — 

Starting at address addr, for count bytes, perform bit-wise AND with byte b 
at each address. Applications similar to BXOR. 

Pronounced "block and." 

BOR addr count b - 

Starting at address addr, for count bytes, perform bit-wise or with byte b 
at each address. Applications similar to BXOR. 

Pronounced "block or." 

STRIG n — flag 

Reads the button of joystick n (0-3). Leaves a true flag if the button is 
pressed, a false flag if it isn't. 

PTRIG n — flag 

Reads the button of paddle n (0-7). Leaves a true flag if the button is 
pressed, a false flag if it isn't. 


XI 1 1 - 7 


1 


(intentionally left blank) 


o 


o 


XI 1 1-8 


1 


TRANSIENTS 


One of the more annoying parts about common releases of FORTH concerns the 
FORTH machine code assemblers. On the positive side, FORTH-based assemblers 
can be extraordinarily smart and easy to use interactively, and can compile 
on the fly as you type, rather than in multiple-pass fashion. (The 6502 
assembler provided with val FORTH is a good example of a smart, structured, 
FORTH-based assembler.) On the other hand, since the assembler loads into 
the dictonary one usually sacrifices between 3 and 4K of memory on a utility 
that is only a compilation aid, and is not used during execution. With the 
utility described below, however, you can use the assembler and then remove 
it from the dictionary when you're finished with it. 

In the directory of the Utilities/Editor disk (screen 170) you will find a 
heading of Transients. Loading this screen brings in three words: TRANSIENT, 

PERMANENT, and DISPOSE, and a few variables. It also defines a new area of 
memory called the Transient area. This area is used to load utilities like 
the assembler, certain parts of case statements, and similar constructs, that 
have one characteristic in common: They have compile-time behavior only, and 

are not used at run-time. An example will help make clear the sequence of 
operations. You may recall that on the val FORTH disk, in order to load float- 
ing point words you needed the assembler. Let's make a disk that has floating 
point but no assembler: 

* Boot your val FORTH disk. It can be the bare system, or your normal program- 
ing disk if it doesn't have the assembler already in it. 

* Insert your Utilities/Editor disk, find the Transient section in the 
directory, and load it. 

* Do MTB (EMPTY-BUFFERS) and swap in your val FORTH disk. (It is a VERY good 

idea to get into the habit of doing MTB before swapping disks.) Find the 
assembler in the directory, but before you load it, do TRANSIENT to cause it 

to be loaded into the transient dictionary area, in high memory. Now go ahead 

and load the assembler. When it is loaded, do PERMANENT so that the next 
entries will go into the permanent dictionary area, which is back where you 
started. 

* Now find and load the floating point words. 

* Finally, do DISPOSE to pinch off the links that tie the transient area 

(with the assembler in it) to the permanent dictionary, with the floating 
point words in it. Do a VLIST or two to prove it to yourself. (Note that 
there are about a half-dozen words in the assembler vocabulary in the kernel. 
These were in the dictionary on boot up and are not affected by DISPOSE.) 

You can derive great benefit from the simple recipe above, and if you study 
the Transient code a bit, you may learn even more. We offer several comments: 


) 


X 1 1 1 - 9 


* In the case of the above recipe, you didn't actually have to do PERMANENT 

and TRANSIENT because the assembler source code checks at the front to see if 
TRANSIENT exists, and does it if so. At the end if checks to see if PERMANENT ) 

exists, and does it if so. This conditional execution is accomplished with 

the val FORTH construct 

'( )( ) 

which is described in valFORTH documentation. Take a look at the assembler 
source code to see how this is done. 

* If you want to do assembly on more than one section of code, you needn't 
DISPOSE until you really finished with the assembler; or, if you have DISPOSED 
of the assembler, you can bring it back in later without harm, by the same 
method. You can also code high-level definitions, and then more assembly 
code, and so on, and only do DISPOSE when you were finished. Be sure to do 
DISPOSE before SAVE or AUTO, however, because either your system will crash 

or your SAVE'd or AUTO'd program won't work. 

The situation is slightly different with "case" words, since if you bring 
them in more than once you'll get duplicate names on the run-time words like 
(SEL), (CASE) and CASE:, which uses extra space and defeats the purpose of 
Transients. 

* If you use the Transient structures for otherpurposes, remember only to 
send code that is not used at run-time to the transient area. As an example 
of this distinction, look at the code for the "case" words on the valFORTH 

disk. Note that the '( )( ) construct is again used, but that some of i 

the parts of the case constructs, for instance (SEL), stay in the permanent 
dictionary. That is because (SEL) actually ends up in the compiled code, 
while SEL does not. 

* Look at the beginning of the code for the Transient structures, and notice 
that the Transient area has been set up 4000 bytes below the display list. 

(The byte just below the display list in normal modes is pointed to by memory 
location 741 decimal, courtesy of the Atari OS.) This is usually a good place 
if only the 0 Graphics mode is used. (8 GR. , for example, will over-write 
this area, crashing the system.) After DISPOSE is executed, this area is 
freed for other purposes. If you want to use a different area for Transients, 
just substitute your address into the source code on the appropriate screen. 

Remember that you must leave enough room for whatever will go into the Transient 
dictionary, and that NOTHING else must write to the area until you have cleared 
it out with DISPOSE. (This includes SMOVE, DISKC0PY1, DISKC0PY2, etc.) 

****** NOTE ***** NOTE ***** NOTE ***** NOTE ***** NOTE ****** 

In the above example, 4000 bytes have been set aside for the Transient area 
just below the 0 GR. display list. This amount of memory will generally hold 
the assembler and some case statement compiling words. REMEMBER that if you 
have relocated the buffers (see the section on Relocating Buffers) to this 
area as well, you will have a collision, and a crashed system in short order. 

To cure this, simply locate the Transient area 2113 bytes lower in memory so 

that there will be no overlap. ) 

****** NOTE ***** NOTE ***** NOTE ***** NOTE ***** NOTE ****** 


XIII- 10 


ACKNOWLEDGEMENT 

Various implementations of the Transient concept have appeared. valFORTH 
adopts the names TRANSIENT, PERMANENT, and DISPOSE from a public domain 
article by Phillip Wasson which appeared in FORTH DIMENSIONS volume III no. 6. 
The Transient structure implemented in the article has been altered somewhat 
in the valFORTH implementation to allow DISPOSE to dispose of the entire 
Transient structure, including DISPOSE itself, thus rendering the final 
product perfectly clean. 

FORTH DIMENSIONS is a publication available through FIG (address listed 
elsewhere) and can be a valuable source of information and ideas to the 
advanced FORTH programmer. 


3 


) 


XIII-ll 


o 


o 


) 


EDITOR/UTILITIES SUPPLIED SOURCE 


Screen : 36 

, 0 ( Transients: setup 

I 1 BOSE @ DCX 
E 

3 HERE 

4 


Screen : 39 

0 
1 


4 


6 741 0 4000 - DP ! 6 

7 ( SUGGESTED PLACEMENT OF TAREA ) 7 

8 8 

9 9 

10 HERE CONSTANT TAREA 10 

11 0 VARIABLE TP 11 

IE 1 VARIABLE TPFLAG IE 

13 VARIABLE OLDDP 13 

14 14 

15 ==> 15 


Screen : 37 Screen : 

0 ( Xsients: TRANSIENT PERMANENT ) 0 

1 1 

£ : TRANSIENT < — ) £ 

3 TPFLAG S NOT 3 

4 IF HERE OLDDP ! TP @ DP ! 4 

5 1 TPFLAG ! 5 

) 6 END IF ; 6 

7 7 

8 : PERMANENT ( — ) 8 

9 TPFLAG @ 9 

10 IF HERE TP ! OLDDP 0 DP ! 10 

11 0 TPFLAG ! 11 

IE END IF ; IE 

13 13 

14 14 

15 --> 15 


40 


Screen: 38 

0 ( Transients: DISPOSE ) 

1 : DISPOSE PERMANENT 

E CR . " Disposing..." VOC-LINK 

3 BEGIN DUP 0 53E79 C! 

4 BEGIN ® DUP TAREA U< 

5 UNTIL DUP ROT ! DUP 0= 

6 UNTIL DROP VOC-LINK 0 

7 BEGIN DUP 4 - 

8 BEGIN DUP 0 53E79 C! 

9 BEGIN PFA LFA 0 DUP TAREA U< 

10 UNTIL 

\ 11 DUP ROT PFA LFA ! DUP 0= 

IE UNTIL DROP 0 DUP 0= 

13 UNTIL DROP [COMPILE] FORTH 

14 DEFINITIONS . " Done" CR ; 

15 PERMANENT BASE ! 


Screen: 41 

0 
1 
E 

3 

4 

5 

6 

7 

8 
9 

10 

11 

IE 

13 

14 

15 


XC! X ! 


Screen : 42 

0 ( Utils: CARRAY ARRAY ) 

1 BASE 0 HEX 

£ : CARRAY < cccc, n — ) 


3 

CREATE SMUDGE 

( cccc: n — a ) 

4 

ALLOT 




5 

; CODE CA C, 

CA 

c, 

18 C, 

6 

A5 C, W C, 

69 

c, 

02 C, 95 C, 

7 

00 C, 98 C, 

65 

c, 

W 1+ C, 

8 

95 C, 01 C, 

4C 

C, 


9 

» + < CFA 0 

) 

, C 

5 


10 

11 : ARRAY ( cccc, n — ) 

12 CREATE SMUDGE ( cccc: n — a ) 

13 2* ALLOT 

14 ; CODE 16 C, 00 C, 36 C, 01 C, 

15 4C C, ’ CARRAY 08 + , C; ==> 


Screen: 45 

0 ( Utils: 

1 

£ : XC! < n0. . . nm cnt addr — ) 

3 OVER 1- + >R 0 

4 DO J I - C! 

5 LOOP R> DROP ; 

6 

7 : X ! ( n0. . . nrn cnt addr — ) 

8 OVER 1- 2* + >R 0 

9 DO J I 2* - ! 

10 LOOP R> DROP ; 

11 

12 ( Caution: Remember limitation 

13 < on stack size of 30 values 

14 ( because of OS conflict. ) 

15 — > 


) 


Screen: 43 

0 ( Utils: CTABLE TABLE ) 

1 

£ : CTABLE ( cccc, — > 

3 CREATE SMUDGE ( cccc: n — a ) 

4 ; CODE 

5 4C C, ’ CARRAY 08 + , C; 

6 

7 : TABLE < cccc, — ) 

8 CREATE SMUDGE ( cccc: n — a ) 

9 ; CODE 

10 4C C, ’ ARRAY 0A + , C; 

11 
12 

13 

14 

15 — > 


Screen : 46 

0 ( Utils: CVECTOR VECTOR ) 

1 

£ : CVECTOR ( cccc, 

3 CREATE SMUDGE < cccc: 

4 HERE OVER ALLOT XC ! 

5 5 CODE 

6 4C C, ’ CARRAY 08 + , 

7 

8 : VECTOR < cccc, 

9 CREATE SMUDGE < cccc: 

10 HERE OVER 2* ALLOT X! 

11 5 CODE 

12 4C C, » ARRAY 0A + , 

13 

14 

15 BASE ! 


cnt — ) 
n — a ) 

C; O 

cnt — ) 
n — a ) 

C; 


Screen : 44 

0 < Utils: 2CARRAY 2ARRAY ) 

1 

2 : 2CARRAY < cccc, n n — ) 

3 <BUILDS ( cccc: n n — a ) 

4 SWAP DUP , * ALLOT 

5 DOES) 

6 DUP >R 0 * + R> +2+ ; 

7 

8 : 2ARRAY ( cccc, n n — ) 

9 <BUILDS ( cccc: n n — a ) 

10 SWAP DUP , * 2* ALLOT 

1 1 DOES) 

12 DUP > R 0 * + 2# R> +2+ ; 

13 

14 

15 ==> 


Screen: 47 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


) 


Screen: 48 


Screen: 51 



0 

( 

Utils: HIDCHR NDKEY 

CURSOR) 

0 

< 

Utils: Y/N -RETURN 

RETURN 

) 

1 

BASE ® DCX 


1 





£ 




2 

s 

Y/N 

( — f 

) 

3 

1 

( CASE ) ( £8 KLOAD ) 


3 


. “ <Y/N> " -Y/N DUP 



4 




4 


IF 89 ELSE 78 END IF 



5 

: 

HIDCHR 

( — ) 

5 


EMIT SPACE ; 



6 


65535 94 ! ; 


6 





7 




7 

s 

-RETURN 

< — 

) 

8 

: 

NDKEY 

( — ) 

a 


BEGIN KEY 155 = UNTIL 

5 


9 


£55 764 C! ; ) 


9 





10 




10 

: 

RETURN 

< — 

) 

11 

: 

CURSOR 

< f — ) 

u 


. " < RETURN) " -RETURN 

5 


1£ 


0= 75E C! 


1£ 





13 


£8 EMIT £9 EMIT ; 


13 





14 




14 





15 



==> 

15 


BASE ! 



Screen: 49 






Screen : 5£ 






0 

( Utils: 

INKEY* 



) 

0 

( Screen code 

conversion 

words ) 

1 

DCX 






1 







£ 

: (INKEY*) 



< 

c 

) 

p 

BASE ® HEX 






3 

70£ C! NOKEY ; 




3 







4 







4 

CODE > BSCD 




( a a 

n — ) 

5 

: INKEY* 



( 

— 

- c ) 

5 

A9 C, 03 

c, 

£0 

c, 

SETUP 

* 

6 

764 C® 






6 

HERE C4 

c, 

C£ 

c. 

D0 C, 

07 C, 

7 

COND 






7 

C6 C, C3 

c, 

10 

c, 

03 C, 

4C C. 

a 

£5£ = 

< ( 

1£8 

(INKEY*) 

0 

> > 

8 

NEXT , 


B1 

C, 

C6 C, 

48 C, 

9 

191 > 

< < 

0 >> 




9 

£9 C, 7F 

C, 

C9 

C, 

60 C, 

B0 C, 

10 

188 = 

< < 

0 >> 




10 

0D C, C9 

C, 

£0 

C, 

B0 C, 

06 C, 

n 

1£4 = 

< < 

64 

(INKEY*) 

0 

> > 

11 

18 C, 69 

C, 

40 

C, 

4C C, 

HERE 

1£ 

60 = 

< < 

0 

(INKEY*) 

0 

> > 

1£ 

£ ALLOT 38 

C, 

E9 

C, 

£0 C, 

HERE 

13 

39 = 

< < 

0 >> 




13 

SWAP ! 91 

C, 

C4 

C, 

68 C, 

£9 C, 

14 

NOCOND KEY 





14 







15 

CONDEND 

5 




— > 

15 






==> 


Screen : 50 



Screen : 53 






0 ( 

Utils: -Y/N 


) 

0 

1 

( Screen code 

conversion 

words ) 

1 

£ : 

-Y/N 


( — f ) 

1 

p 

80 C, 11 

c, 

C4 

c, 

91 C, 

C4 C, 

3 

BEGIN KEY 



Lj 

C8 C, D0 

c, 

D3 

C, 

E6 C, 

C7 C, 

4 

COND 



4 

E6 C, C5 

c, 

4C 

C, 

9 

c ; 

5 

89 = << 1 1 

> > 


5 







6 

78 = <<01 

>> 


6 

CODE BSCD) 




< a a 

n — > 

7 

NOCOND 



7 

A9 C, 03 

c, 

£0 

C, 

SETUP 


8 

0 



8 

HERE C4 

c, 

C£ 

C, 

D0 C, 

07 C, 

9 

CONDEND 



9 

C6 C, C3 

c, 

10 

C, 

03 C, 

4C C, 

10 

UNTIL ; 



10 

NEXT , 


B1 

c, 

C6 C, 

48 C, 

11 




11 

£9 C, 7F 

c, 

C9 

C, 

60 C, 

B0 C, 

IS 




1£ 

0D C, C9 

c, 

40 

C, 

B0 C, 

06 C, 

13 




13 

18 C, 69 

c, 

£0 

C, 

4C C, 

HERE 

14 




14 

£ ALLOT 38 

c, 

E9 

C, 

40 C, 

HERE 

15 



==> 

15 






— > 


conversion words ) 


Screen: 54 

0 < Screen code 

1 


2 

SWAP ! 91 C, 

C4 C, 

68 C, 

29 

C, 

3 

80 C, 11 C, 

C4 C, 

91 C, 

C4 

c, 

4 

C 8 C, D0 C, 

D3 C, 

E 6 C, 

C7 

c, 

5 

E 6 C, C5 C, 

4C C, 

» 



6 






7 






8 

: > SCD SP@ DUP 1 > BSCD ; 



9 

: SCD> SP© DUP 1 BSCD) 5 




10 

11 

12 

13 

14 

15 BASE ! 


Screen: 57 

0 < Case statements: COSE 

1 


o 


2 : CASEND 

3 DUP 6 = 

4 IF 

5 DROP COMPILE NOOP 

6 ELSE 

7 7 7PAIRS 

8 END IF 

9 HERE 2- © OVER 1+ ! 

10 HERE OVER - 

11 5-2/ SWOP C! ; IMMEDIATE 

12 

13 M PERMANENT PERMANENT ) < ) 


14 

15 — > 


Screen : 55 

0 
1 
C 

3 

4 

5 

6 
7 
6 
9 

10 

11 

12 

13 

14 

15 


Screen : 58 

0 < Case statements: SEL 

1 

2 ’ ( PERMANENT PERMANENT ) ( ) 

3 : (SEL) 

4 R 1+ DUP 2+ DUP R C© 

5 2* 2* + R> DROP DUP >R SWAP 

6 DO I 0 3 PICK = 

7 IF I 2+ SWAP DROP LEAVE 

8 END IF 

9 4 /LOOP SWAP DROP ©EX ; 

10 

11 M TRANSIENT TRANSIENT )< ) 

12 : SEL 7COMP 

13 7L0ADING COMPILE (SEL) HERE 

14 0 C, COMPILE NOOP [COMPILE] 

15 8 ; IMMEDIATE 


) 


o 


C 


Screen : 56 

0 < Case Statements: CASE ) 

1 BASE © DCX 

£ ’ ( PERMANENT PERMANENT ) ( ) 

3 : (CASE) 

4 R C@ MIN -1 MAX 2* 

5 R 3 + + ©EX 

6 R C@ 2* 5 + R> + > R ; 

7 ’ ( TRANSIENT TRANSIENT ) ( ) 

8 : CASE 

9 7COMP COMPILE (CASE) 

10 HERE 0 C, 

11 COMPILE NOOP 6 ; IMMEDIATE 

12 

13 : NOCASE 

14 6 7PAIRS 7 ; IMMEDIATE 

15 ==> 


Screen: 59 

0 ( Case statements: SEL ) 

1 

2 : NOSEL 

3 8 7PAIRS [COMPILE] ’ CFA 

4 OVER 1+ ! 8 ; IMMEDIATE 

5 

6 : -> 

7 SWAP 8 7PAIRS , DUP C© 1+ 

8 OVER C! [COMPILE! » 

9 CFA , 8 ; IMMEDIATE 

10 

11 : SELEND ) 

12 8 7PAIRS 

13 DROP [COMPILE] ] 5 IMMEDIATE 

14 ’ ( PERMANENT PERMANENT ) ( ) 

15 


— > 


Screen: 60 

0 < Case statements: CDND ) 

1 ’ ( TRANSIENT TRANSIENT > ( ) 

2 : COND 

3 0 COMPILE DUP ; IMMEDIATE 

4 

5 : < < 

6 1+ [COMPILE! IF 

7 COMPILE DROP ; IMMEDIATE 

8 

9 : >> 

10 [COMPILE! ELSE COMPILE 

11 DUP ROT ; IMMEDIATE 

12 

13 : NOCOND 

14 COMPILE 2DR0P ; IMMEDIATE 

15 M PERMANENT PERMANENT ) < ) ==> 


Screen : 63 

0 
1 
d 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 61 

0 < Case statements: COND ) 

1 

2 ’ < TRANSIENT TRANSIENT ) ( ) 

3 

4 : CONDEND 

X 5 0 DO 

LJ 6 [COMPILE! END IF 

7 LOOP ; IMMEDIATE 

8 

9 ’ ( PERMANENT PERMANENT ) < ) 

10 

11 

12 

13 

14 

15 --> 


Screen: 64 

0 ( ValFORTH Video editor 

1 

2 BASE C- DCX 


4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


( XC! ) ( 21 KLOAD ) 

( HIDCHR ) ( 24 KLOAD > 
( > BSCD ) < 26 KLOAD ) 


Screen : 


J> 


0 

1 

2 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


( Case statements: CASE: 

: CASE: 

(BUILDS 

SMUDSE ! CSP 
[COMPILE! ! 

DOES) 

SWAP 2* + 0EX : 


BASE 


Screen : 65 

0 ( ValFORTH Video editor 

1 
d 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


VI. 1 ) 




VI. 1 ) 


VI. 1 ) 


Screen : 66 

0 ( ValFORTH Video editor 

1 

£ VOCABULARY EDITOR IMMEDIATE 

3 EDITOR DEFINITIONS 

4 


5 

0 

VARIABLE 

XLOC 

< 

X coord . 

> 

6 

0 

VARIABLE 

YLOC 

< 

Y coord. 

) 

7 

0 

VARIABLE 

INSRT 

< 

insert on? 

> 

a 

0 

VARIABLE 

LSTCHR 

< 

last key 

) 

9 

0 

VARIABLE 

7BUFSM 

< 

buf same? 

) 

10 

0 

VARIABLE 

7PADSM 

( 

PAD same? 

) 

1 1 

0 

VARIABLE 

?ESC 

( 

coded char 

?) 

12 

0 

VARIABLE 

TBLK 

( 

top block 

> 


13 

14 

15 ==> 


Screen : S7 

0 ( ValFORTH Video editor VI. 1 ) 

1 

£ 0 VARIABLE LNFLG ( oops flag ) 

3 4 ARRAY UPSTAT ( update map ) 

4 15 CONSTANT 15 

5 3£ CONSTANT 3£ 

6 1£8 CONSTANT l£fl 

7 5 3£ * CONSTANT BLEN 

a 

9 : LMOVE 32 CMOVE ; 

10 : BOL 08 © YLOC 0 1 + 32 * + ; 

1 1 : SBL 88 0 544 + ; 

12 ! PBL PAD 544 + ; 

13 s PBLL PBL BLEN + 32 - ; 

14 : ! SCR 88 © 32 + PAD 512 BSCD) ; 

15 — > 


Screen : 69 

0 ( ValFORTH Video editor 

1 

2 : UPCUR 

3 CBLANK YLOC 0 

4 1 - DUP 0 < 

5 IF DROP 15 ENDIF 

6 YLOC ! CSHOW ; 

7 

8 

9 : DNCUR 

10 CBLANK YLOC 0 

11 1 + DUP 15 > 

12 IF DROP 0 ENDIF 

13 YLOC ! CSHOW ; 

14 

15 


Screen: 7© 

0 ( ValFORTH Video editor VI. 1 ) 

1 

2 : LFCUR ( — ) 

3 CBLANK XLOC 0 

4 1 - DUP 0 < 

5 IF DROP 31 ENDIF 

6 XLOC ! CSHOW ; 

7 

8 : RTCUR 

9 CBLANK XLOC 0 

1© 1+ DUP 31 > 

11 IF DROP 0 ENDIF 

12 XLOC ! CSHOW ; 

13 

14 : EDMRK 

15 1 YLOC 04/ UPSTAT ! ; ==> 


VI. 1 • ') 
( — ) 


< — ) 


— > 


< AT L-SIDE?) 

< FIX IF SO >- x 

o 

( — ) 

( AT R-SIDE?) 

( FIX IF SO ) 


Screen: 68 

0 ( ValFORTH Video editor VI. 1 ) 


1 

£ : CURLOC 

3 BOL XLOC 0 

4 

5 : CSHOW 

6 CURLOC DUP 

7 C0 128 DR 

8 SWAP C! ; 

3 

1© : CBLANK 

1 1 CURLOC DUP 

12 C© 127 AND 

13 SWAP C! ; 

14 

15 


( — ) 

; ( SCR ADDR ) 

( — ) 
( GET SCR ADDR ) 
( INVERSE CHAR ) 
( STORE ON SCR ) 

( — ) 

( GET SCR ADDR ) 

( STRIP MSB ) 

( STORE IT ) 


Screen: 71 

0 ( ValFORTH Video editor VI. 1 ) 

1 

£ : INTGL ( — ) 

3 INSRT 0 ©= ( TOGGLE THE > 

4 INSRT ! ; ( INSRT FLAG ) 

cr 


6 : NXTLN 

7 CBLANK 0 XLOC ! 

8 CSHOW DNCUR ; 

9 

10 : CLREOL 

1 1 CBLANK ! SCR 

12 1 LNFLG ! CURLOC 

13 32 XLOC 0 - 

14 ERASE CSHOW 

15 EDMRK ; 


( — ) 


( — ) 

( CLEAR ) 
( TO END ) 
( OF LINE) 
— > 


Screen: 72 

0 ( ValFORTH Video editor VI. 1 ) 


Screen: 75 

0 < ValFORTH Video editor 


VI. 1 ) 


£ : 

HMCUR 

( — ) 

£ : 

LNDEL 


< — 

) 

«J 

CBLANK 0 XLOC ! 


3 

CBLANK 3 LNFLG ! ! SCR 




4 

0 YLOC ! CSHOW 5 


4 

4 YLOC 04/ 




5 



5 

DO 1 I UPSTAT 1 LOOP 




6 : 

BYTINS CBLANK 

( — ) 

6 

YLOC 0 15 < 




7 

XLOC 0 31 < 

( SPREAD LN ) 

7 

IF BOL 

( 

FROM 

) 

B 

IF 


B 

DUP 3£ + SWAP 

< 

TO 

) 

9 

CURLOC DUP 1+ 

( FROM, TO ) 

9 

15 YLOC 0 - 32 * 

( 

# CH 

) 

10 

31 XLOC 0 - 

( # CHARS ) 

10 

CMOVE 




11 

(CMOVE 

< MOVE IT ) 

11 

END IF 




12 

END IF 


1 £ 

BOL 15 YLOC 0 - 




13 

0 CURLOC C! 

< CLEAR OLD ) 

13 

3£ * + 3£ ERASE 




14 

CSHOW EDMRK ; 

( CHARACTER ) 

14 

CSHOW EDMRK ; 




15 


==> 

15 



— 

■> 


Screen: 73 



Screen: 76 




0 ( 

ValFORTH Video editor VI. 1 

) 

0 

1 

< 

ValFORTH Video editor 


VI. 1 

) 

1 

£ : 

BYTDEL 

( — 

) 

1 

£ 

• 

BFSHW 


< — 

> 

3 

CBLANK 

( CLOSE LINE) 

3 


PBLL 128 - < 

F 

, T 

) 

4 

XLOC 0 31 < 



4 


SBL 160 CMOVE ; ( 

# 

MOVE 

) 

5 

IF 



5 






6 

CURLOC DUP 

( FROM ADDR 

) 

6 

: 

BFROT 


( — 

) 

7 

1+ SWAP 

< TO ADDR ) 


7 


PBL DUP 




8 

31 XLOC 0 - 

( # CHARS ) 


8 


BLEN + LMOVE 




9 

CMOVE 

< MOVE IT ) 


9 


PBL DUP 32 + 




10 

ENDIF 



10 


SWAP BLEN 32 - 




11 

0 CURLOC 

( BLANK OUT 

) 

11 


CMOVE PBLL 32 + 




12 

31 XLOC 0 - + C! 

( CHAR AT ) 


12 


PBLL LMOVE 




13 

CSHOW EDMRK ; 

< END OF LN 

) 

13 


BFSHW 5 




14 




14 






15 


— 

■> 

15 




== 

■> 


Screen: 74 


Screen: 77 


0 ( 
1 

£ : 

ValFORTH Video editor 

VI. 1 ) 

0 < 

1 

ValFORTH Video editor 

VI. 1 ) 

LNINS 

( — ) 

1 

£ : 

<BFROT 

( — ) 

3 

CBLANK £ LNFLG ! !SCR 


3 

PBLL DUP 


4 

4 YLOC 04/ 


4 

32 + LMOVE 


5 

DO 1 I UPSTAT ! LOOP 


5 

PBL DUP 32 + 


6 

YLOC 0 15 < 


6 

BLEN 32 - (CMOVE 


7 

IF 


7 

PBL DUP BLEN + 


8 

BOL DUP 32 + 


8 

SWAP LMOVE 


9 

15 YLOC 0 - 32 * 


9 

BFSHW ; 


10 

<CMOVE 


10 



11 

ENDIF 


11 : 

BFCLR 

( — ) 

12 

BOL 32 ERASE 


12 

PBLL 32 ERASE 


13 

CSHOW EDMRK ; 


13 

(BFROT ; 


14 



14 



15 


==> 

15 


--> 


Screen: 78 Screen: 81 


0 

1 

( ValFORTH Video 

editor VI . 1 ) 

0 

1 

o 

( ValFORTH Video 

editor VI. 1 

J. 

£ 

: BFCPY 

( — ) 

: ARROW 


( — 

3 

CBLANK BFROT 

( BRING LN > 

3 

CBLANK 



4 

BOL PBLL 

( DOWN TO ) 

4 

88 0 541 + DUP 

0 


5 

LMOVE BFSHW 

( BUFFER & ) 

5 

COND 



6 

CSHOW ; 

< ROTATE ) 

6 

3341 = << 30 

7453 

> > 

7 



7 

7453 = << 00 

0000 

> > 

8 

: > BFNXT BFCPY NXTLN ; ( — ) 

8 

NOCOND 



9 



9 

30 3341 



10 

: > BFLN BFCPY LNDEL ; ( -- ) 

10 

CONDEND 



11 



11 

3 PICK ! 



i£ 

: BFLN) 

( — ) 

1£ 

SWAP £+ C! 



13 

LNINS PBLL 

( TAKE LINE) 

13 

1 3 UPSTAT ! 



14 

BOL LMOVE 

< UP FROM ) 

14 

CSHOW ; 



15 

CSHOW <BFROT ; 

( BUFFER ) ==> 

1 5 



— 


Screen: 79 

® ( ValFORTH Video editor VI. 1 ) 
1 


£ : 

BFRPL 


< — 

) 

3 

CBLANK 




4 

! SCR 4 LNFLG ! ( 

TAKE LINE 

) 

5 

PBLL BOL LMOVE ( 

UP 

TO SCR 

) 

6 

<BFROT CSHOW < 

& 

ROTATE 

) 

7 

EDMRK ; 




8 





9 : 

TAB 


( — 

) 

10 

CBLANK XLOC 0 DUP 




11 

31 = IF DROP -1 ENDIF 



1£ 

4 + 4 / 4 * DUP 30 

> 



13 

IF DROP 31 ENDIF 




14 

XLOC ! CSHOW ; 




15 



— 

•> 


Screen : 8£ 

0 ( ValFORTH Video editor VI. 1 ) 

1 


4 

5 

6 

7 

8 
9 

10 

11 

1£ 

13 

14 

15 


OOPS ( 

LNFLG 0 
IF 

CBLANK 

PAD 88 0 3E + 51£ ) BSCD 
CSHOW 
0 LNFLG ! 

END IF ; 


o 




Screen : 80 

0 ( ValFORTH Video editor VI. 1 ) 

1 

£ : RUB ( — ) 

3 XLOC 0 0= NOT < ON L-EDGE? ) 

4 IF 

5 LFCUR ( RUB IF NOT ) 

6 0 CURLOC C! 

7 CSHOW EDMRK 

8 ENDIF 

9 INSRT 0 

10 IF 

1 1 BYTDEL 
1£ ENDIF ; 

13 

14 

15 ==> 


Screen: 83 

0 ( ValFORTH Video editor VI. 1 ) 

1 

£ : SPLIT ( — ) 

3 YLOC 0 15 <> 

4 IF 

5 CBLANK 

6 LNINS 

7 BOL DUP 3£ + SWAP 

8 XLOC 0 CMOVE 

9 BOL 3£ + 

10 XLOC 0 ERASE 

11 CSHOW ( J 

1£ ENDIF ; 

13 

14 

15 


> 


Screen: 84 Screen: 07 


0 

< ValFORTH Video editor 

VI. 1 ) 

0 

( 

ValFORTH Video editor 

VI. 1 

) 

1 



1 





£ 

: SCRSV 

( — ) 

£ 

: 

PRVSCR -1 NWSCR ; 

< — 

) 

u 

88 0 3£ + PAD 51 £ BSCD> 


3 





4 

4 0 


4 

: 

NXTSCR 1 NWSCR ; 

( — 

) 

5 

DO 


5 





8 

I UPSTAT 0 


6 

: 

SPLCHR 1 ?ESC ! ; 

< — 

) 

7 

0 I UPSTAT ! 


7 





8 

IF 


8 

; 

EXIT 

( — 

) 

9 

PAD 1£8 I * + 


9 


HMCUR 19 LSTCHR ! ; 



10 

TBLK 0 I + BLOCK 


10 





11 

1£8 CMOVE UPDATE 


11 

: 

EDTABT 

( — 

) 

1£ 

ENDIF 


1£ 


0 UPSTAT 8 ERASE 



13 

LOOP 


13 


EXIT ; 



14 

0 INSRT ! 


14 





1 5 

0 XLOC ! 0 YLOC ! ; 

==> 

15 



— 

-> 


Screen: 85 


Screer 

>: 08 



0 ( 

ValFORTH Video editor 

VI. 1 ) 

0 ( 

ValFORTH Video editor 

VI. 1 > 

1 

c! 5 

SCRGT 

( — ) 

i 

£ : 

PTCHR 


( — ) 

3 

4 0 


3 

INSRT 0 EDMRK 



4 

DO 


4 

IF BYTINS ENDIF 



5 

TBLK Li 


5 

LSTCHR 0 1£7 AND 



6 

I + BLOCK 


6 

DUP LSTCHR ! 



7 

PAD 1£8 I * + 


7 

> SCD CURLOC C! 



8 

1£8 CMOVE 


8 

RTCUR XLOC @ 0= 



9 

LOOP 


9 

IF DNCUR ENDIF 



10 

PAD 88 0 3£ + 


10 

0 ?ESC ! CSHOW ; 



11 

51E > BSCD ; 


11 




IE 



1£ : 

CONTROL 


( ri — ) 

13 



13 

SEL 19 -> EXIT 

17 - 

> EDTABT 

14 



14 

£8 -> UPCUR 

£9 - 

> DNCUR 

15 


— > 

15 



==> 


Screen : 86 

0 < ValFORTH Video editor VI. 1 ) 

1 

£ : NUISCR ( -1/0/1 — ) 

3 CBLANK DUP 

4 IF SCRSV END IF £* £* 

5 TBLK 0 + 0 MAX TBLK ! SCRGT 

6 TBLK ® 8 /MOD 

7 DUP <ROT SCR ! 

8 IF 44 ELSE 53 END IF 

9 ?1K NOT 

10 IF 

11 44 = SWOP £* + DUP SCR * 0 

1 £ END IF 

13 88 0 17 + C! 

14 0 84 C! 11 85 ! 1 75£ C! 

15 . £ SPACES CSHOW ; ==> 


Screen : 89 

0 ( ValFORTH Video editor VI. 1 ) 

1 


2 

30 -> 

LFCUR 

31 -> 

RTCUR 

3 

1£6 -> 

RUB 

1£7 -> 

TAB 

4 

9 -> 

INTGL 

155 -> 

NXTLN 

5 

£55 -> 

BYTINS 

£54 -> 

BYTDEL.. 

6 

157 -> 

LNINS 

156 -> 

LNDEL 

7 

18 -> 

BFROT 

£ -> 

<BFROT 

8 

3 -> 

BFCLR 

11 -> 

> BFNXT 

9 

£0 -> 

> BFLN 

6 -> 

BFLN> 

10 

16 -> 

PRVSCR 

14 -> 

NXTSCR 

1 1 

£7 -> 

SPLCHR 

8 -> 

CLREOL. 

1£ 

1 -> 

ARROW 

£1 -> 

BFRPL 

13 

15 -> 

OOPS 

10 -> 

SPLIT 

14 

NOSEL PTCHR 



15 

SELEND ; 



— > 


VI. 1 


Screen : 90 

0 < ValFORTH Video editor VI. 1 ) 

1 

£ : (V) ( TBLK — ) 

3 DECIMAL 

4 DUP BLOCK DROP TBLK ! 

5 1 PFLAG ! 0 GR. 1 75£ C! CLS 

6 1 559 C0 £5£ AND OR 559 C! 

7 US 560 0 6 + C! 

8 112 560 0 £3 + C! 

9 Screen #” 1 1 . SPACES 

10 . " #Bufs: " BLEN 3£ / . HIDCHR 

11 0 UPSTAT 8 ERASE 0 NWSCR 

1£ PAD 7PADSM 0 OVER 7PADSM ! = 

13 PBL 0 7BUFSM 0 = AND NOT 

1 A IF PBL BLEN ERASE ENDIF 
15 ==> 


Screen: 91 

0 < ValFORTH Video editor VI. 1 ) 

1 BFSHW 
£ BEGIN 

3 INKEY$ DUP LSTCHR ! -DUP 

4 IF 

5 7 ESC 0 

6 IF DROP PTCHR 0 LSTCHR ! 

7 ELSE CONTROL ENDIF 

8 ELSE 

9 INSRT 0 

10 IF 

1 1 CBLPNK CSHOW 

1£ ENDIF 

13 ENDIF 

14 LSTCHR 0 19 = 

15 UNTIL — > 


Screeri: 9£ 


0 

1 

( ValFORTH Video 

edit or 

VI. 1 

) 

1 

2 

CBLANK SCRSV 0 

767 C! 



3 

£ 560 0 6 + C! 




4 

£ 560 0 £3 + C! 




5 

PBL 0 7BUFSM ! 




6 

£ 559 C0 £5£ AND OR 559 

C! 


7 

0 LNFLG ! 0 75£ 

C! CLS 

CR 


8 

. " Last edit on 

screen 

# " 


9 

SCR 0 . CR CR 0 

INSRT ! 

5 


10 





11 

FORTH DEFINITIONS 




12 





13 

: V 

( 

5 

) 

14 

1 MAX B/SCR * 




15 

EDITOR (V) ; 


== 

: ) 


Screen: 93 

0 ( ValFORTH Video editor 

1 

£ : L ( — ) 

3 SCR 0 DUP 1 + 

4 B/SCR * SWAP B/SCR * 

5 EDITOR TBLK 0 DUP <ROT 

6 <= <ROT > AND 

7 IF 

8 EDITOR TBLK 0 

9 ELSE 

10 SCR 0 B/SCR * 

11 ENDIF 

1£ EDITOR (V) ; 

13 

14 

15 — > 


Screen: 94 

0 ( ValFORTH Video editor VI. 1 ) 

1 

£ : CLEAR ( s — ) 

3 B/SCR * B/SCR O+S 

4 DO 

5 FORTH I BLOCK 

6 B/BUF BLANKS UPDATE 

7 LOOP ; 

8 

9 : COPY ( si s£ — ) 

10 B/SCR * OFFSET 0 + 

11 SWAP B/SCR * B/SCR O+S 

1£ DO DUP FORTH I 

13 BLOCK 2- ! 

14 1+ UPDATE 

15 LOOP DROP ( FLUSH > ; ==> 


Screen : 95 

0 ( ValFORTH Video editor VI. 1 ) 

1 

£ : CLEARS ( s # — ) 

3 OVER > R O+S 

4 2DUP CR 

5 . " Clear from SCR " . CR 

6 . " thru SCR " 1 - . Y/N 

7 IF 

8 DO 

9 FORTH I CLEAR 

10 LOOP 

1 1 ELSE 

12 2DR0P 

13 ENDIF 

14 R> SCR ! FLUSH ; 

15 — > 


99 


Screen: 96 

0 < ValFORTH Video editor VI. 1 ) 

1 

£ : WHERE EDITOR < n n ) 

3 OVER OVER 

4 DUP 65532 AND 

5 SWAP OVER - 128 * 

6 ROT + 32 /MOD 

7 YLOC C! 

8 2-0 MAX XLOC C! 

9 1 INSRT ! 

10 EDITOR (V) ; 

11 

12 : #BUFS < # — > 

13 5 MAX 320 MIN 32 * EDITOR 

14 ’ BLEN 1 0 ?PADSM ! ; 

15 ==> 


Screen : 
0 
1 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 97 Screen: 

0 < ValFORTH Video editor VI. 1 ) 0 

1 1 

2 : (LOC) < sys ) 2 

3 BLK @ , IN @ C, 5 3 

4 4 

5 : LOCATOR ( f ) 5 

6 IF 6 

7 C ’ (LOC) CFA I LITERAL 7 

8 ELSE S 

9 [ ’ NOOP CFA 1 LITERAL 9 

10 END IF 1® 

11 ’ CREATE ! ; 11 

12 12 

13 13 

14 1* 


Screen : 98 

0 ( ValFORTH Video editor VI. 1 

1 

£ : LOCATE 

3 CCOMPILEI ’ DUP NFA 1- DUP 

4 2- is DUP 1439 U < SWAP 0# AND 

5 IF 

6 SWAP DROP DUP C@ 

7 SWAP 2- 8 WHERE 2DR0P 

8 ELSE 

9 CR . " Cannot locate" 

10 » ( DCMPR DROP DCMPR 

11 ) ( 2DR0P CR ) 

12 END IF ; 

13 

14 

15 BASE ! 


Screen : 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

1 5 


100 


101 


Screen : 102 
0 
1 


Screen: 105 
0 
1 


1 


4 

5 
S 
7 
B 
3 

10 
1 1 
12 

13 

14 

15 


3 

4 

5 

6 

7 

8 
3 

10 
1 1 
12 

13 

14 

15 


Screen: 103 
0 
1 
2 
3 


Screen: 106 

0 ( Hi -resol ut ion text printing ) 

1 

2 BOSE @ DCX 

3 


4 

4 

1 ( > SCD ) ( 26 1 

KLOAD 

5 

c: 

5 

C 

’ ( COND ) ( 28 1 

KLOAD 

t> 

7 

D 

7 

57344 

VARIABLE 

GCBAS 

8 

a 

0 

VARIABLE 

GCPTR 

9 

9 

d 

VARIABLE 

GCLFT 

10 

10 

39 

VARIABLE 

GCRGT 

1 1 

u 

0 

VARIABLE 

GMOD 

12 

12 

0 

VARIABLE 

GCCDL 

13 

13 

0 

VARIABLE 

GCROW 

14 

14 

120 

VARIABLE 

VMI# 

1 5 

15 





o 




Screen: 104 Screen: 107 


0 

0 

( Hi-res: GCR ) 

1 

1 


2 

d 

: GCR < — ) 

3 

3 

1 GCROW 0 + DUP 20 

4 

4 

703 C@ MAX < 

5 

5 

IF GCROW ! 

6 

6 

ELSE 

7 

7 

DROP 88 @ 320 O+S 

8 

a 

703 CC" 4 = 

9 

9 

IF 6400 ELSE 7680 END IF 2DUP 

10 

10 

+ 320 - > R CMOVE 

1 1 

u 

R> 320 ERASE 

12 

12 

END IF 

13 

13 

GCROW 0 320 * 

14 

14 

GCLFT @ DUP GCCOL ! 

15 

15 

+ GCPTR ! ; — > 


CGCEMITI 


1 


o 


Screen: 108 

0 ( Hi -rei 

1 

£ : (GCEMIT) < c — > 

3 > SCD 8 * GCBAS @ + 

4 GCPTR & 88 0 + 3£0 0+S 

5 DO 

6 DUP C0 GMOD C0 

7 IF I C0 OR END IF 

8 I C! 1 + 


9 

40 /LOOP 


10 

DROP 1 GCPTR + ! 


1 1 

1 GCCOL @ + DUP GCRGT 0 

a > 

12 

IF DROP GCR 


13 

ELSE GCCOL ! 


14 

ENDIF ; 


15 


==> 


Screen: 109 



0 ( 
4 

Hi -res: GCBKS 

OSTRIKE GCINIT) 

1 

GCBKS 


< — > 

3 

GCCOL § GCLFT 0 

> 


4 

IF 



5 

-1 GCCOL +! 


( backspace ) 

6 

-1 GCPTR + ! 



7 

ENDIF ; 



a 




9 : 

OSTRIKE 


< f — ) 

10 

GMOD ! ; 


< overstrike) 

11 




12 : 

GCINIT 


< — ) 

13 

0 GCROW ! GCLFT 


DUP 

14 

GCCOL ! GCPTR ! 




15 --> 


Screen : 111 



0 ( 

Hi -res: GCEMIT 

GCTYPE 

) 

1 

2 : 

GCEMIT 

( chr - 

-- ) 

3 

DUP 



4 

COND 



5 

£8 = < ( DROP 

SUPER >> 


6 

29 = ( < DROP 

SUB > > 


7 

30 = < < DROP 

GCBKS >> 


8 

NOCOND (GCEMIT) 



9 

CONDEND ; 



10 




11 : 

GCTYPE < 

adr count - 

— ) 

12 

0 MAX -DUP 



13 

IF O+S DO I ce 

GCEMIT LOOP 


14 

ELSE DROP 



15 

ENDIF ; 


— > 


Screer 

112 


0 < 

Hi -res: CGC'I GC" 

) 

1 

2 : 

<GC"> ( 

) 

3 

R COUNT DUP 1+ R> + >R 


4 

GCTYPE ; 


5 



6 



7 : 

GC" < 

) 

8 

34 STATE 0 


9 

IF 


10 

COMPILE (GC") WORD 


11 

HERE C0 1+ ALLOT 


12 

ELSE 


13 

WORD HERE COUNT GCTYPE 


14 

ENDIF ; IMMEDIATE 


15 


= = > 


Screen: 110 

0 ( Hi -res: GCPOS SUPER SUB ) 

1 

£ : GCPOS ( col row — ) 

3 3DUP 3£0 * + GCPTR ! 

4 GCROW ! GCCOL ! ; 

5 

6 : SUPER ( — ) 

7 VMI# @ MINUS GCPTR +! ; 

8 

9 : SUB ( — ) 

10 VMI# @ GCPTR + ! ; 

) U 
12 

13 

14 

15 ==> 


Screen : 113 



0 

< 

Hi-res: GCSPACE CS3 GCD. R 

) 

1 

2 

. 

GCSPACE 

( — 

) 

3 


BL GCEMIT j 



4 





5 

; 

GCSPACES 

( r. — 

) 

6 


0 MAX -DUP 



7 


IF 0 



8 


DO GCSPACE 



9 


LOOP 



10 


ENDIF ; 



1 1 





12 

s 

GCD. R 

( d n — 

) 

13 


> R SWAP OVER 

DABS 


14 


(# #S SIGN #> 

R> OVER - 


15 


GCSPACES GCTYPE ; 

-> 


Screen: 114 



Screen 

0 

< 

Hi-res: 

GC. R GC. 

GCLEN ) 

0 

1 





1 

2 

: 

GC. R 


( r. n — ) 

p 

3 


> R S-> D 

R> GCD. R ; 


3 

4 





4 

5 

s 

GC. 


( n — ) 

5 

6 


0 GC. R 

GCSPACE 5 


6 

7 





7 

6 

: 

GCLEN 

( adr cnt 

— #chrs ) 

a 

9 


0 (ROT 

0+S 


9 

10 


DO I ce 

£8 - 


10 

11 


CASE 

0 0 0 


1 1 

1 £ 


NOCASE 1 


1 £ 

13 


CASEND + 


13 

14 


LOOP ; 



14 

15 




==> 

15 


Screen: 115 Screen: 

0 ( Hi-res: VMI GC. $ ) 0 

1 1 

£ : VMI < n — > £ 

3 40 * VMI# ! ; 3 

4 4 

5 : GC$. ( adr — ) 5 

6 COUNT GCTYPE ; 6 

7 7 

a : GCLS ( — ) a 

9 88 e 9 

10 703 CC< 4 = 10 

11 IF 6400 ELSE 7680 END IF 11 

1£ ERASE 12 

13 GCRGT 0 GCPOS ; 13 

14 14 

15 GCINIT BASE ! 15 


Screen: 116 
0 
1 
£ 

3 

4 

5 

6 
7 

a 

9 

10 

11 

1 £ 

13 

14 

15 


Screen : 
0 
1 


4 

5 

6 

7 

8 
9 

10 

11 

IS- 

IS 

14 

15 


117 


118 


119 


Screen: i£0 


Screen: 1£3 



0 

( Double: DVAR 

DCON D- D> R DR) ) 

0 

( 

Double: 

D) R 

DR) 

1 

BfiSE 0 DCX 


1 





£ 



£ 

: 

D> R 



3 

: DVfiRIflBLE 

< cccc — adr ) 

3 


R> <ROT 

SWAP 

> R > R 

4 

VARIABLE , ; 


4 





5 



5 

: 

DR) 



S 

: DCONSTfiNT 

< cccc — d ) 

6 


R> R> R) 

SWRP 

ROT 

7 

<BUILDS , , 


7 





8 

DOES) D@ ; 


8 

: 

D, 



9 



9 


i » 5 



10 

0. DCONSTANT 0. 

1. DCONSTfiNT 1. 

10 





11 



11 

: 

M+ 



i£ 

: D- 

( d d — d ) 

1 £ 


S-)D D+ 

; 


13 

DMINUS D+ 5 


13 





14 



14 





I 3 


==> 

15 






Screen : 1£1 


Screen: 1£4 


0 ( 

Double: D0= D= 

D0< D < D> 

) 

0 

( Double: DU < 

1 




1 


£ : 

D0= 

( d — 

f ) 

d. 

: DU < 

3 

OR 0= ; 



3 

DUP 4 PICK XOR 0 < 

4 




4 

IF 

5 : 

D= 

( d d — 

f ) 

5 

£DROP D0< NOT 

6 

D- D0= ; 



6 

ELSE 

7 




7 

D- D0< 

8 : 

D0< 

< d — 

f ) 

8 

ENDIF ; 

9 

SWfiP DROP 0< ; 



9 


10 




10 


1 1 : 

D < 

( d d — 

f ) 

11 


1 £ 

D- D0 < ; 



1 £ 


13 




13 


1 4 : 

D) 

( d d — 

f ) 

14 


i 5 

£SWfiP D < ; 


— > 

15 



Screen: 1££ 

8 < Double: DMIN DMftX 

1 

£ : DMIN ( 

3 £OVER £OVER D> 

4 IF 

5 £SWflP 

6 ENDIF 

7 £DROP ; 

8 

9 : DMfiX < 

18 £OVER £OVER D< 

11 IF 
1 £ £SWfiP 

13 ENDIF 

14 £DROP ; 

15 


Screen : 1 £5 

) 8 

1 

d d — d ) £ 

3 

4 

5 

6 

7 

8 

d d — d ) 9 

18 
1 1 
1 £ 

13 

14 

==> 15 


D, M+ ) 

( d — ) 

> R ; 

( — d ) 

R ; 

< d — ) 

d n — d ) 

— > 
) 


BfiSE ! 


Screen : 1 £6 
0 
1 


Screen: 129 
0 
1 


1 


4 

5 

6 
7 
B 
9 

10 
1 1 
12 

13 

14 

15 


3 

4 

5 

6 
7 
B 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 127 
0 
1 


.s 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 


14 

15 


Screen: 130 
0 
1 
2 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


o 


Screen: 128 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 131 
0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


J 


Screen : 
0 
1 


1 32 


4 

5 

6 

7 

8 
3 

10 
1 1 
12 

13 

14 

1 5 


Screen: 135 

0 < Utils: 

1 

3 

4 

5 

6 

7 

8 
3 

10 

11 

12 

13 

14 

15 


— > 


Screen: 133 
0 
1 
£ 

3 

4 

5 

6 
~7 

a 

9 
10 
1 1 
12 
i vi 

14 

15 


Screen: 136 

0 ( Utils: XR/W ) 

1 

£ : XR/W < ttsecs a blk# f — ) 

3 4 PICK 0 

4 DO 

5 3 PICK I B/BUF * + 

6 3 PICK I + 3 PICK R/W 

7 LOOP 

8 2DR0P 2DR0P ; 

9 
10 
1 1 
12 

13 

14 

15 ==> 


Screen: 134 

0 ( Utils: Initialization 

1 


£ BASE ® DCX 

3 

4 M XC! ) ( £1 KLOAD ) 

5 ’ ( HIDCHR ) ( £4 KLOAD ) 

6 ’ ( > BSCD > ( £6 KLOAD ) 

7 

8 
3 

10 
1 1 
12 

13 

14 

15 


) 




Screen: 137 

0 < Utils: SMOVE > 

1 

£ : SMOVE ( orq des cnt — ) 

3 FLUSH MTB 

4 741 @ PAD DUP 1 AND £DUP 

5 SWAP B/SCR * B/BUF * U< 

6 IF CR Too many: 11 

7 B/BUF B/SCR * / U. 

8 . " max. " DROP £DROP 

3 ELSE DROP 

10 > R DCX MTB CR 

11 . " SMOVE from " OVER DUP 3 . R 

1£ . " thru " R + 1- 3 . R CR 

13 8 SPACES 

14 . " to " DUP DUP 3 . R 

15 thru " R + 1- 3 . R — > 


Screen: 138 Screen: 141 


0 

( Utils: SMOVE 

) 

0 

< Utils: 

H-> 

L 

L-)H 

H/L 

C- 

SPACE Y/N 


l 

£ 

HEX 







3 

IF 


3 








4 

CR . " Insert source" 

RETURN 

4 

CODE 

H-> L 





( n — n ) 

5 

R B/SCR * PAD DUP 1 

AND - 

5 


B5 C, 

01 

c, 

95 

c, 

00 C, 

6 

4 ROLL B/SCR * OFFSET @ + 

6 


94 C, 

01 

c, 

4C 

c, 

NEXT , C; 

7 

1 XR/W 


7 








8 

CR . " Insert dest. " 

RETURN 

8 

CODE 

L-> H 





( n — n ) 

9 

R> B/SCR * PAD DUP 1 

AND - 

9 


B5 C, 

00 

C, 

95 

C, 

01 C, 

10 

ROT B/SCR * OFFSET C" 

+ 

10 


94 C, 

00 

C, 

4C 

C, 

NEXT , C; 

11 

0 XR/W 


11 








IS 

ELSE R> DROP 2DR0P 


12 

CODE 

H/L 




( 

n — n n ) 

13 

CR . " Srnove aborted. 

. . " CR 

13 


B5 C, 

00 

C, 

94 

C, 

00 C, 

14 

ENDIF 


14 


4C C, 

PUSH0A , 

C| 


15 

END IF ; 

==> 

15 

DCX 






> 


Screen: 139 


Screen: 14; 

2 




0 < 

Utils: LOADS 

THRU ) 

0 

( Utils: BIT ?BIT 

TBIT 

) 

1 



1 

HEX 





c. 



£ 

CODE BIT 


< b — n 

) 

wi 5 

LOADS 

< n cnt — ) 

3 

B4 C, 

00 C, C 8 C, 

A9 

C, 00 C, 


4 

O+S 


4 

95 C, 

00 C, 95 C, 

01 

C, 38 C, 


5 

DO 


5 

38 C, 

00 C, 36 C, 

01 

C, 18 C, 


6 

I LOAD ?EX IT 


6 

88 C, 

D0 C, F 8 C, 

4C 

C, NEXT , 

u 

7 

LOOP ; 


7 

C 5 





8 



8 

: ?BIT 

BIT AND 0# 

i < 

rt b — f 

) 

9 



9 






10 : 

THRU 

( n n — n cnt ) 

10 

: TBIT 

BIT XOR ; 

( 

n b — n 

> 

1 1 

OVER - 1+ ; 


11 






12 



12 

: SBIT 

BIT OR 5 

( 

n b — n 

) 

13 



13 







14 

15 


--> 


14 : RBIT ( n b — n ) 

15 FFFF SWAP TBIT AND ; ==> 


Screen: 140 


Screen: 143 


0 ( 

Utils: SEC MSEC 

) 

0 

< Utils 


STICK 





1 



1 

HEX 









L_ a 

SEC 

( r. — > 

p 

HERE 

DUP 2 : 

DUP 

0 , 

1 , - 

1 , 

0 

3 

0 DO 


3 










4 

9300 0 


4 

CODE 

STICK 




( n - 

- h 

V 

5 

DO 


5 










6 

LOOP 


6 

B4 

c, 

00 

c. 

B9 

c, 

78 C, 

02 

C, 

7 

LOOP ; 


7 

48 

c, 

CA 

C, 

CA 

C, 

29 C, 

03 

C, 

8 



8 

0A 

c, 

A 8 

C, 

B9 

C, 


95 

c, 

9 : 

MSEC 

< n — ) 

9 

02 

C, 

C 8 

C, 

B9 

C, 

» 

95 

c, 

10 

0 DO 


10 

03 

C, 

68 

C, 

4A 

C, 

4A C, 

29 

c, 

11 

6 0 


11 

03 

C, 

0A 

C, 

A 8 

C, 

B9 C, 



12 

DO 


12 

95 

C, 

00 

C, 

C 8 

C, 

B9 C, 



13 

LOOP NOOP 


13 

95 

C, 

01 

C, 

4C 

C, 

’ SWAP , 


14 

LOOP ; 


14 










15 


==> 

15 

CURRENT 

e i 

CONTEXT ! 



— 


Screen: 144 


0 

( Utils: 

STRIG 

PADDLE 


) 

1 

HEX 









{— 

3 










4 

CODE 

PADDLE 



( n 

— n 

) 

5 

B4 

c, 

00 

c, 

B9 

c. 

£70 , 



6 

4C 

c, 

PUT0A 

, c 

5 




7 










8 

CODE 

STRIG 




( n 

— f 

) 

9 

B4 

c, 

00 

c, 

B9 

C, 

£84 , 



10 

49 

c, 

01 

c, 

4C 

C, 

PUT0A 

, C; 


1 1 

1 ? 

CODE 

PTRIG 




( n 

— f 

> 

13 

B4 

c, 

00 

c, 

B9 

C, 

£7C , 



14 

49 

c, 

01 

c, 

4C 

C, 

PUT0A 

, C; 


15 









= > 


Screen: 145 

0 < Utils: ATRACT NXTATR ) 

1 

£ DCX 

3 

4 : ATTRACT ( f — ) 

5 IF £55 ELSE 0 END IF 77 C ! ; 

6 

7 : NXTATR 

8 £55 £0 C! ; < — > 

9 ( Changes user clock ) 

10 

11 : HLDATR 

1£ 0 £0 C! ; < — ) 

13 ( Changes user clock ) 

14 


Screen: 146 

0 ( Utils: 1ST I ME > 

1 HEX 


3 

CODE 

1ST I ME 





4 

CA 

c, 

CA C, 





5 

A5 

C, 

13 C, 

95 

c, 

01 

C, 

6 

A5 

C, 

14 C, 

95 

c. 

00 

c 

7 

D 0 

C, 

04 C. 





8 

A5 

C, 

13 C, 

95 

c, 

01 

c 

9 

4C 

c. 

NEXT , 

c; 





10 

11 

1 £ 

13 

14 


Screen: 147 


0 

< Utils: 8 RND 16RND 

CHOOSE > 

1 

HEX 


c! 

3 

CODE 8 RND 

( — b ) 

4 

PD C, Dc!0P 9 


5 

4C C, PUSH0P , 


6 

C; 


7 

8 

CODE 16RND 

( — n > 

9 

AD C, D£0A , 48 C, 

68 C, 48 C, 

10 

68 C, 48 C, AD C, 

DiEl 0 P j 

11 

4C C, PUSH , C; 


1 £ 

13 

: CHOOSE 

( r« — ri ) 

14 

16RND U* SWAP DROP 

5 

15 


— > 

Screen: 148 



0 ( Utils: CSHUFL SHUFL > 

1 DCX 

£ : CSHUFL < a r. — ) 

3 1-0 SWAP 

4 DO 

5 DUP I CHOOSE + OVER I + 

£ £DUP C@ SWAP C@ 

7 ROT C! SWAP C! 

B -1 +LOOP DROP 5 
9 

10 : SHUFL (an — ) 

11 1-0 SWAP 

1£ DO DUP I CHOOSE £* + 

13 OVER I £* + 

14 £DUP 0 SWAP 0 ROT ! SWAP ! 

15 -1 +LOOP DROP ; ==> 


Screen: 149 


0 

( Utils: 

H. 

A. 

1 




£ 

: A. 



3 

C@ 1£7 

AND 


4 

DUP 3£ 

< OVER 

5 

1£4 > OR 


6 

IF DROP 

46 

END IF 

7 

SPEMIT 

5 


a 




9 

’ ( H. — > 

) ( 

) 

10 




u 

: H. 



1 £ 

BASE © 

HEX 

SWAP 

13 

0 <# # 

# #> 

TYPE 

14 

BASE ! 

5 


15 





DUMP 


) 


Screen : 1 58 
8 ( Utils: 
1 DCX 


Screen: 153 
8 
1 


E 

3 

4 

5 

6 
7 

a 
s 
10 
1 1 
12 

13 

14 

15 


DUMP (an — ) 

D+S 

DC 

CR I H-> L H. I H. 

£ SPACES I 8 D+S £DUP 
DD 

I C® H. SPACE 
LOOP CR 7 SPPCES 
DO 

I P. £ SPPCES 
LOOP 7EXIT 
a /LOOP 

CR ; ==> 


3 

4 

5 

6 
7 

a 

9 
10 
i i 
12 

13 

14 

15 


Screen: 151 

0 ( Utils: BLKOP 

1 HEX 


system 


Screen: 154 
0 


3 

CODE 

BLKOP 

( 

adr cnt byte — 

- ) 

3 

4 

09 

c, 

03 

c, 

£0 

c, 

SETUP 

i 


4 

5 

HERE 



C4 

c, 

C4 C, 

D0 

c, 

5 

6 

07 

c, 

C6 

C, 

C5 

C, 

10 C, 

03 

C, 

6 

-7 

4C 

C, 

NEXT , 



B1 C, 

C6 

C, 

7 

6 

R5 

C, 

C£ 

C, 

91 

C, 

C6 C, 

ca 

C, 

8 

9 

D0 

C, 

EC 

C, 

EB 

C, 

C7 C, 

4C 

C, 

9 


10 
1 1 
IE 

13 

14 

15 


DCX 


C; 


— ) 


10 

11 

12 

13 

14 

15 


Screen: 152 

0 ( Utils: 

1 HEX 

£ CODE BXOR 
PS C, 4J 
8D C, ’ 
4C C, ’ 


4 

5 

6 
7 

a 

9 

10 

u 

12 

13 

14 

15 


BXOR 

( adr cnt 

I C, 

BLKOP 12 + , 
BLKOP , C: 


CODE BAND 
R9 C, 

8D C, 

4C C, 


( adr cnt 

£5 C, 

’ BLKOP 12 + , 
’ BLKOP , C; 


byte — ) 


byte — ) 


CODE BOR ( adr cnt byte — ) 

P9 C, 05 C, 

8D C, ’ BLKOP 12 + , 

4C C, ’ BLKOP , C; BASE ! 


Screen : 
0 
1 
£ 

3 

4 

5 

a 

7 

a 

9 

10 
1 1 
12 

13 

14 

15 


155 


Screen : 1 56 

0 ( Strings: -TEXT ) 

1 BOSE C- DCX 

£ : -TEXT (a u a — > 

3 £DUP + SWOP 

4 DO 

5 DROP 1+ 

6 DUP 1- CC- 

7 I CC- - DUP 

B IF 

9 DUP PBS 

10 / LEAVE 

11 ENDIF 
IS LOOP 

13 SWRP DROP DUP 

14 IF 1 SWAP +- ENDIF ; 

15 ==> 


Screen: 159 

0 ( Strings: $CON , $VAR , > 

1 

£ : $CONSTANT ( $ ccc — ) 

3 PPD 51£ + SWRP OVER *! 

4 0 VARIABLE -£ ALLOT 

5 HERE *! HERE CC- 1+ ALLOT ; 

6 

7 : ^VARIABLE < ler. ccc — ) 

8 0 VARIABLE 

9 1- ALLOT ; 

10 

11 : (") ( — $ ) 
1£ R DUP CC- 1+ R> + >R i 

13 

14 

15 — > 


Screen: 157 

0 ( Strings: -NUMBER ) 

1 

£ 0 VARIABLE NFLG 


4 



7 

8 
9 

10 
1 1 
1 £ 

13 

14 
35 


-NUMBER ( addr — d ) 

BEGIN DUP CC- BL = DUP + NOT 
UNTIL 0 NFLG ! 0 0 ROT DUP 1+ 
CC- 45 = DUP >R + -1 
BEGIN DPL ! (NUMBER) DUP C@ 
DUP BL <> SWAP 0# AND 
WHILE DUP CC- 48 - NFLG ! 

0 REPEAT DROP R> IF DMINUS 
ENDIF NFLG C- 
IF £DROP 0 0 ENDIF 
NFLG C- NOT NFLG ! ; 

— > 


Screen: 160 



0 ( 

Strings: " 


) 

1 




p • 

M 



3 

34 ( Ascii quote ) 


4 

STATE C- 



5 

IF 

( cccc" 

— ) 

6 

COMPILE <"> 

WORD 


7 

HERE CC- 1 + 

ALLOT 


8 

ELSE 



9 

WORD HERE 

( cccc" - 

- $ ) 

10 

PAD $ ! PAD 



1 1 

ENDIF ; 



1£ 




13 

IMMEDIATE 



14 




1 5 



===> 


Screen: 158 

Screer 

>: 161 

0 

( Strings: UMOVE , $! ) 

0 ( 

Strings: $. , SXCHG 

1 


1 


£ 


P ■ 

i. ( 

3 

FORTH DEFINITIONS 

3 

DUP CC- 0> 

4 


4 

IF 

5 

: UMOVE ( a a n — ) 

5 

COUNT TYPE 

6 

<ROT OVER OVER U< 

6 

ELSE 

7 

IF 

7 

DROP 

8 

ROT (CMOVE 

8 

ENDIF ; 

9 

ELSE 

9 


10 

ROT CMOVE 

10 


11 

ENDIF ; 

11 : 

SXCHG ( *1 *i 

1£ 


1£ 

DUP PAD £56 + %\ 

13 

: $! 

13 

OVER SWAP $! 

14 

OVER CC- 1+ UMOVE ; 

14 

PAD £56 + SWAP $! ; 

15 

==> 

15 



Screen: 16£ Screen: 165 


0 

( Strings: S+ , 

LEFTS 

) 

0 

( 

Strings: S( , 

s 

II 

SVS 


1 




1 






O 

: S+ 

W* 

TO 

— S ) 

a 

: 

S ( 

( SI S£ 

— f 

) 

3 

SWAP PAD £56 + 



3 


SCOMPARE 0 ( 5 




4 

> R R S! 



4 






5 

DUP C@ SWAP 1+ 



5 

: 

S= 

( SI S£ 

— f 

> 

6 

R C© 1+ R + 



6 


SCOMPARE 0= ; 




7 

3 PICK UMOVE 



7 






a 

R C© + £55 MIN 



8 

5 

S> 

< SI S£ 

— f 

) 

3 

R C! R> PAD SI 

PAD ; 


3 


SCOMPARE 0> 5 




10 




10 






11 

: LEFTS 

( S N 

— S ) 

11 

- 

SAVES 

( S 

— S 

) 

1£ 

SWAP PAD (ROT 1 

PAD SI 


1 £ 


PAD 512 + SWAP 




13 

OVER C© MIN 



13 


OVER SI ; 




14 

OVER C! ; 



14 






15 



II 

II 

15 




— 

■> 


Screen: 163 

0 ( Strings: RIGHTS , MID* ) 

1 

£ : RIGHTS < S n — S ) 

3 SWAP PAD <ROT PAD S! 

4 OVER <ROT OVER C© 

5 DUP 4 PICK + 

6 (ROT MIN DUP 

7 (ROT 1 

8 SWAP ROT OVER OVER 

3 C! 1+ SWAP CMOVE ; 

10 

11 : MIDS ( S start len — S ) 

1£ 3 PICK C© 1+ ROT - 

13 0 MAX ROT SWAP 

14 RIGHTS SWAP OVER 

15 C© MIN OVER C! ; — > 


Screen : 1 66 

0 ( Strings: INSTR ) 

1 

£ 0 VARIABLE INCNT 

3 

4 : INSTR ( SI S£ — n ) 

5 0 INCNT ! 1+ SWAP DUP 

6 > R OVER 1- C@ > R 1 + 

7 DUP 1- C© R - 1+ 0 MAX 

8 OVER + SWAP R> (ROT 
3 DO 

10 £DUP I -TEXT 0= 

11 IF 

1£ I J - INCNT ! LEAVE 

13 END IF 

14 LOOP 

15 SDRQP R> DROP INCNT © ; ==> 


Screen: 164 

Screen: 167 

0 

( 

Strings: LEN , ASC , SCOMP ) 

0 

< Strings: CHRS 

1 



1 


£ 

: 

LEN ( S — length ) 

L_ 

: CHRS 

3 


C© , 

3 

1 PAD C! 

4 



4 

PAD 1+ Cl 

5 

: 

ASC ( S — c ) 

5 

PAD ; 

6 


1+ C@ 5 

6 


7 



7 

: DVAL 

8 

: 

SCOMPARE ( SI S£ — f ) 

8 

PAD SI PAD 

3 


£DUP C© SWAP C© SWAP 

3 

DUP C@ OVER 1+ 

10 


£DUP MIN (ROT - >R 

10 

0 SWAP C! 

11 


ROT 1+ (ROT SWAP 1+ 

1 1 

-NUMBER ; 

1£ 


-TEXT -DUP 0= 

12 


13 


IF R> DUP IF 1 SWAP +- END IF 

13 

: VAL 

14 


ELSE R> DROP ENDIF ; 

14 

DVAL DROP ; 

15 


==> 

15 



DVAL , VAL ) 
( c — S ) 


( S — d ) 


) 


( S — n ) 
— > 


STR C ING3 S ) 


Screen: 168 

0 ( Strings: DSTRS , 

1 

£ : DSTRS 

3 DUP <ROT DOBS 

4 <# #S SIGN #> 

5 SWAP 1- DUP 

6 <ROT C! POD S ! PAD 

7 

8 : STRS 

g S-> D DSTRS ; 

10 

11 : STRINGS 
IE 1+ C<? OVER 

13 PAD C! PAD 

14 1+ <ROT FILL PAD ; 

15 


( d 


( d 


n * 


S ) 


$ ) 


$ ) 




Screen: 

0 

1 


4 

5 

6 

7 

8 

g 

10 

u 

IE 

13 

14 

15 


Screen: 16S 

0 ( Strings: S-TB , #INS , INS ) 

1 

£ : S-TB ( S — S ) 

3 DUP DUP 1+ SWAP C@ 

4 --TRAILING SWAP DROP 

5 OVER C! ; 

6 

7 : #IN$ ( n — S ) 

8 -DUP 0= IF £55 ENDIF 

g PAD 1+ SWAP EXPECT PAD 

10 BEGIN 1+ DUP C@ 0= UNTIL 

11 PAD 1+ - PAD C! PAD ; 

IE 

13 : INS ( — S ) 

14 0 #INS ; 

15 BASE ! 


Screen : 
0 
1 
S 

3 

4 

5 

6 

7 

8 
g 

10 

u 

IE 

13 

14 

15 


Screen: 170 Screen: 


0 

1 

CONTENTS OF THIS DISK: 



0 

1 

S 

1 

£ 

TRANSIENTS: 

36 

LOAD 

3 

ARRAYS & THEIR COUSINS: 

4£ 

LOAD 

3 

4 

KEYSTROKE WORDS: 

48 

LOAD 

4 

5 

SCREEN CODE CONVERSION: 

5£ 

LOAD 

5 

6 

CASE STATEMENTS: 

56 

LOAD 

6 

7 

valFORTH EDITOR 1. 1 : 

64 

LOAD 

7 

8 

HIGH-RES TEXT: 

106 

LOAD 

8 

g 

DOUBLE NUMBER XTNSIONS: 

1E0 

LOAD 

g 

10 

MISCELLANEOUS UTILS: 

134 

LOAD 

10 

11 

STRING WORDS: 

156 

LOAD 

1 1 

IE 




IE 

13 




13 

14 




14 

15 




15 


171 


17E 


173 


Screen: 174 
0 
1 
cl 

3 

4 

5 

6 

7 

8 
g 

10 
1 1 
i£ 

13 

14 

15 


Screen: 177 

0 Disk Error ! 

1 

£ Dictionary too big 

3 

4 

5 
8 

7 

8 
9 

10 

11 

1£ 

13 

14 

15 


Screen: 175 
0 
1 

3 

4 

5 

6 
7 

a 

9 
10 
1 1 
1 £ 

13 

14 

15 


Screen: 178 

0 ( Error messages 

1 

£ Use only in Definitions 

3 

4 Execution only 

5 

6 Conditionals not paired 

7 

8 Definition not finished 

9 

10 In protected dictionary 

11 

1£ Use only when loading 

13 

14 Dff current screen 

15 


Screen: 176 

0 ( Error messages 

1 

£ Stack empty 

3 

4 Dictionary full 

5 

6 Wrong addressing mode 

7 

8 Is not unique 

9 

10 Value error 

11 

1£ Disk address error 

13 

14 Stack full 

15 


Screen: 179 

> 0 Declare VOCflBULPRY 

1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

1£ 

13 

14 

15 




IMaiMiaM VALPAP 

INTERNATIONAL 

3801 E. 34 th STREET 
TUCSON, ARIZONA B5713 
60E-7S0-7141 



valFORTH 

T.M. 

SOFTWARE SYSTEM 

for ATARI* 


va/EXQ® 




Software and Documentation 
©Copyright 1982 


Atari is a trademark of Atari, Inc., a division of Warner Communications. 



o 


o 


o 


valFORTH 

T.M. 

SOFTWARE SYSTEM 

va/IMS 

Stephen Maguire 

Software and Documentation 
©Copyright 1982 
Valpar International 

Purchasers of this software and documentation package are 
authorized only to make backup or archival copies of the 
software, and only for personal use. Copying the accompanying 
documentation is prohibited. 


Copies of software for distribution may be made only as speci- 
fied in the accompanying documentation. 


o 


o 


c 


VALPAR INTERNATIONAL 


Disclaimer of Warranty 
on Computer Programs 


All Valpar International computer programs are distributed 
on an "as is" basis without warranty of any kind. The total 
risk as to the quality and performance of such programs is with 
the purchaser. Should the programs prove defective following 
their purchase, the purchaser and not the manufacturer, distributor, 
or retailer assumes the entire cost of all necessary servicing or 
repai r. 


Valpar International shall have no liability or responsibility 
to a purchaser, customer, or any other person or entity with 
respect to any liability, loss, or damage caused directly or 
indirectly by computer programs sold by Valpar International. 

This disclaimer includes but is not limited to any interruption 
of service, loss of business or anticipatory profits or conse- 
quential damages resulting from the use or operation of such 
computer programs. 

Defective media (diskettes) will be replaced if diskette(s) 
is returned to Valpar International within 30 days of date of sale 
to user. 

Defective media (diskettes) which is returned after the 30 day 
sale date will be replaced upon the receipt by Valpar of a $12.00 
Replacement Fee. 


o 


o 


o 


o 


■'V :i. 0053 


Tab 1 e_gf ...Contents 


o 


l.y.J,. Strolling Through valDOS 

A brief look at the features of the valDOS system. 


I . < T 1 . val DOS Lornmarirl Descr ipti ons 

Detailed descriptions of all the valDOS commands,, 

U X 1 II.. valDOS System Plossarv 

a ) rhe internal workings of val DUS 

h) (he system glossary 

i ) The command system glossary 

■■I ' l-mir n.ess«ges and meanings . .......... 


I.X | v a | ons t i l hdi t or 

User's manual Tor the va l DOS file editor,. 

LXV. va l DUS 1 Supplied Source listing 

I XVI. val DUS II Supplied Source listing 


O 


o 


o 


C' 


Strolling Through valDQS 


Until now, one of the' major drawbacks o+ FORT'Hs for Atari 
was that vou could could either save code on screens or in DOS 
files, but not both. The demand to have both brought on the 
development of this two-disk package — valDOS. 

With valDOS vou can load FORTH screens iust as before, or 
vou can load FORTH source from standard Atari DOS files. But 
this package allows much more than that. A complete file 
editor is supplied which can be used to edit FORTH (or 
assembly. Rascal . etc. > source code and save it in DOS format. 

To use this package to its fullest, at least 32K of memory 
should be available. If vou have less than 32K. don't worry, 
it iust means that vou can't, load all of the commands at once. 
The package is broken into six major parts: 

1 i valDOS (approximately 3.6K compiled) 

VI) valDOS extensions 

5) Basic: DOS commands (keyboard entry nnlv/ 

4 ) DOS command extensions 

r j i F o r m a 1 1 <■? r /' c o p i e r s 

ol f i i e odi tor 

Wn shall Ttegin Thus stroll by taking a look at the first 
five r.-irt' . Before' starting. duplicate both master disks 

iwt’ 1 1 be modi t'.-i no the valDOS 11 copy) . Insert your valDOS .1. 

disk in drive one and list screen I/O bv tvpmn I/O LIST 
I (-nil- t nr t ti * -■ I i no that save DOS OUTIITAND hit FNS 1 DNS and load 

them in.. ibis should take a few minutes. There arc so manv 

command's with p.n many variations on each that only the 
h l pi. I i ght c: uf the package will be discussed Imre. barb of the 
commands is explained in detail in section LXJ1,. 

Insert tour copy of the valDOS II diskette. Type DIR and 
pro. « the return let. Vou should see the following on your 
d i *■ p 1 ay : 


Tiles on: vaJDIlS — disk 1.1 

MAI'IF to SI. /.t SEC A TTR 

+ - — i — i — i - a- i i --i — i — i — i — i — i- — i — i — i- 


ASBM . 4TH 

X.UOUT . A TT-I 

DULL I STS. 4 III 
I ILF II ,.4 04 


33 4 L 

1 0 57 L 

7 4 / L. 

8 S4 I . 


'■* < ) 'y f~ 0 c. t". o y~ s f r f? f? 


LX I 


1 


Strolling Thru valDCIS 


The DIR command simply displays the directory of the disk. 
There are four files on this disk. ASSM.4TH is the standard 
valFQRTH assembler with a correction for the "absolute. Y" 
instruction which assembled incorrectly when the "absolute" 
address was in the zero page. XB00T.4TH is a routine which 
allows dictionaries greater than 32K to be SAVEd and AUTOed. 
D0CL1STS.4TH is the routine used to list six screens/page tor 
val FORTH documentation. And finally. FILEIT.4TH is a routine 
that transfers FORTH screens to DOS files. 

If vou have a two drive system, DIR 2 will give the 
directory of the disk in drive two. The DIR command will also 
accept, file specifications. Try the followings 

DIR ASSM.4TH 

DIR X* 

DIR ????!* 

DIR MYFILE 

In these examples, there are? the two characters "?" and 

which need some explanation. SimDly put, "?" will match 
any single letter when compare with a filename in the 
directory. will match any group of letters to the right 

from its position to the end of the filename. In the second 
example above, all files starting with "X" are listed. In the 
third example, all files whose fifth letter is "I" are listed 
(the first four can be anything). 

For advanced FORTH programmers, the SECtor column of the 
listing is the first sector of the? file. This is a DOS sector 
(FORI H sectors are offset bv -1, i.e., FORTH sectors are 

numbered starting at zero while Atari has numbered DOS sectors 
beginning with one; hence, DOS sector 4 is FORTH sector 3). 
The last column indicates the attributes of the files. All of 
the files on this disk are locked and therefore have the "L." 
at.tr i bute. 

Notice that unlike most FORTH words, DIR expects its 
arguments on the right. Although valDOS system itself expects 
all parameters to be passed on the stack, the valDOS user 
commands all expect their arguments on the right, as is usual 
with DOS’s. The only restriction on this method of input, is 
that no blanks may appear within the command list. 

Let’s make a copy of one of the files. The CORY command 
does this nicely for us; 

COPY FILE1=FILE1T„ 4VH 

This command has the basic: format "new=old". The COPY 
command can also append two or more files together and save 
this new tile into another file; 

COPY F I LE2=F 1 LE 1 T . 4 TH , DOCL I STS . 4 TH 

FILE2 should now contain FILEIT.4TH with DOC-LISTS. 4TH 


LX I. 


Strolling Thru valDOS 


appended to it. It is possible to string as many files 
together as desired. We’re not quite through yet. It we were 
to enter: 

COPY FILE2=XB0DT.4TH 

FILE2 would contain an enact copy of XBQ0T.4TH. However, if we 
typed : 


COPY F ILE2/ A=XBOOT . 4TH 

XB00T.4TH would be appended to whatever was already in FILE2. 
namely FILEIT.4TH + DOCLISTS. 4TH. Of course, also legal is: 

COPY FILE2/ A=XBOQT„ 4TH, ASSM.4TH 

and all of the original files would be contained in FILE2. 
Unfortunately, FILE2 is FORTH source, but does not have the 
extension 4TH (it is not needed, but desirable). The RENAME 
command can rememdv this: 

RENAME F I I-E2 . 4TH=F 1 LE2 

Like the COPY command, the format for RENAME is "new=oid". For 
some, tvping a long name like RENAME might be a chore. Since 
we are are in FORTH, we can easily customize: 


: REN RENAME s 

Now that we have some more files to work with, type 


DIP F» 
and DIR F * . 

Notice the difference? In the first example, the remainder of 
the filename is wild, while in the second example, the files 
must end with a null extension. 

If we want to keep the file FI LEI from being modified in 
any way, we can lock it using the LOCK command: 


LOCK FI LEI 
DIR 

The LOCK (and so UNLOCK and KILL) command can take several 
arguments, separated by commas: 


LOCK F I LE 1 » MYF I LE , ASSM . 4TH , F # . 4TH 


In this case, 
being non-existent, 
verification prompt, 
specification FK.4TH. 


LOCK would lock FILE!, report MYFIL.E as 
lock ASSM.4TH, and then issue a 
before locking any file that matches the 
Try the following two examples; 


LX I 


Strolling Thru valDOS 


LOCK #.4TH 

LOCK *.4TH/N 

In the first form, a verification prompt is issued for 
each file before it is locked, while in the second form, the 
verification message is not displayed. The /N switch stands 
for "No ask" or "No verify". 

both KILL and UNLOCK have exactly the same argument list 
as LOCK. Use caution when using the /N switch with the KILL 
command . 

If we want to get a listing of a text file, we use the 
PRINT command. For example: 

PRINT FIL.E-ir.4TH 
we get ; 


LX I 


4 


Strolling Thru valDOS 


o 


o 


o 


F i le: 

1)1 : F ILEX T. 4TH 


000 1 



0002 

( Routine: FILE- IT 


0003 



0004 

The following routine will 


0005 

transfer a specified range of 


0006 

FORTH screens to a file on 


0007 

a DOS formatted disk. 


0008 



0009 

Format: FILE- IT 1st , 1 ast , f i I ename 

00 1 0 

FILE- IT 10, 20. MYFILE 


001 1 



0012 

Note that DOS commands tend to 

be 

0013 

long because of error checking 

and 

0014 

parameter parsing. 


0015 



00 1 6 



0017 

: FILE- IT DOS ( — ) 


00 1 8 

GETARGS 7WRGARG 44 GETARG 7WRGARG 

0019 

GETVAL SWAP 44 GETARG 7WRGARG 


0020 

GETVAL SWAP <R0T OVER - 14- 


002 1 

PAD DUP 1 AND - BURBOT OVER - 


0022 

B/BUF / 3 PICK B/SCR * OVER > 


0023 

IF 


0024 

CR . 11 Too many screens, " 


0025 

B/SCR / . max." CR 


0026 

2DR0P 2DR0P 


0027 

ELSE 


0028 

DROP < ROT 04S 


0029 

DO 


0030 

16 0 


003 1 

DO 


0032 

I J (LINE) 


0033 

-TRAILING >R OVER 


0034 

R CMOVE R> 4 


0035 

155 OVER C! 14 


0036 

LOOP 


0037 

LOOP 


0038 

PAD DUP 1 AND -- SWAP OVER - 


0039 

FLUSH INSDST ROT DUP (ENTER) 

0= 

0040 

IF FL.EXST DSKERR = 7SYSERR END IF 

004 1 

(OPEN) 7SYSERR SWAP DROP >R 


0042 

R (WRITE) 7SYSERR 


0043 

R ( ENDF ) 7SYSERR 


0044 

R> (CLOSE) 


0045 

END IF 


0046 

CR s 


004 7 



0048 

FORTH 



LX I 


Strolling Thru val DOS 


The PRINT command has several, options. It the switch /N 
(no line numbers) is present, the tile is displayed without 
line numbers. It an optional starting line number is supplied, 
printing begins at that line: 

PRINT F1LEIT. 4TH/N, 17 

This will print the tile starting with line 17, and with 
no line numbers. Note that the listing may be aborted at any 
time by pressing one ot the yellow console keys. 

The PRINT command is ideal tor displaying text tiles, but 
is utterly useless tor listing a binary or data tile. For this 
reason, the command FDUMP (tile DUMP) has been supplied. Let's 
try FDUMP on FILEIT.4TH: 


FDUMP 

F I L 

.Err 

.41 

H 






File: 

Dl; 

F1LE1T 

.4" 

m 





0000 

9B 

28 

20 

52 

6F 

75 

74 

69 

. ( Rout i 

0008 

6E 

65 

3 A 

20 

46 

49 

4C 

45 

ne: FILE 

00 1 0 

2D 

49 

54 

9B 

20 

9B 

20 

20 

-IT. . 

0018 

54 

68 

65 

20 

66 

6F 

6C 

6C 

The toll 

0020 

. . . 










Like PRINT, FDUMP may be aborted by pressing one ot the 
yellow console keys. It the tilename has the "wide 11 switch /W 
appended to it, the file is dumped with 16 bytes/line instead 
of eight as above. This format is more appropriate when sent 
to a printer. FDUMP always dumps in hexadecimal. 

Let's compile a routine from a DOS file. The tile 
D0CL1STS.4TH is the program used to print 6 screens/page tor 
documentation. To load this file, we simply enter: 

FLOAD DOCL ISIS. 4TH 

and the routine DOCLISTS should now be in the dictionary. There 
is a nice feature to the FLOAD command: 

FORGET DOCL 1 STS 
ON ECHO 

FLOAD DOCL I ST S . 4TH 

Notice that this time the file was echoed to the display as it 
was being loaded. Like the PRINT command, FLOAD can take an 
optional starting line so that loading can begin mid-file. 
Holding down a console key will abort a load once the current 
definition is compiled. 

If you have a source file which is physically contained 
two or more tiles, they can be linked together using the FLOAD 
command. For example, PARTI. 4TH could end with an 


L.X I - 6 


Strolling Thru valDDS 


FLO AD PART2.4TH, and part.2 could end with FLOAD PART3.4TH, etc. 
In this wav. a multi-part tile could be loaded. Although this 
method works, it should be avoided tor several reasons. One 
reason is that it any ot the tiles are renamed, or it they are 
moved to a ditterent drive, each of the original files may have 
to he edited to change the FLOADs. A second and more 
complicated reason is that for each file FLOADed this way, a 
separate file buffer needs to be allocated. The default number 
of file buffers is four, therefore no more than four files can 
be chained. 

The solution to this problem is to create a file which 
contains nothing but FLOADs: 

File: ALLPARTS. 4TH 

0001 FLOAD PARTI. . 4TH ( load in the ??? routines ) 

0002 FL0AD PART2.4TH ( load in the ??? routines ) 

0003 FLO AD PART3.4TH ( ... ) 

This method requires exactly two file buffers and allows 
filenames to be changed easily, if desired. 

This was just a brief stroll through the valDOS package. 
There are many powerful commands left to explore. I he 

following section on command words explains each command in 
detail. Read through this section carefully and out the 
commands on a test disk. And then there is the File Editor, 
with its own set of documentation, in section L.XIV. 

Have fun. 


LX 1 - 7 


File: D2s VERIFY. 4TH 


000 1 



0002 

0003 

( Routine: Write w/o verify 

0004 

The following routine allows writ.' 

0005 

operations to the disk 

without 

0006 

read verification. This 

speeds up 

0007 

disk access by many times. Note 

0008 

that once this routine 

is loaded, 

0009 

00 1 0 

it may neat be forgotten 

i 

001 1 

Format: ON VERIFY 


0012 

00 1 3 

0014 

OFF VERIFY 


0015 

BABE a HEX 


00 1 6 
00 1 7 

ASSEMBLER 


00 1 8 

LABEL -DSK 


0019 

AD C, 02 C, 03 C, 09 C, 

52 0, 

0020 

D0 C, 05 C, A9 0, 40 C, 

40 C, 

0021 

HERE 4 + , A9 C, 80 0, 

8D C, 

0022 

03 C, 03 C, A9 C, 31 C, 

8D 0, 

0023 

00 0, 03 0, A 9 C, 07 0, 

8D C, 

0024 

06 C, 03 C, A9 0, 80 C, 


0025 

( or 00 C, for Percom?) 

8D 0, 

0026 

08 C, 03 C, A9 0. 00 C, 


0027 

( or 01 C, for Percom:’) 

8D 0, 

0028 

09 C, 03 C, 20 C, 59 C, 

E4 C, 

0029 

0030 

003 1 

0032 

60 C, 


0033 

; VERIFY 

( f — 

0034 

0# 7 * 50 + 


0035 

C ’ -DISK 7 + :i 


0036 

0037 

LITERAL C! ; 


0038 

0039 

-DSK ’ -DISK 27 + ! 


0040 

004 1 

BASE ! 



Command Words 


Introduction and Conventions 


The val FORTH Disk Operatina System can be broken into 
two distinct categories. The first contains the system 
words which are for use within running programs and are 


The second 
designed to 
command words 
or delete a 


rarely typed directly at the keyboard, 
category contains "command" words which were 
be executed onlv at the keyboard. Typical 
are those that list the directory of a disk. 

file from the disk. ^ . . , 

Commands words differ from normal FORTH words in that 
all necessary arguments are entered following, the command 
word. For example, to remove a file from a directory, we 
would types 

KILL UNWANTED. F1L 


instead of the usual FORTH-1 ikes 


" UNWANTED. F I L." KILL 


which will not work 
this method of input 
appear within the 
indicate the end of 


as-is. The onlv restriction placed on 
is that absolutely no blanks must 
command list since the blank serves to 
that list. Thus, 


K I L.L F I LE. 1 . F I LE2 , F I LE3 

would properly kill the three files specified while 
KILL FT LEI , FTI...E2, FIL.E3 


would kill the first file and then abort with an error. 

In the command descriptions that follow, any portion 
of. the command format enclosed by the braces "1" and ,• 
is optional and need not be entered. 

Additional.!.'/, some of the commands may be aborted bv 
pressing one of the yellow console keys found on the far 
right of the keyboard. Those commands which have this 
feature are indicated by the sentences 


'This command is interruptable" 


A1 1 commands 


and arguments must be entered in upper case. 


LX II 


I. 


valDOS Commands 


c 

CLOSE 

Release file buffer and update file. 


STATUS; 

User memory at PAD is untouched. 


COMMAND FORMAT; 

CLOSE i f i 1 enumJ 


DPERAT I ON ; 


The CLOSE command flushes the file buffer (different from 
the FORTH disk buffers), if updated, associated with the 
specified file number. The disk buffer is then released for a 
subsequent open (see OPEN). Any future references to the 
specified tile number are ignored until another OPEN command 
re-assigns it. If a file-number is not specified, or if it is 
zero, all open tiles are closed. 


EXAMPLES; 

CLOSE 

Close all open files. 
CLOSE 0 

Close all open tiles. 
CLOSE 2 

Close file number two. 

NOTES; 


c> 


lxti 


valDOS commands 


o 

COPY 

Transfer the contents of one or more files to another file 


STATUS: 


User memory at PAD is untouched. 


O 


o 


COMMAND FORMAT : 

COPY outfile{/A}=infileU,infile2f, . . . >> 


OPERATION: 

The contents of "infilel" are transferred to "outfile." If 
it does not alreadv exist, "outfile" is created. If the /A 
switch is present, the input file is instead appended to the 
output file. All additional input files are appended to -he 
output file in the order in which thev appear. Single 


rurrent 
frive users 


file in 
should also 


FMIYUF 


EXAMPLES: 

COPY MYFIL-E. BAK=MYFILL- 

Transfer contents of MYFILE to MYF1LE.BAK on the 
default drive unit. (see SET UN IT) 

COPY D2: PARTI / A=PART 2 

Append the file PART 2 found on the default unit 
to file PARTI found on unit two. 

COPY ALLPART8=P ART 1 , D3 : PART 2 , PART 3 

Transfer the contents of PARTI to ALLPARTS. then 
append PART 2 on unit three to the new file ALLF ART _ , 
and finallv. append PART 3 to ALLF'ARTS. 


NOTES: 

In the event that an error occurs, the output file mav be 
left, open and should be closed using the CLOSE command. 


LX 1 1 


valDQS Commands 


DIR 


Display list of files on disk. 


STATUS: 


User memory at PAD is untouched. 
This command is i nterruptabl e. 


COMMAND FORMATS: 

DIR Cfil espec> 
DIR unit 


OPERATION: 

The DIR command lists all files within the directory on 
the default drive unit unless an optional file specification or 
drive number is specified. If the optional filespec is 
specified, it must resolve to a legal filename or else an error 
will result. Likewise, if the optional unit specification is 
supplied, it. must be a number from 1 to 4 inclusive. The DIR 
command also displays the current number of free sectors. Note 
that the size of a file displayed in the listing is not 
necessarily accurate unless that, file is closed. However, the 
number of free sectors on disk is always accurate. 


EXAMPLES: 


DIR 

DIR MVFILE 


list information about, ail files 
found on the default, unit. 

list, information on MYFILE found 
on the default unit. 


DIR D2;#.4TH list information on all files with 

the extension 4TH found on unit. two. 

DIR list information about all files 

found on unit three. 


NOTES: 

If the DIR command is given within a file that is to be 
loaded, a filespec or unit must be specified. Thus the 
first example above must be: DIR * 


LX 1 1 


4 


val DOS commands 


Duplicate an existing diskette. 

STATUS; 

PAD is modified. 

COMMAND FORMAT: 

DISKCOF'Yl single-drive copy 

D1SKC0PY2 multi-drive copy 


OPERA! 1 ON : 

DtSKCOPYl is for users with only one disk drive. D I ShCUF 1 Y 
is for users with two or more drives. 


EXAMPLES: 


D 1 SKCOPY 1 

Copy a disk, using only drive one. The user is 
prompted to insert the source diskette, and then 
the destination diskette. This is repeated 
until the entire source diskette is duplicated. 

D I SKCOPY ii 

Ihe diskette in unit one is copied to the 
diskette in unit two. 


NOTES: 


LX II 


valDQS Commands 


ED X T 

Edit a (FOETH) source file. 
STATUS: 

PAD i s mod if ied. 

COMMAND FORMA T : 

EDIT inf i le{ f outf i le> 


OPERATION: 


The input file is read i 
the editor is used to modify 
modified file is written to 
otherwise it is written back 
File Editor documentation 
information. 


nto memory beginning at PAD 


it 
the 

to the input file 
in section LX IV 


wnere 


Upon leaving the editor, the 
output file, if specified, 
See the valDOS 
for further 


EXAMPLES: 

EDIT MYFILfc 

Edit the file MYF ] Lb on the default drive unit and 
write the modified version back to MYFILE. 

EDI T D1 : PACMAN. 4TH, D2: RAGMAN. 4TH 

Edit the file PACMAN. 4TH on unit one and write the 
resultant file into file PACMAN. 41 H on unit two. 

NOT ES : 


~ 6 > 


LX 1 1 


valDOS command 


ENDF I L_ 

End-file at current file cursor position. 
STATUS: 

User memory at PAD is untouched. 


COMMAND FORMAT : 

ENDF 1L filenum 


OPERATION: 


The current file cursor position within the specified file 
is marked as the new end of that file- Ail data a+ter that 
point in the file is lost and anv disk space used by lost data 

is reclaimed. 


EXAMPLE: 

ENDF 1 L 2 


E n d - f i 1 e file n u mb er t w o . 


NOTES: 

Care should be taken if this command is used on a file 
that is open under more than one file number. 


LX 1 1 


7 


valDOS Commands 


EOF 

Move the file cursor to the end of the tile. 
STATUS: 

User memory at PAD is untouched. 


COMMAND FORMAT: 

EOF +i lenum 

OPERATION! 

the cursor ot the spec:, tied tile is repositioned at the 
end of the tile. The tile must already be open. 

EXAMPLE: 

EOF 1 

Position the cursor of tile one at the end ot that 

file. 

NO f'ES : 


L X 1 1 


B 


valDCJS commands 


ENTER 


Enter (create) a filename in a disk directory. 


ST AT US s 


User memory at PAD is untouched. 


COMMAND FORMAT! 

ENTER filename 


OPERA'!' 1 UN : 


Ihe specified filename is 
directory. The filename must 
will result. The file is created, 
this command is usually called 
in FORTH- 


entered into the indicated 
not. already exist or an error 
but is not opened. Although 
CREATE, that word already exists 


EXAMPLES: 

ENTER MYFTLE 

Enter the filename MYFII..E into the directory on 
the default drive unit. 

EM 1 ER 02 ; 1 NVADERS 4 I'l l 

Enter the filename INVADERS. 4TH into the directory 
on unit two. 

NOT ESs 


LX 1 1 


9 


valDOS Commands 


FDUMP 

Perform a hex /ASCII dump of a file 


STATUS: 


User memory at PAD j. s untouched. 
This command is i nterruptabl e. 


COMMAND FORMAT ; 


I- DUMP f i 1 ename f /W> 


OPERATION: 


The specified file is displayed as a sequence of hex 
numbers and ASCII equivalents. This is typically used for 
looking at machine language programs stored on disk. Normal 
output is 8 bytes per line, however, if the /W (for "wide") 
switch is present. 16 bytes per line are displayed. which is 
more suitable for printed output. 


EXAMPLES: 

FDUMP MVP 1 LE . OBJ 

Durnn the file MYF1LE.UBJ to the current output 
device. Eight bvtes/iine are displayed. 

FDUMP MV F || E. OBJ /W 


Dump the tile MYFILE.OBJ to the current output 
device., 16 hvt.es/line are displayed. 


NOTES : 


LX 1 1 - lu 


valDOS commands 


c 


F" I I- E — I T 

Transform FORTH screen format to DOS file format 
STATUS: 


PAD is used. 


COMMAND FORMAT: 

FILE— IT sc r 1 , scr 2 , f i 1 en ame 


OPERAT I ON : 


The screens from scrl to scr2, inclusive,, are read 
free memory, 1 he DOS disk is then swapped into the drive 
the screens are written to the specified filename. 


into 

and 


o 


EXAMPLES: 

F 1 1 1 T 50 . 60 , MVCODE . 4TH 

Screens SO through 60 are read into free memory. 
The user is then prompted to insert the DOS- 
formal disk: into the drive. f he data is next 

written to the file MYCQDE.4IH. 


NOTES: 


c 


- 1 1 


LX 1 1 


vaiDOS Commands 


FLOAD 

Compile a FORTH source file from disk. 


STATUS: 


PAD is moved bv compilation as usual. 
This command is i nterruptabl e. 


COMMAND FORMAT: 

FLOAD f i 1 enamet /CD- 
FLOAD f i 1 enamel, 1 inenuml 


OPERATION: 


The FLOAD command sends the FORTH 
the specified file to the val FORTH 


source code contained in 
compiler. If the /C (for 
continue") switch is qiven, loading begins at the 
edited in the file editor. This 
tived and compilation to he 
If the optional line number 
that line of the file. 


the last line 
errors to he 


is present. 


beginning of 
allows load 
:ontinued mid-file, 
loading proceeds from 


EXAMPLES: 

FLOAD MYOAME „ A T H 

Load the DOS file MYGAME. 4'TH from the default 
drive unit and compile it. 

FLOAD D2 ; CYCLOPS ■' C 

Load the DOS tile CYCLOPS from unit two starting 
with the last line edited in the file editor. 

FLOAD F OR TP AN . A I H . SO 

Load the DOS file FORTRAN. 4 TH from the default 
umt beginning with the 50th line in the file. 


NOTES: 


It i. != possible to LOAD a screen from a 
and vice versa. Usually. LQADi no and FL.OADi 
different units. Also see ECHO command. 


file being FLOADed 
rig should done from 


- 12 


LX 1 1 


val DOS commands 


FMOVE 

Single drive interdisk -file transfer 
STATUS: 

Memory at PAD is used. 


COMMAND FORMAT: 

FMOVE out+i 1 e=i nf i 1 e 


OPERAT I ON : 


The FMOVE 
only one disk d 
one disk to 
available free 
will prompt for 


command is for those users who have access to 
rive. It is used to transfer a DOS file from 
another. If infile is too large to fit in 
memorv , multiple disk swaps must be made. FMOVE 
all necessary inputs, and swaps. 


EXAMPLES; 

FMOVE MYFILE. BAK=MYFILE 

Transfer contents of MYFILE to MYFILE. DAK. MYFILE 
is read into free memorv, source and destination 
disks are then swapped, and the data stored in free 
memory is written to MYFILE. BAK. 


"’Multi-drive users can use the COPY command tor this 
purpose. 


13 


LX 1 1 


valDOS Commands 


FORMAT 

Format a diskette for use. 

STATUS: 

User memory between PAD and BURBOT is untouched. 

COMMAND FORMAT : 

F D R M A T I’ u n i t > 


OPERA I I ON s 


If 


I he I OR MAI corofn&nd init.ializBB a disk for use? with vaJ DOS* 
a unit number is supplied, formatting will be attempted on 
that unit. , otherwise the default unit, is assumed. The command 
will issue verification prompts and will also allow sectors to 
be locked so that no file will ever occupy those sectors. This 
feature allows mixing FORTH screens < virtual memory) and files 
on a single disk. The valDOS II disk is an example of this. 
This command also allows the newly formatted disk to be named. 


EXAMPLES: 


FORMAT 


Format the default drive unit. 


FORMAT 2 


Format uni t two. 


NO I ESs 


this command replaces the one found on the vaj FORTH 1 l 
disk. See NAMED I SK . 


LX 1 1 - 14 


valDOS command 


FSPACE 

Move the tile cursor relative to its current position. 
STATUS: 

User memorv between PAD and BUFBOT is untouched. 

COMMAND FORMAT: 

FSPACE f i 1 enum , count 


OPERATION: 


The cursor of the specified 
offset specified by count. The 
32767 bytes in either direction, 
toward the beginning of the tile 
file cursor is left untouched. 


file is moved by the signed 
file cursor may be moved up to 
with a negative count spacing 
If the count is zero. the 


EXAMPLES: 

FSPACE 5.123 

Move the cursor of file one 123 bytes toward the 
end of the file. 


FSPACE 


-345 


Move the cursor of file two 345 bytes toward the 
start of the file. 


NOTES: 

Spacino backward is generally much slower than spacing 
forward due to the manner in which data is stored on disk. For 
this reason, backward spacing should be avoided. 


LX 1 1 - 15 


valDQS Commands 


K I I I 

Remove files and release disk space. 


STATUS: 


User memory between PAD and BUFBOT is untouched. 


COMMAND FORMAT: 

KILL f i lespecl C/NJ t, f i Iespec2{/N} {, . . . >} 


OPERATION: 


The KILL command removes the specified files from the 
specified unit. If no unit is given in the file specification, 
the default unit is assumed. If the filespec is unambiguous 
,i.e. ,, no wild cards) , no verify prompt is issued. If the 
filespec is ambiguous, a verify prompt is issued for every file 
about to be deleted unless the /N switch is present. 


EXAMPLES: 

KILL THIS 

Delete tile THIS on the default drive unit. 

K I LL PAR 1 1 ,, PART 2 . PARTS , 1)3 ; PART? 

Remove files PARTI, PART2, and PARTS from the 
default, unit, and all files found on unit three with 
five letter names that begin with PART. 

KILL #.BAS, *. 6AK/N, 02: MYFILE, TEST. */N 

Remove all files on the default unit with the 
extension BAS giving verify prompts. Remove all 
files with the extension BAK without verify 
prompts. Delete MYFILE on unit two, and all 
files named TEST on the default unit. 


NOTES: 


L. X 1 1 


16 


valDDS commands 


o 


l_OCK 

Write and modi f v-protect. tiles on disk 


STATUS: 


User memory at PAD is untouched. 


COMMAND FORMAT: 

LOCK ti 1 espec 1 t /N> i , t i 1 espec2C/N> {,...)> 


OPERATION; 


The LOCK command protects the specified files from being 
modified in anv wav. If the filespec is unambiguous (i.e.. no 
wild cards), no verify prompt is issued. If the filespec is 
ambiguous, a verify prompt is issued for every tile about to be 
locked unless the /N switch is present. 


EXAMPLES: 

LOCK D2: * 

Lock all tiles on unit two, with prompts. 

LUCK FILE7/N, PART 1 , PAR I 2 

Lock all files with five letter names that start 
with FILE, without prompts. Lock PARTI and PARI 2. 

LUCK * . 4TH, D2: MYF IL..E , PROS*/N 

Lock ail files with the extension 4TH giving 
verifv prompts. Lock MYF1LE on unit two, and 
all files beginning with PROG on the default unit, 
without prompts. 


NOTES: 


c 


LX 1 1 - 17 


val DOS Commands 


NAMED I SK 

Name a diskette. 


STATUS: 

User memory at PAD is untouched. 
COMMAND FORMAT: 


NAMED I SK {unit} 


OPERA T I ON ; 


I he val DOS tile system allows disks to named for 
identification. Currently, this name is displayed only m 
directory listings, but is available for user programs. The 
NAMED I SK command displays the name of the disk in the specified 
unit and prompts for the new name to be entered. Disknames mav 
be up to 20 characters long, and any character mav be included 
within that name. 


EXAMPLE: 

NAMED I SK 


Rename the disk in unit three. 


NO T ES : 


Disks named in val DOS will 
DOS's tor the Atari computers. 


function properly in other 


LX 1 1 


18 


val DOS commands 


o 

OPEN 

Open a file for access. 

STATUS: 

User memorv at PAD is untouched. 

COMMAND FORMAT : 

OPEN filename 


OPERATION: 

The OPEN command assigns a butter area and a tile access 
number to t.he specified file. 


EXAMPLE: 


o 


OPEN TEST . 4TH 

Opens the file TEST . 4TH on the default unit. 


NOTES: 

Files mav be multiply open, but are logically different 
files as far as the DOS is concerned. If a file is opened more 
than once and an operation such as ENDFIL is ^iven, l- is 
possible that the other opens will contain data in thei 
transfer buffers that technically no longer exists. Note also 
that' disks should not be exchanged when there are tiles open on 
the disk. 


o 


LX 11 


19 


v a 1 DOS Coman d 5 


OPEN? 

List all tiles currently open. 

STATUS; 

User memory at PAD is untouched. 


□PER AT I ON ; 


All files currently open are displayed 
associated file access numbers. 


along with 


EXAMPLE; 


OPEN? 


NOTES : 


- 20 


thei r 


L.XII 


valDOS commands 


F-R I NT 

Display a text tile on the current, output device. 
STATUS: 

User memory at PAD is untouched. 

This command is i nterruptabl e. 


COMMAND FORMAT: 


PR I NT til ename { /N > t, li nenum) 


OPERA I" I UN ; 

The contents ot the specified tile are sent to the current 
output device. Each line of text is automatically numbered 
unless the /N switch is present. If the optional line numbe 
specification is supplied, printing will beqin with that line 
of the file. 


EXAMPLES: 

PRINT GALAXY. 4TH 

Print the tile GALAXY. 4TH with line numbers. 
PRINT EDITOR. 4TH/N 

Print the file ED1I0R.4TH without line numbers. 
PR 1 NT D2 : M YP 1 LE . T XT , 5h 

Print the file MYPTLE.TXT on unit two with line 
numbers., beginning with the both line of text 
in the file. 

NOTES: 




LX II 


valDOS Commands 


( 

READ 

Read a file into memory. 


STATUS s 

User memorv between PAD and BUFBOT is untouched. 


COMMAND FORMATS! 

READ f i 1 enarne, addressi , count > 
READ f i 1 enum. address { , count} 


OPERATION: 


In the first form, the specified file is opened and the 
first "count" bytes are read into memory starting at the 
address specified. If the count is not specified, the entire 
file is read in. The file is left, closed. In the second form 
of the command, the first "count" bytes of the alreadv opened 
file are read into the specified address. The file is left 
open after the read is complete. Note that the address can be 
specified by a number or by a. single word (such as PAD) which 
returns a number. 


EXAMPLES: 


READ DRIVER. OBJ, PAD 


Read the entire file DRIVER. OBJ into the address 
specified by PAD. The file is then closed. 

READ 1,40960,1000 


Read the first 1000 bytes from the file specified 
by the file access number one into address 40960. 
The file is left open. 


NOTES: 


No check is made to see if the data is being read into 
memory occupied bv the FORTH dictionary. DOS buffers, 'or video 
memory. It is up to the user to supply safe load addresses. 


o 


c 


LX 1 1 


valDOS commands 


o 


RENAME 

Rename a file. 

STATUS: 

User memory at PAD is untouched. 


COMMAND FORTMAT: 

RENAME newname-ol dname 


OPERATION: 

The specified file is given the specified new name, 
must, not already exist a file with the same name 
specified new name or an error will result. 


o 


EXAMPLE: 

RENAME MYF I L E . 4TH=M YF I l-E 

The file MYFILE is renamed as MYFILE.4TH. 


NOTES: 


c 


There 
as the 


LX 1 1 


valDOS Commands 


REUI I MD 

Move the file cursor to the beginning of the file. 


STATUS: 


User memory at PAD is untouched. 


COMMAND FORMAT: 

REW I ND f i 1 enum 

OPERATION: 

1 he cursor of the specified -file is repositioned at 
beginning of the file. lhe file must already be open,. 

EXAMPLE: 


REWIND 1 

Rewind file number one. 


the 


NOTES: 


v a I DOS commands 


SETUN I T 

Set the default drive unit. 

STATUS: 

User memory at PAD is untouched. 


COMMAND FORMAT: 

SE T UN I T un i t 


OPERATION: 


Whenever a filename does not explicitly contain 
specification, the new default drive unit will be 
Units are numbered from one to four. 


a drive 
assumed . 


EXAMPLE: 

SET UN 11 2 

Set the default unit to two. 


NOTES: 


LX 11 


vaiDOS Commands 


UNLOCK 

Unprotect a -file so that it may be modified. 


STATUS: 


User memory at PAD is untouched. 


COMMAND FORMAT; 


UNLOCK 


f i lespecl C/NJ { , 


f i 1 espec21 /N > i , . . . j > 


OPERATION: 

„ no v . r .» y “* r ^ r « 
• , . ' liespec is ambiguous, a verify nrnmnf -i «= 

° v,ry m * • t ° ut *° »* unl „. thi /« sit;; 


EXAMPLES: 


UNLOCK THIS 


Unlock file THIS on the default drive unit. 
UNLOCK PART 1 . PART2 , PARTS , 03 : PART? 

Unlock files PART] , PART2, and PARTS from the 
default unit, and all files found on unit three 
with five letter names that begin with PART. 

UNLOCK * . BAS, * . BAK/N. D2: MYF I LE„ TEST. */N 

Unlock all files with the extension BAS qivinc 
verify prompts. Unlock all files with the 

Mv^p’ Dn BftK Without veri+ V prompts. Unlock 
unit two, and all files named TEST 
on the default, unit. 


NO TES; 


LX 1 1 


26 


valDOS commands 


l*JR I TH 

Write an area of memory to a -file 


STATUS; 

User memory at PAD is untouched* 


COMMAND FORMATS: 

WRITE fi 1 ename, address, count 
WRITE fi lenum, address, count 


OPERATION: 

In the first form, the first "count" bytes of memory at 

£■ «r. 

The address can be specified by either a number or a singl ■ 
word (such as PAD) which returns a number. 


EXAMPLES; 

WRITE MYFILE, PAD, 1000 

Write the 1000 byte block of memory at the addres 
sp©ci‘fi©d by PAD to MV FILE- 

Ia|R I TE 1 h 40960 , 256 

Write the first 236 bytes of memory at address 
40960 to the file associated with file access 
number one?. 


NOTES: 


27 


LX 1 1 


o 


T h e 


valDOS 


The following set of words make up the heart of the valDOS 
svstem. Note that all of the following words- are in a special 
vocabulary named DOS. Any word which uses one of these system 
operations must contain the word DOS in the definition, as it 
is necessary to inform the compiler where to look for these 
definitions. Since most of these commands are on the system 
level, a brief description of how the system works is 


appropr i ate. 

Before any file can be manipulated, it 
access. A file buffer and a status block 
each open file. Additionally, each fil 
cursor (which is positioned at the beginning 
time). This cursor always points to a 
file. If a byte is read from the file, the 
this cursor is returned and the cursor is 
into the file. When a byte is written to the 
the byte pointed to by the file cursor, and 


must be 
are all 
e has i 
of a f i. 
1 oc at ion 
byte poi 
moved a 
file, i 
the fil 


opened for 
ocated for 
ts own file 
le at open 
within the 
nted to by 
byte deeper 
t replaces 
e cursor is 


then bumped. 

Thus, if a 3 OK file is opened and five bytes are 
to the file, the first five bytes will be changed, 
remainder of the file will be left, untouched. If the 
then closed, the file will still be 10 k long. Most 
however, will "end-file" a file when it is closed, i 
this example, the file would be reduced to five bytes, 
implicitly end-filing a file when it is closed, 
flexibility is gained. Note that the valDOS commands 
COPY and EDIT) do implicitly perform an end-file p 


written 
and the 
file is 
BASICS, 

. e « , in 
By not 
greater 
(such as 
rior to 


closing a file. 

The two most, common operations are reading a file ana 
writing a file. Usuailv when reading a file, the file is 
opened, read to the end (eof), and then closed. Generally when 
a file is written, it is opened, written, end-filed, and then 
ci osed . 


LX 1 1 1 


1 


val DOS 


r 

y®iJSB§_Sy st em_ Words 


DOS 

This is the name of the vocabulary which contains all 
of the following DOS system words. DOS stands for' Disk 
Operating System (not Software as some claim). Any word 
which contains one of the following words must contain 
this word within its definition: : myword DOS 

DOS i s I MMED I ATE J 


SENTRIES n 

A quan which contains the number of entries that 
matched the (wild) filename last checked by CHKDIR. CHKDIR 
returns this value automatically. This value can also he 
used to index the first "n" elements of the table pointed 
to bv D.IRTBL (below). 


#FREE 


A 

entries 


n 

quan which 
in the last 


contains the number of free directory 
directory scanned by CHKDIR. 


#UNTRN n 

A quan which contains the number of bytes left 
untransferred in the last block read/write operation. This 
value is only accurate immediately after the read/write 
operation returns control to the calling routine. 


o 


<?OPEN> * if 13/0 

This routine checks to see if the file specified bv $ 
is open. If the operation is successful. a flag is 
returned along with the value one. If this flag is 0, the 
file is closed. If an error occurred, only a zero is 
returned. See DSKERR. This routine uses FNCON. 


(OPEN) * faddr fl# 13/0 

Ihis routine opens the file specified by $ „ It is 
used to create the necessarv data transfer path between 
the application and the DOS. If the open is successful, a 
file transfer buffer is allocated and is assigned a file 
access number. All subsequent operations upon the open 
file require that, this file number be supplied. On a 
successful open, the file number and the transfer buffer- 
address are returned. In most cases, the buffer address 
can simply be discarded, while the file number must be 
stored by the application. Pile numbers are always greater 
than zero. See DSKERR. This routine uses FNCON. 


c 


L XIII 


val DOS 


o 


(CLOSE) 

The 

associ ated 
buffer is 
subsequent 
channel s 
no errors.. 


(CLOSE) operation closes the data transfer path 
with the specified file number. The file 
flushed to disk if updated, and is freed for a 
open operation. If "fl#" is zero, all open 
are closed from access. This routine generates 
Illegal file numbers are ignored. 


Each open file has a file cursor which points to the 
next byte to be read or written. The "end file" operation 
marks the current byte as the end of t.he file. Thus if 
the file cursor points to the fifth byte of a 10K file, 
the current byte and all successive bytes are lost, and 
the disk space is reclaimed. This is typically used lust 
before closing a file that has been written to. _ This 
ensures that no "stale" data remains. The command b.NDI- 11- 
uses this routine. 


o 






The filename specified by * is entered into the 
directory on the unit specified within the filename. if 
no unit is explicitly stated, the default unit (specified 
bv DFLLJNT ) is assumed. A one is returned if the operation 
was successful, otherwise a zero is returned. See DSKERR. 
This routine uses FNCON. (This routine is usually called 
"create". That name is already used in FORTH, however.) 


> * — + 

The filename specified bv $ is deleted from the 
directory on the unit specified within the filename. If 
no unit is explicitly stated, the default unit (specified 
bv DFLUNT) is assumed. A one is returned if the operation 
was successful, otherwise a zero is returned. See DSKERR. 
This routine uses FNCON. 


The filename specified by $ is locked so that 
not be written to, killed, or renamed. A one is 
if the operation was successful, otherwise a 
returned. See DSKERR. This routine uses FNCON. 


it may 
returned 
zero is 


o 


LX 1 1 1 


val DOS 


(RDB) fl# {b 1J/0 

The "read byte" operation reads the next byte from 
the file whose access number is "fl#". If an error occurs 
a zero is returned, otherwise the byte along with a one is 
returned. If many bytes are to be read, (READ) should be 
used if possible as that routine is many times faster than 
(RDB). Note that if a read is attempted with the file 
cursor at the end of the file, an EOFERR error is 
generated. See DSKERR. 


(READ) addr cnt fl# f 

This operation reads the next "cnt" bytes of the file 
whose access number is "fl#" and stores them in memory 
beginning at "addr". If an error occurs a zero is 
returned, otherwise a one is returned. The quan #UNTRN 
contains the number of bytes left untransferred in the 
event of an error. See DSKERR. 


(REN) $n So f 

This operation renames the file $o to $n. A one is 
returned :i.f no error occurred, otherwise a zero is 
returned . 

o 

(SPACE) cnt: fl# f 

The space operation repositions the cursor of the 
file whose access number is "fl#" by the signed number 
"cnt". The value "cnt" must lie in the range of -32768 to 
32767. Also note that the file cursor cannot be spaced 
past byte no. 65,535 of the tile. If "cnt" is zero, the 
space operation is ignored. A one is returned if no error 
occurred, otherwise a zero is returned. 


(UNLOCK) $ f 

The filename specified by $ is unlocked so that it 
may be written to, killed, or renamed. A one is returned 
if the operation was successful. otherwise a zero is 
returned. See DSKERR. This routine uses FNCQN. 


(WIND) f fl# f 

The (WIND) command is used to position the file 
cursor at beginning or end of the file. If "f" is one. 
the file cursor is rewound to the beginning of the file. 
This allows the file to be re-read. If "f" is zero, the 
file cursor is moved to the end of the file for subsequent 
writing, effecting an append operation. A one is returned 
if the operation was successful, otherwise a zero is 
returned. See DSKERR. 


LX 1 1 1 


4 


val DOS 


(WRB) b + 1# — 

The byte "b" 
number is "fl#". If , 

tile, (WRITE) below should be used instead 


is written to the file whose access 
manv bytes are to be written to the 

as it is many 


times faster than (WRB) . 
operation was successful. 
See DSKEER ■ 


A one is returned if the 
otherwise a zero is returned. 


(WRITE) 


addr cnt fl# f 

The block of memory "cnt" bytes long beginning at 
memory location "addr" is written to the file whose access 
number is "fl#". A one is returned if the operation was 
successful, otherwise a zero is returned. See DSKEKR. 


-'DO! 


IERR 

Thi 
rout i lies 
is zero, 
control 
7D0SERR, 
ex amp 1 e , 
within ( 
to (OPE 
7D0SERR 
return 
quan DSK 
good ex a 
a SWAP 


f err# 
i is one of 
avai 1 abl e 
the system 
does not 
but to the 


three (see DOSERR 
at the system level, 
error "err#" is gener 

return to the word 
word which called th 
if an application calls (OPEN 

OPEN) generates an error, 7D0SERR w 
;iM) . but to the application, pass! 

does not generate an error, program 
to (OPEN). 7D0SERR stores the err 
ERR. Bee the actual definition of 
mple of how this is used. 7D0SERR 
Q— IP DOSERR END IF DROP 


7DSKERR) error 
If the flag "f" 
ated. Program 
which contained 
is word. For 
) and a 7D0SERR 
•ill not return 
ng a 0. If the 
control will 
or value in the 
(OPEN) for a 
is essentially 


7DSKERR f 

7DSKERR 
to the next. 
7D0SERR . 


is used to propogate an error from one word 
It replaces the sequence DSKERR 7D0SERR. See 


7WILD f 

This is a quan 
f i 1 ename converted 
card characters "7" 
cards aopeai'' ed - 


which contains a one if the last 
by FNCQN contains either of the wild 
or A zero is returned if no wild 


BUFBOT addr 

This is a word which returns the 
address used by the DOS file buffers. 


lowest memory 


LX III 


val DOS 


CHKDIR n 

The check-directory routine scans the directory on 
the unit specified within the last filename converted by 
FNCON for all occurrences of that filename. For every 
match found (multiple matches are due to wild cards) in 
the directory, a directory entry number is stored in the 
next available location of the memory block pointed to by 
DIRTBL. Thus if CHKDIR finds five occurrences of a 
filespec, the first five elements of DIRTBL. contain the 
directory entry numbers for those five matches. These 
values can then be used in conjunction with the ENTRY 
command to access the files. CHKDIR returns the number of 
matches. 


DFLUNT n 

A quan which contains the number of the default unit. 

I hi s drive number is assumed if no drive specification is 
contained within a filename converted by FNCON. Caution, 
this contains 0 if DOS drive 1 is the default, 1 if DOS 
drive 2 is the default, etc. (FORTH drive = DOS drive-1) 


DIRFRE n 

A quan which contains the entry number 
free entrv in the directory last scanned 
routine. 


of the next 
by the CHKDIR 


DIRTBL addr 

A word which returns the starting address of a 64 
byte memory block: that contains directory entry numbers of 
a.ll files that matched the last, filename checked by the 
CHKDIR routine. See CHKDIR. 


D I RUP 

This marks the current directory as being updated so 
that, it is written to disk upon the next DSKFLS command. 


DOSERR err# 0 

This is one of three (see 7DQSERR, 7DSKERR) error 
routines at the svstem .level. DOSERR unconditionally 
generates the error whose error number is "err#". Program 
control continues two levels up (instead of the usual one) 
and a zero is returned. See 7D0SERR. 


DSKERR 


DOS 


n 

A quan which contains 
error that occurred. See 


the error number of the last 
List, of Errors below. 


LX I II - 6 


va'l DOS 


DSKFLS 

A routine which 
free space map if 
should end with this 
pre-defined commands 


flushes the current directory and 
updated. All user defined commands 

command. See source listing tor 


ENTRY unit n addr 

The entry command returns the address of the "nth" 
entrv m the directory on the specified drive unit. The 
16 byte entry has the following format: 


addr+O; 


addr+1 : 
addr+3: 
addr+5: 


ad dr +13: 


status byte 

bit 7: File deleted it set 

6: File entry valid if set. 

5: File locked if set 
4: File random if set 
3: File; in use if set (not. used) 

2; Unused 

1: DOS format 2 if set 

0: File open for output if set 

length of file in sectors 
first (DOS) sector of file 
8 letter filename , 
left justified, blank filled 
3 1 et ter e;-: t en s i on , 
left justified, blank filled 


If any changes are made, executing DIRUP and DSKFLS will 
write those changes to disk. 


FL.BIJF3 fi# addr 

Whenever a file is opened, a 128 byte transfer buffer 
and a 16 bvt.e status block are allocated. The FLBUFS) 
command returns the address of the file status block 
associated with "fl#"« 1 he 16 byte table contains the 

following information: 


addr+0: 
addr+1 ; 


addr+3: 
addr+5: 
addr+7 : 
addr+8; 
addr+9: 
addr +10: 
addr+1 1 : 
addr+13: 
addr+14: 


ad dr- 128; 


File status byte (see ENTRY). 

Current size of file in sectors. 

If high bit is set, file is updated. 
First (1)08) sector of file. 

(FORTH) sector currently in file buffer. 
Number of bytes into current sector. 

Unit associated with the file. 

Entry number in the directory. 

Non-zero = current sector is updated, 
(reserved for) Current random block, 
(reserved for) Random block update flag. 
Number of bytes into file (unsigned). 
Address of 128 byte file buffer. 


L.XIII 


va] DOS 


FLFL.S fl# 

This operation flushes the 
with the file access number "fl#' 


file buffer associated 


FNCON $ f 

The FNCON command takes the file 
converts it to directory format (i.e., 
blank filled). It stores the 

at the memorv location pointed 


specification $ and 
left j ust i f i ed and 
11 byte formatted filename 
to by FNFLD. All wild 


cards are converted to question marks, thus, "MY7FIL*" 
will become "MY7F.1.L?????" . Additionally, if a drive 
specification is contained in the filespec, it is 
determined and stored in the quan UNIT. If no drive 
specification was supplied, the default unit (in DFLUNT) 
is stored in UNIT. FNCON will also parse out a single 
switch ("/«"> where the character "s" is stored in the 
quan FMSWCFI. If no switch is found, a zero is stored in 
FNSWCH. If any wild cards appear in the file 
specification, the quan 7WILD is set to one, otherwise 
zero is stored. If no errors were detected, a one is 
returned, otherwise zero. 


FNFLD ad dr 

A pointer to an eleven byte storage 
contains the filename last formatted by FNCON. 


whi ch 


FNSWCH s 

A quan which contains the ASCII value of the switch 
in the last filename converted bv FNCON. If no switch was 
present, FNSWCH contains zero. See FNCON. 


F SNAP a d d r 

A word which i* eturns the address of the current free 
space map. 


FSMUP 


The FSMUP 
being updated. 


command 


marks 


the current free space map as 


MAXFL 


A constant which contains the maximum number of files 
that. can be open at any given time. This has a default 
value of four. If this constant is changed. valDOS must 
be completely reloaded. 


LX I I 1 


8 


val DOS 


( I 

VADR n 

After a block read/write operation, this quan 
contains an address one byte higher in memory than that of 
the last byte transferred. This can be used to determine 
how much data was transferred in the event of an error. 


UN I T n 

A quan which contains the unit specification of the 
last filename converted by FNCON. Note that this is a 
FORTH unit li.e., FORTH unit = DOS unit-1). 


WRKSPC addr 

A quan which points to a 128 byte scratch area used 
by many of the system words described above. This is free 
for user applications between val DOS system calls. 


o 


o 


lx i n 


9 


val DOS 


ysl DOS _Command_. SuBBgrt_ Words 


7CMDERR n err# 

Like 7D0SERR, but prints the error message, clears 
both stacks, and aborts program execution through QUIT, if 
the status flag "n" is zero. If "n" is true, 7CMDERR 
returns to the calling word. 


7SYSERR n 

Like 7DSKERR, but aborts through 7CMDERR if "n" is 
zero. If "n" is non-zero, 7SYSERR returns to the calling 
wor d . 


?WR6ARG n 

This is an abbreviation for WR6ARG 7CMDERR . 


CQNFN addr unit $ 

The CONFN routine takes the directory formatted 
filename at "addr" (usually FNFLD) and converts it to a 
string. I he drive specification "unit" is attached to the 
beginning of the filename (i.e., unit = 0 would generate 
"Dli"). 


CM DERR err# 

Like DQSERR, CMDERR unconditionally generates the 
error specified bv "err#". 


ECHO ON/OFF 

When echo is ON, all files being FLOADed will be 
echoed to the current output device(s). When echo is OFF. 
no output is generated. 


FWORD c 

Read the next text characters from the input file 
whose file number is in the quan FL.FL# (FLOAD initializes 
FLFL#) until a delimiter "c" is found, storing the packed 
character string beginning at the dictionary buffer HERE. 
FWORD leaves the character count in the first byte, 
followed by the characters, and ends with two or more 
blanks. Leading occurrences of "c" are ignored. Note 
that "c" may not be the return character (ATASCII 155). 


LX 1 1 1 -10 


val DOS 


(3ETVAL * n 

1+ ¥ is the name of a dictionary word, the word is 
executed and had better return a single value. If ¥ is 
not found in the dictionary, it is assumed to be a number 
and is converted leaving the number n. GETVAL is used so 
that addresses may be stated explicitly, 

(PAD. HERE, etc.). 


or by reference 


GETARGS C* 11/0 

This routine converts the next non-blank 
characters in the input stream to a string. If a 
non-blank characters is found, it is returned along 
one. If no set is found, a zero is returned. 


set of 
set of 
with a 


GETAR6 ¥ c C¥i ¥2 13/{¥ Q> 

The string ¥ is divided into two parts, broken at the 
first occurrence of the character "c". If the character 
"c" is found in ¥, the leftmost portion of ¥ is returned 
3rd on stack, the rightmost 2nd on stack, and 1 on top. If 
"c" is not in the string, the original string along with 0 
is returned. 


LX 1 1 1 -11 


val DOS 


§Y5fe§ffi Jfceqcs i§11...3Ci_Q5fc!§I6W.Is2. 


AMBNME n 

Ambiguous filename. This error is generally issued 
when a filespec containing wild cards is passed to one of 
the primitive file operators like (OPEN) or (KILL). 

BADFL# n 

Bad file number. The error is generated when a file 
number does not lie in the range 1 < fl# < MAXFL (default 
of four ) . 

BADFSM n 

Bad tree space map. This is issued when the number 
of free sectors does not match the true number of free 

sectors. If this error is reported, a new disk should be 

made and all files should be transfered to this new disk 
using COPY or FMOVE. 

BADNME n 

Bad filename. The filename passed to the system 
routine contained an illegal character, or was too long. 
File names can only contain the letters "A" through "Z" 
and the digits "O" through "9". Note that the first 

character of a filename must be a letter. The two wild 

card characters "?" and are also allowed. 

BADUN'T n 

Bad drive specification. A drive number was 
encountered that did not lie in the range 1 < unit < 4. 

D I RFUL n 

Director'/ is full. There is no more room in the 
directory. Kill some unwanted files and try the operation 
agai n 

DSKFUL n 

Disk is full. There are no more free sectors on the 
disk. Kill some unwanted files and try the operation 
agai n . 

EQFERR n 

End of file has been reached. This error generally 
results from an attempt to read data past the end of file 
mark . 


FLDNE n 

File does not exist. 

FLEXST n 

File already exists. 


L X 1 1 1 -12 


valDCJS 


o 


o 


FLNOPN n 

File is not open. Use 
file. This error should 
primitives like (SF'ACEI) and 

FLOFN n 

File is open. Use the 
appropriate file. See OF'EN? 


the OPEN command and open the 
onlv occur when using the file 
(WIND) . 


CLOSE command to close the 


FLTBG n 

F r ile is too big. This error is usually reported by 
the file editor when there is not enough free memory to 
edit the tile. Break the file into two parts, or use the 
FORGET command to free some memory. 


FLWPRT n 

file is write protected (locked). Use the UNLOCK 
command and perform the last operation again. 


TMFOPN n 

Too manv files open. For each file open, a file 
buffer and a file status block is allocated. There are a 
limited number of available buffers (determined by the 
constant. MAXFL) , If ail buffers are being used and an 
open operation is attempted, this error will be generated. 
Use the CLOSE command to free a buffer. 


WRGAKG n 

Bad/no argument list. This is generated 
command expects a list, of arguments and none is 
This is also generated when the wrong number 
arguments is supplied. 


when a DOS 
suppl i ed . 
or type of 


o 


L.X III -13 


c 


O 


A_.nqtet.gn_.Qy AN structures 


The "quan " is a new FORTH data structure, developed at 
Vaipar, and is used in this package. Quans were devised to cut 
down on wasted memory and runtime encountered when using the 
"variable" data structure. Quans work as -follows: (Advanced 

users may want to follow along in the source code for these 
structures also. 

Defining a quan: 

QUAN BINGO 

Note that quans do not take initial values. This form was 
chosen to allow for simpler upgrading to target-compiled code 
later on. 

Giving a quan a value: 

1234 TO BINGO 


Note that since TO is immediate, "TO BINGO" compiles to only 2 
bytes instead of the 4 bytes that would be required if BINGO 
were a variable (i.e., BINGO !). 

Getting the value back from a quan: 

BINGO 


Simply saying the name 
stack, in this case 
constants. BINGO above 
the 4 bytes required 
BINGO 3) . 


of the quan will leave its value on the 
1234. In this way, quans act like 
also compiles to only 2 bytes instead of 
to fetch it if it were a variable (i.e., 


Getting the address of the data in the quan: 
AT BINGO 


This will leave the address of the first byte of data in 
BINGO on the stack, or compile the address as a literal if 
encountered during compilation. (AT is immediate.) This is 
useful for a variety of purposes in general programming and in 
interfacing to machine language routines. 


Advanced users: 


The FORTH 
"non-state-smart " 
applications. We 
"non-state-smart. " 
different users. 


83 Standard appears to lean toward 
words. which is proper for target-compiled 
expect to support both "state-smart." and 
versions of various words, as appropriate for 


Note that while 


15 AT BINGO +! and 15 BINGO + TO BINGO 


accomplish the same task and take the same amount of memory, 
the first version is faster by one primitive nest. 

The most significant internal feature of a quan is that it 
has 3 cfa’s instead of just the one common to most FORTH words. 


This initial four byte disadvantage is overcome at the second 
use of a quan, and so poses essentially no problem. When a quan 
is not preceded by "TO" or "AT", the first cfa <quan®> is 
compiled in. If the quan is preceded by "TO", the second cfa 
(quan!) is compiled in. And if the quan is preceded by "AT", 
the third cfa ('quan) is compiled into the dictionary. 


val DOS File Editor 


Version 1.0 
Oct. 1982 


The FORTH language is a very powerful addition to the 
Atari home computer. F'rograms which are impossible to write in 
BASIC < usual 1 y because of limitations in speed and flexibility) 
can almost alwavs be written in FORTH. Even when one has 
mastered the BASIC; language, making corrections or additions to 
programs can be tedious. The video editor described here 
removes this problem from the FORTH environment. Similar to 
the MEMO PAD function in 


editor makes it possible 
code, insert and delete 
insert and replace modes, 


the Atari operating system, this 
to insert, and delete entire lines of 
single characters, toggle between 
move entire blocks of text, and much 


I 


o 


o 


c ' 


File Editor 


Overview 


This editor is a powerful, extension to the val FORTH system 
designed specifically for the Atari 400/800 series of 
microcomputers. The main purpose for this editor is to give 
the FORTH programmer an easy method of text entry to DOS file 
for subsequent compilation. For those already familiar with 
the val FORTH 1.1 screen editor, this editor is very similar in 
function. In fact, all of the commands found in that editor 
(except ctrl-A) are supported in the file editor. More 
importantly, many additional capabilities have been added to 
this editor. They are: 

1) Tab stops can be set/reset 

2) Splice (unsplit) is now supported 

3) Global pattern searches 

4) A repeat function which repeats the next 
command /key typed until a console key is pressed 

5) File merge (i.e., reading a file into a file) 

6 ) True si ngl e-/mul t- line scrolling either 
forward or backward 

7) Input and output files may be different 


The editor has four basic modes of operation: 


1) It allows entering of new text into a file as 
though typing on a regular typwriter. 

2) It allows simple modification of any text 
with a powerful set of single stroke 
editing commands. 

3) It pinpoints exactly where a compilation error 
has occurred and sets up the editor for 
immediate correction and recompilation. 


The set of single stroke editing commands is a superset of 
the functions found the in ME!MQ PAD function of the standard 
Atari operating system. In addition to cursor movement, single 
character insertion/deletion, and line insertion/deletion, the 
editor supports a cl ear-t.o-end-of-1 i ne function, a split 
command which separates a single line into two lines, its 
complement splice (unsplit), global searches, and many other 
features usually found only in higher quality word processors, 
and almost never in file editors. 

Also provided is a visible edit storage buffer which 
allows the user to move, replace, and insert up to 320 lines of 
text at a time. This feature alone allows the FORTH programmer 
to easily reorganize source code with the added benefit of 


LX IV 


1 


File Editor 


knowing that re-typing mistakes are avoided. Usage has shown 
that, once edit-buffer management is learned, significant typing 
and programming time can be saved. 

For those times when not programming, the editor can 
double as a simple word processor for writing letters and 
filling other documentation needs. Perhaps the best method for 
learning how to use this powerful editor is to enter the edit 
mode and try each of the following commands as they are 
encountered in the reading. 


NOTE: 


this editor can be used to enter assembly language source, 
Pascal, or any other text oriented data. The only limitation 
upon this is that no lines may be longer than 38 characters in 
length. Additionally, this editor can edit files created from 
other sources 5 however, only the first 38 characters of a line 
will be retained. 


LX IV 


File Editor 


Load ing._and_.Ent ©ring the_Editgr 


To load the editor, first load valDOS as described in 
"Strolling Through valDOS". Next, insert, the valDOS II disk 
and list screen 1/0. This should tell you exactly which screen 
to load. The edit mode is initiated using the EDIT command, 
this command has the following format: 


EDIT infilet, outfileJ 

The DOS file "infile" is loaded for editing. When all changes 
have been made and the file is saved, the modified text is 
written to the file "outfile", if supplied, otherwise it is 
written back to "infile". 

Insert a copy of your valDOS II disk and type: 


EDIT FILEIT. 4TH, MYFILE 


The editor will display some information which can be ignored 
for the time being, and then it will wait for the return key to 
be typed . After pressing the return key, the display should 
look like fig. 1. 

The top window, composed of a single line, indicates which 
tile is currently being edited. Also shown is the size of the 
edit buffer (decribed later). In this example, the buffer is 
five lines in length. This window is known as the heading 


window. 

The second window (the text window) contains 16 lines of 
text within the specified file- This window is -38 characters 
wide and 16 lines high. The white cursor (indicated by the 
symbol "®"' will be in the upper-1 efthand corner of the display 
awaiting editing commands. 

The final five-line window found at the bottom of the 
display is known as the buffer window. This is used for 
advanced editing and is described in greater detail in the 
section entitled "Buffer Management. " 


LX IV 


File Editor 


c 

File: MYFILE #Bufs: 5 ! 


SI 

( Routine: FILE- IT 

The -following routine will 
transfer a specified range of 
FORTH screens to a file on 
a DOS formatted disk. 

Format: FILE- IT 1st , 1 ast , f i lename 

FILE— IT 10, 20, MYFILE 

Note that DOS commands tend to be 
1 ono because of error checking and 
parameter parsing. ) 


o 


Fig. 1 


re-edit last file ( ) 

This command is used to re-edit the "Last" file 
edited. It functions identically to the EDIT command, 
except that no file names need to be specified. 

Example: LL <ret> ( re-edit MYFILE > 


( 


LX I V 


4 


File Editor 


WHERE find location of error < > 

If, when compiling code, a compilation error occurs, 
the WHERE command will enter the edit mode and position 
the cursor over the last letter of the offending word. The 
word can then be fixed and the file saved for subsequent 
compilation using the "F'LOAD filename/C" command. 


#BUFS set buffer length ( #lines ) 

The #BUFS command allows the user to specify the 
length (in terms of number of lines) of the special edit 
storaae buffer. The power of the edit buffer lies in the 
number of lines that, can be stored in it. Although the 
default value is five, practice shows that at least 16 
lines should be set aside for this buffer. The maximum 
number of lines allowable is 320 which is enough to hold 
20 full screens simultaneously. 


.INFO display file information ( > 

If an error occurs and an edited file is not saved to 
disk, the .INFO command will supply all the necessary 
information to save the file using the WRITE command. 


c 


LX IV 


File Edi tor 


The -following sections give a detailed description of all 
commands which the video editor recognizes. A quick reference 
command list can be found following these descriptions. 


Cursor Movement 


When the edit mode is first entered via the EDIT command, 
a cursor is placed in the upper lefthand corner of the screen. 
It should appear as a white block and may enclose a black 
letter. Whenever any key is typed and it is not recognized as 
an editor command, it is placed in the text window where the 
cursor appears. Likewise, any line functions (such as delete 
line?) work on the line where the cursor is found. 


Ctrl T , Ctrl 'k , Ctrl , Ctrl * move-cursor commands 

To change the current edit line or character, one of 
four commands may bo? given. These are known as cursor 
commands. They are the four keys with arrows on them. 
These keys move the cursor in the direction specified by 
the arrow on the particular key pressed. There are times, 
however, when this is not the case. 

Similarly, if the cursor is positioned on the 
leftmost edge and the "cursor-left" command is given, the 
cursor will "wrap" to the rightmost character. Issuing 
"cursor-right." will wrap to the left edge. 


RETURN next -line command 

The RETURN key positions the cursor on the first 
character of the next line. If RETURN is pressed when the 
cursor is on the last line of the file, a line is inserted 
at the end of the file. 


TAB tabulate command 

The TAB key is used to tabulate to the next TAB stop 
to the right of the current cursor character. 


LX I V 


6 


File Editor 


c 


Ctrl TAB 


clear TAB stop 


Clear the tab stop at the current cursor location. 
The default tab stops can be reset by issuing the RT 
subcommand . 


shift TAB 

Set a 
default tab 


set TAB stop 

tab stop at the current cursor location, 
stops can be reset by issuing the 


subcommand » 


ctrl L 


continue search 


Search for the next occurrence of the pattern set up 
using the PS subcommand. Patterns can be up to 3u 
characters in length. 


o 


y enter subcommand mode 

The puts the editor into the subcommand mode. See the 
section entitled "Subcommands" for a list of available 
commands. 


NOTE: 

lianv commands in the editor will "mark" the file as 
updated so that any changes made can be preserved on disk. As 
simple cursor movement does not change the text window in anv 
wav, these commands never mark the file. 


o 


LX IV 


File Editor 


Editi.ng_Co m m artds 


Editing commands are those commands which modify the te>;t. 
in some predefined manner and mark the tile as updated for 
later saving. 


Ctrl INS character insert command 

When the "insert-character" command is given, a blank 
character is inserted at the current cursor location. The 
current character and all characters to the right are 
pushed to the right by one character position. The last 
character of the line "falls off" the end and is lost. The 
inserted blank then becomes the current cursor character. 
This is the logical complement to the "delete-character" 
command described below. 


Ctrl DEL 


delete character command 


When the 
current cursor 
the right of 


“delete-character " command is issued, the 
character is removed, and all characters to 
the current cursor character are moved left 


one position, thus giving a " sqeeae" effect. This is 
normally called "closing" a line. The rightmost character 
on the line (which was vacated) is replaced with a blank. 
This serves as the logical complement to the 
"insert-command" described above- 


shift INS line insert command 

The "line-insert" command inserts a blank line 
between the current cursor line and the line immediately 
above it. If this command is accidentally typed, the 
"oops" command (ctrl-D) described later can be used to 
recover from the mistake. Also see the "from buffer" 
command described in the section on buffer management for 
a similar command. This command serves as the logical 
complement to the "line-delete" command described below. 


LX IV 


S 


File Editor 


shi-ft DEL Line delete command 

The "line-delete" command deletes the current cursor 
line. It this command is accidentally issued. recovery 
can be made by issuing the "oops" command (ctrl-O) 
described later. Also see the "to-buffer" command 
described in the section on buffer management for a 
similar command. The "delete-line" command serves as the 
logical complement to the "line-insert" command. 


c trl H erase to end of line 

The "Hack" command performs a clear — to-end-of-1 ine 
function. The current. cursor character and all 
characters to the right of it on the current line are 
blank filled. All characters blanked are lost. The 
"oops" command described later can be used to recover from 
an accidentally hacked line. 


ctrl 1 insert/repl ace toggle 

In normal operation. any key typed which is not 
recognized by the editor as a control command will replace 
the current cursor character with itself. This is the 
standard replace mode. Normally, if one wanted to insert 
a character at the current cursor location, the insert 
character command would have to be issued before any text 
could be entered. If inserting many characters, this is 
cumbersome. 

When active, the insert submode automatically makes 
room for any new characters or words and frees the user 
from having to worry about this. When the editor is 
called up via the EDIT command, the insert mode is 
deactivated. Issuing the insert toggle command will 
activate it and the cursor will blink, indicating that the 
insert mode is on. Issuing the command a second time will 
deactivate the insert mode and restore the editor to the 
replace mode. Note that while in the insert mode, ail 
edit commands (except BACKS, below) function as before. 


LX IV 


9 


File Editor 


BACKS delete previous character 

The BACKS key behaves in two different ways, 
depending upon whether the editor is in the insert mode or 
in the replace mode. When issued while in the replace 
mode, the cursor is backed up one position and the new 
current character is replaced with a blank. If the cursor 
is at the beginning of the line, the cursor does not move, 
but the cursor character is still replaced with a blank. 

If the editor is in the insert mode, the cursor backs 
up one position, then deletes the new current cursor 
character and then closes the line.. If the cursor is at 
the beginning of the line, the? cursor remains in the 
same position, the cursor character is deleted and the 
line closed,. 


NOTE: 


As all of 
manner, the file 
ensure that all 


the above 
is marked as 
chanaes made 


"quit" command described later allows one 
session so that major mistakes need not be 


commands modify the tile in some 
having been changed. This is to 
are eventually saved on disk. The 


to abort 
saved . 


the edit 


o 


l 


L.XIV 


10 


File Editor 


§!-_Managgment 


Much of the utility of the -file editor lies in its ability 
to temporarily save text in a visible butter. To aid the user, 
it is possible to temporarily send text to the butter and to 
later retrieve it. This storage butter can hold as many as 320 
lines of text simultaneously. This butter is viewed through a 
5 line "peephole" visible as the last. window on the screen. 
Using this butter, it is possible to duplicate, move, and 
easily reorganize text, in addition to temporarily saving a 
line that is about to be edited so that the original form can 
be viewed or restored if necessary. The following section will 
explain exactly how to accomplish each of these actions. 


Ctrl T to buffer command 

The "to-buf ter" command deletes the current cursor 
line, but unlike the "delete— 1 ine" command where the line 
is lost, this command moves the "peephole" down and copies 
the line to the bottom line of the visible buffer window. 
This iine is the current buffer line. The buffer is 
rolled upon each occurrence of this command so that it may 
be used repeatedly without the loss of stored text. 

For example, it the cursor is positioned on ninth 
line of the display shown in figure 1 and the "to-buffer" 
command is issued twice, the final result will be as shown 
in figure 2. 


Ctrl F from buffer command 

The "f rom-buf f er " command does exactly the opposite 
of the "to-buffer" command described above. It takes the 
current buffer line and inserts it between the current 
cursor line and the line above it. The cursor line and 
all lines below it are moved down one line. If the cursor 
were placed on line 14 of the above screen display and the 
"f rom-buf fer" command were issued twice, the display shown 
in figure 3 wou 1 d result. 


— 1 . 1 


LX I V 


File Editor 


File: I1YF1LE 


#Bufs: 5 


current 


( Routine: FILE- IT 

The following routine will 
transfer a specified range of 
FORTH screens to a file on 
a DOS formatted disk. 

19 

Note that DOS commands tend to be 
long because of error checking and 
parameter parsing. ) 


: FILE -IT DOS ( — ) 

GET ARBS 7WRGARG 44 GET ARB 7WRGARG 


current 


Format: FILE— IT 1st . 1 ast , f i 1 ename 

FILE— IT 10. 20. MYFILE 


fig. 


— 12 


LX IV 


File Editor 



File: MYFILE 


#Bufs: 5 

1 







( Routine: FILE- IT 

The following routine will 
transfer a specified range of 
FORTH screens to a file on 
a DOS formatted disk. 

Note that DOS commands tend to be 
long because of error checking and 
parameter parsing. 

a Format: FILE- IT 1 st f 1 ast „ f i 1 ename 

FILE- IT 10. 20, MYFILE 
: FILE- IT DOS < — > 


Format: FILE-IT 1 st , 1 ast. , f i 1 ename 

FILE- IT 10. 20. MYFILE 


fig. 


Ctrl K 


copy 


to buffer command 


The "copy— to— buffer" command takes the current cursor 
line and duplicates it. sending the copy t.o the buffer. 
The cursor is then moved down one line, this commands 
functions identically to the "to-buffer" command described 
above. except that the current, cursor line is NOI deleted 
from the text window. 


ctr 1 


U 


copy from buffer 


The "copy-f rom-buf f er " command replaces the current 
cursor line with the current buffer line. This command 
functions identically to the "f rom-buf ter " command 
described above. except that the buffer line is not 
inserted into the text window, it merely replaces the 
current cursor line. The "oops" command described below 


— i: 


LX IV 


File Editor 


can be used to recover from accidental. usage of this 
command . 


( 


ctrl R roll butter 

The "rol 1 -butter " command moves the butter "peephole" 
down one line and redisplays the visible window. It the 
butter were the minimum tive lines in length, the bottom 
tour lines in the window would move up a line and the top 
line would "wrap" to the bottom and become the current 
butter line. It there were more than tive butter lines, 
the bottom tour lines would move up a line, the topmost 
line would be pushed up behind the peephole, and a new 
butter line coming up trom below the peephole would be 
displayed and made current. For example, it the butter 
were tive lines long and contained; 


Current : 


( Who? ) 

< What? ) 
( When? ) 

< Where? ) 
( Why? ) 


fig. 5 

the "rol 1 -buff er " command gives: 


o 


! ( What? > 

! ( When? ) 

! ( Where? ) 

! ( Why? ) 

Current; ! ( Who? ) 


fig. 6 


Ctrl B back-rol 1 -buffer command 

The "back-roll-buffer" does exactly the opposite of 
the "rol 1 -buff er " command described above. For example, 
if given the buffer in fiqure 6 above, the "back-roll" 
command would give the buffer shown in figure 5. 

c 

— 14 


LX IV 


File Editor 


o 

c trl C clear butter line command 

The "clear-butter-line" command clears the current 
butter line and then "back-rolls" the butter so that 
successive clears can be used to erase the entire butter. 


NOTE: 

Any ot the above commands which change the text window 
will mark the tile as updated. Those commands which alter on.lv 
the butter window (such as the "roll" command) will not change 
the status ot the current screen. 


o 


c 


LX IV 


15 


F-ile Editor 


§EC.QlIi DS 


Ctrl X 


previous line command 


The "previous-line" command scrolls the text window 
up a line within the tile. 


Ctrl E 


next line command 


The "next-line" command moves the text window down a 
line within the -file,. 


Ctrl P 


previous page command 


The "previous-page" command scrolls the text window 
up 16 lines within the file. 


Ctrl N next 

The "next-page" command moves 
lines within the file. 


page command 

the text window down 16 


Ctrl S 


save command 


The "save" command saves any changes made to the 
current file and exits the edit mode. 


ctr 'l G quit command 

The "quit" command aborts the edit. session 
"forgetting" any changes made to the text file in memory. 
1 he "quit" command is usually used when either the wrong 
file has been called up, or if it becomes desirable to 
start over and re-edit. 


LX IV 


16 


File Editor 


Special Commands 


There are -four 
greater flexibility 


special commands in this editor which allow 
in programming on the valFORTH system: 


ESCAPE special key command 

The "special -key" command instructs the video editor 
to ignore any command function of the next key typed and 
•force a character to the screen,, For example, normally 
when "ctrl is typed, the cursor is moved right. By 

typing "ESCAPE Ctrl •>" the cursor is not moved 
rather, the right-arrow is displayed. 


Ctrl J 


split line command 


Often times, for formatting reasons, it is necessary 
to "split" a line into two lines. The split line command 
takes all characters to the left of the cursor and creates 
the first line, and with the remaining characters of the 
original line, a second line is created. Braphicallv, 
this looks like: 

before: ! The quickfflbrown fox lumped . ! 


after : 


! The quick® 

! brown fox jumped. 


Ctrl G 


splice (unsplit) command 


'f he 

operation 


"splice-command" performs just 
of the "split-command" above. 


the 


opposi te 


c trl Y repeat command 

The "repeat-command" repeats the next. command or 
character typed until a predefined stop condition occurrs, 
or until a console key is pressed. This is used mostly 
with the previous/next page commands for continuous 
scrol ling. 


LX IV — 17 


File Editor 


( 


Ctrl 0 oops command 

Occassi onal 1 y , a line; is inserted or deleted 
acci dental 1 y , halt a line cleared by mistake, or some 
other major editing blunder is made. As the name implies, 
the "oops" command corrects most of these major editing 
errors. The "oops" command can be used to recover from 
the following commands: 


1) 

insert line command 

( shift 

INS) 

2) 

delete line comand 

< shift 

DEL) 

3 ) 

hack command 

(Ctrl 

H) 

4) 

to buffer command 

(Ctrl 

T ) 

5 ) 

from buffer command 

(Ctrl 

F) 

6) 

copy from buffer command 

(Ctrl 

U> 

7) 

split line command 

(ctr 1 

J) 

8) 

splice command 

(ctrl 

B> 


o 


( 


LX IV 


18 


File Editor 


Subcommands 

The subcommand is entered by typing ctrl-V. The display 
will be cleared and a prompt "> will be issued. The 


Following commands 

may be typed in response. 

ST < return > 

Make the current line the start of the 
File, (i.e., hack off the beginning) 

EN < return > 

Make the current line the end of the 
File. (i . e., hack off the end) 

F'L. <return> 

Position the cursor on the first line 
of the file. 

LL < return > 

Position the cursor on the last line 
of the File. 

RT < ret urn > 

Reset the TAB stops to their original 
setti ngs. 

PB <return> 

Enter the pattern search submode. The user 
will be prompted to enter the search string. 
The ctrl-L command will continue the search. 

IF filename <r 

■eturn> 

Insert the specified File into the File 
fust after the current cursor line. This 
is useful For pulling subroutines From 
another File. This can be stopped at any 

time by pressing a console key. 


LXIV 


19 


F i 1 e Editor 


iditor_Command_Symmary 

Below is a quirk reference list of all the commands which 
the video editor recognizes. 

Entering the Edit Modes (executed outside of the edit mode) 


edi r 

i n f i 1 e-C , outf i 1 e) < j 

tnl ur the edit mode and edit "infile". If 
“outf ile" is specified,, send edited text 
to "outf ile", otherwise send it "intile". 

LL 

< ) 

Re-edit, the last file edited. 

WHERE 

( ) 

Enter the edit mode and position the 
cursor over the word that caused a 
compilation error. 

#BUFS 

< #1 i nes ) 

Sets the length (in lines) of the storane 
buffer. The default is five. 

. INFO 

( ) 

Display memory allocation of the current file 
so that it may be saved using the WRITE 
command, (used in case of a save error) 

Cursor Movement; 

: (issued within the edit mode) 

Ctrl r 

Move cursor up one line, scrolling the 
file down one line if necessary. 

Ctrl y 

Move cursor down one line, scrolling the 
tile up one line if necessary. 

Ctrl 4 

Move cursor left one character, wrappma 
to the right edge if moved off the left. 

Ctrl 4 

Move cursor right one character, wrapping 
to the left edge it moved off the right. 

RETURN 

Position the cursor at the beginning 
of the next line. Insert line if at the 
end of the file. 

TAB 

Advance to next tabular column. 
LX IV — 20 


LX I V 


File Editor 


Ctrl TAB 

Clear tab stop at current cursor location. 

shift TAB 

Set tab stop at current cursor location. 

Editing Commands: 

(issued within the edit mode) 

Ctrl INS 

Insert one blank at cursor location. 

Ctrl DEL. 

losing the last character on the line. 
Delete character under cursor, closing 
the line. 

shift INS 

Insert blank line above current line. 

shift DEL 

Delete current cursor line, closing the 
f i 1 e . 

Ctrl M 

Insert blank line below current line. 

Ctrl I 

Togql e i n serf. -mode /repl ace-mode, 
(see full description of ctrl-I). 

BACKS 

Delete last character typed, if on the 
same line as the cursor. 

Ctrl H 

Erase to end of line (Hack). 

Ctrl V 

Enter the subcommand mode, (see below) 

Buffer Management: 

(issued within the edit mode) 

Ctrl T 

Delete current cursor line sending 
it I'D the edit buffer for later use. 

Ctrl F 

Take the current buffer line and insert 
it above the current cursor line. 

Ctrl K 

Kopy current cursor line sending 
it to the edit buffer for later use. 

Ctrl IJ 

Take the current buffer line and copy 
it to the current, cursor line. Unkopv 

L. 

4-= 

u 

Roll the buffer making the next buffer 
line current. 

Ctrl B 

Roll the buffer Backwards making the 

Ctrl C 

previous buffer line on the screen current 
Clear the current buffer line and 
performs a ctrl-B. 


Note: the current buffer line is last line visible in the 

buffer window. 


File Editor 


Scrol 1 ing/Savi ng: 

(issued within the edit mode) 

Ctrl X 

Scroll the edit window up a line 
within the file. 

Ctrl E 

Scroll the edit window down a line 
within the file. 

Ctrl P 

Scroll the edit window up 16 lines 
within the file. 

Ctrl IM 

Scroll the edit window down 16 lines 
within the file. 

Ctrl S 

Save the changes made to the current 
file and exit the edit mode. 

Ctrl 0 

Quit the edit session forgetting all 
changes made to the current file. 

Special Keys: 

(issued within the edit mode) 

ESC 

Do not interpret the next key typed 
as any of the commands above. Send 
it directly to the screen instead. 

Ctrl J 

Split the current line into two lines 
at the point where? the cursor is. 

Ctrl (3 

Splice (unsplit) the current line and 
the? line above it. 

Ctrl 0 

Corrects any major editing blunders. Oops! 

Ctrl L 

Continue searching for the pattern entered 
in the subcommand mode. Look 

c t r 1 Y 

Enter the repeat mode. The next command 
or character typed will be repeated until 
a stop condition is met, or until a console 
key is pressed. Used most.lv with Ctrl p, 
ctrl-M, and the cursor commands. 

Subcommands: 

(entered in the subcommand mode) 


The subcommand is entered by typing ctrl-V. The display 
will be cleared and a prompt ("; ") will be issued. The 


following commands 

may be typed in response. 

ST (return) 

Make the current line the start, of the 
file, (i.e., hack off the beginning) 


LX IV 


File Editor 


EN '"return > 

Make the current line the end o-f the 
file,, (i.e., hack off the end) 

FL. <return> 

Position the cursor on the first line 
of the file. 

LL < return > 

Position the cursor on the last line 
of the file. 

RT < return 15- 

Reset the TAB stops to their original 
settings. 

PS <return> 

Enter the pattern search submode. The user- 
will be prompted to enter the search string 
The ctrl -L command will continue the search 

IF -filename 

< return > 

Insert the specified file into the file 
just after the current cursor line. This 
is useful for pulling subroutines from 
another file. This can be stopped at any 

time by pressing a console key. 


c 


o 


o 


( 


val DOS I 


Supplied Source Listing 

G 

L XV. 


c 


C i 


o 


u 


Screen: 10 

0 ( valDOSs 

1 ' ( QUAN 


quans and constants 
) ( 150 LOAD ) 


Screen: 13 

0 < val DOS: 

1 


arrays 


2 

• ( CARRAY ) ( 160 

LOAD 

) 

2 

4 CONSTANT MAXFL 


3 

VOCABULARY DOS IMMEDIATE 

T 

128 CONSTANT 128 


4 

DOS DEF I N I T I ONS 



4 



5 





5 

( addresses of file 

buffers 

6 

LABEL FNFLD 

11 ALLOT 

6 

MAXFL 1+ ARRAY FLBUF 

7 

QUAN 

FNCNT 

0 TO 

FNCNT 

7 

0 FLBUF MAXFL 1+ 2* 

ERASE 

8 

QUAN 

FNSEP 

0 TO 

FNSEP 

8 



9 

QUAN 

FNSWCH 

0 TO 

FNSWCH 

9 

( map of buffers in 

use ) 

10 

QUAN 

UN I T 

0 TO 

UN I T 

10 

MAXFL 2* 2 + ARRAY 

OPNSTT 

1 1 

QUAN 

DFLUNT 

0 TO 

DFLUNT 

1 1 

0 OPNSTT MAXFL 4 * 

2 + ERASE 

12 

QUAN 

FNSEC 

0 TO 

FNSEC 

12 



13 

QIJAN 

?W I l-D 

0 TO 

7WILD 

13 

( the filename "D::: 

*" ) 

14 

QUAN 

GENTRIES 

0 TO 

SENTRIES 

14 

LABEL ALLNMS 


15 

QUAN 

#FREE 

0 TO 

ttFREE — > 

15 

04 C, 68 C, 0 C, 58 

C, 42 C, 


Screen : 


1 1 


Screen : 


14 


0 

1 

( val DOS: quans 

and constants ) 

0 

( val DOS: error c< 

QUAN 

u_ 

Lii 

m 

a 

0 TO DSKERR 

2 

1 

CONSTANT 

BADNME 

3 

QUAN 

DIRBLK 

0 TO DIRBLK 

3 

2 

CONSTANT 

BADUNT 

-f 

QUAN 

FSMBL.K 

0 TO FSMBL.K 

4 

2, 

CONSTANT 

BADFSM 

5 

QUAN 

7FSMUP 

0 TO 7FSMUP 

er 

4 

CONSTANT 

FLEXST 

6 

QUAN 

7SAME 


6 

5 

CONSTANT 

DIRFUL. 

7 

QUAN 

DIRFRE 


7 

6 

CONSTANT 

DSKFUL 

8 

QUAN 

FLtt 


8 

7 

CONSTANT 

AMBNME 

9 

QUAN 

TADR 


9 

8 

CONSTANT 

FLDNE 

10 

QUAN 

ttlJNTRN 


10 

9 

CONSTANT 

TMFOPN 

1 1 

QUAN 

N1 $ 


1 1 

10 

CONSTANT 

EOFERR 

12 

QUAN 

N2$ 


12 

11 

CONSTANT 

FLNOF'N 

13 

QUAN 

DIRLQC 


13 

12 

CONSTANT 

BADFL# 

14 

QUAN 

WRKSPC 


14 

13 

CONSTANT 

FLWPRT 

15 

QUAN 

DGSTMP 

— > 

15 

14 

CONSTANT 

WRGARG 


Screen: 12 

0 ( val DOS: quans and constants ) 

1 

2 VEST RDMOF'N 

3 ASSIGN NOOP TO RDMOPN 

4 

5 VECT RDMCLS 

6 ASSIGN NOOP TO RDMCLS 

7 

8 VEST RDMSPC 

9 ASSIGN NOOP TO RDMSPC 
10 

11 VECT RDMENDF 

12 ASSIGN NOOP TO RDMENDF 

13 

14 VEST RDMWND 

15 ASSIGN NOOF TO RDMWND — > 


Screen: 15 

0 ( val DOS: error codes 

1 15 CONSTANT FLOPN 

2 16 CONSTANT FLTBG 

4 HERE 1 AND ALLOT ( even addr 

5 144 MAXFL * 192 + ALLOT 

6 HERE TO WRKSPC 128 ALLOT 

7 : TOF'OM 741 3 1- S 

8 

9 : FSMAP < — a 

10 WRKSPC 128 - ; 

1 1 

12 : DIRTBL FSMAF' 64 - ; < — a 

13 

14 : BUFBOT ( — a 

15 DIRTBL 144 MAXFL * - ; 


error routines 


•filename conversion ) 


Screen: 16 

0 ( val DOS: 


Screen : 


19 


3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 
1.3 

14 

15 


DOSERR ( # 

TO DSKERR R> DROP 0 ; 


< f # — ) 


7DOSERR 
SWAP 0= 

IF 

R> DROP DOSERR 
END IF 
DROP : 


7DSKERR ( f 

0= IF R > DROP 

DSKERR DOSERR END IF : 


6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


( val DOS: 

: FNCON < $ — f )( 

0 TO DSKERR 

COUNT GETSWCH GETUNIT ? DSKERR 
8 TO FNCNT 46 TO FNSEP 
FNFLD 11 BLANKS FNFLD 
BEG I N 

3 PICK CS> DUP FNSEP = 

IF 

2DR0P FNFLD 7 + 

DUP 1+ 3 BLANKS 
3 TO FNCNT 0 TO FNSEP 
ELSE 

DUP 42 ( ) = 


7 

8 

9 
10 
1. 1 
12 

13 

14 

15 


filename conversion ) 
a c ) 


Screen: 17 

0 ( val DOS: 

1 

2 : GETSWCH ( a c - 

3 0 TO FNSWCH DUP 2 > 

4 IF 2D1JF' + 2- CD 47 ( "/" > = 

5 IF 

6 2- 2D UP + 1+ CS> 

TO FNSWCH 

END IF 
END IF : 


GETUNIT ( a c — a c ) 

DFLUNT TO UNIT DUP 2 > 

IF OVER S 14916 ( "D: " ) = 

IF 

2- SWAP 2+ SWAP — > 


Scr 

0 

1 


een: 20 

( val DOS: 

IF 


filename conversion ) 


6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


OVER FNFLD 11 + OVER 
63 ( "?"> FILL DROP 


" 0 " ) 

> OR 


ELSE 

DUP 48 ( 

90 ( "Z" ) 

57 < "9") 

65 ( "A") 

OVER 63 < 

IF 2DR0P 2DR0P 
BADNME DOSERR 
END IF 
OVER C! 

END IF 


OVER 
OVER 
3 PICK 
AND OR 
? n ) <> AND 


c 


Screen: 18 

0 ( val DOS: filename conversion ) 

1 

2 ELSE DUP 3 > 

3 IF OVER C8 68 ( "D" > == 

4 3 PICK 2+ C3 58 = AND 

5 IF OVER 1+ CS> 49 ( "1") - 

6 DUP 0< NOT OVER 3 > NOT AMD 

7 IF 

8 TO UNIT 3 -- SWAP 3 + SWAP 

9 ELSE 

10 2DR0F' DROP BADUNT DOSERR 

11 END IF 

1 2 END I F 

1 3 END I F 

1 4 END I F 

15 END IF 1 ; — > 


scr 

0 

1 


een 

( 


val DOS: filename conversion ) 

FNCNT 1- DUP TO FNCNT 0< 

2 IF DROP 2DR0P 

3 BADNME DOSERR 

4 END IF 

5 END IF 

6 1+ ROT 1+ ROT 1- ROT 

7 OVER 0= 

8 UNTIL 

9 2DR0P DROP FNFLD CS 63 >= 

10 BADNME 7D0SERR 0 TO 7WIL.D 

11 11 0 

12 DO 

13 FNFLD I + C3 63 = ( 

14 IF 1 TO 7WILD END I F 

15 LOOP 1 ; — > 


Screen 


alias definitions 


) 


0 ( valDOS: 


: -_*r i cr-. 

3 3 PICK ; 

4 

5 : FLBUF3 

6 FLBUF 3 ; 

7 

8 : FLINFO 

9 FL# FLBUF3 ; 
10 

11 : 720* 720 * ; 

12 : 256* 256 * ; 

13 : 128- 128 - ; 

14 : 1 -:>5 loo — 5 

15 ; 4* 2* 2* j 


( — n ) 
n — a ) 


( — a ) 


Screen: 25 

0 t valDOS: put free space map i 

1 

2 : FSMFLS < — > 

3 7FSMUP 

4 IF 

5 FSMAP FSMBLK 0 R/W 

6 ENDIF 

7 0 TO 7FSMLJP 

8 0 TO FSMBLK 5 

9 

10 : FSMUP < > 

11 1 TO 7FSMUP ; 

12 

13 : DSKFLS < — > 

14 DIRFLS FSMFLS ; 

15 — > 


0 ( valDOS: get & put directory 

1 

2 : DIR 6 ET ( sector — 

3 OFFSET 3 OVER DR0 BLOCK 

4 TO DIRLOC OFFSET ! TO DIRBLK 


5 

6 : DIRFLS 

7 FLUSH 0 TO DIRBLK 5 

8 

9 : DIRUP 


( 


< — 


10 UPDATE ; 

11 

12 ; ENTRY < unit # — 

13 1- 8 /MOD 360 + 

1.4 ROT 720* + DIR 6 ET 
15 16 * DIRLOC + ; 


) 

) 

3 

) 


) 


) 


Screen: 26 


0 < 

4 

valDOS: check 

directory 

1 

2 s 

CHKDIR 

( 

3 

0 TO SENTRIES 

0 TO #FREE 

4 

5 

65 TO DIRFRE 0 
DO 

368 360 

6 

I UNIT 720* + 

DIR6ET 

7 

DIRLOC 128 + 

DIRLOC 

8 

DO 


9 

1+ 1 TO 7SAME 

10 

I C3 195 AND 

66 — 

11 

IF 11 0 


12 

DO 


13 

J I + 5 + 

C3 FNFLD I 

14 

C3 DUP 63 

( "?") = 

1 5 




Screen; 24 

0 ( valDOS: get free space map ) 

1 

2 : FSMGET < unit — ) 

3 720* 359 + 

4 DUP FSMBLK <> 

5 IF 

6 7FSMUP 

7 IF 

8 FSMAP FSMBLK 0 R/W 

9 ENDIF 

10 FSMAP OVER 1 R/W 

11 TO FSMBLK 0 TO 7FSMUP 

12 ELSE 

13 DROP 

14 ENDIF ; 

15 — > 


Screen: 27 

0 < valDOS: check directory ) 

1 

2 IF DROP DUP ENDIF <> 

3 IF 0 TO 7SAME LEAVE ENDIF 

4 LOOP 7SAME 

5 IF 

6 DUP SENTRIES DIRTBL + C! 

7 1 AT SENTRIES +! 

8 ENDIF 

9 ELSE 

10 DUP DIRFRE MIN TO DIRFRE 

11 1 AT SFREE +! 

12 ENDIF 

13 16 /LOOP 

14 LOOP 

15 DROP SENTRIES 5 — 5 


28 


Screen: 31 


0 

( valDQS: allocate a sector ) 

0 

( 

valDOS: -find free buffer 

1 


1 



X. 

; AI..TSEC ( unit - C# t]/f ) 


■ 

NXTQF'N ( — a 

3 

FSMGET 

T 


MAXFL 4* 0 

4 

FSMAP 3 + 3 DUP 

4 


DO 

5 

IF 

5 


I -144 * DIRTBL 16 - + I ’ 0 

6 

1- FSMAP 3 + ! 

6 


DO 

7 

0 -1 FSMAP 10 + 90 O+S 

7 


I OPNSTT 0 OVER = 

8 

DO 

B 


IF DROP 0 LEAVE END IF 

9 

I CS> 

9 


LOOP -DUP 

10 

IF 

10 


IF DUP I’ 0 

1 1 

SWAP DROP DUP LEAVE 

1 1 


DO I OPNSTT 0 0= 

12 

128 I C3 

12 


IF I OPNSTT ! LEAVE END I 

13 

BEGIN DUP 128 AND 0= 

13 


LOOP LEAVE 

14 

WHILE 2* ROT 1+ ROT 2/ ROT 

14 


END IF 

15 

REPEAT — > 

15 


LOOP ; 

Jcr 6 

sen : 29 

Screen: 32 

0 

( valDQS: allocate a sector ) 

0 

( 

valDOS: flush file buffer 

1 


1 



X. 

DROP I SWAP TOGGLE 

X. 

s 

FLFLS < fltt — 

3 

ELSE 

3 


FLBUF3 DUP 10 + C0 

4 

8 + 

4 


IF 

5 

END IF 

5 


DUP 8 + C0 720* 

6 

1 /LOOP 

6 


OVER 5 + 3 + 

7 

SWAP 0= 

7 


OVER 128- SWAP 0 R/W 

P 

IF 

8 


10 + 0 SWAP C! 

9 

DROP BADFSM DOSERR 

9 


ELSE 

10 

END I F 

10 


DROP 

1 1 

FSMUP 1 

1 1 


END IF ; 

12 

END IF ; 

12 



13 


13 



14 


14 



15 

~ ■' 

15 



Screen: 30 

Screen: 33 

0 

( valDOS: release a sector ) 

0 

( 

valDOS: COPEN] 

1 


1 



2 

: RELSEC ( unit # — ) 

2 

; 

(OPEN) ( t — Ca # 13/0 : 

3 

SWAP FSMGET 

3 


FNCON 7DSKERR 

4 

1+ 8 /MOD FSMAP 10 + + 

4 


7WIL.D NOT AMBNME 7D0SERR 

5 

SWAP 128 

5 


CHKDIR FLDNE 7D0SERR 

6 

BEG I N 

6 


0 MAXFL 1+ 1 

7 

OVER 

-7 


DO 

8 

WHILE 

8 


I FLBUF3 0= 

9 

2/ SWAP 1- SWAP 

9 


IF I + LEAVE END IF 

10 

REPEAT 

10 


LOOP 

1 1 

SWAP DROP OVER 03 

1 1 


-DUP TMFOPN 7D0SERF: 

12 

OR SWAP C! 

12 


>R NXTOF'N DUP R FLBUF ! 

13 

FSMAP 3 + DUP 0 1+ SWAP ! 

13 


DUP 16 ERASE 

14 

FSMUP ; 

14 


UNIT DIRTBL C3 ENTRY 

15 

— > 

15 


. — ; 


o 


Screens 34 

0 ( val DOS: C OPEN 3 

1 

2 OVER 5 CMOVE 

3 3 + DUP 3 1- OVER 2+ ! 

4 5 + UNIT OVER C! 1+ 

5 DIRTBL 03 SWAP C! 

6 R FLBUFS) 128- DUP 

7 UNIT 720* OVER 133 + 

8 3+1 R/W R> 

9 RDMOPN 1 ; 

10 

1 1 
12 

13 

14 

15 


Screen: 37 

0 ( val DOS: [READ II > 

1 

2 : (READ) ( adr cnt f 1 # — f ) 

3 TO FL# TO #UNTRN TO TADR 

4 FL# 1 < FL# MAXFL > OR 

5 NOT BADFL# 7D0SERR 

6 FLINFO FLNOPN 7D0SERR 

7 BEGIN 

8 FLINFO 7 + DUP C3 

9 OVER 8 - 03 = 

10 IF 

11 DUP 10 - DUP 03 3 AND 

12 256* SWAP 1+ 03 + -DUP 0= 

13 IF DROP EOFERR DOSERR END IF 

14 1- FL# FLFLS OVER 135- 

15 OVER 4 PICK 1+ 03 — > 


Screens 35 

0 ( val DOS: 

1 


e close: 


6 

7 

S 

9 


(CLOSE) ( fl# — 

-DUP 

IF D1JF' ELSE MAXFL 1+ 1 END IF 
DO 

I DUP TO FL# FLBUFS) 

IF 

RDMOLB FL# FLFLS 
FLINFO 2+ 03 128 AND 


Screen 
0 ( 

1 


4 

5 

6 

7 

8 
9 


10 

IF 



10 

11 

FLINFO 

DUP 8 + 03 


11 

12 

OVER 9 

+ 03 ENTRY 1+ 


12 

13 

SWAP 1 

1 - 3 32767 AND 


13 

14 

SWAP ! 

DIRIJP DIRFLS 


14 

15 

END I F 


> 

15 


: 38 

val DOB: [READ I 


720* + 1 R/W 
OVER 2- ! 0 OVER C! 

END IF 

DUP 8 - 03 OVER 03 - 
#UNTRN OVER U< 

IF DROP #UNTRN END IF 
DUP 3PICK 7 + DUP 3 
ROT + SWAP ! 

OVER 135- 3PICK 03 + 

TADR DUP 4 PICK + TO TADR 
SPICK CMOVE ttUNTRN OVER - 
TO ttUNTRN OVER 03 + 

SWAP 0! ttUNTRN 0= 

UNTIL 1 5 


) 


Screens 36 

0 ( val DOS: C CLOSE 3 > 

1 

2 FLINFO 0 FL# FLBUF ! 

3 0 OPNSTT 

4 BEGIN 

5 DUP 3 3PICK <> 

6 WHILE 

7 2+ 

B REPEAT 

9 SWAP DROP 0 SWAP ! 

10 END IF 

1 1 LOOP ; 

12 

13 

14 

15 — ' 


Screens 39 

0 ( val DOS: I WRITE 3 > 

1 

2 s (WRITE) ( adr cnt +1# — f ) 

3 TO FL# TO ttUNTRN TO TADR 

4 FL# 1 < FL# MAXFL > OR 

5 NOT BADFL# 7D0BERR 

6 FLINFO -DUP FLNOPN 7D0SERR 

7 03 32 AND NOT FLWF'RT 7D0SERR 

8 BEGIN 

9 FLINFO 7 + DUP 03 125 = 

10 IF 

11 DUP 10 - DUP 

12 03 3 AND 256* SWAP 1+ 

13 03 + -DUP 0= 

14 IF DUP 1+ 03 ALTSEC 0= 


Screen: 40 Screen: 43 

0 ( valDDSs [WRITE 3 ) 0 ( valDOS: CRDB3 

1 1 

TC r\ r-. \ / 


2 

IF 

2 : 

<RDB> ( fl# — 


DROP DSKFUL DOSERR 

T 

DUP TO FL# 

4 

ENDIF 

4 

1 < FL# MAXFL > OR 

5 

DUP 1+ 255 AND 

5 

NOT BADFL# 7D0SERR 

6 

OVER 1+ 32767 AND 256 

6 

FL.INFO FLNOF'N 7D0SERR 

7 

/ 4 PICK 2+ C3 1- 4* 

7 

FLINFO 7 + 

8 

>R R OR 4 PICK 10 - C! 

8 

DUP CS ) OVER 8 - C3 = 

9 

3PICK 9 - C! 1 SPICK 

9 

IF 

10 

3 + C! FL# FLFLS OVER 

10 

DUP 10 - DUP 

1 1 

135- 128 ERASE R> 

1 1 

CS> 3 AND 256* 

12 

SPICK 10 - C! OVER 6 - 

12 

SWAP 1+ CS> + -DUP 0: 

13 

DUP 3 1+ 32768 OR SWAP ! 

13 

IF 

14 


14 

DROP EOFERR DOSERI 

15 

— > 

15 

END I F 


icri 

eeri: 41 

Screen: 44 

0 

( val DOS: L WRITE 3 

) 0 

( val DOS: CRDB1 

1 


1 


2 

ELSE 

r-1 

1- FL# FLFLS 


FL# FLFLS 1- OVER 

3 

OVER 135- OVER 

4 

135- OVER 4 PICK 

4 

4 PICK 1+ C5> 720* + 

5 

1+ C3 720 * + 1 R/W 

5 

1 R/W 

6 

ENDIF 

6 

OVER 2- ! 0 OVER C! 

7 

OVER 2- ! 0 OVER C! 

7 

ENDIF 

8 

ENDIF 

8 

DUP C3 SWAP 

9 

125 OVER CS> - 

9 

OVER 1+ OVER Cl 

1 0 

#UNTRN OVER U< 

10 

1 OVER 7 + +1 

11 

IF DROP ttlJNTRN ENDIF 

1 1 

135- + C3 1 ; 

12 

DUP 3PICK 7 + DUP 

12 


13 

0 ROT i SWAP * 

13 


14 

OVER 135- SPICK CS> + 

14 

FORTH DEFINITIONS 

15 


15 



Sere 

ien : 42 

Screen: 45 

0 

( val DOS: [WRITE! CWRB1 > 

0 

1 


1 

2 

TADR DUP 4 PICK + TO TADR 

21 

3 

SWAP 3PICK CMOVE 

3 

4 

OVER CS> OVER + DUP 

4 

5 

4 PICK Cl 3PICK 8 - 

5 

6 

DUP CD ROT MAX SWAP C 1 

6 

7 

#UNTRN SWAP - TO #UNTRM 

7 

8 

1 SWAP 3 + Cl 

8 

9 

#UNTRN 0= 

9 

10 

UNTIL 1 ; 

10 

1 1 


1 1 

12 

: (WRB) ( b fl# — f ) 

12 

13 

SWAP WRKSPC Cl 

13 

14 

WRKSPC 1 ROT < WRITE) ; 

14 

15 

— > 

15 


ere 

0 

1 

4 

5 

6 

7 

B 

9 

10 

11 

12 

13 

14 

15 

icre 

0 

1 

4 

5 

6 

7 

8 

9 

10 

1 1 

12 

13 

14 

15 

icr ( 

0 

1 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 


46 


49 


Screen : 
0 
1 
9 

y. 

4 

5 

6 
7 
S 
9 

10 

11 

12 

13 

14 

15 


47 


Screen: 50 

0 < valDQSs CWIND1 > 

1 ’ ( DOS DOS ) ( > 

2 ' ( FNFl-D ) ( 10 LOAD ) 


4 DOS DEFINITIONS 

5 

6 : (WIND) < f fl# — + > 

7 TO FL# TO DOSTMP 

B FL.# 1 < FL# MAXFL > OR 
9 NOT BADFL# 7D0SERR RDMWND 

10 FLINFO -DUP FLNOPN 7D0BERR 

1 1 DOSTMP 

12 IF ( rewinding ) 

13 FL# FLFLS DUP 3 + ® 1- 

14 DUP SPICK 5 + 3 <> 

15 — > 


Screen 

: 51 


0 ( 

1 

n 

jt- 

val DOS: CWIND1 


IF 


7 ; 

DUP SPICK 5 + 

! OVER 8 

4 

CS> 720* + OVER 

128- 

5 

SWAP 1 R/W 


6 

7 

ELSE DROP END IF 
0 OVER 7 + C! 


8 

0 SWAP 14 + ! 


9 

ELSE ( to end of 

file ) 

10 

DROP 


1 1 

BEGIN 


12 

WRKSPC 128 FL# 

(READ) 

13 

UNTIL 


14 

DSKERR EOFERR = 

? DSKERR 

15 

END IF 1 ; 



C ENTER 1 


[SPACE] 


Screen : 


0 

1 


4 

5 

6 
7 

a 

9 

10 
1 1 
12 

13 

14 

15 


val DDSs 


(ENTER) ( * — 

FNCON 7DSKERR 

7WILD NOT AMBNME 7D0SERR 

CHKDIR 0= FLEXST 7D0SERR 

#FREE DIRFIJL 7DQSERR 

UNIT ALTSEC DSKFUL 7DOSERR 

DUP 1+ TO FNSEC 

WRKSPC 128 ERASE 

DIRFRE 1- 4* WRKSPC 

125 + C! WRKSPC 

SWAP UNIT 720* + 0 R/W 

UNIT DIRFRE ENTRY 

66 OVER C! 1+ 1 OVER ! 2+ 


) 

f ) 


Screen: 55 

0 < val DOS: 

1 

2 IF 

3 DROP DSKERR DOSERR 

4 ENDIF 

5 ELSE 

6 ROT DROP SWAP DUP 

7 C$> MINUS OVER 7 + +! 

8 0 SWAP C! 

9 ENDIF 

1 0 END I F 

11 128 /MOD 

12 BEGIN DUP ( space forward ) 

13 WHILE 

14 WRKSPC 128 FL# (READ) 0= 

15 


Screen: 53 

0 ( val DOS: CENTER] ) 

1 

2 FNSEC OVER ! 2+ 

3 FNFLD SWAP 11 CMQVE 

4 DIRUP FSMUP 1 ; 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

1 4 


Screen: 54 

0 ( val DOS; [SPACE] ) 

1 

2 ; (SPACE) ( cnt -f 1 # — + ) 

3 TO FL# 

4 FL# 1 < FL# MAXFL > OR 

5 IF DROP BADFL# DOSERR ENDIF 

6 FL1NFO 0= 

7 IF DROP FLNOPN DOSERR ENDIF 

8 RDMSF'C DUP 0< ( backwards ) 

9 IF 

10 FLINFO 7 + DUP CS) 

1 1 3P I CK + DUP 0< 

12 IF 

13 DROP 7 + a + 

14 0 MAX 1 FL# (WIND) 0= 

15 — > 


Screen: 56 

0 ( val DOS: [SPACE] 

1 

2 IF 

3 2DR0P DSKERR DOSERR 

4 ENDIF 

5 1- 

6 REPEAT 

7 DROP WRKSPC SWAP 

8 FL# (READ) 7DSKERR 

9 1 ; 

10 

11 

12 

13 

14 

15 


Screen; 57 

0 ( val DOS: [ 70PEN ] 

1 

2 ; (70PEN) ( if - [f l]/0 ) 

3 FNCON 7DSKERR 

4 7WILD NOT AMBNME 7D0SERR 

5 CHKDIR FLDNE 7D0SERR 

6 UNIT DIRTBL CS> 256* + 

7 0 MAXFL 1+ 1 

8 DO 

9 I FL.BUF3 -DUP 

10 IF 8 + 3 3PICK = 

11 IF 1+ LEAVE ENDIF 

12 ENDIF 

13 LOOP 

14 SWAP DROP 1 ; 

1 5 


Screen: 58 

0 ( val DOS: CREN3 > 

1 

2 : (REN) < *n *o — i ) 

3 TO Ni* TO N2* 

4 N2* FNCON 7DSKERR 

5 7WILD NOT AMBNME 7D0SERR 

6 CHKDIR 0= FLEX ST 7D0SERR 

7 FNFLD WRKSF'C 11 CMQVE 

8 UNIT TO DOSTMP 

9 Nl$ FNCON 7DSKERR 

10 7WILD NOT AMBNME 7D0SERR 

11 DOSTMP UNIT = BADUNT 7D0SERR 

12 CHKDIR FLDNE 7D0SERR 

13 UNIT DIRTBL C® ENTRY C,® 

14 32 AND 0= FLWF'RT 7D0SERR 

15 5 


Screen: 59 

0 ( val DOS: I REN 3 II KILL 3 

1 

2 WRKSF'C UNIT 

3 DIRTBL C® ENTRY 5 + 

4 11 CMQVE DIRUP 1 S 

5 

6 : (KILL) ( * — " 

7 (70PEN) 7DSKERR 

8 NOT FLOPN 7DDSERR 

9 UNIT DIRTBL C® ENTRY 

10 DUP C® 32 AND 

11 IF DROP FLWF'RT DOSERR END IF 

12 DUP 3 + 3 1- 

13 BEGIN 

14 WRKSF'C OVER 

15 UNIT 720* + 1 R/W 


Screen: 60 

0 ( valDOS: CKILLJ 

1 

2 UNIT SWAP RELSEC 

3 WRKSPC 125 + DUP 

4 1+ C® DUP ROT C® 

5 3 AND DUP <ROT 

6 256* + 1- < ROT OR 0= 

7 UNTIL 

8 DROP 128 SWAP C! 

9 DIRUP 1 ; 

10 

11 

12 

13 

14 

15 


Screen: 61 

0 ( val DOS: CLOCK 3 C UNLOCK 3 

1 

2 : (DOLCK) < * opt — f 

3 TO DOSTMP (70PEN) 7DSKERR 

4 NOT FLOPN 7D0SERR 

5 DOSTMP UNIT DIRTBL C® 

6 ENTRY DUP C® ROT 

7 IF 32 OR ELSE 223 AND END IF 

8 SWAP C! DIRUP 1 ; 

9 

10 : (LOCK) < * — i 

11 1 (DOLCK) 7DSKERR 1 S 

12 

13 : (UNLOCK) < * “ f 

14 0 (DOLCK) 7DSKERR 1 ; 

15 


Screen: 62 

0 ( valDOS: CENDF3 

1 

2 ; (ENDF) < * 1 # — f 

3 TO F'L# 

4 FL# 1 < FL# MAXFL. > OR 

5 NOT BADFL# 7D0SERR 

6 FLINFO -DUP FLNDF'N ? DOSERR 

7 DUF' C® 32 AND 

8 IF DROP FLWF'RT DOSERR END IF 

9 DUP 7 + C® OVER 1- C! 

10 DUP 2- DUP C® OVER 1- C® 

11 3 AND ROT DUP 11 + C® 

12 1-4* SWAP 1-114 

13 PICK 10 + C! 

14 ROT 8 + C® < ROT 

15 


Screen: 63 

0 ( valDOS: C ENDF 3 

1 

2 BEGIN 

3 2DUP OR 

4 WHILE 

5 256* + 1- OVER 720* 

6 OVER + WRKSPC SWAP 1 R/W 

7 OVER SWAP RELSEC 

8 WRKSPC 126 + DUP C® 

9 SWAP 1- C® 3 AND 

10 FLINFO 1+ DUP ® 

11 1- 32768 OR SWAP ! 

12 REPEAT 

13 2DR0P DROP RDMENDF 1 ; 

14 

15 FORTH DEFINITIONS 


64 


Screen 

0 

1 


67 


Screen : 
0 
1 


4 

*3 

6 

7 

5 
9 

10 
1 1 
12 

13 

14 

15 


4 

5 

6 

7 

8 
9 

1 0 

11 

12 

13 

14 

15 


( 


Sc reen ™ 


0 

1 


6 c j 


Screen: 68 

0 
1 
*7 


4 

5 
o 

7 

s 

9 

1 0 
1 1 
12 

14 

15 


4 

5 

6 

■/ 
8 
9 
1 0 
J 1 
1 2 

1 3 

14 

1 5 


o 


Screen: 66 

J 


Screens 69 
0 

1 


4 


4 


6 

8 

9 

10 
1 1 
12 

13 

14 

i a 


8 
9 
10 
1 1 
12 

13 

14 

15 


c 


error routines 


Screen: 70 

0 ( val DOS: quems and vects ) 

1 ' ( DOS DOS ) ( ) 

2 ( (WIND) ) ( 50 LOAD ) 

3 ’ < *. > < : #. COUNT TYPE ; ) 

4 ' < +Y/N ) ( 142 LOAD ) 

5 

6 GUAM FL.FL# QUAN FLCNT 

7 QUAN ED# IN 0 TO ED# IN 

8 LABEL FLNME 16 ALLOT 

9 VECT *ECHO 

10 ASSIGN DROP TO *ECHO 

11 

12 : ECHO < f — ) 

13 IF ASSIGN EMIT 

14 ELSE ASSIGN DROP 

15 END IF TO *ECHO ; — > 


Screen: 73 

0 ( val DOS : 

1 

2 : CMDERR DOS ( err — 

3 CR DUP TO DSKERR 4 /MOD 

4 696 + WRKSPC SWAP 1 R/W 

5 32 * WRKSPC + 32 --TRAILING 

6 TYPE CR SP! DSKFLS QUIT ; 

7 

8 : 7CMDERR < f err — 

9 SWAP 0= IF CMDERR END IF DROP 
10 

11 : 7WRGARG DOS ( -f — 

12 WRGARG 7CMDERR ; 

13 

14 : 7SYSERR DOS ( f — 

15 DSKERR 7CMDERR ; 


Screen: 71 

0 ( val DOS: argument evaluation ) 

1 

2 : GETVAL DOS ( * — v ) 

3 WRKSPC 34 BLANKS 

4 WRKSPC OVER C3 1+ CMQVE 

5 WRKSPC LATEST (FIND) 

6 IF 

7 DROP CFA EXECUTE 

8 ELSE 

9 WRKSPC NUMBER DROP 

1 0 END I F |i 

1 1 

12 : GET ARBS ( -- * ) 

13 32 WORD HERE 1 OVER 3 1 = 

14 IF 2DR0P 0 END IF 0 84 C3> 

15 40 Y 85 3 + 88 3 -1- C! ; — > 


Screen: 74 

0 ( val DOS: CONFN 

1 

2 LABEL FNAME 16 ALLOT 

4 : CONFN DOS ( a u — * 

5 FNAME 1+ 68 OVER C! 

6 1+ SWAP 49 + OVER C! 

7 1+ 58 OVER C! 

8 1+ OVER 8 -TRAILING 

9 >R OVER R CMOVE R > + 

10 46 OVER C! 1+ SWAP 8 + 

11 3 -TRAILING >R OVER R 

12 CMOVE R + R> 0= - 

13 FNAME 1+ - FNAME 

14 >R R C! R5 i 

15 


screen: fz 

0 < val. DOS; 


7 

8 
9 

10 
1 1 
12 

13 

14 

15 


argument 


GETARG ( delm ~ 
DOS OVER COUNT 
BEGIN 


evaluation ) 
- $ 11/0 ) 


DUP 0# 

5 PICK 
WHILE 1- 
REPEAT 

ROT DROP -DUP 
IF 

DUP 1- 3PI.CK 
DUP C3 ROT - 
ELSE 

DROP 0 END IF ; 


3PICK C3 

<> AND 

SWAP 1+ SWAP 


C! ROT 
OVER C! 


Screen: 75 

0 < val DOS: FLOAD support 

1 

2 : (SKIP) DOS ( n fl# — 

3 FNSWCH 67 ( "C"> = 

4 IF 

5 ED# IN OVER (SPACE) 7SYSERR 

6 END IF 

7 SWAP 

8 BEGIN -DUP 

9 WHILE 1- 

10 BEGIN 

11 OVER (RDB) 7SYSERR 

12 155 = 

13 UNTIL 

14 REPEAT 

15 DROP ; 


FLO AD support 


l-LOAD 


Screen: 76 

0 ( valDO! 

1 

2 : NXTCHR DOS ( — Cc 11/0 > 

3 7TERMINAL 0= STATE 3 0# 

4 OR EOFERR 7D0SERR 

5 FLFL# (RDE) 7DSKERR 

6 1 AT FLCNT +| DUP *ECHD 

7 DUP 155 = 

8 IF 

9 DROP BL. 

10 FLCNT 0 TO FLCNT 39 = 

1 1 IF 

12 DROP r. LATEST F'FA CFA , 3 

13 7DSKERR 

14 END IF 

15 END IF 1 ; — > 


Screen: 79 

0 ( val DOS: 

1 

2 ’ WORD ! ' FWORD ' WORD 2+ - 

3 ' WORD 2+ ! BLK 3 >R 

4 FLCNT >R 0 BLK ! 

5 DUP FLNME 16 CMOVE 

6 (OPEN) 7SYSERR 

7 TO FLFL# DROP 

8 FLFL# (SKIP) OR INTERPRET 

9 FLFL# (CLOSE) DIRFLS 

10 R > TO FLCNT R> BLK ! 

11 ’ WORD R> OVER 

12 2+ I R> SWAP I 

13 R> TO FLFL# ; 

14 

15 


Screen: 77 



Screen: 80 


0 ( 

2 

val DOS: 

FLOAD support ) 

0 ( 
1 

val DOS: LOAD rede-fined 


FWORD DOS 

( c — ) 

J. 

F I X WORD DOS 


3 

HERE 34 

BLANKS HERE 1+ DUP 

3 

0 ' BLK CFA ’ 

WORD ! 

4 

BEGIN 



4 

’ 3 CFA ’ WORD 2+ ! ; 

5 

DROP NXTCHR DUP 


5 



6 

DSKERR 

EOFERR = 

OR 7SYSERR 

6 ? 

FIXWORD CFA ' 

QUIT ! 

-7 

0= IF 

0 END IF 


7 



3 

DUP 4 

PICK < > 


8 : 

LOAD DOS 

( n — 

9 

UNTIL 



9 

’ WORD D3 >R 

>R FIXWORD DROP 

10 

BEG I N 



10 

LOAD R;- R > ? 

WORD D! ; 

1 1 

OVER C 

! 1 + 


1 1 



12 

TOPOM 

32 - OVER 

U> 

12 : 

( 7L0AD I NG ) 


13 

FLTBG 

7CMDERR 


13 

0= ’ WORD 3 ' 

BRANCH CFA <> 

14 

NXTCHR 

DUP 


14 

AND ; ’ (7L0ADING) CFA 

15 



— > 

15 

•’ 7L0ADING 4 

+ 1 — 


Screen: 78 

0 ( val DOS: FLOAD ) 

1 

2 DSKERR EOFERR = OR 7SYSERR 

3 0= IF 0 END IF 

4 DUP 4 PICK = OVER 0= OR 

5 UNTIL 

6 ROT 2DR0P 

7 HERE 1+ - HERE C! ; 

8 

9 : FLOAD DOS ( — ) 

10 GETARGS 7WRBARG 44 6ETARG 

11 IF SWAP GETVAL 1- 0 MAX 

12 ELSE 0 END IF 

13 SWAP FLFL# >R 

14 ’ WORD DUP 3 >R 2+ 3 >R 

15 C ’ BRANCH CFA 1 LITERAL — > 


Screen: 81 

0 ( val DOS: DIR 

1 

2 : DIR DOS ( • 

3 DFLUNT 49 + ALLNMS 2+ C! 

4 GETARGS 0= IF ALLNMS END IF 

5 DUP 1+ C3 243 AND 48 = 

6 IF 

7 1+ C3 15 AND 48 + ALLNMS 

8 2+ C! ALLNMS 

9 END IF 

10 FNCON 7SYSERR UNIT FSMGET 

11 OR CR . " Files on: " 

12 FSMAP 104 + 

13 BEGIN 

14 DUP C3 -DUP 

15 WH I LE 


Screen: 82 

@ ( val DOS: DIR > 

1 EMIT 1+ 

2 REPEAT 

3 DROP CR CR 

4 NAME EXT SIZE S 

5 EC ATTR " CR 

£ _ ti .4 4 .( 4 4 4 1 1 4 1 1 1 4- 

7 ] 4. 1 4 4- " 

8 CR CR CHKDIR DUP 

9 BEGIN 

10 DUP 0# 7TERMINAL 0= AND 

1 1 WH I LE 

12 2DUP - UNIT SWAP DIRTBL + 

13 C3 ENTRY SPACE DUP 5+8 

14 TYPE DUP 13 + C3 32 <> 

15 IF' 46 EMIT — > 


Screen: 85 

0 C val DOS: COPY 

1 

2 : COPY DOS < “ 

3 6 ETARSS 7WRBARB 

4 61 BETAR 6 7WR6ARB 

5 DUP (ENTER) 0= 

6 IF 

7 DSKERR FLEXBT = 7SYSERR 

8 END IF 

9 DUP (70PEN) 7SYSERR 

10 NOT FLQPN 7CMDERR 

11 (OPEN) 7SYSERR 

12 <ROT DROP OVER 

13 FLBUF3 C3 32 AND 

14 0= FLWPRT 7CMDERR 

15 


Screen: 83 

0 ( val DOS: DIR > 

1 

2 ELSE SPACE END IF 

3 DUP 13 + 3 TYPE 

4 DUP 1+ 3 7 . R 

5 DUP 3 + 3 6 . R 

6 4 SPACES C3 DUP 32 AND 

7 IF 76 ( "L") EMIT ENDIF 

8 16 AND IF 82 < "R" > EMIT 

9 ENDIF 1- CR 

10 REPEAT 

11 CR FSMAP 3 + 3 . 

12 sectors free." CR CR 

13 DSKF'LS 2DR0P ; 

14 


Screen: 86 

0 ( val DOS: COPY 

1 

2 FNSWCH 65 < "A") = 

3 IF 

4 0 3PICK (WIND) 7SYSERR 

5 ENDIF 

6 BE 6 IN 

7 0 >R 44 ( " , " ) GETARB 0= 

8 IF DUP R> 1+ >R ENDIF 

9 (OPEN) 7SYSERR SWAP DROP 

1 0 BEG 1 N 

11 WRKSPC 128 3PICK (READ) 

12 DROP ttlJNTRN 128 <> 

13 WHILE 

14 WRKSPC 128 #UNTRN - 

15 


Screen: 84 

0 ( val DOS: OPEN? > 

1 

2 : OPEN? DOS < — > 

3 CR 0 OUT ’ MAXFL 1+ 1 

4 DO I FLBUF3 -DUP 

5 IF 8 + DUP C3 

6 SWAP 1+ C3 

7 I 0 <# # # #> TYPE 

B OVER TO UNIT ENTRY 

9 5 + UNIT CONFN 

10 2 SPACES $. CR 

11 ENDIF 

1 2 LOOP 

13 DIRFLS OUT 3 0= 

14 IF No files open" CR ENDIF 

15 CR ; — •- 


Screen: 87 

0 ( val DOS: COPY RENAME 

1 

2 5 PICK (WRITE) 7SYSERR 

3 REPEAT 

4 (CLOSE) R> 

5 UNTIL 

6 CR CR DROP DUP 

7 (ENDF) 7SYSERR 

8 (CLOSE) DSKFLS ; 

9 

10 : RENAME DOS < 

1 1 GETARBS 7WRSARB 

12 61 BETARB 7WRBARB 

13 SWAP (REN) ?SYSEF:R 

14 CR File renamed" CR CR 

15 DSKFLS s 


Screen: 88 

0 ( valDQSs system words ) 

1 

2 BLIAN WLDFLG KUAN SWITCH 

3 VECT DISKOP VECT -fcOUT 

4 EUAN TEMP 

5 

6 : (CMDPAR) DOS ( — ) 

7 GETARGS 7WRGARG 

8 BEGIN 

9 0 >R 44 ( " , " ) GETARG 0= 

10 IF DUP R> 1+ >R END IF 

11 DUP TO Nl* FNCON FNSWCH 

12 TO SWITCH 7WILD TO WLDFLG 

13 IF CUR'D I R DUP DUP 0= 

14 IF 

15 FNFLD UNIT CONFN 


Screen 

: 89 

Screen: 92 


0 ( 
1 

valDOSs system words ) 

0 < 

valDOS: KILL 

LOCK 


CR 0 OUT ! 

1 

o . 

jL ■ 

SKILL . " kill" 



18 OUT ® - SPACES 

3 



A 

is non~e>: i stent " 

4 : 

KILL DOS 


5 

ENDIF 

5 

ASSIGN (KILL) 

TO DISK 

6 

BEGIN -DUP 

6 

ASSIGN SKILL TO $OUT 

7 

WHILE 

7 

(CMDPAR) ; 


S 

DIRTBL OVER - 3PICK + 

8 



9 

C® UNIT SWAP ENTRY 5 + 

9 



10 

UNIT CONFN 1 WLDFLG 

10 : 

SLOCK ." lock" 

. 

1 1. 

SWITCH 78 < "N") <> * 

1 1 



12 

IF DROP CR *OUT SPACE 

12 : 

LOCK DOS 


13 

DUP " 7 " +Y/N 

13 

ASSIGN (LOCK) 

TO DISKi 

14 

END I F 

14 

ASSIGN SLOCK TO *OUT 

1 5 

0 OUT ! — > 

15 

(CMDPAR) ; 



Screen: 90 


Scr 

een : 93 

0 ( val DOS 

1 

: system words ) 

0 

i 

( val DOS: UNLOCK SETUN! 

o 

IF DUP DISKOP 0= SWAP CR 

J. 

: ^UNLOCK »" unlock" ; 

3 

*. 18 OUT ® - SPACES 

3 


4 

IF 

4 

: UNLOCK DOB 

5 

DSKERR FLQPN = 

5 

ASSIGN (UNLOCK) TO D I SI- 

6 

IF 

6 

ASSIGN ^UNLOCK TO $OUT 

~7 

is open" 

“7 

(CMDPAR) ; 

8 

ELSE 

8 


9 

DSKERR FLWPRT = 

9 


10 

IF 

10 

: SETUNIT DOS 

1 1 

is locked" 

1 1 

GETARGS 7WRGARG GETVAL 

12 

ELSE is 77?" 

12 

DUP 1 >= OVER 4 <= AND 

13 

ENDIF 

13 

BADUNT 7CMDERR 

1 4 

ENDIF 

14 

1 TO DFLUNT CR ; 

15 

ELSE — > 

15 



Screen: 91 

0 ( val DOS; system words; 

1 

2 ."is" $OUT . 

3 ENDIF 

4 ELSE 

5 DROP 

6 ENDIF 1- 

7 REPEAT 

8 DROP 

9 ELSE 

1® CR 0 OUT ! Nl$ 

11 18 OUT ® - SPACES 

12 . " is ill egal " 

13 ENDIF R> 

14 UNTIL 

15 DROP CR CR DSKFLS ; 


PRINT 


) 


READ 


) 


Screen: 94 

0 < v a I DOS: 

^ 1 

( 2 : PRINT DOS < — > 

3 GETARGS 7WRGARG 44 GETARG 

4 IF SWAP GETVAL 1- 0 MAX 

5 ELSE 0 END IF SWAP 

6 (OPEN) 7SYSERR SWAP DROP 

7 DUF' < ROT OVER TO TEMP (SKIP) 

8 FNFLD UNIT CONFN 

9 OR OR . " File: " $. OR OR 

10 FNSWCIH 78 <> DUP TO FNSWCH 

11 TEMP 1+ * TO TEMP 

12 BEGIN 

13 0 7TERMINAL FNSWCH * 0= 

.14 IF DROP DUP ( RDB ) END IF 

15 — 


Screen: 95 


0 

1 

( val DOS: PRINT 


2 

WHILE 


3 

FNSWCH 1 = 


4 

IF 0 TO FNSWCH 

TEMP 

5 

IF 


6 

TEMP 0 


7 

<# # # # # 

#> TYPE 

8 

SPACE 1 AT 

TEMP +! 

9 

END IF 


10 

ENDIF 


1 1 

DUP EMIT 155 = 

TO FNSWCH 

12 

REPEAT 


13 

(CLOSE) 


14 

15 

CR DSKFLS 5 




Screen: 97 

0 ( val DOS: 

1 

2 : READ DOS < “ > 

3 65535 GETARGS 7WRGARG 

4 44 GETARG 7WRGARG 

5 SWAP 44 GETARG 

6 IF 

7 SWAP 4 ROLL DROP 

8 GETVAL <ROT 

9 END I F 

10 GETVAL <ROT 

11 1 TO TEMP FLOPEN (READ) 

12 0= DSKERR EQFERR <> 

13 AND NOT 7SYSERR 

14 TEMP IF FL# (CLOSE) END IF 

15 CR DSKFLS ; — > 


Screen: 98 

0 ( val DOS: WRITE > 

1 

2 : WRITE DOS < — > 

3 GETARGS 7WRGARG 

4 44 GETARG 7WRGARG 

5 SWAP 44 GETARG 7WRGARG 

6 GETVAL SWAP GETVAL ROT 

7 2 TO TEMP FLOPEN (WRITE) 0= 

8 IF 

9 DSKERR FLWPRT = 7SYSERR 

10 FL# (CLOSE) FLWPRT CMDERR 

11 END IF 

12 TEMP IF 

13 FL# (ENDF) 7SYSERR 

14 FL# (CLOSE) 

15 END IF' CR DSKFLS s 


Screen: 96 

Screen 

: 99 

0 

1 

( valDOS: read/write utility ) 

0 ( 
1 

val DOS: CLOSE 

xi 

: FLOPEN DOS ( $ — > 

jC. u 

CLOSE DOS 

3 

DUP 1+ CS> DUP 240 AND 48 = 

3 

0 GETARGS 

4 

IF 

4 

IF 

5 

15 AND SWAP DROP 0 TO TEMP 

5 

SWAP DROP GETVAL 

6 

ELSE 

6 

ENDIF 

7 

DROP TEMP 2 AND 

7 

(CLOSE) CR DSKFLS 

8 

IF DUP (ENTER) 0= 

8 


9 

IF 

9 


10 

DSKERR FLEX ST = 7SYSERR 

10 


1 1 

ENDIF 

11 


12 

ENDIF 

12 


13 

(OPEN) 7SYSERR SWAP DROP 

13 


14 

ENDIF ; 

14 


15 

— > 

15 



Screen; 100 

In 

1 

4 


6 


8 
9 
10 
1 1 

1 '*» 

J. ,l~ 

14 

1 5 


Screen; 103 
0 
1 
2 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


C 


Screen; 101 
0 
.1. 


Screen : 

0 


1 


104 


4 

& 

7 

8 
9 

10 
1 1 
12 
13 
1 4 
1 5 


4 

b 

6 

7 

8 
9 

10 
1 1 
12 

13 

1 4 

15 


o 


:reen ; 
0 
1 


102 


Screen: 105 

0 
1 


4 


7 

8 
9 

10 
1 1 
12 

13 

14 

15 


4 

5 

6 

7 

8 
9 

1 0 
1 1 
12 

13 

14 

15 


( 


Screens 106 
0 



4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screens 109 
0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screens 107 
0 
1 


Screens 110 

0 ( Utiles OPEN ENTER > 

1 

2 * < FLFL# ) ( 70 LOAD ) 


4 

5 

6 



9 
10 
1 1 
12 

13 

14 

15 


4 s OPEN DOS < — ) 

5 6ETARGS 7WRGARG 

6 (OPEN) 7SYSERR 

7 CR . " Fi le access #" . 

8 DROP CR DSKFLS ; 

9 

10 s ENTER DOS < — > 

1 1 GETARGS 7WRGARG 

12 (ENTER) 7SYSERR 

13 CR DSKFLS ; 

14 

15 --> 


Screens 108 Screens 111 


0 

0 

( Util ss FSPACE ENDFIL 

) 

1 

1 



2 

2 

s FSPACE DOS 

( — ) 

.3 

3 

GETARGS 7WRGARG 


4 

4 

44 GETARG 7WRGARG 


5 

5 

GETVAL SWAP GETVAL 


6 

6 

SWAP (SPACE) 7SYSERR 


7 

7 

CR DSKFLS ; 


8 

8 



9 

9 

s ENDFIL DOS 

( — ) 

10 

10 

GETARGS 7WRGAR6 


11 

1 1 

GETVAL (ENDF) 7SYSERR 


12 

12 

CR DSKFLS ; 


13 

13 



14 

14 



15 

15 


y 


Screei 

-i : 11 2 


Screen: 115 

0 ( 

Utils: FDUMP system words ) 

0 ( 

Utils: FDUMP 

l 



1 


2 ; 

PSF'ACE 

( — ) 

2 

IF 

3 

PFLAG 3 DUP 254 AND 


3 

FNSWCH 16 = 24 

4 

PFLAG ! SPACE PFLAG ! 5 


4 

OUT 3 - SPACES 

Cr i 



5 

DUP TEMP - TEMP 

<b 5 

P. ( 

c — ) 

6 

DO DUP I + C3 P 

7 

127 AND DUP 


7 

LOOP DROP 

8 

32 OVER ( Ctrl? 

) 

8 

ENDIF 

9 

124 > OR ( clear. 

. . 7) 

9 

REPEAT 

10 

IF 


10 

2DROP R> NOT 

1 1 

DROP 46 < " 


1 1 

7TERMINAL OR 

12 

END I F 


12 

UNTIL 

13 

EMIT ; 


13 

DROP (CLOSE) 

14 



14 

CR BASE ! DSKFLS ; 

15 



15 


Screen: 113 


Screen; 116 

0 ( 

Utils: FDUMP 

) 

0 ( 

Utils: REWIND EOF 

1 



1 


o « 

FDUMP DOS 

( — ) 

2 : 

REWIND DOS 


GETARGS 7WRGARG 


3 

GETARGS 7WRGARG 

4 

(OPEN) 7SYSERR 


4 

GETVAL 1 SWAP (WIND) 

5 

FNFLD UNIT CONFN 


5 

7SYSERR CR DSKFLS ; 

6 

CR CR . " File; " $. CR 


6 


7 

8 FNSWCH 87 = 1+ * 


7 : 

EOF DOS 

8 

TO FNSWCH SWAP DROP 


8 

GETARGS 7WRGARG 

9 

BASE 3 HEX SWAP 0 


9 

GETVAL 0 SWAP (WIND) 

1 0 

BEGIN 


10 

7SYSERR CR DSKFLS ; 

1 1 

WRKSPC 12B 4 PICK (READ) 

1 1 


12 

>R 128 ttUNTRN - WRKSPC 


12 


13 

BEG I N 


13 


14 

OVER 0> 7TERMINAL 0= 

AND 

14 


15 


— > 

15 



50 + 


Screens 114 

0 < Utils: FDUMP ) 

1 

2 WH I LE 

3 3 PICK FNSWCH MOD 0= 

4 IF 

5 CR 0 TO TEMP 

6 0 OUT ! 3 PICK 0 

7 <######> 

8 TYPE SPACE PSF'ACE 

9 END I F 

10 DIJF' C3 0 <# # # #> TYPE 

1J SPACE 1+ ROT 1+ 

12 ROT 1- ROT 1 AT TEMP +! 

13 OVER 0= 4 PICK 

14 FNSWCH MOD 0= OR 

15 


Screen: 117 

0 < Utils: NAMED I SK 

1 

2 : NAMED I SK DOS ( 

3 DFLUNT 1 + GETARGS 

4 IF SWAP DROP GETVAL. END IF 

5 DUP 1 < OVER 4 > OR 

6 NOT BADUNT 7CMDERR 

7 1- FSMGET FSMAP 104 + 

S CR ."Old: " DUP 

9 BEGIN DUP CS> -DUP 

10 WHILE EMIT 1+ 

1 1 REPEAT 

12 DROP DUP 20 ERASE CR 

13 . " New: " 20 EXPECT CR CR 

14 1 TO 7FSMUP DSKFL.S ; 

15 


Screens 118 
0 
1 


4 

KSJ 

6 

7 

a 

9 
10 
1 1 
12 

13 

14 

15 


Screens 121 

0 ( Fmtrss FMOVE 

1 

2 : FMQVE DOS < — 

3 GETARGS 7WRGARG 

4 61 GETARG 7WR6ARG 

5 0 (CLOSE) SWAP I NS IN 

6 (OPEN) 7SYSERR <ROT DROP 

7 DSKFLS INSDST DUP (ENTER) 0= 

8 IF 

9 DSKERR FLEXST = 7SYSERR 


10 

ENDIF 


1 1 

(OPEN) 7 

'SYSERR SWAP DROP 

12 

BEGIN 


13 

INSIN 

PAD DUP 1 AND + 

14 

TOPOM 

OVER ~ 4 PICK 

15 

(READ) 

INSDST PAD DUP 


Screens 119 
0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screens 122 

0 ( Fmtrss FMQVE 

1 

2 1 AND + TADR OVER - 

3 4 PICK (WRITE) DSKFLS 0= 

4 IF DROP (CLOSE.) (CLOSE) 

5 DSKERR CMDERR 

6 END IF 0= 

7 UNTIL 

8 DUP (ENDF) < ROT (CLOSE) 

9 (CLOSE) 7SYSERR CR CR DSKFLS 
10 

11 s GETNUM ( — n 

12 HERE 1+ 10 EXPECT HERE 1+ 

13 BEGIN DUP C3 WHILE 1+ REPEAT 

14 BL SWAP C! HERE NUMBER DROP ; 

15 


Screens 120 

0 ( Fmtrss system words ) 

1 ’ ( FLFL# ) ( 70 LOAD ) 

3 s INSIN CR 

4 . " Insert sources <START> " 

5 BEG I N 

6 7TERMINAL 1 = 

7 UNTIL 

8 46 EMIT ; 

9 

10 s INSDST CR 

11 Insert dests <SELECT> " 

12 BEGIN 

13 7TERMINAL 2 = 

1 4 LINT I L 

15 46 EMIT 5 — > 


Screens 123 

0 ( Fmtrss system words 

1 

2 s LOCKOUT DOS ( u s cnt — 

3 ROT FSMGET O+S 

4 DO 

5 11+8 /MOD FSMAP 10 + + 

6 SWAP 128 

7 BEGIN OVER 

8 WHILE 2/ SWAP 1- SWAP 

9 REPEAT 

10 SWAP DROP DUP 255 XOR SWAP 

11 3PICK C3 AND 0# FSMAP 3 + 

12 DUP 3 ROT - SWAP ! 

13 OVER C3 AND SWAP Cl 

14 LOOP 

15 1 TO 7FSMUP ; 


FORMAT 


system words 


) 


Screen: 1 24 

0 < Fmtrs 

1 

2 s FORMAT DOS ( — ) 

3 DFLUNT 1+ GET ARBS 

4 IF GETVAL SWAP DROP END IF 

5 DUP DUP 1- TO UNIT OR OR 

6 Format unit. " . . " ? " +Y/N 

7 IF 

8 DUP WRKSPC 772 ! (FMT) 

9 DROP WRKSPC 128 ERASE 

10 2 WRKSPC C! 

11 WRKSPC 1+ 707 OVER ! 716 

12 SWAP 2+ ! 15 WRKSPC 10 + C! 

13 WRKSPC 11+89 255 FILL 

14 1- 720* 357 + 

15 WRKSPC OVER 0 R/W — > 


Screens 127 
0 < Fmtrs: 

2 0 VARIABLE SEC/PAS ( 

3 0 VARIABLE SECNT 

4 

5 : AXLN DOB < system ) 

6 4 PICK 0 

7 DO 3PICK I 128 * + 

8 3PICK I + 3 PICK R/W 

9 LOOP 2DR0F' 2DR0P ; 

10 

11 s DCSTP DOS ( — ) 

12 DSKFLS TOF’OM PAD DUP 1 AND 

13 - - 0 128 U/ SWAP DROP 

14 SEC/PAS ! 0 SECNT ! ; 

15 — > 


Screens 125 

0 ( Fmtrs: FORMAT ) 

1 

2 UNIT 359 9 LOCKOUT CR CR 

3 Diskname: " 

4 FSMAP 104 + 20 EXPECT CR CR 

5 . " Lock out error screens? " 

6 +Y/N 

7 IF 

8 UNIT 695 24 LOCKOUT 

9 END IF 

10 BEGIN CR CR 

11 Lock out sectors' 7 ' " 

12 +Y/N DUP 

1 3 I F 

14 UNIT CR 

15 ."First sector: " — > 


Screen: 128 

0 ( Fmtrs: DISKCOPY1 ) 

1 

2 : D ISKCOPY 1 ( — ) 

3 DCSTP 

4 BEGIN 

5 CR I NS IN 

6 720 SECNT 3 - SEC/PAS 3 MIN 

7 DUP >R PAD DUP 1 AND - SECNTV" 

8 3 2DUP 5 PICK <ROT 1 AXLN ' 

9 INSDST 0 AXLN CF< 

10 R > SECNT + ! SECNT 3 DUP . 

11 sectors copied" 720 = 

12 UNTIL 

13 MTB CR ; 

14 


Screen 

: 126 


Screen: 129 


0 ( 

Fmtrs: FORMAT 

) 

0 

( Fmtrs: DISKC0PY2 

) 

1 



1 



2 

BET NUM CR 


2 

: DISKC0PY2 

( — j 

3 

# to lock out: ‘ 


3 

DCSTP 


4 

6 ETNUM LOCKOUT- 


4 

CR . " Insert source 

in drive 1 

5 

END IF 


5 

" CR Insert dest. 

in drive 2 

6 

0= UNTIL 


6 

" CR " Press START to 

copy" 

7 

END IF 


7 

WAIT 


8 

DROP DSKFLS CR CR 5 


8 

BEGIN 


9 



9 

720 SECNT 3 - SEC/PAS 3 MIN 

10 



10 

DUP >R PAD DUP 1 AND - SECNT 

1 1 



11 

3 2DUP 5 PICK < ROT 


12 



12 

1 AXLN 720 + 0 AXLN 


13 



13 

R > SECNT +! SECNT 3 

720 = ( 

14 



14 

UNTIL 

V 

15 


> 

15 

MTB CR ; 



Screen 


c 


Screens 130 
0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


0 

1 

2 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen : 
0 

1 


131 


4 

5 

6 

o i 

9 
10 
1 1 
12 

13 

14 

15 


Screen 

0 

1 


4 

5 

6 
7 

a 

9 

10 
1 1 
12 

13 

14 

15 


Screen s 
0 


13 ; 


Screen 

0 

1 


6 

7 

3 

9 

10 

11 


c 


13 

14 

1 5 


4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screens 136 
0 
1 


4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 139 
0 

1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


( 


Screens 137 


1 


Screens 140 
0 
1 


4 

6 

7 

8 
9 


4 

5 

6 

7 

8 
C) 


o 


10 
1 1 
.1 7 

13 

14 

15 


10 
1 1 
12 

13 

14 

15 


Screen : 
0 

1 


1 38 


Screen: 141 

0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

1 £"j 


4 

5 

6 

7 

8 
9 

10 

1 1 
12 

13 

14 

15 


(J 


Screen : 14'2 Screen: 

0 < +Y/N routine > ® 

1 ( This Y/N routine accepts upper 1 

2 or lower case and echos it. ) 2 

4 BASE 3 HEX 4 

5 

6 : +Y/N < — f > 6 

7 KEY DUP DF AND 7 

8 DUP 59 <> B 

9 0BRANCH C 0014 , 3 9 

10 DUP 4E < > 1® 

11 0BRANCH C 0008 ,3 H 

12 2DR0P BRANCH C FFDA ,3 12 

13 SWAP EMIT 59 = ; 13 

14 14 

15 BASE ! 15 


Screen : 
0 

1 


143 


Screen : 
0 
1 


4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


4 

5 

6 
~7 
8 
9 

10 

11 

12 

13 

14 

15 


Screen: 144 
0 
1 


Screen : 
0 
1 


4 

5 

6 
7 
a 
9 

10 

11 

12 

13 

14 

1 5 


4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


145 


146 


147 


TO AT 


Screen: .MS 

0 

1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 151 

0 ( Quan: 

1 

2 : TO 

3 -FIND 0 ~ 0 TERROR DROP 

4 STATE 3 

5 IF , 

6 ELSE EXECUTE 

7 END IF ; IMMEDIATE 

8 

9 : AT 

10 -FIND 0= 0 TERROR DROP 

11 2+ STATE 3 

12 IF , 

13 ELSE EXECUTE 

14 END IF ; IMMEDIATE 

15 < corrected ) 


Screen: 149 

0 

1 


4 

5 

6 

8 

9 

10 
1 1 
12 

13 

14 

15 


Screen: 150 

0 ( Quart: ASSIGN ) 

1 


4 ’ ( CFALIT 

5 : ASSIGN [COMPILE] CFALIT ; 

6 IMMEDIATE — > ) ( ) 

8 : ASSIGN < — c-fa ) 

9 STATE 3 

10 [COMPILE] [ 

11 [COMPILE] ' CFA SWAP 

12 IF ] 

13 END IF [COMPILE] LITERAL ; 

14 IMMEDIATE 

15 


Screen: 152 

0 < Quan: [236] [2!4] 

1 

2 ASSEMBLER HEX 


4 LABEL (236) 


5 

A0 C, 

06 

C, 

B 1 C„ 

w 

C, 

48 C 

6 

C8 C, 

B1 

C, 

W C, 

4C 

c, 

PUSH 

7 








8 

LABEL ( 

2 ! 4 ) 






9 

A0 C, 

04 

c, 

B5 C , 

00 

c, 

91 C 

10 

w c, 

CB 

c, 

B5 C , 

01 

c, 

91 C 

1 1 

w c, 

4C 

c, 

POP , 





12 

13 

14 

15 


Screen: 153 

0 ( Quan: [2V6] 

1 


2 

LABEL ( 

2V6) 






3 

A0 C, 

07 

C, 

B 1 C, 

W 

C, 

48 C, 

4 

88 C, 

B1 

C, 

w C, 

85 

c, 

W C, 

5 

68 C, 

85 

c, 

W 1 + 

C, 



6 

A0 C, 

00 

c <, 

4C C, 

W 1 

- 

, 


7 

8 
9 

10 
1 1 
12 

13 

14 

15 




Screens 154 

0 < Quan: patch for CREATE ) 

1 

2 OCX 

4 : ( PTCH ) ( system ) 

5 SWAP >R R = 251 R = 249 R> = 

6 OR OR ; 

7 

8 : PTCH ( system > 

9 IF [ ’ (PTCH) CFA 3 LITERAL 

10 ELSE L ’ = CFA 3 LITERAL 

11 END IF 

12 T ' CREATE 63 + 1 LITERAL ! ; 

13 

14 

15 — > 


Screens 157 
0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


o 


Screen: 155 

0 ( Quan: QUAN VECT 

1 

2 : GUAM 

3 ON PTCH LABEL -2 ALLOT 

4 (236) , (214) , 

5 C ’ VARIABLE 4 + 1 LITERAL 

6 2 ALLOT OFF PTCH ; 

7 

8 s VECT 

9 ON PTCH LABEL -2 ALLOT 

10 ( 2V6 ) „ (2! 4) , 

11 C VARIABLE 4 + 3 LITERAL 

12 i ’ NOOP CFA 3 LITERAL , 

13 OFF PTCH ; 

14 

1 5 


Screen: 158 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 156 
0 
1 


Screens 159 
0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 



15 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 160 


0 

( Utils: CARRAY ARRAY 


> 

1 

BASE 3 HEX 




2 

; CARRAY 

( cccc, 

n — 

> 

3 

CREATE SMUDGE ( cccc: 

n — 

a ) 

4 

ALLOT 




5 

sCODE CA C, 

CA C, 18 

c, 


6 

AS C. W C, 

69 C, 02 

C, 95 

c, 

7 

00 C, 98 C, 

65 C, W 1+ C, 


8 

95 C, 01 C, 

4C C, 



9 

' + ( CFA 3 

) j C |S 



10 





1 1 

: ARRAY 

( cccc, 

n — 

) 

12 

CREATE SMUDGE ( cccc: 

n — 

a ) 

13 

2* ALLOT 




14 

5 CODE 16 C, 

00 C, 36 

C, 01 

c, 

15 

4C C, ’ CARRAY 08 + 

, C; 

— > 


Screen: 163 

0 ( Utils: XC! X! > 

1 

2 : XC! ( n0. . .nm cnt addr — )( 

3 OVER 1- + >R 0 

4 DO J I - C! 

5 LOOP R > DROP ; 

6 

7 : X! ( n0...nm cnt addr — ) 

B OVER 1- 2* + >R 0 
9 DO J I 2* - ! 

10 LOOP R> DROP ; 

.1 1 

12 ( Caution: Remember limitation 

13 ( on stack size of 30 values 

14 ( because of OS conflict. ) 

15 — > 


Screen: 161 


0 ( 

Uti Is: 

CT ABLE 

TABLE 

) 

1 

CITABLE 


( cccc, 

■— ) 

3 

CREATE 

SMUDGE 

( cccc: 

n — a ) 

4 

5 

; CODE 
4C C, ’ 

CARRAY 

08 + , 

C 5 

6 

7 s 

TABLE 


( cccc, 

— ) 

a 

CREATE 

SMUDGE 

( cccc: 

n — a ) 


9 ; CODE 

10 4C C, ’ ARRAY 0fi + , C; 
1 1 
12 

13 

14 

15 


Screen: 164 

0 ( Utils: CVECTOR VECTOR ) 

1 

2 : CVECTOR < cccc, 

3 CREATE SMUDGE ( cccc: 

4 HERE OVER ALLOT XC ! 

5 ; CODE 

6 4C C, ’ CARRAY 08 + , 

7 

B : VECTOR < cccc, 

9 CREATE SMUDGE < cccc: 

10 HERE OVER 2* ALLOT X! 

1 1 ; CODE 

12 4C C, ’ ARRAY 0A + , 

13 

1 4 BASE ! 

15 


cnt — > 
n — a ) 

C; 

cnt — >C. 

n — a ) 

c; 


Screen: 162 

0 < Utils: 2CARRAY 2ARRAY ) 

1 

2 : 2CARRAY i. cccc, n n — ) 

3 < BUILDS < cccc: n n — a > 

4 SWAP DUP , * ALLOT 

5 DOES > 

6 DUP >R <3 * + R > + 2+ ? 

7 

8 : 2ARRAY ( cccc, n n — ) 

9 < BUILDS ( cccc: n n — a ) 

10 SWAP DUP , * 2* ALLOT 

11 DOES> 

12 DUP >R 3 * + 2* R> + 2+ ; 

13 

14 

15 — > 


Screen: 165 

0 
1 


4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


c 


Screen: 166 

0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 169 
0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 167 
0 

1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 170 

0 CONTENTS OF THIS DISK: 

1 

2 Disk Operating System: 10 LOAD 

3 DOS system extensions: 50 LOAD 

4 BASIC DOS COMMANDS: 70 LOAD 

5 DOS COMMAND EXTENSIONS: 110 LOAD 

6 

7 (note the packages lower on the 

8 screen will load all packages 

9 listed above themselves.) 

10 

11 DISK FORMATTER/COPIERS: 120 LOAD 

12 00 AM STRUCTURES: 150 LOAD 

13 ARRAYS & THEIR COUSINS: 160 LOAD 

14 

15 val DOS FILE EDITOR: valDOS II 


Screen: 168 
0 

1 


Screen: 171 

0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


( 


Screen: 172 

0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 175 

0 File is too big 

1 File is random 

2 File is not random 

3 No room For random map 

4 Random map is bad 

5 File is a device file 

6 File is not a device file 

7 Illegal access to device file 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen : 
0 

1 


173 


4 


7 

8 
9 

10 

1 1 
12 
13 

1 4 

15 


Screen: 176 

0 < Error messages 

1 

2 Stack empty 

4 Dictionary full 

5 

6 Wrong addressing mode 

7 

8 Is not unique 

9 

10 Value error 

1 1 

12 Disk address error 

13 

14 Stack full 

15 


o 


Screen: 174 

0 ( valDQS error messages 

1 Illegal filename 

2 Bad/Mismatched unit.(s) 

3 Bad free space map 

4 File already exists 

5 Directory is full 

6 D i s k is full 

7 Filename is ambiguous 

8 File does not exist. 

9 No room for buffer 

10 End of file encountered 

11 File is not open 

12 Illegal file number 

13 File is locked 

14 Bad argument list 

15 File is open 


Screen: 177 

0 Disk Error ! 

1 

2 Dictionary too big 

4 

5 

6 
7 
B 
9 

10 
1 1 
12 

13 

14 

15 


c 


) 


Screen: 178 

0 ( Error messages 

1 

2 Use only in Definitions 

4 Execution only 

5 

6 Conditionals not paired 

7 

8 Definition not finished 

9 

10 In protected dictionary 

1 1 

12 Use only when loading 

13 

14 Off current screen 

15 


Screen: 179 

0 Declare VOCABULARY 

1 


4 

5 

6 
7 
B 
9 

10 

11 

12 

13 

14 

15 


p 



o 


c 


val DOS II 


Supplied Source Listing 

o 

LXVI . 


( 


o 


o 


o 


Screen: 50 Screen: 53 


0 

( Case Statements: CASE 

) 

0 ( 

Case statements: SEL 

1 

BASE 3 DCX 


1 



2 



n . 
J~ a 

NOSEL 


3 

' ( PERMANENT PERMANENT ) < 

) 

3 

8 7PAIRS [COMPILE] ' 

CFA 

4 

: (CASE) 


4 

OVER 1+ ! 8 ; 

IMMEDIATE 

5 

R C3 MIN -1 MAX 2* 


5 



6 

R 3 + + 3EX 


6 : 

_ \ 


7 

R C3 2* 5 + R> + >R ; 


7 

SWAF 8 7PAIRS , DUP 

C3 1 + 

8 



8 

OVER C! [COMPILE] ’ 


9 

’ ( TRANSIENT TRANSIENT ) ( 

) 

9 

CFA , 8 ; 

IMMEDIATE 

10 

: CASE 


10 



1 1 

7C0MP COMPILE (CASE) 


1 1 ; 

SELEND 


12 

HERE 0 C, 


12 

8 7PAIRS 


13 

COMPILE NOOP 6 ; IMMEDIATE 

13 

DROP [COMPILE] ] ; 

IMMEDIATE 

14 



14 



15 

’ ( PERMANENT PERMANENT ) ( 

) > 

15 


— 


Screen: 51 

Case statements: CASE ) 

NOC-ASE 

6 7PAIRS 7 5 IMMEDIATE 

CASEND 
DUP 6 == 

IF DROP COMPILE NOOP 
ELSE 7 7PAIRS 
END IF 

HERE 2- 3 OVER 1+ ! 

HERE OVER - 

5 - 2/ SWAP C! ; IMMEDIATE- 

PERMANENT PERMANENT > ( > 


Screen: 54 

0 ( Case statements: CQND ) 

1 

2 ’ ( TRANSIENT TRANSIENT ) ( ) 

4 : COND 

5 0 COMPILE DUP ; IMMEDIATE 

6 

7 : << 

8 1+ C COMPILE] IF 

9 COMPILE DROP ; IMMEDIATE 

10 

11 : >> 

12 C COMPILE] ELSE COMPILE 

13 DUP ROT 5 IMMEDIATE 

14 

15 ’ ( PERMANENT PERMANENT ) ( > — > 


0 ( 


o 


6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


0 ( Case statements; SEL ) 

1 

2 : (SEL) 

3 R 1+ DUP 2+ DUP R CS> 

4 2* 2* + R> DROP DUP >R SWAP 

5 DO I 3 3 PICK = 

6 IF I 2+ SWAP DROP LEAVE THEN 

7 4 /LOOP SWAP DROP 3EX ; 

8 

9 * ( TRANSIENT TRANSIENT ) ( ) 

10 : SEL 7C0MP 

11 7L0ADING COMPILE (SEL) HERE 

12. 0 C. COMPILE NOOP C COMPILE] L 

13 8 ; IMMEDIATE 

( I 14 

15 ’ ( PERMANENT PERMANENT ) < ) — > 


Screen; 55 

0 ( Case statements: 

1 

2 : NOCOND 

3 COMPILE 2DROP ; 

4 

5 : CONDEND 

6 0 DO 

7 [COMPILE] END IF 

8 LOOP s 

9 
10 
1 1 
12 

13 

14 

15 


COND ) 


IMMEDIATE 


IMMEDIATE 


59 


Screens 56 Screen: 

0 ( Case statements: CASE: ) 0 

1 1 

2 < PERMANENT PERMANENT > < ) 2 

3 3 

4 : CASE: 4 

5 < BUILDS 5 

6 5MUD6E ! CSP 6 

7 rCOMPILEH 3 7 

8 DOES > B 

9 SWAP 2* + SEX ; 9 

1 0 1 0 

:L1 11 

12 BASE ! 12 

13 13 

14 14 

15 15 



Screens 57 Screen: 60 

!;l 0 < Screen code conversion words ' 

1 1 

2 2 BASE 3 HEX 


4 

5 

6 
~7 

8 

9 

10 
1 1 
12 

13 

14 

15 


4 

CODE >BSCD 



( 

a a 

n — ) 

5 

A9 0, 

03 

C, 20 

c. 

SETUP 


6 

HERE 

C4 

C, C2 

c, 

D0 

c, 

07 C, 

7 

C6 C, 

C3 

C, 10 

c, 

03 

c. 

4c c, r 

48 C, V 

8 

NEXT 


B 1 

C, 

06 

C, 

9 

29 C, 

7F 

C, C9 

C, 

60 

C, 

B0 C. 

10 

0D C, 

C9 

C, 20 

C,, 

B0 

c. 

06 C, 

11 

IB 0, 

69 

C, 40 

C, 

4C 

c, 

HERE 

12 

2 ALLOT 

38 

C, E9 

C, 

20 

C, 

HERE 

13 

SWAP ! 

91 

C, C4 

c, 

68 

c, 

29 C, 

14 

15 

80 C, 

1 1 

C, C4 

C, 

91 

c, 

C4 C, 


Screen : 
0 


1 


5S 


4 

5 

6 
~7 

3 
9 
10 
1 1 
12 

13 

14 

15 


Screen: 61 

0 < Screen code conversion words ) 

1 


2 

C8 C, 

D0 

0, D3 

C, 

E6 

C, 

C7 C, 

t; 

E6 C, 

C5 

C, 4C 

C, 

n 


4 

Cs 






5 








6 

CODE BSCD> 



( a a 

n — 

7 

A9 C, 

03 

C, 20 

C, 

SETUP 

. *1 

8 

HERE 

C4 

C, 02 

C, 

D0 

c, 

07 C, 

9 

C6 C, 

C3 

C f 10 

c. 

03 

c. 

4C C, 

10 

NEXT 


B1 

c. 

C6 

c. 

48 C, 

1 1 

29 C, 

7F 

C„ C9 

C, 

60 

C, 

B0 C, 

12 

0D C, 

C9 

C, 40 

C, 

B0 

c. 

06 C, 

13 

IS c. 

69 

C, 20 

c, 

4C 

C, 

HERE 

14 

2 ALLOT 

38 

C, E9 

0 , 

40 

c, 

HERE 

15 









o 


6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


:»en : 62 

( Screen code conversion words ) 

SWAP ! 91 C, C4 C, 6B C, 29 C, 

80 C, 11 C, C4 C, 91 C, C4 C, 

C8 C, D0 C, D3 C, E6 C, C7 C, 

E6 C, C5 C, 4C C, , 

C; 


>SCD 

SP® DUP 1 >BSCD i 
SCD> 

SP® DUP 1 BSCD> ; 


( c 


sc ) 


( sc — c ) 


BASE 


Screen: 65 

0 
1 


4 

5 

6 
7 
B 
9 

10 

11 

12 

13 

14 

15 


Screen : 
0 
1 


63 


Screen: 66 

0 
1 


4 

5 

6 



9 
10 
1 1 
12 

13 

14 

15 


4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen : 


0 

1 


64 


Screen: 67 

0 
1 


4 


4 


c 


6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


6 

~7 

8 
9 
10 
1 1 
12 

13 

14 

15 


INKEY* 


Screens 68 
0 
1 


4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 71 

0 ( Utils: 

1 

2 : (INKEY*) < 

3 702 C! NOKEY 0 : 

4 


5 : 

INKEY* 


( 

6 

764 C3 



7 

COND 



8 

252 = << 

128 

( INKEY*) 

9 

191 > << 

0 

>> 

10 

188 = << 

0 

> > 

1 1 

124 = << 

64 

(INKEY*) 

12 

60 = << 

0 

( INKEY*) 

13 

39 = << 

0 

NOKEY 

14 

NOCOND KEY 



15 

CONDEND 5 




c 


— c ) 


Screen: 69 

0 
1 


4 

5 

6 

8 

9 

10 
1 1 
12 

13 

1 4 

15 


Screen: 72 

0 < Utils: -Y/N 

1 

2 ( This Y/N routine accepts 

3 or lower case. ) 

4 HEX 

5 

6 : -Y/N ( ■ 

7 KEY DF AND 

8 DUP 59 <> 

9 0BRANCH I 0014 , 1 

10 DUP 4E <> 

11 0BRANCH C 0008 , 3 

12 2DR0P BRANCH C FFDA , 3 

13 59 = ; 

14 

15 DCX 


) 

upper 


- f ) 

o 


Screens 70 


0 

( Utils: HIDCHR NOKEY 

CURSOR) 

1 

n 

jL 

BASE 3 DCX 


4 

’ ( CASE ) ( 50 LOAD ) 


5 

6 

: HIDCHR 

( — ) 

7 

65535 94 ! ; 


8 

9 

: NOKEY 

( — ) 

10 

255 764 C! ; 


1 1 
12 

: CURSOR 

< f — ) 

13 

0= 752 C! 


14 

28 EMIT 29 EMIT ; 


15 


— > 


Screen: 73 


0 

( Utils: Y/N 

-RETURN RETURN ) 

1 

: Y/N 

( — f ) 

3 

. “ < Y/N> " - 

Y/N DUP 

4 

IF 89 ELSE 78 

ENDIF 

5 

EMIT SPACE ; 


6 

7 

: -RETURN 

( — ) 

8 

BEGIN 


9 

KEY 155 = 


10 

UNTIL ; 


11 

12 

: RETURN 

( — > 

13 

. " < RETURN > 

" -RETURN ; 

14 

15 

BASE ! 



Screen: 100 Screen: 103 


0 

( valDOS file editor 1.0 

) 

0 

( valDOS file editor 

1.0 ) 

1 

o 

’ ( FLFL# ) ( 

160 LOAD ;S ) 


1 

r-l 

HEX 


■it. 

3 

BASE S) OCX 



J— 

y t 

LABEL T0S1+ 


4 




4 

F6 C, 00 C, D0 C. 

02 C, F6 C, 

5 

VOCABULARY 1 

EDITOR IMMEDIATE 


5 

01 C, 60 C, 


6 

EDITOR DEFINITIONS 


6 



7 




7 

LABEL TOS 1 — 


8 

’ ( >BSCD ) 

( 60 LOAD ) 


8 

B5 C, 00 C, D0 C, 

02 C, D6 C, 

9 

' < HIDCHR ) 

( 70 LOAD ) 


9 

01 C, D6 C, 00 C, 

60 C, 

10 




10 



1 1 

QUAN XLOC 

0 TO XLOC 


11 

CODE PRVLN 

( a — a ) 

12 

QUAN YL.OC 

0 TO YLOC 


12 

20 C, TOS1- , A 1 C, 

00 C, F0 C, 

13 

QUAN INSRT 

0 TO INSRT 


13 

09 C, 20 C, T0S1- , 

A1 C, 00 C, 

14 

QUAN LSTCHR 

0 TO LSTCHR 


14 

C9 C, 9B C, D0 C, 

F3 C, 20 C, 

15 

QUAN 7BUFSM 

0 TO 7BUFSM 

— > 

15 

TOS 1 + , 4C C, NEXT 

. L : ■■■ 


Screen : 

.101 





Screen; 104 


0 

1 

( valDOS file 

editor 

■ 1.0 

) 

0 

1 

( valDOS file 

editor 1.0 ) 

X 

o 

QUAN 

2PADSM 

0 

TO 

7PADSM 


CODE NXTLN 

(a — a ) 

3 

QUAN 

7MULTI 

0 

TO 

7MULT I 


3 

A 1 C, 

00 C, 

F0 C, 07 C, 20 C, 

4 

QUAN 

7MARK 

0 

TO 

'.’MARK 


4 

TOS1 + 

, C9 C. 

9B C, D0 C, F5 C. 

5 

QUAN 

7UPDAT 

0 

TO 

7UPDAT 


5 

4C C, 

NEXT , 

C;s 

6 

GUAM 

TXTBOT 

0 

TO 

TXTBOT 


6 




7 

QUAN 

TXTEND 

0 

TO 

TXTEND 


7 

CODE CRAM 

( A A — L ) 

8 

QUAN 

DSPTOP 

0 

TO 

DSPTOP 


8 

A9 C, 

02 C, 

20 C, SETUP , 

9 

QUAN 

DSF'BOT 

0 

TO 

DSF'BOT 


9 

A0 C, 

26 C, 

88 C, F0 C, 04 C, 

10 

QUAN 

LNCNT 

0 

TO 

LNCNT 


10 

B1 C, 

N 2+ C, F0 C, -7 C, 

1 1 

QUAN 

CURLN 

0 

TO 

CURLN 


11 

C8 C, 

84 C, 

XBAVE C, A9 C, 

12 

QUAN 

EDFL.# 

0 

TO 

EDFL# 


12 

DB C. 

91 C, 

N C, 88 C, 30 C, 

13 

QUAN 

MEMTOP 

0 

TO 

MEMTOP 


13 

07 C, 

B 1 C, 

N 2+ C, 91 C, 

14 

QUAN 

PTFLG 

0 

TO 

PTFLG 


14 

N C, 

4C C, 

HERE 8 - , A 4 C, 

15 

QUAN 

72BIG 

0 

TO 

72B I G 

> 

15 



— > 


Screen: 102 

0 ( valDOS file editor 1.0 ) 

1 

2 LABEL OOPSLN 38 ALLOT 

3 OOPSLN 38 ERASE 

4 LABEL EDN1$ 16 ALLOT 

5 LABEL EDN2$ 16 ALLOT 

6 LABEL SRCI-I* 34 ALLOT 0 SRCH$ C! 

7 LABEL EBWRK 40 ALLOT 

8 LABEL TABS 4 ALLOT 32 C, 

9 TABS 4 68 FILL 

10 36 TABS 4 + C! 

11 

12 37 CONSTANT 37 

13 16 CONSTANT ttLNS 

14 40 CONSTANT LLEN 

15 5 LLEN * CONSTANT BLEN — > 


Screen: 105 

0 ( valDOS file editor 1.0 ) 

1 


2 

XSAVE 

C, C8 C, 98 C, 

3 

4C 

c, 

PUSH0A , 

4 

C; 



5 




6 

CODE 

UNCRAM < a a -- 

7 

A9 

C, 

02 C, 20 C, SETUP 

8 

B 1 

c, 

N 2+ C, F0 C, 0D C, 

9 

B1 

C, 

N 2+ C, C9 C, 9B C, 

10 

F0 

c, 

06 C, 91 C, N C, 

1 1 

C8 

C, 

4C C, HERE 0A - , 

12 

C8 

c:, 

18 C, 98 C, 65 C, 

13 

N 2+ C, 48 C, A9 C, 00 C, 

14 

65 

c. 

N 3 H- C, 4C C, PUSH 

15 

C: 




) 


Screen: 106 

0 ( valDOS file editor 1.0 

1 


r-\ 

A. 

CODE 7 

ENUF 




( a — 

a cnt ) 

3 

84 C, 

N 

C, 

A 1 

C, 

00 0, 

09 0, 

4 

9B C, 

D0 

c, 

0A 

c, 

E6 C, 

N 0, 

5 

A 9 C, 

10 

C, 

05 

C, 

N 0, 

F0 0, 

6 

0E C, 

D0 

C, 

03 

c, 

0A C, 

F0 0, 

~7 

09 C, 

F6 

c, 

00 

c. 

D0 0, 

02 C, 

Q 

F6 0, 

01 

Cji 

40 

0, 

' 7ENUF 2+ , 

9 

A 5 C, 

N 

c. 

40 

C, 

PUSH0A , 


10 C; 

11 

12 DCX 

13 

14 

15 


Screen: 109 

0 ( valDOS file editor 1.0 ) 

2 : CBLANK ( — f 

3 CURLOC DUP C3 

4 127 AND SWAP C! ; 

5 

6 : NQRPT 0 TO 7MULTI : < — ) 

7 

8 : CRWT ( — ) 

9 CR . " C/R to continue" 

10 253 EMIT 

11 BEGIN 

12 KEY 155 = 

13 UNTIL 

14 88 3 40 + 640 ERASE ; 

15 — > 


Screen: 107 


Screen: 110 


0 ( 

valDOS file editor 1.0 

) 

0 ( 

valDOS file editor 1.6 

5 ) 

J. 



1 



n y 

LMOVE ( f t 

) 

2 : 

OOPSV 

( — ) 

3 

40 CMOVE ; 


3 

BOL QOF'SLN 38 CMOVE ; 


4 



4 



5 : 

BOL ( — 

a ) 

5 



6 

88 3 YLOC 1+ LLEN # + 2+ ; 


6 : 

7FULL 

( — ) 

7 



7 

MEMTOP 1- TXTEND U< 

G 

8 : 

SBL < — 

a > 

8 

DUP TO 72BIG 

9 

88 3 LLEN #LNS 1+ * + ; 


9 

IF 


10 



10 

1500 0 


1 1 : 

PEL ( — 

a ) 

1 1 

DO 


12 

PAD 128 + ; 


12 

0 53279 C! 


13 



1 3 

LOOP 


14 : 

F'BLL C — 

a ) 

14 

ENDIF ; 


15 

F'BL BLEN + LLEN - ; 

— > 

15 


— > 


Screen: 108 



Screen: 111 

0 ( 

valDOS file editor 

1 . 0 

) 

0 < 

valDOS file editor 1.0 

1 




1 


■ 

A. K 

TOF’LN 

( 

— a ) 

a 

SAVLN ( - 

3 

88 3 LLEN + 2+ ; 



3 

7MARK 72BIB NOT AND 

4 




4 

IF 0 TO 7MARK BOL PAD CRAM 

5 : 

BOTLN 

( 

— a ) 

5 

DUP LNCNT <> 

6 

88 3 #LNS LLEN * + 

74 - " 

X-T- JJ 


6 

IF CURLN NXTLN DUP 3 PICK 

7 




7 

LNCNT - DUP >R 4 

8 : 

CURLOC 

( 

— a ) 

8 

TXTEND 3 PICK - R> 

9 

BOL XLOC + ; 



9 

DUP AT TXTEND +! 0< 

10 




10 

IF CMOVE 

1 1 : 

CSHOW 

< 

— a ) 

1 1 

ELSE < CMOVE ENDIF 7FULL 

12 

CURLOC DUP C3 



12 

ENDIF 

13 

128 OR SWAP C! ; 



13 

PAD CURLN ROT BSCD> 

14 




14 

ENDIF ; 

15 



— > 

15 



) 


) 


Screen: 112 

0 ( val DOS file editor 1.0 

1 

2 : DISPLAY ( — ) 

3 TDPLM 2- DSPTOP 

4 1 6 0 

5 DO 

6 PAD 40 BLANKS DUP 

7 PAD 2+ UNCRAM DUP ROT = 

S IF 

9 OVER 40 64 FI LI- 

10 ELSE 

11 PAD 3 PICK LLEN >BSCD 

12 END IF 

13 SWAP 40 + SWAP 

14 LOOP 

15 2DR0F 1 752 C! ; — > 


Screen: 113 

0 ( val DOS file editor 1.0 ) 

1 

2 : GETLN < — ) 

3 CI.JRLN DUP NXTLN 

4 SWAP - TO LNCN'f ; 

5 

6 : GC GETLN CSHOW ; ( — ) 

7 

8 : DC DISPLAY CSHOW ; ( — ) 

9 

10 : CS C BLANK SAVLN ; ( — ) 

1 1 

12 : HOME < dtop — ) 

13 DUP TO DSPTOP TO CURLN 

14 0 TO XLOC 0 TO YLQC 

15 DISPLAY GC ; — > 


Screen: 114 

0 < val DOS file editor 1.0 ) 

1 

2 : ROLLDN ( — ) 

3 DSPTOP DUP 

4 7ENUF 2 DR OF' 2- 3 

5 IF 

6 CS DSPTOP PRVLN 

7 DUP TO DSPTOP 

8 FAD 40 BLANKS PAD 2+ 

9 UNCRAM DROP PAD 

10 TQPL.N 2- DUP DUP 40 + 

11 600 CCMOVE LLEN >BSCD 

12 CURLN PRVLN TO CURLN GC 

13 ELSE 

14 NORPT 

15 END IF ; — > 


Screen; 115 

0 ( val DOS file editor 1.0 

1 

2 : ROLLUP < — ) 

3 DSPTOP CS 

4 7ENUF SWAP 1+ TO DSPBOT 

5 16 <> DSPBOT C3 0= OR NOT 

6 IF 

7 CURLN NXTLN TO CURLN 

8 TOF'LN 2- DUP 40 + SWAP 600 

9 CMOVE PAD 40 BLANKS 

10 DSPBOT PAD 2+ UNCRAM DROP 

11 PAD BOTLN 2- LLEN >BBCD 

12 DSPTOP NXTLN TO DSPTOP 

13 ELSE 

14 NORPT 

15 END I F GC ; — > 


Screen: 116 

0 ( val DOS file editor 1.0 ) 

1 

2 : UF'CUR ( — ) 

3 7MULTI 0= YLOC OR 

4 IF YLOC 

5 IF 

6 CS CURLN PRVLN TO CURLN 

7 -1 AT YLOC +! GC 

8 ELSE 

9 ROLLDN 

10 END IF 

1 1 ELBE 

12 NORPT 

13 END IF ; 

14 

15 — > 


Screen: 117 

0 < val DOS file editor 1.0 ) 

1 

2 : DNCUR ( — ) 

3 7MULTI 0= YLOC 15 <> OR 

4 IF YLOC #LNS 1- = 

5 IF 

6 ROLLUP 

7 ELSE 

8 CURLOC 40 + C3 64 <> 

9 IF 

10 CS CURLN NXTLN TO CURLN 

11 1 AT YLOC +! GETLN 

12 ENDIF 

13 ENDIF 

14 ELSE NORPT 

15 ENDIF CSHOW ; — > 


Screen: 118 


Screen; 121 


0 ( 

val DOS -file editor 1.0 

) 

0 ( 

1 

val DOS tile 

editor 1. 

1 

jL- u 

LFCUR 

( — ) 

i. 

2 5 

BYTDEL 


3 

XLOC 1-- DUP 0< 


3 

□BLANK 


4 

IF UPCUR DROP 37 END IF 


4 

XLOC 37 < 


5 

□BLANK TO XLOC CSHOW 7MULTI 

5 

IF 



IF XLOC TO 7MULTI END IF 


6 

CURLOC DUP 1+ SWAP 

7 



7 

37 XLOC - 

CMOVE 

8 : 

RTCUR 

( — ) 

8 

END IF 


9 

XLOC 1+ DUP 37 > 


9 

0 CURLOC 


10 

IF DROP 0 DNCUR END IF 


10 

37 XLOC - + 

C! 

1 1 

□BLANK TO XLOC CSHOW 7MULTI 

1 1 

CSHOW EDMRK 

5 

12 

IF XLOC 37 <> TO 7MULTI 

THEN ; 

12 
1 3 



1 3 

14 : 

EDMRK 


14 



15 

1 TO 7MARK 1 TO 7UPDAT 

5 

15 




Screen; 119 




Screen 

: 122 

0 

< val DOS tile 

ed i tor 

1.0 

) 

0 < 

I 

val DOS tile editor 1.0 

1 

: INTEL 



( — > 

. 1 . 

o , 

LNINS < - 

3 

INSRT NOT TO 

i INSRT 

NORPT 5 

.3 

72BIB NOT 

4 





4 

IF 

isr ( 

: CLREOL 



( — > 

5 

CS YLOC 15 < 

6 

□BLANK OOPSV CURLOC 38 

XLOC - 

6 

IF BOL 2- DUP LLEN + #LN5 

7 

ERASE CSHOW 

EDMRK 

NORPT 

5 

7 

YLOC - LLEN * < CMOVE 

8 





8 

END IF 

9 

HEX 




9 

BOL 2- 40 ERASE CURLN 

10 

CODE 2'- 


< n - 

- 2 ‘"n ) 

10 

DUP TXTEND OVER - 1+ 

11 

B4 C, 00 C, 

C 8 C, 

A9 C, 

00 C, 

1 1 

OVER 1+ SWAP < CMOVE 155 

12 

95 C, 00 C, 

95 C, 

01 C„ 

38 C, 

12 

SWAP C! 1 AT TXTEND +! 

1 3 

36 C, 00 C, 

36 C, 

01 C, 

18 C, 

13 

<3C 1 TO 7UPDAT 

14 

88 C, D0 C, 

F8 C, 

4C C, 

NEXT , 

14 

END IF 

15 

C; DCX 



■> 

15 

7FULL ; 


Screen 

i: 120 


Screen: 123 

0 < 

valDOS tile editor 1.0 

) 

0 ( 

val DOS tile editor 1.0 

1 



1 


XU n 

BYTINS 

( — > 

O ■ 

BON XT < - 


CBLANK XLOC 37 < 


t; 

CS 0 TO XLOC 

4 

IF 


4 

CURLN NXTLN C3 0= PTFL8 OR 

5 

CURLOC DUP 1+ 


5 

72BIG NOT AND 

6 

37 XLOC -- < CMOVE 


6 

IF 

7 

ENDIF 


7 

CURLN NXTLN 

8 

0 CURLOC C! 


8 

DUP DUP 1+ TXTEND 3 PICK 

9 

CSHOW EDMRK 5 


9 

- 2+ < CMOVE 155 SWAP C! 

10 



10 

1 AT TXTEND +! 

11 



1 1 

DISPLAY 7FULL. 

12 



12 

1 TO 71JPDAT 

13 



13 

END I F 

14 



14 

DNCUR 

15 


— > 

15 

0 TO PTFLG ; 


) 


) 


Screens 124 

0 ( valDOS file editor 1.0 

1 

2 : LNDEL ( — ) 

3 YLQC CLJRLOC 40 + C3 

4 64 <> OR 

5 IF CBLANK OOPSV 

6 CURLN DUP NXTLN 2DUP 

7 SWAP IX TEND 3 PICK - 2+ 

8 CMOVE - AT TXTEND +! 

9 0 TO ?MARK BETLN DISPLAY 

10 CURLOC 03 -64 = 

11 IF IJF'CUR NORPT END IF 

12 CSHOW 1 TO 7UPDAT 

13 ELSE 

14 NORPT 

1 5 END I F 5 


Screen: 127 

0 < valDOS file editor 1.0 

1 

2 : >BFNXT BFCPY DNCLJR ; ( — ) 

3 

4 : >BFLN BFCPY LNDEL ; < — ) 

5 

6 : BFRPL ( — ) 

7 CBLANK OOPSV 

8 PBLL 2+ BOL 38 CMOVE EDMRK 

9 < BFROT CSHOW EDMRK ; 

10 

11 : TABSTP < — ) 

12 XLOC 8 /MOD TABS + 

13 SWAP 2-- OVER C3) OR 

14 SWAP C! NORPT ; 

13 — > 


o 


Screen: 125 

0 ( valDOS file editor 1.0 ) 

1 

2 : BFSHW ( — ) 

3 PBLL L.LEN 2# 2* -- 

4 SBL L.LEN 5 * CMOVE ; 

5 

6 : BFROT ( — ) 

7 PEL. DUP BLEN + L..MOVE 

8 PBL DUP LLEN + SWAP 

9 BLEN LLEN - CMOVE 

10 PBLL LLEN + PBLL LMOVE 

1 1 BFSHW ; 

12 

13 : BFCPY < — ) 

14 CBLANK BFROT BOL PBLL 2+ 

15 38 CMOVE BFSHW CSHOW ; — > 


Screen: 128 

0 ( valDOS file editor 1,0 ) 

1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


TABCLR ( — ) 

XLOC 8 /MOD TABS + 

SWAP 2~ 255 XOR OVER 
03 AND SWAP C! NORPT ; 

TAB CBLANK < — ) 

38 

BEGIN 

1- 1 AT XLOC +! XLOC 
38 MOD 8 /MOD TABS + 

C3 SWAP 2 '" AND OVER 0= OR 
UNTIL DROP XLOC 
38 /MOD SWAP TO XLOC 
IF DNCUR END IF CSHOW ; — > 


Screen: 126 


0 < 
1 

valDOS file editor 

1.0 ) 

i 

2 . * 

< BFROT 

( — ) 

T 

PBLL DUP LLEN + 1..M0VE 

4 

PBL DUP LLEN + 


5 

BLEN LLEN - < CMOVE 


6 

PBL DUP BLEN + 


7 

SWAP LMOVE BFSHW ; 


8 

9 : 

BFCLR 

< — ) 

1 0 

PBLL LLEN ERASE 


1 1 

< BFROT 5 


12 
13 : 

BFL.N> 

( — ) 

14 

LNINS PBLL 2+ BOL 3 

;s CMOVE 

15 

CSHOW < BFROT EDMRK 

5 •'*" 


Screen: 129 

0 < valDOS file editor 1.0 ) 

1 

2 : RUB < — ) 

3 XLOC 

4 IF LFCUR 0 CURLOC C! 

5 CSHOW EDMRK 

6 END IF 

7 INSRT IF BYTDEL END IF NORPT ; 

8 

9 : BOTSCR ( — ) 

10 15 XLOC - -DUP 

11 IF 0 DO DNCUR LOOP END IF ; 

12 

13 : OOPS ( — > 

14 LNINS OOF'SLN BOL 38 CMOVE 

15 EDMRK CSHOW NORPT r, — > 


) 


Screen: 130 

0 ( valDOS -file editor 1.0 

1 

2 : PTCHR < — > 

3 LSTCHR 13 = 7MULTI 1 <> AND 

4 IF 

5 1 TO PTFLG BONXT 

6 ELSE EDMRK 

7 INSRT IF BYTINS END IF 

B LSTCHR >SCD CURLOC C! 

9 XL.OC 37 = 


10 

IF 1 

TO 

PTFLG BONXT 


1 1 
12 
1 T 

ELSE 
ENDIF 5 

RTCUR ENDIF CSHOW 


. 1 . 

14 : 

; F'RVSCR 


( 

) 

15 

#LN5 0 

DO 

ROLL.DN LOOP 5 

> 


reen 

: 131 



0 ( 

1 

valDOS 

file editor 1.0 

) 

NXTSCR 


( — ) 

3 

#LNS 0 

DO ROLLUP LOOP ; 



4 

5 : SPLCHR C — ) 

6 0 7MULTI 0= 

7 IF 1+ 37 88 3 25 + C! ENDIF 

8 TO 7MULTI ; 

9 

10 : MULTI ( — > 

11 0 7MULTI 0= 

12 IF 2+ 57 88 3 25 + C ! ENDIF 

13 TO 7MULTI ; 

14 

15 — > 


Screen: 133 

0 ( valDOS file editor 1.0 ) 

1 

2 FORTH DEFINITIONS ( 

3 

4 : .INFO EDITOR ( — > 

5 CR File start addr: " 

6 TXTBOT DUP U. 

7 CR . " Fi le end addr: " 

8 TXTEND 2- DUP U. 

9 CR File count: " 

10 SWAP - U. 

11 CR . " Bytes -free: " 

12 MEMTOP TXTEND - 

13 0 MAX U. CR ; 

14 

15 EDITOR DEFINITIONS — > 


Screen: 134 

0 < valDOS file editor 1.0 ) 

1 

2 : WIFEIT < — > 

3 88 3 40 + 640 ERASE 

4 12 84 C! 0 752 C ! CR ; 

5 

6 : FLFL ( — ) 

7 TXTBOT HOME ; 

8 

9 : FLLL ( — > 

10 TXTEND 2-- 15 0 

11 DO F'RVLN LOOP HOME BOTSCR ; 

12 

13 : FLEN ( — ) 

14 CURLN NXTLN DUP 

15 2+ TO TXTEND 0 SWAP ! DC ; — > 


Screen: 132 

0 ( valDOS file editor 1.0 ) 

1 : SPLT < — ) 

2 CBLANK BOL EDWRK 38 CMOVE 

3 XLOC CLREOL 1 TO PTFL 6 BONXT 

4 CBLANK TO XLOC EDWRK XLOC + 

5 BOL XLOC + 38 XLOC - CMOVE 

6 EDMRK CSHOW ; 

7 

8 : -SPLT < — > 

9 CURLN TXTBOT <> 

10 IF CBLANK BOL EDWRK 38 CMOVE 

11 LNDEL UPCLIR CBLANK OOF'SV 

12 EDWRK XLOC + BOL XLOC + 

13 38 XLOC - CMOVE CSHOW EDMRK 

14 EDWRK OOPSLN XLOC CMOVE 

15 ENDIF NORPT ; — > 


Screen: 135 

0 ( valDOS file editor 1.0 > 


1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


SRCH 

SRC FIT C3 

IF CS CURLN XLOC + 1+ TXTEND 
OVER - SRCH* COUNT MATCH SWAP 
IF CURLN XLOC + + DUP 
F'RVLN DUP TO CURLN - 
TO XLOC 0 TO YLDC CURLN 
6 0 DO 

DUP PRVLN SWAP OVER 
<> AT YLOC +! 

LOOP TO DSPTOP GETLN DC 
ELSE DROP WIPE IT CR 

. " Not found" CRWT FLFL 
ENDIF 
ENDIF ; 


Screen: 136 

0 ( valDDS -file editor 1.0 

1 

2 : GET* ( del m — 

3 >R PAD 2+ 

4 BE6IN DUP C5> R = 

5 WHILE 1+ REPEAT DUP 


Screen: 139 

) 0 < valDOS file editor 1.0 

1 

* > 2 : SUBCMD 

3 CS WIPE IT 

4 . " : " PAD 32 ERASE 

5 PAD 31 EXPECT CR PAD 3 


6 

BEGIN DUP CS DUP R < 


6 

SEL ( 

ST) 

21587 

~> 

FLST 

7 

SWAP 0# AND 


7 

( 

EN) 

20037 

™> 

FLEN 

8 

WHILE 1+ REPEAT OVER 

- OVER 

a 

( 

FL) 

19526 

--> 

FLFL 

9 

1- C! 1- R > DROP ; 


9 

( 

LL) 

19532 

~> 

FLLL 

10 



10 

( 

IF) 

17993 

-> 

I NFL 

1 1 : 

STSRCH 

( — ) 

1 1 

( 

PS) 

21328 

-> 

STSRCH 

12 

. " 7 " PAD 31 EXPECT 


12 

( 

RT) 

21586 

— > 

TABRST 

13 

CR 88 0 564 + SRCH* 

1+ CRAM 

13 



0 

~> 

DC 

14 

1-- SRCH* C! SRCH* 1 + 

DUP 

14 

NOSEL 

BADSUB 



15 

33 BSCD> SRCH |l 

— > 

15 

SELEND s 





tier 

0 

1 

r> 


eens 137 

( valDOS file editor 1, 


0 


) 


( — ) 


I NFL DOS 

3 INERT 0 TO INSRT 

4 BL GET* (OPEN) 

5 IF DC LNINS 

6 BEGIN 

7 7TERMINAL 72BIG OR NOT DUP 

8 IF DROP DUP (RDB) END IF 

9 WHILE 

10 DUP 155 = 

11 IF DROP 13 END IF 

12 TO LSTCHR PTCHR 

13 REPEAT (CLOSE) DROP 

1 4 ELSE CR 

15 ." Unable to load file" — > 


1 . 0 


Screen: 140 

0 ( valDOS file editor 

1 

2 : EDTABT ( — ) 

3 CS WIPE IT . " Abort? " 

4 +Y/N 19 * DUP TO LSTCHR 0= 

5 IF DC ELSE 7UPDAT 0= 

6 IF CURL.N TXTBDT - TO ED# IN 

7 ELSE TXTBOT DUP TO DSF'TOP 

8 TO CURLN 0 TO XLDC 0 TO YL..QC 

9 END IF END IF NORF'T ; 

10 

11 : EXIT DOS ( — > 

12 CS WIPE IT 8 84 C! 

13 .INFO CR ." Save 

14 EDN2* COUNT TYPE ." " 7 " 

15 +Y/N 19 * DUP TO LSTCHR — > 


Screen: 138 


6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


( valDOS file editor 1.0 ) 

CRWT WIPE I T DC 
END IF TO INSRT ; 

: FL3T ( — > 

CURLN TXTBOT 2DUP 
TXTEND CURLN - 1+ CMOVE 
- MINUS AT TXTEND +! FLFL : 


TABRST 

TABS 4 68 FILL 
36 TABS 4 + C! DC ; 

BADSUB 

CR ." Bad subcommand' 
CRWT WIPE IT DC : 


( 


Screen: 141 

0 ( valDOS file editor 1.0 

1 IF EDN2* (OPEN) 0= 

2 IF 0 DSKERR FLDNE = 

3 IF DROP EDN2* (ENTER) 

4 DROP EDN2* (OPEN) 

5 ENDIF 

6 0= IF DC ; S ENDIF 

7 ENDIF 

8 SWAP DROP TO EDFL# 

9 TXTBOT TXTEND 2- OVER - 

10 EDFL# (WRITE) DROP EDFL# 

11 (ENDF) DROP EDFL# (CLOSE) 

12 CURLN TXTBOT - TO ED# IN 

13 ELSE 

14 DC 

15 ENDIF ; 


) 


Screen 

a 142 




0 ( 

val DOS 

file editor 1 . 


1 

n 

CONTROL 



( n — 

3 

SEL 




4 

19 ~> 

EXIT 

17 -> 

EDTABT 

5 

28 -> 

UPCUR 

29 -> 

DNCUR 

6 

30 — > 

LFCUR 

31 -> 

RTCUR 

7 

126 -> 

RUB 

127 -> 

TAB 

B 

9 — > 

INTGL 

155 -> 

BONXT 

9 

255 — '■> 

• BYTINS 

254 -> 

BYTDEL 

10 

157 -> 

■ LNINS 

156 -> 

LNDEL 

11 

18 -> 

■ BFROT 

2 -> 

< BFROT 

12 

3 -> 

■ BFCLR 

11 -> 

JBFNXT 

13 

2 0 — y 

■ >BFL.N 

6 -> 

BFLN> 

14 

16 -O 

■ F'RVSCR 

14 ~> 

NXTSCR 

15 

15 ~ 

> OOPS 


— 


Screen 

: 143 




0 ( 
1 

val DOS file editor 

1, 

. 0 

27 --> SF'LCHR 

8 


> CLREOL 

3 

21 -> BFRPL 

25 


> MULTI 

4 

24 -> ROLLDN 

5 

- 

> ROLLUP 

5 

22 -> SUBCMD 

12 


> SRCH 

6 

10 -> SPLT 

7 

- 

> -SPLT 

7 

159 -> TABSTP 

158 


> TABCLR 

0 

o 

NOSEL PTCHR SELEND 

s 


7 

10 : 

2STRQKE 



( — 

1 1 

7MULTI 1 = 




12 

IF DROP PTCHR 




13 

EL.SE 




14 

7MULTI 2 = 




15 

IF 





Screen: 144 

0 ( val DOS file editor 1.0 > 

1 

2 BEGIN 

3 8 53279 C! DUF CONTROL 

4 7MIJLTI NOT 7TERMINAL OR 

5 UNTIL 

6 DROP END IF 

7 END IF 

S 0 TO LSTCHR NORPT 
9 0 38 3 25 + C ! ; 

10 

11 : EDTSTP DOS < *i — > 

12 DECIMAL 1 PFLAG ! 

13 F'BL BLEN + LL.EN + 2+ 

14 TO TXTBOT 

15 EDN1* (OPEN) 7SYSERR 


Screen: 145 

0 ( val DOS file editor 1.0 

1 

2 SWAP DROP TO EDFL# 

3 0 TXTBOT 2- ! 155 TXTBOT C! 

4 TXTBOT MEMTOF OVER - DUP 

5 <ROT EDFL# (READ) 

6 IF EDFL# (CLOSE) 

7 FLTBG CMDERR 

8 ENDIF 

9 DSKERR EOFERR = 7SYSERR 

10 EDFL# (CLOSE) 

11 #UNTRN - DUF 0= + TXTBOT + 

12 DUP 2+ TO TXTEND 0 SWAP ! 

13 0 TO ED# IN 0 TO 7UPDAT ; 

14 

15 


Screen: 146 

0 ( val DOS file editor 1.0 

1 

2 : PROCESS DOS < ~ 

3 

4 0 GR. 1 752 C! CLS 

5 112 560 3 6 + C! 

6 112 560 3 23 + C ! 

7 . " File: " EDN2* *. 

8 28 85 ! 

9 #Buf s: " BLEN L.LEN / . 

10 GETLN DC 

1 1 

12 PAD 7PADSM OVER TO 7PADSM = 

13 PEL 3 7BUFSM = AMD NOT 

14 IF PEL BLEN ERASE ENDIF 

1 5 BFSHW 


Screen: 147 

0 ( val DOS file editor 1.0 

1 

2 BEGIN 

3 INKEY* DUF TO LSTCHR -DUF 

4 IF 

5 7MULTI 

6 IF 2STR0KE 

7 ELSE CONTROL ENDIF 

Q ELSE 

9 INSRT 

10 IF CBLANK ( PAUSE) 

11 2DUP DROP DROP CSHOW 

12 ENDIF 

13 ENDIF 

14 LSTCHR 19 = 

15 UNTIL 


) 


Screen: 148 

0 ( val DOS file editor 1.0 

1 

2 0 767 C! 0 752 C! 

3 2 560 5) 6 + C ! 

4 2 560 3 23 + C! 

5 CLS CR 

6 Last edit in: " EDN2* 

7 *. CR .INFO CR 

8 PEL. 3 TO 7BUFSM 

9 DSKFLS ; 

1.0 

1 1 
12 

13 

14 

15 


Screen: 149 

0 ( val DOS file editor 1.0 ) 

1 

2 FORTH DEFINITIONS 

4 s EDIT DOS ( — ) 

5 6ETAR6S 7WRGARG 

6 TOPOM 40 -- EDITOR TO MENTOR 

7 DOS 44 ( " ,, " > GET ARB 0= 

8 IF DIJP END IF TO Nl* TO N2* 

9 0 (CLOSE) N 1 $ (?OPEN) 

1 0 I F 

1 1 0= FLOPN 7CMDERR 

12 ELSE 

13 DSKERR FLDNE = 7SYSERR 

14 

15 — 


Screen: 150 

0 ( val DOS file editor 1.0 ) 

1 

2 CR Ml* *. 

3 . " does not exist, create? " 

4 +Y/N NOT CR IF ;S END IF 

5 Nl$ (ENTER) 7SYSERR 

6 END IF 

7 UNIT DIRTBL C® ENTRY 1+ ® 

8 N2* (70PEN) 

9 IF 

10 0= FLOPN 7CMDERR 

11 UNIT DIRTBL C® ENTRY 1+ ® 

12 ELSE 

13 DSKERR FLDNE = 7SYSERR 0 

14 END IF - 

15 


Screen: 151 

0 ( valDOS file editor 1.0 ) 

1 

2 UNIT FSMBET 

3 FSMAP 3 + ® SWAP - DUP 20 < 

4 IF CR 

5 . " Warning, disk space " 0> 

6 IF . " low'"' 

7 ELSE ." empty" END IF 

8 . " , edit?" 

9 +Y/N NOT CR IF ;S END IF 

10 ELSE DROP END IF 

11 UNIT DIRTBL C® ENTRY C® 32 AND 

12 IF CR 

13 . " File is locked, edit? " 

14 +Y/N NOT CR IF ; S END IF 

15 END IF — > 


Screen: 152 

0 ( val DOS file editor 1.0 ) 

1 

2 Nl* EDITOR EDN1 * OVER 

3 C® 1+ 16 MIN CMOVE 

4 DOS N2$ EDITOR EDN2* OVER 

5 C® 1+ 16 MIN CMOVE 

6 EDTSTP 0 TO INSRT 

7 TXTBOT DUP TO DSPTOF TO CURLN 

8 0 TO XLOC 0 TO YLOC GETLN 

9 CR . INFO CRWT PROCESS ; 

10 

11 FORTH 

12 

13 

14 

15 — > 


Screen: 153 

0 ( val DOS file editor 1.0 ) 

1 

2 : LL. EDITOR < — > 

3 EBN2S EDN1* 16 CMOVE 

4 PAD 7PADSM <> 

5 IF 0 TO XLOC 0 TO YLOC F'BL. 

6 BLEN + LLEN + 2+ DUP TO TXTBOT 

7 DUP TO DSF'TOP TO CURLN 

8 BETLN END IF EDTSTP PROCESS ; 

9 

10 : WHERE DOS ( — > 

11 FLF'L# FLBUF® -DUP 0= 

12 IF 

13 CR No error on record..." 

14 CR QUIT 

15 END IF — > 


Screens 154 Screens 

0 ( val DOS file editor 1.0 ) 0 


1 

0 (CLOSE) 14 + 3 

1 

o 


FLNME EDITOR EDN1* 16 CMOVE 

3 

4 

DOS FLNME: EDITOR EDN2H 

4 

5 

16 CMOVE EDTSTP 

5 

6 

1- TXTBOT + DUP PRVLN 

6 

7 

SWAP OVER - 1- TO XLOC 

7 

8 

DIJP TO CURLN 0 TO YLOC 6 0 

8 

9 

DO 

9 

10 

DUP PRVLN 

10 

1 1 

SWAP OVER < > AT YLOC + ! 

11 

12 

LOOP 

12 

15 

TO DSPTOP 

13 

14 

1 TO INSRT 

14 

15 

PROCESS ; — > 

15 


Screens 155 

Screen 

0 

( valDOS file editor 1.0 ) 

0 

1 


1 

2 

s #BUFS EDITOR < n — ) 


3 

5 MAX 320 MIN LLEN * 

3 

4 

7 BLEM ! 0 TO 7PADSM 

4 

5 

PEL BLEN + LLEN + 2+ 

5 

6 

DUF TO TXTBOT DUP 

6 

7 

TO DSPTOP TO CURLN 

7 

8 

0 TO XLOC 0 TO YLOC f 

8 

9 


9 

10 

FORTH 

10 

1 1 


11 

12 

BASE 1 

12 

13 


13 

14 


14 

15 


15 


157 


158 


Screens 156 
0 

Screen 

1 

0 

1 

2 

n 

X- 

3 

t; 

4 

4 

5 

5 

6 

6 

7 

7 

8 

8 

9 

9 

10 

10 

1 1 

1 1 

12 

12 

13 

13 

14 

14 


Screens 160 ocreen: 

0 < file editor load message ) 0 

1 1 

2 CLS 2 

3 CR CR CR 3 

4 . " valDOS and the basic DOS" CR 4 

5 . " commands must be loaded" CR 5 

6 before the file editor" CR 6 

7 , " is compiled." CR 

B C,R 8 

9 . " Insert the valDOS I disk" CR 9 

10 . " and load the necessary" CR 10 

11 ." routines." CR 11 

12 CR CR 12 

13 FLUSH 13 

14 14 

15 15 


Screen: 161 Screen: 

0 0 

1 1 


4 

5 

6 

7 

8 
9 

10 
1 1 . 
12 

13 

14 

15 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 162 
0 

1 


Screen : 
0 
1 


4 

ej 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

1 5 


163 


164 


1 65 


Screen; 166 
0 
1 


4 

5 

6 

7 

a 

9 

10 
1 1 
12 

13 

14 

15 


Screen: 169 
0 
1 


4 

5 

6 

7 
B 
9 
10 
1 1 
12 

13 

14 

15 


o 


Screen: 167 

0 

1 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen; 170 

0 CONTENTS OF THIS DISK: 

1 

2 CASE STATEMENTS: 

3 SCREEN CODE CONVERSION: 

4 KEYSTROKE WORDS: 

5 DOS FILE EDITOR 1.0: 

6 


50 LOAD 
60 LOAD 
70 LOAD 
100 LOAD 


7 

B 

9 

10 


**** CAUTION **## CAUTION #*## 

This is a DOS -format disk 
with screens 50-79 and 100-179 


o 


11 locked out for FORTH source 

12 code. Do not store FORTH 

13 code on screens that are not 

14 locked out! 

15 


Screen: 168 
0 
1 


Screen : 


0 

1 


171 


4 

5 

6 
7 
S 
9 

10 
1 1 
12 

13 

14 

15 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


( 


Screen: 172 

0 

1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 173 

0 

1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 174 

0 ( valDQS error messages ) 

1 Illegal filename 

2 Bad/Mi smatched unit(s) 

3 E-iad free space map 

4 File already exists 

5 Directory is full 

6 Disk is full 

7 Filename is ambiguous 

8 File does not exist. 

9 No room for buffer- 

10 End of file encountered 

11 File is not open 

12 Illegal file number 

13 File is locked 

14 Bad argument list 

15 File is open 


Screen: 175 

0 File is too big 

1 File is random 

2 File is not random 

3 No room for random map 

4 Random map is bad 

5 File is a device file 

6 File is not a device file 

7 Illegal access to device file 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 176 

0 ( Error messages 

1 

2 Stack empty 

3 

4 Dictionary full 

5 

6 Wrong addressing mode 

7 

8 Is not unique 

9 

10 Value error 

1 1 

12 Disk address error 

13 

14 Stack full 

1 5 


Screen: 177 

0 Disk Error! 

1 

2 Dictionary too big 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


) 


Screen: 178 

0 ( Error messages 

1 

2 Use only in Definitions 

4 Execution only 

5 

6 Conditionals not paired 

7 

8 Definition not finished 

9 

10 In protected dictionary 

1 1 

12 Use only when loading 

13 

14 Off current screen 

15 


Screen: 179 

0 Declare VOCABULARY 

1 


A 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 



valFORTH 

T.M. 

SOFTWARE SYSTEM 

for ATARI* 




* 


Atari is a trademark of Atari, Irtc.. a division of Warner Communications. 




Software and Documentation 
©Copyright 1982 
Valpar International 



c 


C) 


o 


valFORTH 

T.M. 

SOFTWARE SYSTEM 


KjwohAumaui e&sKuea 


Stephen Maguire 


Software and Documentation 
©Copyright 1982 
Valpar International 


Purchasers of this software and documentation package are 
authorized only to make backup or archival copies of the 
software, and only for personal use. Copying the accompanying 
documentation is prohibited. 

Copies of software for distribution may be made only as speci- 
fied in the accompanying documentation. 


o 


o 


c 


o 


o 


valFORTH 

T.M. 


Version 1.0 
April 1982 


The following is a description of commands used in creating seemingly 
difficult video displays using players and missiles. Used alone or in combina- 
tion with the other available systems by Val par International, it is possible to 
obtain graphic displays which compare with those of the best arcade games. The 
use of players and missiles (also called "player/missiles") allows the beginner 
to create high quality moving video displays. 


Software and Documentation 
©Copyright 1982 
Valpar International 


c 


o 


o 


VALPAR INTERNATIONAL 


Disclaimer of Warranty 
on Computer Programs 


All Valpar International computer programs are distributed 
on an "as is" basis without warranty of any kind. The total 
risk as to the quality and performance of such programs is with 
the purchaser. Should the programs prove defective following 
their purchase, the purchaser and not the manufacturer, distributor, 
or retailer assumes the entire cost of all necessary servicing or 
repair. 


Valpar International shall have no liability or responsibi 1 ity 
to a purchaser, customer, or any other person or entity with 
respect to any liability, loss, or damage caused directly or 
indirectly by computer programs sold by Valpar International. 

This disclaimer includes but is not limited to any interruption 
of service, loss of business or anticipatory profits or conse- 
quential damages resulting from the use or operation of such 
computer programs. 

Defective media (diskettes) will be replaced if diskette(s) 
is returned to Valpar International within 30 days of date of sale 
to user. 

Defective media (diskettes) which is returned after the 30 day 
sale date will be replaced upon the receipt by Valpar of a $12.00 
Replacement Fee. 


r 


o 


G 


PLAYER/MISSILE GRAPHICS PACKAGE 


XXI. PLAYER/MISSILE GRAPHICS 

a) STROLLING THROUGH PLAYER/MISSILE GRAPHICS 1 

b) PLAYER/MISSILE GLOSSARY 

1) ENABLING PLAYER/MISSILE GRAPHICS 6 

2) CREATING PLAYERS AND MISSILES 10 

3) MOVING/PLACING PLAYERS AND MISSILES 12 

4) SETTING PLAYER/MISSILE BOUNDARIES 14 

5) COLLISIONS BETWEEN PLAYERS AND MISSILES 16 

XXII. CHARACTER EDITOR 

User's manual for the character set editor. 

XXIII. SOUND EDITOR 

Description of the audio-palette sound editor. 

XXIV. PLAYER/MISSILE SUPPLIED SOURCE 


p 


o 


c 


As knowledge of the internal workings of player/missile graphics is not 
necessary to use this val FORTH package effectively, the internal workings are 
not explained in this manual. However, for the serious programmer trying to 
optimize his/her program in every way, an understanding of these internal 
workings could at times improve code efficiency and/or speed of execution. 

For a complete explanation of player/missile graphics at the nut-and-bolt level, 
see the series of articles by Dave and Sandy Small in Creative Computing. 




o 


c> 


Player Missile Graphics 1.0 


STROLLING THROUGH PLAYER/MISSILE GRAPHICS 


One of the biggest differences between the Atari graphic capabilities and 
those of most other computers is the Atari's ability to use players and missiles. 
This discussion will not explain the internal workings of player/missile graphics 
on the Atari; rather, it will explain how to use the basic commands in this 
val FORTH package. Before we proceed, please load the player/missile graphic 
routines from the Player/Missile disk. The directory on screen 170 will show 
what screen to load. Also, if you have the val FORTH Editor/Utilities package, 
load in the high speed STICK command found in the Miscellaneous Utilities; 
otherwise, load in the slower version on your Player/Missile disk. (Check the 
directory for its location). 


To start with, let's get a simple player up on the screen to experiment with. 
First we must initialize the player/missile graphic system and design the player's 
image. This is simple: 


1 PMINIT 

2 BASE ! 


( Initialize for single 
resolution players ) 

( Change to binary for ease ) 


LABEL CROSS 
00011000 C, 
00011000 C, 
00011000 C, 
11111111 C, 
11111111 C, 

00011000 c, 
00011000 c, 
00011000 c, 

DECIMAL 

PMCLR 

ON PLAYERS 
CROSS 8 180 


( Give the player image a name ) 
( A large plus sign ) 


( Now back into base 10 ) 

( Clear player/missile memory ) 
( Turn on the players ) 

50 0 BLDPLY ( Build a player ) 


You should now see the cross in the upper right-hand corner of the video screen. 
Now let's take a look at this and see how it works. 


First, players are initialized using the PMINIT command. Players can be in 
either a single or double resolution mode (double res players are twice as tall). 
"1 PMINIT" is used for single res players. If we had wanted double res players, 
we would have used "2 PMINIT". 


Next, the player image is created. Since it is much easier to make player 
images as l's and 0's, we use binary (base two) number entry. Before we design 
the image, it must be given a name. The LABEL command does this nicely for us. 


XXI - 1 


Player Missile Graphics 1.0 


This image is named CROSS. All that need be done now is to draw the picture. 
Notice how easy it is to see the image when using base two. Of course, we could 
have stayed in base 10 and still designed the image, but this is usually more 
difficult. The word C, after each number simply tells FORTH to store that number 
in the dictionary. Once the picture is designed, we return to decimal for ease. 

Both the PMCLR and ON PLAYERS commands are fairly self-descriptive: PMCLR 

erases all players and missiles so that no random trash appears when the PLAYERS 
are turned ON. Next, the BLDPLY (build player) command takes the image named 
CROSS which is 8 bytes tall and assigns it to player 0 at horizontal location 180 
and vertical location 50 on the display. Of course, we could have built player 
1, 2, or 3 instead. 

The cross should be black. Suppose we wanted a blue or green cross instead. 
This can be done using the PMCOL (player/missile color) command. Try this: 

098 PMCOL ( player hue lum PMCOL ) 

The cross should now appear blue. This command assigns a BLUE (9) hue with a 
luminance of 8 to player 0. If the color commands are loaded from the valFORTH 
disk. 


0 BLUE 8 PMCOL 

could have been used with the same results. Try changing the color of the player 
to GREEN (12) or PINK (4). Note that the default colors for players 2 and 3 make 
them invisible: Their colors should be set immediately upon being built. 

Now that we have a player on the screen, let's move it around. We use the 
PLYMV (player move) command for this. PLYMV needs to know which player to move 
(there could be as many as five), how far to move it in the horizontal direction, 
and how far to move it in the vertical direction. Try this: 


1 

1 

0 

PLYMV 

( horz vert player PLYMV ) 

This moves 

player 0 

down 1 line and right one horizontal position, thus giving the 

effect 

of 

a di 

agonal 

move towards the lower right-hand corner. Try these as well: 

1 

0 

0 

PLYMV 

( move right one position ) 

-5 

0 

0 

PLYMV 

( move left five positions ) 

0 

20 

0 

PLYMV 

( move down 20 lines ) 

0 - 

■15 

0 

PLYMV 

( move up 15 lines ) 

-5 

2 

0 

PLYMV 

( move left five, and down two ) 


That's all there is to moving a player. Positive horizontal offsets move the 
player right, and negative values move the player left. Likewise, positive 
vertical offsets move the player down while negative ones move the player up. 
The following program can be typed in and you will have a joystick controlled 
player: 


XXI -2 


Player Missile Graphics 1.0 


: JOY 
BEGIN 
0 STICK 
0 PLYMV 
7TERMINAL 
UNTIL ; 

JOY <ret> 

Move the player with stick 0, the left-most stick port. Press any console button 
to exit the program. 

Currently, if the player is moved off any edge, it “wraps" to the opposite 
side. In other words, we have an "unbound" player. This is rarely desirable. 
Normally, we want to restrict player movement to certain boundaries. The PLYMV 
command has a built in boundary check routine specifically for this reason. 

Right now, new boundaries are set so wrapping occurs. Let's set some boundaries: 

60 150 50 200 0 PLYBND 

This sets the boundaries of player zero to 75 on the left, 150 on the right, 50 
on the top, and 200 on the bottom. Type JOY again to verify that you can no 
longer move freely about the display. Try different boundary settings and 
experiment to get the feel of the command. Boundary checking can be disabled 
for any or all of the edges. Setting the left or upper boundary to 0 will 
disable the check on that edge, likewise, 255 in either the right or lower 
boundary will do the same. 

Let's build another player in the lower right-hand corner of the screen. 

This time, instead of designing the player ourself, let's borrow the image 
from the standard Atari character set stored in ROM. The image of the digit 
zero starts at address 57472. The other numbers follow zero. Try this: 

57472 16 160 150 1 BLDPLY 

You should now see the numbers 0 and 1 on your screen. This command builds 
player 1 with the image at address 57472 that is 16 bytes tall and puts it at 
horizontal position 160 and vertical position 150. Give this player a color 
if you want. 

Until now, we have been using normal size players. It is possible to make 
the two players on the display different widths using the PLYWID command. 

PLYWID expects a width specification of 0 or 2 (normal), 1 (double), or 3 
(quadruple). Its command form is: 

width player PLYWID 


( STICK leaves two offsets ) 
( for PLYMV to use. ) 


Thus, 


3 1 PLYWID 

should make player one four times its original size. The same can be done with 
player zero: 

3 0 PLYWID 


XX 1-3 


Player Missile Graphics 1.0 


Type JOY again and notice that the width has no effect on movement whatsoever. 
Also notice that player one is unaffected by movement of player zero. 

Now that we have two players on the screen, let's interface both of them 
to the joystick. Type in the following program: 

: J0Y2 

BEGIN 
0 STICK 
2DUP 

0 PLYMV 
SWAP 

1 PLYMV 
7TERMINAL 

UNTIL ; 

J0Y2 <ret> 

Notice that when you push the stick up, player zero goes up, but player one 
moves left. The SWAP instruction exchanges the vertical and horizontal offsets 
from STICK before moving player one. If we were to take the SWAP out, the 
players would move identically. 

In many applications, it is necessary to know when a player has hit another 
player or some background image. Fortunately, the Atari computer automatically 
makes this information available. An entire collection of valFORTH words allows 
checking of all collisions possible. The most general word is ?C0L which simply 
returns a true flag if anything has hit anything else. Here is an example: 

: BUMP 

BEGIN 
HITCLR 
0 STICK 
0 PLYMV 
?C0L 
IF 

CR ." oops!" 

ENDIF 
2TERMINAL 
UNTIL ; 

BUMP <ret> 

Move the player around and watch the results. Every time you hit any letters 
or player one, the word "oops!" should be printed out. This program is quite 
simple. First, the HITCLR command is issued which erases any old collision 
information. If this command were omitted, the first time a collision occurred, 
"oops!" would be continuously printed out. Next the joystick is read and the 
player moved. If the player touches anything when moved, the collision 
registers are set. ?C0L reads these registers and leaves a true flag if the 
player has hit something, and the IF statement will then print out "oops!". 


( Record stick movement ) 

( Make a copy ) 

( Move player 0 ) 

( Rotate stick 90 degrees ) 
( Move player 1 ) 


XXI -4 


Player Missile Graphics 1.0 


Type JOY again and notice that the width has no effect on movement whatsoever. 
Also notice that player one is unaffected by movement of player zero. 

Now that we have two players on the screen, let's interface both of them 
to the joystick. Type in the following program: 

: J0Y2 

BEGIN 
0 STICK 
2DUP 

0 PLYMV 
SWAP 

1 PLYMV 
2TERMINAL 

UNTIL ; 

J0Y2 <ret> 

Notice that when you push the stick up, player zero goes up, but player one 
moves left. The SWAP instruction exchanges the vertical and horizontal offsets 
from STICK before moving player one. If we were to take the SWAP out, the 
players would move identically. 

In many applications, it is necessary to know when a player has hit another 
player or some background image. Fortunately, the Atari computer automatically 
makes this information available. An entire collection of valFORTH words allows 
checking of all collisions possible. The most general word is ?C0L which simply 
returns a true flag if anything has hit anything else. Here is an example: 

: BUMP 

BEGIN 
HITCLR 
0 STICK 
0 PLYMV 
?C0L 
IF 

CR ." oops!” 

ENDIF 
7TERMINAL 
UNTIL ; 

BUMP <ret> 

Move the player around and watch the results. Every time you hit any letters 
or player one, the word "oops!" should be printed out. This program is quite 
simple. First, the HITCLR command is issued which erases any old collision 
information. If this command were omitted, the first time a collision occurred, 
"oops!" would be continuously printed out. Next the joystick is read and the 
player moved. If the player touches anything when moved, the collision 
registers are set. ?C0L reads these registers and leaves a true flag if the 
player has hit something, and the IF statement will then print out "oops!". 


( Record stick movement ) 

( Make a copy } 

( Move player 0 ) 

( Rotate stick 90 degrees ) 
( Move player 1 ) 


XXI -4 



Player Missile Graphics 1.0 


Using other commands found in the glossary, we can tell specifically what 
the player has hit. For example, the ?PXPF command checks to see if a specific 
player has hit a playfield, and if so, it returns information indicating which 
playfield. 

Although this discussion was limited to using players, the routines for 
missiles function similarly and can be found in the following glossary. Two 
player/missile example programs can be found on your Player/Missile disk. 

These demonstrate how short player/ missile routines can be. 


Player Missile Graphics 1.0 


PLAYER/MISSILE GLOSSARY 


Enabling Player-Missile Graphics 

To make use of players and missiles, the video processor must be activated. 
Players can be several sizes, they can have different overlap priority schemes, 
and they can have different colors. The following collection of "words" makes 
this setup task quite simple. Note: Players and missiles are numbered 0 through 

3. The fifth player is numbered as four. 


(PMINIT) ( addr res — ) 

The (PMINIT) command (or PMINIT below) must be used to initialize 
the player missile routines before any other player missile command may 
be used. (PMINIT) expects both the address of player/missile memory 
and a 1 or a 2 indicating whether single or double resolution is desired. 


NOTE: The difference between single and double resolution is shown 

graphically below: 


Player as defined 
in memory: 


single res 
on screen: 


double res 
on screen: 


00011000 

00111100 

01111110 

00111100 

00011000 




•a 



PMINIT ( res — ) 

The PMINIT command functions identically to the (PMINIT) command 
above, except that no address need be given. PMINIT calculates an address 
based on the current graphic mode. It uses the first unused 2K block of 
memory below the highest free memory ( i . e . , below the display list). 

This should only be used while first learning the system, after that, 
(PMINIT) should be used to optimize memory utilization. Note that the 
variable PMBAS contains the calculated address upon return. 

PMBAS ( — addr ) 

A variable containing the address of player/missile memory. This 
value must lie on a 2K boundary if single resolution players are used 
and on a IK boundary if double resolution players are used. This is set 
using the (PMINIT) command and is automatically set by the PMINIT command 
described above. This value should never be set directly, but can be 
read at any time. 


XX 1-6 


Player Missile Graphics 1.0 


PLAYERS ( ON/OFF — ) 

If the flag found on the top of the stack equates to TRUE or ON, 
then the player/missiles are activated. This does not clear out player 
missile memory; therefore, the PMCLR command described below is usually 
used prior to enabling the players and missiles to ensure that no random 
trash appears on the screen. 

If the flag found on the top of the stack equates to FALSE or OFF, 
then the player/missile graphic mode is de-activated. Turning players off 
does not clear player-missile memory; therefore, a subsequent ON PLAYERS 
command would redisplay any previously defined players and missiles. 

If players are already disabled, the command is ignored. 

5THPLY ( flag — ) 

In many applications it is desirable to combine the four missiles and 
simulate a fifth player, thus giving five players (numbered 0-4), and no 
missiles. If the flag on the stack is non-zero, then the fifth player mode 
will be initiated; otherwise, the missile mode will be re-activated. 

Normally, missiles take on the color of their corresponding players; 
however, when a fifth player is asked for, all missiles take on the common 
color of playfield #3. In addition, it also allows the fifth player to be 
treated exactly as any other player would be treated. Bear in mind that 
although it is called a "fifth" player, its reference number is four (4). 
The fifth player is "built" with missile zero on the right, and missile 
three on the left; 

|m3 | m2 | ml | mO | = fifth player 

(Note: For convenience, the words ON and OFF have been defined to allow 

niceties such as: 


ON 5THPLY 
OFF 5THPLY 

These two words are recognized by all words that require an ON/OFF type 
indication. ) 

PLYCLR ( Pi # — ) 

Few applications use all available players. To keep these unused 
players from displaying trash, they can be cleared of all data by 
using the PLYCLR command. The PLYCLR command expects the player number 
on the top of the stack and fills the specified player with zeroes. 

This command can be used to "turn off" players which are no longer 
needed. 

MSLCLR ( ml# — ) 

The MSLCLR command is very much like the PLYCLR command, described above, 
except that it clears the specified missile. In addition, this can be 
used when the fifth player is activated to erase parts of the fifth player 
for special effects. 


XX 1-7 


Player Missile Graphics 1.0 


PMCLR ( ... ) 

This command clears all players and all missiles. This is generally 
used just prior to activating the player-missile graphic mode to ensure 
that no random trash is. placed on the video screen. PMCLR expects no 
values on the stack, nor does it leave any. 


MCPLY { f — ) 

The MCPLY (Multi-Color Player) command expects one value on the top 
of the stack. If this value is 0 or OFF, then the multi-color player mode 
is disabled. If this value is 1 or ON, this command instructs the video 
processor to logically "or" the bits of the colors of player zero with 
player one, and also of player two with player three. In other words, 
when players 0 and 1 overlap (or players 2 and 3), a third color (determined 
by the colors of the overlapping players) will be assigned to the overlapped 
region rather than assigning one of the players a higher priority. Since 
players must be one color, this allows for multi-colored players. For 
example: 


Player 0 

Player 1 

MCPlayer 

Pink color 

Blue color 

Pink/blue 

( 4 ) 

( 8 ) 

( 4 OR 8 
= green ) 


BBBB 

BBBB 


BBBBBBBB 

BBBBBBBB 

PPPPPPPP 


PPPPPPPP 

PPPPPPPP 

BB BB 

PGGPPGGP 

PPPPPPPP 


PPPPPPPP 

PP PP 


PP PP 

PPPP 


PPPP 

NOTE: The Turns 

of the two players 

are also OR'd. 


The PRIOR command expects one value on the top of the stack. This 
value must be 8, 4, 2, or 1, otherwise unpredictable video displays may 
occur. PRIOR instructs the video processor as to what has higher priority 
for a video location on the screen. For example, it will determine whether 
a plane (a player) will pass in front of a building (a playfield), or 
whether the plane will pass behind the building. Objects with higher 
priorities will appear to pass in front of those with lower priorities. 

The following table shows the available priority settings: 


XXI -8 


Player Missile Graphics 1.0 


n=8 n=4 n=2 n=l 


PFO 

PFO 

PLO 

PLO 

PF1 

PF1 

PL1 

PL1 

PLO 

PF2 

PFO 

PL2 

PL1 

PF3* 

PF1 

PL3 

PL2 

PLO 

PF2 

PFO 

PL3 

PL1 

PF3* 

PF1 

PF2 

PL2 

PL2 

PF2 

PF3* 

PL 3 

PL3 

PF3* 

BAK 

BAK 

BAK 

BAK 


* PF3 and PL4 share the same priority 

Objects higher on the list will appear to pass in front of objects 
lower on the list. 


XX I -9 


Player Missile Graphics 1.0 


CREATING PLAYERS AND MISSILES 

Once the player/missile graphics system has been activated and the 
priorities set, all that need be done is to create the players themselves. 
Normally, this would be quite difficult to do; however, using the commands and 
designing techniques described below, this task is made very simple. 

There are really only three things to do in the creation of a player: setting 
the width size, setting the color, and creating the picture. 


PLYWID ( width pi# — ) 

The PLYWID command sets the specified player to the desired width. 
Players are numbered 0, 1, 2, 3, or in the case of the fifth player, 4. 
Legal widths are: 

image: 10111101 

0 = normal width: ■ •••• 8 

1 = double width: 88 88888888 88 


2 = normal width: • •••• • 

3 quad, width: 8888 8SB@ 

Any other value may cause strange results. 

MSLWID ( size ml# ) 


The MSLWID command is identical to the PLYWID command described above 
except that it is used to set the size of the missiles. The same size 
values apply also. The MSLWID command should only be used when in the 
missile mode (i.e., with the fifth player deactivated). 

PMCOL ( pi# hue lum — ) 

To set the color (hue and lum) of a player, the PMCOL (Player- 
Missile-Color) command is used. It sets the specified player to the hue 
and lumina desired. Note that there is no corresponding command to set 
the colors of missiles as missiles take on the colors of their respective 
players. To set the color of the 5th player, "pi#" should be 4. If the 
color words on the valFORTH 1.1 disk are loaded, they can be used to set 
player colors: 


0 BLUE 8 PMCOL 

This sets player #0 to a medium blue color. 


XXI-10 


Player Missile Graphics 1.0 


BLDPLV ( addr len horz vert pi# — ) 

The BLDPLV command is probably the most useful of all the commands in 
this graphic package. It takes an easily predefined picture that resides 
in memory at address "addr" whose length is "len" and converts it to the 
specified player "pi#". It then positions the player at the coordinates 
(horz, vert). The player is then ready to be moved about the screen using 
the PLYMV command described below. 


As an example, a player in the form of an arrow pointing upward will 
be created, assuming that priorities and such have already been taken care 
of. Practice has proven that the following method is easiest for creating 
players: 


2 BASE ! ( put into binary mode ) 


LABEL PICTURE ( the 

00011000 C, 

00111100 C, 

01111110 c, 

11011011 c, 

00011000 c, 

00011000 c, 

00011 000 c, 

00011 000 c, 

DECIMAL 


image is named PICTURE ) 


1 PMINIT ( initialize for single resolution ) 

PICTURE 8 80 40 0 BLDPLY 


Takes the image at location PICTURE which is 8 bytes long, and builds 
player #0 at location (80,40). 

BLDMSL ( addr len horz vert ml# — ) 


The BLDPLY command described above does just about everything necessary 
to create a high-resolution player. The BLDMSL command functions identically 
to the BLDPLY command except that it is used for setting up missiles (which 
are in effect just skinny players). The method for creating players can be 
used for creating missiles as well. Note that if the fifth player mode is 
activated, the BLDPLY command must be used to create the player. 


Building missiles takes a bit more care than building players. Players 
occupy separate memory, while the four missiles share the same memory. 

Each missile is two bits wide; all four together are exactly a byte wide. 
Missile memory is shared with the two lowest bits devoted to missile zero, 
and the two highest bits devoted to missile three: 

| m3 | m3 | m2 | m2 | ml | ml | mO | mO | 

All players with the same shape can use the same image without any problem 
since they all are a full byte wide. Missiles, however, cannot use the 
same shape since their images must be ORed into missile memory. This means 
that the missile images must be in the proper bit columns. For example, 
the same image for separate missiles could be: 


11000000 

11000000 

11000000 

msl#3 


00110000 

00110000 

00110000 

msl #2 


00001100 

00001100 

00001100 

msl#l 


00000011 

00000011 

00000011 

msl#0 


XXI-11 


Player Missile Graphics 1.0 


PUTTING PLAYERS AND MISSILES IN THEIR PLACE 


Generally, once a player or missile has been created and put to the video 
screen, it is moved around. This can be accomplished very easily with the next 
set of words. Interfacing a movable player with the joystick can improve just 
about any program which requires input. As a result, it usually gives the 
program a more professional appearance. 

PLYLOC ( pi# — horz vert ) 

The PLYLOC command (PLaYer LOCation) returns the vertical and 
horizontal positions of the specified player. This is normally used 
when a joystick/button setup is being utilized -- i.e., when a joystick 
is moving a player and the button is used to pinpoint where the player 
is. A program which draws lines between two dots could use this. The 
joystick is used to move the player to the desired spot on the screen. 
Pressing the button tells the program that a selected spot has been made. 
Once a second spot has been selected, the program then draws a line 
between them. 

MSLLOC ( ml# — horz vert ) 

The MSLLOC command performs the same function as the PLYLOC command 
described above except that it is used to find locations of missiles 
instead of players. Note that using MSLLOC on a fifth player gives 
meaningless results. 


PLYMV 


horz vert pi# --- ) 


The PLaYer MoVe command moves the specified player the direction 
specified by "vert" and "horz". If "vert" or "horz" is negative, the 
player is moved up or left respectively, otherwise it is moved down or 
right unless they happen to be zero in which case nothing happens. The 
following examples clarify this: 


0-50 PLYMV 
-1 -1 3 PLYMV 
3-12 PLYMV 


( Move player 0 up 5 lines ) 

( Move player 3 left and up one line ) 

( Move player 2 up one dot and right 3 ) 


MSLMV 


horz vert ml# — ) 


The MSLMV is identical in function as the PLYMV command described 
above except that it is used to move missiles about the video screen. 

PLYPUT ( horz vert pi# — ) 

The PLYPUT command positions player "pi#" to the location (horz, vert) 
on the video screen. 


XX 1-12 


Player Missile Graphics 1.0 


PLYCHG 


( addr Ten pi# — 


Oftentimes it is necessary to change the image of a player after it 
has been built. The PLYCHG command allows this to be easily done. The 
PLYCHG command takes the image with length "Ten" at address "addr" and 
assigns it to player "pi#". Note that if the new image is shorter than 
the previous one, part of the previous image will remain. This can be 
overcome by executing a PLYCLR command prior to PLYCHG. 


PLYSEL 


( addr 


pl# - ) 


The PLYSEL command is used to select image out of a table of 
images of the same length and assigns that image to the specified player. 
PLYSEL is typically used to animate players. An example usage of this can 
be found in Player/Missile Example #2 found in the directory of the disk. 


o 


o 


XX I -13 


Player Missile Graphics 1.0 


PLAYER/MISSILE BOUNDARIES 



It is often desirable to put limitations on the movements of players 
and missiles. Boundaries can be set up for each player and missile independently 
and upon each move command, they will remain within those boundaries. Additionally, 
a boundary status byte for each player is available for scrutiny at any time. 

This section explains how this is used. 

PLYBND ( left right top bottom pi# -- ) 

In most applications, the movements of players are kept within certain 
boundaries. The PLYBND command frees the user from having to worry about 
boundary checking. This command expects the player number and all four 
boundaries. Whenever a PLYMV is then used, the player is always kept 
within the set boundaries. Also, upon each move a boundary status byte 
is left in the c-array PLYSTT (see?PLYSTT below). The edge boundaries of 
the screen are: 


Note that in special cases the boundary checker will fail. If the 
left boundary is 0 and the player is at the boundary, any move left will 
not be checked as expected. For example, if it were moved left by one 
position (-1), the new horizontal position would be -1 or FFFF in hex. 
Since only 8 bit unsigned comparisons are made, the horizontal position 
appears to be 255 (FF hex). Post calculating boundary checking turns 
out to be more useful because it allows any or all edges to be unbounded. 
If an unbounded player is desired, use this: 


For an example of PLYBND, see the example program found in the directory 
on screen 170 of your disk. 


32 for single, 16 for double 


48 for both 
resolutions 


207 for both 
resolutions 


o 


223 for single, 111 for double 


0 255 0 255 pi# PLYBND 


MSLBND 


( left right top bottom ml# 


The MSLBND command is the same as the PLYBND command above, except 
that it is used for missiles. Upon each move a boundary status byte is 
left in the array MSLSTT. See 7MSI.STT below. 


c 


XX I - 14 


Player Missile Graphics 1.0 


?BND 


( — n ) 


This command leaves the boundary check status of the last PLYMV or 
MSLMV performed. The value has the following form: 


0 

1 

r 

t 

b 


15 14 4 3 2 1 0 


Only the lower four bits are of use. Each bit represents a different 
edge. If the bit is set, then the player or missile has attempted to move 
beyond that boundary. Note that only two of the four bits can be set at 
any time. 

Note: DECIMAL 

?BND 3 AND 

IF hi t-verti cal -boundary ENDIF 
?BND 12 AND 

IF hit-horizontal -boundary ENDIF 


7PLYSTT ( pi# — ''al ) 

Given a player number, returns the boundary check byte of that player. 
This byte is the status byte for the most recent PLYMV of that player. 

See ?BND above for the description of the status byte. 

7MSLSTT ( ml# — val ) 

Given a missile number, returns the boundary check byte of that missile. 
This byte is the status byte for the most recent MSLMV of that missile. 

See ?BND above for the description of the status byte. 


XXI -15 


Player Missile Graphics 1.0 


CHECKING FOR INTERACTION BETWEEN PLAYERS 


All the commands given so far allow the creation of any player or missile 
desired. But once that pi ayer is on the screen and moving around, it is often 
necessary to know when two or more objects (players, missiles, and playfields) 
touch or "crash" into each other. This remaining collection of commands allows 
checking of all possible "hit" combinations. 

?C0L ( — f ) 

The ?C0L command is a very general collision detector. It does nothing 
more than indicate whether two or more objects have "crashed" -- it does not 
give any indication of what has collided. It leaves a 1 on the stack if a 
collision has taken place; otherwise it leaves a zero. 


?MXPF ( ml# — n ) 

The ?MXPF conrnand is a much more specific collision detection command. 
It stands for "?collision of Missile #X with any PlayField". It is used 
to check if a specific missile has hit any playfield. It returns a zero 
if no collision has taken place, and leaves an 8, 4, 2, 1, or combinations 
of these (e.g., 12 = 8+4) if a collision has occurred. Each of these 
four basic values represents a specific playfield: 


3 ?MXPF ( Has missile #3 hit any playfields? ) 


TOS 

binary 

meaning of val 

0 

0000 

no collisions 

1 

0001 

with pf#0 

2 

0010 

with pf #1 

3 

0011 

with pf#0,l 

4 

0100 

with pf#2 

5 

0101 

with pf#2,0 

6 

0110 

with pf#2,l 

7 

0111 

with pf#2,l,0 

8 

1000 

with pf#3 

9 

1001 

with pf#3,0 

10 

1010 

with pf#3,l 

11 

1011 

with pf#3,l,0 

12 

1100 

with pf#3,2 

13 

1101 

with pf#3,2,0 

14 

1110 

with pf#3,2,l 

15 

mi 

with pf#3,2,l,0 


To test for a collision with one specific playfield, use one of the 
following: 


1 AND 

( Leaves 

1 

if collision 

with 

pf#0, else 

0 ) 

2 AND 

( " 

1 

II 

II 

pf#l, " 

0 ) 

4 AND 

( " 

1 

II 

II 

pf#2, " 

0 ) 

8 AND 

( " 

1 

II 

II 

pf#3, " 

0 ) 


XX I - 16 


Player Missile Graphics 1.0 


?PXPF ( pi# ... n ) 

The ?PXPF command (?collision of Player #X with any PlayField) 
behaves in exactly the same manner as the ?MXPF command above except that 
it tests for collisions with players and playfields instead of missiles 
and playfields. 


?MXPL ( ml# — n ) 

The ?MXPL command (?collision of Missile #X with any Player) behaves 
in exactly the same manner as the 7MXPF command above except that it 
tests for collisions between missiles and players. Note that it is 
impossible for a missile to collide with a fifth player since it would be, 
in effect, colliding with itself. 


?PXPL ( pi# — n ) 

The 7PXPL command (?collision of Player #X with any other players) 
behaves in exactly the same manner as the 7MXPF command above except that 
it tests for collisions between players. Note that it is impossible for 
a player to collide with itself. 

HITCLR ( -- ) 

The HITCLR command clears all collision registers. In other words, 
it sets the collision monitor to a state which indicates that no collisions 
have occurred. 


XXI-17 


Q 




O 


C' 


THE CHARACTER SET EDITOR 


Character Sets 

Whenever the computer has to display a character on the video screen, it 
must refer to a table which holds the shape definition for that character. 

By changing this table, new character sets can be formed. 

The shape of a single character in the table (or character set) is made 
up of 8 bytes of data. A character is one byte wide and 8 bytes tall forming 
an 8 by 8 bit matrix. If a bit in this matrix is set (1), then a dot will 
appear on the screen. If a bit is reset (0), nothing is displayed. For 
example, the letter I could be defined as: 


Thus, the sequence 0, 126, 24, 24, 24, 24, 126, 0, represents the letter I. 

The entire alphabet is constructed in this fashion. By selectively setting 
the bit pattern, custom made characters can be formed. This can find many 
uses. A British character set can be made by changing the one character 
to the British monetary symbol. Likewise, a Japanese character set could be 
made by replacing the lowercase characters with Katakana letters. 

Another use would be to design special symbol sets. For example, an 
entire set could be devoted to special mathematical symbols such as plus-minus 
signs, square-root signs integration signs, or vector signs. (Although this 
would be of little use in normal operation where character sets cannot be mixed 
on the same line, using the high resolution text output routines in the 
Editor/Utilities package. It becomes easy to mix character sets in this 
fashion.) Assuming the character sets were defined, it would be possible to 
have a Japanese quotation (in kana of course) embedded within the text of a 
mathematical explanation of some kind all on the same line! 

A final use for custom character sets is for "map-making." Characters 
can be designed so that they can be pieced togehter to form a picture. An 
excellent example of this can be found in Cris Crawford's Eastern Front game 
available through the Atari Program Exchange. When done properly, the final 
"puzzle" will appear as though it is a complicated high resolution picture. 

Now, on to the editor. . . 


00000000 

01111110 

00011000 

00011000 

00011000 

00011000 

01111110 

00000000 


$00 = 0 
$7E = 126 
$18 = 24 
$18 = 24 
$18 = 24 
$18 = 24 
$7E = 126 
$00 = 0 


XXII-1 


The Editor 


The following description explains how to use the character editor found on 
the Player/Missile disk. This editor allows a character set to be designed and 
then saved on disk for later modification or use. A copy of the standard 
character has already been saved and can be located through the directory on 
screen 170. 

After loading the character editor, it is executed by typing: 

CHAR-EDIT <ret> 

The screen has an 8 by 8 grid in the upper-lefthand corner. On the right side 
there is a command list, and at the bottom, a section is reserved to display 
the current character set. 


The Commands: 

I) The joystick 

A joystick in port 0 (the leftmost port) is used to move the 
character cursor (the solid circle) within the 8 by 8 grid. The 
cursor indicates where the next change to the current character 
will be made. 

II) The button 

When pressed, the joystick button will toggle the bit under the 
character cursor in the 8 by 8 grid. If the bit is set (on), it 
will be reset. If the bit is reset (off), it will be set. The 
character will be updated in the character set found at the bottom 
of the screen. 

Ill) "1" command 

By pressing the "1" the current character is cleared in both 
the grid and in the character set at the bottom of the display. 

There is no verify prompt for this command. 

IV) "2" command 

By pressing the “2" key the current character and character 
set are cleared. User verification is required before any action 
is taken. 

V) "3" command 

By pressing the "3" key the current character is saved to disk. 
User verification is required with a yes/no response. If a yes 
response is given, a screen number is asked for and the current 
character set is saved on the specified screen. The current 
character is not destroyed upon a save. 

VI) "4" command 

By pressing the "4" key a character set is loading from disk, 
destroying the current character set. User verification is required 
with a yes/no response. If a yes response is given, a screen number 
is asked for and a character set loaded from the specified screen. 


XXI 1-2 


VII) " and "— >" commands 

These two arrow keys move the character pointer through the 
character set to allow modification of any character in the current 
set. 

VIII) Console key 

Pressing any console key terminates the edit session and returns 
control to the FORTH system. The current character set is lost 
unless it is saved to disk prior to ending the session. 


Loading Character Sets 

The following three words allow easy use of custom character sets. 


CHLOAD ( addr sc r# cnt — ) 

The CHLOAD command takes the first "cnt" characters on screen "scr#" 
and stores them consecutively starting at address "addr". Each screen 
(in half-K mode) will only hold 64 character definitions. If "cnt" is 
greater than 64, CHLOAD will continue loading from the next screen. 

Many character sets could be loaded at one time by giving a very large 
"cnt" value. Besides being able to load a full set, the CHLOAD command 
allows the building of a new set from several other sets. 

Note that if a 20 character/line mode is being used, "addr" should 
lie on a half-K boundary (only upper 7 bits significant). If a 40 
character/line mode is being used, "addr" should lie on an IK boundary 
(only upper 6 bits significant). Also note that PAD is modified by 
CHLOAD. 

SPLCHR ( addr — ) 

The SPLCHR commands activates the character set at the address 
specified. 

NMLCHR ( — ) 

The NMLCHR command re-activates the normal character set. 


XXI 1-3 


p 


o 


(J 


AUDIO-PALETTE — A SOUND EDITOR 


Audio-Palette is a sound editor which generates all possible time-in 
dependent sounds that the Atari 400/800 microcomputer can produce. Each of 
the four channels are interfaced to one of the four joystick ports. The joy- 
sticks allow the setting of the pitch (horizontal) the distortion (vertical) 
of their corresponding channel. When the joystick button is pushed, the 
sound is made. To get a better idea of how this works, load the editor 
(see screen 170) and type: 


AUDED <ret> 

The screen should clear and a table of values should appear at the bottom of 
the display. In the upper lefthand corner of the screen, there should be four 
numerals (players) overlayed (one for each channel). Each of these players 
can be moved around the display by using a joystick in the appropriate port. 

As a player is moved vertically, the distortion changes. As a player is 
moved horizontally, the pitch changes. By pressing the button, a sound will 
be made according to the current frequency (pitch), distortion, volume, and 
audio control settings. To increase the volume, the up-arrow is used, 'ny 
time the up-arrow is pressed, all channels whose corresponding joystick 
buttons are pressed will have their volumes increased. Likewise, the down- 
arrow will decrease the volumes. 

Each bit of the audio control value performs some function in the 
sound generator. The bits are numbered 0 to 7. Pressing the keys 0 to 7 
will toggle the corresponding bits in the audio control register. For a 
description of these bit settings, please refer to the explanation of SOUND 
in the val FORTH 1.1 package. 


XXIII-1 


Q 


O 


XXIV. PLAYER/MISSILE SUPPLIED SOURCE 


Screen: 30 

0 ( PlyMsl: arrays arid variables) 


Screen: 33 

0 ( PlyMsl: PMINIT PLAYERS 


1 

BASE © 



1 


2 

DCX 

: ’ < ARRAY ) ( 80 KLOAD ) 


2 

: PMINIT ( 

3 

0 

VARIABLE 

PMBAS 


3 

2E6 C© 8 - F8 AND 

4 

5 

CARRAY 

PLYVRT 


4 

OVER 1- 4 * + 100 * 

5 

5 

CARRAY 

PLYHRZ 


5 

SWAP (PMINIT) ; 

6 

5 

CARRAY 

PLYLEN 


& 


7 

5 

ARRAY 

PLYADR 


7 

: PLAYERS 

a 

4 

CARRAY 

MSLVRT 


8 

IF 

3 

4 

CARRAY 

MSLHRZ 


3 

PMBAS © DUP 

10 

4 

CARRAY 

MSLLEN 


10 

PMRES © 1+ (PMINIT) 

11 

4 

ARRAY 

MSLADR 


11 

SP@ 1+ C© SWAP 

12 

5 

ARRAY 

PMADR 


12 

DROP D407 C! 

13 

0 

VARIABLE 

PMLEN 


13 

SGRCTL © 3 OR DUP 

14 

0 

VARIABLE 

PMRES 


14 

SGRCTL ! D01D C! 

15 

0 

VARIABLE 

MSLSZ 

= => 

15 

ELSE 


< f 


— > 


o 


0 VARIABLE BOUNDS 34 ALLOT 
5 CARRAY PLYSTT 
4 CARRAY MSLSTT 
0 VARIABLE BNDCOL 
3 VARIABLE 5THWID 


Screen: 31 

0 ( PlyMsl: 

1 
2 

3 

4 

5 

6 
7 

a 

3 

10 
11 
12 

13 

14 

15 


Screen: 34 


arrays and variables) 


CTABLE 5THDAT 
2 C, 4 C, 2 C, 

HEX 


a c, 


CTABLE MSLDAT 

FC C, F3 C, CF C, 3F C, 


— > 


0 

1 

2 

3 

4 

5 

6 
7 

a 

3 

10 

11 

12 

13 

14 

15 


( PlyMsl: 5THPLY 

SGRCTL 0 FC AND 
DUP SGRCTL ! D01D C! 
22F C© E3 AND 22F C! 
D00D 5 ERASE 
END IF : 


5THPLY 
26F C© SWAP 
IF 10 OR 
ELSE EF AND 
END IF 
26F C! : 


( f — ) 




Screen : 


Screen : 35 


c 


0 ( 
1 

PlyMsl: [PMINIT] 

) 

0 

1 

2 

( PlyMsl: 1 

1 

d a 

(PMINIT) < addr 

res — > 


3 

SWAP PMBAS ! 1- DUP 

PMRES ! 

3 

: PMCLR 

4 

NOT 10 * 0C OR 


4 

4 PMADR © 

5 

22F C@ EF AND OR 22F 

C! 

5 

PMLEN © 5 

6 

PMBAS © 180 PMRES © 


6 

0 FILL ; 

7 

NOT 1+ >R 


7 


8 

R * + DUP 4 PMADR ! 


8 


9 

80 R) * >R 


9 

: PLYCLR 

10 

R + DUP 0 PMADR ! 


10 

PMADR © 

11 

R + DUP 1 PMADR ! 


11 

PMLEN © 

12 

R + DUP 2 PMADR ! 


12 

0 FILL ; 

13 

R + 3 PMADR ! 


13 


14 

R> PMLEN ! ; 


14 


15 


==> 

15 



PMCLR PLYCLR 


< — ) 


( pi# — ) 


Screen: 36 

0 < PlyMsl : MSLCLR PRIOR ) 

1 

£ : MSLCLR ( ml# — ) 

3 4 PM ADR 0 DUP 

4 PMLEN @ + SWAP 

5 DO 

6 DUP MSLDAT C<* 

7 I C0 AND I C! 

8 LOOP 

9 DROP ; 

10 

11 : PRIOR ( n — ) 

IS £ 6 F C@ 0F0 AND 

13 OR £ 6 F C! 5 

14 

15 ==> 


Screen: 37 

0 ( PlyMsl: PLYMV ) 

1 

£ CODE PLYMV 


3 

84 

c. 

N 6 + C, 

B5 C, 

00 C, 

4 

0A 

c, 

AS C, B9 

C, 0 

PMADR 1+ , 

5 

85 

C, 

N 1 + C, 

B9 C, 

0 PMADR , 

6 

85 

C, 

N 1- C, 

B9 C, 

0 PLYADR , 

7 

85 

C, 

N £+ C, 

B9 C, 

0 PLYADR 

8 

1 + 


85 C, N 

3 + C, 

B4 C, 0 C, 

9 

B9 

C, 

0 PLYLEN 

, 85 

C, N 4 + C, 

10 

B9 

C, 

0 PLYHRZ 

, 18 

C, 75 C, 

11 

04 

C, 

D9 C, BOUNDS , 

B0 C, 5 C, 

1 £ 

B9 

C, 

BOUNDS , 

E 6 C, 

N 6 + C, 

13 

06 

C, 

N 6 + C, 

D9 C, 

BOUNDS 5 + 

14 

, F0 

C, 07 C, 

90 C, 

05 C, B9 C, 

15 

BDUNDS 5 + , E 6 C, N 

6 + C, — > 


Screen : 38 

0 < PlyMsl: PLYMV ) 


1 

99 

c. 

0 PLYHRZ , 

95 C, 05 C, 

£ 

B9 

c, 

0 PLYVRT , 

85 C, N C, 

3 

18 

c. 

75 C, £ C, 

06 C, N 6 + C, 

4 

D9 

c, 

BOUNDS A + 

, B0 C, 05 C, 

5 

B9 

c, 

BOUNDS A + 

, E 6 C, N 6 + 

6 

c. 

6 

C, N 6 + C, 

D9 C, BOUNDS 

7 

F + . 

F0 C, 07 C, 

90 C, 05 C, 

8 

B9 

c. 

BOUNDS F + 

, E 6 C, N 6 + 

9 

c, 

99 

C, 0 PLYVRT 

’ , 95 C, 3 C, 

10 

38 

c, 

E5 C, N C, 

B0 C, 05 C, 

11 

A5 

c. 

N C, 38 C, 

F5 C, 03 C, 

1 £ 

95 

c, 

0£ C, C5 C, 

N 4 + C, 

13 

90 

c. 

0£ C, A5 C, 

N 4 + C, 

14 

15 

85 

c. 

N 5 + C, 



Screen : 39 

0 ( PlyMsl: PLYMV ) 

1 A5 C, N C, D5 C, 03 C, 90 C, 

£ 08 C, 18 C, 65 C, N 4 + C, 38 

3 C, E5 C, N 5 + C, 85 C, N C, 

4 18 C, 65 C, N 1- C, 85 C, N C, 

5 B5 C, £ C, F0 C, 0B C, A0 C, 

6 00 C, 98 C, 88 C, C 8 C, 91 C, 

7 N C, C4 C, N 5 + C, D0 C, 

8 F9 C, B5 C, 00 C, C9 C, 04 C, 

9 D0 C, 14 C, B5 C, 05 C, A0 C, 

10 04 C, HERE 88 C, 30 C, 0A C, 

11 99 C, D004 , 18 C, 6 D C, 5THWID 

1£ , 4C C, , 4C C, HERE £ ALLOT 

13 B5 C, 05 C, B4 C, 00 C, 99 C, 

14 D000 , HERE SWAP ! B4 C, 00 C, 

15 A5 C, N 6 + C, — > 


Screen : 40 

0 < PlyMsl: PLYMV > 

1 


£ 

99 

c, 

0 PLYSTT , 

BD 

c, 

BNDCOL 

3 

B5 

C, 

3 C, 18 C, 

65 

c, 

N 1- C, 

4 

85 

C, 

N C, A0 C, 

00 

c. 


5 

B1 

C, 

N £+ C, 




6 

91 

C, 

N C, C 8 C, 

C4 

c, 

N 4 + C 

7 

D0 

C, 

F7 C, E 8 C, 

E 8 

1 c, 


8 

4C 

C, 

POPTWO , 

C5 




9 

10 

11 

ia 

13 

14 


15 



=-> 

Screen: 41 



0 

< PlyMsl: MSLMV 


) 

1 

O 

HEX 



1— 

3 

CODE MSLMV 



4 

84 C, N 6 + C, B5 C, 0 

c, 

0A C, 

5 

AB C, AD C, 4 PMADR 1+ 


Q5 C- 

6 

N 1+ C, AD C, 4 PMADR , 

85 C, 

7 

N 1- C, B9 C, 0 MSLADR 

9 

85 C, 

8 

N £+ C, B9 C, 0 MSLADR 

1 + 

9 

9 

85 C, N 3 + C, B4 C, 0 

c, 

B9 C, 

10 

0 MSLDAT , 85 C, N 7 + 

c, 

B9 C, 

11 

0 MSLLEN , 85 C, N 4 + 

c, 

B9 C, 

1 £ 

0 MSLHRZ , 18 C, 75 C, 

04 

c, 

13 

D9 C, BOUNDS 14 + , B0 

c. 

5 C, 

14 

B9 C, BOUNDS 14 + , E 6 

C, 

N 6 + 

15 



--> 


Screen : A2 

0 ( PlyMsl : MSLMV 


Screen: A5 

0 ( PlyMsl: 


1 

2 

c, 

6 C 

N 6 + C, D9 C, BOUNDS 

1 

2 

3 

18 

+ * 

F0 C, 07 C, 90 C, 

3 

A 

05 

c, 

B9 C, BOUNDS 18 + , 

A 

5 

E6 

c. 

N 6 + C, 

5 

6 

99 

C, 

0 MSLHRZ , 95 C, 05 C, 

6 

7 

B9 

C, 

0 MSLVRT , 85 C, N C, 

7 

8 

18 

C, 

75 C, 02 C, 6 C, N 6 + C, 

8 

9 

D9 

C, 

BOUNDS 1C + , B0 C, 5 C, 

9 

10 

B9 

C, 

BOUNDS 1C + , E6 C, N 6 + 

10 

11 

c, 

06 

C, N 6 + C, D9 C, BOUNDS 

11 

12 

20 

+ » 

F0 C, 7 C, 90 C, 5 C, 

12 

13 

B9 

C, 

BOUNDS 20 + , E6 C, N 6 + 

13 

1A 

c, 

99 

C, 0 MSLVRT , 95 C, 3 C, 

1A 

15 



==> 

15 


BLDPLY BLDMSL 


BLDPLY 

> R 

R PLYHRZ C! 

R PLYflDR ! 

0 0 R> PLYMV 

BLDMSL 

> R 

R MSLHRZ C! 

R M5LADR ! 

0 0 R> MSLMV 


( a 1 h v pi# — 
R PLYVRT C! 

R PLYLEN C! 

( R PLYCLR ) 


1 h v pi# 
MSLVRT C! 
MSLLEN C! 
MSLCLR ) 


— ) 


Screen : A3 

0 < PlyMsl: 

1 


MSLMV 


Screen: A6 

0 < PlyMsl: 

1 


PLYCHG PLYSEL PLYPUT) 


£ 

38 C, E5 C, N C, B0 C, 5 C, 05 

£ : 

PLYCHG 

( a len 

pi# 

— ) 

3 

C, N C, 38 C, F5 C, 3 C, 95 C, 

3 

> R R PLYLEN C! 




A 

2 C, C5 C, N A + C, 90 C, 2 C, 

A 

R PLYflDR ! 




5 

05 C, N A + C, 85 C, N 5 + C, 

5 

0 0 R> PLYMV ; 




6 

05 C, N C, D5 C, 3 C, 90 C, 

6 





7 

8 C, 18 C, 65 C, N A + C, 38 

7 : 

PLYSEL 

( a # 

pi# 

— ) 

8 

C, E5 C, N 5 + C, 85 C, N C, 

8 

> R R PLYLEN C0 

* + 



9 

18 C, 65 C, N 1- C, 85 C, N C, 

9 

R PLYLEN C® R> 

PLYCHG 

s 


10 

00 C, FF C, C8 C, B1 C, N C, 

10 





11 

25 C, N 7 + C, 91 C, N C, CA 

11 : 

PLYPUT 

( h v 

pi# 

— ) 

12 

C, N 5 + C, D0 C, F5 C, B5 C, 

12 

) R R PLYVRT C@ 

- 



13 

5 C, BA C, 0 C, 99 C, D00A , 

13 

SWOP R PLYHRZ 

C@ - 



1A 


1A 

SWOP R> PLYMV 

5 



15 

— > 

15 




==> 


Screen: AA 

0 < PlyMsl: 

1 


MSLMV 


Screen: A7 

0 ( PlyMsl : 

1 


PLYWID 


2 

BA 

c, 

0 C, 05 C, N 6 + C, 

99 

£ 

CODE PLYWID 


3 

c, 

0 

MSLSTT , 8D C, 


3 

B5 C, 

00 C, C9 C, 0A C, F0 

C, 

A 

BNDCOL , B5 C, 3 C, 18 C, 


A 

09 C, 

08 C, B5 C, 02 C, 99 

C 

5 

65 

c. 

N 1- C, 85 C, N C, 


5 

D008 

, AC C, HERE 2 ALLOT 


6 

00 

c, 

00 C, B1 C, N C, 


6 

08 C, 

00 C, 0A C, 00 C, 00 

C, 

7 

25 

c. 

N 7 + C, 11C, N 2+ 

c. 

7 

15 C, 

02 C, 88 C, D0 C, F9 

c, 

8 

91 

c. 

N C, C8 C, 


8 

8D C, 

MSLSZ , 8D C, D00C , 


9 

CA 

c, 

N A + C, D0 C, F3 C, 

E8 

9 

BA C, 

02 C, B9 C, 0 5THD0T 

1 

10 

c. 

ES 

C, AC C, POPTWO , C; 


10 

85 C, 

N C, 8D C, 5THWID , 


1 1 





11 

OD C, 

A PLYHRZ , 00 C, 0A C 

'1 

12 





12 

HERE 

88 C, 30 C, 09 C, 99 C 


13 





13 

D00A 

, 18 C, 65 C, N C, AC 

c, 

1A 





1A 

, HERE SWOP ! AC C, POPTWO 

* 

15 




II 

II 

'v' 

15 

C; 




Screen : 40 

0 ( PlyMsl : MSLWID 


Screen: 51 

0 ( PlyMsl: ?MXPL ?PXPL PLYBND 


£ 

CODE 

MSLWID 




2 

CODE 

7MXPL 


( ml# 

— 

- n 

3 

B4 

c. 

00 C, 

B9 C, 0 

MSLDRT , 

3 

B4 

c, 00 C, 

B9 C, 

D008 



4 

£D 

c. 

MSLSZ 

, HERE 



4 

4C 

C, PUT0P , 

C; 




5 

88 

c, 

30 C, 

7 C t 16 

c, 

02 C, 

5 







S 

16 

C, 

02 C, 

4C C, , 

15 

c, 

6 

CODE 

7PXPL 


( pi# 

_ 

- n 

7 

0£ 

C, 

8D C, 

MSLSZ , 

8D 

C, 

7 

B4 

C, 00 C, 

B9 C, 

D00C 



8 

D00C , 

n 

n 

POPTWO 

9 


8 

4C 

C, PUT0P , 

c? 




9 

c? 






9 







10 







10 

CODE 

HITCLR 



( 

— 

11 







11 

8C 

C, D01E , 

4C C, 

NEXT 


C; 

12 







12 







13 







13 

CODE 

7BND 


( xl# 

— 

- n 

14 







14 

PD 

C, BNDCOL 





15 






==> 

15 

4C 

C, PUSH0R 

, C; 




Screen: 

49 





Screen: 

52 






0 ( PlyMsl: PLYLOC MSLLQC MCPLY ) 

1 


0 < PlyMsl: MSLBND ?BND 

1 


£ 

CODE PLYLOC 


( pi# 

— h v 

) 

2 

CODE 

7PLYSTT 


( 

pi# 

r» 

) 

3 

94 C, 01 C, B4 

c, 

0 C, 



3 

B4 

C, 00 C, 

B9 C, 

0 

PLYSTT 



4 

B9 C, 0 PLYHRZ 

9 

95 C, 

0 C, 


4 

4C 

C, PUT0P 

, C; 





5 

B9 C, 0 PLYVRT 

5 

4C C, 

PUSH0P 

f 

5 








6 






6 








7 

CODE MSLLDC 


< ml# 

— h v 

) 

7 

CODE 

7MSLSTT 


< 

ml# — 

n 

) 

a 

94 C, 01 C, B4 

C, 

0 C, 



8 

B4 

C, 00 C, 

B9 C, 

0 

MSLSTT 

5 


9 

B9 C, 0 MSLHRZ 

9 

95 C, 

0 C, 


9 

4C 

C, PUT0P 

, C; 





10 

B9 C, 0 MSLVRT 

9 

4C C, 

PUSH0R 


10 








u 






11 

: PLYBND 

( 1 r 

t 

b pi# - 

— 

) 

12 

: MCPLY 



( f — 

) 

12 

> R 

4 ROLL > R 





13 

26F CC» SWPP 





13 

<ROT SWPP R> 

R> 





14 

IF 20 OR ELSE 

DF 

PND END IF 


14 

BOUNDS + 14 

O+S 





15 

26F C ! ; 



— 

•> 

15 

DO 

I C! 5 /LOOP ; 



= = 

> 


Screen : 50 

0 ( PlyMsl: '’COL HITCLR ?MXPF. . . ) 


Screen : 53 

0 ( PlyMsl: PMCOL 


2 

CODE 7COL 


( 

— f ) 

£ 

: MSLBND ( 1 r t b 

ml# 

— ) 

3 

CP C, CP C, 

98 C, P0 C, 

0F C, 

3 

> R 4 ROLL ) R 



4 

19 C, D000 , 

88 C, 

10 C, 

FP C, 

4 

<ROT SWPP R> R> 



5 

C8 C, 94 C, 

01 C, 95 C, 

00 C, 

5 

BOUNDS +14+10 O+S 



6 

4C C, * 0# ( 

CFR @ 

> , 


6 

DO I C! 4 /LOOP ; 



7 

C; 




7 




8 





8 

: PMCOL ( pi# col 

lum 

— ) 

9 

CODE 7MXPF 


( ml# 

— n > 

9 

SWPP 10*+ 



10 

B4 C, 00 C, 

B9 C, 

D000 

9 

10 

SWPP DUP 4 = 



11 

4C C, PUT0P 

. C; 



11 

IF 



12 





12 

DROP 2C7 C! 



13 

CODE 7PXPF 


( pi# 

— n ) 

13 

ELSE 



14 

B4 C, 00 C, 

B9 C, 

D004 

9 

14 

2C0 + C! 



15 

4C C, PUT0R 

, c? 



15 

END IF ; 


— > 


Screen: 54 Screen: 57 

0 ( PlyMsl: initialization ) 0 

1 1 

2 DCX £ 

3 3 

4 BOUNDS 36 0 FILL 4 

5 BOUNDS 5+5 255 FILL 5 

6 BOUNDS 15+5 255 FILL 6 

7 BOUNDS £4+4 £55 FILL 7 

8 BOUNDS 32+4 £55 FILL 8 

9 9 

10 0 PLYSTT 5 ERASE 10 

11 0 MSLSTT 4 ERASE 11 

12 1£ 

13 1 PMINIT ( Set up defaults ) 13 

14 14 

15 BASE ! 15 


Screen: 55 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 58 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 56 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

1 5 


Screen: 59 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


) 


) 


Screen : 60 

0 < Audio Editor 

1 

£ BASE 9 DCX 

3 

4 * < PLYMV ) < 15 KLOAD ) 

5 ' < SOUND ) ( 83 KLOAD ) 

6 * ( STICK ) ( 84 KLOAD ) 

7 

8 

9 VOCABULARY AUDPAL IMMEDIATE 

10 AUDPAL DEFINITIONS 

11 

12 4 CARRAY PIT 

13 4 CARRAY VOL 

14 4 CARRAY DST 

15 0 VARIABLE ACTL ==> 


Screen : 63 

0 ( Audio Editor 

1 HEX 

2 : SETP < — ) 

3 2 PMINIT PMCLR 1 PRIOR 


4 

0 

3 

< 

RDORNG 

) 

6 

PMCOL 

5 

1 

8 

< 

BLUE 

) 

6 

PMCOL 

6 

£ 

4 

( 

PINK 

) 

8 

PMCOL 

7 

3 

1 

( 

GOLD 

) 

6 

PMCOL 


8 4 0 

9 DO 

10 1 I PLYWID 

11 E080 I 8 * + 8 37 15 I 

12 BLDPLY 

13 LOOP 

14 ON PLAYERS ; 

15 DCX — > 


Screen: 61 






Screen: 64 

0 

( Audio Editor 



) 

0 < 
1 

Audio Editor ) 

1 

2 

HEX 






1 

2 : 

INIT < — ) 

3 

CTABLE TBL 





3 

0 GR. 1 752 C! CLS 3 19 POS. 

4 

32 C, IF 

c, 

IE C, 

1A C, 18 

C, 


4 

. " Chan Freq Diet " 

5 

ID C, IB 

c, 

33 C, 

0F C, 0E 

C, 


5 

. " Vol AUDCTL" 

6 

DCX 






6 

4 0 

7 







7 

DO 

8 

: WPIT 



( pi# 

— 

) 

8 

8 I VOL C! 

9 

10 OVER 

20 

+ POS. 

PIT C@ 



9 

0 I PIT C! 

10 

3 .R ; 






10 

0 I DST C! 

11 







11 

CR I 3 SPACES . I WPIT 

12 

: WDST 



( pi# 

— 

) 

12 

I WDST I WVOL 

13 

16 OVER 

20 

+ POS. 

DST ce 



13 

LOOP 

14 

£ . R ; 






14 

0 ACTL ! WACTL SETP ; 

15 





— 

-> 

15 

==> 


Screen: 62 


Screen : 65 




0 

1 

< 

Audio Editor 

) 

0 

1 

< Audio Editor 


) 

1 

2 

. 

WVOL 

( pi# -- ) 

1 

2 

: SND 


( 

pi# f — ) 

3 


20 OVER 20 + 


3 

IF 




4 


POS. VOL C@ 2 . R ; 


4 

>R R R PIT 

ce 

R DST 

ce 

5 




5 

R> VOL ce 

SOUND 


6 

5 

WACTL 

( — ) 

6 

ELSE 




7 


£8 21 POS. BASE C0 

ACTL ce 

7 

XSND 




8 


DUP DUP 3 . R 2 BASE 

: C! 

a 

END IF ; 




9 


26 22 POS. 0 


9 

HEX 




10 


<######### 

#> TYPE 

10 

CODE DIG 



( n — n ) 

11 


FILTER' BASE C! 5 


11 

B5 C, 00 C, 

94 

C, 00 

c, 

12 




12 

94 C, 01 C, 

38 

C, AS 

c, 

13 




13 

36 C, 00 C, 

36 

C, 01 

c, 

14 




14 

88 C, D0 C, 

F9 

C, 4C 

c. 

15 



==> 

15 

NEXT , C; DCX 


-- > 


) 


> 


Screen : 


66 


0 

G l 

3 

4 

5 

6 
7 

a 

9 

10 

11 

12 

13 

14 

15 


Audio Editor 


VOLUPD < n — ) 

4 0 
DO 

I STRIG 
IF 

DUP I VOL C® + 0 MAX 15 MIN 
I VOL C! I WVOL 
END IF 
LOOP 
DROP ; 




Screen : 69 

0 < Audio Editor 

1 

2 : PDADJ ( hrz vrt pi# — ) 

3 > R -DUP 

4 IF 2* R DST C® + 

5 0 MAX 14 MIN R DST C! 

6 R WDST 

7 END IF 

8 -DUP 

9 IF I PIT C® + 

10 0 MAX 255 MIN R PIT C! 

11 R WPIT 

12 END IF 

13 R> DROP ; 

14 

15 — > 


Screen : 67 

0 < Audio Editor ) 

1 

2 : AKEY < — n tf / ff ) 

3 0 764 C® DUP 255 <> 

4 IF 

5 255 764 C! 

6 10 0 

O 7 DO 

8 DUP I 

9 IF 

10 DROP 

11 END IF 

12 LOOP 

13 ENDIF 

14 DROP ; 

15 


TBL C@ = 

NOT I SWAP 0 LEAVE 

— > 


Screen: 70 

0 ( Audio Editor 

1 


o 

4 

5 

6 

7 

8 
9 

10 

11 

12 


DIGMV 

> R R PIT C® 2/ 55 + 
R DST C® 4 * 21 + 

R> PLYPUT ; 


13 


14 

15 


( pi# 


) 


— ) 


==) 


Screen: 68 

0 ( Audio Editor ) 

1 

2 : ?AKEY ( — > 

3 AKEY 

4 IF 

5 DUP 8 < 

6 IF 

7 ACTL C® SWAP 1+ DIG XOR 

8 ACTL C! WACTL 

9 ELSE 

10 9=2* 1- VOLUPD 

11 ENDIF 

12 ENDIF ; 

13 

14 

15 ==> 


Screen: 71 

0 ( Audio Editor AUDED ) 

1 

2 FORTH DEFINITIONS 

3 

4 : AUDED ( — ) 

5 AUDPAL INIT 

6 BEGIN 4 0 

7 DO 

8 I STICK I PDADJ 

9 I DIGMV I I STRIG SND 

10 LOOP 

11 7AKEY 7TERMINAL 

12 UNTIL 

13 OFF PLAYERS 0 752 C! 

14 00 POS. XSND4 ; 

15 BASE ! FORTH 


Screen: 72 

0 
1 
£ 

3 

4 

5 

6 
7 

a 

9 

10 

u 

12 

13 

14 

15 


Screen: 75 

0 
1 
2 

3 

4 

5 

a 

7 

6 
9 

10 

11 

12 

13 

14 

15 




Screen: 73 

0 
1 


4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 76 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


o 


Screen: 74 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 77 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 



Screen: 78 

0 

P a 

3 

4 

5 

6 
7 

a 

g 

n 

12 

13 

14 

15 


Screen: 81 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 79 

0 
1 


4 

5 



9 

10 

11 

12 

13 

14 

15 


Screen: 82 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 80 

0 
1 
2 

3 

4 

5 
S 

7 

8 
9 

10 

11 



14 

15 


Screen: 83 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screens 84 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 87 

0 
1 
2 

3 

4 

5 
8 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 85 

0 
1 


4 

5 

6 

7 

8 
3 

10 

11 

12 

13 

14 

15 


Screen : 88 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen : 86 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen : 89 

0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

n 

12 

13 

14 

15 


) 


) 


Screen: 90 

0 ( Charedit: var defs 

1 BASE @ DCX 
£ ’ ( POS. ) ( : POS. 84 C! 85 ! ; ) 

3 

4 ’ < STICK ) ( 84 KLOAD > 

5 

6 VOCABULARY CHREDT IMMEDIATE 

7 CHREDT DEFINITIONS 

8 


9 

0 

VARIABLE 

HORZ 

10 

0 

VARIABLE 

VERT 

11 

0 

VARIABLE 

CHAR# 

13 

0 

VARIABLE 

CURLOC 

13 

0 

VARIABLE 

DEFLOC 

14 

0 

VARIABLE 

TPTR 

15 

0 

VARIABLE 

CSET-LOC 


Screen: 91 

0 < Charedit ) 

1 

£ : POSCUR < ri n -- ) 

3 SWAP CURLOC S 

4 DUP C© 84 - 

5 SWAP C! 40 * + £03 + 

6 88 © + DUP C© 

7 84 + OVER Ci 

8 CURLOC I ; 

9 

10 : CLICK ( — ) 

11 0 53379 C! 

13 8 53379 C! ; 

13 

14 

15 — > 


Screen: 93 

0 ( Charedit 

1 ’ ( NFLS — > ) ( ) 

p 

3 0 VARIABLE NFLG 

4 

5 : —NUMBER ( addr — d ) 

6 BEGIN DUP C© BL = DUP + NOT 

7 UNTIL 0 NFLG ! 0 0 ROT DUP 1+ 

8 C© 45 = DUP > R + -1 

9 BEGIN DPL ! (NUMBER) DUP C© 

10 DUP BL <> SWAP 0# AND 

11 WHILE DUP C© 46 - NFLG ! 

13 0 REPEAT DROP R> IF DMINUS 

13 END IF NFLG 8 IF 3DRQP END IF 

14 NFLG © NOT NFLG ! 5 


15 


— > 

Screen : 94 


0 

1 

( Charedit 

) 

X 

3 

: DSPCHR 

( — ) 

3 

88 © £03 + CURLOC ! DUP 

1 330 + 

4 

SWAP 


5 

DO 


G 

I 8 0 DO 


7 

0 OVER C@ 7 I - CHSB1 


8 

IF 138 + END IF 


9 

CURLOC © C! 1 CURLOC 

+ ! 

10 

LOOP 


11 

DROP 33 CURLOC + ! 40 


13 

+LOOP 8 0 VERT ! HORZ ! 

88 © 

13 

£03 + DUP DUP CURLOC ! 

C© 

14 

84 + SWAP C! 5 ' 


15 


==> 


Screen: 93 






Screen: 95 




0 

1 

( Charedit 





> 

0 

( 

Charedit 



> 

X 

3 

HEX 






1 

3 

• 

GRAFC 


( 

— n ) 

3 

: ANTIC 





( f — ) 

3 


88 © 883 + ; 




4 

33F C© SWAP 





4 






5 

IF £0 OR ELSE 

DF 

AND END IF 

5 

; 

GR 8 


< 

— n ) 

6 

££F C ! ; 






6 


88 © 80S + ; 




7 







7 






8 

CODE CHSB0 




< 

b — n > 

8 

s 

SCR/W 

( n 

n 

r, — ) 

9 

B4 C, 00 C, 

C 8 

c, 

A9 

c, 

00 C, 

9 


SWAP B/SCR * 

OFFSET © 

*• 


10 

95 C, 00 C, 

95 

c. 

01 

C, 

38 C, 

18 


DUP 4 + SWAP 




11 

36 C, 00 C, 

36 

c, 

01 

C, 

18 C, 

1 1 


DO 




13 

88 C, D0 C, 

F 8 

c, 

4C 

C, 

NEXT , 

13 


3DUP I SWAP 

R/W 



13 

C; 






13 


SWAP 138 + SWAP 



14 

: CHSB1 



( 

n 

b — f ) 

14 


LOOP 




15 

CHSB0 AND 

0 # ; 

DCX 


==> 

15 


3DR0P ; 



— > 


Screen : 96 


Screen : 99 


0 

( Chared it 



) 

0 

( Charedit 


1 

HEX 




1 



2 

CODE CHSB2 



< n — n ) 

2 

s PTCST < 

scr# — 

3 

B5 C, 00 C, 

94 C, 

00 

c, 

3 

PAD CSET-LOC ! 


4 

94 C, 01 C, 

38 C, 

AS 

c. 

4 

GRAFC DUP 320 + SWAP 


5 

36 C, 00 C, 

36 C, 

01 

c, 

5 

2 0 DO 


6 

aa c, D 0 c, 

F9 C, 

4C 

C, 

6 

32 0 DO 


7 

NEXT , C; 




7 

DUP DUP 320 + SWAP 

DO 

a 

DCX 




a 

I C® CSET-LOC © C! 


9 





9 

1 CSET-LOC +! 


10 

: MPTRR 



( — ) 

10 

40 /LOOP 


1 1 

TPTR © 0 OVER C! 

1+ 1 

DUP 

11 

1+ LOOP 


12 

GR8 2- 33 + 

U> 



12 

DROP 


13 

IF 32 - END IF 



13 

LOOP 


14 

DUP TPTR ! 

93 SWAP C 

! CLICK ; 

14 

PAD SWAP 0 SCR/W ; 


15 




==> 

15 




Screen: 97 


Screen: 100 

0 < 
1 

o . 

Charedit 

) 

0 ( 
1 

Charedit 

MPTRL 

< — ) 

1 

2 : 

GTCST < scr# — 

3 

TPTR © 0 OVER C! 1- 


3 

GRAFC PAD ROT 1 SCR/W 

4 

DUP GR 8 U< 


4 

PAD CSET-LOC ! 2 0 

5 

IF 


5 

DO 

6 

32 + 


6 

32 0 DO 

7 

END IF 


7 

DUP DUP 320 + SWAP DO 

8 

DUP TPTR ! 


8 

CSET-LOC © C© I C! 

9 

93 SWAP C! 


9 

1 CSET-LOC + ! 

10 

CLICK ; 


10 

40 /LOOP 

11 



11 

1+ LOOP 

12 



12 

288 + LOOP DROP GRAFC DUP 

13 



13 

DEFLOC ! DSPCHR 0 CHAR# ! 

14 



14 

GRS DUP 0 TPTR © C! 12 14 POS, 

15 


— > 

15 

0 . 93 SWAP C! TPTR ! ; 


Screen : 98 

Screer 

i: 101 


0 

( Charedit ) 

0 ( 
1 

Charedit 


1 

2 

HEX 

1 

2 : 

GETSCR 

< — scr# 

3 

: DBMAKE < — ) 

3 

BEGIN 


4 

OFF ANTIC 58 © 300 - DUP 

4 

18 14 POS. . " 

Screen #: " 

5 

58 1 FF00 AND DUP 230 1 

5 

PAD 5 EXPECT 

PAD 1 NUMBER 

6 

DUP 3 70 FILL 

6 

DROP 128 17 C 

! 1 752 C* 

7 

3 + DUP 42 SWAP C! 

7 

18 14 POS. 16 

SPACES NFLG 9 

8 

1+ DUP 58 8 SWAP ! 

8 

IF 


9 

2+ DUP 15 2 FILL 

9 

DUP 1 < OVER 

179 > OR 

10 

15 + DUP 12 F FILL 

10 

? IK IF OVER 89 > OR END IF 

11 

12 + DUP 41 SWAP C! 

11 

IF DROP 0 ELSE 1 END IF 

12 

1 + 230 © SWAP ! 

12 

ELSE DROP 0 


13 

ON ANTIC ; 

13 

END IF 


14 

DCX 

14 

UNTIL 


15 

==> 

15 

DUP 13 15 POS. 

3 . R 5 — : 


) 


) 


Screen : 1 02 

0 ( Charedit 

1 

£ : VFIO ( — f ) 

3 KEY 89 = 18 14 POS. 

4 18 SPACES ; 

5 

6 : SVCST < — ) 

7 18 14 POS. . " Save this set?” 

8 VFIO 

9 IF GETSCR PTCST END IF ; 

10 

11 : LDCST ( — ) 

1£ 18 14 POS. ." Load new set?" 

13 VFIO 

14 IF GETSCR GTCST END IF ; 

15 ==> 


Screen: 103 

0 < Charedit ) 

1 

£ : MVRHT ( — ) 

3 CHAR# 0 DUP 63 <> 

4 IF 

5 31 = 

6 IF £89 ELSE 1 END IF 

7 DEFLOC + ! 

8 1 CHAR# +! DEFLOC 

9 0 DSPCHR MPTRR 

10 IE 14 POS. 

1 1 CHAR# ? 

12 ELSE 

13 DROP 

14 END IF ; 

15 — > 


Screen: 105 

0 < Charedit 

1 

2 : CLRCHR < — ) 

3 DEFLOC 080 

4 DO DUP I 40 * + 0 SWAP C! LOOP 

5 DROP 88 0 £03 + 80 

6 DO 

7 DUP I 40 * + 80 

8 DO 

9 DUP I + 0 SWAP Cf 

10 LOOP DROP 

11 LOOP DROP 

1£ 0 VERT ! 0 HORZ ! 

13 88 0 203 + DUP C0 

14 84 + SWAP DUP 

15 CURLOC ! C! ; — > 


Screen: 106 

0 < Charedit ) 

1 

2 : CLRCST ( — > 

3 18 14 POS. .” Clear this set?" 

4 KEY 89 = 

5 IF 

6 GRAFC DUP DUP 680 + SWAP 

7 DO 

8 0 I C! 

9 LOOP 

10 CLRCHR 0 CHAR# ! DEFLOC ! 

11 12 14 POS. CHAR# ? 

12 GR8 0 TPTR 0 C' 93 OVER 

13 C! TPTR ! 

14 ENDIF 

15 18 14 POS. 15 SPACES ; ==> 


Screen: 104 Screen: 107 


0 

1 

< Charedit 

) 

0 

1 

2 

< Charedit 




1 

£ 

: MVLFT 

( — ) 

HEX 





3 

CHAR# 0 -DUP 


3 






4 

IF 


4 

: CKOPT 



( 

5 

32 = 


5 

2FC 

C0 FF 

£FC C! 


6 

IF -289 ELSE -1 ENDIF 


6 

DUP 

IF = 

IF 

CLRCHR 

ENDIF 

7 

DEFLOC +! -1 CHAR# +! 


7 

DUP 

IE = 

IF 

CLRCST 

ENDIF 

8 

DEFLOC 0 DSPCHR MPTRL 


8 

DUP 

18 = 

IF 

LDCST 

ENDIF 

9 

12 14 POS. CHAR# ? 


9 

DUP 

1A = 

IF 

SVCST 

ENDIF 

10 

ENDIF ; 


10 

DUP 

06 = 

IF 

MVLFT 

ENDIF 

11 



1 1 


07 = 

IF 

MVRHT 

ENDIF ; 

12 



12 






13 



13 






14 



14 






15 


==> 

15 

DCX 






) 


— ) 


— > 


Screen: 100 

0 ( Chared it ) 

1 

£ : CKBTN < — ) 

3 644 C0 NOT 

4 IF 

5 CLICK 

6 CURLOC 0 DUP C0 8 CHSB2 XOR 

7 SWAP C! DEFLOC 0 VERT 0 

S 40 * + DUP C0 7 HORZ 0 

9 - 1+ CHSB2 XOR SWOP C! 

10 2000 0 DO LOOP 

11 END IF ; 

12 

13 

14 

15 ==> 


Screen: 109 




0 ( 

Chared it 



z 

o • 

L_ ■ 

CKSTK 



( — 

3 

0 STICK 

2DUP OR 



4 

IF 




5 

VERT 0 

+ 0 MAX 7 

MIN 

VERT ! 

6 

HORZ 0 

+ 0 MAX 7 

MIN 

HORZ ! 

7 

VERT 0 

HORZ 0 POSCUR 


8 

2000 0 

DO LOOP 



9 

ELSE 




10 

2DR0P 




11 

END IF ; 




12 

13 : 

CHECK 



( — 

14 

CKSTK CKBTN CKOPT 

5 


15 






Screen: 110 

0 ( Chared it ) 

1 

£ : STPSCR ( — ) 

3 CR 4 SPACES 

4 . " * * * CHARACTER-EDIT * * *" 

5 CR CR CR . " 01234567" CR 

6 8 0 DO I . CR LOOP 

7 18 4 POS. 

8 . " Opt ions : " 

9 18 6 POS. 

10 (1) Clear Character" 

11 18 8 POS. 

12 < 2) Clear this set" 

13 18 10 POS. 

14 ." (3) Save this set" 

15 ==> 


Screen : 111 

0 ( Chared it ) 

1 

2 18 12 POS. 

3 (4) Load a new set" 

4 214 POS. . " Character 0" 

5 2 15 POS. . " Load/Save: " 

6 2 17 POS. 

7 . " Use ’ " 30 SPEMIT 

8 . " ’ and * " 31 SPEMIT . “ * to" 

9 CR 

10 . " through the character set. " 

11 00 POS. ; 

12 

13 

14 

15 — > 


Screen: 112 

0 < Chared it ) 

1 

2 FORTH DEFINITIONS 

3 

4 : CHAR-EDIT ( — ) 

5 CHREDT ( enter vocabulary ) 

6 0 GR. 1 752 C! 

7 CLS DBMPKE 

8 88 0 1300 ERASE 

9 GRAFC DEFLOC ! 

10 GR8 DUP TPTR ! 

11 93 SWAP Cf 

12 STPSCR 

13 88 0 203 + DUP CURLOC ! 

14 84 SWOP C! 

15 ==> 


Screen: 113 

0 ( Chared it ) 

1 

2 0 HORZ 1 

3 0 VERT ! 

4 0 CHAR# ! 

5 

6 DCX 

7 BEGIN 

8 CHECK 

9 1 752 C! 128 17 C! 

10 7TERMINAL 

11 UNTIL 

12 0 GR. ; 

13 

14 BOSE ! FORTH 

15 


Screen: 114 
® 



3 

4 

5 

6 

7 

8 
9 

1® 

11 

IS 

13 

14 

15 


Screen: 117 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 115 
0 
1 
2 

3 

4 

5 

6 

O I 

9 

10 

11 

12 

13 

14 

15 


Screen : 118 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 116 
0 
1 


o 


3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 119 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

1® 

11 

12 

13 

14 

15 


) 


Screen: 120 

0 < Character words: CHLOAD 

1 

2 BASE 0 DCX 

3 

4 : CHLOAD < addr scr# cnt — ) 

5 8 * DUP <ROT 

6 128 /MOD SWAP 0# + 

7 > R B/SCR * R> 0 

8 DO 

9 PAD 128 I * + 

10 OVER I + 1 R/W 

11 LOOP 

12 DROP 

13 PAD <ROT CMOVE ; 

14 

15 ==> 


Screen: 123 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


G 


Screen: 121 Screen: 124 

0 ( Character words: NML/SPLCHR ) 0 

1 1 

2 2 

3 : SPLCHR < CHBAS — ) 3 

4 SPt? 1+ C@ 4 

5 SWAP DROP 756 C ! ; 5 

6 6 

7 7 

Q : NMLCHR ( — ) 8 

9 57344 SPLCHR ; 9 

10 10 

11 11 

12 BASE ! 12 

13 13 

14 14 

15 15 


o 


Screen: 122 
0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

11 

12 

13 

14 

15 


Screen: 125 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


o 


Screen: 126 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
3 

10 

11 

12 

13 

14 

1 5 


Screen: 129 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 127 
0 
1 
2 

3 

4 

5 
S 
7 

a 

9 

10 

u 

12 

13 

14 

15 


Screen: 130 
0 
1 
£ 

3 

4 

5 

6 

7 ( Standard Character set ) 

6 
9 
10 
11 
12 

13 

14 

15 


Screen: 128 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 131 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 
11 
12 

13 

14 

15 


( Standard Character set ) 


Screen: 132 


Screen : 


0 0 

1 1 

2 2 

3 3 

4 4 

5 5 

6 6 

7 ( PM example #2 ship images > 7 

8 8 

9 9 

10 10 

11 11 

12 12 

13 13 

14 14 

15 15 


135 


Screen: 133 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 136 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 134 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 137 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


> 


Screen: 138 

Screen: 141 

0 

0 

< 

Player/Missile example 1 

Pi 1 

1 



V 2 

2 

s 

BOP 0 53279 C! 8 53279 C! ; 

3 

3 



4 

4 

: 

MOVE-BALL 

5 

5 


BEGIN 

8 

S 


HBALL 0 VBALL 0 0 PLYMV 

7 

7 


0 PLYSTT C0 DUP 3 AND 

8 

8 


IF VBALL 0 MINUS VBALL ! 

9 

9 


ENDIF 

10 

10 


3 > 

11 

11 


IF HBALL 0 MINUS HBALL ! 

12 

12 


ENDIF 

13 

13 


50 0 DO LOOP ( Wait... > 

14 

14 


7TERMINAL 

15 

15 


UNTIL ; 

Screen: 139 

Screen: 142 

0 

0 

( 

Player/Missile example 1 

1 

1 



2 

2 

s 

BOUNCE 

3 

3 


CLS 

4 

4 


1 PMINIT 

5 

5 


PMCLR 


6 


1 PRIOR 

(J 7 

7 


ON PLAYERS 

8 

8 


47 200 32 217 0 PLYBND 

9 

9 


0 9 ( BLUE ) 8 PMCOL 

10 

10 


IMAGE 7 100 75 0 BLDPLY 

11 

11 



12 

12 


. " Press START to stop... " 

13 

13 


MOVE-BALL 

14 

14 


OFF PLAYERS ; 

15 

15 


BASE 





Screen: 148 

0 ( Player/Missile example 1 > 

1 ’ ( PLYMV ) ( 15 KLOAD ) 

2 BASE @ 2 BASE ! 


3 

4 1 VARIABLE HBALL 

5 1 VARIABLE VBALL 


6 

7 LABEL IMAGE 

8 011100 C, 

9 111110 C, 

10 111110 C, 

11 111110 C, 

12 111110 C, 

13 111110 C, 

14 011100 C, 

15 


A BIG BALL ) 




Screen: 143 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


DECIMAL 


Screen: 144 
0 
1 
£ 

3 

4 

5 

6 
7 
S 
9 

10 
11 
1 £ 

13 

14 

15 


Screen: 147 



£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

1£ 

13 

14 

15 


Screen: 145 
0 
1 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
1£ 

13 

14 

15 


Screen: 148 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

1£ 

13 

14 

15 


o 


Screen: 146 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

IS 

1 3 

14 

15 


Screen: 149 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
1£ 

13 

14 

15 


c 


) 


Screen: 150 


e 


0 


( Player/Missile example 
1 BASE 0 DCX 

£ ’ < CHLOAD ) ( 60 KLOAD ) 

) ( 


> < PLYMV 
' < STICK 


15 KLOAD ) 
) ( 84 KLOAD ) 


Screen : 
0 
1 
2 

3 

4 


153 


5 : 

FLY 



5 

6 

BEGIN 



& 

7 

75 0 DO LOOP 

< 

wait ) 

7 

8 

PAD 

< 

addr ) 

8 

9 

0 PLYLOC SWAP 

DROP 


9 

10 

8/11 SWAP - 



10 

11 

11 MIN 0 MAX 

< 

image# ) 

11 

12 

0 PLYSEL 

( 

pl #0 ) 

12 

13 

0 STICK 0 PLYMV 


13 

14 

7TERMINAL 



14 

1 5 

UNTIL 5 


==> 

15 


Screen: 151 

0 < Player/Missile example £ ) 

1 

2 : SHIP 

3 £ PMINIT 

4 1 PRIOR 

5 PMCLR 

, & 0 9 ( BLUE ) 8 PMCOL 

V 7 PAD 132 15 CHLOAD 

8 PAD 8 50 50 0 BLDPLY 

9 50 200 10 110 0 PLYBND 

10 CLS 

11 Move player with stick 0." 

12 CR 

13 Press START to stop... ” 

14 ON PLAYERS FLY OFF PLAYERS ; 

15 BASE ! — > 


Screen: 154 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


c 


Screen : 
0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

11 

12 

13 

14 

15 


152 


Screen: 155 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 156 
0 
1 

2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 159 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


G 


Screen: 157 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 160 

0 ( Utils: CARRAY ARRAY ) 

1 BASE @ HEX 

2 : CARRAY ( cccc, n — ) 

3 CREATE SMUDGE < cccc: n — a ) 

4 ALLOT 


5 

5 CODE 

CA C, 

CA 

c, 

18 C, 

6 

A5 C, 

W C, 

69 

C, 

02 C, ' 

7 

00 C, 

98 C, 

65 

C, 

W 1+ C, 

8 

95 C, 

01 C, 

4C 

C, 


9 

’ + ( 

CFA 0 

> , 

C; 



10 

11 : ARRAY < cccc, n — ) 

12 CREATE SMUDGE ( cccc: n — a ) 

13 2* ALLOT 

14 ; CODE 16 C, 00 C, 36 C, 01 C, 

15 4C C, 1 CARRAY 08 + , C; ==> 


o 


Screen: 158 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 161 

0 ( Utils: CTABLE TABLE ) 

1 

2 : CTABLE < cccc, — ) 

3 CREATE SMUDGE < cccc: n — a ) 

4 ;CODE 

5 4C C, • CARRAY 08 + , C; 

6 

7 : TABLE ( cccc, — ) 

8 CREATE SMUDGE ( cccc: n — a ) 

9 ; CODE 

10 4C C, ' ARRAY 0A + , C: 

11 
12 

13 

14 


G 


Screen: 16£ 

0 ( Utils: 2CARRAY 2ARRAY ) 

1 

£ : 2CARRAY ( cccc, nr, — ) 

3 <BUILDS < cccc: nr, — a ) 

4 SWOP DUP , * ALLOT 

5 DOES) 

6 DUP > R 0 * + R> + 2+ ; 

~7 

a : 2ARRAY ( cccc, nr,— ) 

3 < 8 UILDS ( cccc: r, r, — a ) 

10 SWOP DUP , * 2* ALLOT 

11 DOES) 

12 DUP >R 0 * + 2* R> +2+ j 

13 

14 

15 ==> 


Screen: 165 

0 

1 

2 

3 

4 

5 

6 
7 

a 

3 

10 

n 

12 

13 

14 

15 


Screen: 163 

Utils: XC! X! ) 

XC! ( r,0. . . rirn crit addr — ) 
OVER 1- + >R 0 
DO J I - C! 

LOOP R> DROP 5 

X 1 < n0. . . nrn crit addr — ) 

OVER 1- 2* + >R 0 
DO J I 2* - ' 

LOOP R) DROP j 

Caution: Remember limitation 
on stack size of 30 values 
because of OS conflict. ) 

— > 


Screen: 166 

0 ( Sound: SOUND SO. FILTER 1 ) 

1 

2 BASE 0 HEX 

3 0 VORIOBLE OUDCTL 

4 

5 : SOUND ( ch# freq dist vol — ) 

6 3 DUP D20F C! 232 C! 

7 SWAP 10 * + ROT 2* 

Q D200 + ROT OVER C! 1+ Of 
3 OUDCTL C0 D208 C! ; 

10 

11 : SO. SOUND ; 

12 

13 : FILTER! ( b — ) 

14 DUP D208 C! OUDCTL ! ; 

15 ==> 


0 ( 
1 


o 


■i 

4 

5 

6 

7 : 

8 
3 

10 

11 

12 ( 

13 t 

14 ( 

15 


Screen: 164 


o 


0 

1 

£ 

3 

4 

5 

6 

7 

8 
3 

10 
1 1 
12 
13 


Utils: CVECTOR VECTOR ) 

CVECTOR < cccc, cr.t — ) 

CREATE SMUDGE < cccc: n — a ) 

HERE OVER ALLOT XC! 

; CODE 

4C C, * CORRAY 08 + , C; 

VECTOR < cccc, crit — ) 

CREATE SMUDGE < cccc; n — a ) 

HERE OVER 2* ALLOT X! 

; CODE 

4C C, ’ ARRAY 00 + , C; 


14 


15 


BASE ! 


Screen: 167 

0 < Sound: XSND XSND4 ) 

1 
£ 

3 : XSND ( voice# — ) 

4 2* D201 + 

5 0 SWAP C! ; 

6 

7 

8 : XSND4 ( - ) 

3 D200 8 0 FILL 

10 0 FILTER! ; 

11 
12 

13 > ( POS. ) ( : POS. 54 C! 55 ' ; ) 

14 

15 BASE ! 


) 


Screen: 168 

0 ( Utils: STICK 

1 BOSE § HEX 

2 LABEL STKARY 

3 0 , -1 , 1 , 0 , 

4 

5 : STICK 

6 278 + C® 0F XDR 

7 DUP 2/ 2/ 3 AND 

8 2* STKARY + 0 

9 SWAP 3 AND 

10 2* STKARY + @ ; 

11 


ri 


n n ) 


12 CODE STRIG < n -- f ) 

13 B4 C, 00 C, B9 C, 284 , 

14 49 C, 01 C, 4C C, PUT0A , C; 

15 BASE ! 


Screen: 171 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 169 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 172 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 170 

0 CONTENTS OF THIS DISK: 

1 

2 PLAYER/MISSILES: 

3 AUDIO EDITOR: 

4 CHARACTER EDITOR: 

5 CHARACTER SET WORDS: 

6 

7 STANDARD CHARACTER SET 

8 SPACE SHIP IMAGES 

9 

10 PM EX. #1 < BOUNCE ) 

11 PM EX. #2 ( SHIP ) 

12 

13 ARRAYS ( FOR ALL ) 

14 SOUNDS ( FOR AUDED ) 

15 STICK 


Screen: 173 
0 
1 


30 

LOAD 

2 

60 

LOAD 

3 

90 

LOAD 

4 

120 

LOAD 

5 



6 

130 

LIST 

7 

132 

LIST 

8 



9 

140 

LOAD 

10 

150 

LOAD 

11 



12 

160 

LOAD 

13 

166 

LOAD 

14 

168 

LOAD 

15 


Screen: 174 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 177 

0 Disk Error! 

1 

£ Dictionary too big 

3 

4 

5 

e 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 175 
0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 178 

0 ( Error messages ) 

1 

£ Use only in Definitions 

3 

4 Execution only 

5 

6 Cond i t i ona 1 s not pa i red 

7 

8 Definition not finished 

9 

10 In protected dictionary 

11 

1£ Use only when loading 

13 

14 Off current screen 

15 


Screen: 176 

0 < Error messages 

1 

£ Stack empty 

3 

4 Dictionary full 

5 

6 Wrong addressing mode 

7 

8 Is not unique 

9 

10 Value error 
1 1 

12 Disk address error 

13 

14 Stack full 

15 


Screen: 179 

> 0 Declare VOCABULARY 

1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 




O 


‘VALPAR \ ™ 


INTERNATIONAL 

3801 E. 3a™ STREET 
TUCSON, ARIZONA B5713 
B02-7S0-7iai 



valFORTH 

T.M. 

SOFTWARE SYSTEM 

for ATARI - 


DISPLAY FORMATTER 


Atari is a trademark of Atari, Inc., a division of Warner Communications. 


Software and Documentation 
©Copyright 1982 
Valpar International 


c 


o 


C' 


valFORTH 

T.M. 

DISPLAY FORMATTER 


Version 1.1 
March 1982 


The following is a description of commands used in creating video display 
lists on the Atari 400/800 series microcomputers. Creating custom display 
lists allows for innovative graphic layouts of games, simulations, or business 
applications which utilize both hi-resol ution graphics and text simultaneously. 


Software and Documentation 
©Copyright 1982 
Valpar International 


o 


o 




o 


valFORTH 

T.M. 

SOFTWARE SYSTEM 

DISPLAY FORMATTER 

Stephen Maguire 

Software and Documentation 
©Copyright 1982 
Valpar International 


Purchasers of this software and documentation package are 
authorized only to make backup or archival copies of the 
software, and only for personal use. Copying the accompanying 
documentation is prohibited. 

Copies of software for distribution may be made only as speci- 
fied in the accompanying documentation. 


c 


o 


c 


VALPAR INTERNATIONAL 


Disclaimer of Warranty 
on Computer Programs 


All Valpar International computer programs are distributed 
on an "as is" basis without warranty of any kind. The total 
risk as to the quality and performance of such programs is with 
the purchaser. Should the programs prove defective following 
their purchase, the purchaser and not the manufacturer, distributor, 
or retailer assumes the entire cost of all necessary servicing cr 
repai r. 

Valpar International shall have no liability or responsibility 
to a purchaser, customer, or any other person or entity with 
respect to any liability, loss, or damage caused directly or 
indirectly by computer programs sold by Valpar International. 

This disclaimer includes but is not limited to any interruption 
of service, loss of business or anticipatory profits or conse- 
quential damages resulting from the use or operation of such 
computer programs. 

Defective media (diskettes) will be replaced if diskette(s) 
is returned to Valpar International within 30 days of date of sale 
to user. 

Defective media (diskettes) which is returned after the 30 day 
sale date will be replaced upon the receipt by Valpar of a $12.00 
Replacement Fee. 


I 

C) 


o 




Cl 


An indepth explanation of display lists was written by 
Dave and Sandy Small in a series of articles found in Creative 
Computing . We suggest that this be read to get the most out of 
this val FORTH package. 


c 


o 


c 


val FORTH Display Formatter 1.1 


STROLLING THROUGH THE DISPLAY FORMATTER 


In Atari Basic there are many different graphic modes. Some of these are 
text modes, some are graphics modes, and some are mixed. These different 
graphic modes are based upon display lists. A display list is a list of display 
instructions which tell the video processor whether a particular portion of the 
screen is to be high resolution graphics or normal text. Any given section of 
the display can actually take on one of 18 different characteristics. 


Let's take a look at the display 
values are in base 16) 

BC20 70) 

70> 

70 J 
42) 

40 > 

BCj 



BC40 


list for a graphic 0 display: (These 

24 blank scan lines 
DM jump to BC40 

23 graphic 0 lines 

jump to BC20 

start of display memory 


Each opcode 70 instructs the video processor to display 8 blank scan 
lines. Opcode 2 produces one standard graphic 0 text line. Opcode 42 is a 
modified 2 instruction. In addition to creating a standard text line, it 
also informs the video processor where the display memory is located (the 
address is found in the next two bytes). At the end of the list there is a 
three byte jump instruction which transfers display list interpretation to the 
address specified in the next two bytes of the list. Each of the graphic 
settings have a similar list. This valFORTH package allows you to design your 
own lists. Let's make one now. 

Look in the directory (screen 170) and load in the display formatter. 

Most of the formatter words begin with DB (for display block). To initialize 
the system type: 


DBINIT 

HEX 


XXXI-1 


val FORTH Display Formatter 1.1 


This initializes the system and puts it into the more useful hexadecimal mode. 
Graphic mode 8 is a high resolution graphic mode with a four line text window 
at the bottom of the display. Let's make a display with a four line text 
window at the top of the screen followed by the high resolution graphics plate. 
First, we need 24 blank scan lines at the top: 

70 DBM 
70 DBM 
70 DBM 

The DBM command stands for "Display-Block Make." It takes the opcode on top of 
the stack and tacks it onto the end of the display list currently being created. 
Additionally, it enters an address into the array DBLST which points to the 
first byte of memory used by that display block. There is a plural form of the 
DBM command: 


3 70 DBMS 

This adds 3 opcode 70 ' s to the current display list. Now let's add the four 

line text window. Recall that a normal text line has an opcode of two: 

4 2 DBMS 

Note that the display memory jump described earlier is automatically inserted 
into the display list. Now we need to define the high resolution portion of 
the display. A standard graphic 8 line has an opcode of $F (15 in decimal). 

Let's create 20 graphic 8 lines (20 in base 16 is 14). 

14 F DBMS 

This list is good enough for now. To verify that it has been entered properly, 
type: 


DMPLST 


You should get something like: 


XXXI -2 


val FORTH Display Formatter 1.1 


BLK 

ADDR 

0 

A100 

1 

A100 

£ 

A100 

3 

A100 

4 

Al£8 

5 

A150 

6 

A178 

7 

A1A0 

8 

A1C8 

9 

A1F0 

A 

A£18 

B 

A£40 

C 

A£68 

D 

A£90 

E 

A£B8 

F 

A£E0 

10 

A308 

11 

A330 

1£ 

A358 

13 

A380 

14 

A3A8 

15 

A3D0 

16 

A3F8 

17 

A420 

18 

A448 

19 

A470 

1A 

A49B 


BYTE MODS 

70 

70 

70 

£ J 0100 
£ 

£ 

£ 

F 

F 

F 

F 

F 

F 

F 

F 

F 

F 

F 

F 

F 

F 

F 

F 

F 

F 

F 

F 


Note the automatic insertion of the display memory jump in block three. 
Display memory cannot cross a 4K memory boundary without a display memory jump. 
As each display block is added, a check is made to detect any 4K memory cross- 
ings caused by the display block. If the block does cross, a display memory 
jump is automatically inserted into the list to account for it. 

Now that we have a display list, let's enable it. There are several ways 
to activate a list. For now type: 


MIXED CLS 

This MIXED command enables the new display list and also re-directs output 
to the display memory specified by the list. This allows for interactive dis- 
play list creation. There should be a recognizably different display. Hold 
down the RETURN key and watch how the "ok" message is displayed as the cursor 


XXXI-3 


val FORTH Display Formatter 1.1 


moves down the screen. You should see "ok"'s on the text lines, but in the 
high resolution lines, it shoud look quite different. You can type in a high 
resolution mode because the Atari operating system does not know that the 
display list has been changed. To return to a normal display, the GR. command 
is used: 


0 GR. 

Dump the display list again using the DMPLST command. Let's put some text 
lines in at block B. To do this type: 


B DBPTR 

10 2 DBMS 

The DBPTR command positions the display list pointer to the specified 
block. That block then becomes the end of the list. After that, we add 16 
(10 hex) graphic 0 lines. Dump the list again and verify that this is indeed 
what was accomplished. To view this new display, type: 

MIXED CLS 

Hold down the RETURN key again. Notice what happens as the cursor passes 
through the high resolution section and then back into the second text section. 
Type DMPLST again while in this mode and notice that everything works the same, 
the data is simply displayed differently. To get out, type "0 GR.". 

Besides adding display blocks onto the end of a display list, the display 
formatter allows display blocks to be inserted and deleted as well. Block two 
has an opcode 70 which produces 8 blank scan lines on the video screen. By 
deleting this block from the list, the entire display will shift upwards by 8 
lines. This is accomplished using the DBDEL command: 

2 DBDEL 

Dump the list and verify that the block has indeed been deleted. Enable 
the list using "MIXED CLS". Note that the first text line appears much higher 
than usual on the video screen. While still in this display, execute: 

4 6 DBDELS 

This will delete the four display blocks starting at block six. In this 
case, the four high resolution display lines are deleted. Type “MIXED CLS" 
and watch the screen shrink slightly as the display blocks are extracted. 

Display blocks can be inserted using the DBIN command. When a DBIN 
command is executed, the specified opcode is inserted into the specified block. 
The opcode previously in that block and all opcodes following are pushed back 
by one block. As an example, we will insert opcode 70 (8 blank scan lines) 
at block five. This will do it: 

70 5 DBIN 


XXX I -4 


val FORTH Display Formatter 1.1 


"MIXED CLS" will activate the new list. Press the RETURN key a few times 
and notice how the output routines seem to ignore the blank scan lines. The 
DBINS command is a plural form of the DBIN command. Let's insert a different 
opcode other than 2 or $F. Opcode 6 is a mode which displays colored characters 
which are much larger than normal. This will insert three opcode 6 1 s at block 9 

369 DBINS 

Activate this new list in the normal way and experiment with it. The 
following section describes all of the available opcodes. Experiment with these 
as you read about them and you should have no problem understanding any of them. 

This brief explanation of display list formatting should show the power 
available to the programmer who wants to get that unique display. There are 
many more commands available for use. These are explained thoroughly in the 
glossary at the end of the next section. 


XXXI -5 


val FORTH Display Formatter 1.1 


DISPLAY LIST INSTRUCTIONS 


There are four basic display list instructions. Those that produce blank 
scan lines, the display list jump, the jump on vertical blank, and the display 
block instructions. This is a description of these four basic instructions. 


B1 ank Scan Lines 


Byte form: 



n n = 0 to 7 


This opcode produces n+1 blank scan lines of color BAK. No video 
memory is used by this instruction. 

If the I bit is set, a display list interrupt (DL1 ) will occur upon 
interpretation by Antic (the video processor). 


The 8 legal 

$00 = 0 
$10 = 16 
$20 = 32 
$30 = 48 
$40 = 64 
$50 = 80 
$60 = 96 
$70 = 112 


ues are: 

1 blank scan 

2 blank scan 

3 blank scan 

4 blank scan 

5 blank scan 

6 blank scan 

7 blank scan 

8 blank scan 


1 i ne (128 wi 
lines (144) 
lines ( 160 ) 
lines (176) 
lines (192) 
lines (208) 
lines (224) 
lines (240) 


th I bit set) 


Display List Jump 


Byte form: 


I 

0 

0 

0 

0 

0 

0 

1 


This command instructs Antic to search for the next display list 
instruction specified by the address contained in the next two bytes of 
the display list. The low byte of the address is found lower in memory. 
This command is used primarily to continue a display list across a IK 
memory boundary (Antic will not handle this properly). This is the only 
instruction not supported by the display formatter since its occurrence 
is rare. It is explained here for completeness sake and its use is 
absolutely forbidden. Future releases may have this implemented. 

If the I bit is set, a display list interrupt will occur upon 
interpretation by Antic. 

Legal form: 

$01 addr-low addr-hi Transfer display list 

interpretation to addr. 

XXXI -6 


val FORTH Display Formatter 1.1 


Jump On Vertical Blank 


Byte form: 



This three byte opcode instructs Antic to transfer display list 
interpretation to the address specified by the following two bytes (low 
byte of address first) and to pause until vertical blank occurs. Since 
display list processing halts, any remaining portion of the video display 
takes on the color of BAK. This command is not to be entered by the user. 
The display formatter automatically adds this to the end of the display 
list whenever it is moved or activated. 

If the I bit is set, a display list interrupt will occur upon inter- 
pretation by Antic. 

Legal form: 

$41 addr-low addr-hi Transfer display list 

interpretation to addr. (65) 


Display Block Opcodes 


Byte form: 


I 

J 

V 

H 

X 

X 

X 

X 


n = 2 to $F (15) n 


There are 14 display modes. Six are character modes, eight are 
graphic modes. Each of these modes varies greatly and will be discussed 
individually. But first, the four status bits I, J, V, and H, will be 
discussed as they function similarly for all display modes. 

If the I bit is set, a display list interrupt will occur upon 
interpretation by Antic. 

If set, the J bit instructs Antic to perform a display memory jump. 
Antic expects the next two bytes in the display list to point to the new 
display memory location. The first display block instruction should 
always have this bit set. Also, Antic cannot properly retrieve data 
from display memory across 4K boundaries. Thus, if the display memory 
must cross a 4K boundary, a display memory jump must be used. Note that 
the display formatter automatically takes care of these two problems for 
the user. 

If set, the V bit informs Antic that the current display block is 
to be vertically scrolled upward according to the value in VSCROL (address 
$D405). Note that vertical scrolling is accomplished only if two or more 
consecutive display blocks have this bit set. 


XXX 1-7 


val FORTH Display Formatter 1.1 


If set, the H bit informs Antic that the current display block is 
to be horizontally scrolled right according to the value in HSCROL 
(address $D404). Note that for horizontally scrolled display blocks, 
extra bytes of memory are needed. The exact number of bytes varies for 
different screen (playfield) widths. Use the following calculation: 

# extra = X / n 

where: X = the number of characters/display block 

n = 4 for a narrow playfield 
= 5 for a standard playfield 

There are no extra bytes for the wide playfield setting. 

For example, a 40 character/line display block in the standard 
width would use a total of 40 + 40/5 or 48 characters. Note that only 
one of these extra bytes is actually used for the display. 


val FORTH Display Formatter 1.1 


The Character Modes 


There are 6 character modes (opcodes 2 thru 7). All character modes 
work in the same way, i.e., the values in display memory are indices to 
a large "n" by 8 byte array. In some of these modes, the highest one or 
two bits are used to specify a color with only the remaining lower bits 
used for indexing. The following table gives information about each of 
the modes: 


Antic mode 

2 

3 

4 

5 

6 

7 

Basic mode 

0 

— 

— 

— 

1 

2 

# color * 

1.5 

1.5 

5 

5 

5 

5 

Chars/line 
narrow wid 

32 

32 

32 

32 

16 

16 

Chars/line 
normal wid 

40 

40 

40 

40 

20 

20 

Chars/line 
wide screen 

48 

48 

48 

48 

24 

24 

Scan lines/ 
pi xel 

8 

10 

8 

16 

8 

16 

Bits/pixel 

1 

1 

2 

2 

1 

1 

Color clocks 
per pixel 

.5 

.5 

1 

1 

1 

1 


Colors: 


mode 2: Takes the color of PF2 with the Turn of PF1 

(Artifacting/bleed very noticeable) 
mode 3: Same as above 

mode 4: Two bits/pixel in character definitions 

00 = BAK 01 = PFO 10 = PF1 
11 = PF2 if bit 7 of index = 0, else PF3 
mode 5: Same as 4 above 

mode 6: Most significant two bits of index 

0 = PFO 1 = PF1 etc. 
mode 7: Same as 6 above 


XXX 1-9 


val FORTH Display Formatter 1.1 


The Graphic Modes 


There are 8 graphic modes. Unlike character modes, the values in 
display memory are not indices into an array of character definitions, 
but rather are the definitions themselves. Depending on the graphic mode, 
these values give different results. The following table gives various 
information about each mode. 


Antic mode 

8 

9 

A 

B 

C 

D 

E 

F* 

Basic mode 

3 

4 

5 

6 

— 

7 

— 

8 

# colors 

4 

2 

4 

2 

2 

4 

4 

1.5 

bytes/line 
narrow wid 

8 

8 

16 

16 

16 

32 

32 

32 

bytes/line 
normal wid 

10 

10 

20 

20 

20 

40 

40 

40 

bytes/line 
wide screen 

12 

12 

24 

24 

24 

48 

48 

48 

Pixels per 
normal wid 

40 

80 

80 

160 

160 

160 

160 

320 

Scan lines/pixel 

8 

4 

4 

2 

1 

2 

1 

1 

Bits/pixel 

2 

1 

2 

1 

1 

2 

2 

1 

Color clocks 
per pixel 

4 

2 

2 

1 

1 

1 

1 

.5 


*Mode F values differ when in GTIA modes 


Colors: 


mode 8: Two bits/pixel, 4 pixels/byte 

00 = BAK 01 = PFO 10 = PF1 
mode 9: One bit/pixel, 8 pixels/byte 

0 = BAK 1 = PFO 
mode A: Same as mode 8 above 

mode B: Same as mode 9 above 

mode C: Same as mode 9 above 

mode D: Same as mode 8 above 

mode E: Same as mode 8 above 

mode F: Take the color of PF2 and lum of PF1 
(if not in a GTIA mode) 


11 = PF2 


XXXI-10 


val FORTH Display Formatter 1.1 


GLOSSARY 


(DBINIT) 


( dmem dlist — ) 


The (DBINIT) routine initializes the display formatter. It expects 
two addresses on the stack. The address on top of the stack is used as 
the target address for the display list. The address found second on the 
stack is the target address for display memory. The display list is 
actually created in a c-array named DSPLST. Note that while building the 
list, no check is made to ensure that the display list does not cross a IK 
memory boundary. 

DBINIT ( — ) 

Like the (DBINIT) command above, this initializes the display formatter. 
But unlike (DBINIT), this expects no arguments. Instead, these values are 
calculated automatically. The display memory address is top of memory 
minus 1F00 hex. This is enough for a full graphics 8 screen. The display 
list address is 256 bytes below the display memory address. Note that this 
is very memory wasteful, and should only be used while still learning the 
system. After that, (DBINIT) should be used. 

DBPTR ( block* — ) 

This command instructs the display formatter to create the next 
display block in the specified "block#" of the current display list. 

To begin creating a new display list, use: 


The DBM command adds "antic-mode" to the end of the current display 
list. For example, to create a video display with a single line at the top 
of the screen, the following would be executed: 


0 DBPTR 


DBM 


( antic-mode — ) 


0 DBPTR (new list) 

2 DBM (A graphic 0 line) 


DBMS 


(Note: Antic mode 2 is a BASIC graphics 0 line.) 

( #times antic-mode — 

The DBMS command performs a multiple DBM. For example, to create a 
full graphics 0 screen, the following two commands must be performed: 

0 DBPTR (new list) 

24 2 DBMS (24 graphic 0 lines) 

This would create a full graphics 8 screen: 

0 DBPTR 

192 15 DBMS (Antic 15 = graphic 8) 

(192 graphic 8 lines fill one video screen) 


XXXI-11 


val FORTH Display Formatter 1.1 


DBMS (cont'd) 

Mixed lists are also possible: 

0 DBPTR 
160 15 DBMS 
4 2 DBMS 

This would create a screen of 160 graphic 8 lines with four text lines at 
the bottom. 


DBIN ( antic-mode block# — ) 

Oftentimes, it is desirable to slightly change the existing display 
list to obtain special effects midway through a running program. The DBIN 
command allows insertion of new display blocks within the current display 
list. This command inserts "antic-mode" into the block specified by 
"block#". Whatever was in the block "block#" and following is pushed 
back one block. For example: 


block #0 
1 
2 

with the above display list, a 

15 1 DBIN 

would give the following display list. 

Display list 

block # 0 
1 
2 

3 


2 

15 

2 

8 



The DBIN allows the user to create new display lists without the need to 
duplicate already existing display list sections. 


XXX 1-12 


val FORTH Display Formatter 1.1 


c 


o 


DBINS ( #times antic-mode block# — ) 

This command repeats "antic-mode block# DBIN" the specified number 
of times. 


DBDEL ( block# — ) 

The DBDEL command serves as the logical complement to the DBIN 
command. Thus, after inserting a temporary display block, the DBDEL 
command may be used to delete that display block once it is no longer 
needed: 


Display list 

block # 0 
1 
2 
3 

1 DBDEL would give: 




Note: Deleting non-existing display blocks gives unexpected results. 


DBDELS 


( #times block# — ) 


This command performs "block# DBDEL" the specified number of times. 
This serves as the logical complement to the DBINS command. 


c 


XXX 1-13 


val FORTH Display Formatter 1.1 


DBDELL ( ... ) 

This form of the DBDEL command deletes the last display block created 
using the DBM command. For example: 


block # 0 
1 
2 
3 


Displ ay list 


15 


DBDELL would give: 


Display list 

block # 0 
1 
2 



The main use for the DBDELL command is for "backing up" and re-entering 
a display block when an error has been made while creating a display list 
directly at the keyboard. The DBDELL command can be used successively for 
deleting a section of display blocks at the end of the current display list. 
There is no plural command for DBDELL command as its use is rather limited. 

7ANTM0D ( block# — antic-mode ) 

Occasionally, it is desirable to knew what antic-mode is being used 
for a particular display block (such as for a text output routine — text 
should not be output on a hi-resolution line, for example). This command 
returns the antic-mode of the specified block. 

DBMOD ( modifier block# — ) 

When creating display lists, it is possible to give extra meaning to 
a particular block or section of blocks in the list. This is accomplished 
by using one or more of the three available antic-modifiers: vertical 

scroll modifier (VRTMOD), horizontal scroll modifier (HRZMOD), and the 
display-list interrupt (INTMOD). The following are examples of each: 

VRTMOD 0 DBMOD 
HRZMOD 3 DBMOD 
IMTMOD 5 DBMOn 


XXX! M 


val FORTH Display Formatter 1.1 


DBMOD (cont'd) 

There are several methods in which to put more than one modifier on a 
given display block. For example, each of the following would give the 
same final result: 


VRTMOD 20 DBMOD 
HRZMOD 20 DBMOD 


or 


VRTMOD HRZMOD + 20 DBMOD 

To attach all three modifiers, the best method is: 

VRTMOD HRZMOD INTMOD + + 20 DBMOD 

It should also be noted that it is possible to create modified display 
blocks, thus reducing the need for the DBMOD command: 

HRZMOD 2 + DBM 

This would create one graphic 0 line with a horizontal modifier. 

It is also easy to obtain 16 lines of hi-resolution graphics with both 
horizontal and vertical scroll modifiers: 


16 VRTMOD HRZMOD 15 + + DBMS 


CAUTION: VRTMOD and HRZMOD can 

($2-$F). 

(Note: There is one additional 

absolutely forbidden! This has 
in the next release.) 

DBMODL 

This command modifies the 

7DBM0DS 

This returns the modifiers 
example: 

VRTMOD I 


only be used on antic-modes 2 through 15 

modifier, JMPMOD; however its use is 
been defined as it will be implemented 

( modifier — ) 

ast display-block in the display list. 

( block# — modifiers ) 
on the specified display block. For 

+ 0 DBM 
TDBMODS 


would give VRTMOD. Also: 

VRTMOD HRZMOD 2 + + 0 DBM 
0 7DBM0DS 

would give VRTMOD + HRZMOD. To test for VRTMOD, the following method must 
be used: 

0 2DBM0DS 
VRTMOD AND 

The last line leaves only the vertical modifier, if present, or leaves 0 
indicating no vertical modifier. 


XXX I - 15 


val FORTH Display Formatter 1.1 


DBREM 


The DBREM command removes all modifiers from 
block. Care should be taken when stripping mod if 
horizontal modifier (if present) will change f'ne 

DBREMS 


This performs "block" DBREM" ; -r 


DBREML 


This removes the modifiers from re- 
display list. 

7DBVAL 


The 7DBVAL command returns all inf , t *. 
specified, i.e., the antic mode and ar ■ i ' 1 - 
returned as one value. 


DBWID 


The DBWID command is used to set r .ho desired 

the address array DBLST gives the proper .-a I • 

1 - narrow, 2 - normal, and 3 - wide. 

USRDSP 


Once a display list has been created. HFR'-F 0 


MIXED 


The MIXED command performs a UoP.D'. 
system to re-direct all output to the .ids.: 
newly created display list. 

DMPLST 


The DMPLST command instructs the dr' 
complete, informative listing of the 


DBADR 


The DBADR command is one or the urn.-. ‘ 

Given a display block number, it return:, i,.- ; : i.it o 
that display block. This is extremely use. u'l for 
text or graphic displays should be located. 


DMCLR 


The DMCLR command clears the display memory ;> 
list currently being created. It a i-< 


( block# — ) 

the specified display 
iers, as stripping a 
size of the video memory. 

( # times block# — ) 

' r of times. 

( — ) 

■'ay block in the current 


( block# — info ) 

out the display block 
This information is 


( width — ) 

pleyfield width so that 
Legal settings are: 

( — ) 

activates the new list. 

( — ) 

;ructs the Atari operating 
ly memory specified by the 

( — ) 

. assembler to give a 
last created. 

1 block# — address ) 

omnk.rds to the programmer. 
:ss of the first byte of 
determining where output 

( — ) 

ointed to by the display 
c f memory. 


val FORTH Display Formatter 1.1 


In addition, there are various variables available to the programmer: 

DSPEND Points to the end of the current display list. 

It is an offset from 0 DSPLST, 

DSPBLK Contains the number of the next display block to 
be created. Tg 

DMLOC Points to the beginning of display memory. 

LSTLOC Contains the address of where the display list 
is to reside in memory. 

DBLST Is an array of addresses used by DBADR. 

DSPLST Is a byte array containing the display list currently being 
created. DSPEND above points to the end of the list in 
this array. 


XXXI-17 


o 


c 


XXXII. DISPLAY FORMATTER SUPPLIED SOURCE LISTING 


Screen: 3® 

® ( Graph Sys: tables ) 

1 > ( TRANSIENT TRANSIENT ) < ) 

£ BASE @ DECIMAL 


3 

’ ( CTABLE ) ( 

in 

*4- 

KLOAD 

) 



4 









5 

LABEL 

BLKNML 







6 

0 C, 

0 C, 

40 

c, 

40 

c, 

40 

C, 

7 

40 C, 

£0 C, 

£0 

c, 

1® 

c, 

10 

C, 

6 

£0 C, 

£0 C, 

£0 

c, 

4® 

C, 

40 

C, 

9 

40 C, 








10 









11 

CTABLE 

HSOFS 







1£ 

50 C, 

4 C, 

5 

C, 

50 

C, 



13 









14 

TABLE 

BLKOFS 







15 

50 , 

-5 , 50 

1 , 

5 






Screen: 31 

0 < Graph Sys: variables ) 

1 

£ CTABLE BYTBLK 16 ALLOT 
3 BLKNML 0 BYTBLK 16 CMOVE 
A 


5 

£55 

CARRAY 

DSPLST 

6 

£55 

ARRAY 

DBLST 

7 

5 

VARIABLE 

HS#/ 

8 

0 

VARIABLE 

DSPBLK 

9 

0 

VARIABLE 

PGECRS 

10 

0 

VARIABLE 

DSPEND 

11 

0 

VARIABLE 

NWLST 

1£ 

6 

VARIABLE 

SDTMP 

1 3 

0 

VARIABLE 

DBCNT 

14 

0 

VARIABLE 

DBVRT 

15 





Screen: 3£ 

0 ( Graph Sys: 

constant 

1 

£ 

HEX 

0 

VARIABLE 

DMLOC 

3 

0 

VARIABLE 

LSTLOC 

4 

5 

10 

CONSTANT 

HRZMOD 

6 

£0 

CONSTANT 

VRTMOD 

7 

40 

CONSTANT 

JMPMOD 

8 

80 

CONSTANT 

INTMOD 

9 

10 

DECIMAL 


1 1 

1£ 

11 

CARRAY 

JMPDAT 

13 

10 

CARRAY 

JMPSTT 

14 

15 

0 JMPDAT 1 1 

ERASE 


Screen: 33 


0 

1 

( Graph Sys: 

CDBINIT1 DBINIT 

) 

£ 

3 

: (DBINIT) 

< DM LIST — 

) 

4 

LSTLOC ! 

DUP 


5 

DMLOC ! 

0 DBLST ! 


6 

0 DSPEND ! 

0 PGECRS ! 


7 

0 DSPBLK ! 

1 NWLST ! 


8 

0 JMPDAT 11 

ERASE ; 


9 




10 

: DBINIT 

< — 

) 

11 

106 C® £56 

* 7936 - 


1£ 

DUP £56 - 



13 

(DBINIT) ; 



14 




15 

DBINIT 

— 

> 


Screen: 34 




0 

( Graph Sys: 

HINYB EODB 

) 

1 

DECIMAL 




£ 





3 

: HINYB 

( nmrnm — n 

) 

4 

61440 AND 

4096 / 16 

+ 15 AND 

; 

5 





6 

: EODB 


( n — a 

> 

7 

31 AND DUP 

15 AND ( 

F i rid end ) 

8 

BYTBLK C® 

SWAP ( 

of disp 

> 

9 

15 > 

( 

block ) 


10 

IF 

< Horz 

. scroll 

> 

11 

DUP HS#/ 

0 / + 



1£ 

END IF 




13 

DSPBLK 0 

< Update the ) 


14 

DBLST 0 

< addr 

1 i st ) 


15 

+ 1- ; 


== 

> 


Screen : 35 

0 < Graph Sys: DBPTR ) 

1 

£ : DBPTR < blk# -- ) 

3 DMLOC ® 0 DBLST ! 

4 0 PGECRS ! 0 NWLST ! 

5 DUP DSPBLK ! DUP DSPEND ! 

6 0 JMPDAT C0 -DUP 

7 IF 1+ 1 DO 

8 I JMPDAT C0 OVER < 

9 IF 

10 £ DSPEND + ! 

1 1 ELSE 

1£ 11-0 JMPDAT C! LEAVE 

13 END IF 

14 LOOP 

15 END IF DROP --> 


Screen : 36 

S ere 

<_■ n - : 2 





0 < 
1 

Graph Sys: JMPINS DBPTR ) 

0 

4 

Graph Sys: 

DBM 


> 

1 

£ 

DSPEND 0 DSPBLK 0 = 

£ 

: DBM 



( n — 

> 

3 

IF 

3 

DUP 15 OND 





4 

1 NWLST ! 

4 

TP 

( 

antic 

instr. ? 

) 

5 

ELSE 

rr 

191 OND 

< 

strip 

jump 

> 

6 

DSPBLK 9 DBLST 0 

£ 

DBCRT 





7 

1- HINVB PSECRS ! 

—} 

else 


( scan 1 i nes 

) 

B 

END IF ; 

B 

DSPEND 9 





9 


z 

DSPLST C 

i 




10 S 

JMPINS ( n — ) 

10 

1 DSPEND 

+ ! 




11 

DUP JMPMOD OR 

1 1 

DSPBLK 9 

DUP 

DBLST 

£ 


12 

DSPEND 0 SWOP OVER 

12 

SWOP 1+ DBLST 

* 



13 

DSPLST Cl 1+ NWLST 9 

13 

1 DSPBLK 

+ ! 




14 

IF 

14 

END IF ; 





15 

0 NWLST I ==> 

« rr 




— 

■> 


Screen: 37 


Scree; 

40 



0 ( 

Graph Sys: JMPINS 

) 

0 ( 
< 

Graph Sys: LSTSV 


> 

1 

£ 

DMLOC 0 DUP DUP 40 + 


* 

LSTSV ( 

blk# -- a 

> 

3 

HINYB SWOP HINYB <> 


3 




4 

IF 


4 

DSPEND 0 ( 

pt to blk 

) 

5 

HINYB 1+ 4096 * 


5 

DSPLST 65 OVER C! 



6 

END IF 


6 

SWOP DBPTR 



7 

ELSE 


7 




8 

PGECRS 9 4096 * 


8 

DSPEND 9 DSPLST ( 

save list 

> 

9 

END IF 


9 

DUP SDTMP 9 + ROT 



10 

DUP ROT DSPLST ! 


10 

> R OVER R> - 



11 

3 DSPEND +! 


1 1 

OBS 1+ <CMOVE 



12 

DSPBLK 0 0 JMPDOT C0 1+ 


12 




13 

DUP 0 JMPDOT C! 


13 

DSPEND 9 DSPLST ( 

leave save) 

14 

JMPDOT C I i 


i ' s 

SDTMP 0 + ; ( 

address ) 


15 


— > 

15 


== 

> 


Screen: 38 

Scrti- 

e n ; 4 i 



0 ( 
1 

Graph Sys: DBCRT ) 

0 

! Graph Sys: 

LSTRST 

) 

1 

£ : 

DBCRT ( n — ) 

£ 

: LSTRST 


( a — ) 

3 

DUP EODB DUP 

3 

BEGIN 



4 

HINYB PGECRS 0 

4 

DUP C0 DUP 

65 <> 

< eolst?) 

5 

OVER PGECRS ! <> 

5 

WHILE 



6 

IF 

6 

DUP 15 OND 

0 # 


7 

DROP JMPINS 

7 

OVER 64 OND 0# OND 


8 

DSPBLK 0 DBLST ! EODB 

.‘r. 

* «r 


( jump? ) 

9 

ELSE 

3 

191 AND 

DBM 3 + 


10 

SWOP DSPEND 0 

i 7 , 

ELSE 

< 

normal ) 

11 

DSPLST C! 

X 

DBM 1 + 



12 

1 DSPEND + ! 

13 

ENDIF 



13 

END IF 

13 

REPEAT 



14 

1+ DSPBLK 1 OVER +! 

14 

2 r .»RQP ; 



15 

0 DBLST 1 ; =■--> 

1 



— > 


Screen : 42 

C ( Graph Sys: DBIN DBDEL DBMOD ) 


1 


2 : 

DBIN 

( 

n 

n — ) 

3 

LSTSV SWAP DBM LSTRST 

5 


4 





5 : 

DBDEL 


( 

n — ) 

6 

DUP 1+ LSTSV SWAP 




7 

DBPTR LSTRST ; 




B 





9 : 

DBMOD 

( 

n 

n — ) 

10 

DUP 1 + LSTSV 




11 

SWAP DBPTR SWAP 




12 

DSPEND 0 DSPLST 00 

OR 



13 

DBM LSTRST 5 




14 





15 




==> 


Screen: 43 

0 ( DBREM DBDELL DBMODL DBREML ) 

1 

2 : DBREM < n — ) 

3 DUP 1+ LSTSV 

4 SWOP DBPTR 

5 DSPEND @ DSPLST C0 

6 15 AND DBM LSTRST ; 

7 


a : DBDELL < — > 

9 DSPBLK 0 1- DBPTR 5 
10 

11 : DBMODL ( — > 

12 DSPBLK 0 1- DBMOD ; 

13 

14 : DBREML < — > 

15 DSPBLK 0 1- DBREM ; — > 


Screen: 44 

0 ( Graph Sys: 7DBVAL ) 

1 

2 : 7DBVAL < n — > 


3 DSPBLK 00 0 JMPDAT 00 

4 ROT DBPTR 

5 DSPEND 0 DSPLST 00 

6 <ROT 0 JMPDAT C! 

7 DBPTR ; 

B 

3 

10 

11 

12 

13 

14 

15 ==> 


Scrsfifi s 45 

0 ( Graph Sys: 7ANTM0D 7DBM0DS ) 

1 

2 : 7ANTM0D < n — ) 

3 7DBVAL DUP 15 AND 0 = 

4 IF 127 ELSE 15 END IF 

5 AND ; 

6 

7 : 7DBM0DS ( n — ) 

8 7DBVAL DUP 15 AND 0= 

9 IF 

10 DROP 0 

1 1 ELSE 

12 240 AND 

13 END IF 5 

14 

15 --> 


Screen: 46 

0 ( Graph Sys: DBMS DBDELS ) 

1 

2 : DBMS ( # n — ) 

3 SWAP 0 

4 DO 

5 DUP DBM 

6 LOOP 

7 DROP ; 

8 

9 : DBDELS ( # n — ) 

10 SWAP 0 

11 DO 

12 DUP DBDEL 

13 LOOP 

14 DROP ; 

15 ==> 


Screen: 47 

0 ( Graph Sys: DBREMS > 

1 

2 : DBREMS ( # n — ) 

3 SWAP 0 

4 DO 

5 DUP DBREM 1+ 

6 LOOP 

7 DROP ; 

8 
9 

10 

11 

12 

13 

14 

15 — > 


Screen: 48 

8 ( Graph Sys: 
1 


DBINS 


rreen: 51 

0 < Graph Sys: DMPLST 




2 

: 

DBINS 

< # n n — ) 

o 

: DMPLST 

3 


ROT DUP DBCNT ! 


3 

CR DSPBLK 0 -DUP 

4 


6 + SDTMP 0 SWAP SDTMP ! 

4 

IF 

5 


<ROT DUP LSTSV 


5 

CR . " BLK ADDR" 

6 


SWAP DBPTR SWAP 


£ 

BYTE MODS" 

7 


BEGIN 



rfj _ » ii 

a 


DBCNT @ 

( count zero? ) 

z 

, " n 

9 


WHILE 



0 DO 

10 


DUP DBM ( 

keep creating) 

1 

CR I 3 . R 

u 


-1 DBCNT + ! ( 

dec. counter ) 

1 ! 

I DBLST 0 9 U. R 

12 


REPEAT 


12 

I 7ANTM0D 8 U. R 

13 


DROP LSTRST < 

unsave list ) 

13 

I 7DBM0DS -DUP 

14 


SDTMP ! ; 


1 4 

IF 

15 



==> 

1‘j 

3 SPACES 

Screen: 49 


Sc.-'-*? 

en: 52 

0 

1 

< 

Graph Sys: SCRWID LSTMV ) 

0 

( Graph Sys: DMPLST 

c! 

* 

SCRWID 

( width — ) 

1. 

Zr 

DUP 128 AND 

3 


559 C0 £52 AND 


3 

IF . ” I" END IF 

4 


OR 559 C! ; 


4 

DUP 32 AND 

5 




5 

IF . " V" END IF 

6 

: 

LSTMV 

< — ) 

6 

DUP 16 AND 

7 


LSTLOC 0 DSPEND 

0 

~j 

IF . " H“ END IF 

8 


DSPLST 65 


8 

64 AND 

9 


OVER C! 1+ ! 


9 

IF . " J " I DBLS 

10 


0 DSPLST LSTLOC 

0 

1© 

ENDIF 

11 


DSPEND 0 CMOVE : 

i 

11 

ENDIF ?EX IT 

12 




12 

LOOP 

13 




13 

ELSE 

14 




14 

. " No display list” 

15 




15 

ENDIF CR ; 

Screen: 50 


Sc H 

en : 53 


— > 


o 


0 

1 

2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


( Graph Sys: USRDSP MIXED 


USRDSP 
LSTMV 
559 C0 3 
0 SCRWID 
LSTLOC 0 
SCRWID : 


( — ) 


PND 

560 


MIXED 

DMLOC e 88 
USRDSP : 


( — 


1 3 


13 
i 4 


( Graph Sys: DMCHG DMCLR DBPDR ) 

: DMCLR ( — ) 

DMLOC 0 
10S 0 256 * 

OVER - 
ERASE ; 


:;bpdr 

DEL ST 0 ,• 


< blk# — a ) 


c 




— > 


Screen: 54 Screen: 57 

0 ( VAL-FORTH GRAPHIC SYSTEM 1.1) 0 

1 1 

£ : DBWID ( width — ) £ 

3 0 LSTSV SWAP BLKNML 3 

4 C 0 BYTBLK ] LITERAL 4 

5 16 CMOVE 5 

6 BLKOFS ® C 0 BYTBLK 16 6 

7 OVER + 3 LITERAL LITERAL 7 

8 DQ 8 

9 I C® DUP 3 PICK / + I C! 9 

1® 1 /LOOP 10 

11 HSOFS C® HS#/ ! 11 

IE LSTRST ; 1£ 

13 13 

14 M PERMANENT PERMANENT ) ( ) 14 

15 BASE ! 15 


Screen: 55 Screen: 58 

0 0 

1 1 

£ £ 

3 3 

4 4 

5 5 

6 6 

7 7 

8 8 

9 9 

10 10 

11 11 

1 £ 1 £ 

13 13 

14 14 

15 15 


Screen : 56 

0 
1 


4 

5 

6 

7 

8 
9 

10 

11 

1 £ 

13 

14 

15 


Screen: 59 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

1® 

11 

1 £ 

13 

14 

15 


c 


Screen : 60 


0 

< Transients: setup ) 

O 

1 

BASE 

0 DCX 

1 

£ 



3 

3 

HERE 


3 

4 



4 

rr 



c 

J 



«-•' 

6 

741 C- 4000 - DP ! 

6 

7 

< SUGGESTED PLACEMENT OF TAREA ) 

7 

8 



a 

9 



g 

10 

HERE 

CONSTANT TAREA 

10 

11 

0 

VARIABLE TP 

i 1 

1 £ 

1 

VARIABLE TPFLAG 

12 

13 


VARIABLE OLDDP 

i 7 

14 



14 

15 


==> 

15 


n : 63 


Screen: 61 



Scree 

0 < 

Xsients: TRANSIENT 

PERMANENT 

) 


1 

2 • 

TRANSIENT 

( — 

) 

i 

3 

TPFLAG 0 NOT 



3 

4 

IF HERE OLDDP ! TP 

0 DP ! 


4 

5 

1 TPFLAG ! 



c.- 

6 

END IF 5 



C 

7 




7 

a : 

PERMANENT 

( — 

) 

8 

9 

TPFLAG 0 



9 

10 

IF HERE TP ! OLDDP 

0 DP ! 


10 

11 

0 TPFLAG ! 



1 1 

1£ 

END IF ; 



1 £ 

13 




13 

14 




1 '■ 

15 


— 

-> 

15 


© 


Screen : 6 £ 

0 < Transients: DISPOSE ) 

1 : DISPOSE PERMANENT 

£ CR . " Disposing. . . " VOC-LINK 

3 BEGIN DUP 0 53£79 C! 

4 BEGIN 0 DUP TAREA U< 

5 UNTIL DUP ROT ! DUP 0= 

6 UNTIL DROP VOC-LINK 0 

7 BEGIN DUP 4 - 

8 BEGIN DUP 0 53£79 C! 

9 BEGIN PFA LFA 0 DUP TAREA U< 

10 UNTIL 

11 DUP ROT PFA LFA ! DUP 0= 

1£ UNTIL DROP 0 DUP 0= 

13 UNTIL DROP CCOMPILEI FORTH 

14 DEFINITIONS . " Done" CR ; 

15 PERMANENT BASE ! 


Scr?;~r, : 65 

0 


5 

S 

7 

g 

9 

10 



1 3 
1 4 
15 


o 


o 


Screens 66 thru 89 are blank 


Screen : 90 



Screen: 93 

0 

( Utils: CARRAY ARRAY 

) 

0 

( 

Utils: XC! X! 

1 

BASE 0 HEX 



1 



2 

: CARRAY 

( cccc, n — 

) 

£ 

: 

XC! ( n0. . ■ nrn cnt addr — 

3 

CREATE SMUDGE ( cccc: n — 

a > 

3 


OVER 1- + >R 0 

A 

ALLOT 



A 


DO J I - C! 

5 

;CODE CA C, 

CA C, 18 C, 


5 


LOOP R> DROP ; 

8 

A5 C, W C, 

69 C, 02 C, 95 

c, 

6 



7 

00 C, 98 C, 

65 C, W 1+ C, 


7 

: 

X ! ( n0. . . nrn cnt addr — 

8 

95 C, 01 C, 

AC C, 


8 


OVER 1- 2* + >R 0 

9 

» + ( CFA 0 

) , C; 


9 


DO J I 2* - ! 

10 




10 


LOOP R> DROP 5 

11 

: ARRAY 

< cccc, n — 

) 

11 



12 

CREATE SMUDGE ( cccc: n — 

a ) 

12 

( 

Caution: Remember limitation 

13 

2* ALLOT 



13 

( 

on stack size of 30 values 

1A 

;CODE 16 C, 

00 C, 36 C, 01 

c,) 

1A 

( 

because of OS conflict. ) 

15 

AC C, > CARRAY 08 + , C; 


15 


— 


Screens 91 

0 < Utils: CTABLE TABLE ) 

1 


£ 

: CTABLE 

( cccc, — ) 


3 

CREATE SMUDGE 

( cccc: n — 

a ) 

A 

;CODE 



5 

AC C, ’ CARRAY 

08 + , C; 


6 




7 

: TABLE 

( cccc, — ) 


8 

CREATE SMUDGE 

< cccc: n — 

a ) 

9 

:CODE 



10 

AC C, » ARRAY 0A + , C: 


11 




12 




13 




1A 




15 



— > 


Screen s 9A 

0 ( Utils: CVECTOR VECTOR 

1 

£ : CVECTOR ( cccc, cnt — 

3 CREATE SMUDGE ( cccc: n — a 

A HERE OVER ALLOT XC! 

5 ;CODE 

6 AC C, ’ CARRAY 08 + , C; 

7 

8 : VECTOR < cccc, cnt — 

9 CREATE SMUDGE ( cccc: n — a 

10 HERE OVER £* ALLOT X! 

11 ;CODE 

1£ AC C, ’ ARRAY 0A + , C; 

13 

1A 

15 BASE ! 


) 

> 

) 


o 


) 

) 


Screen : 92 

0 ( Utils: 2CARRAY 2ARRAY ) 

1 

£ : 2CARRAY ( cccc, n n — ) 

3 (BUILDS ( cccc: n n — a ) 

A SWAP DUP , * ALLOT 

5 DOES) 

6 DUP >R <? * + R> + 2 + - 

7 

8 : 2ARRAY < cccc, n n — ) 

9 (BUILDS ( cccc: n n — a ) 

10 SWAP DUP , * 2* ALLOT 

1 1 DOES) 

12 DUP >R 0 * + 2# R> +2+ ; 

13 
1A 

15 ==> 


Screen: 95 

0 
1 
2 
3 
A 

5 

6 
7 

a 

9 

10 

u 

12 

13 

1A 

15 


c 


o 


Screens 96 thru 167 are blank 


Screen: 168 Screen 

® 0 

1 1 

£ £ 

3 3 

4 4 

5 5 

6 6 

7 7 

a 8 

9 g 

10 10 

11 11 

1 £ 12 

13 13 

14 14 


Screen: 169 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

1£ 

13 

14 

15 


Screen : 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

1£ 

13 

14 

15 


Screen: 170 

0 CONTENTS OF THIS DISK: 

1 

£ DISPLAY FORMATTER: 30 LOAD 

3 TRANSIENTS: 60 LOAD 

4 ARRAYS & THEIR COUSINS: 90 LOAD 

cr 


6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen : 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


171 


172 


173 


Screen: 174 
0 
i 


4 

5 

6 

7 

8 
9 

10 

11 

1£ 

13 

14 

15 


Screen: 177 

0 Disk Error ! 

1 

£ Dictionary too big 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
1£ 

13 

14 

15 


Screen: 175 
0 
1 


4 

5 

6 

7 

8 
9 

10 
1 1 
1£ 

13 

14 

15 


Screen: 178 

0 ( Error messages 

1 

£ Use only in Definitions 

3 

4 Execution only 

5 

6 Conditionals not paired 

7 

8 Definition not finished 

9 

10 In protected dictionary 

1 1 

1£ Use only when loading 

13 

14 Off current screen 

15 


Screen: 176 

0 ( Error messages 

1 

£ Stack empty 

3 

4 Dictionary full 

5 

6 Wrong addressing mode 

7 

8 Is not unique 

9 

10 Value error 

1 1 

1£ Disk address error 

13 

14 Stack full 

15 


Screen: 179 

) 0 Declare VOCABULARY 

1 
2 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
1£ 

13 

14 

15 


o 


o 


c 




■■■ I VALPAH 
INTERNATIONAL 

3801 E. 34 th STREET 
TUCSON, ARIZONA B5713 
608-730-7141 



i ralFORTH 

T.M. 

SOFTWARE SYSTEM 

for ATARI* 


infill w 

mm advamhutcu 

ffLOA'filNti PCHN'i’ tturilNteS 


s 


* 


Atari is a trademark of Atari, Inc., a division of Warner Communications. 


Software and Documentation 
©Copyright 1982 
Valpar International 


a>nr><' 


c 


o 


Cj 


valFORTH 

T.M. 

SOFTWARE SYSTEM 


f UMTLS 1 valilAPHiei 
AMO ADVANCiD 
FLOATING POINT lOUTIMSS 


DRAWL N ROUTINES 
ARMADILLO GRAPHICS 
QUAN STRUCTURES 


Stephen Maguire 

Evan Rosen, William Volk 

Evan Rosen 


Software and Documentation 
©Copyright 1982 
Valpar International 


Purchasers of this software and documentation package are 
authorized only to make backup or archival copies of the 
software, and only for personal use. Copying the accompany- 
ing documentation is prohibited. 

Copies of software for distribution may be made only as 
specified in the accompanying documentation. 


c 


o 


L> 


VALPAR INTERNATIONAL 


Disclaimer of Warranty 
on Computer Programs 


All Valpar International computer programs are distributed 
on an "as is" basis without warranty of any kind. The total 
risk as to the quality and performance of such programs is with 
the purchaser. Should the programs prove defective following 
their purchase, the purchaser and not the manufacturer, distributor, 
or retailer assumes the entire cost of all necessary servicing or 
repair. 


Valpar International shall have no liability or responsibility 
to a purchaser, customer, or any other person or entity with 
respect to any liability, loss, or damage caused directly or 
indirectly by computer programs sold by Valpar International. 

This disclaimer includes but is not limited to any interruption 
of service, loss of business or anticipatory profits or conse- 
quential damages resulting from the use or operation of such 
computer programs. 

Defective media (diskettes) will be replaced if diskette(s) 
is returned to Valpar International within 30 days of date of sale 
to user. 

Defective media (diskettes) which is returned after the 30 day 
sale date will be replaced upon the receipt by Valpar of a $12.00 
Replacement Fee. 


c 


c 


val GRAPHICS 1.2 AND QTRIG USER'S MANUAL 


Table of Contents 

Page 

XLI. val GRAPH ICS 

a) Overview 2 

b) Strolling Through valGraphics 

(Walking the Armadillo) 5 

c) Strolling Through valGraphics, II 

(Windows, Lines, and Labeling) 14 

XLI I. valGRAPHICS GLOSSARIES 

a) General Functions 1 

b) Windows and Coordinate Systems ..... 7 

c) Options 10 

d) Screen Dump 14 

e) Interfacing to Custom Display Lists 15 

f) A Note on QUAN Structures 16 

XL III. QUICK TRIG 

XLIV. valGRAPHICS SUPPLIED SOURCE LISTING 


( 


C) 


(J 



Version 1.2 
July 1982 


Many different approaches to creating "computer graphics" are possible, and, 
indeed, many have been implemented. One of the most fruitful approaches, parti- 
cularly for two-dimensional graphics work, is a system usually called "turtle 
graphics." The valGraphics package is a turtle-like system patterned after the 
ATARI PILOT turtle graphics rendition, though with many significant extensions. 


XL I - 1 


Software and Documentation 
©Copyright 1982 
Valpar International 


Overview 


Turtle geometry was originally developed at MIT by Dr. Seymour 
Papert and the LOGO group there. Since that time, a variety of 
different computer-based applications have been said to support 
"turtle graphics," though in general they differ in various ways 
from the initial LOGO formulation. The formulation adopted for this 
package follows the ATARI PILOT turtle graphics nomenclature where 
possible. In general, commands in this package are much smarter than 
their PILOT counterparts, but have also been made friendly so that in 
their default modes they are functionally similar to PILOT commands. 
Because this package differs from "true" turtle graphics in many ways, 
it is called "armadillo graphics." 

Some minor changes have been made in the names of a few ATARI 
PILOT commands because of collisions with existing valFORTH names. 
Important variations are listed here: 


PILOT 

val Graphics 

CLEAR 

WIPE (CLEAR exists) 

FILL 

PHIL (FILL exists) 

FILLTO 

PHILTO (for consistency) 

QUIT 

(not needed and exists) 

PEN ERASE 

0 PEN (ERASE exists) 

LOCATE 

LOOK (LOCATE exists) 


It should be mentioned that for this package, virtually the entire 
set of ATARI operating system graphics functions have been replaced by 
much faster (approximately 6 times) and much smarter graphic routines. 
Highlights of these improvements are: 

* The PHIL and PHILTO functions allow filling to the left and/or 
right, filling across areas already filled, filling until a 
specific color is hit, filling until a specific color is not hit 

( i . e . , re-filling), filling until hitting a set boundary regardless 
of what lies in the way, filling by either replacement or exclusive 
OR'ing, and filling into or out of corners without artifacting. 

* The DRAW and DRAWTO functions allow drawing by either replacement 
or exclusive OR'ing, drawing until hitting a specified color, 
drawing until a specific color is not hit. Additionally, lines 
are more symmetric, and optional starting point plot is supported 
(the Atari routines never plot the first point of a line). 

* All line drawing and fill routines allow plotting in wide and narrow 
screen width settings as well as normal ones, allowing true full 
screen graphics and memory conservative graphics, for the advanced 
programmer. 


XL 1-2 


* Graphic mode 7+ ("7 and a half") is fully supported and is activated 
like any other graphic mode by using the GR. command and standard 
options. This mode is the four-color high-resolution graphic mode 
found in most of the better video games available for the Atari 
computers. (Antic mode 14.) 

* Display windowing and clipping is full supported. Options include 
"machine specific" coordinates for speed and "scaled" coordinates 
for portability. 

* TURNTWD (turn toward) and 2LNX (two line intersection) commands are 
available allowing simplified perspective drawing. 


Although the Atari 400/800 computers have extensive graphic capabilities 
the need to keep the ROM operating system under 10K apparently forced Atari 
to omit the highest resolution color graphic mode (graphic mode 7+) and allowed 
only inefficient draw and fill routines to be implemented. Since this severely 
limited the usefulness of the computer for plotting, both of these problems have 
been corrected. 


A New Graphic Mode 

Many of the better video games for the Atari 400/800 computers use 
a color graphic mode not supported in BASIC. By redefining the GR. 
command, it was possible to implement this previously unavailable mode. 

This new graphic mode, which in this package is called graphic mode 12, 
is similar to graphic mode seven. The difference is that a pixel ( a 
single dot) in graphic 12 is half as tall as the same pixel in graphic 
mode 7. This mode is activated in the same manner as other graphic 
modes: 


12 GR. 

All options ti.e., split/full screen etc.) available for other 
modes will work with this new mode. In the split screen graphics 
12 mode, there are 160 horizontal by 160 vertical pixel locations. 

In the full screen mode, there are 160 horizontal by 192 vertical 
locations. Rote that to use this mode the val Graphics package must 
be loaded and the new draw routines must be used (the operating system 
routines fail in this mode). 


Draw and Fill Routines 


Because the line and fill routines in this package represent 
significant enhancement to the original operating system routines, 
an explanation of the why's and how's of this implementation is 
offered in the following. 


XL 1-3 


It was first decided that the line-drawing routines must be speeded 
up so as to at least be in the class of routines of other 8 bit graphic 
machines. Because of the differing bit structures in the various graphics 
modes, these routines take up about 1000 bytes of memory. This was deemed 
a reasonable tradeoff. Since a complete rewrite had thus been elected, 
the opportunity was taken to expand the versatility of the routines, 
trading a small portion of the speed increase already gained. Several 
capabilities were deemed desirable and were implemented: 

* As mentioned above, the draw routines work in graphics mode 12. 

* Assuming that display memory has been properly laid out, the draw 
routines work in wide and narrow screen widths as well as the normal 
ones. 

* The draw and fill functions, at user option, XOR rather than replace 
pixels in display memory so that new images can be written over back- 
ground images. (Images are then erased by rewriting, restoring the 
background image.) 

* The draw and fill functions can detect a variety of conditions so as 
to allow concepts like "draw until" and "draw until not" as well as 
"fill until" and "fill until not." 

* The fill function allows the edge color and the surface color to be 
different, at user option, with the default setting that they are 
the same. 

* The fill function allows filling to the left, right, or both 
simultaneously, at user option. 

* Fills are able to start from and pass through corners without 
artifacting, at user option. (Implemented for vertical draw only.) 

* Simple initialization of draw functions for custom display lists 
is provided. 

These features were implemented and will be described shortly. 



o 


o 


XL I -4 


STROLLING THROUGH val GRAPHICS 


Walking the Armadillo 


To get started, insert your valGraphics disk and load in the armadillo 
package and all optional graphics packages ("+'s") (including the demos). 

It would even be a good idea to SAVE a copy of this system in case you 
crash later on. (Insert a formatted disk and type SAVE.) The load 
addresses may be found on screen 170 of the disk. Note that you do not 
need, and probably won't want, to first load the graphics package provided 
on your valFORTH 1.1 disk. Note also that as these packages load, some 
load comments may be reported as "xxxx Is not unique" and can be ignored. 
This message simply states that a word has just been defined with the 
same name as an already existing word. 

When plotting in BASIC, location (0,0) is in the upper lefthand 
corner of the video display. All horizontal and vertical positions to the 
right and down are referenced with positive offsets from the (0,0) point. 
Armadillo graphics uses a somewhat different method to specify a location. 

In armadillo graphics, the point (0,0) is located in the cent-r of 
the display. Horizontal locations to right are referenced with positive 
offsets from this point, while locations to the left are referenced using 
negative offsets. Likewise, locations higher on the screen from the origin 
are referenced with positive vertical offsets while those lower on the 
screen are referenced using negative ones. Since this setup follows the 
standard cartesian coordinate system, function plotting is greatly simpli- 
fied. 


0 ° 

(360°) 
+ Y 


270° - X 

(-90°) 


+ X 90° 
(-270°) 


- Y 
180° 
(-180°) 


Let's take a look at 


the basic armadillo graphic commands. 


Type: 


8 GR. ON ASPECT 


XLI-5 


This will put the system into graphic mode 8 with the armadillo positioned 
in the center of the display facing upward (0 degrees). The "dimensions" of 
the display are 320 pixels wide and 160 pixels high. The boundaries are set 
from -159 to 159 left-to-right, and 79 to -79 top-to-bottom. (The lowest 
line of pixels and the furthest right are excluded for code symmetry and 
shortness.) The command "ON ASPECT" will be explained later, but basically 
it ensures that squares will look like squares and not like rectangles (as 
in BASIC). First let’s turn the armadillo to the right. To change its 
direction, we use the TURN command: 


This command turns the armadillo clockwise by 90 degrees from its current 
direction. To draw a line (and move) the armadillo, the DRAW command can 
be used. Try this: 

30 DRAW 90 TURN 50 DRAW 

A short line should have been drawn toward the right -- 30 steps in the 
direction the armadillo was facing. The 90 TURN command was then used 
to aim the armadillo downward, and 50 steps in that direction were taken. 
The DRAW command moves the armadillo the specified number of steps in the 
direction that it is facing. Note that a negative step count tells the 
armadillo to draw in the direction opposite that in which it faces. It. 
is also possible to move the armadillo to a specified point on the screen 
regardless of which direction it is facing. The DRAWT0 command is used 
for this: 


0 -60 DRAWTO 0 TURNTO 

Although the armadillo was facing down, it moved directly to the 
point (0,-60). Note that although it moved diagonally, it still is 
facing directly downward (to 180 degrees). The TURNTO command is used 
to face the armadillo in the specified direction regardless of where 
it is currently facing. In this case, the armadillo is turned to face 
0 degrees. 

In addition to drawing lines as it moves, the armadillo can fill 
in areas of the display. The PHIL command is used for this purpose 
and functions very much like the DRAW command. (FILL is already 
defined and if used mistakenly for PHIL, the system will probably 
crash.) Try this: 


20 PHIL 

This commands the armadillo to take 20 steps in its current direction 
filling the surface area to its right as it goes (the area to the left 
can be filled also -- more on that later). Similar to the DRAWTO command, 
there is also a PHILTO command which works just like PHIL except that the 
armadillo moves to a specified point regardless of the direction it is 
currently facing. To PHIL to the origin (0,0), use: 

0 0 PHILTO 

The PHILTO command should have filled straight up to the point (0,0). 


XL I -6 


So far, we have used the TURN, TURNTO, DRAW, DRAWTO, PHIL, and PHILTO 
commands. These are the basic "drawing" words, used constantly, when work- 
ing with armadillo graphics. You will encounter times when you need to 
move the armadillo without drawing a line between its starting point and 
its destination point. There are four similar commands which allow this. 

The GO, GOTO, GO., and GOTO. All reposition the armadillo without drawing 
a line. The GO and GOTO commands function like DRAW and DRAWTO respectively; 
however, the armadillo is placed at the position where the last dot of the 
plotted line would have been and no line is drawn. GO. and GOTO, function 
like GO and GOTO; however, a single point is plotted at the destination 
point. Try this: 

-30 0 GOTO. 180 TURNTO 

10 PHIL 10 GO 10 PHIL 10 GO 10 PHIL 

0 -60 DRAWTO 

After entering the above, type FRAME to frame this picture. If all went 
well, your display should look like: 


o 



c 


XL I - 7 


Let us now explore the new graphic 12 mode. In this mode, there 
are four colors numbered zero to three. When the armadillo is moved, 
there must be some way to specify which color to DRAW with. The PEN 
command is used for this purpose. Enter the graphic 12 mode by typing: 

12 GR. ON ASPECT 

The GR. command automatically sets the draw color to one (usually 
red). Let's draw some colored lines now: 

10 DRAW (draw in color 1) 

2 PEN 10 DRAW (draw in color 2) 

3 PEN 10 DRAW (draw in color 3) 

You should now have a vertical red, green, and blue line. Note that 
color 0 is black (actually background) and is used primarily for erasing 
lines. Besides setting the draw color, the PEN command also sets the 
PHIL color. 


-50 0 GOTO 45 TURN 

2 PEN 10 PHIL 

After positioning the armadillo in a good position for filling, the draw 
and fill color is set to 2 (usually green) and 10 steps are taken. By 
using PHPEN conmand, it is possible to set the PHIL color to something 
other than the PEN color. PHPEN stands for "phil-pen" and is used in 
the same manner as the PEN command: 

3 PHPEN 32 PHIL 

Note how the edge line remains the color set by the last PEN command, 
while the PHIL command uses the color set by the last PEN or PHPEN 
(whichever came last) command. The PHIL color is always set by the PEN 
command for convenience. Experiment with this a bit. 

To clean the current display, the WIPE command is used. Usually 
after wiping the display, the armadillo is repositioned to the center of 
the screen using either the CENTER or CENTERO conmand. The CENTER command 
simply does a "U 0 GOTO" while the CENTERO command does a "CENTER 0 
TURNTO". 

WIPE CENTERO 

Either right or left filling can be performed, as well as both 
simultaneously. The two commands RPHIL and LPHIL take an ON/OFF value 
and instruct the next PHIL or PHILTO command to take appropriate action. 
The default setting is "ON RPHIL" and "OFF LPHIL". The command DINIT will 
return all settings to their default values. This is especially valuable 
when learning, as it is easy to get fouled up . Type in the following set 
of commands and observe what happens: 

50 50 PHILTO 

CENTER OFF RPHIL ON LPHIL 
-50 50 PHILTO 

CENTER ON RPHIL 1 PEN 

40 PHIL 


XL 1-8 


This demonstration first shows right filling, then left filling, 
and then simultaneous right/left filling. Note that although there was 
nothing on the screen to halt the right/left fills, they still stopped 
upon hitting the edge of the display. In fact, by using windows (which 
will be described later), fill boundaries can be set anywhere on the 
screen and fills will never occur outside of those boundaries. This is 
invaluable when trying to restrict drawing and filling to a select 
portion of the display. 

Another unique feature of the fill routines is that they allow 
filling over any pseudo-background color (default is 0). The PHBAK 
command is used to specify this background color. Like the PEN and PHPEN 
commands, PHBAK accepts a color specification on the stack. WIPE uses 
the color specified by the last PHBAK command, and the fill routines 
recognize this as background to be filled over. Try this: 

3 PHBAK WIPE 

CENTERO 0 PEN 1 PHPEN 

50 50 PHILTO 

For the time being, we will leave the background color blue and 
continue on. Next we are going to define a few words which will d'o.v 
simple shapes. Bear in mind that when defining shape words, TURNTO , 

DRAWTO, and PHILTO should be avoided as they are absolute in nature. 
Typically, figures should be drawn relative to the armadillo's direction. 
Likewise, the armadillo should generally be returned to its original 
position and heading once the "canned" shape has been drawn. (For the 
curious, the words DX1 and DY1 return the x-y coordinates of the armadillo's 
current location. The word DAZM returns the directional angle of the 
armadillo.) We shall now define a word which will draw a square on the 
screen. 

: SQUARE ( ^steps/side --- ) 

DUPDRAW 90 TURN 

DUPDRAW 90 TURN 

DUPDRAW 90 TURN 

DRAW 90 TURN ; 

WIPE CENTERO 2 PEN 

20 SQUARE 

45 TURN 20 SQUARE 

Ihere are several points to be mentioned here. First, because 
combinations of DUP with DRAW, GO, and GO. occur often, the words DUPDRAW, 
DUPGO, and DUPGO. have been defined to conserve memory. 

Also notice that the squares drawn really have sides of equal length 
(in BASIC, the vertical legs would be much shorter). The armadillo package 
performs "aspect ratio" calculations which ensures that "equal" lines are 
drawn the same length regardless of their orientation to a fixed axis. 

These routines were enabled at the beginning of this stroll with the 
"ON ASPECT" command. Because these calculations do take time (approxi- 
mately 3 milliseconds per draw), they can be turned off using the command: 

OFF ASPECT 


XL 1-9 


Now, notice how in the last example, the second square was rotated 
45 degrees from the first square. We can write simple words using this 
effect that look pretty snappy on the screen: 

: FAN ( #steps/side — ) 

20 0 ( 20 squares for fan ) 

DO 

18 TURN ( 360 degrees/20 = 18 ) 

DUP SQUARE 
LOOP 
DROP ; 

WIPE CENTER 30 FAN 

This word draws 20 squares on the screen each offset from each other 
by 18 degrees. Try changing PEN colors and give different step sizes to 
FAN and watch the results. Each of the boxes drawn by FAN is the same 
size. We can write another simple word which will slightly increase the 
size of each box drawn and obtain a different effect: 

: WHIRL ( #boxes — ) 

( #boxes ) 0 

DO 

I 3 / SQUARE ( increase size ) 

5 TURN 
LOOP ; 

WIPE CENTER 250 WHIRL 

This word draws the specified number of boxes, each one rotated from 
the last by 5 degrees. After three boxes are drawn, the box size is 
increased. This is how the swirl effect is obtained. A slight variation 
of this is to change the PEN color before each square is drawn, but this 
is left to the reader. 

Up to now, we have drawn lines from one point to another regardless 
of what the line replaces. This is standard for line drawing routines. 

In the valGraphics package, however, "draw until" is supported. In other 
words, lines can be drawn that will stop on the first occurrence of another 
line (actually, until the color specified by PHBAK or DRBAK, whichever 
came last). When the draw-until switch DRUNT is ON, all DRAW, DRAWTO, PHIL, 
and PHILTO commands will stop when the base line hits another line on the 
display. Here's an example: 

ON DRUNT WIPE CENTERO 
40 SQUARE 

Don't worry if only the two vertical sides of the square were drawn, this 
is normal. Since the draw routines in this package plot both the end 
point and the starting point, the end point of the first side stopped 
the line draw of the second side. In most cases, this. is the desired 
function for DRAW, but while drawi ng-unti 1 (ON DRUNT), first point plotting 
is not desired. For this reason, it can be easily turned off using the 
DR 1ST switch: 

OFF DR1ST WIPE 
40 SQUARE 


XL I- 10 


With DRUNT still on, try the following example: 

WIPE 30 QCIRCLE 
40 SQUARE 

The QCIRCLE conmand draws a quick-and-dirty circle about the 
armadillo, with the value on top of stack taken as the approximate 
radius. Notice how the 40-step square turned out. Because the draw- 
until mode is on, each side is drawn until another line is encountered. 
Note, however, that even though the line was not drawn to the destina- 
tion point, the armadillo was still positioned there. Because interest- 
ing results can be obtained by using this feature, the RELOC command 
must be used explicitly to reposition the armadillo to the last plotted 
point of the line. The following two definitions might come in handy: 

: DRW UNTIL ( #steps — ) 

DILLO 
ON DRUNT 
DRAW DFLG 
IF RELOC ENDIF 
OFF DRUNT ; 

: DRW2UNTIL ( x y — ) 

DILLO 
ON DRUNT 
DRAWTO DFLG 
IF RELOC ENDIF 
OFF DRUNT : 


(DFLG is a flag set true only if the last DRAW or DRAWTO crossed 
the current window. ) 

These two commands will automatically reposition the armadillo at 
the end of the drawn line after each draw. One last point about draw- 
until -- occasionally it is desirable to know when a draw-until line was 
stopped by the draw-until function, rather than by reaching an end point 
or window boundary. The ?DRSTP word will return a one (1) if the last 
line was stopped, otherwise it will return zero. Try drawing a few lines 
and verifying this. ?DRSTP is in the DILLO vocabulary. (See the glossary.) 

Up until now, when we filled areas or drew-until, both the fills 
and draws would stop when encountering a non-pseudo background color (set 
by PHBAK or DRBAK) . Often, it is desirable to refill an area ( i . e. , 
fill until background is hit) or draw-until hitting the pseudo background 
color. There are two switches which can be turned ON or OFF as desired. 

The PHUNOT (fill until not) switch, when ON, fills until the color set 
by the last PHBAK command is not hit. This is the defaulat condition 
( i . e . , fill until background is not hit). When OFF, the fill routines 
continue to fill until the pseudo background color is hit. Likewise, the 
DRUNOT (draw until not) switch, when ON, draws until the color set by the 
last PHBAK or DRBAK (whichever came last) conmand is hit. Let’s take a 
look at this: 

DINI1 (Reset draw/fill switches) 

2 PEN 3 PHPEN 

WIPE CENTERO 50 50 PHILTO 

1 PHPEN 180 TURNT0 

OFF PHUNOT (fill while not background) 

OFF RPHIL ON LPHIL 60 PHIL 


XLI-11 


As you may recall, the DINIT command initializes all eleven switch 
settings (five of which have yet to be introduced). Next a normal right 
fill (filling over background) is performed. The PHUNOT switch is then 
set for filling while not background and a left fill is performed. 

Notice that no filling occurred when the base fill-line extended out of 
the previously filled area. 

DRUNOT works in the same manner. Execute the last example a second 
time, but turn both PHUNOT and DRUNOT off where previously just PHUNOT 
was turned off. Also turn DRUNT on. This time, no line should extend 
past the previously filled area. (Note that the base line of a fill 
responds to all the draw switches). 


To finish off this first part of the stroll, the final five draw 
switches will be explained. Briefly, they are PH-DR which allows the 
base line of a fill to be drawn or not, DRXOR and PHXOR which allow 
lines and fills to be XOR'd into place, PHCRNR which enables/disables 
rudimentary corner check tests for filling, and PHUNT which allows 
filling to the edge regardless of what lies in the way. 

The PH+DR switch is available because there are times when it is rot 
desirable to actually draw the base line of a fill. This is the case when 
PAINTing (i.e., "shape filling," which is not supported but may be imple- 
mented). The default value for PH+DR is ON.. When PH+DR is OFF , the 
pixels where the base line should be drawn are left untouched. 

( The DRXOR and PHXOR switches allow lines and fills to be 
XOR'd into place. This has the useful property that by simply redrawing 
or refilling the exact same line or shape the object will erase itself. 

For a good example of this, we can use graphic mode 8: 

8 GR. DINIT 250 WHIRL 

1 PHBAK ON DRXOR WIPE 

Recall that the WIPE command uses the value set by the PHBAK conmand— 
in this case, one. WIPE is defined to use a multiple DRAW and therefore 
responds to most (but not all) of the draw switches. Because the WIPE is 
performed with the DRXOR mode on, the display is inverted. WIPE the dis- 
play a second time to re-invert it. To erase the display, DRXOR must 
be turned off. Try this: 

0 PHBAK OFF DRXOR WIPE ON DRXOR 

1 PEN CENTERO 40 FAN 

40 FAN ( one more time ) 

It is important to remember that lines drawn with pen zero have no 
effect in the DRXOR mode. Likewise, first point plot should generally be 
turned off when DRXOR is on otherwise endpoints will be lost. Now to 
demonstrate PHXOR and PHUNT try these examples: 

DINIT WIPE (normal situation) 

CENTERO 100 WHIRL 50 50 PHILT0 


XL I -12 


Now with PHUNT off: 


CENTERO OFF PHUNT 50 50 PHILTO 

The last fill command should have filled clear to the edge of the display, 
ignoring everything in its path. Using this with PHXOR, interesting results 
can be obtained: 

WIPE CENTERO 50 FAN 

ON PHXOR 50 50 PHILTO 

Now, try: 

CENTERO 50 50 PHILTO 

By using windows (described later), the fill and draw comnands can be 
restricted to selected areas of the display. In combination with windows, 
PHXOR can produce astounding visual effects (especially in GTIA modes). 

The last remaining switch to be described is the PHCRNR switch. 

PHCRNR allows rudimentary corner checking for vertical fills. Because 
its use is specialized, PHCRNR is normally turned off. The following 
example will show its function: 

DINIT CENTERO WIPE 

50 GO 50 0 DRAWTO 0 0 DRAWTO 50 PHIL 

Notice the artifact at the top corner. Now, turn PHCRNR on and perform 
the same example (less the DINIT command). This time, no artifact should 
have appeared. It is important to remember that these corner tests will 
not work with many diagonal fills, and completely fail when refilling an 
area. Also note that when first point plot is disabled, even vertical 
filling fails. 

All of the basic armadillo commands have been explained and are 
summarized in the glossary and on the valGraphic Handy Reference Card. 
Although many commands have been discussed, there are many more left 
to talk about. These include the perspective drawing commands for 
three dimensional displays, and the complete set of window commands 
which will be described next. 


(NOTE: In all of the above examples, WIPE has been used to 
clear the display. In many cases, the memory FILL 
command can be used instead: 88 @ n 0 FILL where 

n is the size of display memory in bytes. This method 
is much faster but cannot be used with windows.) 


XL I -13 


STROLLING THROUGH valGRAPHICS, PART II: 
Windows, Lines and Labeling 


Wi ndows 

Up until now we've been working in the base window that is set up when using 
the GR. command. Let's compose some other windows. Type: 

12 GR. 

FRAME 
10 QUBE 

-50 -10 30 -10 WINDOW 

FRAME 

DOT 

We entered graphics 12, framed the base window, made a window whose left, right, 
top, and bottom edges were at -50, -10, 30, and -10 respectively, framed it, and 
then put a dot at the armadillo and found that it was at the center of the new 
window. Now type 

25 QUBE 

and note that the cube is clipped within the boundaries of the new window, riot 
the old one. This could be very useful, say, in showing what was visible through 
a "real" window in a house that you had drawn, without going to a lot of extra 
trouble to restrict the image to the house's window. Now type 

WIPE 
CENTER0 
25 QUBE 

Nothing happens. This is because CENTER0 centered the armadillo in the base 
window. We need to use a different word to re-center in the new window. Type 

WCTR0 25 QUBE 

That's more like it. WCTRO stands for "Window CenTeR 0 turnto," and there is 
also just a WCTR, for "Window CenTeR." Let's try some of the other tricks 
from before: 

3 PHBAK 

WIPE 

WCTR 

20 QUBE 

FRAME 

ON DRXOR 

WIPE 

Get the idea? When we did ON DRXOR, the draw routines, which are used by WIPE, 
started doing an XOR instead of a replace, with the same effect as we've seen 
before, but this time restricted to a smaller window. Type 


XL 1-14 


DINIT 

WIPE 

DOT 

to get things back to normal. Note that DINIT returns to the base window and 
so WIPE wipes the entire screen. The window in which we were just working is 
forgotten. (We'll discuss ways to remember it a little later.) DOT shows that 
the armadillo is back at the center. Now type 

ON ASPECT 

-50 -10 30 -10 WINDOW 
FRAME 

and you see that this "same" 40 by 40 window as before now looks much more 
nearly square. This illustrates that ASPECT works on windows as well as lines. 
With ASPECT on, what you give up in order to get better shapes is some informa- 
tion about what coordinates the top and bottom of the screen actually are, but 
for "hands on" use this is not much of a loss. Let's make two more of this 
type of window: 

2 PEN 

0 30 20 -30 WINDOW FRAME 
DOT 


OK, and then 

-30 30 90 -90 WINDOW 

Notice that this window is larger than the base window. Now type 

DOT 

FRAME 

and notice the trash in the text window. If you choose to make a window 
larger than the base window, the system will not protect you; it assumes that 
you know what you're doing. 

Type CLS once or twice to clear the screen. Then type 
12 GR. 

10 50 -10 -60 RELWND 
FRAME 

2 PEN 
40 QUBE 

Interesting. Now a 40 QUBE used to be much bigger; but because we typed RELWND 
instead of WINDOW, objects are drawn relative to the new window, as if it were 
the base window. Type 

3 PHBAK 
WIPE 
FRAME 

10 50 -10 -60 RELWND 

FRAME 

40 QUBE 


XL 1-15 


Get the idea? Relative windows are useful for all sorts of tricks. Often, it 
would be helpful to be able to return to a window, and relative windows are the 
hardest to reconstruct. Try typing, on one line, 

THISWND LIVING-ROOM 

(Defining words should always be followed by the name of the new word on the 
same line. ) 

By typing LIVING-ROOM later on we can return to this window, as a relative window, 
with no further work. To demonstrate, type 

0 PHBAK 
WIPE 
BASWND 
ON DRXOR 

1 PHBAK 
WIPE 

-20 0 20 0 WINDOW WIPE 

THISWND MV-ROOM 

LIVING-ROOM 

WIPE 

50 QUBE 

MY- ROOM 

50 QUBE 

Normal windows, created by WINDOW, of course can also be named more directly: 

: window-name number number number number WINDOW ; 
and you've got it. 

Well , what else? Type 
40 GR. 

What have we here? 40 is 32 + 8 so we've entered 8 GR. without pre-erasing. 

(This is one of the standard GR. options, you'll recall.) Since 12 GR. and 
8 GR. occupy exactly the same display memory, what we see is the 12 GR. image 
data interpreted as 8 GR. Four color 8 GR. This effect has been written up 
in various places, and here it is. You can come back and play with this sometime. 
Right now, type 

DINIT 

WIPE 

DOT (you may not be able to see it on your screen 
without adjustment.) 

0 -30 GOTO 60 DRAW 

30 0 GOTO 270 TURNTO 60 DRAW 

(Now it's more visible) 

87 -31 GOTO. 

(Move away) 

0 0 TURNTWD ( "turn-toward" ) 

100 DRAW 


XL I - 16 


You'll notice that the line doesn't hit 0,0 exactly. This is because the 
armadillo's direction is only represented to the nearest degree. Still, this 
is good enough for most purposes. 

Finally, let's draw the a rectangular solid in two-point perspective. 

(The procedure in this example is not necessarily the best one, but it 
illustrates several capabilities. You might want to have the debugging 
package loaded from the valFORTH 1.1 disk, and have the stack turned on. 

That way you can follow the action on the stack also.) First we set up a 
horizon and two vanishing points: 

WIPE 

-200 60 GOTO 90 TURNT0 500 DRAW 

-100 60 NAMEPT VP1 (name the point on stack) 

100 60 NAMEPT VP2 

Then we "construct" the solid 

CENTER VP1 TURNTWD 40 DRAW 

THISPT PT1 (name the present point) 

CENTER VP2 TURNTWD 30 DRAW 
THISPT PT2 
CENTERO 20 DRAW 
THISPT PT3 

VP1 TURNTWD MAKLN (leave a "line" on the stack) 

PT1 GOTO 0 TURNTO MAKLN (leave a second line) 

2LNX (find their intersection) 

NAMEPT PT4 (and name the point) 

PT4 DRAWTO PT3 DRAWTO 

VP2 TURNTWD MAKLN (do it again) 

PT2 GOTO 0 TURNTO MAKLN (second line) 

2LNX (intersection) 

2DUP GOTO (make a copy then go there) 

PT3 DRAWTO PT2 GOTO 2DUP DRAWTO (put in 2 more lines) 

VP1 TURNTWD MAKLN PT4 GOTO VP2 TURNTWD MAKLN 2LNX 
DRAWTO DRAWTO (finished) 

0 GR. VL1ST (see the new words: point names.) 

40 GR. (Still there.) 

In addition to MAKLN there is also THISLN which name the line the armadillo 
lies on, and NAMELN which will name a line on the stack. Given two points on 
the stack, 2PT-LN will change the four values into three, suitable for use 
with NAMELN. Practice, and some study of the glossary, will help. The user 
should realize that points and lines can't be named very easily within a 
program, but only while the program is loading. Within a program, use the 
stack or array structures for saving points and lines. 

This stroll is not meant to exhaust the possibilities of this package, but 
merely to indicate them. A clever programmer, for instance, would have little 
trouble in figuring out how to interface this package to a joystick to make a 
very versatile sketchpad. 

Hmmmmm? 


XL 1-17 




o 


(intentionally left blank) 


o 


c 


XL 1-18 


val GRAPHICS GLOSSARIES 


Turtle graphics, and so also val GRAPHICS, uses a coordinate system different 
from that used by the Atari OS. In valGRAPHICS, the center of the graphics 
display is the point o,o. "x" values are positive to the right and negative to 
the left, while "y" values are positive toward the top of the display and 
negative toward the bottom. The maximum values of x and y may vary between 
display modes, depending on various user options that are selected. In this 
regard, see examples in the "Strolling Through valGRAPHICS" sections of this 
package, and also the words MCOOR and SCOOR in the "Windows" section below. 

In the glossary that follows, all mention of coordinates will apply to valGRAPHICS 
coordinates rather than to Atari OS coordinates. 

The DRAW, DRAWTO, PHIL, and PHILTO commands support a number of options 
with a fair degree of complexity and power when used fully. These commands and 
options are discussed as a group at the end of the glossary and summarized with 
a chart which also appears on the handy reference card. The functions discussed 
are necessarily complex; however, the command DINIT ("d-init") is provided so 
that the user may return the system to a "standard-option" status during 
experimentation and practice, or during actual program execution. 

The term "pixel" stands for "picture element" and refers to the smallest 
"point" which may be drawn in a given graphics mode. 

As usual, "color" specification numbers refer to color registers. The 
actual colors in the color registers may be changed by various means, including 
loading the COLOR COMMANDS package from the val FORTH 1.1 disk and using the 
SETCOLOR or SE. command. 

On GTIA-equipped machines in 10 GR. there are nine colors available, 
because the four player/missile color registers are also used. Since these 
registers sit just below the playfield color registers in memory, they may be 
set by using negative "playfield" numbers when using SE. . For instance, -3 
PINK 6 SE. will set player/missile 1 (= -3 + 4) to PINK 6. 

On GTIA-equipped machines in 9 GR. the "color" set by the various color 
commands below, e.g. PEN, PHPEN, PHBAK, etc., is interpreted explicitly as 
luminance between 0 and 15. The hue is that of the background color register. 

On GTIA-equipped machines in 11 GR. the "color" set by the various color 
commands below is interpreted explicitly as a hue between 0 and 15, The lum 
is that of the background color register. 

The term "armadillo" rather than "turtle" will be used in this package. 

DILLO (short for armadillo) is a vocabulary that branches from FORTH. 

All of the system words in this package have been put in the DILLO vocabulary 
to keep them out of the way during VLIST and other tasks. Some little-used 
words are also in DILLO, though advanced users may want to get at them. To 
enter the DILLO vocabulary simply type DILLO and these words will now be 
recognized by the system. Note that since the word : generally puts the 
system back into the FORTH vocabulary, DILLO may have to be used within a 
colon definition. See the source code for numerous examples of this. Words 
in the DILLO vocabulary are so specified in the glossary below. (The word 
DILLO is immediate.) 

For clarity, some definitions may be repeated. Within this glossary, 
however, the same name indicates the same word. 


General Functions: 


valGRAPHICS Glossary 
Part I of III 


GR. ( n — ) 

Appears to function as always, but is now much more powerful: 

* For n = 12, or 12 with higher bits set for the usual options, the mode 
known popularly as 7+ will be activated. This mode is set by Antic instruction 
14 and its characteristics are listed on the handy reference card which 
accompanies this package. 

* For n = 3 to 12, (possibly with higher bit options), the appropriate graphics 
mode will be set up, and all armadillo parameters will be initialized. Note, 

of course, that if your machine does not have a GTIA chip, then modes 9, 10, 
and 11 will not operate as they should. 

* For n = 0 to 2, (plus higher bit options), the system will respond as usual. 

* GR. initializes a number of system and user quantities. Data about pixel 
and display-memory dimensions are sent to appropriate addresses. A pen color 
register of 1 is set by 1 PEN, and the background color register for fill 
commands is set to 0 by 0 PHBAK. OFF ASPECT is executed. 

PEN ( n — ) 

This command is used to change the color that the armadillo draws with, 

PEN sets a new color register, n, to be used by the DRAW, DRAWTO, PHIL, and 
PHILTO commands. 

PHPEN ( n — ) 

This command is used to change the color that the armadillo fills with. 
PHPEN sets a new color register, n, to be used by the PHIL and PHILTO commands. 
Note that PEN also sets a new color register for PHIL and PHILTO, so the value 
used by PHIL and PHILTO will be determined by whichever command, PEN OR PHPEN, 
was done last. 

DRCLR ( — b ) 

Returns the present color used by the armadillo for drawing. DRCLR is 
in the DILLO vocabulary. 

PHCLR ( — b ) 

Returns the present color used for filling. PHCLR is in the DILLO 
vocabulary. 

GO ( n — ) 

GO moves the armadillo n units in the direction in which it is facing. 

No lines are drawn or points plotted. 

DUPGO ( n - n ) 

Same as GO, but doesn't destroy stack argument. 


XLII-2 


GO. 


( n - ) 


GO. moves the armadillo n units in the direction in which it is facing 
and then pokes the pixel at its new location with the value set by the last 
PEN command. 

DUPGO. ( n — n ) 

Same as GO., but doesn't destroy stack argument. 

DOT ( - ) 

DOT puts a dot of the present armadillo color, set by PEN, at the present 
armadillo position. 

GOTO ( x y - ) 


GOTO positions the armadillo at x,y. No lines are drawn or points plotted. 
GOTO. ( x y - ) 

GOTO, positions the armadillo at x,y and pokes the pixel at the new 
position according to the color register selected by the last PEN comma-id. 

CENTER ( — ) 

Positions the armadillo at the point 0,0. The direction the armadillo 
is facing is unchanged, 

CENTERO ( — ) 

Positions the armadillo at the point 0,0 and turns it to face 0, i.e., 
straight up. 

RELOC ( — ) 

Positions the armadillo at the last point drawn by the system routines. 

This is a special purpose command and is used in conjunction with clipping 
in windows, and with the "draw-until" option, described elsewhere. RELOC is 
in the DILL0 vocabulary. 

ASPECT ( ON or OFF - ) 

ON ASPECT will cause vertical components of subsequent graphics commands 
to be scaled to account for the fact that pixels are not square. Thus, circles 
will be rounder, squares will be squarer, and so on. Of course, shapes that 
previously fit on the screen may not fit any longer, as a result of the 
vertical expansion. OFF ASPECT will turn the compensation off for subsequent 
commands. OFF is the default mode, but this may be altered by changing "OFF 
ASPECT" to "ON ASPECT" at the end of the source code for GR. 

LOOK ( x y — b ) 

This command returns the value of the pixel at location x,y. LOOK does 
not move the armadillo. For example, to find the color of the pixel under 
the armadillo, use the armadillo's coordinates: DX1 DV1 LOOK. 


XL 1 1 - 3 


DX1 


( - n ) 


Returns the x coordinate of the armadillo. 

DY1 ( — n ) 

Returns the y coordinate of the armadillo. 

TURN ( n — ) 

Changes the direction that the armadillo is facing by n degrees clockwise. 
Hence, if n is negative, the armadillo will turn counter-clockwise. 

TURNTO ( n — ) 

Turns the armadillo to a heading of n degrees from vertical. Hence, 

0 TURNTO points the armadillo toward the top of the display, and 90 TURNTO 
points the armadillo toward the right edge of the display, and -90 TURNTO or 270 
TURNTO both point the armadillo toward the left edge of the display. 

TURNTWD ( x y — ) 

Turns the armadillo so that it faces toward the point x,y. "Turn-toward." 
DAZM ( — n ) 

Returns the direction, in degrees (0-359), in which the armadillo is 
facing. Stands for "dillo azimuth." 

DINIT ( — ) 

DINIT stands for "armaDillo INITialize." Use it to return all options 
to their default values and to center the armadillo in the display. Useful 
during practice and experimentation. 

DRAW ( n — ) 

Move the armadillo n units in the direction in which it is heading. Draw 
that portion of the line of travel of the armadillo, including the first point, 
that falls within the current window, using the current PEN value. 

DRAWTO ( x y — ) 

Move the armadillo to x y and draw that portion of the line of travel that 
falls within the current window, using the current PEN color register. 

PHIL ( n — ) 

Move the armadillo n spaces in the direction it is heading, and as in DRAW, 
color that portion of the path of travel with the PEN value. Also perform a 
fill to the right during the time that the armadillo is in the current window. 

PHILTO ( x y — ) 

Move the armadillo to the point x y. Then proceed as in PHIL. 


XL 1 1 -4 


Windows and Coordinate Systems 


The following discussion is largely technical. Even so, it may be skimmed 
by the casual user, who can also get a "hands-on" feel for the operation of 
windows and coordinate systems by following the examples in the "Strolling 
Through valGRAPHICS" section of this package. The proliferation of quantities 
in this package is necessitated by allowing it to handle both "absolute" and 
"relative" windows at the same time. Because of the complex changes of coordi- 
nate system that this entails, a variety of different data are kept on system 
configuration. This process is transparent to the casual user but may be 
used with great power by the experienced programmer. 

This package uses cartesian (rectangular) coordinate systems (CS's) 
throughout. For highest speed in graphics work, the graphics coordinate system 
should be in the same "scale" as the hardware. That is, moving one unit 
horizontally or vertically in the graphics CS should move the graphics cursor 
(in this case called the armadillo), one pixel. Doing this avoids additional, 
usually relatively slow, multiplication and division operations to make the 
graphics CS "fit" the hardware CS. However, sometimes the speed sacrifice is 
worthwhile in achieving a desired effect. Therefore, both types of CS are 
supported in this package. The default CS is of the first type, and it may also 
be called into play explicitly by the command "MCOOR" which stands for "machine 
coordinates." This mode is used for high-speed at some sacrifice of flexibility. 
The optional mode is called by "SCOOR" which stands for "scaled coordinates." 
Before executing SCOOR, the user may want to set up coordinate boundaries by 
using SET-SCALE, defined below. Moving between these two types of CS may also 
be handled automatically by the window routines discussed next. Because of 
automatic initialization routines in GR., the user may employ both machine and 
scaled CS's without ever calling them up explicitly. This happens through the 
commands WINDOW, which puts the system into the machine CS before interpreting 
its 4 stack arguments; and RELWND, which puts the system into scaled coordinates 
before interpreting its 4 stack arguments. (Clearly, RELWND must force the 
system into scaled coordinates, since it will be creating a window with the 
same numerical coordinates as the one RELWND works from, though the windows 
will generally be different sizes.) For some help in familiarization with these 
procedures, please refer to the examples in the "Strolling..." section. 

A “window," for the purposes of this package, is a rectangular portion of 
the graphics display area. Windows are implemented to allow "clipping" as 
well as some additional scaling and distortion features. Clipping allows the 
armadillo to travel inside and outside the currently active window, while allow- 
ing drawing and filling only while the armadillo is within the boundaries of the 
window. 

The current window's "physical" boundaries are kept in the system quans 
WNDLFT, WNDRGT, WNDTOP, and WNDBOT. (For an explanation of the QUAN structure, 
see the section on this topic.) The user does not generally access these 
quantities directly, but sometimes may want to do so for special effects. 

WNDLFT and WNDRGT are, respectively, the number of pixels from the left edge of 
the display to the left edge of the window, and the number of pixels from the 
left edge of the display to the right edge of the window. Similarly, WNDTOP 
and WNDBOT are referenced from the top of the display. Again, the user doesn't 
have to use these quantities; they are, however, the "bedrock" of the windowing 
process. These quans are in the DILLO vocabulary. 


XL 1 1-5 


When a graphics-type GR. command is executed (3-12, see GR. above) a window, 
called the "base window," is set up which takes up the entire graphics display 
area. (The "physical" edges of the base window are stored in the system quans 
WNDL, WNDR, WNDT, and WNDB, which have meanings similar to WNDLFT, etc., above, 
and are likewise in the DILLO vocabulary.) The user may generally return to 
the base window at any time before leaving the graphics mode by executing BASWND. 
When the base window is made current by the user explicitly or by GR., the 
armadillo is placed at the point 0,0, i.e., the center of the window, and 
turned to 0 degrees, or straight up. The default "numerical" values of the 
window-boundaries are set so that they correspond to pixel counts vertically and 
horizontally. For instance, in 7 GR. the numerical boundaries would be +-79 
horizontally (since there are 160 pixels across the display in that mode), and 
+-39 vertically (since the mode is 80 pixels high.) These values are stored in 
the system quans WNDW, WNDE, WNDN, and WNDS, which stand for "window-west," etc. 
These values may be altered by means described below (SET-SCALE), although the 
change will slow down the draw routines because of the extra transformation 
required when not working in the "natural" coordinates of the system. 

After initializing to a graphics mode with GR., the user may use the various 
commands in this package to create graphics displays in the base window. However, 
additional flexibility is available to the user by defining new windows, as 
follows. 

The command WINDOW is used to define temporarily a rectangular area of the 
display as the current window. This definition will last until the next window 
defining command e.g., WINDOW, BASWND, GR. , DINIT, etc. WINDOW defines the 
window in the coordinate system of the base window. Indeed, WINDOW does 
BASWND before proceeding. (The base window is set up automatically by GR., or 
by DEFBAS when using a customized display list.) WINDOW expects four arguments 
on the stack, namely the left, right, top and botton edges of the new window, 
expressed in the coordinate system of the base window. (RELWND ( "rel -wi nd" ) , 
defines a window relative to the current window, not the base window; its 
description otherwise parallels that of WINDOW.) When WINDOW is executed, a new 
window is made current, and all applicable internal quans are altered as 
appropriate. The armadillo is centered in the new window and turned to 0 degrees. 
The numerical boundaries of the new window will be, as stated before, WNDW, WNDE, 
WNDN, and WNDS. 

(Advanced users: NOTE that, when in a GR. mode, decimal 88 0 will leave the 

address of the byte in the upper-left-hand corner of the display. Internal 
calculations are based on this location. In general, if the user wishes to 
redirect the graphics routines in this package to a display memory area in a 
non-GR. display mode, he or she need do two things: Store the appropriate value 

into memory location decimal 88, and then execute DEFBAS, described below, to 
establish a base window. Note, however, that if your display memory makes a 
discontinuous jump, as can occur for instance when crossing a 4K boundary, the 
graphics routines will not function properly.) 

Additionally, the window-naming word, THISWND, is provided for ease 
simplicity in returning to a specific window. 

Reference on clipping algorithms: 

A Practical Introduction to Computer Programs , Ian 0. Angell. 


XLII-6 


val GRAPHICS GLOSSARY 
Part II of III 


Windows and Coordinate Systems 


WINDOW ( left right top bottom — ) 

Sets a new window whose boundaries, expressed in the coordinate system of 
the base window (not the current window), are taken from the stack in the order 
indicated. The armadillo is centered in the new window and turned to a zero 
angle. Machine coordinates are activated. (See MCOOR). 

RELWND ( left right top bottom — ) 

Makes current a window whose edges are as indicated on stack in the 
coordinate system of the current window (not the base window). Scaled coordi- 
nates are activated. (See SCOOR). 

WIPE ( — ) 

Colors the entire current window according to the color register selected 
by the last PHBAK command. Note that since WIPE uses the system routine DRAWLN 
it will be affected by DRXOR. Hence if ON DRXOR hasbeen executed last then WIPE 
will XOR all pixels in the entire current window with the value set by PHBAK, 
rather than replacing them with that value. This is useful for interesting and 
often eerie effects. 

FRAME ( -- ) 

Draws a line around the current window according to the color register 
selected by the last PEN command. 

BASWND ( — ) 

Makes the base window (usually the full window first put up by a GR. command) 

current, centers the armadillo and turns it to 0 degrees. 

THISWND xxx, ( — ) 
xxx: ( -- ) 

Creates a word, xxx, which when executed makes current the window which 
was current at the time xxx was defined. Also centers the armadillo and turns 
it to 0 degrees, and restores XFORM to its state at the time xxx was defined. 
Located in the "Window Naming" package. 

DEFBAS ( left right top bottom -- ) 

Advanced users. Used to set up a base window when not using GR.. The 
values indicated are the number of pixels from the left edge of the display 
(for left and right) and from the top edge of the display, (for top and bottom). 
Before using this command, the value at decimal 88 should be set to point to the 
byte that represents the upper-left-hand corner of the display area to be used 
for graphics. DEFBAS is in the DILLO vocabulary. 


XL 1 1 - 7 


SET-SCALE ( horiz vert — ) 


Used to redefine the horizontal and vertical numerical boundaries of 
windows. After executing SET-SCALE, the SCOOR (stands for "scaled coordinates") 
command will set windows to range horizontally between +-horiz and vertically 
between +-vert. Note that the point 0,0 will remain the center point of 
windows. Since the command RELWND does SCOOR, relative windows will reflect 
use of SET-SCALE. SET-SCALE is in the DILLO vocabulary. 

MCOOR ( — ) 

Sets the horizontal and vertical numerical boundaries of windows to 
correspond to the number of pixels in each direction in the base window. "MCOOR" 
stands for "machine coordinates." It is not generally accessed directly by the 
user, with one exception: After having done a RELWND and returning to the base 

window by BASWND, an increase in speed may be had by executing MCOOR, if the 
user was using the default scale set automatically by GR. This is a fine 
point, but worth noting. MCOOR is in the DILLO vocabulary. 

SCOOR ( — ) 

Sets the horizontal and vertical numerical boundaries of windows to 
correspond to the default values set by GR. or by values set by SET-SCALE. 
"SCOOR" stands for "scaled coordinates." It is not generally accessed directly 
by the user. SCOOR is in the DILLO vocabulary. 


:WCTR ( — ) 

Centers the armadillo in the current window. 

:WCTR0 ( - ) 

Centers the armadillo in the current window and turns it to 0 degrees. 


o 


c 


XL 1 1 -8 


Line-naming and line manipulation; point-naming 

These packages support labeling various graphics "entities" for convenience in 
recalling them subsequently, for a variety of purposes. 

Lines are stored internally as three-number quantities which are the 
(non-unique) A, B, and C parameters in standard algebraic line notation. 

(See the section on The Straight Line in Mathematical Handbook for Scientists 
and Engineers, 2nd Edition, by Korn and Korn. Point/slope representation is 
insufficient; point/azimuth representation would work but was not used because 
of some doubts concerning execution speed.) Labeling of lines is done princi- 
pally for subsequent geometric-construction-type operations, like finding the 
intersection of two lines, or the point where the armadillo would intersect 
a given 1 ine. 

NAMEPT xxx, { x y — ) 
xxx : ( — x y ) 

Creates a word xxx. When xxx is executed, it returns x and y to the stack. 


THISPT xxx, ( ) 

xxx: ( — x y ) 

Creates a word xxx. When xxx is executed, it returns to the stack 'cLe x 
and y coordinates of the armadillo in the coordinate system of the window current 
at the time xxx was created. 

2PT-LN ( xl yl x2 y2 — a b c ) 

Takes the coordinates of two points on the stack and leaves A, B, and C 
coefficients of the line connecting two points. "Two-point-line." 


MAKLN ( — a b c ) 

Pushes to stack the A, B, C representation of the imaginary line on which 
the armadillo is sitting and along which it faces. Useful in finding where the 
armadillo would intersect a line along its current path. ( Make-line. J 

NAMELN xxx, ( a b c — ) 
xxx: ( -- a b c ) 

Creates the word xxx. When xxx is executed, it returns the values a b c 
to the stack. 


THISLN xxx, ( — ) 

xxx: ( — a b c ) 

Creates the word xxx. When xxx is executed, it returns the A B and C 
values of the line that the armadillo was sitting on and facing along when xxx 
was created. ("This-line.") 


2LNX ( al bl cl a2 b2 c2 — x y ) 

Given two lines on the stack in a b c form, 2LNX returns the point of 
intersection of the two lines. If the lines are parallel or if their point of 
l'r 
1 < 


intersection ot tbe two lines, it cue mn» - 
intersection is very distant and would cause coordinate^ overt low, 
leave -1, -1. ("Two-line-intersection" or "Two-1 ine-X. ") 


2LNX will 


XL 1 1 -9 


val GRAPHICS GLOSSARY 
Part III of III 


Options 

The basic commands, followed by the commands that operate the "switches" on 
options, are described below. 


DRAW ( n — ) 

Standard option: Move the armadillo n units in the direction in 

which it is heading. Draw that portion of the line of travel of the 
armadillo, including the first point, that falls within the current 
window, using the current PEN value. 

ON DRXOR: XOR pixels with the PEN color instead of overwriting 

them with the PEN color. 

ON DRUNT: Stop on hitting a pixel of the value selected with the 

last DRBAK or PHBAK command, whichever was last. 

OFF DRUNOT: DRUNOT makes a difference only when ON DRUNT has been 

executed. When DRUNOT is off and DRUNT is on, lines halt upon hitting 
a pixel of the last color set by DRBAK or PHBAK, whichever was executed 
last. When DRUNOT is on, which is the default case, and DRUNT is on 
also, lines will halt upon hitting a pixel not of the last color set by 
DRBAK or PHBAK, whichever was executed last. 

OFF DR1ST: Don't draw the first point in a line. Useful when 

drawing connected lines after ON DRUNT so that the last point of a line 
won't be interpreted as the stop condition of the next line. See 
"Strolling..." for an example. 


DRAWTO ( x y — ) 


Standard option: Move the armadillo to x y and draw that portion 

of the line of travel that falls within the current window, using the 
current PEN color register. 

ON DRXOR: XOR pixels with the PEN color instead of overwriting them 

with the PEN value. 

ON DRUNT: Stop on encountering a pixel of the color selected with 

the last DRBAK or PHBAK command, whichever was last. 

OFF DRUNOT: DRUNOT makes a difference only when ON DRUNT has been 

executed. When DRUNOT is off and DRUNT is on, lines halt upon hitting 
a pixel of the last color set by DRBAK or PHBAK-, whichever was executed 
last. When DRUNOT is on, which is the default case, apd DRUNT is on 
also, lines will halt upon hitting a pixel not of the last color set 
by DRBAK or PHBAK, whichever was executed last. 


XL 1 1 -10 


DRAWTO (cont'd) 


OFF DR1ST: Don't draw the first point in a line. Useful when 

drawing connected lines after ON DRUNT so that the last point of a 
line won't be interpreted as the stop condition of the next line. See 
"Strolling..." for an example. 

?DRSTP ( — f ) 

?DRSTP is a quan whose value is adjusted after each DRAW and DRAWTO. 

If ?DRSTP is true (non-zero) then the last DRAW or DRAWTO was terminated 
because ON DRUNT had been executed and the line-drawing routine encountered 
a pixel whose value was that selected by the last DRBAK or PHBAK command, 
whichever was last. 7DRSTP is useful in conjunction with RELOC. 


RELOC ( — ) 


Relocates the armadillo to the location of the last pixel drawn by 
the last DRAW or DRAWTO command. If no points were drawn by the last 
DRAW or DRAWTO command, (e.g., if the line fell entirely outside the 
current window) then the armadillo is not moved. RELOC is useful in 
conjunction with ON DRUNT. See example in "Strolling..." RELOC i in 
the DILLO vocabulary. 

DRAWLN ( column row — ) 

A system routine, not intended for general use. This high-speed rou- 
tine replaces the DRAWTO routine in valFORTH 1.1, which used the same OS 
routine as the BASIC DRAWTO command. DRAWLN is in the DILLO vocabulary. 

PHIL ( n — ) 

Standard option: Move the armadillo n spaces in the direction it 

is heading, and ... 

As in DRAW, color that portion of the path of travel with the PEN 
value. Also perform a fill to the right during the time that the arma- 
dillo is in the current window. The color of the fill is set either by 
the PEN value or the PHPEN value, whichever was declared last. The fill 
will always terminate on reaching the edge of the current window if it 
has not been terminated prior to this event. The fill will also termi- 
nate on reaching a pixel that is not background color. In the standard 
option, the command ON PHUNT ( "phi 1 until") has been executed so that 
the fill will stop on the pixel of color register set by PHBAK, and 
0 PHBAK has been executed so that the actual background register, 0, 
will also be used as the phi 1 "background" register. ON RPHIL and OFF 
LPHIL have been executed so that the fill will be toward the right only. 

ON PH+DR has also been executed so that the line of travel of the arma- 
dillo is drawn in addition to the fill operation. 


XL 1 1 — 1 1 


PHIL (cont'd) 


Example Options: 

1 PHBAK: The fill will now stop on reaching a pixel of color 
register 1 (in this example), or the edge of the window. 

ON PHUNOT 2 PHBAK: The state of PHUNOT only matters if ON PHUNT 
has been executed. The effect of PHUNOT ("fill until not") is that the 
fill will now stop on reaching a pixel NOT of color register 2 (in this 
example), or on reaching the edge of the window. 

OFF PHUNT: Turning off fill-until means that now the fill will ONLY 

stop on reaching the edge of the window. 

OFF PH+DR: Turning off PH+DR means that now the routines will not 

draw the line the armadillo is moving along, and will just fill as 
indicated. 

ON LPHIL : Now the routines will also fill to the left. 

OFF RPHIL : Now the routines will not fill to the right. 

ON PHXOR: Now the routines will XOR the pixels with the PEN or 

PHPEN value, whichever was last declared, rather than replacing them 
with it. 

PHILTO ( x y — ) 

Move the armadillo to the point x y. Then proceed as in PHIL. 


C 


O 


XL 1 1-12 


c 


Options: 

(Ail words below take a flag stack argument, and leave none.) 


Switch 

Default 

ON 

OFF 

RPHIL 

on 

Enables right fill 
with PHIL, PHILTO 

Disables right fill 
with PHIL, PHILTO. 

LPHIL 

off 

Enables left fill 
with PHIL, PHILTO. 

Disables left fill 
with PHIL, PHILTO. 

DRXOR 

off 

DRAW, DRAWTO will 
xor pixels with 
line color. 

DRAW, DRAWTO will 
replace pxls with 
line color. 

PHXOR 

off 

PHIL, PHILTO will 
xor pixels with 
fill color. 

PHIL, PHILTO will 
replace pxls with 
fill color. 

DRUNT 

off 

Enable draw-until 
functions. 

Disable draw-until 
functions. 

PHUNT 

off 

Fill to edge of 
window or to dest. 
pixel . 

Fill until encounter- 
ing halt pixel cond 
set by PHBAK, PHUNOT. 

DRUNOT 

on 

With DRUNT on, 

DRAW, DRAWTO draw 
until hit color set 
by DRBAK, PHBAK. 

With DRUNT on, 

DRAW, DRAWTO draw 
until hit not color 
set by DRBAK, PHBAK. 

PHUNOT 

on 

With PHUNT on, 

PHIL, PHILTO fill 
until hitting color 
set by PHBAK. 

With PHUNT on, 

PHIL, PHILTO fill 
until hitting not 
color set by PHBAK. 

PH+DR 

on 

PHIL, PHILTO draw 
line as filling. 

PHIL, PHILTO don’t 
draw line as filling. 

DR1ST 

on 

First point of 
lines is drawn. 

First point of 1 ines 
is not drawn. 

PHCRNR 

off 

PHIL, PHILTO perform 
corner checking, 
armadillo must be 
moving vertically. 

No corner checking. 


DINIT sets all switches to their default values. 


Screen Dump 

This graphics 8 screen-to-Epson/Graftrax dump routine was contributed by William 
Volk, who also collaborated on other parts of this package. 

To dump graphics 8 screens (split or full), load this code and execute with 
GRDUMP. Some samples are shown below. 


Scr # 

0 ( Dll Id: GRDUMP ) 

1 

2 : DMPCOL DILLO < cal — ) 

3 -1 WNDB DO 

4 DUP 88 S + 

5 I BYT/LN * + C3 

6 EMIT 

7 -1 +LQOP 

B DROP ; 

9 

10 : GRPLT DILLO ( — ) 

11 

12 27 EMIT 75 EMI 1 WNDB 

13 WNDT - 1+ FMIT 0 EMIT ; 

14 

15 =■=.- 


Scr # 

0 ( Dillo: BOX-KITE 

1 

2 : BOX -KITE 

3 8 OR . 

4 50 0 

5 DO 

6 1 TCIRCLE 

7 LOOP 

8 -60 60 GOTO 5 QUBE 

9 ON DRXOR 1 F'HBAK WIPE 
10 D I N I T ; 

1 l 
12 

13 

14 

15 


Scr # 

0 < Dillo: GRDUMP ) 

1 

2 : GRDUMP DILLO 

3 ( turn off screen, on printer) 

4 FFLAG 3 2 FFLAG 1 

5 ( set line/ inch = 9 an Epson ) 

6 27 EMIT 65 EMIT 8 EMIT 

7 ( dump the screen / 

8 CR BYT/LN 0 

9 DO 

10 GRPLT I DMPCOL CR 

1 1 LOOP 

12 27 EMIT 65 EMIT 12 EMIT 

13 CF: CR PFLAG ' ; 

14 

1 5 



o 


c 


XL II -14 


Interfacing to Custom Display Lists 

The advanced user wishing to interface valGraphics to a custom (non-GR.) 
display list should recognize that any area of display memory in which valGraphics 
will be required to draw must be continuous. Thus, for example, if a 4K memory 
boundary is crossed, necessitating a jump instruction in the display list, the 
user must ensure that display memory itself crosses the 4K boundary smoothly. 

The location 88 decimal was used by the Atari OS to point to the byte in 
display memory corresponding to the upper left corner of the display, and has 
been adopted for the same purpose in this package. The first thing to do, then, 
is point 88 to the address in display memory that valGraphics should treat as 
the upper left corner of its drawing area. 

The second step is to set up a base window, much as the GR. provided in 
this package does. Use the word DEFBAS to do this, as described in the glossary. 
Note that this word expects its arguments as numbers of pixels, and that "left" 
and "top" will usually be 0. 

Finally, you need to tell the system what graphics mode you’re drawing in. 

The word UGR. (for "user GR.") is provided for this purpose. Give it a number 
from 3 through 12, and it will set up quans like PX/BYT and so on. UGR. recog- 
nizes if you have set up for wide or narrow screen widths, also, and acts accord- 
ingly. 

Do BASWND and the armadillo is centered, pointed up, and ready. 


O 


o 


XL 11-15 


A note on QUAN structures 


The "quan" is a new FORTH data structure, developed at Valpar, and being intro- 
duced in this package. Quans were devised to cut down on wasted memory and 
runtime encountered when using the "variable" data structure. Quans work as 
follows: (Advanced users may want to follow along in the source code for these 

structures also. ) 

Defining a quan: 

QUAN BINGO 

Note that quans do not take initial values. This form was chosen to allow for 
simpler upgrading to target-compiled code later on. 

Giving a quan a value: 

1234 TO BINGO 

Note that since TO is immediate, "TO BINGO" compiles to only 2 bytes instead 
of the 4 bytes that would be required if BINGO were a variable (i.e., BINGO ! ). 

Getting a value back from a quan: 

BINGO 

Simply saying the name of the quan will leave its value on the stack, in this 
case 1234. In this way, quans act like constants. BINGO above also compiles to 
only 2 bytes instead of the 4 required to fetch if it were a variable (i.e., 
BINGO @). 

Getting the address of the data in the quan: 

AT BINGO 

This will leave the address of the first byte of data in BINGO on the 
stack, or compile the address as a literal if encountered during compilation. 

(AT is immediate.) This is useful for a variety of purposes in general 
programming and in interfacing to machine language routines. 


Advanced users: 

The FORTH 83 Standard appears to lean toward “non-state-smart" words, which 
is proper for target-compiled applications. We expect to support both "state- 
smart" and "non-state ' smart" versions of various words, as appropriate for 
different users. 

Note that while 

15 AT BINGO + ! and 15 BINGO + TO BINGO 

accomplish the same task and take the same amount of memory, the first version 
is faster by one primitive nest. 


XL 1 1-16 


c 


o 


The most significant internal feature of quan is that it has 3 cfa's instead of 
just the one common to most FORTH words. This initial 4 byte disadvantage is 
overcome at the second use of a quan, and so poses essentially no problem. 
CQUAN, 2QUAN, 3QUAN, etc., have also been implemented, and the user may have 
some fun puzzling these out before they are published elsewhere. Note that a 
2quan takes 2 arguments from the stack when used with TO, and leaves 2 when 
used alone. When used with AT, a 2quan still leaves the address of the first 
byte of its "parameter field," as does QUAN. Also, when defining CQUAN it is 
probably a good idea to still allot 2 bytes for data, so that +! can be used 
without fear of negative stack arguments. Another new defining structure is 
called "FLAG." Flags have only two cfa's, dropping the one that supports the 
"AT" function. Flags keep only one byte of data, a flag; hence they are 3 
bytes shorter than quans. Flags would not be used in this package enough to 
justify the additional code, but may be worthwhile in other applications. 

Higher speed and cleaner array structures may also be implemented using 
the quan strategy, and may be included in a future release of our utilities- 
editor package. (This would be made available to current u/e owners at a 
price-di fference-plus-handl ing charge. ) 

The word VECT has also been introduced in this package. It has two cfa's, and 
replaces the rather cumbersome variable-based vectoring procedure, 

' SOMEWORD CFA SOMEVARIABLE ! and 

SOMEVARIABLE @ EXECUTE 

with the cleaner, faster, and memory-shorter 

' SOMEWORD CFA TO SOMEVECT and 
SOMEVECT 


c 


XL 11-17 


o 


(intentionally left blank) 


O 


C 


XL! 1-18 


QUICK TRIG 


Since floating point trigonometric operations on the Atari machines are 
rather slow and provide accuracy unnecessary for many applications, this package 
provides integer versions of sine, cosine, and arctangent functions that run 
much faster than their floating point cousins. 

QSIN and QCOS expect scaled radian arguments in the range +-31416, (+-pi), 
with 10000 representing one radian. 

Similarly, QATN returns scaled radian arguments in range +-15708 (+-pi/2). 
QATN accepts arguments in the full single number range, again interpreting 10000 
as 1. This at first glance seems to be a significant limitation on QATN's input 
range but is circumvented by the existence of the more useful QATN2. QATN2 is 
a four-quadrant arctangent function. It accepts two stack arguments, which 
may be thought of as "delta-x" and "delta-y," and uses these arguments to 
construct a value to be used by QATN. QATN 2 then performs sign corrections as 
necessary and returns a value in the range +-31416. QATN2 is what is actually 
used in graphics work, and is used in the word TURNTWD ("turn toward") elsewhere 
in this package. 

For user convenience, the words ->QRD and ->QDG are used to convert from 
scaled-degree arguments to scaled radian arguments and back again. 


16 K/ ( d - n ) 

This is a special-purpose high-speed routine that may find other uses. 
It divides a double number by 16384 and leaves a single number result. 
Used to speed quick-trig functions. 

QSIN ( scaled-radians -- scaled-sine ) 

Takes a scaled-radian argument ( range +-31416 ) and leaves the scaled 
sine in the range +-10000. 

QCOS ( scaled-radians -- scaled-cosine ) 

Takes a scaled-radian argument ( range +-31416 ) and leaves the scaled 
cosine in the range +-10000. 

QATN ( scaled-argument -- scaled-radians ) 

Takes a scaled-argument ( range 0 to 10000 ) and leaves the scaled 
arctangent in the range +-15708 (+-pi/2, scaled). 

QATN2 ( "delta-x" "delta-y" -- scaled-radians ) 

Assuming that the "x" axis points toward zero radians (zero degrees) 
on one end and pi radians (180 degrees) on the other, QATN2 leaves the 
angle ( range +-31416 ) between a line from the origin to the point 
( delta-x, delta-y ). 


XLIII-1 


Counterclockwise angles are positive. 

+15708 



In the illustration above, arctan2 of ( delta-x, delta-y ) would be 
approximately -2.1 radians, or -21000 as computed by QATN2. 

->QRD ( scaled-degrees — scaled-radians ) 

Takes a scaled-degree argument ( range +-18000 ) and converts it 
to a scaled-radian argument ( range +- 31416 ). 

->QDG ( scaled radians — scaled-degrees ) 


Takes a scaled-radian argument ( range +-31416 ) and converts it 
to a scaled-degree argument. ( range +- 18000). 


XL IV valGRAPHICS SUPPLIED SOURCE LISTING 


Screen : 


1 


( Dillo: Drawl ine routine 


HEX 


DILLO DEFINITIONS 


LABEL INCMOD 


( sys ) 


Screen: 4 

0 < Dillo: 

1 

LABEL PHTST 
E6 C, Cl C, 
MTBL2 


£ 

3 

4 


5 

E6 

c, 

C4 

c. 

E6 

c, 

C3 

c. 

D0 

c, 

5 

c, 

AT 

PHUDAT , , 

6 

0£ 

C, 

E6 

c, 

C£ 

c, 

A5 

c, 

C£ 

c, 

6 

CD 

c, 

DRWRK 4 + 

7 

F0 

C, 

02 

c, 

£4 

c, 

C4 

o, 

30 

c, 

7 

2C 

c, 

DRWSTT 6 ■ 

8 

££ 

C, 

85 

c, 

C6 

c, 

A5 

c, 

C3 

c. 

8 

10 

c. 

05 C, £C 1 

9 

85 

C, 

C7 

c, 

84 

C, 

C5 

c, 

A9 

C, 

9 

10 

C, 

02 C, C6 1 

10 

10 

C, 

85 

c, 

Cl 

C, 

06 

c, 

C7 

C, 

10 




1 1 

£6 

C, 

C6 

c, 

26 

C, 

C5 

c, 

38 

C, 

11 




1£ 

A5 

C, 

C5 

C, 

E5 

C, 

C4 

c, 

90 

C, 

12 




13 

04 

C, 

85 

C, 

C5 

C, 

E6 

C, 

C7 

C, 

13 




14 

C6 

C, 

Cl 

C, 

D0 

C. 

EB 

C, 

60 

C, 

14 




15 










==> 

15 





Drawline routine ) 

( sys ) 

B1 C, ca C, 3D c, 
8D C, DRWRK 4 + , AD 
3D C, MTBL2 , 

, D0 C, 07 C, 

+ , 30 C, 09 C, 
C, DRWSTT 6 + , 
C, Cl C, 60 C, 


— > 


Screen: £ 


0 

( Dillo: Drawl ine 

rout ine 

) 

1 

£ 

84 

C, C6 

c, 

84 C, 

C7 

c. 

A5 

c, 

3 

C3 

C, 85 

c, 

C5 C, 

E6 

C, 

C7 

c, 

4 

38 

C, A5 

c. 

C5 C, 

E5 

C, 

C4 

c, 

5 

85 

C, C5 

C, 

C5 C, 

C4 

C, 

B0 

C, 

6 

F3 

C, 60 

C, 






7 









8 









9 

LABEL BUMPY 




( sys ) 

10 

18 

C, AD 

C, 

DRWRK 

! 


65 

C, 

11 

C8 

C, 85 

C, 

C8 C, 

AD 

C, 

DRWRK 

12 

1 + 

, 65 

C, 

C9 C, 

85 

C, 

C9 

C, 

13 

E6 

C, 5A 

C, 

£C C, 

DRWRK 

1 + 


14 

10 

C, 04 

C, 

C6 C, 

5A 

C, 

C6 

C, 

15 

5A 

C, 60 

C, 





==> 


Screen: 5 

0 ( Dillo: Drawline routine ) 

1 


£ 

LABEL (DOPHL) 


( sys ) 

3 

A5 C, 

5B C, 

48 C, 

A5 C, 5C 

C, 

4 

48 C, 

A5 C, 

C8 C, 

48 C, A5 

C, 

5 

C9 C, 

48 C, 

8A C, 

48 C, 84 

C, 

6 

Cl c, 

20 C, 

PHTST 

, 20 C, 


7 

BUMPX 

. 2C 

C, DRWSTT 4 + , 


8 

30 C, 

36 C, 

£C C, 

DRWSTT 7 

+ , 

9 

10 C, 

31 C, 

A5 C, 

C8 C, 48 

C, 

10 

AS C, 

C9 C, 

48 C, 

2C C, DRWRK 

11 

3 + , 

10 C, 

08 C, 

20 C, 


12 

BUMPY 

, EE 

C, DRWRK 3 + , 


13 

F0 C, 

0F C, 

38 C, 

ft5 c, ca 

C, 

14 

15 

ED C, 

DRWRK 


85 C, C8 

c, > 


Screen : 3 

0 < Dillo: Drawline routine ) 

1 

£ LABEL BUMPX ( sys ) 


3 

£C 

c. 

DRWRK 

2+ 

1 

30 

c, 

16 

c, 

4 

ES 

C, 

8A 

c. 

CD 

c. 

AT 

PX/BYT , 

5 

90 

C, 

08 

C, 

A2 

c, 

00 

c, 

E6 

c. 

6 

C8 

C, 

D0 

0, 

02 

C, 

E6 

c, 

C9 

c. 

7 

E6 

C, 

5B 

C, 

D0 

C, 

02 

C, 

E6 

c, 

8 

5C 

C, 

60 

C, 

CA 

C, 

10 

C, 

0C 

C, 

9 

AE 

C, 

AT 

PX/BYT , 

CA 

C, 

A5 

C, 

10 

C8 

c, 

D0 

c. 

02 

C, 

C6 

C, 

C9 

C, 

11 

C6 

C, 

C8 

C, 

A5 

C, 

5B 

C, 

D0 

C, 

12 

02 

C, 

C6 

C, 

5C 

C, 

C6 

C, 

5B 

C, 

13 

60 

C, 










14 

15 ==> 


Screen: 6 

0 ( Dillo: Drawl ine routine ) 

1 


£ 

A5 

c, 

C9 

c, 

ED C, 

DRWRK 1+ , 

3 

85 

c, 

C9 

c, 

£0 C, 

PHTST , 

4 

68 

c, 

85 

C, 

C9 C, 

68 

C, 85 C, 

5 

CS 

C, 

A5 

C, 

Cl C, 

C9 

C, 02 C, 

6 

F0 

C, 

46 

C, 

38 C, 

A5 

C, 5B C, 

7 

ED 

C, 

AT 

WNDLFT , 

A5 

C, 5C C, 

8 

ED 

C,- 

AT 

WNDLFT 1+ , 

30 C, 

9 

39 

C, 

38 

c, 

AD C, 

AT 

WNDRGT , 

10 

E5 

C, 

5B 

c. 

AD C, 

AT 

WNDRGT 1 

11 


1 

E5 

c. 

5C C, 

30 

C, £C C, 

12 

2C 

C, 

DRWSTT 4 + , 


30 C, 

13 

09 

C, 

84 

c, 

Cl C, 

20 

C, PHTST 

14 


» 

A5 

C, 

Cl C, 

D0 

C, IE C, 

15 









Drawl ine routine 


Draw line routine 


) 


Screen : 7 


1 


2 

B1 

c, 

C8 C, 

2C 

c, 

DRWSTT 5 

+ . 

3 

30 

C, 

03 C, 

3D 

c, 

MTBL1 

t 


4 

85 

C, 

Cl C, 

AD 

C, 

AT PHDAT 

» 

5 

3D 

C, 

MTBL2 

v 


45 C, 

Cl 

c, 

6 

91 

C, 

C8 C, 

03 

C, 

Cl C, 

20 

C, 

7 

BUMPX 

, 4C 

C, HERE 44 - 

* 


8 

68 

C, 

AA C, 

68 

C, 

85 C, 

C9 

C, 

9 

68 

C, 

85 C, 

C8 

C, 

68 C, 

85 

C, 

10 

5C 

c. 

68 C, 

85 

C, 

5B C, 

60 

C, 


11 

IS 

13 

14 

15 ==> 


Screen: 10 

0 ( Dillo: 

1 


2 

C8 

c. 

A5 

c. 

59 

C, 

65 

c, 

C3 C, 

3 

85 

c, 

C9 

c. 

AD 

C, 

AT 

PX/BYT , 

4 

85 

c. 

C4 

C, 

A5 

C, 

5B 

c, 

85 C, 

5 

C3 

c, 

A5 

C, 

5C 

C, 

85 

c. 

C2 C, 

6 

20 

c, 

I NCMOD 8 

+ 

, 18 C, 

A5 C, 

7 

C7 

C, 

65 

C, 

ca 

C, 

85 

C, 

ca c, 

8 

A5 

C, 

C9 

C, 

69 

C, 

00 

C, 

85 C, 

9 

C9 

C, 

A6 

C, 

C5 

C, 

60 

C, 



10 

11 

12 

13 

14 

15 ==> 


Screen: 8 


Screen : 1 1 


0 < Dillo: Drawl ine routine 

1 

) 

0 ( Dillo: Drawl ine routine 

1 

) 


2 

LABEL (PHIL) 




( sys ) 

2 

LABEL DTST 


( sys 

3 

2C C, 

DRWRK 

5 + , 

10 

c. 

20 

C, 

3 

E6 C, 

Cl C, AD C, 

AT DRUDAT , 

4 

AD C, 

DRWRK 

2+ , 

48 

c, 

£C 

C, 

4 

3D C, 

MTBL2 , 8D 

C, DRWRK 4 + 

5 

DRWSTT 1+ , 

10 C, 

06 

c, 

8C 

C, 

5 

. B1 

C, CB C, 3D 

C, MTBL2 , 

6 

DRWRK 

2+ , 

20 C, 

(DOPHL) 

1 

6 

CD C, 

DRWRK 4 + , 

D0 C, 

07 C, 

7 

2C C, 

DRWSTT 

£ + > 

10 

C, 

08 

c, 

7 

£C C, 

DRWSTT B + 

DUP , 

30 C, 

8 

A9 C, 

FF C, 

8D C, 

DRWRK 

2+ 

» 

8 

07 C, 

10 C, 06 C, 

£C C, 


9 

20 C, 

(DOPHL) , 

68 

C, 

8D 

c, 

9 

30 C, 

01 C, 60 C, 

C6 C, 

Cl c, 

10 

DRWRK 

£+ , 

60 C, 





10 

AD C, 

DRWRK F + , 

F0 C, 

42 C, 

1 1 








1 1 

EE C, 

AT 7DRSTP , 

ca c, 

ac c, 

12 








12 

DRWRK 

E + , 88 C, 

AD C, 

DRWRK 

13 








13 

2- , 

48 C, 20 C, 

BUMPX 


14 








14 

B1 C, 

C8 C ? 3D C, 

MTBL2 

? 

15 







==> 

15 






Screen : 9 

0 ( Dillo: Drawline routine ) 

1 

2 LABEL PIXEL ( sys ) 


3 

B5 

c, 

00 

c, 

85 

c. 

5A 

c. 

85 

c, 

4 

C4 

C, 

B5 

c, 

02 

c, 

85 

c. 

5B 

c, 

5 

B5 

C, 

03 

c, 

85 

c, 

5C 

C. 

84 

C, 

6 

C2 

C, 

84 

C, 

C3 

c, 

02 

C, 

08 

C, 

7 

A5 

C, 

C4 

C, 

29 

c, 

01 

C, 

F0 

C, 

8 

0E 

C, 

18 

C, 

AD 

c. 

AT 

BYT/LN , 

9 

65 

C, 

C3 

C, 

85 

c, 

C3 

c, 

A9 

C, 

10 

00 

C, 

65 

C, 

C2 

c, 

85 

C, 

C2 

C, 

1 1 

46 

C, 

C2 

C, 

66 

c, 

C3 

C, 

66 

C, 

12 

C4 

C, 

CA 

C, 

D0 

C, 

E3 

C, 

18 

C, 

13 

A5 

C, 

58 

C, 

65 

C, 

C4 

0, 

85 

C, 


14 

15 — > 


Screen: 12 

0 ( Dillo: Drawl ine routine ) 

1 

2 8D C, DRWRK 4 + DUP , AD C, 

3 AT DRUDAT , 3D C, MTBL2 , 

4 CD C, , D0 C, 07 C, 2C C, 

5 DRWSTT B + DUP , 30 C, 0D C, 

6 10 C, 05 C, 2C C, , 10 C, 06 

7 C, CE C, DRWRK E + , CE C, 

8 AT ?DRSTP , 68 C, 48 C, 

3 49 C, FF C, 8D C, 

10 DRWRK 2+ DUP , 20 C, BUMPX , 

11 68 C, 8D C, , 60 C, 

12 

13 

14 

15 ==> 


Screen : 

13 



Screens 16 





0 

1 

< Dillo 

: Draw line 

routine ) 

0 ( 
1 

Dillo: 

Drawl ine 

routine ) 

1 

2 

CODE 

DRAWLN DILLO 

( x y — ) 

X 

2 

C4 C, 

B0 C, 

05 

c, 

CD C, DUP 

3 

86 

c. 

D1 C, 8C C, 

DRWRK 1+ , 

3 

C + DUP , 

90 

c, 

09 C, ED C, 

4 

8C 

c. 

DRWRK 2+ , 

AD C, 

A , 

E6 C, 

C3 C, 

D0 

C, 

02 C, E6 C, 

5 

AT 

BYT/LN , 8D C, 

DRWRK DUP , 

5 

C2 C, 

85 C, 

C4 

C, 

A9 C, FF C, 

6 

38 

c, 

B5 C, 02 C, 

E5 C, 5B C, 

6 

8D C, 

DUP 5 

+ , 

c 

C C, DUP D + 

7 

8D 

c, 

DUP 6 + , 

B5 C, 03 C, 

7 , 

30 C, 

36 C, 

2C 

C, 

DRWSTT 9 + , 

a 

E5 

c, 

5C C, 8D C, 

DUP 7 + , 

8 

10 C, 

0E C, 

84 

C, 

Cl C, 20 C, 

9 

10 

c, 

12 C, CE C, 

DUP 2+ , 

9 

DTST , 

A5 C, 

Cl 

c 

, F0 C, 05 C, 

10 

38 

c. 

98 C, ED C, 

DUP 6 + , 

10 

EE C, 

AT 7DRSTF 

1 9 

D0 C, 76 C, 

11 

8D 

c. 

DUP 6 + , 98 C, ED C, 

11 

2C C, 

DRWSTT 


10 

C, 08 C, 

12 

DUP 7 

+ , 8D C, DUP 7 + , AD 

12 

20 C, 

(PHIL) 

9 

2C 

C, DRWSTT 

13 

c, 

DUP 6 + , 0D C 

, DUP 7 + , 

13 

3 + , 

30 C, 

16 

c. 

B1 C, C8 C, 

14 

8D 

c, 

DUP F + , 38 C, B5 C, 

14 

2C C, 

DRWSTT 

8 

+ 

, 30 C, 03 C, 

15 




— > 

15 





==> 


Screen: 14 






Screen: 17 


0 

1 

2 

( Dillo 

: Drawline 

routine ) 

0 < 

Dillo 

: Drawline routine ) 

00 C, 

E5 

c, 

5A C, 

8D C, 

DUP 

1 

2 

3D C, 

MTBL1 , 85 C, Cl C, 

3 

a + , 

98 

c. 

E9 C, 

00 C, 

8D C, 

3 

AD C, 

AT DRDAT , 3D C, MTBL2 , 

4 

DUP 9 

+ 9 


10 C, 

1A C, 

38 C, 

4 

45 C, 

Cl C, 91 C, C8 C, AD C, 

5 

98 C, 

ED 

C, 

DUP 8 

+ 9 

8D C, 

5 

DUP A 

+ , D0 C, 06 C, 20 C, 

6 

DUP 8 

+ 9 

98 C, ED C, DUP 9 + 

6 

BUMPY 

, 4C C, HERE 8 + , 20 C, 

7 

DUP , 

8D 

c, 

, CE 

C, DUP 1+ , 

7 

BUMPX 

, 8C C, DUP 5 + , AD C, 

8 

38 C, 

98 

c, 

ED C, 

DUP , 

8D C, 

8 

AT 7DRSTP , D0 C, 3D C, A5 C, 

9 

DUP , 

A5 

c, 

5A C, 

85 C, 

C4 C, 

9 

C3 C, 

D0 C, 02 C, C6 C, C2 C, 

10 

20 C, 

PIXEL 

E + , 

SC c, 

DUP 

10 

C6 C, 

C3 C, A5 C, C2 C, 05 C, 

1 1 

A + , 

84 

c, 

C2 C, 

AD C, 

DUP 

11 

C3 C, 

D0 C, A6 C, AD C, DUP 

12 

a + , 

85 

c. 

C3 C, 

AD C, 

DUP 

12 

A + , 

D0 C, 06 C, 20 C, BUMPX 

13 

6 + , 

85 

c, 

C4 C, 

C5 C, 

C3 C, 

13 , 

4C C, 

HERE 5 + , 20 C, BUMPY , 

14 

B0 C, 

05 

C, 

AD C, 

DUP 7 

+ 9 

14 

8C C, 

DUP D + , CE C, B + , 

15 






= => 

15 


— > 


Screen: 15 


Screen: 

18 




0 

1 

( Dillo 

: Draw line routine ) 

0 

1 

( Dillo 

: Drawline routine ) 

X 

2 

F0 C, 

11 C, CE C, DUP A + , 

X 

2 

F0 

c, 

03 C, 

4C 

C, HERE 9A - , 

3 

A5 C, 

C4 C, 85 C, C3 C, AD C, 

3 

A9 

c, 

FF C, 

4D 

C, DRWRK 1+ , 

4 

DUP 7 

+, 85 C, C2 C, AD C, 

4 

8D 

c, 

DRWRK 

1 + 

, 20 C, BUMPY , 

5 

DUP 8 

+ , 85 C, C4 C, 20 C, 

5 

A9 

c, 

FF C, 

4D 

C, DRWRK 2+ , 

6 

INCMOD , A5 C, C4 C, A5 C, 

6 

8D 

c, 

DRWRK 

2+ 

, 20 C, BUMPX , 

7 

C4 C, 

8D C, DUP B + , 8D C, 

7 

A6 

c, 

D1 C, 

4C 

c, 

8 

DUP C 

+ , > 84 C, C4 C, A9 C, 

8 

ASSEMBLER POPTWO , 

9 

FF C, 

8D C, DUP 3 + , 8C C, 

9 






10 

AT 7DRSTP , BC C, DUP D + , 

10 

C; 





11 

2C C, 

DRWSTT A + , 10 C, 03 C, 

11 






12 

CE C, 

DUP D + , A5 C, C6 C, 

12 






13 

85 C, 

C2 C, A5 C, C7 C, 85 C, 

13 

DCX 





14 

C3 C, 

18 C, A5 C, C5 C, 65 C, 

14 






15 

( WAS 

46 ) --> 

15 





= => 


) 


Screen: 19 

0 ( Dillo: PLOT 

1 

2 : PLOT DILLO ( xa ya 

3 C DRWSTT 9 + 1L >R 

4 R 0 0 R ! >R 

5 2DUP 90 C! 91 ! DRfiWLN 

6 R> R> ! 5 

7 

8 
9 

10 

11 


12 


Screen: £2 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 


13 


13 

14 


14 

15 

— > 

15 


Screen: £0 

0 ( Dillo: [LOOK! 

1 

2 HEX 


3 

CODE 

(LOOK) ( 

xa 

ya 

4 

86 

c, 

XSAVE 

c, 

20 

5 

B1 

c, 

N 6 + 

c. 

3D 

6 

48 

c, 

8ft C, 

A6 

c. 

7 

95 

c, 

02 C, 

A9 

c, 

8 

95 

C, 

03 C, 

68 

c, 

9 

4C 

C, 

NEXT , 

c; 



10 DCX 

11 
12 

13 

14 

15 


Screen : 


> 0 

1 
2 

— px# pxl ) 3 

C, PIXEL , 4 

C, MTBL2 , 5 

XSftVE C, 6 

00 C, 7 

95 C, 00 C, 8 

9 


10 
1 1 
12 

13 

14 

==> 15 


£3 


Screen: 21 

0 < Dillo: LOOK 

1 

2 FORTH DEFINITIONS 

3 

4 : LOOK DILLO ( x y 

5 91 0 90 C0 2SWAP XF/L 

6 (LOOK) SWAP 8 PX/BYT / 

7 8 - R> + SHIFT 

8 (ROT 90 C! 91 ! 5 

9 
10 
1 1 
12 


13 

14 


15 


) 


— pen ) 
> R R * 


Screen: 24 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


c 


Screen: 

0 

1 

2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


25 


Screen : 28 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen : 
0 
1 
2 

3 

4 

O l 

7 

8 
9 

10 

11 

12 

13 

14 

15 


28 


Screen : 29 

0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

11 

12 

13 

14 

15 


Screen: 

0 

1 


9 

10 

11 

12 

13 

14 

15 


27 


Screen: 30 


( Qtrig: 
HEX 


16K/ 


2 

2 

CODE 

16K/ 





3 

3 

36 

c, 

03 

c. 




4 

4 

36 

c, 

00 

c, 

36 C, 

01 

C, 

5 

5 

36 

C, 

03 

C, 

36 C, 

00 

c, 

6 

6 

36 

C, 

01 

C, 

B5 C, 

00 

c, 

7 

7 

02 

C, 

B5 

C, 

01 C, 

95 

C, 

a 

8 

03 

cv 

4C 

C, 

POP , 

C; 



9 

10 

11 

12 

13 

14 

15 


95 C, 




DCX 


[QS/C3 


> 


CQATN3 


Screen : 3 1 

0 ( Qtrig: 

1 

2 : <QS/C) ( rad — n > 

3 DUP 670 > 

4 IF DUP 966 > 

5 IF 16384 10000 */ 

6 DUP DUP 4 / M* 16K/ 

7 11 ( TR4 ) OVER M* 16K/ 

8 -208 ( TR3 ) + OVER M* 16K/ 

9 2184 ( TR2 ) + OVER M* 16K/ 

10 -10923 ( TR1 ) + M* 16K/ 

11 OVER M* 16K/ + 

12 10000 M* 16K/ 1+ 

13 ELSE 1- 

14 ENDIF 

15 ENDIF ; — > 


Screen: 34 

0 < Qtrig 

1 

2 : (QATN) < n — rad > 

3 0 >R 

4 DUP 2679 > 

5 IF DUP 17321 10000 */ 10000 - 

6 SWAP 17321 + 10000 SWAP */ 

7 R> 1+ > R 

8 ENDIF 

9 DUP DUP 10000 */ DUP DUP 

10 -509 10000 */ -4708 + 

11 SWAP 2/ 7603 + 

12 */ 2/ OVER 

13 10000 */ + 

14 R> 

15 IF 5236 + ENDIF ; ==> 


Screen : 32 

0 ( Qtrig: QSIN QCOS ) 

1 

2 : QSIN ( rad — r, ) 

3 DUP 0< > R ABS DUP 15708 > 

4 IF 31416 SWAP - ENDIF 

5 (QS/C) R> 

6 IF MINUS ENDIF ; 

7 

8 : QCOS ( rad — n ) 

9 15708 SWAP ABS DUP 15708 > 

10 DUP > R 

11 IF SWAP 

12 ENDIF - (QS/C) R> 

13 IF MINUS ENDIF ; 

14 

15 ==) 


Screen: 35 

0 ( Qtrig: QATN 

1 

2 : QATN ( r, 

3 DUP 0< > R ABS (QATN) R> 

4 IF MINUS ENDIF ; 

5 

6 

7 

8 
9 

10 
11 
12 

13 

14 

15 — > 


> 

— ri > 

o 


Screen: 33 

0 < Qt r i g : 


1 

2 : 
3 


-> QRD -> QDG 


> 


->QRD < scaled degrees — > 
( scaled radians ) 
31416 18000 */ : 


6 : ->QDG < scaled radians — ) 

7 ( scaled degrees ) 

8 18000 31416 */ ; 

9 
10 

1 1 ’ ( (QATN) ; S ) ( ) 

12 

13 

14 

15 — > 


Screen: 36 

0 ( Qtrig: QATN8 

1 

2 : QATN2 ( x y — rad 

3 SWAP 2DUP 0< > R 0 < > R 

4 ABS SWAP ABS SWAP 

5 2DUP > DUP > R 

6 IF SWAP ENDIF 

7 10000 SWAP */ (QATN) R> 

8 IF 15708 SWAP - 

9 ENDIF I’ 

10 IF 31416 I 0= 

11 IF SWAP ENDIF - 

12 ELSE I 

13 IF MINUS ENDIF 

14 ENDIF R> DROP R> DROP ; 

15 


) 

) 


c 


Screen: 37 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 40 

0 < Dillo: 

1 

£ FORTH DEFINITIONS 

3 

4 » < QUAN ) < 57 KLOAD ) 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


DILLO CARMADILLOl 


VOCABULARY DILLO IMMEDIATE 
( ARMADILLO ) 


Screen: 38 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

1£ 

13 

14 

15 


Screen: 41 

0 < Dillo: quans 

1 

£ QUAN DAZM 

3 QUAN DX1 QUAN DY1 

4 

5 DILLO DEFINITIONS 

6 

7 QUAN WNDLFT QUAN WNDRGT 

8 QUAN WNDTOP QUAN WNDBOT 

9 QUAN WNDL QUAN WNDR 

10 QUAN WNDT QUAN WNDB 

11 QUAN WNDW QUAN WNDE 
1 £ QUAN WNDN QUAN WNDS 

13 QUAN DX£ QUAN DY£ 

14 QUAN ?DOWN QUAN DFLG 

15 QUAN 7MCOOR QUAN ?XFM 


Screen: 

0 

1 

£ 

3 

4 

5 
8 

7 

8 
9 

10 

11 

12 

13 

14 

15 


39 


Screen : 


42 


0 

1 

£ 

3 

4 


( Dillo 


quans etc. 


QUAN X ID 
QUAN Y1D 
QUAN X2D 

5 QUAN Y£D 

6 QUAN 1X1 

7 QUAN IY1 

8 QUAN I X£ 

9 QUAN IY2 

10 VECT XF/L VECT <XF/L 

11 VECT CASP 

12 LABEL DRWRK 16 ALLOT 

13 LABEL DRWSTT 16 ALLOT 

14 DRWSTT 16 ERASE 

15 


Screen: 43 


Screen: 


46 


0 

( Dillo: quans etc. 

) 

0 < 
1 

[ Dillo 

: SWAP- 

3L 




1 

£ 

QURN 

DRCLR 



£ CODE SWAP- 





3 

QURN 

PHCLR 



3 

38 C, 

B5 C, 00 

c, 

F5 C, 

02 

c. 

4 

OURN 

DRUCLR 



4 

48 C, 

B5 C, 01 

c, 

F5 C, 

03 

c, 

5 

QURN 

PHUCLR 



5 

4C C, 

BINARY , 

c; 




6 

QURN 

DRDRT 



6 







7 

QURN 

PHDRT 



7 DCX 






8 

QURN 

DRUDflT 



8 







9 

QURN 

PHUDRT 



9 : 

: 3L 



< 

n ■ 

— ) 

10 

QURN 

BYT/LN 



10 

CC0MPILE3 3 





11 

QURN 

PX/BYT 



11 

CC0MPILE3 LITERAL 

; IMMEDIATE 

12 

LRBEL MTBL1 

8 ALLOT 


12 







13 

LPBEL MTBL2 

8 ALLOT 


13 







14 





14 

( 1 

DRRWLN : > 





15 




— > 

15 


1 LORD 




“ * 

Screen : 

44 



Screen: 47 






0 

( Dillo: quans etc. 

) 

0 

1 

( Dillo 

: phi 1 /draw 

opt ions 

> 

1 

QURN 

7DRSTP 

0 TO 7DRSTP 

X 

£ ! 

: RPHIL 

DILLO 


( 

f 

— ) 

3 

QURN 

COSFRC 

1000 TO 

COSFRC 

3 

MINUS 

C DRWSTT 

1 + 

1—1 

r 

n 

5 


4 

QURN 

HSCL 

1000 TO 

HSCL 

4 







5 

QURN 

VSCL 

1000 TO 

VSCL 

5 i 

: LPHIL 

DILLO 


< 

f 

— v. 

6 

QURN 

HRBS QURN VRBS 


6 

MINUS 

l DRWSTT 

£+ 

3L C! 

5 

O 

7 

QURN 

HUSR 

1000 TO 

HUSR 

7 







8 

QURN 

VUSR 

1000 TO 

VUSR 

8 

: PH+DR 

DILLO 


( 

f 

— > 


9 
10 
1 1 
i £ 

13 

14 

15 




9 
10 
1 1 
12 

13 

14 

15 


NOT MINUS C DRWSTT 3 + 3L C! ; 

PHUNT DILLO ( f — ) 

NOT MINUS C DRWSTT 4 + 3L C! ; 

PHXOR DILLO ( f — ) 

MINUS C DRWSTT 5 + 3L C! ; — > 


Screen: 45 

0 ( Dillo: SHIFT 

1 

£ FORTH DEFINITIONS 


Screen : 48 

0 ( Dillo: phil/draw options 

1 

£ HEX 


4 

HEX 








4 

: PHUNOT DILLO 

( f — 

5 

CODE 

SHIFT 






5 

NOT MINUS t DRWSTT 

6 + 3L C! 

6 

B4 

c, 

00 C, 

10 C, 

0R 

c, 

56 

c, 

6 



7 

03 

c. 

76 C, 

02 C, 

C8 

c, 

D0 

c, 

7 

: PHCRNR DILLO 

( f — 

8 

F9 

c, 

4C C, 

HERE 

C + 

» 

F0 

C, 

8 

MINUS C DRWSTT 7 + 

3L C! ; 

9 

08 

c, 

16 C, 

02 C, 

36 

c, 

03 

C, 

9 



10 

88 

c, 

4C C, 

HERE 

8 - 




10 

: DRXOR DILLO 

( f — 

1 1 

4C 

c. 

POP , 

C; 





11 

MINUS C DRWSTT 8 + 

3L C! ; 


1£ 

13 

14 

15 


— > 


1 £ 

13 

14 

15 


DRUNT DILLO 


MINUS C DRWSTT 9 + 3L C! j 


o 


( f — ) 




Screen : 

49 






Screen: 52 

0 

i 

( Dillo: 

DR1ST DRUNOT 


> 

0 

1 

< Dillo: fiDJCLR MSKTBL 

1 

2 

: DR1ST 

DILLO 

< f 

— 

) 

1 

2 

: fiDJCLR 

3 

NOT 

MINUS 

C DRWSTT 

fi + ]L 

C! 

5 

3 

fiT DRDfiT DRCLR (fiDJC) 

4 








4 

fiT PHDfiT PHCLR (fiDJC) 

5 

: DRUNOT 

DILLO 

< f 

— 

) 

5 

fiT DRUDflT DRUCLR (fiDJC) 

6 

NOT 

MINUS 

C DRWSTT 

B + IL 

C! 

5 

8 

fiT PHUDfiT PHUCLR (fiDJC) 

7 








7 


8 








8 

HEX 

9 








9 

LfiBEL MSKTBL 

10 








10 

7F C, BF C, DF C, EF C, 

11 








11 

F7 C, FB C, FD C, FE C, 

12 








12 

3F C, CF C, F3 C, FC C, 

13 








13 

0F C, F0 C, 

14 

DCX 







14 

DCX 

15 






— 

> 

15 



Screen: 50 





Screen: 53 

0 

( Dillo: DTBL 




) 

0 ( Dillo: reserved 

1 






1 

2 

DILLO DEFINITIONS 





2 

3 






3 

4 

’ ( TABLE ==> ) ( ) 





4 

5 

HEX 





5 

6 

: DTBL 





6 

7 

CREATE SMUDGE 





7 

8 

;CODE 16 C, 00 C, 

36 

C, 

01 

c, 

8 

9 

Cfl C, Cfl C, 18 C, 

A5 

c. 



9 

10 

W C, 69 C, 02 C, 

95 

c. 

00 

c, 

10 

1 1 

98 C, 65 C, W 

1 + 

c, 

95 

c, 

11 

12 

01 C, 4C C, > + , 

C; 




12 

13 

DCX 





13 

14 






14 

15 





==> 

15 


Screen: 51 


Screen : 54 

0 ( 

Dillo: CfiDJCl 

) 

0 ( Dillo: reserved 

1 



1 

2 : 

(fiDJC) 

( adr val — ) 

2 

3 

8 PX/BYT 8 MIN 0 

MfiX / SWfiP 

3 

4 

8 3 PICK - SHIFT 

255 AND DUP 

4 

5 

8 4 PICK 


5 

6 

DO 


6 

7 

3 PICK MINUS SHIFT 

7 

8 

SWOP O+S 


8 

9 

3 PICK 


9 

10 

+LOOP 


10 

11 

DROP SWfiP DROP SWAP C! : 

1 1 

12 



12 

13 



13 

14 



14 

15 


— > 

15 


) 


Screen : 55 

0 ( Dillo: reserved 

1 

a 

3 

4 

5 

6 
7 

a 

9 

10 
u 
1 2 

13 

14 

15 


Screen : 58 

0 ( Dillo: reserved 

1 

a 

3 

4 

5 

6 
7 

a 

9 

10 

u 

12 

13 

14 





Screen : 56 

0 ( Dillo: reserved 

1 

a 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


) 




Screen: 59 

0 ( Dillo: reserved 

1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

11 

12 

13 

14 

15 


) 


o 


> 


Screen: 57 

0 < Dillo: reserved 

1 

a 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


) 


— > 


Screen: 60 

0 ( Dillo: POSIT SCRWID ) 

1 

a FORTH DEFINITIONS 

3 

4 : POSIT < xabs yabs — ) 

5 90 C! 91 ! ; 

6 

7 

8 ’ ( SCRWID’ ) < 

9 : SCRWID 

10 559 CC- 252 AND OR 559 C ! ; ) 

11 ( width — ) ( I 

12 


13 

14 

15 ==> 


Screen: 61 






Screen : 64 






0 

( Turtle: TRGTBL 



) 

0 

( 

Dillo: 4 

-SIN, 1 

COS 

#S/C 


) 

1 

DILLO DEFINITIONS 




1 








£ 

> ( TABLE TABLE 

TRGTBL 



) 

3 

s 

4 — SIN 



( 1 r. I — 

n 

> 

3 

( DTBL 

TRGTBL ) 



0 

9 

3 


DAZM 180 

> 





4 

571 , 

1143 , 

1714 

9 

£385 

9 

4 


IF MINUS 

END IF 

9 




5 

£855 , 

34£5 , 

3993 

» 

4560 

9 

5 








6 

51£5 , 

5689 , 

6£5£ 

* 

6813 

9 

6 

: 

4-COS 



( Ini — 

n 

> 

7 

7370 , 

79£7 , 

8480 

9 

9031 

9 

7 


DAZM 90 > 

DAZM 

£70 

< AND 



8 

9580 , 

101£5 , 

10667 

9 

11306 

9 

8 


IF MINUS 

END IF 

9 




9 

1 1 74£ , 

1££74 , 

1£803 

9 

13337 

9 

9 








10 

13847 , 

14364 , 

14875 

9 

15383 

9 

10 

: 

#S/C 



( — index 

) 

11 

15885 , 

16383 , 

16876 

9 

17363 

9 

11 


DAZM DUP 

180 > 





1£ 

17846 , 

183£3 , 

18794 

9 

19£59 

9 

13 


IF 180 - 

END IF 





13 

19719 , 

£0173 , 

£0630 

9 

£1063 

9 

13 


DUP 90 > 






14 

£1497 , 

£19£5 , 

£3347 

9 

£3761 

9 

14 


IF 180 SWAP- END IF 

9 



15 






— > 

15 






== 

■> 


Screen: 63 







Screen: 65 





0 

4 

( Turtle: TRGTBL 



) 

0 

( 

Dillo: 

COSASP 

♦ SIN 

♦COS 

) 

1 

3 

33169 

9 

£3570 

9 

33964 

9 

£4350 

9 

1 

£ 

- 

COSASP 

( 

del Y - 

— fixed 

) 

3 

£4739 

9 

35100 

9 

35464 

9 

£5830 

9 

3 


COSFAC 1000 */ 

5 



4 

£6168 

9 

£6509 

9 

£6841 

9 

£7165 

9 

4 







5 

£7480 

9 

£7787 

9 

£8086 

9 

38377 

9 

5 

: 

♦SIN 


( n — 

n*"sin" 

) 

6 

38658 

9 

£8931 

9 

39195 

9 

£9450 

9 

6 


#S/C TRGTBL @ 

4-SIN 



7 

£9696 

9 

39934 

9 

30163 

9 

30381 

9 

7 


33767 ♦ / 

5 




8 

30590 

9 

30790 

9 

30981 

9 

31163 

9 

8 







9 

31335 

9 

31497 

9 

31650 

9 

31793 

9 

9 

: 

♦COS 


< n — 

n*"cos“ 

) 

10 

31937 

9 

33050 

9 

33164 

9 

33369 

9 

10 


#S/C 90 

SWAP- 

TRGTBL 

@ 4-cns 


11 

33363 

9 

33448 

9 

33533 

9 

33587 

9 

1 1 


33767 ♦ / 

CASP 

5 



13 

33643 

9 

33687 

9 

33733 

9 

33747 

9 

13 







13 

33763 

9 

33767 

9 





13 







14 









14 







15 








==> 

15 





— 

■> 


Screen: 63 


Screen: 66 



0 < 

Dillo: AZMADJ 

) 

0 

( Dillo: ASPECT 



1 



1 




£ : 

AZMADJ 

< — ) 

3 

FORTH DEFINITIONS 



3 

DAZM ABS 360 >= 


3 




4 

IF DAZM 360 MOD TO DAZM 

END IF 

4 

: ASPECT DILLO 

( 1 

ON/OFF 

5 

DAZM 0< 


5 

IF C ' COSASP 

CFA 

3L 

6 

IF 360 AT DAZM +! END IF 

5 

6 

ELSE C » NOOP 

CFA 

3L 

7 



7 

END IF 



8 



8 

TO CASP ; 



9 



9 




10 



10 

OFF ASPECT 



11 



11 





Screens 67 


Screen: 70 


0 

( 

Dillo: CXX3 CYY1 DXF DXL ) 

0 

( 

Dillo: 7HZQNE 7VZ0NE 

DLINE 

) 

1 

DILLO DEFINITIONS 

1 






a 




2 

DILLO DEFINITIONS 



3 

: 

<XX> 

( XnD — xabs ) 

3 






4 


HSCL 

+ WNDRGT WNDLFT - 

4 

3 

7HZ0NE 

( coor — f 

) 

5 


HSCL 

a* NOOP */ WNDLFT + ; 

5 


DUP WNDW ( 




6 




6 


IF DROP -1 

ELSE WNDE > 

END IF 

5 

7 

- 

(YY) 

( YnD — yabe ) 

7 






B 


VSCL 

SWAP- WNDBOT WNDTOP - 

8 

3 

7VZONE 

( coor — f 

) 

9 


VSCL 

2* NOOP */ WNDTOP + ; 

9 


DUP WNDS ( 




10 




10 


IF DROP -1 

ELSE WNDN > 

END IF 

! 

11 

• 

DXF 

( XnD YnD — xabs yabs ) 

11 






12 


(YY) 

SWAP (XX) SWAP ; 

12 

3 

DLINE 


( — 

) 

13 




13 


X ID Y1D XF/L POSIT 



14 

s 

DXL 

( XnD YnD — xabs yabs ) 

14 


X2D Y2D XF/L DRAWLN ; 



15 


) R HABS + R> VABS SWAP- ; — > 

15 




== 

> 


Screen: 6B 




Screen: 

71 




0 

< 

Dillo: 

( LXXI ( CYY3 (DXF 

(DXL 

) 

0 

1 

< 

Dillo: HWSrP VWSTP ICLIP ) 

1 

£ 

. 

( (XX) 

( xabs - 

- YnD 

) 

I 

£ 

- 

HWSTP 0> 


( f — 

- n n ) 

3 


WNDLFT 

- HSCL Z* 1+ 



3 


IF 

WNDE ELSE WNDW 

END IF 

DUP ; 

4 


WNDRGT 

WNDLFT - */ HSCL 

“ 5 


4 







5 






5 

s 

VWSTP 0> 


( f - 

-nr. ) 

6 

s 

( (YY) 

( yabs - 

- XnD 

) 

6 


IF 

WNDN ELSE WNDS 

ENDIF 

DUP ; ( 

7 


WNDTOP 

- VSCL 2* 1+ 



7 







a 


WNDTOP 

WNDBOT - */ VSCL 

+ ; 


B 

s 

ICLIP 



( — ) 

9 






9 


DX1 

TO X ID 

DY1 TO 

Y1D 


10 

• 

(DXF 

( xabs yabs — 

> 

X 

) 

10 


DX2 

TO X2D 

DY2 TO 

Y2D 


u 


((YY) ! 

SWAP ((XX) SWAP ; 



11 


DX1 

?HZONE 

TO I XI 



12 






12 


DX2 

7HZONE 

TO 1X2 



13 

: 

(DXL 

( xabs yabs — 

X# V# 

) 

13 


DY1 

7VZONE 

TO IY1 



14 


> R HABS - R> VABS SWAP- 

5 


14 


DY2 

■>VZONE 

TO IY2 

5 


15 




== 

=> 

15 






— > 


Screen : 69 

0 < Dillos XFORM ) 

1 

£ FORTH DEFINITIONS 

3 

4 : XFORM DILLO ( f -- ) 


5 

IF 

t ’ 

DXF 

CFA 

3L 


6 


I ’ 

(DXF 

CFA 

] L 

1 

7 

ELSE 

C ’ 

DXL 

CFA 

1L 


8 


L ’ 

(DXL 

CFA 

UL 

0 


9 END IF 

10 TO ?XFM TO <XF/L TO XF/L ; 

1 1 

12 OFF XFORM 

13 

14 

15 — > 


Screen: 7£ 

0 ( Dillo: CLIP ) 

1 


2 : 

CLIP 


( — ) 


3 

1 ICLIP 

1X1 I Y 1 1X2 

IY2 


4 

OR OR OR DUP NOT TO 

DFLG 


5 

1X1 1X2 

(> 1X1 0= OR 



6 

IY1 IY2 

(> IY1 0= OR 

AND AND 


7 

IF 1X1 




8 

IF DY1 ' 

DYE - 1X1 HWSTP TO X1D 


9 

DX2 - 

DX1 DX2 - */ 



10 

DY2 + 

DUP 7VZONE 



11 

IF 2DR0P 0 


c 

12 

ELSE TO Y1D 0 TO IY1 

13 

1 TO 

DFLG 



14 

ENDIF 




15 

ENDIF 


==> 



Screen: 73 

0 < Di Ho: CLIP ) 

1 


£ 

IY1 



3 

IF DX1 DX2 - IY1 VWSTP 

TO 

Y1D 

4 

DY2 - DY1 DY2 - */ 



5 

DX2 + DUP 7HZONE 



6 

IF 2DR0P 0 



7 

ELSE TO X ID 1 TO DFLG 



8 

ENDIF 



9 

ENDIF DFLG OR 



10 




11 

1X2 OVER AND 



12 

IF DY2 DY1 - 1X2 HWSTP 

TO 

X2D 

13 

DX1 - DX2 DX1 - */ 



14 

DY1 + DUP 7VZONE 



15 



— > 


Screen: 76 


0 

1 

2 

( 

Dillo: GOCTOl 

DUPGO 

DRAW 

) 


GO DILLO 


( r. — 

) 

3 


?DOWN SWAP 0 TO 

?DOWN 

MOVE 


4 


TO ?DOWN ; 




5 






6 

S 

GOTO DILLO 

( 

x y -- 

) 

7 


TO DY1 TO DX1 ; 




a 






9 

: 

DUPGO 

( 

n — n 

) 

10 


DUP GO ; 




11 






12 

s 

DRAW DILLO 


< n — 

) 

13 


?DQWN SWAP 1 TO 

?DOWN 

MOVE 


14 


TO 7 DOWN ; 





15 ==> 


Screen: 74 


Screen: 77 





0 

< Dillo: CLIP 

) 

0 

( 

Dillo: DUPDRAW 

DRAWTO PHPEN 

> 

1 

IF DROP 


1 







2 

ELSE TO Y2D 

0 TO IY2 

2 

: 

DUPDRAW 


( n — 

n 

> 

3 

1 TO DFLG 


3 


DUP DRAW ; 





4 

ENDIF 


4 







5 

ENDIF 


5 

s 

DRAWTO DILLO 


< x y • 

— 

) 

6 

IY2 AND 


6 


TO DY2 TO DX2 CLIP 

DLN/UPD 

5 


7 

IF DX2 DX1 - 

IY2 VWSTP TO Y2D 

7 







8 

DY1 - DYE DY1 - */ 

8 

: 

PH PEN DILLO 


( b - 

— 

> 

9 

DX1 + DUP 7HZONE 

9 


TO PHCLR ADJCLR 

5 




10 

IF DROP 


10 







11 

ELSE TO X2D 

1 TO DFLG 

11 







12 

ENDIF 


12 







13 

ENDIF 


13 







14 

ELSE DROP 


14 







15 

ENDIF ; 

==> 

15 





— 

> 


Screen: 75 


0 

1 

£ 

3 

4 

5 

6 
7 

a 

9 

10 

11 

12 

13 

14 

15 


< Dillo: DLN/UPD MOVE TURNCTOl) 

: DLN/UPD ( — ) 

DFLG IF DLINE ENDIF 
DY2 TO DY1 DX2 TO DX1 ; 

: MOVE ( n — ) 

DUP *SIN DX1 + TO DX2 
*COS DY1 + TO DYE 0 TO DFLG 
7DOWN IF CLIP ENDIF DLN/UPD ; 

FORTH DEFINITIONS 
: TURN DILLO ( azitn — > 

AT DAZM +! AZMADJ 5 


— ) 
— > 


Screen: 78 

0 ( Dillo: G0CT03. DUPGO. DOT ) 

1 

£ : GOTO. DILLO < x y — > 

3 2DUP 2DUP GOTO 

4 TO DY2 TO DX2 CLIP DFLG 

5 IF C DRWSTT 9 + DL >R R C* 

6 0 R ! > R DRAWTO R> R> ! 

7 ELSE 2DR0P 

8 ENDIF ; 

9 

10 : GO. DILLO < n — ) 

11 GO DX1 DY1 GOTO. ; 

12 

13 : DUPGO. ( n — ) 

14 DUP GO. i 

15 ==> 


TURNTO DILLO 
TO DAZM AZMADJ 


( azirn 


Screen: 79 

0 ( Dillo: DOT PEN DRBfiK PHBAK ) 

1 

£ : DOT < — ) 

3 0 GO. ; 

4 

5 : PEN DILLO ( b — ) 

6 DUP TO DRCLR PHPEN ; 

7 

8 : DRBfiK DILLO < color — > 

9 TO DRUCLR fiDJCLR ; 

10 

11 : PHBflK DILLO ( color — ) 

12 DUP TO PHUCLR DRBfiK ; 

13 

14 

15 --> 


Screen : 8 £ 

0 ( Dillo: WEDG WRL, BT- BfiSNUM) 

1 

2 : WEDG ( 1 r t b — ) 

3 DILLO TO WNDBOT TO WNDTOP 

4 TO WNDRGT TO WNDLFT ; 

5 

£ : WRL- < — n ) 

7 WNDR WNDL - 2/ ; 

8 

9 : WBT- < — n ) 

10 WNDB WNDT - 2/ 5 

11 

12 : BfiSNUM ( — ) 

13 WRL- DUP MINUS SWfiP 

14 WBT- DUP MINUS WNUM ; 

15 ==> 


Screen: 80 

0 ( Dillo: CENTER 103 PHIL CT03 ) 

1 

2 : CENTER < — ) 

3 00 GOTO ; 

4 

5 : CENTER0 < — ) 

6 CENTER 0 TO DfiZM ; 

7 

8 : PHIL DILLO < n — ) 

9 DRWSTT C0 -1 DRWSTT C! 

10 SWfiP DRfiW DRWSTT C! ; 

1 1 

12 : PHILTQ DILLO < x y — ) 

13 DRWSTT C0 -1 DRWSTT C! 

14 (ROT DRfiWTO DRWSTT C' ; 

15 ==> 


Screen : 83 

0 ( Dillo: SCLSTP RELOC 

1 

£ : SCLSTP < 

3 WRL- TO HSCL WBT- TO VSCL 

4 

5 : RELOC ( 

£ 91 0 90 C0 (XF/L GOTO ; 

7 

8 
9 

10 

11 

12 


13 

14 


15 


) 


— > 



— > 


Screen: 81 

0 < Dillo: WfiBS WNDREL WNUM ) 

1 

2 DILLO DEFINITIONS 

3 

4 : WfiBS < lrtb — LRTB) 

5 DILLO ROT SWfiP XF/L ESWfiP 
£ XF/L 2SW0P ROT SWAP ; 

7 

8 : WNDREL (lrtb— LRTB) 

9 DILLO ROT (XF/L 2SWAP 

10 (XF/L 2SWAP ROT SWfiP ; 

1 1 

12 : WNUM (lrtb—) 

13 DILLO TO WNDS TO WNDN 

14 TO WNDE TO WNDW ; 

15 — > 


Screen: 84 

0 ( Dillo: M, SCOOR SET-SCALE ) 

1 

£ : MCOOR DILLO < — ) 

3 SCLSTP 1 TO 7MCOOR 

4 OFF XFORM ; MCOOR 

5 

£ : SCOOR DILLO ( — ) 

7 HUSR TO HSCL VUSR TO VSCL 

8 HUSR DUP MINUS SWfiP 

9 VUSR DUP MINUS WNUM 

10 0 TO ? MCOOR ON XFORM ; 

11 c 

12 : SET-SCALE ( hscl vscl — ) 

13 DILLO TO VUSR TO HUSR 5 

14 

15 ==> 


Screens 85 Screens 88 


0 

4 

< 

Dillo sCOOR DSCALE WNDASP 

WCTR) 

0 

4 

( Dillos DINIT WIPE 

) 

l 

£ 

. 

COOR DILLO 


( 

— ) 

X 

a 

s DINIT DILLO 

( — ) 

3 


7MCOOR 




3 

DRWSTT 16 ERASE 


4 


IF MCOOR ELSE SCOOR 

ENDIF 

5 

4 

ON RPHIL 


5 






5 

MCOOR BASWND 0 PHBAK 

1 PEN ; 

6 

: 

DSCALE 


( 

— ) 

6 

DINIT 


7 


WRL- WBT- SET-SCALE 

5 



7 



8 






8 

s WIPE DILLO ( org 

dest — ) 

9 

: 

WNDASP 


< 

— ) 

9 

C DRWSTT 9 + 3L >R R 

0 0 R ! 

10 


CASP SWAP CASP SWAP 

5 



10 

> R PHCLR DRCLR PHUCLR 

! PEN 

11 






11 

WNDBOT 1+ WNDTOP 


1£ 

FORTH DEFINITIONS 




1£ 

DO WNDLFT I POSIT 


13 

s 

WCTR DILLO 


< 

— ) 

13 

WNDRGT I DRAWLN 


14 


WNDE WNDW - £/ WNDW 

+ 

WNDN 

14 

LOOP PEN PHPEN R> R> 

1 

f 

15 


WNDS - £/ WNDS + GOTO 

5 

— > 

15 


==> 


Screens 86 

0 ( DiUos WCTR0 BASWND WINDOW) 

1 s WCTR0 ( — ) 

£ WCTR 0 TURNTO ; 

3 

4 s BflSWND DILLO ( -- > 

5 WNDL TO WNDLFT WNDR TO WNDRST 

6 WNDT TO WNDTOP WNDB TO WNDBOT 

7 BflSNUM CENTER0 ; 

8 

9 s WINDOW ( 1ft rgt top bot — ) 

10 DILLO WNDflSP MCOOR £OVER £OVER 

11 BflSWND WfiBS WEDG WNUM WCTR0 ; 
1£ 

13 s RELWND ( 1ft rgt top bot -- ) 

14 DILLO WNDflSP SCOOR WflBS 

15 WEDG CENTER0 ; ==> 


Screens 89 

0 ( Dillos ASPSTP ) 

1 

£ DILLO DEFINITIONS 

3 

4 s ASPSTP < tbladr — ) 

5 DUP C8 SWAP 1+ CC» * 3£ SWAP 

6 / 833 * TO COSFflC ; 

7 

8 
9 

10 
1 1 
1 £ 


13 

14 

15 — > 


Screens 87 

0 ( Dillos RELWND FRAME > 

1 

£ 

3 s FRAME DILLO ( — ) 

4 C DRWSTT 8 + IL 

5 DUP @ OVER 0 SWAP ! SWAP 

6 WNDLFT WNDTOP POSIT 

7 WNDRGT WNDTOP DRAWLN 

8 WNDRGT WNDBOT DRAWLN 

9 WNDLFT WNDBOT DRAWLN 

10 WNDLFT WNDTOP DRAWLN ! ; 

1 1 
1£ 

13 

14 

15 --> 


Screens 90 

0 ( Dillos DEFBAS EDGES > 

1 

£ s DEFBAS < L R T B — > 

3 TO WNDB TO WNDT 

4 TO WNDR TO WNDL 

5 WRL- TO HABS WBT- TO VABS 

6 SCLSTP ; 

7 

8 s EDGES ( scn/pxl pxl/ln — ) 

9 1- < WNDR ) > R 

10 703 C@ 4 = ( ?spl it > 

11 IF 160 ELSE 19£ ENDIF 

1 £ SWAP / 1- ( WNDB ) 

13 0 R> 0 4 ROLL DEFBAS 

14 BflSWND ; 

15 ==> 


Screen: 91 

0 ( Dillo: PXLTBL ) 

1 LABEL PXLTBL 

£ < scn/pxl pxl/ln /10 pxl/byt ) 


3 

8 

c, 

4 

c, 

1 

c. 

( 0 

) 

4 

8 

c, 

£ 

c. 

1 

c, 

( 1 

) 

5 

16 

c, 

£ 

c. 

1 

c, 

( £ 

) 

6 

8 

c, 

4 

c. 

4 

c, 

< 3 

) 

7 

4 

c, 

8 

c, 

8 

c, 

( 4 

) 

a 

4 

c, 

8 

c, 

4 

c, 

( 5 

> 

9 

£ 

c. 

16 

c, 

8 

C, 

( 6 

) 

10 

£ 

c, 

16 

C, 

4 

C, 

( 7 

) 

11 

1 

c, 

3£ 

C, 

8 

C, 

( 8 

) 

1£ 

1 

c, 

8 

C, 

£ 

C, 

< 9 

) 

13 

1 

C, 

8 

C, 

£ 

C, 

( 10 

) 

14 

1 

c, 

8 

C, 

£ 

C, 

< 11 

) 

15 

1 

c, 

16 

C, 

4 

C, 

— 

-> 


Screen: 

9£ 



0 

1 

£ 

( Dillo 

: 7PLUS 

) 

CODE 

7PLUS HEX 

( — ) 

3 

A9 

c, 

07 C, 85 C, 57 

C, AD C, 

4 

30 

c, 

0£ C, 85 C, N 

C, AD C, 

5 

31 

c, 

0£ C, 85 C, N 

1+ C, HERE 

6 

B1 

c, 

N C, £9 C, FC 

c, 

7 

C9 

c, 

40 C, F0 C, 


8 

14 

c, 

B1 C, N C, 


9 

85 

c, 

N £+ C, £9 C, 


10 

0F 

c, 

C9 C, 0F C, D0 

C, 06 C, 

1 1 

C 6 

c, 

N £+ C, A5 C, 1 

N £+ C, 

1 £ 

91 

c, 

N C, CB C, 4C 

c, , 

13 

14 

15 

4C 

C, 

NEXT , C; DCX 



Screen: 93 



0 ( Dillo: 

1 

DIMSTP 

) 

1 

£ : DIMSTP 

< stripped-GR-# — 

) 

3 

< scn/pxl pxl/ln 

) 


4 3 * PXLTBL + DUP ASPSTP 

5 DUP C9 ( scn/pxl ) SWAP 

6 DUP £+ C9 TO PX/BYT 

7 1+C0 10 # ( pxl/ln, normal ) 

8 559 < DMACTL ) C0 

9 3 AND DUP £ <> 

10 IF 1 = IF 4 ELSE 6 END IF 5 */ 

1 1 ELSE DROP 

1£ ENDIF < pxl/ln, actual ) 

13 DUP PX/BYT / TO BYT/LN 

14 

15 — > 


Screen : 94 

0 < Dillo: DIMSTP UGR. ) 

1 

£ PX/BYT DUP £ = 

3 IF DROP 1£ 

4 ELSE 4 - 

5 IF 8 ELSE 0 ENDIF 

S ENDIF 

7 MSKTBL +• MTBH 8 CMOVE 

8 8 0 
9 DO 

10 MTBL1 I + C<? 

11 £55 XOR MTBLE I + C! 

1£ LOOP ; 

13 

14 : UGR. < stripped-GR-# — ) 

15 DIMSTP £DROP MCOOR 5 ==> 


Screen: 95 

0 ( Dillo: GR. ) 

1 

£ FORTH DEFINITIONS 

3 

4 : GR. DILLO ( b — ) 

5 ( set up display, 7+ ? ) 

6 DUP 15 AND SWAP OVER 

7 1£ = 

8 IF £- £- GR. 7PLUS 

9 ELSE GR. 

10 ENDIF 

11 ( set up drawln & window data) 

1£ DIMSTP EDGES 

13 ( initialization ) 

14 0 PHBAK 1 PEN MCOOR DSCALE 

15 OFF ASPECT ; FORTH 


Screen: 96 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

1 £ 

13 

14 

15 


Screen : 97 

0 
1 
2 

3 

4 

5 

6 
7 
B 
9 

10 

11 

12 

13 

14 

15 


Screen: 100 

0 ( turntwd : TURNTWD ) 

1 

2 » ( QATN2 ) < 17 KLOAD ) 

3 

4 : TURNTWD DILLO ( x y — ) 

5 DY1 - SWAP DX1 - SWAP 

6 QATN2 DUP ABS 87 + SWAP +- 

7 ( ROUNDING ) 

8 180 31418 */ 

9 < DEGREES ) 

10 90 SWAP- TURNTO ; 

11 
12 

13 

14 

15 


Screen: 98 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 101 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 99 

0 
1 
2 

3 

4 

5 
8 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen 
0 < 

1 

2 : 

3 

4 

5 

8 : 

7 

8 
9 

10 

11 

12 

13 

14 

15 


: 102 

P-naming: NAMEPT THISPT 

NAMEPT ( xxx, x y 

<BUILDS , , < xxx : — x 

DOES) DUP 2+ 0 SWAP 0 ; 

THISPT DILLO < xxx, -- 

( xxx: — x 
DX1 DY1 NAMEPT ; 


y 


y 


) 

) 

) 


) 

) 


( or write 2QUAN ) 


2LNX MPKLN 


Screens 103 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


5 PICK 
4 PICK 


Screen: 106 

0 ( 1 i nes : 

1 
2 

3 

4 

5 

6 

7 

8 
9 

10 
11 
12 

13 

14 

15 


>c 


< al bl cl a2 b2 c2 — x y ) 


2 PICK M* 

7 PICK M* 
DMINUS D+ 

I* J D/ DROP > R 
2DR0P 2DR0P 2DR0P 
R> R> R> R> 2DR0P 5 


< bl*c2 ) 
- b2*cl > 

< x ) 


MPKLN DILLO 
DX1 DY1 

OVER 100 *SIN + 

OVER 100 *COS + 2PT-LN 


( — a b c ) 


Screens 104 

0 < lines: 2PT-LN ) 

1 DILLO DEFINITIONS QUPN LNP 

2 QUPN LNB FORTH DEFINITIONS 

3 : 2PT-LN ( xl yl x2 y2 — a b c ) 

4 DILLO 2DUP >R >R 

5 ROT - TO LNP ( dy = a ) 

6 - TO LNB ( -dx = b ) 

7 LNP R> M* < -ax2-by2) 

8 LNB R> M* D+ DMINUS ( = c ) 

9 2DUP 32767 M/ PBS 

10 SWPP DROP -DUP 

11 IF 1+ >R R M/ SWPP DROP 

12 LNP R / TO LNP 

13 LNB R> / TO LNP 

14 ELSE DROP 

15 END IF LNP LNB ROT : ==> 


Screen : 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


107 


o 


FORTH DEFINITIONS 


Screen: 105 

0 ( lines: 2LNX 

1 

2 M D/ ) < 60 KLOPD ) 

3 

4 

5 

6 

7 

8 
9 

10 
11 
12 

13 

14 

15 


2LNX 
DILLO 

6 PICK 3 PICK M* 
5 PICK 8 PICK M* 
DMINUS D+ > R > R 
4 PICK 4 PICK M* 
3 PICK 9 PICK M* 
DMINUS D+ 

I I’ D/ DROP > R 


( al bl cl a2 b£ c2 ) 

( — x y ) 
( al*b2 ) 
( - a£*bl ) 

( cl*a2 ) 
< - c2*al ) 


< y 


Screen: 108 
0 ( L-naming 


1 

2 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


THISLN 
’ ( 2PT-LN ) ( 52 KLOPD ) 


( xxx, — ) 

< xxx : — a b c ) 


THISLN 
DILLO 
< BUILDS 
MPKLN , , , 

DOES) 

DUP 4 + @ OVER 2+ 0 ROT 0 ; 
( or write 3QUPN ) 


c 




Screen: 109 

Screen: 

112 


0 < 

L-naming: NAMELN ) 

0 

< Dillo option load block 

1 


1 




2 : 

NAMELN ( xxx, xl yl x2 y2 — ) 

2 




3 

< BUILDS ( xxx : — a b c ) 

3 

100 

LOAD 

( TURNTWD ) 

4 

2PT-LN , , , 

4 




5 

DOES) 

5 

102 

LOAD 

( POINT NAMING ) 

6 

DUP 4+0 OVER 2+ 0 ROT © ; 

6 




7 


7 

104 

LOAD 

( LINE-INTERSECT. 

a 

< or write 3QUAN ) 

a 




9 


9 

108 

LOAD 

< LINE NAMING ) 

10 


10 




li 


n 

11 ® 

LOAD 

( WINDOW NAMING ) 

12 


12 




13 


13 




14 


14 




15 


15 





Screen: 110 


Screen: 113 

0 ( 

W-naming: THISWND 

> 

0 

1 



1 

2 : 

THISWND DILLO 

< xxx, — ) 

2 

3 

<BUILDS 

( xxx: — ) 

3 

4 

?XFM , 


4 

5 

WNDW , WNDE , WNDN 

, WNDS , 

5 

6 

WNDLFT , WNDRGT , 


6 

7 

WNDTOP , WNDBOT , 


7 

8 

DOES) > R 18 0 


8 

9 

DO J I + © 2 +LOOP 

R> DROP 

9 

10 

WEDG WNUM XFORM WCTR0 : 

10 

11 



11 

12 



12 

13 



13 

14 



14 

15 



15 


Screen : 111 

Screen: 114 

0 

0 ( 

Quan: TO AT 

1 

1 


2 

2 : 

TO 

3 

3 

-FIND 0= 0 7ERROR DROP 

4 

4 

STATE 0 

5 

5 

IF , 

6 

8 

ELSE EXECUTE 

7 

7 

END IF 5 IMMEDIATE 

8 

8 


9 

9 : 

AT 

10 

10 

-FIND 0= 0 7ERROR DROP 

11 

11 

4 + [COMPILE! LITERAL ; 

12 

12 

IMMEDIATE 

13 

13 


14 

14 


15 

15 



Screen: 115 Screen: 118 


0 

1 

( Quan: C2063 


C£ ! 

A3 



) 

0 

< Quan: QUAN VECT 

X 

£ 

ASSEMBLER HEX 







1 

£ 

: QUAN 

3 








3 

ON PTCH LABEL -£ ALLOT 

A 

LABEL (£S6) 







A 

(£06) , <£ ! A) , 

5 

A0 C, 06 C, 

B1 

c, 

W 

c, 

A8 

c, 

5 

C » VARIABLE A + 3 LITERAL 

6 

C8 C, B1 C, 

W 

C, 

AC 

c, 

PUSH , 

6 

£ ALLOT OFF PTCH ; 

7 








7 

8 

LABEL (£ ! A) 







8 

: VECT 

9 

A0 C, 0A C, 

B5 

C, 

00 

c, 

91 

c, 

9 

ON PTCH LABEL -£ ALLOT 

10 

W C, CB C, 

B5 

C, 

01 

c, 

91 

c, 

10 

(EVA) , (£!£) , 

11 

W C, AC C, 

POP , 





11 

C » NOOP CFA 3 LITERAL , 

12 








1£ 

OFF PTCH ; 

13 








13 


1A 








1A 


15 







— > 

15 



Screen: 116 

0 < Quam [£ ! £3 C2VA3 ) 

1 

£ LABEL (£!£) 

3 A0 C, 0£ C, 

A AC C, ’ <£ ! A) £ + , 

5 

6 LABEL (EVA) 


7 

A0 

c, 

05 

c, 

B1 

c, 

w 

C, 

A8 C, 

a 

88 

C, 

B1 

c, 

W 

C, 

85 

C, 

W C, 

9 

68 

C, 

85 

c. 

W 

1+ 

c, 



10 

A0 

C, 

00 

c, 

AC 

C, 

W 

1- 



11 

1£ 

13 

1A 

15 ==> 


Screen: 119 
0 
1 
£ 

3 

A 



8 

9 

10 

11 

1£ 

13 

1A 

15 


Screen : 117 

0 ( Quan: patch for CREATE ) 

1 

£ DCX 
3 

A : (PTCH) ( system ) 

5 SWAP >R R = £51 R = £A9 R> = 

6 OR DR ; 

7 

8 : PTCH ( system ) 

9 IF t ’ (PTCH) CFA 1 LITERAL 

10 ELSE C ’ = CFA 3 LITERAL 

11 END IF 

1£ C ’ CREATE 63 + 3 LITERAL I ; 

13 

1A 

15 — > 


Screen: 1£0 

0 ( Dbls: DU/MOD ) 

1 DILLO DEFINITIONS 
£ HEX 


3 

CODE 

DU /MOD 

( dl 

d£ - 

— 

dr i 

dq ) 

A 

A9 

c, 

0A 

c, 

£0 

c, 

SETUP 



5 

CA 

c, 

9A 

C, 

00 

c. 





6 

CA 

c, 

9A 

C, 

00 

c, 





7 

CA 

c, 

9A 

C, 

00 

C, 





8 

CA 

C,' 

9A 

C, 

00 

C, 





9 

A0 

c, 

0A 

C, 

CA 

C, 

B9 

c, 

C5 

c. 

10 

00 

c, 

95 

C, 

00 

C, 

88 

C, 

D0 

C. 

11 

F7 

c, 

A0 

C, 

£0 

C, 

16 

C, 

0£ 

K 

12 

36 

C, 

03 

C, 

36 

C, 

00 

C, 

36 

C, 

13 

01 

C, 

36 

C, 

06 

C, 

36 

C, 

07 

C, 

1A 

36 

C, 

0A 

C, 

36 

C, 

05 

C, 

38 

c. 


15 ==> 


DU/ MOD 


) 


Screen: 121 


< Dbl s : 


13 DCX 

14 

15 


Screen: 124 
0 
1 


£ 

B5 

c. 

06 C, 

E5 

c. 

C4 

c, 

48 

c, 

£ 

3 

B5 

c. 

07 C, 

E5 

c. 

C5 

C, 



3 

4 

48 

C, 

B5 C, 

04 

C, 

E5 

C, 

C£ 

C, 

4 

5 

48 

C, 

B5 C, 

05 

C, 

E5 

C. 

C3 

C, 

5 

6 

30 

C, 

10 C, 

95 

C, 

05 

C, 

68 

C, 

6 

7 

95 

C, 

04 C, 

68 

C, 

95 

C, 

07 

C, 

7 

8 

88 

C, 

95 C, 

06 

C, 

F 6 

C, 

02 

C, 

8 

9 

4C 

C, 

HERE 

05 + , 

68 

C, 

66 

C, 

9 

10 

68 

C, 

88 C, 

D0 

C, 

C4 

C, 

4C 

C, 

10 

11 

NEXT 

, C; 







11 


12 

13 

14 

15 


Screen: 122 


0 

1 

£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


( Dbls: D/MOD D/ 

: D/MOD 

DUP 4 PICK DUP > R XOR >R 
DOBS 2SWAP DABS 2SWAP 
DU/MOD R> D+- 
2SWAP R> D+- 2SWAP ; 

: D/ 

D/MOD 2SWAP 2DR0P ; 


Screen: 125 
0 


3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 123 
0 
1 
£ 

3 

4 

5 
8 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 128 

0 ( Quan: 

1 


TO AT 


2 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


TO 

-FIND 0= 0 7ERR0R DROP 
STATE 0 
IF , 

ELSE EXECUTE 
END IF 5 IMMEDIATE 

AT 

-FIND 0= 0 7ERR0R DROP 
4 + C COMPILE! LITERAL 
IMMEDIATE 


Screen: 127 Screen: 130 


0 

( Quan: QUAN 





) 

0 

( Demos: BOX 

1 







1 


2 

ASSEMBLER HEX 






2 

: BOX 

3 







3 

4 0 

4 

LABEL (206) 






4 

DO DUPDRAW 90 TURN 

5 

A0 C, 06 C, 

B1 

c, 

w 

c, 

48 C, 

5 

LOOP DROP 5 

6 

C 8 C, B1 C, 

W 

c, 

4C 

c, 

PUSH , 

6 

7 







7 


8 

LABEL <2! 4) 






8 


9 

A0 C, 04 C, 

B5 

c, 

00 

c, 

91 C, 

9 


10 

W C, CB C, 

B5 

c, 

01 

c, 

91 C, 

10 


11 

W C, 4C C, 

POP , 




11 


12 







12 


13 







13 


14 







14 


15 






— > 

15 



Screen: 128 

0 < Quan: C2I23 [2V43 


Screen: 131 

0 < Demos: QUBE 


1 1 


2 

LABEL (2! 2) 



2 

: QUBE 


3 

A0 C, 02 C, 



3 

> R DX1 DY1 DAZM R> 

4 

4C C, * (2! 

4) 2 + , 


4 

DUPDRAW 

90 TURN 

5 




5 

DUPDRAW 

45 TURN 

6 

LABEL (2V4) 



6 

DUPDRAW 

45 TURN 

7 

A0 C, 05 C, 

Bl C, W C, 48 

c, 

7 

DUPDRAW 

90 TURN 

8 

88 C, Bl C, 

W C, 85 C, W 

C, 

8 

DUPDRAW 

45 TURN 

9 

68 C, 85 C, 

W 1+ C, 


9 

DUPDRAW 

135 TURN 

10 

A0 C, 00 C, 

4C C, W 1- , 


10 

DUPDRAW 

-90 TURN 

1 1 




11 

DUPDRAW 

180 TURN 

12 




12 

DUPGO 


13 




13 

-45 TURN 

DRAW 

14 




14 

TURNTO GOTO : 

15 



==> 

15 




) 


n — ) 


o 


— > 


Screen: 129 

0 ( Quan: QUAN VECT ) 

1 

2 : QUAN 

3 LABEL -2 ALLOT 

4 (206) , (2 ! 4) , 

5 C ’ VARIABLE 4 + 3 LITERAL , 

6 2 ALLOT ; 

7 

8 : VECT 

9 LABEL -2 ALLOT 

10 <2V4> , (2 ! 2) , 

11 C ’ NOOP CFA 3 LITERAL , ; 

12 

13 

14 DCX 

15 


Screen: 132 

0 < Demos: TCIRCLE QCIRCLE ) 

1 

2 : TCIRCLE ( chord — ) 

3 18 0 

4 DO DUPDRAW 20 TURN 

5 LOOP DROP ; 

6 

7 : QCIRCLE ( radius — ) 

8 DAZM DX1 DY1 4 ROLL 

9 -10 TURN 

10 3473 10000 */ DUP 

11 10000 3473 #/ BO 

12 100 TURN TCIRCLE 

13 GOTO TURNTO ; 

14 

15 


Screen: 133 Screen: 

C 0 0 

V 1 1 

£ £ 

3 3 

4 4 

5 5 

S & 

7 7 

8 8 

3 9 

10 10 

11 11 

1£ 1£ 

13 13 

14 14 

15 15 


o 


Screen: 

0 

1 

£ 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
1£ 

13 

14 

15 


134 


Screen : 
0 
1 

g 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
1£ 

13 

14 

15 


c 


Screen: 135 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen : 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


136 


1 37 


1 36 


Screen: 139 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 142 
0 
1 
2 

3 

4 

5 
8 

7 

8 
9 

10 

11 

12 

13 

14 

15 


o 


Screen: 140 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 143 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


o 


Screen: 141 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 144 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


c 


(21 

1 

2 

3 

4 

5 

& 

7 

a 

9 

10 

u 

12 

13 

14 

15 

cri 

0 

1 

2 

3 

4 

5 

6 

7 

a 

9 

10 

u 

12 

13 

14 

15 

cri 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 


Screen: 148 
0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

n 

12 

13 

14 

15 


Screen: 149 
0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

it 

12 

13 

14 

15 


Screen: 150 


0 

1 

( Fp ext : usef < 

1 

£ 

FP 

3. 14159265 

3 

FP 

1 . 57079633 

4 

FP 

1. 04719756 

5 

FP 

. 785398163 

6 

FP 

. 523598776 

7 

FP 

.0174532925 

8 

FP 

57. 2957796 

9 

FP 

2. 71828183 

10 

FP 

1 

11 

FP 

0 

12 

FP 

1E+97 

13 

FP 

IE-97 

14 



15 




) constants ) 

FCONSTftNT PI 
FCONSTfiNT PI/2 
FCONSTftNT PI/3 
FCONSTftNT PI/4 
FCONSTftNT PI/6 
FCONSTfiNT RD/DG 
FCONSTftNT DG/RD 
FCONSTftNT EXP1 
FCONSTftNT FP1 
FCONSTftNT FP0 
FCONSTftNT FTOP 
FCONSTftNT FBOT 


Screeri! 151 Screen: 154 


0 

< 

Fp ext: FMINUS 

2FDUP F+ ! FMAX) 

0 

1 

< 

Fp ext 

: [F0I FPICK FROLL ) 

1 

£ 


FMINUS 

( fp — 

fp 

) 

X 

2 

CODE <F0) 

< system: — Cfpl ) 

3 


spc« 4 + dup ce 




3 


HEX 

CP C, 

CP C, CP C, CP C, 

4 


128 XOR SWAP C! 

5 



4 


CP C, 

CP C, 

4C C, NEXT , DCX 

5 






5 





6 

i 

2FDUP ( fp fp - 

- fp fp fp 

fp 

) 

6 

: 

FPICK 

< fp. 

. f p n — fp. . fp fp) 

7 


FOVER FOVER ; 




7 


1 - 6 

* SP0 

2+ SWAP O+S 

8 






8 


6-6 

CMOVE 

<F0) ; 

9 

: 

F+ ! 

( fp a 

— 

) 

9 





10 


DUP >R F0 F+ R> 

F! ; 



10 

3 

FROLL 

( f p. . f p n — f p. . f p ) 

11 






11 


0 MAX 

-DUP 


12 

; 

FMAX 

( fp fp — 

fp 

) 

12 


IF DUP 

» 6 * 

> R FPICK SP0 

13 


2FDUP F < 




13 


DUP 6 

+ R> 

<CMOVE FDROP 

14 


IF FSWAP END IF 

FDROP ; 



14 


END IF 

5 


15 




— 

•> 

15 




==> 


Screen: 152 Screen: 155 


0 

( 

Fp ext : 1 

FMIN F0< FOBS 2FDP F, ) 

0 

< Fp ext: -FIX -FLOP I 

) 

1 

: 

FMIN 

( fp fp — fp ) 

1 



2 


2FDUP F> 


£ 

: -FIX ( fp — n 

) 

3 


IF FSWPP 

END IF FDROP ; 

3 

FP -32768 FMPX FP 32767 FMIN 


4 




4 

FDUP F0< 


5 

: 

F0< 

( fp — f ) 

5 

IF FMINUS 1 ELSE 0 END IF 


6 


FP0 F < j 


6 

> R FIX R> 


7 




7 

IF MINUS END IF ; 


a 

s 

FABS 

< fp — fp ) 

8 



9 


FDUP F0< 

IF FMINUS END IF ; 

9 

: -FLOAT ( n — fp 

> 

10 




10 

DUP 0 < DUP > R 


u 

: 

2FDR0P 

( fp fp — ) 

11 

IF MINUS END IF 


12 


FDROP FDROP : 

12 

FLOAT R> 


13 




13 

IF FMINUS END IF ; 


14 

: 

F, 

< fp — ) 

14 



15 


SWAP ROT 

. : , ; ==> 

15 

— 

•> 


Screen: 153 Screen: 156 


0 

( 

Fp ext: F> R 

FR> 


~n 

cn 


) 

0 

( Fp ext: FLWCHK [system! 

> 

1 

3 

F> R 



< 

fp 

— ) 

1 




2 


SWAP ROT R> <ROT 





2 

: FLWCHK ( system ) 



3 


> R > R SWAP > R 

> R 


5 



3 

DUP 173 > I fp fp n n 

n - 

— ) 

4 








4 

IF DROP 128 < fp fp 1 / 

fp 

0 ) 

5 

s 

FR> 



( 

— 

fp > 

5 

AND SWAP 128 AND 



6 


R> R> SWAP R> 

R> 





6 

XOR >R 2FDR0P 



7 


ROT > R <ROT SWAP 

? 




7 

FTOP R> 



8 








8 

IF FMINUS 



9 

: 

F. S 




< 

— ) 

9 

ENDIF 0 



10 


CR S0 0 SP0 - 

2- 

6 

/ -DUP 


10 

ELSE 79 < 



11 


IF -1 SWAP 1- 






11 

IF 2DR0P 2FDR0P FP0 0 



12 


DO SP0 I 6 * 

+ F0 

SWAP 

ROT F. 

12 

ELSE 2DR0P 1 



13 


-1 +LOOP 






13 

ENDIF 



14 


ELSE . " No FP 

on 

stack. 

• • 

II 

14 

ENDIF ; 



15 


END IF ; 





— > 

15 



==> 


SEX PC'S [system! 


> 


sin/cos & atn coefs > 


Screen : 


157 


0 

1 

S 

3 

4 

5 

6 

7 

8 
9 

10 

11 

IS 

13 

14 

15 


( Fp ext: 


: 2EXP®& < system ) 

( fp fp — fp fp n n n n ) 
SP 8 10 + DUP C® SWOP 6 - C® 
SDUP 1S7 PND SWAP 
1S7 AND SWAP ; 


— > 


Screen: 1G0 

0 ( Trig: 

1 

S * < 1 /FP ) < 15 KLOAD ) 

3 

4 LABEL SCCFS 

5 FP . E60190304E-5 F, 

6 FP 1 98074 187E-3 F, 

7 FP . 8333025 14E-E F, 

8 FP — . 166666567 F, 

9 

10 LABEL TCFS 

11 FP 5890958S5E-1 F, 

IS FP -.470832514 F, 

13 FP . 141250074E+1 F, 

14 

15 


Screen: 158 

0 ( Fp ext: F*OV F/OV 1/FP ) 

1 

S : F*OV < fp fp — fp > 

3 2EXP@& + FLWCHK IF F* END IF 5 

4 

5 : F/OV < fp fp — f P > 

6 FDUP F0= 

7 IF FDROP FBOT 

8 END IF 

9 SEXP 8 & 128 - MINUS + FLWCHK 

10 IF F/ 

11 END IF ; 

IS 

13 : 1/FP ( fp — fP > 

14 FP1 FSWAP F/OV ; 


Screen: 161 

0 ( Trig: CS/CI 

1 

E : (S/C) < fp f ' 

3 > R FDUP PI F/ FIX DUP 1 

4 IF R) 1 XOR > R 

5 END IF 

6 FLOAT PI F* F- 

7 FDUP FDUP F* FDUP F> R 

8 SCCFS 4 FR> FS FPOLY >F 

9 FOVER F* F+ 

10 R> 

11 IF FMINUS 
IS END IF ; 

13 

14 

15 


Screen: 159 


0 

1 

2 

3 

4 

5 

6 

7 

8 
9 

10 

11 


Fp ext: ->RD 

-> DG 

) 

FR 

( 

— fpl ) 

4 RPICK J I’ ; 



-> RD 

( fpl 

— fp 2 ) 

RD/DG F* ; 



-)DG 

( fpl 

— fp 2 ) 

DG/RD F# ; 




12 


13 

14 

15 


Screen: 16S 

0 ( Trig: SIN COS TAN 

1 

S : SIN < fp ' 

3 FDUP F0 < > R 

4 FABS R> <S/C) ; 

5 

6 : COS < fp ' 

7 FABS PI/2 F+ 

8 0 (S/C) 5 

9 

10 : TAN < fp ' 

11 FDUP SIN FSWAP COS F/OV 
IS 

13 

14 

15 


) 

— fp ) 
AND 

F* 

) 

“ fP > 

— fp ) 

— fP > 
5 


Screen : 1 S3 

0 < Trig: 

1 


CfiTNI 


) 


( fp — fp ) 


2 : (fiTN) 

3 FDUP FP1 F> 

4 IF 1 /FP 2 ELSE 0 END IF >R 

5 FDUP FP .267949192 F> 

6 IF FDUP FP 1.73205081 F* FP1 

7 F- FSWfiP FP 1.73205081 

8 F+ F/ R> 1+ >R 

9 END IF 

10 FDUP FDUP Fa FDUP FDUP F> R 

11 TCFS 2 FR> FS FPQLY >F Fa- 

12 FSWfiP TCFS 12 + F0 F+ F/ 

13 FOVER F* F+ 

14 I 1 > 

15 -- > 


Screen: 166 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 164 

0 ( Trig: CflTNl 

1 

2 IF FMINUS 

3 END IF R> -DUP 

4 IF 

5 1 DUP 

6 IF 

7 1- 

8 IF PI/3 

9 ELSE PI/2 

10 END IF 

11 ELSE PI/6 

12 END IF F+ 

13 END IF ; 

14 

15 


Screen: 167 
) 0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 


Screen: 165 

0 ( Trig: fiTN PTN2 ) 

1 

2 : fiTN ( fp — fp ) 

3 FDUP F0 < > R FOBS (fiTN) R> 

4 IF FMINUS 

5 END IF ; 

6 

7 : PTN2 < fpx fpy — fp ) 

8 FSWfiP 2FDUP FSWfiP 

9 F0 < > R F0 ( ) R 

10 F/OV FOBS <fiTN) R> 

11 IF PI FSWfiP F- 

12 ENDIF R> 

13 IF FMINUS 

14 ENDIF ; 

15 


Screen: 168 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screens 169 


£ 

3 

4 

5 

6 
7 

a 

9 

10 

11 

12 

13 

14 

15 


Screen: 172 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


o 


Screen : 1 70 

0 CONTENTS OF THIS DISK: 

1 

2 ARMADILLO GRAPHICS: 

3 + TURN TOWARD: 

4 + POINT-NAMING: 

5 + LINE-INTERSECT FCNS: 

6 + LINE-NAMING: 

7 + WINDOW-NAMING: 

8 LOAD ALL ABOVE +’ S: 

9 DEMOS: 

10 

11 FLOATING PT. EXTENSION: 
13 ( REQUIRES VAL4TH FLT . 

13 QTRIG (INTEGER) FNCTNS : 

14 

15 QUAN STRUCTURES: 


40 LOAD 
100 LOAD 
102 LOAD 
104 LOAD 
108 LOAD 
110 LOAD 
112 LOAD 
130 LOAD 

150 LOAD 
PT. ) 

30 LOAD 

114 LOAD 


Screen: 173 
0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

11 

12 

13 

14 

15 


Screen: 171 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

(/ U 

12 

13 

14 

15 


Screen: 174 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen: 175 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 178 

0 ( Error messages 

1 

2 Use only in Definitions 

3 

4 Execution only 

5 

fe Conditionals not paired 

7 

8 Definition not finished 

9 

10 In protected dictionary 

11 

12 Use only when loading 

13 

14 Off current screen 

15 


Screen: 17G 

0 ( Error messages 

1 

2 Stack empty 

3 

4 Dictionary full 

5 

6 Wrong addressing mode 

7 

8 Is not unique 

9 

10 Value error 

11 

12 Disk address error 

13 

14 Stack full 

15 


Screen: 177 

0 Disk Error! 

1 

2 Dictionary too big 

3 

4 

5 
8 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 179 

> 0 Declare VOCftBULORY 

1 
2 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


LVALPAR 


international' 

3801 E. 34™ STREET 
TUCSON, ARIZONA B5713 
608-730-7141 



valFORTH 

T.M. 

SOFTWARE SYSTEM 

for ATARI* 


Text Compression and 
Aoto Text Formatting 


c 


* Atari is a trademark of Atari, Inc., a division of Warner Communications. 


Software and Documentation 
©Copyright 1982 
Valpar International 


o 


o 


<J 


valFORTH 

T.M. 

SOFTWARE SYSTEM 

Text Compression and Auto Text Formatting 

Evan Rosen 

Software and Documentation 
©Copyright 1982 
Valpar International 


Purchasers of this software and documentation package are 
authorized only to make backup or archival copies of the 
software, and only for personal use. Copying the accompanying 
documentation is prohibited. 

Copies of software for distribution may be made only as speci- 
fied in the accompanying documentation. 


p 


o 


o 


VALPAR INTERNATIONAL 


Disclaimer of Warranty 
on Computer Programs 


All Valpar International computer programs are distributed 
on an "as is" basis without warranty of any kind. The total 
risk as to the quality and performance of such programs is with 
the purchaser. Should the programs prove defective following 
their purchase, the purchaser and not the manufacturer, distributor, 
or retailer assumes the entire cost of all necessary servicing or 
repair. 

Valpar International shall have no liability or responsibility 
to a purchaser, customer, or any other person or entity with 
respect to any liability, loss, or damage caused directly or 
indirectly by computer programs sold by Valpar International. 

This disclaimer includes but is not limited to any interruption 
of service, loss of business or anticipatory profits or conse- 
quential damages resulting from the use or operation of such 
computer programs. 

Defective media (diskettes) will be replaced if diskette(s) 
is returned to Valpar International within 30 days of date of sale 
to user. 

Defective media (diskettes) which is returned after the 30 day 
sale date will be replaced upon the receipt by Valpar of a $ 12 . 00 
Replacement Fee. 


G 


C 


TEXT COMPRESSION AND AUTO TEXT FORMATTING 
Table of Contents 


LI OVERVIEW AND STROLLING THROUGH TCAF 

LI I TCAF - GLOSSARY 

LI II TCAF - SUPPLIED SOURCE LISTING 


p 


o 


c 


NOTICE 

TEXT COMPRESSION AND AUTOMATIC TEXT FORMATTING 
CODE TRANSPORTATION 


The routines in this package have been coded and presented so 
that they may be readily transported to other fig-FORTH systems 
on machines other than the Atari 400/800. This is in response to 
numerous requests to this effect from various "adventure" game 
authors. We note, however, that the same restrictions apply to 
the software in this package, whether run on the Atari 400/800 
machines or any other: 

First, the code may ONLY be used in either an AUTO'd system as 
described in val FORTH 1.1 documentation, or in a target-compiled 
system. 

Second, any software written with these routines, on any machine, 
must contain the acknowledgement of Valpar International as the 
source of the code, as described and detailed in valFORTH 1.1 
documentation. 

Other distribution may be construed to be a violation of 
applicable copyright laws. 


1 


o 


o 


o 


Overview 


This package attempts to fill at least two common needs of the programmer who 
does verbal/interactive programming. 

First, a group of automatic text formatting routines is provided that allow 
two different approaches: 

*A non-wrap line formatter to both the video display and the 
printer, including variable-margin capability and inverse 
video option, and 

*A versatile window formatting system, with scrolling, color and 
inverse video options as appropriate, and window naming. Notes 
on the creation of window types with different "generic" parameters 
are also included. 

In both modes described above, user options of left-, right-, center-, or 
fill-justification are supported, as is numerical output formatting. 

Second, two different approaches to the problem loosely termed "text 
compression" are implemented: 

Ihe first is intended for use in programs where run-time retrieval of text 
stored on disk is allowable, and provides a set of general virtual -memory 
operators for the creation and retrieval of messages from disk. A simple 
encryption scheme is provided as a (working) example for the software 
developer who wishes his or her messages to be not easily readable from disk 
with, for instance, a Forth screen editor. In addition, alternate points in 
the virtual memory routines are indicated where deeper encryption routines 
might be employed. Routines are provided for virtual memory message program- 
ming on both one- and two-drive development systems. 

ihe second set of text compression routines is intended for use in “in memory 
applications, such as cassette-booted programs, that do not have access to 
disk for message retrieval. In this case the most compact code practical is 
desired, and a system built around some of the basic aspects of Forth's cov.ti 
threaded-code structure is provided. 

Finally, we note that the autoformatting and text compression utilities aie 
designed to be used in most any of their possible different combinations. 


STROLLING THROUGH TCAF 
(Text Compression and Autoformatting) 


The organization of this disk is slightly different from the others in this 
series. While a table of contents may still be found on screen 170 as usual, 
in this package the "load chain," starting on screen 166, will get far more use. 
In general when one wishes to load a TCAF development system with a specific set 
of capabilities, one makes slight adjustments to the load chain option screen 
and then simply loads the first screen in the chain. The chain does the rest. 

To start off, first prepare two blank, formatted disks. Make your normal working 
copy of TCAF on the first disk and leave it un-write-protected. The second disk 
will be used a little later. 


Autoformatti ng 

In order to select options you will want to make changes to the load chain 
option screen. This may be found by locating the load chain in the directory 
on screen 170, and then scanning through the screens in the chain until you 
find the one marked "options" in its first line. (This is on or near screen 167.) 
Look at this screen, and see that most of the lines have a left parenthesis in the 
left column, followed by a LOAD command and a comment. By removing selected 
left-column left parentheses you can activate various options. Right now on your 
working copy use an editor to remove all of the left-column left parentheses 
except for the one on the line that says "text compression." (Text compression 
uses transient structures and will be discussed separately.) And, of course, 
don't remove the one in the comment at the very top of the screen. OK, now 
boot a bare val FORTH 1.1 system, and load in the debugger, and swap in the TCAF 
disk, do MTB as usual, and load the first screen in the load chain on this disk. 
(Probably 166.) 

When the prompt comes back, type 
ON STACK 

since you'll want to watch the stack. Then type 
TYPEOUT 

(Failure to execute this initialization word may cause a crash as you try to 
use words like *TYPE later on.) This command activates one of the two format- 
ting modes. This mode, called "type-out mode," since it uses the word TYPE as 
its actual output word, can send formatted type to either the display or the 
printer. The other formatting mode is activated by WINDOUT and is called 
"window-out mode." It will be discussed a bit later. 


LI-2 


Now type 


" Here is a simple example of the formatter's function." 

using lower case as shown, and notice that an address, actually PAD, is left 
on the stack. Now reactivate upper case (press Shift and Caps-Lowr) if you 
haven't already, and type 

COUNT 

The address was bumped by one, and the string count was extracted from the 
first byte in the string created by " and placed on top of stack. All normal. 
Now type 

2DUP CR CR TYPE CR 

and see that the typed output wraps around as usual. Now try 
2DUP CR CR *TYPE *CR 

The word "formatter's" is no longer split. Let's try it again but with 
different formatting. Type 

CTRJST ("center justification") 

2DUP CR CR *TYPE *CR 

How about 

FILJST ("fill justification") 

2DUP CR CR *TYPE *CR 

The text is now spread or "filled" to take up the whole space between the 
margins. The last mode is 

RGTJST ("right justi fication") 

2DUP CR CR *TYPE *CR 

which gives the expected result. Tinally, type 

LFTJST ("left justification," the default mode) 

2DUP CR CR *TYPE *CR 

and we're back where we started. 

Well, what precisely is happening? The 2DUP each time is there of course 
to reproduce the two stack arguments, adress and count, for use by *TYPE 
(or TYPE). The two CR's each time are merely to space the result down the 
page a bit, and make it start at the left margin. As we will see, these two 

CR's will not generally be necessary in normal programs. The TYPE we'll assume 

you already know about. If not, look it up in the 1.1 glossary. While you're 
looking at TYPE'S definition you might refresh your memory about how to allow 
it to type inverse video characters also. A short discussion about this follows 
TYPE'S definition, and we may need this feature later on. OK, what about *TYPE? 
*TYPE, like TYPE, takes a count and address on the stack, but instead of 

routing the text directly to an output device, *TYPE sends it instead to a 


LI -3 


holding buffer, located at utJF, wnere it accumulates. As each character is sent 
to the buffer it may be colored, inversed, or capitalized, depending on whether 
these options are loaded and appropriate. Since we loaded all three of these 
options we'll try them presently. When the buffer at BUF overflows with a non- 
blank character, *TYPE formats the line (if any format routines were loaded) 
and then sends it out via a vect called *XMTLN. Roughly, a vect is a word that 
can be "assigned" the meaning of a second word so that when the vect is executed 
it acts precisely like the word last assigned to it.) "XMTLN" in ‘XMTL.N stands 
for "uarr.nil line." The word *XMTLNP is currently assigned to ‘XMTLN and is 
located, in the first release, on or near screen 73. *XMTtMP, and so now ‘XMTLN, 
types out the buffer at BUF and increments a line counter if the printer is on 
and does a few CR's if a printed page is full. After the buffer is output, 
cleared, and the overhanging characters have been moved to the beginning of the 
buffer, ‘TYPE continues to consume the character string. In general there will 
always oe something in the buffer unless it has been cleared. *CR pushes the 
last of the text out of the buffer to the output device, and then clears and 
initializes the buffer with BUFINIT. You probably won't have to do BUFINTT 
yourself unless you are experimenting with the internals of the program. To 
illustrate this point about *CR, type 

2DUP CR CR *TYPE 2DUP ‘TYPE *CR 

This time, since we didn't do *CR after the first *TYPE, the next *1'YPF lacked 
its text right on to what was left in the buffer. 

Now type 

SP! (we'll make a new message) 

: SHOW 2DUP CR CR ‘TYPE *CR ; 

" here is another message for another purpose." 

COUNT 
CTRJST 
CAP SHOW 
SHOW 

See what CAP does? Now try 

ON CAPS 
SHOW 
OFF CAPS 
SHOW 


And what about inverse video? Since ‘TYPE uses TYPE and TYPE as it now stands 
will not print inverse video (it strips the high bit before sending a byte rut.) 
we'll need the modification discussed in the 1.1 Glossary, under TYPE. Here it 
is, type it in, careful ly: 

HEX FT ' TYPE 14 + C! DECIMAL 

and then type 

VI. 1ST 

to see an interesting side note. The high bits of the last byte of (almost) all 


I 1-4 


o 


o 


names are v>t . •••• . tubO / search words . But, bad. to buslnes 

Type 

SHOW 

And you ge trasl 1 becau? ne lord in '/LIST uses PAD for something, 

so your me-.:-. • . • just a reminder, lyy • 

SPi (clear L ; j 1 

" Here is r * a.,.. • . now other features." 

COUNT 
ON CAPS 
ON INVID 
SHOW 

ON INVBK (foi " i nve. su background") 

SHOW 

OFF INVID 
SHOW 

2DUP CR *CR *1 Vi't Pl< “OR R 
etc . 

Play with these things uv a while if you like. When you're done, do 
SP! 

OFF CAPS 
OFF INVID 
OFF INVBK 

and we'll continue. 


Virtual (•'.ciirr 

We used :.r, .. rut it lias a serious short coming .in 

that it wor . i ing g than 255 characters since it only keeps 

a one-byte in m . 'I no (t..,c "extended quote") in this package 

allows loiiQi.-i ; • . • • ••-n: .j i * I. . /"will not work from the key- 
board. Use ■ an • c-trieve the two-byte length count and 

leaves it on i op oi the suck. 1 he-- :• is a demo of X" on screen 120. Take a 
look at it if you like and then : /pc 

120 LOAD 

and a she 4 ! •*. • . . of the demo. Turn your stack on if 

you've turned . t • -• mi. .... .r.n, arid do 

XCOUNT 

OFF CAPS OFF INV! il uf ■ If. . 

FILJST 

SHOW 


a 


If you looked at the screen you may have noticed the right-arrow characters 
near the end of the text. These cause a *CR to be executed at that point in 
the text. See *EMIT code for details. You can make your own control characters 
in a similar fashion. (To type a right arrow character in the valFORTH 1.1 
editor, do ESC followed by CTRL-*). Observe also that no --> was required for 
X" to cross the screen boundary. X" will only stop on finding a final " and so 
may run right on through a disk looking for one if you forget to put it in. 

Well, X" is ok, but not as handy as it might be for general programming. Look 
at screen 122 and then type 

SP! 

122 LOAD 

and a demo message will come back again, indicating that a new word, MSGDEM1, 
now exists. This word will actually pull its message text off the disk. Let's 
do it. Do MTB just to make sure it's not cheating, and then type 

CR CR MSGDEM1 

Notice that we didn't use SHOW this time, just the message name. The messages 
end with a right-arrow. Now, the method that generates this message, namely 
using a new word, V" , followed by a string and then a terminating " and then 
the word M: followed by the message name, does achieve the desired result, but 

at the price of leaving the V", ", M:, and name on the disk along with the 

message. This method is provided only because for those working with a one- 
drive development system it is the easiest, and does not involve any disk 
swapping during compile time. However, for those with two drive systems, and 
those with only one drive but also a tolerance for swapping disks every time a 
message is compiled, the next and last structure in this series is provided. 

It allows fully compact, text-only messages to be compiled on the final product, 
and also allows encryption of the text. We will first do it the way the one- 
drivers need to. 

Look at screen 124. The 80 ALTINIT command sets up an alternate set of disk 
pointers to start at screen 80. This is where, in our example, the text of the 
various messages compiled by this method will be stored on the extra disk we 
formatted at the beginning. Notice that the message starts with X" again. 

Hence, we see that it will first be assembled at PAD before being sent elsewhere. 
Now look at screen 125. There's the terminating " , the defining word, MSG:, 
and the message name, and a short message with ." This final message is just 
there for convenience in this demo and is not needed in general. Type 

124 LOAD 

and when it tells you to put in the destination disk, swap in the extra blank 
disk you formatted, then press START as directed. At the next prompt, swap back 
and press START again. When using this method you must be very careful not to 
reverse your disks or you may wipe out part of your source disk. 


LI-6 



o 


Well, the message is now written to the second disk on screen 80, and the 
word MSGDEM2 knows where to find it. Let's take a quick look to see that it's 
really there. Type 

MTB 

to empty the buffers, and then swap disks again (so that the destination disk 
is in the drive) and do 80 LIST, and then 81 LIST. There's the message. The 

first two strange bytes on screen 80 are the count. Now do 

MTB CR CR MSGDEM2 

and watch the routines pull the message from the disk. While we're here, 
let's send this to the printer. But since your printer may have characteristics 
different from the printer this package is initialized for, we want to adjust a 
couple of things. The first item is a quan named PWID. This is the actual 

number of columns your printer has. The default value is 80. To change it to 

96, for example, type 

96 TO PWID 

The second item is the quan PRTWID which is the width of the area you'd like to 
print to. The default again is 80. To set it to 60, say, type 

60 TO PRTWID 

The third item is how far you'd like to indent. This is the quan PRTIND and 
its initial value is 0. To set it to 10 type 

10 TO PRTIND 

Finally, we want to tell the formatter to send its output to the printer now, 
so type 

PRT : 

(The default setting was to the video display, and will be called back by V I D : ) 

Is your printer ready? Lee's try it. Type 

MSGDEM2 

Since many printers will get confused if a character with the high bit set is 
sent to them you might want to be careful about this. 

Incidentally, the same options are available with the video display. PRTWID 
becomes VIDWID and PRTIND becomes VIDIND. PRT: becomes VID: . There is no "VW1D" 
since the formatter derives this from the positioning of the margins. (The left 
margin is kept by the OS in the byte at 82 decimal, and the right margin byte is 
at 83. Default are 2 and 39 respectively.) 


c 


LI-7 


Any new printer settings only become active when PRT: is executed, and like- 

wise with video settings and V I D : . 

Try 

20 TO VIDWID 
4 TO VIDIND 
VID: 

CR CR MSGDEM2 

38 TO VIDWID (back to default) 

0 TO VIDIND (ditto) 

VID: (move in new values) 

OK, now swap the source disk back in, that is, the TCAF working disk, but keep 
the destination disk handy. Let's load a few (six) more messages. Type 

MTB (to empty the buffers) 

126 LOAD 

and follow the prompts. 

As you can see, any large amount of this single-drive compilation could be 
quite tiresome. Do a short VLIST (abort with any of the three yellow console 
buttons) and look at the new messages. Swap in the destination disk, do MTB, 
and then try 

CR MO 
CR Ml 
etc. 


Encryption and 2-Drive Systems 

There are two more features to point out. They are encryption/decryption (e/d) 
and adjustments for two-drive systems. Concerning e/d, look at screen 105, or 
wherever you find the title EN, DECRYPT or similar. (Do an INDEX if you can't 
find the right screen easily.) Notice that there is a --> at the top of this 
screen which is causing it not to load. Remove this arrow with your editor. 
(Since you're going to reload the system in a minute anyway, it's ok if you 
over-write the system to get an editor in. Get one in somehow.) Now on the 
next two screens you should find the words ENCRYPT and DECRYPT in parentheses. 
(DECRYPT is in three times.) Remove the parens to allow these two words to load. 
Now, you folks with two drives, find the screen where MSG: is defined. (On or 
near screen 112). There are several sets of parens. Leave the ones that 
enclose {ENCRYPT and ... {DECRYPT ... alone. Shift only the ones that are 
around " DR! or " to be around " or DSTDSK " and shift the ones around " DRO 
or " to be around " or SRCDSK ." Just to be on the safe side, here's a 
picture of how the screens should look after these changes. 


LI-8 


FOR ONE OR TWO DRIVE SYSTEMS 

FOR TWO DRIVE SYSTEMS ONLY 

Scr 

« 

105 


Scr 

# 

lie 

0 

( 

Vrtxt: EN, DECRYPT example 

) 

0 

< 

Vrtxt: ALT*! MSG: ) 

1 




1 



a 




a 

s 

ALT*! < X* — ) 

3 




3 


VRTSAV ALTREC V*! 

4 

: 

ENCRYPT ( cl — ca 

) 

4 


ALTSAV VRTREC j 

5 


117 - DUP 0< 


5 



6 


IF 858 + END IF } 


a 

s 

MSG: (X* — ) 

7 




7 


< *ENCRYPT ) 

a 

s 

DECRYPT ( ca — cl 

) 

8 


(BUILDS DR1 ( or DSTDSK ) 

9 


117 + DUP 355 > 


9 


ALTBLK , ALT IN , ALT*! 

1 ® 


IF asa - END IF ? 


10 


FLUSH DR0 ( or SRCDSK ) 

n 




11 


DOES) VRTSAV 

is 




12 


DUP 9 SWAP 3+ @ IN ! BLK ! 

13 




13 


V**EMT < or ) 

14 




14 


( V*0 *DECRYPT X COUNT *TYPE ) 

15 



-> 

15 


VRTREC ; 

Scr 

# 

108 





0 

< 

Vrtxt i V*TP V*0 V**EMT 

) 




s 

• 

V*TP ( -- X* C=PAD] 

) 




3 


VRTC0 DECRYPT NXTVRT VRTCG 




4 


DECRYPT NXTVRT a56 * + ; 





5 







a 

: 

V*C- ( — X* C=PADJ 

) 




7 


PAD a+ V*TP DUP PAD ! 0 





8 


DO VRTC® OVER C! 1+ NXTVRT 





3 


LOOP DROP PAD ; 





10 







11 

: 

V**EMT < — X* C=PAD1 

) 




ia 


V*TP 0 





13 


DO VRTC0 DECRYPT 





14 


*EMIT NXTVRT 





15 


LOOP ; 

> 




Scr 

# 

107 





0 

< 

Vrtxt: V$! 

) 




a 

» 

< 

* 

X 

* 

1 

1 

) 




3 


DUP 9 £+ 0 





4 


DO DUP C0 ENCRYPT 





5 


VRTC ! 1+ NXTVRT 





a 


LOOP DROP 5 





7 







8 







9 







10 







11 







ia 







13 







14 







15 


— 

> 





LI-9 


What this last change does is substitute an automatic disk-shift for the swap 
prompts driven by DSTDSK and SRCDSK. These words are no longer needed and may 
be bypassed later on, if you're comfortable with the way things are working. 

OK, now, although some of you might be able to get these changes in by doing 
some FORGETting and reloading (if you didn't have to overwrite the system before), 
why not just reload the whole (modified) system this time, starting from valFORTH 
1.1. Don't forget the debugger if you want it, and remember to initialize with 
TYPEOUT. Go ahead. We'll wait. 

Now you can repeat the exercises from before, starting where you did the 124 LOAD. 
Two drive systems should have the "destination" disk, the one with the messages 
on it, in the second drive, and the source disk, TCAF, in the first drive. Two- 
drive systems should execute DR1 (which in FORTH means the second drive, which 
is number 2 on Atari systems) before saying message names so that the code will 
read the right drive. Say DRO to go back to the source-code drive. (Released 
programs will of course not want to say DR1 since they will expect the "game" 
or application disk to be in the first drive, DRO, which is default. When you 
are making messages in this way, be sure to start them high enough on disk that 
your AUTO'd program, which will actually do the message retrieval, will fit 
under them.) If you look at screen 80 on the destination disk, what you'll see 
is that the text is now scrambled. The encryption routine used is a simple off- 
set scheme, and would be easy to crack for a serious hobbyist, though not for 
the casual user. If you are interested in a higher degree of security, you can 
encode a whole string at a time with more sophisticated routines. A pair of 
names, $ENCRYPT and $DECRYPT, have been reserved for these routines. We don't 
provide any examples, but a modern text on cryptography might be a good place 
to start looking. Anyway, if you use the names $ENCRYPT and $DECRYPT, and if 
the routines expect an extended string on stack (that is, one with a two-byte 
count at its front end) then they will (hopefully) snap right into the spot 
designated by the parens. 


Windows 

Windows are rectangular areas of the video display. They are not supported 
on the printer, but are supported in both "black and white" graphics 0 mode, 
and colored graphics 1 and 2 modes. Windows may be set up on-the-fly or they 
may be given names so that words can call them up readily. The implementation 
provided here may be used as an example and guide, since you may want your 
windows to act somewhat differently. 

Since it is tricky to interact with a graphics 0 window from the keyboard 
(there is no simple way that we can find to date to create a split-screen 
option) we'll illustrate windows in graphics 1, and so also show how color 
works. Type 

1 GR. 

3 4 10 5 MAKECW 

This makes a Color Window whose upper left hand corner is at the 3rd column 
over, 4th row down (counting the left and top edges as zero), and which is 


( 


LI-10 


10 characters wide and 5 high. We have messages MO through M5 still available, 
so let's send them to the window. Type 

W1ND0UT (counterpart of TVPEOUT) 

OFF CAPS 

0 COLOR MO 

1 COLOR Ml 

2 COLOR M2 

3 COLOR M3 
WCLR 

Note the extra coloration caused by the mix of upper and lower clase. This can 
be canceled by ON CAPS though it restricts the user to two color for the letters 
instead of four. A good practice would be to put all the source text for colored 
windows in upper case. Coloration switches in the middle of a message could be 
implemented by control characters similar to the right-arrow character and its 
meaning of *CR. This is done in *EMIT, you'll remember, and you might even use 
a case statement. 

Numerical formatting is also supported, by the words *. and *.R which are 
direct counterparts of . and .R, except that they go through the formatter 
before outputting. Try 

3456 *. *CR 
7890 7 *.R *CR 

These routines should be used both with WINDOUT and TYPEOUT. Using just . or 
.R will upset the formatting. 

There is also 

2 2 15 8 NAMECW BINGO 

which names a color window with the given parameters as BINGO. When BINGO is 
executed it will clear itself and position the imaginary cursor at its the 
upper lefthand corner. By studying the code, this and other performance 
characteristics may be altered. 


Text Compression 

Finally, there is "true" text compression (TC) itself. TC is intended primarily 
for applications where disk access to messages is not available, such as in 
cassette-booted systems. This utility uses Transient structures which you have 
probably come across before in the packages in this series. Hence, all the 
warnings about memory collisions must to some extent apply. The text compression 
utilities themselves are fairly straightforward to use, but what they do is 
rather complex. Briefly, TC allows the creation of bits of headerless code 
called "tc- texts" that, when executed, put a string onto the stack and then 
jump to the appropriate Forth words, for formatting. These tc-texts come in 
three types in this package, namely, tc-words, tc-suffixes and tc-prefixes. 


LI-11 


The general procedure is to: 


(1) Load the text compression routines. 

(2) Define all needed tc-texts. 

(3) Define all words that use tc-texts within themselves. 

(4) Execute DISPOSE which will sever links to all of the 
tc-text creating and compiling structures, leaving 
only minimal, minimal, headerless structures. 

Since (it turns out) we can load the text-compression routines right on top of 
the rest of the code we already have in, let's do that. Look at the screen in 
the load chain which you modified at the beginning of this excursion. It was 
probably 167. Text compression was not loaded at that time. Note the load 
screen for text compression (probably screen 60) and load it. Because this 
section uses transients you cannot use SAVE to create a bootable copy until 
you have executed DISPOSE to break the links to the transient area. In addi- 
tion, FORGET will act a bit odd, and may cause crashes, so try to avoid using 
it until you have disposed. There are only three new words to learn in text 
compression, namely, W= , P= , and S=. These words define tc-words, tc-prefixes 
and tc-suffixes. For example, 

W= DOG 
W= TAIL 
P= SUPER 
S= 'S 
S= ! 

defines five tc-texts. Type in the five definitions above and then type 

DOG DOG DOG DOG DOG CR *CR 

SUPER DOG CR *CR 

SUPER DOG 'S TAIL ! CR *CR 

The justification, capitalization, coloring, window output, and other options 
will also function with tc-texts. 

Obviously, there is potential for numerous word-name conflicts between tc-texts 
and FORTH. The punctuation marks, for instance P= . P= , P= ! and so on all 
are desirable and all already exist in the FORTH vocabulary. Hence the three 
defining words for tc-texts automatically put the words they define into a 
separate vocabulary named /x . In addition, the name I (Shift-=) has been 
assigned as an alias for FORTH to shorten source code and ease typing. For 
instance, one might have a FORTH word like: 

'• ?TL ( flag -- ) 

IF ^ A_DOG_'S_TAIL_IS_HERE ! *CR I 
ENDIF ; 

By going into the ^ vocabulary the tc-text ! was interpreted properly, 
instead of as the FORTH !. Similarly, by going back into the | ( FORTH ) 
vocabulary, the word ; was interpreted as the FORTH ; rather than as some 
prefix that might have been in the vocabulary. 


LI-12 


Several more points are worth noting: 


* If you are programming short phrases that do not generally run together, 
you can save some memory by defining a <BUILDS D0ES> construct that always 
attaches the *CR to the end of the operation, thus saving two bytes per message, 
with the new <BUILD D0ES> that loaded with this package. 

* If you want to create new types of tc-texts, such as one to deal with 
problems like SHINE ING, just follow the examples of how the words W= P= S= are 
constructed. Smart prefixes that strip trailing vowels, for example, would not 
be difficult to code, but would not necessarily be worth the memory cost. How- 
ever, in a very large application it might well be worth coding a large number 
of spelling rules. 

* To create tc-texts that contain blanks, create a control character that is 
not printed, and use this as the blank. The character we suggest for this is 
the underline, whose ATASCII is 95. Note how the right-arrow, ATASCII 31, is 
picked off by *EMIT. Do the same for 95, only make it perform *SPACE instead 
of *CR as right-arrow does. 

* Some tc-texts will get rather long, and will be cumbersome in source text. 
They can be provided with a no-cost alias. For example, say we had 

W= A_D0G_W I TH_A_B0NE 

We could then add 

TRANSIENT 

: D&B ^ [COMPILE] A D0G_WITH_A__B0NE_ I ; IMMEDIATE 

PERMANENT 

This alias would be removed by DISPOSE, as would, of course, the tc-text name 
A DOG WITH A BONE, leaving only the headerless tc-text itself. 

* As set up, the Transient system is 4000 bytes below the display list. This 
may not be enough for some applications. The way to find out how much room you 
have left in the transient area is to type 

TRANSIENT 741 0 HERE - U. PERMANENT 

You might even define a word to do this. Call it TFREE. A trap in CREATE, 
and so also in : is designed to keep you from actually running into the 
display list by simply aborting the definition in progress when there are 
less than 128 bytes left. 

* Finally, always remember to DISPOSE when you're done with the transients. 

If you forget and do SAVE you will not get a working system. 

This system of compression is quite compact, costing only two bytes to produce 
output from a tc-text. The cost in memory of producing the tc-text of a word 
of n letters, (not even counting the trailing blank) is only n + 2. 


LI-13 


o 


o 




TEXT COMPRESSION AND AUTO TEXT FORMATTING GLOSSARY 


Basic Commands 

*." ( - ) 

Like , but sends string to the active formatting/outputting 
routines. 

*TYPE ( addr count -- ) 

Like TYPE, but sends string of count characters starting at addr to 
the active formatting/outputting routines. 

*CR ( - ) 

Somewhat like CR in that it causes a carnage return. In 
addition, *CR first formats and flushes the buffer to the output device, 
and clears the buffer after doing so. 

*EMIT ( c -- ) 

Like EMIT except sends the character c to the formatter, instead 
of directly to the output device. 

*SPACE ( — ) 

Sends a single character of value in the quan BKGND to the 
formatter, through *EMIT. 

♦SPACES ( n -- ) 

Sends n characters of value in the quan BKGND to the formatter, 
through *EMIT. 

♦BACKS ( -- ) 

Similar to action of delete key. Backs up the formatter buffer 
pointer, BPTR, one location and fills new location with BKGND value. 

RGTJST ( - ) 

Sets up formatter for right justification. 

LFTJST ( -- ) 

Sets up formatter for left justification. 

CTRJST ( - ) 

Sets up formatter for center justification. 


L 1 1 - 1 


FILJST 


( - ) 


Sets up formatter for fill justification. 

INVID ( f — ) 

ON INVID means text will be output in inverse video; OFF INVID 
means normal video. 

INVBK ( f — ) 

ON INVBK means background of text will be output in inverse 
video. OFF INVID means normal video. 

CAP ( — ) 

Causes capitalization of the next byte processed by *EMIT or *TYPE. 

CAPS ( f - ) 

ON CAPS means subsequent formatted text will be capitalized if 
lower case. OFF CAPS means text will be printed as-is. 

COLOR ( b -- ) 

New color register b will be used for color of subsequent text 
output to windows in Graphics modes 1 and 2. 

TYPEOUT ( — ) 

Initialization routine for the formatter. Either TYPEOUT or 
WINDOUT must be executed before the first attempt to output text from 
the formatter or the system may crash. TYPEOUT directs the formatter 
to use TYPE as its actual output routine, allowing output to the display 
screen or printer. 

WINDOUT ( — ) 

Initialization routine for the formatter. Either TYPEOUT or 
WINDOUT must be executed before the first attempt to output text from 
the formatter or the system may crash. WINDOUT directs the formatter 
to use window routines for output. A window must be created before 
attempting to use window output or the system may crash. See also 
NAMWND. 


LI 1-2 


Quans, vects, and subcommand s 


FDIR ( -- +-1 ) 

A quan that holds the next direction to be used by the f i 11- 
justification routines when padding the text in the formatting buffer 
with blanks. 


*JUST ( — ) 

A vect used to point to the routine that performs whatever 
justification action is current. Altered by LFTJST, RGTJST, CTRJST, 
and FILJST. 


BKGND ( — n ) 

Quan which holds the value of the background character to be used 
when clearing the formatting buffer. Generally either 32 (blank) or 
160 (inverse blank.) See INVBK. 

EOB ( - n ) 

Quan which points to the location in the formatter buffer 
corresponding to the last allowable position in the current output 
width. Set up by various routines including PRT:, VID:, and window- 
creating routines. Stands for "end of buffer." 

BPTR ( - n ) 

Quan which points to the next available location in the formatter 
buffer. May be user-altered for special purposes, but should not be 
placed lower than BUF or higher than EOB. Stands for "buffer pointer." 

WWID ( -- n ) 

Quan which holds width of field to which text will be output. 

Used to set up EOB, which is actually used by the formatting routines. 
See EOB. Stands for "window width" though windows as defined elsewhere 
need not exist. 

*XMTLN ( — ) 

A vect that points to the routine to be used to move text from the 
formatter buffer to the output device. Set up at present either by 
TYPEOUT or WINDOUT. Stands for "transmit line." 


BUF 


A label that points to the beginning of the formatter buffer area. 
This area need only be three bytes longer than the longest line to be 
formatted. 


INVBK ( ON or OFF — ) 

When ON, background character output by formatter in 0 graphics 
mode will be inverse video blank. When OFF, this character will be 
normal video blank. Sets up BKGND. See BKGND. 


LI 1-3 


BUFCLR 


( - ) 


Fills the formatter buffer with BKGND. 

BUFINIT ( — ) 

Fill the formatter buffer with BKGND, sets up EOB using WWID 
and BUF, and points sets BPTR equal to BUF. 


*TINT ( c - c ) 


A vect that either points to the coloring routines when a color 
window is active, or to NOOP when a 0 graphics window is active. 


*CAP 


( c — c ) 


Capitalization routine. 


*INV 


( c — c ) 


A vect that either points to the inversing routine when a 0 
graphics window is active, or to NOOP when a color window is active. 


Text Compression 

W= xxx, ( -- ) 

xxx: ( -- ) 

Creates a tc-word-compiling word, named xxx, and a headerless 
tc-word which when executed sends the string xxx through the formatter 
followed by *SPACE. xxx when executed, compiles in the cfa of this 
tc-word. W= and xxx are both in transient area and so are disposed by 
DISPOSE. 

P= xxx, ( -- ) 

xxx, ( — ) 

Creates a tc-prefix-compiling word, named xxx, and a headerless 
tc-prefix which when executed sends the string xxx through the 
formatter, xxx when executed, compiles in the cfa of this tc-prefix. 
P= and xxx are both in the transient area and so are disposed by 
DISPOSE. 

S= xxx, ( -- ) 

xxx, ( -- ) 


Creates a tc-suffix-compil ing word, named xxx and a headerless 
tc-suffix which when executed sends the string xxx through the formatter 
preceded by *BACKS and followed by *SPACE. xxx, when executed, compiles 
in the cfa of this tc-suffix. S= and xxx are both in the transient 
area and so are disposed by DISPOSE. 


LI 1-4 


Typed Ou tput 

PRTWID ( -- n ) 

A quan containing the width of the area to be printed when printer 
output from the formatter has been selected by PRT:. PRT : , among other 
things, moves PRTWID to WWID. 

PRTIND ( — n ) 

A quan containing the number of spaces the printer is to indent 
when outputting from the formatter. PRTIND is moved to PVIND by PRT: 

PVIND ( - n ) 

A quan containing the number of spaces the output device is to indent 
when outputting from the formatter. Set up by PRT: from PRTIND or by VID: 
from VIDIND. 

PWID ( - n ) 

A quan containing the number of columns the printer is actually able 
to print as it is currently configured, and independent of the formatting 
routines. 

VIDIND ( — n ) 

A quan containing the number of spaces the output routines is to 
indent when outputting from the formatter. VIDIND is moved into PVIND 
by VID:. 

VIDWID ( -- n ) 

A quan containing the width of the area to be written when video 
output from the formatter has been selected by VID:. VID:, among other 
things, moves VIDWID to WWID. 


PRT: ( - ) 

Directs TYPEd output to the printer, and moves appropriate values 
into WWID and PVIND. 

VID: ( - ) 

Directs TYPEd output to the video display, and moves appropriate 
values into WWID and PVIND. 

PRINIT ( -- ) 

Resets PCTR, the printed line counter. 


*XMTLNP ( — ) 


Routine sent to the vect *XMTLN by TYPEOUT. Routes output 
through TYPE. 


LI 1-5 


Wi ndows 


WADR ( — ) 

Address in memory corresponding to character position in upper 
lefthand corner of current window. 

WHGT ( — ) 

Height in lines of currently active window. 

LPTR ( — ) 

Counter that holds number of next line in window to which text is 
to be written. If LPTR points beyond the window then scrolling will 
occur at next output. 

B/LN ( - n ) 

Bytes per line. Necessary datum for scrolling and clearing routines 
for windows. 


WCLR ( - ) 

Fills the current window with BKGND. 

NAMWND ( wadr wid hght b/ch byt/ln — ) 

One of many possible window-defining structures. Accepts window 
upper lefthand corner address, its width, height, byte-character, and 
the bytes/ln of the current graphics mode. 

NAMEBW xxx, ( column row wid hgt -- ) 
xxx: ( -- ) 

Names a 0 graphics window for later activation. 

MAKEBW ( col row wid hgt -- ) 

Establishes a 0 graphics window immediately but does not name 
it for later retrieval. 

NAMECW xxx, ( col row wid hgt -- ) 
xxx: ( -- ) 

Names a 1 or 2 graphics window for later activation. 

MAKECW ( col row wid hgt -- ) 

Establishes a 0 graphics window immediately but does not name 
it for later retrieval. 


LI 1-6 


Virtual (Disk-based) Memory 


(A pointer to a byte on disk is implemented by the two system variables, BLK and 

IN in the fig model. BLK contains the block number pointed to and IN contains 

the number of bytes into the block the byte in question is located.) 

VRTC0 ( -- b ) 

Fetches the byte pointed to on disk by the system variable BLK and 
IN. (BLK is the block number, and IN is the number of bytes into the 
block the desired byte is located.) 

VRTC ! ( b — ) 

Stores the byte on stack to the location on disk pointed to by BLK 
and IN. See VRTC@. 

VRTSAV ( — ) 

Saves the values of system variables BLK and IN to quans OBLK and 
OIN respectively. 

VRTREC ( — ) 

Recalls the values of the system variables BLK and IN from the 
quans OBLK and OIN respectively. 

NXTVRT ( -- ) 

Bumps the system variables BLK and IN as required to point to the 
next location in virtual memory. 

RELVRT ( offset — ) 

Takes an offset on stack and alters the system variables BLK 
and IN as necessary to point offset bytes from their initial virtual 
memory location. 


V" ( -- blk in ) 

Leaves the values of BLK adn IN on the stack at the time it is 
executed and then scans the virtual memory pointer formed by BLK and 
IN forward until the next " character is encountered. 

XMTV ( — ) 

Starting from the location in virtual memory pointed to by BLK 
and IN, outputs characters through *EMIT until a " character is 
encountered, which it does not output. 


LI 1-7 


XCOUNT 


( adr -- adr+2 xcount ) 


Extracts a two-byte count from an extended string, and leaves 
the count on top of the address + 2. 

M: xxx, ( blk in -- ) 

xxx: ( -- ) 

Generally used after V". Takes a virtual memory pointer from 
the stack, and creates a word xxx which when executed will push the 
virtual memory pointer to BLK and IN and then exectue XMTV, thus 
retrieving a message from disk. See Strolling... for an example. 

V: xxx, ( blk in -- ) 

xxx: ( — ) 

Creates a word xxx which when executed pushes the virtual memory 
pointer which was on stack at the time of its creation to BLK and IN. 

VSTP ( — XCOUNT ) 

Extracts a two-byte string count from the disk location to which 
BLK and IN point, leaves it on stack, and bumps the virtual memory 
pointer made up of BLK and IN twice. 

V$@ ( - X$=PAD ) 

Extracts the extended string in virtual memory pointed to by BLK 
and IN. The string is left at PAD. 

V$*EMT ( — ) 

Sends the extended string pointed to by BLK and IN through *EMIT. 

V$ ! ( X$ - ) 

Stores the extended string on stack to virtual memory starting at 
the location pointed to by BLK and IN. 

X" ( — X$=PAD ) 

Reads the following characters until the delimeter " as an 
extended string and stores the string at PAD. Operates from screens 
only. Crosses block and screen boundaries without additional code. 

Do not use --> to cross screens, as --> will just become part of the 
stri ng. 

ALTSAV ( — ) 

Copies variables BLK and IN to quans ALTBLK and ALTIN respectively. 

ALTREC ( — ) 

Copies quans ALTBLK and ALTIN to variable BLK and IN respectively. 


LI 1-8 


ALTINIT 


( scr -- ) 


Sets up ALTBLK and ALTIN to point to screen scr. ALTBLK and ALTIN 
form an auxiliary virtual memory pointer that is used to keep track of 
how far messages have been compiled onto the destination disk. 

ALTS! ( X$ — ) 

Like V$! except stores string through alternate virtual memory 
pointers made up of ALTBLK and ALTIN. 


LII-9 


p 


c 


L1II. 


TEXT COMPRESSION AND AUTO TEXT FORMATTING 
SUPPLIED SOURCE LISTING 


Screen: 1 Screen: 4 


0 

0 

< Transients: setup ) 

1 

1 

’ < QUAN > ( 5 KLOAD ) 

£ 

£ 


3 

3 

BASE 0 DCX 

4 

4 


5 

5 

HERE 

6 

6 


7 

7 

741 0 4000 - DP ! 

8 

a 

( SUGGESTED PLACEMENT OF TAREA ) 

9 

9 


10 

10 


11 

u 

HERE CONSTANT TAREA 

IS 

13 

QUAN TP 

13 

13 

QUAN TPFLAG 1 TO TPFLAG 

14 

14 

QUAN OLDDP < old HERE ) TO OLDDP 

15 

15 

— > 


Screen : 
0 
1 
g 

3 


Screen : 5 

0 ( Xsients: TRANSIENT PERMANENT ) 

1 ( Expanded from code by Phillip) 
£ ( Wasson, in Forth Dimensions ) 
3 


4 

5 

6 

7 

8 
9 

10 

11 

IS 

13 

14 

15 


4 : TRANSIENT < — ) 

5 TPFLAG NOT 

6 IF HERE TO OLDDP TP DP ! 

7 1 TO TPFLAG 

8 END IF ; 

9 

10 : PERMANENT ( — ) 

1 1 TPFLAG 

1£ IF HERE TO TP OLDDP DP ! 

13 0 TO TPFLAG 

14 END IF ; 

15 — > 


Screen : 3 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

13 

13 

14 

15 


Screen : 6 

0 < Transients: DISPOSE ) 

1 : DISPOSE PERMANENT 

£ CR . " Disposing..." VOC-LINK 

3 BEGIN DUP 0 53£79 C! 

4 BEGIN 0 DUP TAREA U< 

5 UNTIL DUP ROT ! DUP 0= 

6 UNTIL DROP VOC-LINK 0 

7 BEGIN DUP 4 - 

8 BEGIN DUP 0 53379 C! 

9 BEGIN PFA LFA 0 DUP TAREA U< 

10 UNTIL 

11 DUP ROT PFA LFA ! DUP 0= 

13 UNTIL DROP 0 DUP 0“ 

13 UNTIL DROP [COMPILE! FORTH 

14 DEFINITIONS . " Done" CR ; 

15 PERMANENT BASE ! 


7 


Screen : 
0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

11 

12 

13 

14 

15 


Screen: 10 

0 ( Quan: ASSIGN > 

1 
2 

3 

4 > ( CFALIT 

5 s ASSIGN [COMPILE! CFALIT ; 

6 IMMEDIATE — > ) ( ) 

7 


s 

: ASSIGN 

< — cfa ) 

9 

STATE 0 


10 

[COMPILE! [ 


11 

[COMPILE! » CFA 

SWAP 

12 

IF 1 


13 

END IF [COMPILE! 

LITERAL 5 

14 

IMMEDIATE 

15 


— > 


Screen: 8 Screen: 11 


0 

0 

< 

Quan: TO AT 


1 

1 




2 

2 

8 

TO 


3 

3 


-FIND 0- 0 9ERROR 

DROP 

4 

4 


STATE 0 


5 

5 


IF , 


6 

8 


ELSE EXECUTE 


7 

7 


END IF j IMMEDIATE 


8 

a 



9 

9 

8 

AT 


10 

10 


-FIND 0= 0 7ERROR 

DROP 

1 1 

n 


2+ STATE 0 


12 

12 


IF , 


13 

13 


ELSE EXECUTE 


14 

14 


END IF ; IMMEDIATE 


15 

15 


< corrected ) 



Screen: 9 Screen: 12 


0 

0 

< Quan: [206! 

C 2 ! 

4! 


) 

1 

1 







2 

2 

ASSEMBLER HEX 






3 

3 







4 

4 

LABEL <206) 






5 

5 

A0 C, 06 C, 

B1 

o, 

W 

c, 

48 C, 

6 

6 

C 8 C, B1 C, 

W 

C, 

4C 

c, 

PUSH , 

7 

7 







8 

8 

LABEL (2! 4) 






9 

9 

A0 C, 04 C, 

B5 

C, 

00 

c. 

91 C, 

10 

10 

W C, C 8 C, 

B5 

C, 

01 

c, 

91 C, 

11 

11 

W C, 4C C, 

POP , 




12 

12 







13 

13 







14 

14 







15 

15 






— > 


) 


UMAX UMIN HIDCHR ) 


Screen s 1 3 

0 < Quan: C2V63 

1 

2 LABEL (2V6) 


3 

A0 

c, 

07 

c, 

B1 

c, 

w 

C, 

AS C, 

A 

88 

c, 

B1 

c. 

W 

c, 

85 

C, 

W C, 

5 

68 

C, 

85 

c, 

W 

1 + 

c, 



6 

A0 

C, 

00 

c, 

AC 

C, 

w 

1 - 

» 


7 

8 
9 

10 
11 
12 
13 
1 A 

15 — > 


Screens 1A 

0 ( Quan s patch for CREATE > 

1 

2 DCX 

3 

A : <PTCH) ( system ) 

5 SWAP > R R = 251 R = 2A9 R> = 

6 OR OR ; 

7 

8 : PTCH ( system > 

9 IF [ ’ (PTCH) CFA 3 LITERAL 

10 ELSE C » = CFA 3 LITERAL 

11 END IF 

12 C > CREATE 63 + 3 LITERAL ! ; 

13 
1A 

15 --> 


Screens 15 

0 < Quans QUAN VECT ) 

1 

2 s QUAN 

3 ON PTCH LABEL -2 ALLOT 

A (206) , (2 ! A) , 

5 C ’ VARIABLE A + 3 LITERAL , 

6 2 ALLOT OFF PTCH ; 

7 

8 s VECT 

9 ON PTCH LABEL -2 ALLOT 

10 (2V6) , (2 ! A) , 

11 i » VARIABLE A «- 3 LITERAL , 

12 C ’ NOOP CFA 3 LITERAL , 

13 OFF PTCH 5 
1A 

15 


Screens 16 

0 < Utilss 

1 

2 s UMAX ( ul u2 — u3 ) 

3 2DUP U < 

A IF SWAP END IF 

5 DROP 5 

6 

7 : UMIN ( ul u2 — u3 ) 

8 2DUP U> 


9 

10 

11 

IF SWAP 
DROP 5 

ENDIF 


12 

13 

’ < HIDCHR 
s HIDCHR 

) ( 


1A 

15 

-1 9A ! 

I > 

--> 


Screens 17 





0 

( 

Utilss 

Ss Pi 



) 

1 







2 

f 

( Ss sS 

> < ) 




3 

HEX 





A 







5 

1 

Ss 



( f — 

> 

6 


PFLAS 0 

SWAP 




7 


IF 1 OR 

ELSE FE 

AND 

ENDIF 


8 


PFLAG ! 

5 




9 







10 

3 

Ps 



( f — 

) 

11 


PFLAG 0 

SWAP 




12 


IF 2 OR 

ELSE FD 

AND 

ENDIF 


13 


PFLAG ! 

5 




1A 







15 

DCX 






Screens 18 
0 
1 
2 
3 
A 

5 

6 

7 

8 
9 

10 

11 

12 

13 

1A 

15 


Screen : 19 


Screen t £2 


0 

0 

( 

Screen code 

conversion 

words 

1 

1 







2 

2 

SWAP ! 

91 C, 

C4 C, 

68 C, 

29 C, 

3 

3 


80 C, 

11 C, 

C4 C, 

91 C, 

C4 C, 

4 

4 


C8 C, 

DO C, 

D3 C, 

E6 C, 

C7 C, 

5 

5 


E6 C, 

C5 C, 

4C C, 

« 


6 

6 







7 

7 







a 

8 

a 

> SCD 

SP® DUP 1 > BSCD j 


9 

9 

3 

SCD> 

SP® DUP 1 BSCD> ; 



r 


10 

11 

12 

13 

14 

15 


10 

11 

1£ 

13 

14 

15 


BASE 


Screens £0 Screen: 

0 ( Screen code conversion words ) 0 

1 1 


£3 


2 

BASE e 

HEX 







£ 

3 









3 

4 

CODE > BSCD 




( a a 

n — ) 

4 

5 

A9 C, 

03 

c. 

20 

c, 

SETUP 

• 

5 

6 

HERE 

C4 

c, 

C2 

c, 

D0 

c, 

07 C, 

6 

7 

C6 C, 

C3 

C, 

10 

C, 

03 

c, 

4C C, 

7 

8 

NEXT 

> 


B1 

C, 

C6 

c, 

48 C, 

8 

9 

29 C, 

7F 

C, 

C9 

C, 

60 

c, 

B0 C, 

9 

10 

0D C, 

C9 

C, 

£0 

C, 

B0 

c, 

06 C, 

10 

1 1 

18 C, 

69 

c, 

40 

C, 

4C 

c. 

HERE 

11 

12 

2 ALLOT 

38 

C, 

E9 

C, 

20 

c. 

HERE 

12 

13 

SWAP ! 

91 

C, 

C4 

C, 

68 

C, 

29 C, 

13 

14 









14 

15 








— > 

15 


o 


Screen: £1 Screen: 

0 ( Screen code conversion words > 0 

1 1 


24 


2 

80 C, 

11 

c, 

C4 

c. 

91 

c, 

C4 C, 

2 

3 

C8 C, 

D0 

c. 

D3 

c. 

E6 

c. 

C7 C, 

3 

4 

E6 C, 

C5 

c, 

4C 

c, 

i 


c; 

4 

5 









5 

6 

CODE BSCD) 




( a a 

n — ) 

6 

7 

A9 C, 

03 

c. 

20 

c, 

SETUP 

« 

7 

a 

HERE 

C4 

c, 

C2 

C, 

D0 

c. 

07 C, 

8 

9 

C6 C, 

C3 

c, 

10 

C, 

03 

c, 

4C C, 

9 

10 

NEXT , 



B1 

C, 

C6 

c. 

48 C, 

10 

li 

£9 C, 

7F 

c. 

C9 

C, 

60 

c, 

B0 C, 

11 

12 

0D C, 

C9 

c, 

40 

c, 

B0 

c, 

06 C, 

12 

13 

18 C, 

69 

c, 

£0 

C, 

4C 

c, 

HERE 

13 

14 

2 ALLOT 

38 

c, 

E9 

c, 

40 

C, 

HERE 

14 

15 








— > 

15 


c 


1 

a 

3 

4 

5 

& 

7 

8 

9 

10 

11 

12 

13 

14 

15 

icri 

0 

1 

2 

3 

4 

5 

& 

7 

a 

9 

10 

i i 

12 

13 

14 

15 

cri 

0 

1 

2 

3 

4 

5 

6 

7 

a 

9 

10 

11 

12 

13 

14 

15 


> 


25 


Screen: 28 


0 

1 

2 

3 

4 

5 

a 

7 

a 

9 

10 

11 

12 

13 

14 

15 


< AF0: quans vects 


QUflN BKGND 
BL TO BKGND 
QUflN EOB 
QUflN BPTR 
QUflN MW ID 
QUflN B/C 
QUflN LWD ( 
VECT *XMTLN 


< background chr ) 

< end of buffer ) 
( buffer pointer > 

< characters/1 ine ) 

< bytes/character ) 
1st chr of last wd ) 

< send fmted In ) 


LABEL BUF 123 ALLOT ( buffer ) 
< Need only be longest line +3 ) 


— > 


26 Screen i 29 

0 < AF0s ?BL INVBK ) 

1 

2 s ?BL ( — f ) 

3 C<? 31 AND 0= ; 

4 

5 s INVBK ( f — ) 

6 IF 160 

7 ELSE BL 

8 END IF TO BKGND ; 

9 
10 
11 
12 

13 

14 

15 — > 


27 Screen: 30 

0 < AF0: BUFCLR BUF INI T ) 

1 

2 : BUFCLR < -- ) 

3 BUF MW ID BKGND FILL ; 

4 

5 : BUFINIT ( — ) 

6 WWID BUF + 1- TO EOB 

7 BUFCLR BUF TO BPTR ; 

8 
9 

10 38 TO WWID 

11 BUFINIT 

12 

13 < Setup for 0 GR. display ) 

14 

15 


'"'RJ ~CJ 


Screen: 31 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen : 34 

0 ( R, cjust: 

1 

2 * < #JUST ) ( 16 KLOPD ) 

3 : (RCJ) ( b 

4 >R BUF BUF EOB LCHR - 

5 R> / DUP > R + 

6 LCHR BUF - 1+ (CMOVE 

7 BUF R) BKBND FILL ] 

8 

9 : -'RJ < 

10 1 (RCJ) j 

11 

12 : •'CJ ( 

13 2 (RCJ) 5 

14 

15 


Screen: 32 Screen: 35 


0 

( Justify: 

*JUST 

LCRH -'LCHR ) 

0 

( R, cjust : RBT, LFT, CTRJST 

1 




1 


2 

VECT *JUST 



2 

: RSTJST ( 

3 

QURN LCHR 



3 

PSSIGN '‘RJ TO *JUST ; 

4 




4 


5 

: ■''LCHR 


( — ) 

5 

: LFTJST ( 

6 

EOB 



6 

PSSIGN NOOP TO *JUST j 

7 

BEGIN DUP 

BUF U) 

OVER ?BL PND 

7 


8 

WHILE 1- 



8 

: CTRJST ( 

9 

REPEPT TO 

LCHR ; 


9 

PSSIGN A CJ TO #JUST j 

10 




10 


11 




11 


12 




12 


13 




13 


14 




14 


15 




15 



Screen: 33 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen : 36 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


37 




Screen : 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

Id 

11 

IS 

13 

14 

15 


Screen : 40 

0 < Fj ust : A FJ FILJST ) 

1 

£ i ~FJ < — ) 

3 1 TO ?FJ 

4 BEGIN LCHR EOB U< ?FJ AND 

5 WHILE FDIR 0) 

6 IF BUF ELSE LCHR END IF 

7 TO FPTR FPASS 

8 REPEAT FDIR MINUS TO FDIR ; 

9 

10 : FILJST ( — > 

11 ASSIGN ~FJ TO *JUST j 
IS 

13 

14 

15 


o 


Screen : 38 

0 ( Fjust: quans <FPTR> 

1 

£ ’ < *JUST ) ( 16 KLOAD ) 

3 

4 QUAN FDIR 1 TO FDIR 

5 QUAN FPTR 

6 QUAN ?FJ 

7 

8 : <FPTR> 

9 FPTR BUF U< NOT 

10 FPTR LCHR U> NOT AND 

1 1 
12 


13 

14 

15 


) 


( f — ) 


— > 


Screen: 41 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


Screen : 39 

0 < Fjust: FPASS ) 

1 

£ : FPASS ( — ) 

0 TO ?FJ 

BEGIN LCHR EOB U< <FPTR> AND 
WHILE FPTR ?BL 
IF 1 TO ?FJ 

FPTR FPTR 1+ EOB FPTR - 
(CMOVE 1 AT LCHR +! 

BEGIN FDIR AT FPTR +i 
FPTR ?BL NOT <FPTR> NOT OR 
UNTIL 

END IF FDIR AT FPTR +! 

REPEAT ; 

— > 


Screen : 4£ 

0 < AF1 i CLWDI MOVWD RETWD ) 

1 ’ ( BKGND ) ( ;S ) 

£ 

3 : (LWD) < — ) 

4 BPTR 

5 BEGIN 1- DUP BUF U< 

6 OVER ?BL OR 

7 UNTIL 1+ TO LWD ; 

8 

9 : MOVWD ( — ) 

10 LWD HERE BPTR LWD - <CMOVE ; 

11 

1£ : RETWD ( — ) 

13 HERE BUF BPTR LWD - 

14 DUP > R CMOVE 

15 R> BUF + TO BPTR 5 — > 


c 


.3 

4 

5 

6 

7 

8 
9 

10 
1 1 
1£ 

13 

14 

15 


Screen: 43 


Screen: 46 


0 

( 

AFl: CSNDLNI SENDLN 

) 

0 

( 

AFl : ♦TYPE 

1 




1 



£ 

: 

(SNDLN) 

( — ) 

2 

: 

*TYPE ( addr count — 

3 


’ < *JUST ''LCHR ♦JUST ) < 

) 

3 


BEGIN DUP 0> 

4 


♦XMTLN BUFCLR ; 


4 


WHILE 

5 




5 


OVER Ce 127 AND 

6 

: 

SENDLN 

( — ) 

6 


♦EMIT 1- SWAP 1+ SWAP 

7 


(LWD) LWD BUF U> 


7 


REPEAT 2DR0P ; 

a 


IF MOVWD LWD EOB LWD - 

1 + 

8 



3 


0 MAX BKGND FILL 


3 



10 


END IF (SNDLN) 


10 



li 


LWD BUF > 


11 



12 


IF RETWD 


1 £ 



13 


ELSE BPTR 1- C@ BUF C! 


13 



14 


BUF 1+ TO BPTR 


14 



15 


END IF ; 

— > 

15 



Screen: 44 


Screen : 47 

0 

( 

AFl: ♦CR 

) 

0 

< 

AFl: *SPACECS3 *BACKS 

1 




1 



d 

s 

*CR 

( — ) 

£ 

s 

♦SPACE ( — 

3 


BPTR BUF = 


3 


BKGND ♦EMIT ; 

4 


IF BUF WWID BKGND FILL 


4 



5 


’ < *JUST 


5 

: 

♦SPACES ( n — 

6 


ELSE ''LCHR ) < ) 


6 


0 MAX -DUP 

7 


’ ( "'FJ ASSIGN A FJ ) ( 0 

) 

7 


IF 0 DO ♦SPACE LOOP 

8 


* ( * JUST 


8 


ENDIF ; 

9 


AT ♦JUST e <> 


3 



10 


IF ♦JUST 


10 

; 

♦BACKS 

1 1 


ENDIF < ) 


11 


BPTR 1- BUF UMAX TO BPTR 

12 


END IF 


12 


BL > ( ♦INV ♦INV ) ( ) 

13 


♦XMTLN BUFINIT ; 


13 


BPTR C! ; 

14 




14 



15 



— > 

15 



Screen: 45 


Screen: 48 

0 

( 

AF1 : ♦ EMIT 

) 

0 

< 

AFl: O. "I ♦. " 

1 




1 



£ 

s 

*EMI T ( 

c — ) 

£ 

; 

(♦. ") ( -- 

3 


DUP 31 = 


3 


R COUNT DUP 1+ 

4 


IF DROP *CR 


4 


R> + >R *TYPE ; 

5 


ELSE ’ < *TINT *'( I NT ) ( 

) 

5 



6 


’ ( ♦CAP ♦CAP ) ( 

) 

6 

; 

♦ . " 

7 


’ ( ♦ INV ♦ INV ) ( 

) 

7 


ASSIGN TYPE ASSIGN (. ") 

6 


BPTR C! 1 AT BPTR +! 


8 


[ ’ . " 13 + 3 LITERAL 

3 


BPTR EOB 1+ U> 


3 


ASSIGN <♦. ") OVER ! 

10 


IF BPTR 1- ?BL 


10 


C ’ . " 35+1 LITERAL 

11 


IF BPTR EOB £+ MIN TO 

BPTR 

11 


ASSIGN ♦TYPE OVER ! 

12 


ELSE SENDLN 


12 


[COMPILE! ■ " 

13 


ENDIF 


13 


<ROT ! ! ; IMMEDIATE 

14 


ENDIF 


14 



15 


ENDIF ; 

— > 

15 




>c 


- ) 


-> 


- ) 


c 


— > 


- ) 


c 


Screen : 49 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen s 52 

0 ( Capitalization: CAPCS3 

1 

£ QUAN ?CAP 

3 QUAN ?CAPLK 

4 

5 

6 : CAP < 

7 1 TO ?CAP 5 
B 

9 > CAPS { f 

10 DUP TO 7CAPLK TO ?CAP ; 

11 

12 OFF CAPS 

13 

14 

15 


Screen: 50 

0 ( Coloring: *TINT etc. ) 

1 

2 ’ ( > SCD ) ( 10 KLOAD ) 

3 

4 VECT *TINT 

5 

6 ’ t CLRBYT ) ( 

7 0 VARIABLE CLRBYT 

8 : COLOR CLRBYT ! ; ) 

9 

10 : •''TINT ( c — c ) 

11 > SCD CLRBYT 0 

12 64 * OR SCD) ; 

13 

14 ASSIGN ~TINT TO *TINT 

15 


Screen: 51 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen : 53 

0 < Capitalization: *CAP 

1 

2 : *CAP < c - 

3 ?CAP 

4 IF 

5 DUP 127 AND DUP 

6 122 <= SWAP 

7 97 >= AND 

8 IF 32 - 

9 END IF 7CAPLK TO ?CAP 

10 END IF ; 

11 
12 

13 

14 

15 


Screen : 54 

0 ( Inverse Video: *INV etc 

1 

2 QUAN ? INV 

3 VECT *INV 

4 

5 : INVID < f 

6 128 * TO ?INV ; 

7 

8 : A INV < c - 

9 ?INV OR ; 

10 

11 ASSIGN ''INV TO *INV 

12 

13 

14 

15 


etc. ) 

— ) 
-- ) 

— > 
) 

- c ) 


) 

— ) 
■ c ) 


OFF INVID 


) 


Screen : 55 

0 
1 
a 

3 

4 

5 

6 
7 

a 

9 

10 

11 

1 £ 

13 

14 

15 


Screen : 56 

0 ( Efficient (BUILDS. .. DOES) ) 

1 ( Partly after G. B. Lyons ) 

a — > ( Pick up C, code nxt scr ) 

3 ASSEMBLER HEX 

4 

5 LABEL (WIP) 

6 W )Y LDA, CLC, 3 # ADC, 

7 IP STA, INY, W ) Y LDA, 

8 0 # ADC, IP 1+ STA, 

9 DEY, RTS, 

10 

11 LABEL (DOES) 

1£ IP 1+ LDA, PHA, IP LDA, PHA, 

13 (WIP) JSR, * VARIABLE 4 + 

14 JMP, 

15 DCX — > 


Screen s 58 

0 ( Efficient (BUILDS. .. DOES) 

1 

3 s DOES) 

3 COMPILE ( ;CQDE) 

4 4C C, (DOES) , j IMMEDIATE 

5 

6 t (BUILDS 

7 CREATE SMUDGE 5 

8 

9 DCX 
10 
11 
18 

13 

14 

15 


Screen 1 59 

0 
1 
a 

3 

4 

5 

6 
7 

a 

9 

10 

11 
la 

13 

14 

15 


Screen s 57 






Screen 1 60 


0 

1 

( Efficient (BUILDS. 

..1 

DOES) ) 

0 

1 

( Txt comps 

TLABEL 

X 

a 

ASSEMBLER HEX 






1 

a 

’ ( TRANSIENT 

) ( £ KLOAD ) 

3 







3 

» ( 'WIP 

) ( £8 KLOAD ) 

4 

LABEL 'WIP 






4 



5 

Bl C, W C, 

18 

c. 

69 

c. 

03 C, 

5 

TRANSIENT 


6 

85 C, IP C, 

ca 

C, 

Bl 

c, 

W C, 

6 



7 

69 C, 00 C, 

85 

C, 

IP 

1 + 

c, 

7 

s TLABEL 

( — 

a 

88 C, 60 C, 






8 

HERE TRANSIENT 

9 







9 

CONSTANT PERMANENT 

10 

LABEL (DOES) 






10 

[COMPILE! ASSEMBLER 1 

11 

A5 C, IP 1+ 

c, 

48 

c, 



11 



la 

A5 C, IP C, 

48 

c, 

£0 

c. 


ia 

s 1 [COMPILE! 

FORTH $ IMMEDIATE 

13 

'WIP , 4C C, 

» 

VARIABLE 

4 + , 

13 

VOCABULARY ' 

IMMEDIATE 

14 







14 



15 






--> 

15 

PERMANENT 

— 


) 


) 


> 


Screen: 61 Screen: 6 A 


0 

( Txt 

: comp; 

DMCP* 


) 

0 

( 

Txt comp: W= 

1 







1 



2 

HEX 






2 

: 

W= 

3 







3 


<W=) , CURRENT 0 

A 

TLOBEL 

DCMP* 




A 


TC= CURRENT ! j 

5 

P5 

C, 

IP 1 + 

C, A 8 



5 



6 

A5 

C, 

IP C, 

AS C, 

20 C, ~WIP 


6 

s 

P= 

7 

CO 

C, 

CO C, 

18 C, 

05 C, W C, 


7 


<P=> , CURRENT 0 

8 

69 

c. 

02 C, 

95 C, 

00 C, 


a 


TC= CURRENT ! 5 

9 

05 

C, 

W 1 + 

C, 69 

c, 00 C, 


9 



10 

95 

C, 

01 C, 

00 C, 

01 C, 


10 

: 

S= 

11 

C 8 

C t 

B1 C, 

W C, 



11 


<S=> , CURRENT 0 

12 

10 

C, 

FB C, 




12 


TC= CURRENT ! j 

13 

88 

C, 

98 C, 




13 



1A 

00 

C, 

00 C, 

AC C, 

PUSH0O , 


1A 

PERMANENT 

15 





— 

-> 

15 




Screen : 62 

Screen : 65 

0 

( Txt comp: CW=3 [P=3 CS=3 ) 

0 

1 


1 

2 

TLOBEL <W=> ASSEMBLER 

2 

3 

AC C, DCMPt , 

3 

A 

1 *TYPE *SPACE ;S C 

A 

5 


5 

6 

TLOBEL (P=) ASSEMBLER 

6 

7 

AC C, DCMP* , 

7 

8 

3 *TYPE ;S [ 

8 

9 


9 

10 

TLOBEL (S=) ASSEMBLER 

10 

11 

AC C, DCMP* , 

11 

12 

3 *BOCKS *TYPE *SPACE ;S C 

12 

13 


13 

1A 

DCX 

1A 

15 

— > 

1 5 


Screen : 63 

Screen: 66 

0 

( Txt comp: TC= ) 

0 

1 


1 

2 

TRANSIENT 

2 

3 


3 

A 

: TC= 

A 

5 

[COMPILE! A DEFINITIONS 

5 

6 

HERE > R TRANSIENT 

6 

7 

(BUILDS [COMPILE! IMMEDIATE 

7 

8 

LATEST C0 31 AND >R 

8 

9 

LATEST 1+ I’ R CMOVE 

9 

10 

R I* + DUP C0 128 AND SWOP C! 

10 

11 

R> R> 2- , PERMANENT ALLOT 

11 

12 

DOES) 0 STATE 0 

12 

13 

IF , ELSE EXECUTE END IF ; --> 

13 

1A 


1A 

15 


15 


Screen: 67 

Screen : 

70 



0 

0 

< Typed out: 

quans 

) 

1 

1 





2 

2 

QUAN 

PRTWID 

( printer ch/ln 

) 

3 

3 

80 TO PRTWID 

( init value 

) 

4 

4 





5 

5 

QUAN 

VIDWID 

< video ch/ln 

) 

6 

6 

38 TO VIDWID 

( init value 

) 

7 

7 





8 

8 

QUAN 

PCTR < 

printer line ctr 

) 

3 

9 

0 TO 

PCTR < 

init value 

) 

10 

10 





11 

11 

QUAN 

VIDIND 

( video indent ) 


12 

12 

0 TO 

VIDIND 

( init value ) 


13 

13 

QUAN 

PRTIND 

( printer indent 

) 

14 

14 

0 TO 

PRTIND 

< init value ) 


15 

15 

QUAN 

PVIND 

( indention ) — 

•> 


Screen : 68 

Screen: 71 



0 ( 

Numerics: FMT# ) 

0 

1 

( Typed out: ?CR PWID 

?P, VCR 

) 

2 : 

FMT# < f — ) 

JL 

2 

VECT ?CR 



3 

IF 

3 

QUAN PFLG ( value for PFLAG 

) 

4 

ASSIGN *TYPE 

4 

QUAN PWID 



5 

ASSIGN ^SPACES 

5 

80 TO PWID ( adjust 

to suit 

) 

6 

ASSIGN *SPACE 

6 



7 

ELSE 

7 

: ?PCR 

< — 

) 

8 

ASSIGN TYPE 

8 

WWID PVIND + PWID <= 



9 

ASSIGN SPACES 

9 

IF CR END IF 5 



10 

ASSIGN SPACE 

10 




1 1 

END IF 

11 

: ?VCR 

< — 

) 

12 

C ’ D. 4+3 LITERAL ! 

12 

WWID PVIND + 



13 

C ’ D. R 22 + 3 LITERAL ! 

13 

83 C<? 82 C® - 1+ ( 



14 

C ’ D. R 24 + 3 LITERAL ! ; 

14 

IF CR END IF j 



15 

— > 

15 


— 

> 


Screen: 69 



Screen: 72 


0 ( 

Numerics: #. 

*. R 

) 

0 

( 

Typed out: PRT : PRINIT VID: ) 

1 




1 




2 : 

*. 


( n — ) 

2 

8 

PRT: 

( — ) 

3 

ON FMT# . OFF 

FMT# j 


3 


PRTIND TO PVIND 


4 




4 


PRTWID TO WWID 


5 : 

*. R 

< 

nr — ) 

5 


ASSIGN ?PCR TO ?CR 


6 

ON FMT# „R OFF 

FMT# ; 


6 


2 TO PFLG BUFINIT ; 


7 




7 




8 




8 

s 

PRINIT 

( — ) 

9 




9 


0 TO PCTR ; 


10 




10 




11 




11 

8 

VID: 

< — ) 

12 




12 


VIDIND TO PVIND 


13 




13 


VIDWID TO WWID 


14 




14 


ASSIGN ?VCR TO ?CR 


15 




15 


1 TO PFLG BUFINIT ; 

VID: — > 


*XMTLNP 


) 


P 


Screen: 


73 


0 ( Typed out: 


1 

£ : *XMTLNP ( — ) 

3 PFLflG 9 

4 PFLG PFLflG ! 

5 BUF WWID PVIND SPACES TYPE 

6 ?CR PFLG 2 = 

7 IF 1 AT PCTR + ! 

8 PCTR 60 = ( lines/page ) 

9 IF CR CR CR CR CR CR 

10 PRINIT 

11 END IF 

12 END IF 

13 PFLflG ! j 

14 

15 — > 


Screen: 76 

0 
1 
Z 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


o 


Screen: 74 

0 < Typed out: TYPEQUT > 


1 

£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 


TYPEOUT ( — ) 

ASSIGN *XMTLNP TO *XMTLN 5 

for buffer f rating, no windows) 

TYPEOUT 


12 


13 

14 

15 — > 


Screen : 77 

0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 75 

0 

J 

12 

13 

14 

15 


Screen: 78 

0 
1 
o 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 79 

0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

u 

12 

13 

14 

15 


Screen : 62 

0 ( Windows: WCLR ) ( 

1 

2 : WCLR < f — ) 

3 B/C WHGT * B/LN * WADR + WflDR 

4 DO 1 WWID 

5 BKGND 

6 > SCD FILL 

7 B/LN /LOOP 

8 0 TO LPTR } 

9 
10 
11 
12 

13 

14 

15 — > 


Screen: 60 

0 ( Windows: quans etc. ) 

1 

2 ’ ( > SCD ) ( 10 KLOAD ) 


3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


QUflN WflDR ( window uplftcr adr ) 
88 0 2+ TO WflDR < crnt. uplft ) 


QUflN WHGT ( # lines in window ) 
24 TO WHGT ( setup for 0 GR. ) 


OUflN LPTR < wndw line pointer ) 
0 TO LPTR ( default to top ) 


QUflN B/LN < bytes/ line ) 

40 TO B/LN ( setup for 0 GR. ) 

— > 


Screen: 83 

0 ( Windows: NflMWND WSTP RECWND ) 

1 

2 : NflMWND ( wadr wid hgt b/ch ) 

3 <BUILDS < by t /In — ) 

4 

5 

6 : WSTP ( wa wid hgt b/c b/1 — ) 

7 TO B/LN TO B/C TO WHGT 

8 TO WWID TO WflDR 

9 BUF WWID + 1- TO EOB 

10 WCLR BUFINIT ; 

11 

12 : RECWND < system ) 

13 >R -2 8 

14 DO J I + e 

15 -2 +LOOP R> DROP WSTP 5 — > 


Screen: 81 

0 < Windows: CSCRQLL3 SCROLL ) 

1 

2 : (SCROLL) ( — ) 

3 WWID B/C * >R ( # to crnove ) 

4 B/LN B/C * >R ( # to advance) 

5 R WHGT 1- # WflDR + WflDR 

6 DO I J + I 4 RPICK CMOVE 

7 J /LOOP 

8 WflDR WHGT 1- R> * + R> 

9 BKGND > SCD FILL ; 

10 

11 : 7SCR0LL < — ) 

12 LPTR WHGT = 

13 IF (SCROLL) -1 AT LPTR +! 

14 END IF ; 

15 — > 


Screen : 84 

0 ( Windows: aXMTLNW WINDOUT ) 

1 

2 : *XMTLNW ( — ) 

3 7SCR0LL 

4 BUF LPTR B/LN * WflDR + 

5 WWID ) BSCD 1 AT LPTR +! 5 

6 

7 : WINDOUT ( — ) 

8 ASSIGN *XMTLNW TD *XMTLN 5 

9 

10 WINDOUT 

11 
12 

13 

14 

15 — > 


) 


P Screen: 85 

0 
1 
e 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 


Screen : 88 

0 < Color windows: CRPM CVCT 


1 

2 

’ ( WftDR ) < 

40 KLOflD > 

3 

: CPRM ( 

col row wid hght — ) 

4 

( 

wa wid hgt b/c b/1 ) 

5 

ROT 20 ♦ 

4 ROLL + 

6 

88 © + <ROT ( set up wadr ) 

7 

8 

1 20 ; 

< b/chr b/ln ) 

9 

: CVCT 

( — ) 

10 

• < ♦TINT 

ASSIGN A TINT 

11 

TO ♦TINT 

) ( ) 

12 

’ ( (INV 

ASSIGN NOOP 

13 

14 

TO ♦ INV 

> < > ; 

15 


— > 


o 


u 


Screen : 86 

0 < B&W windows: BWPRM BWVCT ) 

1 ’ ( WRDR ) < 40 KLOAD ) 

2 

3 : BWPRM < col row wid hght — ) 

4 < wa wid hgt b/c b/1 ) 

5 ROT 40 * 4 ROLL + 

6 88 0 + <ROT ( set up wadr ) 

7 1 40 3 t b/chr b/ln ) 

8 

9 : BWVCT < — ) 


10 

’ < 

♦TINT 

ASSIGN NOOP 

11 

TO 

♦TINT 

) < ) 

12 

’ ( 

♦ INV 

ASSIGN ''INV 

13 

TO 

♦ INV 

X ) ; 

14 




15 




Screen 

: 

87 



0 ( B&W windows: NRMEBW MAKEBW ) 

1 

2 : NRMEBW ( col row wid hght — > 

3 BWPRM NRMWND 

4 DOES) RECWND BWVCT ; 

5 

6 i MRKEBW < col row wid hght — ) 

7 BWPRM WSTP BWVCT ; 

8 
9 

10 

11 

12 

13 

14 

15 


Screen : 89 

0 < Color windows: NAME, MRKECW 

1 

2 : NAMECW < col row wid hght — 

3 CPRM NRMWND 

4 DOES) RECWND CVCT ; 

5 

6 : MRKECW ( col row wid hght — 

7 CPRM WSTP CVCT ; 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 90 

0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


) 

) 


> 


Screen: 91 

Id 
1 
£ 

3 

4 

5 

6 
7 
B 
9 

10 

11 

12 

13 

14 

15 


Screen : 92 

0 
1 
£ 

3 

4 

5 
S 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 93 

0 
1 
£ 

3 

4 

5 
8 
7 

a 

9 

10 

n 

12 

13 

14 

15 


Screen: 94 

0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

u 

12 

13 

14 

15 


Screen : 95 

0 
1 
£ 

3 

4 

5 
8 
7 

a 

9 

10 

u 

12 

13 

14 

15 


Screen : 96 

0 
1 
£ 

3 

4 

5 

6 
7 

a 

9 

10 

11 

12 

13 

14 

15 


0 

1 

g 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 

cri 

0 

1 

2 

3 

4 

5 

6 

7 

6 

9 

10 

11 

12 

13 

14 

15 

cri 

0 

1 

2 

3 

4 

5 

6 

7 

8 

9 

10 

11 

12 

13 

14 

15 


Screen: 100 

0 ( Vrtxt : VRTfiDJ VRTCX 

1 

2 : VRTfiDJ 

3 ?L0fiDIN6 

4 IN 9 B/BUF >= 

5 IF 0 IN ! 1 BLK +! 

6 END IF ; 

7 

8 : VRTCX ( 

9 VRTfiDJ 

10 BLK 0 BLOCK IN 0 + ; 

11 
12 

13 

14 

15 


) 


i — ) 


— adr ) 


— > 


Screens 101 

0 ( Vrtxt s VRTC0, ! VRTSflV, REC > 

1 

2 i VRTC0 ( — b ) 

3 VRTCX C0 ; 

4 

5 : VRTC ! ( b — ) 

6 VRTCX C! UPDATE 5 

7 

8 QUfiN OBLK QUfiN 01 N 

9 

10 s VRTSfiV ( — blk in ) 

11 BLK 0 TO OBLK IN 0 TO OIN 5 

12 

13 : VRTREC < blk in — ) 

14 OIN IN ! OBLK BLK ! ; 

15 — > 


Screens 102 

0 < Vrtxt: NXTVRT RELVRT ) 

1 

2 : NXTVRT ( — ) 

3 1 IN +! VRTfiDJ 5 

4 

5 s RELVRT < offset — ) 

6 ?LOfiDING 

7 IN 0 + B/BUF /MOD BLK +! 

8 DUP 0 < 

9 IF B/BUF + -1 BLK +! 

10 END IF IN ! ; 

11 
12 

13 

14 

15 — > 


V" ( -- blk in > 

VRTADJ BLK ® IN ® 

BEGIN VRTC® 3A = NXTVRT 
UNTIL ; 


Screens 103 

0 ( Vrtxts 

1 
£ 

3 
A 

5 

6 

7 

8 
9 

10 
11 
IS 
13 
1A 
15 


V” XMTV XCOUNT 


) 


XMTV 

BEGIN VRTC® DUP 3A 
WHILE *EMIT NXTVRT 
REPEAT NXTVRT DRDP 

XCOUNT ( adr — 
DUP ® SWAP 2+ SWAP 


< — ) 


<> 


adr+2 cnt ) 


— > 


Screen : 106 

0 < Vrt xt s 

1 


V*TP V*0 V**EMT 


>c 


2 

3 

A 

5 

6 

7 

8 
9 

10 

11 

12 

13 

1A 

15 


V*TP ( — XCOUNT ) 

VRTC® < DECRYPT ) NXTVRT VRTC® 
( DECRYPT ) NXTVRT 256 * + ; 

V*® ( — X* C=PAD3 ) 

PAD 2+ V*TP DUP PAD ! 0 
DO VRTC® OVER C! 1+ NXTVRT 
LOOP DROP PAD ; 

V**EMT ( — ) 

V*TP 0 

DO VRTC® ( DECRYPT ) 

*EMIT NXTVRT 

LOOP ; — > 


Screen: 1®A 

0 < Vrtxts 

1 


M: 


A 

5 

6 

7 

8 
9 

10 

11 

12 

13 

1A 

15 


Ms 

(BUILDS , , 
DOES) VRTSAV 
DUP @ IN ! 

2+ ® BLK ! 

XMTV *CR VRTREC 

Vs 

(BUILDS , , 
DOES) 

DUP ® IN ! 

2+ ® BLK ! : 


) 

( blk in — ) 


( blk in — ) 




Screens 107 

0 ( Vrt xt : 

1 


V*! 


2 

3 

A 

5 

6 
7 

a 

9 

10 

11 

12 
13 
1A 
15 


V»! 

DUP ® 2+ 0 

DO DUP C® ( ENCRYPT ) 
VRTC! 1+ NXTVRT 
LOOP DROP ; 


< X* — ) 


o 


— ) 


Screens 105 

0 ( Vrtxts 

1 

2 — > 

3 

A 

5 

6 

7 

a 

9 
10 
n 
12 
13 
1A 
15 


EN, DECRYPT example ) 


ENCRYPT 
117 - DUP 0 ( 

IF 256 + END IF 

DECRYPT 

117 + DUP 255 ) 
IF 256 - END IF 


( cl — c2 ) 


( c£ — cl ) 


Screen: 108 

0 ( Vrtxts 

1 
2 
3 
A 

5 

6 

7 

8 
9 

10 
11 
12 
13 
1A 
15 


< -- X* C=PAD3 ) 


X" 


X" 

0 PAD ! PAD 2+ 

BEGIN VRTC® DUP 3A (> 
WHILE OVER C! 1+ 

1 PAD +.' NXTVRT 
REPEAT NXTVRT 2DR0P PAD 


c 


— > 


Screen: 109 

0 ( Vrtxt: 

1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 112 

0 < Vrtxt: 

1 


ALT*! MSG: 


£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


ALT*! 

VRTSAV ALTREC V*! 
ALTSAV VRTREC : 


< X* — ) 


MSG: < X* — > 

< *ENCRYPT ) 

< BUILDS ( DR1 or ) DSTDSK 
ALTBLK , ALTIN , ALT*! 

FLUSH ( DR0 or ) SRCDSK 
DOES) VRTSAV 

DUP @ SWAP 2+ 0 IN ! BLK ! 
V**EMT < or > 

< V*0 *DECRYPT X COUNT *TYPE ) 
VRTREC : 


Screen: 110 


0 

1 

Cm 

3 

4 

5 

6 

7 

8 
9 

10 
1 1 
12 

13 

14 

15 


( Vrtxt : ALTSAV, REC 

QUAN ALTBLK QUAN ALTIN 

: ALTSAV 

BLK C«* TO ALTBLK 
IN 9 TO ALTIN ; 

: ALTREC 

ALTBLK BLK ! 

ALTIN IN ! : 


( — ) 


( — ) 


Screen: 113 
0 
1 
2 

3 

4 

5 

6 

7 

a 

9 

10 

n 

12 

13 

14 


— > 


Screen: 111 

0 < Vrtxt: 

1 


ALTINIT SCRDSK DSTDSK) 


£ 

3 

4 

5 

6 
7 
Q 
9 

10 

11 

12 


ALTINIT < screen 

B/SCR * TO ALTBLK 
0 TO ALTIN : 


: SRCDSK ( — 

CR . " Insert source disk and 
ress START. " WAIT CR : 


DSTDSK ( - 

CR . " Insert dest. disk and pr 

13 ess START. " WAIT CR ; 

14 

15 — > 


Screen: 114 
0 
1 
£ 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screens 115 
S 
1 
2 

3 

4 

5 
S 
7 

a 

9 

10 

11 

12 

13 

14 

15 


Screen: 118 
0 
1 
2 

3 

4 

5 

6 
7 

a 

3 

10 

11 

12 

13 

14 

15 


c 


Screens 11& 

0 < For demoss UMOVE 

1 

2 M *! jS ) < ) 

3 

4 i UMOVE 

5 <ROT OVER OVER U< 

6 IF 

7 ROT <CMOVE 

8 ELSE 

9 ROT CMOVE 

10 END IF 5 

11 

12 s *! 

13 OVER C0 1+ UMOVE 5 

14 

15 


Screen: 119 
*! ) 0 

1 
2 
3 

a a n — ) 4 

5 

6 
7 

a 

9 

10 

11 

12 

13 

14 

— > 15 


o 


Screens 117 

0 < For demos 1 C"3 " ) 

1 

2 s ( ” ) < — * ) 

3 R DUP C0 1+ R) + >R 5 

4 

5 s ” 

8 34 ( Ascii quote ) 

7 STATE ® 

8 IF < cccc" — ) 

9 COMPILE <") WORD 

10 HERE C® 1+ ALLOT 

1 1 ELSE 

12 WORD HERE ( cccc" — * ) 

13 PAD *! PAD 

14 END IF ; 

15 IMMEDIATE 


Screens 120 

0 < X" ... " demo ) 

1 

2 X" When you are going to take in 

3 hand any act, remind yourself w 

4 hat kind of an act it is. If yo 

5 u are going to bathe, place befo 

6 re yourself what happens in the 

7 bath: some splashing the water, 

8 others pushing against one anot 

9 her, others abusing one another, 

10 and some stealing: and thus wi 

11 th more safety you will undertak ' 

12 e the matter, if you say to your 

13 self, I now intend to bathe, and 

14 to maintain my will in a manner 

15 comformable to nature. And so 


MSB: msg-narne demo ) 


Screen: 121 

0 you will do in every act: for t 

1 hus if any hindrance to bathing 
£ shall happen, let this thought b 

3 e ready: it was not this only t 

4 hat I intended, but I intended a 

5 Iso to maintain my will in a way 
£ conformable to nature; but I sh 

7 al not maintain it so, if I am v 

8 exed at what happens.** Epictet us 

9 , translated by George Long, 187 

10 7.-*” 

11 

12 CR 

13 . " The X-quote string is loaded" 

14 CR 

15 


Screen: 122 

0 < V" . . . " M: rnessage-name demo) 

1 

2 V" There is an inconvenience whi 

3 ch attends all abstruse reasonin 

4 g, that it may silence, without 

5 convincing an antagonist, and re 

6 quires the same intense study to 

7 make us sensible of its force, 

8 that was at first requisite for 

9 its invention. When we leave ou 
18 r closet, and engage in the comm 

11 on affairs of life, its conclusi 

12 oris seem to vanish, like the pha 

13 ntorns of the night on the appear 

14 ance of the morning; and ’tis di 

15 fficult for us to retain even th 


Screen: 123 

0 at conviction, which we had atta 

1 in’d with difficulty. This is s 

2 till more conspicuous in a long 

3 chain of reasoning, where we mus 

4 t preserve to the end the eviden 

5 ce of the first propositions, an 

6 d where we often lose sight of a 

7 11 the most receiv’d maxims, eit 

8 her of philosophy or common life 

9 . I am not, however, without h 


10 

11 

opes. . .-*-»David 

Hume, 1 

12 

M: MSGDEM1 


13 

CR 


14 

. " MSGDEM1 now 

exists. 

15 

CR 



Screen: 124 

0 ( X " ... » 

1 

£ 80 ALTINIT 

3 

4 X" 

5 ’Accessory No. 5 is a pocket com 

6 pass and is used in connections 

7 with putting. Like suppose for 

8 inst. you land on the green abou 

9 t 10 ft. from the cup, why the n 

10 ext thing is to find out what di 

11 rection the hole is at and this 

12 can’t be done and done right wit 

13 hout a compass.*-* At lease I hav 

14 e seen a whole lot of golfers tr 

15 y and putt without no compass, a 


Screen: 125 

0 nd their ball has went from 10 t 

1 o 45 ft. degrees to the right or 

2 left of where the hole is actua 

3 lly located. This is because th 

4 ey was just guessing where as wi 

5 th a compass they’ s no guess wor 

6 k about it. If you miss a putt 

7 with a compass to tell you just 

8 where a hole is at, why it’s bee 

9 ause you can’t putt so good. ’ -»-*R 

10 ing Lardner on New Golf Accesori 

11 es, 1924. V 

12 

13 MSG: MSGDEM2 

14 CR . “ MSGDEM2 now exists." CR 

15 


Screen: 126 

0 < More MSG : ’ s ) 

1 

2 X" The rat the cat I bought ca 

3 ught escaped. V MSG: M0 

4 

5 X” There are gold coins here!*" 

6 MSG: Ml 

7 

8 X" Aww, gee, Beave!*" 

9 MSG: M2 
10 

11 X" You see, Watson, but you do n 

12 ot observe.-*" MSG: M3 

13 

14 X" Never look back; something ma 

15 y be gaining on you.*" — > 


Screen: 127 Screen: 130 

0 < More MSG : ’ s ) 0 

1 1 

2 MSG: M4 2 

3 3 

4 X" 'The precise date at which th 4 

5 e reversion to cap and gown took 5 

6 place, as well as the fact that & 

7 it affected so large a number o 7 

8 f schools at about the same time 8 

9 , seems to have been due in some 9 

10 measure to a wave of atavistic 10 

11 sense of cornformity and reputabi 11 

12 lity that passed over the commun 12 

13 ity at that period. ’-*-*Thorstein 13 

14 Veblen, 1899.-*" MSG: M5 14 

15 15 


c 


Screen: 128 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 131 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


o 


Screen: 129 
0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

11 

12 

13 

14 

15 


Screen : 1 32 
0 
1 
2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


c 




o 


Screen 133 through 161 are blank. 


o 


1 

a 

3 

4 

5 

6 

7 

B 

9 

10 

11 

IS 

13 

14 

15 

icri 

0 

1 

2 

3 

4 

5 

6 

7 

8 

3 

18 

11 

12 

13 

14 

15 

cn 

0 

1 

2 

3 

4 

5 

6 

7 

6 

9 

10 

1 1 

IS 


c 


Screen : 1 65 
0 
1 
2 

3 

4 

5 

6 

7 

8 
3 

10 

11 

12 

13 

14 

15 


Screen : 1 66 


0 < Load Chain 


) 


1 

2 

3 

4 

5 

6 
7 

a 

9 

10 

n 

12 

13 

14 

15 


’ < QUAN ) < 10 LOAD ) 

16 LOAD < utilities ) 

Do not modify these lines ) 


— > 


o 


Screen: 167 

0 < Load Chain, options screen ) 


1 

28 


LOAD 

( 

af, 

do not modify 

) 

2 

( 

34 

LOAD 

( 

rgt 

& ctr justify 

) 

3 

( 

38 

LOAD 



< fill justify 

) 

4 

< 

50 

LOAD 



( coloring 

) 

5 

( 

52 

LOAD 


< 

capital izat ion 

) 

6 

( 

54 

LOAD 


( 

inverse video 

) 

7 

42 


LOAD 

< 

af, 

do not modify 

> 

8 

( 

60 

LOAD 


( text compression 

) 

9 

< 

68 

LOAD 

< 

frnt 

’d num. output 

) 

10 

( 

70 

LOAD 



( typed output 

) 

11 

< 

86 

LOAD 

( 

B&W 

window output 

) 

12 

( 

88 

LOAD 

< 

Color wndw output 

) 

13 


< select 

>■ 

= 1 

of above 3 ) 


14 

< 

100 

LOAD 

( 

Virtual mem. text 

) 

15 

< 

116 

LOAD 

( 

" for demos ) 



Screen: 168 

p . 

2 

3 

4 

5 

6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 171 
0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

u 

12 

13 

14 

15 


Screen: 169 
0 
1 


3 

4 

O 6 

7 

8 
9 

10 

11 

12 

13 

14 

15 


Screen: 172 
0 
1 
2 

3 

4 

5 

6 
7 

a 

9 

10 

n 

12 

13 

14 

15 


Screen: 170 Screen: 173 

0 CONTENTS OF THIS DISK: 0 

1 1 

2 LOAD-CHAIN 166 LOAD 2 

3 3 

4 EFFICIENT <BUILDS DOES) 4 

5 (ALSO LOADED BY TXTCMP) 56 LOAD 5 

6 QUAN STRUCTURES 10 LOAD 6 

7 TRANSIENT STRUCTURES 4 LOAD 7 

a a 

9 9 

10 10 

11 11 

12 12 

13 13 

14 14 

15 15 


c 


Screen: 17A 
0 
1 
£ 

3 

A 

5 

6 
7 

e 

9 

10 

11 

12 

13 

1A 

15 


Screen t 177 

0 Disk Error! 

1 

2 Dictionary too big 

3 
A 

5 

6 

7 

8 
9 

10 

11 

12 

13 

1A 

15 


Screen : 1 75 
0 
1 
£ 

3 

A 

5 

6 

7 

8 
9 

10 

11 

12 

13 

1A 

15 


Screen : 178 

0 ( Error messages 

1 

£ Use only in Definitions 
3 

A Execution only 

5 

6 Conditionals not paired 

7 

8 Definition not finished 

9 

10 In protected dictionary 

11 

12 Use only when loading 

13 

1A Dff current screen 
15 


Screen: 176 

0 ( Error messages 

1 

£ Stack empty 
3 

A Dictionary full 

5 

6 Wrong addressing mode 

7 

8 Is not unique 

9 

10 Value error 

11 

12 Disk address error 

13 

1A Stack full 
15 


Screen : 1 79 

) 0 Declare VOCABULARY 

1 
£ 

3 

A 

5 

6 

7 

8 
9 

10 

11 

12 

13 

1A 

15 


