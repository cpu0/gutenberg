NASA Technical Memorandum 101462 


Parallel Processing of a 
Rotating Shaft Simulation 


<*ASA-H5-101462) PABALLEL EiCCESSISG Of A 
l C1ATIKG SHAFT SIFCIAIICK HAS A) 68 p 

CSC1 12B 


G3/66 


Dale J. Arpasi 
Lewis Research Center 
Cleveland, Ohio 


February 1989 


N89-17453 

Due las 
0190058 




E- 42 90 


PARALLEL PROCESSING OF A ROTATING SHAFT SIMULATION 


Dale 3 . Arpasi 

National Aeronautics and Space Administration 
Lewis Research Center 
Cleveland, Ohio 44135 


SUMMARY 

A Fortran program describing the vibration modes of a rotor-bearing sys- 
tem is analyzed for parallelism, and a data-flow statement of the problem is 
developed. This statement identifies the inherent parallelism in this simula- 
tion using a pascal-like structured language. Potential vector operations are 
also identified. 

A critical path through the simulation is identified and used in conjunc- 
tion with somewhat ficticious processor characteristics to determine the time 
to calculate the problem on a parallel processing system having those charact- 
eristics. A parallel processing overhead time is included as a parameter for 
proper evaluation of the gain over serial calculation. The serial calculation 
time is determined for the same ficticious system. An improvement of up to 
640 percent is possible depending upon the value of the overhead time. 

Based on the analysis, certain conclusions are drawn pertaining to the 
development needs of parallel processing technology, and to the specification 
of parallel processing systems to meet specific computational needs. 


INTRODUCTION 

The work described in this report resulted from the cooperative efforts 
in parallel processing underway in the Internal Fluid Mechanics Division and 
the Structures Division at the Lewis Research Center. The objectives of these 
efforts are to establish the requirements of parallel processing to meet the 
computational needs of these divisions, and to commonly advocate and pursue 
parallel processing technology based on these requirements. 

A number of benchmark simulations are being reviewed to establish the 
requirements for parallel processing technology development. One of these is 
a structural dynamics model of a rotor-bearing system. The system is diagramed 
in figure 1. It consists of a shaft and three disks mounted on two axially 
preloaded ball bearings. The bearings were mounted in a squeeze-film damper 
journal containing a centering spring. The calculation approach is described 
in reference 1. The purpose of the simulation is to identify the shaft vibra- 
tion at each time step and to display the vibrations in terms of a motion pic- 
ture. Fixed time steps of 0.12 msec are considered satisfactory to define the 
system dynamics. In the simulation, an external forcing function providing 
shaft position, velocity and acceleration is assumed to be available for sam- 
pling at each time step. 

The Fortran program in appendix A is used as the basis for identifying 
the parallelism in the simulation. The resulting data-flow statement is then 
used to estimate the critical path time through the calculations. The calcula- 
tion time of the critical path is the minimum achievable parallel processing 


I 


time and therefore may be used to evaluate the capabilities of specific proces- 
sors to do the calculation. Parallel processing and serial processing times 
are determined using operations and execution times of a ficticious but repre- 
sentative parallel processing system. A discussion of parallel processing 
overhead is provided. Finally, certain conclusions are drawn based upon the 
results of this effort. 

It is intended that the information and discussion presented will provide 
input for expert system software development (automation of the development of 
time-optimized parallel models on any given parallel processing systems), and 
for benchmark evaluations of available and projected parallel processing sys- 
tems to meet the computational needs of simulations of this type. 


PROBLEM STATEMENT 

The Fortran calculation of the rotating shaft simulation contains three 
main programs: initialization, calculation, and motion picture development. 

These programs operate independently, linked together by data sets. Taking 
some liberties with the structure of the Fortran program, the following state- 
ment of the simulation was formulated: 

PROGRAM SHAFT 
BEGIN 

READ[GE0METRY/SHAFT_DATA_FILE1 ] ; 

INITIALIZE [SHAFT/GEOMETRY] ; 

READCSTART/TERMINAL] ; 

READ[IC/SHAFT_DATA_FILE2] 

RESET [PARAMS/ START , IC] ; 

READ[ANGIC/ANGLE_INPUT_DEVICE] ; 

NEWRAP [SOLUTION /SHAFT, IC, START] ; 

IF CONVERGED THEN 
WHILE NOT STOP DO 
BEGIN 

READCSTOP/TERMI NAL ] ; 

READ[ANGIC/ANGLE_INPUT_DEVICE] ; 

CALCULATEtRESULTS/ANGIC] ; 

D I SP LAY [GRAPH I CS_DEV ICE /RESULTS] 

END 

END; 

where GEOMETRY, SHAFT, START, IC, PARAMS, SOLUTION, ANGIC, and RESULTS are 
groups of variables and INITIALIZE, RESET, READ, NEWRAP, CALCULATE, and DIS- 
PLAY are computational tasks which form the next lower level of simulation 
statement. 

The INITIALIZE Procedure allows specification of shaft geometry; the 
RESET procedure develops initial conditions and time parameters; the CALCULATE 
procedure identifies the dynamics of the shaft as a function of shaft rotation; 
the NEWRAP procedure solves the shaft model at a time point using a Newton- 
Raphson method; the DOMOVIE procedure develops the dynamics into a motion pic- 
ture showing the vibrations of the shaft duririg acceleration. A simple 
data-flow analysis of the program indicates that READ [ANGIC], CALCULATE and 
60 MOVIE can be done in parallel, but they are pipelined, meaning that while 


2 



READ gets a new angle (t = 0), CALCULATE works with the one obtained before 
(at time t = 1), at the same time DOMOVIE displays the results from t = 2. 


DATA-FLOW STATEMENT 

The data-flow statement of the simulation, derived from the Fortran, is 
in appendix B. It is a series of statements which must be computed serially 
because the results generated by one statement are arguments of subsequent 
statements. These statements are numbered to indicate their computational 
sequence. Each serial statement, however, may consist of any number of other 
statements some of which are data-flow-independent of each other and may be 
computed in parallel, some of which are serial, forming other data-flow paths, 
and some of which control the path of calculation according to calculation 
results. 

This simulation statement is not unique since various operations may be 
shifted from one statement to another through the use of dummy variables. 

Also, statements which may be computed in parallel within a serial statement, 
may often be moved forward or backward in the calculation sequence as along as 
data-flow requirements are not violated. In developing this data-flow state- 
ment the author attempted to consolidate the calculations into vector opera- 
tions (defined here as a single calculation sequence operating on lists of 
arguments to produce a list of results where the lists are of equal length). 
This was done to aid in the visualization of the calculations as a vector proc- 
ess. Actual vectori zation , of course, is very dependent on the computational 
hardware involved, including its capabilities in handling indirect access of 
argument vector values, and in the distribution of result vector values to 
other calculations. 

The data-flow statement is written in a pascal-like structure to simplify 
its analysis and understanding. The statement is written using procedures 
which conform to the problem statement described above, and using certain other 
procedures to avoid repetition and to enhance clarity. The use of the FORWARD 
statement to link procedures is omitted for the sake of clarity. Other major 
deviations for pascal are: 

1. The DO_IN_PARALLEL statement - indicates that the statements between 
the following BEGIN/END are data-flow independent and may be computed in 
paral lei. 

2. Possible vectors are denoted as comments of the form 

{ V3 C 50 ] : A=B+C} . 

where "V3" is a vector process identification, "[50]" implies a vector length 
of 50, and the remainder the vector calculation. 

3. Assignment and equivalence are designated using the equal sign. 

4. The F0R_ALL statement is used as a shorthand device. The is used 

to mean replacement. That is, the integer variable to the left of the symbol 
is successively replaced by all values appearing to the right of the symbol 

to form a multitude of statements. For example, 



FOR_ALL J:=l . .2 X< J)=Y( J) 

is interpreted as X(1)=Y(1) and X(2)=Y(2). 

5. Results and arguments are specified as such for all procedures. They 
are del i neated as 


[RESULTS/ARGUMENTS] 

and immediately follow the procedure's identification. 

6. In specifying constants, n@k is interpreted to mean n sequential 
values of k. 

The data-flow statement takes some liberties with the Fortran variables 
and procedures to conform to the author's subjective concept of clarity, and 
to reduce the complexity of the Fortran statements to promote parallism. Many 
of the Fortran loops had to be expanded and many functions had to be merged 
into procedures for the sake of computational data-flow (the comments in 
appendix B (the data-flow statement) try to point out where these functions 
were in the original Fortran code). For this reason, the data-flow statement 
differs substantially from the serial Fortran statement of. appendix A. 


THE CRITICAL PATH 

The critical path is the longest calculation path through the simulation. 
(A path is defined to contain no computational parallelism.) The calculation 
time of the critical path represents the minimum time in which the problem can 
be calculated, no matter how many processors are used. The critical path is 
dependent both on the data-flow in the problem and on the processing speed 
of the parallel processing system on which the problem is to be calculated 
(the target processors). Therefore, in a parallel processing environment, it 
is conducive to success to specify the problem using algorithms which maximize 
the data-flow paths, and to provide parallel processing hardware which minimiz- 
es the calculation times of these paths as well as the overhead (data trans- 
fer, synchronization, ...) required for parallel calculation of the problem. 

An analysis of the critical path through the Newton-Raphson algorithm can 
be used to provide insight into the parallel processing of the rotor-bearing 
simulation. This algorithm represents the bulk of the calculation in this sim- 
ulation and consumes most of the required computing power in each simulated 
time step. 

The data-flow statement in appendix B is macroscopical ly a serial calcula- 
tion if the DO-IN-PARALLEL statements are considered to be computational 
black-box units. The computational path through the calculation is determined 
by the control statements. These are statements such as IF, WHILE, and 
REPEAT. . .UNTIL, which direct the computation according to the values of comput- 
ed results. If these control statements are assumed to result in the longest 
path through the problem then the data-flow statement can be used as an approx- 
imation of the critical path. It is only an approximation because exact speci- 
fication of the critical path depends upon processor calculation times. Using 


4 



the more rigorous techniques described in reference 2, along with precise proc- 
essor operation times, a more computation-time-optimized data-flow statement 
may result. 

Appendix C contains a condensed version of the data-flow statement and 
appendix 0 a condensed version of the critical path. In these versions the 
statements are given in an abbreviated form. For example, the following abbre- 
viated statement appears in the INITIALIZE procedure: 

2 [ 1 72 ] : 1 48@R=B*C : 240R=B+C*D*E* ( F-G) ; 

In this statement, "2" indicates that it corresponds to statement 2 of that 
procedure, and [172] indicates that this statement consists of 172 parallel 
statements. The remainder of the abbreviation specifies the number and opera- 
tional form of the parallel statements. That is, 148 are of the form R=B*C 
and 24 are of the form R=B+C*D*E*(F-G) . In this statement, "R" denotes a real 
number result. In other statements, "A" is used to specify a complex result, 
"I" and integer result and "L "a boolean result. The letters to the right of 
the equal sign are used without any data-type connotation to represent argu- 
ments. 

The calculation time depends on the characteristics of the target proces- 
sors. The statement must be broken down into the basic machine operations of 
that processor and execution times for these operations must be known. Then, 
if 148 calculations of the type, R=C*C, require more time than 24 calculations 
of R=B+C*D*E(F-G) , then the former is the representation of this statement in 
the critical path (appendix D), and its calculation time is the calculation 
time of the statement 2 (the rest being done in parallel). In developing crit- 
ical path times, it is important to include all operations required by the cal- 
culation. Data transfer may be a large part of these calculations if more 
then one processor is used, or if vectors must be constructed to permit vector 
processor calculation other overheads must be included in parallel processor 
calculation times. Accurate statement timing is required for allocation of 
statement execution to a minimum number of processors and for minimizing data 
transfer delays. These complications point out the need for expert system 
software to develop parallel processor programs since the drugery involved is 
likely to be beyond the patience of most humans. 

A shorthand notation opposite to a statement is used to specify the 
machine operations necessary to calculate a statement. In the example above 
the notation 


#R=1 48( L+M+S)+24( L+2A+3M+S) 

would be used to represent the operations involved in a completely serial cal- 
culation of statement 2, and 


#R=L+M+S+1 72X 

would be used to represent the operations contributed to the critical path by 
this statement. The operation mneumonics used in the notation are defined in 
table I. In the notation for the critical path, an overhead tax is imposed on 
each result calculated. It represents the data transfer and other overhead 


5 



associated with parallel processing. The operational equivalent of this tax 
is represented by X. Therefore, in the example, the parallel execution of 
the statement would require 1 load, 1 multiply, 1 store and 172 overhead opera- 
tions (one for each result computed). 

The machine operations given in appendix C represent those necessary for 
serial calculation of the Newton-Raphson algorithm. Table II gives a count of 
these operations in the main procedure, NEWRAP, and in all of its service 
procedures. A total count for the complete algorithm is also given. The oper- 
ations required for real number results are given in part (a) of the table, 
and those for complex results in part (b) of the table. Results of other data- 
types are lumped into part (a). It was assumed that the algorithm requires 20 
iterations to converge and that the rotor is defined by 24 segments. On this 
basis, the algorithm, when executed serially, requires 500 repetitions of the 
CALC1 procedure, 480 of CALC2 , 6240 of EXTER, 520 of J0URNL and 20 repetitions 
of SOLVE, for each calculation of the NEWRAP main procedure. If convergence 
is successful then these are a good approximation to the operations required 
for the CALCULATE procedure at each time step. 

A similar operational analysis of the critical path (appendix D) is given 
in table III. Note the reductions in repetitions required for most service 
procedures, the reduction in most operations, and the addition of the overhead 
tax operator, X, to the operational requirements of each procedure. 

Table IV provides a comparison of serial execution time to parallel (crit- 
ical path) execution time. The numbers of operations required are converted 
to execution time using the operation times given in table I. These operation 
times are representative of those associated with the Motorola 68020 processor, 
operating with cache memory and the companion floating point coprocessor. Note 
that serial calculation of the problem is projected to take about 2.4 sec. 
Parallel calculation time is given by the equation. 

ti me (msec) =380. 07+2202 33Tx 

where Tx is the execution time associated with the overhead tax operator. 

Tx is not specified in table I since it related more to the parallel process- 
ing system then it is to an individual processor. The plot of this equation 
is given in figure 2. It shows that a calculation time improvement 
approaching 6.4 times the serial calculation may be possible (assuming Tx = 0) 
with parallel processing using these M68020 type processors in a configuration 
which allows calculation in the critical path time without any significant 
overhead (Tx =0). On the other hand, an overhead of only 9.33 ps causes par- 
allel processing time to exceed serial processing time. It is therefore 
extremely important to minimize this overhead time in developing parallel pro- 
cessing hardware and software, and to insure that the programming of the paral- 
lel processing system does not increase this overhead. 

This potential improvement may not warrant the expense associated with 
parallel processing (time, manpower and materials), or, it may not be suffi- 
cient to meet simulation objectives. Two avenues for potential improvement of 
the situation are available: (1) find a parallel processing system which fur- 

ther reduces critical path calculation time, or, (2) find a different algorithm 
for the simulation which provides a shorter critical path (more parallelism). 
Doing the latter would also require identification of a suitable parallel 
processing system. 


6 



CONCLUDING REMARKS 


The effort seems to substantiate the following conclusions: 

1. Fortran is difficult to interpret, not self-documenting, and 
certainly not suited to straight-forward data-flow analysis. Additionally, it 
is not sufficiently structured, nor is it a sufficiently high order language 

to prohibit the user from adversely affecting the overhead associated with par- 
allel processing. 

2. Parallel processing systems should be thoroughly benchmarked for all 
intended applications. The parallel to serial calculation time ratios should 
be determined. Then, before selecting a system, any processing-time improve- 
ments should be weighed against initial and ongoing costs. 

3. Studies of this kind, although valuable in benchmark evaluations of 
systems, are very tedious and time consuming (about 6 man weeks from Fortran). 
Automation of these procedures and those associated with the programming and 
operation of parallel processors could eliminate errors, minimize overhead, 
and reduce the turn-around time. 

More generally, parallel processing is a valuable computational tool 
whose usefulness may be significantly impaired by (1) unsuitable computational 
algorithms, (2) error or inefficiency in parallel program generation, (3) too 
much operational overhead in the system software, and (4) a poor choice of sys- 
tem hardware to meet application needs. The elimination of these pitfalls 
might be possible using knowledge-based interfaces between users and the paral- 
lel processing systems at their disposal. These interfaces could provide a 
hardware transparency to the users while minimizing code development time and 
insuring cost effective utilization of existing resources. Without such inter- 
faces, the costs of developing and adapting codes to new parallel machines may 
significantly impair new technology in the areas of computing systems, code 
generation, or both. 


7 



APPENDIX A: FORTRAN STATEMENT 


Here are three programs the first calculates the physical properties M 
and K. The second program calculates the transient motion using the proper- 
ties calculated by the first program. The third program produces a motion pic- 
ture, from the transient motion calculated by the second program. The first 
program extends from line 100 to 8400. Input is in namelist "Geom" and output 
is in namelist "shaft." There are no subroutines. The second program extends 
from line 8500 to 43100. Input is in namelist "Start," "IC," and "Shaft." 
Output is in namelist "Fin" and a binary file, Fortran 7. "IC" is updated and 
used as a restart file. The main control program runs from line 8500 to 
10300. A utility subroutine runs from line 10400 to 25900. It has several 
entry points; "ZIC," "ORDER," "STEP," "DELT," "INCR," "OUTPUT," "ANGLE," 
"RADIUS," "BC," "DEQ," and ROTOR. A logical function "NEWRAP" is a non-linear 
equation solver. It calls 2 subroutines "Jacob" and "Solve" and entry point 
"Angle." "Jacob" calculates the linearized coefficients and "Solve" solves 
the resulting linearized equation set. "Jacob" calls a subroutine "EXTER" 
which calculates the external force at some point on the rotor. Several entry 
points into "Util" are called "Radius," "Rotor," "BC," and "DEQ." "Exter" 
calls "Journl" which is a program to calculate the force on a Journal /Damper 
bearing . 

The last of three programs produces the 3-D movie of shaft motion. Input 
is namelist "FRAM" and the binary file on Fortran tape 7. A complex function 
FO is called which interpolates the motion to equal time steps. 


0000100 

0000200 

0000300 

0000400 

0000500 

0000600 

0000700 

0000800 

0000900 

0001000 

0001100 

0001200 

0001300 

0001400 

0001500 

0001600 

0001700 

0001800 

0001900 

0002000 

0002100 

0002200 

0002300 

0002400 

0002500 

0002600 

0002700 


REAL DO(24),DI(24),E(24) ,RHO(24) 

REAL M(24),IT(24),IP(24),L(24),S(24) 

EQUIVALENCE (N.NUM) 

NAMELIST/SHAFT/NUM.M, IT , IP , K , L , S , SMAX 

REAL*8 AN(2 ,4) , AP( 2 ,4)B(2 ,4) , K(2 , 2 , 24 , 3) ,DUM,DELT ,DS , El 

REAL DBC(2) ,£BC(2),LBC(2) , EIBC(2 ) ,P(2,2) 

DATA P/0. ,-l . ,1 . ,0./ 

DATA PI, G/3. 141593, 386. 4/ 

NAMELIST/GE0M/N,L,D0,DI ,E,RH0,M,IT,IP,DBC,EBC,L8C 
READ( 5 ,GE0M) 

WRITE! 6 , GEOM) 

DO 2 Jl=l ,2 

E I BC ( J 1 )=EBC( J1 ) * < P I *DBC< J 1 ) * *4) / 64 
DO 1 J2=l ,4 

1 AP ( J 1 , J2)=0 

2 AP < J 1 , J 1 ) = 1 
DS=LBC( 1 ) 

EI-EIBC(l) 

S( 1 )=L( 1 ) / 2 
AP( 1 ,2)=DS 
AP(2 ,3)=DS/EI 

AP(1 , 3)=DS*AP(2 , 3 ) / 2 
AP(2 ,4)=AP( 1,3) 

AP( 1 ,4)=DS*AP( 1 ,3)/3 
N1=N+1 
DO 8 J=1 ,N1 
DO 3 Jl=l ,2 


8 



0002800 

0002900 

0003000 

0003100 

0003200 

0003300 

0003400 

0003500 

0003600 

0003700 

0003800 

0003900 

0004000 

0004100 

0004200 

0004300 

0004400 

0004500 

0004600 

0004700 

0004800 

0004900 

0005000 

0005100 

0005200 

0005300 

0005400 

0005500 

0005600 

0005700 

0005800 

0005900 

0006000 

0006100 

0006200 

0006300 

0006400 

0006500 

0006600 

0006700 

0006800 

0006900 

0007000 

0007100 

0007200 

0007300 

0007400 

0007500 

0007600 

0007700 

0007800 

0007900 

0008000 

0008100 

0008200 


DO 3 02=1 ,4 

3 AN ( J 1 , J2)=AP( J1 , J2) 

DS=LBC(2) 

E I = E I BC < 2 ) 

IF(O.GT.N) GO TO 4 
DS=L(J)/2 

IF(J.GT.l) S(J)=S(J-1 )+(L(J-l)+L(J))/2 

DEL=DO( J)**2-DI( J)**2 

SUM=DO( J)**2+DI ( J)**2 

A=PI*DEL/4 

DM=2DS*A*RH0( J)/G 

DIP=DM*SUM/8 

DIT=DIP/2+DM*DS**2/3 

EI=A*SUM*E(J)/16 

M( J)=M( J)+DM 

IP( J)=IP( J)+DIP 

IT( J)=IT( J)+DIT 

4 AP( 1 ,2>=DS 
AP(2 , 3)=DS/EI 

AP(1 ,3)=DS*AP(2,3)/2 
AP(2 , 4)=AP( 1,3) 

AP < 1 ,4)=DS*AP(1 ,3)/3 
DO 5 01=1 ,2 
DO 5 J2-1 ,2 
B( J 1 , J2)=0 
B( J1 , J2+2)=0 
DO 5 J3=l ,2 

B(J1 , J2)=B(J1 , J2)+AP(J1 , J3)*AN( J3 , J2) 

5 B(J1 , J2+2)=B( J1 , J2+2)+AP(Jl , J3)*AN< J3 , J2+2)+AP ' ' 1 , J3+2)*AN( J3, J2) 
DELT=B(1 ,3)*B<2 ,4)-B( 1 ,4)*B(2,3) 

DUM=B(2 ,4)/DELT 
B(2,4)=B(1 ,3)/DELT 
B< 1 , 3)=DUM 
B(2,3)=-B(2,3)/DELT 
B(1 ,4)=-B(l ,4)/DELT 
IF( J . LT.2) GO TO 7 
DO 6 Jl = l ,2 
DO 6 J2=l ,2 
K(J1 , J2 , J-l , 3)=0 
DO 6 J3=l ,2 

K(J1 , J2 , J-l , 3)=K( J1 , J2 , J-l ,3)+P(Jl , J3)*B( J3, J2+2) 

DO 6 J 4= 1 ,2 

K(J1 , J2 , J-l ,2)=K(J1 , J2 , J-l ,2)-P( J1 , J3)*B( J3, J4+2)*B< J4, J2) 

7 IF(J.GT.N) GO TO 9 
DO 8 Jl=l ,2 

DO 8 J2=l ,2 
K< J 1 , J2 , J , 1 )=0 
K(J1 , J2 , J ,2)=0 
DO 8 J3=l ,2 
DO 8 J 4= 1 ,2 

K(J1 , J2 , J ,2)=K( J1 , 02 , J , 2)-P( J 1 , J3)*B( J3 , J4)*B( J4, J2+2) 

DO 8 J 5= 1 ,2 

8 K ( J 1 , J2 , J , 1 ) =K< J 1 ,J2,J,1)+P(J1 , J3)*B( J3, J4)*B( J4, J5+2)*B( J5, J2) 

9 SMAX=S(N)+L(N)/2 
WRITE(4,SHAFT) 


9 



0008300 

0008400 

0008500 

0008600 

0008700 

0008800 

0008900 

0009000 

0009100 

0009200 

0009300 

0009400 

0009500 

0009600 

0009700 

0009800 

0009900 

0010000 

0010100 

0010200 

0010300 

0010400 

0010500 

0010600 

0010700 

0010800 

0010900 

0011000 

0011100 

0011200 

0011300 

0011400 

0011500 

0011600 

0011700 

0011800 

0011900 

0012000 

0012100 

0012200 

0012300 

0012400 

0012500 

0012600 

0012700 

0012800 

0012900 

0013000 

0013100 

0013200 

0013300 

0013400 

0013500 

0013600 

0013700 


STOP 

END 

COMPLEX* 1 6 U(2 , 24) 

LOGICAL NEWRAP, FINISH 
CALL ZIC(U.N) 

I F( . NOT ,NEWRAP(U,E,N)) STOP 
CALL OU T PU T< FINISH) 

4 CALL ORDER(U) 

1 CALL STEP < 1 .) 

IF( . NOT . NEHRAPdJ , E , N) ) GO TO 2 
IFCE.LT.l . E-04) GO TO 3 

2 CALL STEP ( - 1 . ) 

CALL DELT(.l) 

GO TO 1 

3 CALL INCR(U) 

IF(E. LT. 1 . E-06) CALL DELT ( 2 . ) 

IF(E.GT. 1 . E-05) CALL DELT ( . 5) 

CALL OUTPUT(FINISH) 

I F( FINISH) STOP 

GO TO 4 

END 

SUBROUTINE UTI L(U , R , F , A) 

COMPLEX* 16 R(2,3,3),U(2,24),Z(2,24,4) 

COMPLEX* 16 A( 2 , 2 , 2 ,24,3) , C( 2 , 24) ,F(2) , R0( 2 , 3) ,REF(3) 
INTEGER 0,Q1 

COMPLEX RCG (24 ,2),RIC<24,2,2),ROIC(2,3), RBC(2 , 2) , REF0(2) 
REAL M(24),IT(24),IP(24),L(24),S(24) 

REAL ANGIC(2) , ( 3) ,ALP(4,4) 

REAL*8 ANG( 3) ,k( 2 , 2 , 24 , 3) ,T, DT , TEMP , H 
DATA ALP/ 6*0. ,5,0. ,2 . ,3. , 1 . ,0. ,6. , 1 1 . ,6. . 1 . / 

LOGICAL FINISH, LOC 
COMMON / J AC / LOC (24) 

NAMELIST/START/TMAX, AMP, OMEGA 
NAMELIST/FIN/RMAX ,T 

NAMELIST/IC/TIC,RIC, RCG, ANGIC, ROIC, RBC, LOC 
NAMELIST/SHAFT/NUM ,M, IT , IP , <, L ,S ,SMAX 
ENTRY ZIC(U,N) 

READ( 5 , IC) 

WRITE(6,IC) 

READ(5, START) 

WRITE(6, START) 

READ(4, SHAFT) 

WRITEC6, SHAFT) 

WRITE<7) NUM , SMAX ,(S(J1),J1=1 ,NUM) ,(RCG(J1 ,1),J1-1 ,NUM) 
RMAX=0 
T=TIC 
N=NUM 
0=2 

H=1 ./OMEGA 
DO 3 32=1, N 
DO 3 Jl = l ,2 
TEMP=1 /AMP 

I F( J1 . EQ. 2) TEMP=TEMP*L( J2 ) 

DO 2 J3=l ,2 

Z(J1 , J2 , J3)=RIC( J2 , J 1 ,J3)*TEMP 


10 


0013800 

0013900 

0014000 

0014100 

0014200 

0014300 

0014400 

0014500 

0014600 

0014700 

0014800 

0014900 

0015000 

0015100 

0015200 

0015300 

0015400 

0015500 

0015600 

0015700 

0015800 

0015900 

0001600 

0016100 

0016200 

0016300 

0016400 

0016500 

0016600 

0016700 

0016800 

0016900 

0017000 

0017100 

0017200 

0017300 

0017400 

0017500 

0017600 

0017700 

0017800 

0017900 

0018000 

0018100 

0018200 

0018300 

0018400 

0018500 

0018600 

0018700 

0018800 

0018900 

0019000 

0019100 

0019200 


2 TEMP=H*TEMP/J3 

3 Z( J 1 , J2 , 3)=0 
RETURN 

ENTRY ORDER(U) 

IF(Q.GT. 3) RETUEN 

Q=Q+1 

DO 4 J2=l , N 
DO 4 J 1 = 1 ,2 

4 Z(J1 , J2,Q)=U(J1 , J2)/(Q-1 ) 

RETURN 

ENTRY STEP (BET) 

T=T+BET*H 

01 = 0-1 

DO 5 J 3= 1 ,Q1 
TEMP=1 
J4=J3+1 
DO 5 J5=J4 ,Q 

TEMP= ( J 5— 1 )* BET* TEMP/ ( J5-J3) 

DO 5 Jl = l ,2 
DO 5 02=1 , N 

5 Z( J 1 , J2, J3)=Z( J1 , J2 , J3)+TEMP*Z(J1 ,J2,J5) 
RETURN 

ENTRY DELT(BET) 

H=BET*H 
TEMP=1 
DO 6 03=2 ,Q 
TEMP=TEMP*BET 
DO 6 01 = 1 ,2 
DO 6 02=1 , N 

6 Z<01 ,02,03) = TEMP*Z(01 ,J2,J3) 

RETURN 

ENTRY INCR(U) 

DO 7 01 = 1 ,2 
DO 7 02=1 ,N 
DO 7 03=1 ,0 

7 Z(01 ,02,03)=Z( J1 , 02 , J3)+ALP(03,Q)*U(01 , 02 ) 
RETURN 

ENTRY OUTPUT(FINISH) 

TO=T 

REFOC 1 )=REF( 1 ) 

REFO(2)=REF(2) 

WRITE(7)T0, (REFO(03),(RIC(02,1 ,03), 02=1 ,N) 
FINISH=. FALSE. 

I F( T. LT. TMAX) RETURN 
FI NI SH= . TRUE . 

TIC=T 

DO 8 03=1 ,3 
ANGIC(J3)=ANG(J3) 

DO 8 01 = 1 ,2 

8 ROIC(01 ,03)=RO(01 ,03) 

WRITE(3,IC) 

WRITEC6, FIN) 

RETURN 
ENTRY ANGLE 
DT=T-TIC 


,03=1 ,2) 


0019300 ANG(3)=ANGIC(3) 

0019400 ANG(2)=ANGIC(2)+ANGIC(3)*DT 

0019500 ANG( 1 )=ANGIC( 1 )+ANGIC(2)*DT+ . 5*ANGIC( 3)*DT**2 

0019600 DO 9 J 1 = 1 ,2 

0019700 RO( J 1 , 3 > = RO I C < J 1 ,3) 

0019800 RO( J1 ,2)=R0IC(J1 ,2)+ROIC(Jl ,3)*DT 

0019900 9 R0(J1 , 1 )=ROIC( J 1 , 1 )+ROIC( J 1 ,2)*DT+.5*R0IC(J1 , 3)DT**2 

0020000 REF ( 1 )=CDEXP( (0 . ,1 . )*ANG( 1 ) ) 

0020100 REF(2)=(0. ,1 . )*ANG(2)*REF( 1 ) 

0020200 REF(3)=((0. , 1 . ) *ANG( 3)-ANG( 2) **2 )*REF( 1 ) 

0020300 DO 10 J 2 = 1 , N 

0020400 C(1 , J2)=2*AMP*ALP( 3,Q)*M(J2)/H**2 

0020500 C(2,J2)=(AMP*(2*ALP(3,Q)*IT(J2)/H**2-<0. ,1 . )*IP(J2)* 

0020600 1 (ALP (2 ,Q)*ANG(2) /H+ALP( 1 ,Q)*ANG(3))))/L(J2)**2 

0020700 DO 10 J 1 = 1 ,2 

0020800 U( J 1 , J2 )=0 

0020900 10 CONTINUE 

0021000 RETURN 

0021100 ENTRY RADIUS (R.U.JJl ,JJ2,J) 

0021200 TEMP=AMP 

0021300 I F ( J J 1 . EQ. 2) TEMP=TEMP/ L( J ) 

0021400 DO 11 J 3= 1 ,3 

0021500 R( JJ1 , JJ2 , J3)=(Z( JJ1 , J , J3)+ALP( J3,Q)*U( JJ1 ,J))*TEMP 

0021600 11 TEMP=J3*TEMP/H 

0021700 RIC(J , JJ1 , 1 )=R( JJ1 , J 32 , 1 ) 

0021800 RIC( J , JJ1 ,2)=R( JJ1 ,JJ2,2) 

0021900 ABSR=CABS(RIC( J1 ,1,1)) 

0022000 IF(ABSR.GT.RMAX) RMAX=ABSR 

0022100 RETURN 

0022200 ENTRY BC(R,3J0, JJ2) 

0022300 13 DO 14 J3=l,3 

0022400 DO 14 J 1 = 1 ,2 

0022500 14 R ( J 1 ,JJ2,J3)=REF(J3*RBC(JJ0,J1 ) 

0022600 RETURN 

0022700 ENTRY DEQ(F,R,J) 

0022800 F( 1 )=(-R( 1 ,2 , 3)-RCG( J , 1 ) *REF( 3)-R0( 1 , 3))*M(J) 

0022900 1 -K( 1 , 1 , J , 1 )*R( 1 , 1 , 1 )-K( 1 , 1 , J ,2)*R( 1 ,2 , 1 )-K( 1 ,1 ,J,3)*R(I,3,1) 

0023000 2 — K( 1 ,2,J,1)*R(2,1 ,1)-K(1 ,2,J,2)*R(2,2,1)-K(1 ,2,J,3)*R(2,3,1) 

0023100 F(2)=((-R(2,2 , 3)-RCG( J ,2)*REF(3)-RO(2,3))*IT(J) - 

0023200 1 +(0. ,1 .)*IP(J)*(ANG(2)*(R(2,2,2)+RCG(J,2)*REF(2)+RO(2,2)) - 

0023300 2 +ANG( 3) *( R(2 ,2,1 )+RCG( J ,2)*REF(l)+RO(2,l))) 

0023400 3 — K ( 2 , 1 , J , 1 )*R( 1 ,1 , 1 )-K(2 , 1 , J , 2)*R( 1 ,2,1) -K (2,1 ,J,3)*R(1 ,3,1) 

0023500 4 


-K(2,2,J,1)*R(2,1,1)-K(2,2,J,2)*R(2,2,1)-K(2,2,J,3)*R(2,3,1))/L(J) 


0023600 

RETURN 


0023700 

ENTRY ROTOR(A) 

0023800 

DO 15 J 1 =1 

,2 

0023900 

DO 15 02=1 

,2 

0024000 

DO 15 J 3= 1 

,2 

0024100 

DO 15 J 4= 1 

,N 

0024200 

DO 15 J 5= 1 

,3 

0024300 

15 A ( J 1 ,02 , J 3 

,34, 

0024400 

DO 16 04=1 

, N 

0024500 

DO 16 01=1 

,2 

0024600 

A ( 0 1 ,1 ,01 ,04,2 


12 



0024700 A(J1 ,2,J1 , J4,2)=-(0. ,1 . )*C(J1 ,J4) 

0024800 DO 16 J3=l ,2 

0024900 DO 16 J5=l , 3 

0025000 JJ=J4+J5-2 

0025100 IFCJJ.LT.l .OR.JJ.GT.N) GO TO 16 

0025200 TEMP=AMP*ALP( 1 ,Q> 

0025300 IF( J3 . EQ. 2) TEMP=TEMP/L(JJ) 

0025400 IFdl.EQ.2) TEMP=TEMP/L( J4) 

0025500 A(J1 ,1 ,J3,J4,J5)=A(J1 ,1 ,J3,J4,J5)-K(J1 , J3, J4, J5)*TEMP 

0025600 A ( J 1 , 2 , J3 , J4 , J5)=A( J 1 ,2 , J3, J4, J5)-(0. , 1 . )*K(J1 , J3 , J4 , J5) *TEMP 
0025700 16 CONTINUE 

0025800 RETURN 

0025900 END 

0026000 LOGICAL RUNCTION NEWRAP(U , E , N) 

0026100 COMPLEX* 1 6 A( 2 , 2 ,2 ,24 , 3) , F( 2 , 24) , DU ( 2 , 24) ,U(2 , 24) 

0026200 CALL ANGLE 

0026300 DO 2 ITTER=1 ,20 

0026400 E=0 

0026500 CALL JACOB( A , F ,U , ITTER , N) 

0026600 CALL SOLVE(A,F,DU,N) 

0026700 NEWRAP= . TRUE . 

0026800 DO 1 J2-1.N 

0026900 DO 1 Jl-1 ,2 

0027000 U(J1 , J2 )=U( J 1 , J2)+DU( J1 ,J2) 

0027100 ABSU=CDABS(U( J 1 ,J2)) 

0027200 IF(ABSU.GT.E) E=ABSU 

0027300 I F ( CDABS < DU ( J 1 ,J2)) .GT. 1 . E-10)NEWRAP= . FALSE. 

0027400 1 CONTINUE 

0027500 IF(NEWRAP) RETURN 

0027600 2 CONTINUE 

0027700 RETURN 

0027800 END 

0027900 SUBROUTINE JACOB(A,G,U, ITTER, N) 

0028000 COMPLEX* 1 6 A(2 ,2 ,2 ,24, 3) , F(2 ,24) ,DU 

0028100 COMPLEX* 1 6 U(2 ,24) ,R(2 ,3,3) ,F0(2) , FI (2) 

0028200 LOGICAL LOC.FLAG 

0028300 COMMON /JAC/LOC( 24) 

0028400 FLAG=. FALSE. 

0028500 I F(MOD( ITTER , 4) . EQ . 1 ) FLAG=.TRUE. 

0028600 I F ( FLAG ) CALL ROTOR(A) 

0028700 CALL BC(R,1,1) 

0028800 DO 1 Jl-1 ,2 

0028900 1 CALL RADIUS( R ,U , J 1 ,2,1) 

0029000 DO 9 14=1 , N 

0029100 I F( J4 , LT . N) GO TO 2 

0029200 CALL BC(R,2,3) 

0029300 GO TO 4 

0029400 2 J 5= J 4+ 1 

0029500 DO 3 Jl-1 ,2 

0029600 3 CALL RADIUS (R.U.Jl ,3,J5) 

0029700 4 CALL DEQ(F(1 ,J4),R,J4) 

0029800 IF( . NOT . LOC( J4) ) GO TO 10 

0029900 CALL EXTERC FO , R , J4) 

0030000 F( 1 , J 4 ) = F ( 1 , J4) + F0( 1 ) 

0030100 F(2,24)=F(2,J4)+FO(2) f 


13 



0030200 

0030300 

0030400 

0030500 

0030600 

0030700 

0030800 

0030900 

0031000 

0031100 

0031200 

0031300 

0031400 

0031500 

0031600 

0031700 

0031800 

0031900 

0032000 

0032100 

0032200 

0032300 

0032400 

0032500 

0032600 

0032700 

0032800 

0032900 

0033000 

0033100 

0033200 

0033300 

0033400 

0033500 

0033600 

0033700 

0033800 

0033900 

0034000 

0034100 

0034200 

0034300 

0034400 

0034500 

0034600 

0034700 

0034800 

0034900 

0035000 

0035100 

0035200 

0035300 

0035400 

0035500 

0035600 


I F( .NOT. FLAG) GO TO 10 
DO 8 J 5= 1 ,3 
J-J4+J5-2 

IF(J.LT. 1 .OR. J.GT.N) GO TO 8 

DO 7 33*1 ,2 

ABSDU=1 . E-08 

DlUABSDU 

DO 6 02=1 ,2 

U(J3,J)=U(J3, J)+DU 

CALL RADIUSC R ,U , J3 , J5 , J ) 

CALL EXTERCFl ,R,J4) 

DO 5 01=1 ,2 

5 A ( 0 1 , 02, 03, 04, 05) =A (01 ,02,03,04,05) + (Fl(01 ) — F0< 0 1 ) ) / ABSDU 
U(03,0)=U(03,0)-DU 

6 DU=(0 . , 1 . ) *DU 

CALL RADIUS ( R , U , 0 3 , 0 5 , 0 ) 

7 CONTINUE 

8 CONTINUE 

10 DO 9 01=1 ,2 
DO 9 02=1 ,2 
DO 9 03=1 ,3 

9 R ( 0 1 ,J2,J3)=R(J1 ,02+1 ,03) 

RETURN 

END 

SUBROUTINE SOLVE( A , F , DU , N) 

REAL*8 A(4,4,24,3),F(4,24),DU(4,24) 

REAL*8 B(4,4,24,3),C(4,24),BP,BR 
DO 1 I B= 1 , N 
DO 1 1=1,4 
C( I , IB)=F( I , IB) 

DO 1 0 B= 1 ,3 
DO 1 0=1 ,4 

1 B(I,0,IB,0B)=A(I,0,IB,0B) 

DO 11 IB-1, N 
DO 11 IP-1,4 
BP=B( IP , IP , IB ,2) 

DO 2 O-IP , 4 

B( IP,0 , IB,2)=B< IP ,0 , IB,2>/BP 
DO 3 J=1 ,4 

3 B(IP,0,IB,3)=B(IP,0,IB,3)/BP 
C(IP,IB)=C(IP,IB)/BP 
IFdP.EQ.4) GO TO 7 
Il-IP+1 
DO 6 1=11 ,4 
BR=B(I , IP, IB, 2) 

DO 4 J=IP,4 

B(I,0,IB,2)=B<I,0 , IB,2)-BR*B( IP , J , IB,2) 

DO 5 0=1 , 4 

5 B(I,0,IB,3)«B(I,0 , IB, 3)-BR*B( IP ,0 , IB,3) 

6 C ( I . I B ) =C < I , IB)=BR*C( IP , IB) 

7 IF(IB.EQ.N) GO TO 11 
DO 10 1=1,4 

BR=B( I , IP , IB+1 ,1) 

DO 8 0 = I P , 4 

8 B( I ,0 , IB+1 ,1 )=B( I , J , IB+1 ,1 )-BR*B( IP, J , IB, 2) 


14 



0035700 


DO 9 J=1 ,4 

0035800 

9 

B( I , J , IB+1 , 2 ) = B( I , J , IB-1 , 2 )-BR*B( IP , J , IB , 3 ) 

0035900 

10 

C( I , IB+1 )=C(I ,IB+1)-BR*C(IP,IB) 

0036000 

1 1 

CONTINUE 

0036100 


DO 15 I B I = 1 , N 

0036200 


IB=N+1 -IBI 

0036300 

DO 15 11=1,4 

0036400 


1=5-11 

0036500 


DU( I , IB)=-C( I , IB) 

0036600 


IF(I .EQ.4) GO TO 13 

0036700 


J 1 =1+1 

0036800 


DO 12 J=J1 ,4 

0036900 

12 

DU ( I , IB)=DU( I,IB)-B(I,J,IB,2)*DU(J,IB) 

0037000 

13 

IF(IB.EQ.N) GO TO 15 

0037100 


DO 14 J=1 ,4 

0037200 

14 

DU(I,IB)=DU(I,IB)-B(I,J,IB,3)*DU(J,IB+1 ) 

0037300 

15 

CONTINUE 

0037400 


RETURN 

0037500 


END 

0037600 


SUBROUTINE EXTER(F,R,J) 

0037700 C 

F(2)=TORQUE( J)/L( J) 

0037800 


COMPLEX* 1 6 F( 2 ) , R( 2 , 3 , 3) 

0037900 


REAl*8 DEL 

0038000 


F( 1 )=0 

0038100 


F(2)=0 

0038200 


IF( J . EQ. 5 .OR. J . EQ. 1 9) GO TO 1 

0038300 


GO TO 2 

0038400 

1 

CALL JOURNL( F( 1),R(1,2,1),R(1,2,2),0. ,005 . ,00263 . .TRUE . ) 

0038500 


F(1)=F(1)-5000.*R(1 ,2,1) 

0038600 


RETURN 

0038700 

2 

I F ( J . EQ . 3 . OR . J . EQ . 1 2 . OR . J . EQ . 2 1 ) GO TO 3 

0038800 


RETURN 

0038900 

3 

DEL=CDABS(R( 1 ,2,1 )) 

0039000 


IF(DEL.LE. .002) RETURN 

0039100 


DEL-1 .-.002/DEL 

0039200 


F( 1 ) — 1 .D+05* ( 1 . , . 1 )*DEL*R(1 ,2,1 ) 

0039300 


RETURN 

0039400 


END 

0039500 


SUBROUTINE JOURNL(F , R , RDOT .OMEGA ,CR , FO, CAV) 

0039600 


IMPLICIT REAL*8(A-H ,0-Z) 

0039700 


COMPLEX* 16 F , R , RDOT , EPS , V , N , ( 2 ) ,A(2> ,B<2> ,C(2> ,DN<2> ,NSQ 

0039800 


REAL*8 X( 2 ) 

0039900 


REAL*4 OMEGA, CR,FO 

0040000 


LOGICAL CAV 

0040100 


EQUIVALENCE (EPS,X) 

0040200 


DATA PI/3.141 592 654/ 

0040300 


EPS=R/CR 

0040400 


V=RDOT/CR- ( 0 . , 1 . ) ‘OMEGA* EPS 

0040500 


F=0 

0040600 


IF(CDABS(V) . EQ.O) RETURN 

0040700 


EPS=CDABS(V)*EPS/V 

0040800 


H-EPS*DCONJG( EPS) 

0040900 


IF(H.GT. 1 . D- 1 2 ) GO TO 3 

0041000 


IF(.NOT.CAC) F=PI*FO*V 

0041100 


IF(CAV) F=-FO*V* (PI/2+2*(EPS+X(l))) 



0041200 


RETURN 

0041300 

3 

D=DSQRT( 1-H) 

0041400 


N( 1 ) = EPS * ( 1 — D ) / H 

0041500 


N(2)=EPS*(1+D)/H 

0041600 


F=8*F0*V/DC0NJG( E PS ) * * 3 

0041700 


DN( 1 )=N( 1 )-N(2) 

0041800 


DN(2)=DN( 1 ) 

0041900 


DO 2 1=1 ,2 

0042000 


NSQ=N( I ) **2 

0042100 


A( I )=NSQ**( NSQ)+1 ) /DN( I ) **3 

0042200 


B(I)=(2*N(I)* ( 2* NSQ+1 )/DN(I)**2-3*A(I))/DN(I) 

0042300 


C( I )=( ( (6*NSQ+1 )/DN(I)-3*A(I))/DN(I)-3*B(I))/DN(I 

0042400 


IF(CAV) GO TO 1 

0042500 


F=PI *C( 1 ) *F 

0042600 


RETURN 

0042700 

1 

A(I) = N(I)*A(I ) /( NSQ+1 ) **2 

0042800 

2 

B( I )=B( I ) / ( NSQ+1 ) 

0042900 


F=(-A(1)-A(2)+B(1)+B(2)-C(1)*DATAN2(-D,X(1)))*F 

0043000 


RETURN 

0043100 


END 

0043200 


REAL VARS C 7 ) ,DVAR(7) ,CL(10),DCL(10) ,LABLE(8) 

0043300 


REAL X(24),Y(24),S(24) ,XCG(24) ,YCG(24) ,T(2) 

0043400 


INTEGER IVAR( 3) 

0043500 


LOGICAL CG 

0043600 


COMPLEX R( 2 , 2 , 24) , REF< 2 , 2 ) ,FO,RO,REFO, RCG( 24) 

0043700 


NAMELIST/FRAM/H , RMAX , TMIN , TMAX , NUM.CG, LABLE 

0043800 


DATA DVAR/7. ,2.5,0. ,0. ,1 . ,1 . ,2./ 

0043900 


DATA DCL/-1 . ,-.6, -.55, -.45, -.4, .4,. 45,. 55, .6,1 ./ 

0044000 


READ(5, FRAM) 

0044100 


READ(7) N ,SMAX , (S( J) , J=1 ,N) ,(RCG(J) , J=1 ,N) 

0044200 


READ(7) T( 1 ) , REF(J3,1),(R(J3,1,J),J=1,N),J3=1,2) 

0044300 


READ(7) T(2),(REF(J3,2),(R(J3,2,J),J=1 ,N),J3=1 ,2) 

0044400 


CALL GMOVIE(200) 

0044500 


CALL TITLECl ,32 ,29, LABLE) 

0044600 


DO 1 1=1,7 

0044700 

1 

VARS( I )=DVAR( I ) 

0044800 


VARS(5)=RMAX 

0044900 


DO 2 1=1,10 

0045000 

2 

CL ( I )=DCL( I ) *RMAX 

0045100 


IVARd ) = 3 

0045200 


DO 4 J = 1 , N 

0045300 

4 

S(J)=RMAX*(2*S<J)/SMAX-1) 

0045400 


TO=TMIN 

0045500 

3 

VARS ( 3 ) =0 

0045600 


CALL I NTENS < 40 ) 

0045700 


CALL XAXI S ( 5 . , 5 . , VARS) 

0045800 


VARS( 3)=90 

0045900 


CALL YAXIS( 5 . , 5 . , VARS) 

0046000 


IVAR(2)=2 

0046100 


IVAR( 3)=0 

0046200 


DO 5 1=1 ,5 

0046300 

5 

CALL GP LOT <CL(2*I — 1 ) ,CL(2*I — 1 ) , I VAR) 

0046400 


CALL INTENS(20) 

0046500 


DO 10 I TTER= 1 , NUM 

0046600 

6 

I F( TO. LE . T(2 ) ) GO TO 8 


16 


0046700 

0046800 

0046900 

0047000 

0047100 

0047200 

0047300 

0047400 

0047500 

0047600 

0047700 

0047800 

0047900 

0048000 

0048100 

0048200 

0048300 

0048400 

0048500 

0048600 

0048700 

0048800 

0048900 

0049000 

0049100 

0049200 

0049300 

0049400 

0049500 

0049600 

0049700 

0049800 

0049900 

0050000 

0050100 

0050200 

0050300 

0050400 

0050500 

0050600 


T ( 1 ) = T( 2 ) 

DO 7 J 3= 1 ,2 
R E F ( J 3 , 1 ) = REF( J3 ,2) 

DO 7 J = 1 , N 

7 R < J 3 , 1 , J) = R( J3,2 , J) 

READ(7 , END=1 1 , ERR=1 1 ) T(2),(REF(J3,2),(R(J3,2,J),J=1 ,N) ,J3=1 ,2) 
GO TO 6 

8 REFO=FO( REF , T , TO) 

DO 9 J=1 ,N 

RO=FO( R( 1,1,J),T,T0)-(1 . , 1 . )*S(J) 

X( J)=REAL(RO) 

Y ( J )=AIMAG( RO) 

RO=RO+RCG( J)*REFO 
XCG(J)=REAL(RO) 

9 YCG( J )=AIMAG( RO) 

IVAR(2)=N 

IVAR( 3)=0 

CALL GPLOT ( X , Y , IVAR) 

I VAR ( 3 ) = 1 

IF(CG) CALL GPLOT(XCG, YCG, IVAR) 

10 TO=TO+H 

CALL DISPLA(l) 

CALL GMOVIE(NUM) 

IF(TO. LT.TMAX) GO TO 3 

11 CALL TERM 
STOP 

END 

COMPLEX FUNCTION FO(F,X,XO) 

COMPLEX F( 2 , 2 ) , A 
REAL X ( 2 ) ,H(2) ,D(2) 

F0=0 

D( 1 )=X( 1 )-X( 2 ) 

H( 1 ) = ( (XO-X( 2 ) ) / D ( 1 ) )**2 
D( 2 )=X(2 )-X( 1 ) 

H(2 )=( (XO-X( 1))/D(2))**2 
DO 1 J=1 ,2 

A=F(2,J)-2*F(1 ,J)/D(J) 

1 F0=F0+H(J)*(F(1 , J )+A*(XO-X( J) ) ) 

RETURN 

END 


17 


APPENDIX B: THE DATA-FLOW STATEMENT 


PROGRAM SHAFT 
CONSTANTS(REAL) 

PI=3. 141593; 

G= 386 . 4 ; 

ALP (4,4) = [600. ,.5,0.,2.,3.,1. ,0. ,6. , 1 1 . ,6. , 1 . ] ; 

K41 60=8.0* .00263/ .005; 

K41 1 A0=-.00263*PI/(2* .005) ; 

K41 1 B0=- .00263*2/ .005 ; 

VARIABLES (BOOLEAN) 

LOC( 24) ; 

CONVERGED; 

STOP; 

CURRENT 

VARIABLES ( INTEGER) 

N( 24) ; {NUMBER OF SEGMENTS} 

0(2. .4); {ORDER OF INTEGRATION} 

VARIABLES(REAL) 

L ( 2 4 ) ; {LENGTH OF ELEMENT} 

DO(24); {OUTSIDE DIAMETER OF ELEMENT} 

DI(24); {INSIDE DIAMETER OF ELEMENT} 

S( 24) ; {AXIAL DISTANCE OF ELEMENT'S CENTER} 

M( 24) ; {MASS OF ELEMENT} 

IT (24) ; {ELEMENT'S TRANSVERSE MOMENT OF INERTIA} 

I P ( 2 4 ) ; {ELEMENT'S POLAR MOMENT OF INERTIA} 

E( 24) ; {YOUNG'S MODULUS OF ELEMENT} 

RHO< 24) ; {DENSITY OF ELEMENT} 

SMAX; {LENGTH OF SHAFT} 

DBC(2) ; {DIAMETER OF BOUNDRY ELEMENTS} 

LBC(2) ; {LENGTH OF BOUNDRY ELEMENTS} 

EBC(2) ; {YOUNG'S MODULUS OF BOUNDRY ELEMENTS} 
K(2,2,24,3) ; {STIFFNESS MATRIX} 

ANGICC 3 ) ; {INITIAL SHAFT ANGLE PROPERTIES} 
DELTA_ANGLE(3); {TIME-VARIANT SHAFT ANGLE DISPLACEMENT} 
TIC; {INITIAL TIME} 

AMP; 

OMEGA; {FREQUENCY} 

T; {ACCUMULATED TIME} 

TMAX; {MAXIMUM OF ACCUMULATED TIME} 

RMAX ; 

H; {NON-DIMENSIONAL TIME STEP} 

ALP2 ; {RESET PARAMETER} 

P204 , P205 , P206 , P2 1 5 ; {NEWRAP PARAMETERS} 

ERR ' 

VARIBLES(COMPLEX) 

KL(2,2 > 2,24,3),KLI(2,2,2,24,3); {ROTOR PARAMETERS} 

U(2 ,24) ; {NON-DIMENSIONAL Q+l DERIVATIVES} 

Z(2,24,4) ; {NON-DIMENSIONAL <=Q DERIVATIVES} 

R(2 ,3,3) ; 

RE F ( 3 ) ; 

R0(2 , 3) ; 

RE F0( 2 ) ; 

RIC(24,2 ,2) ; 

RCG(24,2) ; 

ROIC (2,3) ; 


18 



NAME_LI STS 

GEOMETRY : N,L, DO, DI.E.RHO.M, IT, IP, DBC.EBC.LBC; 
SHAFT :ALP2,N,M,IT,IP,K,L, S ,SMAX ; 

IC: RIC.RCG, ROIC, ANGIC, TIC, RBC.LOC; 

START: TMAX, AMP, OMEGA; 

PARAMS:T,H,Q,RMAX,KL,KLI , Z , P204 , P205 , P206 , P2 1 5 ; 
FORCEFUN : DELTA_ANGLE ; 

SOLUTION : CONVERGED, U, ERR, RIC; 

RESULTS :N,SMAX,S,T,REFO,RIC,RMAX,RCG; 


BEGIN {SHAFT} 

1 READ [ GEOMETRY \SHAFT_DATA_F I LEI ] ; 

2 DO_IN_PARALLEL 
BEGIN 

DELTA_ANGLE=KO; 

INITIALIZEC SHAFT \GEOME TRY ] ; 

READtSTARTUERMINAL]; 

READ[IC\SHAFT_DATA FILE2 ] 

END; 

3 RES ET [ PARAMS \SHAFT .START , IC] ; 

4 NEHRAP[SOLUTION\ FORCE FUN , PARAMS .SHAFT] ; 

5 IF CONVERGED THEN 
BEGIN {5 ( T > } 

1 DO_IN_PARALLEL 
BEGIN 

STOP=FALSE ; CURRENT=FALSE 
END; 

2 WHILE NOT STOP DO 
BEGIN 

1 DO_IN_PARALLEL 
BEGIN 

READCSTOP \ TERMI NAL ] ; 

READ[FORCEFUN\FORCING FUNCTION INPUT DEVICE]; 

{* THESE RESULTS ARE PIPELINED. THE ACTUAL DISPLAY *} 
{* TAKES PLACE AT T-T-2. *} 

CALCULATE[RESULTS\CURRENT,FORCEFUN, PARAMS .SHAFT]; 
DOMOVIE[CURRENT\ RESULTS] 

END {5(T> .2.1} 

END { 5 ( T ) .2} 

END { 5 < T) } 

END; {SHAFT} 


20 



PROCEDURE INITIALIZE[SHAFT\GEOMETRY] ; 

CONSTANTS(REAL) 

K2=2 ; 

KP5=l/2; 

KP2 5= 1 / 4 ; 

KP 167=1/6; 

KPI064=PI/64; 

KPI04G=PI/4*G; 

KPI032G=PI/32*G; 

KPI064G=PI/64*G; 

KPI048G=PI/48*G 
VARIABLES(REAL) ; 

D02(24) ; D04(24; DI2(24); D 1 4 ( 2 4 ) ; L2( 24) ; LR( 24) ; KE< 24) ; 

KLR4(24) ; KLR32(24); KLR64(24); T 1 3 ( 2 4 ) ; T14AC24); T1 4B( 24) ; T24(24); 
TDELK24) ; DELT(24) ; AP(2 ,4,0. .25) ; B(2,4,24); DBC2(2); DBC4(2); KEB(2) 
BEGIN {INITIALIZE} 

1 DO_IN_PARALLEL 

FOR_ALL J : =1 . . N AND I : = 1 . . 2 
BEGIN {VI [206] : R=B*C} 

ALP2=K2*ALP(3,3) ; {USED IN RESET} 

S( 1 )=L( 1 )*KP5; 

DBC2( I )=DBC( I )*DBC( I ) ; 

D02( J)=DO( J)*DO( J) ; 

DI2(J)-DKJ)*DI<J); 

L2( J)=L( J)*L( J) ; 

LR( J)=L( J)*RHO(J) ; 

KEB(I)=EBC( I )*KPI064 ; 

KE( J)=E( J)*KPI064; 

AP(1 ,2,0)=LBC(1 )*KP5; 

AP( 1 ,2 , J )=L( J)*KP5 ; 

AP(1 ,2,N+1)-LBC(2)*KP5; 

AP( 1 ,3,0)=LBC(1 )*KP25; 

AP ( 1 ,3,J)=L(J)*KP25; 

AP < 1 ,3,N+1 )=LBC(2)*KP25 ; 

AP ( 1 ,4,0)=LBC( 1 ) * KP 167; 

AP ( 1 ,4,J)=L(J)*KP167; 

AP( 1 ,4,N+1 )=LBC(2)*KP1 67 ; 

DBC2 ( I )=DBC( I )*DBC( I ) 

END; 


21 



2 DO_IN_PARALLEL 
BEGIN 

FOR_ALL J : = 1 . .N AND I :=1 . .2 
BEGIN {V2A [ 1 48 ] :R=B*C} 

DBC4( I )=DBC2( I ) *DBC2( I ) ; 

D04(J)=D02(J)*D02(J) ; 

DI4(J)=DI2(J)*DI2(J); 

AP<1 ,3,0>-AP<l ,3,0)*AP<1 ,2,0); 

A P ( 1 , 3 , J )=AP( 1 ,3, J)*AP( 1 ,2 , J) ; 

AP ( 1 , 3 ,N+1 )=AP( 1 , 3 , N+l )*AP< 1 ,2,N+1>; 

KLR4( J)=LR( J)*KPI04G; 

KLR32( J)=LR( J)*KPI032G; 

KLR64( J )=LR( J ) *KPI064G 
END; 

FOR ALL J :=1 . .N {V2BC24] : R=B+C*D*E*( F-G) } 

IT( J) = IT( J) + L2( J)*LR( J)*KPI048G*(D02( J)-DI2( J) ) 
END; {2} 


22 



INITIALIZE (CONTINUED) 

3 DO_IN_PARALLEL 
BEGIN 

FOR_ALL J : =2 . . N {V3AC231 : R=B+C+D} 

S( J)=S( J-1 )+AP( 1 ,2 , J)+AP( 1 ,2 , J-l ) ; 

FOR_ALL J :=1 . . N 

BEGIN {V3B[72 ] : R=B+C(D-E) } 

M( J)=M( J )+<LR4( J ) *(D02( J )-DI2( J ) ) ; 
IP(J)=IP(J)+KLR32(J) * (D04( J )-DI4( J ) ) ; 
IT(J)=IT(J)+KLR64(J)*( D04( J )-DI4( J ) ) 

END; 

FOR_ALL 3 : = 1 . . N 

BEGIN {V3CE961 : R=B/(C* (D-E) ) } 

AP(2 , 3 , J ) =AP ( 1 , 2 , J ) /(KE( J ) *(D04( J)-DI4( J) ) ) ; 
AP(1 , 3 , J )=AP( 1 ,3,J)/<KE(J) * (D04( J )-DI4( J ) ) ) ; 
AP ( 2 , 4, J )=AP( 1 ,3,J)/(KE(J ) *(D04( J )-DI4( J ) ) ) ; 
AP ( 1 , 4 , J )=AP( 1 ,4,J)/(KE(J)*( D04( J ) — D 1 4 ( J ) ) ) 
END; 

BEGIN { V3D [ 8 ] :R=B/(C*D)} 

AP(2 , 3 ,0)=AP( 1,2,0)/(KEB(1) *DBC4( 1 ) ) ; 

AP( 2 , 3 , N+l )=AP( 1 ,2,N+1 )/(KEB(2)*DBC4(2) ) ; 

AP( 1 , 3 ,0)=AP( 1 ,3,0)/ ( KEB < 1 ) *DBC4( 1 ) ) ; 

AP(1 ,3, N+l )=APd ,3,N+1)/(KEB(2 ) * DBC4 ( 2 ) ) ; 

AP ( 2 , 4 ,0)=AP( 1 ,3,0)/(KEBd ) *DBC4( 1 ) ) ; 

AP(2 ,4, N+l )=AP( 1 , 3 , N+l ) / (KEB( 2) *DBC4(2) ) ; 

AP ( 1 , 4 ,0)=AP( l,4,0)/(KEBd) *DBC4( 1 ) ) ; 

APd ,4 , N+l )=AP(1 ,4 , N+l ) / (KEB( 2) *DBC4(2 ) ) 

END 

END; {3} 

4 DO_IN_PARALLEL 
BEGIN 

FOR_ALL J: = l . .N+l 
BEGIN { V4A [ 1 25] : R=B+C} 

B( 1 , 2 , J)=AP( 1 , 2 , J-1 )+AP( 1 ,2 , J) ; 

Bd ,3,J)=AP<1 ,3,J-1)+AP<1 ,3,3); 

B( 1 ,4, J)=AP( 1 ,4, J-l )+AP( 1 ,4, J) ; 

B(2 , 3 , J )=AP( 2 , 3 , J-l )+AP(2,3,J) ; 

B(2 , 4 , J )=AP(2 , 4 , J-l )+AP(2,4,J) 

END; 

FOR_ALL J :=1 . .N+l 
BEGIN {V4B[100]:R=B*C} 

T1 3 < J ) =AP ( 1 ,2 , J)*AP<2 , 3 , J-1 ) ; 

T1 4A( J )=AP( 1 ,2 , J)*AP(2 , 4, J-l ) ; 

T 1 4B( J ) =AP < 1 , 3 , J ) * AP ( 1 ,2, J-l); 

T24( J )=AP(2 , 3, J)*AP( 1 ,2 , J-l ) 

END 

END; {4} 


23 



INITIALIZE (CONTINUED) 

5 DO_IN_PARALLEL 
BEGIN 

FOR_ALL J:=l . .N+l 
BEGIN { V 5A C 50 ] : R=B+C} 

B( 1 ,3, J)=B( 1 ,3,J)+T13(J) ; 

B(2,4,J)=B(2,4,J)+T24(J) 

END; 

FOR_ALL J : = 1 . . N {V5BC 24 ] : R=B+C+D} 

B( 1 ,4, J)=B( 1 ,4,J)+T14A(J)+T14B(J) 

END; {5} 

6 do_in_parallel 

FOR_ALL J :=1 . .N+l 
BEGIN {V6I48] : R=B*C} 

TDELT( J )=B( 1 ,4,J)*B(2,3,J); 

DELT( J )=B( 1 ,3,J)*B(2,4,J) 

END; {6} 

7 DO_IN_PARALLEL 

FOR_ALL J : =1 . .N+l {V7[24] : R=B-C} 

DELT(J)=DELT( J)-TDELT(J) ; 

8 DO_IN_PARALLEL 
FOR_ALL J :=1 . .N+l 
BEGIN { V8 C 96 ] : R=B/C} 

B( 1 , 3 , J )=B( 1 ,3,J)/DELT ; 

B(2,4,J)=B(2,4,J)/DELT; 

B(2,3,J)=B(2,3,J)/DELT; 

B( 1 , 4 , J )=B( 1 ,4, J)/DELT 
END; {8} 

9 do_in_parallel 

BEGIN 

FOR_ALL J : =2 TO N+l 
BEGIN {V9A[ 1 20] : A=B} 

<( 1 ,1 ,J-1 ,1 )=B(2,3,J-1); 

<(2,1 , J-l ,3)=B(1 ,3,3-1 ) ; 

K ( 2 ,2 , J — 1 , 3)=B( 1 , 4 , J - 1 ) ; 

K(1 ,1 ,J-1 ,3)=B(2,3,J) ; 

K( 1 ,2 , J-l , 3)=B(2 ,4, J) 

END; 

FOR_ALL 3 : =2 TO N+l {V9BC24] :A=-B-C*D} 

K(1 ,2, J-l , 1 )=— B(2 ,4,J— 1 )— B( 1 ,2,J— 1 )*B(2,3,J— 1 ); 

FOR_ALL 3 :=2 TO N+l {09CC24] : A=B+C*D} 

K ( 2 , 1 , J-l , 1 )=B( 1 ,3, J-l )+B(l , 2 , J-l ) *B(2 , 3 , J-1 ) ; 

FOR_ALL J :=2 TO N+l {V9DE24] : A=B+C+D* ( E+F+G) } 

<(2,2 , J-l , 1 )=B( 1 ,4, J-l ) + B( 1 ,2, J-l ) + 

B(1 ,2,J— 1 )*(B( 1 ,3,J— 1 )+B(2,3,J— 1 )+B(2,4,J— 1 )) ; 
FOR_ALL J : =2 TO N+l {V9EC24] : A=B+C} 

<(1,1 , J-l , 2 )=B( 2 , 3 , J-l )+B(2 , 3 , J ) ; 

FOR_ALL J : =2 TO N+l {V9F[24] : A=B+C+D*E} 

<(1 ,2, J-l ,2=B(2,4,J-1)+B(2,4,J)+B(2,3,J)*B(1 ,2,J); 

FOR_ALL J : =2 TO N+l {V9GE24] : A=-B-C} 

<(2,1 , J-l ,2)=-B(l , 3 , J-l )-B( 1 ,3,J); 

FOR_ALL J :=2 TO N+l {V9HC24] : A=-B-C+D*E} 

<(2,2, J-l , 2 ) =— B( 1 , 4 , J-l )-B( 1 , 4 , J )+B( 1 , 3 , J ) *B( 1 ,2,J); 
SMAX=S(N)+L(N)*<P5 
END {9} 

END; {INITIALIZE} 


24 



PROCEDURE RESET [PARAMS\ SHAFT, START, IC] ; 
CONSTANTS( IMAGINARY) 

KK0=0 

CONSTANTS( REAL) 

K2 =2 ; K0=0 ; 

BEGIN {RESET} 

1 DO_IN_PARALLEL 
BEGIN 

Q=K2 ; 

FOR_ALL 12=1 . .2 AND 1 3 : = 1 . .3 
BEGIN {VI A[27 ] : R=B} 

T=TIC; 

RMAX=K0; 

KL( 1 2 ,2,1,1 , I3)=K0 ; 

KL( 12 ,2 , N , 3 , I3)=KO ; 

KLI(I2,2, 1 , 1 ,13) =K0 ; 

KLI ( 12 ,2 , N , 3 , I3)=KO ; 

END; 

FOR_ALL J : = 1 . . N 
BEGIN {VI AC483 :A=B} 

Z(1 ,J,3)=KKO; 

Z(2 , J ,3)=KKO 
END; 

FOR_ALL J:=l . .N-l 
BEGIN {VI CC 76 3 :R=B*C} 

AMP2=AMP*K2 ; 

AMAL(2)=AMP*ALP( 1,2); 

AMAL( 3)=AMP*ALP( 1 ,3) ; 

AMAL(4)=AMP*ALP( 1,4); 

LL( J)=L( J)*L( J+l ) ; 

LL(N)=KO*KO; 

ITA( J)=IT(J)*ALP(3,3) ; 
ITA(N)=IT(N)*ALP(3,3) ; 
IPA(J)=IP(J)*ALP(2,3) ; 
IPA<N)=IP(N)*ALP(2,3); 

A2A=AMP*ALP2 

END 

END; {1} 

2 DO_IN_PARALLEL 
BEGIN 

FOR_ALL 

BEGIN {V2A C 1 70 ] :R=B/C} 

H=K1 /OMEGA; 

P21 5( J)=AMP/L( J) ; {USED IN NEWRAP RP1 } 
AOL(J)=AMAL(Q)/L(J); 
AOL2(J)=AMAL(Q)/L2(J) ; 
AOLL(J)=AMAL(Q)/LL(J); 

KIAMP=K1 /AMP ; 

KLAMP( J)=L( J)/AMP; 

AL2( J)=AMP/L2( J) ; 

A2L2(0)=AMP2/L2( J) 

END; 


FOR_ALL J:*1 . .N 
BEGIN {V2BC48 ] : A=B/C} 

HRIC1 ( J)=RIC( J , 1 , 2)/0MEGA; 
HRIC2(J)=RIC(J,2 ,2) /OMEGA 
END 

END; {2} 


26 


RESET (CONTINUED) 

3 DO_IN_PARALLEL {FORTRAN CODE: CALL ZIC} 

BEGIN 

FOR_ALL J: = l . .N 
BEGIN {V3A C 72 ] : R=B*C) 

P204(J)=A2A(J)*M( J) ; {USED IN NENRAP C(1,J)} 

P205C J)=A2L2(J)*ITA( J) ; {USED IN NENRAP T2( J ) } 

P206( J)=AL2( J)*IPA( J) {USED IN NENRAP C(2 , J) } 

END; 

FOR_ALL J : = 1 . .N 
BEGIN { V3B [ 96 ] : A=B*C} 

Z(1 ,J,1)=KIAMP*RIC(J,1 ,1); 

Z(2 , J , 1 )=KLAMP(J )*RIC( J ,2,1); 

Z(1 ,J,2)=KIAMP*HRIC1(J); 

Z(2 , J ,2)=KLAMP( J) *HRIC2( J ) 

END; 

FOR_ALL I :=1 . .3 AND J:=2. .N-1 
BEGIN {V3CC852] :R=-B*C,A=IMAG[R] ] 

KL( 1 , 1 , 1 , 1 , I )=-K( 1 ,1 ,1,1 )*AMAL(Q) ,KLI ( ) = IMAG[KL( ) ] ; 
KL( 1 , 1 , 1 ,2 , I ) =— K ( 1 ,1,1 , 2) *AMAL(Q) , KL I ( )=IMAG[KL( ) ] ; 
KL( 1 , 1 , 1 ,3 , 1 )=-K< 1,1,1 , 3)*AMAL(Q) , K L I < ) = I MAG [ K L ( ) ] ; 
KL(1 ,2,1 ,2,I)=-K(1 ,2,1 , 2 ) * AOL ( 1 ) , KL I < ) = I MAG t KL ( ) ] ; 

KLC 1 ,2,1 ,3 , I )=-K( 1,2,1, 3) *AOL( 2 ) ,KLI ( ) = I MAG [ KL ( ) ] ; 
KL(2 , 1 ,1 ,1 , I )=-K(2 ,1,1,1) *AOL( 1 ) , KL I ( )=IMAG[KL( ) ] ; 
KL(2 , 1 ,1 ,2 , I )=-K(2 ,1,1 ,2)*AOL( 1 ) ,KLI ( )=IMAG[KL( ) ] ; 

KL( 2,1 ,1 , 3 , I )=-K(2 ,1,1 , 3) *AOL( 1 ) , KLI ( ) = IMAG [ KL< ) ] ; 
KL(2 ,2 , 1 ,2 , I )=-K(2 ,2,1 ,2)*AOL2( 1 ) , KLI ()= IMAGE KLC ) ] ; 
KL(2 ,2 , 1 ,3 , 1 )=-K<2 ,2,1 , 3) *AOLL( 1 ) , KL I ( ) = I MAG [ K L ( ) ] ; 
KL( 1 , 1 , J , 1 , I )=-K( 1 , 1 , J , 1 )*AMAl(Q) ,KLI( )=IMAG[KL( ) ] ; 
KL( 1 ,1 , J ,2 , I )=-K( 1 , 1 , J ,2)*AMAL(Q) , KLI ( ) = I MAG [ KL ( ) ] ; 
KL( 1 , 1 , J ,3 , I )=-K( 1 , 1 , J ,3)*AMAL(Q) , KLI ()= IMAGE KL( ) ] ; 
KLC 1 ,2 , J , 1 , I )=-K( 1 ,2 , J , 1 )*AOL( J-l ) ,KLI< )= IMAG [KLC ) ] ; 
KLC 1 ,2 , J ,2 , I )=-K( 1 ,2 , J , 2 ) *AOL( J ) , KLI ( )=IMAG[KL( ) ] ; 

KL( 1 ,2 , J , 3 , I )=-K( 1 ,2 , J , 3) *AOL( J+l ) ,KLI ( ) = I MAG [ KL ( ) ] ; 
KL < 2 , 1 ,0,1 ,1 )=-K(2 , 1 , J , 1 ) *AOL( J ) , KLI ( ) =1 MAG [ KL ( ) ] ; 
KL(2 , 1 , J ,2 , I )=-K(2 , 1 , J , 2) *AOL( J ) , KLI ( ) = I MAG [ KL ( ) ] ; 
KL(2 , 1 , J , 3 , I )=-K(2 , 1 , J , 3) *AOL( J) ,KLI ( )=IMAG[KL< ) ] ; 
KL(2 ,2 , J , 1 , 1 )=-K(2 , 2 , J , 1 ) *AOLL( J-l ) ,KLIO-IMAG[KL< >] ; 
KL(2 ,2 , J ,2 , I )=-K(2 ,2 , J ,2) *AOL2( J) , KLI ( )= IMAG [KLC ) ] ; 
KL(2,2,J,3,I )=-K(2 ,2 , J , 3) *AOLL( J ) ,KLI ( )=IMAGCKL( ) ] ; 
KL( 1 , 1 , N , 1 , 1 )=-K( 1 , 1 , N , 1 ) *AMAL(Q) , KLI < ) = I MAG C KL ( ) ] ; 
KL( 1 ,1 ,N ,2 , I )=-K( 1,1, N ,2) *AMAL(Q) , KL I ( ) = I MAG [ KLC ) ] ; 
KL( 1 , 1 , N , 3, I )=-K( 1 , 1 ,N, 3) *AMAL(Q) , KLI ( )=IMAG[KL( ) ] ; 
KL( 1 ,2 ,N, 1 , 1 )=-K( 1 ,2 ,N , 1 )*AOL( N-1 ) , KL I ( ) = I MAG C KL ( ) ] ; 
KLC 1 ,2 , N,2 , I )=-K( 1,2, N ,2)*AOL( N) ,KLI( )=IMAG[KL( ) ] ; 

KL ( 2 , 1 , N , 1 , I )=-K(2 , 1 , N , 1 )*AOL( N) , KLI ( )= IMAG [KLC ) ] ; 
KLC2 , 1 , N,2 , I )=-K(2 , 1 ,N ,2)*AOL( N) , KLI ( )= IMAG [KLC ) ] ; 

KLC 2 , 1 ,N,3, I)»-K(2 , 1 ,N , 3)*AOL(N) , K L I ( ) = I MAG [KLC ) ] ; 

KLC 2 ,2 ,N, 1 , I)=-K(2 ,2 ,N , 1 ) * AOLLC N— 1 ) , KLI ( )=IMAG[KL( ) ] ; 
KL(2,2,N,2,I)=-K(2,2,N,2)*AOL2(N) , KLI = IMAG [KLC ) ] 

END 

END {3} 

END; {RESET} 



PROCEDURE CALCULATE [RESULTS\CURRENT,FORCEFUN,PARAMS, SHAFT]; 

BEGIN 

1 IF CURRENT THEN {1 (T) } WAIT ELSE 
BEGIN {1(E)} 

1 WHILE T<=TMAX DO {* BOTH T & TMAX ARE READ FROM DATA FILE *} 

BEGIN 

1 IF (CONVERGED AND (Q<4)> THEN {* FORTRAN CODE: *} 

DO_IN_PARALLEL {* ENTRY ORDER(U) *} 

BEGIN {* CALL INC(U) *} 

FOR_ALL I : = 1 . .2 AND J: = 1..N AND K:=Q+1 
Z(I,J,K)=U(I,J)/Q; 

Q=Q+1 

END; {1(E). 1 . 1 (T) } 

2 DO_IN_PARALLEL 
BEGIN 

T=T+H ; 

CASE Q OF 

3:FORESTEP3tZ,T\Z,T,H]; { CALL ORDER(U) ; STEP(l) FOR U=3 } 
4:FORESTEP4[Z,T\Z,T,H] ; { CALL ORDER(U) ; STEP(l) FOR U-4 } 

END 

END; {1(E). 1.2} 

3 DO_IN_PARALLEL 
BEGIN 

NEWRAP[SOLUTION\ PARAMS , IC , START . SHAFT] ; 

CASE Q OF 
3: BEGIN 

BACKSTEP3 [ ZBACK , HBACK , TBACKxZ ,H,T] ; 
HALFSTEP3[ZHALF,HHALF,THALF\Z ,H ,T] ; 

DOUBLESTEP3CZDOUBLE .HDOUBLE .TDOUBLE] 

END; 

4: BEGIN 

BACKSTEP4C ZBACK , HBACK , TBACKNZ ,H,T] ; 
HALFSTEP4[ZHALF,HHALF,THALF\Z ,H,T] ; 

DOUBLESTEP4C ZDOUBLE , HDOUBLE , TDOUBLE ] 

END 

END {CASE Q} 

END; {1(E). 1.3} 

4 IF NOT CONVERGED OR ERR>E04 THEN 
STEP [Z , H ,T\ZBACK , HBACK , TBACK] ELSE 

IF ERR< E06 THEN STEP[Z,H,T\ZDOUBLE, HDOUBLE, TDOUBLE] ELSE 
STEP[Z,H,T\ZHALF,HHALF,THALF] 

END; {1(E). 1} 

END; {1(E)} 


28 


CALCULATE (CONTINUED) 

2 DO_IN_PARALLEL 
BEGIN 

TMAX=K2*TMAX ; 

CURRENT=TRUE ; 

FOR ALL 13 :=1 . .3 
BEGIN {V2A [ 5 ] : R=B} 

TO=T ; 

TIC=T; 

ANGIC( I3)=ANG( 13) 

END; 

FOR ALL 12 : = 1 . .2 AND 1 3 : = 1 . .3 
BEGIN {V2B [ 8 ] : A=B} 

REFO( I2)=REF( 12) ; 

ROIC( 12 , I3)=RO< 12,13) 

END 

END; {2} 

3 WRITECSHAFT INPUT FILE2\IC] 

END; {CALCULATE} 


29 


PROCEDURE BACKSTEP3[ZA(2 ,24,4) : COMPLEX; HA.TA: REAL\Z(2 ,24,4) : COMPLEX ; H , T : REAL ] ; 
CONSTANTS(REAL) 

Kl = l . ; BETU.l; BET2= .01 
BEGIN 

1 DO_IN_PARALLEL {FORTRAN CODE: CALL ORDER( 3) ; STEP(-l) } 

BEGIN 
TA=T-H ; 

HA=BET1 *H ; 


i 


30 



FOR_ALL I :=1 . .2 AND J:=1..N {VI AC48] : A=B-C+D} 
ZACI,J,1)*ZCI,J,1)-ZCI,J,2)+Z(I,J,3); 

FOR ALL I :=1 . .2 AND J:=1..N {VI BC483 : A= ( B-C-D) * E } 

ZAC I , J ,2)=CZ( I , J , 2 )-ZC I , J , 3)-ZC I , J , 3) )*BET1 ; 

FOR ALL I : = 1 . .2 AND J : = 1 . .N 
BEGIN {V1CC 96] : A=B*C} 

ZA(I , J ,3)=Z( I , J ,3)*BET2 ; 

ZAC 1 ,0 ,4)=ZC I , J ,4) *K1 
END 
END 

END; {BACKSTEP3} 

PROCEDURE BACKSTEP4CZAC2 ,24,4) : COMPLEX; HA, TA: REAL\Z( 2 ,24,4) :COMPLEX;H ,T : REAL] ; 
CONSTANTS(REAL) 

Kl = l . ; BETl = .l; BET2-.01; BET3=.001; K3=3. 

VARIABLESC IMAGINARY) 

KZCl . .2,1 . .24) 

BEGIN 

1 DO_IN_PARALLEL {FORTRAN CODE: CALL ORDERC4) ; STEP(-l) } 

BEGIN 
TA=T-H ; 

HA=BET1 *H ; 

FOR_ALL I : = 1 . .2 AND J: = 1 . .N 
BEGIN (V 1 A [ 96 3 : A=B*C} 

KZ( I , J)=K3*Z( 1,3,4); 

ZAC I , J ,4)=Z( I , J ,4)*BET3 
END; 

FOR_ALL I : = 1 . .2 AND J: = 1 . .N 
BEGIN {VI BC 96 ] :A=( B-C-D+E) /F} 

ZAC I ,J,1)=(Z(I,J,1)-Z(I,J,2)-Z(I,J,4)+Z(I,J,3))*K1 ; 

ZACI,J,2) = CZCI,J,2)-ZCI,J,3)-ZCI,J , 3)+KZ( I , J ) > * BET 1 
END; 

FOR_ALL I : = 1 . . 2 AND J : = 1 . . N §V1 CC483 :A=(B-C*D)*Ee 
ZAC I , J , 3)=CZ( I , J , 3)-K3*ZC I , J ,4) )*BET2 
END 

END; {BACKSTEP4} 


31 



PROCEDURE FOREST EP3[Z( 2 ,24,4): COMPLEX\Z(2 ,24,4): COMPLEX] ; 

BEGIN 

1 FOR_ALL I :=1 . . 2 AND J:=1..N { CALL ORDER( 3) ; STEP(l.O) } 

BEGIN {VI [96] : A=B+C+D} 

Z(I,J,1)=Z(I,J,1)+Z(I,J,2)+Z(I,J,3>; 

Z(I,J,2)=Z(I,J,2) + Z(I,J,3)+Z(I,J,3) ; 

END 

END; {FORESTEP3} 

PROCEDURE F0RESTEP4C Z( 2 ,24,4): COMPLEXN Z< 2 ,24,4): COMPLEX ) ] ; 

CONSTANTS(REAL) 

K3=3 

VARIABLES(REAL) 

KZ( 1 . .2,1 . .24) 

BEGIN 

1 DO_IN_PARALLEL { CALL 0RDERC4) ; STEP(l) } 

BEGIN 

FOR_ALL I :=1 . .2 AND J:=1..N {VI A[ 48 ] : A=B*C} 

KZ( I , J)=K3*Z( I , J , 4) ; 

FOR_ALL I :=1 . .2 AND J:=l . .N 
BEGIN { V 1 B [ 1 44 ] : A=B+C+D+E} 

Z(I,J,1)«Z(I,J,1)+Z(I,J,2)+Z(I,J,3)+Z(I,J,4); 
Z(I,J,2)=Z(I,J,2)+Z(I,J,3)+Z(I,J , 3)+KZ( I , J ) ; 
Z(I,J,3)=Z(I,J,3)+Z(I,J,4)+Z(I,J,4)+Z(I,J,4) 

END 

END 

END; { F0RESTEP4} 

PROCEDURE HALFSTEP3CZAC 2 ,24,4): COMPLEX ; HA , TA : REAL\Z( 2 , 24 , 4) -.COMPLEX ; H ,T : REAL] ; 
CONSTANTS(REAL) 

K1 = 1 . ; BET1 = . 5 ; BET2= .25 

BEGIN { FORTRAN CODE: CALL ORDER(3) ; STEP ( . 5) } 

1 DO_IN_PARALLEL 
BEGIN 
TA=TA; 

HA=HA* BET 1 

FOR ALL I : = 1 . .2 AND J: = l . .N 
BEGIN {VI A[ 1 44] : A=( B*C+D) *E} 

ZA( I , J , 1 )=(U( I , J ) *ALP( 1 , 3)+Z( I , J , 1 ) ) *K1 ; 
ZA(I,J,2)=(U(I,J)*ALP(2,3)+Z(I,J,2))*BET1 ; 
ZA(I,J,3)=(U(I,J)*ALP(3,3)+Z(I,J,3))*BET2 
END; 

FOR_ALL I : = 1 . .2 AND {VI B C 48 ] : A=B} 

ZA( I,J,4)=Z(I,J,4) 

END 

END; {HALFSTEP3 } 


32 



PROCEDURE HALFSTEP4[ZA(2 ( 24,4) : COMPLEX; HA, TA:REAL\Z(2 ,24, 4): COMPLEX ;H,T: REAL]; 
CONSTANTS(REAL) 

K0=0 . ; Kl = 1 . ; BETU.5; BET2=.25; BET3=.125 
BEGIN { FORTRAN CODE: CALL ORDER(4) ; STEP(.5) } 

1 DO_IN_PARALLEL 
BEGIN 


TA=TA; 

HA=HA*BET1 ; 

FOR ALL I : = 1 . .2 AND J: = 1 . .N 
BEGIN {VI [1 92] :A=(B*C+D)*E} 

ZA(I,J,1)=(U(I,J)*ALP(1,4)+Z(I,J,1))*K1 ; 
ZA(I,J,2)=(U(I,J)*ALP(2,4)+Z(I,J,2))*BET1 ; 
ZA(I,J,3)=(U(I,0)*ALP(3,4)+Z(I,J ,3))*BET2; 
ZA(I,J,4)=(U<I,J)*ALP(4,4)+Z(I,J,4))*BET3 
END 
END 

END; {HALFSTEP4 } 


33 


PROCEDURE DOUBLESTEP4C ZA( 2 ,24,4) : COMPLEX ; HA , TA : REAL Z(2,24,4) : COMPLEX ;H,T: REAL] 
CONSTANTS(REAL) 

Kl=l . ; BET1 =2 . ; BET2=4. 

BEGIN { FORTRAN CODE: CALL ORDER( 3) ; STEP(2) } 

1 DO_IN_PARALLEL 
BEGIN 
TA=TA ; 

HA=HA*BET1 ; 

FOR ALL I : = 1 . .2 AND J: = l . .N 
BEGIN { V 1 A C 1 44 ] : A=( B*C+D)*E} 

ZA(I,J,1) = (U(I,J)*ALP(1 ,3)+Z( 1,3,1 ))*K1 ; 

ZA(I,J,2) = (U(1 , 3>*ALP(2 ,3) + Z(I,J,2) ) * BET 1 ; 

ZA( I , J , 3)=(U( I , J)*ALP(3,3)+Z( I , J ,3) )*BET2 
END; 

FOR_ALL I :=1 . .2 AND J:=1..N {VI B [ 48 ] : A=B} 

ZA( I , J , 4)=Z( I , J , 4) 

END 

END; {DOUBLESTEP3} 

PROCEDURE DOUBLESTEP4C ZA( 2 ,24,4) : COMPLEX ; HA , TA : REAL\Z(2 ,24,4) : COMPLEX ;H,T: REAL] 
CONSTANTS(REAL) 

K0=0. ; K1 =1 . ; BET1 =2 . ; BET2=4.; BET3=8. 

BEGIN {FORTRAN CODE: CALL ORDER(4) ; STEP(2) } 

1 DO_IN_PARALLEL 
BEGIN 

TA=(K0*K0+TA)*K1 ; 

HA=(K0*K0+HA)*BET1 ; 

FOR_ALL I : = 1 . .2 AND J: = 1 . .N 
BEGIN {VI [192] :A=(B*C+D)*E} 

ZA(I,J,1)=(U(I,J)*ALP(1,4)+Z(I,3,1))*K1 ; 

ZA(I,J,2)-(U(I,J)*ALP(2,4)+Z(I,J , 2 > > * BET 1 ; 
ZA(I,J,3)=(U(I,J)*ALP(3,4)+Z(I,J,3) ) *BET2 ; 
ZA(I,J,4)=(U(I,J)*ALP(4,4)+Z(I,J,4))*BET3 
END 
END 

END; { DOU BLESTEP4} 

PROCEDURE STEP[Z(2,24,4) : COMPLEX ;H,T:REAL\ZA(2,24,4) : COMPLEX; HA , TA: REAL] ; 

BEGIN { FORTRAN CODE: ENTRY STEP(BET) } 

1 DO_IN_PARALLEL 
BEGIN 

FOR ALL I :=1 . . 2 AND J:=1..N AND K:=1..Q {VI [48] : A=B> 

Z( I , J ,K)=ZA( I , J ,K) ; 

H=HA ; 

T=TA 

END 

END; {STEP} 


34 



PROCEDURE NEWRAPCSOLUTION FORCEFUN .PARAMS , SHAFT] ; 
CONSTANTS(REAL) 

ABSDUR=1 . E-08 ; 

CONSTANTS (COMPLEX) 

ABSDUI=( 0 , 1 ) *ABSDUR ; K20=20 ; K0=0 ; KP 5=0 . 5 ; K E 1 0= 1 E 1 0 ; 
VARIABLES (BOOLEAN) 

FLAG 

VARIABLES(INTEGER) 

ITTER 

VARIABLES(REAL) 

DT;DT2;H2;IH1 ; IH2 ; RRA 1 ;T1 ; AA1 ; AA2 ; RRA2 ; ANG2 ; ANG( 3 ) ; 
ANG(3) ; CR ;CI ;T2(24) ;T3(24) ; RP 1(24) ; RP2 ( 24 ) ; 

ABSR;ABSU(2 ,24) ;ABSUD0T(2 ,24) ;CC(4,24) ;B<4,4,24,3) ; 
VARIABLES (COMPLEX) 

TA(2) ;TR(2) ;C(2 ,24) ;RO(2,3) ;TA(24);T4(24); 

A(2 ,2 ,2 ,24, 3) ;R(2 , 3 , 3) ;TB1 (24) ; TB2 ( 24 ) ; 

GO ; G 1 ;G2;G3;G4;G5;G6;G7;G8;G9;G10;G1 1 ;G12;G1 3;G14;G1 5; 
CO; Cl ;C2;C3;C4;C5; 

F( 2 , 24 ) ; FC5 ; FO ( 2 ) ;F1 (2); 

RA1 ; RAT DOT ; RBI ; RBI DOT ; RA2 ; RA2D0T ;RB2 ; RB2D0T ; 

BEGIN {NEWRAP} 

1 DO_IN_PARALLEL {FORTRAN CODE: CALL JACOB } 

FOR_ALL I : =1 . .3 

BEGIN 

ANGIC( I )=ANGIC( I )+DELTA ANGLE(I) ; 

DT=T-TIC 
END; {1} 

2 DO_IN_PARALLEL 

BEGIN {FORTRAN CODE: ENTRY (ANGLE) } 

DT2=KP5*DT*DT ; 

TA=ANGIC(2)*DT+ANGIC( 1 ) ; 

ANG(2)=ANGIC(3) *DT+ANGIC(2) ; 

ANG(3)=KO*DT+ANGIC(3) ; 

TR( 1 )=ROIC( 1 ,2)*DT+R0IC( 1,1); 
TR(2)=ROIC(2,2)*DT+ROIC(2,l ) ; 

R0(1 ,2)=R0IC( 1 ,3)*DT+R0IC( 1,2); 

RO(2,2)=ROIC(2, 3)*DT+ROIC(2 ,2) ; 

R0( 1 ,3)=R0IC( 1,3); 

R0(2 ,3)=ROIC(2 ,3) 

END; {2} 

3 DO_IN_PARALLEL 
BEGIN 

ANG( 1 )=ANGIC( 3) *DT2+TA ; 

R0( 1 ,1 )=ROIC( 1 , 3) *DT2+TR( 1 ) ; 

RO (2,1 )=R0IC(2 , 3) *DT2+TR(2) ; 

ANG2=ANG2*ANG2+KO ; 

H2=H # H+K0 
END; {3} 

4 DO_IN_PARALLEL 
BEGIN 

IH1-1/H; IH2-1/H2; RRA1=AMP/H ; 

CR-COSCANG(l)]; CI«SIN[ANG(1 ) ] 

END; {4} 



NEWRAP (CONTINUED) 

5 do_in_parallel 

BEGIN 

REF < 1 )=CPX[CR,CI ] ; 

REF(2)=CPX[0,ANG(2) ] ; 

REF( 3)=CPX[ANG2 ,ANG( 3) ] 

END; {5} 

6 do_in_parallel 

BEGIN 

ITTER=KO; 

REF(2)=REF(2)*REF( I ) ; 

REF(3)=REF(3)*REF(1 ) ; 

FOR ALL J : = 1 . .N 

BEGIN {V6A[481 : A=B*C ;V6B[76] : R=B*C} 

T1=ANG(3)*ALP(1 ,Q) ; 

AA1 =ALP(1 ,Q) *AMP ; 

AA2=ALP( 2 ,Q) *RRA1 ; 

RRA2=AMP2*IH2; 

T2( J)=P205( J ,Q)*IH2 ; 

Cd ,J)-P204(J,Q)*IH2; 

C(2 , J)=P206(J ,Q)*IH2 ; 

RP 1 (J)=P21 5(J)*IH2 ; 

RP2(0)=P21 5(J)*IH1 
END; 

FOR_ALL I :=1 . .2 AND J:=1..N {V6CC48] :A=B} 

U(I,J)-KO; 

END; {6} 

7 FOR_ALL J :=1 . . N {V7 [24] :A=B*C+D+E} 

C(2 , J)=C(2 , J)*ANG(2)+T2( J)+T1 ; 

8 WHILE ITTER<K20 DO 
BEGIN 

1 DO_IN_PARALLEL 
BEGIN 

ITTER=ITTER+1 ; 

ERR=KO 
END; {8.1} 

NEWRAP (CONTINUED) 

8.2 DO_IN_PARALLEL 
BEGIN 

FOR_ALL J2: = l . .2 AND J3:-1..3 {V2AC63 : A=B*C} 

R(J2,1 ,J3)=REF(J3)*RBC(1 ,J2); 

CALC1 [\1 ,23; 

IF M0D[ITTER,4]<>1 THEN FLAG=FALSE ELSE 

DO_IN_PARALLEL 

BEGIN 

FLAG=TRUE ; 

FOR_ALL J ;=1 . . N {FORTRAN CODE: ENTRY ROTOR(A) } 
BEGIN {V2B[ 4803 : A=B} 

A(l, 1 ,1 ,J,1)=KL(1 ,1 ,J, 1,0-1); 

A(1 ,1 ,1 ,J,3)=KL(1 , 1 , J , 3 , Q— 1 ) ; 

A( 1 , 1 ,2 , J , 1 )=KL( 1 ,2 , J , 1 ,Q-1 ) ; 

A( 1 ,1 ,2 , J ,2)=KL( 1 ,2 , J ,2 ,Q-1 ) ; 

A(1 ,1 ,2 , J ,3)=KL( 1 ,2 , J , 3 ,Q-1 ) ; 

A ( 2 , 1 ,1 ,3,1 )=KL(2 , 1 , J , 1 ,Q-1 ) ; 


36 



A(2 , 1 ,1 , J , 2)=KL(2 , 1 , J ,2 ,Q-1 ) ; 

A<2 , 1 ,1 , J , 3)=KL(2 ,1 , J , 3 ,Q-1 ) ; 

A(2 , 1 ,2 , J , 1 )=KL(2 ,2 , J , 1 ,Q-1 ) ; 

A ( 2 , 1 ,2 , J , 3)=KL( 2 ,2 ,0 , 3 ,Q-1 ) ; 

A< 1 ,2, 1 , J , 1 )=KLI(1 , 1 , J, 1 ,Q-1 ) ; 

Ad ,2,1 , J , 3)=KLI( 1 ,1 ,J, 3,Q-1); 

A( 1 ,2 ,2 , J , 1 )=KLI (1 ,2 , J , 1 ,Q-1 ) ; 

A(1 ,2,2 ,0 , 2)=KLI( 1 ,2 ,0 , 2 ,Q-1 ) ; 

Ad ,2,2,J,3)=KLI(1 ,2, J, 3,0-1); 

A(2 ,2 , 1 , J , 1 )=KLI(2 , 1 , J , 1 ,Q-1 > ; 

A(2 ,2 , 1 , J , 2 )=KLI (2 , 1 , J ,2 ,Q-1 ) ; 

A(2 ,2 , 1 , J , 3)=KLI (2 ,1 , J , 3 ,Q-1 ) ; 

A(2 ,2 ,2 ,J , 1 )=KLI (2 , 2 , J , 1 , Q— 1 ) ; 

A(2 ,2 ,2 , J , 3)=KLI<2 ,2 , J ,3 ,Q-1 ) 

END; 

FOR_ALL J : = 1 . . N 
BEGIN { V2C [ 48 ] : A=B-C} 

Ad ,1 ,1 ,J,2)*KL(1 , 1 , J ,2,Q-1 )-C(l , J) ; 

A(2 , 1 ,2 , J , 2 )=KL(2 , 2 , J , 2 ,0—1 >— C( 2 , J ) 

END; 

FOR_ALL J : = 1 . . N 

BEGIN {V2D C 48 ] :A=B-IMAG[C } 

Ad ,2,1 , J ,2)=KLI(1 ,1 , J ,2 ,Q-1 )-IMAG[C( 1 , J) ] ; 
A(2 ,2,2 , J ,2)=KLI(2 ,2 , J ,2 ,0-1 > - IMAGCC( 2 , J ) ] 
END 

END {8.2(E)} 

END; {8.2} 


37 


NENRAP (CONTINUED) 

8.3 FOR J :=1 . . N DO 
BEGIN 

1 DO_IN_PARALLEL 
BEGIN 

IF J<N THEN CALC1 [\J+1 ,33; 

ELSE FOR_ALL Jl:-1..2 AND J3:=1..3 {VI A( E) [61 : A=B*C} 
R(J1 ,3,J3) = REF(J3)*RBC(2,J1 ) ; 

TA( J)=REF(3)*M( J) ; 

T3(J)=ANG(3)*IP( J) ; 

T2( J)=ANG(2)*IP( J) ; 

T4( J)=REF(3)*IT(J) 

END; {8.3.1} 

2 DO_IN_PARALLEL 
BEGIN 

TB1 ( J)=REF( 1 )*T3(J) ; 

TB2( J)=REF(2)*T2( J) 

END; {8.3.2} 

do_in_parallel 

3 BEGIN 

BEGIN { V3A [ 20 ] : A=B*C} 

GO=RO( 1 , 3) *M( J ) ; 

G1=R(1 ,2,3)*M(J); 

G3=R( 1 ,1 , 1 ) *K< 1 ,1,0,1); 

G4=R( 1,2,1 )*K< 1 ,1 ,3,2); 

G5=R(1 ,3,1 )*K(1 ,1 ,J,3) ; 

G6=R(2 ,1,1 )*K( 1 ,2 , J , 1 ) ; 

G7=R(2,2,1)*K(1 ,2 , J ,2) ; 

F( 1 , J)=R(2 ,3,1 )*K( 1 ,2,J ,3) ; 

CO=RO(2,2)*T2(J) ; 

C1=R(2,2,2)*T2( J) ; 

C3=RO(2 , 1 )*T3( J) ; 

C4=R(2 ,2 , 1 )*T3( J) ; 

G8=RO(2,3)*IT(J) ; 

G9=R(2 ,2 , 3)*IT( J ) 

G1 1 =R( 1,1,1 )*K(2 , 1 , J , 1 ) ; 

G12=R(1 ,2,1 )*K<2 , 1 ,J,2); 

G1 3=R( 1 ,3,1 ) *K(2 , 1 , J , 3) ; 

G14=R(2,1 ,1)*K(2,2,J,1); 

G1 5=R< 2,2, 1 )*K(2 ,2 , J ,2) ; 
F(2,J)=R(2,3,1)*K(2,2,J,3); 

END; 

G2=RCG( J , 1 )*TA( J) ; 

C2=RCG( J ,2)*TB2( J) ; 

C5=RCB( J ,2)*TB1 ( J) ; 

G10=RCG( J ,2)*T4( J) 

END; {8.3.3} 


38 


NEWRAP (CONTINUED) 

8.3.4 DO_IN_PARALLEL 
BEGIN 

F ( 1 , J )=-( F( 1 , J )+GO+G1 +G2+G3+G4+G5+G6+G7 ) 

FC5=KI* (CO+C1 +C2+C3+C4+C5) 

END; {8.3.4} 

5 F(2 , J)=-(F(2 , J)+G8+G9+G10+G1 1+G1 2+G1 3+G14+G1 5-FC5 ) / L( J ) ; 

6 IF LOC(J) THEN CALC2 ; 

7 DO_IN_PARALLEL 
BEGIN 

FOR_ALL II : = 1 . .2 AND 12 : = 1 . .2 AND 13 : = 1 . .3 {V7AC12] :A=B} 
R( 1 1 , 12 , 1 3 ) = R ( 1 1 ,12+1 ,13) ; 

FOR ALL I : = 1 . .3 

BEGIN {V7BC26] ;A=REALCB]} 

CC(1 , J )=REAL[ F( 1 ,J>]; 

CC<3,J)-REALCF(2,J>]; 

B(1 ,1 , J , I )=REAL[A( 1 ,1,1 , J , I ) ] ; 

B(3,l , J , I )=REAL[ A (2,1 ,1 , J , I ) ] ; 

B( 1 ,2 , J , I ) = REAL[A( 1 ,2,1 ,J, 1)1; 

B(3,2,J,I) = REAL C A ( 2 , 2 , 1 , J , I ) ] ; 

B( 1 , 3 , J , I )=REAL[A( 1 ,1 ,2 , J , I ) ] ; 

B( 3 , 3 , J , I )=REAL[A( 2 , 1 ,2 , J , I ) ] ; 

B(1 ,4, J , I)=REAL[A( 1 , 2 , 2 , 0 , I ) ] ; 
B(3,4,J,I)=REAL[A(2,2,2,J,I)] 

END; 


FOR_ALl I : = 1 . .3 

BEGIN CV7CC26] : A=IMAGCB3} 

CC ( 2 , J ) = I MAG [ F ( 1 , J ) ] ; 
CCM,J>-IMAGtF(2,.])l; 

8(2,1 , J , I ) = I MAG t A ( I , 1 , I ,J, I) ] 
B( 4 , 1 , J , I ) = IMAGCA(2 ,1,1 , J , I ) J 
B(2 ,2 , J , I ) = I MAG C A < 1 .2,1 ,J,I)] 
8(4 ,2 , J , I ) = I MAG C A ( 2 ,2,1 , J , I ) ] 
B( 2 ,3 , J , I ) = I MAG C A < 1 ,1 ,2,J,I>] 
B(4 , 3 , J , I )=IMAG[A(2 , 1 ,2,J,I>] 
B( 2 , 4 , J , I ) = I MAG [AC 1 ,2,2,J,I)] 
B( 4, 4 , J , I ) = I MAG C A ( 2 ,2 ,2 , J , I ) ] 
END 

END {8.3.7} 

END; {8.3} 

4 DO_IN_PARALLEL 
BEGIN 

CONVERGE=TRUE ; 

SOLVE [U\U , CC , B , N ] ; 

END; {8.4} 

5 FOR_ALL II :=1 . .2 AND J : = 1 . .N 
BEGIN {V5 [ 48 ] : A=CABS [ B ] } 

ABSU(I1 , J )=CABS[U( 1 1 , J ) ] ; 
ABSUDOTdl ,J)=CABS[DU(I1 ,J)] 

END; {8.5} 


40 



NEWRAP (CONTINUED) 

8.6 DO_IN_PARALLEL 
BEGIN 

FOR I : = 1 . .2 AND J: = 1..N DO IF ABSU(I ,J)>ERR THEN ERR=ABSU; 

FOR I :=1 . .2 AND J:=1..N DO IF ABSUDOTd ,J)>KE10 THEN CONVERGE=FALSE 
END; {8.6} 

7 IF CONVERGE THEN ITTER : =K20 
END {8} 

END; {NEWRAP} 

~P 

PROCEDURE CALCIC I ,M: INTEGER] ; 

BEGIN {CALC 1 } 

1 DO_IN_PARALLEL 

BEGIN {VI [10] :A=B+C*D*E} 

RICd , 1 , 1 )=Z(1 , I , 1 )+ALP( 1 ,Q)*U( 1 , 1 > ) *AMP ; 

RICCI , 1 ,2)=Zd , 1 ,2>+ALP(2 ,Q)*U( 1 » I > ) * RRA 1 ; 

RIC(I,2,1)=Z(2,I,1 )+ALP( 1 ,Q)*U(2,I))*P215d); 

RICd ,2 ,2)=Z(2 , 1 ,2)+ALP(2 ,Q) *U(2 , 1 > )*RP1 (I ) ; 

R(1 ,M, 1 )=Z< 1 , I , 1 )+ALP( 1 ,Q) *U( 1 ,1) ) *AMP ; {FORTRAN CODE : CALL RADIUS} 
Rd ,M,2)=Z(1 , I ,2)+ALP(2 ,Q) *U( 1 ,1 ) )*RRA1 ; 

R(1 ,M,3)=Z(1 ,1 ,3)+ALP(3,Q)*U(l ,I))*RRA2; 

R(2,MJ)=Z(2,I,1 )+ALP(1 ,Q)*U(2 , 1 ) )*P21 5(1); 

R(2,M,2)=Z(2,I ,2)+ALP(2 ,Q) *U(2 , I ) ) *RP1 (I ) ; 
R(2,M,3)=Z(2,I,3)+ALP(3,Q)*U(2,I) ) * RP2 ( I ) 

END; 

2 ABSR-CABS(RIC(I,1,1>; 

3 IF ABSR>RMAX THEN RMAX=ABSR 
END; {CALC1 } 

PROCEDURE CALC2 
BEGIN 

1 EXTER[FO\J ,R( 1 ,2 , 1 ) ,R( 1 ,2 ,2) ] ; 

2 DO_IN_PARALLEL 
BEGIN 

F( 1 , J) = F(1 , J)+FO( 1 ) ; 

F(2,J)-F(2,J)+FO(2) {NOTE F0(2) ALWAYS ZERO} 

END; {2} 

3 IF FLAG THEN 
FOR L:=l . .3 DO 
BEGIN 

1 JJ:=J+L-2; 

2 DO_IN_PARALLEL 

BEGIN {V2[8]:A=B+C*(D+E)} 

RA1=Z< 1 , JJ , 1 )+AAl * ( U ( 1 , JJ)+ABSDUR) ; 

RAlDOT=Zd , JJ ,2)+AA2*(U( 1 , JJ)+ABSDUR) ; 

RB1=Z( 1 ,JJ , 1 )+AAl *(U(1 , JJ)+ABSDUI) ; 

RB1D0T=Z(1 , JJ ,2)+AA2*(U( 1 ,JJ)+ABSDUI) ; 

RA2-Z(1 ,JJ,1)+AA1*(U(2,JJ)+ABSDUR); 

RA2D0T=Z( 1 , JJ ,2)+AA2*(U(2 , JJ)+ABSDUR) ; 

RB2=Z( 1 , JJ , 1 )+AAl * ( U < 2 , JJ )+ABSDUI ) ; 

RB2D0T=Z( 1 , JJ ,2)+AA2*(U(2 ,JJ)+ABSDUI) 

END; {3.2} 

3 D0_IN_PARALLEL 
BEGIN 

EXTERC FA1 \J ,RA1 , RA1 DOT] ; 


41 



EXTERC FBI \ J . RBI ,RB1 DOT] ; 

EXTER[FA2\J,RA2,RA2DOT] ; 

EXTER[FB2\J ,RB2 .RB2DOT] 

END; {3.3} 

4 DO_IN_PARALLEL {FORTRAN CODE: ENTRY ROTOR(A)} 

BEGIN {V4C8 ] : A=B+ < C-D ) / E } 

A(1 ,1 ,1 , J , L)=A( 1 ,1 ,1 ,J,L) + (FAl(l)-FO(1))/ ABSDUR ; 
A(2,l ,1 , J ,L)=A(2 , 1 ,1 , J , L) + < FA1 (2)-FO(2) ) /ABSDUR; 
A( 1 ,2,1 ,J,L)=A(1 ,2,1 ,J,L)+(FBl(1)-FO(l))/ ABSDUR ; 
A(2,2,1 ,J , L)=A(2 ,2 , 1 ,J,L) + (FB1 (2)-FO(2) )/ABSDUR; 
A(1 ,1 ,2 , J , L)=A( 1 ,1 ,2,J , L) + ( FA2( 1 )-FO( 1 ) ) /ABSDUR ; 
A ( 2 , 1 ,2,J,L)=A(2,1 ,2,J,L) + (FA2(2)-FO(2) ) /ABSDUR ; 
A(1 ,2,2,J,L)=A(1 ,2,2,J,L)+(FB2(l)-FO(l))/ ABSDUR ; 
A(2,2,2,J,L)=A(2 ) 2,2,J,L)+(FB2(2)-FO(2) ) /ABSDUR 
END {3.4} 

END {3} 

END; {CALC2} 


42 



PROCEDURE EXTERC F F( 2 ) :COMPLEX\RR,RRDOT :COMPLEX; J : INTEGER] ; 
CONSTANTS(REAL) 

<5000=5000. ; 

< 002 =. 002 ; 

< 0 = 0 ; 

< 1 = 1 . ; 

<D05=-1 . D+05; 

<005=. 005; 

<00263=. 00263 
VARIABLES(REAL) 

DEL 

BEGIN 

1 DO_IN PARALLEL 
BEGIN 

F F < 1 ) =0 ; FF(2)=0 
END; {1} 

2 IF ( J = 5 OR 3 = 19) THEN 
BEGIN (2(T) } 

1 JOURNLC FF < 1 ) \RR,RRD0T,<0, <005 ,<00263, TRUE] ; 

2 FF< 1 )=FF( 1 )-<5000*RR 
END { 2 < T ) } 

ELSE IF (3=3 OR 3=12 OR 3=21) THEN 
BEGIN {2(E)(T)J 

1 DEL=CABS[RR] ; 

2 IF DEL><002 THEN 
BEGIN {2( E) (T) . 2 ( T) } 

1 DEL=<l-<002/DEL; 

2 FF( 1 )=<D05*RR*CPX[DEL,DEL] 

END {2(E) (T) . 2(T) } 

END {2} 

END; {EXTER} 



PROCEDURE JOURNLtF , R , ROOT : COMPLEX ;OM , CR , FZ : REAL4 ; CAV : BOOLEAN ] ; 
CONSTANTS(REAL) 

KDM1 2=1 . D-12 ; 

VARIABLES(REAL) 

H;ABSV;D;DD; 

VARIABLES (COMPLEX) 

X;V;EPS;EPSH;CEPS;CEPS3;F;FOA;FOB;Nl (2) ;DN1 (2) ;N2(2) ;N12(2) ; 

DN2 ( 2 ) ;N34(2) ;N4(2) ;N26;NS1 (2) ;DN3(2) ;NS2(2) ;AA(2) ;BB(2) ;CC<2) ;AAS; 
BEGIN {JOURNL} 

1 DO_IN_PARALLEL 
BEGIN 

X=R/CR; V=(RDOT-KI *OM*R) /CR 
END; {1} 

2 ABSV=CABS[V] ; 

3 IF ABSVoO THEN 
BEGIN { 3< T ) } 

1 EPS=ABS[V]*X/V; 

2 CEPS=CONJ [ EPS ] ; 

3 H=EPS*CEPS ; 

4 IF H<=KDM1 2 THEN 

{4( T) } IF NOT CAV THEN (4(T)(T)} F=-PI*FZ*V ELSE 
BEGIN {4(T)(E>} 

1 DO_IN_PARALLEL 
BEGIN 

FOA=FZ*PI*V/K2 ; 

FOB=FZ*V*2 ; 

F=- ( REAL C X ] +EPS ) 

END; {1} 

2 F=F*FOB-FOA 

END { 3 < T ) .4(T)(E)} ELSE 
BEGIN {4(E)} 

1 CEPS3=CEPS*CEPS*CEPS ; 

2 DO IN PARALLEL 
BEGIN 

F=8*FZ*V/CEPS3 ; 

EPSH-EPS/HH ; 

D=SQRT[1-H] 

END; {2} 

3 DO_IN_PARALLEL 
BEGIN 

NT ( 1 )=( 1 -D) *EPSH ; 

NT (2)=( 1+D)*EPSH 
END; {3} 

4 DO_IN_PARALLEL 
BEGIN 

DN1 ( 1 )=N1 ( 1 )-N1 (2) ; 

DN1 (2)=N1 < 2 ) — N 1 ( 1 ) ; 

N2( 1 )=N1 ( 1 )*N1 ( 1 ) ; 

N2(2)=N1 (2)*N1 (2) ; 

N 1 2 ( 1 )=2*N1 ( 1 ) ; 

N12(2)=2*N1 (2) 

END; {4} 

JOURNL (CONTINUED) 


44 


3.4.5 DO_IN_PARALLEL 
BEGIN 

DN2( 1 )=DN1 < 1 )*0N1 ( 1 ) ; 

DN2 ( 2 )=DN1 ( 2 ) * DN 1 ( 2 ) ; 

N34< 1 )=K4*N1 ( 1 )*N2( 1 ) ; 

N34(2)=K4*N1 (2)*N2(2) ; 

N4< 1 )=N2( 1 )*N2( 1 ) ; 

N4(2) = N2(2)*N2(2) ; 

N26( 1 )=KM6*N2( 1 ) ; 

NS1 < 1 )=N2( 1 )+Kl ; 

NS 1 (2)=N2(2)+K1 
END; {5} 

6 DO_IN_PARALLEL 
BEGIN 

DN3< 1 )=DN1 ( 1 )*DN2( 1 ) ; 

DN3(2)=DN1 (2)*DN2(2) ; 

NS2( 1 )=NS1 ( 1 ) * NS 1 ( 1 ) ; 

NS2(2) = NS1 ( 2 ) * NS 1 (2) 

END; {6} 

7 DO_IN_PARALLEL 
BEGIN 

AA( 1 )=(N4( 1 )+N2( 1 ) )/DN3( 1 ) ; 

AA(2) = (N4(2)+N2(2) ) / DN3 ( 2 ) ; 

BB( 1 )=(N34( 1 )+Nl 2( 1 ) ) /DN3(1 ) ; 
BB(2)=(N34(2)+N12(2))/DN3(2) ; 

CC(1 ) = < N26+MK1 )/DN3(l ) 

END; {7} 

8 DO_IN_PARALLEL 
BEGIN 

BBC 1 )=BB( 1 >-K3*AA( 1 ) /DN1 ( 1 ) ; 
BB(2)=BB(2)-K3*AA(2)/DN1 (2) ; 

CC( 1 )=CC( 1 )+K3*AA( 1 ) / DN2 ( 1 ) 

END; {3(T).4(E) .8} 

9 CC( 1 )=CC( 1 )+K3*BB( 1 ) / DN 1(1); 

10 IF NOT CAV THEN {1 0< T) F=-PI*CC( 1 )*F ELSE 
BEGIN {3(T). 4(E). 10(E)} 

1 DO_IN_PARALLEL 
BEGIN 

DD=ATAN[-D,REAL[X]] ; 

AA( 1 )=AA( 1 ) * N 1 ( 1 ) / NS2 ( 1 ) ; 
AA(2)=AA(2)*N1 (2)/NS2(2) ; 

BBC 1 )=BB( 1 ) / NS 1 ( 1 ) ; 

BB(2)=BB(2) /NS1 (2) 

END; {10(E). 1} 

2 AAS=AA( 1 )+AA(2)-BB(2) ; 

3 F=F* (CC( 1 ) *DD+BB( 1 )-AAS) 

END { 3 ( T ) .4(E) . 1 0 E } 

END { 3 ( T ) .4(E)} 

END { 3 ( T ) } 

END; {JOURNL} 


PROCEDURE SOLVE[U(2 ,24) :COMPLEX\U(2 ,24) rCOMPLEX; CC(4 ,24) : REAL ; 

6(4,4,24,3) : REAL ; N( 24) : INTEGER ] ; 

CONSTANTS(REAL) 

MKU-1 . 

VARIABLES(REAL) 

MDU( 4 ,24) ; MBD1 (4,4) 

BEGIN 

1 FOR J :=1 . .N DO 
BEGIN 

IF J<N THEN 
BEGIN {1(T)} 

1 DO IN PARALLEL 
FOR_ALL II : = 1 . .4 
BEGIN {VI [9] :A=B/C} 

B(1 ,11 , J , 2 )=B( I ,11 , J , 2 ) / B ( 1 ,1 ,J,2); 

B(1 ,I1,J,3)=B(1 ,11 , J , 3) /B( 1 ,1 , J ,2) ; 

MDU( 1 , J)=CC( 1 , J)/B( 1 ,1 , J ,2) 

END; {1 (T) . 1 > 

2 DO_IN_PARALLEL {FORTRAN CODE: CALL BC} 

FOR_ALL K1 :=1 . .4 AND K2:=2..4 AND II : =1 . . 4 
BEGIN {V2C63] : A=B-C*D} 

B(K2 , II ,J,2)=B(K2,I1 , J , 2 ) — B ( 1 ,11 , 0 ,2)*B(K2 ,1 , J ,2) ; 

B ( K2 ,11 , J , 3)=B(K2 , 1 1 , J , 3)-B( 1 ,11 , J , 3) *B(K2 , 1 , J ,2) ; 

B(K1 ,11 ,J + 1 , 1 )=B(K1 ,11 ,3+1 ,1 )-B(l ,11 ,J,2)*B(K1 , 1 ,J+1 ,1 ) ; 
B(K1 ,11 , J + l ,2)=B(K1 ,11 , J + l , 2 ) — B( 1 ,11 , J , 3) *B(K1 ,1 , J+l ,1); 
CC(K2 , J )=CC(K2 , J )-MDU( 1 , J ) * B ( K2 , 1 , J , 2) ; 

CC(K1 , J + l )=CC(K1 , J+l )-MDU( 1 ,J)*B(K1 ,1 ,J + 1 ,1) 

END; {1 ( T) . 2} 

3 DO_IN_PARALLEL 

FOR_ALL 12: =2. .4 AND II : = 1 . .4 
BEGIN {V3[8]:A=B/C} 

B(2,I2,J,2)=B(2,I2,J,2)/B(2,2,J,2); 

B ( 2 , 1 1 , J , 3)=B( 2 , 1 1 ,0,3)/B(2,2,J,2); 

MDU(2 , J)=CC(2 , J) /B(2 ,2 , J ,2) 

END; {1 (T) . 3} 

4 DO_IN_PARALLEL 

FOR ALL K1 : = 1 . .4 AND K3: = 3..4 AND I2:=2..4 AND 1 1 : = 1 . . 4 
BEGIN {V4C481 : A=B-C*D} 

B(K3,I2,J,2)=B(K3,I2,J,2)-B(2,I2,J,2)*B(K3,2,J,2); 

B(K3 , 1 1 , J ,3)=B(K3 , 1 1 ,J,3)-B(2,I1 , J , 3) *B(K3 ,2 , J ,2) ; 

B(K1 ,12,0+1 ,1)=B(K1 ,12, J+l ,1)-B(2, 12, J,2)*B(K1 ,2,0+1 ,1); 
B(K1 ,11 ,J + 1 ,2) = B(K1 ,11 ,0 + 1 ,2)-B(2,Il ,0 , 3) *B(K1 ,2,0 + 1 ,1 ) ; 
CC(K3, J)=CC(K3 , J)-MDU(2 , J)*B(K3 ,2 , J ,2) ; 

CC(K1 , J+l )=CC(K1 ,0+1 )-MDU(2 ,0)*B(K1 ,2, J+l ,1) 

END; {1 (T) . 4} 

5 DO_IN_PARALLEL 

FOR_ALL I3:=3. .4 AND 1 1 : = 1 . .4 
BEGIN {V5 [ 7 ] : A=B/C} 

B(3,I3,J,2)=B(3,I3,J,2)/B(3,3,J,2); 

B< 3 , 1 1 ,0,3) =B( 3,11 ,J,3)/B(3,3,J,2); 

MDU(3, J)=CC(3, J)/B(3,3,J ,2) 

END; {1 (T) . 5} 


46 



SOLVE (CONTINUED) 

IT. 6 DO_IN_PARALLEL 

FOR K1 : =1 . . 4 AND I3:=3..4 AND Il:=1..4 
BEGIN { V6 C 17]: A=B-C*D} 

B(4,I3,J,2)=B(4,I3,J,2)-B(3,I3,J > 2)*B(4 > 3 > J,2); 

B(4,I1 ,J ,3)=B(4, II ,J , 3 ) — B< 3,11 ,J ,3)*B(4,3 1 J ,2) ; 

B ( K 1 , 13 , J+l , 1 )=B(K1 , 1 3 , J + l ,1)-B(3,I2,J,2)*B(K1 ,3,J+1 ,1); 
B(K1 ,11 . J+l ,2)=B(K1 , 1 1 , J+l , 2)-B( 3 , 1 1 , J , 3) *B(K1 ,3, J+l ,1); 
CC(4 , J )=CC( 4 , J )-MDU( 3 ,J)*B(4,3,J,2); 

CC(K1 , J+l )=CC(K1 , J+l )-MDU(3, J)*B(K1 ,3, J + l ,1) 

END; {1 (T) .6} 

7 DO_IN_PARALLEL 
FOR_ALL 1 1 : = 1 . . 4 
BEGIN {V7 [63 :A=B/D} 

B(4,4,J,2)=B(4,4,J,2)/B(4,4,J,2); 

B(4 ,1 1 , J ,3)=B(4, 1 1 , J , 3) /B(4,4, J ,2) ; 

MDU(4 , J )=CC( 4 ,J)/B(4,4,J,2) 

END; {1 (T) . 7} 

8 do_in_parallel 

FOR_ALL K1 : = 1 . .4 AND 1 1 : = 1 . .4 
BEGIN {V8 [ 24 ] : A=B-C*D} 

B(K1 ,4, J+l , 1 )=B(K1 ,4,J + 1 ,1)-B(4,4,J,2)*B(K1 ,4, J + l ,1); 
B(K1 ,11 ,J+1 ,2) = B(K1 ,11 , J + l ,2)-B(4,Il , J , 3) *B(K1 ,4, J+l ,1); 
CC(K1 , J+l )=CC(K1 , J+l ) — MDLK 4,J)*B(K1 ,4, J+l ,1) 

END {1 (T) .8} 

END {1 (T) } ELSE 
BEGIN {1(E)} 

1 DO_IN_PARALLEL 
FOR_ALL II :=1 . .4 
BEGIN {VI [93 : A=B/C} 

B( 1 ,11 ,J,2)=B(1 ,11 , J ,2)/B( 1 ,1 ,J,2); 

B(1 ,11 , J,3)=B(1 ,11 , J , 3 ) / B( 1 ,1 ,J,2); 

MDU( 1 , J)=CC( 1 ,J)/B(1 ,1 ,J,2) 

END; {1(E). 1} 

2 DO_IN_PARALLEL 

FOR K2 :=2 . .4 AND 1 1 : = 1 . .4 
BEGIN { V2 [18] :A=B-C*D} 

B(K2 , 1 1 , J ,2)=B(K2 , II , J , 2 ) — B ( 1 ,11 , J ,2)*B(K2 , 1 , J ,2) ; 

B(K2 ,11 , J ,3)=B(K2 , II , J , 3 ) -B( 1 ,11 , J , 3)*B(K2 , 1 , J ,2) ; 

CC(K2 , J)=CC(K2 , J)-MDU( 1 ,J)*B(K2,1 ,J,2) 

END; {1(E). 2} 

3 do_in_parallel 

FOR_ALL 12=2. .4 AND II :=1 . .4 
BEGIN {V3C7]:A=B/C} 

B<2 , 12 , J ,2)=B(2 , 12 , J ,2)/B(2 ,2 , J ,2) ; 

B( 2 , 1 1 , J , 3)=B(2 , 1 1 , J ,3)/B(2 ,2 , J ,2) ; 

MDU(2 , J)=CC(2 ,J)/B(2,2,J,2) 

END; {1(E). 3} 

4 DO_IN_PARALLEL 

FOR_ALL K3=3 . . 4 AND 12=2.. 4 AND 1 1 : = 1 . . 4 
BEGIN {V4[ 1 6] : A=B-C*D} 

B(K3,I2,J,2)=B(K3,I2,J,2)-B(2,I2,J,2)*B(K3,2,J,2); 
B(K3,I1 , J , 3)=B(K3 , 1 1 , J , 3)-B(2 , 1 1 , J , 3)*B(K3 ,2 , J , 2) ; 

CC(K3 , J )=CC( K3 , J )-MDU( 2 ,J)*B(K3,2,J,2) 

END; {1(E). 4} 


47 



SOLVE (CONTINUED) 

IE. 5 DO_IN_PARALLEL 

FOR_ALL 13=3. .4 AND II : =1 . .4 
BEGIN {V5[7] :A=B/C} 

B(3,I3,J,2)=B(3,I3,J,2)/B(3,3,J,2); 

B(3 , 1 1 ,J,3)=B(3,I1 ,J,3)/B(3,3,J,2); 

MDU( 3, J)=CC( 3,J)/B(3,3,J,2) 

END; {1(E). 5} 

6 DO_IN_PARALLEL 

FOR_ALL 13=3. .4 AND II :=1 . .4 
BEGIN {V6 [ 7 ] :A=B-C*D} 

B(4,I3,J,2)-B(4,I3,J,2)-B(3,I3,J,2)*B(4,3,J,2); 

B(4 , 1 1 , J , 3) = B(4, 1 1 , J , 3)-B( 3 , 1 1 , 3 , 3) *B(4 , 3 , J ,2) ; 

CC(4, J)=CC(4, J )-MDU( 3 , J ) *B( 4 , 3 , J ,2) 

END; {1(E). 6} 

7 DO_IN_PARALLEL 
FOR_ALL II :=1 . .4 
BEGIN { V7 C 6 ] :A=B/C} 

B(4,4,J,2)=8(4,4,J,2)/B(4,4,J,2); 

B(4,I1 , J ,3)=B(4, II ,J,3)/B(4,4,J ,2) ; 

MDU(4, J)=CC(4, J)/B(4,4, J ,2) 

END {1(E). 7} 

END {1(E)} 

END; {1 { {FOR J : =1 . .N} 

2 FOR J :=N . . 1 DO 
BEGIN 

IF J<N THEN 
BEGIN { 2 ( T ) } 

1 D0_IN_PARALLEL 

1 FOR_ALL K1 : = 1 . .4 AND II : = 1 . .4 
BEGIN {VI t 1 6] : A=B*C> 

MBDKK1 , 1 1 )=MDU<K1 ,3+1 )*B( 1 1 ,K1 ,J,3); 

END; {2 ( T ) . 1 } 

2 DO_IN_PARALLEL 
BEGIN 

MDU(4, J)=MDU(4, J)-MBD1 (4,1 ) — MBD 1 (4,2)-MBDl (4,3)-MBDl (4,4) ; 
MDU(3 , J )=MDU( 3 , J ) -MBD 1 (3,1 ) -MBD 1 ( 3 , 2 ) — MBD 1 ( 3, 3)-MBDl (3,4) ; 
MDU(2 , J)=MDU(2 , J)-MBD1 (2,1 ) — MBD 1 (2 , 2)-MBDl (2,3) —MBD 1 (2,4); 
MDU( 1 , J)=MDU( 1 , J ) -MBD 1 (1,1 ) —MBD 1 ( 1 , 2 ) -MBD 1 ( 1 , 3 ) -MBD 1 (1 ,4) ; 
END; { 2 < T ) .2} 

3 DO_IN_PARALLEL 
BEGIN 

MDU(3,J)=MDU(3,J)-B(3,4,J ,2)*MDU(4, J) ; 

MDU(2 , J )=MDU( 2 , J)-B(2 ,4 , J ,2 ) *MDU(4 , J ) ; 

MDU( 1 , J)=MDU( 1 , J)-B( 1 , 4 , J ,2 ) *MDU( 4 , J ) 

END; {2 ( T ) .3} 


48 



SOLVE (CONTINUED) 

2T . 4 DO_IN_PARALLEL 
BEGIN 

MDU(2 , J)=MDU(2 , J)-B(2 , 3 , J ,2) *MDU( 3, J ) ; 
MDU( 1 , J)=MDU( 1 , J)-B( 1 , 3 , J , 2 ) *MDU( 3 , J ) 
END; {2 ( T) . 4} 

5 MDU( 1 , J)=MDU( 1 , J)-B( 1 ,2 , J ,2)*MDU(2 , J) ; 

6 DO_IN_PARALLEL 
BEGIN 

U(1 ,J)=U(1 ,J)-CPX[MDU(1 , J) ,MDU(2 , J) ] ; 
U(2 , J)=U(2 , J)-CPX[MDU( 3 , J) ,MDU(4, J) ] 
END { 2 ( T ) .6} 

END { 2 ( T ) } ELSE 
BEGIN {2 ( E ) { }J :=N} 

1 do_in_parallel 

BEGIN 

MDU( 3 , J )=MDU( 3 , J )-B( 3 , 4 , J , 2 ) *MDU( 4 , J) ; 
MDU(2 , J)=MDU(2 , J)-B<2 ,4, J ,2)*MDU<4, J) ; 
MDU( 1 , J )=MDU( 1 , J )-B( 1 ,4, J ,2)*MDU(4, J) 
END; {2(E). 1} 

2 DO IN PARALLEL 
BEGIN 

MDU( 2 , J ) =MDU (2,J)-B(2,3,J ,2) *MDU( 3 ,3) ; 
MDU( 1 ,J)=MDU( 1 , J)-B( 1 , 3 , J ,2) *MDU( 3 , J ) 
END; {2(E). 2} 

3 MDU( 1 , J)=MDU(1 , J)-B( 1 ,2 , J ,2)*MDU(2 , J) ; 

4 DO_IN_PARALLEL 
BEGIN 

U(1 ,J)=U<1 ,J)-CPX[MDU(1 ,J),MDU(2,J)]; 
U(2 , J)=U(2, J)-CPX[MDU(3, J) ,MDU(4, J) ] 
END {2(E). 4} 

END {2}{E} 

END {2} }J :=N. . 1 } 

END; {SOLVE} 



PROCEDURE DOMOVIE[CURRENT\RESULTS] ; 

{THE TRANSFER OF DATA FROM CALCULATE TO DOMOVIE NEEDS MORE DEFINITION. 
ALSO , THE READ(5,FRAM) STATEMENT MUST BE ADDRESSED) 

CONSTANTS(REAL) 

DVARS(7)=7. ,2.5,0. ,0. , 1 . , 1 . ,2 . ; 

DCL<10) — 1 . ,-.6, -.55, -.45, -.4, -.4, .45, .55, .6,1 . 

VARIABLES! BOOLEAN) 

CG 

VARIABLES (COMPLEX) 

R( 2,2,24), REF( 2,2) ,FO,RO, REFO,RCG( 24) 

VARIABLES(REAL) 

X(24),Y(24),S(24) ,XCG(24) ,YCG(24) ,T(2) , TO ; 

XVARS(7) ,YVARS(7) ,CL( 10) ; LABLE ( 8 ) 

VARIABLES! INTEGER) 

ITTER , I VARS ( 3 ) 

BEGIN 

1 IF CURRENT THEN 
BEGIN { 1 < T ) } 

1 DO_IN_PARALLEL 
BEGIN 

TRANSFER [T( 1 ) ,REF(J3 , 1 ) ,R(J3, 1 ,J)\T0,REF0(J3),RIC(J,1 , J 3 ) ] ; 
TRANSFER [T( 2) ,REF( J3,2) ,R( J3,2 , J)\T0,REF0! J3) ,RIC( J , 1 , J3) ] ; 
CURRENT=FALSE; 

GM0VIE(200) ; 

FOR I:-l . .7 DO VECTOR 
BEGIN 

XVARS! I )=DVAR( I ) ; 

YVARS(I)=DVAR(I); 

IVAR! 1 )=3; 

IVAR(2)=2; 

IVAR(3)=0 

END 

END; 

2 DO_IN_PARALLEL 
BEGIN 

TITLE! 1 ,32,29, LABEL) ; 

XVARS(3)=K0; 

XVARS! 5)=RMAX ; 

YVARS(3)=K90; 

YVARS(5)=RMAX; 

TO=TMIN; 

FOR I :=1 . .10 DO VECTOR 
BEGIN 

CL(I)=DCL(I)*RMAX; 

SS( J)=RMAX*S( J) 

END 

END; 

3 WHILE TO<TMAX DO 
BEGIN 

1 INTENS!K40); {FORTRAN CODE :CALL INTENS) 

2 XAXIS(K5,K5, XVARS); 

3 YAXIS(K5,K5,YVARS); 

4 FOR I ;=1 . .5 BY 2 DO 

GPLOT(CL(I) , CL! I ) ,IVAR) ; 

5 INTENS(K20); 

6 FOR ITTER : =1 . . NUM DO 


50 



BEGIN 

1 WHILE T0>T(2) DO_IN_PARALLEL 
BEGIN 

T( 1 )=T<2) ; 

FOR ALL J3-1 . .2 AND J:«1 . .N 
BEGIN {V 1 A [ 50 3 :A=B} 

REF ( J 3 , 1 )=REF( J3 , 2 ) ; 

R(J3, 1 , J)=R(J3,2 , J) 

END; 

FOR_ALL J3-1..2 AND J:=1..N {VI BC48] : TRANSFER} 

TRANSFER[T<2) ,REF(J3,2) ,R(J3,2,J)\TO,REFO(J3) , RIC< J , 1 , J3) ] 

END; 

2 DO_IN_PARALLEL 
BEGIN 

REFO=FXX[REF,T,TO] ; 

FOR ALL J :=1 . .N {V2C24] : A=FXX} 

R0( J)=FXX[R( 1 ,1 ,J,T,TO)-CPX(SS(J) ,SS(J>] 

END; 

3 DO_IN_PARALLEL 
BEGIN 

FOR_ALL J:=1..N {V3AC24] : R=REAL[B]} 

X(J)=REAL[RO(J) ] ; 

FOR_ALL J : = 1 . . N {V3BC24] : R=IMAG[8]} 

Y( J)=IMAG[RO( J) ] ; 

FOR_ALL J : = 1 . . N {V3CC 24 ] : R=REAL[B+C*D]} 

XCG(J)=REAL[RO( J)+RCG( J)*REFO] ; 

FOR_ALL J : = 1 . . N {V3DC243 : R=IMAGCB+C*D]} 

YCG( J ) = IMAGE ROC J ) +RCG< J)*REFO] 

IVAR(2)=N; 

IVAR(3)=0 

END; 

4 DO_IN_PARALLEL 
BEGIN 

GPLOT[X,Y,IVAR] ; {FORTRAN CODE : CALL GPLOT} 

TO=TO+H ; 

I VAR ( 3 ) = 1 
END; 

5 IF CG THEN GPLOT [ XCG , YCG , I VAR] 

6 DISPLAY(Kl); {CALL DISPLA} 

7 GMOVIE(NUM) {CALL GMOVIE} 

END 

END 

END 

END; {DOMOVIE} 


51 



APPENDIX C: CONDENSED DATA-FLOW STATEMENT 


PROGRAM SHAFT 
BEGIN 
1 : READ 

2[4] :R=B: INITIALIZE : 20READ; 

3: RESET; 

4 : NEWRAP ; 

5: IF CONVERGED THEN 
BEGIN 

1 [2] :20L=B; 

2: WHILE NOT STOP DO 

1 [4] :20READ: CALCULATE : DOMOVIE 
END 

END; 

PROCEDURE INITIALIZE 
BEGIN 

1 [206] :R=B*C; 

2C172] : 1480R=B*C:240R=B+C*D*E*(F-G) ; 

3[1 99] :230R=B+C+D:720R=B+C(D-E) :960R=B/ (C*(D-E) > : 80R=B/ (C*D) ; 

4[216] : 12O0R=B+C:960R=B*C; 

5 C 72 ] : 480R=B+C:240R=B+C+D ; 

6 C 48 ] : R=B*C ; 

7 C 24 ] : R=B-C; 

8C96] : R=B/C ; 

9C289] : 12O0R=B:240R=-B-C*D:240R=B+C*D:240R=B+C+D*( E+F+G) : 

: 24@R=B+C : 240R=B+C+D* E : 240R=-B-C : 240R=-B-C+D* E 
END; {INITIALIZE} 

PROCEDURE RESET 
BEGIN 

1 [1 52] : I=B:270R=B:480A=B: 760R=B*C; 

2C218] : 1 7O0R=B/C : 48@A=B/ C ; 

3C1020] :720R=B*C:960A=B*C: 8520(R=-B*C,A=IMAG[R] ) ; 

END; {RESET} 

PROCEDURE CALCULATE 
BEGIN 

1 [1 ] : IF CURRENT THEN WAIT ELSE 
BEGIN {IE} 

WHILE T<=TMAX DO 
BEGIN 

1 : IF CONVERGED AND Q<4 THEN SI ( E) [49] : I=B+C: 480A=B/C; 

2[2] :R=B+C: IF 0=3 THEN F0RESTEP3 ELSE F0RESTEP4; 

3 [ 2 ] : NEWRAP : I F 0=3 THEN 1 C3] : BACKSTEP3 : HALFSTEP3 : D0UBLESTEP3 
ELSE 1 [3] :BACKSTEP4:HALFSTEP4:D0UBLESTEP4; 

4: IF NOT CONVERGED OR ERR>E04 THEN STEP{8ACK} ELSE 
IF ERR<E06 THEN STEP§DOUBLEe ELSE STEP {HALF } ; 

END; {1 (E)} 

2 [ 1 5] : L=B : 30R=B : 20A=B ; 

3: WRITE 

END; {CALCULATE} 


52 



PROCEDURE BACKSTEP3 
BEGIN 

1 [1 943 : R=B-C: R=B*C:480A=B-C+D:480A=(B-C-D)*E: 960A=B*C 
END; 

PROCEDURE BACKSTEP4 
BEGIN 

1 [242 ] : R=B-C : R=B*C : 480A=( 8-C*D) * E : 960A=( B-C-D+E) *F : 960A=B*C 
END; 

PROCEDURE FORESTEP3 
BEGIN 

1 [963 : A=B+C+D 
END; 

PROCEDURE FORESTEP4 
BEGIN 

1 [ 1 92 3 : 480A=B*C : 1 440A=B+C+D+E 
END; 

PROCEDURE HALFSTEP3 
BEGIN 

1 [194]:20R=B*C:480A=B*C;1440A=(B*C+D)/E 
END; 

PROCEDURE HALFSTEP4 
BEGIN 

1 [ 1 94] :20R=B*C: 1 920A=(B*C+D)/E 
END; 

PROCEDURE DOUBLESTEP3 
BEGIN 

3 [1 943 :20R=B*C:480A=B*C: 1440A=(B*C+D)*E 
END; 

PROCEDURE DOUBLESTEP4 
BEGIN 

1 [1 94] : 20R=B*C: 1 920A=(B*C+D)*E 
END; 

PROCEDURE STEP 
BEGIN {STEP} 

3 [ 1 94] :20R=B: 1 920A=B 
END {STEP} 



PROCEDURE NEWRAP #R=28991 L+28991 S+5380T+28A+1 040M+23D+2C0S+960CABS+960IMAG 

+20#R[ SOLVE 3 + 500#R[ CALC 1 ]+480#RCCALC2 3 
#A=32891 L+32890S+1 4935A+1 5079M+480D+965CPX+20#A[SOLVE 3 
+500#A[CALC1 3+480#A[CALC2 ] 


BEGIN {NEWRAP} 

1 [4] : 3@R=B+C: R=B-C; 

2[ 1 0] : 20A=B : 5@A=B*C+D : 2@R=B*C+D : R=B*C*D ; 

3 [5] :2@A=B*C+D:2@R=B*C+D; 

4 [ 5 ] : 3@R=B/C : R=COS [ B ] : R=S I N C B ] ; 

5 [ 3 ] :#A=CPX[B,C3 ; 

6[1 763 : 2@A=CPX[B,C] :76@R=B*C 
: 48@A=B*C:48@A=B: I=B; 

7 [ 2 4 ] : A=B*C+D+E; 

8[ 1 ] : WHILE ITTER<K20 DO 


BEGIN 

1 [2] : I=B+C: I=B ; 

2C8] : 6@A=B*C : CALC1 : 

IF MODI ITTER , 4] < > 1 THEN 
2(T) : L=B ELSE 
2(E) C 577 ] : L=B: 480@A=B: 
:48@A=B-C:48@A=B-CPX[0,C3 ; 
3 C 1 3 : FOR J: = l . .N DO 


#R=4*( L+A+S) 

#R=3L+3S+2A+2M 
#A=5( L+A+M+S) 

#R=2( L+A+M+S) 

#A=2( L+A+M+S) 

#R=5L+2COS+3D+5S 
#A=3( L+CPX+S) 

#R=77L+76M+77S 
#A=98L+2CPX+48M+96S 
#A=24( L+2A+M+S) 

#R=20( (5+11 N)T+(53+58N)(L+S)+A 
+ (2N)M+D+#R[ SOLVE 3+48CABS 
+( 1 +N)#R[CALC1 ]+( N)#R[CALC2 ] 
+(2N) IMAG 

#A=20( ( 582+44N) ( L+S)+( 96+27N)A 
+(6+31 N)M+( N)D+48CPX+#A[ SOLVE] 
+( 1 +N)#A[CALC1 ]+(N)#ACCALC2] 
#R=2 L+A+2S 

#R=#RCCALC1 I+D+T+3L+3S 
#A=#A[CALC1 ]+582(L+S)+96A+6M 
+48CPX 


#R=N(3T+54L+54S+2M+2IMAG 
+#R[CALC1 ]+#R[CALC2 ] ) 
#A=N( 44L+44S+27A+31 M+D 
+#A [CALC1 ] +#A [CALC2 ] ) 


BEGIN 

1 [5] : 2@R=B*C: 2@A=B*C 

: IF J<N THEN CALC1 
ELSE 1 ( E) [63 : A=B*C; 

2 C 2 ] :A=B*C; 

3 [ 24 3 : A=B*C ; 

4 [ 2 ] : A=-( B+C+D+E+F+G+H+I ) 
:A=B*(C+D+E+F+G+H) ; 

5[ 1 ] :A=-( B+C+D+E+F+G+H+I +J-K) /M 
6[1 ] : IF LOCO) THEN CALC2 ; 

7 C 64 3 : 1 2 @A= B : 2 60R= REAL C B ] 

: 260R=IMAGC B] 


#R=T+#R[CALC1 ]+2( L+M*S) 
#A=3( L+M+S)+#ACCALC1 3 


#A=2( L+M+S) 
#A=24( L+M+S) 
#A=2( L+l 3A+M+S) 


#A=L+A+D+S 


#R=T+#R[CALC2] 
#A=#A[CALC2] 
#R=52( L+IMAG+S) 
#A=1 2 ( L+S ) 


END; 

4 [ 2 3 : L=B:SOLVE #R=L+S+#RCS0LVE3 

#A=#A[S0LVE3 

5 [ 48 3 : R=CABS[B3 ; #R=48( L+CABS+S) 

6 [ 2 3 : FOR I: = 1..2 AND J:=1..N DO #R=4N(2T+L+S) 

IF ABSU( I , J ) >ERR THEN R=B 
: FOR I :=1 . .2 AND J:=l . .N DO 
IF ABSUDOT ( I , J ) > K E 1 0 THEN L=B; 

7[ 1 3 : IF CONVERGE THEN I=B #R=T+L+S 

END {S8} 

END {NEWRAP} 


54 


PROCEDURE CALC1 
BEGIN {CALC1 > 

1 [10]:A=B+C*D*E; 

2[1 ] :R=CABS[B] ; 

3[ 1 ] : IF ABSR>RMAX THEN R 
END; {CALC1 } 

PROCEDURE CALC2 
BEGIN {CALC2} 

1 [1 ] : EXTER; 

2 E 2 ] :A=B+C; 

3t 1 ] : IF FLAG THEN FOR L: 
BEGIN 

1 [1 ] : I=B+C-D; 

2 C 8 ] :A=B+C*(D+E) ; 
3C4] : EXTER; 

4[8] :A=B+(C-D)/E 
END 

END; {CALC1 } 


#R=T+2L+2S+CABS 
#A= 1 0L+20M+ 1 OA+1 OS 

#A= 1 0L+20M+ 1 OA+ 1 OS 
#R=L+CABS+S 
B #R=T+L+S 


#R=4T+3L+3S+6A+1 3#R[ EXTER] 
#A=50L+50S+98A+24M+24D+ 1 3#A[ EXTER] 

#R=#R[EXTER] 

#A=#A[EXTER] 

#A=2L+2A+2S 

1 . . 3 DO #R=T+3(T+L+S+2A+4#R[ EXTER] ) 

#A=3( 1 6L+1 6S+32A+8M+8D+4#A[EXTER] ) 
#R=L+2A+S 
#A=8( L+2A+M+S) 

#R=4#R[ EXTER] 

#A=4#A[EXTER] 

#A=8( L+2A+D+S) 


55 



PROCEDURE EXTER #R=< 1 /24) ( 49T+6L+6S+3A + 3D + 3CABS+2#Rl JOURNL] ) 

BEGIN {EXTER} #A=( 1 /24) ( 5L+5S+2A+8M+3CPX+2#A[ JOURNL] ) 


1 [2] :A=B; 

2C1 ]:IF ( J=5 OR 0=19) THEN 
BEGIN {2 ( T ) } 

HI]: JOURNL; 

2 C 1 ] : A=B-C*D 
END {2( T) } ELSE 
IF ( J=3 OR J=1 2 OR 0=21) THEN 
BEGIN (2( E) ( T) } 

1 [ 1 3 :R=CABS[RR] ; 

2C 1 ] : IF DEL>K002 THEN 
BEGIN {2 ( T) } 

1 [1 ] :R=B-C/D; 

2 C 1 ]:A=B*C*CPX[D,E] 
END { 2 ( T ) } 

END {2(E)(T)} 

END; {EXTER} 


#A=L+S 

#R=T+( 2 /24)#R[ JOURNL] 
#A=(2/24) ( L+A+M+S+#A[ JOURNL] ) 


#R=< 22/24 )T+( 3/24) ( T+2L+2S+A+D+CABS) 
#A= ( 3/24) ( L+2M+CPX+S) 

#R=L+CABS+S 

#R=T+L+A+D+S 

#A=L+2M+CPX+S 


56 



PROCEDURE JOURNL 
BEGIN {JOURNL} 

1 :A=( B— C*D*E> /F ; 

2 : R=CABS[V] ; 

3: IF ABSVoO THEN 
BEGIN { 3 ( T ) } 9 
1 :A=ABS[B]*C/D; 

2 :A=C0NJ [B] ; 
3:R=B*C; 

4: IF H<=KDM1 2 ... 
BEGIN {4(E)} 

1 : A=B*C*D; 

2 : R=SQRT( 1 -B) ; 
3:A=( 1-B)*C; 

4 [ 4 ] : A=B*C; 

5 C 5 ] : A=B*C ; 

6 C 4 ] :A=B*C; 

7 [ 5 3 :A=(B+C)/D 
8 C 2 ] :A=B-C*D/E 
9:A=B+C*D/E; 
10: IF NOT CAV 
BEGIN { 1 0 ( E 
1 : R=ATAN[ 
2 :A=B+C-D 
3:A=B*(C* 
END { 0(E)} 
END {4(E)} 

END { 3 ( T ) } 


#R=3T+4X+5L+4S+A+M+CABS+SQRT+ATAN 
#A=28X+1 3L+1 3S+9A+1 3M+5D+ABS+CONJ 
#A=X+L+A+2M+D+S 
#R=X+L+CABS+S 

#R=3T+3X+4L+3S+A+M+SQRT+ATAN 
#A=27X+1 2L+1 2S+8A+1 1 M+4D+ABS+CONJ 
#A=X+L+M+D+ABS+S 
#A=X+L+CONJ+S 
#R=X+L+M+S 

ELSE #R=2T+2X+3L+2S+A+SQRT+ATAN 

#A=25X+10L+1 0S+8A+1 0M+3D 
#A=X+L+2M+S 
#R=X+L+A+SQRT+S 
#A=X+L+A+M+S 
#A=4X+L+M+S 
#A=5X+L+M+S 
#A=4X+L+M+S 

; #A=5X+L+A+D+S 

; #A=2X+L+A+M+D+S 

#A=X+L+A+M+D+S 

THEN ... ELSE #R=T+X+2L+S+ATAN 
)} #A=2X+2L+4A+2M+2S 

-B , REAL [C3 3 ; #R=X+2L+ATAN+S 

; #A=X+L+2A+S 

D+E-F) #A=X+L+2A+2M+S 


END; {JOURNL} 


57 



PROCEDURE SOLVE 
BEGIN {SOLVE} 

1 : FOR J :=1 . . N DO 
BEGIN 

IF J<N THEN 
BEGIN { 1 ( T > } 

1 [9] : R=B/C; 

2 C 63 ] :R=B-C*D; 

3C8I :R=B/C; 

4[481 : R=B-C*D; 

5 C 7 ] :R=B/C; 

6C 1 7 ] : R=B— C*D ; 

7 C 6 ] : R=B/C; 

8[24] : R=B-C*D 
END { 1 < T ) } ELSE 
BEGIN {1(E)} 

SI [9]:R*B/C; 

S2[ 1 8] : R=B-C*D; 
S3C73 :R=B/C; 

S4[l 6] :R=B-C*D; 
S5C7] : R=B/C; 

S6C7] :R=B-C*D; 

S7 [ 6 ] : R=B/C; 

END {1(E)} 

END; {1} 

2: FOR J :=N. . 1 DO 
BEGIN {2} 

IF J<N THEN 
BEGIN { 2 ( T ) } 

1 [1 6] :R=B*C; 

2 [4] : R=B-C-D-E-F ; 

3 [ 3 3 : R=B-C*D; 

4 [ 2 ] : R=B-C*D; 

5: R=B-C*D; 

6C2] :A=B-CPX[C*D] 
END { 2 ( T ) } ELSE 
BEGIN {2(E)} 

SI [3] :R=B-C*D; 
S2[2] :R=B-C*D; 

S3 C 1 ] :R=B-C*D; 
S4[2] ;A=B-CPX[C*D] 
END {2(E)} 

END {2} 

END; {SOLVE} 


#R=96T+4909L+4909S+4098A+4098M+71 9D 
#A=48L+48S+48A+48M+48CPX 

#R=(N-1 )(2T+182L+182S+1 52A+1 52M+30D) 
+2T+70L+70S+41 A+41 M+29D 

#R=T+182L+1 82S+1 52A+1 52M+30D 


#R=9( L+D+S ) 

#R=63( L+A+M+S) 
#R=8( L+D+S) 

#R=48( L+A+M+S) 
#R=7(L+D+S) 
#R=17(L+A+M+S) 
#R=6( L+D+S) 

#R=24( L+A+M+S) 
#R=70L+70S+41 A+41M+29D 


#R=( N-1 ) ( 2T+28L+28S+24A+24M)+2T+9L+9S+9A+9M 
#A=2N( L+S+A+M+CPX) 

#R=T+28L+28S+24A+24M 
#A=2 ( L+A+M+CPX+S ) 

#R=1 6( L+M+S) 

#R=4(L+4A+S) 

#R=3( L+A+M+S) 

#R=2(L+A+M+S) 

#R=L+A+M+S 
#A=2( L+A+M+CPX+S) 

#R=9( L+A+M+S) 

#A=2( L+A+M+CPX+S) 


58 



APPENDIX D: THE CRITICAL PATH 


PROGRAM SHAFT 
BEGIN 
1 : READ 

2 : INITIALIZE ; 

3 : RESET; 

4 : NEWRAP ; 

5: IF CONVERGED THEN 
BEGIN 

1 [2] : L=B; 

2: WHILE NOT STOP DO 
CALCULATE 
END 

END; 

PROCEDURE INITIALIZE 
BEGIN 

1 [206] :R=B*C; 

2 [ 1 48 ] : R=B*C; 

3 C 96 ] : R=B/(C*(D-E) ) ; 

4[ 120] : R=B+C; 

5 [48] :R=B+C; 

6C48 ] :R=B*C; 

7 [ 24 ] : R=B-C; 

8 C 96 ] : R=B/C ; 

9C1 20] : R=B 
END; {INITIALIZE} 

PROCEDURE RESET 
BEGIN 

1 [48] :A=B; 

2 [ 1 70 ] : R=B/C ; 

3[852] :R=-B*C,A=IMAG[R] ; 

END; {RESET} 

PROCEDURE CALCULATE 
BEGIN 

1 : IF CURRENT . . . ELSE 
BEGIN {IE} 

WHILE T<=TMAX DO 
BEGIN 

1 : IF CONVERGED AND Q<4 THEN 
1 (E) [49] :A=B/C; 

2 : CASE Q OF. . .F0RESTEP4; 

3: NEWRAP 

4: IF NOT CONVERGED OR ERR>E04 ... ELSE 
IF ERR<E06 THEN STEP§DOUBLE} ; 
END {1(E). 1} 

END; {1(E)} 

2 [ 3 ] ; R=B ; 

3 : WRITE 

END; {CALCULATE} 



PROCEDURE FORES T EP4 
BEGIN 


1 [96] : A=B+C+D+E 
END; 

PROCEDURE NEWRAP 


BEGIN {NEWRAP} 

1 [3] : R=B+C; 

2 [5] :A=B*C+D; 

3 [ 3 ] :A=B*C+D; 

4 : R=COS[B] ; 

5 C 3 3 : A=CPX[B,C] ; 

6 [ 50 ] : A=B*C; 

7 C 2 4 ] :A=B*C+D+E; 
8:WHILE ITTER<K20 DO 

BEGIN 


#R=1 4904X+1 482L+1 482S+3400T+21 A+C0S+20CABS 

+480IMAG+480#R[CALC1 ]+48O#R[CALC2]+20#R[SOLVE] 
1 3545X+1 945L+1 945S+7224A+ 1 444M+480D+2 1 CPX 
+480#A[CALC1 ]+480#A[CALC2 ]+20#A[ SOLVE ] 


#R=3X+L+A+S 

#A=5X+L+M+A+S 

#A=3X+L+M+A+S 

#R=X+L+COS+S 

#A=3X+L+CPX+S 

#A=50X+L+M+S 

#A=24X+L+M+2A+S 

#R=20( (2+7N)T+(49+29N)X+(2+3N)L+(2+3N)S 
+A+( N) IMAG+CABS+#R[ SOLVE ] 

+(N) (#R[CALC1 ]+#RCCALC2 ] ) ) 

#A=20( ( 1 +28N)X+( 1 +4N)L+( 1 +4N)S+( 1 +1 5N)A 
+( 3N)M+( N)D+#A [SOLVE ]+CPX 
+(N) (#A[CALC1 ]+#A[CALC2 ] ) ) 


1 :I=B+C; 

2 : IF MOD[ITTER,4]<>1 . . . ELSE 
A=B-CPX[C] ; 

3: FOR 0 :=1 . .N DO 
BEGIN 


1 : IF J<N THEN CALC! ; 


#R=X+L+A+S 

#R=T 

#A=X+L+CPX+A+S 
#R=N( 3T+27X+L+S 

+#R[CALC1 ]+#R[CALC2 1+IMAG) 
#A=N(28X+4L+4S+1 5A+3M+D 
+#A[CALC1 ]+#A[CAL2 ] ) 
#R=T+#R[CALC1 ] 
#A=#A[CALC1 ] 


2 [ 2 ] : A=B*C ; 

3 C 24 ] : A=B*C ; 

4: A=B*(C+D+E+F+G+H) ; 

5 : A=-(B+C+D+E+F+G+H+I+J-K) /M 
6: IF LOC(J) THEN CALC2 ; 

7 [ 26 ] : R=IMAG [ B ] 


#A=2X+L+M+S 

#A=24X+L+M+S 

#A=X+L+5A+M+S 

#A=X+L+1 OA+D+S 

#R=X+T+#R[CALC2 ] 

#A=#A[CALC2] 

#R=26X+L+IMAG+S 


END; 

4: SOLVE 

5 [ 48 ] ; R=CABS[B] ; 

6 : FOR I:=l . .2 AND J:=l . .N DO 


#R=#R[ SOLVE] 
#A=#A[ SOLVE] 
#R=48X+L+CDABS+S 
#R=2N( 2T+X+L+S) 


IF ABSU(I , J ) > ERR THEN 
7: IF CONVERGE THEN I=B 
END { S8 } 

END; {NEWRAP} 

PROCEDURE CALC1 
BEGIN {CALC1 } 

1 [10] :A=B+C*D*E; 

2 : R=CABS[B] ; 

3: IF ABSR>RMAX THEN R=B 
END; {CALC 1 } 


R=B; 


#R=T+2X+2L+2S+CABS 
#A=1 0X+L+S+A+2M 

#A=1 0X+L+2M+A+S 
#R=X+L+CABS+S 
#R=T+X+L+S 


#R=T+X+L+S 


60 



#R=4T+3X+3L+3S+6A+4(#R[EXTER] ) 
#A=50X+7L+7S+1 3A+3M+3D+4(#A[EXTER] ) 
#R=#R[EXTER] 

^A=#A[ EXTER] 

#A=2X+L+A+S 


PROCEDURE CALC2 
BEGIN {CALC2} 

1 : EXTER ; 

2[2] :A=B+C; 

3: IF FLAG THEN FOR L:=1 . . 3 DO 
BEGIN 

1 : I=B+C-D; 

218] :A=B+C*(D+E) ; 

3 [ 4 ] : EXTER; 

4 [8 3 :A=B+(C-D)/E 
END {3} 

END; {CALC2} 


#R=T+3( T+X+L+S+2A+#R[ EXTER] ) 
#A=3( 1 6X+2L+2S+4A+M+D+#A[EXTER]) 
#R=X+L+2A+S 
#A=8X+L+2A+M+S 
#A=#A[EXTER] 

#R=#R[EXTER] 

#A=8X+L+2A+D+S 



#R=( 1/24) (49T+2#R[JOURNL]+6X+6L+6S+3A+3D+3CABS) 
#A=( 1 / 2 4 ) ( 53X+2 9 L+29S+2A+8M+2#A[ JOURNL ]+3CPX) 
#A=2X+L+S 

#R=T+( 2/24)#R[ JOURNL ] 

#A= (2/24) (X+L+A+M+S+#A[ JOURNL] ) 


THEN #R=( 22/24) T+( 3/24) (T+2X+2L+2S+A+D+CABS) 
#A=( 3/24) (X+L+S+2M+CPX) 

#R=X+L+CABS+S 

#R=T+X+L+A+D+S 

#A=X+L+2M+CPX+S 


#R=3T+4X+5L+4S+A+M+CABS+SQRT+ATAN 
#A=28X+1 3L+1 3S+9A+1 3M+5D+ABS+CONJ 
#A=X+L+A+2M+D+S 
#R=X+L+CABS+S 


PROCEDURE EXTER 
BEGIN {EXTER} 

1 [2 ] :A=B; 

2 : I F ( J = 5 OR J=1 9) THEN 
BEGIN { 2 ( T ) } 

1 : JOURNL; 

2 : A=B-C*D 
END {2 ( T) } ELSE 
IF ( J = 3 OR J = 1 2 OR J=2 1 ) 

BEGIN 
1 • R_r ar^ 

2 : IF DEL>K002 THEN 
BEGIN 

1 :R=B-C/D; 

2 :A=B*C*CPX 
END 
END 

END; {EXTER} 

PROCEDURE JOURNL 
BEGIN {JOURNL} 

1 : A= ( B-C*D* E ) / F ; 

2 : R=CABS[V] ; 

3: IF ABSVoO THEN 
BEGIN { 3 ( T ) } 

1 :A=ABS[B]*C/D; 

2 :A=CONJ[B] ; 

3:R=B*C; 

4 : IF H<=KDM1 2 . . . ELSE 
BEGIN {4(E)} 

1 :A=B*C*D; 

2 : R=SQRT ( 1 -B) ; 

3:A=( 1-B)*C; 

4 [ 4 ] : A=B*C; 

5 C 5 ] : A=B*C ; 

6 C 4 ] :A=B*C; 

7 [ 5 3 :A=(B+C)/D; 

8 [ 2 3 :A=B-C*D/E; 

9 :A=B+C*D/E ; 

10: IF NOT CAV THEN . . . ELSE 

BEGIN {10(E)} 

1 : R=ATANC-B , REAL [C3 3 ; 

2 : A=B+C-D; 
3:A=B*(C*D+E-F) 

END {10(E)} 

END {4(E)} 

END { 3 ( T ) } 

END; {JOURNL} 


#R=3T+3X+4L+3S+A+M+SQRT+ATAN 
#A=27X+1 2L+1 2S+8A+1 1 M+4D+ABS+C0NJ 
#A=X+L+M+D+ABS+S 
#A=X+L+CONJ+S 
#R=X+L+M+S 

#R=2T+2X+3L+2S+A+SQRT+ATAN 
#A=25X+1 OL+1 0S+8A+1 0M+3D 
#A=X+L+2M+S 
#R=X+L+A+SQRT+S 
#A=X+L+A+M+S 
#A=4X+L+M+S 
#A=5X+L+M+S 
#A=4X+L+M+S 
#A=5X+L+A+D+S 
#A=2X+L+A+M+D+S 
#A=X+L+A+M+D+S 
#R=T+X+2L+S+ATAN 
#A=2X+2L+4A+2M+2S 
#R=X+2L+ATAN+S 
#A=X+L+2A+S 
#A=X+L+2A+2M+S 


62 


PROCEDURE SOLVE 
BEGIN {SOLVE} 

1 : FOR J : =1 . . N DO 


BEGIN 

IF 3<N THEN 
BEGIN { 1 ( T) } 

1 [9] : R=B/C; 

2 [ 63 ] : R=B-C*D 
3 C 8 ] : R=B/C; 

4 [ 48 ] : R=B-C*D 
5 [ 7 ] : R=B/C; 

6 [ 1 7 ] : R=B-C*D 
7 [ 6 ] : R=B/C; 

8 [ 24 ] : R=B-C*D 


END { 1 ( T) } ELSE 
BEGIN (HE)} 

SI [9] : R=B/C; 

S2C18] :R=B-C*D; 

S3 [ 7 3 :R=B/C; 

S4[16]:R=B-C*D; 

S5 C 7 ] : R=B/C; 

S6[7] :R=B-C*D; 

S7 [ 6 ] : R=B/C; 

END {1(E)} 

END; {1} 

FOR J :=1 TO N DO 
BEGIN {2} 

IF 3<N THEN 
BEGIN { 2 ( T ) } 

1 [ 1 6] : R=B*C; 

2[4] : R=B-C-D-E-F ; 

3 C 3 ] : R=B-C*D; 

4[2] : R=B-C*D; 

5:R=B-C*D; 

6 [ 2 ] : A=B-CPX[C*D] 
END { 2 ( T ) } ELSE 
BEGIN {2(E)} 

SI [3] : R=B-C*D; 

S2[2] :R=B-C*D; 

S3 C 1 ] ; R=B-C*D; 

S4[2] :A=B-CPX[C*D] 
END {2(E)} 

END {2} 

END; {SOLVE} 


#R=48X+4888X+31 2L+31 2S+264A+1 92M+96D 
#A=48X+24L+24A+24M+24S+24CPX 

#R=N( T+l 82X+8L+8S+4A+4M+4D) 

#R=T+1 82X+8L+8S+4A+4M+4D 


#R=9X+L+D+S 

#R=63X+L+A+M+S 

#R=8X+L+D+S 

#R=48X+L+A+M+S 

#R=7X+L+D+S 

#R=1 7X+L+A+M+S 

#R=6X+L+D+S 

#R=24X+L+A+M+S 


NOTE: #R & #A FOR THIS ELSE CLAUSE ARE 
APPROXIMATELY ACCOUNTED FOR BY 
INCREASING THE THEN-CLAUSE-MULTIPLIER 
FROM N-l TO N. 


#R-N( T+26X+5L+5S+7A+4M) 
#A=N( 2X+L+A+M+S+CPX) 

#R=T+26X+5L+5S+7A+4M 
#A=2X+L+A+M+CPX+S 
#R=1 6X+L+M+S 
#R=4X+L+4A+S 
#R=3X+L+A+M+S 
#R=2X+L+A+M+S 
#R=X+L+A+M+S 
#A=2X+L+A+M+CPX+S 

NOTE: SEE NOTE ABOVE 


63 



REFERENCES 

1. Kascak, Albert F.: Direct Integration of Transient Rotor Dynamics. NASA 

TP-1597, 1980. 

2. Arpasi, Dale K.; and Milner, Edward J.: Partitioning and Packing 

Mathematical Simulation Models for Calculation on Parallel Computers. NASA 
TM- 8 7170, 1986. 


TABLE I. - EXECUTION TIME ESTIMATES OF MC68020 MACHINE OPERATIONS 


Machine operations 

Execution time, *is 

Function 

Imneumoni c 

Real result 

Complex result 

Load, store 

L. S 

0.32 

0.64 

Test and jump 

T 

2.64 

— 

Overhead 

X 

— 

— 

Add, sub, neg 

A 

4.0 

8.0 

Mul t i pi y 

M 

5.0 

10.0 

Divide 

D 

7.5 

15.0 

Square root 

SQRT 

8.5 

— 

Cosi ne 

COS 

38.5 

— 

Arctangent 

ATAN 

31.0 

— 

Abs. value 

CABS 

11.3 

— 

Abs. value 

ABS 

— 

4.5 

Convert 

CPX, IMAG 

1.3 

1.3 

Conjugate 

CONJ 

— 

4.7 


TABLE II. - OPERATIONAL SUMMARY FOR SERIAL CALCULATIONS OF THE NEWTON-RAPHSON ALGORITHM 


(a) Operations required for real number results. 


Procedure 

T 

L 

S 

A 

M 

0 

COS 

CABS 

IMAG 

SQRT 

ATAN 

NEWRAP main 

5 380 

28 991 

28 991 

28 

1 040 

23 

2 

960 

960 



0 

500* CALC 1 

500 

1 000 

1 000 

0 

0 

0 

( 


500 







480*CALC2 

1 920 

1 440 

1 440 

2 880 

0 

0 



0 







6240*EXTER 

12 740 

1 560 

1 560 

780 

0 

780 



780 







520*JOURNL 

1 560 

2 600 

2 080 

520 

520 

0 



520 



520 

520 

20*SOLVE 

960 

97 260 

97 260 

81 040 

81 040 

14 380 

0 

0 



0 

( 


NEWRAP 

23 060 

132 851 

132 331 

85 248 

82 600 

15 183 

2 

2760 

960 

520 

520 


(b) Operations required for complex number results 


Procedure 

L 

S 

A 

M 

D 

CPX 

CONJ 

ABS 

NEWRAP main 

32 893 

32 893 

14 936 

15 082 

480 

963 

0 

0 

500 * CALC 1 

5 000 

5 000 

5 000 

10 000 

0 

0 





480*CALC2 

24 000 

24 000 

47 040 

11 520 

1520 

0 





6240*EXTER 

1 300 

130 

520 

2 080 

0 

780 





520*JOURNL 

6 760 

6 760 

4 630 

6 760 

2600 

0 

520 

520 

20*SOLVE 

960 

960 

960 

960 

0 

960 


0 


0 

NEWRAP 

70 913 

69 743 

73 086 

46 402 

4600 

2703 

520 

520 


64 





TABLE III. - OPERATIONAL SUMMARY FOR THE CRITICAL PATH CALCULATION 


OF THE NEWTON-RAPHSON ALGORITHM 


(a) Operations required for real number results. 


Procedure 

X 

T 

L 

S 

A 

M 

D 

COS 

CABS 

IMAG 

SQRT 

ATAN 

NEWRAP main 

14 904 

3 400 

1 482 

1 482 

21 

0 

0 

c 


20 

480 

0 

0 

480*CALC1 

960 

480 

960 

960 

0 

0 

0 

0 

480 

( 






480*CALC2 

1 440 

1 920 

1 440 

1 440 

2880 

1 

0 



0 







1920”EXTER 

480 

3 920 

480 

480 

240 

i 

240 



240 







160*J0URNL 

640 

480 

800 

640 

160 

160 

0 



160 



160 

160 

20*SOLVE 

97 760 

960 

6 240 

6 240 

5280 

3840 

1920 



0 

0 


0 


0 

NEWRAP 

116 184 

11 160 

11 402 

11 242 

8581 

4000 

2160 

2 

900 

480 

160 

160 


(b) Operations required for complex number results 


Procedure 

X 

L 

S 

A 

M 

D 

CPX 

CONJ 

CONJ 

NEWRAP main 

13 545 

1 945 

1 945 

7 224 

1444 

480 

1 

0 

0 

480*CALC1 

4 800 

480 

480 

480 

960 

0 

0 





480*CALC2 

24 000 

3 360 

3 360 

6 240 

1440 

1440 

0 





1920*EXTER 

4 240 

2 320 

2 320 

160 

640 

0 

240 





160*JOURNL 

4 480 

2 080 

2 080 

1 440 

2080 

800 

0 

160 

160 

20*SOLVE 

960 

480 

480 

480 

480 

0 

480 

0 

0 

NEWRAP 

52 025 

10 665 

10 665 

16 024 

7044 

2720 

TFF 

160 

160 


TABLE IV. - CALCULATION TIMES FOR PARALLEL AND SERIAL 
COMPUTATION OF THE NEWTON-RAPHSON ALGORITHM 
(a) Serial computation 


Procedure 

Real n CALCS, 

Complex U CALCS, 

Total CALC, 


msec 

msec 

msec 

NEWRAP mai n 

50.41 

320.86 

371.27 

500*CALC1 

7.60 

146.39 

153.99 

480*EXTER 

17.51 

695.30 

712.81 

6240'EXTER 

52.41 

27.63 

80.04 

20*SOLVE 

36.71 

157.70 

194.41 

520*JOURNL 

901.99 

19.75 

921.74 


NEWRAP (total serial ) 

2434.26 


(b) Parallel computation 


Procedure 

Real n CALCS, 
msec 

Complex # CALCS, 
msec 

Total CALC, 
msec 

NEWRAP main 

500*CALC1 

480-EXTER 

6240*EXTER 

20*SOLVE 

520*J0URNL 

10.89 + 14904Tx 
7.30 + 906 
17.31 + 1440 
16.12 + 480 
11.29 + 640 
61.24 + 97760 

81 .92 + 1 3545 ( 2T x ) 
14.50 + 4800 
90.22 + 24000 
10.96 + 4240 
48.45 + 4480 
9.87 + 960 

92.81 + 41994 Tx 
21.80 + 10506 
107.53 + 49440 
27.08 + 8960 
59.74 + 9600 
71.11 + 99680 

NEWRAP (total serial) 380.07 + 220180 Tx 


where Tx and 2Tx are the assumed transfer times associated 
with real and complex number, respectively. 


65 












MSA. Report Documentation Page 

Space Aclmmistmlion 

1 Report No. 2. Government Accession No 

NASA TM- 101462 

3. Recipient's Catalog No. 

4. Title and Subtitle 

Parallel Processing of a Rotating Shaft Simulation 

i 

5. Report Date 
February 1989 

1 

6. Performing Organization Code 

7. Author(s) 

Dale J. Arpasi 

8. Performing Organization Report No. 

E-4290 


10. Work Unit No. 

505-62-21 

9. Performing Organization Name and Address 


National Aeronautics and Space Administration 
Lewis Research Center 

11. Contract or Grant No. 

■ Cleveland, Ohio 44135-3191 

i 

13. Type of Report and Period Covered 

1 12. Sponsoring Agency Name and Address 

Technical Memorandum 

National Aeronautics and Space Administration 
Washington, D.C. 20546-0001 

1 

14. Sponsoring Agency Code 

15. Supplementary Notes 


16. Abstract 

A Fortran program describing the vibration modes of a rotor-bearing system is analyzed for parallelism, and a 
data-flow statement of the problem is developed. This statement identifies the inherent parallelism in this 
simulation using a pascal-like structured language. Potential vector operations are also identified. A critical path 
through the simulation is identified and used in conjunction with somewhat ficticious processor characteristics to 
determine the time to calculate the problem on a parallel processing system having those characteristics. A 
parallel processing overhead time is included as a parameter for proper evaluation of the gain over serial 
calculation. The serial calculation time is determined for the same ficticious system. An improvement of up to 
640 percent is possible depending upon the value of the overhead time. Based on the analysis, certain conclusions 
are drawn pertaining to the development needs of parallel processing technology, and to the specification of 
parallel processing systems to meet specific computational needs. 


17. Key Words (Suggested by Author(s)) 

Simulation 
Parallel processing 


18. Distribution Statement 

Unclassified - Unlimited 
Subject Category 66 


19 Security Classif. (of this report) 
| Unclassified 


20. Security Classif. (of this page) 
Unclassified 


21 . No of pages 
68 


22. Price* 


NASA FORM 1626 OCT 86 


*For sale by the National Technical Information Service, Springfield. Virginia 22161 




