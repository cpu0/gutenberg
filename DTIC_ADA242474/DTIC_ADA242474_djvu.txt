AD-A242 474 tationpage 


FomAfpfovtd 
OPU No. 070*4188 





t pif iMpoflMt IndudbiQ Pw Phm toi InMucNonk smnMhq wMIiiq dtti muom QtfiMInQ inrt HMMiMnQ Pw dfli 

uid nrtw tonn»flP nm p> d a(tilieolKllano(t«oiiii1oftlnduJngii m i rt oinlott»duc *i g»ilibiiidw.lD W iiW n gw i 
tiiO(iDpiPi ll l|p — |>, Su»tl20«,AilngBii.VA22aap-«3(tt.«iidW«wOWct«Hnl n ii in >on«d n iBi<MD H lAllrt»,Olle»ol 


ANOOA 

Jan 1991 to 01 Jun 1998 


imr^gT: 


Rnal: 

3 


Encore Computer Corporation, Parallel Ada Development System, Revision 1.0, 
Encore 91 Series (Model No. 91-0340) under UMAX 3.0 (Host & Ta 
910130W1.11114 


Wright-Patterson AFB, Dayton, OH 
USA 





Ada Joint Program Office 
United States Department of Defense 
Pentagon, Rm 3E114 
Washington, D.C. 20301-3081 


ii.su 


Ti:arrT=7i i 


10. SPONSORINGVMONITOniNG AGENCY 
REPORT NUMBER 


/4 ^ A K )'t 1 ^ 


ir:'n:!riir«77.\v.iifT;TiFii»ir:^riTrs7ri 


12a. DISTRIBUnON/AVAl 

Approved for public release; distribution unlimited. 


12b. DISTRIi 



13. ABSTRACT (Mwtimum 200 words) 

Encore (Computer Corporation, Parallel Ada Development System, Revision 1.0, Encore 91 Series (Model No. 91-0340) 
under UMAX 3.0 (Host & Target), ACVC 1.11. 


91-15055 




IS. NUM 


Ada pro(pamming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-ISISA, AJPO. 




17. 

Of REPOm 
UNCLASSIFIED 


NSN7B40-01-280-S60 


UNCLASSIFED 




OF ABSTRACT 

UNCLASSIFIED 



Sandaid Fomt 2M. (Rav. 2-80) 
9l n 0^ 1 9 Praacribed by ANSI Stt 230-128 

















AVF Control Number: AVF-VSR-446-0991 

5-September-1991 

90-09-18-ECC 


Ada COIPILER 
VALIDATION SUW1ARY REPORT: 

Certificate Number: 910130W1.11114 
Encore Computer Corporation 
Parallel Ada Development System, Revision 1.0 
Encore 91 Series (Model No. 91-0340) xmder UMAX 3.0 ■> 
Encore 91 Series (Model No. 91-0340) under UMAX 3.0 


Prepared By: 

Ada Validation Facility 
ASD/SCEL 

Wright-Patterson AFB CM 45433-6503 





Certificate Information 


Hie following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on 30 January 1991. 

Compiler Name and Versicxi: Parallel Ada Development System, Revision 1.0 

Host Computer System: Encore 91 Series (Model No. 91-0340) 

under UMAX 3.0 

Target Computer System: Encore 91 Series (Model NO. 91-0340) 

under UMAX 3.0 


Customer Agreement NundDer: 90-09-18-ECC 


See Sectioi 3.1 for any additional information about the testing 
environment. 

As a result of this vedidation effort, Validation Certificate 

910130W1.11114 is awarded to Encore conpater Corporation. This certificate 

expires on 1 Jime 1993. 

This report has been reviewed and is approved. 




Ada Validaticm FaciJ 
Steven P. Wilson 
Technical Director 



ity 


ASD/SCEL 

Wright-Patterson AFB OH 45433-6503 


M' r. . - /. _ 

Ada Valioaticm Organization 

Director, Computer & Software Engineering Division 
Institute for Defense Anedyses 
Alexandria VA 22311 



Dr. John Soloonnd, Director 
Department of Defense 
Washington DC 20301 








DEOARATION OF CONFORMANCE 
Tlie fdlowing declmtioo of confonsanee was supplied by the customer. 


Declaratloo of ConfanDaoce 

Customer Encore Computer Coiporadon 

Cenificste Awardee: Encore Computer Cosporation 

AdaValidadreiFadUty: ASD/SCEL 

Wright-Patterson AFB OH 45433-5503 

ACVC Version: 1.11 


AHa Tmp1«wnenf3irif>n! 


Ada Compiler Name and Version: I^nllel Ada Development System, 

Revision 1.0 


Host Computer System: Encore 91 Series (Model No. 91-0340) 

undcrUMAX3.0 


Target Conmuter System: Encore 91 Series (Model No. 91-0340) 

under UMAX 3.0 


Oedaradon: 

I the undersigned, representing Encore Cocoputer Coipotadan, declare that 
Encore Computer Coqioration has no knowledge of (liberate deviations from 
the Ada Lanmn Standaid ANS1/MIL-STD-1815A ISO 8652-19S7 in the 
in^kmenta^ listed above. 







CHAPTER 1 


INTRODUCTICN 


The Ada impleoientation described above was tested according to the Ada 
Vedidation Procedures (Pro90] against the Ada Standard [Ada83] using the 
current Ada Compiler Validaticoi Capability (ACVC). Ihis Vali^tion Sianmary 
Report (VSR) gives an account of the testing of this Ada inplementation. 

For any technical terms used in this report, the reader is referred to 
(Pro90]. A detailed description of the ACVC may be found in the current 
ACVC User's Guide (UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada 
Certification Body may sake full and free public disclosure of this report. 
In the Uhited States, this is provided in accordance with the "Freedom of 
Information Act” (5 U.S.C. #552). Hie results of this validation a^^ly 
only to the cooputers, operating systems, and compiler versions identified 
in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and conplete, or that the subject implementation has no 
nonconformities to the Ada Standard other than those presented. Copies of 
this re^rt are available to the public from the AVF which performed this 
validation or from: 

National Technical information Service 
5285 Port Royal Road 
Springfield VA 22161 


Questions regarding this report or the validation test results should be 
directed to the AVF vdiich performed this validation or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1-1 





INTROMKITION 


1.2 REFERQ^ES 


Reference Neuiued for the Ada Programning Language [Ada83 ], 
ANSI/MIL-Sm-iaiSA, February 1983 and ISO 8652-1987. 

Ada Compiler Validation Procedures, Version 2.1, [Pro90] 

Ada Joint Program Office, August 1990. 

Ada Conpiler Validation Capability User's Guide [UG89], 21 June 1989. 


1.3 ACVC TEST CLASSES 

Coiq>liance of Ada inplementations is tested by means of the ACVC. The ACVC 
contains a collection of test programs structured into six test classes: 

A, B, C, D, E, and L. Hie first letter of a test name identifies the class 
to v^ich it belongs. Class A, C, D, and E tests are executcdile. Class B 
and class L tests are expected to produce errors at conpile time and link 
time, respectively. 

The executable tests are written in a self-checking manner and produce a 
PASSED, FAILED, or NOT APPLICABLE message indicating the result vhen they 
are executed. Three Ada library units, the packages REPORT and SPPRT13, 
and the procedure CHECK FILE are used for this purpose. The package REPORT 
also provides a set of Identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test 
objective. The package SPPRT13 is used by many tests for Chapter 13 of the 
Ada Standard. The procedure CHECK FILE is used to check the contents of 
text files written by some of the Qass C tests for Chapter 14 of the Ada 
Standard. The operation of REPORT euid CHECK_FILE is checked by a set of 
executable tests. If these units are not operating correctly, validation 
testing is discontinued. 

Class B tests check that a compiler detects illegal leuiguage usage. Class 
B tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that all violations of 
the Ada Standard are detected. Some of the class B tests contain legal Ada 
code which must not be flagged illegal by the conpiler. This behavior is 
also verified. 

Class L tests check that an Ada implementation correctly detects violation 
of the Ada Standard involving multiple, separately compiled \jnits. Errors 
are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by 
implementation-specific values — for example, the largest integer. A list 
of tte values us^ for this implementation is provided in appendix A. In 
addition to these anticipated test modifications, additional changes may be 
required to remove unforeseen ccxiflicts between the tests and 
implementation-dependent characteristics. The modifications required for 
this implwmentation are described in section 2.3. 


1-2 








INTRCffiUCnCN 


For each Ada inplenentation, a custcniized test suite is produced by the 
AVF. This customization consists of making the modifications described in 
the preceding paragraph, removing withdrawn tests (see section 2.1) and, 
possibly seme inapplicable tests (see Section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of 
the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Ccxnpiler Die software and any needed hardware that have to be added 
to a given host and target computer system to allow 
transformation of Ada programs into executable form and 
execution thereof. 

Ada Compiler The means for testing compliance of Ada implementations. 
Validation consisting of the test suite, the support programs, the ACVC 
Capability user's guide and the template for the validation sumnary 

(ACVC) report. 

Ada An Ada conpiler with its host computer system emd its 

Inplementation target conputer system. 

Ada Joint Die part of the certification body which provides policy eund 
Program guidance for the Ada certification system. 

Office (AJPO) 

Ada Die part of the certification body vdiich carries out the 

Vedidation procedures required to establish the conpliance of an Ada 
Facility (AVF) implementation. 

Ada Die part of the certification body that provides technical 

Validation guidance for operations of the Ada certification system. 

Organization 
(AVO) 

Coopliance of Die ability of the implementation to pass an ACVC version, 
an Ada 

Implementation 

Conputer A functional unit, consisting of one or more cemputers and 

System associated software, that uses common storage for all or 

part of a program and also for all or part of the data 
necessary for the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including arithmetic 
operations and logic operations; and that can execute 
programs that modify themselves during execution. A 
computer system may be a stand-alone unit or may consist of 
several inter-connected isiits. 




INTRODUCTION 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 

ISO 

Operating 

System 


Target 

Conputer 

System 

Validated Ada 
Compiler 

Validated Ada 
Inpleroentation 

Validation 


Withdrawn 

test 


Fulfillment by a product, process or service of all 
requirements specified. 

An individual or corporate entity vrtio enters into an 
agreement with an AVF vdiich specifies the terms and 
conditions for AVF services (of any kind) to be performed. 

A formal statement from a customer assuring that conformity 
is realized or attainable on the Ada inplementation for 
vdiich validation status is realized. 

A conputer system v^ere Ada source programs are transformed 
into executable form. 

A test that contains one or more test objectives found to be 
irrelevant for the given Ada inplementation. 

International Organization for Stemdardization. 

Software that controls the execution of programs and that 
provides services such as resource allocation, scheduling, 
input/output control, and data management. Usually, 
operating systems are predominantly software, but partial or 
conplete hardware inplementations are possible. 

A conputer system vrtiere the executable form of Ada programs 
are executed. 


The ccmpiler of a validated Ada implementation. 


An Ada implementation that has been validated successfully 
either by AVF testing or by registration [Pro90]. 

The process of checking the conformity of am Ada coopiler to 
the Ada programming language and of issuing a certificate 
for this implementation. 

A test found to be incorrect and not used in conformity 
testing. A test may be incorrect because it has an invalid 
test objective, fails to meet its test objective, or 
contains erroneous or illegal use of the Ada progranning 
lamguage. 


1-4 





CHAPTER 2 


IMPLEMENTATICXJ DEPENDENCIES 


2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for 
withdrawing each test is available frcan either the AVO or the AVF. The 
publication date for this list of withdrawn tests is 21 November 1990. 


E28005C 

B28006C 

C34006D 

C35702A 

B41308B 

C43004A 

C45114A 

C45346A 

C45612B 

C45651A 

C46022A 

B49008A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CnA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 



2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives vhich are irrelevant 
for a given A^ implementation. Reasons for a test's inapplicability may 
be sv^^rted by documents issued by the ISO and the AJPO known as Ada 
Commentaries and ccmoBionly referenced in the format Al-ddddd. For this 
iii{>lementation, the following tests were determined to be inapplicable for 
the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


2-1 






IMPLmSNmUJON DEPENDENCIES 


The following 201 tests have floating-point type declarations requiring 
more digits than SYSTEM.MAX_DIGITS: 

C24113L..y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 

C35708L..Y (14 tests) C35802L..Z (15 tests) 

C45241L..Y (14 tests) C45321^..Y (14 tests) 

C45421L..Y (14 tests) C45521L..Z (15 tests) 

C45524L..Z (15 tests) C45621L..Z (15 tests) 

C45641L..Y (14 tests) C46012L..Z (15 tests) 

The following 21 tests check for the predefined type LCNG_INTEGER: 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

0456120 

C45613C 

C45614C 

C45631C 

0456320 

B52004D 

B55B09C 

C55B07A 

B86001W 

C86006C 


CD7101F 

C35702B, C35713C, B86001U, and C86006G check for the predefined type 
LONG_FLQAT. 

C35713D and B86001Z check for a predefined floating-point type with a 
naaie other than FLOAT, LC»JG_FLOAT, or SHORT_FLClAT. 

A35801E checks that FLOAT'FIRST..FLOAT'LAST may be used as a range 
constant in a floating-point type declaration; for this implementation 
that range exceeds the safe nuntoers eind must be rejected. (See 2.3) 

C45531M..P (4 tests) and C45532M..P (4 tests) check fixed-point 
operations for types that require a SYSTEM.MAX_MANTISSA of 47 or 
greater. 

C45624A and C45624B check that the proper exception is raised if 
MACHINEjOVERFLOWS is FALSE for floating point types; for this 
inplementation, MACHINE_OVERFLOWS is TRUE. 

C86001F reconciles package SYSTEM, naking package TEXT_IO, and hence 
package REPORT, obsolete. For this inplementation, the package TEXT_I0 
is dependent upon package SYSTEM. 

B86001Y checks for a predefined fixed-point type other than DURATION. 

C96005B checks for values of type DURATICTI'BASE that are outside the 
range of DURATION. There are no such values for this inplementation. 

CD1009C uses a representation clause specifying a non-default size for a 
floating-point type. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and Q)2 a 840 use representation 
clauses specifying non-default sizes for access types. 




IMPLEMENTATION DEPENDENCIES 


■Bie tests listed in the following table are not applicable because the 
given file operations are supported for the given combination of mode 
and file access method. 


Test 

File Operation Mode 

File Access Method 

CE2102D 

CREATE 

IN FILE 

SEQUENTIAL 10 

CE2102E 

create 

OUT FILE 

SEQUENTIAL 10 

CE2102F 

CREATE 

INOUT FILE 

DIRECT 10 

C:E2102I 

CREATE 

IN FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

OUT FILE 

DIRECr_I0 

CE3102E 

CREATE 

IN_FILE 

TE3CT 10 

c:e3102f 

RESET 

Any Mode 

TEXT 10 

CE3102G 

DELETE 


TEXT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT_I0 

CE3102J 

OPEN 

IN FILE 

TEXT_I0 

CE3102K 

OPEN 

OUT FILE 

TEXT_I0 


CE2203A checks that WRITE raises USE_ERROR if the capacity of the 
external file is exceeded for SEQUENTIAL_IO. This implementation does 
not restrict file capacity. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of the 
external file is exceeded for DIRECT_IO. This iitplemen_ation does not 
restrict file capacity. 

CE3304A checks that USE_ERROR is raised if a call to SET LINE LENGTH or 
SET_PAGE LENGTH specifies a value that is inappropriate Tor tEe external 
file. lEis ispleraentation does not have inappropriate values for either 
line length or page length. 

CE3413B checks that PAGE raises LAYOUT_ERROR vrtien the value of the page 
number exceeds CCXJNT'LAST. For this implementation, the value of 
CXDWNT'LAST is greater than 150000 naking the checking of this objective 
impractical. 


2.3 Test Modifications 

Modifications (see section 1.3) were required for 23 tests. 


2-3 





IMPLEMENTATION DEPENDENCIES 


The following tests were split into two or more tests because this 
implementation did not report the violations of the Ada Standard in the way 
expected by the original tests: 

B24009A B33301B B38003A B38003B B38009A B38009B 

B85008G B85008H B91001H BC1303F BC3005B BD2B03A 

BD2D03A BD4003A 


A35801E was graded inapplicable by Evaluation Modification as directed by 
the AVO; the conpiler rejects the use of the range FLOAT'FIRST..FLOAT'LAST 
as the range constraint of a floating-point type declaration because the 
bounds lie outside of the range of safe numbers (cf. ARM 3.5.7(12)). 

CD1009A, CD1009I, CD1C03A, CD2A22J, CD2A24A, and CD2A3IA..C (3 tests) use 
instantiations of the support procedure Length_Check, v^ich uses 
Unchecked Conversion according to the interpretation given in AI-00590. 

The AVO ruled that this interpretation is not binding under ACVC 1.11; the 
tests are ruled to be passed if they produce Failed messages only from the 
instantiations of Leng^_Check—i.e., the allowed Report.Failed messages 
have the general form: 

" * CHECK ON REPRESENTATICN FOR <TYPE IB> FAILED." 


2-4 





QIAPTER 3 


PROCESSING INTORMATIOJ 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is described 
adequately by the information given in the initial pages of this report. 

For a point of contact for technical information about this Ada 
inplementation system, see: 

Gary Beerman 

6901 W. Sunrise Blvd. 

Ft. Lauderdale FL 33340-9148 

For a point of contact for sales information about this Ada inplementation 
system, see: 


Gary Beerman 

6901 W. Sunrise Blvd. 

Ft. Lauderdale FL 33340-9148 


Testing of this Ada inplementation was conducted at the customer's site by 
a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Inplementation passes a given ACVC version if it processes each test 
of the custcmiized test suite in accorciUmce with the Ada Programming 
Language Standard, vhether the test is applicedble or inapplicable; 
otherwise, the Ada Inplementation fails the ACVC [Pro90]. 

For all processed tests (inapplicedjle and applicable), a result was 
obtained that conforms to the Ada Prograsaning Leuiguage Standard. 


3-1 




PROCESSING INFORMATION 


a) Total Number of Applicable Tests 3814 

b) Total Number of Withdrawn Tests 83 

c) Processed Inapplicable Tests 72 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 201 

f) Total Number of Inapplicable Tests 273 


g) Total Number of Tests for ACVC 1.11 4170 


All I/O tests of the test suite were processed because this inplementation 
supports a file system. Hie above number of floating-point tests were not 
processed because they used floating-point precision exceeding that 
supported by the inplementation. When this conpiler was test^, the tests 
listed in section 2.1 had been withdrawn because of test errors. 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 1.3) was 
taken on-site by the validation team for processing. The contents of the 
magnetic tape were loaded directly onto the host computer. 


After the test files were loaded onto the host computer, the full set of 
tests was processed by the Ada ioplementation. 


The tests were compiled, linked, and run on the computer system, as 
appropriate. The results were captured on the computer system. 

Testing was performed using command scripts provided by the customer and 
reviewed by the validation team. See .^pendix B for a complete listing of 
the processing options for this implementation. It also indicates the 
default options. The options invoked explicitly for validation testing 
during this test were: 

Cption/Switch Effect 


-V Verbose 


Test output, compiler and linker listings, and job logs were captured on 
magnetic tape and archived at the AVF. The listings examined on-site by 
the validation team were also archived. 


3-2 






APPEMJIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. 
The meaning and purpose of these parameters are explained in [UG891. The 
parameter values are presented in two tables. The first table lists the 
values that are defined in terms of the maximum input-line length, which is 
the value for $MAX_IN_LEK—also listed here. These values are expressed 
here as Ada string aggregates, where "V" represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 499 

$BIG_ID1 (1..V-1 -> 'A', V -> '1') 

$BIG_ID2 (1..V-1 *> 'A', V -> '2') 

$BIG_ID3 (1..V/2 -> 'A') & '3' & 

(1..V-1-V/2 -> 'A') 

$BIG_ID4 (1..V/2 -> 'A') & '4' & 

(1..V-1-V/2 -> 'A') 

$BIG_INT_LIT (1..V-3 -> '0') & "298" 

$BIG_REAL_LIT (1..V-5 »> '0') & "690.0" 

$BIG_STRING1 & (1..V/2 -> 'A') & 

$BIG_STRING2 & (1..V-1-V/2 -> 'A') & '1' & 

$BLANKS (1..V-20 ) 

$MAX_LEN_INT_BASED_LITERAL 

"2;" & (1..V-5 -> '0') & "lit" 

$MAX_LEN_REAL_BASED_LITEBAL 

"16:" & (1..V-7 -> '0') S. "F.E:" 


A-1 





MACRO PARAMETERS 


$MAX_STRING__LITERAL & (1..V-2 -> 'A') & 

The following table lists all of the other macro parameters and their 
respective values. 


Macro Parameter 

Macro Vedue 

$ACC_SI2E 

32 

$ALIGNMENT 

4 

$COUNT_LAST 

2147483647 

$DEFAULT_MEM_SIZE 

16777216 

$DEFAULT_STOR_UNIT 

8 

$DEFAULT_SYS_NAME 

Umaxv_88k 

$DELTA_DOC 

0.0000000004656612873077392578125 

$ENTRY_AM)RESS 

SYSTEM."+"(16#40#) 

$ENTRY_ADDRESS1 

SYSTEM."+"(16#80#) 

$ENTRY_ADDRESS2 

SYSTEM. "+''(16#100#) 

$FIELD_LAST 

2147483647 

$FILE_TERMINATOR 

f f 

$FIXED_NAME 

NO_SUCH_TYPE 

$FLCIAT_NAME 

NO_SUCH_TYPE 

$PORM_STRING 

nn 

$F0RM_STRING2 

"CANNOT_RESTRICT_FILE_CAPACITY" 

$greater than duration 

100000.0 

$GREATER IHAN DURATION BASE LAST 

TooooUoo 


$GREATER_'IHAN_FLCIAT_BASE LAST 

1.5E+308 

$GREATER_THAN_FLOAT_SAFE LARGE 

5.iyE307 


A-2 





MACRO PARAMETERS 


$GREATER THAN SHORT FLOAT SAFE LARGE 

9.0E37 ~ 

$HlCa_PRIORIT5f 99 

$ILLBGAL_EXTERNAL_FILE NAMEl 

■Villegal/file_naine/2} I%2102c.dat" 

$ILLBGAL_EXTERNAL_FILE NAME2 

'Villegal/f ile_name/CE2102C* .dot" 


$INAPPROPRIATE_LINE LENGTH 

-1 

$INAPPROPRIATE_PAGE_LENGTH 

-1 


$INCL0DE_PRAGMA1 

$INCLUDE_PRAGMA2 

$1NTEGER_FIRST 

$INTEGER_LAST 

$INTEGER_LAST_PLUS_1 2147483648 

$IlJm3lPAaEJLANGUAGE C 

$LESS_THAN_DORATION -100000.0 

$LESS_THAN_DORATION_BASE FIRST 

-lTJOOOOOO-0 


PRAGMA INCLUDE ("A28006D1.TST") 
PRAGMA INCLUDE ("B28006D1.TST") 
-2147483648 
2147483647 


$LINE_TERMINATOR 
$LOW PRIORITY 


ASCII.LF 
0 


$MACHINE_pa)E_STATEMENT 

a»E 0' (OP -> NOP); 


$MACHINE_CC®E_TYPE 

$MANTISSA_DOC 

$MAX_DIGITS 

$MAX_INT 

$MAX_INT_PLUS_1 

$MIN INT 


CODE_0 

31 

15 

2147483647 

2147483648 

-2147483648 


A-3 



MACRO PARAMETERS 


$NAME 

$NAME_LIST 

$NAME_SPECIFICATI0N1 

$NAME_SPECIFICATI0N2 

$NAME_SPECIFICATI0N3 

$NEG_BASED_INT 

$NEW_MEM_SIZE 

$NEW_STORJJNIT 

$NEW_SYS_NAME 

$PAGE_TERMINATOR 

$RECORD_DEFINITION 

$RECORD_NAME 

$TASK_SIZE 

$TASK_STORAGE_SIZE 

$TICK 

$VARIABLE_ADDRESS 

$VARIABLE_AK)RESS1 

$VARIABLE_ADDRESS2 

$YOUR__PRAGMA 


TINY_INTEGER 

Umaxv_88k 

"/tiS/acvcl.ll/^rork/ceZ" & "X21202A" 
"A»5/acvcl.ll/Vrork/ce2" & "X21202B" 
"Ai5/acvcl.ll/\i)ork/ce3" & "X3119A" 
16#F000000E# 

65535 

16 

lBnaxv_88k 

ASCII.FF 

RECORD SUBP: OPERAND; END RECORD; 

CODE_0 

32 

1024 

0.01 

VAR_1'ADDRESS 
VAB_2'ADDRESS 
VAR_3'ADDRESS 
PRAGMA PASSIVE 


A-4 




APPE34DIX B 


COMPIIATIC»I SYSTEM OPTIONS 


The conpiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. IMless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 




ada(l) 


UNIX Programmer’s Manual 


ada( 1) 


NAME 

ada - invoke the Ada compiler 
SYNOPSIS 

ada [oiaions] [source jUe j]... [linker_options\ [objectJileji]... 

DESCRIPnON 

ada executes the Ada compiler and compiles source Jiie. sourceJile must end with the suffix and must 
reside in a directory that has been inidalixed as an Ada library. The adaJib file in this diiectciy is modified 
after each Ada unit is compiled. 

You can specify non-Ada object files (.0 files produced by compilers for other languages) to be linked with 
the specified A^ object files. 

By default, ada produces only object and nets files. If you specify the -M option, the compiler automati- 
c^y invokes add and builds a complete program, with the specified library unit as the main program. 

The order of compilation and the order of the files to be passed to the linker can be significant. You can, 
however, specify command line options in any order. 

Specify no more than one of the following opdoos: -E, -e, -El -el, -ev. 

The (grtionsare: 

-# identifier type value (define) Define an identifier of the specified type and value. (For further 

information, see "Ada Preprocessor Reference.") 

-a file_name (archive) Treat filejuime as an object archive file created by ar. This 

option distinguishes archive files, some of which end with .a, from Ada 
source files, all of which end with Ji. 

(dependencies) Analyze for dependencies only, performing neither 
semantic atudysis nor code generation. Update the library, marking any 
dependent units as uncompiled. The a-make utility uses this informa¬ 
tion to estaNish dependencies among new files. 

(error output) Use a-error to process error messages. If neither file nor 
directory is specified, ada directs a brief listing to standard ouqxii. 
placing the raw error messages in adajourcejtrr. If file is specified, 
ada places the raw erm’ messages in the file with that name. If direc¬ 
tory is specified, ada places the raw error messages in 
directorylsource,KrT. You can use the file of raw error messages as 
input to a^rror. 

-e (error) Use a-error to process compilation error messages, sending the 

listing to standard output Only the source lines containing errors are 
listed. 

(error listing) Same as the -E opdon, except that error messages are 
interspersed among source lines. 

(error listing) Same as the -e option, except that error messages are 
interspersed among source lines. 

(error vi(l)) Process syntax error messages using a-error, embed them 
in the source file, and call the environitwm editor erR(»_editor. If no 
editor is specified, call vi(l). (If ERROR.fDrroR is defined, the environ¬ 
ment variable error_pattern shoiiid also be defined. 
E]UtOR_PAlTERN is an editor seach command that locates the first 
occurrence of the siring ### in the error file.) 

(keep) Keep the intermediate language (IL) file produced by the 


-ev 


-K 


-El [file] [directory] 

-el 


-d 


-E [file] [directory] 


7th Edition 


1 







ada(l) 


UNIX Programmer’s Manual 


ada(l) 


-L libraryjume 


- \filejtbbreviadon 
-M [unitjume] 


-M sourceJUe 


-0 executableJile 
-O[0-9] 


compiler front end; name the file Adajsourcel, and place it in the 
objects directory. 

(library) Operate in the Ada lilsaty libraryjuune. The is the 
current working directory. 

Note: If two files of the same name from different directories are com¬ 
piled in the same Ada library using the -L tqttion, the second compila¬ 
tion overwrites the first, even if the contents and unit names are dif¬ 
ferent For example, ada/usr/directory2/foo.a-L/usr/PADSAest 

overwrites 

ada /uar/directoryl/foo.a -L /uer/PADS/test 
in library /usr/PADS/test. 

(Ubrary search) Direct the linker, ld(l), to search the library file 
q)ecified by filejibbreviadon. 

(main) Produce an executaifie program by linking uiutjume as the 
main jKOgram. unitjume must be either a parameterless procedure or 
a parameterless function returning an integer. Unless it is being com¬ 
piled by this invocation ofruia, unitjume must already have been com¬ 
piled. The executable {»ogram is named a.out unless you use the -o 
option to specify another name. 

(main) Produce an executable program by compiling and linking 
source Jile. The main unit of the program is assumed to be the root 
name of die Ji file (in fooa, for example, the main unit is foo). Unless 
you use the -o option to specify another name, the executable program 
is named 8,oiit Only one ui file can be preceded by -M. 

(output) Name the executable program executable JUe rather than the 
default, a^int This option is used in conjunction with the -M option. 

(optimize) Invoke the code optimizer (OPTIM3). The opdonal digit pro¬ 
vides the level oi optimization. The default is -04. 

This version of the compiler includes a preliminary M88k-specific 
opdinizer. The optimizer schedules load instructions to avoid pipeline 
edicts and moves instructions to the delay slots of branches and 
calls. Since it can be slow for some programs, it is enabled only at 
optimization levels greater than 4. 

-O full optimization 

-OO no optimization 

-01 no hoisting 

-02 no hoisting but more passes 

-03 no hoisting but even mrae passes 

-04 hoisting from loops 

-05 hoisting from loops but more passes 

-Oi hoisting from loops with maximum passes 

-07 hoisting from loops and branches 

-08 hoisting from loops and branches, more passes 


7th Edition 


1 






UNIX Progianuner’s Manual 


ada(l) 


-09 hoisting from loops and braiKhes, maximum passes 

Note: Hoisting from branches (and case alternatives) can be slow and 
does not always provide significant petfonnance gains. You might 
therefore want to suppress it 


-p (preprocessor) Invoke the Ada preprocessor, a.app. 

-R library name (recompile instantiation) Force analysis of all generic instantiations, 

causing reinstanbation of any that are out ctf date. 

-S (suppress) Apply pragma suppress to the entire compilation for all 

suppressible ch«dts. 

-sh (show) Display the name of the executable compiler, but do not exe¬ 

cute it. (Seve^ versions of pads may exist on one system. The ada 
command in any PADSjocadonJbin executes the correct version of the 
compiler based upon visible library directives.) 

-T (timing) Prim timing information for the compilation. 

-V (verbose) Print compiler version number, date and time of compilation. 

name of file compil^ command input line, total compilation dme, and 
error summary line. Provide information about the object file’s use of 
storage. With opmo the output format of compression (the size of 
optimized instructions) is shown as a percentage of input (unoptimized 
instructions). 

-w (warnings) Suppress warning diagnostics. 


FILES 

ada.lib 

gnrx.lib 

cvAS.lock, gnrx.lock 

GVAS_table 

.imports 

.lines 

.nets 

.objects 


Library reference file 

Generic instantiation reference file 

Lock the library while reading or writing special library files 

Address assignmem file 

Imported Ada units directory 

Line number reference files directory 

DIANA nets files directory 

(global) object files directory 


SEE ALSO 

ajipp(l), a.errar(l), a.ld(l), ajnake(l) 
l<l(l).vi(l) 

DIAGNOSTICS 

The diagnostics produced by the compiler are intended to be self-explanatory. Most refer to the Ada 
Language Reference Manual (Ada RM). Each Ada RM reference includes a section number and, option¬ 
ally, a paragraph number enclosed in parentheses. 


7th Edition 


3 







COMPILATION SYSTEM OPTIONS 


LINKE3? OPTIONS 

The linker options of this Ada in?)lenientation, as described in this 
^jpendix, are provided by the custraner. Unless specifically noted 
otherwise, references in this appendix are to linker dociunentation and not 
to this report. 






aJdd) 


UNIX Programmer’s Manual 


aJdd) 


NAME 

aJd - invoke the Ada prelinker 
SYNOPSIS 

aid [options] unitjuane [ld_pptions] 

DESCRIPTION 

aJd collects the object hies needed to make unitjiame a main program, add then calls the linker ld(l) to 
link all Ada object files and any non-Ada object files required to produce an executable image in a.out. 

mitjutme specifies the main program and must be a nongenehc subprogram. If unitjiame is a function, it 
must return a value of type staNDaROJNTEGER. This integer result is passed back to the shell as the status 
code of the execution. 

All arguments after unitjuane are passed to Idvl). These arguments may be Id options, archive libraries, 
library abbreviations, or object files 

The options are: 

-DX (debug) Debug memory overflow. Use this option in cases where Unk¬ 

ing a large number of units produces the error message “local symbol 
overflow". 

(elab(»ate) Elaborate unitjuane as early in the elaboration order as 
possible. 

(files) Display a list of dependent files in order, but suppress linking. 

(Ubrary) Operate in the Ada library libraryjuane. The default is the 
cunem working directory. 

(ouqmt) Name the executable file executable Jile rather than the 
default, a4»t 

Retain relocation entries in the ouq)ut object file. Relocation entries 
must be saved if the output file is to become an input file in a subse¬ 
quent run of a link editor. The link editor does not complain about 
unresolved references, and the ouqtut file is not executable. 

(show) Display the name of the a.hl executable file, but do not execute 
ic (Several versions of pads can exist on one system. 
PADSjocadonJhinlnAd executes tlw correct version of add based upon 
directives visible in the ada.lib file.) 

Use uaget as the target run-time environment. 

(units) Print a list of dependent units in orda, but suppress linking, 
(verbose) Print the linker command betcm executing it. 

(verify) Print the linker command, but suppress execution. 

The aJd tool reads the nets files produced by the Ada compiler to determine dqrendency information. The 
tool produces an nception mapping table and a unit elaboration table and passes this information to the 
linker. 

^d reads instructions for generating executables from the ada.lib file in the Ada libraries on the search 
list In addition to information generated by the compiler, these instructions include wiTHn directives, 
which enable the automatic linking of object modules compiled from oth» languages or Ada object 
modules not named in context clauses in the Ada source. The adaJib file can contain any number of wiTHn 
directives, but the directives must be numbered consecutively, beginning u wrrHl. The directives have the 
following form: WITHlUNlCoii/eci Jife: WITH2: LINK: archive Jile: wiTHn directives can be placed 


-r 


-sh 


-T target 
-U 

-V 

-V 


-E unitjuane 
-F 

-L libraryjuane 
-0 executableJile 


7th Edition 


I 






aJd(l) 


UNIX Programmer’s Manual 


a.ld(l) 


in the local Ada lilxary or in any Ada libraries on the search list A wiTHn directive in the local hbrary or 
earlier on the search list hides any WTTHn directive with the same number in a library later on the search 
list 

Use the tool ainfo to change or display library directives in the current library. 

FILES 

a.out Default ouqrut file 

jiets DIANA nets files directory 

.objects/* Ada object files 

PADSjocation/suindarcU* Start-up and standard library routines 

SEE ALSO 

ada(l), a.info(l) 

IcKD 

DIAGNOSTICS 

aJd produces self-explanatory error messages for missing files, etc. Additional messages are produced by 
the linker, ld(l). 


7th Edition 


2 



APPENDIX C 


APPENDIX F OF THE Ada STANDARD 

♦ 


The only allowed implementation dependencies correspond to 
inpleiaentation-dependent pragmas, to certain machine-dependent conventions 
as mentioned in Chapter 13 of the Ada Standard, and to certain allowed 
restrictions on representation clauses. The inplementation-dependent 
characteristics of this Ada implementation, as described in this Appendix, 
are provided by the customer. Unless specifically noted otherwise, 
references in this Appendix are to compiler documentation and not to this 
report. Implementation-specific portions of the package STANDARD, which 
are not a part of Appendix F, are: 


package STANDARD is 


type INTEGER is range -2147483648 .. 2147483647; 
type FLOAT is digits 15 range -1.701411183E+308 .. 
type DURATION is delta 0.001 range -2147483.648 .. 
type SHORT_INTEGER is range -32768 .. 32767; 
type SHORT_FLQAT is digits 6 range -3.40282E+38 .. 
type TINV_INTEGER is range -128 .. 127; 


1.70141183E+308; 

2147483.647; 


3.40282E+38; 


end STANDARD; 


C-1 






B 


Appendix F 

of the Ada Language 

Reference Manual 


The Parallel Ada Development System provides the full Ada language as 
specified in the Ada Language Reference Manual (Ada RM). Within the Ada RM, 
a number of sections contain the annotation implementation dependent, meaning 
that the interpretation of the section is left to the compiler implementor. This 
appendix describes the implementation-dependent characteristics of the PADS 
compiler. 

PADS has attempted to provide an essentially unlimited capability to program in 
Ada. Consequently, applications programmers can usually program in Ada 
according to the Ada RM and good engineering practices without consideration of 
any PADS specifics. 


PRAGMAS AND THEIR EFFECTS 


This section provides a brief description of every pragma supported by PADS. 
You can find additional information about some of the pragmas under discussions 
of particular language constructs elsewhere in this manual and in the Parallel Ada 
Development System User’s Guide. 

pragma CONTROLLED 


This pragma is recognized by the implementation but has no effect in the current 
release. 


Parallel Ada Oavalopmant Syatam Programmar’s Guide 


B-1 





Pragmas and Their Effects 


Appendix F of the Ada Language Reference Manual 


pragma ELABORATE _ 

This pragma is implemented as described in Appendix B of the Ada RM. 


pragma EXTERNAL_NAME _ 

This pragma enables you to specify an external link name for an Ada variable or 
subprogram so that the object can be referenced from other languages. The 
pragma is allowed at the place of a declarative item in a package specification and 
must apply to an object declared earlier in the same pacl^ge specification. Objects 
must be variables defined in a package specification; subprogranos can be either 
library level or within a package specification. For further information about 
pragma EXTERNAL_NAME, see Chapter 4 of this manual. 

pragma IMPUCIT_CODE _ 

Use this pragma with caution. The pragma, used only within the declarative pan of 
a machine code procedure, specifies whether implicit code generated by the 
compiler is allowed (ON) or disallowed (OFF). Implicit code includes preamble 
and postamble code (for example, code used to move paratneters to and from the 
stack). A warning is generated if implicit code is required and OFF is specified. 

Use of pragma IMPLICIT.CODE does not eliminate code generated for run-time 
checks, nor does it eliminate call/retum instractions. (These can be eliminated by 
pragma SUPPRESS and pragma INLINE, respectively.) 

For further information about pragma IMPLICIT_CODE, see Chapter 3 of this 
manual. 


pragma INLINE 


This pragma is implemented as described in Appendix B of the Ada RM, with one 
addition: Recursive calls can be expanded with the pragma up to the maximum 
depth of 4. Warnings are generated for bodies that are not available for inline 
expansion. When applied to subprograms that declare tasks, packages, 
exceptions, types, or nested sub^grams, pragma INLINE is ignored and causes 
a warning to lx issued. 


B-2 


Parallel Ada Development Syetem Programmer's Guide 







Appendix F of the Ada Language Reference Manual 


Pragmaa and Their Effects 


pragma INLINE_ONLY _ 

When used in the same way as pragma INLINE, this inagzna indicates to the 
compiler that the subprogram must always be inlined. This is very important for 
some code procedures, pragma INLINE.ONLY also saves code space by 
suppressing the generadon of a callable version of the routine. If you erroneously 
twalfe an INLINE_ONLY subprogram recursive, a warning is generated and a 
PROGRAM_ERROR is raised at run time. 


pragma INTERFACE _ 

This pragma, with parameters language and subprogram, supports calls to Ada, C, 
Pascal, and FORTRAN functions. You can also use pragma INTERFACE to call 
code written in unspecified languages, specifying UNCHECKED as the language 
name. The Ada spe^cations can be either fiincdons or procedures. 

For Ada, the compiler generates the call as if it were a call to an Ada procedure, 
but it does not expect a matching procedure body. 

For C, the types of parameters and the result type for functions must be scalar 
types, access types, or the predefined type ADDRESS in package SYSTEM. 
Record and array objects can be passed by reference using the ’ADDRESS 
attribute. All parameters must have mode in. 

For Pascal, the types of parameters and the result type for functions must be 
scalar types, access types, or the predefined type ADDRESS in package 
SYSTEM. Record and array objects can be passed by reference using the 
'ADDRESS attribute. 

For FORTRAN, all parameters are passed by reference The parameter types 
must have type SYS'TEM.ADDRESS, and ^e result type for a function must be a 
scalar type. 

Use UNCHECKED to interface to an unspecified language, such as assembler. 

The compiler generates the call as if it were a call to an Ada procedure, but it does 
not expect a matching Ada procedure body. 

For related information, see the section entitled "Parameter Passing" later in this 
appendix. 


B-3 


Parallel Ada Davalopmant Syatam Pregrammar's GuMa 






Pragmas and Their Effects 


Appendix F of the Ada Language Reference Manual 


pragma iNTERFACE_NAME _ 

This pragma enables direct reference in Ada to variables or subprograms defined 
in another language, pragma INTERFACE.NAME uses the following format: 

pragma INTERFACE_NAME iAda_subprogrcan, linkjutme); 

where Ada_subprogram denoms either an object or a sut^nogram. 

The pragma replaces all references to Ada_subprogram with an external reference 
to linkjutme in the object file. 

UAdajubprogram denotes an object, the pragma is allowed at the place of a 
declarative item in a package specification and must ^ply to an object declared 
earlier in the same package specification. The object must be declared as a scalar 
or an access type and cannot be any of the following: 

• Loop variable 

• Constant 

• initialized variable 

• Array 

• Record 

UAdajubprogram denotes a subprogram, a pragma INTERFACE must already 
have been specified for the subprogram. 

The linkjutme must be constructed as the linker expects; for example, C variable 
names must be prefaced with an underscore. The following example makes the C 
global variable ermo available within an Ada program: 

package PACKAGE_NAME is 
ERRMO;INTEGER; 

pragma INTERPACE_NAME (ERRNO,"_etrno"); 
end PACKAGE_NAME; 

For further information about pragma INTERFACE_NAME, see Chapter 4 of 
this manual. 

pragma UNK_WITH_ 


Use this pragma to pass arguments to the linker. The pragma can appear in any 
declarative part and accept one argumenL a constant string expression. This 
argument is passed to the target linker whenever the unit containing the pragma 
is included in a link. 




PanIM Ada DavaHtpmam SyMam Programmer's Guide 






Appendix P of ttw Ada Language Reference Manual 


Pragmaa and Their Effecta 


For example, the following package puts the -Im option on the command line fcn- 
the linker whenever MATH is included in the linked program: 

package MATH Is 

pragma LINK_MITH( "-Im ") ; 
end; 

And die following package links with the named object file sin.o: 
package MATH Is 


SIN is a routine written in C or assembly: the object 
for the routine is in the object file sin.o 


function SIN (X:FLOAT) return FLOAT; 

pragma interface (C, SIN); 
pragma LINK_WITH("sin.o"); 
end MATH; ~ 

If the constant string expression begins with the string is left untouched. If 
the string begins with neither nor "T, then the string is prefixed with 

pragma LIST_ 


This pragma is in^lemented as described in Appendix B of the Ada RM. 

pragma MEMORY_SIZE_ 


This pragma is recognized by the implementation but has no effect in the current 
release. PADS does not allow modification of package SYSTEM by means of 
pragmas. You can, however, achieve the same effect by copying the file systenua 
in library standard to a local Ada library and recompiling it there with new values. 

pragma NOJMAGE_ 


This pragma suppresses the generaticHi of the image array used for the ’IMAGE 
attribute of enumeration types, eliminating the overhead required to store the 
array in the executable image. Any attenqit to use the ’IMAGE attribute on a 
type whose image array has been suppressed results in a warning at compile time 
and causes the exception PROGRAM_ERROR to be raised at run time. 


Parallel Ada Oevelopmam Syatam Programmer's Guide 


B-5 









Pragmu and Thair Effaeta 


Appendix F of the Ada Language Reference Manual 


pragma NON_REENTRANT _ 

This pragma takes one argument, which can be the name of a library subprogram 
or a subprogram declared immediately within a library package speciHcation 
or body. The pragma prevents the subprogram from being called recursively, 
allowing the compiler to perfinm spe(^c optimizations. You can apply 
pragma NON.REENTRANT to a subprogram or a set of overloaded 
subprograms within a package specification or package body. 

pragma NOT_ELABORATED _ 

This pragma suppresses the generation of elaboration code, issuing warnings if 
elaboration code is required. The pragma prevents elaboration of a package that is 
either part of the run-time system, a configuration package, or an Ada package 
that is referenced fiom a language other than Ada. pragma NOT.ELABORATED 
can appear only in a library package specification. 

pragma OPTIMIZE _ 

This pragma is recogiuzed by the inqrlementation but has no effect in the current 
release. For code optimization options, see the ada - O entry in Chapter 9 of the 
Parallel Ada Development System User's Guide. 

pragma OPTlMIZE_CODE _ 

This pragma specifies whether the compiler optimizes code (ON) or does not 
optimize code (OFF). When OFF (the default) is specified, the compiler 
generates the code as specified. You can use the pragma in any subprogram. 

You can suppress optimization selectively by using this pragma at the 
subprogram level. Inline sut^m}grams are optimized even if 
OPTIMIZE_CODE(OFF) is specified, unless pragma OPTIMIZE_CODE(OFF) 
is also specified for the caller. 

pragma PACK_ 


This pragma causes the ctnnpiler to minimize gaps between components in the 
representation of cmnposite types. Objects larger than a single STORAGE.UNTT 
are packed to the nearest STORAGE.UNTT. Storage optimization generally 
results in less efficient manipulation of the packed data type. 


B-6 


ParalM Ada Oavatopmant SyMam Programmar'a Guida 





AppMKilx F Of tho Ada Languaga Rafaranea Manual 


Pragmas and Tfiair Effacts 


pragma PAGE __ 

This pragma is implemented as described in Appendix B of the Ada RM. The 
pragma is also recognized by the source code formatting tool, a.pr. 

pragma PASSIVE _ 

This pragma directs the compiler to optimize certain tasks into passive tasks. The 
pragma can be applied to a t^ or task type declared immediately within a library 
package specification or body. 

pragma PASSIVE has three forms: 

prag;ina PASSIVE; 

pragma PASSIVE(SEMAPHOR£): 

pragma PASSIVE(INTERRUPT, nnn)\ 

The statements in the task body may prevent the intended optimization. In such 
cases, a warning is generated at compile time and the exception 
TASKING_ERROR is raised at run time. 

For additional infmmation about pragma PASSIVE and passive tasks, see the 
section entitled “Passive Tasks” in Qiapter 2 of this manual. 

pragma PRIORITY _ 


This pragma is in^lemenmd as described in Appendix B of the Ada RM. The 
allowable range for pragma PRIORITY is 0.. 

pragma SHARE_CODE _ 

This pragma eiubles multiple instantiations of the same generic procedure or 
package body to share object code. A “parent” instantiation is created, and 
subsequent instantiations of the same types can share the parent’s object code, 
reducing program size and compilation times. 

pragma SHAR£_CODE takes the name of a generic unit or a generic 
instantiation as its first argument and either of the identifiers TRUE or FALSE as 
its seccMid argument. When the first argument is the name of a generic unit, the 
pragma applies to all instantiations of that generic. When the first argument is the 
name of a generic instantiation, the pragma applies only to the specified 
instantiation ot overloaded instantiations. 


Parallel Ada Davalopmant Syatam Programmar'a GuMa 


B-7 








Pragmas and Thair Effaets 


Appandix F of tha Ada Languaga Rafaranca Manual 


If the second argument is TRUE, the con^iler tries to share code generated for a 
generic instandadon with code generated for other instandadons of the same 
generic. When the second argument is FALSE, each instandadon gets a unique 
copy of the generated code. 

The pragma SHAR£_CODE is allowed only immediately at the place of a 
declaradve item in a declaradve pan or package specificadon or after a library unit 
in a compiladon but befcse any subsequent compiladon unit The extent to which 
code is shared by instandadons depends on this pragma and the kind of generic 
formal parameters declared for the generic unit 

You can subsdtute the nan^ pragma SHARE.BODY for the name pragma 
SHARE_CODE. 

pragma SHARED _ 

This pragma is recognized by the inqilementadon but has no effect in the current 
release. 


pragma STORAGE_UNiT _ 

This pragma is recognized by the implementadon but has no effect m the current 
release. PADS does not allow modificadon of package SYSTEM by means of 
pragmas. You can achieve the same effect by copying the file systenta in library 
standard to a local Ada library and recompiling it there with new values. 
(However, you should not redefine STORAGE.UNTT.) 

pragma SUPPRESS 


This pragma is in:q)lemented as described in Appendix B of the Ada RM, except 
that DIVISION^CHECK and, in some cases, OVERFLOW_CHECK cannot be 
suppressed. 

Using pragma SUPPR£SS(ALL_QiECKS) is equivalent to writing, at the same 
point in the program, a pragma SUPPRESS for each of the checks listed in Ada 
RM11.7. 

pragma SUPPRESS(EXCEPnON_TABLES) tells the code generator not to 
generate, for the enclosing compiladtm unit, the tables that are normally generated 
to identify exception regions. This reduces the size of the static data required for a 
unit but idso disables exception handling within that unit 


Parallel Ada Development System Programmer's Guide 






Appendix F of the Ada Language Reference Manual 


Predefined Packages and Generics 


pragma SYSTEM_NAME _ 

This pragma is recognized by the implementation but has no effect in the current 
release. PADS does not allow modification of package SYSTEM by means of 
pragmas. You can, however, achieve the same effect by cc^ying the file systenLa 
in library standard to a local Ada library and recompiling it there with new values. 


pragma VOLATILE _ 

This pragma, with its argument, object, guarantees that loads and stores to the 
named object are performed as expected after optimization. For example: 

memory_£lag : integer; 
pragma volatile (nieniory_eiag); 


PREDEFINED 

PACKAGES AND GENERICS 


The following predefined Ada packages, specified by Ada RM Appendix C(22), 
are provided in the library standard: 

• generic ftinction UNCHECKED_CONVERSION 

• generic padiage DIRECT.IO 

• generic package SEQUENTIAL.IO 

• generic procedure UNOiECKED.DEALLCX^ATION 

• package CALENDAR 

• package lO.EXCEPTIONS 

• package LOW_LEVELJO 

• package MACHINE.CODE 

• package STANDARD 

• paduge SYSTEM 

• package TEXT J O 


Parallel Ada Oevelopmant System Progr«nmer*s Guide 


B-9 






Predefined Packagee and Generics 


Appendix F of the Ada Language Reference Manual 


Specification of package SYSTEM 


with UNSl(aiED_TYPES; 
package SYSTEM is 

pragma SUPPRESS(ALL_CHECKS); 
pragma SUPPRESS (BXC^TION_TABLES) ; 
pragma NOT_EIiABORATED; 
type NAME is ( umaxv_88k ); 

SYSTEM_HAME : constant NAME uinaxv_88k; 

STORAGE_UNIT : constant 8; 

MEMORY SIZE : constant 16 777 216 


— System-Dependent Named Numbers 


MIM_INT 

MAX_INT 

MAX_D1G1TS 

MAX_MANTISSA 

FINE_DELTA 

tick" 


: constant -2_147_483_648; 
: constant 2_147_483_647; 

: constant :• 15 
: constant :» 31; 

: constant 2.0*»(-31); 

: constant 0.01; 


— Other System-Dependent Declarations 
subtype PRIORITY is INTEGER range 0 .. 99; 

MAX_REC_SIZE : integer 64*1024; 
type ADDRESS is private; 

fvinction ">" {A; ADDRESS; B: ADDRESS) return BOOLEAN; 

function "<" (A; ADDRESS; B: ADDRESS) return BOOLEAN; 

function "X-"(A: ADDRESS; B; ADDRESS) return BOOI.EAN; 

function (A: ADDRESS; B: ADDRESS) return BOOLEAN; 

function (A: ADDRESS; B: ADDRESS) return INTEGER; 

function "+" (A: ADDRESS; 1: INTEGER) return ADDRESS; 

function (A: ADDRESS; I; INTEGER) return ADDRESS; 

function "+" (I: UNSIGNED_TYPES.UNSIGNED_INTEGER) return 
ADDRESS; ~ 

function MEMORY_ADDRESS 

(I; UNSIGNED_TYPES.UNSIGNED_INTEGER) return ADDRESS 
renames "+"; 


NO_ADDR : constant ADDRESS; 
type TASK_ID is private; 

NO_TASK_ID : constant TASK_ID; 
type PROGRAM_ID is private; 

NO_PROGRAM_ID : constant PROGRAM_ID; 

type SIG_STATUS_T is array(1..64) of boolean; 

pragma PACK < S 1G_STATUS__T) ; 

SIG_STATUS_S1ZE: CONSTANT 8; 
private 

type ADDRESS is new UNSI(24ED_TYPES.UNSIGNED_INTEGER; 

NO_ADDR ; constant ADDRESS 0; 

pragma BUILT__IN(">") ; 

pragma BU1LT__IN("<"); 

pragma BUILT^^IN ; 

pragma BUILT IN 


B-10 


Pirellei Ada Davalopmant Syatam Programmar's Gulda 







Appendix F of the Ada Language Reference Manual 


Predefined Packages and Generics 


pragma ; 

pragma BUILT_IN(“+"); 
end SYSTEM; 

package CALENDAR _ 

package CALENDAR operates as specified in Ada RM 9.6. It uses the clock 
function in package CALJENDARXOCAL_TIME (located in the file 
calendar_SLa). which uses the operating system service routines 
GETTIMEOFDAY and L(X^.ALTIME to get the current time. 

package MACHINE_CODE _ 

package MACHINE.CODE provides an assembly language interface for the 
target machine, including the necessary record types needed in the code 
statement (see Ada RM 13.8), an enumeration type containing all the opcode 
mnemonics, a set of register definitions, and a set of addressing mode Actions. 
Also supplied (for use only in units that with MACHINE.CODE) are pragma 
IMPLICn'^CODE and the attribute ’REF. For the specification of the package, 
sec the section entitled “package MACHINE_CODE’’ in Chapter 3. 

Machine code statements take operands of type OPERAND, a private type that 
forms the basis of all machine code address formats for the target 

The general syntax of a machine code sutement is 

CODE_n'(opcode, operand [, operand ]); 

where n indicates the number of operands in the aggregate. 

In the following example, CODE_3 is a record ‘format’ whose first argument is an 
enumeration value of type OPCODE followed by three operands of type 
OPERAND: 

CODE_3'(add, rlO, rll, b'ref) ; 

For those opcodes requiring no operands, you must use named notation (see Ada 
RM 4.3(4)): 

CODE_0’(o/7 »> opcode); 

opcode must specify an enumeration literal (that is, it cannot specify an object, an 
attribute, or a rename), operand can specify only an entity de^ed in 
MACHINE_CODE or the ’REF attribute. 

The ’REF attribute denotes the effective address of the first storage unit allocated 
to the object ’REF is not supported for a package, task unit or entry. For details, 
see the section entitled “’R^’ later in tins appendix. 


Paraliei Ada Oavalopinant System Programmar's Guide 


B-11 





Predefin0ci Packages and Generics 


Appendix F of the Ada Language Reference Manual 


Arguments to any of the functions defined in MACHINE_CODE must be static 
expressions, string literals, or the functions defined in MACHINF_CODE. 

As an example of machine code insertions, the procedure OS_EXTEND requests 
the operating system to extend the program stack space to a new address: 

procedure os_e3ctend (new_top : in system.address) is 
— Extend the stack according to BCS Chapter 5 
pragma in 9 licit_code(off) 
use machine_code; 
begin 

oode_3'(add, rlO, r31, rO); — Save sp 

code_3'(add, r31, r2, rO); — Set sp to new limit 

code_2'(st, rO, r31+0); — Access it; this extends the stack 

code_3'(add, r31, rlO, rO)); — Restore sp 
code_l' (jmp, rl) ; 
end os extend; 


package SEQUENTIALJO 


Sequential I/O is currendy implemented for variant records, with one restriction: 
The maximum size possible for the record is always written. The same is true for 
direct I/O. For unconstrained records and arrays, the constant 
SYSTEM.MAX_REC_ST7F. can be set prior to the elaboration of the generic 
instantiation of SEQUENTIALJO or DIRECTJO. For example, if unconstrained 
strings arc written, SYSTEMMAX_REC_SIZE effectively restricts the maximum 
size of strings. If you know the maximum size of such strings, you can set the 
SYSTEMMAX_REC_SI7P. prior to instantiating SEQL’ENTIALJO for the 
string type. You can reset this variable after the instantiation with no effect 

package UNSiGNED_TYPES 


The package UNSIGNED_TYPES illustrates the definition of and services for 
the unsigned types supplied in this version of PADS. Use this package at your 
own risk. We do not warrant its effectiveness or legality, either expressly or by 
implicadon. 

We plan to withdraw this implementation of UNSIGNED_TYPES if and when the 
Ada Joint Program Office and the Ada community reach agreement on a practical 
specification of unsigned types. We will then standardize our implementation 
based on that accepted version at the earliest practical date. 

The package is supplied in comment form because the actual package cannot be 
expressed in nonnal Ada - the types are not symmetric about 0, as is required by 
the Ada RM This package is supplied and is accessible through the Ada WTIHn 
statement, as if it were pn:sent in source form. 


B-12 


ParalM Ada Dtveiopmant Syatam Programmar't Gkilde 







r 


Appendix F of the Ada Language Reference Manual Predefined Packages and Generics 

Example: 

with winslgned_typas; 

procedure foot xxx: un3igned_types.unsigned_integer) is ... 

Note: Use package UNSIGNED_TYPES at your own risk. 

Specification of package UNSIGNED.TYPES _ 

— package unsigned_types is 

— type unsigned_integer is range 0 .. (2**32 - 1); — 0.. 4294967295 
—function (a, b: unsigned_integer', return boolean; 

—function "/-"{a, b; un3igned_integer) return boolean; 

— function "<" (a, b; unsigned_integer) return boolean; 

—function "<-"{a, b: un3igned_integer) return boolean; 

—function ">" (a, b: tinsigned_integer) return boolean; 

—function (a, b: unsigned_int6ger) return boolean; 

—function "+" (a, b: unsigned_lnteger) return unsigned_integer; 

—function (a, b: unsigned_integer) return unsigned_integer; 

—function "+" (a : unsigned_integer) return un3igned_integer; 

—function (a : un3igned_integer) return unsigned_integer; 

—function "*" (a, b: unsigned_integer) return unsigned_integer; 

—function "/" (a, b: unsigned_integer) return unsigned_integ6r; 

—function "mod" (a, b; unsigned__integer) return un3igned_integer; 
—function "rem"(a, b; unsigned^integer) return unsigned_integer; 

—function "*** (a, b: unsigned__integer) return unsigned_integer; 
—function "adja"(a, b: unsigned___integer) return un3igned_integer; 

— type unsigned_3hort_integer is range 0 .. (2**16 - 1) ;— 0..65535 
—function (a, b; unsigned_3hort_integer) return boolean; 

—fxinction "/-"(a, b: unsigned_3hort_integer) return boolean; 

—function "<" (a, b; un3igned_3hDrt_integer) return boolean; 

—function (a, b; unsigned_short_integer) return boolean; 

—function ">" (a, b: unsigned_short_integer) return boolean; 

—function ">-"(a, b: unsigned_3hort_integer) return boolean; 

—ftinction "+" (a, b: unsigned_short_integer) 

— return unsigned_short_integer; 

—function (a, b: unsigned_short_integer) 

— return un3igned_3hort_intBger; 

—function "+" (a : unsigned_3hort_integer) 

— return unsigned_short_integer; 

—function (a : unsigned_short_integer) 

— return unaigned_,short_integer; 

—function "*" (a, b; unsigned_short_integer) 

— return unsigned_short_integar; 

—function "/" (a, b: un3igned_short_integer) 

— return unsigned_,short_integer; 

—function "mod"(a, b; unsigned_short_integer) 

— return un3igned_short_integer; 

—function "tem"(a, b; unsigned_3hort_integer) 

— return unsigned_short_integer; 

—function "**" (a, b: unsigned_ 3 hott_integer) 


Panillsi Ada Oavslopmsm Systam Progiwnmsr's Gulds 


B-13 




linpleinentatton*Deflned Attributes Appendix F of the Ada Language Reference Manual 

— return unsigned_short_integer; 

—function "abs"(a, b: un3igned_3hort_integer) 

— return un3igned_3hort_integer; 

— type un 3 igned_tiny_integer is range 0 .. (2**8 - 1); — 0..255 
—function "-*• (a, b: un 3 igned_tiny_integer) return boolean; 

—function "/-"<a, b: un 3 igned_tiny_integer) return boolean; 

—function "<" (a, b: un 3 igned_tiny_integer) return boolean; 

—function (a, b: un3igned_tiny_integer) return boolean; 

—function ">" (a, b: un 3 igned_tiny_integer) return boolean; 

—fimction (a, b: un3igned_tiny_integer) return boolean; 

—function "+" (a, b: unsigned_tiny_integer) 

— return unsigned_tiny_integer; 

—function (a, b: unsigned_tiny_integer) 

— return unsigned_tiny_integer; 

—function "+" (a : un3igned_tiny_integer) 

— return unsigned_tiny_integer; 

—function (a : unsigned_tiny_integer) 

— return un3igned_tiny_integer; 

—function (a, b: un3igned_tiny_integer) 

— return un3igned_tiny_integer; 

—function "/" (a, b: unsigned_tiny_integer) 

— return un3igned_tiny_integer; 

—function "mod"(a, b: un3igned_tiny_integer) 

— return unsigned_tiny_integer; 

—function "rem" (a, b: unsigned__tiny_integer) 

— return un 3 igned_tiny_integer; 

—function "**" (a, b: unsigned_tiny_integer) 

— return un 3 igned_tiny_integer; 

—function "abs" (a, b: un3igned__tiny_integer) 

— return unsigned_tiny_integer; 

— end un3igned_type3; 


= IMPLEMENTATION-DEFINED 

inr ATTRIBUTES _ 

This section describes the attributes defined by PADS. 

TASKJD __ 

For a task- object or a value T, T’TASK_ID yields the unique task ID associated 
with the task. The value of this attribute is of the type SYSTEM.TASK_ID. 

-=:r *REF __ 

The ’REF attribute denotes the effective address of the first of the storage units 
allocated to the object ’REF is not supported for a package, task unit or entry. 
This attribute has two forms: X’REF and S YSTEM. ADDRESS’REF(N). X’REF, 


B-14 


Parallel Ada Development System Programmer’s Guide 










Appendix P of the Ada Language Reference Manual 


Implementatlon-Oefined Attributes 


used only in machine code procedures, designates an operand within a code 
statement. SYSTEM>ADD]^SS’REF(N) can be used anywhere to convert an 
integer expression to an address. 

X*REF 

This attribute generates a reference to the entity to which it is applied. 

In X’REF, X must be either a constant, variable, procedure, function, or label. The 
attribute returns a value of the type MACHINE_CODE. OPERAND and can only 
be used to designate an operand within a code statement 

The instruction generated by the code statement in which the attribute occurs can 
be preceded by additional instructions needed to facilitate the reference (for 
example, loading a base register). If the declarative section of the procedure 
contains pragma IMPLICIT_CODE (OFF) and additional code is required, a 
warning is generated. 

References may also cause the generation of run-time checks. You can use 
pragma SUPPRESS to eliminate these checks. 

Example: 

C0DE_1MBSR, PROC'REF); 

C0DE~2Mlcl, rll, X.ALLfZ)'REF) ; 

For further information, see the section entitled "Ada Entities as Operands" in 
Chapter 3 of this manual. 

SYSTEM.ADDRESS*REFfN) 

In SYSTEM.ADDRESS’REF(N), SYSTEM.ADDRESS must be the type 
SYSTEM.ADDRESS; N must be an expression of type 
UNTVERSAL.INTEGER. The attribute returns a value of type 
SYSTEM.ADDRESS, which represents the address designat^ by N. 

The effect of this attribute is similar to the effect of an unchecked conversion from 
integer to address. You should, however, use SYSTEM.ADDRESS’REF(N) in 
the following circumstances (and in these circumstances, N must be static); 

• Within any of the run-time configuration packages. Use of 
UNCHECKED_CONVERSION within an address clause would require the 
generation of elaboration code, and the configuration packages are not 
elaborated. 

• In any instance where N is greater than INTEGER’LAST. Such values are 
required in address clauses that reference the upper portion of memory. 
UNCHECKED.CONVERSION in these instances would require that the 
expression be specified as a negative integer. 


ParaMI Ada Otvolopmam System Programmer's Guide 


B-15 






Restrictions on Main Programs 


Appendix F of the Ada Language Reference Manual 


• To place an object at an address. The integer_yalue in the following example is 
converted to an address for use in the address representation clause. The form 
avoids UNCHECKED_CONVERSION and is also useful for 32-bit unsigned 
addresses: 

—place an object at an address 

for object use at ADDRESS'REF (integer_value) 

—to use unsigned addresses 

for VECTOR use at SYSTEM.ADDRESS'REF(16#808000d0#); 

TOP OF MEMORY : SYSTEM. ADDRESS SYSTEMADDRESS'REF (16#FFFFFFFF#); 


RESTRICTIONS ON MAIN PROGRAMS 


In PADS, a main program must be a nongencric subprogram that is either a 
procedure or a function returning an Ada STANDARD.INTEGER (the predefined 
type). A main program may be neither a generic subprogram nor an instantiation 
of a generic subprogram. 


GENERIC DECLARATIONS 


In PADS, a generic declaration and the corresponding body need not be part of the 
same compilation, nor must they exist in the same Ada library. If a single 
compilation contains two versions of the same unit, an error is generated. 


SHARED OBJECT CODE 
FOR GENERIC SUBPROGRAMS 


The PADS compiler generates code for a generic instantiation that can be shared 
by other instantiations of the same generic, thus reducing the size of the 
generated code and increasing compilation speed. 



Shared code instantiaticms do entail some overhead because the generic actual 
parameten must be accessed indirectly and, in the case of a generic package 
instantuuion, declarations in the package must also be accessed indirectly. In 
addition, unshared instantiations permit greater optimization because exact acmal 
are known. You must therefore determine whether space or time is 
in a specific application. 


some cases. If the generic has a formal private type 
to accommodate an instantiation with an arbitrary 
inefficienL 


; ^SMn Programmer's GhMs 






Appendix F of the Ada Language Reference Manual 


Shared Object Code 


pragma SHARE_CODE lets you control whether an instantiation generates 
unique code or shares code with other similar instantiations. 

This pragma is allowed only in the following places: immediately within a 
declaradve part, immediately within a package specification, or after a library unit 
in a compil^on but before any subsequent compilation unit pragma 
SHARE_CX)DE takes the following form: 

pragma SHARE_CODE (generic, booleanjiterat) 

You can apply pragma SHARE.CODE to a generic declaradon or to individual 
instandadons. l^en pragma SHARE.CODE references a generic unit, it sets 
sharing on or off for all instandadons of that generic unless overridden by specific 
SHARE.CODE pragmas for individual instandadons. When it references an 
instantiated uiut, pragma SHARE.CODE sets sharing on or off for that unit 
alone. The default is to share ail generics that can be shared unless the unit uses 
pragma INLINE. 

The compiler shares code by default if the generic formal type parameters are 
restricted to integer, enumeradon, or floating-point To override the default use 
the pragma SHARE_CODE(/tame, FALSE). If there are formal subprogram 
parameters, instandadons are not shared unless you specify pragma 
SHARE.CX)DE(/uime, TRUE). 

Generics are shared by default if a parent is visible, except in the following cases: 

• When generic formal types other than integer, enumeradon, 
SYSTEM.ADDRESS or floating-point are used 

• When pragma INLINE is applied to a generic subprogram or instandadon or to 
a subprogram visible at the library level within a generic package or 
instandadon 

• When the representadons of the actual type parameters are not the same for 
each of the instandadons 

• When the generic has a formal in out parameter and the subtype of the 
corresponding actual is not the same as the subtype of the formal parameter 

Note that a parent instandadon (the instandadon that creates the shareable 
body) is independent of any individual instandadon. Therefore, reinstandadon of a 
genaic with different parameters has no effect on other compiladons that 
reference it The uiut that caused compiladon of a parent instandadon need not be 
referenced in any way by subsequent uiuts that stun the parent instandadon. 

The uiut SHARED_IO in the library standard instantiates all Ada I/O generic 
packages ftv the most commonly u^ base types. Thus, any instandadon of an 
Ada I/O generic package shares one of the parent instandadon generic bodies 
unless the following pragma is specified: 

pragma SHARE_COOB ( generic, FALSE ); 


Parantl Ada Oavalopmant Syttam Programmar't QuMa 


B-17 




Representation Clauses 


Appendix F of the Ada Language Reference Manual 


REPRESENTATION CLAUSES 


This section describes the PADS implementation of representation clauses. 

Representation Clauses_ 


PADS supports bit-level representation clauses. 

Representation Pragmas_ 


The language-defined pragma PACK is the only representation pragma supponed 
by PADS. 

Length Clauses_ 


PADS supports all length clauses. 

Enumeration Representation Clauses 


PADS supports enumeration representation clauses. 

Record Representation Clauses 


Representation clauses are based on the target machine’s word, byte, and bit 
order numbering, so that VADS compilers are consistent with machine 
architecture manuals for both ‘big-endian’ and ‘little-endian’ machines. Bits 
within a STORAGE_lJNIT are also numbered according to the target machine 
manuals. You need not understand the default layout for rectnds and other 
aggregates, since the use of record representation clauses gives you fine control 
over the layout You can align record fields correctly with structures and other 
aggregate types from other languages by specifying the location of each element 
explicitly. On the MC88100, PADS operates in the big-endian type ordering 
configuration. 


B-18 


Parallel Ada Davtiopmant Syatam Progranunar’a Gulda 








Appendix F of the Ada Language Reference Manual Representation Clauses 


Figure B-1 illustrates MC88100 addressing and bit numbering. 



no-oiouii rm Qxosuiio 

Rgure B<1: MC88100 Addressing and Bit Numbering 

The only restrictions on record representation clauses are the following; 

• If a component does not start and end on a storage unit (byte) boundary, it must 
be stored within 4 consecutive bytes. 

• A component that is itself a record must occupy a power of 2 bits. Components 
that are of a discrete type or packed array can occupy an arbitrary number of 
bits, subject to the preceding restriction. 


Paratlai Ada Oavaiopmant Systam Programmar'a Guida 


B-19 






R«prMMntation ClausM 


Appsndix F of the Ada Language Reference Manual 


Address Clauses 


PADS supports address clauses for objects and entries. 

Note; Use with caution code that references mcmoty-inappcd dc'.'ices 
using a for use at clause to locate an object at the I/O address. 

The default opdmization of the compiler eliminates redundant 
moves to and from memory. If this causes problems, compile with 
pragma OPTIMIZE_CODE(OFF). 


Interrupt Entries 

PADS allows task entries to be associated with operating system signals. The 
operating system handles all inttmipts and faults initially and then returns control 
to the user program as a signal. 


The available signals are described in UMAX V Programmers Guide. Due to 
restrictions in the operating system, some of the signals cannot be caught. 
Although an attempt to assign an entry to these signals does not result in an 
error, the operating system will not deliver the signal to the piogram. 

The Ada run-time system discourages attempts to catch the timer-related 
signals. 


The following example program shows you how to attach to the CTRL-c or 
intemipt-from-keyboard signal: 

with iface_intr; 

with system; use system; 

*.Ith text_io; 
t ^sk interrupt is 
entry SIGINT; 

for SIGINT use at address'ref(iface_intr.sigint); — interrupt 

end; 

task body interrupt is 
begin 
loop 

accept SIGINT do 

text_io.put_line("SIGINT"); 
end; 

end loop; 
end; 


Signal handlers are set up for the following signals by the PADS run-time system: 


tdefine 

fdefine 

tdefine 

tdefine 


SIGFPE 

8 

/* 

floating point exception */ 

SIGSEGV 

11 

/* 

segmentation violation */ 

SIGTRAF 

5 

/* 

trace trap */ 

SIGALRH 

14 

/• 

alarm clocks */ 


B-20 


Parallel Ada Development Syatem Programmer'a Guide 





Appendix F of the Ada Language RefM«nce Manual 


Representation Clauses 


If a task entry is attached to SIGFPE, NUMERIC_£RROR exceptions are not 
raised correctly. If a task entry is attached to SIGSEGV, STORAGE_ERROR 
exceptions may not be raised correctly. If a task entry is attacked to SIGALRM, 
delay statements and time slicing do not work correctly. 

Use of signal handlers is complicated when non-Ada routines are involved. For 
further information, see Chapter 4 of this manual. 

Change of Representation_ 


PADS supports change of representadon. 

The package SYSTEM_ 


For the specifiicadon of package SYSTEM, see the section entitled “Predefined 
Packages and Generics” earlier in this ^ipendix. The specification is also 
available on line in the file systems in the release libr^ standard. The 
pragmas SYSTEM.NAME, STORAGE.UNTT, and MEMORY_SIZE are 
recognized by the implementation but have no effect. PADS does not allow 
SYSTEM to be modified by means of pragmas. However, you can achieve the 
same effect by recompiling package SYSTEM with altered values. Note that 
such recompilation causes other units in the library standard to become out of 
date. Consequendy, you should recompile SYST]^ in some library other than 
standard. 

Representation Attributes_ 


PADS supports the ’ADDRESS attribute for the following entities: 

• Variables 

• Constants 

• Procedures 

• Functions 

If the prefix of an ’ADDRESS attribute is an object that is not aligned on a 
storage unit boundary, the attribute yields the address of the storage unit 
containing the first bit of the object This is consistent with the definition of the 
’FIRST_Bn' attribute. 

All other Ada representation attributes are fully supported. 


PaniM Ada Otvaiopmam Systam Programmafa Gukfa 


B-21 







Paramtter Passing 


Appendix F of the Ada Language Reference Manual 


Representation Attributes of Real Types 

PADS supports these attributes. See the section entitled “Predefined Packages 
and Generics” earlier in this appendix. 

Machine Code Insertions 


PADS supports machine code insertions. See Chapter 3 of this manual for de rail*: 

interface to Other Languages_ 


PADS supports interface to other languages. See Chapter 4 of this manual and the 
section entitled “Pragmas and Their Effects” earlier in this appendix for details. 


Unchecked Programming 


PADS provides both UNCHECKED_DEALLOCATION and 
UNCHECKED.CONVERSION. 

Unchecked Storage Deallocations 

Any object that is allocated can be deallocated. No checks are currently performed 
on released objects. However, when an object is deallocated, its access variable 
is set to null. Subsequent deallocations using the null access variable are ignored. 


Unchecked Type Conversions 

The predefined generic ftinction UNCHECKED_CONVERSION cannot be 
instantiated with a target tjrpe that is an unconstrained array type or an 
unconstrained record type with discriminants. 


PARAMETER PASSING 


Parameters are passed in registers or by pushing values (or addresses) on the 
stack. Extra information is passed ftv records (’CONSTRAINED) and for arrays 
(dope vector address). 

Registers r2 through :9 are used to pass parameters. Parameters of 64-bit 
floating-point type are passed in a register pair. Other parameters of scalar type, 
access type, or the type SYSTEM.ADDRESS are passed in a single register. If 
all parameter registers have been used, a parameter is transmitted in storage by 
pushing its value on the stack. 


B-22 


ParelM Ada Davtiopmant Syatam Programmar'a Gulda 









Appendix F of the Ada Language Reference Manual 


Parameter Passing 


Likewise, a function result of scalar type, access type, or the type 

SYSTEM.ADDRESS is returned in register r2 or in the pair r2, r3, as appropriate. 

Small results are returned in registers; large results with known targets are 
passed by reference. Large results of anonymous target and known size are 
passed by reference to a temporary created in the caller. Large results of 
anonymous target and urtknown size are returned by copying the value down from 
a temporary created by the callee so that the space used by the temporary can be 
reclaimed. 

The compiler assumes the following calling conventions, defined in Object 
Compatibility Standard (OCS): 

1. Caller copies first 8 argument words into r2-r9. 

2. Caller pushes additional arguments on stack. 

3. Caller calls callee. 

4. Callee builds display and allocates space for local variables. 

5. Callee stores any registers it modifies in the set rl4.. r2S. 

6. Callee executes. 

7. Callee restores registers saved in Step 5. 

8. If callee is a function, callee leaves result in r2 (or in the pair r2, r3 for a 64-bit 
floating-point result). 

9. Callee deallocates local storage. 

10. Callee returns to caller. 

11. Caller copies back any out parameters or function values. 

12. Caller deallocates the space used for arguments on the stack. 

Note; Compilers for other languages may follow calling conventions other than 
those expected by PADS. Use the debugger, a.db, to verify that the call 
interface is the expected one. 

When calling C routines (defined with pragma INTERFACE (C, 
Adajubprogram)), the caller allocates stack space far each parameter passed in a 
register in accoixiance with the 88open Consortium Ltd. Object Compatibility 
Standard (OCS). 

When compiler conventions are not compatible, or when interfacing to assembly 
language, you can build a call interface explicitly using machine code insertions. 
For further information, see Chapter 3 of this manual. 


ParaiM Ada OavMopmant S^tam Programmar'a Guida 


B-23 





Conversion and Deallocation 


Appendix F of the Ada Language Reference Manual 


CONVERSION AND DEALLOCATION 


The predefined generic fiuiction UNCHECKED_CONVERSION cannot be 
instantiated with a target type that is an unconstrained array type or an 
unconstrained record type with discriminants. 

There are no restrictions on the types with which generic function 
UNCHECKED_DEALLOCATION can be instantiated. No checks are performed 
on released objects. 


PROCESS STACK SIZE 


The stack limi t for the main program is set in the CONFIGURATION_TABLE 
structure in the package V_USR_CONF. The default value is 

MAIN_TASK_STACK_SIZE => 256000 

The stack limit for tasks is also set in the configuration table. Its default value is 
DEFAULT_TSK_STACK_SIZE => 10_240 

For information on how to modify these values for your program, see Appendix C 
of the Parallel Ada Development System User’s Guide. 


TYPES, RANGES, AND ATTRIBUTES 

This section describes the PADS implemenution of the following types: 

• Numeric literals 

• Enumeration types 

• Discrete types 

• The type STRING 

• Integer types 

• Floating-point types 

• Fixed-point types 

• Array types 


B>24 


Parallal Ada Oevelopmant Systam Programmar's Guide 








Appendix F of the Ada Language Reference Manual 


Types, Ranges, and Attributes 


Numeric Literals 


PADS uses unlimited precision arithmetic for computations with numeric literals. 

Enumeration Types__ 


PADS allows an unlimited number of literals within an enumeration type. 

Attributes of Discrete Types_ 


PADS defines the image of a character that is not a graphic character as the 
corresponding 2- or 3-character identifier from package ASCII of Ada RM, 
Appendix C. The identifier is in upper case without enclosing apostrophes. For 
example, the image for a carriage return is the 2-character sequence CR 
(ASCILCR). 

The type STRING_ 


Except for memory size, PADS places no specific limit on the length of the 
predefined type STRING. Any type derived from the type STRING is sinularly 
unlimited. 

By default, strings are represented with a single character in each byte of memory. 
Thus, storage for string objects is automatically minimized. 

Integer Types_ 


Table B-1 summarizes the attributes of the predefined integer types. 

Table B-l: Attributes of Integer Types 


Name of 
Attribute 

AttributeVaJue 
of INTEGER 

AttributeVaJue of 
SHORT_INTEGER 

AttributeValue of 
TINY_INTEGER 

SIZE 

32 

16 

8 

FIRST 

-2,147_483_648 

-32,768 

-128 

LAST 

2_147_483_647 

32,767 

127 


B-25 


Parallel Ada Development System Programmer's Guide 











Types, Ranges, and Attributes 


Appendix F of the Ada Language Reference Manual 


Operation of Floating-Point Types 


Table B-2 summarizes the attributes of PADS floating-point types. 

Table B-2: Attributes of Floating-Point Types 


Name of 

Attribute 

Attribute Value 
of FLOAT 

Attribute Value 
ofSHORT_FLOAT 

SIZE 

64 

32 

FIRST 

-1.79769313486232E+308 

-3.40282E+38 

LAST 

1.79769313486232E+308 

3.40282E+38 

DIGITS 

15 

6 

MANTISSA 

51 

21 

EPSILON 

8.88178419700125E-16 

9.536743 l<)406250E-07 

EMAX 

204 

84 

SMALL 

1.94469227433161E-62 

2.5849394142282 lE-26 

LARGE 

2.57110087081438E+61 

1.934280389O4620E+25 

SAFE.EMAX 

1021 

125 

SAFE.SMALL 

2Z2507385850720E-308 

L17549435082229E-38 

SAFE_LARGE 

2.24711641857789E+307 

4.25352755827077E+37 

MACWINE.RADIX 

2 

2 

MAC3nNE_MANTISSA 

53 

24 

MACHINE.EMAX 

1024 

128 

MACHINE.EMIN 

-1021 

-125 

MACHINE_ROUNDS 

TRUE 

TRUE 

MACHINE.OVERFLOWS 

TRUE 

TRUE 


Fixed-Point Types _ 

PADS provides fixed-point types mapped to the supported integer sizes. 


B-26 


Parallel Ada Development System Programmer's Guide 












Appendix F of the Ada Language Reference Manual 


Input/Output 


Operation of Fixed-Point Types 


Table B-3 s ummarize s the attributes of the PADS fixed-point type DURATION. 

Tab!" B-3: Attributes of type DURATION 


Name of 

Attribute 

Attribute Value 
for DURATION 

SIZE 

32 

FIRST 

-2147483.648 

LAST 

2147483.647 

DELTA 

l.OE-03 

MANTISSA 

31 

SMALL 

l.OE-3 

LARGE 

2147483.647 

FORE 

8 

AFT 

3 

SAFE.SMALL 

l.OE-3 

SAFE_LARGE 

2147483.647 

MACHINE_ROUNDS 

TRUE 

MACHINE_OVERFLOWS 

TRUE 


Array Types _ 

PADS array bound limits are: 

INTEGER’FIRST: -2,147,483,648 
INTEGER’LAST: 2,147,483,647 

INPUT/OUTPUT 


The PADS I/O system is implemented using UMAX V operating system services. 
Both formatted and binary I/O are available. There are no restrictions on the types 
with which DIRECTJO and SEQUENTIAL .10 can be instantiated, except that 
the element size must be less than a maximum specified by the variable 
SYSTEM.MAX_REC_SIZE. Since you can set this variable to any value prior to 


Parallel Ada Development System Programmer's Guide 


B-27 












Input/Output 


Appendix F 3f the Ada Language Reference Manual 


the generic instantiation, you can use any element size. DIRECTJO can be 
instantiated with unconstrained types, but each element is padded out to the 
maximum possible for that type or to SYSTEMMAX_REC_SIZE, whichever is 
smaller. No checking, other than normal static Ada type checking, is done to 
ensure that values from riles are read into correctly si^ and typed objects. 

PADS rile and terminal input-output are identical in most respects, dMering only 
in the ricquency of buffer flushing. Output is buffered (buffer size is 1024 bytes). 
The buffer is always flushed after each write request if the destination is a 
terminal. The procure FILE_SUPPORT.ALWAYS_FHJSH (FILE_PTR) 
causes the buffer associated with FTLE_PTR to be flushed after all subsequent 
output requests. Refer to the source code for file_spprt_b.a in the standard 
library. Note that the limited private type FILE_T^E, defined in TEXTJO, is 
derived from the type FILE_PTR. Currently, you must convert between them 
using UNCHECK^.CONVERSION, because the derivation happens in the 
private part of the specification of TEXT_IO. For example, the following procedure 
stops buffering for standard ouq)ut: 

with text_io; 

with file_support; 

with unchecked_conversion; 

procedure dont_buffer(file: text_io.file_type) is 
function evt is new unchecJced_conversion ( 
source ■> text__io. file_type, 
target ■> file_support.filejptr); 

begin 

file_support.always_flush(evt(file)); 
end; 

Instantiations of DIRECTJO use the value MAX_REC_SIZE as the record size 
(expressed in STORAGE_UNrrs) when the size of ELEMENT_TYPE exceeds 
that value. For example, for unconstrained arrays such as a string, where 
ELEMENT_TYPE’SIZE is very large, MAX_REC_SIZE is used instead. 
MAX_REC_SIZE is defined in SYSTEM and can be changed before instantiating 
DIRECTJO to provide an upper limit on the record size. The maximum size 
supponed is 1024 * 1024 * STORAGE.UNTT bits. DIRECTJO raises 
USE_ERROR if MAX_REC_SIZE exceeds this absolute limit. 

Instantiations of SEQUENTIAL JO use the value MAX_REC_SIZE as the 
record size (expressed in STORAGE_UNTTs) when the size of 
ELEMENT_TYPE exceeds that value. For example, for unconstrained arrays 
such as a string, where ELEMENT.TYPE’SIZE is very large, MAX_REC_SIZE 
is used instead. MAX_REC_SIZE is defined in SYSTEM and can be changed by 
a program before instantiating SEQUENTIAL JO to provide an upper limit on the 
record size. SEQUENTIAL JO imposes no limit on MAX_REC_SIZE. 


B-28 


Parellal Ada Davalopmant Syttam Programmer’s Guide 





Appendix F of the Ada Language Reference Manual 


Input/Output 


Implementation-Defined Values 

of the Input/Output Packages _ 

The PADS-defined values in the input/output packages are as follows: 

• In package TEXTJO 

type COUNT is range O..INTEGER’LAST; 
subtype FIELD is INTEGER range 0..IN I'tGER’LAST; 

• In package DIRECT.IO 

type COUNT is range 0..2_147_483_647; 


Parallel Ada Development System Programmer's Quids 


B-29 




