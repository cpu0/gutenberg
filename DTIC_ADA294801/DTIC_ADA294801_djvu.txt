NAVAL POSTGRADUATE SCHOOL 
Monterey, California 



THESIS 


TOOLS FOR STORAGE AND RETRIEVAL 
OF ADA SOFTWARE COMPONENTS 
IN A SOFTWARE BASE 

by 

Christopher S. Eagle 
March 1995 

Thesis Co-Advisors: Man-Tak Shing 

Luqi 


Approved for public release; distribution is unlimited. 


DTIC ^ 



19950612 074 












REPORT DOCUMENTATION PAGE 


Form Approved 
0MB No. 0704-0188 


Public reporting turden for this collection of information is estimated to average 1 hour per response, including the time reviewing instructions, searching existing data sources 
gathering and maintaining the data needed, and axnprfetmg and reviewing the collection of infonnation. Send comments regarding this burden estimate or any other aspect of this 
c<^ectionof infonnation, including suggestions for reducing this burden to Washington Headquarters Services. Directorate for Information Operations and Reports, I21S Je^rson 
Davis Highway, Suite 1204, Arlington, VA 22202-4302, and to the Office of Management and Budget, Paperwork ReductionProject (0704-0188), Washington, DC 20503. 


1. AGENCY USE ONLY (Leave Blank) 


4. TITLE AND SUBTITLE 


3. REPORT TYPE AND DATES COVERED 

Master’s Thesis 


TOOLS FOR STORAGE AND RETRIEVAL OF ADA 
SOFTWARE COMPONENTS IN A SOFTWARE BASE 


6. AIJTHOR(S) 

Eagle, Christopher S. 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

Naval Postgraduate School 
Monterey, CA 93943-5000 



*. PERFORMING ORGANIZATION 
REPORT NUMBER 


9. SPONSORING/ MONITORING AGENCY NAME(S) AND ADDRESS(ES) 


10. SPONSORING/ MONITORING 
AGENCY REPORT NUMBER 


11. SUPPLEMENTARY NOTES 


The views expressed in this thesis are those of the author and do not reflect the official policy or 
position of the Department of Defense or the United States Government. 


12a. DISTRIBUTION / AVAILABIUTY STATEMENT 


12b. DISTRIBUTION CODE 


Approved for public release; distribution is unlimited. 


13. ABSTRACT (Maximum 200 words) 

One problem facing the Computer Aided Prototyping System (CAPS) project at the Naval 
Postgraduate School, is the lack of a large repository of existing reliable software components to draw 
upon for the creation of new prototype designs. Specifically, it is the lack of Prototype System 
Description Language (PSDL) specifications which describe Ada software components, that prevents 
Ada software components from being incorporated into the CAPS software base. Previously, PSDL 
specification had to be generated manually for each Ada software component being added into the 
software base. This process was time consuming and error prone. 

The primary goal of this thesis is to solve this problem by creating a tool which accepts an Ada 
Package Specification as input and automatically generates its corresponding Prototype System 
Description Language (PSDL) specification. The Ada package along with its PSDL specification may 
then be stored directly into the CAPS software base. 

The result of this thesis is a translator that examines each declaration contained in an Ada Package 
Specification and creates a corresponding PSDL specification. This tool allows the CAPS software base 
to be populated much faster utilizing existing DOD Ada software libraries such as the CAMP, ASSET, 
RAPID, and CRSS libraries. This tool has demonstrated its effectiveness by translating several complex 
components of the Common Ada Missile Packages into PSDL specifications. 


14. SUBJECT TERMS 

CAPS, PSDL, Software Reuse, Syntactic Matching, Component 


IS. NUMBER OF PAGES 


Retrieval, Ada Translation 


DTIC QUALm' mBPL-GTSD 3 


17. SECURU Y CLASSmCAllON 
OF REPORT 

Unclassified 


NSN 7540-01-280-5500 


1*. SECURll Y CLASSIFICATION 
OF THIS PAGE 

Unclassified 


19. SECURITY CLASSIFICATION 
OF ABSTRACT 


16. PRICE CODE 


20. LIMITATION OF ABSTRACT 


Unclassified 


Standard Form 298 (Rev. 2-89) 

Prescribed by ANSI Std. 239-18 






























11 





Approved for public release; distribution is unlimited 


TOOLS FOR STORAGE AND RETRIEVAL OF ADA 
SOFTWARE COMPONENTS IN A SOFTWARE BASE 


Christopher S. Eagle 
Lieutenant, United States Navy 
B.S.E., University Of Michigan, 1985 


Submitted in partial fulfillment of the 
requirements for the degree of 


Author; 


MASTER OF SCIENCE IN COMPUTER SCIENCE 


from the 


NAVAL POSTGRADUATE SCHOOL 
March 1995 



Accesion For \ 


NTIS CRA&I 15 

DTIC TAB C 

Unannounced C 

Justification 

1 

By 

Distribution / 

— 

Availability Cods 

s 


Avail and/or 
Dist Special 


M 


Approved By: 




Ted Lewis, CTiairm^ 
Department of Computer Science 


iii 













IV 





ABSTRACT 


One problem facing the Computer Aided Prototyping System (CAPS) project at the 
Naval Postgraduate School, is the lack of a large repository of existing reliable software 
components to draw upon for the creation of new prototype designs. Specifically, it is the 
lack of Prototype System Description Language (PSDL) specifications which describe Ada 
software components, that prevents Ada software components from being incorporated into 
the CAPS software base. Previously, PSDL specification had to be generated manually for 
each Ada software component being added into the software base. This process was time 
consuming and error prone. 

The primary goal of this thesis is to solve this problem by creating a tool which 
accepts an Ada Package Specification as input and automatically generates its 
corresponding Prototype System Description Language (PSDL) specification. The Ada 
package along with its PSDL specification may then be stored directly into the CAPS 
software base. 

The result of this thesis is a translator that examines each declaration contained in 
an Ada Package Specification and creates a corresponding PSDL specification. This tool 
allows the CAPS software base to be populated much faster utilizing existing DOD Ada 
software libraries such as the CAMP, ASSET, RAPID, and CRSS libraries. This tool has 
demonstrated its effectiveness by translating several complex components of the Common 
Ada Missile Packages into PSDL specifications. 






VI 





TABLE OF CONTENTS 


l. INTRODUCTION.I 

A. RAPID PROTOTYPING.I 

B. THE CAPS SYSTEM.I 

C. PROBLEM STATEMENT.4 

D. SCOPE.4 

E. ORGANIZATION OF THESIS.4 

n. SOFTWARE REUSE.7 

A. WHY REUSE?.7 

B. COMPONENT RETRIEVAL AND REUSE. 7 

1. Software Component Retrieval Methods.7 

2. Component Retrieval Within CAPS .9 

C. PROTOTYPE SYSTEM DESCRIPTION LANGUAGE.10 

m. MAPPING ADA 95 TO PSDL. 13 

A. INTRODUCTION.13 

B. THE MAPPING SUBSET OF ADA.13 

1. Basic Rules for Translations.14 

2. Productions Which do not Translate to PSDL.17 

3. Productions Which Translate to PSDL.17 

4. Generic Formal Parameters.18 

IV. THE ADA TO PSDL TRANSLATOR.21 

A. BACKGROUND.21 

B. THE SYNTHESIZER GENERATOR.21 

C THE TRANSLATOR.22 

1. SSL Source Files.22 

2. Accomplishing the Translation.23 

3. Assumptions for Proper Translations.23 

V. PSDL TYPE COMPONENT RETRIEVAL.29 






























A. BACKGROUND.29 

B. PSDL TYPE COMPONENTS.29 

C. MATCHING TYPE COMPONENTS.30 

D. DEFINITIONS.31 

1. PSDL Specification.31 

2. Software Base Component.31 

3. Query Component.31 

4. Component Signature.32 

E. SYNTACTIC MATCHING RULES FOR TYPE COMPONENTS.35 

1. Rules for Operator Components.35 

2. Rules for Type Components .36 

F. SEARCHING FOR TYPE COMPONENTS.37 

1. Operator Mapping.38 

2. Type Instantiation Check.39 

VI. CONCLUSIONS AND FUTURE RESEARCH.43 

A. CONCLUSIONS.43 

B. POPULATE THE CAPS SOFTWARE BASE.43 

C. EXTEND THE CAPABILITIES OF CURRENT COMPONENT 

RETRIEVAL TOOLS.43 

D. IMPLEMENT PSDL TYPE COMPONENT RETRIEVAL.44 

LIST OF REFERENCES.45 

APPENDIX A. SSL SOURCE CODE: ABSTRACT SYNTAX.47 

APPENDIX B. SSL SOURCE CODE: UNPARSING RULES.69 

APPENDIX C. SSL SOURCE CODE: ATTRIBUTE FUNCTIONS.103 

APPENDIX D. SSL SOURCE CODE: CONCRETE SYNTAX.117 

APPENDIX E. SSL SOURCE CODE: TRANSFORMATIONS.147 

APPENDIX F. INSTALLATION AND USE.159 

APPENDIX G. ADDING PROCEDURE WRAPPERS FOR ADA FUNCTIONS... 165 
INITIAL DISTRIBUTION LIST .169 


viii 































1. INTRODUCTION 


A. RAPID PROTOTYPING 

The classical approach to software development, the waterfall method, is a method 
in which a project moves forward one phase at a time [Ref. 1]. The phases consist of 
analysis, design, implementation, and testing. Each decision made in the analysis phase 
propagates through to the testing phase, and any problems encountered in the testing phase 
will require a return to the analysis phase to correct. 

Rapid prototyping provides an alternative method to the waterfall method. In rapid 
prototyping, a spiral rather than linear approach is followed, which allows various phases 
of development to proceed in parallel [Ref. 2]. A prototype is constructed quickly which is 
used to verify both the users requirements, and the designers interpretation of those 
requirements. A model for this method is shown in Figure 1 [Ref. 3]. 

One hinderance to the idea of rapid prototyping is the time required to complete the 
coding of a system. The concept of software reuse is one that can dramatically reduce the 
time spent on coding. Utilizing existing software components, prototype designers can 
rapidly construct systems with significant functionality rather than mere skeletons with 
large numbers of procedural stubs. These software components are stored and retrieved 
from a library of software components which is an integral part of the prototype designers 
tools. 

B. THE CAPS SYSTEM 

Computer aided prototyping of hard real-time systems is the goal of the Computer 
Aided Prototyping System (CAPS) project at the Naval Postgraduate School. CAPS 
provides tools which enable users to graphically specify a system, retrieve existing 
software components from a software base and integrate them to form the specified 


1 







prototype, perform timing analysis, and create a running prototype of a hard real-time 
system. Together these tools form the CAPS development environment shown in Figure 2. 



Figure 1. The CAPS Prototyping Process 


Timing analysis in the prototype is performed by the schedulers which examine the 
prototype specifications to produce a static schedule and a dynamic schedule. A static 
schedule is generated to fulfill the timing requirements of all time critical components in 
the system, and ensure that each of these components is scheduled as frequently and as long 
as they require. A dynamic schedule is created to allow those components which are not 
time critical to be incorporated into the processor schedule on a not to interfere basis with 
the time critical operators. In order to accomplish the required analysis, the timing 
requirements of each component in the prototype system must be properly specified. The 
Prototype System Description Language (PSDL) is a language which has been designed to 
accomplish exactly this [Ref. 4]. PSDL is a formal description language which provides a 
means to specify a variety of timing information for software components. Every software 
component which may be incorporated into a CAPS prototype must have a corresponding 


2 






PSDL description to define its characteristics. While there exists a large body of Ada 
software components which could potentially be utilized in the creation of systems, few if 
any of these components have had corresponding PSDL descriptions created for them. 
Before proper PSDL descriptions can be generated for existing Ada components, a 
thorough understanding of the mapping from Ada package specifications into PSDL 
specifications is required. As PSDL is not a language with which most Ada programmers 



are familiar, a major goal of this thesis has been to create a tool which will examine Ada 
package specifications and automatically generate corresponding PSDL descriptions for 
those specifications.The CAPS software base provides a database for these Ada 
components and their PSDL descriptions. The PSDL descriptions serve as the target keys 


3 






in searches of the software database. Because prototype systems are specified using PSDL, 
it becomes necessary to be able to compare one PSDL specification against another. All 
PSDL components are one of two types, a PSDL type component, or a PSDL operator 
component. Scott Dolgoff has described and implemented methods for search, retrieval, 
and integration of PSDL operator components from the software base into CAPS 
prototypes [Ref. 5]. A secondary objective of this thesis is to develop methods for searching 
and retrieving PSDL type components from the software base. The implementation of these 
methods is left for future research. 

C. PROBLEM STATEMENT 

CAPS has been the focus of research efforts for several years. Many different parts 
of CAPS have been implemented as the end product of Doctoral and Masters’ theses over 
the years, during different stages of the design effort, using system models with higher level 
of maturity as time passes. 

The focus of this thesis is to create a tool which allows software base administrators 
to more rapidly incorporate existing Ada software components into the software base. This 
is accomplished by automatically generating a PSDL specification, which accurately 
describes the Ada component, which will be stored along with the Ada component into the 
software base for later retrieval. 

D. SCOPE 

The scope of this thesis includes the development of the previously described tool 
which can operate both interactively and in a batch mode. Additionally, methods for the 
retrieval of PSDL type components from the software base are developed as a foundation 
for further research in the area of software retrieval. 

E. ORGANIZATION OF THESIS 

Chapter n discusses software reuse, and the role which PSDL plays in software 
reuse within CAPS. Chapter III describes the mapping of Ada package specifications into 
PSDL component specifications. Chapter IV discusses the design of a tool which 


4 







automatically translates Ada package specifications into corresponding PSDL component 
specifications. Chapter V describes methods for database search and retrieval of PSDL type 
components. Chapter VI presents conclusions. 


5 



6 





II. SOFTWARE REUSE 


A. WHY REUSE? 

In 1984 it was determined that “of all the code written in 1983, probably less than 
15% is unique, novel, and specific to individual applications. The remaining 85% appears 

to be common, generic and concerned with putting applications onto computers” [Ref 6], 
It is evident that by building large libraries of software components designed for reuse, time 
can be saved in the construction of future software systems. Additionally, reliability in final 
products is enhanced by the use of time tested components. Problems being faced today 
include the availability of large libraries of existing components, and the methods to 
retrieve and integrate these components into new software systems. The focus of this thesis 
is to provide a tool to automate the process of populating a library of software components, 
in this case the CAPS Software Base. 

B. COMPONENT RETRIEVAL AND REUSE 

In its simplest form, software reuse exists as a simple copy and paste operation in a 
programmers development environment. Programmers, familiar with their own previously 
written code, may reuse portions of that code when creating new systems. Two immediate 
benefits await that programmer, first, time is saved that would otherwise have been spent 
creating new code from scratch, and two, this recycled code has been debugged, and shown 
to be reliable within its original system. The goals of software reuse are to make this reuse 
effort pay off on a larger scale, rather than programmers reusing only their own code, it is 
desirable to have large libraries of tested and debugged components available to all 
members of an organization. 

1. Software Component Retrieval Methods 

The collection of software components into some form of component library itself 
is no problem, the problem lies in methods for retrieving components from such a library, 
and integrating those components into a new software system. Three primary methods for 


7 








retrieving software components exist: browsing, informal specifications, and formal 
specifications [Ref 7], Each of these methods is described below: 

a. Browsers 

Browsers simply provide their users a means to scan through a software 
library in search of something useful. A successful search conducted with a browser will 
rely heavily on the users ability to recognize a desirable component when it is displayed by 
the browser. Components within libraries served by browsers must utilize recognizable 
naming conventions or be thoroughly commented in order for users to identify and evaluate 
a component as having potential for reuse. A significant amount of time can be spent 
scanning through large software libraries, which may negate the time savings gained by 
utilizing any retrieved components. 

b. Inforntal Specifications 

Informal specifications are queries constructed by a user with the goal of 
searching a software library for matching components. This type of search may utilize 
keywords to describe component behavior, or classify components by functionality. 
Attributes such as type and numbers of parameters may also be specified in a query of this 
sort. Successful queries of this sort require users to utilize appropriate keywords in order to 
locate desirable components. For example a user who queries based on the keyword “list” 
may not be informed of components in the library named “queue.” The burden of 
evaluating components located in this manner remains entirely with the user. Users must 
still perform final evaluation of components retrieved in this manner in order to determine 
their usefulness. 

c. Formal Specifications 

Formal specification searches attempt to rigidly define a users requirements. 
This type of search can be the most automated of all searches, and therefore produces the 
most accurate and efficient results of the three methods mentioned. Searches may be 


8 





conducted to compare a library components syntactic similarity and semantic similarity 
against a formal specification provided by a user. In syntactic matching, numbers and types 
of parameters, are compared against components within the library to yield only those 
components which have signatures which match a users query. Semantic matching 
attempts to go one step further by examining behaviors identified by the user as desirable, 
against known behavior of library components. Components fully satisfying the constraints 
imposed by semantic matching are exactly those which can be integrated directly into the 
users new systems. [Ref 8] 

2. Component Retrieval Within CAPS 

There are currently three methods available for searching the CAPS software base 
for desirable components. These methods are browsing, keyword search, and PSDL query. 
[Ref 5] 

a. Browsing Within CAPS 

Browsing simply presents the user with a list of available type or operator 
components which may be further examined, and ultimately selected for inclusion in the 
users system, should they meet the users requirements. 

b. Keyword Search in CAPS 

PSDL permits the use of keywords ;vithin PSDL components as shown in 
Figure 3. These keywords are used as the basis of keyword searches within CAPS. The user 
is presented with a list of all keywords currently used by CAPS software base components. 
From this list, the user can select one or more keywords, and the search will yield all 
components containing those keywords. The user may then browse the resulting list to find 
a specific component which satisfies the users requirements. 

c. PSDL Query 

A PSDL query is a query by formal specification. In order to perform a 
PSDL query, the user must provide a PSDL specification as a query. That query is 


9 



compared against PSDL components stored in the CAPS software base, and only those 
components within the software base that satisfy the query are returned. Syntactic matching 
examines both numbers and types of parameters within the query component in search of 
a match within the software base. Syntactic matching has been described and implemented 

by John McDowell [Ref 9] and Scott Dolgoff [Ref 5]. 

OPERATOR Addition 
SPECIFICATION 
INPUT 

Opl : Integer, 

Op2 : Integer 
OUTPUT 

Result: Integer 
KEYWORDS 
addition, sum 

END 

Figure 3. PSDL Component with Keywords 

Semantic matching examines not only the external interface to a component, 

but the internal behavior of the component as well [Ref 7]. Internal behavior is evaluated 
by utilizing normalized algebraic expressions which describe the desired behavior in a 
query specification, and actual behavior of a software base component. These expressions 
are embedded in PSDL specifications in the form of OBJ3 conditional equations utilizing 
the axioms facility of PSDL 

C. PROTOTYPE SYSTEM DESCRIPTION LANGUAGE 

PSDL is a text-based language designed to express the specifications of real-time 
systems. It is based on a graphic model of vertices and edges, in which the vertices 
represent operators, or software process, and the edges represent the conceptual “flow” of 
data from one operator to another. Each vertex and edge may have associated timing 
constraint, and the vertices may have associated control constraints. 

Formally, the model used is that of an augmented graph. 


10 






G=(V, E, T(v), C(v)) 

where G is the graph, V is the set of vertices, E is the set of edges, T(v) represents the timing 
constraints for the vertices, and C(v) represents the control constraints for the vertices [Ref 
4]. 

Conceptually, PSDL operators may contain other operators to support the principle 
of abstraction. Effectively, the prototype may be expressed as a flat graph, or a one level 
graph containing all the atomic operators and their streams. An atomic operator is one that 
is implemented in a programming language, vice a composite operator consisting of other 
operators and streams. 

For example, the following diagram shows a PSDL prototype: 



Figure 4. Example of PSDL Graph 


This graph represents an operation modelled by the Operator X that accepts one 
item from Stream A, it performs some operation on the data, and outputs Stream B. The 
Maximum Execution Time (MET), this is the maximum possible time the operator may 
take to execute the task, defined as 600 milliseconds. 


11 







In this example, Operator X is decomposed as follows. 



Operator X is a composite operator, while Operator XI and Operator X2 are atomic 
operators, implemented in Ada or some other language. The timing and control constraints 
on these atomic operators must be consistent with those of their parent operator. In a single 
processor the combined METs of these atomic operators can not be greater than their 
parent. Operator X is really not needed to implement the prototype. It serves merely to 
abstract the functionality of its child operators. A more detailed description of the PSDL 

may be found in [Ref 4] and [Ref 3]. 


12 









III. MAPPING ADA 95 TO PSDL 


A. INTRODUCTION 

In order to perform the translation of Ada software into PSDL specifications, a well 
formulated set of rules is required which will accept all legal Ada programs, and provide 
an accurate translation in all cases. Past research within the CAPS project has provided the 
capability to perform Software Base queries based upon syntactic attributes of desired 
software components. This syntactic matching process serves as a front end filter for later 
semantic matching operations. The syntactic characteristics of an Ada package can be 
observed entirely within the package specification by examining the number of procedure 
declarations, and the number and type of arguments to those procedures. Semantic 
matching operations must focus on the actual behavior exhibited by component software 
packages. Behavioral characteristics can not be inferred from a package specification 
alone, and it becomes necessary to examine the package bodies of software components in 
order to provide effective semantic matching services. 

The work in this thesis provides additional capabilities for existing syntactic 
matching services in the CAPS environment. The focus of the translation effort is therefore 
limited to Ada package specifications. Future research will examine the possibilities of 
extending these methods to cover Ada package bodies. 

B. THE MAPPING SUBSET OF ADA 

The CAPS software base, and retrieval tools are set up in a way that requires Ada 
software components to be contained within an Ada package. For that reason, the starting 
point for the translation effort, which is the focus of this thesis, is the subset of the Ada 95 
language which is required to specify package specifications. This subset is expressed by 
the abstract syntax of Appendix A. Given this grammar subset, there are productions which 
have no translation to PSDL, productions which have some form of translation to PSDL, 
and productions which translate in a nearly one to one manner to PSDL. 


13 





1. Basic Rules for Translations 

The translator accepts Ada 95 package specifications and produces appropriate 
PSDL specifications which describe the given Ada component. The input Ada component 
must be a valid Ada 95 package specification free of syntax errors. The output of the 
translator will be a valid PSDL component. PSDL components are either data types or 
operators. A PSDL operator represents a single operation which may have inputs and 
outputs. A PSDL data type represents a state machine along with the associated operators 
to manipulate that state machine. 

Ada procedures translate rather straightforwardly into PSDL operators as shown in 
Figure 6. Ada packages which contain a single procedure declaration will translate into 


Ada 

procedure ExampleProc(p 1 : typel; p2 ; outtype2; p3 : in outtypeS); 

PSDL 

operator ExampleProc 
specification 
input 

pi typel, 
p3 : type3 
output 

p2 ; type2, 
p3 ;type3 
end 

implementation ada ExampleProc 
end 

Figure 6. Translation of an Ada Procedure 

PSDL operator components. The name of the PSDL operator component will be that of the 


14 






single procedure contained in the Ada package. For example, the Ada package of Figure 7 


package OneProc_pkg is 

DemoException : exception; 
procedure Procl(x : integer; y : in out float); 
end OneProc_pkg; 

Figure 7. Ada Package Containing a Single Procedure 


becomes the PSDL operator of Figure 8. Ada package specifications which contain either 


operator Prod 
specification 
input 

X: integer, 
y: float 
output 
y: float 
exceptions 

DemoException 

end 

implementation ada Prod 

end_ 

Figure 8. PSDL Translation of Single Procedure Package 


no procedure declarations or two or more such declarations will translate into PSDL type 
components. In this case, the package must contain a type declaration for an abstract data 
type upon which all of the procedures within the package operate. The name of the PSDL 
type component will be that of the abstract data type so defined. An example of a well 


15 












formed PSDL type component is shown as an Ada package specification in Figure 9 and in 


package Set_pkg is 
type Set is private; 

DemoException: exception; 

procedure Union(sl, s2 ; in Set; Result: out Set); 

SecondException: exception; 

procedure Size(s : in Set; result: out integer); 

private 

type Set is array(L.lO) of integer; 
end Set_pkg; 

Figure 9. Ada Package with Two Procedures 

Figure 10 as its corresponding PSDL specification. Current CAPS prototype generation 

type Set 

specification 
operator Union 
specification 
input 

si, s2: Set 
output 

Result: Set 
exceptions 

DemoException, SecondException 
end 

operator Size 
specification 
input 
s : Set 
output 

Result: integer 
exceptions 

DemoException, SecondException 
end 
end 

Figure 10. PSDL Translation of Two Procedure Package 

tools do not allow for the use of functions within Ada software components. Operations 


16 







which must return a value should be written as procedures with an additional out parameter 
which is used to pass the return value to the calling unit. Within an Ada package 
specification, each procedure will translate into a PSDL operator specification. 

2. Productions Which do not Translate to PSDL 

The following list represents Ada 95 productions which have no legitimate 
translation to PSDL: 

• Pragmas. 

• Object declarations. 

• Number declarations. 

• Type declarations. 

• Subtype declarations. 

• Task declarations. 

• Function declarations. 

• With and Use clauses. 

• Generic formal parameters which are packages. 

3. Productions Which Translate to PSDL 

The following Ada productions have some form of translation into PSDL: 

• Package declarations (including generics). 

• Procedure declarations (including generics). 

• Exception declarations. 

• Generic formal parameters (except packages). 

Packages translate as described previously. Ada procedures are translated to PSDL 
by listing the in and in out parameters of the procedure as inputs of the translated PSDL 
operator, and the out and in out parameters as outputs of the translated PSDL operator. All 
exceptions declared within a package are listed as PSDL exceptions of all translated PSDL 
operators. This approach to exceptions is a conservative approximation that includes all 
possible behaviors, as it is not possible by examining an Ada package specification to 
determine which declared exceptions will be raised by particular procedures. Restricting 


17 



exception declarations to only those operators which actually raise them would require 
analysis of Ada components to be extended to the package bodies as well. This requires a 
considerable amount of additional computational effort with relatively little gain in 
translational accuracy. 

4. Generic Formal Parameters 

Naming conventions were required in order to properly translate generic formal 
parameters in an Ada specification into generic formal parameters of a PSDL component. 
The translations for generic formal type parameters are shown in Figure 11. In order to 


Ada 

PSDL 

type tl is (<>); 

tl: DISCRETE_TYPE 

type t2 is RANGE <>; 

t2: RANGE_TYPE 

type t3 is MOD <>; 

t3 : MOD_TYPE 

type t4 is DELTA <>; 

t4: DELTA_TYPE 

type t5 is DELTA <> DIGITS <>; 

t5 ; DELTA_DIGIT_TYPE 

type t6 is DIGITS <>; 

t6: DIGITS.TYPE 

type t7 is PRIVATE; 

t7 ; PRIVATE.TYPE 


Figure 11. Translation of Generic Formal Parameters 


specify generic function and procedure parameters, it is necessary to utilize the array syntax 
of PSDL to specify the parameters, and the associated types of the Ada function and 
procedure parameters. The translation of an Ada generic formal function parameter is 
shown in Figure 12. PSDL array syntax is utilized to specify the formal parameters and the 

Ada: 

with function funcl(parml : integer; parm2 : float) return boolean is <>; 

PSDL: 

fund : function [ parml: integer, parm2 : float, return : boolean ] 

Figure 12. Translation of Generic Formal Function Parameter 


18 






return type of the parameter function. The return type is appended to the formal parameters 
of the function to make up the array components. The identifier return in the PSDL 
translation is guaranteed to be unique since it is a keyword in Ada, and no identifier in Ada 
may bear that name. It is not necessary to include information about the modes of the 
various parameters as they can be inferred from the fact that it is an Ada function being 
translated. All formal parameters are assumed to be in parameters, and the return parameter 
is assumed to be an out parameter. The translation of an Ada generic formal procedure 
parameter takes on a slightly different form. In the case of a procedure, it is necessary to 
encode the mode information for each formal parameter of the procedure. Again, the syntax 
for PSDL generic types is utilized. Nesting of PSDL generic instantiations is used to encode 
parameter mode information for each formal parameter. The identifiers in, out, and in_out 
are used to indicate the mode of a parameter. The identifier t is used as a placeholder, 
followed by the actual type of the formal parameter. This method maintains consistency of 
translation between Ada types and PSDL types, and allows for the proper translation of 
nested type definitions. The translation of an Ada generic formal procedure parameter is 
shown in Figure 13. 


Ada: 


with procedure prod (pi : integer; 

p2: out float; 

p3 : in out boolean) is <>; 

PSDL; 


prod : procedure [ 

parml: in [ t: integer ], 
parm2 : out [ t: float ], 
parm3 : in_out [ t: boolean ] ] 


Figure 13. Translation of Generic Formal Procedure Parameter 


19 












20 





IV. THE ADA TO PSDL TRANSLATOR 

A. BACKGROUND 

Previous work in this area was completed by Jennie Sealander in 1992 [Ref. 10], A 
variety of deficiencies in that work lead to requirements for follow-on work. These 
deficiencies include: 

• No support for the Ada 95 language. 

• Failure to handle nested packages. 

• Restriction to uppercase only or lowercase only for Ada keywords. 

• Does not handle exceptions for PSDL operators. 

• Improper handling of generic value, generic array, and generic subprogram 
parameters. 

• No support for in out parameters. 

In order to provide an updated translator, the decision was made to build a 
completely new version rather than attempt to upgrade the existing version. Starting from 
scratch allowed the selection of a new tool for constructing the translator. While tools such 
as Kodiak, developed at the University of Minnesota, and Eli, developed at the University 
of Colorado, are available as compiler/translator generators, the Synthesizer Generator 
(SynGen) was ultimately selected for implementation of the translator. All of these tools 
are based upon the concept of attribute grammars as described by Knuth [Ref 11]. SynGen 
was selected because it has the capability to generate a syntax-directed editor from the 
specified attribute grammar. Additionally, SynGen was used to construct the PSDL editor 
utilized by CAPS, so a common interface is achieved with the Ada 95 editor generated as 
a part of the translator tool. 

B. THE SYNTHESIZER GENERATOR 

The Synthesizer Generator is a tool, which through the use of attribute grammars 
can create a variety of syntax directed editors, translators, and other language based tools. 
The generated tools are designed to be run within the X graphical environment, but may be 


21 








created to operate in batch modes as well. The Synthesizer Specification Language (SSL) 
is utilized to create editor specifications. SynGen creates C language source files utilizing 
a user’s SSL files, and other tools such as YACC. These source files are compiled to create 
a stand-alone final product. SSL constructs are used to specify several aspects of user 
specified editors including: 

• The abstract syntax of a language. 

• Context-sensitive relationships. 

• Display format. 

• Concrete input syntax. 

• Transformation rules for restructuring objects. [Ref 12] 

Each of these may be specified in separate files, with an abstract syntax the only 
requirement for executing SynGen. This allows tools to be constructed in an incremental 
manner, gready easing the debugging process. 

C. THE TRANSLATOR 

The translator constructed utilizing SynGen can be operated in two modes, 
interactive and batch. In the interactive mode, the translator is a syntax directed Ada 95 
package specification editor which simultaneously produces PSDL translations. In the 
batch mode, an existing Ada package specification is specified as input to the translator 
which produces two output files, a PSDL translation, and an annotated Ada file which has 
comments interspersed with the Ada source code, these comments indicate the quality of 
the translation which has taken place. By examining the annotated Ada source file, users 
can get an idea as to how complete the translation was. Error messages inserted into the Ada 
source code, in the form of Ada comment statements, indicate which lines of source 
presented problems for the translator 

1. SSL Source Files 

The translator is constructed from eight SSL source files. Two files specify the 
abstract syntax of for Ada 95 package specifications, and PSDL. The source code listings 


22 






for the abstract syntax files are contained in Appendix A. One file specifies the concrete 
syntax for Ada 95 package specifications which allows the translator to accept existing Ada 
95 text files as input. Appendix D contains the concrete syntax rules for the translator. One 
file contains SSL functions which are used to compute attributes for Ada 95 productions 
which translate to PSDL. These functions are contained in Appendix C. Three files are 
required to specify the unparsing rules for Ada 95 and PSDL. Unparsing rules specify the 
format which is to be used for display of the underlying syntax trees. The source code for 
all unparsing rules may be found in Appendix B. The final file contains SSL transformation 
declarations which specify the manner in which users of the interactive translator may 

manipulate the syntax tree for Ada specifications. Appendix E contains the source listing 
for the transformation declarations used by the translator. 

2. Accomplishing the Translation 

An Ada package specification is translated into PSDL by taking advantage of the 
way in which SSL treats abstract syntax definitions and user-defined attribute types. In SSL 
these two concepts are merged so that attributes are in turn root nodes of an abstract syntax 
tree. In order to perform a translation, both the abstract syntax for Ada 95 and the abstract 
syntax for PSDL were specified. The Ada production pkg_spec contains a single attribute 
psdl trans which serves as the root of a PSDL abstract syntax tree. The attribute, 
psdl trans, is computed based upon the structure of the Ada abstract syntax tree rooted at 
pkg_spec by utilizing a variety of attribute computation functions which extract 
information from the Ada tree and convert it to nodes in the PSDL tree. By displaying the 
PSDL abstract syntax tree rooted at psdl trans, a translation of the Ada pkg_spec is 
obtained. 

3. Assumptions for Proper Translations 

There are several restrictions which apply to the use of the translator. These fall into 
two categories: 

• Implementation imposed limitations. 


23 




• Limitations imposed by Ada to PSDL mapping restrictions. 

The translator expects input files to contain only Ada package specifications. Ada 
package bodies are not recognized by the translator, and will result in no translation being 
accomplished. Components which place both the package specification and the package 
body in a single file must be split into two separate files, one containing the specification 
and the other the package body. The specification file is the file which the translator will 
process. 

The input file may contain zero or more Ada package specifications, but it is 
recommended that each input file contain only a single package specification in order to 
produce only a single PSDL component as output. Multiple package specifications in a 
single file will result in multiple PSDL component specifications in the output file. 

Ada functions are not translated into PSDL because the CAPS prototype 
construction tools provide only for interfacing to Ada procedures. In order to utilize the vast 
amount of existing Ada functions which have been written, packages which contain 
functions should be preprocessed to add procedure wrappers for each function interface. 
This is done by adding an additional procedure within the package specification which 
contains the same parameters as the function, and an additional out parameter used to pass 
out the return value. In the package body, a wrapper procedure is inserted which calls the 
function and passes out the functions return value in its extra out parameter. Appendix F 
discusses this process and contains examples of how this is done for both generic and non¬ 
generic functions within a package. 

PSDL does not allow the nested definition of type components. In many cases the 
outermost package specification in a file may contain one or more nested package 
specifications. If these nested package specifications translate to PSDL type components, 
then the outermost package specification is stripped off and each nested package translated 
as a unique PSDL type component. This makes more of the software components available 
for reuse. If the outer package was not stripped away, the nested packages would not be 


24 




translated at all, and would be unavailable for reuse. Figure 14 show and Ada package 
package OuterPkg is 

procedure OuterProcl( parml : in integer); 
procedure OuterProc2(pann2 : out float); 
package Inner_Pkg is 

procedure InnerProcl(parml : character); 
procedure InnerProc2(parm2 ; in out integer); 
end Inner_Pkg; 
end Outer Pkg; 


Figure 14. Package with Nested Package 

specification containing a nested package. A strict translation of the this package to PSDL 
is shown in Figure 15. Notice that no translation of Inner_Pkg occurs. Inner_Pkg would 


type Outer Pkg 
specification 

operator OuterProc 1 
specification 
input 

parml : integer 
end 

operator OuterProc2 
specification 
output 

parm2 : float 
end 
end 

implementation ada Outer_Pkg 
end 

Figure 15. Strict Translation for Nested Packages 


25 









translate into a PSDL type component, however, no translation is performed because nested 
types are not allowed in PSDL. By allowing the outermost package in a specification to be 
stripped away, the translation of Figure 16 is obtained. This form of translation makes many 


operator OuterProcl 
specification 
input 

parml : integer 
end 

implementation ada OuterProcl 
end 

operator OuterProc2 
specification 
output 

parm2 : float 
end 

implementation ada OuterProc2 
end 

type Inner_Pkg 
specification 

operator InnerProcl 
specification 
input 

parml ; character 
end 

operator InnerProc2 
specification 
input 

parm2 : integer 
output 

parm2 : integer 
end 
end 

implementation ada Inner_Pkg 
end 

Figure 16. Translation with Outer Package Stripped Away 


more packages available within the software base. It is an attempt to allow access to 


26 






software in cases where many unrelated packages are bundled together to form a single 
package simply for containership. 


27 










28 






V. PSDL TYPE COMPONENT RETRIEVAL 

A. BACKGROUND 

Design and implementation of tools for retrieving PSDL operator components was 
performed by McDowell [Ref. 9] and Dolgoff [Ref. 5]. In particular Dolgoff’s work yields 
a tool which utilizes user interactions to retrieve “best match” operator components from 
the CAPS software base for integration into prototype systems. It is desirable to extend this 
tool to allow the retrieval of PSDL type components as well. This chapter discusses 
considerations for the retrieval of PSDL type components from the software base, while 
leaving actual implementation of such a tool for future research. 

B. PSDL TYPE COMPONENTS 

PSDL type components are similar to the “objects” of object-oriented programming 
languages. PSDL types represent a data object and the associated operators to manipulate 
that object, within CAPS, they correspond to Ada abstract data types (ADT). Figure 17 
shows a partial specification of a generic PSDL set data type. PSDL type components may 
be either generic, or non-generic, may contain internal type declarations, and may contain 
zero or more operators which operate on that type. 

In order to retrieve a type component from the software base a user must formulate 
a PSDL query which specifies the user’s type component. This will be referred to as the 
query type component, or simply query component (qc), throughout the remainder of the 
chapter. Given a query component, the software base is searched in order to find a match 
for the specified query component. Software base components (sbc) are those PSDL type 
components residing in the software base which are the objects of search process. Any 


29 









software base components which pass through all filtering operations become possible 
candidates for integration into the user’s prototype system. 

type Set 
specification 
generic 

Element: PRIVATE_TYPE 

operator Insert 
specification 
input 

NewElement: Element 
output 

NewSet: Set 
end 

operator Empty 
specification 
output 

EmptySet: Set 

end 

operator In 
specification 
input 

Item; Element, 

SI : Set 
output 

Result: boolean 
end 

end 

Figure 17. PSDL Specification of a Set Data Type 

C. MATCHING TYPE COMPONENTS 

The goal of the matching process is to locate, for the user, as many type components 
as possible which may suit the requirements of the users prototype. In presenting these 
“matching” types to the user, it is desirable to narrow the range of choices the user must 
evaluate to those which have the highest likelihood of suiting the user’s needs. In order to 


30 




prevent the user from browsing through the entire dictionary of type components within the 
CAPS software base, several filters are applied, utilizing the user’s query component, to 
make the list of choices more manageable for the user. These filters are constructed based 
upon information specified by the users query component. An initial query to the software 
base utilizing these initial filters will return a set of type components which will be 
subjected to further processing. The results of this second pass over the components are 
then displayed to the user, who can browse the list of type components in search of the most 
suitable for the current prototype system. Once the user has selected a type component for 
integration into a CAPS prototype, the retrieved component must be made available to the 
user in a form which will integrate directly into the prototype. In the case of generic type 
components, it is necessary to first instantiate the component. Following instantiation, 
integration proceeds similarly for both generic and non-generic type components. A 
wrapper package must be constructed which suitably renames and instantiates the target 
component into a component which will integrate directly into the users prototype system. 

D. DEFINITIONS 

The following definitions are taken firom Dolgoff’s thesis and are utilized here for 
consistency [Ref. 5]. 

1. PSDL Specification 

The PSDL specification for a component denoted by PS. 

2. Software Base Component 

The software base component is denoted by sbc. The PSDL specification of a 
software base component is denoted by PS(sbc). 

3. Query Component 

A query component refers to the component that the CAPS user is in the process of 
finding a match for and is denoted by qc. The PSDL specification for a query component 
is denoted by PS(qc). 


31 








4. Component Signature 

The component signature refers to the types of the component parameters, with 
separate signatures representing the input and output parameters of software base 
components. A signature encodes information that describes each instance of parameter 
types utilized by the component. Figure 18 shows the signature for a PSDL operator 

operator ExampleOp 
specification 
input 

Parml : Integer, 

Parm2 : Integer, 

Parm3 : Boolean, 

Parm4: Range 
output 

Parm5 : Hoat 


Input Signature: 

(Integer, Integer, Boolean, Range) 

Output Signature: 

(Hoat) 

Figure 18. Example Operator Component Signatures 


component. Ordering of types within a signature is insignificant. For example, the input 
signature (Boolean, Integer, Range, Integer) is considered a match for the input signature 
in Figure 18. The types will be mapped by the wrapper package created to integrate a 
software base component into the users prototype. For PSDL type components, the 
signatures represent the aggregate of all parameter types utilized by the types operators. 
Figure 19 shows the signatures for an example type component. 

a. Parameter Types 

In the simplest case of parameter matching, an input PS(qc) parameter 
exactly matches an input PS(sbc) parameter. However, the type hierarchy employed by 
Ada allows types to be matched in some cases where it would appear that no match exists. 


32 




The types Private, Discrete, Integer, Range, Natural, Positive, Enumeration, Character, 
Boolean, Access, Record, Array, String, Digits, Float, Delta, and Fixed are predefined and 
form the hierarchy depicted in Figure 20. Utilizing these relationships, it can be seen that 


type ExampleType 
specification 

operator TypeOpl 
specification 
input 

Parml : Boolean, 
Parm2: Integer 
output 

Parm3 : Integer 


operator TypeOp2 
specification 
input 

Parm2 : Integer 
end 
end 

Input Signature: 

(Boolean, Integer, Integer) 

Output Signature: 

(Integer) 

Figure 19. Example Type Component Signatures 


an input PS(qc) parameter of type Positive can be matched to an input PS(sbc) parameter 
of type Integer. This is a one way relationship. Input parameter types in a PS(sbc) must 
accept the entire range of values expressed by the input parameter types of a PS(qc). 
Conversely, the output parameter types of a PS(qc) must accept all values generated by the 
output parameter types of a PS(sbc). 


33 







b. Input Parameters 

Each input parameter has an identifier name, and a type. The identifier name 
is represented by p. The expression input_type(p,sbc) refers to the parameter type for a 
specified input parameter p in a PS(sbc). Similarly, the expression input_type(p,qc) refers 



to the parameter type for a specified input parameter p in a PS(qc). The expression In(sbc) 
refers to the entire set of input parameter identifier names in a PS(sbc), and In(qc) refers 
to the entire set of input parameter identifier names in a PS(qc). 

c. Output Parameters 

Output parameter definitions mirror those of input parameters. The 
expression output_type(p,sbc) refers to the parameter type for a specified output 
parameter p in a PS(sbc). Similarly, the expression output_type(p,qc) refers to the 
parameter type for a specified output parameter p in a PS(qc). The expression Out(sbc) 
refers to the entire set of output parameter identifier names in a PS(sbc), and Out(qc) refers 
to the entire set of output parameter identifier names in a PS(qc). 


34 




d. States 


The expression ST(sbc) is a boolean function that evaluates whether the 
software base component is a state machine or not. ST(qc) does the same for a query 
component. 

e. Abstract Data Types 

Type components may contain type declarations for abstract data types 
utilized by the type component. This is not the case for operator components. ADT(sbc) 
denotes the set of all abstract data types in s software base type component, while ADT(qc) 
represents the set of all abstract data types in a query type component. OPS(sbc) denotes 
the set of all operators in a software base type component, while OPS(qc) represents the 
set of all operators in a query type component. Tot_In(sbc) denotes the entire set of input 
parameter identifier names over all operators of a software base type component, while 
Tot_In(qc) denotes the entire set of input parameter identifier names over all operators of 
a query type component. Similarly Tot_Out(sbc) and Tot_Out(qc) are defined for output 
operators. 

E. SYNTACTIC MATCHING RULES FOR TYPE COMPONENTS 

The following rules for component matching are again taken from McDowell [Ref. 
9] and Dolgoff [Ref. 5]. NUM(X) is used to represent the cardinality of the set X. 

1. Rules for Operator Components 

Initial filtering for operator components is based upon comparing numbers of 
parameters between two operators, these are listed below: 

• NUM(In(sbc)) = NUM(In(qc)) 

• NUM(Out(sbc)) > NUM(Out(qc)) 

• ST(sbc) = ST(qc) 

The number of software base component input parameters must be the same as those of the 
query component. The number of software base component output parameters must be 


35 



greater than or equal to those of the query component. Both components must either be 
state machines, or both components must not be state machines. 

Extended filtering rules for operator components were specified by Dolgoff and 
follow below [Ref. 5]: 

a. Property 1 

There must exist a bijective function f from the set In(qc) to the set In(sbc) 
for which the following holds: 

(Vp e In(qc)) (input_type(p, qc) c input_type(f(p), sbc)) 
where the subset operator denotes “is a subtype of’. 

h. Property! 

There must exist a one-to-one function f from the set Out(qc) to the set 
Out(sbc) for which the following holds: 

(Vp e Out(qc)) (output_type(f(p), sbc) c output_type(p, qc)) 

These two rules enforce signature matching for operator components. 

2. Rules for Type Components 

PSDL type components contain one or more abstract data type declarations and zero 
or more operator. Initial filtering of software base type components is based upon aggregate 
signatures composed from the type’s operator components. The basic rules for types are 
[Ref. 9]: 

• NUM(ADT(sbc)) > NUM(ADT(qc)) 

• NUM(Tot_In(sbc)) > NUM(Tot_In(qc)) 

• NUM(Tot_Out(sbc)) > NUM(Tot_Out(qc)) 

• NUM(OPS(sbc)) > NUM(OPS(qc)) 

The number of ADTs, operators, total operator inputs and total operator outputs within the 
software base type component must all be greater than or equal to those of the query type 
component. 


36 


Extended filtering for type components as specified by Dolgoff, consists of a single 
rule which states that there must exist a one-to-one function f from the set OPS(qc) to the 
set OPS(sbc) such that VOP^^. e OPS(qc) properties one and two above, for operators, 

hold true [Ref. 5]. In addition to the rules specified by Dolgoff, properties one and two for 
operators must be satisfied by type components as well, in order to match the aggregate 
signatures for component inputs and outputs. 

F. SEARCHING FOR TYPE COMPONENTS 

The process for matching type components is shown in Figure 21. This is a slightly 



modified version of the process presented by Dolgoff [Ref. 5]. The Array Check step has 
been removed, as it is performed within the Operator Mapping sub-process. All filtering 
prior to Operator Mapping is accomplished by database queries to the CAPS software base, 
as described by Dolgoff. Operator Mapping and the Instantiation Check are discussed in 
the following sections. 


37 











1. Operator Mapping 

Operator Mapping is the process that determines whether a one-to-one function can 
be found that maps OPS(qc) to OPS(sbc). In order to do this, each operator component, 
within the query type component, is formulated into a query operator component, and used 
as input to existing operator matching functions. Each of these query operator components 
is matched against a set derived from OPS(sbc) in search of a match. Should a match be 
found for an operator component, it becomes part of the Operator Mapping function, and 
the matching software base operator component is added to a set Used_OPS(sbc). 
Used_OPS(sbc) is initialized to the empty set. The set of available software base operator 
components input to the process is, OPS(sbc) - Used_OPS(sbc). This assures that a one- 
to-one mapping will be generated should the process succeed. If no match can be found for 
an operator component, backtracking is utilized in order to achieve an exhaustive search 
for a suitable one-to-one mapping. If no one-to-one mapping can be generated, then the 
entire Operator Mapping step fails for that particular software base type component, and it 
is eliminated from consideration as a match for PS(sbc). The Operator Mapping process is 
shown in Figure 22 and is derived from Dolgoff’s filter process for operators. The Is 



Figure 22, Operator Mapping Sub-Process 


38 





Generic step is a modified version of the same step used by Dolgoff. Is Generic branches 
in the following manner: 

* Yes - The Yes branch can be taken for either of the following two reasons. First, the 
software base operator component is generic. Second, if the software base type 
component which contains the software base operator component is generic, and one 
ore more of the operator’s input or output parameter types matches one of the type 
component’s declared generic parameters (see example Figure 23). 

• No -The No branch is taken if the operator component is non-generic, and none of its 
input or output parameters match any generic parameters which belong to the type 
component in which it is contained. 

The Array Check step performed across the set of OPS(qc), throughout the process of 
Operator Mapping, removes the need to perform Array Check separately in the type 
matching process. 

2. Type Instantiation Check 

At the Instantiation Check stage, generic type components are evaluated to 
determine if a proper set of actual Ada type parameters can be found to properly instantiate 
the type component to match the query type component. If no set of Ada types can be found 
to perform the instantiation, the software base type component is removed from 
consideration as a possible match for the query component For non-generic software base 
type components, this stage is simply a pass through filter, and the previous stages have 
demonstrated that the component is a syntactic match for the query component For generic 
software base type components, the Operator Mapping stage has shown that at the operator 
level, generic instantiations exist which match all operators contained in the query type 
component. A problem exists in the fact that the generic parameters are defined at the type 
level rather than at the operator in generic type components. Figure 23 shows an example 
of a generic type component. Potential problems lie in the manner in which the Operator 
Mapping phase assigns to actual Ada types to the parameter Discrete 1. Figure 24 shows an 
example query type component which can be matched by the type component in Figure 23. 
In this example, the Operator Mapping process would assign Discrete 1 to Ada type 
Positive when instantiating Opl, and it would assign Discrete 1 to Ada type Integer when 
instantiating Op2. The problem is to find a single type to assign to Discrete 1 which will 


39 



create suitable instantiations for both Opl and C)p2. The solution is to utilize the subtype 


type GenericExample 
specification 
generic 

Discrete 1 : Discrete_Type 

operator Opl 
specification 
input 

OplParml: Discretel 
end 

operator Op2 
specification 
input 

Op2Parml: Discretel 
output 

Op2Parm2: Float 
end 

end 

Figure 23. Example Generic Type Specification 

hierarchies specified by Dolgoff [Ref. 5]. In cases where two or more operator components 
utilize the same generic parameter in declaring input or output parameters, the concept of 
least upper bound is used to determine a proper instantiation of the type component 
Considering the Ada t5^es selected for instantiation of operators within the software base 
type component as a set, a proper instantiation is possible only if the least upper bound of 
the set is a specific Ada type, as opposed to the types which may only appear in generic 
formal parameter declarations (shown in Figure 11). In attempting to match the query 
component in Figure 24 to the software base component of Figure 23, the set of possibilities 
for the Discretel parameter is found to be {Integer, Positive}. Referring to Figure 20, the 
Ada type Integer is found to be the least upper bound. Integer is a specific Ada type, and is 
therefore selected as the appropriate type with which to instantiate the software base 
component. In Figure 25, an example of an unsuccessful instantiation is shown. The set of 


40 




possibilities for Discretel in this case is {Positive, String}, and the least upper bound of this 
set is the Ada type Private. Private is not a specific Ada type, and the conclusion is that 
GenericExample can not be instantiated in such a way as to match QueryExample2. There 
is no single Ada type with which GenericExample can be instantiated which contains both 
a String and an Integer. GenericExample is then removed from consideration as a matching 
type component. 

type QueryExample 
specification 

operator Opl 
specification 
input 

OplParml : Positive 
end 

operator Op2 
specification 
input 

Op2Parml: Positive 
output 

Op2Parm2 : Float 
end 


Figure 24. Example Query Type Component (Successful Match) 


41 





type QueryExample2 
specification 


operator Opl 
specification 
input 

OplParml : Positive 

end 

operator Opl 
specification 
input 

Op2Pamil : String 
output 

Op2Parm2 : Float 
end 


end 

Figure 25. Example Query Type Component (Unsuccessful Match) 


42 







VI. CONCLUSIONS AND FUTURE RESEARCH 

A. CONCLUSIONS 

The primary goal of this thesis was to produce a tool with the capability to 
automatically produce a PSDL specification when given an Ada package specification as 
input. This translation tool was produced utilizing the Synthesizer Generator, and has 
demonstrated its effectiveness by successfully translating several complex components 
from the Common Ada Missile Packages library. Additional accomplishments include the 
extension of PSDL constructs to allow the use of Ada procedures and functions as generic 
formal parameters, and extended considerations for the retrieval of PSDL type components 
from the CAPS software base. The following sections discuss areas in which further work 
may be accomplished to build upon the work of this thesis. 

B. POPULATE THE CAPS SOFTWARE BASE 

The completion of the translation tool presented in this thesis provides the 
opportunity to populate the CAPS software base by bringing in components from a variety 
of DOD Ada software libraries. These libraries include, but are not limited to, the CAMP, 
RAPID, ASSET, and CRSS libraries. Population of the software base will greatly enhance 
the ability of CAPS users to build significant, useful, prototype systems. 

C. EXTEND THE CAPABILITIES OF CURRENT COMPONENT 

RETRIEVAL TOOLS 

The current retrieval tool utilized by CAPS is capable of retrieving PSDL operator 
components only. Two major restrictions were imposed on these retrieval operations due 
to Ada to PSDL mapping limitations which existed at the time the retrieval tool was 
created. The first restriction prevented the use of in out parameters as procedure arguments. 
The second restriction prevented the use of functions and procedures as generic formal 
parameters. Updated translation tools and further review of PSDL have removed these two 
restrictions. First, in out parameters are now allowed as formal arguments within 
procedures, and second, mapping schemes have been created to allow functions and 


43 








procedures to be used as generic formal parameters. Dolgoffs retrieval tool needs updating 
to handle these two new cases. Additionally, Dolgoffs tool was created to handle Ada 83 
packages, and with the introduction of Ada 95, further research will be required to 
determine how derived types, and generic derived types can be made to fit into Dolgoffs 
type hierarchy. 

D. IMPLEMENT PSDL TYPE COMPONENT RETRIEVAL 

Scott Dolgoffs work created a tool which is used to retrieve PSDL operator 
components from the CAPS Software Base. This thesis extends the discussion on methods 
for the retrieval of PSDL type components from the software base. These methods require 
some further refinement followed by an actual implementation and integration with the 
operator retrieval tool to provide a complete PSDL component retrieval suite. 


44 




LIST OF REFERENCES 


1. Royce, R. W., “Managing the Development of Large Software Systems,” 
Proceedings, IEEE Wescon, August 1970. 

2. Boehm, B. W., “A Spiral Model of Software Development and Enhancement,” 
Tutorial: Software Engineering Project Management, IEEE Computer Society 
Press, 1987. 

3. Luqi, Software Evolution Through Rapid Prototyping, IEEE Computer, May 1989. 

4. Luqi, Berzins, V., Yeh, R. T., “A Prototyping Language for Real-Time Software,” 
IEEE Transactions on Software Engineering, October 1988. 

5. Dolgoff, S. J., Automated Interface for Retrieving Reusable Software Components, 
Master’s Thesis, Naval Postgraduate School, Monterey, CA, September 1993. 

6. Jones, C., “Reusability in Programming: A Survey of the State of the Art,” IEEE 
Transactions on Software Engineering, September 1984. 

7. Steigerwald, R., Reusable Software Component Retrieval via Normalized 
Algebraic Specifications, PhD. Dissertation, Naval Postgraduate School, 
Monterey, CA, December 1991. 

8. Steigerwald, R., Luqi, McDowell, J., “CASE Tool for Reusable Software 
Component Storage and Retrieval in Rapid Prototyping,” Information and 
Software Technology, November 1991. 

9. McDowell, J. K., A Reusable Component Retrieval System for Prototyping, 
Master’s Thesis, Naval Postgraduate School, Monterey, CA, September 1991. 

10. Sealander, J. M., Building Reusable Software Components for Automated 
Retrieval, Master’s Thesis, Naval Postgraduate School, Monterey, CA, September 
1992. 

11. Knuth, D, E., “Semantics of Context-Free Languages,” Mathematical Systems 
Theory, June 1968. 

12. Reps, T. W., Teitelbaum, T, The Synthesizer Generator, Springer-Verlag, 1989. 


45 



46 




APPENDIX A. SSL SOURCE CODE: ABSTRACT SYNTAX 


The source code below comprises two files which specify the abstract syntax for 
Ada 95 package specifications and for PSDL. 


/* File; abstract. ada9x.ssl */ 

ADate: 3 March, 1995 */ 

/* Author; Chris Eagle */ 

/* System; Sun SPARCstation */ 

/* Description; This file contains the abstract grammar for that */ 

/* portion of the Ada9x language which is required for */ 

/* package specifications. It was derived from the YACC */ 

/* grammar noted below. */ 




YACC grammar for Ada 9X *********♦*****************************/ 


/* Copyright (C) Intermetrics, Inc. 1994 Cambridge, MA USA */ 

/* Copying permitted if accompanied by this statement. */ 

/* Derivative woiks are permitted if accompanied by this statement. */ 

/* This grammar is thought to be correct as of May 1, 1994 */ 

/* but as usual there is *no warranty* to that effect. */ 




/* Lexemes for concrete syntax. This specification accounts for */ 

/* Ada’s type insensitivity. */ 


QUOTED STRING; 

< \”(n”]r’VT”)*\” >; 

CHAR_LIT. 


TIC 


DOT DOT 


BOX 

< “O” >; 

LT EQ 

< “<=” >-^ 

LT LT 

< “<“ >; 

EXPON 


NE 

< “/=” >; 

GE 

< “>=” >• 

GT GT 

< >; 

IS ASSIGNED 

< “;=” >; 

RIGHT SHAFT 

<“=>” >; 

ABORT 

< [aA][bB][oO][rR][tT] >; 

ABS 

< [aA][bB][sS] >; 

ABSTRACT 

< [aA][bB][sS][tT][rR][aA][cC][tT] >; 

ACCEPT 

< [aA][cC][cC][eE][pP][tT] >; 

ACCESS 

< [aA][cC][cC][eE][sS][sS] >; 

ALIASED 

< [aA][lL][iI][aA][sS][eE][dD] >; 


47 






ALL 

AND 

ARRAY 

AT 

BEGIN 

Body 

CASE 

CONSTANT 

DECLARE 

DELAY 

DELTA 

DIGITS 

DO 

ELSE 

ELSIE 

END 

ENTRY 

EXCEPTION 

EXECUTION 

EXIT 

FOR 

FUNCTION 

GENERIC 

GOTO 

HRS 

IF 

IN 

IS 

LIMITED 

LOOP 

MAXIMUM 

MIN 

MOD 

MS 

NEW 

NOT 

Null 

OF 

OR 

OTHERS 

OUT 

PACKAGE 

PrAGMA 

PRIVATE 

PROCEDURE 

PROTECTED 

RAISE 

RaNGE 

RECORD 

REM 

ReNAMES 


:< [aA][IL][IL] >; 

:< [aA][nN][dD] >; 

:< [aA][rR][rR][aA][y Y] >; 

:< [aA][tT] >; 

;<[bB][eE][gG][iI][nN]>; 

:< [bB][oO][dD][yY] >; 

:< [cC][aA][sS][eE] >; 

:< [cC][oO][nN][sS][tT][aA][nN][tT] >; 

:< [dD][eE][cC][IL][aA][rR][eE] >; 

:< [dD][eE][IL][aA][yY] >; 

:< [dD][eE][IL][tT][aA] >; 

:< [dD][iI][gG][iI][tT][sS] >; 

:< [dD][oO] >; 

:< [eE][IL][sS][eE] >; 

:<[eE][IL][sS][iI][fF]>; 

:< [eE][nN][dD] >; 

:< [eE][nN][tT][rR][yY] >; 

:< [eE][xX][cC][eE][pP][tT][iI][oO][nN] >; 

:< <PSDL_STATE> [eE][xX][eE][cC][uU][tT][iI][oO][nN] >; 
:< [eE][xX][iI][tT]>; 

:< [fF][oO][rR] >; 

;< [fF][uU][nN][cC][tT][iI][oO][nN} >; 

:< [gG][eE][nN][eE][rR][iI][cC] >; 

;< [gG][oO][tT][oO]>; 

: < <PSDL_STATE> [hH][oO][uU][rR][sS] <INITIAL> >; 

:< >; 

:< [iI][nN] >; 

:< [iI][sS] >; 

:<[IL][iI][mM][iI][tT][eE][dD]>; 

:< [IL][oO][oO][pP] >; 

;< <PSDL_STATE> [mM][aA][xX][iI][mM][uU][inM] >; 

:< [iiiM][iI][nN] >; 

:< [inM][oO][dD] >; 

: < <PSDL_STATE> [mM][sS] <INITIAL> >; 

:< [nN][eE][wW] >; 

:< [nN][oO][tT] >; 

;< [nN][uU][IL][IL] >; 

:< [oO][fF] >; 

:< [oO][rR] >; 

:< [oO][tT][hH][eE][rR][sS] >; 

:< [oO][uU][tT] >; 

:< [pP][aA][cC][kK][aA][gG][eE] >; 

•< [pP][rR][aA][gCi][niM][aA] >; 
:<[pP][rR][iI][vV][aA][tT][eE]>; 

:< [pP][rR][oO][cC][eE][dD][uU][rR][eE] >; 

:< [pP][rR][oO][tT][eE][cC][tT][eE][dD] >; 

:< [rR][aA][iI][sS][eE] >; 

;< [rR][aA][nN][gG][eE]>; 

:< [rR][eE][cC][oO][rR][dD] >; 

:< [rR][eE][mM] >', 

:< [rR][eE][nN][aA][niM][eE][sS] >; 


48 





REQUEUE 

RETURN 

REVERSE 

SEC 

SELECT 

SEPARATE 

SUBTYPE 

TAGGED 

TASK 

TERMINATE 

THEN 

TIME 

TYPE 

UNTIL 

USE 

USEC 

WHEN 

WHILE 

WHITESPACE 

WITH 

XOR 


< [rR][eE][qQ][uU][eE][uU][eE] >; 

< [rR][eE][tT][uU][rR][nN] >; 

< [rR][eE][vV][eE][rR][sS][eE] >; 

< <PSDL_STATE> [sS][eE][cC] <INITIAL> >; 

< [sS][eE][lL][eE][cC][tT] >; 

< [sS][eE][pP][aA][rR][aA][tT][eE] >; 

< [sS][uU][bB][tT][yY][pP][eE] >; 

< [tT][aA][gG][gG][eE][dD] >; 

< [tT][aA][sS][kK] >; 

< [tT][eE][rR][mM][iI][nN][aA][tT][eE] >; 

< [tT][hH][eE][nN] >; 

< <PSDL_STATE> [tT][iI][mM][eE] >; 

< [tT][y Y][pP][eE] >; 

< [uU][nN][tT][iI][lL] >; 

< [uU][sS][eE] >; 

< <PSDL_STATE> [mM][iI][cC][rR][oO][sS][eE][cC] <INITIAL> >; 

< [wW][hH][eE][nN] >; 

< [wW][hH][iI][lL][eE] >; 

<[\\t\n] >; 

< [wW][iI][tT][hH] >; 

< [xX][oO][rR] >; 


PSDL_COMMENT ; < “-PSDL “ <PSDL_STATE> >; 
ADA_COMMENT : < >; 

INTEGER :<[0-9]L?[0-9])* >; 

REAL_CS : <[0-9]C?[0-9])*(\.[0-9](_?[0-9])*) >; 

ID : <[a-zA-Z](_?[a-zA-Z0-9])* >; 

/* precedence declarations */ 


left 

left AND, OR, XOR; 

left NE, LT_LT, LT_EQ, GT_GT, GE; 
left *+’, 

left ‘*’,7’, MOD, REM; 

leftEXPON; 

left 


root compilation; 


comp_unit, pkg_decl, pkg_spec, private_part, decl_item_s, decl_item, decl 
{inh INT nestingjevel;}; 

compilation : CompilationNilQ 

I Compilation(pragma_s comp_unit_list) 


optional list comp_unit_list; 


49 



comp_unit_list: CUListNil() 

I CUList(comp_unit comp_unit_list) { 

comp_unit.nesting_level = 0; 

> 


comp_unit: CompUnit(context_spec_opt private_opt pkg_decl pragma_s) { 
pkg_decl.nestmg_level = $$.nesting_level; 

} 


optional private_opt; 
private_opt: PrivateOptNull() 

I PrivateOptPromptO 
I PrivateOptO 


optional context_spec_opt; 
context_spec_opt: ContextSpecNull() 

I ContextSpecPromptO 
I ContextSpec(context_spec) 


context_spec ; EmptyContextSpec() 

I ContextWithUse(context_spec_opt with_clause use_clause_opt) 
I ContextPragma(context_spec pragma) 


with_clause : WithClause(c_name_list) 


optional list use_clause_opt; 
use_clause_opt: UseClauseOptNil() 

I UseClause(use_clause use_clause_opt) 


use_clause : EmptyUseC() 

I Use(name_s) 

I UseType(name_s) 


list name_s; 
name_s: NameNil() 

I nameList(name name_s) 


name : EmptyName() 

I SimpleName(identifier) 

I IndexComp(name value_s) 

I SelectedComp(selected_comp) 
I Attribute(name attribute_id) 


50 


I OperatorSymbol(QUOTED_STRING) 


identifier: IdNull() 

I Ident(ID) 


list value_s; 
value_s: ValueNil() 

I ValueList(value value_s) 


value : Empty Value() 

i ValueExpr(expression) 

I ValueCompAssoc(comp_assoc) 

I ValueDiscWithRange(discrete_with_range) 


selected_comp : EmptySelCompO 

I DotId(name identifier) 

I DotUsedChaifname CHARLIT) 

I DotString(name QUOTEDSTRING) 
I DotAll(name) 


attributejd : EmptyAttribld() 

I Attribld(identifier) 
I AttribDigitsO 
I AttribDeltaO 
1 AttribAccessO 


expression: EmptyExpression() 

I Relation(relation) 

I And, Or, Xor, AndThen, OrElsefexpression relation) 


relation: EmptyRelationQ 

I SimpleExpr(simple_expression) 

I Equal, NotEqual, LessThan, LessThanEq, 

GreaterThan, GreaterThanEq(simple_expression simple_expression) 
I RangeMember(simple_expression membership range) 

I NameMember(simple_expression membership name) 


membership : EmptyMembr() 
|In() 

I NotlnQ 


simple_expression: Empty Simple() 


51 








I Term(unary term) 

I Addition, Subtraction, Concat(simple_expression term) 


optional unary; 
unary : UnaryNull() 

I UnaryPromptO 
I PlusQ 
I MinusQ 


term ; Empty Term() 

I Factor(factor) 

I Mult, Divide, Mod, Rem(tenn factor) 


factor: Empty Factor() 

I Primary(primary) 

I NotPrimary(primary) 

I AbsPrimary(primary) 

I Expon(primary primary) 


primary : EmptyPrimaryO 

i Literal(literal) 

I PrimaiyName(name) 

I Allocator(allocator) 

I Qualified(qualified) 

I Parens(expression) 

I PrimaryAgg(aggregate) 


list compound_name; 
compound_name : EmptyCompound() 

I DotCompound(identifier compound_name) 


list c_namejist; 

c_name_list: CompoundNameNil() 

I CompoundList(compound_name c_name_list) 


numericjit: IntLit(integer) 

I RealLit(REAL_CS) 


literal : EmptyLiteral() 

I NumLit(numeric_lit) 

I UsedChar(CHAR_LIT) 
I NilLitO 


52 




aggregate : EmptyAggregateQ 

I AggCompAssoc(comp_assoc) 

I AggValues2(value_s_2) 

I AggExprValue(expression value_s) 
I AggExprWithNull(expression) 

I AggExpNullRecO 


value_s_2 : ValueS2Pair(value value) 

I ValueS2List(value_s_2 value) 


comp_assoc ; CompAssoc(choice_s expression) 


list choice_s; 
choice_s : ChoiceNil() 

I ChoiceList(choice choice_s) 


choice : EmptyChoice() 

I ChoiceExpr(expression) 

I ChoiceRange(discrete_with_range) 
I ChoiceOthersO 


discrete_with_range: DiscreteNameRange(name range_constramt) 
I DiscreteWithRange(range) 


range_constraint: Range(range) 


range : EmptyRange() 

I SimpleRange(simple_expression simple_expression) 
1 NameTicRange(name) 

I NameTicRangeExp(name expression) 


qualified: EmptyQual() 

I NameTicAgg(name aggregate) 

I NameTicExpr(name expression) 


allocator: newName(name) 

I NewQualified(qualified) 


pragma : EmptyPragma() 

I Pragmald(identifier) 


53 





I PragmaSimple(identifier pragma_arg_s) 


list pragma_arg_s; 
pragma_arg_s ; PragmaArgNil() 

I PragmaSargList(pragma_arg pragma_arg_s) 


pragma_arg : EmptyPragmaArgO 

I PragmaExp(expression) 

I PragmaNameExp(identifier expression) 


optional list pragma_s; 
pragma_s : PragmasNil() 

I PragmasList(pragma pragma_s) 


pkg_decl; EmptyPkgDecl() 

I PkgSpec(generic_hdr pkg_spec) { 
pkg_spec.nesting_level = $$.nesting_level; 

} 

I GenPkgInst(compound_name generic_inst) 


pkg_spec : Package(compound_name decl_item_s private_part) { 

decl_item_s.nesting_level = $$.nesting_level + 1; 
private_part.nesting_level = $$.nesting_level; 

} 


optional private_part; 
private_part: PrivatePartNull() 

i PrivatePartPromptO 
I Private(decl_item_s) { 

decl_item_s.nesting_level = $$.nesting_level + 1; 

} 


optional list decl_item_s', 
decl_item_s ; DeclListNil() 

I DeclList(decl_itern decl_item_s) { 
decl_item_s$2.nesting_level = $$.nesting_level; 
decl_iteni.nesting_level = $$.nesting_level; 

} 


decl_item : EmptyDeclItemO 

I Decl(decl) { 

decl.nesting_level = $$.nesting_level; 

} 


54 




I UseClauseDecl(use_clause) 
I DeclRepSpec(rep_spec) 

I DeclPragma(pragma) 


rep_spec : EmptyRepSpec() 

I AttribDef(mark expression) 

I RecordTypeSpec(mark align_opt comp_loc_s) 
I AddressSpec(mark expression) 


optional align_opt; 
align_opt: AlignOptNull() 

I AlignOptPromptO 
I AlignOpt(expression) 


optional comp_loc_s; 
comp_loc_s; CompLocNull() 

I CompLocPromptO 

I CompLocList(comp_loc_s mark expression range) 


mark : EmptyMark() 

I Mark(identifier marklist) 


optional ticdot; 
ticdot: TicDotNilO 

i TicDotPHO 
I TicOpt(attribute_id) 
I DotOpt(identifier) 


optional list marklist; 
marklist: MarkListNil() 

I MarkList(ticdot marklist) 


decl : EmptyDeclO 

I ObjDecl(def_id_s object_qualifier_opt object_subtype_def init_opt) 
I NumDecl(det^id_s expression) 

I TypeDecl(identifier discrim_part_opt type_completion) 

I SubTypeDecl(identifier subtype_md) 

I SubProgDecl(subprog_decl) 

I PkgDecl(pkg_decl) { 
pkg_decl.nesting_level = $$.nesting_level; 

} 

I TaskDecl(task_spec) 
i ProtDecl(prot_spec) 

I ExcDecl(def_id_s) 








I RenameDecl(rename_decl) 
I BodyStubDecl(body_stub) 


list def_id_s; 
def_id_s : DefIdNil() 

I DefIdList(identifier def_id_s) 


optional object_qualifier_opt; 
object_qualifier_opt: ObjQualOptNullO 

I ObjQualOptPromptO 
I AliasedO 
I ConstantO 
I AliasedConstO 


object_subtype_def: EmptySubtypeDef() 

I Subtypelnd(subtype_ind) 
I ArrayType(array_type) 


optional init_opt; 
init_opt: InitOptNull() 

I InitOptPromptO 
I ExprlnitOpt(expression) 


subtype_ind: EmptySubtInd() 

I SubtypeIndConstraint(naine constraint) 
I SubTypelndName(name) 


constraint: EmptyConstraintO 

I RangeConstraint(range_constraint) 

I DecDigConstraint(expression range_constr_opt) 


range_constr_opt: EmptyRangeConstrOpt() 

I RangeConstr(range_constraint) 


array_type : EmptyArrayType() 

I UnconstrAiTay(index_s component_subtype_det) 

I ConstrArray(iter_discrete_range_s component_subtype_def) 


component_subtype_def: CompSubtypeDef(aliased_opt subtype_ind) 


optional aliased_opt; 


56 




aliased_opt: AliasedOptNullQ 

I AliasedOptPromptO 
I AliasedOptO 


list index_s; 
mdex_s : IndexNil() 

I IndexList(name index_s) 


list iter_discrete_range_s; 
iter_discrete_range_s: DiscreteRangeNil() 

I DiscreteRangeList(discrete_range iter_discrete_range_s) 


discrete_range : EmptyDiscRngO 

I DiscRangeName(name range_constr_opt) 
I DiscRangeRange(range) 


optional discrim_part_opt; 
discrim_part_opt: DiscrimPartNull() 

I DiscrimPartPromptO 
I DiscrimPart(discriin_spec_s) 
I Box() 


list discrim_spec_s; 
discrim_spec_s : DiscrimSpecNil() 

I DiscrimSpecList(discrim_spec discrim_spec_s) 


discrim_spec : DiscrimSpecDef(def_id_s access_opt mark init_opt) 


optional access_opt; 
access_opt: AccessOptNull() 

I AccessOptPromptO 
I AccessOptO 


optional type_completion; 
type_completion: TypeComplNull() 

I TypeComplPromptO 
I TypeDefCompl(type_def) 


type_def: EmptyTypeDef() 

I EnumTypeDef(enum_id_s) 
1 IntTypeDef(integer_type) 

I RealTypeDef(real_type) 


57 



I Array TypeDef(array_type) 

I RecordType(tagged_opt limited_opt record_def) 
I AccessTypeDef(access_type) 

I DerivedTypeDef(derived_type) 

I PrivateTypeDef(private_type) 


derived_type : EmptyDerivedType() 

I NewDerivedType(subtype_ind) 
i NewDerivedWithPrivate(subtype_ind) 

I NewDerivedWithRecord(subtype_ind record_def) 

I AbsNewDerivedWithPrivate(subtype_ind) 

I AbsNewDerivedWithRecord(subtype_ind record_def) 


list enum_id_s; 
enum_id_s ; EnumIdNil() 

I EnumIdList(enum_id enum_id_s) 


enum_id : EmptyEnumId() 

I Id(identifier) 

I CharLit(CHAR_LIT) 


integer_type : EmptyIntType() 

I RangeSpec(range_spec) 
I ModExpr(expression) 


range_spec: RangeSpecConstr(range_constraint) 

5 

record_def: EmptyRecordDef() 

I Record(pragma_s comp_list) 
I NullRecordO 


comp_list; EmptyCompList() 

I CompListWithVariant(comp_decl_s variant_part_opt) 
I CompListWithPragma(variant_part pragma_s) 

I NullWithPragma(pragma_s) 


comp_decl_s : CompDeclNilQ 

I CompDecl(comp_decl) 

I CompDecIList(comp_decl_s pragma_s comp_decl) 


variant_part_opt: EmptyVariantPart() 

I VariantPartOptPragma(pragma_s) 


58 




I VariantPartOpt(pragma_s variant_part pragma_s) 


comp_decl: CompDecIDefs(def_id_s component_subtype_def init_opt) 


variantjjart: VariantPart(identifierpragma_s variant_s) 


list variant_s; 
variant_s : VariantNil() 

I VariantList(variant variant_s) 


variant: VariantChoice(choice_s pragma_s comp_list) 


optional tagged_opt; 
tagged_opt: TaggedOptNullQ 

I TaggedOptPromptO 
I TaggedO 
I AbstractTaggedO 


optional range_spec_opt; 
range_spec_opt: RangeSpecOptNull() 

I RangeSpecOptPromptO 
I RangeSpecOpt(range_spec) 


real_type : EmptyRealType() 

I FloatType(expression range_spec_opt) 
I FixedType(fixed_type) 


fixed_type : EmptyFixedType() 

I FixedDelta(expression range_spec) 

I FixedDeltaDigits(expression expression range_spec_opt) 


private_type : PrivateType(tagged_opt limited_opt) 


optional limited_opt; 
limited_opt: LimitedOptNull() 

I LimitedOptPromptO 
I LimitedO 


subprog_decl: Empty SubpDecl() 

I SubprogSpec(generic_hdr subprog_spec psdl_met_opt) 


59 



I GenericSubprogInst(subprog_spec generic_inst psdl_met_opt) 
I AbstractSubprogSpec(subprog_spec psdl_met_opt) 


optional psdl_niet_opt; 
psdl_met_opt: MetNull() 

I MetPromptO 

I MetUsec, MetMs, MetSec, MetMin, MetHrs(integer) 


subprog_spec : Empty SubpSpec() 

I SubProgProc(compoiind_name formal_pait_opt) 

I SubProgFuncRetum(designator formal_part_opt name) 
I SubProgFunc(designator) 


designator: EmptyDesignator() 

I DesigCompound(compound_name) 
I DesigString(QUOTED_STRING) 


optional fonnal_part_opt; 
formal_part_opt: FormalPartOptNull() 

I FormalPartOptPromptO 
I FonnalPart(param_s) 


list param_s; 
param_s: ParamNil() 

I ParamList(param param_s) 


param : Paramld(def_id_s mode mark init_opt) 
I EmptyParamO 


optional mode; 
mode : ModeNull() 

I ModePromptO 
I InModeO 
I OutModeO 
I InOutModeO 
I AccessModeO 


task_spec : EmptyTaskSpec() 

I Simple!ask(identifier task_det) 
i TaskType(identifier discrim_part_opt task_def) 


optional task_def; 


60 




task_def: TaskDefNull() 

I TaskDefPromptO 

I TaskDef(entry_decl_s rep_spec_s task_private_opt) 


optional task_private_opt; 
task_private_opt: TaskPvtOptNull() 

I TaskPvtOptPromptO 
I TaskPvtOpt(entiy_decl_s rep_spec_s) 


entry_decl_s ; EntryDeclPragma(pragma_s) 

I EntiyDeclPragmaList(entry_decl_s entry_decl pragma_s) 


entry_decl: EmptyEntiyDecl() 

I EntryDeclld(identifier formal_part_opt) 

I EntryRange(identifier discrete_range fonnal_part_opt) 


optional rep_spec_s; 
rep_spec_s: RepSpecNull() 

I RepSpecPromptO 

I RepSpecList(rep_spec_s rep_spec pragma_s) 


prot_spec: EmptyProtSpec() 

I Prot(identifier prot_def) 

I ProtType(identifier discrim_part_opt prot_def) 


prot_def; ProtDef(prot_op_decl_s prot_private_opt) 


optional prot_private_opt; 
prot_private_opt; ProtPvtOptNull() 

I ProtPvtOptPromptO 
I ProtPvtOpt(prot_elem_decl_s) 


optional list prot_op_decl_s; 
prot_op_decl_s : ProtOptDeclListNil() 

I ProtOptDeclList(prot_op_decl prot_op_decl_s) 


prot_op_decl: EmptyProtOpDecl() 

I EntryDecl(entry_decl) 

I ProtOptSubprog(subprog_spec) 
I RepSpec(rep_spec) 

I ProtOptPragma(pragma) 


61 


optional list prot_elem_decl_s; 
prot_elem_decl_s: ProtElemDeclNilQ 

I ProtElemDeclList(prot_elem_decl prot_elem_decl_s) 


prot_elem_decl: EmptyProtElem() 

I ProtOptDecl(prot_op_decl) 

I ProtElemCompDecl(comp_decl) 


rename_decl: EmptyRenameDecl() 

I RenameDeclSub(def_id_s object_qualifier_opt subtype_md renames) 
I RenameExc(def_id_s renames) 
i RenameUnitDecl(rename_unit) 


rename_unit: EmptyRenameUnit() 

I RenamePkg(generic_hdr compound_name renames) 

I RenameSubprog(generic_hdr subprog_spec renames) 


renames : Renames(name) 


optional generic_hdr; 
generic_hdr: GenericHdrNil() 

I GenericHdrPromptO 
I GenericHdr(generic_fonnal_part) 


optional list generic_formal_part; 
generic_formal_part: GenericNil() 

I GenFormalList(generic_formal generic_formal_part) 


generic_formal: Empty GenFormalQ 

I GenParm(param) 

I GenTypeParm(identifier generic_discrim_part_opt generic_type_def) 
I GenProcParm(identifier formal_part_opt subp_default) 

I GerLFuncParm(designator formal_part_opt name subp_default) 

I GenPkgParmBox(identifier name) 

I GenPkgParm(identifier name) 

I GenUseparm(use_clause) 


optional generic_discrim_part_opt; 
generic_discrim_part_opt: GenDiscOptNull() 

I GenDiscOptPromptO 
I GenDisc(discrim_spec_s) 
I GenBoxO 


62 


optional subp_default; 
subp_detault: SubpDefaultNull() 

I SubpDefaultPromptO 
I SubpDefName(name) 
I SubpDefBoxO 


generic_type_def: EmptyGenTypeDef() 

I GenTypeBoxO 
I GenTypeRangeBoxO 
I GenTypeModBoxQ 
I GenTypeDeltaBoxO 
I GenTypeDeltaDigBoxO 
I GenTypeDigitsBoxO 
I GenTypeArray (array_type) 

I GenTypeAccess(access_type) 

I GenTypePriv(private_type) 

I GenTypeDerived(generic_derived_lype) 


generic_derived_type: EmptyGenDerType() 

I GenDerivedSubt(subtype_md) 

I GenDerivedSubtPriv(subtype_ind) 
I GenDerivedAbst(subtype_ind) 


integer: IntNull() 

I Integer(INTEGER) 


access_lype ; EmptyAccessTypeQ 

I AccessSubtype(subtype_ind) 

I AccessConstSubtype(subtype_ind) 

I AccessAIlSubtype(subtype_ind) 

I AccessProcedure(prot_opt fonnal_part_opt) 

I Access?unction(prot_opt fonnal_part_opt mark) 


optional prot_opt; 
prot_opt; ProtOptNullO 

I ProtOptPromptO 
I ProtectedO 


body_stub : Empt\'BodyStub() 

I TaskStub(identifier) 

I PkgStub(compound_name) 

I SubprogStub(subprog_spec) 
I ProtStub(identifier) 


63 






generic_inst: Genlnst(name) 


jifi it:)|c:(c:|e9t;3|c9|c:|c3(c3t:9»::4c9t:3»:**9t:**********9|e4(3(«***«*4:4:3tc:|e)ie:|e:4e4:]4e^]4e:4e)tcJks|c9te:tc*)(e4:it:3fc9|c4;9|c9|c4e:ie*:<c:|c9|e9|e***/ 

l:fp. 9»;s»;3)c*9(:9tc3l(*9t:9t(****9k*9»;**iie9K*»i<:4:*9tc***3fe3»:4:4!9*::te*4:3fc**3|e)|c;tc9|e:|:4:}(c](c9|e:(e:|e9ie9|e9|e3|e^9(e:|e4c9|e4:4;9|c9»:9|c:4c9(:«:|c9|e:(c^ 
9K9ie9|e*4:**3|(******9k3K***9|«»K4:i|c4:*9Ki((*4!9t:)((*3(E3lc4:4;3tc3|c3|e3|e:f::4c:fc3|c:tc:|c:(e:4e4e:4e9fe:4c:4e:|c:t::4c:le:4e9(e%3)e9tc:4c:^9le:^9|c:^9^3f::^^ 


/* File: abstract.psdl.ssl */ 

/* Date: 3 March, 1995 */ 

/* Author: Chris Eagle */ 

/* System: Sun SPARCstation */ 

/* Description: This file contains the abstract syntax definitions */ 

/* for the PSDL language. These productions are used to */ 

/* provide attribution for an Ada 9x abstract syntax tree */ 

/* with the resulting display providing the translation from */ 

/* Ada 9x to PSDL */ 


ieifif1Hfifiti^1Hf:iHHfif^:tfif******^******iHf******it^*******iFit^*if*********************l 

optional psdl; 
psdl: EmptyPsdlO 

I PsdlPHO 

I Component(component) 


list component_s; 
component_s : ComponentNil() 

I ComponentList(component.component_s) 

j 

component: CompDataType(data_type) 

I CompOperator(operator_imp) 


data_type : DataType(compound_name type_spec type_impl) 

type_spec : TypeSpec(generic_type_decl type_decl_opt op_list_opt 
ftinctionality) 

optional generic_type_decl; 
generic_type_decl: GTDNil() 

I GTD_PH() 

I GTD(type_decl_s) 


optional type_decl_opt; 
type_decl_opt: TDO_Nil() 


64 






I TDO_PH() 

I TDO(type_decl_s) 


optional list op_list_opt; 
op_list_opt: OLO_Nil() 

I OLO_Cons(operator op_list_opt) 


operator: Empty Operator() 

I PsdlOp(compound_name operator_spec) 


operator_imp : OperatorImp(operator operator_impl) 


operator_spec : OpSpec(interface_s functionality) 


optional list interface_s; 
interface_s : Interface_s_Nil() 

I InterfaceList(interface interface_s) 


interface: EmptyInterface() 

1 Interface(attribute reqmts_trace) 


attribute : Generics, Inputs, Outputs(type_decl_s) 

I States(type_decl_s initial_expression_list) 
I Excpts(def_id_s) 

I MET(time_unit) 


/* this list unparses with a carriage return between elements */ 
list type_decl_s; 
type_decl_s : TypeDeclNil() 

i TypeDeclList(type_decl type_decl_s) 


/* this list unparses with no carriage return between elements */ 
list type_decl_s2; 
type_decl_s2 : TypeDeclNil2() 

I TypeDeclList2(type_decl type_decl_s2) 


type_decl: TypeDeclPSDL(def_id_s type_name) 
I EmptyTypeDeclO 


type_name ; Empty TypeName() 


65 







I TN_Id(identifier) 

1 TN_Array (identifier type_decl_s2) 


optional reqmts_trace; 
reqints_trace : RqmtsNil() 

I Rqmts_PH() 

/* I Rqmts(def_id_s)*/ 


optional functionality; 
functionality : FuncNil() 

I FuncPHO 

/* I Fimctionality(keywords informal_desc formal_desc)*/ 


/* 


optional keywords; 
keywords : KW_Nil() 


I KW_PH() 

I Keywords(def_id_s) 


optional infonnal_desc; 
infonnal_desc : ID_Nil() 

I ID_PH() 

I InfDesc(text) 


optional fonnal_desc; 
formal_desc : FD_Nil() 


I FD_PH() 

I FoiTnalDesc(text) 


*/ 

type_impl: AdaTypeImp(compound_naine) 

/* i Typelmpl(type_name op_inip_s)*/ 


operator_impl: AdaOpImp(compound_naine) 

I Empty Impl() 

/* I PsdlOpImpl(psdl_impl)*/ 


list initial_expression_list; 
initial_expression_list: InitExpNil() 

I InitExpList(initial_expression initial_expression_list) 


initial_expression: ExpTrue, ExpFalse() 


66 




I Explnt(mteger) 

I ExpReal(REAL_CS) 

I ExpStr(QUOTED_STRING) 
i Expld(identifier) 

I ExpType(type_name identifier opt_init_exp_list) 

I ExpInitExp(initial_expression) 

I ExpBinOp(initial_expression binary _op initial_expression) 
I ExpUnary(unary_op initial_expression) 


optional opt_init_exp_list; 
opt_init_exp_list; optListNil() 

I optListPromptO 
I optList(initial_expression_list) 


binary op ; PsdlAnd, PsdlOr, PsdlXor, PsdlLT, PsdlGT, 

PsdlEQ, PsdlGTEQ, PsdILTEQ, PsdlNE, PsdlAdd, 
PsdlSub, PsdlCat, PsdlMul, PsdlDiv, PsdlMod, 
PsdlRem, PsdIExpO 


unary_op : PsdlNot, PsdlAbs, PsdlNeg, PsdlPos() 


time_unit: TimeuSec, TimeMs, TimeSec, TimeMin, TimeHrs(integer) 


67 







68 





APPENDIX B. SSL SOURCE CODE: UNPARSING RULES 


The source code below comprises three files which specify the unparsing rules for 
Ada 95 package specifications and for PSDL. 




/* File: 

unparse. ada9x.ssl 

*/ 

/* Date: 

3 March, 1995 

*/ 

/* Author: 

Chris Eagle 

*/ 

/* System: 

Sun SPARCstation 

*/ 

/* Description: 

This file contains the unparsing rules for that 

*/ 

/* portion of the Ada9x language which is required for 

*/ 

/* package specifications. It was derived from the YACC 

*/ 

/* grammar noted below. 

*/ 


/♦***♦** YACC grammar for Ada 9X ♦♦♦’•‘♦♦♦♦♦■t'*****************************/ 
/* Copyright (C) Intermetrics, Inc. 1994 Cambridge, MA USA */ 

/* Copying permitted if accompanied by this statement. */ 

/* Derivative works are permitted if accompanied by this statement. */ 

/* This grammar is thought to be correct as of May 1, 1994 */ 

/* but as usual there is *no warranty* to that effect. */ 

style Keyword, Placeholder; 

identifier : IdNull[@ ::= “<%S(Placeholder:identifier%S)>”] 

I Ident['' ;;= 


integer : IntNull[@ ::= “<%S(Placeholder:integer%S)>”] 
I Integer[^ : := 


compilation : CompilationNil[@ ; “<%S(Placeholder:compilation%S)>”] 
i Compilation[@ : @ @] 


comp_unit_list: CUListNil[@ :] 
I CUList[@ ::= ^ @] 


pragma : EmptyPragma[''; “<%S(Placeholder:pragma%S)>%n”] 

I Pragmald[(2). :;= “%S(Keyword:PRAGMA%S) “ @ 

‘■;%n—TRANSLATION_ERROR: pragmas do not translate to PSDL%n”] 

I PragmaSimple[@ ::= ““/oSCKeywordiPRAGMAyoS) “ @ “(“ @ 

‘0;%n—TRANSLATION_ERROR: pragmas do not translate to PSDL%n”] 






pragma_arg_s : PragmaArgNil[@ :] 

I PragmaSargList[@ ::= [“, “] @] 


pragma_arg ; EniptyPragmaArg['': “<%S(Placeholder;pragma arg%S)>”] 
i PragmaExp[@ ::= @] 

I PragmaNameExp[@ @ 


pragina_s ; PragmasNil[@ :] 

I PragmasList[@ :;= [“%n"] @] 


decl : EmptyDecl['': “<%S(Placeholder:declaration%S)>”] 

I ObjDecl['': @ @ @ @ 

I NumDecU'': @ : %S(Keyword:CONSTANT%S) := “ @ 

I TypeDecir : “%S(Keyword:TYPE%S) “ @ @ @ 

I SubTypeDecl[^ : “%S(Keyword:SUBTYPE%S) “ @ “ IS “ @ 
I SubProgDecl[^; @] 

I PkgDec^* : @] 

I TaskDecir ; @ 

I ProtDecl[^ ; @ 

I ExcDecl['^: @ ; %S(Keyword;EXCEPTION%S);”] 

I RenanieDecl[''; @] 

I BodyStubDecl['': @] 


def_id_s : DefldNiU® :] 

|DefldList[@ “] @] 


object_qualifier_opt: ObjQualOptNull[@:] 

I ObjQualOptPrompt[@ ::= “<%S(Placeholder:qualifier%S)>”] 

I Aliased[^ : “%S(Keyword:ALIASED%S) “] 

I Constant[^ : “%S(Keyword:CONSTANT%S) “] 

I AliasedConst[^ ; “%S(Keyword:ALIASED CONSTANT%S) “] 


object_subtype_def: EmptySubtypeDef[@ ;:= 

“<%S(Placeholder:object subttype def%S)>”] 
I Subtypelnd[@ : := @] 

I ArrayType[@ ::= @] 


init_opt: InitOptNull[@ :] 

I InitOptPrompt[@ ::= •■<%S(Placeholder:iiiitializer%S)>”] 
I ExprInitOpt[@ ::= “ ;= “ @] 


discrim_part_opt: DiscrimPartNull[@;] 

I DiscrimPartPrompt[@ ::= “<%S(Placeholder:discriminant%S)>”] 


70 




I DiscrimPart[@ ::= “ @] 
|Box[@ ::=“(<>)”] 


type_completion: TypeComplNull[@ ;] 

I TypeComplPrompt[''; “<%S(Placeholder;type%S)>”] 
I TypeDefCompl[@ “ %S(Keyword;IS%S) “ @] 


type def: EmptyTypeDeff'': “<%S(Placeholder:type def%S)>”] 
I EnumTypeDef[^ : “(“ @ “)”] 

I IntTypeDef[''; @] 

I RealTypeDef[^; @] 

I Array TypeDef[''; @] 

I RecordType[''; @ @ @] 

I AccessTypeDef[''; @] 

I DerivedTypeDef['': @] 

I PrivateTypeDetp : @] 


subtype_ind : EmptySubtlnd[@ ::= “<%S(Placeholder:subtype_ind%S)>”] 
I SubtypeIndConstraint[@ ::= @ @] 

I SubTypeIndName[@ ;:= @] 


constraint: Empty Constraint : “<%S(Placeholder:constraint%S)>”] 
I RangeConstraint[@ : := @] 

I DecDigConstraint[@ ;:= “ %S(Keyword:DIGITS%S) “ @ @] 


derived_type : EmptyDerivedType['': ■‘<%S(Placeholder;derived type%S)>”] 

I NewDerivedType['': “%S(Keyword:NEW%S) “ @ ] 

I NewDerivedWithPrivate[^ : “%S(Keyword:NEW%S) “ @ 

“ %S(Keyword: WITH PRIVATE%S)”] 

I NewDerivedWithRecord[* : “%S(Keyword:NEW%S) “ @ 

“ %S(Keyword:WITH%S) “ @ ] 

I AbsNewDerivedWithPrivate['': “%S(Keyword;ABSTRACT NEW%S) “ @ 
“ %S(Keyword; WITH PRIVATE%S)”] 

I AbsNewDerivedWithRecord['': “%S(Keyword:ABSTRACT NEW%S) “ @ 
“ %S(Keyword;WITH%S) “ @ ] 


range_constraint: Range[@ ::= ■‘%S(Keyword:RANGE%S) “ @] 


range : Empty'Range['': “<%S(Placeholder:range%S)>”] 

I SimpleRange['': @ @] 

I NameTicRange[^ : @ ‘“%S(Keyword:RANGE%S)”] 

I NameTicRangeExp[^ ; @ -““/oSCKeywordiRANGE^/oSX" @ “)”] 


71 





enum_id_s : EnumIdNil[@ :] 

I EnumIdList[@ ::= ^ “] @] 


enum_id : EmptyEnumld[@ ;:= “<%S(Placeholder;enumeration id%S)>”] 

I Id[@ ::= @] 

I CharLit[@ ;:= @] 


mteger_type : EmptyIntType[@ :;= “<%S(Placeholder:mt type%S)>”] 
I RangeSpec[@ ;;= @] 

I ModExpr[@ ;;= “ %S(Keyword:MOD%S) “ @] 


range_spec : RangeSpecConstr[@ ::= @] 


range_spec_opt: RangeSpecOptNull[@:] 

I RangeSpecOptPrompt[@ :;= “<%S(Placeholder:range specifier%S)>”] 
I RangeSpecOpt[@ ;:= “ “ @] 


real_type ; EmptyRealType[@ ::= “<%S(Placeholder:real type%S)>”] 
I FloatType[@ ::= “%S(Keyword;DIGITS%S) “ @ “ “ @] 

I FixedType[@ 


fixed_type : EmptyFixedType[@ ::= “<%S(Placeholder:fixed_1ype%S)>”] 
I FixedDelta[@ “%S(Keyword:DELTA%S) “ @ “ “ @] 

I FixedDeltaDigits[@ ::= “%S(Keyword;DELTA%S) “ @ 

“ %S(Keyword:DIGITS®/oS) “ @ @] 


array_type : EmptyArrayType[@ ::= “<%S(Placeholder;array type%S)>”] 
I UnconstrArray[@ ::= “%S(Keyword:ARRAY%S) (“ @ 

“) %S(Keyword:OF%S) “ @] 
i ConstrArray[@ ;:= “%S(Keyword:ARRAY%S) (“ @ 

“) %S(Keyword:OF%S) “ @] 


component_subtype_def: CompSubtypeDef[@ ;:= @ @] 


aliased_opt; AliasedOptNull[@ :] 

I AliasedOptPrompt[@ ::= “<%S(Placeholder:aliased%S)>”] 
I AliasedOpt[^ : “%S(Keyword:ALIASED%S) “] 


mdex_s : IndexNil[@,:] 

I IndexList[@ ^ “ %S(Keyword:RANGE%S) o” [“, “] @] 


72 






iter_discrete_range_s: DiscreteRangeNil[@:] 
I DiscreteRangeList[@ ::= '' [“, “] @] 


discrete_range : EmptyDiscRng[@ ::= “<%S(Placeholder;discrete range%S)>”] 
I DiscRangeName[@ ::= @ @] 

I DiscRangeRange[@ ;;= @] 


range_constr_opt: EmptyRangeConstrOpt[@ ::= 

“<%S(Placeholder;range constraint%S)>”] 
1 RangeConstr[@ ::= " “ @] 


record_def: EmptyRecordDef[@ ::= “<%S(Placeholder:record def%S)>”] 
I Record[@ ::= “%S(Keyword:RECORD%S)%t%n” @ @ 
“%b%n%S(Keyword:END RECORD%S)”] 

I NullRecord[^ : “%S(Keyword:NULL RECORD%S)”] 


tagged_opt: TaggedOptNull[@ :] 

I TaggedOptPrompt[@ ::= “<%S(Placeholder:tagged%S)>”] 

I Tagged['': “%S(Keyword:TAGGED%S) “] 

I AbstractTagged['^: “%S(Keyword:ABSTRACT TAGGED%S) “] 


compjist: EmptyCompList[@ ::= “<%S(Placeholder:comp list%S)>”] 
I CompListWithVariant[@ ::= @ @] 

I CompListWithPragma[@ @ 

I NullWithPragma[@ “ %S(Keyword:NULL%S);%n” @] 


comp_decl_s ; CompDeclNil[@ :] 

I CompDecl[@ :;= @] 

I CompDeclList[@ ;:= @ @ @] 


variant_part_opt: EmptyVariantPart[@ :;= “<%S(Placeholder:variant part%S)>”] 
1 VariantPartOptPragma[@ :;= @] 

I VariantPartOpt[@ ::= @ @] 


comp_decl: CompDeclDels[@ ::= @ @ “;%n”] 


discrim_spec_s : DiscriniSpecNil[@ :] 

I DiscrimSpecList[@ ::= ^ [“;%n”] @] 

discrim_spec : DiscrimSpecDel]^®, ::= @ “ @ @ f®] 


73 



access_opt: AccessOptNull[@ :] 

I AccessOptPrompt[@ ;;= “<%S(Placeholder;access%S)>”] 
I AccessOpt[^ : “%S(Keyword;ACCESS%S) “] 


variant_part: VariantPart[@ ::= “%S(Keyword:CASE%S) “ @ 
“ %S(Keyword;IS%S)%t%n” @ @ 
“%b%n%S(Keyword:END CASE%S);%n”] 


variant_s : VariantNil[@ :] 

I VariantList[@ ::='' [“%n”] @] 


variant; VariantChoice[@ “%S(Keyword:WHEN%S) “ @ “ =>%t%n” @ @ “%b”] 


choice_s : ChoiceNil[@ :] 

1 ChoiceList[@ :;= [“ | “] @] 


choice : EmptyChoice[@ ::= “<%S(Placeholder:choice%S)>”] 
I ChoiceExpr[@ : ;= @] 

I ChoiceRange[@ ::= @] 

I ChoiceOthers['': “%S(Keyword:OTHERS%S)”] 


discrete_with_range : DiscreteNameRange[@ @ “ @] 
I DiscreteWithRange[@ ::= @] 


access_type ; EmptyAccessType[^ : “<%S(Placeholder:access type%S)>”] 

I AccessSubtype[^ : “%S(Keyword:ACCESS%S) “ @] 

I AccessConstSubtype[''; “%S(Keyword:ACCESS CONSTANT%S) “ @] 
I AccessAllSubtype['': “%S(Keyword:ACCESS ALL%S) “ @] 

I AccessProcedure[^ : “%S(Keyword:ACCESS%S) “ @ 

“ %S(Keyword:PROCEDURE%S) “ @] 
i AccessFunction['': ■‘%S(Keyword:ACCESS%S) “ @ 
%S(Keyword:FUNCTION%S) “ @ 

“ %S(Keyword:RETURN%S) “ @ “%n”] 


prot_opt: ProtOptNull[@ :] 

I ProtOptPrompt[@ :;= ■'<%S(Placeholder:protected%S)> “] 
1 Protected['': “ %S(Keyword:PROTECTED%S) “] 


decl_item_s: DeclListNil[@ :] 


74 




I DeclList[@ ::= '' [“%n%n”] @] 


decl_item : EinptyDeclItem[@ "<%S(Placeholder:decl item%S)>‘‘I 
I Decl[@ ::= @] 

I UseClauseDecl[@ :;= @] 

I DeclRepSpec[@ ::= @] 

I DeclPragma[@ : := @] 


name : EmptyName[@ ::= “<%S(Placeholder:name%S)>”] 
I SimpleName[@ @] 

I IndexComp[@ ::= @ “(“ @ “)”] 

I SelectedComp[@ : := @] 

I Attribute[@ ::= @ @] 

I OperatorSymbol[@ ::= @] 


marie: EmptyMark[@ ::= “<%S(Placeholder:mark%S)>”] 
I Mark[@ ::= @ @] 


tiedot: TicDotNil[@ ;:= ] 

I TicDotPH[@ ;:= “<%S(Placeholder:’ATTR or .ID%S)>”] 
|TicOpt[@ ::=“V”@] 

I DotOpt[(2), @] 


marklist: MarkListNil[@ ::=] 
I MarkList[@ ::= ^ @] 


compound_name : EmptyCompound[@ :] 
I DotCompound[@ ;:='' @] 


c_name_Iist; CompoundNameNil[@ :] 
I CompoundList[@ ::= ^ [“, “] @] 


value_s; ValueNil[@ :] 

I ValueList[@ '' [“, “] @] 


value : EmptyValue[@ ■‘<%S(Placeholder:value%S)>”] 
I ValueExpr[(3) ::= @] 

I ValueCompAssoc[@ ::= 

I ValueDiscWithRange[@, (5)] 


selected_comp : EmptySelComp[@ ■■<%S(Placeholder:selected component%S)>”] 


75 









I DotId[@ ::= @ @] 

I DotUsedChar[@ ::= @ @] 

I DotString[@ ;;= @ @] 

I DotAll[@ ::= @ “.%S(Keyword;ALL%S)”] 


attribute_id : EmptyAttribld[@ :;= “<%S(Placeholder:attribute id%S)>”] 
I Attribld[@ ;:= @] 

I AttribDigits['': “%S(Keyword;DIGITS%S)”] 

I AttribDelta['': “%S(Keyword:DELTA%S)”] 

I AttribAccess[''; “%S(Keyword:ACCESS%S)”] 


numeric_lit; IntLit[@ :;= @] 
I ReaILit[@ ::= @] 


literal : EmptyLiteral[@ :;= “<%S(Placeholder;literal%S)>”] 
I NumLit[@ ;:= @] 

I UsedChar[@ ;:= @] 

I NilLit[^: “%S(Keyword:NULL%S)”] 


aggregate : EmptyAggregate[@ ::= “<%S(Placeholder;aggregate%S)>”] 

I AggCompAssoc[@ ::= “(“ @ “)”] 

I AggValues2[@ : := “(“ @ “)”] 

I AggExprValue[@ ;;= “(" @ “ %S(Keyword;WITH%S) “ @ “)”] 

I AggExprWithNull[@ :;= “(“ @ “ %S(Keyword:WITH NULL RECORD%S))”] 
I AggExpNullRec['': “(%S(Keyword:NULL RECORD%S))”] 


value_s_2 : ValueS2Pair[@ ::= @ “ @] 

I ValueS2List[@ ::= @ “ @] 

comp_assoc ; CompAssoc[@ :;= @ “ => “ @] 


expression ; EmptyExpression[@ ;:= “<%S(Placeholder;expression%S)>”] 
I Relation[@ ;;= @] 

I And[@ ::= @ “ %S(Keyword:AND%S) “ @] 

I Or[@'?;= %S(Keyword:OR%S) “ @] 

I Xor[@ @ “ %S(Keyword;XOR%S) “ @] 

I AndThen[@ :;= @ “ %S(Keyword:AND THEN%S) “ @] 

I OrElse[ @'^:= @ “ %S(Keyword:OR ELSE%S) “ @] 


relation : Empty Relation [@ :;= ■■<%S(Placeholder;relation%S)>”] 
I SimpleExpr[@ ;:= @] 

I Equal [@ ::= @ “ = " @] 

I NotEqual[@ @ " /= " @] 


76 





I LessThan[@ : @ “ @] 

I LessThanEq[@ : := @ “ <= “ @] 

I GreaterThan[@ @ “ @] 

I GreaterThanEq[@ @ “ >= “ @] 
I RangeMember[@ ::= @ @ @] 

I NameMember[@ ::= @ @ @] 


membership : EmptyMembr[@ ::= “<%S(Placeholder:mbr op%S)>”] 
I In['': “ %S(Keyword:IN%S) “] 

I NotIn['': “ %S(Keyword:NOT IN%S) “] 


simple_expression : EmptySimple[@ ::= “<%S(Placeholder;simple expr%S)>”] 
|Term[@::=@@] 

I Addition[@ ::= @ “ + “ @] 

I Subtraction[@ ;;= @ “ @] 

I Concat[@ : @ “ @] 


unary : Unary Null [@ :] 

I UnaryPrompt[@ ::= “<%S(Placeholder:unary op%S)>”] 
I Plus['': “+”] 

I Minus['': 


term : EmptyTerm[@ ::= “<%S(Placeholder:tenn%S)>”] 
I Factor[@ 

|Mult[@::=@“*“@] 

|Dmde[@::=@“/“@] 

I Mod[@ @ “ %S(Keyword:MOD%S) “ @] 

I Rem[@ ::= @ “ %S(Keyword:REM%S) “ @] 


factor : EmptyFactor[@ :;= ‘■<%S(Placeholder:factoi%S)>”] 
I Primary [@ ::= @] 

I NotPrimary[@ ::= “%S(Keyword:NOT%S) “ @] 

I AbsPrimary[@ ;;= “%S(Keyword:ABS%S) “ @] 

I Expon[@ ::= @ “ ** “ @] 


primary : Empty Primary [@ ::= “<%S(Placehotder:primary%S)>”] 
I Literal[@ ::= @] 

I PrimaryName[@ ::= @] 

I Allocator[(3), ::= @] 

I Qualified[@ :;= @] 

I Parens[@ ::= “C @ ■‘)"] 

I PrimaryAgg[@ : := @] 


qualified : Empt\'Qual[@ ::= “<%S(Placeholder:qualified%S)>”] 


77 






I NaineTicAgg[@ @ @] 

I NameTicExpr[@ ::= @ "‘C @ “)’ ] 


allocator : newName[@ ::= “%S(Keyword:NEW%S) “ @] 
I NewQualified[@ ::= “%S(Keyword:NEW%S) “ @] 


subprog_decl: EmptySubpDecl[@ ::= “<%S(Placeholder:subprog decl%S)>”] 

I SubprogSpec[@ ::= @ @ @] 

I GenericSubprogInst[@ @ “ %S(Keyword:IS%S) “ @ @] 

I AbstractSubprogSpec[@ @ “ %S(Keyword;IS ABSTRACT%S);” @] 


psdl_met_opt: MetNull[@ :] 

I MetPrompt[@ ::= “%n<%S(Placeholder:psdl met%S)>”] 

I MetUsec[@ ::= “%n -PSDL MAXIMUM EXECUTION TIME “ @ “ MICROSEC”] 
I MetMs[@ ::= “%n -PSDL MAXIMUM EXECUTION TIME “ @ “ MS”] 

I MetSec[@ ::= “%n -PSDL MAXIMUM EXECUTION TIME “ @ “ SEC”] 

I MetMin[@ ::= “%n -PSDL MAXIMUM EXECUTION TIME “ @ “ MIN”] 

I MetHrs[@ ::= “%n -PSDL MAXIMUM EXECUTION TIME “ @ “ HOURS”] 


subprog_spec : EmptySubpSpec[@ ::= ”<%S(Placeholder:subprog spec%S)>”] 

I SubProgProc[@ ;:= “%S(Keyword:PROCEDURE%S) “ @ @] 

I SubProgFuncRetum[@ ::= “®/oS(Keyword:FUNCTION%S) “ @ @ 

“ ®/oS(Keyword:RETURN«/oS) “ @ 

“;®/on-TRANSLATION_ERROR: Functions do not translate to PSDL”] 
I SubProgFunc[@ ::= “«/oS(Keyword:FUNCTION»/oS) “ @ 

“;«/on-TRANSLATION_ERROR; Functions do not translate to PSDL”] 


designator : EmptyDesignator[@ ::= “<%S(PlacehoIder:designator%S)>”] 
I DesigCompound[@ ;;= @] 

I DesigString[@ ::= @] 


formal_part_opt: FormalPartOptNull[@:] 

I FormalPartOptPrompt[@ ::= “<®/oS(Placeholder:formals®^S)>”] 
I FormalPart[@ ::= “(“ @ ”)”] 


param_s : ParamNil[@ :] 

I ParamList[@ ::= ^ [“; “] @] 


param : Paramld[@ ::= (3), “ : “ @ @ @] 


mode : ModeNull[@ :] 

I ModePrompt[@ ::= ”<%S(Placeholder:mode%S)>”] 


78 





I InMode[^ : “%S(Keyword:IN%S) “] 

I OutMode[^ : “%S(Keyword:OUT%S) "] 

I InOutMode[^ : “%S(Keyword:IN OUT%S) “] 
i AccessMode['': “%S(Keyword:ACCESS%S) “] 


pkg_decl: EmptyPkgDecl[@ ::= “<%S(Placeholder:pkg decl%S)>”] 

I PkgSpec[@ ::= @ @ “;%n”] 

I GenPkgInst[@ ;:= “%S(Keyword:PACKAGE%S) “ @ “ %S(Keyword:IS%S) “ @] 


pkg_spec : Package[@ ;;= “%S(Keyword:PACKAGE%S) “ @ 

“ %S(Keyword:IS%S)%t%n” @ @ 
“%b%n%S(Keyword:END%S) “ compound_name] 


private_part: PrivatePartNull[@ :] 

I PrivatePartPrompt[@ ::= “%n<%S(Placeholder:private pait%S)>”] 
I Private[@ ::= “%n%S(Keyword;PRIVATE%S)%t%n” @] 


private_type : PrivateType[@ “%S(Keyword:PRIVATE%S)”] 


limited_opt: LimitedOptNull[@ :] 

I LimitedOptPrompt[@ ::= “<%S(Placeholder:limited%S)>”] 
I Limited[@ ::= “%S(Keyword:LIMITED%S) “] 


use_clause : EmptyUseC[@ ::= “<%S(Placeholder;use clause%S)>”] 
I Use[@ "%S(Keyword:USE%S) “ @ “;%n”] 

I UseTypet® ;;= “%S(Keyword:USE TYPE%S) “ @ “;%n”] 


name_s: NameNil[@ :] 

I nameList[@ ::= [“, “] @] 


rename_decl: EmptyRenameDecl[@ ::= “<%S(Placeholder:rename decl%S)>”] 
I RenameDeclSub[@ ;:= @ “ : “ @ “ “ @ 

I RenameExc[@ ::= @ “ : %S(Keyword:EXCEPTION%S) “ @ 

I RenameUnitDecl[@ ::= @] 


rename_unit: EmptyRenameUnit[@ ::= ■‘<%S(Placeholder:rename unit%S)>”] 
I RenamePkg[@ ::= ® ■'%S(Keyword:PACKAGE%S) “ @ “ " @ 
i RenameSubprog[@ :;= @ @ “ “ @ 


renames : Renames[@ ::= ■‘%S(Keyword:RENAMES%S) “ @] 


79 



task_def {inh identifier idopt;}; 

task_spec : EmptyTaskSpec[@ ::= “<%S(Placeholder:task spec%S)>”] 
I Simple!ask[@ ::= “%S(Keyword;TASK%S) “ @ @] { 
task_def.idopt = identifier; 

} 

I TaskType[@ ;;= “%S(Keyword:TASK TYPE%S) “ @ @ @] { 
task_def. idopt = identifier; 

} 


task_def: TaskDefNull[@:] 

I TaskDefPrompt[@ ::= “<%S(Placeholder:task def%S)>”] 
I TaskDef[@ ::= “ %S(Keyword:IS%S)%t%n” @ @ @ 
“%b%n%S(Keyword:END%S) “ 
task_def.idopt] 


task_private_opt: TaskPvtOptNull[@:] 

I TaskPvtOptPrompt[@ “<%S(PlacehoIder:task private%S)>”] 
I TaskPvtOpt[@ “%S(Keyword:PRIVATE%S)%n” @ @] 


prot_def {inh identifier idopt;}; 

prot_spec : EmptyProtSpec[@ ::= “<%S(Placeholder:protected spec%S)>”] 

I Prot[@ ::= “%S(Keyword:PROTECTED%S) “ @ @] { 
prot_def. idopt = identifier; 

} 

I ProtType[@ ;:= “%S(Keyword;PROTECTED TYPE%S) “ @ @ @] { 
prot_def.idopt = identifier; 

} 


prot_def: ProtDef[@ “ %S(Keyword:IS%S)%t%n” @ @ 
“%b%n%S(Keyword:END%S) “ 
prot_def idopt] 


prot_private_opt: ProtPvtOptNull[@ :] 

I ProtPvtOptPrompt[@ ::= “<%S(Placeholder;protected private%S)>”] 
I ProtPvtOpt[@ ::= “%S(Keyword:PRIVATE%S)%t%n” @] 


prot_op_decl_s : ProtOptDeclListNil[(2):] 
i ProtOptDecIList[@ ::= ^ [“%n”] @] 


prot_op_decl: EmptyProtOpDecl[@ ::=''<%S(Placeholder:prot op%S)>”] 
I Entiy'Decl[@ ::= (5),] 


80 




I ProtOptSubprog[@ ::= @ “;%n”] 
I RepSpec[@ ::= @] 

I ProtOptPragma[@ : := @] 


prot_elem_decl_s: ProtElemDeclNil[@ ;] 

I ProtElemDeclList[@ ::= [“%n”] @] 


prot_elem_decl: EmptyProtElem[@ ;;= “<%S(Placeholder:prot elem%S)>”] 
I ProtOptDecl[@ ::= @] 

I ProtElemCompDecl[@ ::= @] 


entry_decl_s : EntryDeclPragma[@ ::= @] 

I EntryDeclPragmaList[@ ::= @ @ @] 


entry _decl: Empty Entry Decl[@ ::= “<%S(Placeholder:entiy decl%S)>”] 
I EntryDeclld[@ ::= “%S(Keyword:ENTRY%S) “ @ @ “;%n”] 

I EntryRange[@ ::= “%S(Keyword:ENTRY%S) “ @ “(“ @ “)” @ 


rep_spec_s: RepSpecNull[@ :] 

I RepSpecPrompt[@ “<%S(Placeholder:representation specs%S)>”] 
I RepSpecList[@ : := @ @ @] 


comp_unit: CompUnit[@ ::= @ @ “%n” @ “%n” @] 


private_opt: PrivateOptNuIl[@ :] 

I PrivateOptPrompt[@ ::= “<%S(Placeholder:private%S)>”] 
I PrivateOpt[@ ::= “%S(Keyword:PRIVATE%S)”] 


context_spec_opt: ContextSpecNull[@ :] 

I ContextSpecPrompt[@ ::= “<%S(Placeholder:context spec opt%S)>%n”] 
I ContextSpec[@ : := @ “%n”] 


context_spec ; EmptyContextSpec[@ ::= “<%S(Placeholder:context spec%S)>”] 
I ContextWithUse[@ ::= @ @, @] 

I ContextPragma[@ ::= @@] 


with_clause : WithClause[@ ::= “%S(Keyword:WITH%S) “ @ “;%n”] 


use_clause_opt: UseClauseOptNil[@ :] 
I UseClause[@ ::= @] 


81 


body_stub : Empty Body Stub[@ ::= “<%S(Placeholder:body stub%S)>”] 
i TaskStub[@ ::= “%S(Keyword:TASK BODY%S) “ @ 

“ %S(Keyword:IS SEPARATE%S);%n”] 

I PkgStub[@ ::= “%S(Keyword:PACKAGE BODY%S) “ @ 

“ %S(Keyword;IS SEPARATE%S);%n”] 

I SubprogStub[@ @ “ %S(Keyword:IS SEPARATE%S);%n”] 

I ProtStub[@ ::= “%S(Keyword:PROTECTED BODY%S) “ @ 

“ %S(Keyword:IS SEPARATE%S);%n”] 


generic_hdr: CienericHdrNil[@ :] 

i GenericHdrPrompt[@ : “<%S(Placeholder:generic header%S)>%n”] 

I GenericHdr[@ ::= “%S(Keyword:GENERIC%S)%t%n” @ “%b%n”] 


generic_formal_part; GenericNil[@ :] 

I GenFormalList[@ ::= ^ [“%n”] @] 


generic_formal: EmptyGenFormal[@ ::= “<%S(Placeholder:generic formal%S)>”] 
I GenPann[@ ;:= @ 

“;%n~TRANSLATION_ERROR: Generic value parameters do not “ 
“translate to PSDL”] 

I GenTypeParm[@ ;:= “%S(Keyword:TYPE%S) “ @ @ 

“ %S(Keyword:IS%S) “ @ 

I GenProcParm[@ ::= “%S(Keyword:WITH PROCEDURE%S) “ @ @ @ 

I GenFuncParm[@ ::= “%S(Keyword:WITH FUNCTION%S) “ @ @ 

“ %S(Keyword:RETURN%S) “ @ @ 

I GenPkgParmBox[@ “%S(Keyword:WITH PACKAGE%S) “ @ 

“ %S(Keyword:IS NEW%S) “ @ 

“(o);%n-TRANSLATION_ERROR: Generic package parameters “ 
“do not translate to PSDL”] 

I GenPkgParm[@ :;= “%S(Keyword:WITH PACKAGE%S) “ @ 

“ %S(Keyword:IS NEW%S) “ @ 

“;%n~TRANSLATION_ERROR: Generic package parameters do not 
“translate to PSDL”] 

I GenUseparm[@ ::= @ 

“%n-fRANSLATION_ERROR: Generic Use clauses do not “ 
“translate to PSDL”] 


generic_discrim_part_opt; GenDiscOptNull[@ :] 

I GenDiscOptPrompt[@ ::= “<%S(Placeholder:discriminant%S)>”] 
I GenDisc[@ ::= “(“ @ “)”] 

I GenBox['': “(o)”] 


subp_default: SubpDefaultNull[@;] 

I SubpDefaultPrompt[@ :;= “<%S(Placeholder;default%S)>”] 


82 


I SubpDefName[@ ::= “ %S(Keyword:IS%S) “ @] 
I SubpDefBox[@ ;:= “ %S(Keyword:IS%S) o”] 


generic_type_def: EmptyGenTypeDef[@ ::= “<%S(Placeholder:generic type deP/oS)>”] 
I GenTypeBox['': “(<>)”] 

I GenTypeRangeBox['': “%S(Keyword:RANGE%S) o”] 

I GenTypeModBoxP : “%S(Keyword:MOD%S) o”] 

I GenTypeDeltaBox[^ : “%S(Keyword:DELTA%S) o”] 

I GenTypeDeltaDigBox[^; 

“%S(Keyword:DELTA%S) o %S(Keyword:DIGITS%S) o”] 

I GenTypeDigitsBox['': “%S(Keyword:DIGITS%S) o”] 

I GenTypeArray[@ ::= @] 

I GenTypeAccess[@ ::= @] 

I GenTypePriv[@ : := @] 

I GenTypeDerived[@ ;:= @] 


generic_derived_type ; EmptyGenDerType[@ :;= 

“<%S(Placeholder: generic derived type%S)>”] 

1 GenDerivedSubt[@ ;:= “%S(Keyword;NEW%S) “ @] 

I GenDerivedSubtPriv[@ ::= “%S(Keyword:NEW%S) “ @ 

“ %S(Keyword:WITH PRIVATE%S)”] 

I GenDerivedAbst[@ ::= “%S(Keyword:ABSTRACT NEW%S) “ @ 
“ %S(Keyword:WITH PRIVATE%S)”] 


generic_inst: Genlnst[@ ::= “%S(Keyword:NEW%S) “ @] 


rep_spec : EmptyRepSpec[@ “<%S(Placeholder:representation spec%S)>”] 

I AttribDef[@ “%S(Keyword:FOR%S) “ @ “ %S(Keyword:USE%S) “ @ “;%n”] 
I RecordTypeSpec[@ ::= “%S(Keyword:FOR%S) “ @ 

“ %S(Keyword:USE RECORD%S)%t%n” @ @ 

“%b%n%S(Keyword:END RECORD%S);%n”] 

I AddressSpec[@ ;:= “%S(Keyword:FOR%S) “ @ 

“ %S(Keyword:USE AT%S) “ @ “;%n”] 


align_opt: AlignOptNull[@ :] 

I AlignOptPrompt[@ ::= “<%S(Placeholder;align%S)>”] 

I AlignOpt[@ ::= “%S(Keyword:AT MOD%S) “ @ “;%n”] 


comp_loc_s: CompLocNull[@ :] 

I CompLocPrompt[® ::= “<%S(Placeholder:locations%S)>”] 
I CompLocList[@ ::= @ @ “ %S(Keyword:AT%S) “ @ 

“ %S(Keyword:RANGE%S) “ @ “;%n”] 


83 


ji/L 9(c:t:******3|c3|c:«:3t::(c3t;*3t:****9»::(e**9|c*:t:**********4c3(:)|c:4e3ie3|e9(C3t:******)f:**4:**«*****9tc*******/ 
jifi )je3|e3|e9|e:^i|e9|e9^9i:9(:9|e9|c9|e9|c:|c9|c:)c:^^:t;:4e%i|c)^4:9f::ie4:9i::le:)c:t;9t::)c)|e:|e4::(e9ic9|(:|e^4c*9t(9i(9)ct******^****************/ 


**i»:it;9|;)|c9|::|c:t:*******9»:***9f:*9|:«**********3*:3»:«*«*****«***:»:9<c**i|e*«*4:4:3t:************/ 

/* File: unparse.AdaToPsdl.ssl */ 

/♦Date: 3 March, 1995 */ 

/* Author: Chris Eagle */ 

/* System: Sun SPARCstation */ 

/♦ Description: This file contains the unparsing rule to display ♦/ 

/♦ the PSDL translation of an Ada 9x package specification. */ 

/♦ It was derived from the YACC grammar noted below. */ 

I* ;|e:|c:4‘3t‘*^3|e*3K3|c*3(e4:3|et*4:*3|‘3tE3tc**3f:*3t:*4e*4:4!3(e3tc:tc9tc:(c3t;ite3|e:|c:fc4c4ca)c]tc:(c3le:tc:fc]tc:tc#3le3t:%)tc>(c3(e*3t:**a|e)|c3|e:(c:t:3(e9|e:|e9|e^ 

^ YACC grainniar for Ada 9X ************♦*********=♦'*************♦**/ 
/* Copyright (C) Intermetrics, Inc. 1994 Cambridge, MA USA */ 

/* Copying permitted if accompanied by this statement. */ 

/* Derivative works are permitted if accompanied by this statement. */ 

/* This grammar is thought to be correct as of May 1, 1994 */ 

/* but as usual there is *no warranty* to that effect. */ 

view PSDL_VIEW; 

identifier : IdNull(PSDL_VIEW * : “<identifier>”] 

I Ident[PSDL_VIEW 
} 

integer : IntNull[PSDL_VTEW'': “<integer>”] 

I Integer[PSDL_VIEW 
> 

compilation : CompilationNil[PSDL_VIEW @ :] 

I Compilation[PSDL_VIEW @ : .. 

comp_unit_list: CUListNil[PSDL_VIEW @ ;] 

I CUList[PSDL_VIEW @ : := '^ “%n” 

pragma : EmptyPragma[PSDL_VIEW :] 

I PragmaId[PSDL_VIEW :..] 

I PragmaSimple[PSDL_VIEW'';....] 

pragma_arg_s : PragmaArgNil[PSDL_VIEW :] 

I PragmaSargList[PSDL_VIEW ^ : .. ..] 

pragma_arg : EmptyPragmaArg[PSDL_VIEW '':] 

I PragmaExp[PSDL_VIEW ^ : ..] 

I PragmaNameExp[PSDL_VIEW '': .. ..] 


84 




pragma_s ; PragmasNil[PSDL_VIEW :] 
I PragmasList[PSDL_VIEW 


decl ; EmptyDecl[PSDL_VIEW :] 

I ObjDecl[PSDL_VIEW ^ :.] 

I NumDecl[PSDL_VIEW 

I TypeDecl[PSDL_VIEW :.] 

I SubTypeDecl[PSDL_VIEW 
I SubProgDecl[PSDL_VIEW ''; “%n”] 
I PkgDeclCPSDL_VIEW ^ “%n”] 

I TaskDecl[PSDL_VIEW : ..] 

1 ProtDecl[PSDL_VIEW 
I ExcDecl[PSDL_VIEW 
1 RenameDecl[PSDL_VIEW 
I BodyStubDecl[PSDL_VIEW ^ 


def_id_s : DefldNil[PSDL_VIEW :] 

I DefIdListpSDL_VIEW [“, “] 


object_qualifier_opt: ObjQualOptNull[PSDL_VIEW :] 
I ObjQualOptPrompt[PSDL_VIEW'':] 

1 Aliased[PSDL_VIEW :] 

I Constant[PSDL_VIEW ^ :] 

I AliasedConst[PSDL_VIEW ^:] 


object_subtype_def: EmptySubtypeDef[PSDL_VIEW '':] 
I SubtypeInd[PSDL_VIEW ^ ;..] 

1 ArrayType[PSDL_VIEW : ..] 


init_opt: InitOptNulip’SDL_VIEW ^ :] 
I InitOptPrompt[PSDL_VIEW'':] 

1 ExprInitOpt[PSDL_VIEW 


discrim_part_opt: DiscrimPartNull[PSDL_VIEW :] 
I DiscrimPartPrompt[PSDL_VIEW ^;] 

I DiscrimPart[PSDL_VIEW 
I Box[PSDL_VIEW :] 


type_completion : TypeComplNull[PSDL_VIEW ^ :] 
I TypeComplPrompt[PSDL_VIEW ^:] 

I TypeDefCompl[PSDL_VIEW ^ 


85 










type_def: EmptyTypeDefp’SDL_VIEW '';] 
I EnumTypeDef[PSDL_VIEW 
I IntTypeDef[PSDL_VIEW 
I RealTypeDef[PSDL_VIEW 
I ArrayTypeDef[PSDL_VIEW 

I RecordType[PSDL_VIEW ^ :.] 

I AccessTypeDef[PSDL_VIEW ^ 

I DenvedfypeDef[PSDL_VIEW 
I PrivateTypeDef[PSDL_VIEW 


subtype_ind : EmptySubtInd(PSDL_VIEW :] 

I SubtypeIndConstraint[PSDL_VIEW ^ :....] 
I SubTypeIndName[PSDL_VIEW 


constraint: EmptyConstraint[PSDL_VIEW ^ ;] 
I RangeConstraint[PSDL_VIEW ^ 

I DecDigConstramt[PSDL_VIEW : ....] 


derived_type : EmptyDerivedType[PSDL_VIEW ^ :] 

I NewDerivedType[PSDL_VIEW ^ 

I NewDerivedWithPrivate[PSDL_VIEW ^ :..] 

I NewDerivedWithRecord[PSDL_VIEW :.. 

I AbsNewDerivedWithPrivate[PSDL_VIEW ^ :..] 

I AbsNewDerivedWithRecordlPSDL_VIEW :....] 


range_constraint: Range[PSDL_VIEW :..] 


range : EmptyRange[PSDL_VIEW ^ ;] 

I SimpleRange[PSDL_VIEW '':.. ..] 

I NameTicRange[PSDL_VIEW 
I NameTicRangeExp[PSDL_VIEW '':.. ..] 


enumjd_s : EnumIdNil[PSDL_VIEW ^ :] 
I EnumIdList[PSDL_VIEW 


enum_id : EmptyEnumId[PSDL_VIEW '';] 
I Id[PSDL_VIEW ^ : ..] 

I CharLit[PSDL_VIEW : ..] 


integer_type : EmptyIntType[PSDL_VIEW ^ :] 
I RangeSpec[PSDL_VIEW '':..] 

I ModExpr[PSDL_VIEW ''; 


86 






range_spec: RangeSpecConstr[PSDL_VIEW 


range_spec_opt: RangeSpecOptNull[PSDL_VIEW :] 
I RangeSpecOptPrompt[PSDL_VIEW ^:] 

I RangeSpecOpt[PSDL_VIEW : ..] 


real_type : EmptyRealType[PSDL_VIEW ;] 
I FloatType[PSDL_VIEW ;....] 

1 FixedType[PSDL_VIEW 


fixed_type : EmptyFixedType[PSDL_VIEW ^ :] 
I FixedDelta[PSDL_VIEW : .. ..] 

I FixedDeltaDigits[PSDL_VIEW :.] 


array_type : EmptyArrayType[PSDL_VIEW :] 
I UnconstrArray[PSDL_VIEW 
I ConstrArray[PSDL_VIEW 


component_subtype_def: CompSubtypeDef[PSDL_VIEW 


aliased_opt: AliasedOptNull[PSDL_VIEW ^ ;] 
I AliasedOptPrompt[PSDL_VIEW ;] 

I AliasedOpt[PSDL_VIEW :] 


index_s ; IndexNil[PSDL_VIEW '':] 

I IndexList[PSDL_VIEW : .. ..] 


iter_discrete_range_s : DiscreteRangeNil[PSDL_VIEW ;] 
I DiscreteRangeList[PSDL_VIEW ^ : .. ..] 


discrete_range ; EmptyDiscRng[PSDL_VIEW ^ :] 
I DiscRangeName[PSDL_VIEW''; ....] 

I DiscRangeRange|PSDL_VIEW '':..] 


range_constr_opt: EmptyRangeConstrOptpSDL_VIEW '' :] 
I RangeConstr[PSDL_VIEW 


record_def: EmptyRecordDef[PSDL_VIEW :] 


87 







I Record[PSDL_VIEW : .. ..] 

I NullRecord[PSDL_VIEW :] 


tagged_opt: TaggedOptNull[PSDL_VIEW ;] 
I TaggedOptPrompt[PSDL_VIEW ^:] 

I Tagged[PSDL_VIEW ^:] 

I AbstractTagged[PSDL_VIEW ^:] 


comp_list; EmptyCoinpList[PSDL_VIEW :] 

I ConipListWithVariant[PSDL_VIEW ^ ;....] 
I CompListWithPragina[PSDL_VIEW :....] 
I NullWithPragma[PSDL_VIEW 


comp_decl_s : CompDecl[PSDL_VIEW :..] 
I CompDeclList[PSDL_VIEW:.] 


variant_part_opt: Empty VariantPart[PSDL_VIEW :] 
I VariantPartOptPragma[PSDL_VIEW :..] 

I VariantPartOpt[PSDL_VIEW :.] 


comp_decl: CompDeclDefs[PSDL_VIEW :.] 


discrim_sp€c_s : DiscrimSpecNil[PSDL_VIEW :] 
I DiscrimSpecList[PSDL_VIEW '':.. 


discrim_spec : DiscrimSpecDeflPSDL_VIEW :.] 


access_opt: AccessOptNulipSDL_VIEW ;] 
I AccessOptPrompt[PSDL_VIEW :] 

I AccessOpt[PSDL_VIEW'':] 


variant_part: VariantPart[PSDL_VIEW :.] 


variant_s : VariantNil[PSDL_VIEW '':] 
I VariantList[PSDL_VIEW ^ : .. ..] 


variant: VariantChoice[PSDL_VIEW :.] 


88 










choice_s : ChoiceNil[PSDL_VIEW ;] 
I ChoiceList[PSDL_VIEW : .. ..] 


choice : EmptyChoice[PSDL_VIEW ^ :] 
I ChoiceExpr[PSDL_VIEW 
i ChoiceRange[PSDL_VIEW 
I ChoiceOthers[PSDL_VIEW ^ :] 


discrete_with_range : DiscreteNameRange[PSDL_VIEW ^ 
I DiscreteWithRange[PSDL_VIEW ;..] 


access_1ype : EmptyAccessType[PSDL_VIEW ^ :] 
I AccessSubtype[PSDL_VIEW : ..] 

I AccessConstSubtype[PSDL_VIEW :..] 

I AccessAllSubtype[PSDL_VIEW ;..] 

I AccessProcedure[PSDL_VIEW : ....] 

I AccessFunction[PSDL_VIEW :.] 


prot_opt: ProtOptNull[PSDL_VIEW :] 
I ProtOptPrompt[PSDL_VIEW :] 

I ProtectedpSDL_VIEW ^ :] 


decl_item_s ; DeclListNil[PSDL_VIEW :] 

/* I DeclList[PSDL_VIEW [“%n”] ^]*/ 
I DeclList[PSDL_VIEW ^ [“%n ”]''] 


decl_item : EmptyDeclItem[PSDL_VIEW '':] 
I Decl[PSDL_VIEW 
I UseClauseDecl[PSDL_VIEW ^ : ..] 

I DeclRepSpec[PSDL_VIEW '': ..] 

I DeclPragma[PSDL_VIEW ^ : ..] 


name : EmptyName[PSDL_VIEW ^ :] 

I SimpleName[PSDL_VEW ^ : ..] 

1 IndexComp[PSDL_VIEW '':.. ..] 

I SelectedComppSDL_VIEW ^ ;..] 
I Attribute[PSDL_VIEW ^ : ....] 

I OperatorSymbol[PSDL_VIEW 


mark : EmptyMark[PSDL_VIEW :] 
I Mark[PSDL_VIEW ^ 


89 








ticdot: TicDotNil[PSDL_VIEW ^ : ] 

I TicOpt[PSDL_VIEW '^] 

I DotOpt[PSDL_VIEW 


marklist: MarkListNil[PSDL_VIEW ^ ;] 
I MarkList[PSDL_VIEW ^ 


compound_name : EmptyCompoundP’SDL_VIEW'':] 
i DotCompound[PSDL_VIEW ^ 


c_name_list: CompoundNameNil[PSDL_VIEW '';] 
I CompoundList[PSDL_VIEW : .. ..] 


value_s ; ValueNil[PSDL_VIEW '':] 
I ValueList[PSDL_VIEW 


value : Empty Value[PSDL_VIEW :] 

I ValueExpr[PSDL_VIEW 
I ValueCompAssoc[PSDL_VIEW :..] 
I ValueDiscWithRange[PSDL_VIEW 


selected_comp : EmptySelComplPSDL_VIEW :] 
|DotId[PSDL_VIEW'': ..] 
i DotUsedChar[PSDL_VIEW ;....] 

I DotString[PSDL_VIEW'': .. ..] 

I DotAll[PSDL_VIEW 


attribute_id ; EmptyAttribId(PSDL_VIEW '':] 
I AttribId[PSDL_VIEW 
I AttribDigits[PSDL_VIEW'':] 

I AttribDelta[PSDL_VIEW'';] 

I AttribAccess[PSDL_VIEW'';] 


numeric_Iit: IntLit[PSDL_VIEW '': 
I RealLit[PSDL_VIEW '': ''J 


literal: EmptyLiteral[PSDL_VIEW '':] 
I NiimLit[PSDL_VIEW ^ : ..] 

I UsedChar[PSDL_VIEW 
I NilLit[PSDL_VIEW ^ :] 


90 




aggregate ; Empty Aggregate [PSDL_ VIEW '':] 
1 AggCompAssoc[PSDL_VIEW ^ 

I AggValues2[PSDL_VIEW 
I AggExprValue[PSDL_VIEW 
i AggExprWithNull[PSDL_VIEW ^ : ..] 

I AggExpNullRec[PSDL_VIEW'':] 


value_s_2 : ValueS2Pair[PSDL_VIEW : .. ..] 
I ValueS2List[PSDL_VIEW ^ 


comp_assoc : CompAssoc[PSDL_VIEW ^ 


expression : EmptyExpressionlPSDL_VIEW :] 
I Relation|PSDL_VIEW 
I And[PSDL_VIEW ^ 

I Or[PSDL_VIEW ^ 

I Xor[PSDL_VIEW '': .. ..] 

I AndThen[PSDL_VIEW 
I OrElse[ : .. ..] 


relation : EmptyRelation[PSDL_VIEW :] 

I SimpleExpr[PSDL_VIEW 
I Equal[PSDL_VIEW ^ : ....] 

1 NotEqual[PSDL_VIEW :.. 

1 LessThan[PSDL_VIEW ^ :....] 

I LessThanEq[PSDL_VIEW 
I GreaterThan[PSDL_VIEW : .. ..] 

I GreaterThanEq[PSDL_VIEW ^ ; .. ..] 

I RangeMember[PSDL_VIEW :.] 

I NameMember[PSDL_VIEW ^ ;.] 


membership : EmptyMembr[PSDL_VIEW :] 
I In[PSDL_VIEW :] 

I NotIn[PSDL_VIEW :] 


simple_expression : EmptySimple[PSDL_VIEW :] 
|Tenn[PSDL_VIEW'': ....] 

I Addition[PSDL_VIEW 
1 Subtraction[PSDL_VIEW : .. ..] 

1 Concat[PSDL_VIEW : .. ..] 


unaiy- : Unary Null [PSDL_VIEW :] 
I UnaryPrompt[PSDL_VIEW '';] 

I Plus[PSDL_VIEW ^:] 


91 




I Minus[PSDL_VIEW :] 


terai : Empty Term [P SDL _ VIEW :] 
I Factor[PSDL_VIEW : ..] 

I Mult[PSDL_VIEW 
|Divide[PSDL_VIEW'':.. ..] 

I Mod[PSDL_VIEW 
I Rem[PSDL_VIEW ..] 


factor: EmptyFactor[PSDL_VIEW :] 
I Primary [PSDL_ VIEW 
I NotPrimary[PSDL_VIEW : ..] 

I AbsPrimaiy[PSDL_VIEW ^ 

I Expon[PSDL_VIEW 


primary : Empty Primary [PSDL_VIEW ^ :] 
I Literal[PSDL_VIEW ^ : ..] 

I PrimaryName[PSDL_VIEW ^ : ..] 

I Allocator[PSDL_VIEW 
I Qualified[PSDL_VIEW 
I Parens[PSDL_VIEW ^ : ..] 


qualified : EmptyQual[PSDL_VIEW :] 

I NameTicAgg[PSDL_VIEW ;....] 
I NameTicExpr[PSDL_VIEW :.. 


allocator; newName[PSDL_VIEW 
I NewQualified[PSDL_VIEW ^ 


subprog_decl: EmptySubpDecl[PSDL_VIEW :] 
I SubprogSpec[PSDL_VIEW ^ ^ 

I GenericSubprogInst[PSDL_VIEW ^ :.] 

1 AbstractSubprogSpecP’SDL_VIEW ^ :....] 


psdl_met_opt: MetNull[PSDL_VIEW ^ :] 
I MetPromptP’SDL_VIEW :] 

I MetUsec[PSDL_VIEW ^ : ..] 

I MetMs[PSDL_VIEW '': 

I MetSec[PSDL_VIEW ^ : ..] 

I MetMm[PSDL_VIEW ^ : ..] 

I MetHrs[PSDL_VIEW 


subprog_spec : Empty SubpSpec[PSDL_VIEW '': ] 


92 





I SubProgProc[PSDL_VIEW 

I SubProgFuncRetum[PSDL_VIEW :.] 

I SubProgFunc[PSDL_VIEW 

/* for generic inst and generic rename */ 


designator : EmptyDesignator[PSDL_VIEW ^ ;] 
I DesigCompound[PSDL_VIEW ^ 

I DesigString[PSDL_VIEW : ..] 


fonnal_part_opt: FormalPartOptNull[PSDL_VIEW'':] 
I FonnalPartOptPrompt[PSDL_VIEW ^;] 

I FoimalPart[PSDL_VIEW 


param_s : ParamNil[PSDL_VIEW : ] 

I ParamList[PSDL_VIEW [“, “]''] 


param : ParamId[PSDL_VIEW ^ ^ ..] 


mode : ModeNull[PSDL_VIEW :] 

I ModePrompt[PSDL_VIEW :] 
I InMode[PSDL_VIEW :] 

I OutMode[PSDL_VIEW :] 

I InOutMode[PSDL_VIEW ^:] 

I AccessMode[PSDL_VIEW :] 


pkg_decl: EmptyPkgDecl[PSDL_VIEW ^ :] 

I PkgSpec[PSDL_VIEWpsdl_trans] 
I GenPkgInst[PSDL_VIEW ^ 


pkg_spec : Package[PSDL_VIEW ^ :.] 


private_part: PrivatePartNull[PSDL_VIEW :] 
I PrivatePartPrompt[PSDL_VIEW'':] 

I Piivate[PSDL_VIEW 


private_type : PrivateType[PSDL_VIEW ^ : ....] 


limited_opt: LimitedOptNull[PSDL_VIEW ^ :] 
I LimitedOptPrompt[PSDL_VIEW'':] 

I Limited[PSDL_VIEW'':] 


93 




use_clause : EmptyUseC[PSDL_VIEW '':] 
I Use[PSDL_VIEW ^ 

I UseType[PSDL_VIEW ^ 


name_s : NameNil[PSDL_VIEW ^ :] 
I nameList[PSDL_VIEW : .. ..] 


rename_decl: EmptyRenameDecl[PSDL_VIEW '':] 

I RenameDeclSub[PSDL_VIEW:.] 

I RenameExc[PSDL_VIEW ^ ;....] 

I RenameUnitDecl[PSDL_VIEW ^ 


rename_unit: EmptyRenameUnit[PSDL_VIEW ^ ;] 

I RenamePkgP’SDL_VIEW :.] 

I RenameSubprog[PSDL_VIEW ^ ^ 


renames : Renames[PSDL_VIEW '':..] 


task_spec : EmptyTaskSpec[PSDL_VIEW ^ :] 
I SimpleTask[PSDL_VIEW ^ :....] 

I TaskType[PSDL_VIEW :.] 


task_def: TaskDefNull[PSDL_VIEW ^;] 
I TaskDetPrompt[PSDL_VIEW ^:] 

I TaskDef[PSDL_VIEW :.] 


task_private_opt; TaskPvtOptNull[PSDL_VIEW ;] 
I TaskPvtOptPrompt[PSDL_VIEW ^:] 

I TaskPvtOptpSDL_VIEW : .. ..] 


prot_spec : EmptyProtSpec[PSDL_VIEW ^ :] 
I Prot[PSDL_VIEW 
I ProtType[PSDL_VIEW ^ :.] 


prot_def: ProtDef[PSDL_VIEW ^ 


prot_private_opt: ProtPvtOptNull[PSDL_VIEW :] 
I ProtPvtOptPrompt[PSDL_VIEW ^ :] 

I ProtPvtOpt[PSDL_VIEW 


94 







prot_op_decl_s : ProtOptDeclListNil[PSDL_VIEW ^ :] 
I ProtOptDeclList[PSDL_VIEW ^ : .. ..] 


prot_op_decl: EmptyProtOpDecl[PSDL_VIEW ^ :] 
I EntryDecl[PSDL_VIEW :..] 

I ProtOptSubprog[PSDL_VIEW : ..] 

I RepSpec[PSDL_VIEW '': ..] 

I ProtOptPragma[PSDL_VIEW ^ ;..] 


prot_elem_decl_s : ProtElemDeclNil[PSDL_VIEW ^ :] 
I ProtElemDeclList[PSDL_VIEW :....] 


prot_elem_decl: EmptyProtElem[PSDL_VIEW '':] 
i ProtOptDecl[PSDL_VIEW ^ 

I ProtElemCompDecl[PSDL_VIEW : ..] 


entry_decl_s : EntryDeclPragma[PSDL_VIEW ;..] 
I EntryDeclPragmaList[PSDL_VIEW ^ :.] 


entry_decl: EmptyEntiyDecl[PSDL_VIEW :] 
I EntryDeclId[PSDL_VIEW ^ 

I EntryRange[PSDL_VIEW ^ :.] 


rep_spec_s : RepSpecNull[PSDL_VIEW ^ :] 
I RepSpecPrompt[PSDL_VIEW :] 

I RepSpecList[PSDL_VIEW :.] 


comp_unit: CompUnit[PSDL_VIEW .,] 


private_opt: PrivateOptNull[PSDL_VIEW :] 
I PrivateOptPrompt[PSDL_VIEW :] 

I PrivateOpt[PSDL_VIEW :] 


context_spec_opt: ContextSpecNull[PSDL_VIEW :] 
I ContextSpecPrompt[PSDL_VIEW ^ :] 

I ContextSpec[PSDL_VIEW :..] 


context_spec : EmptyContextSpec[PSDL_VIEW ^ ;] 

I ContextWithUse[PSDL_VIEW ^ :.] 

I ContextPragma[PSDL_VIEW ^ 


95 






with_clause : WithClause[PSDL_VIEW 


use_clause_opt: UseClauseOptNil[PSDL_VIEW ^ ;] 
I UseClause[PSDL_VIEW 


body_stub ; EmptyBodyStub[PSDL_VIEW '':] 
I TaskStub[PSDL_VIEW 
I PkgStub[PSDL_VIEW ^ ; ..] 

I SubprogStub[PSDL_VIEW ^ :..] 

I ProtStub[PSDL_VIEW : ..] 


generic_hdr : GenericHdrNil[PSDL_VIEW ^ :] 
I GenericHdrPrompt[PSDL_VIEW ^ :] 

I GenericHdr[PSDL_VIEW ^ :..] 


generic_formal_part: GenericNil[PSDL_VIEW ^ : “%b”] 
I GenFonnalList[PSDL_VIEW ^ [“%n”] “%n”] 


generic_formal: EmptyGenFormaI[PSDL_VTEW ^ :] 

I GenParm[PSDL_VIEWGeneric Value”] 

I GenTypePann[PSDL_VIEW ^ .. “ : GenericType”] 

I GenProcPartn[PSDL_VIEW : GenericProcedure”] 

I GenFuncPann[PSDL_VIEW .“ ; GenericFunction”] 

I GenPkgParmBox[PSDL_VIEW ^ :.. ..] 

I GenPkgPaim[PSDL_VIEW 
I GenUsepannpSDL_VIEW ^ : ..] 


generic_discrim_part_opt: GenDiscOptNull[PSDL_VIEW ^ ;] 
I GenDiscOptPrompt[PSDL_VIEW ^ :] 

I GenDisc[PSDL_VIEW : ..] 

I GenBox[PSDL_VIEW ^:] 


subp_default: SubpDefaultNull[PSDL_VIEW ^ ;] 
I SubpDefaultPrompt[PSDL_VIEW ^:] 

I SubpDefNaine[PSDL_VIEW : ..] 

I SubpDetBox[PSDL_VIEW ^;] 


generic_type_def: EmptyGenTypeDef[PSDL_VIEW :] 
I GenTypeBox[PSDL_VIEW ^ :] 

I GenTypeRangeBox[PSDL_VIEW :] 

I GenTypeModBox[PSDL_VIEW'':] 


96 




GenTypeDeltaBox[PSDL_VIEW'':] 
GenTypeDeltaDigBox[PSDL_VIEW :] 
GenTypeDigitsBox[PSDL_VIEW :] 
GenTypeArray[PSDL_VIEW ^ 
GenTypeAccess[PSDL_VIEW : ..] 
GenTypePriv[PSDL_VIEW ^: ..] 
GenTypeDerived[PSDL_VIEW ;..] 


generic_derived_type : EmptyGenDerType[I^SDL_VIEW ^ :] 
1 GenDerivedSubt[PSDL_VIEW 
I GenDerivedSubtPriv[PSDL_VIEW ^ 

I GenDerivedAbst[PSDL_VIEW ^ 


generic_inst: GenInst|PSDL_VIEW 


rep_spec : EmptyRepSpecpSDL_VIEW :] 

I AttribDeflPSDL_VIEW 

I RecordTypeSpec[PSDL_VIEW :.] 

I AddressSpec[PSDL_VIEW ;.. ..] 


align_opt: AlignOptNull[PSDL_VIEW ;] 
I AlignOptPrompt[PSDL_VIEW :] 

I AlignOpt[PSDL_VIEW ^ 


comp_loc_s : CompLocNulllPSDL_VIEW :] 
I CompLocPrompt[PSDL_VIEW ^:] 

I CompLocList[PSDL_VIEW ^ ;.] 






/* File: 

unparse.psdl.ssl 

■*! 

/* Date: 

3 March, 1995 

*1 

/* Author: 

Chris Eagle 

*1 

/* System: 

Sun SPARCstation 

*/ 

/* Description: 

This file contains the unparsing rules for PSDL 

*1 

/* productions. 


*/ 


psdl: EmptyPsdl[PSDL_VIEW '': ] 

I PsdlPH[PSDL_VIEW :] 

I Component[PSDL_VIEW^ ] 


97 









component_s : ComponentNil[PSDL_VIEW :] 

I ComponentList[PSDL_VIEW [“%n%n”] '^] 


component: CompDataType[PSDL_VIEW 
I CompOperator[PSDL_VIEW 


data_type : DataType[PSDL_VIEW '': “%S(Keyword:TYPE%S) “ '' “%n” ^ 

type_spec : TypeSpec[PSDL_VIEW : “%S(Keyword:SPECIFICATION%S)%t%n” 
A A A A “o/„s(Keyword:%b%nEND%S)%n”] 


generic_type_decl: GTDNiip’SDL_VIEW : ] 

I GTD_PH[PSDL_VIEW '': ] 

I GTD[PSDL_V]EW : “%S(Keyword;GENERIC%S)%t%n” “%b%n”] 


type_decl_opt: TDO_Nil[PSDL_VIEW :] 
1 TDO_PHP’SDL_VIEW :] 

I TDOP’SDL_VIEW ^ “%n” ] 


op_list_opt: OLO_Nil[PSDL_VIEW :] 

I OLO_Cons[PSDL_VIEW ^ [“%n”] ''J 


operator: EmptyOperator[PSDL_VIEW ^ : ] 

I PsdlOpP’SDL_VIEW '': “%S(Keyword;OPERATOR%S) “ “%n” 


operator_imp : OperatorImp[PSDL_VIEW '': “%n” ''] 


operator_spec : Op Spec [PSDL_ VIEW ^ : “%S(Keyword:SPECIFICATION%S)%t” ^ ^ 
“%S(Keyword:%b%nEND%S)%n”] 


interface_s : Inteiface_s_Nil[PSDL_VIEW :] 
I InteilaceListpSDL_VIEW ^ 


interface : EmptyInterface[PSDL_VIEW'':] 
I Interface[PSDL_VIEW ^ : “%n” 


attribute : Generics[PSDL_VIEW ; ‘^%S(Keyword:GENERIC%S)%t%n” '' “%b”] 
I Inputs[PSDL_VIEW ^ : “%S(Keyword:iNPUT%S)%t%n” ^ "“/ob”] 


98 


1 Outputs|PSDL_VIEW ^ : “%S(Keyword;OUTPUT%S)%t%n” ^ “%b”] 
i States[PSDL_VIEW ^ : “%S(Keyword:STATES%S)%t%n” '' 
“%S(Keyword:INITIALLY%S)%n” ^ ““/ob”] 

I Excpts[PSDL_VIEW : “%S(Keyword;EXCEPTIONS%S)%t%n” ^ “%b”] 

I MET[PSDL_VIEW '': “%S(Keyword:MAXIMUM EXECUTION TIME%S) “ 


type_decl_s : TypeDeclNil[PSDL_VIEW @ :] 

I TypeDeclList[PSDL_VIEW @ [“.%n”] @] 


type_decl_s2 : TypeDeclNil2[PSDL_VIEW @ :] 

I TypeDeclList2[PSDL_VIEW @ ::= ^ [“, “] @] 


type_decl: TypeDeclPSDL[PSDL_VIEW @ @ : “ @] 

i EmptyTypeDecl[PSDL_VIEW @ :] 


type_name : EmptyTypeName|PSDL_VIEW @ :] 
I TN_Id[PSDL_VIEW 
I TN_AiTay[PSDL_VIEW ^ ^ “]”] 


reqmts_trace : RqmtsNil[PSDL_VIEW * :] 

I Rqmts_PH[PSDL_VIEW ^:] 

/* I Rqmts[PSDL_VIEW ^ : “%S(Keyword:BY REQUIREMENTS%S) “ ..]*/ 


functionality : FuncNil[PSDL_VIEW * :] 

I FuncPH[PSDL_VIEW ^:] 

/* I Functionality[PSDL_VIEW ^ :.]*/ 


/* 

keywords : KW_Nil[PSDL_VIEW :] 

I KW_PH[PSDL_VIEW ^;] 

I Keywords[PSDL_VIEW ^ : “%S(Keyword:KEYWORDS%S) “ ..] 


informal_desc : ID_Nil[PSDL_VIEW :] 

I ID_PHPSDL_VIEW :] 

i InlDesc|PSDL_VIEW ^ : “%S(Keyword:DESCRIPTION%S)%t%n” .. “%b%n] 


formal_desc : FD_Nil[PSDL_VIEW :] 

I FD_PH[PSDL_VIEW ^ :] 

I FormalDesc[PSDL_VIEW ^ : “%S(Keyword:AXIOMS%S)%t%n” .. “%b%n”] 

*1 


99 



type_impl: AdaTypeImp[PSDL_VIEW ^ : 

“%S(Keyword:IMPLEMENTATION ADA%S) “ 
“%S(Keyword:%nEND%S)%n”] 

/* I TypeImpl[PSDL_VIEW ^ : “%S(Keyword:IMPLEMENTATION%S) 
.. “%S(Keyword:%nEND%S)%n”]*/ 


operator_impl: AdaOpImp[PSDL_VIEW * : 

“%S(Keyword:IMPLEMENTATION ADA%S) “ 
“%S(Keyword;%nEND%S)"/on”] 

I EmptyImpl[PSDL_VIEW ^ :] 

/* I PsdlOpImpl[PSDL_VIEW ^ : “%S(Keyword:IMPLEMENTATION%S) 
.. “%S(Keyword:%nEND%S)%n”]*/ 


initial_expression_list: InitExpNil[PSDL_VIEW :] 
I InitExpList[PSDL_VIEW ^ ^ “] 


mitial_expression : ExpTrue[PSDL_VIEW : “True”] 
I ExpFalse[PSDL_VIEW '': “False”] 

I ExpInt[PSDL_VIEW : ^] 

I ExpReaip’SDL_VIEW ^ ;''] 

I ExpStr[PSDL_VIEW ^ :''] 

I ExpId[PSDL_VIEW ^ 

I ExpType[PSDL_VIEW ^ ; a - a aj 
I ExpInitExp[PSDL_VIEW ^ “)”] 

I ExpBinOp[PSDL_VIEW 
I ExpUnaiy[PSDL_VIEW ^ 


opt_mit_expJist: optListNil[PSDL_VIEW ^ ;] 
I optListPrompt|PSDL_VIEW ^;] 

I optListp’SDL_VIEW “)”] 


bmaiy_op ; PsdlAndP’SDL_VIEW ^ : “%S(Keyword: AND%S) “] 
I PsdlOr[PSDL_VIEW ^ : “%S(Keyword: OR%S) “] 

I PsdlXor[PSDL_VEW '': “%S(Keyword: XOR%S) “] 

I PsdlLT[PSDL_VIEW ^ < “] 

I PsdIGT[PSDL_VIEW ^ > “] 

I PsdlEQ[PSDL_VIEW ^ = “] 

I PsdlGTEQ[PSDL_VIEW ^ : “ >= “] 

I PsdlLTEQ[PSDL_VIEW ^ : “ <= “] 

I PsdlNE[PSDL_VIEW ^ : “ /= “] 

I PsdlAddpSDL_VEW + “] 

I PsdlSub[PSDL_VIEW ^ - “] 

I PsdlCat[PSDL_VIEW & “] 

I PsdlMul[PSDL_VIEW * “] 

I PsdlDiv[PSDL_VIEW ^ /'-] 

I PsdlMod[PSDL_VIEW ^ : “%S(Keyword: MOD%S) “] 


100 



I PsdlRem[PSDL_VIEW : “%S(Keyword: REM%S) “] 
I PsdlExp[PSDL_VIEW ^ “] 


unary_op : PsdlNot[PSDL_VIEW : “%S(Keyword;NOT%S) “] 
I PsdlAbs[PSDL_VIEW : '‘%S(Keyword;ABS%S) “] 

I PsdlNeg[PSDL_VIEW '': 

I PsdlPos[PSDL_VIEW '': “+”] 


time_unit: TimeuSec[PSDL_VIEW ^ :'' “%S(Keyword: MICROSEC%S)”] 
I TimeMs[PSDL_VIEW ^ “%S(Keyword: MS%S)”] 

I TimeSec[PSDL_VIEW “%S(Keyword; SEC%S)”] 

I TimeMin[PSDL_VIEW ^ “%S(Keyword; MIN%S)”] 

1 TimeHrs[PSDL_VIEW ^ ^ “%S(Keyword; HOURS%S)”] 


101 






102 




APPENDIX C. SSL SOURCE CODE: ATTRIBUTE FUNCTIONS 


The source code below is used to compute the attributes of Ada 95 productions. 
These attributes are are specified as productions within the PSDL language. Once 
computed each attribute is displayed according to the unparsing rules for PSDL 
productions. 




/* 

File: 

attrib.ada9x.ssl 

*/ 

/* 

Date; 

3 March, 1995 

*! 

/* 

Author: 

Chris Eagle 

*1 

/* 

System: 

Sun SPARC station 

*/ 

/* 

Description: 

This file contains functions which compute the 

*1 

/* 

attribute for Ada 9x productions. These attributes are 

*/ 

/* 

in turn PSDL productions, which when displayed provide 

*/ 

/* 

the Ada 9x to PSDL translation. 

*/ 


subprog_spec { 

inh psdl_met_opt met; 

}; 


/* procedure to indicate whether the input subprog_spec is */ 

/* an Ada Procedure specification, or a Function specification */ 

/* Return = 1 for ss = Procedure spec */ 

/* Return = 0 for ss = Function spec */ 


INT IsProcSpec(subprog_spec ss) { 
with (ss) ( 

SubProgProc(*,*): 1, 
default: 0 

) 

}; 


/* procedure to indicate whether the input decl is */ 

/* an Ada Procedure declaration, or some other declaration */ 

/* Return = 1 for d = Procedure decl */ 

/* Remrn = 0 for d = other decl */ 


INT IsProcDecl(decl d) { 
with (d) ( 

SubProgDecl(sd): with (sd) ( 

SubprogSpec(*,ss,*): IsProcSpec(ss), 
default; 0 

), 


103 







default: 0 

) 

}; 


/* fuction to count the number of declarations in the input */ 

/* decl_item_s list which will translate to PSDL operators */ 

/* Return value = number of decls that will become PSDL operators */ 

INT CountOps(decl_item_s dis) { 
with (dis) ( 

DeclListNil: 0, 

DeclList(di, rest): with (di) ( 

Decl(d): with (d) ( 

SubProgDecl(*): IsProcDecl(d) + CountOps(rest), 

PkgDecl(pd): with (pd) ( 

PkgSpec(gh, ps): with (ps) ( 

Package(cn, ds, pp): (CountOps(ds) == 1 ? 1 : 0) + 
CountOps(rest) 

). 

default: CountOps(rest) 

)= 

RenameDecl(rd): with (rd) ( 

RenameUnitDecl(ru): with (ru) ( 

RenameSubprog(*, ss, *); IsProcSpec(ss) + CountOps(rest), 
default; CountOps(rest) 

), 

default: CountOps(rest) 

), 

default: CountOps(rest) 

). 

default: CountOps(rest) 

) 

) 

}; 

identifier MarkToId(mark m) { 
with (m) ( 

EmptyMark: IdNull, 

Mark(i,*): i 

) 

) . 

type_name PSDLTypeName(mark m) { 
with (m) ( 

EmptyMark : EmptyTypeName, 

Mark(i, *): TN_Id(i) 

) 

}; 

t\'pe_decl PSDLTypeDecl(param p) { 


104 




with (p) ( 

EmptyParam : EmptyTypeDecl, 

Paramld(dis, *, m, *): TypeDeclPSDL(dis,PSDLTypeName(m)) 

) 

}; 


/* function to return a parameter list containing only the parameters 
/* in p which are of type IN or IN OUT 

type_decl_s Extractlns(param_s p) { 
with (p) ( 

ParamNil: TypeDeclNil, 

ParamListfparm, ps): 
with (parm) ( 

Paramld(d, md, mk, *): 
with (md) ( 

OutMode ; Extractlns(ps), 

AccessMode : Extractlns(ps), 
default: PSDLTypeDecl(parm)::ExtractIns(ps) 

). 

EmptyParam : Extractlns(ps) 

) 

) 

}; 


/* function to create the INPUTS portion of a PSDL operator 
/* specification given an input formal parameter list 

interface MakeInputs(formal_part_opt fp) { 
with (fp) ( 

FormalPart(p): with (Extractlns(p)) ( 

TypeDeclNil: Emptyinterface, 

TypeDeclList(*, *); Interface(Inputs(ExtractIns(p)),RqmtsNil) 

), 

default: Emptyinterface, 

) 


/* function to return a parameter list containing only the parameters 
/* in p which are of type OUT or IN OUT 

type_decl_s ExtractOuts(param_s p) { 
with (p) ( 

ParamNil: TypeDeclNil, 

ParamList(parm, ps): 
with (parm) ( 

Paramld(d, md, mk, io): 
with (md) ( 

OutMode : PSDLTypeDecl(parm);;ExtractOuts(ps), 








InOutMode: PSDLTypeDecl(parm)::ExtractOuts(ps), 
default: ExtractOuts(ps) 

), 

EmptyParam : ExtractOuts(ps) 

) 

) 

}; 


*/ 
*/ 

interface MakeOutputs(formal_part_opt fp) { 
with (fp) ( 

FonnalPart(p): with (ExtractOuts(p)) ( 

TypeDeclNil; Emptyinterface, 

TypeDeclList(*, *): Interface(Outputs(ExtractOuts(p)),RqmtsNil) 

), 

default: Emptyinterface, 

) 


/* function to create the OUTPUTS portion of a PSDL operator 
/* specification given an input formal parameter list 


/* function to create the MET portion of a PSDL operator given */ 

/* an input psdl_met_opt from an Ada program */ 

interface MakeMet(psdl_met_opt pmo) { 
with (pmo) ( 

MetUsec(i): Interface(MET(TimeuSec(i)),RqmtsNil), 

MetMs(i): Interface(MET(TimeMs(i)),RqmtsNil), 

MetSec(i): Interface(MET(TimeSec(i)),RqmtsNil), 

MetMin(i): Interface(MET(TimeMin(i)),RqmtsNil), 

MetHrs(i): Interface(MET(TimeHrs(i)),RqmtsNil), 
default: Emptyinterface 
) 


identifier ModeToId(mode m) { 
with (m) ( 

OutMode: Ident("out''), 
InOutMode: Ident("in_out"), 
AccessMode : Ident("access"), 
default: Ident("in") 

) 

}•- 


t\'pe_decl PSDLProcParm(param p) { 
with (p) ( 

Paramld(dis, md, mk, *): 

TypeDeclPSDL(dis,TN_Array(ModeToId(md), 

TypeDeclPSDL(Ident("t")::DefldNil, 


106 


TN_Id(MarkToId(mk))):: TypeDeclNil2)), 
EmptyParam : EmptyTypeDecl 

) 


type_decl_s2 ProcParmsToTypeDeclS(param_s p) { 
with (p) ( 

ParamNil: TypeDeclNil2, 

ParamListCparm, ps) ; 
with (parm) ( 

Paramld(d, md, mk, *): 

PSDLProcPaiin(parm)::ProcPaiinsToTypeDeclS(ps), 
EmptyParam : ProcParmsToTypeDeclS(ps) 

) 

) 

}; 


type_name ProcTypeName(formal_part_opt fpo) { 
with (fpo) ( 

FormalPart(p): 

TN_Array(Ident(“PROCEDURE”),ProcParmsToTypeDeclS(p)), 
default: TN_Id(Ident(“PROCEDURE”)) 

) 

}; 


identifier NameToIdent(name n) { 
with (n) ( 

EmptyName : IdNull, 
SimpleName(i): i. 
OperatorSymbol(os): Ident(os), 
default: Ident(“DefaultId”) 

) 

}; 


type_decl_s2 RetuniDecl(name n) { 

TypeDeclPSDL(Ident(“RETURN”)::DefldNilJN_Id(NameToIdent(n)))::TypeDeclNil2 

}; 

type_decl_s2 FuncParmsToTypeDeclS(param_s p) { 
with (p) ( 

ParamNil: TypeDeclNil2, 

ParamList(parm, ps): 
with (parm) ( 

Paramld(d, md, mk, io): 

PSDLTypeDecl(parm):;FuncParmsToTypeDeclS(ps), 
EmptyParam : FuncParmsToTypeDeclS(ps) 

) 

) 

) ■ 


type_name FuncTypeName(formal_part_opt fpo, name n) { 


107 








with (fpo) ( 

FormalPart(p): 

TN_Array(Ident(“FUNCTION”),FuncPamisToTypeDeclS(p)@JleturnDecl(n)), 
default: TN_AjTay(Ident(“FUNCTION”),RetuniDecl(n)) 

) 


type_decl MakeProcDecl(identifier i, formal_part_opt fpo) { 
Ty peDeclPSDL (i; ;Def[dN il ,ProcT y peName(fpo)) 

}; 


SIR CompoundToStr(compound_naine cn, SIR sep) { 
with (cn) ( 

EmptyCompound : 

DotCompound(id, rest): with (id) ( 

IdNull; CompoiindToStr(rest, sep), 

Ident(i): with (rest) ( 

EmptyCompound; i, 

DotCompound(*,*): i#sep#CompoundToStr(rest,sep) 

) 

) 

) 

}; 


identifier CompoundToId(compound_name cn) { 
Ident(CompoundToStr(cn,”_”)) 


identifier DesigToId(designator d) { 
with (d) ( 

DesigCompound(cn): CompoundToId(cn), 
DesigString(s): Ident(“func_”#s), 

Empty Designator; Ident(““) 

) 

}; 


type_decl MakeFuncDecI(designator d, formal_part_opt fpo, name n) { 
TypeDeclPSDL(DesigToId(d)::Def[dNil,FuncTypeName(fpo,n)) 


type_decl MakePSDLTypeDecl(identifier i, SIR s) { 
TypeDeclPSDL(i::DefIdNil,TN_Id(Ident(s))) 

}; 


type_name CompSubDefToTN(component_subtype_def csd) { 
with (csd) ( 

CompSubtypeDef(*,si): with (si) ( 

SubtypeIndConstraint(n,*): TN_Id(NameToIdent(n)), 
SubTypelndName(n); TN_Id(NameToIdent(n)), 
defaut: TN_Id(Ident("UNDEF_TYPE")) 

) 


108 


) 


type_name IndexsToTN(index_s idx) { 
with (idx) ( 

IndexList(n,*): TN_Id(NameToIdent(n)), 
default: TN_Id(Ident("UNDEFINED_TYPE")) 

) 

}; 

type_decl_s2 ConstrTypeDecl(iter_discrete_range_s iter, component_subtype_def csd) { 
TypeDeclPSDL(Ident("ARRAY_ELEMENT")::DefldNil,CompSubDefroTN(csd))::( 
TypeDeclPSDL(Ident("ARRAY_INDEX")::DefIdNil, 
TN_Id(Ident(’'RANGE")))::TypeDeclNil2) 


type_decl_s2 UnConstrTypeDecl(index_s idx, component_subtype_def csd) { 

TypeDeclPSDL(Ident("ARRAY_ELEMENT")::DefldNil,CompSubDefroTN(csd))::( 

TypeDeclPSDL(Ident("ARRAY_INDEX”):;DefldNil,IndexsToTN(idx)):: 

TypeDeclNil2) 

}; 


type_decl MakeArrayDeclfidentifier i, array_type a) { 
with (a) ( 

UnconstrArray(ind, csd): TypeDeclPSDL(i;;DefrdNil, 

TN_Array(Ident("ARRAY"),UnConstrTypeDecl(ind,csd))), 
ConstrArray(iter, csd): TypeDeclPSDL(i::DefldNiI, 

TN_Array(Ident("ARRAY"),ConstrTypeDecl(iter,csd))), 
default: EmptyTypeDecl 

) 

}; 


/* function to examine a single generic formal parameter from an Ada */ 

/* program and determine if it will become a parameter in the PSDL */ 

/* generic parameter list. The inpput generic_formal is examined */ 

/* and placed at the tail of the input param_s list if it maps to */ 

/* PSDL. The remainder of the generic_fonnals are transformed by */ 

/* passing rest to PsdlGeneric */ 


type_decl MakeParam(generic_formal gf) { 
with (gf) ( 

GenProcParm(i, fpo, sd): MakeProcDecl(i,fpo), 

GenFuncParm(d, fpo, n, sd): MakeFuncDecl(d,fpo,n), 

GenTypeParm(i, gdpo, gtd): with (gtd) ( 

GenTypeBox : MakePSDLTypeDecl(i,”DISCRETE_TYPE”), 
GenTypeRangeBox: MakePSDLTypeDecl(i,”RANGE_TYPE”), 
GenTypeModBox: MakePSDLTypeDecl(i,”MOD_TYPE”), 
GenTypeDeltaBox : MakePSDLTypeDecl(i,”DELTA_TYPE”), 
GenTypeDeltaDigBox: MakePSDLTypeDecl(i,”DELTA_DIGITS_TYPE”), 
GenTypeDigitsBox : MakePSDLTypeDecl(i,”DIGITS_TYPE”), 
GenTypeArray(a): MakeArrayDecl(i,a), 

GenTypeAccess(at): MakePSDLTypeDecl(i,”ACCESS_TYPE”), 


109 



GenTypePriv(*): MakePSDLTypeDecl(i,”PRIVATE_TYPE”), 
GenTypeDerived(gdt): MakePSDLTypeDecl(i, 
“GENERIC_DERIVED_TYPE”), 

default: Empty TypeDecl 

), 

/* PSDL does not currently allow value parameters as generic formals 
/* if that changes, the following lines must be uncommented to 
/* provide the translation 
/* 

GenParm(p): with (p) ( 

Paramld(id *,* *); MakePSDLTypeDecl(id,”GENERIC_VALUE”), 
default: Empty TypeDecl 
), 

*/ 

default: Empty TypeDecl 

) 

}; 

/* function to build a list of generic parameters for a PSDL component 
/* specification given an input list of Ada generic formal parameters 

type_decl_s PsdlGeneric(generic_formal_part gfp) { 
with (gfp) ( 

GenericNil: TypeDeclNil, 

GenFormalList(gf, rest): with (MakeParam(gf)) ( 

Empty TypeDecl: PsdlGeneric(rest), 
default: MakeParam(gf)::PsdlGeneric(rest) 

) 


/* ftmction to create the PSDL code for a list of Generic 
/* formal parameters 

interface MakeGenerics(generic_fonnal_part gfp) { 
with (gfp) ( 

GenericNil: Empty Interface, 

GenFormalList(*, *): Inteiface(Generics(PsdlGeneric(gfp)),RqmtsNil) 

) 


*/ 

*/ 

*/ 


*/ 

*/ 


*! 

*/ 


/* create a PSDL generic type declaration from an Ada generic formal */ 

/* parameter list */ 

generic_type_decl MakeGenericTypeDecl(generic_formal_part gfp) { 
with (gfp) ( 

GenericNil: GTDNil, 

GenFormalList(*, *); GTD(PsdlGeneric(gfp)) 

) 


110 





/* build the interfaces portion of a PSDL component specification 
/* given input generic formal parameter list, formal parameters, 

/* an existing interface portion, and a psdl met from an Ada program 

interface_s Buildlnterfaces(generic_formal_part gfp, formal_part_opt fpo, 
interface e, psdl_met_opt pmo) { 

MakeGenerics(gfp):: Makelnputs(fpo):: MakeOutputs(fpo):: 
e :: MakeMet(pmo):: Interface_s_Nil 


/* Extract all of the exceptions from a list of declarations 

def_id_s ExtractExceptions(decl_item_s dl) { 
with (dl) ( 

DeclListNil: DefldNil, 

DeclList(di, rest): 
with (di) ( 

Decl(dcl) ; 

with (del) ( 

RenameDecl(rd): with (rd) ( 

RenameExc(ds, *): 

ds @ ExtractExceptions(rest), 
default; ExtractExceptions(rest) 

), 

ExcDecl(dids): dids @ ExtractExceptions(rest), 
default: ExtractExceptions(rest) 

), 

default: ExtractExceptions(rest) 

) 

) 

}; 


/* create the exceptions portion of a PSDL component specification 

interface MakeExcepts(decl_item_s d) { 
with (ExtractExceptions(d)) ( 

DefldNil: Emptyinterface, 

DefldList(*, *): Interface(Excpts(ExtractExceptions(d)),RqmtsNil) 

) 

}; 


/* combine two lists of exceptions to form a single list 

interface JoinExcepts(interface il, interface i2) { 
with (il) ( 






Interface(a, r): with (a) ( 

Excpts(d): with (i2) ( 

Interface(a2, r2): with (a2) ( 

Excpts(d2): Interface(Excpts(d @ d2), RqmtsNil), 
default: il 

), 

default: il 

), 

default: i2 

), 

default: i2 

) 

}; 


*/ 
*/ 
*! 

operator MakeOpFromPkg(generic_hdr gh, pkg_spec ps, interface e) { 
with (ps) ( 

Package(cn, d, pp); with (gh) ( 

GenericHdr(gfp): with (MakeOpFroinPkg(GenericHdrNil, ps, 

Empty Interface)) ( 

PsdlOp(c, os): with (os) ( 

OpSpec(is, f): PsdlOp(c,OpSpec(MakeGenerics(gfp):: is, f)) 

), 

EmptyOperator: EmptyOperator 

), 

default: with (MakeOps(d, JoinExcepts(e,MakeExcepts(d)))) ( 

OLO_Nil: EmptyOperator, 

OLO_Cons(o, rest): o 

) 

) 

) 

}; 


/* given an Ada package specification and its generic header 
/* create a PSDL operator specification incorporating the 
/* interfaces e 


*/ 
*/ 

component MakeCompFromPkg(generic_hdr gh, pkg_spec ps) { 
with (ps) ( 

Package(cn, d, p): CountOps(d) == 1 ? 

CompOperator(OperatorImp(MakeOpFromPkg(gh, ps, Emptyinterface), 
AdaOpImp(with (MakeOpFromPkg(gh, ps. EmptyInterface))( 

PsdlOp(c,o); c, 

EmptyOperator: Empty Compound 

)))) 

with (gh) ( 


/* given an Ada package specification and its generic header, 
/* create a PSDL Type component specification 


112 





GenericHdr(gfp): 

CompDataType(DataType(cn,MakeType(ps,gfp),AdaTypeImp(cn))), 
default; 

CompDataType(DataType(cn,MakeType(ps,GenericNil),AdaTypeIinp(cn))) 

) 

) 

}; 


component_s MakeCompListFromDeclItemS(decl_item_s dis, interface exc) { 
with (dis) ( 

DeclListNil: ComponentNil, 

DeclList(di, rest); with (di) ( 

Decl(dcl); with (del) ( 

SubProgDecl(sd): with (sd) ( 

SubprogSpec(gh, ss, pmo) : 
MakeCompOpFromSubprog(gh, ss, pmo, exc)@ 
MakeCompListFroniDeclItemS(rest, exc), 

default; MakeCompListFromDeclItemS(rest,exc) 

), 

PkgDecl(pd): with (pd) ( 

PkgSpec(gh, ps); MakeCompFromPkg(gh,ps):: 
MakeCompListFromDeclItemS(rest,exc), 

default: MakeCompListFroinDeclItemS(rest,exc) 

), 

default: MakeCompListFromDeclItemS(rest,exc) 

), 

default: MakeCompListFromDeclItemS(rest,exc) 

) 

) 

}; 


BOOL NestedTypes(decl_item_s dis) { 
with (dis) ( 

DeclListNil: false, 

DeclList(di, rest): with (di) ( 

Decl(d): with (d) ( 

PkgDecl(pd); with (pd) ( 

PkgSpec(gh, ps): with (ps) ( 

Package(cn, ds, pp): 

CountOps(ds) != 1 ? true : NestedTypes(rest) 

), 

default: NestedTypes(rest) 

), 

default; NestedTypes(rest) 

), 

default: NestedTypes(rest) 

) 

) 

}; 


113 









component_s MakeCompListFromPkg(generic_hdr gh, pkg_spec ps) { 
with (ps) ( 

Package(cn, dis, p): NestedTypes(dis) ? 
MakeCompListFromDeclItemS(dis,MakeExcepts(dis)): 
MakeCompF romPkg(gh,ps); .ComponentNil 

) 

}; 


*/ 
*/ 
*/ 

operator MakeOpFromSubprog(generic_hdr gh, subprog_spec ss, 
psdl_met_opt pmo, interface e) { 
with (gh) ( 

GenericHdr(gfp): with (ss) ( 

SubProgProc(c, f) ; PsdlOp(c, OpSpec(BuildInterfaces(gfp, 
f, e, pmo), FuncNil)), 
default: Empty Operator 

), 

default: with (ss) ( 

SubProgProc(c, f) : PsdlOp(c, OpSpec(BuildInterfaces(GenericNil, 
f, e, pmo), FuncNil)), 
default: Empty Operator 

) 

) 

}; 


/* given an input subprogram specification, its generic header, 
/* its MET, and existing interfaces, create a PSDL operator 
/* specification 


component_s MakeCompOpFromSubprog(generic_hdr gh, subprog_spec ss, 
psdl_met_opt pmo, interface e) { 
with (ss) ( 

SubProgProc(c, t) : CompOperator(OperatorImp( 
MakeOpFromSubprog(gh,ss,pmo,e),AdaOpImp(c)));:ComponentNil, 
default: ComponentNil 
) 

1 ■ 

/. 


*/ 
*/ 

op_list_opt MakeOps(decl_item_s d, interface exc) { 
with (d) ( 

DecLListNil: OLO_Nil, 

DeclList(di, rest): with (di) ( 

Decl(dcl): with (del) ( 

SubProgDecl(sd); with (sd) ( 

SubprogSpec(gh, ss, pmo); 

MakeOpFromSubprog(gh, ss, pmo, exc);:MakeOps(rest, exc), 
default: MakeOps(rest,exc) 


/* create a list of PSDL operators from a list of Ada declarations 
/* incorporating the exceptions specified in exc 


114 





), 

PkgDecl(pd): with (pd) ( 

PkgSpec(gh, ps): with (ps) ( 

Package(cn, ds, pp): CountOps(ds) == 1 ? 

akeOpFromPkg(gh, ps, exc):: akeOps(rest,exc 

MakeOps(rest,exc) 

), 

default: MakeOps(rest,exc) 

). 

default: MakeOps(rest,exc) 

), 

default; MakeOps(rest,exc) 

) 

) 

}; 


1ype_spec MakeType(pkg_spec ps, generic_formal_part gfp) { 
with (ps) ( 

Package(c, d, p); TypeSpec(MakeGenericTypeDecl(gfp), 
TDO_Nil, MakeOps(d, MakeExcepts(d)), FuncNil) 

) 


subprog_decl: SubprogSpec{ 

subprog_spec.met = psdl_met_opt; 

1 

/ 

I GenericSubprogInst{ 

subprog_spec.met = psdl_met_opt; 

} 

I AbstractSubprogSpec{ 

subprog_spec.met = psdl_met_opt; 

} 


pkg_decl; 

PkgSpec{ 

local component_s psdl_trans; 
psdl_trans = ($$.nesting_level = 0) ? 

MakeCompListFromPkg(generic_hdr, pkg_spec) : 
ComponentNil; 

}; 


rename_unit: RenameSubprog{ 

subprog_spec.met = MetNull; 
; 


prot_op_decl: ProtOptSubprog { 

subprog_spec.met = MetNull; 


115 









} 


body_stub : SubprogStub{ 

subprog_spec,met = MetNull; 

} 


116 



APPENDIX D. SSL SOURCE CODE: CONCRETE SYNTAX 


The source code below is used to specify the concrete syntax of Ada 95 package 
specifications. A complete concrete syntax for Ada 95 package specifications allows 
SynGen to construct a parser which will accept existing Ada 95 source code as a text file, 
and create the attributed abstract syntax tree which is required to complete a translation. 




/* File: concrete.ada9x.ssl */ 

/* Date: 3 March, 1995 */ 

/* Author: Chris Eagle */ 

/* System: Sun SPARC station */ 

/* Description: This file contains the concrete syntax for the */ 

/* portion of the Ada 9x language required to produce *! 

/* package specifications. The concrete syntax allows */ 

/* text data to be read in and converted into an */ 

/* appropriate abstract syntax tree for an Ada 9x */ 

/* package specification. */ 


COMPILATION { syn compilation abs;}; 
compilation ~ COMPILATION.abs; 

COMP_UNIT_LIST { syn comp_unit_list rev; 

inh comp_unit_list tail;}; 
comp_unit_list ~ COMP_UNIT_LIST.rev 

{COMP_UNIT_LIST.tail = CUListNil; }; 

PRAGMA { syn pragma abs; }; 
pragma ~ PRAGMA, abs; 

PRAGMA_ARG_S { syn pragma_arg_s rev; 

inh pragma_arg_s tail;}; 
pragma_arg_s ~ PRAGMA_ARG_S.rev 

{PRAGMA_ARG_S.tail = PragmaArgNil;}; 

PRAGMA_ARG { syn pragma_arg abs;}; 
pragma_arg ~ PRAGMA_ARG.abs; 

PRAGMA_S { syn pragma_s rev; 

inh pragma_s tail; }; 
pragma_s ~ PRAGMA_S.rev 

{PRAGMA_S.tail = PragmasNil;}; 

DECL { s>'n decl abs; }; 
decl ~ DECL.abs; 


117 





DEF_ID_S { syn def_id_s rev; 

inh def_id_s tail;}; 
def_id_s ~ DEF_ID_S.rev 

{DEF_ID_S.tail = DefldNil;}; 

OBJECT_QUALIFIER_OPT { syn object_qualifier_opt abs; }; 
object_qualifier_opt ~ OBJECT_QUALIFIER_OPT.abs; 

OBJECT_SUBTYPE_DEF { syn object_subtype_def abs; }; 
object_subtype_def ~ OBJECT_SUBTYPE_DEF.abs; 

INIT_OPT { syn init_opt abs; }; 
init_opt ~ INIT_OPT.abs; 

DISCRIM_PART_OPT { syn discrim_part_opt abs; }; 
discrini_part_opt ~ DISCRIM_PART_OPT.abs; 

TYPE_COMPLETION { syn type_conipletion abs; }; 
type_completion ~ TYPE_COMPLETION.abs; 

TYPE_DEF { syn type_def abs;}; 
type_def ~ TYPE_DEF.abs; 

SUBTYPE_IND { syn sub1ype_ind abs; }; 
subtypejnd ~ SUBTYPE_II^.abs; 

CONSTRAINT { syn constraint abs; }; 
constraint ~ CONSTRAINT.abs; 

DERIVED_TYPE { syn derived_type abs; }; 
derived_type ~ DERI VED_TYPE. abs; 

RANGE_CONSTRAINT { syn range_constraint abs; }; 
range_constraint ~ RANGE_CONSTRAINT.abs; 

RANGE { syn range abs; }; 
range ~ RANGE.abs; 

ENUM_ID_S { syn enum_id_s rev; 

inh enum_id_s tail;}; 
enum_id_s ~ ENUM_ID_S.rev 

{ENUMJD_S.tail = EnumIdNil;}; 

ENUM_ID { syn enum_id abs; }; 
enum_id ~ ENUM_ID.abs; 

INTEGER_TYPE { syn integer_type abs; }; 
integer_type ~ INTEGER_TYPE.abs; 

RANGE_SPEC { syn range_spec abs; }; 


118 



range_spec ~ RANGE_SPEC.abs; 

RANGE_SPEC_OPT { syn range_spec_opt abs; }; 
range_spec_opt ~ RANGE_SPEC_OPT.abs; 

REAL_TYPE { syn real_type abs; }; 
real_type ~ REAL_TYPE.abs; 

FIXED_TYPE { syn fixed_type abs; }; 
fixed_type ~ FIXED_TYPE.abs; 

ARRAY_TYPE { syn array_type abs; }; 
array _type ~ ARRAY_TYPE.abs; 

COMPONENT_SUBTYPE_DEF { syn component_subtype_def abs; }; 
component_subtype_def ~ COMPONENT_SUBTYPE_DEF.abs; 

ALIASED_OPT { syn aliased_opt abs; }; 
aliased_opt ~ ALIASED_OPT.abs; 

INDEX_S { syn index_s rev; 

inh index_s tail;}; 
index_s ~ INDEX_S.rev 

{INDEX_S.tail = IndexNil;}; 

ITER_DISCRETE_RANGE_S { syn iter_discrete_range_s rev; 

inh iter_discrete_range_s tail; }; 
iter_discrete_range_s ~ ITER_DISCRETE_RANGE_S.rev 

{ITER_DISCRETE_RANGE_S.tail = DiscreteRangeNil;}; 

DISCRETE_RANGE { syn discrete_range abs; }; 
discrete_range ~ DISCRETE_RANGE.abs; 

RANGE_CONSTR_OPT { syn range_constr_opt abs; }; 
range_constr_opt ~ RANGE_CONSTR_OPT.abs; 

RECORD_DEF { syn record_def abs; }; 
record_def ~ RECORD_DEF.abs; 

TAGGED_OPT { syn tagged_opt abs; }; 
tagged_opt ~ TAGGED_OPT.abs; 

COMP_LIST { syn comp_list abs; }; 
comp_list ~ COMP_LIST.abs; 

COMP_DECL_S { syn comp_decl_s abs;}; 
comp_decl_s ~ COMP_DECL_S.abs; 

VARIANT_PART_OPT { syn variant_part_opt abs; }; 
variant_part_opt ~ VARlANT_PART_OPT.abs; 


119 


COMP_DECL { syn comp_decl abs; }; 
comp_decl ~ COMP_DECL.abs; 

DISCRIM_SPEC_S { syn discrim_spec_s rev; 

inh discrim_spec_s tail; }; 
discrim_spec_s ~ DISCRIM_SPEC_S.rev 

{DISCRIM_SPEC_S.tail = DiscrimSpecNil;}; 

DISCRIM_SPEC { syn discrini_spec abs; }; 
discrini_spec ~ DISCRIM_SPEC.abs; 

ACCESS_OPT { syn access_opt abs; }; 
access_opt ~ ACCESS_OPT.abs; 

VARIANT_PART { syn variant_part abs; }; 
variant_pait ~ VARIANT_PART.abs; 

VARIANT_S { syn variant_s rev; 

inh variant_s tail;}; 
variant_s ~ VARIANT_S.rev 

{VARIANT_S.tail = VariantNil;}; 

VARIANT { syn variant abs; }; 
variant ~ VARIANT.abs; 

CHOICE_S { syn choice_s rev; 

inh choice_s tail; }; 
choice_s ~ CHOICE_S.rev 

{CHOICE_S.tail = ChoiceNil;}; 

CHOICE { syn choice abs;}; 
choice ~ CHOICE.abs; 

DISCRETE_WITH_RANGE { syn discrete_with_range abs;}; 
discrete_with_range ~ DISCRETE_WITH_RANGE.abs; 

ACCESS_TYPE { syn access_type abs; }; 
access_type ~ ACCESS_TYPE.abs; 

PROT_OPT { syn prot_opt abs; }; 
prot_opt ~ PROT_OPT.abs; 

DECL_ITEM_S { syn decl_iteni_s rev; 

inh decl_item_s tail; } ; 
decl_item_s ~ DECL_ITEM_S.rev 

{DECLJTEM_S.tail = DeclListNil;}; 

DECL_1TEM { syn decl_item abs; }; 
decl_item ~ DECL_ITEM.abs; 

NAME { syn name abs; }; 


120 



name ~ NAME.abs; 


MARK { syn mark abs; }; 
mark ~ MARK.abs; 

TICDOT { syn ticdot abs; }; 
ticdot ~ TICDOT.abs; 

MARKLIST { syn maiklist abs; }; 
marklist ~ MARKLIST. abs; 

COMPOUND_NAME { syn compound_name rev; 

inh compound_name tail; } ; 
compound_name ~ COMPOUND_NAME.rev 

{COMPOUND_NAME.tail = EmptyCompound;}; 

C_NAME_LIST { syn c_name_list rev; 

inh c_name_list tail; }; 
c_name_list ~ C_NAME_LIST.rev 

{C_NAME_LIST.tail = CompoundNameNil;}; 

VALUE_S { syn value_s rev; 

inh value_s tail; }; 
value_s VALUE_S.rev 

{VALUE_S,tail = ValueNil;}; 

VALUE { syn value abs; }; 
value ~ VALUE, abs; 

SELECTED_COMP { syn selected_comp abs; }; 
selected_comp ~ SELECTED_COMP.abs; 

ATTRIBUTE_ID { syn attribute_id abs; }; 
attribute_id ~ ATTRIBUTE_ID.abs; 

NUMERIC_LIT { syn numeric_lit abs; }; 
numeric_lit ~ NUMERIC_LIT.abs; 

LITERAL { syn literal abs; }; 
literal ~ LITERAL.abs; 

AGGREGATE { syn aggregate abs; }; 
aggregate ~ AGGREGATE, abs; 

VALUE_S_2 { syn value_s_2 abs; }; 
value_s_2 ~ VALUE_S_2.abs; 

COMP_ASSOC { syn comp_assoc abs; }; 
eomp_assoc ~ COMP_ASSOC.abs; 

EXPRESSION { s>'n expression abs; }; 


121 


expression ~ EXPRESSION, abs; 

RELATION { syn relation abs;}; 
relation ~ RELATION, abs; 

SIMPLE_EXPRESSION { syn simple_expression abs; }; 
simple_expression ~ SIMPLE_EXPRESSION.abs; 

TERM { syn term abs; }; 
term ~ TERM, abs; 

FACTOR { syn factor abs;}; 
factor ~ FACTOR.abs; 

PRIMARY { syn primary abs;}; 
primary ~ PRIMARY.abs; 

QUALIFIED { syn qualified abs; }; 
qualified ~ QUALIFIED, abs; 

ALLOCATOR { syn allocator abs;}; 
allocator ~ ALLOCATOR.abs; 

SUBPROG_DECL { syn subprog_decl abs; }; 
subprog_decl ~ SUBPROG_DECL.abs; 

PSDL_MET_OPT { syn psdl_met_opt abs; }; 
psdl_met_opt ~ PSDL_MET_OPT.abs; 

SUBPROG_SPEC { syn subprog_spec abs; }; 
subprog_spec ~ SUBPROG_SPEC.abs; 

DESIGNATOR { syn designator abs;}; 
designator ~ DESIGNATOR.abs; 

FORMAL_PART_OPT { syn formal_part_opt abs; }; 
formal_part_opt ~ FORMAL_PART_OPT.abs; 

PARAM_S { syn param_s rev; 

inh param_s tail; }; 
param_s ~ PARAM__S.rev 

{PARAM_S.tail = ParamNil;}; 

PARAM { syn param abs; }; 
param ~ PARAM. abs; 

MODE { syn mode abs; }; 
mode ~ MODE, abs; 

PKCi_DECL { syn pkg_decl abs; }; 
pkg_decl ~ PKG_DECL.abs; 


122 




PKG_SPEC { syn pkg_spec abs; }; 
pkg_spec ~ PKG_SPEC.abs; 

PRIVATE_PART { syn private_part abs;}; 
private_part ~ PRIVATE_PART.abs; 

PRIVATE_TYPE { syn private_type abs; }; 
private_type ~ PRIVATE_TYPE.abs; 

LIMITED_OPT { syn limited_opt abs;}; 
limited_opt ~ LIMITED_OPT.abs; 

USE_CLAUSE { syn use_clause abs;}; 
use_clause ~ USE_CLAUSE.abs; 

NAME_S { syn name_s rev; 

inh name_s tail; }; 
name_s ~ NAME_S.rev 

{NAME_S.tail = NameNil;}; 

RENAME_DECL { syn rename_decl abs; }; 
rename_decl ~ RENAME_DECL.abs; 

RENAME_UNIT { syn rename_unit abs; }; 
rename_unit ~ RENAME_UNIT.abs; 

RENAMES { syn renames abs; }; 
renames ~ RENAMES.abs; 

TASK_SPEC { syn task_spec abs; }; 
task_spec ~ TASK_SPEC.abs; 

TASK_DEF { syntask_def abs; }; 
task_def ~ TASK_DEF.abs; 

TASK_PRIVATE_OPT { syn taskjprivate_opt abs; }; 
task_private_opt ~ TASK_PRIVATE_OPT.abs; 

PROT_SPEC { syn prot_spec abs; }; 
prot_spec ~ PROT_SPEC.abs; 

PROT_DEF { syn prot_def abs; }; 
prot_def ~ PROT_DEF.abs; 

PROT_PRIVATE_OPT { syn prot_private_opt abs;}; 
prot_private_opt ~ PROT_PRIVATE_OPT.abs; 

PROT_OP_DECL_S { syn prot_op_decl_s rev; 

inh prot_op_decl_s tail; }; 
prot_op_decl_s ~ PROT_OP_DECL_S.rev 


123 








{PROT_OP_DECL_S.tail = ProtOptDeclListNil;}; 

PROT_OP_DECL { syn prot_op_decl abs; }; 
prot_op_decl ~ PROT_OP_DECL.abs; 

PROT_ELEM_DECL_S { syn prot_elem_decl_s rev; 

inh prot_elem_decl_s tail; }; 
prot_elem_decl_s ~ PROT_ELEM_DECL_S.rev 

{PROT_ELEM_DECL_S.tail = ProtElemDeclNil;}; 

PROT_ELEM_DECL { syn prot_elem_decl abs; }; 
prot_elem_decl ~ PROT_ELEM_DECL.abs; 

ENTRY_DECL_S { syn entry_decl_s abs; }; 
entiy_decl_s ~ ENTRY_DECL_S.abs; 

ENTRY_DECL { syn entry_decl abs; }; 
entiy_decl ~ ENTRY_DECL.abs; 

REP_SPEC_S { syn rep_spec_s abs; }; 
rep_spec_s ~ REP_SPEC_S.abs; 

COMP_UNIT { syn comp_unit abs; }; 
comp_unit ~ COMP_UNIT.abs; 

PRIVATE_OPT { syn private_opt abs;}; 
private_opt ~ PRIVATE_OPT.abs; 

CONTEXT_SPEC_OPT ( syn context_spec_opt abs; }; 
context_spec_opt ~ CONTEXT_SPEC_OPT.abs; . 

CONTEXT_SPEC { syn context_spec abs; }; 
context_spec ~ CONTEXT_SPEC.abs; 

WITH_CLAUSE { syn with_clause abs; }; 
with_clause ~ WITH_CLAUSE.abs; 

USE_CLAUSE_OPT { syn use_clause_opt rev; 

inh use_clause_opt tail; }; 
use_clause_opt ~ USE_CLAUSE_OPT.rev 

{USE_CLAUSE_OPT.tail = UseClauseOptNil;}; 

BODY_STUB { syn body_stub abs; }; 
body_stub ~ BODY_STUB.abs; 

GENERIC_FORMAL_PART { syn generic_fomial_part rev; 

inh generic_formal_part tail; }; 
generic_formal_part ~ GENERIC_FORMAL_PART.rev 

{GENERIC_FORMAL_PART.tail = GenericNil;}; 

GENER1C_F0RMAL { syn generic_formal abs; }; 


124 



generic_formal ~ GENERIC_FORMAL.abs; 

GENERIC_DISCRIM_PART_OPT { syn generic_discrim_part_opt abs; }; 
generic_discrim_part_opt ~ GENERIC_DISCRIM_PART_OPT.abs; 

SUBP_DEFAULT { syn subp_default abs; }; 
subp_default ~ SUBP_DEF AULT.abs; 

GENERIC_TYPE_DEF { syn generic_type_def abs; }; 
generic_type_def ~ GENERIC_TYPE_DEF.abs; 

GENERIC_DERIVED_TYPE { syn generic_derived_type abs; }; 
generic_derived_type ~ GENERIC_DERIVED_TYPE.abs; 

GENERIC_INST { syn generic_inst abs; }; 
generic_inst ~ GENERIC_INST.abs; 

REP_SPEC { syn rep_spec abs; }; 
rep_spec ~ REP_SPEC.abs; 

ALIGN_OPT { syn align_opt abs;}; 
alignopt ~ ALIGN_OPT.abs; 

COMP_LOC_S { syn comp_loc_s abs;}; 
comp_loc_s ~ COMP_LOC_S.abs; 

INTEGER_CS { syn integer abs;}; 
integer ~ INTEGER_CS.abs; 

INTEGER_CS ::= (INTEGER) {$$.abs = Integer(INTEGER);} 


COMPILATION () {$$.abs = CompilationNil; } 

I (PRAGMA_S COMP_UNIT_LIST) { 

PRAGMA_S.tail = PragmasNil; 

COMP_UNIT_LIST.tail = CUListNil; 

$$.abs = Compilation(PRAGMA_S.rev, COMP_UNIT_LIST.rev);} 


COMP_UNIT_LIST ::= (COMP_UNIT) {$$.rev = COMP_UNIT.abs::$$.tail;} 
I (COMP_UNIT_LIST COMP_UNIT) { 

COMP_UNIT_LIST$2.tail = COMP_UNIT.abs::$$.tail; 

$$.rev = COMP_UNIT_LIST$2.rev; 

) 

/ 


PRAGMA ::= (PrAGMA ID ‘;’) { $$.abs = PragmaId(Ident(ID)); } 

I (PrAGMA ID '(‘ PRAGMA_ARG_S ')’ { 

PRAGMA_ARG_S.tail = Pragma ArgNil; 

$$.abs = PragmaSimple(Ident(ID), PRAGMA_ARG_S.rev); 

} 


125 


PRAGMA_ARG_S ::= (PRAGMA_ARG) { $$.rev = PRAGMA_ARG.abs::$$.tail; } 
I (PRAGMA_ARG_S PRAGMA_ARG) { 

PRAGMA_ARG_S$2.tail = PRAGMA_ARG.abs::$$.tail; 

$$.rev = PRAGMA_ARG_S$2.rev; 

} 


PRAGMA_ARG ;;= (EXPRESSION) { $$.abs = PragmaExp(EXPRESSION.abs); } 
I (ID RIGHT_SHAFT EXPRESSION) { 

$$.abs = PraginaNameExp(Ident(ID), EXPRESSION.abs); 

} 


PRAGMA_S ::=(){ $$.rev = SS.tail; } 

I (PRAGMA_S PRAGMA) { 

PRAGMA_S$2.tail = PRAGMA. abs::$$. tail; 
$$.rev = PRAGMA_S$2.rev; 

} 


OBJECT_DECL {syn decl abs;}; 

NUMBER_DECL {syn decl abs;}; 

TYPE_DECL {syn decl abs;}; 

EXCEPTION_DECL {syn decl abs;}; 

DECL ;:= (OBJECT_DECL) {$$.abs = OBJECT_DECL.abs;} 

I (NUMBER_DECL) {SS.abs = NUMBER_DECL.abs;} 

I (TYPE_DECL) {$$.abs = TYPE_DECL.abs;} 

I (SUBTYPE ID IS SUBTYPE_IND ‘;’) { 

$$.abs = SubTypeDecl(Ident(ID), SUBTYPEJND.abs);} 

I (SUBPROG_DECL) { $$.abs = SubProgDecl(SUBPROG_DECL.abs); } 
I (PKG_DECL) { $$.abs = PkgDecl(PKG_DECL.abs); } 

I (TASK_SPEC ‘;’) { $$.abs = TaskDecI(TASK_SPEC.abs); } 

I (PROT_SPEC ‘;’) { $$.abs = ProtDecl(PROT_SPEC.abs); } 

I (EXCEPTION_DECL) {$$.abs = EXCEPTION_DECL.abs; } 

I (RENAME_DECL) { $$.abs = RenameDecl(RENAME_DECL.abs); } 

I (BODY_STUB) { SS.abs = BodyStubDecl(BODY_STUB.abs);} 


OBJECT_DECL ::= 

(DEF_ID_S OBJECT_QUALIFIER_OPT OBJECT_SUBTYPE_DEF 
INIT_OPT ‘;’) { 

DEF_ID_S.tail = DefIdNil; 

SS.abs = ObjDecl(DEF_ID_S.rev, OBJECT_QUALIFIER_OPT.abs , 
OBJECT_SUBTYPE_DEF.abs, INIT_OPT.abs); 


NUMBER_DECL ::= PEF_ID_S CONSTANT IS_ASSIGNED EXPRESSION ‘;’) { 
DEF_ID_S.tail = DefldNil; 


126 


$$.abs= NumDecl(DEF_ID_S.rev, EXPRESSION.abs); } 


TYPE_DECL ::= (TYPE ID DISCRIM_PART_OPT TYPE_COMPLETION { 
$$.abs = TypeDecl(Ident(ID), DISCRIM_PART_OPT.abs, 
TYPE_COMPLETION.abs); 

> • 

EXCEPTION_DECL ;;= (DEF_ID_S EXCEPTION { 

DEF_ID_S.taiI = DefldNil; 

$$.abs = ExcDecl(DEF_ID_S.rev); } 


DEF_ID_S ::= (ID) {$$.rev = Ident(ID)::$$.tail;} 

I (DEF_ID_S ID) { DEF_ID_S$2.tail = Ident(ID)::$$.tail; 
$$.rev = DEF_ID_S$2.rev; } 


OBJECT_QUALIFIER_OPT ::= () { $$.abs = ObjQualOptNull; } 
I (ALIASED) { $$.abs = AIiased(); } 

I (CONSTANT) { $$.abs = Constant(); } 

I (ALIASED CONSTANT) { $$.abs = AliasedConst(); } 


OBJECT_SUBTYPE_DEF ;:= 

(SUBTYPE_IND) { $$.abs= SubtypeInd(SUBTYPE_IND.abs); } 
I (ARRAY_TYPE) { $$.abs = ArrayType(ARRAY_TYPE.abs); } 


INIT_OPT ;:= () { $$.abs = InitOptNull(); } 

I (IS_ASSIGNED EXPRESSION) { $$.abs = ExprInitOpt(EXPRESSION.abs);} 


DISCRIM_PART_OPT ::=(){ $$.abs = DiscrimPartNull(); } 
I (‘(‘ DISCRIM_SPEC_S ')’) { 

DISCRIM_SPEC_S.tail = DiscrimSpecNil; 

$$.abs = DiscrimPart(DISCRIM_SPEC_S.rev); } 

I (X‘ BOX ‘)’) { $$.abs = Box();} 


TYPE_COMPLETION ::=(){ $$.abs = TypeComplNullQ; } 

I (IS TYPE_DEF) { $$.abs = TypeDefCompl(TYPE_DEF.abs);} 


TYPE_DEF ::= (‘(‘ ENUM_ID_S ‘)’) { 

ENUM_ID_S.tail = EnumIdNil; 

$$.abs = EnumTypeDef(ENUM_ID_S.rev); } 

I (INTEGER_TYPE) { $$.abs = IntTypeDef(INTEGER_TYPE.abs); } 
I (REAL_TYPE) { $$.abs= RealTypeDef(REAL_TYPE.abs); } 

I (ARRAY_TYPE) { $$,abs = ArrayTypeDef(ARRAY_TYPE.abs); } 

I (TAGGED_OPT LIMITED_OPT RECORD_DEF) { 


127 


$$.abs = RecordType(TAGGED_OPT.abs, LIMITED_OPT.abs, 
RECORD_DEF.abs); } 

I (ACCESS_TYPE) { $$.abs = AccessTypeDef(ACCESS_TYPE.abs);} 

1 (DERIVED_TYPE) { $$.abs = DerivedTypeDef(DERIVED_TYPE.abs); } 
I (PRIVATE_TYPE) { $$.abs = PrivateTypeDef(PRIVATE_TYPE.abs); } 


SUBTYPEJND ;;= (NAME CONSTRAINT) { 

$$.abs= SubtypeIndConstraint(NAME.abs, CONSTRAINT.abs); } 
I (NAME) { $$.abs = SubTypeIndName(NAME.abs); } 


CONSTRAINT ::= (RANGE_CONSTRAINT) { 

$$.abs = RangeConstraint(RANGE_CONSTRAINT.abs); 

} 

I (DIGITS EXPRESSION RANGE_CONSTR_OPT) { 

$$.abs = DecDigConstraint(EXPRESSION.abs, RANGE_CONSTR_OPT.abs); 

} 


DERIVED_TYPE ::= 

(NEW SUBTYPEJND) { $$.abs= NewDerivedType(SUBTYPEJND.abs); } 
I (NEW SUBTYPEJND WITH PRIVATE) { 

$$.abs = NewDerivedWithPrivate(SUBTYPEJND.abs); 

} 

I (NEW SUBTYPEJND WITH RECORD_DEF) { 

$$.abs = NewDerivedWithRecord(SUBTYPEJND.abs, RECORD_DEF.abs); 

} 

I (ABSTRACT NEW SUBTYPEJND WITH PRIVATE) { 

$$.abs = AbsNewDerivedWithPrivate(SUBTYPEJND.abs); } 

I (ABSTRACT NEW SUBTYPEJND WITH RECORD_DEF) { 

$$.abs = AbsNewDerivedWithRecord(SUBTYPEJND.abs, 
RECORD_DEF.abs); 

} 


RANGE_CONSTRAINT ::= (RaNGE RANGE) { $$.abs = Range(RANGE.abs); } 


RANGE :;= (SIMPLE_EXPRESSION DOT_DOT SIMPLE_EXPRESSION) { 
$$.abs = SimpleRange(SIMPLE_EXPRESSION$I.abs, 
SIMPLE_EXPRESSION$2.abs); 

} 

I (NAME TIC RaNGE) { $$.abs = NameTicRange(NAME.abs); } 
i (NAME TIC RaNGE 'C EXPRESSION ‘)’) { 

$$.abs = NameTicRangeExp(NAME.abs, EXPRESSION.abs); 


ENUMJD_S ::= (ENUMJD) {$$.rev = ENUMJD.abs::$$.tail;} 
I (ENUMJD_S •; ENUMJD) { 


128 


ENUM_ID_S$2.tail = ENUMJD.abs::$$.tail; 
$$.rev = ENUM_ID_S$2.rev; 

} 


ENUMJD ::= GD) { $$.abs = Id(Ident(ID)); } 

I (CHAR_LIT) { $$.abs = CharLit(CHAR_LIT);} 


INTEGER_TYPE ::= (RANGE_SPEC) { $$.abs = RangeSpec(RANGE_SPEC.abs);} 
I (MOD EXPRESSION) { $$.abs = ModExpr(EXPRESSION.abs); } 


RANGE_SPEC ::= (RANGE_CONSTRAINT) { 

$$.abs = RangeSpecConstr(RANGE_CONSTRAINT.abs); 

} 


RANGE_SPEC_OPT ::= () { $$.abs = RangeSpecOptNullQ; } 

1 (RANGE_SPEC) { $$.abs = RangeSpecOpt(RANGE_SPEC.abs);} 


REAL_TYPE ::= (DIGITS EXPRESSION RANGE_SPEC_OPT) { 

$$.abs= FloatType(EXPRESSION.abs,RANGE_SPEC_OPT.abs); } 
I (FIXED_TYPE) { $$.abs = Fixedlype(FIXED_TYPE.abs); } 


FIXED_TYPE ::= (DELTA EXPRESSION RANGE_SPEC) { 

$$.abs = FixedDelta(EXPRESSION.abs, RANGE_SPEC.abs); } 

1 (DELTA EXPRESSION DIGITS EXPRESSION RANGE_SPEC_OPT) { 
$$.abs = FixedDeltaDigits(EXPRESSION$l.abs,EXPRESSION$2.abs, 
RANGE_SPEC_OPT.abs); } 


ARRAY_TYPE ::= (ARRAY ‘(‘ INDEX_S ‘)’ OF COMPONENT_SUBTYPE_DEF) { 
INDEX_S.tail = IndexNil; 

$$.abs = UnconstrAiray(INDEX_S.rev, 

COMPONENT_SUBTYPE_DEF.abs); } 

I (ARRAY ‘(‘ ITER_DISCRETE_RANGE_S ‘)’ OF COMPONENT_SUBTYPE_DEF) { 
ITER_DISCRETE_RANGE_S.tail = DiscreteRangeNil; 

$$.abs = ConstrArray(ITER_DISCRETE_RANGE_S.rev, 
COMPONENT_SUBTYPE_DEF.abs); } 


COMPONENT_SUBTYPE_DEF ::= (ALIASED_OPT SUBTYPE_IND) { $$.abs = 
CompSubtypeDef(ALIASED_OPT.abs, SUBTYPE_IND.abs);} 


ALIASED_OPT ::=(){ $$.abs = AliasedOptNull();} 
1 (ALIASED) { $$.abs = AliasedOptQ; } 


129 







INDEX_S (NAME RaNGE BOX) {$$.rev = NAME.abs::$$.tail;} 
I (INDEX_S NAME RaNGE BOX) { 

INDEX_S$2.tail = NAME.abs::$$.taiI; 

SS.rev = INDEX_S$2.rev;} 


ITER_DISCRETE_RANGE_S ::= (DISCRETE_RANGE) { 

SS.rev = DISCRETE_RANGE.abs:;$$.tail;} 

I (ITER_DISCRETE_RANGE_S DISCRETE_RANGE) { 

ITER_DISCRETE_RANGE_SS2.tail = DISCRETE_RANGE.abs;;SS.tail; 
SS.rev = ITER_DISCRETE_RANGE_S$2.rev;} 


DISCRETE_RANGE ::= (NAME RANGE_CONSTR_OPT) { 

SS.abs= DiscRangeName(NAME.abs, RANGE_CONSTR_OPT.abs); } 
I (RANGE) { SS.abs = DiscRangeRange(RANGE.abs); } 


RANGE_CONSTR_OPT :;= () { SS.abs = EmptyRangeConstrOpt(); } 

I (RANGE_CONSTRAINT) { SS.abs = RangeConstr(RANGE_CONSTRAINT.abs); } 


RECORD_DEF ;:= (RECORD PRAGMA_S COMP_LIST END RECORD) { 
PRACiMA_S.tail = PragmasNil; 

SS.abs = Record(PRAGMA_S.rev, COMP_LIST,abs); } 

I (Null RECORD) { SS.abs = NullRecord();} 


TAGGED_OPT () { SS.abs = TaggedOptNull();} 

I (TAGGED) { SS.abs = Tagged(); } 

I (ABSTRACT TAGGED) { SS.abs = AbstractTagged(); } 


COMP_LIST ::= (COMP_DECL_S VARIANT_PART_OPT) { 
SS.abs = CompListWithVariant(COMP_DECL_S.abs, 
VARIANT_PART_OPT.abs); } 

I (VARIANT_PART PRAGMA_S) { 

PRAGMA_S.tail = PragmasNil; 

SS.abs = CompListWithPragma(VARIANT_PART.abs, 
PRAGMA_S.rev); } 

I (Null PRAGMA_S) { 

PRAGMA_S.tail = PragmasNil; 

SS.abs = NullWithPragma(PRACiMA_S.rev); } 


COMP_DECL_S (COMP_DECL) { SS.abs = CompDecl(COMP_DECL.abs); } 
I (COMP_DECL_S PRAGMA_S COMP_DECL) { 

PRAGMA_S.tail = PragmasNil; 

SS.abs = CompDeclList(COMP_DECL_SS2.abs, PRAGMA_S.rev, 


130 




COMP_DECL.abs); } 


VARIANT_PART_OPT ::= (PRAGMA_S) { 

PRACiMA_S.tail = PragmasNil; 

$$.abs = VariantPartOptPragma(PRAGMA_S.rev);} 
I (PRAGMA_S VARIANT_PART PRAGMA_S) { 
PRAGMA_S$1 .tail = PragmasNil; 
PRAGMA_S$2.tail = PragmasNil; 

$$. abs = VariantPartOpt(PRAGMA_S$ 1 .rev, 
VARIANT_PART.abs. PRAGMA_S$2.rev); } 


COMP_DECL ::= (DEF_ID_S COMPONENT_SUBTYPE_DEF INIT_OPT ‘;’) { 
DEF_ID_S.tail = DefldNil; 

$$.abs = CompDeclDefs(DEF_ID_S.rev, 

COMPONENT_SUBTYPE_DEF.abs, INIT_OPT.abs); } 


DISCRIM_SPEC_S ;:= (DISCRIM_SPEC) {$$.rev = DISCRIM_SPEC.abs:;$$.tail;} 
I (DISCRIM_SPEC_S DISCRIM_SPEC) { 

DISCRIM_SPEC_S$2.tail = DISCRIM_SPEC.abs;:$$.tail; 

$$.rev = DISCRIM_SPEC_S$2.rev; 

} 


DISCRIM_SPEC ::= (DEF_ID_S ACCESS_OPT MARK INIT_OPT) { 
DEF_ID_S.tail = DefldNil; 

$$.abs = DiscrimSpecDef(DEF_ID_S.rev, 

ACCESS_OPT.abs, MARK.abs, INIT_OPT.abs);} 


ACCESS_OPT :;= () { $$.abs = AccessOptNullQ;} 
I (ACCESS) { SS.abs = AccessOpt(); } 


VARIANT_PART ::= (CASE ID IS PRAGMA_S VARIANT_S END CASE ‘;’) { 
PRAGMA_S.tail = PragmasNil; 

VARIANT_S.tail = VariantNil; 

$$.abs = VariantPart(Ident(ID), PRAGMA_S.rev, 

VARIANT_S.rev); } 


VARIANT_S ::= (VARIANT) { $$.rev = VARIANT.abs::$$.tail;} 
I (VARIANT_S VARIANT) { 

VARIANT_S$2.tail = VARIANT.abs::$$.tail; 

$$.rev= VARIANT_S$2.rev; 

} 


VARIANT ::= (WHEN CHOICE_S RIGHT_SHAFT PRAGMA_S COMP_LIST) { 


131 







CHOICE_S.tail = ChoiceNil; 

PRAGMA_S.tail = PragmasNil; 

$$.abs = VariantChoice(CHOICE_S.rev, PRAGMA._S.rev, 
COMP_LIST.abs); } 


CHOICE_S ::= (CHOICE) {$$.rev = CHOICE.abs::$$.tail;} 
I (CHOICE_S T CHOICE) { 

CHOICE_S$2.taiI = CHOICE.abs::ChoiceNiI; 
$$.rev = CHOICE_S$2.rev; 

} 


CHOICE ;:= (EXPRESSION) { $$.abs = ChoiceExpr(EXPRESSION.abs); } 
I (DISCRETE_WITH_RANGE) { 

$$.abs = ChoiceRange(DISCRETE_WITH_RANGE.abs); 

} 

I (OTHERS) { $$.abs = ChoiceOthers(); } 


DISCRETE_WITH_RANGE ;:= 

(NAME RANGE_CONSTRAINT) { 

$$.abs = DiscreteNameRange(NAME.abs, 
RANGE_CONSTRAINT.abs); 

} 

I (RANGE) { $$.abs = DiscreteWithRange(RANGE.abs); } 


ACCESS_TYPE ::= 

(ACCESS SUBTYPEJND) { $$.abs = AccessSubtype(SUBTYPE_IND.abs);} 
I (ACCESS CONSTANT SUBTYPE_IND) { 

$$.abs = AccessConstSubtype(SUBTYPE_IND.abs); 

} 

I (ACCESS ALL SUBTYPEJND) { 

SS.abs = AccessAIlSubtype(SUBTYPE_IND.abs); 

} 

i (ACCESS PROT_OPT PROCEDURE FORMAL_PART_OPT) { 

SS.abs = AccessProcedure(PROT_OPT.abs, FORMAL_PART_OPT.abs); 

} 

I (ACCESS PROT_OPT FUNCTION FORMAL_PART_OPT RETURN MARK) { 
SS.abs = AccessFunction(PROT_OPT.abs, 

FORMAL_PART_OPT.abs, MARK.abs); 


PROT_OPT ::=(){ SS.abs = ProtOptNullQ; } 

I (PROTECTED) { SS.abs = Protected(); } 


DECL_ITEM_S ::=(){ SS.rev = SS.tail; } 
I (DECL_ITEM_S DECLJTEM) { 


132 


DECL JTEM_S$2.tail = DECL_ITEM.abs;;$$.tail; 
$$.rev = DECL_ITEM_S$2.rev; 

} 


DECLJTEM ::= PECL) { $$.abs = Decl(DECL.abs); } 

I (USE_CLAUSE) { $$.abs= UseClauseDecl(USE_CLAUSE.abs); } 
I (REP_SPEC) { $$.abs = DeclRepSpec(REP_SPEC.abs); } 

I (PRAGMA) { $$.abs = DeclPragina(PRAGMA.abs);} 


NAME ::= (ID) { $$.abs = SimpleName(Ident(ID));} 

I (NAME ‘(‘ VALUE_S ‘)’) { 

VALUE_S.tail = ValueNil; 

$$.abs = IndexComp(NAME$2.abs, VALlJE_S.rev); 

} 

I (SELECTED_COMP) { $$.abs = SelectedComp(SELECTED_COMP.abs); } 
I (NAME TIC ATTRIBUTEJD) { 

$$.abs = Attribute(NAME$2.abs, ATTRIBUTEJD.abs); 

} 

I (QUOTED_STRING) { $$.abs = OperatorSymbol(QUOTED_STRING);} 


MARK ::= (ID MARKLIST) { 

$$.abs = Mark(Ident(ID), MARKLIST.abs);} 


TICDOT (TIC ATTRIBUTEJD) { $$.abs = TicOpt(ATTRIBUTEJD.abs);} 
I (‘. JD) { $$.abs= DotOpt(Ident(ID));} 


MARKLIST 0 { $$.abs = MarkListNil;} 

I (TICDOT MARKLIST) { 

$$.abs = TICDOT.abs::MARKLIST$2.abs;} 


COMPOUND_NAME ;:= (ID) { $$,rev= Ident(ID);;$$.tail;} 
1 (COMPOUND_NAME ID) { 

COMPOUND_NAME$2.tail = Ident(ID)::$$.tail; 
$$.rev = COMPOUND_NAME$2,rev; 


C_NAME_LIST ::= (COMPOUND_NAME) { 

COMPOUND_NAME.tail = EmptyCompound; 

$$.rev = COMPOUND_NAME.rev::$$.tail; 

} 

I (C_NAME_LIST L’ COMPOUND_NAME) { 
COMPOUND_NAME.tail = EmptyCompound; 
C_NAME_LIST$2.taiI = COMPOUND_NAME.rev::$$.taiI; 
$$.rev = C_NAME_LIST$2.rev; 


133 








} 


VALUE_S ::= (VALUE) {$$.rev = VALUE.abs::$$.tail;} 
I (VALUE_S VALUE) { 

VALUE_S$2.tail = VALUE.abs::$$.tail; 

$$.rev = VALUE_S$2.rev; } 


VALUE ::= (EXPRESSION) { $$.abs = ValaeExpr(EXPRESSION.abs); } 

I (COMP_ASSOC) { $$.abs = ValueCompAssoc(COMP_ASSOC.abs); } 
I (DISCRETE_WITH_RANGE) { 

$$.abs = ValueDiscWithRange(DISCRETE_WITH_RANGE.abs); 

} 


SELECTED_COMP ::= (NAME ID) { $$.abs= DotId(NAME.abs, IdentaO)); } 
I (NAME CHAR_LIT) { 

$$.abs = DotUsedChar(NAME.abs, CHAR_LIT);} 

I (NAME QUOTED_STRING) { 

$$.abs = DotString(NAME.abs, QUOTED_STRING); } 

I (NAME ALL) { $$.abs = DotAll(NAME.abs); } 


ATTRIBUTEJD ::= (ID) { $$.abs = AttribId(Ident(ID));} 
I (DIGITS) { $$.abs = AttribDigits();} 

I (DELTA) { SS.abs = AttribDelta();} 

I (ACCESS) { $$.abs = AttribAccess();} 


INTEGER_CS ::= (INTEGER) {$$.abs = Integer(INTEGER);}; 

NUMERIC_LIT ::= (INTEGER_CS) {$$.abs = IntLitaNTEGER_CS.abs);} 
I (REAL_CS) {$$.abs = RealLit(REAL_CS);} 


LITERAL ::= (NUMERIC_LIT) { $$.abs = NumLit(NUMERIC_LIT.abs); } 
I (CHAR_LIT) { $$.abs = UsedChar(CHAR_LIT); } 

I (NuLL) { $$.abs = NilLit();} 


AGGREGATE ::= 

(‘(‘ COMP_ASSOC •)’) { $$.abs= AggCompAssoc(COMP_ASSOC.abs); } 
I (•(‘ VALUE_S_2 ‘)’) { $$.abs = AggValues2(VALUE_S_2.abs); } 

I (X^ EXPRESSION WITH VALUE_S ‘)’) { 

VALUE_S.tail = ValueNil; 

SS.abs = AggExprValue(EXPRESSION.abs, VALUE_S.rev); 

} 

I (■(• EXPRESSION WITH NuLL RECORD ')’) { 

$$,abs = AggExprWithNull(EXPRESSION.abs); 

1 

/ 


134 






I (‘(‘ Null record y) { $$.abs = AggExpNullRecO;} 


VALUE_S_2 :;= 

(VALUE L’ VALUE) { $$.abs = ValueS2Pair(VALUE$Labs, VALUE$2,abs); } 
I (VALUE_S_2 VALUE) { 

$$.abs = ValueS2List(VALUE_S_2$2.abs, VALUE.abs); 

} 


COMP ASSOC ::= (CHOICE_S RIGHT_SHAFT EXPRESSION) { 
CHOICE_S.tail = ChoiceNil; 

$$.abs = CompAssoc(CHOICE_S.rev, EXPRESSION.abs); 

} 


LOGICAL {syn expression expOut; 
inh expression expIn;}; 

SHORT_CIRCUIT {syn expression expOut; 
inh expression expIn;}; 

EXPRESSION (RELATION) { $$.abs = Relation(RELATION.abs);} 
I (EXPRESSION LOGICAL) { 

LOGICAL.expIn = EXPRESSION$2.abs; 

$$.abs = LOGICAL,expOut; 

} 

1 (EXPRESSION SHORT_CIRCUIT) { 

SHORT_CIRCUIT.expIn = EXPRESSION$2.abs; 

$$.abs= SHORT_CIRCUIT.expOut; 


LOGICAL ::= (AND RELATION) { 

SS.expOut = And($$.expIn,RELATION.abs); 

} 

I (OR RELATION) { 

SS.expOut = Or(SS.expIn,RELATION.abs); 

} 

I (XOR RELATION) { 

SS.expOut = Xor(SS.expIn,RELATION.abs); 

} 


SHORT_CIRCUIT ::= (AND THEN RELATION) { 

SS.expOut = AndThen(SS.expIn,RELATION.abs); 

} 

I (OR ELSE RELATION)) 

SS.expOut = OrElse(SS.expIn,RELATION.abs), 

} 


135 








RELATIONAL {syn relation relOut; 
inh simple_expression sein;}; 

MEMBERSHIP {syn relation rel Out; 
inh simple_expression seIn;}; 

RELATION ::= (SIMPLE_EXPRESSION RELATIONAL) { 
RELATIONAL, sein = SIMPLE_EXPRESSION.abs; 
$$.abs = RELATIONAL.relOut; 

} 

I (SIMPLE_EXPRESSION MEMBERSHIP) { 

MEMBERSHIP, sein = SIMPLE_EXPRESSION.abs; 
$$.abs = MEMBERSHIP.relOut; 

) 

/ 


RELATIONAL () (SS.relOut = SimpleExpr($$.seIn);} 

I (‘=’ SIMPLE_EXPRESSION) { 

$$.relOut = Equal($$.seIn,SIMPLE_EXPRESSION.abs); } 

I (NE SIMPLE_EXPRESSION) { 

SS.relOut = NotEqual($$.seIn,SIMPLE_EXPRESSION.abs); } 

I (LT_LT SIMPLE_EXPRESSION) { 

SS.relOut = LessThan($$.seIn,SIMPLE_EXPRESSION.abs); } 

I (LT_EQ SIMPLE_EXPRESSION) { 

SS.relOut = LessThanEq(SS.seIn,SIMPLE_EXPRESSION.abs); } 

I (GT_GT SIMPLE_EXPRESSION) { 

SS.relOut = GreaterThan(SS.seIn,SIMPLE_EXPRESSION.abs);} 

I (GE SIMPLE_EXPRESSION) { 

SS.relOut = GreaterThanEq(SS.seIn,SIMPLE_EXPRESSION.abs); } 


MEMBERSHIP (INRANGE) { SS.relOut = RangeMember(SS.seIn,In,RANGE.abs); } 
I (NOT IN RANGE) { SS.relOut = RangeMerabei<SS.seIn,NotIn,RANGE.abs); } 
i (IN NAME) { SS.relOut = NameMember(SS.seIn,In,NAME.abs); } 

I (NOT IN NAME) { SS.relOut = NameMember(SS.seIn,NotIn,NAME.abs); } 


ADDING {syn simple_expression seOut; 
inh siinple_expression sein;}; 

UNARY {syn simple_expression abs;}; 

SIMPLE_EXPRESSION ;:= (UNARY) {SS.abs = UNARY.abs;} 
I (■-’ TERM) {SS.abs = Tenn(Minus(),TERM.abs);} 

I (SIMPLE_EXPRESSION ADDING) { 

ADDING.seIn = SIMPLE_EXPRESSIONS2.abs; 

SS.abs = ADDING.seOut; 

} 


136 



UNARY ::= (TERM) {$$.abs = Term(UnaiyNullJERM.abs);} 
I (‘+’ TERM) {$$.abs = Tenn(Plus,TERM.abs);} 

I TERM) {$$.abs = Tenn(Minus,TERM.abs);} 


ADDING ::=(‘+’ TERM) { 

SS.seOut = Addition($$.seIn,TERM.abs); 

} 

I TERM) { 

SS.seOut = Subtraction(SS.seIn,TERM.abs); 

} 

I (‘&’ TERM) { 

SS.seOut = Concat(SS.seIn,TERM.abs); 

} 


MULTIPLYING {syn term termOut; 
inh term termln;}; 

TERM ::= (FACTOR) { SS.abs = Factor(FACTOR.abs);} 
i (TERM MULTIPLYING) { 

MULTIPLYING.termln = TERMS2.abs; 

SS.abs = MULTIPLYING.termOut; 

} 


MULTIPLYING ::= (‘*’ FACTOR) {SS.termOut = Mult(SS.termIn,FACTOR.abs);} 
I (7’ FACTOR) {SS.termOut = Divide(SS.termIn,FACTOR.abs);} 

I (MOD FACTOR) {SS.termOut = Mod(SS.termIn,FACTOR.abs);} 

I (REM FACTOR) {SS.termOut = Rem(SS.tennIn,FACTOR.abs);} 


FACTOR ::= (PRIMARY) { SS.abs = Primary(PRIMARY.abs);} 

I (NOT PRIMARY) { SS.abs = NotPnmaiy(PRIMARY.abs);} 
I (ABS PRIMARY) { SS.abs = AbsPrimaiy(PRIMARY.abs);} 
I (PRIMARY EXPON PRIMARY prec EXPON) { 

SS.abs = Expon(PRIMARYSl.abs.PRIMARYSl.abs);} 


PRIMARY ::= (LITERAL) { SS.abs = LiteraKLITERAL.abs); } 

I (NAME) { SS.abs = PrimaryName(NAME.abs); } 

I (ALLOCATOR) { SS.abs =' Allocator(ALLOCATOR.abs);} 

I (QUALIFIED) { SS.abs = Qualified(QUALIFIED.abs); } 
i (‘(‘ EXPRESSION ‘)’) { SS.abs = Parens(EXPRESSION.abs);} 
I (AGGREGATE) { SS.abs = PrimaryAgg(AGGREGATE.abs); } 


QUALIFIED ::= (NAME TIC AGGREGATE) { 

SS.abs = NameTicAgg(NAME.abs, AGGREGATE.abs); } 

I (NAME TIC ■(■ EXPRESSION ‘)’) { 

SS.abs = NameTicExpr(NAME.abs, EXPRESSION.abs); } 


137 



ALLOCATOR ::= (NEW NAME) { $$.abs = newName(NAME.abs); } 

I (NEW QUALIFIED) { $$.abs= NewQualified(QUALIFIED.abs); } 


SUBPROG_DECL ;;= 

(GENERIC GENERIC_FORMAL_PART SUBPROG_SPEC PSDL_MET_OPT) { 
GENERIC_FORMAL_PART.tail = GenericNil; 

$$.abs = SubprogSpec(GenericHdr(GENERIC_FORMAL_PART.rev), 
SUBPROG_SPEC. abs, PSDL_MET_OPT.abs); 

} 

I (SUBPROG_SPEC PSDL_MET_OPT) { 

$$.abs = SubprogSpec(GenericHdrNil, 

SUBPROG_SPEC.abs, PSDL_MET_OPT.abs); 

} 

|(SUBPROCt_SPEC is GENERICJNST PSDL_COMMENT PSDL_MET_OPT) { 
$$.abs = GenericSubprogInst(SUBPROG_SPEC.abs, 

GENERICJNST.abs, PSDL_MET_OPT.abs); } 

I (SUBPROG_SPEC IS ABSTRACT PSDL_MET_OPT) { 

$$.abs = AbstractSubprogSpec(SUBPROG_SPEC.abs, 

PSDL_MET_OPT.abs);} 


PSDL_MET_OPT ::=(){ $$.abs = MetNullQ; } 

I (PSDL_COMMENT MAXIMUM EXECUTION TIME INTEGER_CS USEC) { 
$$.abs = MetUsec(INTEGER_CS.abs); } 

I (PSDL_COMMENT MAXIMUM EXECUTION TIME INTEGER_CS MS) { 
$$.abs = MetMs(INTEGER_CS.abs);} 

I (PSDL_COMMENT MAXIMUM EXECUTION TIME INTEGER_CS SEC) { 
$$.abs = MetSec(INTEGER_CS,abs); } 

I (PSDL_COMMENT MAXIMUM EXECUTION TIME INTEGER_CS MIN) { 
$$.abs = MetMin(INTEGER_CS.abs); } 

I (PSDL_COMMENT MAXIMUM EXECUTION TIME INTEGER_CS HRS) { 
$$,abs = MetHrs(INTEGER_CS.abs); } 


SUBPROCi_SPEC ::= (PROCEDURE COMPOUND_NAME FORMAL_PART_OPT) { 
COMPOUND_NAME.tail = EmptyCompound; 

$$,abs = SubProgProc(COMPOUND_NAME.rev, FORMAL_PART_OPT.abs); 
/ 

I (FUNCTION DESIGNATOR FORMAL_PART_OPT RETURN NAME) { 

$$.abs = SubProgFuncRetum(DESIGNATOR.abs, 

FORMAL_PART_OPT.abs, NAME.abs); } 

I (FUNCTION DESIGNATOR) { 

$$,abs = SubProgFunc(DESICiNATOR.abs); 

} /* for generic inst and generic rename */ 


DESIGNATOR ::= (COMPOUND_NAME) { 

COMPOUND_NAME.tail = EmptyCompound; 


138 




$$.abs= DesigCompound(COMPOUND_NAME.rev); } 

I (QUOTED_STRING) { $$.abs = DesigString(QUOTED_STRING); } 


FORMAL_PART_OPT ::=(){ $$.abs = FonnalPartOptNull(); } 
I (‘(‘ PARAM_S “)’) { 

PARAM_S.tail = ParamNil; 

$$.abs = FormalPart(PARAM_S.rev);} 


PARAM_S ::= (PARAM) {$$.rev = PARAM.abs::$$.tail;} 
I (PARAM_S PARAM) { 

PARAM_S$2.tail = PARAM.abs::$$.tail; 

$$.rev = PARAM_S$2.rev;} 


PARAM ;:= (DEF_ID_S MODE MARK INIT_OPT) { 

DEF_ID_S.tail = DefldNil; 

$$.abs = ParamId(DEF_ID_S.rev, MODE.abs, MARK.abs, INIT_OPT.abs); 

} 


MODE ;:= () { $$.abs = ModeNull();} 

I (IN) { $$.abs = InModeO;} 

I (OUT) { $$.abs = OutModeO; } 

I (IN OUT) { $$.abs = InOutModeQ; } 

I (ACCESS) { $$.abs = AccessMode();} 


PKG_DECL ::= 

(GENERIC GENERIC_FORMAL_PART PKG_SPEC ‘;’) { 
GENERIC_FORMAL_PART.tail = GenericNil; 

$$.abs = PkgSpec(GenericHdr(GENERIC_FORMAL_PART,rev), 
PKG_SPEC,abs);} 

I (PACKAGE COMPOUND_NAME IS GENERICJNST ‘;’) { 
COMPOUND_NAME.tail = EmptyCompound; 

SS.abs = GenPkgInst(COMPOUND_NAME.rev, GENERICJNST. abs); 

} 

I (PKG_SPEC ‘;’) { 

$$.abs = PkgSpec(GenericHdrNiI, PKG_SPEC.abs); 

} 


PKG_SPEC ;:= 

(PACKAGE COMPOUND_NAME IS DECLJTEM_S PRIVATE_PART END 
C JD_OPT) { 

COMPOUND_NAME.tail = EmptyCompound; 

DECL JTEM_S.tail = DeclListNil; 

SS.abs = Package(COMPOUND_NAME.rev, DECL JTEM_S.rev, 
PRIVATE_PART.abs); 


139 



C_ID_OPT ::= () 

I (COMPOUND_NAME) {COMPOUND_NAME.tail = Empty Compound;} 


PRIVATE_PART ;:= () { $$.abs = PrivatePartNull(); } 
I (PRIVATE DECL_ITEM_S) { 

DECL_ITEM_S.tail = DeclListNil; 

$$.abs = Private(DECL_ITEM_S rev);} 


PRIVATE_TYPE ::= (TAGGED_OPT LIMITED_OPT PRIVATE) { 

$$.abs = PrivateType(TAGGED_OPT.abs, LIMITED_OPT.abs); } 


LIMITED_OPT ::=(){ $$.abs = LimitedOptNull(); } 
I (LIMITED) { $$.abs = Limited();} 


USE_CLAUSE ::= (USE NAME_S ‘;’) { 
NAME_S.taiI = NameNil; 

SS.abs = Use(NAME_S.rev);} 

I (USE TYPE NAME_S ';’) { 
NAME_S.tail = NameNil; 

$$.abs = UseType(NAME_S.rev);} 


NAME_S ::= (NAME) { $$.rev = NAME.abs:;$$.tail;} 
I (NAME_SNAME) { 

NAME_S$2.tail = NAME.abs;;$$.tail; 

$$.rev = NAME_S$2.rev; } 


RENAME_DECL :;= 

(DEF_ID_S OBJECT_QUALIFIER_OPT SUBTYPEJND RENAMES ‘;’) { 
DEF_ID_S.taiI = DefldNil; 

$$.abs = RenameDeclSub(DEF_ID_S.rev, 

OBJECT_QUALIFIER_OPT.abs, SUBTYPEJND.abs, RENAMES.abs); 

} 

I (DEFJD_S EXCEPTION RENAMES ‘;’) { 

DEFJD_S.tail = DefldNil; 

$$.abs = RenameExc(DEF_ID_S.rev, RENAMES.abs); 

} 

I (RENAME_UNIT) { SS.abs = RenameUnitDecl(RENAME_UNIT.abs); } 


RENAME JJNIT ::= (GENERIC GENERIC_FORMAL_PART 
PACKAGE COMPOUND_NAME RENAMES ‘;’) { 
GENERIC_FORMAL_PART.tail = GenericNil; 
COMPOUND_NAME.tail = EmptyCompound; 


140 





$$.abs = RenamePkg(GenericHdr(CiENERIC_FORMAL_PART.rev), 
COMPOUND_NAME.rev, RENAMES.abs); } 

I (PACKAGE COMPOUND_NAME RENAMES { 
COMPOUND_NAME.tail = EmptyCompound; 

$$.abs = RenamePkg(GenericHdrNil, COMPOUND_NAME.rev, 
RENAMES.abs); } 

I (GENERIC GENERIC_FORMAL_PART SUBPROG_SPEC RENAMES { 
GENERIC_FORMAL_PART.tail = GenencNil; 

$$.abs = RenameSubprog(GenericHdr(GENERIC_FORMAL_PART.rev), 
SUBPROG_SPEC.abs. RENAMES.abs); } 

I (SUBPROG_SPEC RENAMES ‘;’) { 

$$.abs = RenameSubprog(GenericHdrNil, SUBPROG_SPEC.abs, 
RENAMES.abs); } 


RENAMES ::= (ReNAMES NAME) { $$.abs = Renames(NAME.abs); } 


TASK_SPEC ::= 

(TASK ID TASK_DEF) { $$.abs = SimpIeTask(Ident(ID), TASK_DEF.abs);} 
I (TASK TYPE ID DISCRIM_PART_OPT TASK_DEF) { 

SS.abs = TaskTypeadent(ID),DISCRIM_PART_OPT.abs, 
TASK_DEF.abs); } 


TASK_DEF ::=(){ SS.abs = TaskDefNullQ; } 

I (IS ENTRY_DECL_S REP_SPEC_S TASK_PRIVATE_OPT END ID_OPT) { 
SS.abs = TaskDef(ENTRY_DECL_S.abs, REP_SPEC_S.abs, 
TASK_PRIVATE_OPT.abs);} 


ID_OPT ::= 0 

KID) 


TASK_PRIVATE_OPT ::=(){ SS.abs = TaskPvtOptNullO;} 

I (PRIVATE ENTRY_DECL_S REP_SPEC_S) { 

SS.abs = TaskPvtOpt(ENTRY_DECL_S.abs, REP_SPEC_S.abs); } 


PROT_SPEC :;= 

(PROTECTED ID PROT_DEF) { SS.abs = Prot(Ident(IDX PROT_DEF.abs); } 
1 (PROTECTED TYPE ID DISCRIM_PART_OPT PROT_DEF) { 

SS.abs = ProtType(Ident(ID), DISCRIM_PART_OPT.abs, 
PROT_DEF.abs); } 


PROT_DEF ::= (IS PROT_OP_DECL_S PROT_PRIVATE_OPT END ID_OPT) { 
PROT_OP_DECL_S.tail = ProtOptDecIListNil; 

SS.abs = ProtDef(PROT_OP_DECL_S.rev, PROT_PRIVATE_OPT.abs); } 


141 



PROT_PRIVATE_OPT ::=(){ $$.abs = ProtPvtOptNulI(); } 

I (PRIVATE PROT_ELEM_DECL_S) { 

PROT_ELEM_DECL_S.tail = ProtElemDecINil; 
$$.abs = ProtPvtOpt(PROT_ELEM_DECL_S.rev); } 


PROT_OP_DECL_S ;:=(){ $$.rev = $$.tail;} 

I (PROT_OP_DECL_S PROT_OP_DECL) { 

PROT_OP_DECL_S$2.tail = PROT_OP_DECL.abs;;$$.tail; 
$$.rev = PROT_OP_DECL_S$2.rev;} 


PROT_OP_DECL ::= (ENTRY_DECL) { $$.abs= EntiyDecl(ENTRY_DECL.abs); } 
I (SUBPROG_SPEC { $$.abs = ProtOptSubprog(SUBPROG_SPEC.abs); } 

I (REP_SPEC) { $$.abs = RepSpec(REP_SPEC.abs); } 

I (PRAGMA) { $$.abs = ProtOptPragma(PRAGMA.abs); } 


PROT_ELEM_DECL_S ::=(){ $$.rev = SS.tail;} 

I (PROT_ELEM_DECL_S PROT_ELEM_DECL) { 

PROT_ELEM_DECL_S$2.tail = PROT_ELEM_DECL.abs:;$$.tail; 
$$.rev = PROT_ELEM_DECL_S$2.rev; } 


PROT_ELEM_DECL ;;= 

(PROT_OP_DECL) { $$.abs = ProtOptDecl(PROT_OP_DECL.abs); } 

I (COMP_DECL) { $$.abs = ProtElemCompDecl(COMP_DECL.abs);} 


ENTRY_DECL_S ;:= (PRAGMA_S) { 

PRAGMA_S.tail = PragmasNil; 

$$.abs = EntryDeclPragma(PRAGMA_S.rev); } 

I (ENTRY_DECL_S ENTRY_DECL PRAGMA_S) { 
PRAGMA_S.tail = PragmasNil; 

$$.abs = EntryDeclPragmaList(ENTRY_DECL_S$2.abs, 
ENTRY_DECL.abs, PRAGMA_S.rev); } 


ENTRY_DECL ::= (ENTRY ID FORMAL_PART_OPT { 

$$.abs = EntryDeclId(Ident(ID), FORMAL_PART_OPT.abs); } 

I (ENTRY ID ‘(‘ DISCRETE_RANGE FORMAL_PART_OPT { 
$$.abs = EntryRange(Ident(ID), DISCRETE_RANGE.abs, 
FORMAL_PART_OPT.abs);} 


REP_SPEC_S :;= () { $$.abs = RepSpecNullQ; } 

I (REP_SPEC_S REP_SPEC PRAGMA_S) { 

PRAGMA_S.tail = PragmasNil; 

$$.abs = RepSpecList(REP_SPEC_S$2.abs, REP_SPEC.abs. 
PRAGMA_S.rev); } 


142 







COMP_UNIT::= 

(CONTEXT_SPEC_OPT PRIVATE_OPT PKG_DECL PRAGMA_S) { 
PRAGMA_S.tail = PragmasNil; 

$$.abs = CompUnit(CONTEXT_SPEC_OPT.abs, PRIVATE_OPT.abs, 
PKG_DECL.abs, PRAGMA_S.rev);} 


PRIVATE_OPT ::=(){ $$.abs = PrivateOptNull(); } 
I (PRIVATE) { $$.abs = PrivateOptO; } 


CONTEXT_SPEC_OPT ::=(){ $$.abs = ContextSpecNullQ; } 

I (CONTEXT_SPEC) { $$.abs = ContextSpec(CONTEXT_SPEC.abs); } 


CONTEXT_SPEC ::= 

(CONTEXT_SPEC_OPT WITH_CLAUSE USE_CLAUSE_OPT) { 
USE_CLAUSE_OPT.tail = UseClauseOptNil; 

$$,abs = ContextWithUse(CONTEXT_SPEC_OPT.abs, 
WITH_CLAUSE.abs, USE_CLAUSE_OPT.rev);} 

I (CONTEXT_SPEC PRAGMA) { 

$$.abs = ContextPragma(CONTEXT_SPEC$2.abs, PRAGMA.abs); } 


WITH_CLAUSE ::= (WITH C_NAME_LIST ‘;’) { 
C_NAME_LIST.tail = CompoundNameNil; 
SS.abs = WithClause(C_NAME_LIST.rev);} 


USE_CLAUSE_OPT ::=(){ $$.rev = $$.tail;} 

I (USE_CLAUSE_OPT USE_CLAUSE) { 

USE_CLAUSE_OPT$2,tail =USE_CLAUSE.abs: :$$.tail; 
$$.rev = USE_CLAUSE_OPT$2.rev; } 


BODY_STUB ::= (TASK BoDY ID IS SEPARATE ‘;’) { $$.abs = TaskStub(Ident(ID)); } 
I (PACKAGE Body C0MP0UND_NAME IS SEPARATE ‘;’) { 
COMPOUND_NAME.tail = EmptyCompound; 

$$.abs = PkgStub(COMPOUND_NAME.rev); } 

I (SUBPROG_SPEC IS SEPARATE •;’) { 

$$.abs = SubprogStub(SUBPROG_SPEC.abs);} 

I (PROTECTED BoDY ID IS SEPARATE ‘;’) { 

$$.abs= ProtStub(Ident(ID));} 


GENERIC_FORMAL_PART ::=(){ $$.rev = $$.tail;} 

I (GENERIC_FORMAL_PART GENERIC_FORMAL) { 

GENERIC_FORMAL_PART$2.tail = GENERIC_FORMAL.abs::$$.tail; 
$$.rev = GENERIC_FORMAL_PART$2.rev; } 


143 







GENERIC_FORMAL ::= (PARAM { $$.abs= GenPann(PARAM.abs); } 

I (TYPE ID GENERIC_DISCRIM_PART_OPT IS GENERIC_TYPE_DEF { 
$$.abs= GenTypeParm(Ident(ID), GENERIC_DISCRIM_PART_OPT.abs, 
GENERIC_TYPE_DEF.abs);} 

I (WITH PROCEDURE ID FORMAL_PART_OPT SUBP_DEFAULT { 
$$.abs = GenProcParm(Ident(ID), FORMAL_PART_OPT.abs, 
SUBP_DEFAULT.abs); } 

I (WITH FUNCTION DESIGNATOR FORMAL_PART_OPT RETURN NAME 
SUBP_DEFAULT { 

$$.abs = GenFuncPanii(DESIGNATOR.abs, FORMAL_PART_OPT.abs, 
NAME.abs, SUBP_DEFAULT.abs); } 

I (WITH PACKAGE ID IS NEW NAME ‘(‘ BOX ‘)’ { 

$$.abs = GenPkgPannBox(Ident(ID), NAME.abs); } 

I (WITH PACKAGE ID IS NEW NAME { 

$$.abs = GenPkgParm(Ident(ID), NAME.abs);} 

I (USE_CLAUSE) { $$.abs = GenUseparm(USE_CLAUSE.abs); } 


GENERIC_DISCRIM_PART_OPT ;:= () { $$.abs = GenDiscOptNullO; } 
I (‘(‘ DISCRIM_SPEC_S ‘)’) { 

DISCRIM_SPEC_S.tail = DiscrimSpecNil; 

$$.abs = GenDisc(DISCRIM_SPEC_S.rev); } 

I (‘(‘ BOX ‘)’) { SS.abs = GenBox(); } 


SUBP_DEFAULT ::=(){ SS.abs = SubpDefaultNull(); } 

I (IS NAME) { SS.abs = SubpDetName(NAME.abs); } 
I (IS BOX) { SS.abs = SubpDeffloxQ;} 


GENERIC_TYPE_DEF (‘(‘ BOX “)’) { SS.abs = GenTypeBox(); } 

I (RaNGE BOX) { SS.abs = GenTypeRangeBox(); } 

I (MOD BOX) { SS.abs = GenTypeModBox(); } 

I (DELTA BOX) { SS.abs = GenTypeDeltaBox();} 

I (DELTA BOX DIGITS BOX) { SS.abs = GenTypeDeltaDigBox(); } 

I (DIGITS BOX) { SS.abs = GenTypeDigitsBox(); } 

I (ARRAY_TYPE) { SS.abs = GenTypeArray(ARRAY_TYPE.abs); } 

I (ACCESS_TYPE) { SS.abs = GenTypeAccess(ACCESS_TYPE.abs); } 
I (PRIVATE_TYPE) { SS.abs = GenTypePriv(PRIVATE_TYPE.abs);} 

I (GENERIC_DERIVED_TYPE) { 

SS.abs = GenTypeDerived(GENERIC_DERIVED_TYPE.abs); } 


GENERIC_DERIVED_TYPE ::= 

(NEW SUBTYPEJND) { SS.abs = GenDerivedSubt(SUBTYPE_IND.abs); } 
I (NEW SUBTYPEJND WITH PRIVATE) { 

SS.abs = GenDerivedSubtPriv(SUBTYPEJND.abs); } 

I (ABSTRACT NEW SUBTYPEJND WITH PRIVATE) { 

SS.abs = GenDerivedAbst(SUBTYPEJND.abs); } 


144 





GENERICJNST ::= (NEW NAME) { $$.abs =GenInst(NAME.abs); } 


REP_SPEC ::= (FOR MARK USE EXPRESSION { 

$$.abs = AttribDef(MARK.abs, EXPRESSION.abs); } 

I (FOR MARK USE RECORD ALIGN_OPT COMP_LOC_S END RECORD { 
SS.abs = RecordTypeSpec(MARK.abs, ALIGN_OPT.abs, 
COMP_LOC_S.abs); } 

I (FOR MARK USE AT EXPRESSION { 

SS.abs = AddressSpec(MARK.abs, EXPRESSION.abs); } 


ALIGN_OPT ::=(){ SS.abs = AlignOptNuII(); } 

I (AT MOD EXPRESSION ‘;’) { SS.abs = AIignOpt(EXPRESSION.abs); } 


COMP_LOC_S ::=(){ SS.abs = CompLocNuII(); } 

I (COMP_LOC_S MARK AT EXPRESSION RaNGE RANGE ‘;’) { 
SS.abs = CompLocList(COMP_LOC_SS2.abs, MARK.abs, 
EXPRESSION.abs, RANGE.abs); } 


145 


146 



APPENDIX E. SSL SOURCE CODE: TRANSFORMATIONS 


The source code below is used to specify the allowable transformations for Ada 95 
productions. Transformation declarations specify the manner in which a user may 
manipulate the abstract syntax tree while using the translator in the interactive mode. 

I* :|t*!|t*!(t*!(t*!|(*:(t***** + !|i:|:*********************i(ei(r***i(t********!(i!(t*i|=***J|i:(c*!|t!t;!|t***!(t/ 


/* File; transforms. ada9x.ssl *! 

/* Date: 3 March, 1995 */ 

/* Author; Chris Eagle */ 

/* System: Sun SPARCstation */ 

/* Description: This file contains the transform rules which */ 

/* specify the ways in which users of the syntax directed *! 

/* may transform the syntax tree of an Ada 9x package */ 

/* specification. */ 


transform compilation 

on “PKG DECL” <compilation>: Compilation(<pragma_s>, 

CUList(<comp_unit>,[comp_unitJist])) 


transform comp_unit_list 

on “COMP_UNIT” <comp_unit_list>; CUList(<comp_unit>, [comp_unit_list]) 


transform pragma 
on “ID” 
on“LIST” 


transform pragma_arg 
on “EXPR” 
on “NAMED” 


transform decl 

on “OBJECT” <decl>: ObjDecl(<def_id_s>, <object_qualifier_opt>, 

<object_subtype_def>, <init_opt>), 

on “NUMERIC” <decl>: NumDecl(<def_id_s>, <expression>), 

on “TYPE” <decl>: TypeDecl(<identifier>, <discrim_part_opt>, 

<type_completion>). 

on “SUBTYPE” <decl>: SubTypeDecl(<identifier>, <subtype_ind>), 

on “SUBPROG” <decl>: SubProgDecl(<subprog_decl>), 

on “PKG” <decl>; PkgDecl(<pkg_decl>), 

on “TASK” <decl>: TaskDecl(<task_spec>), 


<pragma_arg>: PragmaExp(<expression>), 
<pragma_arg>: PragmaNameExp(<identifier>, 
<expression>) 


<pragma>: Pragmald(<identifier>), 

<pragma>: PragmaSimple(<identifier>, <pragma_arg_s>) 


147 


on “PROTECTED” <decl>: ProtDecl(<prot_speO), 

on “EXCEPTION” <decl>: ExcDecl(<def_id_s>), 

on “RENAMES” <decl>: RenameDecI(<rename_decl>), 

on “BODY_STUB” <decl>: BodyStubDecl(<body_stub>) 


transform object_subtype_def 

on “SUBTYPE” <object_subtype_def>; Subtypelnd(<subtype_ind>), 

on “ARRAY” <object_subtype_def>:ArrayType(<array_type>) 


transform type_def 
on “ENUM” 
on “INT” 
on “REAL” 
on “ARRAY” 
on “RECORD” 

on “ACCESS” 
on “DERIVED” 
on “PRIVATE” 


<type_def>; EnumTypeDef(<enum_id_s>), 
<type_def>: IntTypeDef(<integer_type>), 
<type_def>: ReaITypeDef(<real_type>), 
<type_def>: ArrayTypeDef(<array_type>), 
<type_def>: RecordType(<tagged_opt>, 
<Iimited_opt>, <record_def>), 
<type_def>: AccessTypeDef(<access_type>), 
<type_def>: DerivedTypeDef(<derived_type>), 
<type_def>: PrivateTypeDef(<private_type>) 


transform subtype_ind 

on “CONSTRAINT” <subtype_ind>: SubtypeIndConstraint(<name>, 

<constraint>), 

on “NAME” <subtype_ind>: SubTypeIndName(<name>) 


transform constraint 

on “RANGE” <Constraint>: RangeConstraint(<range_constraint>), 

on “DIGITS” <constraint>: DecDigConstraint(<6xpression>, 

<range_constr_opt>) 


transform derived_type 

on “NEW” <derived_type>: NewDerivedType(<subtype_ind>), 

on “NEW_PRIVATE” <derived_type>; NewDerivedWitIiPrivate(<subtype_ind>), 

on “NEW_RECORD” <derived_type>: NewDerivedWithRecord(<subtype_ind>, 

<record_def>), 

on “ABSTRACT_PRIVATE” <derived_type> 


: AbsNewDerivedWithPrivate(<subtype_ind>), 
on “ABSTRACT_RECORD” <derived_type>: 

AbsNewDerivedWithRecord(<subtype_ind>, 

<record_def>) 


transform range 

on“..” <range>: SimpIeRange(<simple_expression>, 

<simple_expression>). 


148 


on “‘RANGE” 
on “-RANGECEXPR)” 


transform enum_id 
on “ID” 

on “CHAR LIT” 


transform integer_type 
on “RANGE” 
on “MOD” 


transform real_type 
on “FLOAT” 
on “FIXED” 


transform fixed_type 
on “DELTA” 
on “DLETA_DIGITS” 


transform array_type 

on “UNCONSTRAINED” 

on “CONSTRAINED” 


transform discrete_range 
on “NAME” 

on “RANGE” 


transform record_def 
on “RECORD” 
on “NULL” 


transform comp_list 
on “VARIANT” 

on "PRAGMA” 

on "NULL” 


<range>: NameTicRange(<name>), 

<range>: NameTicRangeExp(<name>, <expression>) 


<enum_id>: Id(<identifier>), 
<enum_id>; CharLit(<CHAR_LIT>) 


<integer_type>; RangeSpec(<range_spec>), 
<integer_type>; ModExpr(<expression>) 


<real_type>: FIoatType(<expression>, <range_spec_opt>), 
<real_type>: FixedType(<fixed_type>) 


<fixed_type>: FixedDelta(<expression>, <range_speO), 
<fixed_type>: FixedDeltaDigits(<expression>, 
<expression>, <range_spec_opt>) 


<array_type>: UnconstrArray{<index_s>, 
<component_subtype_def>), 

<array_type>: ConstrAiTay(<iter_discrete_range_s>, 
<component_subtype_defi») 


<discrete_range>; DiscRangeName(<name>, 
<range_constr_opt>), 

<discrete_range>; DiscRangeRange(<range>) 


<record_def>: Record(<pragma_s>, <comp_list>), 
<record def>: NullRecord 


<comp_Iist>; CompListWithVariant(<tomp_decI_s>, 
<variant_part_opt>), 

<comp_list>: CompListWithPragma(<variant_part>, 
<pragma_s>), 

<comp_list>: NulIWithPragma(<pragma_s>) 


149 





transform variant_part_opt 
on “PRAGMA” 
on “VARIANT” 


transform choice 
on “EXPR” 
on “RANGE” 
on “OTHERS” 


transform access_type 
on “SUBTYPE” 
on “CONST_SUBTYPE” 
on “A11_SYBTYPE” 
on “PROCEDURE” 

on “FUNCTION” 


transform decl_item 
on“DECL” 
on “USE_CLAUSE” 
on “REP_SPEC” 
on “PRAGMA” 


transform name 
on “SIMPLE” 
on “INDEX” 
on “SELECTED” 
on “ATTRIBUTE” 
on “OPERATOR” 


transform mark 
on “MARK” 


transform ticdot 
on “ATTR” 
on ".ID” 


transform compound_name 
on " ID” 


<variant_part_opt>: VariantPartOptPragma(<pragma_s>), 
<variant_part_opt>; VariantPartOpt(<pragma_s>, 
<variant_part>, <pragma_s>) 


<choice>: ChoiceExpr(<expression>), 

<choice>: ChoiceRange(<discrete_with_range>), 
<choice>; ChoiceOthers 


<access_type>: AccessSubtype(<subtype_ind>), 
<access_type>: AccessConstSubtype(<subtype_ind>), 
<access_type>: AccessAIlSubtype(<subtype_ind>), 
<access_type>: AccessProcedure(<prot_opt>, 
<formal_part_opt>), 

<access_type>: AccessFunction(<prot_opt>, 
<formal_part_opt>, <maik>) 


<decl_item>: Decl(<decl>), 

<decl_itein>: UseClauseDecl(<use_clause>), 
<decl_item>: DeclRepSpec(<rep_speo), 
<decl_item>: DeclPragma(<pragma>) 


<name>: SimpleName(<identifiei>), 

<name>: IndexComp(<name>, <value_s>), 
<name>; SelectedComp(<seIected_comp>), 
<name>: Attribute(<name>, <attribute_id>), 
<name>: OperatorSymbol(<QUOTED_STRING>) 


<mark>: Mark(<identifier>, <marklist>) 


<ticdot>: TicOpt(<attribute_id>), 
<ticdot>; DotOpt(<identifier>) 


<compound_name>: DotCompound(<identifier>, 
<compound_name>) 


150 


transforai value 

on “EXPR” <value>: ValueExpr(<expression>), 

on “COMP_ASSOC” <value>: ValueCompAssoc(<conip_assoc>), 

on “DISC_WITH_RANGE” <value>: ValueDiscWithRange(<discrete_with_range>) 


transform selected_comp 
on “DOTJD” 
on “DOT_CHAR” 
on “DOT_STRING” 

on “DOT ALL” 


<selected_comp>: DotId(<name>, <identifier>), 
<selected_comp>: DotUsedChar(<name>, <CHAR_LIT>), 
<selected_comp>: DotString(<name>, 
<QUOTED_STRING>), 

<selected_comp>: DotAll(<name>) 


transform attribute_id 
on “ID” 
on “DIGITS” 
on “DELTA” 
on “ACCESS” 


<attribute_id>: Attribld(<identifier>), 
<attribute_id>: AttribDigits, 
<attribute_id>: AttribDelta, 

<attribute id>: AttribAccess 


transform literal 
on “NUMERIC” 
on “CHAR” 
on “NIL” 


<literal>: NumLit(<numeric_lit>), 
<literal>: UsedChar(<CHAR_LIT>), 
<literal>: NilLit 


transform aggregate 
on “COMP_ASSOC” 
on “VALUES” 
on “EXPR_VALUE” 
on “EXPR” 

on “EXPR NULL REC” 


<aggregate>; AggCompAssoc(<comp_assoc>), 
<aggregate>: AggValues2(<value_s_2>), 

<aggregate>: AggExprValue(<expression>, <value_s>), 
<aggregate>; AggExprWithNull(<expression>), 
<aggregate>: AggExpNulIRec 


transform expression 
on “RELATION” 
on “AND” 
on “OR” 
on “XOR” 
on “AND_THEN” 
on“OR ELSE” 


<expression>: Relation(<relation>), 

<expression>: And(<expression>, <relation>), 
<expression>: Or(<expression>, <relation>), 
<expression>: Xor(<expression>, <relation>), 
<expression>: AndTlien(<expression>, <relation>), 
<expression>: OrElse(<expression>, <relation>) 


transform relation 
on “SIMPLE” 
on “=” 

on “/=” 

on ”<“ 


<relation>: SimpleExpr(<simple_expression>), 
<relation>: Equal(<simple_expression>, 
<simple_expression>), 

<relation>: NotEqual(<simple_expression>, 
<simple_expression>), 

<relation>: LessThan(<simple_expression>, 


151 


on “<=” 
on “>” 
on “>=” 

on “RANGE_MBR” 
on “NAME_MBR” 


transform membership 
on “IN” 
on “NOTJN” 


transform simple_expression 
on “TERM” 
on “+” 

on 

on 


transform unary 
on + 


transform term 
on “FACTOR” 
on 
on 

on “MOD” 
on “REM” 


transform factor 
on “PRIMARY” 
on “NOT_PRIMARY” 
on ••ABS_PRIMARY” 
on “EXPON” 


transform primary 
on "LITERAL" 
on "NAME” 


<simple_expression>), 

<relation>; LessThanEq(<simple_expression>, 
<simple_expression>), 

<relation>; GreaterThan(<simple_expression>, 
<simple_expression>), 

<relation>: GreaterThanEq(<simple_expression>, 
<simple_expression>), 

<relation>: RangeMember(<simple_expression>, 
<membership>, <range>), 

<relation>; NameMember(<simple_expression>, 
<membership>, <name>) 


<membership>: In, 
<membership>: NotIn 


<simple_expression>; Term(<unary>, <term>), 
<simple_expression>: Addition(<simple_expression>, 
<term>), 

<simple_expression>: Subtraction(<simple_expression>, 
<tenn>), 

<simple_expression>: Concat(<simple_expression>, 
<term>) 


<unary>: Plus, 
<unary>: Minus 


<term>: Factor(<factor>), 

<term>: Mult(<term>, <factor>), 
<term>: Divide(<term>, <factor>), 
<term>: Mod(<term>, <factor>), 
<term>: Rem(<term>, <factor>) 


<factor>: Primary(<primary>), 

<factor>; NotPrimary(<primary>), 
<factor>: AbsPrimary(<primaiy>), 
<factor>: Expon(<primary>, <primary>) 


<primary>: Literal(<literal>), 
<primary>; PrimaryName(<name>), 


152 




on “ALLOCATOR” 
on “QUALIFIED” 
on “(EXPR)” 
on “AGGREGATE” 


<primaiy>: Allocator(<allocator>), 
<primaiy>: Qualified(<qualified>), 
<primaiy>: Parens(<expression>), 
<primaiy>; PrimaryAgg(<aggregate>) 


transform qualified 

on ‘“AGGREGATE” <qualified>: NameTicAgg(<name>, <aggregate>), 

on ‘“EXPR” <qualified>: NameTicExpr(<name>, <expression>) 


transform subprog_decl 

on “SUBPROG” <subprog_decl>: SubprogSpec(<generic_hdi>, 

<subprog_speo, <psdl_met_opt>), 
on “GENERIC_SUBPROG” <subprog_decl>: 

GenericSubprogInst(<subprog_spec>, 
<generic_inst>, <psdl_met_opt>), 
on “ABSTRACT_SUBPROG” <subprog_decl>: 

AbstractSubprogSpec(<subprog_spec>, 

<psdl_met_opt>) 


transform psdl_met_opt 
on “uSEC” 
on “mSEC” 
on“SEC” 
on “MIN” 
on “HRS” 


<psdl_met_opt>: MetUsec(<integer>), 
<psdl_met_opt>: MetMs(<mteger>), 
<psdl_met_opt>: MetSec(<integer>), 
<psdl_met_opt>: MetMin(<integer>), 
<psdl_met_opt>: MetHrs(<integer>) 


transform subprog_spec 

on “PROCEDURE” <subprog_spec>: SubProgProc(<compound_name>, 

<formal_part_opt>), 

on “FUNCTION” <subprog_speo: SubProgFuncRetum(<designator>, 

<formal_part_opt>, <name>), 

on “FUNCTION_DESIGNATOR” <subprog_spec>: SubProgFunc(<designator>) 


transform designator 

on “COMPOUND_NAME” <designator>: DesigCompound(<compound_name>), 

on “STRING” <designator>; DesigString(<QUOTED_STRING>) 


transform pkg_decl 

on ‘■PKG_SPEC” <pkg_decl>: PkgSpec(<generic_hdr>, <pkg_speO), 

on “GENERIC_PKG_INST” <pkg_decl>: GenPkgInst(<compound_name>, 

<genericinst>) 


transform use_clause 
on "USE” 


<use_clause>: Use(<name_s>), 


153 







on “USE_TYPE” 


transform rename_decl 
on “SUBTYPE” 


on “EXCEPTION^ 
on “UNIT” 


transform rename_unit 
on “PKG” 

on “SUBPROG” 


transform task_spec 
on “TASK” 
on“TASK TYPE” 


transform prot_spec 
on “PROTECTED” 
on “PROTECTED_TYPE” 


transform prot_op_decl 
on “ENTRY” 
on “SUBPROG” 
on “REP_SPEC” 
on “PRAGMA” 


transform prot_elem_decl 
on“OPDECL” 
on “ELEM_DECL” 


transform entry_decl 
on “ENTRY” 

on “RANGE_ENTRY” 


transform context_spec_opt 
on -■CONTEXT_SPEC” 


<use_clause>: UseType(<name_s>) 


<rename_decl>; RenameDeclSub(<def_id_s>, 
<object_qualifier_opt>, <subtype_ind>, 
<renames>), 

<rename_decl>: RenameExc(<def_id_s>, <renames>), 
<rename_decl>: RenameUnitDecl(<rename_unit>) 


<rename_iinit>: RenamePkg(<generic_hdi>, 
<compound_name>, <renames>), 
<rename_unit>: RenameSubprog(<generic_hdr>, 
<subprog_spec>, <renames>) 


<task_spec>: SimpleTask(<identifier>, <task_def>), 
<task_spec>; TaskType(<identifier>, <discrim_part_opt>, 
<task_def>) 


<prot_spec>: Prot(<identifier>, <prot_def>), 
<prot_spec>: ProtType(<identifier>, 

<discrim_part_opt>, <prot_def>) 


<prot_op_decI>: EntiyDecl(<entry_decl>), 
<prot_op_decl>: ProtOptSubprog(<subprog_spec>), 
<prot_op_decl>: RepSpec(<rep_spec>), 
<prot_op_decl>: ProtOptPragma(<pragma>) 


<prot_elem_decl>: ProtOptDecl(<prot_op_decl>), 
<prot_elem_decl>; ProtElemCompDecI(<comp_decl>) 


<entry_decl>: EntryDeclld(<identifier>, 
<formal_part_opt>), 

<entry_decl>: EntryRange(<identifier>, <discrete_range>, 
<fonnal_part_opt>) 


<context_spec_opt>; ContextSpec(<context_spec>) 


154 








transform context_spec 

on “CONTEXT_WITH_USE” <context_spec>: 

ContextWithUse(<context_spec_opt>, 

<with_clause>, <use_clause_opt>), 

on “PRAGMA” <context_spec>: ContextPragma(<context_spec>, 

<pragma>) 


transform body_stub 
on “TASK” 
on “PKG” 
on “SUBPROG” 
on “PROTECTED^ 


<body_stub>: TaskStub(<identifier>), 
<body_stub>: PkgStub(<compound_name>), 
<body_stub>: SubprogStub(<subprog_spec>), 
<body_stub>: ProtStub(<identifier>) 


transform generic_hdr 

on “GENERIC_FORMALS” <generic_hdr>: GenericHdr(<generic_formal_part>) 


transform generic_formal 
on “PARM” 
on “TYPE” 

on “PROCEDURE” 

on “FUNCTION” 


on “PKGo” 


on “PKG” 
on “USE” 


<generic_formal>; GenParm(<param>), 

<generic_formal>: GenTypePann(<identifier>, 

<generic_discrim_part_opt>, <generic_type_def>), 
<generic_formal>: GenProcParm(<identifier>, 
<fonnal_part_opt>, <subp_default>), 
<generic_formal>; GenFnncParm(<designator>, 

<formal_part_opt>, <name>, <subp_default>), 
<generic_formal>: GenPkgParmBox(<identifier>, 

<name>), 

<generic_formai>: GenPkgParm(<identifier>, <name>), 
<generic_fonnal>: GenUsepann(<use_clause>) 


transform generic_type_def 
on “o” 

on “RANGEo” 
on “MODo” 
on “DELTAo” 
on “DELTA_DIGITSo^ 
on “DIGITSo” 
on “ARRAY” 
on “ACCESS” 
on “PRIVATE” 
on “DERIVED” 


<generic_type_def>: GenTypeBox, 
<generic_type_def>: GenTypeRangeBox, 
<generic_type_def>: GenTypeModBox, 
<generic_type_def>: GenTypeDeltaBox, 

<generic_type_def>: GenTypeDeltaDigBox, 
<generic_type_def>: GenTypeDigitsBox, 
<generic_type_def>; GenTypeArray(<array_type>), 
<generic_type_def>: GenTypeAccess(<access_type>), 
<generic_type_def>: GenTypePriv(<private_type>), 
<generic_type_def>: 

GenTypeDerived(<generic_derived_type>) 


transform generic_derived_type 

on “SUBTYPE” <generic_derived_type>: GenDerivedSubt(<subtypeJnd>), 


155 










on “PRIVATE” 


<generic_derived_ty pe>: 

GenDerivedSubtPriv(<subtype_ind>), 
on “ABSTRACT” <generic_derived_type>: GenDerivedAbst(<subtype_ind>) 


transfoim rep_spec 
on “ATTRIBUTE 
on “RECORD” 

on “ADDRESS” 


transform object_qualifier_opt 

on “ALIASED” <object_qualifier_opt>: Aliased, 

on “CONSTANT” <object_qualifier_opt>: Constant, 

on “ALIASED CONSTANT” <object_qualifier_opt>: AliasedConst 


transform imt_opt 

on “ASSIGN” <init_opt>: ExprInitOpt(<expression>) 


transform discrim_part_opt 
on “DISCRIM” 
on “BOX” 


transform range_spec_opt 
on “RANGE” 


transform aliased_opt 

on “ALIASED” <aliased_opt>; AliasedOpt 

5 

transform range_constr_opt 

on “RANGE_CONSTRAINT” <range_constr_opt>: 

RangeConstr(<range_constraint>) 

5 

transform tagged_opt 

on “TAGGED” <tagged_opt>: Tagged, 

on “ABSTRACT_TAGGED” <tagged_opt>; AbstractTagged 


transform access_opt 

on “ACCESS” <access_opt>: AccessOpt 


<discrim_part_opt>: DiscrimPart(<discrim_spec_s>), 
<discrim_part_opt>: Box 


<range_spec_opt>: RangeSpecOpt(<range_spec>) 


<rep_speO: AttribDef(<mark>, <expression>), 
<rep_spec>; RecordTypeSpec(<mark>, <align_opt>, 
<comp_loc_s>), 

<rep_spec>: AddressSpec(<mark>, <expression>) 


transform prot_opt 
on “PROTECTED” 


<prot_opt>; Protected 






transform formal_part_opt 

on “FORMALS” <formal_part_opt>; FormalPart(<param_s>) 

transform mode 
on “IN” 
on “OUT” 
on ‘TN_OUT” 
on “ACCESS” 


transform private_part 

on “PRIVATE” <private_part>: Private(<decl_item_s>) 

> 

transform Iimited_opt 

on “LIMITED” <limited_opt>: Limited 


transform task_def 
on “TASK” 


transform taskjprivate_opt 

on “PRIVATE” <task_private_opt>: TaskPvtOpt(<entry_decI_s>, 

<rep_spec_s>) 

j 

transform prot_private_opt 

on “PRIVATE” <prot_private_opt>: ProtPvtOpt(<prot_elem_decI_s>) 


transform private_opt 

on “PRIVATE” <private_opt>: PrivateOpt 


transform generic_discrim_part_opt 

on “DISCRIMINANT” <generic_discrim_part_opt>: GenDisc(<discrim_spec_s>), 

on “BOX” <generic_discrim_part_opt>: GenBox 


transform subp_default 
on “NAME” 
on “BOX” 


transform align_opt 

on “ALIGN” <align_opt>: AIignOpt(<expression>) 


<subp_default>; SubpDefName{<name>), 
<subp_default>: SubpDetBox 


<task_def>: TaskDef(<entry_decl_s>, <rep_spec_s>, 
<task_private_opt>) 


<mode>; InMode, 
<mode>: OutMode, 
<mode>: InOutMode, 
<mode>: AccessMode 


157 









transform rep_spec_s 

on “REPRESENTATION 


transform comp_loc_s 
on “COMP_LOCS” 


transform type completion 
on “TYPES” 


SPECS”<rep_spec_s>:RepSpecList(<rep_spec_s>, 

<rep_spec>, <pragma_s>) 


<compJoc_s>: CompLocLjst(<comp_loc_s>, <mark>, 
<expression>, <range>) 


<type_completion>: TypeDefCompl(<type_def>) 


158 



APPENDIX F. INSTALLATION AND USE 


In order to use the translator, all of the SSL source files contained in Appendices A 
through E must be installed. An executable is created utilizing the makefile shown in Figure 
26. The Synthesizer Generator version 4.1 is required in order to create the executable. This 


PROJECT = abstract.ada9x.ssl\ 
abstract.psdl.ssl\ 
attrib.ada9x.ssl\ 
unparse.ada9x.ssl \ 
concrete.ada9x.ssl \ 
transforms.ada9x.ssl \ 
unparse. AdaToPsdl.ssl \ 
unparse.psdl.ssl 

pkgtrans: $(PROJECT) 

sgen -ssLinterpreter -o pkgtrans $(PROJECT) 

cstrip: cstrip.o 

CC -0 cstrip cstrip.c 

Figure 26. Translator Makefile 

executable is created to run in either an interactive mode or a batch mode by including the 
-ssl_interpreter switch. In either case, the translator may only be executed from within the 
X Windows System environment. Execution in interactive mode is initiated by the 
command: 

pkgtrans 

In order to execute using the batch mode, the command is: 
pkgtrans -b -1 scrip0le 


159 










where scriptfile is a file containing SSL commands which are to be executed by the 
translator. A script file is shown in Figure 27. This script file reads in an Ada package 


C)pen(“temp.strip”, “compilation”, “No”)! 
Save_as(“Text”,”temp.annotated.ada”, “B ASEVIEW”)! 
Change_view(“PSDL_VIEW”, false)! 

Save_as(“Text”, “temp.psdl”, “PSDL_VIEW”)! 

Exit(); 


Figure 27. Batch Mode Script File 


specification required to be in a file named temp, strip, this file is a preprocessed package 
specification which has had all comments removed from it by a comment stripping 
processor (source code follows text). The output of the batch mode is two files, the first is 
a file named temp.annotated.ada which is temp.strip with error comments from the 
translation inserted. The second file produced is called temp.psdl and contains the PSDL 
translation of temp.strip. The file names temp.* are hard coded due to restrictions on 
command line parameters for the translator in the batch mode. In order to provide more 
flexibility, a shell file is used, which allows for the use of command line parameters and 
provides automatic comment stripping. This shell file is shown in Figure 28. This shell 

cstrip $1 temp.strip 
pkgtrans -b -1 transcript 
mv temp.psdl $2 

Figure 28. Translator Shell Execution File 

allows user specified input Ada files and output PSDL files and assuming the file is named 
AdaToPsdl, may be executed as follows: 

AdaToPsdl PkgSpec.a PkgSpec.psdl 

This will translate the file PkgSpec.a to a PSDL file named PkgSpec.psdl, and will also 
produce the file temp.annotated.ada. The source code for a comment stripping program 
follows: 


160 








#include <stdio.h> 

#include <stdlib.h> 

#include <ctype.h> 

FILE *infile, *outfile; 
int inQuote = 0; 
char ch; 

char chline[256]; 
int currCh = 0; 
int backup = 1; 

void flusheolO { 
char chi; 

currCh -= backup; 
chline[currCh] = 0; 
if (currCh) 

fprintf(outfile,”%s\n”,chline); 
do { 

chi = fgetc(infile); 

} whUe ((chi != EOF) && (chi != ‘\n’)); 
currCh = 0; 
backup = 1; 

} 

char GetChO { 
char ch; 
do { 

ch = fgetc(infile); 

} while ((ch == ‘\r’) && (ch != EOF) && linQuote); 
chline[currCh++] = ch; 
return ch; 

} 

int main(int argc, char **argv) { 
if (argc < 3) { 

printf(“USAGE: cstrip infile outfileNn”); 
exit(O); 

} 

infile = fopen(argv[l],”r”); 
if (! infile) { 

printf(“Could not open %s for reading\n”,argv[l]); 
exit(O); 

} 


161 








outfile = fopen(argv[2],”w”); 
if (loutfile) { 

printf(“Could not open %s for writing\n”,argv[2]); 
exit(O); 

} 

while ((ch = GetCh()) != EOF) { 
if (ch == ‘V”) inQuote = linQuote; 
if (! inQuote) { 
if(ch == ‘-’) { 
backup++; 
ch = GetChO; 
if ((ch ==*-’)){ 
backup++; 
ch = GetChO; 
if((ch==‘P’)){ 
backup++; 
ch = GetChO; 
if((ch==‘S’)){ 
backup++; 
ch = GetChO; 
if((ch==‘D’)){ 
backup++; 
ch = GetChO; 
if((ch==‘L’)) 
continue; 

} 

} 

} 

flusheolO; 

continue; 

} 

else if (ch == “V”) inQuote = ! inQuote; 

} 

} 

backup = 1; 
if(ch ==‘\n’) { 
if (currCh != 1) { 
currCh[chline] = 0; 
fprintf(outfile,”%s”,chline); 

} 

currCh = 0; 

} 

} 


162 



if (currCh) { 
currCh[chlme] = 0; 
fprintf(outfile,”%s\n”,chline); 

} 

fclose(infile); 
fclose(outfile); 
return 0; 

} 

This program strips out all Ada comments with the exception of those which begin as: 
-PSDL 

comments of this sort are used by the translator to recognize PSDL constructs annotated 
within Ada programs. 


163 






164 




APPENDIX G. ADDING PROCEDURE WRAPPERS FOR ADA FUNCTIONS 


The current implementation of CAPS expects all PSDL operators to be 
implemented as Ada procedures. Unfortunately, most software components are written 
using a mix of functions and procedures. In order to perform a complete translation of an 
Ada software component to PSDL, it is necessary to add procedure interfaces for any 
functions which are specified in the Ada package. In order to accomplish this, 
preprocessing must be performed on both the Ada package specification, and the Ada 
package body to insert the required procedure wrappers. Figure 29 shows a sample Ada 


package TestPkg is 
generic 

type X is private; 
function funcl(y : x) return float; 

function func2(z : character) return integer; 
end TestPkg; 

package body TestPkg is 

function funcl(y : x) return float is 
begin 

return 1.0; 
end fund; 

function func2(z : character) return integer is 
begin 

return character’pos(z); 
end func2; 

end TestPkg; 

Figure 29. Ada package with functions only 


package containing both a generic function and a non-generic function. 


165 



The same package following preprocessing is shown in Figure 30. Procedure 
package TestPkg is 
generic 

type X is private; 
function funcl(y : x) return float; 

generic 

type X is private; 

procedure procedure_funcl(y: x; ProcRetum : out float); 

function func2(z : character) return integer; 

procedure procedure_func2(z : character; ProcRetum : out integer); 
end TestPkg; 

package body TestPkg is 

function funcl(y : x) return float is 
begin 

return 1.0; 
end fund; 

procedure procedure_funcl(y : x; ProcRetum : out float) is 
function func_inst is new fund (x); 
begin 

ProcRetum := func_inst(y); 
end procedure_funcl; 

function func2(z : character) return integer is 
begin 

return character'pos(z); 
end func2; 

procedure procedure_func2(z : character; ProcRetum : out integer) is 
begin 

ProcRetum := func2(z); 
end procedure_func2; 
end TestPkg; 

Figure 30. Ada package with procedure wrappers for functions 


166 




interfaces have been added to provide access to all declared functions. Note that for generic 
functions, a generic procedure must be created with identical generic formal parameters 
which will be used to instantiate a version of the generic function within the procedure 
body. 


167 







168 



INITIAL DISTRIBUTION LIST 


1. Defense Technical Information Center.2 

Cameron Station 

Alexandria, Virginia 22304-6145 

2. Library, Code 52.2 

Naval Postgraduate School 

Monterey, California 93943-5101 

3. Chairman, Code CS.1 

Computer Science Department 

Naval Postgraduate School 
Monterey, California 93943-5000 

4. Dr. Man-tak Shing, Code CS/Sh.2 

Computer Science Department 

Naval Postgraduate School 
Monterey, California 93943-5000 

5. Dr. Luqi, Code CS/Lq.20 

Computer Science Department 

Naval Postgraduate School 
Monterey, California 93943-5000 

6. LT Christopher Eagle.2 

936 Darby Road 

Virginia Beach, VA 23464 

7. Chief of Naval Research.1 

800 N. Quincy Street 

Arlington, VA 22217 

8. Ada Joint Program Office.1 

Defense Research & Engineering 

Pentagon, 3E118 
Attn: John P. Solomond 
Washington, D.C. 20301 


169 















9. Carnegie Mellon University.1 

Software Engineering Institute 

Department of Computer Science 
Attn: Mario R. Barbacci 
Pittsburgh, PA 15213-3890 

10. Office of Naval Technology.1 

800 N. Quincy Street 

Code 227 ONT 
Attn: Elizabeth Wald 
Arlington, VA 22132-5000 

11. Advanced Research Projects Agency (ARPA).1 

Integrated Strategic Technology Office (ISTO) 

Attn: Kirsti Bellman 
1400 Wilson Boulevard 
Arlington, VA 22209-2308 

12. ARPA/ISTO.1 

3701 N. Fairfax Drive 

Attn: Edward Thompson 
Arlington, VA 22203-1714 


13. Attn: Mr. William McCoy.1 

Code K54, NSWC 

Dahlgren, VA 22448 

14. Advanced Research Projects Agency (ARPA).1 

Director, Naval Technology Office 

1400 Wilson Boulevard 
Arlington, VA 22209-2308 


15. Advanced Research Projects Agency (ARPA).1 

Director, Prototype Projects Office 

1400 Wilson Boulevard 
Arlington, VA 22209-2308 

16. Advanced Research Projects Agency (ARPA).1 

Director, Tactical Technology Office 

1400 Wilson Boulevard 
Arlington, VA 22209-2308 


170 











17. Dr. Aimram Yehudai.1 

Tel Aviv University 

School of Mathematical Sciences 
Department of Computer Science 
Tel Aviv, Israel 69978 

18. Dr. Robert M. Balzer.1 

USC-Information Sciences Institute 

4676 Admiralty Way 
Suite 1001 

Marina del Ray, CA 90292-6695 

19. Dr. Raymond Yeh.1 

International Software Systems, Inc. 

9430 Research Blvd, Bldg 4, Suite 250 
Austin, TX 78759 

20. Kestrel Institute.1 

Attn: Dr. C. Green 

1801 Page Mill Road 
Palo Alto, CA 94304 

21. Prof. D. Berry.1 

Computer Science Department 

Technion 
Haifa 32000 
Israel 

22. Massachusetts Institute of Technology.1 

Department of Electrical Engineering and Computer Science 

Attn: Dr. B. Liskov 
545 Tech Square 
Cambridge, MA 02139 

23. Massachusetts Institute of Technology.1 

Department of Electtical Engineering and Computer Science 

Attn: Dr. J. Guttag 
545 Tech Square 
Cambridge, MA 02139 


171 










1 


24. Dr. Michael Gray.. 

CSIS Department 
American University 
4400 Massachusetts Ave. NW 
Washington, D.C. 20016-8116 

25. National Science Foundation.1 

Division of Computer and Computation Research 

1800 G Street NW 
Attn: Dr. Bruce Barnes 
Washington, D.C. 20550 

26. Mr. Hans Mumm.1 

NCCOSC RDTE DIV 4121 

53560 Hull Street 

San Diego, CA 92152-5001 


27. NAVSEA, PMS-4123H.1 

Attn: William Wilder 

Arlington, VA 22202-5101 

28. New Jersey Institute of Technology.1 

Computer Science Department 

Attn: Dr. Peter Ng 
Newark, NJ 07102 


29. Office of Naval Research.1 

Computer Science Division, Code 1133 

Attn: Dr. Van Tilborg 
800 N. Quincy Street 
Arlington, VA 22217-5000 

30. Office of Naval Research.1 

Computer Science Division, Code 1133 

Attn: Dr. R. Wachter 
800 N. Quincy Street 
Arlington, VA 22217-5000 

31. Southern Methodist University.1 

Computer Science Department 

Attn: Dr. Murat Tanik 
Dallas, TX 75275 


172 











32. Ohio State University.1 

Department of Computer and Information Science 

Attn: Dr. Ming Liu 
2036 Neil Ave MaU 
Columbus, OH 43210-1277 

33. University of California at Berkeley.1 

Department of Electrical Engineering & Computer Science 

Computer Science Division 
Attn: Dr. C.V. Ramamoorthy 
Berkeley, CA 90024 


34. University of Maryland.1 

College of Business Management 

Tydings Hall, Room 0137 
Attn: Dr. Alan Hevner 
College Park, MD 20742 

35. University of Pittsburgh.1 

Department of Computer Science 

Attn: Dr. Alfs Berztiss 
Pittsburgh, PA 15620 

36. Research Administration.1 

Code 012 

Naval Postgraduate School 
Monterey, CA 93943 

37. Attn: Dr. David Hislop.1 

Laboratory Command 

Army Research Office 
P.O. Box 12211 

Research Triangle Park, NC 27709-2211 

38. Monmouth College.1 

Computer Science Department 

Software Engineering Program 

Attn: Jerry Powell 

West Long Branch, NJ 07764 


173 















1 


39. Dr. Joseph Goguen 
Oxford University 
Computing Lab 
llKeble Road 
Oxford 0X1 3QD 
England 


174 




