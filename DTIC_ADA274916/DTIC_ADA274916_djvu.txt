NAVAL POSTGRADUATE SCHOOL 
Monterey, California 

AD--A274 916 

■lillili 

S DTIC 

ELECTE 
JAN 2 6 1994 ,, 

A i 

il THESIS 


An Automated 
Ada Physical Source 
Line Counter 

by 

Kevin J. Walsh 
Septemba 1993 

Thesis Advisor Timothy J. Shimeall 

Approved for public release; distribution is unlimited. 



94-02269 


94 1 25 08 8 








Best 

Available 

Copy 





1 REPORT DOCUMENTATION PAGE 

form Approved I 

Om No. 0704-0188 I 

nMienportingbufdantwMtoallMlionolMonraliMiiaMiniitadtoavarat* 1 hour pwiwponu, ineluding ttwtmraviMiirig insliuoliont. wmohing witting date souicm 
gadtetitg and mainteiningitte date naadsd, and oentpteting and teviaiKingdiaeolaclienelinlotinalion. Sand ocininante regarding tti» burden aatiinate PC any olhataifiaci el itiB 
QeHeeliennlintonnalion.includwigauggaationalof reducing mil burden teWaahinglon Haadquarteta Sarvieaa, PireclDrate lor Wontialion Oparaliona and Reporla, l2l5Jeaaraon 

Oania Higiniray, Suto t204, rMngton, VA 22202-4302, and to Ilia OMoa el ManagamanI and Budgal. Papararork Radurdion Proiael (0700-0188), Waahinglon. OC 20S03 

11. AGENCY USE ONLY (Lmv« Blank) K. REPORT DATE I 

1 I ScDtcmber 1993 1 

3. REPORT TYPE AND DATES COVERED 

Master’s Thesis 1 

4. TITLE AND SUBTITLE 

An Automated Ada Physical Source Line Counter (U) 

S. FUNDING NUMBERS 

6. AUTHORIS) 

Walsh, Kevin John 

7. PERFORMING ORGANIZATION NAMEIS) AND AOORESS<ES) 

Naval Postgraduate School 

Monterey, CA 93943-5000 

a. PERFORMING ORGANIZATION 

REPORT NUMBER 

9. SPONSORING/ MONITORING AGENCY NAME(S) AND ADORESS<ES) 

10. SPONSORING/ MONITORING 

AGENCY REPORT NUMBER 

11. SUPPLEMENTARY NOTES 

The views expressed in this thesis are those of the author and do not reflect the official policy or position 
of the Department of Defense or the United States Government. 

12a. DISTRIBUTION / AVAIUBIUTY STATEMENT 

UnclassifiedAJnlimited 

12b. DISTRIBUTION CODE 

13. ABSTRACT (Maximum 200 words) 

Tools to count lines of code have not been standardized or automated in a flexible fashion. This lack of 
flexibility can lead to ambiguous interpretations of the size of software modules, especially when the 
person performing the measurement does not use the method or rules expected by ffie person requesting 
the measurement. The Software Engineering Institute (SEl) Framework for Size Measurement provides a 
basis for flexible design of software measurements. The SEI framework describes measurements using 
nine attributes. This Framework is part of recently proposed DoD guidelines for software process 
measurement. The problem that this thesis addresses is how to implement the SEI Framework for Size 
Measurement to flexibility count lines of the code in Ada software. The approach is to build an automated 
Ada Physical Source Line Counter that measures Ada source files and generates the appropriate reports. 
The tool works as follows; the user defines the measurement constraints to the tool, which calls an Ada 
parser to generate counts to be included in user-specified reports. The result is a program that takes user 
requests and Ada source files and produces measurement reports as output. This program fully captures 
the flexibility of the SEI framework along five of the nine measurement attributes. 

14. SUBJECT TERMS 

Software Metrics, Source Lines of Code, Ada 

15. NUMBER OF PAGES 

286 

17. SECURITY CLASSIFICATION 18. SECURITY CLASSIFICATION 

OF REPORT OF THIS PAGE 

Unclassified Unclassified 

19. SECURITY CLASSIFICATION 

OF ABSTRACT 

Unclassified 

20. LIMITATION OF ABSTRACT 

UL 


NSN 7540-01-280-5500 


Standard Form 298 (Rev. 2-89) 
Prescribed by ANSI Std. 239-18 

























Approved for public release; distribution is unlimited 


Author: 


Approved By: 


An Automated Ada 
Physical Source 
Line Counter 


by 

Kevin J. Walsh 
Major, United States Army 
BS.C.S., Youngstown State University, 1979 


Submitted in partial fulfillment of the 
requirements for the degree of 


MASTER OF COMPUTER SCIENCE 


from the 

NAVAL POSTGRADUATE SCHOOL 
September 1993 



(7^/a/9 /I 

NfAJ David A. Gaitros, Second Reader 

Dr. Ted Lewis, Chairman, 
Department of Computer Science 


ii 






ABSTRACT 


Tools to count lines of code have not been standardized or automated in a flexible 
fashion. This lack of flexibility can lead to ambiguous interpretations of the size of software 
modules, especially when the person performing the measurement does not use the method 
or rules expected by the person requesting the measurement The Software Engineering 
Institute (SEI) Framework for Size Measurement provides a basis for flexible design of 
software measurements. The SEI framework describes measurements using nine attributes. 
This Framework is part of recently proposed DoD guidelines for software process 
measurement. 

Hie problem that this thesis addresses is how to implement the SEI Framework for 
Size Measurement to flexibility count lines of the code in Ada software. 

The approach is to build an automated Ada Physical Source Line Counter that 
measures Ada source fries and generates the appropriate reports. The tool works as follows: 
the user defines the measurement constraints to the tool, which calls an Ada parser to 
generate counts to be included in user-specified reports. 

The result is a program that takes user requests and Ada source fries and produces 
measurement reports as output. This program fully captures the flexibility of the SEI 
framework along five of the nine measurement attributes. 


DTIO UISPSCTED 6 


Accesion For | 

NTIS 

CRA&l 

s— 

DTIC 

TAB 


Unannounced 

1 1 

Ju3tifica*ior, 


By _ 



Disti ib;.t4on / 

. 

f 

vailabi:;! 



Avcti) 

1: ■ )! 

Dist 

Spr- 

oiut 





iii 











TABLE OF CONTENTS 


I. INTRODUCTION.1 

A. BACKGROUND.1 

1. Size.2 

2. Personncl/Effort. 2 

3. Computer Use.2 

4. Schedule Progress.3 

5. Requirement and Design Progress.3 

6. Testing Progress/Quality.3 

7. Incremental Release Content.3 

8. Complexity.4 

B. USERS OF SOFTWARE METRICS.4 

C WHY COUNTERS AT ALL?.6 

1. Automated versus Manual Counters.6 

2. Counting versus Reporting versus Tracking.6 

D. PROBLEM DESCRIPTION.8 

E. OVERVIEW OF THESIS.8 

n. SEI FRAMEWORK.9 

A. DEFINITION OF FRAMEWORK.9 

1. Attributes.10 

2. Values.10 

3. Reports. 11 

B. APPLICATIONS OF FRAMEWORK.11 

1. Software Size Measurement:.11 

2. Software Effort and Schedule Measurement:.12 

3. Software Quality Measurement:.12 

C AUTOMATION OF SIZE MEASURE.12 


IV 
































D. PREVIOUS SIZE CALCULATORS 


13 

1. DOS Version of the SEI Framework on Size.13 

2. PC-Metric for Pascal.13 

E. SUMMARY.14 

m. TOOL DESIGN.15 

A. ATTRIBUTES SUPPORTED.15 

1. Statement Type.15 

2. How Produced.16 

3. Origin.16 

4. Usage.16 

5. Delivery.17 

6. Development Status.17 

7. Qarifications (General and Ada Specific).17 

B. ATTRIBUTES NOT SUPPORTED.18 

1. Functionality.18 

2. Replications.18 

C DEFAULT REPORTS/OUTPUT.18 

1. Report A.19 

2. Report B.19 

3. Report C.19 

4. Report D.20 

5. Report E.20 

D. USER-DEFINED REPORTS/OUTPUT.21 

E. DATA STRUCTURES.22 

1. Variables used for every report.22 

2. Size Attributes.23 

3. Five Dimensional Arrays.24 

4. Priority Arrays.24 



































5. Rags Array.25 

6. Current Settings Record.25 

7. Checklist Variables.25 

R OVERVIEW.26 

G. USER INTERFACE.27 

H. PARSER.32 

I. REPORT GENERATOR.34 

J. SUMMARY.34 

IV. TOOL USAGE.36 

A. INTRODUCTION.36 

B. REQUIREMENTS.36 

1. Hardware.36 

2. Software.36 

3. Input.36 

4. Legal Ada Syntax.36 

C LIMITATIONS.37 

1. Package Conflicts.37 

2. Coding Style.37 

D. COMMAND LINE INVOCATION.38 

E. EXTENDED EXAMPLE.38 

1. Sample Application.38 

2. User Interface.39 

3. Statement Processing.42 

a. Executable Statements.42 

b. Declaration Statements.44 

c. Comments on Own Line.45 

d. Banner Comments.46 

e. Blank Lines.46 


vi 



































f. OUTPUT.47 

F. SUMMARY.53 

V. SUMMARY AND CONCLUSIONS.55 

A. RESEARCH SUMMARY.55 

B. RECOMMENDATIONS.56 

APPENDIX A USER MANUAL.58 

A. REQUIREMENTS.58 

1. Hardware.58 

2. Software.58 

3. Input.58 

4. Legal Ada Syntax.60 

B. LIMITATIONS.61 

1. Package Conflicts.61 

2, Coding Style.61 

C COMMAND LINE INVOCATION.62 

D. USER INTERFACE.62 

1. Push-buttons.63 

2. Checkboxs.64 

3. Radio-buttons.64 

4. Labels and Text/Integer Keyin items.64 

E. INTRODUCTORY PANEL.65 

F. INPUT PANEL.65 

G. ATTRIBUTE PANELS.66 

H. CLARfflCATIONS (GENERAL and Ada) PANELS.72 

I. GENERATE REPORT PANEL.72 

J. QUIT PANEL.72 

APPENDIX B. SOURCE CODE.77 

APPENDIX C EXTEND SAMPLE INPUT AND OUTPUT.244 


vii 




































UST OF REFERENCES 
INITIAL DISTRIBUTION LIST 





LIST OF FIGURES 


Figure 1 SEI Attributes supported and not supported.15 

Figure 2 Written Description for Report A .19 

Figure 3 Written description for report B .20 

Figure 4 Written description for report C .20 

Figures Written description for report D .21 

Figure 6 Written description for report E.21 

Figure 7 Relationship of input fUe name and Ada source files to be measured.23 

Figure 8 Attribute Statement Type values declared as an enumerated type .23 

Figure 9 Declaration of five dimensional array.24 

Figure 10 Declaration of Priority type array to track precedence levels.24 

Figure 11 Declaration of FLAGS_TYPE_ARRAY.25 

Figure 12 Example of FLAGS_TYPE_ARRAY values set to true.25 

Figure 13 Overview of the Automated Ada Physical Source Line Counter.26 

Figure 14 Overview of User interface.31 

Figure 15 Example of Ada code executed inside of Ayacc.32 

Figure 16 Example of rule to find blank lines.32 

Figure 17 Example of rules added to Aflex.33 

Figure 18 Example of code to recognize Special comments.34 

Figure 19 Example of Ada.y input file to Ayacc.37 

Figure 20 Example of two different coding styles.38 

Figure 21 Contents of EXAMPLE_FILE .39 

Figure 22 Example of text keyin fields .40 

Figure 23 Example of marked checkboxs for selecting reports A - F.40 

Figure 24 Example of customizing report F .41 

Figure 25 Variables used during parsing of source files.42 

Figure 26 Sample input code.44 

Figure 27 Partial output of Report A.48 

Figure 28 Partial output of Report B.49 

Figure 29 Partial output of Report C.50 

Figure 30 Partial output of Report D.51 

Figure 31 Partial output of Report E .52 

Figure 32 Partial output of Report F .54 

Figure A-1 Special Comments.59 

Figure A-2 Example of Ada.y input file to Ayacc.61 

Figure A-3 Example of two different coding styles.62 

Figure A-4 Example of Push-buttons.63 

Figure A-5 Available Report Names .64 

Figure A-6 Text Keyin fields and labels.65 

Figure A-7 Statement Type Panel.67 

Figure A-8 How Produced Panel.68 

Figure A-9 Origin Panel.69 

ix 
















































Figure A-10 Usage and Delivery Options Panel .70 

Figure A-11 Development Status Panel.71 

Figure A-12 Qarifications (general) Panel.73 

Figure A-13 Clarifications (Ada) Panel.74 

Figure A-14 Generate Report Panel.75 

Figure A-15 (Juit Panel.76 


X 










ACKNOWLEDGEMENTS 


This project is not the work of one individual alone. There is a large number of people 
who contributed to this work both directly and indirectly. Although it would be impossible 
to acknowledge all of them, I would like to take this opportunity to thank the major player, 
Dr. Timothy J. Shimeall, who provided endless support and encouragement during this 
work. His guidance was invaluable. Additionally, I would like to thank MAJ Gaitros for his 
conpibution in making this thesis more understandable. Thanks are 'Uso due to Mr. Bob 
Park and others at SEI for their previous work providing the basis for this thesis. 

Bob Ordonio helped me see the light in numerous programming dark holes. 

Finally, I would like to thank my wife, Susan, my son Sean and my daughter Sara, for 
their loving support and understanding during the many nights spent at the terminals in the 
Computer Science Lab. 

Without the help and moral support of the above people and countless others, this work 
would not have been possible. 


XI 






I. INTRODUCTION 


A. BACKGROUND 

From 1980 to 1985, software-related costs rose from 3 percent ($40 billion) of the U.S. 
gross national product to S percent ($228 billion). Software effects are increasing, due in 
part to: the decreasing cost of hardware, which has been cut in half every two years; the 
increasing speed and capacity of computers to new applications as computers do tasks that 
are either too complicated or too time-consuming to do manually. However, the systems 
that rely on software will only use software that is reliable, easy to use, and accomplishes 
the needs of the people using the systems. The software developer is tasked to ensure that 
software is delivered on time, under budget and meeting or exceeding the performance 
requirements. [BER 90] 

Software is not just the code, but the entire set of documentation, operating 
procedures, test cases, and programs associated with a computer-based system. The goal of 
software engineering is to provide effective methods for producing software systems that 
meet the needs of the customer, while conforming to the customer’s schedule and budget 
constraints. [BER 90] 

Part of this process is to provide accurately-generated attributes to estimate cost and 
effort, then track the ensuing process against the estimate. The field of computer science 
does not currently quantify accurately its attributes. [BEI90] 

Beizer categorizes computer metrics into three groups, which are: Linguistic, 
Structural, and Hybrid. Linguistic metrics are measurements without regard to 
interpretation. For example, most counts of things are linguistic. The measurement of the 
number of unique operands or number of unique operators is linguistic. The order of either 
operands or operators is of little concern. The total number of operators or operands is the 
target, not where in the code or how they interact with each other or other parts of the code. 
[BEI 90] 






Structural metrics are based upon the structural relations between objects within the 
program. Structural metrics measure the properties of the control flowgraphs of data 
flowgraphs. An example would be to count the number of links, number of nodes, and 
nesting depths. To accomplish this type of metric, the program would need to be 
interpreted. Hybrid metrics are some combination of linguistic and structural. [BEl 90] 

There are many different measurements currently in use. Some measure the size of a 
project from the number of lines it contains, others base the size on the number of operators. 
There are measures for productivity, schedule, effort, quality, requirements designed, 
detailed designs, and use of availability of computer resources. Some commonly used 
metrics include, but are not limited to Size, Personnel, Computer use. Unit Progress, 
Schedule Progress, Design Complexity, Requirement and design Progress, Testing 
Progress, and Incremental release content. The next sections will briefly discuss some 
metrics available and the benefits of using them. 

1. Size 

The size measurement may reflect either the planned size or current or estimated 
size. One possible unit of measure is lines of code to be developed, modified, planned, and 
reused. This metric can help plan the total effort and schedule and measure productivity. 
For an example, an increase in the size of the software code, shows the project will require 
more resources of time, money and personnel. 

2. Personnel/Effort 

The personnel/effort measurement includes the estimated and current number of 
personnel working on the project. One possible unit of measure is time card hours. This 
metric measures productivity, and how staffing is effecting the planned schedule and cost. 

3. Computer Use 

The computer use measurement includes the estimated and actual percentage of 
the target system’s hardware CPU, storage, and communication capacity. A possible unit 


2 





of measure is the CPU speed. This metric shows if the planned target system is capable of 
the current requirements and if any spare capacity exists for increases later. 

4. Schedule Progress 

Schedule progress measurement includes the estimated progress, measured as the 
ratio of the planned to the actual work done on the schedule. This metric can measure 
productivity and progress. For example, this measurement can show if the software 
development is meeting the scheduled requirements as laid out in the contract. This metric 
uses the standard cost-reporting data on software work packages completed under MIL- 
STD 2167 A. 

5. Requirement and Design Progress 

Hie meLlo for requirement and design progress can track requirement 
documentation process. The measurement would detail the number of requirements, 
number of requirements documented, and the number of requirements scheduled to be 
documented. This metric is used in the specification and detailed design phases. This metric 
is another measure of progress and productivity. 

6. Testing Progress/Quality 

The measurement of progress and quality includes the planned and actual 
configuration items and completed system tests; number of new problem reports and 
opened or unresolved problem reports. These metrics can measure the progress in 
completing testing, the number of potential bugs found, and the speed of fixing them. These 
metrics can also estimate software quality, and the time needed to complete the tests. 

7. Incremental Release Content 

This metric, compares the estimated and actual release date with the estimated 
and actual components in each release. The metric measures the progress of a software 
project in relation of the estimated module releases, with the actual module releases. For 
example, if the number of actual modules increases for a planned release, is this as a result 


3 







of changing requirenjents or coding is ahead of schedule? Conversely, if the number of 
actual modules decreases for a planned release, is this a result of pressure to meet the 
published schedule dates, and coding is behind schedule? 

8. Complexity 

The most common design complexity metric is Cyclomatic complexity [NAS 90]. 
This metric indicates which parts of the software system that may be error prone or hard to 
maintain. For example, a software developer may use cyclomatic complexity on a piece of 
software such that, once a software module exceeds a level the module is reworked to bring 
the complexity level down if there is sufficient time and budget for the rework. Cyclomatic 
complexity may also provide a relative indication of where testing will be difficult, which 
aids in planning test efforts. 

B. USERS OF SOFTWARE METRICS 

Program managers and software developers are the main users of software metrics. 
Users can benefit from the use of software measurement throughout a software project. 

Program managers use software metrics to help them estimate project costs, schedules 
and performance. A good estimate is the cornerstone of a successful project. To have a 
successful program, the manager needs to know how much money to spend, (cost), how 
much time to finish the program (schedule), and what the final specifications are 
(performance). When dealing with software projects, the manager needs to know how long 
it is going to take to develop the final product and at what cost. To do this effectively, a 
good, accurate, estimate early in the program’s life cycle is needed. The estimate of the 
project size will affect the cost, schedule, and performance qualities of the project. For 
instance, if the project is estimated to have the functionality of A, B, and C; the project must 
be completed in one year, the project is estimated to have lOOK lines of code; with five 
programmers; and no more than $5()0K. Management needs to ensure that resources are 
employed to complete the project on time or to make a decision to trade-off one resource 
for another. Management will also need to know during the life of the project the status of 


4 







the constraints placed on this project - is it falling behind or ahead of schedule, exceeding 
or within its budget 

Software metrics can help decide where the software project is in relation to the project 
completion and alert project managers, maintainers, testers of future problems, delays, and 
increased costs. During a large multi-year software development there are usually only a 
few major milestones that must be met by the software developer. The major milestones do 
not allow for adequate management visibility of the entire process for a day to day or week 
to week development tracking. A lot happens between these milestones, and a more 
detailed picture is needed on a more frequent basis. In order for management to track the 
progress of a project, they will need to know a frequent basis, day-to-day, week-to-weck, 
or month-to-month how the project is progressing along the planned route. Any deviations 
from this planned route will cost the development some precious resources down the line, 
either time or money or schedule. The sooner management can make an informed decision, 
the better. A good set of software metrics provides this information. However, clear 
guidance must be given on what data to collect and made available to users. 

The use of metrics is still in the development stages with no existing standards to what 
to count or report Reports within an organization may fluctuate from project to project 
depending on the importance placed on metrics. This lack of standardization interferes with 
comparing of lessons learned from one project to another project 

Software projects, like any other projects contain a certain amount of risk. The use of 
inaccurate or paradoxical metrics increases diat risk. The factors that contribute to this 
include lack of: standardization for languages; rules to compare across languages, such as 
Ada and C; accurate size estimations during the requirements phase, when this information 
is needed. 

Software metrics are not a panacea, but merely a tool that can deliver response to 
management and the technical staff on various aspects of a software project For example, 
when using a complexity metric, once a module has exceeded a certain predetermined 


5 







threshold, then remedial action might bring the complexity of the module back within 
allowed limits by dividing the code into smaller less complex modules. [SLI87] 

C. WHY COUNTERS AT ALL? 

The use of size metrics (Source lines of code (SLOC) and logical source statements) 
include tracking, planning, budgeting, nuuntaining and estimating software projects. 
Software developers also use software size metrics to plan, control, and improve their 
product [SEI-B 92] 

1. Automated versus Manual Counters 

Performing software measurements with a purely manual technique is expensive 
because of the extra-ordinary amount of time involved even for the simplest of 
measurements. In addition, performing any function manually may introduce errors 
because humans are fallible. To overcome these problems and provide the flexibility, 
consistency and reliability the process of making these measurements must be automated. 

2. Counting versus Reporting versus Tracking 

The smart software developer will get the most out of the information available 
from metrics. The metric numbers are the result of performing some measurements against 
a piece of software. These numbers represent the counting portion of the metric. The results 
will differ when the rules are changed. The displays of the outputs from the count have to 
deal with the reporting aspect of the metrics. The user requesting, the information need to 
be able to get the infoirvition in a form that he is expecting, and one that will be of use. 
Tracking refers to the ability to trace the progress of the software development project 
completely. During tracking, the manager can decide if the project is meeting the schedule. 

The Department of Defense (DoD) is trying to deal with the effects of a reduced 
budget As DoD rightsize itself, organizations are going to have to do more with less. The 
software community will be no different. DoD has set up some long term goals that include: 
reducing the life-cycle costs by a factor of two; reducing software problems rates by a 


6 





factor of ten; achieving new levels of DoD mission capability and interoperability via 
software. 

These goals imply that DoD can apply some measure of where they are now, 
against where they are going, to know if they ever get there. However, no baseline has been 
set to measure progress toward these goals. DoD has teamed up with the Software 
Engineering Institute (SEI) to provide a part of the baseline that will be necessary to meet 
the above goals by the year 2000. Software metrics will provide the measurement from the 
baseline of the software development progress. [SEI-A 92] 

SEI’s task is to provide a core set of measurements for use within DoD software 
projects. In 1992, SEI published several frameworks accomplishing the goal. DoD agencies 
can use these frameworks to plan, monitor, and manage its software projects, both internal 
and contracted. These SEI framework documents outline how to: define what is to be 
measured (set a standard), by using a checklist; and to express clearly the results of those 
measurements, (provide unambiguous results) consistently. 

TTic SEP frameworks help management to answer several key questions. How big 
is the job? Can our staffs meet the added commitments? C^ we deliver on schedule? How 
reliable is our project? Will the project meet fielding deadlines? Will the project meet the 
required specs? Will the project need more time and effort due too unplanned releases to 
fix detected bugs? The answers to these questions will help the software developer ensure 
the proper mix of personnel are available for the project and give an idea of where the 
project is in relation to the baseline. 

SEI has concentrated on defining unambiguous measures for size, effort, 
schedule, and quality. It is SEPs objective to provide tools the project manager can use 
concerning project planning, project management and process improvement. Consistent 
measurements are crucial to the project manager. 


7 






D. PROBLEM DESCRIPTION 

Tools to count lines of code have been around for a long time. However, these tools 
are not standardized, automated and can lead to misleading and ambiguous interpretations 
of the size of software modules, especially when the person performing the measurement 
does not use the method or rules expected by the person requesting the measurement 

One question addressed by this research looks at the ability to automate the SEl 
framework for Software Size Measurement Introducing automation to most processes 
reduces the time required to complete the process since machines are inherently faster than 
man. If automating the SEI framework for Software Size Measurement provides more 
benefits compared to costs, then it may be of value to carry out the framework. 

Another question addressed by this research pertains to the ability to provide the 
standardization of the SEI framework for Software Size Measurement Introducing 
standardization to the measurement process will provide unambiguous, clear and consistent 
reports, that management can use to track their software development process. 

A final question addressed by this research looks at how to provide the flexibility 
outlined in the SEI framework for Software Size Measurement The SEI framework is 
designed to allow over eighty different values, while still maintaining the consistency and 
reliability of the counting tool. 

E. OVERVIEW OF THESIS 

Chapter 11 provides background information related to this thesis. Topics covered 
include an overview of the SEI frameworks on size, effort and schedule, and quality. 
Chapter III discusses the tool design. This includes each of the major parts of the tool, TAE, 
Ayacc, and Aflex, giving an overview, purpose and interaction with the other parts. Chapter 
IV describes how to use the tool. Chapter V provides a summary of conclusions and further 
work. Appendix A contains a user manual. Appendix B list the source code for the tool. 
Appendix C lists some sample inputs and outputs. 


8 






n. SEI FRAMEWORK 


A. DEFINITION OF FRAMEWORK 

A framewoik is “a structure to hold together or support something” fWAR 90]. SEI 
has published three frameworks in the area of software measurement The three 
frameworks are concerned with size, effort and schedule, and quality. These frameworks 
are the result of years of work by several groups of software professionals. [SEI-A 92] 

SEI does not propose that these framewoiks as standards set in concrete, but to use 
them as a basis for collecting information concerning the development of software. These 
frameworks provide measurements that will lead to unambiguous and mutually exclusive 
reports. To achieve this, each SEI framework uses two criteria. The first is communication. 
A measurement is not useful if the report user does not understand the results, or the rules 
used to get them. The report needs to convey what was measured and what was not 
measured. The second criterion is repeatability. Ute noeasurement, when applied by others, 
should have the same results. Consistent report results provide confidence to the users. 
Users will not use a measurement that does not provide stable results. [SEI-A 92] 

Each framework proposed by SEI has some common structures. They all use 
checklists and recording forms. The checklists provide the repeatability mechanism. 
Having a checklist filled out and on hand, any person performing the measurement knows 
what is to be measured. The recording forms provide this communication mechanism. The 
person reading the recording forms can see what was measured and what was not. [SEI-A 
92] 

Developers of software projects are looking at ways to help manage the entire software 
process as the software projects get larger and more complicated. The software developer 
goal is to produce code that is on time, reliable, and performs as the users requested. 
Software developers can add these frameworks to their toolbox and use them during the life 
cycle of a project The use of measurements can help the software developer produce 
quality code on time and under budget [SEI-A 92] 


9 






A problem with previous measurement was not doing the measurement, but 
communicating the result so diey have meaning to the user. Important parts of the 
firameworks are the attributes of the measurement 

1. Attributes 

An attribute is “something seen as belonging to or representing someone or 
somediing.** [WAR 90] The attributes associated with the SEI frameworks provide insight, 
definition and charactnistic of the software project being measured. [SEI-A 92] 

The SEI checklist identifies the attributes that need to be measured to ensure the 
two criteria of communications and repeatability. The checklist shows what attributes are 
included or excluded for each report To ensure that measurements are accurate and non¬ 
overlapping, SEI has carefully chosen the attributes so that they are orthogonal in nature. 
The attributes are the broad categories of the firameworks. Each attribute is made up of two 
or more values to provide a finer measurement [SEI-A 92] 

2. Values 

The values for each attribute were chosen so that they are mutually exclusive of 
each other. The reason for this is to help eliminate misunderstandings that can result if the 
values for any one attribute are overlapping. Values are listed on the checklist form. The 
measurement user then fills out the form and either chooses each value as included in the 
measurement, or excludes the value from the measurement. Statement type is one attribute 
within the SEI framework for Size. The listed values for this attribute are: executable, 
declarations, comments on their own line, comments on line with source code, comments 
that are banners or nonblank spacers, empty comments and blank lines. This is not an 
exclusive list, users can add or change as they see fit However, users need to ensure that 
changes or modifications to the values keep the mutuaUy exclusive property. Changes that 
violate the mutual exclusion property could result in possible double counting of some 
values. [SEI-A 92] 


10 






3. Reports 

After the checklist has been filled out, and the measurement performed, the next 
step is to express the results of the measurement in a way that can be understood and read 
by the people who use them. Each of the three frameworks that SEI published has an 
example of some predefined initial reports and the associated value settings. Ilie reports for 
the SEI framework on Size are discussed in more detail in chapter three. A more detailed 
discussion of reports for the other two frameworks can be found in the Software 
Engineering Institute reports. 

B. APPLICATIONS OF FRAMEWORK 

1. Software Size Measurement: 

The SEI framework for size provides two independent templates that can measure 
the size of software, physical source lines and logical source statements. The use of size 
measurements can be used by software project managers to plan, maintain, track, and 
estimate software projects. [SEI-B 92] 

Another goal of SEI was to reduce ambiguities and misunderstandings in the 
different reports of software size. Without using a process similar to the SEI framework, 
reports containing statements like “our activity produced over 500K source lines of code” 
would be meaningless to everybody except the person performing the count. The reason 
this count is unclear is the fact that the statement does not tell die reader what wa^ counted, 
what was not counted, rules used to perform the count, if the count included all software 
modules, or just newly developed modules. The user of the reports needs to understand the 
rules and methods used to perform the counting operations. SEI’s framework on size 
provides for complete and explicitly defined measures for both physical source lines of 
code and logical source statements. [SEI-A 92] 

The framework also provides for the ability to ensuring that the report received 
this month is consistent with the report received last month and the one that will be received 
a year from now. This consistency will allow users to gain insight into project trends, to 


11 





compare one project against others, and ultimately to make necessary corrections if needed 
in the total software development process. [SEI-A 92] 

2. Software Effort and Schedule Measurement: 

The framework for effort and schedule provides a starting point for building 
unambiguous measures that will help manage, software projects and processes. The SEI 
reports are an approach to gather information for defining and recording staff-hours and 
related schedule information. There are many reasons for collecting and using data for 
staff-hours, three of which are: to pay individuals (payable hours), to charge for hourly 
services (billable hours), and to use in productivity and quality studies (actual hours). [SEI- 
A92] 

3. Software Quality Measurement: 

As with the other SEI frameworks, the goal of the quality framework is to provide 
the user the ability to obtain clear, non-overlapping and repeatable reports of software 
quality. The framework includes: the relationship of the discovery, reporting, and 
measurement of problems and defects; a set of measurable, orthogonal attributes for 
making the measurement descriptions exact and unambiguous; checklists for creating 
unambiguous and explicit definitions or specifications of software problem and defect 
measurements; exanqtles of how to use the checklists to construct measurement 
specifications; and examples of measurements using various attributes of software problem 
reports and defects. The reports of software quality can help the user to estimate, plan, and 
track, the software development process. [SEI-D 92] 

C. AUTOMATION OF SIZE MEASURE 

There are several reasons for selecting the size measurement as the measurement to 
automate first They are: 

• Most of the historical data for cost models and project estimating are based 

on physical measures of source code size. 

• Size measurements are easier to define and use. 


12 






D. PREVIOUS SIZE CALCULATORS 

There are two size calculators that were looked at as examples of tools to count source 
line of code. One tool was a static prototype of the SEI framework, on DOS a platform. The 
other tool was a mature DOS product for Pascal programs, to calculate non-SEI size 
measures and other metrics. 

1. DOS Version of the SEI Framework on Size 

The version tested was a prototype of the SEI framework on size. The tool was 
not completely functional. The tool as tested only carried out the attribute’s statement type 
and origin. The other attributes were scheduled to be set up at a later release date. The tool 
also did not allow for the operator to change the settings of the values for the two attributes 
supported. The settings for both attributes were set to “included.” [CSC 92] 

AdaS AGE provides the user interface to the tool. The interface was a copy of the 
checklist form provided by the SEI framework. The tool requires the user to type in the 
name of a source Ele. The source file will contain the names of Ada modules. The tool will 
write the results of the measurement to a file. [CSC 92] 

A session at a recent software engineering conference included descriptions of 
tools developed in parallel with this thesis, but these were unavailable for examination. 
[SEI 93] 

2. PC-Metric for Pascal 

TTie PC-Metric for Pascal is a DOS-based tool that provides three separate 
measurement reports on Pascal programs. The three reports are the complexity report, the 
exception report and the error report As a part of these reports, the PC-Metric for Pascal 
also provides information on the number of lines of code contained in the source file. 
However, the lines of code are just that, the total number of lines of Pascal code. No 
information on the statement types that were counted, how the code was produced, the 
origin of the code and so on. The method for obtaining the line count was to count the total 
number of lines in the source file. [SLI87] 


13 





However, the PC-Metric for Pascal docs provide some insight into the 
complexity, the exception and errors of the Pascal source file. Also included with the 
documentation, is a tutorial on software metrics. The tutorial covers how to develop 
metrics, metrics’ accuracy, specific metrics and how to use metrics in software 
development [SLI 87] 

E. SUMMARY 

This chapter has discussed the SEI framework, the building blocks of the framework, 
how the frameworks can be applied, and examples of some tools that provide physical 
source lines of code measurements. The SEI framework is designed to provide a flexible, 
automated measurement tool based on consistency and reliability. The two tools 
summarized above do not provide the flexibility of the SEI framework. The Automated 
Ada Physical Source Line Counter provides a flexible, automated tool that provides 
consistent and reliable results. 


14 




m. TOOL DESIGN 


A. ATTRIBUTES SUPPORTED 

The SEI framework on size details nine different attributes that are orthogonal in 
nature. The Automated Ada Source Line Counter implements six of the nine attributes. The 
following sections discuss the attributes in detail. (See Figure 1) 


SEI Attributes 

* Statement type 

* How Produced 

* Origin 

* Usage 

* Delivery 

* Development Status 
Functionality 
Replications 

** Languages 


* Implemented in this tool 
♦* Ada is the only language 
implemented 


Figure 1 SEI Attributes supported and not supported 
1. Statement Type 

The statement type attribute distinguishes the source statements according to the 
function they perform. There are five basic types of statements, they are: executable, 
declarations, compiler directives, comments, and blank lines. Comments are fiirther 
subdivided into: comments on their own lines, comments on lines by themselves, banner 
and nonblank spacers, and empty comments. The value of this attribute is determined for 
each physical source line of code during the parsing of the input files. [SEI-B 92] 






2. How Produced 

This attribute is used to identify the process by which the individual line of code 
was produced. This attribute is divided into six values, that include: programmed, 
generated with source code generators, converted with automated translators, copied or 
reused without change, modified, and removed. The value of this attribute is determined by 
special comments in the source code. The default value for this attribute is ‘programmed’. 
Special comments are discussed in greater detail in PARSER on page 32. [SEI-B 92] 

3. Origin 

The attribute origin tracks the prior life, if any, of the product software. The origin 
attribute is divided into eleven values. The values are the following: new work; a previous 
version, build or release; commercial, off-the-shelf software (COTS), other than libraries; 
government furnished software (GFS), oth» than reuse libraries; another product; a 
vendor-supplied language support library (unmodified); a vendor-supplied operating 
system or utility (unmodified); a local or modified language support library or operating 
system; other commercial library; a reuse library (software designed for reuse); and other 
software component or library. The value of this attribute is determined by special 
comments in the source code. The default value for this attribute is ‘new work’. [SEI-B 92] 

4. Usage 

The usage attribute makes the distinction of code developed as part of the 
software project and code not developed for the software project. The attribute usage is 
divided into the values in or as part of the primary product and external to or in support of 
the primary product Code that is developed as part of the software project could have 
different costs associated with the development maintenance, and testing of the code 
versus code that is developed for support of the code. For example, test drivers are not 
maintained or documented at the same level as the primary code. Distinguishing the 
differences is important for reports of productivity, quality, effort and progress. The value 


16 







of this attribute is determined by special comments in the source code. The default value 
for this attribute is ‘in or as part of the primary product’. [SEI-B 92] 

5. Delivery 

The delivery attribute distinguish between the form and destination of the source 
code. In this tool, delivery means delivered to the organization that will maintain the source 
code. The delivery attribute is divided into four values, that include: delivered as source; 
delivered in compiled or executable form, but not as source; under configuration control; 
and not under configuration control. For reports A through E, this value is set to ‘delivered 
as source’. For report F, the tool user has the option to pick one of the four values of this 
attribute. The default value for report F is ‘delivered as source’. [SEI-B 92] 

6. Development Status 

The development status attribute is used to mark the progress of the source code 
from the design phase to a finished product The count of the various values of development 
status can provide insight into the development and integration workload yet to be 
accomplished. The attribute development status is divided into eight values, which are: 
estimated or planned; designed; coded; unit tests completed; integrated into components; 
test readiness review completed; software (CSCI) test completed; and system test 
completed. The value for this attribute is determined by special comments in the source 
code. The default value for this attribute is ‘system tests completed’. [SEI-B 92] 

7. Clarifications (General and Ada Specific) 

The clarification attributes, both the general and Ada specific, aid in explaining 
the rules used to define the differences among the eight values of the attribute statement 
type. The general clarifications are for any language. The Ada specific clarifications deal 
only with Ada programming language issues. Each general and Ada specific clarification 
is associated with a unique statement type attribute value. For example, the default setting 
for counting a null statement, is to count the null statement as an executable. The 

17 






clarifications for reports A through E can not be changed. In report F, the user may change 
the clarifications rules from one of the attribute statement type values to another. [SEl-B 
92] 

B. ATTRIBUTES NOT SUPPORTED 

There are two attributes of the SEI checklist that were not implemented in this tool. 
They are functionality and replications, which are discussed briefly in the following 
paragraphs. 

1. Functionality 

The attribute functionality deals with whether or not a line of source code is a 
functional part of the code or not The attribute functionality is divided into two parts 
operative and inoperative. Inoperative is further divided into inoperative but functional 
(intentional dead code, reactivated for special purposes) and nonfunctional (unintentionally 
present). [SEI-B 92] 

2. Replications 

The attribute replication describes how to account for a software project’s master 
source statements from its copies. There are four values for the attribute replications, which 
are: master source statements (originals); physical replicates of master statements, stored 
in the master code; copies inserted, instantiated, ot expanded when compiling or linking; 
and postproduction replicates — as in distributed, redundant, or reparameterized systems. 
[SEI-B 92] This attribute was not implemented in this tool, although combinations of the 
Ada Physical Source Line Counter with a differencing tool such as the unix DIFF might be 
useful [SUN 90]. 

C. DEFAULT REPORTS/OUTPUT 

There are a total of six reports that this tool can generate. Five of the reports are defined 
by the SEI framework on Size. A sixth report is provided to allow the usct to create, modify, 


18 





and use as they see fit. Appendix C contains examples of each reports ou^ut Each report 
will be briefly discussed in the following paragraphs. 

1. Report A 

RqK)rt A is the basic definition for counting physical source lines of code. Hiis 
report will give us information on the total noncomment and nonblank physical source lines 
of code. Report A explicitly spells out the rules to be used when conunents are on the same 
lines as other source statements. The report also addresses all origins, stages of 
development and code that is integral to the product and external to the product, and forms 
of code production. Reports B through F build upon this basic definition. See Figure 2 for 
a written specification for this report. No data arrays are included in this report. [SEI-B 92] 

For the prognunming language Ada, measure and record these values: 

Total lines 

Individual totals for aU values included 

Figure 2 Written Description for Report A 

2. Report B 

Report B provides the capability for project tracking. Rq)ort B provides this 
information through the expanded use of the development status attribute. For example, 
report B will provide the progress of the software project through each of the production 
processes, the how produced attribute in comparison to the stage of development and the 
development status attribute. This is accomplished through periodic measurements using 
report B and comparing the results of the two-dimensional array. See Figure 3 for a written 
specification for report. Appendix C contains an example of report B and the associated 
two-dimensional anay. [SEI-B 92] 

3. Report C 

Rq)ort C is designed for the end of project data gathering. The results of this 
report can be used to improve future estimates and planning for future projects. ITiis data 


19 








For the ptogramming language Ada, measure and record these values: 

Total lines 

Individual totals for all values included 
A two-dimensional array showing die number of lines 
in each devek^ent status 
for each production class 

Figure 3 Written description for report B 
would be collected at the end to help fine tune existing estimates and cost models and for 

the estimation of future software projects. Report C adds to report A by including the values 

of comments on their own lines and comments on lines with source code for the statement 

type attribute, the value removed for the how produced attribute, and a two-dimensional 

array, six by eight, containing the attributes statement type and how produced. See Figure 

4 for a written specification for this report [SEI-B 92] 


For die programming language Ada, measure and record diese values: 
Total lines 

Individual totals fw all values included 
A two-dimensional array showing the number of lines 
in each statement ty^ 
for each production class 


Figure 4 Written description for report C 

4. Report D 

This report measures reuse of software code. The data elements included in this 
report will help the user to quantify and interpret the amount of software reuse. This report 
can also be used to measure productivity and quality. Report D, in addition to the 
information for report A, asks for a two-dimensional array, six by eleven, containing the 
attributes of how produced and origin, and includes the value removed for the attribute how 
produced. See Figure 5 for a written specification for this report [SEI-B 92] 

5. Report E 

Report E is the combination of report C and D. Combining the two reports can 
save resources including time, money, and paper. However, the trade-off for this report is 


20 









For the programming language Ada, measure and record these values: 

Total lines 

A two-dimensional array showing the number of lines 
in each productkm class 
for each origin 

Figure 5 Written description for report D 
the creation of a three>diiiiensional array. Three-dimensional arrays are harder to 

communicate to the user, especially using two-dimensional medians such as monitors and 

paper. Report C generated one two-dimensional array of six by eight Report D generated 

one two-dimensional array of six by eleven. Report E on the other hand, generates eleven 

two-dimensional reports of six by eight The higher number of arrays are required to 

facilitate the display of information that can be displayed on a terminal, written to an ASCII 

file, or printed on paper. A three-dimensional array is displayed by taking the third 

dimersion of size eleven and creating one two-dimensional array of six by eight from the 

otho- two dimensions. See Figure 6 for a written specification for this report [SEI-B 92] 

For the programming language Ada. measure and record these values: 

Total lines 

A three-dimoisional array showing the number of lines 
in each production class 
for each origin 
in each statement type 

Figure 6 Written description for report E 

D. USER-DEFINED REPORTS/OUTPUT 

The tool enables the user the ability to create any unique report This report is left up 
to the user of the tool to design and create according to requirements. The initial settings 
are the same as report A. For instance, the user would use report F to assign a different 
priority to the values of the statement type attribute. 












E. DATA STRUCTURES 

There are several key data structures used throughout the tool. The data structures are 
declared in the Transportable Applications Environment (TAB) global package because of 
the need for TAE generated Ada code to have the ability to set key variables used for every 
report and to change, as required, the user defined report 

The key elements of the data structure include: variables used for every report; the size 
attributes declared as enumerated types; one five-dimensional array to hold the source line 
count per reports; one one-dimension array to track the precedence levels of the statement 
type attribute; one two-dimensional array that maps the eight different statement type 
values to two boolean variables to track statements on lines; a record structure containing 
Eve Helds, one field for each of the five dimensions and a record that contains all of the 
supported attribute values. 

Several of these different data structures are repeated, one instance of each data 
structure for each possible report Having the multiple instances of the data structure allows 
for up to six different reports to be generated at the same time, even though the Ada input 
files are only parsed once. A trade-off was made in favor of time to make repeated runs of 
the tool versus the extra storage space needed to generate all six reports during one run. A 
detailed discussion of each key data structure follows. 

1. Variables used for every report 

Every time that the Automated Ada Physical Source Line Counter is invoked, 
there are two pieces of information that must be entered by the user for the tool to run 
properly. The two pieces of information are the names of the input and out files. There are 
two other pieces of information that are not mandatory, but will help in the tracking of the 
different report versions. The name of the person requesting the information and the name 
of the report are non-mandatory. 

The input file is an ASCII file that contains the names Ada source file (s) to be 
processed by this tool. Even though there exist a cost in time to generate the file with all the 


22 






filenames, the benefits of this approach outweigh the cost (See Figure 7) The output file 



Figure 7 Relatimship of input file name and Ada source files to be measured 


name is used to create an ASCII file containing the reports requested by the user. At this 
time there ia no default name used by the tool. 

2. Size Attributes 

The five attributes of the SEI fran^work that are measured in this tool have each 
been declared as enumerated types. The values for each attribute enumerated type are the 
values for that attribute as defined in the SEI framework for size checklist Using 
enumerated types facilitated the use of the Ada language attributes associated with 
enumerated types. (See Figure 8). 

type STMT_TYPE is (EXECUTABLE, DECLARATIONS , 

COMPILER.DIRECnVES, 
CMTS_ON_OWN_LlNE, 
CMTS_WITH_SRC_CODE, 
BANNERS_NON_BLANK_SPACERS, 
BLANK.COMMENTS, BLANK.LINES); 

Figure 8 Attribute Statement T^pe values declared as an enumerated type 


23 











3. Five DimaisifMial Arrays 


To keep track of the five orthogonal attributes a five dimensional array was 
created, one dimension corresponding to each attribute. This was followed by the creation 
of six instances of the five dimensional array. Each instance of the five dimensional array 
is associated to one of the six reports. Each line counted of the Ada source files has one of 
the values of each attribute associated with it The Automated Ada Physical Source Line 
Counter uses the five-dimensional array to track this association. To calculate the 
individual totals for each value, the five-dimensional array is traversed one dimension at a 
time. The tool also uses the five-dimensional array when computing the requested two and 
three dimensional arrays for reports A through E. (See Figure 9) 

type COUNT_ARRAY TYPE is array (STMTJTYPE, 

HOW_PRODUCED, 

ORGIN, 

USAGE, 

DEVELOPMENT_STATUS) ol natural; 

Figure 9 Declaration of five dimensional array 
4. Priority Arrays 

The priority arrays are checked each time the lexical analyzer recognizes the end 
of the line marker. At this time, the highest priority of the statement type values found on 
the line is determined. When the statement with the highest priority is marked as 
“included”, the line statement type attribute is set to this value. 

For the five default reports A through E, the precedence for each report is the 
same and can not change. For the user defined report F, the precedence for each value of 
the statement type can be set according to the user’s requirement The user sets the 
precedence levels for report F inside of the user interface. (See Figure 10) 

type PRIORITY_TYPE_ARRAY is array (1..8) of STMT.TYPE; 


Figure 10 Declaration of Priority type array to track precedence levels 

24 









5. Flags Array 

A two-dimensional array was created to determine when a particular statement 
type value has been recognized on a line. The first dimension of the array is the range of 
the enumerated statement type. The second dimension of the array contains two boolean 
variables. (See Figure 11) One of the boolean values is set to true when the start of a 

type FLAGS_TYPE_ARRAY is array (STMT.TYPE, 1.. 2) of boolean; 

Figure 11 Declaration of FLAGS_TYPE_ARRAY 
language construct is recognized by the parser. The second boolean value is set to true when 
the end of a language construct is recognized by the parser. (See Figure 12) When the 
lexical analyzer recognizes the end of line, the flags_array is traversed from highest to 
lowest precedence. The statement type value recognized with the highest precedence is 
then counted, if required. 

set_exec_start: {FLAGS_ARRAY(STMT_TYPE’val(0). 1) := true;); 
set_cxec_end: |FLAGS_ARRAY(STMT_TYPE’val(0), 2):»true;); 

Figure 12 Example of FLAGS_TYPE_ARRAY values set to true 

6. Current Settings Record 

In order to track each of the five dimensions, the record structure 
“current_settings” was created. This record structure is used whenever a physical line of 
code is counted. The respective current_settings field is updated when the parser recognizes 
either the language constructs associated with the statement type attribute or the special 
comments for the other four attributes. 

7. Checklist Variables 

A record structure, record.flags, was created to track each attribute and its values. 
There is one instance of record_flags for each report. The default values for reports A 


25 







through E are assigned when the package Global is elaborated. The default values for report 
F are the same as the basic report A. The user specifies their own values for report F by 
stepping through the user interface panels. See Appendix B for copy the global package 
source code. 

F. OVERVIEW 

The Automated Ada Physical Source Line Counter, as its name suggests, is a tool that 
will perform a count on Ada source files and generate reports of the total number of 
physical source lines counted and individual totals of each value included for each report 
requested. The tool consists of four parts diagramed in Bgure 13. 

Automated Ada Physical Source Line Counter 


User Interface 



Figure 13 Overview of the Automated Ada Physical Source Line Counter 


26 













The first part is the data structure. The data structure holds all of the default and user 
set variables that are used by the other three parts of the tool. The default values are set for 
reports A through E during elaboration. The user-specified values for report F are set by the 
user via the user interface. The second component is the user interface. The user interface 
allows the user to request either five default reports, or to create a report of their own. The 
user interface was built using TAE, and based upon the SEI framework on size 
checklists.[NAS 90] The next element of the tool is the parser. The parser was created using 
two tools, Ayacc, and Aflex. Ayacc generates a parser, where Aflex generates a lexical 
analyzer used by Ayacc. The parser created by Ayacc and Aflex is used to distinguish 
between the different values of the statement type attribute, recognize special comments, 
and at the end of every line determine how the line should be counted, if at all. Tiie next 
part is the report generator. This part performs the calculations that sum the individual and 
aggregate totals and any two and three-dimensional arrays. In addition, each report that is 
requested is generated and written to an ASCII file. Each part of the tool will be discussed 
in greater detail in the following sections. A user manual for the tool is included in 
Appendix A. 

G. USER INTERFACE 

The user interface provides a window type access that is an easy-to-use method to 
request one or several pre-defined reports or to create an individualized report Each of the 
supported attributes is contained in its own panel or screen. The user interface is made up 
of eleven panels. (See Figure 14) 

The panels are made up of selection items, text items and labels. There are three types 
of selection items. The types are push-button, checkboxes and radio buttons. The push¬ 
button is used to connect one panel to another. The push-buttons are shaped like a rectangle. 
The checkboxes are used whenever the user has the choice to pick more than one item. The 
checkboxes are shaped like a square. For example the user can pick just one report, say A, 
an or the user can pick all six reports, A through F. The radio buttons are used when the 


27 





user can pick only one of the items in the group. The radio-buttons are ^aped like a 
diamond. At least one item will always be picked. For example, if the user picks the value 
blank lines to be included in report F. then the radio button for “Includes” will be 
highlighted. The button for “Excludes” will change from highlighted to blank and vice 
versa. 

Each of the panels have default settings for push-buttons, radio-buttons and 
checkboxes. Each default selection is highlighted. To change or add too the default 
selection, the user must use the left mouse button. The default push-button can be selected 
when the return key is pressed while the cursor is in that panel. 

The push-buttons for each panel are displayed along the bottom. Two of these push¬ 
buttons are common to each panel and will be discussed separately from each particular 
panel. Tlie first push-button is the “Quit” button. The other push-button is the “Help” 
button. When the quit button is pressed, the quit panel is displayed over the top of the 
current panel. The quit panel gives the user the choice to quit the application, or to go back 
to the panel that they were just on. When the help button is pressed, a help panel with 
infomiation particular to that panel will be displayed. When the user is finished with the 
help screen, the help screen will disappear and the panel that initiated the help screen will 
again be the active screen. 

The first panel is an introduction panel. The introduction panel contains the name of 
the tool, name of the author and three push-buttons displayed along the bottom. Beside the 
quit and help push-buttons, the other push-button is the “Next screen” button. The next 
screen button will make the introduction panel disappear, and bring up the second panel. 
The next screen push-button is the default push-button for the introduction panel. 

The second panel is where the user wUl enter the mandatory information for the tool 
to operate. The second panel contains four string keyin areas, a group of six checkboxes 
and four push-buttons. The string keyin areas are for the report name, file list, requestor 
name and output file name, respectively. The user enters the appropriate information by 
placing the cursor over the window and type in the appropriate information. Six checkboxes 


28 





of the attribute statement type. TAE will ensure that the precedence entered is within the 
range of one through eight However, if the user does not ensure that each precedence value 
is unique, the results for report F may not be accurate. 

The eight and ninth panels are for the general and Ada specific clarifications panels 
respectively. These two panels arc similar to panel three, the difference being the number 
of radio-buttons. There are a total of thirteen general clarifications and six Ada specific 
clarifications. Each clarification is associated with one of the values of the attribute 
statement type. 

The tenth »^anel is the generate report panel. This panel has two push-buttons displayed 
along the bottom of the panel, they are labeled cancel and generate report. The generate 
report is the default button. The cancel button will make the generate report panel 
disappear. The user must then use the mouse to click on the icon of the previous panel. In 
addition to the push-buttons, this panel displays a text message explaining the different 
options available to the user. 

The last panel is the quit panel. This panel also has two push-buttons displayed along 
the bottom of the panel, they are labeled qua and cancel. The quit button is the default 
button. When the quit button is selected, the panel will disappear and the tool will 
terminate. When the cancel button is selected, the quit panel disappears leaving the 
previous panel as the active panel. In addition to the push-buttons, there is a text area that 
displays the options to the user. This is provided in lieu of a help button. 


30 





t 


represent six different reports that can be generated by this tool. Any one or all of the 
checkboxes nrtay be selected. Report A is the default selection. In addition to the quit and 
help push-button, the second panel also has displayed along the bottom a “Generate 
Report” push-button and a “Specify Custom Report” push-button. When the generate 
report button is pressed, the second panel will disappear and the generate report panel will 
appear on the screen. When the specify custom report push-button is selected, the second 
panel disappears, and activates the third panel. The generate report push-button is the 
default push-button for the second panel. 

The third through the seventh panels contain the attributes of the SEI checklist, one 
attribute per panel. There are five push-buttons on each of these panels. The first two push¬ 
buttons are the quit and help buttons. Another push-button is the “Previous Screen” push¬ 
button. When the previous screen button is pressed, the current panel disappears, and 
activates the previous panel. The next push-button is labeled “Next Screen”. When pressed, 
the current panel will disappear, activating the next panel in the sequence. The last push¬ 
button is the generate report button. When this button is pressed it will make the current 
panel disappear and activate the generate report panel. TTie generate report panel is the 
default button. 

Along the top right comer in panels three through seven arc two radio-buttons 
displayed, one above the other. These radio-buttons allow the user to specify that in 
addition to the individual totals, this attribute will be included in a multi-dimension array 
at the end of the normal report format When this choice is selected, all of the attributes 
selected as such (must have at least two) will be displayed as two or three dimensional 
arrays at the end of report F. When more than three attributes are selected, then all 
combinations of N choose three will be displayed at the end of report F, where N will be 
either four or five. The other major part of panels three through seven are the radio-buttons 
that correspond to the values for each attribute. All of the radio-buttons are the same, either 
the include button is highlighted or the exclude button is highlighted. Panel three also has 
eight integer keyin windows. Each integer keyin window corresponds to one of the values 


29 







Figure 14 Overview of User interface 


31 














H. PARSER 

The Automated Ada Physical Source Line Counter uses the generated parser from 
Ayacc [TAB 88] to differentiate between executable, declarations and compiler directives. 
These are three of the eight values associated with the attribute statement type. To do this, 
the q)ecification file for Ayacc, ada.y, was slightly modified. 

The differences between the three attributes were used to set flags when a particular 
language cons' ict was recognized. To set these flags, several nonterminals were added to 
ada.y. The purpose of these nonterminals was to have the parser execute the associated Ada 
code. (See Figure 15) 

set_exec_start: (FLAGS_ARRAY(STMT_TYPE’val(0). 1) := Inie; h 
set_exec_end: {FLAGS_ARRAY(STMT_TYPE‘val(0). 2) := true;); 

Figure 15 Example of Ada code executed inside of Ayacc 
The Automated Ada Physical Source Line Counter uses the lexical analyzer generated 
by Aflex [SEL 90] for several purposes. The primary reason is to provide the lexical 
analyzer function required by Ayacc. This tool also uses Aflex to find all occurrences of 
each type of comment and blank lines in the Ada source files. (See Figure 16) 

- Checking for blank lines 
''[\t]’An {ECHO; 

FLAGS_ARRAY (STMT_TYPE’VAL (7), 1) := TRUE; 

ADD_TO_ARRAY; 

linenum;} 

Figure 16 Example of rule to find blank lines 
This tool also uses the lexical analyzer to recognize certain Ada source statements/ 
fragments in certain situations. These situations have been derived from the clarifications 
code (general and Ada specific). For example, rules were added to the Aflex specifications 
file which will find when one of the following occurs: an “elsif ’ on line by itself; an “else” 
on line by itself; a “then” on line by itself; or “others” on line by itself. (See Figure 17) 


32 









— Looking for an elsif on a line by itself 

- Aiy]*”elsir(M]*\n {ECHO; ENTER(Z); 

if COUNT.CLARIHCATION (GLOBALjyBCORD_FLAGS_FJ»ANEL10JJNE_ll) then 


FLAGS.ARRAY (STMT.TYra’val (0). 1) := TRUE; 
FLAGS_ARRAY (STMT.TYPE’val (0). 2) ;= TRUE; 
ADD_TO_ARRAY; 

end if; 
linenum; 

retum(ELSIF_TOKEN);} 

— Looking for an “else” on a line by itself 
AIN*]*”else”ISt]*^ {ECHO;ENTER(Z); 

if COUNT.CLARfflCATION (GLOBALRECORD_FLAGS_FPANEL10.LINE_10) then 

FLAGS.ARRAY (STMT_TYPE’val (0), 1) := TRUE; 
FLAGS.ARRAY (STMT.TYPE’val (0), 2):» TRUE; 
ADD_TO_ARRAY; 

end if; 

retum(ELSE_TOKEN);) 

linenum; 


Figure 17 Example of rules added to Aflex 
Finally, this tool uses the lexical analyzer from Aflex to recognize when any of the 27 

special comments or flags have been used in the Ada source files. The special comments 

are used to change the values of the four attributes How Produced, Origin, Usage, and 

Development Status. When a special comment is found, Ada code is executed to set the 

global flag SPECIAL_COMMENT to true and to set the associated curTcnt_scttings field 

to the corresponding value. See Figure 18, 


33 







"-•_Genoraie<r {ECHO; 

SreCIAL.COMMENT := TRUE; 

CURRENT_SETnNGS.SECOND_ATrRroUTE := HOW_PRODUCED’val (1);) 

Figure 18 Example of code to recognize Special comments 

When the lexical analyzer reaches the end of each line, the procedure 

ADD_TO_ARRAY is called. This procedure determines which reports are active, 
determines the highest priority of the statement type(s) recognized on the line, and 
determines if this statement type value is included or excluded for the reports that are 
active. If the statement type value is included, then the count for that report is incremented. 

I. REPORT GENERATOR 

The report generator provides for the generation of the reports after the Ada source 
files have been parsed. The report generator is made up of several Ada packages. Two of 
which will be discussed here. The main package is the report_package. The main functions 
of this package are to determine which reports have been requested; perform the necessary 
calculations of the values for each report; and to create and write to the output file the 
reports requested. Several of the default reports require the generation and output of two or 
three dimensional arrays. To accomplish this, a separate generic package was created. 

All calculations of the two and three dimensional arrays are performed in the generic 
package. The large number of multi-dimensional arrays that could occur in report F was the 
driving factor for this package. In report F, the user can request data arrays for all five 
attributes. This would require ten two-dimensional arrays of five choose two and ten three- 
dimensional arrays of five choose three. To reduce the number of instantiations of the 
generic package, the permutations of the two and three dimensional arrays were checked 
and the duplicates were discarded. The generic package is instantiated fourteen times. 

J. SUMMARY 

This chapter discusses the attributes supported, attributes not supported, default 
reports A through E, user defined rqiort F, key data structures, user interface, parser and 


34 







the report generator. Together, these parts show that the SEI franwwork for Size can be 
implemented into a fool providing flexibility and maintaining the two criteria of 
communication and repeatability. 


35 







IV. TOOL USAGE 


A. INTRODUCTION 

This chapter describes what is needed to use the tool in section B. Some limitations of 
the tool are discussed in section C. Section D goes over the command line invocation. An 
extended example of an Ada source file is discussed in Section E. Finally, section F 
discusses the reports generated as output fi'om the extended example. Appendix A provides 
a complete user manual for the tool. 

B. REQUIREMENTS 

1. Hardware 

The Automated Ada Hiysical Source Line Counter requires the use of an Unix 
workstation. The tool has successfully run on several SPARC compliant computers: 
Solboume Computer S4000, Sun SPARC station 10, Sun SPARC station 1 and Sun 
SPARC station 2. 

2. Software 

The Automated Ada Physical Source Line Counter requires the use of “X- 
windows” to operate. This tool has worked under Openwindows and Motif. 

3. Input 

The Automated Ada Physical Source Line Counter requires the entering of 
several pieces of information to run correctly. Hie information that is required are the input 
filename, output filename, name of person requesting report and name of the report. The 
first two items are required information. The second two pieces of information are not 
required, but suggested. 

4. Legal Ada Syntax 

Hie Automated Ada Physical Source Line Counter will only work with 
syntactically correct Ada source files. In some instances, generated code will have 


36 






embedded special characters, such as (^L, page tweaks for printing) that will cause a syntax 
error in die parser. This particular error does not cause the tool to terminate, but there nuy 
be some embedded characters that do. This prototype tool was built using version 1.0 of 
Ayacc [TAB 88]. A newer and improved version of Ayacc was released after the tool was 
built and offers some improvement in acceptance of Ada source Hies. 

C. LIMITATIONS 

1. Package Conflicts 

The parser generated by the two tools Ayacc uses a grammar supplied be the user. 
[TAB 88] For this tool, the grammar was the one supplied with Ayacc, but modified for 
purposes of the tool. For the situation of recognizing either a package spec, a package body 
or a generic package requires that for the proper counting of lines, the entire package spec, 
package declaration or generic package declaration must be one line or the final count may 
be incorrect 


gen_inst: 

PACKAGE^TOKEN IDENTIFIER IS.TOKEN 
NEWJTOKEN expanded.n .gen_act_part. 

I PROCEDURE_ident_IS_ 

NEW_TOKEN expanded.!) .gen_actj>art. 

I FUNCnON.TOKEN designator IS.TOKEN 

NEW.TOKEN expanded.n .gen.actjxart ; 

Figure 19 Example of Ada.j input file to Ayacc 
2. Coding Style 

The Automated Ada Physical Source Line Counter counts physical source lines 
of code and is based upon the SEI framework on size. [SEI-B 92] Different coding styles 
can and will result in different results. For example, let’s compare a short example of the 
same code, but different writing styles. (See Figure 20) The total number of non-comment, 
non-blank lines for version one would be two. However, the total for non-conunent, non- 


37 








blank lines for the same exact code in version two results in a total of Hve. The use of a 
pretty printer on the Ada source files prior to using the Automated Ada Physical Source 
Line Counter will ensure consistent results for reports A through E. 

Version One 

procedure EXAMPLE_ONE is TEMP_INT; integers 0; begin 
TEMP.INT := TEMP_INT + 1; end EXAMPLE.ONE; 

Version Two 
procedure EXAMPLE_TWO is 
TEMP_INT; integers 0; 
begin 

TEMP_INT ;s TEMP_INT + 1; 
endEXAMPLE.TWO; 

Figure 20 Example of two different coding styles 

D. COMMAND LINE INVOCATION 

To start the Automated Ada Physical Source Line Counter, the user must either be in 
the directory that contains the tool or have the directory containing the Automated Ada 
Physical Source Line Counter in a valid path statement. In addition, the user must be 
running in an X-windows environment (operating motif, for example). The tool is started 
by any Unix program-execution procedure, but input and output may not be redirected. 

E. EXTENDED EXAMPLE 

1. Sample Application 

The package TASK_PACKAGE was created as part of an earlier class 
programming project This package just one of several packages created for a class project 
The overall objective of this project was to read in a file containing initial information about 








a spaceship. The information included location in three-dimensional space, speed in each 
of the three directions and remaining fuel. Hie object of the program was to be able to 
accept input from a user via the keyboard at least every second and update the spaceships 
parameters. This file was chosen for the extended example because it was of moderate 
length, involved a number of different Ada statements in one file. 

2. User Interface 

In order to see the actual measurement results for an Ada source file performed 
by this tool, the tool was invoked with the file EXAMPLE_FILE. This file contained the 
Ada package TASK_PACKAGE. (See Rgure 21) This section works through an example 

task_package.a 

Figure 21 Contents of EXAMPLE_FILE 

of how to use the tool and how the tool works. This example will result in the generation 
of reports A through F. The tool is started as explained in section A. The user then places 
the cursor inside of the introduction panel and presses the carriage return. The information 
needed to properly run the tool is typed into the text keyin fields of panel number two. (See 
Figure 22) The tool needs this information in order to know the correct input and ouq)ut 
files to open and create respectively. In addition, the name of the report and person 
requesting report are entered. The next step is to choose the rcport(s) the tool are to 
generate. (See Figure 23) Report A is already marked so no further action is required. For 
reports B through F the corresponding checkbox must be marked by placing the cursor over 
the checkbox and/or label for reports B through F and press the left mouse button. Since 
report F has been chosen, the next step is to place the cursor over the push-button Specify 
Custom report. This action will cause panel number two to disappear and activate panel 
number three. 

The changes for panel three include marking all of the radio-buttons for the 
attribute statement type values as included and selecting the push-button generate report. 









Thesis example 
example 
Kevin J. Walsh 
example.out^ 


Figure 22 Example of text keyin fields 


R(^itiype 

1 A; Basic 

■ D; Reuse Measurement 

■ B: n:oject Tracking 

■ E; Project Ana^s(C+D) 

1 C Project Ana^ 

1 F; OistomRqiort 


Figure 23 Example of marked checkboxs for selecting reports A - F 


RqxxrtName; 

File list 
Requestor Name; 
Output File Name: 


40 














(See Figure 24) Marking all of the radio-buttons as included customizes report F to 
measure all lines of tl;e input Ada source file as one of the eight possible statement type 
values. When the push-button generate report is selected, panel number three will disappear 
and the generate report panel appears. Since no mistakes have been made, the next step is 
to select the push-button generate report The generate report panel will disappear. 


1. Executables: 

□ 

^Inclodes ^Excludes 

2. Nonexecutables: 



3. Declarations 

□ 


4. Compiler Directives 

□ 

^Inchides ^Excludes 

5. Comments 



6. Ontheirown 

[I] 

^Includes ^Exchutes 

7. m Source Cbde 

□ 

4 I^lodes 0 Exchdes 

8. Banners/non blank 

□ 

^Includes ^Exchides 

9. Blank (emp^) comments 

4 Includes 4 Excludes 

10. Blanklines 

□ 

^Includes ^Excludes 


Figure 24 Example of customizing report F 


The user interface portion of the tool is now complete. Control of the tool now 
passes over to the parser section. The file list tile name entered in panel two is opened to 
read the name(s) of the Ada source file(s). In this example, the file task_package.a is 
opened and the parser starts to work. To explain how the parser section of the tool works, 









an example of five of the possible values of the attribute ‘statement_type’ arc discussed in 
the following paragraphs. 

3. Statement Processing 

The flexibility of the Ada prograrrung language made it necessary to create 
several variables that this tool and in particular the parser uses to recognize the various 
values of the attribute ‘statement_type’. The Ada language allows more than one statement 
type on a line and allows for executable statements, declarations and compiler directives to 
extend over more than one line. To account for diis, the parser needs to mark the start and 
end of executable statements, declarations and compiler directives; and also to track when 
either an executable statement or declaration or compiler directive extends beyond one line. 
The variables are outlined by statement type and fiinction in the figure below. (See Figure 
25) The variables used for compiler directives is included in Figure 25, even though the 
extended example does not include an example of a compiler directives, the function and 
actions are similar to executable and declaration statements. The code used for the extended 
example is in Figure 26. 



Mark start of 

statement 

variable 

Mark end of 

statement 

variable 

Track multi- 
line statement 
variable 

Executable 

exec_start 

exec_end 

exec_level 

Declaration 

dec_start 

dec_end 

dec_level 

Compiler Direc¬ 
tives 

pragma_start 

pragma_end 

pragmajevel 


Figure 25 Variables used during parsing of source files 


a. Executable Statements 

The parser processes the Ada source sequentially, reading in tokens via the 
lexical analyzer. When the parser recognizes the keyword ‘select’ as starting an executable 
statement, exec_start is set to true (See bubble 1 in Figure 26). When the lexical analyzer 
reaches the end-of-line marker and the procedure add_to_array is called. 


42 

















Once inside add_to_array, the values of exec_start and exec_end are 
evaluated to determine if the variable execjevel needs to be increased or decreased. In this 
case, the variable execjevel is increased. The next check made is to determine if this line 
of code is either a comment on its own line, a banner comment, an empty conunent or a 
blank line. For this line, all of these cases fail. 

The next part of the code checks from the highest to the lowest precedence 
statement type. In this case, the execution statement precedence is the highest, so the loop 
is traversed only once. Since the exec_start flag is true, the cuiTent_settings.fist_attribute is 
set to executable. Now the line is ready to be added to all applicable arrays. 

The procedure determine_which_array is called with the variable 
current_settings. This procedure will add this line to all applicable arrays as long as all five 
values of the variable current_settings are valid for each report requested. In this case, all 
six reports have been requested and the values for the variable current_settings are valid for 
each report The corresponding entry in the arrays for each report is increased by one. Once 
the arrays are modified control is passed back to the parser. 

For the second through the fourth line of this executable code, the variable 
execjevel is greater than zero and the variables exec_start and exec_end are false. The 
lexical analyzer reaches the end-of-line marker and checks the status of the flag settings. 
Since the variable execjevel is greater than zero, then the variable exec_start is set to true. 
In this situation, the variable cuiTent_settings.first_attribute is again set to executable, and 
then processed as the first statement. 

At the beginning of the last executable line is this example, execjevel is 
greater then zero. When the parser reaches the ‘end_select’, the end of the executable 
statement recognized and the flag exec_end is set to true. Before the flags_array is checked, 
the variable exec_start is set to true because of the fact that execjevel was greater than 
zero. Now when the flags_array is checked, both of the variables exec_start and exec_end 
are true. The variable current_settings.first_attribute is assigned tlie value of executable, 
and processed as were the preceding executable statements. 


43 





1 —_ 



Task allows the user to input data to the isogram. 

~ Task will voify input to ensure that input is valid 


task body KEYREAD is 



CHARACTER_1NPUT : 
CHARACTERJO 

DONE 

TEST 

ROCKET_CONTROL_lNPUT; 
character, 
boolean ;= FALSE; 
natural; 

@ 

begin 

© 

select 

a£cq)t start; 
or 

termiitate; 
end select; 




Figure 26 Sample input code 


For the last executable line in this example, the variable exec_level and 
exec_end are both set to true. When the lexical analyzer reaches the end of the line marker, 
the flags_array is checked. With the executable statements having the highest precedence, 
they are checked first. Both of the flags are set to true, which means that at least one 
executable statement either started and finished on this line or an executable statement was 
finished on this line. In this case, it was the later of the two. The variable 
current_settings.first attribute is assigned the value of executable. Then the variable 
current_settings is checked for each report. In this case, for all reports, the current_settings 
are valid and each report count_array is incremented by one. 

b. Declaration Statements 

When the parser recognizes the identifier ‘character_input’ as the start of a 
declaration statement, the variable dec_start is set to true (See bubble 2 of Figure 26). When 
the parser reaches the semicolon, it recognizes the end of the declaration statement and sets 
the variable dec_end to true. In this case, there are no further statement types and the end- 


44 






of-line marker is reached in the lexical analyzer. At this point the procedure add_to_array 
is called and is processed as discussed above. In this example, all four declaration 
statements are parsed and counted in the same manner as the Hrst statement. 

c. Comments on Own Line 

Unlike executable statements^ declarations and compiler directives, aU 
comments and blank lines are handled direcdy from the lexical analyzer. When the lexical 
analyzer recognizes a comment on a line by itself, (See bubble 3 in Figure 26), a comment 
flag is set to true, the procedure determinc_type_comment is called first and then the 
procedure add_to_array is called. The lexical analyzer recognizes a comment on a line by 
itself using the following rules: 

• Zero or more spaces or tabs between the start of line marker and two 
hyphens. 

• Any combination of one or more characters between the two hyphens and 
the end of line marker. 

The procedure determine_type_comment is passed the length of the current 
line, the third character the line and the string of characters from one to the current line 
length. The main purpose of determine_type_comment is to see if the ctirrent comment 
being parsed is either a regular comment on a line by itself or a banner comment. The 
actions taken for banner conunents are discussed below. In this case, the comment is not a 
banner comment. 

Once inside add_to_array, the first check that is applicable for comments is 
determining if the current comment is a full line of code. This is true for this case. The 
current_settings.first_attribute will be set to comments_on_own_line and the procedure 
determine_which_array will be called. As discussed earlier, the procedure 
determine_which_array will check all of the five fields of the variable current_settings and 
increase each array by one when no discrepancies are found. In this case, only the arrays 
for reports C, E and F are incremented. They are the only reports that have comments on 
own line marked as included. 


45 





d. Banner Comments 


A banner comment is a line of symbols used to visually separate blocks of 
comments or blocks of source code. (Sec bubble 4 in Figure 26) The actions taken for 
banna comments are similar to regular comments except as noted here. Inside of the lexical 
analyzer there are two places where a banner comment may be recognized. The first rule is 
the same rule discussed above for comments. The second rule that looks for a banner 
comment made up of just hyphens. The rule used is as follows: 

• Between the start of line marker and the first three hyphens, there can only 
be zero or more blanks and or tabs. 

• Following the first three hyphens there can be zero or more hyphens. 

• Between the hyphens and the end of line marker there can only be zero or 
more blanks and or tabs. 

In the first case the procedure determine_type_comment is called. The 
comment is then parsed looking for a repetition of the third through the sixth character. The 
third through sixth character needs to repeated at least four times to count the comment as 
a banner comment If the comment meets the criteria, then the start and stop flags for banner 
comments are set to true. If the comment does not meet the criteria then the start and stop 
flags for a comment on a line by itself are set to true. The procedure add_to_array is called 
next The actions taken are similar to those discussed above. 

e. Blank Lines 

When the lexical analyzer recognizes a blank line (see bubble 5 in Figure 26) 
the blank_line flag is set to true and the procedure add_to_array is called. In this example, 
for any of the blank lines, the start and end flags for blank lines will be set to true. 

Once inside add_to_aiTay, the first check that is applicable for blank lines is 
determining if line of code in question is a full line of code. This is true for this example. 
The current_settings.first_attribute will be set to blank_lines and the procedure 
detcrmine_which_aiTay will be called. As discussed earlier, the procedure 
determine_which_array will check all of the five fields of the variable current_settings and 


46 






increase the corresponding entry of each array by one if no discrepancies are found. In this 
case, this line will only be added to report F. Reports A through E do not have blank lines 
marked as included, therefore their arrays are not increased. 

/. OUTPUT 

After the source files have been parsed and measurements collected, the data 
must be presented in a way that can be read and understood by the people who request the 
measurements. For the example of using task_packag.a as the Ada source files, a copy of 
each possible report was requested and generated. The different reports will show how 
using different rules can result in different but correct results. 

For brevity, only parts of each report are shown. The complete listing of each 
report are included in Appendix C. The file task_package.a was processed by the 
Automated Ada Physical Source Line Counter producing reports A through F. (See Figure 
27) (See Figure 28) (See Figure 29) (See Figure 30) (See Figure 31) (See Figure 32) To 
compare the results of this tool, the Unix utility wc [SUN 90] was also ran on the file 
task_package.a, which calculated a total of 284 lines for the file. Reports A through the F 
also report the number of lines, but also provide additional information as detailed in the 
SEI Framework for Size Measurement. [SEI-B 92] 

Report A is tools basic definition for counting physical source lines of 
code. Report A details the total number of lines and individual totals for each value marked 
as included. Report A measures all noncomment and nonblank physical source line. (See 
Figure 27) Report A measured a total of 193 lines of physical source lines of code. 

Report B is an example of a report that can be used for project tracking. The 
results from this report can be used to track development status. Report B measures the total 
number of lines, individual totals for values marked as included and a two-dimensional 
array consisting of the attributes development status and how produced. (See Figure 28) 
This report will also count any removed code if annotated vwth a special comment Report 
B measured a total of 193 physical source lines of code. 


47 






REPORTA 



Report Name; Thesis example 

File List used; example 

Requested by; Kevin J. Walsh 



Measured as; Physical source lines 



Delivered as; Delivered as source 



Counted; 193 

Estimated; 0 



Total 

Total Individual 1 

1 Includes Excludes 

totals 

Statement type 

When a line or statement contains more than 



one type, classify it as the type with the 
highest precedence. 



1 Executables Precedence => 1 XXXX 

2 Nonexecutables 


157 

3 Declarations 2 XXXX 


36 

4 Compiler Directives 3 XXXX 


0 

5 Comments 

6 On their own lines 4 

XXXX 

0 

7 On lines with source code 5 

XXXX 

0 

8 Banners and nonblank spacers 6 

XXXX 

0 

9 Blank (empty) comments 7 

XXXX 

0 

10 Blank lines 8 

XXXX 

0 


Figure 27 Partial output of Report A 


Report C is an example of a report that can be used for project analysis. This 
report would usually be requested only at the end of a project. The results would be used to 
provide for better estimates of future projects. Report C measures the total number of lines, 
individual totals for all values marked as included and a two-dimensional array consisting 


48 







REPORTS 



Report Name; Thesis example 

File List used: example 

Requested by: Kevin J. Walsh 



Measured as: Physical source lines 



Delivered as: Delivered as source 



Counted: 193 

Estimated: 0 



Total 

Total 

Individual 

1 Includes Excludes 

totals 

Statement type 

When a line or statement contains more than 



one type, classify it as the type with the 
highest precedence. 



1 Executables Precedence «> 1 XXXX 

2 Nonexecutables 


157 

3 Declarations 2 XXXX 


36 

4 Compiler Directives 3 XXXX 


0 

5 Comments 

6 On their own lines 4 

XXXX 

0 

7 On lines with source code 5 

XXXX 

0 

8 Banners and nonblank spacers 6 

XXXX 

0 

9 Blank (empty) comments 7 

XXXX 

0 

10 Blank lines 8 

XXXX 

0 


Figure 28 Partial output of Report B 


of the attributes statement type and how produced. Report C measmed a total of 240 
physical source lines. 

Report D is an example of a report used for reuse measurement The results 
of this report can be used to evaluate the amount of software reuse. Report D measures the 
total number of lines of lines, individual totals for all values marked as included and a two- 


49 








REPORT C 



Report Name: Thesis example 





File List used: example 
Requested by: Kevin J. Walsh 





Measured as: Physical source lines 




Delivered as: Delivered as source 





Counted: 240 

Estimated: 0 







Total 

Total Individual I 



Includes 

Excludes 

totals 

Statement type 





When a line or statement contains more than 
one type, classify it as the type with the 



highest precedence. 





1 Executables Precedence => 

1 

xxxx 


157 

2 Nonexecutables 

3 Declarations 

2 

xxxx 


36 

4 Compiler Directives 

3 

xxxx 


0 

5 Comments 

6 On their own lines 

4 

xxxx 


47 

7 On lines with source code 

5 

xxxx 


0 

8 Baimers and nonblank spacers 

6 


XXXX 

0 

9 Blank (empty) comments 

7 


xxxx 

0 

10 Blank lines 

8 


xxxx 

0 


Figure 29 Partial output of Report C 


dimensional anay consisting of the attributes how produced and origin. For this example 
file, report D measured a total of 193 lines of physical source lines of code. 

Report E is an example of the combination of two previous report 
specifications. Report E is also used for project analysis. This report would be requested at 
the end of a project The results would then be used to better estimates for future projects. 


50 







REPORT D 



Report Name: Thesis example 




File List used: example 

Requested by: Kevin J. Walsh 




Measured as: Physical source lines 




Delivered as: Delivered as source 




Counted: 193 

Estimated: 0 

Total 

Total 

Individual 


Includes 

Excludes 

totals 

Statement type 




1 When a line or statement contains more than 



one type, classify it as the type with the 
highest precedence. 




I Executables Precedence => 1 

XXXX 


157 

2 Nonexecutables 

3 Declarations 2 

XXXX 


36 

4 Compiler Directives 3 

XXXX 


0 

5 Comments 

6 On their own lines 4 


XXXX 

0 

7 On lines with source code 5 


XXXX 

0 

8 Banners and nonblank spacers 6 


XXXX 

0 

9 Blank (empty) conuncnts 7 


XXXX 

0 

10 Blank lines 8 


XXXX 

0 


Figure 30 Partial output of Report D 


Report E measures the total number of lines, individual totals for all values marked as true 
and a three-dimensional array consisting of the three attributes how produced, statement 
type and origin. For this example file, report E measured a total of240 physical source lines 
of code. 


51 





REPORT E 


Rq>ort Name; Thesis example 

File List used: example 
Requested by: Kevin J. Walsh 

Measured as: Physical source lines 

Delivered as: Delivered as source 

Counted; 240 
Estimated: 0 

Total Total Individual 
Includes Excludes totals 

Statement type 

When a line or statement contains more than 
one type, classify it as the type with the 
highest precedence. 


1 Executables Precedence => 

2 Nonexecutables 

I 

xxxx 


157 

3 Declarations 

2 

xxxx 


36 

4 Compiler Directives 

5 Comments 

3 

xxxx 


0 

6 On their own lines 

4 

xxxx 


47 

7 On lines with source code 

5 

xxxx 


0 

8 Barmers and nonblank spacers 

6 


xxxx 

0 

9 Blank (empty) comments 

7 


xxxx 

0 

10 Blank lines 

8 


xxxx 

0 


Figure 31 Partial output of Report E 
Report F is a us< .jcfined report The user can change any of the values for 
each of the five attributes supported from included to excluded or vice versa. In addition, 
the uso* can request any combination of two, three, four and five dimensional arrays. 


52 







However, any combination of four or five dimensional arrays (all five attributes) will be 
reported as ten three dimensional reports. In this example report F measures the total lines, 
individual totals for all values marked as included. In contrast to report A that measures 
only noncomment and nonblank lines, report F measures all physical source lines of code. 
For this example, report F measures a total of 284 physical lines of code. Hiis is the same 
result as the Unix wc utility. However, report F gives the reader more information than just 
the total number of lines. 

F. SUMMARY 

In summary, this chapter has discussed the tool requirements, tool limitations, 
command line invocation, an extended example and reports generated from the extended 
example. 


53 






REPORT F 


Report Name: Thesis example 

File List used: example 
Requested by: Kevin J. Walsh 

Measured as: Physical source lines 

Delivered as: Delivered as source 

Counted: 284 

Estimated: 0 

Total Total Individual 

Includes Excludes totals 

Statement type 

When a line or statement contains more than 
one type, classify it as the type with the 
highest precedence. 


1 Executables Precedence => 1 XXXX 

2 Nonexecutables 

157 

3 Declarations 

2 XXXX 

36 

4 Compiler Directives 

5 Comments 

3 XXXX 

0 

6 On their own lines 

4 XXXX 

47 

7 On lines with source code 

5 XXXX 

0 

8 Banners and nonblank spacers 

6 XXXX 

5 

9 Blank (empty) comments 

7 XXXX 

0 

10 Blank lines 

8 XXXX 

39 


Figure 32 Partial output of Report F 


54 









V. SUMMARY AND CONCLUSIONS 


There were two areas addressed by this research, the first was to look at the possibility 
of automating the SEI Framework for Size Measurement The second was to look at how 
to provide the flexibility outlined in the SEI Rrantework for Size Measurement This 
chapter provides the answers to these questions. Section A summarizes the significant 
results of this research. Section B concludes by giving suggestions for future research. 

A. RESEARCH SUMMARY 

The research studied the SEI Framework and developed a tool to implement attributes 
of the framework. It was determined that a prototype tool could be implemented supporting 
the following attributes statement type; how produced; origin; usage and development 
status. The user-interface was designed to mimic the SEI Checklist for each supported 
attribute. The user-interface calls a parser that performs the measurements according to 
user-defined requests. Once the parser calculates the counts for the source, the final step is 
to generate the user-requested reports. 

After performing the development, testing and evaluation of the various features of 
this project, we have reached the following conclusions: 

The first result of this research demonstrated that the SEI Framework for Size 
Measurements can be implemented in a tool using the Ada programing language. The tool 
consists of programed Ada code and generated Ada code. The generated Ada code was 
produced using TAE, Aflex and Ayacc. TAE provides the user-interface; Aflex produces a 
lexical analyzer, and Ayacc produces a parser. The programmed Ada code was used to 
integrate the three tools and to produce a report generation capability. The result is a tool 
that implements a major portion of the SEI Framework in Ada, with minimal execution 
cost 

The second outcome of this study demonstrated that the framework’s flexibility can 
be maintained and implemented using source flags. The tool uses those flags to capture the 


55 





flexibility of SEI’s framework checklist and generate multiple reports during one pass of 
the Ada source files. Another mechanism employed the use of global variables that are used 
during the parsing of the Ada code. These global variables are declared for each report to 
separate the different values the supported attributes may have. 

B. RECOMMENDATIONS 

Program managers and software developers should use tools such as the one 
developed in this research to track the entire software project process and compare the 
current program state against the estimated or planned program state at predetermined 
points in time. The results of the tool provide clear and consistent measurement results 
thereby allowing for more accurate decision making. 

Since this work is among the first to use the SEI’s framework, there arc a large number 
of areas where it can be expanded with future studies. Some of these include: 

The entire set of attributes outlined in the SEI Framework for Size Measurement is not 
implemented in this tool. The functionality and replication attributes are not supported in 
this tool. The attribute functionality identifies the number of lint^ of code that arc a 
functional part of the code and the number of lines of code that are not functional part of 
the code. Whereas the attribute replication describes how to account for a software project’s 
master source statements from its copies. To implement both of these attributes would 
require research into how to integrate existing tools, such as the Unix diff, or to build other 
tools. 

The Automated Ada Physical Source Line Counter only measures physical source 
lines of code. The SEI framework also allows for measurement of logical source 
statements. To implement logical source measures research is needed to define exact and 
complete rules for identifying the beginnings and endings for all possible statement types. 

The current tool is implemented for the Ada language. The tool can be extended to 
support other programming languages, such as C and C-H-. Development of an appropriate 
C parser would be needed along with interaction into the tool itself and its user-interface. 


56 







Currently the SEI framework does not involve measurements in areas outside of size, 
effort and quality. Research extending the SEI framework to other metric principles such 
as complexity is needed. 

Finally, this tool provides a clear and consistent size measurement of Ada source files. 
The result of this and future research will improve the ability of software developers to 
accurately quantify and measure software projects. The metrics produced by these efforts 
will improve software productivity and quality. These metrics will provide additional tools 
to the software developer to ensure that projects meet the time and cost constraints. This 
research has established some initial observations and steps of how to automate the SEI 
Framework for Size Measurement, but more questions are left unanswered. 


57 







APPENDIX A USER MANUAL 

A. REQUIREMENTS 

1. Hardware 

The Automated Ada Physical Source Line Counter requires the use of an Unix 
workstation. The tool has successfully run on several SPARC compliant computers: 
Solboume Computer S4000, Sun SPARC station 10, Sun SPARC station 1 and Sun 
SPARC station 2. 

2. Software 

The Automated Ada Physical Source Line Counter requires the use of “X- 
windows” to operate. This tool has worked under Openwindows and Motif. 

3. Input 

The Automated Ada Physical Source Line Counter requires the entering of 
several pieces of information to run correctly. The information that is required are the input 
filename, output filename, name of person requesting report and name of the report. The 
first two items are required information. The second two pieces of information are not 
required, but suggested. 

Special comments are used to distinguish between the different values of the four 
attributes how produced, origin, usage and development status. (See Figure A-1) These 
special comments must be entered by the code maintainer manually. These special 
comments flags are recognized by the lexical analyzer and change the second through the 
fifth field of the variable current_settings. All special comments are in the form of 
*_<text>”. The double hyphens identify the line as a comment. The asterisk is included for 
compatibility with other tools such as Adadl. [SSD 90] The text corresponds to the unique 
values of the four attributes how produced, origin, usage and development status. The lines 
that the special comments are on are not included in the measurement. 


58 




Attributes 

Description 

How Programmed 


-♦_Programmed 

Statements prepared by programmers that are 
not modifications of pre-existing statements 

-*_Generated 

Created by using tools to produce compilable 
statements automatically 

-♦_Converted 

Pre-existing statements that are translated 
automatically or with minor human interven¬ 
tion 

~*_Copied 

Those statements taken verbatim from other 
sources and used as part of the master source 
code for the new product 

--*_Modified 

Modifications are adaptations made to pre¬ 
existing statements so that they can be used 
in a new product, build, or release 

“*_Removed 

All statements that are removed from prior 
code when that code is copied or modified for 
use in a new or revised product 

Origin 


"♦_New_work 

Statements that implement new designs 

“*_Previous_version 

A previous version, build or release 

-*_COTS 

Commercial off the shelf software 

-♦_GFS 

Government furnished software 

--*_Another_product 

Another product 

-*_V SL_spt_library 

Vendor-supplied language support library 
(unmodified) 

—*_V S_OS_or_utility 

A vendor-supplied operating system or utility 
(unmodified) 

--♦_A_modified_spt_lib 

A local or modified language support library 
or operating system 

" *_Other_comm_lib 

Other commercial library 

--*_Reuse_library 

A reuse library (software designed for reuse) 

—*_Other_Software_component 

Other software component or library 


Figure A-1 Special Comments 


59 












































Usage 


~*_Part_of.product 

All code incorporated into the primary prod¬ 
uct and all code delivered with or as part of 
the product that is developed and tested as if 
it were to operate in the primary product 

~*_Extemal_toj)roduct 

All code that is produced or delivered by the 
project that is not an integral part of the pri¬ 
mary product 

Development Status 


“♦_Estimated_or_planned 

The total number of lines estimated for a par¬ 
ticular software module 

“*_Designed 

Appropriate stage of 2167 development 

~*_Coded 

Appropriate stage of 2167 development 

”*_Unit_tests_completed 

Appropriate stage of 2167 development 

~*_Intcgrated_into_componcnts 

Appropriate stage of 2167 development 

--*_Test_readiness_review_completed 

Appropriate stage of 2167 development 

-*_CSQ_completed 

Appropriate stage of 2167 development 

-*_System_tests_completed 

Appropriate stage of 2167 development 


Figure A-I Special Cumment^ 


4. Legal Ada Syntax 

The Automated Ada Physical Source Line Counter will only work with 
syntactically conect Ada source files. In some instances, generated code will have 
embedded special characters, such as ('^L, page breaks for printing) that will cause a syntax 
error in the parser. This particular error does not cause the tool to terminate, but there may 
be some embedded characters that do. This prototype tool was built using version 1.0 of 
Ayacc [TAB 88]. A newer and improved version was released after the tool was built and 
offers some improvement in acceptance of Ada source files. 


60 



























B. LIMITATIONS 


1. Package Conflicts 

The parser generated by the two tools Ayacc uses a grammar supplied be the user. 
[TAB 88] For this tool, the grammar was the one supplied with Ayacc, but modified for 
purposes of the tool. For the situation of recognizing either a package spec, a package body 
or a generic package requires that for the proper counting of lines, the entire package spec, 
package declaration or generic package declaration must be one line or the final count may 
be incorrect. 


gen^inst: 

PACKAGE.TOKEN IDENTIFIER IS.TOKEN 
NEW_TOKEN expanded_n .gen_act_part. 

I PROCEDURE_ident_IS_ 

NEW_TOKEN expanded_n .gen_act_part. 

I FUNCnON_TOKEN designator IS.TOKEN 
NEW_TOKEN expanded_n .gen_act_part. ; 

Figure A-2 Example of Ada.y input file to Ayacc 
2. Coding Style 

The Automated Ada Physical Source Line Counter counts physical source lines 
of code and is based upon the SEI framework on size. [SEI-B 92] Different coding styles 
can and will result in different results. For example, lets compare a short example of the 
same code, but different writing styles. (See Figure A-3) The total number of non¬ 
comment, non-blank lines for version one would be two. However, the total for non¬ 
comment, non-blank lines for the same exact code in version two results in a total of five. 
The same code, only different coding styles. The use of a pretty printer on the Ada source 
files prior to using the Automated Ada Physical Source Line Counter will ensure consistent 
results for reports A through E. 


61 







Version One 


procedure EXAMPLE_ONE is TEMP_INT: integers 0; begin 
TEMP.INT:« TEMP_INT + 1; end EXAMPLE.ONE; 


Version Two 
procedure EXAMPLEJTWO is 
TEMP_INT: integers 0; 


TCMP_INT :s TEMP_INT + 1; 
cndEXAMPLE.TWO: 


Figure A*3 Example of two different coding styles 

C. COMMAND LINE INVOCATION 

To start the Automated Ada Physical Source Line Counter, the user must either be in 
the directory that contains the tool or have the directory containing the Automated Ada 
Physical Source Line Counter in a valid path statement In addition, the user must be 
running in an X-windows environment (operating motif for example) To invoke the tool, 
any Unix program execution method may be employed, but input and ou^ut may not be 
redirected. 

D. USER INTERFACE 

The user interface provides a window type access that is an easy-to-use method to 
request one or several pre-defined reports or to create an individualized report Each of the 
supported attributes is contained in its own panel or screen. The user interface is made up 
of eleven panels. The panels are made up of selection items, text items, text and integer 
keyin items and labels. There are three types of selection items. The types are push-button, 
checkboxes and radio buttons.Each of the panels have default settings for push-buttons, 
radio-buttons, integer keyin items and checkboxes. Each default selection is highlighted. 


62 






To change or add too the default selection, the user must use the left mouse button. Several 
of the figures are labeled one, two or three. Hie items with a one label means that those 
items are radio buttons. Items with a label two are push-buttons. Finally, the items labeled 
three are keyin items. 

1. Push-buttons 

The push-button is used to connect one panel to another. The push-buttons are 
shaped like a rectangle. (See Figure A-4) Tlie default push-button can be selected when the 
return key is pressed while the cursor is in that panel.The push-buttons for each panel are 
displayed along the bottom. Two of these push-buttons are common to each panel and will 
be discussed separately from each particular panel. The first push-button is the “(^it” 
button. The other push-button is the “Help” button. When the quit button is pressed, the quit 
panel is displayed over the top of the current panel. The quit panel gives the user the choice 
to quit the application, or to go back to the panel that they were just on. When the help 
button is pressed, a help panel with information particular to that panel will be displayed. 
When the user is finished with the help screen, the help screen will disappear and the panel 
that initiated the help screen will again be the active screen. 



|Sp<d^QBtBm Repent 

Figure A-4 Example of Push-buttons 


63 












2. Checkbozs 


The checkboxes are used whenever the user has the choice to pick iiK>re than one 
item. The checkboxes are shq)ed like a square. For example the user can pick just one 
report, say A, an or the user can pick all six reports, A through F. 

□ D; KoKMeuonnal 

□ B: FhjectTndBng □ E; hqectAnljiBlCfD) 

Q C RtajeetAiiljn DFrCtattnl^ut 

Figure A>5 Available Report Names 


3. Radio-buttons 

The radio buttons are used when the user can pick only one of the items in the 
group. The radio-buttons are shaped like a diamond. At least one item will always be 
picked. For example, if the user picks the value blank lines to be included in report F, then 
the radio button for “Includes” will be highlighted. The button for “Excludes” will change 
from highlighted to blank and vice versa. 

4. Labels and Text/Integer Keyin items 

Labels are used to identify the two types of keyin items. (See Figure A-6) The 
labels are place holders and have no action associated with them. The text keyin items will 
accept any input from the keyboard. However, if this information is the filelist, then the tool 
will terminate if a correct file is not found. The integer keyin fields are used for the setting 
of the precedence levels for report F. The precedence levels for reports A through E are 
preset and can only be changed by going into the source code and manually changing the 


64 








values. For the integer keyin fields, TAE will check to ensure that the value is within the 
prescribe range, which is from one through and including eight. However, TAE does not 
check to see if duplicate values are entered. 



Figure A*6 Text Keyin fields and labels 


E. INTRODUCTORY PANEL 

The first panel is an introduction panel The introduction panel contains the name of 
the tool, name of the author and three push-buttons displayed along the bottom. Beside the 
quit and help push-buttons, the other push-button is the “Next screen” button. The next 
screen button will make the introduction panel disappear, and bring up the second panel. 
The next screen push-button is the default push-button for the introduction panel. 

F. INPUT PANEL 

The second panel is where the user will enter the mandatory information for the tool 
to operate. The second panel contains four string keyin areas, a group of six checkboxes 
and four push-buttons. The string keyin areas are for the report name, file list, requestor 
name and output file name, respectively. The user enters the appropriate information by 
placing the cursor over the window and type in the appropriate information. Six checkboxes 
represent six different reports that can be generated by this tool. Any one or all of the 


65 








checkboxes may be selected. Report A is the default selection. In addition to the quit and 
help push-button, the second panel also has di^layed along the bottom a 'tjenerate 
Report” push-button and a “Specify Custom Report” push-button. When the genoate 
report button is pressed, the second panel will disappear and the generate report panel will 
appear on the screen. When the specify custom report push-button is selected, the second 
panel disappears, and activates the third panel. The generate report push-button is the 
default push-button for the second panel. 

G. ATTRIBUTE PANELS 

The third through the seventh panels contain the attributes of the SEI checklist, one 
attribute per panel. (See Figure A-7) (See Figure A-8) (See Figure A-9) (SceRgurcA- 
10) (See Figure A-11) There are five push-buttons on each of these panels. The first two 
push-buttons are the quit and help buttons. Another push-button is the “Previous Screen” 
push-button. When the previous screen button is pressed, the current panel disappears, and 
activates the previous panel. The next push-button is labeled “Next Screen”. When pressed, 
the current panel will disappear, activating the next panel in the sequence. The last push¬ 
button is the generate report button. When this button is pressed it will make the current 
panel disappear and activate the generate report panel. The generate report panel is the 
default button. . 

Along the top right comer in panels three through seven are two radio-buttons 
displayed, one above the other. These radio-buttons allow the user to specify that in 
addition to the individual totals, this attribute will be included in a multi-dimension array 
at the end of the normal report format. When this choice is selected, all of the attributes 
selected as such (must have at least two) will be displayed as two or three dimensional 
arrays at the end of report F. When more than three attributes are selected, then all 
combinations of N choose three will be displayed at the end of report F, where N will be 
either four or five. The otho* major part of panels three through seven are the radio-buttons 
that correspond to the values for each attribute. All of the radio-buttons arc the same, either 


66 








Custom 




Statement Type Order of Precedence 


1. Bcecutables: 

2. Nonexecutables: 

3. Declarations 

4. Compiler Directives 

5. Comments 

6. Ontheirown 

7. With Source Code 

S. Banners/non blank 


Ontheirown [Q 

With Source Code [sH 

Banners/non blank fT"! 

Blank (empty) comments [?^ 


10. Blank lines 


© 


Generate Report 


Quit application 




0 

^Inclndes ^Eiclndes 

4 Inchides 0 Eicbdes 
^Inchides ^Eichdes 

^Inchides ^Eidudos 
^Includes 4Eulades 

^Inchides ^Eidndes 
^Indodes ^Eidades 
^ Inclodes 4 Eiclndes 


Previous Screen 


Next Screen 




67 



























ClBtani 


G BHef ate PaadMumterZ 


HowIVoduced 


1. hogrammed 

1 Generated with souice code generators 

3. Converted with automated translators 

4. Copied or reused without change 

5. Modified 

6. Removed 


o 


4 Definition 
0 Data Array 


0 

4 Includes 0 Excludes 
4 Includes 4 Excludes 
4 Includes 4 Excludes 
4 Includes 4 Excludes 
4 Includes 4 Excludes 
4 Includes 4 Excludes 



Quit application 


Generate Report 


I^evious Screen 


Nea Screen 


Figure A>8 How Produced Panel 





























1. Nnr«Dik:nopiorciistenee 

2. Priomirk: taken or adapted faimi 

3. Ap«TOBTenioii,UldorKlease 

4. OommcRial off the shelf software (COTS) 

5. Govainment, famished software (GFS) 

(. Another pnAict 

7. A vendor sqipUedlaivaeesappoitlfaiaiy 

8. A vendor sopplied operating system 

9. Amodified or local langsage ept library or OS 

10. Acommeieiallihnry 

11. A reoM library (software desipied far rene) 

12. Another software component or libiary 


o 

^Definition 

^DitaArriQr 


^Inchdes 

4 Includes 0 Exdudes 
4 Includes ^ Excludes 
^Includes 0 Excludes 
4 Includes 0 Excludes 
0 Includes 4 Excludes 
0 Includes 4 Excludes 
^Includes ^Excludes 
^Includes ^ Excludes 
^Includes 0 Excludes 
^Includes 0 Excludes 



Figure A-9 Origin Panel 





























Usige 


1. In or u part of the primaiy product 

2. External to or in upport of the primary 
product 


^Defmition 
^ Data Amy 

“o 

^Includes 

0Includes ^Excludes 


Delivery Options 
^Ddivered as source 

o 

^ Delivered in compiled or ececutabie form^ but not as source 

0 Under ocmfigpration control 

0 Not under configiiration control 

0 Don't care 




Figure A-10 Usage and Delivery Options Panel 


70 

























Generation Panel Number? 


o 


Devdopment status 


1. Estimated or Planned 

2. Designed 

3. Codedj under configuration control 

4. Unit tests compided 

5. Integrated into components 

6. Test readiness revriew completed 

7. Softvirare(CSG) tests completed 

8. System tests completed 


^Udinition 

^DataAnay 


^Includes 
0 Includes 
0 Includes 

O 0 Includes 
0 Includes 
^Includes 
0 Includes 
^Includes 


^ Exdudes 
4 Excludes 
4 Excludes 
4 Excludes 
4 Excludes 
4 Excludes 
4 Excludes 
4 Excludes 



Figure A-11 Development Status Panel 

the include button is highlighted or the exclude button is highlighted. Panel three also has 
eight integer keyin windows. Each integer keyin window corresponds to one of the values 
of the attribute statement type. TAE will ensure that the precedence entered is within the 


71 
































range of one through eight. However, if the user does not ensure that each precedence value 
is unique, the results for report F may not be accurate. 

H. CLARIFICATIONS (GENERAL and Ada) PANELS 

The eight and ninth panels are for the general and Ada specific clarifications panels 
respectively. (See Figure A-12) (See Figure A-13) These two panels are similar to panel 
three, the difference being the number of radio-buttons. There are a total of thirteen general 
clarifications and six Ada specific clarifications. Each clarification is associated with one 
of the values of the attribute statement type. 

I. GENERATE REPORT PANEL 

The tenth panel is the generate report panel. (See Figure A-14) This panel has two 
push-buttons displayed along the bottom of the panel, they are labeled cancel and generate 
report. The generate report is the default button. The cancel button will make the generate 
report panel disappear. The user must then use the mouse to click on the icon of the 
previous panel. In addition to the push-buttons, this panel displays a text message 
explaining the different options available to the user 

J. QUIT PANEL 

The last panel is the quit panel. This panel also has two push-buttons displayed along 
the bottom of the panel, they are labeled quit and cancel. (See Figure A-15) The quit button 
is the default button. When the quit button is selected, the panel will disappear and the tool 
will terminate. When the cancel button is selected, the quit panel disappears leaving the 
previous panel as the active panel. In addition to the push-buttons, there is a text area that 
displays the options to the user. This is provided in lieu of a help button. 


72 






aarifications (general) 


Listed eiementi are 
asi^ed to statement type 


I. Null, continues, and no-opi 

1 Emptystmts (eg. 

3. Statements that instaniategeneria 

4. Begin, jend and (..} pain used as 
executable statements 

5. Begin..tnd and (..} pain that 
delimit (sub^irogram bodies 

6. Logical expressions used as test conditions 

7. Expression evahitionsused as 
subprogram argpments 

8. End qmbols that terminate 
executable statements 

9. End symbols that terminate 
declarations or (iub)program bodies 

10. Then, else, and otherwise i^bols 

II. Elsif statements 

12. Keywords likeproceduredivision, 
interface, and implementation 

13. Labds (branching destinations) 
on lines lythenselves 


© 


© 


4 Includes 0 Excludes 
^ Includes ^ Bedudes 
^Includes 0Excludes 

^ Includes 0 Excludes 

^Includes 0Excludes 
0Includes ^Bedudes 

0Indudes ^Excludes 

^Includes 0 Excludes 

^Includes 0Excludes 
^Includes 0 Excludes 
4 Includes 0 Excludes 

0 Indudes 4 Excludes 

4 Includes 4 Excludes 



Figure A>12 Clarifications (general) Panel 























GnentioR Panel MnlKr 



listed dements are 

GaiificatioRS (Ada specific) assipedtostatement^ 


1. End pbob that terminate 


I Blockstatements (e^, ... end) 

3. Withandusedauses 

4. When [the k^rd preceding 

necntable statements) 

5. E(ceDtionfthekeyword,usedasa 


o 

□ 

r 


o 

0 Includes 4 Udes 
0 Includes 4 deludes 
4 Includes 0B(ciudes 

4 Includes 4 Udes 

4 Includes OUdes 
4 Includes 0 Excludes 



Figure A-13 Clarifications (Ada) Panel 

















Figure A-14 Generate Report Panel 


75 
















'^ou have pressed the " Quit" button In one of the 
panels. 

Press the " Quit" bxxtton to exit the tool. 

Otherwise press die Cancel button to go back to 
the previous panel. 


Quit 


Cancel 


Figure A-15 Quit Panel 













APPENDIX B. SOURCE CODE 
ADA.Y 

%token .(‘ *)’ •*’ *+’ 7’ 

%token ‘<‘ *=’ *>* ‘I’ 

%token ARROW DOUBLE_DOT DOUBLE_STAR ASSIGNMENT INEQUALITY 
%token GREATER_THAN_OR_EQUAL LESS_THAN_OR_EQUAL 
%token LEFr_LABEL_BRACI^ RIGHT_LABEL_BRACKET 
%token BOX 

%token ABORT_TOKEN ABS_TOKEN ACCEPT.TOKEN ACCESS.TOKEN 
%token ALL_TOKEN AND.TOKEN ARRAY.TOKEN AT.TOKEN 

%token BEGIN_TOKEN BODY_TOKEN 

%token CASE.TOKEN CONSTANT.TOKEN 

%token DECLARE.TOKEN DELAY_TOKEN DELTA_TOKEN DIGITS.TOKEN DO.TOKEN 

%token ELSE_TOKEN ELSBF.TOKEN END_TOKEN ENTRY.TOKEN EXCEPTION_TOKEN 
%token EXrr.TOKEN 

%token FOR.TOKEN FUNCTION_TOKEN 

GENERIC_TOKEN GOTO.TOKEN 

%token IF_TOKEN IN.TOKEN IS_TOKEN 

%token UMTTED.TOKEN LOOP.TOKEN 

%token MOD.TOKEN 

%token NEW_TOKEN NOT.TOKEN NULL_TOKEN 

%token OF_TOKEN OR.TOKEN OTHERS.TOKEN OUT.TOKEN 

%token PACKAGE.TOKEN PRAGMA_TOKEN PRTVATE.TOKEN PROCEDURE_TOKEN 

%token RAISE.TOKEN RANGE.TOKEN RECORD.TOKEN REM.TOKEN 
RENAMES_TOKEN 

%token RETURN.TOKEN REVERSE_TOKEN 

%token SELECT_TOKEN SEPARATE_TOKEN SUBTYPE_TOKEN 

%token TASK.TOKEN TERMINATE_TOKEN THEN.TOKEN TYPE_TOKEN 





%tokenUSE_TOKEN 

%loken WHEN.TOKEN WHILE_TOKEN WTTH.TOKEN 
XOR_TOKEN 
%loken IDENTIFIER 

%token INTEGER.UTERAL REAL.LITERAL 
%loken CHARACTER.UTERAL STRING_L1TERAL 

%token ERRORl ERROR2 ERRORS ERROR4 ERRORS ERRORS ERROR? ERROR8 
%token ERROR9 ERRORIO ERRORl 1 ERROR12 ERROR13 ERROR14 ERRORl 5 

%stait compilation 

I 

subtype yystype is integer, 

} 


%% 

set_exec_statt : {FLAGS_ARRAY(STMT TYPE'val(0). 1) :=tnie; |: 
set_exec_end : {RAGS_ARRAY(STMT_TYPE’val(0), 2) ;= true;); 
set_dec_start : {FLAGS_ARRAY(STMT_TYPE’val(l), 1) := true; 

put (“ dec start “); i; 

set_dcc_end : (FLAGS_ARRAY(STMT_TYPE’val(l),2) :=tnie; 
put (“ dec end “);); 

count_last_line : {if DECLEVEL > 0 then 
DECREASE_DECLEVEL; 
end if; 
newjine; 

GLdBAL.ADD_TO_ARRAY; 

I; 


task_body_or_body_stub : 

check_lask_token_body_token_sim_n 

check_task_body_or_body_stub 


check_task_ttJcen_body_token_sim_n : 
TASK.TOKEN 
BODY.TOKEN 
set_dec_start 


78 






siin_n 

IS_TOKEN 

set_dec_end 


check_task_body_or_body_stub 

SEPARATE_TOKEN 

I 

.decl_part 


check_package_body_or_body_stub ; 
check_package_body_stub_cominon 
check_package_body_or_stub 


check_package_body_stub_comtnon : 
PACKAGE_TOKEN 
BODY_TOKEN 
set_dec_start 
sim_n 
IS.TOKEN 
set_dec_end ; 

check_package_body_or_stub : 
SEPARATE.TOKEN 
I 

.decl_part. 


" Clarifications general 


- line 1 

check_nuU_start : {if COUNT_CLARinCATION 
(GLOBALJIECORD_FLAGS_FPANEL10.LINE_1) then 

FLAGS_ARRAY (STMT.TYPE’val (0). 1) ;= TRUE; 
put (“ exec start”); 
else 
null; 

end if; ) ; 

check_null_end : {ifCOUNT_CLARIFICATION 
(GLOBALJRECORD_FLAGS_FJ>ANEL10.LINE_1) then 

FLAGS_ARRAY (STMT_TYPE’val (0), 2) := TRUE; 
put (“ exec end”); 
else 
null; 

end if; } ; 


79 







-line 2 

- Not applicable to Ada 


- line 3 

- expanded in-line 

- check_gen_inst_start 

- check_gen_inst_end 

-line4 

check_begin..end_start : 

{ if COUNT_CLARIHCATION (GLOBAL.RECORD_FLAGS_FJ>ANEL10XINE_4) then 
FLAGS.ARRAY (STMT_TYPE’val (0). 1) := TRUE; 
put C‘ exec start “)• 
else 
null; 

end if;} ; 

check_begin..end_end 

{ if COUNT.CLARinCATION (GLOBAL.RECORD_FLAGS_FPANEL10.LINE_4) then 
FLAGS_ARRAY (STMT_TYPE Val (0). 2) := TRUE; 
put C‘ exec end “); 
else 
null; 

end if;) ; 

check_end_block_slint : 

END_TOKEN check_begin..end_end ; 


-lines 

check_begin..end_delinate_stait : 

{ if CX)UNT_CLARinCATION (GLOBAL.RECORD_FLAGS_FPANEL101.INE_5) then 
FLAGS.ARRAY (STMT.TYPE’val (0), 1) ;= TRUE; 
put C‘ exec start “); 

else 

null; 

end if;) ; 

check_begin..end_delinate_end : 

{ if COUNT_CLARinCATION (GLOBAL.RECORD_FLAGS_F.PANEL10.LINE_5) then 
FLAGS_ARRAY (STMT.TYPE’val (0). 2) := TRUE; 
put C exec end “): 

else 

null; 

end if;) ; 

check_begin_stint : 

check_begin..end_delinate_start BEGIN_TOKEN check_begin..end_delinate_end ; 


- line 6 

- Not specific to Ada 


80 





-- line? 

-- Are considered part of Executable statement 

-- line 8 

check_end_exec_statement_start : 

{ if COUNT_CLARIHCATION (GLOBAL.RECORD_FLAGS_FJPANEL10iINE_8) then 
H AGS.ARRAY (STMT_TYPE*vai (0). 1) := TRUE; 
put C‘ wee start “); 
else 
null; 

end if; ) ; 

check_end_exec_statement_end : 

I if COUNT.CLARERCATION (GLOBAL.RECORD_FLAGS_FJ>ANEL10JLINE_8) then 
FLAGS_ARRAY (STMT_TYPE’val (0). 2) := TRUE; 
put C‘ exec end “): 
else 
null; 

end if;} ; 

CHECK_END_EXEC_STMT : 

END_TOKEN check_end_exec_staiement_end ; 


- line 9 

check_end_declarations_start : 

{ifCOUNT_CLARinCATION(GLOBAL.RECORD_FLAGS_FPANEL10iINE 9) then 
FLAGS.ARRAY (STMT.TYPE’val (1). 1) := TRUE; 
put C‘ dec start “); 
else 
null; 

end if; ) ; 

check_end_declarations_end : 

{ if COUNT_CLARinCATION (GLOBAL.RECORD_FLAGS_FPANEL10.LINE_9) then 
FLAGS_ARRAY (STMT_TYPE’val (1), 2) ;= TRUE; 
put (“ dec end “); 
else 
null; 

end if;} ; 

check_end_dec : 

END.TOKEN 

check_end_declarations_end 


- line 10 

- check for else, then, others on line by themselves 

- Is now tested for inside of adajex.l 


- line 11 

- check for elsif on line by itself 


81 





-- is now tested for inside of ada_lex.l 


-- line 12 

- Does not i^ply to Ada 
“line 13 

check_label_stait : 

{if COUNT^CLARfflCATlON (GLOBALJlECORD_FLAGS_FPANEL10iINE_13) then 
FLAGS_ARRAY (STMT.TYPEVal (0). 1) := TRUE; 
put C‘ exec start “); 
else 
null; 

end if;} ; 
check_label_end 

{ if COUNT_CLARinCAT10N (GLOBAL.RECORD_FLAGS_FPANEL101.1NE_13) then 
FLAGS.ARRAY (STMT_TYPE’val (0), 2) := TRUE; 
put C‘ exec end “); 
else 
null; 

end if; ) ; 


~ Ada specific clarifications 
“line 1 

" checkec in line 9 of general clarifications 
“line 2 

“ checked in line 4 of general clarification!: 

- line 3 

check_with_and_use_start : 

( if cbuNT_CLARinCATION (GLOBAL.RECORD_FLAGS_FPANELll.LINE_3) then 
FLAGS_ARRAY (STMT_TYPE’vaI (1). 1) := TRUE; 
put (“ dec start “); 
else 
null; 

end if; | ; 

check_with_and_use_end ; 

{if cbuNT_CLARinCAT10N (GLOBAL.RECORD_FLAGS_FPANELll.LINE_3) then 
FLAGS.ARRAY (STMT.TYPE’val (1). 2) := TRUE; 
put (“ dec end “); 
else 
null; 

end if; ) ; 


- line 4 

check_when_start : 

{if COUNT_CLARIHCATION (GLOBAL.RECORD_FLAGS_FPANELll.Ln^_4) then 


82 






r 


FLAGS_ARRAY (STMT_TYPE’val (0). 1) := TRUE; 
put C‘ exec start “); 
else 
null; 

end if; } ; 

check_when_end : 

{ if C0UNT_CLAR1HCATI0N (GLOBAL.RECORD_FLAGS_FPANELlll.INE_4) then 
FLAGS.ARRAY (STMT_TYPE*val (0), 2) := TRUE; 
put (“ exec end “); 
else 
null; 

end if;} ; 


check_when 

check_when_start WHEN_TOKEN check_when_end ; 


-- line 5 
- working 

check_exception_keyword_start : 

{ if COUNT_CLARinCATION (GLOBAL.RECORD_FLAGS_F.PANELlliINE_5) then 
FLAGS.ARRAY (STMT.TYPE’val (0). 1) := TRUE; 
put (“ exec start “); 
else 
null; 

end if; } ; 

check_exception_keyword_end : 

{if COUNT.CLARBFICATION (GLOBAL.RECORD_FLAGS_FPANELl liINE_5) then 
FLAGS.ARRAY (STMT.TYPE’val (0), 2) ;= TRUE; 
put (“ exec end “); 
else 
null; 

end if; } ; 


“ line 6 

check_pragnia_start : 

{if COUNT.CLARIHCATION (GLOBAL.RECORD_FLAGS_FPANELlliINE_6) then 
FLAGS.ARRAY (STMT_TYPE’val (2), 1) := TRUE; 
put (“ pragma start 
else 
null; 

end if; } ; 

check_pragma_end : 

{ if COUNT_CLARinCATION (GLOB.AL.RECORD_FLAGS_FPANELl liINE_6) then 
FLAGS_ARRAY (STMT.TYPE’val (2), 2) := TRUE; 
put (“ pragma end “); 
else 
null; 


83 







-- Ayacc grammer rules follow 


prag: check_pragma_start 
HIAGMA.TOKEN IDENTIFIER .arg_ascs 
check_pragina_cnd ; 


-prag: PRAGMA_T0KEN IDENTIFIER .arg_ascs : 


arg_asc : 
expr 

IIDENTIFIER ARROW expr ; 


-•** Added *** - 
numeric_literal 
: REAL_LITERAL 
I INTEGER_LITERAL 


basic_d : 

object_d set_dec_end 
lset_dec_start ty_d set_dec_end 
I subty_d set_dec_end 
lsubprg_d 
I pkg_d 

ltask_d set_dec_end 
I gen_d set_dec_end 
lexcptn_d set_dec_end 
I gen_inst 

I renaming_d set_dec_end 
1 number_d set_dec_end 
I error ; 


object_d : 

set_dec_start idents 
I set_dec_start idents 
I set_dec_start idents 
1 set_dec_staTt idents 


subty_ind ._ASN_expr. 

CONSTANT_TOKEN subty.ind ._ASN_expr. 
c_arr_def ._ASN_expr. 

CONSTANT.TOKEN c_arr_def ._ASN_expr. 


number_d : 





seLdec.start idents CONSTANT.TOKEN ASSIGNMENT exjw 


idents: IDENTIFIER ...idenL.; 


ty_d : 
full_ty_d 
lincomplete_ty_d 
lpriv_ty_d ; 


fuU_ty_d : 

TYPE_TOKEN IDENTIFIER IS.TOKEN ty_def 
I 

TYPE_TOKEN IDENTIFIER discr_part IS_TOKEN ty_def ; 


ty_def: 

enuin_ty_defl inte 2 er_ty_def 
lteal_ty_defl aiTay_ty_def 
liec_ty_defl access_ty_def 
lderived_ty_def; 


siibty_d : 

set_dec_start SUBTYPE.TOKEN IDENTIFIER IS.TOKEN subty.ind 


subtyjnd :ty_mk .constit; 


ty_mk : expanded_n; 


constit : 
mg_c 

Ifltg point c 1 fixed_point_c 
laggr; 


derived_ty_def: NEW_TOKEN subtyjnd; 


mg_c : RANGE_TOKENmg; 


85 






mg : 
name 

Isim.expr DOUBLE_DOT sim_expr. 


enum_ty_def : 

‘(‘ eniim_lit_spec 

...enum_lit_spec.. *)’: 


enum_lit_spec : enum_lit; 


enum_lit : IDENTIFIER I CHARACTER_LrTERAL; 


integer_ty_def: mg_c: 


real_ty_def : 
flt g p oint c I fixed_point_c; 


fltg pcnnt c : 
fltg_accuracy_def .mg_c.; 


fltg_accuracy_def : 
DIGITSjrOKEN sim_expr; 


fixed_point_c: 
fixed_accuracy_def jng_c.; 


fixed_accuracy_def : 
DELTAJTOKEN sim_expr; 


airay_ty_def 

uncnstmd_anay_defl c_aiT_def; 


uncnstmd_array_def: 


86 





ARRAY.TOKEN ‘(‘ idx_subty_def ...idx_subty_dsf.. *)’ OF.TOKEN 
subty_ind; 


c_aiT_def 

ARRAY.TOKEN idx_c OF_TOKEN subtyjnd; 


idx_subty_def name RANGE_TOKEN BOX; 


idx_c : ‘(‘ dscr_nig ...dscr_mg.. *)’; 


dscr_mg: 

mg 

Iname mg_c; 


rec_ty_def: 

RECORD_TOKEN 

cmpons 

CHECK_END_DEC RECORD.TOKEN; 


--rec_ty_def: 

-RECORD.TOKEN 
- cmpons 

-END.TOKEN RECORD.TOKEN; 


cmpons: 

..prag.. ..cmpon_d.. cmpon_d ..prag.. 
I..prag.. ..cmpon_d.. variant_part ..prag.. 
I ..prag.. NULL.TOKEN ..prag..; 


cmpon_d : set_dec_start 

idents cmpon_subty_def ._ASN_expr. set_dec_end; 


cmpon_subty_def : subtyjnd; 


discr_part : 

‘(‘ discr_spec ...discr_spec.. *)’; 


discr_spec : 


87 







idenis ty_mk ._ASN_expr.; 


variant_pait : 

CASE.TOKEN sim.ii IS_TOKEN 
..{vag.. variant ..variant. 
CHECK_END_DEC CASE_TOKEN ; 


-variant_pait : 

-CASE_TOKEN sim_n IS.TOKEN 
..{^g.. variant ..variant. 
END.TOKEN CASE.TOKEN ; 


variant : 

CHECK_WHEN choice ..or_choice.. ARROW 
cmpons; 


-variant : 

-WHEN_TOKEN choice ..or_choice.. ARROW 
- cmpons: 

choice : sim.expr 
I name mg_c 

I sim_expr DOUBLE_DOT sim_expr 
I OTHERS.TOKEN 
I error 


access_ty_def: ACXrESS_TOKEN subtyjnd; 


incomplete_ty_d : 

TYPE.TOKEN IDENTIFIER 
I 

TYPE.TOKEN IDENTIFIER discr_pait 


decl_pait : 

..basic_decljtem.. 

I ..basic_decl_item.. body ..later_decljtem..; 

basic_decl_item: 
basic_d 

liep_cl I use_cl; 


88 




later_decl_iteni; body 
lsubprg_d set_dec_end 
I pkg_d set_dec_end 
lt^_dset_dec_end 
I gen_d set_dec_end 
luse_cl 
I gen_inst ; 

body : proper_body I body_stub ; 


proper_body : 

subprg_body I irfcg_body I task_body; 


name : sim_n 

I CHARACTER_LITERAL I op_symbol 
(idxed_cmpon 

lselected_cmponI attribute; 


sim_n iIDENllhlER ; 


prefix: name ; 


idxed_cmpon : 
prefix aggr ; 


selected_cmpon : prefix selector ; 


selector : sim_n 

I CHARACIER.LITERAL I op_symbol I ALL_TOKEN 


attribute : prefix attribute_designator ; 


attribute_designator: 
sim_n 

IDIGITS.TOKEN 
IDELTA_TOKEN 
IRANGE_TOKEN ; 


aggr : 

‘(‘ cmpon_asc ...cmpon_asc.. *)’; 


89 



cmpon_asc 

exi»r 

Ichoice ..or_choicc.. ARROW expr 
Isim.expr DOUBLE_DOT siin_expr 
Iname mg_c; 


expr : 

iel..AND_rel.. I rel..AND_THEN_rel.. 
lrcl..OR_rel.. J rel..OR_ELSE_rel.. 
liel..XOR_rel.. ; 


rel : 

sim_cxpr .relal_op_sim_expr. 

lsiin_exprJ40T.IN_nig_or_siin_expr.NOT.IN_ty_mk; 


sim_expr ; 

.unary_add_op.tenn..binary_add_op_tenn..; 


term : factor..mult_op_fact«'.. ; 


factor pri._EXP_pri. lABS.TOKEN pri INOT_TOKENpri 


pri : 

numericjiteial I NULL_TOKEN 
lallocato' I qualifled_expr 
Iname 
laggr; 


relal_op : *=’ 

I INEQUALITY 
I ‘<‘ 

I LESS_THAN_OR_EQUAL 
I *>’ 

I GREATER_THAN_OR_EQUAL ; 


binary_add_op : *+’ I I *&’; 


unary_add_op : *+’ I ; 


90 






inuU_op ; •*’ I T I MOD_TOKEN I REM.TOKEN ; 


qualified_expn 

ty_inkaggr_or_ty_mkPexprP_; 


allocator : 

NEW_TOKENty_ink 
INEW.TOKEN ty_mk aggr 
I NEW_TOKEN ty_mk aggr ; 


seq_of_stmts; ..prag.. stmt ..stmt.. { null;} -- Because of bug 


stmt : 

..label.. sim_stmt 
I ..label.. compound_stmt 
I error ; 


"Stmt : 

"..label.. sim_stmt 
- I ..label. compound_stmt 
" I error ; 


sim_stmt :null_stmt 

lset_exec_start assignment_stmt set_exec_end 
I set_exec_start exit_simt set_exec_end 

lset_exec_start retum_stmt set_exec_end 
I set_exec_start goto_stmt set_exec_end 

lset_exec_start delay_stmt set_exec_end 
I set_exec_start abort_stmt set_exec_end 

lset_exec_start raise_stmt set_exec_end 
I set_exec_start code_stmt set_exec_end 

I set_exec_start name set_exec_end ; 


--sim_stmt :null_stmt 

— Iassignment_stmt I exit_stmt 

~ lretum_stmt I goto_stmt 

- Idelay_stmt I abort_stmt 
-- lraise_stmt I code_stmt 
-- I name ; 


91 





compotiiK]_stmt : 
set_exec_siait if_stnit 
I set_excc_start case_stint 
lsct_exec_start loop_stmt 
I set.exec.start block_stmt 
lset_exec_start accq>t_stint set_exec_end 
lset_exec_start select_stmt set_exec_end ; 


"Compound.stmt : 

-- I case_stim 

- Doop_stmt 

- I block.stmt 

- laccept.stmt 
-- iselect_stmt ; 


label : 

check_label_stail 

LEFT_LABEL_BRACKET siin_n RIGHT_LABEL_BRACKET 
check_label_end 


null_stmt : clieck_null_start NULL_TOKEN check_null_end ; 


- nuU.stmt : NULL_TOKEN ; 


assignment.stmt : name ASSIGNMENT expr ; 


if_stmt : 

IF.TOKEN cond THEN.TOKEN 
seq_of_stmts 

..ELSIF cond THE N s eq of stmts.. 
£LSE__seq_of_stmts. 

CHECK_END_EXEC_STMT IF_TOKEN ; 


--if_stmt : 

-IF_TOKEN cond THEN_TOKEN 
- seq_of_simts 

--..ELSIF_^cond_THEN_seq_of_stmts.. 

“ £LSE__seq_of_stmts. 

END_TOKEN IF.TOKEN ; 





cond : expr; 


case_stmL' 

CASE_TOKEN expr IS_TOKEN 
case_stint_alt.case_stmt_alL. 
CHECK_END_EXEC_STMT CASE.TOKEN ; 

“Case_stnit: 

-CASE_TOKEN expr IS_TOKEN 
- case_stint_alL.case_stint_alL. 

END_TOKEN CASE_TOKEN : 


case_stmt_alt : 

CHECK_WHEN choice ..or_choice.. ARROW 
seq_of_sonts; 


-case_stint_alt : 

-WHEN_TOKEN choice ..or_choice.. ARROW 
-- seq_of_stints; 


loop_stint: 

.siin_nC. 

.iteration_scheme. LOOP_TOKEN 
seq_of_stmts 

CHECK_END_EXEC_STMT LOOPJTOKEN .sim 

“loop_stmt 

--.sim_nC. 

— .iteration_scheme. LOOP_TOKEN 
seq_of_stmts 

END_TOKEN LOOP_TOKEN .sim.n.; 


iteration_scheine 
: WHILE.TOKEN cond 
IWHILE_TOKENenor 
I FOR_TOKEN loop_pnn_spec 
IFOR_TOKENerror 


loop_prm_spec : 

IDENTIFIER IN.TOKEN JIEVERSE. dscr_mg ; 


93 



bIock_siint : 

^iin_nC. 

J)ECLARE_declj>ait. 

check_begin..aul_start 

BEGIN.TOKEN 

check_begin..end_start 

scqj)f_stints 

£XCEFnON_exq)ln_handler..excpln_handJer.. 
check_cnd_Wock_stint .siin_n. ; 

-block_stint : 

--.sim_nC. 

~ J5ECLARE_decljpart. 

- BEGIN.TOKEN 
seq_of_stints 

-- EXCEPTION_^excptn_handler..excptn_handler.. 

END_TOKEN .siin_n. ; 


exit_stint; 

EXIT_TOKEN .expanded_n. .WHEN_cond. 


retuni_stint : RETURN_TOKEN .expr. ; 


goto_stmt ; GOTOJTOKEN expanded_n ; 


subprg_d : subprg_spec ; 

procedurejdent: 
set_dec_start 

PROCEDURE_TOKEN IDENTIFIER ; 

fiinction.desig: 
set_dec_start 

FlJNCnON_TOKEN designator ; 

--function_desig: 

--set_dec_start 

“FUNCnONJTOKEN designator set_dec_end ; 


94 






subprg^spec : 

procedure.ident .finl_pan. set_dec_end 

I fiinction_desig .finljpart. RETLIRN_TOKEN ty_ink set_dec_end; 


designator : IDENTIFIER I op_symbol ; 


op_symbol : STRING_LrTERAL ; 


fml jpart ; 

‘(‘ pnn_spec .._.pnn_spec.. *)’: 


pnn_spec : 

idents mode ty_ink ._ASN_expr. ; 


mode : JN. I IN_TOKEN OUT.TOKEN I OUT.TOKEN ; 


subprg_body ; 
subprg_spec IS_TOKEN 
.decl_parL 

check_begin..end_delinate_start 

BEGIN.TOKEN 

check_begin..end_<feUnate_end 

seq_of_stmts 

£XCEPnON_excptn_handler..excptn_handler... 
check_begin ..end_delinate_start 
END_TOKEN .designatOT. 
check_begin..end_delinate_end 


-subprg_body ; 

“Subprg_spec IS_TOKEN 
~ .decl_part 
-BEGIN_TOKEN 
“ seq_of_stmts 

-£XCEPnON_excptn_handler..excpm_handler... 
END_TOKEN .designator. ; 


pkg_d : pkg_spec ; 

packagejdent : 

PACKAGE_TOKEN 

IDENTIFIER 


95 






IS_TOKEN 


set_dec start_end : 

{ FLAGS_ARRAY(STMT_TYPE’val(l), 1) := true; 
put (“ dec start pkg “); 

FLAGS_ARRAY(STMT_TYPE’val(l). 2) := true; 
put (“ dec end pkg “); 

} 


—checkjpk£_declaration : 

package_ident 

set_dec_start_end 

IsriOKEN 


check_pkg_declaration ; 

PACKAGE_TOKEN 

IDENTIFIER 

set_dec_start 

IS_TOKEN 

set_dec_end 


pkg_spec : 

check_pkg_declaration 
..basic.decljtem.. 
PRIVATE..basic_declJtein... 
check_end_decIarations_start 
check_end_dec 
.sim n. 


-pkg_spec : 

PACKAGE_TOKEN 
-IDENTIFIER IS.TOKEN 

- ..basic_decl_iteni.. 

- PRTV ATE. .basic_decljtem. 
-ENDJTOKEN .siin_n. ; 


pkg_body ; 

check_package_body_OT_body_stub 

.BEGIN_seq_of_stmts.EXCEPTION_excptn_handler. .excptn_handler... 
check_begin..end_delinate_start 
END.TOKEN .sim.n. 
check_begin..end_delinate_end 


96 




-pkg_body : 

-PACKAGE.TOKEN BODY_TOKEN sim_n IS.TOKEN 
“ .decl_pait 

— JBEGIN_seq_of_stints£XCEPnON_excptn_handler..excptn_handler... 
-END.TOKEN .sim_n. ; 


priv_ty_d : 

TYPE.TOKEN IDENTIFIER IS_TOKEN ilMITED. PRIVATE.TOKEN 
I 

TYPE.TOKEN IDENTIFIER discr_part IS_TOKEN .LIMITED. PRIVATE.TOKEN 


use_cl : check_with_and_use_start 

USE_TOKEN expanded_n ...expanded_n.. 
check_with_and_use_end ; 


“renaining_d ; 

set_dec_start idents ty_mk RENAMES_TOKEN name 

- I set_dec_start idents EXCEPTION.TOKEN RENAMES.TOKEN expanded.n ‘ 

- 1 packagejdent RENAMES_TOKEN expanded_n 

- I subprg_spec RENAMES_TOKEN name ; 


renaming_d : 

set_dec_start idents ‘: ’ ty_mk RENAMES_TOKEN name ‘; ’ 

I set.dec.start idents EXCEPTION_TOKEN RENAMES.TOKEN expanded_n 
I PACKAGE.TOKEN IDENTIFIER RENAMES.TOK^ expanded.n 

I subprg_spec RENAMES_TOKEN name ; 


task_d : task_spec‘;’ ; 


task_spec ; 

TASK.TOKEN set_dec_start .TYPE. IDENTIFIER 
.IS.,ent_d_.jep_cl_END.sim_n. ; 


task_body : 

task_body_or_body_stub 
CHECK_BEGIN_STMT seq_of_stmts 
£XCEPTION_excptn_handler..excptn_handler... 
check_begin..end_delinate_start 
END.TOKEN .sim_n. 
check_begin..end_delinate_end ; 


97 








-task_body : 

-TASK.TOKEN BODY_TOKEN sim.n IS.TOKEN 
“ .decl_part. 

--BEGIN_TOKEN 
- seq_of_stints 

-JSXCEPnON_exq)tn_handler..excpm_handJer... 
END.TOKEN .siin_n. ; 


ent_d : 

set_dec_start ENTRY_TOKEN IDENTIFIER .fml_part. set_dec_end 
I ^t_dec_start ENTRY_TOKEN IDEhJTEFIER ‘(‘ dscr.mg *)’ .fml^pait ‘ 
set_dec_end ; 


ent_call_stint : 

..prag.. name ; 


accept_stmt : 

ACCEPT_T0KEN sim_n .Pent_idx_P..fml_part. 
.DO_se(i_of_stmts_END.sim_n.. ; 


entjdx :expr ; 


delay_sunt : DELAY_TOKEN sim_expr ; 


select_stmt :sclec_wait 
lcondal_ent_calll timed_ent_call ; 


selec_wait; 

SELECT_TOKEN 

select_all 

..OR_select_alt. 

•ELSE_seq_of_stmts. 

END.TOKEN SELECT_TOKEN : 


--selec_wait: 

-SELECT_TOKEN 
- select_alt 
-- ..OR_sclect_alL. 

“ £LSE_^seq_of_stmts. 

END.TOKEN SELECT_TOKEN ; 


98 






F 


select_alt : 

.WHEN_condARROW.selec_wait_aIt ; 


selec_wait_alt : accept_alt 
ldelay_alt I tertninate_alt ; 


accept_alt : 

accept_stint.seq_of_stmts. ; 


delay_alt : 

delay_stint.seq_of_stints. ; 


terminate.alt : TERM.stmt ; 


condal_ent_call: 

SELECT_TOKEN 

ent_call_stint 

.seq„of_stmts. 

ELSE.TOKEN 

seq_of_stints 

END.TOKEN SELECT.TOKEN 


-condal_ent_call: 

-SELECr_TOKEN 

- ent_call_stint 

- .seq_of_stnits. 

-ELSE_TOKEN 
~ seq_of_stnits 

END_TOKEN SELECT.TOKEN 


timed_ent_call : 

SELECT.TOKEN 

ent_call_stmt 

.seq_of_stmts. 

OR.TOKEN 

delay_alt 

END_TOKEN SELECT_TOKEN ; 


-timed_ent_call : 
-SELECT TOKEN 






- ent_call_slint 

- .seq_of_stmts. 

-OR_TOKEN 

“ delay_alt 

END.TOKEN SELECT.TOKEN ; 


abort.stmt : ABORT_TOKEN name ...name.. ; 


compilation ;..compilation_unit.. count_last_line ; 


-compilation :..compilation_unit.. ; 


compiladon.unit : 
context_cl library_unit 
I context_cl secondary_unit; 

library_unit : 
subprg_dl pkg_d 
I gen_dl gen_inst 
lsul^g_body ; 


secondaty_unit; 
library_unit_body I subunit; 


library_unit_body ; 
pkg_body_or_subprg_body ; 


contextjcl : ..with_cl..use_cl....; 

with_cl : check_with_and_use_start 

WITH_TOKEN sim_n ...sim_n.. 
check_with_and_use_end ; 


—with_cl : set_dec_start WITH_TOKEN sim_n ...sim_n.. set_dec_end 


body_stub : 

subprg_spec IS_TOKEN SEPARATE_TOKEN 
I check_package_body_or_body_stub set_dec_end 
I task_body_or_body_stub set_dec_end 


100 





"body_stub : 

subprg_spec IS.TOKEN SEPARATE.TOKEN 
-- I PACKAGE_TOKEN BODY.TOKEN sim.n IS_TOKEN SEPARATE_TOKEN ' 
- I TASK_TOKENBODY_TOKENsiin_n IS_TOKEN SEPARATE_TOKEN 


subunit : SEPARATE_TOKEN ‘(‘ expanded_n *)’ prc^r_body ; 


excptn_d : set_dec_start idents EXCEPTION_TOKEN ; 


cxcptn_handlen 

CHECK_WHEN excptn_choice ..or_excptn_choice.. ARROW 
seq_of_stints ; 

"excptn_handler 

"WHEN_TOKEN excptn_choice ..or_excptn_choice.. ARROW 
seq_of_stmts ; 


excptn_choice : expanded_n IOTHERS_TOKEN; 
raise_stmt : RAISE_TOKEN .expanded_n. ; 
gen_d : gen_spec ; 


gen_spec ; 

gen_fml_part subprg_spec 
lgen_fnil_part pkg_spec ; 


~gen_spec : 

-gen_fml_part subprg_spec 
- Igen_fml_part pkg_spec ; 


gen_fml_part :set_dec_start GENERICJTOKEN set_dec_end ..gen_pnn_d.. ; 


"gcn_fntl_part : GENERIC_TOKEN ..gen_pnn_d.. ; 


101 





gen_pnn_d : 
set_dec_stait 

idents .IN.OUT.. ty_mk ._ASN_expr. 
set_dec_end 
I set_dec_start 

TYPE.TOKEN IDENTIFIER IS_TOKEN gen_ty_def 
set_dec_end 
lset_dec_siait 
priv_ty_d 
set_dec_end 

I WITH_TOKEN subprg_spec .IS_BOX_. *;* 


--gen_pnn_d : 

-idents JN.OUT.. ty_ink ._ASN_expr. 

- I TYPE.TOKEN IDENTIFIER IS.TOKEN gen_ty_def 

- fpriv_ty_d 

- I WITH_TOKENsubprg_spec.IS_BOX_.‘;’; 


gen_ty_dcf : 

‘(‘ BOX 

I RANGE_TOKEN BOX 
I DIGITS.TOKEN BOX 
I DELTA_TOKENBOX 
I aiTay_ty_def 
I access_0'_d6f 


check_pkg_inst_declaration : 

PACKAGE.TOKEN 

IDENTIFIER 

set_dec_start 

IS_TOKEN 

NEW.TOKEN 


gcnjnst : 

check_pkg_inst_declaration 

i if COUNT.CLARfflCATION (GLOBAL.RECORD_FLAGS_FPANEL10JLINE_3) then 
FLAGS.ARRAY (STMT.TYPE’val (1), 1) := TRUE; 
put (“ dec start “); 
else 
null; 
end if;} 
expanded.n 
.gen_act_part 


102 




i ifCOUNT_CLARIFICAnON(GLOBAL.RECORD_FLAGS FPANEL10iINE_3) then 
FLAGS.ARRAY (STMT.TYPE’val (1). 2) ;= TRUE; 
put (“ dec end “); 
else 
null; 
end if;} 

IPROCEDURE_ident_lS_ 

{if COUNT.CLARIFICATION (GLOBAL.RECORD_FLAGS_FPANEL10JLINE_3) then 
FLAGS_ARRAY (STMT_TYPE’val (1). 1) := TRUE; 
put (" dec start “): 
else 
null; 
end if;) 

NEW_TOKEN expanded_n .gen_act_part. 

(ifCOUNT_CLARIFICATION (GLOBAL.RECORD_FLAGS_FPANEL10XINE_3) then 
FLAGS_ARRAY (STMT_TYPE’val (1). 2) ;= TRUE; 
put (“ dec end “); 
else 
null; 
end if; | 

lfunction_desig IS_TOKEN 

{ if COUNT.CLARIFICATION (GLOBAL.RECORD_FLAGS_FPANEL10J-INE_3) then 
FLAGS.ARRAY (STMT_TYPE’val (1). 1) := TRUE; 
put (“ dec start “); 
else 
null; 
end if;) 

NEW_TOK^ expanded.n .gen_act_part 

{ifCOUNT_CLARIFICATlbN(GLOBAL.RECORD_FLAGS FPANELlOilNEJ) then 
FLAGS.ARRAY (STMT.TYPE’val (1), 2) ;= TRUE; 
put (“ dec end “); 
else 
null; 
end if;) 


gen_act_part ; 

set_dec_start 
‘(‘ gen_asc ...gen_asc.. *)’ 
set_dec_end 


"gen_actjpart ; 

‘(‘ gen_asc ...gen_asc.. *)’ 


gen_asc 

.gen_fitnl_prmARROW.gen_act_pnn; 


103 





gen_finl_pnn : 
siin_n I <q)_symbol ; 

gcn_act_pnn : 

cxi»_or_name_or_subprg_n_OT_ent_n_or_ty_ink 


rep_cl : 

ty_rep_cl I addiess.cl ; 

ty_rep_cl : length_cl 
lenuin_rq)_cl 
lrec_rep_cl ; 


length_cl : FOR_TOKEN attribute USE_TOKEN siiii_cxiw; 


enum_rep_cl : 

FOIL_ty_siin_n_^USE_ aggr ; 


rec_rq)_cl: 

FOR_ty_sim_n_USE_ 

RECORD.TOKEN .algt_cl. 

..cinpon_cl.. 

CHECK_END_DEC RECORD_TOKEN‘/ ; 


-rec_rep_cl: 

“FOR_ty_siin_n_USE_ 

- RECORD.TOKEN .algt_cl. 

„cmpon_cl.. 

END_TOKEN RECX)RD_TOKEN ; 


algt_cl : AT_TOKEN MOD_TOKEN sim_expr ; 
cmpon_cl : 

name AT_TOKEN sim.expr RANGE.TOKEN mg ; 
address_cl : FOR.TOKEN sim_n USE.TOKEN AT.TOKEN sim.expr 


code_stmt ; ty_mk_rec_aggr ; 


104 



..I»ag.. : 
l..prag..prag ; 

^g_ascs: 

I ‘C arg_ascs *)’; 

aig_ascs: 
arg_asc 

I arg_ascs arg_asc; 

._ASN_expr.: 
lASSIGNMENTexpr ; 

...idem.. ; 

I ...idem.. IDENTIFIER ; 

.constrt. : 

Iconstrt ; 


expanded_n : 

IDENTIFIER 

I expanded_n IDENTIFIER ; 


...enum_Iit_spec..: 

I ...enum_lit_spec.. 
enum_lit_spec; 

jng_c. : 
lnig_c; 

...idx_subty_def.. : 

I ...idx_subty_def.. idx_subty_def 


,..dscr_mg..: 

I ...dscr_mg.. dscr_mg ; 


,.cmpon_d..: 

I ..cmpon_d.. cmpon_d ..prag.. ; 
...discr_spec..: 

I ...discr_spec.. discr_spec ; 


..variant.. : 


105 








I..variaiit.. variant ; 


,or_choice..: 

I ..or_choice.. ‘I’ choice ; 


.l)asic_dccljtcfn.. 

..prag.. 

l..basic_decLitein.. basic_decl_item ..prag..; 

•laier_decl_itein.. 

..prag.. 

I ..latcr_decl_item.. Iater_decl_item ..prag.. ; 


..cmpon_asc.. 

I ...cmpon.asc.. cmpon_asc; 


rel..AND_reI.. 
rclAND.TOKENrel 
lrel..AND_rel.. AND_TOKEN tel; 


rel..OR_rel..: 
lelOR.TOKENrel 
lrel.OR_reI.. OR.TOKEN rel; 


rel..XOR_rel., : 
rel 

I.JCOR_rel.. ; 


,.XOR_rel.. : 
rel XOR_TOKEN rel 
I..XOR_rel.. XOR.TOKEN rel; 


rel..AND_THEN_rel.. : 
rel AND.TOKEN THEN_TOKEN rel 
lrel..AND_THEN_rel.. AND_TOKEN THEN_TOKEN rel 


rcl..OR_ELSE_^rel..; 

rel OR.TOKEN ELSE.TOKEN rel 
lrel..OR_ELSE_rel.. OR.TOKEN ELSE_TOKEN rel ; 


100 




jelaLop_siin_expr. : 

lrelal_op siin_expr ; 


sim_exprJ40T.IN_mg_(»’_siin_expr.NOT.IN_ty_mk; 

sim_expr .NOT. IN_TOKEN mg ; 


i-IOT. : 

INOT.TOKEN ; 

.unary_add_op.tenn..binary_add_op_term.. : 
term 

lunary_add_op term 

l.unary_add_op.term..binary_add_op_term.. 
binary_add_op term ; 

factor..mult_op_factor..: 

factor 

lfactor..mult_op_factor.. mult_op factor; 

■ EX P p ri. ; 

IDOUBLE_STARpri; 


ty_inkaggr_or_ty_mkPexprP_ : 
prefix aggr; 


..stmt.. : 

..prag.. 

I..stmt. stmt ..prag..; 


..label.. : 
(..label., label ; 


..ELSIF_^cond_THEN_seq_of_stmts.. : 

l.£LSIF_^c(Mid_THEN_seq_of_stmts.. 

ELSIF.TOKEN cond THEN_TOKEN 
seq_of_stmts ; 

£LSE_seq_of_stmts.: 

IELSE_TOKEN 
seq_of_stmts ; 

case_stmt_alt..case_stmt_alt.: 

..prag.. 


107 






casc_stmt_alt 
..casc_stint_alt. ; 

..case.jStint_ali..: 
l.xase_stmt_alL. case_stint_alt; 

.siin_nC.: 

I siin_n ; 

^iin_n.: 
lsim_n ; 

.iteration_scheine. : 
titeradon.scheme ; 

AVERSE.: 

IREVERSE.TOKEN ; 

X)ECLARE_decl_parL 
lset_exec_start DECLARE_TOKEN 
<lecljpartset_exec_end; 

£XCEPnON_excptn_handler..excptn_handler,.. : 
lcheck_exception_keyword_start 
EXCEPTION.TOKEN 
chcck_exception_keyword_end 
..prag.. excptn_handlers set_exec_end ; 


~£XQEPnON _^exq)tn_handler..excptn_handler... 

- EXCEPnON_TOKEN ..prag.. excptn_han<ilers set_exec_end 


excptn_handlers; 

excptn_handler 

lexcptn_handlers excptn_handler ; 

.expanded_n. : 
lexpanded.n ; 

.WHEN_cond. : 

ICHECK_WHEN cond; 


-.WHEN_cond. : 

- IWHEN.TOKEN cond; 


lOh 





.expr.: 
lexpr ; 


.fml_part. : 
lfinl_part ; 

.._.pnn_spec.. : 

I .._.pnn_spec.. pnn_spec ; 
.IN. : 

IIN.TOKEN ; 

.decl_part. ; decl_part; 


.designator. : 

I designator ; 


i*RIVATE..basic_declJteni...: 
lset_dec_start 

PRIVATE.TOKEN 
set_dec_end 
..basic.decljtetn..; 


-J’RIVATE..basic_decl_item...: 

- I PRIVATE_TOKEN 

- ..basic_decl_item..; 


.BEGIN seq of sttnts.EXCEPnON_^excptn_handler..excpin_handler... 

Icheck_begin_stmt 

seq_of_stmts 

£XCEPnON_excptn_handler..excptn_hand]er... ; 


-.BEGIN_seq_of_stmts£XCEPnON_^excptn_handler..excptn_handler... 

- IBEGIN_TOKEN 
seq_of_stmts 

-JEXCEPnON_excptn_handler..exq)tn_handler... ; 


ilMITCD. ; 
ILIMTIED.TOKEN ; 


109 






...expanded_n..: 

I ...expanded_n.. expanded_n ; 


.TYPE.: 

ITYPE_TOKEN ; 

JS..ent_d_..rcp_cLENI> sim_n. : 
IIS.TOKEN 
..ent_d.. 

..tep_cl.. 

END.TOKEN .sim_n. ; 


..ent_d.. : 

..prag.. 

I..ent_d.. ent_d ..ptag..; 
..rep_cl.. : 

l.jep_cl.. rep_cl ..prag..; 


PentJdx_P..fml_part. : 

.ftnl_part. 

I ‘(‘ entjdx *)’ .fml_part. ; 

JXD_seq_of_stints_END.sim_n.. : 
IDO.TOKEN 
seq_of_stinis 

END.TOKEN .sim.n. ; 


--.DO_seq_of_stints_END.siin_n.. ; 
- IDO_TOKEN 
“ seq_of_stmts 
—END_TOKEN .sini_n. ; 


..OR_select_alt.. : 

I..OR_select_alt. OR_TOKEN select_alt; 


.WHEN_condARROW.selec_wait_alt : 
selec_wait_alt 

ICHECK_WHEN cond ARROW selec_wait_alt 


“.WHEN_condARROW.selec_wait_alt : 

—selec_wait_alt 

- IWHEN_TOKEN cond ARROW selec_wait,alt 


no 



accept_stmt.seq_of_stmts. : 

..prag.. accept_stmt .seq_of_stmts. ; 


delay_stint.seq_of_stmts. : 

..prag.. delay_stint .seq_of_stints.; 


TERM.stmt : ..prag.. TERMINATE.TOKEN 
..prag.. ; 


~TERM_stmt : ..prag.. set_exec_start TERMINATE_TOKEN ‘ 
..prag.. set_exec_end ; 


.seq_of_stints.: 

..prag.. 

lseq_of_stmts; 


..name..: 

I ...name.. name ; 


,compilaiion_unit.. ; 

..prag.. 

l..compilation_unit.. compilation_unit ..prag..; 


pkg_body_or_subprg_body : pkg_bcxly ; 


,with_cl..use_cl....: 
l..with_cl..use_cl.... with_cl use_cls; 


use_cls : 

..prag.. 

Iuse_cls use_cl ..prag.. : 


,.sim_n.. : 

I ...sim_n..sim_n ; 


.or_excptn_choice..: 

I ..or_excptn_choice.. ‘I’ excptn.choice; 


111 




..gen_prm_d.. : 
l..gen_pnn_d.. gen_prm_d; 

JN.OUT.. : 

JN. 

IIN_TOKEN OUTjrOKEN; 

JS_BOX_.: 

IIS_TOKENname 
IB.TOKEN BOX; 

PROCEDURE_^ident_IS_ : subprg_spec IS_TOKEN ; 


.gen_act_part. : 
lgen_act_part; 


,.gen_asc..: 

I ...gen_asc.. gen_asc; 


-.gen_finl_pnnARROW.gen_act_pnn : 

set_dec_start 

gen_act_pnn 

set_dec_end 

I 

set_dec_start 

gen_finl_prm ARROW gen_act_prm 
set_dec_end 


.gen_fmljpnnARROW.gen_act_pnn : 
gen_act_pnn 

lgen_finl_pnn ARROW gen_act_pnn ; 


expr_or_name_or_subprg_n_or_ent_n_or_ty_ink 
: expr ; 


FOR_ty_siin_n_USE_ ; 
FOR.TOKEN sim_n USE.TOKEN; 


^gt_cl. ; 
..prag.. 


112 







I ..jwag.. algt_cl ..prag.. ; 


..cmpon_cl.. : 

I ..cmponjcl.. cmpon_cl ..prag.. ; 
ty_mk_rec_aggr : qualified_expr ; 


%% 


package parser is 

procedure yyparse; 

echo: boolean := false; 
nuinber_of_errors: natural ;= 0; 


end parser, 

with ada_tokens, ada_goto, ada_shift_reduce, adajex, textjo, GLOBAL; 
use ada_tokens, ada_goto, ada_shift_reduce, adajex. textjo, GLOBAL; 
package body parser is 

procedure yyerrorfs: in string := “syntax error”) is 
begin 

nuinber_of_errors := nuinber_of_eiTors + 1 ; 
put(“«< •** “); 
put_line(s); 
end yyerror; 


##%procedure_parse 
end parser. 


113 






ADA LEX.L 







—/* Lexical input for LEX for LALR(l) Grammar for ANSI Ada 


../* V 

-/* Herman Fischer */ 

-/• Litton Data Systems */ 

-/* March 26,1984 */ 

*/ 

Accompanies Public Domain YACC format Ada grammar 

V 

-f* */ 

-r */ 

-/* */ 

--/* */ 

-r V 

-r */ 


V 


V 


%STARTIDENTZ 


A 

[aA] 

B 

[bB] 

C 

[cC] 

D 

[dD] 

E 

[eE] 

F 

[IF} 

G 

[gG] 

H 

[hH] 

I 

[in 

J 

m 

K 

[kK] 

L 

[IL] 

M 

[mM] 

N 

[nN] 

0 

[oO] 

P 

[pP] 

Q 

[qQ] 

R 

[rR] 

S 

[sS] 

T 

[tn 

U 

[uU] 

V 

[vV] 

W 

[wW] 

X 

[xX] 

Y 

[yY] 

Z 

[ZZ] 


%% 


114 






{AHBHOHR) {T) {ECHO; ENTER(Z); retum(ABORT_TOKEN);} 

I A) {B} IS) {ECHO; ENTER(Z); retum(ABS_TOKEN);) 

{AHC)|C}{E){P){T) {ECHO; ENTER(Z); retuni(ACCEPT_TOKEN);} 

{A} {C| {CHEHS) {S) {ECHO; ENTER(Z); tetum(ACCESS_TOKEN);) 

{ AHL HL J {ECHO; ENTER(Z); retun\(ALL_TOKEN); { 

{A){N}{D} {ECHO;ENTER(Z);retum(AND_TOKEN);} 

{A} {R) {R} {A) {Y} {ECHO; ENTER(Z); retiim(ARRAY_TOKEN);) 

{A} {T) {ECHO; ENTER(Z); retun»(AT_TOKEN):) 

{B){E}{G}{I){N) {ECHO; ENTER(Z); ietum(BEGIN_TOKEN);} 

{B){0){D){Y} {ECHO; ENTER(Z); relum(BODY_TOKEN);) 

{C){A){S}{E) {ECHO; ENTER(Z); fetum(CASE_TOKEN):} 

{C} {0){N} {S) {Tl {A) {N) {T) {ECHO; ENTER(Z); retiim(CONSTANT_TOKEN);} 

{D){E}{C}{L}{A){R}{E} {ECHO; ENTER(Z); retum(DECLARE_TOKEN):} 

{D) {E) {L} {A) {Y) {ECHO; ENTER(Z); retuni(DELAY_TOKEN);) 

{D1 {E) {L) {T) {A} {ECHO; ENTER(Z); retum(DELTA_TOKEN);) 

{D) {1} {G}{I} {T} {S} {ECHO; ENTER(Z); retum(DlGrrS_TOKEN);) 

{D}{0} {ECHO;ENTER(Z);rctum(DO_TOKEN):) 

{E}{L}{S}{E} {ECHO;ENTER(Z);retiim(iLSE TOKEN);) 

{E) {L) {S) {1} {F) {ECHO; ENTER(Z); tetum(ELSff_TOKEN);} 

{E} {N} {D) {ECHO; ENTER(Z); retum(END_TOKEN);} 

{E} {N| {T} {R} {Y) {ECHO; ENTER(Z); retum(ENTRY_TOKEN);} 

{E) {X} {C) {E} {P) {T} {1} {0} {N) {ECHO; ENTER(Z); retuni(EXCEPnON_TOKEN);) 
{E){X){I}{T} {ECHO;ENTER(Z);retum(EXIT TOKEN);) 

{F} {0) {R) {ECHO; ENTER(Z); rctuni(FOR_TOKEN);} 

{F){U){N){C}{T){I}{0){N) {ECHO;ENTER(Z);retiim(FUNCTION_TOKEN);) 

{G){E}{N){£){R){I){C) {ECHO;ENTER(Z);retum(GENERIC_TOKEN);) 

{G) {O) {T) {O) {ECHO; ENTER(Z); retum(GOTO TOKEN);) 

{!) {F) {ECHO; ENTER(Z); retum(IF_TOKEN);) 

{1} {N) {ECHO; ENTERCZ); retum(IN_TOKEN);) 

{I){S) {ECHO;ENTER(Z);retiimaS_TOKEN);) 

{L) {!) {M) {1} {T) {E) {D) {ECHO; ENTER{Z); rctum(LIMITED_TOKEN);) 

{L) {0} {O) {P) {ECHO; ENTER(Z); retum(LOOP_TOKEN);} 

{M){0){D} {ECHO; ENTER(Z);return(MOD TOKEN);) 

{N){E}{W) {ECHO;ENTER(Z);retum(NEW_TOKEN);) 

{N) {O) {T) {ECHO; ENTER(Z); retum(NOT_TOKEN);) 

{N) {U) {L} {L} {ECHO; ENTER(Z); retum(NULL TOKEN);} 

{ 0 ){F) {ECHO;ENTER(Z);rctum(OF_TOKEN);) 

{0)1R) {ECHO;ENTER(Z);retum(OR_TOKEN);) 

{0} {T} {H) {E} {R} {S) {ECHO; ENTER(Z); retum(OTHERS_TOKEN);) 

{O) {U} {T) {ECHO; ENTER(Z); retunj(OUT_TOKEN);) 

{P){A){C){K) 1 A! (G){E) {ECHO; ENTER(Z);retiim(PACKAGE_TOKEN);) 

{P) {R} {A) {Gj {Mi; A) {ECHO; ENTER(Z); retum(PRAGMA_TOKEN);) 

{P) {R) {1} {V) {A) {T) {E) {ECHO; ENTER(Z); retum(PRIVATE_TOKEN);) 
{P){R}{0){C){E){D){U){R}{E) {ECHO;ENTER(Z);retuni(PROCEDURE TOKEN);} 
{R} {A} {1} {S} {E} {ECHO; ENTER(Z); rctuni(RAISE_TOKEN);} 

{R} {A} {N} {G} {E} {ECHO; ENTER(Z); retuni(RANGE_TOKEN);} 

{R}{E}{C}{0}{R){D} {ECHO;ENTER(Z);rctiim(RECORD TOKEN);} 

{R} {E} {M} {ECHO; ENTER(Z); retum{REM_TOKEN);] 

{R}{E}{N}{A){M}{E){S} {ECHO;ENTER(Z); return(RENAMES_TOKEN);) 

{R} {E) {T} {U} {R) {N) {ECHO; ENTER(Z); retuni(RETURN_TOKEN);} 

{R}{E){V){E}{R){S){E} {ECHO;ENTER(Z); retum(REVERSE_TOKEN);} 


115 






|S){E}{L){E){C){T) {ECHO; ENrER(Z); retum(SELECT_TOKEN);} 

{SHE) (P) {AKR) {A) (T) (E1 {ECHO; ENTER(Z); retum(SEPARATE_TOKEN);} 

{S HU) {B1 {T» {Y1 {P| {E1 {ECHO; ENTER(Z); re&im(SUBTYPE_TOKEN);) 
{T){A}{S){K} {ECHO; ENTER(Z); retuni(TASK_TOKEN);) 

{T) {E) {R) {M) {I) {N) {A) {T) {E) {ECHO; ENTER(Z); retuni(TERMINATE_TOKEN);} 
{T){H){E){N) {ECHO;ENTHl(Z);return(THEN TOKEN);} 

{Tj {Y) {P) {E) {ECHO; ENTER(Z); retum(TYPE_TOKEN);) 

{U1{S){E1 {ECHO;ENTER(Z);retum(USE_TOKEN);} 

{W) {H){E) {N) {ECHO; ENTER(Z); retiim(WHEN TOKEN);} 

{W) {HI {!) {L) {E} {ECHO; ENTER(Z); retum(WHILE TOKEN);) 

(W) {!) {T} {H) {ECHO; ENTER(Z); retum(WlTH_TOKEN);} 

{X} {O} {R) {ECHO; ENTER(Z); retum(XOR_TOKEN);) 

“=>” {ECHO;ENTER(Z);retuni(ARROW);) 

{ECHO; ENTER(Z); retum(DOUBLE_DOT);) 

{ECHO; ENTER(Z); ietinn(DOUBLE_STAR);) 
{ECHO;ENTER(Z);r6tum(ASSIGNMENT);) 

“/t- {ECHO; ENTCR(Z); letumONEQUALITY);) 

“>«” {ECHO; ENTER(Z); n5tum(GREATER_THAN_OR_EQUAL):} 

{ECHO; ENTER(Z); rctum(LESS_THAN_OR_EQUAL);) 

“«“ {ECHO; ENTER(Z); retum(LEFT_LABEL_BRACKET);) 

“»" {ECHO; ENTER(Z); rctuni(RIGHT_LABEL_BRACKET);) 

“o” {ECHO; ENTER(Z); ictuiT»(BOX);) 

“ft** {ECHO; ENTER(Z); retuni(‘&’);) 

“r {ECHO; ENTER(Z); retuni(‘(‘);) 

T {ECHO; ENTER(IDENT); retumC)’): 1 
{ECHO; ENTERGZ); fetum(‘*’);} 

“+” {ECHO; ENTER(Z); «stuni(‘+’);) 

{ECHO; ENTER(Z); retum(‘.’);} 

{ECHO; ENTER(Z); retum(‘.’);} 

“ ” {ECHO; ENTER(Z); retum(‘.’);} 

T (ECHO; ENTER(Z); retum(r); I 
{ECHO; ENTER(Z); retum(‘:’);) 

{ECHO; ENTER(Z); letumC;’);} 

“<“ {ECHO; ENTER(Z); retumC<‘);} 

{ECHO;ENTER(Z);retum(‘=’); I 
“>” {ECHO; ENTER(Z); retuni(‘>’);) 

‘‘r {ECHO; ENTER(Z); retum(T);) 

<IDENTyv’ {ECHO;ENTER(Z);retuni(‘”);) 

(a-z_A-Zl[a-z A-ZO-9]* {ECHO;ENTER(roENT);retuni(IDENTIFffiR);} 
[0-9][0-9J*([J(0-9J+)?([Ee][-+]?(0-9J+)? { 

ECHO; ENTER(Z); 
ietum(RE AL_LITERAL);) 

t0-91[0-9J‘*#(0-9a-fA-FJ+([.][0-9a-fA-FJ+)?#([Eel{-+]?{0-9J+)?{ 

ECHO;ENTER(Z); 
retumONTEGER.LITERAL);) 

\”([n♦^’^”)*)*^’’ {ECHO; ENTER(Z); retum(STRING_LITERAL);) 

<Z>V([<'’INV)V {ECHO; ENTER(Z); rctumCCHARACIER.LITERAL):} 


116 





- Locdung for an elsif on a line by itself 

A[\t]*”elsirtNt]^ {ECHO; 

ENTER(Z); 

--put_line C‘ just found a elsif on a line by itself “): 
if GLOB AL.COUNT_CLARIFICATION 
(GLOBALJIECORD_FLAGS_FPANEL10.LINE_11) then 
--put (“ exec start “); 

--put (“ exec end “); 

~new_line; 

GLOBAL.FLAGS_ARRAY (GLOBAL.STMT_TYPE’val (0). 1) := TRUE; 
GLOBAL.FLAGS_ARRAY (GLOBAL.STMT_TYPE’val (0). 2) ;= TRUE; 
GLOBAL.ADD_TO_ARRAY; 
else 
null; 
end if; 
linenum; 

retum(ELSIF_TOKEN);} 


" Looking for an “else” on a line by itself 

A[\t]*”else”['t]*^ {ECHO; 

ENTER(Z); 

“put_line (“ just found a else on a line by itself “); 
if GUJB AL.COUNT_CLARMCATION 
(GLOBALJ<ECORD_FLAGS_FPANEL10iINE_10) then 
-put (“ exec start “); 

-put (“ exec end “); 

-new_line; 

GLOBAL.FLAGS_ARRAY (GLOBAL.STMT_TYPE’val (0), 1) := TRUE; 
GLOBAL.FLAGS_ARRAY (GLOBAL.STMT_TYPE’val (0). 2) := TRUE; 
GLOBAL.ADD_TO_ARRAY; 
else 
null; 
end if; 
linenum; 

Tetum(ELSE_TOKEN);} 


- Looking for a “then” on a line by itself 

''[\t]*”then”[M]*Nn {ECHO; 

ENTER(Z); 

-put_line C‘ just found a then on a line by itself “); 
if GLOBAL.COUNT_CLARIHCATION 
(GLOBALJIECORD_FLAGS_FPANEL10.LINE_10) then 
-put (“ exec start “); 

-put (“ exec end “); 


117 





r 


-new line; 

GLOBALJFLAGS_ARRAY (GLOBAL.STMT.TYra’val (0). 1) := TOUE; 
GLOBALJLAGS_ARRAY (GLOBAL.STMT_TYre’val (0), 2) := TRUE; 
GLOBAL.ADD_TO_ARRAY; 
else 
null; 
end if; 
bnenum; 

retum(THEN_TOKEN); ) 


- Loddng for an “others** on a line by itself 

^[' 4 ]*’*otliers**[M]*Vn 1 ECHO; 

ENTHl(Z); 

~put_line C just found a others on a line by itself “); 
if GLOBAL.COUNT_CLARIFICATION 
(GLOBALJt£CORD_FLAGS_FJ>ANEL10.LINE_10) then 
-^t C exec start "); 

--put (“ exec end “); 
new_line; 

GLOBALfLAGS_ARRAY (GLOBAL.STMT_TYPE’val (0). 1) ;= TRUE; 
GLOBAL JLAGS.ARRAY (GLOBAL.STMT_TYPE’val (0). 2) := TRUE; 
GLOBAL.ADD_TO_ARRAY; 
else 
null; 
end if; 
linenum; 

tetuni(OTHERS_TOKEN);} 


- Looking for a banner comment of just hyphens “—**, must be longer 

- than two initial hypens, otherwise it is a empty comment. 

{ECHO; 

~ put.line C* found a banner comment of just hyphens “); 

GLOBALJLAGS.ARRAY (GLOBAL.STMT.TYPE’val (5). 1) := TRUE; 
GLOBAL JLAGS.ARRAY (GLOBAL.STMT_TYPE’val (5), 2) := TRUE; 
GLOBAL.ADD_TO_ARRAY; 
linenum; } 


- Checking for empty comments on a line by themselves 
A[N|]*"„**i\t]*Vn {ECHO; 

GLOBALPLAGS.ARRAY (GLOBAL.STMT.TYPE’val (6), 1) := TRUE; 
GLOBALJLAGS.ARRAY (GLOBAL.STMT_TYPE’val (6), 2) ;= TRUE; 
GLOBAL.ADD_TO_ARRAY; 
linenum;) 


118 






" Checking for blank lines 
I ECHO; 

GLOBALPLAGS.ARRAY (GLOBAL.STMT.TYPE’val (7). 1) := TRUE; 
GLOBALJLAGS.ARRAY (GLOBAL.STMT.TYPE’val (7), 1) := TRUE; 
GLOBAL.ADD_TO_ARRAY; 
linenum;) 


[\t] ECHO; •• ignore qxaces and tabs 


“-♦.Programmed’' {ECHO; 

GLOBAL.SPECIAL_COMMENT := TRUE; 
GLOBAL.CURRENT_SETnNGS.SECOND_ATTRIBUTE ;= 
GLOBAL.HOW_PRODUCED’val (0);} 

“-♦.Generated” {ECHO; 

GLOBAL.SPECIAL_COMMENT := TRUE; 
GLOBAL.CURRENT.SETnNGS.SECOND.ATTRIBUTE := 
GLOBAL.HOW.PRODUCED*val (1);) 

“-♦.Converted” {ECHO; 

GLOBAL.SPECIAL_COMMENT := TRUE; 
GLOBAL.CURRENT.SETnNGS.SECOND.ATTRffiUTE := 
GLOBALJIOW.PRODUCED’vai (2);) 

“-♦.Copied” {ECHO; 

GLOBAL.CURRENrr_SETTINGS.SECOND.ATTRIBUTE;» 
GLOBAL JIOW.PRODUCED’val (3); 

GLOBAL.SPECIAL_COMMEbrr;=TRUE;) 

“-♦.Modified” {ECHO; 

GLOBAL.CURRENT.SEmNGS.SECOND_ATTRIBUre ;= 
GLOBAL.HOW.PRODUCED’val (4); 

GLOBAL.SPECIAL_COMMENT:=TRUE; ) 

- User will need to foUow the following examples if they want to include 

- removed code in their counts 

—*.Removed Executables => 45, Declarations => 4, Pragmas => 0 
—♦.Removed Exec => 45, Dec => 4, Prag => 0 
—♦.Removed E => 45, D => 4, P => 0 


“-♦.Removed”* {ECHO; 

GLOBAL.CURRENT.SETTINGS.SECOND.ATTRIBUTE := 
GLOBAL-HOW.PRODUCED’val (5); 

GLOBAL.SPECIAL.COMMENT := TRUE; 

GLOBAL.SPEC_c6MMENT.m4GTH ;= ada.lex.dfa.yytextTength; 
GLOBAL.SPEC.COMMENT.STRING (1.. GLOBAL.SPEC.COMMENT.LENGTH) 
:= ada.lex.dfa.yytext; 

GLOBALPARSE.SPECIAL.COMMENT (GLOBALREMOVED.NUM, 
GLOBAL.SPEC.COMMENT.LENGTH, 
GLOBAL.SPEC.COMMENT.STRING); } 


119 






“_*_Ncw_work” {ECHO; 

GlX)BAL.CUIWEOT_SETnNGS.THIRD_ATTRIBUTE 


( 0 ); 


GLOBAL.SraClAL_COMMENT:=TRUE; ) 


“-♦_Previous_vcrsion" {ECHO; 

GIX)BAL.CURREOT_SETTINGS.THIRD_ATTRIBUTE: 


( 1 ); 


GLOBAL.SPECIAL_COMMENT:=TRUE; } 


“-♦.COTS” 

( 2 ); 


{ECHO; 

GIX>BAL.CURRENT_SETTINGS.THlRD_ATrRIBUTE: 
GLOBAL.SreCIAL_COMMENT:=TRUE; 1 


“-•_GFS” 

(3); 


{ECHO; 

GLOBAL.CURREm'_SETTINGS.THIRD_ATTRIBlJTE: 
GLOBAL.SPECIAL_COMMENT;=TRUE: ) 


“-•_Annother_producr {ECHO; 

GLOBAL.CURREFrr_SETTINGS.THIRD_ATTRIBUTE; 


(4); 


GLOBAL.SreCIAL_COMMENT:=TRUE; ) 


«_*_VSLjipt_Ubrary” {ECHO; 

GLOBAL.CURREOT_SETTINGS.THIRD_ATrRffiUTE 


(5); 


GLOBAL.SPECIAL_COMMENT:*TRUE;) 


“-•_VS_OS_or_utiUty” {ECHO; 

GLOBAL.CURREm’_SETTINGS.THlRD_ATrRIBUTE 


( 6 ); 


GLOBAL.SPECIAL_COMMENT := TRUE; ) 


(7); 


.A_nK)dified_spt_lib” {ECHO; 

GLOBAL.CURRENT_SETTINGS.THIRD_ATrRIBUTE: 

GLOBAL.SPECIAL_COMMENT:=TRUE; } 


“-•.Other.comm.Ub” {ECHO; 

GLOBAL.CURRENT_SETTINGS,THIRD_ATTRroUTE; 


( 8 ); 


GLOBAL,SPECIAL_COMMENT ;= TRUE; } 


“-*_Reuse_libraiy” {ECHO; 

GLOBAL.CURREOT.SETTINGS.THIRD.ATrRIBUTE 


(9); 


GLOBAL.SPECIAL_COMMENT := TRUE;} 


GLOBAL.ORGIN’val 


= GLOBAL.ORGIN’val 


= GLOBAL.ORGIN’val 


= GLOBAL.ORGIN’val 


= GLOBAL.ORGIN’val 


= GLOBAL.ORGIN’val 


:= GLOBAL.ORGIN’val 


= GLOBAL.ORGIN’val 


:= GLOBAL.ORGIN’val 


:= GLOBAL.ORGIN’val 


120 






“-*_Other_Software_component” {ECHO; 

GLOBALrURREOT.SETTINGS.THIRD.ATTRIBUTE := 
GLOBAL.ORGIN’vaI (10); 

GLOBAL.SPECIAL_COMMENT := TRUE; ) 


“-♦.Pait.ofjwoduct” {ECHO; 

GLOBAL.(:TJRRENT_SETnNGS.FOURTH_ATTRIBUTE := 
GLOBAL.USAGE’val (0); 

GLOBALJSPECIAL_COMMENT;=TRUE; } 

“-*_Extemal_to_jwoduct” {ECHO; 

GLOBAL.CURRENT_SETnNGS.FOURTH_ATTRIBUTE := 
GLOBAL.USAGE’val (1); 

GLOBAL.SPECIAL_COMMENT;» TRUE; } 

" To include an estimated or planned value for executable, declarations, and or pragmas, the 

- user will need to follow the following examples 

—’•_Estimated Executables => 2245, Declarations => 4(X), Pragmas => 14 
—♦_Estimated Exec => 2245, Dec => 400, Prag => 14 

- -‘.Estimated E => 2245, D => 400, P => 14 

“-*_Estimated_or_planned“.* {ECHO; 

GLOBAL.CURRENT_SETnNGSJTFTH_ATTRIBUTE := 
GLOBAL.DEVELOPMENT_STATUS*val (0); 

GLOBAV.S ECIAL.COMMENT := TRUE; 
GLOBAL.SPEC_COMMENT_LENGTH := ada.lex dfa.yytextTength; 
GLO:iAL.SPEC_COMMENT_STRING (1.. 
GLOBAL.SPEC_COMMENT_LENGTH) := ada_lex_dfa.yytext; 

GLOBAL.PARSE_SPECIAL_COMMENT(GLOBAL.ESTlMATED_NUM, 
GLOBAL.SPEC_COMMENT_LENGTH, 
GLOBAL.SPEC_COMMENT_STRING); ) 


“-♦.Designed” {ECHO; 

GLOBAL.CURRENT.SETnNGSJTFTH.ATTRlBUTE := 
GLOBAL.DEVELOPMENT.STATUS’val (1); 

GLOBAL.SPEaAL.COMMENT:=TRUE;) 

“-♦.Coded” (ECHO; 

GLOBAL.CURRENT.SETnNGS JTFTH.ATTRIBUTE ;= 
GLOBAL.DEVELOPMENT.STATUS’val (2); 

GLOBAL.SPECIAL.COMMENT :=TRUE;) 

“-♦.Unit.tests.completed” {ECHO; 

GLOBAL.CURRENT.SETTINGS JTFTH.ATTRIBUTE := 
GLOBAL.DEVELOPMENT.STATUS’val (3); 

GLOBAL.SPECIAL.COMMENT := TRUE; ) 


“-♦.Integiated.into.components” {ECHO; 

GLOBAL.CURRENT.SETTINGS JIFTH.ATTRIBUTE := 
GLOBAL.DEVELOPMENT.STATUS’val (4); 

GLOBAL.SPECIAL.COMMENT;=TRUE; } 


121 




r 


“-•_Tcst_readiness_rev_completed” | ECHO; 

GU)BAL.CURREOT_SETTINGSJTFra_ATniIBlJTE:= 
GLOBALDEVELOPMENT STATUS’val (5): 

GLOBAL.SPECIAL_COMMENT:=TRUE; } 

‘•-*_CSCI_completed” {ECHO; 

GLOBAL.ClJRRENT_SETTINGS.FIFrH_ATTRIBUTE ;= 
GLOBAL J)EVELOPMENT_STATUS*var (6); 

GLOBAL.SreCIAL_COMMENT := TOUE; ) 

‘‘-*_Sy«;'.em_tests_completed” {ECHO; 

GLOBAL.CURREOT_SETTnvlGS.nFrH_ATTRIBUTE ;= 
GLOBAL.DEVELOPMENT_STATUS’var (7); 

GLOBAL.SPECIAL_COMMENT:=TRUE; } 


- Checking for comments on their own line 

A[\t]*"„“.#sn {ECHO; 

GLOBAL.THIRD_CHAR := adajex_dfa.yytext (3); 
GLOBAL.SPEC_COMMENT_LENGTH := ada_lex_dfa.yytext’length: 
GLOBAL.SPEC_COMMENT_STRING (1.. 
GLOBAL.SPEC_COMMENT_LENGTH):=adaJex_dfa.yytext; 

GLOBAL.DETiRMINE_TYPE_COMMENT 

(GLOBAL.SPEC_COMMENT_LENGTH. 

GLOBAL.THIRD_CHAR, 
GLOBAL.SPEC_COMMENT_STRING); 
GLOBAL.ADD_TO_ARRAY; 
linenum;} 


- Looking for a comment on a line with source code. 
-- Conditions: 

- Actions: 


{ECHO; 

if GLOBAL.EXECLEVEL >0 or 
GLOBAL J3ECLEVEL >0 or 
GLOBALJ>RAGMALEVEL>0 then 

GLOBALJFLAGS_ARRAY (GLOBAL.STMT_TYPE’val (4), 1) := TRUE; 
GLOBALfLAGS_ARRAY (GLOBAL.STMT_TYPE’val (4), 2) := TRUE; 
else 
nuU; 
end if;} 


{ECHO; 

text_io.putJineC‘?? lexical error” & ada_lex_dfa.yytext & “??”); 
num_enors := num_ertors + 1; ) 


122 







|\n] {ECHO; 

GLOBAL.ADD_TO_ARRAY: 
linenum; ) 

%% 

withTEXTJO, 

ada_tokens, 

GLOBAL. 

ada_lex_clfa, 

TAE; 

use ad^tokens; 

package ada_lex is 

lines : positive := 1; 

num_eiTors : naoiral := 0; 

procedure DECREASE_DECLEVEL; 

procedure linenum; 

function yylex return token; 

end ada_lex; 

package body adajex is 


procedure DECREASE_DECLEVEL is 
begin 

GLOBAL.DECLEVEL := 0; 
end DECREASE.DECLEVEL; 


procedure linenum is 
begin 

text_io.put(integer’image(lines) & 
lines := lines + 1; 
end linenum; 

## 

end adajex; 


123 






GLOBAL S.A 


„ *«* Plus Code Generator version V5.1 
~ *** File: global_s.a 

- •** Generated: Apr 15 10:49:42 1993 

.. * 

-- * Global - Package SPEC 

.. * 

^^mm0m*mm*****************’************************************************ 


with X_Windows; 
with TextJO; 
withTAE; 
use TAE; 
package Global is 


-I PURPOSE: 

-I This package is automatically “with^ed in to each panel package body. 
—I You can insert global variables here. 

~l 

-I INITIALIZATION EXCEPTIONS: (none) 

-I 

-I NOTES; (none) 

-I 

-•I REGENERATED; 

~l This file is generated only once. 

-I 

-I CHANGE LOG; 

-115-Apr-93 TAE Generated 

“•_Programmed 

- (+) begin added code 


type MY_VALUE is array (1..1) of String (l..TAE.Tae_Taeconf.STRINGSIZE); 


SPEQAL.COMMENT. 

COMMENT_FLAG ; boolean :* false; 

SPEC_COMMENT_LENGTH. 

EXECXEVEL, 

DECLEVEL, 

PRAGMALEVEL ; integer ;-0; 

REMOVED_NUM : integer ;= -1; 

ESTIMATED_NUM : integer := 1: 

THIRD_CHAR : character ;= ‘ 


124 








SPEC_COMMENT_STRING : string (1.. 1024) := (others => ‘ ‘); 


OUT_FILE_TYPE ; textJo.fUe_type; 

F : text_io.file_type; 

FILE_LIST_NAME : string (1.. 1024) := (others => ‘ ‘); 

type STMT.TYPE is (EXECUTABLE, DECLARATIONS. COMPELER.DIRECTIVES, 
CMTS_ON_OWN_LINE. CMTS_WITH_SRC_CODE. 
BANNERS_NON_BLANK_SPACERS, BLANK_EMPTY_CMTS. 

BLANK.LINES); 

type HOW_PRODUCED is (PROGRAMMED. GENERATED, COVERETED, 

COPIED, MODIFIED, REMOVED); 

type ORJIN is (NEW.WORK, PREVIOUS_VERSION, COTS. GFS, ANNOTHER.PRODUCT, 
VENDOR_SUPPLIED_SPT_LIB, VENDOR_SUPPLIED_OS, 
LOCAL_SUPPLIED_LIB, COMMERCIAL_LIB, REUSE.LB, 
OTHER_COMPONENT_LIB); 

type USAGE is (PRIMARY.PRODUCT, EXTERNAL); 

type DEVELOPMENT.STATUS is (ESTIMATED, DESIGNED. CODED, UNIT_TEST_DONE, 
INTEGRATED, TEST_READINESS_REVIEW, 

CSCLCOMPLETED, SYSTEM_TESTS_COMPLETED); 

type COUNT_ARRAY_TYPE is array (STMT.TYPE, HOW.PRODUCED, 

ORGIN, USAGE, DEVELOPMENT_STATUS) of natural; 


type FLAGS_TYPE_ARRAY is array (STMT_TYPE, L,2) of boolean; 
type PRIORITY_TYPE_ARRAY is array (L.8) of STMT_TYPE; 
type ORDER_OF_PRECEDENCE is range 1..8; 


type CURRENT_SETnNGS_TYPE is 
record 


FIRST_ATTRIBUTE 
SECOND_ATTRIBUTE 
THIRD_ATTRIBUTE 
FOURTH_ATTRIBUTE 
FIFTH.ATTRIBUTE 
end record; 


: STMT_TYPE := EXECUTABLE; 

: HOW_PRODUCED := PROGRAMMED; 

: ORGIN :=NEW_WORK; 

; USAGE := PRIMARY_PRODUCT; 

: DEVELOPMENT_STATUS := SYSTEM_TESTS_COMPLETED; 


type STMT_TOTALS_TYPE is 
record 

EXEC.TOTAL, 

DEC_TOTAL, 

PRAGMA.TOTAL, 

CMTS_ON_OWN_TOTAL. 

CMTS_W_SRC_TOTAL, 


125 







BANNER_CMTS_TOTAL. 
EMPTY_CMTS_TOTAL. 
BLANK_LINES_TOTAL ; natural :=0; 

Old record; 

type HOW_PRODUCED_TYPE is 
record 

PROGRAMMED_TOTAL. 

GENERATED.TOTAL, 

CONVERTCD.TOTAL, 

COPffiD_TOTAL. 

MODIFIED_TOTAL. 

REMOVED_TOTAL : natural :=0; 
end record; 

type ORGIN_TYPE is 
record 

NEW_WORK_TOTAL. 

PREVIOUS_VERSION_TOTAL. 

COTS_TOTAL. 

GFS.TOTAL, 

ANNOTHER_PRODUCT_TOTAL. 

VS_SPT_LIB_TOTAL, 

VS_SPT_OS_TOTAL, 

LOCAL_SUPPLIED_LIB_TOTAL, 

COMMERCIAL_LIB_TOTAL. 

REUSE_LIB_TOTAL. 

OTHEICCOMPONENT.TOTAL : natural ;= 0; 
end record; 

type USAGE_TYPE is 
record 

PR1MARY_PR0DUCT_T0TAL, 
EXTERNAL.TOTAL : natural :=0; 
end record; 

type DEVELOPMENT_STATUS_TYPE is 
recOTd 

ESTIMATED.TOTAL, 

DESIGNED_TOTAL. 

CX)DED_TOTAL, 

UNlT_TEST_DONE_TOTAL, 
INTEGRATED_TOTAL, 
TEST_READINESS_REVIEW_TOTAL, 
CSCI_COMPLETED_TOTAL, 
SYSTEM_TEST_TOTAL : natural :=0; 
end record; 

type COLINT_TOTALS_TYPE is 
rectvd 

STMT_NUMS ; STMT_TOTALS_TYPE; 


126 





PRODUCED.NUMS : HOW_PRODUCED_TYPE; 
ORGIN_NUMS ; ORGIN_TYPE; 

USAGE.NUMS ; USAGE_TYPE; 

DEVELOPED.NUMS : DEVELOPMENT.STATUS.TYPE; 
end record; 


type panel_2 is 
record 


report_a 

: boolean := true; 

iepoit_b 

: boolean := false; 

teport_c 

: boolean := false; 

reported 

: boolean := false; 

report_e 

: boolean :s false; 

report_f 

: boolean := false; 

next_scm 

: boolean := false; 

out_file_name 

: my_value; 

in_file_name 

: my_value; 

requestor 

: my_value; 

repoit_heading 

: my_value: 


end record; 

type panel_3 is 
record 
line_l 
line_3 
line_4 
line_6 
Iine_7 
line_8 
Iine_9 
line_10 
line_l_int 
line_3_int 
line_4_int 
line_6_int 
line_7_int 
line_8_int 
line_9_int 
line_10_int 
def_data_airay ; boolean := false; 
end record; 


type panel_4 is 
record 


line_l 

: boolean := true; 

line_2 

: boolean := true; 

line_3 

: boolean := true; 

line_4 

; boolean ;= true; 

line_5 

; boolean := true; 

line_6 

: boolean := false; 


boolean := true; 
boolean := true; 
boolean := true; 
boolean := false; 
boolean := false; 
boolean := false; 
boolean := false; 

: boolean := false; 

: TAE.TAEINT ;= 1; 

: TAE.TAEINT := 2; 

: TAE.TAEINT := 3; 

: TAE.TAEINT := 4; 

; TAE.TAEINT := 5; 

; TAE.TAEINT:=6; 

; TAE.TAEINT := 7; 

: TAE.TAEINT := 8; 


127 









(Ief_(lata_anay : bootean :s false; 
Old record; 


type pancLS is 
record 
line_l 
line_3 
line_4 
line_5 
line_6 
liiie_7 
line_8 
line_9 
linc_10 
line_ll 
line_12 
def_data_array 
end record; 


boolean := true; 
booleantrue; 
boolean is true; 
boolean true; 
boolean := true; 
boolean ;= false; 
boolean := false; 
boolean := true; 
boolean := true; 
boolean := true; 
boolean := true; 

; boolean := false; 


type panel_6 is 
rec^ 

Iine_l : 

line_2 : 

DEL_OPTION 
def_daia_array 
Old record; 


boolean := true; 
boolean := false; 

: MY_VALUE; 
: boolean false; 


type panel_9 is 
record 
line_l 
line_2 
line_3 
line_4 
line_5 
line_6 
line_7 
line_8 

def_data_array 
end record; 


boolean := fidse; 
boolean := false; 
boolean := false; 
boolean ;= false; 
boolean := false; 
boolean := false; 
boolean := f^se; 
boolean := true; 

: boolean ;= false; 


typcpanel_10is 

record 


line_l 

; boolean := true; 

Iine_2 

: boolean := true; 

line_3 

; boolean ;= true; 

line_4 

: boolean := true; 

liiie_5 

: boolean := true; 


128 






line_6 
line_7 
line_8 
line_9 
line_10 
line_ll 
line_12 
linc_13 
line_l_int 
line_2_int 
line_3_int 
iine_4_int 
line_5_mt 
line_6_int 
line_7_int 
line_8_int 
line_9_int 
line_10_int 
line_lljnt 
line_12Jiit 
line_13_int 
def_data_array 
end record; 

typepanel_ll is 
record 
line_l 
line_2 
line_3 
line_4 
line_5 
line_6 
line_l_int 
line_2_int 
line_3_int 
line_4_int 
Iine_5_int 
line_6_int 
end record; 

type flags is 
record 
panel2 
panel3 
pane]4 
panels 
panel6 
panel9 
panellO 
panelll 
end record; 


boolean ;= true; 
boolean :& true; 
boolean ;s true; 
boolean :& true; 
boolean := true; 
boolean := true; 
boolean := true; 
boolean := true; 
TAE.TAEINT ;= 1; 
TAE.TAEINT:=1; 
TAE.TAEINT := 3; 
TAE.TAEINT := 1; 
TAE.TAEINT := 3; 
TAE.TAEINT := 1; 
TAE.TAEINT ;= 1; 
TAE.TAEINT ;= 1; 
TAE.TAEINT := 3; 
TAE.TAEINT := 1; 
TAE.TAEINT := 1; 
TAE.TAEINT := 3; 
TAE.TAEINT := 1; 
: boolean := false; 


boolean ;= true; 
boolean := true; 
boolean :s true; 
boolean :& true; 
boolean :* true; 
boolean ;= true; 
TAE.TAEINT := 3 
TAE.TAEINT ;= 1 
TAE.TAEINT := 3 
TAE.TAEINT := 1 
TAE.TAEINT ;= 3 
TAE.TAEINT := 4 


panel_2; 

panel_3; 

panel_4; 

panel_5; 

panel_6; 

panel_9; 

panel_10; 

paneLH; 


129 












recocd.flags : flags; 

recofd_flags_A : flags; 

iec(xd_flags_B : flags; 

fecord_flags_C : flags; 

iec(nd_flags_D : flags; 

(ecord_flags_E : flags; 

tec(»d_flags_F : flags; 

CX)UNT_ARRAY_A : COUNT_ARRAY_TyPE ;= (others => (others => 
(others => (others => 

(others => 0))))); 

CX)UNT_ARRAY_B : COUNT_ARRAY_TYPE ;= (others => (others => 
(others => (others => 

(others => 0))))); 

COUNT_ARRAY_C : COUNT_ARRAY_TYFE := (others => (others => 
(others => (others => 

(others => 0))))); 

COUNT_ARRAY_D : COUNT_ARRAY_TYPE := (others => (others => 

(others => (others => 

(others => 0))))); 

COUNT_ARRAY_E ; COUNT_ARRAY_TYPE := (others => (others => 
(others => (others *> 

(others => 0))))); 

COUNT_ARRAY_F : COUNT_ARRAY_TYPE ;= (.olfiers => (others => 
(others => (others *> 

(others => 0))))); 

FLAGS.ARRAY : FLAGS_TYPE_ARRAY; 
PRIORfrY_ARRAY_A_E ; PRIORUY.TYPE.ARRAY; 
PRIORTTY.ARRAY.F ; PRIORITY.TYPE.ARRAY; 

CURRENT.SETTINGS ; CURRENT.SETITNGS.TYPE; 

COUNT.TOTALS : CX)UNT_TOTALS_TYPE; 

COUNT_TOTALS_A : COUNT_TOTALS_TYPE; 
COUNT_TOTALS_B : COUNT_TOTALS_TYPE; 
COUNT_TOTALS_C ; COUNT_TOTALS_TYPE; 
COUNT_TOTALS_D : COUNT_TOTALS_TYPE; 
CX)UNT_TOTALS_E : COUNT_TOTALS_TYPE; 

COUNT_TOTALS_F : COUNT_TOTALS_TYPE; 

TOTAL_COUNTED_A. 

TOTAL_COUNTED_B, 

TOTAL_COUNTED_C. 

TOTAL_COUNTED_D. 


130 








TOTAL_COUNTED_E. 
TOTAL_COUNTED_F :nalural:=0; 


'•(•) end added code 


-* Generated 


package TaefloatJO is new Text_IOPloai_IO (TAE.Taefloat); 
Default_Display_Id: X_Windows.Display; 


- procedure CHECK_FLAG_SETnNGS; 


AH)lication_Done -- Subprogram SPEC 


function Application.Done 
return Boolean; 

--I PURPOSE: 

-I This function returns true if a “quit” event handler has called 
"I Set_Application_Done, otherwise it returns false. 

-I 

-1 EXCEPTIONS: (none) 

-I 

-I NOTES: (none) 


Set_Application_Done ~ Subprogram SPEC 


procedure Set_Application_Done; 


-I PURPOSE: 

-I This procedure can be used by an event handler, typically a “quit” 


131 






-I button. 10 signal the end of the application. 
-I 

-I EXCEPTIONS; (none) 

-I NOTES: (none) 


Switch.flag 


■ Sulq;»t)grain SPEC 


function Switch.Flag (FLAG_IN: in boolean) return boolean; 


~l PURPOSE: 

-I This ivocedure will be used when the user changes the default settings 
-I for the custom format rqxMl 
-I 

~l EXCEPTIONS: (none) 

-I 

-I NOTES: (none) 




function CHECK_REPORT_A_E return boolean; 


function CHECK_REPORT_F return boolean; 


function COUNT.CXARIHCATION (BOOLEAN_IN; in BOOLEAN) return BOOLEAN; 

-I 

-I 

-I 


procedure OPEN_OUT_FILE; 


procedure CLOSE_OUT_FILE; 


32 








function FIND_LENGTH (FILELIST: in GLOBAL.MY_VALUE) return integer; 


procedure ADD_TO_ARRAY; 


procedure COUNT.LINE (IN.RECORD : in CURRENT.SETTINGS.TYPE; 
ARRAY_TYre: in out COUNT_ARRAY_TYre; 
ADD_NUMBER: in natural ;= 1); 


iwocedure DETERMINE_WHICH_ARRAY (IN.RECORD ; in 
CURRENT_SETTINGS_TYPE; 

ADD_NUMBER; in natural ;= 1); 


procedure PARSE_SPECIAL_COMMENT (IN_NUM : in integer. 
IN_LENGTH; in integer; 

IN_STRING; in string); 


procedure DETERMINE_TYPE_COMMENT (IN_BANNER_LENGTH : in out integer; 
IN_B ANNER_CHAR ; in out character, 

IN_BANNER_STRING : in out STRING); 


end Global; 


133 







GLOBAL B.A 


„ *** pjyj Qjjjg Generator version V5.1 

~ File: global.ba 

-*•* Generated: Apr 15 10:49:42 1993 


_ ♦ 

~ * Global - Package BODY 

„ * 


with TEXTJO; 
use TEXTJO; 
package body Global is 

-I NOTES: (none) 

-I 

-I REGENERATED: 

~t This file is generated only once. 

-I 

-I CHANGE LOG: 

—115-Aiw-93 TAE Generated 

-*_Programmed 

package TAE_INTEGER_IN_OUT is new integer Jo (TAE.TAEINT); 
use TAE_INTCGER_IN_OUT; 

package INTEGER_IN_Oin' is new integer Jo (integer); 
use INTEGER_IN_OUT; 

package ENUMERATION.IN.OUT is new ENUMERATION JO (STMT.TYPE); 
use ENUMERATION_IN_buT; 


Generated 


Is_Application_Done: Boolean := FALSE; 


Application_Done - Sut^rogram BODY 


function Application_Done 
return Boolean is 

-I NOTES: (none) 


134 









begin ~ Applicadon.Done 
return Is_AH)lication_Done; 
end Application.Done; 


- . Set_Application_Done - Subprogram BODY 


procedure Set_Application_Done is 
-I NOTES: (none) 
begin - Set_Application_Done 
Is_Application_Done := TRUE; 
Old Set_Applicarion_Done: 

-*_Piogrammed 


-- . Switch.flag - Subprogram SPEC 


function Switch_Flag (FLAG_IN: in boolean) return boolean is 
-I PURPOSE: 

“I This procedure will be used when the user changes the default settings 
--I for the custom format report 
-I 

-I EXCEPTIONS: (none) 

-I 

-I NOTES: (none) 

TCMP_FLAG : boolean; 
begin 

ifFLAG_IN then 
TEMP_FLAG := false; 
else 

TEMP_FLAG := true; 


135 





end if; 

return TEMP_FLAG; 
end Switch_Flag; 


function CHECK_REPORT_A_E return boolean is 
BOOLEAN_FLAG : boolean := FALSE; 


begin 

if RECORD_FLAGSPANEL2.REPORT_Aor 
RECORD_FLAGS.PANEL2J«EPORT_B or 
RECORD_FLAGS.PANEL2PEPORT_C or 
RECX)RD_FLAGS.PANEL2 PEPORT.D or 
RECXDRD_FLAGS.PANEL2PEPORT_E then 
BOOLEAN.FLAG ;= TRUE; 
end if; 

return BOOLEANJFLAG; 
end CHECK_REPORT_A_E; 


function CHECK._REPORT_F return boolean is 
BOOLEAN.FLAG : boolean := FALSE; 
begin 

if RECORD_FLAGSPANEL2.REPORT_F then 
BOOLEAN_FLAG := TRUE; 
end if; 

return BC)OLEAN_FLAG; 
end CHECK_REPORT_F; 


function COUNT.STMTT.TYPE (S : in STMT_TYPE; 

IN_COUNT_ARRAY: in COUNT_ARRAY_TYPE) return integer is 

TEMP_COUNT : integer :=0; 


136 





begin 

for H in HOW.PRODUCED’FIRST .. HOW_PRODUCED’LAST loop 
forOinORGIN’FIRST..ORGIN’LAST lo(^ 
for U in USAGE’FIRST.. US AGE’LAST loop 

for D in DEVELOPMENT_STATUS’FIRST.. DEVELOPMENT_STATUS’LAST loop 
TEMP.COUNT := TEMP_COUNT + IN_COUNT_ARRAY (S, H. O, U, D); 
end loop; 
end loop; 
end loop; 
end loop; 

return TEMP_CX)UNT; 
end COUNT_STMT_TYPE; 


function COUNT_HOW_PRODUCED (H : in HOW_PRODUCED; 

IN_c6uNT_ARRAY : in COUNT_ARRAY_TYPE) return integer is 

TEMP_COUNT ; integer :=0; 

begin 

for S in STMT_TYPE’FIRST.. STMT.TYPE’LAST loop 
for O in ORGIN’FIRST.. ORGIN’LAST loop 
for U in USAGE’FIRST. US AGE’LAST loop 

for D in DEVELOPMENT_STATUS’FIRST.. DEVELOPMENT_STATUS’LAST loop 
TEMP.COUNT ;= TEMP_COUNT + IN_COUNT_ARRAY (S. H, O, U, D); 
end loop; 
end loop; 
end loop; 
end loop; 

return TEMP_CX)UNT; 
end COUNT_HOW_PRODUCED; 


function COUNT_ORGIN (O : in ORGIN; 

IN_COUNT_ARRAY : in COUNT_ARRAY_TYPE) return integer is 


TEMP_COUNT : integer :=0; 


begin 

for S in STMT_TYPE’FIRST.. STMT_TYPE’LAST loop 
for H in HOW_PRODUCED’FIRST.. HOW_PRODUCED’LAST loop 
for U in USAGE’FIRST.. US AGE’LAST loop 


137 







f« D in DEVELOPMENT_STATUS’FIRST.. DEVELOPMENT_STATUS’LAST Icx^ 
TEMP.COUNT := TEMP.COUNT + IN_COUNT_ARRAY (S, H, O. U, D); 
end loop; 
end loop; 
end loop; 
out loop; 

return TEMP_CX)UNT; 
endCOUNT.ORGIN; 


function CX)UNT_USAGE (U : in USAGE; 

INj:OUNT_ARRAY: in COUNT_ARRAY_TYPE) return integer is 

TEMP_CX)UNT : integer :=0; 

begin 

for S in STMT_TYPE’FIRST.. STMT_TYPE’LAST loop 
for H in HOW_PRODUCED’FIRST.. HOW.PRODUCED’LAST loop 
for O in ORGIN’FIRST.. ORGIN’LAST loop 

for D in DEVELOPMENT_STATUS’FIRST.. DEVELOPMENT.STATUS’LAST loop 
TEMP_COUNT := TEMP_COUNT + IN_COUNT_ARRAY (S, H, O, U. D); 
end loop; 
end loop; 
end loop; 
end loop; 

return TEMP_COUNT; 

«idCOUNT_USAGE; 


function COUNT.DEVELOPMENT.STATUS (D : in DEVELOPMENT.STATUS; 

IN_COUNT_ARRAY: in COUNT_ARRAY_TYPE) return integer is 


TEMP_COUNT : integer :=0; 


begin 

for S in STMT_TYPE’FIRST.. STMT.TYPE’LAST loop 
for H in HOW.PRODUCED’FIRST.. HOW.PRODUCED’LAST loop 
for O in ORgIn’FIRST .. ORGIN’LAST loop 
for U in USAGE’FIRST.. US AGE’LAST loop 

TEMP.COUNT := TEMP_COUNT + IN_COUNT_ARRAY (S, H. O. U, D); 
end loop; 
end loop; 
end lot^; 
end loop; 


138 





return TEMP_COUNT; 
end COUNT_DEVELOPMENT_STATUS; 


procedure COUNT_ATTRIBUTE_ONE (lN_RECORD_FLAGS : in FLAGS; 

IN_COUNT_TOTALS : in out COUNT_TOTALS_TYPE; 
IN_ARRAY ; in COUNT_ARRAY_TYPE) is 

begin 

if IN_RECORD_FLAGS.PANEL3.1ine_l then 

IN_COXJNT_TOTALS.STMT_NUMS£XEC_TOTAL := COUNT_STMT_TYPE 
(STMT.TYPE’val (0), IN.ARRAY); 
end if; 

if IN_RECORD_FLAGS.PANEL3.1ine_3 then 

IN_COUNT_TOTALS.STMT_NUMS.DEC_TOTAL := COUNT_STMT_TYPE 
(STMT_TYPE’val (1). IN.ARRAY); 
end if; 

if IN_RECORD_FLAGS.PANEL3.1ine_4 then 

IN_COUNT_TOTALS.STMT_NUMSPRAGMA_TOTAL := COUNT_STMT_TYPE 
(STMT.TYPE’val (2), IN_ARRAY); 
end if; 

if IN_RECORD_FLAGS.PANEL3.line_6 then 
IN_COUNT_TOTALS.STMT_NUMS.CMTS_ON_OWN_TOTAL:= 
COlj^_STMT_TYPE (STMT.TYPE’val (3). IN.ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL3.1ine_7 then 
inJcount_totals.stmt_nums.cmts_w_src_total:= 

COUNT.STMT.TYPE (STMT.TYPE’val (4), IN.ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL3.1ine_8 then 
IN_COUNT_TOTALS.STMT_NUMS.BANNER_CMTS_TOTAL := 
COUNT_STMT_TYPE (STMT_TYPE’val (5), IN_ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL3.1ine_9 then 
IN_COUNT_TOTALS.STMT_NUMS£MPTY_CMTS_TOTAL := 
COUNT_STMT_TYPE (STMTJTYPE’val (6), D^_ARRAY); 

end if; 

if lN_RECORD_FLAGS.PANEL3.1ine_10 then 
!N_C0UN1_T0TALS.STMT_NUMS.BLANK_LINES_T0TAL:= 
COUNT_STMT_TYPE (STMT.TYPE’val (7), IN.ARRAY); 

eiKlif; 

end COUNT_ATTRIBUTE_ONE; 


procedure COUNT_ATTRIBUTE_TWO (IN_RECORD_FLAGS : in FLAGS; 

IN_COUNT_TOTALS : in out COUNT.TOTALS.TYPE; 


139 






IN_ARRAY : in COUNT_ARRAY_TYPE) is 

begin 

if IN_RE(X)RD_FLAGSJ»ANEL4.line_l then 

IN_CX)UNT_TOTALSJ»RODUCED_NUMS.PROGRAMMED_TOTAL ;= 

(X)UNT_HOW_PRODUCED (HOW_E^ODUCED*val (0), IN.ARRAY); 

mdif; 

if IN_RECORD_FLAGS J»ANEL4.1ine_2 then 
IN_CX)UNT_TOTALSJ»RODUCED_NUMS.GENERATED_TOTAL := 

COUNT_HOW_HlODUCED (HOW.H^ODUCED’val (1). IN.ARRAY); 

end if; 

if IN_RECORD_FLAGSJ>ANEL4.1ine_3 then 
IN_COUNT_TOTALS J»RODUCED_NUMS.CONVERTED_TOTAL := 

COUNT_HOW_PRODUCED (HOW_PRODUCED’val (2). IN.ARRAY); 

end if; 

if IN_RECX)RD_FLAGS.PANEL4.1ine_4 then 
IN_COUNT_TOTALS.PRODUCED_NUMS.COPIED_TOTAL:= 

COUNT_HOW_PRODUCED (HOW_PRODUCED’val (3). IN_ARRAY); 

end if; 

if INJlECX3RD_FLAGS.PANEL4.1ine_5 then 
IN_COUNT_TOTALS.PRODUCED_NUMS.MODIFIED_TOTAL;= 

CX)UNT_HOW_PRODUCED (HOW_PRODUCED’val (4). IN„ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL4.1ine_6 then 
IN_COUNT_TOTALS.PRODUCED_NUMS.REMOVED_TOTAL;=: 

COUNT_HOW_PRODUCED (HOW.PRODUCED’val (5), IN_ARRAY); 

end if; 


end COUNT.ATTRIBUTE.TWO; 


procedure COUNT.ATTRIBUTE_THREE (IN_RECORD_FLAGS : in FLAGS; 

IN_COUNT_TOTALS : in out COUNT_TOTALS_TYPE; 

IN.ARRAY : in COUNT_ARRAY_TYPE) is 

begin 

if IN_RECORD_FLAGS.PANEL5.1ine_l then 

IN_COUNT_TOTALS.ORGIN_NUMSJSIEW_WORK. TOTAL := COUNT.ORGIN 
(ORGIN’val (0), IN.ARRAY); 
end if; 

if IN_RECORD_FLAGS.PANEL5.Iine_3 then 

IN_COUNT_TOTALS.ORGIN_NUMSPREVIOUS_VERSION_TOTAL:= 
COUNT.ORGIN (ORGIN’val (1), IN.ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL5.1ine_4 then 

IN_COUNT_TOTALS.ORGIN_NUMS.COTS_TOTAL ;= COUNT ORGIN (ORGIN’vai (2), 
IN.ARRAY); 
end if; 

if IN_RECORD_FLAGS.PANEL5.1ine_5 then 


140 




IN_COUNT_TOTALS.ORGIN_NUMS.GFS_TOTAL ;= COUNT.ORGIN (ORGIN'val (3). 
IN.Aj^Y); 
end if; 

if IN_RECX)RD_FLAGS.PANEL5.1ine_6 then 

IN_COUNT_TOTALS.ORGIN_NUMS.ANNOTHER_PRODUCT_TOTAL;= 
COUNT.ORGIN (ORGIN’val (4). IN_ARRAY): 

end if; 

if IN_RECORD_FLAGSPANEL5.1ine_7 then 

IN_COUNT_TOTALS.ORGIN_NUMS.VS_SPT_LIB_TOTAL := COUNT.ORGIN 
(ORGIN’val (5), IN.ARRAY); 
end if; 

if IN_RECX)RD_ELAGS.PANEL5.1ine_8 then 

IN_COUNT_TOTALS.ORGIN_NUMS.VS_SPT_OS_TOTAL := COUNT_ORGIN 
(ORGIN’val (6), IN_ARRAY); 
end if; 

if IN_RECX)RD_FLAGS.PANEL5.1ine_9 then 

IN_COUNT_TOTALS.ORGIN_NUMSl-OCAL_SUPPLIED_LIB_TOTAL:= 
COUNT.ORGIN (ORGIN’val (7). IN_ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL5.1ine_10 then 
IN_COUNT_TOTALS.ORGIN_NUMS.COMMERCIAL_LIB_TOTAL;= 

COUNT_ORGIN (ORGIN’val (8). IN_ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL5.1ine_ll then 

IN_COUNT_TOTALS.ORGIN_NUMS jyEUSE_LIB_TOTAL := COUNT.ORGIN 
(ORGIN’val (9), IN.ARRAY); 
end if; 

if IN_RECX)RD_FLAGS.PANEL5.1ine_12 then 
IN_COUNT_TOTALS.ORGIN_NUMS.OTHER_COMPONENT_TOTAL:* 
COUNT.ORGIN (ORGIN’val (10), IN.ARRAY); 

end if; 


end COUNT_ATTRIBUTE_THREE; 


procedure COUNT_ATTRIBUTE_FOUR (IN_RECORD_FLAGS : in FLAGS; 

IN_COUNT_TOTALS : in out COUNT_TOTALS_TYPE; 
IN_ARRAY : in COUNT_ARRAY_TYPE) is 

begin 

if IN_RECORD_FLAGS.PANEL6.1ine_l then 

IN_COUNT_TOTALS.USAGE_NUMSJ>RIMARY_PRODUCT_TOTAL:= 
COUNT_USAGE (USAGE’val (0), IN_ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL6.1ine_2 then 

IN_COUNT_TOTALS.USAGE_NUMS£XTERNAL_TOTAL := COUNT_USAGE 
(USAGE’val (1), IN_ARRAY); 
end if; 


141 





end CX)UNT_ATrRIBUTE_FOUR; 


jHOcedure COUNT_ATTRIBUTE_FIVE (IN_RECORD_FLAGS; in FLAGS; 

IN_COUNT_TOTALS: in out COUNT.TOTALS.TYPE; 
IN.ARRAY : in COUNT_ARRAY_TYPE) is 

begin 


if IN_RECX)RD_FLAGS.PANEL9.1ine_l then 
IN_CX)UNT_TOTALS.DEVELOPED_NUMS.ESTIMATED_TOTAL := 

COlff^_DEVELOPMENT_STATUS (DEVELOPMENT_STATUS’val (0). 
IN.ARRAY); 
end if; 

if IN_RECX)RD_FLAGS.PANEL9.1ine_2 then 
IN_COUNT_TOTALS.DEVELOPED_NUMS.DESIGNED_TOTAL:= 

COin9T_DEVELOPMENT_STATUS (DEVELOPMENT_STATUS’val (1). 
IN_ARRAY); 
end if; 

if IN_RECX)RD_FLAGS.PANEL9.line_3 then 
IN_COUNT_TOTALS.DEVELOPED_NUMS.CX)DED_TOTAL ;= 

COUNT_DEVELOPMENT_STATUS (DEVELOPMENT_STATUS’val (2), 
IN.ARRAY); 
end if; 

if IN_RECORD_FLAGS.PANEL9.1ine_4 then 

IN_COUNT_TOTALS.DEVELOPED_NUMS.UNIT_TEST_DONE_TOTAL:= 

COUNT_DEVELOPMENT_STATUS (DEVELOPMENT_STATUS’val (3), 
IN_ARRAY); 
end if; 


if IN_RECX)RD_FLAGS.PANEL9.1ine_5 then 

IN_COUNT_TOTALS.DEVELOPED_NUMS.INTEGRATED_TOTAL := 

COUNT_DEVELOPMENT_STATUS (DEVELOPMENT_STATUS’val (4), 
IN.ARRAY); 
end if; 

if IN_RECORD_FLAGS.PANEL9.1ine_6 then 

IN_COUNT_TOTALS.DEVELOPED_NUMS.TEST_READINESS_REVIEW_TOTAL 
COUNT_DEVELOPMENT_STATUS (DEVELOPMENT_STATUS’val (5), 
IN.ARRAY); 
end if; 


if IN_RECX)RD_FLAGS.PANEL9.Iine_7 then 

IN_COUNT_TOTALS.DEVELOPED_NUMS.CSCI_COMPLETED_TOTAL:= 

COUNT_DEVELOPMENT_STATUS (DEVELOPMENT.STATUS’val (6). 
IN.ARRAY); 
end if; 


if IN_RECORD_FLAGS.PANEL9.line_8 then 

IN_COUNT_TOTALS.DEVELOPED_NUMS.SYSTEM_TEST_TOTAL:= 

COUNT_DEVELOPMENT_STATUS (DEVELOPMENT_STATUS’vaI (7). 
IN_ARRAY); 
end if; 


end COUNT ATTRIBUTE FIVE; 






function COUNT_CLARIFICATION (BOOLEAN_IN : in BOOLEAN) return boolean is 
TEMP : boolean := FALSE; 
begin 

if BOOLEAN.IN then 
TEMP := TRUE; 
else 

TEMP := FALSE; 
end if; 

return TEMP; 

end COUNT.CLARinCA'nON; 


function FIND_LENGTH (FILELIST; in GLOBAL.MY_VALUE) return integer is 

TEMP_NUMBER : integer := 0; 

TEMP_CHAR ; character := ‘ 

begin 

for I in FILELIST’range loop 
for J in 1.. 1024 loq) 
if FILELIST (D(J) /= 1 -MP.CHAR then 
TEMP_NUMBER := lEMP.NUMBER + 1; 
else 
exit; 
end if; 
end loop; 
end loop; 

return TEMP_NUMBER; 
endFlND.LENGTH; 


procedure OPEN_OUT_FILE is 

OUT_FILE_NAME : GLOBAL.MY_VALUE ;= 
GL0B>ijlEC0RD_FLAGS.PANEL2.0UT_FILE_NAME; 
LENGTH : integer. 


3 





begin 

LENGTH := FIND.LENGTH (OUT_FILE_NAME); 
FILE_LIST_NAME(l.iENGTH) := OUT_FILE_NAME (1) (1..LENGTH); 
create (OUT_FILE_TYPE. out.file, FILE_UST_NAME (l.iENGTH)); 
end OPEN_OUT_FILE; 


procedure CLOSE_OUT_FILE is 

OUT_FILE_NAME : GLOBAL.MY_VALUE := 

GLOBAL JIEC0RD_FLAGS.PANEL2.0UT_FILE_NAME; 

LENGTH : integer, 

begin 

LENGTH := FIND_LENGTH (OUT_FILE_NAME); 
FILE_LIST_NAME(1.XENGTH) := OTJT_FILE_NAME (1) (LiENGTH); 
close (OUT_FILE_TYPE); 

end CLOSE.OUT.HLE; 


procedure DETERMINE_TYPE_COMMENT (IN_BANNER_LENGTH : in out integer 
IN_BANNER_CHAR : in out character; 

IN_BANNER_STRING : in out STRING) is 

~ Function to determine if a particular comment is 
- a banner comment. 

function BANNER_FOUND (BANNER_LENGTH ; in integer; 

BANNER_CHAR : in character; 

BANNER_STRING : in STRING) return boolean is 


FIRST : integer :* 1; 

BANNER : boolean := FALSE; 

BLANK_SPACE : character ‘ 

HYPHEN : character := 

BANNER_CHARS ; string (1..4) ;= (others => ‘ *); 
COUNTJLOOP : integer :=0; 

REPEAT_CHARS : boolean := FALSE; 


begin 


144 






for I in BANNER_STRING*first.. BANNER.STRING’last -1 loop 


if BANNER_STRING (!) = •-’ and 
BANNER.STOING G+D = then 

BANNER_CHARS ;= BANNER_STRING a+2..I+5): 

for J in BANNER_STRING’first+I+2.. Banner_length - 4 loq) 

if BANNER.STWNG (J) = BANNER.CHARS (1) ot 
BANNER_STRING (J) * BANNER.CHARS (2) or 
BANNER_STRING (J) = BANNER_CHARS (3) or 
BANNER_STRING (J) = BANNER.CHARS (4) or 
BANNER.STRING (J) = BLANK.SPACE then 

COUNT_LOOP := COUNT.LOOP + 1; 
if COUNT.LOOP > 4 then 
BANNER :=TRUE: 
end if; 
else 

BANNER := FALSE; 
exit; 
end if; 

if counljoop < bannerjength -1 then 
null; 
else 
exit; 
end if; 
end loop; 

exit; 
end if; 

end loop; 

return BANNER; 

end BANNER_FOUND; 


begin 

- Checking for banner comments. 

- CONDITIONS: 

- Banner characters must be non-blank; 

- Banner characters must be either the third character from the 
~ left, or blank chaiactor. 

- ACTION: 

" Set the start and stop flags to true for Baiuier comments, 
if BANNER_FOUND (IN_B ANNER_LENGTH, IN BANNER_CHAR, 
IN_BANNER_STRING) then 

FLAGS.ARRAY (STMT.TYPE’val (5), I) := TRUE; 
FLAGS_ARRAY (STMT_TYPE’val (5). 2) := TRUE; 


145 




~ Giecldng for commenis on own line. 

•> Conditions: 

- Start flags for Executable, Declaratkm, and or Pragma must not be 
~ set to true. 

- ACTIONS: 

~ Set start and stt^ flags to true for Comments on own line, 
else 

FLAGS.ARRAY (STMT.TYPE’val (3). 1) := TRUE; 
FLAGS.ARRAY (STMT.TYPE'val (3). 2) := TRUE; 
end if; 

end DETERMINE_TYPE_COMMENT; 


function CHECKED_OKAY_A (IN_CURRENT_SETTINGS: CURRENT_SETTINGS_TYPE) 
return boolean is 

OKAY : boolean := TRUE; 

begin 

case IN_CURREbn'_SETnNGS JIRST_ATTRIBUTE is 
when STMT_TYPE’VAL (3) I STMT_TYPE’VAL (4) I STMT TYPE'VAL (5) I 
STMT.TYPE’VAL (6) I STMT.TWE’VAL (7) *> 

OKAY := FALSE; 
when others «> 
null; 

end case; 

case IN_CURRENT_SETnNGS.SECOND_ATTRIBUTE is 
when HOW_PRODUCED’VAL (5) => 

OKAY := FALSE; 
when others => 
null; 

end case; 

case IN_CURRENT_SETTINGS.THIRD_ATTRIBLriE is 
when ORGIN’VAL (5) I ORGIN’VAL (6) => 

OKAY := FALSE; 
when others => 
null; 
end case; 

case IN_CURRENT_SETnNGS J0URTH_ATTR1BUTE is 
when USAGE’VAL (1) => 

OKAY := FALSE; 
when others => 
null; 

end case; 


146 






case IN_aJRRENT_SETTINGS JTFTH.ATTRIBUTE is 
when 6eVEL0PMENT_STATUS’VAL (0) I DEVELOPMENT.STATUS’VAL (1) I 
DEVELOPMENT_sf ATUS’VAL (2) I DEVELOPMENT.STATUS’VAL (3) I 
DEVELOPMENT_STATUS’VAL (4) I DEVELOPMENT.STATUS’VAL (5) I 
DEVELOPMENT_STATUS’VAL (6) => 

OKAY := FALSE; 
when others a> 
null; 

end case; 


return OKAY; 
end CHECKED_OKAY_A; 


function CHECKED_OKAY_B (IN_CURRENT_SETnNGS : CURRENT_SETTINGS_TYPE) 
return boolean is 

OKAY : boolean ;= TRUE; 
begin 

case IN_CURRENT_SETrn^GS JTRST_ATIRIBUTE is 
when STMT.TYPE’VAL (3) I STMT.TYPE’VAL (4) I STMT.TYPE’VAL (5) I 
STMT.TYPE’VAL (6) I STMT.TYPE’VAL (7) => 

OKAY:* FALSE; 
when others *> 
null; 

end case; 

case IN_CURRENT_SETTINGS.THIRD_ATTRIBUTE is 
when ORGIN’VAL (5) I ORGIN’VAL (6) => 

OKAY:* FALSE; 
when others => 
null; 

end case; 

case IN_amENT_SETnNGS JOUTITH^ATTRIBUTE is 
whenUSAGE’VAL(l)=> 

OKAY:* FALSE; 
when others => 
null; 

end case; 

case IN_aJRRENT_SETTINGS JTFTH.ATTRIBUTE is 

when DEVELOPMENT_STATUS’VAL (0)' DEVELOPMENT STATUS’VAL (1) => 
OKAY := FALSE; 
when others => 


147 





null; 

end case; 
return OKAY; 
end CHECKED_OKAY_B; 


function CHECKED_OKAY_C (IN.CURRENT.SETTINGS ; CURRENT.SETTINGS.TYPE) 
return boolean is 

OKAY : boolean := TRUE; 
begin 

case IN_CXJRRENT_SETTINGSEIRST_ATTRIBUTE is 
when STMT_TYPE’VAL (5) I STMT_TYPE’VAL (6) I STMT_TYPE’VAL (7) => 

OKAY:* FALSE; 
when others *> 
null; 

end case; 

case IN_CURREhrr_SETTINGS.THIRD_ATTRIBUTE is 
when ORGIN’VAL (5) I ORGIN’VAL (6) => 

OKAY:* FALSE; 
when others *> 
null; 

end case; 

case IN_CmREOT_SETTTNGSEOURTH_ATrRIBUTE is 
whenUSAGE’VAL(l)=> 

OKAY:* FALSE; 
when others *> 
null; 

end case; 

case IN_CURREOT_SETTINGSEIFTH_ATTRIBUTE is 
when DEVELOPMENT_STATUS’VAL (0) I DEVELOPMENT_STATUS’VAL (1) I 
DEVELOPMENT_STATUS’VAL (2) I DEVELOPMENT.STATUS’VAL (3) I 
DEVELOPMENT_STATUS’VAL (4) I DEVELOPMENT_STATUS’VAL (5) I 
DEVELOPMENT_STATUS’VAL (6) *> 

OKAY:* FALSE; 
when others *> 
null; 

end case; 

return OKAY; 
end CHECKED_OKAY_C; 


148 




function CHECKED_OKAY_D (IN_CURRENT_SETTINGS : CURRENT_SETTINGS_TYPE) 
return boolean is 

OKAY : boolean := TRUE; 
begin 

case IN_CURRENT_SETnNGS JTRST.ATTRIBUTE is 
when STMT_TYPE’VAL (3) I STMT_TYPE’VAL (4) I STMT_TYPE’VAL (5) I 
STMT_TYPE’VAL (6) I STMT TYPE’VAL (7) => 

OKAY := FALSE; 
when others => 
null; 

end case; 

case IN_(:URREbrr_SETTINGS.THIRD_ATTRIBUTE is 
when ORGIN’VAL (5) IORGIN’VAL (6) => 

OKAY := FALSE; 
when others => 
null; 

end case; 

case IN_CXJRRENT_SETTINGSEOURTH_ATTRIBUTE is 
when USAGE'VAL (1) => 

OKAY ;= FALSE; 
when others s> 
null; 

end case; 

case IN_CURREOT_SETTINGSJIFTH_ ATTRIBUTE is 
when DEVELOPMENT.STATUS’VAL (0) I DEVELOPMENT_STATUS’VAL (1) I 
DEVELOPMENT.STATUS’VAL (2) I DEVELOPMENT_STATUS’VAL (3) I 
DEVELOPMENT.STATUS’VAL (4) I DEVELOPMENT_STATUS’VAL (5) 1 
DEVELOPMENT_STATUS’VAL (6) => 

OKAY := FALSE; 
when others => 
null; 

end case; 

return OKAY; 
end CHECKED_OKAY_D; 


function CHECKED_OKAY_E (IN_CURRENT_SETnNGS : CURRENT_SETTINGS_TYPE) 
return boolean is 


149 






OKAY : boolean := TRUE; 


begin 

case IN_CURREbn'_SETriNGS JTRST.ATTRIBUTE is 
when STNfT.TYPE’VAL (5) I STMT.TYPE’VAL (6) I STMT.TYHE’VAL (7) => 
OKAY:* FALSE; 
when others => 
null; 

end case; 

case IN_CURREbn:_SETriNGS.THIRD_ATTRIBl)TE is 
when ORGIN’VAL (5) I ORGIN’VAL (6) => 

OKAY:* FALSE; 
when others => 
null; 

end case; 

case IN_ajRREhn'_SETTINGS JOURTH.ATTRIBUTE is 
whenUSAGE’VAL(l)*> 

OKAY:* FALSE; 
when others *> 
null; 

end case; 

case IN CURRENT SETTINGSJIFTH ATTRIBUTE is 
when DEVELOPMENT STATUS’VAL (0) I DEVEI.OPMENT„STATUS’VAL (1) I 
DEVELOPMENT.STATUS’VAL (2) IDEVELOPMENT_STATUS'VAL (3) I 
DEVELOPMENT.STATUS’VAL (4) I DEVELOPMENT.STATUS’VAL (5) I 
DEVELOPMENT_STATUS’VAL (6) => 

OKAY:* FALSE; 
when others *> 
null; 

end case; 

return OKAY: 
end CHECKED_OKAY_E; 


function CHECKED_OKAY_F (IN_CURRENT_SETnNGS : CURRENT.SETTINGS.TYPE) 
return boolean is 

OKAY : boolean := TRUE; 

begin 


150 





case IN_aiRREOT_SETriNGS JTRST>TTRIBUTE is 

when STMT.TYPE’VAL (0) => 

if not GLOBAL JIECX)RD_FLAGS_FPANEL3JLINE_1 then 
OKAY := FALSE; 
end if; 

when STMT_TYPE’VAL (1) => 

if not GLOBALJlECORD_FLAGS_FJ’ANEL3XINE_3 then 
OKAY := FALSE; 
end if; 

when STMT_TYPE’VAL (2) => 

if not GLOBALJRECX3RD_FLAGS_FPANEL3J-INE_4 then 
OKAY := FALSE; 
end if; 

when STMT_TYPE’VAL (3) => 

if not GLOBALJlECORD_FLAGS_FPANEL3XINE_6 then 
OKAY := FALSE; 
end if; 

when STMT_TYPE'VAL (4) => 

if not GLOBALJiECX)RD_FLAGS_FPANEL31.INE_7 then 
OKAY := FALSE; 
end if; 

when STMT_TYPE’VAL (5) => 

if not GLOBAL JiECORD_FLAGS_FPANEL31.INE_8 then 
OKAY := FALSE; 
end if; 

when STMT_TYPE’VAL (6) => 

if net GLOBAL.RECX)RD_FLAGS_FPANEL3J-INE_9 then 
OKAY := FALSE; 
end if; 

when STMT.TYPE’VAL (7) => 

if not GLOBALPECORD_FLAGS_FPANE! .31.INE_10 then 
OKAY := FALSE; 
end if; 
end case; 

case IN_anGlEm'_SETnNGS.SECOND_ATTRIBUTE is 

when HOW_PRODUCED’VAL (0) => 
ifnotGLOBALPECORD_FLAGS_FPANEL4PINE_l then 
OKAY := FALSE; 
end if; 

when HOW_PRODUCED’VAL (1) => 
if not GLOBALPECORD_FLAGS_FPANEL4.LINE_2 then 
OKAY := FALSE; 
end if; 

when HOW.PRODUCED’VAL (2) => 
if not GLOBALJlECX)RD_FLAGS_FPANEL4PINE_3 then 
OKAY := FALSE; 
end if; 

when HOW.PRODUCED’VAL (3) => 
if not GLOBALPECORD_FLAGS_FPANEL4iINE_4 then 
OKAY := FALSE; 


151 






end if; 

when H0W_H10DUCED’VAL (4) => 
if not GLOBAL JIECX)RD_FLAGS_FPANEL41,INE_5 then 
OKAY:* FALSE; 
end if; 

when HOW.HIODUCED’VAL (5) => 
if not GLOBAL jyECORD_FLAGS_FPANEL41JNE_6 then 
OKAY:* FALSE; 
end if; 
end case; 


case IN_<:iJRRENT_SETTINGS.THlRD_ATTRIBlJTE is 

when ORGIN’VAL (0) => 

if not GLOBAL JlECORD_FLAGS_FPANEL51INE_l then 
OKAY:* FALSE; 
end if; 

when ORGIN’VAL (1) *> 

if notGLOBALPECORD_FLAGS_FPANEL5iINE_3 then 
OKAY;* FALSE; 
end if, 

when ORGIN’VAL (2) *> 

if not GLOBALPECORD_FLAGS_FPANEL5I.INE_4 then 
OKAY:* FALSE; 
end if; 

when ORGIN’VAL (3) => 

if not GLOBALPECX)RD_FLAGS_FPANEL51.INE_5 then 
OKAY:* FALSE; 
end if; 

when ORGIN’VAL (4) *> 

if not GLOBALPECORD_FLAGS_FPANEL5I.INE_6 then 
OKAY:* FALSE; 
end if; 

when ORGIN’VAL (5) => 

if not GLOBALPE(X)RD_FLAGS_FPANEL5JLINE_7 then 
OKAY:* FALSE; 
end if; 

when ORGIN’VAL (6) => 

if not GLOBALPECORD_FLAGS_FPANEL5J-INE_8 then 
OKAY;* FALSE; 
end if; 

when ORGIN’VAL (7) => 

if not GLOBAL jyECORD_FLAGS_FPANEL51-INE_9 then 
OKAY:* FALSE; 
end if; 

when ORGIN’VAL (8) => 

if not GLOBALPECORD_FLAGS_FPANEL5iINE_10 then 
OKAY;* FALSE; 
end if; 

when ORGIN’VAL (9) *> 

if not GLOBALPECX)RD_FL AGS_FPANEL5LINE_11 then 


152 






OKAY := FALSE: 
end if; 

when ORGIN’VAL (10) => 

if not GLOBAL JiECORD_FLAGS_FPANEL51.INE_12 then 
OKAY := FALSE; 
end if; 
end case; 

case IN_CmREhn’_SETnNGS JOURTO.ATTRIBUTE is 

whenUSAGE’VAL(0)=> 

if not GLOBAL JlECORD_FLAGS_FPANEL6I-INE_l then 
OKAY := FALSE; 
end if; 

when USAGE’VAL(1)=> 

if not GLOBAL J?ECORD_FLAGS_FPANEL6XINE_2 then 
OKAY ;= FALSE; 
end if; 
end case; 

case IN.OJWlEhn'.SETTlNGS J1FTH_ATTRIBIJTE is 

when DEVELOPMENT.STATUS’VAL (0) => 
ifnotGLOBALJlECORD_FLAGS_FPANEL9iINE_l then 
OKAY := FALSE; 
end if; 

when DEVELOPMENT.STATUS’VAL (1) => 
if not GLOBALPECoi^_FLAGS_FPANEL9LINE_2 then 
OKAY := FALSE; 
end if; 

when DEVELOPMENT.STATUS’VAL (2) => 
if not GLOBALPECO^_FLAGS_FPANEL9ilNE_3 then 
OKAY := FALSE: 
end if; 

when DEVELOPMENT_STATUS’VAL (3) => 
if not GLOBALPECORD_FLAGS_FPANEL9XINE_4 then 
OKAY ;= FALSE; 
end if; 

when DEVELOPMENT_STATUS’VAL (4) => 
if not GLOBALPECORD_FLAGS_FPANEL9.LINE_5 then 
OKAY ;= FALSE; 
end if; 

when DEVELOPMENT.STATUS’VAL (5) => 
if not GLOBALPECORD_FLAGS_FPANEL9iINE_6 then 
OKAY := FALSE; 
end if; 

when DEVELOPMENT_STATUS’VAL (6) => 
if not GLOBALPECX)RD_FLAGS_FPANEL9I-INE_7 then 
OKAY := FALSE; 
end if; 

when DEVELOPMENT_STATUS’VAL (7) => 
if not GLOBAL.RECORD_FLAGS_FPANEL9iINE_8 then 
OKAY ;= FALSE; 


153 





end if, 
end case; 


return OKAY; 
end CHECKED_OKAY_F; 


procedure PARSE_SPECIAL_LINE (LENGTH : in integer, 
POINTER_l : in out positive; 

RETURN_VALUE ; ait integer, 
PARSE_STRING : in out string) is 

POINTER_2 ; positive; 

NOT.FOI^ ; boolean := FALSE; 

PARSE_STRING_2 : string (1.^) := (others => ‘ ‘); 

TEMP_INT : integer, 

begin 

while na NOT_FOUND and POINTER_l <= (LENGTH -').) loop 
if PARSE_STRING (POINTER.l.. POINTER.! + 3) = “ => “ then 
POINTER.! := POINTER.! + 4; 

POINTER_2 ;= POINTER.! + I; 

whi!e not NOT.FOUND and POINTER_2 <= LENGTH loop 
if PARSE.STRING (POINTER_2) = or 
PARSE.STRING(POINTER_2) = “ then 
PARSE_STRING_2 (POINTER.! - (POINTER.! -!).. 
(roiNTER.2 - POINTER.!)) 

:= PARSE.STRING (POINTER.!.. POINTER.2 -1); 
TEMP.INT := integer’VALUE (PARSE.STRING_2); 
RETURN.VALUE ;= TEMP.INT; 

PARSE_STRING_2 ;= (others => ‘ *); 

NOT.FOUND ;= TRUE; 
else 

POINTER_2 := POINTER.2 + 1; 
end if; 
end loop; 

else 

POINTER.! := POINTER.! + !; 
end if; 

end !oop; 


end PARSE.SPECIAL.LINE; 





procedure PARSE_SPECIAL_COMMENT (IN_NIJM ; in integer; 

IN_LENGTH: in integer; 

IN_STRING ; in string) is 

TEMP_STRING : string (1.. 1024) := M.STRING; 

EXEC.TEMP, 

DEC.TEMP, 

PRAGMA_TEMP : natural := 0; 

OFFSET : positive; 

OFFSET_l : positive ;= 13; 

OFFSET_2 : positive := 26; 

OLD.SETTINGS : CURRENT_SETnNGS_TYPE := CURRENT.SETTINGS; 


begin 

ifIN_NUM<0then 
OFFSET ;= OFFSET_l; 

CURREbrr_SETTINGS.SECOND_ATTRIBirrE := HOW.PRODUCED’val (5); 
else 

OFFSET ;= OFFSET_2; 

CURRENT_SETTINGS.FIFTH_ATTRIBIJTE := DEVELOPMENT_STATUS’val (0); 
end if; 

if IN_LENGTH>Othen 

-- Now looking for the number associated with Executables 
PARSE_SPECIAL_LINE (IN.LENGTH, 

OFFSET, 

EXEC.TEMP, 

TEMP_STRING); 

Cl«REbrr_SETTINGSJTRST_ATTRIBUTE := STMT_TYPE’val (0); 
if CHECK_REPORT_A_E then 

GLOBAL.DETERhflNE.WHICH.ARRAY (IN_RECORD => CURRENT.SETTINGS, 
ADD_NUMBER => EXEC_TEMP); 

end if; 

if CHECK_REPORT_F then 

if CHECKED_OKAY_F (CURRENT.SETTINGS) then 
COUNT_LINE (CURRENT_SETTINGS, COUNT_ARRAY_F, EXEC.TEMP); 
end if; 
end if; 


- Now need to find the number associated for Declarations 
PARSE_SPECIAL_LINE (IN.LENGTH, 

OFFSET, 

DEC_TEMP, 

TEMP_STRING); 


aJRRENT_SETTINGSJIRST_ATTRIBUTE ;= STMT_TYPE’val (1); 
if CHECK_REPORT_A_E then 


155 




GLOBAL.DETERMINE_WHICH_ARRAY (IN_RECORD => CURRENT.SETnNGS, 
ADD_NUMBER => DEC.TE^); 

end if; 

if CHECK_REPORT_F then 

if CHECKED_OKAY_F (CURRENT.SETITNGS) then 
COtINT_LI^ (CURRENT_SETTINGS. COlJNT_ARRAY_F, DEC_TEMP); 
end if; 
end if; 

- Now need to find the number associated for Compiler Directives 
PARSE_SPECIAL_LINE (IN.LENGTH. 

OFFSET, 

PRAGMA_TEMP. 

TEMP.STOING); 

aJRRENr_SETTINGSfIRST_ATTRIBUTE ;= STMT_TYPE’val (2); 
if CHECK_REPORT_A_E then 

GLOBAL.DETERMINE_WHICH_ARRAY (IN_RECORD => CURRENT_SETnNGS, 
ADD_NUMBER => PRAGMA.TEMP); 

end if; 

if CHECK_REPORT_F then 

if CHECKED_OKAY_F (CURRENT.SETTINGS) then 

COUNT_LINE (CU^NT_SETTINGS, COUNT_ARRAY_F. PRAGMA_TEMP); 
end if; 
end if; 

CURRENT.SETTINGS ;= OLD.SETITNGS; 


end if; 

end PARSE_SPECIAL_COMMENT; 


procedure DETERMINE_WHICH_ARRAY (IN_RECORD : in 
CURRENT_SETnNGS_TYPE; 

ADD_NUMBER: in natural ;= 1) is 


begin 


if RECORD_FLAGS.PANEL2.REPORT_A then 
if CHECKED_OKAY_A (IN_RECORD) then 
COUNT.LINE (IN.RECORD, COUNT_ARRAY_A, ADD.NUMBER); 
end if; 
end if; 


if RECORD_FLAGS.PANEL2JlEPORT_B then 
if CHECKED_OKAY_B (IN_RECORD) then 


156 





COUNT_LINE (IN.RECORD. COUNT_ARRAY_B. ADD_NUMBER): 
end if; 
end if; 


if RECORD_FLAGSPANEL2REPORT_C then 
if CHECKED_OKAY_C (IN.RECORD) then 
COUNT.LINE (IN.RECORD, COUNT.ARRAY.C, ADD.NUMBER); 
end if; 
end if; 

if RECORD.FLAGS.PANEL2JlEPORT_D then 
if CHECKED.OKAY.D (IN.RECORD) then 
COUNT.LINE (IN.RECORD. COUNT.ARRAY.D, ADD.NUMBER); 
end if; 
end if; 

if RECORD.FLAGS.PANEL2JtEPORT.E then 
if CHECKED.OKAY.E (IN.RECORD) then 
COUNT.LINE (IN.RECORD, COUNT.ARRAY.E, ADD.NUMBER); 
end if; 
end if; 


end DETERMINE.WfflCH.ARRAY; 


procedure COUNT.LINE (IN.RECORD : in CURRENT.SETTINGS.TYPE; 
ARRAY.TYPE: in out COUNT.ARRAY.TYPE; 
ADD.NUMBER: in natural := 1) is 


TEMP : natural := 0; 


begin 


TEMP := ARRAY.TYPE (IN.RECORDJTRST.ATTRIBUTE, 
IN.RECORD.SECOND_ATTRIBUTE. 
IN.RECORD.THIRD.ATTRIBUTE, 
IN.RECORDPOURTH.ATTRIBUTE, 
IN.RECORD.FIFTH.ATTRIBUTE); 

TEMP := TEMP + ADD.NUNfflER; 

-put(“+TEMP+”); 

-put (integer’image(temp)); 

ARRAY.TYPE (IN.RECORDJFIRST.ATTRIBUTE, 
IN.RECORD.SECOND.ATTRIBUTE, 
IN.RECORD.THIRD.ATTRIBUTE, 

IN.RECORD JOURTH.ATTRIBUTE, 

IN.RECORDJTFTH.ATTRIBUTE) ;= TEMP; 
end COUNT.LINE; 


157 





r 


procedure ADD_TO_ARRAY_A_E (IN_CURRENT_SETTINGS : in out 
CURRENT.SE'nTNGS.TYPEl is 

ADDED_TO_ARRAY : boolean := false; 

begin 

for I in PRIORrTY_ARRAY_A_E’range loop 
fw J in STMT_TYPE loop 

- Found the statement type with the highest priority 

- Conditions: 

— Start flag is tnie, stop flag is true, ADDED_TO_ARRAY is false. 

- Actions: 

- Set ADDED_TO_ARRAY to true; set the FIRST_ATTRIBUTE to the 

- current STATEMENT_TYPE (J); set both the 

-• start and stqr flag of the current statement type to false, 
if PRIORITY_ARRAY_A_E (1) = J and 
FLAGS.ARRAY (J, 1) and 

FLAGS_ARRAY (J, 2) and 

not (ADDED_TO_ARRAY) then 

IN_ajIWEhn'_SETWGS JnORST^TlTUBU^ := J; 
DETERMINE_WfflCH_ARRAY (IN.RECORD => IN_CURRENT_SETnNGS); 
ADDED_TO_ARRAY := true; 

“ Found die statement type with the highest priority 
" that extends over two or more lines. 

-- Conditions; 

- Start flag is true, stop flag is false, ADDED_TO_ARRAY is false. 

" Actions; 

- Set ADDED_TO_ARRAY to true; set the FIRST_ATTRIBUTE to the 

- current STATENffiNT_TYPE (J); 

elsif PRIORTTY.ARRA Y_A_E (I) = J and 
FLAGS_ARRAY(J,1) and 
notFLAGS_ARRAY(J,2) and 
not ADDED_TO_ARRAY then 
IN_CIJRRENT_SETTINGS.FIRST_ATTRIBUTE := J; 

ADDED_TO_ARRAY := TRUE; 

DETERMINE_WfflCH_ARRAY (IN_RECORD => IN.CURRENT.SETTINGS); 
end if; 

end loop; 

end loop; 


158 






ead ADD_TO_ARRAY_A_E; 


procedure ADD_TO_ARRAY_F (TN.CURRENT.SETTINGS : in out 
CURRENT_SE’mNGS_TYPE) is 

ADDED_TO_ARRAY ; boolean := false; 

begin 

for I in PRIORITY_ARRAY_F’range loop 
for J in STMT_TYPE loop 

- Found the statement type with the highest priority 

- Conditions: 

“ Start flag is true, stop flag is true, ADDED_TO_ARRAY is false. 

“ Actions: 

- Set ADDED_TO_ARRAY to true; set the FIRST_ATTRIBUTE to the 
-- current STATEMENT_TYPE (J); call the procedure COUNT_LINE 

- which will add this line to the total; set both the 

- start and stop flag of the current statement type to false, 
if PRIORITY.ARRAY_F (I) = J and 

FLAGS.ARRAY (J, 1) and 
FLAGS.ARRAY (J. 2) and 
not (ADDED_TO_ARRAY) then 

IN CURRENT SETTINGSJIRST ATTRIBUTE:*!; 
if CHECKED_OKAY_F (IN.CURRENT.SETnNGS) then 
GLOBAL.COUNT_LINE (IN.CURRENT.SETTINGS, COUNT_ARRAY_F); 
end if; 

ADDED_TO_ARRAY := true; 

-- Found the statement type with the highest priority 

- that extends over two or more lines. 

- Conditions: 

“ Start flag is true, stop flag is false, ADDED_TO_ARRAY is false. 

“ Artions: 

“ Set ADDED_TO_ARRAY to true; set the FIRST.ATTRIBUTE to the 

- current STATEMENT.TYPE (J); and call the procedure COUNT.LINE 

- which will add this line to the total, 

elsif PRIORITY_ARRAY_F (I) = J and 

FLAGS.ARRAY (J,l) and 
notFLAGS_ARRAY(J,2) anJ 
not ADDED_TO_ARRAY then 
IN_CURRENT_SETTINGS.FIRST_ATTRIBUTE := J; 

ADDED_TO_ARRAY := TRUE; 

if CHECKED_OKAY_F (IN_CURRENT_SETnNGS) then 
GLOBAL.COUNT.LINE ON.CURRENT.SETTINGS, COUNT_ARRAY_F); 
end if; 


159 






end if; 


endkx^; 
end loop; 

end ADD_TO_ARRAY_F; 


procedure ADD_TO_ARRAY u 
CURRENT_SETTINGS_A_E. 

CURRENT_SETnNGS_F : CURRENT.SETITNGS.TYPE := CURRENT.SETTINGS; 
begin 

if nor SPECIAL_COMMENT then 

if FLAGS_ARRAY(STMT_TYPE’val(0).l) and 
not FLAGS.ARRAY (STMT_TYPE’val (0). 2) then 
EXECLEVEL := EXECLEVEL + 1; 
dsif not FLAGS.ARRAY (STMT.TYPE’val (0). 1) and 
FLAGS_ARRAY(STMT_TYPE’val(0).2) then 
FLAGS_/5 iRAY (STMT.TTPE’val (0), 1) := TRUE; 

EXEGLivEL ;= EXECLEVEL -1; 
ifEXECLEVEL<Othen 

put_line(“Waniing; execution parsing is confused”); 
end if; 

elsif EXECLEVEL > 0 then 
FLAGS.ARRAY (STMT.TYPE’val (0). 1) := TRUE; 
else 
null; 
end if; 

if FLAGS_ARRAY (STMT.TYPE’val (1), 1) and 
not FLAGS.ARRAY (STMT.TYPE’val (1). 2) then 
DECLEVEL := DECLEVEL + 1; 
elsif not FLAGS.ARRAY (STMT.TYPE’val (1), 1) and 
FLAGS.ARRAY (STMT.TYPE’val (1), 2) then 
FLAGS.ARRAY (STMT.TYPE’val (1), 1) := TRUE; 

DECLEVEL := DECLEVEL - 1; 
if DECLEVEL <0 then 

put_line(“Waming: declaration parsing is confused”); 
end if; 

elsif DECLEVEL > 0 then 

FLAGS.ARRAY (STMT.TYPE’val (1), 1) := TRUE; 
else 
null; 
end if; 


160 





if FLAGS_ARRAY (STMT_TYPE’val (2). 1) and 
not FLAGS.ARRAY (STMT.TYre’val (2). 2) then 
PRAGMAUEVEL := PRAGMALEVEL + 1; 
clsif not FLAGS.ARRAY (STMT_TYre*val (2). 1) and 
FLAGS_AR^Y (STMT.TYPE'val (2). 2) then 
FLAGS. ARRAY (STMT.TYPE’val (2). 1) := TRUE; 
PRAGMALEVEL ;= PRAGMALEVEL -1; 
elsif PRAGMALEVEL > 0 then 
FLAGS.ARRAY (STMT.TYPE’val (2). 1) := TRUE; 
else 
null; 
end if; 

- Debugging statements to help Egiue out the three 

- variables used to track multiline flags 

--put (“[“); 

--put (integer’image(execlevel)); 

-put (“]”); 

-put (“[“); 

-put (integer’image(declevel)); 

-put ("]”); 

-put (“[“); 

-put (integer’image(iHagmalevel)); 

-put (“]”); 


- Checking for full line code 
if FLAGS.ARRAY (STMT.TYPE’val (3), 1) then 
CmREm'.SETTINGS.FIRST.ATmiBUTE := STMT.TYPE’val (3); 
DE’IERMINE.WHICH.ARRAY (IN.RECORD => CURRENT.SETTINGS); 

if CHECK.REPORT.F then 
if CHECKED.OKAY.F (CURRENT.SETTINGS) then 
GLOBAL.COUNT.LINE (CURRENT.SETTINGS, COUNT.ARRAY.F); 
end if; 
end if; 

elsif FLAGS.ARRAY (STMT.TYPE’val (5). 1) then 
CURRENT.SETTINGS.FIRST.ATTRIBUTE := STMT.TYPE’val (5); 
DETERMINE.WfflCH.ARRAY (IN.RECORD => CURRENT.SETTINGS); 

if CHECK.REPORT.F then 

if CHECKED.OKAY.F (CURRENT.SETTINGS) then 
GLOBAL.COUNT.LINE (CURRENT.SETTINGS, COUNT.ARRAY.F); 
end if; 
end if; 

elsif FLAGS.ARRAY (STMT.TYPE’val (6), 1) then 
CTJRRENT.SETTINGS.FIRST.A’rTRIBUTE := STMT.TYPE’val (6); 
DETERMINE.WHICH.ARRAY (IN.RECORD => CURRENT.SETTINGS); 


161 




if CHECK_REPORT_F then 

if CHECKED_OKAY_F (CURRENT.SETTINGS) then 
GLOBAL.COUNT_LINE (CURRENT_SETnNGS. COUNT_ARRAY_F); 
end if; 
end if; 

elsif FLAGS>RRAY (STMT.TYPE’val (7). 1) then 
CURRENT.SETTINGS JTRST.ATTRIBUTE := STMT.TYPE’val (7); 
DETEimil^_WHICH_ARRAY (IN_RECORD => CURRENT_SETTINGS); 

if CHECK_REPORT_F then 

if CHECKED.OKAY.F (CURRENT.SETTINGS) then 
GLOBAL.COUNT_LINE (CURRENT_SETnNGS. COUNT_ARRAY_F); 
end if; 
end if; 

else 

if CHECK_REPORT_A_E then 
ADD_T0_ARRAY_A_E (CURRENT_SETnNGS_A_E); 
end if; 

if CHECK_REPORT_F then 
ADD_TO_ARRAY_F (CURRENT.SETTINGS.F); 
end if; 

end if; 

else 

SPECIAL.COMMENT ;= FALSE; 
end if; 

~ for insurance, clear apprqxiate flags before processing the next line 
for i in STMTJTYPE’first.. STMT_TYPE’last loop 
FLAGS.ARRAYa.l) := FALSE; 

FLAGS_ARRAYa.2) := FALSE; 
end loop; 

end ADD_TO_ARRAY; 


(Htx^edure INIT_RECORD_FLAGS is 
begin 

RECORD_FLAGS.PANEL6.DEL_OPnON (l)(my_value’range) := (others => ‘ ‘) 
RECORD_FLAGS.PANEL6.DEL_OPnON (IKl •• 19) := “DeUvered as source”; 

end INIT_RECORD_FLAGS: 


162 





procedure INIT_RECORD_FLAGS_B is 
begin 


RECORD_FLAGS_B.PANEL4iINE_6 := TRUE 
RECORD_FLAGS_B.PANEL9UNE_3 := TRUE 
RECORD_FLAGS_B.PANEL9iINE_4 ;=TRUE 
RECX)RD_FLAGS_B.PANEL9IJNE_5 ;=TRUE 
RECORD_FLAGS_B.PANEL9 JLINE_6 := TRUE 
RECORD_FLAGS_B.PANEL9JJNE_7 := TRUE 


end INIT_RECORD_FLAGS_B; 


procedure INIT_RECORD_FLAGS_C is 
begin 

RECORD_FLAGS_C.PANEL3iINE_6 := TRUE 
RECORD_FLAGS_C.PANEL3iINE_7 :=TRUE 
RECORD_FLAGS_C.PANEL41iNE_6 := TRUE 


end INIT_RECORD_FLAGS_C: 


procedure INIT_RECORD_FLAGS_D is 
begin 

RECORD_FLAGS_D.PANEL4XINE_6 ;= TRUE; 
end INrr_RECORD_FLAGS_D; 


procedure INIT_RECORD_FLAGS_E is 
begin 

RECORD_FLAGS_EPANEL3iINE_6 := TRUE; 
RECORD_FLAGS_EPANEL3.LINE_7 := TRUE; 
REC0RD_FLAGS_EPANEL4.LINE_6 := TRUE; 


end INIT_RECORD_FLAGS_E; 


163 








procedure INn'_RECORD_FLAGS_F is 
begin 

RECORD_FLAGS_F := RECORD_FLAGS; 
end INIT_RECORD_FLAGS_F; 

begin 

INTT RECORD.FLAGS; 

INIT_RECORD_FLAGS_B: 

INIT_RECORD_FLAGS_C: 

INIT_RECORD_FLAGS_D: 

INIT_RECORD_FLAGS_E; 

INrr_RECORD_FLAGS_F; 

end Global; 


164 





COUNT TOOL PKG 


'-•_Pn)grammed 
with GLOBAL, 

TAE, 

PARSER, 
ADA_LEX_IO, 
ADA_LEX. 
REPORT.PACKAGE, 
TEXTJO; 
use TAE, 

TEXTJO; 


package TOOL_PACKAGE is 


procedure SET_PRECEDENCE_F; 
procedure SET_PRECEDENCE_A_E; 
procedure START_COUNT: 


end TOOL.PACKAGE; 


-*J*rogrammed 


package body TOOL_PACKAGE is 

INITIAL.TYPE : GLOBAL.STMT_TYPE; 

INrnAL_PRIORITY : TAE.TAEINT; 

package TAE_INTEGER_IN_OUT is new integerjo (TAE.TAEINT); 
use TAE_INTEGER .IN_OUT; 

package INTEGER_IN_OUT is new integerjo (integer); 
use INTEGER_IN_OUT; 

package ENUMERATION_IN_OUT is new ENUMERATION JO (GLOBAL.STMT_TYPE); 
use ENUMERATION_IN_OUT; 


procedure DETERMINE_PRIORITY (A : in GLOBAL.STMT_TYPE; 
B :in TAE.TAEINT; 

C : in out GLOBAL.STMT_TYPE; 


165 






D : in out TAE.TAEINT) is 


begin 

if (D > B and B /= 0) or D = 0 then 
C:= A; 

D:= B; 
end if; 

end DETERMINE_PRIORITY; 


procedure SET_PRECEDENCE_F is 
TEMP_TYPE : GLOBAL.STMT_TYPE; 
begin 

FOR I in GLOBAL.PRIORm_ARRAY_F’range loop 


INmAL_TYPE := GLOBAL.STMT_TYPEVal(0): 

INmAL.PRIORITY := GLOBALRECORD_FLAGS_F.PANEL3XINE_l_lNT; 

DETERMINE.PRIORITY (GLOBAL.STMT_TYPE’val(0), 

GLOBAL JlECORD_FLAGS_FPANEL3XINE_l_INT. 
INmAL.TYPE, 

INrnAL.PRIORITY); 

DETERMINE.PRIORITY (GLOBAL.STMT_TYPE’val(l). 

GLOBALRECORD_FLAGS_FPANEL3XINE_3_INT. 

INniAL_TyPE, 

INmAL_PRIORITY); 

DETERMINE.PRIORITY (GLOBAL.STMT_TYPE’val(2). 

GLOBALPECORD_FLAGS_FPANEL3iINE_4_INT, 

INITIAL.TYPE, 

INmAL.PRIORITY); 

DETERMINE.PRIORITY (GLOBAL.STMT_TYPE’val(3), 

GLOBAL JlECORD_FLAGS_F.PANEL3.LINE_6_INT, 
INITIALjrYPE, 

INITIAL.PRIORITY); 

DETERMINE_PRIORITY (GLOBAL.STMT_TYPE’val(4), 

GLOBAL JlECORD_FLAGS_FPANEL3.LI>}E_7_INT, 

INITIAL_TYPE. 

iNmAL.PRiORrry); 

DETERMINE.PRIORITY (GLOBAL.STMT_TYPE’val(5). 

GLOBALPECORD_FLAGS_FPANEL3XINE_8_INT, 

INmAL_TYPE, 

INTnAL.PRIORITY); 

DETERMINE_PRIORITY (GLOBAL.STMT_TYPE’val(6), 

GLOBAL JlECORD_FLAGS_FPANEL3XINE_9_INT, 
INrnAL_TYPE, 


166 





INITIAL_PRIORITY): 

DETERMINE.PRIORITY (GLOBAL.STMT_TYPE’val(7). 

GLOBAL JlECORD_FLAGS_FPANEL3iir'fE_10_INT. 
IN1TIAL_TYPE. 

INITIAL_PRIORITY); 

case INmAL_TYPE is 
when GLOBAL.STMT_TYPE’vaI(0) => 
newjine (2); 

put (GLOBAL.STMT_TYPE’vaI(0)): 
put C‘ is priority: “); 

put (GLOBAL.RECORD_FLAGS_FPANELS.LINE. 1_INT); 
newjine; 

GLOBAL.RECORD_FLAGS_F.PANEL3iINE_l_INT := 0; 
when GLOBAL.STMT_TYPE’val(l) => 
put (GLOBAL.STMT_TYPE’val(l)); 
put C‘ is priority: “) 

put (GLOBAL.RECORD_FLAGS_F.PANEL3 .LINE_3_INT): 
newjine: 

GLOBAL.RECORD_FLAGS_F.PANEL3.LINE_3_INT := 0; 
when GLOBAL.STMT_TYPE’val(2) => 
put (GLOBAL.STMT_TYPE’val(2)); 
put (“ is priority: “); 

put(GLOBAL.RECORD_FLAGS_FPANEL3.LINE_4_IND; 

newjine; 

GLOBAL.RECORD_FLAGS_F.PANEL3iINE_4_INT := 0; 
when GLOBAL.STMT_TyPE’val(3) => 
put (GLOBAL.STMT_TYPE’val(3)); 
put (“ is priority; “): 

put(GLOBAL.RECORD_FLAGS_F.PANEL3.LINE_6_INT); 

newjine; 

GLOBAL.RECORD_FLAGS_F.PANEL3.LINE_6_INT := 0; 
when GLOBAL.STMT_TYPE’val(4) => 
put (GLOBAL.STMT_TYPE’val(4)); 
put (“ is priority: “); 

put(GLOBAL.RECORD_FLAGS_FPANEL3.LINE_7_INT); 

newjine; 

GLOBAL.RECORD_FLAGS_F.PANEL3.LINE_7_INT := 0; 
when GLOBAL.STMT_TYPE’val(5) => 
put (GLOBAL.STMT_TYPE’val(5)); 
put (“ is priority: “); 

put(GLOBAI..RECORD_FLAGS_F.PANEL3.LINE_8_INT); 

newjine; 

GLOBAL.RECORD_FLAGS_F.PANEL3.LINE_8_INT := 0; 
when GLOBAL.STMT_TYPE’val(6) => 
put (GLOBAL.STMT_TYPE’vaI(6)); 
put (“ is priority: “); 

put(GLOBAL.RECORD_FLAGS_FPANEL3.LINE_9_INT): 

newjine; 

GLOBAL.RECORD_FLAGS_FPANEL3PINE_9_INT := 0: 
when GLOBAL.STMT_TYPE’val(7) => 


167 






put {GL0BAL.STMT_TYPE’val(7)); 
put C is priority: “); 

put (GLOBAL.RECORD_FLAGSJFPANEL3.LINE_10_INT); 
new_line (2); 

GLOBALJtECORD_FLAGS_F.PANEL3iINE_10_INT := 0; 
end case; 

GLOBAL.PRIORrrY_ARRAy_F a) := INTTIAL.TYPE; 
end loop; 

end SET_PRECEDENCE_F; 


procedure SET_PRECEDENCE_A_E is 
begin 

GLOBAL.PRIORITY_ARRAY_A_E (1) := GLOBAL.STMT_TYPE’val(0) 
GLOBAL.PRIORITY_ARRAY_A_E (2) := GLOBAL.STMT_TYPE’val(l) 
GLOBAL.PRIORITY_ARRAY_A_E (3) := GLOBAL.STMT_TYPE’val(2) 
GLOBAL.PRIORrrY_ARRAY_A_E (4) := GLOBAL.STMT_TYPE’val(3) 
GLOBAL.PRIORrrY_ARRAY_A_E (5) := GLOBAL.STMT_TYPE’va](4) 
GLOBAL.PRIORITY_ARRAY_A_E (6) := GLOBAL.STMT_TYPE’val(5) 
GLOBAL.PRIORITY_ARRAY_A_E (7) ;* GLOBAL.STMT_TYPE’val(6) 
GLOBAL.PRIORrrY_ARRAY_A_E (8) := GLOBAL.STMT TyPE’val(7) 

end SET.PRECEDENCE.A.E; 


procedure GET_FILE_NAME (OUT_FILE_NAME : out string; 
OUT_NAME_LENGTH; out integer, 

F : in out file_type) is 

TEMP_NUMBER : integer :=0; 

TEMP_NAME : string (1 .. 80) := (others => ‘ ‘): 
N0T_BLANK : boolean := TRUE; 

begin 

if not end_of_fUe (F) then 
getjine (F, TEMP_NAME, TEMP_NUMBER); 

while N0T_BLANK loop 
if TEMP.NAME (TEMP_NUMBER) = ‘ ‘ then 
TEMP NUMBER := TEMP NUMBER - 1; 






else 

NOT_BLANK ;= FALSE; 
end if; 
end loop; 

end if; 

OUT_FILE_NAME := TEMP_NAME; 
OUT_NAME_LENGTH := TEMP.NUMBER; 

-put (“the name of the file to opened is: “); 
-put_line (temp_name); 

-put (“the file name is this long; “); 

-put (temp_number, width => 3); 

-newjine; 

end GET_FILE_NAME; 


procedure START_PARSE is 
IS_Fn-ELIST ; boolean; 

FILELIST : GLOBAL.MY_VALUE := GLOBALJiECORD_FLAGS. 

PANEL2.IN_FE-E_NAME; 

LENGTH ; integer, 

FILE_NAME ; string(L.80); 

LAST : integer ;* 0; 

FILE_LIST_NAME : string (1.. 1024) := (others => ‘ *): 

F : file_type; 

begin 

LENGTH ;= GLOBAL.FIND_LENGTH (FILELIST); 

FILE_LIST_NAME(1.LENGTH) := FILELIST (1) (1..LENGTH); 

open (F, in_file, FILE_LIST_NAME (L.LENGTH)); 

while not END_OF_FILE (F) loop 

GET_FILE_NAME (FILE.NAME, LAST, F); 

ADA_L£X_IO.OPEN_INPUT (FILE_NAME (1..LAST)); 
ADA_LEX_IO.CREATE_OUTPUT; 

new_line; 

put_line(“ Starting parse “); 

ADA_LEX.linenum; 

PARSER.yyparse; 


169 






new_line; 

put_lineC‘ Finished parse “); 


ADA_LEX_IO.CLOSE_INPUT; 

ADA_LEXJO.CLOSE_OinPUT: 

end loop; 

endSTART.PARSE; 


procedure START_COUNT is 
begin 

SET_PRECEDENCE_A_E: 

if GLOBAL JlECORD_FLAGSJ>ANEL2.REPORT_F then 
SET_PRECEDENCE_F; 
end if; 

GLOBAL.OPEN_OUT_FILE; 

START_PARSE; 

REPORT_PAaCAGE.DETERMINE_WHICH_REPORT; 
endSTART.COUNT; 
end TOOL.PACKAGE; 


170 




REPORT PKG S.A 


--♦_Piogrammed 


with GLOBAL, 

TAE, 

TEXTJO, 

GENERIC.COUNTS; 
use TAE, 

GLOBAL, 

TEXTJO; 


package REPORT_PACKAGE is 

type TYPE_NUMBER_TYPE is range 1.. 5; 

T2_NUMBER : TYPE_NUMBER_TYPE; 

type NAME_REPORT_TYPE is (REPORT_A, REPORT_B. REPORT.C, 
REPORT.D, REPORT_E, REPORT_F); 
REPORT_NAME ; NAME_REPORT_TYPE; 

procedure DETERMINE_WHICH_REPORT; 

function RETRIEVE_2D_1(TYPE_1 : STMT_TYPE; 

TYPE_2 : HOW_PRODUCED; 

TYPE_3 : ORGEN; 

TyPE_4 ; USAGE; 

TYPE_5 : DEVELOPMENT_STATUS; 

TYPE_6 : NAME_REPORT_TYPE) return natural; 

function RETRIEVE_2D_2(TYPE_I : STMT_TYPE; 

TYPE_2 ; USAGE; 

TYPE_3 : HOW.PRODUCED; 

TYPE_4 : ORGIN; 

TYPE_5 : DEVELOPMENT_STATUS; 

TYPE_6 : NAME_REPORT_TYPE) return natural; 

function RETRIEVE_2D_3 (TYPE_1 : ORGIN; 

TYPE_2 : HOW_PRODUCED; 

TYPE_3 : STMT_TYPE; 

TYPE_4 : USAGE; 

TYPE_5 : DEVELOPMENT_STATUS; 

TYPE_6 ; NAME_REPORT_TYPE) return natural; 

function RETRIEVE_2D_4(TYPE_1 : ORGIN; 

TYPE_2 : STMT_TYPE; 

TYPE 3 ; HOW PRODUCED; 





TYPE_4 : USAGE; 

TYPE_5 : DEVELOPMENT_STATUS; 

TYPE_6 : NAME_REPORT_TYPE) return natural; 

function RETRIEVE_2D_5(TYre_l : ORGIN; 

TYPE_2 : USAGE; 

TYPE_3 ; STMT_TYPE; 

TYPE_4 : HOW_PRODUCED; 

TYPE_5 : DEVELOPMENT_STATUS; 

TYPE_6 : NAME_REPORT_TYPE) return natural; 

function RETRIEVE_2D_6(TYPE_1 : ORGIN; 

TYPE_2 : DEVELOPMENT_STATUS; 

TYPE_3 : STMT_TYPE; 

TYPE_4 : H0W_PR0DUCED; 

TYPE_5 : USAGE; 

TYPE_6 : NAME_REPORT_TYPE) return natural: 

function RETRIEVE_2D_7(TYPE_1 : USAGE; 

TYPE_2 ; HOW_PRODUCED; 

TYPE_3 ; STMT_TYPE; 

TYPE_4 ; ORGIN; 

TYPE_5 : DEVELOPMENT_STATUS; 

TYPE_6 : NAME_REPORT_TYPE) return natural; 

function RETRIEVE_2D_8 (TYPE_1 : DEVELOPMENT_STATUS; 
TYPE_2 : STMT.TYPE; 

TyPE_3 : HOW_PRODUCED; 

TYPE_4 : ORGIN; 

TYPE.S : USAGE; 

TYPE_6 : NAME_REPORT_TYPE) return natural; 

function RETRIEVE_2D_9(TYPE_I : DEVELOPMENT_STATUS: 
TYPE_2 ; USAGE; 

TYPE_3 ; STMT_TYPE; 

TYPE_4 : HOW_PRODUCED; 

TYPE_5 : ORGW; 

TYPE_6 ; NAME_REPORT_TYPE) return natural; 

function RETRIEVE_2D_10 (TYPE_1 : DEVELOPMENT.STATUS; 
TYPE_2 ; HOW_PRODUCED; 

TYPE_3 : STMT_TYPE: 

TYPE_4 : ORGIN; 

TYPE_5 : USAGE; 

TYPE_6 ; NAME_REPORT_TYPE) return natural; 

function RETRIEVE_3D_1 (TYPE_1 : USAGE; 

TYPE_2 : HOW_PRODUCED; 

TYPE_3 ; ORGIN; 

TYPE_4 ; STMTJTYPE; 

TYPE 5 : DEVELOPMENT STATUS; 






TYPE_6 : NAME_REPORT_TYre) return natural; 

function RETRIEVE_3D_2 (TYPE.l : USAGE; 

TYPE_2 : HOW_PRODUCED; 

TYPE_3 ; DEVELOPMENT_STATUS; 

TYPE_4 ; ORGIN; 

TYPE_5 : STMT.TYPE; 

TYPE_6 : NAME_REPORT_TYPE) return natural; 

function RETRIEVE_3D_3 (TYPE_1 : DEVELOPMENT_STATUS; 

TYPE_2 : HOW_PRODUCED; 

TYPE_3 : ORGIN; 

TYPE_4 : STMT.TYPE; 

TYPE_5 : USAGE; 

TYPE_6 ; NAME_REPORT_TYPE) return natural; 

function RETRIEVE_3D_4 (TYPE_1 ; DEVELOPMENT_STATUS; 

TYPE_2 : USAGE; 

TYPE_3 : ORGIN; 

TYPE_4 ; HOW.PRODUCED; 

TYPE_5 : STMT_TYPE; 

TYPE_6 : NAME_REPORT_TYPE) return natural; 

function CHECK_2D_1 return TYPE_NUMBER_TYPE; 

function CHECK_2D_2 return TYPE_NUMBER_TYPE; 

function CHECK_2D_3 return TYPE_NUMBER_TYPE; 

function CHECK_2D_4 return TYPE_NUMBER_TYPE; 

function CHECK_3D_1 return TYPE_NUMBER_TYPE; 

function CHECK_3D_2 return TYPE_NUMBER_TYPE; 

function CHECK_3D_3 return TYPE_NUMBER_TYPE; 

function CHECK_3D_4 return TYPE_NUMBER_TYPE; 

procedure HEADING_STMT_TYPE (ROW_POSITION: positive); 

procedure HEADING_ORGIN (ROW_POSmON : positive); 

procedure HEADING_US AGE (ROW_POSrnON ; positive); 

procedure HEADING_DEV_STATUS (ROW_POSinON : positive); 

package INTEGER_IN_OUT is new integer_io (integer); 
use INTEGER_IN_OUT; 

package ENUMERATION_IN_OUT is new ENUMERATIONJO (STMT_TYPE); 


173 




use ENUMERATION_IN_OUT; 


package RETRIEVE. 1_2D is new GENERIC.COUNTS (FIRST.TYPE s> STMT.TYPE, 

SECOND.TYPE => HOW.PRODUCED, 

THIRD.fvPE => ORGIN, 

FOUR-ni.TYPE => USAGE. 

FIFTH.TYPE => DEVELOPMENT.STATUS, 
reporttype =>NAME_REP0RT_TYPE, 
T_NUMBER_TYPE => TYPE_NUMBER_TYPE, 
rItRIEVE *>RETRIEVE_2D_1. 

CHECK_TYPE_2 => CHECK_2D_1. 

CHECK_TYPE_3 => CHECK_3D_1. 
PRINT_R0W_HEADING => HEADING_STMT_TYPE); 

package RETRIEVE_2_2D is new GENERIC.COUNTS (FIRST.TYPE => STMT.TYPE, 

SECOND.TYPE => USAGE. 

THIRD.TYPE => HOW.PRODUCED. 

FOUR'ra.TYPE => ORGIN. 

FIFTH.TYPE => DEVELOPMENT.STATUS. 
REPORT.TYPE => NAME_REPORT_TYPE. 
T_NUMBER_TYPE => TYPE_NUMBER_TYPE. 

RETRIEVE => RETRIEVE_2D_2. 

CHECK_TYPE_2 => CHECK_2D_3. 

CHECK_TYPE_3 => CHECK_3D_1. 
PRINT_ROW_HEADING => HEAD^JG.STMT.TYPE); 

package RETRIEVE_3 2D is new GENERIC.COUNTS (HRST.TYPE *> ORGIN. 

SECOND.TYPE => HOW_PRODUCED. 

THIRD.TYPE => STMT.TYPE. 

FOURTH.TYPE »> USAGE. 

FIFTH.TYPE => DEVELOPMENT.STATUS. 
REPORT.TYPE => NAME_REPORT_TYPE. 
T_NUMBER_TYPE => TYPE_NUMBER_TYPE. 

RETRIEVE => RETRIEVE_2D_3. 

CHECK_TYPE_2 => CHECK_2D_1. 

CHECK_TYPE_3 => CHECK_3D_2. 
PRINT_ROW_HEADING => HE^ING.ORGIN); 


package RETRIEVE_4_2D is new GENERIC.COUNTS (FIRST.TYPE => ORGIN. 

SECOND.TYPE => STMT.TYPE. 

THIRD.TYPE => HOW.PRODUCED. 
FOURTO.TYPE => USAGE. 

FIFTH.TYPE => DEVELOPMENT.STATUS. 
REPORT.TYPE => NAME_REPORT_TYPE. 
T_NUMBER_TYPE => TYPE_NUMBER_TYPE. 
RETRIEVE => RETRIEVE_2D_4, 

CHECK_TYPE_2 => CHECK_2D_2. 

CHECK_TYPE_3 => CHECK_3D_3. 
PRINT_ROW_HEADING => HE^ING.ORGIN); 

package RETRIEVE_5_2D is new GENERIC.COUNTS (FIRST.TYPE => ORGIN. 


174 






SECOND.TYPE => USAGE, 

THIRD_TYPE => STMT_TYPE. 
FOUR'm.TYPE *> HOW_PRODUCED. 
FIFTH.TWE => DEVELOPMENT_STATUS, 
REPORT_TYPE => NAME_REPORT_TYPE. 
T_NUMBER_TyPE => TYPi_NUMBER_TYPE. 
RETRffiVE => RETRIEVE_2D_5. 
CHECK_TYPE_2 => CHECK_2D_3. 
CHECK_TYPE_3 => CHECK_3D_2. 
PRINT_ROW_HEADING => HEADING.ORGIN); 


package RETRIEVE_6_2D is new GENERlC_COUNTS (FIRST_TYPE => ORGIN, 

SECOND.TYPE => DEVELOPMENT.STATUS, 
THIRD_TYPE => STMT.TVPE, 

FOURTH_TYPE => HOW_PRODUCED, 

FIFTH.TWE => USAGE, 

REPORT_TYPE => NAME_REPORT_TYPE, 
T_NUMBER_TYPE => TYPE_NUMBER_TYPE, 
RETRIEVE => RETRIEVE_2D_6, 

CHECK_TYPE_2 => CHECK_2D_4, 

CHECK_TYPE_3 => CHECK_3D_2, 
PRINT_ROW_HEADING => HEADING.ORGIN); 


package RETRIEVE_7_2D is new GENERIC.COUNTS (FIRST_TYPE => USAGE, 

SECOND_TYPE => HOW.PRODUCED, 

THIRD_TYPE => STMtJtYPE, 

FOURTH.TYPE *> ORGIN, 

FIFTH_TYPE => DEVELOPMENT.STATUS, 
REPORT.TYPE *> NAME_REPORT_TYPE. 
T_NUMBER_TYPE => TYPE_NUMBER_TYPE, 
RETRIEVE => RETRIEVE_2D_7, 

CHECK_TYPE_2 => CHECK_2D_1, 

CHECK_TYPE_3 => CHECK_3D_2, 
PRINT_ROW_HEADING => HEADING.USAGE); 

package RETRIEVE_8_2D is new GENERIC_COUNTS (FIRST_TYPE => 
DEVELOPMENT_STATUS, 

SECOND_TYPE => STMT_TYPE, 

THIRD_1TPE => HOW.PRODUCED, 

FOURTH_TYPE => ORGIN, 

FIFTH.TYPE => USAGE, 

REPORT_TYPE *> NAME_REPORT_TYPE. 
T_NUMBER_TYPE => TYPE_NUMBER_TYPE, 
RETRIEVE => RETRIEVE_2D_8, 

CHECK_TYPE_2 => CHECK_2D_2. 

CHECK_TYPE_3 => CHECK_3D_3. 
PRINT_ROW_HEADING => HEADING_DEV_STATUS); 

package RETRIEVE_9_2D is new GENERIC.COUNTS (FIRST TYPE => 
DEVELOPMENT.STATUS, 

SECOND_TYPE => USAGE, 


175 






r 


THIRD_TYPE => STMT_TYPE, 

FOURTH_TYPE => HOW.PRODUCED, 
FlFTH.TYre => ORGIN, 
reporxtype =>name_report_type, 

T_NUMBER_TYra => TYPE_NUMBER_TYPE, 
RiTRffiVE => RETRffiVE_2D_9. 

CHECK_TYPE_2 => CHECK_2D_3. 

CHECK_TYPE_3 => CHECK_3D_2. 
PRINT_ROW_HEADING => HEADING_DEV_STATUS): 


package RETRffiVE_10_2D is new GENERIC_COUNTS (FIRST_TYPE => 

DEVELOPMENT_sfATUS, 


SECOND.TYPE => HOW_PRODUCED. 
THIRD_1^E => STMT_TYPE, 

FOURTO.TYPE => ORGIN, 

FIFTH.TYPE => USAGE, 

REPORT.TYPE => NAME_REPORT_TYPE, 
T_NUMBER_TYPE => TYPE_NUMBER_TYPE, 
rItRIEVE => RETRIEVE_2D_10, 
CHECK_TYPE_2 => CHECK_2D_1, 

CHECK_TYra_3 => CHECK_3D_2, 

PRINT ROW HEADING => HEADING_DEV_STATUS): 


package RETRIEVE_1_3D is new GENERIC_COUNTS (FIRST.TYPE => USAGE, 

SECOND_TYPE => HOW.PRODUCED, 

THIRD.ITPE => ORGIN, 

FOURra_TYPE => STMT_TYPE, 

FIFTH.TYPE •=> DEVELOPMENT_STATUS, 
REPORT.TYPE => NAME_REPORT_TYPE, 
T_NUMBER_TYPE => TYPE_NUMBER_TYPE, 
RETRIEVE => RETRIEVE_3D_I, 

CHECK_TYPE_2 => CHECK_2D_1, 

CHECK_TYPE_3 => CHECK_3D_1, 
PRINT_ROW_HEADING => HEADING_USAGE); 


package RETRIEVE_2_3D is new GENERIC_COUNTS (FIRST.TyPE => USAGE, 

SECOND.TYPE => HOW.PRODUCED, 

THIRD_TYPE => DEVELOPMENT_STATUS, 
FOURTH.TYPE => ORGIN, 

FIFTH_TYPE => STMT.TYPE, 

REPORT_TYPE => NAME_REPORT_TYPE, 
T_NUMBER_TYPE => TYPE_NUMBER_TYPE, 
RETRIEVE => RETRIEVE_3D_2, 

CHECK_TYPE_2 => CHECK_2D_1, 

CHECK _TYPE_3 => CHECK_3D_4, 
PRINT_ROW_HEADING => HEADING.USAGE); 

package RETRIEVE_3_3D is new GENERICjCOUNTS (FIRST_TYPE => 
DEVELOPMENT.STATUS, 

SECOND.TYPE => HOW_PRODUCED, 

THIRD_TYPE => ORGIN, 


176 




FOURTH.TYPE => STMT.TYPE, 

FBFTH.TYPE => USAGE, 

REPORT.TYPE => NAME_REPORT_TYPE, 
T_NUMBER_TYPE => TYPE_NUMBER_TYPE. 
RETRIEVE => RETRIEVE_3D_3. 

CHECK_TYPE_2 => CHECK_2D_1, 

CHECK_TYPE_3 => CHECK_3D_1, 
PRINT_ROW_HEADING => HEADING_DEV_STATUS); 

package RETRIEVE_4_3D is new GENERIC_COUNTS (FIRST_TYPE => 

DEVELOPMENT_STATUS. 

SECOND.TYPE => USAGE, 

THIRD_1YPE => ORGDM, 

FOURTH_TYPE => HOW_PRODUCED, 
FIFTH_TyPE => STMT.TYPE, 

REPORT_TYPE => NAME_REPORT_TYPE, 
T_NUMBER_TYPE => TYPE_NUMBER_TYPE, 
RETRIEVE => RETRIEVE_3D_4, 

CHECK_TYPE_2 => CHECK_2D_3, 

CHECK_TYPE_3 => CHECK_3D_1, 
PRINT_ROW_HEADING => HEADING_DEV_STATUS): 

end REPORT.PACKAGE; 


177 







REPORT PKG B.A 


-*_Piogrammed 


package body REPORT_PACKAGE is 


funcUonCNT_EST(D : in DEVELOPMENT_STATUS; 

IN_COlJNT_ARRAY : in COUNT_ARRAY_TYPE) return integer is 

TEMP_COUNT ; integer :=0; 

begin 

for S in STMT.TYPE’FIRST.. STMT_TYPE’LAST loop 
for H in HOW.PRODUCED’FIRST.. HOW_PRODUCED’LAST loop 
for O in ORg1n*FIRST .. ORGIN’LAST loop 
for U in USAGETIRST.. US AGE’LAST loop 

TEMP.COUNT ;= TEMP_(X)UNT + IN_COUNT_ARRAY (S, H, O, U. D); 

end loop; 
end loop; 
end loop; 
end loop; 

return TEMP_COUNT; 
end CNT.EST; 


function RETRIEVE_2D_1 (TYPE_1 : STMT_TYPE; 

TYPE_2 : HOW_PRODUCED; 

TYPE_3 : ORGIN; 

TYPE_4 : USAGE; 

TYPE_5 ; DEVELOPMENT_STATUS; 

TYPE_6 : NAME_REPORT_TYPE) return natural is 

TEMP : natural :=0; 

begin 

case TYPE_6 is 


178 



whenREPORT_A=> 

TEMP ;= COUNT_ARRAY_A (TYPE_1. TYPE_2. TYPE_3. TYPE_4, TYPE_5); 
whenREPORT_B=> 

TEMP := COUNT_ARRAY_B (TYPE_1. TYPE_2. TYPE_3. TYPE_4, TYPE_5); 
when REPORT_C => 

TEMP := COUNT_ARRAY_C (TYPE_1. TYPE_2, TYPE_3. TYPE_4, TYPE_5); 
when REPORT_D => 

TEMP := COUNT_ARRAY_D (TYPE_1. TYPE_2. TYPE_3. TYPE_4, TYPE_5); 
when REPORT_E => 

TEMP := COUNT_ARRAY_E (TYPE.l, TYPE_2. TYPE_3, TYPE_4, TYPE_5); 
when REPORT_F => 

TEMP := COUNT_ARRAY_F (TYPE_1. TYPE_2. TYPE_3. TYPE_4. TYPE_5); 
end case; 

return TEMP; 

end RETRffiVE_2D_l: 


function RETRIEVE_2D_2(TYPE_1 : STMT.TYPE; 

TYPE_2 ; USAGE; 

TYPE_3 : HOW_PRODUCED; 

TYPE_4 : ORGIN; 

TYPE_5 : DEVELOPMENT.STATUS; 

TYPE_6 : NAME_REPORT_TYPE) return natural is 

TEMP : natural :=0; 
begin 

case TYPE_6 is 
when REPORT_A => 

TEMP := COUNT_ARRAY_A (TYPE_1. TYPE_3, TYPE_4, TYPE_2, TYPE_5); 
when REPORT_B => 

TEMP := COUNT_ARRAY_B (TYPE_1, TYPE_3. TYPE_4, TYPE_2, TYPE_5); 
when REPORT_C => 

TEMP := COin4T_ARRAY_C (TYPE_1, TYPE_3, TYPE_4, TYPE_2. TYPE_5); 
when REPORT_D => 

TEMP := COUNT_ARRAY_D (TYPE_1, TYPE_3. TYPE_4, TYPE_2, TYPE_5); 
when REPORT_E => 

TEMP ;= COI^_ARRAY E (TYPE_1. TYPE_3. TYPE_4, TYPE_2, TYPE_ 5); 
when REPORT_F => 

TEMP := COUNT_ARRAY_F (TYPE_1. TYPE_3. TYPE_4. TYPE_2, TYPE_5); 

end case; 

return TEMP; 
end RETRIEVE_2D_2; 


179 




function RETRIEVE_2D_3 (TYPE_1 : ORGIN; 

TYPE_2 : HOW_PRODUCED; 

TYPE_3 : STMT_TYPE; 

TYPE_4 : USAGE: 

TYPE_5 : DEVELOPMENT.STATUS; 

TYPE_6 ; NAME_REPORT_TYPE) return natural is 

TEMP : natural := 0; 
begin 

case TYPE_6 is 
when REPORT_A => 

TEMP ;= COUNT_ARRAY_A (TYPE_3. TYPE_2. TYPE_1. TYPE_4, TYPE_5); 
when REPORT_B => 

TEMP ;= COUNT_ARRAY_B (TYPE_3. TYPE_2. TYPE_1. TYPE_4. TYPE_5): 
when REPORT_C => 

TEMP := COUNT_ARRAY_C (TYPE_3. TYPE_2. TYPE.l, TYPE_4. TYPE_5); 
when REPORT_D => 

TEMP := COUNT_ARRAY_D (TYPE_3, TYPE_2. TYPE_1, TYPE_4, TYPE_5); 
when REPORT_E => 

TEMP := COUNT_ARRAY_E (TYPE_3. TYPE_2, TYPE_1, TYPE_4. TYPE_5); 
when REPORT_F => 

TEMP ;= COUNT_ARRAY_F (TYPE_3.TYPE_2, TYPE.l, TYPE_4.TYPE_5); 

end case; 

return TEMP; 
end RETRIEVE_2D_3; 


function RETRIEVE_2D_4 (TYPE_1 : ORGIN; 

TYPE_2 : STMT.TYPE; 

TYPE_3 ; HOW_PRODUCED; 

TYPE_4 : USAGE; 

TYPE_5 ; DEVELOPMENT_STATUS; 

TYPE_6 : NAME_REPORT„TYPE) return natural is 

TEMP : natural := 0; 

begin 

case TYPE_6 is 
when REPORT_A => 

TEMP := COUNT_ARRAY_A (TYPE_2. TYPE_3. TYPE_1, TYPE_4. TYPE_5); 
when REPORT_B => 

TEMP := COUNT_ARRAY_B (TYPE_2, TYPE_3, TYPE_1, TYPE_4, TYPE_5); 
when REPORT_C => 


180 




TEMP:» COUNT_ARRAY_C (TYPE_2. TYPE_3, TYPE_1. TYPE_4, TYPE_5); 
when REPORT_D => 

TCMP :* COUNT_ARRAY_D (TYPE_2, TYPE_3, TYPE_1. TYPE_4, TYPE_5): 
when REPORT_E =*> 

TEMP :* COUNT_ARRAY_E (TYPE_2. TYPE_3, TYPE_1. TYPE_4, TYPE_5); 
whenREPORT_F*> 

TEMP := COUNT_ARRAY_F (TYPE_2. TYPE_3. TYPE.l, TYPE_4, TYPE_5); 
end case; 

return TEMP; 

cndRETRffiVE_2D_4; 


function RETR[EVE_2D_5(TYPE_1 : ORGIN; 

TYPE_2 ; USAGE; 

TYPE_3 : STMT_TYPE; 

TYPE_4 : HOW.PRODUCED; 

TYPE_5 : DEVELOPMENT_STATUS; 

TYPE_6 : NAME_REPORT_TYPE) return natural is 

TEMP : natural :=0; 
begin 

case TYPE_6 is 
when REPORT_A => 

TEMP:» COUNT_ARRAY_A (TYPE_3, TYPE_4, TYPE.l, TYPE_2, TYPE_5); 
when REPORT_B => 

TEMP := COUNT_ARRAY_B (TYPE_3. TYPE_4, TYPE_1. TYPE_2. TYPE_5); 
when REPORT_C => 

TEMP := COUNT_ARRAY_C (TYPE_3, TYPE_4, TYPE_1, TYPE_2, TYPE_5); 
when REPORT_D => 

TEMP := COUNT_ARRAY_D (TYPE_3. TYPE_4, TYPE_1, TYPE_2, TYPE_5); 
when REPORT_E => 

TEMP := COUkr_ARRAY_E (TYPE_3. TYPE_4, TYPE.l, TYPE_2, TYPE_5); 
when REPORT_F => 

TEMP := COW>IT_ARRAY_F (TYPE_3, TYPE_4, TYPE.l, TYPE_2, TYPE_5); 

end case; 

return TEMP; 
endRETRIEVE_2D_5; 


function RETRIEVE_2D_6(TYPE_1 : ORGIN; 

TYPE_2 : DEVELOPMENT_STATUS; 
TYPE_3 : STMT_TYPE; 

TYPE_4 : HOW_PRODUCED; 





r 


TYPE_5 : USAGE; 

TYPE_6 : NAME_REPORT_TYPE) retum natural is 
TEMP : natural :-0; 
begin 

case TYPE_6 is 
when REPORT_A => 

TEMP := COUNT_ARRAY_A (TYPE_3. TYPE_4. TYPE.l, TYPE_5. TYPE_2) 
whenREPORT_B=> 

TEMP := COUNT_ARRAY_B CTYPE.S, TYPE_4. TYPE_1. TYPE_5. TYPE_2) 
when REPORT_C -> 

TEMP:» COUNT_ARRAY_C (TYPE_3. TYPE_4, TYPE.l, TYPE_5. TYPE_2) 
whenREPORT_D=> 

TEMP ;= COUNT_ARRAY_D (TYPE_3. TYPE_4. TYPE.l, TYPE_5. TYPE_2) 
when REPORT_E => 

TEMP := COlijT_ARRAY_E (TYPE_3. TYPE_4. TYPE_1, TYPE_5. TYPE_2) 
whenREPORT_F=> 

TEMP ;= CX)UNT_ARRAY_F (TYPE_3. TYPE_4. TYPE.l, TYPE_5. TYPE_2); 
end case; 

retum TEMP; 

end RETRIEVE_2D_6; 


function RETRIEVE_2D_7(TYPE_1 : USAGE; 

TYPE_2 ; HOW_PRODUCED; 

TYPE_3 : STMT_TYPE; 

TYPE_4 : ORGIN; 

TYPE_5 : DEVELOPMENT_STATUS; 

TYPE_6 : NAME_REPORT_TYPE) retum natural is 

TEMP : natural :=0; 
begin 

case TYPE_6 is 
when REPORT_A => 

TEMP := COUNT_ARRAY_A (TYPE_3. TYPE_2, TYPE_4, TYPE_1, TYPE_5); 
when REPORT_B => 

TEMP := COin^_ARRAY_B (TYPE_3, TYPE_2, TYPE_4, TYPE_1, TYPE_5); 
whenREPORT_C=> 

TEMP := COin^_ARRAY_C (TYPE_3, TYPE_2. TYPE_4. TYPE_1, TYPE_5); 
whenREPORT_D=> 

TEMP ;= COUNT_ARRAy_D (TYPE_3, TYPE_2, TYPE_4, TYPE_1, TYPE_5); 
when REPORT_E => 

TEMP ;= COUNT_ARRAY_E (TYPE_3. TYPE_2, TYPE_4. TYPE_1, TYPE_5); 
when REPORT_F => 


182 






TEMP := COUNT_ARRAY_F (TYPE_3. TYPE_2. TYPE_4. TYPE.l, TYPE_5); 
end case; 

return TEMP; 

endRETRIEVE_2D_7; 


function RETRffiVE_2D_8(TYPE_I ; DEVELOPMENT_STATUS; 

TYPE_2 : STMT_TYPE; 

TYPE_3 : H0W_PR0DUCED; 

TYPE_4 : ORGW; 

TYPE_5 ; USAGE; 

TYPE_6 : NAME_REPORT_TYPE) return natural is 
TEMP ; ratural;=0; 
begin 

case TYPE_6 is 
when REPORT_A => 

TEMP := COUNT_ARRAY_A (TYPE_2. TYPE_3. TYPE_4. TYPE_5, TYPE.l); 
when REPORTED => 

TEMP := COUNT_ARRAY_B (TYPE_2. TYPE_3. TYPE_4, TYPE_5. TYPE.l); 
whenREPORT_C=> 

TEMP;» COUNT_ARRAY_C (TYPE_2, TYPE_3. TYPE_4, TYPE_5, TYPE_1); 
when REPORT_D => 

TEMP := COUNT_ARRAY_D (TYPE_2. TYPE_3. TYPE_4. TYPE_5. TYPE.l); 
whenREPORT_E=> 

TEMP COUNT_ARRAY_E (TYPE_2, TYPE_3, TYPE_4, TYPE_5, TYPE.l); 
when REPORT_F => 

TEMP ;= COUNT_ARRAY_F (TYPE_2, TYPE_3, TYPE_4, TYPE_5. TYPE_1); 
end case; 

return TEMP; 

endRETRIEVE_2D_8; 


function RETRIEVE_2D_9(TYPE_1 : DEVELOPMENT_STATUS; 
TYPE_2 : USAGE; 

TYPE_3 : STMT.TYPE; 

TYPE_4 : HOW_PRODUCED; 

TYPE_5 ; ORGIN; 

TYPE_6 : NAME_REPORT_TYPE) return natural is 


TEMP : natural := 0; 
begin 


183 






case TYPE_6 is 
when REPORT_A »> 

TEMP := COUNT_ARRAY_A (TYPE_3. TYPE_4. TYffi.S, TYPE_2. TYPE 1); 
whenREPORT_B*> 

TEMP > CX)UNT_ARRAY_B (TYPE_3. TYPE_4. TYPE_5. TYPE_2. TYPE_1); 
when REPORT_C «> 

TEMP COUNT_ARRAY_C (TYPE_3. TYPE_4, TYPE_5. TYPE_2, TYPE.l); 
when REPORT_D *> 

TEMP := CX)UNT_ARRAY_D (TYPE_3, TYPE_4. TYPE_5, TYPE_2. TYPE 1); 
whenREPORT_E=> 

TEMP := COUNT_ARRAY_E (TYPE_3. TYPE_4. TYPE_5. TYPE_2, TYPE.l): 
whenREPORT_F*> 

TEMP :* COUNT_ARRAY_F (TYPE_3. TYPE_4. TYPE_5. TYPE_2. TYPE.l); 
end case; 

return TEMP; 

endRETRIEVE_2D_9; 


function RETRIEVE_2D_10(TYPE_I ; DEVELOPMENT.STATUS; 

TYPE_2 : HOW_PRODUCED; 

TYPE_3 : STMT.TYPE; 

TYPE_4 : ORGIN; 

TYPE_5 : USAGE; 

TYPE_6 : NAME.REPORT .TYPE) return natural is 
TEMP : natural :s0: 
begin 

case TYPE_6 is 
when REPORT_A => 

TEMP ;= COUNT_ARRAY_A (TYPE_3. TYPE_2, TYPE_4, TYPE_5. TYPE_1); 
when REPORT_B => 

TEMP := COukr_ARRAY_B (TYPE_3, TYPE_2, TYPE_4, TYPE_5. TYPE_1): 
when REPORT_C => 

TEMP := COUOT_ARRAY_C (TYPE_3, TYPE_2. TYPE_4, TYPE_5, TYPE_1); 
when REPORT_D => 

TEMP := COUNT_ARRAY_D (TYPE_3, TYPE_2, TYPE_4, TYPE_5, TYPE_1); 
when REPORT_E => 

TEMP := COlS^_ARRAY_E (TYPE_3. TYPE_2, TYPEjl, TYPE_5, TYPE_1); 
when REPORT_F => 

TEMP := COUNT. ARRAY.F (TYPE_3. TYPE_2, TYPE_4. TYPE_5, TYPE_1); 
end case; 

return TEMP; 

end RETRIEVE_2D_10; 


184 





function RETR]EVE_3D_1(TYPE_1 : USAGE; 

TYPE_2 : HOW.PRODUCED; 

TYPE_3 : ORGIN; 

TYPE_4 : STMT_TYPE; 

TYPE_5 : DEVELOPMENT.STATUS; 

TYPE_6 : NAME_REPORT_TYPE) return natural is 

TEMP : natural :=0; 
begin 

case TYPE_6 is 
when REPORT_A => 

TEMP ;=COUNT_ARRAY_A (TYPE_4.TYPE_2.TYPE_3,TYPE_1.TYPE_5); 
when REPORT_B => 

TEMP := COUNT_ARRAY_B (TYPE_4. TYPE_2, TYPE_3, TYPE_1, TYPE_5): 
when REPORT C=> 

TEMP ;= COUNT_ARRAY_C (TYPE_4, TYPE_2. TYPE_3. TYPE_1. TYPE_5); 
when REPORT_D => 

TEMP := COUNT_ARRAY_D (TYPE_4, TYPE_2, TYPE_3. TYPE_1. TYPE_5): 
when REPORT_E => 

TEMP := COUNT_ARRAY_E (TYPE_4, TYPE_2. TYPE_3. TYPE_1, TYPE_5); 
when REPORT_F => 

TEMP := COUNT_ARRAY_F (TYPE_4, TYPE_2, TYPEJ, TYPE_1, TYPE.S); 

end case; 

return TEMP; 
endRETRIEVE_3D_l; 


function RETRIEVE_3D_2(TYPE_1 : USAGE; 

TYPE_2 : HOW.PRODUCED; 

TYPE_3 : DEVELOPMENT_STATUS; 

TYPE_4 : ORGIN; 

TYPE_5 : STMT_TYPE; 

TYPE_6 : NAME_REPORT_TYPE) return natural is 
TEMP : natural := 0; 
begin 

case TYPE_6 is 
when REPORT_A => 

TEMP := COUNT_ARRAY_A (TYPE_5. TYPE_2, TYPE_4, TYPE_1, TYPEJ); 
when REPORT_B => 

TEMP := COUNT_ARRAY_B (TYPE_5. TYPE_2, TYPE_4, TYPE_1, TYPE_3); 


185 





whenREPORT_C»> 

TOMP>CX)UNT_ARRAY_C(TYPE_5.TYPE_2,TYPE 4. TYPE 1,TYPE_3); 
whenREPORT_D»> 

TEMP :«COUNT_ARRAY_D(TYPE_5.TYPE_2, TYPE 4. TYPE_1. TYPE 3); 
whenREPORT.E-o 

TEMP ;= CX)UNT_ARRAY^E (TYPE.S, TYPE_2. TYPE 4. TYPE_1. TYPE_3); 
whenREPORT_F=> 

TEMP :a COUNT_ARRAY_F (TYPE_5. TYPE_2, TYPE_4. TYPE_l, TYPE_3); 
end case; 

leftmiTEMP; 

endRETRffiVE_3D_2; 


function RETRffiVE_3D_3 (TYPE_1 : DEVELOPMENT.STATUS; 

TYPE_2 : HOW_PRODUCED; 

TYPE_3 : ORGW; 

TYPE_4 : STMT.TYPE; 

TYPE_5 : USAGE; 

TYPE_6 : NAME_REPORT_TYPE) return natural is 
TEMP ; natural := 0; 
begin 

case TYPE_6 is 
when REPORT_A => 

TEMP := COUNT_ARRAY_A (TYPE_4, TYPE_2. TYPE_3. TYPE_5, TYPE_1); 
when REPORT_B => 

TEMP := COUNT_ARRAY_B (TYPE_4, TYPE_2, TYPE_3, TYPE_5, TYPE_1): 
when REPORT_C => 

TEMP := COUNT_ARRAY_C (TYPE_4. TYPE_2, TYPE_3, TYPE_5, TYPE_1): 
when REPORT_D => 

TEMP := COl^_ARRAY_D (TYPE_4. TYPE_2, TYPE_3, TYPE_5, TYPE_1); 
when REPORT_E => 

TEMP := COim_ARRAY_E (TYPE_4. TYPE_2, TYPE_3, TYPE_5, TYPE_1); 
when REPORT_F => 

TEMP ;= COUOT_ARRAY_F (TYPE_4. TYPE_2, TYPE_3, TYPE_5, TYPE.l); 
end case; 

return TEMP; 

endRETRffiVE_3D_3; 


function RETTIIEVE_3D_4 (TYPE_1 : DEVELOPMENT_STATUS; 
TYPE_2 : USAGE; 

TYPE_3 ; ORGIN; 


186 





TYPE_4 : HOW_PRODUCED; 

TyPE_5 : STMT_TYPE; 

TYPE_6 : NAME_REPORT_TYPE) return natural is 
TEMP : natural :sO; 
begin 

case TYPE_6 is 
when REPORT A=> 

TEMP := COUNT_ARRAY_A (TYPE_5. TYPE_4. TYPE_3. TYPE_2, TYPE_1); 
when REPORT_B => 

TEMP:» COUNT_ARRAY_B (TYPE_5, TYPE_4. TYPE_3. TYPE_2. TYPE_1): 
whenREPORT_C*> 

TEMP := COUNT_ARRAY_C (TYPE.S, TYPE_4, TYPE_3. TYPE_2. TYPE_l); 
when REPORT D*> 

TEMP := COUNT_ARRAY_D (TYPE_5. TYPE_4. TYPE_3. TYPE_2, TYPE_1); 
whenREPORT_E=> 

TEMP := COUNT_ARRAY_E (TYPE_5. TYPE_4. TYPE_3. TYPE_2. TYPE_1); 
when REPORT_F *> 

TEMP := COUNT_ARRAY_F (TYPE_5. TYPE_4, TYPE_3. TYPE_2. TYPE.l); 
end case; 

return TEMP; 

endRETRIEVE_3D_4; 


function CHECK_2D_1 return TYPE_NUMBER_TYPE is 
T2_NUMBER : TYPE_NUMBER_TYPE := 1; 
begin 

return T2_NUMBER; 
endCHECK_2D_l; 


function CHECK_2D_2 return TYPE_NUMBER_TYPE is 
T2_NUMBER : TYPE_NUMBER_TYPE := 2; 
begin 

return T2_NUMBER; 
endCHECK_2D_2; 


function CHECK_2D_3 return TYPE_NUMBER_TYPE is 
T2_NUMBER ; TWE.NUMBER.TYPE := 3; 


187 




begin 

return T2_NUMBER; 
endCHECK_2D_3; 


function CHECK_2D_4 return TYre_NUMBER_TYPE is 
T2_NUMBER : rW»E_NUMBER_TYPE ;=4; 
begin 

return T2_NUMBER: 
endCHECK_2D_4; 


function CHECK_3D_1 return TYPE_NIIMBER_TYPE is 
T3_NUMBER : TYPE_NUMBER_TYPE := 5; 
begin 

return T3_NUMBER; 
endCHECK_3D_l; 


function CHECK_3D_2 return TyPE_NUMBER_TYPE is 
T3_NUMBER : TYPE_NUMBER_TYPE:» 2; 
begin 

return T3_NUMBER; 
endCHECK_3D_2; 


function CHECK_3D_3 return TYPE_NUMBER_TYPE is 
T3_NUMBER : TYPE_NUMBER_TYPE := 1; 
begin 

return T3_NUMBER; 
endCHECK_3D_3; 


function CHECK_3D_4 return TYPE_NUMBER_TTPE is 
T3_NUMBER : TYPE_NUMBER_TYPE := 4; 
begin 


188 




return T3_NUMBER; 


endCHECK_3D_4; 


procedure HEADING_STMT_TYPE (ROW.POSITION: positive) is 
■reMP : integer := ROW.POSITION -1; 
begin 

ifTEMP = Othen 

put (OUT_FILE_TYPE. “Executable “); 
elsif TEMP = 1 then 

put (OUT_FILE_TYPE. “Declarations “): 
elsif TEMP = 2 then 

put_line (OUT_FILE_TYPE, “Compiler dir- “); 
put (0UT_FI1£_TYPE, “ectives “); 
elsif TEMP = 3 then 

put_Iine (OUT_FILE_TYPE, “Comments on “); 
put (OUT_FILi_TyPE. “their own line “); 
elsif TEMP = 4 then 

put_line (OlJT_FILE_TYPE, “Comments on “); 
put.line (OUT_FILE_TYPE, “lines with “); 
put (OUT_FILE_TYPE. “source code “); 
elsif TEMP = 5 then 

put.line (OUT_FILE_TYPE, “Banner and non-"); 
put^OUT.Fnii.TYPE, “blank spacers “); 
elsif TEMP = 6 then 

put.line (OUT_FIL£_TYPE, “Blank (empty) “): 
put (OUT_FILE_TYPE, “comments “); 
elsif TEMP = 7 then 

put (OUT_FILE_TYPE, “Blank Ones “); 
end if; 

end HEADING_STMT_TyPE; 


procedure HEADING_ORGIN (ROW_POSmON : positive) is 
TEMP : integer :=ROW_POSrnON-1; 
begin 

if TEMP =0 then 

puLline (OUT_FILE_TyPE, ‘T^ew Wwk: no “); 
put (OUT_FILE_TYPE, “prior existence”); 
elsif TEMP = 1 then 


189 


put.tine (OUT_FE^_TTra, “A previos ver- “); 
put.tine (OUT_FE£_TYra. “sion, buUd, “); 
put (OUT_FILE_TYPE, “w release “); 
elsif TEMP s 2 then 

put (OUT_FILE_TYPE. “COTS “); 
elsifTEMP = 3 thra 
put(OUT_FILE_TYPE.“GFS “); 
dsif TEMP = 4 then 

put (OUT_FILE_TYPE. “Another product”); 
elsif TEMP = 5 then 

put_]ine (OUT_FILE_TYPE, “A vendor Mippl-”); 
put_line (OlJT_FILE_TYPE, “ied language “); 
put (OUT_FILE_TYPE, “support library”); 
dsif TEMP = 6 then 

put_line (OUT_FEE_TYPE, “A vendor-suppl-”); 
put_line (OUT_FILE_TYPE, “ied operating “); 
put_line (OUT_FILE_TYra, “system or “); 
put (OUT_FILE_TYPE. “utility “); 
elsif TEMP = 7 then 

put_line (OUT_FILE_TYPE, “A local or mod-”); 
put_line (OUT_FILE_TYPE, “ified language “); 
put_lirte (OUT_FILE_TYPE, “support library”); 
put_Iine (OUT_FILE_TYPE, “ or operating “); 
put (OUT_FILE_TYPE. “system “); 
elsif TEMP = 8 then 

put.line (OlJT_FILE_TYPE, “Other commer- “); 
put(OUT_FILE_TYPE,“cialUbrary “); 
elsif TEMP = 9 then 

pul_line (Oirr_FILE_TYPE, “A reuse library”); 
put_line (OUT_FILE_TYPE. “(software “); 
put_line (OUT_FILE_TYPE, “designed fw “); 
put (OUT_FILE_TYPE, “reuse “); 

elsif TEMP = 10 then 

put_line (OUT_FILE_TYPE, “Other software “): 
put_line (OlJT_FILE_TyPE, “component or “); 
put (OUT_FILE_TYPE. “Ubrary “); 

end if; 

end HEADING_ORGIN; 


procedure HEADING_USAGE (ROW_POSrnON : positive) is 
TEMP : integer ,*ROW_POSrnON-l; 
begin 

if TEMP = 0 then 

put_line (OlJT_FILE_TYPE, “In or as part “); 
put_line (OUT_FILE_TYPE, “of the primary “); 


190 





put(OUT_FILE_TYPE.“pioduct “); 
elsif TEMPs 1 then 

put.line (OUT_FILE_TYPE. “External to or “); 
put_line (OUT_FIL£_TYPE, “in support of “); 
put_line (OUT_FILE_TYPE, “the primary “); 
put (OUT_FILE_TYPE, “product “); 
end if; 

end HEADING.USAGE; 


procedure HEADING_DEV_STATUS (ROW_POSITION: positive) is 
TEMP : integer := ROW.POSITION -1; 
begin 

if TEMP = 0 then 

put_line (OUT_FTL£_TYPE, “Estimated or “); 
put (OUT_FILE_TYPE. “planned “); 

elsifTEMP* 1 then 

put (OUT_FILE_TYPE, “Designed “); 
elsif TEMP = 2 then 

put (OUT_FILE_TYPE, “Coded “); 

elsif TEMP * 3 then 

put_line (OUT_FILE_TYPE, “Unit tests com-”); 
put (OUT_FILE_TYPE, “pleted “); 

elsif TEMP = 4 then 

put.Une (OUT_FE£_TYPE, “Integrated into”); 
put (OUT_FIL£_TYPE, “components “); 
elsif TEMP = 5 then 

put_line (OUT_FIL£_TYPE, ‘Test readiness “); 
put_line (OUT_FILE_TYPE, “review com- “); 
put (OUT_FILE_TYPE, “pleted “); 

elsif TEMP «= 6 then 

put_line (OUT_FILE_TYPE, “Software (CSCI)”); 
put (OUT_FILE_TYPE, “tests completed”); 
elsif TEMP = 7 then 

put_line (OUT_FIL£_TYPE, “System tests “); 
put (OUT_FIL£_TYPE, “completed “); 
end if; 

end HEADING_DEV_STATUS; 


function FIND_PRIORITY_F (IN_STMT_TYPE : in STMT_TYPE) return integer is 

COUNTER : integer ;=1; 

PRIORrrY_NUM ; integer :=0; 


191 





begin 

for F in KUORTTY.ARRAY.F’range loop 
if PRIORITY_ARRAY_F (F) = IN_STMT_TYPE then 
exit; 
else 

COUNTCR := COUhTl ER + 1; 
end if; 
end loop; 

PRIORITY.NUM := COUNTER: 
return PRIORTTY.NUM; 

end FIND_PRIORITY_F; 


function COUNT_TOTAL_LINES_A (IN_COUNT_TOTALS ; COUNT_TOTALS_TYPE) return 
natural is 

TEMP : natural; 

begin 

TEMP := IN_COUNT_TOTALS.STMT_NUMS.EXEC_TOTAL + 
IN_COUNT_TOTALS.STMT_NUMS.DEC_TOTAL + 
IN_COUNT_TOTALS.STMT_NUMS PRAGMA_TOTAL; 

return TEMP; 

end COUNT_TOTAL_LINES_A; 


function COUNT_TOTAL_LINES_B (IN_COUNT_TOTALS : in COUNT_TOTALS_TYPE) 
return natural is 

TEMP : natural; 

begin 

TEMP := IN_COUNT_TOTALS.STMT_NUMS.EXEC_TOTAL + 
IN_COUNT_TOTALS.STMT_NUMS.DEC_TOTAL + 
IN_COUNT_TOTALS.STMT_NUMSPRAGMA_TOTAL: 

return TEMP; 

end COUNT_TOTAL_LINES_B; 


192 




function COUNT_TOTAL_LINES_C (IN_COUNT_TOTALS : in COUNT_TOTALS_TYPE) 
return natural is 


TEMP : natural; 


begin 


TEMP ;= IN_CX)UNT_TOTALS .STMT_NUMS.EXEC_TOTAL + 
IN_COUNT_TOTALS.STMT_NUMS.DEC_TOTAL + 
IN_COUNT_TOTALS.STMT_NUMSPRAGMA_TOTAL + 
iN_COUNT_TOTALS.STMT_NUMS .CMTS_ON_OWN_TOTAL + 
IN_COUNT_TOTALS.STMT_NlJMS.CMTS_W_SRC_TbTAL; 


return TEMP; 

end COUNT_TOTAL_LINES_C; 


function COUNT_TOTAL_LINES_D (IN_COUNT_TOTALS ; in COUNT_TOTAJ.S_TYPE) 
return natural is 

TEMP ; natural; 

begin 

TEMP:=IN_COUNT_TOTALS.STMT_NUMS.EXEC_TOTAL + 
IN_COUNT_TOTALS.STMT_NUMS.DEC_TOTAL + 
IN_COUNT_TOTALS.STMT_NUMS .PRAGMA_TOTAL; 

return TEMP; 

end COUNT_TOTAL_LINES_D; 


function COUNT_TOTAL_LINES_E (IN_COUNT_TOTALS : in COUNT_TOTALS_TYPE) 
return natural is 

TEMP : natural; 

begin 

TEMP := IN_COUNT_TOTALS .STMT_NUMS.EXEC_TOTAL + 
IN_COUNT_TOTALS.STMT_NUMS.DEC_TOTAL + 


193 





IN_CX)UmLTOTALS.STMT_NUMSJ»RAGMA_TOTAL + 
IN_COU^^^_TOTALS.ST^^'_^aJMS.CMTS_ON_OWN_TOTAL + 
IN_CX)UNT_TOTALS.STMT_NUMS.CMTS_W_SRC_TOTAL; 

return TEMP; 

end COUNT_TOTAL_LINES_E; 


function COUNT_TOTAL_LINES_F (IN_COUNT_TOTALS: in COUNT_TOTALS_TYPE) 
return natural is 


TEMP : natural := 0; 


begin 

if RECORD_FLAGS_F.PANEL3I,INE_l then 
TEMP := TEMP + IN_COUNT_TOTALS.STMT_NUMS£XEC_TOTAL; 
end if; 

if RECORD_FLAGS_F.PANEL3J-INE_3 then 
TEMP := TEMP + IN_COUNT_TOTALS.STMT_NUMS.DEC_TOTAL; 
end if; 

if RECORD_FLAGS_F.PANEL3iINE_4 then 

TEMP := TEMP+ IN_COUNT_TOTALS.STMT_NUMSJ»RAGMA_ TOTAL; 
end if; 

if RECORD_FI,AGS_FJ>ANEL3XINE_6 then 

TEMP ;= TEMP + IN_COUNT_TOTALS.STMT_NUMS.CMTS_ON_OWN_TOTAL; 
end if; 

if KECORD_FLAGS_FJ»ANEL3iINE_7 then 

TEMP := TEMP + IN_COUNT_TOTaLs.STMT_NUMS.CMTS_W_SRC_TOTAL; 
end if; 

if RECORD_FLAGS_FJ>ANEL3iINE_8 then 

TEMP := TEMP + IN_COUNT_TOTALS.STMT_NUMS.BANNER_CMTS_TOTAL; 
end if; 

if RECORD_FLAGS_F.PANEL3iINE_9 then 

TEMP ;= TEMP + IN_COUNT_TOTALS.STMT_NUMS£MPTY_CMTS_TOTAL; 
end if; 

if RECORD_FLAGS_F.PANEL3.LINE_10 then 

TEMP := TEMP + IN_COUNT_TOTM.S.STMT_NUMS.BLANK_LINES_TOTAL; 
end if; 

return TEMP; 

eatd COUNT_TOTAL_LINES_F; 


194 






procedure PRINT_REPORT_HEADER_l is 
MY_TEMP : siring (1.. 11) := (others => ‘ *); 
begin 

newjine (OUT_FILE_TYPE): 
put(OUT_FILE_TYPE,“ ReptwtName: “); 

put_Une (OUT_FILE_TYPE. RECORD_FLAGSJ>ANEL2J^PORT_HEADING (1)(1.. 50)); 
pul(Ol]T_FILE_TYPE.“ File List used: “); 

put.Une (OUT_FILE_TYPE.RECORD_FLAGSPANEL2.IN_FILE_NAME (l)(l.. 50)); 
put70UT_FILE_TYPE, “ Requested by: “): 

put.line (OUT_FILE_TYPE. RECORD_FLAGS.PANEL2JlEQUESTOR (1)(1.. 50)); 
new_line (OUT_FILE_TyPE); 

put_line (OUT_FILE_TYPE. “ Measured as; Physical source lines “); 
new_line (OUT_FILE_TYPE); 
pul(OUT_FILE_TYPE.“ DeUveredas: “); 

MY_TEMP:= GLOBALJlECORD_FLAGSJ»ANEL6.DEL_OPnON(l)(l .. 11); 

if MY_TEMP = “Delivered a” then 
put_line (OlJT_FILE_TYPE, “Delivered as source”); 
elsif MY_TEMP = “Delivered i” then 

put_line (OUT_FILE_TYPE, “Delivered in compiled or executable form, but not as source”); 
elsif MY_TEMP = “Under confi” then 
put_line (OUT_FDLE_TYPE, “Under configuration control”); 
elsif MY_TEMP = “Not under c” then 
put_line (OUT_FILE_TYPE, “Not under configuration control”); 
else 

put_line (OUT_FILE_TYPE, “Don’t care”); 
end if; 

newjine (OUT_FILE_TYPE): 
end PRINT_REPORT_HE ADER_1; 


procedure PRINT_REPORT_HEADER_2 is 
begin 

newjine (OUT_FILE_TYPE); 
put(OUT_FILE_TYPE,“ “); 

put (OUT_FILE_TYPE.“ Total Total Individual”); 
newjine (OUT_FILE_TYPE); 
put(OUT_FILE_TYPE,“ “); 

put (OUTJFILE_TYPE, “Includes Excludes totals “); 
new_Iine (OUT_FILE_TYPE); 


195 





end PRINT_REPORT_HEADER_2; 


procedure PRINT_STMT_HE ADER is 
begin 

new_line (01JT_FI1JE_TYPE); 

put_Iine (OUT_FILE_TYPE, “Statement type”); 

put_Iine (OUT_FILE_TYPE. “ When a line or statement contains more than”); 
put_line (OUT_FILE_TYPE. “ one type, classify it as the type with the “); 
put_line (Oin'_FILE_TYPE, “ highest precedence.”); 
newjine (OUT_FILE_TYPE); 

end PRINT_STMT_HEADER; 


procedure PRINT_STMT_TYPE_1_IN (IN_COUNT_TOTAL: in COUNT_TOTALS_TVPE; 
REPORT_TYPE ; in integer) is 

begin 

put (OlJT_FILE_TYPE, “ 1 Executables Precedence => “); 

if REPORT.TYPE > 0 then 
put (OUT_FILE_TYPE, “1”); 
else 

put (OUT_FILE_TYPE. FIND_PRIORITY_F (STMT.TYPE’val (0)), width => 1); 
end if; 

put(OUT_FILE_TYPE,“ XXXX “); 

put (OUT_FILE_TYPE. IN_COUNT_TOTAL.STMT_NUMS JEXEC.TOTAL, width => 10); 
newjine (OUT_FILE_TYPE); 

end PRINT_STMT_TYPE_1_IN; 


procedure PRINT_STMT_TYPE_1_EX (REPORT_TYPE ; in integer) is 
begin 

put (OUT_FILE_TYPE, “ 1 Executables Precedence *> “); 
if REPORT_TYPE > 0 then 
put (OUT_FILE_TYPE, “1”); 
else 

put (OUT_FILE_TYPE, FIND_PRIORITy_F (STMT.TYPE’val (0)). width => 1); 
end if; 

put(OUT_FILE_TYPE.“ XXXX 0”); 

new_line (OUTJFILE_TyPE); 

end PRINT_STMT_TYPE_1_EX: 


196 




procedure PRINT_STMT_TYPE_2 is 
begin 

put_Iine (OUT_FILE_TYPE, “ 2 Nonexecutabies “): 
Mjd PRINT_STMT_TYPE_2; 


procedure PRINT_STMT_TYPE_3_IN (IN_CX)UNT_TOTAL : in COUNT.TOTALS.TYre; 
REPORT_TYPE : in integer) is 

begin 

put (OUT_FIL£_TYPE, “ 3 Declarations “); 

if REPORT.TYPE > 0 then 
put (OUT_FILE_TYPE. “2”); 
else 

put (OUT_FILE_TYPE. FIND_PRIORITY_F (STMT.TYPE’val (1)). width => 1); 
end if; 

put(OUT_FILE_TYPE,“ XXXX “); 

put (OUT_FILE_TYPE, IN_COlJNT_TOTAL.STMT_NlJMS.DEC_TOTAL. width => 10); 
new_line (OUT_FILE_TYPE); 

end PRINT_STMT_TYPE_3_IN; 


procedure PRINT_STMT_TyPE_3_EX (REPORT_TYPE ; in integer) is 
begin 

put(OUT_FILE_TYPE.“3 Declarations “); 

if REPORT.TYPE > 0 then 
put (OUT_FILE_TYPE, “2”); 
else 

put (OUT_FILE_TYPE, FZND.PRIORTTY.F (STMT_TYPE’val (1)), width => 1); 
end if; 

put(OUT_FILE_TYPE,“ XXXX 0”); 

newjine (OUT_Fn-E_TYPE): 

end PRINT_STMT_TYPE_3_EX; 


procedure PRINT_STMT_TYPE_4_IN (IN_COUNT_TOTAL; in COUNT_TOTALS_TYPE; 
REPORT_TYPE : in integer) is 


begin 


197 




pul (OlJT_FILE_TYra, “ 4 Compile Directives “): 

if REPORT_TYPE > 0 then 
put (OUT_Fn-E_TYPE. “3”); 
else 

put {OUT_FILE_TYPE. FIND.PRIORITY.F (STMT.TYPE’val (2)). width => 1); 
emlif; 

put(OUT_FlLE_TYre.“ XXXX “): 

put (OUT_FILE_TYPE, IN_COUNT_TOTAL.STMT_NUMS.PRAGMA_TOTAL. width => 10); 
new.line (OUTJFILE_TYPE); 

end PRINT_STMT_TYPE_4_IN: 


procedure PRINT_STMT_TYPE_4_EX (REPORT_TYPE : in integer) is 
begin 

put (OUT_FIL£_TYPE, “ 4 Compiler Directives “); 

if REPORT.TYPE > 0 then 
put (OUT_FILE_TYPE, “3"); 
else 

put (Oirr_FILE_TYPE. FIND_PRIORITY_F (STMT_TYPE’val (2)). width => 1); 
end if; 

put (OUT_FILE_TYPE. “ XXXX 0”); 

new_line (OUT_FILE_TYPE); 
end PRINT_STMT_TYPE_4_EX; 


procedure PRINT_STMT_TYPE_5 is 
begin 

put_line (OUT_FILE_TYPE, “ 5 Comments “); 
end PRINT_STMT_TyPE_5; 


p.x>rediire PRINT_STMT_TYPE_6_IN (IN_COUNT_TOTAL: in COUNT_TOTALS_TYPE; 
REPORT_TYPE : in integer) is 

begin 

put (01JT_FI1JE_ TYPE, “6 On their own lines “); 

if REPORT_TYPE > 0 then 
pot (OUT_FILE_TYPE. “4”); 
else 

put (OUT_FILE_TYPE, FIND_PRIORITY_F (STMT.TYPE’val (3)), width => 1); 
end if; 

put(OUT_FILE_TYPE,“ XXXX "); 


198 





put (OUT_FILE_TYPE, IN_CX)UNT_TOTAL.STMT_NUMS.CMTS_ON_OWN_TOTAL. width 

»> 10); 

ncw_line (OUT_FILE_TYPE); 
end PRINT_STMT_TYPE_6_IN; 


imx;eduie PRINT_STMT_TYPE_6_EX (REPORT_TYPE ; in integer) is 
begin 

put (OUT_FIUE_TYPE, “ 6 On their own lines “); 

if REPORT_TYPE > 0 then 
put {0UT_F1LE_TYPE. “4”); 
else 

put (OUT_FILE_TYPE, FIND_PRIORITY_F (STMT_TYPE*val (3)). width => 1); 
end if; 

put(OUT_FILE_TYPE.“ XXXX 0**); 

new_line (01JT_FILE_TYPE); 

end PRINT_STMT_TYPE_6_EX; 


procedure PRINT_STMT_TYPE_7_IN (IN_C»UNT_TOTAL: in COUNT_TOTALS_TYPE; 
REPC®T_TYPE : in integer) is 

begin 

put (OUT_FILE_TYPE, “ 7 On lines with source code "); 

if REPORT_TYPE > 0 then 
put (OUT_FILE_TYPE, “5”); 
else 

put (OUT_FILE_TYPE. FIND_PRIORnT_F (STMT.TYPE’val (4)), width => 1); 
end if; 

put(OUT_FILE_TYPE.“ XXXX “); 

put (OUT_FILE_TYPE. IN_COUNT_TOTAL.STMT_NUMS.CMTS_W_SRC_TOTAL, width 

=> 10 ); 

new_line (OlJT_FILE_TYPE); 
end PRINT_STMT_TYPE_7_IN; 


procedure PRINT_STMT_TYPE_7_EX (REPORT.TYPE : in integer) is 
begin 

put (OUT_FILE_TYPE, “ 7 On lines with source code “); 
if REPORT_TYPE > 0 then 
put (OUT_FILE_TYPE, “5”); 


199 






else 

put (OUT_FILE_TYre. FIND_PR10R1TY_F (SmT.TYPE’val (4)). width => 1); 
end if; 

put (OUT_FILE_TYre, “ XXXX 0”): 

new_Une (OUT_FILE_TYPE); 

end PRINT_STMT_TYre_7_EX; 


piocedure PRINT_STMT_TYPE_8_IN (IN_COUNT_TOTAL: in COUNT_TOTALS_TYPE: 
REPORT_TYPE : in integer) is 

begin 

put (OUT_FILE_TYPE. “ 8 Bannos and nonblank q)acers “): 
if REPORT TVre > 0 then 
put (OUT_FILE_TYPE. “6”); 
else 

put (OUT_FILE_TYre. FIND_PRIORITY_F (STMT.TYPE’val (5)). width => 1); 
end if; 

put(Oirr_FILE_TYPE.“ XXXX “); 

put(OUT_FILE TYPE, IN COUNT TOTAL.STMT NUMS.BANNER_CMTS_TOTAL. width 

*> 10 ): 

ncw.Iine (OUT_FILE_TYPE); 
end PRINT_STMT_TYPE_8_IN; 


procedure HUNT_STMT_TYPE_8_EX (REPORT_TYPE : in integer) is 
begin 

put (OUT_FILE_TYPE, “ 8 Banners and nonblank spacers “); 
if REPORT.TYPE > 0 then 
put (OUT_FILE_TYPE. “6”); 
else 

put (OUT_FILE_TYPE. FIND_PRIORrry_F (STMT.TYPE’val (5)), width => 1); 
end if; 

put(OUT_FILE_TYPE,“ XXXX 0”); 

new_line (OUr_FILE_TYPE); 

end PRINT_STMT_TYPE_8_EX; 


procedure PRINT_STMT_TYPE_9_IN (IN_COUNT_TOTAL: in COUNT_TOTALS_TYPE; 


200 





REPORT_TYre : in integer) is 

begin 

put (Ol)T_FILE_TYPE, “ 9 Blank (empty) comments “); 

if REPORT.TYPE > 0 then 
put (OUT_FILE_TYPE, “7”); 
else 

put (OUT_FILE_TYPE. FIND_PRIORnY_F (STMT.TYPE’val (6)). width => 1); 
end if; 

put(Oirr_FILE_TYPE.“ XXXX “); 

put (OUT_FILE_TYre. IN_COlJhn'_TOTAL.STMT_NlJMS£MPTy_CMTS_TOTAL. width 
=> 10 ); 

newjine (OUT_FILE_TYPE); 
end PRINT_STMT_TYPE_9_IN; 


procedure PRINT_STMT_TYPE_9_EX (REPORT_TYPE ; in integer) is 
begin 

put (0UT_F1LE_TYPE, “ 9 Blank (empty) comments “); 
if REPORT_TYPE > 0 then 
put (OUT_FILE_TYPE. ‘7”); 
else 

put (OUT_FILE_TYPE. FIND_PRIORITY_F (STMT.TYPE’vaJ (6)). width *> 1); 
end if; 

put(OUT_FEi_TYPE.“ XXXX 0”); 

newjine (OUT_FILE_TYPE); 

end PRINT_STMT_TYPE_9_EX; 


procedure PRINT_STMT_TYPE_10_IN (IN_CX)UNT_TOTAL: in CX)UNT_TOTALS_TYPE; 
REPORT_TYPE : in integer) is 

begin 

put (OUT_FILE_TYPE. “10 Blank lines “); 

if REPORT.TYPE > 0 then 
put (OUT_FILE_TYPE, “8”); 
else 

put (OUT_FILE_TYPE. FIND.PRIORITY.F (STMT.TYPE’val (7)). width => 1); 
end if; 

put (OUT_FILE_TYPE, “ XXXX “); 

put(OUT_FILE_TYPE,IN_COUNT_TOTAL.STMT NUMS.BLANK_LINES TOTAL, width 

=> 10 ); 

newjine (OUT_FILE_TYPE); 


201 







end PRINT_STMT_TYPE_10_IN; 


I»ocedurePRINT_STMT_TYPE_10_EX(REPORT_TYPE : in integer) is 
begin 

put (OUT_FILE_TYPE. “10 Blank lines “); 

if REPORT_TYPE > 0 then 
put (OUT_FILE_TYra. “8"); 
else 

put (OUT_FIIJE_TYPE. FIND_PRIORny_F (STMT.TYPE’val (7)). width => 1); 
end if; 

put(OUT_FILE_TYPE.“ XXXX 0”); 

new.line (OUT_FILE_TYPE): 

end PRINT_STMrr_TYPE_10_EX; 


procedure PRINT_HOW_PRODUCED is 
begin 

new_line (OUT_FILE_TYPE); 

put.line (OUT_FILE_TyPE, “How Produced”): 

new.line (OUT_FILE_TYPE); 

end PRINT_HOW_PRODUCED; 


procedure PRINT_HOW_PRODUCED_l_IN (IN.COUNT TOTAL: in 
COUNT_TOTALS_TYPE) is 
begin 

put (OUT_FILE_TYPE, “ 1 Programmed XXXX “); 

put (OUT_FILE_TYPE, IN_COUNT_TOTALPRODUCED_NUMS J>ROGRAMMED_TOTAL, 
width => 10); 

new_line (OUT_FILE_TYPE); 

«td PRINT_HOW_PRODUCED_l_E^; 


procedure PRINT_HOW_PRODUCED_l_EX is 
begin 

put(OUT_FILE_TYPE,“l Programmed XXXX 0”); 

new_line (OUT_FILE_TYPE); 

«id PRINT_HOW_pRODUCED_l_EX; 


202 




procedure PRINT_HOW_PRODUCED_2_IN (IN_COUNT_TOTAL ; in 
COUNT_TOTALS_TYPE) is 
begin 

put (Oirr_FILE_TYPE, “ 2 Generated with source code generators XXXX “): 
put (OUT_FILE_TYPE, IN_COUNT_TOTAL.PRODUCED_NUMS.GENERATED_TOTAL. 
width => 10); 

new_line (OUT_FILE_TYPE); 
end PRINT_HOW_Pr6dUCED_2_IN; 


procedure PRINT_HOW_PRODUCED_2_EX is 
begin 

put (OUT_FILE_TYPE, “ 2 Generated with source code generators XXXX 0”); 

new_line (OUT_FILE_TYPE); 

end PRINT_HOW_PRODUCED_2_EX; 


procedure PRINT_HOW_PRODUCED_3_IN (IN_COLINT_TOTAL: in 
COUNT_TOTALS_TYPE) is 
begin 

put (OUT_FIIJE_TYPE, “ 3 Converted with automated translators XXXX “); 
put (OUT_FILE_TYPE, lN_COUNT_TOTAL.PRODUCED_NUMS.CONVERTCD_TOTAL, 
width => 10); 

new.line (OUT_FBLE_TyPE); 
end PRINT_HOW_PRODUCED_3_IN; 


procedure PRINT_HOW_PRODUCED_3_EX is 
begin 

put (OUT_FILE_TYPE, “ 3 Converted with mJtomated translators XXXX 0”); 

newjine (OUT_FILE_TYPE); 

end PRINT_HOW_PRODUCED_3_EX; 


procedure PRINT_HOW_PRODUCED_4_IN (IN_COUNT_TOTAL: in 
COUNT_TOTALS_TYPE) is 
begin 

put (OUT_FnJE_TYPE, “ 4 Copied or reused without change XXXX “); 
put (OUT_FILE_TYPE, IN.COUNT TOTAL.PRODUCED_NUMS.COPIED_TOTAL, width 
=> 10); 

newjine (OUT_FILE_TYPE); 
end PRINT_HOW_PRODUCED_4_IN; 


203 






xxxx 


0 ”): 


procedure PRINT_HOW_PRODUCED_4_EX is 
begin 

put (OUT_FILE_TYPE, “ 4 Copied or reused without change 
new.line (OUtJfILE.TYPE): 

end PRINT_HOW_PRODUCED_4_EX; 


procedure PRINT_HOW_PRODUCED_5_IN (IN_COUNT_TOTAL: in 
COUNT_TOTALS_TVPe 1 is 
begin 

put (OUT FILE TVre, “ 5 Modified XXXX “): 

put (OutIfile.type. in_count_total.produced_nums.modified_total. 

width => 10); 

new_line (OUT_FILE_TYPE); 
end PRINT_HOW_PRODUCED_5_IN; 


procedure PRINT_HOW_PRODUCED_5_EX is 
begin 

put(OUT_FILE_TYPE.“5 Modified XXXX 0”); 

new_line (OUT_FILE_TyPE); 

end PRINT_HOW_PRODUCED_5_EX; 


procedure PRINT_HOW_PRODUCED_6_IN (IN_COUNT_TOTAL: in 
COUNT_TOTALS_TYPE) is 
begin 

put (OUT FILE_TYPE,‘‘6 Removed XXXX “); 

put (OUT_FILE.TYPE, IN_COUNT_TOTAL.PRODUCED_NUMS.REMOVED_TOTAL, 
width => 10); 

newjine (OUT_FILE_TYPE); 
end PRINT_HOW_PRODUCED_6_IN; 


procedure PRINT_HOW_PRODUCED_6_EX is 
begin 

put (OUT_FILE_TYPE.“ 6 Removed XXXX 0”); 

new_line (OUT_FILE_TYPE); 
end PRINT_HOW_PRODUCED_6_EX; 


204 



procedure PRINT_ORGIN is 
begin 

new.line (OUT_FILE_TYPE); 
put.line (OUT_FILE_TYPE. “Orgin”); 
new.line (OUT_FILE_TYPE): 
end PRINT_ORGIN; 


procedure PRINT_ORGIN_l_IN {IN_COUNT_TOTAL : in COUNT_TOTALS_TYPE) is 
begin 

put (OUT_FE£_TYPE. “ 1 New Woilc: no prior existence XXXX “): 

put (OUT FILE_TYPE,IN COUNT_TOTAL.ORGIN_NUMSJ^W_WORK TOTAL, width 
=> 10 ); 

newjine (OUT_FILE_TYPE); 
end PRINT_ORGIN_l_IN; 


procedure PRINT_ORGIN_l_EX is 
begin 

put (OUT_FILE_TYPE, “ 1 New Work; no prior existence XXXX”); 

put.Iine (OUT_FILE_TYPE, “ 0”); 

end PRINT_ORGIN_I_EX; 


procedure PRINT_ORGIN_2 is 
begin 

put_line (OUT_FILE_TYPE, “ 2 Prior work: taken or ad^ted from “); 
end PRINT_ORGIN_2; 


procedure PRINT_ORGIN_3_IN (IN_COUNT_TOTAL; in COUNT_TOTALS_TYPE) is 
begin 

put (OUT_FILE_TYPE, ” 3 A previous versioii, build, or release XXXX “); 
put (OUT_FILE_TYPE, 

IN_COUNT_TOTAL.ORGIN_NUMS.PREVlOUS_VERSION_TOTAL, width => 10); 
new_line (OUT_FILE_TyPE); 
end PRINT_ORGIN_3llN; 


in'ocedure PRINT_ORGIN_3_EX is 
begin 

put (OUT_FILE_TYPE, “3 A previous version, build, or release XXXX”); 

put_Une(OUT_FILE_TYPE,“ 0”); 


205 





end PRINT_0RGIN_3_EX; 


isocedure HUNT_ORGIN_4_IN (IN_COUNT_TOTAL : in COUNT_TOTALS_TYPE) is 
begin 

put_line (OUT_FILE_TYPE, “ 4 Commercial, off the shelf software”); 
put(OUT_FILE_TYPE.“ COTS), other than libraries XXXX “); 

put (OUT_FILE_TYPE. IN_COUNT_TOTAL.ORGIN_NUMS.COTS_TOTAL, width => 10); 
new_line (OUT_FILE_TYPE); 
end PRINT_ORGIN_4_IN; 


procedure PRINT_ORGIN_4_EX is 
begin 

put_line (OUT_FILE_TYPE, “ 4 Commercial, off the shelf software”); 
put(OUT_FILE_TYPE.“ COTS), other than Ubraries XXXX”); 

put_linc(OUT_FILE_TYPE,“ 0”); 
end PRINT_ORGIN_4_EX; 


procedure PRINT_ORGIN_5_IN (IN_COUNT_TOTAL; in COUNT_TOTALS_TYPE) is 
begin 

put_line (OlJT_FILE_TYPE, “ 5 Government furnished software (GFS),”); 
put (OUT_FILE_TYPE, “ other than reuse libraries XXXX “); 

put (Oirr_FnJE_TYPE. IN_C0UNT_T0TAL.0RGIN_NUMS.GFS_T0TAL, width => 10); 
new_line (OUT_FILE_TYPE); 
end PRINT_ORGIN_5_IN; 


procedure PRINT_ORGIN_5_EX is 
begin 

put (OlJT_Ftt£_TYPE, “ 5 Government furnished software (GFS),”); 
put (OlJT_FILE_TYPE, “ other than reuse libraries XXXX”); 

put_line (OUT_FILE_TYPE. ” “); 

end PRINT_ORGIN_5_EX; 


procedure PRINT_ORGIN_6_IN (IN_COUNT_TOTAL: in COUNT_TOTALS_TYPE) is 
begin 

put (OUT_FILE_TYPE, “ 6 Another product XXXX “); 

put (OUT_FILE_TYPE, 

IN_COUNT_TOTAL.ORGIN_NUMS.ANNOTHER_PRODUCT_TOTAL, width => 10); 
new_line (OlJT_FILE_TYPE); 
end PRINT_ORGIN_6_IN; 


206 





procedure PRINT_ORGIN_6_EX is 
begin 

put(OUT_FILE_TYPE,“6 Anorher product XXXX”); 

put.line (OUT_FILE_TYPE. “ 0”); 

end PRINT_ORGIN_6_EX; 


procedure PRINT_ORGIN_7_IN (IN_COUNT_TOTAL: in COUNT_TOTALS_TYPE) is 
begin 

put_line (OUT_FE£_TYPE, “7 A vendor-supplied language support”); 
put(Oirr_FE£_TYPE.‘‘ library (unmodified) XXXX “); 

put (OUT_FILE_TYPE, IN COUNT_TOTAL.ORGIN_NUMS.VS_SPT_LIB_TOTAL, width => 
10 ): 

new.line (OUT_FILE_TYPE); 
end PRINT_ORGIN_7_IN; 


procedure PRINT_ORGIN_7_EX is 
begin 

put_line (OUT_FILE_TYPE, “7 A vendor-supplied language support”); 
put(OUT_FILE_TYPE,“ library (unmodified) XXXX”); 

put_line(OUT_FILE_TYPE,“ 0”); 
end PRINT_ORGIN_7_EX: 


procedure PRINT_ORGIN_8_IN (IN_COUNT_TOTAL: in COUNT_TOTALS_TYPE) is 
begin 

put_line (OUT_FILE_TYPE, “8 A vedor-supplied operating system or”); 
put (OUT_FIli_TYPE, “ utUity (unmodified) XXXX “); 

put (OUT_FILE_TYPE, IN_COUNT_TOTAL.ORGIN NUMS.VS_SPT_OS_TOTAL, width => 
10 ); 

new_line (OUT_FILE_TYPE); 
end PRINT_ORGIN_8_IN; 


procedure PRINT_ORGIN_8_EX is 
begin 

put_line (OlJT_FILE_TYPE, “8 A vedor-supplied operating system or”); 
put (OUT_FILE_TYPE, “ utility (unmodified) XXXX”); 

put_line(OUT_FILE_TYPE,“ 0”); 
end PRINT_ORGIN_8_EX; 


procedure PRINT_ORGIN_9_IN (IN_COUNT_TOTAL; in (X>UNT_TOTALS_TYPE) is 
begin 


207 






put.line (OUT_FILE_TYra, “9 A local or modified language support”); 

pul (OUT_FILE_TYPE." lihtffy or operating system XXXX “); 

put(OUT_FILE_TYPE. 

IN_COUNT_TOTAL.ORGIN_NUMS.LOCAL_SUPPLffiD_LIB_TOTAL. width => 10); 
new.line (OUT.FBLE.TYPE); 
end PRINT_ORGIN_9_IN; 


procedure PRINT_ORGIN_9_EX is 
begin 

put_line (0UT_F1LE_TYPE, “9 A local or modified language support”); 
put (OUT_FILE_TYPE, “ library or operating system XXXX”); 

put.line (OUT_FILE_TYPE. “ 0”); 

end PRINT_ORGIN_9_EX; 


procedure PRINT_ORGIN_10_IN (IN_COUNT_TOTAL; in COUNT_TOTALS_TYPE) is 
begin 

put(OUT_FILE_TYPE,“10 Other commercial library XXXX “); 

put (OUT_FILE_TYPE, IN_COUNT_TOTAL.ORGIN_NUMS.COMMERCIAL_LIB_TOTAL. 
width => 10); 

new_line (OlJT_FILE_TYPE); 
end PRINT_ORGIN_10_IN; 


procedure PRINT_ORGIN_lO_EX is 
begin 

put (OUT_FILE_TYPE, “10 Other commwcial Ubrary XXXX”); 

put_Une (OUT_FILE_TYPE, “ 0”); 

end PRINT_ORGIN_10_EX; 


procedure PRINT_ORGIN_l 1_IN (IN_COUNT_TOTAL: in COUNT_TOTALS_TYPE) is 
begin 

put_line (OUT_FILE_TYPE, “11 A reuse library (software designed”); 
put(OUT_FILE_TYPE,“ for reuse) XXXX “); 

put(OUT_FILE_TYPE,IN_COUNT TOTAL.ORGIN_NUMSJREUSE LIB.TOTAL, width => 
10 ); 

new_line (OUT_FILE_TYPE); 
end PRINT_ORGIN_ll_IN; 


procedure PRINT_ORGIN_l 1_EX is 
begin 

put_line (OUT_FILE_TYPE, “11 A reuse lilsary (software designed”); 
put (OUT_FILE_TYPE," for reuse) XXXX”); 


208 






put_line.(OUT_FILE_TYPE.“ 0”); 
end PRINT_ORGIN_ll_EX: 


procedure PRINT_ORGIN_12_IN (IN_COUNT_TOTAL: in COUNT_TOTALS_TYPE) is 
begin 

put(OUT_Fn-E_TYPE,‘*12 Other software component or library XXXX “): 

put (OUT_FILE_TYPE, 

IN_COUNT_TOTAL.ORGIN_NUMS.OTHER_COMPONENT_TOTAL. width => 10); 
new.line foUT.FILE.TYPE); 
end PRINT_ORGIN_12_IN; 


procedure PRINT_ORGIN_12_EX is 
begin 

put (OUT_FILE_TYPE, “12 Other software component or library XXXX”); 

puLline (OUT_FILE_TYPE. “ 0”); 

end PRINT_ORGIN_12_EX; 


procedure PRINT_USAGE is 
begin 

new_line (OUT_FILE_TYPE); 
put.line (OUT_FILE_TYPE, “Usage”); 
new_line (OUT_FILE_TYPE); 
endPRINT.USAGE; 


procedure PRINT_USAGE_1_IN (IN_COUNT_TOTAL; in COUNT_TOTALS_TYPE) is 
begin 

put (OUT_FILE_TYPE, “1 In or as part of the primary product XXXX “); 

put (OutIfile.type, 

IN_COUNT_TOTAL.USAGE_NUMS.PRIMARY_PRODUCT_TOTAL, width => 10); 
newjine (OUT_FILE_TYPE); 
end PRINT_USAGE_1_IN; 


procedure PRINT_USAGE_1_EX is 
begin 

put (OUT_FILE_TYPE, “ 1 In or as part of the primary product XXXX 0”); 

newjine (OUT_FILE_TYPE); 
end PRINT_USAGE_I_EX; 


209 






procediue reiNT_USAGE_2_IN (IN_COUNT_TOTAL: in COUNT_TOTALS_TYPE) is 
begin 

put_Iine (Oin'_FILE_TYPE, “ 2 External to or in support of the”); 
put(OUT_FELE_TYPE.“ primary product XXXX “); 

put (OUT FILE TYPE.IN_COUNT_TOTAL.USAGE NUMSiXTERNAL TOTAL, width => 
10 ); 

new_line (OUT_FILE_TYPE); 
end PRINT_USAGE_2_IN; 


procedure PRINT_USAGE_2_EX is 
begin 

put_line (OUT_FILE_TYPE, “ 2 External to or in support of the”); 
put (OUT_FILE_TYPE, “ primary product XXXX 0”): 

new.line (OUT_FILE_TYPE); 
end PRINT_USAGE_2_EX; 


procedure PRINT_DEVELOPMENT_STATUS is 
begin 

new_line (OUT_FILE_TYPE); 
put_line (OUT_FILE_TYPE, “Development Status”); 
new_line (OUT_FILE_TYPE); 
end PRINT_DEVELOPMENT_STATUS; 


procedure PRINT_DEVELOPMENT_STATUS_l_IN (IN_CX)UNT_TOTAL: in 
COUNT_TOTALS_TYPE) is 
begin 

put (OUT_FILE_TYPE,“l Estimated or planned XXXX “); 

put (OUT_FILE_TYPE, IN_COUNT_TOTAL.DEVELOPED_NUMSJESTIMATED_TOTAL. 
width => 10); 

new_line (OUT_FILE_TYPE); 
end PRINT_DEVEL0PMENT_STATUS_1_1N; 


procedure PRINT_DEVELOPMENT_STATUS_l_EX is 
begin 

put (OUT_FILE_TYPE, “ 1 Estimated or planned XXXX”); 

put_line(OUT_FILE_TYPE,“ 0”); 
end PRINT_DEVELOPMENT_STATUS_l_EX; 


procedure PRINT_DEVELOPMENT_STATUS_2_IN (1N_CX)UNT_T0TAL: in 
COUNT_TOTALS_TYPE) is 
begin 


210 




put(0UT_FILE_TYra.“2 Designed XXXX “); 

put (OUT_FILE_TYPE. IN_COUNT_TOTAL.DEVELOPED_NUMS.DESIGNED_TOTAL, 
width => 10); 

new.line (OUT_FILE_TYPE): 
end PRINT_DEVELOPMENT_STATUS_2_IN; 


procedure PRINT_DEVELOPMENT_STATUS_2_EX is 
begin 

put (OUT_FILE_TYPE.“ 2 Designed XXXX”); 

put_line (OUT_FILE_TYPE. “ 0”); 

end PRINT DEVELOPMENT_STATUS_2_EX; 


procedure PRINT_DEVELOPMENT_STATUS_3_IN (IN_COUNT_TOTAL: in 
COUNT_TOTALS_TYPE) is 
begin 

put(OUT_FILE_TYPE,“3 Coded XXXX “); 

put (OUT_FILE_TYPE. IN_COUNT_TOTAL.DEVELOPED_NUMS.CODED_TOTAL. width 
=> 10 ); 

newjine (OUT_FILE_TYPE); 
end PRINT_DEVELOPMENT_STATUS_3_IN; 


procedure PRINT_DEVELOPMENT_STATUS_3_EX is 
begin 

put(OUT_FILE_TYPE.“3 Coded XXXX”); 

put_line (OUT_FILE_TYPE. “ 0”); 

end PRINT_DEVELOPMENT_STATUS_3_EX; 


procedure PRINT_DEVELOPMENT_STATUS_4_IN (IN_COUNT_TOTAL : in 
COUNT_TOTALS_TYPE) is 
begin 

put (OUT_FILE_TYPE, “ 4 Unit tests completed XXXX “); 

put (OUT_FILE_TYPE, 

IN_COUNT_TOTAL.DEVELOPED_NUMS.UNrr_TEST_DONE_TOTAL, width => 10); 
newjine (OUT_FILE_TyPE); 
end PRINT_DEVELOPMENT_STATUS_4_IN; 


procedure PRINT_DEVELOPMENT_STATUS_4_EX is 
begin 

put (OUT_FILE_TYPE, “ 4 Unit tests completed XXXX”); 

put.Kne (OUT_FILE_TYPE. “ 0”); 

end PRINT_DEVELOPMENT_STATUS_4_EX; 


211 






procedure PRINT_DEVELOPMENT_STATUS_5_IN (IN_COUNT_TOTAL: in 
CX)UNT_TOTALS_TYPE) is 
begin 

put (OUT_FILE_TYPE, “ 5 Integrated into components XXXX “); 

put (OUT_FILE_TYPE, IN_COUNT_TOTAL.DEVELOPED_NUMS JNTEGRATED.TOTAL, 
width «> 10); 

new_line (OUT_FILE_TYPE); 
eni PRINT_DEVELOPMENT_STATUS_5_IN; 


procedure PRINT_DEVELOPMENT_STATUS_5_EX is 
begin 

put (OUT_FILE_TYPE, “ 5 Integrated into components XXXX”); 

put_line(OUT_FILE_TYPE.“ 0”); 
end PRINT_DEVELOPMENT_STATUS_5_EX; 


procedure PRINT_DEVELOPMENT_STATUS_6_IN (IN_CX)UNT_TOTAL: in 
COUNT_TOTALS_TYPE) is 
begin 

put (OlJT_FILE_TYPE, “ 6 Test readiness review completed XXXX “); 

put(OUT_FILE_TYPE. 

IN_COUNT_TOTAL.DEVELOPED_NUMS.TCST_READINESS_REVIEW_TOTAL, width => 
10 ); 

new.line (OUT_FILE_TYPE); 
end PRINT_DEVEL0PMENT_STATUS_6_1N; 


procedure PRINT_DEVELOPMENT_STATUS_6_EX is 
begin 

put (OUT_FILE_TYPE, “ 6 Test readiness review completed XXXX”); 

put_Une(OUT_FILE_TYPE.“ 0”); 
end PRINT_DEVELOPMENT_STATUS_6_EX; 


procedure PRINT_DEVELOPMENT_STATUS_7_IN (IN_CX)UNT_TOTAL: in 
COUNT_TOTALS_TYPE) is 
begin 

put (OUT_FILE_TYPE," 7 Software (CSCI) tests completed XXXX “); 

put (OUT_FIIJE_TYPE, 

IN_COUNT_TOTAL.DEVELOPED_NUMS.CSCI_COMPLETED_TOTAL, width => 10); 
new_line (OUT_FILE_TYPE); 
end PRINT_DEVELOPMENT_STATUS_7_IN; 


212 





procedure PR3^_DEVELOPMENT_STATUS_7_EX is 
begin 

put (OUT_FILE_TYPE. “ 7 Software (CSCI) tests completed XXXX”); 

put_line(OUT_FILE_TYPE.“ 0”); 
rod HUNT_DEVELOPMENT_STATUS_7_EX; 


iwocedure PRINT_DEVELOPMENT_STATUS_8_IN (IN_CX)UNT_TOTAL : in 
CX)UNT_TOTALS_TYPE) is 
begin 

put (OUT_FILE_TYPE, “ 8 System tests completed XXXX “); 

put (OUT_FILE_TYPE, IN_COUNT_TOTAL.DEVELOPED_NUMS.SYSTEM_TEST_TOTAL, 
width s> 10); 

new_line (OlJT_FILE_TYPE); 
rod PRINT_DEVELOPMENT_STATUS_8_IN; 


procedure PRINT_DEVELOPMENT_STATUS_8_EX is 
begin 

put (OUT_FILE_TYPE, “ 8 System tests completed XXXX”); 

put.Une (OUT_FILE_TVPE. “ 0”); 

end PRINT_DEVEl6pMENT_STATUS_8_EX; 


procedure PRINT_DATA_ARRAY_F is 
begin 


- check for 3D arrays 

if RECORD_FLAGS_F.PANEL3.DEF_DATA_ARRAY and 
RECORD_FLAGS_FJ>ANEUX>EF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL5.DEF_DATA_ARRAY then 
RETRIEVE_l_2D.INTERFACE_3D_MAT (REPORT.F); 
end if; 

if RECORD_FLAGS_FJ»ANEL3.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL4.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL6.DEF_DATA_ARRAY then 
RETRffiVE_2_2D.INTERFACE_3D_J^T (REPORT.F); 
end if; 

if RECORD_FLAGS_FPANEL3.DEF_DATA_ARRAY and 
RECX)RD_FLAGS_FPANEL4.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL9.DEF_DATA_ARRAY then 
RETRIEVE_8_2D.INTERFACE_3D_MAT (REPORT.F); 
end if; 

if RECORD_FLAGS_FPANEL3.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL6.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL5.DEF_DATA_ARRAY then 


213 





RETRIEVE_5_2D.INrrERFACE_3D_MAT (REPORT.F); 
end if; 

if RECORD_FLAGSJ!J»ANEL3.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL9.DEF_DATA_ARRAY and 
RECX)RD_FLAGS_FPANEL5.DEF_DATA_ARRAY then 
RETRIEVEj6_2D.INTCRFACE_3D_MAT (REPORT_F): 
end if; 

if RECORD_FLAGS_FPANEL3.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL6.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL9.DEF_DATA_ARRAY then 
RETRIEVE_9_2D.INTERFACE_3D_MAT (REPORT.F); 
end if; 

if RECORD_FLAGS_FPANEL6.DEF_DATA_ARRAYand 
RECORD_FLAGS_FPANEL4.DEF_DATA_ARRAY and 
RECORD_FLAGSJFPANEL5.DEF_DATA_ARRAY then 
RETTUEVE_1_3D,INTERFACE_3D_MAT (REPORT_F); 
end if; 

if RECORD_FLAGS_FPANEL9.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL4.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL5.DEF_DATA_ARRAY then 
RETWEVE_3_3D.INTERFACE_3D_MAT (REPORT.F); 
end if; 

if RECORD_FLAGS_FPANEL6.DEF_DATA_ARRAYand 
RECORD_FLAGS_FPANEL4.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL9.DEF_DATA_ARRAY dien 
RETOIEVE_2_3D.INTERFACE_3D_MAT (REPORT.F); 
end if; 

if RECX)RD_FLAGS_FPANEL9.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL6.DEF_DATA_ARRAY and 
RECORD.FLAGS_FPANEL5.DEF_DATA_ARRAY then 
RETRIEVE_4_3D.INTERFACE_3D_MAT (REPORT_F); 
end if; 

~ check for 2D anays 

if RE<X)RD_FLAGS_FPANEL3.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL4.DEF_DATA_ARRAY then 
REn«EVE_l_2D.INrERFACE_2D_MAT (REPORT.F); 
end if; 

if RECX)RD_FLAGS_FPANEL3.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL5.DEF_DATA_ARRAY then 
RETRIEVE_4_2D.INTERFAC:E_2D_MAT (REPORT.F); 
end if; 

if REC0RD_FLAGSj:PANEU.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL6.DEF_DATA_ARRAY then 
RETRIEVE_2_2D.INTERFAC:E_2D_MAT (REPORT.F); 
end if; 

if RECORD_FLAGS_FPANEL3.DEF_DATA_ARRAY and 
REC0RD_FLAGS_FPANEL9.DEF_DATA_ARRAY then 
RETRIEVE_8_2D.INTERFAC:E_2D_I^T (REPORT.F); 
end if; 

if REC0RD_FLAGS_FPANEL4.DEF_DATA_ARRAY and 


214 




RECC»D_FLAGS^Fi»ANEL5.DEF_DATA_ARRAY then 
RETRffiVE_3_2D.INTERFACE_2D_I^T {REPORT_F); 
end if; 

if REC0RD_FLAGS_FPANEL4.DEF_DATA_ARRAY and 
REC0RD_FLAGS_FJANEL6.DEF_DATA_ARRAY then 
RE‘nUEVE_7_2D.INTORFACE_2D_MAT (REPORT.F); 
end if; 

if RECORD_FLAGS_FPANEL4.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL9.DEF_DATA_ARRAY then 
RETRffiVE_10_2D.INTERFACE_2D_MAT (REPORT_F); 
end if; 

if RECORD_FLAGS_FPANEL6.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL5.DEF_DATA_ARRAY then 
RETRIE VE_5_2D.INTERFACE_2D_MAT (REPORT_F); 
end if; 

if RECORD_FLAGS_FPANEL5.DEF_DATA_ARRAY and 
RECORD_FLAGS^FPANEL9.DEF_DATA_ARRAY then 
RETRffiVE_6_2D.INTERFACE_2D_MAT (REPORT_F); 
end if; 

if RECORD_FLAGS_FPANEL9.DEF_DATA_ARRAY and 
RECORD_FLAGS_FPANEL6.DEF_DATA_ARRAY then 
RETRIEVE_9_2D.INTERFAC:E_2D_MAT (REP0RT_F); 
end if; 


end PRINT_DATA_ARRAY_F; 


function COUNT_STMT_TYPE(S : in STMT.TYPE; 

IN_COUNT_ARRAY: in COUNT^ARRAY.TYPE) return integer is 

TEMP_CX)UNT : integer :=0; 

begin 

for H in HOW_PRODUCED’FIRST.. HOW.PRODUCED’LAST loop 
for O in ORGIN’FIRST.. ORGEN’LAST loop 
for U in USAGE’FIRST.. USAGE’LAST loop 

for D in DEVELOPMENT.STATUS’FIRST.. DEVELOPMENT.STATUS’LAST loop 
TEMP_COUNT := TEMP_COUNT + IN_COUNT_ARRAY (S, H, O, U. D); 
end loop; 
end loop; 
end loqp; 
end loop; 

return TEMP_CX)UNT; 
end COUNT_STMT_TYPE; 


215 






function CX)UNT_HOW_HlODUCED (H ; in HOW_PRODUCED; 

IN_c6uNT_ARRAY : in COUNT_ARRAY_TYre) return integer is 

TEMP_COIJNT : integer :=0; 


begin 

for S in STMT.TYPE’FIRST.. STMT.TYPE’LAST loop 
ftw O in ORGW’FIRST.. ORGIN’LAST loop 
far U in USAGE’FIRST.. USAGE’LAST kx^ 

fw D in DEVELOPMENT_STATUS*FIRST.. DEVELOPMENT.STATUS’LAST loop 
TEMP.COUNT:« TEMP_COUNT + IN_COUNT_ARRAY (S. H. O, U. D); 
end loop; 
endloc^: 
end loop; 
end loop; 


return TEMP_COUNT; 
end COUNT_HOW_PRODUCED; 


function COUNT.ORGIN (O : in ORGIN; 

IN_COUNT_ARRAY: in COUNT_ARRAY_TYPE) return integer is 

TEMP_CX)UNT ; integer :=0; 

begin 

for S in STMT.TYPE’FIRSTSTMT_TYPE’LAST loop 
for H in HOW_PRODUCED’FIRST.. HOW.PRODUCEDXAST loop 
for U in USAGETIRSTUSAGE’LAST loop 

for D in DEVELOPMENT.STATUS’FIRST.. DEVELOPMENT.STATUS’LAST loop 
TEMP_CX)UNT ;* TEMP_COUNT + IN_COUNT_ARRAY (S, H. O. U, D); 
end loop; 
end loop; 
end loop; 
end loop; 

return ‘rEMP_CX)UNT; 
endCOUNT.ORGIN; 


function COUNT_USAGE (U : in USAGE; 

IN_COUNT_ARRAY; in COUNT_ARRAY_TYPE) return integer is 

TEMP_OOUNT : integer ;=0: 


216 






begin 

for S in STMT.TYPE’FIRST.. STMT_TYPE’LAST loop 
for H in HOW.PRODUCED’FIRST.. HOW.PRODUCED’LAST loop 
for O in ORGIN’FIRST.. ORGIN’LAST loop 

for D in DEVELOPMENT.STATUS’FIRST.. DEVELOPMENT.STATUS’LAST loq) 
TEMP.COUNT := TEMP.COUNT + IN_COUNT_ARRAY (S. H. O. U. D); 
end loop; 
end loop: 
endloc^; 
end loop; 

return TEMP_COUNT; 
endCOUNT_USAGE; 


function COUNT_DEVELOPMENT_STATUS (D ; in DEVELOPMENT.STATUS; 

IN_COUNT_ARRAY : in COUNT_ARRAY_TYPE) return integer is 

TEMP.COUNT : integer :=0; 

begin 

for S in STMT TYPE’FIRST.. STMT_TYPE’LAST loop 
for H in HOW.PRODUCED’FIRST.. HOW.PRODUCED’LAST loop 
for O in ORGIN’FIRST.. ORGIN’LAST loop 
for U in USAGE’FIRST.. US AGE’LAST loop 

TEMP.COUNT:« TEMP.COUNT + IN_COUNT_ARRAY (S, H, O, U, D); 
end loop; 
end loop; 
end loop; 
end loop; 

return TEMP_COUNT; 
end COUNT_DEVELOPMENT_STATUS; 


procedure COUNT_ATTRIBUTE_ONE (IN_RECORD_FLAGS : in FLAGS; 

IN_COUNT_TOTALS : in out COUNT_TOTALS_TYPE; 
IN.ARRAY : in COUNT. ARRAY_TYPE) is 

begin 

if IN_RECORD_FLAGS.PANEL3.1ine_l then 

IN.COUNT TOTALS.STMT_NUMS£XEC_TOTAL := COUNT.STMT.TYPE 
(STMT.TYPE’val (0). IN.ARRAY); 
end if; 

if IN.RECORD.FL AGS .PANELS .line_3 then 


217 






IN_COUm‘_TOTAl^.STl^_NUMS.DEC_TOTAL ;= COUNT_STMT_TYPE 
(STMT.TYPE’val (1). IN_ARRAY); 
end if; 

if IN_RECORD_FLAGSJ»ANEL3Jiiic_4 then 

IN_CX)Uhn'_TC)TALS.STMT_NUMSJPRAGMA_TOTAL := COUNT_STMT_TYPE 
(SThfT.TYPE’val (2). IN_ARRAY); 
end if; 

if IN_RECORD_FLAGS.PANEL3.1ine_6 then 
IN_COIJNT_TOTALS.STMT_NUMS.CMTS_ON_OWN_TOTAL := 
CX)UNT_STMT_TYPE (STMT.TYPE’val (3), IN_ARRAY); 

Old if; 

if IN_RECX)RD_FLAGSJ>ANEL3.1ine_7 Aen 
IN_COU>n'_TbTAlJS.STMT_NlJMS.CMTS_W_SRC_TOTAL := 
COin^_STMT_TYPE (STMT.TYra’val (4). IN_ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL3.1ine_8 Aen 
IN_COUhrr_TOTALS.STMT_NUMS.BANNER_CWrrS_TOTAL := 
COUOT_STMT_TYPi (STMT_TYPE’val (5). IN.ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL3.1ine_9 then 
IN_COIJNT_TOTALS.STMT_NUMS£MPTY_CMTS_TOTAL := 
COUNT_STMT_TYPE (STMT.TYPE’val (6). IN.ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL3.1ine_10 Aen 
IN_COUNT_TOTALS.STMT_NUMS.BLANK_LINES_TOTAL := 
COUNT_STMT_TYPE (STMT.TYraVal (7), W.ARRAY); 

end if; 

end COUNT.ATTRTOUTE.ONE; 


procedure COUNT_ATTRIBUTE_TWO (IN_RECORD_FLAGS : in FLAGS; 

IN_CX)lJNT_TOTALS : in out COUNT_TOTALS_TYPE; 
IN_ARRAY : A COUNT.ARRA Y_TYPE) is 

begA 

if IN_RECORD_FLAGS.PANEU.Iine_l Aen 

IN_COUNT_TOTALS.PRODUCED_NUMS.PROGRAMMED_TOTAL := 

COUNT_HOW_PRODUCED {HOW_PRODUCED’val (0), IN_ARRAY); 

end if; 

if IN_RECX)RD_FLAGS.PANEU.lme_2 Aen 
IN_COUNT_TOTALS.PRODUCED_NUMS.GENERATED_TOTAL := 

COUNT_HOW_PRODUCED (HOW_PRODUCED’val (1), IN.ARRAY); 

end if; 

if IN_RECORD_FLAGSJ»ANEL4.1Ae_3 Aen 
IN_(X)UNT_TOTALS J>RODUCED_NUMS.CONVERTED_TOTAL := 

COUNT_HOW_PRODUCED (HOW_PRODUCED’vaI (2). IN_ARRAY); 

end if; 

if IN_RECX)RD_FLAGSJ>ANEU.line_4 Aen 
IN_COUNT_TOTALS.PRODUCED_NUMS.COPIED_TOTAL;= 


218 






CX)UNT_HOW_HlODUCED (HOW.PRODUCED’val (3). IN_ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL4.Une_5 dien 

inJcount.totals-produced.nums.modified.total := 

CXJUNT.HOW.PRODUCED (HOW.PRODUCED’val (4). IN.ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL4.1ine_6 then 
IN_COUNT_TOTALS.PRODUCED_NUMS.REMOVED_TOTAL := 

COUNT_HOW_PRODUCED (HOW.HlODUCED'val (5). IN.ARRAY); 

end if; 

end CX)UNT_ATrRIBUTE_TWO; 


procedure COUNT_ATTRffilJTE_THREE (1N_REC0RD_FLAGS : in FLAGS; 

IN_COUNT_TOTALS : in out COUNT_TOTALS_TYPE; 

IN_ARRAY : in COUNT_ARRAY_TYPE) is 

begin 

if IN_RECX)RD_FLAGS.PANEL5.1ine_l then 

IN_COUNT_TOTALS.ORGIN_NLMSJ^W_WORK_TOTAL := COUNT_ORGIN 
(ORGIN’val (0). IN_ ARRAY); 
end if; 

if IN_RECORD_FLAGS.PANEL5.1ine_3 Aen 

IN_COUNT_TOTALS.ORGIN_NUMSPREVIOUS_VERSION_TOTAL:= 
COUNT_ORGIN (ORGIN’val (1). IN.ARRAY): 

end if; 

ifIN_RECX)RD FLAGS.PANEL5.1ine_4 Aen 

IN_COUNT_TOTALS.ORGIN_NUMS.COTS_TOTAL := COUNT.ORGIN (ORGIN’vaJ (2). 
IN_ARRAY); 
end if; 

if IN_RECX)RD_FLAGS.PANEL5.1me_5 Aen 

IN_COUNT_TOTALS.ORGIN_NUMS.GFS_TOTAL ;= COUNT.ORGIN (ORGIN’val (3). 
IN.ARRAY); 
end if; 

if IN_RECORD_FLAGS.PANEL5.1Ae_6 Aen 

IN_COUNT_TOTALS.ORGIN_NUMS.ANNO’rHER_PRODUCT_TOTAL:= 
COUNT_ORGIN (ORGIN’val (4), EN.ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL5.1me_7 Aen 

IN_COUNT_TOTALS.ORGIN_NUMS.VS_SPT_LIB_TOTAL := COUNT.ORGIN 
(ORGIN’val (5), IN.ARRAY); 
end if; 

if IN_RECORD_FLAGS,PANEL5.lme_8 Aen 

IN_COUNT_TOTALS.ORGIN_NUMS.VS_SPT_OS_TOTAL := CX)UNT_ORGIN 
(ORGIN’val (6), IN_ARRAY); 
end if; 

if IN_RECORI>_FLAGS.PANEL5.1Ae_9 Aen 

IN_COUNT_TOTALS.ORGIN_NUMSiOCAL_SUPPLIED_LIB_TOTAL:= 
COUNT_ORGIN (ORGIN’val (7), IN.ARRAY); 


219 




end if; 

if IN_RECX)RD_FLAGS.PANEL5.Une_10 then 
INjC0UNT_TbTALS.0RGIN_NUMS.C0MMERCIAL_Lm_T0TAL:= 
COUOT.ORGIN (ORGIN’val (8). IN.ARRAY); 

end if; 

if IN_RECORD_FLAGS.PANEL5.1ine_l 1 then 

IN_COUNT_TOTALS.ORGIN_NUMS JiEUSE_LB_TOTAL := COUNT.ORGIN 
(ORGIN’val (9), IN.ARRAY); 
end if; 

if IN_RECX)RD_FLAGS.PANEL5.Une_12 then 

inJcount_totals.orgin_nums.other_component_total:= 

COUNT_ORGIN (ORGIN’val (10). IN_ARR/.Y); 

end if; 


end COlR'rr_ATrRIBlJTE_THREE; 


procedure COUNT_ATTRIBUTE_FOUR (IN_RECORD_FLAGS : in FLAGS; 

IN_COUNT_TOTALS : in out COUNT_TOTALS_TYPE; 
IN_ARRAY : in COUNT_ARRAY_TYPE) is 

begin 

if IN_RECX)RD_FLAGS.PANEL6.1ine_l then 

IN_COUNT_TOTALS.USAGE_NUMSJ>RIMARY_PRODU(n'_TOTAL:= 
COUNT.USAGE (USAGE’val (0), IN.ARRAY); 

end if; 

if IN_RECX)RD_FLAGS.PANEL6.Une_2 then 

IN_CX)UNT_TOTALS.USAGE_NUMSJEXTERNAL_TOTAL :* COUNT.USAGE 
(USAGE’val (1), IN_ARRAY); 
end if; 

end COUNT.ATTRIBUTE.FOUR; 


procedure COUNT_ATTRIBUTE_FIVE (IN_RECORD_FLAGS : in FLAGS; 

IN_COUNT_TOTALS : in out COUNT_TOTALS_TYPE; 
IN.ARRAY : in COUNT_ARRAY_TYPE) is 

begin 

if IN_RECORD_FLAGS.PANEL9.1ine_l then 
IN_COUNT_TOTALS.DEVELOPED_NUMS.ESTlMATED_TOTAL:= 

COUNT_DEVELOPMENT_STATUS (DEVELOPMENT_STATUS’val (0), 
IN.ARRAY); 

Old if; 

if IN_RECX)RD_FLAGS.PANEL9.1ine_2 then 
IN_CX)UNT_TOTALS.DEVELOPED_NUMS.DESlGNED_TOTAL:= 

COUNT_DEVELOPMENT_STATUS (DEVELOPMENT.STATUS’val (1), 
IN.ARRAY); 


220 





end if; 

if IN_RECORD_FLAGS.PANEL9.1ine_3 ihen 
IN_COUNT_TOTALS.DEVELOPED_NUMS.CODED_TOTAL:= 

COUOT_DEVELOPMENT_STATUS (DEVELOPMENT_STATUS’val (2), 


IN.ARRAY); 
end if; 

if IN_RECX)RD_FLAGS.PANEL9.1ine_4 then 
IN_COUNT_TOTALS.DEVELOPED_NUMS.UNIT_TEST_DONE_TOTAL := 

COljNr_DEVELOPMENT_STATUS (DEVELOPMENT.STATJS’val (3). 
IN.ARRAY); 
end if; 


if IN_RECORD_FLAGS.PANEL9.1ine_5 then 

IN_COUNT_TOTALS.DEVELOPED_NUMS.INTEGRATED_TOTAL;= 

COUNT_DEVELOPMENT_STATUS (DEVELOPMENT.STATUS’val (4), 
IN.ARRAY); 
end if; 

if IN_RECORD_FLAGS.PANEL9.line_6 then 

IN_COUNT_TOTALS.DEVELOPED_NUMS.TEST_READINESS_REVIEW_TOTAL:= 
COUNT_DEVELOPMENT_STATUS (DEVELOPMENT_STATUS’val (5), 
IN_ARRAY); 
end if; 

if ]N_RECORD_FLAGS.PANEL9.1ine_7 then 
IN_COUNT_TOTALS.DEVELOPED_NUMS.CSCI_COMPLETED_TOTAL;= 
COUNT_DEVELOPMENT_STATUS (DEVELOPMENT_STATUS’val 


IN_ARRAY); 
end if; 

if IN_RECORD_FLAGS.PANEL9.1ine_8 then 

IN_COUNT_TOTALS.DEVELOPED_NUMS.SYSTEM_TEST_TOTAL;= 

COUNT_DEVELOPMENT_STATUS (DEVELOPMENT.STATUS’val (7), 
IN_ARRAY); 
end if; 


end COUNT_ATTRBUTE_FIVE; 


procedure REPORT_A (COUNT_TOTALS_A : in out COUNT_TOTALS_TYPE) is 
REPORT_A_FLAG : integer := 1; 

ESTIMATED_TOTAL ; DEVELOPMENT_STATUS ;= DEVELOPMENT_STATUS’val(0); 
begin 

new_line (OUT_FILE_TYPE, 2); 

put_Une(OUT_FILE_TYPE,“ REPORTA”): 

PRINT_REPORT_HE ADER_1; 

newjine (OUT_FILE_TYPE); 

put (OUT_FILE_TYPi, “ Counted: “); 


221 





put (OUT_FILE_TYPE, COUNT_TOTAL_LINES_A (COUNT_TOTALS_A)): 
new_line (OUT_FILE_TYPE); 
put(OUT_FILE_TYre.“ Estimated: “); 

put (OUTJFILEjrYPE. CNT_EST (ESTIMATED_TOTAL, COUNT_ARRAY_A)); 

new.line (OUT_FILE_TYPE); 

PRINT_REPORT_HEADER_2; 

PRINT_STMT_HEADER; 

PR1NT_STMT_TYPE_1_IN (COUNT_TOTALS_A, REPORT_A_FLAG): 
PRINT_STMT_TYPE_2; 

PRINT_STMT_TYPE_3_IN (COUNT_TOTALS_A, REPORT_A_FLAG); 
PRINT_STMT_TYPE_4_IN (COUNT_TOTALS_A. REPORT_A_FLAG); 
PRINT_STMT_TyPE_5; 

PRINT_STMr_TYPE_6_EX (REPORT_A_FLAG); 

PRINT_STMT_TYPE_7_EX (REPORT_A_FLAG); 

PRINT_STMT_TYPE_8_EX (REPORT_A_FLAG); 

PRINT_STMT_TYPE_9_EX (REPORT_A_FLAG); 

PRINT_STMT_TYPE_10_EX (REPORT_A_FLAG); 

PRINT_HOW_PRODUCED; 

PRINT_HOW_PRODUCED_l_IN (COUNT_TOTALS_A); 
PRINT_HOW_PRODUCED_2_IN (COUNT_TOTALS_A); 
PRINT_HOW_PRODUCED_3_IN (COUNT_TOTALS_A); 
PRINT_HOW_PRODUCED_4_IN (COUNT_TOTALS_A); 
PRINT_HOW_PRODUCED_5_IN (COUNT_TOTALS_A); 
PRINT_HOW_PRODUCED_6_EX; 

PRINT.ORGIN; 

PRINT_ORGIN_l_IN (COUNT_TOTALS_A); 

PRINT_ORGIN_2; 

PRINT_ORGIN_3_IN (COUNT_TOTALS_A); 

PRINT_ORGIN_4_IN (CX)UNT_TOTALS_A); 

PRINT_ORGIN_5_IN (COUNT_TOTALS_A); 

PRINT_ORGIN_6_IN (COUNT_TOTALS_A); 

PRINT_ORGIN_7_EX; 

PRINT_ORGIN_8_EX; 

PRINT_ORGIN_9_IN (COUNT_TOTALS_A); 

PRINT_ORGIN_10_IN (COl)NT_TOTALS_A); 

PRINT_ORGIN_ll_IN (COUNT_TOTALS_A); 

PRINT_ORGIN_12_IN (COUNT_TOTALS_A); 


- PRINT_REPORT_HEADER_2; 
PRINT_USAGE; 

PRINT_USAGE_1_IN (COUNT_TOTALS_A); 
PRINT_USAGE_2_EX; 

PRINT_DEVELOPMENT_STATUS; 

PRINT_DEVELOPMENT_STATUS_l_EX; 

PRINT_DEVELOPMENT_STATUS_2_EX; 


222 









HUNT_DEVEL0PMENT_STATUS_3_EX; 

PRINT DEVEL0PMENT_STATUS_4_EX; 
PRINT_DEVEL0PMENT_STATUS_5_EX; 
HlINT_DEVELOPMENT_STATUS_6_EX; 
PRINT_DEVEL0PMENT_STATUS_7_EX; 
PRINT_DEVEL0PMENT_STATUS_8_IN(CX)UNT_T0TALS_A); 

endREPORT.A; 


procedure REPORT_B (CX)UNT_TOTALS_B ; in COUNT_TOTALS_TYPE) is 
REP0RT_B_FLAG : integer ;= 1; 

ESTIMATEDjrOTAL : DEVELOPMENT_STATUS ;= DEVELOPMENT_STATUS’val(0); 
begin 

new_page (OlJT_FILE_TYPE); 
new.line (OUT_FILE_TYPE. 2); 

putjine (OUT_FILE_TYPE. “ REPORT B”); 

new_line (OUT_FILE_TYPE); 

PRINT_REP0RT_HEADER_1; 

newjine (OUT_FILE_TyPE); 
put(OUT_FILE_TYPE,“ Counted: “); 

put (OUT_FILE_TYPE, COUNT_TOTAL_LINES_B (COUNT_TOTALS_B)); 

new.line (OUTJTLE.TYPE); 

put (OUT_FILE_TYPE. “ Estimated: “): 

put (OUT_FILE_TYPE, CNT_EST (ESTIMATED_TOTAL, COUNT_ARRAY_B)): 
new_line (OUT_FILE_TYPE); 

PRINT_REPORT_HEADER_2; 

PRINT_STMT_HEADER: 

PRINT_STMT_TYPE_1_IN (COUNT_TOTALS_B, REPORT_B_FLAG); 
PRINT_STMT_TYPE_2; 

FRINT_STMT_TYPE_3_IN (COUNT_TOTALS_B, REPORT_B_FLAG); 
PRINT_STMT_TYPE_4_IN (COUNT_TOTALS_B. REPORT_B_FLAG); 
PRINT_STMT_TYPE_5; 

PRINT_STMT_TYPE_6_EX (REPORT_B_FLAG); 

PRINT_STMT_TYPE_7_EX (REPORT_B_FLAG); 

PRINT_STMT_TYPE_8_EX (REPORT_B_FLAG); 

PRINT_STMT_TYPE_9_EX (REPORT_B_FLAG); 

PRINT_STMT_TYPE_10_EX (REPORT_B_FLAG); 

PRINT_HOW_PRODUCED; 

PRINT_HOW_PRODUCED_l_IN (COUNT_TOTALS_B); 

PRINT_HOW_PRODUCED_2_IN (COUNT_TOTALS_B); 






HUNrr_HOW_HlODUCED_3_IN (CX)UNT_TOTALS_B); 
PRINT_H0W_PR0DUCED_4_IN (CXDUNT_TOTALS_B); 
HUNT_H0W_H10DUCED_5_IN (COUNT_TOTALS_B): 
PRINT_H0W_H10DUCED_6_IN (COUNT_TOTALS_B): 

KUNT.ORGIN; 

raiNT_ORGIN_I_IN (COUNT_TOTALS_B): 

PRINT_ORGIN_2; 

KUNT_ORGIN_3_IN (CX)UNT_TOTALS_B): 
PRINT_ORGIN_4_IN (CX)UNT_TOTALS_B): 
PRINT_ORGIN_5_IN (COUNT_TOTALS_B): 
PRINT_ORGIN_6_IN (CX)UNT_TOTALS_B): 
PRINT_ORGIN_7_EX; 

PRINT_ORGIN_8_EX; 

PRINT_ORGIN_9_IN (COUNT_TOTALS_B): 
PRINT_ORGIN_10_IN (COUNT_TOTALS_B); 
PRINT_ORGIN_ll_IN (COUNT_TOTALS_B): 
reiNT_ORGIN_12_IN (COUNT_TOTALS_B); 

- PRINT_REPORT_HEADER_2; 

PRINT_USAGE; 

PRINT_USAGE_1_IN (COUNT_TOTALS_B): 
PRINT_USAGE_2_EX; 

PRINT_DEVELOPMENT_STATUS; 

PRINT_DEVELOPMENT_STATUS_l_EX; 

PRINT DEVELOPMENT_STATUS_2_EX; 

PRINT DEVELOPMENT„STATUS_3_lN ((X>UNT_TOTALS_B) 
PRINT DEVELOPMENT_STATUS_4_IN (COUNT_TOTALS_B) 
PRINT DEVELOPMENT_STATUS_5_IN (COUNT_TOTALS_B) 
PRINT_DEVELOPMENT_STATUS_6_IN (COUNT_TOTALS_B) 
PRINT_DEVELOPMENT_STATUS_7_IN (COUNT_TOTALS_B) 
PRINT_DEVELOPMENT_STATUS_8_IN (CX)UNT_TOTALS_B) 

" Using generic package to print out two dimensional array 
-- of Development_status and How_produced 
RETRIEVE_10_2D.INTERFACE_2D_MAT (REPORT_B): 

endREPORT_B; 


procedure REPORT.C (COUNT_TOTALS_C: in COUNT_TOTALS_TYPE) is 
REPORT_C_FLAG : integer := 1; 

ESTIMATED_TOTAL : DEVELOPMENT_STATUS := DEVELOPMENT_STATUS’val(0); 
begin 

new_page (OUT_FILE_TYPE); 


224 









REPORT C”): 


new.line (OUT_FILE_TYPE. 2); 
puLline (Ol]T_FE£_TYPE, “ 
new.line (OUT_FILE_TYPE); 
PRINT_REPORT_HEADER_l; 


new_Une (OUT_FILE_TYPE); 
put(OUT_FnJE_TYPE.“ Counted: “): 

put (OUT_FILE_TYPE. COUNT_TOTAL_LlNES_C (COUNT_TOTALS_C)); 
new_line (OXJr_FILE_TYPE); 
put(OUT_FILE_TYPE.“ Estimated: “): 

put (OUT_FILE_TYPE. CNT_EST (ESTTMATED.TOTAL, COUNT_ARRAY_C)); 
new.line (OUT_FE£_TYPE); 

PRINT_REPORT_HEADER_2: 


PRINT_STMT_HEADER: 

PRINT_STMT_TYPE_1_IN (COUNT_TOTALS_C. REPORT_C_FLAG); 
PRINT_STMT_TYPE_2: 

PRINT_STMT_TYPE_3_IN (COUNT_TOTALS_C, REPORT_C_FLAG); 
PRINT_STMT_TYPE_4_IN (COUNT_TOTALS_C, REPORT_C_FLAG); 
PRINT_STMT_TYPE_5; 

PRINT_STMT_TYPE_6_IN (COUNT_TOTALS_C. REPORT_C_FLAG); 
PRINT_STMT_TYPE_7_IN (COUNT_TOTALS_C. REPORT_C_FLAG): 
PRINT_STMT_TYPE_8_EX (REPORT_C_FLAG); 
PRINT_STMT_TYPE_9_EX (REPORT_C_FLAG); 
PRINT_STMT_TYPE_10_EX (REPORT.C.FLAG); 

PRINT HOW PRODUCED; 

PRINT HOW_PRODUCED_l_IN (COUNT_TOTALS_C); 

PRINT HOW_PRODUCED_2_IN (COUNT_TOTALS_C); 
PRINT_HOW_PRODUCED_3_IN (COUNT_TOTALS_C); 
PRINT_HOW_PRODUCED_4_IN(COUNT_TOTALS_C); 
PRINT_HOW_PRODUCED_5_IN(COUNT_TOTALS_C); 
PRINT_HOW_PRODUCED_6_IN (COUNT_TOTALS_C); 


PRINT.ORGIN; 

PRINT_ORGIN_l_IN (COUNT_TOTALS_C); 
PRINT_ORGIN_2: 

PRINT_ORGIN_3_IN (COUNT_TOTALS_C); 
PRINT_ORGIN_4_IN (COUNT_TOTALS_C); 
PRINT_ORGIN_5_IN (COUNT_TOTALS_C); 
PRINT_ORGIN_6_IN (COUNT.TOTALS. C); 
PRINT_ORGIN_7_EX; 

PRINT_ORGIN_8_EX; 

PRINT_ORGIN_9_IN (COUNT_TOTALS_C); 
PRINT_ORGIN_10_IN (COUNT_TOTALS_C) 
PRINT_ORGIN_ll_IN (COUNT_TOTALS_C) 
PRINT_ORGIN_12_IN {COUNT_TOTALS_C) 


- PRINT_REPORT_HEADER_2; 


225 










PRINr.USAGE; 

PRINT_USAGE_1_IN (COUNT_TOTALS_C); 
PRINT_USAGE_2_EX: 


PRINT_DEVELOPMENT_STATUS; 

HUNT_DEVEL0PMENT_STATUS_1_EX; 

PRINT_DEVEL0PMENT_STATUS_2_EX; 

HUNT_DEVELOPMENT_STATUS_3_EX: 

PRINT_DEVELOPMENT_STATUS_4_EX; 

PRINT_DEVEL0PMENT_STATUS_5_EX; 

PRINT_DEVEL0PMENT_STATUS_6_EX; 

PRINT_DEVEL0PMENT_STATUS_7_EX; 

PRINT_DEVELOPMENT_STATUS_8_IN (COUNT_TOTALS_C); 


~ Using generic package to print out two dimensional array 
- of Statement_type and How_produced 
RE’miEVE_l_2D.INTCRFACE_2D_MAT (REPORT.C); 

endREPORT_C; 


procedure REPORT_D (COUNT_TOTALS_D: in COUNT_TOTALS_TYPE) is 
REPORT_D_FLAG : integer :=1; 

ESTIMATED.TOTAL ; DEVELOPMENT.STATUS := DEVELOPMENT_STATUS’vaI(0); 
begin 

new_page (OUT_FILE_TYPE); 
new_line (OUT_FILE_TYPE, 2); 

put_line(OUT_FILE_TYPE.“ REPORT D”); 

new_line (OUT_FILE_TYPE); 

PRINT_REPORT_HEADER_l; 

new_line (OUT_FILE_TYPE); 
put(OUT_FILE_TYPE.“ Counted: “); 

put (OUT_FILE_TYPE, COUNT_TOTAL_LINES_D (COUNT_TOTALS_D)); 

new_line (OUT_FILE_TYPE); 

put (OUT_FILE_TYPE, “ Estimated: 

put (OUT_FILE_TYPE, CNT_EST (ESTIMATED_TOTAL, COUNT_ARRAY_D)); 

ncw_line (OUT_FILE_TyPE); 

PRINT_REPORT_HEADER_2; 

PRINT_STMT_HEADER; 

HMNT_STMT_TYPE_1_IN (COUNT_TOTALS_D, REPORT_D_FLAG); 
PRINT_STMT_TYPE_2; 

PRINT_STMT_TYPE_3_IN (COUNT_TOTALS_D. REPORT_D_FLAG); 
PRINT_STMT_TYPE_4_1N (COUNT_TOTALS_D, REPORT_D_FLAG); 





PRINT_STMT_TYPE_5; 

PRINT_STMT_TyPE_6_EX (REPORT_D_FLAG): 
PRINT_STMT_TYPE_7_EX (REPORT_D_FLAG); 
IWNT_STMT_TYPE_8_EX(REP0RT_D_FLAG); 
PRINT_STMT_TYPE_9_EX (REPORT_D_FLAG); 
PRINT_STMT_TYPE_10_EX (REPORT_D_FLAG); 

PRINT_HOW_PRODUCED; 

PRINT_HOW_HlODUCED_l_IN (COUNT_TOTALS_D) 
PRINT_H0W_PR0DUCED_2_IN (COUNT_TOTALS_D) 
PRINT_H0W_H10DUCED_3_IN (COUNT_TOTALS_D) 
PRINT_H0W_PR0DUCED_4_IN (COUNT_TOTALS_D) 
PRINT_H0W_PR0DUCED_5_IN (COUNT_TOTALS_D) 
PRINT_H0W_PR0DUCED_6_IN (COUNT_TOTALS_D) 


PRINT_ORGIN; 

PRINT_0RGIN_1_IN (COUNT_TOTALS_D); 

PRINT_0RGIN_2; 

PRINT_0RGIN_3_IN (COUNT_TOTALS_D); 
PRINT_0RGIN_4_IN (COUNT_TOTALS_D); 
PRINT_0RGIN_5_IN (CX)UNT_TOTALS_D); 
HUNT_0RGIN_6_IN (COUNT_TOTALS_D); 
PRINT_0RGIN_7_EX: 

PRINT_0RGIN_8_EX; 

PRINT.0RGIN_9_IN (COUNT_TOTALS_D); 
PRINT_ORGIN_10_IN (COUNT_TOTALS_D); 
PRINT^0RGIN_11_IN (COUNT_TOTALS_D); 
PRINT_0RGIN_12_IN (COUNT_TOTALS_D); 

-- PRINT_REP0RT_HEADER_2; 

PRINT.USAGE; 

PRINT_USAGE_1_IN (COUNT_TOTALS_D); 
HyNT_USAGE_2_EX; 

PRINT_DEVELOPMENT_STATUS; 

PRINT_DEVEL0PMENT_STATUS_1_EX; 

PRINT_DEVEL0PMENT_STATUS_2_EX; 

PRINT_DEVEL0PMENT_STATUS_3_EX; 

PRINT_DEVEL0PMENT_STATUS_4_EX; 

PRINT_DEVEL0PMENT_STATUS_5_EX; 

PRINT_DEVEL0PMENT_STATUS_6_EX; 

reiNT_DEVEL0PMENT_STATUS_7_EX; 

PRINT_DEVEL0PMENT_STATUS_8_IN (COUNT_TOTALS_D); 

~ Using generic package to print out two dimensional array 
-- of Orgin and How_produced 
RETRIEVE_3_2D.INTERFACE_2D_MAT (REPORT.D); 


endREPORT_D; 


227 









procediue REPORT.E (COUNT_TOTALS_E: in COUNT_TOTALS_TYPE) is 
REPORT_E_FLAG : integer :«1; 

ESnMATED.TOTAL : DEVELOPMENT.STATUS := DEVELOPMENT_STATUS’val(0); 
begin 

new_page (OUT_FILE_TYPE); 
new line (OlJT_FILE_TYPE, 2); 

put_Bnc(OUT_FILE_TYPE.‘‘ REPORT E”); 

new_Iine (OUT_FILE_TYPE); 

PRINT_REPORT_HEADER_l; 
new_line (OUT_FII-E_TYPE); 
put(Oirr_FIIJE_TYra.“ Counted: “): 

put (0UT_F1LE_TYPE. COUNT_TOTAL_LINES_E (COUNT_TOTALS_E)); 

new_Une (OUT_FIL£_TYPE); 

put (OUT FILE TYPE," Estimated; “); 

put (OUT_FILE_TyPE, CNT_EST (ESTIMATED.TOTAL, COUNT_ARRAY_E)): 
new.line (OUT_FILE_TYPE); 

PRINT_REPORT_HEADER_2; 

PRINT_STMT HEADER; 

PRINT_STMT_TYPE_1_IN (COUNT_TOTALS_E. REPORT_E_FLAG); 
PRINT_STMT>TYPE_2; 

PRINT_STMT.TyPE_3_IN (COUNT_TOTALS_E. REPORT_E,FLAG): 
PRINT_STMT_TYPE_4_IN (COUNT_TOTALS_E. REPORT_E_FLAG): 
PRINT_STMT_TYPE_5; 

PRINT_STNn’_TYPE_6_IN (COUNT_TOTALS_E, REPORT_E_FLAG); 
PRINT_STMT^TYPE_7_IN (COUNT_TOTALS_E. REPORT_E_FLAG); 
PRINr_STMT^TYPE_8JEX (REPORT_E_FLAG); 

PRINT_STMT_TYPE_9_EX (REPORT_E_FLAG); 

HUNT_STMT_TYPE_10_EX (REPORT_E_FLAG); 

HUNT_HOW_PRODUCED; 

PRINT_HOW_HlODUCED_l_IN (COUNT_TOTALS_E); 

PRINT_HOW_PRODUCED_2_IN (COUNT_TOTALS_E); 

PRINT_HOW_PRODUCED_3_IN (COUNT_TOTALS_E); 

FRINT_HOW_PRODUCED_4_IN (COUNT_TOTALS_E); 

PRINT_HOW_PRODUCED_5_IN (COUNT_TOTALS_E); 

PRINT_HOW_reODUCED_6_IN (COUNT_TOTALS_E); 


HUNT.ORGIN; 

PRINT_ORGIN_l_IN (COUNT.TOTALS.E); 
PRINT_ORGIN_2; 

PRINT_ORGIN_3_IN (COUNT_TOTALS_E); 
PRINT_ORGIN_4_IN (CX)UNT_TOTALS_E); 
PRINT_ORGIN_5_IN (COUNT_TOTALS_E); 
PRINT_ORGIN_6_IN (COUNT.TOTALS JE); 
PRINT_ORGIN_7_EX; 


228 







PRINT_C«GIN_8_EX: 

PRINT_0RGIN_9_IN (COUNT_TOTALS_E); 
PRINT_ORGIN_10_IN (COUNT.TOTALS.E) 
PRINT_ORGIN_ll_IN (COUNT_TOTALS_E) 
PRINT_ORGIN_12_IN (COUNT_TOTALS_E) 


-- PRINT_REPORT_HEADER_2: 


PRINT.USAGE; 

PRINT_USAGE_1_IN (COUNT_TOTALS_E); 
PRINT_USAGE_2_EX; 

PRINT_DEVELOPMENT_STATUS; 

PRINT_DEVELOPMENT_STATUS_l_EX: 

PRINT_DEVELOPMENT_STATUS_2_EX; 

PRINT_DEVEL0PMENT_STATUS_3_EX; 

HUNT_DEVELOPMENT_STATUS_4_EX; 

PRINT_DEVELOPMENT_STATUS_5_EX; 

PRINT_DEVELOPMENT_STATUS_6_EX: 

HUNT_DEVEL0PMENT_STATUS_73X; 

HUNT_DEVELOPMENT_STATUS_8_IN (COUNT_TOTALS_E); 

RETRIEVE_1_2D.INTERFACE_3D_MAT (REPORT.E); 


cndREPORT.E; 


procedure REPORT_F (COUNT_TOTALS_F: in COUNT_TOTALS_TYPE) is 
REPORT_F_FLAG : integer :=-l; 

ESTIMATED.TOTAL : DEVELOPMENT_STATUS := DEVELOPMENT_STATUS’val(0); 
begin 

new_page (OUT_FILE_TYPE); 
new.line (OUT_FILE_TYPE, 2); 

put.line (OUT_FILE_TYPE. “ REPORT F”); 

new_line (OUT_FILE_TYPE); 

- Print_out_panel_3_settings; 

PRINT_REPORT_HEADER_l; 

new_line (OlJT_FILE_TYPE); 

put (OUT_Fn-E_TYPE, “ Counted; “); 

put (OtJT_FILE_TYPE, COUNT_TOTAL_LINES_F (COUNT_TOTALS_F)); 
new.line (OUT_FILE_TYPE); 
put(OUT_FILE_TYPi.“ Estimated: “); 

put (OUT_FILE_TYPE, CNT_EST (ESTIMATED_TOTAL, COUNT_ARRAY_F)); 


229 







new_line (OUT_FILE_TYPE); 

PRINT_RBPORT_HEADER_2; 

PRINT_STKfr_lffiADER; 
ifRECORD_FLAGS_FPANEL3iINE_l then 
PRINT_STMr_TYPE_l_IN (CX)UNT_TOTALS_F. REPORT_F_FLAG); 
else 

PRINT_STMT_7Yre_l_EX (REPORT_F_FLAG); 
end if; 

HUNT_STMT_TYPE_2; 

ifRECORD_FLAGS_F.PANEL3iINE_3 then 
PRINT_STMT_TYPE_3_IN (COUNT_TOTALS_F. REPORT_F_FLAG); 
else 

HUNT_STMT_TYra_3_EX (REPORT_F_FLAG); 
end if; 

if RECORD_FLAGS_F.PANEL3XINE_4 then 
PRINT_STMT_TYPE_4_IN (COUNT_TOTALS_F. REPORT_F_FLAG); 
else 

PRINT_STMT_TYPE_4_EX (REPORT_F_FLAG); 
end if; 

HUNT_STMT_TYPE_5; 

if REC0RD_FLAGS_F.PANEUiINE_6 then 
PRINT_STMT_TYPE_6_IN (COUNT^TOTALS_F, REPORT_F_FLAG); 
else 

PRINT_STMT_TYPE_6_EX (REPORT_F_FLAG); 
end if; 

if RECORD_FLAGS_FPANEL3XINE^7 then 
PRINT_STMT_TYPE_7_IN (COUNT^TOTALS_F, REPORT_F_FLAG); 
else 

PRINT_STMT_TYPE_7_EX (REPORT_F_FLAG); 
end if; 

if RECORD_FLAGS_F.PANEL3XINE_8 then 
PRINT_STMT_TYPE_8_IN ((X)UNT_TOTALS_F. REPORT_F_FLAG); 
else 

PRINT_STMT_TYPE_8_EX (REPORT_F_FLAG); 
end if; 

if RECORD_FLAGS_F.PANEL3iINE_9 then 
PRINT_STMT_TYPE_9_IN (CX)UNT_TOTALS_F, REPORT_F_FLAG); 
else 

PRINT_STMT_TYPE_9_EX (REPORT_F_FLAG); 
end if; 

if RECORD_FLAGS_FPANEL3iINE_10 then 
PRINT_STMT_TYPE_10_IN (COUNT_TOTALS_F. REPORT_F_FLAG); 
else 

PRINT_STMT_TYPE_10_EX (REPORT_F_FLAG); 
end if; 

PRINT_HOW_PRODUCED; 


230 





if RECORD_FLAGS_F.PANEUiINE_l then 
HUNT_H0W_PR0DUCED_1_IN (COUNT_TOTALS_F); 
else 

reiNT_HOW_PRODUCED_l_EX; 
end if; 

if REC0RD_FLAGS_F.PANEUI.INE_2 then 
PRINT_H0W_PR0DUCED_2_IN (COUNT_TOTALS_F); 
else 

HUNT_H0W_PR0DUCED_2_EX; 
end if; 

if RECORD FLAGS_F.PANEL41.INE_3 then 
PRINT_h6w_PRODUCED_3_IN (C0UNT_T0TALS_F): 
else 

PRINT_HOW_PRODUCED_3_EX; 
end if; 

if RECORD_FLAGS_F.PANEWiINE_4 then 
PRINT_HOW_PRODUCED_4_IN(COUNT_TOTALS_F); 
else 

PRINT_HOW_PRODUCED_4_EX; 
end if; 

ifRECORD_FLAGS_F.PANEL4iINE_5 then 
PRINT_HOW_PRODUCED_5_IN (COUNT_TOTALS_F); 
else 

PRINT_HOW_PRODUCED_5_EX; 
end if; 

if RECORD_FLAGS_F.PANEL4I-INE_6 then 
PRINT_h6w_PRODUCED_ 6_IN (C0UNT_T0TALS_F); 
else 

PRINT_HOW_PRODUCED_6_EX; 
end if; 

PRINT.ORGIN; 

if RECORD_FLAGS_F.PANEL5iINE_l then 
PRINT_ORGIN_l_IN (COUNT_TOTALS_F); 
else 

PRINT_ORGIN_l_EX; 
end if; 

PRINT_ORGIN_2; 

if RECORD_FLAGS_F.PANEL5iINE_3 then 
PRINT_ORGIN_3_IN (COUNT_TOTALS_F); 
else 

PRINT_ORGIN_3_EX; 

mdif; 

if RECORD_FLAGS_F.PANEL5XINE_4 then 
PRINT_0RG1N_4_IN (COUNT_TOTALS_F); 
else 

PRINT_ORGIN_4_EX; 


231 





end if; 

if RECX)RD_FLAGS_F.PANEL5iINE_5 then 
PRINT_0RGIN_5_IN (COUNT_TOTALS_F): 
else 

KUNT_ORGIN_5_EX; 
end if; 

if RECORD_FLAGS_F.PANEL5ilNE_6 then 
WllNT_ORGIN_6_IN (COUNT_TOTALS_F); 
else 

RRINT_0RGIN_6_EX; 
end if; 

if RECORD_FLAGS_FJ»ANEL51-INE_7 then 
PRINT_ORGIN_7_IN (COUNT_TOTALS_F); 
else 

PRINT_0RGIN_7_EX; 
end if; 

if RECORD_FLAGS_F.PANEL5iINE_8 then 
PRINT_ORGIN_8_&4 (COUNT_TOTALS_F); 
else 

raiNT_ORGIN_8_EX; 
end if; 

if RECORD_FLAGS_F.PANEL5iINE_9 then 
HUNT_0RGIN_9_1N (COUNT_TOTALS_F); 
else 

PRINT_0RGIN_9_EX; 
end if; 

if RECORD_FLAGS_F.PANEL5JLINE_10 then 
PRINT_ORGIN_10_IN (COUNT_TOTALS_F); 
else 

PRINT_ORG1N_10_EX; 
end if; 

if REC0RD_FLAGS_FPANEL51.INE_11 then 
PRINT_0RGIN_11_IN (COUNT_TOTALS_F); 
else 

PRINT_0RGIN_11_EX; 

Old if; 

if RECX)RD_FLAGS_F.PANEL51,INE_12 then 
PRINT_ORGIN_12_IN (COUNT_TOfALS_F); 
else 

PRINT_ORGIN_12_EX; 
end if; 

~ PRINT_REPORT_HEADER_2; 
PRINT.USAGE; 

if RECORD_FLAGS_F.PANEL6JLINE_l then 
PRINT_US AGE_1_IN (COUNT.TOTALS.F); 
else 

PRINrr_USAGE_l_EX; 
end if; 


232 





if RECORD_FLAGS_F.PANEL6JLINE_2 then 
PR1NT_USAGE_2 Jn (C0UNT_T0T^S_F): 
else 

PRINT_USAGE_2_EX; 
end if; 

PRINT_DEVELOPMENT_STATUS; 

if REC0RD_FLAGS_FJ>ANEL9I.INE_1 then 
PRim'_DEVELOPMENT_STATUS_T_IN(CX)UNT_TOTALS_F); 
else 

PRINT_DEVELOPMENT_STATUS_l_EX; 
end if; 

if RECORD_FLAGS_F.PANEL9LINE_2 then 
PRim'_DE\^L0PMENT_STATUS_2_IN((:0lJNT_T0TALS_F); 
else 

PRINT_DEVEL0PMENT_STATUS_2_EX; 
end if; 

if RECORD_FLAGS_F.PANEL9JLINE_3 then 
PRINT_DEVELOPMENT_STATUS_3_IN(COUNT_TOTALS_F); 
else 

PRINT_DEVEL0PMENT_STATUS_3_EX; 
end if; 

if RECORD_FLAGS_F.PANEL91.INE_4 then 
PRINT_DEVEL0PMENT_STATUS_4_IN (CX)UNT_T0TALS_F); 
else 

PRINT_DEVEL0PMENT_STATUS_4_EX; 
end if; 

if RECORD_FLAGS_F.PANEL9i,INE_5 then 
PRINT_DEVELOPMENT_STATUS_5_IN (COUNT_TOTALS_F): 
else 

PRINT_DEVEL0PMENT_STATUS_5_EX; 
end if; 

ifRECORD_FLAGS_F.PANEL9I.INE_6 then 
PRINT_DEVEL0PMENT_STATUS_6_IN (CX)UNT_TOTALS_F); 
else 

PRINT_DEVEL0PMENT_STATUS_6_EX; 
end if; 

if RECORD_FLAGS_F.PANEL9iINE_7 then 
PRINT_DEVEL0PMENT_STATUS_7_EX; 
else 

PRINT_DEVEL0PMENT_STATUS_7_EX; 
end if; 

if RECORD_FLAGS_F.PANEL9XINE_8 then 
PRINT_DEVEL0PMENT_STATUS_8_IN (C0UNT_T0TALS_F); 
else 

PRINT_DEVELOPMENT_STATUS_8_EX; 

Old if; 

PRINT_DATA_ARRAY_F; 


233 




endREPORT.F: 


procedure DETERMINE_WHICH_REPORT is 
begin 

if RECORD.FLAGSJ»ANEL2.REPORT_A then 

COUNT.ATTRIBUTE.ONE (RECORD_FLAGS_A, COUNT_TOTALS_A. 
COUNT_ARRAY_A); 

COUNT_ATTRIBUTE_TWO (RECORD_FLAGS_A, COUNT_TOTALS_A, 
COUNT_ARRAY_A); 

COUNT_ATTRIBlJTE_THREE (RECORD_FLAGS_A, COUNT_TOTALS_A, 
COUNT_AKRAY_A); 

CX)UNT_ATrRrBUTE_FOUR (RECORD_FLAGS_A. COUNT_TOTALS_A, 
COUNT_ARRAY_A); 

COUNT_ATTRIBl]TE_nVE (RECORD_FLAGS_A. CX)UNT_TOTALS_A, 
COUNT_ARRAY_A); 

REPORT.A (COUNT_TOTALS_A); 
end if; 

if RECORD_FLAGSPANEL2.REPORT_B then 
COUNT.ATTRIBUTE.ONE (RECORD_FLAGS_B, COUNT_TOTALS_B. 
COUNT_ARRAY_B); 

COUNT_ATTRIBUTE_TWO (RECORD_FLAGS_B. COUNT_TOTALS_B. 
COUNT_A^Y_B); 

CXJUNT.ATTRffiUTE.THREE (RECORD_FLAGS_B. COUNT_TOTALS_B. 
COUNT_ARRAY_B); 

COUNT_ArrRffiUTE_FOUR (RECORD_FLAGS_B, COUNT_TOTALS_B. 
COUNT_ARRAY_B); 

CXDUNT_ATmiBUTE_nVE (RECORD_FLAGS_B, COUNT_TOTALS_B, 
COUNT_ARRAY_B): 

REPORT_B (COUNT_TOTALS_B); 
end if; 

if RECORD_FLAGSJ>ANEL2.REPORT_C then 

C»UNT_ATTRIBUTE_ONE (RECORD_FLAGS_C, COUNT_TOTALS_C, 
COUNT_ARRAY_C); 

COUNT_ATrRIBUTE_TWO (RECORD_FLAGS_C, CX)UNT_TOTALS_C. 
COUNT_ARRAY_C); 

COUNT.ATTRIBUTE.THREE (RECORD_FLAGS_C, COUNT_TOTALS_C, 
COUNT_ARRAY_C); 

CX)UNT_ATrRIBUTE_FOUR (RECORD_FLAGS_C, COUNT_TOTALS_C, 
COUNT_ARRAY_C); 

COUNT.ATTRIBUTE.FIVE (RFCORD_FLAGS_C, COUNT_TOTALS_C. 
COUNT_ARRAY_C); 

REPORT_C (COUNT_TOTALS_C); 
end if; 


234 





if RECORD_FLAGSPANEL2.REPORT_D then 

COUNT_ATTRIBUTE_ONE (RECORD_FLAGS_D. COUNT_TOTALS_D. 
COUNT. ARRAY.D); 

COUNT.ATTRIBUTE.TWO (RECORD.FLAGS.D, COUNT.TOTALS.D, 
COUNT.ARRAY.D); 

COUNT.ATTRIBUTE.THREE (RECORD.FLAGS.D. COUNT.TOTALS.D, 
COUNT.ARRAY.D); 

COUNT.ATTRIBUTE.FOUR (RECORD.FLAGS.D. COUNT.TOTALS.D, 
COUNT.A]^Y.D); 

COUNT.ATTRIBUTE.FIVE (RECORD.FLAGS.D, COUNT.TOTALS.D, 
COUNT.ARRAY.D); 

REPORT.D (COUNT.TOTALS.D); 
end if; 

if RECORD.FLAGSPANEL2.REPORT.E then 

COUNT.ATTRIBUTE.ONE (RECORD.FLAGS.E, COUNT.TOTALS.E, 
COUNT.A^AY.E); 

COUNT.ATTRIBUTE.TWO (RECORD.FLAGS.E. COUNT.TOTALS.E. 
COUNT.ARRAY.E); 

COUNT.ATTRIBUTE.THREE (RECORD.FLAGS.E, COUNT.TOTALS.E. 
COUNT.ARRAY.E); 

COUNT.ATTRIBUTE.FOUR (RECORD.FLAGS.E, COUNT.TOTALS.E, 
COUNT.ARRAY.E); 

COUNT.ATTRIBUTE.nVE (RECORD.FLAGS.E, COUNT.TOTALS.E, 
COUNT.ARRAY.E); 

REPORT.E (COUNT.TOTALS.E); 
end if; 

if RECORD_FLAGSRANEL2.REPORT_F then 

COUNT.ATTRIBUTE.ONE (RECORD.FLAGS.E, COUNT.TOTALS.E, 
COUNT.ARRAY.E); 

COUNT.ATTRIBUTE.TWO (RECORD.FLAGS.E, COUNT.TOTALS.E, 
COUNT.AI^Y.F); 

COUNT.ATTRIBUTE.THREE (RECORD.FLAGS.E, COUNT.TOTALS.E, 
COUNT.ARRAY.E); 

COUNT.ATTRIBUTE.FOUR (RECORD.FLAGS.E, COUNT.TOTALS.E, 
COUNT.ARRAY.E); 

COUNT.ATTRIBUTE.nVE (RECORD.FLAGS.E, COUNT.TOTALS.E, 
COUNT.ARRAY.E); 

REPORT.F (COUNT.TOTALS.E); 
end if; 


end DETERMINE.WHICH.REPORT; 


end REPORT.PACKAGE; 


235 





GENERIC PACKAGE SPEC AND BODY 


--*_Programmed 
with textjo, 

GLOBAL; 
use text_io, 

GLOBAL; 

generic 

typeFIRST_TYreis (o); 

type SECONDJTYPE is (o); 

typeTHIRD_TYPEis (o); 

type FOlJRTH_TYPE is (o); 

type FIFTH_TYPE is (o); 

type REPORT_TYPE is (o); 

type T_NUMBER_TYPE is range o; 

with function RETRIEVE (TYPEl: FIRST_TYPE; 

TYPE2: SECOND.TYPE; 

TYPE3: THIRD_TYPE; 

TyPE4: FOURTH_TYPE; 

TYPES: FIFTH_TYPE; 

TYPE6: REPORT_TYPE) return natural; 
with function CHECK_TYPE_2 return T_NUMBER_TYPE; 
with function CHECK_TYPE_3 return T_NUMBER_TYPE; 
with procedure PRINT_ROW_HEADING (ROW_NUM: positive); 


package GENERIC_COUNTS is 

package INTEGER_IN_OUT is new integer_io (integer); 
use INTEGER_IN_OUT; 

package ENUMERATION_IN_OUT is new ENUMERATIONJO (STMT.TYPE); 
use ENUMERATrON_IN_OUT; 


procedure INTERFACE_2D_MAT (T6; in REPORT_TYPE); 


procedure INTERFACE_3D_MAT (T6: in REPORT_TYPE); 


end GENERIC.COUNTS; 


236 





package body GENERIC_COlJNTS is 


procedure HOW_KlODUCED_HEADING (1N_NUM: positive := 20) is 
TEMP : natural := IN_NUM -1; 
begin 


ifIN_NUM> 15 then 
new_line (OUT_FIIJE_TYPE); 
put.line (OUT_FILE_TYPE. “ 
Removed”): 

new_Une (OUT_FILE_TYPE. 2); 
else 

if TEMP = 0 then 
put (OUT_FILE_TYPE, “ 
elsif TEMP = 1 then 
put (OUT_FILE_TYPE, “ 
elsif TEMP = 2 then 
put (OUT_FILE_TYPE. “ 
elsif TEMP = 3 then 
put (OLnr_FILE_TYPE. “ 
elsif TEMP = 4 then 
put (OUT_FILE_TYPE. “ 
elsif TEMP = 5 then 
put (OUT_FILE_TYPE, “ 
end if; 
end if; 


Programmed Generated Converted Copied Modified 


How producedProgrammed”); 

How producedGenerated with source code generators”); 
How produced.Converted with automated translators”); 
How produced.Copied or reused without change”); 

How produced-Modified”); 

How producedRemoved”): 


end HOW.PRODUCED.HEADING; 


procedure STMT_TYPE_HEADING (IN_NUM: positive := 20) is 
TEMP : natural ;= IN_NUM -1; 
begin 


if IN_NUM >15 then 
new_line (OUT_FILE_TYPE); 
put_Une (OUT_FILE_TYPE, “ 
Banner Empty Blank”); 

new_line (OUT_FILE_TYPE, 2); 
else 

if TEMP = 0 then 
put (OUT_FILE_TYPE, “ 
elsif TEMP = 1 then 
put (OUT_FILE_TYPE, “ 
elsif TEMP = 2 then 
put (0UT_F1LE_TYPE," 
elsif TEMP = 3 then 
put (OUT_FILE_TYPE, “ 


Exec Dec Pragma Cmmts Cmmts_w_other 


Statement typeExecutable”); 

Statement type.Declarations”); 

Statement type.Compiler Directives”); 
Statement type.Comments on their own lines”); 


237 




elsif TEMP a 4 then 
put (OUT_FEi_TYPE. “ 
clsif TEMP a 5 then 
put(OUT_FILE_TYPE,“ 
elsif TEMPa6then 
put (OUT_FILE_TYPE. “ 
elsif TEMP a 7 then 
put (OUT_FILE_TYPE. “ 
end if; 
end if; 

end STMT_TYPE_HEADING; 


Statement type.Comments on lines with source code”); 
Statement type.Banners and nonblank spacers”); 
Statement type.Blank (empty) comments”); 

Statement type.Blank lines”); 


procedure USAGE_HEADING (IN_NUM: positive := 20) is 
TEMP : natural := IN_NUM -1; 
begin 


if IN_NUM > 15 then 
new_line (OUT_FILE_TYPE); 
put_line (OUT_FILE_TYPE, “ 
new.line (OUT_FILE_TYPE, 2); 
else 

ifTEMPaOthen 
put(OUT_FILE_TYPE, “ 
elsif TEMP a 1 then 
put (OUT.FILE.TYPE, “ 
end if; 
end if; 


Primary External”); 


Usage.In or as part of the primary product”); 
UsageExtemal to or in support of the primary product”); 


end USAGE_HEADING; 


procedure DEVELOPMENT_STATUS_HEADING (IN_NUM: positive := 20) is 
TEMP : natural := IN_NUM -1; 
begin 

if IN_NUM >15 then 
new_line (0UT_F1LE_TYPE); 

put_lme (OUT_FILE_TYPE, “ Est Designed Coded Unit test Integrated 

Readiness CSCI System Tests”); 
new_line (OUT_FILE_r/PE, 2); 
else 

ifTEMPaOthen 

put (OUT_FILE_TYPE, “ Development Status.Estimated or planned”); 

elsif TEMP a 1 then 


238 







puKOUT.FILE.TYPE.** 
elsif TEMP = 2then 
put (OUT_FILE_TYPE, “ 
elsif TEMP = 3 then 
put(OUT_FILE_TYPE.“ 
elsif TEMP = 4 then 
put(OUT_FE-E_TYPE.“ 
elsif TEMP = 5 then 
put (OUT_FILE_TYPE. “ 
elsif TEMP = 6 then 
put(OUT_FILE_TYPE.“ 
elsif TEMP = 7 then 
put (OUT_FILE„TYPE. “ 
end if; 
end if; 


Development Status.Designed”); 

Development Status.Coded”); 

Development Status.Unit tests completed”); 
Development Status.Integrated into components”); 
Development Status.Test readiness completed”); 
Development Status.Software (CSCI) tests completed”); 
Development Status.System tests completed”); 


end DEVELOPMENT_STATUS_HEADING; 


procedure ORGIN_HEADING (IN_NUM; positive := 20) is 
TEMP ; natural := IN_NUM -1; 


begin 

if TEMP = 0 then 
put(OUT_FaE_TYPE.“ 
elsif TEMP = 1 then 
put(OUT_FEE_TYPE.“ 
elsif TEMP = 2 then 
put (OUT_FILE_TYPE, ” 
elsif TEMP = 3 then 
put (C’JT_FILE_TYPE. “ 
elsif TLiyiP = 4 then 
put(OtIT_FILE_TYPE.“ 
elsif TEMP = 5 then 
put (OUT_FILE_TYPE, “ 
elsif TEMP = 6 then 
put (OUT_FILE_TYPE, “ 
elsif TEMP = 7 then 
put (OUT_FILE_TYPE, “ 
elsif TEMP = 8 then 
put (OUT_FILE_TYPE, “ 
elsif TEMP = 9 then 
put (OUT_FILE_TYPE, “ 
elsif TEMP = 10 then 
put (OUT_FILE_TYPE, “ 
end ift 


Orgin J4ew work”); 

Orgin.Previos version”); 

Orgin.COTS”); 

Orgin.GFS”); 

Orgin.Annother product”); 

OrginA vendor supplied language support library”); 
Orgin A vendor supplied (grating system or utility”); 
OrginA local or modified language support library”); 
Orgin.Other commercial library”); 

OrginA reuse library”); 

Orgin.Other software component or library”); 


new_line (OUT_FILE_TYPE); 






eaid ORGIN.HEADING; 


function GEN_2D_MAT (FIX_1: in FIRST_TYPE; 
FIX_2: in SECOND.TYPE; 

IN_T6 : in REPORT_TYPE) return natural is 

SUM : natural :=0: 


begin 

for T3 in THIRD_TYPE’first.. THIRD_TYPE’last loop 
for T4 in FOURTH_TYPE’first.. FOURTH_TYPE’last loop 
for T5 in FIFTH.TYPE’first.. FIFTH_TYPE’last loc^ 

SUM := SUM + RETRIEVE (FIX_1. FIX_2, T3. T4. T5. IN_T6); 
end loop; 
end loop; 
end loop; 
return SUM; 
endGEN_2D_MAT; 


function GEN_3D_MAT (FIX_1: in FIRST.TYPE; 
nX_2: in SECOND.TYPE; 

FIX_3: in THIRD.TYPE; 

IN_T6: in REPORT_TYPE) return natural is 

SUM : natural := 0; 

begin 

for T4 in FOURTH.TYPE’first.. FOURTH.TYPE’last loop 


for T5 in FIFTH_TYPE’first.. FIFTH.TYPE’last loop 
SUM := SUM + RETRIEVE (FIX_1, FIX_2, nX_3. T4. T5, IN_T6): 






return SUM; 


ciidGEN_3D_MAT; 


procedure INTERFACE_2D_MAT (T6; in REPORT.TYPE) is 

type MAT_TYPE is array (FIRST.TYre, SECOND_TYPE) of natural; 
MAT : MAT.TYPE; 

T2_NUMBER : T_NUMBER_TYPE; 

LOOP.NUM : positive := 1; 

TYPE_TWO : positive := 2; 

begin 

foe T1 in FIRST.TYPE’first.. FIRST_TYPE’last lo<^ 
for T2 in SECOND_TYPE*first.. SECX)ND_TYPE*last loop 

MAT (Tl, T2) ;= GEN_2D_MAT (Tl. T2, T6); 

end loop; 
end loop; 

T2_NUMBER := CHECK_TYPE_2; 

if T2_NUMBER« 1 then 
HOW_PRODUCED_HEADING; 
elsif T2_NUMBER = 2 then 
STMT_TYPE_HEADING; 
elsif T2_NUMBER = 3 then 
USAGE.HEADING; 
elsif T2_NUMBER = 4 then 
DEVELOPMENT_STATUS_HEADING; 
end if; 

for Tl in FIRST.TYPE’first.. FIRST.TYPE’last loop 
PRINT_ROW_HEADING (LOOP_NUM); 
for T2 in SECOND.TYPE’first.. SECOND.TYPE’last lo(^ 
put (OUT_FILE_TYPE, MAT (Tl, T2). width => 10); 
end loop; 

new.line (OUT_FILE_TYPE. 2); 

LOOP_NUM := LOOP.NUM + 1; 
end loop; 

end INTERFACE_2D_MAT; 


procedure INTERFACE_3D_MAT (T6: in REPORT_TYPE) is 


241 





type MAT.TYPE is array (FIRST.TYPE, SECOND_TYPE) of natural; 
MAT ; MAT.TYPE; 

LCX!)P_NUM_3 : positive := 1; 

LCX)P_NUM_2 : positive := 1; 

T3_NUMBER : T_NUMBER_TYPE; 

T2_NUMBER ; T_NUMBER_TYPE; 

TYra_THREE : positive:« 3; 

begin 

•• Need to find out the type of the third dimension 
T3_NUMBER := CHECK_TYPE_3; 

T2_NUMBERCHECK_TYPE_2: 

new_line (OlJT_Fn-E_TYPE, 2); 

~ need to loop through 3rd type here 

for T3 in THERD.TYPE’first.. THIRD_TYPE’last loop 

- Creating a two dimensional array with the same third dimesion 

- staying constant 

for T1 in FIRSTJTYPE’first.. FIRSTJTYPE'last loop 
for T2 in SEOOND.TYPETirst.. SECOND.TYPE’last loop 

MAT (Tl. T2) := GEN_3D_MAT (Tl. T2. T3, T6); 

end loop; 
end loop; 

- need to output the thrid dimemsion heading here 
ifT3_NUMBER= 1 then 

HOW_PRODUCED_HEADING (LOOP_NUM_3); 
elsif T3_NUMBER * 2 then 
STMT_TYPE_HEADING (LOOP_NUM_3); 
elsif T3_NUMBER = 3 then 
null; 

elsif T3_NUMBER = 4 then 

DEVELOPMENT_STATUS_HEADING (LOOP_NUM_3); 
elsif T3_NIJMBER = 5 then 
ORGIN.HEADING (LOOP_NUM_3); 
end if; 

- Need to output the second dimension as column headings 

- Finding which type is the second dimension 
if T2_NUMBER = 1 then 

HOW_PRODUCED_HEADING; 
elsif T2_NUMBER * 2 then 
STMT_TYPE_HEADING; 
elsif T2_NlJMBkR = 3 then 
USAGE_HEADING; 


242 





elsif T2_NUMBER = 4 then 
DEVELOPMENT_STATUS_HEADING: 
end if; 

- Printing out the contents of the two dimensumal matrix 
for T1 in FIRSTJTYreTirst.. FIRST TVre’last loop 
PRINT_ROW_HEADING (L<X)P_NUM_2): 
for T2 in SECWND.TYHETtrst.. SECOND.TYPE’last loop 
INit (OUT_FILE_TYRE. MAT (Tl. T2). width => 10); 
end loop; 

new.line (OUT_FILE_TYPE. 2); 

LOOP_NUM_2 := LCX)P_NUM_2 + 1; 
end loop; 

LOOP_NUM_2 := 1; 


LOOP_NUM_3 ;= LOOP_NUM_3 + 1; 


end loop; 

end INTERFACE_3D_MAT; 


end GENERIC_COUNTS; 


243 





APPENDIX C. EXTEND SAMPLE INPUT AND OUTPUT 


Contents of File list Example 

task_i»ackagejk 


Extended Example Input 

-TITLE : CS 4530 Class Project, Land^ 

~AlJnK)R : Kevin J. Walsh and Robert R. Otdonio 

- DATE : 21 Novembw 1992 

-REVISED : 22Nov.24Nov. 

-COURSE : CS4S30, Software Engineering with ADA 

- SYSTEM : UNK 

-COMPILER ; Vads6 

-DESCRIPTION : Package contains all the tasks required for the Lander Program 

- 22 Nov (1) Added code to CALCULATE task. Code was to test for the ending 

- conditions, and to be able to exit the kx^, and terminate 

- the task when ending condition was found. 

- 24 Nov (1) Reinserted the stop entry call into input task, this will be 

- called by the calculate task after the input is complete 

- (2) Recoded CALCULATE ta^ to perform calculations 

- 27 Nov (1) Integrated keytime code into this package. 


withDATA_TYPES. 

UnUTY.PKG, 

CURRENT_EXCEPnON. 

TEXTJO, 

lOCTL, 

TTY, 

OS.HLES; 
use DATA_TYPES, 

UnUTY.PKG, 

TEXTJO; 

package TASK.PACKAGE is 

- Declaration of local variables used with the package 
sgttyb_buf : tty.sgttyb; 

old.flags ; shott_integer, 

- Instaniation of Enumeration 10 to output ROCKET_CONTROL_INPUT variable 
package ’^OCKET_CONTROL_INPUTJO is new enumeration.io 

(ROCP _v;ONTROL_INPUT); 
use ROd^_CONTROL_INPUTJO; 

- Instaniation of Enumeration 10 to output the various rocket moto' 


244 





- variables, rocket positions and fuel c^iacity. 
package FUELJO is new floatjo (FUEL); 
use FUELJO; 

~ Task will peifonn all calculations for the jnogiain 
task CALCULATE.TASK is 

entry INPUT (RC)CKET_DIRECTION: in ROCKET_CONTROL_INPUT); 
end CALCULATE.TASK; 

~ Task will alk>w the user to input information to the program 
task KEYREAD is 
entry START; 
end KEYREAD; 

end TASK.PACKAGE; - Package specification for task_package 

~ Package body fw TASK.PACKAGE 
package body TASK.PACKAGE is 

~ Declaration of local variables used with package 
CRASH.EXCEPnON, 

MISS.EXCEPnON, 

SKID_EXCEPTION : exception; 


- Task allows the user to input data to the program. 

- Task will verify input to ensure that input is valid 

task body KEYREAD is 

CHARACTER_INPUT : ROCKET_CONTROL_INPUT; 
CHARACTERJO ; character; 

DONE : boolean := FALSE; 

TEST : natural; 

begin 

select 

accept start; 
or 

terminate; 
end select; 

loop 

~ Get information from the user 
get (CHARACTERJO); 

- Detomine what the user wants to do 
case CHARACTERJO is 
when ‘u’ => 
test;= 0; 


245 





when ‘i* »> 
test;«1; 
when ‘o’ »> 
test ;s 2: 
when ‘p’ 
testts 3; 
when ‘h’ => 
test:« 4; 
when ‘j* ss> 
test:s S; 
when ‘k’ => 
test :s 6; 
when ‘1’ 
test:* 7; 
when ‘v’ *> 
test:* 8; 
when *b’ »> 
test :* 9; 
when ‘n’ *> 
test :* 10; 
when *m’ *> 
test:* 11; 
when others *> 
new_line (2); 

put.line (“ You have entered the wrong input. Please try againi’O; 
end case; 

- Cmivert input to rocket control input 

CHARACTCR.INPUT := ROCKET_CX)NTROL_INPUT’VAL(TEST); 
CALCULATE.TASKJNPUT (CHARACTER.INPUT): 

end loop; 

exception 
when others *> 
new_line(2); 

put_Iine(cunent_cxception.exception_nanie & “ raised in calculate task.”); 
new_line(2); 

put_line(“Exiting from the input task. “); 
new_line(2); 

endkeyread; 


- Task will perform all calculations for the program. Task 
" will also check landing and call display procedure to 
~ show status of lander information. 


task body CALCULATE_TASK is 

- Declaration (tf variables used with the task 
CX)NTROL_ROCKEr ; RC)CKET_CONTROL_INPUT; 


246 






TEST 


: natural; 


begin 

kxq) 

select 

~ Option to handle user input 

accept INPUT (ROCKET.DIRECnON : in ROCKET_CONTROL_INPUT) do 
CONTROL.ROCKET ;= ROCKET.DlRECnON; 
end INPUT; 

or 

-- No user input therefore calculate with previous data 
delay 1.0; 

CONTROL_ROCKET := A; 
end select; 

- Conditional to determine if lander has fuel to manipulate rockets 
if FUEL_LEFT > 0.0 then 
" Case statement to reset specific rocket input 
case CONTROL_ROCKET is 
when U => 

POSmVE_ROCKETS.X := POSITIVE.ROCKETS.X + 1.0; 
when I => 

if POSrnVE_ROCKETS.X > 0.0 then 
POSrnVE_ROCKETS.X ;= POSITIVE.ROCKETS.X -1.0; 
end if; 
when O => 

NEGATIVE_ROCKETS.X := NEGATIVE_ROCKETS.X + 1.0; 
when P *> 

if NEG ATIVE_ROCKETS.X > 0.0 then 
NEGATIVE_ROCKETS.X := NEGATIVE_ROCKETS.X -1.0; 
end if; 
when H => 

POSmVE_ROCKETS.\ :=POSrnVE_ROCKETS.Y+1.0; 
when J => 

if POSmVE.ROCKETS.Y > 0.0 then 
POSmVE.ROCKETS.Y := POSmVE.RCXTKETS.Y -1.0; 
end if; 
when K => 

NEGATTVEJIOCKETS.Y ;= NEGATIVE_ROCKETS.Y + 1.0; 
when L => 

if NEGATIVE_ROCKETS.Y > 0.0 then 
NEGATTVE.ROCKETS.Y := NEGATIVE.ROCKETS.Y -1.0; 
end if; 
when V => 

POSmVE_ROCKETS2 := POSrnVE_ROCKETS.Z + 1.0; 
when B => 

if P0SrnVE_R0CKETS2 > 0.0 then 
POSmVE_ROCKETSZ := POSrnVE_ROCKETS.Z -1.0; 
end if; 


247 




when N «> 

NEGATIVE.ROCKETS^ :» NEGATIVE.ROCKETS^ + 1.0; 
whraMs> 

if NEGATIVE_ROCKETS.2 > 0.0 then 
NEGATIVE_ROCKETS.Z:» NEGATTVE.ROCKETS.Z -1.0; 
end if; 

when OTHERS => 
null; 

end case; 
else 

~ FUEL.LEFT s 0 therefcne all engines ^uld be at 0.0 
POSrrr^.ROCKETS := (others =>0.0); 

NEGATIVE.ROCKETS (others-> 0.0); 
end if; 

- Calculation for new current position 

CURRENT_POSrnONS.X :* CURRENT^POSITIONS.X + DELTA_VECTOR.X; 
CURRENT.POSmONS.Y := CURRENT.POSITIONS.Y + DELTA_VECTOR.Y; 
CURRENT_POSrnONS.Z := CURRENT_POSmONS.Z + DELTA.VECTORZ; 

- CDalculation for new delta vector 

DELTA_VECTOR.X :» POSITIVE.ROCKETS.X - NEGATlVE_ROCKETS JC; 
DELTA_VECTOR.Y := POSITIVE.ROCKETS.Y - NEGATIVE.ROCKETS.Y; 
DELTA_VECTOR.Z := POSmVE.ROCKETSZ - NEGATIVE.RtXKETSJZ - 9.8; 

- Calculation for new fuel left value 

FUEL_LEFT := FXJEL_LEFT - (POSmVE.ROCKETS + 
POSmVE.ROCKETS.Y + 

POSmVE_ROCKETSJZ + 

NEGATIVE.ROCKETS.X 
NEGATIVE.ROCKETS.Y + 

NEGAnVE_ROCKETS.Z); 


- Procedure to display to screen position and info 
DISPLAY (FUEL.LEFT, POSmVE.ROCKETS, NEGATTVE.ROCKETS, 
DELTA.VECTOR, 

START_POSmONS, CURRENT.POSrnONS, FINAL.POSITIONS); 


- Test to detennine if current position Z tower than final position Z 
if CURRENT.POSmONSZ: <= FINAL.POSITIONSJZ then 
exit; 
end if; 


end loop; - Main initial loop to cycle through calculation task 

- EVALUATE THE LOCATION AND VELOCITY OF LANDER 
if MISS_DISTANCE (CURRENT.POSITIONS.X. 
FINAL_POSrnONS.X, 

CURRENT.POSmONS.Y, 

FINAL_POSmONS.Y) then 
- LANDING IS CONSIDERED A MISS 


248 






raise MISS.EXCEPTION; 


elsif SKID_DISTANCE (DELTA_VECTOR.X. 

DELTA_VECTOR.Y) then 

- LANDING IS CONSIDERED A SKID 
raise SKID.EXCEPnON: 

elsif CRASH_DISTANCE (DELTA.VECTORZ) then 

- LANDING IS CONSIDERED A CRASH 
raise CRASHJEXCEPTION; 

else 

- LANDING IS CONSIDERED A SUCCESS!!!! 
new_line(2); 

put_line(“CONGRATULATIONS. Successful landing accomplished. “); 
new_line(2); 
abort KEYREAD; 
end if; 

exception 

when MISS_EXCEPnON => 
new_line (2); 

put_Iine (“ SORRY, BUT THE LANDING IS CONSIDERED A MISS”); 
put_line (“ Calculations stopped, program aborted. “); 
new_line (2); 
abort KEYREAD; 
when SKID_EXCEPTION => 
new line (2); 

putjine (“ SORRY, BUT THE LANDING IS CONSIDERED A SKID”): 
put_line(“ Calculations stopped, program aborted. “); 
new_line (2); 
abort KEYREAD; 
when CRASH_EXCEPTION => 
new_line (2); 

put_Une (” SORRY, BUT THE LANDING IS CONSIDERED A CRASH”); 
new_line (2); 
abort KEYREAD: 

end CALCULATE.TASK; 

end TASK_PACKAGE; ~ Package body for task_package 


249 





Extended Example Output 


! 

i 

j 

REPORT A 


Rqxfft Name: Thesis example 
Fite List used: example 
Requested by: Kevin J. Walsh 

Measured as: Physical source lines 

Delivered as: Delivered as source 


Counted: 193 

Estimated: 0 


Total Total Individual 
Includes Excludes totals 


Statement type 

When a line or statement contains more than 
one ^pe, classify it as the type with the 
high^ precedence. 


1 Executables Precedence *> 1 XXXX 157 

2 Nonexecutables 


3 

4 

5 

6 

7 

8 

9 

10 


Declarations 2 XXXX 36 

Compiler Directives 3 XXXX 0 

Comments 


On their own lines 4 

On lines with source code 5 
Banners and nonblank spacers 6 
Blank (empty) comments 7 
Blank lines 8 


XXXX 0 
XXXX 
XXXX 
XXXX 

XXXX 0 


0 

0 

0 


How Produced 


1 Programmed XXXX 193 

2 Genoated with source code generators XXXX 0 

3 Converted with automated translators XXXX 0 

4 Copied or reused without change XXXX 0 

5 Modified XXXX 0 

6 Removed XXXX 0 


Orgin 

1 New Weak: no prior existence XXXX 193 


250 





2 Priwwotk: taken or adapted from 

3 A previous version, build, or release XXXX 0 

4 Comnrercial, off the shelf software 

COTS), otho* than libraries XXXX 0 

5 Government furnished software (GFS), 

other dian reuse libraries XXXX 0 

6 Another product XXXX 0 

7 A vendor-suf^lied language support 

library (unmodified) XXXX 0 

8 A ve^-supplied operating system or 

utility (unmodified) XXXX 0 

9 A local or modified language support 

library ot operating system XXXX 0 

10 Other commocial library XXXX 0 

11 A reuse library (software designed 

for reuse) XXXX 0 

12 Other software component or library XXXX 0 

Usage 

1 In or as part of the primary product XXXX 193 

2 External to or in support of the 

primary product XXXX 0 

Development Status 

1 Estimated or planned XXXX 0 

2 Designed XXXX 0 

3 Coded XXXX 0 

4 Unit tests completed XXXX 0 

5 Integrated into components XXXX 0 

6 Test readiness review completed XXXX 0 

7 Software (CSCI) tests completed XXXX 0 

8 System tests completed XXXX 193 


251 






REPORT B 


Repent Name: Thesis example 
File List used: example 
Requested by: Kevin J. Walsh 

Measured as: Physical source lines 

Delivered as: Delivered as source 


Counted: 193 

Estimated: 0 


Total Total Individual 
Includes Excludes totals 


Statement type 

When a liiM or statement contains more than 
one type, classify it as the type with die 
highest precedence. 


1 Executables Precedence => 1 XXXX 157 

2 Nonexecutables 

3 Declarations 2 XXXX 36 

4 Compiler Directives 3 XXXX 0 

5 Comments 

6 On their own lines 4 XXXX 0 

7 On lines with source code 5 XXXX 0 

8 Banners and nonblank spacers 6 XXXX 0 

9 Blank (empty) comments 7 XXXX 0 

10 Blank lines 8 XXXX 0 


How Produced 

1 Programmed XXXX 

2 Genoated with source code generators XXXX 

3 Converted with automated translators XXXX 

4 Copied or reused without change XXXX 

5 Modified XXXX 

6 Removed XXXX 

Orgin 

1 New Work: no prior existence XXXX 193 

2 Pricrwoik: taken or adapted fiom 

3 A previous version, build, or release XXXX 0 

4 Commercial, off the shelf software 

COTS), other than libraries XXXX 0 



252 





5 Government furnished software (GFS). 

other than reuse libraries XXXX 0 

6 Another i»x)duct XXXX 0 

7 A vendcv-supplied language support 

library (unmodified) XXXX 0 

8 A ve^-supplied operating system or 

utility (unmoved) XXXX 0 

9 A local or modified language support 

library or operating system XXXX 0 

10 Other commercial library XXXX 0 

11 A reuse litwary (software designed 

for reuse) XXXX 0 

12 Other software component or lilMary XXXX 0 

Usage 

1 In or as part of the primary product XXXX 193 

2 External to or in support of the 

primary product XXXX 0 

Development Status 

1 Estimated or plarmed XXXX 0 

2 Designed XXXX 0 

3 Coded XXXX 0 

4 Unit tests completed XXXX 0 

5 Integrated into components XXXX 0 

6 Test readiness review completed XXXX 0 

7 Software (CSCI) tests completed XXXX 0 

8 System tests completed XXXX 193 


Progranuned Generated Converted Copied Modified Removed 


Estimated or 

planned 0 0 0 0 0 0 

Designed 0 0 0 0 0 0 

Coded 0 0 0 0 0 0 

Unit tests com¬ 
pleted 0 0 0 0 0 0 

Integrated into 

ctxnponents 0 0 0 0 0 0 

Test readiness 
review com¬ 
pleted 0 0 0 0 0 0 


253 





Software (CSQ) 

tests cmnpleted 0 0 0 0 0 

System tests 

completed 193 0 0 0 0 


254 






REPORT C 


RqxHt Name: Th^is example 
File List used: example 
Requested by: Kevin J. Walsh 

Measured as: Physkal source lines 

Delivered as: Delivered as source 


Counted: 240 

Estimated: 0 


Total Total Individual 
Includes Excludes totals 


Statement type 

When a line or statement contains more than 
one type, classify it as the type with the 
highest precedence. 

1 Executables Precedence => 1 XXXX 1S7 

2 Nonexecutables 

3 Declarations 2 XXXX 36 

4 Compiler Directives 3 XXXX 0 

5 Comments 

6 On their own lines 4 XXXX 47 

7 On lines with source code 5 XXXX 0 

8 Banners and nonblank spacers 6 XXXX 0 

9 Blank (empty) comments 7 XXXX 0 

10 Blank lines 8 XXXX 0 

How Produced 

1 Programmed XXXX 240 

2 Generated with source code generators XXXX 

3 Converted with automated cranslamrs XXXX 

4 Copied or reused without change XXXX 

5 Modified XXXX 0 

6 Removed XXXX 0 

Orgin 

1 New Work: no (nior existence XXXX 240 

2 PriOTwork: taken w adapted from 

3 A previous version, build, or release XXXX 0 

4 Commercial, off the shelf software 


0 

0 

0 


255 



COTS), other than libraries XXXX 0 

5 Govenunent furnished software (GFS), 

other than reuse libraries XXXX 0 

6 Another product XXXX 0 

7 A vendor-supplied language sigjport 

library (unmoved) XXXX 0 

8 A veto-aipidied operating system or 

utility (unmcxlified) XXXX 0 

9 A lo^ or modified language support 

library or (iterating system XXXX 0 

10 Other commercial library XXXX 0 

11 A reuse library (software derigned 

for reuse) XXXX 0 

12 Other software component or library XXXX 0 

Usage 

1 In or as part of the primary product XXXX 240 

2 External to or in siqtport of the 

primary product XXXX 0 

Development Status 

1 Estimated or platmed XXXX 0 

2 Designed XXXX 0 

3 Coded XXXX 0 

4 Unit tests completed XXXX 0 

5 Integrated into components XXXX 0 

6 Test readiness review completed XXXX 0 

7 Software (CSCI) tests completed XXXX 0 

8 System tests completed XXXX 240 


Programmed Generated Converted Copied Modified Removed 


Executable 

157 

0 

0 

0 

0 0 

Declarations 

36 

0 

0 

0 

0 0 

Compiler dir- 

ectives 

0 

0 

0 

0 

0 0 

Comments on 

their own line 

47 

0 

0 

0 

0 0 

Comments on 
lines with 
source code 

0 

0 

0 

0 

0 0 

Banner and non- 

blank spacers 

0 

0 

0 

0 

0 0 


256 




Blank (onpty) 

comments 0 0 0 0 0 0 

Blank lines 0 0 0 0 0 0 


257 





REPORT D 


RqiKxt Name: Thesis example 
File List used: example 
Requested by: Kevin J. Walsh 

Measured as: Physical source lines 

Delivered as: Delivered as source 


Counted: 193 

Estimated: 0 


Total Total Individual 
Includes Excludes totals 


Statement type 

When a line or statement contains more than 
one type, classify it as die type with the 
high^ precedence. 


1 Executables Precedence s> 1 XXXX 1S7 

2 Nonexecutables 


3 Declarations 2 XXXX 36 

4 Compiler Directives 3 XXXX 

5 Comments 

6 On their own lines 4 XXXX ( 

7 On lines with source code S XXXX 

8 Baruiers and nonblank spacers 6 XXXX 

9 Blank (empty) comments 7 XXXX 

10 Blanklines 8 XXXX 0 


0 

0 

0 


How Produced 


1 Programmed XXXX 193 

2 Genoated with source code generators XXXX 0 

3 Converted with automated translators XXXX 0 

4 Copied or reused without change XXXX 0 

5 Modified XXXX 0 

6 Removed XXXX 0 


Orgin 

1 New Work: no prior existence XXXX 193 

2 Prior work: taken or adtgited fiom 

3 A previous version, build, or release XXXX 0 

4 Commercial, off the shelf software 

COTS), odier than libraries XXXX 0 


258 





5 Govenunent furnished software (GFS), 

other than reuse libraries XXXX 0 

6 Another product XXXX 0 

7 A vendor-supplied language support 

Ubiary (unmoved) XXXX 0 

8 A ve^-supplied (^lerating system or 

utility (unmodified) XXXX 0 

9 A local or modified language support 

liluary or operating system XXXX 0 

10 Oth^ commercial library XXXX 0 

11 A raise libr^ (software designed 

fcv reuse) XXXX 0 

12 Other software component (u library XXXX 0 

Usage 

1 In or as part of the primary product XXXX 193 

2 External to or in support of the 

primary product XXXX 0 

Development Status 

1 Estimated or planned XXXX 0 

2 Designed XXXX 0 

3 Coded XXXX 0 

4 Unit tests completed XXXX 0 

5 Integrated into components XXXX 0 

6 Test readiness review completed XXXX 0 

7 Software (CSCI) tests completed XXXX 0 

8 System tests completed XXXX 193 


Programmed Generated Converted Copied Modified Removed 


New Work; no 

prior existence 193 0 0 0 0 0 

A previos ver¬ 
sion, build, 

or release 0 0 0 0 0 0 

COTS 0 0 0 0 0 0 

GFS 0 0 0 0 0 0 

Another {Hoduct 0 0 0 0 0 0 

A vendor suj^l- 
ied language 

support library 0 0 0 0 0 0 


259 




A vendor<sun>l- 

Kdq)erating 

systems 

utility 0 0 0 0 0 0 

A local w mod¬ 
ified language 
support library 
or operating 

system 0 0 0 0 0 0 

Other commer¬ 
cial liixary 0 0 0 0 0 0 

A reuse library 
(software 
desigiMd fw 

reuse 0 0 0 0 0 0 

Other software 
component or 

library 0 0 0 0 0 0 


260 





REPORT E 


Reprat Name: Thesis example 
Fite List used: example 
Requested by: Kevin J. Walsh 

Measured as: Physical source lines 

Delivered as: Delivered as source 


Counted: 240 

Estimated; 0 


Total Total Individual 
Includes Excludes totals 

Statement type 

When a line or statement contains more than 
one type, classify it as the type with the 
high^t precedence. 


1 Executables Precedence => 1 XXXX 157 

2 Nonexecutabtes 

3 Declarations 2 XXXX 36 

4 Compiler Directives 3 XXXX 0 

5 Comments 

6 On their own lines 4 XXXX 47 

7 On lines with source code 5 XXXX 0 

8 Banners and nonblank spacers 6 XXXX 0 

9 Blank (empty) comments 7 XXXX 0 

10 Blank lines 8 XXXX 0 


How Produced 


1 Programmed XXXX 240 

2 Generated with source code generators XXXX 

3 Converted with automated translators XXXX 

4 Copied or reused without change XXXX 

5 Modified XXXX 0 

6 Removed XXXX 0 


0 

0 

0 


Orgin 

1 NewWwk: no prior existence XXXX 240 

2 Prior worL* taken or adapted from 

3 Aprevious version, build, or release XXXX 0 

4 Commercial, off the shelf software 

COTS), other than libraries XXXX 0 


261 







5 Govenunent fwnished software (GFS). 

other than raise libraries XXXX 0 

6 Anoth^product XXXX 0 

7 A vendor-supplied language suppot 

library (unmodified) XXXX 0 

8 A vedor-supplied operating system or 

udhQr (unmodifietO XXXX 0 

9 A local or modified language support 

library <x operating syston XXXX 0 

10 Other commocial liltfary XXXX 0 

11 A reuse library (software designed 

for reuse) XXXX 0 

12 Other software component or library XXXX 0 

Usage 

1 In or as part of the primary [Htxluct XXXX 240 

2 External to or in support of the 

primary [noduct XXXX 0 

Development Status 

1 Estime dor planned XXXX 0 

2 Designed XXXX 0 

3 Coded XXXX 0 

4 Unit tests completed XXXX 0 

5 Integrated into components XXXX 0 

6 Test readiness review completed XXXX 0 

7 Software (CSCI) tests completed XXXX 0 

8 System tests completed XXXX 240 


Orgin J4ew work 

Programmed Generated Converted Copied Modified Removed 


Executable 

157 

0 0 0 

0 

0 

Declarations 

36 

0 0 0 

0 

0 

Compiler dir- 

ectives 

0 

0 0 0 

0 

0 

Comments on 

their own line 

47 

0 0 0 

0 

0 

Comments on 
lines with 
source code 

0 

0 0 0 

0 

0 


262 




Banner and non¬ 
blank spacers 0 0 0 0 0 0 

Blank (empty) 

comments 0 0 0 0 0 0 

Blank lines 0 0 0 0 0 0 

OrginPrevios version 

Programmed Generated Converted Copied Modified Removed 

Executable 0 0 0 0 0 0 

Declarations 0 0 0 0 0 0 

Compiler dir- 

ectii*es 0 0 0 0 0 0 

Comments on 

their own line 0 0 0 0 0 0 

Comments on 
lines with 

source code 0 0 0 0 0 0 

Banner and non¬ 
blank spacers 0 0 0 0 0 0 

Blank (empty) 

comments 0 0 0 0 0 0 

Blank lines 0 0 0 0 0 0 

Orgin.COTS 

Programmed Generated Converted Copied Modified Removed 

Executable 0 0 0 0 0 0 

Declarations 0 0 0 0 0 0 

Compiler dir¬ 
ectives 0 0 0 0 0 0 

Comments on 

their own line 0 0 0 0 0 0 

Comments on 


263 





lines with 
source code 


0 0 0 0 0 0 


Banner and non¬ 
blank spacers 0 0 0 0 0 0 

Blank (empty) 

comments 0 0 0 0 0 0 

Blank lines 0 0 0 0 0 0 

Orgin.GFS 

Programmed Generated Converted Copied Modified Removed 


Executable 0 0 0 0 0 0 

Declarations 0 0 0 0 0 0 

Compiler dir¬ 
ectives 0 0 0 0 0 0 

Comments on 

their own line 0 0 0 0 0 0 

Comments on 
lines with 

source code 0 0 0 0 0 0 

Banner and non¬ 
blank spacers 0 0 0 0 0 0 

Blank (empty) 

comments 0 0 0 0 0 0 

Blank lines 0 0 0 0 0 0 

Orgin-Annother product 

Programmed Generated Converted Copied Modified Removed 

Executable 0 0 0 0 0 0 

Declaratitms 0 0 0 0 0 0 

Compiler dir¬ 
ectives 0 0 0 0 0 0 

Comments on 


264 




their own line 0 0 0 0 0 0 

Conunents on 
lines with 

source code 0 0 0 0 0 0 

Banner and non¬ 
blank spacers 0 0 0 0 0 0 

Blank (onpty) 

comments 0 0 0 0 0 0 

Blank lines 0 0 0 0 0 0 

Orgin.A vendor supplied language sun^ort library 
Programmed Generated Converted Copied Modified Removed 

Executable 0 0 0 0 0 0 

Declarations 0 0 0 0 0 0 

Compiler dir¬ 
ectives 0 0 0 0 0 0 

Comments on 

their own line 0 0 0 0 0 0 

Comments on 
lines with 

source code 0 0 0 0 0 0 

Banner and non¬ 
blank spacers 0 0 0 0 0 0 

Blank (empty) 

comments 0 0 0 0 0 0 

Blank lines 0 0 0 0 0 0 

Orgin.A vendor supplied operating system or utility 
Programmed Generated Converted Copied Modified Removed 

Executable 0 0 0 0 0 0 

Declarations 0 0 0 0 0 0 

Compiler dir- 


265 




Comments on 
their own line 

Comments on 
lines with 
source code 

Banno' and non- 
blank qiaceis 

Blank (empty) 
comments 

Blank lines 


0 0 0 

0 0 0 

0 0 0 

0 0 0 
0 0 0 


0 0 0 

0 0 0 

0 0 0 

0 0 0 
0 0 0 


Orgin.A local or modified language support library 
Programmed Genmted Converted Copied Modified Removed 


Executable 


0 0 0 0 0 0 


Declarations 


0 0 0 0 0 0 


Compiler dir¬ 
ectives 0 0 0 0 0 0 

Comments on 

their own line 0 0 0 0 0 0 

Comments on 
lines with 

source code 0 0 0 0 0 0 

Banner and non¬ 
blank spacers 0 0 0 0 0 0 

Blank (empty) 

comments 0 0 0 0 0 0 


Blank lines 


0 0 0 0 0 0 


Orgin.Other commercial library 


Programmed Generated Converted Copied Modified Removed 


0 0 0 0 0 0 


266 


Executable 






Declarations 


0 0 0 0 0 0 


Compiler dir- 

ectivea 0 0 0 0 0 0 

Comments on 

their own line 0 0 0 0 0 0 

Comments on 
lines with 

source code 0 0 0 0 0 0 

Banner and non¬ 
blank spacers 0 0 0 0 0 0 

Blank (empty) 

comments 0 0 0 0 0 0 

Blank lines 0 0 0 0 0 0 

Orgin.A reuse library 

Programmed Generated Converted Copied Modified Removed 


Executable 0 0 0 0 0 0 

Declarations 0 0 0 0 0 0 

Compiler dir¬ 
ectives 0 0 0 0 0 0 

Comments on 

their own line 0 0 0 0 0 0 

Comments on 
lines with 

source code 0 0 0 0 0 0 

Banner and non¬ 
blank spacers 0 0 0 0 0 0 

Blank (empty) 

comments 0 0 0 0 0 0 

Blank lines 0 0 0 0 0 0 

Orgin.Other software component or library 
Programmed Generated Converted Copied Modified Removed 


267 






Executable 0 0 0 0 0 0 

Declarations 0 0 0 0 0 0 

Compiler dir¬ 
ectives 0 0 0 0 0 0 

Comments on 

their own line 0 0 0 0 0 0 

Comments on 
lines with 

source code 0 0 0 0 0 0 

Banner and non¬ 
blank spacers 0 0 0 0 0 0 

Blank (empty) 

comments 0 0 0 0 0 0 

Blank lines 0 0 0 0 0 0 


268 






REPORT F 


Report Name: Thesis example 
File List used: example 
Requested by: Kevin J. Walsh 

Measured as: Physical source lines 

Delivered as: Delivoed as source 


Counted: 284 

Estimated: 0 

Total Total Individual 
Includes Excludes totals 

Statement type 

When a line or statement contains more than 
one type, classify it as the type with the 
highest precedence. 


1 Executables Precedence => 1 XXXX 157 

2 Nonexecutables 

3 Declarations 2 XXXX 36 

4 Compiler Directives 3 XXXX 0 

5 Comments 

6 On their own lines 4 XXXX 47 

7 On lines with source code 5 XXXX 0 

8 Banners and nonblank spacers 6 XXXX 5 

9 Blank (empty) comments 7 XXXX 0 

10 Blank lines 8 XXXX 39 

How Produced 

1 Programmed XXXX 284 

2 Generated with source code genoators XXXX 0 

3 Converted with automated translators XXXX 0 

4 Copied or reused without change XXXX 0 

5 Modified XXXX 0 

6 Removed XXXX 0 

Orgin 

1 New Weak: no prior existence XXXX 284 

2 Prior work: taken or adapted from 

3 Aprevious version, build, or release XXXX 0 

4 Commercial, off the shelf software 

COTS), other than libraries XXXX 0 


269 





1 


5 Govenunent Avnished software (GFS), 

other than reuse libraries XXXX 0 

6 Another product XXXX 0 

7 A vendor-sui^Ued language support 

hbfary (unmoved) XXXX 0 

8 A vedor-suiqtlied (grating system or 

utility (unmodified) XXXX 0 

9 A local or modified language support 

litMaryOT iterating system XXXX 0 

10 Other commercial library XXXX 0 

11 A reuse lil»ary (software designed 

for reuse) XXXX 0 

12 Other software component or library XXXX 0 


Usage 


1 In or as part of the primary product XXXX 284 

2 External to (V in siqrport of the 

primary product XXXX 0 


Development Status 

1 Estimated or planned 

2 Designed 

3 Coded 

4 Unit tests completed 

5 Integrated into components 

6 Test readiness review completed 

7 Software (CSCI) tests completed 

8 System tests completed 


XXXX 0 

XXXX 0 
XXXX 0 
XXXX 0 

XXXX 0 
XXXX 0 

XXXX 0 

XXXX 284 


270 






LIST OF REFERENCES 


[BEI90] Beizer, Boris, Software Testing Techniques, 2d ed., pp 213-242, Van 
Nostrand Rcinhold, 1990. 

[BER90] Berzins, V., Luqi, Software Engineering with Abstractions, pp 1-21, 
Addison-Wesley I^blishing Company, 1990 

[CSC 92] Conununications System Center/Software Department, Tinker Air Force 
Base, Oklahoma, "The Source Code Line Counter Program,"' T. Goff, pp. 1- 
8,17 December, 1992. 

[NAS 90] McCabe, Tom, “A Complexity Measure,” IEEE Transactions Software 
Engineer, pp 308-320, December 1976. 

[NAS 90] National Aeronautics and Space Administration, Goddard Space Flight 
Center, Transportable Applications Environment Plus User Interface 
Developer's Guide, v. 5.1, pp 1-265, April 1991. 

[NGU 88] Nguyen, T., Forester, K., ALEX - An Ada Lexical Analysis Generator, Version 
1.0, Arcadia Environment Research Project, Department of Information and 
Computer Science, University of California, Irvine, 1988. 

[SLI87] Set Laboratories, Inc., PC-METRIC (PASCAL), pp 1-1 to 6-5,1987. 

[SEL90] Self, J., AFLEX - A fast lexical analyzer generator for Ada, Version 1.1, 
Arcadia Environment Research Project, Department of Information and 
Computer Science, University of California, Irvine, 1 September 1990. 

[SEI93J Software Engineering Institute, Software Engineering Symposium, The 
Business of Software Engineering: The Competitive Edge, The SEI 
Measurements Checklist-User Experience, August 1993. 

[SEI-A 92] Software Engineering Institute, Technical Report 19, Software Measurement 
for DoD Systems: Recommendations for Initial Core Measures, Carleton, A., 
D., and others, pp. 1-68, September 1992. 

[SEI-B 92] Software Engineering Institute, Technical Report 20, Software Size 
Measurement, Park, R. E., pp. 1-167, September 1992 

[SEI-C 92] Software Engineering Institute, Technical Report 21, Software Effort & 
Schedule Measurement: A Framework for Counting Staff-Hours and 
Reporting Schedule Irformation, Goethert, W., B., Bailey, E., K., and Busby, 
M., B., pp 1-10, September 1992. 


271 





[SEI-D 92] 

(SSD 901 
[SUN 90] 
[TAB 88] 

[WAR 90] 


Software Engineering Institute, Technical Report 22, Software Quality 
Measurement: A Framework for Counting Problems and Defects, Florae, W. 
A., pp 1-20, September 1992 

Software Systems Design, Inc., ADADL User's Manual, Release 5.0, pp 1- 
130, July 1990. 

Sun Microsystems, Inc, SunOS Reference Manual, Revision A of 27 March, 
1990. 

Taback, D., Deepak, T, AKACC - Users Manual, Version 1.0, Arcadia 
Environment Research Project, Department of Information and Computer 
Science, University of California, Irvine, 1988. 

Warner Books Inc., Webster’s New World Dictionary, pp 38, 236, August 
1990. 


272 







INITIAL DISTRIBUTION LIST 


Defense Technical Information Center 2 

Cameron Station 
Alexandria. VA 22304-6145 

Dudley Knox Library 2 

Code 052 

Naval Postgraduate School 
Monterey, CA 93943-5002 

Dr. Timothy J. Shimeall 4 

Computer Science Department Code CS/Sm 
Navil Postgraduate School 
Monterey. CA 93943-5118 

MAJ David Gaitros 1 

Computer Science Department Code CS/Ga 
Naval Postrgraduate School 
Monterey, CA 93943-5118 

Dr. Ted Lewis 1 

Computer Science Department Code CS/Lt 
Naval Postgraduate School 
Monterey, CA 93943-5118 

MAJ Kevin J. Walsh 3 

18 Carty Ave. 

Fort Monmouth, NJ 07703 

Ms. Anita Carleton 1 

Software Engineering Institute 
Carnegie Mellon University 
Pittsburgh, PA 15213-3890 

Dr. Marshall Potter 1 

NISMC-03 

Bldg. 166 

Washington Navy Yard 
Washington, DC 20374-5070 


273 





