FLORIDA INSTITUTE OF TECHNOLOGY 

A Thesis Submitted in Partial Fulfillment 
of the Requirements for the Degree of 

Master of Science 
in 

Computer Science 

FIGS 

A FORTH INTERACTIVE GRAPHICS SYSTEM 

Jer-Ming Lee 

APPROVED BY: 


Dr. Thomas 0. Hand 

Associate Professor and Chairman of the 
Graduate Computer Science Program 



Professor of Physics Adjunct Instructor of 

Computer Science 







PIGS 


QA96.5 

L43 

1985 


A FORTH INTERACTIVE GRAPHICS SYSTEM 

by 

Jer-Ming Lee 

B.S. in C.S., Tamkang University, R.O.C., 1979 

Submitted to the Graduate Faculty 
in partial fulfillment of 
the requirements for the degree of 
Master of Science 
in 

Computer Science 

Florida Institute of Technology 
1985 


The author grants permission to reproduce single copies 


~""" “ ~ — — — — — — — 

Jer-Ming Lae 



ACKNOWLEDGEMENT 


11 


The author wishes to acknowlege his theses advisor, 
Dr. Thomas 0. Hand for his abundant lectures, invaluable 
advice, great ideas and comments. 

The author also wishes to acknowledge his Graphics 
teacher, Ms. G. R. Cuthbert for her exciting lectures 
on Interactive Graphics. 

The author wishes to thank Dr. Joel H. Blatt for 
reading this thesis. 

The author wishes to dedicate this achievement to his 
wife Shin-Pang for her constant encouragement and her 
unending patience in typing. 


Ill 


TRADEMARKS 

ATARI 800 XL is a trademark product of Atari, Inc. 

KoalaPad Touch Tablet is a trademark product of Koala 
Technologies Corporation. 


IV 


TABLE OP CONTENTS 

ACKNOWLEDGEMENT . ii 

TRADEMARKS . iii 

TABLE OF CONTENTS .. iv 

LIST OP TABLES . xi 

LIST OP FIGURES . xii 

ABSTRACT . xiv 

I. INTRODUCTION . 1 

II. ATARI 800 XL COMPUTER SYSTEM OVERVIEW . 7 

A. Internal Hardware Components . 7 

B. Graphics Features . 10 

1. Text/Graphic Modes . 10 

2. Display Lists . 11 

3- Colors . 13 

< 

4. Player-missile Graphics . 13 

III. KOALAPAD TOUCH TABLET . 15 

IV. ATARI PIG-PORTH MEMORY MAP . 18 

V. A FORTH INTERACTIVE GRAPHICS SYSTEM . 20 

A. General Concepts . 20 

B. System Overview . 23 

C. Detail Description of Commands . 26 

1 . Mode Switching Commands . 26 

a. SCREEN-OF'P . 27 

b. SCREEN-ON . 27 



























V 

c. MODEO . 28 

d. MODE1 . 28 

e. M0DE2 . 28 

f. MODE3 . 28 

g. MODE4 . 29 

h. MODE5 . 29 

i. MODE6 . 29 

j. MODE7 . 29 

k. M0DE8 . 29 

2. Offset Manipulation Commands ... 30 

a. OFFSET! . 30 

b. OFFSET® .. 31 

c. +OFFSET . 32 

d. OFFSET>T . 33 

e. T>OFFSET . 33 

3- Window Boundary Manipulation Commands .. 34 

a. TWINDOW . 35 

b. WINDOW . 36 

c. TW>W... 37 

d. BOUNDARY? . 38 

4. Color Manipulation Commands . 39 

a. DARKER . 41 

b. BRIGHTER . 42 

c. USECOLOR . 43 

5- Screen Cursor Manipulation Commands .... 44 

a. LOCATE . 44 


























vi 

b. READXY . 45 

6 . Plot Point Commands . 46 

a. PLOT . 46 

7. Draw Line Commands . 51 

a. General Line Algorithms .. 51 

(1) . Basic Incremental Algorithms . 51 

(2) . Bresenham's Algorithms . 52 

b. Special Line Algorithms . 57 

(1) . Horizontal Line . 57 

(2) . Vertical Line . 58 

c. DRAWLINE .. 60 

d. LINE . 62 

e. DRAWTO . 63 

8 . Draw Box Commands .. 64 

a. BOX . 64 

b. PBOX . 65 

9* Draw Circle Commands . 66 

a. CIRCLE-PTS . 68 

b. CIRCLE-PILL . 69 

c. DRAWCIRCLE . 70 

d. CIRCLE . 72 

e. PCIRCLE . 73 

10. Draw Text String Commands . 74 

a. CHARACTER . 74 

b. TEXT . 76 

c. STRING" . 77 



























Vll 


1 1 . Pill Commands .. 78 

a. BPILL . 80 

b. FILL> . 81 

12. Clear Screen Commands ... 83 

a. BCLEAR . 83 

b. CLEAR .. 84 

13- Box Region Moving and Copying Commands . 85 

a. Horizontal Line Copying . 85 

b. RCOPY . 89 

c. RMOVE . 91 

14- Scaling or Zoom Commands . 92 

a. ! ZOOM-DLS . 94 

b. PLUSHDL . 94 

c. >Z00MXY . 95 

15- Player Cursor Manipulation Commands .... 96 

a. SINGLE-SIZE, DOUBLE-SIZE, QUAD-SIZE 96 

b. SINGLE-LINE, DOUBLE-LINE . 96 

c. PLAYER-ON, PLAYER-OPP . 96 

d. PLAYER-CLEAR . 97 

e. SETPFIG . 97 

f. SETPLAYERS . 97 

g. USEPLAYER . 97 

h. PLAYER . 98 






















viii 

16. Disk File Management Commands . 99 

a. DIR . 104 

b. STORE-DATA . 104 

c. GSAVE . 106 

d. SAVE-DL . 106 

e. SAVE-DD . 107 

f. SAVE-ALL . 107 

g. GLOAD . 107 

h. DELETE . 107 

i. FORMAT .'. 108 

17- KoalaPad Touch Tablet Interfacing 

Commands . 109 

a. PADXY . 109 

b . LBTN . .. 109 

c. RBTN . 109 

d. >SCRXY . 109 

18. Display List Interrupt Handling Commands 110 

a. DLI-ON . Ill 

b. DLI-OFF . Ill 

c. SETDLIV . Ill 

VI. A FORTH INTERATIVE GRAPHICS EDITOR . 112 

A. System Overview .. 1 1 4 

B. Detail Description of Commands. 119 

1. PADPLOT . 119 

2. INITENV . 121 

3- SHOW-MENU . 123 


























ix 

4. GET-CMD . 123 

5- EXEC-CMD . 125 

6. SETCOLOR . 128 

7. DISK . 130 

8. DRAW . 132 

C. User's Guide .... 134 

1. Getting Started . 134 

2. Using the Main Menu .. 135 

3 . Talcing a Glance on the Main Graphics 

Screen . 137 

4- Using Graphics Commands . 138 

a. Point .. . 138 

b. Line . 139 

c. Draw . 140 

d. Erase . 1 4 1 

e. Text . 142 

f. Box . 143 

g. Pbox .. . 144 

h. Circle . 145 

i. Pcircle . 146 

j. Pill .. 147 

k. Copy . 148 

l. Move . 149 

m. Clear . 150 

n. Bclear . 151 


























X 


5- Using the Color Menu . 152 

6 . Usecolor . 153 

7- D<—>B . 154 

8 . Zoom . 155 

9. Setbrush .. 156 

10. Disk .. .. 157 

1 1 . Exit . 158 

12. Go . 159 

VII. CONCLUSION . 160 

APPENDIX A: GLOSSARY OF WORDS FOR FIGS . 163 

1. Constants for FIGS . 164 

2. Variables and Arrays for FIGS . 176 

3* High-level and Low-level Words for 

FIGS . 197 

APPENDIX B: SOURCE LISTING FOR FIGS . 232 

APPENDIX C: GLOSSARY OF WORDS FOR FIGE . 276 

1 . Constants for FIGE . 277 

2. Variables and Arrays for FIGE . 280 

3. High-level and Low-level Words for 

FIGE . 286 

APPENDIX D: SOURCE LISTING FOR FIGE . 305 

REFERENCES . 529 

REFERENCES NOT CITED .. . 330 























XI 


LIST OF TABLES 

Table II-1 ANTIC Mode Line Requirements . 10 

Table II-2 Display List Instruction Set . 12 

Table III—1 Port Assignments and the KoalaPad 

Touch Tablet Interface . 16 

Table V-1 Color Assignments . '40 

Table V-2 Color Masks . 43 

Table V-3 Pixel Mask Values . 48 

Table VI-1 FIGE Command Table . 126 











xii 

LIST OP FIGURES 


Figure 1-1 Main Menu — FORTH Interactive 

Graphics Editor . 3 

Figure XI —1 Hardware Arrangement for the ATARI 

800 XL Computer . 8 

Figure II-2 Four Options for the Display List 

Instruction . 12 

Figure IV-1 Memory Map for the ATARI Fig-FORTH 

Environment . 19 

Figure V-1 Conceptual Arrangement of the Display 

System .,. 21 

Figure V-2 Conceptual System Layout of FIGS . 24 

Figure V-3 Color Registers . 39 

Figure V-4 Storing a Pixel . 49 

Figure V-5 Bresenham’s Algorithm . 52 

Figure V-6 Eight Symmetrical Points on a Circle .. 67 

Figure V-7 Copying a Horizontal Line .. . 87 

Figure V-8 Extent of Zoom Windows . 93 

Figure V-9 Master Directory Sector Layout . 101 

Figure V-10 Data Sector Layout . 101 

Figure V-11 File Directory Layout . 102 

Figure V-12 File Directory Entry Layout . 102 

Figure V-13 Relationship Among Three Kinds 

of Sectors . 1 03 


















XI11 

Figure VI-1 Main Menu of FIGE .. 113 

Figure VI-2 Main Structure Chart for PADPLOT . 116 

Figure VI-3 Structure Chart for GET-CMD . 117 

Figure VI-4 Structure Chart for EXEC-ICMD . 117 

Figure VI-5 Structure Chart for EXEC-CMD . 118 

Figure VI-6 Title Page of FIGE . 121 

Figure VI-7 Disk Operation Menu . 130 

Figure VI-8 Graphics Screen . 137 










XIV 


ABSTRACT 

The purpose of this thesis is to develop an 
interactive color graphics environment implemented in the 
FORTH language on the ATARI 800 XL computer. This 
environment contains two main parts. 

The first part is called the FORTH Interactive 
Graphics System (FIGS). FIGS provides capabilities to 
switch graphics modes, change colors, create graphics on 
the screen surface, save graphics images in disk files, 
and reload them as needed. 

The second part is an application of FIGS called the 
FORTH Interactive Graphics Editor (FIGE). FIGE allows the 
user to select graphics commands from the graphics menus 
and to create graphics on the screen surface by using the 
KoalaPad Touch Tablet and the ATARI keyboard. It provides 
a four-colored graphics screen with resolution of 160 by 
80. The images on the graphics screen can be scaled by a 
factor of 2 or 4. The disk operations for saving screen 
data and reloading screen data are also available in FIGE. 


1 


I. INTRODUCTION 

The purpose of this thesis is to develop an 
Interactive Computer Graphics Environment implemented in 
the FORTH language. This environment contains two main 
parts. The first part is the kernel of the environment, 
called the FORTH Interactive Graphics System (FIGS), which 
provides a collection of primitive graphics commands. The 
second part is an interactive graphics editor, called the 
FORTH Interactive Graphics Editor (FIGE), which utilizes 
these primitive graphics commands. It provides 

capabilities for creating graphics on a display surface by 
using the KoalaPad and the ATARI keyboard. Figure 1-1 
shows the main menu for the FORTH Interactive Graphics 
Editor. A brief description for each selection is listed 
below: 

Point: Plot a point at the present cursor position. 

Line: Draw a line between two points. 

Draw: Plot points determined by the trace of the 

cursor. 

Erase: Erase points determined by the trace of the 

cursor. 

Text: Draw a text string which is entered from 

the keyboard starting at the present cursor 
position. 

Box: Draw a rectangle. 


Pbox: 


2 


Circle: 
Pcircle: 
Fill: 

Copy: 

Move: 
Clear: 
Bclear: 
Setcolor: 
Disk: 


Print er: 
Zoom: 

Usebrush: 
D<—>B: 

Exit: 

Go: 

Usecolor: 


Draw a filled rectangle. 

Draw a Circle. 

Draw a filled circle. 

Pill a connected closed region with the 
current color. 

Copy a rectangular region to another place. 
Move a rectangular region to another place. 
Clear the whole screen. 

Clear a rectangular (box-like) region. 
Display a color menu. 

Disk operations: 

. Show directory 
. Save screen data 
. Load screen data 
. Delete a file 
. Format a disk 

Reserved for further implementation. 

Set zoom mode to either normal, double or 
quadruple. 

Select a brush for either Draw or Erase. 
Adjust the luminance of the current color 
(Darker or Brighter). 

Exit to the FORTH interpreter. 

Go ahead and execute the selected command. 
Select a color number from the available 
(four) color numbers. 



Figure 1-1 Main Menu - 


- FORTH Interactive Graphics Editor 

























4 


Before getting started with the over-all system 
design, there are two important questions that must be 
considered. They are 

1 . What is Interactive Computer Graphics? 

2. Why is FORTH suitable for Interactive Computer 
Graphics? 

According to James D. Foley(l), Interactive Computer 
Graphics is a form of man-machine interaction in which a 
user dynamically controls the picture's content, format, 
size, or colors on a display surface by means of 
interaction devices such as a keyboard, lever, or joystick. 
Because of this interaction, the speed becomes a very 
important factor in designing the system. 

FORTH has been successfully used in several 
applications, such as, real-time system control(2), data¬ 
base management(3)» Turtle Graphics(4), and robotics. 
FORTH has significant features that have made it 
successful. Some of these features, which are listed 
below, are beneficial for developing an Interactive 
Computer Graphics Environment. 



5 


1 . Interactive Nature 

Since FORTH is an interactive programming 
environment, it certainly meets the interactive 
reguirement. Actually, FORTH consists of two 
interpreters along with several compilers. 

2. Faster Speed 

Since FORTH is a threaded language, there is less 
overhead •than required in most other high level 
languages. 

3. Extensibility 

This feature aids 'with constructing complex 
graphics images from more elementary images. 

4* Selectiveness to Specific Application 

By using FORTH's vocabularies, specific application 
oriented words can be designed that reduce the 
command search time at compile time. 

5. Ease to Interface to Assembly Language 

By using a FORTH assembler, time critical 
words can be developed as low-level words that 
speed up execution. Also, operating system routines 
can be easily called. 

6 . Compactness of Code 

This feature simply saves memory which allows the 
extra memory to be used for other features. 


Observing the fitness of FORTH to do interactive 
graphics, I decided to use it to develop an interactive 
graphics environment for my thesis. 

This environment has been developed on the ATARI 800 
XL home computer, because it has several significant 
graphics features and because it is available in the 
Computer Science department. 

Several preliminary chapters are presented on material 
necessary for the development of this thesis. A system 
overview of the ATARI 800 XL computer is presented in 
chapter II. A memory map for the ATARI fig-FORTH is 
presented in chapter IV. Since the FORTH Interactive 
Graphics Editor uses the KoalaPad Touch Tablet as the major 
pointing device, an introduction to the KoalaPad Touch 
Tablet is presented in chapter III. 

The two main parts of this thesis are presented in 
chapter V and chapter VI. Only the important words are 
discussed in these chapters although the complete source 
listing for the thesis appears in Appendices A and C. 


7 


II. ATARI 800 XL Computer System Overview 

A. Internal Hardware Components 

The internal hardware layout for the ATARI 800 XL 
computer is very much different from other personal 
computers. Besides the basic components of the computer 
system, such as a 6502 microprocessor, RAM, ROM, and a PIA, 
it also has three special-purpose chips named ANTIC, CTIA, 
and POKEY. Figure I1—1 illustrates the hardware 
arrangement. 

ANTIC is a microprocessor dedicated to the television 
display. It has its own specialized instruction set. Its 
programs and data are written in RAM by the 6502. ANTIC 
executes its programs, called display lists, and retrieves 
data (display data) from RAM by using direct memory access 
(DMA) . 

CTIA is a television interface chip. It converts the 
digital commands from ANTIC or the 6502 into a signal that 
goes to the television. It also has some features of its 
own, such as handling color, player-missile graphics, and 
collision detection. 



8 


“1 - 

1 

1 

keyboard controller 

i 

| PIA 

1 1 

joystick 

\ 1 

1 1 

1 I 

1 1 

1 

paddle trigger 



Figure II—1 Hardware Arrangement for the ATARI 800 XL 


Computer 






























9 


POKEY is a digital input/output chip. It handles 
serial I/O bus, audio-generation, keyboard scan, and random 
number generation. It also digitizes the resistive paddle 
inputs and controls maskable interrupt requests from 
peripherals. 

All three of these special chips (ANTIC, CTIA, POKEY) 
function simultaneously with the 6502. They remove a lot 
of the load from the 6502 and speed up the overall system 


execution. 



10 


B.Graphics Features 

1. Text/Graphics Modes 

There are 6 text modes and 8 graphics modes available 
to ANTIC. Some of the modes have 4 colors available while 
the others have only 2 colors available. Pixel widths and 
mode line widths vary with the mode. Table II—1 
illustrates these details. 


ANTIC 

Mode 

BASIC 

Mode 

Nbr of 
Colors 

Scan Lines/ 
Mode Line 

Pixels/ 
Mode line 

Bytes/ 

line 

Bytes/ 

screen 

2 

0 

2 

8 

40 

40 

960 

3 

none 

2 

10 

40 

40 

760 

4 

none 

4 

8 

40 

40 

960 

5 

none 

4 

16 

40 

40 

480 

6 

i 

5 

8 

20 

20 

480 

7 

2 

5 

16 

20 

20 

240 

8 

3 

4 

8 

40 

10 

240 

9 

4 

2 

4 

80 

10 

480 

A 

5 

4 

4 

80 

20 

960 

B 

6 

2 

2 

1 60 

20 

1 920 

C 

none 

2 

1 

1 60 

20 

3840 

D 

7 

4 

2 

1 60 

40 

3840 

E 

none 

4 

1 

1 60 

40 

7680 

F 

8 

2 

1 

320 

40 

7680 


Table II—1 ANTIC Mode Line Requirements 





2. Display Lists 


A display list is a program executed by ANTIC. It 
provides the flexibility for controlling the display. 
Different graphics modes can be mixed on the same screen. 
ANTIC's instruction set is rather simple but at the same 
time is quite powerful. Table II-2 gives the display list 
instruction set. Besides the four classes of normal 
instructions, such as graphics mode, text mode, blank 
line, and jump, there are also four special options, 
namely, display list interrupt (DLI), load memory scan 
(LMS), vertical scroll, and horizontal scroll. Figure II-2 
illustrates the bit arrangement for the four options of a 
display list instruction. DLI can be used to add more 
colors to a display. A load memory scan can be used to 
direct ANTIC to fetch display data from noncontiguous 
RAM areas. Vertical scrolling and horizontal scrolling 
can be used to aid with fine scrolling of the display. 
These are powerful tools which can be used to enhance the 
graphics; they will be used in this environment. 




1 2 


Instruction 

(HEX) 


Meaning 

0 

1 

blank 

line 

10 

2 

blank 

lines 

20 

3 

blank 

lines 

30 

4 

blank 

lines 

40 

5 

blank 

lines 

50 

6 

blank 

lines 

60 

7 

blank 

lines 

70 

8 

blank 

lines 

1 

jump to location 

41 

jump and 

wait for vertical blank interrupt 

2—F 

14 

display instructions corresponding to 14 


ANTIC modes 


Table II-2 Display List Instruction Set 


1 0 

-r 

i 

_! Diplay list instruction 

-> ANTIC mode number (2—F) 

-> Vertical scroll 
-> Horizontal scroll 
-> Load memory screen (LMS) 

-> Display list interrupt (DLI) 


Figure II-2 Four Options for the Display List Instruction 















13 


3* Colors 

Color values are kept in one-byte color registers. 
CTIA provides 16 hue values and 8 luminance values for 
each hue giving a total of 128 possible colors. However, 
they are restricted both by the number of color registers 
and by the graphics modes. In particular, only 2 or 4 
colors can be displayed in a normal mode line. As has been 
mentioned previously, additional colors on the same screen 
can be achieved by using the DLI. 

4. Player-missile Graphics 

The conventional way to achieve animation in computer 
graphics is to move the image data through the screen RAM 
area. However, there are two problems with this technique. 
First, if the animation is being done in a graphics mode 
with large pixels, the motion will not be smooth. Second, 
the screen is a two-dimensional image, but the screen RAM 
is one-dimensional. 

The ATARI computer provides player-missile graphics to 
solve these problems. Player-missile graphics is separated 
from normal graphics modes (playfields). There are 4 
players and 4 missiles provided by CTIA. Each player or 
missile has its own color register, horizontal position 
register, and shape data area in RAM. The horizontal 
motion of a player-missile is easy to handle by the user. 


14 


Simply put the horizontal position value into its 
horizontal position register. However, the user is 
responsible for handling all vertical motion of the player- 
missiles. A simple way to achieve this is to move the 
player-missiles shape data through its own data area. 
There are two kinds of vertical resolution (single line and 
double line), and three kinds of horizontal width (normal, 
double, and quadruple) available in player-missile 
graphics. Because player-missiles are separated from 
playfields, they can be used efficiently as screen cursors. 
They also can be used to add colors in the same mode line. 


15 


III KOALAPAD TOUCH TABLET 


The KoalaPad Touch Tablet is a pointing device 
developed by Koala Technologies Corporation. It has three 
main features: 


1 . Pressure Sensitive Drawing Surface 

A point on the surface can be selected by pressing 
either the stylus provided or your finger at that 
point. The KoalaPad Touch Tablet's internal 
circuitry converts pressure on the surface to 
location information that is sent to the 
computer. 

2. Two Control Buttons 

These buttons may be used to either confirm menu 
selections or present data entries. 

3- Stylus 

This is a pencil-like device specially designed to 
select a point on the surface by pressing it at 
that point. 


The position of the stylus on the tablet's flat 
surface is defined by horizontal and vertical coordinates. 
The horizontal coordinate is read as PADDLE 0 and the 
vertical coordinate is read as PADDLE 1. Similarly, the 
two touch tablet buttons are treated as paddle trigger 0 
(left button) and paddle trigger 1 (right button). Table 



16 


III—1 illustrates the port assignments and read values for 
the KoalaPad Touch Tablet as used on the ATARI 800 XL 
computer. 


Descriptions 

Port 

name 

Memory 

location 

(HEX) 

Shadowed 

memory 

(HEX) 

Read values 

stylus position 

horizontal 

PADDLE 0 

D200 

270 

3-228@ 

vertical 

PADDLE 1 

D201 

271 

3-228@ 

tablet buttons 

left 

PTRIG 0 

D300* 

27 C 

0-pressed 
1-not pressed 

right 

PTRIG 1 

D300* 

27D 

0-pressed 
1-not pressed 


@ 3 is the default value when stytus is not on 
* D300 is the memory location for PORTA of the 6502 PIA 


Table III—1 Port Assignments and the KoalaPad Touch 
Tablet Interface 


The range of posible values for horizontal and 
vertical coordinates on the KoalaPad are 3 (the extreme 
left or top) through 228 (the extreme right or bottom). 
If the stylus is not pressed against the tablet, the 
default paddle values are both 3* The possible values for 
the two touch tablet buttons are either 0 (pressed) or 1 
(not pressed). 





17 


Unlike joysticks or game paddles, touch tablets can 
get from point A to point B by skipping all intermediate 
points. This direct positioning capability makes touch 
tablets easier to use for selecting menu entries, moving 
game players and drawing computer graphics. For this 
reason, the KoalaPad Touch Tablet was chosen as the major 
pointing device in the FORTH Interactive Graphics Editor. 


18 


IV. ATARI Fig-FORTH MEMORY MAP 

The memory map for the ATARI fig-FORTH is similiar to 
the standard fig-FORTH memory map. However, there are some 
special assignments in ATARI fig-FORTH. 

1 . The return stack is the same as the system stack 
(from IFF down to 100). 

2. The parameter stack is allocated on the zero-page 
RAM (from BC down to 92). 

3- Block size is 128 bytes. 

4. Disk buffers, user area, terminal input buffer, 
and stacks are all allocated in memory below 
the dictionary. 

Figure IV-1 illustrates the memory map for the ATARI 


fig-FORTH environment. 


19 


FFFF 

COOO-> 

MEMTOP -> 



DP § 


text buffer 


"word" buffer 


dictionary 


boot-up literals 


PAD § 


ORIGIN (FOO) 


(E40) LIMIT->' 

(600) FIRST-■’> 


i user area 
(480)--->!_ 


disk buffers 


(IFF) RO @->1 return stack 7T 

! _ / ! < 

RP @---> | / terminal 

! / input buffer j 


(BC) SO @ - >1 "T 

| parameter stack! 

SP § ->|_ j 

1 page 0 ! < 

oooo ! ! 


in e 

TIB § (100) 


0 PAGE 


Fig IV-1 


Memory Map for the ATARI Fig-FORTH Environment 





























20 


V. FORTH INTERACTIVE GRAPHICS SYSTEM 

The purpose of the FORTH Interactive Graphics System 
is to provide a FORTH environment in which users can 
create graphics on the display surface by using graphics 
commands. The scope of this chapter is concerned primarily 
with these graphics commands. Generally, the descriptions 
for these graphics commands are concerned with three 
considerations. They are 

1 . What is the function of the command? 

2. How is the command implemented? 

3. How is the command used? 

A. General Concepts 

Suppose that one wants to plot a pixel on the 
television screen. What must the computer do to accomplish 
this? What must happen at the interface between the 
computer and the television set? Since the television 
set uses what is called a raster beam display system, it 
does not maintain the image. Consequently, the computer 
must maintain the screen image in a buffer and consistently 
send signals to the television telling it what to display. 
This action requires full-time attention. For this reason, 
most microcomputers have special designed hardware circuits 


21 


to handle it. Figure V-1 shows the conceptual arrangement 
for the basic system as used by most microcomputer systems. 


display 

command 


Micocomputer 


| j display information 

i i 
i i 

\/ 


Screen RAM 


!, display information 

i i 
I ! 

\/ 


1 

>! 

Video 


1 

1 

1_ 

hardware 



1| display signals 

i i 
i i 

\/ 


TV screen \ 

I 

_I 


Figure V-1 Conceptual Arrangement of the Display System 

















22 


This arrangement releases some of the burden from the 
CPU of the microcomputer. 

Fortunately, the ATARI 800 XL microcomputer has two 
special chips that were designed for the television 
interface. The ANTIC executes the display lists and 
converts screen image data into digital commands which are 
to be sent to the CTIA. The CTIA, then, converts the 
digital command's into signals for the television. 

The programmer prepares the display lists and the 
screen image data and sets or resets the appropriate 
registers to control this special hardware. Consequently, 
the following questions become important where the graphics 
system is concerned: 

1. How are display lists created? 

2. How is memory for display lists and screen image 
data area allocated? 

3. How are two-dimensional coordinates transformed 
into memory locations? 

4. How are out-of-boundary conditions that 

potentially could destroy other useful data 
managed? 

5- How are the coordinates for certain graphics 
shapes, such as line, circle and boxes calculated? 

6. How are pixel data placed into screen image data 


areas? 



23 


7. How are colors set and used? 

Once the solutions of these questions have been 
presented and graphical pictures can be created, it will be 
necessary to both save the pictures on disk and load them 
back into memory at a later time. 

B. System Overview 

The FORTH Interactive Graphics System is designed as 
an environment which is an extension of the ATARI fig-FORTH 
System. It acts as an interface between ATARI FORTH users 
and the graphics display processors (ANTIC, CTIA). Figure 
V-2 shows the relationship between them. It provides 
groups of commands which can be used to switch graphics 
modes, to change colors, to draw figures in the screen 
image RAM and to save display lists and/or screen image 
data on disk. The basic system approach is based upon the 
general concepts which were stated in the last section. 
Furthermore, the algorithms implemented in this thesis 
answer the questions asked in the last section. 


24 


-- r 

1 

“-r 

i i 

| ATARI 

ANTIC j 

i 

i 

! CTIA i 

i i 

i i 

! os 

i 

i 

/\ 
i i 
i i 

/\ 
i i 

1 ! 

/\ 

11 

I ! 

i i 
i i 

V 

t I 
t i 

\/ 

1 I 
! 1 

\/ 

System 

Constants & Control 

Registers 


j FORTH Constants j 

i i 

i_i 


1 -■-r 

| fig-FORTH ! 

i i 

i t 

i 

GlobalT 

Mode 

| Offset 

i 

i 

i 

variables j 

switch 

! commands 

t 

i 

i 

i 

i 

& constants j 

i 

commands 

1 

1 

1 

i 

i 

i 

i 

i 

Window J 

Draw 

! Fill 

i 

t 

i 

i 

i 

i 

i 

boundary j 

commands i 

i 

commands 

! commands 

i 

i 

i 

i 

i 

t 

i 

i 

I 

i 

Clear ! 

Move 

i Text 

i 

i 

i 

i 

i 

i 

i ^ 

commands ! 

i 

i 

i 

commands 

| commands 

i 

i 

i 

i 

i 

i 

_i 

i 

i 

Disk ! 

Copy 

i 

i 

i 

i 

i 

i 

i 

i 

commands ; 

i 

i 

commands 

i 

i 

j 

i 

i 

i 


! Application oriented words 


T 


User 


T 


Processor 

and 

OS level 


FORTH 

Interactive 
Graphics 
Enviroment 


Figure V-2 Conceptual System layout of FIGS 























25 


PIGS can be subdivided into several categories of 
commands by the function that they perform. These are 

1 . Mode switching commands. 

2. Offset manipulation commands. 

5- Window boundary manipulation commands. 

4. Color manipulation commands. 

5- Screen cursor manipulation commands. 

6. Plot point commands. 

7. Draw line commands. 

8. Draw box commands. 

9. Draw circle commands. 

10. Draw text string commands. 

11. Pill commands. 

12. Clear screen commands. 

13. Box region moving or copying commands. 

14. Scale or zoom commands. 

15« Player cursor manipulation commands. 

16. Disk file management commands. 

17- KoalaPad interfacing commands. 

18. Display list interrupt handling commands. 

The remaining sections of this chapter present detail 
descriptions for each of these categories of commands. 



26 


C. Detail Description of Commands 

In this section, more detailed descriptions of the 
commands are presented. 

1. Mode Switching Commands 

These commands create display lists for specific 
graphics modes. They can also set default values for the 
environment, such as color values, text window boundaries, 
number of scroll lines, screen boundaries, and initial 
cursor position. Here is the general psuedocode for the 
mode switching commands. 

INPUT: none 

OUTPUT: none 

< 

PROCEDURE Mode switching commands 

Create a display list in high portion of RAM 

Set default values 

Turn off the screen display 

Store the starting address of created display list 
in SDLSTL (location 230 H) 

Turn on the screen display 


ENDPROC 


27 


To create a display list, there are three main words 
that can be used, namely BEGIN-DL, MODE-LINE and END-DL. 
Since all nine of the graphics modes provided by ATARI 
BASIC begin with 24 blank scan-lines (which equals 3 8- 
blank mode-lines), BEGIN-DL puts 3 bytes of 70H into 
memory, starting at the address that is on top of the 
parameter stack. MODE-LINE creates that part of the 
display list that begins with a load memory scan option 
instruction. END-DL concludes the display list with a 
jump instruction that directs ANTIC to fetch the display 
list instructions starting at the begining of the display 
list. Please refer to Table II-2 for more information 
about the display list instructions. 

a. SCREEN-OPP 

SCREEN-OPP turns off ANTIC by storing 0 in SDMCTL 
(location 22FH). It also keeps the old value of this 
control register in a temporary location for possible 
restoring by the SCREEN-ON command. 

b. SCREEN-ON 


SCREEN-ON 

turns 

on ANTIC and 

restores 

other 

DMA 

functions that 

had 

been previously 

working 

before 

the 


SCREEN-OPP command turned them off. 


28 


The next nine commands are used to create mode 
environments which correspond to those provided by ATARI 
BASIC. Refer to Table II—1 for more information. 

c. MODEO 

This command switches the present graphics mode to 

graphics mode 0. See the start of this section for the 

appropriate pseudocode. 

d. M0DE1 

This command switches the present graphics mode to 

graphics mode 1. See the start of this section for the 

appropriate pseudocode. 

e. M0DE2 

This command switches the present graphics mode to 

graphics mode 2. See the start of this section for the 

appropriate pseudocode. 

f. M0DE3 

This command switches the present graphics mode to 

graphics mode 3* See the start of this section for the 


appropriate pseudocode. 



29 


g. M0DE4 

This command switches the present graphics mode to 

graphics mode 4* See the start of this section for the 

appropriate pseudocode. 

h. M0DE5 

This command switches the present graphics mode to 

graphics mode 5- See the start of this section for the 

appropriate pseudocode. 

i. M0DE6 

This command switches the present graphics mode to 

graphics mode 6. See the start of this section for the 

appropriate pseudocode. 

j. M0DE7 

This command switches the present graphics mode to 

graphics mode 7. See the start of this section for the 

appropriate pseudocode. 

k. M0DE8 

This command switches the present graphics mode to 

graphics mode 8. See the start of this section for the 


appropriate pseudocode. 



30 


2. Offset Manipulation Commands 

These commands manipulate offsets within the screen. 
They provide a redraw capability; the same picture can be 
redrawn at a different position by simply changing the 
offset values and by executing the same graphics command 
again. The main idea is to maintain a pair of X-Y offset 
values, called the x-offset and the y-offset. These 
values are to be added to the normal screen coordinates 

during the excution of the graphics draw commands. The 

x-offset is maintained in the FORTH variable XO while the 
y-offset is maintained in the FORTH variable YO. 

a. OFFSET! 

This command stores new offset values in the FORTH 
variables XO and YO. 

INPUT: X-offset 

Y-offset 
OUTPUT: none 

PROCEDURE OFFSET! 

Store the y-offset in the variable YO 

Store the x-offset in the variable XO 


ENDPROC 


31 


b. OFFSET® 

This command puts the current offset values on top of 
the parameter stack. It provides a convenient way for the 
user to check the current offset values. 

INPUT: none 

OUTPUT: X-offset 
Y-offset 

PROCEDURE OFFSET® 

Fetch the x-offset from the variable XO 
Fetch the y-offsiet from the variable YO 


ENDPROC 



32 


c. +OFFSET 

This command transforms the normal X-Y coordinate 
values into the offset coordinate values by adding the 
corresponding offset values to the X-Y coordinate values. 
It is called during the execution of the graphics draw 
commands. 

INPUT: X — X-coordinate before adding the x-offset value 

Y — Y-coordinate before adding the y-offset value 


OUTPUT: X-coordinate 

after 

adding 

the 

x-offset 

value 

Y-coordinate 

after 

adding 

the 

y-offset 

value 


PROCEDURE +OFFSET 

Add the x-offset to X 
Add the y-offset to Y 


ENDPROC 


33 


d. OFFSET>T 

This command temporarily saves the current offset 
values. 

INPUT: none 

OUTPUT: none 

PROCEDURE 0FFSET>T 


Move 

the 

x-offset 

to 

the 

temporary 

variable 

TXO 

Move 

the 

y-offset 

to 

the 

temporary 

variable 

TYO 


ENDPROC 

e. T>OFFSET 

This command restores the current offset values to the 
values previously saved in TXO and TYO. 

INPUT: none 

OUTPUT: none 

PROCEDURE T>0FFSET 

Move the x-offset in the temporary variable TXO to the 
current offset variable 

Move the y-offset in the temporary variable TYO to the 
current offset variable 


ENDPROC 


34 


5- Window Boundary Manipulation Commands 

These commands are used to set or check window 
boundary conditions. The main purpose is to prevent data, 
which is in critical memory areas, from being destroyed by 
attempting to draw something outside of the proper screen 
boundaries. The screen boundaries are kept in two sets of 
variables. The first set consists of TXMIN, TYMIN, TXMAX, 
and TYMAX. They are used to keep the terminal coordinate 
boundaries which varies from mode to mode. The second set 
consists of XMIN, YMIN, XMAX, and YMAX. They are used to 
keep the logical window boundaries. 

Normally, once a certain graphics mode is selected and 
used, the contents of the first set of variables are saved. 
This allows the logical window boundaries to be restored to 
the whole terminal screen. On the other hand, the logical 
window boundaries can be dynamically changed at will. 


35 


a. TWINDOW 

This command sets the current terminal 
boundaries. 


INPUT: XMIN 
YMIN 
XMAX 
YMAX 

OUTPUT: none 


low limit of the X-coordinate 
low limit of the Y-coordinate 
high limit of the X-coordinate 
high limit of the Y-coordinate 


PROCEDURE TWINDOW 

Store high limit of 
TYMAX 

Store high limit of 
TXMAX 

Store low limit of 
TYMIN 

Store low limit of 
TXMIN 


the Y-coordinate in the 


the X-coordinate in the 


the Y-coordinate in the 


the X-coordinate in the 


screen 


variable 


variable 


variable 


variable 


ENDPROC 



36 


b. WINDOW 

This command sets the current logical screen 
boundaries. It provides the capability to restrict the 
effects of the graphics draw commands to a specific window. 
With the aid of the offset commands, it then allows the 
user to draw within certain restricted regions of the 
display. The input, output and psuedocode are almost the 
same as that for TWINDOW except that the second set of 
variables (XMIN, YMIN, XMAX and YMAX) are used in WINDOW. 


37 


c. TW>W 

This command restores the current logical window 
boundaries to the current terminal screen boundaries. 

INPUT: none 

OUTPUT: none 

PROCEDURE TW>W 

Fetch the low limit of the X-coordinate in the terminal 
screen 

Fetch the low limit of the Y-coordinate in the terminal 
screen 

Fetch the high limit of the X-coordinate in the terminal 
screen 

Fetch the high limit of the Y-coordinate in the terminal 
screen 

Call WINDOW to set the logical window boundaries with 
these limits 


ENDPROC 



38 


d. BOUNDARY? 

This command checks whether a given pair of 
coordinates are within the logical window boundaries, 
word is used by each draw command to restrict their 
to within the selected logical window. 

INPUT: X — X-coordinate of the given point 
Y — Y-coordinate of the given point 
OUTPUT: P — result flag 

1: within the window 
0: outside of the window 

PROCEDURE BOUNDARY? 

IP the X-Y coordinates are within the logical 
THEN 

Set the result flag to 1 
ELSE 

Set the result flag to 0 
END IP 


X-Y 

This 

effect 


window 


ENDPROC 



39 


4. Color Manipulation Commands 

These commands select colors and place them in 
specific color registers, or select a certain color 
register as the current color register. Color registers 
are one-byte in length. The high-order nibble can contain 
16 hue values. The low-order nibble contains 8 luminance 
values. Luminance values must be even because bit 0 is 
ignored by the ATARI 800 XL computer. Figure V-3 
illustrates the bit arrangement within a color register. 


hhhhlllx 

- ( -,-r 

i i i 

I i i 

I i i 


not used 

luminance 


hue 


Figure V-3 Color Registers 









40 


For the reason of readability, the color values are 
defined as FORTH constants with appropriate names. Table 
V-1 shows some color values and their corresponding names. 


Color values 
(HEX) 

Color names 

0 

BLACK 

10 

RUST 

20 

RED-ORANGE 

30 

DARK-ORANGE 

40 

RED 

50 

DARK-LAVENDER 

60 

COBALT-BLUE 

70 

ULTRAMARINE-BLUE 

80 

MEDIUM-BLUE 

90 

DARK-BLUE 

AO 

BLUE-GREY 

BO 

OLIVE-GREEN 

DO 

DARK-GREEN 

EO 

ORANGE-GREEN 

FO 

ORANGE 


Table V-1 Color Assignments 


The following two commands deal with changing the 
luminance of a color which is contained in a color 


register. 






41 


a. DARKER 

This command decreases the luminance value in the 
given color register by two so that the color becomes 1 
level darker. However, if the value is 0, it is changed to 
the brightest luminance value of OE (hex). 

INPUT: color number 

OUTPUT: none 

PROCEDURE DARKER 

Convert the color number to a color register location 
Fetch the color value from the given color register 
location 

Duplicate the color value 

Substract 2 from the second color value 

Form a new color value with the high-order nibble of the 
first color value and low-order nibble of the 
second color value 

Store the new color value in the given color register 
ENDPROC 



42 


b. BRIGHTER 

This command increases the luminance value in the 
given color register by two so that the color becomes 1 
level brighter. However, if the value is OE (hex), it is 
changed to the darkest luminance value of 0. 

The input, output and pseudocode for BRIGHTER are 
similar to that of the word DARKER except that the word 
BRIGHTER adds 2 to the color value instead of substracting 
2 from the color value. 


43 


c. USECOLOR 

This command selects one of the four color numbers as 
the current color number. It also sets the color mask byte 
(COLORMSK) by taking the color mask value from the color 
mask table (COLMSKTB). Table V-2 shows the color mask 
values that correspond to the number of available colors 
and the color number. 


Number of colors 
available 

Color 

number 

Color 
(binary) 

mask 
(hex) 

2 

0 

00000000 

00 


1 

11111111 

PP 

4 

0 

00000000 

00 


1 

01010101 

55 


2 

10101010 

AA 


3 

11111111 

PP 

Table 

V-2 Color 

Masks 



INPUT: color number 

OUTPUT: none 

PROCEDURE USECOLOR 

Store the color number in the current color number 
variable 

Get the color mask value from the color mask table 
Store the color mask value in the color mask byte 


ENDPROC 





44 


5. Screen Cursor Manipulation Commands 

These commands change the cursor position and read the 
current coordinates of the cursor. In PIGS, the current 
cursor column and row coordinates are kept in the variables 
OLDCOL and OLDROW, respectively. The two cursor 
manipulation commands simply deal with either storing the 
given coordinates in the current cursor coordinate 
variables or fetching the coordinates from these variables. 

a. LOCATE 

This command moves the cursor position to the position 
given by the coordinates that are on top of the parameter 
stack. 

INPUT: X-coordinate 

Y-coordinate 
OUTPUT: none 

PROCEDURE LOCATE 

Store the given Y-coordinate in the corresponding 
variable 

Store the given X-coordinate in the corresponding 
variable 


ENDPROC 



45 


b. READXY 

This command fetches the coordinates of the current 
cursor position and puts them on top of the parameter 
stack. This provides the capability of examining the 
current cursor position. 

INPUT: none 

OUTPUT: X-corrdinate of the current cursor position 
Y-coordinate of the current cursor position 

PROCEDURE READXY 

Fetch the X-coordinate of the current cursor position 
Fetch the Y-coordinate of the current cursor position 
ENDPROC 



46 


6. Plot Point Commands 

These commands are used to plot points on the display. 
The main idea is to put the current color number as the 
pixel value at the proper location in the screen image data 
RAM. 


a. PLOT 

This is a general PLOT' command which can be used to 
put a pixel value at the proper location in the screen 
image data RAM. It may be applied in various graphic modes 
even if they have different pixel sizes and different 
resolutions. 

In order to plot a pixel value at the proper location, 
the transformation from a two-dimensional X-Y coordinate to 
one-dimensional memory location is necessary. The command 
POSITION does this work. 

To transfer from an X-Y coordinate to a memory 
location, the following formulas are used. 

Memory Location = Screen memory + Y * bytes-per-line 

+ INT ( X / pixels-per-byte ) 

Pixel number in byte = MOD ( X / pixels-per-byte ) 



47 


where 

X and Y are the given coordinates, 

screen memory is the start location of screen image RAM, 

bytes-per-line is the number of bytes used to hold pixel 
values of one mode-line, 

pixels-per-byte is the number of pixels which one byte 
can hold. 

Since most of the graphics modes, other than the text 
modes, do not use a whole byte to hold a single pixel 
value, it becomes impossible to put a single pixel into RAM 
without being concerned with the other pixels in that same 
data byte. There is one efficient method of solving this 
problem. A special byte called the pixel mask is used to 
mask out the pixel values of the color mask. Table V-3 
shows the pixel mask values that correspond to the number 
of pixels. The complement of the pixel mask is used to 
mask out the surrounding pixel values of the specific data 
byte. Consequently, the new pixel value and the unchanged 
surrounding pixel values can be recombined and stored back 
in the data byte. The word PXPUT does this work. Figure 
V-4 shows how this method works with sample values. 



Pixels/byte 

Pixel 

position 

Pixel 
(binary) 

mask 
(hex) 

1 

0 


FF 

2 

0 

11110000 

FO 


1 

00001111 

OF 

4 

0 

11000000 

CO 


1 

00110000 

30 


2 

00001100 

OC 


3 

00000011 

03 

8 

0 

10000000 

80 


i 

01000000 

40 


2 

00100000 

20 


3 

00010000 

10 


4 

00001000 

08 


5 

00000100 

04 


6 

00000010 

02 


7 

00000001 

01 


Table V-3 Pixel Mask Values 






49 


image 
data 

byte j j i 

V 


1-! 

i ooooooii! 


pixel 

mask 

byte 


color 

mask 

byte 



AND 


-> 00010000 



i->7—y 


I or! 


1 _N 1 1 

1 1 1 


>!00010011 


Figure V-4 Storing a Pixel 




















50 


INPUT: X-coordinate 

Y-coordinate 
OUTPUT: none 

PROCEDURE PLOT 

Locate the cursor position with the given coordinates 
Add the offset values to the given coordinates 
Check the boundary 

IP the point is within the boundary THEN 

Transform the X-Y coordinates to a memory location 
and put the pixel number in that byte 
Set the pixel mask byte by using the pixel number 
Put the pixel value into the proper location by using 
the color mask byte and the pixel mask byte 

ELSE 

Do not plot the point 
ENDIP 
ENDPROC 



51 


7. Draw Line Commands 

These commands draw line segments on the display from 
one point to a second point. How can the coordinates of 
the points that lie on the line segment he calculated? 

a. General Line Algorithms 

(1) . Basic Incremental Algorithms 

Let's take a glance at some line drawing algorithms. 
The simplest approach is to calculate of the slope of the 
ideal line and use it to increment both the Y-coordinate 
value and the X-coordinate value to obtain other points on 
the line. This algorithm is called the Basic Incremental 
Algorithm(5)• 

This algorithm requires the usage of floating point 
arithmetic because slope is a real number. Unfortunately, 
the floating point arithmetic words provided by ATARI fig- 
PORTH are not efficient. 

(2) . Bresenham's Algorithm 

Consequently, the Bresenham's Line Algorithm(6) 
becomes attractive because it requires only integer 
arithmetic. Figure V-5 illustrates the geometry for 
Bresenham's algorithm. The black circles are the pixels 
selected by Bresenham's algorithm. 



52 


Bresenham’s algorithm uses a decision variable di 
which at each step is proportional to the difference of s 
and t. Figure V-5 depicts the ith step, at which the 
pixel Pi-1 has been determined to be closest to the actual 
line being drawn, and now it must be decided whether the 
next pixel to be plotted should be Ti or Si. If s < t, 
then Si is closer to the desired line and it should be 
plotted; otherwise, Ti is closer and it should be plotted. 



Figure V-5 Bresenham's Algorithm 




53 


The derivation is based on the above idea and the 
resulting equations are listed below: 

When dx > 0 and dy > 0: 

If di >= 0, then 

di+1 = di+2 ( dy - dx ) 
else 

di+1 = di + 2dy 

and 

di = 2dy - dx 

However, this version works only for lines with slope 
between 0 and 1. A general version is derived from a 
variant of Figure V-5 , and the resulting equations are 
list below: 

When dx < 0 and dy < 0: 

If di < 0, then 
di —1 = di - 2dy 
else 

di—1 = di - 2( dy - dx ) 

and 


di = - ( 2dy - dx ) 



54 


When dx > 0 and dy < 0: 

If di < 0, then 

di+1 = di = 2 ( dy + dx ) 
else 

di+1 = di + 2dy 

and 

di = 2dy + dx 

When dx < 0 and dy > 0: 

If di < 0, then 

di—1 = di-2 ( dy + dx ) 
else 

di — 1 = di - 2dy 

and 

di = - ( 2dy + dx ) 

The incremental, values Incl and Inc2 and the initial 
value for di are derived from the equations listed below: 

Incl = ( xsign ) 2dy 

Inc2 = ( xsign ) 2 ( dy - ( xysign ) dx ) 
di = ( xsign ) ( 2dy - ( xysign ) dy ) 

where 


xsign = 1 , 

if 

X2 

- XI 

> 0 

o, 

if 

X2 

- XI 

= 0 


if X2 - XI < 0 



55 


ysign = 1, 

if 

Y2 - Y1 

> 

0 

0, 

if 

Y2 - Y1 

= 

0 

-1 , 

if 

Y2 - Y1 

< 

0 

xysign = ( xsign 

) ( 

ysign ) 




However, this 

general 

version works only 

for 

lines 

with slope between - 

-1 and 1 . 

A 

few modifications to 

this 

algorithm will give a version 

that handles 

lines 

with 

slopes not between 

-1 and 1 . 


Simply exchange 

the x 

and y 

coordinates of each 

point before 

performing the 

calculation 

and exchange them 

back before 

drawing the 

point. 

The 


algorithm given’below is a general version of Bresenham's 
Line Algorithm. 

INPUT: XI — X-coordinate of the start point 

Y1 — Y-coordinate of the start point 

X2 — X-coordinate of the end point 

Y2 — Y-coordinate of the end point 

OUTPUT: none 

PROCEDURE Bresenham's Line Algorithm 
Set offset to (XI,Y1) 

Compute dx = ]X2 - X 1 j 
Compute dy = jY2 - Y1 j 



56 


IP dy > dx THEN 

Exchange XI and Y1 
Exchange X2 and Y2 
Exchange dx and dy 
Exchange xsign and ysign 
Set exchanged indicator to 1 


ENDIP 




Compute 

Incl = ( xsign ) 

2dy 

Compute 

Inc2 = ( xsign ) 

2 

( dy - ( xysign ) dx ) 

Compute 

d = (xsign ) 

( 

2dy - ( xysign ) dx ) 

Set y to 

0 



FOR each 

x PROM 0 TO 

( 

X2 - XI ) 

IP ( xysign ) d < 0 THEN 


Add 

Incl to d 



ELSE 




Add 

ysign to y 




Add Inc2 to d 
ENDIP 

IP exchanged indicator = 1 THEN 
Draw point (y,x) 

ELSE 

Draw point (x,y) 

ENDIP 

ENDFOR 


ENDPROC 



57 


b. Special Line Algorithms 

Since Bresenham's algorithm is a general line 
algorithm, it has overheads for some special lines such as 
horizontal lines and vertical lines. 

(1). Horizontal Line 

Actually, the data for a horizontal line lies in 
contiguous bytes of memory. So, to draw a horizontal line, 
simply fill these contiguous bytes with the value of the 
color mask and take care of the two bytes that correspond 
to the ends of the line. 

INPUT: XI — X-coordinate of the start point 

Y1 — Y-coordinate of the start point 

X2 — X-coordinate of the end point 

Y2 — Y-coordinate of the end point 

OUTPUT: none 



58 


PROCEDURE Horizontal line 

Transform (XI ,Y1) into the starting location and the 
pixel number 

Transform (X2,Y2) into the end location and the pixel 
number 

Put the pixel values in the first byte 

Eill in the bytes between the starting location and the 
end location with the value from the color mask 
Put the pixel values in the last byte 
ENDPROC 

(2). Vertical Line 

The data for a vertical line have the same pixel 
number in those bytes which correspond to the points on the 
line. 

INPUT: XI — X-coordinate of the start point 

Y1 — Y-coordinate of the start point 

X2 — X-coordinate of the end point 

Y2 — Y-coordinate of the end point 


OUTPUT 


none 



59 


PROCEDURE Vertical line 

Transform (XI,Y1) into the starting location and pixel 
number 

Set the address to the starting location 
FOR each y FROM Y1 TO Y2 

Put the pixel value for given pixel number at the 
address 

IF Y1 < Y2 THEN 

Add the number of bytes per line to the address 
ELSE 

Substract the number of bytes per line from the 
address 

ENDIF 

ENDFOR 

Put the pixel value for the given pixel number at the 
address 


ENDPROC 



60 


c. DRAWLINE 

This command draws a line between two points which are 
maintained in the FORTH variables OLDCOL, OLDROW, NEWCOL, 
and NEWROW. It is the kernel for both the LINE command and 
the DRAWTO command. 

For efficiency, the draw line function is divided into 
three parts; the general Bresenham's line algorithms, the 
horizontal line algorithm and the vertical line algorithm. 


INPUT: none 


OUTPUT: none 



61 


PROCEDURE DRAWLINE 

Fetch the coordinates of the first point 
Add the offset values to the first point's coordinates 
Compute the outcode value for the first point 
Fetch the coordinates of the second point 
Add offset values to the second point's coordinates 
Compute the outcode value for the second point 
IF the logical-AND of the two outcode values = 0 THEN 
Compute the direction values 
IF ysign = 0 THEN 

Draw the line using the horizontal line algorithm 
ELSE 

IF xsign = 0 THEN 

Draw the line using the vertical line algorithm 
ELSE 

Draw the line using the general Bresenham's 
line algorithm 

END IF 
ENDIF 
ENDIF 


ENDPROC 



62 


d. LINE 

This command calls the command DRAWLINE to draw a line 
between the two given points whose coordinates are on top 
of the parameter stack. 

INPUT: XI — X-coordinate of the start point 

Y1 — Y-coordinate of the start point 

X2 — X-coordinate of the end point 

Y2 — Y-coordinate of the end point 

OUTPUT: none 

PROCEDURE LINE 

Store the coordinates of the first point 
Store the coordinates of the second point 
Call DRAWLINE to draw the line 

< 

Position the cursor at the second point 


ENDPROC 



63 


e. DRAWTO 

This command draws a line from the current cursor 
position to the point whose coordinates are on top of the 
parameter stack. DRAWLINE is called by DRAWTO to do this 
work. 

INPUT: X-coordinate of the point to be drawn to 
Y-coordinate of the point to be drawn to 
OUTPUT: none 

PROCEDURE DRAWTO 

Store the coordinates of destination point 
Call DRAWLINE to draw the line 
Position the cursor at the destination point 
ENDPROC 



64 


8. Draw Box Commands 

a. BOX 

This command draws a rectangular region determined by 
the two opposite-corner points of the rectangular region. 

INPUT: XI — X-coordinate of the first point 

Y1 — Y-coordinate of the first point 

X2 — X-coordinate of the second point 

Y2 — Y-coordinate of the second point 

OUTPUT: none 

PROCEDURE BOX 

Call LOCATE to move the cursor position to (XI,Y1) 

Call DRAWTO to draw a line from (XI f Y1) to (XI,Y2) 

Call DRAWTO to draw a line from (XI,Y2) to (X2,Y2) 

Call DRAWTO to draw a line from (X2,Y2) to (X2,Y1) 

Call DRAWTO to draw a line from (X2,Y1) to (XI ,Y1 ) 


ENDPROC 



65 


b. FBOX 

This command draws a filled rectangular region 
determined by two opposite-corner points of the rectangular 
region. 


INPUT: 


XI — X-coordinate of the first point 

Y1 — Y-coordinate of the first point 

X2 — X-coordinate of the second point 

Y2 — Y-coordinate of the second point 


OUTPUT: none 

PROCEDURE PBOX 


Add the offset values to the first point's coordinates 
Compute the outcode value for the first point 
Add the offset values to the second point's coordinates 
Compute the outcode value for the second point 
IP the logical-AND of the two outcode values = 0 THEN 
Compute the direction values 
Clip the out of range part 
FOR y FROM clipped Y1 to clipped Y2 

Draw a horizontal line from (clipped XI, y) to 
(clipped X2, y) 

ENDFOR 
ENDIF 

Position the cursor at (X2,Y2) 


ENDPROC 



66 


9. Draw Circle Commands 

These commands are used to draw a circle and a filled 
circle with a given center and a given radius. 

There are several very easy but inefficient ways for 
drawing a circle. For example, consider a circle with 
center at the origin with radius R. It's equation is given 
by 

X 2 + Y 2 = R 2 

To draw a quarter circle, we can increment x from 0 to 
R (radius) in unit steps, solving for the y at each step. 
The second way is to plot Rcos© or RsinQ by stepping 9 
from 0 to 90 degrees. Again, these two methods involve 
floating point arithmetic and special function calculations 
which are quite time consuming. 

Bresenham has developed a incremental circle generator 
(7) which is more efficent than either of the above two 
methods. J. Michener(8) derived the following specific 
algebraic results and the consequent algorithm by applying 
Bresenham's methodology. 

dl = 3 - 2R 

If di < 0, then 

di+1 = di + 4Xi-1 + 6 

else 

di+1 = di + 4 ( Xi+1 - Yi-1 ) + 10 



67 


To use J. Michener's algorithm, a supporting algorithm 
called the Eight-way Symmetry Algorithm(9) has to be used. 
This supporting algorithm reduces the necessary coordinate 
calculations to only those for X between 0 to R /J~2~ (the 
point at which x = y). Figure V-6 shows eight symmetical 
points on a circle. 


(-Y.X) 


(-Y.-X) 



(Y,X) 

(Y ,-X) 


Figure V-6 Eight Symmetrical Points on a Circle 



68 


a. CIRCLE-PTS 

This command plots the eight symmetric points of the 
given circle point by applying the Eight-way Symmetry 
Algorithm. When a circle is to be drawn, CIRCLE-PTS is 
called by the DRAWCIRCLE command to plot the eight 
symmetric points for each point on the circle generated by 
DRAWCIRCLE. 

INPUT: X — X-coordinate of a circle point 
Y — Y-coordinate of a circle point 
OUTPUT: none 

PROCEDURE CIRCLE-PTS 
Draw the point (x,y) 

Draw the point (y,x) 

Draw the point (y,-x) 

Draw the point (x,-y) 

Draw the point (-x,-y) 

Draw the point (-y,-x) 

Draw the point (-y,x) 

Draw the point (-x,y) 


ENDPROC 


69 


b. CIRCLE-PILL 

This command draws four horizontal line segments 
between some of the eight symmetric points. When a filled 
circle is to be drawn, CIRCLE-PILL is called by the 
DRAWCIRCLE command to draw the four horizontal line 
segments between some of the eight symmetric points for 
each point on the circle generated by DRAWCIRCLE. 

INPUT: X — X-coordinate of a circle point 
Y — Y-coordinate of a circle point 
OUTPUT: none 

PROCEDURE CIRCLE-PILL 

Draw a horizontal line segment from (X,Y) to (-X,Y) 

Draw a horizontal line segment from (Y,X) to (-Y,X) 

Draw a horizontal line segment from (Y,-X) to (-Y,-X) 

Draw a horizontal line segment from (-X,-Y) to (X,-Y) 


ENDPROC 



70 


c. DRAWCIRCLE 

This command applies J. Michener's algorithm to 
calculate the coordinates of the points on the circle and 
calls CIRCLE-PUT to either draw a circle or a filled circle 
determined by the value of the fill-flag (PILLPLG). 

If the value of the fill-flag is 0, CIRCLE-PUT calls 
CIRCLE-PTS to plot the eight symmetric points; otherwise, 
it calls CIRCLE-PILL to draw the four horizontal line 
segments between some of the eight symmetric points. 


INPUT: CX — X-coordinate of the center point 
CY — Y-coordinate of the center point 
R — Radius of the circle 


OUTPUT: none 



71 


PROCEDURE DRAWCIRCLE 

Transform the origin to (CX,CY) 

Set x to 0 
Set y to R 

Compute d = 3 - 2 * R 
WHILE x < y 

Call CIRCLE-PTS to plot eight symmetric points 
IP d < 0 THEN 

Compute d=d+4*x+6 
ELSE 

Compute d=d+4*(x-y)+10 
Decrement y by 1 
END IP 

Increment x by 1 
ENDWHILE 
IP x = y THEN 

Call CIRCLE-PTS to plot eight symmetric points 
ENDIP 
ENDPROCE 

Consequently, the CIRCLE and PCIRCLE commands become 
quite simple. They either set or reset the fill-flag 
(PILLFLG) and call DRAWCIRCLE to draw the appropriate 
graph. 

Here are more specific details for both CIRCLE and 


PCIRCLE. 



72 


d. CIRCLE 

This command draws a circle with center at the given 
coordinates with radius R. 

INPUT: CX — X-coordinate of the center 

CY — Y-coordinate of the center 
R — Radius of the circle 
OUTPUT: none 

PROCDURE CIRCLE 

Set the fill-flag to "off" 

Call DRAWCIRCLE to draw the circle 
Position the cursor at the center of the circle 
ENDPROC 



73 


e. FCIRCLE 

This command draws a filled circle centered at the 
given coordinates with the given radius. 

INPUT: CX — X-coordinate of the center 

CY — Y-coordinate of the center 
R — Radius of the circle 
OUTPUT: none 

PROCEDURE PCIRCLE 

Set the fill-flag to "on" 

Call DRAWCIRCLE to draw the line segments that fill the 
circle 

Position the cursor at the center of the circle 
ENDPROC 



74 


10. Draw Text String Commands 

These commands are used to draw text strings on the 
display starting at a given point. The text string is 
either entered by the user interactively at execution-time 
or put in word definitions for later compilation. 

The shape of each character in a string is taken from 
the standard ATARI character set which is indexed by the 
Internal Code for the ATARI computer. 

a. CHARACTER 

This command takes the shape data for the given 
ATASCII code and draws that character on the display. It is 
the basis for each text string drawing command. 



75 


INPUT: X — X-coordinate of the given point 
Y — Y-coordinate of the given point 
CODE — ATASCII code for the given character 
OUTPUT: none 


PROCEDURE CHARACTER 

Convert the ATASCII code into the Internal Code 
Compute the starting address of the shape data for that 
character 

FOR each byte of shape data 
FOR each bit of that byte 
IF the bit is "on" THEN 
Plot a point at (X,Y) 

END IF 

Increment X by 1 
ENDFOR 

Reset X to the original value 
Increment Y by 1 
ENDFOR 


ENDPROC 



76 


b. TEXT 

This command draws a text string, entered by 
interactively, on the display starting at the given 
Note: the reference position for the first character 
bottom left-hand corner. 

INPUT: X — X-coordinate of the given point 
Y — Y-coordinate of the given point 
OUTPUT: none 

PROCEDURE TEXT 

Display the prompt message 
Query the use for the string 
FOR each character of that string 

Call CHARACTER to draw that character 
Increment X by 8 
ENDPOR 


user 
point. 
is the 


ENDPROC 



77 


c. STRING" 

This word is an immediate word. At compile time, it 
compiles (PRINT) and the string from the input stream into 
the dictionary. At execution-time, it executes (PRINT) to 
draw the compiled string on the display. Note: the 
reference position for the first character is the bottom 
left-hand corner. 

INPUT: X — X-coordinate of the given point 
Y — Y-coordinate of the given point 
OUTPUT: none 


PROCEDURE STRING" 

IP the state is compile state THEN 

Compile (PRINT) into the dictionary 
Compile the string from the input stream 
ELSE 

Draw the compiled string on the display starting at 
the point (X,Y) 


END IP 


ENDPROC 



78 


1i. Pill Command 

For clarity, some special terms are defined before the 
fill algorithms are considered. The interior of a region 
consists of all the pixels within the region that are not 
on the boundary of the region. A region is called 4- 
connected if all pixels in the region can be reached, one 
from the other, by a sequence of the one-pixel moves: up, 
down, left, or right. The command BPILL in PIGS is 
concerned with 4-connected regions. 

A very simple algorithm to fill a 4-connected region 
is the Simple Recursive Algorithm(10) which applys 
recursion to the set of four neighbor pixels after plotting 
a certain pixel. The primary drawback of this algorithm is 
that many levels of recursion take place and may cause 
stack overflow when memory space is limited. A more 
efficient approach has been developed by A. R. Smith(ll). 

Smith's algorithm divides the region into runs, which 
are horizontal groups of adjacent pixels. Only one pixel 
position is kept for each run to reduce the depth of 
recursion. The algorithm proceeds as follows: the 
contiguous horizontal run of pixels containing the starting 
point is filled in. Then the row just above the filled run 
is examined from right to left to find the rightmost pixel 
of that run. These rightmost pixel addresses are stacked. 
The same is done for the row just below the filled run. 



79 


When a run has been processed in this manner, the pixel 
address at the top of the stack is used as a new starting 
point. When the stack becomes empty, the algorithm 
terminates. 

The algorithm used in BFILL also uses the idea of 
runs, but the sequence of both filling a run and finding 
the seeds for possible runs above and/or below the filled 
run are totally different from that of Smith's algorithm. 

It proceeds as follows: scan each pixel of a run from 
the starting point towards the left to find the left 
boundary position of that run. Then fill the run with the 
current color value. At the same time, check the rows, 
both above and’ below, to determine whether some more runs 
are required; if so, keep the seeds for these runs on the 
stack. When a run has been processed in this manner, the 
seed at top of the stack is used as the next starting 
point. When the stack is empty, the algorithm terminates. 



80 


a. BFILL 

This command fills a 4-connected region with the 
current color starting at the given starting point. If the 
pixel at the starting point already has the same value as 
the current color number, this command terminates 
immediately. 

INPUT: X — X-coordinate of the starting point 
Y — Y-coordinate of the starting point 
OUTPUT: none 

PROCEDURE BPILL 

Read the pixel value of the starting point and keep it 
as the old-value 

IP the old-value is different from the fill value THEN 
Initialize the stack 

Push the starting point on the stack 
WHILE the stack is not empty 

Pop the top point as the next starting point 
Call <FILL to find the left boundary and set both 
uptrig and downtrig to 1 

Call FILL> to plot the pixel values of the run and 
check for new runs above and below 

ENDWHILE 
END IP 


ENDPROC 



b. FILL> 


This word is called by the word BFI1L. It fills the 
current run with the current color and checks the rows 
above and below the current run to determine whether some 
more runs are required- If more runs are required, FIL1> 

puts the seeds of these runs on the stack. 

INPUT: ADDR — address of the left boundary of the run 

PXR — pixel number of the left boundary point of 
the current run 

X — X-coordinate of the left boundary of the run 

Y — Y-coordinate of the left boundary of the run 


OUTPUT: none 



82 


PROCEDURE FILL> 

FOR each pixel of the run from left to right 

Set the pixel value to the current color number 
IF the value of upper pixel = old-value THEN 
IF uptrig = 1 THEN 

Push the position of upper pixel on the stack 
Set uptrig to 0 
END IP 
ELSE 

Set uptrig to 1 
END IF 

IF the value of lower pixel = old-value THEN 
IF downtrig = 1 THEN 

Push the position of lower pixel on the stack 
Set downtrig to 0 
END IF 
ELSE 

Set downtrig to 1 
END IF 
ENDFOR 


ENDPROC 



83 


12. Clear Screen Commands 

These commands are used to clear the whole screen or a 
rectangular region within the screen determined by two 
opposite-corner points. This is done simply by temporarily 
changing the current color to the background color and 
utilizing the PBOX command. 

a. BCLEAR 

This command clears a rectangular region within the 
screen determined by two opposite-corner points. 

INPUT: XI — X-coordinate of the first point 

Y1 — Y-coordinate of the first point 

X2 — X-coordinate of the second point 

Y2 — Y-coordinate of the second point 

OUTPUT: none 

PROCEDURE BCLEAR 

Temporarily save the current color 
Set the current color to the background color 
Call PBOX to draw a filled rectangular determined by two 
opposite-corner points 

Reset the current color back to the saved color 


ENDPROC 



84 


b. CLEAR 

This command clears the whole screen. 

INPUT: none 

OUTPUT: none 

PROCEDURE CLEAR 

Fetch the four boundaries of the terminal window 
Call BCLEAR to' clear a rectangular block whose 
is the terminal window 

ENDPROC 


extent 



85 


15- Box Region Moving and Copying Commands 

These commands move and copy a rectangular region of 
screen data to another place on the same screen. The main 
difference between the two commands in this section is that 
the move command will fill the source rectangular region 
with the background color after copying the screen data to 
another place, but the copy command will not. 

a. Horizontal Line Copying 

For easier implementation, a rectangular region is 
divided into horizontal lines. Copying a rectangular 
region then becomes the process of copying a series of 
horizontal lines. 

For some graphics modes, a screen data byte does not 
contain exactly one pixel. Furthermore, the starting 
pixel, for a horizontal line within a source or destination 
rectangular region, is not always located exactly on a byte 
boundary. As a result, screen data from one region can not 
be copied to another region in a byte by byte manner. 



An approach for copying a horizontal line proceeds as 
follows: first, copy the minimum number of bytes of screen 

data which contain the pixels of the source horizotal line 
into a working area. Second, shift the pixels, which are 
in the working area, either to the left or to the right so 
that they have the same relative alignment within the 
destination horizontal line. Then put the surrounding 
pixels of the destination horizontal line into the two end 
bytes. Finally, copy the bytes of screen data from the 
working area to the destination horizontal line byte by 
byte. Figure V-7 illustrates the copying process for a 
horizontal line from the source to the destination. In 
FIGS, this work is performed by the command LMOVE. 



87 


i i i i 


! dddd|dddd j dddd 

• i i i 

i i i 

ddddjdddd 

1 1 

1 1 

] dddd 

idddd 

i 

i 

i i } 

i “• i- 

|SSSS!SXXX!xxxx 

i 1 1 

1 1 1 

1 i 

1 1 -— 1 

1 XXXX j xxss 

1 1 

1 1 

1 _ 

| SSSS 

1 

1 

i_ 

] SSSS 

1 

1 

1 

i 

| copy to 

!- 1 area 

V 

1 1 1 

working 

i_ 

V 

1 1 

\ 

1 

1 

1 

1 

1 

1 __ 

1 _ 

1 - 1 -i- 

j SXXX!xxxx j xxxx 

1 1 1 

I I 1 

i 1 

] xxss] 

1 1 

1 1 

1 

1 

1 

1 

1 

1 

1 

1 

t r 

1 1 

l-l shift pixels j — | 

V V 

i i i i i 

! _____ 

1 __ _ 

1 1 1 
| sx|xxxx]xxxx 

1 1 
] xxxx]ss 

1 

1 

1 

! 


Destination line 
before copying 


Source line 


Working area 

before 

shifting 


Working area 

after 

shifting 


— > 


handle surrounding 
pixels 


dddx 


xxxx|xxxx 


xxxx 


dddd 


copy To ” 

destination 


V 

• i 

V 


dddd 


ddddIdddx 


XXXXjxxxx 


I 

■ I 

V 


xxxx 


dddd ! 


Working area with 
surrounding pixel 


Destination line 
after copying 


Figure V-7 Copying a Horizontal Line 











































88 


INPUT: none 

OUTPUT: none 

PROCEDURE LMOVE 

Copy screen data bytes from the source horizontal line 
to the working area 

IP the first pixel of the destination horizontal line is 
in a higher-order pixel position than is the 
first pixel of the source horizontal line THEN 
Shift the pixels in the working area to the right to 
match the alignment of the destination 

horizontal line 

ELSE 

Shift the pixels in the working area to the left to 
match the alignment of the destination 

horizontal line 

END IP 

Put the surrounding pixels of the destination horizontal 
line in the two end bytes 

Copy the bytes from the screen data working area to the 
destination hosizontal line 


ENDPROC 



89 


Since the basic components for copying rectangular 
regions have been presented, the two primary commands for 
copying and moving rectangular regions can be discussed. 

b. RCOPY 

This command copies the contents of a rectangular 
region to another place within the same screen. The 
contents of the source region remain unchanged after the 
execution of this command. 



90 


INPUT: SX1 


SY1 

SX2 

SY2 


DX 

DY 


X-coordinate of the first point of the 

source retangular region 

Y-coordinate of the first point of the 

source retangular region 

X-coordinate of the second point of the 

source retangular region 

Y-coordinate of the second point of the 

source retangular region 

X-coordinate of the starting point for the 
destination rectangular region 
Y-coordinate of the starting point for the 
destination rectangular region 


OUTPUT: none 


PROCEDURE RCOPY 

Prepare for the LMOVE command 

FOR each horizontal line within the source rectangular 

region 

Call LMOVE to copy that horizontal line 
ENDFOR 


ENDPROC 



91 


c. RMOVE 

This command copies the contents of a rectangular 
region to another place within the same screen and fills 
the source rectangular region with the background color. 
INPUT: SX1 — X-coordinate of the first point of the 

source retangular region 

SY1 — Y-coordinate of the first point of the 

source retangular region 

SX2 — X-coordinate of the second point of the 

source retangular region 

SY2 — Y-coordinate of the second point of the 

source retangular region 

DX — X-coordinate of the starting point for the 
destination rectangular region 

DY — Y-coordinate of the starting point for the 
destination rectangular region 

OUTPUT: none 

PROCEDURE RMOVE 

Prepare for the LMOVE command 

FOR each horizontal line within the source rectangular 

region 

Call LMOVE to copy that horizontal line 

Fill the source horizontal line with the background 

color 

ENDFOR 

ENDPROC 



92 


14. Scale or Zoom Commands 

These commands provide the capability of magnifying a 
certain part of the screen by a factor of 2 or 4* 

Normally, zooming is done by mapping the zoom window, 
which defines the extent of a certain picture to be seen, 
to a certain viewport, which defines the area of the 
display where the zoomed picture is to be shown. To do 
this mapping, the following general mapping equations are 
normally used. 

Xv.max - Xv. mi n 

Xv = Xv.min +-( Xw - Xw.min ) 

Xw.max - Xw.min 

Yv.max - Yv.min 

Yv = Yv.min +-( Yw - Yw.min ) 

Yw.max - Yv.min 

These equations are quite powerful; they can be 
applied to any size of zoom window and any size of viewport 
as long as the arithmetic computations are valid. However, 
they involve floating point arithmetic. 

The ANTIC graphics modes 8, A and E have the same 
numbers of colors (four), the resolution of mode A is two 
times that of mode 8, and the resolution of mode E is two 
times that of mode A. This means that the pixel size of 
mode A is two times that of mode E and the pixel size of 
mode 8 is four times that of mode E. 





93 


Consequently, zooming can be done by directing ANTIC 
to fetch screen data for display lists of mode 8 or mode A 
from the screen data RAM of mode E. Figure V—8 shows the 
extent of zoom windows for modes 8, A and E. 

0 39 79 159 

0 

19 

39 


79 


Figure V-8 Extent of Zoom Windows 

Since the required screen data for each mode line of 
either mode 8 or mode A is less than that of mode E, the 
screen data required by the zoom window becomes not 
contiguous. A special display list must be prepared to 
direct the ANTIC to fetch these noncontiguous screen data 
for each mode line of either mode 8 or mode A. Each mode 
instruction of this special display list is created with a 
load memory scan option. In FIGS, the word IZOOM-DLS is 
used to prepare that kind of display list. 


- 1 — 

1 

mode 8 i 

i 

i 

i 


- 1- 

1 

1 

1 

1 

1 

1 


i 

mode 

A 

1 

1 

1 

1 

i 

I 

1 

1 

_ 1 



mode 

E 








94 

Furthermore, it is easy to move the zoom window 
around by simply directing ANTIC to fetch screen data 
from different parts of screen data RAM; that is, to change 
the load memory address for each mode line in the display 
list. 

Because these three modes are all 4-color modes and 
four pixel values are maintained in one byte, it seems 
impossible to have a zoom window starting from a point with 
a horizontal coordinate that can not be divided by 4- 
Fortunately, this problem can be solved by using the fine 
scrolling technique. FLUSHDL moves the zoom window by 
changing the load memory addresses for each mode line in 
the display list and using fine scrolling. 

a. !ZOOM-DLS 

For the zoom mode, this command creates a special 
display list which contains a load memory scan option for 
each mode instruction. 

b. FLUSHDL 

This commmand moves the zoom window to a place pointed 
to by the given point. This is done by changing the load 
memory address for each mode line in the display list and 
applying fine scrolling. 



INPUT: 


X — X-coordinate of the upper left-hand corner of 


the zoom window 

OUTPUT: Y — Y-coordinate of the upper left-hand corner of 

the zoom window 

PROCEDURE FLUSHDL 

Transform the X-Y coordinate to a screen data memory 
location and a pixel number 

Compute a proper fine scrolling value using the pixel 
number 

FOR each load memory scan address in the display list 
Put the screen data memory location in that load 
memory scan address 

Increment the screen data memory location by bytes- 
per-line in this mode. 

ENDPOR 

ENDPROC 

c. >Z00MXY 

This command tries to move the zoom window so that the 
cursor position can be at the center of that window; if 
this is not possible, the zoom window will touch the 
boundary of the logical window and will have the cursor 
somewhere within the zoom window. It transforms the given 
X-Y coordinates to zoom X-Y coordinates after moving the 


zoom window. 



96 


15- Player Cursor Manipulation Commands 

These commands provide the capabilities to use ATARI 
players. Please refer to chapter II for more information 
about player-missile graphics. 

a. SINGLE-SIZE, DOUBLE-SIZE, QUAD-SIZE 

These three commands set the player size to either 
single-size (8 color clock width), double-size (16 color 
clock width) or quadruple-size (32 color clock width) for 
the given player. 

b. SINGLE-LINE, DOUBLE-LINE 

These two commands set the player line size option to 
either single-line or double-line. 

c. PLAYER-ON, PLAYER-OFF 

PLAYER-ON directs the CTIA to start fetching the 
player shape data from the player-missile base area. 
PLAYER-OFF directs the CTIA to stop fetching all player 
shape data. 



97 


d. PLAYER-CLEAR 

This command clears the player shape data for 
current player. 

e. SETPPIG 

This command assigns a defined player shape and 
reference position to a given player. 

f. SETPLAYERS 

This command reserves a block of memory for 
player-missile base area and sets the default values 
each player. 

g. USEPLAYER 

This command selects the given player number as 
current player number and sets the necessary data for 
player. 


the 


its 


the 

for 


the 

that 



98 


h. PLAYER 

This command puts the player shape data in the player 
shape data area for the current player and sets the 
horizontal position register to the proper value. When the 
player display is turned on by PLAYER-ON, it displays the 
player shape at the given position on the screen. 

INPUT: X — X-coordinate of the given player position 
Y — Y-coordinate of the given player position 
OUTPUT: none 

PROCEDURE PLAYER 

Transform the X-Y coordinates to the coordinates used 
by the player 

Store the X-coordinates used by the player in the 

t 

horizontal position register 

Move the player shape data to the player shape data area 
for the current player 

ENDPROC 



99 


16. Disk File Management Commands 

These commands provide a simple disk file management 
environment that supports the following functions: 

. Display the directory of a disk 

. Save the screen data as a file on a disk 

. Save the display list in a disk file 

. Reload the screen data and/or display list from a 
disk file 

. Delete a disk file 

. Format a new disk 

The basic component of the file management system is a 
block (a sector on the ATARI) which is 128 bytes in 
length. The disk is divided into three categories: 

. Master directory sector 

. File directory sectors 


. Data sectors 



100 


Once a new disk has been formated by the FORMAT 
command, the data sectors are linked together into a free 
sector list and the directory sectors are linked together 
to form the directory. The master directory sector keeps 
the pointers and counters for the free sector list and the 
head of the directory sectors. It also keeps track of the 
total number of sectors in this disk and the number of 
sectors currently being used. Figure V-9 illustrates the 
master directory sector layout. Figure V-10 illustrates 
the data sector layout. Figure V—11 illustrates the file 
directory layout. Figure V—12 illustrates file directory 
entry layout. Figure V—13 illustrates the relationship 
among the three kinds of sectors. 



Not used 


! ! j I_ Number of free sectors 

I I I 

! i j Pointer to free sector list 

1 ! - 

i i 

; |_ Number of file directory sectors 

i 

!_ Pointer to file directory list 

_ Number of sectors 

currently in use 

_ Total number of disk sectors 

Figure V-9 Master Directory Sector Layout 


2 | 120 ! 
i i 

i__i 

I 1 

j | Data area 

i - 

i 

|_ Bytes in data area 

_ Load address 

__ Link to next sector 

_ Sector number 

Figure V-10 Data Sector Layout 




























102 


2 


31 


31 


31 


i 

i 

i 


Not used 


Pile directory 
entries 


Sector number 


Figure V—11 Pile Directory layout 


18 


Other 

information 


Number of file sectors 

Pointer to the tail of 
file sector list 


Pointer to the head of 
file sector list 

Starting address of 
display list 

Pile name 

(1-5 characters) 


Length of file name 


Figure V-12 Pile Directory Entry Layout 


























103 


Master directory 




Figure V-13 Relationship Among the Three Kinds of Sectors 









104 


a. DIR 

This command lists the filenames of the existing 
files. It provides the capability to look at the filenames 
for the existing files. 

INPUT: none 

OUTPUT: none 

PROCEDURE DIR 

FOR each file directory sector 
Read this sector 

FOR each file directory entry in this sector 
IF the length of filename > 0 THEN 
Display the file name 
ENDIF 
ENDFOR 
ENDFOR 
ENDPROC 

b. STORE-DATA 

Depending on the value of DDFLAG and DLFLAG, this word 
is called by (GSAVE) to save a display list and/or screen 
data as a disk file. It is the basis for (GSAVE). 



105 


INPUT: none 

OUTPUT: none 

PROCEDURE STORE-DATA 

Set the display list pointer to the starting location of 
the current display list 

WHILE the display list pointer does not equal the last 
byte of the display list 

Get one display list instruction from the display 
list 

IP the instruction is a blank line instruction THEN 
Increment the display list pointer 
ELSE 

IP the instruction is either a load memory scan or 
a jump vertical blank instruction THEN 
Store the previous unsaved part of the screen 
data 

Increment the display list pointer by 3 
IP the instruction is a jump vertical blank 
instruction THEN 

Store the previous unsaved part of the 
display list 

Indicate the end of the display list 
END IP 
ELSE 


Increment the display list pointer by 1 



106 


END IP 
END IP 

IP the length of the previous unsaved screen data is 
more than 119 bytes THEN 
Store 120 bytes of screen data on disk 
END IP 

IP the length of the previous unsaved display list is 
more than 119 bytes THEN 
Store 120 bytes of screen data on disk 
ENDIP 
ENDWHILE 
ENDPROC 

c. GSAVE 

Depending on the values of DDFLAG and DLPLAG, this 
command checks whether a specific filename is duplicated; 
if not, it calls (GSAVE) to save the display list and/or 
screen data as a disk file. 

d. SAVE-DL 

If the filename is unique, this command saves the 
display list in a file with this name. It simply resets 
the DDPLAG to 0, sets the DLPLAG to 1 and calls GSAVE to 
complete the work. 


107 


e. SAVE-DD 

If the filename is unique, this command saves the 
screen data in a specific file. It simply sets the DDFLAG 
to 1 , resets the DLFLAG to 0 and calls GSAVE to complete 
the work. 

f. SAVE-ALL 

If the filename is unique, this command saves both the 
screen data and display list in the specific file. It 
simply sets boths DDPLAG and DLPLAG to 1 and calls GSAVE to 
complete the work. 

g. GLOAD 

This command reloads the screen data and/or display 
list from the given file. Since every data sector of a 
file keeps not only the data itself but also its load 
address, the load process is quite simple; read each sector 
of the file and move the data into memory starting from the 
load address. 

h. DELETE 

This command deletes the given filename from the file 
directory and reassigns the used data sectors to the free 


sector list. 


108 


i. FORMAT 

This command formats a disk with the format necessary 
for this simple disk file management system. Actually, it 
links the file directory sectors into the file directory 
sector list, it links the data sectors into the free sector 
list, and it writes the necessary initial values in the 
master directory sector. 



109 


17. KoalaPad Interfacing Commands 

These commands read the values of the stylus position, 
along with the left-hand right-hand buttons of the KoalaPad 
Touch Tablet. Please refer to chapter III for more 
information about the KoalaPad Touch Tablet. 

a. PADXY 

This command reads the X-Y coordinates of the stylus 
and puts them on top of the parameter stack. 

b. LBTN 

This command reads a value from the left button of the 
KoalaPad Touch Tablet and puts it on top of the parameter 
stack. 

c. RBTN 

This command reads a value from the right button of 
the KoalaPad Touch Tablet and puts it on top of the 
parameter stack. 

d. >SCRXY 

This command transforms the values read from the 
stylus position of the KoalaPad Touch Tablet to the normal 
X-Y coordinates for the current graphics mode. 



110 


18. Display List Interrupt Handling Commands 

These commands aid the user to handle display list 
interrupts. 

A display list interrupt is a non-maskable interrupt. 
The process begins when the ANTIC encounters a display list 
instruction with its interrupt bit (bit 7) set. ANTIC 
waits until the last scan line of the current mode line is 
displayed. It then refers to the non-maskable interrupt 
enable register to see whether the display interrupt bit 
has been set. If that bit is not set, ANTIC goes back to 
its normal work; otherwise, an interrupt to the 6502 
occurs. The 6502 then vectors through the non-maskable 
interrupt vector (NMI) to an interrupt service routine in 
the OS. This service routine first determines the cause of 
the interrupt. If the interrupt is indeed a display list 

f 

interrupt, the routine vectors through addresses 200 and 
201 (hex) to a display interrupt service routine. 

In the FORTH environment, the service routine can be 


written 

as a 

low- 

-level 

code word with 

the code 

field 

address 

(CFA) 

of 

that 

word as its entry point. 

This 

routine 

must 

end 

with 

a RTI (return 

from interrupt) 


instruction. 



Once the service routine has been prepared, the 
address of its entry point can be put in addresses 200, and 
201 (hex). Finally, the user can enable the display list 
interrupt routine by setting the enable bit for the display 
list interrupt. 

a. DLI-ON 

This command enables the display list interrupt 
routine by setting the display list interrupt enable bit in 
the NMIEN register to 1. 

b. DLI-OFF 

This command disables the display list interrupt 
routine by resetting the display list interrupt enable bit 
in NMIEN register to 0. 

c. SETDLIV 

This command put the address of the entry point for 
the display list interrupt service routine, which is on top 
of the parameter stack, in the display list interrupt 
vector at 200, 201 (hex). 



VI. A FORTH INTERACTIVE GTAPHICS EDITOR 


The purpose of the Forth Interactive Graphics Editor 
(FIGE) is to provide capabilities for creating graphics on 
the display surface of a television by using the KoalaPad 
Touch Tablet and the ATARI keyboard. The human factors 
considered during the design of FIGE were 

. Make it simple for the user to use 

. Give the user more than one chance 

The first factor requires a simple man-machine 
interface that is not only easy to use but is also easy to 
learn. In FIGE, a simple menu driven interface is achieved 
with the KoalaPad and the ATARI keyboard. It is very 
simple both to use and to learn. 

The second factor allows the user to gracefully 
recover from mistakes. The FIGE performs boundary checking 
for all graphics draw commands. It also requires user 
acknowledgement for such critical destructive commands as 
clearing a whole screen, formatting a disk, and exiting 
from the system without saving screen data. 

For the sake of convenience, the main menu of FIGE, 
which first appeared in chapter I, is presented again 
in Figure VI-1. 



113 



Figure VI-1 Main Menu of FIGE 




























114 


A. System Overview 

The FIGE has been developed as an application oriented 
extension of PIGS. It utilizes the primitive commands 
provided by PIGS to perform most of its functions. Since 
PIGE is a menu driven graphics editor, all graphics 
features are selected and performed through a menu. As a 
result, an efficient pointing device was required for 
selecting entries from the menus. The KoalaPad Touch 
Tablet was chosen as the primary pointing device because of 
its significant features that aid menu selection. Refer to 
chapter III for more information about this device. 

Before descriptions of the system structure are 
presented, a summary of the features provided by the PIGE 
are listed below: 

. Plot a point at the present cursor position 
. Draw a line between two points 

. Draw points determined by the trace of the cursor 
. Erase points 
. Draw a text string 
. Draw a rectangle 
. Draw a filled rectangle 
. Draw a circle 
. Draw a filled circle 

Pill a connected closed region with the current 


color 




115 

. Copy a rectangular region to another place 
. Move a rectangular region to another place 
. Clear the whole screen 
. Clear a rectangular region 

. Display a color menu and select colors from it 
. Display a disk management menu and provide 
functions such as displaying the directory, saving 
screen data, loading screen data, deleting a file, 
and formatting a disk 

. Zoom the picture to either normal, double or 
quadruple size 

. Select brushes to draw or erase with 
. Adjust the luminance of the current color 
. Select a color number from the available (four) 
color numbers 

A user's guide for FIGE is presented in the next 
section. 

Since the FIGS is a menu driven system, system control 
is based on the user selecting entries from a menu. The 
processing sequence listed below is executed repeatedly by 
FIGS. 

Show the menu 
Get a command 


Execute that command 


11 6 

The main structure chart for FIGE is shown in 
igure VI-2 while the subordinate structure charts are 
hown in Figure VI-3, Figure VI-4, and Figure VI-5- 



Figure VI-2 Main Structure Chart for PADPLOT 





























1 18 




i 

i 



Figure VI-5 Structure Charts for EXEC-CMD 



































119 


B. Detail Description of Commands 

In this section, the important words from FIGE are 
described in detail. They are presented in the top-down 
sequence as they appear in the system structure charts 
presented in the last section. 

1. PADPLOT 

This command is the only command that can be used to 
enter PIGE when the CONTEXT vocabulary is DEMO. It is at 
the top level of PIGE. See the structure chart shown in 
figure VI-2. PADPLOT calls INITENV first to display the 
title page of PIGE, to prompt the user for entering "GO", 
to load the main menu into RAM from the disk, and to 
initialize the required environment. It then repeatedly 
executes the sequence: show the menu, get a.command and 
execute that command, until the user chooses to leave the 
system by selecting the command EXIT. Finally, it informs 
the the user that PADPLOT has been exited and returns to 
the FORTH environment. 

INPUT: none 


OUTPUT: none 



PROCEDURE PADPLOT 


Call INITENV to load the main menu and to initialize the 
required environment 
Set exitflag to 0 

IP the initialization process was successful THEN 
UNTIL exitflag = 1 

Call SHOW-MENU to display the main menu 
Call GET-CMD to allow user to select commands with 
the KoalaPad Touch Tablet stylus from 
the main menu 

IP the attempt at selecting a command succeeded 

THEN 

Call EXEC-CMD to execute that command 
END IP 
ENDUNTIL 
END IP 


ENDPROC 


121 


2. INITENV 

This word is called by PADPLOT. It displays the title 
page for FIGE, prompts the user to enter "GO" from a 
keyboard to load the main menu, and initializes the 
environment. The content of the title page is shown in 
Figue VI-6. 


WELCOME TO 
PADPLOT 
BY 

JER-MING LEE 
19 8 5 

INSERT SCREEN DISK 
TYPE 'GO' TO START 


Figure VI-6 Title Page of FIGE 


INPUT: none 

OUTPUT: Result flag 

1: "GO" was typed and the main menu was 

successfully loaded 

0: only the <RETURN> key was pressed. The user 
wanted to leave the system 






122 


PROCEDURE INITENV 

Set the color registers to their default values 
UNTIL "GO" is typed or only the <RETURN> key is pressed 
Display the title page 

Query the user to either enter "GO" or to press the 
<RETURN> key 
IP "GO" was typed THEN 

Inform the user to wait 

Call GLOAD to load the main menu from a disk file 
named "GO" 

Reset the current zoom, the current brush, and the 
current command to their default values 
Set the result flag to 1 
ELSE 

IP only the <RETURN> key was pressed THEN 
Set the result flag to 0 
END IP 
ENDIP 
ENDUNTIL 


ENDPROC 



3. SHOW-MENU 


This word displays the main menu on the screen, marks 
the current color and the current brush with players 1 and 
2, and displays the names of the current command and the 
current zoom. It is called by PADPLOT. Figure VI-1 
illustrates the main menu. 

4. GET-CMD 

This word allows the user to select one of the 
commands from the main menu by pressing the stylus on the 
KoalaPad Touch Tablet and pushing the appropriate button. 
It can also execute immediate commands, which do not 
directly operate on the main graphics screen. Such 

commands include changing the colors, selecting the 

current color, selecting the current brush, selecting the 
current zoom mode, changing the luminance of the current 
color, directing FIGE to exit and directing FIGE to execute 
the currently selected command. 

INPUT: none 

OUTPUT: CMD# — command number 

1 — flag indicating selected command is OK 
or 0 — flag indicating that the EXIT immediate 

command has been executed and that the 
execution of the current command is not 


necessary 



124 


PROCEDURE GET-CMD 

UNTIL either the immediate command EXIT or GO is 
executed 

UNTIL a valid command is selected and the left 
button of the KoalaPad Touch Tablet is 
pressed 

Get a position from the Koalapad Touch Tablet 
Call >CMD# to convert the position to a command 
number 

IP the command number is valid THEN 

Display the name of that command as a candidate 
command 

END IP 
ENDUNTIL 

IP the command is an immediate command THEN 
Execute that command 
ELSE 

Set the current command to that selected command 
Display the name of that command as the current 
command 

END IP 
ENDUNTIL 


ENDPROC 



125 


5• EXEC-CMD 

This word is called by PADP10T. It executes the 
command selected by GET-CMD. This is done by means of 
vectored execution. The vector for each command is kept 
in a table called the command table. The vector for a 
command contains the code field address (cfa) of that word. 
When a command is selected for execution, the cfa for this 
command is executed by the FORTH word EXECUTE. 

Table VI-1 illustrates the contents of the command 
table. This table consists of several arrays, namely 
CMD-CFA, CMD-ATTR, and CMD-NAME. CMD-CFA contains the cfas 
of the commands. COM-ATTR contains the attributes of the 
commands. CMD-NAME contains the names of the commands. 



Command 

number 

Command 

name 

Word in 

PIGE 

Command 

attribute 

(hex) 

0 

POINT 

PLOT 

1 

1 

LINE 

LINE 

2 

2 

DRAW 

DRAW 

0 

3 

ERASE 

ERASE 

0 

4 

TEXT 

XTEXT 

1 

5 

BOX 

BOX 

2 

6 

PBOX 

PBOX 

2 

7 

CIRCLE 

XCIR 

2 

8 

FCIRCLE 

XPCIR 

2 

9 

PILL 

BP ILL 

1 

10 

RCOPY 

RCOPY 

3 

11 

RMOVE 

RMOVE 

3 

12 

CLEAR 

XCLEAR 

0 

13 

BCLEAR 

BCLEAR 

2 

14 

SETCOLOR 

SETCOLOR 

10 

15 

DISK 

DISK 

0 

16 

PRINTER 

PRINTER 

0 

17 

SETZOOM 

SETZOOM 

10 

18 

SETZOOM 

SETZOOM 

10 

19 

SETCOLOR 

SETCOLOR 

10 

20 

SETBRUSH 

SETBRUSH 

10 

21 

LUMINANCE 

SETLUMIN 

10 

22 

EXIT 

EXIT 

10 

23 

GO 


10 

24 

USECOLOR 

UCOLOR 

10 


Table VI-1 FIGE Command Table 






1 27 


INPUT: CMD# — command number selected by GET-CMD 

1 — flag indicating the selected command is OK 
or 0 — flag indicating that the execution of the 

current command is not necessary 

OUTPUT: none 

PROCEDURE EXEC-CMD 

Get the cfa of the current command from the array 
CMD-CFA 

IF the current command is a primitive command THEN 

Call SHOW-SCREEN to display the main graphics screen 
UNTIL the right button of the KoalaPad Touch Tablet 
is pressed 

Vector to either ONE-POINT, TWO-POINTS or THREE- 
POINTS to get the correct number of 
points needed by the current command 
IF the points were obtained THEN 
Execute the primitive command 
END IF 

Clear the base area of the players 
ENDUNTIL 
ELSE 

Execute the current special command 
END IF 


ENDPROC 


6. SETCOLOR 


This command displays a color menu which overlays the 
left-hand side of the main menu and allows the user to 
select a color for the current color. The color menu is a 
collection of colored bands. It is shown by means of 
player 3 in quadruple size. The purpose of using a player 
as a color menu is to make it easier to overlay the color 
menu on the main menu. A display list interrupt is used to 
show 16 different colors on the same screen. First, the 16 
different color values are prepared in an array called 
C0LRP001. Second, a display list is prepared with the 
interrupt bit set on every other ten mode lines. Third, a 
display list interrupt service routine is prepared that 
fetches a color value from COLRPOOL and stores it in the 
color register of player 3 whenever a display interrupt 
occurs. Finally, the interrupt service routine is enabled. 


In 

FIGE, all four 

steps 

are done before SETCOLOR 

is 

called. 

Consequently, 

SETCOLOR shows 

the color 

menu 

by 

simply 

moving the player to 

the proper 

place 

from 

the 

previous 

hidden place. 

When 

selecting 

a color 

from 

the 


color menu, the user can also change the luminance of the 


current color. 



INPUT: none 


OUTPUT: none 

PROCEDURE SETCOLOR 

Show the color menu by moving player 3 to position (0,0) 
UNTIL the selected position is not for the color menu 
and not for changing the current color and not 
for changing the luminance 
Select a position on the menu screen 

IP the selected position is for the color menu THEN 
Store the selected color in the current color 
register 

ELSE 

IP the selected position is for adjusting the 
luminance THEN 
Adjust the luminance 
ELSE 

Set the current color to the selected color 
END IP 
END IP 
ENDUNTIL 

Move player 3 to a hidden place 


ENDPROC 



130 


7. DISK 

This command displays a disk operation menu 
allows the user to select one of the disk operations 
the KoalaPad Touch Tablet. Figure VI-7 illustrates 
disk operation menu. 



DISK 

OPERATION MENU 



> 

DIRECTORY 



> 

SAVE SCREEN 



> 

LOAD SCREEN 



> 

DELETE FILE 



> 

FORMAT DISK 



> 

RETURN 



Figure VI-7 Disk Operation Menu 


that 

with 

the 





131 


INPUT: none 

OUTPUT: none 

PROCEDURE DISK 

UNTIL the 'RETURN' option is selected or the right 
button of the KoalaPad Touch Tablet is pressed 
Display the disk operation menu 
UNTIL a valid option is selected 

Call ONE-POINT to get one point from the screen 
IP this point is a valid point THEN 

Convert the coordinates of that point to a menu 
option 

IP this is a valid option THEN 

Vector to the command corresponding to this 
option 

Execute that command 

t 

END IP 
ENDIP 
ENDUNTIL 
ENDUNTIL 


ENDPROC 



8. DRAW 


This command draw points determined by the trace of 
the cursor. The cursor can correspond to one of five 
brushes that have different sizes and shapes. Different 
brushes are selected by the SETBRUSH command. When the 
cursor is moved to a new point, this command draws lines 
between the respective points corresponding to the current 
brush. In order to draw points with different types of 
brushes, the DRAWLINE command is vectored to the 
appropriate draw command. 

Because noise is sometimes detected as points by the 
KoalaPad Touch Tablet, the word GOODPOINT? is used to check 
for noise. This is done by continually comparing 
consecutive pairs of points that are read by the KoalaPad; 
if the second point is more than five points away from the 
first point, then the second point is treated as noise, 
that is, it is ignored. 

INPUT: none 


OUTPUT: none 



133 


PROCEDURE DRAW 

WHILE the right button of the KoalaPad Touch Tablet is 
not pressed 

Call SETPOINT to set the first point 

WHILE the left button of the KoalaPad Touch Tablet is 
pressed 

Call SETPOINT to set the second point 
Call GOODPOINT? to check for noise 
IP the second point is a good point THEN 

Call DRAWLN to draw a line from the first point 
to the second point and set the 
current point to be the second point 

END IP 
ENDWHILE 
ENDWHILE 
ENDPROC 



C. User's Guide 


In this section, a complete description for each 
selection in FIGE is presented. For convenience, the 
appropriate figure from the main menu is presented with 
each selection. 

1. Getting Started 

. Boot up the system from the FIGE boot diskette 
which contains fig-FORTH, FIGS, and FIGE. 

. Type "GRAPHICS" to switch to the GRAPHICS 
vocabulary. This vocabulary contains FIGS. 

. Type "DEMO" to switch to the DEMO vocabulary. 
This vocabulary contains FIGE. 

. Type "PADPLOT" to start FIGE. The title page for 
FIGE will then appear on the display screen. Figure 
VI-6 shows the contents of this title page. 

. Insert into the drive a FIGE file system diskette 
which contains the file to be operated on. 

. Type "GO" to load the main menu. After a few 
seconds, the main menu illustrated in Figure VI-1 
will be displayed. 



135 


2. Using the Main Menu 

The main menu for FIGE consists of four sections, 
namely, the color section, the command section, the message 
section, and the color menu section. 

Color section (top): This section contains the 

current colors that are in the four color 
registers. 

. Command section (middle): This section contains 
entries for selecting graphics commands, a set 
color command, a set brush command, and a set zoom 
mode command. 

. Message section (bottom): This section dynamically 
displays messages to the user, such as the name of 
the current command, the name of the candidate 
command, and the name of the current zoom mode. 

. Color menu section: This section is shown only when 
the SETCOLOR command is activated. The left-hand 
side of the command section is overlayed when the 
color menu is being shown. 



136 


To make a selection from the menu, follow the steps 
listed below: 

. Press the stylus on the touch tablet. A cursor 

will appear on the display screen. 

Move the stylus so that the position of the cursor 
is on the entry to be selected. When this occurs, 
the name of the candidate command will be 

displayed in the message section with the label 
"NEW:". 

. Press the left-hand button when the entry is 

correctly positioned. When this entry has been 
selected, the corresponding command name will be 
displayed in the message section with a label 
"CMD:". Note: not all entries will effect the 
current command status. 



137 


3- Taking a Glance at the Graphics Screen 

The graphics screen consists of two main sections, 
namely, the graphics section and the message section. 

. Graphics section: This section is based on ANTIC 

mode D which has 4 colors and 160 by 80 resolution. 

. Message section: This section dynamically displays 
messages to the user, such as the current command 
(labled as "CMD:") and the current cursor 
coordinate (labled as "X,Y:"). 

Figure VI-8 illustrates the layout of the graphics 
screen. 


0 160 


1 

1 

1 

1 

1 

I 

1 

1 

1 

1 

I 

1 

1 

! 


-r 

i 

f 

i 

i 

i 

i 

i 

i 

i 

i 

i 

! Graphics 

I 

1 

1 

1 

1 

1 

1 

1 

I 

1 

1 

1 

1 

i 

1 


! section 

i 

1 

1 

1 

1 

1 

1 

1 

1 

! 

1 

___ 1 

i CMD: . . . 

X,Y: .. , .. 

! Message 

i 

i 

i 

i 


| section 

i 

i 


Figure VI-8 Graphics Screen 






4. Using the Graphics Commands 


1 38 


a. Point 

This command plots a point at the present cursor 
position. 

. Position the cursor on the display screen at the 
desired point. 

. Press the left-hand button of the KoalaPad. A 

point will appear at the cursor position. 

. Release the left-hand button of the KoalaPad. 

. Repeat the above steps, if needed. 

. Press the right-hand button of the KoalaPad to 
return to the main menu. 





139 


b. Line 

This command draws a line between two points that have 
been previously selected. 

. Position the cursor on the display screen at the 
first point. 

. Press the left-hand button of the KoalaPad to fix 
the first point. 

. Repeat the above steps a second time to select the 
second point. A line will be drawn between these 
two points. 

. Repeat the above steps to draw more lines, if 
needed. 

Press the right-hand button of the KoalaPad to 
return to the main menu. 



Line 




Draw 


1 40 


c. 


This command draws points determined by the trace of 
the brush (or cursor). 


Position the brush on the display screen at the 
starting location. 

Hold down the left-hand button of the KoalaPad. 

. Move the brush. The points under the trace of the 
brush will be drawn. 

. Release the left-hand button of the KoalaPad to 
stop drawing. 

Repeat the above steps to start drawing again at a 
new location, if needed. 

. Press the right-hand button of the KoalaPad to 
return to the main menu. 





141 


d. Erase 

This command erases points determined by the trace of 
the brush (or cursor). 

Position the brush on the display screen at the 
starting location. 

Hold down the left-hand button of the KoalaPad. 

Move the brush. The points under the trace of the 
brush will be erased. 

Release the left-hand button of the KoalaPad to 
stop erasing. 

. Repeat the above steps to start erasing again at a 
new location, if needed. 

Press the right-hand button of the KoalaPad to 
return to the main menu. 





142 


e. Text 

This command draws a text string, which is entered 
from the keyboard, starting at the present cursor position. 
Note: the reference position for the first character is the 
bottom left-hand corner. 

Position the cursor on the display screen at 
desired point. 

. Press the left-hand button of the KoalaPad to fix 
the reference position at the present cursor 
position for the first character of a text string. 
Enter a text string from the keyboard of the ATARI 
as instructed. The text will then be drawn on the 
display screen starting at the cursor position. 

. Repeat the above steps to draw as many text strings 
as are needed. 

. Press the left-hand button of the KoalaPad to 
return to the main menu. 





143 


f. Box 

This command draws a rectangle determined by two 
opposite corners of that rectangle. 

. Position the cursor on the display screen at one 
of the corners of the rectangle. 

. Press the left-hand button of the KoalaPad to fix 
the cursor at this corner. 

Repeat the above steps once again to select the 
opposite corner of the rectangle. A rectangle will 
then be drawn. 

. Repeat the above steps, if needed. 

Press the right-hand button of the KoalaPad to 
return to the main menu. 





144 


g. Fbox 

This command draws a filled rectangle determined by 
two opposite corners of that rectangle. 

Position the cursor on the display screen at one 
of the corners of the rectangle. 

. Press the left-hand button of the KoalaPad to fix 
the cursor at this corner. 

. Repeat the above steps once again to select the 
opposite corner of the rectangle. A filled 
rectangle will then be drawn. 

. Repeat the above steps, if needed. 

. Press the right-hand button of the KoalaPad to 
return to the main menu. 





145 


h. Circle 

This command draws a circle with center at the first 
selected point and with radius determined by the distance 
between the first selected point and the second selected 
point. 

. Position the cursor on the display screen at the 
center of a circle. 

. Press the left-hand button of the KoalaPad to fix 
the cursor at that position. 

. Move the cursor to a second point which determines 
the radius of the circle. 

. Press the left-hand button of the KoalaPad to 

select that position. A circle will then be drawn. 

. Repeat the above steps to draw as many circles as 
are needed. 

. Press the right-hand button of the KoalaPad to 

return to the main menu. 





146 


i. Fcircle 

This command draws a filled circle with center at the 
first selected point and with radius determined by the 
distance between the first selected point and the second 
selected point. 

. Position the cursor on the display screen at the 
center of a circle. 

. Press the left-hand button of the KoalaPad to fix 
the cursor at that position. 

. Move the cursor to a second point which determines 
the radius of the circle. 

Press the left-hand button of the KoalaPad to 

select that position. A filled circle will then be 

drawn. 

Repeat the above steps to draw as many filled 

circles as are needed. 

Press the right-hand button of the KoalaPad to 

return to the main menu* 





147 


j. Fill 

This command fills a connected closed region with the 
current color. 

. Position the cursor on the display screen at a 
point within the region that is to be filled. 

. Press the left-hand button of the KoalaPad to 

select that location. The region will then be 

filled with the current color. 

. Repeat the above steps to fill as many regions as 
needed. 

. Press the right-hand button of the KoalaPad to 

return to the main menu. 





148 


k. C opy 

This command copies a rectangular region to another 
position. 

. Position the cursor on the display screen at a 
corner of the source rectangular region. 

. Press the left-hand button of the KoalaPad to 

select that corner. 

. Follow the same process to select the opposite 
corner of the source rectangular region. 

. Follow in the same manner as above to select the 

upper left-hand corner of the destination 
rectangular region. The source rectangular region 
will then be copied to the desired destination. 

. Repeat the above steps to copy as many regions as 

needed. 

. Press the right-hand button of the KoalaPad to 

return to the main menu. 




149 


1. Move 

This command moves a rectangular region to another 
position- 


Position the cursor on the display screen at a 
corner of the source rectangular region. 

Press the left-hand button of the KoalaPad to 
select that corner. 

. Follow the same process to select the opposite 
corner of the source rectangular region. 

. Follow in the same manner as above to select the 
upper left-hand corner of the destination 
rectangular region. The source rectangular region 
will then be moved to the desired destination and 
the source rectangular region will be filled with 
the background color. 

. Repeat the above steps to move as many regions as 
needed. 

. Press the right-hand button of the KoalaPad to 
return to the main menu. 




m. Clear 


1 50 


This command clears the whole screen. The user must 
acknowledge this request by pressing the left-hand button 
of the KoalaPad. 

. Follow the instructions in the message section to 
press either the left-hand button of the KoalaPad 
or the right-hand button of the KoalaPad. 

. If the left-hand button of the KoalaPad has 
been pressed, the whole screen is cleared. 

. If the right-hand button of the KoalaPad has 
been pressed, this command is ignored. 

. After executing this command, the user will be 
returned to the main menu. 





151 


n. Bclear 

This command clears a rectangular (box-like) region 
determined by two opposite corners of that rectangular 
region. 

Position the cursor on the display screen at one 
corner of the required rectangular region. 

. Press the left-hand button of the KoalaPad to 
select that corner. 

. Follow the same process again to select the 
opposite corner of that region. That region will 
then be filled with the background color. 

. Repeat the above steps to clear as many rectangular 
regions as needed. 

Press the right-hand button of the KoalaPad to 
return to the main menu. 





5- Using the Color Memu 


The setcolor command displays the color menu on the 
left-hand side of the graphics screen. The user can select 
any color as one of the four possible colors (registers). 
See the next section on how to switch from the current 
color register to one of the other three possible color 
registers. 

. Position the cursor within the block of the color 
to be selected. 

. Press the left-hand button of KoalaPad to select 
that color. It will become the the current color 
for that register. 

. Repeat the above steps, if needed, to select colors 
for the other color registers. 

. To make the color menu disappear and the main 
menu return, either press the right-hand button of 
KoalaPad or press the left button of the KoalaPad 
while leaving the stylus off the tablet. 

. While using the color menu, the usecolor and 
the adjust luminance commands still can be used. 





153 


6. Usecolor 

The usecolor command selects a color from the 

four available colors. 

. Position the cursor within the color box that has 
the color to be selected as the current color. 

. Press the left-hand button of the KoalaPad to 
select that color. A pair of bright horizontal 
lines will appear above and below that color box to 
indicate that it is the current color. 

. To change the color under consideration, repeat the 
above steps. 

Usecolor can be executed either during the main menu 
command selection stage or during the color menu 
selection stage. 













154 


7. D<—>B 

This command adjusts the luminance of the current 
color (Darker or Brighter). 

. Position the cursor within either the hox which 
contains "D" or the box which contains "B". 

. Press the left-hand button of the KoalaPad to 
change the current color one level in brightness. 
If "D” had been selected, the current color will 
get one level darker; while, if "B" had been 
selected, the current color will get one-level 
brighter. Beware, one level brighter than the 
brightest level is the darkest level. Similarly, 
one level darker than the darkest level is the 
brightest level. 





155 


8. Zoom 

This command sets the zoom mode to either normal, 
double, or quadruple. 

. Position the cursor within the smallest box, 
the medium sized box, or the largest box. 

. Press the left-hand button of the the KoalaPad to 
set the current zoom mode to either normal, double, 
or quadruple. 

. To select another zoom mode, follow the steps 
described above. 





9. Setbrush 


1 56 


This command selects one of the five brushes for 
drawing or erasing. 

. Position the cursor in the box that contains the 
desired brush shape. 

. Press the left-hand button of the KoalaPad to 
select that brush as the current brush. A pair of 
bright horizontal lines will appear above and below 
that box to indicate that it is the current brush. 

. To select another brush, follow the steps described 


above. 




1 57 


10. Disk 

This command displays the disk operation menu and 
allows the user to select one of the disk operations. 

. Position the cursor at the disk operation entry. 

. Press the left-hand button of the KoalaPad to 
select that entry. 

Follow the instructions to either enter a filename 
for a screen to be saved, or load a screen that has 
been previously saved, or delete a file from the 
directory, or format a diskette, or terminate the 
directory session. 

. Select the entry "RETURN" to return to the main 
menu. 





1 58 

11. Exit 

This command allows the user to exit FIGE. It 
displays a warning message to make sure that the current 
screen is saved before leaving, if that is desired. The 
user can select one of three options; namely, save the 
current screen, return to PIGE, or exit PIGE. 

. Position the cursor on one of the three options. 

. Press the left-hand button of the KoalaPad to 
select the desired option. Upon leaving PIGE, the 
user will be returned to FORTH. 





159 


12. GO 

This command goes ahead and executes the current 
command. 

This command must be selected by the user whenever 
the current command involves any screen other than the main 


menu. 




VII. CONCLUSION 


1 60 


The purpose of this thesis was to design and implement 
in FORTH both an interactive color graphics system and an 
interactive color graphics editor. 

FORTH Interactive Graphics System (FIGS) has been 
successfully developed on the ATARI 800 XL computer. It 
takes advantage of the advanced hardware features of the 
ATARI computer along with the powerful software features of 
FORTH. Some significant characteristics of FIGS includes: 

1 . FIGS is completely interactive. 

Because FORTH is an interactive environment, the 
user can enter specific graphics commands and see 
results immediately. 

2. FIGS is easy to use. 

Meaningful command names have been selected. 
Simple parameter passing is handled through the 
parameter stack of the FORTH environment. 

3- Commands are error tolerant. 

FIGS protects itself against accidental 
destruction of graphics displays by always 
verifying boundaries specified by the user. 



161 


4- Commands can execute in different graphics modes. 
Most of the graphics commands are designed to work 
with different graphics modes. In addition, 
simple mode switching commands have been provided 
in PIGS. 

5. KoalaPad Touch Tablet is easy to interface to. 
Interfacing to the KoalaPad Touch Tablet is quite 
simple because PIGS provides a collection of 
interfacing commands especially designed for that 
purpose. 

6. Graphics displays are easily saved and reloaded. 
With the support provided by the disk operation 
commands, graphics displays can be saved on disk 
as files and reloaded later as needed. 

The FORTH Interactive Graphics Editor (PIGE) was also 
successfully developed on the ATARI 800 XL computer. It 
was designed on top of PIGS. PIGE is a menu-driven 
graphics editor that uses the KoalaPad as a pointing 
device. 

There are some operations that would desirable but 
have not been implemented in this thesis. These operations 
would be slow on the ATARI computer because no efficient 
floating point hardware is available. One such operation 
is a general scaling algorithm for retangular regions of 
the display. 



The execution speed of some commands could be improved 
with additional hardware support. The absent of floating¬ 
point hardware results both in using more complicated 
algorithms and in using more memory. The overhead due to 
frequent boundary checking also reduces the speed. 



APPENDIX A: GLOSSARY OP WORDS FOR PIGS 


word screen number high/low level 

stack effects 
description 


Comments 

X will always represent the X-coordinate. 
Y will always represent the Y-coordinate. 



1 . Constants for PIGS 


BACKGROUND 7 

( — 2C8H ) 

This constant contains the address of a color register 
used as the background color register. 

BLACK 7 

( — 0 ) 

This constant contains a color value for black. 

BLUE-GREY 7 

( - AO ) 

This constant contains a color value for blue-grey. 

BORDER 7 

( — 2C8H) 

This constant contains the address of a color register 
used as the border color register. 

CHBASE 58 

( — EOOOH ) 

This constant contains the starting address of the 


standard character set shape data. 



COBALT-BLUE 


7 


( — 60H ) 

This constant contains a color value for cohalt-blue. 

COL-SCR 6 

This constant contains the address where the OS keeps 
the X-coordinate of the cursor for the graphic screen. 

COL-TXT 6 

( — 291H ) 

This constant contains the address where the OS keeps 
the X-coordinate of the cursor for the text window. 


COLOR 6 

( — 2C4H ) 

This constant contains the starting address of an area 
where the color registers are located. 

COLORO 7 


( — 2C8H ) 

This constant contains the address of the color 
register used as color 0. 



166 


COLORl 7 

( — 2C4H ) 

This constant contains the address of the color 

register used as color 1 . 

C0L0R2 7 

( — 2C5H ) 

This constant contains the address of the color 

register used as color 2. 

C0L0R3 7 

( — 2C6H ) 

This constant contains the address of the color 

register used as color 3* 


DARK-BLUE 7 

( — 90H ) 

This constant contains a color value for dark-blue. 

DARK-GREEN 7 

( — DOH ) 

This constant contains a color value for dark-green. 



167 


DARK-LABENDER 7 

( — 50H ) 

This constant contains a color value for dark- 
lavender. 

DARK-ORANGE 7 

( — 30H ) 

This constant contains a color value for dark-orange. 

GRACTL 78 

( — D01DH ) 

This constant contains the address of the graphic 
control register used by the CTIA chip. 

HPOSPO 78 

( — DOOOH ) 

This constant contains the address of a register which 
contains the horizontal position of player 0. 

HSCROL 86 

( — D404H ) 

This constant contains the address of the register 

which controls the horizontal fine scrolling. 



LBTN 


79 


( — D404H ) 

This constant contains the address of a register where 
the OS places the value read from the left-hand button 
of the KoalaPad. 

LMGN 6 

( -- 52H ) 

This constant contains the address of a register used 
by the OS to keep the left-hand margin of the text 
screen. 

MEDIUM-BLUE 7 

( — 80H ) 

This constant contains a color value for medium-blue. 

MIEN 61 

( — D40E ) 

This constant contains the address of the non-maskable 
interrupt enable register. 

OLDADDR 6 

( — 5 EH ) 

This constant contains the address of the address 
register used to keep the address of the cursor's 



OLDCHR 


6 


( — 5DH ) 

This constant contains the address of a register where 
the byte which contains the current pixel is saved. 


OLIVE-GREEN 7 

( — BOH ) 

This constant contains a color value for olive-green. 


ORANGE 7 

( — POH ) 

This constant contains a color value for orange. 


ORANGE-GREEN 7 

( — FOH ) 

This constant contains a color value for orange-green. 

PADX 79 

( — 270H ) 

This constant contains the address of a register where 
the OS places the value read as the X-coordinate from 


the KoalaPad. 



170 


PADY 79 

( — 271H ) 

This constant contains the address of a register where 
the OS places the value read as the Y-coordinate from 
the KoalaPad. 

PCLORO 7 

( — 2C0 ) 

This constant contains the starting address where the 
shadow color registers for the four players are 
located. 

RBTM 79 

( — 27D ) 

This constant contains the address of a register where 
the OS places the value read from the right-hand 
button of the KoalaPad. 

RED 7 

( — 40 H ) 

This constant contains a color value for red. 

RED-ORANGE 7 

( — 20H ) 

This constant contains a color value for red-orange. 



171 


ROW-SCR 6 

( — 54 ) 

This constant contains an address where the OS keeps 
the Y-coordinate of the cursor for the graphics 
screen. 

ROW-TXT 6 

( — 290 ) 

This constant contains an address where the OS keeps 
the Y-coordinate of the cursor for the text window. 

RPMBS 78 

( -- D407H ) 

This constant contains the address of the player- 
missile base register. 

RUST 7 

( — 10 ) 

This constant contains a color value for rust. 


SCR-MEMORY 6 

( — 58H ) 

This constant contains the address of an address 


register where the starting address of a graphics 
screen RAM is kept. 



172 


SCR-MODE 6 

( — 57H ) 

This constant contains the address of a register where 
the current graphics mode is kept for OS use. 

SCROLL-LINES 6 

( — 2BPH ) 

This constant contains the address of a register where 
the number of scroll lines is kept. 

SDLSTL 6 

( -- 230 ) 

This constant contains the address of an address 

register where the starting address of the display 
list is kept. 

SDMCTL 6 

( — 22PH ) 

This constant contains the address of the shadow DMA 


control register. 



1 73 


SETVBV 61 

( — E5CH ) 

This constant contains the entry address of an OS 
routine. This routine sets the vertical blank 
interrupt service routine entry vector to the current 
value of the system registers X(high) and Y(low). 

SIZEPO 78 

( — D008H ) 

This constant contains the address of a register where 
the size data for the player 0 is kept. 

STACK-PT 44 

( — D2H ) 

This constant contains the address of the stack 
pointer for an user defined stack. 

TXT-MEMORY 6 

( — 294H ) 

This constant contains the address of an address 
register where the starting address for a text window 


screen RAM is kept. 



174 


TXT-MODE 6 

( — 293H ) 

This constant contains the address of a register where 
the current text mode is kept. 

RLTRAMARINE-BLUE 7 

( — 70H ) 

This constant contains a color value for ultramarine- 
blue. 


VBDEXIT 61 

( — C28AH ) 

THes constant contains the default entry address of 
the vertical blank interrupt delay service routine. 

VDSLST 61 

( — 200H ) 

This constant contains the address of the entry vector 
of the display list interrupt service routine. 

XTEMP 44 

( — 90 ) 

This constant contains a address where the X register 
is temporarily kept during the execution of (STACK- 


PUSH) . 



175 


WADDR 52 
( — 92 ) 

This constant contains a address where the address of 
the working area is temporarily kept during the 
execution of LSHIFT or RSHIG-T. 


176 


2. Variables and Arrays for PIGS 

ADDRPO 78 

( player# — address ) 

This array contains the starting addresses of the four 
locations where ANTIC gets player shape data. 

BI/PX 8 

( mode# — value ) 

This array contains the value for number of bits-per- 
pixel for each of ANTIC modes. 

BITS 52 

( — address ) 

This variable contains the number of bits that the 
bytes within a horizontal line are to be shifted 
before they are copied to the destination. 

BY/LN 8. 

( mode# — value ) 

This array contains the values for the number of bytes 
per line for each of the ANTIC modes. 



177 


BYLN 44 

( — address ) 

This variable contains the value of the the number of 
bytes per line for the current mode. 

CDDA 62 

( — address ) 

This variable contains the current value for the 
screen data pointer. 

CDLA 62 

( — address ) 

This variable contains the current value of display 

list pointer. 


CK/PX 86 

( — address ) 

This variable contains the value of color clocks per 
pixel for the current zoom mode. 

OMSK 10 

( — address ) 

This variable contains the pixel mask value for the 
current pixel number. 


178 


COLMSKTB 9 

( — address ) 

This variable and its following 9 bytes contains 
values of the color masks. 

COLORMSK 10 

( — address ) 

This variable contains the color mask value for 

current color. 

CURR-COLOR 10 

( — address ) 

This variable contains the current color number. 

CURR-MODE 10 

( — address ) 

This variable contains the current mode number. 

CURR-PFIG 78 

( — address ) 

This variable contains the address of a player 
data for the current player. 

CURR-PLAYER 78 

( — address ) 

This variable contains the current player number. 


the 


the 


shape 



179 


DADDR 52 
( — address ) 

This variable contains the starting destination 
address where a horizontal line is copied to or moved 
to. 


DBYTES 52 

( — address ) 

This variable contains the number of bytes the 

destination line should have. 

DDFLAG 62 

( — address ) 

This variable contains a flag that determines whether 
the screen data will be saved or not. 

DL-HERE 17 

( — address ) 

This variable contains the next address where a 

display list instruction will be put at. 

DLFLAG 62 

( — address ) 

This variable contains a flag that determines whether 
or not the display list will be saved. 


180 


DLPX 52 

( — address ) 

This variable contains the pixel number of the left 
most pixel of the destination horizontal line. 

DOWNTRIG 44 

( — address ) 

This variable contains a trigger value which controls 
the seeds qualification for runs below the current 
run. 

DRPX 52 

( — address ) 

This variable contains the pixel number of the right 
most pixel of the destination horizontal line. 

PDA 63 

( — address ) 

This variable contains a fixed address where the 
directory sectors will be read into. 

PIGPO 78 

( player# — address ) 

This array contains the addresses of the player shapes 
for the four players. 


181 


FILLFLG 38 

( — address ) 

This variable contains a flag which determines whether 
to draw a circle or a filled circle. 

FIXFLAG 86 

( — address ) 

This variable contains a flag which determines whether 
a zoom window needs to be fixed. 

PMSK 10 

( — address ) 

This variable contains both the left pixel fill mask 
and the right pixel fill mask for drawing a horizontal 
line. 

HLOWPO 78 

( player# — value ) 

This array contains the horizontal lower limits of the 
coordinates for the four players. 

HPSIZE 78 

This array contains the player sizes for the four 
players. 



182 


LFMSKTB 9 

( — address ) 

This variable and its following 14 bytes contain the 
left pixel fill mask values. 

NCOLORS 9 

( mode# — address ) 

This array contains the numbers for the colors 
corresponding to the 14 ANTIC modes. 

NEWCOL 10 

( — address ) 

This variable contains the X-coordinate of the second 
point when drawing a line, a box, etc. 

NEWROW 10 

( — address ) 

This variable contains the Y-coordinate of the second 
point when drawing a line, a box, etc. 

OLDCOL 10 

( — address ) 

This variable contains the X-coordinate of the current 


cursor position. 


183 


OLDCOLMSK 44 

( — address ) 

While filling a region this variable contains the 
color mask of the old color. 

OLDROW 10 

( — address ) 

This variable contains the Y-coordinate of the current 
cursor position. 


PADDR 78 

( — address ) 

This variable contains the address of the currently 
used player shape data. 

PDATAO 81 

( — address ) 

This variable and its following few bytes contain the 
data of a player shape. The first byte contains the 
length of that player shape data. The second and the 
third bytes contain the reference position for that 
player shape. The remaining bytes contain shape data. 



184 


PDATA1 80 
( — address ) 

This variable and its following few bytes contain the 
data of a player shape. The first byte contains the 
length of that player shape data. The second and the 
third bytes contain the reference position for that 
player shape. The remaining bytes contain shape data. 

PDDA 62 
( — address ) 

This variable contains the starting address for the 
part of screen data that has not yet been saved during 
the execution of SAVE-DATA. 

PDLA 62 
( — address ) 

This variable contains the starting address for the 
part of display list that has not yet been saved 
during the execution of SAVE-DATA. 

PFX 79 
( — address ) 

This variable contains the factor value for the X- 
coordinate while transforming the values read from the 
KoalaPad to screen coordinates. 



185 


PFY 79 
( — address ) 

This variable contains a factor value for 
Y-coordinate while transforming the values read 
the KoalaPad to screen coordinate. 


PHLOW 78 

( — address ) 

This variable contains the horizontal lower limit 
the current player. 

PMBASE 78 

( — address ) 

This variable contains the starting address of 
player-missile graphics base area. 


PMODE 


10 


( — address ) 

This variable contains the current graphics mode. 


PNL 78 

( — address ) 

This variable contains the player line size ( 1 
scan lines ). 


the 

from 


for 


the 


or 2 



186 


PSIZE 78 

( — address ) 

This variable contains the size of base area for the 
current player. 


PVLOW 78 

( — address ) 

This varible contains the vertical lower limit for the 
current player. 

PX/BY 8 

( mode# — value ) 

This array contains the number of pixels per byte for 
each of the ANTIC modes. 

PX/ML 8 

( mode# — value ) 

This array contains the number of pixels per mode line 
for each of the ANTIC modes. 

PXBY 10 

( — address ) 

This variable contains the number of pixels per byte 


for the current mode. 



187 


PXML 78 

( — address ) 

This variable contains the number of pixels per mode 
line for the current mode. 

PXMSKTB 9 

( — address ) 

This variable and its following 13 bytes contain pixel 
mask values for the different number of pixels per 
byte. 

RFMSKTB 9 

( — address ) 

This variable and its following 13 bytes contain the 
left pixel fill mask values for the different number 
of pixels per byte. 

RPXPO 78 

( player# — value ) 

This array contains the horizontal values for the 
reference positions of the player shapes for the four 
players. 



188 


RPYPO 78 

( player# — value ) 

This array contains the vertical values of the 
reference positions for the player shapes for the four 
players. 

SADDR 52 

( — address ) 

This variable contains the starting address of the 
source where a horizontal line is copyed or moved 
from. 


SDXA 52 

( — address ) 

This variable contains the number of bytes in the source 
horizontal line. 

SL/ML 8 

( mode# — value ) 

This array contains the number of scan lines per mode 
line for each of the 14 ANTIC modes. 

SLML 78 

( — address ) 

This variable contains the number of scan lines per 


mode line for the current mode. 


189 


STACK-BTM 44 

( — address ) 

This variable contains the address of the bottom of 
the user defined stack. 

TNEWCOL 10 

( — address ) 

This variable temporarily contains the X-coordinate of 
the second point during the execution of CLINE. 

TNEWROW 10 

( — address ) 

This variable temporarily contains the Y-coordinate of 
the second point during the execution of CLINE. 

TOLDCOL 10 

( — address ) 

This variable temporarily contains the X-coordinate of 
the first point during the execution of CLINE. 

TOLDROW 10 

( — address ) 

This variable temporarily contains the Y-coordinate of 
the first point during the execution of CLINE. 


TSDMCTL 


10 


( — address ) 

This variable temporarily contains the value of 
SDMCTL. 


TXO 10 

( — address ) 

This variable temporarily contains the X-offset value. 

TXMAX 10 

( — address ) 

This variable contains the largest X-boundary value 
for the terminal screen window. 

TXMIN 10 

( — address ) 

This variable contains the smallest X-boundary value 
for the terminal screen window. 

TYO 10 

( — address ) 

This variable temporarily contains the Y-offset value. 



191 


TXMAX 10 

( — address ) 

This variable contains the largest Y-boundary value 
for the terminal screen window. 

TYMIN 10 

( — address ) 

This variable contains the smallest Y-boundary value 
for the terminal screen window. 

UPTRIG 44 

( — address ) 

This variable contains a trigger value which controls 
the seeds qualification for the runs above the current 
run. 


YL 29 

( — address ) 

This variable contains a value that indicates whether 
the value of |X2-X1] is less than the value of 
|Y2-Y1 | ; if so, VL contains 1 . 

VLOWPO 78 

( player# -— value ) 

This array contains the vertical lower limits for the 
coordinates of the four players. 



VPOSPO 


78 


( player# — value ) 

This array contains the Y-coordinates of the current 
positions for the four players. 

WORKING 52 

( — address ) 

This variable contains the starting address Of a 
working area for moving or copying a horizontal line. 

XO 10 

( — address ) 

This variable contains the current X-offset value. 

XMAX 10 

( — address ) 

This variable contains the largest X-boundary value 
for the logical window. 

XMIN 10 

( — address ) 

This variable contains the smallest X-boundary value 
for the logical window. 


193 


XSIGN 29 

( — address ) 

This variable contains: 


-1, 

if 

X2 

is less than XI 

0 , 

if 

X2 

equals to XI 

1, 

if 

X2 

is greater than XI. 


It is set by DIRECTION. 

XYSIGN 29 

( — address ) 

This variable contains the vesulting from 
operation value XSIGN * YSIGN. 

YO 10 

( — address ) 

This variable contains the current Y-offset value 

YMAX 10 

( — address ) 

This variable contains the largest Y-boundary 
for the logical window. 

YMIN 10 

( — address ) 

This variable contains the smalleat Y-bounda.ry 
for the logical window. 


the 


value 


value 



194 


YSIGN 29 

( — address ) 

This variable contains: 


-1, 

if 

Y2 

is 

less than Y1 

0 , 

if 

Y2 

equals to 

Y1 

1, 

if 

Y2 

is 

greater 

than Y1 . 


It is set by DIRECTION. 


ZDL-ADDR 86 

( — address ) 

This variable contains the starting address of the 
display list for the current zoom mode. 


ZFLAG 86 
( — address ) 

This variable contains a flag value that indicates if 
the zoom mode is active or not. A value 1 means 
active. 


ZMLX 86 

( — address ) 

This variable contains the width in X-direction of the 


zoom window for the current zoom mode. 


195 


ZMLY 


86 


( — address ) 

This variable contains the width in Y-direction of the 
zoom window for the current zoom mode. 


ZMODE 86 

( — address ) 

This variable contains the current zoom mode. 


ZXO 86 

( — address ) 

This variable contains the X-coordinate of the upper 
left-hand corner for the current zoom window. 


ZXHIG 86 

( — address ) 

This variable contains the largest X-limit value that 
ZXO can be. 

ZXLOW 86 

( — address ) 

This variable contains the smallest X-limit value that 


ZXO can be 


1 96 


ZYO 86 

( — address ) 

This variable contains the Y-coordinate of the upper 
left-hand corner of the current zoom window. 

ZYHIG 86 

( — address ) 

This variable contains the largest Y-limit value that 
ZYO can be. 


ZYLOW 86 

( — address ) 

This variable contains the smallest Y-limit value that 


ZYO can be. 


197 


3. High-level and Low-level words for PIGS 

JZOOM-DLS 87 H 

( DL-addr screen-addr zoom-mode base-mode lines — ) 
This word creates a given number of mode lines in a 
display list starting at the given address. 

(=0LDC0L0R?) 45 L (ASM ONLY) 

( address — flag ) 

This word is an assembly language subroutine which is 
called by other low level code words to see if the 
pixel at the given address has the same value as that 
stored in the variable OLDCOLMSK; if so, the flag is 
set to true. 

(DELETE) 68 H 

( address flag — ) 

If the flag is true, this word deletes a file 
directory entry whose information is at the given 
address; otherwise, it displays the message: "Filename 


Not Pound!". 


1 98 

(GLOAD) 76 H 

( address flag — ) 

If the flag is true, this word reloads the screen data 
and/or the display list from a file whose directory 
information is at the given address. 

(GSAVE) 74 H 

( address flag — ) 

If the flag is true, this word saves the screen data 
and/or the display list in a file whose directory 
information is at the given address. 

(PRINT) 60 H 

( X Y — ) 

This word draws the text string, which is already in 
the dictionary, on the screen surface starting at the 
given X-Y coordinates. 

(STACK-PUSH) 46 L (ASM ONLY) 

( X Y — ) 

This word is an assembly language subroutine which is 
called by other low level words to push the given X-Y 
coordinates on top of the user defined stack. 


199 


+OFFSET 12 H 

( X Y — X-offset Y-offset ) 

This word adds the current offset values to the given 
X-Y coordinates. 


<FILL 49 H 

( X Y — address pixel# X Y ) 

This word scans each pixel of a run from the given 
starting point towards the left to find the left 
boundary position of that run and puts that address, 
the pixel number, and the X-Y coordinates of that left 
boundary position on top of the parameter stack. 

=0LDC0L0R? 45 L 

( address — flag ) 

This word determines if the pixel at the given address 
has the same color value as that stored in the 
variable OLDCOLMSK; if so, the flag is set to true. 

>CREG 13 H 

( color# — address ) 

This word converts the given color number to the 
address of the corresponding color register. 



200 


>INCODE 58 H 

( ATASCII-code — incode ) 

This word converts the given ATASCII-code to the 
Incode for the ATARI computer. 

>PXY 84 H 

( X Y — X-player Y-player ) 

This word transforms the given X-Y coordinates to 
player X-Y coordinates. 

>SCRXY 80 H 

( X-Pad Y-Pad — X Y ) 

This word transforms the given coordinates read from 
the KoalaPad Touch Tablet to screen X-Y coordinates. 

>TEMP 29 H 

( X-1 Y-1 X-2 Y-2 — ) 

This word stores the given two points in temporary 
variables with the X-Y coordinates exchanged when the 
value in the FORTH variable VL is 1 . 

>Z00MXY 88 H 

( X Y — X-zoom Y-zoom ) 

This word moves the zoom window by transforming the 
given X-Y coordinates to the zoomed X-Y coordinates. 


201 


ABOVE? 47 L 

( address X Y — ) 

This word examines the value in the pixel position 
above the given pixel position to see if this pixel 
position should be the starting point for a new run; 
if so, this pixel position is pushed on top of the 
stack. 

BCLEAR 43 H 

( X-1 Y-1 X-2 Y-2 — ) 

This word clears a retangular region determined by the 
given two opposite-corner positions by filling that 
region with the background color. 

BEGIN-DL 17 H 

( Dl-address — DL-address ) 

This word puts 3 bytes of 70H into memory, starting at 
the address that is on top of the parameter stack. 

BELOW? 48 L 

( address X Y -- ) 

This word examines the value in the pixel position 
below the given pixel position to see if this pixel 
position should be the starting point for a new run; 
if so, this pixel position is pushed on top of the 


stack. 


202 

BFILL 51 H 

( X Y — ) 

This command fills a connected region with the 
current color starting at the given starting point. 
If the pixel at the starting point already has the 
same value as the current color number, this command 
terminates immediately. 

BOUNDARY? 11 H 

( X Y — flag ) 

This commands checks whether a given pair of X-Y 
coordinates are within the logical window boundary. 

BOX 41 H 

( X-1 Y-1 X-2 Y-2 — ) 

This command draws a rectangular region determined by 
two opposite-corner points for that rectangular 
region. 

BRIGHTER 15 Ii 

( color# — ) 

This command increases the luminance value in the 
given color register by two so that the color becomes 
1 level brighter. 


203 

CHARACTER 59 H 

( X Y code — ) 

This command draws on the display starting at the 
given position the character whose shape is given by 
the corresponding code. 

CIRCLE 41 H 

( X Y radius — ) 

This command draws a circle with center at the given 
point with the given radius. 

CIRCLE-PILL 38 H 

( X Y - ) 

This command draws four horizontal line segments 
between some of the eight symmetric points. 

t 

CIRCLE-PTS 39 H 

( X Y — ) 

This command plots the eight symmetric points for the 
given point on the circle. 

CIRCLE-PUT 39 H 

( X Y — ) 

This command checks the value of the fill-flag 
(PILLPLG) to determine whether to call CIRCLE-FILL or 


CIRCLE-PTS. 


204 


CLEAR 43 H 

( — ) 

This command clears the whole screen. 

CLINE 37 H 

( X-coordinate-1 Y-coordinate-1 X-coordinate-2 

Y-coordinate-2 — ) 

This command is called by DRAWLINE to draw a line 
between the given two points. 

DARKER 13 H 

( color# — ) 

This command decreases the luminance value in the 
given color register by two so that the color becomes 
1 level darker. 

DELETE 69 H 

( - ) 

This command deletes the given filename from the file 
directory and reassigns the used data sectors to the 
free sector list. 


DIR 77 H 

( — ) 

This command lists the filenames for the files that 


exist on the files diskette. 


205 


DIR? 34 H 

( value-1 value-2 — direction ) 

This words compares the given two values. If the 
first value is smaller than the second value, then the 
value assigned to direction is -1; otherwise, the 
value assigned is 1 . 

DIRECTION 35 H 

( X-1 Y-1 X-2 Y-2 — X-direction Y-direction ) 

This command evaluates the direction values for a 
vector from the first point to the second point. 

DLI-OFF 61 H 

( — ) 

This command disables the display list interrupt 
routine. 

DLI-ON 61 H 

( — ) 

This command enables the display list interrupt 
routine. 

DOUBLE-LINE 82 H 

( — ) 

This command sets the player line size option to 


double-line. 



206 


DOUBLE-SIZE 81 H 

( player# — ) 

This command sets the player size to double-size ( 8 
color clock width ). 

\ 

DRAWCIRCLE 40 H 

( X Y radius — ) 

This command calculates the coordinates of the points 
on a circle and determined by the value of the fill- 
flag (FILLFLG) calls CIRCLE-PUT to either draw a 
circle or draw a filled circle. 

DRAWLINE 37 H 

( - ) 

This command draws a line between two points which are 
maintained in the FORTH variables OLDCOL, OLDROW, 
NEWCOL, and NEWROW. 

DRAWTO 38 H 

(X Y — ) 


This command draws a line from the current cursor 
position to the given point. 



207 


END-DL 17 H 

( address — ) 

This command concludes the display list with a jump 
instruction that jumps to the given display list 
address. 

FBOX 43 H 

( X-1 Y-1 X-2 Y-2 — ) 

This command draws a filled rectangular region 
determined by the two given opposite-corner points for 
that retangular region. 

FCIRCLE 41 H 

( X Y radius — ) 

This command draws a filled circle centered at the 
given point with the given radius. 

FILBOX 42 H 

( — ) 

This command draws a filled rectangular region 
determined by two opposite-corner points which are 
maintained in the FORTH variables OLDCOL, OLDROW, 


NEWCOL, and NEWROW. 



208 


FILL> 50 H 

( address pixel# X Y — ) 

This word is called by BFILL. It fills the current 
run with the current color and checks the rows above 
and below the current run to determine whether some 
more runs are required. If more runs are required, 
FILL> puts the seeds of these runs on the stack. 

FIND-FD 67 H 

( address-1 — address-2 flag ) 

This command attempts to find the address of the 
directory entry with the filename that is kept at the 
given address; if the filename is found, its address 
along with a flag with value 1 are returned; 
otherwise, only a flag with value 0 is returned. 

FIND-FN 67 H 

( — address flag ) 

This command obtains a filename from the current input 
stream and calls FIND-FD to find the address of a 
directory entry with that name. 

FIND-EMPTY 68 H 

( — address flag ) 

This command determines an entry for a new directory 


item. 



209 


FLUSHDL 87 H 

( address pixel# — ) 

This command moves the zoom window to a location 
determined by the given point. This is done by 
changing the load memory address for each mode line in 
the display list and applying fine scrolling. 

FORMAT 65 H 

( — ) 

This command formats a disk with the format necessary 
for this simple disk file management system. 


FORMAT-FDD 65 

( — ) 

This word is called 
appropriate sectors for 

FORMAT-FDS 65 

( - ) 

This word is called 
appropriate sectors for 

FORMAT-MFD 64 


H 

by FORMAT to format the 

a directory. 

H 

by FORMAT to format the 

the free sector list. 

H 


( - ) 

This word is called by FORMAT to format the sector for 
the master directory. 



210 


GET-MFD 64 H 

( - ) 

This command reads the master directory sector into 
memory. 

GETCOLMSK 12 H 

( color# — mask-value ) 

This command gets the corresponding mask-value for the 
given color from the color mask table. 


GLOAD 

76 

H 



( — ) 





This command 

reloads 

the screen 

data 

and/or the 

display list 

from the 

given file. 

The 

filename is 

obtained from 

the input 

stream. 



GSAVE 

74 

H 



( - ) 





This command saves the 

display list 

and/or the screen 

data as a file 

on disk. 

The filename is 

obtained from 


the input stream. 

HCALINC 29 H 

( — incl inc2 diffence end begin ) 

This command calculates the incremental values for 


HDRAWPTS. 


21 1 

HCLIP 35 H 

( X-1 Y-1 X-2 Y-2 — X-1-clipped Y-1 X-2-clipped 

Y-2 ) 

This command clips the X-coordinates for the given two 
points. 

HDRAW 33 L 

( address bytes — ) 

This word draws a horizontal line starting at the 
given address with the length determined by the proper 
number of pixels within the bytes. 

HDRAWPTS 30 H 

( incl inc2 diffence end begin — ) 

This word applys Bresenham's Line Algorithm to draw a 
line by using the incremental values. 

HLINE 36 H 

( x-1 Y-1 X-2 Y-2 — ) 

This word draws a horizontal line between the two 


given points. 



HPOS 42 H 

( X-1 Y-1 X-2 Y-2 — address bytes ) 

This word converts the coordinates for the two given 
points to a starting address and the proper number of 
pixels within the bytes between them. It also sets 
the masks for the two end bytes. 

INCADR 32 L (ASM ONLY) 

( - ) 

This word is an assembly language routine which is 
called by HDRAW to increment or decrement, determined 
by the value in FORTH variable XSIGN, the address in 
the FORTH variable OLDADR. 

LINE 38 H 

( X-1 Y-1 X-2 Y-2 — ) 

This command draws a line between the given two 
points. 

LMOST 54 L 

( working-addr left-byte-addr — ) 

This word copies some pixels from the left-most byte 
of the source line to the corresponding byte in the 
working area. 



213 


LMOVE 55 H 

( - ) 

This word copies a horizontal line from the source 
retangular region to the destination. 

LOAD-DATA 76 H 

( - ) 

This word reloads the screen data and/or display list 
from the data sectors of a file. 

LOAD-ENV 73 H 

( — ) 

This word reloads the saved environment information 
from a file. 

LOCATE 27 H 

( X Y — ) 

This command moves the cursor position to the given 
position. 

LSHIPT 52 L 

( address bytes bits — ) 

This word shifts the bits of some contiguous bytes at 
the given address by the a given number of bits. 


214 


LUMINACE+! 13 H 

( color# increment — ) 

This word adjusts the luminance value of the given 
color by the given incremental value. 

MATCH? 66 H 

( address-1 address-2 — flag ) 

This word compares two character strings starting at 
the two given addresses; if the two strings are 
identical, a flag with value 1 is returned. 

MODE-LINE 17 H 

( address mode# lines — ) 

This word creates a part of a display list with the 
given number of lines with the given mode number and 
with a load memory scan option. 

MODEO 18 H 

( — ) 

This command switches the present graphics mode to 
graphics mode 0. 

M0DE1 19 H 

( — ) 

This command switches the present graphics mode to 
graphics mode 1 . 



215 


M0DE2 20 H 

( — ) 

This command switches the present graphics mode to 

graphics mode 2. 

M0DE3 21 H 

( — ) 

This command switches the present graphics mode to 

graphics mode 3* 

M0DE4 22 H 

( - ) 

This command switches the present graphics mode to 

graphics mode 4. 


M0DE5 


23 


H 


This command switches the present graphics mode to 
graphics mode 5* 



This command switches the present graphics mode to 
graphics mode 6. 



M0DE7 25 H 

( - ) 

This command switches the present graphics mode to 
graphics mode 7. 

M0DE8 26 H 

( ~ ) 

This command switches the present graphics mode to 
graphics mode 8. 

OFFSET! 12 H 

( X-value Y-value — ) 

This command stores new offset values in the FORTH 
variables XO and YO. 

0FFSET>T 12 H 

( — ) 

This command temporarily saves the current offset 
values. 

OFFSET® 12 H 

( — X-value Y-value ) 

This command puts the current offset values on top of 
the parameter stack. 


217 

OUTCODE 34 H 

( X Y — outcode ) 

This command evaluates the outcode value for the given 
point by comparing that point with the logical screen 
boundaries• 


PADXY 79 L 

( — X Y ) 

This command reads the X-Y coordinates of the stylus 
and puts them on top of the parameter stack. 

PLAYER-CLEAR 82 H 

( - ) 

This command clears the player shape data for the 
current player. 

PLAYER-OPP 82 H 

( ~ ) 

This command turns off the player features. 

PLAYER-ON 82 H 

( - ) 


This command turns on the player features. 


218 


PLOT 28 H 

( X Y — ) 

This command plots the given point on the display. 

POSITION 27 H 

( X Y — address pixel#) 

This command transforms the given X-Y coordinates to a 
memory address and a pixel number. 

PREPARE 56 H 

( X-1-source Y-1-source X-2-source Y-2-source X-dest 

Y-dest — Y-dest-end Y-dest-begin ) 
This word calculates required data for LMOVE and puts 
it in the corresponding FORTH variables. 

PRINT 59 H 

( X Y address length — ) 

This word draws starting at the given position a text 

string that is located at the given address. 

PUT-FDD 64 H 


( - ) 

This command writes a directory sector to the disk 


219 


PUT-FDS 64 H 

( - ) 

This command writes a data sector to the disk. 

PUT-MFD 64 H 

( ~ ) 

This command writes the master directory sector to the 
disk. 


PX! 31 L (ASM ONLY) 

( - ) 

This word is an of assembly language routine which is 
called by the low-level word HDRAW to put a pixel 
value in the screen RAM. 

PXPUT • 28 L 

( address — ) 

This word puts a pixel value at the given address. 

QUAD-SIZE 81 H 

( player# — ) 

This command sets the player size to quadruple-size 
(32 color clock width). 


220 


RCOPY 57 H 

( X-1-source Y-1-source X-2-source Y-2-source 

X-dest Y-dest — ) 

This command copies the contents of a rectangular 
region to another place within the same screen. The 
contents of the source region remain unchanged after 
the execution of this command. 

READ 64 H 

( address sector# — ) 

This command reads the contents of the given sector 
into memory starting at the given address. 

READPX 44 H 

( X Y — pixel-value ) 

This command reads the pixel value for the given 
point. 

RELEASE 66 H 

( - ) 

This command reassigns a used sector to the free 
sector list of the disk file management system. 



221 


REQUEST 69 H 

( — ) 

This command requests a sector from the free sector 
list of the disk file management system. 

RESETVBD 61 L 

( ~ ) 

This command resets the vertical blank interrupt delay 
phase (VBD) entry vector to its default value. 

RESORT 27 L 

( X-1 Y-1 X-2 Y-2 — X-upper-left Y-upper-left 

X-bottom-right Y-bottom-right ) 

This command rearranges the given coordinates so that 
the first pair become the coordinates of the upper 
left-hand point and the second pair become the 
coordinates of the bottom right-hand point. 

RMOST 54 L 

( — ) 

This word copies the appropriate pixels that are in 
the right most byte of the source line to the 
corresponding byte in the working area. 



222 


RMOVE 57 H 

( X-1-source Y-1-source X-2-source Y-2-source 

X-dest Y-dest — ) 

This command copies the contents of a retangular 
region to another location within the same screen and 
fills the source rectangular region with the 
background color. 

RSHIPT 53 L 

( address bytes bits — ) 

This word shifts to the right a given number of bits 
all the bits within a contiguous area of bytes 
starting at the given address. 

SAVE-ALL 75 H 

( - ) 

If the filename is unique, this command saves both the 
screen data and display list in that file. 

SAVE-DD 75 H 

( - )_ 

If the filename is unique, this command saves the 
screen data in that file. 



223 


SAVE-DL 75 H 

( - ) 

If the filename is unique, this command saves the 
display list in that file. 

SCR-LOCATE 13 H 

( X-coordinate Y-coordinate — ) 

This command sets the graphics screen cursor position 
to the point with the given X-Y coordinates. 

SCREEN-OFF 1 1 H 

( — ) 

This command turns off ANTIC by storing 0 in SDMCTL 
(location 22FH). It also saves the old value from 
this control register in a temporary location for 
possible restoring by the SCREEN-ON command. 

SCREEN-ON 1 1 H 

( — ) 

This command turns on ANTIC and restores the DMA 
functions that had been previously working before the 
SCREEN-OFF command turned them off. 



224 


SET-DEFAULTS 16 H 

( — ) 

This word sets the default values for the graphics 
mode environment. 

SETBYLU 44 H 

( — ) 

This word sets the FORTH variable BYLN to the number 
of bytes needed for a mode line in the current mode. 

SETCMSK 27 H 

( pixel# — ) 

This word gets a pixel mask' for the given pixel number 
from the pixel mask table (PXMSKTB) and stores it in 
the FORTH variable OMSK. 

SETDLIV 61 H 

( address — ) 

This command stores the given address in the display 
list interrupt handler vector which is maintained at 
location 200H. 

SETMSK 31 L 

( pixel#1 pixel#2 — ) 

This word sets the pixel masks for the two end bytes 
of a horizontal line. 



225 


SETPF 80 H 

( - ) 

This word calculates the two pad-screen transformation 
factors for the current mode and stores them in the 
FORTH variables PFX and PFY. 

SETPFIG 85 H 

( address X-reference Y-reference player# — ) 

This command sets the address where a piece of player 
shape data is kept and sets the reference position for 
the player shape for the given player. 

SETPLAYERS 83 H 

( - ) 

This command sets the default values for the player 
graphics environment. 

SETPLINE 81 H 

( code lines length address — ) 

This word is called by SINGLE-LINE and DOUBLE-LINE to 
set the required data for them. 

SETPSIZE 81 H 

( player# code — ) 

This word sets the given code of specific player size 
for the given player. 



226 


SETSTACK 45 H 

( address — ) 

This command creates a stack with its bottom at the 
given address. 

SETBVD 61 L 

( address — ) 

This command sets the vertical blank interrupt delay 
phase (VBD) entry vector to the given address. 

SINGLE-LINE 82 H 

( - ) 

This command sets the player line size option to 
single-line (one scan line). 

SINGLE-SIZE 81 H 

( player# — ) 

This command sets the player size for the given player 
to single-size (8 color clock width). 

STACK-EMPTY? 46 H 

( — flag ) 

This command checks whether the user defined stack is 
empty; if so, the returned flag value is 1. 



227 


STACK-POP 46 H 

( — value-1 value-2 ) 

This command pops the top two elements of the user 
defined stack and leaves them on top of the parameter 
stack. 

STACK-PUSH 47 L 

( value-1 value-2 — ) 

This command pushes the two given values on top of the 
user defined stack. 

STORE-DATA 71 H 

( address — ) 

Depending on the value of DDPLAG and DLFLAG, this word 
is called by (GSAVE) to save a display list and/or 
screen data in a disk file. 

STORE-DD 70 H 

( - ) 

This word stores part of the screen data in a disk 
file. 

STORE-DL 70 H 

( - ) 

This word stores part of the display list in a disk 
file. 



228 


STORE-ENV 73 H 

( — ) 

This word stores the the graphics mode environment. 

STRING" 60 H 

( X Y — ) 

This word is an immediate word. At compile time, it 
compiles (PRINT) and the string from the input stream 
into the dictionary. At execution-time, it executes 
(PRINT) to draw the compiled string on the display. 

T>0FFSET 12 H 

( — ) 

This command restores the current offset values to the 
values previously saved in TXO and TYO. 

TEXT 60 H 

( X-coordinate Y-coordinate — ) 

This command draws a text string, entered 
interactively by user, on the display starting at the 
given point. 


Ttf>W 11 H 

( — ) 

This command restores the current logical window 
boundaries to the current terminal screen boundaries. 



229 


TWINDOW 11 H 

( X-min Y-min X-max Y-max — ) 

This command sets the current logical screen 

boundaries to the given values. 

TXT-LOCATE 13 H 

( X Y — ) 

This command sets the text window cursor position to 
the given X-Y coordinates. 

USECOLOR 12 H 

( color# — ) 

This command sets the current color number to the 
given color number. 

USEPLAYER 84 H 

( player# — ) 

This command sets the current player to the given 
player. 

VCLIP 36 H 

( XI Y-1 X-2 Y-2 — X-1 Y-1-clipped X-2 Y-2-clipped ) 
This command clips the Y-coordinates for the given two 
points. 



230 


VDRAW 32 L 

( length bytes/line — ) 

This word draws a vertical line with the given length 
starting at the address kept in OLDADR. 

VLINE 36 H 

( X-1 Y-1 X-2 Y-2 — ) 

This word draws a vertical line between the two given 
points. 

WCLEAR 43 H 

( — ) 

This command fills the whole logical window with the 
background color. 

WINDOW 1 1 H 

( X-min Y-min X-max Y-max — ) 

This command sets the current logical window 
boundaries to the given values. 

WRITE 64 H 

( address sector# — ) 

This command writes the block of data at the given 
address to the given disk sector. 



23 1 


WTCRS 28 H 

( - ) 

This command puts a pixel value on the display at the 
position kept in the FORTH variables OLDCOL and 

OLDROW. 

XCLIP 35 H 

( X-coordinate — clipped-X ) 

This command clips the given X-coordinate to the 
logical boundaries. 

YCLIP 35 H 

( Y — clipped-y ) 

This command clips the given Y-coordinate to the 

logical boundaries. 

< 

ZPLAYER 88 H 

( X Y — ) 

This command displays, depending on the value of the 
zoom flag (ZFLAG), a player either on a zoom mode 


screen or on a normal screen at the given position. 



APPENDIX E: 


SOURCE LISTING FOR FIGS 



3 \BlJiLUS 1+ ALLliT DOES > + 

3 t SARRAY i N L_h.N — ) 

6 <BUILDS DUP C, SWAP 1+ * ALLOT 

7 DOES> DUP C© >R SWAP R *• + 1+ R> 

S ; 

9 : SARRAYi ( ADDRi ADDR2 LEN — ) 

10 2DUP BL FILL >R SWAP COUNT ROT SWAP R> MIN CMOVE 

i 1 ; 

12 : 3ARRAY? < ADDR LEN — ) 

13 TYPE 

14 ; 

OR #4 

0 ( GRAPHICS — PREDEFINED TOOLS ) 

1 : NOT 0— , < F — NOT—F ) 

2 ; U> SWAP U< ; < N1 N2 — F ) 


4 CuDE d ( — J ) 


CT 

t-J 

XSAVE 

SIX, 

TSX, 105 

,x 

LDA, PHA, 

6 

106 , X 

LDA, 

XSAVE LD 

X, 

PUSH JMP, 

7 






8 

CODE CE¬ 

< 

— X Y ) 



7 

DE X , 

DEX, 

DEX, DEX 

5 

PLA, 2 ,X STA 

to 

PLA, 

3 ,X 

b i A , PLA 

5 

0 ,X STA, PLA 

-» ^ 

A 1 

1 ,X 

STA, 

F‘HA , 0 , 

X 

LDA, PHA, 

12 

3 , X 

LDA, 

PHA, 2 , 

V 

A 

LDA, PHA, 

i “r 

NEXT 

-J HP, 





14 FORTH 


hL'R #U 

0 ( GRAPHICS — RECORD 3/27/85 ) 

1 ; RECORD ( ADDR — > 

2 VARIABLE O , O LATEST PFA 

^ 5 

4:7. < COUNT PFA — COUNT PFA ) 

5 <BUILDS DUP , OVER , 

6 DOES > DUP <£ @ SWAP 2 + & + 

7 i 

8 : BYTES ROT + SWAP ; ( COUNT PFA N — CQUNT+N PFA 

9 : END-RECORD 2 + ! ; ( COUNT PFA — ) 

10 : LEN' C — LENGTH ) 

11 -FIND 

12 IF DROP 2 + @ 

13 ELSE . " UNDEFINED RECORD NAME M 

14 END IF 


SCR #6 

0 ( SYSTEM CONSTANTS ) 

1 VOCABULARY GRAPHICS GRAPHICS DEFINITIONS 


2 HEX 

3 52 CONSTANT LMGN 

4 54 CONSTANT ROW-SCR 

5 57 CONSTANT SCR-MQDE 

6 5D CONSTANT QLDCHR 

7 2C0 CONSTANT PCOLRO 
S 22F CONSTANT SDMCTL 
9 290 CONSTANT ROW-TXT 

10 293 CONSTANT TXT-MODE 

11 2BF CONSTANT 

4 -“V 
1 ud 

14 
1 


53 CONSTANT RMGN 
55 CONSTANT CQL-SCR 
58 CONSTANT SCR-MEMORY 
5E CONSTANT OLDADR 
2C4 CONSTANT COLOR 
230 CONSTANT SDLSTL 
291 CONSTANT COL-TXT 
294 CONSTANT TXT—MEMORY 


SCROLL-LINES 



0 < 


GRAPHIC 


REGISTERS ) 


1 O CONSTANT BLACK 10 CONSTANT RUST 

2 20 CONSTANT RED—ORANGE 30 CONSTANT DARK-ORANGE 

3 40 CONSTANT RED 50 CONSTANT DARK-LAVENDER 

4 60 CONSTANT COBALT-BLUE 70 CONSTANT ULTRAMARINE-BLU 

5 -30 CONSTANT MEDIUM-BLUE 90 CONSTANT DARK-BLUE 

6 AO CONSTANT BLUE-GREY BO CONSTANT OLIVE-GREEN 

7 CO CONSTANT MEDIUM-GREEN DO CONSTANT DARK-GREEN 

o EO L-UNb- 1 AN I CHANGE—GKLEN FO CONS 1 ANT OHANUh. 

9 2C3 CONSTANT BORDER 2CS CONSTANT BACKGROUND 

10 2C8 CONSTANT COLORO 2C4 CONSTANT COLOR1 

11 2C5 CONSTANT CQL0R2 2C6 CONSTANT COLORS 

13 

14 

15 —> 

3Ch: #8 

0 < GRAPHIC — CQNT. #2 ) 


1 

2 F CARRAY SL/ML -E ALLOT 


3 


DAOS , 100U , 

1008 , 0408 , 0204 

1 

0201 

, 0101 


p 

CARRAY BY/LN 

-E ALLOT 




U 


a 2U^iH 

1414 ? OAOA , 1414 

9 

2814 

, 2828 

/ 

o 

F 

ARRAY FX/ML - 

1C ALLOT 




~7 

/ 


? 23 , 28 

, 28 , 14 , 14 , 28 

9 

Sn 

9 

50 , 

8 


AO , AO , AO 

, AO , 140 , 




9 

rr 

CARRAY PX/BY 

-E ALLOT 




10 


0101 , 0101 , 

0101 , 0804 , 0804 

9 

0408 

, 0804 

11 

F 

CARRAY BI/PX 

-E ALLOT 




12 


OSOS , 0808 , 

0808 , 0102 , 0102 

9 

0201 

, 0102 


13 F CARRAY NCGLORS -E ALLOT 



SCR #9 

0 < GRAPHICS — TABLES CONT, 



0 

VARIABLE PXMSKTB 

_ n 

ALLOT 









-3 


FF C, F0 C, OF 

c, 

CO C, 

30 

C, 

oc 

C, 

Uvf 

C, 

SO 

C, 

4 


•40 C, 20 C, 10 

c, 

08 C, 

04 

C, 

02 

C, 

01 

C, 



5 

0 

VARIABLE COLMSKTB - 

2 ALLO' 

r 








i 

o 


00 C, FF C, OO 

L 9 

55 C, 

AA 

p 

FF 

c. 

FF 

e, 

FF 

c. 

—r 

/ 


FF C, FF C, 











0 

0 

VARIABLE LFMSKTB 

-“2 

ALLOT 









9 


FF C, FO C, FF 

C, 

CO C, 

FO 

C, 

FC 

c. 

FF 

c. 

SO 

C, 

10 


CO C, EO C, FO 

c. 

F8 C, 

FC 

C, 

FE 

L ? 

hF 

c. 



11 

0 

VARIABLE RFMSKTB 

X- 

ALLOT 









12 


FF L, FF L, OF 

C, 

FF C, 

3F 

C, 

OF 

C, 

03 

C, 

FF 

c, 

13 


7F C, 3F C, IF 

C, 

OF C, 

07 

C, 

03 

C, 

01 

r 

w ? 




14 

15 —> 

SCR #10 


0 

( 

GRAPHICS 

— VARIABLE 

3 ) 


1 

0 

VARIABLE 

OLDCOL 

0 

VARIABLE 

QLDROW 

n 

X. 

o 

VARIABLE 

NEWCOL 

0 

VARIABLE 

NEWRQW 


0 

VARIABLE 

TOLDCOL 

0 

VARIABLE 

TOLDROW 

4 

0 

VARIABLE 

TNEWCOL 

0 

VARIABLE 

TNEWROW 


0 

VARIABLE 

XMIN 

0 

VARIABLE 

YMIN 

6 

0 

VARIABLE 

xhax 

0 

VARIABLE 

YMAX 

7 

0 

VARIABLE 

TXMIN 

0 

VARIABLE 

TYMIN 

8 

Q 

VARIABLE 

TXHAX 

Q 

VARIABLE 

TYMAX 

9 

0 

V ARIABLE 

xo 

0 

VARIABLE 

YO 

0 

0 

VARIABLE 

TXO 

0 

VARIABLE 

TYO 

1 

0 

VARIABLE 

CliSK 

0 

VARIABLE 

FMSK 

7 

0 

VAR I ABLb. 

PXBY 

0 

VARIABLE 

CQLORMS! 

3 

0 

VARIABLE 

CURR-MO 

DE C 

f VARIABL 

E CURR-C 

■*+ 

0 

VAKIAbLh 

TSBMCTL 

c 

t VARIABL 

E RHODE 



:37 


SCR #11 

0 ( GRAPHICS — BASIC WORDS > 

1 

2 : SCREEN—OFF SDMCTL CS TSDMCTL C! O 3DMCTL C! ; < — ) 

3 : SCREEN-ON TSDMCTL C@ SDMCTL C! ; ( — ) 

4 : WINDOW < XMIN YMIN XMAX YMAX — > 

5 YMAX ! XMAX ! YMIN I XMIN ! ; 

6 : TWINDGW < TXMIN TYMIN TXMAX TYMAX — ) 

7 TYMAX ! TXMAX I TYMIN ! TXMIN ! ; 

S : TW>W ( — > 

9 TXMIN & TYMIN @ TXMAX @ TYMAX S WINDOW ; 

10 : BOUNDARY? < X Y — F ) 

11 DUP YMIN 'I < SWAP YMAX @ > OR SWAP 

12 DUP XMIN & < SWAP XMAX & > OR OR NOT 

13 ; 

14 

1 5 — > 


SCR #12 

0 i. idRAh'HICS —— BASIU WUKDS ) 

1 

2 ; OFFSET! YO i XO ! ; ( XO YO — ) 

3 : -OFFSET < X Y — X+XO Y+YO ) 

4 YO S + SWAP XO @ + SWAP 

5 ; 

£> : OFFSETS XO & Yo S ; \ — XO Yu ) 

7 i OFFSET>T OFFSETS TYO ! TXO ! ; ( — ) 

8 : T>OFFSET TXO S TYO @ OFFSET! ; ( — ) 

9 : GETCOLMSK ( COLOR# — COLMSK ) 

10 CURR—MODE C@ NCui_ORS C@ JJUk 

11 IF 2 - ENDIF + C0LM3KTB + CS ; 

12 : USECOLOR ( COLOR# — ) 

13 DUP CURR-COLOR C! GETCOLMSK COLQRMSK C! ; 

14 


15 




233 


SCR #13 

0 < GRAPHICS — DEMO ) 

1 

2 : >CREG ( C# — REG# ) 

3 DLSP 0= IF DROP 2C3 ELSE 2C3 + END IF ; 

4 i LUMINACE+! ( C# N — > 

5 >R >CREG DUP CS DUP R> + OF AND 

6 SNAP FO AND OR SWAP C! 

7 ; 

3 : DARKER -2 LUMINACE+I ; < C# — ) 

9 : BRIGHTER 2 LUMINACE+! ; < C# — ) 

10 2 I XT—LOCATE 

11 : SCR—LOCATE 

12 

13 

14 10 LOAD 

15 

SCR 
0 


4 

nr 

6 

—r 

/ 

i—r 

o 

9 

10 

11 


#14 

( ERROR MESSAGES fig—FORTH ) 

Stack empty 

Dictionary tul1 

Wrong address mode 

Isn't unique 

Value error 

Disk address error 

Stack -full 

Disk Error! 

All s well 


ROW—TXT C? COL—TXT ! 
ROW—SCR C! CQL-SCR ! 


X Y — ) 

X ¥ — ) 


14 

1 er 



239 


SCR #15 

0 < ERROR MESSAGES tig—FORTH ) 

1 Use only in Definitions 

2 Execution only 

3 Conditionals not paired 

4 Definition not finished 

5 In protected dictionary 

6 Use only when loading 

7 Off current screen 

S VOCABULARY 

9 Nothing is wrong at all 
10 
11 
12 

13 

14 

SCR #16 

GRAPHICS — SET-DEFAULTS ) 

SET-DEFAULTS ( — ) 

23 2C4 C! CA 2C5 C! 94 2C6 C! 

46 2C7 C! 0 2CS Cl 0 0 OFFSET! 

0 ROW—SCR C! 0 COL—SCR C! 

0 ROW—TXT Ci 0 COL—TXT C! 

1 USECOLOR 4 SCROLL-LINES C! 

0 TXT-MODE C! BF60 TXT-MEMORY ! 
CURR-MODE CQ DUP PX/BY C@ PXBY C 


0 < 

1 

o = 


6 


6 

9 

10 ; 


! RHODE C! 


15 



240 


SCR #17 

0 ( GRAPHICS — MODE-LINE ) 

1 0 VARIABLE DL-HERE 

2 : MODE-LINE ( SM-ADDR MODE-NO MODE-LINES — ) 

3 OVER 40 + DL-HERE © Ci 

4 ROT DL-HERE © 1+ ! 

5 1 - SWAP OVER DL-HERE © 

6 3 + BLIP ROT + DL-HERE ! 

7 ROT ROT OVER IF FILL ELSE 2DR0P DROP ENDIF 

a ; 

9 : BE8IN-DL ( DL-ADDR — DL-ADDR ) 

10 DUP'DUP 3 70 FILL 3 + DL-HERE ! 

11 ; 

12 ; ENB-DL < DL-ADDR — ) 

13 DL-HERE © 41 OVER Ci 1+ ! 

14 ; 

1 'Zi — > 


SCR #18 

0 ( GRAPHICS — MODEO ) 


10 


MODEO ( — ) 

BC20 BEGIN—DL 

BC40 2 IS MODE-LINE 

END-DL 2 CURR-MODE C? 

SET-DEFAULTS 18 SCROLL-LINES Ci 
BC40 3C0 O FILL 0 0 27 13 TWINDOW 
0 SCR-MODE Ci BC40 SCR-MEMORV i 
BC40 TXT-MEMORY i TW>W 
SCREEN-OFF BC20 SDLSTL i SCREEN-ON 


14 

i =: 



SCk #iv 


241 


0 < GRAPHICS — MODE1 ) 


JL 


4 

5 

6 

—f 

/ 

8 

7 

10 

11 


12 

13 

14 

15 


: MODE! 1 — ) 

BD5E BEGIN-DL 

BDSO h 14 MODE—LINE BF60 2 4 MODE-LINE 
END-DL 6 CURE-MODE C! SET-DEFAULTS 
1 SCR-MODE C! BDSO SCR—MEMORY I 
BDSO 280 0 FILL 0 0 13 13 TWINDOW 
TW >W SCREEN-OFF BD5E SDLSTL I SCREEN-ON 


SCR #20 

0 ( GRAPHICS — M0DE2 ) 

1 

2 : M0DE2 ( — ) 

3 BESS BEGIN-DL 

4 BE70 7 A MODE-LINE BF60 2 4 MODE-LINE 

5 END-DL 7 CURE-MODE C! SET-DEFAULTS 

6 2 SCR-MODE C! BE70 SCE-MEMORY ! 

7 BE70 190 O FILL O 0 13 9 TWINDOW TW>W 

8 SCREEN-OFF BESS SDLSTL ! SCREEN-ON 

9 I 
10 


14 

15 



242 


SCR #21 

0 < GRAPHICS — MGDE3 ) 

1 

2 : M0DE3 < — ) 

3 BE4E BEGIN-DL 

4 BE70 3 14 MODE-LINE BF60 2 4 MODE-LINE 

5 END-BL 3 CURR-MODE C! SET-DEFAULTS 

6 3 SCR-MODE C? BE70 SCR—MEMORY ! 

7 8E70 190 0 FILL O O 27 13 TWINDGW TW>W 

S SCREEN-OFF BE4E SDLSTL I SCREEN-ON 

9 5 
10 


14 —> 

15 


SCR #22 

0 < GRAPHICS — M0DE4 ) 

1 

2 ; M0DE4 ( — ) 

3 BD4A BEGIN-DL 

4 BD-30 9 20 MODE-LINE BF60 2 4 MODE-LINE 

5 END-DL 9 CURR-MODE Cl SET-DEFAULTS 

6 4 SCR-MODE Cl BDSO SCR-MEMORY ! 

7 BDSO 230 O FILL O O 4F 27 TWINDOW TW>W 

3 SCREEN-OFF BD4A 230 ! SCREEN-ON 


10 


1 Zj 



MODES ) 


24 


SCR #23 

0 ( GRAPHICS — 


2 : MODES < — ) 

3 BB6A BEGIN-DL 

4 BBAO A 23 MODE-LINE BF60 2 4 MODE-LINE 

5 END-DL A CURR-MODE C! SET-DEFAULTS 

6 5 SCR-MODE Cl BBAO SCR-MEMQRY I 

7 BBAO 460 O FILL 0 0 4F 27 TWINDON TUJ>W 

S SCREEN-OFF BB6A SDLSTL ! SCREEN-ON 

9 ; 

10 

11 —> 

■i —i 

J. jL 

13 

14 


SCR #24 

O < GRAPHICS — MODES ) 

-t 

i. * 

2 : MODES ( — ) 

3 B782 BEGIN-DL 

4 B7E0 B 50 MODE-LINE BF60 2 4 MODE-LINE 

5 END-DL B CURR-MODE Cl SET-DEFAULTS 

6 6 SCR-MODE CI B7E0 SCR-MEMORY ! 

7 B7E0 320 0 FILL O O 9F 4F TWINDOW TW>W 

3 SCREEN—OFF B732 SDLSTL I SCRth.N—UN 

q . 

-I 

A *_> 

H -> 


1 J1 



244 


SCK #2tj 

0 < GRAPHICS — M0DE7 ) 

1 

2 5 MGDE7 i — > 

3 AFA2 BESIN-DL 

4 BO60 0 50 MODE—LINE BF60 2 4 MODE-LINE 

5 END-DL D CURR—MODE C! SET-DEFAULTS 

6 7 SCR—MODE C! B060 SCR—MEMORY ! 

7 B060 FAO O FILL 0 O 9F 4F TNINOON TW>W 

8 SCREEN-OFF AFA2 SDLSTL ! SCREEN-ON 

9 ; 

10 


14 


SCR #26 

0 < GRAPHICS — MODES ) 

1 

2 : MODES i — ) 

3 A050 BEGIN—DL 

4 A150 F 5D MODE-LINE BOOO F 42 MODE-LINE 

5 BF60 2 4 MODE-LINE 

6 END-DL F CURR-MODE Ci SET-DEFAULTS 

7 S SCR—MODE C! A150 SCR-MEMORY ! 

3 A150 1EBO 0 FILL 0 O 13F 9F TWINDOW 

9 TW>W SCREEN-OFF A050 SDLSTL ! SCREEN-ON 

10 : 

11 —> 

12 



24 ; 


SCR #27 

0 ( GRAPHICS — LOCATE ) 

1 : LOCATE OLDROW ! OLDCOL ! ; < X Y — ) 

2 : READXY OLDCOL © OLDROW © ; ( — X Y ) 

3 ; RESORT < XI Y1 X2 Y3 — SLX SLY SRX SRY ) 

4 ROT >R >R 2DUP > IF SWAP ENDIF R> R> 

5 2DUF‘ > IF SWAP END IF >F: SWAP R> 

6 ; 

7 : POSITION ( X Y — ADDR RPX ) 

S CURR-MGDE C© BY/LN C© * 

9 SCR—MEMORY © + SWAP PXBY C© 

10 /MOD SWAP >R + RO- 

11 ; 

12 CODE SETCMSK ( PX — ) 

13 PXBY LDA, CLC, O ,X ADC, TAY, DEY, 

14 PXMSKTB ,Y LDA, CMSK STA, POP JMP, 

15 —> 


SCR #28 

0 < GRAPHICS — PLOT ) 

■i 

1 

2 CODE PXPUT ( ADDR — ) 

3 CMSK LDA, FF # EOF;, 0 X) AND, 0 X) STA, 

4 CMSK LDA, CGLORMSK AND, O X> ORA, 0 X) STA, 

5 OLDCHF; STA, 0 ,X LDA, OLDADR STA, 

6 1 ,X LDA, OLDADR 1+ STA, PGP JMP, 

T 

/ 

8 ; WTCRS < — ) 

9 OLDCOL © OLDROW S +OFFSET 2DUP BOUNDARY? 

10 IF POSITION SETCMSK PXPUT ELSE 2DR0P ENDIF 

11 ; 

12 

13 : PLOT LOCATE WTCRS ; ( X Y — ) 


15 



24 

SCR #29 

0 ( GRAPHICS — DRAWLINE ) 

1 0 VARIABLE XSIGN 0 VARIABLE Y3IGN 

2 0 VARIABLE XYSIGN 0 VARIABLE VL 

3 : HCALINC ( — INCI INC2 DEFF XEND X ) 

4 TNEWCOL @ TOLDCOL a - DUP >R TNEWROW @ TOLDROW @ - 

5 DUP ROT XYSIGN a * - OVER OVER + XSIGN a * ROT 

6 DUP + XSIGN a * ROT DUP + XSIGN a * ROT R> 0 

■ ? 

3 : >TEMP < XI Y1 X2 Y2 — ) 

9 VL a IF TNEWCOL ! TNEWROW ! TOLDCOL ! TOLDROW ! 

10 XSIGN a YSIGN a XSIGN ! YSIGN ! 

11 ELSE TNEWROW ! TNEWCOL ! TOLDROW ! TOLDCOL ! 

12 ENDIF XSIGN @ YSIGN @ +- XYSIGN I 

13 ; 

14 —> 


SCR #30 

0 ( GRAPHICS — DRAWLINE ) 

1 ; HDRAWPTS ( INCI INC2 DEFF XEND X — ) 

2 >R >R O R> R> 

3 DO I XSIGN a + >R >R DUP XYSIGN a +- 0< 

4 IF >R OVER R> + R> 

5 ELSE OVER + R> YSIGN a + 

6 ENDIF R> OVER VL a IF SWAP ENDIF PLOT 

7 XSIGN a +LOOF' 2DR0P 2DR0P 

a ; 

9 —> 

10 


14 


15 


247 


SCR 


0 

i 


CODE SETMSK 


< 


SETMSK 
R2 Ri 


— ) 


, DEY, 


o 

9 

10 

11 


PX8Y LDA, CLC, 0 ,X ADC, TAY, 

XSIGN BIT, IFPL, RFMSKTB ,Y LDA, ENDIF, 

XSIGN BIT, IFHI, LFMSKTB ,Y LDA, ENDIF, 

FMSK ST A, F'XBY LDA, CLC, 2 , X ADC, TAY, 

DEY, XSIGN BIT, IFPL, LFMSKTB ,Y LDA, ENDIF, 
XSIGN BIT, IFHI, RFMSKTB ,Y LDA, ENDIF, 

FMSK 1+ STA, P0PTW0 JMP, 

CODE PXI ( ASM ONLY ) 

TYA, PHA, 0 # LDY, CMSK LDA, FF # EOR, 

QLDADR )Y AND, OLDADR )Y STA, CMSK LDA, 
C0L0RM5K AND, OLDADR )Y ORA, 


13 QLDADR >Y STA, OLDCHR STA, PLA, TAY, RTS, 

14 

15 —> 


0 ( GRAPHICS — INCADR VDRAW ) 

1 CODE INCADR i ASM ONLY WITH JSR ) 

2 OLDADR LDA, CLC, XSIGN ADC, 

3 OLDADR STA, OLDADR 1+ LDA, 

4 XSIGN 1+ ADC, OLDADR 1+ STA, RTS, 


6 CODE VDRAW ( DISP +-B/L — ) 

7 2 ,X LDA, IFNE, TAY, BEGIN, 

S ULDADR LDA, CLC, 0 ,X ADC, 

9 QLDADR STA, OLDADR 1+ LDA, 1 ,X ADC, 

10 OLDADR 1+ STA, 1 PX» JSR, DEY, 

11 0= END, ENDIF, PQPTWO JMP, 

12 

13 

14 

1 — > 



0 

•i 

L 

*~y 



4 


6 

7 

id 

9 

10 

11 



14 

15 


SCR 


u 


1 


4 


cr 

i-J 

b 


a 

9 

10 


( GRAPHICS — HDRAW ) 

CODE HDRAW ( ADDR1 DISP — > 

2 ,X LDA, QLDADR STA, 3 , X LDA, 
QLDADR 1+ STA, 0 ,X LDA, IFEQ, 

FMSK LDA, FMSK 1+ AND, CMSK STA, 

' PX! JSR, ENDIF, O ,X LDA, 

IFNE, FMSK LDA, CMSK STA, ' PX! JSR 
' INCADR JSR, XSAVE STX, O ,X LDA, 
TAX, DEX, IFNE, BEGIN, CGLORMSK LDA 
QLDADR )Y STA, ' INCADR JSR, 

DEX, 0= END, ENDIF, FMSK 1+ LDA, 
CMSK STA, ' PX! JSR, XSAVE LDX, 

ENDIF, PQPTWQ JMP, 


#34 

\ GN Af-’H ILS — DIKCT ) 

; OUTCODE ( X Y — CODE ) 

O OVER YMAX @ > IF S + ENDIF 
SWAP YMIN @ < IF 4 + ENDIF 
OVER XMAX @ > IF 2 + ENDIF 
SWAP XMIN a < IF 1+ ENDIF 

% 

: DIR? < Hi N2 — SIGN ) 

~ DUP O— 

IF DROP O 

ELSE 0< IF -1 ELSE 1 END IF 


24V 


SCR #35 

0 < GRAPHICS — DIRCTION? ) 

1 : DIRECTION ( Xi Yi X2 Y2 — XSIGN YSIGN 

2 ROT DIR? DUP YSIGN ! 

3 >R SWAP DIR? DUP XSIGN R> 

4 j 

5 : XCLIP < X — CX ) 

6 XMIN @ MAX XMAX @ MIN 

7 ; 

8 : YCLIP < Y — CY ) 

9 YMIN @ MAX XMAX @ MIN 


10 | 

11 ; HCLIP < XI Yl X2 Y2 — CXI CY1 CX2 CY2 ) 

12 >R XCLIP >R >R XCLIP R> R> R> 


14 


SCR #36 

0 < GRAPHICS — HLINE ) 

1 ; VCLIP ( XI Yl X2 Y2 — CXI CY1 CX2 CY2 ) 

2 YCLIP >R >R YCLIP R> R> 


4 ; HLINE ( XI Yl X2 Y2 — ) 

5 HCLIP >R >R POSITION 

6 R> R> ROT >R POSITION 

7 >R OVER - A8S R> R> SETMSK HDRAW 
S ; 

9 ; VLINE f XI Yl X2 Y2 — ) 

10 VCLIP SWAP DROP OVER - ABS >R 

11 POSITION SETCMSK PXPUT R> CURR-MODE @ 

12 BY/LN C@ YSIGN @ +- VDRAW 


14 


15 




SCR #37 


0 < GRAPHICS — CLINE ) 

1 : CLINE < XI Y1 X2 Y2 — ) 

2 20'v'ER 20VER 20VER OFFSET>T OFFSET! ROT - ABS 

3 >R - ABS R> < VL ! 

4 >TEMP HCALINC O 0 PLOT HDRAWPTS T>OFFSET 

5 

6 ; DRAWLINE ( — } 


7 

OLDCOL @ OLDROW & +OFFSET 

2DUP 

OUTCODE 

S 

NEWCOL @ NEWROW & +OFFSET 

2DUP 

GUTCODE ! 

9 

IF 20‘v‘ER 20'v‘ER DIRECTION 

0= 


10 

IF DROP HLINE 



11 

ELSE 0= IF VLINE ELSE 

CLINE 

END IF 

12 

END IF 



13 

ELSE 2DRQP 2DR0P 



14 

END IF NEWCOL £> OLDCOL ! NEWROW 

@ OLDROW 

15 | 

__ \ 




SLR #38 

0 ( GRAPHIC — LINE , DRAWTO ) 

1 : LINE < XI Y1 X2 Y2 — ) 

2 NEWROW ! NEWCOL ! OLDROW ! OLDCOL ! DRAWLINE 




4 

* 

DRA^JTO ( X2 Y2 - 

~ ) 

5 


NEWROW ! NEWCOL 

? DRAWLINE 

a 

5 



7 




8 

0 

VARIABLE FILLFL8 


9 

: 

CIRCLE-FILL < X Y 

— ) 

10 


2DUP OVER MINUS 

OVER LINE SWAP 

1 1 

A A 


2DUP OVER MINUS 

OVER LINE MINUS 

12 


2DUP OVER MINUS 

OVER LINE 

13 


SNAP MINUS OVER 

MINUS OVER LINE 

14 

5 



15 

— ■ 

- > 




SCR #39 

0 < GRAPHICS — CIRCLE ) 

1 

2 : CIRCLE-PTS < X Y — ) 

3 OVER OVER PLOT SWAP OVER OVER 

4 PLOT MINUS OVER OVER PLOT 

5 OVER OVER MINUS SWAP MINUS 

6 OVER OVER PLOT OVER OVER SWAP 

7 MINUS OVER OVER SWAP PLOT PLOT 

3 SWAP PLOT SWAP PLOT 

10 : CIRCLE-PUT ( X Y — ) 

11 FILLFLG C0 IF CIRCLE-FILL 

12 ELSE CIRCLE-PTS 

13 END IF 

14 ; 

15 —> 

SCR #40 

0 ( GRAPHICS — CIRCLE ) 

1 ; DRAWCIRCLE ( X Y R — ) 

2 >R OFFSET>T +QFFSET OFFSET! R> 

3 3 OVER 2 * - SWAP 0 SWAP 

4 BEGIN OVER OVER < 

5 WHILE OVER OVER CIRCLE-PUT OVER OVER 

6 >R >R >R >R DUP 0< 

7 IF 4 * 6 + + R) DRUP R> 1+ R> 

8 ELSE 4 R> R> — * + 10 + R> 1+ R> 1 — 

9 ENDIF 

10 REPEAT OVER OVER = 

11 IF CIRCLE-PUT DROP 

12 ELSE DROP DROP DROP 

13 END IF TXJFFSET 

14 ; 



0 < GRAPHICS — CIRCLE ) 

1 

2 : CIRCLE < XC YC R — ) 

3 >R 2BUP R> O FILLFLG C? 

4 DRAWCIRCLE OLDROW ! QLDCQL ? 


6 

7 

8 
9 

10 

11 

12 

13 

14 


: FCIRCLE < XC YC R — ) 

>R 2DUP R> 1 FILLFLG C! 

DRAWCIRCLE OLDROW ? OLDCGL ! 

5 

: BOX ( XI Y1 X2 Y2 — ) 

NEWROW ! NEWCOL ? 2DUP OLDROW ? OLDCGL ! 
WEWCOL @ 2DUP NEWROW @ OLDCGL @ 2DUP 
OLDROW 0 LOCATE DRAWTO DRAWTO DRAWTO DRAWTO 


SCR #42 

0 < GRAPHICS — FBOX ) 

1 ; HPOS ( XI Yl X2 Y2 —ADDR1 DX ) 

2 >R >R POSITION OVER R> R> POSITION 

3 >R SWAP - SWAP R> SWAP SETMSK 



HDKAW UVEH 4-LOUP 


<iwl 


SCR #43 

0 < GRAPHICS — CLRBOX ) 

1 : FBQX < XI Yi X2 Y2 — ) 

2 NEWROW ! NEWCOL I OLDROW ! OLDCOL ! 

3 FILBOX NEWCOL @ OLDCOL i NEWROW @ OLDROW 

4 ? 

5 : BCLEAR < XI Yi X2 Y2 — ) 

6 CURR-COLQR C@ >R 0 USECOLOR 

7 FBOX R> USECOLOR 

a I 

9 : WCLEAR < — ) 

10 XMIN S YMIN @ XMAX @ YMAX § BCLEAR 

? 

12 : CLEAR < — ) 

13 TXMIN @ TYMIN @ TXMAX @ TYMAX @ BCLEAR 



SCR #44 

0 i GRAPHICS — BFILL ) 

1 

2 0 VARIABLE BYLN 0 VARIABLE QLDCOLMSK 

3 O' VARIABLE UPTRIG O VARIABLE DOWNTRIG 

4 D2 CONSTANT STACK-PT 90 CONSTANT XTEMP 

5 0 VARIABLE STACK—STM 

6 i READPX < X Y — COLOR ) 

7 POSITION SETCMSK CS CMSK CS AND O 

S' BEGIN 2DUP 6ETC0LMSK CMSK C@ AND = NOT 

9 WHILE 1+ 

10 REPEAT SWAP DROP 

11 | 

12 ; SETBYLN < — 5 

13 CURR-MODE C@ BY/LN C@ BYLN C! 



254 


SCR #45 

0 < GRAPHICS — BFILL ) 

1 

2 CODE (=OLDCOLOR?) ( ADDR — F ) ( ASH ONLY ) 

3 O # LDY, O X) LDA, CHSK AND, 0 ,X STA, 

4 OLDCOLMSK LDA, CHSK AND, O ,X CHP, 

5 1 ,X STY, IFEQ, INY, ENDIF, 

6 O ,X STY, RTS, 

7 

S CODE =QLDCOLOR? ( ADDR — F ) 

9 ' (=QLDCQLOR?) JSR, NEXT JHP, 

10 

11 s SETSTACK < ADDR — ) 

12 DUP STACK-BTM ! STACK-PT ! 

13 % 

14 —> 

15 

SCR #46 

0 < GRAPHICS — BFILL ) 

1 ; STACK-EMPTY? ( — F ) 

2 STACK—BTM @ STACK-PT & < NOT 

4 : STACK-POP ( — X Y ) 

5 STACK-PT @ 2 - DUP £ SNAP 

6 2 - DUP STACK-PT ! € 

7 ; 

3 CODE (STACK-PUSH) ( X Y — ) < ASH ONLY ) 

9 XTEHP STX, 0 # LDA, XTEMP 1+ STA, 4 # LDY, 

10 BEGIN, DEY, XTEHP )Y LDA, STACK-PT )Y STA, TYA, 

11 0= UNTIL, STACK-PT LDA, CLC, 4 # ADC, 

12 STACK-PT STA, STACK-PT i+ LDA, 

13 O # ADC, STACK-PT STA, 

14 INX, INX, INX, INX, RTS, 

15 — > 



SCR #47 


0 

1 


6 


o 

9 

10 

11 

12 

13 


( GRAPHICS 


CODE STACK-PUSH ( X Y — ) 

' (STACK-PUSH) JSR, NEXT JMP, 

CODE ABOVE? < ADDR X Y — ) 

0 ,X LDA, SEC, 1 # SBC, 0 ,X STA, 1 ,X LDA, 0 # SBC, 

0 # SBC, 1 ,X STA, SEC, 0 ,X LDA, YMIN SBC, 

1 ,X LDA, YMIN 1+ SBC, IFVS, SO # EOR, ENDIF, 

IFMI, INX, INX, POPTWO JMP, ENDIF, 

XSAVE STX, INX, INX, INX, INX, O ,X LDA, 

SEC, BYLN SBC, O ,X STA, 1 ,X LDA, O # SBC, 

1 ,X STA, ’ (=OLDCOLOR?) JSR, O ,X LDA, 

IFEQ, 1 # LDA, UPTRIS STA, POP JMP, ENDIF, 

UPTRI3 LDA, IFEQ, POP JMP, ENDIF, 

O # LDA, UPTRIG STA, XSAVE LDX, 


14 ' (STACK-PUSH) JSR, POP JMP, 


15 —> 


SCR #48 

0 < GRAPHICS — BFILL ) 

1 

2 CODE BELOW? ( ADDR X Y — ) 

3 0 ,X LDA, CLC, 1 # ADC, O ,X STA, 1 ,X LDA, 

4 O # ADC, 1 ,X STA, SEC, YMAX LDA, 0 ,X SBC, 

5 YMAX 1+ LDA, 1 ,X SBC, IFVS, SO # EOR, ENDIF, 
S IFMI, INX, INX, POPTWO JMP, ENDIF, 

7 XSAVE STX, INX, INX, INX, INX, O ,X LDA, 

S CLC, BYLN ADC, 0 ,X STA, 1 ,X LDA, O # ADC, 

9 1 ,X STA, ' <=OLDCOLQR?> JSR, 0 ,X LDA, 

10 IFEQ, 1 # LDA, DOWNTRIG STA, POP JMP, ENDIF, 

11 DOWNTRIG LDA, IFEQ, POP JMP, ENDIF, 

12 O # LDA, DOWNTRIG STA, XSAVE LDX, 

13 ’ (STACK-PUSH) JSR, POP JMP, 

14 


15 



SCR #49 

0 it GRAPHICS — BFILL ) 

1 : <FILL < X Y — ADR PXR BX BY ) 

2 2DUP >R >R POSITION 

3 BEGIN 2DUP SETCMSK =QLDCOLOR? 

4 I XMIN S < NOT AND 

5 WHILE R> 1 - >R DUP 0= 

6 IF DROP 1 - PXBY C@ ENDIF 1 - 

7 REPEAT R> R> 1 DUP UPTRIG Cl 

8 DOWNTRIG Cl 

9 ; 

10 —> 

1 1 


i 3 
14 


#50 

< GRAPHICS — BFILL ) 

: FILL> ( ADDR PXR X Y — ) 

>R >K 

BEGIN 1 + DUP PXBY CO = 

IF DROP 0 END1F 
2DUP SETCMSK =OLDCOLOR? R> 1+ 
DUP >R XMAX O > NOT AND 
NHILE OVER PXPUT OVER 2R ABOVE? 

OVER 2R BELON? 

REPEAT 2DR0P R> R> 2DR0P 

? 

11 — > 
i ■”> 




15 



GRAPHICS — BFILL 
BFILL C X Y — ) 


SETBYLN 2BUP READF'X GETCOLMSK 
DUP GLDCQLMSK C! COLORHSK C@ = NOl 
IF HERE 100 + SETSTACK STACK-PUSH 
BEGIN STACK-EMPTY? NOT 
WHILE STACK-POP 
< FILL 
FILL > 


REPEAT 
ELSE 2DR0P 
END IF 


< LSHIFT ) 

0 VARIABLE SADDR O VARIABLE DADDR 


0 VARIABLE DBYTEE 
0 VARIABLE DLPX 


0 VARIABLE BITS 
O VARIABLE DRPX 


4 0 VARIABLE 3DXA 

5 400 VARIABLE WORKING 92 CONSTANT WADDR 


CODE LSHIFT ( ADDR BYTES BITS — ) 

4 ,X LDA, WADDR STA, 5 ,X LDA, WADDR 1+ 
BEGIN, 2 ,X LDY, CLC, 

BEGIN, DEY, WADDR >Y LDA, ROL.A, 


WADDR )Y 


i, TYA, 0= 


UNTIL, 0 ,X DEC, 0= 
UNTIL, 

I NX, INX, PQF'TWO JMP, 






253 


SCR #53 

0 ( RSHIFT ) 

1 

2 CODE RSHIFT < ADDR BYTES BITS — > 


3 

4 ,X LDA, WADDR S 

TA, 5 

,X LDA, 

4 

WADDR 1+ STA, 



er 

BEGIN, 0 # LDY, 2 

,X L 

DA, 

6 

XSAVE STX, TAX, 

CLC, 


7 

BEGIN, WADDR )Y 

LDA, 

RGR.A, 

S 

WADDR )Y STA, 

INY, 

DEX, 0= 

9 

UNTIL, 



10 

XSAVE LDX, 0 ,X 

DEC, 

0= 

11 

UNTIL, 



12 

INX, INX, POPTWO 

JMP, 



13 

14 —> 

15 


ICR 

#54 



0 

< RCOFY - 

- ) 


1 

CODE RMOST 

< b-fr raddr — ) 


r—i 

PXBY LDA, 

CLC, DRPX ADC, 


y t 

TAY, DEY, 

LFMSKTB ,Y LDA, 2 X) 

AND, 


2 X > STA, 

LFMSKTB ,Y LDA, FF # 

EOR, 

u 

0 X) AND, 

2 X) ORA, 2 X) STA, 


A 

PORTED JH 

Pi 


7 

CODE LiiOST 

< b-fl 1 addr — ) 


3 

PXBY LDA, 

CLC, DLPX ADC, 


9 

TAY, DEY, 

RFMSKTB ,Y LDA, 


10 

2 X) AND, 

2 X) STA, RFMSKTB ,Y 

LDA, 

11 

FF # EOR, 

0 X) AND, 2 X) ORA, 


12 

2 X) STA, 

POPTWO JMP, 


13 

FORTH 




14 —> 

15 



259 


SCR #55 

0 < RCOPY — ) 

1 

2 : LMQVE < — ) 

3 SADDR § WORKING @ DBYTES C£ 14* CMOVE 

4 WORKING € DBYTES C® 1 + SITS @ DUP 

5 IF DUP 0< 

6 IF MINUS LSHIFT 

7 ELSE RSHIFT 

3 ENDIF 

9 ELSE DROP 2DR0P 

10 ENDIF WORKING £ DADDR @ 2DUP LMOST 

11 DBYTES C£ >R OVER R + I OVER 

12 R 4- 1 - RMOST R> CMOVE 

1 T e 

i 5 

14 —> 

15 


SCR #56 

0 < RCOPY — } 

2 : PREPARE < six sly srx sry dlx dly — dyend dly ) 

3 >R >R RESORT 20VER 20VER DIRECTION 2BRQP 

4 >R OVER R> SWAP - >R >R 2DUP OVER R> SWAP 

5 OVER SWAP - >R OVER HPOS SDXA ! SADDR ! 

6 POSITION SWAP DROP R> R> SWAP R + TXMAX © 

7 MIN R> R POSITION 2DUP DLPX Cl 

3 DADDR ! ROT R POSITION DRPX C! 


9 

SWAP 

>R SWAP 

- 1 + DBYTES C! R> 

10 


>R SWAP 

- CURR-MODE C© BI/PX 

JL i. 

BITS 

? R> R -4 

TYMAX © MIN 1+ R> 

12 5 




13 




14 





15 



SCR #S 


RCOPY ) 

RCGPY < six sly srx sry dlx dly 
PREPARE 

DO LMOVE CURR-MODE C@ BY/LN C© 
DUP SADDR + ! DADDR + ! 


lOVt ( six sly srx sry dlx dly 
CURR-COLQR C© >R O USECOLOR PREF 
DO LMOVE SADDR © SDXA © HDRAW 
CURR-MODE C© BY/LN C@ DUP 
SADDR +i DADDR +! 


3/16/35 ) 


2 EOOO CONSTANT CHBASE 

3 PXMSKTB 7 + CONSTANT BITMSKTB 


4 ; >INCODE 


< ascii — ireads ) 


DUP 20 < DUP 7F > OR 
IF DROP 0 
ELSE DUP 60 < 

IF 20 - ENDIF 
END IF 


14 —> 


15 




SCR #59 


TEXT 

CHARACTER 


< X Y CODE — ) 


>INCODE 8 * CHBASE + SWAP 1+ DUP 
DO SWAP 8 0 

DO OVER C© I BITMSKTB + C@ AND 
IF DUP I + J PLOT ENDIF 
LOOP SWAP 1+ 

LOOP 2DR0P 


OVER 


< X Y ADDR 
SWAP 


NGTH — 


DO 2DUP I C© CHARACTER 


SWAP 


LOOP 2DR1 


: (PRINT) 


( X Y — ) 


R COUNT DUP 1+ R> + >R PRINT 


; STRING" 


( X Y — ) 


22 STATE © 

IF COMPILE (PRINT) WORD HERE C© 1+ ALLOT 
ELSE WORD HERE COUNT PRINT 
END IF 
IMMEDIATE 
TEXT ( X Y — ) 

CR ." TYPE IN TEXT STRING : " CR 

QUERY G WORD HERE COUNT PRINT 



262 


SCR #61 

0 < GRAPHICS — DLI ) 

1 200 CONSTANT VDSLST D40E CONSTANT NMIEN 

2 E45C CONSTANT SETVBV C2SA CONSTANT VBDEXIT 

3 : DLI-ON SO NMIEN C@ OR NMIEN C! ; i — ) 

4 : DLI-OFF 7F NMIEN C@ AND NMIEN C! ; ( — ) 

5 : SETDLIV VDSLST ! ; ( DLIRTN — ) 

6 CODE SETVBD ( ADDR — ) 

7 XSAVE STX, 0 ,X LDY, 1 ,X LDA, 

8 TAX, 7 # LDA, SETVBV JSR, 

9 XSAVE LDX, POP JMP, 


10 


11 CODE RESETVBD < — ) 

12 XSAVE STX, 7 # LDA, C2 # LDX, 

13 8A # LDY, SETVBV JSR, 

14 XSAVE LDX, NEXT JMP, 

15 —> 


SCR 

Q 

1 

** 7 » 

3 

4 

Zi 

6 


11 


#62 

< GRAPHICS — SSAVE ) 

O VARIABLE PDLA O VARIABLE COLA 

0 VARIABLE PDDA O VARIABLE CDDA 

1 VARIABLE DLFLAG 1 VARIABLE DDFLAG 

400 RECORD MFD 

% TOT#SEC 2 BYTES 
% DIR-SEC 2 BYTES 
% FREE-LIST 2 BYTES 
END-RECORD 
5S0 RECORD FDS 

% SEC# 2 BYTES % NEXT 


7. USED#S£C 
7. DIR#SEC 
% FEEE#SEC 


2 BYTES 
2 BYTES 
2 BYTES 


% LDA 2 BYTES 
% DATA 120 BYTES 
END-RECORD 


BTS 


2 BYTES 
2 BYTES 


14 



SSAVE ) 


SCR #63 

0 < GRAPHICS — 


2 500 VARIABLE FDA 

3 502 RECORD FDD 


4 

% 

LENGTH 

1 

BYTES 

7. 

NAME 

5 

BYTES 

5 

% 

DLA 

2 

BYTES 

»/ 

/« 

HEAD 

2 

BYTES 

6 

% 

TAIL 


BYTES 

7. 

#SEC 

1 

BYTES 

7 

% 

SCROLL 

1 

BYTES 

/« 

SCRM 


BYTES 

8 

■/ 

TXTli 

2 

BYTES 

y 

FXHIN 

n 

x. 

BYTES 

9 

y 

FXMAX 

n 

iL 

BYTES 

7 

FYlilN 

2 

BYTES 

10 

/• 

FYMAX 

—« 

BYTES 

7. 

COLR 

5 

BYTES 


11 END-RECORD 

12 

13 

14 —> 
i 5 


Ch 

#64 




Q 

i 

GSAVE — 

) 



i 


READ 1 R/W 

? 

< ADDR SEC# — 

) 

0* 


NRITE 0 R/W 

) 

( ADDR SEC# — 

) 

4 


GET—MFD MFD 

fd 

0 READ ; ( — ) 


5 


PUT—MFD MFD 

(3 

0 WRITE ; < — ) 


6 


PUl—FDD FDA 

B 

DUP © WRITE ; ( 

— ) 

T 

= 

PUT—FDS FDS 


SEC# ■§ WRITE ; < 

— ) 

S 

‘ 

FORMAT-MFD 

( 

— ) 


9 


MFD @ SO 

0 ! 

FILL 2CE TOT#SEC 

! 

10 


0 USED#SEC 

! 1 DIR-SEC ! F DIR#SEC 

11 


10 FREE-LIST ! 2BE FRE£#SEC 

1 

12 


PUT-MFD 




13 

5 





14 

— 

— > 





1 



SUK #6ti i 


264 


0 

( 

SSAVE — ) 



■i 

1 


FORMAT—FDD ( - 

-) 


2 


FDA S SO 0 FILL 10 1 


3 


DO I FDA @ ! 

FDA <§ I WRITE LOOP 

4 

■ 

n 





m 

FORMAT-FDS < - 

- } 


6 


FDS # DUP SO 

0 FILL 2CE 

10 

7 


DO DUP I DUP 

DUP SEC# ! 

1+ NEXT 1 WRITE 

a 


2CE DUP SEC# 

? 0 NEXT ! 

WRITE 

9 

5 




10 


FORMAT < — ) 



11 


CR ." Insert 

blank disk 

Si 

12 


CR ." Type ' 

V ' to start 

" CR KEY 59 = 

13 


IF „" <WAIT> 

Ji CR FORMAT 

-MFD FORMAT-FDD 

14 


FORMAT-FDS 

END IF 


in 

H 

5 

— > 




SCR #66 


0 < 

SSAVE 

_ ^ 


1 : 

MATCH? 

( ADDR1 ADDR2 — 

F ) 

n 

0 ROT 

ROT OVER Ca 1+ 


3 

h MIN 

OVER + SWAP 


4 

DO DUP D3 I ca = NOT 


5 

IF 

LEAVE SNAP DROP 1 

SNAP 

6 

LOOP 

DROP NOT 



7 ^ 

8 s RELEASE < — ) 

9 FDS 0 TAIL @ 2DUP READ 

10 FREE-LIST @ NEXT ! WRITE #SEC C0 

11 DUP MINUS USED#SEC +! FREE#SEC +! 

12 HEAD @ FREE-LIST ! LENGTH IF 0 FILL 

13 z 

14 —> 





65 


SCR 

#67 


0 

< GSAVE — > 


■i 

: FIND-FD ( ADDR — ADDR 1 or 0 


0 10 1 


y t 

DO DROP FDA @ DUP I READ 

2 + 

4 

DO DROP 2DUP MATCH? 


5 

IF SWAP DROP 1 LEAVE 

6 

ELSE IF + 0 


7 

END IF 


3 

LOOP 


9 

IF 1 LEAVE ELSE DROP 0 

END! 

10 

LOOP 


11 

IF 1 ELSE DROP 0 ENDIF 


12 

5 


13 

2 FIND-FN < — ADDR F ) 


14 

SET-MFD 0 WORD HERE FIND- 

■FD ; 

15 

— > 



SCR #63 

0 ( GSAVE — ) 

1 : FIND—EMPTY ( — ADDR 1 Or O ) 

2 O 10 1 

3 DO DROP FDA 0 DUP I READ 2+040 

4 DO DROP DUP C@ 0= 

5 IF 1 LEAVE ELSE IF + 0 ENDIF 

6 LOOP 

7 IF 1 LEAVE ELSE DROP O E HD IF 

a LOOP 

9 ; 

10 ; (DELETE) < ADDR F — ) 

11 IF FDD l RELEASE PUT-FDD PUT—MFD 

12 ELSE . 11 File name Not Found ! ” 

13 END IF 

14 5 


15 



266 


SCR #69 

0 < SSAVE — > 

1 : DELETE FIND-FN (DELETE) ; ( — ) 

2 

3 : REQUEST ( — ) 

4 FREE#SEC @ 0= 

5 IF .“ Disk Full ! " RELEASE 

6 PUT—FDD PUT-HFD ABORT 

7 ENDIF 

8 1 USED#3EC +i -1 FREEtSEC +! 

9 FREE-LIST § DUP HEAD @ 

10 IF NEXT ! PUT—FDS ELSE HEAD ! ENDIF 

11 TAIL ! FDS @ FREE-LIST & READ 

12 NEXT Q FREE-LIST ! O NEXT ! 

13 1 ttSEC + ! 

14 ; 


SCR #70 

0 ( SSAVE — ) 

1 : STORE-DL ( — ) 

2 DLFLAS DS IF PDLA & CDLA <S OVER - DUP 

3 IF REQUEST 78 MIN >R DUP LDA ! 

4 DUP DATA R CMGVE R + PDLA ! R> BTS ! 

5 ELSE 2DR0P 

6 ENDIF ENDIF 

7 | 

8 : STORE—DD < — ) 

9 DDFLAS OS IF PDDA <1 ODD A @ OVER - DUP 

10 IF REQUEST 78 MIN >R DUP LDA l 

11 DUP DATA R CMGVE R + PDDA ! R> 

■i 

J. X. 

13 

14 \ 

15 —> 


ELSE 2DR0P 
ENDIF ENDIF 


BTS ! 



267 


SCR #71 


0 

< 

GSAVE — ) 


i 

; 

STORE-DATA < ADDR — ) 




DUP CDLA ! PDLA ! 




BEGIN 0 CDLA @ C© DUP OF 

AND DUP 

4 


IF OVER 40 AND 


*3 


IF STORE-DD DUP 1 > 


o 


IF CDLA © 1+ & DUP 

PDDA 1 CDDA i 

~7 

/ 


3 CDLA +! BY/LN 

C@ CDDA +! DROP 

8 


ELSE 2DR0P CDLA DUP @ 1+ @ SWAP 

9 


2DUP @ 3 CDLA +! 

STORE-DL > 

10 


IF ! ELSE 2DR0P 

DROP 1 ENDIF 

11 


END IF 


12 


ELSE 1 CDLA +! BY/LN 

C@ CDDA +! DROP 

13 


END IF 


14 


ELSE 2DR0P 1 CDLA +! 


15 


END IF —> 


ICR 

#72 


0 

< 

GSAVE — ) 


i 


, CDDA @ PDDA ® - 77 > 


9 


IF STORE-DD ENDIF 


3 


CDLA @ PDLA @ - 77 > 


4 


IF STORE-DL ENDIF 


5 


UNTIL 


6 


CDDA @ PDDA - 0 > 


/ 


IF STORE-DD ENDIF 


8 


CDLA @ PDLA @ - 0 > 


9 


IF STORE-DL ENDIF 


10 


PUT-FDS 


11 

3 



12 




i ~y 

1 




14 

— 

— > 



1 U 



,&Q 


SCR #73 

0 ( SSAVE — ) 

1 : STORE—ENV ( — ) 

2 SCROLL-LINES C© SCROLL C! 

3 SCR-MEMORY © SCRM ! TXT—MEMORY © TXTM ! 


4 

TXMIN % 

FXMIN ! 

TXMAX © FXMAX I TYMIN © FYMIN 

5 

TYMAX e 

FYMAX ! 

2C4 COLR 5 CMOVE 

6 2 




7 : 

LOAD—ENV 

( — 

) 


S SCROLL C© SCROLL-LINES Cl 

9 SCRM © SCR-MEMORY ! TXTM © TXT—MEMORY I 

10 FXMIN © TXMIN I FXMAX © TXMAX I FYMIN © TYMIN I 

11 FYMAX © TYMAX I COLR 2C4 5 CMOVE 

12 ; 

13 

14 —> 

■i ST 
1 

SCR #74 

0 ( SSAVE — } 

1 : (SSAVE) < ADDR F — ) 

2 IF DROP . n File name Net Unique ! 11 

3 ELSE HERE FIND—EMPTY 

4 IF FDD ! DUP 3 MIN LENGTH 

5 SNAP CMOVE STORE—ENV SDLSTL @ DUP DLA i 

6 STORE-DATA PUT—FDD PUT—MFD 

7 ELSE . 11 Directory Full ? " 

3 END IF 

9 END IF 

10 ; 

11 

12 2 SSAVE FIND-FN (SSAVE) ; < — ) 

13 

14 

15 —> 



SCR *75 


0 < GRAPHICS — BSAVEALL ) 

1 

2 : SAVE-DL < — ) 

3 1 DLFLAG C! 0 DDFLAG C! GSAVE 

4 ; 

5 : SAVE-DD < — ) 

6 O DLFLAG C! 1 DDFLAG C! GSAVE 

7 ; 

S : SAVE-ALL < — ) 

9 1 DLFLAG Cl 1 DDFLAG C! GSAVE 



14 

15 — > 

SCR #76 

0 < GLOAD — } 

1 : LOAD-DATA < — ) 

2 FDS @ HEAD @ 


3 BEGIN DUP 

4 WHILE OVER SWAP READ DATA 









SCR #79 


271 


( GRAPHICS — PADXV ) 

270 CONSTANT PADX 271 CONSTANT PADY 
27C CONSTANT LBTN 27D CONSTANT RBTN 
0 VARIABLE PFX 0 VARIABLE PFY 
CODE PADXY < — X Y ) 

DEX, DEX, BEX, DEX, 0 # LDA, 


9 

10 
-t A 

i. i 

12 

1 T 

A 1 

14 

15 


2 , X STA 


, PADY LDA, 


,X STA, PADX LDA, 

0 , X STA, 

BEGIN, O * LDY, PADX LDA, 2 ,X CMP, 
IFNE, INY, 2 ,X STA, ENDIF, 

PADY LDA, 0 ,X CMP, 

IFNE, INY, 0 ,X STA, ENDIF, 

O # CPY, 0= 

UNTIL, NEXT JMP, 


SCR #80 

0 ( PAD — TEST ) 

1 : SETPF < — ) 

2 CURR-MQDE CS DUP PX/ML S PFX ! 

3 SL/ML CS AO SWAP / PFY i 



>SCRXY < PX PY 

— X Y ) 

6 

PVLOW CS - DUP 

0 > IF PFY @ 

/ 

PHLOW CS - DUP 

0 > 

a 

IF CURR-MODE 

CS F = 

V 

IF 2 * ELS 

E PFX @ * AO 

10 

END IF SWAP 


1 i . 

* * j 



12 0 

VAR 1 ABl_iz. rU AT A1 

-2 ALLOT 

1 -jf 

OE C, 1010 , 101 

O , 3838 , EE 


1 ' i T 

i =; 


FT 


3S3S , 1010 , 1010 



SCR #81 

0 < PLAYER 
1 0 

2 07 C, 10 C, 10 C, 38 C, EE C, 3- 

3 s SETPSIZE < P# CODE — ) 

4 2DUP 1+ SWAP HPSIZE C! OVER 

5 SI ZERO 4- C! 30 SWAP HLGWPO C! 

6 ? 



- 

SINGLE-SIZE 0 

SETPSIZE 3 

( pit -} 

3 

; 

DOUBLE-SIZE 1 

SETPSIZE ^ 

< P#-) 

Q 

• 

QUAD-SIZE 3 

SETPSIZE ; 

< P#-) 

10 


SETPLINE ( CODE LINES LEN 

ADDR — > 

11 


OVER PSIZE ! 

4 0 


12 


DO DUP PMBAS 

E @ + I ADDRP 

0 ! OVER 

13 


2DRQP PNL C? 

DUP 10 4- VLOWPO C! 

14 


EF SDMCTL C@ 

AND OR 3DMCT 

L C? 

15 

H 

— > 




BCR #82 


GRAPHICS — PLAYER ) 

SINGLE-LINE 10 1 100 400 SETF'LINE 
DOUBLE-LINE O 2 SO 200 SE7PLINE 5 


4 s PLAYER—ON < — > 

5 SDMC7L C@ 8 OR SDMCTL 

6 GRAC7L C@ 2 OR GRACTL 


r * 


I 

i * 


8 s PLAYER-OFF ( — ) 

9 SDMCTL CO FB AND SDMCTL C! 
GRACTL C0 FD AND GRACTL C? 


PLAYER-CLEAR C — ) 

PADDR @ PSIZE & 0 FILL ; 


15 




SCR #83 


PLAYER ) 

SETPFIG ( PDftTA RPX RPY P# — ) 

>R I RPYPO C! I RPXPO Cl R> FIGPO I 


6 


10 

11 

12 

13 

14 


SETPLAYERS ( — ) 

PMBASE © DUP 100 / RPMBS CI 
800 O FILL HPGSPO 4 0 FILL 
PCOLRO 4 FF FILL 

4 O DC PDATAO 331 SETPFIG I SINGLE-SIZE 
LOOP SINGLE-LINE PMODE C© DUP 
SL/ML C© SLML I PX/ML <1 PXML I SETPF 


SCR 

o 


#84 


8 


PLAYER ) 
USEPLAYER 


:■# — 


} 


DUP CURR—PLAYER C? DUP HLOWPO C0 OVER 
DUP RPXPO C@ SWAP HPSI2E C@ * - PHLQW C! 
VLQWPO C€l OVER RPYPO C@ - PVLOW C! 

DUP ADDRPO @ PADDR ? FIGPO @ CURR-PFIG ! 


5 X 

W 3B 

>PXY 

( X 

Y " 

— PX 

PY 

} 


9 

DUP 

0 > 

IF 

SLML 

@ * 

PML C@ / 

END IF PVLOW C€l + 

-i A 

SWAP 

DUP 

o 

> IF 

AO 

* pxML 0 

/ ENDIF 

11 

PHLO 

W C(§ 

4- 

SWAP 





15 



274 


#85 
( F 
= P! 


9 

1 Q 

11 

12 

13 

14 


LAYER > 

.AYER ( X Y — ) 

>FXY PSIZE @ 2DUP < 

IF OVER - >R SWAP OVER GURR-PLAYER C& 
SWAP OVER VPOSPO C? HPOSPO + C! 
PLAYER-CLEAR PADDR @ + 

CURR-PFIG €* DUP 


>R 14- SWAP R> C@ 
ELSE 2DR0P DROP 
EHDIF 


MIN CMQVE 


SCR #36 
0 < i 


LOOM 


4 

0 

VARIABLE 

ZMODE 

A 

VARIABLE 

ZFLAG 


0 

VARIABLE 

ZMLX 

0 

VAR1ABLE 

ZMLY 


A 

VARIABLE 

ZXLOW 

A 

VARIABLE 

ZYLQW 

if 

0 

VARIABLE 

ZXHIG 

0 

VAR1ABLE 

ZYHIB 

=T 

0 

variable 

CK/PX 

0 

VARIABLE 

ZDL—A: 

o 

0 

VARIABLE 

zxo 

A 

VARIABLE 

ZYO 

7 

0 

VARIABLE 

FIXFL 

AG 




D404 CONSTANT HSCROL 


■» i_ 



SCR 


id on > 


< 

dla sc; 

RA MZ 

MB LINES — > 


1 c@ 

>R 10 

+ >R 

SNAP BEGIN—DL 

SNAP R> R> 

>R 

2DUP 1 

MODE 

-LINE SNAP R + 

SNAP R> 

:0P 

DROP B 

F60 2 

4 MODE-LINE El 

ND-DL 

ADDR PX 

_ 



! 4 

= OVER 

0 > 

AND NOT IF >R 

1 - R> ENDIF 

- CK 

;/PX c© 

* NS 

CROL Cl 


5 @ 

SWAP OVER 4 

*T* 


' €> 

3 + 

SNAP 




DO CUP I ! CURR-MODE C@ BY/LN C@ +3+1 
DROP SDLSTL SCREEN-OFF ! SCREEN-ON 


0 ( ZOOM > 

1 : >ZOOMXY < X Y — ZX ZY ) 

2 2DUP BOUNDARY? 

3 IF FIXFLAG C@ 

4 IF ZXO 8 ZYO S 

5 ELSE 2DUP ZMLY S 2 / - ZYLOW S MAX ZYHIS -S MIN 

6 SNAP ZMLX @ 2 / - ZXLGW 9 MAX ZXHIS @ MIN SWAP 

7 ENDIF 2DUP POSITION FLUSHDL 2DUP ZYO ! ZXO ! 

S >R SWAP >R - R> R> - 

9 ENDIF 

.0 i 

Li : ZPLAYER < X Y — ) 

L2 ZFLAS C@ IF >ZOOMXY ENDIF PLAYER 


jRTH DEFINITIONS DECIMAL 




APPENDIX C: 


GLOSSARY OP WORDS FOR FIGE 


word screen number high/low level 

stack effects 
description 


Comments 

X will always represent the X-coordinate. 
Y will always represent the Y-coordinate. 



277 


1 . Constants for FIGE 

COLPPO 7 

( — D016H ) 

This constant contains the address of the 
register for play-field 0. 

CRSINH 4 

( — 2P0H ) 

This constant contains the address of the 
inhibition control register. 


DZOOM-DL 4 

( — BE40 ) 

This constant contains the starting address 
display list for the double-zoom mode. 


M1-DL 4 

( — BCDOH ) 

This constant contains the starting address 
display list for BASIC mode 1. 


color 


cursor 


of the 


of the 


278 


M12-SCR 4 

( — B910H ) 

This constant contains the starting address of the 

screen data RAM for BASIC mode 1. 

MAIN-DL 4 

( — BD1 OH ) 

This constant contains the starting address of the 

display list for the main graphics screen. 

MAIN-SCR 4 

( — 9380H ) 

This constant contains the starting address of the 

screen data RAM for the main graphics screen. 

MENU-DL 4 

( — BD80H ) 

This constant contains the starting address of the 

display list for the main menu screen. 

MENU-SCR 4 

( __ A010H ) 

This constant contains the starting address of the 

screen data RAM for the main menu screen. 


279 


QZOOM-DL 4 

( — BEDOH ) 

This constant contains the starting address of the 
display list for the quadruple-zoom mode. 


< 



280 


2. Variables and Arrays for FIGE 

BRPX 12 

( brush# — X-reference ) 

This array contains the X-reference values for the 

five single-line brushes. 

BRPY 1 1 

( brush# — Y-reference ) 

This array contains the Y-reference vlaues for the 

five single-line brushes. 

BRUSH 1 1 

( brush# — address ) 

This array contains the starting addresses of the 

shape data for the five single-line brushes. 

BSH-POOL 1 1 

( — address ) 

This variable defines the starting address of the 
brush shape data pool. 

CMD-ATTR 10 

( command# — attribute ) 

This array contains the collection of attributes for 


the 25 commands. 



281 


CMD-CFA 10 

( command# — cfa ) 

This array contains the collection of CFAs for the 25 
commands. 

CMD-NAME 10 

( command# — ) 

This array is a character string array which contains 
the collection of the command names for the 25 
commands. 

CMDVEC 4 

( — address ) 

This variable contains the CPA of the current command. 

CMENU 10 

( — address ) 

Ibis. variable and its following, 158 bytes contain the 
shape data for the player which is used as the color 


menu. 



282 


COLNO 7 

( -- address ) 

This variable is used as a counter during the 
execution of DLIRTN2 to count the number of times the 
display list interrupts has occurred after the recent 
vertical blank interrupt occured. It is also used as 
an index to the color pool COLRPOOL. 

COLRPOOL 7 

( — address ) 

This variable and its following 15 bytes contain the 
color values which will be displayed in the color menu 
when the DLI occurs. 

CURR-BRUSH 4 

( — address ) 

This variable contains the current brush number. 

CURR-CMD 4 

( — address ) 

This variable containds the current command number. 

CURR-ZOOM 4 

( — address ) 

This variable contains the current zoom mode number. 



283 


DBRPX 12 

( brush# — X-reference ) 

This array contains the X-reference values for the 

five double-line brushes. 

DBRPY 12 

( brush# — Y-reference ) 

This array contains the Y-reference values for the 

five double-line brushes. 

DBRUSH 11 

( brush# — address ) 

This array contains 'the starting addresses of the 

shape data for the five double-line brushes. 

DISKVEC 39 

( operation# — cfa ) 

This array contains the CFAs of the disk operations. 

EXITFLG 4 

This variable contains a flag value which determines 
whether or not to exit PIGE. 



284 


HLCFA 18 

( brush# — ) 

This array contains the CFAs of the words which draw 
horizontal lines for the five brushes. 


HLVEC 4 

( — address ) 

This variable contains the CFA of the word which draws 
a horizontal line for the current brush. 

MARKER 12 

( — address ) 

This variable and its following 21 bytes contain the 
shape data for a marker used to mark the current color 
and the current brush. 

PLBTN 29 

( — address ) 

This variable contains the value which is previously 
read from the left-hand button of the KoalaPad. 

PLCFA 18 

( brush# — cfa ) 

This array contains the CFA's of the words which plot 
points for the five brushes. 



285 


PLVEC 4 

( — address ) 

This variable contains the CPA of the word which plots 
points for the current brush. 

VLCPA 18 

( brush# — cfa ) 

This array contains the CPA's of the words which draw 
vertical lines for the five brushes. 

VLVEC 4 

( — address ) 

This variable contains the CPA's of the words which 

draws a vertical line for the current 

brush. 

XYPLAG 4 

( — address ) 

This variable contains a flag value which determines 
to whether or not display the current cursor position 
in the message section. 



286 


3 . High-level and Low-level Words for FIGE 

!DZOOM-DL 6 H 

( ~ ) 

This command creates a display list for the double¬ 
zoom mode. 

IM1-DL 6 H 

( - ) 

This command creates a display list with BASIC mode 1. 

!M2-DL 6 H 

( - ) 

This command creates a display list with BASIC mode 2. 

!MAIN-DL 5 H 

( - ) 

This command creates a display list for the main 
graphics screen. 

1MENU-DL 5 H 

( - ) 

This command creates a display list for the main menu 


screen. 



287 


! QZOOM-DL 6 H 

’( “ ) 

This command creates a display list for the quadruple- 
zoom mode. 


>CMD# 43 H 

( X Y — command# flag ) 

This command attempts to convert the given X-Y 
coordinates to a command number; if it can, the flag 
value will be set to 1 . 

>CXYR 26 H 

( x-1 Y-1 X-2 Y-2 — X-center Y-center radius ) 

This command converts the’two given points to a center 
point and a radius of a circle. 

CHECK-NAME 38 H 

( — address flag ) 

This command repeatedly queries the user for a 
filename until a new filename, with respect to the 
directory, is obtained. It then puts the address of 
the directory entry and a flag with value 1 on top of 
the parameter stack. 



288 


CLN 27 H 
( X-1 Y-1 X-2 Y-2 — ) 

This word draws a line between the two given points. 
The breadth of the line depends on the shape of the 
current brush. 


CLRM1 23 H 

( - ) 

This command clears the whole BASIC mode 1 screen. 

COLOR! 24 H 

( color-value — ) 

This command stores the given color value in the 
current color register. 

DELLINE 23 H 

( line-1 line-2 — ) 

This command deletes the data between the two given 
lines in a BASIC mode 1 screen. 

DISK 40 H 

( - ) 

This command displays the disk operation menu and 
allows the user to select one of the disk operations. 



289 


DLIRTN1 7 L (ASM ONLY) 

( - ) 

This word is a assembly language subroutine which 
serves as a display list interrupt service routine for 
the main graphics screen to change colors in the text 
window of that screen. 

DLIRTN2 7 L (ASM ONLY) 

( - ) 

This word is a assembly language subroutine which 
serves as a display list interrupt service routine for 
the main menu screen to change colors on that screen. 
The color menu is obtained with the aid of this 
service routine. 


DRAW 

35 

H 



( - ) 





This command < 

draws points 

determined 

by the trace of 

the brush ( 

or cursor ) 

which is 

handled 

by the 

KoalaPad Touch 

Tablet. 




DRAWLN 

28 

H 



This command 

draws a line between 

the two 

points 

maintained in 

the FORTH 

variable, 

OLDCOL, 

OLDROW, 


NEWCOL and NEWROW. The breadth of this line depends 
on the shape of the current brush. 



290 


DZ00M 31 H 

( — ) 

This command sets the required data for the double¬ 
zoom mode environment and turns on that mode. 

ERASE 35 H 

( - ) 

This command erases points determined by the trace of 
the brush ( or cursor ) which is handled by the 
KoalaPad Touch Tablet. 

EXEC-CMD 45 H 

( command# — ) 

This command executes the command with the given 
command number by means of vectored execution. 

EXEC-ICMD 43 H 

( X Y command# — ) 

This command executes the command with the given 
command number by means of vectored execution. X and 
Y are used during the execution of the given command. 



291 


EXIT 41 H 

( — ) 

This command allows the user to exit FIGE. It 
displays a warning message to make sure that the 
current screen is saved before leaving, if that is 
desired. 

GET-CMD 44 H 

( — command# flag ) 

This word allows the user to select one of the 
commands from the main menu by using the KoalaPad. If 
the selected command is an immediate command, GET-CMD 
executes it immediately; otherwise, the command number 
and a proper flag are put on top of the parameter 
stack. 

i 

GET-NAME 37 H 

( — address flag ) 

This command repeatedly queries the user for a 
filename and checks in the directory until the 
filename has been found. It then puts the address of 
the directory entry and a flag with value 1 on top of 
the parameter stack. 



292 


GETPOIHT 21 H 

( — X Y flag ) 

This command repeatedly reads position values from the 
KoalaPad and moves the cursor until a proper button is 
pressed. If the read position values are valid, the 
read position values and a proper flag value are put 
on top of the parameter stack. 

GETXY 21 H 

( — X Y ) 

This command reads position values from the KoalaPad 
and moves the cursor to that position. 

GOODPOINT? 30 H 

( — flag ) 

This word examines the point maintained in the FORTH 
variable NEWCOL and NEWROW to see whether it is noise 
or not; if not, a flag with value 1 is returned. 

HDWPTS 27 H 

( incl inc2 difference end begin — ) 

This word applys Bresenham's Line Algorithm to draw a 
line by using the incremental values. The breadth of 
the line depends on the shape of the current brush. 



293 


HLN1 


17 

H 





( XI 

11 X2 Y2 — ) 






This 

word draws a 

horizontal 

line 

with 

breadth 


corresponding to brush 

1 . 




HLN2 


17 

H 





( XI 

Y1 X2 Y2 — ) 






This 

word draws a 

horizontal 

line 

with 

breadth 


corresponding to brush 

2. 




HLN3 


17 

H v 





( XI 

Y1 X2 Y2 — ) 






This 

word draws a 

horizontal 

line 

with 

breadth 


corresponding to brush 

3- 




HLN4 


17 

H 





( XI 

Y1 X2 Y2 — ) 






This 

word draws a 

horizontal 

line 

with 

breadth 


corresponding to brush 4* 


INITENV 46 


H 


( — flag 
This word 
the user 
main menu, 


displays the 
to enter "GO" 
and initializ 


title page for FIGE 
from a keyboard to 
es the environment. 


prompts 
load the 



294 


MARK-BRUSH 18 H 

( - ) 

This word marks the box of the current brush with two 
bright horizontal lines. 

MARK-COLOR 23 H 

( — ) 

This word marks the box of the current color with two 
bright horizontal lines. 

NCMD? 20 H 

( command# — ) 

This word displays the corresponding command name with 
the given command number on the message section with a 
label "NEW:". 


NZOOM 31 H 

( - ) 

This command sets the required data for the normal- 
zoom mode environment and turns on that mode. 

OCMD? 20 H 

( command# — ) 

This word displays the corresponding command name with 
the given command number on the message section with a 
label "CMD:". 



295 


ONE-POINT 21 H 

( — X Y flag ) 

This command gets one cursor position by using the 
KoalaPad. 

PADDRAW 30 H 

( - ) 

This command allows the user to draw points determined 

by the trace of the brush by using the KoalaPad Touch 

Tablet. 

PADPLOT 47 H 

( - ) 

This command allows the user to start FIGE. 

PL0T1 13 H 

( X Y — ) 

This word draws points around the given point 

determined by the shape of brush 1. 

PL0T2 13 H 

( X Y — ) 

This word draws points around the given point 

determined by the shape of brush 2. 



296 


PL0T3 13 H 

( X Y — ) 

This word draws points around the given point 
determined by the shape of brush 3* 


PL0T4 13 H 

( X Y — ) 

This word draws points around the given point 
determined by the shape of brush 4• 

PRINTER 40 H 

This word shows a message: "RESERVED FOR PRINTER". 

QZOOM 32 H 

( - ) 

This command sets the required data for the quadruple- 
zoom mode environment and turns on that mode. 

RESETDLI 8 H 

( — ) 

This command turns off the display list interrupt 


feature. 



297 


SET-BRUSH 19 H 

( X Y — ) 

This command converts the given X-Y coordinates to a 
brush number and marks the corresponding box of the 
brush shape as the current brush. 

SET-PIGS 19 H 

( 0 address X-reference Y-reference — ) 

This word assigns the given player shape data to all 
the four players. 

SETCOLOR 25 H 

( - ) 

This command displays a color menu which overlays the 
left-hand side of the main menu and allows the user to 
select a color for the current color. 

SETDLI 8 H 

( address — ) 

This command assigns an assembly language subroutine, 
whose entry point is at the given address, and the 
display list interrupt service routine is enabled. 



298 


SETLUMIN 23 H 

( X Y — ) 

This command adjusts the luminance of the current 
color to either darker or brighter determined by the 
given X-Y coordinate. 

SETPOINT 29 H 

( player# — X Y flag ) 

This word uses the given player as a cursor to select 
a point from the KoalaPad and maintains the selected 
point in a pair of proper FORTH variables for PADDRAW. 

SETZOOM 24 H 

( X Y — ) 

This command sets the current zoom mode to a zoom mode 
determined by the given X-Y coordinates. 

SHOW-DMENU 36 H 

( - ) 

This command displays the disk operation menu on the 
BASIC mode 1 screen. 

SHOW-MI 36 H 

( - ) 

This command displays the BASIC mode 1 screen. 



299 


SHOW-MENU 34 H 

( - ) 

This command displays the main menu on the display. 

SHOW-SCREEN 33 H 

( - ) 

This command displays the main graphics screen on the 
display. 

THREE-POINTS 22 H 

( — X-1 Y-1 X-2 Y-2 X-3 Y-3 flag ) 

This command gets three points from the KoalaPad by 
using three different players as the pointing cursors. 

TWO-POINTS 22 H 

( — X-1 Y-1 X-2 Y-2 flag ) 

This command gets two points from the KoalaPad by 
using two different players as the pointing cursors. 

UCOLOR 24 H 

( X Y — ) 

This command converts the given X-Y coordinates to a 
color number and marks the corresponding box of color 


as the current color. 



300 


USEBRUSH 19 H 

( brush# — ) 

This command assigns the brush shape of the given 
brush number to be the current cursor shape. 

USECOLOR? 24 H 

( X Y - flag ) 

This word checks to see if the given X-Y coordinates 
are located in the region of the usecolor command 
entry. 

VBDRTN 8 L (ASM ONLY) 

( - ) 

This word is an assembly language subroutine which is 
called by the vertical blank interrupt service routine 
to continue the user defined part of service. This 
word simply resets the color counter used by DLIRTN2 
to 0. 


VLN1 16 H 

( X-1 Y-1 X-2 Y-2 — ) 

This word draws a vertical line between the two given 
points. The breadth of the line depends on the shape 


of brush 1. 



301 


VLN2 


VLN3 


VLN4 


XCIR 


16 H 
( X-1 Y-1 X-2 Y-2 — ) 

This word draws a vertical line between the two given 
points. The breadth of the line depends on the shape 
of brush 2. 


16 H 
( x-1 Y-1 X-2 Y-2 — ) 

This word draws a vertical line between the two given 
points. The breadth of the line depends on the shape 
of brush 3• 


16 H 
( X-1 Y-1 X-2 Y-2 — ) 

This word draws a vertical line between the two given 
points. The breadth of the line depends on the shape 
of brush 4- 


26 H 

( X-center Y-center X Y — ) 

This command draws a circle with center at the first 
point and with radius determined by the distance 
between the first point and the second point. 



302 


XCLEAR 35 H 

( - ) 

This command clears the whole graphics screen if the 
user's response is to do so. 

XDEL 39 H 

( — ) 

This command deletes the given filename from the file 
directory and reassigns the used data sectors to the 
free sector list. 


XFCIR 26 H 

( X-center Y-center X Y — ) 

This command draws a filled circle with center at the 
first point and with radius determined by the distance 
between the first point and the second point. 

XGLOAD 39 H 

( - ) 

This command reloads the screen data and/or the 
display list from the given file. The filename is 


obtained from the input stream. 



303 


XG-SAVE 39 H 
( - ) 

This command saves the display list and/or the screen 
data as a file on disk. The filename is obtained from 
the input stream. 

XTEXT 31 
( X Y — ) 

This command draws 
interactively by user, 
given point. 

XY? 20 H 
( X Y - ) 

This word displays the given X-Y coordinates in the 
message section with the label: "X,Y", if the value of 
XYFLAG is 1. 


H 

a text string, entered 
on the display starting at the 


ZOOM 32 H 
( - ) 

This command sets up the environment for either 
normal-zoom mode, double-zoom mode or quadruple-zoom 
mode determined by the current zoom mode number. 



304 


ZOOM? 


20 H 

( zoom# — ) 

This word displays the name of the current zoom mode 
in the message section with a label "ZOOM:". 



APPENDIX D: SOURCE LISTING FOR PIGE 



L'EMQ ) 


SLR #3 
O ( t 


ir\s-fr n jl \ 


2 HEX 

3 GRAPHICS DEFINITIONS 

4 VOCABULARY DEMO 

5 DEMO DEFINITIONS 

6 


9 

10 


BCR #4 

0 ( GRAPHICS — CONSTANTS ) 


n 

BD10 

CONSTANT 

MAIN—DL 

9380 

CONSTANT 

MAIN—SCR 

3 

BDOO 

CONSTANT 

MENU—DL 

AO 10 

CONSTANT 

MENU—SCR 

4 

BCDO 

CONSTANT 

M1 -DL 

BCFO 

CONSTANT 

m _n? 

; ijl. 1/L. 

3 

BE 40 

CONSTANT 

DZGQM-DL 

BEDO 

CONSTANT 

QZOOM-DL 

/ 

o 

B910 

CONSTANT 

Ml2—SCR 




-? 

2F0 

CONSTANT 

CRSINH 





n 

O 

0 

VARIABLE 

CURR-CMD 

0 

VARIABLE 

CURR- 

9 

0 

VARIABLE 

XYFLAG 

0 

VAhIABLE 

PLVEC 

1 

A 

VARIABLE 

<_j| yrjQ 

o 

VARIABLE 

VLVEC 

1 1 
.i. i 

0 

VARIABLE 

CMDVEC 

0 

VAKIhBlE 

CURR- 

12 

Q 

V A RIA o L t. 

EXITFLG 





I -3 



307 


b'UH #L 

0 < GRAPHICS — DLS ) 


3 

iMENU-DL 

( — } 




3 

HERE >R 

MENU-DL DP ! 

4330 

, BF 40 , 

BOOS , 4E 

4 

AGIO , 

A 0 DO 9 0 DO 

OE C, 

LOOP SE 

C, LOOP 

£=* 

4E0E , 

B00O , 7 0 uQ 

OE C, 

LOOP 


6 

5 0 DO 

SE C, 9 0 DO 

OE C, 

LOOP LOOP 


7 

42b'0 n 

BF60 , 0202 , 

4102 

, BDSO , 

R> DP ? 


8 ; 

9 : fMAIN-DL < — ) 

10 MAIN—DL BESIN-DL 

11 MAIN—SCR D 50 MODE-LINE 

12 BF60 2 4 MODE-LINE END-DL 

13 SD MAIN-DL 54 + C! 

■i fi m 

j.*t ; 

15 —> 


SCR #6 

0 ( GRAPHICS — DLS ) 

1 i !DZOOM—DL < — ) 

2 DZOOM—DL MAIN—SCR A E 2S !ZGOM-DLS 

3 DA DZOOM-DL 73 + C! 


a 

Q 

10 


!QZOGM-DL i — ) 

QZOQM-DL MAIN—SCR 3 E 14 !ZOOM—DLS 
D3 QZOON-DL 3C + C? 

iMl—DL < — ) 

Ml—DL BEGIN-DL Ml2—SCR 6 IS MODE-LINE END-DL 


12 s iM2—DL < — ) 


M2-DL BEGIN-DL Ml2—SCR 7 C NODE-LINE END-DL 


14 






3 OS 


SCR #7 

O < GRAPHICS — DEMO ) 

1 DO16 CONSTANT COLPFO O VARIABLE COLNO 


3 1402 VARIABLE COLRPOOL 3424 , 5444 , 

4 7464 , 9484 , B4A4 , D4C4 , F4E4 , 92 C, 

5 

6 CODE DLIRTN1 ( — > 

7 PHA, CA # LDA, DO17 STA, 

a 92 # LDA, DOIS STA, PLA, RTI, 

9 


10 

11 

12 
-f ~T 

14 


CODE DLIRTN2 ( — ) 

PHA, IXA, PHA, COLNO LDX, COLRPOOL ,X LDA, 
DO15 STA, DOIS STA, O # LDA, D01A STA, 

28 * LDA, DO16 STA, CA # LDA, DO17 STA, 

INX, COLNO STX, PLA, TAX, PLA, RTI, 


1 =;_ 


SCR #8 

0 ( GRAPHICS — DEMO ) 

1 CODE VBDRTN < — ) 

2 0 # LDA, COLNO STA, VBDEXIT JMP, 

/t 

■** 

5 = SETDLI ( ADDR — ) 

6 SETDLIV ' VBDRTN SETVBD DLI-ON 

7 ; 

S : RESETDLI DLI-OFF RESETVBD ; < — > 

9 
10 
1 1 


14 


15 



SCR #9 


309 


0 < GRAPHICS — EDMO } 

1 

2 : INIT—SARRAY < BEGIN END — ) 

3 -FIND 

4 IF DROP CFA >R SNAP 

5 DU BL WORD HERE @ i = 

6 IF 1 BLK +! 0 IN ! BL WORD END IF 

7 HERE I 3 EXECUTE SARRAY! 

S LOOP R> DROP 

9 ELSE 2DR0F* . “ Undefined string array name 

10 END IF 

11 5 
12 
13 


SCR #10 

O ( GRAPHICS — EDMO > 


i-i 

6 


IS A SARRAY CMD-NAME 
0 IS INIT—SARRAY CMD-NAME 

POINT LINE DRAW ERASE TEXT BOX FBOX CIRCLE 
FCIRCLE FILL COPY MOVE CLEAR BCLEAR SETCOLOR 
DISK PRINTER SETZOOM SETZOOM SETCOLOR SETBRUSH 
LUMINACE EXIT GO USECOLQR 


9 IS CARRAY 

CMD- 

ATTR -19 

ALLOT 

10 0201 , 

0000 

, 0201 

, 0202 , 01 

11 0010 , 

1000 

, 1010 

, 1010 , 10 


i n ~ 

? * w ? 


1 o- 

14 

15 


0 VARIABLE CMEMU 9F ALLS' 


:menu AO OVER 


VO FF FILL 




310 


SCR #11 

0 < GRAPHICS — DEMO ) 

1 4 ARRAY BRUSH 4 ARRAY DBRUSH 


2 

0 VARIABLE BSH 

-POOL - 

2 ALLOT 


7T 

HERE 

0 

BRUSH ? 

3002 , 

SO C, 


4 

HERE 

I 

BRUSH ? 

E002 , 

EO C, 


ET 

HERE 

n 

BRUSH ? 

8006 , 

bOSO , 

8080 , 80 C, 

h 

HERE 

3 

BRUSH ! 

F802 , 

Fb L , 


— 

/ 

HERE 

4 

BRUSH ? 

800A , 

8080 , 

8080 , 8080 , 3030 

s 

HERE 

0 

DBRUSH 

! 3004 

, 8080 

, SO c. 

9 

HERE 

i 

DBRUSH 

i E004 

, EOEO 

, EO C, 

10 

HERE 

n 

DBRUSH 

! SOOC 

, SOSO 

, 8080 , 8080 , 

11 

8080 

, 8080 

, 80 C, 




HERE 


DBRUSH 

! FS04 

, FSF8 

, FS C, 

13 

HERE 

4 

DBRUSH 

! 3014 

Ml 

CD 

O 

CD 

O 

, 8080 , 8080 , 80S' 

14 

8080 

, SOSO 

, 8080 

, SOSO 

, 8080 , 80 C, 

15 

-> 







SCR #12 

0 ( GRAPHICS — DEMO > 

1 

2 0 VARIABLE MARKER -2 ALLOT 

3 14 C, FFFF , 0000 , 0000 , 0000 , 0000 , 


4 


0000 , 

0000 

, 0000 , 

3000 







A 

4 

CARRAY 

BRPX 

-5 ALLOT 


~7 


0 C , 1 

C, 0 

C, 2 C, 0 

c, 

s 

4 

CARRAY 

BRPY 

-5 ALLOT 


9 


0 C, 0 

C, 2 

C, 0 C, 4 

C, 

10 

4 

CARRAY 

DBRPX 

-5 ALLOT 


11 


0 C, 2 

C, 0 

C, 4 C, 0 

C, 

■s -~ 

X jC- 

4 

CARRAY 

DBRPY 

-5 ALLOT 


1 7 


o u 5 u 

C, 4 

c, 0 C, 8 

r 

w i 

14 







15 




GRAPHICS — DEMO ) 

PLOT1 < X Y — ) 

OVER I - OVER PLOT OVER 1+ OVER PLOT PLOT 

PL0T2 ( X Y — ) 

OVER OVER 1 - PLOT OVER OVER 1+ PLOT PLOT 

PL0T3 ( X Y — ) 

OVER 3 + BUP 5 - DO I OVER PLOT LOOP PLOT 

PL0T4 < X Y — ) 

SWAP OVER 3 + BUP 5 - 
DO BUP I PLOT LOOP SWAP PLOT 

15 10 LOAD 

SCR #14 

O < ERROR MESSAGES -fig-FORTH ) 

1 Stack empty 

2 Dictionary full 

3 Wrong address mode 

4 Isn't unique 

5 Vaiue error 

6 Disk address error 

7 Stack t Lt 11 

8 Disk Error! 




312 


-3l_-r\ tr 1 


s 

9 

10 

11 

12 


( ERROR -MESSAGES fig—FORTH } 

Use only in Definitions 
Ex ecut i on on 1 y 
Conditionals not paired 
Definition not finished 
In protected dictionary 
Use only when loading 
Off current screen 
Dec1 are VOCABULARY 
Nothing is wrong at all 


14 


:r 

o 

i 


< GRAPHICS — DEMO ) 

5 VLN1 < XI Y1 XI Y2 — > 

OFFSET>T 0 0 OFFSET? >R >R >R 
1 - R> R> If R > FBOX T>QFFSET 


-_j 

6 


>R >R 1 


R> R> If- VLINE 


o 

9 

10 
11 
12 

13 

14 


VLN3 < XI Y1 XI Y2 — ) 

OFFSET>T 0 0 OFFSET! >R >R >R 
2 — R > R > 2 + R> FBOX T>0FFSET 


rLN4 


( XI Y1 XI Y2 — ) 


>R >R 2 - R> R> 2 + VLINE 



313 


SCR #17 

0 < GRAPHICS — DEMO ) 

1 : HLN1 ( XI Y1 X2 Yl — ) 

2 >R >R >R 1 - R> R> 1+ R> OFFSET>7 

3 0 0 OFFSET! FBOX T>OFFSET ; 

4 : HLN2 < XI Y1 X2 Yl — ) 

5 OFFSET>T 0 U OhFSEl! >R >K 

6 1 - R> R> 1+ FBOX T>OFFSET 


/ ; 

S : HLN3 < XI Yi X2 Y1 — ) 

9 >R >R >R 2 — R X R> 2 + R > OFFSET>T 

10 0 O OFFSET! FBOX T>OFFSET ; 

11 : HLN4 < XI Yl X2 Yl — ) 

12 OFFSET>7 O 0 OFFSET! >R >R 

13 2 — R> R> 2 + FBOX TYOFFSET 

14 ; 

15 —> 


SCR #18 


v 

1 


GRAPHICS —DEMO ) 


ARRAY PLCFA -A ALLOT 


PLOT CFA 


PLOT1 CFA 


PLO!2 UFA 


4 

U 4 


S 4 
9 

10 
11 s 
i 2 

13 


Lr'r H , ' PLO i 4 CF A , 

ARRAY HLCFA -A ALLOT 

' HLINE CFA , *' HLN1 CFA , ' HLN2 CFA , 

- HLN3 CFA 5 ' HLN4 CFA , 

ARRAY VLCFA -A ALLOT 

- VLINE CFA , ' VLNi CFA , “ VLN2 CFA , 

' VLN3 CFA , ' VLN4 CFA , 

MARK-BRUSH < — ) 

CURR-PLAYER C@ 2 USEPLAYER CURR—BRUSH C0 
10 * 78 PLAYER USEPLAYER 


14 ^ 


j. ^ j 



314 


SCR #19 

0 ( GRAPHICS — DEMO ) 

1 : SETBRUSH < X Y — ) 

2 DROP 5 - F / CURR-BRUSH C! MARK-BRUSH 


4 : SETFIGS < 0 PDATA RPX RPY — ) 

5 4 0 DO 2QVER 20VER I SETPFIG DROP 

6 LOOP 2DR0P 2DR0P 

7 | 

8 : USEBRUSH ( BRUSH# — ) 

9 >R R PLCFA & F'LVEC ! R HLCFA @ HLVEC ! 


10 

R VLCFA % VLVEC ! 

CURR—ZOOM 00 2 

11 

IF 0 

R DBRUSH § R 

DBRPX 00 R DBRi 

12 

ELSE 

0 R BRUSH @ 

R BRPX 00 R BRP 

13 

END IF 

SETFIGS R> 

DROP 

14 ; 




15 — 





grp aro 

0 ( GRAPHICS — DEMO ) 

1 ; XY? < X Y — ) 

2 XYFLAG C@ IF 19 0 TXT—LOCATE 10 SPACES 

3 14 0 TXT-LOCATE ." X,Y :" SWAP 

4 ELSE 2DR0P ENDIF 


ii ii 

» ? 


6 ; OCMD? ( CMD# — ) 

7 2 0 TXT-LOCATE ." CMD : " CMD—NAME TYPE ; 

8 : NCMD7 ( CMD# — ) 

9 21 TXT-LOCATE ." NEW : " CMD—NAME TYPE ; 

10 5 ZOOM? < ZM# — ) 

11 14 O TXT-LOCATE .“ ZOOM : " DUP 0= 

12 IF . " Normal" DF:QP 

13 ELSE 1 = IF ," Double" ELSE 

14 ENDIF 


IF 


yuat 


END IF 



315 


:r #21 

0 < GRAPHICS — DEMO ) 

1 : GETXY < — X Y ) 

2 PADXY >3CRXY 2DUP ZPLAYER 


SETPOINT ( — X Y 1 C or LR O 1 ) 

BEGIN LBTN C@ UNTIL 

BEGIN GETXY 2BUP XY? R8TN C@ 

IF LBTM C@ IF 2BR0P 0 ELSE 2BUP BOUNDARY? 

IF 1 1 ELSE 2DR0P O O 1 ENDIF ENDIF 
ELSE 2DR0P 101 ENDIF 
UNTIL 

ONE-POINT < — X Y 1 Cor LR 03 ) 

0 USEPLAYER SETPOINT 


o 

9 
10 
11 


14 




1 


< GRAPHICS — DEMO ) 

TWO-POINTS < — XI Y1 X2 Y2 1 Cor 
ONE-POINT 1 FIXFLAG C! 

IF 1 USEPLAYER SETPOINT 

IF 1 ELSE O 2SWAP 2DR0P ENDIF 
ELSE 0 ENDIF 0 FIXFLAG Cl 


n 

O 

9 

10 


THREE-POINTS i — XI Yl 
TWO-POINTS 1 FIXFLAG C! 


Y2 X3 Y3 


or 0 J 


IF 2 USEPLAYER SETPOINT 

IF 1 ELSE >R 2DR0P 2DR0P R> 0 ENDIF 
ELSE 0 ENDIF 0 FIXFLAG C * 


ARRAY GETPTVEC -6 ALLOT 


14 ' ONE-POINT CFA , 

15 ' THREE-POINTS CFA 


TWO-POINTS CFA 





DEMO > 



< GRAPHICS — 


S 

9 


11 


14 


SETLUMIN < X Y — ) 

DROP CURR-COLOR CS SWAP 78 > 

IF BRIGHTER ELSE DARKER ENDIF 

MARK-COLOR < — > 

CSJRR-PLAYER C@ 1 USEPLAYER CURR-COLOR C® 
20 * 10 + -16 PLAYER USEPLAYER 

CLRM1 M12-SCR 1E0 0 FILL ; < — ) 

DELLINE < LI L2 — ) 

OVER - 1+ CURR-MODE C® BY/LN C® * O 
ROT POSITION DROP SWAP 0 FILL 


SCR #24 

0 { GRAPHICS — DEMO ) 

1 s UCOLQR ( X Y — ) 

2 DROP 10 - 20 / USECOLOR MARK-COLOR 

3 ; 

4 : SETZOOM ( X Y — ) 


5 DROP DUP 50 < 

-6 IF DROP O ELSE SO < IF 1 ELSE 2 END IF END 

7 DUP CURR-ZOOM C! ZOOM? 


n 

w 

9 

10 
i i 


USECOLOR? ( X Y - F ) 

0< OVER F > AND SNAP 90 < AND 

COLOR? < OVAL — ) 


CURR-COLOR C@ >CREG C! 



317 


SCR #25 

O < GRAPHICS — DEMO ) 

1 : SE7C0L0R ( — ) 

2 3 USEPLAYER O O PLAYER 0 USEPLAYER 

3 BEGIN BEGIN L8TN C@ UNTIL O 0 

4 BEGIN 2DRQP GETXY LBTN CS RBTN C0 AND NOT 

5 UNTIL RBTN C0 

6 IF 2DUP BOUNDARY? 


Q 

9 

10 


14 


IF OVER 20 < IF A / COLRPOOL + COLOR! ] 
ELSE DUP 78 > OVER SC < AND 
IF SETLUMIN 0 ELSE 2DR0P 1 EHD1F ENDIF 
ELSE 2DUP USECOLOR? 

IF UCOLOR O ELSE 2DR0P 1 ENDIF 


'Ur 


Q 


UNTIL 0 


IF 

2DROP 1 ENDIF 
3 HPOSPO + C 


i 




SCR #26 

O < GRAPHICS — DEMO ) 

4 

1 

2 s >CXYR ( CX CY X Y — CX CY R ) 

3 20VER ROT - ABS >R - ABS DUP DUP * R R * + 

4 SNAP R> + O SNAP DUP 1+ SNAP 2 •/ 

5 DO DROP I 2DUP DUP * < 

6 IF LEAVE ENDIF 

7 LOOP SNAP DROP 

W 5 

9 : XFCIR ( CX CY X Y — ) 

10 >CXYR FCIRCLE 

11 ; 

12 : XCIR < CX CY X Y — ) 

13 >CXYR CIRCLE 

14 ; 




GRAPHICS — DRAWLINE ) 

HDWPTS ( INCI INC2 DEFF XEND X ) 

>R >R 0 R> R> 

DO I XSIGN 0 + >R >R DUP XYSIGN 0 +- 0< 

IF >R OVER R> + R> 

ELSE OVER 4- R> YSIGN 0 + 

ENDIF R> OVER VL 0 IF SWAP ENDIF 
PLVEC 0 EXECUTE 
XSIGN 0 +LOQP 2DRQP 2DRQP 

CLN < XI Yi X2 Y2 — ) 

20VER 20VER 20VER OFFSET>7 OFFSET? ROT - ABS 
>R - ABS R> < VL ! >TEMP HCALINC 
O 0 PLVEC 0 EXECUTE HDWPTS T>0FFSE7 


Q 


GRAPHICS 


CL 


INE 


) , 


DRAWLN < — ) 

NEWCOL 0 NEWROW 0 OLDCOL 0 OLDROW 0 2QVER 
20VER 20VER DIRECTION 0= 

IF DROP HLVEC 0 EXECUTE 
ELSE 0= IF VLVEC 0 EXECUTE 
ELSE CLN ENDIF 

END IF 

OLDRQW ? OLDCOL ! 



319 


SCR #29 

0 ( GRAPHICS — SETPOINT ) 

1 O VARIABLE PLBTN 

2 : SETPOINT i N — X Y F ) 

3 LBTN C© PLBTN Cl >R 

4 I USEPLAYER O 0 

5 BEGIN 2BR0P GETXY 2DUP XY? 2DUP I 

6 IF NEWROW ! NEWCOL ! 

7 ELSE OLBRQW I OLBCOL ! 

3 ENDIF 2DUP BOUNDARY? 

9 IF LBTN C@ PLBTN C© AND 

10 ELSE 1 

11 ENDIF RBTN C© AND 0= 

12 UNTIL RBTN C© LBTN C© 0= AND R> DROP 

13 ; 

14 —> 

15 


SCR *30 

O ( GRAPHICS — PADDRAW 1/29/85 ) 

1 : SOODPGINT? ( — F ) 

2 NEWCOL © OLDCOL © - ABS 5 < 

3 NEWROW S OLDROW © - ABS 5 < AND 

4 5 

5 : PADDRAW < — ) 

S PLAYER-ON BEGIN RBTN CS SETPF 

7 WHILE 0 SETPOINT >R 2DR0P R> PLAYER-CLEAR 

8 IF BEGIN LBTN C© NOT 


9 

10 

11 

12 


14 


WHILE 1 SETPOINT 


IF GOGDPGINT? 

IF DRAWLN ENDIF 
ENDIF 2DR0P PLAYER-CLEAR 
REPEAT 

r-kin r r- 

CPi u i r 


REPEAT PLAYER-OFF 



320 


SCR #31 


v ^ 

1 : 
o 


A 


GRAPHICS — DEMO ) 
XTEXT BF8S 50 0 FILL 


2 0 TXT-LOCATE TEXT 


( — ) 


NZOOM ( — ) 

\ MAIN—DL SCREEN-OFF MAIN—DL SDLSTL ! SCREEN-ON 
0 ZFLAG C! D PMODE C! SINGLE-LINE 
SETPLAYERS 3 0 DO I SINGLE-SIZE LOOP 


o 

Q 


12 

13 

14 

15 


DZOGM ( — ) 

!DZOOM-DL DZOOM-DL ZDL-ADDR ! 1 ZFLAG C! A PMODE Cl 

50 ZXHIG ! 2S ZYHIG I 50 ZMLX ! 28 ZMLY ! 

SETPLAYER3 2 CK/PX C! ZXO 0 ZYO 2 POSITION FLUSHDL 
DOUBLE-LINE 3 O DO I DOUBLE-SIZE LOOP 


scr #: 
0 < 


4 


GRAPHICS — DEMO ) 

QZGGM ( — ) 

!QZOCM-DL QZOOM-DL ZDL-ADDR ! 1 ZFLAG C! 8 PMODE C! 

78 ZXHIG ! 3C ZYHIG ! 28 ZMLX ! 14 ZMLY ! 

SETPLAYERS 4 CK/PX C! ZXO 2 ZYO 2 POSITION FLUSHDL 
DOUBLE-LINE 3 O BO I QUAD-SIZE LOOP 


10 


'12 


14 


ZOOM ( — > 

CURR-ZOOM C2 DUP 0= 

IF NZOOM ELSE DUP 1 = IF DZOQM ELSE QZOOM ENDIF 
ENDIF CURR-CMD C2 DUP 2 = SWAP 3 = OR 
IF CURR-BRUSH CS USEBRUSH DROP 
ELSE 2 = IF O PDATA1 3 6 

ELSE O PDATAO 3 3 ENDIF SETFIGS 
ENDIF PLAYER-ON 


15 



DEMO ) 


-r r\ It-J 

0 ( GRAPHIC 


2 : SHOW-SCREEN ( — > 

3 iMAIN-DL BF&O AO 0 FILL D PX/BY C© PXBY C! 

4 D CURR—MODE Cl 00 9F 4F TWINDOW TW>W 

5 MAIN—SCR SCR—MEMORY ! 8F60 TXT—MEMORY I 

6 ' DLIRTN1 SETDLI ZOOM 1 XYFLAS C! 

7 4 SCROLL-LINES Cl CURR-CMD C© OCMD? 


10 

11 

12 

13 

14 


0 


o 

4 

5 
h 
7 


#34 

C GRAPHICS — DEMO ) 

: SHOW-MENU C — ) 

IMENU-DL BF60 AO 0 FILL ' DLIRTN2 SETDLI 
SCREEN-OFF MENU-DL SDLSTL ! SCREEN-ON 
MENU—SCR SCR-MEMORY ! BF60 TXT—MEMORY i 

1 26F Cl O O 9F 9F TWINDOW TW>W 

4 SCROLL-LINES C! E CURR-MODE C! E PMODE C! 
SETPLAYERS PLAYER-ON CMENU 0 0 3 SETPFIG 
3 QUAT-SIZE MARKER O 0 2 SETPFIG 

2 DOUBLE-SIZE MARKER 0 0 1 SETPFIG 1 QUAT-SIZE 
MARK-BRUSH MARK-COLOR CURR-CMD C© OCMD? 
CURR-ZOOM C© ZOOM? E PX/BY C© PXBY Cl 

O ZFLAG Cl 0 XYFLAG C! O USEPLAYER 
CURR-COLOR C-© USECQLOR 


14 




BCR #: 

o < 

1 2 


GRAPHICS — DEMO ) 
DRAW < — ) 

SHOW-SCREEN PADDRAW 


u- 

6 

7 

a 


ERASE < — ) 

CURR—COLOR C@ >R O USECOLQR DRAW R> USECOLOR 

X CLEAR < — ) 

SHOW-SCREEN 2 1 TXT—LOCATE 
, ” Are you SURE to discard the screen?” 


10 

2 2 TXT-LQCATE 


1 1 

. " Le-ft btni : YES 

Right btm i 

12 

BEGIN LBTM C@ DUP 

NOT 

13 

IF CLEAR ENDIF R 

:BTM C@ AND NOT 

14 

I IfvIT" T ? 

» X. L_ 


15 i 

/ 



BCR 
0 ( 

1 i 

n 

3 

4 


GRAPHICS — DEMO ) 

SHOW-MI ( — ) !Ml—DL 

SCREEN-OFF Ml—DL SDLSTL I SCREEN-ON 
6 CURR-MODE Cl 6 PMODE C! SETPLAYERS PLAYER-ON 
M12-SCR SCR-MEMORY ! M12-SCR TX7-MEMORY I 0 XYFLAG 
C! 0 0 13 17 TWINDOW TW>W 18 SCROLL-LINES Cl 
CURR-MODE C@ PX/BY C3 PXBY C! 0 ZFLAG Cl CLRM1 


8 : SHOW-DMENU ( — ) 

9 1 0 SCR-LOCATE ." 

10 32 SCR-LOCATE .” 

11 33 SCR-LOCATE ." 

12 34 SCR-LOCATE ." 

13 . " > DELETE FILE" 

14 37 SCR-LOCATE ." 


I Ml—DL 

disk operation menu" 

> DIRECTORY" 

> SAVE SCREEN" 

> LOAD SCREEN" 3 5 SCR-LOCATE 
3 6 SCR-LOCATE ." > FORMAT DI£ 

3 SCR-LOCATE 


i -_J 





SCR 


^5 

4 
3 
6 
7 

5 
9 

-a A 

i. 

11 
12 
13 
1 4 


#37 

< GRAPHICS — DEMO > 

5 GET-NAME < — ADDR F ) 

0 >R BEGIN ROW—SCR C@ 2 * 4 OVER + DECLINE 
R IF ." file NOT found" ENDIF CR 
." File Name: (XXXXX)“ E SPACES QUERY 
TIB @ IN @ + C@ 0= 

IF O 1 

ELSE FIND-FN 
IF 1 1 

ELSE R> DROP 1 >R 2 ROW-SCR CS 
1 - SCR—LOCATE 0 
END IF 
END IF 

UNTIL R> DROP 


SCR #38 


0 


6 

— 


10 

11 

12 

13 


* 4 OVER + DECLINE 
unique" ENDIF CR 


GRAPHICS — DEMO ) 

CHECK-NAME < — ADDR F ) 

O >R BEGIN ROW-SCR C@ 1 
R IF . " f ile N01 
. ■* File Name: (XXXXX) " E SPACES QUERY 
TIB @ IN @ + C@ 0= 

IF 0 1 

ELSE FIND-FN 

IF R> 2DR0P 1 >R 2 ROW-SCR CS 
1 - SCR-LOCATE 0 
ELSE Oil 
END IF 
END IF 

UNTIL R> DROP 


14 



324 


SCR #39 

O ( GRAPHICS — DEMO ) 

1 : XSSAVE ( — ) 

2 CHECK-NAME IF 2 2 TXT—LOCATE 0 DLFLAG C? 1 DDFLAG 

3 C! CURR-ZOOM C@ O CURR-ZOOM Ci SHOW—SCREEN 

4 . “ <SCREEN SAVING?" 0 (GSAVE) CURR-ZOOM Cl ENDIF 


5 5 

6 5 XGLQAD < — ) 

7 GET-NAME CR IF .» <SCREEN LOADING?" 1 (GLOAD) ENDIF 

a ; 

9 : XDEL ( — ) 

0 GET-NAME CR IF ." <FILE DELETING?" i (DELETE) ENDIF 


11 % 

12 4 ARRAY DISKVEC -A ALLOT 

13 ' DIR CFA , ' XSSAVE CFA , * XGLOAD CFA , 

14 ' XDEL CFA , ' FORMAT CFA , 

15 —> 


SCR #40 

0 < GRAPHICS — DEMO ) 

1 : DISK < — ) 

2 BEGIN SHOW-MI SHOW-DMENU 

3 BEGIN ONE-POINT 

4 IF SWAP DROP DUP 3 > OVER 10 < AND 

5 IF 4 - 2 / DUP 5 = 

6 IF DROP 1 1 ELSE DISKVEC @ EXECUTE 0 1 ENDIF 

7 ELSE DROP O ENDIF 

S ELSE 1 1 ENDIF 

9 UNTIL 

10 UNTIL 

U ; 

12 : PRINTER < — ) 

13 22 TXT-LOCATE ." RESERVED FOR PRINTER" 


14 




SCR #41 

O < GRAPHICS — DEMO ) 

1 : EXIT ( — ) 

2 BEGIN SHOW-MI 1 O SCR-LOCATE . " it is time to say" 

3 31 SCR-LOCATE ." GOOD BYE" 1 3 SCR-LOCATE 

4 .“ but be SURE to save" 3 4 SCR-LOCATE 

5 ." your NICE WORK!" 3 6 SCR-LOCATE .“ . SAVE SCREEN" 


6 37 SCR-LOCATE ." . BACK TO SYSTEM" 

7 3 S SCR-LOCATE ." . BYE-BYE" ONE-POINT 

3 IF SWAP DROP DUP B > OVER 12 < AND 

9 IF C - 2 / DUP 

10 IF 2 = IF 1 EXITFLG C! ENDIF 1 

11 ELSE DROP 1 9 SCR-LOCATE XGSAVE 0 ENDIF 

12 ELSE DROP 0 ENDIF 

13 ENDIF 

14 UNTIL 

15 | —> 


SCR #42 

0 ( GRAPHICS — DEMO ) 

1 18 ARRAY CMD-CFA -32 ALLOT 

2 ' PLOT CFA , ' LINE CFA 

3 ' ERASE CFA , 

4 ' FBOX CFA , 

5 ' BFILL CFA , 

6 ' XCLEAR CFA 

7 ' DISK CFA , 

8 ' SETZOOM CFA 

9 ' SETLUMIN CF 

10 ' UCOLOR CFA 


XTEXT CFA , 
XCIR CFA , ' 

RCOPY CFA , 

' BCLEAR CFA 
PRINTER CFA 


draw cfa . 

' BOX CFA , 

XFCIR CFA , 

' RMOVE CFA , 

, ' SETCOLQR CFA 

, ' SETZOOM CFA , 


SETCOLOR CFA , 
EXIT CFA , 0 


SE i BRUSH UFA 


12 


■s err 
± U 





DEMO ) 


SCR #43 


( GRAPHICS — 


1 : 

>CMD# ( X Y — CMD# 1 

or 0 ) 



2DUP BOUNDARY? 



■u> 

IF DUP 78 < 



4 

IF IE / 5 * SWAP 5 

- IE / + 


5 

ELSE 78 - 14 / 2 * 

SWAP 50 / 

-t- 14 

A 

ENDIF 1 



~7 

ELSE USE-COLOR? IF 18 

1 ELSE 0 

END IF 

r~, 

u 

END IF 



9 ; 




10 : 

EXEC-ICMD ( X Y CMD# 

— ) 


11 

DUP E = OVER 13 = OR 

OVER 16 = 

GR 

12 

IF SWAP DROP SWAP DR 

OP END IF 



CMD-CFA © EXECUTE 




14 
i *3 


0 < 

GRAPHICS — DEMO ) 


1 s 

X « 

GET-CMD ( — CMD# 1 or 0 ) 


2 

BEG IN 


3 

BEGIN GETXY 2DUP >CMDS 


4 

IF DUP NCMD? LBTN C© IF 

2DR0P 

Zj 

ELSE 2DR0P 0 ENDIF 


6 

UNTIL DUP 16 = OVER 17 = 

OR 

7 

IF 16 = IF EXIT 2DR0P 0 


3 

ELSE 2DUP CURR-CMD CS 1 

9 

ELSE DUP CMD-ATTR C© 10 = 


10 

IF EXEC-ICMD 


11 

ELSE DUP CURR-CMD C! OCMD? 2DR 

i 3 

ENDIF 0 


1 j 

END IF 


14 

UNTIL RESETDLX 


15 ; 

— > 



imiF i 


326 


END 1 r 



SCR #45 

0 < GRAPHICS — DEMO ) 

1 : EXEC-CHD ( CHD# — > 

2 DUP CliD-CFA @ >R CMD-ATTR C® DUP 

3 IF SHOW-SCREEN 

4 BEGIN DUP GETPTVEC € EXECUTE 

5 IF R EXECUTE O ENDIF PMBASE € SCO O FILL 

6 UNTIL RESETDLI 

7 ELSE R EXECUTE 

3 END IF R> 2DRGP 

9 ? 

10 

11 

12 

13 

14 

15 —> 


iCR #46 

0 ( GRAPHICS — DENG ) 

1 : INITENV < — F ) 

< 

2 CA2S 2C4 ! 4694 206 ! O 203 0! SHOW-MI 

3 BEGIN CLRM1 13 RMGN C! 

4 5 O SCR-L0CA7E . '* WELCOME TO” 7 1 SCR-LOCATE 

5 . ” F'ADF'LOT" 9 4 SCR-LOCATE . " BY" 4 5 SCR-LOCATE 

6 ." JER-MING LEE" S 6 SCR-LOCATE . " 1985" 

7 O 7 SCR-LOCATE 14 0 DO ." LOOP 0 F 13 17 

8 WINDOW 2 8 SCR-LOCATE ." Insert Screen disk" 

9 ," Type 'GO' to start" QUERY TIB % IN % + DUP <§ 

10 4F47 = IF DROP CR <WAIT>" GLOAD 0 CURR-ZOOM C! 

11 0 CURR—BRUSH C! 0 CURR-CMD C! 1 CR3INH C! 1 1 

12 ELSE D! IF 0 ELSE O 1 ENDIF ENDIF 

13 UNTIL 27 RMGN Ci MAIN-SCR COO O FILL 1 USECOLOR 


14 



o 


DEMO ) 


GRAPHICS 


2 : PADPLOT i — ) 

3 INITENV 0 EXITFLG Cl 

4 IF BEGIN SHOW-MENU GET-CMD 

5 IF EXEC—CMD ENDIF 

6 EXITFLG OS 

7 UNTIL 

3 MQDEO 0 CRSINH Cl 20 TXT—LOCATE 

9 . ” EDN OF PADPLOT" CR PLAYER-OFF 

10 END IF 

11 ; 

■* *"7 

13 FORTH DEFINITIONS 

14 DECIMAL 

15 ; S 


329 


REFERENCES 


1. Foley, J. D. and A. V. Dam, Fundamentals of Interactive 
Graphics, Addison-Wesley Publishing Company, pp. 3* 

2. Tenney, G. S., "TURTLETALK: A LOGO-like turtle graphics 
environment," 1981 FORM! Proceedings, vol. 2, p. 521. 

3. Miller, D., "The DATAHANDLER: A Simple, High-Speed 

Database Application in MMSFORTH," 1982 Rochester Forth 
Conference on Data Bases and Process Control, p. 39* 

4. Bowhill, S. A. and F. Keasler, "FORTH System for Radar 
Control and Data Aquisition Using a Microcomputer," 
1982 Rochester Forth Conference on Data Base and 
Process Control, p. 313* 

5- Foley, J. D. and A. V. Dam, Fundamentals of Interactive 
Graphics, Addison-Wesley Publishing Company, p. 432. 

6. Foley, J. D. and A. V. Dam, Fundamentals of Interactive 
Graphics, Addison-Wesley Publishing Company, p. 433* 

7. Foley, J. D. and A. V. Dam, Fundamentals of Interactive 
Graphics, Addison-Wesley Publishing Company, p. 442. 

8. Foley, J. D. and A. V. Dam, Fundamentals of Interactive 
Graphics, Addison-Wesley Publishing Company, p. 445* 

9. Foley, J. D. and A. V. Dam, Fundamentals of Interactive 
Graphics, Addison-Wesley Publishing Company, p. 442. 

10. Foley, J. D. and A. V. Dam, Fundamentals of Interactive 
Graphics, Addison-Wesley Publishing Company, p. 448. 

11. Foley, J. D. and A. V. Dam, Fundamentals of Interactive 
Graphics, Addison-Wesley Publishing Company, p. 450. 



330 


REFERENCES NOT CITED 


1. Rogers, D. P. and J. A. Adams, Mathematical Elements 
for Computer Graphics, 1978.. 

2. Compute!'s Second Book of ATARI, Published by Compute! 
Books, 1982. 

3. Chadwick, I., Mapping the ATARI, Compute! Publications, 
Inc, 1983* 

4. Leventhal, L. A., 6502 Assembly Language Programming, 

Osborne/McGraw-Hill, 1979* 

5- Brodie, L., Starting FORTH, Prentice-Hall, 1982. 

6. Derick, M. and L. Barker, FORTH Encyclopedia, Mountain 
View Press, 1982. 



