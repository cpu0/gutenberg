REPORT DOCUMENTATION PAGE 

I J — k7^ timated to average 1 hour per response, including the l 

* w # “fr viewing the collection of information. Send comment 


Form Approved 
OPMNo. 


timated to average 1 hour per response, including the time tor reviewing Instructions, searching ex! .jng data 
viewing the collection ol information. Send comments regadlng this burden, to Washington Headquarters 
1215 Jefferson Davis Highway. Suite 1204, Arlington, VA 22202-4302, and to the Office of Information and 
gton, DC 20503. 


I 2. REPORT 


3. REPORT TYPE AND DATES 


4. TITLE AND: Alsys Corporation, Cornpiler: AlsyCOMP_17 Version 5.4.10 
Host: VAXstation 4000 Model 60 (under VAXA/MS V 5.5-2) 

Target: INMOS T9000 transputer Gamma D02 installed on an INMOS VME 
TestBoard (Bare), VC#: 940826N 1.11375 


6. Authors: The Naitonal Computing Centre, Ltd. 


tv 



7. PERFORMING ORGANIZATION NAME (S) AND: 

The National Computing Centre, Ltd. 

Oxford Road 
Manchester Ml 7ED 
England 


9. SPONSORING/MONITORING AGENCY NAME(S) AND: 

Ada Joint Program Office, Defense Information Systems Agency 
Code TXEA, 701 S. Courthouse Rd. 

Arlington, VA 22204-2199 


m 


. PERFORMING 
(RGANIZATION 


10. SPONSORING/MONITORING 
AGENCY 



12a. DISTRIBUTION/AVAILABILITY: Approved for Public Release: distribution 12b. DRISTRIBUTION 
unlimited 



15. NUMBER OF 


14. SUBJECT: Ada Programming Language, Ada Compiler Validation Summary 
Report, Ada Compiler Validation Capability Validation Testing, Ada Validation Office, 

Ada Validation Facility, ANSI/MIL-STD-1815A, AJPO i -jg price 


17 SECURITY 
CLASSIFICATION 

UNCLASSIFIED 




18. SECURITY 

19. SECURITY 


CLASSIFICATION 

UNCLASSIFIED 

UNCLASSIFIED 


20. LIMITATION OF 


UNCLASSIFIED 






















AVF Control Number: AVF_VSR_05401/87-940831 


Ada COMPILER 

VALIDATION SUMMARY REPORT: 
Certificate Number: #940826N 1.11375 
ALSYS LIMITED 
AlsyCOMP_017 Version 5.4.10 
VAXstation 4000 Model 60 Host and 
INMOS T9000 transputer Gamma D02 on 
an INMOS VME TestBoard Target 


Prepared By: 

Testing Services 

The National Computing Centre Limited 
Oxford Road 
Manchester 
Ml 7ED 
England 


Accesion For 

NTIS CRA&I 
DTIC TAB 
Unannounced 
Justification 

r 

□ 


By 

Distrib 

jtion / 



Avnilabili- 

y Codes 


Dist 

Avail 

Spc 

- c! j or 
cial 


ttL 





Template Version 94-05-11 X)TIC QUALITY TUHTTCTYD - 


94-32008 

, 11111111114/ 

flint •54 <> 


o 


Validation Sunnary Report 
Alsys United 


AVF_VSR_05401/87-940831 
A1 syCOHP_017 Version 5.4.10 









TABLE OF CONTENTS 


TABLE OF CONTENTS 
CHAPTER I INTRODUCTION 


1.1 USE OF THIS VALIDATION SUMMARY REPORT. 1 

1.2 REFERENCES . 1 

1.3 AC VC TEST CLASSES. 2 

1.4 DEFINITION OF TERMS. 3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS. I 

2.2 INAPPLICABLE TESTS. 1 

2.3 TEST MODIFICATIONS . 4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT . 1 

3.2 SUMMARY OF TEST RESULTS . 2 

3.3 TEST EXECUTION. 2 

APPENDIX A MACRO PARAMETERS . 1 

APPENDIX B COMPILATION SYSTEM OPTIONS . 1 

APPENDIX C APPENDIX F OF THE Ada STANDARD . 1 


Validation Suanary Report 
Alsys Malted 


AVF_VSR_05401/87-940831 
A1 syC0MP_017 Version 5.4.10 



















Certificate Information 


The following Ada implementation was tested and determined to pass AC VC Ml. Testing was completed on 
24 August 1994. 

Compiler Name and Version: AlsyCOMP_017 Version 5.4.10 

Host Computer System: VAXstation 4000 Model 60 (under VAX/VMS V 5.5-2) 

Target Computer System: INMOS T9000 transputer Gamma D02 installed on an INMOS 

VME TestBoard (Bare) 

See section 3.1 for any additional information about the testing environment. 

As a result of this validation effort. Validation Certificate #940826N1.11375 is awarded to Alsys Limited. This 
certificate expires 2 years after ANSI/MIL-STD-1815B is approved by ANSI. 

This report has been reviewed and is approved. 




Jon Leigh 
Manager, System Software Testing 
The National Computing Centre Limited 
Oxford Road 
Manchester 
Ml 7ED 
England 



Ada V^icfetjbirOrganization 
Director, Computer and Software Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 



Donald J Re 
Director, Aa^Jdint Program Office 
Defense Information Systems Agency 
Centre for Information Management 
Washington DC 20301 


Validation Suaury Report 
Alsys Halted 


AVF_VSR_05401/87• 940831 
AlsyCOMP_017 Version 5.4.10 




DECLARATION OF CONFORMANCE 


DECLARATION OF CONFORMANCE 

The following declaration of conformance was supplied by the customer. 

Declaration of Conformance 
Customer: ALSYS LIMITED 

Ada Validation Facility: The National Computing Centre Limited 

ACVC Version: 1.11 

Ada Implementation: 

Ada Compiler Name and Version: AlsyCOMP_OI7 Version 5.4.10 

Host Computer System: VAXstation 4000 Model 60 (under VAX/VMS V 5.5-2) 

Target Computer System: INMOS T9000 transputer Gamma D02 installed on an INMOS 

VME Testboard (Bare) 

Declaration: 

I, the undersigned, declare that [I/we] have no knowledge of deliberate deviations from the Ada Language 
Standard ANSI/MIL-STD-1815A, ISO 8652-1987, FIPS 119 as tested in this validation and documented in the 
Validation Summary Report. 



Validation Summary Report 
Alsys Limited 


AVF_VSR_05401/87-940815 
A1 syCOMP_017 Version 5.4.10 





TABLE OF CONTENTS 


INTRODUCTION 


1 Implementation-Dependent Pragmas 

1.1 INLINE 

1.2 INLINEGENERIC 

1.3 INTERFACE 

1.3.1 Calling Conventions 

1.3.2 Parameter-Passing Conventions 

1.3.3 Parameter Representations 

1.3.4 Restrictions on Interfaced Subprograms 

1.4 INTERFACENAME 

1.5 NOIMAGE 

1.6 INDENT 

1.7 Other Pragmas 

2 Implementation-Dependent Attributes 

3 Specification of the Package SYSTEM 

4 Restrictions on Representation Clauses 

4.1 Enumeration Types 

4.2 Integer Types 

4.3 Floating Point Types 

4.4 Fixed Point Types 

4.5 Access Types 

4.6 Task Types 

4.7 Array Types 

4.8 Record Types 


Table of Contents 





5 

Conventions for Implementation-Generated Names 

51 

6 

Address Clauses 

53 

6.1 

Address Clauses for Objects 

53 

6.2 

Address Clauses for Program Units 

53 

6.3 

Address Clauses for Entries 

53 

7 

Restrictions on Unchecked Conversions 

55 

8 

Input-Output Packages 

57 

8.1 

NAME Parameter 

57 

8.2 

FORM Parameter 

57 

8.2.1 

File Sharing 

58 

8.2.2 

Binary Files 

59 

8.2.3 

Buffering 

60 

8.2.4 

Appending 

61 

8.3 

USEERROR 

61 

9 

Characteristics of Numeric TVP es 

63 

9.1 

Integer Types 

63 

9.2 

Floating Point Type Attributes 

64 

9.3 

Attributes of Type DURATION 

65 

REFERENCES 

67 

INDEX 


69 


IV 


Alsys Ada for the Transputer, Appendix F, \<5.4 




INTRODUCTION 


Implementation-Dependent Characteristics 


This appendix summarizes the implementation-dependent characteristics of the Alsys Ada 
Compilers for INMOS transputers. This document should be considered as the Appendix 
F to the Reference Manual for the Ada Programming Language ANSI/MIL-STD 1815A, 
January 1983, as appropriate to the Alsys Ada implementation for the transputer. 

Sections 1 to 8 of this appendix correspond to the various items of information required in 
Appendix F [F]*; sections 9 and 10 provide other information relevant to the Alsys 
implementation. The contents of these sections is described below: 

1. The form, allowed places, and effect of every implementation-dependent pragma. 

2. The name and type of every implementation-dependent attribute. 

3. The specification of the package SYSTEM (13.71. 

4. The list of all restrictions on representation clauses (13.1]. 

5. The conventions used for any implementation-generated names denoting 
implementation-dependent components (13.4). 

6. The interpretation of expressions that appear in address clauses. 

7. Any restrictions on unchecked conversions (13.10.2). 

8. Any implementation-dependent characteristics of the input-output packages [14], 

9. Characteristics of numeric types. 


* Throughout this manual, citations in square brackets refer to the Reference Manual 
for the Ada Programming Language, ANS1/M1L-STD-1815A, January 19S3. 


1 


Implementation-Dependent Characteristics 





Throughout this appendix, the name Ada Run-Time Executive refers to the run-time 
library routines provided for all Ada programs. These routines implement the Ada heap, 
exceptions, tasking control, I/O, and other utility functions. 


2 


AlsysAda for the Transputer, Appendix F, v5.4 




CHAPTER 1 


Implementation-Dependent Pragmas 
1.1 INLINE 

Pragma INLINE is fully supported, except for the fact that it is not possible (o inline a 
function call in a declarative part. 


1.2 INLINE GENERIC 

The pragma INLINEGENERIC takes the name of a generic unit or of an instance of a 
generic unit as argument. 

When the argument is the name of a generic unit, pragma INLINE GENERIC specifies that 
all the instances of the generic unit will be generated in line (and not in a subunit) 
regardless of the value of the option GENERICS of the command COMPILE. 

When the argument is the name of an instance of a generic unit, pragma INLINE GENERIC 
specifies that this instance will be generated in line (and not in a subunii) regardless of the 
value of the option generics of the command COMPILE. 

pragma INLINE GENERIC (Ada-designator {, Ada_dest & \alor }) 

Example: 

procedure MY_PROCEDURE is 
type MY TYPE is (...); 
generic 

procedure MYFIRSTGENERIC; 
generic 

type T is (< >); 

function MY_SECOND_GENERlC(L,R : T) return T; 


Implementation-Dependent Pragmas 


3 




function MY_SECOND_GENERIC(L,R : T) return T is 
begin 

end; 


function “+" is new MY SECOND GENERIC(MY TYPE); 

pragma 1NLINE_GENERIC(MY_FIRST_GENERIC," + "); 

procedure MYF1RSTGENER1C is 
begin 

end; 


end MY PROCEDURE; 

Limitations on the use of pragma !NL!NE_GENERIC 

• This pragma is only allowed at the place of a declarative item in a declarative part or 
package specification, or after a library unit in a compilation but before any 
subsequent compilation unit. If the pragma appears at the place of a declarative 
item, each argument must denote a generic unit, or an instance of a generic unit, 
declared by an earlier declarative item of the same declarative part or package 
specification. If several (overloaded) subprograms satisfy this requirement, the 
pragma applies to all of them. If the pragma appears after a given library unit, the 
only name allowed is the name of this unit, which must be a generic unit. 

• If an instance cannot be generated in line, in spite of a valid pragma 

INLINE GENERJC, a warning will be emitted and the instance will be generated in a 
subunit. This will occur in particular when (he body of the generic unit has not been 
compiled at the point of instantiation. This will also happen on instances appearing 
within the specification of a generic package (due to a restriction of the Alsys 
implementation). 


4 


Alsys Ada for the Transputer, Appendix F, v5.4 




13 INTERFACE 


Ada programs can interface to subprograms written in occam through the use of the 
predefined pragma INTERFACE (13.9) and the implementation-defined pragma 
INTERFACE_NAME. 

Pragma INTERFACE specifies the name of an interfaced subprogram and the name of the 
programming language for which calling and parameter passing conventions will be 
generated. Pragma INTERFACE takes the form specified in the Reference Manual: 

pragma INTERFACE ( language name, subprogram name); 

where: 

• language name is the name of the other language whose calling and parameter 
passing conventions are to be used. 

■ subprogram name is the name used within the Ada program to refer to the 
interfaced subprogram. 

The language names currently accepted by pragma INTERFACE are OCCAM and 
OCCAMHIGH. 

The language name used in the pragma INTERFACE does not necessarily correspond to the 
language used to write the interfaced subprogram. It is used only to tell the Compiler how 
to genera: subprogram calls, that is, which calling conventions and parameter passing 
techniques to use. 

The language name OCCAM is used to refer to the standard occam calling and parameter 
passing conventions for the transputer (Ref. 4, Section 5.10). The programmer can use 
the language name OCCAM to interface Ada subprograms to subroutines written in any 
language that follows the standard occam calling conventions. 

The programmer can use the language name OCCAM HIGH to run the interfaced 
subroutine as a high priority process instead of a low priority process. The 
OCCAM HIGH interface is otherwise identical to the OCCAM interface. 


1.3.1 Calling Conventions 

The following calling conventions are required for code to be called from Ada by use of 
pragma INTERFACE. 


Implementation-Dependent Pragmas 


5 



On entry to the subprogram, the registers A, B and C are undefined. For the T8 and 
T9000, the floating point registers FA, FB and FC are similarly undefined. The return 
address and any parameters are accessed relative to the workspace pointer, W, by the 
subprogram. 

There are no assumptions concerning the contents of the register stacks (A, B, C and FA, 
FB, FC) upon return from the interfaced subprogram, other than for interfaced 
subprograms which are functions (see below). However, the workspace pointer, W, 
should contain the same address upon return from the interfaced subprogram as it 
contained before the call. 

On the T4 and T8 the setting of the error flag is ignored on return. 


1.3.2 Parameter-Passing Conventions 

On entry to the subprogram, the word at offset 0 from the transputer workspace (W) 
pointer contains the return address of the called subprogram. Subsequent workspace 
locations (from W +1 to W + n, where n is the number of parameters) contain the 
subprogram parameters, which are all one word in length. 

There is always an implicit vector space parameter passed as the last parameter to all 
interfaced subprograms. This points to an area of free memory which can be used by the 
occam compiler to allocate arrays declared in the interfaced subprogram. 

Actual parameters of mode in which are access values or scalars of one machine word or 
less in size are passed by copy. If such a parameter is less that one machine word in 
length it is sign extended to a full word. For all other parameters of mode in, and all 
parameters of mode in out or out, the value passed is the address of .he actual parameter 
itself. 

Since all large scalar, non-scalar and non-access parameters to interfaced subprograms 
are passed by address, they cannot be protected from modification by the called 
subprogram even though they may be formally declared to be of mode in. It is the 
programmer’s responsibility to ensure that the semantics of the Ada parameter modes are 
honoured in these cases. 

If the interfaced subprogram is a function, the result is returned as follows: 

A floating point rcsub is returned in register FPA. 


6 


Alsys Ada for the Transputer, Appendix F, v5.4 






Any other result is returned by value in register A if its size is at most one machine 
word and by address in register A otherwise. 

No consistency checking is performed between the subprogram parameters declared in 
Ada and the corresponding parameters of the interfaced subprogram. It is the 
programmer’s responsibility to ensure correct access to the parameters. 

1.3.3 Parameter Representations 

This section describes the representation of values of the types that can be passed as 
parameters to an interfaced subprogram. The discussion assumes no representation 
clauses have been used to alter the default representations of the types involved. Chapter 
4 describes the effect of representation clauses on the representation of values. 

Integer Types [3.5.4] 

Ada integer types are represented in two’s complement form and occupy a byte 
(SHORT INTEGER) or a word (INTEGER). 

Parameters to interfaced subprograms of type SHORTINTEGER are passed by copy with 
the value sign extended to a full machine word. Values of type INTEGER are always passed 
by copy. The predefined type LONG INTEGER is not available. 

Enumeration Types [3.5.1] 

Values of an Ada enumeration type are represented internally as unsigned values 
representing their position in the list of enumeration literals defining the type. The first 
literal in the list corresponds to a value of zero. 

Enumeration types with 256 elements or fewer are represented in 8 bits. All other 
enumeration types are represented in 32 bits. 

Consequently, the Ada predefined type CHARACTER [3.5.2] is represented in 8 bits, using 
the standard ASCII codes [C] and the Ada predefined type BOOLEAN [3.5.3] is represented 
in 8 bits, with FALSE represented by the value 0 and TRUE represented by the value 1. 

As the representation of enumeration types is basically the same as that of integers, the 
same parameter passing conventions apply. 


Implementation-Dependent Pragmas 


7 






Floating Point Types [3-S.7,333] 

Ada floating-point values occupy 32 (float) or 64 (LONGFLOAT) bits, and are held in 
ANSI/IEEE 754 floating point formal. 

Parameters to interfaced subprograms of type FLOAT are always passed by copy. 
Parameters of type LONG FLOAT are passed by address. 

Fixed Point Types [33.9,33.10] 

Ada fixed-point types are managed by the Compiler as the product of a signed mantissa 
and a constant small. The mantissa is implemented as an S or 32 bit integer value. Smalt 
is a compile-time quantity which is the power of two equal or immediately inferior to the 
delta specified in the declaration of the type. 

The representation of an actual parameter of a fixed point type is the value of its mantissa. 
This is passed using the same rules as for integer types. 

The attribute MANTISSA is defined as the smallest number such that: 

2 ** MANTISSA > = max (abs (upper_bound), abs (lower_bound)) / small 

The size of a fixed point type is: 

MANTISSA Size 

1.. 7 8 bits 

8 .. 31 32 bits 

Fixed point types requiring a MANTISSA greater than 31 are not supported. 

Access Types [3.8] 

Values of access types are represented internally by the address of the designated object 
held in single word. The value MIN INT (the smallest integer that can be represented in a 
machine word) is used to represent null. 

Array Types [3.6] 

Ada arrays are passed by address; the value passed is the address of the first element of 
the first dimension of the array. The elements of the array are allocated by row. When an 
array is passed as a parameter to an interfaced subprogram, the usual consistency 
checking between the array bounds declared in the calling and the called subprogram is 
not enforced. It is the programmer’s responsibility to ensure that the subprogram does 
not violate the bounds of the array. 


8 


Alsys Ada for the Transputer, Appendix F, v5.4 








When passing arrays to Occam, it may be the case that some of its bounds are undefined in 
the source of the interfaced subprogram. If this is true, the missing bounds should be 
passed as extra integer value parameters to the subprogram. These parameters should be 
placed immediately following the array parameter itself and in the same order as the 
missing strides appear in the occam source. 

Values of the predefined type STRING [3.6.3] are arrays, and are passed in the same way: 
the address of the first character in the string is passed. Elements of a string are 
represented in 8 bits, using the standard ASCII codes. The elements are packed into one 
or more words and occupy consecutive locations in memory. 

Record Types [3.7] 

Ada records are passed by address; the value passed is the address of the first component 
of the record. Components of a record are aligned on their natural boundaries (e.g. 
INTEGER on a word boundary) and the components may be re-ordered by the Compiler so 
as to minimize the total size of objects of the record type. If a record contains 
discriminants or components having a dynamic size, implicit components may be added to 
the record. Thus the default layout of the internal structure of the record may not be 
inferred directly from its Ada declaration. The use of a representation clause to control 
the layout of any record type whose values are to be passed to interfaced subprograms is 
recommended. 

1.3.4 Restrictions on Interfaced Subprograms 

Interfaced subprograms must be compiled using an error mode compatible with that used 
by the Ada runtime system to avoid errors when linking. For T4 and T8 mode S (STOP) 
or X (UNIVERSAL) should be used and for T9000 mode H (HALT) or X 
(UNIVERSAL) should be used. 

There is no mechanism to allow runtime errors in interfaced subprograms to 
automatically raise an Ada exception. Interfaced subprograms should be written to 
explicitly deal with any errors likely to occur at runtime and return an error indication to 
the Ada program using an out parameter or a function result. 

On T4 and T8, if the interfaced subprogram causes a process halt as a result of executing a 
STOPP or STOPERR instruction, the calling Ada task will become permanently blocked 
and will never terminate. On T9000 an interfaced subprogram is called with a null trap 
handler, so unless the subprogram installs its own handler any errors resulting in a trap 
will cause a process halt and will permanently block the calling Ada task. 


Implementation-Dependent Pragmas 


9 




In view of this, the use of runtime checking code added by the occam compiler is limited, 
and it is often convenient to suppress it using option U. 

Parameters which are of a task or private type, or are access values not of mode in, should 
not be passed to interfaced subprograms. 

It is not possible to interface to Occam functions which have more that one return val' 
Unconstrained records and arrays cannot be returned from interfaced subprogram^ 


10 


AlsysAda for the Transputer, Appendix F, vS.4 




1.4 INTERFACE NAME 


Pragma INTERFACENAME associates the name of an interfaced subprogram, as declared 
in Ada, with its name in the language of origin. If pragma INTERFACE NAME is not used 
the Ada name in uppercase is used as its name in the interfaced language. 

This pragma takes the form: 

pragma INTERFACE NAME (subprogram jumte, string literal ); 
where.' 

• subprogram name is the name used within the Ada program to refer to the 
interfaced subprogram. 

■ string literal is the name by which the interfaced subprogram is referred to at link¬ 
time. 

The use of INTERFACE NAME is optional and is not needed if a subprogram has the same 
name in Ada as in the language of origin. It is necessary, for example, if the name of the 
subprogram in its original language contains characters that are not permitted in Ada 
identifiers or contains lowercase letters. Ada identifiers can contain only letters, digits and 
underscores, whereas the INMOS linker allows external names to contain other characters, 
for example full stops. These characters can be specified in the string literal argument of 
the pragma INTERFACE NAME. 

The pragma INTERFACE NAME is allowed at the same places of an Ada program as the 
pragma INTERFACE (13.9J. However, the pragma INTERFACE NAME must always occur 
after the pragma INTERFACE declaration for the interfaced subprogram. 


Example 

package SAMPLE DATA is 

function SAMPLE DEVICE (X : INTEGER) return INTEGER; 
function PROCESSSAMPLE (X : INTEGER) return INTEGER; 
private 

pragma INTERFACE (OCCAM, SAMPLE DEVICE); 
pragma INTERFACE (OCCAM, PROCESS SAMPLE); 
pragma INTERFACE NAME (PROCESS SAMPLE, "process.sampIe"); 
end SAMPLE DATA; 


Implementation-Dependent Pragtnas 


11 









1.5 NO IMAGE 


The pragma NOJMAGE takes the name of an enumeration type as argument. This 
pragma specifies to the compiler that the attributes 'IMAGE, 'value or width will never 
be used for this type, and that in consequence, no image table should be generated for this 
enumeration type. Any compilation unit containing an attribute ’IMAGE, value or 
'WIDTH for a type on which a pragma NO IMAGE was applied, will be rejected by the 
compiler. 

The exception to this rule is that in the case where 'WIDTH can be determined at compile¬ 
time (i.e. it is not applied to an enumeration subtype with dynamic bounds) its use is 
allowed with the pragma NOJMAGE. 

Example: 

package MYPACKAGE is 

type ENUM is (FIRST, SECOND, THIRD); 
pragma NOIMAGE(ENUM); 


end MY PACKAGE; 

Limitations on the use of pragma NO IMAGE 

■ This pragma must occur in a declarative part and can be applied only to types 
declared in this same declarative part. 


1.6 INDENT 

This pragma is only used with the Alsys Reformatler ( AdaRcfomwt ); this tool offers the 
functionalities of a source reformatler in an Ada environment. 

The pragma is placed in the source file and interpreted by the Reformatler. 

pragma INDENT(OFF) 

The Reformatter docs not modify the source lines after the OFF pragma INDENT, 
pragma INDENT(ON) 


12 


Alsvs Ada for llie Transputer, Appendix F, v5.4 







The Reformatter resumes its action after the ON pragma INDENT. Therefore any source 
lines that are bracketed by the off and on pragma indents are not modified by the Alsys 
Reformatter. 


1.7 Other Pragmas 

Pragmas IMPROVE and PACK are discussed in detail in the section on representation 
clauses (Chapter 4). 

Pragmas STORAGE_SIZE_RATIO and FASTPRIMARY which are applicable only lo task 
types are discussed in detail in section 4.6. 

Pragma PRIORITY is accepted with the range of priorities running from 1 to 10 (see the 
definition of the predefined package SYSTEM in Chapter 3). The undefined priority (no 
pragma PRIORITY) is treated as though it were less than any defined priority value. 

In addition to pragma SUPPRESS, it is possible to suppress checks in a given compilation by 
the use of the Compiler option CHECKS. 

The following language defined pragmas have no effect. 

CONTROLLED 
MEMORY SIZE 
OPTIMIZE 
STORAGE_UNIT 
SYSTEM NAME 

Note that all access types are implemented by default as controlled collections as 
described in [4.8], 


Implementation-Dependent Pragmas 


13 




14 


AlsysAda for the Transputer, Appendix F, v5.4 




TABLE OF CONTENTS 


INTRODUCTION 1 

1 Implementation-Dependent Pragmas 3 

1.1 INLINE 3 

1.2 INLINE GENERIC 3 

1.3 INTERFACE 5 

1.3.1 Calling Conventions 5 

1.3.2 Parameter-Passing Conventions 6 

1.3.3 Parameter Representations 7 

1.3.4 Restrictions on Interfaced Subprograms 9 

1.4 INTERFACENAME 11 

1.5 NOIMAGE 12 

1.6 INDENT 12 

1.7 Other Pragmas 13 

2 Implementation-Dependent Attributes 15 

3 Specification of the Package SYSTEM 17 

4 Restrictions on Representation Clauses 21 

4.1 Enumeration Types 22 

4.2 Integer Types 25 

4.3 Floating Point Types 28 

4.4 Fixed Point Types 30 

4.5 Access Types 33 

4.6 Task Types 34 

4.7 Array Types 36 

4.8 Record Types 40 


Table of Contents 



5 

Conventions for Implementation-Generated Names 

51 

6 

Address Clauses 

53 

6.1 

Address Clauses for Objects 

53 

6.2 

Address Clauses for Program Units 

53 

6.3 

Address Clauses for Entries 

53 

7 

Restrictions on Unchecked Conversions 

55 

8 

Input-Output Packages 

57 

8.1 

NAME Parameter 

57 

8.2 

FORM Parameter 

57 

8.2.1 

File Sharing 

58 

8.2.2 

Binary Files 

59 

8.2.3 

Buffering 

60 

8.2.4 

Appending 

61 

83 

USEERROR 

61 

9 

Characteristics of Numeric Types 

63 

9.1 

Integer Types 

63 

9.2 

Floating Point Type Attributes 

64 

9.3 

Attributes of Type DURATION 

65 

REFERENCES 

67 

INDEX 


69 


IV 


AlsysAda for the Transputer, Appendix F, v5.4 




INTRODUCTION 


Implementation-Dependent Characteristics 


This appendix summarizes the implementation-dependent characteristics of the Alsys Ada 
Compilers for INMOS transputers. This document should be considered as the Appendix 
F to the Reference Manual for the Ada Programming Language ansi/mil-STD 1815a, 
January 1983, as appropriate to the Alsys Ada implementation for the transputer. 

Sections 1 to 8 of this appendix correspond to the various items of information required in 
Appendix F [F]*; sections 9 and 10 provide other information relevant to the Alsys 
implementation. The contents of these sections is described below: 

1. The form, allowed places, and effect of every implementation-dependent pragma. 

2. The name and type of every implementation-dependent attribute. 

3. The specification of the package SYSTEM J13.7]. 

4. The list of all restrictions on representation clauses [13.1]. 

5. The conventions used for any implementation-generated names denoting 
implementation-dependent components [13.4], 

6. The interpretation of expressions that appear in address clauses. 

7. Any restrictions on unchecked conversions [13.10.2], 

8. Any implementation-dependent characteristics of the input-output packages [14]. 

9. Characteristics of numeric types. 


Throughout this manual, citations in square brackets refer to the Reference Manual 
for the Ada Programming Language, ANSI/M1L-STD-1815A, January 1983. 


Implementation-Dependent Characteristics 


1 





Throughout this appendix, the name Ada Run-Time Executive refers to the run-time 
library routines provided for all Ada programs. These routines implement the Ada heap, 
exceptions, tasking control, I/O, and other utility functions. 


2 


Alsvs Ada for the Transputer, Appendix F, v5.4 





CHAPTER 1 


Implementation-Dependent Pragmas 
1.1 INLINE 

Pragma INLINE is fully supported, except for the fact that it is not possible to inline a 
function call in a declarative part. 


1.2 INLINEGENERIC 

The pragma INLINE GENERIC takes the name of a generic unit or of an instance of a 
generic unit as argument. 

When the argument is the name of a generic unit, pragma INLINEGENERIC specifies that 
all the instances of the generic unit will be generated in line (and not in a subunit) 
regardless of the value of the option GENERICS of the command COMI’ILE. 

When the argument is the name of an instance of a generic unit, pragma INLINE GENERIC 
specifies that this instance will be generated in line (and not in a subunit) regardless of the 
value of the option generics of the command COMPILE. 

pragma INLINE_GENERIC (Ada jiesigiator {, Ada-designator }) 

Example: 

procedure MYPROCEDURE is 
type MY TYPE is (...); 
generic 

procedure MYFIRSTGENERIC; 
generic 

type T is (< >); 

function MY_SECOND_GENERIC(L,R : T) return T; 


Implementation-Dependent Pragmas 


3 





function MY_SECOND_GENERIC(L,R : T) return T is 
begin 

end; 

function “+" is new MY SECOND GENERIC(MY TYPE); 
pragma INLINE_GENERIC(MY_FIRST_GENERIC, "+*); 


procedure MYFIRSTGENERIC is 
begin 

end; 


end MY PROCEDURE; 

Limitations on the use of pragma INLINEGENERIC 

• This pragma is only allowed at the place of a declarative item in a declarative part or 
package specification, or after a library unit in a compilation but before any 
subsequent compilation unit. If the pragma appears at the place of a declarative 
item, each argument must denote a generic unit, or an instance oi a generic unit, 
declared by an earlier declarative item of the same declarative part or package 
specification. If several (overloaded) subprograms satisfy this requirement, the 
pragma applies to all of them. If the pragma appears after a given library unit, the 
only name allowed is the name of this unit, which must be a generic unit. 

■ If an instance cannot be generated in line, in spite of a valid pragma 

INLINE GENERIC, a warning will be emitted and the instance will be generated in a 
subunit. This will occur in particular when the body of the generic unit has not been 
compiled at the point of instantiation. This will also happen on instances appearing 
within the specification of a generic package (due to a restriction of the Alsys 
implementation). 


4 


Alsys Ada for the Transputer, Appendix F, v5.4 








13 INTERFACE 


Ada programs can interface to subprograms written in occam through the use of the 
predefined pragma INTERFACE [13.9] and the implementation-defined pragma 
INTERFACENAME. 

Pragma INTERFACE specifies the name of an interfaced subprogram and the name of the 
programming language for which calling and parameter passing conventions will be 
generated. Pragma INTERFACE takes the form specified in the Reference Manual : 

pragma INTERFACE (language name, subprogram name)', 

where: 

■ language_name is the name of the other language whose calling and parameter 
passing conventions are to be used. 

■ subprogram jxame is the name used within the Ada program to refer to the 
interfaced subprogram. 

The language names currently accepted by pragma INTERFACE are OCCAM and 
OCCAM HIGH. 

The language name used in the pragma INTERFACE does not necessarily correspond to the 
language used to write the interfaced subprogram. It is used only to tell the Compiler how 
to generate subprogram calls, that is, which calling conventions and parameter passing 
techniques to use. 

The language name OCCAM is used to refer to the standard occam calling and parameter 
passing conventions for the transputer (Ref. 4, Section S.10). The programmer can use 
the language name OCCAM to interface Ada subprograms to subroutines written in any 
language that follows the standard occam calling conventions. 

The programmer can use the language name OCCAM_HIGH to run the interfaced 
subroutine as a high priority process instead of a low priority process. The 
OCCAM HIGH interface is otherwise identical to the OCCAM interface. 


13.1 Calling Conventions 

The following calling conventions are required for code to be called from Ada by use of 
pragma interface. 


Implementation-Dependent Pragmas 


5 




On entry to the subprogram, the registers A, B and C are undefined. For the T8 and 
T9000, the floating point registers FA, FB and FC are similarly undefined. The return 
address and any parameters are accessed relative to the workspace pointer, W, by the 
subprogram. 

There are no assumptions concerning the contents of the register stacks (A, B, C and FA, 
FB, FC) upon return from the interfaced subprogram, other than for interfaced 
subprograms which are functions (see below). However, the workspace pointer, W, 
should contain the same address upon return from the interfaced subprogram as it 
contained before the call. 

On the T4 and T8 the setting of the error flag is ignored on return. 


1.3.2 Parameter-Passing Conventions 

On entry to the subprogram, the word at offset 0 from the transputer workspace (W) 
pointer contains the return address of the called subprogram. Subsequent workspace 
locations (from W +1 to W + n, where n is the number of parameters) contain the 
subprogram parameters, which are all one word in length. 

There is always an implicit vector space parameter passed as the last parameter to all 
interfaced subprograms. This points to an area of free memory which can be used by the 
occam compiler to allocate arrays declared in the interfaced subprogram. 

Actual parameters of mode in which are access values or scalars of one machine word or 
less in size are passed by copy. If such a parameter is less that one machine word in 
length it is sign extended to a full word. For all other parameters of mode in, and all 
parameters of mode in out or out, the value passed is the address of the actual parameter 
itself. 

Since all large scalar, non-scalar and non-access parameters to interfaced subprograms 
are passed by address, they cannot be protected from modification by the called 
subprogram even though they may be formally declared to be of mode in. It is the 
programmer’s responsibility to ensure that the semantics of the Ada parameter modes are 
honoured in these cases. 

If the interfaced subprogram is a function, the result is returned as follows: 

A floating point result is returned in register FPA. 


6 


AisysAda for the Transputer, Appendix F, v5.4 



Any other result is returned by value in register A if its size is at most one machine 
word and by address in register A otherwise. 

No consistency checking is performed between the subprogram parameters declared in 
Ada and the corresponding parameters of the interfaced subprogram. It is the 
programmer’s responsibility to ensure correct access to the parameters. 

1.3.3 Parameter Representations 

This section describes the representation of values of the types that can be passed as 
parameters to an interfaced subprogram. The discussion assumes no representation 
clauses have been used to alter the default representations of the types involved. Chapter 
4 describes the effect of representation clauses on the representation of values. 

Integer Types [3-5.4] 

Ada integer types are represented in two’s complement form and occupy a byte 
(SHORT INTEGER) Or a word (INTEGER). 

Parameters to interfaced subprograms of type SHORTINTEGER are passed by copy with 
the value sign extended to a full machine word. Values of type INTEGER are always passed 
by copy. The predefined type LONGJNTEGER is not available. 

Enumeration Types (35.1] 

Values of an Ada enumeration type are represented internally as unsigned values 
representing their position in the list of enumeration literals defining the type. The first 
literal in the list corresponds to a value of zero. 

Enumeration types with 256 elements or fewer are represented in 8 bits. All other 
enumeration types are represented in 32 bits. 

Consequently, the Ada predefined type CHARACTER [3.5.2] is represented in 8 bits, using 
the standard ASCII codes [C] and the Ada predefined type BOOLEAN [3-5.3] is represented 
in 8 bits, with FALSE represented by the value 0 and TRUE represented by the value 1. 

As the representation of enumeration types is basically the same as that of integers, the 
same parameter passing conventions apply. 


Implementation-Dependent Pragmas 


7 









Floating Point Types [3_5.7,3-5-8] 

Ada floating-point values occupy 32 (FLOAT) or 64 (longfloat) bits, and are held in 
ANSI/IEEE 754 floating point format. 

Parameters to interfaced subprograms of type FLOAT are always passed by copy. 
Parameters of type long float are passed by address. 

Fixed Point Types [33.9,35.10] 

Ada fixed-point types are managed by the Compiler as the product of a signed mantissa 
and a constant small. The mantissa is implemented as an 8 or 32 bit integer value. Small 
is a compile-time quantity which is the power of two equal or immediately inferior to the 
delta specified in the declaration of the type. 

The representation of an actual parameter of a fixed point type is the value of its mantissa. 
This is passed using the same rules as for integer types. 

The attribute MANTISSA is defined as the smallest number such that: 

2 ** MANTISSA > = max (abs (upper_bound), abs (lower_bound)) / small 

The size of a fixed point type is: 

MANTISSA Size 

1.. 7 8 bits 

8 .. 31 32 bits 

Fixed point types requiring a MANTISSA greater than 31 are not supported. 

Access Types [3.8] 

Values of access types are represented internally by the address of the designated object 
held in single word. The value MIN INT (the smallest integer that can be represented in a 
machine word) is used to represent null. 

Array Types [3.6] 

Ada arrays are passed by address; the value passed is the address of the first element of 
the first dimension of the array. The elements of the array are allocated by row. When an 
array is passed as a parameter to an interfaced subprogram, the usual consistency 
checking between the array bounds declared in the calling and the called subprogram is 
not enforced. It is the programmer’s responsibility to ensure that the subprogram does 
not violate the bounds of the array. 


8 


Alsys Ada for the Transputer, Appendix F, v5.4 







When passing arrays to Occam, it may be the case that some of its bounds are undefined in 
the source of the interfaced subprogram. If this is true, the missing bounds should be 
passed as extra integer value parameters to the subprogram. These parameters should be 
placed immediately following the array parameter itself and in the same order as the 
missing strides appear in the Occam source. 

Values of the predefined type STRING [3.63) are arrays, and are passed in the same way: 
the address of the first character in the string is passed. Elements of a string are 
represented in 8 bits, using the standard ASCII codes. The elements are packed into one 
or more words and occupy consecutive locations in memory. 

Record Types [3.7] 

Ada records are passed by address; the value passed is the address of the first component 
of the record. Components of a record are aligned on their natural boundaries (e.g. 
INTEGER on a word boundary) and the components may be re-ordered by the Compiler so 
as to minimize the total size of objects of the record type. If a record contains 
discriminants or components having a dynamic size, implicit components may be added to 
the record. Thus the default layout of the internal structure of the record may not be 
inferred directly from its Ada declaration. The use of a representation clause to control 
the layout of any record type whose values are to be passed to interfaced subprograms is 
recommended. 

1.3.4 Restrictions on Interfaced Subprograms 

Interfaced subprograms must be compiled using an error mode compatible with that used 
by the Ada runtime system to avoid errors when linking. For T4 and T8 mode S (STOP) 
or X (UNIVERSAL) should be used and for T9000 mode H (HALT) or X 
(UNIVERSAL) should be used. 

There is no mechanism to allow runtime errors in interfaced subprograms to 
automatically raise an Ada exception. Interfaced subprograms should be written to 
explicitly deal with any errors likely to occur at runtime and return an error indication to 
the Ada program using an out parameter or a function result. 

On T4 and T8, if the interfaced subprogram causes a process hall as a result of executing a 
STOPP or STOPERR instruction, the calling Ada task will become permanently blocked 
and will never terminate. On T9000 an interfaced subprogram is called with a null trap 
handler, so unless the subprogram installs its own handler any errors resulting in a trap 
will cause a process halt and will permanently block the calling Ada task. 


Implementation-Dependent Pragmas 


9 




In view of this, the use of runtime checking code added by the occam compiler is limited, 
and it is often convenient to suppress il using option U. 

Parameters which are of a task or private type, or are access values not of mode in, should 
not be passed to interfaced subprograms. 

It is not possible to interface to occam functions which have more that one return value. 
Unconstrained records and arrays cannot be returned from interfaced subprograms. 


JO 


Aisys Ada for the Transputer, Appendix F, v5.4 




1.4 INTERFACE NAME 


Pragma INTERFACENAME associates the name of an interfaced subprogram, as declared 
in Ada, with its name in the language of origin. If pragma INTERFACENAME is not used 
the Ada name in uppercase is used as its name in the interfaced language. 

This pragma takes the form: 

pragma INTERFACE NAME (subprogram jiame, string literal)-, 
where: 

• subprogram name is the name used within the Ada program to refer to the 
interfaced subprogram. 

• string literal is the name by which the interfaced subprogram is referred to at link¬ 
time. 

The use of INTERFACE NAME is optional and is not needed if a subprogram has the same 
name in Ada as in the language of origin. It is necessary, for example, if the name of the 
subprogram in its original language contains characters that are not permitted in Ada 
identifiers or contains lowercase letters. Ada identifiers can contain only letters, digits and 
underscores, whereas the inmos linker allows external names to contain other characters, 
for example full stops. These characters can be specified in the string literal argument of 
the pragma INTERFACE NAME. 

The pragma INTERFACE_NAME is allowed at the same places of an Ada program as the 
pragma INTERFACE [ 13.9]. However, the pragma INTERFACE NAME must always occur 
after the pragma INTERFACE declaration for the interfaced subprogram. 


Example 

package SAMPLE DATA is 

function SAMPLE DEVICE (X : INTEGER) return INTEGER; 
function PROCESS_SAMPLE (X : INTEGER) return INTEGER; 
private 

pragma INTERFACE (OCCAM, SAMPLE DEVICE); 
pragma INTERFACE (OCCAM, PROCESS_SAMPLE); 
pragma INTERFACE NAME (PROCESS SAMPLE, "process.sample"); 
end SAMPLE DATA, 


Implementation-Dependent Pragmas 


11 







1.5 NO IMAGE 


The pragma NO IMAGE takes the name of an enumeration type as argument. This 
pragma specifies to the compiler that the attributes ’IMAGE, ‘value or width will never 
be used for this type, and that in consequence, no image table should be generated for this 
enumeration type. Any compilation unit containing an attribute ‘IMAGE, value or 
’WIDTH for a type on which a pragma NOJMAGE was applied, will be rejected by the 
compiler. 

The exception to this rule is that in the case where WIDTH can be determined at compile¬ 
time (i.e. it is not applied to an enumeration subtype with dynamic bounds) its use is 
allowed with the pragma NOJMAGE. 

Example: 

package MYPACKAGE is 

type ENUM is (FIRST, SECOND, THIRD); 
pragma NOJMAGE(ENUM); 


end MY PACKAGE; 

Limitations on the use of pragma NO_IMAGE 

■ This pragma must occur in a declarative part and can be applied only to types 
declared in this same declarative part. 

1.6 INDENT 

This pragma is only used with the Alsys Reformatter (AdaRcfomwi)\ this tool offers the 
functionalities of a source reformaltcr in an Ada environment. 

The pragma is placed in the source file and interpreted by the Reformatter. 

pragma INDENT(OFF) 

The Reformatter docs not modify the source lines after the OFF pragma INDENT, 
pragma INDENT(ON) 


12 


Alsys Ada for the Transputer, Appendix F, v5.4 





The Reformatter resumes its action after the ON pragma INDENT. Therefore any source 
lines that are bracketed by the OFP and on pragma indents are not modified by the Alsys 
Reformatter. 


1.7 Other Pragmas 

Pragmas IMPROVE and PACK are discussed in detail in the section on representation 
clauses (Chapter 4). 

Pragmas STORAGESIZl- RATIO and FAST_PRIMARY which are applicable only to task 
types are discussed in detail in section 4.6. 

Pragma PRIORITY is accepted with the range of priorities running from 1 to 10 (see the 
definition of the predefined package system in Chapter 3). The undefined priority (no 
pragma priority) is treated as though it were less than any defined priority value. 

In addition to pragma SUPPRESS, it is possible to suppress checks in a given compilation by 
the use of the Compiler option CHECKS. 

The following language defined pragmas have no effect. 

CONTROLLED 
MEMORY SIZE 
OPTIMIZE 
STORAGE UNIT 
SYSTEM NAME 

Note that all access types are implemented by default as controlled collections as 
described in [4.8], 


Implementation-Dependent Pragmas 


13 




14 


Alsys Ada for the Transputer, Appendix F, v5.4 







CHAPTER 2 


Implementation-Dependent Attributes 


In addition to the Representation Attributes of 113.7.21 and [13.7.3], the attributes listed in 
section 5 (Conventions for Implementation-Generated Names), for use in record 
representation clauses, and the attributes described below are provided: 

TDESCRIPTORSIZE For a prefix T that denotes a type or subtype, this 

attribute yields the size (in bits) required to hold a 
descriptor for an object of the type T, allocated on 
the heap or written to a file. If T is constrained, 
rDESCRIPTORStZE will yield the value 0. 

TIS ARRAY For a prefix T that denotes a type or subtype, this 

attribute yields the value TRUE if T denotes an array 
type or an array subtype; otherwise, it yields the 
value FALSE. 


Limitations on the use of the attribute ADDRESS 

The attribute ADDRESS is implemented for all prefixes that have meaningful addresses. 
The following entities do not have meaningful addresses. The attribute address will 
deliver the value SYSTEM.NULLADDRESS if applied to such prefixes and a compilation 
warning will be issued. 

■ A constant or named number that is implemented as an immediate value (i.e. does 
not have any space allocated for it). 

■ A package specification that is not a library unit 

■ A package body that is not a library unit or subunit. 

■ A function that renames an enumeration literal. 

If the attribute ADDRESS is applied to a named number, a compilation error will be 
produced. 


Implementation-Dependent Attributes 


15 





16 


Aliys Ada for the Transputer, Appendix F, v5.4 






CHAPTER 3 


Specification of the Package SYSTEM 


package SYSTEM is 

type NAME is (180X86, 

I80386, 

MC680X0, 

S370, 

TRANSPUTER, 

VAX, 

RS 6000, 

MIPS, 

HP9000 PA RISC, 

SPARC )7 

SYSTEM_NAME : constant NAME := TRANSPUTER; 

STORAGE_UN!T : constant 8; 

MAX_INT : constant :* 2**31 - 1; 

MIN_INT s constant :« - (2**31); 

MAX_MANTISSA : constant :« 31; 

FINE_DELTA : constant :* 2#1.0#E-31; 

MAX_DIGITS s constant :■ 15; 

MEMORY_SIZE : constant :* 2**32; 

TICK : constant := 1.0E-6; 

subtype PRIORITY is INTEGER range 1 .. 10; 

type ADDRESS is private; 

NUU_ADDRES$ : constant ADDRESS; 


function VALUE (LEFT : in STRING) return ADDRESS; 

subtype A00RESS_STRING is STRING(1..8); 

function IMAGE '.EFT : in ADDRESS) return ADDRESS_STRING; 

type OFFSET is range -(2**31) .. 2**31-1; 

-- This type is used to measure a number of storage units (bytes), 
function SAM£_SEGHENT (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 
ADDRESS_ERROR : exception; 


Specification of the Package SYSTEM 


17 





function (LEFT : in ADDRESS; RIGHT : in OFFSET) return ADDRESS; 
function «♦" (LEFT : in OFFSET; RIGHT : in ADDRESS) return ADDRESS; 
function (LEFT : in ADDRESS; RIGHT : in OFFSET) return ADDRESS; 

function (LEFT : in ADDRESS; RIGHT : in ADDRESS) return OFFSET; 

function “<=" (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 
function “<" (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 
function <•>*" (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 
function ">" (LEFT, RIGHT : in ADDRESS) return BOOLEAN; 

function “mod" (LEFT : in ADDRESS; RIGHT : in POSITIVE) return NATURAL; 


type ROUND_DIRECTION is (DOWN, UP); 

function ROUND (VALUE : in ADDRESS; 

DIRECTION : in ROUND DIRECTION; 

MODULUS : in POSITIVE) return ADDRESS; 


generic 

type TARGET is private; 

function FETCH_FROM_ADDRE$S (A : in ADDRESS) return TARGET; 
generic 

type TARGET is private; 

procedure ASSIGN_TO_ADDRESS (A : in ADDRESS; T : in TARGET); 

-- These routines are provided to perform READ/WRITE operations in memory. 


type OBJECTJ.ENGTH is range 0 .. 2**31 -1; 

-- This type is used to designate the size of an object in storage units. 

procedure MOVE (TO : in ADDRESS; 

FROM : in ADDRESS; 

LENGTH : in OB4ECTJ.ENGTH); 

end SYSTEM; 


The function VALUE may be used to convert a string into an address. The string is a 
sequence of up to eight hexadecimal characters (digits or letters in upper or lower case in 
the range A..F) representing the address. The exception CONSTRAINTJERROR is raised if 
the string does not have the proper syntax. 

The function IMAGE may be used to convert an address to a string which is a sequence of 
exactly eight hexadecimal digits. 


18 


AlsysAda for the Transputer, Appendix F, v5.4 





ii 


Alsys Ada for the Transputer, Appendix F, vS.4 





INTRODUCTION 


CHAPTER 1 INTRODUCTION 


The Ada implementation described above was tested according to the Ada Validation Procedures [Pro92] against 
the Ada Standard [Ada83] using the current Ada Compiler Validation Capability (ACVC). This Validation 
Summary Report (VSR) gives an account of the testing of this Ada implementation. For any technical terms used 
in this report, the reader is referred to [Pro92]. A detailed description of the ACVC may be found in the current 
ACVC User’s Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada Certification Body may make lull and free 
public disclosure of this report. In the United States, this is provided in accordance with the "Freedom of 
Information Act" (5 U.S.C. #552). The results of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report do not represent or warrant that all statements 
set forth in this report are accurate and complete, or that the subject implementation has no nonconformities to 
the Ada Standard other than those presented. Copies of this report are available to the public from the AVF 
which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results should be directed to the AVF which performed this 
validation or to: 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 

1.2 REFERENCES 

[Ada83] Reference Manual for the Ada Programming Language. 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro92] Ada Compiler Validation Procedures. 

Version 3.1, Ada Joint Program Office, August 1992. 

[UG89] Ada Compiler Validation Capability User’s Guide. 

21 June 1989. 


Validation Susmary Report 
Alsys Limited 


Chapter 1 - Page 1 of 4 


AVF_VSR_05401/87-940831 
AlsyC0MP_017 Version 5.4.10 










INTRODUCTION 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC contains a collection of test 
programs structured into six test classes: A, B, C, D, E, and L. The first letter of a test name identifies the class 
to which it belongs. Class A, C, D, and E tests are executable. Class B and class L tests are expected to produce 
errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and produce a PASSED, FAILED, or NOT 
APPLICABLE message indicating the result when they are executed. Three Ada library units, the packages 
REPORT and SPPRT13, and the procedure CHECKFILE are used for this purpose. The package REPORT also 
provides a set of identity functions used to defeat some compiler optimizations allowed by the Ada Standard that 
would circumvent a test objective. The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents of text files written by some of the Class 
C tests for Chapter 14 of the Ada Standard. The operation of REPORT and CHECK FILE is checked by a set 
of executable tests. If these units are not operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class B tests are not executable. Each test in 
.this class is compiled and the resulting compilation listing is examined to verify that all violations of the Ada 
Standard are detected. Some of the class B tests contain legal Ada code which must not be flagged illegal by 
the compiler. This behaviour is also verified. 

Class L tests check that an Ada implementation correctly detects violation of the Ada Standard involving 
multiple, separately compiled units. Errors are expected at link time, and execution is attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by implementation-specific values - for 
example, the largest integer. A list of the values used for this implementation is provided in Appendix A. In 
addition to these anticipated test modifications, additional changes may be required to remove unforeseen 
conflicts between the tests and implementation-dependent characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by the AVF. This customization consists of 
making the modifications described in the preceding paragraph, removing withdrawn tests (see section 2.1), and 
possibly removing some inapplicable tests (see section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of the customized test suite accoiuing 
to the Ada Standard. 


Validation Summary Report 
Alsys Limited 


Chapter 1 • Page 2 of 4 


AVF_VSR_05401/87-940831 
AlsyC0MP_017 Version 5.4.10 









INTRODUCTION 


1.4 DEFINITION OF TERMS 


Ada Compiler 


\da Compiler Validation 
apability (ACVC) 


Ada Implementation 

Ada Joint Program Office 
(AJPO) 

Ada Validation Facility 
(AVF) 

Ada Validation 
Organization (AVO) 

Compliance of an Ada 
Implementation 

Computer System 


Conformity 

Customer 

Declaration of 
Conformance 

Host Computer System 
Inapplicable test 

ISO 


The software and any needed hardware that have to be added to a given host and 
target computer system to allow transformation of Ada programs into executable 
form and execution thereof. 

The means for testing compliance of Ada implementations, consisting of the test 
suite, the support programs, the ACVC user’s guide and the template for the 
validation summary report. 

An Ada compiler with its host computer system and its target computer system. 

The part of the certification body which provides policy and guidance for the 
Ada certification system. 

The part of the certification body which carries out the procedures required to 
establish the compliance of an Ada implementation. 

The part of the certification body that provides technical guidance for operations 
of the Ada certification system. 

The ability of the implementation to pass an ACVC version. 


A functional unit, consisting of one or more computers and associated software, 
that uses common storage for all or part of a program and also for all or part of 
the data necessary for the execution of the program; executes user-written or 
user-designated programs; performs user-designated date manipulation, including 
arithmetic operations and logic operations; and that can execute programs that 
modify themselves during execution. A computer system may be a stand-alone 
unit or may consist of several inter-connected units. 

Fulfilment of a product, process or service of all requirements specified. 

An individual or corporate entity who enters into an agreement with an AVF 
which specifies the terms and conditions for AVF services (of any kind) to be 
performed. 

A formal statement from a customer assuring that conformity is realized or 
attainable on the Ada implementation for which validation status is realized. 

A computer system where Ada source programs are transformed into executable 
form. 

A test that contains one or more test objectives found to be irrelevant for the 
given Ada implementation. 

International Organization for Standardization. 


Validation Sunnary Report 
Alsys United 


Chapter 1 • Page 3 of 4 


AVF_VSR_05401/87-940831 
AlsyC0MP_017 Version 5.4.10 










INTRODUCTION 


LRM 

Operating System 

Target Computer System 

Validated Ada Compiler 

Validated Ada 
Implementation 

Validation 

Withdrawn test 


Validation Stannary Report 
Alsys Limited 


The Ada standard, or Language Reference Manual, published as ANSl/MIL-STD- 
1815A-1983 AND ISO 8652-1987. Citations from the LRM take the form 
"<section>.<subsection>:<paragraph>." 

Software that controls the execution of programs and that provides services such 
as resource allocation, scheduling, input/output control and data management. 
Usually, operating systems are predominantly software, but partial or complete 
hardware implementations are possible. 

A computer system where the executable form of Ada programs are executed. 
The compiler of a validated Ada implementation. 

An Ada implementation that has been validated successfully either by AVF 
testing or by registration [Pro92]. 

The process of checking the conformity of an Ada compiler to the Ada 
programming language and of issuing a certificate for this implementation. 

A test found to be incorrect and not used in conformity testing. A test may be 
incorrect because it has an invalid test objective, fails to meet its test objective, 
or contains erroneous or illegal use of the Ada programming language. 


AVF_VSR_05401/87-940831 
Chapter 1 - Page 4 of 4 AlsyC0HP_017 Version 5.4.10 










IMPLEMENTATION DEPENDENCIES 


CHAPTER 2 IMPLEMENTATION DEPENDENCIES 
2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for withdrawing each test is available from 
either the AVO or the AVF. The publication date for this list of withdrawn tests is 22 November 1993. 


B27005A 

E28005C 

B28006C 

C32203A 

C34006D 

C35507K 

C35507L 

C35507N 

C35507O 

C35507P 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

C37310A 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A54B02A 

C55B06A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

C83026A 

B83026B 

C83041A 

B85001L 

C8600IF 

C9402IA 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2U7A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE341IB 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 






2.2 INAPPLICABLE TESTS 


A test is inapplicable if it contains test objectives which are irrelevant for a given Ada implementation. Reasons 
for a test’s inapplicability may be supported by documents issued by the ISO and the AJPO known as Ada 
Commentaries and commonly referenced in the format Al-ddddd. For this implementation, the following tests 
were determined to be inapplicable for the reasons indicated; references to Ada Commentaries are included as 
appropriate. 


The following 201 tests have floating-point type declarations requiring more digits than 
SYSTEM.MAXDIGITS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 
C35802L..Z (15 tests) 
C45321L..Y (14 tests) 
C45521L..Z (15 tests) 
C45621L.Z (15 tests) 
C46012L..Z (15 tests) 


Validation Sunnary Report 
Alsys United 


Chapter 2 - Page 1 of 4 


AVF_VSR_05401/87-940831 
AlsyC0HP_017 Version 5.4.10 







For example: 


type COLOR is (GREEN. B1ACK. WHITE. RED. BLUE. YELLOW); 

— The minimum si/e of COLOR is 3 bits. 

subtype BLACKANDWHITE is color range BLACK .. white; 

— The minimum size of BIACKAND WHITE is 2 bits. 

subtype BLACK OR WHITE is BLACK AND WH1TE range X .. X; 

-- Assuming that X is not statie, the minimum size of BLACKORWHITE is 
- 2 bits (the same as the minimum size of the static type mark 
-- black and wiirn-;). 

Size: When no size specification is applied to an enumeration type or first named subtype 
(if any), the size of that type or first named subtype is the smallest of 32, 8,4,2 or 1 bit 
which is equal to or greater than the minimum size for the type or first named type. 

When a size specification is applied to an enumeration type, this enumeration type and 
each of its subtypes has the size specified by the length clause. The same rule applies to a 
first named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies. 

For example: 

type EXTENDED is 

( — The usual American ASCII characters. 


NU¬ 

SOU. 

STX. 

ETX. 

EOT. 

ENO. 

ACK. 

BEU 

BS. 

irr. 

LF. 

VI. 

FF. 

CR. 

SO. 

SI. 

DLE. 

DO. 

DC2. 

DC3. 

DC4. 

NAK. 

SYN. 

ETB. 

CAN. 

EM. 

SUB. 

ESC. 

FS. 

C.S. 

RS. 

US. 


'!'. 

—. 

'#'. 

’S'. 




T. 

')'• 

••• 





v. 

O'. 

T. 

*2*. 

'3'. 

'4'. 

'5'. 

'6'. 

•7. 

'S'. 

V. 



<’. 

' s \ 


"?' 


A'. 

B'. 

C. 

D'. 

E. 

T. 

G. 

H. 

T. 

T. 

K. 

L'. 

M. 

•N'. 

O’. 

T\ 

Q'. 

IV. 

S'. 

T. 

U'. 

•V'. 

•W'. 

X'. 

Y\ 

Z\ 

T- 

A'. 

T- 

•A* 

• • 


'a'. 

'b\ 

Y. 

d'. 

'e\ 

T, 


h'. 

T. 

!• 

k'. 

T. 

'm'. 

’n\ 

’o'. 

P- 

M • 

'r'. 

's'. 

T. 

'u'. 

V*. 

’w". 

Y. 

y- 



T. 

I’- 


DEL, 


Restrictions on Representation Clauses 23 








-- Extended characters 
LEFTARROW. 

R1GHTARROW. 

UPPERARROW. 

LOWERARROW. 

UPPERLEPTCORNER. 

UPPER_RIGHT_CORNER- 
LOWER Riot rr_CO RNER. 

LOWERLEFI'CORNER. 

...): 

for EXTENDED SIZE use 8; 

-- The size of type EXTENDED will be one byte. Its objects will be represented 
-- as unsigned 8 bit integers. 

The Alsys Compiler fully implements size specifications. Nevertheless, as enumeration 
values are coded using integers, the specified length cannot be greater than 32 bits. 

Object size: Provided its size is not constrained by a record component clause or a 
pragma PACK, the size of an object of an enumeration subtype is determined as follows: 

When no size specification is applied to the enumeration type or its first named subtype (if 
any), the objects of that type or first named subtype are represented as cither unsigned 
bytes or signed words. The compiler selects automatically the smallest such object 
which can hold each of the internal codes of the enumeration type (or subtype). The size 
of objects of the enumeration type, and of any of its subtypes, is thus 8 bits in the case of 
an unsigned byte, or the machine size (32 bits) in the case of signed word. 

When a size specification is applied to an enumeration type or its first named subtype, 
objects of this enumeration type, or of any of its subtypes, have the size specified by the 
length clause. 

Alignment: An enumeration subtype is byte aligned if the size of the subtype is less than 
or equal to 8 bits, word aligned otherwise. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of an enumeration subtype is a multiple 
of the alignment of the corresponding subtype. 


24 


Alsys Ada for the Transputer, Appendix F, vS.4 





4.2 Integer Types 

Predefined integer types 

In the Alsys Ada implementation for the transputer the following predefined integer types 
are available: 

type SHORT INTEGER is range -2**07 .. 2* *07-1; 
type INTEGER is range -2**31 .. 2**31-1; 


Selection of the parent of an integer type 
An integer type declared by a declaration of the form: 
type T is range L .. R; 

is implicitly derived from one of the predefined integer types. The compiler automatically 
selects the predefined integer type whose range is the shortest that contains the values L 
to R inclusive. 


Encoding of integer values 

Binary code is used to represent integer values, using a conventional two’s complement 
representation. 


Integer subtypes 

Minimum size: The minimum size of an integer subtype is the minimum number of bits 
that is necessary for representing the internal codes of the subtype values in normal binary 
form (that is to say, in an unbiased form which includes a sign bit only if the range of the 
subtype includes negative values). 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M are 
the lower and upper bounds of the subtype, then its minimum size L is determined as 
follows. For m > = 0, L is the smallest positive integer such that M < = 2*--l. For m < 
0, L is the smallest positive integer such that -2 1 -" 1 < = m and M < = 2 , -‘*-l. 


Restrictions on Representation Clauses 


25 









For example: 

subtype S is INTEGER range 0 .. 7; 

— The minimum size of S is 3 bits. 

subtype D is S range X .. Y; 

- Assuming that X and Y arc not static, the minimum size of 

-- D is 3 bits (the same as the minimum size of the static type mark S). 

Size: The sizes of the predefined '..legcr types SIIORTINTF.GER and INTEGER are 
respectively 8 and 32 bits. 

When no size specification is applied to an integer type or to its first named subtype (if 
any), its size and the size of any subtypes is the smallest of 32, 8,4, 2 or 1 bit which is 
equal to or greater than the minimum size for the type or first named type. 

For example: 

type S is range 80 .. 100; 

-- S is derived from SltORTJNTnGER, its size is 8 bits. 

type J is range 0 .. 65535; 

-- J is derived from INTEGER, its size is 32 bits. 

type N is new J range 80 .. 100; 

-- N is indirectly derived from INTEGER, its size is 32 bits. 

When a size specification is applied to an integer type, this integer type and each of its 
subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or equal 
to the minimum size of the type or subtype to which it applies. 

For example: 

type S is range 80 .. 100; 
for S’SIZE use 32; 

- S is derived from SIIORTINTEGER, but its size is 32 bits 

- because of the size specification. 

type J is range 0 .. 255; 
for J’SIZE use 8; 

-- J is derived from INTEGER, bui ils size is 8 bits because 
-- of the size specification. 


26 


Aliys Ada for the Transputer, ApjKiidix F, vS.4 





type N is new J range 80 .. 100; 

-- N is indirectly derived from INTEGER, but its size is 8 bits 
— because N inherits the size specification of J. 

The Alsys Compiler implements size specifications. Nevertheless, as integers are 
implemented using machine integers, the specified length cannot be greater than 32 bits. 

Object size: Provided its size is not constrained by a record component clause or a 
pragma PACK, the size of an object of an integer subtype is determined as follows: 

When no size specification is applied to the integer type or its first named subtype (if any), 
the objects this type, or any of its subtypes, have the size of the predefined type from 
which it derives directly or indirectly. 

When a size specification is applied to an integer type or its first named subtype, objects of 
this integer type, or of any of its subtypes, have the size specified by the length clause. 

Alignment: An integer subtype is byte aligned if the size of the subtype is less than or 
equal to 8 bits, word aligned otherwise. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of an integer subtype is a multiple of 
the alignment of the corresponding subtype. 


Restrictions on Representation Clauses 


27 






4 3 Floating Point Types 

Predefined floating point types 

There are two predefined floating point types in the Aisys implementation for transputers: 
Their characteristics are: 


FLOAT: 

FLOAT’DIGITS 
FLOAT’FIRST 
FLOAT’LAST 

FLOATMACHINE MANTISSA 


= 6 

= -(2.0 - 2.0**(-23))*2.C**127 
= (2.0 - 2.0**(-23))*2.0**127 
= 24 


LONGFLOAT: 

long'floatdigits 

LONGFLOAT’FIRST 

LONG FLOAT’LAST 

LONG FLOATMACHINE MANTISSA 


= 15 

= -(2.0 - 2.0**(-52))*2.0**1023 
= (2.0 - 2.0**(-52))*2.0**1023 
= 53 


Selection of the parent of a floating point type 
A floating point type declared by a declaration of the form: 
type T is digits D [range L .. R); 

is implicitly derived from a predefined floating point type. The Compiler automatically 
selects the smallest predefined floating point type whose number of digits is greater than 
or equal to D and which contains the values L and R. 


Encoding of floating point values 

In the program generated by the Compiler, floating point values are represented using the 
ANSI/IEEE 754 standard 32-bit and 64-bit floating point formats as appropriate. 

V alues of the predefined type FLOAT are represented using the 32-bit floating point 
format and values of the predefined type LONG FLOAT are represented using the 64-bit 
floating point format as defined by the standard. The values of any other floating point 
type are represented in the same way as the values of the predefined type from which it 
derives, directly or indirectly. 


26 


Aisys Ada for the Transputer, Appendix F, i ’5.4 








Floating point subtypes 

Minimum size: The minimum size of a floating point subtype is 32 bits if its base type is 
FLOAT or a type derived from FLOAT and 64 bits if its base type is long i loa 1 or a type 
derived from LONGFLOAT. 

Size: The sizes of the predefined floating point types FLOAT and long FLOAT are 
respectively 32 and 64 bits. 

The size of a floating point type and the size of any of its subtypes is the size of the 
predefined type from which it derives directly or indirectly. 

The only size that can be specified for a floating point type or first named subtype using a 
size specification is its usual size (32, or 64 bits). 

Object size: An object of a floating point subtype has the same size a.s its subtype. 
Alignment: A floating point subtype is always word aligned. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of a floating point subtype is a multiple 
of the alignment of the corresponding subtype. 


Restrictions on Representation Clauses 


29 





4.4 Fixed Point Types 

Small of a fixed point type 

If no specification of small applies to a fixed point type, then the value of small is 
determined by the value of della as defined by [3.5.9], 

A specification of small can be used to impose a value of small. The value of small is 
required to be a power of two. 

Predefined fixed point types 

To implement fixed point types, the Alsys Compiler for the transputer uses a set of 
anonymous predefined types. These arc: 

type SHORTFIXED is delta D range -2**7*S .. (2**7-1)*S; 
for SHORTFIXED’SMALL use S; 

type FIXED is delta D range -2**31 *S .. (2**31-1)*S; 
for FIXED’SMALL use S; 

where D is any real value and S any power of two less than or equal to D. 

Selection of the parent of a fixed point type 
A fixed point type declared by a declaration of the form: 

type T is delta D range L .. R; 
possibly with a small specification: 
for TSMALL use S; 

is implicitly derived from a predefined fixed point type. The Compiler automatically 
selects the predefined fixed point type whose small and della are the same as the small 
and delta of T and whose range is the shortest that includes the values L and R. 

Encoding of fixed point values 

In the program generated by the Compiler, a safe value V of a fixed point subtype F is 
represented as the integer: 

V / FBASE’SMALL 


30 


Alsys Ada for ilic Transputer, Appendix F, v5.4 







Fixed point subtypes 

Minimum size: The minimum size of a fixed point subtype is the minimum number of 
binary digits that is necessary for representing the values of the range of the subtype using 
the small of the base type (that is to say, in an unbiased form which includes a sign bit only 
if the range of the subtype includes negative values). 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, s and S being 
the bounds of the subtype, if i and I arc the integer representations of m and M, the 
smallest and the greatest model numbers of the base type such that s < m and M < S, 
then the minimum size L is determined as follows. For i > = 0, L is the smallest positive 
integer such that I < = 2*--l. For i < 0, L is the smallest positive integer such that - 
2 1 -' 1 < = i and I < = 2 L1 -1. 

For example: 

type F is delta 2.0 range 0.0 .. 500.0; 

-- The minimum size of F is S bits. 

subtype 8 is F delta 10.0 range 0.0 .. 250.0; 

-- The minimum size of S is 7 bits. 

subtype D is S range X .. Y; 

- Assuming that X and Y are not static, the minimum size of D is 7 bits 
-- (the same as the minimum size of its type mark S). 

Size: The sizes of the sets of predefined fixed point types SHORTFIXED, and FIXED are 8 
and 32 bits respectively. 

When no size specification is applied to an fixed point type or to its first named subtype (if 
any), its size and the size of any subtypes is the smallest of 32,8,4, 2 or 1 bit which is 
equal to or greater than the minimum size for the type or first named type. 

For example: 

type F is delta 0.01 range 0.0 .. 1.0; 

-- F is derived from a 8 bit predefined fixed type, its size is 8 bits, 
type L is delta 0.01 range 0.0 .. 300.0; 

-- L is derived from a 32 bit predefined fixed type, its size is 32 bits, 
type N is new L range 0.0 .. 2.0; 

-- N is indirectly derived from a 32 bit predefined fixed type, its size is 32 bits. 


Restrictions on Representation Clauses 


31 






When a size specification is applied to a fixed point type, this fixed point type and each of 
its subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or equal 
to the minimum size of the type or subtype to which it applies. 

For example: 

type F is delta 0.01 range 0.0 .. 1.0; 
for FSIZE use 32; 

-- F is derived from a 8 bit predefined fixed type, but its size is 32 bits 
-- because of the size specification. 

type L is delta 0.01 range 0.0 .. 300.0; 
for FSIZE use 16; 

- F is derived from a 32 bit predefined fixed type, but its size is 16 bits 
-- because of the size specification. 

-- The size specification is legal since the range contains no negative values 

- and therefore no sign bit is required. 

type N is new F range 0.8 .. 1.0; 

- N is indirectly derived from a 16 bit predefined fixed type, but its size is 

- 32 bits because N inherits the size specification of F. 

The Alsys Compiler implements size specifications. Nevertheless, as fixed point objects 
are represented using machine integers, the specified length cannot be greater than 32 
bits. 

Object size: Provided its size is not constrained by a record component clause or a 
pragma PACK, the size of an object of a fixed point subtype is determined as follows: 

When no size specification is applied to the fixed point type or its first named subtype (if 
any), the objects this type, or any of its subtypes, have the size of the predefined type from 
which it derives directly or indirectly. 

When a size specification is applied to an fixed point type or its first named subtype, 
objects of this integer type, or of any of its subtypes, have the size specified by the length 
clause. 

Alignment: A fixed point subtype is byte aligned if its size is less than or equal to 8 bits, 
word aligned otherwise. 


32 


Alsys Ada for the Transputer, Appendix F, vS.4 







Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of a fixed point subtype is a multiple of 
the alignment of the corresponding subtype. 


4.5 Access Types 

Collection Size 

When no specification of collection size applies to an access type, no storage space is 
reserved for its collection, and the value of the attribute STORAGES1ZE is then 0. 

As described in [13.2], a specification of collection size can be provided in order to reserve 
storage space for the collection of an access type. The Aisys Compiler fully implements 
this kind of specification. 


Encoding of access values 

Access values are machine addresses represented as machine word - sized values (i.e. 32 
bits). 


Access subtypes 

Minimum size: The minimum size of an access subtype is that of the word size of the 
target transputer. 

Size: The size of an access subtype is the same as its minimum size. 

The only size that can be specified for an access type using a size specification is its usual 
size. 

Object size: An object of an access subtype has the same size as its subtype, thus an 
object of an access subtype is always one machine word long. 

Alignment: An access subtype is always word aligned. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of an access subtype is always on a 
word boundary, since its subtype is word aligned. 


Restrictions on Representation Clauses 


33 







4.6 Task Types 

Storage for a task activation 

When no length clause is used to specify the storage space to be reserved for a task 
activation, the storage space indicated at bind time is used for this activation. 

As described in (13.2], a length clause can be used to specify the storage space for the 
activation of each of the tasks of a given type. In this case the value indicated at bind time 
is ignored for this task type, and the length clause is obeyed. 

Both the length clause and the bind time parameter specify the combined size of the task’s 
primary and auxiliary stacks. Further bind time parameters specify the percentage of this 
storage size to be allocated to the primary stack and indicate whether or not to attempt to 
allocate the primary stack in fast internal memory. These bind time parameters indicate 
the default action and can be overridden using the implementation defined pragmas 
STORAGESIZERATIO and FAST_PRJMARY. 

pragma STORAGE_SIZE_RATIO ( taskjiame , integer literal ); 

pragma FAST PRIMARY ( taskjiame , YES | NO ); 

These two pragmas are not allowed for derived types. They apply to the task type 
taskjiame. For each pragma, the pragma and the declaration of the task type to which it 
applies must both occur within the same declarative part or package specification, 
although the declaration of the task type must precede the pragma. 

Pragma STORAGE SIZE RATIO specifies the percentage of the total storage size reserved 
for the activation of the task to be used as the task’s primary stack. Any remaining storage 
space will be used as the task’s auxiliary stack. In the absence of the pragma the default 
ratio specified at bind time is used for the activation. 

Pragma FAST PRIMARY specifies whether or not an attempt should be made to allocate 
the task’s primary stack in fast internal memory. In the absence of the pragma the default 
indication specified at bind time is used for the activation. 


Encoding of task values 

Task values are represented as machine word sized values. 


34 


Alsys Ada for the Transputer, Appendix F, vS-4 








Task subtypes 

Minimum size: The minimum size of a task subtype is 32 bits. 

Size: The size of a task subtype is the same as its minimum size. 

The only size that can be specified for a task type using a size specification is its usual size. 

Object size: An object of a task subtype has the same size as its subtype. Thus an object 
of a task subtype is always 32 bits long. 

Alignment: A task subtype is always word aligned. 

Object address: Provided its alignment is not constrained by a record representation 
clause, the address of an object of a task subtype is always on a word boundary, since its 
subtype is word aligned. 


Restrictions on Representation Clauses 


35 






4.7 Array Types 

Layout of an array 

Each array is allocated in a contiguous area of storage units. All the components have the 
same size. A gap may exist between two consecutive components (and after the last one). 
All the gaps have the same size. 



□ 


□ 




Component Gap Component Gap Component Gap 


Components 

If the array is not packed, the size of the components is the size of any object of the 
subtype of the components. 

For example: 

type A is array (1.. 8) of BOOLEAN; 

- The size of the components of A is the size of any object of the type boolean: 

- 8 bits. 

type DECIMAL_DIGIT is range 0.. 9; 
for DECIMAL DIGITSIZE use 4; 
type BINARY_CODED_DECIMAL is 

array (INTEGER range < >) of DECIMAL_DIGIT; 

-- The size of the type DECIMAL DIGIT is 4 bits. Thus in an array of 

— type BINARY CODED DECIMAI. each component will be represented in 

— 4 bits as in the usual BCD representation. 

If the array is packed and its components are neither records nor arrays, the size of the 
components is the size of the subtype of the components. 


36 


AlsysAda for the Transputer, Appendix F, v5.4 









For example: 

type A is array (1 .. 8) of BOOLEAN; 
pragma PACK(A); 

- The size of the components of A is the size of the type BOOLEAN: 1 bit. 

type DECIMal_DIGIT is range 0 .. 9; 
type binary_coded_decimal is 

array (integer range < >) of decimaldigit; 
pragma pack(binarycodeddecimal); 

- The size of the type decimaldigit is 4 bits. 

-- BINARY CODED DECIMAL is packed, each component of an array of this 

- type will be represented in 4 bits as in the usual BCD representation. 

Packing the array has no effect on the size of the components when the components are 
records or arrays. 


Gaps 

If the components are records or arrays, no size specification applies to the subtype of the 
components and the array is not packed, then the Compiler may choose a representation 
with a gap after each component; the aim of the insertion of such gaps is to optimize 
access to the array components <• id to their subcomponents. The size of the gap is chosen 
so that the relative displacement of consecutive components is a multiple of the alignment 
of the subtype of the components. This strategy allows each component and 
subcomponent to have an address consistent with the alignment of its subtype 

For example: 

type R is 
record 

K : INTEGER; — INTEGER is word aligned. 

B : BOOLEAN; -- BOOLEAN is byte aligned. 

end record; 

-- Record type R is word aligned. Its size is 40 bits, 
type A is array (1.. 10) of R; 

— A gap of three bytes is inserted after each component in order to respect the 
-- alignment of type R. The size of an array of type A will be 640 bits. 


Restrictions on Representation Clauses 


37 






Component Gap Component Gap Component Gap 
Array of type A: each subcomponent K has a word offset. 


If a size specification applies to the subtype of the components or if the array is packed, no 
gaps are inserted. 

For example: 

type R is 
record 

K : INTEGER; 

B : BOOLEAN; 

end record; 

type A is array (1.. 10) of R; 
pragma PACK(A); 

-- There is no gap in an array of type a because A is packed. 

— The size of an object of type A will be 400 bits. 

type NR is new R; 
for NR'SIZE use 40; 

type B is array (1 .. 10) of NR; 

- There is no gap in an array of type B because NR has a size specification. 

-- The size of an object of type B will be 400 bits. 






m 

a 



m 

! 


m 

H 



■ ■■■■ 



Component Component Component 

Array of type A or B: a subcomponent K can have any byte offset. 


38 


AisysAda for the Transputer, Appendix F, v5A 












Array subtypes 

Size: The size of an array subtype is obtained by multiplying the number of its 
components by the sum of the size of the components and the size of the gaps (if any). If 
the subtype is unconstrained, the maximum number of components is considered. 

The size of an array subtype cannot be computed at compile time 

■ if it has non-static constraints or is an unconstrained array type with non-static index 
subtypes (because the number of components can then only be determined at run 
time). 

■ if the components are records or arrays and their constraints or the constraints of 
their subcomponents (if any) are not static (because the size of the components and 
the size of the gaps can then only be determined at run time). 

As has been indicated above, the effect of a pragma PACK on an array type is to suppress 
the gaps and to reduce the size of the components. The consequence of packing an array 
type is thus to reduce its size. 

If the components of an array are records or arrays and their constraints or the constraints 
of their subcomponents (if any) are not static, the Compiler ignores any pragma PACK 
applied to the array type but issues a warning message. Apart from this limitation, array 
packing is fully implemented by the Alsys Compiler. 

The only size that can be specified for an array type or first named subtype using a size 
specification is its usual size. Nevertheless, such a length clause can be useful to verify 
that the layout of an array is as expected by the application. 

Object size: The size of an object of an array subtype is always equal to the size of the 
subtype of the object. 

Alignment: If no pragma PACK applies to an array subtype and no size specification 
applies to its components, the array subtype has the same alignment as the subtype of its 
components. 

If a pragma PACK applies to an array subtype or if a size specification applies to its 
components (so that there are no gaps), the alignment of the array subtype is the lesser of 
the alignment of the subtype of its components and the relative displacement of the 
components. 


Restrictions on Representation Clauses 


39 





Object address: Provided its alignment is not constrained by a record representation 
clause, the address of an object of an array subtype is a multiple of the alignment of the 
corresponding subtype. 


4.8 Record Types 

Layout of a record 

Each record is allocated in a contiguous area of storage units. The size of a record 
component depends on its type. Gaps may exist between some components. 

The positions and the sizes of the components of a record type object can be controlled 
using a record representation clause as described in [13.4], In the Alsys implementation 
for transputer targets there is no restriction on the position that can be specified for a 
component of a record. If a component is not a record or an array, its size can be any size 
from the minimum size to the size of its subtype. If a component is a record or an array, 
its size must be the size of its subtype. 

In a record representation clause, the first storage unit (that is, a byte) and the first bit 
position within a storage unit are numbered zero. Bits are ordered, and thus numbered, 
least significant bit first within a storage unit. Storage units are numbered such that lower 
numbers have the least significance in a machine word. 

A component clause may be specified such that the component overlaps a storage unit 
boundary. In this case, the bits are numbered in sequence from the least significant bit of 
the first storage unit to the most significant bit of the last storage unit occupied by the 
component. For example: 

type BIT3 is range 0 .. 7; 
for Brr_3’SlZE use 3; 

type BIT S is range 0 .. 31; 
for BIT_5’SIZE use 5; 

type BITS is range 0 .. 255; 
for BIT_8’SIZE use 8; 


40 


Alsys Ada for the Transputer, Appendix F, v5.4 








type R is 
record 

FIRST: BIT_3: 

SECOND : BIT_8; 

THIRD : BIT 5: 
end record; 
for R use 
record 

FIRST at 0 range 0 .. 2; 

SECOND at 0 range 3 .. 10; 

— Component SECOND overlaps a storage unit boundary. 

THIRD at 1 range 3 .. 7; 
end record; 
for R’SlZE use 16; 


Most Significant 
Bit (MSB) 


1 0 Storage unit number 


Least Significant 
Bit (LSB) 


7 3207 320 Bit nunber within 

storage unit 



Representation of a Record of type R 


A record representation clause need not specify the position and the size for every 
component. 

If no component clause applies to a component of a record, its size is the size of objects of 
its subtype. Its position is chosen by the Compiler so as to optimize access to the 
components of the record: the offset of the component is chosen as a multiple of the 
alignment of the component subtype. Moreover, the Compiler chooses the position of the 
component so as to reduce the number of gaps and thus the size of the record objects. 

Because of these optimisations, there is no connection between the order of the 
components in a record type declaration and the positions chosen by the Compiler for the 
components in a record object. 


Restrictions on Representation Clauses 


41 




Indirect components 

If the offset of a component cannot be computed at compile time, this offset is stored in 
the record objects at run time and used to access the component. Such a component is 
said to be indirect while other components are said to be direct: 



Beg inning of the record 
Compile time offset 


Compile time offset 


Run time offset 


A direct and an indirect component 


If a record component is a record or an array, the size of its subtype may be evaluated at 
run time and may even depend on the discriminants of the record. We will call these 
components dynamic components. 


42 


AlsysAda for the Transputer, Appendix F, vS.4 





For example: 

type DEVICE is (SCREEN fER); 

type COLOR is (GREEN, RED, BLUE); 

type SERIES is array (POsmvE range < >) of INTEGER; 

type GRAPH (L : NATURAL) is 
record 

X : SERIES( 1.. L); - The size of X depends on L 
Y : SERIES(1 .. L); — The size of Y depends on L 

end record; 

Q : POSITIVE; 

type PICTURE (N : NATURAL; I) : DEVICE) is 

record 

F : GRAPli(N); -- The size of F depends on N 
S : GRAPH(Q); — The size of S depends on Q 
case D is 

when SCREEN = > 

C: COLOR; 
when PRINTER = > 

null; 

end case; 
end record; 

Any component placed after a dynamic component has an offset which cannot be 
evaluated at compile time and is thus indirect. In order to minimize the number of 
indirect components, the Compiler groups the dynamic components together and places 
them at the end of the record: 


Restrictions on Representation Clauses 


43 





The record type PICTURE: F and S are placed at the end of the record 

Thanks to this strategy, the only indirect components are dynamic components. But not 
all dynamic components are necessarily indirect: if there are dynamic components ir, a 
component list which is not followed by a variant part, then exactly one dynamic 
component of this list is a direct component because its offset can be computed at 
compilation time. 


44 


Alsys Ada for the Transputer, Appendix F, v5.4 






For example: 



> Beginning of the record 
. Compile time offset 

—Compile time offset 
Size dependent on discriminant L 
————— Run time offset 
Size dependent on discriminant l 


The record type GRAPH: the dynamic component X is a direct component. 


The offset of an indirect component is always expressed in storage units. 

The space reserved for the offset of an indirect component must be large enough to store 
the size of any value of the record type (the maximum potential offset). The Compiler 
evaluates an upper bound MS of this size and treats an offset as a component having an 
anonymous integer type whose range is 0.. MS. 

If C is the name of an indirect component, then the offset of this component can be 
denoted in a component clause by the implementation generated name C'OFFSET. 


Implicit components 

In some circumstances, access to an object of a record type or to its components involves 
computing information which only depends on the discriminant values. To avoid 
unnecessary recomputation, the Compiler stores this information in the record objects, 
updates it when the values of the discriminants are modified and uses it when the objects 
or their components are accessed. This information is stored in special components called 
implicit components. 


Restrictions on Representation Clauses 


45 







An implicit component may contain information which is used when the record object or 
several of its components are accessed. In this case the component will be included in any 
record object (the implicit component is considered to be declared before any variant part 
in the record type declaration). There can be two components of this kind; one is called 
RECORD_siZE and the other variant tvnrx. 

On the other hand an implicit cu. . ... may be used to access a given record 

component. In this case the implicit component exists whenever the record component 
exists (the implicit component is considered to be declared at the same place as the record 
component). Components of this kind are called ARRAYDESCRJPTORs or 
RECORD DESCRIPTORS. 

RECORD SIZE 

This implicit component is created by the Compiler when the record type has a variant 
part and its discriminants are defaulted. It contains the size of the storage space necessary 
to store the current value of the record object (note that the storage effectively allocated 
for the record object may be more than this). 

The value of a RECORDSIZE component may denote a number of bits or a number of 
storage units. In general it denotes a number of storage units, but if any component 
clause specifies that a component of the record type has an offset or a size which cannot 
be expressed using storage units, then the value designates a number of bits. 

The implicit component RECORD SIZE must be large enough to store the maximum size of 
any value of the record type. The Compiler evaluates an upper bound MS of this size and 
then considers the implicit component as having an anonymous integer type whose range 
is 0.. MS. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R’RECORD SIZE. 

VAR1A NTJNDEX 

This implicit component is created by the Compiler when the record type has a variant 
part. It indicates the set of components that are present in a record value. It is used when 
a discriminant check is to be done. 

Component lists that do not contain a variant part are numbered. These numbers are the 
possible values of the implicit component VARIANT INDEX. 


46 


Alsys Ada for the Transputer, Appendix F, vS.4 







For example: 


type VEHICLE is (AIRCRAFT. ROCKET, BOAT. CAR); 

type DESCRIPTION (KIND : VEHICLE : = CAR) is 

record 

SPEED : INTEGER; 
case KIND is 

when AIRCRAFT I CAR = > 

WHEELS : INTEGER; 
case KIND is 

when AIRCRAFT = > — 1 

WINGSPAN : INTEGER; 

when otiiers = > — 2 

null; 
end case; 

when boat = > - 3 

STEAM : BOOLEAN; 
when ROCKET = > - 4 

STAGES : INTEGER; 

end case; 
end record; 

The value of the variant index indicates the set of components that are present in a record 
value: 


Variant Index 

Set 

1 

{KIND, SPEED, UHEELS, WINGSPAN) 

2 

{KIND, SPEED, WHEELS) 

3 

{KIND, SPEED, STEAM) 

4 

{KIND, SPEED, STAGES) 


A comparison between the variant index of a record value and the bounds of an interval is 
enough to check that a given component is present in the value: 


Restrictions on Representation Clauses 


47 








Component 

interval 

KIND 


SPEED 

-- 

WHEELS 

1 .. 2 

WINGSPAN 

1 .. 1 

STEAM 

nvn 

STAGES 

mu 


The implicit component VARIANT INDEX must be large enough to store the number V of 
component lists that don’t contain variant parts. The Compiler treats this implicit 
component as having an anonymous integer type whose range is 1 .. V. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name RVARIANTJNDEX. 

ARRAY DESCRIPTOR 

An implicit component of this kind is associated by the Compiler with each record 
component whose subtype is an anonymous array subtype that depends on a discriminant 
of the record. It contains information about the component subtype. 

The structure of an implicit component of kind ARRAYDESCRIPTOR is not described in 
this documentation. Nevertheless, if a programmer is interested in specifying the location 
of a component of this kind using a component clause, he can obtain the size of the 
component using the ASSEMBLY parameter in the COMPILE command. 

The Compiler treats an implicit component of the kind ARRAYDESCRIPTOR as having an 
anonymous record type. If C is the name of the record component whose subtype is 
described by the array descriptor, then this implicit component can be denoted in a 
component clause by the implementation generated name CARRAY DESCRIPTOR. 

RECORD DESCRIPTOR 

An implicit component of this kind is associated by the Compiler with each record 
component whose subtype is an anonymous record subtype that depends on a discriminant 
of the record. It contains information about the component subtype. 

The structure of an implicit component of kind RECORD DESCRIPTOR is not described in 
this documentation. Nevertheless, if a programmer is interested in specifying the location 
of a component of this kind using a component clause, he can obtain the size of the 
component using the assembly parameter in the COMPILE command. 


48 


AlsysAda for the Transputer, Appendix F, v5.4 













The Compiler treats an implicit component of the kind RECORDDESCRllTOR as having 
an anonymous record type. If C is the name of the record component whose subtype is 
described by the record descriptor, then this implicit component can be denoted in a 
component clause by the implementation generated name crecorddescriptor. 


Suppression of implicit components 

The Alsys implementation provides the capability of suppressing the implicit components 
RECORD SIZE and/or VARIANTJNDEX from a record type. This can be done using an 
implementation defined pragma called IMPROVE. The syntax of this pragma is as follows: 

pragma IMPROVE (TIME | SPACE , [ON = >] simple name ); 

The first argument specifies whether TIME or SPACE is the primary criterion for the choice 
of the representation of the record type that is denoted by the second argument. 

If TIME is specified, the Compiler inserts implicit components as described above. If on 
the other hand SPACE is specified, the Compiler only inserts a VARIANTJNDEX or a 
RECORD S1ZE component if this component appears in a record representation clause that 
applies to the record type. A record representation clause can thus be used to keep one 
implicit component while suppressing the other. 

A pragma improve that applies to a given record type can occur anywhere that a 
representation clause is allowed for this type. 


Retard srbtypes 

Size: UnLss a component clause specifies that a component of a record type has an offset 
or a size which cannot be expressed using storage units, the size of a record subtype is 
rounded up to a whole number of storage units. 

The size of a constrained record subtype is obtained by adding the sizes of its components 
and the sizes of its gaps (if any). This size is not computed at compile time 

• when the record subtype has non-static constraints, 

• when a component is an array or a record and its size is not computed at compile 
time. 

The size of an unconstrained record subtype is obtained by adding the sizes of the 
components and the sizes of ihc gaps (if any) of its largest variant. If the size of a 


Restrictions on Representation Clauses 


49 








component or of a gap cannot be evaluated exactly at compile time, an upper bound of 
this size is used by the Compiler to compute the subtype size. 

The only size that can be specified for a record type or first named subtype using a size 
specification is its usual size. Nevertheless, such a length clause can be useful to verify 
that the layout of a record is as expected by the application. 

Object size: An object of a constrained record subtype has the same size as its subtype. 

An object of an unconstrained record subtype has the same size as its subtype if this size is 
less than or equal to 4 Kbyte. If the size of the subtype is greater than this, the object has 
the size necessary to store its current value; storage space is allocated and released as the 
discriminants of the record change. 

Alignment: When no record representation clause applies to its base type, a record 
subtype has the same alignment as the component with the highest alignment 
requirement. 

When a record representation clause that does not contain an alignment clause applies to 
its base type, a record subtype has the same alignment as the component with the highest 
alignment requirement which has not been overridden by its component clause. 

When a record representation clause that contains an alignment clause applies to its base 
type, a record subtype has an alignment that obeys the alignment clause. 

Object address: Provided its alignment is not constrained by a representation clause, the 
address of an object of a record subtype is a multiple of the alignment of the 
corresponding subtype. 


50 


Alsys Ada for (he Transputer, Appendix F, v5.4 






CHAPTER 5 


Conventions for Implementation-Generated Names 

Special record components are introduced by the Compiler for certain record type 
definitions. Such record components are implementation-dependent; they arc used by the 
Compiler to improve the quality of the generated code for certain operations on the 
record types. The existence of these components is established by the Compiler 
depending on implementation-dependent criteria. Attributes are defined for referring to 
them in record representation clauses. An error message is issued by the Compiler if the 
user refers to an implementation-dependent component that does not exist. If the 
implementation-dependent component exists, the Compiler checks that the storage 
location specified in the component clause is compatible with the treatment of this 
component and the storage locations of other components. An error message is issued if 
this check fails. 

There are five such attributes described below (also see section 4.8): 

TRECORD StZE For a prefix T that denotes a record type. This attribute 

refers to the record component introduced by the Compiler 
in a record to store the size of the record object. This 
component exists for objects of a record type with defaulted 
discriminants when the sizes of the record objects depend 
on the values of (he discriminants. 

TVAR1ANTJNDEX For a prefix T that denotes a record type. This attribute 

refers to the record component introduced by the Compiler 
in a record to assist in the efficient implementation of 
discriminant checks. This component exists for objects of a 
record type with variant type. 

CARRAY DESCRIPTOR For a prefix C that denotes a record component of an array 

type whose component subtype definition depends on 
discriminants. This attribute refers to the record 
component introduced by the Compiler in a record to store 
information on subtypes of components that depend on 
discriminants. 


Conventions for Implementation Generated Names 


51 








CRECORD DESCRIPTOR 


COFFSET 


For a prefix C that denotes a record component of a record 
type whose component subtype definition depends on 
discriminants. This attribute refers to the record 
component introduced by the Compiler in a record to store 
information on subtypes of components that depend on 
discriminants. 

For a prefix C that denotes an indirect component of a 
record type. This attribute refers to the offset component 
introduced by the Compiler in a record to store the offset of 
C. 


52 


Alsvs Ada for the Transputer, Appendix F, v5.4 







CHAPTER 6 


Address Clauses 

6.1 Address Clauses for Objects 

An address clause can be used to specify an address for an object as described in [13.5]. 
When such a clause applies to an object no storage is allocated for it in the program 
generated by the Compiler. The program accesses the object using the address specified 
in the clause. 

An address clause is not allowed for task objects, nor for unconstrained records whose 
maximum possible size is greater than 4 Kbytes, or for a constant. 


6.2 Address Clauses for Program Units 

Address clauses for program units arc not implemented. 


6.3 Address Clauses for Entries 

Address clauses for entries are not implemented. 


Address Clauses 


53 




54 


Alsys Ada for the Transputer, Appendix F, v5.4 



CHAPTER 7 


Restrictions on Unchecked Conversions 


Unconstrained arrays are not allowed as target types. 

Unconstrained record types without defaulted discriminants are not allowed as target 
types. 

If the source and the target types arc each scalar or access types, the sizes of the objects of 
the source and target types must be equal. If a composite type is used either as the source 
type or as the target type this restriction on the size does not apply. 

If the source and the target types are each of scalar or access type or if they are both of 
composite type, the effect of the function is to return the operand. 

In other cases the effect of unchecked conversion can be considered as a copy: 

■ if an unchecked conversion is achieved of a scalar or access source type to a 

composite target type, the result of the function is a copy of the source operand: the 
result has the size of the source. 

• if an unchecked conversion is achieved of a composite source type to a scalar or 
access target type, the result of the function is a copy of the source operand: the 
result has the size of the target. 


Restrictions on Unchecked Conversions 


55 



56 


AlsysAda for the Transputer, Appendix F, v5.4 






CHAPTER 8 


Input-Output Packages 


The predefined input-output packages SEQUENTIAL JO [14.2.3], DIRECT jo [14.2.5], 

TEXT JO [14.3.10] and lOEXCEPTIONS [14.5] are implemented as described in the 
Language Reference Manual. 

It should be noted that, in order to generate output, calls to PUT procedures should be 
followed by a call to either PUTJLINE or new line. 

The package LOWJ.EVEI.JO [14.6], which is concerned with low-level machine-dependent 
input-output, is not implemented. 

All access to the services of the host system are provided through the INMOS supplied 
server (e.g. isen’er Ref.3), so much of Ada inpul-output is host independent. Any 
restrictions that apply to the server will also apply to the Ada input-output. 


8.1 NAME Parameter 

No special treatment is applied to the NAME parameter supplied to the Ada procedures 
CREATE or OPEN [14.2.1]. This parameter is passed immediately on to the INMOS server 
and from there to the host operating system. The file name can thus be in any format 
acceptable to the host system. 


8.2 FORM Parameter 

The FORM parameter comprises a set of attributes formulated according to the lexical 
rules of [2], separated by commas. The form parameter may be given as a null string 
except when DlRECT IO is instantiated with an unconstrained type; in this case the record 
size attribute must be provided. Attributes are comma-separated; blanks may be inserted 
between lexical elements as desired. In the descriptions below the meanings of natural, 
positive, etc., are as in Ada; attribute keywords (represented in upper case) arc identifiers 
[2.3] and as such may be specified without regard to case. 

USE ERROR is raised if the FORM parameter docs not conform to these rules. 


Input-Output Packages 


57 






The attributes are as follows: 

8.2.1 File Sharing 

This attribute allows control over the sharing of one external file between several internal 
files within a single program. In effect it establishes rules for subsequent OPEN and 
CREATE calls which specify the same external file. If such rules are violated or if a 
different file sharing attribute is specified in a later OPEN or CREATE call, USEERROR will 
be raised. The syntax is as follows: 

NOT SHARED| 

SHARED = > access mode 


where 

access mode :: = READERS | SINGLEWRITER | ANY: 

A file sharing attribute of: 

NOT SHARED implies only one internal file may access the 

external file. 

SHARED = > READERS imposes no restrictions on internal files of 

mode INFILE, but prevents any internal files of 
mode OUTFILE or INOUT FILE being 
associated with the external file. 

SHARED = > SINGLE WRITER is as SHARED = > READERS, but in addition 

allows a single internal file of mode OUTFILE 
or INOUTFILE. 

SHARED = > ANY places no restriction on external file string. 

If a file of the same name has previously been opened or created, the default is taken from 
that file’s sharing attribute, otherwise the default depends on the mode of the file: for 
mode IN Fll.l- the default is shared = > READERS, for modes INOUT FILE and OUT FILE 
the default is NOT SHARED. 


5S 


Alsys Ada for the Transputer, Appendix F, \ 5.4 






8.2.2 Binary Files 

Two FORM attributes, RECORDSIZE and RECORDUNIT, control the structure of binary 
files. 

A binary file can be viewed as a sequence (sequential access) or a set (direct access) of 
consecutive RECORDS. 

The structure of such a record is: 

( HEADER 1 OBJECT { UNUSEDPART ] 

and it is formed from up to three items: 

■ an OBJECT with the exact binary representation of the Ada object in the executable 
program, possibly including an object descriptor 

■ a HEADER consisting of two word sized fields: 

- the length of the object in bytes 

- the length of the descriptor in bytes 

• an UNUSED PART of variable size to permit full control of the record’s size 

The HEADER is implemented only if the actual parameter of the instantiation of the IO 
package is unconstrained. 

The file structure attributes lake the form: 

RECORD SIZE = > size in bytes 
RECORDUNIT = > size in bytes 

Their meaning depends on the object’s type (constrained or not) and the file access mode 
(sequential or direct access): 

a) If the object’s type is constrained: 

- The RECORD UNI T attribute is illegal 

- If the RECORDSIZE attribute is omitted, no UNUSED PART will be 
implemented: the default RECORDSIZE is the object’s size 


Inpui-Outinu Packages 


59 







If present, the RECORDSIZE attribute must specify a record size greater than or 
equal to the object’s size, otherwise the exception USEERROR will be raised 


b) If the object’s type is unconstrained and the file access mode is direct: 

- The RECORD UNIT attribute is illegal 

- The RECORDSIZE attribute has no default value, and if it is not specified, a 
USE ERROR will be raised 

- An attempt to input or output an object larger than the given RECORD SIZE will 
raise the exception DATAERROR 

c) If the object’s type is unconstrained and the file access mode is sequential: 

- The RECORD SIZE attribute is illegal 

- The default value of the RECORD UNIT attribute is 1 (byte) 

- The record size will be the smallest multiple of the specified (or default) 
RECORD UNIT that holds the object and its header. This is the only case where 
records of a file may have different sizes. 

In all cases the value given must not be smaller than a minimum size. For constrained 
types, this minimum size is ELEMENT TYPE SIZE / SYSTEM.STORAGE UNIT; USE ERROR 
will be raised if this rule is violated. For unconstrained types, the minimum size is 
ELEMENTTYPEDESCRIPTORSIZE / SYSTEM.STORAGEUNIT plus the size of the largest 
record which is to be read or written. If a larger record is processed, DA TA ERROR will be 
raised by the READ or WRITE. 


8.2.3 Buffering 

This attribute controls the size of the buffer used as a cache for input-output operations: 

BUFFER_SJZE = > sizc_in_bytcs 
The default value for BUFFERSIZF. is 0; which means no buffering. 


60 


Alsys Ada for the Transputer, Appendix F, v5.4 







8.2.4 Appending 

This attribute may only be used in the FORM parameter of the OPEN command. If used in 
the FORM parameter of the create command, USEERROR will be raised. 

The affect of this attribute is to cause writing to commence at the end of the existing file. 

The syntax of the APPEND attribute is simply: 

APPEND 

The default is APPEND = > FALSE, but this is overridden if this attribute is specified. 

In normal circumstances, when an external file is oper.ed, an index is set which points to 
the beginning of the file. If the APPEND attribute is present for a sequential or for a text 
file, then data transfer will commence at the end of the file. For a direct access file, the 
value of the index is set to one more than the number of records in the external file. 

This attribute is not applicable to terminal devices. 


S3 USE ERROR 

The following conditions will cause USE ERROR to be raised: 

■ Specifying a FORM parameter whose syntax does not conform to the rules given 
above. 

■ Specifying the RECORDSIZE FORM parameter attribute to have a value of zero, or 
failing to specify RECORDSIZE for instantiations of DIRECT JO for unconstrained 
types. 

■ Specifying a RECORD SIZE FORM parameter attribute to have a value less than that 
required to hold the clement for instantiations of DIRECT JO and SEOUENTlALIO for 
constrained types. 

• Violating the file sharing rules stated above. 

■ Attempting to perform an input - output operation which is not supported by the 
INMOS iserver due to restrictions of the host operating system. 

■ Errors delected whilst reading or writing (e.g. writing to a file on a read-only disk). 


Input-Output Packages 


61 







62 


A lays Ada for the Transputer, Appendix F, v5.4 












CHAPTER 9 


Characteristics of Numeric Types 
9.1 Integer Types 

The ranges of values for integer types declared in package standard are as follows: 
SHORTINTEGER -128.. 127 - 2**7 - 1 

INTEGER -2147483648 .. 2147483647 - 2**31 - 1 

Other Integer Types 

For the packages DIRECT IO and TEXTJO, the ranges of values for types COUNT and 
POSITIVE COUNT are as follows: 

COUNT 0.. 2147483647 - 2**31 - 1 

POSITIVE COUNT 1 .. 2147483647 - 2**31 - 1 

For the package TEXTJO, the range of values for the type FIELD is as follows: 

FIELD 0..255 - 2**8- 1 


Characteristics of Numeric Types 


63 







9.2 Floating Point Type Attributes 


FLOAT 


DIGITS 

6 

Approximate 

value 

MANTISSA 

21 


EMAX 

84 


EPSILON 

2.0 ** -20 

9.54E-7 

SMALL 

2.0 ** -85 

2.58E-26 

LARGE 

2.0 **84 *(1.0 -2.0 **-21) 

1.93E + 25 

SAFE EMAX 

125 


SAFESMALL 

2.0 ** -126 

1.18E-38 

SAFE LARGE 

2.0** 125 *(1.0-2.0 **-21) 

4.25E + 37 

FIRST 

-2.0 ** 127 * (2.0 - 2.0 ** -23) 

-3.40E + 38 

LAST 

2.0 ** 127 * (2.0 - 2.0 ** -23) 

3.40E + 38 

MACHINE RADIX 

2 


machine'mantissa 

24 


MACHINEEMAX 

128 


MACHINE EMIN 

-125 


MACHINE ROUNDS 

TRUE 


machine'overflows 

TRUE 


SIZE 

32 



64 


AlsysAda for the Transputer, Appendix F, i '5.4 







LONGFLOAT 

Approximate 

value 


DIGITS 

15 



MANTISSA 

51 



EMAX 

204 



EPSILON 

2.0 ** -50 


8.88E-16 

SMALL 

2.0 ** -205 


1.94E-62 

LARGE 

2.0 ** 204 * (1.0 - 2.0 ** - 

51) 

2.57E + 61 

SAFE EMAX 

1021 



SAFE SMALL 

2.0 ** -1022 


2.22E-308 

SAFE LARGE 

2.0** 1021 *(1.0-2.0** 

-51) 

2.25E + 307 

FIRST 

-2.0 ** 1023 * (2.0 - 2.0 ** -52) 

-1.79E + 308 

LAST 

2.0 ** 1023 * (2.0 - 2.0 ** 

-52) 

1.79E + 308 

MACHINE RADIX 

2 



MACHINE MANTISSA 

53 



machine'emax 

1024 



MACHINE EMIN 

-1021 



MACHINE ROUNDS 

TRUE 



MACHINE OVERFLOWS 

TRUE 



SIZE 

64 




9 3 Attributes of Type DURATION 


DURATION’DELTA 

2.0 ** -14 

Approximate 

value 

DURATION’SMALL 

2.0 ** -14 


DURATION’LARGE 

2.0**17-2.0**-14 

131072 

DURATION’FIRST 

-131072.0 


DURATION’LAST 

2.0**17-2.0**-14 

131072 


Characteristics of Numeric Types 


65 







66 


Alsys Ada for the Transputer, Appendix F, v5.4 






REFERENCES 


[1] Reference Manual for the Ada Programming Language 
(ANSI/MIL-STD- 1815A-1983). 

[2] Occam2 Reference Manual. 

INMOS Limited 
Prentice Hall, 1988. 

[3] Occam2 Toolset User Manual. 

INMOS Limited. 

See release notes for version number. 

[4] Transputer Instruction Set - A Compiler Writer’s Guide 
INMOS Limited 

Prentice Hall, 19S8 

[5] The T9000 Transputer Instruction Set Manual 
INMOS Limited 


References 





66 


Alsys Ada for the Transputer, Appendix F, vS.4 







INDEX 


Adadesignator 3 
ADDRESS attribute 15 
restrictions 15 
Append attribute 61 
ARRAY_DESCRIPTOR attribute 51 
ASCII 7,9 
Attributes 15 

ARRAY DESCRIPTOR 51 
DESCRIPTOR SIZE 15 
IS ARRAY 15 
OBJECT 52 

RECORD DESCRIPTOR 52 
RECORDSIZE 51, 57 
representation attributes 15 
VAR1ANT INDEX 51 
BOOLEAN 7 
C’OFFSET attribute 52 
CHARACTER 7 
COUNT 63 

DESCRIPTOR SIZE attribute 15, 60 
DIRECTIO 57,63 
DURATION 
attributes 65 
Enumeration types 7 
BOOLEAN 7 
CHARACTER 7 
FAST PRIMARY 13,34 
FIELD 63 

File sharing attribute 58 
Fixed point types 8 
DURATION 65 
FLOAT 8, 28,64 
Floating point types 8 
FLOAT 8, 64 
LONGFLOAT 8,65 
FORM parameter 57 
FORM parameter attributes 


append 61 

file sharing attribute 58 
record_size attribute 61 
Implementation-dependent attributes 
15 

Implementation-dependent pragma 5 
Implementation-generated names 51 
IMPROVE 13 
INDENT 12 
INLINE 3 

1NLINE GENERIC 3 
Input-Output packages 57 
DIRECT IO 57 
IOEXCEPTIONS 57 
LOW LEVEL IO 57 
SEQUENTIAL IO 57 
TEXT IO 57 
INTEGER 7,63 
Integer types 7, 63 
COUNT 63 
FIELD 63 
INTEGER 7,63 
POSITIVE COUNT 63 
SHORT INTEGER 7,63 
INTERFACE 5 
INTERFACE NAME 5,11 
IO EXCEPTIONS 57 
IS ARRAY attribute 15 
Language_name 5 
LONG FLOAT 8, 28, 65 
LOW LEVEL IO 57 
NO IMAGE 12 
NOT_SHARED 58 
Numeric types 

characteristics 63 
Fixed point types 65 
integer types 63 


Index 


69 








OCCAM 5 
OCCAM HIGH 5 
PACK 13 

Parameter representations 7 
Access types 8 
Array types 8 
Enumeration types 7 
Fixed point types 8 
Floating point types 8 
Integer types 7 
Record types 9 

Parameter-passing conventions 6 
POSITIVECOUNT 63 
Pragma INLINE 3 
Pragma INLINE GENERIC 3 
Pragma INTERFACE 5 
languagename 5 
OCCAM 5 
subprogramname 5 
Pragma INTERFACE NAME 5 
stringliteral 11 
subprogramname 11 
Pragma NO IMAGE 12 
Pragmas 

FASTPRIMARY 13,34 
IMPROVE 13 
INDENT 12 
INTERFACE 5 
INTERFACENAME 11 
PACK 13 
PRIORITY 13 

STORAGE_SIZE_RATIO 13, 34 
SUPPRESS 13 
PRIORITY 13 

RECORD DESCRIPTOR attribute 52 
RECORD_SIZE attribute 51,57,61 
Representation attributes 15 
Representation clauses 21 
restrictions 21 
SEQUENTIAL IO 57 


SHARED 58 
SHORT INTEGER 7,63 
STORAGE SIZE RATIO 13,34 
STRING 9 
Stringliteral 11 
Subprogram name 5, 11 
SUPPRESS 13 
SYSTEM package 17 
TEXT IO 57,63 
Unchecked conversions 55 
restrictions 55 
USE ERROR 57,61 
VARIANT INDEX attribute 51 


70 


AlsysAda for the Transputer, Appendix F, v5.4 






