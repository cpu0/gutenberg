

NASA Technical Memorandum 88234 

k 4 

/v-/f7?7 


{NASA-TM-88234) 1IME-BASEE AIE IEAFFIC N86-28068 

MANAGEMENT USING EX FEET SYSTEMS {NASA) 59 p 
HC A04/ME A0 1 CSCE 07G 

Unclas 
G3/03 43477 


Time-Based Air Traffic 
Management Using Expert 
Systems 

L. Tobias and J.L. Scoggins 


April 1986 


fU/VSA 

National Aeronautics and 
Space Administration 


NASA Technical Memorandum 88234 


Time-Based Air Traffic 
Management Using Expert 
Systems 

L. Tobias, 

J. L. Scoggins, Ames Research Center, Moffett Field, California . 


April 1986 


IW\SA 

National Aeronautics and 
Space Administration 

Ames Research Center 

Moffett Field, California 94035 





SUMMARY 


A prototype expert system has been developed for the time scheduling of 
aircraft into the terminal area. The three functions of the air-traffic-control 
schedule advisor are as follows: First, for each new arrival, it develops an admis- 

sible flight plan for that aircraft. Second, as the aircraft progresses through the 
terminal area, it monitors deviations from the aircraft's flight plan and provides 
advisories to return the aircraft to its assigned schedule. Third, if major disrup- 
tions such as missed approaches occur, it develops a revised plan. The advisor is 
operational on a Symbolics 3600, and is programmed in MRS (a logic programming 
language), Lisp, and Fortran. 


INTRODUCTION 


At present, the decision-making process of air traffic control (ATC) in the 
extended terminal area (from 150 n. mi. from touchdown until touchdown) is a manual 
one. Controllers expertly direct traffic flow to maximize capacity without compro- 
mising safety by issuing to each aircraft clearances which specify speed, altitude, 
or heading requirements. In terms of arrivals to a single runway at a major termi- 
nal area, this is generally accomplished as follows: along each of the three to 

four major arrival directions, traffic is spaced uniformly. However, the traffic 
flows from the various arrival directions are uncoordinated. It is the responsibil- 
ity of the final controller to take these uncoordinated flows and establish a 
sequence of traffic which does not violate separation constraints between consecu- 
tive aircraft. 

The automation of selected ATC decision-making functions using a time-based 
framework has been the subject of a series of real-time simulation studies (1). The 
goals of these studies have been to increase landing rate and to reduce fuel con- 
sumption, and in addition, to reduce controller workload. Time scheduling is to be 
accomplished by developing a time plan, and a means of controlling aircraft to 
achieve a desired time, so that traffic flows which reach the final controller are 
coordinated, and that little maneuvering is required to achieve the final 
sequencing. 

The key element in the time-based system is a four -dimensional (4D) algorithm 
(2) which, given the present position, route, and touchdown time, generates a time- 
table of commands to control the aircraft to follow the route specified and touch- 
down at the specified time. Flight tests of aircraft equipped with the 4D software 
have demonstrated that accuracies of ±5 sec can be obtained. In addition, it has 


1 


been demonstrated in simulation studies (3) that modifications of the 4D algorithms 
can be used by the ATC computer to generate a speed advisory to assist in achieving 
time accuracies of ±20 sec for aircraft which are unequipped.^ 

Real-time simulation studies have used these 4D algorithms to investigate the 
feasibility of a time-based set of candidate operational procedures for handling a 
mix of 4D-equipped and -unequipped aircraft in the terminal area. The operational 
procedures include a time-assignment procedure for new arrivals, a procedure to 
correct for time errors as the aircraft progresses through the terminal area, and a 
means of handling missed approaches. Results indicate that the procedures investi- 
gated are promising; however, they represent only a limited (but important) subset 
of the procedures which will be required for implementing a time-based system. 
Attention needs to be focused on a more complete, adaptable plan for scheduling 
traffic into the terminal area. 

This paper describes the initial step in implementing a more complete, time- 
based system for traffic management in the extended terminal area using the frame- 
work of expert systems. A prototype schedule advisor formulated as an expert system 
is described. First, the rationale for an expert systems approach is given. This 
is followed by a detailed description of the ATC problem. The software design is 
then outlined, with a complete, documented code given in the appendix. Finally, 
plans for the continued development of the schedule advisor are discussed. 


RATIONALE FOR AN EXPERT SYSTEMS APPROACH FOR A 
SCHEDULE ADVISOR 


The plan for implementing a schedule advisor in an actual operating environment 
will be initially to provide a system with limited capabilities, and to gradually 
increase the sophistication of the computer software as more of the controller's 
expertise is understood. Thus, the controller would initially possess considerable 
knowledge not resident in the advisor, and would need to interact with the advisor 
to modify or override the computer-generated plans. The controller may want to 
prohibit the scheduling of aircraft during a time interval because of runway visi- 
bility problems, to assign priority to one aircraft because it is low on fuel, or to 
request a particular landing order for a group of aircraft to increase the landing 
rate. 


In addition to the interaction requirement, it is also necessary for the 
advisor to explain its actions to the controller . 2 The controllers may initially be 
skeptical of the computer-generated plans, particularly if the computer solution is 


Without speed advisories, time accuracies of 
controllers in the en route area. 

2 The explanation capability of expert systems 
in Ref. 4. 


±2 min 
in the 


have been achieved by 
ATC context is discussed 


2 



not in complete agreement with their own intuitive plan. If the logic of the com- 
puter plan is understood, the controller will gain confidence in the system more 
quickly. 

It is also expected that the initial set of heuristics will need to be modi- 
fied. The new heuristics can readily be formulated as added or modified rules: for 

example, the controller may wish to add a rule to restrict the speed of an aircraft 
which is in a given altitude range of a given sector under specified traffic flow 
conditions. It is important that the modifications described be readily 
implemented . 

It is for these primary reasons — the need for a software system which is inter- 
active, which can explain its behavior, and which can easily accept procedural 
modifications — that an expert systems approach has been formulated. In addition, it 
should also be noted that there are many other suggested expert system guidelines 
(5) that are met for this problem area. There are many domain experts that under- 
stand and operate the present ATC system, and there are some whose expertise has 

been built over a long period of time who can commit a substantial amount of time to 

the development of the system. In addition, the problem domain is well bounded — the 
problem under consideration is restricted to routes in a major terminal area from 
120 n. mi. from touchdown until touchdown. At any one time the number of aircraft 
in the plan is less than 100, and thus reasoning about aircraft schedules in real 
time should not be a problem. 


THE PROTOTYPE SCHEDULE ADVISOR: THE ATC PROBLEM 


A prototype ATC Schedule Advisor has been developed, and will now be described. 
First, the ATC problem will be presented, followed by a discussion of the system 
design. 

A plan for new arrivals 

The terminal area under consideration, shown in Fig. 1, is based on the route 
structure in a 150 n. mi. radius of Denver, Colorado. The Denver route structure is 
a "four-corner-post" system with conventional jet aircraft arriving from either 
Drako from the northwest, Keann from the northeast, Kiowa from the southeast, and 
Byson from the southwest. A route for low-speed, general -aviation traffic which 
emanates from Colorado Springs is also considered. It is assumed that Instrument 
Flight Rules (IFR) prevail, and that all landings are at the Denver Stapleton 
Airport on runway 26L. The area under consideration contains the Denver Terminal 
Radar Approach Control (TRACON) and a portion of the Denver Air Route Traffic 
Control Center (ARTCC) . 

Conventional jet traffic enters the terminal area region at one of the feeder 
fixes of the four corner posts described, and general-aviation traffic enters from 
Colorado Springs. When the traffic enters the terminal area, a time assignment is 
generated for the aircraft to reach touchdown. The time assignment is based on the 


3 



range of feasible times for the aircraft to fly the route. The aircraft has a 
preferred nominal time, but can speed up or slow down within a specified range. 

There is an additional FAA requirement in which consecutive aircraft must be 
separated by a minimum distance; this distance is a function of the weight cate- 
gories of the aircraft. Three categories have been defined: light, large, and 

heavy. For the route system under consideration, light aircraft are restricted to 
the Colorado Springs route, while both large and heavy aircraft can fly on the four 
jet routes. These distance-separation requirements can be translated into minimum 
separation times for the purpose of time scheduling (1). Thus, scheduling new 
arrivals involves both determining the range of feasible times for the aircraft and 
checking that the proposed schedule does not conflict with previously scheduled 
aircraft. In the prototype design, the schedule of aircraft which have arrived 
earlier are considered fixed, and the plan for a new arrival is based on meeting 
separation constraints with respect to these schedules. It may be possible that no 
conflict-free time exists. In this case, the new arrival is scheduled for later 
departure and will hold at the route entry point (feeder fix) until its assigned 
time. 


A typical situation is shown in Fig. 2, which is a time-line representation of 
all the aircraft currently in the system at time 12:37:03. A separate line is drawn 
for each of the arrival routes previously discussed, and there is also a line for 
the missed-approach route, which will be discussed. On the Keann route, two air- 
craft are shown which have been scheduled; PA003, for which time at touchdown is 
12:46:10, and UA003, which directly follows it at 12:49:05. Suppose that at time 
12:37:03, WA374 reaches the feeder fix at Drako. The following times are computed 
by the planner: nominal time to touchdown is 12:52:38, with a range of 12:51:38 to 

12:54:38. Any time assignment outside this range would necessitate some holding at 
Drako. The planner first attempts to schedule WA374 at the nominal, then tries 
other times on either side of the nominal until the range limits are reached. In 
this example, the aircraft can be assigned at its nominal time, and no initial 
holding is necessary. Holding is permitted at some interior points in the region, 
but interior holding is not part of the initial schedule plan. 

Correcting minor schedule deviations 

After creating an initial schedule plan, the next function of the schedule 
advisor is to monitor each aircraft as it proceeds from feeder fix to touchdown, 
detect deviations from its assigned 4D route, and suggest corrective actions. It is 
important to note that, while advisories can perhaps be generated continuously in 
real-time operation, the number of corrective actions (i.e., clearances based on 
computer-generated advisories) must be kept small. There is still a substantial 
research problem to optimize the number of advisories, the type of advisories, and 
the times in which they should be given to the aircraft to minimize the deviation 
from scheduled touchdown time. One time of advisory, the speed advisory, has been 
mentioned earlier. In the prototype schedule advisor, the only advisories used are 
heading and path advisories, which will now be discussed. 


4 


When the aircraft departs the feeder fix, a planned touchdown time has been 
established. A 4D route is synthesized and used as the reference trajectory as the 
aircraft proceeds from feeder fix to touchdown. To correct for minor deviations 
from the 4D route, a decision point has been established on each of the routes. 
Figure 3 shows the decision point for the two northern routes. When the aircraft 
reaches the decision point D K on Keann, or D D on Drako, a path correction is 
generated so that the aircraft can meet its assigned time schedule. From Drako, the 
aircraft will be required to adjust its time to turn, while from Keann, a heading 
change will be required. Note that the advisory will include a warning if, even 
with the largest correction allowed, an error remains. In the prototype system, no 
attempt is made to resolve this type of problem. At present, it is necessary for 
the controller to call for a missed approach, or take some other action to resolve 
the problem. 

Schedule revisions 

So far, only minor deviations have been considered, and the strategy has been 
to generate corrections to return the aircraft to its assigned time so that the 
schedule plan for other aircraft need not be altered. However, the schedule advisor 
must consider the situation when major disruptions occur, i.e., when it is not 
possible to retain the existing plan. These changes may be necessitated by aircraft 
executing a missed approach or an emergency landing, or by weather-related modifica- 
tions such as rerouting to avoid severe weather, runway closure, or runway use 
changes caused by shifting winds. A revised plan must be generated which must 
handle the disruption in a continually safe manner, and which will return to an 
expeditious flow after an initial transient period. In the prototype system, two 
classes of major disruptions are considered: missed approaches and runway closures. 

If an aircraft is to execute a missed approach (Fig. 4), it proceeds along its 
route in level flight toward the touchdown point, then to the departure end of the 
runway, and then turns right heading toward point H D where it rejoins the Drako 
route for a second attempt at a flight to touchdown. A new touchdown time must be 
assigned for this aircraft, and it is preferred that the missed-approach aircraft be 
given priority to land at its earliest possible time. This may necessitate holding 
other aircraft at the feeder fixes or the internal holding points until a revised 
conflict-free touchdown time is available. 

A sample holding situation is illustrated in Fig. 5. Figure 5a shows a time- 
line plot at time 13:06:54. At this time, the controller decides that AA251 needs 
to execute a missed approach. The missed-approach command is entered into schedule 
advisor, and the revised time line shown in Fig. 5b is generated. The aircraft 
AA251 now appears on the missed-approach line, and has been rescheduled without 
holding. 

Elements of a plan for handling runway closure have been developed. Suppose 
that the controller declares that a runway is closed for the interval (tj_,tf), 
where t ^ is the time when the closure is first effective, and t f is the time 
when the runway is to be reopened. ^ The advisor first determines which flights are 
currently assigned in the blocked interval. These flights and any flights which 


5 



follow them are sequentially rescheduled. Any flight which has passed the last 
holding point will be told to execute a missed approach and proceed in for a new 
approach or for holding as required. 

A sample runway closure situation is shown in Fig. 6. Figure 6a shows a time 
line plot at 13:20:16. At this time the controller decides that no aircraft can 
land in the interval from now until 13:23. One aircraft, PA35, is scheduled to land 
in this interval. The revised plan is shown in Fig. 6b. No aircraft are scheduled 
in the blocked interval. The aircraft PA35 has executed a missed approach and is 
now rescheduled without holding. 


THE PROTOTYPE SCHEDULE ADVISOR: SOFTWARE DESIGN 


A prototype for the ATC schedule advisor has been programmed on a 
Symbolics 3600 Lisp machine. A fully commented program listing is given in the 
appendix; this discussion serves to highlight the key features of the software 
involved. The intention was to combine existing numerical subroutines, capable of 
4D planning single flights, with artificial intelligence (AI) planning techniques to 
produce an intelligent 4D scheduler for a system of flights. In addition, this 
scheduler will serve as a research tool, with the ability to add new features as 
they are developed. 

Problem representation 

A generalized representation of the problem is to treat the terminal area as a 
directed graph. A sample graph is given in Fig. 7. Each node on the graph repre- 
sents some physical point such as touchdown or a feeder fix. These nodes are 
labeled "a" through "k" in the figure. Each directed arc represents a transition in 
terms of the time required for a flight to move between the two connected nodes. 

For example, between the feeder fix "j" and the waypoint "f," a flight may have the 
option to wait at the holding point labeled "b." 

Various information is maintained for each arc, such as the distance to the 
runway, alternate paths, and procedures that must be executed whenever a flight 
enters or exits the arc. For example, if a given arc represents the travel between 
a decision point and the runway, the arc's entry procedure would then include a code 
to generate a path correction. 

Two ordered lists are also maintained for each arc which denote, respectively, 
the flights that are scheduled to enter and exit the arc. In Fig. 7, the flight 
PA35 is scheduled to enter at 13:02:23 and then exit at 13:11:45. Upon exiting, 

PA35 should be flying at an altitude of 36,000 ft and a calibrated airspeed of 


^The case when the runway is closed indefinitely is more complex and is not 
considered in the prototype system. 


6 


182 knots. Likewise, the flight AA24 has already entered the arc at 12:50:33 and is 
scheduled to exit at 12:59:57. 

This information shows the planned state of the arc at any given time, and can 
be used to help reschedule flights and to detect potential conflicts. Also, the 
system can use the list of entering flights at the touchdown arc to determine possi- 
ble "time slots" .where aircraft can be allowed to land. Given this representation, 
the problem is to develop a planner which finds good time-based paths through the 
graph for flights that need to be scheduled, and to develop a control structure 
which operates on the graph as events occur (i.e., flights enter and exit arcs, 
plans are revised, etc.). 

Planning functions 

The first planning goal is to always have a consistent plan for the overall 
system. Each flight in the system must always have a scheduled path from its cur- 
rent position to touchdown. This path consists of a list of scheduled waypoint 
arrival times which cannot conflict with blocked-runway time intervals or separation 
requirements for other flights. If situations arise in which the system cannot 
adequately plan for all of the arriving flights, some of the air traffic will then 
be placed in holding patterns. For example, if the runway is blocked and a number 
of flights arrive at the feeder fixes, then some of the flights may have to hold 
until conflict-free touchdown times can be scheduled. 

Next, consider what kind of information the planner must understand and main- 
tain for each flight. This is determined by the numerical routines for 4D path 
generation and control which lie at the heart of the planner. Input parameters to 
these routines consist of current time, altitude, calibrated airspeed, distance to 
touchdown, and speed profile. Output parameters from these routines consist of a 
list of the computed altitude, airspeed, and distance for the flight at various time 
steps to touchdown, and the controller advisories required to execute the plan. 

The planner must determine a good strategy for a given flight, feed the correct 
parameters to the numerical routines, and check the resulting plan for any conflicts 
with flights that are already scheduled in the system. The strategy determines 
whether a flight should hold at the feeder fix, or use a faster or slower speed pro- 
file, etc., and hence determines the parameters to the numerical routines. Plan 
segments that could be added to arcs on the graph are interpolated from the time 
steps of the computed flight parameters. Then the planner checks for separation 
conflicts, blocked-runway conflicts, etc., to test the candidate plan along its path 
through the graph. This plan is returned if valid; otherwise, the planner back- 
tracks to attempt some alternate strategy. 

The planner therefore uses a "generate and test" structure, backtracking when- 
ever some conflict is found. Logic programming is used to encode the planner since 
backtracking is an inherent feature. Flight strategies can also be represented 
symbolically and reasoned about conveniently. Heuristics can be added to guide the 
backtracking. As more engineering knowledge is applied to the ATC problem, more 


7 



expertise will be encoded into these heuristics to make the path-generation process 
more efficient. 

System architecture 

The schedule advisor runs in the Symbolics Zetalisp environment using software 
programmed in MRS, Lisp, and Fortran. The Lisp functions call a Fortran program to 
run when the numerical subroutines are needed, and parameters are communicated 
through input and output data files. The numerical subroutines for 4D path genera- 
tion and control consist of nearly 3000 lines of a Fortran 77 code originally devel- 
oped under VAX VMS (3). This code performs a Runge-Kutta integration to determine 
optimal descent paths. The Symbolics software provides a Fortran 77 development 
environment and only a few minor changes were needed to port these routines. For 
instance, the Symbolics Fortran had a shorter line length, and exclamation points 
could not be used for in-line comments. 

Combining Lisp and Fortran code into the same software system produces some 
challenges. Fortran requires a main program to run before any subroutines can be 
called, which restricts the use of Fortran subroutines within Lisp programs. To 
avoid this, the software can be run as a Fortran main program with Lisp functions 
called as subroutines. Fortunately, data types such as characters, integers, and 
reals tend to be machine- independent; hence, parameter passing does not require any 
coercion. Another option chosen for this system is to run Fortran routines as sep- 
arate programs, or even separate processes, and have Lisp and Fortran communicate 
through data files or input/output buffers. 

One interesting point is that Symbolics Fortran uses Lisp as the intermediate 
code during compilation, and that it retains the user-defined Fortran variable names 
for the corresponding Lisp symbols in the intermediate code. This is unfortunate 
since Fortran programmers tend to use the real variable "T" to denote time values, 
but the name "T" in Lisp denotes a system-wide symbol for truth. For this system, 
it was sufficient to rename all Fortran "T" variables as "T1." 

Most of the general programming has been Jone in the Symbolics Lisp language 
called Zetalisp, which is very close to Common Lisp. This has proven to be a very 
powerful and well-designed programming language. One major feature is that Zetalisp 
has a good set of software tools available for writing and debugging code, such as 
the ZMACS screen editor. 

Zetalisp also provides several useful packages, such as TV for windows and 
graphics, and Flavors for object-oriented programming. The user interface, pro- 
grammed using the TV package, consists of three windows and various menus as shown 
in Fig. 8. A "Time Routes" window shows a graphic depiction of the time-scheduled 
flights in the terminal area. An "Advisories" window displays advisories and expec- 
tations about the descending flights. A "Listener" window gives the user access 
into the system by providing a command prompt and a mouse with sensitive pop-up 
menus . 


8 


Objects, defined with the Flavors package, are useful for representing data 
structures and for representing knowledge about the system which changes frequently 
or involves "inheritance." For example, an object is created for each flight that 
enters the system. Various slots are defined for each flight object, such as 
"touchdown time," or "neighboring flights." Inheritance is useful in defining 
classes of objects. For instance, a general class of objects called PLANE could 
have attributes such as "scheduled touchdown time" "neighboring flights," which all 
aircraft must have values for. Another type of objects could be defined for HEAVY- 
AIRCRAFT. As a subclass of PLANE, these would inherit all the properties of PLANE 
objects, and possibly add other more specific attributes, such as "separation 
requirements for heavy aircraft." 

Other forms of knowledge about the system are represented in MRS, which pro- 
vides logic programming similar to the Prolog language. MRS, which stands for Meta- 
level Reasoning System, was developed by Genesereth (6). Logic programming is 
generally more straightforward than algorithmic methods, so long as the problem can 
be formulated efficiently in predicate logic. Essentially, the steps are to 
1) encode the specifications for a given problem solution, 2) assert the relevant 
facts into the knowledge base, and 3) query a theorem prover to determine some 
specific solution. One advantage of formulating ATC planning in logic programming 
is that the rules can be easily modified and amended as the expertise involved in 
air traffic control becomes better understood. Another advantage is that the 
resulting facts and rules can be viewed as the specifications for an optimized 
version of the system. 

MRS has features for solving problems with backward chaining, forward chaining, 
condition-action rules, and more. In addition, MRS automatically backtracks to 
search for solutions, and meta-level rules can be defined to order this backtracking 
(i.e., to incorporate heuristic searches). The planning functions required in this 
system rely on heuristic techniques since a real-time advisor cannot afford to spend 
very much time generating alternative 4D paths. 

Facts which do not change over time, such as "Flight XX007 executed a missed 
approach at time 11:30:45," or "Waypoint WP3 is a feeder fix for the KIOWA route," 
are stored in the MRS knowledge base, along with the various rules. To handle a new 
arriving flight, the rules determine a good, feasible flight plan in the following 
order: 

1 . Use heuristics to develop a possible strategy 

2. Call numeric subroutines to compute a plan from this strategy 

3. Check constraint rules to test the plan for violations, blocks 


^An earlier version of the schedule advisor by B. Boesch, D. Gregory, J. L. 
Scoggins, and L. Tobias was implemented entirely in MRS as a class project in 
Building Expert Systems at Stanford University. 


9 



Failure to satisfy the constraint rules at any point will invoke backtracking to 
search for an alternative plan. 

Program operation 

Assume that the schedule advisor software runs on a personal workstation net- 
worked to host computers for real-time data access. Actual operation of the system 
basically differs from simulation by the source of the data. Using the Symbolics 
interface facilities, which provide multiple graphics windows and user interaction 
menus, the user can create new arrivals, block runways, alter the data structures 
and knowledge base, execute scenario data files, and step or reset the system clock. 

The main program executes a loop to 

1 . Look for and process input data 

2. Update the system clock 

3. Check the graph for events that should have occurred by the new current 
clock time and execute them 

At any time, the user can activate a mouse button to interrupt the main loop 
and request a command menu. Most of the commands are used for data input, such as 
creating new arrivals, signaling a missed approach, or blocking the runway for some 
time period. Some other commands provide system controls, such as regulating the 
Lisp machine's memory garbage collection, or resetting the system clock. 

To create a new arrival, for instance, the user selects the "New Arrival" menu 
option. A special menu then prompts for the flight identification number, type of 
aircraft, arrival feeder fix, estimated arrival time at the feeder fix, etc. A new 
object is created to represent this flight, and the planning begins. The resulting 
advisories are displayed, and the aircraft symbol is plotted on the time line. 


CONCLUDING REMARKS 


A prototype schedule advisor formulated as an expert system has been developed 
to assist the air traffic controller in the time scheduling of traffic in the 
extended terminal area. The advisor develops a time plan for all new arrivals into 
the terminal area, which takes into account the aircraft performance requirements 
and the schedules of other aircraft which have already entered into the terminal 
area. The advisor monitors aircraft flight progress through the terminal area and 
generates advisories (candidate ATC clearances) to the controller to correct devia- 
tions from the time plan. Some initial procedures for revising the plan to accommo- 
date missed approaches and blocked runways have been included. 

Future research will be focused on refining the advisor, i.e., applying knowl- 
edge of engineering techniques to develop better planning heuristics. The rules 


10 



developed so far basically demonstrate what types of reasoning can be done, without 
attempting to be detailed, or to be very precise. This knowledge engineering would 
depend on a better understanding of the problem domain through: 

1 . ATC expertise 

2. NASA research through simulation, field testing, etc. 

3. Encoded domain policies and conventions, e.g., FAA regulations 

Among the general issues that need to be addressed in refining the schedule 
advisor are flight-path optimization, procedures to minimize time deviations at key 
schedule points, and strategies to improve airport capacity. For example, when 
planning new arrivals, one question to address would be whether to hold a flight for 
some time and have it follow a fast speed profile, or to have it just follow a slow 
speed profile without holding. Another question would be to switch the landing 
order of scheduled flights as new flights arrive. 

As far as the system architecture is concerned, the next step would be to 
distribute the advisor. For example, it would be good to have both the numerical 
subroutines and the graphic display windows run as spearate processes. This could 
alleviate some of the problems found in combining various programming languages in 
the same run-time environment. 

The overall system should be represented in terms of standard data structures, 
such as directed graph, priority queues, etc. The logic programming would then be 
used exclusively for the planner; that is, to generate and test strategies and 
represent search heuristics. 


11 



References 


(1) Tobias, L., Erzberger, H., Lee, H.Q. and O'Brien, P.J.: "Mixing Four- 

Dimensional Equipped and Unequipped Aircraft in the Terminal Area," AIAA 
Journal of Guidance. Control and Dynamics , Vol. 8, No. 3, p. 296: May-June 

1985. 

(2) Lee, H.Q. and Erzberger, H.: "Time-Controlled Descent Guidance Algorithm for 

Simulation of Advanced ATC Systems," NASA TM-84373, 1983. 

(3) Erzberger, H. and Chapel, J.D.: "Ground Based Concept for Time Control of 

Aircraft Entering the Terminal Area," Proceedings AIAA Guidance and Control 
Conference , Snowmass, CO, Aug. 1985. 

(4) Cross, S.E.: "Model-Based Reasoning in Expert Systems: An Application to 

Enroute Air Traffic Control," Proceedings AIAA/IEEE Sixth Digital Avionics 
Systems Conference , Baltimore, MD, Dec. 1984. 

(5) Prerau, D.S.: "Selection of an Appropriate Domain," AI Magazine, Vol. 7, 

No. 2, p. 18: Summer 1985. 

(6) Genesereth, M.R. and Ginsberg, M.L., "Logic Programming," Communications of the 

ACM , Vol. 28, No. 9, p. 933: Sept. 1985. 


12 



APPENDIX 
PROGRAM LISTING 


13 



CHA:>Scogg1ns>newaveo>atc.1 1sp.8 


12/13/85 11:32:18 


Mode: LISP; Package: MRS; Syntax: Zetallsp; Base: 10 
NB: Change this first line and all life as you know It will cease to exist... 


John Scoggins 
NASA/Ames Research Center 
M/S 210-9 

Moffett Field, CA 94035 
(415) 694-5431 

Overview 

This file contains the top level definitions and system calls to start the 
ATC Scheduler expert system. Simply use the command: 

Load File CHA:>Scogg1ns>newaveo>atc 

This file will then: 

• Add the ATC system as a select option on the lisp machine 

• Define the ATC system In terms of file dependencies 

• Compile and load the ATC system 

• Run the command loop to start the system 


; Define the system In terms of the required files and which 
; comp Hers they use 

(def system ATC-Scheduler 

(:name "NASA Air Traffic Control Scheduler") ;System names and defaults 
(: short-name "ATC Scheduler") 

( :pathname-default "CHA:>Scogg1ns>newaveo>" ) 

(: package MRS) 

(:module fonts ( "atcfont" )) ;Module names and files 

(:modu1e pathgen ("pathgen")) 

(:module objects ("user" "graph")) 

(: module planner ("planner")) 

(:load-bfd fonts) ;Comp11er dependencies 

( :fortran-comp11e-load pathgen) 

( :comp11e-load objects) 

(:readf11e planner) 

) 


; Compile and load the system 

(make-system 'ATC-Scheduler 
:comp11e 
:noconf1rm 
) 


; Call the command loop for FRAME to run the system 

(send FRAME : command- loop) 

(Comment (process-run-functlon 
"ATC Scheduler" 

'(lambda () 

(send FRAME : command- loop) 

) 

) 

) 


14 



CHA:>Scogg1ns>newaveo>p1anner. 1 1sp.40 


1/16/86 21:27:53 


Mode: LISP; Package: MRS; Syntax: Zetallsp; Base: 10 
NB: Change this first line and all life as you know It will cease to exist... 


John Scoggins 
NASA/Ames Research Center 
M/S 210-9 

Moffett Field, CA 94035 
(415) 694-5431 

Overview \ 

This file contains the MRS rules and facts required for the planning 
functions In the ATC Scheduler expert system. 

This file will: 

• Create and clear Its own MRS theory called ATC 

• Set up the meta level definitions for the knowledge base 

• Stash the rules, facts and demons Into the knowledge base 

• Define the planning functions and Interface to the FORTRAN code 



15 


CHA:>Scogg1ns>newaveo>pl anner . 1 1$p.40 


1/16/86 21:27:53 



Meta Level Definitions 


These rules, facts and functions make up the systems level Incantations 
needed to support demons, backward chaining, rule ordering, and 
procedural attachment Into lisp and the object base. Logicians use 
the term "meta" to describe propositions about an inference process. 
Basically, we use the meta level to short-circuit MRS, for example 
when we need to access the object base. 

Contrary to what the manual may say... we have Included any "wisdom" 
about the MRS system that we had to learn the hard v/ay, 1e. there 
are bugs and contradictions to the documentation. 

The propositions DONE and CUT will only work at the meta level 
and not at the base level. EVAL has been added to take the place 
of DONE at the base level. 

The difference between ELEMENT and MEMBER Is that only the latter 
will bind Its first argument to a list of variables. 

RESIDUE will not support generate and test strategies since it 
tries to find all solutions Instead of backtracking when necessary. 


(setq theory 'GLOBAL) 

(unstash '(toassert (and . A1 ) assert-and)) 
(stash '(toassert &p fc)) 

(stash '(toassert (and . A1 ) assert-and)) 

(setq theory 'ATC) 

(empty theory) 

; (load "CHA: >mrs>set" ) 

(stash '(tolookup (EVAL Afunct . Aargs) 
fq-lookup)) 

(stash '(tolookups (EVAL Afunct . Aargs) 
fq-lookups)) 

(stash '(lisp EVAL EVAL)) 


; repair meta level to forward chain 
;w1 th more than one conclusion - this 
; enables explanations for the demons 


jdeflne a theory and clear it each time 
;we reload the file - also load any 
; necessary MRS packages, like SET 

;procedural attachment to call 
; LISP and FORTRAN routines from 
;MRS 


; Short cuts to call the most commonly need LISP functions without using EVAL - see 
;the Complete Guide to MRS" under procedural attachment 

(stash '(tolookup (FORMAT . Aargs) lisp-lookup)) 

(stash '(tolookups (FORMAT . Aargs) lisp-lookups)) 

(stash '(tolookup (GETBDG . Aargs) lisp-lookup)) 

(stash '(tolookups (GETBDG . Aargs) lisp-lookups)) 


(stash '(tolookup (SEND . Aargs) lisp-lookup)) 
(stash '(tolookups (SEND . Aargs) 1 Isp- lookups ) ) 

(stash '(tolookup (SETQ . Aargs) lisp-lookup)) 
(stash '(tolookups (SETQ . Aargs) lisp-lookups)) 


(Defun LISP-LOOKUP 
(P) 

(let ((vals (get-term p))) 
(unlfyp 
(eval 

(car vals)) 

(cadr vals))) 

) 


(Defun LISP-LOOKUPS 
(P) 

(let ((vals (get-term p))) 
(plural Ize 


;MRS has FQ-LOOKUPS defined to do this 

;k1nd of procedural attachment, but it 
; really only works for the numerical 
functions. LISP-LOOKUP(S) replaces the 
; the EVAL proposition defined In RULES. LISP 
;Th1s Is called a "computable representation" 
;see the file CHA: >MRS>efrepn. 1 Isp 


;MRS requires a plural Ized form for each 
;computable representation 

16 


CHA:>Scogg1ns>ne«raveo>planner.Hsp.40 


1/16/86 21:27:58 


(unlfyp 

(eval 

(car vals)) 
(cadr vals)))) 

) 


(Defun LEQP ;MRS defines these comparison operators 

(&rest args) ;for two operands only... this patch allows 

;us to use queries like: 

(apply X* args) ; (-T&UEP *(<* 2 3 4)) 

) 


(Defun GEQP 

(&rest args) 

(apply •>* args) 

) 



CHA:>Scogg1ns>newaveo>planner.Hsp.40 


1/16/88 21:27:53 


Utility Rules and Definitions 

These misfit propositions have nothing to do with either the meta level 
or the domain knowledge base. They just make life easier when using MRS. 


(stash ’(append nil $lst Slst)) ;Append two list to return a third 

;11st a3 the result - this Is an 

(stash ’(append Slst nil Slst)) jexcellent example of logic programming 

;for any Prologer who wants to learn MRS 

(stash ’(If (append Scdr Slst Sans) 

(append (Scar . Scdr) Slst (Scar . Sans)) 

)) 


18 



CHA:>Scogg1ns>newaveo>p1anner.l1sp.40 


1/16/86 21:27:58 


Planning Functions 


(Defun PLAN -NEW- ARRIVAL 

(flight class route time alt cas) 

9 

instantiate flight with Its parms 
(set flight 

(make-instance 'FLIGHT 

: label (get-pname flight) 

:class class 
: current-route route 

i 

;Query to find and Install plan segments 

(let* ((approach (eval (Implode (append *(A P P -) (explode route))))) 

(Inlt-seg (list (eval flight) approach time time (send approach :d1st-to-td) alt cas)) 
(query (truep '(planned , Inlt-seg Ssegs Sadvs))) 

) 

(send (eval flight) :1nsta11-plan (getvar 'Ssegs query) (getvar 'Sadvs query)) 

) 

) 


(Defun PLAN -MISSED- APPROACH 
(flight) 

» 

; Find the flight's segment on TD-ARC and move it to HISSED 
(let* ((td-seg (send flight :ed1t-plan-at TD-ARC)) 

(mlss-seg (list flight MISSED (nth 2 td-seg) (nth 3 td-seg) 0.0 36000.0 180.0?) 

) 

(send TD-ARC :del-fl1ght td-seg) 

(send flight :1nsta11-plan 
(list mlss-seg) 

(list (format nil "Flight ~A executes a missed approach at ~\t1me\" 

(send flight : label) (nth 2 mlss-seg))) 

) 

9 

;Query to find and Install revised plan segments 
(let* ((query (truep '(planned , mlss-seg Ssegs Sadvs))) 

) 

(send flight :1nstall-plan (getvar 'Ssegs query) (getvar 'Sadvs query)) 

) 

) 


(Defun PUN-BLOCKED-RUNWAY 
(flight) 

! 

; Remove flight plan segments past current arc 
(let* ((oldies (reverse (send flight :segments))) 

(Inlt-cur (send flight :ed1t-plan-at (send flight :current-arc))) 

(cur-segs (send flight : segments)) 

(Inlt-old (list flight MISSED (nth 2 (car oldies)) (nth 2 (car oldies)) 0.0 36000.0 180.0)) 
(old-segs (reverse (cons Inlt-old (cdr oldies)))) 

) 

9 

; Remove all trace of the flight until It Is replanned 
(send flight :set-segments oldies) 

(send flight :remove-self ) 

(send flight rdescrlbe) — 

(send TERMINAL-GRAPH :add-fl1ght flight) 

(send flight : set-segments nil) 

S 

;Query to find and Install revised plan segments 

(let* ((query (truep '(block-replanned , Inlt-cur , cur-segs ,1n1t-old , old-segs Ssegs Sadvs))) 

) 

(send flight :1nsta11-p1an (getvar 'Ssegs query) (getvar 'Sadvs query)) 

) 

) 


) 


19 



CHA:>Scoggins>newaveo>planner . 1 1sp.40 


1/16/86 21:27:53 


Planning Facts and Rules for Path Generation 


(stash '(If (and (planned Slnlt-old Jsegsl Sadvsl) 

(append Sold-segs Ssegsl Ssegs) 

(append Sadvsl ("Hissed approach forced by blocked runway") Sadvs) 

) 

(block-replanned $1n1t-cur Scur-segs $1n1t-old Sold-segs Ssegs Sadvs) 

)) 


(stash '(If (and (planned Slnlt-cur Ssegsl Sadvsl) 

(append Scur-segs Ssegsl Ssegs) 

(append Sadvsl ("Rescheduled due to blocked runway") Sadvs) 

) 

(block-replanned Slnlt-cur Scur-segs Slnlt-old Sold-segs Ssegs Sadvs) 

)) 


(stash '(If (and (« Slnlt-seg (Sflt Sarc Sentry Sexlt Sdls Salt Seas)) 
(gen-path Sarc (Sarc . Spath)) 

(gen-segs Slnlt-seg Spath Ssegs Sadvs) 

( no-block-conflicts Ssegs) 

) 

(planned Slnlt-seg Ssegs Sadvs) 

)) 


(stash *(1f (and (send Sarc :next-arcs Snext-arcs) 
(member Snext Snext-arcs) 
(gen-path Snext Sresult-path) 

) 

(gen-path Sarc (Sarc . Sresult-path)) 

)) 


(stash '(gen-path ,TD-ARC (.TD-ARC)) 

) 


(stash '(If (and (= Slnlt-seg (Sflt Sarc Sentry Sexlt Sdls Salt Seas)) 
(strategy Sproflle) 

(eval (PATH-GEN 'Sproflle 'Sflt 'Spath 'Sexlt 'Salt 'Seas) 
(Ssegs Sadvs)) 

(no-fllght-confllcts Ssegs) 

) 

(gen-segs Slnlt-seg Spath Ssegs Sadvs) 

)) 


(stash * ( 1 f (and (send Shold-arc :1sa-hold-pt t) 

(gen-hold Sinlt-seg Shold-arc Shold-seg Shold-adv) 

(no-fl Ight-confl lets (Shold-seg)) 

(gen-segs Shold-seg Spath Ssegs Sadvs) 

) 

(gen-segs Slnlt-seg (Shold-arc . Spath) (Shold-seg . Ssegs) (Shold-ad\T": Sadvs)) 

)) 


(stash '(If (and (» Slnlt-seg (Sflt Sarc Sentry Sexlt Sdls Salt Seas)) 

(send Sflt :label Sflt-label) 

(send Shold-arc : label Sarc-label) 

(member Shold (30 60 120 240 480 10000)) 

(+ Sexlt Shold Shold-exlt) 

(format nil 

"Flight ~A holds for ~0S sec at ~0S ft over the ~A" 
’Sflt-label ’Shold 'Salt ’Sarc-label 
Shold-adv 
) 

(* Shold-seg (Sflt Shold-arc Sexlt Shold-exlt Sdls Salt Seas)) 

) 

(gen-hold Slnlt-seg Shold-arc Shold-seg Shold-adv) 

20 


CHA:>Scogg1n$>newaveo>planner . 1 Isp. 40 


1/16/86 21:27:58 


)) 


(stash '(If (unprovable 

(and (member Sthls-seg Ssegs) 

(= (Sflt Sarc Sentry Sexlt Sdls Salt Seas) Sthls-seg) 
(send Sarc rwlll-confllct ’Sthls-seg (Sfront Sback)) 
(+ Sfront Sback Sconfllct) 

(> Sconfllct 0) 

)) 

(no-fllght-conflicts Ssegs) 

)) 


(stash '(If (unprovable 

(and (member (Sflt , TO- ARC Sentry Sexlt Sdls Salt Seas) Ssegs) 
(blocked-runway Stl St2) 

(< Stl Sentry St2) 

)) 

(no-block-conflicts Ssegs) 

)) 


(stash '(strategy FAST) ;unt11 FORTRAN Is debugged.,, 

) 


21 



CHA:>Scoggins>newaveo>p Tanner. 1 1sp.40 


1/18/86 21:27:58 


Interface to Numerical Subroutines for Path Generation 


(Defun PATH-GEN 

(type flight path time altd spd) 

(list 

(loop with prev-tlme » 0.0 

for (arc enter dls alt cas) 

In (reverse ( PATH-GEN- AUX type (reverse path) time altd spd)) 
for exit first enter then prev-tlme 

collect (list flight arc enter exit dls alt cas) Into segs 
do (setq prev-tlme enter) 
finally (return segs) 

) 

(cons 

(format nil "Flight ~A:" (send flight :label)) 

(wlth-open-flle 

(advs "CHA:>Scogg1ns>adv1sor1es.data" *:d1rect1on *: Input) 

(loop while (send advs : listen) 
collect (read line advs) 

) 

) 

) 

) 

) 


(Defun PATH-GEN-AUX 

(type path time altd spd) • 

9 

; Find the distances for each arc In the given path 
(setq path 

(loop for arc In (reverse path) 

collect (cons arc (send arc :d1st-to-td)) 

) 

) 

9 

; Write the Initial flight parameters to the file "flt-parms.data" 

(wlth-open-flle 

(parms M CHA: >Scogg1ns>f 1 t-parms. data* rdlrectlon routput) 

(format parms 

"~A ~S ~S ~$ ~S~V 

(selectq type ;map the speed profile parameter value 

(FAST 1) (NOMINAL 2) (SLOW 3)) 

(float time) 

(cdar path) 

(max altd 4650. 0) ; error check the alt parameter 

(max spd 154.0) ; error check the cas parameter 

) 

) 

» 

(f77: execute PathGen 

: Inlt-to-zero t ; Initialize FORTRAN variables to zero 

rpathname-default "CHA:>Scogg1ns>" ;Def1ne logical units for files 

runlts ((2 "cmdtab.data" ) 

(9 "eprdata3.data") 

(18 "flt-parms.data") 

(19 "flt-segs.data") 

(20 "advisories. data") 

) 

) 

(let* 

((tlm (make-array *(100))) 

(dls (make-array *(100))) 

(alt (make-array *(100))) 

(cas (make-array '(100))) 

(nsegs 0) 

(coords nil) 

) 


22 


CHA:>Scogg1ns>newaveo>planner . 1 1sp.4Q 


1/16/86 21:27:58 


(wlth-open-flle 

(segs "CHA:>Scogg1ns>flt-segs.data" :d1rect1on :1nput) 
(loop for 1 from 0 below 100 

while (send segs : listen) 
do (aset (read-for-top- level segs) tlm 1) 
do (aset (read-for-top- level segs) dls 1) 
do (aset (read-for-top- level * ' m 

do (aset (read-for-top- level — 

finally (setq nsegs (If (< (aref dls ( 

(- 1 2 ) 

(- 1 

)) 

) 

) 


segs) alt 1 ) 
segs) cas 1) 

1 2 )) 0 . 0 ) 

1 ) 


» 

(aset (t (aref tlm (1- nsegs)) 

(// (* (aref dls (1- nsegs)) 
3600.0) 

(aref cas (1- nsegs)) 

)) 

tlm 

nsegs) 


) 


• 

(aset 0.0 dls nsegs) 

(aset 0.0 alt nsegs) 

(aset (aref cas (1- nsegs)) cas nsegs) 

(catch * PROF-EX IT 
(loop for J from 0 below nsegs 
as dl « (aref dls J) 
as d2 « (aref dls (It j)) 
do (loop for (arc . d) In path 
while (>« dl d d2) 
do (push 

(list arc 

(t time ;t1me 

(pt-slope d 

dl (fix (aref tlm J)) 

^ d2 (fix (aref tlm (It j)))) 

d ; distance 

(pt-slope d ;a1t1tude 

dl (aref alt j) 
d2 (aref alt (It j)) 

) 

(pt-slope d ; speed 

dl (aref cas J) 
d2 (aref cas (It j)) 

) 

) 

coords) 
do (pop path) 

when (null path) do (throw 'PROF-EXIT (reverse coords)) 

) 


) 


(Defun PT-SLOPE ;use the point-slope formula to 

(x xl yl x2 y2) ; linearly Interpolate between two points 

(cond ((zerop (- x2 xl)) 

'Undefined 

) 

( (f loatp yl) 

(♦ yl 

(* (- x xl) 

(// (- y2 yi) 

<- x2 xl)))) 

) 

(t 

(♦ yi 

(fix (* (- X xl) 

(// (float (- y2 yl)) 

(- x2 xl))))) 


23 



CHA:>Scogg1ns>newaveo>planner . lisp. 40 


1/16/88 21:27:68 


) 

) 


24 



CHA:>Scoggins>newaveo>p Tanner. T 1sp.40 


1/16/86 21:27:53 


Planning Facts and Rules for Path Correction 


For now, we just use a uniformly distributed random variable to simulate the 
amount of path error. 

This should even be smarter, 1e. If a flight Is too early, but there Is no 
runway block or time separation conflict In front of Its scheduled touchdown, 
then why bother with path stretching? 


; CORRECTION determines how a flight should maneuver to correct, based on the 
;calculated time descrepancy. 

(stash '(If (and (- Stdly Sdelta Serror) 

(format nil 

"Flight ~A executes ~A ~2S late to correct for time error-XWARNING Flight ~A Is -0$ s 
ec early even with corrections" 

’Slabel 'Sman 'Sddly ’Slabel terror Smsg) 

) 

(correction Slabel St Sman Sdelta Sdadv Stadv Sddly Stdly Smsg) 

)) 


(stash "(If (and (<= Stdly Sdelta) 

(* Sdelta Sddly Stemp) 

(// Stemp Stdly Scorrect) 

(format nil 

"Flight ~A executes -A ~2S late to correct for time error" 
'Slabel 'Sman 'Scorrect Smsg) 

) 

(correction Slabel St Sman Sdelta Sdadv Stadv Sddly Stdly Smsg) 

)) 


(stash '(If (and (<=» -5.0 Sdelta) 

(format nil 

"Flight ~A requires no path correction" 

'Slabel Smsg) 

) 

(correction Slabel St Sman Sdelta Sdadv Stadv Sddly Stdly Smsg) 

)) 


(stash '(if (and (< 5.0 Sdelta) 

(* Sdelta Sdadv Stemp) 

(// Stemp Stadv Scorrect) 

(format nil 

"Flight ~A executes -A ~2S early to correct for time error" 
'Slabel 'Sman 'Scorrect Smsg) 

) 

(correction Slabel St Sman Sdelta Sdadv Stadv Sddly Stdly Smsg) 

)) 


(stash '(if (and (< Stadv Sdelta) 

{- Sdelta Stadv Serror) 

(format nil 

"Flight -A executes -A ~2S early to correct for time error~%WARNING Flight -A is -OS 
sec late even with corrections" 

'Slabel 'Sman 'Sdadv 'Slabel 'Serror Smsg) 

) 

(correction Slabel St Sman Sdelta Sdadv Stadv Sddly Stdly Smsg) 

)) 


25 


CHA:>Scogg1n$>newaveo>graph . 1 isp .31 


1/16/86 18:42:39 


-*- Mode: LISP; Package: MRS; Syntax: Zetallsp; 8ase: 10 

NB: Change this first line and all life as you know It will cease to exist... 


John Scoggins 
NASA/Ames Research Center 
M/S 210-9 

Moffett Field, CA 94035 
(415) 694-5431 

Overview 


This file defines the flavors and methods used In the ... 



(Declare 

(special 

;Here*s a list of all the names for Instantiated objects which will be 
; referred to by these flavors and methods, 1e. the “forward references". 

FRAME 
TO- ARC 

TERMINAL-GRAPH 

) 

) 


26 



CHA:>Scogg1ns>newaveo>graph . 1 1sp.31 


1/16/86 18:42:39 


I I » I I > I I I » I t M » > > > > I > I M I » > > II I I I I > > I I » M I M > M I I > » > It I I > I > f > M I II I » ! ! I ! ! ) I ) ! 

FLIGHT Flavor Definition and Methods 


Here's what a flight segment Is supposed to look like: 
(FLIGHT ARC ENTER-TIME EXIT-TIME DIS ALT CAS) 

IIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIMI 


(Def Flavor FLIGHT 

;This is the generic flight flavor to represent aircraft In the 

; system. 

((class nil) 

(current-arc nil) 

(current-route nil) 

(advisories nil ) 

(segments nil ) 

(label nil) 

(icon #/a) 

) 

» 

o 

» 

:gettable-1nstance-var1abl 
isettable-lnstance-varlabl 
: Ini table-lnstance-varlabl 
) 


(DefMethod (FLIGHT jafter :1n1t) 

(Ignore) 

;Th1s demon adds every newly Instantiated flight to the TERMINAL-GRAPH'S 
; list of flights. 

I 

(setq Icon (if (eq class ’small) #/b #/a)) 

(send TERMINAL-GRAPH :add-f light self) 

) 


(DefMethod (FLIGHT : Instal 1 -plan) 

(new-segs new-advs) 

(setq advisories (append advisories new-advs)) 

(If new-advs (send FRAME :pr1nt-adv1sor1es new-advs)) 
(setq segments (sort (append segments new-segs) 
’(lambda (segl seg2) 

(< (nth 2 segl) (nth 2 seg2)) 

)) 

) 

(loop for seg In new-segs 

do (send (nth 1 seg) :add-fl1ght seg) 

) 

) 


(DefMethod (FLIGHT :ed1 t-plan-at) 

(last-arc) 

5 

(loop for seg In segments 

while (neq last-arc (nth 1 seg)) collect seg Into good-segs 
finally (setq segments good-segs) 
finally (return seg) 


(DefMethod (FLIGHT :t1me-sep) 

(other-flight) 

i 

(cadr (assoc (cons class (send other-flight :class)) 

'(((HEAVY . HEAVY) 94) ((HEAVY . LARGE) 74) ((HEAVY . SMALL) 74) 
((LARGE . HEAVY) 114) ((LARGE . LARGE) 74) ((LARGE . SMALL) 74) 
((SMALL . HEAVY) 167) ((SMALL . LARGE) 38) ((SMALL . SMALL) 98)) 

27 


;aircraft size class 
; current position 
; current route 
;adv1sor1es list 
;plan segment list 
sprinted label string 
; graphics character 


es ; these flags mean that any of the 
es {flavor's slot can be Initialized, 
es {accessed or reset 



CHA:>Scogg1ns>newaveo>graph. 1 1sp.31 


1/16/86 18:42:39 


) 


)) 


(DefMethod (FLIGHT : report-pi an) 

() 

5 

(loop for (flight arc enter exit dls alt cas) In (reverse segments) 

Initially (format t "~%F11ght ~A Is scheduled as follows:-'*" label) 
do (format t ■-'%-'\t1me\ -A" enter (send arc :labe1)) 

) 

) 


(DefMethod (FLIGHT :remove-se1f ) 

() 

(loop for seg in segments 
for arc » (nth 1 seg) 
do (send arc sdel-fllght seg) 

) 

(send TERMINAL-GRAPH sdel-fllght self) 

) 


28 



CHA:>Scogg1ns>newaveo>graph. 1 i$p.31 


1/16/86 18:42:39 


ARC Flavor Definition and Methods 


(Def Flavor ARC 

;This is the generic arc flavor to represent an arc between 
;waypoints in the terminal area. 

((entering-flights nil) 

(exiting-flights nil) 

( isa-hold-pt nl 1 ) 

(from-node nil) 

(to-node nil ) 

(dist-to-td 0.0) 

(next-arcs nil ) 

(parent-route nil ) 

(label nil) 

(symbol nil) 

) 

9 

(> 

9 

:gettable- instance-variables 
: settable- instance-variables 
: ini table- Instance- variables 
) 


(DefMethod (ARC rafter :1nit) 

(ignore) 

;This daemon adds every newly Instantiated arc to the TERMINAL -GRAPH • s 
; 1 1 st of flights. 

(send TERMINAL-GRAPH :add-arc self) 

) 


(DefMethod (ARC :add-fl1ght) 

(flt-seg) 

;This method inserts a new flight plan segment "flt-seg" Into the list 
;of flight segments in sorted order. 

(If (* (nth 3 flt-seg) (send FRAME :time)) 

(setq entering-flights 

(sort (cons flt-seg entering-flights) 

•(lambda (segl seg2) 

(< (nth 2 segl) (nth 2 seg2))) 

)) 

) 

) 


(DefMethod (ARC :del-flight) 

(flt-seg) 

;Th1s method deletes the given flight plan segment "flt-seg" from the list 
;of flight segments. 

I 

(setq entering-flights (remove flt-seg entering-flights) 
exiting-flights (remove flt-seg exiting-flights) 

) 

) 


; entering flight segments 
jexiting flight segments 
;flag for holding arcs 
; source waypoint 
;dest1nat1on waypoint 
; distance to touchdown 
;connect1ng arcs 
; parent route 
;pr1nted label string 
; object symbol name 


(DefMethod (ARC : reset) 

() 

;This method removes all the old flight plans to reset the system state before 
;a scenario file is restored. 

(setq entering-flights nil 
exiting-flights nil 
) 

) 

29 


CHA:>Scoggins>newaveo>graph. 1 lsp.31 


1/16/86 18:42:39 


(DefMethod (ARC : run-entry-code) 

(flt-seg time) 

» 

(send FRAME tprlnt-advlsorles 

(list (format nil "Flight -A should have reached the ~A by ~\t1me\" 
(send (car flt-seg) : label) 
label 
time 
))) 

(send (car flt-seg) : set-current-arc self) 

(setq entering-flights 

(remove flt-seg entering-flights)) 

(setq exltlng-f lights 

(sort (cons flt-seg exltlng-fllghts) 

'(lambda (segl seg2) 

(< (nth 3 segl) (nth 3 seg2))) 

)) 

) 


(DefMethod (ARC :run-ex1 t-code) 

(flt-seg time) 

* 

(setq exltlng-fllghts 

(remove flt-seg exltlng-fllghts)) 
(+ 1 time) 

) 


(DefMethod (ARC rupdate) 

(time) 

» 

(loop for flt-seg In enterlng-f 1 Ights 
while (i time (nth 2 flt-seg)) 

do (send self : run -entry-code flt-seg time) ;execute the arc’s entry code 


» 

(loop for flt-seg In exltlng-fllghts 
while (£ time (nth 3 flt-seg)) 

do (send self : run -exit-code flt-seg time) ; execute the arc's exit code 

) 

) 


(DefMethod (ARC :wi 1 1 -conf 1 let) 
(new-seg) 


» 

( 


) 


let* ((fnt-bek 

(loop with front * nil 

with enter-time * (nth 2 new-seg) 
for seg In entering-flights 
when (< enter-time (nth 2 seg)) 
return (cons nil seg) 
while (* enter-time (nth 2 seg)) 
do (setq front seg) 
finally (return (cons front 

(cadr (member front 

entering-flights)))) 


) 


)) 

(list (send self :segs-confl let (edr fnt-bek) new-seg) 
(send self :segs-confl let new-seg (car fnt-bek))) 


) 


(DefMethod (ARC : segs-conf 1 let) 
(segl seg2) 

5 

(If (not (and segl seg2)) 

0 

(abs (min 0 

(- (nth 2 segl ) 


30 



CHA:>Scogg1ns>newaveo>graph. 1 isp.31 


1/16/86 18:42:39 


(nth 2 seg2) 

(send (car segl) :t1me-sep (car seg2)) 


31 



CHA:>Scogg1ns>nev*aveo>graph . 1 1sp.31 


1 / 16/86 18 : 42:39 


Flavor Definitions and Methods for Specific ARC Types 


(DefFlavor APPROACH-ARC 

() 

(ARC) 

) 


(DefFlavor HOLDING-ARC 

( ( Isa-hold-pt t) jholdlng flag set true 

) 

(ARC) 

) 


(DefMethod (HOLDING-ARC :w111-confl1ct) 
(new-seg) 

9 

; Nothing conflicts here yet... 
nil 
) 


(DefFlavor CORRECTION-ARC 
((advance 3.0) 

(delay 4.0) 

(maneuver "turn to base leg") 

) 

(ARC) 

) 


(DefMethod (CORRECTION-ARC :after : run-entry-code) 
(flt-seg time) 

? 

(send (car flt-seg) : Instal 1-plan 
nil 
(list 

(getbdg ’Jmsgs 

(list 'correction 

(send (nth 0 flt-seg) : label) 

(nth 2 flt-seg) 

maneuver 

(- (mod (abs (random)) 20) 10) 
advance 

(// (* advance 7200.0) 

(nth 6 flt-seg)) 
delay 

(// (* delay -7200.0) 

(nth 6 flt-seg)) 

'Imsgs 

)) 

) 

) 

) 


(DefFlavor TOUCHDOWN-ARC 

() 

(ARC) 

) 


(DefMethod (TOUCH DOWN -ARC :block-runway) 

(tlmel t1me2) 

# 

(loop for (flight arc enter . rest) In entering-flights 
when (£ tlmel enter t1me2) 

do (PLAN-BLOCKED-RUNWAY flight) 

) 


;fl1ght label 

jenterlng (correction) time 
; required maneuver 
•randomly generated error 
; distance of advance allowed 
;t1me of advance allowed 

;d1stance of delay allowed 
;t1me of delay allowed 

; returned correction messages 


) 


32 



CHA:>Scoggins>newaveo>graph . 1 Isp .31 


1/16/86 18:42:39 


(Def Flavor MISSED- ARC 

() 

(ARC) 

) 


(DefMethod (MISSED-ARC rafter : run-entry-code) 
(flt-seg time) 

* 

(send (car flt-seg) : set-current-route 'MISSED) 

) 


33 



CHA:>Scogg1n$>newaveo>graph . 1 1sp.31 


1 / 16/86 18 : 42:39 


GRAPH Flavor Definition and Methods 


(Def Flavor GRAPH 

((arc-list nl 1 ) 
(flight-list nil) 

) 

t 

o 

i 

:gett able- Instance- variables 
: settable- Instance -variables 
: Ini table- instance-variables 
) 


(DefMethod (GRAPH :add-arc) 

(arc) 

» 

(setq arc-list (cons arc arc-list)) 

) 


(DefMethod (GRAPH :del-arc) 

(arc) 

! 

(setq arc-list (remove arc arc-list)) 

) 


(DefMethod (GRAPH :add-f light) 

(flight) 

(setq flight-list (cons flight flight-list)) 

) 


(DefMethod (GRAPH :del-f light) 

(flight) 

(setq flight-list (remove flight flight-list)) 

) 


(DefMethod (GRAPH :update) 

(time) 

i 

(loop for arc In arc-list 

do (send arc :update time) 

) 

) 


(DefMethod (GRAPH :save-scenar1o) 

(pathname) 

(wi th-open-f lie 

(save pathname :d1rect1on routput) 

;Write file attribute list 

(format save " ; Mode: LISP; Package: MRS; Syntax: Zetallsp; Base: 10 -*-~2V) 

» 

;Write the list of runway blocks 

(loop for block In (trueps ’(blocked-runway Jtl Jt2)) 
collect (format save 

"(stash '(blocked-runway ~A ~A))~2% M 
(getvar *$t1 block) 

(getvar ’St2 block) 

) 


) 


34 


CHA:>Scogg1ns>newaveo>graph . 1 1 sp .31 


1/16/36 18:42:39 


; Write the current system time 
(format save 

“(send FRAME :reset-t1me ~A)~2%" 

(send FRAME :t1me) 

) 

! 

; Write list of flight object Instances 
(loop for fit In (reverse flight-list) 
for label * (send fit : label) 
do (format save 

"(setq ~A (make- Instance ’FLIGHT 
: label (get-pname '~A) 

: cl ass *~A 
: current-route *~A 
: current-arc ~A 
) )~ 2 %" 

label 

label 

(send fit :c1ass) 

(send fit : current-route) 

(send (send fit :current-arc) :symbol) 

) 

do (format save 

"(send ~A : Instal 1-plan '~A nil )~2%" 
label 

(loop for (flt2 arc . rest) In (send fit :segments) 
collect (format nil 

"( *~A ,~A . ~A)" 
label 

(send arc : symbol) 
rest 


) 

) 


(DefMethod (GRAPH : restore-scenario) 

(pathname) 

! 

; Remove all the old flights and flight plans and empty scratch theory 
(setq flight-list nil) 

(loop for arc In arc-list 
do (send arc : reset) 

) 

(empty theory) • 

5 

;Read In the given scenario file 
(load pathname) 

) 


35 



CHA:>Scogg1ns>newaveo>graph. 1 1sp.31 


1/16/86 18:42:39 


Compile, Load Flavors; and Instantiate Objects 


(Compl 1 e-Fl avor-Methods 
FLIGHT 

ARC APPROACH-ARC HOLDING-ARC CORRECTION-ARC TOUCHDOWN-ARC MISSED-ARC 
GRAPH 
) 


(setq TERMINAL-GRAPH 

(make-instance 'GRAPH)) 


(Comment (Inlt-path Drako wp6 wpIO wp14 wp20 wp53 wp42 wp35 wp39 D TD) 

(Inlt-path Keann wp4 wp15 wp17 wp19 wp20 wp53 wp42 wp35 wp39 D TD) 

(Inlt-path COS wp9 wp45 wp42 wp35 wp39 D TD) 

(Inlt-path Kiowa wp3 wp22 wp23 wp25 wp54 wp42 wp35 wp39 D TD) 

(Inlt-path Byson wp7 wp28 wp29 wp25 wp54 wp42 wp35 wp39 D TD) 

(inlt-path Missed D TD Miss wp53 wp42 D TD) 

) 


(setq MISSED 

(make-instance 'MISSED-ARC 

:d1 st-to-td 150.0 
; label "missed approach point" 
:symbo 1 'MISSED 
)) 

(setq TD-ARC 

(make-instance 'TOUCHDOWN -ARC 
:d1st-to-td 0.0 
: label "runway" 

: symbol 'TD-ARC 

)) 

(setq COR- DRAKO 

(make -Instance 'CORRECTION-ARC 
:d1st-to-td 30.0 
: label "Drako decision point" 

: symbol 'COR-DRAKO 

)) 

(setq COR-KEANN 

(make-instance 'CORRECT ION -ARC 

:d1st-to-td 30.0 , 

: label "Keann decision point" 

: symbol 'COR-KEANN 

)) 

(setq COR-COS 

(make- Instance 'CORRECTION- ARC 
;d1st-to-td 30.0 
; label "COS decision point" 

: symbol 'COR-COS 

)) 

(setq COR-KIOWA 

(make-instance 'CORRECT ION -ARC 
:dist-to-td 30.0 
: label "Kiowa decision point" 

: symbol 'COR-KIOWA 

)) 

(setq COR-BYSON 

(make-instance ’CORRECT I ON -ARC 
:dist-to-td 30.0 
: label "Byson decision point" 

: symbol 'COR-BYSON 

)) 


36 



CHA:>Scogg1ns>newaveo>graph . 1 1sp.31 


1/16/86 18:42:39 


(setq FF-DRAKO 

(make-instance ’ARC 

:d1st-to-td 100.0 
: label "Drako feeder fix" 

: symbol ’FF-DRAKO 

)) 

(setq FF-KEANN 

(make- Instance 'ARC 

:d1st-to-td 100.0 
: label “Keann feeder fix" 

: symbol ’FF-KEANN 

)) 

(setq FF-COS 

(make-instance ’ARC 

:d1st-to-td 100.0 
: label "COS feeder fix" 

: symbol ’FF-COS 

» 

(setq FF-KIOWA 

(make-instance ’ARC 

:d1st-to-td 100.0 
: label "Kiowa feeder fix" 

: symbol ’FF-KIOWA 

)) 

(setq FF-BYSON 

(make-instance ’ARC 

:d1st-to-td 100.0 
: label "Byson feeder fix" 

: symbol 'FF-BYSON 

)> 

(setq HOLD-DRAKO 

(make-instance ’HOLDING-ARC 

:d1st-to-td 100.0 
: label "Drako holding point" 
: symbol 'HOLD-DRAKO 
)) 

(setq HOLD-KEANN 

(make- Instance ’HOLDING-ARC 

:d1st-to-td 100.0 
: label “Keann holding point" 
: symbol ’HOLD-KEANN 
)) 

(setq HOLD-COS 

(make- Instance 'HOLDING-ARC 

:d1st-to-td 100.0 
: label "COS holding point" 

: symbol ’HOLD-COS 

)) 

(setq HOLD-KIOWA 

(make-instance ’HOLDING-ARC 

:d1st-to-td 100.0 
: label "Kiowa holding point" 
: symbol ’HOLD-KIOWA 
)) 

(setq HOLD-BYSON 

(make-instance ’HOLDING-ARC 

:d1st-to-td 100.0 
: label "Byson holding point" 
: symbol ’HOLD-BYSON 
)) 


(setq APP-DRAKO 

(make- Instance ’APPROACH-ARC 

:d1st-to-td 100.0 
: label "Drako approach path" 
: symbol ’APP-DRAKO 


37 



CHA:>Scoggins>newaveo>graph . 1 1sp.31 


1/16/86 18:42:39 


)) 

(setq APP-KEANN 

(make- Instance ’APPROACH-ARC 

:d1st-to-td 100,0 
: label "Keann approach path** 
: symbol ’APP-KEANN 
)) 

(setq APP-COS 

(make- Instance ’APPROACH-ARC 

:d1st-to-td 100.0 
: label "COS approach path" 

: symbol ’APP-COS 

)) 

(setq APP-KIOWA 

(make-instance ’APPROACH-ARC 

:d1st-to-td 100.0 
:label "Kiowa approach path" 
: symbol ’APP-KIOWA 
)) 

(setq APP-BYSON 

(make- Instance 'APPROACH-ARC 

:d1st-to-td 100.0 
: label "Byson approach path" 
: symbol ’APP-BYSON 
)) 


38 



CHA:>Scogg1ns>newaveo>graph. 1 Isp .31 


1/16/86 18:42:39 


Interconnect Arcs In the Terminal Graph 


(send MISSED 

: set-next-arcs (list FF-DRAKO HOLD-DRAKO) ) 

(send TD-ARC 

: set-next-arcs nil) 

(send COR-DRAKO 

:set-next-arcs (list TD-ARC)) 

(send COR -KE ANN 

: set-next-arcs (list TD-ARC)) 

(send COR-COS 

: set-next-arcs (list TD-ARC)) 

(send COR-KIOWA 

: set-next-arcs (list TD-ARC)) 

(send COR-BYSON 

: set-next-arcs (list TD-ARC)) 

(send FF-DRAKO 

: set-next-arcs (list COR-DRAKO)) 

(send FF-KEANN 

: set-next-arcs (list COR-KEANN)) 

(send FF-COS 

: set-next-arcs (list COR-COS)) 

(send FF-KIOWA 

: set-next-arcs (list COR-KIOWA)) 

(send FF-BYSON 

:set-next-arcs (list COR-BYSON)) 

(send HOLD-DRAKO 

: set-next-arcs (list FF-DRAKO)) 

(send HOLD-KEANN 

: set-next-arcs (list FF-KEANN)) 

(send HOLD-COS 

: set-next-arcs (list FF-COS)) 

(send HOLD-KIOWA 

: set-next-arcs (list FF-KIOWA)) 

(send HOLD-BYSON 

: set-next-arcs (list FF-BYSON)) 

(send APP-DRAKO 

: set-next-arcs (list FF-DRAKO HOLD-DRAKO)) 
(send APP-KEANN 

: set-next-arcs (list FF-KEANN HOLD-KEANN)) 
(send APP-COS 

: set-next-arcs (list FF-COS HOLD-COS)) 
(send APP-KIOWA 

: set-next-arcs (list FF-KIOWA HOLD-KIOWA)) 
(send APP-BYSON 

: set-next-arcs (list FF-BYSON HOLD-BYSON)) 


39 


CHA:>Scoggin$>newaveo>user . 1 1sp.40 


1/16/86 17:10:27 


Mode: LISP; Package: MRS; Syntax: Zetallsp; Base: 10 
NB: Change this first line and all life as you know It will cease to exist... 


John Scoggins 
NASA/Ames Research Center 
M/S 210-9 

Moffett Field, CA 94035 
(415) 694-5431 

Overview 

This file defines the flavors and methods used In the object base of 
the ATC Scheduler expert system. For documentation about the syntax and 
features of the Flavors package, please see the Symbolics manual called 
"Reference Guide to Symbol 1cs-L1sp" , p. 417. Since much of this file 
concerns the graphics and user Interface packages. It Is also helpful to 
see the Symbolics manual called "Programming the User Interface", p. 73. 

This file will: 

• Define the global variables for the system 

• Define the flavors and methods for windows, routes and planes 

All of this code Is defined in terms of lisp functions or calls to the 
Flavors package, so It might be useful to compile this file for faster 
execution. 


40 


CHA:>Scogg1ns>newaveo>u$er. 1 1sp.40 


1/16/86 17:10:27 


Define Global Variables 

We use the function (DECLARE (SPECIAL <var>)) to define global variables 
Instead of the typical use of SETQ. This defines variables in terms 
of the Flavors package. Primarily, this results in cleaner programming and 
less compiler warnings, but no change In the execution semantics. 


(comment (Declare 
(special FRAME 

MENU-FLIGHT 
MENU-CLASS 
MENU-ROUTE 
MENU-TIME1 
MENU-TIME2 
MENU-ALT 
MENU-CAS 
MENU-ARC 
MENU-MORE 
MENU-FLIGHTS 
MENU-TRACE 
MENU-STEP 
MENU-GC 
• )) 


) 

; Menu variable Initial definitions 

(setq MENU-ID 'PA001) 

(setq MENU-FLIGHT nil) 

(setq MENU-CLASS ’HEAVY) 

(setq MENU-ROUTE ’DRAKO) 

(setq MENU-TIME1 (time:get-un1versal-t1me)) 
(setq MENU-TIME2 ( t1me:get-un1 versal-time)) 
(setq MENU-ALT 36000.0) 

(setq MENU-CAS 180.0) 

(setq MENU-ARC ’TD-ARC) 

(setq MENU-MORE nil) 

(setq MENU-FLIGHTS nil) 

(setq MENU-TRACE nil) 

(setq MENU-STEP t) 

(setq MENU-MI NSTEP 4) 

(setq MENU-SAVE ’SAVE) 

(setq MENU-FILE M CHA: >Scogg1ns>TestCases.save" ) 
(setq MENU-GC *gc-off) 


41 



CHA:>Scoggins>newaveo>user . 1 1sp.40 


1/16/86 17:10:27 


;;; PANE Flavor Definitions and Methods 


» • 


(Def Flavor LISTENER-PANE ((who- line ■■) 

) 

(tv:w1ndow) 

:gettable- Instance-variables 
: settab 1 e- 1 nstance-var 1 abl es 
; Ini table- Instance-variables 
) 


; these flags mean that any of the 
flavor’s slot can be Initialized, 
; accessed or reset 


(DefMethod (LISTENER-PANE :who-1 Ine-documentat Ion-string) 

() ; explain mouse features 


who-1 Ine 


2 


CHA:>Scogg1ns>newaveo>user . 1 1sp.40 


1/16/86 17:10:27 


FRAME Flavor Definitions and Methods 


(Def Flavor FRAME ((advisories nil) 

(command-menu nil) 

( listener nil ) 

(time-routes nil ) 

(mln-tlme-step 4) 

(last-time 0) 

(time 0) displayed time 

(routes nil) 

) 

( tv: bordered-constral nt-f rame-wl th-shared- 1 o-buf fer 
tv:bas1c-frame 


) 

:gettable- Instance-variables 
: settable- Instance-variables 
: inltable-instance-varlables 


) 


(Def Method (FRAME rafter :1nit) 
(Ignore) 


(setq 


(send 

(send 

) 


advisories 

command-menu 

listener 

time-routes 

time 

last-time 

) 


(send self :get-pane ’ADVISORIES) 
(send self :get-pane ’COMMAND-MENU) 
(send self :get-pane ’LISTENER) 
(send self : get-pane ’TIME-ROUTES) 
(time: get-universal -time) 

(time: get-universal -time) 


self : set-save-bits t) ;save screen when deexposed 

self :select-pane listener) 


(DefMsthod 
(loop do 


(FRAME : command- loop) 

() ; command loop for system - this enables 

;the use of mouse/menu driven user Input 

(catch-error-restart 

((ERROR SYS: ABORT) "Return to the ATC Scheduler prompt") 


(send self rexpose) 

(setq TERMINAL-IO listener) 

(send listener :fresh-11ne) 

(cond ((or MENU-STEP 

(send listener : listen) 

) 

(multiple-value-bind (value flag) 

(with- Input-editing-options 
( ( :preemptable :b!1p) 

(: prompt "ATC Scheduler: ") 

) 

(read-or-end listener ’read-command-or-form) ) 
(selectq flag 
( :end 

(format t "~&~A" "Leaving the ATC Scheduler...") 
(return t) 

) 

( :bl ip 

(selectq (car value) 

( :menu 

(catch 'MENU-ABORT 

(format listener (eval (caddadr value))) 

) 

) 

( :mouse-button 
(selectq (cadr value) 

(#\mouse-l -1 
ni 1 
) 


M3 



CHA:>Scoggins>newaveo>user .1 1sp.40 


1/16/36 17:10:27 


(#\mouse-m-1 

(setq MENU-STEP (not MENU-STEP)) 

(If (not MENU-STEP) 

(send listener :set-more-p nil) 

) 

) 

(#\mouse-r-1 

nil 

) 

) 

) 

(otherwise 

(format listener "Random blip $" value))) 

) 

(: command 

(format listener "Execute ~:C command" (second value)) • 

) 

(otherwise 

(send listener :fresh-11ne) 

(format listener (eval value)) 

) 

) 

) 

) 

((cond ((and (not MENU-STEP) 

(< mln-tlme-step 
(abs (- last-time 

(time: get-universal -time) ) ) ) 

) 

(send FRAME :update-t1me) 

(send FRAME : draw-time-routes) 

(send TERMINAL-GRAPH rupdate time)) 

)) 


(DefMethod (FRAME :draw-t1me-routes) 

() 

;Draw the time lines 

(send time-routes rclear-wlndow) 

(loop for (route . lines) In routes 

do (eval '(send , time-routes :draw-11nes tv:alu-1or ,G11nes)) 
do (send time-routes :draw-string (get-pname route) 0 (+ 12 (cadr lines))) 
) 

;Draw each flight 

(loop for (flight arc enter exit dls alt cas) 

In (send TD-ARC :enter1ng-f 1 Ights) 


(send time-routes swldth) 

(// max-x 4000.0) 
nil 

(- max-x (round (* (- enter time) scale))) 

(nth 2 (assoc (send flight : current-route) routes)) 
for x-sep first 0 then (round (* scale (send flight :t1me-sep front))) 
do (send time-routes :draw-str1ng (send flight : label) x-pos (- y-pos 12)) 
(send time-routes :draw-char fonts:ATCFONT (send flight :1con) x-pos y-pos) 
(send time-routes : draw- rectangle x-sep 3 x-pos (1- y-pos)) 

(setq front flight) 

) 

current time 


with max-x 
with scale 
with front 
for x-pos 
for y-pos 


do 

do 

do 


;Draw the 
(send time-routes 
: draw-string 

(format nil "Current Time: ~\t1meV 
(- (send time-routes twldth) 100) 

(- (send time-routes shelght) 20) 
tv:alu-xor 
) 


; redisplay the current time - the bit logic 
; function TV: ALU-XOR seems to right justify 
time) 


(DefMethod (FRAME :pr1nt-adv1 sorles) 
(advs) 

:Di.-nlay a list of new advisories onto 
ADVISORIES pane 


44 



CHA:>Scogg1n$>newaveo>u$er . 1 1$p.40 


1/16/86 17:10:27 


(loop for m In (reverse 

(cond ((atom advs) (list advs)) 
(t advs))) 

do (send advisories :home-cursor) 
do (send advisories : Insert-1 Ine) 
do (send advisories :str1ng-out m) 

) 

) 


(DefMethod (FRAME :reset-time) 

(new- time) 

» 

(setq time new-time 

last-time (t1me:get-un1versa1-t1me) 

) 

) 


(DefMethod (FRAME : update-time) 

() 

5 

(let* ((thls-tlme (t1me:get-universal-time))) 
(setq time (♦ time (- thls-tlme last-time)) 
last-time thls-tlme 
) 

time 

) 

) 


45 



CHA:>Scoggins>newaveo>user . 1 1$p.40 


1/16/86 17:10:27 


Command Menu Items 


(DefVar MENU-ITEMS 

'(("New Arrival" 

: value (let* () 

(setq MENU-TIME1 (send FRAME :update-time) ) 

(tv: choose-varlabl e-values 

'((MENU-ID "Flight ID" rexpresslon) 

(MENU-CLASS "Class" :choose 

(HEAVY URGE SMALL)) 

(MENU-ROUTE "Current Route" rchoose 

(DRAKO KEANN COS KIOWA BYSON MISSED)) 

(MENU-TIME1 "Time 9 Feeder Fix" :date) 

(MENU-ALT "Current Altitude" : decimal -number) 

(MENU-CAS "Current CAS" : decimal -number) 

) 

: label "Arrival Flight Parameters" 

: margin-choices '(("Abort" (throw 'MENU-ABORT "Menu Options Aborted")) 


(PUN-NEW-ARRIVAL 

MENU-ID MENU-CUSS MENU-ROUTE MENU-TIME 1 MENU-ALT MENU-CAS)) 

: documentation " Create a new arrival" 

) 

("Blocked Runway" 

:value (let* ( ) 

(setq MENU-TIME 1 (send FRAME :update-t1me) ) 

(setq MENU-TIME2 MENU-TIME1 ) 

(tvrchoose-varlable-values 
' ( (MENU-TIME1 "From " :date) 

(MENU-TIME2 "Until" :date) 

) 

: label "Blocked Runway Parameters" 

: margin-choices '(("Abort" (throw 'MENU-ABORT "Menu Options Aborted")) 

) 

) 

(stash ‘(blocked-runway , MENU-TIME 1 # MENU-TIME2) ) 

(send TD-ARC :block-runway MENU -TIME 1 MENU-TIME2) 

) 

: documentation " Signal a blocked runway condition" 

) 

("Missed Approach" 
rvalue (let* () 

(setq MENU-FLIGHT nil) 

(tvrchoose-varlable-values 

‘((MENU-FLIGHT "Flight to miss approach" 

: assoc ,(mapcar '(lambda (fit) 

(cons (send fit : label) fit)) 

(send TERMINAL-GRAPH :f 1 1ght-l 1st ) 

)) 

) 

imargln-cholces ’(("Abort" (throw 'MENU-ABORT "Menu Options Aborted")) 

) 

) 

(If MENU-FLIGHT 

(PUN-MISSED-APPROACH MENU-FLIGHT) ) 

: documentation • Signal a missed approach condition" 


("Display Flight Plan" 

: value (let* ((old-more-p (send TERMINAL-IO :more-p)) 

) _ 

(send TERMINAL-IO :set-more-p t) 

(setq MENU-FLIGHT nil) 

(tvrchoose-varlable-values 

‘((MENU-FLIGHT "Flight to display" 

rassoc ,(mapcar '(lambda (fit) 

(cons (send fit rlabel) fit)) 


46 



CHA:>Scogg1ns>newaveo>u$er . 1 1$p.40 


1/16/86 17:10:27 


(send TERMINAL-GRAPH :f 1 1ght-l 1st ) 

)) 

) 

: margin-choices ’(("Abort" (throw 'MENU-ABORT "Menu Options Aborted")) 

) 

(send TERMINAL-IO rclear-wlndow) 

(If MENU-FLIGHT 

(send MENU-FLIGHT : report-pi an ) ) 

(send TERMINAL-IO :set-more-p old-more-p) 

) 

:document3t1on " Display a report of some flight’s scheduled plan" 

) 

("Obliterate Flight" 
rvalue (let* () 

(setq MENU-FLIGHT nil) 

(tvrchoose-variable-values 

*( (MENU-FLIGHT "Flight to remove" 

: assoc ,(mapcar ’(lambda (fit) 

(cons (send fit rlabel) fit)) 

(send TERMINAL-GRAPH :f 1 1ght-l 1st ) 

)) 

) 

: margin-choices ’(("Abort" (throw ’MENU-ABORT "Menu Options Aborted")) 


(if MENU-FLIGHT 

(send MENU-FLIGHT rremove-self ) ) 

) 

: documentation " Disavow any Information concerning a particular flight" 

("Modify Clock" 
rvalue (let* () 

(setq MENU-TIME1 (send FRAME r update-time) ) 

(tvrchoose-variable-values 

’ ( (MENU-TIME1 "New Time" rdate) 

(MENU-MINSTEP "Minimum Time Step" r Integer) 

(MENU-STEP "Time Stepping Mode" rassoc (("Real-Time" .nil) 

("Manual -Step" . t) 

)) 

) 

rmargln-cholces ' (("Abort" (throw ’MENU-ABORT "Menu Options Aborted")) 


(If (not MENU-STEP) 

(send TERMINAL-IO rset-more-p nil) 

) 

(send FRAME rreset-tlme MENU- TIME 1 ) 

) 

r documentation " Change the system clock parameters" 

) 

("Save or Restore" 
rvalue (let* () 

(tvrchoose-variable-values 

’((MENU-FILE "Scenario file" rpathname) 

(MENU-SAVE "Perform with file" rchoose (SAVE RESTORE)) 

) 

rmargln-cholces ’(("Abort" (throw ’MENU-ABORT "Menu Options Aborted")) 


(selectq MENU-SAVE 
(SAVE 

(send TERMINAL-GRAPH r save-scenario MENU-FILE)) 

(RESTORE 

(send TERMINAL-GRAPH r restore-scenario MENU-FILE)) 

) 

) 

r documentation • Use a saved scenario file to control the simulation" 

) 

("More Processing" 
rvalue (let* () 

(tvrchoose-variable-values 

47 



CHA:>Scoggin$>newaveo>user . 1 1sp.40 


1/16/86 17:10:27 


•((MENU-MORE "Listener **M0RE** processing" :assoc (("On" . t) 

("Off" .nil) 

)) 

) 

tmargln-cholces ’(("Abort" (throw ’MENU-ABORT "Menu Options Aborted")) 


(If MENU-MORE 

(setq MENU-STEP t) 

) 

(send TERMINAL- 10 :set-more-p MENU-MORE) 

) 

: documentation " Toggle Listener **M0RE** processing" 

) 

("MRS Task Tracing" 

:value (let* () 

(tvtchoose-varlable-values 

’((MENU-TRACE "MRS task tracing" :assoc (("On" . t) 

("Off" .nil) 

)) 

) * 

:marg1n-cho1ces ’(("Abort* (throw 'MENU-ABORT "Menu Options Aborted")) 


(if MENU-TRACE 

(tracetask ’&x) 

(untracetask) 

) 

) 

: documentation " Toggle MRS task tracing” 

) 


("Garbage Collection" 
tvalue (let* ((old-state MENU-GC) 

) 

( tv: choose-varlabl e-values 

’((MENU-GC "Garbage collection" :assoc (("On" . gc-on) 

("Off" . gc-off) 

("Immediately" . gc- Immediately) 
(“Status" . gc-status) 

)) 

) 

tmargln-cholces ’(("Abort" (throw 'MENU-ABORT "Menu Options Aborted")) 

) 

) 

(apply MENU-GC nil) 

(If (eq MENU-GC 'gc-status) . 

(setq MENU-GC old-state) 

) 

) 

: documentation " Change the garbage collection state’ 

) — 

) 

) 


48 


CHA:>Scogg1ns>newaveo>user . 1 Isp .40 


1/16/86 17:10:27 




Compile, Load Flavors; and Instantiate Objects 


We give the compiler the names of each flavor to be used In the system. 
Then as this file Is compiled, all flavor definitions and methods will be 
compiled into the bin file. Also, data structures for all the flavors will 
then be created at load time. Otherwise the flavors and methods would be 
compiled at run time. 


I I M M I M I I 1 I M » M » M I I II M I I M I t I I M I » I I r I > t I I » M > > > > I I M I » M M I I I M , ! ! ) » ! » > 


(Compl le-Flavor-Methods 
LISTENER-PANE 
FRAME 
) 


(setq FRAME 

(tvrmake-wlndow ’FRAME 
: routes 

’((Drako 0 50 900 50 900 100 1067 100) 
(Keann 0 100 1067 100) 

(COS 0 150 900 150 900 100 1067 100) 

(Kiowa 0 200 900 200 900 100 1067 100) 

(Byson 0 250 900 250 900 100 1067 100) 

(Missed 0 300 900 300 900 100 1067 100) 

) 

:panes 

* ( (COMMAND-MENU tv: command-menu -pane 

: Item- list .MENU- ITEMS 

) 

(TIME-ROUTES tv: window-pane 

: font-map ,(11st fonts: hi 7) 

: label '•Time Routes" 
:bl1nker-p nil 
) 

(ADVISORIES tv: window-pane 

: font-map ,(11st fonts :tvfont) 
: label "Advisories" 

:more-p nil 
:blinker-p nil 
) 

(LISTENER LISTENER-PANE ’ 

: font-map ,(11st fonts: tvf on t) 

: label "Listener" 

:more-p nil 
:who-11ne 

" M: Real Time on//off..." 

) 

) 


) 


constraints 

* ( (main . ((TIME-ROUTES bottom-strip) 

((bottom-strip horizontal (0.5) 

(ADVISORIES COMMAND-MENU LISTENER) 
((ADVISORIES 0.46) 

(COMMAND-MENU 0.14) 

(LISTENER 0.40)))) 
((TIME-ROUTES :even)))) 

) 

) 


*\9 



WA374 


DRAKO 

— r 

UA003 

PA003 

KEANN 



i 

* 

COS 



KIOWA 



BYSON 




MISSED 

TIME ROUTES CURRENT TIME: 12:37:03 


Fig. 2 Schedule for New Arrival. 



B: LATEST TURN POINT 


MAX. CHANGE 0 * 


Fig. 3 Path Correction. 


51 










Fig. 4 Missed Approach Route. 


52 




Fig. 5 Time Line, (a) Just before Missed Approach for AA251. (b) Missed Approach 

for AA251. 






(a) 







DRAKO 

AA251 

KEANN 

i 

* 

COS 


KIOWA 


BYSON 


PA35 



MISSED 


i 



TIME ROUTES 



CURRENT TIME: 13:21:51 | 


(b) 


Fig. 6 Time Line, (a) Runway Closure, (b) Revised Schedule Due to Runway Closure 


5 




INFORMATION FOR ARC J - H 


DISTANCE-TO-TOUCHDOWN: 

ALTERNATE-PATH: 

ENTRY-CODE: 

EXIT-CODE: 

ENTERING-FLIGHTS: 

EXITING-FLIGHTS: 


165 n.mi. 

J - F 

FEEDER FIX ENTRY PROC 
FEEDER FIX EXIT PROC 
(PA35 13:02:23 13:11:45 36000 182) 
(VA07 13:10:55 13:20:01 34500 178) 
(AA24 12:50:33 12:59:57 32800 191) 
(XX01 12:55:41 13:03:28 29000193) 


Fig. 7 Terminal area represented as a direct graph. 


55 





*00R QUALITY 


m i/n/M itom 


New Arrival 
Blocked Runway 
Hissed Approach 
| Display Flight, Plan 
Obliterate Flight 
Modify Clock 
Save or Restore 
More Processing 
HRS Tesk Tracing 
I Garbage Collection 


pTC 

r*f um< IPiafel* U find ttm f I If 

OF« tteaggirMtf t ?ur*-2‘ im 

• MUw* irdttad (drf«wU OMi »*£•«* ln«»f i jm*"*-! . •** ) T Odi 

■win »T#*tC — 

| Odi>lM 99 ir«*Ti 

pTC 


19719 

**>> 


MTCUDCO li me ll«*4TU> J7 1371 OU Hi 371 0*7 • • * • JO 

■*aj* 


|t«rUO<T 13713M* 
FTC tcf*»«Jl«rt (p 


pit Idaifciltn 
l^nrt # 11 ) 

I cfw Xttn 
k**nd **731 i art- to 


i **731 iwt'K 


* Ch«: >oc 099 ins>newavcs/ dec . ntp 92J; Ibis 


User interface. 


56 




1. Report No. 

NASA TM-88234 

2. Government Accession No. 

4. Title and Subtitle 


TIME-BASED AIR TRAFFIC MANAGEMENT USING 
EXPERT SYSTEMS 

7. Author(s) 


L. Tobias and J. L. Scoggins 

9. Performing Organization Name and Address 


Ames Research Center 
Moffett Field, CA 94035 


12. Sponsoring Agency Name and Address 


National Aeronautics and 
Washington, DC 20546 

Space Administration 


3. Recipient's Catalog No. 


5. Report Date 

April 1986 


6. Performing Organization Code 


8. Performing Organization Report No. 

A-86188 


10. Work Unit No. 


1 1 . Contract or Grant No. 


13. Type of Report and Period Covered 
Technical Memorandum 


14. Sponsoring Agency Code 

505-66-1 


15. Supplementary Notes 

Point of Contact: L. Tobias, Ames Research Center, M/S 210-9, Moffett 

Field, CA 94035. (415) 694-5430 or FTS 464-5430 


16. Abstract 

A prototype expert system has been developed for the time scheduling 
of aircraft into the terminal area. The three functions of the air- 
traffic-control schedule advisor are as follows: First, for each new 

arrival, it develops an admissible flight plan for that aircraft. Second, 
as the aircraft progresses through the terminal area, it monitors devia- 
tions from the aircraft's flight plan and provides advisories to return 
the aircraft to its assigned schedule. Third, if major disruptions such 
as missed approaches occur, it develops a revised plan. The advisor is 
operational on a Symbolics 3600, and is programmed in MRS (a logic pro- 
gramming language). Lisp, and Fortran. 


17. Key Words (Suggested by Author(s)) 

Air traffic control 
Expert system 
Scheduling 


19. Security Classif. (of this report) 

Unclassified 


18. Distribution Statement 

Unlimited 


20. Security Classif. (of this page) 

21. No. of Page* 

Unclassified 

58 


Subject Category - 03 


22. Price* 

A04 


*For sale by the National Technical Information Service, Springfield, Virginia 221 61 






















