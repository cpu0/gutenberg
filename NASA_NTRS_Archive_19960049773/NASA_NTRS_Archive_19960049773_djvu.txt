NASA Contractor Report 201592 



CLMNANAL: A C++ Program for 
Application of the Coleman Stability 
Analysis to Rotorcraft 


Michael B. Lance 

Lockheed Martin Engineering & Sciences Company 
Hampton , Virginia 


Contract NAS1-19000 
August 1996 


National Aeronautics and 
Space Administration 
Langley Research Center 
Hampton, Virginia 23681-0001 



Summary 


The theory of the self-excited instability of hinged rotor blades, commonly known as 
ground resonance, was worked out by Robert P. Coleman and Arnold M. Feingold between 
the years of 1942 and 1947. Two Restricted Reports and a Technical Note were released 
describing the theoretical analysis of ground resonance, and the methodology for the applica- 
tion of the theory to rotorcraft (reference 1). Various interpretive papers were written on the 
subject of application of the theory to rotor systems with 3 or more blades. A FORTRAN 4 
program was developed based on those papers. That program was upgraded and corrected in 
a FORTRAN 77 version. This C++ program was based on the FORTRAN 77 version. 

Introduction 

CLMNANAL is a C++ program for applying the analysis presented in reference 1 to rotor- 
craft configurations with 3 or more articulated blades. CLMNANAL will allow for analysis 
of multiple excitation modes, but has only been tested for the two mode case of pitch and roll. 
One possible use for this multiple-mode capability would be for the analysis of one or two dif- 
ferent modes of motion for multiple weight configurations. 

The C++ source code, including custom header files, is listed in the appendices. 

Compilation 

CLMNANAL is fully ANSI compatible, and will compile and run on either a Unix or DOS 
based platform. The program was compiled on a HP-UX system (Unix) with the GNU C++ 
compiler. The C++ libraries were in a directory, /usr/gnu/lib/g++_include, which was linked 
to the standard include directory, /usr/include, by the link “gnu”. As a result, this link was part 
of the include statements for C++ specific header files. For compilation on such a system, the 
compiler switch -D_GNU was used to instruct the compiler to use the linked headers instead 
of the standard headers. Compilation on DOS based systems was performed using the 
Microsoft Visual C++ 1.52 compiler set for a DOS target application. 

For limited debug output, the compiler switch -D_DBG can be used. This debug output 
will be printed to a file named “DebugOut”. 

Command Line Syntax 

The command line syntax for CLMNANAL is: 

CLMNANAL [option] 
where available options are: 

-h or -H - Displays a help file. 


1 


-o or -O - Displays an overview of CLMNANAL and how to run it. 

-a or -A - Runs an analysis session. 

-t or -T - Runs an analysis session and displays time elapsed for data entry, time 
elapsed for computations and total time elapsed. 


Input 

CLMNANAL will run with two kinds of input: Dimensional (engineering units) and non- 
dimensional. The dimensional inputs, in the order they would appear in a text file, are: 

Integer number of modes to analyze 
Integer number of blades. 

Rotor radius (in) 

Hinge radial station (in) 

Blade radius of gyration (in) 

Blade weight (lb) 

Pylon weight (lb) 

Lag hinge radial spring constant (ft-lb/rad) 

Lag hinge radial damping constant (ft-lb-sec/rad) 

For each mode: 

Descriptive mode label string 
Pylon spring constant (lb/ft) 

Pylon damping constant (lb-sec/ft) 

Name of file in which to store results for this mode 

The non-dimensional inputs, in the order they would appear in a text file, are: 

Integer number of modes to analyze 
Blade lead/lag natural frequency (Hz) 

Blade lead/lag critical damping ratio 

Ratio of lead/lag hinge radial location to the blade radius of gyration. 

One-half the ratio of the sum of the rotor blade masses to the sum of blade masses and 
pylon mass 
For each mode: 

Descriptive mode label string 
Pylon natural frequency (Hz) 

Pylon critical damping ratio 

Name of file in which to store results for this mode 


Output 

The results of the analysis will be stored in the file specified by the user in the input. The 
output consists of: 

A record of the input data. 


2 



A listing of complex roots, ordered by rotor RPM. The resolution of this listing will be 
according to user input unless a resonance was encountered. In the event of a resonance, 

the roots will be output at a resolution of 1/20^ the user specified resolution. 

A damping analysis specifying the system damping product available, and the damping 
product required. 

Resonance frequency information - range, predicted range and mid-point of range. 

A comparison of the maximum real root and the predicted maximum real root. 

References 

1 Coleman, Robert P.; and Feingold, Arnold M.: Theory of Self-Excited Mechanical 

Oscillations of Helicopter Rotors With Hinged Blades. NACA TR 1351, NAC A TN 3844, 
1958. 


3 


Appendix I 


String Class 

Specification 

// mystring.h 

// 

// Specification for custom String class. 

// 

// Michael B. Lance 

// Lockheed Engineering and Sciences Company 
// Hampton, Virginia 

fifndef _MYSTRING_H 
#def ine _MYSTRING_H 

#ifdef _GNU 

#include <gnu/iostream. h> 

#else 

♦include <iostream.h> 
fendif 

class String 
{ 

public : 

String (); // The constructor. Since the text data 

// member of a String instance is dynamically 
// allocated, the actual String will be built 
// with an "Invocation" function. 

String(const Strings.); // This is the copy constructor. 

// Note that since it is called by 
// reference, the parameter does 
// not call the constructor. 

~String(); // The destructor. 

int IString (char*) ; // Invocation function. Handles the 

// dynamic allocation tasks for all 
// String instances. 

int IString (const char*); // Overloaded IString function. 


4 



int IString (unsigned char*); // Overloaded IString. 

int IString (const Strings); // Overloaded IString. 

int GetLengthO const; // Function to return the String 

// length. 

// Function to return the location in the String of the 
// first occurrence of the FindSet string: 

int FindFirst (const char* pFindSet) const; 

// Function to return the last location in the String of the 
// occurrence of the FindSet string: 

int FindLast (const char* pFindSet) const; 

char* GetTextPtrO const; // Function to return a 

// pointer to the String text . 

String LowerCase (); // Function to return the lower-case 

// representation of a String. 

String Uppercase (); // Function to return the upper-case 

// representation of _a String. 

// Function to return a String of NumChar characters 
// starting at Position in the String: 

String GetChars (int Position, int NumChar) const; 

String GetChars (const char* pChars) const; // Overloaded 

// GetChars. 

II Overloaded = to handle assignments like si— s2. It 
// must also allow sl=s2=s3: 

Strings operator= (const Strings); 

Strings operator= (const char*); // Overloaded = to handle 

// sl=" 

// Overloaded + to handle sl+s2. Can add a constant String 
//to si, the result is not a constant. Note this function 
// cannot return a referenced value because a return value 
// must be created in the function to leave both the implicit 
// and explicit values unchanged. The return value does not 
// have any persistence. Also handles sl+" " . 

String operator+ (const Strings) const; 


5 


String operator+ (const char &c) const; // Overloaded + 

// to handle 
// si + • • . 

int operator== (const Strings) const; // Overloaded == to 

// handle sl==s2. 

int operator != (const Strings) const; // Overloaded != 

//to handle 
// si ! =s2 . 

int operator== (const char*) const; // Overloaded == to 

// handle sl==" 

int operator != (const char*) const; // Overloaded != to 

// handle sl!=" " . 

int operator> (const Strings) const; // Overloaded > to 

// handle sl>s2. 

int operator< (const Strings) const; // Overloaded < to 

// handle sl<s2. 

// Overloaded [] to return the i'th member of the 
// text part of a String: 

chars operator [] (const intS) const; 

// Overloaded cast operator. Allows casting of Strings 
// to a constant character pointer: 
operator const char* () const; 

// Overloaded cast operator. Allows casting of Strings 
// to a character pointer: 
operator char* () const; 

// Function to compare a String to two input strings: 
int CompOr (const char*, const char*) const; 

// All the following functions must be friends because the 
// first function argument is not a member of the String 
// class. All true class member functions are called with the 
// first argument data supplied implicitly by the class object 
// through use of the Object .Function (Argument) notation. 

/ / Friend functions are called like non— class— member functions 
// in order to explicitly provide the data through the 


6 



// arguments. 


// This function allows an instance of sl+s2, " "+sl or 

// » " + " «. It uses the cast operator to properly convert the 

// Strings: 

friend String operator+ (const char*, const char*) ; 


// Function to 
friend int 


check for " " == si: 

operator== (char*, const Strings); 


// Function to check for " " != si: 

friend int operator!= (char*, const Strings); 

// Function to check for sl>s2, " ">sl, or " ">" " : 
friend int operator> (const char*, const char*) ; 

// Function to check for sl<s2, " "<sl, or " "<" 

friend int operator< (const char*, const char*); 


// Overloaded cin so String type variables can be read from 
// stdin . It must return an istream type, and must be a friend 
// because istream data are not accessible by the String 
// class. istreams cannot be converted to Strings, nor can 
// Strings be converted to istreams. 

friend istreams operator» (istreams. Strings); 


// Overloaded cout so String type variables can be written to 
// stdout . It must return an ostream type, and must be a 
/ / friend because ostream data are not accessible by the 
// String class, ostreams cannot be converted to Strings, 

// nor can Strings be converted to ostreams. 

friend ostreams operator<< (ostreams, const Strings), 


// Data Members 
private : 

int lgth; 
char *txt; 


#endif 


7 


Implementation 

// mystring.cpp 

// Implementation of custom String class. 

// Michael B. Lance 

// Lockheed Engineering and Sciences Company 
// Hampton, Virginia 

♦include <stdlib.h> 

♦include <string.h> 

♦include "mystring.h" 

String: : String () // Constructor with void argument. 

{ 

lgth=l; // Initialize the length to 1. 
txt=NULL; // Initialize the text pointer to NULL. 


String :: String (const String &s) // Copy constructor. 

{ 

lgth=s . lgth; 

if ( (txt= new char [lgth+1 ] ) == NULL) // Catch memory 
{ // problem. 

cout << "\nString copy constructor could not allocate"; 
cout << " memory for String \"" « s.txt << 

} 

strcpy (txt , s.txt) ; 


String: : -String () // Destructor. 

{ 

delete [] txt; 

} 

int String :: IString (char *ds) // Invocation function. 

// Can return an error flag 
{ //if needed. 

lgth=strlen (ds) ; // Set length. 

if ( (txt= new char ( lgth+1 ] ) == NULL) // Dynamic allocation 

// of txt. 

return (0); // Return 0 if there is not enough memory, 

else 

strcpy (txt, ds) ; // Else copy the string to txt. 


8 



return (1); // Return 1 on success. 

} 

int String :: IString (const char *ds) // Overloaded Invocation 
j // function. 

lgth=strlen (ds) ; // Set length. 

if ((txt- new char [lgth+1] ) == NULL) // Dynamic allocation 

// of txt . 

return (0); // Return 0 if there is not enough memory, 

else 

strcpy (txt, ds) ; // Else copy the string to txt. 

return (1); // Return 1 on success. 

} 

int String: : IString (unsigned char *ds) // Overloaded 

j // Invocation 

j // function. 

lgth=strlen ( (const char*)ds); // Set length. 

if ((txt- new char [lgth+1] ) — NULL) // Dynamic allocation 

// of txt. 

return (0); // Return 0 if there is not enough memory. 

else . 

strcpy (txt/ (char*) ds) ; // Else copy the string to txt. 

return ( 1 ) / // Return 1 on success. 

} 

int String: :IString (const String SlnString) // Overloaded 

// Invocation 
// function. 

int rtlnt; // Declare a return value holder. 
lgth=InString . lgth; 

if((txt=new char [lgth+1 ] ) == NULL) 

rtlnt=l; // Return 1 if there is not enough memory. 

else 

strcpy (txt, InString.txt) ; // Copy InString txt member to 

// (*this) .txt. 

rtlnt=l; // Return 1 if all is well. 

} 

return (rtlnt) ; 

} 

int String: :FindFirst (const char* pFindSet) const 
{ 


9 



int Location= -1; // Declare and assign Location. 

int SetLgth= (int ) strlen (pFindSet ) ; // Declare and assign 

// SetLgth. 

if (SetLgth > lgth) 

return (Location) ; // Return an error value, 

int i; // Declare a counter, 
int j; // Declare a counter, 
i -= i; // Initialize i to zero, 
j -= j; // Initialize j to zero. 

int LgthLeft= lgth; // Declare and assign LgthLeft. 
int SetLeft= SetLgth; // Declare and assign SetLeft. 
while ( (SetLeft) && (SetLeft <= LgthLeft)) 

{ 

if(txt[i] == pFindSet [j] ) 

{ 

++ j; // Increment j. 

— SetLeft; // Decrement SetLeft. 

} 

else 

{ 

i f ( j > 0) // If there was a previous match, and now a 

{ // mismatch: 

— i; // Decrement i to recompare this char- with 
// FindSet[0]. 

++LgthLeft; //.Increment LgthLeft to reflect the i 
// adjustment. 

} 

j -= j; // Reset j to start comparing FindSet[0]. 
SetLeft= SetLgth; // Reset SetLeft to reflect the j 

// adjustment. 

} 

— LgthLeft; // Decrement LgthLeft. 

++i; // Increment i. 

} // End WHILE ( (j<SetLgth) && (SetLeft<=LgthLeft) ) . 

if (! SetLeft) // If all pFindSet was found: 

Location= i-j; // Compute Location, 
return (Location) ; 


int String: :FindLast (const char* pFindSet) const 

{ 

int Location= -1; // Declare and assign Location. 

int SetLgth= (int ) strlen (pFindSet ) ; // Declare and assign 

// SetLgth. 

if (SetLgth > lgth) 

return (Location) ; // Return an error value. 


10 



int i; // Declare a counter, 
int j; // Declare a counter. 
i= lgth-1; // Initialize i. 
j= SetLgth-1; // Initialize j. 

// Note: j+1 is number of members left in FindSet to match. 

I j i+1 is number of members left in txt to compare to . 

while ((j+1) && ((j+1) <= (i+D)) 

{ if (txt [i] == pFindSet [ j] ) // When FindSet [0] is found, 

/ / done . 

— j; // Decrement j. 
else 

if ( j < (SetLgth-1)) // If there was a previous match, 

// and now a mismatch: 

++i; // Increment i to recompare this char with 

// FindSet [SetLength-1] . 
j= SetLgth-1; // Reset j to start comparing 
// FindSet [SetLength-1] . 

} 

— i; // Decrement i. 

} // End WHILE ( (SetLeft) && (SetLeft<=LgthLeft) ) . 

II if(j == -l), j was decremented below 0, all were 
// found: 

if ( i ++ j) // if all pFindSet was found: 

Location= ++i; // Compute Location, 

return (Location) ; 

} 

int String: :GetLength() const 

{ return (lgth) ; // Return the lgth member instance. 

} 

char* String: :GetTextPtr () const 

return (txt); // Return the txt member. 

} 

String String: :LowerCase () 

int itxt; // int for integer representation of txt members, 
char* pLowTxt; // Pointer to char to hold converted txt. 
pLowTxt= new char [lgth+1]; // Allocate heap for LowTxt. 

for (int i=0; i<lgth; ++i) 

{ 


11 



itxt= (int ) * (txt+i) ; // Convert txt[i] to int. 

if ( (itxt > 64) && (itxt < 91)) // If txt[i] is an upper- 

77 case letter, 

* (pLowTxt+i) = (char) (itxt+32) ; // load the converted 

// letter to LowTxt . 

else // Not an upper-case letter. 

* (pLowTxt+i) = (char) itxt; // Load the char to LowTxt. . 

} 

* (pLowTxt+i) =' \0 ' ; // Explicitly append NULL. 

String RetString; // Declare a String for return. 

RetString . IString (pLowTxt) ; // Invoke RetString. 

delete [] pLowTxt; // Free heap. 

return (RetString); // Return the converted string. 


String String : : Uppercase ( ) 

{ 

int itxt; /7 int for integer representation of txt members, 
char* pUpTxt; // Pointer to char to hold the converted txt. 
pUpTxt= new char [lgth+1]; // Allocate heap for UpTxt . 

for (int i=0; i<lgth; ++i) 

{ 

itxt= (int )* (txt+i) ; // Convert txt[i] to int. 

if ((itxt > 96) && (itxt < 123)) J / If txt[i] is an lower- 

77 case letter, 

*(pUpTxt+i)= (char) (itxt-32) ; // load the converted 

// letter to UpTxt. 
else // Not an lower-case letter. 

*(pUpTxt+i)= (char) itxt; // Load the char to UpTxt. 

} 

* (pUpTxt +i) = ' \0 • ; // Explicitly append NULL. 

String RetString; // Declare a String for return. 

RetString. IString (pUpTxt) ; // Invoke RetString. 

delete [] pUpTxt; // Free heap. 

return (RetString); // Return the converted string. 


String String: :GetChars (int Position, int NumChar) const 

{ 

String RetString; // Declare a String for the return value, 
int Lastlndex= lgth-1; // Determine the last index of txt. 
if ( (Position > Lastlndex) I I (Position < 0) || 

(NumChar <= 0) ) 

return (RetString); // Return the empty String, 
if ( (Position+NumChar-1) > Lastlndex) 

NumChar= lgth-Position; // Adjust NumChar. 


12 



char* pTxt= new char[NumChar + 1]; 
if (pTxt == NULL) 

return (RetString) ; // Return the empty String. 

for (int i= 0; i< NumChar; ++i) 

*(pTxt+i)= txt [i+Position] ; // LoadRetString.txt 

* (pTxt+i) = ’NO'; // Add terminator. 

RetString. IString (pTxt) ; // Invoke RetString. 

delete [] pTxt; // Free heap, 
return (RetString) ; 


i] . 


} 


String String: :GetChars (const char* pChars) const 

{ String RetString; // Declare a String for return. 

int Position= FindFirst (pChars) ; // Find the position, 

int NumChar= strlen (pChars) ; // Determine NumChars . 

RetString= GetChars (Position, NumChar); // Get the chars, 
return (RetString) ; 

} 


String& String :: operator- (const String &s) // Handles 

{ if (this == &s) // Takes care of sl=sl. 

return *this; - , . . 

delete U txt; // Get rid of space allocated to si. txt. 

lcrth= strlen (s .txt) ; , . . 

txt = new char [lgth+1] ; // Dynamically allocate new implicit 

// txt storage space. 

if (txt == NULL) 

cout << "\nMemory exhaustion: String: : operator-, / 

cout " new char . \n ; 

} 

strcpy (txt , s . txt) ; ... . i 

return *this; // Return the implicit String, si. 


Strings String :: operator- (const char *ds) 

{ 

lgth= strlen (ds); 
txt= new char (lgth+1] ; 
if (txt == NULL) 

cout << "NnMemory exhaustion: String: : operator-, , 

cout « " new char.\n”; 

} 


13 


strcpy (txt, ds) ; 
return *this; 


String String: :operator+ (const String &s) const 

{ 

char *bf= new char [lgth+s .lgth+1] ; // Buffer variable to 

// hold text of both 
// implicit and s. 

if (bf == NULL) 

{ 

cout « "XnMemory exhaustion: String: : operator+, 

cout « " new char.Xn"; 

} 

strcpy (bf , txt) ; 
strcat (bf , s . txt) ; 

bf [lgth+s . lgth] = ' \0 ' ; // Terminate bf. 

String rets; // Uses the default constructor, 
int retval; 

if ( ! (retval=rets . IString (bf ) ) ) 

{ 

cout << "\nMemory exhausted at overloaded + for"; 
cout « " Strings. \n"; 

} 

delete [] bf; 
return rets; 


String String: :operator+ (const char &c) const 

{ 

char *bf= new char [lgth +2]; // Buffer to hold both txt 

// and c. 

if (bf == NULL) 

{ 

cout « "XnMemory exhaustion: String: :operator+/ "; 

cout « " new char.Xn"; 

} 

for (int i=0; i< lgth; ++i) 

*(bf+i)= * (txt+i) ; // Assign bf[i], 

*(bf+i)= c; // Assign bf[lgth]; 

*(bf+i+l)= ' X 0 * ; // Terminate bf. 

String retString; 
int retval; 

if ( ! (retval= retString .IString (bf ) ) ) 

{ 

cout << "XnMemory exhaustion in String: :operator+"; 


14 



cout << 


(const chars c) An"; 


\\ 


} 

delete [] bf; // Free heap, 
return (retString) ; 

} 

int String: :CompOr (const char* InCharl, const char* InChar2) 
const 

{ return ( (int) ( (*this == InCharl) II (*this == InChar2))); 

} 

String operator+ (const char *pcl/ const char *pc2) 

{ 

// Determine the string lengths: 
int lenl= strlen(pcl); 
int len2= strlen(pc2); 
char *bf= new char [lenl+len2+l] ; 
if (bf == NULL) 

cout << "\nMemory exhaustion: String: :operator+, , 

cout « " new char An"; 

} 

strcpy (bf,pcl) ; 

strcat (bf , pc2) ; 

String rets; 
int retval; 

if ( ! (retval=rets . IString (bf ) ) ) 

cout « "\nMemory exhausted at overloaded + for"; 
cout « " Strings An"; 

) 

delete [] bf; 
return rets; 

} 

int String :: operator== (const String &s) const 

{ int retval=strcmp (txt, s .txt) ; // Returns 0 if equal, 1 if 

// txt greater, -1 if less. 

if (retval == 0) // If retval is 0, the strings are equal, 

retval=l; //so return (==) = TRUE, 
else // Else, rtval was 1 or -1, 

retval=0; // so return (==) = FALSE, 
return (retval); 


15 


int String: : operator != (const String &s) const 

{ 

int retval=strcmp (txt , s . txt ) ; 

if (retval != 0) // If retval 1 or -1, not equal is true. 

retval=l; // return (!=) = TRUE, 
else // Else, retval was 0, so they are equal... 

retval=0; // return (!=) = FALSE, 
return (retval) ; 


int String :: operator== (const char *ds) const 

{ 

int retval=strcmp (txt, ds) ; 

//cout « "\nThe comparison value was " « retval « "\n" 
if (retval == 0) 
retval=l; 
else 

retval=0; 
return (retval) ; 


int String: : operator != (const char *ds) const 

{ 

int retval=strcmp (txt, ds) ; 
if (retval != 0) 
retval=l; 
else 

retval=0; 
return (retval) ; 


int operator== (char *sl, const String &s2) 

{ 

int retval=strcmp (si, s2 . txt ) ; 
if (retval == 0) 
retval=l; 
else 

retval=0; 
return (retval) ; 


int operator != (char *sl, const String &s2) 

{ 

int retval=strcmp (si, s2 .txt) ; 
if (retval != 0) 


16 



retval=l; 

else 

retval=0; 
return (retval) ; 

} 

int String: :operator> (const String &s) const 

{ 

int cmpv=strcmp (txt/ s .txt) ; 
if(cmpv == 1) 
return (1) ; 
else 

return (0) ; 

} 

int String: :operator< (const String &s) const 

{ 

int cmpv=strcmp (txt, s . txt) ; 

if (cmpv == -1) 
return (1) ; 
else 

return (0) ; 

} 

int operator> (const char *pcl, const char *pc2) 

{ 

int cmpv=strcmp (pcl,pc2) ; 
if (cmpv == 1) 
return (1) ; 
else 

return (0) ; 

} 

int operator< (const char *pcl, const char *pc2) 

{ 

int cmpv=strcmp (pcl,pc2) ; 
if (cmpv == -1) 
return (1); 
else 

return (0) ; 

} 

String: :operator const char* () const 

{ 

return (txt); 

) 


17 



String :: operator char* () const // Overloaded cast operator. 

{ 

return (txt ) ; 

} 

char& String :: operator [ ] (const int Si) const 

{ 

return (txt [i] ) ; 

} 

istreams operator» (istream Sinob, String ss) 

{ 

delete [] s.txt; // Clear out the memory allocated to s. 
char buf[265]; // Create some space with a fixed length, 
inob.getline (buf, 132) ; // Bring whatever is out at the 

// input area (stored in cin, 

// here, inob) into the buffer, 
s . lgth=strlen (buf ) ; // Set lgth from the buffer length. 
s.txt=new char [s . lgth+1 ] ; // Since txt was deleted, it must 

// be reallocated. 

if (s.txt == NULL) 

{ 

cout << "\nMemory exhaustion: String operator>>, 

cout « " new char.\n"; 

} 

strcpy (s . txt, buf ) ; // Load buf into the txt. 

* (s . txt+s . lgth) = 1 \ 0 1 ; // Explicitly append NULL, 

return inob; // The return type is istream. 


ostreams operator« (ostreams otob, const Strings s) 

{ 

otob«s.txt; // Output txt. 
return otob; 


18 



Appendix II 
Complex Class 

Specification 

// complex. h 

// Specification file for class Complex, a complex number 
// structure. 

// Michael B. Lance 

// Lockheed Engineering and Sciences Company 
// Hampton, Virginia 

#ifndef _COMPLEX_H 
♦define _COMPLEX_H 

# include <math.h> 

♦include "mystring .h" 

class Complex 

{ 

public : 

Complex () ; // Constructor; 

Complex (doubles ) ; // Conversion constructor. 

Complex (const ComplexS); // Copy constructor. 

-Complex (); // Destructor. 

int IComplex (double, double, const char*); // Invocator. 
double GetRealO; // Function to return the real part . 
double GetlmagO; // Function to return the imaginary 

// part. 

double GetMagO; // Function to return the magnitude, 
double GetPhsO; // Function to return the phase angle, 
void SetReal (double InReal) ; // Function to set the real 

// part. 

void Setlmag (double Inlmag) ; // Function to set the 

// imaginary part. 

void SetMag (double InMag) ; // Function to set the 

// magnitude. 

void SetPhs (double InPhs) ; // Function to set the phase 

// angle. 

Complex power (double Power); // Function to raise to a 

// power. 


19 



Complex* root (int Root); // Function to return roots, 
void root (Complex *pCRoots, int Root); // Overloaded 

// root function 

Complex operator+ (const Complexs) const; // Overloaded 

// operator + 

Complex operator- (const Complex*;) const; // Overloaded 

// operator - 

Complex operator* (const Complexs) const; // Overloaded 

// *. 

Complex operator* (const doubles) const; // Overloaded 

// operator *. 

Complex operator/ (const Complexs) const; // Overloaded 

// operator / 

Complex operator/ (const doubles) const; // Overloaded 

// operator /. 

Complexs operator= (const Complexs); // Overloaded 

// operator =. 

int operator== (const Complexs) const; // Overloaded 

// operator ==. 

int operator != (const Complexs) const; // Overloaded 

// operator !=. 

void PrintComplex () const; // Print function. 

//_Function to return the complex conjugate: 
void CompCon jugate (const Complexs) ; 

// Overloaded * for "double * Complex" case: 

friend Complex operator* (doubles, Complexs); 

/ / Overloaded operator<< for output of real and imaginary 
// parts: 

friend ostreams operator« (ostreams otop, 

Complexs OtComp) ; 


// Data Members 
public : 

double Real; // Data member Real, 
double Imag; // Data member Imag. 
double Mag; // Data member Mag. 
double Phs; // Data member Phs, radians, 
double PI; // Public data member PI. 

private : 

void RItoMPO; // Function to compute the Mag and Phs 

// from Real and Imag. 

void MPtoRIO; // Function to compute the Real and Imag 


20 



} ; 


// from Mag and Phs. 

void AdjustPhase () ; // Function to remove multiples of 2 

// Pi from phase angles. 


#endif 


21 


Implementation 

// complex. C 

// Specification of class Complex. 

// Michael B. Lance 

// Lockheed Engineering and Sciences Company 
// Hampton, Virginia 

♦include "complex. h" 

Complex : : Complex ( ) 

{ 

Real -= Real; 

Imag -= Imag; 

Mag -= Mag; 

Phs -= Phs; 

PI= 4 . 0*atan (1.0); 

} 

Complex: : Complex (doubles InDouble) 

{ 

Real=InDouble; // Assign Real. 

Imag=0.0; //Assign Imag. 

RItoMPO; // Compute Mag and Phs. 

} 

Complex :: Complex (const Complex SInComplex) 

{ 

Real= InComplex .Real; 

Imag= InComplex . Imag; 

Mag= InComplex .Mag; 

Phs= InComplex . Phs; 

PI= InComplex .PI; 

} 

Complex : : -Complex ( ) 

{ 

} 

void Complex : :AdjustPhase () 

{ 

Phs -= (int) (Phs/ (2.0*PI) ) *2.0*PI; 

} 


22 



void Complex : :MPtoRI 0 

Real=Mag*cos (Phs) ; // Compute Real. 

Imag=Mag*sin (Phs) ; // Compute Imag. 

} 


void Complex : :RItoMP () 

{ Mag=sqrt (Real*Real + Imag*Imag); // Compute Mag. 
if (Real == (double) 0.0) 

Phs= PI/2.0; 


else 

Phs=atan (Imag/Real) ; // Compute Phs. 

if (Real < (double) 0) 

Phs += PI; 

else if (Imag < (double) 0) 


Phs += 2.0 * PI; 
AdjustPhase () ; // 


Remove multiples of 2 Pi from Phs. 


} 


int Complex: : IComplex (double A, double B, const char *RIMP) 

{ String *RIorMP=NULL; // Declare and initialize a String 

// pointer. 

RIorMP=new String; ^ . 

int rtval= RIorMP->IString (RIMP) ; // Invoke RIorMP String. 

if ( ! rtval) // If the String allocation failed, 
return (-1); // return an error, 

if (RIorMP->UpperCase () == (const char*)"RI") 

Real=A; // Assign Real. 

Imag=B; // Assign Imag. 

RItoMPO; // Call function to compute Mag and Phs. 
rtval-1; // Assign rtint 1. 

else if (RIorMP->UpperCase () == (const char*)"MP") 

{ 

Mag=A; // Assign Mag. 

Phs=B; // Assign Phs. 

AdjustPhase () ; // Remove multiples of 2 Pi from Phs. 

MPtoRlO; // Call function to compute Real and Imag. 
rtval=l; // Assign rtint 1. 

} 

cout « "\nImproper option String in IComplex call.\n”; 
delete RIorMP; // Free heap. 


23 


return (rtval) ; 


} 

double Complex: :GetReal () 

{ 

return (Real) ; 

) 

double Complex: : Get Imag () 

{ 

return (Imag) ; 

} 

double Complex : :GetMag () 

{ 

return (Mag) ; 

} 

double Complex: :GetPhs () 

{ 

return (Phs) ; 

} 

void Complex: :SetReal (double InReal) 

{ 

Real= InReal; // Assign Real. 
RItoMPO; // Compute new Mag and Phs. 

} 

void Complex :: Setlmag (double Inlmag) 

{ 

Imag= Inlmag; // Assign Imag. 
RItoMPO; // Compute new Mag and Phs. 


void Complex :: SetMag (double InMag) 

{ 

Mag= InMag; // Assign Mag. 

MPtoRI () ; // Compute new Real and Imag. 


void Complex :: SetPhs (double InPhs) 

{ 

Phs= InPhs; // Assign Phs. 

AdjustPhase () ; // Remove multiples of 2 PI from Phs. 

MPtoRI () ; // Compute new Real and Imag. 


24 



} 


Complex Complex: : power (double Power) 

Complex ReturnComplex; // Declare a return Complex, 
double PowerMag= pow(Mag, Power); // Declare and assign 

// PowerMag. 

double PowerPhs= Power*Phs; // Declare and assign PowerPhs. 
ReturnComplex . IComplex (PowerMag, PowerPhs, 

(const char*) "MP") ; 

return (ReturnComplex) ; 

) 

void Complex :: root (Complex* pCRoots, int Root) 

{ 

// Declare and assign RootMag: 

double RootMag= pow (Mag, (1/ (double) Root) ) ; 
double RootPhs; // Declare RootPhs. 

const char* MP= "MP"; // Declare and assign a descriptor 

// for the invocator. 
int i; // Declare a counter, 
for (i=0; i<Root; ++i) 

{ RootPhs= (Phs + 2.0*PI*i) /Root; // Compute RootPhs. 

// Invoke the i'th array member: 

(pCRoots+i) ->IComplex (RootMag, RootPhs, MP) ; 

} 

} 

Complex Complex: :operator+ (const Complex &InComplex) const 

Complex RetComplex; // Declare a Complex. 

Ret Complex. Real= Real + InComplex .Real; // Compute new 

// Real. 

RetComplex . Imag= Imag + InComplex. Imag; // Compute new 

// Imag. 

RetComplex. RItoMPO ; // Compute new Mag and Phs. 

return (RetComplex) ; 

} 

Complex Complex: : operator- (const Complex &InComplex) const 

{ Complex RetComplex; // Declare a Complex. 

RetComplex . Real= Real - InComplex .Real; // Compute new 

// Real. 

RetComplex. Imag= Imag - InComplex. Imag; // Compute new 


25 


// Imag. 

RetComplex. RIt oMP () ; // Compute new Mag and Phs. 

return (RetComplex) ; 


Complex Complex: : operator* (const Complex &InComplex) const 
{ . 

Complex RetComplex; // Declare a Complex. 

RetComplex.Mag= Mag * InComplex. Mag; // Compute new Mag. 
RetComplex . Phs= Phs + InComplex. Phs; // Compute new Phs. 
RetComplex .Ad justPhase () ; 

RetComplex .MPtoRI () ; // Compute new Real and Imag. 

return (RetComplex) ; 


Complex Complex: : operator* (const double &InDouble) const 
{ 

Complex RetComplex; // Declare a Complex. 

RetComplex .Mag= Mag * InDouble; // Compute new Mag. 
RetComplex. Phs= Phs; // Assign Phs. 

RetComplex .MPtoRI () ; // Compute new Real and Imag. 

return (RetComplex) ; 


Complex Complex :: operator/ (const Complex &InComplex) const 

{ 

Complex RetComplex; // Declare a Complex. 

RetComplex. Mag= Mag / InComplex .Mag; // Compute new Mag. 
RetComplex .Phs= Phs - InComplex. Phs; // Compute new Phs. 
RetComplex .MPtoRI () ; // Compute new Real and Imag. 

return (RetComplex) ; 


Complex Complex: : operator/ (const double &InDouble) const 

{ 

Complex RetComplex; // Declare a Complex. 

RetComplex . Mag= Mag / InDouble; // Compute new Mag. 
RetComplex .Phs= Phs; // Assign Phs. 

RetComplex .MPtoRI () ; // Compute new Real and Imag. 

return (RetComplex) ; 


Complexs Complex: :operator= (const Complex sinComplex) 

{ 

if (this == SlnComplex) // If a case of 'C = C', 
return (*this) ; // return 'C'. 


26 



Real=InComplex .Real; // Assign Real. 

Imag=InComplex. Imag; // Assign Imag. 

Mag=InComplex .Mag; // Assign Mag. 

Phs=InComplex.Phs; // Assign Phs. 
return (*this) ; 

} 

int Complex :: operator== (const Complex SlnComplex) const 

{ int rtint=0; // Declare and initialize a return int. 
if (Real == InComplex .Real) // If Real == Real, 
if (Imag == InComplex. Imag) // check Imag. If 1, 
if (Mag == InComplex .Mag) // check Mag. If 1, 
if (Phs == InComplex. Phs) // check Phs. If 1, 
rtint=l; // numbers are equal, 
return (rtint) ; // Return int. 

} 

int Complex: : operator != (const Complex &InComplex) const 

{ int rtint=0; // Declare and initialize a return int. 
if (Real != InComplex. Real) //If Real != Real, 

if (Imag != InComplex. Imag) // check Imag. If 1, 
if (Mag != InComplex. Mag) // check Mag. If 1, 
if (Phs ! = InComplex. Phs) // check Phs. If 1, 
rtint=l; // numbers are equal, 
return (rtint); // Return int. 

} 

void Complex :: CompCon jugate (const Complex &InComplex) 

{ 

Real= InComplex .Real; // Assign Real. 

Imag= -InComplex . Imag; // Assign Imag. 

RItoMPO; // Compute new Mag and Phs. 

) 

void Complex: :PrintComplex () const - 

{ cout « ” \nAddress " « this « " data:"; 
cout « "\nln RI format : \n" ; 
cout « Real << " + " « Imag « " i\n"; 
cout « "\nln MP format:"; 

cout « "\n" « Mag « " cis " « Phs « " radians"; 
cout « "\n" « Mag « " cis " « Phs*180 . 0/PI; 
cout « " degrees\n" ; 


27 



Complex operator* (double &InDouble, Complex &InComplex) 

{ 

Complex RetComplex; // Declare a Complex. 

RetComplex .Mag= InComplex .Mag * f abs (InDouble) ; // Compute 

// new Mag. 

RetComplex. Phs= InComplex .Phs; // Assign Phs. 

// Check for a negative multiplier: 

if ( (int) (InDouble/f abs (InDouble) ) < 0) // If 

RetComplex. Phs= InComplex .Phs + InComplex. PI; // adjust 

// Phs. 

RetComplex. Ad justPhase () ; // Remove increments of 2 Pi 

// from Phs. 

RetComplex. MPt oRI () ; // Compute new Real and Imag. 

return (RetComplex) ; 

} 

ostreams operator« (ostream& otop, ComplexS OtComp) 

{ 

otop. setf (ios : rshowpos) ; // Make the + print for positive 

// numbers. 

otop « OtComp. Real « " " « OtComp. Imag; 

otop « " i"; 

- return (otop) ; 

} 


28 



Appendix in 
CDatDim Class 

Specification 

// cdatdim.h 

// 

// Specification file for class CDatDim. 

// Michael B. Lance 

// Lockheed Engineering and Sciences Company 
// Hampton, Virginia 

#ifndef _CDATDIM_H 
♦define _CDATDIM_H 

♦ifdef _GNU 

♦include <gnu/fstream.h> 

♦else 

♦include <fstream.h> 

♦endif 

♦include <math.h> 

♦include "mystring.h" 

♦ifndef _PI 
♦define _PI 

♦define Pi (double) (4 . 0 *atan( (double) 1 . 0) ) 

♦endif 

class CDatDim 
{ 

public : 

CDatDim () ; // Constructor. 

-CDatDim (); // Destructor. 

CDatDim (const CDatDim& Orig) ; // Copy constructor, 

int I CDatDim (int Interactive= 0); // Invocator. 

// Function to read input from file: 

void ReadDataDimensional (fstream* File) ; 

// Function to print a file top Header: 

void PrintHeader (int Mode, fstream* pFile) ; 

// Function to save input data to file: 
void SaveData (fstream* File) ; 


29 



// Overloaded assignment operator: 

CDatDim& operator= (const CDatDim& Orig) ; 

// Overloaded output operator: 

friend ostreams operator« (ostreamfi otop, 

CDatDim& OutData) ; 

friend class CClmnData; // Declare class CClmnData to be 

// a friend. 


protected: 

void InPrompt (); // Function to prompt user for input. 

// Function to make a non-shallow copy: 
int MakeCopy (const CDatDimfi Orig) ; 

int AllocateMemory () ; // Function to allocate memory. 


private : 

int NumBlades; // Number of rotor blades. 

int NumModes; // Number of modes of motion to analyze. 

double Radius; // Blade radius, inches. 

double HingeRadius; // Lag-hinge radial station, inches, 
double HingeToCG; // Distance from hinge station to blade 

// center of gravity. 

double BladeWeight; // Blade weight, pounds, 
double PylonWeight; // Support pylon (gimbal) weight, 

// pounds. 

double *pStructK; // Array of NumModes structural spring 

// constants, pound/foot, 
double *pStructB; // Array of NumModes damping 

// coefficients, pound/foot-second, 
double BladeK; // Lag hinge spring constant, 

// foot-pound/radian, 
double BladeB; // Lag damping constant, 

// foot-pound-second/radian. 

String *pOutFileName; // Array of NumModes file names 

// for output. 

String *pModeLabel; // Array of NumModes mode identifier 

// Strings. 


} ; 


#endif 


30 



Implementation 

// cdatdim.C 

// Implementation of class CDatDim. 

// Michael B. Lance 

// Lockheed Engineering and Sciences Company 
// Hampton, Virginia 

♦include "cdatdim.h" 

CDatDim: : CDatDim () 

1 ... 

NumBlades -= NumBlades; // Initialize to zero. 

Radius -= Radius; // Initialize to zero. 

HingeRadius -= HingeRadius; // Initialize to zero. 

HingeToCG -= HingeToCG; // Initialize to zero. 

BladeWeight — BladeWeight; // Initialize to zero. 

PylonWeight -= PylonWeight; // Initialize to zero. 

BladeK -= BladeK; // Initialize to zero. 

BladeB -= BladeB; // Initialize to zero. 

pStructB= NULL; // Point to NULL. 

pStructK= -NULL; // Point to NULL. 

pOutFileName= NULL; // Point to NULL. 

pModeLabel= NULL; // Point to NULL. 

} 

CDatDim: : -CDatDim () 

if(NumModes > 1) 7 / If more than 1 Mode, then arrays 

{ // were allocated. 

delete [] pStructB; // Free array of heap, 
delete [] pStructK; // Free array of heap, 
delete [] pOutFileName; // Free array of heap, 
delete [] pModeLabel; // Free array of heap. 

} 

else 

{ 

delete pStructB; // Free heap, 
delete pStructK; // Free heap, 
delete pOutFileName; // Free heap, 
delete pModeLabel; // Free heap. 

} 

} 


31 



CDatDim: :CDatDim (const CDatDimS Orig) 

{ 

MakeCopy (Orig) ; // Call MakeCopy for a non-shallow copy. 

} 

void CDatDim: : InPrompt () 

{ 

cout « "\nWhat is the number of blades ? "; 
cin » NumBlades; 

cout « "\nWhat is the blade radius (in) ? 
cin » Radius; 

cout « "\nWhat is the radial hinge location (in) ? 
cin » HingeRadius; 

cout « "\nWhat is the distance from the hinge to the"; 
cout « " blade CG (in) ? "; 
cin » HingeToCG; 

cout « "\nWhat is the blade weight in (lb) ? 
cin » BladeWeight; 

cout « "\nWhat is the support pylon weight in (lb) ? "; 
cin » PylonWeight; 

cout « "\nWhat is the blade spring constant"; 
cout << " (ft-lb/radian) ? " ; 
cin » BladeK; 

cout « "\nWhat is the blade damping constant"; 
cout « " (ft-lb-sec/radian) ? 
cin » BladeB; 

cin.getO; // Clear the input buffer. 
for(int i=0; i<NumModes; ++i) 

{ 

cout « "\nFor mode " « i+1 « ":\n”; 

cout « " \nWhat is a descriptive label for this mode ? "; 
cin » * (pModeLabel+i) ; 

cout « "\nWhat is the support spring constant"; 
cout « " (lb/ft) ? " ; 
cin » * (pStructK+i) ; 

cout << " \nWhat is the support damping constant"; 
cout « (lb-sec/ft) ? ”; 
cin » * (pStructB+i) ; 

cin.getO; // Clear the input buffer. 

cout « "\nWhat do you wish to name the analysis results"; 
cout « " output file ? w ; 
cin » * (pOutFileName+i) ; 

} 


void CDatDim: : SaveData (fstream* File) 


32 



{ 

★File « NumModes « "\n"; 

★File « NumBlades « "\n"; 

*File « Radius « "\n M ; 

*File « HingeRadius « ”\n"; 

★File << HingeToCG << " \ n " ; 

★File « BladeWeight « "\n"; 

*File « PylonWeight « "\n"; 

*File « BladeK « "\n"; 

*File « BladeB « "\n"; 
for(int i=0; KNumModes; ++i) 

★File << * (pModeLabel+i) << "\n"; 

*File « * (pStructK+i) « "\n"; 

*File « * (pStructB+i) « "\n"; 

★File << * (pOutFileName+i) << "\n"; 

} 

} 

int CDatDim: :MakeCopy (const CDatDim& Orig) 

NumBlades= Orig. NumBlades; // Assign NumBlades. 

NumModes= Orig. NumModes; // Assign NumModes. 

Radius= Orig .Radius.; // Assign Radius. 

HingeRadius= Orig. HingeRadius; // Assign HingeRadius. 
HingeToCG= Orig. HingeToCG; // Assign HingeToCG. 
BladeWeight= Orig. BladeWeight; // Assign BladeWeight. 
PylonWeight= Orig. PylonWeight ; // Assign PylonWeight. 

BladeK= Orig. BladeK; // Assign BladeK. 

BladeB= Orig. BladeB; // Assign BladeB. 

int NoAlloc= AllocateMemory () ; // Allocate required heap, 

if (NoAlloc) 

return (NoAlloc) ; // Memory allocation error! 

for (int i=0; i<NumModes; ++i) 

★ (pStructB+i) = * (Orig .pStructB+i) ; // Assign StructC[i] 

★ (pStructK+i) = * (Orig. pStructK+i) ; // Assign StructK[i] 

* (pOutFileName+i) = ★ (Orig .pOutFileName+i) ; // Assign 

// OutFileName ( i ] . 

★ (pModeLabel+i) = * (Orig .pModeLabel+i) ; // Assign 

// ModeLabel [i] . 

} 

return (NoAlloc) ; 


void CDatDim: :ReadDataDimensional (fstream *File) 


33 



{ 


♦File » NumBlades; 

♦File » Radius; 

♦File » HingeRadius; 

♦File » HingeToCG; 

♦File » BladeWeight; 

♦File » PylonWeight; 

♦File » BladeK; 

♦File » BladeB; 

File->get(); // Clear the input buffer. 
for(int i=0; i<NumModes; ++i) 

{ 

♦File » * (pModeLabel+i) ; 

♦File » * (pStructK+i) ; 

♦File » * (pStructB+i) ; 

File->get(); // Clear the input buffer. 

♦File » * (pOutFileName+i) ; 

} 

} 

int CDatDim: : AllocateMemory () 

{ 

int NoAlloc= 0; // Declare and assign an int to return the 

// status of the allocation. 

if (NumModes > 1) 

{ 

pModeLabel= new String [NumModes]; // Allocate heap. 
pStructK= new double [NumModes]; // Allocate heap. 
pStructB= new double [NumModes]; // Allocate heap. 
pOutFileName= new String [NumModes]; // Allocate heap. 

} - 

else if (NumModes == 1) 

{ 

pModeLabel= new String; // Allocate heap. 
pStructK= new double; // Allocate heap. 
pStructB= new double; // Allocate heap. 
pOutFileName= new String; // Allocate heap. 

} 

else 

NoAlloc= 1; 

if ( (pModeLabel == NULL) II (pStructK == NULL) || 

(pStructB == NULL) | | (pOutFileName == NULL) ) 

NoAlloc= 1; // There was insufficient memory! 

return (NoAlloc) ; 


34 



int CDatDim : : ICDatDim (int Interactive) 

{ int Change Input = 1; // Declare and initialize an input 

// status flag. 

String EchoChoice; // Declare a String to catch user 

// response. 

String* pDatFileName= new String;. // Declare and allocate 

// a String. 

fstream* pDataFile= new fstream; // Declare and allocate 

//an fstream. 

if ( (pDatFileName == NULL) II (pDataFile == NULL)) 

cout « "\nMemory allocation error !\n"; 

return (1); // Return with a memory allocation error. 

int NoAlloc= 0; // Declare and assign an int to return the 

// status of the allocation. 

if (Interactive) 

cout « "\nWhat is the number of modes to analyze ? 

cin » NumModes; . 

NoAlloc= AllocateMemory () ; // Call the memory allocation 

// function. 


if (NoAlloc) - - , , 

return (NoAlloc) ; // Return with a memory allocation 

// error. 

while (Changelnput) 

{ InPrompt (); // Call the input prompt routine. 

cout << *this; / / Echo the input . . ^ tt 

cout « "\n\nDo you wish to change any input (V’YV, ; 
cout « " ALL inputs must be"; 
cout « " reentered, or \"N\") ? "; 
cin >> EchoChoice; 

EchoChoice= EchoChoice .Uppercase () ; 
if (EchoChoice == (const char*)"N") 

Changelnput -= Changelnput; // Set the flag to 

// terminate the while. 

else if (EchoChoice != (const char*)"Y") 

{ cout « "\n\"" « EchoChoice « "\" improper"; 
cout « " choice !\n"; 

} 

} // End WHILE (Changelnput) . 

cout << " \nWhat do you wish to name the data storage ; 
cout << " file ? "; 


35 


cin » *pDatFileName; 

pDataFile->open ( (const char*) *pDatFileName / ios: :out) ; 
if ( IpDataFile) 

{ 

cout << "\nFile " << *pDatFileName << ":\n"; 
return (1); // Return with a memory allocation error. 

} 


} 

else 

( 

cout « "\nWhat is the name of the input data file ? 
cin » *pDatFileName; 

// Try to open the file: 

pDataFile->open ( (const char* ) *pDatFileName/ ios : : in | 

ios : :nocreate) ; 

if ( ! *pDataFile) 

{ 

cout « "NnFile " « *pDatFileName « ” :\n"; 
return (2); // Return with a memory allocation error. 

} 

*pDataFile >> NumModes; 

NoAlloc= AllocateMemory () ; // Call the memory allocation 

// function. 

if (NoAlloc) 

return (NoAlloc) ; // Return with a memory allocation 

// error. 

ReadDataDimensional (pDataFile) ; // Read the data from 

// file. 

if (pDataFile->bad () ) 

{ 

cout « "\nData file bad ! \n"; 
return (2) ; 

} 

else 

pDataFile->close () / // Close the file, 

while (Changelnput ) 

{ 

cout « *this; // Echo the input. 

cout « "\n\nDo you wish to change any input (\"Y\", 
cout « " ALL inputs must be"; 
cout << " reentered, or \"N\") ? 
cin » EchoChoice; 

EchoChoice= EchoChoice .Uppercase () ; 
if (EchoChoice == (const char*)"N") 

Changelnput -= Changelnput; // Set the flag to 


36 



// terminate the while, 
else if (EchoChoice == (const char*)"Y") 

InPrompt (); // Prompt for new input, 

else 

cout « "\n\"" « EchoChoice « "\" improper"; 
cout « " choice! \n"; 

} 

pDataFile->close () ; // Close the DataFile. 

pDataFile->open ( (const char*) *pDatFileName/ ios: tout I 

ios : tnocreate) ; 

pDataFile->clear () ; // Clear the state of DataFile. 

} 

if (pDataFile->bad() ) 

cout « "\nData file is corrupted or did not open 
properly !\n" ; 

NoAlloc= 2; 

} 

else 

{ 

SaveData (pDataFile) ; 
pDataFile->close () ; 

} 

delete pDatFileName; //'Free heap, 
delete pDataFile; // Free heap. 

return (NoAlloc) ; // Return the memory allocation results. 

} 

CDatDim& CDatDim: :operator= (const CDatDim& Orig) 

{ 

if (this == &Orig) 
return (*this) ; 
else 

MakeCopy (Orig) ; // Call MakeCopy for a non-shallow copy, 

return (*this) ; 

} 

void CDatDim: tPrintHeader (int Mode, fstream *pFile) 

*pFile « "\nNumber of blades: " « NumBlades; 

*pFile « "\nBlade radius: " « Radius « " inches. \n"; 
*pFile « "Radial hinge location: " « HingeRadius; 

*pFile « " inches . \nDistance from the hinge to the blade"; 
*pFile « " CG: " << HingeToCG « " inches. \n"; 


37 


*pFile « "Blade weight: " « BladeWeight « " lbs."; 

*pFile « "\nSupport pylon weight: " « PylonWeight « 

*pFile « " lbs." « "\nBlade spring constant: " « BladeK; 
*pFile « " ft-lb/radian . \nBlade damping constant: "; 

*pFile « BladeB « " ft-lb-sec/radian. \n"; 

*pFile « "\nMode: " « * (pModeLabel+Mode) ; 

*pFile « "\nSupport spring constant: " « * (pStructK+Mode) ; 
*pFile « " lb/ft .\nSupport damping constant: 

*pFile « * (pStructB+Mode) « " lb-sec/ft .\n\n"; 

*pFile « " Complex Frequency"; 

*pFile « " (Hz) \n RPM Real"; 

*pFile « " Imaginary\n"; 


ostreamfi operator^^ (ostream& otop/ CDatDxm& OutData) 

{ 

otop << "\nNumber of blades: " « OutData.NumBlades; 

otop « "\nBlade radius: " « OutData . Radius « " inches."; 

otop « "\nRadial hinge location: " « OutData .HingeRadius; 

otop « " inches. NnDistance from the hinge to the "; 

otop « "blade CG: " « OutData.HingeToCG « " inches."; 

otop « "\nBlade weight: " « OutData. BladeWeight ; 

otop « " lbs . \nSupport pylon weight: "; 

otop « OutData. PylonWeight « " lbs."; 

otop « "\nBlade spring constant: " « OutData. BladeK; 

otop « " ft-lb/radian. \nBlade damping constant: "; 

otop « OutData. BladeB « " ft-lb-sec/radian."; 

for(int i=0; i<OutData .NumModes; ++i) 

{ 

otop « "\n\nFor " << * (OutData. pModeLabel+i) ; 

otop « " mode : \n\nSupport spring constant: "; 

otop « * (OutData. pStructK+i) « " lb/ft."; 

otop « "\nSupport damping constant: "; 

otop « * (OutData. pStructB+i) « " lb-sec/ft."; 

otop « "\nOutput data for this mode will be stored in "; 

otop « "the file \"" « * (OutData.pOutFileName+i) ; 

otop « " \ " . " ; 

) 

otop << "\n"; 
return otop; 


38 



Appendix IV 


CClmnData Class 


Specification 


// cclmndat.h 

// Specification file for class CClmnData. 

// Michael B. Lance 

/ / Lockheed Engineering and Sciences Company 
// Hampton, Virginia 

#ifndef _CCLMNDAT_H 
Idefine _CCLMNDAT_H 

#ifdef _GNU 

linclude <gnu/f stream. h> 

#else 

linclude <fstream.h> 

-#endif 

# include <math.h> 
linclude "mystring.h" 
linclude "cdatdim.h" 


lifndef _PI 
Idefine _PI 

Idefine Pi (double) ( 4 . 0 *atan ( (double) 1 . 0) ) 
lendif 


class CClmnData 

{ 

public : 

CClmnData (); //Constructor. 
-CClmnData () ; // Destructor. . 

CClmnData (const CClmnData& Orig) ; 
int ICClmnData (int CreateMode= 0) ; 
int ICClmnData (CDatDim* pCDatDim) ; 


// Copy constructor. 
// Invocator. 

// Overloaded 
// invocator. 


// Function to provide access to NumModes: 
void SetNumModes (int InNum) ; 

// Function to provide access to non-array members: 


39 



int SetNonArray (int NMod, double BDmp, double BFrq, 

double ARat, double MRat) ; 

// Function to provide access to array members: 

void SetArray(int Ndx, double SFrq, double SDmp, String 
*pOFN/ String *pML, double DC); 

// Function to retrieve a pointer to a specific OutFileName: 
String* GetFileName (int Mode) ; 

// Function to read input data from file: 
void ReadData (fstream* File) ; 

// Function to return the number of modes for analysis: 
int GetNumModes () ; 

// Function to compute the coefficients for the 

// characteristic equation of motion: 

void ComputeCoeff s (double* pCoefs, double *pRpm, 

int *pMode); 

// Function to compute the damping product available: 

double ComputeDampingData (int *pMode, double *pDampAva, 

double *p0mega2) ; 

// Function to compute the RPM-related output: 

double ComputeRpmData (int *pMode, double *pMaxRootRpm) ; 

// Function to coupute the predicted maximum real root: 

double ComputeMaxRoot (int *pMode, double *pMaxRootRpm) ; 

// Overloaded assignment operator: 

CClmnDataS operator= (const CClmnDatai Orig) ; 

// Overloaded output operator: 

friend ostream& operator« (ostream& otop, 

CClmnData &OutData) ; 

protected: 

// Function to prompt user for input of nondimensional data: 
void InPrompt () ; 

// Function to make a non-shallow copy: 
int MakeCopy (const CClmnData& Orig) ; 

// Function to print a Header using nondimensional data: 
void PrintHeader (int Mode, fstream* pFile) ; 

// Function to save input nondimensional data to file: 
void SaveData (fstream *File) ; 

// Function to perform memory allocations: 
int AllocateMemory () ; 

private : 

int NumModes; // Number of modes of motion to analyze, 
double ArmRatio; // Ratio of lag-hinge offset to distance 

// from lag-hinge to blade center of 
// gravity. 

double BladeFreq; // Blade natural frequency in lag. 


40 



double BladeDamp; 


double 

double 

double 

double 

String 

String 

} ; 

tendif 


// Blade lag critical lag damping 
// ratio. 

MassRatio; // Blade mass ratio. 

*pStructFreq; // Array of NumModes structural 

// natural freqencies. 

* p S t r u c t D ampRa t i o ; // Array of NumModes critical 

// damping ratios. 

* pD ampC onversion; // Array of double factors for 

// converting from non- 
// dimensional to dimensional 
// representation. 

* P OutFileName; // Array of NumModes file names 

// for output. 

*pModeLabel; // Array of NumModes mode identifier 
// Strings. 


41 



Implementation 

// cclmndat.C 

// Implementation for class CClmnData. 

// Michael B. Lance 

// Lockheed Engineering and Sciences Company 
// Hampton, Virginia 

♦include "cclmndat .h" 

CClmnData: : CClmnData () 

{ 

NumModes -= NumModes; // Initialize to zero. 

ArmRatio -= ArmRatio; // Initialize to zero. 
BladeFreq -= BladeFreq; // Initialize to zero. 

BladeDamp -= BladeDamp; // Initialize to zero. 

MassRatio -= MassRatio; // Initialize to zero. 

pDampConversion= NULL; // Point to NULL. 
pStructFreq= NULL; // Point to NULL. 
pStructDampRatio= NULL; // Point to NULL. 
pOutFileName= NULL; / / Point to NULL; 
pModeLabel= NULL; // Point to NULL; 

- } . 

CClmnData : : -CClmnData ( ) 

{ 

if (NumModes > 1) // If more than 1 Mode, then arrays 

{ // were allocated. 

delete [] pStructFreq; // Free array of heap, 
delete [] pStructDampRatio; // Free array of heap, 
delete [] pOutFileName; // Free array of heap, 
delete [] pModeLabel; // Free array of heap, 
delete [] pDampConversion; // Free array of heap. 

} 

else 

{ 

delete pStructFreq; // Free heap, 
delete pStructDampRatio; // Free heap, 
delete pOutFileName; // Free heap, 
delete pModeLabel; // Free heap, 
delete pDampConversion; // Free of heap. 

} 

} 


42 



CClmnData: :CClmnData (const CClmnDataS Orig) 

{ MakeCopy (Orig) ; // Call MakeCopy to make a non-shallow 

// copy. 


} 


void. CClmnData: : InPrompt () 

cout « " \nWhat is the blade natural frequency in , 
cout « "lag (Hz) ? 

cin >> BladeFreq; , . . ^ n . 

cout « "\nWhat is the blade lag critical damping ratio . / 

cin » BladeDamp; ^ . . „ . 

cout « " \nWhat is the ratio of lag-hinge-offset to hinge- , 

cout « "to-blade CG distance ? 

cin » ArmRatio; 

cout « "\nWhat is the blade mass ratio ? 
cin » MassRatio; 

cin. get () ; // Clear the input buffer. 

for(int i=0; i<NumModes; ++i) 


cout « "\nFor mode " « i+1 « " :\n"; „ . 

cout « "\nWhat is a descriptive label for this mode . , 

cin » * (pModeLabel+i) ; ft 

cout « "\nWhat is the support structural ^natural ; 

cout « " frequency for this mode (Hz) ? 

cin » * (pStructFreq+i) ; . „ 

cout « "\nWhat is the support structural critical ; 

cout « " damping ratio ? 
cin » * (pStructDampRatio+i) ; 

cin. get () ; // Clear the input buffer.- - _ 

cout « "\nWhat do you wish to name the analysis results 

cout « " output file ? 
c in >> * (pOutFileName+i) ; 

* (pDampConversion+i) = 1.0; // Assign DampConversion . 

} 

cout « " \n" ; 


} 


void CClmnData :: SaveData (f stream *File) 

★Pile << NumModes << "\n”; 

*File << BladeFreq << "\n"; 

★Pile << BladeDamp << "\n"; 

*File << ArmRatio << " \n"; 

★File << MassRatio << "\n"; 


43 



for(int i=0; i<NumModes; ++i) 

{ 

*File « * (pModeLabel+i) « "\n"; 

*File « * (pStructFreq+i) « "\n"; 

*File « * (pStructDampRatio+i) « "\n"; 

*File « * (pOutFileName+i) « "\n"; 

} 

} 

int CClmnData: :AllocateMemory() 

{ 

int NoAlloc= 0; // Declare and assign an int to return the 

// status of the allocation. 

if (NumModes > 1) 

{ 

pModeLabel= new String [NumModes]; // Allocate heap. 
pStructFreq= new double [NumModes]; // Allocate heap. 
pStructDampRatio= new double [NumModes]; // Allocate 

// heap. 

pOutFileName= new String [NumModes]; // Allocate heap. 
pDampConversion= new double [NumModes]; // Allocate heap. 

} 

else if (NumModes == 1) 

{ 

pModeLabel= new String; // Allocate heap. 
pStructFreq= new double; // Allocate heap. 
pStructDampRatio= new double; // Allocate heap. 
pOutFileName= new String; // Allocate heap. 
pDampConversion= new double; // Allocate heap. 

} 

else 

NoAlloc= 1; 

if ( (pModeLabel == NULL) | | (pStructFreq == NULL) I I 

(pStructDampRatio == NULL) | | (pOutFileName == NULL) I I 
(pDampConversion == NULL) ) 

NoAlloc= 1; 
return (NoAlloc) ; 


int CClmnData: :MakeCopy (const CClmnDataS Orig) 

{ 

NumModes= Orig. NumModes; // Assign NumModes. 
ArmRat io= Orig . ArmRatio; // Assign ArmRatio. 
BladeFreq= Orig .BladeFreq; // Assign BladeFreq. 
BladeDamp= Orig.BladeDamp; // Assign BladeDamp. 
MassRatio= Orig .MassRatio; // Assign MassRatio. 


44 



int NoAlloc= AllocateMemory () / . // Allocate required heap. 
if(NoAlloc) 

return (NoAlloc) ; // Memory allocation error, 

for (int i-0; KNumModes; ++i) // Assign array members: 

{ * (pStructFreq+i)= * (Orig.pStructFreq+i) ; 

* (pStructDampRatio+i) = * (Orig.pStructDampRatio+i) ; 

* (pOutFileName+i) ** * (Orig.pOutFileName+i ) , 

* (pModeLabel+i) = * (Orig.pModeLabel+i) ; 

// Assign DampConversion: 

* (pDampConversion+i) = * (Orig.pDampConversion+i) / 

} 

return (NoAlloc) ; 

) 

int CClmnData : : ICClmnData (int CreateMode) 

{ int Changelnput= 1; // Declare and initialize an input 

// status flag. 

String EchoChoice; // Declare a String to catch user 

// response. 

String* P DatFileName= new String; // Declare and allocate 

//a String. 

f stream* pDataFile= new fstream; // Declare and allocate 

//an fstream. 

if ( (pDatFileName == NULL) I I (pDataFile == NULL) ) 

cout << "NnMemory allocation error !\n"; 

return (1); // Return with a memory allocation error. 

int NoAlloc= 0; // Declare and initialize an int to track 

// the tatus of memory allocation, 
if (CreateMode) // If CreateMode is 1, interactive creation 

cout « "\nWhat is the number of modes to analyze ? ; 

cin >> NumModes; „ 

NoAlloc AllocateMemory () ; II Call the memory allocation 

// function. 

if (NoAlloc) // Check the allocation status. 

return (NoAlloc) ; // Memory allocation error! 

while (Changelnput) 

{ inPrompt (); // Call the input prompt routine. 

cout « *this; // Echo the input. _ /VllvV „ „ . 

cout << "\n\nDo you wish to change any input (\ i\ , , 
cout « " ALL inputs must be”; 


45 


cout « " reentered, or \"N\") ? 
cin » EchoChoice; 

EchoChoice= EchoChoice. Uppercase () ; 
if (EchoChoice == (const char*) "N") 

Changelnput -= Changelnput; // Set the flag to 

// terminate the while, 
else if (EchoChoice != (const char*)"Y") 

{ 

cout « "\n\" " « EchoChoice « "\" improper"; 
cout « " choice !\n"; 

} 

) 

cout « "\nWhat do you wish to name the data storage"; 
cout « " file ? "; 
cin » *pDatFileName; 

pDataFile->open ( (const char*) *pDatFileName, ios: rout) ; 

} 

else if ( ICreateMode) // If CreateMode is 0, file input: 

{ 

cout « " \nWhat is the name of the input data file ? "; 
cin » *pDatFileName; 

pDataFile->open ( (const char*) *pDatFileName, 

ios : : in | ios : rnocreate) ; 

// Allocate heap for the fstream and open it. 
if ( ! *pDataFile) 

{ 

cout « "\nFile " « *pDatFileName « " :\n" ; 
return{2); // Return with a memory allocation error. 

} 

*pDataFile >> NumModes; 

NoAlloc= AllocateMemory () ; -// Call the memory allocation 

// function. 

if (NoAlloc) // Check the allocation status. 

return (NoAlloc) ; // Memory allocation error! 

ReadData (pDataFile) ; // Read the data from file, 

if (pDataFile->bad () ) 

{ 

cout « " \nData file bad ! \n"; 
pDataFile->close ( ) ; // Close the data file, 

return (2) ; 

} 

else 

pDataFile->close () ; // Close the data file, 

while (Changelnput) 

{ 

cout << *this; // Echo the input. 


46 



cout « "\n\nDo you wish to change any input (\"Y\" , ; 
cout « " ALL inputs must be"; 
cout « " reentered, or \"N\") ? 
cin » EchoChoice; 

EchoChoice= EchoCho ice. Uppercase () ; 
if (EchoChoice == (const char*)"N") 

Changelnput — = Changelnput; / / Set the flag to 

// terminate the while. 

else if (EchoChoice == (const char*)"Y") 

InPrompt (); // Prompt for new input, 

else 

{ cout « "\n\"" « EchoChoice « "\" improper"; 
cout « " choice !\n"; 

} 

pDataFile->open ( (const char*) *pDatFileName 

ios : : out I ios : :nocreate) ; 

pDataFile->clear () ; // Clear the state of DataFile. 

} 

if (pDataFile->bad ( ) ) 

cout « "\nData file is corrupted or did not open"; 

cout « " properly !\n"; 

delete pDatFileName; // Free heap. 

delete pDataFile; // Free heap. 

return (2) ; 

} 

else 

{ 

SaveData (pDataFile) ; 
pDataFile->close () ; 

} 

delete pDatFileName; // Free heap, 
delete pDataFile; // Free heap. 

f stream* pFile; // Declare a pointer to fstream. 
pFile= new fstream; // Allocate heap, 
if (pFile == NULL) 

return(l); // Return memory allocation error. 
for(int i=0; i< NumModes; ++i) 

{ 

// Assign DampConversion [i] : 

* (pDampConversion+i) = (double) 1.0; 

pFile->open ( (const char*) * (pOutFileName+i) , ios:: out), 
if ( ! *pFile) 

{ 


47 



cout << "File " « * (pOutFileName+i) « ":\n"; 
return (2); // Return file error. 

} 

PrintHeader (i, pFile) ; // Print the header. 

pFile->close () ; // Close the file. 

} 

delete pFile; // Free heap. 

return (NoAlloc) ; // Return the memory allocation status. 


int CClmnData : : ICClmnData (CDatDim* pCDatDim) 

{ 

double Gravity= 32.174; // Declare and assign Gravity. 

// Declare and compute BladeMass: 

double BladeMass= pCDatDim->BladeWeight/Gravity; 

// Declare and compute Bladelnertia: 

double Bladelnertia= BladeMass*pow (pCDatDim- >HingeToCG, 

2.0) /144.0; 

// Compute BladeFreq: 

BladeFreq= sqrt (pCDatDim->BladeK/BladeInertia) ; 

// Compute BladeDamp: 

BladeDamp= pCDatDim->BladeB/ (2 . 0*BladeFreq*BladeInertia) ; 
// Compute ArmRatio: 

ArmRatio= pCDatDim->HingeRadius /pCDatDim- >HingeToCG; 
n Declare and compute PylonMass: 

double PylonMass= pCDatDim->PylonWeight/Gravity; 

// Declare and compute RotorMass: 

double RotorMass= pCDatDim->NumBlades*BladeMass; 

// Declare and compute TotalMass: 

double TotalMass= RotorMass+PylonMass; 

MassRatio= 0 . 5*RotorMass/TotalMass; // Compute MassRatio. 
NumModes= pCDatDim->NumModes; // Assign NumModes. 

// Allocate heap for array members: 
int NoAlloc= AllocateMemory () ; 
if (NoAlloc) 

return (NoAlloc) ; // Return error, 

double SFreq; ' // Declare a holder for StructFreq. 

f stream* pFile; // Declare a pointer to f stream. 
pFile= new f stream; // Allocate heap, 
if (pFile == NULL) 

return (1); // Return error, 

for (int i=0; i<NumModes; ++i) 

{ 

// Compute SFreq: 

SFreq= sqrt (* (pCDatDim->pStructK+i ) /PylonMass) ; 

* (pStructFreq+i) = SFreq; // Assign StructFreq. 


48 



// Compute StructDampRatio: 

* (pStructDampRatio+i) = * (pCDatDim— >pStructB+i) / 

(2 . 0*SFreq*TotalMass) / 

// Compute DampConversion: 

* (pDampConversion+i) = 4 . 0*SFreq*BladeFreq; 

// Assign OutFileName [i] : . 

* (pOutFileName+i) = * (pCDatDim->pOutFileName+i) ; 

// Assign ModeLabel [i] : 

* (pModeLabel+i) = * (pCDatDim->pModeLabel+i) ; 
pFile->open ( (const char*) * (pOutFileName+i) / ios::out); 

if ( ! *pFile) 

cout « "File " « * (pOutFileName+i) « ":\n"; 
return (2); // Return file error. 

pCDatDim- >PrintHeader (i, pFile) ; // Print the header. 

pFile->close () ; // Close the file. 

} 

delete pFile; // Free heap, 
return NoAlloc; // Return NoAlloc. 


int CClmnData : : SetNonArray (int NMod, double BDmp, double BFrq, 

double ARat/ double MRat) 

{ 

NumModes= NMod>* // Assign NumModes. 

BladeDamp= BDmp; // Assign BladeDamp. 

BladeFreq= BFrq; // Assign BladeFreq. 

ArmRatio= ARat; // Assign ArmRatio; 

MassRatio= MRat; // Assign MassRatio. 

int NoAlloc= AllocateMemory () ; // Allocate memory. 

return (NoAlloc) ; 


void CClmnData: : SetArray (int Ndx r double SFrq, double SDmp, 

String *pOFN / String *pML, double DC) 

{ 

* ( P structFreq+Ndx)= SFrq; // Assign StructFreq. 

* (pStructDampRatio+Ndx)= SDmp; // Assign StructDampRatio. 

* ( P OutFileName+Ndx)= * (pOFN+Ndx) ; // Assign OutFileName. 

* (pModeLabel+Ndx) = * (pML+Ndx) ; // Assign ModeLabel. 

* (pDampConversion+Ndx) = DC; // Assign DampConversion. 

) 

String* CClmnData :: GetFileName (int Mode) 

{ 


49 



return (pOutFileName+Mode) ; // Return OutFileName [Mode] . 

} 

void CClmnData : :ReadData (f stream *File) 

{ 

*File » BladeFreq; 

*File » BladeDamp; 

*File » ArmRatio; 

*File » MassRatio; 

File->get(); // Clear the input buffer, 
for (int i=0; i<NumModes; ++i) 

{ 

*File » * (pModeLabel+i) ; 

*File » * (pStructFreq+i) ; 

*File » * (pStructDampRatio+i) ; 

File->get(); // Clear the input buffer. 

*File » * (pOutFileName+i) ; 

} 


int CClmnData : : GetNumModes ( ) 

{ 

return (NumModes) ; 

} 


void CClmnData : :ComputeCoeffs (double* pCoefs, double *pRpm / 

int *pMode) 


{ 


} 


double Omega= *pRpm/60.0; // Convert RPM to Hz. 

double Gamma= sqrt (ArmRatio*Omega*Omega + 

BladeFreq*BladeFreq) ; 

double Whirl= Omega - Gamma; // Compute whirl frequency. 
*(pCoefs+2)= 1.0 + MassRatio*Whirl/ (2 . 0*Gamma) ; 
*(pCoefs+l)= Whirl*Whirl + * (pStructFreq+ *pMode) * 

* (pStructFreq+ *pMode) ; 

* (pCoefs) = Whirl*Whirl * * (pStructFreq+ *pMode) * 

* (pStructFreq+ *pMode) ; 


double CClmnData :: ComputeDampingData (int *pMode, 

double *pDampAva, 
double *pOmega2) 

{ 

*pDampAva= * (pDampConversion+ *pMode) * * (pStructDampRatio+ 
*pMode) *BladeDamp; 

double DampReq= MassRatio* * (pStructFreq+ *pMode) * 


50 



* (pStructFreq+ *pMode) ; 
DampReq /- 8. 0*BladeFreq* (*pOmega2/60.0 - 
* (pStructFreq+ *pMode) ) ; 

/ / Return the converted damping required: 
return (* (pDampConversion+ *pMode) *DampReq) ; 


double CClmnData : : ComputeRpmData (int *pMode, 

double *pMaxRootRprn) 

{ double PredRpmRng= sqrt (2 . 0*MassRatio* (*pMaxRootRpm/60 . 0 

* (pStructFreq+ *pMode) ) ) ; 

PredRpmRng *= * ( P StructFreq+ *pMode) *sqrt <* (pStructFreq+ 

*pMode) ) ; 

PredRpmRng /= *pMaxRootRpm* (1 . 0-ArmRatio) /60 . 0 - 
* (pStructFreq+ *pMode) ; 

return (PredRpmRng* 60 . 0) ; // Return in RPM instead of Hz 

} 

double CClmnData: :ComputeMaxRoot (int *pMode, 

double *pMaxRootRprn) 

double PredMaxRoot= * (pStructFreq+ *pMode) *MassRatio; 
PredMaxRoot /= 8 . 0* (*pMaxRootRpm/60.0 - * (pStructFreq+ 

*pMode) ) ; 

PredMaxRoot= * (pStructFreq+ *pMode) *sqrt (PredMaxRoot) ; 
return (PredMaxRoot) ; 

} 

CClmnData& CClmnData :: operator= (const CClmnData& Orig) 

{ 

if (this == &Orig) 
return (*this) / 
else 

MakeCopy (Orig) ; // Use the copy maker, 

return (*this) ; 

} 

void CClmnData: :PrintHeader (int Mode, fstream* pFile) 

*pFile « "\nBlade natural frequency: " « BladeFreq; 
*pFile « " Hertz . \nBlade lag critical damping ratio: 
*pFile « BladeDamp « " AnRatio of lag-hinge-off set " ; 
*pFile << " to hinge-to-blade CG distance: " << ArmRatio 
*pFile « " .\nBlade mass ratio: " « MassRatio << "An"; 


51 



} 


*pFile « 
*pFile « 
*pFile « 
*pFile « 
*pFile « 
*pFile « 
*pFile « 
*pFile « 


It 


* 

l» 

* 

It 

II 


\nMode : " << * (pModeLabel+Mode) ; 

\nSupport structural natural frequency: 
(pStructFreq+Mode) ; 

Hertz." « "\nSupport critical damping ratio: " 
(pStructDampRatio+Mode) « ",\n\n"; 

Complex Frequency" 


(Hz) \n RPM 


Real 


Imaginary \n"; 


ostreamfi operator« (ostreams otop, CClmnData& OutData) 

{ 

otop « "\nBlade natural frequency: " « OutData .BladeFreq 

otop « " Hertz . \nBlade lag critical damping ratio: "; 

otop « OutData .BladeDamp « " AnRatio of lag-hinge-"; 

otop « "offset to hinge-to-blade CG distance: "; 

otop « OutData .ArmRatio « " AnBlade mass ratio: "; 

otop « OutData .MassRatio « 

for(int i=0; i<OutData .NumModes; ++i) 

{ 

otop « "\n\nFor " « *( OutData. pModeLabel+i) ; 
otop << " mode : \n\nSupport structural natural"; 
otop « " frequency: " « * (OutData. pStructFreq+i) ; 
otop « " Hertz . \nSupport critical damping ratio: "; 
otop « * (OutData .pStructDampRatio+i) « " ."; 
otop « "\nOutput data for this mode will be stored in"; 
otop « " the file \"" « * (OutData. pOutFileName+i) ; 
otop « 

} 

otop « "\n"; 
return otop; 


52 



Appendix V 
CMainData Class 

Specification 

// clmndata.h 

// 

// Header and function specifications for clmncpp.C. 

// Michael B. Lance 

// Lockheed Engineering and Sciences Company 
// Hampton, Virginia 

fifndef _CMAINDATA_H 
#define _CMAINDATA_H 

finclude "cclmndat .h" 
finclude "complex. h” 

class CMainData 

{ 

public: 

CMainData (); // Constructor. 

CMainData (const CMainData& Orig) ; // Copy constructor. 

-CMainData () ; // Destructor, 

int I CMainData () ; // Invocator. 

// Function to find thecomplex roots of the characteristic 

// equation. 

int SolveForRoots (double* pCoefs, Complex* pRoots) ; 

// Function to handle error output. 

// Error codes: 

// 0 - Exit with no error. 

// 1 - Memory allocation error (default) 

// 2 - File open error 

void ErrMsg (int ErrCode= 0); 

void ErrMsg (int ErrCode , const char* pFileName) / 

// Function to print the complex root information: 
void PrintResult (fstream *pOutFile, double Rpm, 

Complex *pRoot) ; 

// Functions to print the RPM range statistics and damping 
// information: 

void PrintDampAnal (fstream *pOutFile, double DampProdA, 

double DampProdR) ; 


53 



void PrintRpmStats (f stream *pOutFile/ double InstRng, 

double PInstRng, double MxRRpm, 
double MxR, double PMxR) ; 

// Function to echo a message in the file: 

void PrintMsg (f stream* pOutFile, const char* pOutMsg) ; 

public : 

long NumRpm; // Number of discreet RPM values, 
double RpmStart; // Starting RPM for analysis, 
double RpmEnd; // Ending RPM for analysis, 
double RpmSpacing; // Resolution of RPM spacing. 
String* pDampUnits; // Units of damping product. 
CClmnData *pCClmnData; // Pointer to CClmnData. 


fendif 


54 



Implementation 

// cmndata.C 

// Implementation of functions for Coleman Analysis code. 


// Michael B. Lance 

// Lockheed Engineering and Sciences Company 
// Hampton, Virginia 

# include <stdlib.h> 

# include "cmndata.h" 
finclude "cdatdim.h" 

f stream *pDbgFile; // Declare a pointer to fstream. 

CMainData : : CMainData ( ) 

NumRpm -= NumRpm; // Initialize to zero. 

RpmStart -= RpmStart; // Initialize to zero. 
RpmEnd -= RpmEnd; // Initialize to zero. 
RpmSpacing -= RpmSpacing; // Initialize to zero. 
pDampUnits= NULL; // Point to NULL. 

P CClmnData= NULL; // Point to NULL. 


CMainData :: CMainData (const CMainDataS Orig) 

{ 

NumRpm= Orig. NumRpm; // Assign Numrpm. 

RpmStart= Orig. RpmStart; // Assign RpmStart. 

RpmEnd= Orig. RpmEnd; // Assign RpmEnd. 

RpmSpacing= Orig .RpmSpacing; // Assign RpmSpacing. 
pDampUnits= new String; // Allocate heap for DampUnits. 
*pDampUnits= *Orig.pDampUnits; // Assign DampUnits. 
pCClmnData= new CClmnData; // Allocate heap for CClmnDat. 
*pCClmnData= *Orig.pCClmnData; // Assign CClmnDat. 

} 

CMainData : : -CMainData ( ) 

{ 

delete pDampUnits; // Free heap, 
delete pCClmnData; // Free heap. 

} 

int CMainData :: ICMainData () 

{ cout « " \nColeman Instability Analysis - C++ Style !\n"; 


55 


String DimFmt; // Declare a String to hold the dimensional 

// format. 

String DataFmt; // Declare a String to hold the data 

// format. 

int ProperFmt; // Declare an int for control of input loop. 
ProperFmt -= ProperFmt; // Set to zero. 

int IMode; // Declare an int to hold the mode argument for 
// data type invocation. 

IMode -= IMode; // Set to zero. 

int GoodExitState; // Declare an int to hold the exit 

// status. 

GoodExitState= 1; // Set GoodExitState true, 

while ( ’ProperFmt) 

{ 

cout « "\nDo you wish to enter your data"; 
cout « " \” I interactively, "; 

cout « " from a \"F\"ile\nor \"E\"xit the program ? ”; 
cin » DataFmt; 

DataFmt= DataFmt .Uppercase () ; 
if (DataFmt == (const char*) "E”) 

{ 

GoodExitState -= GoodExitState; // Set GoodExitState 

// to false. 

ProperFmt= 1; // Set ProperFmt true. 

) 

else if (DataFmt == (const char*) "I") 

{ 

IMode= 1; // Set IMode for interactive input. 

ProperFmt= 1; // Set ProperFmt true. 

} 

else if (DataFmt == (const char*) "F") 

ProperFmt = 1; // Set ProperFmt true, 

else 

{ 

cout << "\n\"" << DataFmt << "\" is not a proper"; 
cout << " response !\n"; 

ProperFmt -= ProperFmt; // Set ProperFmt false. 

} 

) 

if ( ! GoodExitState) 

return (GoodExitState) ; // Return error condition. 

ProperFmt -= ProperFmt; // Set ProperFmt false. 
pDampUnits= new String; // Allocate heap, 
if (pDampUnits == NULL) 

{ 

cout << "\nMemory allocation error !\n"; 


56 



return (-1); // Return memory error. 

pCClmnData= new CClmnData; // Allocate heap for CClmnDat. 

if (pCClmnData == NULL) 

return (-1); // Return memory error, 

int InvRetBad; // Declare an int to catch the returns from 

// invocations. 

InvRetBad -= InvRetBad; / / Set to zero . 
while ( IProperFmt) 

cout « "\nAre your data in \"D\"imensional or \^N\"on-"; 
cout « "dimensional format, \nor do you wish to , 
cout « "\"E\"xit the program ? 
cin » DimFmt; 

DimFmt= DimFmt .Uppercase () ; 
if (DimFmt == (const char*) "E") 

GoodExitState -= GoodExitState; / / Set GoodExitState 

// to false. 

ProperFmt= 1; // Set ProperFmt true, 

else if (DimFmt == (const char*)"D") 

{ CDatDim* pCDatDim; // Declare a pointer to CDatDim. - 
pCDatDim= new CDatDim; // Alocate heap, 
if (pCDatDim == NULL) 

GoodExitState= -1; // Set GoodExitState to memory 

// error state. 

cout « "\nlnsuf f icient memory !\n"; 
break; // Break -the while loop. 

) 

// Invoke CDatDim: 

InvRetBad= pCDatDim->ICDatDim (IMode) ; 
if (InvRetBad) 

GoodExitState= -InvRetBad; // Set the GoodExitState. 
delete pCDatDim; // Free heap, 
break; // Break the while loop. 

} 

// Invoke for a dimensional product: 

InvRetBad= !pDampUnits->IString ( (const char*) " (1/sec) ); 

// Invoke CClmnDat: 

InvRetBad |= pCClmnData->ICClmnData (pCDatDim) ; 
if (InvRetBad) 

{ 


57 



GoodExitState= -InvRetBad; // Set the GoodExitState . 
delete pCDatDim; // Free heap, 
break; // Break the while loop. 

} 

delete pCDatDim; // Free heap. 

*pDampUnits= *pDampUnits + (char) (0xB2); 

ProperFmt= 1; // Set ProperFmt true. 

} 

else if (DimFmt == (const char*)"N") 

{ 

// Invoke for a nondimensional product: 

InvRetBad= !pDampUnits->IString ( (const char*) 

" ") ; 

// Invoke CClmnDat: 

InvRetBad |= pCClmnData->ICClmnData (IMode) ; 
if (InvRetBad) 

GoodExitState= -InvRetBad; // Set the GoodExitState. 
ProperFmt= 1; // Set ProperFmt true. 

} 


else 


{ 

cout « "\n\"" « DimFmt « "\" is not a proper"; 
cout « ” response !\n" ; 

ProperFmt -= ProperFmt; // Set ProperFmt false. _ 

} 

} // End of WHILE (! ProperFmt) . 

if (GoodExitState <= 0) 

return (GoodExitState) ; // Return false. 

ProperFmt -= ProperFmt; // Set ProperFmt false, 
while ( ! ProperFmt) 

{ 

cout « "\nWhat is the starting RPM for the analysis ? "; 
cin » RpmStart; 

cout « "\nWhat is the ending RPM for the analysis ? "; 
cin » RpmEnd; 

cout « "\nWhat RPM resolution for the analysis ? 
cin » RpmSpacing; 

if ( (RpmEnd <= RpmStart) || (RpmSpacing <= 0)) 

{ 

String YorN; // Declare a String to catch a yes or no. 
cout << " \nNegative or zero RPM range or RPM"; 
cout « " resolution !\n"; 

cout « "\nDo you wish to reenter the RPM data"; 

cout << " (\"Y\"es or \"N\"o, No"; 

cout << " will exit the analysis !) ? "; 

int GetRet= cin.getO; // Clear the input buffer. 


58 



cin » YorN; 

YorN= YorN. Uppercase () ; 
if (YorN != (const char*)"Y") 

{ GoodExitState -= GoodExitState; // Set GoodExitState 

// to exit state. 

ProperFmt= 1; // Set ProperFmt true, 

cout << "\nExiting analysis session. \n , 

} 

} 

else 

ProperFmt= 1; // Set ProperFmt true. 

} 

if (GoodExitState <= 0) . 

return (GoodExitState); // Return the error condition. 

// Compute NumRpm: . 

NumRpm= (long) (1.0 + (RpmEnd - RpmStart) /RpmSpacing) ; 
return (GoodExitState); // If all is well, return true :) 


int CMainData: : SolveForRoots (double* pCoefs, Complex* pRoots) 


{ 


double R= -0.5* *(pCoefs+l)/ *(pCoefs+2); // b/2a 
double 1= * (pCoefs+1) * * ( P Coefs + l) - 4.0* * ( P Coefs + 2i 
*pCoefs; // bb-4ac 

if (I < (double) 0.0) // Imaginary root: 

I= sqrt (-1) / (2.0* * (pCoefs+2) ) ; // sqrt (4ac-bb) /2a 

else // All real: 


* 


r= R + sqrt (I) / (2.0* * (pCoefs+2) ) ; // -b/2a + 

// sqrt (bb-4ac) /2a 


1 = 0 . 0 ; 


} 

fifdef DBG 

*pDbgFile « "\nA= " « * (pCoefs+2) « "\nB- 
*pDbgFile « * (pCoefs+1); 

* P DbgFile « "\nC= " « * (pCoefs) « M \nR= " « R; 
* P DbgFile « ”\nl= ” « I « "\n"; 

#endif 

Complex Root; // Declare a temporary Complex. 

Root . IComplex (R, I , (const char*) "RI" ) ; // Invoke Root. 

Root. root (pRoots, 2); // Find the complex square _ roots . 

// Get the absolute value of the real part of the first root 
double AbReal= f abs (pRoots->GetReal () ) ; 

int InstabilityFound; // Declare a flag to set true for 

// instability. 


59 


if (AbReal > 0.00999) 

InstabilityFound= 1; // There is an instability, 

else 

{ 

InstabilityFound -= InstabilityFound; // Set to zero. 
pRoots->SetReal ( (double) 0 . 0) ; // Clear residual value. 

(pRoots+1) ->SetReal ( (double) 0 . 0) ; // Clear residual 

// value. 

> 

return (InstabilityFound) ; 


void CMainData: :ErrMsg (int ErrCode /*= 0 */) 

{ 

switch (ErrCode) 

{ 

case (0) : 
break; 
case (1) : 

{ 

cout « "\nMemory allocation error !\n"; 
break; 

} 

case (2) : 

{ 

cout << "\nError opening file !\n"; 
break; 

} 

default : 

cout « "\nUndef ined error code !\n"; 

} 

} 

void CMainData : :ErrMsg (int ErrCode , const char* pFileName) 

{ 

switch (ErrCode) 

{ 

case (2) : 

{ 

cout << "\nError opening file \"" « pFileName; 

cout << "\" !\n"; 

break; 

} 

default : 

cout << "XnUndefined error code !\n"; 

} 


60 



void CMainData : :PrintResult (f stream *pOutFile, double Rpm, 

Complex *pRoot) 

{ * P OutFile « " " « Rpm « " " « *pRoot « "\n"; 

} 

void CMainData: :PrintDampAnal <f stream *pOutFile, 

double DampProdA, 
double DampProdR) 

{ 

*pOutFile « "\n Damping product / 

*pOutFile « " Minimum damping\n 

*pOutFile « " available ' 

*pOutFile « " product required\n " « DampProdA; 

*pOutFile « " " « *pDampUnits « " 

*pOutFile « DampProdR « " " << *pDampUnits « "\n\n"; 


void CMainData: 


:PrintRpmStats (f stream *pOutFile/ 

double InstRng, double PInstRng/ 
double MxRRpm, double MxR, 
double PMxR) 


*pOutFile « 
*pOutFile « 
*pOutFile << 
*pOutFile « 
*pOutFile << 
*pOutFile << 
*pOutFile << 
*pOutFile << 
*pOutFile << 
*pOutFile << 
*pOutFile << 
*pOutFile « 
*pOutFile << 


"\n 

"Resonance 
"SecondXn Frequency 
" CrossingNn 


Predicted\n 

Resonance 

Frequency 

Range 


/ 

II 


II , 
f 


"Range 
" RPM 


Point\n " 
« PInstRng « " 


« InstRng 


RPM"; 


\n 

" « MxRRpm « " RPM\n" ; 

Predicted 

\n 

Maximum 

Maximum" 

\n 

Real 

Real"; 

\n 

Root 

Root " ; 

\n 11 
Hz\n n 

« MxR « " 
/ 

Hz" « " " « 

PrintMsg (f stream* pOutFile, 

const char* pOutMsg) 


{ 

*pOutFile « pOutMsg « "\n"; 

} 


61 



Appendix VII 

CLMNANAL Application 

// clmncpp.C 

// Coleman Analysis code in C++. 

// Michael B. Lance 

// Lockheed Engineering and Sciences Company 
// Hampton, Virginia 

finclude <stdlib.h> 
finclude <time.h> 
finclude <string.h> 
finclude "cmndata.h" 
finclude "complex. h" 

extern fstream *pDbgFile; // Memory for the pointer is 

// allocated in an include file. 

// Function to extract the name of the executable file: 
void GetExeName (const char* pArgO, String *pExeName) ; 

// Function to echo help and usage: 
void DisplayHelp (String* pExeName) ; 

// Function to give an overview of the code: 
void DisplayOverview (String* pExeName); 

int main(int argc, char** argv) 

{ 


int ShowTime; // Declare a flag to signal time data output. 
ShowTime -= ShowTime; // Initialize to zero. 

String *pExeName; // Declare a String on the stack. 
pExeName= new String; // Allocate heap. 

GetExeName (*argv, pExeName); // Get the name of the 

// executable file. 

String *pArgl; // Declare a String to hold argv[l] . 
pArgl= new String; // Allocate heap. 
pArgl->IString (argv [ 1 ] ) ; // Invoke Argl. 

*pArgl= pArgl->LowerCase ( ) ; // Convert arg[l] to lower 

// case. 

if (argc == 2) 

{ 


62 



if(*pArgl == (const char*) "-h") 

DisplayHelp (pExeName) ; // Echo the help information, 

return (1); // Exit with no error. 

} 

else if (*pArgl == (const char*) n -t") 

ShowTime= 1; // Set the ShowTime flag, 

else if (*pArgl == (const char*) "-o") 

DisplayOverview (pExeName) ; // Echo the help 

// information. 

return (1) ; // Exit with no error. 

} 

else if (*pArgl == (const char*) "-a") 

; // Analysis option - run the code. 

else 

{ ,v „ 

cout « " \nlnvalid argument !\n"; 

DisplayHelp (pExeName) ; // Echo the help information, 

return (0) ; // Exit with error. 

} 

} 

else if (argc >= 1) 

cout << "\nNo arguments or too many arguments ! \n , 
DisplayHelp (pExeName) ; // Echo the help information, 

return (0); // Exit with error. 

} 

delete pExeName; // Free heap, 
delete pArgl; // Free heap. 

time t Time0= time (NULL) ; // Declare and initialize a 

// time_t. 

#ifdef DBG w . 

if ( ( P DbgFile= new fstream) == NULL) // Allocate heap and 

// verify it. 

pCMainData->ErrMsg (1) ; // Call ErrMsg with ErrCode of 1 

return (0); // Return with error. 

} 

// Open DebugOut: 

pDbgFile->open ( (const char*) "DebugOut", ios::out), 

if ( ! *pDbgFile) // If the file failed to open properly: 

{ 

// Call ErrMsg with ErrCode of 2: 

pCMainData->ErrMsg (2, (const char*) "DebugOut ") ; 
return (0) ; // Return with error. 


63 



} 

else 

cout « "\nFile \"DebugOut\" open !\n"; 
fendif 

CMainData *pCMainData; // Declare a pointer to CMainData. 
pCMainData* new CMainData; // Allocate heap, 
if (pCMainData == NULL) 

{ 

cout « "\nFailed to allocate heap for CMainData !\n"; 
#ifdef _DBG 

*pDbgFile « "\nFailed to allocate heap for 
*pDbgFile « "CMainData !\n"; 
pDbgFile->close () ; 

#endif 

return (0); // Return with error. 

} 

cout.setf (ios: :showpoint) ; // Set the output format to 

// show trailing 0's. 

int SetUp= pCMainData->ICMainData () ; // Invoke CMainData. 

if (Setup < 0) 

{ 

pCMainData->ErrMsg (-Setup) ; // Call ErrMsg with proper 

// ErrCode. 

delete pCMainData; // Free heap, 
fifdef _DBG 

*pDbgFile « "\nFailed to set up SMainData !\n"; • 

pDbgFile->close () ; 
fendif 

return (0) ; 

} 

else if (Setup == 0) 

{ 

pCMainData->ErrMsg () ; // Call ErrMsg. 

delete pCMainData; // Free heap, 
cout << "Good bye !\n"; 
fifdef _DBG 

*pDbgFile « "\nUser termination !\n"; 
pDbgFile->close () ; 
fendif 

return (1) ; 

} 

int InstabilityFound; // Flag to signal a real root, 
int RangeStarted; // Flag to signal that the unstable RPM 

// range has been entered, 
double Rpm= (double) 0.0; // RPM tracker. 

// Assign an RPM increment: 


64 



double DelRpm= pCMainData->RpmSpacing/20 . 0; 

double Startlnstability= (double) 0.0; // Start of unstable 

// RPM range. 

double Endlnstability= (double) 0.0; // End of unstable RPM 

// range. 

double PredInstRng= (double) 0.0; // Predicted unstable RPM 

// range. 

double MaxRealRoot= (double) 0.0; // Maximum real root, 

double PredMaxRealRoot= (double) 0.0; // Predicted maxium 

// real root. 

double MaxRootRpm= (double) 0.0; // RPM at which the maxium 

// real root occurs. 

double RootHolder= (double) 0.0; // Temporary holder of 

// Real part of root. 

double *pCoef fArray= NULL; // Pointer to array of 

// coefficients. 

double DampAva= (double) 0.0; // Damping product available, 
double DampReq= (double) 0.0; // Damping product require . 
f stream *pOutFile; // Pointer to the output file. 

Complex *pRoots= NULL; // Pointer to array of Complex 

// roots. 

if ( ( (pCoef f Array= new double [3]) == NULL) II 
( (pRoots= new Complex [2]) == NULL)) 

{ 

pCMainData->ErrMsg (1) ; 

*pDbgFile « "\nFailed to allocate heap for pCoef f Array , 
*pDbgFile « " or pRoots !\n"; 
pDbgFile->close () ; 

#endif 

delete pCMainData; // Free heap, 
return (0) ; 


pOutFile= new fstream; // Allocate heap, 
if (pOutFile == NULL) 


P CMainData->ErrMsg (1) ; // Call ErrMsg with ErrCode of 1 

delete pCMainData; / / Free heap. 


#ifdef DBG . . „ 

*pDbgFile « "\nFailed to allocate heap for pOutFile . \n ; 

pDbgFile->close () ; 

fendif 

return (0); // Exit with false. 


} 

// Output in scientific notation: 

pOutFile->setf (ios: :scientific, ios : : f loatf ield) ; 


65 



// Make +'s show in front of positive numbers: 
pOutFile->setf (ios: :showpos) ; 

pOutFile->precision (4) ; // Set the number of digits after 

// radix to 4. 

String FileName; // Declare a String to hold OutFileName. 
time_t Timel=* time (NULL) ; // Declare and initialize a 

// second time_t. 

for(int i=0; i< pCMainData->pCClmnData->GetNumModes () ; ++i) 

{ 

FileName® *pCMainData->pCClmnData->GetFileName (i) ; 
pOutFile->open ( (const char*) FileName, 

ios : : app | ios : rnocreate) ; 

if ( I *pOutFile) 

{ 

pCMainData->ErrMsg (2, FileName); // Call ErrMsg. 

#ifdef _DBG 

*pDbgFile « "\nFailed to properly open 
*pDbgFile << FileName « "\" !\n"; 
pDbgFile->close () ; 
lendif 

break; 

} 

Rpm® pCMainData->RpmStart; // Initialize RPM. 
Startlnstability -= Startlnstability; // Initialize to 

// zero. 

RangeStarted -= RangeStarted; // Unset RangeStarted. 

// While the Rpm is in range: 

while (Rpm < pCMainData->RpmEnd+DelRpm) 

{ 

pCMainData->pCClmnData->ComputeCoeffs (pCoeff Array, 

&Rpm, &i) ; 

#ifdef _DBG 

*pDbgFile « "\nRpm= " « Rpm; 

#endif 

InstabilityFound= pCMainData-SolveForRoots (pCoef fArray, 

pRoots) ; 

if (InstabilityFound) 

{ 

Endlnstability= Rpm; // Assign Endlnstability . 
if ( ! RangeStarted) 

{ 

Startlnstability= Rpm; // Assign Startlnstability. 
// Assign KaxRealRoot : 

MaxRealRoot= pRoots->GetReal () ; 

KaxRootRpm= Rpm; // Assign MaxRootRpm; 


66 



RangeStarted= 1; // Set RangeStarted. 

} 

else 

RootHolder= pRoots->GetReal () ; // Store real part 

.// of root. 

if (RootHolder > MaxRealRoot) 

{ 

MaxRealRoot= RootHolder; / / Re-assign 

// MaxRealRoot. 

MaxRootRpm= Rpm; // Re - assign MaxRootRpni. 

} 

} 

// Print the results: 

pCMainData->PrintResult (pOutFile, Rpm, pRoots) ; 

else if ( ( (int) (Rpm/pCMainData->RpmSpacing) *pCMainData- 
RpmSpacing) == Rpm) 

// Print the results: 

pCMainData->PrintResult (pOutFile, Rpm, pRoots); 
else if ( (Rpm == pCMainData->RpmEnd) I I 
(Rpm == pCMainData->RpmStart) ) 

// Print the results :- 

pCMainData->PrintResult (pOutFile, Rpm, pRoots); 

Rpm += DelRpm; // Increment RPM. 

} // End WHILE (Rpm < pCMainData->RpmEnd+DelRpm) . 

if (RangeStarted) // If an unstable range was encountered 

{ 

DampReq= pCMainData->pCClmnData- 

ComputeDampingData (&i, &DampAva, &MaxRootRpm) ; 
P CMainData->PrintDampAnal (pOutFile, DampAva, DampReq) ; 
// Print damping information: 

PredInstRng= pCMainData->pCClmnData- 

ComputeRpmData (&i, &MaxRootRpm) ; 
PredMaxRealRoot= pCMainData->pCClmnData- 

ComputeMaxRoot (&i, &MaxRootRpm) ; 
pCMainData->PrintRpmStats (pOutFile, (Endlnstability- 

St art Inst ability) , 
PredlnstRng, MaxRootRpm, 
MaxRealRoot, PredMaxRealRoot ) 

} 

else 

pCMainData->PrintMsg (pOutFile, (const char*) 

"\nNo instability found !"); 
pOutFile->close () ; // Close OutFile[i]. 

} // End FOR (i< pCMainData->pDatNonDim->GetNumModes () ) . 


67 



delete pOutFile; // Free heap, 
delete [] pCoeff Array; // Free heap, 
delete [] pRoots; // Free heap, 
delete pCMainData; // Free heap, 
cout « "\nColeman Analysis complete !\n"; 
tifdef _DBG 

*pDbgFile « "\nReached end of .C file !\n"; 
pDbgFile->close () ; 

#endif 

time_t Time2= time (NULL) ; // Declare and initialize a 

// time_t. 

if (ShowTime) 

{ 

cout « "\nData entry time: " « difftime (Timel, TimeO) ; 
cout « " seconds . \n" ; 

cout « "Computation time: " « difftime (Time2, Timel); 

cout « " seconds. \n"; 

cout « "Total elapsed time: "; 

cout « difftime (time (NULL) , TimeO) « " seconds. \n"; 

} 

return (1) ; 


void GetExeName (const char* pArgO, String *pExeName) 

{ 

int LenArgO= strlen (pArgO)'; // 'Determine the lenght of the 

// string. 

String SrchString; // Declare a String on the stack. 
SrchString. IString (pArgO) ; // Invoke SrchString. 

// Find the last "\": 

int Slashlndex= SrchSt ring. FindLast ( (const char*)"\\"); 
if (Slashlndex < 0) // If did not find \, look for /. 

Slashlndex= SrchString. FindLast ( (const char*) "/") ; 

// Find the last 

int DotIndex= SrchString. FindLast ( (const char*)"."); 
if (Dotlndex < 0) // Command does not have a . in the name. 
DotIndex= LenArgO; // The . would be after the end of 

// argO. 

int Startlndex= Slashlndex+l; // Compute the start index 

// of the command. 

int NumChar= Dot Index-Start Index; // Determine length of 

// executable name. 

// Get the executable name text: 

*pExeName= SrchString . GetChars (Startlndex, NumChar) ; 


68 



void DisplayHelp (String* pExeName) 

cout « "\nWelcome to the Coleman Analysis program ! \n , 

cout « "\nCopy right 1996"; . 

cout « "\nMichael B. Lance NnLockheed Engineering 

cout « " Sciences CompanyNn"; 

cout « "Hampton, VirginiaXn".; 

cout « "\nThe usage of this program is:\n\n 

cout « *pExeName « " [-h/H] [-o/O] [-a/A] [-t/T]\n\n , 

cout « " -h: Display this help file.\n"; 

cout « "\n -a: Run the analysis . \n”; 

cout « "\n -t: Run the analysis and display time"; 

cout « n statistics."; 

cout « "\n These statistics are: "; 

cout « "\n Time elapsed for data entry."; 

cout « "\n Time elapsed for computations."; 

cout « "\n Total time elapsed. \n"; 

cout « "\n -o: Display an overview of the"; 

cout « " program. \n\n”; 


void DisplayOverview (String* pExeName) 

cout « "AnWelcome to the Coleman Analysis program !\n , 
cout « "\nCopyright 1996"; 

cout « "\nMichael B. LanceXnLockheed Engineering &"; 
cout « " Sciences CompanyNn"; 
cout « "Hampton, VirginiaNn"; 

cout « "\nThis is a brief overview of " « *pExeName; 
cout « " and how to run it. \n" (Enter to continue) , 
int GetRet; // Declare an int to catch input chars, 
while ( (GetRet= cin.getO) != 10); // Wait for \n. 

cout « "\nHistory :\n"; ( 

cout « "This program is an adaptation of the theory of , 
cout « " Robert P. Coleman andNnArnold M. Feingold as"; 
cout << " presented in NACA Report 1351, 1958. ThisNn , 
cout « "theory provided a method for the analysis of , 
cout « " multiple-bladed rotorNnsystems to determine , 
cout « " the system susceptibility to ground resonance. 
cout << " Their \ntreatment also provided a simple means ; 
cout « " for determining the required\nproduct of rotor"; 
cout << " and chassis damping factors to suppress the' ; 
cout « " resonance. \nThis C++ program is based on a"; 
cout << " FORTRAN 77 version of a similar code . \n" ; 
cout « "The FORTRAN 77 code was converted by the author"; 
cout « " from a FORTRAN 4 code written by Carl Freeman. \n"; 


69 



cout « "(Enter to continue)"; 

while ( (GetRet= cin.getO) != 10); // Wait for \n. 

cout « "\nHow to run " « *pExeName « ":\n"; 
cout « *pExeName « " can be run with interactive input"; 
cout « " or with data from a file.NnThese data can be"; 
cout « " in a dimensional format (inches, pounds, etc.),"; 
cout « " or the\nappropriate non-dimensional format"; 
cout « * (length ratios, mass ratios, etc.).\n"; 
cout « " Dimensional data required/file format :\n"; 
cout « " Number of modes to analyze\n Number of"; 
cout « " blades. \n Rotor radius (in)\n Hinge"; 
cout « " radial station (in) \n Blade radius of "; 
cout « "gyration (in) \n Blade weight (lb) \n Pylon"; 
cout « " weight (lb) \n Lag hinge radial spring"; 
cout « " constant (ft-lb/rad) \n Lag hinge radial"; 
cout « " damping constant (ft-lb-sec/rad) \n"; 
cout « " For each mode:\n Descriptive mode label"; 

cout « " string\n Pylon spring constant (lb/ft) \n;" 

cout « " Pylon damping constant (lb-sec/ft) \n"; 

cout « " Name of file to store results for this"; 

cout « " mode\n (Enter to continue)"; 
while ( (GetRet= cin.getO) != 10); // Wait for \n. 

cout « " Non-dimensional data required/file format :\n"; 
-cout « " Number of modes to analyze\n Blade "; 
cout « "lead/lag natural frequency (Hz)\n Blade"; 
cout « " lead/ lag critical damping ratio\n Ratio of"; 
cout « " lead/ lag hinge radial location to the blade"; 
cout « " radius of gyration. \n One-half the ratio "; 
cout « "of the sum of the rotor blade masses to the sum"; 
cout « " of blade\n masses and pylon mass\n For"; 
cout « " each mode:\n Descriptive mode label"; 

cout « " string\n Pylon natural frequency (Hz)\n"; 

cout « " Pylon critical damping ratio\n Name"; 

cour « " of file to store results for this mode\n\n"; 
cout « *pExeName « " will prompt for the rpm at which"; 
cout « " to start the analysis, the rpm\nat which to"; 
cout « " end the analysis, and the rpm increment to"; 
cout « " use when displaying \nthe results . \nNOTE : "; 

cout « "If an instability is encountered, results "; 
cout « "will be\ndisplayed at 20 times this frequency !\n"; 


70 




REPORT DOCUMENTATION PAGE 

Form Approved 

OMB No. 0704-0188 

Publio wportmg burden tor this edhation of inlorm*ion * — timwd to iMragi 1 hour per response, mduding ttw tone lor reviewing instructions, leeching seeling d*a sources. 

Highway. Suite 12D4, Arlington. VA 22200-4302. end to the Office of Menegemert end Budget Paperwork Reduction Prefect (0704-01M), Washington. DC 20603 

1. AGENCY USE ONLY ( Leave blank) 2. REPORT DATE 3. REPORT TYPE AND DATES COVERED 

August 1996 Contractor Report 

4. TITLE AND SUBTITLE 

CLMNANAL: A C++ Program for Application of the Coleman 
Stability Analysis to Rotorcraft 

5. FUNDING NUMBERS 

C NAS1-19000 
WU 505-63-36-12 

6. AUTHOR(S) 

Michael B. Lance 

7. PERFORMING ORGANIZATION NAME(S) AND ADDRESSES) 

Lockheed Martin Engineering & Sciences Company 
144 Research Drive 
Hampton, VA 23666 

8. PERFORMING ORGANIZATION 
REPORT NUMBER 

9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

National Aeronautics and Space Administration 
Langley Research Center 
Hampton, VA 23681-0001 

10. SPONSORING/MONITORING 
AGENCY REPORT NUMBER 

NASA CR-201592 

11. SUPPLEMENTARY NOTES 

Langley Technical Monitor: Susan A. Gorton 

12a. DISTRIBUTION/AVAILABILITY STATEMENT 

Unclassified Unlimited 
Subject Category 01 

12b, DISTRIBUTION CODE 

13. ABSTRACT ( Maximum 200 words) 

This program is an adaptation of the theory of Robert P. Coleman and Arnold M. Feingold as 
presented in NACA Report 1351, 1958. This theory provided a method for the analysis of 
multiple-bladed rotor systems to determine the system susceptibility to ground resonance. Their 
treatment also provided a simple means for determining the required product of rotor and chassis 
damping factors to suppress the resonance. This C++ program is based on a FORTRAN 77 
version of a similar code. 

14. SUBJECT TERMS 

Ground Resonance, Rotorcraft, Multiple-Bladed Rotor Systems 

15. NUMBER OF PAGES 

71 

16. PRICE CODE 

A04 

17, SECURITY CLASSIFICATION 
OF REPORT 

Unclassified 

18. SECURITY CLASSIFICATION 
OF THIS PAGE 

Unclassified 

19. SECURITY CLASSIFICATION 
OF ABSTRACT 

Unclassified 

20. LIMITATION OF ABSTRACT 


NSN 7540-01-280-5500 Standard Form 298 (Rev. 2-89) 


Prescribed by ANSI Sid. 239-18 


296-102 





















