[Report documentation page 


Form Approved 


0MB No. 0704-0188 


Public reporting burden for this collection of information is estimated to average 1 hour per response, including the time for reviewing instructions, searching existing data 
sources, gathering and maintaining the data needed, and reviewing the collection of information. Send comments regading this burden, to Washington Headquarters Service, 
Directorate for Information Operations and Reports, 1215 Jefferson Davis Highway, Suite 1204, Arlington, VA 22202-4302, and to the Office of Information and Regulatory 
Affairs, Office of Management and Budget, Washington, DC 20503. 


1. AGENCY USE ONLY (Leave blank) 


2. REPORT DATE 

March 28, 1995 


3. REPORT TYPE AND DATES COVERED 


4. TITLE AND SUBTITLE: 

Ada Compiler Validation Summary Report, VC# 950303S1.11381 

Digital Equipment Corporation -- Compiler Name: DEC Ada for OpenVMS Alpha 

Systems, Version 3.2 


6. AUTHOR(S) 

Software Standards Validation Group 


7. PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 255, Room A266 
Gaithersburg, MD 20899 


9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 
Ada Joint Program Office, Defense Information System Agency 
Code JEXCJ, 701 S. Courthouse Rd., Arlington, VA 
22204-2199 


11. SUPPLEMENTARY NOTES 


5. FUNDING NUMBERS 



8. PERFORMING ORGANIZATION 
REPORT NUMBER 


10. SPONSORING/MONITORING 
AGENCY REPORT NUMBER 


19950428 068 


12a. DISTRIBUTION/AVAILABILITY STATEMENT 


Approved for public release; Distribution is unlimited. 


12b. DISTRIBUTION CODE 


13. ABSTRACT (Maximum 200 words) 

This Ada implementation was tested and determined to pass ACVC 1.11. Testing was completed on March 3, 1995. 

Host Computer System: DEC 3000 Model 400 AXP Workstation under OpenVMS Alpha Operating System, Version 6.1 
Target Computer System: DEC 3000 Model 400 AXP Workstation under OpenVMS Alpha Operating System, Version 6.1 


14. SUBJECT TERMS ''5- NUMBER OF PAGES 

Ada Programming Language, Ada Compiler Validation Summary Report, Ada Compiler 76 
Validation Capability, Validation Testing, Ada Validation Office, Ada Validation Facility, le. PRICE 
ANSI/MIL-STD-1815A, Ada Joint Program Office 


OF REPORT 

UNCLASSIFIED 


18. SECURITY CLASSIFICATION 

19. SECURITY CLASSIFICATION 

OF THIS PAGE 

OF ABSTRACT 

UNCLASSIFIED 

UNCLASSIFIED 


UNCLASSIFIED 

















DICLAIMEI NOTICE 



TfflS DOCUMENT IS BEST 
QUALITY AVAILABLE. THE COPY 
FURNISHED TO DTIC CONTAINED 
A SIGNraCANT NUMBER OF 
PAGES WHICH DO NOT 
REPRODUCE LEGIBLY. 



AVF Control Number: NIST94DEC502_2_1.11 
DATE COMPLETED 

BEFORE ON-SITE: 95-02-23 
AFTER ON-SITE: 95-03-06 
REVISIONS: 95-03-28 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Number: 950303S1.11381 
Digital Equipment Corporation 
DEC Ada for OpenVMS Alpha Systems, Version 3.2 
DEC 3000 Model 400 AXP Workstation => 

DEC 3000 Model 400 AXP Workstation 


Prepared By: 

Software Standards Validation Group 
Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 


AVF Control Number: NIST94DEC502_2_1.11 
Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on March 3, 1995. 

Compiler Name and Version: DEC Ada for OpenVMS Alpha Systems, 

Version 3.2 

Host Computer System: DEC 3000 Model 400 AXP Workstation under 

OpenVMS Alpha Operating System, Version 

6.1 

Target Computer System: DEC 3000 Model 400 AXP Workstation under 

OpenVMS Alpha Operating System, Version 

6.1 

See section 3.1 for any additional information about the testing 
environment. 

As a result of this validation effort. Validation Certificate 
950303S1.11381 is awarded to Digital Equipment Corporation. This 
certificate expires March 31, 1998. 


This report has been reviewed and is approved. 


Ada Validatio^^adpRty Ada Validatioi^acility 

Dr. David K. Jefferson Mr. L. Arnold^ohnson 

Chief, Information Systems Manager, Sof-^are Standards 

Engineering Division (ISED) Validation Group 

Computer Systems Laboratory (CSL) 

National Institute of Standards and Technology 
’ Building 225, Room A266 
Gaithersburg MJl—20899 

_ Jn 


Ada Valiirat'ion^ Organization 
Directoi^/pomputer & Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 


^^nald Jr" Reifer 
Chief/^Ada Joint Program Office 
Defense Information Systems Agency 
Center for Software 
Washington DC 20301 


U.S.A. 


Declaration of Conformance 


t 

The following declaration of conformance was supplied by the customer. 


Customer! Digital Kguipment Corporation 

Certificate Awaraee; Digital Equipment Corporation 

Ada Validation Facility; 

National Institute of Standards and Technology 

Computer Systems Laboratory (CSL) 

S:)ftware Validation Group 
Building 225, Room A266 
Gaithersburg, Maryland 20899 

ACVC Version; 1.11 

Ada Implementation; 

Compiler Name and Version; 

DEC Ada Version 3.2 for OpenVMS Alpha Systems 

Host Computer System: 

DEC 3000 Model 400 AXP Workstation, 

under OpenVMS Alpha Operating System Version 6.1. 


Target Computer System; 

DEC 3000 Model 400 AXP Workstation, 

under OpenVMS Alpha Operating System Version 6.1. 


Declaration; 

I, the undersigned, declare that I have no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STD-1815A ISO 8652 1987 
in the implementation listed above. 


C l\/\ \ U-:! /Ql "'Cr ! (C- 

Customer Signature 
Charles McCutcheon 
Project Leader 

Digital Equipment Corporation 


1 7: A; - L \ r ( ^ < c Cfi/J'K 

Certificate Awardee Signature 
Charles McCutcheon 
Project Leader 

Digital Equipment Corporation 



Date 



Date 


Aeeesslca for 


RTIS GRAa;I 


miC TAB 

□ 

Unannounced 
Just.li’icat ion_ 

□ 

Bv.. _ ... 

Distributloo/ , 


Availability C 

Odes 





TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-1 

1.3 ACVC TEST CLASSES...1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2 IMPLEMENTATION DEPENDENCIES 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS. 2-1 

2.3 TEST MODIFICATIONS.2-4 

CHAPTER 3 PROCESSING INFORMATION 

3.1 TESTING ENVIRONMENT.3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A MACRO PARAMETERS 

APPENDIX B COMPILATION SYSTEM OPTIONS 


APPENDIX C APPENDIX F OF THE Ada STANDARD 












CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro92] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to [Pro92]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89], 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552). The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 


1.2 REFERENCES 

[Ada82] Reference Manual for the Ada Programming Language , 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 


1-1 


[Pro92] Ada Compiler Validation Procedures , Version 3.1, Ada Joint 
Program Office, August 1992. 

[UG89] Ada Compiler Validation Capability User's Guide , 21 June 
1989 . 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK_FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is 
compiled and the resulting compilation listing is examined to 
verify that all violations of the Ada Standard are detected. Some 
of the class B tests contain legal Ada code which must not be 
flagged illegal by the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values — for example, the 
largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation—dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 


1-2 


For each Ac'’.a implementation, a customized test suite is produced by 
the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [UG89]). 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler The software and any needed hardware that 

have to be added to a given host and 
target computer system to allow 
transformation of Ada programs into 
executable form and execution thereof. 


Ada Compiler 
Validation 
Capability (ACVC) 


The means for testing compliance of Ada 
implementations. Validation consisting of 
the test suite, the support programs, the 
ACVC Capability User's Guide and the 
template for the validation summary (ACVC) 
report. 


Ada Implementation An Ada compiler with its host computer 

system and its target computer system. 


Ada Joint Program 
Office (AJPO) 


Ada Validation 
Facility (AVF) 


Ada Validation 
Organization (AVO) 


Compliance of an 
Ada Implementation 


The part of the certification body which 
provides policy and guidance for the Ada 
certification Office system. 

The part of the certification body which 
carries out the procedures required to 
establish the compliance of an Ada 
implementation. 

The part of the certification body that 
provides technical guidance for operations 
of the Ada certification system. 

The ability of the implementation to pass 
an ACVC version. 


1-3 


Computer System 


Conformity 


Customer 


Declaration of 
Conformance 


Host Computer 
System 


Inapplicable Test 


ISO 

LRM 


Operating System 


A functional unit, consisting of one or 
more computers and associated software, 
that uses common storage for all or part 
of a program and also for all or part of 
the data necessary for the execution of 
the program; executes user- written or 
user-designated programs; performs 
user-designated data manipulation, 
including arithmetic operations and logic 
operations; and that can execute progra^iis 
that modify themselves during execution. A 
computer system may be a stand-alone unit 
or may consist of several inter-connected 
units. 

Fulfillment by a product, process, or 
service of all requirements specified. 

An individual or corporate entity who 
enters into an agreement with an AVF which 
specifies the terms and conditions for AVF 
services (of any kind) to be performed. 

A formal statement from a customer 
assuring that conformity is realized or 
attainable on the Ada implementation for 
which validation status is realized. 

A computer system where Ada source 
programs are transformed into executable 
form. 

A test that contains one or more test 
objectives found to be irrelevant for the 
given Ada implementation. 

International Organization for 
Standardization. 

The Ada standard, or Language Reference 
Manual, published as 
ANSI/MIL-STD-1815A-1983 and ISO 8652-1987. 
Citations from the LRM take che form 
"<section>.<subsection>:<paragraph>." 

Software that controls the execution of 
programs and that provides services such 
as resource allocation, scheduling, 
input/output control, and data management. 
Usually, operating systems are 
predominantly software, but partial or 
complete hardware implementations are 
possible. 


1-4 


Target Computer 
System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 


Validation 


Withdrawn Test 


A computer system where the executable 
form of Ada programs are executed. 

The compiler of a validated Ada 
implementation- 

An Ada implementation that has been 
validated successfully either by AVF 
testing or by registration [Pro92]. 

The process of checking the conformity of 
an Ada compiler to the Ada programming 
language and of issuing a certificate for 
this implementation. 

A test found to be incorrect and not used 
in conformity testing. A test may be 
incorrect because it has an invalid test 
objective, fails to meet its test 
objective, or contains erroneous or 
illegal use of the Ada programming 
language. 


1-5 


CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 


Some tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 104 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 93-11-22. 


B27005A 

E28005C 

B28006C 

C32203A 

C34006D 

C35507K 

C35507L 

C35507N 

C355070 

C35507P 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

C37310A 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A54B02A 

C55B06A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3814A 

CE3412B 

CE3902B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 


2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Commentaries and commonly referenced in 
the format Al-ddddd. For this implementation, the following tests 
were determined to be inapplicable for the reasons indicated; 
references to Ada Commentaries are included as appropriate. 

The following 198 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 


C24113L..V (11 tests) 
C35706L..Y (14 tests) 


2-1 


C35705L..Y (14 tests) 
C35707L..Y (14 tests) 


C35708L..Y 
C45241L..Y 
C45421L..Y 
C45524L..Z 
C4'^641L. . Y 


(14 tests) 
(14 tests) 
(14 tests) 
(15 tests) 
(14 tests) 


C35802L..Z 
C45321L..Y 
C45521L..Z 
C45621L..Z 
C46012L..Z 


(15 tests) 
(14 tests) 
(15 tests) 
(15 tests) 
(15 tests) 


C24113W..Y (3 tests) contain lines that exceed this 

implementation's maximum input-line length of 255 characters. 

C35713B, C45423B, B86001T, and C86006H check for the predefined 

type SHORT_FLOA'r, for this implementation, there is no such type. 


C45531M..P and C45532M..P (8 tests) check fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for 
this implementation, MAX_MANTISSA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLOWS is FALSE for floating point types and the results 
of various floating-point operations lie outside the range of the 
base type; for this implementation, MACHINE_OVERFLOWS is TRUE. 


B86001Y uses the name of a predefined fixed-point type other than 
type DURATION; for this implementation, there is no such type. 


B91001H checks that an address clause may not precede an entry 
declaration; this implementation does not support address clauses 
for entries. (See section 2.3.) 

C96005B uses values of type DURATION'S base type that are outside 
the range of type DURATION; for this implementation, the ranges are 
the same. 

CD1009C checks whether a length clause can specify a non-default 
size for a floating-point type; this implementation does not 
support such sizes. 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length 
clauses to specify non-default sizes for access types; this 
implementation does not support such sizes. 

CD2B15B checks that STORAGE_ERROR is raised when the storage size 
specified for a collection is too small to hold a single value of 
the designated type; this implementation allocates more space than 
was specified by the length clause, as allowed by AI-00558. 

BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine 
code insertions; this implementation provides no package 
MACHINE_CODE. 

The 18 tests listed in the following table check that USE_ERROR is 
raised if the given file operations are not supported for the given 


2-2 


combination of mode and access method; this implementation supports 
these operations. 


Test 

File Operation 

i Mode 

File Access Method 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL_IO 

CE2102F 

CREATE 

INOUT FILE 

DIRECT 10 

CE2102J 

CREATE 

OUT FILE 

DIRECT 10 

CE2102N 

OPEN 

IN FILE 

SEQUENTIAL 10 

CE21020 

RESET 

IN FILE 

SEQUENTIAL 10 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL 10 

CE2102Q 

RESET 

OUT FILE 

SEQUENTIAL 10 

CE2102R 

OPEN 

INOUT FILE 

DIRECT 10 

CE2102S 

RESET 

INOUT FILE 

DIRECT 10 

CE2102T 

OPEN 

IN FILE 

DIRECT 10 

CE2102U 

RESET 

IN FILE 

DIRECT 10 

CE2102V 

OPEN 

OUT FILE 

DIRECT 10 

CE2102W 

RESET 

OUT FILE 

DIRECT 10 

CE3102F 

RESET 

Any Mode 

TEXT 10 

CE3102G 

DELETE 


TEXT 10 

CE3102I 

CREATE 

OUT FILE 

TEXT 10 

CE3102J 

OPEN 

IN FILE 

TEXT 10 

CE3102K 

OPEN 

OUT FILE 

TEXT 10 


The 3 tests listed in the following table check the given file 
operations for the given combination of mode and access method, 
this implementation does not support these operations. 

Test File Operation Mode File Access Method 


CE2105A CREATE IN_FILE SEQUENTIAL_IO 

CE2105B CREATE IN_FILE DIRECT_IO 

CE3109A CREATE IN_FILE TEXT_IO 

The following 12 tests check operations on sequential, direct, and 
text files when multiple internal files are associated with the 
same external file and one or more are open for writing; USE_ERROR 
is raised when this association is attempted. 

CE2107B CE2107E CE2107G CE2110B CE2110D 

CE2111D CE2111H CE3111B CE3111D..E CE3114B 

CE3115A 

CE2107C..D (2 tests), CE2107H, and CE2107L apply function NAME to 
temporary sequential, direct, and text files in an attempt to 
associate multiple internal files with the same external file; 
USE ERROR is raised because temporary files have no name. 

CE.^108B, CE2108D, and CE3112B use the names of temporary 

sequential, direct, and text files that were created in other tests 
in order to check that the temporary files are not accessible after 


2-3 





the completion of those tests; for th±s implementation, temporary- 
files have no name. 

CE2111C checks RESET for sequential files including an attempt to 
reset ? file from mode IN_FILE to OUT_FILE; this implementation 
does not support such an operation and raises USE_ERROR. 

CE2203A checks that WRITE raises USE_ERROR if the capacity of an 
external sequential file is exceeded; this implementation cannot 
restrict file capacity. 

CE2401H, EE2401D, and EE2401G use instantiations of DIRECT_IO with 
unconstrained array and record types; this implementation raises 
USE_ERROR on the attempt to create a file of such types. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of an 
external direct file is exceeded; this implementation cannot 
restrict file capacity. 

CE3304A checks that SET_LINE_LENGTH and SET_PAGE_LENGTH raise 
USE_ERROR if they specify an inappropriate value for the external 
file; there are no inappropriate values for this implementation. 

CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the 
page number exceeds COUNT'LAST; for this implementation, the value 
of COUNT'LAST is greater than 150000, making the checking of this 
objective impractical. 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 1 test. 

B91001H was graded inapplicable by Evaluation Modification as 
directed by the AVO. This test expects an error to be cited for an 
entry declaration that follows an address clause for a preceding 
entry; but this implementation does not support address clauses for 
entries (rather, it provides a package that allows a task to wait 
for the delivery of one or more signals) , and so rejects the 
address clause. 


2-4 


CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is 
described adequately by the information given in the initial pages 
of this report. 

For technical and sales information about this Ada implementation, 
contact: 


Attn: Cathy Axel 
Ada Product Manager 
Digital Equipment Corporation 
110 Spit Brook Road (ZK02-3/M11) 

Nashua, NH 03062 
(603) 881-1413 

Testing of this Ada implementation was conducted at the customer's 
site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada implementation fails the ACVC 
[Pro92]. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language Standard. 

The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were 
withdrawn because of test errors (item b; see section 2.1). All 
tests passed, except those that are listed in sections 2.1 and 2.2 
(counted in items b and f, below). 

a) Total Number of Applicable Tests 3788 

b) Total Number of Withdrawn Tests 104 

c) Processed Inapplicable Tests 278 

d) Non-Processed I/O Tests 0 

e) Non-Processed Floating-Point 

Precision Tests 0 


3-1 


f) Total Number of Inapplicable Tests 278 (c+d+e) 

g) Total Number of Tests for ACVC 1.11 4170 (a+b+f) 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 
1.3) was taken on-site by the validation team for processing. The 
contents of the magnetic tape v;ere loaded directly onto the 
host/target computer. 

ji^fter the test files were loaded onto the host/target computer, the 
full set of tests was processed by the Ada implementation. 

The tests were compiled, linked, and executed on the host/target 
computer system. The results were captured on the host/target 
computer system and transferred to magnetic tape for storage. 

Tearing was performed using command scripts provided _ by the 
customer and reviewed by the validation team. See Appendix B 
a complete listing of the processing options _ for this 

implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this test 
were; 

C0PY_S0URCE NODEBUG NODIAG ERROR_LIMIT=1000 LIST NOSHOW 

Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. The listings 
examined on—site by the validation team were also archived. 


3-2 


APPENDIX A 


MACRO PARAMETERS 

This appendix contains the macro parameters used for customizing 
the ACVC. The meaning and purpose of these parameters are 
explained in [UG89]. The parameter values are presented in two 
tables. The first table lists the values that are defined in terms 
of the maximum input-line length, which is the value for 
$MAX IN LEN—also listed here. These values are expressed here as 
Ada string aggregates, where "V” represents the maximum input-line 
length. 

Macro Parameter Macro Value 

$MAX_IN_LEN 255— Value of V 

$BIG_ID1 (1..V-1 => 'A', V => '!') 

$BIG_ID2 (1..V-1 => 'A', V => '2') 

$BIG ID3 (1..V/2 => 'h') & '3' Sc (1..V-1-V/2 => 'A') 

$BIG ID4 (1..V/2 => 'A') & '4' & (1..V-1-V/2 => 'A') 

$BIG_INT_LIT (1..V-3 => '0') & "298” 

$BIG_REAL_LIT (1..V-5 => '0') & "690.0" 

$BIG_STRING1 (1..V/2 => 'A') & 

$BIG_STRING2 '""'&(1..(1..V-l-V/2 => 'A')&'1' & 

$BLANKS (1..V-20 => ' ') 

$MAX LEN INT BASED_LITERAL 

“ “ "2:" & (1..V-5 => '0') & "11:" 

$MAX LEN REAL BASED_LITERAL 

“ "16:" & (1..V-7 => '0') & "F.E:" 

$MAX STRING_LITERAL & (1..V-2 => 'A') Sc 


A-1 



The following table contains the values for the remaining 
macro parameters. 

Macro Parameter Macro Value 


$ACC_SIZE 

$ALIGNMENT 

$COUNT_LAST 

$DEFAULT_MEM_SIZE 

$DEFAULT_STOR_UNIT 

$DEFAULT_SYS_NAME 

$DELTA_DOC 

$ENTRY_ADDRESS 

$ENTRY_ADDRESS1 

$ENTRY_ADDRESS2 

$FIELD_LAST 

$FILE_TERMINATOR 

$FIXED_NAME 

$FLOAT_NAME 

$FORM_STRING 

$F0RM_STRING2 

$GREATER THAN DURATION 


32 

4 

2_147_483_647 

2**31-1 

8 

OPENVMS_AXP 

2.0**(-31) 

FCNDECL.ENTRY_ADDRESS 
FCNDECL.ENTRY_ADDRESS1 
FCNDECL.ENTRY_ADDRESS2 
2_147_483_647 

NO_SUCH_FIXED_TYPE 

LONG_LONG_FLOAT 

IIII 

"CANNOT_RESTRICT_FILE_CAPACITY 
75 000.0 


$GREATER_THAN_DURATION_BASE_LAST 131_073.0 
$GREATER_THAN_FLOAT_BASE_LAST 1.80141E+38 
$GREATER_THAN_FLOAT_SAFE_LARGE 1.7014117E+38 
$GREATER THAN SHORT FLOAT SAFE LARGE 1.0E308 


$HIGH PRIORITY 


15 


II 


A-2 



$ILLEGAL_EXTERNAL_FILE_NAME1 
$ILLEGAL_EXTERNAL_FILE_NAME2 
$INAPPROPRIATE_LINE_LENGTH 
$INAPPROPRIATE_PAGE_LENGTH 
$INCLUDE_PRAGMA1 
$INCLUDE_PRAGMA2 
$TNTEGER_FIRST 
$INTEGER_LAST 
$INTEGER_LAST_PLUS_1 
$INTERFACE_LANGUAGE 
$LESS_THAN_DURATION 
$LESS_THAN_DURATION_BASE 
$LINE_TERMINATOR 
$LOW_PRIORITY 
$MACHINE_CODE_STATEMENT 
$MACHINE_CODE_TYPE 
$MANTISSA_DOC 
$MAX DIGITS 


BAD/CHAR^@.~! 

x"& (1..256=>'c')&"y 

65_536 

-1 

PRAGMA INCLUDE ( "A28006D1. TST 

PRAGMA INCLUDE ( "B28006E1. TST 

-2147483648 

2147483647 

2_147_483_648 

C 

-75_000.0 
’ -131_073.0 

/ ! 

0 

NULL; 

NO_SUCH_TYPE 

31 

15 


") 


") 


$MAX_INT 

$MAX_INT_PLUS_1 

$MIN_INT 

$NAME 

$NAME LIST 


$NAME SPECIFICATION! 


9223372036854775807 

9_2 2 3_3 7 2_0 3 6_8 5 4_7 7 5_8 0 8 

-9223372036854775808 

SHORT_SHORT_INTEGER 

VAX_VMS,VAXELN,OPENVMS_AXP,RIS 
C_ULTRIX,DEC_0SF1_AXP,MIL_STD_ 
1750A,MC68000,MC68020,MC68040, 
CPU3 2 

ACVC_LFN_DEVICE:[ACvC_LFN_AREA 
]X2120A.;1 


A-3 


$NAME SPECIFICATI0N2 


$NAME_SPECIFICATI0N3 

$NEG_BASED_INT 

$NEW_MEM_SIZE 

$NEW_STOR_l^!IT 

$NEW_SYS_NAME 

$PAGE_TERMINATOR 

$RECORD_DEFINITION 

$RECORD_NAME 

$TASK_SIZE 

$TASK_STORAGE_SIZE 

$TICK 

$VARIABLE_ADDRESS 
$VARIABLE_ADDRESS1 
$VARIABLE_ADDRESS2 
$YOUR PRAGMA 


ACVC_LFN_DEVICE:[ACVC_LFN_AREA 
]X2120B.;1 

ACVC_LFN_DEVICE: [ACVC_LFN_AREA 
]X3119A.;1 

16#FFFFFFFFFFFFFFFE# 

1_048_576 

8 

OPENVMS_AXP 

/ / 

RECORD NULL; END RECORD; 
NO_SUCH_MACHINE_CODE_TYPE 
64 
0 

10.0**(-3) 

FCNDECL.VARIABLE_ADDRESS 
FCNDECL.VARIABLE_ADDRESS1 
FCNDECL.VARIABLE_ADDRES S 2 
EXPORT OBJECT 


A-4 



APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 


B-l 


COMPILER OPTIONS 

Compiler options for DEC Ada hosted on OpenVMS Alpha systems The default compiler 
options were used, except as follows: 

1. /LIST was used to produce compiler listings. 

2. /NODEBUG was used to inhibit the generation of debugging information in the object 
file since such information is not relevant to vahdation. 

3. /ERROR_LIMIT=1000 was used since more than 30 errors are diagnosed for some val¬ 
idation tests. 

4. /NOSHOW was used to exclude portabihty information from the compiler hstings. 

The DEC Ada compiler options and defaults for OpenVMS Alpha systems are summarized 
as follows: 

• /ANALYSIS _DATA or/NOANALYSIS_DATA 

Controls whether a data analysis file containing source code cross-referencing and static 
analysis information is created. 

The default is /NOANALYSIS_DATA 

• /CHECK or /NOCHECK 

Controls whether run-time error chec ki ng is suppressed. (Use of /NOCHECK is equiv¬ 
alent to giving all possible suppress pragmas in the source program.) 

The default is /CHECK (error checking is not suppressed, except by pragmas.) 

• /COPY_SOURCE or /NOCOPY_SOURCE 

Controls whether the source being compiled is copied into the compilation library for a 
successful compilation. 

The default is /COPY_SOURCE. 

• /DEBUG or /NODEBUG or /DEBUG=option 
where option is one of: 

ALL, SYMBOLS or NOSYMBOLS, TRACEBACK or NOTRACEBACK, or NONE 
Controls the inclusion of debugging symbol table information in the compiled object 
module. 

The default is /DEBUG or, equivalently, /DEBUG=ALL. 

• /DESIGN or /NODESIGN 

Controls whether the input file is processed as a design or compiled as an Ada soirrce. 
The default is /NODESIGN, in which case the file is compiled. 

• /DIAGNOSTICS, /DIAGNOSTICS=file-name, or /NODIAGNOSTICS 

Controls whether a special diagnostics file is produced for use with the Language Sen¬ 
sitive Editor ( a separate DIGIT.VL product.) 

The default is /NODIAGNOSTICS. 

• /ERROR_LIMIT=:n 

Controls the number of error level diagnostics that are allowed within a single compi¬ 
lation unit before the compilation is aboreted. 

The default is /ERROR_LIMIT=30. 

• /LIBRARY=::directory_name 


1 



Specifies the name of the Ada compilation hbrary to be used as the context for the 
compilation. 

The default is the hbrary last estabhshed by the ACS SET LIBRARY command. 

• /LIST, /LIST=file_name, or /NOLIST 

Controls whether a hsting fil e is produced. /LIST without a file-name uses a default 
file-name of the form sourcename.LIS, where sourcename is the name of the source file 
being compiled. 

The default is /NOLIST (for both interactive and batch mode). 

• /LOAD or /NOLOAD 

Controls whether the current program hbrary is updated with the successfully processed 
units contained in the source file. 

The default is /LOAD. 

• /MACHINE_CODE or /NOMACHINE_CODE 

Controls whether generated machine code (approximating assembler notation) is in¬ 
cluded in the hsting file, if produced. 

The default is /NOMACIIINE_CODE. 

• /NOTE_SOURCE or /NONOTE_SOURCE 

Controls whether the file specification of the current source file is noted in the compila¬ 
tion hbrary. (This copy is used for certain automated (re)compilation features.) 

The default is /NOTE_SOURCE. 

• /OPTIMIZE or /NOOPTIMIZE 

Controls wehther full or minimal optimization is applied in producing the compiled code. 
The default is /OPTIMIZE. (/NOOPTIMIZE is primarily of use in combination with 
/DEBUG.) 

• /SMART_RECOMPILATION or /NOSMART_RECOMPILATION 

Controls whether smart recompilation information is stored and used to mi nimi ze un¬ 
necessary recompilations. 

The default is /SMART_RECOMPILATION 

• /SYNTAX_ONLY or /NOSYNTAX_ONLY 
Controls whether a syntax check only is performed. 

The default is /NOSYMTAX_ONLY, which indicates that fuU processing is done. 

• /SHOW=PORTABILITY or /NOSHOW 

Controls whether a portability summary is included in the listing. 

The default is /SHOW=PORTABILITY. 

• /WARNINGS=(category;destination, ... ) 

Specifies which categories of information and warning level messages are displayed 
for which destinations. The categories can be WARNINGS, WEAK_WARNINGS, SUP¬ 
PLEMENTAL, COMPILATION_NOTES, and STATUS. The destinations can be ALL, 
NONE, or combinations fo TERMINAL, LISTING, or DIAGNOSTICS. 

The default is: /WAENINGS=(WARNALL,WEAK:ALL,SUPP:ALL,COMP:NONE,STAT:LIST) 


2 


LINKER OPTIONS 


The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer- Unless specifically noted 
otherwise, references in this appendix are to linker documentation and 
not to this report. 


B-2 


LINKER OPTIONS 


Linker options for DEC Ada hosted on OpenVMS VAX and OpenVMS Alpha Systems. 

DEC Ada programs are linked using the "ACS LINK' command. The default ACS LINK 
options were used, except as follows; 

1. /COMMAND was used. ACS LINK checks that aU units in a program are current and 
writes a command file to create the executable image using the VMS Imker. By default, 
this command file is invoked in a subprocess and the image is hnked. If /COMMAND 
is specified, the command file is written but not invoked. For vahdation, /COMMAND 
was used, and the generated command file was invoked after the ACS LINK command 
to do the actual link. This approach saves the overhead of spawning a subprocess for 
each executable vahdation test. 

2. /NOTRACE was specified to exclude the traceback symbol information from the image 
file since this information is only relevant when debuggging programs. 

3. /EXECUTABLE was used to specify the name of the executable image file. 

The options and defaults for linking Ada programs are summarised below. 

• /COMMAND=file-name 

Write a command file to create the executable image using the VMS hnker but do not 
invoke this command file. 

• /DEBUG or /NODEBUG 

Controls whether a debugger symbol table is included in the executable image. 

The default is /NODEBUG. 

• /EXECUTABLE, /EXECUTABLE-file-name, or /NOEXECUTABLE 

Controls whether the Hnker creates an executable image file and optionally provides the 
name of the file. 

The default is /EXECUTABLE. 

• /LOG or /NOLOG 

Controls whether a Hst of aU units in the image is displayed. 

The default is /NOLOG. 

• /MAIN or /NOMAIN 

Specifies whether the main Ada unit is the main program. 

The default is /MAIN, which indicates that the main Ada moit is the main program. 

• /MAP, /MAP=file-name, or /NOMAP 

Controls whether the link er creates an image map listing file. If /MAP is specified, some 
other options can be specified to control the level of detail in the map fisting file. 

The default is /NOMAP. 

• /OUTPUT=file-name 

If specified, requests that output be ".vritten to a file other than to the standard output 
device. 

• /SYSLIB or /NOSYSLIB 


3 


Controls whether the link er automatically searches the default system hbrary for unre¬ 
solved references. 

By default, the system hbrary is always searched. 

• /SYSSHR or /NOSYSSHR 

Controls whether the linker automatically searches the default system shareable image 
library for unresolved references. 

By default, the system shareable image Hbrary is always searched. 

• /SYSTEM_NAME= system 

Directs the program Hbrary manager to produce an image for execution on a particular 
operating system. On VAX system, the possible values are VAX_VMS or VAXELN. On 
Alpha system, the only value supported is OpenVMS_AXP. 

If /SYSTEM_NAME is not specified, the setting of the pragma SYSTEM_NAME deter¬ 
mines the target environment. 

• /TRACEBACK or /NOTRACEBACK 

Controls whether subprogram traceback information is included in the executable image 
for run-time error reporting. The default is /TRACEBACK. 

• /USERLIBRARY=(table,...) or /NOUSERLIBRARY 

Controls whether the link searches any user-defined default Hbraries for unresolved 
external symbols. 

By default, the link er searches process, group, and system logical name tables for user- 
defined Hbrary definitions. 

Additional options are provided that control whether the link is done while the user waits or 
is done in a background mode. Using one option or the other has no effect on the executable 
image that is generated. 


4 


APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type SHORT_SHORT_INTEGER is range -128..127; 
type SHORT_INTEGER is range -32768..32767; 
type INTEGER is range -2147483648..2147483647; 
type LONG_INTEGER is range -2E+63..2E63-1; 


type FLOAT is digits 6 range -1.70141E+38..1.70141E+38; 
type LuNG_FLOAT is digits 15 range 

-8.988465674312E+307..8.988465674312E+307; 
type LONG_LONG_FLOAT is digits 15 range 

-8.988465674312E+307..8.988465674312E+307; 

type DURATION is delta l.OE-4 range -131072.0..131071.9999; 

end STANDARD; 


C-1 


Implementation-Dependent Characteristics 


Note 


r 


This appendix is not part of the standard definition of the Ada 
programming language. 


This appendix summarizes the implementation-dependent characteristics of 
DEC Ada by presenting the following: 

• Lists of the DEC Ada pragmas and attributes. 

• The specification of the package SYSTEM. 

• The restrictions on representation clauses and unchecked type conversions. 

• The conventions for names denoting implementation-dependent 
components in record representation clauses. 

• The interpretation of expressions in address clauses. 

• The implementation-dependent characteristics of the input-output 
packages. 

• Other implementation-dependent characteristics. 

See the relevant run-time reference manual tor additional implementation- 
specific details. 

F.1 Implementation-Dependent Pragmas 

DEC Ada provides the following pragmas, which are defined elsewhere in the 
text. In addition. DEC Ada restricts the predefined language pragmas INLINE 
and INTERFACE. See Annex B for a descriptive pragma summary. 


F-’ 


'ir-iDlementation-Dependent Pragmas F I 




Pragma 

DEC Ada systems 
on which It applies 

Section 

.\ST_ENTRY 

Open^AtS 

9.12a 

COMMON_OBJECT 

.Ail 

13.9a.2.3 

COMPONENT_ALIGNMENT 

-Al 

13.1a 

EXPORT_EXCEPTION 

Open VAIS 

13.9a.3.2 

EXPORT.FUNCTION 

.A1 

13.9a.1.3 

EXPORT.OBJECT 

A1 

l*.9a.2.2 

EXPORT_PROCEDURE 

A1 

13.9a.1.3 

EXPORT.VALUED.PROCEDURE 

.Ai 

13.9a.1.3 

FLOAT_REPRESE .STATION 

OoenVAlS 

DEC OSF l 

3.5.7a 

IDE.NT 

.A! 

Annex B 

LMPORT_EXCEPTION 

OpenVAIS 

13.9a.3.1 

IMPORT_FUNCTION 

.411 

13.9a.l.l 

IMP0RT_0 EJECT 

.4J1 

13.9a.2.1 

IMPORT_PROCEDURE 

.411 

13.9a.l.l 

[MPORT_VALUED_PROCEDURE 

.411 

13.9a.l.l 

LNLINE.GENERIC 

All 

12.1a 

ISTERF.4CE_N.AAIE 

All 

13.9b 

LONG_FLO.AT 

OpenVAIS 

3.5.7b 

.\L4IN_STOR.4GE 

OpenVAIS VAX 

13.2b 

PSECTJDBJECT 

OpenVAIS 

13.9a.2.3 

SH.4RE .GENERIC 

OpenVAIS 

12.1b 

SUPPRESS.ALL 

.A1 

11.7 

T.ASK.STORAGE 

.411 

13.2a 

TIME_.SLICE 

iJpenVAIS 

9.8a 

TITLE 

.A1 

Annex B 

VOL.4TILE 

.All 

9.11 


F.2 Implementation-Dependent Attributes 

DEC Ada provides the following attributes, which are defined elsewhere in the 
text. See Annex A for a descriptive attribute summary. 


F2 Impiementatior Dependent Attributes 


F-2 


Attribute 

DEC Ada systems 
on which it applies 

Section 

.AST_ENTRY 

OpenV'MS 

9.12a 

BIT 

.All 

13.7.2 

MACHINE_SIZE 

.All 

13.7.2 

NULL.RARAMETER 

.All 

13.9a.l.2 

TYTE^CLASS 

.All 

13.7a.2 


7 


F.3 Specification of the Package System 

DEC Ada provides a system-specific version of the package SYSTEM for each 
system on which it is supported. The following specification is composite; it 
includes all common and system-specific features. 

package SYSTEM is 

---- On OITRIX systems: 
type NAME is (RISC_ULIRIX); 
for NAME use (6); 


- On all other systems: 

type NAME is 

— DEC Ada implementations 

(VAX_VMS, VAXELN, OpenVMS_AXR, RISC_CLTRIX, :eC_OSF 1_AXP, 
— XD .Ada implementations 

m:L_STD_ 1750A, MC68000, MC68020, MC68040, C?"32); 
for NAME use (I, 2, 7, 8, 9, 101, 102, 103, 104, 105); 


sy:tem_name 

SYSTEM_NAME 
£YSTEM_NAME 
SYSTEM NAME 


fic definitions of SYSTEMJ.AME 
constant NAME := VAXJ.'MS. 
constant NAME := :per,'-'MS_.AX?, 
constant NAME = S£C_:£ri_.AX?, 
constant NAME .= RISC CITR'X, 


STCRAGE_aNIT 
.MEMORY SIZE 

.memc?.y'’si:e 


constant := 3; 
constant : = 2**63-l, 
constant := 2’'31-1. 


; ^ SCGC 


:ic definition: 


.MAX INT ana .MIN INT 


-On .AX? systems: 

.MAX_INT : constant := 2*’6 3-l, 

-MIN INT : constant ;= 


-On ali. 

MAZ<_1NT 
MIN 'N'^ 


Other systems: 

: constant = L": 

' constant = - ^: 1'. 


F-3 


Soecification ot the Package System F.3 




-- System-specific defir.ititr.s :: MA:<_SISir3 

- On OpenVMS VAX systems: 

MAX_0I3I'rs : constant .= i3, 

- On all other systems: 

yAX_DIGirS : constant := It; 

MAX_MANTISSA : constant := 31; 

F:ME_0ELTA : constant := 1 3".-31), 

— System-specific defir.iti 

On OpenVMS VAX systems 

TICK : constant , = 

-—- On AXP systems: 

TICK : constant := 

On ULTRIX systems: 

TICK : constant := 3 306 ’ 13.0*’(-3); 

subtype PRIORITY is INTEGER range 0 .. 15; 

— On OpenVMS and OSF.^l systems: 

type INTEGER_8 is range -128 . 12’; 

for INTEGER_8'SIZE use 8; 

— On OpenVMS and OSF/1 system.s: 

type INTEGER_16 is range -32_"'63 . . 32_’61’; 
for INT£GER_16'SIZE use 16; 

-- Cn OpenVMS and OSF/1 systems: 

type 1NTEGER_32 is range -2_l-5'_48 3_648 .. 2_1-I’_483 _d 47; 
for 1NTEGER_32'SIZE use 32; 

— On AXP systems: 

type INTEGER_64 is range 

-9_223_372_036_854_7’5_3:s >^;23_3’2_036_954_'75_807; 

for :NTEGER_64'SIZE use 64, 

— Cn OpenVMS and CSF/i systems 

type 1ARG£ST_:NTEC-ER is range M1N_1NT MAX_1NT; 

-- Cn Cper.’/MS and CSF/1 systems: 

function "not" (LEFT _.'J-.CEST INTEGER) return LARGEST_INT£GER; 

function ’’and" (LEFT, RIGHT l.AR.CEST INTEGER) return LARGEST_1NTEGER; 

function "cr" (LEFT, RIGHT lAP.GEST INTEGER) return LARGEST_INTEGER; 

function "xor" (LEFT, RIGHT 1.A.-GEST INTEGER) return LARGE3T_INTEGER; 

-- Address type 

type AOZRESS is private; 


F-4 



F 3 Soecification of the Package System 





.-^:?£33_:£RC ; constant 

NC A£CR : constant A££?Z£S; 

N'Cll A£3R£33 : constant A££?i;£3, 

-£r. 23F/1 svsteras: 

.-£:£?£££ ££££ : constant = o4; 


-£r. Ccer.VMS 3yste"3: 

.-£::?i3£ £;££ : constant := j£. 


function 

(IIFI 

AF ZPS33 , ? 13£Z 


return 

function 

(iiFT 

INTFGZR, jHT 

rS Z PS 3 3 ) 

return .ADDRESS 

function 


AFFP.ZS3. PlZr.Z 

PS Z PS 3 S 

return INTEGER 

function 


rS ZPS33 - r ZZr.Z 

INTEGER) 

return .ADDRESS 


.'t'cte cr.at because AC£R£3S is a crivace type 

tee functions " = and are a.ready availafc.e and 


do not nave to be exp.ioit.y 


■i 0 fir.se 


-‘•--.''-itr. 


; ^£3“'7 

^ I '•HT 

rS Z PS 3 3 ) 

return 

3CCLEAN; 

function 


C-Zr T, 

~IGHT 

ADDRESS j 

return 

300LEAN; 

function 


(LZFT, 

RD^GHT 

.ADDRESS) 

return 

BOOLEAN; 

function 


(IFFT, 

RIGHT 

.ADDRESS) 

return 

BOOLEAN; 

function 


fZZFT, 

RIGHT 

.ADDRESS) 

return 

BOOLEAN; 

function 

generic 


'■ *' 

RIGHT 

.Ai.. w an 11 ) 

return 

BOOLEAN; 


type ri-RGE'r is private; 

function EErfH ERCM ADDRESS iA . ADDRESS) return DXRGET 


generic 

type DAR.DET is private; 

procedure A3S;£N_TO_ADDR£SS (A ; ADDRESS; D : TARGET); 

DED Ada floating point type declarations for the VAX 
f-oating point cata topes 

systems: 

■digits 6>; 

■digits i-, 
digits It', 

-'r. Icer.'v'MS VAX svste.T.s; 

type H^EDCAT is {digits 55'; 

DED A'Ca floating coint type cec.arat-ons tor one IEEE 
floating point data types 

-Dn .1X2 and 'JDTRIX systems 

type ;EEE_5:NGDE_tDCAX is digits 
type ;iEE_DCD3DE_EDCAT is digits 



- Dn DpenVMS 

f/pe .“LDAT is 
type D EIDAT is 
type -■_£1;AT is 


Specilication of the Package System F.3 









type ::Ph;_;las 3 is irY?£_:iASS iN'.YtzPA.r::;:, 
TYPE E1AS3'i^.'YEPE?,, 



-- A3T handler type 

In Cren'v'MS svsterr.s: 
type A3'r_HANCLER is limitel private, 

-■ Cn Cnen'/MS svste.T.s: 

NC_AST_;iAiNCEER : constant A3T_;-iAl.'ElER, 

-- Mon-Ada exception 

MCN_A-A_£RRCR : exception; 

-- Hardware-oriented types and functions 

type Bir_ARRAY is array (INTEGER ranee <>) of BOOLEAN; 
pragma PACK(B:T_ARRAY); 

subtype BIT_ARRAY_3 is BIT_ARBAY (0 .. ’), 

subtype 3IT_ARRAY_16 is aiT_ARRAY (0 .. 15); 

subtype BIT_.ARRAY_32 is BIT_ARRAY (3 .. il!, 

subtype BIT_ARRAY_54 is BIT_ARRAY iO , 33); 

typ>e CMSIGMEI)_BYTE is range 0 . . 255; 
for ■.’NSIGMEj BYTE'size use 8, 


function "not" 

(LEFT 


CNSIGNED 

SYTE) 

return CNSI3ED 

BYTE 

function "ana" 

(LEFT, 

RIGHT 

CNSI3ED 

JYEE) 

return CNSIGNED 

'byte 

function "or" 

(LEFT, 

RIGHT 

CNSIGNEL 

3:T£) 

return 'CNSI3ED 

BYTE 

function "xor" 

(LEFT, 

RIGHT 

CNSIGNEZ 

2'iZZ) 

return CNSI3ED 

'byte 


function T0_UNSIGNED_3YT£ iX , BIT_.'j:i:.A:_3 1 return CNSIGNEI^BYTE; 
function TO_3IT_ARRAY_3 'X . Yf;3IG;.'EC_3iT£i return 3IT_ARRAY_8; 

type uNSIGNED_3YTE_ARRAY is array 'INTEGER range <>) of ■JNSIGNED_3YTE; 

type '.ColGMEC_WCRC is range 3 c;:]:. 

for YM3IGN’EC_WCRC'SIZE use 16, 

function "not" 'LEFT GMSIG3;E1_WCRCi return YNSIGNEO_WCRD; 

function "and" (LEFT, RIGHT ■.■NGIGI.'ECJaGPE) return 'INSIGNED WORD; 

function ":i" (LEFT, RIGHT GNIIGN'EC_WC?i:t return "NSI3ED~WCRD; 

f'Linction 'Lior" (LEFT, RIGHT , I'NSIGNEOJflCRi; i return LNSIGNED_WORD; 

function TGJJNSIGMECJaCPI: X h:T_.'-=FAY_ 16' return 'INSIGNEO_WCRD; 
function TC_3IT_.ARulAY_16 X .'N3I INEE^WCREi return 3IT_.ARRAY 16; 

type ''JNSIGNED_WCRD_.ARRAY is array 'INTEGER range <>) of CNSIGNED WORD; 


F 3 Specrfication of the Package System F-6 












typ€ 'JNSZoNED ICNGWCPX is range _‘irj_o4 ; 

for 'J^iSIoNEC ICNGWGRD'3IZE use j-, 

function '’not" 'lErT . '-G.'iI 3N'E:_L:NGWC?Gi return ZfJSIGMEZ^lZNGWCFG; 

function "and" (LEFT, RIGHT : ■.T:s::dEG_L::JGWC?E) return '.11S:3NET_ICNG>;CRi:; 

function "or" ilEET, RIGHT ; .G.'GI3i:EE_ICNGWCiO) return GTJSIjNED__CNGWCRE'; 

function "xcr" flEET, RIGHT ■ ■.G;£IG>iE:__:NGV.’CRE) return GIlSIG>;EE_LCNG>fCRD; 

function TO_TNSTGNED_ICNGWCRi; ■ X =IT_.'_=RA'f_32) return G1i£IGUED_LCNGWCRE; 
function :o_ 3IT_R-RRA.Y_32 iX ; '.G.'SI Ii:E:_i;NGrtCRE) return 3i:_.VRRJiT_32 ; 

type •.i;SIGNEE_ICNGWCRG_.i-RFAiY is ^ 

array iINTEGER range <>i or VNSIGI!E3_ICN'G><CRI:; 

— Cn AX? systece: 

type ■.'NSIGNED_32 is range 3 . ■;_2}4_5'i'__255; 

for TNSIGNE3_32'SITE use 32; 

-- In AXr systems: 

function "not" (lEET : '.GoIGNED_32) return TNSIGNED_32; 

function "and" (LEFT, RIGHT : ■INSIGMEO_32) return L’NSIGNED_32; 

function "or" (LEFT, RIGHT 'H.'3IGNED_32) return L'NSIGNED_32; 

function "xor" (LEFT, RIGHT ; L'NSIGNED_321 return u'NSIGKED_32; 

-- Cn AXP systems: 

function TO^L1JSIGNED_32 (X : 5IT_A?JLAY_32) return L’NSIGNED_32; 

function TO_3IT_ARRAY_32 (X : TNSIGNED_32) return 3IT_ARRAY_32; 

type L'NSIGNE3_;CADW0RD is 
record 

LG : L'NSIGNED_LCNGWCRL; 

LL . L"NSIGNED_LONGWCRD; 
end record; , 

for IG:SI.GI;EC_;CACW0RD'SIZE use 64, 
for TNSIGNEC_;L'ACH0RD use 
record at mod 8; 
end record; 

function "not" (-EFT : IT.'SIGNEC_2VAI;WCRD) return GNSIGNED_Q!JA3W0RD; 

function "and" (LEFT, RIGHT IToIGNEC G^ACWCR—) return UNS-GNED^QUAuWORD; 

function "or" (LEFT, RIGHT : '.T;SIGI;EC_GCACWCRI;) return L’NSIGNED_QOADWORD; 

function "xcr" (LEFT, RIGHT : G'NSIGI.’ED^GLACWCRi;') return aNSIGNED_QOADWORD; 

function TC GGoGGNEL GTACWCRII X 3IT .-"FAY 641 return TNSIGNED_QnADWORD; 

function TILSIT .ARRAY 04 'X GG.’GIGNEC_2,L'.ALWCRCi return 3IT_.ARRAY_d4; 

type gg:si;nel_;l’ai;wcri:_.a.3fay is 

array : INTEGER ra.tge <>' :t .G-'S-GIiEE_iLACWCf<II; 

function TC_.Ai;:.RES3 (X . INTEGERi return .iAC.RESS; 

function :G_.AELRES5 !X GNSI;nEL_-CNG’WC?IIi return .AECRESS; 

function TC_.iXCRES3 (X : - j.t-ver 5 a-_i.tteger■) return .ACTRESS; 

function TC INTEGER X .AEL.RESS) return -NTiGER; 

function TC GN3IGNEC LCNGWCRE X .ALLRESS) return TNSIGNED_LCNGWORD; 


■SpGcrfication of the Package System F.3 








— Cn CTsenVMS systems sniy: 

function :C iTISI^NED LCNGVJCRE iX ■ A3TJ-;ANCLE?.) return L'NS:3flED_L0NGWCRD; 


— Lsr.venticnai names for stac.t s'. 

subtype ■JNSIGNED_1 is LflSIGNED 
subtype "NSIGNEDJ is GNSLGIJEC' 
subtype 'JNSIGNEC_3 is L'NSIGNEC’ 
subtype •JNS:'GNED_4 is LfJSLGNEC' 
subtype L'NSIGNED_5 is GNSI'GNECy 
subtype 'JNSIG>!ED_6 is GNSIGNED 
subtype GNSl!GNE[;_‘^ is GNSLGNEC 
subtype LCIS:GNED_3 is j^.’SIGNEC' 
subtype ■jNSI'GNED_ 9 is L'NSIGNEC 
subtype ■JNSIGNED_1G is L'NSIGNEC 
subtype !JNSIGNED_11 is L^SIGNED 
subtype L‘NS:GNED_12 is 'GNSIGN'EC 
subtype UNSIGNED_13 is 'JNSIGNED 
subtype UNSIGNED_14 is 'JNSIGNED 
subtype 'JNSIGNED_i5 is GNSI’GNED 
subtype LrNSIGNED_16 is UNSIGNED 
subtyp--! UNSIGNED_17 is UNSIGNED 
subtype UNSIGNED_18 is UNSIGNED 
subtype aNSIGNED_19 is UNSIGNED 
subtype rJNSIGNEDjO is UNSIGNED 
subtype UNSIGNED_21 is UNSIGNED 
subtype UNSI'3NED_22 is UNSI'GNED 
subtype UNSIGNED_23 is UNSIGNED 
subtype L'NSI'GNED_24 is UNSIGNED 
subtype 'JNSIGN'ED_25 is UNSIGNED 
subtype ■JNSIGNED_26 is UNSIGNED 
subtype ’UNSIGNED 27 is 'UNSIGNED 
subtype ■JNSIGNED_28 is UNSIGNED 
subtype L'NSI’GNED_29 is UNSIGNED 
subty^ UNSIGNED- 30 is 'UNSIGNED 
subtype DNSIGNED_31 is UNSIGN'ED 


rtiTes cf Z'/ve 'JNS*GNr.C LCNG'iVCRD 


LCNG'WCRD 

LGNG'^JCRD 

LGNG'WCRC 

LGNGWORC- 

LLNCrfCSD 

'iGNG'rtCRC 

'LGMG'WCRD 

'lung'wcpd 

‘lGNG'WORD 

'lUNG’^JCRD 

'lCN'G’WCHD 

'LCNG'WCRD 

'lgngwcrd 

'longword 

'loncwcrd 

'lcngword 

‘lCNG'WORD 

‘lcngword 

‘longword 

‘lcngword 

‘lcngword 

‘lgngwcrd 

‘lcngword 

‘LCNG'WCRD 

LCNG'WCRD 

’LCNG'WCRD 

_LCNG'WCRD 

_LCN'G'WCRD 

^LCNG'WCRD 

^LCNG'WCRD 

LCNG'WORD 


range 3 
range 0 
range 3 
range 3 
range 3 
range 3 
range 3 
range -3 
range 3 
range 0 
range 0 
range 0 
range 0 
range 0 
range 0 
range 0 
range 0 
range 0 
range 0 
range 0 
range 3 
range 0 
range 3 
range 3 
range 3 
range 0 
range 3 
range 3 
range 3 
range 3 
range 0, 


i*’ t-i 
; «/ 7 _• 


2«T 9-y 

2”I3-1 

2”Ii-l 

2 ’* 12-1 

2*’13-1 

2*»14-1 

2*»15-1 

2’*16-1 

2*’17-1 

2’*18-1 

2**19-1 

2**20-l 

2*'21-1 

2**22-l 

2'*23-I 

2”24-l 

2**25-l 

2**26-l 

2"27-l 

2”28-l 

:”29-l 

2**30-l 


Function for obtaining global symbol vaj-ues 

function IMPORT_VAL'JE (SYMBOL : STRING) return UNSIGNED_LCNG'WORD; 

-- :r. Gcen'JMS ana CSF/'l systems: 

function i;<rCRT .ADDRESS (S'iMBCL ; STRING) return .ADC.RESS; 

function IM?CRT'‘LARGEST '/.AL'UE (S'YMECL ; STRING) return LARGEST_INTEGER; 


VAX aevioe ana process register 

— Cn CoenV'MS VAX syste.ms only 
function .READ_REGI3TER 'SOURCE 
function .^EAC^REGISTER (SOURCE 
function ?EAD_?EGISTER iSCURCE 
return 'UNSIGNED LCNG'WCRD; 


■,NSIGNEC_aYTE) return ■UNSIGNED_3YTE; 
'UNSIGNECJWCRD) return 'UNSIGNEDJWORD; 
'.NS I GNEC‘‘LCNG'WCRD ) 


F 3 Specification of the Package System 


F-a 





procedure ■iVRirE_?- 
procedure VTRirE 
procedure 'fiRZZZ ?_ 


-- Ir. Cuer.’/^S VAX svscec.s rr..-.- 
function '.VZYZZ?. : 

procedure MTPR ■,?£3~..V>SI?. : 


’ ZViZ-Z WCPJ3 ' , 

' IC'M-WCPJT; 
,:izizyiZZ icN'3w.:?i 


return I -CNGWCRT; 


“..5 :c-.:wir.c ter.uri 


:ara.T.eter : 


ze c. a r a 11 r n w 11 r.: u t 
-v. A va.-e of j 


Ir.oer-ocl<ed"-t3tructior. crooecor^s 
-- Cn Iper.VMS and CSF, 1 svsoer.s 

procedure :1IAR_;NTZR1C:?'J;3 =:: in out 5CCLFAN; 

;i3_VAlVI out 3CCi£AfJ) ; 

procedure SET_:NriRLCCK£: .'SIT in out BCCLiAN; 

ZZZJi'kZ'ZZ : out SCCIEAN), 

-- On OpenVMS and CSF/1 sysoems: 
type .AO:ONEO_WCRO is 
record 

V.AIOE : £HORT_:NrE:-ER; 
end record, 
for AOI ON'EO_WCRD use 
record at mod 2; 
end record; 


-- :n .AX? aysoems only: 
procedure OLEAR^INTERLOCKEO '3;o 



procedure 3 ET_:nTERLCCF-ED 



in out aCCLEAfl; 
out 3CCEEA*N; 
in NAOVRAL; 
out 3COOEAN) , 
in out BOCIEAH, 
out EMIEA-N; 
in MAOVRA.E, 
out SMOEAN!; 


procedure .AOO 



in o;-;; = o^;noeger; 

in out -AO; JXEEJWCRD, 
out Od'O^lERl, 


Soecification of the Package System 














— :ri AJ<? systems cn-y; 
type ALI3NED_INTEGER is 
record 

VAIEE : INTEGER; 

end record; 

for AI.IGNEG_INTEGER use 
record at mod 4, 
end record; 

-- Gr. .AX? syste.TS tn.y: 
type AI.IGNED_ICMG_INGEGER is 

record f 

GCNG_:NrEGE?., 

end record; 

for .A1:GNEE_ICNG_:;!TEGER use 
record at mod 3; 
end record; 

-- Eor the fcllcwing dec.aratitr.s, t:te that the declaration without 
-- a ?G;TRY CCCNT oarair.eter mean to retry infinitely. A value of 0 
-- ::r the .RETRY_GC'JNT means uc not retry. 


-- On .AX? syste-ms only: 

procedure ADD_.ATCMIC (TO 

.AMCniT 

orocedure ADD_.ATCMIC (TO 

AMCOllT 
.RETRY_G:raT 
OLD VALvE 
3'JCCEEo z —Au 

procedure .AOC_ATGMIC (TO 

.AMOUNT 

procedure .AiC_.ATCMIC (TO 

AMOUNT 

.RETRY_CCUNT 

OLD_VALUE 


in out .AL:GNED_TNTEGER; 

in INTEGER); 

in out .AI.I3NED_INTEGER; 

in INTEGER; 

in NATURAL; 

out INTEGER; 

cut 3XLEAN) ; 

in out .ALIGNEO_LOSG_INTEG£R; 

in LONG_INTEGER); 

in out .ALIGNED_LCNG_INTEGER; 

in LONG_INTEGER; 

in NATURAL; 

out UONG_INTEGER; 

out 5CCLEAN); 


— On AX? systems only: 
procedure AND_ATCMIC 'TO 

ERCM 

procedure .ANO_.ATCMIO TO 


ERuM 

.^LTRY HUNT 



procedure ANO_ATOMTO iTO 

FROM 

procedure .AND_ATCMIG ; TO 


r- '•M 



in out .ALIGNEO_INTEGER; 

in INTEGER); 

in out .ALIGNEO_INTEGER; 

in INTEGER; 

in NATURAL, 

out INTEGER; 

out 3XLEAN) ; 

in out .ALIGN'ED LONG_INTEGER; 

in LONG_INTEGER), 

in out .ALIGNEO LONG INTEGER; 



in NATURAL, 
out LONG_INTE.jER; 
out see LEAN), 


F 3 Soecification ot the Package System 


F-10 








-- tr. AX2 svs"err,s :r.-y: 


procedure IR AICMI3 

r:: - V 

in cut ALISIfEL INTESER; 

procedure ATCMIZ 

r ACM 

la cut AICCNAC CN'TCCAA. 

:n S'ACVPA', 



cut 


c - . w-Cw * 

cut , 

procedure ;r ARCMIZ 

r- ' V 

in out ALIStiET LINT- It.'TETiR 

Procedure AIC.MIC 

• rc 

:a out A1C3N':.C CCN'C 


rr “M 

. *.-“T zTz ^ 


- 



liZ VAl.'Z, 

cut IINC IN'TECZR; 


- - -A u 

out s:-:lea_n , 

-- :r, :oer.yMS 7iJ< S-- 

C “ p, ' •/ 


type ;t;3C_S7AT'JS is 
for iNS; STATTS use 

(:Ki:A"rT?sf 

ca;c nc ccck, :k firso, 

=> ' 


:AI1 L-TK 

s > 


;K_r:RST 

= > S', 

— ;r. CoenVMS VAX systems oniv: 


type Ri-MC SIAT'JS is 

iCK N’CT £MPTT, 
CK SMPTT, 

FAIL NC LOCK, 

FAIL WAS EMPTY); 

for RSy.Q STATUS use 

!CK NOT HUMFTY 

=> 3, 


ta;: nc ucck 

=> 1, 


CK IMPTY 

=> C, 


FAIL WAS -LxPTY 

= > 3) ; 

-- Sr. :ter.'/MS A-XP systems only; 


t'y'ue cTAIl’S is 

(FAIL NC LUCK. 

IK NCT FIRST. IK FIRST); 

for IN'il SIArvS use 

(FAIL NO LOCK 

=> -I, 


OK NOT FIRST 

= > , 


CK_FIRST 

= '> I' , 

-- :r. TT3enV>fS AX^ sy 

5Zem3 cr.ly 


tyr>€ ?"MC STATUS is 

CK NCT £^*lrT'*, 

"AC- WAS ly.rCY, 

for RiyiQ STATUS use 

(FAIL NC l::k 

=-> -I, 


FAIL WAS ItCT: 



C^ NCr £Mr’~ i 



CK 

=’ i 

-- ivster 

s zr. ^ ’/ 


procedure (*T 

EM on ACL? 




F 


Specification Of the Package Systam F 3 


















procedure INSQXI ilXEM : in 
HEAXER in 
EEAE'JS out 

-- ‘2’'^ I'csr.V'^S sv3"^r?.s ''■r.lv' 
procedure EiEMQXI (HEAEER ' in 
::em out 
EEAI'.'E out 

private 

- - S' 0 1 5 h c w n 
end S'iSXEM; 




F.4 Restrictions on Representation Clauses 

The representation clauses allowed in DEC .A.da are length, enumeration, 
record representation, and address clauses. 

In DEC Ada, a representation clause tor a genenc formal type or a type that 
depends on a generic formal type is not allowed. In addition, a representation 
clause for a composite type that has a component or subcomponent of a generic 
formal type or a type derived from a genenc formal type is not allowed. 

F.5 Restrictions on Unchecked Type Conversions 

DEC Ada supports the genenc function UNCHECKED_CONVERSION with 
the following restrictions on the class of t3npe3 involved; 

• The actual subtype corresponding to the formal type TARGET must not be 
an unconstrained array type. 

• The actual subt. pe corresponding to the formal type TARGET must not be 
an unconstrained type with discriminants. 

Further, when the target type is a type with discnminants, the value resulting 
from a call of the conversion function resulting from an instantiation of 
UXCHECK£D_CON'\’ERSIO\ is checked to ensure that the discnminants 
satisfy the constraints of the actual subtvpe. 

If the size of the source value is greater than the size of the target subtype, 
then the high order bits of the value are ignored 'truncated;; if the size of 
the source value is less than the size -if the target subtype, then the value is 
extended with zero bits to form the result value. 


F5 Restrictions on Unchecked Type Conversions 


F-12 





F.6 Conventions for Implementation-Generated Names 
Denoting Implementation-Dependent Components in 
Record Representation Clauses 

DEC Ada does not allocate implementation-dependent components in records. 

F.7 Interpretation of Expressions Appearing in Address 
Clauses ^ 

Expressions appearing in address clauses must be of the type ADDRESS 
defined in the package SYSTEM see 13.7a. 1 and F.3i. In DEC Ada. values 
of the type SYSTEM..ADDRESS are interpreted as vnrtual addresses in the 
machine's address space. 

DEC .Ada allows address clauses for objects and imported subprograms; on 
DEC OSFD or L’LTRIX systems, the simple name may also be the name of a 
single entry i.see 13.5). 

On Open VMS systems, DEC .Ada does not support interrupts as defined in 
section 13.5.1. Instead, DEC .Ada provides the pragma .AST_ENTRY and the 
.AST_ENTRY attribute as alternative mechanisms for handling asynchronous 
interrupts from the OpenVMS operating system isee 9.12a). 

On DEC OSF/1 or ULTRIX systems, DEC .Ada supports interrupts as defined 
in section 13.5.1. to allow some DEC OSF/1 or ULTRIX signals to be associated 
with task entry calls. For information on handling DEC OSF/1 or ULTRIX 
signals, see the DEC Ada Run-Time Reference Manual for DEC OSF11 Systems 
or DEC Ada Run-Time Reference Manual for ULTRIX Systems. 

F.8 Implementation Dependent Characteristics of 
In^-jut-Output Packages 

In addition to the standard predefined input-output packages 
.SEQUENTIAL_IO. DIRECT_IO, TEXT_iC rnd IO_EXCEPTIONS), DEC Ada 
procodes the following packages for handling sequential and direct files with 
mixed-tv-pe elements: 

• SEQUENTIAL_MIXED_10 ^see U 2b.4i. 

• DIRECT_MIXEDJO isee 14 2b bi 

DEC .Ada does not provide the low level mput-output package described in this 
section. 


F-:3 


Imolemeniation-DeDendeni Characteristics ot Inout-Outout Packages F8 


As specified in section 14,4, DEC Ada raises the following language-defined 
exceptions for error conditions chat occur during input-output operations: 
STATUS_ERROR, MODE_ERROR. N'.\ME_ERROR, USE_ERROR. END_ 
ERROR. DATA_ERROR, and L\YOL’T_ERROR. DEC Ada does not raise the 
language-defined exception DEVICE_ERROR; device-related errors cause the 
exception USE_ERROR to be raised. 

The exception L'SE_ERROR is raised under the following conditions: 

• If the capacity of the external file has been exceeded. ^ 

• In all CREATE operations if the mode specified’s I\_FILE. 

• In all CREATE operations if the file attributes specified by the FORM 
parameter are not supported by the package. 

• In all CREATE, OPEN. DELETE, and RESET operations if, for the 
specified mode, the environment does not support the operation for an 
external file. 

• In all NAME operations if the file has no name. 

• In the SET_LINE_LENGTH and SET_PAGE_LENGTH operations on text 
files if the lengths specified are inappropriate for the external file. 

• In text files if an operation is attempted that is not possible for reasons 
that depend on characteristics of the external file. 

DEC Ada provides other input-output packages that are available on specific 
systems. The following sections outline those packages. The following sections 
also give system-specific information about the overall set of DEC Ada 
input-output packages and input-output exceptions. 

F.8.1 DEC Ada Input-Output Packages on OpenVMS Systems 

On OpenVMS systems, the DEC Ada predefined packages and their operations 
are implemented using OpenVYlS Record Management Services 'RMS) 
rile organizations and facilities. To give users the maximum benefit of the 
underlying RMS input-output facilities, DEC Ada provides the following 
OpenVAlS-specific packages: 

• RELATIVE_IO 'see 14.2a.3 

• INDEXED_IO (see 14,2a,5i. 

• RELATIVE_MIXED_IO isee 14 2b S'. 

• INDEXED_MIXEDJO'see 14 2b.l0i. 

• AL’X_IO_EXCEPTIONS 'see 14 5a:. 


c Q 1 ncv 




r^, ,♦ n 





The following sections summarize the implementation-dependent characteris¬ 
tics of the DEC Ada input-output packages. The DEC Ada Run-Time Reference 
Manual for OpenVMS Systems discusses these characteristics in more detail. 

F.8.1.1 Interpretation of the FORM Parameter on OpenVMS Systems 

On OpenVT/IS systems, the value of the FORM parameter may be a string 
of statements of the Open VAIS Record Management Services ' RMS) File 
Definition Language (FDD, or it may be a string referring to a text file of FDL 
statements '.called an FDL file). 

t 

FDL is a special-purpose OpenVAIS language for writing file specifications. 
These specifications are then used by DEC Ada run-time routines to create 
or open files. See the DEC Ada Run-Time Reference Manual for OpenVMS 
Systems for the rules governing the FORM parameter and for a general 
description of FDL. See the Guide to OpenVMS File Applications and the 
OpenVMS Record Management Utilities Reference Manual for complete 
information on FDL. 

On OpenVMS systems, each input-output package has a default string of FDL 
statements that is used to open or create a file. Thus, in general, specification 
of a FORM parameter is not necessary: it is never necessary in an OPEN 
procedure; it may be necessary in a CREATE procedure. The packages for 
which a value for the FORM parameter must be specified in a CREATE 
procedure are as follows: 

• The packages DIRECTJO and RELATrVE_IO require that a maximum 
element 'record) size be specified in the FORM parameter if the item with 
which the package is instantiated is unconstrained. 

• The packages DIRECT_MIXED_lO and RELATIVE_MIXED_IO require 
that a maximum element (record) size be specified in the FORM parameter. 

• The packages INDEXED_IO and INDEXED_MIXED_IO require that 
information about keys be specified in the FORM parameter. 

.Anv explicit FORM specification supersedes the default attributes of the 
governing input-output package. The DEC Ada Run-Time Reference Manual 
for OpenVMS Systems describes the default external file attributes of each 
input-output package. 

The use of the FORM parameter is described for each input-output package 
in chapter 14. For information on the default FORM parameters for each 
DEC Ada input-output package and for information on using the FORM 
parameter to specify external file attnbutes. see the DEC Ada Run-Time 
Reference Manual for OpenVMS Systems. For information on FDL, see the 
Guide to OpenVMS File Applications and the OpenVMS Record Management 
Utilities Reference Manual. 




F.8.1.2 Input-Output Exceptions on OpenVMS Systems 

In addition to the DEC Ada exceptions that apply on ail systems, the following 

also apply on OpenVIVIS systems: 

• The DEC Ada exceptions LOCK_ERROR. EXISTENCE_ERROR, and KEY_ 
ERROR are raised for relative and indexed input-output operations. 

• The exception USE_ERROR is raised as follows in lelative and indexed 
files: 

- In the WRITE operations on relative or indexed fil|fs if the element in 
the position indicated has already been written. 

- In the DELETE_ELEMEN'T operations on relative and indexed files if 
the current element is undefined at the start of the operation. 

- In the UPDATE operations on indexed files if the current element is 
undefined or if the specified key violates the external file attributes. 

• The exception N.\ME_ERROR is raised as specified in section 14.4: 
by a call of a CREATE or OPEN procedure if the string given for the 
NAME parameter does not allow the identification of an external file. On 
OpenVMS systems, the value of a NAAIE parameter can be a string that 
denotes a OpenVMS file specification or a OpenVMS logical name (in either 
case, the string names an external file). For a CREATE procedure, the 
value of a NAME parameter can also be a null string, in which case it 
names a temporary external file that is deleted when the main program 
exits. The DEC Ada Run-Time Reference Manual for OpenVMS Systems 
explains the naming of external files in more detail. 

• The exception LAYOUT_ERROR is raised as specified in section 14.4: 
in text input-output by the functions COL, LINE, or PAGE if the value 
returned exceed. COLCVT' LAST. The exception LAYOLT_ERROR is also 
raised on output by an attempt to set column or line numbers in excess 
of specified maximum line or page lengths, and by attempts to output too 
many characters to a stnng. In the DEC .Vda mi.xed input-output packages, 
the exception LAYOL’T_ERROR is raised by the procedure GET_ITEM if 
no more items can be read from the file buffer; it is raised by the procedure 
PUT_ITEM if the current position exceeds the file buffer size. 


con 


n- 


nc/T' r\cc,i I II TDiv c_ 


r 1 c 


F.8.2 Input-Output Packages on DEC OSF/1 or ULTRIX Systems 

On DEC OSF/1 or ULTRIX systems, the DEC Ada predefined packages and 
their operations are implemented using DEC OSF/1 or ULTRIX file facilities. 
DEC Ada provides no additional input-output packages specifically related to 
DEC OSF/1 or ULTRIX systems. 

The following sections summarize the DEC OSF/1 or ULTRIX-specific 
characteristics of the DEC Ada input-output packages. The DEC Ada Run¬ 
Time Reference Manual for DEC OSF.' I Systems and DEC Ada Run-Time 
Reference Manual for ULTRIX Systems discuss these characteristics in more 
detail. 

F.8.2.1 Interpretation of the FORM Parameter on DEC OSF/1 Systems 

On DEC OSF/1 systems, the value of the FORAI parameter conforms to the 
description of the FORM parameter in IEEE Standard 1003.5-1992, IEEE 
Standard for Information Technology. POSIX Ada Language Interfaces. The 
value of the FORM parameter must be a character string, defined as follows: 

f c;r'rr'._irr.age : : = 

; f-eid_.oame_identif ler *> :ield_'/a-ue 

{.field na/Tie_icier.tifler »> iieta _vai'ue!! 

field value ; : fieid_valua_iaer.cifler , integer 

The field names and field values supported by DEC Ada are as follows: 

OWNER, GROUP, OTHER Determines the file permissions associated 

with the file. 

The field value may be NONE, READ, WRITE, 
EXECUTE, or any combination of the latter 
three values separated by underscores (for 
example, READ_WRITE). The field values set 
the access permissions for the created file. If 
no field value is specified, the defauL ' alue is 
RE.AD_WRITE_EXECUTE. 

The file permissions field names and values 
mav be used only in the FORM parameter of 
a (/REATE procedure. The exception USE_ 
ERROR is raised if they are used in the FOR>^ 
parameter of an OPEN procedure. 

■APPEND Determines whether or not data can be 

appended to the file. 


F-17 


Interpretation of t^-e t-ORM Parameter on DEC OSF 1 Systems F.8.2.1 


BLOCKING 


TERMINAL_INPUT 


FILE_STRUCTURE 


The field value must be either TRUE or 
FALSE. A value of TRUE causes any output 
to be written to the end of the named external 
file. If no field value is specified, the default 
value is FALSE. 

The append field name and value may be used 
only in the FORM parameter of an OPEN 
procedure. The exception USE_ERROR is 
raised if they are used in t^e FORM parameter 
of a CREATE procedure. 

Determines w'hether or not blocking input- 
output is in effect. 

The field value must be TASKS. This value 
causes a calling task (but not other tasks) to 
wait for the completion of any input-output 
operation on the file. 

Specifies how characters are read from the 
keyboard. This field applies to text files only. 

The field value must be either LINES or 
CHARACTERS. The value LINES causes 
the canonical terminal input. The value 
CHARACTERS causes noncanonical terminal 
input. If no field value is specified, the default 
value is LINES. 

The terminal input field name and value have 
no effect if the file is not opened for input or if 
the file is not opened on a terminal. 

Determines w'nether the file is first-in first-out 
(FIFO) or not. 

The field value must be either REGULAR or 
FIFO. If no field value is specified, the default 
value is REGULAR. 

The file structure field name and values may 
be used only in the FORM parameter of a 
CREATE procedure. The exception USE_ 
ERROR IS raised if they are used in the 
FORM parameter of an OPEN procedure. 

The exception USE_ERROR is also raised if 


F 3.2.1 Interoretation of the FORM Parameter on DFO OFtF-i .Sv/cfoma 


F_i a 


the field name and values are applied to files 
created or opened with operations from the 
packages DIRECT_IO and DIRECT_MIXED_ 
10 . 

FILE_DESCRIPTOR Specifies a DEC OSF/l file descriptor for the 

Ada file being opened 

The field value specifies the file descnptor. The 
file descriptor must be open. 

e 

If the file descnptor is not open, if the file 
descnptor refers to an Ada file that is already 
open, or if the file descnptor refers to an 
Ada file with an incompatible mode, then the 
exception USE_ERROR is raised. Note that 
the file descriptor option can be used only in 
the FORM parameter of an OPEN procedure. 

PAGE_TERMINATORS Determines the treatment of line, page, and 

file terminators. This field applies to text files 
only. 

The field value must be either TRUE 
or FALSE. A value of TRUE causes the 
external representation of line, page, and 
file terminators to be as defined in the DEC 
Ada run-time reference manuals. A value of 
F.ALSE causes the external file to have no page 
terminators. If no field value is specified, the 
default value is TRUE. 

(')utput to the external file occurs as 
follows when •'he field value is FALSE: line 
terminators are repr sented by the character 
■ASCII LF page terminators are omitted, and 
file terminators are represented by the physical 
end of the file The exception USE_ERROR is 
raised when an explicit call is made to the 
procedure TEXT_IO NEW__P.\GE or an explicit 
call IS made to the procedure TEXT_IO.SET_ 
LI.NE and the current line number exceeds the 
alue specified by the TO parameter. 


P_' Q 


1 n ror ot af n^n nf *q P-ar a ,1 Cvxr'*, 


C a O 1 


Input to the external file occurs as follows 
when the field value is FALSE: any occurrence 
of the character ASCII.FF is interpreted as the 
character ASCII.FF, not as a page terminator. 

BUFFER_SIZE Determines the size of the buffer used during 

file operations. 

The field value must be an integer; it specifies 

the number of bvtes in the buffer. 

t 

ELEMENT_SIZE Determines the maximum element size for a 

direct file. 

The field value must be an integer: it specifies 
the maximum number of bytes in the element. 

Each input-output package has an implementation-defined value form string 
that is used to open or create a file. Thus, in general, specification of a FORM 
parameter is not necessary. The packages for which a value for the FORM 
parameter must be specified in a CREATE procedure are as follows: 

• The package DIRECT_IO requires that a maximum eleuient size be 
specified in the FORM parameter if the item with which the package is 
instantiated is unconstrained. 

• The package DIRECT_MIXED_IO requires that a maximum element size 
be specified in the FORM parameter. 

F.8.2.2 Interpretation of the FORM Parameter on ULTRIX Systems 

On ULTRIX systems, the value of the FORM parameter must be a character 
string, defined as follows; 

acrir.g "[field '.fie*!-." 

field : : fiel3_id => field_val e 

Depending on the fields specified, the value of the FORM parameter may 
represent one or more of the following; 

• The size of the buffer used dunng file operations. The field value specifies 
the number of bytes in the buffer. 

• The maximum element size for a direct file. The field value specifies the 
maximum number of bytes in the element. 


P fl 9 9 tntorrSrotatinr^ nf rho FORM Par;pmotor nn I ii TPIV ‘^t/ctomc 


F_on 



• A DEC OSF/1 or L’LTRIX file descnptor for the Ada file being opened. The 
file descriptor must be open. 

If the file descnptor is not open, or if it refers to an Ada file that is 
already open, then the exception L'SE_ERROR is raised. Note that the 
file descnptor option can be used only in the FORM parameter of an OPEN 
procedure. 

Each input-output package has an implementation-defined value form string 
that IS used to open or c^'eate a file. Thus, in general, specification of a FORM 
parameter is not necessary. The package^ for which a valtfe for the FORM 
parameter must be specified in a CREATE procedure are as follows: 

• The package DIRECT_IO requires that a maximum element size be 
specified in the FORM parameter if the item with which the package is 
instantiated is unconstrained. 

• The package DIRECT_MIXED_IO requires that a maximum element size 
be specified in the FORM parameter. 

The use of the FORM parameter is descnbed for each input-output package in 
chapter 14. For information on using the FORM parameter to specify external 
file attributes, see the DEC Ada Run-Time Reference Manual for DEC OSF11 
Systems or DEC Ada Run-Time Reference Manual for ULTRIX Systems. 

F.8.2.3 Input-Output Exceptions on DEC OSF/1 or ULTRIX Systems 

In addition to the DEC Ada exceptions that apply on all systems, the following 
also apply on DEC OSF/1 or ULTRIX systems; 

• The exception NAME_ERROR is raised as specified in section 14.4: by a 
call of a CREATE or OPEN procedure if the string given for the NAME 
parameter does not allow the identification of an external file. On DEC 
OSF/1 or ULTITX systems, the value of a NAME parameter can be a string 
that denotes an DEC OSF/1 or ULTRIX file specification. For a CREATE 
procedure, the value of a NAME parameter can also be a null string, in 
which case it names a temporary external file that is deleted when the 
mam program exits. The DEC Ada Run-Time Reference Manual for DEC 
OSF I Systems or DEC Ada Run-Ume Reference Manual for ULTRTX 
Systems explains the naming of external files in more detail. 

• The exception LAYOUT_ERROR is raised as specified in section 14.4: 
in text input-output by the functions COL. LINE, or PAGE if the value 
returned exceeds COUNT' LAST. The exception LAYOUT_ERROR is also 
raised on output by an attempt to set coium.n or line numbers in excess 
of specified maximum line or page lengths, and by attempts to output too 
many characters to a stnng. In the DEC Ada mixed input-output packages, 
the exception LAYOUT_ERROR is raised by the procedure GET_ITEM if 


F-21 


inDut-OutDut E.xcecit-Ors or DEC GSF 1 or IJl TRIX Svstom'^ F fl ? T 


no more items can be read from the file buffer; it is raised by the procedure 
PUT_i i'EM if the current position exceeds he file buffer size. 

F.9 ether Implementation Characteristics 

Implementation characteristics relating to the definition of a mam program, 
various numeric ranges, and implementation limits are summanzed in the 
following sections. 

F.9.1 Definition of a Main Program r 

DEC Ada permits a library unit to be used as a (iiam program under the 
following conditions: 

• If it is a procedure with no formal parameters. 

On OpenVCvIS systems, the status returned to the OpenVMS envdronment 
upon normal completion of the procedure is the value 1. 

On DEC OSF/1 or CLTRIX systems, the status returned to the DEC OSF/1 
or CLTRIX environment upon normal completion of the procedure is the 
value 0. 

On DEC OSF/1 systems, the status returned to the DEC OSF/1 
environment when unhandled exceptions have been raised is the value 
42. 

• If it is a function with no formal parameters whose returned value is of 
a discrete type. In this case, the status returned to the operating-system 
envnronment upon normal completion of the function is the function value. 

• If it IS a procedure declared with the pragma EXPORT_VALUED_ 
PROCEDURE, and it has one formal out parameter that is of a discrete 
type. In this ca-e, the status returned to the operating-system environment 
upon normal completion of the procedure is the value of the first (and only) 
parameter. 

.Vote that when a main function or a main procedure declared with the pragma 
EXPORT_VALUED_PROCEDURE returns .i discrete value whose size is 
less than 32 bits (on OpenVC^IS V.AX or CLTRIX systems; or 64 bits ion AXP 
systems), the value is zero- or sign-extended as appropriate. 


F 9 2 Values of Integer Attributes 


F-22 


F.9.2 Values of Integer Attributes 

The ranges of values for integer types declared in the package ST.\NDARD are 
as follows: 


Integer type 

Range 

Systems on which It 
applies 

SHORT_SHORT_INTEGER 

-12S 127 

.^1 

SHORT_INTEGER 

-3276’< 32767 

^.XJ! 

INTEGER 

-2147483648 . 2147483647 

.\J1 

LONG_INTEGER 

-2U7483648 . 2147483647 

OpenVMS VAX 
■AXP 




\ / T . I ■ o r- /-V # 1 


r" n 



For the applicable input-output packages, the ranges of values for the types 
COUNT and POSITIVE_COUNT are as follows: 

COUNT 0 .. INTEOER E.\ST 

POSITEVT^COUNT 1 INTEGER LUST 

For the package TEXT_IO. the ranize of values for the type FIELD is as follows: 
FIELD 0 ,, INTEGER L.-VST 

F.9.3 Values of Floating Point Attributes f 

DEC Ada provides the follownng floating point types in the package 
STANDARD. Additional floating point types are declared in the package 
SYSTEM (see 13.7b. 1 and 13.7b.2^ 


Type 

Default Representation 

Systems on which 

It applies 

Section 

FLOAT 

F_fioar;r.e 

IEEE single float 

(DoenV'lMS 

DEC OSF/1 or 
ULTRDC 

3.5.7 

LONG.FLOAT 

G_floanng 

I^EE double float 

OpenVNIS 

DEC OSF'l or 
ULTREX 

3.5.7 

LONG_LONG_FLOAT 

H_floating 

IEEE double float 

Open VMS VAX 

DEC OSF 1 or 
ULTRK 

3.5.7 


The values of the floating point attnbutes for the different floating point 
representations appear in the following tables. 


F9 3 Values of Fioatina Point Attributes 


F-24 




FJIoatIng Characteristics 


Attribute 

FJIoatIng value and approximate decimal equivalent 
(where applicable) 

DIGITS 

6 

M.\NTISSA 

21 

EM.AX 

r 

EPSILON 

L6#0,1000 000#e-4 

approximately 

9,53674E-07 

SMALL 

16#0.8000 000#(^21 

approximately 

2.38494E-26 

L.ARGE 

16#0.FFFF F80#e+21 

approx} mately 

L93428E+25 

S.\FE_E\LAX 

127 

SAFE SMALL 

16#0,1000 000#e-31 

approximately 

2.93874E-39 

SAFE LARGE 

16#0.7FFF FC0#e+32 

approximately 

1.70141E+38 

FIRST 

-16#0.7FFF FF8#e+32 

approximately 

-l,7014lE+38 

LAST 

16#0.7FFF FF8#e+32 

approximately 

1.70141E+38 

MACHINE_FL\D[X 

2 

MACHINE^NLAN'TISSA 

24 

MACHL\E_ENLAX 

127 

MACHINE.EMIN 

-127 

MACHINE.ROL'NDS 

True 

MACHINE _OVTRFLOWS 

True 


F.9.3.2 DJioating Characteristics 


Attribute 

O_floatlng value and approximate decimal equivalent 
(where applicable) 

DIGITS 

9 


MANTISSA 

31 


EMAX 

124 

f 

EPSILON 

approximately 

16#0.4000 0000 0000.000#e-7 
9.313225:461548E-10 


SMALL 

approximately 

16#0.8000 0000 0000 000#e-31 
2.3509887016446E-38 


L.AEGE 

approximately 

16#0,FFFF FFFE 0000 000#e+31 
2.1267647922655Ea37 


S.4FE_EMAX 

127 


S.XFE.SMALL 

approximately 

16#0.1000 0000 0000 000#e-31 
2.9387358770557E-39 


s afe_large 

approxiTnately 

16#0.7FFF_FFFF_0000_000#e+32 

1.7014118338124E+38 


FIRST 

approximately 

-16#0.7FFF FFFF FFFF.FF8#e+32 
-1.7014118346047E-I-38 


L\ST 

approximately 

16#0.7FFF_FFFF.FFFF_FFS#e-32 

1.7014118346047E+38 


MACHINE_R.M)IX 

2 


MACHINE.MANTISSA 

56 


MACHINE.EMAX 

127 


MACHINE.EMIN 

-127 


MACHINE^ROL'NDS 

True 


MACHINE .OVERFLOWS 

True 



p q T p n finatinn Charartori'^fir': 


F-P6 


F.9.3.3 GJIoating Characteristics 


Attribute 

G fioatlng value and approximate decimal equivalent 
(where applicable) 

DIGITS 

15 


M.4NTISSA 

51 


EM.AX 

204 

f 

EPSILON 

approximateiy 

16#0,4000 0000 0000 00#e-12 
3.88i:8419:OOlE-l6 


SMALL 

approximately 

I6#0,8000_0000_0000_00#e-51 

1.9446922743.32E-62 


LARGE 

approximately 

16#0.FFFF_FFFF_FFFF_E0#e+51 

2.571100870814E-.61 


S.AFE_E\LAX 

1023 


safe_small 

approximately 

16#0.1000_0000_0000_00#e-255 
5.562684846268E-309 


safe_large 

approximately 

16#0.7FFF FFFF_FFFF_F0#e+256 
8.988465674312E+307 


FIRST 

approximately 

-16#0.7FFF FFFF FFFF_FC#e+256 
-8.988465674312E+307 


L*\ST 

approximate! V 

16#0.7FFF FFFF_FFFF_FC#e+256 
8.988465674312E+307 


MACHINE.RADIX 

2 


MACHINE .MANTISSA 

53 


MACHINE.EMAX 

1023 


MACHINE.EMIN 

-1023 


MACHINE.ROL'NDS 

True 


MACHINE .O^TIRFLOWS 

True 



c 


♦i/^arir'n r'.hara/^tQnctiP Q 


F.9.3.4 HJIoating Characteristics 


Attribute 

H floating value and approximate decimal equivalent 
(where applicable) 

DIGITS 

33 

MANTISSA 

111 

EM.AX 

444 f 

EPSILON 

approximately 

L6#0.4000 0000 0000 0000 0000 0000 0000 0#e-27 
7.:037197775489434122239117703397E“-34 

SMALL 

approximately 

16#0.8000 0000_0000_0000_0000_0000_0000_0#e-lll 

1.100656821463791S210934318020936E-134 

L.ARGE 

approximately 

16#0,FFFF FFFF FFFF FFFF FFFF FFFF FFFE_0#e+lll 
4.5427420268475-t30659332737993000E+133 

SAFE_ENLAX 

16383 

SAFE.SMALL 

approximately 

16#0.1000 0000 0000_0000_0000_0000_0000_0#e-4095 
8.4052578577802337656566945433044E-A933 

bAF ENLARGE 

approximately 

16#0.7FFF FFFF FFFF FFFF_FFFF_FFFF_FFFF_0#e+4096 
5.9486574767861588254287966331400E+4931 

FIRST 

approximately 

-16#0.7FFF FFFF FFFF.FFFF.FFFF_FFFF_FFFF_C#e+4096 
-5.9486574767861588254287966331400E+4931 

L.\ST 

approximately 

16#0.7FFF FFFF FFFF FFFF FFFF_FFFF_FFFF_C#e+4096 
5.9486574767861588254287966331400Ei-4931 

MACHINE_RADIX 

2 

MACHINE_NLANTISSA 

113 

MACHINE^EMAX 

1-383 

MACHINE_EMIN 

-16383 

MACHINE_ROL'NDS 

True 

MACHINE .OVERFLOWS 

True 


rn jioaiing ^^naracibribucb 


i—dO 



F.9.3.5 IEEE Single Float Characteristics 


Attribute 

IEEE single float value and approximate decimal equivalent 
(where applicable) 

DIGITS 

6 

MANTISSA 

21 

EM.MX 

84 , 

EPSILON 

16#0.1000 000«<:^4 

approximately 

9.53674E-0: 

3\L4LL 

16#0.8000 OOOas^'il 

approxmately 

2.5849E-26 

L.ARGE 

16#0,FFFF F^OxE-’l 

approxmately 

1.9342SE+25 

S.AFE.EMAX 

125 

3.AFE_3MALL 

approxmately 

1.i:549E-38 

S.4FE .LARGE • 

approxmately 

4,25353E+37 

FIRST 

approxmately 

-3.40282E*38 

L.\ST 

approxmately 

3.40282E+38 

MACHINE_R.ADIX 

2 

MACHINE_.\LM\TISSA 

24 

MACHINE_E\LAX: 

128 

MACHINE.EMIN 

-125 

MACHINE.ROL'NDS 

True 

MACHINE _0\'ERFL0WS 

True 


F-29 


EEE S'-g e Fbat Characteristics F93.5 


F.9.3.6 IEEE Double Float Characteristics 


IEEE double float value and approximate decimal equivalent 


Attribute 

(where applicable) 

DIGITS 

15 

MANTISSA 

51 

EM.AX 

204 

EPSILON 

approximately 

S,88178419T0012E-16 

SNLALL 

approximately 

1.9446922743316E-62 

L.AIGE 

approximately 

2.5711008708144E-01 

SAFE_E.\LAX 

1021 

SAFE .SMALL 

approximately 

2.22507385850720E-.308 

SAFE .LARGE 

approximately 

2.2471ie4185T79E+307 

FIRST 

approximately 

-1.7976931348623E-^308 

L.A3T 

approximately 

1.7976931348623E+308 

MACHINE .FLADK 

2 

MACHINE.NLANTISSA 

53 

MACHINE.ENLAX 

1024 

MACHINE.EMIN 

-1021 

MACHINE.ROLNDS 

True 

MACHIN E_0\’FRFLOWS 

True 


F.9.4 Attributes of Type DURATION 

The values of the significant attributes of the type DL'Pw\TION are as follows: 

DLTL\T!ON'DELTA 0.0001 

DL'RATION''S\L\LL 2"" 

DLHATION' FIRST -131072.0000 


F 9A Artobutes of Type DURATION 


F-30 




DL'RATION'LAST 131071.9999 

DLTL\TION''LARGE 131071,9999 

F.9.5 Implementation Limits 


Limit 

DEC 

systems 
on which it 
applies^ 

Value 

Maximum number of formal paramerers m, a 
subprogram or entr\- declaranon mat are af an 
unconstrained record type 

.Ml 

32 

Maximum idennfier length mumber of characters ' 

.Ml 

255 

Maximum number of characters ;n a source im.e 

.Ml 

255 

Maximum collection size mumber of bytes' 

OoenV"MS 

L'LTRIX 

2'" -1 


DEC OSF/1 

2'^-! 

Maximum number of discriminants for a record type 

Ml 

245 

Maximum number of formal parameters in an entry or 
subprogram declaration 

Ml 

246 

Maximum number of dimensions m an array type 

Ml 

255 

Maximum number of library units and subunits :n a 
compilation closure' 

.Ml 

4095 

Maximum number of library units and suDunits .n an 
execunon closure' 

Ml 

16383 

Maximum number of objects declared vcith the or.acma 
CO.\LMON_OBJECT or PSECT.OBJECT 

.Ml 

32 i 57 

Maximum number of enumieration literals ;n an 
enumeration type definition 

.Mi 

65535 

Maxmum number of lines in a source “^.le 

Ml 

65534 

Maxmum number of bits in any object 

.Ml 

■A' _ 1 

Maximunn size of the static portion -jt a -tacK. frame 
approximate i 

.Ml 

2J0 

‘The compilation closure oi a given urc.t :i tr.o - ..ta, .;.n: 

directly and indirectly. 

.13 '.nat ir.e ^ven 

unit depends on. 

-The execution closure of a given unit •..ne .urr.pilaiiori ^..;su 
library bodies and subunitsc 

re p:u3 aii associated secondary units 


1 


I rr*o m Q nf 31 lo n I 


C Q C 


Predefined Language Pragmas 


f 

This annex defines the pragmas LIST. PAGE, and OPTIMIZE, and summanzea 
the definitions given elsewhere of the remaining language-defined pragmas. 

The DEC Ada pragmas IDENT and TITLE are also defined in this annex. 


Pragma Meaning 

.AST_ENTRY On OpenVAIS systems only. 

Takes the simple name of a single 
entry as the single argument: at most 
one AST_ENTRY pragma is allowed 
for any given entry. This pragma 
must be used in combination with the 
AST_ENTRY attribute, and is only 
allowed after the entry declaration and 
in the same task type specification or 
single task as the entry to which it 
applies. This pragma specifies that the 
given entry may be used to handle an 
OpenVCVIS asynchronous system trap 
'.■\ST) resulting from an Open VMS 
system service call. The pragma does 
not affect normal use of the entry i see 
9.12a). 

C0MM0X_0BJECT Takes an internal name denoting 

an object, and optionally takes an 
external designator ( the name of a 
linker storage area) and a size as 
arguments. This pragma is only 
allowed at the place of a declarative 
item, and must apply to a variable 
declared by an earlier declarative 




COMPONENT 


CONTROLLED 


item of the same declarative part or 
package specification. The variable 
must have a size that is known at 
compile time, and it must not require 
implicit initialization. This pragma is 
not allowed for objects declared with 
a renaming declaration. This pragma 
enables the shared use of objects that 
are stored in overlaid storage areas 
see 13.9a.2.3). t 

ALIGNMENT Takes an alignment choice and 

optionally the simple name of an array 
or record type as arguments. When no 
simple name is specified, the pragma 
must occur within a declarative part or 
package specification, and the effect of 
the pragma extends to types declared 
from the place of the pragma to the 
end of the innermost declarative part 
or package specification in which 
the pragma was declared. When a 
simple name is specified, the pragma 
and the type declaration must both 
occur immediately within the same 
declarative part, package specification, 
or task specification; the declaration 
must occur before the pragma. The 
position of the pragma and the 
restrictions on the named type are 
governed by the same rules as those for 
a representation clause. Thi_ pragma 
specifies the kind of alignment used for 
the components of the array or record 
tvpes to which it applies (see 13.1a). 

Takes the simple name of an access 
t>'pe as the single argument. This 
pragma is only allowed immediately 
wnthin the declarative part or package 
specification that contains the 
declaration of the access t>'pe; the 
declaration must occur before the 
pragm.a. This pragma is not allowed for 


EL.\BORATE 


EXPORT_EXCEPTION 


a derived tvpe. This pragma specifies 
that automatic storage reclamation 
must not be performed for objects 
designated by values of the access type, 
except upon leaving the innermost 
block statement, subprogram body, or 
task body that encloses the access type 
declaration, or after leaving the main 
program • see 4.81 

Takes one or more simple names 
denoting library units as arguments. 
This pragma is only allowed 
immediately after the context clause 
of a compilation unit i before the 
subsequent library unit or secondary 
unit). Each argument must be 
the simple name of a library unit 
mentioned by the context clause. 

This pragma specifies that the 
corresponding library unit body 
must be elaborated before the 
given compilation unit. If the given 
compilation unit is a subunit, the 
library unit body must be elaborated 
before the body of the ancestor library 
unit of the subunit (see 10.5). 

On Open'V'MS systems only. 

Takes an internal name denoting an 
exception, and optionally takes an 
external designator 'the name of a 
linker global symbol), a form (ADA 
or VAIS), and a code (a static integer 
expression that is interpreted as a 
condition code) as arguments. A code 
value must be specified when the 
form is ^TvIS 'the default if the form 
IS not specified). This pragma is only 
allowed at the place of a declarative 
item, and must apply to an exception 
declared by an earlier declarative 
Item of the same declarative part 


or package specification; it is not 
allowed for an exception declared 
with a renaming declaration or for an 
exception declared in a generic unit. 
This pragma permits an Ada exception 
to be handled by programs written in 
another programming language i see 
13.9a.3.2i. 

EXPORT_FX,'NCTIO.V Takes an internal i^me denoting 

a function, and optionally takes an 
external designator < the name of a 
linker global symbol), parameter types, 
result type, parameter mechanisms, 
and result mechanism as arguments. 
This pragma is only allowed at the 
place of a declarative item, and 
must apply to a function declared 
by an earlier declarative item of the 
same declarative part or package 
specification. In the case of a function 
declared as a compilation unit, the 
pragma is only allowed after the 
function declaration and before 
any subsequent compilation unit. 

This pragma is not allowed for a 
function declared with a renaming 
declaration, and it is not allowed for a 
generic function (it may be given for 
a generic instantiation). This pragma 
permits an Ada function to be called 
from, a program written in another 
programm. ig language 'see 13.9a. 1.3). 

EXPORT_OBJECT Tc-'ces an internal name denoting an 

object, and optionally takes an external 
designator 'the name of a linker global 
symbol) and size option (a linker 
absolute global symbol that will be 
defined m the object module—useful on 
OpenAAIS systems only) as arguments. 
This pragma is only allowed at the 
place of a declarative item, and must 
apply to a constant or a variable 


B-4 


declared by an earlier declarative 
Item of the same declarative part or 
package specification; the declaration 
must occur at the outermost level of a 
library package specification or body, 
The object to be exported must have 
a size that is known at compile time. 
This pragma is not allowed for objects 
declared with a renaming declaration, 
and is not allowed fn a generic unit. 
This pragma permits an Ada object to 
be referred to by a routine wntten in 
another programming language (see 
13.9a.2.2). 

EXPORT_PROCEDURE Takes an internal name denoting 

a procedure, and optionally takes 
an external designator ithe name of 
a linker global symbol), parameter 
tyiDes. and parameter mechanisms 
as arguments. This pragma is only 
allowed at the place of a declarative 
item, and must apply to a procedure 
declared by an earlier declarative 
item of the same declarative part or 
package specification. In the case of a 
procedure declared as a compilation 
unit, the pragma is only allowed 
after the procedure declaration and 
before any subsequent compilation 
unit- This pragma is not allowed for 
,1 prc-..cdure declared with a renaming 
declaration, and is not allowed for a 
generic procedure 'it may be given for 
a generic instantiation). This pragma 
permits an Ada routine to be called 
from a program wntten in another 
programming language ‘see 13.9a.1.3). 

EXPORT_VALUED_PROCEDL'RE Takes an internal name denoting 

a procedure, and optionally takes 
an external designator ‘the name of 
a linker global symbol), parameter 
types, and parameter mechanisms 


B-5 



FLOAT 


I DENT 


as arguments. This pragma is only 
allowed at the place of a declarative 
Item, and must apply to a procedure 
declared by an earlier declarative item 
of the same declarative part or package 
.specification. In the case of a procedure 
declared as a compilation unit, the 
pragma is only allowed after the 
procedure declaration and before any 
subsequent compilAion unit. The first 
or onlyi parameter of the procedure 
must be of mode out. Tins pragma is 
not allowed for a procedure declared 
with a renaming declaration and is not 
allowed for a generic procedure (it may 
be given for a generic instantiation). 
This pragma permits an Ada procedure 
to behave as a function that both 
returns a value and causes side effects 
on its parameters when it is called 
from a routine written in another 
programming language (see 13.9a.1.3). 

REPRESENTATION On OpenVAIS and DEC OSF./l systems 

only. 

Or Open\'MS VAX systems, takes 
VAX_FLOAT as the single argument. 

On Open VMS AXP systems, takes 
either VAX_FLOAT or IEEE_FLOAT 
as the single argument; the default is 
V.AX_FLOAT. On DEC OSF/1 systems, 
takes lEEE_FLOAT as the single 
argument. This pragma is only allowed 
at ''e start of a compilation, before 
the first compilation unit (if any) of 
the compilation. It specifies the choice 
of representation to be used for the 
predefined floating point types in the 
package ST.AND.ARD (see 3.5.7a). 

Takes a string literal of 31 or fewer 
characters as the single argument. The 
pragma IDENT has the following form: 


B—6 


pragma 


This pragma is allow<jd only m 
the outermost declarative part or 
declarative items ot’a compilation unit 
The given string is used to identify 
the object module associated with the 
compilation unit in which the pragma 
IDENT occurs. 

On Open^'NIS syste^n s only. 

Takes an internal name denoting an 
exception, and optionally takes an 
external designator ithe name of a 
linker global svmbol), a form (ADA 
or and a code 'a static integer 

expression that is interpreted as a 
condition code,' as arguments. A code 
value is allowed only when the form 
IS VdVlS (the default if the form is 
not specified). This pragma is only 
allowed at the place of a declarative 
Item, and must apply to an exception 
declared by an earlier declarative item 
of the same declarative part or package 
specification; it is not allowed for an 
exception declared woth a renaming 
declaration. This pragma permits a 
non-.Ada exception (most notably, an 
OpenVArlS condition) to be handled by 
an .Ada program see 13.9a.3.1j. 

Takes an internal name denoting 
a function, and optionally takes an 
-xt'mal designator 'the name of a 
linker global symbol), parameter types, 
result ty^De, parameter mechanisms, 
.ind result mechanism as arguments. 
On OpenVAIS systems, a first optional 
parameter is also available as an 
argument. The pragma INTERFACE 
must be used with this pragma 
see 13.9). This pragma is only allowed 
at the place of a declarative item, and 


must apply to a function declared 
by an earlier declarative item of the 
same declarative part or package 
specification. In the case of a function 
declared as a compilation unit, the 
pragma is only allowed after the 
function declaration and before any 
subsequent compilation unit. This 
pragma is allowed for a function 
declared with a rerfeming declaration; 

It IS not allowed for a generic function 
or a genenc function instantiation. 

This pragma permits a non-Ada 
routine to be used as an .\da function 
see 13.9a.1.1). 

IMPORT_OBJECT Takes an internal name denoting 

an object, and optionally takes an 
external designator ithe name of a 
linker global symbol) and size (a linker 
absolute global symbol that will be 
defined in the object module—useful on 
OpenVTVIS systems only) as arguments. 
This pragma is only allowed at the 
place of a declarative item, and 
must apply to a variable declared 
by an earlier declarative item of the 
same declarative part or package 
specification. The variable must have 
a size that is known at compile time, 
and It cannot have an initial value. 
This pragma is not allowed for objects 
declared with a renaming declaration. 
This pragma permits storage declared 
in a non-Ada routine to be referred to 
by an .\da program 'see 13.9a.2.1). 

IMPORT_PROCEDURE Takes an internal name denoting 

a procedure, and optionally takes 
an external designator 'the name of 
a linker global svanbol), parameter 
types, and parameter mechanisms as 
arguments. On OpenVAlS systems, 
a first optional parameter is also 


B-8 


available as a; argument. The pragma 
INTERFACE must be u.-ed with this 
pragma ;see 13.9', This pragma is only 
allowed at the place of a declarative 
Item, and must apply to a procedure 
declared by an earlier declarative 
Item of the same declarative part or 
package specification. In the case of a 
procedure declared as a compilation 
unit, the pragma i/only allowed after 
the procedure declaration and before 
any subsequent compilation unit. This 
pragma is allowed for a procedure 
declared with a renaming declaration; 
it is not allowed for a generic procedure 
or a generic procedure instantiation. 
This pragma permits a non-Ada routine 
to be used as an Ada procedure 
fsee 13.9a. 1.1). 

IMP0RT_V’ALUED_PR0CEDL’RE Takes an internal name denoting 

a procedure, and optionally takes 
an external designator (the name of 
a linker global symbol), parameter 
types, and parameter mechanisms as 
arguments. On Open VMS systems, 
a first optional parameter is also 
available as an argument. The pragma 
INTERFACE must be used with this 
pragma (see 13.9). This pragma is only 
allowed at the place of a declarative 
item, and must apply to a procedure 
declared by an earlier declarative item 
of fhe same declarative part or package 
specincation. In the case of a procedure 
declared as a compilation unit, the 
pragma is only allowed after the 
procedure declaration and before any 
subsequent compilation unit. The first 
'or only) parameter of the procedure 
must be of mode out. This pragma 
is allowed for a procedure declared 
with a renaming declaration: it is not 


R_Q 


INLINE 


INLINE 


allowed for a generic procedure. This 
pragma permits a non-Ada routine that 
returns a value and causes side effects 
on its parameters to be used as an Ada 
procedure ■'see 13.9a. l.L. 

Takes one or more names as 
arguments: each name is either the 
name of a subprogram or the name of 
a generic subprogram. This pragma 
is only allowed at the place of a 
declarative item in a declarative part 
or package specification, or after a 
library unit in a compilation, but before 
any subsequent compilation unit. This 
pragma specifies that the subprogram 
bodies should be expanded inline at 
each call whenever possible; in the case 
of a generic subprogram, the pragma 
applies to calls of its instantiations 
' see 6.3.2). 

GENERIC Takes one or more names as 

arguments; each name is either the 
name of a generic declaration or the 
name of an instance of a generic 
declaration. This pragma is only 
allowed at the place of a declarative 
item in a declarative part or package 
specification, or after a library unit 
in a compilation, but before any 
subsequent compilation unit. Fa-'h 
argument m.ust be the simple name 
of a generic subprogram or package, 
or a inongenenci subprogram or 
package that is an instance of a generic 
subprogram or package declared by 
an earlier declarative item of the 
same declarative part or package 
specification. This pragma specifies 
that inline expansion of the generic 
body IS desired for each instantiation 
of the named generic declarations or 
of the particular named instances; 


INTERFACE 


INTERFACE 


the pragma does not apply to calls of 
instances of generic subprograms 
: see 12. lat 

Takes a language name and a 
subprogram name as arguments. This 
pragma is allowed at the place of a 
declarative item, and must apply in 
this ca.^e to a subprogram declared 
by an earlier declaiative item of the 
same declarative part or package 
specification. This pragma is also 
allowed for a library unit; in this case 
the pragma must appear after the 
subprogram declaration, and before 
any subsequent compilation unit. This 
pragma specifies the other language 
iand thereby the calling conventions) 
and informs the compiler that an 
object module will be supplied for the 
corresponding subprogram (see 13.9). 

In DEC Ada, the pragma INTERFACE 
is required in combination with the 
pragmas IMPORT_FUNCTION, 
IMPORT_PROCEDURE, IMPORT_ 
V.ALUED_PROCEDURE, and 
INTERFACE_NAME when any of those 
pragmas are used (see 13.9a.1). 

N.VME Takes an internal name and an 

external name as arguments. The 
internal name may be an Ada simple 
name that denotes a subprogram or 
an v-bject. If the declared entity is a 
function, the internal name may be a 
string literal that denotes an operator 
symbol. The external name may be any 
string liLeral; the literal is used as a 
linker global symbol that is associated 
with the external subprogram or 
object. This pragma is only allowed 
at the place of a declarative item, 
and must apply to an entity declared 


by an earlier declarative item of the 
same declarative part or package 
specification 

If this pragma applies to a subprogram, 
then the pragma INTERFACE must 
also apply ^se*^ 13.9i. If a subprogram 
has been declared as a compilation 
unit, the pragma is only allowed after 
the subprogram de^aration and before 
any subsequent compilation unit. This 
pragma is allowed for subprograms 
declared with a renaming declaration. 
This pragma is not allowed for a 
generic subprogram or a generic 
subprogram instantiation. 

If this pragma applies to an object, 
then the size of the object must be 
known at compile time. This pragma is 
not allowed for an object declared with 
a renaming declaration. 

This pragma associates an external 
symbol with the internal Ada name for 
a subprogram or object (see 13.9b). 

list Takes one of the identifiers ON or 

OFF as the single argument. This 
pragma is allowed anywhere a pragma 
is allowed. It specifies that listing of 
the compilation is to be continued or 
suspended until a LIST pragma with 
the opposite argument is given within 
the same compilation. The pragma 
!t: If is always listed if the compiler is 
producing a listing. 

LONG_FLOAT On OpenVAIS systems only. Also, 

the value of the pragma FLOAT_ 
REPRESENTATION must be VAX_ 
FLOAT. 


B-12 


MAJN.STORAGE 


MEMORY_SIZE 


Takes either D_FLOAT or G_FLOAT 
as the single argument. The default 
IS G_FLOAT. This pragma is only 
allowed at the start of a compilation, 
before the first compilation unit 
I'f any ) of the compilation. It specifies 
the choice of representation to be used 
for the predefined type LONG_FLOAT 
in the package STANDARD, and for 
floating point type declarations with 
digits specified in the range 7 .. 15 
■ see 3.5.7b). 

On OpenVNlS V.AX systems only. 

Takes one or two nonnegative static 
simple expressions of some integer type 
as arguments. This pragma is only 
allowed in the outermost declarative 
part of a library subprogram; at most 
one such pragma is allowed in a library 
subprogram. It has an effect only when 
the subprogram to which it applies is 
used as a main program. This pragma 
causes a fixed-size stack to be created 
for a main task ! the task associated 
with a main program), and determines 
the number of storage units (bytes) 
to be allocated for the stack working 
storage area or guard pages or both. 
The value specified for either or both 
the working storage area and guard 
pages IS rounded up to an integral 
number of pages. A value of zero for 
ttu working storage area results in the 
use of a default size; a value of zero for 
the guard pages results in no guard 
storage. A negative value for either 
working storage or guard pages causes 
the pragma to be ignored (see 13.2b). 

Takes a numeric literal as the single 
argument. This pragma is only allowed 
at the start of a compilation, before the 


B-13 


first compilation unit uf any: of the 
compilation. The effect of this pragma 
1.S to use the value of the specified 
numeric literal for the definition of the 
named number MEMORY_SIZE 
see 13.7i 

OPTIMIZE Takes one of the identifiers TIME 

or SPACE as the single argument. 

This pragma is onl^ allowed within a 
declarative part and it applies to the 
block or body enclosing ‘he declarative 
part. It specifies whether time or space 
IS the primary' optimization cnterion. 

In DEC Ada. this pragma is only 
allowed immediately wthin a 
declarative part of a body declaration. 

PACK Takes the simple name of a record or 

array type as the single argument. The 
allowed positions for this pragma, and 
the restnctions on the named type, 
are governed by the same rules as for 
a representation clause. The pragma 
specifies that storage minimization 
should be the main cnterion when 
selecting the representation of the 
given type ' see 13.1). 

page This pragma has no argument, and is 

allowed anywhere a pragma is allowed. 
It specifies that the program text which 
follows the pragma should start on a 
new page ' if the compiler is currently 
producing a listing;. 

PRIORITY Takes a static expression of the 

predefined integer subtype PRIORITY 
as the single argument. This pragma is 
only allowed within the specification of 
a task iinit or immediately withirt the 
outermost declarative part of a mam 
program. It specifies the prionty of the 


B-14 


PSECT_OBJECT 


SFL\RED 


SH.\KE_GENERIC 


task ‘Or tasks of the task type; or the 
pnorii^, of the main program isee 9.S). 

On OpenVMS systems only. 

Has the same syntax and the same 
effect as the pragma C9MM0N_ 
OB.JECT .see 13,9a.2.3). 

Takes the simple name of a variable as 
the single argumer^. This pragma is 
allowed only for a vanable declared by 
an object declaration and whose type 
IS a scalar or access type; the vanable 
declaration and the pragma must 
both occur nn this order; immediately 
within the same declarative part or 
package specification. This pragma 
specifies that every read or update of 
the vanable is a s; nchronization point 
for that vanable. .An implementation 
must restrict the objects for which 
this pragma is allowed to objects 
for which each of direct reading and 
direct updating is implemented as an 
indivisible operation (see 9.11). 

On OpenV'AlS systems only. 

Takes one or more names as 
arguments; each name is either the 
name of a genenc declaration or the 
name of an instance of a generic 
declaration. This pragma is only 
allowed at the place of a declarative 
;v.em in a declarative part or package 
'pecification. or after a library unit in a 
compilation, but before any subsequent 
compilation unit. Each argument 
either must be the simple name of a 
generic subprogram or package, or it 
must be a inongeneric) subprogram 
or package that is an instance of a 
genenc subprogram or package. If the 
argument is an instance of a genenc 


B--5 


STOR.AGE 


SUPPRESS 


'ubprogram or package, then it must 
be declared by an earlier declarative 
Item of the .same declarative part or 
package .specification. This pragma 
'pecifies that generic code sharing is 
desired for each instantiation of the 
named genenc declarations or of the 
particular named instances 'see 12.1bj. 

UNIT Takes a numeric lifcral as the single 

argument. This pragma is only allowed 
at the start of a compilation, before the 
first compilation unit (if any) of the 
compilation. The effect of this pragma 
IS to use the value of the specified 
numeric literal for the definition of the 
named number STORAGE_UNIT 
see 13.7). 

In DEC Ada. the only argument 
allowed for this pragma is 8 (bits). 

Takes as arguments the identifier 
of a check and optiona'.ly also the 
name of either an object, a type or 
subtype, a subprogram, a task unit, or 
a genenc unit. This pragma is only 
allowed either immediately within a 
declarative part or imm.ediately within 
a package specification. In the latter 
case, the only allowed form is with a 
name that denotes an entity (or several 
overloaded subprograms! declared 
■mmediately within the package 
'pp'-ification. The permission to omit 
the gven check extends from the 
place of the pragma to the end of the 
declarative regon associated with the 
innermost enclosing block statement or 
program unit. For a pragma gven in a 
package specification, the permission 
extends to the end of the scope of the 
named entity. 


Q_i a 


SUPPRESS_.\LL 


SYSTEM.N.AME 


T.\SK_STORAGE 


[f the pratjma ..icludes a name, the 
permission to omit the gi.en check 
IS further restncted: it is given only 
for operations on the named object 
or on all objects of the base type of a 
named type or subtype; for calls of a 
named subprogiam. for activations of 
tasks of the named task type; or for 
instantiations of the given genenc unit 
^ee 11.7). ^ 

This pragma has no argument and is 
only allowed following a compilation 
unit. This pragma specifies that 
all run-time checks in the unit are 
suppressed 'see 11.7). 

Takes an enumeration literal as the 
single argument. This pragma is only 
allowed at the start of a compilation, 
before the first compilation unit 
if any) of the compilation. The effect of 
this pragma is to use the enumeration 
literal with the specified identifier 
for the definition of the constant 
SYSTEM_NAME. This pragma is 
only allowed if the specified identifier 
corresponds to one of the literals of the 
typie N'.-YME declared in the package 
SYSTEM isee 13.7). 

Takes the simple name of a task 
'vpe and a static expression of some 
;nteger type as arguments. This 
prc.mna is allowed anywhere that a 
'ask storage specification is allowed; 
'hat IS. the declaration of the task 
type to which the pragma applies and 
the pragma must both occur i in this 
order immediately within the same 
declarative part, package specification, 
or task specification. The effect of 
this pragma is to use the value of the 
expression as the number of storage 



TIME_SLICE 


TITLE 


units bytes) to be allocated as guard 
storage. The value is rounded up to 
•in appropnate boundary. A negative 
^alue causes the pragma to be ignored. 
A zero value has .system-specinc 
results: on OpenVAIS V.AX systems, 
a value of zero results m no guard 
'torage; on OpenVAIS .AXP and DEC 
OSF 1 or L'LTRIX systems, a value of 
zero results in a mfriimal guard area 
see 13 2a.i. 

On Open\'AIS and DEC OSF 1 systems 
only. 

Takes a static expression of the 
predefined fixed point type DURATION 
in the package STANDARD) as the 
single argument. This pragma is only 
allowed in the outermost declarative 
part of a library subprogram, and 
at most one such pragma is allowed 
in a library subprogram. It has an 
effect only when the subprogram to 
which It applies is used as a main 
program. This pragma causes the task 
scheduler to turn time slicing on or 
off and. on some systems, to limit the 
amount of continuous execution time 
given to a task see 9.8a; see also the 
appropnate run-time reference manual 
for imolementation differences across 
'vstemsi. 

Takes a title or a subtitle string, or 
both, as arguments. The pragma 
TITLE has the following form: 



B-ia 




I 



This pragma is allowed anywhere a 
pragma is allowed; the given strings 
supersede the default title and'or 
subtitle portions of a compilation 
listing. 

\'OLATILE Takes the simple name of a vanable 

as the single argument. This pragma 
IS only allowed for a vanable declared 
by an object declar^ion. The vanable 
declaration and the pragma must 
both occur dn this orderj immediately 
within the same declarative part or 
package specification. The pragma 
must appear before any occurrence of 
the name of the variable other than 
in an address clause or in one of the 
DEC Ada pragmas IMPORT_OBJECT, 
EXP0RT_0EJECT, COMMON, 
OBJECT, or PSECT_0EJECT TTie 
variable cannot be declared by a 
renaming declaration. The pragma 
VOLATILE specifies that the variable 
may be modified asynchronously. This 
pragma instructs the compiler to obtain 
the value of a vanable from memory 
each time it is used 'see 9.11). 


R_1 Q 


