NASA MARSHALL SPACE FLIGHT CENTER 


Simulink Code Generation 

Tutorial for generating C code from Simulink 
Models using Simulink Coder 

Jose Carlos Molina Fraticelli 
4/25/2012 


Contents 


1. Introduction 3 

2. Good Programming Practices in Simulink 4 

3. Choosing Variable Data Types 6 

4. Hardware Implementation data type information 7 

5. Naming Standards 7 

6. Creation of practice model for code generation 8 

7. Preparing practice model for code generation 17 

8. Compiling and Executing generated code 29 

9. Comparing output of MATLAB with that of the generated code 36 

References 37 

Appendix A Hardware Implementation Table 38 



1. Introduction 


This document explains all the necessary steps in order to generate optimized C code from 
Simulink (Ref. [2]) Models. This document also covers some general information on good 
programming practices, selection of variable types, how to organize models and subsystems, and 
finally how to test the generated C code and compare it with data from MATLAB (Ref. [1]). 

(NOTE: This guide was prepared using MATLAB/Simulink Ver. R201 lb (Ref. [1]).) 



2. Good Programming Practices in Simulink 


Below are some guidelines to follow when creating Simulink (Ref. [2]) Models: 

• Create bus objects for subsystems with many outputs and inputs. It makes organizing a 
model simpler by requiring less cabling and also makes management of the data 
contained in the bus easier when debugging as errors usually show up in a single location. 

• Avoid using Mux blocks to create Bus signals. Always use a Bus Creator blocks. 

• Avoid Crossing Cables when possible: There are a variety of ways to avoid crossing 
cables which can make debugging Simulink (Ref. [2]) models complicated. Some of 
these include: Organizing Subsystem Inputs to match cabling going into the subsystem, 
Goto and From blocks, Bus Creator blocks, Bus Selector blocks, among others. 

• Determine variable types ahead of time. Simulink (Ref. [2]) defaults all data types to 64- 
bit doubles by default. This can sometimes be a problem for code generation as not all 
targets can support these types of variables and it can be hard to change these once a 
model is created. This will save a lot of time trying to find problematic typecasts. 

• Use MATLAB (Ref. [1]) structures when working with Bus Signals. 

• Determine whether a model is a sub-function or a subsystem. 

• Avoid Algebraic Loops. They are problematic for code generation as stated by 
Mathworks. If the algebraic loop cannot be avoided use a Unit Delay Block to break up 
the loop. (NOTE: Verify that adding this block has not changed the output of the model.) 

• Avoid using different sampling times between models. This is not supported by code 
generation. 

• Avoid using variable-step solvers. The only valid solver for code generation is the Fixed 
Step Solver with a discrete time step. 

• Build models from the ground up with code generation in mind. 

• Test models as a standalone piece both in simulation and in the generated code and 
ensure it is working before adding additional models. 

• Avoid using equal names for buses, data, constants and models. This can cause serious 
problems with code generation. Use a naming standard to clearly define what every 
object is or isn’t. 

• Rename models such as “Foo One Model”; to Foo One Model. This will help avoid 
problems with code generation. 



If a model name is too long try shortening it. Model names should not exceed 20 
characters. 

Align models and objects that are part of the model using the alignment tools available in 
Simulink (Ref. [2]) these can be accessed by selecting two or more model objects and 
selecting align blocks. This can help clean up models immensely 

Make sure the warning indicator on MATLAB (Ref. [1]) function blocks is green. Try to 
fix all warnings pointed to by this indicator. Also always add the %#codegen pragma 
directive below the function name declaration and before any code. 

Don’t use Goto and From blocks between different models. Use a signal line instead. 

Avoid the use of extremely memory intensive blocks such as ‘Fuzzy Logic controllers’ if 
generating code for embedded platforms such as microcontrollers; as the generated code 
will not fit in the stack due to the high amount of floating point variables required. 

Avoid excessive unnecessary variables. Memory is at a premium in embedded hardware 
as opposed to a desktop computer. 

Use consistent signal names. This can help ease debugging immensely. 

Align all inputs to the left of the model and all outputs to the right of the model. This can 
help find problematic inputs/outputs faster. 


3. Choosing Variable Data Types 


In order to determine the correct data type for a variable one must determine what that variable 
will be used for. Simulink (Ref. [2]), by default, will generate all variables as 64-bit doubles. 
This can cause problems for embedded platforms with a low memory footprint such as 
microcontrollers which is where generated code is usually targeted to. Below are some tips in 
order to determine which variable type is viable for each action: 

• boolean: If the variable is to be used as a ON/OFF switch then this variable type should 
be used 

• int8: If the variable does not exceed 8 bits and is a character then this variable type 
should be used 

• inti 6: If the variable does not exceed 16 bits and is an integer then this variable data type 
should be used 

• int32: If the variable does not exceed 32 bits and is an integer then this variable data type 
should be used 

• single: If the variable is a single precision floating point number then this variable data 
type should be used 

• double: If the variable is a double precision floating point number then this variable data 
type should be used. (NOTE: This is the default variable type for Simulink (Ref. [2])) 

• If the variables to be defined contain many elements then a structure must be created to 
house these elements. A Bus must be created from said structure and then used as the 
data type of the variable. 



4. Hardware Implementation data type information 


Below is a table listing device specific information for Hardware Implementation of the 
Simulation and Generated code. This information is set in the Hardware Implementation pane 
located in the Simulation Configuration Parameters: 


Device 

Number of bits Largest atomic size 

Byte 

Rounds 

Shift 

vendor / 

Device 

type 

char 

short 

int long native int 

float 

ordering 

to 

right 

ARM Compatible 

ARM 

7/8/9/10 

8 16 

32 

32 32 Long 

Float 

X 

X 

X 

Microchip 

dsPIC 

8 16 

16 

32 16 x 

X 

Little Endian 

Zero 

Set 

Texas Instruments 

MSP430 

8 16 16 

32 16 

X 

x Little 
Endian 

Zero 

Set 


Table 1: Hardware Implementation Partial 

(NOTE: For a complete Hardware Implementation table refer to Appendix A.) 

5. Naming Standards 

To remain consistent on which object is what, and also to make debugging of problems easier, it 
is important to establish a naming standard. This naming standard must be applied to models, 
constants, variables and buses. An example of this standard is listed below and can be used as is 
or with some modifications if required: 

• If the object in question is a model then the name of that model should be in the form of: 
“NameModel” 

• If the object in question is a constant then the name of that constant should be in the form 
of: “Name Constant” 

• If the object in question is a bus then the name of that bus should be in the form of: 
“Name Bus” 



• If the object in question is a signal then the name of that signal should be in the form of: 
“Name_Signal” 

• If the object in question is a function then the name of that signal should be in the form 
of: “Name Func” 

• If the object in question is a subsystem input then the name of that input should be in the 
form of: "Name lnput" 

• If the object in question is a subsystem input then the name of that input should be in the 
form of: "Name Output" 

6. Creation of practice model for code generation 

In this section a new practice model will be created in order to demonstrate the necessary steps to 
do successful code generation from any Simulink (Ref. [2]) model. 

Open up MATLAB (Ref. [1]) and type the ‘buseditor’ command on the command window in 
order to access the Bus Editor. 

Command Window _+l □ ? x 

— 

■vj 1 New to MATLAB? Watch this Video, see Demos, or read Getting Started . 

/* >> buseditGr 


Bus Editor GUI: 




Once here click on File > Add Bus, (or alternatively Ctrl+B), while having the Base Workspace 
selected. A new Bus Object will be created in the MATLAB (Ref. [1]) workspace. Rename this 
Bus Object to Inputs by modifying the Name Field in the Bus Editor: 


SimuhnlcBus: Inputs 

Properties 

Name: Inputs 

Code generation options 
DataScope: [ Auto 
HeaderFile: 


Alignment: -1 

Description: 


Click Apply at the bottom of this window. 


Now add two new elements to this Bus by going to File> Add/Insert Element (or alternatively 
Ctrl+E) while having this Bus Object selected. These elements will be called Input_A and 
Input B respectively and will be of type int32: 


Simulink.BusElement: Input_A 

Properties 


Name: | Input_A 


DataType: | int32 


Data Type Assistant 

Mode: (Built in “31 int32 ~^~|Data type override: (inherit 




Minimum: \[] 
Maximum: |"[j 
Complexity: (real 
Dimensions: (1 


DimensionsMode: | Fixed 
SamplingMode: (sample based 
SampleTime: |^l 


U 


~3 


Now repeat the previous process for the Outputs Bus but this time add five elements sum of type 
int32, sub of type int32, mul of type int32, div of type double, and sum gain of type int32. Once 
finished the Bus Editor Window should contain the following objects: 



Bus Editor - Manage Bus Objects in the Base Workspace 


File Edit View Options Help 


^^l + =-= ± + I Eft] 


* * -- 1 ' X 


Filter :jb7 


Bus Name 


3 • = Inputs 

— Input_A 
— Input_B 
S = Outputs 

— sum 

— sub 

— mul 

— div 

— sum_gain 


Go back to the workspace and write the following command in the command window: ‘gain = 
int32(l)’. You should see the following now: 


Command Window 


( * ■ New to MATLAB? Watch this Video, see Demos, or read Getting Started . 
>> gain = int32 ( 1) 

gain = 

1 

f* >> 


Now that the workspace contains all necessary bus objects and variables with their defined data 
types proceed to create a new model for Simulink (Ref. [2]) by going to File>New>Model at the 
top toolbar: 


« MATLAB R201 lb 


File Edit Debug Parallel Desktop Window Help 



1 D:\.,.TSAT_ERT\driveSTK,m 

2 C:\. , .ibrary_F5W\busDef,nn 

3 C:\. . .ro_mod\InDataFile.m 

4 C:\. , ._mod\Cubesat_init.m 

Exit MATLAB Ctrl+Q 

*1 Sum sFun.mexw32 


Now this new model should be open: 



Bring up the Simulink (Ref. [2]) Library Browser and add the following blocks to the model 


• 3 Bus Creator Blocks 




• 3 Constant Blocks 

• 7 Bus Selector Blocks 

• 2 Display Blocks 

• 5 MATLAB (Ref. [1]) Function Blocks 

• 1 Model Info Block 

Once these are added to the model organize them in the following manner: 



MATLAB Function4 



gain 


Make sure that the Output data types of the Input A, Input B and gain constants are of type 
int32. (NOTE: Set the gain constant value to ‘gain’) 


Open the first of the MATLAB (Ref [1]) Function blocks and write the following code inside: 
sum func: 



For the next four blocks write the following code in order from top to bottom: 



sub func: 



mul func: 



div func: 



sum_gain_func: 



Connect the model as shown below: 



(NOTE: Make sure the First Bus Creator on the left has a data type of ‘Bus: Inputs’ and that the 
following Bus Creator to the right has a datatype of ‘Bus: Outputs’ as can be seen on the above. 
Also be sure to label all signal cables with their corresponding names) 

Configure the Model Info Block with the following tokens then click Apply and OK: 



Run the model and look at the output seen on the display block; if the Input Constant values of 
Input A and Input B are set to 1 and 2 respectively then the output of the simulation should be 
um = 3, sub = —1, mul = 2, sum aain = 4 and div = 0.5 : 



0.5 


Displayl 


Select this section of the model and right click it. Afterwards select Create Subsystem from the 
popup menu: 


1 


Busjnputs 


<lnput_A> 


<lnput_B> 


<lfiput_A,> 


<lnput_B> 


<lnput_A> 


<lnput_B> 


<lnput_A> 


<lnput_B> 


<lnput_A> 
I <lnput_B> 


gam 


gain 


lnput_A 

_ ft sium 

I n ^ F u n c 


sum Func 


lnput_A 

4i sub 

Func 


sub Func 


Input A _ 

^ mvl 
'"PlttJf Func 


mul Func 


lnput_A 

^ div 
ln P%9 func 


■div Func 


lnput_A 

Input JE ^m_ga i 
fjfflH_gain_func 


su b 


unui 


— 


div 


5un_gam 


sum_gai n _Func 


The model should now look as follows. Save this model as CodegenT_Model 



Display! 


7. Preparing practice model for code generation 

Now that the CodegenT Model is finished and running it is time to prepare it for code 
generation. To start right click on the Subsystem Model and select Subsystem Parameters: 


SI Function Block Parameters: Subsystem 
Subsystem 

Select the settings for the subsystem block. To enable parameters on the 
Code Generation tab, on the Main tab r select 'Treat as atomic unit 1 . 


Inl 


Out! 


In 2 


Subsystem 


Main 


Code Generation 


Show port labels 


FromPortlcon 


Read/Write permissions: ReadWrite 


Name of error callback function: 


Permit hierarchical resolution: All 
Treat as atomic unit 


OK 


Cancel 


Help 


Apply 


<diiv> 


Displgyl 


Check the box that is labeled "Treat as atomic unit"; click Apply then OK. This will change the 
borders of the Subsystem to a bold line indicating that the system is now atomic and will execute 
as a single unit inside the simulation. Systems must be atomic in order to be generated as re- 
usable C functions using Real-Time Workshop. The Subsystem model should now look as 
follows (NOTE: Changing a Subsystem to an atomic representation can change simulation 
output; always verify that the simulation is still working before generating code from it.): 



S u bsyste m 




Rename the Subsystem model to Calc_Test_Model: 




Ini 

Out! 

In2 


Ca I c_T e5t_Model 


Once again right click on the model and open the Subsystem Parameters, go to the Code 
Generation Tab which is enabled when the Subsystem is declared as atomic and choose the 
"Reusable Function" option on the "Function packaging" dropdown list. Afterwards two more 
dropdown lists will appear "Function name options" and "File name options"; For the first 
dropdown list choose "User Specified" and write the following name in the provided text space 
"calc_functions". Afterwards choose the "Use function name" option for the "File name options" 
dropdown list. Finally click Apply then OK to close the subsystem parameters: 




Next go to the top toolbar in Simulink (Ref. [2]) and click on Simulation > Configuration 
Parameters. The following window will open: 


Configuration Parameters:: CodegenT_Model/Configuration [Active) 
Simulation time 


Select: 


! ■ Solver 

| ■ Data Import/ Export 
EE- Optimization 
+ ■■ Diagnostics 

j - Hardware Implementation 
h Model Referencing 
+ ■■ Simulation Target 
Ed- Code Generation 


Start time: 0.0| 

Solver options 

Type: Variable-step 


Max step size: auto 


Min step size: auto 


Stop time: 10.0 


Solver: 


I ode45 (Dorm and- Prince) 


Relative tolerance: le-3 


Absolute tolerance: auto 


Initial step size: auto 
Number of consecutive min steps: 1 

Tasking and sample time options 
Tasking mode for periodic sample times: 

0 Automatically handle rate transition for data transfer 
0 Higher priority value indicates higher task priority 


Shape preservation: | Disable all 


Zero- crossing options 


Zero-crossing control: | Use local settings 
Time tolerance: 10 a|: 128 =t eps 


| Algorithm: (Nonadaptive 


Signal threshold: auto 


OK 


Cancel 


Help 


Apply 


These are all the available properties for the simulation. For code generation only some of these 
properties need to be modified. To start off set the Solver pane options as shown below: 


Configuration Parameters:: CodegenT_Model/Configuration [Active) 
Simulation time 


Select 


Solver 

Data Import/Export 
+ ■■ Optimization 
+ ■■ Diagnostics 
Hardware Implementation 
Model Referencing 
+ ■■ Simulation Target 
+ -Code Generation 


Start time: 0.0 
Solver options 


Type: | Fixed-step 


Stop time: inf 


T Solver: discrete (no continuous states) 


Fixed-step size (fundamental sample time): 

Tasking and sample time options 
Periodic sample time constraint: 

Tasking mode for periodic sample times: 

0 Automatically handle rate transition for data transfer 
□ Higher priority value indicates higher task priority 


Unconstrained 


Auto 





Next in Data Import/Export pane change the signal logging name to BusData (NOTE: Signal 
logging can be used for debugging and generating files from simulation output data): 


Configuration Parameters- CodegenT_Model/Configu ration [Active) 
Load from workspace 
□ Input: 


Select 


■Solver 

■Data Import/ Export 
0- Optimization 
0- Diagnostics 
■Hardware Implementation 
■Model Referencing 
0- Simulation Target 
3-Code Generation 


[t r u] 


□ Initial state: xlnitial 


Save to workspace 
Time P State, Output 
3 Time: 

□ States: 

[7] Output: 


tout 


xout 


yout 


□ Final states: xFinal 


Signals 


3 Signal logging: BusData| 

| Configure Signals to Log... 


Data Store Memory 


[3 Data stores: dsmout 


Format: 


| Array 

3 

1000 



Decimation: 1 

□ Save complete SimState in final state 


Signal logging format: | ModelDataLogs 


For the Optimization pane change the Application lifespan setting to inf: 


Configuration Parameters: CodegenT_Model/Configuration [Active) 
Simulation and code generation 
[3 Block reduction 


Select: 


Solver 
■Data Import)'' Export 


3 Conditional input branch execution 


Diagnostics 

Hardware Implementation 
Model Referencing 
0- Simulation Target 
3- Code Generation 


3 Implement logic signals as Boolean data (vs. double) Application lifespan (days) inf 

□ Use integer division to handle net slopes that are reciprocals of integers 

□ Use floating-point multiplication to handle net slope corrections 

Code generation 
Data initialization 

3 Use memset to initialize floats and doubles to 0.0 
Integer and fixed-point 

3 Remove code from floating-point to integer conversions that wraps out-of-range values 
3 Remove code from floating-point to integer conversions with saturation that maps NaN to zero 

Accelerating simulations 

Compiler optimization level: | Optimizations off (faster builds) 

3 Verbose accelerator builds 



Jump over to the Hardware Implementation pane and set the settings of this pane as outlined in 
Table 1 based on the Hardware for which the code will be generated (NOTE: For this example 
Unspecified (32-bit generic) will be used): 


Configuration Parameters: CodegenT_Model/Configuration [Active) 

Embedded hardware (simulation and code generation) 


Select 


■Solver 

-Data Import/ Export 
+ ■■ Optimization 
0- Diagnostics 


Hardware Implementation 


-Model Referencing 
0- Simulation Target 
0-Code Generation 


Device vendor: Generic 


Number of bits 


char: 

3 

short: 

long: 

32 

float: 

native: 

32 

pointer: 


16 


32 


int: 

double: 


32 


Byte ordering: | Unspecified 


32 


64 


0 Shift right on a signed integer as arithmetic shift 

Emulation hardware (code generation only) 

0 None 


| Device type: | Unspecified (assume 32-bit Generic) T | 
Largest atomic size 


integer: 


Char 


floating-point: | None 


Signed integer division rounds to: | Undefined 


Go to the Code Generation Pane and select the following options: 


Configuration Parameters: Co deg enT_Model/Configu ration [Active) 


Select: 

"Solver 

"Data Import/ Export 
0- Optimization 
-•■"Diagnostics 

H a r d wa re Im p I e m e ntati o n 
"Model Referencing 
±1- Simulation Target 
— Code Generation 
I- Report 
!"■■ Comments 
I"" Symbols 
I " Custom Code 
Debug 
Interface 

!" SIL and PIL Verification 
Code Style 
l"Templates 
;-Code Placement 
I - Data Type Replacem... 

; - Memory Sections 


Target selection 


Embedded Coder 


System target file : ert.tlc 
Language: |c 

Description: 

Build process 

Compiler optimization level: | Optimizations off (faster builds) 
TLC options: 

Makefile configuration 
0 Generate makefile 
Make command: make_rtw 

Template makefile: ert_default_tmf 


Browse.. 


Data specification override 
□ Ignore custom storage classes 


□ Ignore test point signals 


Code Generation Advisor 

Prioritized objectives: Execution efficiency,. ROM efficiency, RAM efficiency, ... 


Check model before generating code: | On (stop for warnings) 
0 Generate code only 


Set objectives . 
Check model .. 


Generate code 


n 





Set Objectives Pop-Up to the desired objectives: 



Make sure to select the correct target file based on the desired target. For this example ert.tlc 
Embedded Coder will be used. 

Select the Report Pane and set the following options: 






Go to the Interface pane and select the following options: 



Make sure the "Generate reusable code" checkbox is checked in this pane. 

Go to the Code Style pane and check all checkboxes. This is done to set the coding style as 
humanly readable as possible for code generation: 


Configuration Parameters:: CodegenT_Model/Configuration [Active) 


Select: 

-Solver 

-Data Import/ Export 
+ ■■ Optimization 
3 - Diagnostics 
■ H a rd wa re Im p I e m e ntati o n 
-Model Referencing 
□■■Simulation Target 
Eh Code Generation 
j- Report 
j- Comments 
;■ Symbols 
;■■■■ Custom Code 
j- Debug 
I- Interface 

! SIL and PIL Verification 
j-Code Style 
j- Tern plates 
j-Code Placement 
1-Data Type Replacem... 
"■■■Memory Sections 


Code Style 

Parentheses level: (Nominal (Optimize for readability) 

[V] Preserve operand order in expression 
[Zl Preserve condition expression in if statement 
W\ Convert if- el seif- else patterns to switch- case statements 
[V] Preserve extern keyword in function declarations 

[V] Suppress generation of default cases for Stateflow switch statements if unreachable 




Next go to the Templates pane and set the following options: 



In this pane source code generation templates may be selected. This requires advanced 
knowledge of tic language. Information on tic language and files can be found in the MATLAB 
(Ref. [1]) help window. 

Once again return to the Code Generation pane; click Apply then click the generate code button. 
A model check procedure will now start to verify that all settings are correct for code generation: 




Select the first warning symbol on the top of the Code Generation Objectives list and then click 
on Modify Parameters: 


id: name and description ▼ ^ 


ft Code Generation Objectives 

/!\ Check model configuration settings 
G Identify unconnected lines,, input p 
G Checkfor optimal bus virtuality 

Check Data Store Memory blocks for m 
Q ■'■Identify block output signals with cor 
G Identify questionable blocks within the 
A Checkthe hardware implementation 
^ Identify questionable software environ 
G Identify questionable code instruments 
G Checkfor blocks that have constraints 
^ ^Identify questionable subsystem setti 
A ■' Identify blocks that generate expensii 
G ■'■Identify questionable fixed-point ope 
Q Checkfor efficiency optimization paranr 


Check model configuration settings against code generation objectives 


The following parameter values are not optimized for the selected objectives: Execution efficiency, ROM 
efficiency, RAM efficiency, Traceability, Safety precaution. 

To automatically fix the warning, dick the 'Modify Parameters' button and then rerun the check. To manually fix 
the warning, dick the parameter hyperlink to open the Configuration Parameters dialog box, and manually 
apply the recommended value. 


(Objectives: Execution efficiency, ROM efficiency, RAM efficiency, Traceability, Safety precaution) 



|Pa ra meter 

(Ciirnent Valine (Recommended Value 



|SuDoress error stotus in real-time model data structure 

|off 

h 



[ion-finite numbers 

□ |pn 




(Compiler optimization level 

Jl°ff 




Minimize data copies between local and alobal variables 

Jloff 

F 



(inline parameters 

Jl°ff 

F 



Remove code from floating -point to integer conversions that 


IF 

- 



Action 


Change current values to recommended value. Some parameters might require manual changes. 


Modify 


Parameters 


This will set the conflicting parameters to the correct settings for code generation. Once this is 
done click on Run This Check will in the same window: 


Code Generation Objectives 
G Check model configuration settings 
G Identify unconnected lines, input p 
G Checkfor optimal bus virtuality 
^ Check Data Store Memory blocks fc 
G ^Identify block output signals with 
G Identify questionable blocks within 
^ Checkthe hardware implementatio 
^ Identify questionable software envi 
G Identify questionable code instrum 
O Checkfor blocks that have constrai 
^ identify questionable subsystem s 
A ^Identify blocks that generate expe 
G ^Identify questionable fixed-point 
G Checkfor efficiency optimization ps 


Check model configuration settings against code generation objectives 

Analysis 

Check model configuration settings against the code generation objectives. Successfully passing this check may take 
multiple iterations since a change to one option can impact other options. 

| Run This Check ] 

Result: G Passed 


Passed 

(Objectives: Execution efficiency, ROM efficiency, RAM efficiency. Traceability, Safety precaution) 
The following parameters have been checked and confirmed with the recommended value 


(Parameter 

(Value 


hon-inlined S -functions 



ISuooress error status in real-time model dato structure 

fn 


MAT-file loqqinq 

FT~ 


|GRT compatible call interface 



(continuous time 

Ff~ 


[ion -finite numbers 

Ff~ 


(Single outout/uodate function 



Minimize algebraic loop occurrences 

FT~ 



Do the same procedure for the remaining warnings if necessary based on individual model 
configurations. In the case of this simple example it is not necessary to fix all warnings as they 
are only there to prevent what could be future issues but not really simulation errors. 


Once done here go back to the Configuration Parameters and change the "Check model before 
generating code" dropdown list to the "Off' setting in order to bypass the model advisor. Click 
Apply then OK to save these changes then close the Configuration Parameters: 


Code Generation Advisor 

Prioritized objectives: Execution efficiency, ROM efficiency, RAM efficiency, 
Check model before generating code: 

Z Generate code only 


Off 


Set objectives ... 


Check model ... 


Generate code 


Right click on the Calc_Test_Model Subsystem and go to Code Generation > Build Subsystem. 
If there are not conflicts the following window should appear. (NOTE: It is possible an error 
message might pop-up due to an unset or incorrectly set configuration parameter option. This is 
normal and can be easily fixed by changing the conflicting parameter): 


4 Build code for Subsystem:Calc_T est_Model 
Picktunable parameters 


= || © I— —I 


Variable Name Class StorageClass 

EEI gain 

int32 

Inlined v 

















Blocks using selected variable 


Block 

Parent 






Build 


Cancel 


Help 


Status 

Select tunable parameters and click Build 


This window contains all workspace constants that are to be used in the generated code and offer 
storage options for the generated code. In the case of this example the variable gain can be left as 
"Inlined". Click on Build and the code generation process will start. 



The code generation progress should be shown in the command window as seen below: 


Command Window 

■ ‘ ' New to MATLAB? Watch this Video , see Denies , or read Getting Started . 


-+■ n ? x 

X 


### Caching m.odel source code 


#*# 

Writing 

source 

file 

Calc Test Model. c 





### 

Writing 

header 

file 

Calc Test Model private. h 





### 

Writing 

header 

file 

Calc Test Model. h 





### 

Writing 

header 

file 

Calc Test Model types. h 





*** 

Writing 

source 

file 

C : \Users\ Jose\Desktop\Version 

Control\non 

version 

cont r o 1 1 e d\ 5 imul ink 

Tutoric 

*** 

Writing 

header 

file 

C : \Users\ Jose\Desktop\ Version 

Control\non 

version 

controlled\5imulink 

Tutoric 

#*# 

Writing 

source 

file 

C : \Users\ Jose\Desktop\Yersion 

Control\non 

version 

cont r o 1 1 e d\ 5 imul ink 

Tutoric 

*** 

Writing 

header 

file 

C : \Users\ Jose\Desktop\Version 

Control\non 

version 

c ont r o 1 1 e d\ 5 imul ink 

Tutoric 

*#* 

Writing 

header 

file 

c al c funct i ons . h 






If all goes well the following Code Generation Report should show up: 




From here the generated code can be evaluated and can also be traced back to the Simulink (Ref. 
[2]) Model. For more information on the Code Generation Report consult the MATLAB (Ref. 
[1]) help window. 

Now on the current MATLAB (Ref. [1]) path there should be two folders called 
Calc_Test_Model_ert_rtw and slpij respectively: 


Name Date modified Type 


C a 1 c_T est_M o d el_ert_rtw 

4/13/2012 5:21 PM 

File folder 

slprj 

4,13/2012 5:06 PM 

File folder 

-Smulink Code Generation V3.docx 

4,13/2012 5:10 PM 

Microsoft ( 

,* busdefines.m 

4/5/2012 3:35 PM 

M File 

_j Calc_Test_Model_sfun.mexvv64 

4,13/2012 5:20 PM 

MEXW64 F 

CodegenT_Model.mdl 

4,10/2012 10:23 PM 

MDL File 


These folders contain all the generated code from the Simulink (Ref. [2]) Model; copy and paste 
these folders to any desired location for the next section of the tutorial where the code will be 
compiled and executed. 


8. Compiling and Executing generated code 


Now that the code is generated the next step is to test the code by compiling it and creating an 
executable to run it. For this section of the tutorial a C IDE and compiler are required. This 
tutorial will use Bloodshed Software’s Dev-C++ IDE [2] but these steps can be done in any IDE 
with any compiler. Dev-C++ (Ref. [3]) can be downloaded from Bloodshed Software’s webpage: 
http://www.bloodshed.net/download.html 



Download the Dev-C++ (Ref. [3]) setup and install it by following the on-screen prompts: 





Once finished with the installation open up the Dev-C++ (Ref. [3]) IDE: 



Go to the top toolbar then go to File > New > Project, afterwards select the following options: 
Empty Project, check C Project and Name the project Calc_Test_Generated_Model: 


New project 



Click on Ok and a Prompt will come up asking for a location to save the project. Choose any 
desired location. (NOTE: It is recommended to create a new folder for this project) 


After creating the project the left hand tab will contain a root folder with the name of the project. 
This is where all source code will be located: 


@Dev-C++4.9.9.2 

File Edit Search View Project E; 


m □ 


gg □ □ gg ^ 


r f @ | ’ 


Project Classes | Debug | 


KJ Calc Test Generated Model 


Now drag the copies of the Calc_Test_Model_ert_rtw and the slprj folders into the 
Calc_Test_Generated Model project folder in the previously selected location: 



Next go to the top toolbar then go to Project > Project Options then in the Pop Up window go to 
the Directories Tab then inside of it go to the Include Directories Sub Tab. Add the following 
paths to the include directories: ".\Calc_Test_Model_ert_rtw" and "Aslprj\ert\_sharedutils" 
(NOTE: replace the dot with the absolute path to the CalcTestGeneratedModel folder): 







Right click on the Calc_Test_Generated_Model folder on the left hand tab and then click on 
"Add Folder" call the folder CalcTest then click OK: 



Add an additional folder to the top folder called utilities: 


0 D ev- C + + 4 .9 .9 .2 - [Cal c_T est_G en e 
File Edit Search View Project E. 


08 


□ HQ* 

IE 

1 * 

□ □ 
□ □ 

□ □ 
□ □ 

□ 

□ 

f <§> 

L 




Right click on Calc Test and then click on "Add to project". Browse to the 
Calc_Test_Model_ert_rtw folder then add all .c and .h files excluding the ert main.c. Repeat this 
for the utilities folder by going to slprj\ert\_sharedutils. Finally right click on the top 
Calc_Test_Generated Model folder and add the ert_main.c from the Calc_Test_Model_ert_rtw 
folder: 





After adding everything the folders should contain the following: 


0 Dev-C++ 4.9.9.2 - [ Calc_Test_Gener 
File Edit Search View Project E; 



□ 

m 


□ □ 
□ □ 

□ 

□ 

□ □ 
□ □ 

t ® 

c 


Project | Classes | Debug | 


Calc Test Generated Model 




B-m 


□ 


Calc_T est 

calc_f unctions, c 
calc_f unctions, h 
Calc_Test_Model.c 
Calc_Test_Model.h 
Calc_T est_Model_private.F 
Calc_T est_Model_ types, h 
utilities 

mul_s32_s32_s32_sat. c 
mul_s32_s32_s32_sat. h 
mul_wide_s32.c 
mul_wide_s32.h 
rtw_shared_utils.h 
rtwtypes.h 
ert main.c 


Go to the top toolbar then click on Execute > Compile & Run and if there are no problems the 
following output should appear: 







Now that the code is up and running; open the ertrnain.c and make the following modifications 
to the main function: 

#if 0 

printf("Warning: The simulation will run forever. " 

"Generated ERT main won't simulate model step behavior. " 

"To change this behavior select the 'MAT-file logging' optionAn"); 
fflush((NULL)); 

while (rtmGetErrorStatus(O) == (NULL)) { 

/* Perform other application tasks here */ 

} 

#else 

int32_T Input A = 1 ; 
int32_T InputB = 2; 

while(l) 

{ 

/* Pass input data */ 

Calc_Test_Model_U_Input_A = InputA; 

Calc_Test_Model_U_Input_B = InputB; 

/* Run Subsystem */ 

Calc_Test_Model_step(&Calc_Test_Model_DWork, Calc_Test_Model_U_Input_A, 
Calc_Test_Model_U_Input_B, &Calc_Test_Model_Y_Outl); 


/* View Output */ 


printf("Input_A: %ld , Input_B: %ld\n\n" 
"sum: %ld\n\n" 

"sub: %ld\n\n" 

"mul: %ld\n\n" 

"div: %lf\n\n" 

"sum_gain: %ld\n\n" 

CalcTest _Model_U_Input_A, 
CalcTest _Model_U_Input_B, 
Calc_Test_Model_Y_Out 1 .sum, 
Calc_Test_Model_Y_Out 1 .sub, 
Calc_Test_Model_Y_Out 1 .mul, 

Calc Test Model Y Out 1 .div, 

Calc Test Model Y Out 1 .sum_gain) ; 

Input_A++; 

Input_B++; 

sleep(lOOO); 


} 

#endif 

The modifications to the code add the Inputs A and B initialized to 1 and 2 respectively. Then an 
infinite while loop is started. Inside this loop the Inputs are passed to their corresponding 
structure elements located in the input variables for the model step function denoted by the _U 
(e.g. Calc_Test_Model_U_Input_A), next the step function, denoted _step (e.g. 
Calc_Test_Model_step ) is called to run the model. After calling the step function the values are 


now in the output data structure denoted by the _Y (e.g.:Calc_Test_Model_Y_Outl) and then 
these can be accessed globally for any purpose. 

The output data can then be viewed with the printf function as shown below: 



9. Comparing output of MATLAB with that of the generated code 

Once the code is generated and running there is a couple of ways to determine if the output is 
correct: 


• Simple observation of the simulation output can be used in the case of simple calculations 
as those carried out in this example. 

• In the case of more complex calculations a text file can be generated and plotted to 
compare to output data from the simulation model. 

• Text files can be loaded into MATLAB (Ref. [1]) then the difference between these two 
files can be plotted showing differences in output for each sample. 




References 


Computer Software 

[1] MATLAB, The MathWorks, Inc., Software Package, Ver. R2011b, Natick, Massachusetts, 
2011 . 

[2] Simulink, The MathWorks, Inc., Software Package, Ver. R2011b, Natick, Massachusetts, 
2011 . 

[3] Dev-C++, Bloodshed Software, Software Package, Ver. 5, 2005. 



Appendix A Hardware Implementation Table 


Key: float and double (not listed) always equal 32 and 64, respectively 

pointer (not listed) matches the value of int 
Rounds to = Signed integer division rounds to 


Shift right = Shift right on a signed integer as arithmetic shift 


Device 

vendor / 

Device type 

Number of bits 

Largest 
atomic size 

Byte 

ordering 

Round 
s to 

Shift 

right 


cha 

r 

shor 

t 

int 

long 

native 

int 

float 




Generic 

Unspecified 
(assume 32 - 
bit Generic) 
(default) 

8 

16 

32 

32 

32 

X 

X 

Unspecifie 

d 

X 

Set 

Custom 

X 

X 

X 

X 

X 

X 

X 

X 

X 

X 

16-bit 

Embedded 

Processor 

8 

16 

16 

32 

16 

X 

X 

X 

X 

Set 

32-bit 

Embedded 

Processor 

8 

16 

32 

32 

32 

X 

X 

X 

X 

Set 

32-bit Real 

Time 

Simulator 

8 

16 

32 

32 

32 

X 

X 

X 

X 

Set 

32-bit x86 

8 

16 

32 

32 

32 

X 

X 

Little 

Zero 

Set 



Key: 

float and double (not listed) always equal 32 and 64, respectively 


pointer (not listed) matches the value of int 


Rounds to = 

= Signed integer division rounds to 





Shift right = 

= Shift right on a signed integer as arithmetic shift 



Device 

vendor / 

Device type 

Number of bits 

Largest 
atomic size 

Byte 

ordering 

Round 
s to 

Shift 

right 


cha 

r 

shor 

t 

int 

long 

native 

int 

float 




compatible 








Endian 



8-bit 

Embedded 

Processor 

8 

16 

16 

32 

8 

X 

X 

X 

X 

Set 

MATLAB 

Host 

Computer 

8 

16 

32 

Host 
specifi 
c value 
(32 or 
64) 

Host 
specifi 
c value 
(32 or 
64) 

X 

X 

Little 

Endian 

X 

Set 


AMD 


K5/K6/Athlo 

n 

8 

16 

32 

32 

32 

X 

X 

Little 

Endian 

X 

Set 

ARM Compatible 

ARM 

8 

16 

32 

32 

32 

Lon 

Float 

X 

X 

X 

7/8/9/10 






g 





ARM 11 

8 

16 

32 

32 

32 

Lon 

Doubl 

X 

X 

X 







g 

e 





Key: float and double (not listed) always equal 32 and 64, respectively 

pointer (not listed) matches the value of int 
Rounds to = Signed integer division rounds to 


Shift right = Shift right on a signed integer as arithmetic shift 


Device 

vendor / 

Device type 

Number of bits 

Largest 
atomic size 

Byte 

ordering 

Round 
s to 


cha 

r 

shor 

t 

int 

long 

native 

int 

float 



ARM Cortex 

8 

16 

32 

32 

32 

Char 

None 

X 

X 


ASIC/FPGA 


ASIC/FPGA 

NA 

NA 

N 

NA 

NA 

NA 

NA 

NA 

NA 




A 








Analog Devices 


Blackfin 

8 

16 

32 

32 

32 

Lon 

g 

Doubl 

e 

Little 

Endian 

Zero 

SHARC 

32 

32 

32 

32 

32 

Lon 

g 

Doubl 

e 

Big Endian 

Zero 

TigerSHARC 

32 

32 

32 

32 

32 

Lon 

g 

Doubl 

e 

Little 

Endian 

Zero 

Atmel 

AYR 

8 

16 

16 

32 

8 

X 

X 

Little 

Endian 

Zero 


Freescale 


Shift 

right 

x 

NA 

Set 

Set 

Set 

Set 


Key: float and double (not listed) always equal 32 and 64, respectively 

pointer (not listed) matches the value of int 
Rounds to = Signed integer division rounds to 


Shift right = Shift right on a signed integer as arithmetic shift 


Device 

vendor / 

Device type 

Number of bits 



Largest 
atomic size 

Byte 

ordering 

Round 
s to 

Shift 

right 

cha 

r 

shor int 
t 

long 

native 

int 

float 

32-bit 

8 

16 32 

32 

32 

Lon 

Doubl 

Big Endian 

Zero 

Set 

PowerPC 





g 

e 




68332 

8 

16 32 

32 

32 

X 

X 

Big Endian 

X 

Set 

68HC08 

8 

16 16 

32 

8 

X 

X 

Big Endian 

X 

Set 

68HC11 

8 

16 16 

32 

8 

X 

X 

Big Endian 

X 

Set 

ColdFire 

8 

16 32 

32 

32 

X 

X 

Big Endian 

Zero 

Set 

DSP563xx 

8 

16 16 

32 

16 

X 

X 

X 

X 

Set 

(16-bit mode) 










HC(S)12 

8 

16 16 

32 

16 

X 

X 

Big Endian 

X 

Set 

MPC52xx, 

8 

16 32 

32 

32 

Lon 

Doubl 

X 

Zero 

Set 

MPC5500, 





g 

e 





MPC55xx, 

MPC5xx, 

MPC7400, 

MPC7xxx, 

MPC82xx, 

MPC83xx, 



Key: float and double (not listed) always equal 32 and 64, respectively 

pointer (not listed) matches the value of int 
Rounds to = Signed integer division rounds to 


Shift right = Shift right on a signed integer as arithmetic shift 


Device 

vendor / 

Device type 

Number of bits 

Largest 
atomic size 

Byte 

ordering 

Round 
s to 

Shift 

right 

cha 

r 

shor 

t 

int 

long 

native 

int 

float 




MPC86xx, 

MPC8xx 











MPC85xx 

8 

16 

32 

32 

32 

Lon 

g 

Float 

X 

Zero 

Set 

S12x 

8 

16 

16 

32 

16 

X 

X 

Big Endian 

X 

Set 

Infineon 

C16x, XC16x 

8 

16 

16 

32 

16 

X 

X 

Little 

Endian 

Zero 

Set 

TriCore 

8 

16 

32 

32 

32 

X 

X 

Little 

X 

Set 


Endian 


Intel 


8051 

Compatible 

8 

16 

16 

32 

8 

X 

X 

X 

X 

Clea 

r 

x86/Pentium 

8 

16 

32 

32 

32 

X 

X 

Little 

Endian 

X 

Set 



Key: float and double (not listed) always equal 32 and 64, respectively 

pointer (not listed) matches the value of int 
Rounds to = Signed integer division rounds to 


Shift right = Shift right on a signed integer as arithmetic shift 


Device Number of bits 

Largest Byte Round 

vendor / 


atomic size ordering s to 

Device type 



cha shor 

int long native 

int float 

r t 




Microchip 


PIC 18 

8 

16 

16 

32 

8 

X 

X 

Little 

Endian 

Zero 

dsPIC 

8 

16 

16 

32 

16 

X 

X 

Little 

Endian 

Zero 

NEC 

V850 

8 

16 

32 

32 

32 

X 

X 

X 

X 

Renesas 

M16C 

8 

16 

16 

32 

16 

X 

X 

Little 

Endian 

X 

M32C 

8 

16 

X 

32 

X 

X 

X 

Little 

Endian 

X 

R8C/Tiny 

8 

16 

16 

32 

16 

X 

X 

Little 

Endian 

X 

SH-2/3/4 

8 

16 

32 

32 

32 

X 

X 

X 

X 


Shift 

right 


Set 


Set 


x 


x 


X 


X 


X 


Key: 

float and double (not listed) always equal 32 and 64, respectively 


pointer (not listed) matches the value of int 


Rounds to = 

= Signed integer division rounds to 





Shift right = 

= Shift right on a signed integer as arithmetic shift 



Device 

vendor / 

Device type 

Number of bits 

Largest 
atomic size 

Byte 

ordering 

Round 
s to 

Shift 

right 

cha 

r 

shor 

t 

int 

long 

native 

int 

float 




SGI 

UltraSPARC 

Hi 

8 

16 

32 

32 

32 

X 

X 

Big Endian 

X 

Set 

STMicroelectronics 

ST 1 0/Super 1 
0 

8 

16 

16 

32 

16 

X 

X 

Little 

Endian 

Zero 

Set 

Texas Instruments 

C2000 

16 

16 

16 

32 

16 

Int 

None 

X 

Zero 

Set 

C5000 

16 

16 

16 

32 

16 

Int 

None 

Big Endian 

Zero 

Set 

C6000 

8 

16 

32 

40 

32 

Int 

None 

X 

Zero 

Set 

MSP430 

8 

16 

16 

32 

16 

X 

X 

Little 

Endian 

Zero 

Set 

TMS470 

8 

16 

32 

32 

X 

X 

X 

X 

X 

X 


Table 2: Hardware Implementation Complete 




