




I y~ y * " **! 


AD-A280 145 


Iv M*Nfe«Mi feMtfM. !•««•■ 



940325S1.11345, AVF: 94ddc500_2 

DDC-1, DACS Sun SPARC/SunOS to 680x9 Bare Ada Cross Compiler 
System, Version 4.6.9 




National Institute of Standards and Technology 
Gaithersburg, Maryland 




riT: 


10 . 
AQENCY 


Host: Sun SPARCstation IPX (under SunOS, Release 4.1.1) 
Target: Motorola MVME143 (6030/68882) (bare machine) 







17. 

CLA8SIRCATION 

UNCLASSIRED 


UNCLASSIRED 


£|T1C X 


UNCLASSIFED 


PrssoribsdbyANSISid. 


5 25 090 





























AVF Control Nvunber 
DATE COMPLETED 
BEFORE ON-SITE: 
AFTER ON-SITE: 
REVISIONS: 


NIST94DDC500_2_1.11 

94-03-18 

94-03-28 

94-04-11 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 
Certificate Nxiiaber: 940325S1.11345 
DDC-I 

DACS Sun SPARC/SunoS to 680x0 Bare Ada 
Cross Compiler System, Version 4.6.9 
Sun SPARCstation IPX =»> 

Motorola MVME143 68030/^8882 (Bare Machine) 


Prepared By: 

Software Standards Validation Group 
Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899| 

U.S.A. 


Accesion For 


NTIS CRA&I 
DTIC TAB 
Unannounced 
Justification.^ 


By. 

Dibt ibution | 


I 

□ 


Availability Codes 


Dist 


Avail and / or 
Special 






MIST94DDC500_2_1.11 
DECLARATION OF CONFORMANCE 

Th« following doclaration of confoxiunce was supplied by the custoner. 
Customer: DDC-I 

Certificate Awardee: OOC-I 

Ada Validation Facility: National Institute of Standards and 

Technology 

Computer Systems Laboratory (CSL) 

Software Standards Validation Group 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 

ACVC Version: 1.11 


Ada Implementation: 

Compiler Name and Version: DACS Sun SFARC/SunOS to 680x0 Bare Ada Cross Compiler 

System, Version 4.6.9 

Host Computer System: Sun SPARCstation IPX running under SunOS, Release 

4.1.1 

Target Conputer System: Motorola MVME143 68030/68882 (Bare Machine) 

Declaration: 

I the undersigned, declare that I have no knowledge of deliberate deviations from the 
Ada Language Standard ANSI/MIL-STD-1815A ISO 8652-1987 in the inplementation listed 
above. 

'74 -c-7 - ?r 

Date 


Date 







AVP Control Nuabor: NIST94DDC500_2_1.11 
Cortificato Information 


Tha following Ada implementation was tested and determined to pass ACVC 
1.11. Testing was completed on March 25 , 1994. 

Compiler Name and Version: DACS Sun SPARC/SunOS to 680x0 Bare Ada 

Cross Compiler System, Version 4.6.9 

Host Computer System: Sun SPARCstatlon IPX mmnlng under SunOS, 

Release 4.1.1 

Target Computer System: Motorola MVME143 68030/68882 (Bare 

Machine) 

See section 3.1 for any additional information about the testing 
environment. 


As a result of this validation effort. Validation Certificate 
940325S1.11345 is awarded to ODC-I. This certificate expires 2 years 
after ANSZ/MIL-ST0-1815B is approved by ANSI. 





Ada Validation F^ility 

Or. David K. J^feWs^' Nr. L. Arnold gj^mson 

Chief, Information SylBtems Manager, Software Standards 

Engineering Division (ISED) Validation Group 

Computer Systems Laboratory (CSL) 

National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 
U.S.A. 


Ada ValU^anehyorganizatlon 
Direct^, ^ojiP'ater & Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 


Ada Joint Program Office 
David R. Basel 
Deputy Director, 

Ada Joint Program Office 
Defense Information Systems Agency 
Center for Information Management 
Washington DC 20301 


U.S.A. 








TABLE OF CONTENTS 

CHAPTER 1.1-1 

INTRODUCTION.1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT.1-1 

1.2 REFERENCES.1-2 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES.2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS.2-1 

2.3 TEST MODIFICATIONS.2-3 

CHAPTER 3..................................................3—1 

PROCESSING INFORMATION.3-1 

- 3.1 TESTING ENVIRONMENT..3-1 

3.2 SUMMARY OF TEST RESULTS.3-1 

3.3 TEST EXECUTION.3-2 

APPENDIX A.A-1 

MACRO PARAMETERS.A-1 

APPENDIX B.B-1 

COMPILATION SYSTEM OPTIONS.B-1 

LINKER OPTIONS.B-2 

APPENDIX C.C-1 

APPENDIX F OF THE Ada STANDARD.C-1 





























CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro92] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Sximmary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to [Pro92]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United states, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552) . The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from; 

National Technical Information Service 
5285 Port Royal Road 
Springfield, Virginia 22161 
U.S.A. 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 


Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria, Virginia 22311-1772 

U.S.A. 


1-1 




1.2 REFERENCES 


[Ada83] Referenc e Manual for the_Ada_Proaranunina Language. 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

CPro92] Ada Comp iler Valid ation Procedures. Version 3.1, Ada Joint 
Program Office, August 1992. 

[UG89] Ada Compiler Validation Capability User*s Guide. 21 June 
1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
test classes: A, B, C, D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK_FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. 
Class B tests are not executable. Each test in this class is 
compiled and the resulting compilation listing is examined to 
verify that all violations of the Ada Standard are detected. Some 
of the class B tests contain legal Ada code which must not be 
flagged illegal by the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values—for example, the 


1-2 










largest Integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 
the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and CUG89]). 

In order to pass an ACVC an Ada implementation must process each 
test of the customized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 


Ada Compiler 


Ada Compiler 
Validation 
Capedslllty (ACVC) 


Ada Implementation 


Ada Joint Program 
Office (AJPO) 


Ada Validation 
Facility (AVF) 


Ada Validation 
Organization (AVO) 

Compliance of an 
Ada Implementation 


The software and any needed hardware that 
have to be added to a given host and target 
computer system to allow transformation of 
Ada prograuns into executable form and 
execution thereof. 

The means for testing compliance of Ada 
implementations. Validation consisting of 
the test suite, the support programs, the 
ACVC Capability User's Guide and the 
template for the validation summary (ACVC) 
report. 

An Ada compiler with its host computer 
system and its target computer system. 

The part of the certification body which 
provides policy and guidance for the Ada 
certification Office system. 

The part of the certification body which 
carries out the procedures required to 
establish the compliance of an Ada 
implementation. 

The part of the certification body that 
provides technical guidance for operations 
of the Ada certification system. 

The ability of the implementation to pass an 
ACVC version. 


1-3 




Computer System 


Conformity 

Customer 


Declaration of 
Conformance 


Host Computer 
System 

Inapplicable Test 

ISO 

LRM 


Operating System 


Target Computer 
System 


A f\inctional unit, consisting of one or more 
computers and associated software, that uses 
common storage for all or part of a program 
and also for all or part of the data 
necessary for the execution of the program; 
executes user- written or user-designated 
programs; performs user-designated data 
manipulation, including arithmetic 
operations and logic operations; and that 
can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 

Fulfillment by a product, process, or 
service of all requirements specified. 

An individual or corporate entity who enters 
into an agreement with an AVF which 
specifies the terms and conditions for AVF 
services (of any kind) to be performed. 

A formal statement from a customer assuring 
that conformity is realized or attainable on 
the Ada implementation for which validation 
status is realized. 

A computer system where Ada source programs 
are transformed into executable form. 

A test that contains one or more test 
objectives found to be irrelevant for the 
given Ada implementation. 

International Organization for 
Standardization. 

The Ada standard, or Language Reference 
Manual, published as ANSI/MIL-STD-1815A 
-1983 and ISO 8652-1987. Citations from the 
LRM take the form ”<section>.<subsection>; 
<paragraph>.” 

Software that controls the execution of 
programs and that provides services such as 
resource allocation, scheduling, 
input/output control, and data management. 
Usually, operating systems are predominantly 
software, but partial or complete hardware 
implementations are possible. 

A computer system where the executable form 
of Ada programs are executed. 


1-4 




Validated Ada 
Compiler 

Validated Ada 
Implementation 

Validation 


Withdrawn Test 


The compiler of a validated Ada 
implementation. 

An Ada implementation that has been 
validated successfully either by AVF testing 
or by registration [Pro92]. 

The process of checking the conformity of an 
Ada compiler to the Ada programming language 
and of issuing a certificate for this 
implementation. 

A test found to be incorrect and not used in 
conformity testing. A test may be incorrect 
because it has an invalid test objective, 
fails to meet its test objective, or 
contains erroneous or illegal use of the Ada 
programming language. 


1-5 







CHAPTER 2 

IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Sontt tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 104 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 93-11-22. 


B27005A 

E28005C 

B28006C 

C32203A 

C34006D 

C35507K 

C35507L 

C35507N 

C355070 

C35507P 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

C37310A 

B41308B 

C43004A 

C45114A 

C45346A 

C4S612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A54B02A 

C55B06A 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

B83026B 

C83026A 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

C040240 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

A07201A 

AD7201E 

CD7204B 

A07206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

COA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 






2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents Issued by ISO 
and the AJPO )cnown as Ada Commentaries and commonly referenced in 
the format Al-ddddd. For this implementation, the following tests 
were determined to be inapplicable for the reasons indicated; 
references to Ada Commentaries are included as appropriate. 

The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 

C24113L..Y (14 tests) C35705L..Y (14 tests) 

C35706L..Y (14 tests) C35707L..Y (14 tests) 





C35708L..Y (14 tests) 
C45241L..Y (14 tests) 
C45421L..Y (14 tests) 
C45524L..Z (15 tests) 
C45641L..Y (14 tests) 

C24113I..K (3 tests) use a line 
exceeds 126 characters. 


C35802L..Z (15 tests) 
C45321L..Y (14 tests) 

C45521L..Z (15 tests) 
C45621L..Z (15 tests) 

C46012L..Z (15 tests) 

length in the input file which 


The following 20 tests check for the predefined type LONG_INT£GER; 
for this implementation, there is no such type: 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001W 

C86006C 

CD7101F 


C35404D, C45231D, B86001X, C86006E, and CD7101G check for a 
predefined integer type with a name other than INTEGER, 
LONG_INTEGER, or SHORT_INTEGER; for this implementation, there is 
no such type. 

C35713B, C45423B, B86001T, and C86006H check for the predefined 
type SHORT_FLOAT; for this implementation, there is no such type. 

C35713D and B86001Z check for a predefined floating-point type with 
a name other than FLOAT, L0NG_FL0AT, or SH0RT_FL0AT; for this 
implementation, there is no such type. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations 
for types that require a SYSTEM.MAX_MANTISSA of 47 or greater; for 
this implementation, MAX_MANTISSA is less than 47. 

C45624A..B (2 tests) check that the proper exception is raised if 
MACHINE_OVERFLOWS is FALSE for floating point types and the results 
of various floating-point operations lie outside the range of the 
base type; for this implementation, MACHINE_OVERFLOWS is TRUE. 

C4A013B contains a static universal real expression that exceeds 
the range of this implementation's largest floating-point type; 
this expression is rejected by the compiler. 

D56001B uses 65 levels of block nesting; this level of block 
nesting exceeds the capacity of the compiler. 

B86001Y uses the name of a predefined fixed-point type other than 
type DURATION; for this implementation, there is no such type. 

C96005B uses values of type DURATION'S base type that are outside 
the range of type DURATION; for this implementation, the ranges are 
the same. 


2-2 







CA2009C and CA2009F check whether a generic unit can be 
instantiated before its body (and any of its subunits) is compiled; 
this implementation creates a dependence on generic units as 
allowed by AI’>00408 and AI-00506 such that the compilation of the 
generic unit bodies makes the instantiating units obsolete. (See 
section 2.3.) 

CD1009C checks whether a length clause can specify a non-defaiflt 
size for a floating-point type; this implementation does not 
support such sizes. 

CD2A84A, CD2A84E, C02A84I..J (2 tests), and CD2A840 use length 
clauses to specify non-default sizes for access types; this 
implementation does not support such sizes. 

The following 264 tests check operations on sequential, text, and 
direct access files; this implementation does not support external 
files: 


CE2102A..C 

(3) 

CE2102G..H 

(2) 

CE2102K 


CE2102N..Y i 

(12) 

CE2103C..0 

(2) 

CE2104A..D 

(4) 

CE2105A..B 

(2) 

CE2106A..B 

(2) 

CE2107A..H 

(8) 

CE2107L 


CE2108A..H 

(8) 

CE2109A..C 

(3) 

CE2110A..D 

(4) 

CE2111A..1 

(9) 

CE2115A..B 

(2) 

CE2120A..B 

(2) 

CE2201A..C 

(3) 

EE22010..E 

(2) 

CE2201F. .N 

(9) 

CE2203A 


CE2204A..0 

(4) 

CE2205A 


CE2206A 


CE2208B 


CE2401A..C 

(3) 

EE2401D 


CE2401E..F 

(2) 

EE2401G 


CE2401H..L 

(5) 

CE2403A 


CE2404A..B 

(2) 

CE2405B 


CE2406A 


CE2407A..B 

(2) 

CE2408A..B 

(2) 

CE2409A..B 

(2) 

CE2410A..B 

(2) 

CE2411A 


CE3102A..C 

(3) 

CE3102F..H 

(3) 

CE3102J..K 

(2) 

CE3103A 


CE3104A..C 

(3) 

CE3106A..B 

(2) 

CE3107B 


CE3108A..B 

(2) 

CE3109A 


CE3110A 


CE3111A..B 

(2) 

CE3111D..E 

(2) 

CE3112A..D 

(4) 

CE3114A..B 

(2) 

CE3115A 


CE3119A 


EE3203A 


EE3204A 


CE3207A 


CE3208A 


CE3301A 


EE3301B 


CE3302A 


CE3304A 


CE3305A 


CE3401A 


CE3402A 


EE3402B 


CE3402C..D 

(2) 

CE3403A..C 

(3) 

CE3403E..F 

(2) 

CE3404B..D 

(3) 

CE3405A 


EE3405B 


CE3405C..0 

(2) 

CE3406A..0 

(4) 

CE3407A..C 

(3) 

CE3408A..C 

(3) 

CE3409A 


CE3409C..E 

(3) 

EE3409F 


CE3410A 


CE3410C..E 

(3) 

EE3410F 


CE3411A 


CE3411C 


CE3412A 


EE3412C 


CE3413A..C 

(3) 

CE3414A 


CE3602A..D 

(4) 

CE3603A 


CE3604A.oB 

(2) 

CE3605A..E 

(5) 

CE3606A..B 

(2) 

CE3704A..F 

(6) 

CE3704M..0 

(3) 

CE3705A..E 

(5) 

CE3706D 


CE3706F..G 

(2) 

CE3804A..P 

(16) 

CE3805A..B 

(2) 

CE3806A..B 

(2) 

CE3806D..E 

(2) 

CE3806G..H 

(2) 

CE3904A..B 

(2) 

CE3905A..C 

(3) 

CE3905L 


CE3906A..C 

(3) 

CE3906E..F 

(2) 


CE2103A, CE2103B, and CE3107A use an illegal file name in an 
attempt to create a file and expect NAME_ERROR to be raised; this 
implementation does not support external files and so raises 
USE_ERROR. (See section 2.3.) 


2-3 





2.3 TEST MODIFICATIONS 


Modifications (see section 1.3) were required for 72 tests. 

The following tests were split into two cr more tests because this 
implementation did not report the violations of the Ada Standard in 
the way expected by the original tests. 


B22003A 

B35101A 

B38009B 

B61001R 

B83E01D 

B91002C 

B91002J 

B95077A 

BC1109D 


B26001A 

B37106A 

B55A01A 

B61001W 

B83E01E 

B91002D 

B91002K 

B97103E 

BC1202A 


B26002A 

B37301B 

B61001C 

B67001H 

B85001D 

B91002E 

B91002L 

B97104G 

BC1202F 


B26005A 

B37302A 

B61001F 

B83A07A 

B85008D 

B91002F 

B95030A 

BAIOOIA 

BC1202G 


B28003A 
B38003A 
B61001H 
B83A07B 
B91001A 
B91002G 
B95061A 
BAUD IB 
BE2210A 


B29001A 

B38003B 

B61001I 

B83A07C 

B91002A 

B91002H 

B95061F 

BC1109A 

BE2413A 


B33301B 

B38009A 

B61001M 

B83E01C 

B91002B 

B91002I 

B95061G 

BC1109C 


C83030C and C86007A were graded passed by Test Modification as 
directed by the AVO. These tests were modified by inserting 
"PRAGMA ELABORATE (REPORT);" before the package declarations at 
lines 13 and 11, respectively. Without the pragma, the packages 
may be elaborated prior to package Report's body, and thus the 
packages' calls to function REPORT.IDENT_INT at lines 14 and 13, 
respectively, will raise PROGRAM^ERROR. 

CA2009C and CA2009F were graded inapplicable by Evaluation 
Modification as directed by the AVO. These tests contain 
instantiations of a generic unit prior to the compilation of that 
unit's body; as allowed by AI-00408 and AI-00506, the compilation 
of the generic unit bodies makes the compilation unit that contains 
the instantiations obsolete. 

BC3204C and BC3205D were graded passed by Processing Modification 
as directed by the AVO. These tests check that instantiations of 
generic units with unconstrained types as generic actual parameters 
are illegal if the generic bodies contain uses of the types that 
require a constraint. However, the generic bodies are compiled 
after the units that contain the instantiations, and this 
implementation creates a dependence of the instantiating units on 
the generic units as allowed by AI>00408 and AI-00506 such that the 
compilation of the generic bodies makes the instantiating units 
obsolete—no errors are detected. The processing of these tests 
was modified by re-compiling the obsolete units; all intended 
errors were then detected by the compiler. 


CD2A83A was graded passed by Test Modification as directed by the 
AVO. This test uses a length clause to specify the collection size 
for an access type whose designated type is STRING; eight 


2-4 





dMignatttd objects are allocated, with a combined length of 30 
characters. Because of this implementation's heap-management 
strategy and alignment requirements, the collection size at line 22 
had to be increased to 812. 

CE2103A, CE2103B, and CE3107A were graded inapplicable by 
Evaluation Modification as directed by the AVO. The tests abort 
with an unhandled exception when USE ERROR is raised on the attempt 
to create an external file. This Ts acceptable behavior because 
this implementation does not support external files (cf. AI-00332). 






CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

Th« Ada implenentation tested in this validation effort is 
described adequately by the infomation given in the initial pages 
of this report. 

For technical information about this Ada implementation, contact: 

Forrest Holemon 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 
Telefax: 602-275-7502 

For sales information about this Ada implementation, contact: 

Hike Halpih 

410 North 44th Street, Suite 320 
Phoenix, Arizona 85008 (U.S.A.) 

Telephone: 602-275-7172 
Telefax: 602-275-7502 

Testing of this Ada implementation was conducted at the customer's 
site by a validation team from the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro923. 

For all processed tests (inapplicable and applicable), a result was 
obtained that conforms to the Ada Programming Language standard. 

The list of items below gives the number of ACVC tests in various 
categories. All tests were processed, except those that were 
withdrawn because of test errors (item b; see section 2.1), those 
that require a floating-point precision that exceeds the 
implementation's maximum precision (item e; see section 2.2), and 
those that depend on the support of a file system—if none is 
supported (item d). All tests passed, except those that are listed 
in sections 2.1 and 2.2 (counted in items b and f, below). 


3-1 









a) Total NUabar of Applicabla Tasts 3542 

b) Total Nuabar of Withdrawn Tasts 104 

c) Procassad Inapplicedsla Tasts 524 

d) Non-Procassad I/O Tests 0 

a) Non-Procassad Floating-Point 

Precision Tests 0 


f) Total Nuabar of Inapplicable Tests 524 (c+d-t-e) 

g) Total Nuabar of Tasts for ACVC 1.11 4170 (a+b+f) 


3.3 TEST EXECUTION 

A aagnatic tape containing the custoaized test suite (see section 
1.3) was taken on-site by the validation teaa for processing. The 
contents of the aagnetlc tape were loaded directly onto t lost 
coaj^uter. 

After the test files were loaded onto the host coaputer, the full 
set of tests was processed by the Ada lapleaentation. The DDC-I 
Ada do%mloader runs on the S\m SPARCstation IPX and is used for 
downloading the executable iaages to the target Motorola MVME143 
68030/68882 (Bare Machine) and to capture the results. The DDC-I 
Debug Monitor runs on the target Motorola MVME143 68030/68882 (Bare 
Machine) and provides coaaunication Interface between the host 
debugger and the executing target Motorola MVME143 68030/68882 
(Bare Machine). The two processes coaaunicate via RS-232 to 
download and to upload. 

The tests were compiled and linked on the host computer system, as 
appropriate. The executable Images were transferred to the target 
computer system by the communications link described above, and 
run. The results were captured on the host computer system. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B for 
a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this test 
were: 


-nowaming -list 
The linker options specified were: 


al -cpu 
-fpu 

-ram_base 

-rauB 

-main 


68030 

68882 

0x10000 

0X0, 0x3fffff 

stack size«0xl00000 


3-2 







-tcb 

-ucc 


30 

ada invmel43.slb 


Teat output, conpiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. The listings 
examined on-site by the validation team were also archived. 


3-3 






APPENDIX A 


MACRO PARAMETERS 


This appsndix contains the macro parameters used for customizing 
the ACVC. The meaning and purpose of these parameters are 
explained in [U689]. The parameter values are presented in two 
tables. The first table lists the values that are defined in terms 
of the maximum input-line length, which is the value for 
$MAX_ZN LEN—also listed here. These values are expressed here as 
Ada string aggregates, where "V** represents the maximum input-line 
length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 126 — Value of V 

$BIG_ID1 (1..V-1 «> 'A', V -> 'I') 

$BIG_ID2 (1..V-1 •> 'A', V -> '2') 

$BIG_ID3 (1..V/2 -> 'A') 6 '3' & (1..V-1-V/2 -> 'A') 

$BIG_ID4 (1..V/2 -> 'A') 6 '4' & (1. .V-l-V/2 -> 'A') 

$BIG_INT_LIT (1..V-3 -> *0') & "298'* 

$BIG_REAL_LIT (1..V-5 •> '0') & "690.0" 

$BIG_STRING1 & (1..V/2 -> 'A') & 

$BIG_STRING2 & (1..V-l-V/2 -> 'A') & *1' & •""• 

$BLANKS (1..V-20 »> • •) 

$MAX__LEN_INT_BASED_LITERAL 

"2;" & (1..V-5 -> '0') & "11:" 

$MAX_LEN_REAL_BASED_LITERAL 

"16:" & (1..V-7 »> '0') & "F.E:" 

$MAX_STRING_LITERAL & (1..V-2 «> 'A') & 


A-1 









Th« following table contains the values for the remaining 
macro parameters. 

Macro Parameter Macro Value 


ACC SIZE 

ALIGNMENT 

COUNT_LAST 

DEFAULT_MEM_SIZE 

DEPAULT_STOR_UNIT 

DEFAULT_SYS NAME 

DELTA DOC 

entry'address 

ENTRY_ADDRESS1 

ENTRY_ADDRESS2 

FIELD^LAST 

FILE_TERMINATOR 

FIXED_NAME 

FLOAT__NAME 

FORM_STRING 

FORM STRIMG2 


32 

4 

2_147_483_647 

2#1«E32 

8 

DACS_680X0 

2#1.0«E-31 

FCNDECL.ENTRY.ADDRESS 
FCNDECL.ENTRY.ADDRESS1 
FCNDECL.ENTRY.ADDRESS2 
35 

I I 

MO_SUCH_TYPE 

NO_SUCH_TYPE 

ItH 


CONNOT 

GREATER_THAN_DURATION 
GREATER THAN DURATION_BASE_LAST 

greater”than”float_base last 

greater”than“float_safe~large 

greater_than“short_float_safe_large 

HIGH PRIORITY 

illegal_external_file_namei 

ILLEGAL_EXTERNAL_FILE_NAME2 

INAPPROPRIATE_LINE__LENGTH 

INAPPROPRIATE_PAGE_LENGTH 

INCLUDE_PRAGMA1 

PRAGMA 

INCLUDE PRAGMA2 : 


RESTRICT_FILE_CAPACITY'' 

"lOOOOO.O 

200000.0 

16«1.0«E-»-32 

16#5.FFPF_F0#E+31 

16#5.FPFF_F0#E+31 

24 

/NODIRECTORYl/FILENAMEl 
/NODIRECTORY1/FILENAME2 
-1 
-1 

INCLUDE ("A28006D1.ADA") 


PRAGMA 

INTEGER_FIRST : 

INTEGER_LAST : 

INTEGER_LAST_PLUS_1 : 

INTERFACE_LANGUAGE : 

LESS_THAN_DURATION : 

LESS_THAN_DURATION_BASE_FIRST 
LINE_TERMINATOR : 

LOW__PRIORITY : 

MACHINE_CODE_STATEMENT : 

AA_INSTR' (AA__EXIT_SUBPRGRM,0, 
MACHINE_CODE__TYPE : 

MANTISSA DOC : 

MAX DIGITS : 


INCLUDE (’'B28006E1.ADA") 
-2147483648 
2147483647 
2147483648 
AS 

-75000.0 

-131073.0 

I I 
1 

0,0,AA_INSTR_INTG'FIRST,0) 

AA_INSTR 

31 

15 


A-2 











HAX_IlfT 

MAX I1IT_PUJS_1 

min'int 

NAME 

NAME_LIST 

NAME_SPECIFICATI0N1 

NAME_SPECIFICATI0N2 

NAME_SPECIFICATI0N3 

MEG_BASED_INT 

NEW_MEM_SIZE 

NEW_STOR_UNIT 

NEW__SYS_NAME 

PAGE_TERMINATOR 

RECORD_DEFINITION 

RECORD - INSTR_NO 
ARG2:INTEGER;ARG3 

RECORO_NAME 
TASK_SIZE 
TASK_STORAGE_SIZE 
TICK 

VARIABLE_ADDRESS 
VARIABLE ADDRESS1 


2147483647 

2147483648 

•2147483648 

NO_SUCH_TYPE_AVAILABLE 
DACS 680x0 


/home/sun2/ada/68030/test/wrk/X212 0A 

/home/sun2/ada/68030/test/wr)c/X2120B 

/home/sun2/ada/68030/test/wrk/X3119A 
: 16«F000000E« 

: 2097152 
: 8 

: DACS 680x0 


INTEGER;ARGO:INTEGER;ARGl:INTEGER; 
INTEGER;END - RECORD; 

; AA_INSTR 
: 96 
: 1024 

: 2#1.0#E-14 

: FCNDECL.VARIABLE_ADDRESS 
: FCNDECL.VARIABLE ADDRESS1 


VARIABLE ADDRESS2 
YOUR PRAGMA 


FCNDECL.VARIABLE_ADDRESS 2 
NOFLOAT 


A-3 









APPEKOIX B 


COMPILATION SYSTEM OPTIONS 


Th« coBpll«r options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to compiler documentation and 
not to this report. 


B-1 








T 


.l.iPiJii I .JIM 


5 THE ADA COMPILER 


The Ada Compiler compiles all program units within the specified source file and inserts the 
generated otgects into the cunem sublibrary. Compiler options are provided to allow the user 
control of optimization, run-time checks, and compiler input and mitput files such as list files, 
configuration files, the program library used. etc. 

The input to the compler consists of the source file, the configuration file (which ctmtrols the 
format of the list file), and the compiler optitms. Section S.l provides a list of all com{»ler 
options, aid Section 5.2 describes the source aid configuration files. 

OuQHit omsists of an object placed in the program library, diagnostic messages, and optional 
listings. The omfiguration file and the cornier options specify the forma and contents of the 
lia information. Output is described in section 5.3. If any diagnostic messages are produced 
during the compilation, they are output to the diagnostic file and on the current ouqiut file. The 
diagnostic file and the diagnostic messages are desoibed in Section 5.3.2. 

The compiler uses a program library during the compilation. The compilation unit may refer to 
units fiom the program library, and an internal representation of the compilation unit will be 
included in the program library as a result of a successful compilation. The program library is 
described in Qu^r 3. Section 5.4 briefly describes how the Ada compiler uses the library. 


5.1 The Invocation Command 

Invoke the Ada compiler with the following command to the SunOS shell: 

$ ada {<option>} <soiirceH)r-unit> 
where the options and parameters are: 


35 




DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
The Ada Compiler 


OPTION DESCRIPTION 


REFERENCE 


•(nolautoJnline 

Automatic inline expansion of local subprograms. 

5.1.1 

•body 

Compile body unit from source saved in library. 

5.1.2 

nhanir 

•CMCK 

Specifies run-time constraim checks. 

5.1.3 

•configunitioii-flle 

Specifies the configuration file used by the compiler 

5.1.4 

•(noldebug 

Generate debug infonnation. 

5.1J 

•(noinMi 

Generate code for the floating point co-processors 

5.1.6 

•Ubrary 

Specifies program library used. 

5.1.7 

•[nollitt 

Writes a source listing on the list file. 

5.1.8 

•mo^ 

Protection mode. 

5.1.9 

-optimixe 

Specifies compiler optimizatiotL 

5.1.10 

•[no]save-source 

Insens source text in program library. 

5.1.11 

•spccUlcation 

Comfrile specification unit from source saved in library. 

5.1.12 

•(nolverbose 

Displays compiler progress. 

5.1.13 

•[noiwarnings 

Di^ay warning fim the compiler 

5.1.14 

•[noixref 

Creates a cross reference listing. 

5.1.15 

<souroeH>r-uiiit> 

The name of the source file or unit to be compiled. 

5.1.16 


Examples: 

$ adla -list t«atpro 9 

This example compiles the source file testprogjida and generates a list file with the name 
testprogJis. 

$ ada -library aqr-library test 

This example compiles the source file testada imo the library my Jibrary. 

Default values exist for most options as indicated in the following sections. Options and q)tion 
keywmds may be abbreviated (characters omitted from the right) as long as no ambiguity arises. 
Casing is significant for options, but not for option keywords. When conflicting options are given 
on the cmnmand Uim, (e.g. *1181 and >nolist) the last one is used. 


5.1.1 •[nolauto-inline 

•auto-inline LOCAL | GLOBAL 
•noautoJnline (default) 

This option specifies whether subprograms should be inline expanded. The inline expansion only 
occurs if the subprogram has less than 4 object declartuions and less than 6 statements, and if the 
subprogram fulfills the requirements defined for pragma INLINE (see Section B.2.3). LOCAL 
specifies that only inline expansion of locally defined subprograms should be doiK, while 
GLOBAL will cause inline expansion of all sul^nograms, including subprograms from other 
units. 


36 








DACS 68Qr 0 Bale Ada Croas CompQ^ System - User’s Guide 
The Ada Cornier 


A waming is issued when inline expansron is not achieved. 


5.1 J -body 


•body 


When using the option 'body the Ada compiler will recompile the body of the unit specified as 
parameter to the Ada compiler (see section 5.1.16) into the current sublibraiy. The source code 
saved in the program library at the previous comi^tion of the body is used as the source code 
to be comfril^ If no source code is present or the body for the unit does not exist in the library, 
an error message is issued. This option is primarily for use by the Ada Recompiler (see chapter 
7). 


5.1 J -check 

-check [ <keyword> s ON | OFF { y<keyword> = ON | OFF } ] 

•check ALL=ON (default) 

•check q)ecifies which run-time checks should be performed. Setting a nm-time check to ON 
enables the check, while setting it to OFF disaldes the check. All run-time checks are enabled by 
default. The following explicit checks will be disabled/enabled by using the name as <keyword>: 


ACCESS 

ALL 

DISCRIMINANT 

ELABORATION 

INDEX 

LENGTH 

OVERFLOW 

RANGE 

STORAGE 


CTheck for access values being non NULL. 
All checks. 

Checks for discriminated fields. 

Checks for subprograms being elaborated. 
Index dieck. 

Array length check. 

Explicit overflow checks. 

Checks for values being in range. 

Checks for sufRcient storage availalde. 


5.1.4 •configuration.fDe 

-configuration-file <file-qMC> 

•configuration-file oonfig (defoult) 

This qxion ^recifies the configuration file to be used by the compiler in the current compilation. 
The c^gunition file allows the user to format compiler listings, set error limits, etc. If tiie 
option is omitted the cmifigutaticm file config located in the same directory as the Ada compiler 
is used by default Section 52.2 ctmtains a description of tiie configuration file. 


37 




OACS 680x0 Bare Ada Cross Compiter System - User’s Guide 
The Ada Compiler 


S.1J$ -[noldcbug 


•debug 

•nodebug (default) 

• 

Generate debug infonnation for the compilation and store the information in the program library. 
This is necessary if the unit is to be debugged with the DDC-I Ada Symbolic Cross Debugger. 
Note that the program must also be linked with the -debug option, if the program is to be 
debugged with the DDC-I Ada Symbdic Cross Debugger. See S^on 6.2.4. 


S.lii -[no]f^u 

•f)pu (default) 

•[nolftni 

If the -ffM option is specified the compiler will assume that a floating point co-processor is present 
and generate code accordingly. If the -nolfw option is specified the compiler will assume that a 
floating point co-processor is not present, and will not generate instructions for the co-processors. 
Floating point operations are instead implemented by calls to tun time library. 


5.1.7 -library 

•library <file-speo 

•library $ADA-LIBRARY (default) 

This option specifies the cuirent sublibrary that will be used in the compilation and will receive 
the objea when the compilation is complete. By specifying a current sublibrary, the current 
program library (current suUibrary arul ancestors op to root) is also implicitly ^cified. 

If this option is omitted, the sublibraiy designated by the environmental variable ADA-LIBRARY 
is used as the current sublibrary (see Chapter 3). Section S.4 describes how the Ada compiler uses 
the library. 


5.1B -[nollist 


•Ust 

-nollst (default) 

•fist specifies tiiat a source listing will be produced. The source listing is written to the list file, 
which has the ruune of the source file with the extension Jis. Section 5.3.1.1 contains a description 
of the source listing. 

If -nolist is active, no source listing is produced, regardless of LIST pragmas in the program or 
diagnostic messages produced. 


38 






DACS 610x0 Bare Ada Cross CbopOer System 
The Ada Compiler 


User’s Guide 


5.1^ -nibde 

•mode ALL i BASIC | SECURE 
•mode ALL (default) 

The compiler generates code to execute in a non-protected BASIC mode, or in a {Motected 
SECURE mode according to die •mode option. Code can be generated to run in all protection 
modes by qiecifying ALL, this way protection mode can be decided at link time. The fastest and 
most cooqMct code is geneiated by selecting the [Motectitm mode in which the program shall 
execute. Please refer to chapter 10 for details on protection modes. Mode SECURE is only usable 
if die pR^ram will be linl^ for a Motorola 68030 or 68040 processor. 


5.1.10 •optimize 

•optimize [ <keyword> = ON | OFF { ,<keyword> = ON | OFF } ] 

•optindze ALL^FF 

This option specifies which optimizations wiU be performed during code generation. The possible 
keywords are: 


ALL 

CHECK 

CSE 

FCT2PROC 

REORDERING 

STACK_HEIGHT 

BLOCK 


All possible optimizations are invoked. 

Eliminates superfluous checks. 

Performs common subexpression elimination including common address 
expressions. 

Change function calls returning objects of constrained array types or 
objects of record types to procedure calls. 

Transforms named aggregates to positional aggregates and named 
parameter associations to positional associations. 

Performs stack height reductions (also called Aho UUman reordering). 
Optimize block and call frames. 


Setting an optimization to ON enables the optimization, while setting an optimization to OFF 
disables the optimization. All optimizations are disaUed by default In addition to the optional 
optimizations, the compiler always performs the foUowit^ optimizations: constant folding, dead 
code elimination, and selection of optimal jumps. 


5.U1 •(nolsave-source 

•nve-jource (default) 

•nosave-source 

When •save-source is specified, a copy of the compiled source code is placed in the program 
litnary. If •nosave-souroe is used, source code will not be retained in the program library. 

Using •nosave-source, while helping to keep lilxary sizes smaller, does affect the operation of 
the recompiler, see Chapter 7 for more details. Al^, it will not be possible to do symbolic 
debugging at the Ada source code level with the DACS-680x0 Symbolic Ada Debugger, if the 
source code is not saved in the library. 


39 





DACS 680x0 Bare Ada Cross Compiler System • User's Guide 
The Ada Compiler 


5.1.12 •spedflcation 
•specification 

When using the option •specification the Ada compiler wUl recompile the specification of the unit 
specified as parameter to the Ada compiler (see section S.1.16) into the current sublibrary. The 
source code saved in the program libra^ at the previous compilation of the specification is used 
as the source code to be compiled. If no source code is presem or the ^lecification for the unit 
does not exist in the library, an error message is issued. This option is primarily for use by the 
Ada Recom{^er (see chapter 7). 


5.1.13 •(nolverbose 
•verbose 

•noverbose (default) 

When •verbose is specified, the compiler will output infomiation about which pass the compiler 
is currently running, otherwise no information will be output 


5.1.14 •(nolwamings 

•warnings (default) 

•nowamings 

All warnings from the Ada Compiler are displayed when option •warnings is specified. All 
compiler warnings are suppressed when -nowarnings is specified. See Section S.3.2 for a 
description of how and when warnings are reported from the Ada Compiler. 


5.1.15 •[no]xref 


•xref 

•iwxref (default) 

A cross-reference listing can be requested by the urer by means of the option -xref. If the •xref 
option is given and no severe or fatal errors are found during the compilation, the cross-reference 
listing is written to the list file. The cross-reference listing is described in Section S.3.1.3. 


5.1.16 The Source or Unit Parameter 
<source-or-unit> 

This parameter specifies either the text file containing the Ada source text to be compiled or, 
when option -body or -specification is used, the name of the unit to be compiled. When 
interpreted as a file name, the file type ".ada" is assumed by default, if the file type is omined 
in the source file specification. 


40 








.. I'URj^v" fi.., 'VJ' W'-*; ■:WT^' 


DACS 680x0 Bwe A(to Cion Compiler System - User’s Guide 
The Ads Compiler 



5J Compiler Input 

Input to the compiler consists of the command line options, a source text file and. optionally, a 
configuratum file. 


SJM Source Text 

The user submits one file containing a source text in each compilation. 

The foimat of the source text must be in ISO-FORMAT ASCII. This format requires that the 
source text is a sequence of ISO characters QSO Standard 646). where each line is terminated by 
either one of the following termination sequences (CR means carriage return, VT means vertical 
tabulafion, LF means line feed, and FF means form feed): 

• A sequence of one or more CRs, where the sequence is neither irmnediately preceded nor 
immediately followed by any of the characters VT. LF, or FF. 

• Any of the characters VT. LF, or FF, immediately preceded and followed by a sequence 
of zero or more CRs. 

In general. ISO control characters are not permitted in the source text with the following 
exceptions: 

• The horizontal tabulation (HT) charaaer may used as a separator between lexical units. 

• LF, VT. FF, and CR may be used to terminate lines, as described above. 

The maximum number of characters in an input li^ie is determined by the contents of the 
configuration file (see Section 5.2.2). The control characters CR, VT, LF, and FF are not 
considered a part of the line. Lines containing more than the maximum number of characters are 
truTKated and an error message is issued. 


5JL2 Configuration File 

Certain processing characteristics of the compiler, such as format of irqrut and output and error 
limit, may be modified by the user. These characteristics are passed to the compiler by means 
of a configuration file, which is a standard SunOS text file. The ctmtents of the configuration 
file must be an Ada positional aggre^te, written on one line, of the type 
CONFIGURAHON-RECO^, which is described below. 

The configuration file (config) is not accepted by the compiler in the following cases: 

• The syntax does not conform with the syntax for positional Ada aggregates. 

• A value is outside the ranges specified. 

• A value is not specified as a literal. 

• LINES_PER_PAGE is not greater than TOP-MARGIN + BOTTOM-MARGIN. 


41 







DACS 680x0 Bare Ada Cross Compiler System • Usm-’s Guide 
The Ada Cominler 


• The aggregate occupies more than one line. 

If the omnpiler is unable to accept the configuration file, an error message is written on current 
output and the compilation is terminated. 

Below is a description of the record whose values must appear in aggr^ate fonn within the 
configuration file. The record declaration makes use of some other types (given below) for the 
sidce of dttfity. 


type CONFIGURATZON.n£CORD is 
record 

IN_FORMAT : ZNFORMXTTING; 

OUT-FORMAT : OUTFORMATTING; 
ERROR-LIMIT : INTEGER RANGE 1..32-767; 
end record; 


type INPUT-FORMATS is (ASCII) 


type INFORMATTING is 
record 

INPUT-FORMAT 
INPUT-LINELENGTH 
end record; 

type OUTFORMATTING is 
record 

LINES-PER-PAGE 
TOP-MARGIN 
BOTTOM-MARGIN 
OUT-LINELENGTH 
SUPPRESS-ERRORNO 
end record; 


INPUT-FORMATS; 

INTEGER range 72..250 


INTEGER range 30..100 
INTEGER range 4.. 90 
INTEGER range 0.. 90 
INTEGER range 80..132 
BOOLEAN; 


The outformatting parameters have the following meaning: 

1) LINES-PER-PAGE: specifies the maximum number of lines written on each page 
(including top and bottom margin). 

2) TOP-MARGIN: specifies the number of lines on top of each page used for a standard 
heading and Uank lines. The heading is placed in die middle lines of the top margin. 

3) BOTTOM-MARGIN: specifies the minimum number of lines left Uank in the bottom of 
the page. The number of lines available for the listing of the program is LINES 
PER-PAGE - TOP-MARGIN - BOTTOM-MARGIN. 

4) OUT-LINELENGTH: specifies the maximum number of characters written on each line. 
Lines longer than OUT-LINELENGTH are separated into two lines. 

5) SUPPRESS-ERRORNO: specifies the foimat of eiror messages (see Section S.3.2.2). 


42 










DACS 680x0 Bare Ada Cron Gompiler System - User’s Guide 
The Ada Compiler 


The none of a user-sup(^ed configuration file can be passed to the compiler through the 
•conflguration_file option. DDC-1 supftiies a default configuration file (config) with the following 
content: 

((ASCU, 126), (48,5.3,100,FALSE). 200) 



Figure 5.1: Page Layout 


5 J Compiler Output 

The compiler may produce output to the list file, the diagnostic file, and the curtem output file. 
It also urates the program libraiy if the compilation is successful. The present section describes 
the text output in the three files mentioned above. The updating of the program library is described 
in Section 5.4. 

The ctnnpiler may produce the following text output: 

1) A listing of the source text with embedded diagnostic messages is written to die list file, 
if the option 'list is active. 

2) A compilation summary is written to the list file, if -list is active. 


43 






DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
The Ada Compiler 


3) A cross-reference listing is written to the list file, if -xref is active and no severe or fatal 
errors have been detected during the compilation. 

4) If there are any diagnostic messages, a dii^nostic file containing the diagnostic messages 
is written. 

5) Diagnostic messages other than warnings are written on the current output file. 


5 J.1 Hie List FUc 

If the user requests any listings by specifying the options -Ust or -XTcf, a new list file is created. 
The name of the list file is identical to the name of the source file except that it has the file type 
"Jis". The file is located in the current directory. If any such file exists prior to the compilat^, 
the file is deleted. 

The list file may include one or more of the Avowing parts: a source listing, a cross-reference 
listing, and a compilation summary. 

The parts of the list file are separated by page ejects. The contents of each part are described in 
the following sections. 

The format of the output to the list file is controlled by the configuration file (see Section 5.22) 
and may therefore be controlled by the user. 


5 J.1.1 Source Listing 

A source listing is an unmodified copy of the source text. The listing is divided into pages and 
each line is supplied with a litw number. 

The number of lines output in the source listing is governed by the occurrence of LIST pragmas 
and the number of objectionable lines. 

• Parts of the listing can be suppressed by the use of LIST pragmas. 

• A line containing a omsmict that caused a diagnostic message to be produced is printed 
even if it occurs at a point where listir^ has been suppressed by a LKT pragma 


5J.12 Compilation Summary 

At the end of a comi»lation, the compiler produces a summary that is output on the list file if the 
option -list is active. 

The summary ctmtains infonnation about: 

1) The type and name of the compilation unit, and whether it has been compiled successfully 
or not. 


44 




DACS 6I09B0 Bare Ada Qoia Compiler Syreem - Iter’s Ctede 
The Ada Compiler 


2) The number of diagnostic messages produced for each class of severity (see Section 5.3.2.1). 

3) Which options were active. 

4) The fiiU name of the source file. 

5) The lull name of the current sublibniy. 
d) The number of source text lines. 

7) The sire of the code produced (specified in bytes). 

8) Elapsed real time and elapsed (7U time. 

9) A "CompQation tenninated" message if the compilation unit was die last in the compUation 
or "Compilation of next unit initiated" otherwise. 


5 J.1J Cross-Reference Listing 

A aoss-referenoe listing is an alphabedcally soned list of identifiers, operators and character 
literals of a compilation unit The list has an entry for each entity declared and/or used in the 
unit with a few exceptions stated below. (Tverioading is evidenced the occurrence of multiple 
entries for the same identifier. 

Fbr instantiations of generic units, the visible declarations of the generic unit are included in the 
cross-reference listing immediately after the instantiation. The visiUe declarations ate the 
subprogram parameters for a generic subprogram and the declarations of the visible part of the 
package declaration for a generic padcage. 

For type declarations, all imidicitly declared operations are included in the cross-reference listing. 

Cross-reference information will be produced for every constituent character literal for string 
literals. 

The fidlowing are not included in the cross reference listing: 

• Pragma identifiers and pragma argument idemifiers. 

• Numeric literals. 

• Record component identifiers and discriminant identifiers. For a selected name whose 
sdector denotes a record componem or a discriminant, only the prefix generates 
cross-reteence information. 

• A parent unit rume (following the keyword SEPARATE). 


45 







DACS 680x0 Bait Ada Cress Compiler System • User’s Guide 
The Ada Cmnpiler 


Each entry in the cfoss-refeitnoe listing contains; 

• The kkmifier with at most IS characters. If the identifier exceeds IS characters, a bar ("I”) 
is wrinen in the 16th position and the rest of the characters are not printed. 

• The place of the definiticm. i.e. a line number if the entity is declared in the current 
compUttion unit, otherwise the name of the complation unit in which the entity is declared 
and the line munber of the dedandon. 

• The line numbers at which the endty is used. An asterisk C*'*) after a line number indicates 
an assignment to a variable, initialization of a constam, assignments to functions, or 
user-defined opeiitois by means of RETURN statements. 


532 The Diagnostic File 

The name of the diagnostic file is identical to the name of the source file exc^ that it has the 
file type ".mt". It is located in the current directory. If any such file exists prior to the 
compilatkm the newest version of the file is deleted. If any diagnostic messages are produced 
during the compilation a new diagnostic file is creiaed. 

The diagnostic file is a text file containing a list of diagnostic messages, each preceded by a line 
showing die number of the line in the source text causing the message, and foUowed by a Uank 
line. There is no separation into pages and no headings. The file may be used by an imeractive 
editor to show the diagnostic messages together with the erroneous source text 


5JJ.1 Diagnostic Messages 

The Ada compiler issues diagnostic messages to the diagnostic file. Diagnostics other than 
warnings also appear on standard output If a source text listing is required, the diagnostics are 
also found embedded in the list file (see Section S.3.1). 

In a source listing, a diagnostic message is placed immediately after the source line causing the 
message. Messages not related to any particular line are {daced at the tq> of the listing. The lines 
are ordered by increasing source line numbers. Line number 0 is assigned to messages not related 
to any particular line. ^ standard ouqmt the messages appear in the order in which they are 
general^ by the compiler. 

The diagnostic messages are classified according to their severity and the compiler action taken: 


Warning: Reports a qirestimiaUe construct or an error that does not influence the meaning of the 
program. Warnings do not hinder the generation of object code. 

Example: A warning will be issued for constructs for which the compiler detects that 
they will raise CONSTRAINT_ERROR at ran time. 


Error Reports an illegal construct in the source program. Compilation continues, but no object 
co^ will be generated. 


46 








DACS 6I0h 0 Bare Alta QroM Compikr Syreem • User’s Guide 
The Ada Compiler 


Examples: roost syntax errors: most static semantic errors. 


Severe Reports an error which causes the compilation to be terminated immediately. No object 
error code is genermed. 

Exan^: A severe error message will be issued if a library unit mentioned by a WITH 
clause is not presem in the currem progimn librw^. 


Fatal Reports an error in the compiler system itself. Compilation is teimiruted immediately 

etitMT. and no olrject code is produced. The user may be aide to circumvent a fatal error 

correcting the program or by replacing program constructs witti alternatives. Please 
. inform DDC-I about the occurrence of faial errors. 

The detection of mote errors than allowed by the number specified by the 
ERROR_LIMIT parameter of the configuration fife (see section 5.2.2) is also considered a severe 
error. 


5JJJ Format and Content of Diagnostic Messages 

Fbr certain syntactically incorrect constructs the diagnostic message consists of a pointer line and 
a text line. In odier cases a diagnostic message consists of a text line only. 

The pointer line contains a pointer (a carat symbol to the offending symbol or to an illegal 
character. 

The text line contains the following information: 

• The diagnostic message identification 

• The message code XY-Z where 
X is the message number 

Y is the severity code, a letter showing the severity of the error 

W: warning 
E: error 
S: severe error 
F: fatal error 

Z is an ineger which together with the message number X uniquely identifies the compiler 
location that generated the diagnostic message; Z is of importance mainly to the 
compiler mainterumce team *• it does not contain infonnation of interest to the compiler 
user. 

The message code (with the exception of the severity code) will be suppressed if the 
parameter SUPPRESS JERROR-NO in the configuration file has the value TRUE (see 
section 5.2.2). 


47 




DACS 680x0 Bare Ada Cross Compiler System * User’s Guide 
The Ada Compiler 


• The message text: the text may include one context dependem field that contains the name 
of the offtnding symbol: if the name of the offending symbol is longer than 16 characters 
only the first 16 characters are shown. 

Examides of diagnostic messages: 


*«* 

18W-3: 

*«* 

320E-2: 


535E-0: 

*** 

1508S-0 


Naming: Exception OQII8TltEXllT_niUXl will be raised here 
Name CBJ does not denote a type 
Expression in return statement missing 

Specification for this package body not present in the library 


5 J J Return Status 

The Ada Cbmpiler’s return value will have one of the following values: 

0: The compilation was successful, warnings may have been generated. 

1,2: Fatal imemal error in the nm-time system. Please contact DDC-I engineeis. 

3.4: Errors in command line options, ctunpiler generates an error message indicating the 
error. 

5: Fatal internal error in the compiler. CompOer generates an error message indicating the 

error. Please contact DDC-I engineers. 

6: Severe error during compilation, e.g. a unit mentioned by a WITH clause is not present 

in the library. Compiler generates an error message indicating the error. 

7: Error durir^ cmnpilation, e.g. most syntax errors. Compiler generates an error message 

indicating the error. 


5.4 The Program Library 

This sectimi briefly describes how the Ada compiler changes the program library. For a more 
general description of the program library the user is referred to Chapter 4. 

The cmnpiler is allowed to read fiom all sublibraries constituting the current program library, but 
mily the currem si:'dibrary may be changed. 


5.4J Correct Compilations 

In the following examples it is assumed that the ccmipilation units are correctly compiled, i.e. that 
no errors are detected by the compiler. 


48 






DACS 680x0 B«e Acfai Cross Corapilo’ System • User’s Guide 
The Ads Compiler 


CompUathMi of a Ittirary unit which is a dcdaratimi 

If a declaration unit of the snae name exists in the cunem sublibraiy. it is deleted together with 
its body unit wd possible subunits. A new declaration unit is inserted in the sublibrary, together 
with an empty body unit. 


Compilation of a Iflrrary unit which is a subprogram body 

A subfxogram body in a compilatimi unit is treated as a secondary unit if the current sublibrary 
contains a subprogram declaration or a genetic subfxogram declaration of the same name and this 
declaratkm unit is not invalid. In all oter cases it will be treated as a library unit, i.e.: 

« When Aete is tw library unit of that name. 

• When there is an invalid declaration unit of that name. 

• When there is a package declaration, generic package declaration, an instantiated package, 
or subprogram of that name. 


Compilation of a library unit which is an instantiation 

A possible existing declaration unit of that name in the current sublibtary is deleted together with 
its body unit and possibl<’s' bunits. A new declaration unit is inserted. 


Compilation of a secondary unit which is a litnwy unit body 

The existing body is deleted from the sublibtary together wiA its possible subunits. The new 
body unit is insetted. 


Conqrilation of a secondary unit which is a subunit 

If the subunit exists in the sublibrary it is deleted together wiA its possible subunits. The new 
subunit is insetted. 


5.4,2 Incorrect Compilations 

If the compiler detects an error in a compilation unit, the {Hogram library will remain unchanged. 

Note that if a file consists of several compilation units and an error is detected in any of these 
complation units, the program library will not be updated for any of the compilatitm units. 


5,5 Instantiation of Generic Units 

This section describes the order of compilation for generic units and describes situations in which 
an error will be generated during the instantiation of a generic unit. 


49 







DACS 680x0 Bale Ada Cross Compiler System - User’s Guide 
The Ada Compiler 


5 J.I Order of Compilation 

When instantiating a generic unit, it is required that the entire unit, including body and possible 
subunits, be compiled before the fitst instandatioa This is in accordance with the [DoD-83] 
Chapter 10.3 (1). 


5S2 Generic Formal Private Types 

This section (tescribes the treatment of a generic unit with a goteric formal private type, where 
there is some construa in the generic unit diat requires that the cotre^nding actual type must 
be constrained if it is an array type or a type with discriminants, and there exists instantiations 
with such an unconstrained t)^ (see (DoD-83] Section 12.3.2(4)). This is considered an illegal 
combinatiotL In some cases the error is detected when the instantiation is compiled, in other cases 
when a constraint-requiring construct of the generic unit is compiled: 

1) If the instantiation appears in a later comixlation unit than the first constraint-requiring construct 
of the generic unit, the error is associated with the instantiation which is rejected by the 
compiler. 

2) If the instantiation appears in the same cominladon unit as the first constraint-requiring 
construction of the genetic unit there ate two possibilities: 

a) If there is a constraint-requiting corrstrucdon of the generic unit after the instantiation, an 
error message af^ars with the instantiation. 

b) If the instantiation appears after all constraint-requiring constructs of the genetic unit in that 
compilation unit, an error message appears with the constraint-requiring construct but it will 
refer to the illegal instantiation. 

3) The instantiation appears in an earlier compilation unit than the fitst constraint-requiring 
crnistruction of the generic unit, which in that case will ag^car in the genetic body or a 
subunit If the instantiation has been accepted, the instantiation will corre^xmd to the generic 
declaration only, and not include the body. Nevertheless, if the generic unit and the instantiation 
are located in same sublibrary, then the compiler will consider it an error. An error message 
will be issued with the constraint-requiting construct and will refer to the illegal instantiation. 
The unit cotttaining the instantiation is not changed, however, and will not be marked as 
invalid. 


5.6 Uninitialized Variables 

Use of uninitialized variables is not flt^d by the compiler. The effect of a program that refers 
to the value of an uninitialized variable is undefined. A cross-reference listing may help to find 
uninitialized variables. 


50 




DACS 68 O 11 O Bate Ada Cioas Gompi^ Sytteai - lMer*s Guide 
The Ada Compiler 


5.7 Program Structure and Compilation Issues 

The ftdlowing limitations apply to the DACS-680x0 system: 

• Each source file can contain, at most, 32_767 lines of code. 

• The name of compilation units and identiflecs may not exceed the number of characters given 
in the INPUT-UNELENGTH parameter of the configuration file. 

• An integer literal may not exceed the range of INTEGER, a real literal may not exceed the 
range of LONG JPLOAT. 

• The number of formal parameters permitted in a procedure is limited to 64 per parameter 
spedficatimL There is no limit on the number of {Mocedure specifications. FOr example the 
dedatadon: 

procedure OVER-LIMIT (INTEGEROl, 

IMTEGER02, 

• • • • ^ 

INTEGER66: in INTEGER); 

exceeds the limit, but the procedure can be tK:com|dished with the following: 

procedure UNDER-LIMIT(INTEGEROl : in INTEGER; 

INTEGER02 : in INTEGER; 

• • • 

INTEGER66 : in INTEGER); 

The above limitations are diagnosed by the compiler. In practice these limitations are seldom 
restrictive and may easily be circumvented by using subunits, separate compilation, or creating new 
suUibraries. 


51 





52 






LINKER OPTIONS 


The linker options of this Ada implementation, as described in this 
Appendix, are provided by the customer. Unless specifically noted 
otherwise, references in this appendix are to linker dociimentation and 
not to this report. 


B-2 








APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada implementation, 
as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to 
compiler documentation and not to this report. 
Implementation-specific portions of the package STANDARD, which are 
not a part of Appendix F, are: 

package STANDARD is 

type SHORT_INTEGER is range -32_768 .. 32_767; 

type INTEGER is range -2_147_483_648 .. 2_147_483_647; 

type FLOAT is digits 6 

range -3.4028234666385E+38 .. 3.4028234666385E+38; 
type LONG_FLOAT is digits 15 

range -1.7976931348623157E-*-308 .. 1.7976931348623157E+308 ; 
type DURATION is delta 2#1.0#E-14 range -131__072.0 .. 131_071.0; 
end STANDARD; 


C-1 






6 THE ADA LINKER 


The DACS-680x0 linker must be executed to create a program executable in the target 
environmem. Linking is a two stage process that includes an Ada link using the infoimation in 
the Ada program library, and a target link to integrate the application code, run-time code, and 
any additional configuration code developed by the user. The lii^r peifonns these two suges with 
a single command, providing options for omtrolling both the Ada and target link processes. This 
chapter describes die link process, the t^ons to the DACS-680x0 linker, and the configuration 
of the linker. 


6.1 The Link Process 

The linking process can be viewed as two consecutive {diases that are automatically carried out 
when issuing the link command al. 

The link process is carried out in the following steps: 

• Determination of Ada compilation units to include in the target program. 

• Checking the validity of the included units according to the Ada rules. 

• Determination of an elaboration order for the target program. 

• Group units and tasks into classes (for security critical applications, see chapter 10). 

• Generation of an objea module to invoke the elaboration of the included Ada compilation 
units. This module is called the elaboration module. 

• Determination of attributes of the program being linked (see section 6.7). 

• Generation of an irutialization module. 

• Generation of option file(s) to the target linker. 

• Invocation of the target linker. 

The tasks of the first three steps are described in chapter 10 of the [DoD-83], the last five steps 
are described in detail in the following sections. 

6.2 The Invocation Command 

Enter the following command to the SunOS shell to invoke the linker 
$ al {<option>} <unitname> 
where the options and parameters are: 


53 








DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


OPTION 

DESCRIPTION REFERENCE 

•[nolboot 

Generate boot module. 

6.2.1 

-[no]class-flle 

Qass file name. 

6.2.2 

•qw 

Select Taijet board CPU. 

6.2.3 

•(noldcbiig 

Generate debug information. 

6.2.4 

•defaults 

Save options as new linker defaults. 

6.25 

•(noloitry 

Altetiutive program start label. 

6.2.6 

•(nolexcqitions 

Control of exception management 

6.2.7 

•{no]executable 

Name of executable file. 

6.2.8 

•(nojfkNi 

Control of which floating point processor is used. 

6.2.9 

•[nojlwap 

Control of memory management 

6.2.10 

•[nojinitJile 

Initialization file name. 

6.2.11 

•interrupt-stack 

Interrupt stack description. 

6.2.12 

•[nolitcb 

Number of Interrupt Task Control Blocks allocated. 

6.2.13 

•[nojkeep 

Do rut delete temporary files. 

6.2.14 

•Ubrary 

The library used in the link. 

6.2.15 

-[nollog-file 

Log file name. 

6.2.16 

•[nojlogical-meinory 

Logical memory specification. 

6.2.17 

•mate-task 

Main task specification. 

6.2.18 

•[no]map 

Keq) linker map file. 

6.2.19 

•mimi-details 

Setup values for MMU legisteis. 

6.2.20 

•mode 

Execution mode. 

6.2.21 

•[no]option-flle 

Linker option file name. 

6.2.22 

•ram 

Physical RAM memory specification. 

6.2.23 

•ram-base 

Base address for RAM sections. 

6.2.24 

•ram-sections 

Description of RAM memory sections. 

6.2.25 

•[no]rom 

Physical ROM memory specification 

6.2.26 

•[nojrom-base 

Base address for ROM sections. 

6.2.27 

•[nojrom-sections 

Description of ROM memory sections. 

6.2.28 

-rts-stack-use 

Amount of memory used by RTS. 

6.2.29 

•[nolscod 

Supervisor code sections. 

6.2.30 

•[nojsdat 

Supervisor data sections. 

6.2.31 

•{nojstatistics 

Print statistics. 

6.2.32 

•[nojtarget-options 

Options to the target linker. 

6.2.33 

•task-defaults 

Default values for tasks. 

6.2.34 

•[no]tcb 

Number of Task Control Blocks allocated. 

6.2.35 

•ucc-llbrary 

UCC library name. 

6.2.36 

•[nolucod 

User code sections. 

6.2.37 

•[nojucst 

User constant sections. 

6.2.38 

•[nojudat 

User data sections. 

6.2.39 

•[no]usr-llbrary 

A user supplied objea library. 

6.2.40 

•[nojvector 

Interrupt vector description. 

6.2.41 

•Inolveriiy 

Prim information about the link. 

6.2.42 

•[no]wamlngs 

Prim warnings. 

6.2.43 

<uiiit^name> 

Name of the main unit 

6.2.44 


54 














DACS 680x0 Bare Ada Cross Compiler System - User's Guide 

The Ada Linker 


All options and option keywords may be abbreviated (characters omitted from the right) as 
long as no ambiguity arises. Casing is significant for options but not for option keywords. 

For all option values specifying a 32-bit address, 2-complemem wrap-around is performed on 
negative numbers, e.g. -rom_base=:-l is equivalent to -rom-basesOxffffffff. 


6JL1 ‘[nolboot 


•boot 

•noboot (default) 

If -boot is specified an absolute file suited to gain control upon a reset is generated. The first two 
longwords in the RTS-CODE section contain the start Program Counter and the interrupt stack 
address. If -noboot is specified the absolute file does not contain the reset information, -boot is 
not valid when option Alebug is specified, see section 6.2.4. 


6J,2 -[noldass-file 

•class-file <flle-naine> 

-nodass-file (default) 

Spedfies the name of the file containing the class specifications. The syntax of class specifications 
is described in chapter 10, where the concepts of classes are described as well. This option is 
only legal if option -mode is set to SECURE or SAFE. 


6,2J -cpu 

-cpu 68020 I 68030 | 68040 
•cpu <highest licens^ (default) 

Spedfies the Motorola Central Processing Unit (CPU) tm the target board. The -cpu option must 
match the actual CPU on the target board, as this option directs the Ada Linkers selection of RTS 
and supporting libraries. This option defaults to the highest CPU for which the DACS-680x0 has 
been licensed, with 68020 being the lowest and 68040 being the highest 


6J.4 •[noldebug 
-debug 

-nottebug (default) 

The -debug option spedfies that debug information is generated. The debug information is required 
to enable symbolic debugging. If -nodebug is spedfied, the Ada linker will ^p the generation 
of debug information, thus saving link time, and will not insert the debug information into the 
chosen sublibrary, thus saving disk space. Note that any unit which should be symbolically 
debugged with the DDC-1 Ada Symbolic Cross Debugger must also be compiled with the -debug 


55 







DACS 680x0 Bare Ada Croas Compiler System • User’s Guide 

The Ada Linker 


(^Nion. See Section 3.1 J. -debug is not valid, when opdmu -boot or -vector INIT are specified, 
see sectimis 6.2.1 and 6.2.41. 


6J,S -deCiutts 
•defaults 

Saves the cunent setting of all options and param^eis, except the -dcCiults option itself, as new 
defnihs for the linker. The defnilts are sav^ in the file specified by the environmental variable 
AOAJLINK-DEFAIJLTS. When this option is present, no actual linking will take place. For a 
complete description of the Ada Linker defaults system, {dease refer to section 6.3. 


6J2j6 -[nolentry 

•oitry <string> 

•noentry 

-entry "Ada-ELABSEntry" (default) 


The -entry option specifies the entry name of the program. If -entry is not specified the entry 
point is the start of the elaboration module. 


6,2.7 -[nolexceptions 

•exceptions (default) 

-noexceptions 

If -exceptions is specified the exception management routines are included in the target program. 
If -noexceptions is specified, the exception managemem routines are not included in the program, 
and the program will abort if the program raises any exceptions. If -noexceptions is specified 
and the target program has the exception attribute (see section 6.7) a warning is reported, and the 
exception management routines will not be itKlud^. 


-[nolexecutaUe 

•executable <(lle-name> 

-noexecutaUe 

•executable <inain-unit>jc (default) 

The -executable option qrecifies the file name of the absolute file created. <flle-iMnie> is used 
as name for the absolute file. If -noexecutable is specified die absolute file is trot created. 


56 







OACS 6ilM> Bm Ada Ormi Ooo^fier Syiieiii • User’s Gride 

The Ada Ltaker 


dJJ •{noWj^ 

•fkm iSttl I d8882 
•mrilNi 

•fkm 68882 (definilt) 


Spedfies the floating poim ooixocessor avstlabie on the taiget system. If <pu 68840 has been 
specified, 4^ 68881 is not allowed, as the MC68040 FPU emulates the MC68882 coprocessor 
and not the MG68881 c o proce s sor. If is specified and the target program contains any 
fioating point instructions sn emw message is issued. See section 6.7 concerning the float attribute. 
If aD compilation imits required ffx execution are compiled with -nofjpu option no floating point 
instructions are gerrertted and a link with -noI{» will never fail. 


6 J.10 -[nojhcap 

-heap (default) 

•noheap 

If -heap is qrecified and the target program has the heap attribute (see section 6.7) then the 
storage management routines are included in the target program. If -nohcap is specified the 
storage managemem rmitines are not included in the program. When -nohcap is specified and 
the target program has the heap attribute, an error is reponed and linking tenninates. 


6J.11 -[noliniUJIle 

•init-flle <fUe-nanie> 

•nolnit_flle (default) 

The -init-file option specifies the name of a user supplied initialization file. <fHe-nanie> is used 
as name for the initialization file. If -noinit-filc is specified, the linker gerrerates an initialization 
file with the name <prcfix> Jnitsrc. It is assumed that the initialization file is an assembler 
source file. 


6 J.12 -intcrrupt-jtack 

-interrupt-stack [NOSTART | STARTs<addrc8S>l[^ZE=<nuniber>] 

•interrupt-jtack NOSTART^ZEslQ240 (default) 

Specifies the creation of the inienupt stadc. If STARTs<addrcss> is specified the iruernipt stack 
pointer is initialized to <addrcss>. If NOSTART is specified the liriker allocates the intenupt 
stack in the section RTS-DATA. STARTs<address> is not valid ^iriien -mode is set to SECURE 
or SAFE. If SIZEa<nunil>cr> is specified the <nunriwr> bytes is allocated finr the interrupt stack. 


57 





DACS 680x0 Bate Ada Cfoas Conpiler System - User’s Guide 

The Ada Li^r 


6^13 -(nolhcb 


•ttdt <nuiiibcr> 
•Boitcb 

•ttcb 5 (default) 


The •itch opckm specifies the number of intemtpt contiol blocks to ^locate. If 'itch <niniibcr> 
is specified then <niinibcr> of imem^t coosiol Mocks ut allocaied. where <iiuiBber> must be 
in the range 1. J2767. If -nottcb is specified and the target progiam has the intenupt attribute (see 
section 6.7) then an error is iqxxied and the absolute file is not created. If the target program 
does not have the intenupt attribute the 4106 option is ignored. 


6.2.14 -[nolkeep 


•keep 

•nokecp (default) 

If •keep is specified temporary linker files are not deleted, otherwise they are deleted. See also 
section 6.5 about temporary linker files. 


6.2^5 4ibrary 

•Hbrary <file*name> 

•Ubrary $ADA_UBRARY (default) 

The 4ibrary option specifies the cunem sublibraiy. from which the linking of the main unit will 
take (dace. If ^s opticm is not specified, the sutdibrary specified by the environmental variable 
ADA_LIBRARY is used. 


6JL16 '[nollog-file 

•log-file <flle^naine> 

•iiMk>g-filc (deftailt) 

Specifies that linker infonnation shall be written to a file named <flle>naine>. The log file will 
contain all verification infonnation specified by the •verify option and all statistics q)ecified with 
the •statistics option, idus warnings and errors messages, a listing of the class file (see section 
6.2.2), an expanded list of the class file ^jedficadons, a detailed description of each omipilatioa 
unit included in the program, and a link summary. 


58 






DAC3 6IQrO Bue Ada On« CbBqdkif System • User’s Oidde 

The Ada U^r 





•logkal.meiiiory <8tart-JMkh->,<cnd-jddr>{,<start-JMidr>,<end-addr>} 
•noloi^cal-iiieiiiory (de&ult in BA SIC mode) 

4og|kal-mainory OxKMKMMMMh^ffinr (defoilt in SECURE and SAFE RKKte) 

The •logicaLjiieniory specifies the logical memofy areas available for task stacks and task heaps 
in the peogism. - l og ka l- in anio r y is only l^ai when option -mode is set m SECURE or SAFIL 
The k^ical memoiy must be dUfjoint frm the physical memory (see section 6.2J23). 


dJJS -main-task 

•-mato-tadt [PR10RITYx<nuinbcr>l 

[^OHME-SUCE I ,TIME-SUCEs<rcal>] 

[^OFLOAT i ,FLOAT] 

(J40STACK-START | 3TACK.START=:<address>] 
(;STACK-SIZEs<number>] 

[41EAP-SIZEs<numbcr>] 

-main-task PRIORITYsl2^OTIME-SUCEJi1.0ATJ40STACK-START,\ 
STACK-SIZEs 102404IEAP-SIZE=10240 (default) 

The -main-task option specifies priority, time slice, use of floating point co-(»Dcessor, stack 
Stan, stack size and heap size for the main task. If PR10RlTY3<number> is specified and the 
pragma PRIORITY has not been applied then the main task has the priority <number> which 
most be in the range \.2A, otherwise it has the priority specified in the pragma. If the 
TIME-SLICEs<rcai> is specified then the main task has tlw time slice <real> (<reai> must be 
in the form <numbcr>.<numbcr>). If NOTIME-SLICE is specified the main program does not 
have a time slice. If FLOAT is specified the main program may use the floating poiitt 
co-processor. The state of the co-processor will not be saved as pan of the main task context If 
NOFLOAT is specified the main program must NOT use the floating poim co-processor. If 
STACK-START3<addr«ss> is specified the main stack pointer is initialized to <addrcss>. If 
NOSTACK-START is specified tlM linker allocates the stack for the main program in the section 
RTS-DATA, and initializes the stack pointer. STACK-START=<address> is not valid when 
•mode is set to SECURE or SAFE. If STACK-SIZE=<nutnbcr> is specified then <number> 
of bytes is allocated for the main program stack. If llEAP-SIZE3<number> is specified then 
<number> of bytes is allocated for the main program heap. 


6J2J9 -[twlmap 


•map 

•nomap (default) 

-map directs the linker to keep the map file. The map file contains information about memory 
layout of the program. The name of the map file is <main-unit-tume>jiwp. Please refer to 
[Nficroiec-a] for a description of the map file. 


59 








DACS 680rO Bare Ada Ciots Craipikr Sysrem • User’s Guide 

The Ada Linker 


6JL20 •{Mlmiiiu-dctails 

-mmu-defaUs (TIAa<iiumbcr>H»NOTIB | ,TIBs<auiiibcr>] 

[,NOI1C I ,TlC3<niinbcr>U,NOTn> | ,TlD=<nuinbcr>] 
[,PAGE.iilZEs<iiiniilMr>](;SCGMENT-SIZEs<nuiiibcr>] 

•iioiiimu_ddaib (defiuilt in 3ASIC mode) 

•mmu-detaib TlAs7,TIB«7,TICa6/<OTID^AGE_SIZEsl2^EGMENT_SIZEs2S 
(debult in SECURE and SAFE mode) 

Specifies vdues fi>r the MMU Translation Contnd Registers, -mmu ..details is only legal ^t^ien 
•nnde is sec to SECURE or SAFE, -nommu-details is only legal when MODE is set to BASIC. 
The paiametm’ values are all number of bits. TIA to TID specifies the number of bits to use on 
MMU table level A to D. PAGE-SIZE specifies the number of bits used for each page accessed 
by a page descriptor entry in the MMU tifoles. SEGMENT-SIZE specifies the number of bits 
u^ for a s^ment of the logical memoiy assigned to each task group. The segment of a task 
groiq> contains the task group heap mi stacks of all taska of the task group. Please refer to 
[MOTTOROLA-a] and [h^TOR(X^-b] for a detailed description of the MMU and its rasters. 

A munber of constraincs appty to the keywords of the optkm: 

• If •qiu 68030 is qiedfied. the foUowit^ values are valid for the keywords of the 
•nunu-details option: HA, HB, TIC and HD must be in the range 2..15; NOHB, 
NOHC and N(HTD can also be used. PAGE-SIZE must be in the range 8..1S for page 
sizes between 256 bytes and 32K bytes. SEGMENT-SIZE must be in the range 9..30 for 
a segment size between 512 bytes and 1 gigabyte. 

• If -epu 68040 is specified, the following values are valid for the keywords of the 
•nnnu-detaib option: HA and HB must be 7, HC must be 5 or 6, and NOHD must 
be used. NOHB and NOHC cannot be used. PAGE-SIZE must be 12 or 13 for a page 
^ of 4K bytes or 8K bytes. SEGMENT-SIZE must be 18 or 25 for a segment size of 
256K bytes or 32M bytes. 

• SEGMENT-SIZE must be equal to PAGE-SIZE -f HD or PAGE-SIZE + HD + HC 
or PAGE-SIZE + HD + HC + HB. 

• PAGE-SIZE must be equal to or greater than each of HA •«' 2, HB 2, HC + 2, and 
HD 2. 

• If NOHB is specified, both NOHC and NOHD must be specified as well, otherwise if 
NOHC is specified, NOHD must be specified as well. 

• The sum of HA. HB, HC, HD and PAGE-SIZE must be equal to 32. 

The defeolt value of •mmu-details in SECURE and SAFE mode defines a four level address 
translation taUe tree with each p^ having a size of 4 Kbytes and each logical segment having 
a size of 32 Mbytes. See section 10.5 for further descrifXion of how die values for •mmu-detalls 
is utilized. 


60 








DACS 6l6iB0 Ban Ada Cioa Goa^pfier Synem • User’s Guide 

Tlie Ada Unker 


CJJl Hoedc 


•asode BASIC | SECURE | SAFE 
•mode BASIC (defiuilt) 

^xdlles how the prognm shah execute. BASIC means that all code executes at supervisor 
pdvikfe levd ix. there is memofy proiectian of neither code nor data. SECURE mode nd SAFE 
mode means that code and data can be protected using the MMU and specified by use of the 
•dasB-IUe option. If •mode is set to SECURE or SAFE the •dass-flle qptkm must be specified 
as wdL In SECURE mode an ofetjects allocated by allocatois are allocated on the stack of the task 
executing the aUocator. wtaik in SAFE mode they are aUocaied on the het^ of the task executing 
the anocMor. SECURE and SAFE modes can only be selected when option -cpu is set to 68030 
or 68040. See chapter 10 fix a complete description of modes. 


6.2.22 •(no]iHitioa JfHc 

•optfoo-llle <flle-name> 

•nooption_flle (default) 

The •optkm.iile option specifies the name of the target link option file. <fne-naine> is used as 
the name fix the target link option file. If -nooption-file is specified the Ada linker generates 
an option file with the name <inain.ainitjnaine>.opt. 


6JL23 •ram 

•ram <start-addr>,<end-addr>{,<start-addr>,<aid-addr>} 

•ram OxO/hrfllffr (default) 

The •ram qrecifies the physical RAM memory availaUe for the executable program. 


6J.24 •ram-base 

•ram-base <address> 

•ram-base 0x10000 (default) 

The •ram-base option specifies the base address for the program fdaced in RAM memory. The 
program sections specified in t^on •ram-secthms are placed consecutively from the address 
spedfied witii this option. In SECURE and SAFE modes, tiie base address will always be page 
^gned. The address must be wittiin the physical RAM memory specified in option > 0110 . 


61 




DACS 680x0 Bare Ada Cross Ctmpiler System • User’s Guide 

The Ada Linker 


6.2JS •ram.aectioiis 

•nim_aectioii8 <aection_iMiiie>{,<acctkm-iuime>) 

.ram-sections SUPER.CODE^UPER-DATA,USER.CODE,\ 

USER-CONS,USER-OATA (default) 

The Mram.sections option specifies the sections to be placed in RAM memoiy. The sections are 

placed in Ae ^)ecified order from the address specified wiA option Hram-base. Valid section 
names are SUPER-CODE, SUPER-DATA, USER-CODE, USER-CONS and USER-DATA (see 
section 6.8). 


6.2J6 .[nolrom 

•rom <start-addr>,<emi-addr>{.<start-addr>,<cnd-addr>} 

Htorom (default) 

The ^rom specifies the physical ROM memory available for the executable program. 


6.2.27 .(no]rom-base 

HPom-base <address> 

•norom-base (default) 

The .rom-base option specifies the base address for the program placed in ROM memoiy. The 
program sections specified in option .rom-sections are placed consecutively from the address 
qiecified wiA this option. In SECURE and SAFE modes, the base address will always be page 
aligned by tiunctting the address wiA the number of bits specified in option >mmu-dctails 
keyword PAGE-SIZE, i.e. the base address will be the start of the page appointed by the 
specified address. The address must be within the physical ROM memory specified in r^on 
HTom. 


6JJ8 .[nolrom-aections 

.rom-sections <section-nanie>{,<section-name>} 

.norom-acctkms (default) 

The •Tom-sections option specifies the sections to be i^aced in ROM memoiy. The sections are 
placed in the specified order from the address specified wiA the .rom-base option. Valid section 
nunes are SUPER-COES, USER-CODE and USER-CONS (see section 6.8). By default no 
sections are placed in ROM. 


62 




DACS MW) Ban Alta Onn Oompitar Synem - Uaer'a Gakta 

The Ada Linker 




-rta jtack. uae 

-If f ««f*> <nunibcr> 

•rts.jtacli..un 0 (deWilt) 

• 

Specifies the amount oi extm stack space allocated in each task for the use of user supplied code 
in the RTS. If the Ada code imertaces to any externally si 4 )plied user code (e.g. by use of the 
•uar-ttbrary option) execudi^ in supervisor mode, «rts,.stack-use should be set to the amount 
of stack consumed by this external code. The Ada Lirdcer detennines how much RTS stack space 
it will need for foe RTS operations, and will automWcally allocate the minimum necessary RTS 
stack ^race. 


dJJO -[nolscod 


•scod <string>{,<string>} 
•nosood 

•scod RTS.-CODE (default) 


Specifies which luogram sections are to be placed in the supervisor code space, 'noscod indicates 
tlw no program sections should be placed in the supervisor code space. See section 6.8 about 
program sections. 


lUJl •(no]sdat 

•sdat <string>{,<string>} 

•nosdat 

•sdat RTSJDATA (defiiult) 

Specifies which program sections are to be placed in the s^rervisor data space, -nosdat indicates 
that no (»Dgram sections should be placed in the supervisor data space. See section 6.8 about 
program sectitxis. 


6JL32 •(nolstatistics 
•statistics 

•nostatistics (default) 

•statistics specifies that statistics foould be di^yed about the compilation units included in foe 
program and their dependencies, otherwise no statistics is displayed. If option -log-file is specified 
(see sectitm 6.2.16), foe statistics will be included im the log file as well. 


63 





DACS 680kO Bare Ada Cross Compiler Sysnem - User's Guide 

The Ada Linker 


6JL33 '[noltariet-options 

•target-options <string> 

•notarget-joptkNis (default) 

•target-options specifies additional options to the taiget linker. <string> will be added to the 
opti^ for the target linker when the Ada Linker invokes the target linker. FOr instance if 
•target-options "•f c" is qjedfied, •f c will be added to the target linker options, resulting (in 
this case) in the external symbol cross-reference table being included in the linker map file. If 
•notarget-options is specified no additional options, apart from the options determined by the 
Ada liifeer itself, will be added to the options for the target linker. 


6,134 -task-defeults 

•task-defaults [STACK-SIZE=<nuiiiber>][4*RIORlTY=<number>] 

(^OTIME-SUCE I ,TIME-SUCE=<real>] 

. -task-defeults STACK-SIZEsl024<U>RIORITYsl2^OTIME-SUCE (default) 

Specifies the default values to be used for task creation. The defaults specified will be used when 
creating tasks which do not contain pragma priority or the length clause specifying the stack size. 
If STACK-SIZE=<numbcr> is qrecified then <nuinber> of bytes is allocated for a task stack. 
If PRIORrrYs<numbcr> is specified then <numb«r> is used as the priority of the task. The 
specified priority must be in the range 1 to 24. If TIME-SLICEs<real> is specified then <real> 
specifies the number of seconds to use as the time slice for the task; <real> has the form 
<nuinber>.<numbcr>. If NOTIME-SLICE is specified the task does not have a time slice. If 
the target program does not have the tasking attribute (see section 6.7) the -task-defaults option 
is ignored. 


<L135 -[noltcb 


•tcb <number> 
•notch 

•tcb 10 (default) 


Specifies the number of task control blocks to be allocated. If -tcb 0 or -notch is specified and 
the target program has the tasking attribute the linker reports a error and no absolute file will be 
produced. This qption is ignored if the target (MX)gram does not have the task attribute (see section 
6.7). 


6JZ36 -ucc-Jibrary 

•ucc-library <filc-naine> 

•ucc Jibrary $AOA-UCC (default) 

The -ucc-library option specifies the name of the UCC library to include in the target program. 
If the UCC library is not specified the environmental variable ADA_UCC is used as file name. 


64 







DACS MONO Bare Ada Cioaa OonqjOer Synem • Uaer’s Ouide 

Tile Ada Linker 


dJJ7 •CnoJiMod 

•uood <itrin^{,<string>) 

•noucod 

•uood ADA.CODE (default) 

Specifies which progfam sections are to be (daced in the user code space. Htioucod indicates that 
no program sections should be {tiaced in die user code space. See section 6.8 about program 
sections. 


6JJ8 •[nolucst 


•ucst <string>{,<string>} 

•nouost 

•ucst ADA.CONS (default) 

Specifies which program sections are to be jtiaced in the user ccmstant space, •noucst indicates 
thu no program sections should be placed in the user constant space. See section 6.8 about 
program sections. 


6JJ9 •(noludat 

•udat <string>{y<string>} 

•noudat 

•udat AOA-DATA (default) 

Specifies which program sections are to be placed in the user data space, •noudat indicates that 
no program sections should be placed in the user dau space. See section 6.8 about program 
sections. 


62A0 •[nolusr Jibrary 

•usrJibrary <flle-juinie>,(<flle-naiiie>} 

•nousrJibiiu^ (default) 

When specified the objea files and objea libraries denoted by file-name is included in the link, 
otherwire no user library is included in the link. 


6J,4I •[nolvcctor 

•vector [NOADDRESS | ADDRESS-<addrcss>]{,COPY | 4NIT] 
•novector 

•vector NOADDRESS,COPY (default) 


65 





DACS 680x0 Bate Ada Cross Compiler System • User’s Guide 

The Ada Linker 


Specifies creation of the imemipt vector. If ADDRESS is specified the interrupt vector is placed 
at <address>. When NOADDRESS is specified, the interrupt vector will be pl^d in the seaion 
RTS-DATA. If COPY is specified the interrupt vector active when the program was invoked is 
copied. If INTT is specified the interrupt vector is initialized by the routine Ada.UCC-DSInitlV. 
•novector specifies that no initialization of the interrupt vector takes place. The program can 
hereby be invoked by an interrupt After program invocation the interrupt vector can potentially 
be modified. INIT is not valid when option -debug is specified, see section 6.2.4. 
ADDRESSs<address> is invalid when -mode is set to SECURE or SAFE. 


6J.42 -[nojverify 

•verify [ALL][,ELABORATION-ORDER](,COMMANDS](4*ARAMETERS] 

•noverify (default) 

Determines the type and amount of information generated. If ELABORATION.ORDER is 
specified the elaboration order is displayed, if COMMANDS is specified the commands executing 
the various subprocesses are displayed, if PARAMETERS is specified the active parameters and 
options are displayed, and if ALL is specified all of the above mentioned information is displayed. 
If option -log-file is specified (see section 6.2.16) the information wiU be included in the log 
file as well. 


6.2.43 -[nolwarnings 
•warnings 

•nowamings (default) 

Specifies whether warnings should be generated or not. Warnings are generated when conflicts 
between target program attributes and specified options are detected, and when a package does 
not have a body. 


6J.44 The Main Unit Parameter 
<unit-naine> 

The main unit must be a parameterless procedure and must be present in the library. The main 
unit name is a required parameter. 


6 J The Linker Defaults System 

As it can be seen from the description of options above, default values exist for all options. 
However, it is possible to change the initial setting of default values and even have several 
configurations of default values for the Ada Linker. The Ada Linker default values are controlled 
by use of the option -defaults and the environmental variable ADA_LINK_DEFAULTS. 


66 






DACS 6809(0 Bare Ada Cross Compiler System • User’s Guide 

The Ada Linker 


The Ada Linker obtains its option and parameter values in the following way: First, i^ons are 
initialized with the default values indicated in the above description of options. Second, new 
option and parameter defaults are loaded from the Ole indicated by the environmeittal variable 
^A_L1NK-DEFAULTS, if this points to an existing file. And third, options and parameters are 
given the value specified in the invocation command of the Ada Linker. 

When the option -defaults is specified, the current value of options and parameters are saved as 
new defaults in the file identified by the envirorunental variable ADA JLINK-DEFAULTS. Note 
that ADA-LINK-DEFAULTS is not defined as a environmental variaUe when the DACS-680x0 
is distributed by DDC-I, so an ex{riicit definition is necessary. 

Assume that the default value of -itch should be 25 instead of S, and that the new default settings 
should be saved in the file DEFAULTS.LINK. The following commands could be used: 

$ satanv ADA-LI1IK_DEFAULTS DEFAULTS. LINK 
$ ml -defaults -itcb 25 

These commands will create a new file called DEFAULTS.L1NK in the current directory (if it 
does not exist already) and save the new linker default values in this file. As long as 
ADA-LINK JDEFAULTS keeps its current value of DEFAULTS.L1NK, all linking performed in 
the current directory will have a -itch default value of 25. Note that one should noimally assign 
a fully eiqianded file name, like /home/ada-usersAisei2/work/DEFAULTSJ.lNK, to 
ADA-LINKJdEFAULTS to ensure that the correct default file will be found no matter in what 
directory the linking is performed. 

Several configurations of Ada Linker defaults is possible, simply by changing 
ADAJLINK-DEFAULTS to denote different linker default files depending on the desired 
configuration. By the same method, different users can have different linker default values, simply 
by having ADA-UNK-DEFAULTS denote different files. 

When option -defaults is specified no actual linking takes place; only the current value of the 
options and parameters are saved as new defaults. Before saving the new defaults, all options are 
checked to have a valid value without consideration of other options. If this is not the case, an 
error is reported and the new values ate not saved as defaults. However, no check on 
interdependence between the options are performed when specifying new default values, e.g. it is 
possible to set -mode SECURE as default value without specifyirtg a default value for -class-file. 
The interdependence between option values is checked only when an actual linking will be 
performed, i.e. when -defaults is not ^cified. 

To reset the Ada Linker Defaults to the faaory setting, simply use the command: 

$ sotonv ADA-LntK-DEFAULTS "" 

which will ensure that no linker defaults file will be read when the linker is invoked. If the file 
denoted by AOA_LlNK-DEFAULTS will not be used again, the file can be deleted. The current 
linker defaults setting can be viewed with the option -verify PARAMETERS, see section 6.2.42. 






DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 

The Ada Linker 


6.4 Environmental Variables Used by the Ada Linker 

When the Ada linker is executed, the following environmental variables are used: 


VARIABLE PURPOSE 


ADA-LIBRARY Ideittifies the defoult library used by all DACS tools. It is the lowest 

level suUibiary in the program library hierarchy. This defoult may 
be overridden by the •Ubrary option. 

ADA JLINK-IMEFAULTS Identifies the file containing the Ada Linker defaults. Defaults are 

saved in this file when the option -defaults is used. 

ADA-UCC Identifies the library containing the User Configurable Code, e.g. an 

UCC library supplied DDC-I. This default may be overridden by 
the -ucc-library option. 


6.5 File Names Used by the Linker 

During the link, the following temporary files are created in the currem default directory: 

<prefix>-iniLsrc 

<prefix>-iniLobj 

<prefix>-elab.src 

<prefix>-elab.obj 

<I»efix>-end.src 

<prefix>-end.obj 

<prefix>.opt 

<prefix>-<unit-no>.obj 

<main-unit-name>.opt 

<main-unit-name>.oom 

If the -keep (^<m is used <prefix> is the main unit name, otherwise <prefix> is the i»ocess 
idoitification (pid). 

If linking for SECURE or SAFE mode (see section 6.2.21), the main unit and each defined class 
will result in die generation of a target linker option file. 


6.6 Return Status 

After a lirddng the return value of the Ada Linker will reflect if the linking was successftilly 
comideted. The following return values are possilde: 


68 









r 


OACS 680x0 Btte Ada Cross Compiler System • User’s Ooide 

The Ada Linker 


0: The link was successful. Warnings may have been generated during the link process. 

1: An error occurred during the link prxscess, e.g. the Ada Linker is unable to find the UCC 
file. The Ada Linker will generate an error message stating the cause of the error. 

2: An interrud error has caused the Ada Linker to abort, please contaa DDC-1 engineers. 


6.7 Program Attributes 

The linker evaluates the following attributes of the target program: 

• Taddng constructs 

The target program has the task attribute when Ada tasking constructs are used. 

• Floating point constmcts 

The target program has the float attribute when the program uses the floating point 
co-processor. The target program will only use the co-processor instructions to implement 
options on floating poim types. 

• Iruerrupts, entries or procedures 

The target program has the interrupt rutribute when the program contains address clauses 
for task entries or the PRAGMA INTERRUFT_HANDLER. 

• Exception handlers 

The target program has the exception attribute if the program contains any exception 
handlers. 

• Het^ 

The target program has the heap attribute when the program contains allocations or 
deallocations on the heap. 

• Secure execution 

The target program has the secure attribute if the program is compiled with option -mode 
set to SECURE or SAFE. In this case the MC68030/MC68040 on-chip Memory 
Management Unit is used to protect code and data segments and for controlling storage 
checks. 

The linker uses the attributes to generate the initialization module, to issue warnings if a 
combination of options is in conflict with the attrilnites of the target program, and to determine 
the i»oper RTS to include in the target link. 

If a program ctxitains interface calls interfacing to code which requites tasking, uses floating point 
instructions or storage management, the Ada compilation unit must contain a pragma to set the 
appropriate attribute. Please refer to Chapter 12 for details. 


69 






DACS 680x0 Bare Ada Cioas Cbmpikr Sysieni - User’s Guide 

The Ada Lifiker 


6J Profram Scctfams 


The oompiler uses the following progiam sections: 


Section 

Contents 

RTS-CODE 

RTSJIATA 

ADA-CODE 

ADA-COMS 

ADA-DATA 

Run-Time System code 

Run-Time System data 

Compiler generated code 

Cos^iler generated constants 
Compiler generated data 


TaUe 6.1: Program sections 

The program sectimis RTSJDATA and ADA-OATA must be in RAM memory. The program 
sectkms RTS-COOE, ADA-CODE, and AOA.CONS are not modified by the execution of the 
program and may be fdaced in ROM. All sections must be placed in either RAM or ROM 
memoiy. 

The linker groups the program sections into 5 new sections: SUPER-CODE, USER-CODE, 
USER-CONS, SUPERJDATA and USER-DATA. COI% and CONS sectimis can be stored in 
R OM i f desired. DATA sections must be placed in RAM. In SECURE and SAFE mode the 
SUPER and USER sections can be accessed when executing at supervisor privilege level, while 
only USER sectiwis can be accessed when exoniting at user privilege level (i^ease refer to 
[MOTOROLA'S] and [MOTOROLA*b] about supervisor and user privilege level). In BASIC mode 
the SUPER and USER sections can be accessed both when executing at supervisor privilege level 
and when executing at user privilege level. 

When including user defined sections e.g. modules written in assembler, each of the compilers 
program sections and the user defined sections must be qrecified to the linker as one of the RTS 
progiam sections using the options 'Udat, 'Sdat, •nest, 'ucod and osood. 


6.9 The Initialization Moduie 

Tlie initializatitm module defines constants, allocates memory, and contains the code for 
initialization of the processor and the RTS. The initialization module for a given target program 
depends on the program attributes and the optitms given to the linker. The initialization module 
is generated as an assembler file with the name <prefix>-init.src. The assembler is invoked to 
produce the object file with the name <preflx>-init.obj. If the •keep option is used <prefix> is 
die main unit name, otherwise <prefbo is the process identification (pid). 


6.9.1 The Initialization Constants 

The initializreion module defthe following externally visiUe symbols whidi are constants used 
by the ruiHime system. 

Ada-INIT$DisplaySize 

The size of the display vector in bytes. This symbol is always defined. 


70 



















DACS 6IOkO Ban Ada Omai Coapfler Syaon • Ukt*! Guide 

tlK Ada Lteker 


AdaJNITSIiilemiptStackSiae 

The size of the intemipt stack in bytes. This symbol is defined when the •intemipt..jtacfc option 
is specified. 

Ada-INIT$MainStackSizc 

The byte size of the stadt fcx the main task. This symbol is always defined. 
Ada-INirSMainHeapSize 

The byte size of the heap for the main task. This symbol is defined when option 'amde is 
specified to SECURE or SAFE. 

Ada-INlT$DefiiultTimeSlice 

The defuilt tune slice for tasks. The symbol defines an integer the unit is in SYSTEM.TICKS. 
The symbol is defined when the target pr ogram h as the task attribute. If the NOTIME_SLICE 
is spewed, the value of the symbd IS fotfflfffflfr. 

Ada-INITSDcfiiultPriority 

The default priority for tasks. The symbol is defined when the target program has the task 
attribute. 

Ada-lNIT$MainPriority 

The priority for die main task. The symbol is defined when the target program has the task 
attribute. 

Ada-INIT$MainTiiiieSlice 

The time slice for the main program. Same omvaition as Ada-INTTSDefoultTinieSlice. 
Ada-INIT$DefiiultStaciiSize 

The stack size for tasks for whidi the 'STORAGE-SIZE is not applied. This symbol is only 
defined if the target program has the task attribute. 

Ada-INITSRTSSinckUae 

The amoum of memory reserved on the stack of eadi task to be used by the RTS. 
Ada-INIT$MainFPUae 

Specifies whether tn not the main task may use the floating point co-processor or the 68040 FPU. 
Ada-INIT$TCBCoint 

The number of task control Uodcs allocated minus one. This symbol is only defined when the 
target program has the task attribute. 


71 








DACS 680x0 Bve Ada Cross Compiler System • User’s Guide 

The Ada Linker 


AdaJNlTSITCBCoiuit 

The number of inienupt task control bloda allocated minus one. Tlus symbol is only defined 
whoi the taiget program has the interrupt mtiibute. 

AdaJWITSSupcrStacliArcaSiae 

The sixe of the area to allocate supervisor stacks firom. which can be allocmed to tasks running 
on user privilege levd. This symbol is only defined when option -10060 is specified to SECURE 
or SAFE. 

Ada-INIT$SupcrStackCount 

The maximum number of supervisor stadcs minus one. which can be allocated to tasks running 
on supervisor privilege level. This symbol is only defined when option -iiiode is q)ecified to 
SECURE or SAFE. 

Ada-INlT$MainSuperStackSize 

The size of the supervisor stack allocated for the main task. This symbol is only defined when 
option -mode is specified to SECURE or SAFE. 

Ada-INIT$HcapHcaderCount 

The number of heap headers allocated minus one. A heap header contains a pointer to the heap 
and a heap semaphore (if the program contains tasking). This symbol is only defined when option 
•mode is ^Kdfied to SECURE or SAFE. 

Ada-lNIT$DcfaultHeapSize 

The size of the heap allocated for a task. This symbol is only defined when option •mode is 
specified to SECURE or SAFE. 

AdaJ[NIT$PageSize 

The logical/physical page size measured in number of bytes. This symbol is only defined when 
option -111060 is q)ecifi^ to SECURE or SAFE. 

Ada.lNIT$PageWidth 

The number of bits used as offset within a page, log 2 of page size. This symbol is only defined 
when option -mode is specified to SECURE or SAFE. 

Ada-INIT$LogSegmentWidth 

The number of bits used as offset within a segment. This symbol is only defined when option 
•mode is specified to SECURE or SAFE. 

Ada-IN1T$MMUTIA 

The Translation (jontrol Register’s Table Index A value. This symbol is only defined whoi qxion 
-mode is specified to SECURE or SAFE. 


72 










DAGS 68QfeO Bate Ada Cioaa GompOer System • User’s Guide 

Tlie Ada Linker 


AdaJNlT$MMUTIB 

The Translation Control Register’s Table Index B value. Ttus symbol is only defined when option 
•mode is specified to SECURE or SAFE. 

Ada-1NIT$MMUTIC 

The Translation Control Register’s Table Index C value. This symbol is only defined when option 
-mode is qtedfied to SECURE or SAFE. 

Ada.lNlT$MMUTID 

The Translation Control Register’s Table Index D value. This symbol is only defined when optitm 
•mode is specified to SECURE or SAFE. 

Ada-INIT$TLMMFrecCount 

The size of a table describing fiee logical memory within all active task groups. This symbol is 
(mly defined when option -mode is specified to SECURE or SAFE. 


63J2 Initialization Code 

The initialization module contains code for initialization of the RTS components included in the 
target program. The initialization steps are executed in tlK same sequence as they are listed. When 
the initialization code is called, the interrupt priority level (IPL) mask in MCtiSOxO Status Register 
is assumed to be 7 and the active stack is assumed tt) be the interrupt stack. 

Initialization of the Interrupt Stack 

The interrupt stack pointer is initialized. This initialization is only performed when the option 
•intcrruinJstacfc is specified. 

Initialization of the Main Stack 

The mode is changed to use the master stack pointer and the master stack pointer is initialized. 
This initialization is only performed if option -main^ask, keyword STACkIsIZE > 0. If option 
•mode is set to SECU^ or SAFE the supervisor main stack is initialized instead. 

Initialization of the Interrupt Vector 

The interrupt vector is either copied from the intenupt vector defined by the VBR register, or 
initialized comidetely, dqiending rni the -vector option. If the -novector option is specified the 
interrupt vector is not initialized. 

Initialization of the Virtual Mermry Manager 

If option -mode is set to SECURE or SAFE the Virtual Memory Manager is initialized. The • 
VMM initialization generates internal data structures concerning free physical RAM memory 
specified by option -ram and free logical memory specified by option -logical-nwnwry. 
Furthermore, MMU tables are created for supervisor code mapping all code as read only, user 


73 




DACS 680x0 Bwb Ada Cross Compiler System - User’s Guide 

The Ada Linker 


code mapping Ada code as read only, and supervisor data mapping all physical RAM memory as 
specified wift option •ram as read/^te. 

Iitittelixatkm of Classes 

Initializaticm of classes is performed if option •mode is set to SECURE or SAFE. For each class 
a user daa memory mtgtping table is generated. The table contains constants, stack, heap and 
peimanem data for the class itself and data from other classes according to the tights defined in 
the class file in specified with option •dass-flle. 

Ibiltialiaition of the 680x0 Interrupt Vector Eirtiies 

The interrupt vector entries for the 680x0 exceptions that are used by the RTS are initialized by 
calling Ada-UCCJE$InitMPUIV (see the Configuration Guide [DDC-b] for more details). This 
initiali^mi is only performed if •noexceptions has not been specified arid the target program has 
the exception handler attribute. 

Initlaliation of 6888x Interrupt Vector Entries 

The interrupt vector entries for the 6888x or 68040 FPU exceptions that are used by the RTS are 
initialized by calling Ada-UCC-F$InitFPUIV (see the Configuration Guide [DDC-b] for more 
details). This initializtsion is only performed if •noexceptions has not been specified, and the 
program has the float and exception handler attributes. 

Initialization of the Storage Manager 

The parameter list defining the memory available to the storage manager is created and the storage 
manager is initialized. The storage manager is only initialized when the target program has the 
he^ attribute. 

Initialization of Exception Handler 
Initializatitm for pre-handlers is performed. 

Initialization of the Hmer 

If the target program has the task attribute, the timer is initialized by calling 
Ada_UCC-A$InilT!mer (see the Configuration Guide [DDC-b] for more details). The timer may 
also be initialized when the pack^ Calendar is itKluded in the program, but that depends on the 
imfdementation of package Calendar. The implementation sui^lied by DDC-I will use the timer. 

User Specified Initialization Code 

At this point, user specified initialization code is called. Please refer to Section 6.2.11 for details 
on user specified initialization code. 

Initialization of Frame Heap 

The permanent frame herq) headers on the outermost tevel are initialized. A frame heap header is 
a structure of heap elements at current Uock level. 

Initialization of the Main Program 


74 





1 


DACS ttOiO Bare Ada Great GompOer Synem • User’s Guide 

Tte Ada Linker 


Hk initialization of ttw main prognm allocmes and initiaUzes the display ector and initializes 
the fiaiiie pointer and the display pointer (A6. A5). 

Initialization of the Tasking Kernel 

If the taiget program has the task or the intemqx attribute, the tasking kernel is initialized. The 
initializadon of the tasking kernel creates the main task. The initializmion of the tasking kernel 
wm also diange the IPL to 0. If the program have nekher of the mentioned attributes, the tasking 
kernel is not initialized, but the IPL is changed to 0. 

Invocation of the Elaboration Module 

The daboradon module is invoked and will execute the target program. The elaboration module 
is invoked by a branch and will return by a branch or a trap if linked in SECURE or SAFE 
mode. 

Termination of the Main Task 

Upon return fiom the elaboradon module, the main program must wait until all tasks have 
terminated. If the target program has the task attribute, the routine in the tasking kernel terminating 
the main program is called. If not, the only task (the main task) is already terminated and no 
action is required. 

Preparation fbr Terminadon of the Program 

To ensure proper termination the IPL is raised to 7, the Master Stack will be the active stack 
afterwards. 

Invocation of User Defined Termination Code 

Transfers control to the user supplied terminadon routine Ada-U(X-B$Exit (see [DDC-b]). nease 
refer to Section F.1.4 for details on user specified terminadon code (PRAGMA RUNDOWN). 


6.9 J Inidalizadon 

The initialize module allocates memory for the RTS data structures that depends on the target 
program or on options to the linker. The following data areas are defined, and made addressable 
by the symbols: 

Ada-JNITSInterruptVcctor 

The address of the interrupt vector. This symbol is defined when the option -vector is specified. 
If ADDRESS3<addrcss> is specified an absolute section is created at <address>, the symbol is 
equated to <address>, and 1024 bytes is allocated for the interrupt vector. If -iwvector is specified 
the symbtd is not defined and the memory not allocated. 

Ada-INIT$IntaTuptStack 

The start address of the interrupt stack. This symbol is defined when the option -interrupt-stack 
is specified. If STARTs<address> is specified an absolute section is created at <address>, the 


75 








DACS 680x0 Bare Ada Cross Oxnpiler System - User’s Guide 

The Ada Linker 


symbol is equated to <addrcss> and the number of bytes specified with SIZE are reserved. 
Otherwise the interrupt stack is allocated in the RTS-DATA section by a DS directive. 

Ada-INlT$MainStack 

The start address of the main program ^ck. The symbol is defined when the option •main-task 
is qrecified. If STARTs<address> is q)ecified then the symbol is equated to <address> otherwise 
die main stack is allocated in the RTS-DATA secdon a DS directive. 

AdaJmrrSMainDlapUy 

A pointer to the main display when the program has no tasking. The memory is only allocated 
whm the target program has the task attribute. 

Ada-INIT$TCBAddress 

The start address of the memory allocated for the task control Modes. The memory is allocated 
when the target program has the task attribute. 

Ada-lNIT$ITCBAddrcss 

The start address of the memory allocated for intenupt task control blocks. The memory is 
allocated when the target program has the intenu|X attribute. 

Ada-INIT$CurrITCB<interrupt*no> 

One long word is allocated for each interrupt vector entry that the target program references. 
Ada-lNIT$SuperStackArea 

The start address of the area from which supervisor stacks are allocated. Only supervisor stacks 
for tasks at user privilege level are allocated in this area. The memory is only allocated when the 
option •mode is set to SECURE or SAFE. 

Ada-lNlT$TempHeap 

The address of the memory for Frame heap header for allocation of temporary objects on the 
outermost lexical levd. 

Ada-INITSHeapIIeaderArea 

The start address of the memory allocated for heap headers. The memory is only allocated when 
the q)ti(m •mode is set to SECURE or SAFE. 

Ada-INIT$FdTable 

The start address of the memory allocated for the Function Code Lookup table used by the MMU. 
The address must be 16 bytes aligned. The memory is only allocated when the option •mode is 
set to SECURE or SAFE. 

Ada_INlT$FreePageCount 


76 






- .j.a?*>y,'.' w .1 


DACS 68QrO Bare Ada Cnre Compiler System • User’s Guide 

The Ada Linker 


The address of the memory allocated for the number of free physical pages. The memory is only 
allocated when the option •mode is set to SECURE or SAFE. 

AdaJNITSFrccPageUst 

The address of a pointer, addressing the list describing the free physical pages for each task group 
(see chqjter 10). The memory is only allocated when the q)tion •mode is set to SECURE or 
SAFE. 

Ada-INIT$FreePageIndex 

The address of the memory pointing at the next free physical monory area in 

Ada-INIT$FrcePageTable. The memory is only allocated when the option •nnode is set to 
SECURE or SAFE. 

Ada-INlTSFreePageTable 

The start address of the memory allocated for the table of physical RAM memory areas used 
initially. The contents of the table is derived from the option -ratiL The memory is only allocated 
when the option -mode is set to SECURE or SAFE. 

Ada-lNlTSFreeSegmentlndex 

The address of the memory pointing at the next entry with a free segment in 

Ada-lNIT$FreeSegmentTable. The memory is only allocated when the option 'inode is set to 
SECURE or SAFE. 

AdaJfNITSFreeSegmentTable 

The start address of the memory allocated for the table of free logical memory segments. The 
memory is only allocated when the option -mode is set to SECURE or SAFE. 

Ada-INITSFreeSegmentTop 

The address of the top of the free segment stack. Tire memory is only allocated when the option 
•mode is set to SECURE or SAFE. 

Ada.JNIT$FreeSegnientStack 

The start address of the memory allocated for the stack of deallocated segments. The memory is 
only allocated when the option •mode is set to SECURE or SAFE. 

Ada-INITSTLMMFi'eeArea 

The start address of the memory allocated for the table describing the ftee logical memory within 
all active task groups. The memory is only allocated when the option •mode is set to SECURE 
or SAFE. 


77 




DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 

The Ada Linker 


6.10 The Elaboration Module 

The elaboration module is generated as an assembly file, and the assembler is invoked to produce 
the actual object module. The assembly file is named <prefix>-elab.src and the object file name 
is <prcfix>_elab.obj. 

TIk elaboration module has the entry poiiu AdtuELABSEntiy. which is invoked from the 
initialization module by a branch. 


6.10.1 BASIC Execution Mode 

The elaboration module has the following structure, when ‘inode is set to BASIC: 

NAME AOA-ELAB 
CHIP <selected cpu> 

XDEF Ada^IAB$Entry 
XREF Ada.INITSElabExit 
XREF M$<inain_unit-no>-l 
XDEF R$<unit_no_l>_0 
XREF M$<unit_no_l>_0 
XDEF R$<unit-no-2>_0 
XREF M$<unit-no_2>_0 


SECTION ADA-CODE 

Ada-ELAB$Entry: bra.l M$<unit-no-l>-0 

RS<unit_no_l>_0: bra.l M$<unit_no_2>_0 

RS<unit_no_2>_0: ... 

bsr.l M$<main_unit_no>_l 

moveq.l #0,d0 

bra.l Ada-INITSElabExit 

END 


The elaboration module branches to the elaboration for each of the included compilation units, and 
the elaboration code will branch back to the eltdwration module. The elaboratitm code for a 
compilation unit will be identified by the label M$<iinit-no>-0 where <unit-iio> is the unit 
number of the compilation unit. The return point is identified by the label R$<unit-no>-0. 


6.10.2 SECURE and SAFE Execution Mode 

When linking with option ‘inode set to SECURE or SAFE, the elaboration module has the 
following structure: 


78 





DACS 680k 0 Bare Ada Cross Compiler Sysmn • User’s Guide 

The Ada Linker 


NAME ADA_ELAB 
CHIP <selected cpu> 

XDEF Ada-ELAB$Entry 
XREF Ada.INIT$ElabExit 
XREF M$<inain-unit-.no>-l 
XREF Ada-TK-X$Elaborate 
XREF Ada-TK-X$CallMain 
XREF Ada_lNZT$MainClass 
XREF N$<clasa-nane-l> 
XREF N$<cla3a-naiDe-2> 


XDEF R$<iinit_no_l>-0 
XREF M$<unit_no_l>_0 
XDEF RS<unit_no_2>-0 
XREF M$<unit-no-2>-0 


Ada_ELAB$Entry: 


SECTION ADA-CODE 

lea.l N$<class-naine>, aO 
lea.l M$<unit_no>-l/al 
bar.1 Ada_TK_X$Elaborate 
• • « 

lea.l N$<class-naine>, aO 
lea.l M$<unit_no>-l,al 
bsr.l Ada_TK_X$Elaborate 


lea.l N$<class-naine>, aO 
lea. 1 M$<inain-unit-no>-l 
moveq.l #0,d0 
bsr.l AdaTK-X$CallMain 
lea.l Ada-INIT$ElabExit,aO 
nusveq.l #0,d0 
moveq.l #l,d7 
trap #13 


R$<unit_no_l>_0: 
R$<unit_no_2>_0: 


R$<unit_no_<u»_0: moveq.l #0,d7 

trap #13 
END 

The elaboration of eadt compflation unit is handled by Ada-TK-X$Elaborate which takes a class 
name and an elaboration code label M$<unU-no>-0. The return point is identified by the label 
R$<unit-iH»-.0. The elaboration of each compilation unit nms at user privilege level, but the 
setup for the elaboration of each compilation unit must run at supervisor privilege level. To switch 
from user privilege level to supervisor privilege level a trap operation is executed, and the 
elaboration of the next unit will proceed. 


79 







DACS 680x0 Bare Ada Gross Cmnpiler System • User’s Guide 

The Ada Linker 


6.10J Execution of the Main Program 

When all the comf^don units have been elaborated the main program is called. The main 
program is identified by the label M$<main-unit-no>-l. If the main program returns, register 
dO is cleared to signal successful completion, and control is passed back to the initialization 
module. 

Please note that all transfers of control between the initialization module, the elaboration module, 
and the elaboration code is imi^emented by branch instnictions. The branch instractions are used 
because the elaboratitm code may allocate objects m the stack, and consequently stack balance 
cannot be assumed. 


6.11 Linker Examples 

This section contains a number of linker examples. It is assumed that the compilation unit example 
is compiled into the default program suUibrary. that the environmental vaiiaUe ADAJLIBRARY 
has bem equated to the default sublibrary and that the environmental variable ADA_UCC has 
been equated to an User Configurable Code Library suitable for the target board on which the 
linked program will be executed. DDC-I provides UCC libraries for the Radstone CPU*3A and the 
Motorola MVME133. MVME143 and MVME16S boards. 


Example: 1 

$ al -noheap example 

The program will start at address 0x10000, and the heap is not initialized. If the target program 
has the heap attribute an error message is issued. 


Example: 2 

$ al -ram 0x10000,Oxfffff example 

The program will start at address 0x10000, and the heap will be placed within the address range 
0x10000 to OxffffT. This is the simplest form of a link that will support all Ada constructs. 


Example: 3 

$ al -ram_base 0x4000 -ram 0x0,0x£ff£f example 

The program will start at address 0x4000, and the heap will be placed within the address range 
0x4000 to OxffffT. Physical memory below address 0x4000 is not used. 


80 



DACS 680x0 Bate Aite Cioa GomiiOtf Syttem • User’s Guide 

The Ada Linker 


Example: 4 

$ al -roa-aactions SUPBXL.COOB,USBIL.CODE,USBR-COOB\ 
-raauaactiona SUPBR-OATX, OSER-DXTX\ 

-roa 0x200000,0x2fffff -r^aJbaaa 0x200000\ 

-raa 0x0,0xffff£ -rauLJbaaa 0x0 axaa^la 

The sections SUPER-CODE, USER-CODE and USER-CONS are placed in ROM liom address 
0x200000. The sections SUPER-DATA and USER-DATA are placed in RAM fiom address 
0x0. The part of the address range 0x0 to OxfOfT not used by the SUPER-DATA section is used 
as heq> space. 


Example: 5 

$ al -roa-aaetions SUPBR-CODE -rom-basa 0x200000\ 
-raa-aactions SUPER-DATA -raa-baaa 0x0 \ 

-acod RTS-CODE,ADA-CODE,ADA-COMS\ 

-noucod -noucat -vactor IMZT -boot\ 

-ram 0x0,0xfffff -ram 0x200000,0x2ff£ff axaxpla 

As example 4 but a module containing reset infonnation is produced. The reset address is 
0x200000. The interrupt vector is completely initialized. The first two long words of section 
RTS-CODE contains the initial PC and the initial interrupt suck pointer, consequently 
RTS-CODE must be the first section to load in order to control the reset address. 


Example: 6 

$ al -raa 0x10000,0x£ffff\ 

-vactor AODRESS»0x70000,COPY\ 

-Intarrupt-stack STARTsOxTOOOO,SIZEs0x8000\ 

-main-task STACK-STARTs0x68000, STACK-SIZZs0x8000,\ 
PRZORZTY»3, TINE-SLICBsO. 2, FL0AT\ 
-ta8k-da£aalts STACK-SIZEsOxSOOO, PRIORITY^d, \ 
TIMB-SLICEsO. 1 axaaiple 

The start address of the program is 0x10000. The intemipt vector has the address 0x70000 and 
is a copy of the interrupt vector defined when the Ada program gains control. The interrupt suck 
has start address at 0x70000 and the size 0x8000. Please note that the first byte used in the suck 
is Qx6ffif and the stack grows by decrementing the stadc pointer (suck grows "down" in memory). 
The main program suck’s start address is (^68000. and the size is 0x8000, the main program 
has a priority of 3 if pragma priority does not apply, the time slice is 0.2 seconds and the main 
program uses the floating poim co-processor. The defaults used for task suck size is 0x8000, a 
priority of 4 and a time slice of 0.1 second. 




DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 

The Ada Linker 


Example: 7 

$ al my.fil«.arc -optlon_fila my.fila.opt axaa^le 

The linker was not able to generate an adequate initialization and option file, and the user decided 
to use his own. The my-flle.src file contains the assembly source for the initialization module, 
and the my-fileuipt contains the option file for the link. With this form of link the user has full 
coittrol over the option file and the initialization module. 


Example: 8 

$ al -noda SBCORX -elass-fila axaaqpla.clsX 
-ram 0x10000,Oxfffff\ 

-mmu-datails SBGMEMT-SIZEslS, PAGE-SIZE>10, \ 
TIA^8,TIBs8,TIC»6 axampla 

Execution of the program will be in SECURE mode. The class specification is in the file 
example.ds. Heaps and dynamic allocated stacks will be placed in address range 0x10000 to 
Oxffflf. The MMU Translation Control Register is setup with a page size of IK bytes, and TIA 
= 8, TIB = 8. TIC = 6, TID = 0, each class gets 64K bytes of logical memory for heaps and 
stacks. 


82 









APPENDIX F - IMPLEMENTATION DEPENDENT CHARACTERISTICS 


This appendix describes the implementadon-dependent characteristics of DACS-680x0 required in 
Appendix F of the Ada Reference Manual (ANSI/MIL-STD-181SA). 


F.l Implemenitation'Dependent Pragmas 

This section describes all implementation defined pragmas. 


Fl.l PRAGMA INTERFACE-SPELLING 

Format: pragma INTERFACE-SPELLING(<subprogram-name>, <string>) 

Placement: The pragma may be placed as a declarative item. 

Restrictions: Pragma INTERFACE-SPELLING must be applied to the subprogram denoted 
by <subprogram-name>. The <string> must be a string literal. 

This pragma allows an Ada program to call routines with a name that is not a legal Ada name, 
the <string> provides the exact speUing of the name of the procedure. 


F1.2 PRAGMA INTERFACE-TRAP 

Format: pragma INTERFACE-TRAP(<subprogram-name>, <string>, <integer>) 

Placement: The pragma may be placed as a declarative item. 

Restrictions: The <subprogram-name> must denote a procedure or a function for which pragma 
interface to AS has been applied. The <string> must be a string literal. The 
<integer> must be greater than 3. 

The pragma allows the programmer to implement assembler routines that need access to the run¬ 
time system code or dm in a link mode independent marmer. The string literal is used as the 
name for a global linker symbol, when the linker implements the call to the user supplied 
subroutine. The string literal must be unique when linking a program containing calls to 
subprograms for which INTERFACE-TRAP is applied. The integer is used as an index to the 
table of entry points in the kernel and must likewise be unique. When the integer is chosen, please 
consult the padcage RTS-TRANSFER-INDICES (see appendix C.8) to avoid conflicts with the 
indices used by the run-time system and support packages. 

When control is passed to the user supplied routine register A4 contains the value of the 
stackpointer prior to the call: A4 is the only way to access parameters for the routine. The routine 
must maintain stack balance and must return by a RTS. 






DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
Implemeruation Dependent Characteristics 


For a program linked with the SECURE or SAFE mode it is checked that the task executing the 
routine has the "change mode to supervisor" privilege. The check is performed before control is 
passed to the user supplied routine. 


FIJ PRAGMA INITIALIZE 

Format: pragma INITIALIZE(<stringJiteral>) 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

When the pragma is applied the linker will, as pan of the initialization code generate a call to the 
subprogram with the name <string-literal>. The call will be performed before the elaboration of 
the Ada program is initiated, with the interrupt mask in the Stanis Register at 7. If several 
pragmas INITIALIZE are applied to the same program the routines are called in the elaboration 
order, if several pragmas INITIALIZE are applied to one compilation unit the routines are called 
in the order of appearance. If several compilation units apply pragma INITIALIZE to the same 
routine the routine is only called once. 


Fl,4 PRAGMA RUNDOWN 

Format: pragma RUNDOWN(<stringJiteral>) 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Similar to pragma initialize, but the subprogram is called after the main program have terminated 
and in th^ everse order of the elaboration order. 


Fl,5 PRAGMA TASKS 
Format: pragma TASKS; 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Marks the compilation unit with the task attribute. If the code that is interfaced by a pragma 
INTERFACE uses any tasking constructs, the compilation unit must be marked such that the 
linker includes the tasldng kernel in target programs that reference the compilation unit. 


1-74 



DACS 68QhO B«e Ada Cross Compiler System • User’s Guide 
Impiementaiion Dependent Characteristics 

n.6 PRAGMA FLOATS 
Fdraiat: pragma FLOATS; 

Placement; The pragma may be placed as a declarative item. 

Restrictions: Nmie. 

M alta t he cmnpilarion unit with the float attribute. If the code that is interfaced by a pragma 
INTERFACE uses any floating point co-processor instnictions, the compilation unit must be 
marked such that the linker indudes initializaticm of the floating point co-processor in target 
programs that reference the compilation unit 

F1.7 PRAGMA INTERRUPTS 
Format: pragm INTERRUPTS; 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Marta the comirilation unit with the interrupt attribute. If the code that is interfaced by a pragma 
INTERFACE uses any inienupts. the compilation unit must be maiked such that the linker 
include the interrupt lumdling in target programs that reference the compilation unit. 

Fl^ PRAGMA STORAGE-MANAGER 
Fbrmat: pragma STORAGE-MANAGER; 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Marta the compilation unit with die hea|/ nmbute. If the code that is interfaced by a pragma 
INTERFACE uses the storage maiuiger, the compilation unit must be maiked such that the linker 
indude initialization of the storage manager in target programs that reference the compilation unit. 

F1.9 PRAGMA INTERRUPT-HANDLER 

The pragma INTERRUPT-HANDLER is defined with two fonnats. 









DACS 680x0 Bare Ada Cross Compiler System • User's Guide 
Implementation Dependent Characteristics 


Fl.9.1 PRAGMA INTERRUPT-HANDLER for Task Entries 
Fonnat: pra{ina INTERRUPT-HANDLER; 

Placement: The pragma must be placed as the first declarative item in the task specification that 

it applies to. 

Restrictions: The task for which the pngna INTERRUPT-HANDLER is applied must fulfill 
the following requirements: 

1) The pragma must appear first in the specification of the task and an address clause must 
be given to all entries defined in the task, see below. 

. task £ih is 

pragma interrupt-handler; 
entry handlerl: 
for handlerl use at 254; 
entry handler2; 
for handler2 use at 255; 
end fih; 

2) All entries of the task must be single entries with no parameters. 

3) The entries must not be called from any tasks. 

4) No other tasks may be specified in the body of the task. 

5) The body of the task must consist of a single sequence of accept statements for each of the 
defined iiuenupts, see below: 

task body fih is 

— local simple data declaration, no tasks, 
begin 

accept handlerl do 
<statementlist>; 
end handlerl; 
accept handler2 do 
<stateinentlist>; 
end handler2; 
end fih; 

6) The only tasking construa that may be used from the body of an accept statement is 
unconditional entry calls. Several unconditional entry calls may appear in the body of an 
accept statement but only one entry call must be made during tire handling of the interrupts. 

7) Any procedures called from the accept body may not use any tasking constructs at all. 

8) A given entry must only be accepted once within the body of an FIH. 

9) No exceptions may be propagated out of the task body. 

If the restrictions described above are not fulfilled, the program is erroneous and the result of the 
execution unpredictable. The compiler carmot and is not checking all the restrictions, but attempts 
to perform as many checks of the requirements as possible. 






















DACS 68QrO Bate Ada Oms Compiler Sy«em • User’s Guide 
bnptementation Dependent Characteristics 


The pragma INTERRUFTJHANDLER with no parameters allows the user to implement 
immediate response to exceptions. 


F1.9J PRAGMA INTERRUPTJIANDLER for Procedures 

Fbrmat: pragma INTERRUPT_HANDLER(procedure>name,inteser-literai); 

Placement: The i»agma must be placed as a declarative item, in the declarative part, 

immediately after the procedure specification. 

Restrictions: The procedure for which pragma INTERRUPT-HANDLER applies must fulfill the 
following restrictions: 

1) The pragma must aiqiear before the body of the procedure. 

2) The procedure must not be called anywhere in the application. 

3) No tasks may be declared in the body of the procedure. 

4) The only tasking construct that may be used from the body of the procedure is 
unconditionai entry calls. Several unconditional entry calls may appear in the body of the 
procedure, but only one entry call may be made during the handling of the intenupt. 

5) Any subprograms called from the procedure must not use any tasking constructs at all. 

6) The procedure must have no parameters. 

7) No exceptions may be propagated out of the procedure. 

If the restrictions described above is not fulfilled the program is erroneous and the result of the 
execution unptediaable. The compiler carmot and is not checking all the restrictions, but attempts 
to perform as many checks of the requirements as possible. 

The pragma INTERRUPT-HANDLER for procedures defines the named subprogram to be an 
interrupt handler for the interrupt vector enoy defined by the integer-literal. 


n.lO PRAGMA NO-FLOATING-POINTS 

Format: pragma NO-FLOATING-POINTS(task-id) 

Placemeru: The pra^a must be placed as a declarative item, in the declarative part, defining 

the task type or object dermted by the task-id. 

Restrictions: The task(s) denoted by the task-id must not execute floating-point co-processor 
instructions. 

This pragma informs the compiler and run-time system that the task will not execute floating point 
co-processor iasiructions. Consequently the context switch needs not save and restore the state of 
the lloating point co-processor yielding improved performance. 







DACS 680x0 Bare Ada Croas Comixier System - User’s Guide 
Implementadmi Dependent Characteiistics 

F1.11 PRAGMA SUPERVISOR-TASK 
Fonnat: pragma SUPERVISOR-TASK 

nacemera: The pragma must be placed immediately after the task declaration of the task 

declaring it as a SUPERVISOR-TASK. 

Restrictions: The pragma has no meaning if linking with BASIC mode. 

This pragma infi)nns the cmnpiler and ran-time system that the task shall execute at the supervisor 
privilege level, all other tasks will execute at user privilege level when linking with SECURE or 
SAFE mode. In BASIC mode all tasks execute at the supervisor privilege level. 

F1.12 PRAGMA ACCESS-TYPE-RETAINJHEAP 
Fonnat: pragma ACCESS-TYPE-RETAIN-HEAP 

Placement: The pragma must be placed as a declarative item in the declarative pan. immediately 

after the procedure specification. 

Restrictions: The pragma can only be used when linking in BASIC mode. 

This {xagma suppresses garbage collection of access types, when leaving the scope of the access 
type declaiatiotL 

F2 Implementation-Dependent Attributes 
No implementation-dependent attributes are defined. 







DACS 680x0 Bare Ada Cross Gompiter Sysiem > User’s Guide 
Imptementation Dependent Characteristics 



FJ Package SYSTEM 
package SYSTEM is 


type ADDRESS 

is new INTEGER, 


subtype PRIORITY 

is INTEGER range 1 .. 24; 

type NAME 

is ( DACS-680X0 

); 

SYSTEM-NAME: 

constant NAME 

« DACS-680X0; 

STORAGE-UNIT: 

constant 

- 8; 

MEMORY-SIZE: 

constant 

- 2#1#E32; 

MIN-INT: 

constant 

- -2_147_483_648 

MAX-INT: 

constant 

- 2-147.483-647; 

MAX-DIGITS: 

constant 

- 15; 

MAX-MANTISSA: 

constant 

- 31; 

FINE-DELTA: 

constant 

- 2#1.0#E-31; 

TICK: 

constant 

2#1.0#E-14; 

type interface-language 

is (AS,C); 



end SYSTEM; 

The basic clock period SYSTEM.TICK is not utilized by DACS-680x0. The real time between 
each successive timer tick will be a multiplum of SYSTEM.TICK. but the actual time between 
each timer tick depends on a given target board and is specified in the User Configurable Code 
(UCQ. 


F.4 Representation Clauses 

The DACS-680x0 fully supports the 'SIZE representation for derived types. The representation 
clauses that are accepted for non-derived types are described in the following subsections. 


F4.1 Length Clause 

Some remarks on imidementadon dependent behavior of length clauses are necessary: 

• When using the SIZE attribute for discrete types, the maximum value that can be specified 
is 32 bits. 

• SIZE is only obeyed for discrete types when the type is a part of a composite object, e.g. 
arrays or records. 

• Using the STORAGE_.SIZE attribute for a colleaion will set an upper limit on the total 
size of objects allocated in this collecdotL If further allocation is attempted, the exception 
STORAGE-ERROR is raised. 

• When STORAGE-SIZE is specified in a length clau.se for a task, the process stack area 
will be of the specified size. 





DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
bnpiememaiion Dependent Oiaracteiistics 


F4J Enumeration Representation Clauses 

Enumeration representation clauses may specify representations in the range of ENTEGER'FIRST 
+ l..INTEGER'LAST - I. 


F4J Record Representation Qauses 

When representation clauses are applied to records the following restrictions are imposed: 

• If the component is a record or an unpacked array, it must start at a storage unit boundary 
(8 bits). 

• A record occupies an integral number of ston^e units (words) (even though a record may 
have fields that only define an odd number of bytes). 

• A record may take up a maximum of 2 gip bits. 

• A component must be specified with its proper size (in bits), regardless of whether the 
component is an array or noL 

• If a non-airay component has a size which equals or exceeds one storage unit 32-bits the 
component must start on a storage unit boundary. 

• The elements in an array component should always be wholly contained in 32-bits. 

If the record type cotuains components which are not covered by a component clause, they are 
allocated consecutively after the component with the value. Allocation of a record component 
without a component clause is always aligned on a storage unit boundary. Holes created because 
of component clauses are not otherwise utilized by the compiler. 

Pragma PACK on a record type will attempt to pack the components not already covered by a 
representation clause (perhaps none). This packing will begin with the small scalar components and 
larger components will follow in the order specified in the record. The packing begins at the first 
storage unit after the components with representation clauses. 


F4J.1 Alignment Clauses 

Alignment clauses for records are implemented with the following characteristics: 

• If the declaration of the record type is done at the outermost level in a library package, any 
alignment is accepted, otherwise only longword alignments are accepted. 

• Any record objea declared at the outermost level in a library package will be aligned 
according to the alignment clause specified for the type. Record objects declared elsewhere 
can only be aligned on a longword boundary. If the record type is associated wiih a 
different alignment, an error message will be i.ssued. 

• If a record type with an associated. alignment clause is used in a composite type, the 
alignment is required to be longword; an error message is issued if this is not the ease. 






OACS 680x0 Bare Ada Qw Cbrapiter System - User’s Guide 
liaptenientation DqKndem Chaiacrerisdcs 


FJi Inipteineiitation>Depciident Names for Impleinentatioii«Dependent Components 
None defined by the compiler. 

« 

Address Clauses 

This section describes the implementation of address clauses and what types of entities may have 
their address specified by the user. 

F6.1 Objects 

Address clauses are supported for scalar and composite objects whose size can be detennined at 
compile time if the address is specified. 

F6.2 Task Entries 

Address clauses are supported for task entries. The following restrictions applies: 

• The affeaed entries must be defined in a task object only, not a task type. 

• The entries must be single and parameterless. 

• The address specified must not denote an interrupt index which the processor may trap. 

• If the interrupt entry executes floating point co-processor instructions the state of the 
co-processor must be saved prior to execution of any floating point instructions, and restored 
before the return. 

The address specified in the address clause denotes the interrupt vector index. 

F.7 Unchecked Programming 

Both UNCHECKED_DEALLOCATION and UNCHECKED_CONVERSION are supported as 
indicated below. 

F7.1 Unchecked Deallocation 

Unchecked deaUocadon is fully supported through the procedure UNCHECKED-DEALLOCATION 
as defined in [DoD-831 13.10.1. 



DACS 680x0 Bait Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 


F7.2 Unchecked Conversion 

Unchecked conversion is hilly supported through the procedure UNCHECKED-CONVERSION as 
deflned in [DoD-83] 13.10.2. Unchecked conversion is only allowed between objects of the same 
"size". However, if a scalar type have different sizes (packed and unpacked), unchecked conversion 
between such a type and another type is accepted if either the packed or the unpacked size fits 
the other type. 


F.8 biput/Output Packages 

In many embedded systems, there is no need for a traditional I/O system, but in order to suppon 
testing and validation. DDC-I has developed a small terminal oriented I/O system. This I/O system 
consists’essentially of TEXT_IO adapted with respect to handling only a terminal and not file I/O 
(hie I/O will cause a USE-ERROR to be raised) and a low level package called 
TERMINAL-DRIVER. A BASIC-IO package has bera provided for convenience purposes, 
forming an interface between TEXT—lO and TERMINAL—DRIVER as illustrated in the following 
figure. 



• 

TEXT-IO 



BASIC-IO 

TERMINAL-DRIVER 
(H/W interface) 


Figure F.l: 

The TERMINAL-DRIVER package is the only package that is target dependent, i.e., it is the 
only package that need be changed when changing communications controllers. The actual body 
of Ae TERMINAL-DRIVER is written in assembly language, but an Ada interface to this body 
is provided. A user can also call the terminal driver routines directly, i.e. from an assembly 
language routine. TEXT-IO and BASIC-IO are written completely in Ada and need not be 
changed. 

BASIC-IO provides a mapping between TEXT-10 control characters and ASCII as follows: 


TEXT-IO 

ASCII Character 

LINE-TERMINATOR 

PAGE-TERMINATOR 

FILE-TERMINATOR 

NEW-LINE 

ASCII.CR 

ASCII.FF 

ASCII.EM (Ctrl Z) 

ASCII.LF 


Table F.l: Mapping between TEXT_IO and .ASCII 











DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
Imidementation Dependent Characteristics 

The services provided by the temiinal driver arc: 

1) Reading a character from the communications port 

2) Writing a character to the communications port. 


F8.1 Package TEXT-IO 

The speciiication of package TEXT.IO: 


pragma page; 
with BASIC_IO; 

with IO_EXCEPTIONS; 
package TEXT-IO is 

type FILE-TYPE is limited private; 

type FILE-MODE is (IN-FILE, OUT-FILE); 

type COUNT is range 0 .. INTEGER'LAST; 

subtype POSITIVE-COUNT is COUNT range 1 .. COUNT'LAST; 

UNBOUNDED: constant COUNT:- 0; — line and page length 

— max. size of an integer output field 2#....# 
subtype FIELD is INTEGER range 0 .. 35; 

subtype NUMBER-BASE . is INTEGER range 2 .. 16; 

type TYPE-SET is (LOWER-CASE, UPPER-CASE); 




DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
Implementation Dependent Cha^eristics 

pragma PAGE; 

— File Management 


procedure CREATE 

(FILE 


in 

out 

FILE-TYPE; 



MODE 


in 


FILE-MODE ;-OUT-FILE; 



NAME 


in 


STRING :-••*•; 



FORM 

) ; 


in 


STRING 

procedure OPEN 

(FILE 


in 

out 

FILE-TYPE; 



MODE 


in 


FILE-MODE; 



NAME 


in 


STRING; 



FORM 

); 


in 


STRING :»" •* 

procedure 

CLOSE 

(FILE 


in 

out 

FILE-TYPE); 

procedure DELETE 

(FILE 


in 

out 

FILE-TYPE); 

procedure 

RESET 

(FILE 


in 

out 

FILE-TYPE; 



MODE 


in 

FILE-MODE); 

procedure 

RESET 

(FILE 


in 

out 

FILE-TYPE); 


function MODE (FILE : in FILE-TYPE) return FILE-MODE; 

function NAME (FILE : in FILE-TYPE) return STRING; 

function FORM (FILE ; in FILE-TYPE) return STRING; 

function IS-OPEN(FILE ; in FILE-TYPE return BOOLEAN; 
pragma PAGE; 

~ control of default input and output files 

procedure SET-INPUT (FILE : in FILE-TYPE); 
procedure SET-OUTPUT (FILE : in FILE-TYPE); 

function STANDARD-INPUT return FILE-TYPE; 

function STANDARD-OUTPUT return FILE-TYPE; 

function CURRENT-INPUT return FILE-TYPE; 

function CURRENT-OUTPUT return FILE-TYPE; 

pragma PAGE; 

— specification of line and page lengths 

procedure SET-LINE-LENGTH (FILE : in FILE-TYPE; 

TO : in COUNT); 

procedure SET-LINE-LENGTH (TO : in COUNT); 

procedure SET-PAGE-LENGTH (FILE : in FILE-TYPE; 

TO : in COUNT); 

procedure SET-PAGE-LENGTH (TO : in COUNT); 

function LINE-LENGTH (FILE : in FILE-TYPE) 

return COUNT; 
function LINE-LENGTH return COUNT; 

function PAGE-LENGTH (FILE : in FILE-TYPE) 

return COUNT; 
function PAGE-LENGTH return COUNT; 


1S4 






DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
luqjtememadon Dependem Characteiistics 

pragma PAGE; 

Column, Line« and Page Control 

procedure NEW-LINE (FILE : in FILE-KPE; 

SPACING : in POSITIVE-COUNT 1); 
procedure NEW_LINE (SPACING : in POSITIVE-COUNT 1); 

procedure SKIP-LINE (FILE : in PilE-TYPE; 

SPACING : in POSITIVE-COUNT :« 1); 
procedure SKIP-LINE (SPACING : in POSITIVE-COUNT 1); 

function END-OF-LINE (FILE : in FILE-TYPE) return BOOLEAN; 

function END_OF-LINE return BOOLEAN; 

procedure NEW-PAGE (FILE : in FILE-TYPE); 
procedure NEW-PAGE; 

procedure SKIP-PAGE (FILE : in FILE.TYPE); 
procedure SKIP-PAGE; 

function END-OFJPAGE (FILE : in FILE-TYPE) return BOOLEAN; 

function END.OF-PAGE return BOOLEAN; 

function END-OF-FILE (FILE : in FILE-TYPE) return BOOLEAN; 

function END-OF-FILE return BOOLEAN; 

procedure SET-COL (FILE : in FILE-TYPE; 

TO : in POSITIVE-COUNT); 
procedure SET-COL (TO : in POSITIVE-COUNT); 

procedure SET-LINE (FILE : in FILE-TYPE; 

TO : in POSITIVE-COUNT); 

procedure SET-LINE (TO : in POSITIVE-COUNT); 

function COL (FILE : in FILE-TYPE) 

return POSITIVE-COUNT; 
function COL return POSITIVE-COUNT; 

function LINE (FILE : in FILE-TYPE) 

return POSITIVE-COUNT; 
function LINE return POSITIVE-COUNT; 

function PAGE 


function PAGE 


(FILE : in FILE-TYPE) 
return POSITIVE-COUNT; 
return POSITIVE-COUNT; 





DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
Implementation Dependem Characteristics 


pragma PAGE; 

— Character Input-Output 


procedure GET 

(FILE 

: in FILE_TYPE; 

ITEM : 

out 

CHARACTER) 

procedure GET 

( 




ITEM : 

out 

CHARACTER) 

procedure PUT 

(FILE 

: in FILE-TYPE; 

ITEM : 

in 

CHARACTER) 

procedure PUT 

( 




ITEM : 

in 

CHARACTER) 

~ String Input-Output 






procedure GET 

(FILE 

: in FILE-TYPE; 

ITEM : 

out 

CHARACTER) 

procedure GET 

( 




ITEM : 

out 

CHARACTER) 

procedure PUT 

(FILE 

: in FILE-TYPE; 

ITEM : 

in 

CHARACTER) 

procedure PUT 

( 




ITEM : 

in 

CHARACTER) 

procedure GET. 

.LINE 

(FILE 


in FILE. 

-TYPE; 





ITEM 


out STRING; 





LAST 


out NATURAL); 



procedure GET. 

.LINE 

(ITEM 


out STRING; 





LAST 

1 

out NATURAL); 



procedure PUT. 

.LINE 

(FILE 


in FILE. 

-TYPE; 





ITEM 


in STRING); 



procedure PUT. 

.LINE 

(ITEM 


in STRING); 












DACS 680x0 Bm Ada Qoas Compiler System • User’s Guide 
Implemeiitmion Depotdent CharacteiisUcs 


pragma PAGE; 

— Generic Package for Input-Output of Integer Types 


generic 

type NUM is range <>; 
package INTEGER-IO is 


DEFAULT.WIOTH : FIELD MUM'WIDTH; 

DEFAULT_BASE : NUMBEIUBASE 10; 


procedure GET 

(FILE 

in FILE-TYPE; 


ITEM 

out NUM; 


WIDTH 

in FIELD 0); 

procedure GET 

(ITEM 

out NUM; 


WIDTH 

in FIELD 0); 

procedure PUT 

(FILE 

in FILE-TYPE; 


ITEM 

in NUM; 


WIDTH 

in FIELD DEFAULT-WIDTH; 


BASE 

in NUMBER-BASE DEFAULT-BASE); 

procedure PUT 

(ITEM 

in NUM; 


WIDTH 

in FIELD DEFAULT-WIDTH; 


BASE 

in NUMBER-BASE DEFAULT-BASE); 

procedure GET 

(FROM 

in STRING; 


ITEM 

out NUM; 


LAST 

out POSITIVE); 

procedure PUT 

(TO 

out STRING; 


ITEM 

in NUM; 


BASE 

in NUMBER-BASE DEFAULT-BASE); 


end INTEGER-IO 











DACS 680x0 Bare Ada CiDss Compiler System • User’s Guide 
Implementation Dependent Characteristics 


pragma PAGE; 

— Generic Packages for Input-Output of Real Types 
generic 

type HUM is digits•<>; 
package FLQAT-IO is 


DEFAULT-FORE : 

FIELD 

2; 

DEFAULT-AFT 

FIELD 

HUM'DIGITS - 1; 

DEFAULT-EXP 

FIELD 

3; 

procedure GET 

(FILE 

: in FILE-TYPE; 


ITEM 

: out NUM; 


WIDTH 

: in FIELD 0) ; 

procedure GET 

(ITEM 

: out NUM; 


WIDTH 

: in FIELD 0); 

procedure PUT 

(FILE 

: in FILE-TYPE; 


ITEM 

: in NUM; 


FORE 

: in FIELD DEFAULT-FORE; 


AFT 

: in FIELD DEFAULT-AFT; 


EXP 

: in FIELD DEFAULT-EXP); 

procedure PUT 

(ITEM 

: in NUM; 


FORE 

; in FIELD DEFAULT-FORE; 


AFT 

: in FIELD DEFAULT-AFT; 


EXP 

: in FIELD DEFAULT-EXP); 

procedure GET 

(FROM 

: in STRING; 


ITEM 

: out NUM; 


LAST 

; out POSITIVE); 

procedure PUT 

(TO 

: out STRING; 


ITEM 

: in NUM; 


AFT 

: in FIELD DEFAULT-AFT; 


EXP 

: in FIELD DEFAULT_EXP) 


end FLOAT-IO; 








DACS 68(M) Bate Ada Cioas Coaa|iler System - User’s Guide 
bnpleraemttion Dependent Characteristics 


pragma PAGE; 
generic 

type NUM ia delta <>; 
package FIXED-IO is 

DEFAUm-ORE : FIELD NUM'FORE; 
DEFAULT-AFT : FIELD NUM'AFT; 

DEFAULT-EXP : FIELD 0; 

procedure GET (FILE : in FILE-TYPE; 

ITEM : out NUM; 

WIDTH : in FIELD 0); 
procedure GET (ITEM : out NUM; 

WIDTH : in FIELD 0) ; 


procedure 

PUT 

(FILE 


in 

FILE-TYPE; 



ITEM 


in 

NUM.- 





FORE 


in 

FIELD 


DEFAULT-FORE .- 



AFT 


in 

FIELD 


DEFAULT_AFT; 



EXP 


in 

FIELD 


DEFAULT-EXP); 

procedure 

PUT 

(ITEM 


in 

NUM.- 





FORE 


in 

FIELD 

* fli 

DEFAULT-FORE .- 



AFT 


in 

FIELD 

• • 

DEFAULT-AFT.- 



EXP 


in 

FIELD 


DEFAULT-EXP); 

procedure GET 

(FROM 


in 

STRING 

0 




ITEM 


out NUM; 





LAST 


out POSITIVE); 


procedure PUT (TO : out STRING; 

ITEM ; in NUM.- 

AFT : in FIELD DEFAULT_AFT; 

EXP : in FIELD DEFAULT_EXP); 


end FIXED-IO 







DACS 680x0 Bare Ada Cross Cominler System • User’s Guide 
Implementation Depemlent Characteristics 


pragma PAGE; 

— Generic Package for Input-Output of Enumeration Types 
generic 

type ENUM is (<>); 
package ENUMERATION.10 is 

DEFAULT.WIDTH : FIELD 0; 

DEFAULT-SETTING ; TYPE-SET UPPER-CASE; 


procedure GET 

(FILE : 

in FILE-TYPE; 

ITEM : out ENUM); 

procedure GET 

( 


ITEM : out ENUM); 

procedure PUT 

(FILE 

; FILE-TYPE; 



ITEM 

: in ENUM; 


• 

WIDTH 

: in FIELD 

DEFAULT-WIDTH; 


SET 

; in TYPE-SET 

DEFAULT-SETTING); 

procedure PUT 

(ITEM 

: in ENUM; 



WIDTH 

: in FIELD 

DEFAULT-WIDTH; 


SET 

; in TYPE-SET 

DEFAULT-SETTING); 

procedure GET 

(FROM : 

in STRING; 



ITEM : 

out ENUM; 



LAST : 

out POSITIVE) 


procedure PUT 

(TO ; 

out STRING; 



ITEM : 

in ENUM; 



SET : 

in TYPE-SET 

:• DEFAULT-SETTING); 


end ENUMERATION-IO; 

pragma PAGE; 

— Exceptions 

STATUS-ERROR 
MODE.ERROR 
NAME-ERROR 
USE-ERROR 
DEVICE-ERROR 
END-ERROR 
DATA-ERROR 
LAYOUT-ERROR 

pragma page; 
private 

type FILE-TYPE is 
record 

FT : INTEGER -1; 
end record; 

end TEXT-IC; 


exception 

exception 

exception 

exception 

exception 

exception 

exception 

exception 


renames 

renames 

renames 

renames 

renames 

renames 

renames 

renames 


IO_EXCEPTIONS, 
IO_EXCEPTIONS. 
ID-EXCEPTIONS. 
lO-EXCEPTIONS. 
lO-EXCEPTIONS. 
lO-EXCEPTIONS. 
lO-EXCEPTIONS, 
lO-EXCEPTIONS, 


STATUS-ERROR 

MODE-ERROR; 

NAME-ERROR; 

USE-ERROR; 

DEVICE-ERROR 

END-ERROR; 

DATA-ERROR; 

LAYOUT-ERROR 


190 









DACS 6M9(0 Bait Ada Cross Compiler System • User’s Guide 
Implemematton Dependem Characteristics 


F1U Package IO.EXCEPnONS 

The specification of the package lO-EXCEFTIONS: 


package lO-EXCEPTIONS is 


STATUS-ERROR 

MODE-ERROR 

NAME-ERROR 

USE-ERROR 

DEVICE-ERROR 

END-ERROR 

DATA-ERROR 

LAYOUT-ERROR 


exception; 

exception; 

exception; 

exception; 

exception; 

exception; 

exception; 

exception; 


end ZO-EXCEPTIONS; 


F8J Package BASIC-IO 

The specification of package BASIC-IO: 

with IO_EXCEPTIONS; 
package BASIC-IO is 

type count is range 0 .. integer'last; 

subtype positive-count is count range 1 •. count'last; 


function get-integer return string; 

— Skips any leading blanks, line terminators or page terminators. 

— Then reads a plus or a minus sign if present, then reads according 

— to the syntax of an integer literal, which may be based. 

— Stores in item a string containing an optional sign and an integer 

— litteral. 

— The exception DATA-ERROR is raised if the sequence ofcharacters dees 

— not correspond to the syntax described above. 

— The exception END-ERROR is raised if the file terminator is read. 

— (This means that the starting sequence of an integer has not been met) 

— Note that the character terminating the operation must be available 

— for the next get operation. 


• 1^1 





DACS 680x0 Bare Ada Cross Compiler System - User’s Guide 
Imi^ementation Dependent Chaiacteristics 


function get-real return string; 

— Corresponds to get-integer except that it reads according to the 

— syntax of a real literal, which may be based. 

function get-enumeration return string; 

— Corresponds to get-integer except that it reads according to the 

— syntax of an identifier, where upper and lower case letters are 

— equivalent to a character literal including the apostrophes. 

function get-item(length : in integer) return string; 

— Reads a string from the current line and stores it in item; 

— If the remaining number of characters on the current line is 

— less than length then only these characters are returned. 

— The line terminator is not skipped. 

procedure put-itemCitem : in string); 

— If the length of the string is greater than the current maximum line 

— linelength the exception LAYOUT-ERROR is raised. 

-- If the string does not fit on the current line a line terminator is 
■*- output. Then the item is output. 


— Line and page lengths - ARM 14.3.3. 


procedure set-line-length(to : in count); 

procedure set-page-length(to : in count); 

function line-length return count; 
function page-length return count; 

— Operations on columns, lines and pages - ARM 14.3.4. 


procedure new_line; 


procedure skip-line; 


function end-of-line return boolean; 


procedure new-page; 


procedure skip_page; 


192 



DACS MQhO Bam Ada Crou Compiler Syston - User’s Guide 
l a ^ jle mem miop Oepeadem Characteristics 


function end-of-page return boolean; 
function end-of-file return boolean; 


procedure set-coKto : in positive-count); 
procedure set-line(to : in positive-count); 
function col return positive-coimt; 
function line return positive-count; 
function page return positive-count; 

— Character and string procedures. 

— Corresponds to the procedures defined in ARM 14.3.6. 


procedure get-character(item : 


out character); 


procedure 

procedure 

procedure 

procedure 

procedure 


get-string(item : out string); 

get-line(item : out string; 

last : out natural); 

put-character(item : in character); 

put-string(item : in string); 

put-line(item : in string); 


— exceptions: 

USE-ERROR : exception renames lO-EXCEPTIONS.USE-ERROR; 
DEVICE-ERROR : exception renames lO-EXCEPTZONS.DEVICE-ERROR; 
END-ERROR : exception renames lO-EXCEPTIONS.END-ERROR; 
DATA-ERROR : exception renames lO-EXCEPTIONS.DATA-ERROR; 
LAYOUT-ERROR : exception renames lO-EXCEPTIONS.LAYOUT-ERROR; 


end BASIC-IO; 





DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
Imfdementadon Dqxndem Characteristics 

F8.4 Package TERiVUNAL-DRlVER 

The specification of package TERMINAL-DRIVER: 


package terminal.drivee is 

procedure put-character(ch : character); 
procedure flush; 

fiinction get-character return character; 
procedure purge; 
private 

pragma interface (AS, put-character) ; 

pragma interface-spelling(put-character, "Ada-UCC-GSPutByte"); 
pragma interface (AS, get-character); 

pragma interface-spelling(get-character, "Ada-UCC-GSGetByte”); 
pragma interface (AS, flush); 

pragma interface-spelling(flush, "Ada_UCC-GSFlushOutput"); 
pragma interface (AS, purge); 

pragma interface-spelling(purge, "Ada-UCC-GSPurgelnput”); 

pragma initialize("Ada-UCC-GSInitlO”); 
pragma rundown ("Ada-UCC-GSCloselO"); 

end terminal-driver; 


F8J Package SEQUENHAL-IO 

As files are not supported, the subprograms in this package will raise USE-ERROR or 
STATUS-ERROR. The specification of package SEQUENTIAL-IO: 


— Source code for SEQUENTIAL-IO 

pragma PAGE; 

with lO-EXCEPTIONS; 

generic 

type ELEMENT-TYPE is private; 


194 





DACS 68QkO Bare Ada Cioa Compiler System - User's Guide 
lo^ileiiieiiiadoii Oepemtem Characteristics 


package SEQUENTIAL-IO is 

type FILE_TYPE is limited private; 
type FILE_MODE is (IN_FILE, OUT_FILE); 


pragma PAGE; 

— File management 


procedure CREATE 

(FILE 


in 

out 

FILE-TYPE; 



MODE 


in 


FILE-MODE 

OUT-FILE; 


NAME 


in 


STRING 

MM. 

t 


FORM 


in 


STRING 

""); 

procedure OPEN 

(FILE 


in 

out 

FILE-TYPE; 



MODE 


in 


FILE-MODE; 



NAME 

: 

in 


STRING; 



FORM 


in 


STRING "“) 

» 

procedure CLOSE 

(FILE 


in 

out 

FILE-TYPE); 


procedure DELETE 

(FILE 


in 

out 

FILE-TYPE) ; 


procedure RESET 

(FILE 

J 

in 

out 

FILE-TYPE; 



MODE 

: 

in 


FILE-MODE); 


procedure RESET 

(FILE 


in 

out 

FILE-TYPE); 


function MODE 

(FILE 

• 

in 

FILE-TYPE) return 

FILE-MODE; 

function NAME 

(FILE 

; 

in 

FILE-TYPE) return 

STRING; 

function FORM 

(FILE 

; 

in 

FILE-TYPE) return 

STRING; 

function IS-OPEN(FILE 

; 

in 

FILE-TYPE) return 

BOOLEAN; 


pragma PAGE; 

— input and output operations 


procedure READ 


(FILE ; in FILE-TYPE; 

ITEM ; out ELEMENT-TYPE); 


procedure WRITE (FILE 
ITEM 


in FILE-TYPE; 
in ELEMENT-TYPE); 


function END-OF-FILE(FILE : in FILE-TYPE) return BOOLEAN; 







DACS 680x0 Baie Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 


pragma PAGE; 
— exceptions 


STATUS-ERROR 

: exception 

renames 

MODE-ERROR 

: exception 

renames 

NAME-ERROR 

: exception 

renames 

USE-ERROR 

: exception 

renames 

DEVICE-ERROR 

: exception 

renames 

END-ERROR 

: exception 

renames 

DATA-ERROR 

: exception 

renames 


IO_EXCEPTIONS.STATUS-ERROR; 
IO_EXCEPTIONS.MODE-ERROR; 
ZO.EXCEPTIONfS .NAME-ERROR; 
lO-EXCEPTIONS.USE-ERROR; 
IO_EXCEPTIONS.DEVICE-ERROR; 
ZO-EXCEPTIONS.END-ERROR; 
lO-EXCEPTIONS.DATA-ERROR; 


pragma PAGE; 
private 

type FILE-TYPE is new INTEGER; 


end SEQUENTIAL-IO; 


F8.6 Package DIRECT-IO 

As files are not supported, the subprograms in this package will raise USE-ERROR or 
STATUS-ERROR. The specification of package DIRECT-IO; 


pragma PAGE; 
with lO-EXCEPTIONS; 

generic 

type ELEMENT-TYPE is private; 
package DIRECT-IO is 


type FILE-TYPE is limited private; 

type FILE-MODE is (IN_FILE, INOUT-FILE, OUT-FILE); 

type COUNT is range 0..2-147-483-647; 

subtype POSITIVE-COUNT is COUNT range 1..COUNT'LAST; 


1 % 






DACS 680x0 Bare Ada Cross Compiler System • User’s Guide 
Implementation Dependent Characteristics 


pragnui PAGE; 

— File management 

procedure CREATE(FILE : in out FILE_TYPE; 

MODE : in FILE-MODE 

NAME : in STRING 

FORM : in STRING 

procedure OPEN (FILE : in out FILE-TYPE; 

MODE : in FILE-MODE; 

NAME : in STRING; 

FORM : in STRING "") ; 

procedure CLOSE (FILE : in out FILE-TYPE); 

procedure DELETE(FILE : in out FILE-TYPE); 

procedure RESET (FILE : in out FILE-TYPE; 

MODE ; in FILE-MODE); 

procedure RESET (FILE : in out FILE-TYPE); 

function MODE (FILE : in FILE-TYPE) return FILE-MODE; 

function NAME (FILE : in FILE-TYPE) return STRING; 

function FORM (FILE : in FILE-TYPE) return STRING; 

function IS-OPEN(FILE : in FILE-TYPE) return BOOLEAN; 


- INOUT-FILE; 

_ l« • 

$ 

- ""); 









»'il.fJJ'■ I WW-iuii li n il . l ,J i| p |||pjfj||P|Pjll|^^ 


pfprawp 


DACS 680x0 Bare Ada Cioas Compto^ System - User’s Guide 
bqjtementation Dependent Charactoistics 


pragma PAGE; 
— input and 

output 

operations 

procedure 

READ 

(FILE : 

in 

FILE-TYPE; 



ITEM : 


out ELEMENT-TYPE; 



FROM : 

in 

POSITIVE-COUNT); 

procedure 

READ 

(FILE : 

in 

FILE-TYPE; 



ITEM : 


out ELEMENT-TYPE); 

procedure 

WRITE 

(FILE : 

in 

FILE-TYPE; 



ITEM : 

in 

ELEMENT-TYPE; 



TO 

in 

POSITIVE-COUNT); 

procedure 

WRITE 

(FILE : 

in 

FILE-TYPE; 



ITEM : 

in 

ELEMENT-TYPE); 

procedure 

SET-INDEX(FILE : 

in FILE-TYPE; 



TO 

; 

in POSITIVE-COUNT); 


function INDEX(FILE ; in FILE-TYPE) return POSITIVE-COUNT; 
function SIZE (FILE : in FILE-TYPE) return COUNT; 
function END-OF-FILE(FILE : in FILE-TYPE) return BOOLEAN; 


pragma PAGE; 
— exceptions 


STATUS-ERROR 

MODE-ERROR 

NAME-ERROR 

USE-ERROR 

DEVICE-ERROR 

END-ERROR 

DATA-ERROR 


exception renames 
exception renames 
exception renames 
exception renames 
exception renames 
exception renames 
exception renames 


lO-EXCEPTIONS.STATUS-ERROR; 
lO-EXCEPTIONS.MODE-ERROR; 
lO-EXCEPTIONS.NAME-ERROR; 
lO-EXCEPTIONS.USE-ERROR; 
lO-EXCEPTIONS.DEVICE-ERROR; 
lO-EXCEPTIONS.END-ERROR; 
lO-EXCEPTIONS.DATA-ERROR; 


pragma PAGE; 
private 


type FILE-TYPE is new INTEGER; 


end DIRECT-IO; 


F.9 Package CALENDAR 

Package CALENDAR is as defined in [DoD-83] section 9.6, except for a new procedure 
SET-TIME, which has been added to the package. SET-TIME allows setting of TIME for the 
duration of the executing program. SET-TIME parameters follow the same conventions as the 
parameters for SPLIT. The specification of package CALENDAR; 


198 












DACS 680x0 Bare Ada Cross Compiltf System - User’s Guide 
Implementation Dependent Characteristics 


PRACatA PAGE; 

PACKAGE calendar IS 

TYPE Time IS PRIVATE; 

SUBTYPE Year-number IS Integer RANGE 1901..2099; 

SUBTYPE Month-number IS Integer RANGE 1..12; 

SUBTYPE Day-number IS Integer RANGE 1..31; 

SUBTYPE Day-duration IS Duration RANGE 0.0..86-400.0; 

FUNCTION clock RETURN Time; 

FUNCTION year(date: Time) RETURN Year-number; 

FUNCTION month(date: Time) RETURN Month-number; 

FUNCTION day(date: Time) RETURN Day-number; 

FUNCTION seconds(date: Time) RETURN Day-duration; 

PROCEDURE split(date: IN Time; 

year: OUT Year-number; 
month: OUT Month-number; 
day: OUT Day-number; 
seconds: OUT Day-duration); 

FUNCTION time-o£(year: Year-number; 

month: Month-number; 
day: Day-number; 

seconds: Day-duration :* 0.0) RETURN Time; 

FUNCTION "+" (left: Time; 

right: Duration) RETURN Time; 

FUNCTION (left; Duration; 

right: Time) RETURN Time; 

FUNCTION (left: Time; 

right: Duration) RETURN Time; 

FUNCTION (left: Time; 

right: Time) RETURN Duration; 

FUNCTION '*<" (left,right: Time) RETURN Boolean; 

FUNCTION (left,right: Time) RETURN Boolean; 

FUNCTION ">” (left,right: Time) RETURN Boolean; 

FUNCTION (left,right: Time) RETURN Boolean; 

PROCEDURE set-time(year : IN Year-number; 

month : IN Month-number; 

day : IN Day-number; 

seconds : IN Day-duration); 

TIME-ERROR: Exception; — ...can be raised by 

— tirae-of , "+" and . 

PRIVATE 


END calendar; 









0 


DACS 6IOrO B«e Ada Gnts Cocapikr Syiaem - User’s Guide 
bnplemenuttkMi Dq^ndem Ouncteristics 


F.IO Machine Code Insertions 

Machine code insertions are allowed using the instructions defined in package MACHINE-CODE. 
All arguments given in the code statement aggregate must be static. 

The madiitK lar^uage defined in package MACHINE-CODE is not 680x0 assembler, but rather 
Abstract A-code which is an intermediate language used by the compiler. 


200 







