AD-A246 081 


T 


JTGRADUATE SCHOOL 
Monterey, California 




DTIC 



ELECTE 
FEB 2 01992 





THESIS 


A REUSABLE COMPONENT RETRIEVAL SYSTEM 

FOR 

PROTOTYPING 

by 


John Kelly McDowell 


September 1991 

Thesis Advisor: 

Dr. Luqi 


Approved for public release; distribution is unlimited. 



92 2 12 


157 








REPORT DOCUMENTATION PAGE 


UNCLASSIFIED 







Approved for public release; 
distribution is unlimited 





puter science uept. 
il Postgraduate School 


DRESS (City. State, and ZIP Code) 

terey, CA 93943-5000 


(if applicable) 

cs 


Naval Postgraduate School 


7b. ADDRESS (City. State, and ZIP Code) 

Monterey, CA 93943-5C)00 


!▼. I :ff •! H ^ 11 ^ I 11 :/•! : t [< 




(if applicable) 


CCR-9058453 




wmmm 


IGANIZATION 

Dnal Science Foundation 


IDRESS (City, State, and ZIP Code) 

IG Street, N.W. 
hington, D.C., 20550 


TLE (Include Security Classification) 

EUSABLE COMPONENT RETRIEVAL SYSTEM FOR PROTOTYPING 



i U:iaa«i;u 

im 


14. DATE OF REPORT (Year, Month. Day) 

September 19^ 


e views expressed in tnis thesis are those or the author and do not rerlect the otticial 
:y or position of the Department of Defense or the United States Government. 


COSATI CODES 


GROUP 


SUB-GROUP 



18. SUBJECT TERMS (Continue on reverse if necessary and identify by block number) 

Reusable Software Components, Rapid lYototyping 


)STRACT (Continue on reverse if necessary and identify by block number) 

Prototyping is an important software development method to rapidly construct software, validate and refine requiremcn i, and check 
insistency of proposed software designs. This thesis describes the design and implementation of a CASE tool to be used in conjunction 
the Computer Aided Prototyping System (CAPS) which retrieves and prepares reusable components for use in PSDL (Proiot>pc System 
ription Language) prototypes. Reusable components and their PSDL specifications are stored in a software base. 

Components can be retrieved from the software base via its Object-Oriented Data Base Management System (OODBMS) using PSDL 
mulate queries. All of the PSDL specifications for the reusable components are normalized and stored in the software base to support 
ent search based on a given query PSDL specification for a software component. The search process is based on both syntactic and 
ntic matches between the query and stored components. 

Our software base has been designed to be easily configured to support storage and retrieval of reusable components m any 
amming language with the initial configuration for Ada components. 

A window based user interface was also implemented to allow easy access to the software base via the CAPS user interlace a.N ccell xs 
alone use. 































Approved for public release; distribution is unlimited 

A Reusable Component Retrieval System for 

Prototyping 


John Kelly McDowell 

Lieutenant, United States Navy > 

Submitted in partial fulfillment of the 
requirements for the degree of 


MASTER OF SCIENCE IN COMPUTER SCIENCE 


Author: 

Approved By: 


from the 

NAVAL POSTGRADUATE SCHOOL 



Robert B. McGhee, Chairman, 
Department of Computer Science 


I 

t 


11 






ABSTRACT 


Prototyping is an important software development method to rapidly construct 
software, validate and refine requirements, and check the consistency of proposed 
software designs. This thesis describes the design and implementation of a CASE 
tool to be used in conjunction with the Computer Aided Prototyping System (CAPS) 
which retrieves and prepares reusable components for use in PSDL (Prototype 
System Description Language) prototypes. Reusable components and their PSDL 
specifications are stored in an software base. 

Components can be retrieved from the software base via its Object-Oriented 
Data Base Management System (OODBMS) using PSDL to formulate queries. All 
of the PSDL specifications for the reusable components are normalized and stored 
in the software base to support efficient search based on a given query PSDL 
specification for a software component. The search process is based on both 
syntactic and semantic matches between the query and stored components. 

Our software base has been designed to be easily configured to support 
storage and retrieval of reusable components in any programming language with 
the initial configuration for Ada components. 

A window based user interface was also implemented to allow easy access to 
the software base via the CAPS user interface as well as stand alone use. 



TABLE OF CONTENTS 


I. INTRODUCTION.1 

A. THE SOFTWARE CRISIS.2 

B. STRUCTURED ANALYSIS.3 

C. RAPID PROTOTYPING.6 

D. THE COMPUTER AIDED PROTOTYPING SYSTEM (CAPS).... 8 

E. GOALS OF THIS THESIS.9 

II. REUSABLE COMPONENT LIBRARIES.10 

A. RETRIEVAL METHODS .11 

1. Browsers.11 

2. Informal Specifications.12 

B. KEYWORD SEARCH.12 

C. MULTI-ATTRIBUTE SEARCH.13 

1. Natural Language Interfaces.14 

2. Formal Specification.14 

D. REVIEW OF CURRENT SYSTEMS.15 

1. Draco.15 

2. Rapid.16 

3. Operation Support System.17 

4. The Reusable Software Library.17 

5. Common Ada Missile Packages.18 

6. Software Reuse At Hewlett-Packard. 19 

III. CAPS AND PSDL.20 

A. USING CAPS TO BUILD EXECUTABLE PROTOTYPES. 20 

B. USING REUSABLE COMPONENTS IN CAPS.23 


f 


i 


IV 




























IV. SOFTWARE BASE IMPLEMENTATION.25 

A. REQUIREMENTS.25 

B. ONTOS DATABASE MANAGEMENT SYSTEM.26 

C. SEGREGATION OF REUSABLE COMPONENT DOMAINS ... 29 

D. STORAGE OF UNCONSTRAINED TEXT OBJECTS.30 

E. BROWSING THE SOFTWARE BASE.32 

1. Named Look Up Of Components.33 

2. Keyword Queiying.33 

F. QUERY BY SPECIFICATION.35 

1. Syntactic Matching.38 

2. Operator Component Library.41 

3. Abstract Data Type Library.42 

G. DATA STREAM TYPE MATCHING.44 

H. ABSTRACT REPRESENTATION OF SOFTWARE BASE.46 

COMPONENTS 

I. INTEGRATING RETRIEVED COMPONENTS INTO CAPS. ... 48 

J. SOFTWARE BASE INTERFACE.51 

1. Command Line Interface.51 

2. Graphical User Interface.52 

V. CONCLUSIONS AND FUTURE RESEARCH.53 

A. ADDING COMPONENTS TO THE SOFTWARE BASE.53 

1. Component Testing.53 

2. Component Implementation Restrictions.53 

3. Writing Formal Specifications Of Existing Components .... 54 

B. DELETING AND UPDATING COMPONENTS.54 

C. EFFICIENCY.55 

D. SOFTWARE BASE SYSTEM IMPLEMENTATION LANGUAGE. 55 

LIST OF REFERENCES.57 




























APPENDIX A- USING PSDL TO SPECIFY REUSABLE.60 

COMPONENTS 

APPENDIX B • C++ SOURCE CODE FOR SOFTWARE BASE ... 69 

APPENDIX C- PARSER GENERATION INPUT FILES.210 

APPENDIX D- INTEGRATING ADA COMPONENTS INTO . . . .228 

CAPS 

APPENDIX E - COMMAND LINE INTERFACE.238 , 

SPECIFICATION 

APPENDIX F- SOFTWARE BASE GRAPHICAL USER.246 

INTERFACE MANUAL 

APPENDIX G- SOFTWARE BASE GRAPHICAL USER.259 

INTERFACE SOURCE CODE 

BIBLIOGRAPHY.326 

INITIAL DISTRIBUTION LIST.327 


t 


A 


VI 












ACKNOWLEDGEMENT 


I would like to thank Professor Luqi and Professor Berzins for all of their support 
throughout this project. Their words of wisdom and encouragement got me through 
those difficult periods when this project seemed hopeless. 

I thank Albert Wong and the rest of the NPS Computer Science Department 
technical staff for supporting my software needs throughout the past two years. 

I would also like to thank Captain Robert Steigerwald, U.S. Air Force, for all of his 
assistance in the completion of the project and in the preparation of this thesis. 

A very special thank you to my wife Naida and two sons, Jonathan and Brandon. 
Without their sacrifice over the past two years, I could not have completed this research. 


Accesion For 

NTIS CRA&I 
DTIC TAB 
U:.a'-:OLii.ced 
Justification 


By. 

Di.'t ibi'tionf 

Availability 


□ 

□ 


Codec 


Dist 


A(Vdi‘ a-.d|or 
special 









1. INTRODUCTION 


This thesis addresses the issues related to the design and implementation of an 
automated reusable software component retrieval system. The purpose of the system is 
to support the Computer Aided Prototyping System (CAPS) [Ref 1]. CAPS is an 
ongoing software engineering research project at the Naval Postgraduate School. The 
reusable component retrieval system is a critical component in the CAPS tool set. 

This chapter provides an introduction to computer aided prototyping and the need 
for automated retrieval of software components. Chapter 11 details the current state of 
the art in component reuse and reusable component libraries. Chapter FV is an overview 
of CAPS and its specification language. Prototyping System Description Language 
(PSDL), used for specifying reusable components. Chapter IV presents the design and 
implementation of the software base for CAPS. Chapter V contains the conclusions of 
this research and recommendations for future research. Appendix A details the usage of 
PSDL to specify reusable components. Appendix B contains the source code for the 
software base system. Appendix C is the source code for the generation of the PSDL 
parser. Appendix D presents an example of how to integrate reusable Ada components 
into a CAPS prototype. Appendix E provides the specification for the software base 
command line interface. Appendix F is a users manual for the software base graphical 
user interface. Appendix G is the source code for the software base graphical user 
interface. 


1 





A. THE SOFTWARE CRISIS 


Creating software for hard real-time and embedded computer systems is a complex 
process. The complexity of this task has created a situation where the demand for these 
systems currently exceeds the ability of the software industry to develop them. 

The United States Department of Defense (DOD) is the world’s largest user of 
embedded computer systems. In the mid 1970's the gap between the growing demand for 
high quality software and industry’s inability to meet that demand caused the DOD to 
investigate potential solutions to the problem. The DOD concluded that the problems 
"...appear in the form of software that is non-responsive to user needs, unreliable, 
excessively expensive, untimely, inflexible, difficult to maintain, and not reusable." 
[Ref.2:p41] 

One of the results of this investigation was the development of tne Ada programing 
language. Although Ada provides some capabilities to overcome the shortcomings noted 
by the DOD additional software tools are still required if the software gap is to be closed. 
These tools are especially needed in the areas of requirements analysis and refinement, 
software validation, and software testing. The design and implementation of tools in 
these areas continues to be a major focus of software engineering research. 


2 




B. STRUCTURED ANALYSIS 


A widely used design methodology that attempted to address the issues in software 
development is Structured Analysis [Ref 3:p78]. Structured analysis breaks the creation 
of software systems into distinct areas or steps, which is essentially a variation of the 
"waterfall" model in DOD-STD-2167A [Ref 4:pl0]. 

Its first step is requirements analysis. During this step the actual needs and external 
interfaces of the system are identified and recorded. The second step is functional 
specification of the system. Functional specification uses the requirements from the first 
step to specify the proposed external functionality of the software system. The third step 
in structured analysis is system design. During the design step the internal aspects of the 
system are specified. This design is then used in the fourth step, which is system 
implementation. After the system has been implemented the system is tested and 
delivered. After initial system delivery the software enters its maintenance phase. 
Maintenance of the system follows the same basic approach with each change going 
through requirements analysis, design, and finally implementation. 

If at any time during this approach an inconsistency is identified the process reverts 
back to the appropriate step to correct the problem. This method of software 
development has been called the "waterfall approach" because the system goes from one 
step to the other as though going down a waterfall. Figure 1 is a graphic representation 
of classical structured analysis. 


3 




Rguro 1 - Classical Struclured Analysis 

This approach has been modified [Ref 3] to make the steps in the model less distinct 
and allow more parallel effort. The steps were made less distinct because in practice it 
was found that information discovered in later steps sometimes required earlier steps to 
be modified. The ability to complete steps in parallel is possible because some functions 
lower in the cycle can be performed while higher level items are being completed. This 
parallel activity can greatly enhance the efficiency of the overall effort and allows for 
more feedback between steps. 

In order for this approach to work there must be a means of communicating the 
results of each step other than plain English. This is because English prose can be 
amibiguos and if is very difficult to verify the consistancy of a written document. 


4 










Several representations were developed in order to convey this information. These 
representations include Data Flow Diagrams (DFD's), Context Diagrams (CD's), Entity 
Relationship Diagrams (E/R Diagrams), State Transition Diagrams (STD's), and Data 
Dictionaries (DD). These representations make it possible for the developers to 
communicate with each other the behavior of a proposed system. 

One of the deficiencies of structured analysis is that the English prose used to 
describe portions of the requirements of the system often is not precise enough to define 
critical subsystems. This is very important where failure of a real-time or embedded 
system to meet a given requirement could result in injury or death. Most military 
software systems and medical systems fall into this category because failure can result in 
life threatening circumstances. 

Several high level specification languages have been developed to solve these 
problems. These languages support formal specifications of critical portions of the 
system. From these formal specifications the system can be verified to achieve the 
required functionality. One such specification language is SPEC [Ref 5: p82]. SPEC 
can be used to rigorously specify critical sections to avoid ambiguity. 

Communication between a software development team and the system's end users is 
difficult using structured analysis. This communication is vital since in most cases the 
software development team is unfamiliar with the domain of the proposed system while 
the domain experts (end users) are unfamiliar with many of the representations used in 
the development of the software system. 


5 





Although DFD's, CD's, E/'R diagrams, STD's, DD's, and formal specification 
languages are very useful for communication between software engineers, many end 
users are unfamiliar and/or uncomfortable with them. This results in potential mistakes 
or misconceptions between the developers and the users in the early stages of a project 

i 

that can go undetected until the first executable version of the system has been 

* 

completed. The development of this first executable version of a system can consume so 
much of a projects allotted development time or budget that it may be too late or costly 
to make any major modifications. This results in the end user being forced to accept a 
system that does not meet their original expectations. 

C. RAPID PROTOTYPING 

One promising area of software engineering research that addresses this problem is 
rapid prototyping [Ref 6]. A prototype is an executable model of a proposed software 
system, usually including a software simulation of the system’s hardware external 
interfaces. The prototype accurately reflects chosen aspects of the system including 
display formats, correctness of computations, and real-time constraints. 

Prototyping attempts to solve the communications problem by rapidly developing a 
prototype of the proposed system from available information and then using that 
prototype to communicate to the user[Ref 7]. The executable prototype presents a view > 

of the system that the user is most familiar with. This allows the user to provide 
feedback to the design team that can be used to update the prototype. This feedback 


6 




process continues until the user is satisfied that the prototype accurately describes the 
needs of the system. At this point the prototype system itself acts as one of specification 
tools for the final system. 

There are two problem areas in the acceptance of prototyping as the preferred 
software development technique. The first is that the process of creating and modifying 
prototypes must be rapid enough to avoid the same resource consumption pitfalls of 
classical structured analysis. The second difficulty is that typically prototype systems are 
used only as a guideline for the final system. Yourdon states "when the modeling is 
finished, the programs will be thrown away and replaced with REAL programs." 

[Ref 3:p98] If all of the prototype system is completely discarded it becomes 
questionable as to how effective the prototyping approach is at reducing software system 
development cost and time. 

Without addressing these two issues prototyping could actually increase the overall 
development time and cost of the system as compared to structured analysis. Clearly to 
fulfill the promise of rapid prototyping it is necessary to overcome these difficulties. 

The solution to the first problem is the development of computer aided prototyping 
systems that enable the rapid development of executable prototypes. To achieve this 
rapid evolution of executable prototypes it is necessary to achieve a very high rate of 
code reuse instead of creating the entire prototype from scratch [Ref 8]. The solution to 
the second problem is to implement the prototype with code of sufficient quality that 


7 




only those modules that require performance enhancements need be re-implemented to 
produce the final system. 

With this in mind it is clear that for rapid prototyping to be of maximum benefit, 
reusable component libraries containing many high quality components coupled with 
powerful query techniques to identify components for reuse are mandatory. The 
remainder of this thesis discusses CAPS and the development of a reusable component 
software base that fulfills these requirements. 

D. THE COMPUTER AIDED PROTOTYPING SYSTEM (CAPS) 

The Computer Aided Prototyping system is designed as a rapid prototyping system 
for hard real-time systems. CAPS prototypes a system through translation of the high 
level specification language Prototyping System Description Language (PSDL) into Ada 
code along with the incorporation of atomic Ada reusable components [Ref 9J. The 
concept of using both specification translation and atomic component composition makes 
CAPS a unique prototyping tool. PSDL is unique in that it provides a rich set of 
real-time constraints to enable the prototyping of hard real-time systems, and automatic 
translation of these timing constraints into Ada tasking information. 

The use of composition of atomic components allows for the use of high quality 
reusable Ada components to provide the majority of the code to implement the prototype. 
PSDL is used to specify the interface and functionality of the atomic components to 
make automated searches of a reusable component library feasible. 


8 






The software base subsystem of CAPS has been designed to allow the user to create 
a PSDL specification of a necessary component and then perform an automated search 
of the library for preexisting candidate implementations of the specification. Automation 
of the search of the software base is critical because the software base must be able to 
grow indefinitely without significantly degrading the users ability to locate components 
for reuse. As the software base grows larger fewer components will need to be manually 
coded, thus achieving a system that provides greater power with time. 

E. GOALS OF THIS THESIS 

The goal of this thesis is to describe the design and implementation of a software 
base system for the CAPS prototyping environment. The theoretical foundations for 
component matching, the development of algorithms to take advantage of these concepts, 
the design of a database structure that enables the efficient implementation of the entire 
system, and a description of how to obtain the maximum benefit of using this system are 
discussed. 


9 



II. REUSABLE COMPONENT LIBRARIES 

As the gap between the demand for software systems and the software industry’s 
ability to meet it became obvious, so did the need to reuse existing software components. 
Many retrieval systems have been proposed and implemented that address this issue. 
Several of these systems are discussed in this section. 

In order to compare and contrast these retrieval systems it is necessary to develop a 
metric by which the systems can be evaluated. How well an information system 
performs is based on the nature of the objects that are returned for a given query. The 
two most useful measures of performance for a retrieval system are precision and recall 
[Ref lOJ. Precision is defined as the ratio between the number of relevant components 
retrieved and the total number of components retrieved. Recall is defined as the ratio 
between the number of relevant components retrieved and the number of relevant 
components in the database. Precision and recall are both maximal when they equal 1. 

There is a tradeoff between precision and recall. It is easy to have a system 
maximize one but not the other. If the system returns all objects in the database than 
recall will always be 1 but precision will be very low. On the other hand if a query only 
yields one relevant component than precision would be 1 but recall would be low. 

In order to obtain maximum reuse of existing software components in a given 
collection of components, queries on that collection should have a recall value of 1. 
Without a recall of 1, components that could be reused will be missed. The system also 


10 




needs a high degree of precision because it is possible to spend more time manually 
searching through the results of a component query with low precision than it would take 
to implement the component manually. 

A. RETRIEVAL METHODS 

Almost all of the tools developed to assist in reusing software components use one 
(or more) of three different approaches for retrieval of components; browsers, informal 
specifications, or formal specifications. For this reason a general overview of these 
retrieval methods is presented followed by a discussion of some existing tools that use 
these methods. 

1. Browsers 

A browser is a tool for looking through a collection of software components. 
The interface for a browser can range from simple text through complex graphical user 
interfaces. The goal of all such systems is to allow the user to direct a search through the 
available components. 

The advantage of a browsing system is that the user is given complete control 
over the retrieval process. This can be important for users who are familiar with the 
content of the software collection and want the ability to quickly traverse the structure of 
the collection to find components that they know are in the collection. 

The first disadvantage of the system is that it has very low precision. The user 
may have to look at all of the components to find the one that is desired. Because of the 


11 





manual nature of the search, as the software collection grows the time the user spends 
browsing also increases. 

The second disadvantage of browsing is that the system relies on the users 
knowledge of the structure of software collection. Without such knowledge a user will 
have difficulty in directing a search to retrieve a desired reusable component. 

The third disadvantage of this type of a system is that unless the user finds 
exactly what they are searching for, there is no clear termination point for the search until 
every component has been reviewed. 

2. Informal Specifications 

This technique requires the user to describe or list some attributes of the 
component that they are looking for. This informal description is then used to direct the 
user to the appropriate components. Examples of some common attributes are keywords 
and natural language interfaces. 

B. KEYWORD SEARCH 

A keyword searching mechanism requires the user to specify a list of 
words relevant to the component being sought. The keywords the user chooses can be 
drawn from a known system vocabulary (controlled vocabulary) or they can be 
unconstrained (uncontrolled vocabulary). In the case of uncontrolled vocabulary 
synonym tables are often used to normalize the keyword selections into a known 
vocabulary. 


12 






The advantage of the keyword query is that it is conceptually simple and 
reduces the number of components that the user must review. Because of this simplicity 
many of the software component retrieval mechanisms reviewed in the next section 
employ some aspects of this technique. 

There are two basic disadvantages to this approach. The first one is that 
the precision and recall of the system depend on how many keywords are used for the 
query. Using only one keyword typically will result in a very large number of 
components (high recall, low precision). Using too many keywords could miss possible 
candidate components (high precision, low recall). 

The second disadvantage is that the user must be familiar with the 
structure of the keyword categories that are being used by the collection administrator to 
achieve maximum benefit form the system. Without such knowledge a user can easily 
miss potential candidates that match their needs. 

C. MULTI-ATTRIBUTE SEARCH 

A multi-attribute search is really just an extension of the keyword 
concept. Instead of using only keywords for forming a query, other attributes of the 
search component can be used as well. These attributes includes the class of component 
(procedure, function, package, etc.), the number and type of parameters used, its domain 
of use, etc. 


13 





Tlie advantage of this type of system is that by using more than just 
keywords the search can be more selective. All of the attributes taken together make up 


a classification scheme that provides more information than keywords alone. 

The disadvantage to this type of system is that the collection 
administrator must identify the attributes for stored components and the user must 
identify the attributes of the component that is desired. If the user succeeds in filling in 
the same attribute values as the administrator will a query be successful, otherwise the 
query mechanism must be capable of identifying when two attributes are "close" to being 
the same. 

1. Natural Language Interfaces 

Natural language interfaces for information retrieval is a growing field of 
computer science research. An advantage of this system is the ease in which a user 
describes a desired component. 

The difficulty in this approach is that due to the broad semantics of the English 
language, implementation of these systems have had to constrain the language used to 
form a query. As the number of constraints on the query language grows the system 
begins to be more like a multi-attribute system. 

2. Formal Specifications 

The use of formal specifications to direct a reusable component query can be 
very beneficial. Because specifications systems such as SPEC and OBJ3 [Ref 11] are 
based on predicate calculus they are free from ambiguity. This means that formal 


14 




specifications can be transformed into normal representations without changing their 
meaning using logic and term rewriting rules. 

Matching of specifications allows queries that achieve both high precision 
(formal specifications enable conclusive demonstrations that particular components do 
meet the requirements in a query) and high recall (through term rewriting it is possible to 
allow candidates with appropriate functionality to be located even if the author of the 
component did not anticipate the components being utilized in this context). 

The primary disadvantage of this approach is that writing formal specifications 
for components is difficult and requires software engineers with advanced skills. 
Another disadvantage is that automated matching of formal specifications can be time 
consuming. 

D. REVIEW OF CURRENT SYSTEMS 

1. Draco 

The Draco project was bom in the early 1980's at the University of California, 
Irvine. The Draco approach to software reuse is essentially a multi-attribute query 
system. Software components are organized into problem areas or domains. Queries are 
constructed by the formulation of a tuple of attributes that best characterizes a particular 
domain. Each domain uses a different set of attributes for its queries. This type of 
classification of components has been called faceted classification [Ref 12]. 


15 





In evaluating the effectiveness of faceted classificaiion Draco researchers 
compared it to a system using no classification scheme. Using faceted classification the 
number of components retrieved was reduced by more than 50% yet the precision of the 
queries was 100%. 

The advantages of faceted classification are that it is conceptually simple for 
users and relatively easy to implement. Because of this, the concept has been borrowed 
to implement the retrieval methods in both RAPID and OSS (See sections B.2 and B.3). 

One of the disadvantages of this type of system is that semantically similar 
components may be missed because there attribute definitions are different. Draco 
addresses this issue by maintaining a measure of conceptual closeness for the term lists of 
each attribute. This allows unsuccessful searches to be tried again using an alternate but 
similar term for one of its attributes. 

Another disadvantage of this system is that components in other domains that 
may be useful are easily missed. This puts the burden on the user to ensure that they 
have selected an appropriate domain for their search. 

2. Rapid 

The RAPID (Reusable Ada Packages for Information System Development) 
project is an ongoing effort in the Department of Defense. The objective of RAPID is to 
provide software engineers with quick access to reusable Ada packages in the 
information systems domain. The system performs reusable component classification, 
storage and retrieval. 


16 





RAPID uses a faceted classification scheme to organize and retrieve 
components and thus uses multi-attribute searches [Ref 13]. The system is currently 
being beta tested but no measures of performance or quality assessments are available 
yet. 

3. Operation Support System 

The Operation Support System (OSS) is an ongoing project aimed at 
developing an integrated software engineering environment. The system is being 
developed at the Naval Ocean Systems Center. One of the goals of the project is to 
establish a Naval software library of reusable software components. 

The current prototype library subsystem allows for component retrieval using 
faceted classification (See section B.l), keywords, or simple textual browsing. The 
components currently stored in the library are for command, control, and 
communications and intelligence (CH) systems. Due to the early stages of this project no 
information is available on the performance characteristics of the system. 

4. The Reusable Software Library 

The Reusable Software Library is a system design by Intermetrics to make 
software reuse an integral part of the software development process Components in this 
system are stored in a database with attribute values that provide the basis for a search. 
There are two methods available to search for a component. These methods are based on 
multi-attribute and natural language searches. 


17 



The multi-attribute search provides a menu driven system in which the user 
selects the attributes desired for the search. Alteratively the user may express the query 
in a natural language form such as "I want a stack package for Integers." The system 
parses this natural language input for keywords and forms a multi-attribute query from it. 

The designers of the system report [Ref 14] that the natural language front end 
is considerably easier to use but the search speed is significantly slower. No additional 
measures of performance were provided. 

5. Common Ada Missile Packages 

The Common Ada Missile Packages (CAMP) project is an effort sponsored by 
the Department of Defense to create a software engineering system and reusable software 
library of components. The system is directed toward software for missile systems and 
uses Ada as the source language for its reusable components. 

The main pan of the reusable component system is the Parts Engineering 
System (PES) catalog. The PES catalog is similar to a card catalog for books. The 
catalog system, used by both software engineers and domain engineers, is written in Ada 
and provides a menu driven intenace for storing, modifying, and retrieving components 
(parts). Queries to this system are of the multi-attribute type. 

Users select a set of attributes to search for from a predetermined finite list of 
values. The system then queries on each of these attributes one at a time. The results of * 

these queries can be chained together to achieve a multi-attribute query. The CAMP 
documentation [Ref 15] does not assess the performance of the FES Catalog system. 


18 




6. Software Reuse At Hewlett-Packard 

Hewlett-Packard recognizes the need to make software reuse an integral part 
of the software development process [Ref 16]. A reusable component retrieval system is 
currently under development to help achieve this goal. The system will have a hyper-text 

K 

browsing facility as well as using informal specifications to locate reusable components. 

j 


19 







III. CAPS AND PSDL 


The Computer Aided Prototyping System (CAPS), with its accompanying 
specification language the Prototyping System Description Language (PSDL), is an 
ongoing software engineering project in the Naval Postgraduate School computer science 
department. CAPS is a set of software tools designed to automate the process of 
prototyping real-time software systems [Ref 17]. 

A. USING CAPS TO BUILD EXECUTABLE PROTOTYPES 

The basic building blocks for a prototype in CAPS are operators, types, and 
streams. The software system being prototyped is modeled as an OPERATOR whose 
input and output streams correspond to the external interfaces of the system. For 
prototyping purposes, CAPS uses operators for software simulation of external entities as 
well. Based on this, the top level Data Flow Diagram (DFD) for the prototyped system is 
composed of an operator that represents the proposed system itself, one operator for each 
external entity, and the external data streams in and out of the proposed system. This top 
level DFD is the decomposition of a single operator that represents a closed system 
composed of the proposed software and all external systems that interact with the 
software. Figure 2 is an example of a top level DFD for a prototyped software system. 


20 







Figure - 2 CAPS Top Level DFD For Robot Prototype 

CAPS prototypes are expressed in the Prototyping System Description Language 
(PSDL). PSDL is based on a graph model for real-time system: 

G=(V,E,T(V),C(V)) 

where G is the graph that represents a prototype, V is the set of vertices in the graph 
where each vertex represents an operator in the prototype, E is the set of directed edges 
in the graph where each edge represents a data stream, T(V) is the set of timing 
constraints that are imposed on the vertex set V, and C(V) is the set of control constraints 
placed on the vertex set V [Ref. 18]. 

Decomposition of a prototype is achieved by implementing each of its composite 
operators with a graph. Each new graph G’ is a more detailed representation of one of 


21 

















the nodes in its parent graph G. Decomposition of operators continues in this fashion 
until each operator has been fully decomposed. 

In order to make a prototype specified in PSDL executable, it is necessary to 
provide programming language implementations for all leaf operators. The current 
version of CAPS requires that all leaf operators be implemented in the Ada programming 
language. Future versions of CAPS will be capable of supporting other programming 
languages as well. 

Each data stream in CAPS carries an instance of an abstract data type. The abstract 
data type for each stream is defined as a PSDL TYPE component. This definition 
includes all of the OPERATORS that can operate on that data type. A PSDL type's 
operators can also be graphically decomposed in the same manner as a prototype's 
operators. To make a prototype executable, ail of the PSDL type's leaf operators must 
be implemented in Ada. 

In the current version of CAPS the designer uses a graphical editor to design and 
decompose the prototype's operators [Ref 19]. Future versions of CAPS will also allow 
for graphical design of abstract data types. 

By specifying prototypes in this manner CAPS can rapidly build an executable 
real-time prototype for user validation. Any deficiencies that the validation process 
identifies can be applied to the prototype and a new executable generated. This process 
can be repeated until the prototype meets all of the users needs. 


22 





B. USING REUSABLE COMPONENTS IN CAPS 


To achieve maximum benefit as a rapid prototyping system it is necessary for CAPS 
to achieve a high rate of component reuse in the implementation of leaf operators. The 
software base described in this thesis has been designed to support this goal. 

After the user has specified a needed operator or type, they have the opportunity to 
use that specification as a query to the software base to look for a potential match. If one 
is found it can be included in the prototype. If not the user has the choice of 
decomposing the component further or implementing the component manually. 

In addition to automatic component retrieval facilities, the software base contains a 
keyword browsing feature to assist the designer in finding components in the software 
base to be used for manual implementation. 

PSDL "was designed to serve as an executable prototyping language at the 
specification and design level." [Ref 17, p26] The grammar for the PSDL interface 
specification is not biased toward a particular programming language but rather is 
general enough to allow it to be extended to support any programming language. 

Because of this general design it is necessary to add some pre-defined abstract data 
types with specific interpretations related to software reuse to PSDL (not the grammar 
itself), in order to adequately specify a component for automated retrieval. These 
extensions include a methodology for describing type inheritance and distinguishing 


23 




between different types of generic parameters. A description of how PSDL was extended 
to support reusable components in Ada is included in Appendix A, 


24 






IV. SOFTWARE BASE IMPLEMENTATION 


A. REQUIREMENTS 

The CAPS software base must perform four basic tasks [Ref 20]. Figure 3 depicts 
these tasks. Text file storage is a mechanism to store and retrieve portions of a reusable 
component. Component browsing refers to giving the user the ability to locate and view 
components in a manner other than by PSDL query. The ability to query the software 
base by PSDL specification gives the system the retrieval characteristics desired in this 
prototyping system. Component integration into CAPS is required once a reusable 
component is located so that the execution support system can produce an executable 
prototype. 



Figure 3 - Requirements for CAPS Software Bose 


25 






Due to the complexity of storing variable length source code and querying the 
software base using PSDL specifications, a powerful DBMS system is necessary [Ref 
21]. CAPS is designed to exist in a multi-user networiced environment, therefore the 
DBMS system also needs to support multi-user, networked access to its data. 

Section B of this chapter is a description of the DBMS system that was used to 
implement the CAPS software base. Section C describes the segregation of reusable 
components into language domain areas. Section D is a description of the method used 
to store text files in the database. Section E is a description of the implementation of the 
software base browsing facilities. Sections F through H describe the implementation of 
the query by specification function of the software base. Section I discusses the 
requirements for integration of components into CAPS prototypes. Section J describes a 
prototype graphical user interface for the CAPS software base. 

B. ONTOS DATABASE MANAGEMENT SYSTEM 

The Ontos database management system [Ref 22] is one of a growing number of 
Object-Oriented Database Management Systems (OODBMS). It was selected for use in 
the software base project because it has sufficient capabilities to handle the requirements 
for the implementation of an advanced reusable software component library. 

The Ontos OODBMS is not constrained by a particular data model such as 
relational or hierarchical systems, but rather allows the database developer the ability to 
make any data object persist past the execution of the program that created it. 


26 






Persistence of objects is accomplished by assigning each object a system generated 
unique identifier (UID), and providing methods to store and retrieve each type of object. 

The Ontos system uses C++ [Ref 23] as its implementation and application 
language. The database developer defines the database schema using C++ class 
definitions and the Ontos Classify utility. These classes are then implemented using 
standard C++. 

In Ontos all that is needed to make an instance of a particular class persistent is to 
have that class inherit from the Ontos-defined class Object. The Object class construcior 
assigns each object a UID. The methods necessary for reading and writing instances of a 
persistent class are defined by the Object class, and thus inherited by all instances of 
persistent classes. The reading and writing of persistent objects is transparent to the 
application. 

Ontos includes a set of persistent aggregate classes in order to efficiently handle 
collections of persistent objects. These aggregate classes include List, Set, Array, and 
Dictionary. 

The List class provides functionality analogous to a linked list data structure. The 
Set class implements the standard concept of a set and its associated operations. The 
Array class implements the programing language concept of a dynamically sizable array 
structure. 

The Dictionary class is the most robust of all Ontos aggregate classes. It is a keyed 
data structure that can be ordered or unordered. For every entry in a Dictionary there are 


27 





two attributes stored, the Tag and the Element. The Tag is used for indexed look up and 
the Element holds the desired data. Dictionaries can be defined with or without duplicate 
Tags being allowed. The implementation of these structures is very efficient. 
Dictionaries that are unordered and do not allow duplicates are implemented via hash 
tables. All other Dictionaries are implemented as B-tree's. Figure 4 shows the 
inheritance relationship between the pre-defined Ontos aggregate classes. 



Figure 4 - Ontos Aggregate Inheritance Structure 


Using aggregate classes the designer can define a database architecture that best 
suits the needs of the application rather than modifying the application's structure to fit a 
particular database model. Using the transparent referencing of the database and 


28 







1 


aggregate data structures, the developer designs the application as though all data is 
immediately available when referenced in a program. 

While this type of DBMS may be difficult to use where general ad-hoc query 
capabilities are desired, it is ideal for the development of software tools where the nature 
of the queries to be issued are known well in advance and the database schema must be 
designed to support them efficiently. 

C. SEGREGATION OF REUSABLE COMPONENT DOMAINS 

The CAPS software base is designed as a general purpose tool capable of storing 
components implemented in many programming languages. Because of differences in 
the capabilities of each programing language there are differences in the way the 
pre-defined abstract data types used in PSDL to specify components are interpreted by 
the software base. An example of this is that the char type in C++ is a subset of the type 
int while in Ada character is a system defined enumerated type. These differences in the 
interpretation of PSDL specifications require that all components of a particular 
implementation language be considered in a unique domain. 

It is also possible to create multiple component domains for a given implementation 
language. This allows segregation of components into major problem areas such as 
information systems and control systems. 

Each domain in the software base is referred to as a library and is an instance of the 
class SB_LIBRARY. The class SB_LIBRARY inherits from the Ontos class Object and 


29 





thus its members are persistent objects. Each instance of SB_LIBRARY is composed of 
five parts: a component dictionary, a keyword library, an operator library, an abstract 
data type library, and a recognized type matrix. 

The component dictionary is used to ensure that duplicate component names are not 
used within a particular library. The keyword library provides the ability to formulate 
and process keyword queries on the domain library. The operator and abstract data type 
libraries are used for the query by PSDL specification and are discussed in more detail in 
sections F.2 and F.3. The recognized type matrix contains the type name matching 
information for this library domain and is discussed in section G. 

The specification and implementation for the class SB_LIBRARY are in Appendix 
B. Figure 5 is an attribute diagram for the class SB_LIBRARY. The symbols used in 
this attribute diagram are the same as those used in Entity / Relationship Diagrams. 
Single ovals represent attributes of an object. Concentric ovals indicate a multi-valued 
attribute (Ontos Dictionary). The attributes shown for multi-valued objects are the 
contents of a single instance contained in that multi-valued object. Underlined attributes 
are the key or tag field of a multi-valued attribute (Ontos Dictionary). 

D. STORAGE OF UNCONSTRAINED TEXT OBJECTS 

In a typical development environment, program source files are stored in the 
operating system's directory structure as text files. This is an effective method for storing 
source code for a small number ( < 100) of software components. As the number of 


30 





components increases however, this method becomes unacceptable. This is because the 
burden for maintaining the integrity of the files is placed on the users with little or no 
automated assistance. 



FIGURE 5 - UBRARY ATTRIBUTE DIAGRAM 


Because of the anticipated size of the CAPS software base the decision was made to 
encapsulate all of the component te.xt inside of the software base itself rather than using 
the operating system's file structure. 

For each component in the CAPS software base there are six text files that must be 
stored. These files are the PSDL specification source code, the implementation language 
specification, and the implementation body, the informal description, the axiomatic 
specifiction, and a normalized version of the axiomatic specification. 

In order to store these text attributes it was necessary to design a persistent class for 
Ontos that would allow storage and retrieval of variable length text strings in an efficient 


31 









manner. The software base class SB_TEXT_OBJECT was develoned to perform this 
function. 

The SB_TEXT_OBJECT class supports the creation of persistent text objects and 
appends to these objects C++ character strings (char *) or a C++ input stream 
Ufstream&). For output, an instance of the class SB_TEXT_OBJErT can output its text 
via a C++ character string {char *) or to an output stream {ofstream&). 

The class SB_TEXT_OBJECT is a child of the Ontos class Object and thus has all 
of the Ontos persistent methods for storage to and retrieval from the software base. 
Instances of the SB_TEXT_OBJECT class can be used as attributes of each component 
in the software base to store the PSDL and implementation source code. The full 
definition and implementation of the class SB_TEXT_OBJECT is given in Appendix B. 

E. BROWSING THE SOFTWARE BASE 

Although browsing by component name and keyword browsing are not the 
preferred methods for finding reusable components in a large software base, they are a 
necessary feature of any software collection. These types of features are required to 
allow users to familiarize themselves with the components in the software base as well as 
to allow the software base administrators to maintain them. Due to this need the software 
base was designed and implemented to support both keyword queries and named look up. 


32 





1. Named Look Up Of Components 

PSDL has only two types of software components: abstract data types and 
operators. Each software base domain library has been divided into these disjoint 
categories of components. For browsing purposes the software base provides a complete 
list of either all abstract data types, all operators, or all components in a particular library. 
These lists are in alphabetical order and are used to support for named look up of 
individual components. 

2. Keyword Querying 

Each software base library includes a keyword library for handling keyword 
access to its components. A keyword library is an instance of the class 
SB_KEYWORD_LIBRARY. The class SB_KEYWORD_LIBRARY has been designed 
to allow the keyword attribute of PSDL to form a keyword structured method of 
browsing the software base. 

An instance of SB_KEYWORD_LIBRARY provides a method for listing all 
keywords used in the library. From this list a keyword query can be formulated. 

The result of a keyword query is a list of those components that possess one or 
more of the query keywords. The list is ordered with those components that satisfy the 
most query keywords coming first. Figure 6 graphically represents the keyword query 
process for a query defined by keywords A,B, and C. 

The result of the query shown in Figure 6 will follow the following format: 

1. All components in area 1 will be listed first (since these components contain all 
keywords in the query). 


33 





2. The next components in the list will be those in areas 2, 3, and 4. 

3. The last components listed will be those in areas 5, 6, and 7. 

4. Those components in area 8 will not be included in the list since they do not 
contain any of the keywords in the query. 



L • Sat of ol componanta in tsiciiy 
A • Sat of ci componanta that contain keyword A 
B • Sat of ci componanta that contain keyword B 
C - Set of ol components that contdn keyword C 


Figure 6 - Venn Diagram of Keyword Query 

The class SB_KEYWORD_LIBRARY is a Dictionary with individual keywords as 
the Dictionary tags. Each tag is associated with a separate Dictionary that contains a list 
of components that contain that particular keyword. Figure 7 is an attribute diagram for 
the class SB_KEYWORD_LIBRARY. 


34 







Figure 7 - Keyword Library E/R Diagram 

F. QUERY BY SPECIFICATION 

As stated previously, the implementation method that was chosen for the CAPS 
software base is to store components in a database and use PSDL specifications as the 
basis for high recall queries. Each stored component consists of a PSDL specification, an 
implementation specification, the implementation code, and a normalized version of the 
PSDL specification. The syntax and semantics of the PSDL specification will be used to 
direct the search for a component. 

Figures 8 and 9 summarize the steps necessary to store components m the software 
base and to retrieve them using a given query specification. Components to be stored 


35 






must first pass through syntactic and semantic normalization (see Figure 8). The 
normalization processes transform the component's PSDL speciHcation to facilitate later 
matching [Ref 24]. Syntactic normalization involves primarily format changes and 
statistical calculations while semantic normalization requires specification expansion and 
transformations. 



Figure 8 - Comporient Storage Mechanism 


Figure 9 shows the general process for component retrieval. A query for a library 
component is formed by constructing the PSDL specification for the desired component. 
The query specification is syntactically and semantically normalized and then matched 
against the stored specifications. 

Syntactic matching of the query component takes place before semantic matching. 
The reason for this is that syntactic matching is faster than semantic matching and will be 
used to partition the software base quickly in order to narrow the list of possible 


36 














candidates that the semantic matching algorithm must consider. Semantic matching is 
time consuming and must be applied to as small a candidate list as possible. 


Quay 



Rgure 9 - Query By PSDL Speclflcatlon 

Both syntactic and semantic normalization and matching are required to achieve the 
best performance from the system. The main benefit of syntactic matching is speed 
whereas the advantage of semantic matching is accuracy. Accuracy is required in order to 
reduce the number of reusable components that a designer will have to evaluate before 
making a selection. 

Consider the example of trying to find an abstract data type for a set. The Booch 
component library [Ref 25] contains 34 different variations for implementing a set. The 
specifications for these set packages are quite similar but the implementations are clearly 
different. 


37 












If we consider generic packages to perform sorting, the Booch library contains 15. 
Nine of the 15 Ada specifications are identical with the exception of the name given to 
the package. Clearly we cannot rely on syntax alone to provide us a sufficiently fine 
grained search. Semantics are also required. 

A semantic process alone would be unacceptable because semantic matching would 
have to be applied to every software base component causing the search process to be 
impractically time consuming. For a more detailed discussion of the semantic matching 
mechanisms used by the software base refer to [Ref 26], 

The details of the syntactic matching mechanisms employed in the CAPS software 
base are addressed in the following sections of this thesis. 

1. Syntactic Matching 

The purpose of syntactic matching is to rapidly eliminate from consideration 
those modules in the software base that cannot match the query specification's interface. 
This matching process uses the query module's PSDL interface specification to formulate 
a query. Once those modules with unsuitable interfaces have been removed, only a small 
subset of the software base needs to be semantically analyzed. The syntactic matching 
process reduces the number of candidate modules sufficiently to make semantic matching 
practical. 

Prior to discussing the design of the software base architecture needed to 
support syntactic matching it is necessary to rigorously define what constitutes a 
syntactic match. PSDL allows the definition of both type and operator modules. Since a 


38 




type module is a superset of an operator module, the definition of an operator module 
match will be given in detail and then extended for use with type modules. 

The attributes of a PSDL specification p for a software component c that are 

important to the syntactic matching process are the following: 

1. S(p)= ( {In(t,n): there are n>0 occurrences of type t as input parameters to c }, 
{Out(t,m): there are m>0 occurrences of type t as output parameters from c }, 

(E : E is an exception defined in c},{ 

St: St is a state variable in c) ) 

S(p) is the interface subset of the PSDL specification for module c and is the 
only part of the specification that pertains to the syntactic matching process. 

Given a software base module m, and a query module q, along with their 
respective PSDL interface specifications S(m) and S(q) then m is a syntactic match for q 
if and only if all of the following constraints are met: 

1. 3fi:S(q) S(m) 3 [(f; (In(t,n)^) = In(t',m)j (m=n and (t=t' or t* is a generic match 
of t)) and fj is bijective] 

2. 3 f„: S(q) S(m) 3 [(f^ (Out(t,n)q) = Out(t’,m)„ (m=n and (t=t' or t' is a generic 
match of t)) and f„ is injective] 

3. if (|{STq}| >0then |{STm}| > 0) else (|{STq}| = |{STm}| =0) 

This definition of a syntactic match could be used directly to determine if a 
software base component could match a query specification's interface but would require 
the system to check every component in the software base. This type of implementation 
would be very inefficient. A better strategy involves using the matching rales to derive a 


39 




set of module attributes that can be used to rapidly identify and reject modules with 

unsuitable interfaces. Some examples of these derived attributes include: 

1. If the number of input parameters in S(q) is not equal to the number input 
parameters in S(m), then there can be no function f; to satisfy rule 1. Therefore 
S(m) can be eliminated from the search. 

2. If the number of output parameters in S(q) is greater than the number of output 
parameters in S(m), then there can be no function f„ to satisfy rule 2. Therefore 
S(m) can be eliminated from the search. 

3. If S(q) has state variables defined (i.e. q defines a state machine) but S(m) has no 
state variables, then S(m) can be eliminated from the search. 

If a component passes these tests, it does not mean that it is a syntactic match, 
a failure however, does eliminate the module from further consideration because it 
cannot be a syntactic match. These attributes are derivable from the PSDL specification 
and can be used to form multi-attribute keys. These keys allow a rapid reduction in the 
size of the viable subset of the software base via multi-attribute queries without the need 
to attempt to identify the individual mapping functions for each module. For those 
modules that are selected by the multi-attribute query additional checks can be made to 
identify components that cannot meet rules 1 and 2. These checks form a filtering 
mechanism that removes any unsuitable components from the query result. 

The rules for the syntactic matching of type modules are similar to those for 
operator modules with the addition of a mapping function to map the operators of S(q) to 
the operators of S(m) and an additional check to ensure the generic parameter 
substitutions used for this mapping function are consistent for all operators in S(m). 
Multi-attribute keys can be formulated that incorporate these .additional requirements. 


40 





These keys can then be used for the initial type module database query and additional 
checks only applied to those modules that are selected by the multi-attribute query. 

Through the use of a complex aggregate hierarchy, the software base can be 
separated into disjoint areas, each queriable via multi-attribute keys. 

2. Operator Component Library 

The class SB_OPERATOR_LIBRARY is structured to allow a multi-attribute 

query to be performed efficiently on the following attributes: 

1. State_Flag 

2. Number_of_Inputs 

3. Number_of_Outputs 

4. Number_of_Generic_Type s / Number_of_Unrecognized_Types 

The Number_of_Generic_Types attribute is for software base components and 
Number_of_Unrecognized_Types is the corresponding attribute for query components. 

In order for a software base operator component m to be returned from the 

multi-attribute query for component q it must satisfy the following conditions: 

1. State_Flag(m) = State_Flag(q) 

2. Number_of_Inputs(m) = Number_of_Inputs(q) 

3. Number_of_Outputs(m) >= Number_of_Outputs(q) 

4. Number_of_Generic_Types >= Number_of_Unrecognized_Types(q) 

The fourth requirement is due to the fact that if the software base library does 
not recognize a particular type in the query specification the only way that type could be 
matched is via a generic type. 


41 




The result of this query is a set of software base components that are potential 
syntactic matches of the query specification. At this point additional tests (filters) can be 
applied to each remaining component to determine if it should be passed to the semantic 
matching step. Applying these filters is an iterative process that must be carried out on 
one software base component at a time. 

The schema for the class SB_OPERATOR_LIBRARY is shown in figure 10. 

3. Abstract Data Type Library 

The abstract data type library is similar to the operator component library. It is 
an instance of the class SB_ADT_LIBRARY and uses the following attributes for multi 

attribute queries: 

1. Number_of_ADTs 

2. Total_Number_of_Inputs 

3. Total_Number_of_Outputs 

4. Total_Number_of_Generic_Types / Total_Number_of_Unrecognized_Types 

5. Number_of_Operators 

In order for a software base operator component m to meet an attribute query 

for component q all of the following must be true: 

1. Number_of_ADTs(m) >= N umber_of_ADTs(q) 

2. Total_Number_of_Inputs(m) >= TotaLTotal_Number_of_Inputs(q) 

3. Total_Number_of_Outputs(m) >= Total_Number_of_Outputs(q) 

4. Total_Number_of_Generic_Types(m) >= 

Total_N umber_of_U nrecognized_T ypes(q) 

5. Number_of_C)perators(m) >= Number_of_Operators{q) 


42 





43 


Rgure 10 - Operator Library Attribute Diagram 





The rationale behind requirement 5 is the same as for the operator query. 
Again the results of the multi-attribute query is a set of type components that are 
potential maps for the query component. The schema for the class SB_ADT_LIBRARY 
is shown in Figure 11. 

G. DATA STREAM TYPE MATCHING 

One of the critical concepts in the syntactic matching methodology is the 
determination if a library component stream data type is a match of a query component 
stream data type. The criteria for making this decision differs for each implementation 
language because they each have their own set of predefined data types and inheritance 
techniques. 

In order to identify if one stream type can map into another stream type, each 
library contains an instance of the class SB_RECOGNIZED_TYPES. This class 
contains the names of all of the type identifiers the library recognizes along with a matrix 
for determining whether a given type can map into another type that the system 
recognizes. This matrix represents all of the subtype relationships among the recognized 
types. 

The direction of the mapping is important as illustrated by the following 
example. In Ada the subtype Natural is defined as the range from O..Integer'Max and 
Positive is defined as h.Integer'Max. 


44 






Attribute Diagram 






A Positive data type in an input stream of a query can map into a Natural in an 
input stream of a stored component since all of the Positive's allowed values are also 
valid Natural values. A Natural however cannot map into a Positive because 0 is not a 
valid Positive number. The situation is reversed for output streams. 

The SB_RECOGNIZED_TYFES class also contains information about how 

some standard programing language concepts will be identified. These include: 

1. Whether or not the language is case sensitive. 

2. How type inheritance will be identified. 

3. The base type name for generic types, values, and procedures. 

4. The base type name for abstract data types. 

5. How array types will be specified (including the index type and element type). 

An example of the type matrix for Ada and its use is presented in Appendix A. 

H. ABSTRACT REPRESENTATION OF SOFTWARE BASE COMPONENTS 

The class SB_COMPONENT is an abstract base class for storing the attributes of 
software base components. It includes attributes that are common to all software 
components. The classes SB_ADT_COMPONENT and SB_OPERATOR inherit from 
SB_COMPONENT and include additional attributes that are specific to each. 

Two classes inherit from SB_OPERATOR. These are 

SB_OPERATOR_COMPONENT and SB_ADT_OPERATOR. These two classes differ 
only in the methods for handling generic and recognized types. 

Figure 12 shows the inheritance hierarchy used in defining the persistent classes for 
software base components. Figure 13 is the schema for the class 


46 





SB_ADT_COMPONENT and Figure 14 is the schema for the class SB_OPERATOR 
respectively. 


SB.COMPONENT 



f > 

SB_ADT 


SB_OPERArOR 

, COMPONENT , 


, COMPONENT , 


Figure 12 - SOFTWARE BASE COMPONENT INHERITANCE 


Each of these schemas contain some derived attributes. These derived attributes are 
stored in the software base to prevent them from being recomputed each time they are 
needed. 

A parser for the specification subset of PSDL was developed using lex [Ref 27] and 
yacc [Ref 28] in order to construct instances of the SB_ADT_COMPONENT and 
SB_OPERATOR_COMPONENT classes. For this parser to take the appropriate 
semantic actions, language preserving transformations of the original PSDL grammar 
were necessary. These transformations consist of the addition of non-terminals and 
productions to allow appropriate semantic actions to be carried out. 


47 









Figure 13 - ADT Component Attribute Diagram 

The source code input to lex and yacc that was used to generate the parser is 
included in Appendix C. 

1. INTEGRATING RETRIEVED COMPONENTS INTO CAPS 

The goal of the software base is to provide to CAPS a component implementation 
that is an exact match for a query specification and meets the needs of the CAPS 
execution support system. To accomplish this, once a reusable software component has 
been located it must be transformed into a form that matches all of these requirements. 


48 








This transformation involves changing parameter, type, and operator names of the library 
component to match those of the query specification as well as instantiating any generics. 



Figure 14 - Operator Component Attribute Diagram 


Rather than modifying the library component itself, the library unit can be used as a 
basis for the creation of a separate component that meets the needs of the query 
component. This is accomplished via inheritance or using the with statement in Ada. 

The software base cannot directly generate implementation code because it is not 
language specific. It can generate an abstract representation of how the library 
component satisfies the syntax and semantics of a query component. This representation 
can then be used by a translation tool specific to a particular implementation language to 
generate the implementation code. Figure 15 shows the details of the integration process. 


49 









Figure 16 - IntegroHon of Components Into CAPS 


This method of component integration is preferable since additional implementation 
languages can be added to the software base as long as a translation tool to generate the 
final implementation is provided. Appendix D provides a specification for a proposed 
mapping grammar that can be generated by the semantic matching system and used for 
generation of component implementation. Appendix D also gives an example of this 
process to generate an implementation for an abstract integer set using a generic set 
package. 


50 












J. SOFTWARE BASE INTERFACE 


C/ itself is a set of individual tools. These tools are linked together with a tool 
interface. One of the CAPS tools is a graphical user interface. The user graphical 
interface gains access to all of the other tools in the system via the tools interface. The 
reason for having all graphical user interface functions in a single tool is to simplify 
future enhancements to the interface. 

Based on this structure, each tool in the CAPS system provides a command line 
interface that is used by the tool interface to invoke the tool. The software base has been 
designed with an interface that meets this requirement. 

1. Command Line Interface 

The software base implementation provides a command line interface. This 
type of interface supports easy integration of the software base functions into the CAPS 
system. The functions provided by the software base command line interface are the 
following: 

1. Make a new domain library. 

2. Add a new software base component. 

3. Update a software base component. 

4. Delete a software base component 

5. Generate a list of components in a library 

6. Generate a list of operators in a library 

7. Generate a list of types in a library 

8. Generate list of keywords in a library 


51 





9. Keyword query 

10. Component query 

11. View a component's source files 

12. Output diagnostic information (for testing and maintenance only) 

13. Generate a component's mapping for a given query 

A function to generate a mapping for a query has not been implemented in the 
current version of the software base. For details on the exact syntax of these commands 
refer to Appendix E. 

2. Graphical User Interface 

In order to demonstrate the capabilities of the software base system and the 
command line interface, a graphical user interface was prototyped for the software base 
system using the Interviews 3.0b [Ref 29] interface builder application and the 
Interviews 3.0b object library. This interface is not intended to be full functioning but 
rather an example of the functionality of the software base system. 

Appendix F is the user's manual for the prototype software base graphical 
interface. Appendix G is the source code for this graphical user interface. 


52 





V. CONCLUSIONS AND FUTURE RESEARCH 


The software base system described in this thesis has been implemented. It has not 
yet been integrated into CAPS. Due to the complexity of the software base system, there 
are many areas that can be improved by future research. This chapter identifies those 
areas that need improvements and provides recommendations where possible. 

A. ADDING COMPONENTS TO THE SOFTWARE BASE 

Reusable components are currently being selected and tested for possible inclusion 
into the software base. This is a labor intensive activity for several reasons. 

1. Component Testing 

Any component that is added to the software base must be adequately tested to 
ensure that it fully meets its specification. Testing software components continues to be 
a difficult area in software engineering research and further advances in testing are 
necessary to make reusable component libraries more successful. Some relevant research 
in this direction is provided in [Ref 30]. 

2. Component Implementation Restrictions 

The CAPS system restricts the nature of the components used in prototypes. 
The first restriction is that implementations of OPERATORS must be procedures rather 
than functions. The second restriction is that "in out" parameters are not allowed. These 


53 



restrictions necessitate the modification of most existing components that are candidates 
for reuse. This includes sources such as the Booch library, the Ada software repository, 
the RAPID project, the CAMPS project etc. One method of overcoming this difficulty is 
automate the modification process using a translation tool. 

3. Writing Formal Specifications Of Existing Components 

CAPS and the software base system require that reusable components be 
specified in two additional specification languages. These are PSDL and the OBJ3 used 
for semantic matching. Writing these specifications is a time consuming process that 
could be partially automated by using the implementation language's specification to 
generate skeletons of PSDL and OBJ3 interface specifications. 

B. DELETING AND UPDATING COMPONENTS 

Updating or deleting components from the software base could cause system 
inconsistencies. These inconsistencies take two forms. The first involves other software 
base components that may depend on the deleted or updated component. The second is 
that previously generated prototypes may depend on the component that has been deleted 
or modified. The current implementation of the software base relies on the software base 
administrator to ensure that these conditions do not arise. This process should be 
automated to ensure that the inconsistencies do not occur. 





To correct the first problem it is necessary to add dependency relationships between 
software base components and the software base. This would allow the software base to 
ensure that all updates and deletions do not create inconsistencies. 

To correct the second problem it is necessary to save the source code for all deleted 
or updated components external to the software base. This could be accomplished 
through the use of a version control system such as SCCS. 

C. EFFlCffiNCY 

The most time consuming portion of a software base query is semantic matching. 
The easiest way to improve overall query performance is to reduce the number of 
components that must be analyzed by the semantic matching system. 

As more components are added to the software base, experience will be gained on 
the performance of the syntactic matching system. This experience will make it possible 
to identify additional attributes for the multi-attribute queries and to add more detail to 
the post-query filtering routines. These additions will reduce the number of candidates 
passed to the semantic matching system and thus increase overall query performance. 

D. SOFTWARE BASE SYSTEM IMPLEMENTATION LANGUAGE 

The long term goal for CAPS is that it be entirely implemented in Ada. A major 
portion of the software base system is currently implemented in C++. C++ was used 
because there does not exist a tool with the capabilities of Ontos that interfaces directly to 


55 





Ada. As more robust database tools become available for Ada, it will be possible to 
re-implement the software base tool fully in Ada. A DBMS of this type is currently 
being developed which could be used for future versions of the software base [Ref 31]. 


56 






LIST OF REFERENCES 


1. Lxiqi, M. Ket&hchi, A Computer Aided Prototyping IEEE Software, 

March 1988, pp. 66-72. 

2. Elbert, T. F., Embedded Programming in Ada, Van Nostrand Reinhold 
Publishing Co., Inc., New York, NY, 1986. 

3. Yourdon, E., Modern Structured Analysis, Yourdon Press, Englewood Cliffs, NJ, 
1989. 

4. Military Standard Defense System Software Development, DOD-STD 2167a, 
February, 1988. 

5. Berzins, V. and Luqi, Software Engineering with Abstractions, Addison-Wesley 
Publishing Company, Reading, MA, 1990. 

6. Luqi, Computer Aided Software Prototyping, IEEE Computer, September, 1991, 

p. 111-112. 

7. Luqi, Software Evolution via Rapid Prototyping, IEEE Computer, May 1989, pp. 
13-25. 

8. Luqi, Knowledge-Based Support for Rapid Prototyping, IEEE Expert, Fall 1988, 
pp. 9-18. 

9. Luqi, V. Berzins, R. Yeh, A Prototyping Language for Real-Time Software, 
IEEE Transactions on Software Engineering, October, 1988, Vol. 14, No. 10, 
pp. 1409-1423. 

10. Salton, G. and McGill, M., Introduction to Modern Information Retrieval, 
McGraw-Hill, 1983. 

11. Goguen, J. A., SRI International Report SRI-CSL-88-4R2, OBJ as a Theorem 
Prover with Applications to Hardware Verification, August^l988. 

12. Prieto-Diaz, Ruben, and Freeman, Peter, Classifying Software for Reusability, 
IEEE Software, v. 4, pp6-16, January, 1987. 

13. Vogelsong, T. and Rothrock, J., Reusable Ada Products for Information Systems 
Development (RAPID) Lessons Learned During Pilot Operations, U.S. Army 
Information Systems Software Development Center - Washington, 1990. 

14. Burton, B., Wienk, R., and others. The Reusable Software Library, IEEE 
Software, v. 4, pp. 25-33, July,1987. 


57 




15. Air Force Armament Laboratory, Contract F08635-88-C-0002, CDRL No. A009, 
CAMP Parts Engineering System Catalog User's Guide, McDonnell Douglas 
Missile Systems Company, 1989. 

16. Griss, G. L., Software Reuse at Hewlett-Packard, OOPSLA'91 Proceedings, 
Phoenix, AZ, October 6,1991. 

17. White, L. J., The Development of a Rapid Prototyping Environment, M.S. Thesis, 
Naval Postgraduate School, Monterey, CA, December 1989. 

18. Berzins, V., and Luqi, Rapidly Prototyping Real-Time Systems, IEEE Software, 
September 1988. 

19. Cummings, M. A., The Development of User Interface Tools for the Computer 
Aided Prototyping System, M.S. Thesis, Naval Postgraduate School, Monterey, 
CA, June 1990. 

20. D. Galik, Luqi, A Conceptual Design of a Software Base Management System for 
the Computer Aided Prototyping System, Technical Report NPS 52-89-002, 
Computer Science Department, Naval Postgraduate School, 1989. 

21. J. Huskins, Issues in Expanding the Software Base Management System 
Supporting the CAPS, M.S. Thesis, CS, Naval Postgraduate School, June, 1990. 

22. Ontologic Inc., Ontos Object Database Documentation Release 15, Bulington, 
MA, 1991. 

23. Stroustrup, B., The C++ Programming Language, Addison Wesley, 1986. 

24. Luqi, Normalized Specifications for Identifying Reusable Software, Presented at 
ACM-IEEE Computer Society 1987 Fall Joint Computer Conference, Refereed 
Paper, Conference Proceedings, pp. 46-49, Dallas, TX, October, 1987. 

25. Booch, G., Library of Reusable Ada Components, Wizard Software, Lakewood, 
CO, 1990. 

26. B. Steigerwald, Luqi, J. McDowell, A CASE Tool for Reusable Software 
Component Storage and Retrieval in Rapid Prototyping, Vol 38, #11, Nov. 1991, 
Information and Software Technology, England. 

27. Lesk, M. E. and Schmidt, E., Lex - A Lexical Analyzer Generator, AT&T Bell 
Laboratories, Murray Hill, NJ. 

28. Johnson, S. C., Yacc: Yet Another Compiler-Compiler, AT&T Bell Laboratories, 
Murray Hill, NJ. 

29. Computer System Laboratory Department of Electrical Engineering and 
Computer Science Stanford University, Interviews Reference Manual, Version 
3.0-beta, Stanford, CA, 1991. 


58 




30. Depasquale, J., Design and Implementation of Module Driver and Output 
Analyzer Communication, M.S. Thesis, Naval Postgraduate School, Monterey, 
CA, June 1990. 

31. Persistant Data Systems Inc., IDB User’s Manual, IDB Version 1.0, January, 
1991. 


59 


APPENDIX A - USING PSDL TO SPECIFY 
REUSABLE COMPONENTS 

The ability to accurately specify reusable components with PSDL is critical to the 
success of the software base. Due to the general nature of the PSDL interface 
specification its use for specifying specific programming languages must be refined. The 
software base is designed to recognize the enumeration of PSDL for any language in the 
following areas. 

A. STRUCTURE OF EXTENSIONS TO PSDL INTERFACE SEMANTICS 

1. Generic Parameters 

In languages that support the concept of generic units, such as Ada, or in 
macro expansion facilities, there are three categories of generic parameters. These are 
generic types, generic values, or generic program units. 

The generic specification structure in PSDL must be extended to identify a 
particular generic parameter as either a type, value, or program unit. This is 
accomplished in the software base by defining of three identifiers that have special 
significance in the generic structure. 

2. Abstract Data Types 

There are cases where in the definition of one abstract data type it is necessary 
to define others as well. Programing languages such as Ada allow an individual package 


60 




to define an unlimited number of abstract data types. PSDL TYPE'S can specify multiple 
abstract data type structures through the definition of an identifier that has a special 
meaning in the type declaration structure of a PSDL TYPE. 

3. Type Inheritance 

Most modem programming languages suppon user defined types. In many 
cases user defined types actually inherit from a predefined language type and the new 
type retains compatibility with its parent. An example of this is the subtype construct in 
Ada. 

The software base needs to be able to identify when a user defined type is 
compatible with a predefined type or another user defined type. One way of achieving 
this is to allow the ability to specify from what base type a user defined type inherits. 
This inheritance identification is achieved in the software base through the definition of 
an identifier that has special meaning in the type name construct of PSDL. 

4. The Array Abstract Data Type 

The concept of an array of data is present in almost all programing languages. 
Because of this, the decision was made to add the definition of special identifiers in 
PSDL to allow the software base to decide when two array types are compatible. The 
identifiers are used to identify the type of the index of the array as well as the type of the 
element of the array. 


61 







B. EXAMPLE DEFINITIONS FOR ADA 


For a particular language library the definitions of the special identifiers are 
contained in the rule file used when the library is created. The rule file defined for Ada 
follows this description of a rule file's contents. The first field in the rule file indicates if 
the language being defined is case sensitive (1) or not (0). 

The next six rules define the special identifiers for the following concepts. 

1. Type that must be matched generically 

2. Inheritance 

3. Generic type 

4. Generic program unit 

5. Generic value 

6. Abstract data type 

7. Array 

8. Array index 

9. Array element 

These identifiers must all be defined and in this order. 

Following these identifiers is a list of type names that the designer wants the 
software base library to recognize in this library. The list is terminated with a 

Following the ~ is a matrix of boolean (0 or 1) values concerning type 
compatibility. This matrix is constructed by listing all identifiers above the ~ to identify 
the rows and columns of the matrix. A value of 1 at (row x, column y) indicates that 
type X can map into the type y. 


62 








C. ADA RULE FILE 


0 

UNRECOGNIZED 

BASE_TYPE 

GENERIC.TYPE 

GENERIC.PROCEDURE 

GENERIC. VALUE 

ADT 

ARRAY 

ARRAY.INDEX 

ARRAY.ELEMENT 

DISCRETE 

RANGE 

DIGIT 

DELTA 

PRIVATE 

ENUMERATION 

INTEGER 

NATURAL 

POSITIVE 

BOOLEAN 

FLOAT 

nXED 

CHARACTER 

STRING 

ACCESS 

00000000000 
00000000000 
00000000000 
00000000000 
00000000000 
00000000000 
OOOOOOIOOOO 
00000000000 
00000000000 
00000000000 
00000000000 
00000000000 
00000000000 
00000000000 
0000000001 1 
0000000001 1 
0000000001 1 
0000000001 1 
00000000010 
00000000000 


0010000000000 
0000000000000 
0000000000000 
0000000000000 
0000000000000 
0000000000000 
0010000000000 
0000000000000 
0000000000000 
0000000000000 
0000000000000 
0000000000000 
0000000000000 
0000000000000 
0010000000000 
0010100000000 
0010110000000 
00101 1 1000000 
0010000100000 
1010000010000 


63 







000000000000110000001000 
000000000100010000000100 
000000010000010000000010 
000000000000000000000001 


D. EXAMPLE PSDL SPECIFICATIONS USING ADA RULES. 


1. Bubble Sort Operator 

E. PSDL 


operator bubble_sort 
speciHcalion 
generic 

anay_lype: GENER1C_TYPE[ 

BASE.TYPE: ARRAY( 

ELEMENT : PRIVATE, INDEX : DISCRETE]], 
lessjhan : GENERIC_PROCEDURE 

input 

the_array : array_type 

output 

the_array: array_type 
keywords array,sort,bubbIe 
description { Booch library bubble sort) 
end 


F. ADA SPECIFICATION 


- (C) Copyright 1986, 1987, 1988,1989,1990 Grady Booch 

- All Rights Reserved 

- Serial Number 0100219 

"Restricted Rights Legend" 

- Use, duplication, or disclosure is subject to 

- restrictions as set forth in subdivision (b) (3) (ii) 

- of the rights in Technical Data and Computer 

-- Software Clause of FAR 52.227-7013. Manufacturer: 

- Wizard software, 2171 S. Parfet Court, Lakewood, 

- Colorado 80227 (1-303-987-1874) 


64 





generic 

type Item is private; 
type Index is (<>); 

type Items is array(Index range <>) of Item; 
with function "<" (Left : in Item; 

Right: in Item) return Boolean; 
package Bubble_Sort is 

procedure Sort (The_Items : in out Items); 

end Bubble_Sort; 


65 







1. Set Abstract Data Type 


G. PSDL SPECIFICATION FOR SB_SET_PKG 


type sb_sel_pkg 
specification 
generic 

t: GENERIC.TYPE, 
block_size: GENERIC_VALUE, 
eq : GENERIC.PROCEDURE 

set; ADT 


operator empty 
specification 
output 


end 


s: set 


operator add 
specification 
input 


output 


end 


X : t, 
si: set 

so: set 


operator remove 
specification 
input 

X : t, 
si : set 


end 


output 

so : set 


operator member 
specification 
input 

X ; t, 

s: set 


end 


output 

V : boolean 


operator union 


66 




specification 

input 

output 


end 


sl,s2: set 
s3 : set 


operator difference 
specification 
input 

sl,s2; set 


end 


output 

s3 : set 


operator intersection 
specification 
input 

sl,s2; set 

output 

s3 : set 


end 


operator size 
specification 
input 

output 


end 


s: set 
V : natural 


operator equal 
specification 
input 

output 


end 


sl,s2; set 
V : boolean 


operator subset 
specification 
input 

output 


end 


sl,s2 ; set 
V : boolean 


keywords SET 


description { SET ADT WITH OPERATIONS FOR EMPTY, ADD, SUBSET, EQUAL ) 
end 


67 




H. ADA SPECIFICATION FOR SB_SET_PKG 


with textjo; use text_io; 
generic 

type t is private: 
block_size: in natural:=128; 
with procudure eq(x,y: in t, v : BOOLEAN); 
package sb_set_pkg is 

type set is private; 

type index_array is array(natural range <>) of natural; 

procedure empty(s: out set); 
procedure add(x: in t; si; in set, so: out set); 
procedure remove(x: in t; s; in out set); 
procedure member(x; in t; s: in set, v : boolean); 
procedure union(sl, s2: in set; s3: out set); 
procedure differencefsl, s2: in set; s3; out set); 
procedure intersection(s 1, s2: in set; s3: out set); 
procedure size(s: in set, v : out natural); 
procedure equal(sl, s2; in set, v : out boolean); 
procedure subset(sl, s2: in set, v : out boolean); 

private 

type link is access set; 

type elenients_typc is array(l..bIock_size) of i; 

type set is 

record 

size: natural :=0; -The size of the set 
elements: elcmcnts_type; -The actual elements of the set 
next: link:=null; —The next node in the list 
end record; 

-Elemcnts(l..min(size,block_size)) contains data 
end sb_set_pkg; 


68 



APPENDIX B . C++ SOURCE CODE FOR 
SOFTWARE BASE 


The source code for the software base included in this Appendix was formatted 
using the c++21atex code formatting system written by Norbert Kiesel. His program was 
modified to have it generate output that conforms to the requirements of the Naval 
Postgraduate School thesis format. 


69 





II - 

// CAPS REUSABLE COMPONENT RETRIEVAL SYSTEM CLASS DEFINITIONS 

// 

11 J. K. MCDOWELL 23 AUG 91 

n 

n - 

// 

finclude <strea]n.hxx> 

#include <str6treain.hxx> 
extern "C—" 

{ 

#inclttde <string.h> 

#includ6 <stdio.h> 

•include <stdlib.h> 

•include <ctype.h> 

} 

// - 

// 

// - 

• include <Dictionary.h> 

• include <Array.h> 

• include <List.h> 

• include <TRel.h> 

• include <Type.h> 

• include <Database.h> 

• include <Directory.h> 

• include <GlobalEntities.h> 


// - 

// PRE-DECLARE ALL CLASSES TO AVOID PROBLEMS WITH DECLARATION ORDER 

H - 

class SBXIBRAR^'; j j M.cn 

class SBJ^DT.COMPON'ENTXIBRARY; Usbacl.cxx 

class SB.OPERATOR.C'OMPONENTilBRARY; j j shod.cii 

class SB-KEYWORD-LIBRARY; f/sbkwicix 

class SB-COMPONENT; Hsbc.czx 

class SB-COMPONENT JDICTIONARY; jlsbcd cxx 

class SB-KEYWORD-DICTIONARY; Hshkxcd cxx 

class SB-TEXT-OBJECT; f/sbio.cxx 

class SB-ADT-COMPONENT; //sbac.cxx 

class SB-OPERATOR; //sbo.cxr 

class SB-OPERATOR-COMPONENT; //sboc.czr 

class SB-ADT-OPERATOR: /Isbao.cxx 

class SBJD-DECL-DICTIONARY; //sbidd.cxx 

class SBJD.DECL: ffsbid.cxx 

class SB-TYPE-USAGE; /(sblu.cxx 

class SB-TYPE.USAGE.DICTIONARY: //sblud.cxx 











class SB.TYPEJ^AME; /Isblu.crr 
class SB^DT.OPERATOR-DICTIONARY; l/sbaod.cxi 
class SB-EXCEPTION-DICTIONARY; //sbed.cn 
class SB.RECOGNIZED.TYPES; f/sbrl.cix 

n - 

// SOFTBASE NAMEIXG CONVENTIONS 

// 

// A. all sofibase class names start with ”SB.’ this eliminates any 
II potential name space conflicts with any other software. 

II B. all TRef instances start with "theN and there dereferencing 
II functions use the rest of tin name. (te. TRef *ihe.name, 

II SB.* name!) ) 

//- 

// --- 

// to eliminate confusion between PSDL types and stream types 

II PSDL types art refered to as abstract data types (ADT) and 
II stream types are refered to as simply types 
U - 


71 







class SB.LIBRAR'S' : public Object 

{ . 

private: 

TRef ♦the^dt.componentJibrary; 

Dictionarylterator adt.iterator(): 

SBjVDT.COMPONENTXIBRARY ♦adt-componentJibraryO; 

TRef ♦ the.operator.component Jibrary; 

Dictionarylterator operatorJterator(); 

SB.OPERATOR.COMPONENTXIBRARV ♦operator-componentJibrary() 

TRef ♦the.component.dictionary; 

Dictionarylterator component .iterator(); 

SB-C0MP0NENTT)1CT10NARV ♦component.dictionaryO; 


TRef ♦theJceywordJibrary; 

SBJ<EY\VORD.LIBRARY ♦keyword-library!); 


TRef ♦ thej'ecognized-types; 

SB-COMPONENT-DICTIONARY *<,uery(SB.COMPONENT ♦); 
public: 

// methods for- oiitos 

SBJ.IBRARY (APL ♦): 

virtual void Destroy!Boolean al)orted=FALSE): 
virtual void deleteObject!Boolean deallocate=FALSE); 
virtual void putOl'jectlBoolean deallocate=I'ALSE); 

Type ♦get Direct Type!); 

// - 

SB-LIBRARY!cliar ♦name,char ♦table); 
void component.list!ofstream.k’ outstreatn); 
void keywordJistlofstreamA oiitstream); 
void type-list!ofstream,k: otitstream): 


void operator-listjofstreamik: outstream); 

void query!SB-COMPONEN 1 ♦query.com|)onent,ofstream(k: outstream); 





void keyword.query(ifstreami: instream, ofstreami: outstream); 
Boolean add(SB-COMPONE.N'T *); 

SB-COMPONENT ♦query(char ♦component-iiame); 
void update_recognized.types(char ♦file); 
SB_RECOGNTZED-TVPES ♦recognized.types(); 
void delete. component (SB-COMPONENT ♦the.component); 




class SB^DTX’OMPONENT-LIBRARV : public Object 

{ _ 

private: 

TRef ♦the.adt.component-dietionary; 

SB-COMPONENTJD1CT10NAR1' ♦adt_component-dictionary(); 

TRef ♦the-maiii-library; 

Dictionary *niain-library(): 

public: 

// meihods for oulos 

SB.ADT.COMPONENT-LIHRARY(APL *): 
virtual void Destioy(Boolean aborted=FALSE); 
virtual void deleteOliject(Boolean deallocate=FALSE); 
virtual void putObject(Boolean deallocate=FALSE); 

Type ♦getDirectType{): 

// - 

SB-ADT.COMPONENTXIBRARV(); 

Boolean add(SB-ADT.COMPONENT* ); 

SB-COMPONFNT-DICTIONARV ♦query(SB.ADT.COMPONENT ♦queryxomponent); 
void list(ofstream.V onistreaiii); 

Dictionarylterator itciatori (); 

void delete-componcni(SB-.ADT-COMPONENT ♦the.component); 

}; 


71 







class SB-COMPONENTJDK'TIONARY : public Dictionary 

{ 

public: 

// ontos methods 

SB-C0MP0NENTJD1CT10NARY(APL *); 
virtual void Bestroy(Boolean aborted=FALSE); 
virtual void deleteObject(Boolean deallocate^FALSE); 
virtual void putObject(Boolean deaIlocate=FALSE): 
Type +getDirectType(): 

SB-C0MP0NE.\TJ:)ICT10NARY(): 

Boolean add( SB.COM PON ENT *): 

SB.COMPONENT *(|ii''ry(char *nanie); 
void printOn(ofstloam.N ouisireani); 

Dictioiiarylteiator iiinaiorl): 

}: 





class SB-OPERATOR-COMPONENTJ.IBRARY : public Object 

{ 

private; 

TRef ♦the.operator.component.dictionary; 

SB-COMPONENTJDICTIONARY ♦operator.component_dictionary(); 

TRef ♦tiie.state-dictionary; 

Dictionary ♦state-dictionary(); 

TRef *1116jion -State -dictionary; 

Dictionary ♦non-state-dictionary(); 

public: 

// oiitos methods 

SB-OPERATOR-COMPONENTJTBRARY(APL ♦); 
virtual void De.stroy(Boolean aborted=FALSE); 
virtual void deleteObjecl(Boolean deallocate=FALSE); 
virtual void pu(Object(Boolean deallocate=FALSE); 

Type *getDirect'rype(); 

// - 

SB-OPERATOR-COMPONENTXIBRARYO, 

Boolean add(SB-OPERATOR.COMF’ONENT ♦new.component); 

SB-COMPONENT-DICTIONARY ♦query! 

SB-OPERATOR-COMPONENT ♦query.component) 


void list(ofstreamA' outstream); 

Dictionarylterator iterator!): 

void delete-componeiit (SB-0 PER ATOR.COM PON ENT ♦the .component); 


}: 








class SBJvEYWORD.LIBRARY' ; public Dictionary 

{ 

public: 

// oiitos methods 

SB-KEY"WORDXIBRARY"(APL »); 
virtual void Destroy(Boolean aborted=FALSE); 
virtual void deleteObject( Boolean deallocate=FALSE); 
virtual void piitObject(Boolean deallocate=FALSE); 

H - 

SB-KEY\V0RD.L1RRARY'(); 

void query!ifslreaiiu^- instream, ofstreami: outstream); 

Boolean add.component (SB.COM PON ENT ♦new.component); 
void delete.con>ponent(SB.COMPONENT ♦the.component); 
Dictionarylterator iterator!); 


void list!ofstreamY outstream); 











class SB.COMPONENT : public Object 

{ 

private: 

char *the_compoiient_nanie: 

TRef ♦theJieyword-dietionary; 

TRef ♦the-psdi-text; 

TRef ♦theJmp-spec-text ; 

TRef +theJmp.body.text; 

TRef *thejnfornial_descriptioii; 

TRef ♦theJormal-description; 

TRef ♦tlie_iiorm_formaLdescription; 
TRef *the-recognized.type .usage: 

TRef ♦the.unrecognized Jype.usage: 

TRef *the.geneiic-iisage; 


protected: 


SB-COMPOi\E.\T(APL ♦theAPL); 

public: 

virtual Type ♦getDiiectType{)=0; 
virtual void Destroy(Boolean aborted=FALSE); 
virtual void delete01)ject(Boolean deallocate=FALSE); 
virtual void |intObject(Boolean deallorate=FALSE); 

SB.COMPO.\ENT(cliar ♦id): 

virtual void printOnfofstream.'c outstreani)=0; 

Boolean addJvey\vord(cliar ♦keyword); 
char ♦component Jiame(); 

SB-TEXT.OBJECT ♦psdLtext(); 

SB-TEXT-OBJECT ♦imp.s|iecjext(); 
SB-TEXT.OBJECT ♦imp-l.ody-text(): 


SB.TEXT-OBJECT ♦inforniaLdescriplion(): 






SB-TEXT.OBJECT *formaLdescription(); 

SB-TEXT-OBJECT *norm-fonnaLdescription(); 

SB-TYPE-USAGE.D1CTIONARY ♦generjc.usage(); 

void add-text(ifstreanii: psdl, ifstreamfc spec, ifstreamii body); 

void insert-geiierics(SB-TYPE-USAGE J)ICTIONARY * new generic jjsage) 

SB-TYPE-USAGE-DICTIONARY ♦recognized.type.usage(); 

SB.TYPE-USAGE-DICTIONARY ♦unrecognized.type_usage(); 

SBJ<EY\VORDJDICTIONARY ♦keyword-dictionary(); 

int num.unrecognized.tyi)es(); 

virtual int nuni_geneiic.types( )=0; 

int total.types(): 


}•. 


79 







class SB-ADT.COMPOXENT : public SB.GOMPONENT 

{ . 

private: 

TRef *the jidt-usage; 

TRef ♦thejoperator^pecs; 

SB_A.DT.OPERATOR.DICTIONARY ♦operator^pecs(); 
public: 

// ontos melhods 

SBJiDT.COMPONENT (APL ♦); 
virtual void Destroy( Boolean aborted=FALSE): 
virtual void deletcObject(Boolean deallocate=FALSE); 
virtual void pulObject(Boolean deallocate=FALSE); 

Type ♦getDirectTyiie(); 

// - 

SBJVDT.COMPONENT (char ♦id): 

void insert.adt.usage(SB.TYPE.USAGEJDICTIONARY * ne\v.adt-usage); 

void insert .operators( SB .A DT.OPERATOR JDICTION ARY ♦new .operators); 

int nuni.adts(); 

int num.adt.opeiators(); 

int totalJnputs(); 

int total.oiilputs(); 

virtual int nuni-generic.(ypes(); 

Boolean filter(SB.ADT.COMPONENT ♦library-component): 
Dictionarylterator adt.itcrator(); 

Dictionarylterator adt.operator jteralor(); 
void printOn(ofstreamiV o\itstieam): 
virtual Boolean )iroress.ty|ie_inro(); 


SB-TYPE.USAOE.nirTIONARY ♦adi..isage(); 










class SB-OPERATOR ; public SB.COMPONENT 

{ 

private; 

TRef ♦theJnput.attributes; 

TRef *the-outpiit .attributes: 

TRef ♦the.exceptioiis; 

Boolean states.flag; 
protected; 

// ovtos Viet hods 

SB.OPERATOR(APL * tlieAPL); 

virtual void Deslroy(Boolean al>orted=FALSE); 

virtual void deleleObject(Boolean deallocate=FALSE); 

virtual void putObject(Boolean deallocate=FALSE); 

virtual Type ♦getDiiectType( )=0; 

// - 

SB J D JDECL.DICTION A R^' *input.alf ributes(); 

SBJD-DECL.DICTIONARY' ♦output_altributes(); 
SBJIXCEPTIONJYICTIONARY' *exceptions(); 
SB.OPERATOIRchar *id); 
public: 

Boolean add-inputs(SBJD.DECL.DICTIONARY *); 

Boolean add-outputs(SDJD.DECL.DICTIONARY ♦); 

Boolean add.exfeptions{SB JlXCEPTlONTilCTIONARY ♦ 

int numJnputs(); 

iiit i(Uin.outpiits(): 

virtual int nuin.generif_types(); 

Dictionarylterator input jteraioi (); 





Dictionarylterator out|)ut Jteiator(): 


Dictionary Iterator exception Jtprator(); 
Boolean states(); 
void set3tates(); 

virtual void printOn(ofstreami: ); 









class SB^DT.OPERATOR : public SB.OPERATOR 

{ 

public: 

// ontos methods 

SBADT.OPERATOR(APL ♦ theAPL); 
virtual void Destroy(Boolean aborted=FALSE); 
virtual void deleteObject(Boolean deaIlocate=FALSE); 
virtual void putObject(Boolean deallocate=FALSE); 
virtual Type *getDirectType(): 

// - 

Boolean process-tyi)eJnfo(SB_ADT-COMPONENT *adt); 
SB-ADT.OPERATOR(char *); 

}; 


M 








class SB-OPERATOR-COMPOXENT : public SB.OPERATOR 

{ 

public: 

// ontos melhods 

SB.OPERATOR-COMPONENT(APL ♦ iheAPL); 
virtual void Destroy( Boolean al.iorted=FALSE); 
virtual void cleleteObject( Boolean deallocate=FALSE)j 
virtual void putObject(Bo'^lean deallocate=FALSE); 
virtual Type *getDirectType(): 

S B -O P E R ATO R .C O M I’O X E \ T( char *); 

Boolean process.tyiiejnfo(): 

Boolean filtei(SB.OPERATOR.COMPONENT ♦library.unit); 


8 -") 






class SB.TEXT.OBJECT : public Object 

{ 

private: 

char *the.text , 
public: 

// ontos methods 

SB.TEXT-OBJECT(APL +); 

Type *getDirectType(); 

virtual void Destroy( Boolean aborted=FALSE); 
virtual void (leleteObject(Boolean deallocate=FALSE); 
virtual void pntObject(Bool. an deallocate=FALSE); 

SB.TEXT.OBJECT!); 
void append!ifstreaniiV ); 
void append!char ♦); 
void textlofstreaniA- ): 
char »text!): 

}: 






class SBJvEVWORD.DICTlONARY : public Dictionarv 

{ 

public: 

// onios methods 

SBJvEYW0RD.DICT10NARY(APL *); 
virtual void Bestroy( Boolean aborted=FALSE); 
virtual void delett'Object(Boolean deallocate= FALSE); 
virtual void putObject(Boolean dcallocate=FALSE); 
Type ♦getDirectTyiie(); 

SB-KEYWORD.DK’TlONAini): 

Boolean add{cliar *); 

Dictionarylterator iteiatoi(). 
void printOn(ofsti'eainA' ); 

}. 


N( 







class SB_ADT.0FERAT0R.D1CTI0NARY : public Dictionary 

{ 

public: 

// onlos methods 

SB-ADT-OPERATOR.DICTIONARY(APL* ); 
virtual void Destroy!Boolean aborted=FALSE); 
virtual void deleteOliject(Boolean deallocate=FALSE); 
virtual void putObjecf(Boolean deallocate=FALSE); 

Type* getDirectType(); 

SB JkDT .OPERATOR.DICTION ARY(); 

void add(SB.ADT.OPERATOR ♦); 

void append(SB.ADT-0PERAT0RJDICT10NARY *); 

iut num(); 

iut totaljnputs(): 

int total.outputs(): 

Dictionarylteraior iterator!); 

V lid printOn!ofstreaiuA ); 

}; 





class SB-EXCEPTION-DICTIONARY ; public Dictionary 

{ 

public; 

// ontos inelhods 

SB-EXCEPTION JDICT10NARY(APL * ); 
virtual void Destroy!Boolean aborted=FALSE); 
virtual void deleteObject(Boolean deaIlocate=FALSE); 
virtual void putObject(Boolean deailocate=FALSE); 
Type +getDirectType(); 

SB_EXCEPT10N JDICTION A RY(); 

Boolean add(char *); 

Boolean appeiuKSB-EXCEPTION-DICTIONARY * ); 
Dictionaryllerator iterator!); 
void printOiRofstreariii^ ): 




class SBJD.DECL.DICTIONARY : public Object 

{ 

private: 

TRef ♦the_dictionary.by.type; 

TRef ♦the.dictionary.byjd; 

TRef tthe Jd.declaration Jist; 

Dictionary ♦dictionary.by.type(); 

Dictionary ♦dictionary.by_id(); 

List ♦id.declaration.list(); 

public: 

// onios methods 

SBJDJ)ECL.D1CTI0NARY(APL ♦); 
virtual void Destioy( Boolean aborted=FALSE); 
virtual void deleteObject(Boolean deallocate=FALSE); 
virtual void putObject(Boolean deallocate=FALSE): 
Type ♦getDirectType(): 

// - 

SBJDJ3ECL-DICTI0NARV(): 

Boolean add.decl(char ♦id.SB.T^'PEJS'AME ♦typejiame) 
Boolean add-decl(SBJD.DECL ♦decl); 
void remove-decl(SB.lD.DErL ♦decl): 

Boolean append(SB.ID.DECL.DICTIONARY ♦); 
int num(); 

SBJDJDECL ♦queryJd(char ♦queryjianie); 
Dictionarylterator iditerator(); 

Dictionarylterator typeJterator(); 

Lisflterator orderJterator(): 
void printOn(ofstreainY )• 

}: 


90 










class SBJD-DECL : public Object 

{ 

private; 

char ♦theJd; 

TRef *the.type_iiaii]e; 

public; 

// onios methods 
SBJDJ)ECL(APL ♦); 

virtual void Destroy(Boolean aborted=FALSE); 
virtual void deleteObject(Boolean deallocate=FALSE); 
virtual void putObjectlBoolean deallocate=FALSE); 
Type* getDirectType(); 

// - 

SBJD.DECL(char ♦, SB.TYPE.NA.ME * ); 
SB-TYPE-NAME *typejianio(); 
char »id(); 

void prinlOn(ofstreanu'c ); 


92 







class SB_TYPE-NAME . public Object 

{ 

private: 

char ♦tlieJd; 

char ♦the.bEiseJypeicl; 

int the.type.code: 
int the-baiseJype_code; 

TRef ♦theJd-decLdictionary; 

SBJD-DECL-DICTIONARY +id-decLdictionary(); 

public: 

// onios welhods 

SB-TYPE.NAME(APL * ); 

virtual void Destroy!Boolean aborted=FALSE); 

virtual void deleteObjecl(Boolean deallocate=FALSE); 

virtual void pu(Object(Booleaii deallocate=:FALSE); 

Type* getDirectType(); 

//- 

SB.TYPE.NAME(char *,SBJD-DECL.DICTIONARY *); 
virtual Boolean oi>orator == (EntityA: ); 
virtual Boolean operator > (EntityA" ); 

Listlterator decLiteiator(); 
char *id(); 
char *baseJypeJd( ); 
int type.codc(); 
int base-type.code(); 

Boolean recognized!); 
int nuni-decl!); 

void printOn!ofstreaniA' outsireain); 


93 







!)1 







class SB-TYPE.USAGE : public Object. 

{ 

private: 


char ♦the-typeJd: 

TRef ♦the.typejiame; 
int the.times.used; 

public: 

// onios methods 

SB-TYPE.USAGE(APL ♦theAPL); 
virtual void Destroy (Boolean aborted=FALSE); 
virtual void deleteObject(Boolean deallocate=FALSE); 
virtual void putObject(Boolean deaUocate=FALSE); 

SB.TYPE-USAGE(chav *ne\v.typeJd,SB.TYPEJ<AME *ne\v.typejiaiT)e); 
char ♦typeJd(); 
void used(); 
int times_used(): 

Type ♦getDirec*Type(); 

void print On(ofst ream A outstream); 

SB-TYPE.NAME ♦ty| 
char ♦base_typeJd(): 

}; 


Vt.j 


A 







class SB.TYPE.USAGEJ31CT10NARY : public Object 

{ 

private. 

TRef ♦the.dictionarv-by.typeJci; 

TRef ♦the-dictionary-by.times-used; 

TRef »the_dictionary-by-base.type; 

Dictionary ♦dictionary-by-times-used(); 

Dictionary ♦dictionarj -by-typeJd(); 

Dictionary ♦dictionary-by-base-type(); 

public: 

// on/os methods 

SB-TYPE-USAGE-DICTIONAH> (APL ♦). 
virtual void Destroy{Boolean aborted=FALSE); 
virtual void delete01iject(Boolean deallocate=FALSE); 
virtual void putObject( Boolean deallocate=FALSE); 

Type ♦getDirectType(); 

// - 

SB.TYPE-USAGE-DICTIONARYO; 

Boolean add.type(char ♦ty|)eJd,SB-TYPE-i\AME ♦typejiame); 

Boolean add.typefSB-T'i’PE-l'SAGE ♦type-usage); 

Boolean updatelSB-T^’PE-NAME ♦tyi>eJiaine); 

Boolean append(SB.TYPE-USAGE-DICT10NARY ♦); 

void remove-usage(SB-TYPE-VSAGE ♦the-usage); 
int num(); 

Dictionary-Iterator typeJdJterator(): 

Dictionary-Iterator tinies-U.sed-iterator(); 

Dictionarylterator ba.se-typeJfei-ator(); 
void printOn(ofstreaniA- ); 

}: 







class SBJIECOGNIZED.TYPES : public Object 

{ 

// this object uses a data file which follows the following format 
// for its input 

I* - 

case.sensitivity (0 for no, 1 for yes) 

unrecognized.td (le UNRECOGNIZED for Ada. This id is 

automatically asigned to all unrecognized id’s) 
inheritance.id (te base.iype used for Ada) 

generic.type.id (ie genenc.type used for Ada) 

generic.subprogram.id (le generic.procedure used for Ada) 
abstract.data.typc.id (te adt used for Ada) 
array.id (le array used for Ada) 

array.index.id (le index used for Ada) 

ariay.eleiiun1.id (le element used for Ada) 

{ucogmzed.iype.td]* (all other type.id's known to this language 

te INTEGER, POSITIVE etc. used in Ada) 
~ (used to separate the IDs from the rule map) 

rule inatrii where 0 tndiceilcs no mapping 1 indicates yes 

each id entered above the ~ makes up the rows and columns of 
the matrix 

- */ 

private; 

1 Rel *tliejiaiiie.(lictionary: 

Dictionary *nanic.(.lictioiiaiy(); 

TRef *thej-ow.array: 

Array +ro\v.array(): 

int array-size: 

Boolean ca.se_sensiiive: 

char ♦convert.tO-ni)iH'i(char ♦typeJd); 

public: 

// ontos metheids 

SB -R ECOG NIZ E D P E.S (A P L ♦ t he A I'L); 

Type ♦getDirerlTyiH'l); 

virtual void Destroy!Boolean aborted^FALSE); 


f 








virtual void deleteObject( Boolean deaIlocate=FALSE) 
virtual void putObject(Boolean dea!loca(e=FALSE); 

H - 

SBJlECOGNlZED.TYPES(char »fiie); 
int typejiumber(cliar ♦typeJd); 

Boolean map(int mapJn.i>»t map.out); 








// 

// this file coiitaihs all of the ericrnal reterences to the 
II ontos type schemas 

n 


extern Type *SB-LIBRARY-OType; 

extern Type *SB-.VDT-COMPONENT-LIBRARY-OType; 

extern Type ♦SB.OPERATOR-COMPONENTXlBRARY.OType 

extern Type »SB-COMPONENT.OType; 

extern Type ♦SB.COMPONENTJDICTIONARY.OType; 

extern Type *SB.KEYWORD-DICTIONARY-OType; 

extern Type ♦SB.TEXT.OBJECT.OTypc; 

extern Type *SB-^\DT-COMPONENT.OType; 

extern Type ♦SB.OPERATOR-COMPONENT.OType: 

extern Type ♦SB-AOT-Of’ERATOR-OType; 

extern Type ♦SBJD-l)E('L.DlCTIO^’AR^’.OTypo; 

extern Type ♦SBJD-DE('L.OType; 

extern Type ♦SB-T^'PE.^’A^IE,OType; 

extern I'vpe ♦SB.ADT.OPERATOR.DICTIONARY.OType: 

extern Type *SB.EXCEPTION-DlCTIONARY,OType; 

extern Type ♦SB.T'k'PE.l’SAGE.OType. 

extern Type .SB.T\'PE.USA(.E.DlCT10NAR\'-0Type; 

extern Type ♦SB-RECOCJNIZED.T^ PES.OType: 

extern SB.LIBRARY ♦SB.MAIN.LIBRARY; 


« d*iin« DEFAI LT.NAME-SIZE 21 
•define SB.ENRECOG.MZEn.T^'PE 1 
•define SB.BASE.TYPE 2 
•define SBJ.’ENERRlA'PE i 
•define SB.(iENERI('.SEBI’ROC;RAM 1 
•define SB-GE\EM<I('.X'AIT'E •') 

•define SB-ABSI RAt T.DATA.lA PE 6 
•define SB-ARRA^' 7 
•define SB.ARRAY.INDEX 8 


•define SB.ARRAY.EEEMENT 




#include ”shall .hxx" 

U - 

// these defines arc to declare the command line 
II arguments 

H - 

extern "C—'• 

{ . 

int system(char ♦); 

} 


tdsline KWL "kwl" // capssoflhase kwl language out.file 
#define KWL.N 1 // keyword list 

#define KVVQ "kwq" // caps.softbase kwq language in.file out.file 
tdeline K\VQ_N 2 // keyword query (2) 

#define OL "ol" // caps^softhase ol language out.file 
#define OL.N 3 // operator list (ij 

#deline TL "tl" // caps.softhase tl language out.filt 
#define TL,N All type list (-i) 

tdefine CQ "cq" // caps.softbase cq language psdLfile out.file 
#datine CQ.N 5 // component query (.5) 

idslins CA "ca" // caps.softbase ca language 

II psdLfile spec.tn body.in 

•define CA.N fi // component add (6) 

•define CU "cu" // caps.softbase cii language 

II psdLfile spec.in body.in 

•define CU.N 7 // component update (7) 

•define CD "cd" // caps.softbase cd language component .name 
•define CD-N 8 // component delete (8) 

•define CL "cl" // caps.softbase cl language out.fil 
•define CL.N 9 If component list (9) 

•define CGM "cgm" // caps.softbase eg language 
II psdl component map.out 

•define CCM.N 10 // component generate map (10) 

•define ML "ml" // caps.softbase ml language generator table 
•define ML.N 11 // make new library 

•define CV' "cv" // caps.softbase cr language 
II component.name psdl 
II ada.spec ada.body 
•define CV'.N 12 // component new 

•define DL "dl" // caps.softbase dl language 


100 








#defiiie DL-N 13 // detele language library 


#deXine CDIAG "cdiag" // caps^sofibase cdiag language 
// component.name oulfile 

#define CDIAG-N 14 // prini component diagnostics 


#define LOGICAL.DB.NAME "caps_8oftbase_LogDB" 

♦define LIBRARY-PREFIX "SB." 

♦define LIBRARY-SUFFIX "LIBRARY" 

♦define TEMP_ENVIRONMENT "TEMP" 

♦define DEFAULT.TEMP "./" 

♦define NORMALIZE "caps.softbase.normalize " 

♦ifdef ..TURBOC.. 
int linejiumber: 

FILE +yyin: 

♦else 

extern "C—" 

{ 

extern int line.mmihor; // used to report the line number of an error 
extern FILE ♦yvin; // lez input stream 

} 

♦endif 

Type ♦SB.LIBRAR’l'.OType; 

Type *SB.ADT-COMPONENTXIBRARY.OType; 

Type *SB.OPERATOR-COMPONENTi!BRARY.OType; 

Type ♦SB.COMPONENT.OType; 

Type ♦SB.COMPONENTJDlCTlONARY.OType; 


Type ♦SB.KE'^'WORD.DICTIONARY.OType; 

Type ♦SB.TEXT.OBJECT.OType; 

Type ♦SB.ADT-COMPONENT.OType; 

Type ♦SB.OPERATOR.COMPONENT.OType; 

Type ♦SB.ADT-OPERATOR.OType; 

Type ♦SBJD-DECL.DlCTIONARY-OType: 

Type ♦SBJD.DECL-OType; 

Type ♦SB.TYPEJS'AME.OType, 

Type ♦SB.ADT.OPERATOR.DlCTIONARY.OType; 
Type ♦SB.EXCEPTIOA.DICTIONARY-OType; 

Type ♦SB.T'i PE-USAGE-OType; 

Type ♦SB.TYPE.USAGEJDlCTlONARY.OTypo; 
Type ♦SB.REC OGNIZED.TYPES.OType. 


101 




SBXIBRARY ♦SB.MAIN.LIBRARY; 


SB-COMPONENT *YYPARSE-component; // vsed by yyparse to pass the components 

extern yyparse(); 

main(int argc.char +argv[]) 

{ 

int exit-flag; 

void update.db-types(); 

int parse-conin]and(int argc.cliar ♦argvQ): 

Boolean gelJanguage-library(int argc.ohar *argv[]); 

if{OC.open(LOGICAL.DB-NAME)^TRUE) 

{ 

cout < "THE LOGICAL SOFTBASE " < LOGICAUDB-NAME < "OPEN FAILED\n" 
exit(l); 

}; 

int the.operation=parse.conimand(argc.argv); 
if(the.operation^ML-N the.operation^O) 

{ , 

if(!get.language-librarv(aigc,argv)) 

{ 

exit(l); 

}; 

}■. 

update-db-types(); 

switch! the.operatioii) 

case 0: 

{ 

cout < "AN INVALID OPERATION WAS GIVEN TO SB\n”; 
break; 

}; 

case KWLJV: 

{ 

if(argc==4) 

{ 

ofstreani oiitfile(argv[3],ios::noreplace): 
if(outfile) 

{ 

// ouifile was opened successfully 
SB.MAIN XIBRAR’l'—key word-list (out file); 


1(12 





exit_flag=0; 

} 

else 

{ 

cout «: "UNABLE TO OPEN OUTPUT FILE\ii"; 
exit-flag=l: 

} 

else 

{ 

cout "INCORRECT NUMBER OF ARGUMENTS\n"; 
exit jlag=l: 

}; 


break; 

}; 

case K\VQ_N; 

{ 

if(argc==5) 

{ 

ifstream infile(arg\ [3].ios;:nocreafe): 
if( infile) 

{ 

// query file open successful 
ofstream outfile(argv[4),ios;;noreplace); 
ifloutfile) 

{ 

// ouipul file opened successful 

SB-MAIN-LlBRARY—key\vord.query(infile,outfile); 
exit Jlag=0; 

} 

else 

{ 

cout < "UNABLE TO OPEN OUTPUT FILE\n"; 
exit_flag= 1; 

} 

} 

else 

{ 

cout < "UNABLE TO OPEN INPUT FILE\n"; 
exitJlag=l: 

)■■ 

} 

else 

cout < "INCORRECT NUMBER OF ARGUMENTS\n"; 
exitJlag^l; 

}; 


break; 

}: 


103 




case OL-N; 

{ 

if(argc==4) 

ofstream outfile(argv[3],ios;;noreplace); 
if(outfile) 

{ 

// output file opened successfully 

SB31AIN-LIBRARY-*operatorJist(outfile); 

exit.flag=0; 

} 

else 

{ 

cout < "UNABLE TO OPEN INPUT FILE\n"; 
exit_flag=l; 

); 

} 

else 

^ cout < "INCORRECT NUMBER OF ARGUMENTS\n"; 
exit-flag=l; 

}; 

break; 

}; 

case CLJS’: 

{ 

if(argc==4) 

ofstream outfile(argv[3],ios::noreplace); 
if(outfile) 

{ 

// output file opened svccessfully 

SB-M AIN XIBR ARY—component Jist(outfile) 

exit Jiag=0; 

) 

else 

cout < "UNABLE TO OPEN INPUT FILE\n"; 
exit Jlag=l; 

} 

else 

cout < "INCORRECT NUMBER OF ARGUMENTS\n"; 
exit Jlag=l; 

}; 

break; 

}; 

case TLJs': 

{ 


104 



if(argc==4) 

{ 

ofstream outfile{argv[3],ios:;noreplace); 
if(outfile) 

{ 

// output file opened successfully 
SB_MAINXIBRARY—typeJist(outfile); 
exit Jlag=0: 

} 

else 

{ 

coiit -C "UHABLE TO OPES INPUT FILE\n''; 
exit Jlag=l; 

} 

else 

{ 

cout < "INCORRECT NUMBER OF ARGUMENTS\n"; 
exit_flag=l; 

}; 

break; 

}; 

case CQ-N: 

{ 

if(argc==o) 

{ 

yyin=fopen(argv[3]."r"); 

if(vvin5^NULL) 

{ 

// psdl file opened succesfully 
ofstream outfile(argv[4],ios;:noreplace); 
if(outfile) 

// outfilc open so do parse psdLfile 

II nest the transaction so syniar error transaction 

II can be aborted 

get JaiiguageJibrary(argc,argv); 


if(vvparse()==0) 

{ 

// file parsed successfully result is 
II in YYPARSE.component 

if('^'YPARSE.conlponent—»getDirectType()==SB_OPERATOR-COMPONENT .OTj 

{ 

((SB.OPERATOR.COMPONENT ♦)YYPARSE-component)^ 
process-tvpeJnfo(); 

} 

else 

{ 

((SB_ADT-COMPONENT ♦)YYPARSE.component ) — 


103 


r 




process-type JjifoO; 


}; 

SB-MAIN-LIBRARY—‘query (^'YPARSE-component.outfile) 
/ / YYPARSE-componen1->D€stroy(FALSE); 
exit_flag=0; 

} 

else 

{ 

cout < "THERE WAS AN ERROR DURING PARSING 

cout -C argv[3] "\n‘'; 

exitJiag=l; 

}; 


} 

else 

{ 

cout. < "UNABLE TO OPEN OUTPUT FILE\n"; 
exit_flag=l; 

}; 

} 

else 

cout < "UNABLE TO OPEN INPUT FILE\n"; 
exitJlag=l: 

): 

} 

else 

{ 

cout < "INCORRECT NUMBER OF ARGUMENTS\n"; 
exit Jlag=l; 

}. 

break; 


case CAj\. 

{ 

if(argc==6) 

{ 

yyin=fopen(argv[3],"r"); 

if(yyin#NULL) 

{ 

// psd! file opened succesfully 
ifstream spec Jn(argv[4],ios:;nocreate); 
if(specJn) 

{ 

// spec.VI file open so do parse psdl.file 
ifstream bodyJn(argv[5].ios;;noreplace); 
if(body.in) 

{ 

// all files successfully open so start transaction 


106 




// nest the transacUons so syntax errors can 
// b( aborted 


getJanguageJibrary(argc,argv); 
update-db_types(); 

if(yyparse()==0) 

{ 

// file parsed successfully result is 

II in YYPARSE.component so add the psdl to it 

II and the spec and body 

ifstream psdl Jn( argv[3] ,ios: :nocreate); 

\TPARSE-component—►add.text(psdlJn,specJn,bodyJn); 

// now normalize the formal description if there is 
II one 

i f( s (r 1 en (Y Y PA RS E .com poneii t -- 

fonnaLdescripiion()—*text())>0) 

^ dial- *t.enip-dir = geienv(TEMP.ENVIRONMENT); 
if (temp-dir == NULL) 

{ 

temp-dir = new char[strlen(DEFAULT.TEMP) + 1]; 
strcpy(teinp-dir, DEFAULT .TEMP); 

}; 

char ♦temp-file = tempnam(temp.dir, "ojb"); 
char ♦errorJile = tempnam(temp.dir,"nrm"); 

ostrstream commancLbuffer; 
ostrstream remove-buffer; 
ostrstream objJile.buffer; 
ostrstream norni-file-buffer; 

obj-file-buffer < temp-file < ".obj" < ends; 
norm-file-buffer < temp-file < ".obj .norm" < ends; 

char ♦obj-file=obj-file-buffer str(); 
char ♦norm-file=:norm-file-buffer.str(); 

command-buffer <C NORMALIZE: 
command-buffer <1; obj.file " "; 
command-buffer <C error-file ends; 

remove-buffer <C "rm " temp.file <C ".♦"; 
remove-buffer •C ends; 
ofstream formal-desc(obj-file); 

YY- 

PARSE -Component —'formaLdescriptionO—>texl(formaLdesc); 

formal-desc .close(); 

cliar ♦command=comman<J-buffer.str(); 
iiit status Jlag=system( comm and); 
if{statu.s_flag==0) 


107 




// snccsessful so get the norm file 
ifstream norni.in(norm-file); 
if{normJn) 

{ 

// file was there so append it 
YYPARSE.component—► 
norni-formaL description ()—► 
append(norm jn); 


» 


*)YYPA RSE.component)— 


♦ )\'YPARSE-coniponent)— 


if(^'YPARSE-component—►getDirectType()== 
SB-OPERATOR.COMPONENT-OType) 

{ 

((SB.OPERATOR.COMPONENT 
process Jtype jnfo(); 

} 

else 

{ 

((SB^DT.COMPONENT 
process Jtype jnfo(); 

}; 


if(SB.MAIN.LIBRARY^ 

querv(YYTARSE.component—►componentJiame())==NULL) 

{ 

// component not already in library so store it 
OC-transactionStart(); 

YYPARSE-component—►putObjectO; 

Boolean add-status=FALSE; 

addj5tatus=SB_MAINilBRARY—►add(YYPARSE.componen 
if(addjstatus==TRUE) 

{ 

OC-transactionCommit(); 

exit-flag=0; 

} 

else 

{ 

exit-flag=l; 

cout < "UKABLE TO ADD COMPOKEST 

cout «C ^ 

\'YPARSE.component—component .name(); 

cout < "TO MAIN LIBRARY\n"; 

OC-transaction Abort(); 

} 

} 

else 

{ 

cout < "COMPONENT " < 


108 






endl: 


\'YPARSE.component—*componentjiame(); 
cout < " IS ALREADY IH MAIK LIBRARY "< 


♦ )\"\^PARSE_compoiie]it)—- 


cout < "UHABLE TO ADD IT AGAIN \n"; 
exit-flag=l; 

}; 

} 

else 

{ 

cout < "ERROR NORMALIZING AXI0MS\n"; 
exit_flag=l; 

}. 

} 

else 

{ 

cout < "ERROR NORMALIZING AXIOMS\n"; 
ifstreain error jstream(errorJile); 
if(error jstream) 

{ 

cliar ♦thejine=new char[256]; 
while( lerror ^stream .eof()) 

{ 

error j5tream.getline( the Jine,255); 
cout theJine «C endl; 
error jstream ^ ws; 

} 

else 

{ 

cout < "COULD NOT OPEN NORMALIZE"; 
cout < " ERROR FILE\n"; 

}■ 

exil_flag=l; 

}; 

} 

else 

{ 

if(YYPARSE.component—►getDirectType()== 
SB.OPERATOR.COMPONENT-OTvpe) 

{ 

((SB-OPERATOR-COMPONENT 
process-tvpe-info(); 

} 

else 

{ 

((SB-ADT-COMPONENT ♦)YYPARSE-component)— 
process-type -info(); 

}; 


if( SB-MAIN -LI BRA RY— 


lO'l 





queryC^’^'^PARSE-component—►component Jiame())==NULL) 

{ 

// component not already in library so store it 
OC-transactionStart(); 

\'^'PARSE-component—♦putObjectO; 

Boolean addj5tatus=FALSE; 

add^tatus=SB_MAINXIBRARY—►add(^'TPARSE-component); 
if(add^tatus==TRUE) 

{ 

OC-transactionCommit(); 

exit-flag=0; 

} 

else 

{ 

exit Jlag=l; 

cout < "UNABLE TO ADD COMPONENT 

cout -C 

'\'A'PARSE-coniponent—component-naine(); 

cout < "TO MAIN LIBRARY\n"; 

OC-transactionAbort(); 

} 

} 

else 

{ 

cout < "COMPONENT " < 

V'YPARSE.component—►componentmame(); 
cout < " IS ALREADY IN MAIN LIBRARY "-Cendl; 

cout < "UNABLE TO ADD IT AGAIN \n"; 
exit_flag=l; 

): 

}; 

} 

else 

{ 

cout <c "THERE WAS AN ERROR DURING PARSING 
cout < argv[3] < "\n"; 
exit-flag—1: 

}: 


} 

else 

{ 

cout < "UNABLE TO OPEN THE IMPLEMENTATION BODY FILE\n"; 
exit.flag=l; 

}: 

} 

else 

{ 

cout < "UNABLE TO THE IMPLEMENTATION SPEC FILE\n"; 
exit-flag= 1. 


110 






): 

} 

else 

{ 

cout < "UNABLE TO OPEN PSDL FILE\n"; 
exit Jlag=l: 

}; 

} 

else 

{ 

cout < "INCORRECT NUMBER OF ARGUMENTS\n"; 
exit-flag=l; 

}; 

break; 

}; 

case ML_N: 

{ 

if(argc==-l) 

{ 

char ♦language-iiaiiie=argv[2]: 

char ♦liliraiA.iiaiiie=new char[strlen(language_name)+ 

slrlen(LIBRARY.PREFlX)+ 

strlen(LIBRARY^UFFlX)+l]; 

St rcpy( library jianie, LIBRARY-PREFIX); 

St rcat( library jiaine.language.naine); 

St rcat (library jianie.LI BRA RY.su FFIX); 

OC.traiisactioiiStart(): 

SBJSIAINXIBRARY=uew SB-LIBRARY(libraryjiame,argv[3]); 
SB.MAINJLIBRARY-putObjectO; 

OC-traiisactioiiC'oiiiniit(): 
exit Jlag=0; 

} 

else 

{ 

cout < "INCORRECT NUMBER OF ARGUMENTS\n"; 
exit Jiag=l; 

}. 

break; 


}; 

case DL.N. 

{ 

if(argc ==3) 

{ 

OC-transact ionSt art(); 

SB.MAIN JABRARY—deleteObject(TRUE); 
OC-traiisaftionC'ommit(); 


111 


I 


w 




exit Jlag=0; 

} 

else 

^ cout < "INCORRECT NUMBER OF ARGUMENTS\n"; 
exit-flag=l; 

}; 

break; 

); 

case C\-N . 

{ 

if(argc==7) 

{ 


ofslream pscll.out(argv[4],ios::norei>lace); 
if(psdLout) 

{ 

ofstream spec.out (argylS],ios:;noreplace); 
if( spec .out) 

{ 

ofst ream body-OUt(argv[6],ios::noreplace); 
if(bod\ .out) 

{ 

getJanguageJibrary(argc,argv); 

update.db.types(); 

SB-COMPONENT 

♦ the.component=SB.MAINXIBRARY—query(argv(3]); 

if( t lie.com ponent NU L L) 

{ 

// compoiietil found so dump all streams 

(tlie.component—*psdl.text())—»text(psdlj3ut); 

(t he.com poiieni—imp.spec.text())—►text(specj3ut); 

(the.component—“imp-body-text())—>text(body-out): 

psdl.out.closeO; 

spec.out.closef); 

body.out.cioseO; 

exit-flag=0; 

} 

else 

{ 

com < "COMPONENT " -C argv[3] <C " NOT FOUND\n"; 
exit.flag=l; 

}• 

} 

else 

cout < "UNABLE TO OPEN THE IMPLEMENTATION BODY FILE\n"; 
exlt.flag=l; 

}• 


112 


} 

else 

{ 

cout <c "UNABLE TO OPEN THE IMPLEMENTATION SPEC FILE\n"; 
exit-flag=l', 

} 

else 

{ 

cout < "UNABLE TO OPEN PSDL FILE\n"; 
exit Jlag=l: 

}; 

} 

else 

{ 

cout <c "INCORRECT NUMBER OF ARGUMENTS\n"; 

exit Jlag= 1; 

}: 

break: 

case CD.N: 

{ 

if(argf = = 1) 

{ 


SB.rOMPONENT ♦tlie.coiiipoiiout=SB-MAlNXlBRARY—query(argv[3]); 
if(tlie.coniiionenl ^M'LL) 

{ 

// cowpoiKul found so outpu! tis sources to backup 
II this IS ulicrc the SCCS code goes for the.componeiii 
11 (till .coiiii>oii(iil->psdlJ(Tt( ))->text(psdLout): 

11 (the-COW poll (nl->tmp.spfr .text ())‘>text(spcc.out); 

11 (th( .foiiipoiK iit->iiiip.bodgJert( ))-> text (body.out): 

11 psdLoiil.cloxI): 

11 spt (-oiil.dosi (): 

IIbody.out (losf(): 

OC .1 raiisact loiiStart (): 

// iioir d(Ut( the coiiipoiiciit from the library 

SB -M AIN XIBH A R^’ —delet e.coniponent (t lie.coniponent); 

exit Jlag=0; 

OC.t ransac(iouC'ommit(); 

) 

else 

{ 

cout < "COMPONENT " < argv[3] < " NOT FOUND\n": 
exit Jlag=l; 

}: 


} 

els€' 

{ 


li:t 




cout < "INCORRECT NUMBER OF ARGUMENTS\n''; 
exit_flag=l; 

}. 

break; 

}; 

case CDIAG-N: 

{ 

if(argc==o) 

{ 

ofslream outfile(argv[4],ios::noreplace); 
if(outfile) 

{ 

// oulfile was opened successfully 

SB-COMPONENT ♦fhe-coiuponent=SB-MAlN-LIBRARY^query(argv[3]); 
if(tlie-Coniponeiit9^NI.'LL) 

{ 

// cowpone 111 found so oulpuis ils diagnostics 
t iie.coiiiponeiit —priiuOii(outfile); 

} 

else 

< 

rout < "COMPONENT " < argv(3] < " NOT FOUND\n"; 
e.\it.flag= 1; 


) 

else 

cout < "UNABLE TO OPEN OUTPUT FILE\n"; 
c.\it_nag=l; 


} 

else 

{ 

cout < "INCORRECT NUMBER OF ARGUMENTS\n"; 
exit Jlag= 1; 

}; 

break; 

}; 


}. 

OC-close(); 
exit(exitJlag): 

}: 

iiit yyerror(cliar ♦s) 


111 









{ 

cout -C "\n" s <C " on line number " •C linejiumber; 

cout < "\n": 

return(O): 

}; 

void update_clb-tvpes() 

{ 


SBXIBRARY.OType=(Type ♦) OCJookup("SBXIBRARY"); 
SB-COMPONENT.OType=(Type ♦) OC Jookup{"SB-COMPONENT"); 
SB-ADT-COMPONENT-OType=(Type ♦) OC Jookup("SB-ADT_COMPO»ElfT"); 
SBJDJ)ECL-DlCTIONARY_OType=(Type ♦) OCJookup("SB_IDJ)ECL.DICTIOKARY"); 
SBJD.DECL-OType=(Type ♦) 0CJookup("SB.IDJ5ECL"); 

SB.TYPE_NAME.OType=(Type ♦) OCJookup("SB-TYPE.NAME"); 
SB_ADT-0PERAT0R-DICT10NARY.0Type=(Type ♦) 
OCJookupC'SB-ADT-OPERATOILDICTIONARY"); 

SB-ADT-OPERATOR-OType=(Type ♦) OCJookup("SBJlDT_DPERATOR"); 
SB-OPERATOR-COMPONEi\T-6Type=(Type ♦) OCJookup(”SB-0PERAT0ILC0MP0NENT"); 
SBJEXCEPTIONJDICTlONARY.OType=(Type ♦) OC Jookup(*’SB_EXCEPTION.DICTIONARY") 
SB.TEXT.OBJECT.OType=(Type *) OC Jookup("SB.TEXT-OBJECT"); 
SBJvEYVVORD.DICTl6NARY.OType=(Type *) OCJookup("SBJ(EYWORD_DICTIONARY"); 
SB.COMPONENTJDICTIONARY-OType=:(Type *) 
OCJookupC'SB.COMPOMENT-DICTIONARY"); 

SB-ADT-COMPONENTXlBRARY.OType=(Type ♦) 
OCJookupC'SBJlDT.COMPOKENT-LIBRARY"); 

SB.OPERATOR-COMPONENTXIBRARY.OType=(Type *) 
OCJookupC'SB-OPEPATOR-COMPONEIIT.LIBRARY"); 

SB-TYPE.USAGE.OType=(Type *)OCJookiip{’‘SB.TYPE.USAGE"); 

SB-TYPE-USAGEJ)ICTIOi\ARY.OType=(Type 
♦ )OCJookup( "SB-TYPE-USAGELDICTIONARY"); 

SB-RECOGNlZED.T^'PES.OType=(Type ♦)OCJookup(”SB_RECDGNIZED-TYPES"); 




iiit parse-coniinaiKl(int argc. char *argv[]) 

{ 

iiit return-valnp=0: 
if(argc >2) 

if(strcnip(argv[l],K\VL)==0) 

{ 

retiirn_value=K\VL.N; 

} 

else if(strcmp(argv[l].K\\'Q)==0) 

{ 

retuni.valiip=K\\’Q-N: 

} 


115 







else if(strcmp(argv[I],OL)==0) 

{ 

return .value=OL_N; 

} 

else if(strcnip(argv[l].TL)==0) 

{ 

return .value=TL_N; 

} 

else if(strcmp(argv[l],CQ)==0) 

{ 

return.value=CQ-N; 

} 

else if(strcmp(argv[l],CA)==0) 

{ 

return .val ue= C A _N; 

} 

else if(strcmp(argv[l],Cl’)==0) 

{ 

return .value=CU -N; 

} 

else if(strcmp(argv[l],CD)==0) 

{ 

return .value=CD_N; 

} 

else if(strcmp(argv[l],CL)==0) 

{ 

return-value=CL.N; 

} 

else if(strcmp(argv[l],CGM)==0) 

{ 

return.value=CGM-N; 

} 

else if(strcmp(argv[l],ML)==0) 

{ 

return-value=ML.N; 

} 

else if(St rc 111 p( argV [ 1 ],CA')==0) 

{ 

return-value=C\'-N; 

} , 

else if(strcmp(argv[l],DL)==0) 

{ 

return .value=DL-N: 

} 

else if(strcmp(argv[l],CDIAG)==0) 

{ 

reiurn.val\)e=CDIAG JS’; 

} 

} 

return ret urn.value; 

}: 


116 








Boolean getJanguageJibrarv(iiit argc,char ♦argvQ) 


Boolean return.flag=FALSE; 

if(argc > 0) 

{ 

char *language_name=argv[2]; 


char *libraryjiame=new char[strlen(languagejiame)+ 

strlen(LIBRARYJREFIX)+ 

str!en(LIBRARY^UFFIX)+l]; 


strcpy (library Jiame, LIBRARY-PREFIX); 

St rcat( library Jianie.language.name); 
strcat(library_name,LIBRAR^'.SUFFIX); 

// ASSIGN THE GLOBAL VARIABLE SB-MAIN.LIBRARY THE VALUE OF THE 
LIBRARY 

SB_MA1N.LIBRARY=(SB.LIBRARY *) OCJookup(library-name); 

if(SB.MAlN.LlBRARY==NULL) 

{ 

cout < "LIBRARY FOR LANGUAGE 

cout -C language-name " NOT F0UND\n"; 

return .flag=FALSE; 

} 

else 

{ 

returnJlag=TRUE; 

}; 

} 

else 

{ 

cout « "INCORRECT NUMBER OF ARGUMENTS\n"; 
return return-flag: 

}; 


117 








# include ” shall. hxx 


# include’’sbextern.h” 

SB-ADT-COMPONENT::SB^DT.COMPONENT(APL ♦theAPL); 
SB.COMPONENT(theAPL) 

{ 

}; 

SBjVDT.COMPONENT;:SBj^DT.COMPONENT (char ^id) : SB-COMPONENT(id) 

{ 

SB-TYPE_US AGE-DICTION ARY ♦new.adt.usage=new 
SB.TYPE.USAGEJDICTIONARYO; 
the .ad t .usage=new jad I .usage—* fi ndT Ref(); 

SB.ADT.OPERATORJDICTIONARY *new.operatorjspecs-new 
SB.ADT.OPERATOR.DlL nONARYO; 


the.operator.specs=new japerator .specs—findTRef(); 

}; 

void SBjVDT.COMPONENT::inseit^dt.usage(SB.TYPE.USAGEJDICTIONARY* 
new.adt.usage) 

adt.usage{)—append(new jdt .usage); 

}; 

void SBJVDT.COMPONENT;:insert.operators(SBj\DT.OPERATORDICTIONARY* 
new .operators) 

{ 

operator .specs()—append( new xiperators); 

}; 

void SB.ADT.COiMPONENT::Destrov(Booiean aborted) 

{ 

adt.usageO—Destroy (aborted); 

operator.specs()—Destroy(aborted); 

delete thexidt.usage; 
delete the.operator.specs; 

S B.COM PO N ENT:: Destroy (a Ijort cd); 

}; 

void SB.ADT.COiMPONEi\T::deleteObject(Boolean deallocate) 


118 








adt.usageO—deleteObjecf (FALSE); 
operator ^pecs()—*deleteObject( FALSE); 

SB.COMPONENT: ;deleteObject( deallocate); 

}; 

void SB_ADT.COMPONENT;:putObject(Boolean deallocate) 

{ 

adt-usage()—>putObject( deallocate); 
operator.specs()—>putObject(dealIocate); 
SB-COMPONENT;:put Object (deallocate); 


}; 

SB-TYPE.USAGEJDICTIONAR')’ *SB.ADT_COMPONENT;:adt.usage() 

{ 

return (SB.TYPE.USAGE.DICTIONARY ♦)(the_adt.usage—‘BindingO); 

}; 

SBJVDT.OPERATOR-DICTIONARY *SB.ADT-COMPONENT;:operator.specs() 

{ 

return (SBj\DT-OPERATOR.DICTIONARY *)(the.operatorjspecs-*Binding()); 

}; 

Type *SB.ADT.COMPONENT::getDirectTvpe() 

{ 

return SBJtDT.COMPONENT.OTvpe; 

}; 


void SB.ADT-COiMPONENT:;piintOii(ofstreamA: outstream) 

{ 

outstream < "\nOUTPUTIHG THE CONTENTS OF DATA TYPE "; 
outstream C this—♦compoueiiLname() «C ":\n\n"; 

outstream "num unrecognized types " •C nurruunrecognized-typesO <C 
outstream < "GENERIC SPECS\n"; 

SB-COMPONEN'T::generic.usage()—‘printOn(outstream); 
outstream < "\nTYPE SPECS\n"; 
adt.usage()—*printOii(outstream); 

outstream C "\nOPERATOR SPECS\n". 
operator .specs()-^printOn(out St ream); 

outstream "\n\n": 


}: 


119 







int SB_ADT.COMPONENT;:nuni.adt.operators() 

{ 

return operator.specs()—►num(); 

}; 

int SBJiDT.COMPONENT;;lolalinputs() 

{ 

return operator3pecs()-+totalJnpufs(); 

}: 

int SBJ^DT.COMPONENT:;num-adts() 

{ 

return adt.usage()—num(); 

}; 


int SB_ADT-COMPONENT::totaLoutputs() 

{ 

return operator_specs()—totaLoutputs(); 

}; 

Dictionarylterator SB_A DT.COM PONENT:;adt .operator jterator() 

{ 

return operator-specs!)—iterator!); 

}; 

Dictionarylterator SB_ADT.COMPONENT::adtJterator() 

{ 

return adt.usage!)—tvpe jditerator!); 

}; 

Boolean SB jVDT.COM PON ENT; :process.ivpejnfo() 

{ 

// iell each opcralor 1o ripdaic ils type vsage lists 
// they iulurii update the adt lists 

Dictionarylterator next-operator=adt.operatoriterator!); 
while!next.operator.moreDat a()) 

{ 

((SB.ADT.OPERATOR ♦)!Entity ♦)next.operator())—* 
process .type info! this); 

}; 

return TRUE: 

}; 

int SB_ADT-COMPONE\T;;num.generic.tvpes!) 

{ . 

int thejiuni^O; 


1-20 





Dictionary Herat or next.operator=aclt_operator Jterator(); 
while(next-operator.moreData()) 

{ 

the_num=thejium+ 

((SB-ADT-OPERATOR +)(Entity ♦)next-operator())—* 
nuni-generic-tvpes(); 

}; 


// now get an iterator for the adt generics list 


Dictionary Iterator next Jd=SB-COMPONENT::genericjusage()—► 
typeJdJteratorO; 

while(nextJd.inoreData()) 

{ 

SB-TYPE-USAGE ♦tlie.usage=(SB-TYPE-USAGE*)(Entity ♦)nextJd(); 
SB-TYPE-NAME *tlie-typejiame:=tlie-usage—type-name(); 
if(the-t\pe-naine—tvpe-code()==SB-GENERlC-TYPE) 

{ 

tliejiuni=tlie-num++; 

}; 


}; 

return thejium: 

}; 

Boolean SB-ADT-COMPONENT::filter(SB-ADT-COMPONENT ♦library-unit) 

{ 

// (‘PVh additional filler operations to the library unit 
//to see if the component can be rejected. True means 
II that it may still be a match. False indicates no match 

return TREE; 

}; 


121 






# include ”shall.hxx” 


# include "sbextern.h" 


SB-ADT-COMPONENTXIBRARY;:SBj^DT.COMPONENTXIBRARY(APL *theAPL) 
Object(theAPL) 

{ 

}; 


SBJ^DT-C0MP0NENTXIBRARY::SB^DT.C0MP0NENTXIBRARY() : Object() 

{ 


SB.COMPONENTJDICTIONARY ♦new_adt_component_dictionary= 
new SB.COMPONENTJ)ICTIONARY(); 


the.adt.component.dict.ionary= 

new.adt.component.dictionary—findTRef(); 

Dictionary *neH'.main.library=new Dictionary(OC-integer, 

OC.dictionary, 

TRUE, 

FALSE); 

thejTiain.library=ne\v.main-library —findTRef(); 


}; 

void SBJ^DT.COMPONENTJ.IBRARY::Destrov(Boolean aborted) 

{ 

adl.component.dictionaryO—Destroy (aborted); 

// now must iterate through the multi-attribute tree of 
// dictionaryies to destroy each one of them 

Dictionary ♦byjium.adts; 

Dictionary ♦by.num.operators; 

Dictionary ♦byjiuni.totaLinputs; 

Dictionary ♦byjium.generics; 

Dictionary ♦by.nuni.total.outputs; 

Dictionary +leaf_dictionary; 

byjium-adts=main-library(); 

Dictionarylterator next_byjium-adt(by-num-adts); 

while(next-bv.num.adt .nioreData()) 

{ 

by.num-operators=( Dictionary ♦)(Entity ♦)next.byjiuin.adt(); 

// components must hare at least as many operators as the query 


vn 







Diction aryl terat or next-byjium.operators(by_num-operators); 

while(next.by.num.operators.moreData()) 

{ 

by.num.generics=( Dictionary ♦)(Entity ♦) 
next-by_num-operators(); 

Dictionary Iterator next_byjium.generics(by Jium.generics); 

while( next .bv.num.generics.moreData()) 

{ 


by_nuni,totaLoutputs=(Dictionary ♦)(Entity *) 
next .by jium.generics(); 

Dictionary Iterator 

nexf-b}-jjuin.lotaLoutpiit.s(byjium.totaLoutputs); 

while(next.bv.nuni.totaLoutputs.moreData()) 

{ 


by-niiiTi-total.inputs=(Dictionary *)(Entity ♦) 
next.by jium.total.outputsO; 

Dictionarylterator 

next.by juiin.totaLinputs(by.num-totaLinputs); 

while(next.bv.num-totaLinputs.moreData()) 

{ 

leaf.dict ionary={ Diet ionary ♦)( Entit y ♦) 
next.byjium-total-inputs(); 

leaf.dict ionary—Destroy(aborted); 


by.iuim.tolal.inputs—Destroy(aborted); 


by . nuni.t ot al.ou I i>uts—* Destroy (aborted); 


}; 

by Jiuni.generics— Dost rov( abort ed); 

}; 

b V Jiu ni.ad t s— Dest roy ( a b or t ed): 

}; ’ 


delete the.adf.component.diet ionary. 
delete tliejiiain.library; 


Object:: Dest roy (aborted); 






void SB^DT.COMPONENTXIBRARY::deleteObject(Boolean deallocate) 

{ 

adt.coniponent.dictionaryO—►deleteObject(deallocate); 

// now must iterate through, the multi-attribute tree of 
II dictionaryies to destroy each one of them 

Dictionary ♦byjium.adts; 

Dictionary ♦by.nuni-operators; 

Dictionary *by-nuni_totalJnputs; 

Dictionary ♦by.num-generics; 

Dictionary ♦by.num.totaLoutputs; 

Dictionary ♦leaf.dictionary; 

by-nuni-adts=main-library(); 

Dictionarylterator next-byjiuiii.adt(by-num-adts); 

while(next.by-num-adt.moreDataO) 

{ 

by_num-operators=(Dictionary ♦)(Entity ♦)next.byjium.adt(); 

// components must have at least as many operators as the query 

Dictionarylterator next.byjium-operators(by_num-operators); 

while(next,by.num.operators.moreData()) 

{ 

byjium_generics=(Dictionary *)(Entity ♦) 
nexl-by Jiuin.operators(); 

Dictionarylterator next.by-num-generics(by_num-generics); 

while(next-by_num-generics.moreData()) 

{ 


by_nuni.totaLoutputs=(Dictionary *)(Entity +) 
next-by_num-generics(); 

Dictionarylterator 

next-byjium-totaLoutputs(byjiuni.totaLoutputs); 

while(next.bv.nun].totaLoutputs.nioreData()) 

{ 


byjium.totaLinputs=(Dictionary *)(Entity ♦) 
iiext-by jiuni-totaLoutputs(); 

Dictionarylterator 

nextJjyjinm-total-inputsl by.num.totaLinputs); 
while(nexl Jiy_nnm-totaLinputs.nioreData()) 


121 






{ 

leaf.dictionary=(Dictionary ♦)(Entity ♦) 
next-byjium_total.inputs(); 

leaf-dictionary—i^cleleteObject( FALSE); 
byjium.totaLinputs—»deleteObject(FALSE); 

}; 

by-num_totaLoutputs—*deleteObject( FALSE); 

}; 

by_num.generics—*deleteObject(FALSE); 

}; 

by _nuni.adts—'deleteObject( FALSE); 

Object ;:deleteObject( deallocate); 

}; 

void SB-ADT.COMPONENT.LIERARY;;putObiect(Boolean deallocate) 

adt.coniponent.dictionaryO—Diet ionary :;putObject(deallocate); 
mainJibraryO—putObject(deallocate); 

Object ;:put Object (deallocate): 


Type ♦SB-ADT.COMPONENTXIBRARY::getDirectTvpe() 

{ 

return SB./\DT.COMPONENTXIBRARY.OType; 

}; 

SB-COMPONENT-DICTIONAR^' 

♦SB.ADT-COMPONENTXIBRARY::adt.component-dictionarv() 

{ 

return (SB-COMPONENT.DICTIONARY ♦)(Entity *) 
tlie.adt.component-dictionary—Binding!); 

}; 

Dictionary *SB-fVDT-COMPONENTXlBRARY:;niain-library() 

{ 

return (Dictionary ♦)(Entitv *)tlie-niain-library—^BindingO; 

}; 


Boolean SB-ADT-COMPO\ENTXlBRARY:;add(SB^DT-COMPONENT ♦new-component) 

{ 

Boolean retnrn-flag=TRl'E: 


125 




r 



Dictionary ♦byjiuin-adts; 

Dictionary ♦by.nuni-operators; 

Dictionary *by_num-totaLinputs; 

Dictionary ♦byjiuni-generics; 

Dictionary ♦byjium-total.outputs; 

Dictionary ♦leaf.dictionary; 

adt_component.dictionary()—*add(ne\v.coniponent); 
adt-component.dictionary ()—^Dictionary; :putObject(); 

// insert into the component dictionary was snccessfuU 
11 so insert it into the library 

II get the dictionary for the number of adt 's 

by_num-adts=main-library(): 

// now find the dictionary for adt.operators 

if(by_nuni.adts—islndex(ne\v_component^iium_adts())) 

{ 

by-num.operators=( Dictionary ♦)(Entity ♦)(*by.num-adts) 
[new.component—'nuin.adts()]; 

} 

else 

{ 

byjium-operators=new Dictionary(OC-integer, 

OC-dictionary, 

TRUE, 

FALSE); 

by Jium.adts—‘Insert (new.component — 
nuni.adts(). 
by .mini .opera t ors); 


}; 


// have correct by.num.opeivior dictionary so get the 
II generic types diet. 

if( by .num-operators—islndex( new.component — 

n u m.ad t .operators())) 

{ 

by.num.generics=(Dictionary *)(Entity *) 
(♦byjium.operators) 

[ new.component — 
n«m.adt.operators()]; 

} 

else 


126 





{ 

byjiiini.geiierics=new Dictionary(OCJnteger, 

OC-dictionary, 

TRUE, 

FALSE); 


byjiuni-operators—Insert (new.component— 

nu m-adt-operators(), 
byjiuni-generics); 

}; 

// goi the genertcs dictionary so get the total base 
II types dictionary 

if(by.num.generics—isIiKlex( new .component — 

iium.geneiic_tvpes())==TRUE) 

{ 

byJium-total.ontputs=(Dictionary ♦)(Entity ♦) 

(♦by Jium.generics) 

[new.coinponent—mim-generic-types()]; 

} 

else 

{ 

byjium.totaLoutputs=new Dictionary(OCJnteger, 

OC-dictionary, 

TRUE. 

FALSE); 

by Jiuni-generics—Insert (new.component — 

num.generic.l ypes(), 
liy jtu m.t otaLou t puts); 




if( by .num. total-outputs— 

islndex(new .component—total.output.s( ))==TRUE) 

{ 

byjium-totaI.inputs=(Dictionary ♦)(Entity ♦) 

(♦by Jium.total-outputs) 

[new-component—total-outputs()]; 

} 

else 

{ 

by-num-total.inputs=iiew Dictionary(OCJnteger, 

OC-dictionary, 

TRUE, 


127 






TRUE); 


byjiuiii-totaLoutputs—Insert (new .component— 

total.outputs(), 

byjinm.total.inputs); 


}; 


if(by.num.totaLinputs— 

isIndex(new.component—total.inputs())==TRUE) 

{ 

leaf.dictionary=(Dictionary ♦)( Entity ♦) 

(*by Jium.lotal.inputs) 

[new.component—total-input s()]; 

} 

else 

leaf.dictionary=iiew Dictionary(OC-String. 

SB-ADT.COMPONENT.OType, 

FALSE, 

FALSE); 

by jiunutotaLinputs—Insert (new.component — 

total Jnputs(). 
leaf.dictionary); 


}; 

// have to leaf dictionary so now insert the component into it 

leaf.dictionary—Insert (new .component—component Jiame(), 

new.component); 


byjium.adts—putObject(); 
byjium.operators—pulObjeci (). 
byjium.total.inputs—pulOI)ject(); 
by jnim.generics—putObject(); 
by.num.total.out puts—put Object (); 
leaf.dictionary—put01>ject();; 

return returnJIag. 

}; 

void SBJVDT.COMPONENTXIBRARY::delete.component(SBJVDT-COMPONENT 
♦ the.ccmponcnt) 

{ 


Dictionary *by.num-aflls; 
Dictionary ♦In .nuin- 0 |)erators: 






Dictionary ♦ by.num.tot aLin]iut s; 
Dictionary ♦byjium.generics; 
Dictionary ♦by.nuni_totaLout]iuts; 
Diction'ry ♦leaf-dictionary; 


adt-component.dictionary()—Remove(the-component—‘componentjiame 
adt.component.dictionary ()—Dictionary:;putObject(); 


by_num-adts=main_library(); 

// now find the dictionary for adt.operators 

if(bv-num-adts—isIndex(the-COinponent—*num-adts())) 

by _num-operators=( Diet ionary ♦)( Entity +)(+by.num.adts) 
[the.component—mnn.ad(s()]; 

// have correct hy.num.operator dictionary so get the 
II generic types diet. 


if( by-num.operators—islndex( the.component—* 

num.adt .operators())) 


{ 


by.num.generics=(Dictionary ♦)(Entity ♦) 
(♦by jium.operators) 

[the.component — 
num.adl-operators()]: 


// got the generics dictionary so get the total base 
II types dictionary 


if(by-mim.generics—isl ndex( the.component—► 

imm-generic-types())==TRUE) 

{ 

by-nnm.total.outputs=(Dictionary ♦)(Entity ♦) 

(♦by jium.geneiics) 

[the.component—num.generic.types()]; 


if(by.num.totaLoutputs— 

isIndex(the-component—*total.outputs())==TRUE) 

{ 

byj)iim.total.input.s=(Djctionary ♦)(Entity ♦) 

(♦by jium.total.outputs) 

[tlie.romponent— *total-OUtputs()]; 


i f( by.n u m. t ot a 1. in pu I s— 

islndex( the.component—total-inputs())==TRUE) 

{ 

leaf.dictionary=( Diet ionary ♦)(Entity ♦) 





(♦byjium.total.inputs) 

[the.component—>totaLinputs()]; 

// have 1o leaf dictionary 

leaf.dictionary—►Remove(the_component^component-name()); 
leaf-dictionary—*putObject(); 
if(leaf_dictionary—►Cardinality ()==0) 

{ 

byjium.totaLinputs—► 

Remove(the-component—♦total.inputsO); 
byjium.totaLinputs—►putObject(); 
leaf.dictionary—»deleteObject(TRUE); 

if(by.num.totaLinputs—»Cardinality()==0) 

{ 

byjium.totaLoutpnts—► 

Reniove(the-coniponent—♦total.outputsO); 
byjium.totaLoutputs—►putObject(); 
by.nuni_totaLinputs—►deleteObject(TRUE); 

if(bv.num-totaLoutputs—►Cardinality()==0) 

by-nuni-generics—* 

Remove! the.component—*num-generic_types()); 
byjium.generics—*putObject(); 
byjium-totaLoutputs—»deleteObject(TRUE); 

if(bv.num-generics—>Cardinality()==0) 

{■ 

by_num.operators—» 

Remove(the.component—►num.adt.operatorsO'; 
byjiuni.operators—►putObject(); 
byjium.generics—►deleteObjectO; 

if(bv.num.operators—»Cardinality()==0) 

{ 

byjium.adts—► 

Remove(the.component—►num.adtsO); 
byjium-adts—►putObject(); 
byjium-operators—►deleteObject(); 


}; 


}; 






130 







}; 

}; 

}; 

}•. 

}; 

SB.COMPONENTJDICTIONARY ♦SB^DT.COMPONENT_LIBRARY:;query( 

SB_ADT.COMPONENT 

♦querv_component) 

{ 

Dictionary ♦by.nuni.aclts; 

Dictionary ♦byjium.operators; 

Dictionary ♦by-iimn-total.inputs; 

Dictionary ♦by.nmn.generics; 

Dictionary ♦by.nuiii-total.outputs; 

Dictionary ♦leaf-dictionary, 

SB.COMPONENTJDICTIONARY ♦query j-esuit=new SB .COMPONENT JDICTIONARY() 

// tn order for a malch library must hart at least as many adt’s as 
II being requested 

by u m.a d ts=ni a i n. 1 i bra ry (): 

Dictionarylterator next .by juim-adt(by Jiiini-adts, 

' FALSE, 

querv'-component—►num.adtsO); 

while(nextJ)y-num-adl.nioieData()) 

{ 

byJium.operators=( Dictionary ♦)(Entity ♦)next.byjium.adt(); 

// components must have at least as many operators as the query 

Dictionarylterator next .by jium.operators(by jium.operators, 

FALSE, 

query .component—♦num.ad t.operatorsf)) ; 

while( next-bv.nil in.operators.inoreDataO) 

{ 

by.nuni-geiierifs=(Dictionary ♦)(Entily ♦) 
next -by jiuni.operator.s(); 


1.11 






Dictionarylterator next-by_nuni-generics(by-num_generics, 

FALSE, 

query-component- 


*num.unrecognized.types()); 


while(next.by.num.generics.moreData()) 

{ 


by_]iuiTi-totaLoutput.s=(Dictionary ♦)(Entity *) 
nextJby _num.generics(); 


Dictionarylterator next.by_num.total_outputs(by_num_totaLoutputs, 


FALSE, 

query-component—►total.outputsO); 


while(next-bv.nuin-totaLoutputs.moreData()) 

{ 


by.num-totaLinputs=(Dictionary *)(Entity +) 
nex t Jjy ji u m -totaLou tpu ts(); 

Dictionarylterator next .byJium.totaLinputs(by.num-totaLinputs, 

FALSE, 

query-component—»totaLinputs()); 


while(next.bv.nuni.totaLinputs.moreData()) 

{ 

leaf.dictionary=(Dictionary *)(Entity ♦) 
next.byjnim.total-inputs(); 

Dictionarylterator next.component(leaf-dictionary); 

while( next-component.moreDataO) 

{ 

SB-ADT-COMPONENT ♦the-component= 

(SB-ADT-COMPONENT ♦)(Entity ♦)next-component(); 
if(ciuerv.component—filter(the-component)==TRUE) 

{ 

querv-result—add(the-component); 

}; 

}: 

}; 

}; 

// add code here for semantic matclnng interface 


return query-result: 







}; 

void SB_ADT-COMPONENTJdBRARY::list(ofstream& outstream) 

{ 

adt-Component-dictionary() —printOn(outstream); 

}: 


133 





# include ” shall. hxx" 


# include ’'sbextern.h" 


SB-ADT.OPERATOR::SB_ADT.OPERATOR(APL ♦theAPL) : 
SB.OPERATOR(theAPL) 

{ 

}; 


SB_ADT-OPERATOR;:SB_ADT.OPERATOR(char *id) : 

SB.OPERATOR(id) 

{ 

}; 

void SB_ADT.OPERATOR::Destrov(Boolean aborted) 

{ 

SB.OPERATOR: :Destiov( aborted); 

}; 

void SB.ADT.OPERATOR::deleteObject(Boolean deallocate) 

{ 

SB.OPERATOR::deleteObjec((deallocate); 

}; 

void SB.ADT.OPERATOR::putObject(Boolean deallocate) 

{ 

SB-OPERATOR;:put Object (deallocate); 

}; 

Type *SBJlDT-OPERATOR..getDirectTvpe() 
return SB.ADT-OPERATOR-OTvpe; 

}; 

Boolean SB.ADT.OPERATOR;:piocessJ.vpeJnfo(SB.ADT.COMPONENT ♦adt) 

// process lypes by checking local generic then adt.adi usage then 
II adi.generic usage before making it unrecognized. This will update 
II the adt usage dictionaries as well 

II update all usage dictionaryies for inputs and outputs 

II 

II first go through all of the inputs 

Dictionarylterator nextJnput=input-attributes()—*idjterator(); 
while(next Jnput.moreData()) 

{ 

SBJD.DECL *this.decl=(SBJDJDECL ♦)(Entity ♦)nextJnput(); 
SB-TYPE.NAME ♦tliis_typejname=this-decl—typejiame(); 

// first see if this id.decl type is a generic 


134 









if(generic.usage()^update(this_typejianie)==FALSE) 

{ 

// was tioi a generic iype check ike ADT generic list 

if(adt—generic.usage()—'update(this-typeaiame)==FALSE) 

{ 

// was not an adt generic so check the adt list 
if(adt-^adt-usage()—»update(tliis.typejiatne)==FALSE) 
{ 

// was not an adt adt so put it in Us local list 

II based on whether or not it is recognized 
if(this.typejiame—►recognized()==FALSE) 

{ 

// was unrecognized so try to update 
II the unrecognized list or add it to 
II the list 

if( unrecognized Jype.iisage()— 

upda(e(tliis.typejiame)==FALSE) 

{ 

// not yet in list so add it 
uniecognized.type.usage()—► 
add.type(this_typejiame-*id(), 
this.typejiame); 

// now update it for being used once 
u n recogn ized J ype.usage() —' 
update(lhis.tvpejiame); 

}; 

} 

else 

{ 

// this type name is recognized so update 
II or add it 

if( recognized .type-usage()—^ 

update(this.tvpejianie)==FALSE) 

{ 

// not yet in list so add it 
recognized Jype.usage()—* 

add.type(this-typejiame—►idO, 
tliis-typejiame); 

// now update it for being used once 
recognized J.ype.usage()-— 
update! this-tvpe_name); 

}; 

}: 

}; 

Dictionarylterator next-output =output-att.rilnites()—'id jterator(); 
while!next -out put inoreDat a!)) 








{ 

SBJD_DECL *lhis.decl=(SBJDJDECL *)(Entity *)nextjoutput(); 
SB-TYPE-NAME ♦this.typejiame=this_decl—»type_name(); 

// firsi see if this id.dtcl type is a generic 

if(go n?'’ic-usage()—‘update(this-type_namf*)== FALSE) 

{ 


// was not a generic type check the ADT generic list 

if(adt—'generic-usage()—>update(this.type_naine)==: FALSE) 

{ 

// was not an adt generic so check the adt list 
if(adt—‘adt.usageO—»update(this_type_name)==FALSE) 


// was not an adt adt 

II so put it in its local list 

II based on whether or not it is recognized 

if( this J.ype.name—*recognized()==: FALSE) 

{ 

// was unrecognized so try to update 
II the unrecognized list or add it to 
II the list 

if( u n recogn ized .ty pe.usage() —> 

update(tliis.typejiame)==FALSE) 

{ 

// not yet in list so add it 
u n recognized .type _usage()—► 
add.type(this_typejiame-*id(), 
this-typejiame); 

// HOW update it for being used once 
unrecognized Jype.usage()—» 
update(this.typejiame); 

}; 


// now update the adt list as well 

if(adt—unrecognized.type.usage()—► 
update(this-typeJiame)==FALSE) 

{ 

// not yet in list so add it 
adt—unrecognized .t.ype.usage()—> 
add_type(this-typejiame—»id(), 
this-typejiame); 

// now update it for being used once 
adt—-unrecognized _type.usage()—> 
update(thisjypejianie); 


} 


136 




// this type name is recognized so update 
//or add it 

if( recognized-type.usageO—* 

update{thisJypejname)==FALSE) 

{ 

// not yet in list so add it 
recognized .type.usage{)—> 

add-type(this.typejiame—‘idO, 
this-typejfiame); 

// now update for being used onece 
recognized .type.usage()—► 
updale(this-tvpe_name); 

}; 

// now update the adi usage list 
if( adt—recognized_type_usage()—> 

update(tliisJvpejiame)==FALSE) 

{ 

// not yet in list so add it 
adt—recognized-type_usage()—♦ 
add-type(thisJype_name^id(), 
this-typejiarne); 

// now update for being used onece 
adt—recognized-type-usageO— 
n p da te( t h is.ty pe Jiaine); 









#include ”shall.hxx" 


It include’'sbextern.h" 


SB_ADr-OPtRATOR-DlCTIONAHY::SBJiDT.OPERATOR-DICTIONARY(APL ♦theAPL) ; 

Dictionary( theA PL) 

{ 

}; 

« 

SBJVDT.0PERAT0RJD1CTI0NARY:;SB,ADT.0PERAT0R-DICTI0NARY() : Dictionary 
(OCJnteger, // icy 

SB-ADT.OPERATOR-OType, 

TRUE, 

TRUE) 

{ 

}; 

void SB^DT-OPERATOR-DICTIO.WARY.rDestroyfBoolean aborted) 

{ 

Dictionary]terafor iiex t .operator] tliis); 
while]next.operator. moreDat a()) 

{ 

]]SB.AET.OPERATOR ♦)]Entity ♦)next.operator())-*Destroy]aborted); 

}; 

Dictionary: iDestroy] aborted); 

}; 

void SBJiDT.OPERATOR.DICTIONARY::deleteObject]Boolean deallocate) 

{ 

Dictionarylterator next.operator]this); 
while]next.operator.nioreData])) 

{ 

]]SBj\DT.OPERATOR *)]Entity *)next.operator]))—*deleteObject]FALSE); 

}; 

Dictionary::deleteObject] deallocate); 

t 

}; 

void SBjVDT.OPERATOR.DICTIONARY:;putObject]Boolean deallocate) 

{ 

Dictionarylterator iiext.operator]tIiis); 
while]next.operator.nioreDala])) 

{ 

]]SB.ADT.OPERATOR ♦)]Entity ♦)next.operator]))-+putObject]deallocate); 

}■ 




Dictionary :;put Object (deallocate); 




Type ♦SB-ADT-OPERATOR-DICTIONARY::getDirectType() 

{ 

return SB^DT.OPERATOR-DICTIONARY.OType; 

}; 

void SBjVDT-OPERATOR.DICTlONARY:;add(SB-ADT-OPERATOR *op) 

{ 


Insert (op-’num Jnputs().op): 

}; 


void SB-ADT-OPERATOR-DlCTION’ARY;:append(SBJ^DT.OPERATOR-DICTIONARY 
*ne\v.dict) 

// gei an titralov for ihe dictionary then insert each operator into 
II the dictionary. Finally delete the input dictionary 

Dictionary Iterator next.operator=ne\v.diet—-iteratorO; 
whiIe(next.operator.moreData()) 

{ 

SB.ADT-OPERATOR ♦the-operator= 

(SBj 4DT-OPERATOR ♦)(Entify *)next.operator(); 
this—add( t lie.operator); 

}; 

next.operator.Reset(); 

// destroy the dictionary neic.dicl hut not its nienibers 
new-diet—Diet ionarv:: Destroy (FALSE); 

void SB^DT.OPERATOR.DICTION ARY ::priiitOn(ofstreainS: outstream) 

{ 

Dictionary Iterator next -Opeiator=iterator(); 
while(next .operator.nioreDat a()) 

((SBj^DT.OPERATOR ♦)(Entity ♦)iiext.operator())—♦printOn(outstream); 


}; 


int SBjVDT-OPERATORJ)ICTIOXARY;:num() 

return (inOCardinalilvO; // cast to int (no need for long) 

}■ 




int SBj^DT.OPERATOR_DICTIONARY::totaLinputs() 

{ ^ 

int total=0; 

Dictionary Iterator iiext.operator=iterator(); 

while(next-operator.moreData()) 

{ 

total=total + 

((SBj\DT-OPERATOR ♦)(Entity *)nextjoperator())-*numJnputs(); 

}; 

return total; 

}; 


int SB-ADT.OPERATOR-DICTIONARY::totaLoutput.s() 

{ . 

int total=0; 

Dictionarylterator next.operaior=iterator(); 
while( next-operator .nioreDat a()) 
total=t.otal + 

((SB-OPERATOR *)(Entity ♦)next-operator())—►num-outputs(); 

}; 

return total; 

}; 


Dictionarylterator SB-ADT-OPERATORJDICTIONARY .iterator() 

{ 

return DictionaryIterator((Dictionarv ♦)this): 

}; 









# include’shall.hxx' 


# include’’sbextern.h" 


SB.COMPONENT;:SB-COMPONENT(APL ♦theAPL) : Object(theAPL) 

{ 

}; 

SB-COMPONENT.;SB-COMPONENT(char *id) : Object() 

{ 

the.component_iianie=new char[strlen(id)+l3; 
strcpy (the -Component -name,id); 

SB-KEYWORD-DICTIONARV *nevv-key word-dictionary=new 
SB-KEYWORD-DICTION ARV(); 

tlie_keywoi d-diftioiiary=new-key word-dictionary—findTRef(); 


SB-TEXT-OBJECT *new-psdl-text=new SB-TEXTJ0BJECT(); 
tlie-psdl-te.\t=new-psdl-te.xt—findTRef(); 

SB-TEXT-OBJECT *new jmp.spec.text=new SB-TEXT-OBJECT(); 
theJmp_spec.text=new jmpj5pec.text-*findTRef(); 

SB-TEXT-OBJECT *newJmp-body-text=iiew SB-TEXT-OBJECT(); 
theJmp-body-text=newJmp-l>ody-text—'findTRefO; 

SB-TEXT-OBJECT ♦newjnformal-descriplion=new SB.TEXT-OBJECT(); 
tlieJnformal-de.scription=new-informaLdescription—“findTRefO; 

SB-TEXT-OBJECT ♦new-formal-description=new SB-TEXT-OBJECT(); 
the-formal-descriiit ion = new-formal-descript ion—“findTRefO; 

SB-TEXT-OBJECl ♦newjiormJormal-description=new SB-TEXT-OBJECTf); 
tlie-norni-formal-dc^ci ipt ion = new-iiorm-formaLdescription—findTRefO; 

SB-TYPE-USAGE-DICTIONARY' ♦new-recognized-type-usage= 
new SB-TYPE-USAGE.DICTIONARY0; 
the-recognized-lype-Usage=new j-ecognized Jypejisage—“findTRefO; 

SB-TYPE-USAG E-DICTION ARY ♦new-unrecognized-type-usage= 
new SB-TYPE-USAGE-DICTIONARYO; 
the-unrecognized.type-usage=newjm recognized Jlype jjsage—“findTRefO; 

SB-TY'PE-US AG E-DICTION ARY' ♦new-generic-usage=new 
SB.TYPE-USAGE-DICTIONARY'O; 

the-generic.iisage=new .generic .usage—findTRefO; 


Ml 








}; 

void SB.COMPONENT::Destrov(Boolean aborted) 

{ 

psdl.text()—Destroy (aborted); 
imp^pec-tex 10 —'Destroy (aborted); 
imp.body-text ()—' Destroy (aborted); 
informaLdescri p t ion () —♦ Destroy (aborted); 
formaLdescription()—» Destroy (aborted); 
norm.formaLdescription ()—‘Destroy (aborted); 
recognized -ty pe.usage( )—* Destroy (aborted); 
unrecognized _ty pe_usage()—»Destroy (aborted); 
keyword-dictionaryO—‘Destroy(aborted); 
generic.usage()—Destroy (aborted); 

delete tlie.component.iiaine: 
delete the Jcey word .dictionary; 
delete the.psdl.text; 
delete the jmp.spec.text; 
delete theJmp.bod}.text; 
delete the jnformal.description; 
delete theJormal.descriptioir. 
delete thejiorm.formaLdescription; 
delete thejecognized.typeoisage: 
delete the.unrecognized.type.usage; 
delete the .generic .usage; 


Object:: Destroy (aborted); 

}; 

void SB.COM PON ENT: :deleteObject( Boolean deallocate) 

{ 

psdl.textO—dele(eObject( FALSE); 
imp.spec.text()—deleteObject( FALSE); 
imp.body.lextO—deleteObject( FALSE); 
informal.description()—deleteObject( FALSE); 
formal.description()—»deleteObject( FALSE); 
norm.formaLdescription!)—deleteObject( FALSE); 
recognized .type.usage()—deleteObject( FALSE); 
unrecognized.type.usage()—deleteObject( FALSE); 
keyword.dictionary!)—deleteObject (FALSE): 
generic.usageO—deleteObject (FALSE): 

Object ;;deleteObiect( deallocate); 

}; 

void SB.COMPONENT;:putOliject(Boolean deallocate) 

{ 

psdl.text()—put Object (deallocate): 
imp.spec.text()—put Object (deal locate); 
imp-body.text()—put Object (deallocate); 


M2 






informaLdescription()—►putObject(deallocate); 
formaLdescription()—'putObject(deallocate); 
norm.formaLdescription()—‘putObject(deanocate); 
recognized.type.usage()—►putObject(deallocate); 
unrecognized-type.usage()—»putObject(deallocate); 
keyword.dictionaryO—>putObject(deallocate); 
generic.usage()—>putObject(deallocate); 

Object "putObject (deallocate), 

}; 

SBJvEYWORDJDlCTIONARY ♦SB-COMPONENT::keyword.dictionary() 

{ 

return ((SB-KEYWORD.DICTIONARY ♦)(tlie_keyword-dictionary—*Binding())); 

}; 

SB.TEXT.OEJECT *SB.COMPONENT;;psdLtext() 

{ 

return!(SB.TEXT.OBJEC’T ♦)(the.psdLtext—►Binding!))); 

SB.TEXT.OBJECT ♦SB.COMPONENTximp^pec.text!) 

{ 

return!(SB.TEXT.OBJECT ♦KtheJmp.spec.text-^Binding!))); 

}; 

SB.TEXT.OBJECT ♦SB.CO.MPONENT::imp.body.text!) 

{ 

return!(SB.TEXT.OBJECT ♦XtbeJmp.body.text—►Binding!))); 


SB.TEXT.OBJECT *SB-COMPO.NENT::informaLdescription!) 

{ 

return!(SB.TEXT.OBJECT ♦)(!heJnforniaLdescription—“Binding!))): 

}; 


SB.TEXT.OBJECT ♦SB.COMPONEXT::formal.description!) 

{ 

return!(SB.TEXT.OBJECT *)(theJoriual.descriplion—*Binding!))); 

}; 


SB.TEXT.OBJE('T ♦SB.COMPONENT::norm.formaLdescription!) 

{ 

return!(SB.TEXT.OBJECT ♦)!thejioriu.formal.description— 




Binding!))); 


SB.TYPE.USAGLJDICTIONARY* SB.CO.MPONENT;:recognized.tvpe.usage!) 

{ 

return (SB.T^TE.ESAGE JJICTIO.XAIOG) 











thejecognized Jypejusage—Binding(); 

}; 

SB_TYPE_USAGE_DICTIONARY* SB.COMPONENT::unrecognizedJtype-usage() 

{ 

return (SB.TYPE.USAGEJDICTIONARY*) 
the.unrecognized Jvpejusage—Binding(): 

}; 

SB-TYPE.USAGEJ)ICTIONARY% SB.COMPONENT;:genericjusage() 

{ 

return (SB.TYPE.USAGE J)ICTIONARY*)the.genericaisage—►Binding(); 

}; 

Boolean SB_COMPONENT;;addJcevword{char ♦keyword) 

{ 

return kevword-dictionary()—add(kevword); 

}; 


int SB-COMPONENT::nuni.unrecognized.tvpes() 

{ 

return int(unrecognized.tvpc-Hsage()—num()); 

int SB.COMPONENT;:total.tvpes() 

{ 

return num-unrecognized.types( )+ 
recognized .type atsage()—num(); 

}; 


void SB.COMPONENT::insert.generics! SB.TYPE.USAGETilCTIONARY ♦new.generic.usage) 

{ 

if( new.generic.usage^^ NULL) 

{ 

SB.COMPONENT;:generic.usage()—appeiid(new generic jusage); 

); 

}; 

char ♦SB.COMPONENT::coinponentjianie() 

{ 

return the.coniponent jianie; 

}; 

void SB.COMPONENT::add.text(ifstreamA' psdl, ifstreami: spec, ifstream& body) 

{ 


psdl.text()—append! psdl); 




j jnp-spec-t ex t () ^ append (spec); 
imp-body.text()-^append(body); 





# include ” shall. hxx" 

# include’’sbextern.h" 


SB.COMPONENTJDICTIONARY;;SB.COMPONENT_DICTIONARY(APL ♦theAPL) ; 

Dictionary (theAPL) 

{ 

}; 

SB.COMPONENTJ)ICTIONARY::SB.COMPONENT-DICTIONARY() ; Dictionary 
(centring, // KEY 

SB-COMPONENT-OType, 

TRUE, 

FALSE) 

{ 

}; 

Tvpe *SBXOiMPONENTJDICTIONARY::getDirectTvpe() 

{ 

return SB.COMPONENTJDICTIONARY.OTvpe; 

}; 

void SB.COMPONENTJDICTIONARY::Destrov(Boolean aborted) 

{ 

// firsi deslroy all of Ihe nfcrcnces in the dictionary 

Dictionarylterator next.coniponent(this); 

while(next .component .nioreData()) 

{ 

((SB.COM PON ENT »)(Entity »)next.component())—*Destroy( aborted); 

}■■ 

Dictionary:'.Destroy (aborted): 

void SB.C0MP0NENT.DICT10NARY:;delete0bject(Boolean deallocate) 

{ 

// first delete all of the references tn the dictionary 

Dictionarylterator next .component (this); 

while( next.component .moreData()) 

{ 

((SB-COMPONENT ♦)(Entity ♦ )next.component())—>deieteObject(FALSE); 

}; 

Dictionary::deleteObject (deallocate); 


14(5 









}; 

void SB-COMPONENTJDICTIONARY::putObject(Boolean deallocate) 

{ 

// first put all of the references tn the dictionary 

Dictionary Iterator next.component(this); 

while(next.coniponent.moreData()) 

{ 

((SB-COMPONENT ♦)(Entity ♦)next-coniponent())-+putObject(deallocate); 

}; 

Dictionary :;putObject(deallocate); 

}; 


Boolean SB-COMPONENT-DICTIONARY::add(SB-COMPONENT *new.component) 
Boolean return-flag; 

if( Dictionary ;:islndex(ne\v .component—component jiame())==FALSE) 

{ 

// keyword is not yet tn the dictionary so insert it 

Dictionary ::lnsert(ne\v .component—component.name(),new.component); 
return-flag=TRl'E: 

} 

else 

{ 

return.flag=FALSE; 

}; 

return retuni-flag; 

SB-COMPONENT *SB-COMPONENTJ)lCT10NARY;:query(char ♦name) 

{ 

’ SB-COMPONENT ♦return-component=NULL; 

if( Dictionary ::isIndex(name)==TRUE) 

ret urn .component =( SB-COM PON ENT ♦)( Entity ♦)(^this)[name]; 

}; 

return ret urn.component: 

}: 

void SB-COMPONENT.DlC'l IONARY;:prinlOn(ofslream& outstream) 

{ 


117 







Dictionary Iterator next-component= 

Dictionary Iterator( this); 

while(next_component .moreData()) 

{ 

int i; 

SB-COMPONENT *the.component=(SB.COMPONENT ♦)(Entity *)next_component(); 
outstream ^ the.coinponent—*coniponent_name(); 

for(i=strlen(the.component—►component_name());i < DEFAULT_NAME.SIZE; i++) 

{ 

outstream ^ 

}i 

outstream 

char *informaLdesc=(the.component—►informaLdescriptionO)—*text(); 
i=0_; 

while(informaLdesc[i]^NULL && informaLdesc[i] 7 C\n’) 

{ 

outstream informaLdesc[i]; 

i++; 

}: 

outstream <C "\n"; 

}; 









# include ’’ shall. hxx" 

# include "sbextern.h" 

SB_EXCEPTI0N_DICT10NARY::SB_EXCEPTI0N-DICTI0NARY(APL ♦theAPL) : 
Dictionary(theAPL) 

{ 

}; 

void SB-EXCEPTION.DICTIONARY;:Destroy(Boolean aborted) 

{ 

Dictionarylterator next.exception(this); 
while(next.exception.nioreData()) 

{ 

delete (char *)iiext_exception(): 

}; 

Dictionary'.iDest ioy( aborted): 

}; 

void SB.EXCEPTION J)ICTIONARY;:deleteObject(Boolean deallocate) 

{ 

Dictionary.-.'deleteObject (deallocate); 

}; 

void SB.EXCEPTION.DICTIONARY;;putObject(Boolean deallocate) 

{ 

Dictionary ■.■.i)ut Object (deallocate): 

}; 

Type ♦SB.EXCEPTION JDICTIONARY::getDirectType() 
return SB.EXCEPTIONTilCTlONARY.OTvpe; 

}• 


SBJIXCEPTIONJ)1CT10NARY::SB.EXCEPT10NJ)ICTI0NARY() : Dictionary (OCjstring, 
// KEY 

OC.string, 

TRUE. 

FALSE) 

{ 

}: 


Boolean SB.EXCEPTION J3ICTI0NARY::add(char ♦exceptionJd) 

{ 


MO 




Boolean return .flag; 


if(Dictionary;:isInclex(exceptionJd)=:=FALSE) 

{ 

// exceptionJd is not yet in the dictionary so insert it 
Dictionary: :Insert(exception Jd"); 
return Jlag=TRU E; 

} 

else 

{ 

return Jlag=FALSE; 

}; 

return return.flag; 

}: 

Boolean SBJ:XCEPTION JJICT10NARY;:append(SBJEXCEPTI0N JJICTIONARY 
♦ dictionary) 

Boolean return-flag=TRUE; 

Dictionarylterator next Jd=dictionary—»iterator(); 

while(nextJd.moreDataO fci: return.flag==TRUE) 

{ 

if(add((char ♦)nextJd())==FALSE) 

{ 

return Jlag=FALSE: 

}; 

}; 

dictionary—De»troy(FALSE); // delete the object and deallocate 
return return Jlag: 

}; 


void SB J)XCEPTION JI)lCTIONARY;:printOn(ofstream& outstream) 

{ 

Dictionarylterator next-exception=i(erator(); 

while(next-exception.nioreData()) 

{ 

outstream •C (cliar ♦)nexf.exception!) •C "\n”; 

}; 

}: 


150 







Dictionary Herat or SB_EXCEPTION JDICTIONARY;;iterator() 

{ 

// use tagiteraie since tag ts the data 
return DictionarvIterator(this,TRUE); 

}; 







# include '' shall. hxx' 


# include’’sbextern.h" 

SBJD_DECL;;SB-ID-DECL(APL ♦theAPL) ; Object(theAPL) 

{ 

}; 


SBJD_DECL;:SBJD-DECL(char ♦new.theJd, 

SB-TYPEJVAME ♦new.typejiame); 
ObjectO 

{ 


thead=iiew char[strleii(new.theJd)+l]; 
strcpy (tlie Jd ,new .the Jd); 

the.type Jiame=ne\v.t\ pe jiaine—findTRef{); 


}; 

void SBJD-DECL::Destiov(Boolean aborted) 

{ 

if(theJd5itNlILL) 

{ 

delete theJd; 

}; 


typejiameO—Destroy(al3orted): 


Object:: Dest rov( a borted): 

}; 

void SB.ID-DECL::deleteObject(Boolean deallocate) 

{ 


type jianie()—deleteObject( FALSE); 


Object ;:deleleObject(deallocate): 

}; 

void SBJD.DECL.:putObject(Boolean deallocate) 

{ 


type Jiaitie()—put Object( deallocate); 


Object; :put Object (deallocate): 

}; 









SB-TYPEJ^AME ♦SBJD-DECL::typejiame() 

^ return ((SB-TYPE.NAME ♦) (the.typejiame^Binding())) 

}; 


Type *SB.ID-DECL::getDirectType() 

{ 

return SB JD-DECL-OType; 

}; 

void SBJD.DECL:;printOn(ofstream& outstream) 

{ 

outstream <C theJd < " ; 
type-name()—printOii(outstream); 

}; 


char ♦SBJDJDECL::id() 

{ 

return tliejd; 

}; 





* include "sball.hxx’ 


# include’’sbextern.h" 

SBJD-DECL_DICTIONARY::SBJD.DECL.DICTIONARY(APL ♦theAPL) : Object(theAPL) 

{ 

}; 


SBJD-DECL-DICTIONARY:;SB.ID.DECL,DICTIONARY() . Object() 

{ 


Dictionary ♦new.dictionary-by.type= new Dictionary(SB_TYPE-NAME-OType, 

SBJDJDECL.OType, 

TRUE, 

TRUE); 


the.dictionary .by .type=new .diet ionary Jby-type—findTRef(); 

Dictionary ♦new.dictionary-byJd= new Dictionary(OC.string, 

SBJD.DECL.OType, 

TRUE, 

FALSE); 


the.dictionary.byJd=new.dictionary-byJd—findTRefO; 

List *newJd.declarationJist=new List(SBJD.DECL.OType); 


t he Jd.declaration.list=newJd.declaration Jist—►findTRefO; 


}; 

void SBJD.DECL.DICTIONARY..Destroy(Boolean aborted) 

{ 


Listiterator nextJd.dec^id.d-clarationJistO); 
while(next jd.decl.moreData()) 

{ 

((SBJDJDECL ♦)(Entity *)nextJd.decl())—*Destroy(aborted); 

}; 

dictionary.by.typeO—Destroy (aborted); 
dictionary.by.id()—Destroy (aborted); 
id-declaration.list()—Destroy (aborted); 

delete the .dictionary .by .type: 


1 











delete the.dictionary-byJd; 
delete theJd.declarationJist; 


Object:: Destroy( aborted); 


}; 


void SBJD.DECL.DICTIONARY::deleteObject(Boolean deallocate) 

{ 

Listlterator nextJd_decl(id.declarationJist()); 
while( next Jd-decl. moreData()) 

{ 

((SBJD-DECL *)(Entity »)nextJd-decl())—deleteObject(FALSE); 

}; 


dictionary .by-type()—deleteObject( FALSE); 
dictionary-byJd()—deleteObject( FALSE); 
id.declaration.list( )^deleteObject{ FALSE); 

Object ::deleteObject( deallocate); 


}; 


void SBJD.DECL.DlCT10NARY::put0bject(Boolean deallocate) 

{ 


Listlterator nextid.decl(id.declarationJist()); 
while(next-id.decl.moreData()) 

{ 

((SBJD-DECL *)(Entity ♦)nextjd.decl())—putObject(deallocate); 

}; 

dictionary_by.type()—►putObject(deallocate); 
dictionary .by Jd()—putObject(deallocate); 
id-declarationJist()—putObject(deallocate); 

Object ::putObject(deallocate); 


}; 

Type ♦SBJD-DECL-DICTIONARY::getDirectType() 

{ 

return SBJDJ)ECL.DICTIONARY.OTvpe; 

}; 

Dictionary ♦SBJD-DECL-DICTIONARY::dictionary-by-type() 

{ 

return (Dictionary ♦)(the.dictioiiary.bv-tvpe—BindingO); 

}; 

Dictionary »SBJD-DECL J)lCTlONARY::dictionary.by-id() 


l.>> 







return (Dictionary ♦)(the_dictionary.by.id—^BindingO); 

}; 

List ♦SBJD-DECL-DlCT10NARY::id.declaration_list() 

{ 

return (List ♦)(the-id.declaration-list—‘BindingO); 

}: 

Boolean SBJD-DECLJDICT10NARY.;add_decl(SBJD-DECL ♦decl) 

{ 

Boolean return.flag; 


if(dictionary-by.id()—islndex(decl—id())==FALSE) 

{ 

// ID NOT YET USED 

dictionary.by.typeO—Insert (decl—’type Jiaine(),decl); 


dictionary.byJd()—Insert (dec!—id(),decl); 


id.declarationJist()—>Insert(decl); 


return Jlag=TRUE; 

} 

else 

{ 

// id already in use so can not insert 
return Jlag= FALSE; 

}; 

return return-flag; 

}; 

void SBJD-DECL-DICTIONARY ;remove-decl(SB.ID-DECL *decl) 

{ 

dictionary-by-ty pe()—* Remove( decl—ty pe_name() ,decl); 


dictionary.by.id()—Remove(decl—id( ),decl); 


id-declaration Jist( )—> Remove! id-declaration-list()—Index(decl)); 






Boolean SBJD-DECL.DICTIONARY::add-decl(char ♦id,SB.TYPE.NAME ♦type_name) 

{ 

Boolean return.flag; 


if(dictionary-by-id()—»isIndex{id)==FALSE) 

{ 

// ID NOT YET USED 
II create new SB-ID.DECL 

SBJD-DECL »decl=new SBJDJ)ECL(id,type-name); 


dictionary.l)y.type()—Insert (type_name,decl); 


dictionary-byJd()—[nsert(id.decl); 


id-declaiation.list()—Insert(decl); 


return .flag=TRUE: 

} 

else 

{ 

// id already in use so can not insert 
ret urn _flag= FALSE; 

}; 

return return-flag; 

}; 


Boolean SBJD-DECL-DICTIONARY::append(SB.lD-DECL-DICTIONARY ♦dictionary) 

{ 

Boolean return-flag=TRUE; 

Listlterator nextJd^dictionary—orderJteratorf); 

while!next-id.nioreDataf) relurn-flag==TRUE) 

{ 

SBJD-DECL ♦this-decl={SBJD-DECL ♦)(Entity ♦)nextjd(); 
return-flag=add-decl( tliis-decl ): 

} 









/* nezt.id.Resetf); 
while (next Jd. moreDaia()) 

{ 

SBJDJ)ECL *this^decl=(SBJDJ)ECL *)(EntHy *)nexiJd(); 
dictionary->remove.decl(ihis.decl); 

); 

dictionary-> Destroy(FALSE):*/ 
return return Jag; 

1 


void SBJD-DECL-DICTIONARY.:printOn(ofstream& outstream) 

{ 

Listiterator next-clecl=orderiterator(); 
if( next-decl .moreData()) 

{ 

((SBJD-DECL *)(Entity ») next.decl())—♦printOn(outstream); 

while(next-decl.nioreData()) 

{ 

outstream ",\n": 

((SBJD-DECL *)(Entit.y *) next-decl())—*printOn(outstream); 

}; 

}; 

}; 

int SBJDJDECL-DlCTIONARY:;num() 

{ 

return (int)(dictionary.by.type()-'Cardiuality()); 

}; 

Dictionary Iterator SB JD_DECL.DICTION ARY; id Jterator() 

{ 

return Dictionary Iterator! dictionary.by Jd()): 

}; 

Dictionary Iterator SB JD.DECL.DlCTIONARY::typeJterator() 

{ 

return DictioiiaryIterator(dictionary.by.type()); 

}; 


Listiterator SBJD.DECL.DICTIONARY;:orderJterator() 

{ 

return Listlterator(id.declarationJist()); 

}; 


SBJD-DECL *SBJD-DRCL-DlCTIONARY;;(iuerv-id(char ♦query.name) 

{ 


158 








SBJD-DECL +return-value=NULL; 

if(dictionary-by-id()—►islndex(query-name)) 

return.value=(SBJD-DECL *)(Entity *)dictionary_byJd()—» 
getEntityElement(query.name); 

}; 

return return .value; 







# include ” shall. hxx” 

# include’’sbextern.h” 


SB-KEYWORD-DICTIONARY.:SB-KEYWORD-DICTIONARY(APL ♦theAPL) : 

Dictionary (the APL) 

{ 

}; 

SB.KEYWORD-DICTIONARY::SB-KEYWORD-DICTIONARY() : Dictionary (OC-string, // 

KEY 

OCjstring, 

TRUE, 

FALSE) 

{ 

}: 

Type ♦SB-KEYVVORD-DlCTlONARY;:getDirectType() 

^ return SBJ<EYWORDJDICTIONARY-OType; 

}; 

void SBJvEYVVORD-DICTIONARY:;Destroy(Boolean aborted) 

{ 

Dictionary:: Destroy (aborted); 

)-• 

void SB KEYVVORD.DICTIONARY;:deleteObject(Boolean deallocate) 

{ 

Dictionary :;deieteObject(deallocate): 

}i 

void SB.KEYWORD.DICTIONARY::putObject(BooIean deallocate) 

{ 

Dictionary ::putObject(deallocate): 

}; 

Boolean SB-KEY\VORD_DICTIONARY::add(char ^keyword) 

{ 

Boolean return Jag; 

if(Dictionary::isIndex(keyword)==FALSE) 

{ 

// keyword ts not yet in the dictionary so insert it 

Dictionary ::lnsert( keyword.""); 
return Jlag=TRUE; 

} 

else 

{ 

return Jlag=FALSE: 


160 


return return-flag; 


}; 

void SB-KEYVVORD-DICTIO\ARV':;printOn(ofstreamiSi outstream) 

{ 

Dictionarylterator nextJceywor(J=iterator(); 

while(next-keyword.moreData()) 

{ 

outstream (cliar ♦)nextJieyworcl() <C "\n"; 

}; 

}; 


Dictionarylterator SB.KEYVVORD-DICTIONARV::iterator() 

{ 

// use lagiterafe since tag is the data 
return DictionaryUerator(this.TRUE); 

}; 








tinclude ”shall.hxx” 
#include ’’sbextern.h’ 


SB-KEYWORDJ.IBRARY:;SB.KEYWORDXIBRARY(APL *theAPL) : Dictionary(theAPL) 

{ 

}; 

SBJ(EYW0RD-LIBRARY:;SB.KEYW0RD-L1BRARY() : 
Dictionary(OC-string,SB.COMPONENT_DICTIONARY.OType,TRUE,FALSE) 

{ 


}; 


void SB-KEYV\'ORD-LIBRARY;.query(ifstream& instream, ofstream<i: outstream) 

{ 

char the_keyword[256]; 

Dictionary ♦the_result=new 
Dictionary (OCjstriiig,OCJnteger,FALSE,FALSE), 

while(!instream.eDf()) 

{ 

instream theJceyword; 

instream ^ ws; // get the newJine character or eof 
if(this-'isIndex(theJvey\vord)==TRUE) 

{ 

SB-COMPONENT-DICTIONARY *the.component.dictionary= 
(SB.COMPONENTJDICTIONARY *) 
this—»getEntityElement( theJceyword); 

Dictionarylterator next.component= 

Dictionary lterator(the.component_dictionary); 

// update the result dictionary 


1 ; 


while( next.component.moreDataO) 

{ 

SB COMPONENT *the.component=(SB-COMPONENT *) 

(Entity ♦)next-component(); 
char ♦the.componentjiame; 

the.component.name=the-component—“Component jiame(); 
iRthejesult— 

islndex(the.component jiame)==TRUE) 

{ . 

int newjiumber= int( 

the Jesuit—getlntegerElement(thejcomponentjiame))- 

t he Jesuit— ‘Remove(the.component-name); 
the.result-— 

Insert(the jomponent jmnie.new jiumber); 

} 

else 

{ 


102 



the Jesuit—Insert( the jomponent Jiame,-1); 

}; 

}; 

}; 

}; 

// create new dictionary ordered by number of times found 
Dictionary *finaljesult=new 

Dictionary(OCJnteger,OC^tring,TRUE,TRUE); 

Dictionary Iterator next jesult=DictionaryIterator( the Jesuit); 

Dictionarylterator next Jesuit Jag=DictionaryIterator(thejesult,TRUE); 
while( next jesu 11. more D at a()) 

{ 

char ♦component=(char ♦)nextjesult.tag(); 

int times-used=iut(nextjesult()); 

final Jesuit—Insert( times .used,component); 

}; 

Dictionarylterator nextJinal-result=:DictionaryIterator(finaJjesult); 
while(next Jinal.result.moreDataO) 

{ 

char* componentjianie=(char *)next.finaljesult(); 

SB.COM PON ENT *the-component=SB.MAINT,IBRARY—*query (component jiame) 

// SB.MAIN.LIBRARY IS GLOBAL 

int i; 

outstream C the.component—*componentjiame(); 

for(i=strlen(the.component—componentJiame());i < DEFAULT.NAME.SIZE; i++) 

{ 

outstream •< " "; 

}; 

outstream " "; 

char ♦informaLdesc=(the.component—informaLdescriptionO)—►textO; 
i=0; 

while(informaLdesc[i]^NULL kk informaLdesc[i]^’\n’) 

{ 

outstream informaLdesc[iJ; 
i++; 

}; 

outstream "\n"; 

}; 

the Jesuit— Destroy (); 
final Jesuit—Destroy!); 

}; 

Boolean SB J<EYWORDXIBRARY::add.component(SB.COMPONENT ♦new.component) 

{ 

SBJ<EYWORDT)ICTIONARY* keyword Jist=new .component—key word-dictionary!); 
Dictionarylterator nextJ{ey»vord=keyword Jisf—iterator!); 
whilet next Jcey word. moreData!)) 

{ 

char ♦tlieJveyword=!cliai' ♦)nextJ\eyword(); 








if(this—►isIndex{theJteyword)==TRUE) 

{ 

SB-COMPONENT JDICTIONARY 
♦the-dictionary=(SB-COMPONENT.DICTIONARY ♦) 
this—»getEntityElement(theJcey word); 
the-dictionary—►add(new-component); 
the.dictioiiary—»Dict ionary ::putObject(); 

} 

else 

{ 

// this is a new keyword so make a new sb.component Aid 
II and add tt to the key.word library 
SB-COMPONENT-DICTIONARY* new.dictionary=new 
SB-COMPONENT JDICTIONARYO; 
new-dictionary—►add(new-component); 
new-dictionary—Diet ionary ;:putObject(); 
this—In.sert(the-kevvvord,new-dictionary); 

}; 

}; 

return TRUE; 

}; 

void SB-KEYWORD-LlBRARY::delete-component(SB-COMPONENT ♦the-component) 

{ 

SB-KEYWORD-DICTIONARY* keywordJist=the-component—<-keyword-dictionary(); 
Dictionarylterator next Jceyword=keyword Jist—iterator(); 
while( next-key word. iiioreData()) 

{ 

char *theJ(eyword=(char *)next-keyword(); 
if( this—islndex(the-key word )==TRUE) 

{ 

SB-COMPONENT-DICTIONARY 
*the-dictionary=(SB-COMPONENT.DICTIONARY *) 
this—getEntityElement(theJceyword); 
the-dictionary—Remove! the-Component—componentjiame()); 
the-dictionary—putObject(); 
if(the-dictionary—CardinaIity()==0) 

{ 

this—Remove! the-key word); 
the-dictionary—deleteObject!TRUE); 

} 

}; 

}; 

j ' 

void SB-KEYWORD-LIBRARY::Destrov!Boolean aborted) 

{ 











Dictionarylterator next.component.dictionary=iterator(); 
while(next-component_dictionary.moreData()) 

{ 

((SB-COMPONENTJDICTIONARY *)( Entity ♦)nextxoniponent_dictionary()) 
Destroy (aborted); 

} 

Dictionary:: Destroy (aborted); 


void SB.KEYWORD.LIBRAR^'::deleteObject( Boolean deallocate) 

Dictionarylterator next-component-dictionary=iterator(); 
while(next-component.dictionary.moreData()) 

{ 

((SB.COMPONENTJDICTIONARY *)(Entity ♦)nextxomponent.dictionary()) 
deleteObject( FALSE); 

} 

Dictionary: :deleteObject(deallocate); 

); 

void SB-KEYWORD-LIBRARY::putObject(Boolean deallocate) 

{ 

Dictionary::putObject( deallocate): 

}; 

Dictionarylterator SB_KEYWORDXIBRARY;;iterator() 

{ 

return Dictionarylterator!this,TRUE); // rtiurn tag iterate 


void SB-KEYWORD-LIBRARY::list(ofstream& outstream) 

{ 

Dictionarylterator next J;eyword=iterator(); 
while(next-keyword.moreData()) 

{ 

outstream <C (char *)nextJ;eyword() <C ”\n"; 

} 

}: 


1(55 





# include ” shall. hxx 


# include’’sbextern.h” 

SB-LIBRARY::SB-LIBRARY(APL ♦theAPL): Object(theAPL) 

{ 

}; 

SBXIBRARY::SB-LIBRARY(char *name, cliar ♦table) : Object(name) 

{ 

SB.COMPONENTJDICTIONARY ♦new.coinponent.dictionary= 
new SB.COMPONENT-DICTIONARYO; 

the.coniponent.dictionary= 

new .component.dictionary—►findTRefO; 

thejecognized.types=NULL; 

updatej‘ecognized.types( table); 


SB.OPERATOR.COMPONENTilBRARY ♦new.operator.componentJibrary= 
new SB.OPERATOR.COMPONENTXIBRARYO; 

the.operator.component Jibrary= 
new.operator.componentJibrary—findTRef(); 

SB.ADT.COMPONENTXIBRARY ♦new.adt.componentJibrary=new 
SBjVDT.COMPONENTXIBRARYO; 

the.adt.componentJibrary=new.adt.component.library—►findTRefO; 

SB J(EY\V0RDXIBRARY ♦newJ;eywordJibrary=new 
SBJ<EYWORD.LIBRARY(); 

theJieyword Jibrary=newJ{eyword Jibrary—findTRefO; 

}; 

SBJIECOGNIZED.TYPES ♦SB.LIBRARY;;recognized.types() 

{ 

return (SB.RECOGNIZED.TYPES ♦)(Entitv ♦)thejecognized.types—►Binding(); 

}; 

void SBXIBRARY::updatej-ecognized.tvpes(char ♦file) 

if( the jecogn ized .ty pes 9 ^ N U L L) 

{ 

recognized .tvpes()—deleteObject(): 

}; 


160 







SB-RECOGNIZED_TYPES *newaypejnatrix=new 
SBJlECOGNIZED.TYPES(file); 
the-recognized.types=new Jype Jiiatrix—findTRef(); 

} 

void SBXIBRARY::Destroy(Boolean aborted) 

{ 

operator.coniponent Jibrary()—Destroy(aborted); 
adt-component Jibrary 0 —»Destroy (aborted); 
component-dictionaryO—‘Destroy(abort.ed); 
recognized-types()—* Destroy (aborted); 
key word Jibrary ()—Destroy (aborted); 

delete the^dt.componentJibrary; 
delete the joperator.component Jibrary; 
delete the.component.dictionary; 
delete theJcey word Jibrary; 
delete the_recognized.types; 

Object "Destroy (aborted); 


}; 

void SB-LIBRARY::deleteObject(Boolean deallocate) 

{ 

operator.componentJibrary()—deleteObject( FALSE); 
adt-componentJibraryO—deleteObject(FALSE); 
component-dictionary()—deleteObject( FALSE); 
recognized Jypes()—deleteObject( FALSE); 
key word Jibrary()—*deleteObject( FALSE); 

Object ::deleteObject( deallocate); 


}; 

void SBXIBRARY:.putObject(Boolean deallocate) 

{ 

operator.coniponentJibraryO—*putObject(deallocate); 
adt.componentJibraryO—*putObject(deallocate); 
component.dictionary()—*Dictionary::putObject(deallocate); 
recognized JypesO—^putObjectldeallocate); 
keywordJibrary()—putObject( deallocate); 

Object ::putObject(deallocate): 


}; 


Type ♦SB-LlBRARY::getDirectTvpe() 

{ 

return SB-LlBRARY.OType, 

}: 


167 







SB_A.DT-COMPONENTXIBRARY ♦SB-LIBRARY::adt.component-library() 

{ 

return (SB-ADT-COMPONENTJ.IBRARY ♦) 

(the^dt-ComponentJibrary—BtndingO); 

}; 

SB.OPERATOR.COMPONENTXIBRARY *SBXlBRARY::operator.componentJibrary() 

{ 

return (SB-OPERATOR.COMPONENTLIBRARY ♦) 

(thejoperator-component Jibrary—*Binding()); 

}; 

SBJCEYWORDXIBRARY ♦SB-LIBRARY::keywordJibrary() 

{ 

return (SB.KEYVVORD.LIBRARY ♦)the.keywordJibrary—Binding(); 

}; 

Boolean SB-LIBRARY::add(SB-COMPONENT ♦new.component) 

{ 

Boolean returnJlag=FALSE; 

// first ensure that this component name is not already in use 

if(component.dictionary()—•add(new.component)==:TRUE) 

{ 

component-dictionaryO—Dictionary..putObjectO; 

// name not in use so continue processing 
II add the component to the keyword libraries 
return Jlag=TRUE; 

key word Jibrary()—‘add-component(new.component); 
key word-library()—putObject(); 

if(new.component—*get DirectType( )==SB.A DT.COM PONENT.OType) 

{ 

return Jlag=adt.componentJibrary()— 
add((SB_ADT-COMPONENT ♦)new.component); 

} 

else 

{ 

return Jlag=operator.component Jibrary()—* 

add((SB.OPERATOR-COMPONENT ♦Inew.component); 

}; 

}; 


return return-flag; 








void SB-LIBRARY::delete-coiTiponent(SB-COMPONENT ♦the_component) 

{ 

key word Jibrary ()—“delete_com ponent{ the-component); 
keywordJibraryO—"putObjectO; 

if(the.componeiU—•getDirectTvpe()==SB_ADT-COMPONEN’TjOType) 

{ 

adt.component Jibrary( )— 

delete-component ((SB DT.COM PON ENT ♦)the-component); 

} 

else 

{ 

operator.componentJibraryO—» 

delete.component((SB-OPERATOR-COMPONENT ♦)the.component); 

}; 

component-dict ionary ()—Remove(the-component—component-name()); 
component.dictionary()—•putObject(); 
the.component—deleteObjecl(TRl)E), 


void SB.LIBRARY::compouent.list(ofstreaniij outstream) 

{ 

adt.componentJibraryO—•list(outstream); 
operator-Component.library()—list (outstream); 

}; 

SB.COMPONENTJDICTIONARY ♦SB-LIBRARY::query(SB-COMPONENT 
*query .component) 

{ 

SB-COMPONENTJ)ICTIONARY *return.dictionary; 

if(query-Component—getDirectType()==SB j\DT-COMPONENT-OType) 

{ 

return.dictionary=adt.component Jibrary( )— 

query((SB.ADT.COMPONENT ♦)query.component); 

} 

else 

{ 

return-dictionary=operat or.component Jibrary( )— 

querv((SB-OPERATOR-COMPONENT ♦)querv-component); 

}; 

return return-dictionary; 

}: 


SB.COM PON ENT ♦S B TI BRA RY;:query( char *romponent-name) 








{ 

return component.dictionary()—query(componentJiame); 

void SBXIBRARY:;keyword.query(ifstream& instream,ofstream& outstream) 

{ 

key word Jibrary( )—*query( inst ream,outstream); 

}; 

SB.COMPONENT-DICTIONARY *SB-L!BRARY:;component-dictionary() 

{ 

return (SB.COMPONENT-DICTIONARY *)(Entity *) 
the .component.dictionary—Binding(); 

}; 

void SBXIBRARY::key\vord.list(ofstreami: outstream) 

{ 

kevwordJibraryO—list (outstream); 

}; 

void SB.LIBRARY::typeJist(ofstreami; outstream) 

{ 

adt.component.library ()—list( outstream); 

}; 

void SB.LIBRARY.;operator.list(ofstream& outstream) 

{ 

operator.component JibraryO—list(outstream); 

}; 

void SB.LIBRARY;;query(SB-COMPONENT *query.component,ofstream& outstream) 

i 

SB.COMPONENTT)ICTIONARY* thej-esult=query(querycomponent); 
thejesult—printOn( outstream); 

}; 


170 






# include’’shall.hxz 


# include "sbextern.h" 


SB_OPERATOR::SB.OPERATOR(APL ♦theAPL) : SB.COMPONENT(theAPL) 

{ 

}; 


SB.OPERATOR::SB.OPERATOR(char *1(1) ; SB,COMPONENT(i<i) 

{ 


SBJDJDECL-DICTIONARY *newjnput-attribules=new SBJD-DECL-DICTIONARY(); 


SBJD-DECL.DFCTFONARY ♦n<nv.oiiiput.attributes=new SBJD_DECL_DICTIOi\ARY(): 
SBJIXCEPTION-DICTIONARY ♦new.exceptioiis=new SBJEXCEPTION JDICTIONARY; 


the Jiiput_attributes=new jiiput-attributes—findTRef(); 
the-Output-attributes=new jDutpiit^ttributes—findTRefO; 
the.exceptioiis=new jexceptions—fiiidTRef(); 

states Jiag=FALSE; 


} 


SBJD-DECL.DICTIONARY «SB-OPERATOR::input.attributes() 

{ 

return (SB.ID.DECL-DICTIONARY *)(the.inpiit-atlributes—BindingO); 

}; 

SBJD-DECL.DICTIONARY »SB.OPERATOR::output.attributes() 

{ 

return (SB-ID.DECL. DICTION ARY' ♦ )(tlie.out put .attributes—Binding!)); 

}: 

Boolean SB-OPERATOR::states() 

{ 

return states-flag; 

}; 

SB_EXCEPT10N-DICTIONARY .SB.OPKICVIOH exceptions() 

{ 

return (SB.EXCEPTION.CK'TIONARY ODbe.exceptions-Binding!)): 









Boolean SB-OPERATOR;;addJnputs(SBJDJ)ECL-DICTIONARY ♦input,dictionary) 

{ 

Boolean return-flag; 

// add new declarations to the declaration list 
return_flag=input-attributes()—’append( input-dictionary); 

return return.flag; 

}; 

Boolean SB-OPERATOR.:add-outputs(SBJDJDECLJDICTIONARY ^output.dictionary) 

{ 

Boolean return-flag; 

return Jlag=output .attributes!)—append(output jJictionary); 
return return.flag; 

void SB.OPERATOR::set.states() 

{ 

states _flag=:TRUE; 

}; 

Boolean SB.OPERATOR;:add-exceptions(SB JiXCEPTlON J)1CT10NARY 
♦exception-dictionary) 

{ 

Boolean return-flag; 

return.flag=exceptions()—appencl(exception .dictionary); 
return return.flag; 


void SB.OPERATOR::Destroy(Boolean aborted) 

{ 

input-attributes()—Destroy (aborted); 

out put-attributes!)—Destroy (aborted), 

exceptions!)—Destroy! aborted); 

delete the Jnput .attributes, 
delete the.output-attributes; 
delete the.exceptions; 


S B -COM PONENT ; Destroy(ahorted) ; 













}; 

void SB.OPERATOR;;deleteObject(Boolean deallocate) 

{ 

input.attributesO—deleteObject( FALSE); 
output.attributesO—deleteObject( FALSE); 
exceptions()—'deleteObject( FALSE); 
SB-COMPONENT:;deleteObject(deallocate); 

}; 

void SB-OPERATOR::putObject(Boolean deallocate) 

{ 

iuput.attributes( )—putObject( deallocate); 

output.attributes()—putObject( deallocate); 

exceptions()—putObject( deallocate); 
SB-COMPONENT::putObject(deallocate); 

}; 

void SB.OPERATOR::piiutOn(ofstreamic outstieam) 

{ 

outstream < "OUTPUTIKG INTERFACE FOR OPERATOR "; 
outstream < this—componenUiame() <C "\n"; 

outstream < "GENERIC ATTRIBUTES\n\n"; 
SB-COMPONENT;:geiieric,usage()—piintOn(outstream); 

outstream C "\nIHPUT ATTRIBUTES\n\n"; 
input .attributes! )—printOn( outstream); 

outstream «; "\nOUTPUT ATTRIBUTES\ii\n"; 
output.attributes()—printOn(outstream); 

outstream < "\nUNRECOGNIZED TYPES\n\n"; 
unrecognized .type.usage!)—prinfOn!outstream); 

outstream < "\nRECOGIIZED TYPES\n\n"; 
recognized-type .usage!)—print On!outstream); 

outstream ■C "\nSTATES\n\n": 
if!s‘ates-flag==TRUE) 

{ 

outstream < ‘'YES\n"; 

} 

17 ;{ 












else 

{ 

outstream <C "M0\n"; 

}; 


outstream < "\nEXCEPTIOMS\n\n"; 

exceptions()—*printOn(outstream); 

outstream < "OUTPUTIIG THE PSDL TEXT\n\n"; 

outstream psdl_text()—^textO **\n"; 

outstream < "OUTPUTIHG THE IHFORMAL DESCRIPTIOH\n\n"; 

outstream <C informaLdescription()—^textO "\n"; 

outstream < "OUTPUTIHG THE FORMAL DESCRIPTIOM\n\n"; 

outstream formaLdescription()—*text() "\a''; 

outstream < "OUTPUTIHG THE HORMALIZED FORMAL DESCRIPTIOH\n\n"; 

outstream <C norm.formaLdescription()—^textO "\n"; 

outstream < "OUTPUTIHG THE ADA SPEC\n\n"; 

outstream «C imp-spec.text()—text() •C "\n"; 

outstream < "OUTPUTIHG THE ADA BODY\n\n"; 

outstream <C imp-body.text()—text() <C ''\n"; 


}; 


int SB.OPERATOR::num.inputs() 

{ 

return input.attributes()—num(); 

}; 

int SB-OPERATOR::num.outputs() 

{ 

return output-attributes()—num(); 

}; 

Dictionarylterator SB.OPERATOR.;inputJterator() 

{ 

return irput.attributesO—typeJterator(); 

}; 

Dictionarylterator SB.OPERATOR:;outputdterator() 

{ 

return output-attributes()—typeJterator(); 

}; 


Dictionarylterator SB-OPERATOR::exceptionJttTator() 

{ 

return exceptions!)—iterator!); 

}; 


17 » 








int SB-OPERATOR;;num.generic.types() 

{ 

// get ar. iterator for the type.decl list 

II and any spec that is not a procedure ts a generic type 

int count=0; 

Dictionary Iterator next Jd=S B.COMPON ENT: :genericjisage()—> 
typeidJterator(); 

while(nextJd.nioreData()) 

{ 

SB.TYPE.USAGE ♦the.usage=(SB.TYPE-USAGE*)(Entity ♦)nextJd(); 
SB-TYPE-NAME ♦the-typejianie=the_usage—*typejiame(); 
if(the.typej\ame—>type.code{)==:SB-GENERIC-TYPE) 

{ 

count=count++; 

}; 

}; 

return count; 

}; 






# include ” shall. hxx’ 


# include "sbextern.h” 


SB-OPERATOR.COMPONENT::SB.OPERATOR.COMPONENT(APL *theAPL) 
SB.OPERATOR(tlieAPL) 

{ 

}; 


SB.OPERATOR-COMPONENT::SB.OPERATOR-COMPONENT(char ♦id) ; 
SB.OPERATOR(id) 

{ 

}; 

void SB_OPERATOR-COMPONENT::Destroy(Boolean aborted) 

{ 

SB-OPERATOR;: Destroy (aborted); 

}; 

void SB.OPERATOR-COMPONENT::deleteObject( Boolean deallocate) 

{ 

SB.OPERATOR::deleteObject(deallocate); 

}; 

void SB.OPERATOR.COMPONENT::putObject(Boolean deallocate) 

{ 

SB-OPERATOR. :putObject(deallocate); 

}; 

Type ♦SB.OPERATOR-COMPONENT::getDirectType() 

{ 

return SB-OPERATOR.COMPONENT.OType; 

}; 

Boolean SB.OPERATOR.COMPONENT:;process_type jnfo() 

{ 

// update all usage dicUonaryies for inputs and outputs 

// 

// first go through all of the inputs 

Dictionarylterator nextJnput=input-attributes()—>idJterator(); 
while(next Jnpnt.moreData()) 

{ 

SBJD_DECL ♦this.decl=(SBJDJDECL ♦)(Entity ♦InextJnput(); 
SB-TYPE.NAME ♦tliis.typejjame=tlus-decl—>type-name(); 

// first see tf this id.decl type is a generic 
if(generic.usage()—update) this-tvpejiaine)= = FALSE) 

{ 

// was not a generic type so put it in the usage list 
// based on whether or not it is recognized 







if(this.typejiame—recognized{)==FALSE) 

{ 

// was unrecognized so try to update 
jj the unrecognized list or add it to 
II the list 

if(unrecognized.type.usage()— 

update(this.type-Hame)=:=FALSE) 

{ 

// not yet in list so add it 
unrecognized.type.usageO—* 
add-type( t his.type Jiame—'id(), 
this.typejiame); 

// now update it for being used once 
unrecognized.type.usageO— 
update(this.typejiame); 

}; 

} 

else 

{ 

// this type name is recognized so update 
II or add it 

if( recogn ized .ty pe-usage( )— 

update(this.typejiame)==FALSE) 

{ 

// not yet in list so add it 
recognized .type-usage()— 
add-type( tliis.typejjame—id(), 
this-typejiame); 

// now update it for being used once 
recognized .type.usage( )— 
update(this.typejiame); 

}: 

}; 

}; 

}; 

Dictionary Iterator next.output=output.attributes()—id jterator(); 
while(next.output.iTioreData<)) 

{ 

SBJDJ)ECL *this.decl=(SBJDJ3ECL *)(Entity *)next.output(); 
SB.TYPEJ^AME *this.typejiame=this.decl—typejiame(); 

// first see if this id.dect type is a generic 
if(generic.usageO—update(tliis.typejiame)==FALSE) 

{ 

// was not a generic type so put it in the usage list 
II based on whether or not it is recognized 
if( t h is-ty pejiame— recogn ized()==FA LS E) 

{ 

// was unrecognized so try to update 
II the unrecognized list or add it to 
II the list 


177 









if(unrecognized.type-usage()—► 

update( this-type jiame)==FALSE) 

{ 

// not yet tn list so add it 
unrecognized.type.usage()— 
add.type(this.type-natiie—id(), 
this.typejiame); 

// now update it for being used once 
unrecognized -type -usage( )— 
update( this-type-iiame); 

}; 

} 

else 

{ 

// this type name is recognized so update 
//or add it 

if(recognized_type.usage()— 

update(this-tvpe-name)==FALSE) 

{ 

// not yet in list so add it 
recognized-type-usage( )— 

add-type(this-type-name—*id(), 
this-type-name); 

// now update for being used onece 
recognized-type-usageO— 
update(this-typejname); 

1 : 

}; 


}; 


}i 


return TRUE; 


}; 


Boolean SB-OPERATOR.COMPONENT:;filter(SB-OPERATOR.COMPONENT +library.unit) 

{ 

// apply additional filter operations to the library unit 
//to see if the component can be rejected. True means 
// that it may still be a match. False indicates no match 

return TRUE; 

}: 


178 









# include ” shall. hxx’ 


It include’’sbextern.h” 


SB-OPERATOR.COMPONENTJ.IBRARY;:SB-OPERATOR.COMPONENTXIBRARY(APL 
♦theAPL) ; 

Object(theAPL) 

{ 

}; 


SB-OPERATOR-COMPONENTXIBRARY;:SB.OPERATOR-COMPONENTXIBRARY() : 
ObjectO 
{ 


SB-COMPONENT -DICTIONARY *new-operator-component-dictionary= 
new SB-COMPONENT_DICTIONARY(); 

the-operator-componeut-dictioiiary= 

new-operator-coniponent-dictioiiary—findTRef(); 

Dictionary ♦iiew-state.dictionary=aew Dictionary(OCJnteger, 

OC-dictionary, 
TRUE, 

FALSE); 

the.state.dictionary=new.statejdictionary'—findTRef(); 

Dictionary ♦newjion_state.dictionary=new Dictionary(OCJnteger, 

OC-dictionary, 

TRUE, 

FALSE); 

the-non-state.dictionary=ne\v-nonj5tatejdictionary—findTRefO; 


}; 

void SB-OPERATOR-COMPONENT-LIBRARY::Destroy(Boolean aborted) 

{ 

operator-component.dictionary ()—Destroy! aborted); 

// now must iterate through the multi-attribute query 
// dictionary tree 

Dictionary ♦leaf-dictionary; 

Dictionary ♦by-iium-inputs.dictionary; 

Dictionary ♦by .num.unrecognized.diet ionary; 

Dictionary ♦by.num-outputs.dictionary; 

by-num.inpu ts.dictionary=st a te.dict ionary!); 








Dictionarylterator nextJnput_dictionary= 

Dictionary Iterator(byjium-inputs.dictionary); 

while(next Jnput.dictionary.moreDataO) 

{ 

by_num-unrecognized.dictionary= 

(Dictionary ♦)(Entity *)nextJnput_dictionary(); 


Dictionarylterator next .outputs.dict(byjiuiTi.unrecognized-dictionary); 

while( next .out puts.dict.moreDataO) 

{ 

by-num-OUtputs.dictionary=( Dictionary ♦)(Entity ♦) 
next-outputs.dict(); 


Dictionarylterator nextJeaf-dict(byJium-outputs.dictionary); 

while) next Jeaf.dict .more Data))) 

{ 

leaf-dictionary=(Dictionary ♦((Entity ♦) 
next Jeaf-dict)); 

Dictionarylterator next.coniponent(leaf.dictionary); 


while) next .component. moreData))) 

{ 

((SB-OPERATOR-COMPONENT ♦((Entity ♦(next-component)))-. 
Destroy(aborted); 

}; 

leaf-dic t ionary—Destroy (aborted); 

}; 

by-num-outputs-dictionary—» Destroy (aborted); 

}; 

by-num.unrecognized-dictionary—•Destroy (aborted); 

}; 

by-num-inputs-dictionary—Destroy) aborted); 


by-num-inputs-dictionary=non-state-dictionary(); 


nextJnput-dictionary= 

Diet ionary Iterator) by-num-inputs-dictionary); 

while(next-input-dictionarv.moreData()) 

{ 

by-num-unrecognized-dictionary= 

(Dictionary ♦((Entity ♦)next-input-dictionary(); 


180 







Dictionarylterator next.outputs_dict(byjiuni-unrecognized.dictionary); 
while(next.outputs.dict.moreData()) 

{ 

by.nuni.outputs.dictionary=(Dictionary *)(Entity *) 
next jDutputs.dict(); 


Dictionarylterator nextJeaf.dict(byjiiim.outputs.dictionary); 

while( next Jeaf.dict .moreData()) 

{ 


leaf.dictionary=(Dictionary ♦)(Entity +) 
next Jeaf.dict)); 

Dictionarylterator next.compoiient(leaf.dictionary); 


while) next.component. moreDataO) 

{ 

))SB.OPERATOR.COMPONENT ♦))Entity ♦)next.component))) 
Destroy)aborted); 

}: 

leaf.dictionarv—Destroy) aborted): 

}; 

by .num.outputs.dict ionary™ Destroy) aborted); 

}; 

by jium.unrecognized.dictionary—Destrov)aborted); 

by mum.inputs.dict ionary—Destroy)aborted); 

delete the.operator,component .dictionary; 
delete the.state.dictionary; 
delete themon.state.dictionary; 


}; 

void SB.OPERATOR.COMPONENTilBRARY::deleteObject)Boolean deallocate) 

{ 

operator .component.diction ary))—deleteObject)deallocate); 

Dictionary ♦leaf.dictionary; 

Dictionary ♦byjium.inputs.dictionary; 

Dictionary +by.num.unrecognized .dictionary; 

Dictionary ♦byjium.outputs.dictionary; 

byjium.inputs.dictionary=state-dictionary)); 


Dictionarylterator next input.diet ionary) by jmm.inputs.dictionary); 








while(nextJnput.dictionary.moreData()) 

{ 

by-num.unrecognized-dictionary= 

(Dictionary ♦)(Entity *)next-input-dictionary(); 


Dictionary Iterator next.outputs.dict( by .num.anrecognized-dictionary); 

while(next-outputs-dict.moreData()) 

{ 

by_num.outputs-dictionary=(Dictionary ♦)(Entity *) 
next joutputs.dict(); 


Dictionary Iterator nextJeaf.dict(byjium.outputs.dictionary); 

whiIe(next-leaf-dict.inoreData()) 

{ 

leaf_dictionary=(Dictionary ♦)(Entity ♦) 
next Jeaf-dict(); 

Dictionary Iterator next-Component( leaf-dictionary); 


while( next-coniponent.moreData()) 

{ 

((SB-OPERATOR-COiMPONENT *)(Lntity *)next.component())— 
deleteObject( FALSE); 

}; 

leaf.dictionary—deleteObject( FALSE); 

}; 

by .num.outpnts.dictionary—deleteObject( FALSE); 

}; 

bv-iiutn.unrecognized-diet ionary—deleteObject(FALSE); 

} ' 

by-num-inputS-dictionary—deleteObject( FALSE); 


by-num.inputs.dictionary=non.state-dictionary(); 


next Jnput-dictionary= 

Dictionary Iterator! by .nuin.inputs.dictionary); 

while!next Jnput.dictionary.moreDataO) 

{ 

by-num.unrecognized.dictionary= 

(Dictionary ♦((Entity ♦)nextJnput.dicfionary(); 


Dictionary Iterator next-outputs-dict( by jiuin .unrecognized-dictionary); 
wIiile(next.outpiitS-dict .moreData()) 


182 









{ 

byjium.outputs.dictionary={ Dictionary ♦)(Entity *) 
next joutputs-dict(); 


Dictionary Iterator next JeaLdict(by jium-outputs.dictionary); 

while( next Jeaf.dict .moreData()) 

{ 

leaf.dictionary=(Dictionary *)(Entity ♦) 
next JeaLdict(); 

Diet ionary Iterator next-component( leaf-dictionary); 


while(next.component.moreData()) 

{ 

((SB.OPERATOR-COMPONENT *)(Entity ♦)next-component())—* 
deleteObject( FALSE); 

}; 

leaf.dictionary—deleteObject( FALSE); 

}; 

by-nuin.outputs-dict ionary—deleteObject( FALSE); 

}; 

by_num-unrecognized-dictionary—deleteObject( FALSE); 

}; 

byjium-inputs.dictionary—deleteObject( FALSE); 

Object :;deleteObject( deallocate); 

}: 

void SB.OPERATOR-COMPONENTXIBRARY:.pntObject(Boolean deallocate) 

{ 

operator.component.dictioiiary()—>putObject(deaIlocate); 

state-dictionary()—*putObject( deallocate); 
non.state-dictionary()—*putObject( deallocate); 

Object: :putObject( deallocate); 

}; 


Type *SB.OPERATOR.COMPONENTXIBRARV;:getDirectType() 

{ 

return SB-OPERATOR-COMPONENT±lBRARY-OType; 

}; 

SB.COMPONENTJDICTIONARY 

♦SB.OPERATOR-COMPONENT J.1BRARN': operator-component.dictionary() 

{ 










return (SB.COMPONENT.DICTIONARY *)(Entity *} 
thex-perator.component-dictionary—Bincllng(); 

}; 

Dictionary ♦SB-OPERATOR-COMPONENTJ.lBRARV..state.dictionary() 

{ 

return (Dictionary ♦)(Entity ♦)the^tate.dictioiiary^Binding(); 

}; 

Dictionary *SB-OPERATOR-COMPONENTXIBRARY;.non^tatejdictionary() 

{ 

return (Dictionary ♦)(Entitv *)the-nonxtate.dictionary—►BindingO; 

}; 

Boolean SB-OPERATOR-COMPONENT-LlBRARY..add(SB.OPERATOR-COMPONENT 
♦ new-coniponeiit) 

{ 

Boolean return.flag^TRUE: 

Dictionary ♦leaf.dictionary; 

Dictionary *by.num.inputs.dictionary; 

Dictionary ♦by jium.unrecognized .dictionary; 

Dictionary ♦by.num.outputs.dicfionary; 

operator.component.dictionary ()—add(new.component); 

operator.component.diet ionary()—Dictionary::putObject(); 

// insert into the component dictionary was successfull 
II so insert it into the library 

if(new.component—states()==TRUE) 

{ 

by jium.inputS-dictlonarv=state.dictionary(); 

} 

else 

{ 

byjium-inpnts.dictionaiy = non.state.dictionary(); 

}; ■ 

// have correct state dictionary so now find correct 
// input dictionary 

if(bv_num.inputs-dictionary—isIndex(new.component—num_inputs())==TRUE) 

{■ 

byjium.unrecognized.dictionary=( Dictionary *) 

(Entity ♦)(^by.num-inputs.dictionary) 

[new.component—n\)m_iirputs()]: 


1.'<1 


} 

else 

{ 






by_num.unrecognized.dictionary=new Dictionary(OCJnteger, 

OC-dictionary, 

TRUE, 

FALSE); 


by_num-inputs.dictionary—Insert(new.component—* 

numJnputsO, 

by-Hum-Unrecognized-dictionary); 


}; 

// have correct by num inputs dictionary so get the 
II unrecognized types diet. 


II got the unrecognized dictionary 

II use num generics since for a library unit all unrecognized types 
II must be generics 

if(by-num.unrecognized.dictionary— 

islndex(new.component—num-generic-types())==TRUE) 

{ 


by-num.outputs_dictionary=(Dictionary ♦)(Entity *) 
(»byjiuni-unrecognized.dictionary) 

[new.coinponent—num.generic.types()]; 


} 

else 

{ 


by jium.outputs.dictionary=iiew Dictionary(OCJnteger, 

OC-dictionary, 

TRUE, 

FALSE); 

by-num_unrecognized-dictionary—Insert! new-component—► 

num-generic-types(), 
byjium-outputs-dictionary); 


}; 


if(by-num-Outputs-dictionary— 

islndex( new-component—num-outpnts())==TRUE) 

{ 

leaf-dictionary=(Dictionary *)(Entity *) 
(♦byjium-outputs.dictionary) 

[new.component—num-outputs()]; 


} 


185 



else 

{ 

leaLdictionary=new Dictionary(OC^tring, 

SB-COMPONENT .OType, 
FALSE, 

FALSE); 

by-Hum-outputs-dictionary—Insert(new.component—► 

num-outputs(), 

leaf-dictionary); 


}; 


// have to leaf dictionary so now insert the component into it 
leaf-dictionary—»lnsert(new-component—*component-name(), 

new -Com p onent); 

leaf-dictionary—putObject(); 
by-num-inputs-dictionary—putObjectO; 
by-num-unrecognized-dictionary—putObject(); 
by-num-outputs.dictionary—putObject(); 

return return.flag; 

}: 


void SB-OPERATOR-COMPONENTXIBRARY:: 
delete-Component(SB-OPERATOR.COMPONENT ♦the-component) 
{ 


Dictionary ♦leaf-dictionary; 

Dictionary ♦by_num.inputs.dictionary; 
Dictionary ♦by-num.unrecognized-dictionary; 
Dictionary ♦by-iiuni-outputs-dictionary; 

operator-component.dictionaryO— 

Remove( the-component—component.name()); 
operator-component-dictionary ()—putObjecl(); 


if(the-component—states()==TRUE) 

{ 

by-num-inputs-dictionary=state-dictionary(); 

} 

else 

{ 

by-num-inpuls.dictionarv=non.state-dictionary(); 

}: 


186 




// have correct state dictionary so now find correct 
II input dictionary 


if(by-num.inputs-dictionary—»isIndex(the.component—‘num.iaputs())==TRUE) 

{ 

by-num-unrecognized-dictionary=(Dictionary ♦) 

(Entity *)(*by-num.inputs.dictionary) 

[the_component—»num.inputs()]; 

// got the unrecognized dictionary 

II use num generics since for a librai-y unit all unrecognized types 
II must be generics 

if(by.iium_unrecognized.dictionary—* 

isIndex(the-component—num-generic.lypes())==TRUE) 

{ 


byjium-outputs-diciioiiary=(Dictionary ♦)(Entity ♦) 
(♦by-num-unrecoguized-dictionary) 

[the.coniponent—nuin-generic.types()]; 

if(by.num-outputs-dictionary—' 

isIndex(the.component—num_outputs())==TRUE) 

{ 

leaf.dictionary=:(Dictionary ♦)(Entity *) 
(♦byjium.outputs.dictionary) 

[tlie.component—num.outputs()]; 

// have to leaf dictionary 

ieaf.dictionary—‘Remove(the.component—♦componentjiameO); 
leaf-dictionary—putObject(); 
if(leaf-dictionary—*CardinaIity()==0) 

{ 

by-num.outputs.dictionary—► 

Remove( the.coniponent—*num-outputs()); 
by-num.outputs.dictionary—putObject(); 

if(by.nuin.outputs.dictionary—Cardinality()==0); 

{ 

by jium.unrecognized.dictionary— 

Remove(the.component—nunn_generic.types()); 
by Jium.unrecognized.dictionary—putObject(); 

if(by.num.unrecognized.dictionary—Cardinality ()=:=0) 

{ 

by jium.inputs.dictioiiary- 

Remove(the.component—num_inputs()); 
by jiuni.iiiputs.dictionary—putObject(); 
by-nuni-unrecogiiized .dictionary—deleteObject(TRUE); 

}; 

by jiuni.out pnts.dict ionary—deieteObject(TRUE); 


1»7 



}; 

leaf.dictionary—»deleteObject(TRUE); 

}; 

}; 

}; 

}; 

}; 


SB.COMPONENT-DICTIONARY *SB.OPERATOR-COMPONENTXIBRARY;; 
query (SB-OPERATOR-COM PON ENT ♦query.component) 

{ 

SB.COMPONENTJDICTIONARY ♦query J-esult=new SB-COMPONENT J)ICTIONARY(); 

Dictionary ♦leaf.dictionary; 

Dictionary ♦by.num.inputs.dictionary; 

Dictionary ♦by.num.unrecognized.dictionary: 

Dictionary ♦by.num.outputs.dictionary; 

// gel the correct state.dictionary to start the query 

if( query .component—states( )==TRU E) 

{ 

byjium.inputs-dictionary=state.dictionary(); 

} 

else 

{ 

byjium.inputs.dictionary=non-state-dictionary(); 

}; 

// have correct stale dictionary so now find correct 
II input dictionary 

II for inputs must match exactly so only get one dictionary 

if((by-numJnputs-aictionary—>isIndex(query-component—♦num_inputs()))==TRUE) 

{ 

byjium.unrecognized.dictionary= 

(Dictionary ♦)(Entity ♦)(♦by.num.inputs.dictionary) 

[query.component—«num.inputs()]; 

// got the correct unrecognized.dictionary so iterate over it for 
11 the output dictionaries 
Dictionarylterator nextjoutputs.dict= 

Dictionary Iterator(byjium-unrecognized.dictionary, 

FALSE, 

qnery.component— 

num.unrecognized.typesO); 

// loop through all of the unrecognized types that are valid 
while(next-Outputs.dict.moreData{)) 




{ 

by_nuni-outputs_dictionary=(Dictionary ♦)(Entity *) 
nextjoutputsjdict(); 

// goi the outputs dictionary so now get the leaf dtctionarys 

Dictionary Iterator nextJeaf.dict= 

Dictionarylterator(byjium-outputs_dictionary, 

FALSE, 

query-component— 
num.outputsO); 


while(nextJeaf.dict.moreData()) 

{ 

leaf-dictionary=(Dictionary ♦llEntity ♦) 
next Jeaf.dict(); 

Dictionary Iterator next.component= 
Diet ionary Iterator! leaf-dictionary); 


// got an output dictionary so iterate 
jj through it and put the components in the 
// return result dictionary 

while(next.component.moreDalaO) 

{ 

SB.OPERATOR.COMPONENT ♦the-component= 
(SB-OPERATOR-COMPONENT *)(Entity *)next.component!); 

if(query.component—filter! the-Component)==TRUE) 

{ 

query .result—add!tbe.component); 

}; 


}; 


}: 

}; 

}; 


// add code to interface to semantic check routine here 


return query .result; 


}; 


void SB-OPERATOR-COMPONENTXlBRARY::list!ofstream& outstream) 

1 


18 !) 



operator.component.dictionaryO—>printOn(outstream); 

}; 


190 





#include ”shall.hxx’ 


#include ’’sbextern.h” 

SB-RECOGNIZED,TYPES::SB JlECOGNIZED.TYPES(char *1116) ; Object() 

{ 

char new .type Jiame[2.56]; 
int count=0: 
int flag.value; 
int case.sensitivejnt; 

Dictionary ♦newjiame.dictionary=new 

Dictionary(OCjstring,OCJnteger, FALSE, FALSE): 

thejiame-dictionary=newjiame-dictionary—‘findTRefO; 

ifstream type.defs(file); 

type.defs ';$> case.sensitive Jnt; 
if(ca.sejsensitiveJnt==0) 

{ 

case .sensitive^ FALSE; 

} 

else 

{ 

case.sensitive=TRUE; 

}; 


Boolean doneJiag=FALSE; 
whiIe(done-flag==FALSE) 
{ 


count+-i-; 

type-defs new.typejiame; 
if(strcmp(new.typejiame,"~")^0) 

{ 

char ♦store.typejiame; 
if( !ca.sej5ensitive) 

{ 

store .typejiame=con vert-to Jipper( new J.ypejiame); 

} 

else 

{ 

store.typejiame= new.typejiame: 

}; 

name-dictionary()—Insert(store_typeJiame,count); 


} 

else 

{ 


101 





doneJlag=TRUE; 

count—; 

}; 

}; 

array-size=count; 

Array ♦ new_row.array=new Array(OCjirray,count,1); 

the jow.array=newjrow jirray —'findTRef(); » 

int row.count=:l; 


for( row.count=l;row.count < array.size+r, row.count++) 

{ 

Array ♦new.colum.array=new Array(OCjnteger,count,1); 
int i; 

for(i=l;(i < count+l);i++) 

{ 

type.defs flag.value; 
new.colum.array—setElement(i,flag.value); 

} 

row.arrayO—*setElement(row.count,new.colum_array); 

}; 

}i 

SBJlECOGNIZED.TYPES;;SBJlECOGNIZED.TYPES(APL ♦theAPL) : Object(theAPL) 

{ 

} 

void SB.RECOGNIZED.TYPES::Destroy(Boolean aborted) 

{ , 

int row.count; 

name.dictionary()—Destroy( aborted); 

for(row.count=l;row.count < arravjsize+l; row.count++) 

{ 

Array &row=*(rowjirrayO); 

((Array ♦)(Entity ♦)row[row.count))—Destroy(aborted); 

}; 

row.array()—Destroy( aborted); 

delete thejiame.dictionary ; 
delete the jow jirray; 

Object:: Destrov( aborted); 


192 





void SB-RECOGNIZED.TYPES;:deleteObject(Boolean deallocate) 

{ , 

int row_count; 

name.dictionary()—deleteObject( FALSE); 

for(row_count=l;row.count < array.si?e+l; row.count++) 

{ 

Array &row=*(rowjirray()); 

((Array ♦)(Entity ♦)row[row.count])—deleteObject(FALSE); 

}; 

row.array()—deleteObject( FALSE); 

Object ■.■.deleteObject(deallocate); 

}; 

void SB-RECOGNIZED.TYPES::iHitObject(Boolean deallocate) 

{ . 

int row.count; 

nanie.dictionary( ) — putObject( deallocate): 

for(row.count=l;rovv.count < array.size+l; row.count++) 

{ 

Array i:row=»(row.array()); 

((Array ♦((Entity ♦)row(row.count])—putObject(deallocate); 

}; 

row.array()—putObject( deallocate); 

Object ::putObject( deallocate); 

}; 

Type ♦SB.RECOGNlZED.TYPES::getDirectType() 

{ 

return SB.RECOGNlZED.TYPES.OType; 

}; 

Array ♦SBJlECOGNlZED,TYPES::row.array() 
return (Array ♦((Entity ♦(the.row.arrav—BindingO; 

}; 

Dictionary ♦SB.RECOGNIZED-TYPES::name-dictionary() 

{ 

return (Dictionary ♦((Entity ♦)thejiame.dictionary—Binding(); 

); 

Boolean SB-RECOGNIZED-TYPES::map(int in.map.int ouLmap) 

{ 

Boolean return-flag=FALSE: 

Arrayi<c rows=^(row.array()); 


193 





Array& colum=*((Array *)(Entity *)rows[in-map]); 


if( int(colum[out_map])==l) 

{ 

return-flag=TRUE; 

}; 

return return-flag; 

}; 

int SB.RECOGNlZED-TYPES::type_number(char ♦typeJd) 

{ 

int return.value=SB-UNRECOGNIZED.TYPE; 
char ♦search Jd; 

if( lease .sensitive) 

{ 

search Jd=convert-to jjpper(tvpeJd); 

} 

else 

{ 

search Jd=typeJd; 

}; 

if(name.dictionary()—islndex(search.id)) 

{ 

return.value=int(nanie.dictionary()—getlntegerElement(searchJd)); 

}; 

return return-value; 

} 

char ♦SB-RECOGNIZED-TYPES.;convert-to-upper(char ♦typeJd) 

{ , 

int i; 

char ♦newjd=:new char[strlen(typeJd)+l]; 
for(i=0;i<strlen(tvpeJd);i++) 

{ , 

if(islower(typeJd[i])) 

{ 

newJd[i]=typeJd[i] + 'A'-’a’; 

} 

else 

{ 

new Jd[i]=type Jd[i]; 

}; 

}; 

newJd[i] = NULL; 
return new jd . 







# include ” shall. hxx 


# include’’sbextern.h" 

SB.TYPEJ^AME::SB.TYPE_NAME(APL ♦theAPL) : Object(theAPL) 

{ 

}; 

SB.TYPEJVAME::SB-TYPE-NAME(char ♦newjd.SBJD.DECL.DICTIONARY 

♦ new.dictionary) : Object() 

{ 


theJd=new char[strlen(newjd)+l]; 
strcpy(the Jd.new Jd); 


if(new-dictionarv==NULL) 

{ 

new.dictionary= new SBJD-DECL.DICT10NARY(); 

}; 

the Jd.decl.diet ionary=new.diet ionary—>findTRef(); 

Boolean fonndJlag=FALSE; 

SBJDJDECL ♦base.type.decl: 

Dictionary Iterator next Jd-decl=id.decl jdictionary()—►idJteratorO; 
while(next-id.decl.nioreData() fck Ifound.flag) 

{ 


SBJDJDECL *the.type.decl=(SBJDJDECL ^IIEntity *)nextJd.decl(); 
if((SB.MAIN.LIBRARY—*recogniEed.types())— 

type.number(tlie-tvpe.decl—id())==SB J3ASE.TYPE) 

( 

n fo and the base type decl 

found-fiag=TRUE; 

base .type.decl=tlie.typejdecl; 

}: 

}; 

if( found Jlag) 

{ 

// has a base type defined so look tt up 
the.base.type jd=( base-type jdecl —type Jiame( ))—id(); 

} 

else 

{ 

the.base.type jd=the Jd; 

}; 

the-base-typp.code=(SB JVIAIN J.IBRARY— 

recognized .types())— type.numberfthe.base.type Jd); 
the.type.code=(SB JVIAIN JJBRARY— 

recognized .types)))—type.number( the Jd); 



void SB.TYPE.NAME;;Destrov(Boolean aborted) 

{ 

if(theJd?‘NULL) 

{ 

delete theJd; 

}: 

if(the-base-type Jd) 

{ 

delete the.base.typeid; 

}; 


id.decLdictionary()^Destroy( aborted); 
delete theJd-decl.dictionary; 

Object;'.Destroy (aborted); 

}; 

void SB.TYPE.NAME;;deleteObJect(Boolean deallocate) 

{ 

id.decLdictionary()—deleteObject( FALSE); 

Object; .deleteOb ject (deal loca t e); 

}; 

void SB.TYPE.NAME;;putObject(Boolean deallocate) 

{ 

id.decl.dictionaryO—>putObject(deallocate); 

Object ;;putObject( deallocate); 

}; 

SBJD-DECL-DICTIONARY *SB-TYPEJ<AME;;id-decLdictionary() 

{ 

return (SB.ID.DECL.DICTIONARY ♦)(theJd-decLdictionary^Binding()) 

}; 


Type *SB.TYPE_NAME;;getDirectType() 

{ 

return SB-TYPEJMAME.OType; 

}; 

Boolean SB.TYPEJ^AME;;operator ==(Entitv& other-type) 

{ 

Boolean return-flag=FALSE; 


197 






char *this-baseJd=this—»base.typeJd(); 
char +thisJd=this—*id(); 

char ♦other-base jd=((SB.TYPE_NAME &)other J,ype).base J,ypead(); 
char ♦otherJd=((SB-TYPEJVAME &)otherJtype).id(); 

if(strcmp(this-baseJd,other-baseJd)==0 kk 
(strcmp(thisJd,otherid)==0)) 

{ 

return-flag=TRUE; 

}; 

return return-flag; 

}; 

Boolean SB.TYPE-NAME::operator >(Entity& other.type) 

{ 


Boolean return.flag=FALSE; 

char ♦this-bciseJd=this—>base.typeJd(); 

char ♦thisJd=this—id(); 

char ♦other-baseJd=((SB-TYPE-NAME &)otherJtype).baseJ.ype jd(); 
char ♦otherJd=((SB-TYPE_NAME &)other-type).id(); 

if( strcmp(this.baseJd,other.baseJd) < 0) 

{ 

return Jflag=FALSE; 

} . 

else if(strcmp(this-base-id,other-base.id) > 0) 

{ 

return Jlag=;TRUE; 

} 

else if(strcmp(this-id,other.id)< 0) 

{ 

return.flag=FALSE; 

} 

else 

{ 

return-flag=TRU E; 

}; 

return return-flag; 

}; 


void SB.TYPE-NAME:;printOn(ofstream& outstream) 

{ 

outstream <C this—theald; 
outstream <C " = " type-code(); 
outstream the.base.typeJd <C " = "; 

outstream •C base.type.code() " )"; 

outstream <g; "[ "; 


198 






id-decLdictionary()--‘printOn(outstream); 

outstream 


}; 

Listlterator SB.TYPE_NAME::decliterator() 

{ 

return id,decLdictionary()—order jterator()'. 

}; 

int SB-TYPE J'lAMExnum-declO 

{ . 

int return .value; 

if(id.decl.dictionary()==:NULL) 

{ 

return.value=0; 

} 

else 

{ 

return.value=id.decLdictionary()—num(); 

}: 

return return.value; 

}; 

char *SB-TYPEJVAME::id() 

{ 

return theJd; 

}; 

char *SB-TYPEJVAME;:base-tvpeJd() 

{ 

return the.base.type Jd; 

}; 

int SB.TYPEJVAME:;base-typexode() 

{ 

return the.base.typexode; 

}; 


int SB.TYPE_NAME::type.code() 

{ 

return the-type.code; 

}; 

Boolean SB.TYPE J'J AME..recoguized() 

{ 

return Boolean(base.type-code( l^SB-l^N RECOGNIZED-TYPE); 


199 





200 






# include ”shall.hxx” 

# include’’sbextern.h” 

SB-TEXT.OBJECT;;SB-TEXT-OBJECT(APL ♦theAPL) ; Object(theAPL) 

{ 

}; 

SB.TEXT.0BJECT-..SB.TEXT-0B.1ECT() : Object() 

{ 

the-text=new char[l]; 
strcpy(the.text.,""); 

}; 

Type *SB-TEXT.OBJECT::getDirectType() 

{ 

return SB.TEXT-OBJECT.OType; 

}; 

void SB-TEXT-OBJECT;: Destroy (Boolean aborted) 

{ 

delete the.text; 

Object:: Destroy (aborted); 

}; 

void SB.TEXT-OBJECT::deleteObJect(Boolean deallocate) 

{ 

Object;;deIeteObject(dealIocate); 

}; 

void SB.TEXT-OBJECT::putObject(Boolean deallocate) 

{ 

Object ::putObject(deallocate); 

}: 

void SB.TEXT-OBJECT:.appeud(ifstream& instream) 

{ 

ostrstream buffer; 

while( linstream .eof()) 

{ 

char text=instream.get(); 
if(text^EOF) 

{ 

buffer.put( text); 

}; 

}; 

buffer.put( NULL); 
the-text=buffer.str(); 

}; 

void SB.TEXT.OBJECT::append(char *instring) 


201 






{ 

the-text=new char[strlen(instring)+l]; 
strcpy(the.text,instring); 

}; 


void SB-TEXT-OBJECT::text(ofstream& outstream) 

{ 

outstream the.text; 

}; 

char *SB.TEXT.OBJECT::text() 

{ 

return the.text; 

}; 


202 



# include ” shall. hxx' 


# include "sbextern.h” 

SB.TYPE.USAGE;:SB.TYPE-USAGE(APL ♦theAPL) ; Object(theAPL) 

{ 

}; 


SB.TYPE-USAGE::SB.TYPE.USAGE(char ♦new.typeJd, 

SB-TYPE-NAME ♦new.typejiame): 
ObjectO 

{ 


the.typeJd=new char[strlen(new.typeid)+l]; 
strcpy (the.type jd,new .type id); 

the.type Jiame=new.typejianie—>findTRef(); 
the.times.used=0; 


}; 

void SB.TYPE-USAGE::Destroy(Boolean aborted) 

{ 

if(the.typeid) 

{ 

delete the.typeJd; 

}; 

type Jiame()—»Destroy (aborted); 
Object;;Destroy(aborted); 

}; 

void SB.TYPE.USAGE:;deleteObject(Boolean deallocate) 

{ 

typejiame()—deleteObject( FALSE); 

Object ;;deleteObject(deallocate); 

}; 

void SB.TYPE.USAGE::putObject(Boolean deallocate) 

{ 

typejiameO—♦putObject(deallocate); 

Object ::putObject( deallocate): 

}; 

char ♦SB.TYPE.USAGE::tvpeid() 

{ 


203 





return the.typeJd; 

}; 

SB-TYPE_NAME ♦SB-TYPE.USAGE::typejiame() 

{ 

return ((SB.TYPE.NAME *) (the.typejiame—‘BindingO)); 

}; 

void SB.TYPE.USAGE::used() 

{ 

the_times.used++; 

}; 

int SB-TYPE-USAGE:;times_used() 

{ 

return (the.times.used); 

}; 


Type ♦SB.TYPE.USAGE::getDirectType() 

{ 

return SB.TYPE.USAGE.OType; 

}; 

void SB.TYPE.USAGE::printOn(ofstreamiS: outstream) 

{ 

outstream < tlie.typeJd < " used " < the.times.used < " " 
typejiameO—•printOn(outstream); 

}; 

char ♦SB.TYPE.USAGE::base.typeJd() 

{ 

return typemameO—*base.tvpeJd(); 

}; 


204 




# include ”shall.hxx' 


# include’’sbextern.h” 

SB-TYPE-USAGE_DICT10NARY::SB.TYPE_USAGEJDICTI0NARY(APL ♦theAPL) : 
Object(theAPL) 

{ 

}; 


SB-TYPE-USAGE-DICTIONARY::SB-TYPE-USAGE-DICTIONARY() : Object() 

{ 


Dictionary +new_dictionary-by.base-type= new Dictionary(OC-string, 

SB-TYPE-USAGE-OType. 

TRUE, 

TRUE); 


the-dictionary-by-ba,se-type=:newjdictionary-by-base Type—findTRef(); 


Dictionary *new-dictionary-bv.typeJd= new Dictionary(OC-string, 

SB-TYPE-USAGE-OType, 

TRUE, 

FALSE); 


the-dictionary-by-type Jd=new-dictionary-by-type Jd—findTRef(); 

Dictionary ♦new-dictionary-by-tinies-U!5ed=new Dictionary(OC integer, 

SB-TYPE-USAGE-OType, 

TRUE, 

TRUE); 

the-dictionary-by.tiines-Used=new-dictionary.by-times-Used—‘findTRefO; 


}; 

void SB TYPE-USAGE-DlCTIONARY::Destrov(Boolean aborted) 

{ 


Dictionarylterator next-decl=type-iditerator)); 

while) next-decl.moreData))) 

{ 

((SB.TYPE-US AGE ♦)( Entity ♦)next.decl())—Destroy (aborted); 

}; 



dictionary.by.base.type()—►Destroy(aborted); 
dictionary .by .type Jd()—> Destroy (aborted); 
dictionary-by .times.used()—Dest roy (aborted); 

delete the.dictionary.by-base-type; 
delete thc-dictionary-by-type Jd; 
delete the-dictionary-by-times-used; 

Object;; Destroy (aborted); 


}; 

void SB-TYPE-USAGE-DICTIONARY;;deleteObject(Boolean deallocate) 

{ 


Dictionarylterator next-decl=typeid.iterator(); 

while(next.decl.moreData()) 

{ 

((SB-TYPE-USAGE ♦)(Entity ♦)next-decl())^deleteObject(FALSE); 

}; 

dictionary-by-base-type()—>deleteObject( FALSE); 
dictionary-by-typeJd()—deleteObject( FALSE); 
dictionary-by-tinies-used()—deleteObject( FALSE); 

Object.•;deleteObject(deaUocate); 


}; 


void SB-TYPE-USAGE-DICTIONARY;;putObject(Boolean deallocate) 

{ 


Dictionarylterator next-decl=typeJdJterator(); 

while(next-decl.iTioreData()) 

{ 

((SB-TYPE-USAGE ♦)(Entity ♦)next-decl())—putObject(deallocate); 

}; 

dictionary-by-base-type()—♦putObject(deallocate); 
dictionary-by-typeJd()—►putObject(deallocate); 
dictionary-by-times-used()—*put0bject( deallocate); 

Object;;putObject(deallocate); 


}; 


Type *SB.TYPE-USAGE.DlCTIONARY;;getDirectType() 


206 







{ 

return SB.TYPE-USAGE-DlCTlONARY.OType; 

}; 

Dictionary ♦SB-TYPE.USAGE_DlCTIONARY:;dictionary-by.base-type() 

{ 

return (Dictionary ♦)(the.dietionary-by.base.tvpe^BindingO); 

); 

Dictionary ♦SB.TYPE.USAGE JDlCTIONARY::dictionary_by-type jd() 

{ 

return (Dictionary ♦)(the.dictionary.by.type.id—BindingO); 

}; 

Dictionary ♦SB.TYPE.USAGE JD[CTIONARY;;dictionary_by.times.used() 

{ 

return (Dictionary +)(tlie.dictioiiary.bv.tiines.used—►BindingO); 

}; 


Boolean SB.TYPE.USAGE-DICT[ONARY::add.type(char ♦typeJd.SB.TYPEJV'AME 
♦type .name) 

{ 

Boolean return.flag; 


if(dictionary.bv.type.id()—isIndex(type-id)==FALSE) 

{ 

// ID NOT YET USED 

SB.TYPE.USAGE ♦ne\v.usage=new SB.TYPE.USAGE(type Jd,typejiame); 

dictionary.by.typeJdO—Insert( type Jd,new .usage); 
dictionary.by.base.type()—Insert(typejiame—base .type jd(),new jisage); 
dictionary .by .times.usedO—[nsert(0,new .usage); 

return Jlag=T RUE; 

} 

else 

{ 

// id already in use so can not insert 
return Jlag=FALSE; 

}; 

return return Jlag; 

}; 

Boolean SB.TYPE.USAGEJ)ICTIONARY::add.tvpe(SB.TYPE-USAGE ♦type.usage) 

{ 

Boolean return-flag; 


207 




if(dictionary.by.type-id()—islnciex(tvpe-usage—typeJd())==FALSE) 

{ 

// ID NOT YET USED 

dictionary.by.typeJdO—»Insert(type-usage—►typeJd(),typejisage); 
dictionary-by,base-type()^lnsert(typejisage—►base Jtypejd(),type jjsage); 
dictionary_by.times.used()—lnsert(0,type.usage); 

return _flag=TRUE; 

} 

else 

{ 

// id already in use so can not insert 
return Jlag= FALSE; 

}i 

return return-flag; 


}; 


Boolean SB-TYPE.USAGE-DlCTl0NARY::append(SB.TYPE-USAGE_DlCT10NARY 
♦dictionary) 

{ 

Boolean return.flag=TRUE; 

Dictionary Iterator nextJd=dictionary—typeJdJterator(); 

while(next-id.moreData() return_flag==TRUE) 

{ 

SB.TYPE.USAGE ♦the-usage=(SB-TYPE-USAGE ♦)(Entity ♦)nextJd(); 
ret u rn -flag=add .ty pe( the .usage); 

}; 

/♦ next.td.Resei(): 
while (nexLtd. more Data()) 

{ 

SB.TYPE.USAGE *1he.usage=(SB.TYPE.USAGE *)(Entity *)nexi.id(); 
dictionary->remove.usage(the.usage): 

}; 


dtctionary-> Destroy(FALSE);*/ 


return return-flag; 

}; 

void SB.TYPE.USAGE-DICTIONARY::remove-usage{SB-TYPE.USAGE ♦the.usage) 

{ 

dictionary-by-times-used( )—‘Remove( the.usage—times.usedO, the.usage); 
dictionary.by.typeJd()—Remove! the.usage—type Jd(), the.usage); 
dictionary-by-base-type!)—Remove!the.usage—base .type Jd!), the.usage); 


208 




}; 


void SB-TYPE.USAGEjDICTIONARY;;printOn(ofstream& outstream) 

{ 

Dictionarylterator &next.clecl= 

♦ (new DictionaryIterator(dictionary.by_base_type())); 

while(next-decl.moreData()) 

{ 

((SB.TYPE.USAGE ♦((Entity ♦) next-decl())—printOn(outstream); 
outstream -C 

}; 

}; 

int SB.TYPE-USAGE-DICTIONARY.:num() 

{ 

return (int)(dictionarv-by-base.tvpe()—CardinalityO); 

}; 

Dictionarylterator SB.TV'PE.USAGEJDICTIONARY::typeJdaterator() 

{ 

return DictionarvIterator(dictioiiary.bv.tvpeJd()); 

}; 

Dictionarylterator SB.T YPE.US AGE-DICTION ARY::base .type Jterator() 

{ 

return DictionaryIterator(dictionary.by.base.tvpe()); 

}; 

Dictionarylterator SB.TYPE.USAGE J5ICTI0NARY;:times.usedJterator() 

{ 

return DictionaryIterator(dictionary.bv.times.used()); 

}; 


Boolean SB.TYPE.USAGE.DICTIONARY;:update(SB-TYPEJVAME ♦typemame) 

{ 

Boolean return-flag=FALSE; 

if(dictionary.by.type.id()—islndexltvpe.name—id())) 

{ 

// <Ai5 type td IS tn the list so update its usage 
((SB.TYPE.USAGE ♦)dictionary.by.type.id()—> 
getEntityEIement(typejiame—id()))—used(); 
return JIag=TRUE; 

}; 

return return Jag; 

): 


2oy 




APPENDIX C - PARSER GENERATION INPUT 

FILES 


A. LEX INPUT 


# include "y tab.h"; 
int line_number=l; 

%} 


a 

b 

c 

d 

e 

f 

g 

h 

i 

i 

k 

I 

m 

n 

o 

P 

q 

r 

s 

t 

u 

V 

w 

X 

y 

z 

sp)ace 

%% 


[aA] 

[bB] 

[cC] 

[dD] 

[eEl 

m 

[gG] 

[hH] 

(ill 

Wl 

[kKl 

[IL] 

[mM] 

[nN] 

[oO] 

[pP] 

[qQ] 

[rR] 

[sS] 

[tT] 

[uU] 

[vV] 

[wW] 

[xXl 

[yY] 

[zZ] 

[] 


{t)(y)(p){e} 

(s){pl{e}{c){i){f){il{c){a){t){i){o}{n) 

{e}{n}{d) 

(g){e){n){e)(r)(i)(c} 


retum(TYPE); 

retum(SPECinCATION); 

rp.tum(END); 

retum(GENERIC); 


210 





{oJ{p){ej(r){aJ{t]{oj{r) 

re£um(OPERATOR); 

{i}ln}{p)(u){t) 

retuni(INPUT): 

{o){u){t}{p){u){t} 

return(OUTPLrr); 

(s){t){a}{i}{e){s} 

retum(STATES); 

{e){x){c)[e)|p){t){i){o){n){s) 

retum(EXCEPTIONS); 

{b} (y) (space} (r) (e) (q) (u) {i} (r) (e) (m) (e) (n) (t) (s) retiim(BY_REQ); 

{d){e}{s]{c){r)(i){p|{t){i){o){n} 

retum(DESCRIPnON); 

{a){x){i}{o){m){s} 

retum(AXIOMS); 

{k}{e){y)(w){o){r){d){s} 

relum(KEYWORDS); 

{m){a){x}{i}{m){u){m){space)(e) 

(x) (e) (c) (u) (t) (i) (o) (n) (space) (t) (i) (m) (e) 

retuni(MAX_EXEC_TIME); 

{m){i]{c){r)(o}(s)(e)(c} 

retum(MICROSEC); 

{m]{s) 

retuni(MS); 

{sj{e){c) 

retum(SEC); 

{m){il{n) 

retuni(MIN); 

{h}{o){u|{r){s) 

retum(HOURS); 

{a){n){d) 

retum(AND); 

{o){r) 

retum(OR); 

(x){ol{r) 

relum(XCR); 

(t)lr}{u){e) 

retum(TRUE); 

{f){a){l){s}(e} 

retum(FALSE); 

{nl(o}{t} 

retum(NOT); 


relum('<'); 


retum('>’); 


retum(-'): 


retum(GTE); 


retum(LTE); 

II ** 

retum(NEQV); 


retum('+’); 

M M 

relum(’-’); 


retum('&'); 


relumC*'); 

7" 

retumC/'); 

{m}{o){d) 

reium(MOD); 

{r]{e){m} 

reuirn(REM); 


retum(EXP); 

[0-9] [0-9]* 

retum(INTEGER_LlTERAL); 

[0-9][0-9)*"."(0-9]* 

retum(REAL_LITERAL); 

11 nilI'/VJ 

retum(STRING_LITERAL); 

If It 

relum(’.'); 

II, If 

retum(':'); 

If If 

retumC,'); 


retumCC); 

"]’■ 

retumC)'); 


retumCC); 


retumC)'); 

..{••[A}]-.).. 

( 

char *temp=yytext; 
whilc(*temp!=NULL) 

{ 

if(*temp=='\n') 


211 






[a-zA-Z][a-zA-Z_0-9]* 

"\n" 


{ 

line_nuinber++; 

}; 

temiH-+; 

); 

retum(TEXT BLOCK); 

); 

retum(ID); 

{ 

line_number++; 

); 


212 








B. YACC INPUT 


%start component 


%union { 

void* OBJECT_POINT; 

} 

%token ID TYPE SPECIFICATION END GENERIC 
%token OPERATOR INPUT OUTPUT 

%token STATES EXCEPTIONS BY_REQ DESCRIPTION AXIOMS 
%token TEXT.BLOCK KEYWORDS 
%token MOD GTE LTE 

%token MS MICROSEC SEC HOURS MIN AND OR XOR 

%token NEQV REM EXP 

%token INITIALLY MAX_EXEC_TIME 

%loken INTEGER_L1TER^ TRUE FALSE REAL_LITERAL STRING.LITERAL 

%token NOT ABS 


%type 

%type 

%type 

%type 


<OBJECT_POINT> 

<OBJECT_POINT> 

<OBJECT_POINT> 

<OBJECT_POINT> 


type_spec optional_generic_specs 
optional_type_decl optionaI_operator_decl 
operator data_type type_name generic_attributes 
input.attributes output_attribute$ exceptions_attributes 


%{ 

#include <stream.hxx> // C++ specific io routines 
#include "sball.hxx" 

/* this code allows the C++ compiler to use the c code generated by lex as standard c code */ 


extern "C-" 

{ 

extern int yylex(); 
extern int line_number; 
extern char yytext(]; 
#include <string.h> 
finclude <ctype.h> 
#include <stdlib.h> 
finclude <stdio.h> 

) 


extern int yyerror(char ♦); 

extern SB_COMPONENT* YYPARSE_component; // global pointer to the main library object 
extern Boolean YYPARSE_query_flag; 

// predeclare functions for internal stacks 


213 





void push_object(void *new_object); 

void *top_objectO; 

void *pop_objectO: 

void push_id(char '''new_id); 

char *top_idO; 

char ♦pop_idO; 

void push_rid(char •new_id); 

char *top_ridO; 

char *pop_ridO; 


// declare global variables for the parser 

Boolean SB_COMPONENT_ADT_FLAG=FALSE; 
char •psdl_type_name; 


component: 

data_type 

{ 

YYPARSE component=(SB_COMPONENT *)$!; 

} 

I 

operator 

{ 

YYPARSE component=(SB_COMPONENT*)$l; 

); 

data_type; 

TYPE 

push_ID 

{ 

psdl_type_name=topJd(); 

push_object(new SB_ADT_COMPONENT(popJdO)): 
SB_COMPONENT_ADT_FLAG=TRUE; 

) 

typc_spcc 

{ 

$$=(SB_COMPONENT •)pop_objectO; 

): 


type_spec: 

SPECinCATION 
optional _generic_specs 
optional_type_decl 
optional_operator_decl 


214 





functionality 

END 

{ 

if($2!=NULL) 

{ 

((SB_ADT_COMPONENT *)top_objectO)-> 

insert_generics((SB_TYPE_USAGE_DICTIONARY*)$2); 

); 

if($3!=NULL) 


((SB_ADT_COMPONENT '*)lop_objectO)-> 

insert_adt_usage((SB_TYPE_USAGE_DICnONARY*)$3); 

1 : 

if($4!=NULL) 

{ 


((SB_ADT_COMPONENT *)top_objectO)-> 

insert_operators((SB_ADT_OPERATOR_DICnONARY*)$4); 


): 


oplional_generic_specs; 

GENERIC 

push_new_SB_TYPE_USAGE_DICTIONARY 
iist_of_type decl 
( 

$$=(SB_TYPE_USAGE_DIGTIONARY *)pop objectO; 

); 

I 

/•optional*/ 

{$$=NULL;); 

optional_type_decl; 

push_new_SB_TYPE_USAGE_DICTIONARY 

list_of_type_decl 

( 

$$=(SB_TYPE_USAGE_DICTIONARY •)pop_objectO; 

) 

I 

/•optional*/ 

($$=NULL;); 

optional_operator_decl; 

push_new_SB_ADT_OPERATOR_DICTIONARY 

operatorjist 

{ 

$$=(SB_ADT_OPERATOR_DICTIONARY •)pop_objcctO; 

) 

I 


215 





/■"optional*/ 

{$$=NULL;): 

list_of_type_decl; 

list_of_type_decl 

f t 

type_decl 

I 

type_decl; 

type_decl: 

pushjdjist_start 

idjist 

1,1 

type name 

{ 

// must use another stack in order to reverse the order back 
// to the original order in the declaration 
while(top_idO!=BOTTOMJD) 

{ 

push_rid(pop_idO); 

) 

popJdO: //pop off the BOTTOM JD MARKER 
while(top rid()!=NULL) 

{ 

((SB_TYPE_USAGE_DICTIONARY*)top_objectO)-> 
add_type(pop_rid().(SB_TYPE_NAME *)$4): 



idjist: 

idjist 

I I 
1 

push_ID 

I 

push_lD; 

type_name: 

push_ID 

{ 

$S=newSB_TYPE_NAME(pop_id<),(SB_ID_DECL_DICTIONARY*)NULL); 

); 


push_ID 

push_new_SB_lD_DECL_DlCT10NARY 

iist_of_id_decl 

T 


216 



{ 

$$=new SB TYPE_NAME(popJd().(SBJD_DECL_DICTIONARY*)pop_objectO): 

}; 

list_of_id_decl: 

list_of_id_decl 

t f 
» 

id_decl 

I 

id_decl; 

id_decl: 

push_id_list_start 

id_list 

type_name 

{ 

// must use another stack in order to reverse the order back 
// to the original order in the declaration 
while(top_id()!=BOTTOM_ID) 

( 

push rid(pop id()); 

); 

popJdO: // pop off the BOTTOMJD MARKER 
whilc(top_rid()!=NULL) 

{ 

((SBJD.DECL_DlCnONARY*)top_objectO)-> 

add_decl(pop_ridO.(SB_TYPE NAME *)$4); 

); 

}: 

operatorjist; 


operator 

{ 

((SB_ADT_OPERATOR_DICTIONARY*)top_objectO)->add((SB_ADT_OPERATOR*)Sl); 

}; 

I 


operator 

operatorjist 

{ 

((SB_ADT_OPERATOR_DICnONARY*)top_objectO)-> 


add((SB_ADT_OPERATOR*)$l); 


functionality: 

keywords 

informaLdesc 



formal.desc 


keywords; 

{/^optional*/) 

I 

KEYWORDS 

push_idjist_start 

id_list 

{ 

while(topJdO!=BOTTOM_ID) 

{ 

(((SB_COMPONENT *)top_objectO)->keyword_dictionaryO)'>add(popJd()); 

); 

pop_id(); // remove the bottomjd 

): 

informal_desc: 

{/^optional*/) 

I 

DESCRIPTION 

TEXT_BLOCK 

{ 

char *the_text=new char[strlen(yytext)+l]; 

// put all but the opening { and closing ) into the_text 
int i; 

for(i=l;i< strlen(yytext)-l;i++) 

{ 

the_text[i-1 ]=yytext(i]; 

); 

the_text[i-1 ]=NULL; 

(((SB_COMPONENT*)top_objectO)->infonnal_descriptionO)->append(the_text); 
delete the_text; 

) 

formal_desc: 

{/*opuonal*/) 

I 

AXIOMS 

TEXT.BLOCK 

( 

char *the_text=new char[strlen(yytext)+l]; 

// put all but the opening ( and closing ) into the_text 
int i; 

for(i=l;i< strlen(yytext)-1 ;i++) 

{ 

the text[i-ll=yytext[il; 

); 

the_text[i-l )=NIJLL; 


218 




(((SB_COMPONENT*)top_objectO)->formal_descriptionO)->append(the_text); 
delete the_text: 

) 

operator 

OPERATOR 

push_ID 


if(SB_COMPONENT_ADT_FLAG==TRUE) 

{ 

// concatonate the psdl_type name and the operator name to ensure 

// a unique name in the database for the new component 

char *component_name=new 

char[strlen(psdl_type_name)+ 

strlen(top_id0)+2]; 

strcpy(component_name,psdl_type_name); 

strcat(component_name,”.”); 

strcat(component_name,pop_idO); 

push_object(new SB_ADT_OPERATOR(component_name)); 
delete component_name; 

1 

else 

{ 

push_object(new SB_OPERATOR_COMPONENT(pop_idO)): 

); 


operator spec 

{ 

$$=pop_objectO: 

}; 


operator_spec: 

SPECIFICATION 

operator_interface 

functionality 

END 

operatorjnterface: 

{/•empty •/) 

I 

attribute 

req_trace 

operator_interface 

attribute: 

generic_attributes 

{ 


219 





((SB.OPERATOR 

*)top_objectO)->insert_generics((SB_TYPE_USAGE_DlCTIONARY *)$1); 


I 


input_attributes 

{ 

((SB_OPERATOR *)top_object())->add_inputs((SB_ID_DECL_DICTIONARY *)$ 1); 

); 


output.attributes 

{ 


((SB_OPERATOR *)top_objectO)-> 

add_ouiputs((SB_ID_DECL_DICnONARY *)$!); 


state^attributes 

I 

exceptions_attributes 

I 

((SB.OPERATOR *)top_object())-> 

add_exceptions((SB_EXCEPnON_DICnONARY *)$1); 


I 

inax_execution_attribute; 

req_trace: 

(/•empty*/) 

I 

BY.REQ 

id_list 

generic_attributes: 

GENERIC 

push_new_SB_TYPE_USAGE_DICTIONARY 

iist_of_type_decl 

{ 

$$=(SB_TYPE_USAGE_DICTIONARY •)pop_objectO: 

); 


input.atcributes; 

INPUT 

push_new_SB_ID_DECL_DICTIONARY 

list_of_id_decl 

( 

$$=(SB_ID_DECL_DICTIONARY •)pop_objectO; 

); 


output.attributes: 


220 





OUTPUT 

push_new_SB_ID_DECL_DlCTIONARY 

list_of_id_(lecl 

{ 

$$=(SB_ID_DECL_DICTIONARY *)pop_object(); 

}; 


state_attributes; 

STATES 

list_of_id_decl 

{ 

// through away the list of type deci since it is not used 
pop_objectO: 

) 

INITIALLY 

initiaLexpression_list 


exceptions_attributes: 

EXCEPTIONS 

push_new_SB_EXCEPTION_DICTIONARY 
push_id_list_start 
id list 
( 

whileftop id()!=BOTTOM_ID) 

( 

((SB_EXCEPTION_DICTIONARY *)top_object())->add(popJdO); 

): 

pop_id(); // pop off the bottom marker 
$$=(SB_EXCEPTION_DICTIONARY *)pop_objectO; 


max_execution_attribute: 

MAX_EXEC_TIME time; 
time: 

INTEGER.LITERAL MICROSEC 
I 

INTEGER.LITERAL MS 
I 

INTEGER.LITERAL SEC 
I 

INTEGER.LITERAL MIN 
I 

INTEGER.LITERAL HOURS; 

initiaI_expression_list: 

initiaLexpression_list 


221 





inidal.expression 

I 

initial.expression; 

initial_expression: 

TRUE 

I 

FALSE 

I 

INTEGER_LITERAL 

I 

REAL.LITERAL 

I 

STRING_LITERAL 

I 

ID 

I 

type_name 

ID 

I 

type_name 

t ( 

ID 

'(' initial_expression_list ’)' 
I 

'(’ initial_expression')' 

I 

initial_expression 

log_op 

initiaI_expression 

linitial_expression 

reLop 

initial_expression 

I'-' 

initiaLexpression 

I 

initial_expression 

I 

inidal.expression 

bin_add_op 

initial_expression 

I 

initial_expression 

bin_mul_op 

initial_expression 

I 

initial.expression 

EXP 



initial_expression 

I 

NOT 

initial.expression 

1 

ABS 

initial_expression; 

log_op; 

AND 

I 

OR 

I 

XOR; 

rel_op: 


’>’ 

I 

GTE 

I 

LTE 

I 

NEQV; 

bin_add_op; 

1 

f f 

I 

bin_mul. op: 

I 

r 

I 

MOD 

I 

REM; 

pushJD: 

ID 

{ 

char *new_id=ncw char[strlen(yytexl)+l]; 

strcpy(new_id,yytext); 

push_id(ncw_id); 

); 


223 




push_new_SB_EXCEPTION_DICnONARY: 

{ 

push_object(newSB_EXCEPnON_DICTIONARY()); 

); 

push_new_SB_TYPE_USAGE_DICTIONARY: 

( 

push_object(newSB_TYPE_USAGE_DICTIONARY()); 

): 

push_new_SB_ADT_OPERATOR_DICnONARY: 

{ 

push_object(new SB_ADT_OPERATOR_DICTIONARY0); 

); 

push_id_list_start; 

{ 

push_id(BOTTOM_ID); 

1 ; 

push_new_SB ID DECL.DICTIONARY: 

{ 

push_objecr(newSB_ID_DECL_DlCTIONARY0); 

): 


/* define the id stack and the object pointer stack */ 


typedef struct OBJECT_STACK_RECORD 

{ 

void *object_point; 

OBJECT.STACK.RECORD *next_record; 
) OBJECT_STACK_RECORD: 

typedef struct ID_STACK_RECORD 

{ 

char *id; 

1D_STACK_REC0RD •next_record; 

) ID_STACK_RECORD; 

typedef struct NAME_STACK_RECORD 

{ 

char ‘name; 

NAME_STACK_RECORD *next_record; 

) NAME_STACK_RECORD; 


224 





char BOTTOM_ID_^^ARKER[2]="#"; /* used as a bottom of idjist marker ♦/ 
char *BOTTOM_ID=(char *)BOTTOM_ID_MARKER; 

OBJECT_STACK_RECORD *top_objectJn_stack=NULL; 

ID_STACK_RECORD *top_id_in_stack=NULL; 

ID_STACK_RECORD *top_rid_in_stack=NULL; 

NAME_STACK_RECORD ♦top_name_in_stack=NULL; 

void push_object(void •new_object) 

{ 

OBJECT_STACK_RECORD •new_object_record=new OBJECT_STACK_RECORD; 
new_object_record->object_point=new_object; 
new_object_record->next_record=top_object_in_stack; 
top_object_in_stack=new_object_record: 

}; 


void ■''top_object() 

{ 

void *rf .um_object=NULL; 
if(top_object_in_stack!=NULL) 

{ 

retum_object=lop_object_in_stack->object_point; 

} 

else 

( 

cerr« "error in object stack tried to view top object that was nulISn”; 

); 

return retum_object; 

}: 


void •pop_objectO 

{ 

void *retum_object=NULL; 

OBJECT_STACK_RECORD *temp_point=top_object_in_stack; 
if(top_objectJn_stack!=NULL) 

{ 

retum_object=top_object_in_stack->object_point; 
top_object_in_stack=top_object_in_siack->next_record; 
delete temp_point: 

) 

else 

{ 

cen « "PARSER: error in object stack read past endSn"; 

): 

return retum_object; 

); 


void push_rid(char •new_id) 

{ 

ID_STACK_RECORD *new_id_record=new ID_STACK_RECORD; 
new_id_record->id=new_id; 


225 






new_id_record->next_record=top_rid_in_stack: 
top_rid_in stack=newJd_record; 

); 


char *top_ridO 

I 

char *retum_id=NULL; 
if(top_rid_in_ stack!=NULL) 

{ 

retum_id=top_rid_in_stack->id; 

); 

return retumjd; 

); 


char •pop_ridO 

{ 

char *retum_id=NULL; 
if(top_rid_in_stack!=NULL) 

{ 

retumJd=top_rid_in_stack->id; 
ID_STACK_RECORD *temp_point=top_rid_in_stack; 
top_rid_in_stack=top_ridJn_stack->next_record: 
delete temp_point; 

) 

else 

{ 

cerr « "PARSER: error in rid stack read past endSn"; 

}: 

return retumjd; 

): 


void push_id(char *new_id) 

{ 

ID_STACK_RECORD ♦new_id_record=new ID_STACK_RECORD; 
new_id_rccord->id=new_id; 
new_id_record->next_record=top_id_in_stack; 
top id_in stack=new_id_record; 

); 


char *topjd0 

{ 

char *retum_id=NULL; 
if(top_id_in_jtack!=NULL) 

{ 

retum_id=top_id_in_stack->id; 

) 

else 

{ 

cerr « "PARSER: error in id stack looked at NULL recordSn" 

); 

return retum_ld; 


226 






char '''retum_id=NULL; 
if(top_idJn_stack!=NULL) 

I 

retum_id=top_id_in_stack->id; 
ID_STACK_RECORD •temp_point=topJd_in_stack; 
top_id_in_stack=top_idJn_stack->next_record; 
delete tetnp_point; 

) 

else 

{ 

cerr « "PARSER: error in id stack read past endVn"; 

1 ; 

return retum_id: 





APPENDIX D - INTEGRATING ADA 
COMPONENTS INTO CAPS 

Once a reusable component has been retrieved it must be transformed for use in the 
prototype being developed. As previously discussed, this requires that the names for 
parameters, streams, operators, and types be changed to match those of the query 
component. Along with this transformation the execution support system expects several 
naming conventions to be followed for Ada components. This appendix will discuss how 
an Ada reusable component can be transformed into the domain of the query component 
as well as the naming conventions the execution support system expects for Ada 
components. An example of the transformation process is also included. 

A. ADA REUSABLE COMPONENT NAMING CONVENTIONS 

The execution support system requires that all Ada reusable components are 
implemented via packages. To simplify the process of identifying package names the 
following conventions are used. 

1. Operators 

An operator with an ID of operator_name will be implemented in a package 
named operator_name_pkg. The operator itself will be implemented by the procedure 
operator_name_pkg.operator_name. 


228 





2. Types 


A PSDL type with an ID of psdLtype_name will be implemented in a package 
named psdl_type_name_pkg. 


B. EXAMPLE 


1. Query Specification 

type integer_sel 
specification 

integer_set: ADT 

operator create 
specification 
output 

the_set: integer_set 
end 

operator insert 
specification 
input 

X: integer, 
in_set; integer_set 

output 

out_set; integer_set 
end 

operator remove 
specification 
input 

X; integer, 
in_set; integer_set 

output 

out_set: integer_set 
end 

» operator member 

specification 

input 

X: integer, 
in_set: integer_set 

output 

result: boolean 
end 
end 


229 





2. Library Specification Located As A Match 

typeset 

specification 

generic t: GENERIC_TYPE, 

block.size: GENERIC_VALUE, 
eq: GENERIC_PROCEDURE 


set: ADT 


operator empty 
specification 
output 


end 


s: set 


operator add 
specification 
input 


output 


end 


x: t, 
si: set 

so; set 


operator remove 
specification 
input 

X: t, 
si: set 


end 


output 

so: set 


operator member 
specification 
input 

X: t, 

s; set 


end 


output 

V: boolean 


operator union 
specification 
input 

output 


end 


sl,s2: set 
s3 : set 


230 




operator difference 
specification 
input 

sl,s2: set 

output 

s3 : set 


end 


operator intersection 
specification 
input 

sl,s2; set 

output 

s3; set 


end 



operator equal 
specification 
input 

output 

end 


sl,s2: set 
V: boolean 


operator subset 
speciHcation 
input 

output 

end 


sl,s2: set 
V; boolean 


keywords SET 

description { SET ADT WITH OPERATIONS FOR EMPTY. ADD, SUBSET. EQUAL ) 
end 


231 


3. Matching Map 

TYPE set -> integer_set 
MAP 

set -> integer_set 

GENERIC 

t -> integer 

eq -> UNDEHNED 

OPERATOR empty -> create 
MAP 

OUTPUT 

s : set -> new_set: integer_set 

END 

OPERATOR add -> insert 
MAP 

INPUT 

X : t -> X : integer, 
si; set -> in_set: integer_set 
OUTPUT 

so : set -> out_set: integer_set 

END 

OPERATOR remove -> remove 
MAP 

INPUT 

X : t -> X : integer, 
si: set -> in_set: integer_set 
OUTPUT 

so: set -> out_set: inieger_set 

END 

OPERATOR member -> member 
MAP 

INPUT 

X : t -> X ; integer, 
si: set -> in_set: integer_set 
OUTPUT 

V ; boolean -> result: boolean 

END 

END 

The grammar that defines this mapping language is included in this Appendix. 


232 





4. Generated Ada Code 


From this matching map the following Ada specification and implementation 
can be generated to implement integer_set. 


C. ADA SPECIFICATION 


with sb_set_pkg; 
package integer_set_pkg is 

type integer_set is private: 

procedure create(new_set: out integer_set); 

procedure insert(x ; in integer; 

in_set: in integer_set; 
out_set: out integer_set): 

procedure remove(x : in integer; 

in_set; in integer_set; 
out_set: out integer_set); 

procedure n)ember(x : in integer; 

in_set: in integer_set; 
result: out boolean); 


private 

package sb_set_pkg_toJnteger_set_pkg is new sb_set_pkg(integer,UNDEFINED); 
integer_set is subtype sb_set_pkg_to_integer_set_pkg.set; 
end integer_set_pkg: 


233 




D. ADA IMPLEMENTATION 


package body integer_set_pkg is 

procedure create(new_set; out integer_set) is 
begin 

sb_set_pkg_to_integer_set_pkg.empty(new_set); 

end; 

procedure insert(x : in integer; 

in_set: in integer_set; 
out_set; out integer_set) is 

begin 

sb_set_pkg_to_integer_set_pkg.insert(x.in_set,out_set); 

end; 

procedure remove(x ; in integer; 

in_set; in integer_set; 
out_set: out integer_set) is 

begin 

sb_set_pkg_to_integer_set_pkg.remove(x,in_set,out_set); 

end; 

procedure meniber(x; in integer; 

in.set; in integer.set; 
result; out boolean) is 

begin 

sb_set_pkg_toJnteger_set_pkg.member{x, in_setjesult); 

end; 

end integer_set_pkg; 


234 




E. PSDL MATCHING MAP GRAMMER (YACC INPUT FORMAT) 


%start psdl_inap 

%token ID OPERATOR MAPS.TO MAP END TYPE GENERIC COMMA INPUT OUTPUT 
%loken COLON UNDERNED 


psdl_map; 
opera tor_map 
I 

type_map 

operator_map: 

OPERATOR 

library_id 

MAPS.TO 

query_id 

MAP 

operator_attributes 

END 

type_map: 

TYPE 
library_id 
MAPS.TO 
query Jd 
MAP 

type_attributes 

END 

type_attributes; 

adt_map_iist 

generic_m^_list 

operator_map_list 

adt_inap_list: 

(ropnoNAL*/) 

I 

map_type_list 

generic_map_Hst; 

{/♦OPTIONAL*/} 

I 

GENERIC 

map_lype_list 


235 



operator_map_list; 

operalor_mapJist 

COMMA 

operator_map 

I 

operator_inap 

operator.atthbutes: 

generic_inap_lisl 

input_mapjist 

outpul_map_list 

exception_mapJisi 

input_mapjist: 

{/•OPTIONAL*/) 

I 

INPUT 

map_decLlist 

output_map_Iist: 

(/•OPTIONAL*/) 

I 

OUTPUT 

map_decl_lisi 

exception_inap_list: 

(/•OPTIONAL*/) 

I 

EXCEPTION 

map.exceptionjist 

map_dccl_list: 

map_decLljsi 

COMMA 

map_decl 

I 

map_decl 

map.decl: 

libraryjd 

COLON 

library_typc_id 

MAPS.TO 

qucryjd 

COLON 

query_type_id 

I 

Iilwafy_id 

MAPS.TO 

UNDEFINED 





m^_type_list: 

map_typejist 

COMMA 

ms^.type 

1 

map_type 

map_type: 

Ubrary_type_id 

MAPS.TO 

query_type_id 

I 

Iibrary_type_id 

MAPS.TO 

UNDEHNED 

map_exception_list: 

map_exception_list 

COMMA 

map_exception 

I 

map.exception 

map.excepUon; 

libraryjd 

MAPS.TO 

queryjd 

I 

libraryjd 

MAPS.TO 

UNDEFINED 

I 

UNDEHNED 

MAPS.TO 

query_id 

library_id: 

id 

qucry_id; 

id 

library jype_id: 
id 

query_type_id: 

id 


id: 


ID 


237 




APPENDIX E - COMMAND LINE INTERFACE 

SPECIFICATION 

The software base has been implemented with a command line interface to simplify 
its integration into CAPS. This Appendix provides a detailed specification of the 
command line interface for the software base. 

The following is a list of the software base commands available and how to used 
them. Each command is prefixed by the name of the software base executable (i.e. 
caps_software_base). 

A. MAKE NEW SOFTWARE BASE LIBRARY 

1. Command 

ml library_name type_matching_rule_file 

2. Description 

Creates a new reusable component library within the software base named 
library^name using the type matching rules specified in the file 
type_matching_rule_file. See Appendix A for a description of the contents of the type 
matching rule file. 

3. Example 

%caps_software_base ml Ada Ada_rule_file 


238 




B. DELETE SOFTWARE BASE LIBRARY 


1. Command 

dl library _name 

2. Description 

Deletes the library Iibrary_name from the software base and all of the 
components in this library. 

3. Example 
%caps_software_base dl Ada 

C. ADD A COMPONENT TO A SOFTWARE BASE LIBRARY 

1. Command 

ca library_name psdl_file imp_spec imp_body 

2. Description 

Adds the component specified in psdl_file to the library named library_name. 
The implementation source code is in the files imp_spec and imp_body. 

3. Example 

%caps_software_base ca Ada sb_set.psdl sb_set.spec.a sb_set.body.a 




D. DELETE A COMPONENT FROM A SOFTWARE BASE LIBRARY 


1. Command 

cd library_name component_name 

2. Description 

E>eletes the component named component_name from the library named 
library_name. 

E. UPDATE A COMPONENT IN A SOFTWARE BASE LIBRARY 

1. Example 

%caps_software_base cd Ada sb_set 

2. Command 

cu library_name psdl_file imp_spec imp_body 

3. Description 

Update the existing component specified in psdl_file with the new 
specification given in psdl_file and the new implementation given in the files imp_spec 
and imp_body. 

4. Example 

%caps_software_base cu Ada set.psdl new_set.spec.a new_set.body.a 


240 






F. VIEW A COMPONENT IN A SOFTWARE BASE LIBRARY 


1. Command 

cv library_name component_name sb_set.psdl sb_set.spec.a sb_set.body.a 

2. Description 

Generate text files for viewing the component component_name which is in 
library Iibrary_name. The text is written to the files specified by psdl_file, imp_spec, 
imp_body. 

3. Example 

%caps_software_base cv Ada sb_set.psdl sb_seLspec.a sb_set.body.a 

G. LIST OF KEYWORDS IN A SOFTWARE BASE LIBRARY 

1. Command 

kwl library_name output_file 

2. Description 

Generate a list of keywords defined in library library_name. This list is 
provided to allow the formulation of keyword queries or when selecting keywords for a 
new component. The list of keywords is written to the file output_file. 

3. Example 

%caps_software_base kwl Ada keyword_list 


241 






H. LIST OF COMPONENTS IN A SOFTWARE BASE LIBRARY 


1. Command 

cl library_name output_file 

2. Description 

Generate a list of component names defined in library Iibrary_name. This list 
can be used for named look up of components in the software base. The list is written to 
the file output_file. 

3. Example 

%caps_software_base cl Ada component_list 

1. LIST OF PSDL TYPES IN A SOFTWARE BASE LIBRARY 

1. Command 

tl library_name output_file 

2. Description 

Generate a list of PSDL type components defined in library library_name. 
This list can be used for named look up of type components in the software base. The 
list is written to the file output_rile. 

3. Example 

%caps_software_base tl Ada typejist 


242 






J. LIST OF PSDL OPERATORS IN A SOFTWARE BASE LIBRARY 


1. Command 

ol library_name output_file 

2. Description 

Generate a list of PSDL operator components defined in library 
library__name. This list can be used for named look up of components in the software 
base. The list is written to the file output_file. 

3. Example 

%caps_software_base ol Ada operator_list 

K. KEYWORD QUERY 

1. Command 

kwq library_name keyword_list output_file 

2. Description 

Perform a keyword query on library library_name using the keywords in the 
file keywordjist and write the output to output_fiIe. The output file contains the 
component name, the percentage of keywords matched, and the first line of the 
description of the component. 

3. Example 

%caps_software_base kwq Ada query_keyword_list result_list 


243 





L. COMPONENT QUERY 


1. Command 

cq library_name psdl_file output_file 

2. Description 

Performs a query by specification on the library Iibrary_name using the 
PSDL specification in psdl_file for the query. Writes the output to output_file. The 
output file contains the name of the component, the percentage score from semantic 
matching, and the first line of the description for the component. 

3. Example 

%caps_software_base cq Ada query .file result_file 

M. GENERATE MATCHING MAP 

1. Command 

cgm library _name psdl_file component_name output_file 

2. Description 

Generate a matching map of how the component component_name matches 
the PSDL specification in psdl^file and writes the map to the file output_file. This 
function is currently not implemented. 

3. Example 

%caps_softwate_base cgm Ada query.psdl result_file 


244 




N. COMPONENT DIAGNOSTICS 


1. Command 

cdiag library _name cotnponent_naine output_file 

2. Description 

Creates a text file that contains diagnostic information about the component. 

3. Example 


%caps_software_base cdiag Ada sb_set 



APPENDIX F - CAPS SOFTWARE BASE 
GRAPHICAL USER INTERFACE USERS 

MANUAL 


A. BASIC MOUSE TECHNIQUES 

1. Clicking 

Clicking the mouse means moving the cursor to the desired location and 
pressing the left mouse button and then releasing it. 

2. Double Clicking 

Double clicking means clicking the mouse on an item twice in rapid 
succession. This technique is often used to select an item from a list of items. 

3. Dragging 

Dragging and item is accomplished by moving the cursor to the desired item 
and pressing the left mouse button. While holding the button down the item can be 
moved (dragged) to the desired location. To complete the operation simply release the 
mouse button. 

4. Push Buttons 

A button is pushed by clicking the left mouse button while the mouse cursor is 
over the button. Pushing a button will cause the labeled action to take place. 


246 




5. Pull Down Menus 


A pull down menu is selected by clicking the left mouse button on the menu 
title and holding the button down. A list of the available options for this menu will be 
displayed. To select one of the available options move the mouse to the option (a 
highlighted bar will follow the mouse) and let up on the mouse button. Letting up on the 
mouse button anywhere outside of the pull down menu's option list will take no action. 

6. Scrolling 

1. Click on scroll bar arrows to scroll display one line in the desired direction. 

2. Click above or below the scroll bar display icon to move up or down a page of 
information. 

3. Drag the scroll bar display icon to the desired position in the view. 

4. Use the middle mouse button to get the "Grabber Hand" which can be used to 
move the display. This method can be used on all scrolling views even if there is 
no scroll bar. This is useful for string editors that have no scroll bars. 

7. Sizing Windows 

All of the windows in the Software Base user interface have been designed to 
allow resizing to user preferences. The method used to resize a window depends on the 
version of XI1 window manager that is in use. The examples in this manual are for the 
OpenWindows manager. 

To resize a windows. In OpenWindows, simple drag any comer of the window 
in the desired direction and the window will be resized. 


247 






B. STARTING THE SOFTWARE BASE GRAPHICAL USER INTERFACE 

The Software Base graphical user interface is started by executing the command 
softbase.exe from the command line. The path for the CAPS executables must be in your 
path. Currently you must be either working on suns5 or rxterm'ed to suns5 to use this 
interface. This is due to the requirement that the Interviews 3.0 libraries must be 
mounted for the interface to execute. These libraries are currently only mounted on 
sunsS. 

C. CAPS SOFTWARE BASE MAIN MENU (FIGURE F.l) 

The CAPS Software Base main menu is the top level of the Software Base 
Browsing System. From here all options of the Software Base are available. These 
options are to add new components, update existing components, delete components, 
browse by keyword, browse operators, browse types, query for a given specification, 
and get on-line help (The help system is currently not implemented). 

These options are organized into four categories: File, Browse, Query, and Help. 
These categories make up the main menu for the system. 

1. File 

The file option is a pull down menu of operations. These operations are Add 
Component, Update Component, and Quit. See section A.5 for details on how to select 
pull-down menu items. 


248 




''a 


CAPS SOFTBASE 

“ 

1 Flic 

Srow^e 

Query 

Help 1 



” ■■ - H 

Figure - F.l Main Menu 

a. Add Component 

>Mien this option is chosen the user will be prompted for the input files 
by the input file selection window. See section D for a detailed description of how to use 
this window. 

Once the input files have been selected the system attempts to add the 
component to the software base. If an error occurs an error display will be provided. If 
no errors have occurred the input window will be removed from the screen to indicate a 
successful addition. 

b. Update Component 

This option is used to provide an updated version of an existing 
component. The method used is the same as for adding components except that the new 
PSDL specification and implementation files will replace those that are currently in the 
software base. 


249 





c. Quit 

This option quits the Software base Browsing system. 

2. Browse 

The browse option is a pull-down menu of browsing operations. These 
operations are By Keyword, By Operator, and By Type. See section I for details on how 
to select pull-down menu items. 

a. By Keyword 

Browsing by keyword means that the user will provide a list of desired 
keywords via the Keyword Selection Window and then will be given a Component 
Selection Window containing of those components in the software base which are 
members of at least one of those keyword categories. 

The contents of the Component Selection Window are ordered such that 
those components which are members of more of the desired keyword categories are 
first. See section E for more information on using the Keyword Selection Window and 
section F for use of the Component Selection Window. 

b. By Operator 

Browsing by operator provides a Component Selection Window 
containing all of the operator components in the software base. These components are 
ordered alphabetically. See section F for details of how to use the Component Selection 
Window. 


250 





c. By Type 

Browsing by operator provides a Component Selection Window 
containing all of the type components in the software base. These components are 
ordered alphabetically. See section F for details of how to use the Component Selection 
Window. 

3. Query 

The query option allows for a query of the software base based on a given 
PSDL specification. The user is prompted for a query specification with the Query 
Specification Window. If any components were found that match the query specification 
then a Component Selection Window is provided with all of the names of the matches in 
it. See section VII for details on the Component Selection Window. 

4. Help 

This option provides an on-line version of this manual (not implemented). 

D. INPUT FILE SELECTION WINDOW (FIGURE F.2) 

Inputs to the software base are made up of three text files. The PSDL specification, 
the implementation specification, and the implementation body. The input file selection 
window allows the selection of each of these files. 

The file selection boxes show the current working directory in the Directory Box, 
and all of the files in that directory in the rest of the box. Eiouble clicking on a file in one 
of the file selection boxes selects that file. Double clicking on a directory in a file 


251 



selection box will change to that directory. A new directory can be entered manually by 
typing it in the Directory box. The name of the file can be entered manually by typing it 
into the File Name box. 


IZJ 


CAPS SOFTBASE 


Input File Selection 


PSDl 





Ml 

./ 

Celsius, to. faraaliiat .p«ll 
intoqor.Mt .ps 41 
iato9sr.sot.pk9.bodf. 0 
int090r.sot.pk9. spoe. 0 
Mp.OSMiplO 

9iMuo.pocll 

qaous. psdl. bod. odt 

90000. podl. bod. ops 

90000. psdl .bod. lairoe 

90000. psdl .booloA 

1 


imQitmentaoon Spec 






./ 

. ./ 

colsioo.ttt.faronhiot. psdl 
intogor.sot.podl 
iato9Br.sot.pk9.bodf.o 
iBto90r.sot.pfc9. spoc. 0 
oop.iwplo 

9um.podl 

90000. psdl. bod. odt 
qoooo. psdl. bod. ops 

90000. psdl. bod. vnroc 

90000. podl. boolooa 



impiementanon aodv 


[1. ii.ifAi.djTr^rnirrrm 




./ 

celsiuo.to.foronbiot. psdl 
uito9er.Mt. podl 
iato9sr.tot.pk9.bodf. 0 
iato^r.sotj)k9. fpoc. 0 
o^p.osoaplo 

911000.ps^ 

9USU0. psdl. bod. odt 
qosoo. psdl. bod. ops 

90000.psdl .bod.unroc 

90000. psdl. boolooB 

1 


( Cancel 1 


Figure - F.2 Input File Selecter 


Once all of the input files have been entered pushing, OK will cause the input files 
to be processed. Pushing Cancel will cause the input operation to terminate. 


E. KEYWORD SELECTION WINDOW (FIGURE F.3) 


This window allows the selection of keywords for a keyword search of the software 
base. All keyword categories in the software base are list in the left hand Box. Double 
clicking on a keyword will add it to the Keyword Selected box on the right hand side. 
Double clicking on keywords in the Selected box will remove them. Once the desired 
keywords have been selected pushing OK will start the search of the software base. 
Pushing Cancel will abort the search. 


252 





















0 


softbase.exe 




Keyword Selection Menu 


Keywords Available Keywords Selected 



1 ^ 





heap 






111 <1^ 




( Cancel ] [ok] 


Figure - F.3 Keyword Selecter 


F. COMPONENT SELECTION WINDOW (FIGURE F.4) 


This window displays a list of component names and a one line description of each 
component. Double clicking on a component will bring up a view of that components 
PSDL specification. See section VIII for details on using this view. This window is not 
removed automatically when a component is selected for viewing so that multiple 
components can be viewed simultaneously. To remove this window form the display 
push the cancel button. Pressing the OK button will view the currently selected 
component. 


253 















G. PSDL SPECIFICATION VIEWING WINDOW (FIGURE F.5) 

This window displays the PSDL specification for a given component and allows 
various actions to take place on that component. The action available are: printing the 
specification, saving the specification to a file, deleting the component from the software 
base, viewing the components Ada specification, and searching for a given text string in 
the specification. 

1. File 

This is a pull-down menu for the print, save, delete, and quit view operations. 

a. Print 

Causes a printout of the specification to be spooled to the default printer. 

b. Save As 

Prompts the user for a file name and saves the specification to that file. 


254 











c. Delete 


The system verifies that no other components are dependant on this 
component and if not allows the user to confirm that they wish to remove this component 
from the software base. 

d. Quit View 

Removes this view from the display. 


Q CAPS SOFTBASE 


Viewtna sat pkqPSDL Specification 

Fil« Find View Spec 

Itypa set jikg 
epedricetian 

gwMne t : QINERIC TYPE* 

block_siM : cdOKZC.VALUEs 
eq : GQfERIC.PRDCEDURE 

set : AOT 

operator eapty 
apediicetioB 

output e : set 
end 

operator add 
apecificatiQB 

input 1 : t* Si : set 
output so : set 
end 

operator teiwee 
specification 

ft 

2 




Figure - A.5 PSDL Specification Viewing Window 


2. Find 

Prompts for text to search for and if found repositions the cursor to that text 
(not implemented). 

3. View Ada Specification 

Provides the Ada Specification Viewing Window for this component. 


255 






H. ADA SPECinCATION VIEWING WINDOW (FIGURE F.6) 


This window displays the Ada specification for a given component and allows 
various actions to take place on that component. The action available arc: printing the 
specification, saving the specification to a file, viewing the components Ada body, and 
searching for a given text string in the specification. 


'■g] CAPSSOFTBASE 


Viewinq sat nttalmiilainanUUon Speciflcation 

film Find Vi«v Bodf 

with tAt.io; vmm tftst.lo: 


^■Mrie 

tvp« t is privsts: 
biock^siss: ia iiatiir«l:«t2B; 
vitt prucuAirs eqix.y: in t* ▼ : BOOLEAN): 
psricsqs sb.qnsos is 


typs qimm is prismts; 

typs indss.srrsp is «rr«y(MtursX ratgs <>) of BatnrsI: 


procsdnrs sspt|(st cnt sot): 

pcocxhurs sdd(s: in t: si: in sot* so : cut sot); 
procsAirs rsnovs(s: in t: s: in oot sot); 
procsdors nabseCs: in t: s: in smt, ▼ : booXsan): 
procstes iman(si. s2: in sot: s3: imt sot): 
pcocsduurs diiXsrsnes<sl. 92: in sot: s3: out sot): 
procodurs intsi!ssctiqp(sla 92: in 9St: s3: out sot): 
procsdurs siss(s: in sot. v : out nstural): 
procstkors oqaaKsl. «2; in sst, r : out boolaao): 

3 

d iC> 



Figure - F.6 Ada Specification Viewing Window 


1. File 


This is a pull-down menu for the print, save, and quit view operations. 

a. Print 

Causes a printout of the specification to be spooled to the default printer. 

b. Save As 

Prompts the user for a file name and saves the specification to that file. 


256 





c. Quit View 

Removes this view from the display. 

2. Find 

Prompts for text to search for and if found repositions the cursor to that text 
(not implemented). 

3. View Ada Body 

Provides the Ada Body Viewing Window for this component. 

I. ADA BODY VIEWING WINDOW (FIGURE 7) 

This window displays the Ada body for a given component and allows various 
actions to take place on that component. The action available are: printing the body, 
saving the body to a file, and searching for a given text string in the body. 

1. File 

This is a pull-down menu for the print, save, and quit view operations. 

a. Print 

Causes a nrintout of the body to be spooled to the default printer. 

b. Save As 

Prompts the user for a file name and saves the body to that file. 

c. Quit View 

Removes this view from the display. 


257 





2. Find 


Prompts for text to search for and if found repositions the cursor to that text 
(not implemented). 



Figure - F.7 Ada Body Viewing Window 



258 







APPENDIX - G SOFTWARE BASE GRAPHICAL 
USER INTERFACE SOURCE CODE 


All of the classes with the extension of "-core" in their name are implemented with 
code generated by the ibuild tool which is part of Interviews 3.0b [Ref 19]. This code is 
not presented here since it was machine generated. The class definitions for these "core 
classes" are included since the leaf classes inherit from the "core classes". Ibuild 
generated skeletons for the leaf classes. All that was required to implement this GUI was 
the addition of the code for each of the leaf class methods. 


259 





*ifnd«l SBjnain-menu-core_h 
#<lefin« SBjnaiti-tnenu.core.h 

tinclttde <InterVi6B8/scene.h> 

class Menultem; 

class SB-main.menu-core : public MonoScene { 
public: 

SBjnain.menu.core(const char*); 
virtual void -AddCoinponent(); 
virtual void .UpdateComponent(); 
virtual void quit(); 
virtual void browse.by.keyword(); 
virtual void browse.by.type(); 
virtual void browse.by-operator(); 
virtual void query(); 
virtual void Jlelp(); 
protected: 

Interactor* Interior(); 
protected: 

Menultem* thejiienuJile.quit, 

Menultem* thejnenu-browseJceyword; 
Menultem* the-menu.browse.type; 
Menultem* theJiienu.browse.by.operator; 
Menultem* thejnenu.query; 


#«ndif 



#ilnd6f SBjfnain.menu_h 
#defina SBjnain.menii-h 


#include ’’SBjnainjnenu-core.h” 

class SBjnfiain.menu : public SB.maitumenu-core { 
public: 

SB-main-menu(const char*); 

virtual void j\^ddComponent(); 
virtual void _UpdateComponent(); 
virtual void quit(); 
virtual void browse.by-keyword(); 
virtual void browse.by.typeO; 
virtual void browse.by-operator(); 
virtual void query(); 
virtual void JlelpO; 

}; 


#endil 


261 




#iliidel body.viewer.coreJi 
fdeline body .viewer .core Ji 

#include <InterVieas/scene.h> 

class HBox; 
class Message; 
class MenuBar; 
class PulldownMenu; 
class TextEditor; 
class ButtonState; 

class body.viewer.core : public MonoScene { 

public: 

body.viewer-core(const char*); 
virtual void JSaveas(); 
virtual void J’rinlO; 
virtual void .QuitView(); 
virtual void JindO; 
protected: 

Interactor* Interior(); 
protected: 

HBox* theJilejiame; 

Message* defaultjiiessage; 

MenuBar* menu.bar; 

PulldownMenu* file.meuu; 

TextEditor* the.editor; 

}; 


#«ndif 


262 




tilndal body .viewer Ji 
#d«liii« body.viewer Ji 

tinclude ’’body.viewer-core.h” 

class body.viewer : public body.viewer.core { 
private: 

char* thejstring; 
char* componentjiame; 

TextBuffer *the.bufFer; 


public: 

body.viewer(const char*componentJiame, char *body.file); 

virtual void JSaveas(); 
virtual void J’rintO; 
virtual void .QuitView(); 
virtual void .Find(): 

}; 


#endil 




iilndel component^electer-coreJi 
#deline componentjselecter-coreji 

#includ« <InterVie«s/scene.h> 

class StringBrowser; 
class ButtonState; 
class PushButton; 

class component^electer.core ; public MonoScene { 

public: 

componentjselecter.core(const char*); 
virtual void selected(); 
virtual void cancel(); 
virtual void okay(); 
protected: 

Interactor* Interior(); 
protected: 

ButtonState* the.browser_BS; 

ButtonState* the-caiicel_BS; 

ButtonState* the.ok_BS; 

StringBrowser* the.browser; 

PushButton* cancel .button; 

PushButton* ok-button; 

}; 


#endil 


264 




tilndal componentjselecterJi 
#deline component^lecterJi 

tincluda ”component-selecter-core .h” 
iinclude <streaiii.h> 

class componentjselecter ; public component-selecter.core { 

public: 

component^electer(const char*); 

void Insert.components(); 

void Insert .com ponents( char +filejiame); 

virtual void selected(); 

virtual void cancel(); 

virtual void okav(); 

}; 


#endil 





#ilndel delete.warning-coreJi 
#deline delete.warning-coreJj 

#include <InterVieHs/dialog.h> 

class ButtonState: 

class delete.warning.core : public Dialog { 
public: 

delete.warning-core(const char*); 

protected: 

Interactor* Interior!); 
protected: 

}; 

#endlf 






#ilndel delete.warningJi 
#deline delete.warning-h 

#include ”delete_Harning-core.h” 

class delete.wariiing : public delete.warning.core { 

public; 

delete.wariiing( const chax-+); 


}; 


#endil 





#ilndef dependancy^electer xoreJi 
#deline dependancy^electer j:ore-h 

#include <InterViews/scene.h> 

class Message; 
class StringBrowser; 
class ButtonState; 
class PushButton; 

class dependancyjselecter jcore . public MonoScene { 

public: 

dependancy^electerxore(const char*); 
virtual void new^election(); 
virtual void removexelection(); 
virtual void cancel(); 
virtual void okay(); 
protected: 

Interactor* lnterior(); 
protected: 

ButtonState* the.choice JS; 

ButtonState* tlie^elected^S; 

ButtonState* cancel.BS; 

ButtonState* ok.’yJBS; 

Message* thejianie: 

Message* the.choicejiiessage; 

StringBrowser* choice.browser; 

Message* thejselected juessage; 

StringBrowser* selected-browser: 

PushButton* the-caucelJbutton: 

PushButton* the.ok.button; 

}; 


#endif 






#ifndef dependancy^electer Ji 
tdefine dependancy^electer Ji 

#include ”dependancy_selecter-core .h” 

class dependancyjselecter : public dependancy_selecter_core { 

public; 

dependancy-selecter(const char*); 

void Insert_coiTiponents(); 
virtual void new^election(); 
virtual void remove^election(); 
virtual void cancel(); 
virtual void okav(); 

}; 

#endif 


209 






#ilndel error .viewer .core Ji 
#define error.viewer.coreJi 

#include <InterVieHs/scene.h> 

class HBox; 
class Message; 
class TextEditor; 
class ButtonState; 

class error .viewer .core : public MonoScene { 

public; 

error.viewer.core(const char+); 
virtual void ok.action(); 
protected: 

Interactor* Interior(); 
protected; 

ButtonState* ok.BS; 

HBox* theJilejiame; 

Message* defaultjnessage; 

TextEditor* the.editor; 

}; 


#«ndil 




#ilndel error.viewerJi 
#detina error-viewer Ji 
#include <IiiterViews/textbuller .h> 

#include ’’error.viewer-core.h” 

class error.viewer : public error.viewer.core { 
private: 

TextBuffer ♦the-buffer; 

public: 

error_viewer(const char*iianie, char ♦error_file); 
void ok-action(); 


}: 


#endif 







#ilnd6l inputJilejselecter.coreJi 
#delin« input Jile^electer.core Ji 


#incluca <InterVieHs/scene.h> 

class StringEditor; 
class ButtonState; 
class FileBrowser; 

class inputjile^electer-core : public MonoScene { 

public; • 

input Jile^electer j:ore(const char *); 
virtual void new.psdLfile_name(); 
virtual void update.pdsLdir(); 
virtual void psdl-selected(); 
virtual void new.spec_file.name(); 
virtual void update_ada_spec.dir(); 
virtual void spec^elected(); 
virtual void new.body_file_name(); 
virtual void update-ada.body-dir(); 
virtual void body^elected(); 
virtual void cancel(); 
virtual void okay(); 
protected: 

Interactor* lnterior(); 
protected; 

ButtonState* psdlJilejianie.BS; 

ButtonState* psdLdir.BS; 

ButtonState* psdlJBS; 

ButtonState* specJilejiame_BS; 

ButtonState* adajspec.dir JS; 

ButtonState* specJiles_BS; 

ButtonState* bodyJile-name.BS; 

ButtonState* ada.body-dir_BS; 

ButtonState* bodyJilesJS: 

ButtonState* canceLBS; 

ButtonState* okay_BS; 

StringEditor* psdlJile_name; 

StringEditor* psdl.dir; 

FileBrowser* psdIJiles; 

StringEditor* specJilejiame; 

StringEditor* adajspec.dir; » 

FileBrowser* specJiles; 

StringEditor* bodyJilejiame; 

StringEditor* ada.body_dir; 

FileBrowser* bodyJiles; 

}; 


#endif 


2T2 






#ilndaf inputJile-selecter-h 
#delina input-file^electerJi 

#include ” input.f ile.selecter-core. h” 

class input-filejselecter : public input-file-seiecter.core 

public: 

inputJilejelecter(const char*); 

virtual void new.psdLfile.name(); 
virtual void update.pdsLdir(); 
virtual void psdl-selected(); 
virtual void new.spec-file-name(); 
virtual void update-ada_spec-dir(); 
virtual void specjselected(); 
virtual void new.body_file-iiame(); 
virtual void update-adsubody.dir(); 
virtual void body^elected(); 
virtual void cancel(); 
virtual void okav(); 

}; 


#endil 





tilndel keywordjselecterxore Ji 
#d«fine keywordjselecterxoreJi 

#include <InterVie0s/8cene.h> 

class Message; 
class StringBrowser; 
class ButtonState; 
class PushButton; 

class keyword-selecterxore : public MonoScene { 

public; 

keywordxelecterxore(const char*); 
virtual void Hewxelection(); 
virtual void remove_seiection(); 
virtual void cancel(); 
virtual void okay(); 
protected: 

Interactor* Interior(); 
protected: 

ButtonState* thexhoice_BS; 

ButtonState* thexelected JS; 

ButtonState* canceLBS; 

ButtonState* ok.BS; 

Message* thejiame; 

Message* thexhoice Jiiessage: 

StringBrowser* choice .browser; 

Message* thejselected xnessage; 
StringBrowser* selected .browser; 

PushButton* the.cancel Jjutton: 

PushButton* the.ok.button; 

}; 

#endif 


274 





tifndaf keyword^lecter Ji 
keyword^electer Ji 

#includ« ”keyword-selecter-core. h” 

class keyword-selecter ; public keyword_selecter_core 

public: 

keyword3electer(coust char*); 

void Insert _keywords(); 
virtual void newjelection(); 
virtual void remove^election(); 

virtual void cancel(); 
virtual void okay(); 

}: 

#endil 





#iliid«l psdl-viewer.coreJi 
tdefine psdLviewer-coreJi 

#include <InterVieBs:/scene.h> 

class HBox; 
class Message; 
class MenuBar; 
class PulldownMenu; 
class Menultem; 
class TextEditor; 
class ButtonState; 

class psdLviewer.core : public MonoScene { 

public: 

psdl-viewer.core(const char*); 
virtual void ^aveas(); 
virtual void J*rint(); 
virtual void _Delete(); 
virtual void .QuitView(); 
virtual void -Find(); 
virtual void view.spec.actioii(); 
protected: 

Interactor* Interior!); 
protected: 

HBox* theJilejiame; 

Message* defaultjuessage; 

MenuBar* menu.bar; 

PulldownMenu* file-menu; 

Menultem* view.spec; 

TextEditor* the.editor; 

}; 

#eiidif 


276 




filndel psdLviewerJi 
tdeline psdI.viewerJi 

tfinclude ’’psdl.vieHer-core.h” 

#include <Int erViews/t extbulf er.h> 
class psdLviewer : public psdLviewer.core 
{ 

private: 

char *component_name; 
char ♦psdlJile; 
char ♦spec Jile; 
char ♦body-file; 
char ♦the.string; 

TextBuffer ♦tbe.buffer; 


public: 

psdl.vie\ver(coiist char^); 

virtual void .Savea.s(); 
virtual void .Print(); 
virtual void -Delete(); 
virtual void .Quit\'iew(); 
virtual void .Find(); 
virtual void view.spec.action(); 
virtual void Handle(Event&): 

}; 


#endif 






*ilnd«t query Jile.dialog.coreJi 
fdeline queryJile-dialog.core-h 

#include <InterVieus/dialog.h> 

class StringEditor: 
class ButtonState; 
class FileBrowser; 

class query-file.dialog-core : public Dialog { 
public: 

query Jile_diaiog-core( const char *); 

virtual void file.uame.action(); 
virtual void directory-action(); 
virtual void file.browser-action(); 
virturd void canceLaction(); 
virtual void okay^ctioii(); 
protected; 

Interactor* Interior!); 
protected: 

ButtonState* dialog^S; 

ButtonState* theJilejiame.BS; 
ButtonState* directory.name.BS; 
ButtonState* file.browser_BS; 
ButtonState* cancel.BS; 

ButtonState* okay.BSi 
StringEditor* theJilejiame; 
StringEditor* directoryjiame; 
FileBrowser* tlieJile.browser; 

}; 


#endif 






#ilndftf query Jile.dialog.h 
#d«fin« query Jile.dialog.h 

#include ” query.lile_dialog-core. h” 

class query-file-dialog : public query .file_dialog_core { 

public; 

query-file.dialog(const char*); 

virtual void file-name_action(); 
virtual void directory.action(); 
virtual void file-browser-action(); 
virtual void canceLaction(); 
virtual void okay_action(); 
const char* filejiaine(); 

}; 


#endi{ 





#ilnde{ save.browser.dialog-CoreJi 
#delin« save.browser-dialog-core Ji 

tinclude <InterVieHs/dialog.h> 

class StringEditor, 
class ButtonState; 
class FileBrowser; 

class save.browser.dialog.core : public Dialog { 
public: 

save.browser_dialog-Core(const char*); 

virtual void update.file-name(); 
virtual void update_directory(); 
virtual void file-browser.actioti(); 
virtual void canceLaction(); 
virtual void oLactioti(): 
protected; 

Interactor* Interior!); 
protected; 

ButtonState* dialog-BS; 

ButtonState* file-iiame.BS; 

ButtonState* new.directory_BS: 
ButtonState* file.browser J3S; 

ButtonState* cancel.BS; 

ButtonState* ok.BS: 

StringEditor* theJileJianie; 

StringEditor* the.directory jianie; 
FileBrowser* theJile.browser: 

}; 


#endif 





#ilndel save_browser-dialogJi 
#deline save.browser .dialog Ji 

#include ”save_browser_dialog-core .h” 

class save.browser.dialog ; public save-browser.dialog-core 

{ , 

private: 

char +default_name; 


public: 

save.browser .dialog! const char+name); 


virtual void file.browser-action(); 
virtual void update.file.name(); 
virtual void update.directory(); 
virtual void cancel.action(); 
virtual void ok.action(); 
const char ♦filejiaine(); 


#endil 


281 



#ilndel spec .viewer .core Ji 
#deline spec .viewer .core Ji 

#include <InterViews/scene.h> 

class HBox; 
class Message; 
class MenuBar; 
class PulldownMenu; 
class Menultem; 
class TextEditor; 
class ButtonState; 

class spec.view’er.core : public MonoScene { 

public: 

spec.viewerjcore(const chart); 
virtual void JSaveas(); 
virtual void J*rint(); 
virtual void .QuitView(); 
virtual void JindO; 
virtual void view.body.action(); 
protected: 

Interactort Interior!): 
protected: 

HBox* theJileJiame; 

Message* defaultjnessage; 

MenuBar* menu.bar; 

PulldownMenu* filejnenu; 

Menultem* view.body; 

TextEditor* the.editor; 

}; 


#endif 


282 




#iliul6l spec.viewer Ji 
ffdflline spec .viewer Ji 


#include ’’spec.viewer-core.h” 

class spec.viewer : public spec.viewer.core { 

private; 

char ♦componentjiame; 
char ♦bodyJile; 
char *thejstring; 

TextBuffer *the.buffer; 


public: 

spec.viewer(const char*coinponent.name, char+specJile, char +bodyJile); 

virtual void .Saveas(); 
virtual void J’rintO; 
virtual void .QuitView(); 
virtual void J'indO; 
virtual void vi*'w.bodv.action(); 

}; 


#endil 




iinclude <InterVieHs/menu.h> 
#iiiclud« ’’SBjnain-fflenu.h” 
tinclude <InterVieHs/button.h> 
#include <InterVieas/interactor.h> 
tinclude <InterVieHs/2.6/-enter. h> 
#include <InterVievs/frorld.h> 
#include "keyvord-selecter.h” 
#include ’’component-selecter .h” 
tinclude ” input-f ile.selecter. h” 
#include ’’error.viewer .h” 

#include <stream.h> 

#include <strstream.h> 

#include <stdlib.h> 

#include <string.h> 

#include ”query-file.dialog.h” 


#deline TEMPJ:NVIR0NMENT "TEMP" 
#define CAPS-ENVIRONMENT "CAPS" 
#deline DEFAULT.TEMP "/tmp" 
#delina TL-PREFIX "tmptl" 

#deline ERROR-PREFIX "tmperror" 
•define SB_PROGRAM "sb" 


SB-main.menu::SB-maiii-menu(const char* name) : SB-main.menu.core(name) {} 

void SB-main-menu::quit() 

{ 

World* w=GetWorld(); 
w-*quit(); 

} 

void SBjnaiii-menu;;browse.by.kevword() 

{ 

World* w=GetWorld(); 

keyword jselecter* the Jrey word-selecter=new key word jselecter("the.key_word_selecter"); 
theJceyword-selecter—Insert Jreywords(); 

//the.keyword.selecter->SetName(”Keyword Selection”); 
w—»InsertToplevel(the Jcey word-selecter,this); 

} 

void SBjTiain_menu;:browse.by-tvpe() 

{ 

World* w=GetWorld(); 

component-selecter* component-selecter-by-type=new 

component.selecter("component-selecter-by-type"); 

// create list of components 
int commandjstatus; 
ostrstream command.buffer; 
ostrstream remove-buffer: 


284 






char ♦caps-dir = getenv(CAPS-ENVIRONMENT); 
char ♦temp.dir = getenv(TEMP-ENVIRONMEiNT); 
if (temp-dir == NULL) 

{ 

temp-dir = new char[strlen(DEFAULT.TEMP) + 1]; 
strcpy(temp-dir, DEFAULT-TEMP); 

}; 


command-buffer 4 ; SB-PROGRAM <C " tl ada 
char ♦list-file = tempnam(temp-dir, TL-PREFIX); 
char ♦error-file = tempnam(temp-dir, ERROR-PREFIX); 
command-buffer <C list-file <C " > " <C error-file <C ends; 

remove-buffer <C "rm "; 
remove-buffer 4C error.file <C ends; 

char ♦rm-command = remove-buffer.str(); 

char ♦command = command-buffer.str(); 
command-status=system(command); 
if (command.status==0) 

{ 

// no error occured so pass the tl to the component selecter 
componentjselecter.by-type—‘Insert xomponents(listJile); 
w—Insert Application! component-selecter-by-type); 


} 

else 

{ 


// display error info 

cerr < "AN ERROR OCCURED WITH COMMAND " < command < "\n 


// remove temp files 
system! rm-command); 
delete command; 
delete rm-command; 


}; 


void SB-main-inenu: :browse-by-operator!) 

{ 

Worlds w=Get\Vorld!); 

component-selecter^ componentjselecter.by-type=new 

component-selec ter! "component-select er.by-type"); 
// create list of components 
int command-status; 





ostrstream command-buffer; 
ostrstream remove-buffer; 


char ♦caps-dir = getenv(CAPS-ENVlRONMENT); 
char *temp-dir = getenv(TEMP-ENVIRONMENT); 
if (temp-dir == NULL) 

{ 

temp-dir = new char[str!en(DEFAULT-TEMP) 4- 1]; 
strcpy(temp-dir, DEFAULT-TEMP); 

}; 


command-buffer <€. SB-PROGRAM " ol ada 
char ♦list-file = tempnam(temp-dir, TL.PREFIX); 
char ♦error-file = tempnam(temp-dir, ERROR-PREFIX); 
command-buffer -C list-file <C " > ” error-file <C ends; 

remove-buffer <C "rm "; 
remove-buffer <C error-file <C ends; 

char ♦na-command = remove.buffer.str(); 

char ♦command = command_buffer.str(); 
commandjstatus=system(command); 
if (commandj5tatus==0) 

{ 

// no error occured so pass the tl to the component selecter 
component-selecter-by-type—►Insertxomponents(list.file); 
w—Insert Applicationfcomponent-selecter-by-type); 


} 

else 

{ 


// display error info 

cerr < "AM ERROR OCCURED WITH COMMAND ” < command < "\n" 


// remove temp files 
system( rm-command); 
delete conimand; 
delete rm-command; 


} 

void SB-main-menu::query() 

{ 

World^w=GetWorld(); 

query-file-dialogs the.query-dialog=new 

query -file.dialogf "the-query-dialog"); 
w—InsertTransient( the jqueryjdialog,this); 


286 





boolean status-flag=the_query-dialog—*Accept(); 
if(status_flag) 

{ 

w—*sync(); 

int commancLstatus; 

ostrstream command.buffer; 
ostrstream remove.buffer; 

char *caps_dir = getenv(CAPS-ENVIRONMENT); 
char ♦temp-dir = getenv(TEMP_ENVlRONMENT); 
if (temp-dir == NULL) 

{ 

temp.dir = new char[strlen(DEFAULT_TEMP) + 1]; 
strcpy(temp.dir, DEFAULT-TEMP); 

}; 

command-buffer <C SB-PROGRAM <C ” cq ada 
char ♦list-file = tempnam(temp-dir, TL-PREFIX); 
char ♦error.file = tempnam(temp-dir, ERROR-PREFIX); 
command-buffer -C the-query-dialog—►file_name() <C " "; 
command-buffer <C list-file <C " > " ■< error-file <C ends; 

remove-buffer -C "rm "; 
remove.buffer ^ error Jile ends; 

char ♦rm.command = remove.buffer.str(); 

char ♦command = command-buffer.str(); 
command^tatus=system(command); 
if (command.3tatus==0) 

{ 

// no error occured so pass the tl to the component selecter 

component jselecter+ componentjselecter-by.query=new 
component.selecter( "component.selecter.by .query"); 


component jselectef-by .query—‘Insert xomponents(list .file); 
w—Insert Application! component jselecter-by .query); 


} 

else 

{ 

// display error info 
error-viewer ♦error-view=new 
error.viewer("Add Component ".error.file); 
w—Insert Application(error-view); 


}; 


2M 



// remove temp files 
system( rrri-command); 
delete command; 

delete rm.command; 

w—>Remove(tlie_query-dialog); 
delete the.query .dialog; 


} 


void SB.main.menu::.AddComponent() { 

World* w=GetWorld(); 

input-filejselecter* inJile=iiew input.file3electer("in_file"); 
w—>lnsertApplicat.ion( in-file). 

} 

void SBjTiain-menu::.UpdateComponent() 

{ 

World* w=GetWorld(); 

input-filejselecter* inJile=new input.filejselecter("in_file"); 
w-*lnsertApplication(ir..file); 


}; 


void SB.main-menu::-Help() 

{ 

system!"doc "title 'Soltbase Help' soitbaseLhelp.docft"); 

} 


288 






#include <InterViess/button.h> 

#include <InterVieHs/box.h> 

#include <InterVieBs/message.h> 

#include <InterVieHs/menu.h> 

#includ« <InterVievs/texteditor.h> 

#include <InterVie8s/textbufler.h> 
tinclude ’’body.viewer .h” 

#include ’’spec-viewer .h” 

#include ’’body.viever .h” 
tinclude ” save-browser.dialog. h” 

#include <InterVieas/Horld.h> 

# include <InterViewa/2.6/_enter .h> 

#include <strstreaffl.h> 

#include <stream.h> 

#include <stdlib.h> 

#include <string.h> 

body.viewer:;body.viewer(const char* name, char tbodydile) : 
body-viewer.core(name) 

{ 

componentJiame=(char ♦)name; 
ostrstream viewjiame.buffer; 

viewjiame.buffer componentJiame <C "Implementation Body" <§; ends; 
the Jilejiame—Remove( default-message); 
delete default-message; 

Message* tlieJilejTiessage=new Message("filo_name", 

view.name.buffer.str(), 

Center); 

the.filejiame—>Insert{the.filejTiessage); 
tlie-file-iiame—Change(); 

ifstream body(body_file); 
if(body) 

{ 

ostrstream construct .buffer; 
while(!bodv.eof()) 

{ 

char text=body.get(); 
if(text^EOF) 

{ 

construct-buffer.putftext); 

}; 

}; 

thejstring=construct Jbuffer.strO; 
int theJength=strlen( the .string); 

the-buffer=new Text Buffer( the-string, the Jength,th'^,Jength); 
the-editor—Edit(the-bufFer); 

} 

else 

{ 


289 




cerr < "UIABLE TO OPEI BODY FILE TO VIEW FILEJAME IS " 
cerr <C body Jile <C! "\n"; 


}; 


} 


void body.viewer::_Saveas() 

{ 

ostrstream def-nanie.buffer; 

def_name.buffer <C componentJiame <C ".body. a" <C ends; 
char ♦defjianie=def_name-bufFer.str(); 

save_browser-dialog ♦save-browser=new save-browser .dialog(def_name); 

World ♦w=GetWorld(); 

w-—lns€rtTransient(save-browser, this); 

boolean save.flag=save-browser—*Accept(); 

if(save-flag) 

{ 

ofstream outpul-file(save-browser—file-name()); 
output-file the.string; 
out|iut.file.close(); 

}; 

w—Remove! save-browser): 
delete save-browser; 


} 

void body-viewer:Print!) { 
/♦ unimplemented ♦/ 

} 


void body-viewer::-Find!) { 
/+ unimplemented */ 

} 


void body-viewer::-QuitView!) 

{ 

If remove temp file and remove application from the world 
World ♦w=GetWorld!): 
w—^ Remove! this); 
jjdelete this: 


• 2<»0 


} 




tinclud* <Int«rVieBs/button.h> 
iincluda <InterVieHs/strbroaser.h> 
■^include ” componentjialecter.h" 
tinclttde <InterVie0s/2.6/.enter. h> 
tinclude <stream.h> 
tinclude <string.h> 

#include <InterVieHs/world.h> 
tinclude "psdl.viever .h” 
tinclude <strstreeuii.h> 

extern "C" 

{ 

int system!char ♦); 

}; 


tdefine MAX.NAME.LENGTH 2.^)6; 

componentJ5electer::com|)onent-.selecter(const char* name) : componentjselecter-core(name) {} 

void component3electer;:selected() 

{ 

int state.value; 

the J)rowser-BS—Get Value! state .value); 
if!state.value^O) 

{ 


World* w=GetWorld!): 
w—sync!); 

int selected Jude,x=:the J)rowser—Selection!0); 
if! selected jiule.\>0) 

{ 

char *selected .buffer=the browser— 

String!selected Jndex); 

char *selected jiame=new char[strlen!selected-bufrer)+l]; 
int i=0: 

while!selected-bufTerfiJ^^’ ') 

{ 

selected Jiame[i]=selectedJbuffer[i]; 
i+4-; 

}; 

selected jiame[i] = NULL; 

psdLviewer* the.psdLview=new 

psdl-viewerfselected Jiame); 
w—Insert Application! the 4 )sdl .view); 

} 

else 

{ 

w—RmgBell! 100); 

): 

the.browser J3S—Set Value!0); 


201 






} 


}; 


void component^lecter;;cancel() 

{ 

World* w=GelWorld(); 
w—► Remove! this); 
delete this; 

}; 

void component^electer::okav() 

{ 

int state.value; 

the x)k.BS—>GetValue(st ate .value); 
if(state-value^O) 

{ 

the.browserJlS—Set Value! 1 '• 
tlie.ok.BS—Set \'alue!0); 

}; 

} 


void com poiientjselec ter:: Insert .components!) 

the.browser—Append! "comp 1"); 
the.browser—Append!“comp 2"); 
the.browser—Append!"comp 3"); 
the.browser—Append!"comp 4"); 
the.browser—Append!"comp 5"); 
the.browser—Append!"comp 6"); 
the.browser—Append!"comp 7"); 
the.browser—Append! "comp 8"); 
the.browser—Append!"comp 9"); 
the.browser—Append!"comp 0"); 

}; 

void component.selecter::insert.components!char *filejiame) 

{ 


char the.component[256); 

ifstream infile!filejiame); 

infile » ws; 
while! linfile.eof!)) 

{ 

infile.getline!f he.component.256); 
the.browser—Append! the jcomponent); 
infile ^ ws; 

}; 


■292 




ostrstream command; 

command ■< "rm " -C filejiame <C ends; 

char ♦the,command=command.str(); 


system(the_command); 






#include <InterViews/button.h> 

#include ’’dslete.narning.h” 

#include <InterVieHs/2.6/-eiiter.h> 

delete-warning:;delete-warning(const char* name) : delete_warning.core(name) {} 






tinclude <InterVie»s/me8sag«.h> 

#include <InterViews/strbroaser.h> 
tinclude <InterVie«s/button.h> 
tinclude ’’dependancy-selecter .h” 
tinclude <InterViews/Horld.h> 
tinclude <InterViews/2.6/_enter. h> 

dependancy^electer;:dependancv^electer(const char* name) ; dependancyjelecterj:ore(name) 

{} 

void dependancyj5electer::Insert j:omponents() 

{ 

choice.browser—► Append( "comp 1"); 
choice-browser—‘Append)"comp 2"); 
choice.browser—‘Append)"comp 3"); 
choice-browser—Append)"comp 4"); 
choice-browser—Append) "comp 5"); 
choice.browser—Append)"comp 6"); 
choice-browser—Append)"comp 7"); 
choice.browser—Append)"comp 8"); 
choice-browser—Append) "comp 9"); 
choice.browser—Append)"comp 0"); 

}; 


void dependancy.selecter:;new.selection)) 

{ 

iiit state-value; 

the .choice-BS—Get Value)state .value); 
if)state.value^O) 

{ 

// get the new selection and check it against the 

II selected list if it is not there than add it 

iiit selected jndex=choice-browser—Selection)0); 

char *new.selection=choiceJbrowser—String)selectedindex); 

if)selected-browser—Index) new .selection)<0) 

{ 

// not in the selected browser so append it 
selected .browser-Append) new .selection); 
the.choice.BS—Set Value)0); 

}; 

}; ■ 

} 

void dependancy.selecter: :remove^selection)) 

{ 

int state .value; 

the.selected.BS—Get Value)state .value); 
if)state.value^O) 

{ 

// remove the selected entry from the browser 


29o 



int selected Jndex=selected browser—+Selection(0); 
selected J)rowser—»Remove(selected index); 
the^elected J3S—'SetValue(O); 


} 

void dependancy^electee: ;cancel{) 

{ 

World* w=GetWorld(); 
w—* Remove( this); 
delete this; 

} 

void dependancy^electer::okay() { 
World* w=GetWorld(); 
w—►Remove! this); 
delete this; 

} 


296 



#include ’’error-viewer .h” 

♦include <InterViews/button.h> 

♦include <InterViens/box.h> 

♦include <InterViews/message.h> 

♦include <InterVieus/menu.h> 

♦include <InterVie 0 s/texteditor.h> 

♦include <InterViews/textbufler.h> 

♦include <InterViews/world.h> 

♦include <InterVie«s/2.6/-enter .h> 

♦include <str3tream.h> 

♦include <streaiii.h> 

♦include <stdlib.h> 

♦include <string.h> 

error-viewer;:error_viewer(const char* name, char ♦errorJile) : 
error-viewer-core( name) 

{ 

ostrstream view-iiame-bufTer; 
view-name-buffer "Error Messages" <C ends; 
the-file jiame—*Remove( default-message); 
delete default-message; 

Message* the-file-message=new Message(" error-file", 

view_name-buffer.str(), 

Center); 

the-filejiame—>Insert(the.filejnessage); 
the Jile Jiame—Change)); 

ifstream error(error-file); 
if (error) 

{ 

ostrstream construct-buffer; 
while) lerror .eof))) 

{ 

char text=error,get(); 
if(text5.tE0F) 

{ 

construct-buffer.put(text); 

}; 

}; 

char *the.string=construct-buffer.str(); 
int theJength=strlen(thejstring); 

the-buffer=new TextBuffer(thej5tring,theJength,the Jength); 
thejeditor—Edit(the-buffer); 

} 

else 

{ 

cerr <C "UHABLE TO OPEK BODY FILE TO VIEW FILE-KAME IS 
cerr C error-file -C "\n"; 

}; 


297 




} 


void error.viewer;:ok-action() 

{ 

World ♦w=GetWorld(); 
w—►Remove(this); 

/Idelete this; 



#iiiclude <Int«rVie¥s/button.h> 

#include <IiiterVieHs/streditor. h> 

#include <InterVie 0 s/filebrowser.h> 

#includ« ” input_lile.selecter. h” 

#include ’’error.viewer.h” 

#iiiclude <InterViews/2.6/_enter. h> 

#include <strecun.h> 

#include <string.h> 
tinclude <strstreaffl.h> 

#include <InterViews/world.h> 

#include <sys/parain.h> 

#include <stdlib.h> 
extern ”C" 

{ 

extern char ♦getwd(char ♦); 

}; 

#define TEMPJ:NVIR0NMENT "TEMP" 

#define CAPSJ:NVIR0NMENT "CAPS" 

#deline DEFAULT .TEMP "/tmp" 

#deiine KWL.PREFIX "tmpkl" 

#deline ERROR-PREFIX "tmperror" 

#deline KWQ.PREFIX "tmpcl" 

#define SBJ’ROGRAM "sb" 

inputJiiej5electer::inputJiJe.selecter(const char* name) : inputJilejselecter.core(name) { 

char pathname[MAXPATHLEN]; 
getwd(pathname); 
psdlJiles—Set Directory (pathname); 
spec Jiles—‘Set Directory( pathname); 
bodyJiles—*SetDirectory(pathname); 
psdl.dir—> Message( psdl Jiles—GetDirectory()); 
adaj5pec.dir—Message(psdljdir—‘TextO); 
ada.body.dir—►Message(psdl.dir—*Text()); 


} 

void inputJile.selecter::psdl.selected() 

{ 

int state .value; 

psdUS—►Get Value(state.value); 
if(state.value/0) 

{ 

int index=psdlJiles—>Selection(0); 

if(psdlJiles—►IsADirectory(psdlJiles—Path( index))) 

{ 

psdl.dir—*Message(psdlJiles—>Path( index)); 
ada^pec-dir—“Message! psdl Jiles—Path(index)); 
ada.body.dir—Message!psdl.files—Path( index)); 
psdl Jiles—Set Directory!psdLdir—Text!)); 


299 



spec-files—* Set Directory (psdl jdir—►Text()); 
body-files—*SetDirectory(psdl.d!r—►TextO); 
psdl.file_name—MessageC*"); 
spec-file-name—►Message( 
body-file.name—»Message("*'); 

} 

else 

{ 

psdlJUejiame—►Message(psdl_files—►Path(index)); 

// update the other file names if the correct ones exist 

}; 

psdl-BS—*SetValue(0); 

}; 

} 

void input_file.selecter::iipdate.pdsLdir() { 
int state.value; 

psdl-dir-BS—*GetValue(state-value); 
if(state-value^O) 

{ 

// the ttser has entered a directory name of his own 

const char *temp-directory=psdLfiles—*Normalize(psdLdir—►TextO); 

char *new-directory=new char[strlen(temp_directory)+l]; 

strcpy(new jdirectory.temp-directory); 

if(psdlJ]les—lsADirectory(new-directory)) 

{ 

psdl.dir—Message(new-directory); 
ada-spec-dir—Message(new-directory); 
ad a-body.dir—*Message(new-directory); 
psdi-files—SetDirectory(new jdirectory); 
spec -files—Set Directory( new jdirectory); 
body-files—SetDirectory (new -directory); 

}; 

delete new-directory; 
psdl-dir-BS—SetV’alue(O); 

}; 


void input-file.selecter::spec.selected() 

{ 

int state.value; 

specJiles-BS—Get Value(state-value); 
if(state-value^O) 

{ . 

int index=:spec-files—Selection(O); 
if(specJiles—IsADirectory(spec-files—Path(index))) 

I 

I 

ada-spec-dir—Message(specJiles—Path( index)); 
ada-body.dir—Message(spec Tiles—Path(index)); 
spec-files—Set Directory! ada-spec -dir—Text()); 
body.files—Set Directory (ada.spec.dir—Text()); 


300 





} 

else 

{ 

specJilejiame—Message(spec Jiles—►Path(index)); 

// update the other file names if the correct ones exist 

}; 

spec-filesJBS—*SetValue(0); 

}; 

} 

void input Jile^electer::updatejda^pecjdir() 

{ 

int state.value; 

ada-spec.dirJS—‘Get V'alue(state-value); 
if(state-value^O) 

{ 

// the user has entered a directory name of his own 

const char ♦temp.directory=spec-files—‘Normalize(ada-spec-dir—*Text()); 
char ♦uew-directory=new char[strlen(temp.directory)+l]; 
strcpy (new jdirectory,temp-directory); 
if(spec-files—Is ADirectory(new-directory)) 

{ 

ada.spec-dir—►Message( new-directory); 
ada-body-dir—►Message(new-directory); 
spec -files—‘SetDirectory (new jdirectory); 
body-files—►SetDirectory(new-directory); 

}; 

delete new-directory; 
ada.spec-dir-BS—SetValue(O); 

}; 

} 

void input-file-selecter::body-selected() { 
int state-value; 

body-files-BS—‘GetValue(state-value); 
iffstate-value^O) 

{ 

int index=body-files—Selection(O); 
if(body-files—»IsADirectory(body_fiIes—‘Path(index))) 

{ 

ada-body-dir—*Message( body-files—‘Path(index)); 
body-files—>SetDirectory(ada.body-dir—‘Text()); 

} 

else 

{ 

body-file-name—‘Message! body-files—►Path(index)); 

}i 

body-files.BS—SetValue{0); 


301 


J 






}; 

} 

void input Jile^electer:;update^da-bocly-dir() 

{ 

int state.value; 

ada.body.dir.BS—>GetValue(state.value); 
if(state-value^O) 

{ 

// the user has entered a directory name of his own 

const char ♦temp-directory=body_files—►Normalize(adcLbody-dir—►TextO); 
char ♦new.directory=new char[strlen(temp.directory)+l]; 
strcpy(new jdirectory,temp.directory); 
if(body-files—Is ADirectory(new .directory)) 

{ 

ad a.b ody .d i r—• Message( new .d i rectory); 
bodvJiles—SetDirectory( new .directory); 

}; 

delete new.directory; 
ada.l)ody.dir-BS—SetValue(O); 

}; 

} 

void inputJile.selecter::cancel() 

{ 

World ♦w=GetWorld(): 
w—*Remove(this); 
delete this; 

} 

void input Jilejselecter::okay() 

{ 

int conimandjstatus; 

World *w=GetWorld(); 

char *psdlJile=NULL; 
char +specJile=NULL; 
char ♦bodyJile=NULL; 
ostrstream psdlJile.buffer; 
ostrstream specJileJjuffer; 
ostrstream bodyJile.buffer; 

// verify that all of the selected items are files 
i^psdlJiles—Selections( )>0 kk bodyJiles—‘Selections() > 0 kk 
spec Jiles—“Selections!) > 0) 

{ 

// something has been selected in each browser 
II so see if they are all valid files 

int psdIJileJium=psdlJiles—Selection!0); 

int specJiIejumi=spec Jiles—Selection!0); 

int bodyJile.num=bodyJiles—Selection!0); 

if!!psdlJiles—IsADirectory!psdlJiles—*Path!psdlJilejium))) 


302 





{ 

// not a directory so get the file-name 
psdlJile.buffet ^ psdl-files—fPath(psdl_filejium); 
psdlJile-buffer -4^ ends; 
psdlJile=psdl_file.buffer.str(); 

if( !spec Jiles—IsADirectory (spec-files—>Path(specjilejium))) 

{ 

// not a directory so get the file.name 

spec-file Jauffer -C spec Jiles—♦Path(spec iile Jium); 

spec JileJauffer -C ends; 

spec Jile=spec Jile J)uffer.str(); 

}; 

if(!body-files—IsADirectory(bodv-files—►Path(bodyJile-num))) 

{ 

// not a directory so get the file.name 
body Jile-buffer <C body .files—►Path(body_file_num); 
body JHe.buffer <C ends; 
bodv-file=body-file-bufrer.str(); 

}; 

if(specJile5£NULL kk psdlJleytNULL kk bodyJile^^NULL) 

{ 

// all were valid files so process the addition 
char ♦temp.dir=getenv(TEMP JINVIRONMENT); 

if(temp.dir==NULL) 

{ 

temp-dir=new char[strlen(DEFAULT_TEMP)4-1]; 
strcpy(temp-dir,DEFAULT-TEMP); 

}; 

char ♦error Jile=tempnam(temp-dir,"tnipa’’); 
ostrstream command-bufTer; 

CO mm and-buffer «C SB.PROGRAM <C " ca ada "; 
command-buffer •<C psdLfile; 
command-buffer <g; " " <C specJile; 
command-buffer <tC " " <C bodyJile; 
command-buffer <C " > " C error.file <C ends; 

ostrstream rm.buffer; 

rm.buffer "rm " -C error_file <C ends; 


char ♦command=command.buffer.str(); 


command_status=system(command); 

if(command-status:^0) 


// display error info 
error-viewer ♦error-view=new 


303 







error_viewer("Add Component",error-file); 
w—Insert Application(error.view); 
char ♦rm=:rm-buffer.str(); 
system (rm); 

} 

else 

{ 

char ♦rm=rm_bufFer.str(); 
system(rm); 

}; 

w—►Remove(this); 
delete this; 

} 

else 

{ 

w—RiiigBell( 100); 

}: 

} 

else 

{ 

w-RingBell(lOO); 

}; 


} 


void input.filejselecter::new 4 )sdlJileJiame() 

{} 

void input_filejselecter::new^pec Jile jiameO 

{} 

void inputJile-selecter::newJbody Jilejiame() 

{} 


304 





#iiiclude <InterVieHs/button.h> 
tinclude <InterVie 0 s/message.h> 
#include <IntarViav8/strbrowser.h> 
#includa "kayvord-salactar .h" 
#includa <IntarViaws/2.6/.enter. h> 
#includa <8tra^un.h> 

#includ8 ”componant-salactar. h": 
#includa <InterViaws/world.h> 
tincluda <8trstr8an.h> 
kincluda <8tdlib.h> 
tincluda <string.h> 

#dalina TEMPJENVlRONMEiNT "TEMP" 
#daf ina CAPSJ:NVIR0NMENT "CAPS" 
tdafina DEFAULT-TEMP "/tmp" 
#dafina KWL.PREFIX "tmpkl" 

#dalina ERROR-PREFIX "tmperror" 
#dafina KWQ-PREFIX "tmpcl" 

#dafina SB-PROGRAM "sb" 


key word-sekc ter: :kev word-selecter( const char *nanie):keyword-selecter xore(name) 

{ 

} 

void keyword-selecter : 

okay() 

{ 

int comntand.status; 

// check buttonstate for a 0 value 

World *w = GetWorld(); 

// check to ensure that at least I keyword was selected 
if (selected-browser—Count() >0) 

{ 


ostrslream comiiiand.buffer; 
ostrstreain remove-buffer: 

char ♦caps-dir = getenv(CAPS-ENV'IRONMENT); 
char ♦temp.dir = getenv(TEMP-ENVIRONMENT); 
if (temp-dir == NULL) 

{ 

temp-dir = new cliar[strlen(DEFAULT-TEMP) 4- 1]; 
St rcpy( temp.dir, DEFAULT .TEMP); 

}; 


char *list-file = tempnamftemp.dir. KWLF’REFIX): 
ofstream out put (list-file); 
if (output) 






// opened the kwl file fine 

iiit i: 

for (i = 0; i < selected-browser—Count(); i++) 

{ 


// output each kw selected to the file 
output 4 ; selected-browser—String(i) 4 ; "\n"; 

}. 

output.close(); 
w — Reniove( t his); 


char ♦result.file = teinpnam(temp-dir, KWQ-PREFIX); 
char ♦error-file = tempnam(temp-dir, ERROR-PREFIX); 
command-buffer 4C SB-PROGRAM 4C " Icwq ada " 4C list-file 4C " " 
command-buffer 4C result-file 4 ; " > " C error-file 4C ends; 

remove-buffer 4 ; "rm 

remove-buffer 4^ list-file 4^ " " 4 ; error.file; 
remove.buffer 4C ends; 

char ♦rnt-conimatid = remove-buffer.str(); 

char ♦command = command.buffer.str(); 


command-status=system(command); 
component-selecter ♦component-selecter-by-keyword; 
if (command-status 5 ^ 0 ) 

{ 

cerr < "AH ERROR OCCURED WITH COMMAHD " 4 ; command < "\n"; 

} 

else 

{ 

//no error occured so create the component selecter 

component-seleclerJby-keyword = new 
component-selecterf "component-selecter-byJteyword"); 

// pass the result stream to selecter to process 

component-selecter-by -keyword- 
insert-components( result-file); 

}: 


dOfi 


// remove temp files 
systemfrni-command); 
delete command; 



delete rm.command; 


w—‘Insert Application(component^electerJbyJcey word); 
delete this; 

} 

else 

{ 

cerr < "UHABLE TO OPEN THE kwl FILE\ll"; 
w—‘ Reinove( this); 

}: 

} 

else 

{ 

w—RingBell(lOO); 

// reset the button state 


}; 


void keyword^electer;; 

cancelO 

{ 

World ♦w = GetWorldO; 
w —♦ Remove( this); 
delete this; 


void keyword^electer;: 

newjselectionO 


{ 


int state.value; 

the-choice_BS—‘Get Value(state .value); 
if (state-value ^ 0) 

{ 

// get the new selection and check it against the 

II selected list if it is not there than add tt 

int selectedJndex — choice-browser—‘Selection(O); 

char ♦new.selection = cIioiceJ)rowser—‘String(selected index) 

if (selectedJbrowser—‘lndex(new.selection) < 0) 

{ 

// not m the selected browser so append it 
selected Jbrowser—Appendlnew .selection); 
the-choice-BS—*SetValue(0); 

}; 

}; 


void key word jselecter:: 

reniove.selection() 


307 




int state.value; 

the jselected iS—*GetValue(state .value); 
if (state.value ^ 0) 

{ 

// remove the selected entry from the browser 
int selected Jndex = selected Jbrowser—>Selection(0); 
selected J)rowser—>Remove(selected index); 
the.selected.BS—♦Set Value(O); 

}; 


} 


void keyword.selecter:: 

Insert Jceywords() 


{ 


int command.status; 
ostrstreain command.buffer; 
ostrstream remove.buffer; 


char ♦caps.dir = getenv(CAPSJ^NVIRONMENT); 
char *temp.dir = getenv(TEMPJENVIRONMENT); 
if (temp.dir == NULL) 

{ 

temp.dir = new char[strlen(DEFAULT.TEMP) + 1]; 
strcpy( temp.dir, DEFAULT .TEMP); 

}; 


command.buffer SB.PROGRAM <C " kwl ada 
char ♦list.file = tempnam(temp.dir, KWL.PREFIX); 
char ♦errorJile = tempnam(temp.dir, ERROR-PREFIX); 
command.buffer <C list.file < " > " <C error-file C ends; 

remove-buffer < "nn "; 

remove-buffer < list Jile < " " < errorJile <C ends; 

char +rm.command = removeibuffer.strO; 

char ♦command = command.buffer.str(); 
command.status=system(command); 
if (commandj5tatus==0) 

{ 

//no error occured so read in the kwl 
ifstream kwf(listJile); 
if (kwf) 

{ 

char ♦next Jreyword = new char[256]; 

// file opened fine 
while (!kwf.eof()) 

{ 

kwf.getline(nextJieyword.256); 
kwf > ws; 


308 








choice-browser—►Append(nextJcey word); 

}; 

} 

else 

{ 

cerr < "UHABLE TO OPEH OUTPUT FILE FOR COMMAND " 
cerr command <C 

}; 

} 

else 

{ 


// display error info 

cerr < "AN ERROR OCCURED WITH COMMAND " < command < "\ii 


// remove temp files 
system( rm.command); 
delete command; 
delete rm.command; 






#include <InterVie«s/button.h> 
iinclttde <InterVieH8/box.h> 
tincluda <InterVieBs/message.h> 
#include <Int«rVieBs/meiiu.h> 

#include <InterView8/texteditor.h> 
tinclude <InterVieH8/textbulfer.b> 
finclude <ZnterVieH8/world.h> 
#include ”p8dl-vie8er .h” 

#include ”8pec-vieHer .h” 

#include ” 8ave_brow8er-dialog. h" 
#include ’’delete-earning.h” 

#include <string.h> 

#include <InterVieH8/2 .6/-enter. h> 
#include <strstreaffl.h> 

#include <8treain.h> 

#include <stdlib.h> 


#deline TEMP.ENVIRONMENT "TEMP" 
#define CAPS-ENVIRONMENT "CAPS" 
#deline DEFAULT-TEMP "/tmp" 
#deline PSDL.PREFIX "tmpvp" 

#deline SPEC-PREFIX "tmpvs" 
fdeline BODY-PREFIX "tmpvb" 
#deline ERROR-PREFIX "tmperror" 
#def ine SBJPROGRAM "sb" 


psdl-viewer;:psdl-viewer(const char* name) : psdl-viewer-core(name) 

{ 

component-name=(cliar *)name; 
ostrstream viewjiame.buffer; 

view-name-buffer name <C "PSDL Specification" ends; 
theJilejiame—Remove(defaul t-message); 
delete default-message; 

Message* theJile-message=new Message("f ileJiame", 

view-name.buffer.str(), 

Center); 

the.filejiame—Insert( the-file-message); 
the-file.name—*Change(); 

// gei'ihe files from the softbase and open the psdl file 

int commandjstatus; 
ostrstream command-buffer; 
ostrstream remove-buffer; 

char *caps-dir = getenv(CAPS-ENVIRONMENT); 
char *temp-dir = getenv(TEMP-ENVIRONMENT); 
if (temp.dir == NULL) 

{ 

temp-dir = new char[strlen(DEFArLT-TEMP) + 1]; 


;no 




strcpy(temp-dir, DEFAULT.TEMP); 


}: 


command-buffer SB.PROGRAM •C " cv ada " name; 

psdlJile = tempnam(temp-dir, PSDL.PREFIX); 
specJile = tempnam(temp-dir, SPEC-PREFIX); 
body-file = tempnam(temp-dir, SPEC-PREFIX); 

char ♦error-file = tempnam(temp-dir, ERROR-PREFIX); 

command-buffer C " " <C psdl-file -C " " ■C spec.file; 
command-buffer < body-file; 

command-buffer ^ " > " <C error-file •C ends; 
remove-buffer "rm " •C error-file ends; 


char ♦command = command-buffer.str(); 
commandj5tatus=system(command); 
if (command.status==0) 

{ 

// no error occured so read in the psdLfile 
ifstream psdl(psdl-file); 
if (psdl) 

{ 

ostrstream construct-buffer; 
wrhile(!psdl.eof()) 

{ 

char text=psdl.get(); 
ifftext^EOF) 

{ 

construct_buffer.put(text); 

}; 

}; 

the.string=construct J5uffer.str(); 
int theJength=strlen(the3tring); 

the-buffer=new TextBuffer(the jtring,theJength,theJength); 
tliejeditor—Edit(the-buffer); 

} 

else 

{ 

cerr < "UIABLE TO OPEH PSDL FILE FOR COMMAHD "; 

cerr <C command <C "\n"; 

}; 

} 

else 

{ 


// display error info 

cerr < "AH ERROR OCCURED WITH COMMAHD " < command < "\n" 


311 






// remove temp files 

char *remove.commancl=remove.bufFer.str(); 
system( remove.command); 
delete remove.command; 
delete command; 


} 

void psdLviewer::^aveas() 

{ 

ostrstream defjiame-bufFer; 

def-name.bufFer component-name ^ ''.psdl'' <C ends; 
char *def.name=def.name.buffer.str(); 

save-browser-dialog ♦save-browser=new save-browser-dialog(def-name); 

World ♦w=GetWorld(); 

w—►InsertTransient(save-browser,this); 

boolean savejlag=save.browser—►Accept(); 

if(save.flag) 

{ 

ofstream outputJile(save.browser—►filejiame{)); 
output-file < the-string; 
output.file.close(); 

}; 

w—» Remove! save.browser); 
delete save.browser; 


} 

void psdl-viewer::-Print() { 

/* unimplemented */ 

} 

void psdl.viewer.'.'-DeleteO 

{ 

World* w=GetWorld(); 

delete.warning ♦warning=new delete.warningC'the.waniing"); 
w—»InsertTransient( warning, this); 
if( warning—Accept!)) 

{ 


// create hst of components 
int command-status; 



ostrstream command-buffer; 
ostrstream remove-buffer; 


char *caps-dir = getenv(CAPS-ENVIRONMENT); 
char *temp-dir = getenv(TEMP-ENVIRONMENT); 
if (temp-dir == NULL) 

{ 

temp-dir = new char[strlen(DEFAULT-TEMP) + 1]; 
strcpy(temp-dir, DEFAULT-TEMP); 

}: 


command-buffer <C SB-PROGRAM '* cd ada 
command-buffer component-name ■C " 
char ferror-file = tempnam(temp-dir, ERROR-PREFIX); 
command-buffer < " > " < error-file -C ends; 

remove-buffer "rm 
remove-buffer <C error-file ends; 

char ♦rm-command = remove-buffer.strf); 

char +command = command-buffer.str(); 

// put dialog here to ensure this is what you want 

command-status=system( command); 
if (command-status^O) 

{ 


// display error info 

cerr < "illl ERROR OCCURED WITH COMMAHD " < command < "\n" 


// remove temp files 
system( rm-command); 
delete command; 
delete rm-command; 


}; 

w—►Remove( warning); 
delete warning; 

} 

void psdl-viewer::.QuitView() 

{ 

World ♦w=GetWorld(); 
w —► Remove( t his); 
ostrstream remove-buffer; 

remove-buffer < "rm " psdl.file <C " " < spec-file; 
remove.buffer •C " " body-file ■<C ends; 


313 



char ♦remove=remove_buffer.str(); 
system(remove); 


delete thejstring; 
delete the.buffer; 

I/delete this; 

} 

void psdLviewer::.Find() { 

/* unimplemented */ 

} 

void psdLviewer::viewjspec-action() 

{ 

World *w=GetWorld(); 

spec-viewer ♦new.view=iiew spec.viewer(coniponent .name, 

spec Jile, 
bodyJile); 

w—►Insert Application(new.view); 

} 

void psdl-viewer::Handle (Events e) 

{ 

}; 


314 





#include <InterVi6«s/button.h> 
#includ« <InterVie«s/streditor.h> 
tinclude <InterVie«8/filebrovser.h> 
#include <InterVieHs/world.h> 
#include ’’query.file.dialog.h” 
tinclude <InterViev8/2.6/_enter. h> 
tinclude <strean.h> 
tinclude <8tring.h> 
tinclude <8y8/parain.h> 
tinclude <8tdlib.h> 
tinclude <strstrean.h> 
extern "C" 

{ 

extern char +getwd(char *); 


}; 

query_file_dialog::query.file.<lialog(const char* name) ; queryJile-dialog-core(name) 

{ 

char pathname(MAXPATHLEN]; 
getwd(pathname); 

theJileJbrowser—*SetDirectory(pathname); 

directory .name—>Message( the Jile-browser—^GetDirectoryO); 

} 

void query Jile.dialog;;file.naiTie.action() 

{ 

World *w=GetWorld(); 

// ensure file does not already exist 
int state-value; 

the.file-name.BS—►GetValue(state-value); 
if(state-value^O) 

{ . 

int theJndex=theJileJ)rowser—“Index(the Jile-name—*Text()); 
if(theJndex > 0) 

{ 

w—►RingBell(lOO); 

} 

else' 

{ 

// update the save browser button to 1 to indicate 
II success 

theJile-browser—‘Select(the jndex): 
dialog-BS—>SetValue( 1); 


}; 


315 


J 




theJile_name.BS—►SetValue(O); 


}: 


} 

void queryJfile-dialog::directory.action() 

{ 

World ♦w=GetWorld(); 
int state.value; 

directory Jiame.BS—‘Get Value(state_value); 
if(state-value 5 ^ 0 ) 

{ 

// the user has entered a directory name of his own 
const char 

*temp_directory=theJileJ)rowser—Normali 2 e(directoryjiame—‘Text()); 

char ♦new.directory=new char[strlen(temp.directory)+l]; 
strcpy( new ^directory,temp-directory); 
if(the.file.brovvser—IsADirectory(new-directory)) 

{ 

directory-name—‘Message(new-directory); 
t he Ji le -b ro wser—»Set Direc tory (ne w directory); 

} 

else 

{ 

w—RingBell(lOO); 

}; 

delete new.direc tory; 
directory jiameJBS—‘Set Value(O); 

}; 

} 

void queryJile-dialog::file.browser-action() 

{ 

int state.value; 

file.browser.BS—‘Get Valued state .value); 
ifdstate.value^O) 

int index=theJileJbrowser—‘Selection(O); 

if(theJile.browser—*lsADirectory(theJiieJ>rowser—‘Path(index))) 

{ 

directory Jiame—‘Messaged the JileJt)rowser—*Path(index)); 
theJileJ)rowser—SetDirectory(directory Jiame—‘Text()); 

} 

else 

{ 

theJilejiame—Messaged the JileJ)rowser—*String(index)); 
dialog-BS—SetValuedl); 

}; 


316 







file.browser^S—"Set Value( 0); 


}: 

} 

void query-file.dialog::canceLaction() 

{ 

int state.value; 

canceUS—►GetValue(state_value); 
if(state.value^O) 

{ 

// a value other than 1 indicates false 
dialog.BS—»SetValue(2); 
cancel.BS—Set Value(O); 

}: 

}; 


void query JHe.dialog: :okay.action() 

{ 

World ♦w=GetWorld(); 
int state.value; 

okay .BS—"Get Value(state.value); 
if(state.value^O) 

{ 


int theJndex=theJileJ3rowser—"Index(theiile Jiame—"Text()); 
if(theindex < 0) 

{ 

// file already does not exists 
w—RingBell( 100); 

} 

else 

{ 

// update the save browser button to 1 to indicate 
II success 

dialog-BS—SetValue(l); 

}; 

okay .BS—Set Value(O); 


}; 

} 

const char ♦query-file-dialog::file.name() 

{ 

ostrstream fullJilejiame; 

fullJilejiame the.file.browser—*GetDirectory{); 

fullJilejiame C the.file.name—Text(); 

return fulLfile.name.slr(); 


317 








tinclad* <Int«rVi6vs/button.h> 
tfincludo <InterViews/streditor.h> 
#include <InterViaws/filebrovser.h> 
#includ6 <InterVieB8/vorld.h> 
#include ”save-browser.dialog. h” 
#include <IntorViows/2. BAenter. h> 
#include <stream.h> 
tinclwde <string.h> 

#include <sys/paran.h> 
tinclude <stdlib.h> 
tinclude <str3trean.h> 
extern "C" 

{ 

extern char ♦getwd(char ♦); 

}; 


save-browser-dialog::save.browser-dialog{const char4> name) : save.browserjdialog_core(name) 

{ 

default-name=(char ♦)name; 
char pathname[MAXPATHLEN]; 
getwd( pathname); 

the.fileJ3rowser—SetDirectory(pathname); 

the-directory Jiame—>Message(theJileJt>rowser—►GetDirectoryO); 

the-filejiame—Message( default jiame); 


} 

void save-browser-dialog. :file-browser-action() 

{ 

int state-value; 

file-browser JBS—‘Get Value( state-value); 
iflstate.value^iO) 

{ 

int index=the.fileJbrowser—*Selection(0); 

if( the Jile-browser—*Is ADirectory (the-file-browser—►Path(index))) 

{ 

the-directory-name—Message( the-file-browser—‘Path(index)); 
the-file-browser—SetDirectory(thejjirectory Jiame—‘Text()); 

}; 

file-browser-BS—‘SetValue(O); 

}; 

} 

void save-browser-dialog: :update_file_name() 

{ 

World *w=GetWorld)); 

// ensure file does nol already eitst 


319 






int state.value; 

file_name_BS—•GetValue(state-value); 
if(state-value 5 ^ 0 ) 

{ 

int theJndex=theJile-browser—>Index(theiile jiame—►TextO); 
if(theJndex > 0) 

{ 

// file already exists so do not accept it 
w—RingBell( 100): 

} 

else * 

{ 

% 

// update the save browser button to 1 to indicate 
II success 

dialog.BS—SetValue( 1); 

}; 

file.name.BS—SetValue(O): 

}; 

} 

void save.browser-dialog::update.directory() 

{ 

World ♦w=GetWorldO; 
int state.value; 

iiew.directoryJS—'Get Value(state.value); 
if(state.value^O) 

{ 

// the user has entered a directory name of his own 
const char 

♦temp.directory=theJileJbrowser—'Normalize! the.directoryjiame—'TextO); 

char *new.directory=new char[strlen(temp.directory)+l]; 
strcpy( new jdirectory, temp.directory); 
if(theJile.browser—IsADirectory(newjdirectory)) 

{ 

the.directoryjiame—'Message! new jdirectory); 
theJile.browser—Set Directory! new jdirectory); 

} 

■ else • 

{ 

w—RingBell! 100); a 

}; 

delete new.directory; 

new .directory J3S—SetValue!0); 

} 


void save.browser.dialog::cancel-action!) 

{ 


;i20 





f 


» 


int state-value; 

cancel_BS—►GetValue(state_value); 
ifi(state-value540) 

{ 

//a value other than 1 indicates false 
dialog.BS—♦SetValue(2); 
cancel_BS—‘SetValue(O); 

}; 


void save-browser-(lialog::ok-action() 

{ 

World ♦w=GetWorld(); 
int state-value; 

ok_BS—►GetValue(state-value); 
if(state-value^O) 

{ 


int theJndex=the-file-browser—*Index(the Jile jiame—‘■TextO); 
if(the.index > 0) 

{ 

// file already exists so do not accept it 
w—RingBell(lOO); 

} 

else 

{ 

// update the save browser button to 1 to indicate 
II success 

dialog-BS—Set Value( 1); 

}; 

ok-BS—>SetValue(0); 


}: 

} 

const char *save.browser-dialog::file-name() 

{ 

ostrstream full-file.name; 

full-file_name <C the_file.browser—GetDirectory(); 
full-file-name the-file.name—►TextO; 

return fulLfile.name.str(); 

}; 


321 




tinclude <InterVie«s/painter.h> 
#iiiclude <IiiterVieHs/shape.h> 
tinclude <InterVieBs/sensor.h> 
tinclude <InterVieH8/Horld.h> 
tinclude ’’SBjnain-menu.h” 
tinclude <InterVieHs/2.6/-enter. h> 

static PropertyData propertiesQ = { 
tinclude ’’soltbase-props” 

{ ■•♦title","CAPS SOFTBASE"}, 
{nil} 

}; 


static OptionDesc options^ = { 

{ nil } 

}: 

int main (iiit argc, cliar%« argv) { 

World* w = new World("+***", argc, argv, options, properties); 
SBjnain.menu* thejnain.menu = new SB-main-menu("tha^main.menu"); 
w—►Insert Application( the jnain.menu); 

w—►Run(); 
delete w; 
return 0; 



tinclude <InterVies8/button.h> 
#includ« <Int«rVieva/box.h> 
#iiiclude <InterVieBs/message.h> 
#include <lnterVie«8/menu.h> 
#include <InterViea8/texteditor.h> 
♦include <InterView8/textbuffer.h> 
♦include <InterVieH8/world.h> 
♦include ” apec.vieser. h” 

♦include ’’padl.viewer .h” 

♦include "body-viewer .h” 

♦include ” aave.browaer.dialog. h” 
♦include <InterVieHs/2.6/-enter.h> 
♦include <8trstrean.h> 

♦include <stream.h> 

♦include <stdlib.h> 

♦include <string.h> 


spec.viewer::spec.viewer(const char* name, char ♦specJile, char ♦body.file.in) : 
spec -viewer -Core( name) 


{ 


component_name=(char *)name; 
boclyJile=body-fileJn; 
ostrstream viewjiame.buffer; 

viewjiame.buffer ^ component-name “Implementation Specification" ^ ends; 
t he Ji le jiame—♦ Remove( default-message); 
delete default-message; 


Message* the-fiie-message=new Message(“f ile-name", 

view-name-buffer.str(), 

Center); 

t he -fi le Ji ame—»Insert(the-file jnessage); 
the.filejiame—Change!); 


ifstream spec(spec-file); 
if (spec) 

{ 

ostrstream construct-buffer; 
while(!spec.eof()) 

{ 

char text=spec.get(); 
ifftextytEOF) 

{ 

construct-bufFer.put(text); 

}; 

}; 

the jtring=construct J>ufrer.str(); 
int theJength=strlen(the^tring); 

the-buffer=new TextBuffrrfthejstring.theJength.theJength); 
thejsditor—*Edit(theJbuffer); 

} 

else 


323 




{ 

cerr < "UMABLE TO OPEH SPEC FILE TO VIEW FILENAME IS " 

cerr spec .file <C ''\n": 

}; 


} 

void spec.viewer;:^aveas() 

{ 

ostrstream defjiame.bufFer; 

defjiame.buffer componentjiame <C “.spec.a" <C ends; 

char ♦defjiame=defjiame_bufrer.str(); 

save.browser.dialog ♦save-browser=new save_browser-dialog(def-name); 

World ♦w=GetWorld(); 

w—►InsertTransient(save.browser,this); 

boolean save_flag=save-browser—>■ Accept(); 

if(save_flag) 

{ 

ofstream output Jile(save-browser—►fileJiame()); 

output-file the.string; 

output-file.closeO; 

}; 


w—• Remove(save.browser); 
delete save.browser; 


} 

void spec .viewer:; _Print() { 

/♦ ummplemented */ 

} 

void spec.viewer;:.QuitView() 

{ 

// remove temporary file and remove application from world 
World ♦w=GetWorld(); 
w—► Remove( this); 
jjdelete this; 

} 

void spec.viewer::.Find() { 

/♦ unimplemented */ 

} 

void spec-viewer;;view_bodv.action() 

{ 


World ♦w=GetWorld(): 

body.viewer ♦new-view=new body_viewer(component_name, 


324 





w—►Insert Application( new_view); 


body-file); 


} 







BIBLIOGRAPHY 


1. Bayramoglu, S., The ‘Design and fmpUmentation of an ‘Ejcpanderfor !}^racftiad 
!}(fai-‘Iime Constraints (f Computer Aided (Prototyping System, M.S. Thesis, Naval 
Postgraduate School, Monterey, CA, September, 1991. 

2. Biggerstaff, T. J. and Perils, A. J., Software (^usaSdity ‘UoCume I Concepts andOdodeCs, 
ACM Press, New York, NY, 1989. 

3. Biggerstaff, T. J. and Perils, A. J., Software (R^usabdity ‘UoCume 11 Applications and 
‘EjqperUnce, ACM Press, New York, NY, 1989. 

4. Booch, G., Object Oriented Design ‘H^tb. Applications, The Benjamin/Cummings 
Publishing Company, Inc., 1991. 

5. Dwyer, A. P. and Lewis, G. W., ‘Ifie Development of a Design Database for the 
Compuur Aided (Prototyping System, M.S. Thesis, Naval Postgraduate School, 
Monterey, CA, September 1991. 

6. Elmasri, R. and Navathe, S., fundamentals of Database Systems, The 
Benjamin/Cummings Publishing Company, Inc., 1989. 

7. Gough, K. J., SyntwcAnalysis andSoftware fools, Addison-Wesley Publishing 
Company, 1988. 

8. Levine, J., An efficient (HeuTistic Scheduler for (Hard (Rfol-'Iime Systems, M.S. Thesis, 
Naval Postgraduate School, Monterey, CA, September, 1991. 


326 






INITIAL DISTRIBUTION LIST 


1. Defense Technical Information Center 2 

Cameron Station 

Alexandria, VA 22304-6145 

2. Dudley Knox Library 2 

Code 52 

Naval Postgraduate School 
Monterey, CA 93943 

3. Computer Science Department 2 

Code CS 

Naval Postgraduate School 
Monterey, CA 93943 

4. Office of the Assistant Secretary of the Navy 1 

Research Development and Acquisition 

Department of the Navy 
Attn: Mr. Gerald A. Cann 
Washington, DC 20380-1000 

5. Office of the Chief of Naval Operations 1 

OP-094 

E>epartment of the Navy 
Attn: VADM J. O. Tuttle, USN 
Washington, DC 20301-3040 

6. Director of Defense Information 1 

Office of the Assistant Secretary of Defense 

(Command, Control, Communications, & Intelligence) 

Attn: Mr. Paul Strassmann 
Washington, DC 20301-0208 

7. Center for Naval Analysis 1 

4401 Ford Avenue 

Alexandria, VA 22302-0268 


327 




8. E)irector of Research Administration 
Attn: Prof. Howard 

Code 08Hk 

Naval Postgraduate School 
Monterey, CA 93943 

9. Chairman, Code CS 
Computer Science Department 
Naval Postgraduate School 
Monterey, CA 93943-5100 

10. Prof. Luqi, Code CSLq 
Computer Science Department 
Naval Postgraduate School 
Monterey, CA 93943 

11. Chief of Naval Research 
800 N. Quincy Street 
Arlington, VA 22217 

12. Director, Ada Joint Program Office 
OUSDRE (R&AT) 

Room 3E114, The Pentagon 
Attn: Dr. John P. Solomond 
Washington, DC 20301-0208 

13. Carnegie Mellon University 
Software Engineering Institute 
Atm: Dr. Dan Berry 
Pittsburgh, PA 15260 

14. Office of Naval Technology (ONT) 

Code 227 

Atm: Dr. Elizabeth Wald 
800 N. Quincy St. 

Arlington, VA 22217-5000 

15. Defense Advanced Research Projects Agency (DARPA) 
Integrated Strategic Technology Office (ISTO) 

Atm: Dr. B. Boehm 
1400 Wilson Boulevard 
Arlington, VA 22209-2308 






16. Defense Advanced Research Projects Agency (DARPA) 
ISTO 

1400 Wilson Boulevard 
Attn; LCol Eric Mattala 
Arlington, VA 2209-2308 

17. Defense Advanced Research Projects Agency (DARPA) 

^ Director, Tactical Technology Office 

1400 Wilson Boulevard 

* Arlington, VA 2209-2308 

18. Attn: Dr. Charles Harland 
Computer Science 
Department of the Air Force 

Bolling Air Force Base, DC 20332-6448 

19. Chief of Naval Operations 

Attn: Dr. R. M. Carroll (OP-01B2) 

Washington, DC 20350 

20. Dr. Amiram Yehudai 
Tel Aviv University 

School of Mathematical Sciences 
Department of Computer Science 
Tel Aviv, Israel 69978 

21. E)r. Robert M. Balzer 
USC-Information Sciences Institute 
4676 Admiralty Way 

Suite 1001 

Marina del Ray, CA 90292-6695 

22. Dr. Ted Lewis 

OR State University 

• Computer Science Department 
Corvallis, OR 97331 

23. International Software Systems Inc. 

12710 Research Boulevard, Suite 301 
Atm: Dr. R. T. Yeh 

Austin, TX 78759 


329 



24. Kestrel Institute 
Attn: Dr. C. Green 
1801 Page MiU Road 
Palo Alto. CA 94304 

25. National Science Foundation 

Division of Computer and Computation Research 
Attn: K. C. Tai 
Washington, DC 20550 

26. Commander Space and Naval Warfare Systems Command 
SPA WAR 3212 

Department of the Navy 
Attn: Cdr M. Romeo 
Washington, DC 20363-5100 

27. Naval Ocean Systems Center 
Attn: Linwood Sutton, Code 423 
San Diego, CA 92152-5000 

28. Office of Naval Resjarch 
Computer Science Division, Code 1133 
Atm: Dr. Gary Koob 

800 N. Quincy Street 
Arlington. VA 22217-5000 

29. Commander, Naval Sea Systems Command (PMS-4123H) 
Attn: William Wilder 

Washington, DC 20380-1000 

30. New Jersey Institute of Technology 
Computer Science Department 
Atm: Dr. Peter Ng 

Newark, NJ 07102 

31. Office of Naval Research 
Computer Science Division, Code 1133 
Atm: Dr, A. M. Van Tilborg 

800 N. Quincy Street 
Arlington, VA 22217-5000 



32. Office of Naval Research 
Computer Science Division, Code 1133 
Attn: Dr. R. Wachter 

800 N. Quincy Street 
Arlington, VA 22217-5000 

33. OR Graduate Center 
Portland (Beaverton) 

Attn: Dr. R. Kieburtz 
Portland, OR 97005 

34. Santa Clara University 

Department of Electrical Engineering and 
Computer Science 
Attn: Dr. M. Ketabchi 
Santa Clara, CA 95053 

35. Software Group, MCC 
9430 Research Boulevard 
Attn: Dr. L. Belady 
Austin, TX 78759 

36. University of CA at Berkeley 
Department of Electrical Engineering and 
Computer Science 

Computer Science Division 
Attn: Dr. C.V. Ramamoonhy 
Berkeley, CA 90024 

37. University of CA at Irvine 

Department of Computer and Information Science 
Attn: Dr. Nancy Leveson 
Irvine, CA 92717 

38. Chief of Naval Operations 
Attn: Dr. Earl Chavis (OP-ltiT) 

Washington, DC 20350 

39. Office of the Cliief of Naval Operations 
Attn: Dr. John Davis (OP-094H) 

Washington, DC 20350-2000 


331 






40. University of Illinois 
E)epartment of Computer Science 
Atm: Dr, Jane W. S. Liu 
Urbana Champaign, IL 61801 

41. University of MD 

College of Business Management 
Tydings Hall, Room 0137 
Atm: Dr. Alan Hevner 
College Park, MD 20742 

42. University of MD 
Computer Science Department 
Atm: Dr. N. Roussapoulos 
College Park, MD 20742 

43. University of Massachusetts 

E)epartment of Computer and Information Science 
Atm: Dr. John A. Stankovic 
Amherst, MA 01003 

44. University of Pittsburgh 
Department of Computer Science 
Attn: Dr, Alfs Berztiss 
Pittsburgh, PA 15260 

45. University of TX at Austin 
Computer Science Department 
Atm: Dr. A1 Mok 

Austin, TX 78712 

46. Commander, Naval Surface Warfare Center, 

Code U-33 

Atm: Dr. Philip Hwang 
10901 New Hampshire Avenue 
Silver Spring, MD 20903-5000 

47. Atm: George Sumiall 
US Army Headquarters 
CECOM 

AMSEL-RD-SE-AST-SE 
Fort Monmouth, NJ 07703-5000 





48. Attn: Joel Trimble 

1211 South Fem Street, C107 
Arlington, VA 22202 


1 


49. United States Laboratory Command 1 

Army Research Office 

Attn; Dr. David Hislop 
P.O.Box 12211 

Research Triangle Park, NC 27709-2211 

50. George Mason University 1 

Computer Science Department 

Attn: Dr. David Rine 
Fairfax, VA 22030-4444 

51. Hewlett Packard Research Laboratory 1 
Mail Stop 321 

1501 Page Mill Road 
Attn: Dr. Martin Griss 
Palo Alto, CA 94304 

52. Carnegie Mellon University 1 

SEI 

Attn: Dr. Mario Barbacci 
Pittsburgh, PA 15213 

53. Persistent Data Systems 1 

75 W. Chapel Ridge Road 

Attn; Dr. John Nester 
Pittsburgh, PA 15238 

54. Sun Microsystems Inc. 1 

MS MTVlOO-01 

Silicon Valley Government District 
1842 N. Shoreline Boulevard 
Atm: Vice President c/o Don Chandler 
Mountain View, CA 94043 

55. Commandant of the Marine Corps 1 

Ada Joint Program Representative 

Code CCI 

Atm: Capt Gerald Depasquale 
Washington, DC 20301 


333 





56. Ontologic, Inc. 

Three Burlington Woods 
Attn: Mr. Gregory Harris 
Burlington, MA 01803 








