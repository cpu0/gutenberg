1 . AGENCY USE 


(Leave 


Form Approved 
OPMNo 


tntQm 1 hour p«r rMpo^MD. tnciudtng th4> um« lor r•v^h•n ^9 inatnxiion*. Miv ;r»r )9 a«ia 

wy SmnO oommoritt roQ«/tiir >9 thm burclon Mttmsi* or *ny oihor ASpoci o< * coitAO-or o* ^otormaj.Of';. ncf«Oif>g 
m. OirodoraiA ior informoiion Oporatong and Raports. 15 JArt#r»on OavJg Hign«ar Sufl# ' ?0<, Arsirtgior. VA 
• of ManagAmant and Budgat. Waahingtor). DC 20S03 

DRT 3, REPORT TYPE AND DATES 

Final;08 May 91 


4. TITLE AND 

Validation Summary Report; Alsys Limited, AlsyCOMP-073, Version 5.3, 
IBM ES/9000 Model 610 (under AIX/ESA Version 2)(Host & Target), 

921126N1.11300 


National Computing Centre Limited 
Manchester, UNITED KINGDOM 


7. PERFORMING ORGANIZATION NAME(S) AND 

National Computing Centre Limited 
Oxford Road 
Manchester Ml 7ED 
UNITED KINGDOM 


9, SPONSORING'MONITORING AGENCY NAME(S) AND 

Ada Joint Program Office 

United States Department of Defense 

Washington, D.C. 20301-3081 


DTIC 


MAR 3 01993 




8 PERFORMING 
ORGANIZATION 

A VF-VSR-90502/85-930121 


10. SPONSORINGMONITORING 
AGENCY 



12a. DISTRIBUTION/AVAILABILITV 


Approved for public release; distribution unlimited. 


13. (Maximum 200 

Alsys Limited, AlsyCOMP_073 Version 5.3, IBM ES/9000 Model 610 (under AIX/ESA Version 2)(Host & 
Target), AC VC 1.11 



93 


3 29 003 


93-06374 




14. SUBJECT 


15. NUMBER OF 


Ada programming language, Ada Compiler Val. Summary Report, Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility. ANSI/MIL-STD-1815A, I 


17. SECURITY 
CLASSIFICATION 

UNCLASSIFIED 


18. SECURITY 

UNCLASSIFED 


19. SECURITY 
CLASSIFICATION 

UNCLASSIFIED 


20. LIMITATION OF 


NSN 


Standard Form 298. (Rev 2 89) 
Prescribed by ANSI Sid 














AVF Control Number: AVF_VSR_90502/'85-930121 


Ada COMPILER 

VALIDATION SUMMARY REPORT: 
Certificate Number; #921126N1.11300 
Alsys Limited 

AlsyCOMP 073 Version 5.3 
IBM ES/9000 Model 610 (under AIX^'ESA Version 2) 


Prepared By: 

Testing Services 

The National Computing Centre Limited 
Oxford Road 
Manchester 
Ml 7ED 
England 


Template Version 91-05-08 


Acceslon For 

- f - 

/ 

NTIS CRA&I 
DTIC TAB 
U'id.'inoU'iCed 
JuStlticat'i'.n 

□ 

o 

□ 




By 

Dislnbution 1 

Avdiiability Codes 

O'st 

Avrjil and/Of 

Sptcial 

f\A 




Validation Suanry Report 
Alsys Liaited 



AVF_VSR_90502/85 
AlsyCOMP_073 Version 5.3 


TESTING 









Certificate Information 


The following Ada implementation was tested and determined to pass ACVC 1.11. Testing was 
completed on 26 November 1992. 

Compiler Name and Version: AlsyCOMP_073 Version 5.3 

Host Computer System: IBM ES/9000 Model 610 (under AIX/ESA Version 2) 

Target Computer System: EBM ES/9000 Model 610 (under AIX/ESA Version 2) 

See section 3.1 for any additional information about the testing environment. 

As a result of this validation effort, Validation Certificate #921126N 1.11300 is awarded to Alsys 
Limited. This certificate expires 2 years after ANSI/MIL-STD-1815B is approved by ANSI. 

This report has been reviewed and is approved. 




Jon Leigh 

Manager, System Software Testing 
The National Computing Centre Limited 
Oxford Road 
Manchester 
Ml 7ED 
England 



Ada Valfdatl(^ Organization 

Directo^Comimter and Software Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 




Ada Joint Program Office 
Dr. John Solomond, Director 
Department of Defense 
Washington DC 20301 


Validation Suawry Report 
Altya Liaited 


*VF_VSR_90502/85 
AtayCnir_073 Version 5.3 




DECLARATION OF CONFORNUNCE 


DECLARATION OF CONFORMANCE 
The following declaration of conformance was supplied by the customer. 

Declaration of Conformance 
Customer: Alsys Limited 

Ada Validation Facility: The National Computing Centre Limited 

ACVC Version: 1.11 

Ada Implementation: 

Ada Compiler Name and Version: AlsyCOMP_073 Version 5.3 

Host Computer Sy'stem; IBM ES/9(X)0 Model 610 (under AlX/tSA Version 

2 ) 

Target Computer System: IBM ES/9000 Model 610 (under AIX'ESA Version 

2 ) 

Declaration: 

I, the undersigned, representing Alsys Limited, declare that AJsys Limited has no knowledge 
of deliberate deviations from the Ada Language Standard ANSI/MIL-STD-1815A, ISO 
8652-1987, FIPS 119 as tested in this validation and documented in the Validation Summary 
Report. 


Jon Frosdick Date 

Director of Engineering 
Alsys Limited 





Validation SuMary Seport 
Alay« Liatited 


AVF_VSR_9C502/85 
AlsvC0HP_073 Version 5.3 








TABLE OF CONTENTS 


TABLE OF CONTENTS 

CFiAPTER 1 . 1 

INTRODUCTION. 1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT. 1 

1.2 REFERENCES. 1 

1.3 ACVC TEST CLASSES. 2 

1.4 DEHNITION OF TERMS . 3 

CHAPTER 2 . 1 

IMPLEMENTATION DEPENDENCIES. 1 

2.1 WITHDRAWN TESTS. 1 

2.2 INAPPLICABLE TESTS. 1 

2.3 TEST MODIFICATIONS . 4 

CHAPTER 3 . 1 

PROCESSING INFORMATION. 1 

3.1 TESTING ENVIRONMENT. 1 

3.2 SUMMARY OF TEST RESULTS. 1 

3.3 TEST EXECUTION. 2 

APPENDIX A . 1 

MACRO PARAMETERS. 1 

APPENDIX B . 1 

COMPILATION SYSTEM OPTIONS. 1 

APPENDIX C . 1 

APPENDIX F OF THE Ada STANDARD . 1 


Validation &Mary Report AVF_VSR_90502/85 

Alsy* Liaited _ Table of Contents - Page 1 of 1 *l8yCWP_073 Version 5.5 


























INTRODtCTION 


CHAPTER 1 
INTRODUCTION 


The Ada implementation described above was tested according to the Ada Validation Procedures 
{Pro92] against the Ada Standard [AdaSBJ using the current Ada Compiler Validation Capability 
(ACVC). This Validation Summary Report (VSR) gives an 'account of the testing of this Ada 
implementation. For any technical terms used in this report, the reader is referred to [Pro92]. A 
detailed description of the ACVC may be found in the current ACVC User’s Guide [UG89). 


1.1 USE OF THIS validation SUMMARY REPORT 

Consistent with the national laws of the originating country, the Ada Certification Body may make 
full and free public disclosure of this report. In the United States, this is provided in accordance with 
the "Freedom of Information Act" (5 U.S.C. #552). The results of this validation apply only to the 
computers, operating systems, and compiler versions identified in this report. 

The organizations represented on the signature page of this report do not represent or warrant that 
all statements set forth in this report are accurate and complete, or that the subject implementation 
has no nonconformities to the Ada Standard other than those presented. Copies of this report are 
available to the public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results should be directed to the AVF which 
performed this validation or to; 

Ada Validation Organization 

Computer and Software Engineering Division 

Institute for Defense Analyses 

1801 North Beauregard Street 

Alexandria VA 22311-1772 

1.2 REFERENCES 

[Ada83] Reference Manual for the Ada Programming Language . 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987, 

(Pio92] Ada Compiler Validation Procedures . 

Version 3.1, Ada Joint Program Office, August 1992. 


Validation Suaaary Report 
Atsya Liaited _ 


Chapter 1 - Page 1 of 4 


AVF_VSR_90502/85 
At8yC0»IP_073 Version 5.3 





INTRODLCTION 


[UG89] Ada Compiler Validation Capability User’s Guide . 

2i June 1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. The ACVC contains a 
collection of test programs structured into six test classes: A, B, C, D, E, and L. The first letter of a 
test name identifies the cla&. to which it belongs. Class A, C, and E tests are executable. Class B 
and class L tests are expected to produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and produce a PASSED, FAILED, or 
NOT APPLICABLE message indicating the result when they are executed. Three Ada library units, 
the packages REPORT and SPPRT13, and the procedure CHECK_FILE are used for this purpose. 
Tne package REPORT also provides a set of identity functions used to defeat some compiler 
optimizations allowed by the Ada Standard that would circumvent a test objective. The package 
SPPRT13 is used by many tests for Chapter 13 of the Ada Standard. The procedure CHECK_FILE 
is used to check the contents of text files written by some of the Class C tests for Chapter 14 of the 
Ada Standard. The operation of REPORT and CHECK_FILH is checked by a set of executable tests. 
If these units are not operating correctly, validation testing is discontinued. 

Class B tests check that a compiler detects illegal language usage. Class B tests are not executable. 
Each test in this class is compiled and the resulting compilation listing is e.xamined to verify that all 
violations of the Ada Standard are detected. Some of the class B tests contain legal Ada code which 
must not be flagged illegal by the compiler. This behaviour is also veriSed. 

Class L tests check that an Ada implementation correctly detects violation of the Ada Standard 
involving multiple, separately compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be replaced by implementation-specific 
values - for example, the largest integer. A list of the values used for this implementation is provided 
in Appendix A In addition to these anticipated test modifications, additional changes may be required 
to remove unforeseen conflicts between the tests and implementation-dependent characteristics. The 
modifications required for this implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by the AVF. This customization 
consists of making the modifications described in the preening paragraph, removing withdrawn tests 
(see section 2.1), and possibly removing some inapplicable tests (see section 2.2 and [UG89]). 

In order to pass an ACVC an Ada implementation must process each test of the customized test suite 
according to the Ada Standard. 


Validation trij—ry Report 
Alays Liaited 


Chapter 1 - Pa 9 e 2 of A 


AVf_VSR_90502/85 
AlsyC0MP_073 Version 5.3 





INTRODUCTION 


1.4 DEFINITION OF TERMS 


Ada Compiler 


Ada Compiler 
Validation Capability 
(ACVC) 

Ada Implementation 


Ada Joint Program 
Office (AJPO) 

Ada Validation Facility 
(AVF) 

Ada Validation 
Organization (AVO) 

Compliance of an Ada 
Implementation 

Computer System 


Conformity 

Customer 


Declaration of 
Conformance 

Host Computer System 


The software and any needed hardware that have to be added to a given 
host and target computer system to allow transformation of Ada 
programs into executable form and execution thereof. 

The means for testing compliance of Ada implementations, consisting of 
the test suite, the support programs, the ACVC user’s guide and the 
template for the validation summary report. 

An Ada compiler with its host computer system and its target computer 
system. 

The part of the certification body which provides policy and guidance for 
the Ada certification system. 

The part of the certification body which carries out the procedures 
required to establLsh the compliance of an Ada implementation. 

The part of the certification body that provides technical guidance for 
operations of the Ada certification system. 

The ability of the implementation to pass an ACVC version. 


A functional unit, consisting of one or more computers and associated 
software, that uses common storage for all or part of a program and also 
for all or part of the data necessary for the execution of the program; 
executes user-written or user-designated programs; performs user- 
desigitated date manipulation, including arithmetic operations and logic 
operations; and that can execute programs that modify themselves during 
execution. A computer system may be a stand-alone unit or may consist 
of several inter-connected units. 

Fulfilment of a product, process or service of all requirements specified. 

An individual or corporate entity who enters into an agreement with an 
AVF which specifies the terms and conditions for AVF services (of any 
kind) to be" performed. 

A formal statement from a customer assuring that conformity is realized 
or attainable on the Ada implementation for which validation status is 
realized. 

A computer system where Ada source programs are transformed into 
executable form. 


Validation SuMnry Report 
Alsys Liaited 


Chapter 1 - Page 3 of 4 


AVF_VSR_90502/8S 
AlsyCO(P_073 Version 5.3 





INTRODUCTION 


Inapplicable test 

ISO 

LRM 

Operating System 

Target Computer 
System 

Validated Ada Compiler 

Validated Ada 
Implementation 

Validation 

Withdrawn test 


Va tidal ion Sumiary Report 
Atays Lilli ted 


A test that contains one or more test objectives found to be irrelevant for 
the given Ada implementation. 

International Organization for Standardization. 

The Ada standard, or Language Reference Manual, published as 
ANSI/MIL-STD-1815A-1983 AND ISO 8652-1987. Citations from the 
LRM take the form ’'<section>.<subsection>:<paragraph>.’' 

Software that controls the execution of programs and that provides 
services such as resource allocation, scheduling, input/output control and 
data management. Usually, operating systems are predominantly 
software, but partial or complete hardware implementations are possible. 

A computer system where the executable form of Ada programs are 
executed. 

The compiler of a validated Ada implementation. 

An Ada implementation that has been validated successfully either by 
AVF testing or by registration [Pro92). 

The process of checking the conformity of an Ada compiler to the Ada 
programming language and of issuing a certificate for this 
implementation. 

A test found to be incorrect and not used in conformity testing. A test 
may be incorrect because it has an invalid test objective, fails to meet its 
test objective, or contains erroneous or illegal use of the Ada 
programming language. 


AVF_VSR_90502/85 

Chapter 1 - Page 4 of A AtsyCaNP_073 Version 5.3 





IMPLEMENTATION DEPENDENCIES 


CHAPTER 2 

IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

The following tests have been withdrawn by the AVO. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for this list of withdrawn tests is 2 
August 1991. 


E28005C 

B28006C 

C32203A 

C34006D 

C35508I 

C35508J 

C35508M 

C35508N 

C35702A 

C35702B 

B41308B 

C43004A 

C45114A 

C45346A 

C45612A 

C45612B 

C45612C 

C45651A 

C46022A 

B49008A 

B49008B 

A74006A 

C74308A 

B83022B 

B83022H 

B83025B 

B83025D 

C83026A 

B83026B 

C83041A 

B85001L 

C86001F 

C94021A 

C97116A 

C98003B 

BA2011A 

CB7001A 

CB7001B 

CB7004A 

CC1223A 

BC1226A 

CC1226B 

BC3009B 

BD1B02B 

BD1B06A 

AD1B08A 

BD2A02A 

CD2A21E 

CD2A23E 

CD2A32A 

CD2A41A 

CD2A41E 

CD2A87A 

CD2B15C 

BD3006A 

BD4008A 

CD4022A 

CD4022D 

CD4024B 

CD4024C 

CD4024D 

CD4031A 

CD4051D 

CD5111A 

CD7004C 

ED7005D 

CD7005E 

AD7006A 

CD7006E 

AD7201A 

AD7201E 

CD7204B 

AD7206A 

BD8002A 

BD8004C 

CD9005A 

CD9005B 

CDA201E 

CE2107I 

CE2117A 

CE2117B 

CE2119B 

CE2205B 

CE2405A 

CE3111C 

CE3116A 

CE3118A 

CE3411B 

CE3412B 

CE3607B 

CE3607C 

CE3607D 

CE3812A 

CE3814A 

CE3902B 



2.2 INAPPLICABLE TESTS 

A test is inapplicable if it contains test objectives which are irrelevant for a given Ada 
implementat'on. Reasons for a test’s inapplicability may be supported by documents issued by the ISO 
and the AJPO known as Ada Commentaries and commonly referenced in the format Al-ddddd. For 
this implementation, the following tests were determined to be inapplicable for the reasons indicated; 
references to Ada Commentaries are included as appropriate. 


The following 159 tests have floating-point type declarations requiring more digits than 
SYSTEM.MAX_DIGITS: 


C241130..Y (11 tests) 
C35706O..Y (11 tesU) 
C35708O..Y (11 tests) 
C452410..Y (11 tests) 
C454210..Y (11 tests) 


C35705O..Y (11 tests) 
C35707O..Y (11 tests) 
C35802O..Z (12 tests) 
C453210..Y (11 tests) 
C455210..Z (12 tests) 


Vatidation SuHaary Report 
Atsyt Liaited 


Chapter 2 - Page 1 of 5 


AVF_VSR_90502/85 
*lsyCB(P_073 Version 5.3 






IMPLEMENTATION DEPENDENCIES 


C455240..Z (12 tests) C456210..Z (12 tests) 

C456410..Y (11 tests) C46012O..Z (12 tests) 

The following 20 tests check for the predefined type LONG_INTEGER; for this implementation, 
there is no such type: 


C35404C 

C45231C 

C45304C 

C45411C 

C45412C 

C45502C 

C45503C 

C45504C 

C45504F 

C45611C 

C45613C 

C45614C 

C45631C 

C45632C 

B52004D 

C55B07A 

B55B09C 

B86001W 

C86006C 

CD7101F 


C35713D and B86001Z check for a predefined floating-point type with a name other than FLOAT, 
LONG_FLOAT, or SHORT_FLOAT; for this implementation, there is no such type. 

C45423A..B (2 tests), C45523A, and C45622A check that the proper exception is raised if 
MACHINE_OVERFLOWS is TRUE and the results of various floating-point operations lie outside 
the range of the base type; for this implementation, MACHlNE_OVERFLOWS is FALSE. 

C45531M..P and C45532M..P (8 tests) check fixed-point operations for types that require a 
SYSTF.M.MAX_MANTISSA of 47 or greater; for this implementation, MAX_MANT1SSA is less 
than 47. 

C45536A, C46013B, C46031B, C46033B, and C46034B contain length clauses that specify values for 
’SMALL that are not powers of two or ten; this implementation does not support such values for 
’SMALL. 

B86001Y uses the name of a predefined fixed-point type other than type DURATION; for this 
implementation, there is no such type. 

C96005B uses values of type DURATION’S base type that are outside the range of type 
DURATION; for this implementation, the ranges are the same. 

CD1009C checks whether a length clause can specify a non-default size for a floating-point type; this 
implementation does not support such sizes 

CD2A53A checks operations of a fixe^’-point type for which a length clause specifies a power-of-ten 
TYPE’SMALL; this implementation does not support decimal ’SMALLs. (See section 2.3.) 

CD2A84A, CD2A84E, CD2A84I..J (2 tests), and CD2A840 use length clauses to specify non-default 
sizes for access types; this implementation does not support such sizes. 

BD8001A, BD8003A, BD8004A..B (2 tests), and AD8011A use machine code insertions; this 
implementation provides no package MACHINE_CODE. 


Validation Sunaary Report 
Alays Liaited 


Chapter 2 - Pape 2 of 5 


*VF_VSR_90502/85 
Alsya*P_073 Version 5.3 






IMPLEMENTATION DEPENDENCIES 


The test listed in the following table checks that USE_ERROR is raised if the given file operations 
are not supported for the given combination of mode and access method; this implementation 
supports these operations. 


Test 

File Operation 

Mode 

File Access Method 

CE2102E 

CREATE 

OUT FILE 

SEQUENTIAL_IO 

CE2102F 

CREATE 

INOUT HLE DIRECTJO 

CE2102J 

CREATE 

OUT FILE 

DIRECT lO 

CE2102N 

OPEN 

IN fTlE 

SEQUENTIAL lO 

CE2102O 

RESET 

IN FILE 

SEQUENTIAL lO 

CE2102P 

OPEN 

OUT FILE 

SEQUENTIAL lO 

CE2102Q 

RESET 

OUT HLE 

SEQUENTIAL lO 

CE2102R 

OPEN 

INOUT FILE DIRECT lO 

CE2102S 

RESET 

INOUT HLE DIRECTJO 

CE2102T 

OPEN 

IN FILE 

DIRECT lO 

CE2102U 

RESET 

IN HLE 

DIRECT lO 

CE2102V 

OPEN 

OUT FILE 

DIRECT lO 

CE2102W 

RESET 

OUT FILE 

DIRECT lO 

CE3102F 

RESET 

Any Mode 

TEXT lO 

CE3102G 

DELETE 


TEXT lO 

CE3102I 

CREATE 

OUT FILE 

TEXT lO 

CE3102J 

OPEN 

IN fFlE 

TEXT lO 

CE3102K 

OPEN 

OUT FILE 

TEXT lO 

The tests listed in the following table check the given file operations for the given combination 

mode and access method; this implementation does not support these operations. 


Test 

File Operation 

Mode 

File Access Method 

CE2105A 

CREATE 

IN FILE 

SEQUENTIAL lO 

CE2105B 

CREATE 

IN FILE 

DIRECT lO 

CE3109A 

CREATE 

IN FILE 

TEXT lO 


CE2203A checks that WRITE raises USE_ERROR if the capacity of an external sequential file is 
exceeded; this implementation cannot restrict file capacity. 

EE2401D, EE2401G and CE2401H use instantiations of DIRECT_IO with unconstrained array and 
record types; this implementation raises USE_ERROR on the attempt to create a file of such type. 

CE2403A checks that WRITE raises USE_ERROR if the capacity of an external direct file is 
exceeded; this implementation cannot restrict file capacity. 


Vatidatfon Summcy Report 
Atsys Liaited 


Oiapter 2 - Page 3 of 5 


AVF_VSR_90502/85 
*tsyC0MP_073 Version 5.3 




IMPLEMENTATION DEPENDENCIES 


CE3304A checks that SET.LINE_LENGTH and SET_PAGE_LENGTH raise USE_ERROR if 
they specify an inappropriate value for the external file; there are no inappropriate values for this 
implementation. . 

CE3413B checks that PAGE raises LAYOUT_ERROR when the value of the page number exceeds 
COUNT’LAST; for this implementation, the value of COUNT'LAST is greater than 150(XK), making 
the checking of this objective impractical. 

CE3202A expects that function NAME can be applied to the standard input ind output files; in this 
implementation these files have no names, and USE_ERROR is raised. (See section 2.3.) 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 29 tests 

The following tests were split into two or more tests because this implementation did not report the 


violations 

of the Ala S.andard in the way expected by the original tests. 

B23004A 

B24007A 

B24009A 

B28003A 

B32202A 

B32202B 

B32202C 

B37004A 

B6I012A 

B74304A 

B74401F 

B74401R 

B910C4A 

B45102A 

B95069A 

B95069B 

B97103E 

BA1101B2 

BA1101B4 

BC2()01D 

BC3009C 

BC3204D 





B85002A was graded passed by Evaluation Modification as directed by tne AVO This test declares 
a record type REC2 whose sole component is of an unconstrained record type with a si/e in excess 
of 2** 32 bytes; this implementation rejects the declaration of REC2. Although a strict interpretation 
of the LRM requires that this type declarations be accepted (an exception may be raised on the 
elaboration of the type or an object declaration), the AVO accepted this behaviour in consideration 
that such early error detection is expected to be allowed by the revised language standard. 

C64103A and C95084A were graded passed by Evaluation Modification as directed by the AVO. 
Because this implementation’s actual values for LONG_FLOAT’SAFE_LARGE and 
SH0RT_FL0AT’LAST lie within one (SHORT_FLOAT) model interval of each other, the tests' 
floating-point applicability check may evaluate to TRUE and yet the subsequent expected exception 
need not be rais^. The AVO ruled that the implementation's behaviour siiould be graded as passed 
because the implementation passed the integer and fixed-point checks; the following 
REPORT.FAILED messages were produced after the type conversions at line 198 in C64103A and 
lines 101 and 250 in C95084A failed to raise exceptions: 

C64103A; "EXCEPTION NOT RAISED AFTER CALL P2 (B)" 

C95084A. "EXCEPTION NOT RAISED BEFORE CALL - T2 (A)" 

"EXCEPTION NOT RAISED AFTER CALL - T5 (B)" 


Validation SuMry Report 
Altys Lisited _ 


Chapter 2 - Page 4 of S 


AVF VSR_90502/85 
AlsyCt**‘_073 Version 5.3 





implementation dependencies 


BA2(X)1E was graded passed by Evaiualion Modification as directed by the AVO. The lest expects 
that duplicate names of subunits with a common ancestor will be detected as compilation errors; this 
implementation detects the errors at link time, and the AVO ruled that this behaviour is acceptable. 

EA3004D was graded passed by Evaluation and Processing Modification as directed by the AVO. Tlie 
test requires that either pragma INLINE is obeyed for a function call in each of three contexts and 
that thus three library units are made obsolete by the re-compilation of the inlined function’s body, 
or else the pragma is ignored completely. This implementation obeys the pragma except when the 
call is within the pack.-'ge specification. When the test’s files are processed in the given order, only 
two units are made obsolcic; thus, the expected error at line 27 of file EA3004D6M is not valid and 
is not flagged. To confirm that indeed the pragma is not obeyed in this one case, the test was also 
processed with the files re-ordered so that the re-compilation follows only the package declaration 
(and thus the other library units will not be made obsolete, as they are compiled later); a "NOT 
APPLICABLE" result was produced, as expected. The revised order of files was 0-1-4-5-2-3-6. 

CD2A53A was graded inapplicable by Evaluation Modification as directed by the AVO. The test 
contains a specification of a power-of-10 value as ’SMALL for a fixed-point type. The AVO ruled 
that, under ACVC 1.11, support of decimal ’SMALLs may be omitted. 

CE3202A was graded inapplicable by Evaluation Modification as directed by the AVO. This lest 
applies function NAME to the standard input file, which in this implementation has no name; 
USE_ERROR is raised but not handled, so the test is aborted. The AVO ruled that this behaviour 
is acceptable pending any resolution of the issue by the ARG. 


Validation SuMry Keport 
Atays Liaited 


Chapter 2 - Page 5 of 5 


AVF_VS«_90502/» 
AtsyC3iP_073 Version 5.3 




PROCESSING INFORMATION 


CHAPTER 3 

PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The Ada implementation tested in this validation effort is described adequately by the information 
given in the initial pages of this report, together with the following additional details: 

The Host computer has 4 CPU’s and is physically partitioned into two equal "sides" each with two 
processors. The side used for the validation has 256 Mbytes of physical memory. However, the AIX 
operating system runs in a virtual machine environment, implemented by VM/ESA Release 1.1. The 
virtual machine, upon which the validation runs, has 64 Mbytes of virtual storage. 

For technical information about this Ada implementation, contact; 

Simon FitzMaurice 
Alsys Ltd 
Partridge House 
Newtown Road 
Henley-on-Thames 
Oxfordshire 
RG9lEN 

For sales information about this Ada implementation, contact: 

Sharon Aucoin 
Alsys Inc 
1432 Main Street 
Waltham MA 02154 
USA 

Testing of this Ada implementation was conducted at the customer’s site by a validation team from 
the AVF. 

3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes each test of the customized test 
suite in accordance with the Ada Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC [Pro92]. 

For all processed tests (inapplicable and applicable), a result was obtained that conforms to the Ada 
Programming Language Standard. 


Validation Suanry Report 
Atays Liaitad 


Chapter 3 - Pa 9 e 1 of 4 


AVf_VS*_90502/85 
AtsyCONPOTS Veraion 5.3 






PROCESSING 1NF0R.NUT10N 


The list of items below gives the number of ACVC tests in various categories. All tests were 
processed, except those that were withdrawn because of test errors (item b; see section 2.1), those 
that require a floating-point precision that exceeds the implementation’s maximum precision, other 
than the first test in each series, (item e; see section 2.2), and those that depend on the support of 
a file system -- if none is supported (item d). All tests passed, except those that are listed in sections 
2.1 and 2.2 (counted in items b and f, below). 


a) 

Total Number of Applicable Tests 

3834 

b) 

Total Number of Withdrawn Tests 

95 

c) 

Processed Inapplicable Tests 

- 96 

d) 

Non-Processed I/O Tests 

0 

e) 

Non-Processed Floating-Point Precision Tests 

; 145 

f) 

Total Number of Inapplicable Tests 

241 (c+d-(-e) 

g) 

Total Number of Tests for ACVC 1.11 

4170 (a-fb+f) 


3.3 TEST EXECUTION 

A magnetic tape containing the customized test suite (see section 1.3) was taken on-site by the 
validation team for processing. The contents of the magnetic tape were loaded directly onto the host 
computer. 

After the test files were loaded onto the host computer, the full set of tests was processed by the Ada 
implementation. 

Testing was performed using command scripts provided by the customer and reviewed by the 
validation team. See Appendix B for a complete listing of the processing options for this 
implementation. It also indicates the default options. 

The following non-default options are passed to the compiler for executable tests; 

CALLS = INLINED 

Allow inline insertions of code or subprograms. 

EXPRESSIONS = EXTENSIVE 

Perform optimisations on common subexpressions and register allocations. 

REDUCTION = EXTENSIVE 

Perform optimisations on run-time checks and remove dead code. 

WARN = NO 


Vatldation 


Alayt Liaited 


iry Report 


Chapter 3 - Page 2 of 4 


*VF_VSR_90502/85 
AtsyC0MP_073 Version 5.3 







PROCESSING INFORNUTION 


Do not include warning messages in the compilation listing. 

DEBUG = YES 

Save informations for the Alsys debuggers. 

The following non-default options are passed to the compiler for non-executable tests: 

ERRORS = 999 

Set the maximum number of compilation errors permitted before compilation is aborted, 
TEXT 

Print a compilations listing including the full score text. 

SHOW = NONE 

Do not print a header and do not include an error summary in the compilations listing. 
DETAIL = NO 

Do not include extra detail in the compilations listing. 

WARN = NO 

Do not include warning messages in the compilations listing. 

The following non-default options are passed to the binder for executable tests: 

LEVEL = BIND 

Do not perform the systems linkage step. 

WARN = NO 

Do not output warning messages. 

OUTPUT = NONE 

Do not produce any output binder listing. 

No Non-default options are passed to the binder for ‘L’ tests. 

The system command cc is used to link object files generated by the binder with the routine C and 
assembler library. No non-default options are passed. 


Validation Suaaary Report 
Alsys Liaited _ 


Chapter 3 - Page 3 of 4 


AVF_VSR_90502/85 
AlsyCO*>_073 Version 5.3 






PROCESSING information 


Test output, compiler and linker listings, and job logs were captured on magnetic tape and archived 
at the AVF. The listings examined on-site by the validation team were also archived. 


Vatictotion Suwary Raport 
Altys Liaitad 


Chapter 3 - Paoe 4 of 4 


AVF_VSt_90502/«5 
AlsyCaMP_073 Version 5.3 







NUCRO PARAMETERS 


APPENDIX A 
MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing the ACVC. The meaning and 
purpose of these parameters are explained in (UG89J. The parameter values are presented in two 
tables. The first table lists the values that are defined in terms of the maximum input-line length, 
which is the value for SMAX_IN_LEN-also listed here. These values are express^ here as Ada 
string aggregates, where "V" represents the maximum input-line length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 

SBIGJDl 

$BIGJD2 

$BIGJD3 

$B[G_ID4 

$BIG_INT_LIT 

$BIG_REAL_LIT 

$BIG_STRING1 

$BIG_STRING2 

SBLANKS 

$MAX_LEN_INT_BASED_LITERAL 


255 - Value of V 
(1..V-1 => ’A’. V => T’) 

(1..V-1 => ’A’, V => '2') 

(1..V/2 => ’A’) & ’3’ & (1..V-1-V/2 => 
(1..V/2 => 'A') & ’4’ & (1..V-I-V/2 => 
(1..V-3 => ’O’) & "298" 

(1..V-5 => ’O’) & ”690.0" 

& (1..V/2 ’A’) & 

’■•’ & (1..V-1-V/2 => ’A’) & 

(1..V-20 => ”) 


’A’) 


’A’) 


"2:" & (1..V-5 => ’O’) & "11:" 


$MAX_LEN REAL BASED LITERAL 

"16:" & (1..V-7 => ’O’) & "F.E:” 


$MAX_STRING_LITERAL & (1..V-2 => ’A’) & 


Validation SuaMry Report AVF_VS«_90S02/8S 

*lay» Liaitad __ Appendix A - Page 1 of 4 AlsyCCMP_073 Version 5.3 






NUCRO PARAMETERS 


The following table lists all of the other macro parameters and their respective values 

Macro Parameter 

Macro Value 

$ACC_SIZE 

32 

SALIGNMENT 

4 

$COUNT_LAST 

2147483647 

$DEFAULT_MEM_SIZE 

4294967296 

$DEFAULT_STOR_UNIT 

8 

$DEFAULT_SYS_NAME 

S370 

$DELTA_DOC 

2;1.0;E-31 

$ENTRY_ADDRESS 

SYSTEM.NULL_ADDRESS 

$ENTRY_ADDRESS1 

SYSTEM.NULL_ADDRESS 

$ENTRY_ADDRESS2 

SYSTEM.NULL_ADDRESS 

$FIELD_LAST 

255 

$FILE_TERMINATOR 

t f 

$nXED_NAME 

NO_SUCH_TYPE 

$FLOAT_NAME 

NO_SUCH_TYPE 

$FORM_STRING 


$FORM_STRING2 

"CANNOT_RESTRlCT_FlLE_CAPACITY’' 

$GREATER_THAN_DURAT10N 

100000.0 

$GREATER_THAN_DURATION. 

_BASE_LAST 

131_073.0 

SGREATER THAN FLOAT BASE LAST 

l.OE+80 

SGREATER THAN FLOAT SAFE LARGE 

1 6:0. FFFF_FFFF_FFFF_F9: E63 


Validation Suaaary Report AVf_VSR_90502/85 

Alaya Liaited _ Appendl* * - Page 2 of 4 AtsyC0NP_073 Version 5.3 




MACRO PARAMETERS 


SGREATER THAN SHORT_FLOAT_SAFE_LARGE 

16:0,FTFF_P9:E63 

$HIGH_PRIORlTY 10 

$ILLEGAL_EXTERNAL_F1LE_NAME1 

/nodirectory/filenamel 

$ILLEGAL_EXTERNAL_FILE_NAME2 

/nodirectory/filenameZ 

$INAPPROPRIATE_LINE_LENGTH -1 

SINAPPROPRLATE PAGE_LENGTH 

-1 

$INCLUDE_PRAGMA1 PRAGMA INCLUDE ("A28006D1.TST’’) 

SINCLUDE_PRAGMA2 PRAGMA INC JDE ("B 28006 Dl.TSr') 

$INTEGER_FIRST -2147483648 

$1NTEGER_LAST 2147483647 

$INTEGER_LAST_PLUS_1 2147483648 

SINTERFACE_LANGUAGE C 

$LESS_THAN_DURATION -100_000.0 

$LESS THAN DURATION BASE FIRST 

-131_073.0 

$LINE_TERMINATOR ASCII.LF 

$LOW_PRIORrrY 1 

$MACHINE_CODE_STATEMENT NULL; 

$MACHINE_CODE_TYPE NO_SUCH_TYPE 

$MANTISSA_DOC 31 

SMAX_DIGITS 18 

SMAXJNT 2147483647 

Validation SuMaary Report AVF_VSR_90502/85 

Alaya Liaited _ Appendix A - Pape 3 of 4 Als>cnNP_073 Version 5.3 





NUCRO PARAMETERS 


$MAX_INT_PLUS_1 

SMINJNT 

$NAME 

$name_list 

$name_specificationi 

$NAME_SPECinCATION2 

$NAME_SPECinCATION3 

$NEG_BASED_INT 

$NEW_MEM_SIZE 

$NEW_STOR_UNIT 

$NEW_SYS_NAME 

$PAGE_TERMINATOR 

$RECORD_DEFINnTON 

$RECORD_NAME 

$TASK_SIZE 

$TASK_STORAGE_SIZE 

STICK 

$VARIABLE_ADDRESS 

$VARIABLE_ADDRESS1 

$VARIABLE_ADDRESS2 

$your_pragma 


2147483648 

-2147483648 

short_short_integer 

180X86,I80386,MC680XO,S370.TRANSPUTER.VAX,RS. 
6000,MIPS,SPARC 

Aendor A'end0226/acvcrun/X2120A 

AendorAend0226/acvcnin/X2120B 

AendorAend0226/acvcrun/X3119A 

16#FOOOOOOE# 

0 

0 

VAX 
ASCII.FF 
NEW INTEGER; 

NO_SUCH_MACHINE_CODE_TYPE 

32 

10240 

0.01 

V_ADDRESS 

V_ADDRESS1 

V_ADDRESS2 

EXTERNAL^NAME 


Validation Sunaary Report 
Altya Liaited 


Appendix A - Pape A of 4 


AVF_VSR_90502/85 
AlsyCOaP_073 Version 5.3 





COMPILATION SYSTEM OPTIONS 


APPENDIX B 

COMPILATION SYSTEM OPTIONS 

The compiler options of this Ada implementation, used in this validation and described in this 
Appendix, are provided by the customer. Unless specifically noted otherwise, references in this 
Appendix are to compiler documentation and not to this report. 


COMPILE (SOURCE => <source>, 

name of source file. 

LIBRARY => < library >, 

name of Ada library. 


OPTIONS => (ANNOTATE 

null annotation string stored in library with unit. 

— W Mit 
“ » 

ERRORS 

allow 999 errors before aborting compilation. 

= >999, 

LEVEL 

compile to object code and update Ada library. 

= > UPDATE, 

CHECKS 

perform all runtime checks. 

= >ALL, 

GENERICS 

placed code of generic instantiations in-line. 

= >INLINE, 

MEMORY 

allow 500KB of virtual memory for compiler. 

= >500), 

DISPLAY => (OUTPUT 

send listing to standard output (normally the screen). 

= > SCREEN, 

WARNING 

suppress warning messages. 

= >NO, 

TEXT 

include full course text in listing. 

= >YES, 

SHOW 

do not include banner or error summary in listing. 

= >NONE, 

DETAIL 

do not include extra detail in error messages. 

= >NO, 

ASSEMBLY 

do not include assembly code in listing 

= >NONE), 

IMPROVE '=> (CALLS 

use normal mode for subprogram calls. 

= > NORMAL, 

REDUCTION 

do not invoke high level optimiser. 

= >NONE, 

EXPRESSIONS 

do not invoke low level optimiser. 

= >NONE, 

OBJECT 

invoke the peephole optimiser. 

= >PEEPHOLE), 


Validation Suawry Report 
Alaya Liaited 


Appendix B - Page 1 of 3 


AVF_VS«_90502/85 
AtsyCOPP_073 Version 5.3 




COMPILATION SYSTEM OPTIONS 


KEEP =>(TREE =>NO, 

do not keep the intermediate representation of the program in the Ada library. 

DEBUG =>NO, 

do not keep debug information for the program in the Ada library. 

COPY =>NO), 

do not keep source text of the program in the Ada library. 

ALLOCATION = > (STACK = > 1024, 

maximum size of data allocated directly in stack frame. 

GLOBAL =>1024, 

maximum size of data allocated directly in global data area. 

UNNESTED '=>16)); 

maximum size of data allocated in parent frame of subunit. 


Vatidation SuNMiry Report 
Alsys LiMited 


Appendix B - Pea* 2 of 3 


AVF_VSR_90502/85 
Al»yC**P_073 Version 5.3 








COMPILATION SYSTEM OPTIONS 


LINKER (Binder) OPTIONS 

The linker (binder) options of this Ada implementation, as used in the validation and described in 
this Appendix, are provided by the customer. Unless specifically noted otherwise, references in this 
Appendix are to linker documentation and not to this report. 

(PROGRAM => <program name>, 

name of main subprogram. 

LIBRARY => <library>, 

name of Ada library. 

OPTIONS => (LEVEL '=>BIND, 

link all units into a single executable. 

OBJECT => AUTOMATIC, 

derive executable name directly from program name. 

UNCALLED = > REMOVE, 

remove code for uncallable subprograms. 

SLICE =>1000, 

set timeslice interval to 1000 microseconds. 

BLOCKING => AUTOMATIC), 

derive lO blocking automatically. 

STACK =>(MAIN =>64, 

default size for main program stack. 

TASK =>16, 

default size of task stacks. 

HISTORY =>YES), 

include call history information. 

INTERFACE => (DIRECTIVES =>"", 

null directives list passed to system linker. 

MODULES =>"", 

null modules list passed to system linker. 

SEARCH =>”", 

null search library list passed to system linker. 

HEAP => (SIZE =>256, 

default initial size for heap. 

INCREMENT =>4, 

default increment size for heap. 

DISPLAY => (OUTPUT =>NONE, 

do not produce a bind listing. 

NB For L tests the binder listing is set to standard output by setting OUTPUT => SCREEN 

DATA =>NO, 

do not include detailed program map in listing. 

WARNING =>NO), 

suppress warning messages. 

KEEP => (DEBUG =>NO, 

do not keep debug information for the program in an information file. 

CUI => AUTOMATIC)); 

derive the name of the information file from the program name. 


Validation SuHMry Report 
Alsya Liaitad 


Appendix B - Page 3 of 3 


AVF_VS«_90502/85 
Al8vC0HP_073 Version 5.3 





APPENDIX F OF THE Ada STANDARD 


APPENDIX C 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to implementation-dependent pragmas, 
to certain machine-dependent conventions as mentioned in Chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The impldhientation-dependent characteristics 
of this Ada implementation, as described in this Appendix, are provided by the customer. Unless 
specifically noted otherwise, references in this Appendix are to compiler documentation and not to 
this report. Implementation-specific portions of the package STANDARD, which are not a part of 
Appendix F, are: 


package STANDARD is 

type SHORT_SHORT_INTEGER is range -128.. 127; 

type SHORT_INTEGER is range -32768..32767; 

type INTEGER is range -2147483648..2147483647' 

type SHORT FLOAT is digits 6 range -16#0.FFFF FF#E+63.. 

16#0.FFFFJt#E+63; 

type FLOAT is digits 15 range -16#0.FFFF_FFFF FFFF FF#E-t-63.. 

16#0.FFFF_FFFF_FFFFJfF#E+63; 

type L0NG_FL0AT is digits 18 range -16#FFFF FFFF FFFF_FFFF_FFFF_FFFF_FFFF#E+63.. 

16#FFFF>FFF~FFFF_.FFFF_FFFF_FFFF_FFFF#E+63; 

type DURATION is delta 2#0.000_000_000_000_01#range -131_072.0..131_071.0; 


end STANDARD; 


«VF_VSR_90502/85 
AlsyC0NP_073 Version 5.3 


Validation SuHaary Report 
Alsys Liaited 


Appendix C - Page 1 of 1 







Alsys IBM 390 Ada Compiler 


APPENDIX F ' 
for AIX 


Implementation - Dcj endcnt Characteristics 


Version 5.3 





TABLE OF CONTENTS 


APPENDIX F 


1 Implementatioii'Dependent Pragmas 

1.1 INLINE 

1.2 INTERFACE 

1.3 INTERFACE NAME 

1.4 INDENT 

1.5 Other Pragmas 

2 Implementation-Dependent Attributes 


3 Specification of the Package SYSTEM 


4 Restrictions on Representation Clauses 

4.1 Enumeration Types 

4.2 Integer Types 

4.3 Floating Point Types 

4.4 Fixed Point Types 

4.5 Access Types 

4.6 Task Types 

4.7 Array Types 

4.8 Record Types 

5 Conventions for Implementation-Generated Names 


6 Address Clauses ' 

6.1 Address Clauses for Objects 

6.2 Address Clauses for Program Units 

6.3 Address Clauses for Entries 


Table of Contents 





7 


Restrictions on Unchecked Conversions 


38 


8 Input-Output Packages 39 

8.1 NAME Parameter 39 

8.2 FORM Parameter , 39 

8.3 STANDARDJNPUT and STANDARD OUTPUT 45 

8.4 USEERROR ‘ 46 

8.5 Text Terminators 46 

9 Characteristics of Numeric Types 47 

9.1 Integer Types 47 

9.2 Floating Point Type Attributes 48 

9.3 Attributes of Type DURATION 50 

10 Other Implementation-Dependent Characteristics 51 

10.1 Characteristics of the Heap 51 

10.2 Characteristics of Tasks 51 

10.3 Definition of a Main Program 52 

10.4 Ordering of Compilation Units 52 


INDEX 55 


Als\'s IBM 390 Ada Compiler, Appendix F forAIX, v5.J 







APPENDIX F 


Implementatioti'Dependent Characteristics 


This appendix summarizes the implementation-dependent characteristics of the Alsys 
IBM 390 Ada Compiler for AlX. This document should be considered as the Appendix F 
to the Reference Manual for the Ada Programming Language ANSI/MIL-STD l8l5iA, 
January 1983, as appropriate to the Alsvs Ada implementation for the IBM 390 under 
AlX. 

Sections 1 to 8 of this appendix correspond to the various items of information required in 
Appendix F (F]*; sections 9 and 10 provide other information relevant to the Alsys 
implementation. The contents of these sections is described below: 

1. The form, allowed places, and effect of every implementation-dependent pragma. 

2. The name and type of every implementation-dependent attribute. 

3. The specification of the package system |13.7]. 

4. The list of all restrictions on representation clauses |13.1J. 

5. The conventions used for any implementation-generated names denoting 
implementation-dependent components [13.4). 

6. The interpretation of expressions that appear in address clauses. 

7. Any restrictions on unchecked conversions (13.10.2]. 

8. Any implementation-dependent characteristics of the input-output packages [14], 

9. Characterbtics of numeric types. 


* Throughout this manual, citations in square brackets refer to the Reference Manual 
for the Ada Programming Language, ANSI/M1L-STD-1815A, January 1983. 


Appendix F, Implementation-Dependent Characteristics 


I 




10. Other implementation-dependent characteristics. 

Throughout this appendix, the name Ada Run-Time Executive refers to the run-time 
library routines provided for all Ada programs. These routines implement the Ada heap, 
exceptions, tasking control, I/O, and other utility functions. 


1 Implementation-Dependent Pragmas 
1.1 INLINE 

Pragma INLINE is fully supported, except for the fact that it is not possible to inline a 
function call in a declarative part. 


1.2 INTERFACE 

Ada programs can interface to subprograms written in C or other languages through the 
use of the predefined pragma INTERFACE [13.9] and the implementation-defined pragma 
INTERfACE_NAME. 

Pragma interface specifies the name of an interfaced subprogram and the name of the 
programming language for which calling and parameter passing conventions will be 
generated. Pragma INTERFACE lakes the form specified in the Reference Manual: 

pragma INTERFACE {language jiame, subprogram jiame), 

where: 

■ languagejtame is the name of the other language whose calling and parameter 
passing conventions are to be used. 

• subprogram jtame is the name used within the Ada program to refer to the 
interfaced subprogram. 

The only language names currently accepted by pragma INTERFACE are C and 
ASSEMBLER. 

The language name used in the pragma INTERFACE does not necessarily correspond to 
the language used to write the interfaced subprogram. It is used only to tell the Compiler 
how to generate subprogram calls, that is, which calling conventions and parameter 
passing techniques to use. 


2 


Alsys IBM 390 Ada Compiler, Appendix F forAJX, v5.J 



The language name C is used to refer to the standard IBM AlX/390 C calling and 
parameter passing conventions. The programmer can use the language name C to 
interface Ada subprograms with subroutines written in any language that follows the 
standard IBM AIX/390 C calling conventions. 

The language name ASSEMBLER provides the same calling and parameter passing 
conventions as the language name C, and only differs in the handling of the external name, 
as described below. 


1.3 INTERFACE NAME 

Pragma I.ntERFace NAME associates the name of an interfaced subprogram, as declared 
in Ada, with its name in the language of origin. If pragma 1NTERF.ace_na.ME is not used, 
then the two names are assumed to be identical. 

This pragma takes the form: 

pragma INTERFACE NAME (subprogram name, string literal)', 
where: 

■ subprogram jxame is the name used within the Ada program to refer to the 
interfaced subprogram. 

■ stringJiteral is the name by which the interfaced subprogram is referred to at link¬ 
time. 

The use of INTERFACE Name is optional, and is not needed if a subprogram has the same 
name in Ada as in the language of origin. It is necessary, for example, if the name of the 
subprogram in its original language contains characters that are not permitted in Ada 
identifiers. Ada identifiers can contain only letters, digits and underscores, whereas the 
IBM AIX/390 linkage editor (Id) allows external names to contain other characters, e.g. 
the plus or minus sign. These characters can be specified in the string literal argument of 
the pragma interface_name. 

The pragma l^rTERFACE_NAME is allowed at the same places of an Ada program as the 
pragma INTERFACE [13.91- However, the pragma INTERFACE NAME must always occur 
after the pragma INTERFACE declaration for the interfaced subprogram. 

There is no limit to the length of the string Jiteral nor any restriction on the characters of 
which is it composed. The user must be aware however, that some tools from other 


Appendix F, Implementation-Dependent Characteristics 


3 





vendors may not fully support the standard object file format and may restrict the length 
or character content of symbols. 

For a subprogram intei faced using the language name ASSEMBLER, the external name of 
the subprogram passed through to the AIX object file is the string literal used in the 
pragma INTERFACE NAME, with case preserved. If a pragma lNTERF.ArE_.\A.ME is not 
used, the Ada name of the subprogram is passed through io the object file, in lower case. 

The external name passed through to the object file for a subprogram interfaced using the 
language name C is formed in the same way as for a subprogram interfaced using 
ASSEMBLER, with the addition of a leading underscore character. This follows the same 
conventions as used by the AlX/390 C compiler and assembler. 

The Runtime Executive contains several external identifiers. The majority of these 
identifiers begin with the string "ALSY" or the string "alsy". Accordingly, external names 
of this form should be avoided by the user. 


Example 

package SAMPLE DATA is 

function SAMPLE DEVICE {X ; INTEGER) return INTEGER; 
function PROCESS_SAMPLE (X : INTEGER) return INTEGER; 
private 

pragma INTERFACE (C, SAMPLE DEVICE); 
pragma INTERFACE (C, PROCESS SAMPLE); 
pragma INTERFACE NAME (PROCESS SAMPLE, "PSAMPLE”); 
end SAMPLE DATA; 


1.4 INDENT 

This pragma is only used with the Alsys Reformatter {AdaReformat)-, this tool offers the 
functionalities of a source reformatter in an Ada environment. 

The pragma is placed in the source file and interpreted by the Reformatter. 

pragma INDENT(OFF) ” 

The Reformatter does not modify the source lines after the OFF pragma INDEOT. 
pragma INDENT(ON) 


4 


Alsys IBM 390 Ada Compiler, Appendix F for AIX, vS.3 



The Reformatter resumes its action after the ON pragma INDENT. Therefore any source 
lines that are bracketed by the OFF and on pragma indents are not modified by the Alsys 
Reformatter. 


1.5 Other Pragmas 

Pragmas I.MPROVE and PACK are discussed in detail in the section on representation 
clauses (Chapter 4). 

Pragma PRIORITY is accepted with the range of priorities running from 1 to 10 (see the 
definition of the predefined package SYSTE.M in Chapter 3). The undefined priority (no 
pragma PRIORITY) is treated as though it were less than any defined priority value. 

In addition to pragma SUPPRESS, it is possible to suppress checks in a given compilation by 
the use of the Compiler option CHECKS. 

The following language defined pragmas have no effect 

CONTROLLED 
MEMORY SIZE 
OPTIMIZE 
STORAGE_L'Nrr 
SYSTEM_NA.ME 

Note that all access types are implemented by default as controlled collections as 
described in (4.8] (see section 10.1). 


2 Implementation-Dependent Attributes 

In addition to the Representation Attributes of (13.7.2] and 113.7.3], the four attributes 
listed in section 5 (Conventions for Implementation-Generated Names), for use in record 
representation clauses, and the attributes described below are provided: 

TDESCRIPTOR SIZE For a prefix T that denotes a type or subtype, this 

attribute yields the size (in bits) required to hold a 
' descriptor for an object of the type T, allocated on 
the heap or written to a file. If T is constrained, 
TDESCRIPTOR SIZE will yield the value 0. 


Appendix F, Implementation-Dependent Characteristics 


5 




ns array 


For a prefix T that denotes a type or subtype, this 
attribute yields the value TRUE if T denotes an 
array type or an array subtype; otherwise, it yields 
the value false. 

Limitations on the use of the attribute ADDRESS 

The attribute ADDRESS is implemented for all prefixes that have meaningful addresses. 
The following entities do not have meaningful addresses. The attribute address will 
deliver the value SYSTEM n'L LL address if applied to such prefixes and a compilation 
warning will be issued. 

• A constant or named number that is implemented as an immediate value (i.e. does 
not have any space allocated for it). 

■ A package specification that is not a library unit. 

■ A package body that is not a library unit or subunit. 


3 Specification of the Package SYSTEM 

package SYSTEM is 

type NAME is (180X86, 

I80386, 

HC680X0, 

S370, 

TRANSPUTER, 

VAX, 

RS 6000, 

MIPS, 

SPARC); 

SYSTFM_NAME : constant NAME := S370; 

STORAGE_UNIT : constant := 8; 

MAX INT“ : constant := 2**31 - 1; 

MIMJNT : constant := • (2**31); 

MAX'mANTISSA : constant := 31; 

FINE DELTA : constant := 2#1.0#£-31; 

MAX DIGITS ; constant :* 18; 

MEm5ry_SIZE : constant := 2**32; 

TICK : constant := 0.01; 

subtype PRIORITY is INTEGER range 1 .. 10; 


6 


Alsys IBM 390 Ada Compiler, Appendix F forAlX, v5.J 




INTERRUPT_LEVELS : constant := 1; 

subtype INTERRUPT PRIORITY is INTEGER range 

PRIORITY' LAST^T. .priority* LAST*INTERRUPT_LEVELS; 

type ADDRESS is private; 

NULL_ADDRESS : constant ADDRESS; 

ADORESS_SIZE : constant := 4; 

function VALUE (LEFT ; in STRING) return ADDRESS; 

subtype ADDRESS_STRINC is STRINGCl..6); 

function IMAGE (LETT ; in ADDRESS) return A00RESS_STR1NG; 


type OFFSET is range -(2**31) .. 2**31-1; 

-- This type is used to measure a nutiber of storage units (bytes), 
function SAME_SEGMENT (LEFT, RIGHT ; in ADDRESS) return BOOLEAN; 


A00RESS_ERR0R ; exception; 


function 
function "+" 
function 

function 


(LEFT 

in ADDRESS; RIGHT 

in 

OFFSET) 

return 

ADDRESS 

(LEFT 

in OFFSET; RIGHT 

in 

ADDRESS) 

return 

ADDRESS 

(LEFT 

in ADDRESS; RIGHT 

in 

OFFSET) 

return 

ADDRESS 

(LEFT 

in ADDRESS; RIGHT 

in ADDRESS) 

return 

OFFSET; 


function "<=» (LEFT, RIGHT 
function "<" (LEFT, RIGHT 
function ">=" (LEFT, RIGHT 
function ">" (LEFT, RIGHT 


in ADDRESS) 
in ADDRESS) 
in ADDRESS) 
in ADDRESS) 


return BOOLEAN 
return BOOLEAN 
return BOOLEAN 
return BOOLEAN 


function "mod" (LEFT 


in ADDRESS; RIGHT : in POSITIVE) return NATURAL; 


type ROOMO_DIRECTION is (DOWN, UP); 


function ROUND (VALUE 

DIRECTION 

MODULUS 


in ADDRESS; 

in ROUND_DIRECTION; 

in POSITIVE) return ADDRESS; 


generic 

type TARGET is private; 

function FETCH_FROM_AOORESS (A : in ADDRESS) return TARGET; 
generic 

type TARGET is private; 

procedure ASSIGN_TO_ADDRESS (A : in ADDRESS; T : in TARGET); 

-- These routines are provided to perform READ/WRIIE operations in memory. 


Appendix F, Implementation-Dependent Characteristics 


7 






type OBJECT_LENGTH is range 0 .. 2»*31 -1; 

-- This type is used to designate the size of an object in storage units. 

procedure HOVE (TO ; in ADORERS; 

FROM : in AODi. GS; 

LENGTH : in OBJ’ LENGTH); 

end SYSTEM; 

The function VALUE may be used to convert a string into an address. The string is a 
sequence of up to eight hexadecimal characters (digits or letters in upper or lower case in 
the range A..F) representing a virtual address. The exception CONSTRAint error is 
raised if the string does not ha- c .he proper syntax. 

The function IMAGE mav ^ used to convert an address to a string which is a sequence of 
exactly eight hexade^it ..i digits. 

The function S\ME_SEGMENT always returns TRUE and the exception ADDRESS ERROR is 
never raised as the 390 is a non segmented architecture. 

The fur ctions “ +" and with an ADDRESS and an OFFSET parameter provide support to 
perform address computations. The offset parameter is added to, or subtracted from 
the address. The exception CONyrRAlNT ERROR can be raised by these functions. 

The function with the two ADDRESS parameters may be used to return the distance 
between the specified addresses. 

The functions "< = and may be used to perform a comparison on the 

specified addresses. The comparison is unsigned. 

The function "mod" may be used to return the offset of LEFT address relative to the 
memory block immediately below it starting at a multiple of RIGHT storage units. 

The function ROUND may be used to return the specified address rounded to a specific 
value in a particular direction. 

The generic function FETCH FROM ADDRESS may be used to read data objects from given 
addresses in store. The generic function assign to aDDRESS may be used to write data 
objects to given addresses in store. These routines may not be instantiated wth 
unconstrained types. 

The procedure MOVE may be used to copy LENGTH storage units starting at the address 
FROM to the address TO. The source and destination locations may overlap. 


8 


Alsys IBM 390 Ada Compiler, Appendix F for AIX, v5.J 






4 Restrictions on Representation Clauses 

This section explains how objects are represented and allocated by the Alsys IBM 390 Ada 
Compiler and how it is possible to control this using representation clauses. 

The representation of an object is closely connected with its type. For this reason this 
section addresses succes.sively the representation of enumeration, integer, floating point, 
fixed point, access, task, array and record types. For each class of type the representation 
of the corresponding objects is described. 

Except in the case of array and record types, the description of each class of type is 
independent of the others. To understand the representation of an array type it is 
necessary to understand first the representation of its components. The same rule applies 
to a record type. 

Apart from implementation defined pragmas, Ada provides three means to control the 
size of objects: 

■ a (predefined) pragma PACK, when the object is an array, an array component, a 
record or a record component 

■ a record representation clause, when the object is a record or a record component 

■ a size specification, in any case. 

For each class of types the effect of a size specification is described. Interaction between 
size specifications, packing and record representation clauses is described under array and 
record types. 

Representation clauses on derived record types or derived task types are not supported. 

Size representation clauses on types derived from private types are not supported when 
the derived type is declared outside the private part of the defining package. 


4.1 Enumeration Types 

Internal codes of enumeration literals 

When no enumeration representation clause applies to an enumeration type, the internal 
code associated with an enumeration literal is the position number of the enumeration 
literal. Then, for an enumeration type with n elements, the internal codes are the integers 
0,1, 2,..., n-1. 


Appendix F, Implementation-Dependent Characteristics 


9 






An enumeration representation clause can be provided to specify the value of each 
internal code as described in [13.3], The Alsys Compiler fully Implements enumeration 
representation clauses. 

As internal codes must be machine integers the internal codes provided by an 
enumeration representation clause must be in the range -23i .. 231-1. 


Encoding of enumeration values 

An enumeration value is always represented by its internal code in the program generated 
by the Compiler. 


Enumeration subtypes 

Minimum size: The minimum size of an enumeration subtype is the minimum number of 
bits that is necessary for representing the internal codes of the subtype values in normal 
binary form. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M are 
the values of the uJternal codes associated with the first and last enumeration values of the 
subtype, then its minimum size L is determined as follows. For m > = 0, L is the smallest 
positive integer such that M < = 2L-1. For m < 0, L is the smallest positive integer such 
that -21-1 < = m and M < = 2L-1.1. 


For example: 

type COLOR is (green, black, white, red. blue, yellow); 

— The minimum size of COLOR is 3 bits. 

subtype BLACK_AND_WHrrE is COLOR range BLACK .. WHITE; 

— The minimum size of black_a.nd_white is 2 bits. 

subtype BLACK_OR_WHrrE is BLACK and white range X .. X; 

- Assuming that X is not static, the minimum size of BLACK or white is 
" 2 bits (the same as the minimum size of the static type mark 

- BLACK_AND_WHITE). ' 

Size: When no size specification is applied to an enumeration type or first named subtype, 
the objects of that type or first named subtype are represented as signed integers if the 
internal code associated with the first enumeration value is negative, and as unsigned 


JO 


Alsys IBM 390 Ada Compiler, Appendix FforAlX, v5.3 


integers otherwise. The machine provides 8, 16 and 32 bit integers, and the Compiler 
selects automatically the smallest machine integer which can hold each of the internal 
codes of the enumeration type (or subtype). The size of the enumeration type and of any 
of its subtypes is thus 8, 16 or 32 bits. 

When a size specification is applied to an enumeration type, this enumeration type and 
each of its subtypes has the size specified by the length cla«se. The same rule applies to a 
first named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies. 

For example: 

type EXTENDED is 

( — The usual American ASCII characters. 


NUL. 

SOH. 

STX. 

ETX. 

EOT. 

ENO. 

ACK. 

BEL. 

BS. 

HT. 

LF. 

VT. 

FF 

CR. 

SO. 

SI, 

DLE. 

DCl. 

DC2. 

DC3. 

DC4, 

\AK. 

SYN. 

ETB. 

CAN, 

E.M, 

SUB. 

ESC. 

FS. 

GS. 

RS. 

US. 

”, 



■#•. 

■S'. 









■•'. 


■ r 
! . 

•O', 

'1'. 

'2‘. 

■r 

•4', 

■S', 

■6'. 

■7'. 

■8'. 

•9 . 



■ < 

■ = ■, 

■ > . 

'*T 


•A'. 

B', 

c. 

D'. 

E', 

F. 

G'. 

■H'. 

I', 

■J'. 

K 

L. 

M . 

■N". 

O’, 

P. 

O'. 

R. 

■S'. 

T. 

■f. 

■V'. 

"W. 

'X'. 

•y. 

T. 

T. 

■\'. 

T- 

... 



a'. 

b\ 

'c'. 

'd , 

'e'. 

T. 

'%■ 

■h’. 

'i'. 

y. 

k'. 

'I'. 

'm'. 

'n'. 

'o', 

■p'. 

■q'- 

‘r’. 

's'. 

I'. 

'u'. 

'v'. 

'W. 

’x'. 

y. 

'z'. 





DEL. 


- Extended characters 

LEFTARROW, 

RIGHTARROW, 

UPPERARROW, 

LOWERARROW, 

UPPER LEFT CO R,NER. 
UPPERRIGHTCORNER. 
LOWER_RIGHT_COR,NER. 
LOWER_LEFT_COR.\ER. 
...); 


Appendix F, Implementation-Dependent Characteristics 11 










for c\"re\Dt;D sizt: use 8, 

-- The 'izc of type EXTENDLD v.ifl be one byte, (ts objects will be represented 
-- as unsigned 8 bit integers. 

The Alsys Compiler fully implements size specifications. Nevertheless, as enumeration 
values arc coded using integers, the specified length cannot be greater than 32 bits. 

Object size: Provided its size is not constrained by a recor'S component clause or a 
pragma PACK, an object of an enumeration subtype has the same size as its subtype. 

.41ignment: An enumeration subtype is byte aligned if the size of the subtype is less than 
or equal to 8 bits, halfword aligned if the size of the subtype is less than or equal to 16 bits 
and word aligned otherwise 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of an enumeration subtype Ls a 
multiple of the alignment of the corresponding subtype 


4.2 Infeger Types 

Predefined integer types 

There are three predefined integer types in the .Alsys implementation for IBM 390 
machines: 

type SHORT_SHORTJ.NTEOER is range -2*’07 . 2**07.1; 

type SHORT_lNTEGER is range -2*’15 .. 2'*15-1; 

type INTEGER is range -2**31 .. 2**3l-l; 


Selection of the parent of an integer type 

An integer type declared by a declaration of the form: 

typeT is range L .. R; 

is implicitly derived from eitherjhe SHORTJNTEGER or INTEGER predefined integer type. 
The Compiler automatically selects the predefined integer type whose range is the 
shortest that contains the values L to R inclusive. Note that the SHORT SHORT INTEGER 
representation is never automatically selected by the Compiler 


12 


Alsys IBM Ada Compiler. Appendix Ffor AIX, vS.3 





Encoding of integer values 

Binary code is used to represent integer values, using a conventional two’s complement 
representation. 


Integer subtypes 

Minimum size: The minimum s ze of an integer subtype is the minimum number of bits 
that is necessary for representing the internal codes of the subtype values in normal binary 
form (that is to say, in an unbiased form which includes a sign bit only if the range of the 
subtype includes negative values). 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M are 
the lower and upper bounds of the subtype, then its minimum size L is determined as 
follows. For m > = 0, L is the smallest positive integer such that M < = 2t -1. For m < 
0, L is the smallest positive integer such that -2L l < = m and M < = 2L1-1. 

For example; 

subtype S is l.NTEGER range 0 .. 7; 

-- The minimum size of S is 3 bits. 

subtype D is S range X .. Y; 

- Assuming that X and Y are not static, the minimum size of 

-- D is 3 bits (the same as the minimum size of the static type mark S). 

Size: The sizes of the predefined integer types SHORT SHORT IVTEGER, SHORTJNTEGER 
and I.vteger are respectively 8,16 and 32 bits. 

When no size specification is applied to an integer type or to its first named subtype (if 
any), its size and the size of any of its subtypes is the size of the predefined type from 
which it derives, directly or indirectly. 

For example: 

type S is range 80 .. 100; 

-- S is derived from SHORT INTEGER, its size is 16 bits. 

type J is range 0 .. 65535; 

— J is derived from INTEGER, its size is 32 bits. 


Appendix F, Implementation-Dependent Characteristics 


13 






type N is new J range 80 .. 100; 

'• N is indirectly derived from INTEGER, its size is 32 bits. 

When a size specification is applied to an integer type, this integer type and each of its 
subtypes has the size specified by the length clause. The same rule applies to a first named 
subtype. The size specification must of course specify a value greater than or equal to the 
minimum size of the type or subtype to which it applies. 

For example: 

type S is range 80 .. 100; 
for S’StZE use 32; 

-- S is derived from SHORT I.ntEGER, but its size is 32 bits 
-- because of the size specification. 

type J is range 0 .. 255; 
for TSIZE use 8; 

- J is derived from SHORTJNTEGER, but its size is 8 bits because 

- of the size specification. 

type N is new J range 80 .. 100; 

- N is indirectly derived from SHORTJNTEGER, but its size is 8 bits 
-- because N inherits the size specification of J. 

The Alsys Compiler implements size specifications. Nevertheless, as integers are 
implemented using machine integers, the specified length cannot be greater than 32 bits. 

Object size: Provided its size is not constrained by a record component clause or a 
pragma PACK, an object of an integer subtype has the same size as its subtype. 

Alignment: An integer subtype is byte aligned if the size of the subtype is less than or 
equal to 8 bits, halfword aligned if the size of the subtype is less than or equal to 16 bits 
and word aligned otherwise. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of an integer subtype is a multiple of 
the alignment of the corresponding subtype. 


14 


Alsys IBM 390 Ada Compiler, Appendix F forAIX, vS.3 




4 J Floating Point Types 

Predefined floating point types 

There are three predefined floating point types in the Alsys implementation for IBM 390 
machines: 

type SHORT FLOAT is 

digits 6 range -2.0**252*{l.O-2.0**-24) .. 2.0**252'(1.0-2.0*’-24); 
type FLOAT is 

digits 15 range -2.0**252*(1.0-2.0**-56) .. 2.0**252*(1.0-2,0’*-56); 
type LONG FLOAT is 

digits 18 range -2.0**252*(1.0-2.0**-112).. 2.0**252*(1.0-2.0**-112); 


Selection of the parent of a floating point type 

A floating point type declared by a declaration of the form: 
type T is digits D [range L .. R|; 

is implicitly derived from a predefined floating point type. The Compiler automatically 
selects the smallest predefined floating point type whose number of digits is greater than 
or equal to D and which contains the values L and R. 


Encoding of floating point values 

In the program generated by the Compiler, floating point values are represented using the 
IBM 390 data formats for single precision, double precision and extended precision 
floating point values as appropriate. 

Values of the predefined type SHORT_float are represented using the sintrle precision 
format, values of the predefined type float are represented using the douuie precision 
format and values of the predefined type LONG FLOAT are represented using the extended 
precision format. The values of any other floating point type are represented in the same 
way as the values of the predefined type from which it derives, directly or indirectly. 


Appendix F, Implementation-Dependent Characteristics 


15 




Floating point subtypes 

Minimum size: The minimum size of a floating point subtype is 32 bits if its base type is 
SHORT FLOAT or a type derived from SHORT FLOAT, 64 bits if its base type is FLOAT or a 
type derived from FLOAT and 128 bits if its base type is LONG FLOAT or a ’.ype derived 
from LONG FLOAT. 

Size: The sizes of the predefined floating point types SHOftT_ float, float and 
LONG FLOAT are respectively 32, 64 and 128 bits. 

The size of a floating point type and the size of any of its subtypes is the size of the 
predefined type from which it derives directly or indirectly. 

The only size that can be specified for a floating point type or first named subtype using a 
size specification is its usual size (32, 64 or 128 bits). 

Object size: An object of a floating point subtype has the same size as its subtype. 

Alignment: A floating point subtype is word aligned if its size is 32 bits and double word 
aligned otherwise. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of a floating point subtype is a 
multiple of the alignment of the corresponding subtype. 


4.4 Fixed Point Types 

Small of a fixed point type 

If no specification of small applies to a fixed point type, then the value of small is 
determined by the value of delta as defined by [3.5.9). 

A specification of small can be used to impose a value of small. The value of small is 
required to be a power of two. 


16 


A/sys IBM 390 Ada Compiler, Appendix F forAIX, vS.3 





Predefined fixed point types 

To implement fixed point types, the Alsys Compiler for IBM 390 machines uses a set of 
anonymous predefined types of the form; 

type nxED is delta D range (-2”15)*S .. (2”15-1)*S; 
for nxED’SMALL use S; 

type LONG FtXED is delta D range (-2**31)*S .. (2**31-1)’S; 
for LONG nXED'SMALL use S; 

where D is any real value and S any power of two less than or equal to D. 


Selection of the parent of a Fixed point type 

A fixed point type declared by a declaration of the form: 

type T is delta D range L .. R; 
possibly with a small specification; 
for TSMALL use S; 

is implicitly derived from a predefined fixed point type. The Compiler automatically 
selects the predefined fixed point type whose small and delta are the same as the small 
and delta of T and whose range is the shortest that includes the values L and R. 


Encoding of fixed point values 

In the program generated by the Compiler, a safe value V of a fixed point subtype F is 
represented as the integer: 

V / FBASE’SMALL 

Fixed point subtypes 

Minimum size: The minimum size of a fixed point subtype is the minimum number of 
binary digits that is necessary for representing the values of the range of the subtype using 
the small of the base type (that is to say, in an unbiased form which includes a sign bit only 
if the range of the subtype includes negative values). 


Appendix F, Implementation-Dependent Characteristics 


17 




For a static subtype, if it has a null range its minimum size is I. Otherwise, s and S being 
the bounds of the subtype, if i and I are the integer representations of m and M, the 
smallest and the greatest model numbers of the base type such that s < m and M < S, 
then the minimum size L is determined as follows. For i > = 0, L is the smallest positive 
integer such that I < = 21-1. For i < 0, L is the smallest positive integer such that - 
2L-1 < = i and I < = 21--1-1. 

For example: 

type F is delta 2.0 range 0.0 .. 500.0; 

— The minimum size of F is 8 bits. 

subtype S is F delta 16.0 range 0.0 .. 2S0.0; 

— The minimum size of S is 7 bits. 

subtype D is S range X .. Y; 

-- Assuming that X and Y are not static, the minimum size of D is 7 bits 
-- (the same as the minimum size of its type mark S). 

Size: The sizes of the sets of predefined fixed point types FI.XED and long FIXED are 16 
and 32 bits respectively. 

When no size specification is applied to a fixed point type or lo its first named subtype, its 
size and the size of any of its subtypes is the size of the predefined type from which it 
derives directly or indirectly. 

For example; 

type F is delta 0.01 range 0.0 .. 2.0; 

" F is derived from a 16 bit predefined fixed type, its size is 16 bits, 
type L is delta 0.01 range 0.0 .. 300.0; 

-- L is derived from a 32 bit predefined fixed type, its size is 32 bits, 
type N is new L range 0.0 .. 2.0; 

- N is indirectly derived from a 32 bit predefined fixed type, its size is 32 bits. 

When a size specification is applied to a fixed point type, this fixed point type and each of 
its subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or equal 
to the m inimum size of the type or subtype to which it applies. 


18 


Alsys IBM 390 Ada Compiler, Appendix FforAJX, v5.J 



For example: 

type F is delta 0.01 range 0,0 .. 2.0; 
for FSIZE use 32; 

-- F is derived from a 16 bit predefined fixed type, but its size is 32 bits 
-- because of the size specification. 

type L is delta 0.01 range 0.0 .. 300.0; 
for FSIZE use 16; 

— F is derived from a 32 bit predefined fixed type, but its size is 16 bits 

— because of the size specification. 

-- The size specification is legal since the range contains no negative values 

— and therefore no sign bit is required. 

type N is new F range 0.8 .. 1.0; 

— N is indirectly derived from a 16 bit predefined fixed type, but its size is 
-- 32 bits because N inherits the size specification of F. 

The Alsys Compiler implements size specifications. Nevertheless, as fixed point objects 
are represented using machine integers, the specified length cannot be greater than 32 
bits. 

Object size: Provided its size is not constrained by a record component clause or a 
pragma PACK, an object of a fixed point type has the same size as its subtype. 

Alignment: A fixed point subtype is byte aligned if its size is less than or equal to 8 bits, 
halfword aligned if the size of the subtype is less than or equal to 16 bits and word aligned 
otherwise. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma pack, the address of an object of a fixed point subtype is a multiple of 
the alignment of the corresponding subtype. 


4.5 Access Types 
Collection Size 

When no specification of collection size applies to an access type, no storage space is 
reserved for its collection, and the value of the attribute STORaGE SIZE is then 0. 


Appendix F, Implementation-Dependent Characteristics 


19 



As described in [13.2], a specification of collection size can be provided in order to reserve 
storage space for the collection of an access type. The Alsys Compiler fully implements 
this kind of specification. 

Encoding of access values 

Access values are machine addresses represented as 32 bit values. The implementation 
uses the top (most significant) bit of such a 32 bit value to pass additional information to 
the Ada Run-Time Executive. 


Access subtypes 

Minimum size: The minimum size of an access subtype is 32 bits. 

Size: The size of an access subtype is 32 bits, the same as its minimum size. 

The only size that can be specified for an access type using a size specification is its usual 
size (32 bits). 

Object size: An object of an access subtype has the same size as its subtype, thus an 
object of an access subtype is always 32 bits long. 

Alignment: An access subtype is always word aligned. 

Object address: Provided its alignment is not constrained by a record representation 
clause or a pragma PACK, the address of an object of an access subtype is always on a 
word boundary, sbcc its subtype is word aligned. 


4.6 Task Types 

Storage for a task activation 

When no length clause is used to specify the storage space to be reserved for a task 
activation, the storage space indicated at bind time is used for this activation. 

As described in (13.2), a length clause can be used to specify the storage space for the 
activation of each of the tasks of a given type. In this case the value indicated at bind time 
is ignored for this task type, and the length clause is obeyed. 


20 


Alsys IBM 390 Ada Compiler, Appendix F forAlX, v5.3 


It is not allowed to apply such a length clause to a derived type. The same storage space is 
reserved for the activation of a task of a derived type as for the activation of a task of the 
parent type. 


Encoding of task values 

Task values are machine addresses. 


Task subtypes 

Minimum size: The minimum size of a task subtype is 32 bits. 

Size: The size of a task subtype is 32 bits, the same as its minimum size. 

The only size that can be specified for a task type using a size specification is its usual size 
(32 bits). 

Object size: An object of a task subtype has the same size as its subtype. Thus an object 
of a task subtype is always 32 bits long. 

Alignment: A task subtype is always word aligned. 

Object address: Provided its alignment is not constrained by a record representation 
clause, the address of an object of a task subtype is always on a word boundary, since its 
subtype is word aligned. 


4.7 Array Types 
Layout of an array 

Each array is allocated in a contiguous area of storage units. All the components have the 
same size. A gap may exist between two consecutive components (and after the last one). 
All the gaps have the same size. 









Component Gap Component Gap CoRX>onent Cap 


Appendix F, Implementation-Dependent Characteristics 


21 






Components 

If the array is not packed, the size of the components is the size of the subtype of the 
components. 

For example; 

type A is array (1 .. 8) of BOOLEAN; 

-- The size of the components of A is the size of the type BOOLEAN: 8 bits. 

type DECIMAL DIGIT is range 0 .. 9; 
for DECIMAL DIGITSIZE USe 4; 
type BINARY CODED DECIMAL is 

array (INTEGER range <>) of decimal digit; 

-- The size of the type DECIMal diGIT is 4 bits. Thus in an array of 
-- type BINary coded decimal each component will be represented in 
“ 4 bits as in the usual BCD representation. 

If the array is packed and its components are neither records nor arrays, the size of the 
components is the minimum size of the subtype of the components. 

For example: 

type A is array (1 .. 8) of boolean; 
pragma PACK(A); 

-- The size of the components of A is the minimum size of the type BOOLEAN: 

1 bit. 

type DECIMAL_DIGIT is range 0 ,. 9; 
type BINARY_CODED_DECIMAL is 

array (INTEGER range <>) of DECIMAL DIGIT; 
pragma pack(binary_coded_decimal); 

- The size of the type decimal digit is 16 bits, but, as 

-- BINARY CODED DECIMAL is packed, each component of an array of this 

•• type will be represented in 4 bits as in the usual BCD representation. 

Packing the array has no effect on the size of the components when the components are 
records or arrays. - 


22 


Alsys IBM 390 Ada Compiler, Appendix F for AIX, vS.3 




Gaps 

If the components are records or arrays, no size specification applies to the subtype of the 
components and the array is not packed, then the Compiler may choose a representation 
with a gap alter each component; the aim of the insertion of such gaps is to optimize 
access to the array components and to their subcomponents. The size of the gap is chosen 
so that the relative displacement of consecutive components is a multiple of the alignment 
of the subtype of the components. This strategy allows each component and 
subcomponent to have an address consistent with the alignment of its subtype 

For example: 

type R is 
record 

K : INTEGER; - INTEGER is word aligned. 

B ; BOOLEA.N; -- BOOLEA.N is byte aligned. 

end record; 

- Record type R is word aligned. Its size is 40 bits, 
type A is array (1 .. 10) of R; 

-- A gap of three bytes is inserted after each component in order to respect the 
- alignment of type R. The size of an array of type A will be 640 bits. 



Ccxnponent Gap Coinponent Gap Coinponent Gap 
Array of type A: each subcomponent K has a word offset. 


If a size specification applies to the subtype of the components or if the array is packed, no 
gaps are inserted. 


Appendix F, Implementation-Dependent Characteristics 


23 













or their components are accessed. This information is stored in special components called 
implicit components. 

An implicit component may contain information which is used when the record object or 
several of its components are accessed. In this case the component will be included in any 
record object (the implicit component is considered to be declared before any variant part 
in the record type declaration). There can be two components of this kind; one is called 
RECORD_siZE and the other variantjndex. 

On the other hand an implicit component may be used to access a given record 
component. In this case the implicit component exists whenever the record component 
exists (the implicit component is considered to be declared at the same place as the record 
component). Components of this kind are called array DESCRtPTORs or 
RECORD_DESCRlPTORs. 

RECORD SIZE 

This implicit component is created by the Compiler when the record type has a variant 
part and its discriminants are defaulted. It contains the size of the storage space necessary 
to store the current value of the record object (note that the storage effectively allocated 
for the record object may be more than this). 

The value of a RECORD SIZE component may denote a number of bits or a number of 
storage units. In general it denotes a number of storage units, but if any component clause 
specifies that a component of the record type has an offset or a size which cannot be 
expressed using storage units, then the value designates a number of bits. 

The implicit component RECORd size must be large enough to store the maximum size of 
any value of the record type. The Compiler evaluates an upper bound MS of this size and 
then considers the implicit component as having an anonymous integer type whose range 
is 0.. MS. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementatior generated name R RECOrd size. 

variantjndex 

This implicit component is creafed by the Compiler when the record type has a variant 
part. It indicates the set of components that are present in a record value. It is used when 
a discriminant check is to be done. 

Component lists that do not contain a variant part are numbered. These numbers are the 
possible values of the implicit component variantjndex. 


32 


Alsys IBM 390 Ada Compiler, Appendix FforAlX, v5.3 



For example: 


type VEHICLE is (AIRCRAFT, ROCKET, BOAT, CAR); 

type DESCRIPTION (KIND : VEHICLE := CAR) is 

record 

SPEED : INTEGER; 
case KIND is 

when AIRCRAFT | CAR = > 

WHEELS : INTEGER; 
case KIND is 

when AIRCRAFT = > -- 1 

WINGSPAN ; INTEGER; 
when others = > -2 

null; 
end case; 

when BOAT = > - 3 

STEAM : BOOLEAN; 
when ROCKET = > - 4 

STAGES ; INTEGER; 
end case; 
end record; 

The value of the variant index indicates the set of components that are present in a record 
value: 


Variant Index 

Set 

1 

CKIND, SPEED. WHEELS, WINGSPAN) 

2 

(KINO, SPEED, WHEELS) 

3 

CXI NO, SPEED, STEAM) 

4 

{KINO, SPEED, STAGES) 


Appendix F, Implementation-Dependent Characteristics 


33 








A comparison between the variant index of a record value and the bounds of an intervaJ is 
enough to check that a given component is present in the value: 


,---- 1 

CoffpoACnt 

— 

!ni^^val I 

KINO 

t 

► 

SPEED 


WHEELS 

’ • 2 i 

WINCSPAN 

... 1 i 

STEAM 

3 .. 5 ! 

STAGES 

A . . 4 1 


The implicit component varIant indeX must t e large enough to store the number V of 
component lists that don’t contain sariant parts. The Compiler treats this implicit 
component as having an anonymous integer type whose range is 1 . V’. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R V ARl-WT INDEX. 

AJiR4 y_DESCRIPTOR 

An implicit component of this kind is associated by the Compiler with each record 
component whose subtype is an anonymous array subtype that depends on a discriminant 
of the record. It contains information about the component subtype. 

The structure of an implicit component of kind array DESCRJPTOR is not de.scribed in 
this documentation. Nevertheless, if a programmer is interested in specifying the location 
of a component of this kind using a component clause, he can obtain the size of the 
component using the ASSEMBLY parameter in the COMPILE command 

The Compiler treats an implicit component of the kind array DESCRIPU OR as having an 
anonymous record type. If C is the name of the record component whose subtype is 
described by the array descriptor, then this implicit component can be denoted in a 
component clause by the implementation generated name C array DESCRJPTOR 

RECORD DESCRIPTOR 

An implicit component of this kind is associated by the Compiler with each record 
component whose subtype is an anonymous record subtype that depends on a discriminant 
of the record. It contains information about the component subtype. 


34 


Alsys IBM 390 Ada Compiler, Appendix F forAIX, v5..? 




The structure of an implicit component of kind RECORD DESCRJPTOR is not described in 
this documentation. Nevertheless, if a programmer is interested in specifying the location 
of a component of this kind using a component clause, he can obtain the size of the 
component using the ASSEMBLY parameter in the COMPILE command. 

The Compiler treats an implicit component of the kind record DESCRIPTOR as having 
an anonymous record type. If C is the name of the record gomponent whose subtype is 
described by the record descriptor, then this implicit component can be denoted in a 
component clause by the implementation generated name C RECORD DESCRIPTOR. 


Suppression of implicit components 

The Alsys implementation provides the capability of suppressing the implicit components 
RECORD SIZE and/or varLANTJNDE.X from a record type. This can be done using an 
implementation defined pragma called IMPROVE. The syntax of ihis pragma is as follows: 


pragma IMPROVE ( TIME ) SPACE , (ON = >\stinpk’ name ): 


The first argument specifies whether TIME or SP.ACE is the primary criterion for the choice 
of the representation of the record type that is denoted by the second argument. 


Ifn.ME is specified, the Compiler inserts implicit components as described above. If on 
the other hand SPACE is specified, the Compiler only inserts a varja.vt index or a 
RECORD SIZE component if this component appears in a record representation clause that 
applies to the record type. A record representation clause can thus be used to keep one 
implicit component while suppressing the other. 


A pragma improve that applies to a given record type can occur anywhere that a 
representation clause is allowed for this type. 


Record subtypes 

Size: Unless a component clause specifies that a component of a record type has an offset 
or a size which cannot be expressed using storage units, the size of a record subtype is 
rounded up to a whole number of storage units. 

The size of a constrained record subtype is obtained by adding the sizes of its components 
and the sizes of its gaps (if any^ This size is not computed at compile time 

■ when the record : btype has non-static constraints. 


J5 


Appendix F, Implementation-Dependent Characteristics 





■ when a component is an array or a record and its size is not computed at compile 
time. 

The size of an unconstrained record subtype is obtained by adding the sizes of the 
components and the sizes of the gaps (if any) of its largest variant. If the size of a 
component or of a gap cannot be evaluated exactly at compile time, an upper bound of 
this size is used by the Compiler to compute the subtype size. 

The only size that can be specified for a record type or first named subtype using a size 
specification is its usual size. Nevertheless, such a length clause can be useful to verify that 
the layout of a record is as expected by the application. 

Object size: An object of a constrained record subtype has the same size as its subtype. 

An object of an unconstrained record subtype has the same size as its subtype if this size is 
less than or equal to 8 Kbyte. If the size of the subtype is greater than this, the object has 
the size necessary to store its current value; storage space is allocated and released as the 
discriminants of the record change. 

Alignment: When no record representation clause applies to its base type, a record 
subtype has the same alignment as the component with the highest alignment 
requirement. 

When a record representation clause that does not contain an alignment clause applies to 
its base type, a record subtype has the same alignment as the component with the highest 
alignment requirement which has not been overridden by its component clause. 

When a record representation clause that contains an alignment clause applies to its base 
type, a record subtype has an alignment that obeys the alignment clause. 

Object address: Provided its alignment is not constrained by a representation clause, the 
address of an object of a record subtype is a multiple of the alignment of the 
corresponding subtype. 


5 Conventions for Implementation^Generated Names 

Special record components are introduced by the Compiler for certain record type 
definitions. Such record components are implementation-dependent; they arc used by the 
Compiler to improve the quality of the generated code for certain operations on the 
record types. The existence of these components is established by the Compiler 
depending on implementation-dependent criteria. Attributes are defined for referring to 


36 


j4/sys IBM 390 Ada Compiler, Appendix F for AlX, v5.3 





them in record representation clauses. An error message is issued by the Compiler if the 
user refers to an implementation-dependent component that does not exist, if the 
implementation-dependent component exists, the Compiler checks that the storage 
location specified in the component clause is compatible with the treatment of this 
component and the storage locations of other components. An error message is issued if 
this check fails. 

There are four such attributes; 

TRECORD_SIZE For a prefix T that denotes a record type. This attribute 

refers to the record component introduced by the Compiler 
in a record to store the size of the record object. This 
component exists for objects of a record type with defaulted 
discriminants when the sizes of the record objects depend 
on the values of the discriminants. 

TVaRIANTJNDEX For a prefix T that denotes a record type. This attribute 

refers to the record component introduced by the Compiler 
in a record to assist in the efficient implementation of 
discriminant checks. This component exists for objects of a 
record type with variant type. 

CARRAY DESCRIPTOR For a prefix C that denotes a record component of an array 

type whose component subtype definition depends on 
discriminants. This attribute refers to the record 
component introduced by the Compiler in a record to store 
information on subtypes of components that depend on 
discriminants. 

CRECORD DESCRIPTOR For a prefix C that denotes a record component of a record 

type whose component subtype definition depends on 
discriminants. This attribute refers to the record 
component introduced by the Compiler in a record to store 
information on subtypes of components that depend on 
discriminants. 


Appendix F, Implementation-Dependent Characteristics 


37 




6 Address Clauses 

6.1 Address Clauses for Objects 

An address clause can be used to specify an address for an object as described in (13,5). 
When such a clause applies to an object no storage is allocated for it in the program 
generated by the Compiler. The program accesses the object using the address specified in 
the clause. 

An address clause is not allowed for task objects, nor for unconstrained records whose 
maximum possible size is greater than 8 Kbytes. 


62 Address Clauses for Program Units 

Address clauses for program units are not implemented. 


6.3 Address Clauses for Entries 

Address clauses for entries are not implemented. 


7 Restrictions on Unchecked Conversions 

Unconstrained arrays are not allowed as target types. 

Unconstrained record types without defaulted discriminants are not allowed as target 
types. 

If the source and the target types are each scalar or access types, the sizes of the objects of 
the source and target types must be equal. If a composite type is used either as the source 
type or as the target type this restriction on the size does not apply. 

If the source and the target types are each of scalar or access type or if they are both of 
composite type, the effect of the function is to return the operand. 

In other cases the effect of unchecked conversion can be considered as a copy: 

■ if an unchecked conversion is achieved of a scalar or access source type to a 

composite target type, the result of the function is a copy of the source operand: the 
result has the size of the source. 


38 


Alsys IBM 390 Ada Compiler, Appendix FforAlX, v5-3 



• if an unchecked conversion is achieved of a composite source type to a scalar or 
access target type, the result of the function is a copy of the source operand: the 
result has the size of the target. 

8 Input-Output Packages 

The predefined input-output packages SEOt'ENTlALJO (14.2.31, DIRECT to (14.2.5), 

TEXT IO [14.3.10] and lO EXCEPTIONS (14.5) arc implemented as described in the 
Language Reference Manual. 

The package LOW LEVEL IO (14.6), which is concerned with low-level machine-dependent 
input-output, is not implemented. 


8.1 NAME Parameter 

The ,NAME parameter supplied to the Ada procedures CREATE or OPEN (14.2.1) must be a 
siring which defines a legal path name under AIX. 


8.2 FORM Parameter 

The FORM parameter comprises a set of attributes formulated according to the lexical 
rules of (2), separated by commas. The FOR.M parameter may be given as a null strmg 
except when DIRECTJO is instantiated with an unconstrained type; in this case the record 
size attribute must be provided. Attributes are comma-separated; blanks may be inserted 
between lexical elements as desired. In the descriptions below the meanings of natural, 
positive, etc., are as in Ada; attribute keywords (represented in upper case) are identifiers 
[2.3] and as such may be specified without regard to case. 

LSE ERROR is raised if the FORM parameter does not conform to these rules. 

The attributes arc as follows: 

8.2.1 File Protection 

These attributes are only meaningful for a call to the CREATE procedure. 


Appendix F, Implementation-Dependent Characteristics 


39 




File protection involves two independent classifications. The first classification is related 
to who may access the file and is specified by the keywords: 


OWNER Only the owner of the directory may access this file. 

GROUP Only the members of a predefined group of users may access 
this file. 


WORLD Any user may access this file. 

For each type of user who may access a file there i re various access nghis, and this forms 
the basis for the second classification. In general, there are four types of access right, 
specified by the qualifiers: 

READ The user may read from the external file. 

WRITE The user may write to the external file. 

EXECUTE The user may execute programs stored in the external file. 


NONE The user has no access rights to the external file (This access 
right negates any prior privileges.) 

More than one access right may be relevant for a particular file, in which case the 
qualifiers are linked with underscores ( _ ). 

For example, suppose that the world may execute a program in an external file, but only 
the OWNER may modify the file. 


WORLD = > EXECUTE , OWNER = > READ WRITE EXECUTE, 
Repetitior of the same qualifier within the attributes is illegal: 


WORLD = >EXECUTE_EXECUTE. - NOT legal 

but repetition of the entire attribute is allowed: 

WORLD = > EXECUTE, WORLD = > EXECUTE. -- Legal 


40 


Alsys IBM 390 Ada Compiler, Appendix F for AIX, v5.3 




8JJ! File Sharing 

An externa] file can be shared, which means associated simultaneously with several logical 
file objects created by the OPEN and CREATE procedures. 

The file sharing attribute may restrict or suppress this capability by specifying one of the 
following access modes: 

NOTSHARED 

SHARED = > READERS 

SHARED = > SINGLE WRITER 

SHARED = > ANY 

The exception USE ERROR is raised 
file object: 

■ a further OPEN or CREATE specifies a file sharing attribute different from the current 
one 

• a further OPEN, CREATE or RESET violates the conditions imposed by the current file 
sharing attribute. 

The restrictions imposed by the file sharing attribute disappear when the last logical file 
object linked to the external file is closed. 

The file sharing attribute provides control over multiple accesses within the program to a 
given external file. 

This control does not extend to the whole system. 

The default value for the file sharing attribute is SH/%RED = > a.n’Y 

823 File Structure 

Text Files 

There is no FORM parameter to define the structure of text files. 


Exclusive access - no other logical file may be 
associated with the external file 

Only logical files opened with mode IN are 
allowed 

Only logical files opened with mode IN and at 
most one with mode INOUT or OUT are allowed 

.No restriction 

if, for an external file already associated with an Ada 


Appendix F, Implementation-Dependent Characteristics 


41 




A text file consists of a sequence of bytes holding the ascii codes of characters. 

The representation of Ada-terminators depends on the file’s mode (IN or OLT) and 
whether it is associated with a terminal device or a disk file; 

• Disk files 


end of line: 

ASCII.LF 

end of page: 

ASCIl.LF ASCII FE 

end of file: 

ASCII.LF 

Terminal device with 

mode IN 

end of line: 

ASCII LF 

end of page: 

ASCII FF 

end of file: 

ASCII EOT 

Terminal device with 

mode OLT 

end of line: 

ASCII LF 

end of page: 

ASCII.LF ASCII.FF 

end of file: 

ASCII LF .ASCII FF 


Binary Files 

Two FORM attributes, RECORD SIZE and RECORD LMT, control the structure of binary 
files. 

A binary file can be viewed as a sequence (sequential access) or a set (direct access) of 
consecutive RECORDS. 

The structure of such a record is: 

1 HEADER ! OBJECT [ UNUSED_PART | 

and it is formed from up to three items: 

■ an OBJECT with the exact binary representation of the Ada object in the executable 
program, possibly including an object descriptor 

■ a HEADER consisting of two fields (each of 32 bits) : 

- the length of the object, in bytes when the object is a record and in bits when 
the object is an array 


42 


Alsys IBM 390 Ada Compiler, Appendix F forAlX, v5.J 



the length of the descriptor in bytes 


■ an UNUSED PART of variable size to permit full control of the record's size 

The HEADER is implemented only if the actual parameter of the instantiation of the lO 

package is unconstrained. 

The file structure attributes take the form; 

RECORD SIZE = > size_in bytes 
RECORD UNIT = > size_in_bytes 

Their meaning depends on the object’s type (constrained or not) and the file access mode 

(sequential or direct access): 

a) If the object’s type is constrained: 

• The RECORD_UNrr attribute is illegal 

- If the RECORD SIZE attribute is omitted, no UNUSED PaRT will be 
implemented: the default RECORD SIZE is the object’s size 

- If present, the RECORD SIZE attribute must specify a record size greater than or 
equal to the object’s size, otherwise the exception l;se_ERROR will be raised 

b) If the object’s type is unconstrained and the file access mode is direct; 

- The RECORD UNIT attribute is illegal 

- The RECORD SIZE attribute has no default value, and if it is not specified, a 
USE ERROR will be raised 

- An attempt to input or output an object larger than the given RECORD SIZE will 
raise the exception data ERROR 

c) If the object’s type is unconstrained and the file access mode is sequential; 

- The RECORD SIZE attribute is illegal 

- The default value of the RECORD U'NIT attribute is 1 (byte) 

■ The record size will be the smallest multiple of the specified (or default) 

R£C0RD_U'NIT that holds the object and its header. This is the only case where 
records of a file may have different sizes. 


Appendix F, Implementation-Dependent Characteristics 


43 





8^.4 BufTering 

The buffer size can be specified by the attribute 
BtFFER SIZE = > size_in_bytes 

The default value for BUFFER SIZE is 0 (which means no buffering) for terminal devices; it 
is 1 block for disk files. 

8^.5 Appending 

Only to be used with the procedure OPEN, the format of this attribute is simply 
APPEND 

and it means that any output will be placed at the end of the named external file. 

In normal circumstances, when an external file is opened, an index is set which points to 
the beginning of the file. If the APPEND attribute is present for a sequential or for a text 
file, then data transfer will commence at the end of the file. For a direct access file, the 
value of the index i,> set to one more than the number of records in the external file. 

This attribute is not applicable to terminal devices. 

8^.6 Blocking 

This attribute has two alternative forms: 

BLOCKING . 
or 

NON BLOCKING . 

This attribute specifies the lO system behavior desired at any moment that a request for 
data transfer cannot be fulfilled. The stoppage may be due, for example, to the 
unavailability of data, or to the unavailability of the external file device. 

NON_BLOCKING 

If this attribute is set, tl en the task that ordered the data transfer is suspended - 
meaning that other tasks can execute. The suspended task is kept in a ‘ready’ state, 
together with other tasks in a ready state at the same priority level (that is, it is 
rescheduled). 


44 


Alsys IBM 390 Ada Compiler, Appendix F forAlX, v5.3 



When the suspended task is next scheduled, the data transfer request is reactivated. 
If ready, the transfer is activated, otherwise the rescheduling is repeated. Control 
returns to the user program after completion of the data transfer. 

BLOCKING 

In this case the task waits until the data transfer is complete, and all other tasks are 
suspended (or ‘blocked’). The system is busy waitmg-' 

The default for this attribute depends on the actual program; it is BLOCKING for programs 
without task declarations and NON BLOCKING for a program containing tasks. 

8^.7 Terminal Input 

This attribute takes one of two alternative forms: 

TERMtNALJNPUT = > LINES. 

TERMINAL_INPLT = > CHARACTERS. 

Terminal input is normally processed in units of a line at a time, where a line is delimited 
by a special character. A process attempting to read from the terminal as an external Tile 
will be suspended until a complete line has been typed. At that time, the outstanding read 
call (and possibly also later calls) will be satisfied. 

The first option specifies line-at-a-time data transfer, which is the default case. 

The second option means that data transfer is character by character, and so a complete 
line does not have to be entered before the read request can be satisfied. For this option 
the BUFFER SIZE (see section 8.2.4) must be zero. 

The TERMtNALJNPLT attribute is only applicable to terminal devices. 


8.3 STANDARDJNPUT and STANDARD OUTPUT 

The Ada internal files STANDard input and STandard oltput are associated with the 
external streams stdin and stdoul, respectively. By default under AIX the stdin and stdout 
streams are defined to be the terminal, but the user may redefine them by using the lO 
redirection symbols (<, > and >>)■ The < (less than) symbol can be used to take input 
from a file. The > (peater than) symbol can be used to send output to a file, overwritmg 
any ori^al contents. The > > symbol can be used to append output to a file. 


Appendix F, Implementation-Dependent Characteristics 


45 




8.4 USEERROR 

The following conditions will cause USE ERROR to be raised; 

■ Specifying a FORM parameter whose syntax does not conform to the rules given 
above. 

■ Specifying the RECORD SIZE FORM parameter attribute to have a value of zero, or 
failing to specify RECORD SIZE for instantiations of DIRECT IO for unconstrained 
types. 

■ Specifying a RECORD SIZE FORM parameter attribute to have a value less than that 
required to hold the element for instantiations of DiRECT iO and SEQUENTIaljo for 
constrained types. 

■ Violating the file sharing rules stated above. 

■ Errors detected whilst reading or writing (e.g. writing to a file on a read-only disk). 

8.5 Text Terminators 

Line terminators [14.3] are implemented using the ascii nl character OA (hexadecimal) 
and are implied by the end of physical record. 

Page terminators [14.3] are implemented using the ASCli.NP character OC (hexadecimal). 

File terminators [14.3] are implemented using the ASCII EOT character 04 (hexadecimal) 
and are implied by the end of physical file. 

The user should avoid the explicit output of the character ASCII NP |C], as this will not 
cause a page break to be emitted. If the user explicitly outputs the character ASCII.LF, this 
is treated as a call of new line [14.3.4]. 


46 


Alsys IBM 390 Ada Compiler, Appendix F forAIX, v5.3 



9 Characteristics of Numeric Types 


9.1 Integer Types 

The ranges of values for integer types declared in package STANDARD are as follows: 
SHORTSHORTINTEGER -128.127 ' -.2*‘7 2'*7-l 

SHORTJNTEGER -32768 32767 --2*'15 2”1S - 1 

INTEGER -2147483648 , 2147483647 --2 “31 2”31 - 1 

For the packages DIRECT IO and TEXT IO, the ranges of values for types COUNT and 
POSmvE_COUNT are as follows: 

COUNT 0 . 2147483647 - 0 2 “31-1 

POSmVE_COUNT 1 . 2147483647 - 1 . 2 ”31 - 1 

For the package TEXT IO, the range of values for the type HELD is as follows: 

FIELD 0 255 - 0.. 2**8-l 


Appendix F, Impkinentation-Dcpendent Characteristics 



9.2 Floating Point Type Attributes 

SHORT FLOAT 


Approximate 

value 


Dionrs 

6 


MANTISSA 

’1 


EMAX 



EPSILON 

2 0 •• -21) 

9 ME-O"! 

SMALL 

2 0 •• -85 

2 58L-2(. 

LARGE 

2 0 *• S4 ■ (1 0 ■ 2i.> •• -21) 

1 931, . 25 

SAFE_EMAX 

252 


SAFE_SM.ALL 

20 •* -252 

69iL.r" 

SAFEL-XRGE 

2 0 *• 2-2 • (1 0 - 20 •• 21) 

' 241 . '5 

HRST 

■20 •• 252 • (1 0 - 20 •• -24) 

•’ 24f. ♦ "5 

LAST 

2 0 ’• 252 • il 0 2 0 •• .2-1) 

'24i;.25 

machine, RADIX 

U. 


MACHlNE_MANnSSA 

6 


MACHINEEMAX 

f.2 


MACHINE_EMIN 

(A 


MACHINE, ROUNDS 

lALSL 


SiACHINE,OVERFLOWS 

TRUE 


SIZE 

32 



48 


Ats\s IBM 390 Ada Compiler, Appendix F forAJX, v5.3 






FLOAT 


Approiimatt 

value 


DIGITS 

15 


MANTISSA 

51 


EMAX 

204 


EPSILON 

2.0 ••-50 

g8SE-16 

SMALL 

2 0 •• -205 

1 04E-62 

LARGE 

2 0 •• 204 • (1,0-2 0 •• -51) 

2 57E-6! 

SAFE EMAX 

252 


SAFESMALL 

20 •• -253 

6,91E-r? 

SAFELARGE 

2 0 •• 252 • (1 0 - 2 0 •• -51) 

7 24E * 75 

RRST 

-2 0 •• 252 • (1.0 - 20 •• -56) 

-7 24E»75 

LAST 

2 0 •• 252 • (10-20 •• -56) 

7 24E*75 

MACHINE RADIX 

16 


MACHIN'E_MANT!SSA 

14 


MACH1N’E_EMAX 

63 


MACH1NE_FMIN 

-64 


machine_rounds 

FALSE 


MACHINTOVERFLOWS 

TRUE 


SIZE 

64 



Appendix F, Implementation-Dependent Characteristics 


49 




LONG_FLOAT 

Approumaie 

value 


DIGITS 

18 


MANTISSA 

61 


EMAX 

244 


EPSILON 

2 0 ••-60 

867E-19 

SMALL 

2 0 •• -245 

1 77H-74 

large 

20 •• 244 • (1 0 - 20 •• -61) 

2 83E V n 

SAFEEMAX 

252 


SAFE SMALL 

2 0 •• -253 

6‘nE-77 

SAFE large 

20 •• 252 • (1 0- 20 •• -61) 

7 24E-.7S 

FIRST 

•2 0 •• 252 • (1 0 - 2 0 •• -112) 

■■’24E‘'5 

LAST 

20 *• 252 • (10-20 •• -112) 

'24E-75 

MACHINE_RADIX 

16 


MACHIN EMANTISSA 

28 


MACHINE_E.MAX 

63 


MACHINE_EMIN 

-M 


machine_rounds 

FALSE 


machine’overflows 

true 


size 

128 



9.3 Attributes of Type DURATION 


DtRATION'DELTA 2 0 •• -14 

DURATION'SMALL 20--14 

DURATIONUVRGE 131072 0 

DURATlON-nRST -1310720 

DLRAT10NM5T 131071.0 


50 


Alsys IBM 390 Ada Compiler, Appendix F for AIX, v5.3 



10 


Other Implementation-Dependent Characteristics 


10.1 Characteristics of the Heap 

Ail objects created by allocators go into the program heap. Jn addition, portions of the 
Ada Run-Time Executive’s representation of task objects, including the task slacks, are 
allocated in the program heap. 

All objects on the heap belonging to a given collection have their storage reclaimed on exit 
from the innermost block statement, subprogram body or task body that encloses the 
access type declaration associated with the collection. For access types declared at the 
library level, this deallocation occurs only on completion of the main program. 

There is no further automatic storage rcclaimation performed, i.e, in effect, all access 
types are deemed to be controlled (4.8|. The explicit deallocation of the object designated 
by an access value can be achieved by calling an appropriate instantiation of the generic 
procedure ljNCHECKED_DEALLOCAT10N. 

Space for the heap is initially claimed from the system on program start up and additional 
space may be claimed as required when the initial allocation is exhausted. The size of 
both the initial allocation and the size of the individual increments claimed from the 
system may be controlled by the Binder options SIZE and I.SCREMEST. Corresponding 
run-lime options also exist. 

On an extended architecture machine space allocated from the program heap may be 
above or below the 16 megabyte virtual storage line. 


10.2 Characteristics of Tasks 

The default initial task stack size is 16 Kbytes, but by using the Binder option TASK the 
size for all task stacks in a program may be set to any size from 4 Kbytes to 16 Mbytes. A 
corresponding run-time option also exists. 

If a task stack becomes exhausted during execution, it is automatically extended using 
storage claimed from the heap. The task option specifies the minimum size of such an 
extension, i.e. the task stack is extended by the size actually required or by the value of the 
TASK option, whichever is the larger. 


Appendix F, Impiementalion-Dependcnt Characteristics 


51 






