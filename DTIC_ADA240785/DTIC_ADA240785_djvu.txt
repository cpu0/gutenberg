REPORT DOCUMENTATION PAGE 

uf p#f 'ftscionM. inciudmQ lh« am# tof 
CJ [S iwden «iim4ie Of any o«r»*f asp^o o< m« CO 

M ^fson Dave Hignwav Sulla 1204 Anmgion. 


Form Approved 
OPMNo. 0704-0183 


ur par rasponaa. >00100109 tha ama lor ra^aawmg rvtructiooa. taarcorQ aiMng oau aourcaa and mavturwig ina data 

^dan aatimaia of any oinaf aspao ot ms coHactoo of Hofmalion. ncluding uigoastona for raducmg ms burdan to WiafvigKxi 
^rson Oavs Hignaay Suaa i2C4 Arimgion. VA 22202-4302. and to ma Oflica of miorTTvioon and Ragmaiory Aftava. Ofica of 



RT DATE 

3 REPORT TYPE AND DATES COVERED 


Final: 24 Jul 91 to 01 Jun 1993 


4 TITLE AND SUBTITLE 

Ada Compiler Validation Summary Report:DDC International A/S, DACS 
Sun-3/SunOS to 68030 Bare Ada Cross Compiler System, Version 4.6.4, MRI IEEE 
695, Sun-3/50 (Host) to Motorola MVME143 Board (Target), 910502S1.11159 

5 FUNDING NUMBERS 

6. AUTHOR(S) 

National Institute of Standards and Technology 

Gaithersburg, MD 

USA 


7 PERFORMING ORGANIZATION NAME(S) AND ADDRESS(ES) 

National Institute of Standards and Technology 

National Computer Systems Laboratory 

Bldg. 255, Rm A266 

Gaithersburg, MD 20899 USA 

8 PERFORMING ORGANIZATION 

REPORT NUMBER 

NIST90DDC500_11_1.11 

9. SPONSORING/MONITORING AGENCY NAME(S) AND ADDRESS(ES) 

Ada Joint Program Office 

United States Department of Defense 

Pentagon, RM 3E114 

Washington, D C. 20301-3081 

10 SPONSORING/MONITORING AGENCY 
REPORT NUMBER 

11 SUPPLEMENTARY NOTES 

12a DISTRIBUTION/AVAILABILITY STATEMENT 

Approved for public release; distribution unlimited. 

12b DISTRIBUTION CODE 


13 abstract (Maximum 200 words) 

DDC International A/S, DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler System. Version 4.6.4, MRI IEEE 695 
(BASIS_MODE), Gaithersburg, MD, Sun-3/50 running SunOS Release 4.0_Export (Host) to Motorola MVME143 Board 
(68030/68882)(Target), ACVC 1.11. 


fiTir 

5^1 n ^^CTF: s 
SEP 19 W9t! 



91-11052 


14 SUBJECT TERMS 


Ada programming language, Ada Compiler Val. Summary Report. Ada Compiler Val. 
Capability, Val. Testing, Ada Val. Office, Ada Val. Facility, ANSI/MIL-STD-1815A, AJPO. 


17 SECURITY CLASSIFICATION 
Cr hE,'Y;'>'^ 

UNCLASSIFIED 


18 SECURITY CLASSIFICATION 

UNCLASSIFED 


19 SECURITY CLASSIFICATION 
OF ABSTRACT 
UNCLASSIFIED 


15. NUMBER OF PAGES 


16. PRICE CODE 


20 LIMITATION OF ABSTRACT 



NSN 7540-01-280-550 


“ Standard Form 298. (Rev 2-89) 
Prescribed by ANSI Sid. 239-128 































AVF Control Number: NIST90DDC500_11_1.11 
DATE COMPLETED 

BEFORE ON-SITE: 1991-04-22 
AFTER ON-SITE: 1991-05-02 
REVISIONS: 1991-07-24 


Ada COMPILER 
VALIDATION SUMMARY REPORT: 

Certificate Number: 910502S1.11159 
DDC International A/S 

DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler System, 
Version 4.6.4, MRI IEEE 695 (BASIC_MODE) 

Sun-3/50 => Motorola MVME143 Board (68030/68882) 


Prepared By: 

Software Standards Validation Group 
National Computer Systems Laboratory 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, Maryland 20899 





hVF Control Nximber; NIST90DDC500_ll_i. ii 
Certificate Information 


The following Ada implementation was tested and determined to pass 
ACVC 1.11. Testing was completed on May 2, 1991. 


Compiler Name and Version: DACS Sun-3/SunOS to 68030 Bare Ada 

Cross Compiler System, Version 
4.6.4, MRI IEEE 695 (BASIC_MODE) 

Host Computer System; Sun-3/50 running SunOS Release 

4.0_Export 


Target Computer System; Motorola MVME143 Board (68030/68882) 


A more detailed description of this Ada implementation is found in 
section 3.1 of this report. 


As a result of this validation effort. Validation Certificate 
910502S1.11159 is awarded to DDC International A/S. This 
certificate expires on March 01, 1993. 


This report has been reviewed and is approved. 





Engineering Division (ISED) 


Facility 
Mr. L. Amo^ Johnson 
Manager, Software Standards 
Validation Group 


Computer Systems Laboratory (CLS) 
National Institute of Standards and Technology 
Building 225, Room A266 
Gaithersburg, MD 20899 




Director, 


ifibn Organization 
Computer & Software 
Engineering Division 
Institute for Defense Analyses 
Alexandria VA 22311 



Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 





DECLARATION OF CONFORMANCE 


The following declaration of conformance was supplied by the 
customer. 


DECLARATION OF CONFORMANCE 


Customer and Certificate Awardee: DDC International A/S 

Ada Validation Facility; National Institute of Standards and 

Technology 

Computer Systems Laboratory (CSL) 
Software Validation Group 
Building 225, Room A266 
Gaithersburg, Maryland 20899 

ACVC Version: 1.11 

Ada Implementation; 

Compiler Name and Version: 


Host Computer System: 


Target Computer System: 


Declaration: 

I the undersigned, declare that I have no knowledge of deliberate 
deviations from the Ada Language Standard ANSI/MIL-STD-1815A ISO 
8652-1987 in the implementation listed above. 



C\istomer Signature 
‘■Ccr.pany tkiC. International A/S 
Title Project Manager 


DACS Sun-3/SunOS to 68030 Bare Ada 
Cross Compiler System, Version 
4.6.4, MRI IEEE 695 (BASIC_MODE) 

Sun-3/50 running SunOS Release 
4.0_Export 

Motorola MVME143 Board (68030/68882) 


Date 









/ 

TABLE OF CONTENTS 


CHAPTER 1.1-1 

INTRODUCTION . 1-1 

1.1 USE OF THIS VALIDATION SUMMARY REPORT .... 1-1 

1.2 REFERENCES.1-1 

1.3 ACVC TEST CLASSES.1-2 

1.4 DEFINITION OF TERMS.1-3 

CHAPTER 2.2-1 

IMPLEMENTATION DEPENDENCIES . 2-1 

2.1 WITHDRAWN TESTS.2-1 

2.2 INAPPLICABLE TESTS . 2-1 

2.3 TEST MODIFICATIONS.2-4 


CHAPTER 3.3-1 

PROCESSING INFORMATION . 3-1 

3.1 TESTING ENVIRONMENT . 3-1 

3.2 SUTyiMARY OF TEST RESULTS.3-3 

3.3 TEST EXECUTION. 3-3 


APPENDIX A.A-1 

MACRO PARAMETERS.A-1 

APPENDIX B.B-1 

COMPILATION SYSTEM OPTIONS . B-1 

LINKER OPTIONS . B-2 


APPENDIX C . 

APPENDIX F OF THE Ada STANDARD . 


o o 


























CHAPTER 1 


INTRODUCTION 


The Ada implementation described above was tested according to the 
Ada Validation Procedures [Pro90] against the Ada Standard [Ada83] 
using the current Ada Compiler Validation Capability (ACVC). This 
Validation Summary Report (VSR) gives an account of the testing of 
this Ada implementation. For any technical terms used in this 
report, the reader is referred to [Pro90]. A detailed description 
of the ACVC may be found in the current ACVC User's Guide [UG89]. 


1.1 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the 
Ada Certification Body may make full and free public disclosure of 
this report. In the United States, this is provided in accordance 
with the "Freedom of Information Act" (5 U.S.C. #552) . The results 
of this validation apply only to the computers, operating systems, 
and compiler versions identified in this report. 

The organizations represented on the signature page of this report 
do not represent or warrant that all statements set forth in this 
report are accurate and complete, or that the subject 
implementation has no nonconformities to the Ada Standard other 
than those presented. Copies of this report are available to the 
public from the AVF which performed this validation or from: 

National Technical Information Service 
5285 Port Royal Road 
Springfield VA 22161 

Questions regarding this report or the validation test results 
should be directed to the AVF which performed this validation or 
to: 


Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 


1.2 REFERENCES 

[Ada83] Reference Manual for the Ada Programming Language . 

ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 

[Pro90] Ada Compiler Validation Procedures . Version 2.1, Ada Joint 
Program Office, August 1990. 


1-1 






[UG89] Ada Compiler Validation Capability User's Guide . 21 June 
1989. 


1.3 ACVC TEST CLASSES 

Compliance of Ada implementations is tested by means of the ACVC. 
The ACVC contains a collection of test programs structured into six 
tost classes: A, B. C. D, E, and L. The first letter of a test 
name identifies the class to which it belongs. Class A, C, D, and 
E tests are executable. Class B and class L tests are expected to 
produce errors at compile time and link time, respectively. 

The executable tests are written in a self-checking manner and 
produce a PASSED, FAILED, or NOT APPLICABLE message indicating the 
result when they are executed. Three Ada library units, the 
packages REPORT and SPPRT13, and the procedure CHECK_FILE are used 
for this purpose. The package REPORT also provides a set of 
identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The package SPPRT13 is used by many tests for Chapter 13 of the Ada 
Standard. The procedure CHECK_FILE is used to check the contents 
of text files written by some of the Class C tests for Chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is 
checked by a set of executable tests. If these units are not 
operating correctly, validation testing is discontinued. Class B 
tests check that a compiler detects illegal language usage. Class 
B tests are not executable. Each test in this class is compiled 
and the resulting compilation listing is examined to verify that 
all violations of the Ada Standard are detected. Some of the class 
B tests contain legal Ada code which must not be flagged illegal by 
the compiler. This behavior is also verified. 

Class L tests check that an Ada implementation correctly detects 
violation of the Ada Standard involving multiple, separately 
compiled units. Errors are expected at link time, and execution is 
attempted. 

In some tests of the ACVC, certain macro strings have to be 
replaced by implementation-specific values — for example, the 
largest integer. A list of the values used for this implementation 
is provided in Appendix A. In addition to these anticipated test 
modifications, additional changes may be required to remove 
unforeseen conflicts between the tests and implementation-dependent 
characteristics. The modifications required for this 
implementation are described in section 2.3. 

For each Ada implementation, a customized test suite is produced by 
the AVF. This customization consists of making the modifications 
described in the preceding paragraph, removing withdrawn tests (see 
section 2.1) and, possibly some inapplicable tests (see Section 3.2 
and [UG89]). 


1-2 




In order to pass an ACVC an Ada implementation must process each 
test of the^trstomized test suite according to the Ada Standard. 


1.4 DEFINITION OF TERMS 

Ada Compiler The software and any needed hardware that have to 

be added to a given host and target computer 
system to allow transformation of Ada programs 
into executable form and execution thereof. 

The means for testing compliance of Ada 
implementations. Validation consisting of the 
test suite, the support programs, the ACVC 
Capability user's guide and the template for 
the validation summary (ACVC) report. 

Ada An Ada compiler with its host computer system and 

Implementation its target computer system- 

Ada The part of the certification body which carries 

Validation out the procedures required to establish the 

Facility (AVF) compliance of an Ada implementation. 

Ada The part of the certification body that provides 

Validation technical guidance for operations of the Ada 
Organization certification system. 

(AVO) 

Compliance of The ability of the implementation to pass an ACVC 
an Ada version. 

Implementation 

Computer A functional unit, consisting of one or more 

System computers and associated software, that uses 

common storage for all or part of a program and 
also for all or part of the data necessary for 
the execution of the program; executes 
user-written or user-designated programs; performs 
user-designated data manipulation, including 
arithmetic operations and logic operations; and 
that can execute programs that modify themselves 
during execution. A computer system may be a 
stand-alone unit or may consist of several 
inter-connected units. 

Conformity Fulfillment by a product, process or service of 

all requirements specified. 

Customer An individual or corporate entity who enters into 

an agreement with an AVF which specifies the terms 
and conditions for AVF services (of any kind) to 


Ada Compiler 
Validation 
Capability 
(ACVC) 


1-3 







Declaration of 
Conformance 


Host Computer 
System 

Inapplicable 

test 


Operating 

System 


Target 

Computer 

System 

Validated Ada 
Compiler 

Validated Ada 
Implementation 


Validation 


Withdrawn 

test 


be performed. 

A formal statement from a customer assuring that 
conformity is realized or attainable on the Ada 
implementation for which validation status is 
realized. 

A computer system where Ada source programs are 
transformed into executable form. 

A test that contains one or more test objectives 
found to be irrelevant for the given Ada 
implementation. 

Software that controls the execution of programs 
and that provides services such as resource 
allocation, scheduling, input/output control, 
and data management. Usually, operating systems 
are predominantly software, but partial or 
complete hardware implementations are possible. 

A computer system where the executable form of Ada 
programs are executed. 


The compiler of a validated Ada implementation. 


An Ada implementation that has been validated 
successfully either by AVF testing or by 
registration [Pro90]. 

The process of checking the conformity of an Ada 
compiler to the Ada programming language and of 
issuing a certificate for this implementation. 

A test found to be incorrect and not used in 
conformity testing, A test may be incorrect 
because it has an invalid test objective, fails 
to meet its test objective, or contains erroneous 
or illegal use of the Ada programming language. 


1-4 






CHAPTER 2 


IMPLEMENTATION DEPENDENCIES 


2.1 WITHDRAWN TESTS 

Some tests are withdrawn by the AVO from the ACVC because they do 
not conform to the Ada Standard. The following 93 tests had been 
withdrawn by the Ada Validation Organization (AVO) at the time of 
validation testing. The rationale for withdrawing each test is 
available from either the AVO or the AVF. The publication date for 
this list of withdrawn tests is 91-03-14. 


E28005C 
C35508N 
C45346A 
B49008A 
B83025D 
C94021A 
CB7004A 
BD1B06A 
CD2A4lA 
CD4022A 
CD4051D 
CD7006E 
BD8004C 
CE2117B 
CE3118A 
CE3812A 


B28006C 

C35702A 

C45612A 

A74006A 

B83026B 

C97116A 

CC1223A 

AD1B08A 

CD2A41E 

CD4022D 

CD5111A 

AD7201A 

CD9005A 

CE2119B 

CE3411B 

CE3814A 


C34006D 

C35702B 

C45612B 

C74308A 

C83026A 

C98003B 

BC1226A 

BD2A02A 

CD2A87A 

CD4024B 

CD7004C 

AD7201E 

CD9005B 

CE2205B 

CE3412B 

CE3902B 


C35508I 

B41308B 

C45612C 

B83022B 

C83041A 

BA2011A 

CC1226B 

CD2A21E 

CD2B15C 

CD4024C 

ED7005D 

CD7204B 

CDA201E 

CE2405A 

CE3607B 


C35508J 

C43004A 

C45651A 

B83022H 

B85001L 

CB7001A 

BC3009B 

CD2A23E 

BD3006A 

CD4024D 

.CD7005E 

AD7206A 

CE2107I 

CE3111C 

CE3607C 


C35508M 

C45114A 

C46022A 

B83025B 

C86001F 

CB7001B 

BD1B02B 

CD2A32A 

BD4008A 

CD4031A 

AD7006A 

BD8002A 

CE2117A 

CE3116A 

CE3607D 


2.2 INAPPLICABLE TESTS 


A test is inapplicable if it contains test objectives which are 
irrelevant for a given Ada implementation. The inapplicability 
criteria for some tests are explained in documents issued by ISO 
and the AJPO known as Ada Issues and commonly referenced in the 
format Al-dddd. For this implementation, the following tests were 
inapplicable for the reasons indicated; references to Ada Issues 
are included as appropriate. 


The following 201 tests have floating-point type declarations 
requiring more digits than SYSTEM.MAX_DIGITS: 


C24113L..Y (14 tests) 
C35706L..Y (14 tests) 
C35708L..Y (14 tests) 
C45241L..Y (14 tests) 


C35705L..Y 
C35707L..Y 
C35802L..Z 
C45321L..Y 


(14 tests) 
(14 tests) 
(15 tests) 
(14 tests) 


2-1 






C4b^lL. . Y (14 tests) 
C4552?L..Z (15 tests) 
C45641L..Y (14 tests) 


C45521L..Z f15 tests) 
C45621L..Z (15 tests) 
C46012L..Z (15 tests) 


C24113I..K (3 TESTS) USE A LINE LENGTH IN THE INPUT FILE WHICH 
EXCEEDS 126 CHARACTERS. 


THE FOLLOWING 20 TESTS CHECK FOR THE PREDEFINED TYPE 
LONG INTEGER: 


C35404C 

C45502C 

C45613C 

C55B07A 


C45231C 

C45503C 

C45614C 

B55B09C 


C45304C 

C45504C 

C45631C 

B86001W 


C45411C 

C45504F 

C45632C 

C86006C 


C45412C 

C45611C 

B52004D 

CD7101F 


C35404D, C45231D, B86001X, C86006E, AND CD7101G CHECK FOR A 

PREDEFINED INTEGER TYPE WITH A NAME OTHER THAN INTEGER, 
LONG INTEGER, OR SHORT INTEGER 


C35713B, C45423B, B86001T, AND C86006H CHECK FOR THE PREDEFINED 
TYPE SHORT FLOAT. 


C35713D AND B86001Z CHECK FOR A PREDEFINED FLOATING-POINT TYPE 
WITH A NAME OTHER THAN FLOAT, LONG_FLOAT, OR SHORT_FLOAT. 

C45531M, C45531N, C455310, C45531P, C45532M, C45532N, C455320, 

AND C45532P CHECK FIXED-POINT OPERATIONS FOR TYPES THAT REQUIRE 
A SYSTEM.MAX_MANTISSA OF 47 OR GREATER. 

C45624A AND C45624B CHECK THAT THE PROPER EXCEPTION IS RAISED IF 
MACHINE_OVERFLOVfS IS FALSE FOR FLOATING-POINT TYPES; FOR THIS 
IMPLEMENTATION, MACHINE_OVERFLOWS IS TRUE. 

C4A013B CONTAINS THE EVALUATION OF AN EXPRESSION INVOLVING 
■MACHINE_RADIX APPLIED TO THE MOST PRECISE FLOATING-POINT TYPE. 
THIS EXPRESSIQN WOULD RAISE AN EXCEPTION. SINCE THE EXPRESSION 
MUST BE STATIC, IT IS REJECTED AT COMPILE TIXE. 


B86001Y CHECKS FOR A PREDEFINED FIXED-POINT TYPE OTHER THAN 
DURATION. 


C96005B CHECKS FOR VALUES OF TYPE DURATION'BASE THAT ARE OUTSIDE 
THE RANGE OF DURATION. THERE ARE NO SUCH VALUES FOR THIS 
IMPLEMENTATION. 


CA2009C AND CA2009F CHECK WHETHER A GENERIC UNIT CAN BE 
INSTANTIATED BEFORE ITS BODY (AND ANY OF ITS SUBUNITS) IS 
COMPILED; THIS IMPLEMENTATION CREATES A DEPENDENCE ON GENERIC 
UNITS AS ALLOWED BY AI-00408 AND AI-00506 SUCH THAT THE 
COMPILATION OF THE GENERIC UNIT BODIES MAKES THE INSTANTIATING 
UNITS OBSOLETE. (SEE SECTION 2.3.) 


2-2 







CD1009C A REPRESENTATION CLAUSE SPECIFYING A NON-DEFAULT 

SIZE FOR A FLOATING-POINT TYPE. 


CD2A84A, CD2A84E, CD2A84I..J (2 TESTS), AND CD2A840 USE 
REPRESENTATION CLAUSES SPECIFYING NON-DEFAULT SIZES FOR ACCESS 
TYPES. 

THE FOLLOWING 264 TESTS CHECK FOR SEQUENTIAL, TEXT, AND DIRECT 
ACCESS FILES: 


CE2102A..C (3) 
CL2103C..D (2) 
CE2107A..H (8) 
CE2110A..D (4) 
CE2120A..B (2) 
CE2203A 
CE2208B 
EE2401G 
CE2405B 
CE2409A..B (2) 
CE3102F..H (3) 
CE3106A..3 (2) 
CE3110A 
CE3114A..B (2) 
EE3203A 
CE3301A 
CE3305A 
CE3402C..D (2) 
CE3405A 
CE3407A..C (3) 
EE3409F 
CE3411A 
CE3413A..C (3) 
CE3604A..B (2) 
CE3704A..F (6) 
CE3706F..G (2) 
CE3306D..E (2) 
CE3905L 


CE2102G. 

.H 

(2) 

CE2104A. 

. D 

(4) 

CE2107L 

CE2111A. 

. I 

(9. 

CE2201A. 

n 

(3) 

CE2204A. 

.D 

(4) 

CE2401A. 

.C 

(3) 

CE2401H. 

. L 

(5) 

CE2406A 

CE2410A. 

. 3 

(2) 

CE3102J. 

.K 

(2) 

CE3107B 

CE3111A. 

.B 

(2) 

CE3115A 

EE3204A 

EE3301B 

CE3401A 

CE3403A. 

.C 

(3) 

EE3405B 

CE3408A. 

.C 

(3) 

CE3410A 

CE3411C 

CE3414A 

CE3605A. 

.E 

(5) 

CE3704M. 

.0 

(3) 

CE3804A. 

.P 

(16) 

CE3806G. 

.H 

(2) 

CE3906A. 

.C 

(3) 


CE2102K 
CE2105A..B (2) 
CE2108A..H (i) 
CE2115A..B (2) 
EE2201D..E <2) 
CE2205A 
EE2401D 
CE2403A 
CE24n7A..B(2) 
CE2411A 
CE3103A 
CE3108A..B (2) 
CE3illD..E (2) 
CE3119A 
CE3207A 
CE3302A 
CE3402A 
CE3403E..F (2) 
CE3405C..D (2) 
CE3409A 
CE3410C..E (3) 
CE3412A 
CE3602A..D (4) 
CE3606A..B (2) 
CE3705A..E (5) 
CE3805A..B (2) 
CE3904A..B (2) 
CE3906E..F (2) 


CL'2102N. 

_ v 

(12) 

CE21D6A. 

. B 

(2) 

CE2i09A, 

. C 

(3) 

CE2201F. 

.N 

(9) 

CE2206A 



CE2401E. 

. F 

(2) 

CE2404A. 

. B 

(2) 

CE2408A. 

, B 

(2) 

CE3102A. 

.C 

(3) 

CE3104A. 

. C 

(3) 

CE3109A 



CE3112A. 

. D 

(4) 

CE3208A 



CE3304A 



EE3402B 



CE3404B. 

.D 

(3) 

CE3406A. 

. D 

(4) 

CE3409C. 

.E 

(3) 

EE3410F 



ES3412C 



CE3603A 



CE3706D 



CE3806A. 

.B 

(2) 

CE3905A. 

. C 

(3) 


CE2103A..B AND CE3107A EXPECT THAT NAME_ERROR IS RAISED WHEN AN 
ATTEMPT IS MADE TO CREATE A FILE WITH AN ILLEGAL NAME; THIS 
IMPLEMENTATION DOES NOT SUPPORT THE CREATION OF EXTERNAL FILES 
AND SO RAISES USE_ERROR. (See section 2,2.) 


2.3 TEST MODIFICATIONS 

Modifications (see section 1.3) were required for 70 tests. 


2-3 






The following tests were split into two or more tests because this 
implementat«m-did not report the violations of the Ada Standard in 
the way expected by the original tests. 


B22003A 

B26001A 

B26002A 

B26005A 

B28003A 

B29001A 

B33301B 

B35101A 

B37106A 

B37301B 

B37302A 

B38003A 

B38003B 

B38009A 

B38009B 

B55A01A 

B61001C 

B61001F 

B61001H 

B61001I 

B61001M 

B61001R 

B61001W 

B67001H 

B83A07A 

B83A07B 

B83A07C 

B83E01C 

B83E01D 

B83E01E 

B85001D 

B85008D 

B91001A 

B91002A 

B91002B 

B91002C 

B91002D 

B91002E 

B91002F 

B91002G 

B91002H 

B91002I 

B91002J 

B91002K 

B91002L 

B95030A 

B95061A 

B95061F 

B95061G 

B95077A 

B97103E 

B97104G 

BAIOOIA 

BAllOlB 

BC1109A 

BC1109C 

BC1109D 

BC1202A 

BC1202F 

BC1202G 

BE2210A 

BE2413A 



"PRAGMA ELABORATE (REPORT)" has been added at appropriate points in 
order to solve the elaboration problems for; 

C83030C C86007A 


BC3204C and BC3205D were graded passed by Processing Modification 
as directed by the AVO. These tests check that instantiations of 
generic units with unconstrained types as generic actual parameters 
are illegal if the generic bodies contain uses of the types that 
require a constraint. However, the generic bodies are compiled 
after the units that contain the instantiations, and this 
implementation creates a dependence of the instantiating units on 
the generic units as allowed by AI-00408 and AI-00506 such that the 
compilation of the generic bodies makes the instantiating units 
obsolete—no errors are detected. The processing of these tests 
was modified by re-compiling the obsolete units; all intended 
errors were then detected by the compiler. 


The value used to specify the collection size has been increased 
from 256 to 324 take alignment into account for; 

CD2A83A 

CE2103A..B and CE3107A abort with an unhandled exception when 
USE_ERROR is raised on the attempt to create an external file (see 
2.2). The AVO ruled that these tests are to be graded as 
inapplicable. 


2-4 






CHAPTER 3 


PROCESSING INFORMATION 


3.1 TESTING ENVIRONMENT 

The executable files were prepared on the Sun-3/50 host computer. 
The target linker used was developed by Microtech Research Inc. 
and is called "Inkesk". The linker produces an S-record format 
module that prior to being loaded is packed by a DDC-I developed 
tool. The executables were transferred via an RS232 serial line 
from the Sun-3/50 (host) to the Motorola MVME143 Board 
(68030/68882) (target); this RS232 line is used by a downloader 
on the host for communication with the monitor on the target. The 
serial RS232 line is also used for communication between the Ada 
program running on the target board for TEXT_IO communication 
with the downloader on the host which captures the output. 

The DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler System, 
Version 4.6.4, MRI IEEE 695 (BASIC_MODE) was executed on the 
target board with the following: 

Motorola MVME143 Board (68030/68882) 

One internal timer 
One serial port 
4MB RAM 

For each category, a command file was generated that loaded and 
executed every program. 

For a point of contact for technical information about this Ada 
implementation system, see; 

In th« U.S.A.: 


Mr. Larry Price 
DDC-I, Inc. 

9630 North 25th Avenue 
Suite #118 

Phoenix, Arizona 85021 

Mailing address: 

P.O. Box 37767 
Phoenix, Arizona 85069-7767 
Telephone: 602-944-1883 

Telefax: 602-944-3253 

In the rest of the world: 


3-1 







Mr. Svend Bodilsen 
DDC International A/S 
Gl. Lundtoftevej IB 
DK-2800 Lyngby 
DENMARK 

Telephone: + 45 45 87 11 44 
Telefax: + 45 45 87 22 17 

For a point of contact for sales information about this Ada 
implementation system, see: 

In the U.S.A.: 


Mr. Mike Turner 
DDC-I, Inc. 

9630 North 25th Avenue 
Suite #118 

Phoenix, Arizona 85021 

Mailing address: 

P.O. Box 37767 
Phoenix, Arizona 85069-7767 
Telephone: 602-944-1883 

Telefax; 602-944-3253 

In the rest of the world: 

Mr. Palle Andersson 
DDC International A/S 
Gl. Lundtoftevej IB 
DK-2800 LYNGBY 
Denmark 

Telephone: + 45 45 87 11 44 
Telefax: + 45 45 87 22 17 

Testing of this Ada implementation was conducted at the 
customer's site by a validation team from the AVF. 


3.2 SUMMARY OF TEST RESULTS 

An Ada Implementation passes a given ACVC version if it processes 
each test of the customized test suite in accordance with the Ada 
Programming Language Standard, whether the test is applicable or 
inapplicable; otherwise, the Ada Implementation fails the ACVC 
[Pro90]. 







For all processed tests (inapplicable and applicable), a result 
was obtain^?r“^hat conforms to the Ada Programming Language 
Standard. 



a) 

Total Number of Applicable Tests 

3554 



b) 

Total Number of Withdrawn Tests 

93 



c) 

Processed Inapplicable Tests 

523 



d) 

Non-Processed I/O Tests 

0 



e) 

Non-Processed Floating-Point 





Precision Tests 

0 



f) 

Total Number of Inapplicable Tests 

523 

(c+d+e) 


g) 

Total Number of Tests for ACVC 1.11 

4170 

(a+b+f) 

3 TEST 

EXECUTION 



Version 

1. 

11 of the ACVC comprises 4170 tests. 

When this 


compiler was tested, the tests listed in section 2.1 had been 
withdrawn because of test errors. The AVF determined that 523 
tests were inapplicable to this implementation. All inapplicable 
tests were processed during validation testing. In addition, the 
modified tests mentioned in section 2.3 were also processed. 

A magnetic tape containing the customized test suite (see section 
1.3) was taken on-site by the validation team for processing. 
The tests were compiled and linked on the host computer system, 
as appropriate. The executable images were transferred to the 
target computer system by the communications link described 
above, and run. The results were captured on the host computer 
system using the communications link described above. 

Testing was performed using command scripts provided by the 
customer and reviewed by the validation team. See Appendix B for 
a complete listing of the processing options for this 
implementation. It also indicates the default options. The 
options invoked explicitly for validation testing during this 
test were: 

-L -a <library> 

There were NO compiler options invoked by default for validation 
testing during this test. 

The specific linker options invoked for the BASIC_MODE were: 

-m stack_size=200000 
-t 30 

-u ../dacs/Ada_UCC.slb 


3-3 





-a acvc.alb 


Test output, compiler and linker listings, and job logs were 
captured on magnetic tape and archived at the AVF. Selected 
listings examined on-site by the validation team were also 
archived. 


3-4 








APPENDIX A 


MACRO PARAMETERS 


This appendix contains the macro parameters used for customizing 
the ACVC. The meaning and purpose of these parameters are 
explained in [UG89]. The parameter values are presented in two 
tables. The first table lists the values that are defined in 
terms of the maximum input-line length, which is 126 the value 
for $MAX_IN_LEN—also listed here. These values are expressed 
here as Ada string aggregates, where "V” represents the maximum 
input-line length. 

Macro Parameter Macro Value 


$MAX_IN_LEN 



126 



$BIG_ID1 

(1..V-1 

=> 

'A\ 

rH 

A 

II 

> 


$BIG_ID2 

(1..V-1 

=> 

'A\ 

V => '2') 


$BIG_ID3 

(1..V/2 

=> 

'A') 

& '3' & (1..V-l-V/2 => 

'A') 

$BIG_ID4 

(1..V/2 

=> 

'A') 

& '4' & (1. .V-l-V/2 => 

'A') 

$BIG_INT_LIT 

(1..V-3 

=> 

'0') 

& "298" 


$BIG_REAL_LIT 

(1..V-5 

=> 

'0') 

& "690.0" 


$BIG_STRING1 

& (1 

. .V/2 = 

> 'A') & 


$BIG_STRING2 

& (1 

. .V 

-l-V/2 => 'A') & '1' & 


$BLANKS 

(1..V-20 

=> 

/ / 

) 


$MAX LEN INT BASED 

LITERAL 






"2:" & (1..V-5 => '0') & "11:" 

$MAX_LEN_REAL_BAS E D_LITERAL 

"16;" & (1..V-7 => '0') & "F.E:" 

$MAX_STRING_LITERAL & (1..V-2 => "A') & 


A-1 








The following table contains the values for the remaining macro 
paramet^r^ 

Macro Parameter Macro Value 


ACC_SIZE 

ALIGNMENT 

COUNT_LAST 

DEFAULT_MEM_SIZ Z 

DEFAULT_STOR_UNIT 

DEFAULT_ * S_NAME 

DELTA_DOC 

ENTRY_ADDRESS 

ENTRY_ADDRESS1 

ENTRY_ADDRESS2 

FIELD_LAST 

FILE_TERMINATOR 

FIXED_NAME 

FLOAT_NAME 

FORM_STRING 

FORM STRING2 


: 32 
; 4 

; 2_147_483_647 
: 2#1#E32 
: 8 

: DACS_680X0 
: 2#1.0#E-31 
: FCNDECL.ENTRY_ADDRESS 
: FCNDECL.ENTRY_ADDRESS1 
: FCNDECL.ENTRY_ADDRESS2 

: 35 

• / / 

: NO_SUCH_TYPE 
: NO_SUCH_TYPE 

. IIII 

"CANNOT RESTRICT FILE CAPACITY" 


GREATER_THAN_DURATION : 100000.0 

GREATER_THAN_DURATION_BASE_LAST : 200000.0 

GREATER_THAN_FLOAT_BASE_LAST : 16#1.0#E+32 

GREATER_THAN_FLOAT_SAFE_LARGE : 16#5.FFFF_F0#E+31 

GREATER_THAN_SHORT_FLOAT_SAFE_LARGE: 16#5.FFFF_F0#E+31 
HIGH_PRIORITY : 24 

ILLEGAL_EXTERNAL_FILE_NAME1 : /NODIRECTORY1/NOFILENAMEl 

ILLEGAL_EXTERNAL_FILE_NAME2 : /NODIRECTORY2/NOFILENAME2 

INAPPROPRIATE_LINE_LENGTH : -1 

INAPPROPRIATE_PAGE_LENGTH : -1 

INCLUDE_PRAGMA1 : PRAGMA INCLUDE ("A28006D1.TST") 

INCLUDE_PRAGMA2 : PRAGMA INCLUDE ("B28006D1.TST") 

INTEGER_FIRST : -2147483648 

INTEGER_LAST : 2147483647 

INTEGER_LAST_PLUS_1 : 2147483648 

INTERFACE__LANGUAGE : AS 

LESS_THAN_DURATION : -75000.0 

LESS_THAN_DURATION_BASE_FIRST : -131073.0 

LINE_TERMINATOR ; ' ' 

LOW_PRIORITY : 1 

MACHINE_CODE_STATEMENT : 

AA_INSTR'(AA_EXIT_SUBPRGRM,0,0,0,AA_INSTR_INTG'FIRST,0); 


MACHINE_CODE_TYPE 

MANTISSA_DOC 

MAX_DIGITS 

MAX_INT 

MAX_INT_PLUS_1 

MIN INT 


AA_INSTR 

31 

15 

2147483647 

2147483648 

-2147483648 


A-2 













NAME 

NAME_LIST 

NAME_SPEcfffCATION1 

NAME_SPECIFICATION2 

NAME_SPECIFICATION3 

NEG_BASED_INT 

NEW_MEM_SIZE 

NEW_STOR_UNIT 

NEW_SyS_NAME 

PAGE_TERMINATOR 

RECORD DEFINITION 


: NO_SUCH_TYPE_AVAILABLE 
: DACS_680X0 

/honie/sun2/ada/68 030/test/wrk/X212 0A 
/home/suh2/ada/68030/test/wrk/X2120B 
/home/sun2/ada/68030/test/wrk/X3ll9A 
: 16#F000000E# 

: 2097152 
: 8 

: DACS 680X0 


RECORD INSTR NO:INTEGER;ARGO:INTEGER;ARG1:INTEGER; 


ARG2:INTEGER;ARG3;INTEGER;END RECORD; 


RECORD_NAME 
TASK_SIZE 
TASK_STORAGE_SIZE 
TICK 

VARIABLE_ADDRESS 
VARIABLE_ADDRESS1 
VARIABLE_ADDRESS2 
YOUR PRAGMA 


AA_INSTR 

32 

1024 

0.0208130 

FCNDECL.VARIABLE_ADDRESS 
FCNDECL.VARIABLE_ADDRESS1 
FCNDECL.VARIABLE_ADDRESS 2 
NOFLOAT 


A-3 










APPENDIX B 


COMPILATION SYSTEM OPTIONS 


The compiler options of this Ada implementation, as described in 
this Appendix, are provided by the customer. Unless specifically 
noted otherwise, references in this appendix are to compiler 
documentation and not to this report. 

Invoke the Ada compiler with the following command to the SunOS 
shell: 


ada {<option>) <source-spec> {<source-spec>) 
where the options and parameters are: 


QUALIFIER 


DESCRIPTION 


Specifies program library used. 

-c CONFIGURATION_FILE. Specifies the file used by the 



-X 

-d 

<source-spec> 


compiler 

LIST. Writes a source listing on the list file. 
MODE. Protection mods 

NOCHECK, Generates run-time constraint checks. 
OPTIMIZE. Specifies compiler optimization. 
PROGRESS. Displays compiler progress. 

NOSAVE. Inserts source text in program library. 
UNIT. Assigns a specific unit number to 
compilation 

(must be free and in a sublibrary). 

XREF. Creates a cross reference listing. 

DEBUG. Generates debug information 

The name of the source file to be compiled 


the 






LINKER OPTIONS 


The linker options of this Ada implementation, as described in 
this Appendix, are provided by the customer. Unless specifically 
noted otherwise, references in this appendix are to linker 
documentation and not to this report. 

Enter the following command to the SunOS shell to invoke the 
linker: 

al {<option>) <unitnajiie> 

where the options and parameters are: 

QUALIFIER DESCRIPTION 


-a 

-b 

-d 

-D 


-e 


-E 

-f 

-F 

-g 

-G 

-H 

-i 

-I 

-j 

-J 

-k 

-1 

-L 

-m 

-M 

-n 


-o 

-O 

-P 

-q 

-r 

-R 

-s 

-S 

-t 

-T 

-u 


LIBRARY. The library used in the link 

RAM_BASE. Base address for RAM sections 

ROM_BASE. Base address for ROM sections 

DEBUG. Generate debug information 

STATISTICS. Print statistics 

ENTRY. Alternative program start label 

NOEXCEPTIONS. Control of exception management 

FLOAT. Control of which float processor is used 

CLASS_FILE. Class file name 

USER_CONSTANT. User constant sections 

SUPERVISOR_CONSTANT. Supervisor constant sections 

NOHEAP. Control of memory management 

INTERRUPT_STACK. Interrupt stack description 

INTERRUPTS. Number of Interrupt Task Control Blocks 

allocated 

USER_CODE. User code sections 
SUPERVISOR_CODE. Supervisor code sections 
KEEP. Do not delete temporary files 
LOGICAL_MEMORY. Logical memory specification 
LOG_FILE. Log file name 
MAIN_TASK. Main task specification 
MODE. Execution mode 
OPTION_FIIiE. Linker option file name 
EXECUTABLE. Name of executable file 
NOEXECUTABLE. Do not create executable 
PHYSICAL_MEMORY. Physical memory specification 
RTS_STACK_USE. Amount of memory used by RTS 
RAM. Description of RAM memory sections 
ROM. Description of ROM memory sections 
USER_DATA. User data sections 
SUPER_DATA. Supervisor data sections 
TASKS. Number of Task Control Blocks allocated 
TASK_DEFAULTS. Default values for tasks 
UCC_LIBRARY. UCC library name 


B-2 






p > > > X >iX N eg 


USR_LIBRARY. A user supplied object library 
VERIFY. Print information about the link 
MMU_DETAIIiS . Setup values for MMU registers 
WARNINGS. Print warnings 

TARGET_OPTIONS . Options to the target linker 
VECTOR. Interrupt vector description 
NOVECTOR. No interrupt vector 
INIT_FIIiE. Initialization file name 
BOOT. Generate boot module 

All qualifier keywords to the options may be abbreviated to the 
minimal unique substring, and casing is not significant. 


B-3 






APPENDIX C 


APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to 
implementation-dependent pragmas, to certain machine-dependent 
' conventions as mentioned in Chapter 13 of the Ada Standard, and 
to certain allowed restrictions on representation clauses. The 
implementation-dependent characteristics of this Ada 
implementation, as described in this Appendix, are provided by 
the customer. Unless specifically noted otherwise, references in 
this Appendix are to compiler documentation end not to this 
report. Implementation-specific portions or the package 
STANDARD, which are not a part of Appendix F, are; 

package STANDARD is 

type SHORT_INTEGER is range -32_768 .. 32_767; 

type INTEGER is range -2_147_483_648 .. 2_147_483_647; 

type FLOAT is digits 6 

range -16#0.FFFF_FF#E32 .. 16#0.FFFF_FF#E32; 

type LONG_FLOAT is digits 15 

range -16#0.FFFF_FFFF_FFFF_F8#E256 .. 

16 # 0.FFFF_FFFF_FFFF_F8 #E2 5 6; 

type DURATION is delta 2#1.0#E-14 range -131_072.0 .. 131_071.0; 
end STANDARD; 


C-1 






APPENDIX I. 


IMPLEMENTATION DEPENDENT CHARACTERISTICS 


This appendix describes the inplementation-dependent 
characteristics of DACS-68030 required in Appendix F of the Ada 
Reference Manual (ANSI/MIL-STD-1815A), 


A. Implementation-Dependent Pragmas 

This section describes all implementation defined pragmas. 


1. PRAGMA INTERFACE SPELLING 

Format: pragma INTERFACE_SPELLING(<subprogram-name>, 

<string>) 

Placement: The pragma may be placed as a declarative item. 

Restrictions: Pragma INTERFACE_SPELLING must be applied to the 

subprogram denoted by <subprogreun-name>. The 
<string> must be a string literal. 

This pragma allows an Ada program to call routines with a name that 
is not a legal Ada name, the <string> provides the exact spelling 
of the name of the procedure. 


2. PRAGMA INITIALIZE 

Format: pragma INITIALIZE(<string_literal>) 

Placement: The pragma may be placed as a declarativa item. 

Restrictions: None. 

When the pragma is applied the linker will, as part of the 
initialization code generate a call to the subprogram with the name 
<string_literal>. The call will be performed before the elaboration 
of the Ada program is initiated, with IPL on 7. If several pragmas 
INITIALIZE are applied to the same program the routines are called 
in the elaboration order, if several pragmas INITIALIZE are applied 
to one compilation unit the routines are called in the order of 
appearance. If several compilations units apply pragma INITIALIZE 
to the same routine the routine is called once only. 


C-2 






3. PRAGMA RUNDOWN 


Format; pragma RUNDOWN(<string_literal>) 

Placement; The pragma may be placed as a declarati/e item. 

Restrictions; None. 

Similar to pragma initialize, but the subprogram is called after 
the main program have terminated and in the reverse order as for 
the pragma INITIALIZE. 


4. PRAGMA TASKS 

Formar; pragma TASKS; 

Placement; The pragma may be placed as a declarative item. 

Restrictions; None. 

Marks the compilation unit with the task attribute. If the code 
that is interfaced by a pragma INTERFACE uses any tasking 
constructs, the compilation unit must be marked such that the 
linker includes the tasking kernel in target programs that 
reference the compilation unit. 


5. PRAGMA FLOAT 

Format; pragma FLOAT; 

Placement; The pragma may be placed as a declarative item. 

Restrictions; None. 

Marks the compilation unit with the float attribute. If the code 
that is interfaced by a pragma INTERFACE uses any floating point 
co-processor instructions, the compilation unit must be marked such 
that the linker includes initialization of the floating point 
co-processor in target programs that reference the compilation 
unit. 


6. PRAGMA INTERRUPTS 

Format: pragma INTERRUPTS; 


C-3 




DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


PlacementT*"' The pragma may be placed as a declarative item. 
Restrictions: None. 

Marks the compilation unit with the interrupt attribute. If the 
code that is interfaced by a pragma INTERFACE uses any interrupts, 
the compilation unit must be marked such that the linker include 
the interrupt handling in target programs that reference the 
compilation unit. 


7. PRAGMA STORAGE MANAGER 

Format: pragma STORAGE_MANAGER; 

Placement: The pragma may be placed as a declarative item. 

Restrictions: None. 

Marks the compilation unit with the heap attribute. If the code 
that is interfaced by a pragma INTERFACE uses the storage manager, 
the compilation unit m.ust be marked such that the linker include 
initialization of the storage manager in target programs that 
reference the compilation unit. 


8. PRAGMA INTERRUPT HANDLER 

The pragma INTERRUPT_HANDLER is defined with two formats. 

a. PRAGMA INTERRUPT HANDLER for Task Entries 
Format: pragma INTERRUPT_HANDLER; 

Placement: The pragma must be placed as the first declarative 

item in the task specification that it applies to. 

Restrictions: The task for which the pragma INTERRUPT HANDLER is 

applied must fulfill the following requirements: 

An address clause must be specified for all entries to 

the task. 

All entries of the task must be single entries with no 


C-4 









DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


--^ccrameters. 

The entries must not be called from any tasks. 

No other tasks may be specified in the body of the task. 

The body of the task must consist of a single sequence of 
accept statements for each of the defined interrupts, see 
below: 

task body fih is 

— local simple data declaration, no tasks, 
begin 

accept handlerl do 
<statementlist>; 
end handlerl; 
accept handler2 do 
<statementlist>; 
end handler2; 
end fih; 

No other tasking construct than unconditional entry calls 
may appear in the statement list for the select 
alternatives. The execution of a statement list must only 
execute one unconditional entry call. 

Any procedures called from the accept body must not use 
any tasking constructs at all. 

No heap storage must allocated. 

No exception must be propagated out of the statement list 
of the accept alternatives. 

If the restrictions described above are not fulfilled, the prograr 
is erroneous and the result of the execution unpredictable. Th 
compiler cannot and is not checking all the restrictions, but 
attempts to perform as many checks of the requirements as possible. 

The pragma INTERRUPT_HANDLiER with no parameters allows the user to 
implement immediate response to exceptions. 


b. PRAGMA INTERRUPT HANDLER for Procedures 

Format: pragma 

INTERRUPT_HANDLER(procedure-name,integer-literal); 


C-5 








DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - 'Jser's Guide 
Implementation Dependent Characteristics 


Placementi-«w The pragma must be placed as a declarative item, in 
the declarative part, immediately after the 
procedure specification. 

Restrictions: The procedure for which pragma INTERRUPT HANDLER 

applies must fulfill the following restrictions: 

The integer-literal must be in range 0. .255, and must not 
define an interrupt vector entry to which the processor 
may generate a trap. 

The procedure must not be called anywhere in the 
application. 

No tasks may be declared in the body of the procedure. 

The only tasking construct that may be used from the body 
of the procedure is unconditional entry calls. Several 
unconditional entry calls may appear in the body of the 
procedure but the execution of the body must only lead to 
the execution of one. 

Any subprograms called from the procedure must not use 
any tasking constructs at all. 

The procedure must be parameterless. 

No heap storage must allocated from the procedure. 

Exceptions must no be propagated out of the procedure. 

If the restrictions described above is not fulfilled the program is 
erroneous and the result of the execution unpredictable. The 
compiler cannot and is not checking all the restrictions, but 
attempts to perform as many checks of the requirements as possible. 

The pragma INTERRUPT HANDLER for procedures defines the named 
subprogram to be an interrupt handler for the interrupt vector 
entry defined by the integer-literal. 


C-6 







DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


9. PRAGMA^sWOFLOAT 

Format: pragma NOFLOAT(task-id) 

Placement: The pragma must be placed as a declarative item, in 

the declarative part, defining the task type or 
object denoted by the task-id. 

Restrictions: The task(s) denoted by the task-id must not execute 

floating-point co-processor instructions. 

This pragma informs the compiler and runtime system that the task 
will not execute floating point co-processor instructions. 
Consequently the context switch needs net save and restore the 
state of the floating point co-processor yielding improved 
performance. 


10. PRAGMA SUPERVISOR_TASK 

Format: pragma SUPERVISOR_TASK 

Placement: The pragma must be placed immediately after the 

task declaration of the task declaring as a 
SUPERVISOR_TASK. 

Restrictions: The pragma has no meaning if linking with BASIC 
mode. 

This pragma informs the compiler and runtime system that the task 
shall execute at the supervisor privilege level, all other tasks 
will execute at user privilege level when linking with SECURE 
execution mode. In BASIC execcution mode all tasks execute at the 
supervisor privilege level. 


11. PRAGMA ACCESS_TyPE_RETAIN_HEAP 

Format: pragma ACCESS_TYPE_RETAIN_HEAP 

Placement: The pragma must be placed as a declarative item, in 

the declarative part, immediately, after the 
procedure specification. 

Restrictions: The pragma can only be used when linking in BASIC 

mode. 


C-7 






DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


This prett^Bt^ supress garbage collection of access types, when 
leaving the scope of the access type declaration. 


B. Implementation-Dependent Attributes 
No implementation-dependent attributes are defined. 


C. Package SYSTEM 


package SYSTEM is 


type ADDRESS 
subtype PRIORITY 
type NAME 
SYSTEM_NAME: 
STORAGE_UNIT: 
MEMORY_SIZE: 
MIN_INT: 

MAX_INT: 
MAX_DIGITS: 

MAX MANTISSA: 


IS new INTEGER; 
is INTEGER range 1 .. 24; 
is ( DACS_680X0 ); 


constant NAME 

constant 

constant 

constant 

constant 

constant 

constant 


DACS_680X0; 

8 ; 

2#1#E32; 
-2_147_483_648; 
2_147 483_647; 
15; 

31; 


FINE_DELTA: 
TICK: 


constant 

constant 


:= 2#1.0#E-31; 
:= 0.0208130; 


type interface_language is (AS,C); 


end SYSTEM; 


D. Representation Clauses 

The DACS-68030 fully supports the 'SIZE representation for derived 
types. The representation clauses that are accepted for non-derived 
types are described in the following subsections. 


1. Lengrth Clause 

Some remarks on implementation dependent behavior of length clauses 
are necessary: 


C-8 







DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


-^len using the SIZE attribute for discrete types, the 
maximum value that can be specified is 32 bits. 

SIZE is only obeyed for discrete types when the type is 
a part of a composite object, e.g. arrays or records. 

Using the STORAGE_SIZE attribute for a collection will 
set an upper limit on the total size of objects allocated 
in this collection. If further allocation is attempted, 
the exception STORAGE_ERROR is raised. 

When STORAGE_SIZE is specified in a length clause for a 
task, the process stack area will be of the specified 
size. 


2. Enumeration Representation Clauses 

Enumeration representation clauses may specify representations in 
the range of INTEGER'FIRST + 1..INTEGER'LAST - 1. 


3. Record Representation Clauses 

When representation clauses are applied to records the following 
restrictions are imposed: 

if the component is a record or an unpacked array, it 
must start at a storage unit boundary bits) 

a record occupies an integral number of storage xinits 
(words) (even though a record may have fields that only 
define an odd number of bytes) 

a record may take up a maximum of 2 giga bits 

a component must be specified with its proper size (in 
bits), regardless of whether the component is an array or 
not. 

if a non-array component has a size which equals or 
exceeds one storage unit 32-bits the component must start 
on a storage unit boundary. 

the elements in an array component should always be 
wholly contained in 32-bits. 


C-9 





DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


If the recsBPd- type contains components which are not covered by a 
component clause, they are allocated consecutively after the 
component with the value. Allocation of a record component without 
a component clause is always aligned on a storage unit boundary. 
Holes created because of component clauses are not otherwise 
utilized by the compiler. 

Pragma PACK on a record type will attempt ro pack the components 
not already covered by a representation clause (perhaps none). This 
packing will begin with the small scalar components and larger 
components will follow in the order specified in the record. The 
packing begins at the first storage unit after the components with 
representation clauses. 


a. Alignment Clauses 

Alignment clauses for records are implemented with the following 
characteristics: 

If the declaration of the record type is done at the 
outermost level in a library package, any alignment is 
accepted. 

If the record declaration is done at a given static level 
(higher than the outermost library level, i.e., the 
permanent area), only word alignments are accepted. 

Any record object declared at the outermost level in a 
library package will be aligned according to the 
alignment clause specified for the type. Record objects 
declared elsewhere can only be aligned on a word 
boundary. If the record type is associated with a 
different alignment, an error message will be issued. 

If a record type with an associated alignment clause is 
used in a composite type, the alignment is required to be 
one word; an error message is issued if this is not the 
case. 


E. Implementation-Dependent Names for Implementation-Dependent 
Components 

None defined by the compiler. 


C-10 







DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


F. Address Clauses 

This section describes the implementation of address clauses and 
what types of entities may have their address specified by the 
user. 


1. Obj ects 

Address clauses are supported for scalar and composite objects 
whose size can be determined at compile time if the address is 
specified. 


2. Task Entries 

Address clauses are supported for task entries. The following 
restrictions applies: 

The affected entries must be defined in a task object 
only, not a task type. 

The entries must be single and parameterless. 

The address specified must not denote an interrupt index 
which the processor may trap. 

If the interrupt entry executes floating point 
co-processor instructions the state of the co-processor 
must be saved prior to execution of any floating point 
instructions, and restore before the return. 

The address specified in the address clause denotes the interrupt 
vector index. 


G. Input/Output Packages 

In many embedded systems, there is no need for a traditional I/O 
system, but in order to support testing and validation, DDC-I has 
developed a small terminal oriented I/O system. This I/O system 
consists essentially of TEXT_IO adapted with respect to handling 
only a terminal and not file I/O (file I/O will cause a USE ERROR 
to be raised) and a low level package called TERMINAL_DRIVER. A 


C-11 







DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


BASIC_IO-:=pac^^cage has been provided for convenience purposes, 
forming an interface between TEXT_IO and TERMINAL_DRIVER as 
illustrated in the following figure. 



Fig. F.l: 

The TERMINAL_DRIVER package is the only package that is target 
dependent, i.e., it is the only package that need be changed when 
changing communications controllers. The actual body of the 
TERMINAL_DRIVER is written in assembly language, but an Ada 
interface to this body is provided. A user can also call the 
terminal driver routines directly, i.e. from an assembly language 
routine. TEXT_IO and BASIC_IO are written completely in Ada and 
need not be changed. 

BASIC_I0 provides a mapping between TEXT__IO control characters and 
ASCII as follows: 


TEXT 10 

ASCII Character 

LINE TERMINATOR 

PAGE TERMINATOR 

FILE TERMINATOR 

NEW LINE 

ASCII.CR 

ASCII.FF 

ASCII.EM (Ctrl Z) 

ASCII.LF 


Table F.l: Mapping between TEXT_IO and ASCII 
The services provided by the terminal driver are: 

1) Reading a character from the communications port. 

2) Writing a character to the communications port. 


1. Package TEXT lO 


C-12 












DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


The speci-fication of package TEXT_I0: 

pragma page; 
with BASIC_IO; 

with IO_EXCEPTIONS; 
package TEXT_I0 is 

type FILE_TYPE is limited private; 

type FILE_M0DE is (IN_FILE, OUT_FILE); 

type COUNT is range 0 .. INTEGER'LAST; 

subtype POSITIVE_COUNT is COUNT range 1 .. COUNT'LAST; 

UNBOUNDED: constant COUNT:= 0; — line and page length 

— max. size of an integer output field 2#....# 
subtype FIELD is INTEGER range 0 .. 35; 

subtype NUMBER_BASE is INTEGER range 2 .. 16; 

type TYPE_SET is (LOWER_CASE, UPPER_CASE); 
pragma PAGE; 

— File Management 


procedure 

CREATE 

(FILE 

• 

• 

in 

out FILE TYPE; 




MODE 

• 

• 

in 

FILE MODE :=0UT FILE; 



NAME 

• 

in 

STRING 

• 

f 



FORM 
) ; 

• 

• 

in 

STRING 


procedure 

OPEN 

(FILE 

« 

« 

in 

out FILE TYPE; 




MODE 

• 

• 

in 

FILE MODE; 




NAME 

• 

• 

in 

STRING; 




FORM 
) ; 


in 

STRING 


procedure 

CLOSE 

(FILE 


in 

out FILE TYPE); 


procedure 

DELETE 

(FILE 


in 

out FILE TYPE); 


procedure 

RESET 

(FILE 


in 

out FILE TYPE; 




MODE 


in 

FILE MODE); 


procedure 

RESET 

(FILE 


in 

out FILE_TYPE); 


function 

MODE 

(FILE 


in 

FILE TYPE) return 

FILE MODE 

function 

NAME 

(FILE 


in 

FILE TYPE) return 

STRING; 

function 

FORM 

(FILE 


in 

FILE TYPE) return 

STRING; 

function 

IS_OPEN(FILE 

: 

in 

FILE_TYPE return BOOLEAN; 


C-13 






DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PA^Pr* 

— control of default input and output files 

procedure SET_INPUT (FILE : in FILE_TYPE); 
procedure SET_OUTPUT (FILE : in FILE_TYPE); 

function STANDARD_INPUT return FILE_TYPE; 

function STANDARD_OUTPUT return FILE_TYPE; 

function CURRENT_INPUT return FILE_TYPE; 

function CURRENT_OUTPUT return FILE_TYPE; 

pragma PAGE; 

— specification of line and page lengths 

procedure SET_LINE_LENGTH (FILE : in FILE_TYPE; 

TO : in COUNT); 

procedure SET_LINE_LENGTH (TO : in COUNT); 

procedure SET_PAGE_LENGTH (FILE : in FILE_TYPE; 

TO : in COUNT); 

procedure SET_PAGE_LENGTH (TO : in COUNT); 

function LINE_LENGTH (FILE : in FILE_TYPE) 

return COUNT? 
function LINE_LENGTH return COUNT; 

function PAGE_LENGTH (FILE : in FILE_TYPE) 

return COUNT; 
function PAGE LENGTH return COUNT? 


C-14 




DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PASSv- 

— Column, Line, and Page Control 


procedure 

NEW LINE (FILE : in 

FILE TYPE; 



SPACING : 

In POSITIVE COUNT := 

1); 

procedure 

NEW LINE (SPACING : 

in POSITIVE COUNT := 

1) ; 

procedure 

SKIP LINE (FILE : in FILE_TYPE; 



SPACING 

: in POSITIVE COUNT := 

= 1) ; 

procedure 

SKIP_LINE (SPACING 

: in POSITIVE_COUNT := 

= 1); 

function 

END OF LINE 

(FILE : 

in FILE_TYPE) return 

BOOLEAN; 

function 

END_OF_LINE 


return 

BOOLEAN; 

procedure 

NEW PAGE 

(FILE : 

in FILE_TYPE) ; 


procedure 

NEW_PAGE; 




procedure 

SKIP PAGE 

(FILE : 

in FILE_TYPE); 


procedure 

SKIP_PAGE; 




function 

END OF PAGE 

(FILE : 

in FILE_TYPE) return 

BOOLEAN; 

function 

END_OF_PAGE 


return 

BOOLEAN; 

function 

END OF FILE 

(FILE : 

in FILE_TYPE) return 

BOOLEAN; 

function 

END_OF_FILE 


return 

BOOLEAN; 

procedure 

SET_C0L 

(FILE : 

in FILE TYPE; 




TO : 

in POSITIVE COUNT); 


procedure 

SET_COL 

(TO : in P0SITIVE_C0UNT); 


procedure 

SET_LINE 

(FILE : 

in FILE_TYPE; 




TO : in POSITIVE COUNT); 


procedure 

SET_LINE 

(TO ; in POSITIVE_COUNT); 


function 

COL 

(FILE : 

in FILE TYPE) 




return 

POSITIVE COUNT; 


function 

COL 

return 

POSITIVE_COUNT; 


function 

LINE 

(FILE : 

in FILE TYPE) 




return 

POSITIVE COUNT; 


function 

LINE 

return 

POSITIVE_COUNT; 


function 

PAGE 

(FILE ; 

in FILE TYPE) 




return 

POSITIVE COUNT; 


function 

PAGE 

return 

POSITIVE COUNT; 



C-15 




DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PASPh' 

— Character Input-Output 


procedure 

GET 

(FILE 

: in FILE TYPE; ITEM 


out 

CHARACTER) 

procedure 

GET 

( 


ITEM 


out 

CHARACTER; 

procedure 

PUT 

(FILE 

: in FILE TYPE; ITEM 


in 

CHARACTER) 

procedure 

PUT 

( 


ITEM 


in 

CHARACTER) 

— String 

Input-Output 





procedure 

GET 

(FILE 

: in FILE TYPE; ITEM 


out 

CHARACTER); 

procedure 

GET 

( 


ITEM 


out 

CHARACTER); 

procedure 

PUT 

(FILE 

: in FILE_TYPE; ITEM 


in 

CHARACTER); 

procedure 

PUT 

{ 


ITEM 


in 

CHARACTER); 

procedure 

GET_ 

_LINE 

(FILE : 

in FILE_TYPE; 







ITEM ; 

out STRING; 







LAST : 

out NATURAL): 




procedure 

GET_ 

_LINE 

(ITEM : 

out STRING; 







LAST : 

out NATURAL); 




procedure 

PUT_ 

LINE 

(FILE : 

in FILE TYPE; 







ITEM : 

in STRING); 




procedure 

PUT_ 

LINE 

(ITEM : 

in STRING); 





C-16 







User's Guide 


DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - 
Implementation Dependent Characteristics 


pragma PAtS', - 

— Generic Package for Input-Output of Integer Types 
generic 

type MUM is range <>; 
package INTEGER_IO is 

DEFAULT_WIDTH : FIELD := NUM'WIDTH; 

DEFAULT_BASE : NUMBER_BASE := 10; 

procedure GET (FILE : in FILE_TYPE; 

ITEM : out NUM.- 

WIDTH : in FIELD := 0); 

Pi.ocedure GET (ITEM : out NUM.- 

WIDTH : in FIELD := 0); 

procedure PUT (FILE : in F1LE_TYPE.- 

ITEM ; in NUM; 

WIDTH : in FIELD := DEFAULT_WIDTH; 

BASE : in NUMBER_BASE := DEFAULT_BASE); 
procedure PUT (ITEM : in NUM; 

WIDTH : in FIELD := DEFAULT_WIDTH; 

BASE : in NUMBER_BASE := DEFAULT_BASE); 

procedure GET (FROM • in STRING; 

ITEM ; out NUM; 

LAST ; out POSITIVE); 

procedure PUT (TO : out STR:''NG; 

ITEM : in NUM.- 

BASE : in NUMBER_BASE := DEFAULT_BASE); 


end INTEGER 10; 






DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PA^r* 

— Generic Packages for Input-Output of Real Types 
generic 

type NUM is digits <>; 
package FLOAT_IO is 


DEFAULT_FORE : FIELD : 
DEFAULT_AFT : FIELD : 
DEFAULT EXP : FIELD : 


procedure 

GET 

(FILE 

ITEM 

WIDTH 

procedure 

GET 

(ITEM 

WIDTH 

procedure 

PUT 

(FILE 

ITEM 

FORE 

AFT 

EXP 

procedure 

PUT 

(ITEM 

FORE 

AFT 

EXP 

procedure 

GET 

(FROM 

ITEM 

LAST 

procedure 

PUT 

(TO 


ITF’^ 


AFT 

EXP 


2 ; 

NUM'DIGITS - 1; 

3 ; 

in FILE_TYPE; 
out NUM; 
in FIELD := 0); 
out NUM; 
in FIELD := 0); 

in FILE_TYPE; 
in NUM; 

in FIELD := DEFAULT_FORE; 
in FIELD := DEFAULT_AFT; 
in FIELD ;= DEFAULT_EXP); 
in NUM; 

in FIELD ;= DEFAULT_FORE; 
in FIELD := DEFAULT_AFT; 
in FIELD := DEFAULT_EXP); 

in STRING; 
out NUM; 
out POSITIVE); 
out STRING; 
in NUM; 

in FIELD := DEFAULT_AFT; 
in FIELD := DEFAULT_EXP); 


end FLOAT 10; 


C-18 












DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User' 
Implementation Dependent Characteristics 


pragma PA^,'^ 
generic 

type NUM is delta <>; 
package FIXED_I0 is 

DEFAULT_FORE : FIELD := NUM'FORE; 

DEFAULT_AFT : FIELD := NUM'AFT; 

DEFAULT_EXP : FIELD := 0; 

procedure GET (FILE : in FILE_TYPE; 

ITEM : out NUM; 

WIDTH : in FIELD := 0) ; 
procedure GET (ITEM : out NUM; 

WIDTH : in FIELD := 0) ; 


procedure 

PUT 

(FILE 


in FILE_TYPE; 



ITEM 


in NUM; 



FORE 


in FIELD := DEFAULT FORE; 



AFT 


in FIELD := DEFAULT AFT; 



EXP 


in FIELD := DEFAULT_EXP); 

procedure 

PUT 

(ITEM 


in NUM; 



FORE 


in FIELD := DEFAULT FORE; 



AFT 


in FIELD := DEFAULT AFT; 



EXP 


in FIELD := DEFAULT_EXP); 

procedure 

GET 

(FROM 


in STRING; 



ITEM 


out NUM; 



LAST 


out POSITIVE); 

procedure 

PUT 

(TO 


out STRING; 



ITEM 


in NUM; 



AFT 


in FIELD := DEFAULT AFT; 



EXP 


in FIELD := DEFAULT EXP); 


end FIXED 10; 


Guide 


C-19 








DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PASF,*-' 

— Generic Package for Input-Output of Enumeration Types 


generic 

type ENUM is (<>); 
package ENUMERATION_IO is 


DEFAULT_WIDTH : FIELD := 0; 
DEFAULT_SETTING : TYPE_SET := UPPER_CASE; 


procedure 

GET 

(FILE : 

in FILE_TYPE; 

ITEM : out ENUM); 

procedure 

GET 

( 


ITEM : out ENUM); 

procedure 

PUT 

(FILE 

ITEM 

WIDTH 

SET 

: FILE_TYPE; 

: in ENUM; 

: in FIELD 
: in TYPE_SET 

:= DEFAULT WIDTH; 

:= DEFAULT_SETTING); 

procedure 

PUT 

(ITEM 

WIDTH 

SET 

: in ENUM; 

: in FIELD 
: in TYPE_SET 

:= DEFAULT WIDTH; 

:= DEFAULT_SETTING); 

procedure 

GET 

(FROM : 
ITEM : 
LAST : 

in STRING; 
out ENUM; 
out POSITIVE) 


procedure 

PUT 

(TO : 

ITEM : 
SET ; 

out STRING; 
in ENUM; 
in TYPE_SET 

:= DEFAULT_SETTING); 


end ENUMERATI0N_I0; 

pragma PAGE; 

— Exceptions 

STATUS_ERROR 
M0DE_ERR0R 
NAME_ERROR 
USE_ERR0R 
DEVICE_ERROR 
END_ERROR 
DATA_ERROR 
LAYOUT ERROR 


exception 

exception 

exception 

exception 

exception 

exception 

exception 

exception 


renames 

renames 

renames 

renames 

renames 

renames 

renames 

renames 


IO_EXCEPTIONS 
IO_EXCEPTIONS 
IO_EXCEPTIONS 
IO_EXCEPTIONS 
IO_EXCEPTIONS 
IO_EXCEPTIONS 
IO_EXCEPTIONS 
10 EXCEPTIONS 


.STATUS_ERROR; 

,M0DE_ERR0R; 

,NAME_ERROR; 

,USE_ERROR; 

, DEVICE_ERROR; 
.END_ERROR; 

, DATA_ERROR; 
.LAYOUT ERROR; 


C-20 






DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma pag^;'^ 
private 

type FILE_TYPE is 
record 

FT : INTEGER := -1; 
end record; 

end TEXT 10; 


2. Package lO EXCEPTIONS 

The specification of the package I0_EXCEPTI0NS: 


package I0_EXCEPTI0NS is 


STATUS_ERROR 

MODE_ERROR 

NAME_ERR0R 

USE_ERR0R 

DEVICE_ERR0R 

END_ERR0R 

DATA_ERR0R 

LAYOUT ERROR 


exception; 
exception; 
exception; 
exception; 
exception; 
exception; 
exception; 
exception; 


end 10 EXCEPTIONS; 


3. Package BASIC lO 

The specification of package BASIC_I0; 


with I0_EXCEPTI0NS; 
package BASIC_I0 is 

type count is range 0 .. integer'last; 

subtype positive_count is count range 1 .. count'last; 

function get_integer return string; 

— Skips any leading blanks, line terminators or page 
— terminators. Then reads a plus or a minus sign if 


C-21 










DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


— preiSht, then reads according to the syntax of an 

— integer literal, which may be based. Stores in item 

— returns a string containing an optional sign and an 

— integer literal. 

— The exception DATA_ERROR is raised if the sequence 

— of characters does not correspond to the syntax 

— described above. 

— The exception END_ERROR is raised if the file teirminator 

— is read. This means that the starting sequence of an 

— integer has not been met. 

— Note that the character terminating the operation must 

— be available for the next get operation. 


function get_real return string; 

— Corresponds to get_integer except that it reads according 

— to the syntax of a real literal, which may be based. 

function get_enumeration return string; 

— Corresponds to get_integer except that it reads according 

— to the syntax of an identifier, where upper and lower 

— case letters are equivalent to a character literal 

— including the apostrophes. 

function get_item (length : in integer) return string; 

— Reads a string from the current line and stores it in 

— item. If the remaining number of characters on the 

— current line is less than length then only these 

— characters are returned. The line terminator is not 

— skipped. 

procedure put_item (item ; in string); 

— If the length of the string is greater than the current 

— maximum line (linelength), the exception LAYOUT_ERROR 

— is raised. 

— If the string does not fit on the current line a line 

— terminator is output, then the item is output. 

— Line and page lengths - [DOD-83] 14.3.3. 


C-22 









DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 

procedor^set_line_length (to : in count) ; 

procedure set_pdge_length (to : in count); 

function line_length return count; 
function page_length return count; 

— Operations on columns, lines and pages - [DOD-83] 14.3.4. 

procedure new_line; 

procedure skip_line; 

function end_of_line return boolean; 

procedure new_page; 

procedure skip_page; 

function end_of_page return boolean; 

function end_of_file return boolean; 

procedure set_col (to ; in positive_count); 

procedure set_line (to : in positive_count); 

function col return positive_count; 

function line return positive_count; 

function page return positive_count; 

— Character and string procedures. 

— Corresponds to the procedures defined in [EX)D-83] 14.3.6. 

procedure get_character (item : out character); 

procedure get_string (item ; out string); 

procedure get_line (item ; out string; 

last ; out natural); 

procedure put_character (item : in character); 
procedure put_string (item : in string); 


C-23 







DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - Us«_r's Guide 
Implementation Dependent Characteristics 


procedS?©-put_line (item : in string); 


exceptions: 

USE_ERR0R : exception renames I0_EXCEPTI0NS.USE_ERR0R; 
DEVICE_ERROR : exception renames IO_EXCEPTIONS.DEVICE_ERROR; 
END_ERROR : exception renames IO_EXCEPTIONS.END_ERROR; 
DATA_ERROR : exception renames I0_EXCEPTI0NS.DATA_ERROR; 
LAX0UT_ERR0R : exception renames IO_EXCEPTIONS.LAY0UT_ERR0R; 

end BASIC 10; 


4. Package TERMINAL DRIVER 

The specification of package TERMINAL_DRIVER: 
package terminal_driver is 

procedure put_character(ch : character); 
procedure flush; 

function get_character return character; 
procedure purge; 
private 

pragma interface (AS, put_character); 

pragma interface_speiling(put_character, "Ada_UCC_G$PutByte"); 
pragma interface (AS, get_character); 

pragma interface_spelling(get_character, "Ada_UCC_G$GetByte"); 
pragma interface (AS, flush); 

pragma interface_speiling(flush, "Ada_UCC_G$FlushOutput"); 
pragma interface (AS, purge); 

pragma interface_speiling(purge, "Ada_UCC_G$PurgeInput"); 

pragma initialize("Ada_UCC_G$InitIO"); 
pragma rundown ("Ada_UCC_G$CloseIO"); 

end terminal driver; 


C-24 





DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 

5. Packagtf^QUENTIAL 10 

The specification of package SEQUENTIAL_IO: 

— Source code for SEQUENTIAL_IO 

pragma PAGE; 

with I0_EXCEPTI0NS; 

generic 

type ELEMENT_TYPE is private; 
package SEQUENTIAL_IO is 

type FILE_TYPE is limited private; 
type FILE_M0DE is (IN_FILE, OUT_FILE); 


C-25 





DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Implementation Dependent Characteristics 


pragma PASE't' 

— File management 


procedure CREATE(FILE ; in out FILE_TYPE; 

MODE : in FILE_M0DE := 0UT_FILE; 

NAME : in STRING := 

FORM : in STRING := ; 

procedure OPEN (FILE : in out FILE_TYPE; 

MODE : in FILE_MODE; 

NAME : in STRING; 

FORM : in STRING := ""); 

procedure CLOSE (FILE : in out FILE_TYPE); 

procedure DELETE(FILE : in out FILE_TYPE); 

procedure RESET (FILE : in out FILE_TYPE; 

MODE : in FILE_MODE); 

procedure RESET (FILE : in out FILE_TYPE); 

function MODE (FILE : in FILE_TYPE) return FILE_MODE; 

function NAME (FILE : in FILE_TYPE) return STRING; 

function FORM (FILE : in FILE_TYPE) return STRING; 

function IS_OPEN(FILE : in FILE_TYPE) return BOOLEAN; 


pragma PAGE; 

— input and output operations 


procedure READ (FILE : in FILE_TYPE; 

ITEM : out ELEMENT_TYPE); 

procedure WRITE (FILE ; in FILE_TYPE; 

ITEM : in ELEMENT_TYPE); 

function END_OF_FILE(FILE : in FILE_TYPE) return BOOLEAN; 


C-26 









DACS Sun-3/SunOS to 68030 Bare Ada Cross Compiler - User's Guide 
Impj^ementation Dependent Characteristics 


pragma PAGE; 
— exceptions 


STATUS_ERR0R 

MODE_ERROR 

NAME_ERROR 

USE_ERR0R 

DEVICE_ERROR 

END_ERR0R 

DATA ERROR 


exception 

exception 

exception 

exception 

exception 

exception 

exception 


renames 

renames 

renames 

renames 

renames 

renames 

renames 


IO_EXCEPTIONS.STATUS_ERROR; 
IO_EXCEPTIONS.MODE_ERROR; 
IO_EXCEPTIONS.NAME_ERROR; 
IO_EXCEPTIONS.USE_ERR0R; 
IO_EXCEPTIONS.DEVICE_ERROR; 
IO_EXCEPTIONS.END_ERROR; 

10 EXCEPTIONS.DATA ERROR; 


pragma PAGE; 
private 


type FILE_TYPE is new INTEGER; 


end SEQUENTIAL 10; 


H. Machine Code Insertions 

Machine code insertion is allowed using the instruction defined 
in package MACHINE_CODE. All arguments given in the code 
statement aggregate must be static. 

The machine language defined in package MACHINE_CODE is not 68020 
assemble, but rather Abstract A-code which is an intermediate 
language used by the compiler. 


C-27 


