NASA Technical Memorandum 86241 


A Rule Based Computer 
Aided Design System 

i. „ : . ( i. ; J a ) '• J r- ■- *- 


Timothy Premack 

OCTOBER 1986 



NASA Technical Memorandum 86241 


A Rule Based Computer 
Aided Design System 


Timothy Premack 
Goddard Space Flight Center 
Greenbelt, Maryland 


NASA 

National Aeronautics 
and Space Administration 

Scientific and Technical 
Information Branch 


1986 



TABLE OF CONTENTS 


INTRODUCTION 1 

Modeling Design 1 

CAD Systems And Their Limitations 1 

SYSTEM REQUIREMENTS 2 

Design As A Function 2 

Network Data Base For CAD 2 

Control Structure 2 

Logic Programming 3 

Prolog Examples 3 

Logic Programming In Design 3 

A ‘Satisficing 4 System 3 

RULE BASED CAD SYSTEM 3 

Data Base 3 

Design Function 4 

Geometry 4 

Solid Of Revolution 4 

Solid Of Linear Extrusion 4 

Solid Of Helical Extrusion 4 

Part 4 

Structure Definitions 4 

Execution 5 

PISTON EXAMPLE 5 

Description Of The Piston Design 5 

Piston Redesign 5 

CONCLUSION 6 

REFERENCES 6 

APPENDIX A ELEMENT DEFINITIONS 
APPENDIX B SPRING PISTON EXAMPLE 
APPENDIX C PROLOG CAD SYSTEM CODE 

iii 


f!RE£CP&& PAGE S NOT FSUflK* 


PREFACE 


This paper was originally submitted to the John Hopkins University as a master’s essay in October, 1985. 

I would like to thank Drs. A. Douglas and J. O’Rourke of Johns Hopkins University for advising me on this thesis. I also 
thank L. Purves of The Goddard Space Flight Center for providing an environment to conduct this research, and Prologica 
for supplying a bug free Prolog interpreter. 


pl£C&)8«3 PAGE- BLA^C NOT FftJW© 


V 


A RULE BASED COMPUTER AIDED 
DESIGN SYSTEM 

Timothy Premack 

INTRODUCTION 

A theory of the process of design and how a design is represented is presented. A description of current 
CAD systems and their shortcomings is described. A system is then presented which addresses the needs 
of design: it models the iterative nature of the design process, the associativity between constitutive parts, 
and permits design by an explicit function of parameters. An example design of a spring piston is used to 
illustrate the system. 


MODELING DESIGN 

To model design one must not only represent the physical 
design but model the design process itself. A model of the 
design is a description of the geometry representing its con- 
stitutive parts and their relationship to each other in their 
assembled configuration. 

The process of design is usually defined as iterative [1]. 
It consists of specification, initial design, evaluation of the 
design, and redesign. In essence, given a requirement, one 
produces a design and refines it until it meets specific 
requirements. 

The relationship of the parts forming an assembly 
resembles a hierarchy [2]. The top node of the tree is the 
assembly itself, the branches form sub-assemblies, moving 
down the tree until the assembly has been subdivided down 
into indivisible parts, i.e. one piece of geometry. If the Con- 
structive Solid Geometry* (CSG) method is used to describe 
the geometiy, then the hierarchy can move down even further. 
For example one might think of a bolt as being a quantum 
part, but it can be modeled as the union of a cylinder and 
a hexagonal prism. 

A physical object can be described as an interconnecting 
relationship between many ideas [3]. In applying this theory 
to design, one can see how various parts are linked together. 
Where two parts interact, each affect the design of the other. 
A simple example is a bolt in a hole. The information shared 
between the two parts is the diameter of the hole or the 
diameter of the bolt. Therefore an assembly of parts can be 
represented as a directed graph. 


Constructive Solid Geometry is a geometric modeling technique 
which generates complex geometric objects for the logical combina- 
tion (union, negation, intersection) of solid geometric primitives 
(sphere, cube, cone, etc.). 


CAD SYSTEM AND THEIR LIMITATIONS 

Current commercial CAD systems are geometric data base 
editors. The geometries are interactively entered into the 
system via commands from a keyboard, graphics tablet, or 
mouse. There are also commands to manipulate and display 
the data base. The programs use the geometric data along 
with other information to perform analysis such as in- 
terference checking, mass properties, mechanism simulation, 
and structural analysis. 

CAD systems do not have methods for storing the asso- 
ciativity of elements in their data base. Many systems have 
methods for grouping parts into one part. This makes the data 
base smaller and manipulation of the parts easier for the user. 
For dimensioning parts, systems can tie the dimension lines 
to the part geometries, so if the geometry is changed, the 
annotation changes automatically. The journaling capability 
can also be considered to provide associativity between parts. 
A journal file is made from the user’s interactive commands. 
If there is a change to be made, the user can edit the journal 
file and then execute it. Other systems provide what are called 
parameterized parts, a macro capability for defining solid 
geometries in the same format as the system uses. 

These methods provide the support needed for design, but 
they are deficient in two key areas. They do not explicitly 
support the iterative design process nor store limited part 
associativity. An example of their limitations follows. 

A truss structure is defined as four elements joined to 
represent a rectangle with a fifth element as a diagonal (an 
element being some prismatic bar). If the length of one of 
the sides is changed, the element joining the sides does not 
change position or length, and the connectivity between 
elements in the data base is not stored. 

To solve this problem, one could define the truss to be 
a parameterized part. This definition has limited usefulness, 
however. The truss does not change with a change in defini- 
tion, but must be removed and then recreated. Hence the idea 
of parameterized parts is useful mainly in data base creation, 
not in modification. 


1 


One could also use a journal file to define the truss. The 
designer edits the journal file to define the new truss, removes 
the current truss from the data base and execute the journal 
file— a process similar to the parameterized part. Although 
the journal file protects the user from loss of work, its use 
as a design generator has some problems. For one, there is 
a large overhead in interpreting the file to create a design. 
If used as a design generator the file actually becomes the 
data base, from which the system creates its internal data 
base. Since the journal file is a sequentially ordered list of 
commands, the user is responsible for inserting commands 
in the correct order. For menu driven systems this procedure 
is quite complicated, since the function of a command is 
predicated on the previous command. 

In designing the next iteration one favors the use of as much 
of the data base as possible in developing the next design. 
In CAD, as in board design, the process is a manual one. 
The designer must manually change the drawing to reflect 
new design considerations. Since the systems store limited 
part associativity, the designer must manually change all the 
affected parts in the event of a design change. Needed is a 
system that stores the part connectivity and uses as much of 
the design data base as possible between iterations. 

In summary, the problem with current CAD systems is they 
retain virtually none of the logic that controls the geometric 
shapes in the database, they are design documentors [4], They 
provide no more design support than current text editors pro- 
vide composition support. The analysis programs are 
equivalent to spelling checkers. 

SYSTEM REQUIREMENTS 

The functions a CAD system should exhibit in providing 
additional design support are now described. 

DESIGN AS A FUNCTION 

A mechanical design can be thought of as a set of 
mathematical functions where each function describes a 
dimension in the design. Some of these functions are con- 
stants, these can be thought of as design parameters. 
Therefore given n design functions fj,. . ., f n , k design 
parameters pi, ... , p k , one can define m dimensional 
parameters d 1? . . ., d m [5]. Depending on the design re- 
quirements each dimensional parameter dj is dependent on 
a subset of the design parameters p and other dimensional 
parameters d or: 

di = f; { di, . . d m , p,, . . pj } 

NETWORK DATA BASE FOR CAD 

This type of description can be represented as a directed 
graph, where each node is dj, the i th dimensional parameter 


or p k the k th design parameter, and the paths from the other 
nodes are the arguments to the function f[. The idea or con- 
cept of the design is represented by the network. An execu- 
tion of the design is produced by assigning numerical values 
to the parameters. 

Note that each path is directed. For example a bearing in 
' a pillow block, either the bearing defines the pillow block 
or vice versa. They cannot mutually define one another. One 
can see from the network that any change in a design 
parameter ripples through the design, generating a new ex- 
ecution of the idea represented by the network [6]. 

An example of a CAD system using a network data base 
and nodal values to define the solid geometries representing 
each part would be: 

dl = fl { Pi. P2. P9. • • • } 

d 2 = h { Pi. di, ... } 

d 3 = f3 { P2. di, P4, ... } 


parti is a cylinder with radius di, length d 2 , 
centered at (d 3 , d 4 , d 5 >. 

Of course d 3 can not be used in a function until it has been 
defined. The functions can consist of anything, strength of 
material laws, kinematics, dimension matching, random 
number generation, etc. 

CONTROL STRUCTURE 

If one represents the design as a network, what type of 
control structure would a program require? What types of 
ancillary functions would be needed to support the design? 
In describing the dimensional parameters, a procedural math 
based language is needed, something like FORTRAN, 
BASIC or APL would suffice. 

Most designs require the choice of some standard parts, 
i.e. structural steel, bolts, bearings etc. Since the method most 
useful for storing tabular data is a relational data base, this 
ingredient is included with the procedural language. 

But what about checking for legal dimensional parameters? 
Conditionals must be provided. That is not a problem— each 
function can check for legal values. What happens if a dimen- 
sional parameters is not legal? Does the design fail? If a 
design fails in trying to satisfy dimensional parameters, the 
control mechanism should back up and retry the previous 
function since it may have more than one solution available. 
What happens when more than one standard part will work 
in the design, implying a multiplicity of executions? The 
system should then generate all possible represented designs. 


2 


LOGIC PROGRAMMING 

A logic programming language called Prolog provides the 
three functions required to represent the design as a network: 
math based procedural language, relational data base, and 
automatic generation of all possible solutions. Prolog uses 
first order predicate calculus to represent its data and resolu- 
tion theorem proving to prove data base queries. The resolu- 
tion theorem prover performs a depth first search in order 
to resolve the predicates. For a description of the algorithm 
see [7]. For a description of the Prolog language see [8]. 

Although Prolog is not considered a mathematical language 
it contains all the FORTRAN intrinsic functions such as 
trigonometry, logarithms, bit manipulation, etc. Although 
APL is probably the best interactive language for vector or 
matrix operations, Prolog can work with lists of numbers. 
Inherent in Prolog is a relational data base. By defining 
predicates with the same name, a table can be created and 
searched. The generation of all possible solutions is also built 
into Prolog. The inference algorithm will generate all possi- 
ble solutions to a problem represented in the data base. 

Prolog Examples— Prolog predicates are broken down into 
two types, facts and rules. A fact is an assertion about 
something, such as the sky is blue. In Prolog this would be 
represented as: 

Example of a Prolog Fact, 
sky (blue). 

A rule is an assertion about something, such as the fac- 
torial of the number N is N times the factorial of N-l. In 
Prolog this would be: 

Example of a Prolog Rule. 

factorial(N, Answer) :- 
N1 is N-l, 
factorial(N 1 , A NS 1), 

Answer is ANSI * N. 

This is a recursive definition of factorial. It needs a fact 
as a terminal case, that is the factorial of one is one. 

Prolog Definition of Factorial. 

factorial(l,l). 
factorial(N, Answer) :- 
N1 is N-l, 
factorial(N 1 , ANS 1 ) , 

Answer is ANSI * N. 


LOGIC PROGRAMMING IN DESIGN 

Logic has been shown to be a good method for perform- 
ing design [13], and is being used in other systems. The use 
of a rule data base for CAD has been demonstrated in various 
applications consisting of architectural design, crankcase 
design, and v-belt drive design. 

The Carter system [9] uses a rule data base to design 
crankcases. Although this is not a general design program 
and does not provide graphical output, it does illustrate the 
use of a rule data base for design. The v-belt drive design 
program also uses a rule data base. It uses OPS5 instead of 
Prolog. In architectural design, Swinson describes the use 
of a fact dependency system, [11] and [12]. Another exam- 
ple of an architectural application isdemonstrated by Markusz, 
[13]. It uses Prolog to define a data base for the design of 
apartments. 

Although the systems describe are not general design pro- 
grams, they all use the idea of describing the design with 
logic. 

A “SATISFICING” SYSTEM 

Simon coined the word “satisficing” [14] to describe 
“decision methods that look for good or satisfactory solu- 
tions instead of optimal ones”. The CAD system proposed 
is a satisficing system. Given the design rules it will generate 
all the possible designs represented by the rules. This is dif- 
ferent from the idea of optimization. Optimization finds the 
values of the design variables which will yield the optimal 
value of an objective function. The classic example of an 
objective function in structural optimization is weight 
minimization. 

RULE BASED CAD SYSTEM 

The CAD system uses an entirely different data base than 
conventional systems. To represent the geometry, the data 
base consists of three parts: 

1. Predicates describing each node of the network. 
These are the design functions. 

2. Predicates which define the geometry in a 
parameterized form. 

3. Predicates which describe the hierarchical structure 
of the assembly. 

To display a design, the design predicate would have to 
be proven and the parameters passed to the geometric defini- 
tions for display. 

DATA BASE 

The system uses Prolog’s predicates as the data base. It 
is created directly by the user. The predicate’s name defines 
its data type. The data types supported are: 


3 


• DESIGN: A design 

• PART: Hierarchical Structure. 

• Geometric Data Types 

—REV CLOSED: Solid of Revolution. 

— REV__OPEN: Solid of Revolution. 

— SLE: Solid of Linear Extrusion. 

—SHE: Solid of Helical Extrusion. 

The arguments to the predicate consist of the following: 

• Name: Any legal Prolog structure* or atom the user 
wishes to identify the data element. Examples are 
“hello”, “123”, “0.5”, “part(34)”. 

• Attribute List: A Prolog list of structures containing 
auxiliary data. Such data items consist of color, densi- 
ty, reflectivity, or user documentation. It is open to the 
user to put any type of data the user deems useful. 

• Parameter List: This argument is used by the system 
to pass the parameters to the data section. If the ele- 
ment does not have any parameters it should be instan- 
tiated (defined) as a Prolog empty list, i.e. [], else it 
is a variable. 

• Data: The data structure contains various structures 
depending upon the element’s data type defined by the 
predicate’s name. The system uses the data stoied here 
to display what ever is defined. 

DESIGN FUNCTION 

The design function is executed in a design predicate. The 
data to this predicate has two arguments. One is a predicate 
which returns a list of parameters. The second is a list of 
element names (corresponding to the name field) used in the 
design. To generate all the designs represented by the rules, 
the program uses Prolog’s built in backtracking. It calls the 
design function to get the parameter list, displays the 
elements, and then by intentionally failing incurs the 
backtracking algorithm of the resolution theorem prover to 
try to prove the predicate a different way. 
design( Name, Attributes , 
data( 

Design predicate, elements( element 1, ..., 

element n ) 

))• 

Geometry— The system defines solids by sweeping a 
planer closed curve down another curve. This is one of many 
methods for representing solid geometry for CAD [16]. It 
was chosen for its compactness. 

All the geometric definitions have two data items in com- 
mon. They all have a planer curve definition and all are 
rotated and translated by a general transformation matrix. See 
appendix A for examples of each definition. 

*A Prolog structure is essentially a named list, e.g. radius (1.5, 
inches) is a structure of arity two. Its name or principal functor is 
“radius”, a Prolog atom. Structures may contain other structures. 


Solid Of Revolution— 

rev open( Name , Attributes , Parameters, 

data( angle( Theta ), 

rf( Offset(X,Y,Z), angles( Yaw, Pitch, 
Roll)), 

curve( curve definition ) 

)). 

rev closed( Name , Attributes , Parameters, 

data( angle( Theta ), 

rf( Offset(X,Y,Z), angles( Yaw, Pitch, 
Roll)), 

curve( curve definition ) 

))• 

Solid Of Linear Extrusion— 
sle( Name, Attributes, Parameters, 

data( delta( Delta X, Delta Y, Delta Z), 

rf( Offset(X,Y,Z), angles( Yaw, Pitch, 
Roll)), 

curve( curve definition ) 

))■ 

Solid Of Helical Extrusion— 
she( Name, Attributes, Parameters, 
data( 

length( L ), mean radius( R ), pitch( P ), 

rf( Offset(X,Y,Z), angles( Yaw, Pitch, 
Roll)), 

curve( curve definition ) 

)). 

Part . A part is a hierarchical structure. It is an element which 
contains other elements. Along with passing the parameters to the 
elements in the list it can also define local parameters to the elements. 
Local parameters are stored in the element parameters list struc- 

ture. It can be used to define standard parts. 
part( Name, Attributes, Parameters, 
data( 

rf( Offset(X,Y,Z), angles( Yaw, Pitch, 
Roll)), 

elements( element 1 , element 2 , 

. . . , element n) , Element Parameters 

))• 

Structure Definitions — 

• rf( Offset(X,Y,Z), angles( Yaw, Pitch, Roll)) is a general 
transformation matrix. The part is rotated by the angles Yaw, 
Pitch, Roll, (Theta-z, Theta-y, Theta-x) and then is translated 
by X,Y,Z. The angles are in degrees. The XYZ convention 
is used to define the rotation matrix [17]. 

• curve definition is a closed curve defined in the x-y plane. 

It consists of a list of verticies and circular arc definitions. 
The starting and ending verticies must coincide for a closed 
curve arc and it must be defined in the counter-clockwise 
direction. 

• A vertex is described as v(X,Y), a point in the x-y plane. 

• A circular arc drawn counter-clockwise is described as 

arc(s(SX,SY),c(CX,CY),e(EX,EY)). Where (SX,SY) is the 
start point of the arc, (CX,CY) is the center of the arc, and 
(EX,EY) is the end point of the arc. All the points lie in the 
x-y plane. A clockwise arc is described using the structure 
name arc cw instead of arc. 


4 


EXECUTION 

The CAD system runs on a VAX 1 1/780 under VMS ver- 
sion 3.4 operating system. It uses a Prolog interpreter 
marketed by Prologica located in King of Prussia, Penn- 
sylvania. For a description of the Prolog interpreter see [18]. 
The interpreter is virtual memory based and can interface with 
other languages. This feature was used in the system to pro- 
vide the display interface to the various graphical devices. 

The Prolog part of the system defines the data base and 
generates the model for display. A FORTRAN sub-system 
is used in mapping the three dimensional world model to the 
two dimensional screen. The Prolog consists of approximately 
1300 lines of code and documentation, the FORTRAN part 
consists of approximately 3000 lines of code and documen- 
tation. See appendix C for a list of the main body of the Pro- 
log code which produces a design from the user defined 
predicates. 

PISTON EXAMPLE 

A spring loaded piston is used to demonstrate the CAD 
system. It is a piston in a cylinder with two opposing springs. 
The device was used in a robotics experiment and was design- 
ed on a commercial CAD system in 1981. See appendix B 
for the Prolog predicates which define the piston. The model 
produced by the rule based CAD system is shown in figures 
7,8 and 9 with the element “housing” shown sectioned for 
clarity. Only one of the four possible designs is shown. Table 
1 contains the parametric values defined by the design 
predicate ‘piston*. The names shown in this table correspond 
to the structure definitions defined in the predicate ‘piston’. 
These structure definitions also correspond to the structure 
definitions in the solid geometric definitions. 

DESCRIPTION OF THE PISTON DESIGN 

The design is parameterized by five parameters: 

• Minimum travel. 

• Load range, minimum and maximum. 

• Rod diameter. 

• Wall thickness. 

The choice of design parameters was not arbitrary, but the 
set shown is not necessarily the fundamental set. The wall 
thickness is dependent on the load range. Along with design 
parameters there are certain functional and geometric con- 
straints which must be met. These were formulated in a 
predicate called “constraint”. 


Design Constraints 

1. Spring must meet load constraints 

2. Rod must fit inside the spring. 

3. Spring must have desired travel. 


4. Bearings must fit the rod. 

Note for item 4 how Prolog is used to search for an ex- 
plicit match. The predicate “ball bushing” also instantiates 

the dimensions of the ball bushing. 

In the section defined as “spring data” note that more than 
one spring was defined. Stock springs were used to 
demonstrate the relational data base capability of Prolog and 
how it was used in the CAD system. 

The predicate “piston” is the user defined design predicate 
which defines all the dimensions required for the geometric 
elements. It first instantiates the design parameters by call- 
ing the “spec ’’predicates. The rest of the predicate defines 
the other geometric parameters and checks if they are valid 
by use of the “constraint” predicate. Inter-part connectivity 
is accomplished by arithmetic expressions defining 
parameters to be passed to the geometric definitions. Some 
examples of connectivity in the piston design are: 

• Inside diameter of piston housing defined by the out- 
side diameter of the spring. 

• The length of the piston housing is defined by the 
springs, desired travel, bearing length, and housing 
thickness. 

• The rod length is defined by the bearing spacing, bear- 
ing lengths, and compressed lengths of the springs. 

The directed graph representing the design connectivity is 
shown in figure 6. The variable names correspond to the 
variable names used in the predicate “piston” (variables 
begin with a capital letter). 

PISTON REDESIGN 

New design possibilities are performed by changing the 
“spec” predicates or by changing the design predicate or by 
adding more standard parts to the data base such as springs 
and bearings. If the predicate “spec(travel(1.0))” is chang- 
ed to “spec(travel(1.5))” the only design possibility is design 
possibility 2 in table 1. 

To illustrate how a modification was performed on the 

design, two parts, internal cap and lvdt cap, were 

modified. Instead of butting against the rod a spot face was 
added to the caps so the rod fits in a blind hole. Appendix 
B contains the code for the complete definition of the rede- 
fined piston with new or modified predicates italicized. Table 
2 contains the new parameters for the design and figures 10, 
1 1 and 12 show the new piston. The only solid geometry 
definition changed was that of the element called “cap”. 
Three equations were changed to reflect the addition of the 
spotface and one predicate was added to relate the spotface 
depth with the rod diameter. 

The length of the Prolog code in appendix B may seem 
unduly long to represent the eight parts making up the piston. 
More than just geometries are defined, the logical connec- 
tion between parts is represented, a relational data base of 
stock springs is defined, and the geometry is represented in 
parametric form. 


5 


CONCLUSION 

The rule based CAD system described provides three func- 
tions of a design system by : 1 . supporting the iterative nature 
of the design process, 2. defining the associativity between 
parts in a design, and 3. allowing explicit design by 
parameters and functions. As can be seen from the piston 
example, new design executions can be obtained by chang- 
ing the “spec” predicates. Iterations are performed by re- 
fining the rule data base and the geometric elements are 
described explicitly as a function of design parameters. 

Prolog was used because it is a rule based language. Using 
its resolution theorem prover to resolve the design represented 
in its rule data base, it automatically generates all possible 
solutions. Its predicates and list structures provide a flexible 
representation of the solid models and of the design functions. 

In preliminary design, much of the design time is spent 
examining the effect parameter changes have on the design’s 
configuration. If the connectivity between mating parts is 
defined in the data base, a new design can be generated easily 
by changing a parameter or a rule. This increases the effi- 
ciency of the process. 

The goal of this research is to develop a technique for 
design synthesis. In design synthesis, the concept is described 
in physical functions and capabilities rather than in geometric 
terms. The CAD system developed here is a step toward that 
goal in that it was used to develop the kinds of data struc- 
tures and knowledge representations that define the required 
geometric interrelationships of a mechanism. 

The next steps in this research requires use of this program 
as a design generator, the incorporation of test functions to 
evaluate the designs and the heuristics to alter the rule data 
base. Design synthesis could then be realized through the use 
of generic design rules, a data base of parts and a translator 
to convert functions and capabilities to geometric terms. 

REFERENCES 

1 . Dixon, J.R., M.K. Simmons, P.R. Cohen, An Architec- 
ture for Application of Artifical Intelligence to Design, 
ACM IEEE 21st Design Automation Conference Pro- 
ceeding 1984. 

2. Katajma, Katsuhiro, Hiroyuki Yoshikawa, 
HIMADES-1: A Hierarchical Machine Design System 
Based on the Structure Model for a Machine, Computer 
Aided Design , Volume 16, number 6, 1984. 


3. Alexander, Christopher, Notes on the Synthesis of Form, 
Harvard University Press, Cambridge, Massachusetts, 
1970. 

4. Sambura, Andrzej S., and John S. Gero, Framework for 
a Computer Integrated Design Environment, Proceeding 
of the IFIP WG 5.2 Working Conference on CAD Systems 
Framework , Roros, Norway, 15-17 June 1982, Edited 
by K. BO and F.M. Lillehagen, North-Holland 1983. 

5. Asimow, Morris, Introduction to Design, Prentice-Hall, 
1962. 

6. Hiroyuki Yoshikawa, CAD Framework Guided by 
General Design Theory, CAD Systems Framework , Pro- 
ceeding of the IFIP WG 5.2 Working Conference on 
CAD Systems Framework, Roros, Norway, 15-17 June 
1982, Edited by K. BO and F.M. Lillehagen, North- 
Holland 1983. 

7. Nilsson, Nils J., Principles of Artificial Intelligence, 
Tioga Publishing Co., 1980. 

8. Clocksin, W.F., Mellish, C.S., Programming in Pro- 
log , Springer- Verlag, 1981. 

9. Reynier, Marie, Fouet, Jean-Marc, Automated Design 
of Crankcases: The Carter System, Computer Aided 
Design , Volume 16, Number 6, November 1984. 

10. Dixon, J.R., Simmons, M.K., An Architecture for Ap- 
plication of Artificial Intelligence to Design, ACM IEE 
21st Design Automation Conference, Proceedings ’84. 

1 1 . Swinson, Peter S.G. , Fernando C.N. , Bijl, Aart, A Fact 
Dependency System for the Logic Programmer, Computer 
Aided Design, Volume 15, Number 6, November 1983. 

12. Swinson, Peter S.G., Prolog: A Prelude to a New 
Generation of CADD, Computer Aided Design, Volume 
15, Number 6, November 1983. 

13. Markusz, Asuzsanna, Design in Logic, Computer Aid- 
ed Design, Volume 14, Number 6, November 1982. 

14. Simon, Herbert A., The Sciences of the Artificial, MIT 
Press, 2nd Edition, pp 138-139. 

15. Schmit, Lucien A., Structural Synthesis - Its Genesis 
and Development, AIAA Journal, Volume 19, Number 
10, October 1981. 

16. Aristides A.G. Requicha, Representations for Rigid 
Solids: Theory, Methods, and Systems, Computing 
Surveys, Volume 12, Number 4, December 1980. 

17. Goldstein, Herbert, Classical Mechanics, Addison- 
Wesley, Second Edition, July 1981. 

18. Prolog- 1 Language Reference Manual, Issue 2, March 
1984, Expert Systems Limited, 9 West Way, Oxford 
OX2 OJB 


6 


APPENDIX A 


ELEMENT DEFINITIONS 


This appendix contains examples of element definitions along with the solid geometry they represent. 


ELEMENT DEFINITIONS 


sle( figure 1 , 

[ comment) ' Example of user documentation’) ] , [] , 
data( 

delta( 0.1E1 , 1 , 5.5), 
rf( offset( 0,0,0), angles(0,0,0)), 
curve( v(0,0), arc( s(4,0), c(4,2), e(4,4)), 
v(0,4), v(0,0)))). 


v(0,4) e(4,4) 



Figure 1. Solid of Linear Extrusion. 


A-2 



ELEMENT DEFINITIONS 


rev closed( figure2, [], [] , 

data( 

angle(36.0), 

rf( offset( 0,0,0), angles(30,45,0)), 
curve( 


v f0 Yt vf4 Y) 

arci_cw( s(4,YP) , c(2,YP), e(0,YP) ), 
v(0,Y) 

))) Y is 3.0, YP is Y + 4.0, !. 



Figure 2. Solid of Revolution - Closed Curve. 


A-3 


ELEMENT DEFINITIONS 


rev — open( figure3 ,[],[], 
data( 

angle(360.0), 

rf( offset(0,0,0), angles(30,45,0», 

curve( arc( s(5,0), c(2.5,0), e(0,0)) 

)))• 



ELEMENT DEFINITIONS 


part( figure4 ,[],[], 
data( 

rf( offset(l,2,3), angles( 0,0,0)), 
elements( ball, tube ), 

[ ball(center([0,0,0]), radius(C)), 
tube( id(ID), od(OD), length(L)) ] 

)) 

C is 2.0, 

ID is C * 2 , OD is ID + 1, L is C*3, !. 

rev open( ball, [] , Parameters , data( 

angle(360.0), 

rf( OFFSET , angles(0,0,0)), 
curve( 

arc( s(RAD,0), c(0,0), e(-(RAD),0)) 

))) 

param( ball(center(CENT), radius(RAD)), 

Parameters), 

OFFSET =.. [offset|CENT], !. 

rev closed( tube , [] , Paramters , data( 

angle(360.0), 

rf( offset(0,0,0), angles(0,0,0)), 

curve( v(Xl,Yl), v(X2,Yl), v(X2,Y2), v(Xl,Y2), v(Xl,Yl) 

))) 

param( tube( id(ID), od(OD), length(L)), Paramters ), 

XI is 0.0, 

Y1 is ID / 2, 

X2 is L + XI, 

Y2 is OD * 0.5, 



Figure 4. Part Definition with Parameters. 


A-5 


ELEMENT DEFINITIONS 


part( figures, [],[], 
data( 

rf( offset(0,0,0), angles(30,75,0)), 

elements( spring), [ spring( od(4), wire dia( 0.25 ), 

pitch(l), length(4)) ])):-!. 
she( spring, [], Params, 
data( 

length(L), mean radius(R), pitch(P), 

rf( offset(0,0,0), angles(0,0,0)), 
curve( arc( s(SX,0), c(0,0), e(SX,0)) 

) 

)) 

param( spring( od(OD), wire dia(WD), pitch(P), 

length(L)), Params), 

R is (OD -WD) * 0.5, 

SX is WD / 2.0, !. 



Figure 5. Solid of Helical Extrusion. 


A-6 


APPENDIX B 


SPRING PISTON EXAMPLE 


new reconsult(pistonl), consult(userlib), !. 


/* 


*/ 


DESIGN SPECIFICATIONS 


/* At least this Travel */ 

spec(travel(1.0)). 

spec(load max(30.0)). /* At solid height */ 

spec(load min( 10.0)). 

spec(rf(offset(0.0,0.0,0.0),angles(0. 0,0.0, 0.0))). 

spec(thickness(0 . 25)) . 

spec(identity( 

rf(offset(0. 0,0.0, 0.0), angles(0.0, 0.0, 0.0)) 

)). 

spec( rod,diameter(0.375)). 
spec( rod,offset(0.0)). 


DESIGN CONSTRAINTS 


constrain^ load , Load at solid height, Max load, Min load ) 

Load at solid height < Max load. 

Load at solid height > Min load. 

constraint travel, Travel , Free_length , Solid height ) 

Travel < Free length - Solid height. 

constraint rod and spring , Spring ID, Rod_diameter ) 

Spring ID > Rod diameter. 


design( piston , data( 

piston , elements(rod,bearingl,bearing2, 

internal cap,lvdt — cap , housing, springl, spring2) )) 

! . 


/* 


*/ 


PISTON DESIGN PREDICATE 


B-l 



piston( [ 

rod( length(Rod length)), 

rod( diameter( Rod diameter)), 

rod( offset( Rod offset)), 

spring 1( offset( S X)), 

spring( id( Spring__ID)), 

spring( od( Spring OD)), 

spring( length( Compressed length)), 

spring2( offset( S X2)), 

bearing( id( Bearing ID)), 

bearing( od( Bearing OD)), 

bearing( len( Bearing len)), 

bearing 1( offset( B oxl)), 

bearing2( offset( B ox2)), 

housing( 

radii( 

H spring radius, H bearing radius, 

H rodclear radius, H outside radius), 

lens( H springtravel , H bearings, H rod ), 

rf( offset(H offset, 0,0) , angles(0,0,0)) 

), 

cap( thickness( Cap thickness), od( Cap OD) ), 

cap rf( offset( 0,0,0), angles(0,0,0)), 

Ivdt cap rf( offset(LVDT offset, 0,0) , angles(0, 180,0) ) 

] ) 

spec( load max( Load maximum)), 

spec( load min( Load minimum)), 

spec( travel( Travel)), 
spec( thickness( Thick)), 

spec( rod,diameter(Rod diameter)), 

spec( rod,offset(Rod offset)), 

spring(Spring name, od(Spring OD),hd(Spring hd), 

wd(Spring wiredia),load sh(Load at solid height), 

fl(Free length), k(Spring K), sh(Solid height) ), 

/* Find a valid spring *1 

constraint load. Load at solid height , Load maximum , 

Load minimum ), 

constraint travel, Travel , Free length , Solid height ), 

ball bushing(Type ,bore(Rod diameter) ,od(Bearing OD) , 

len(Bearing len)) , 

Spring ID is Spring OD - 2 * Spring wiredia, 

/* Rod must fit inside the spring */ 

constraint rod and spring , Spring ID, Rod diameter ), 


B-2 



DEFINE PART ASSOCIATIVITY 


Compressed length is Free length * 0.45 , 

Distance between bearings is 3 * Bearing len, 

S X is Rod offset , 

S X2 is S X + Compressed length + 

Distance between bearings + Thick, 

Rod length is 

Distance between bearings 

+ (Compressed length * 2.0) + Thick , 

Cap thickness is Thick, 

Cap OD is Spring hd, 

Bearing ID is Rod diameter, 

B oxl is Compressed length + S X, 

B ox2 is B oxl + 2.0 * Bearing len, 

H spring radius is ( Cap OD * 0.5 ) +0.1, 

H bearing radius is Bearing OD * 0.5, 

H rodclear radius is Rod diameter * 0.5 + 0.010, 

H springtravel is Cap thickness + Compressed length 

+ Travel, 

H bearings is Distance between bearings , 

H rod is Thick, 

H outside radius is H spring radius + Thick, 

H offset is — (H springtravel) + Compressed length , 

LVDT offset is Rod length. 


LINEAR BEARING DATA BASE 
THOMPSON LINEAR BEARING CO 


ball bushing(’XA-61014\bore(0. 375), od(0. 6250), len(0. 875)). 


STOCK SPRING DATA BASE 
LEE SPRING COMPANY 


B-3 



springC LC-055 J -6 ’ , od(0.720),hd(0.75),wd(0.055), 

load sh(13.0),fl(1.75),k(9),sh(0.4) ). 

springC LC-055 J-7\ od(0.720),hd(0.75),wd(0.055), 

load sh( 1 3 .0) ,fl(2 .0) ,k(8 . 5) ,sh(0.42 1 ) ). 

springC LC-055J-5’, od(0.720),hd(0.75),wd(0.055), 

load sh(13.0),fl(1.50),k(11.5),sh(0.331) ). 

springe LC-065J-5’, od(0.720),hd(0.75),wd(0.065), 

load sh( 1 9 . 0) , fl( 1 . 50) , k( 1 9 . 0) , sh(0 .465) ). 

spring(’LC-063h-5 ’ , od(0.600),hd(0.625),wd(0.063), 

load sh(23.0),fl(l .250),k(30.0),sh(0.457) ). 



part(rod,[color(green)],P,data( 

Identity, 

elements(cylinder) , 

[ 

radius(RAD), 
center([0. 0,0. 0,0.0]), 
length(LEN), 
axis( X unit ) 

] 

)) 

spec(identity (Identity)) , 

param( rod(diameter(D)),P), 
param( rod(length(LEN)), P ), 

x unit(X unit), 

RAD is D / 2 , !. 

part(springl,[],P, 

data( 

rf(offset(X ,0,0) , angles(0 ,90,0)), 
elements(spring), 

U 

)) 

param(spring 1 (offset(X)) , P) , 


B-4 



she(spring,[color(red)] ,P, 
data( 

length(Spring length) , mean__radius(Mean_radius) , 

pitch(Pitch), 

rf( offset(0,0,0), angles(0,0,0) ), /* was 
offset(X,0,0) */ 

curve( arc( s(Wire start, 0),c(Wire center, 0), 

efWire start, 0))) 


)) > 

param(spring(length(LEN)) , P) , 

param(spring(id(ID)),P), 

param(spring(od(OD)),P), 

Mean__radius is ( ID + OD) / 4, 

Spring length is LEN, 

Wire dia is ( OD - ID)/2, 

Wire start is Wire dia / 2, 

Wire center is 0.0, 

Pitch is 4.0, 

i, 

part(spring2 , [color(blue)] ,P, 
data( 

rf(offset(X,0,0),angles(0,90,0)), 

elements(spring), 

[] 

)) •- 

param( spring2( offset(X) ),P), 


part(bearing,[],P, 

data( 

rf( offset(0,0,0), angles(0,0,0) ), 
elements(tube), 

[ tube( id(ID), od(OD), len(LEN), 

center([ X, 0.0, 0.0]), axis(Xaxis)) ] 

)) 

x unit( Xaxis), 

param(bearing(len(LEN)) , P) , 
param(bearing(id(ID)) , P) , 
param(bearing(od(OD)) , P) , 
param(center x(X) , P) , 


part(bearing2,[color(yellow)],P, 

data( 

rf(RFO,RFA), 
elements(bearing) , 

[ center x(X) ] 

)) 


B-5 


spec(rf(RFO,RFA)) , 

param( bearing2( offset(X) ),P), 


part(bearing 1 , [color(yellow)] ,P, 
data( 

rf(RFO,RFA), 

elements(bearing), 

[ center x(X) ] 

)) > 

spec(rf(RFO,RFA)), 

param( bearing 1( offset(X) ),P), 


rev closed( housing , 

[ color(blue), 

comment^ The piston housing enclosing the mechanism’)], 

Parameters, 

data( 

angle( 180 ), 

rf(OFFSET ,angles(0, 0,180)), 
curve( 

v(Xl,Y4), v(X4,Y4), v(X4,Yl), 
v(X3,Yl), v(X3,Y2), v(X2,Y2), 
v(X2,Y3), v(Xl,Y3), v(Xl,Y4)) 

)) > 

param( 

housing( 

radii( 

H spring radius, H bearing radius, 

H rodclear radius, H outside radius), 

lens( H springtravel , H bearings, H rod ), 

rf( OFFSET, ANGLES )), 

Parameters ), 

XI is 0.0, 

X2 is H springtravel, 

X3 is X2 + H bearings, 

X4 is X3 + H rod, 

Y1 is H rodclear radius, 

Y2 is H bearing radius, 

Y3 is H spring radius, 

Y4 is H outside radius, !. 

sle(junk, , , ) !. 

part(l vdt cap, [color(cy an)] , P,data( 

rf( Offset , Angles ), 
elements( cap ),[] )) 

param( lvdt cap rf( Offset, Angles ) , P),!. 


/ B-6 


part(intemal cap, [color(yellow)] ,P,data( 

rf( Offset , Angles ), 

elements( cap ),[] )) 

param( cap rf( Offset, Angles ) , P),!. 

sle( cap, [] , Params , data( 
delta( 0,0 , Length ), 
rf( OFF , angles( 0,-(90),0)), 
curve( arc( s( XI, 0), c( 0,0),e(Xl,0») 
)) 

spec(identity(rf(OFF, ))), 

param( cap( thickness(Cap thickness), 

od( Cap OD) ), Params), 

XI is Cap OD * 0.5, 

Length is Cap thickness, !. 


SPRING PISTON EXAMPLE 


Table 1. Design Possibility 1. 

rod 

length 4.4500 

rod 

diameter 0.3750 

rod 

offset 0.0 

spring 1 

offset 0.0 

spring 

id 0.6100 

spring 

od 0.7200 

spring 

length 0.7875 

spring2 

offset 3.6625 

bearing 

id 0.3750 

bearing 

od 0.6250 

bearing 

len 0.8750 

bearing 1 

offset 0.7875 

bearing2 

offset 2.5375 

housing 


radii 

0.4750 

0.3125 

0.1975 

lens 

2.375 

2.6250 

0.2500 

rf 

offset 

-1.2500 

0.0 

0.0 

angles 0.0 

0.0 

0.0 


cap 

thickness 

od 

0.2500 

0.7500 



cap rf 

offset 

0.0 

0.0 

0.0 

angles 

0.0 

0.0 

0.0 

lvdt cap rf 

offset 

4.4500 

0.0 

0.0 

angles 

0.0 

180.0 

0.0 


B-8 


Table 1. Design Possibility 2 , 


rod 

length 4.6750 

rod 

diameter 0.3750 

rod 

offset 0.0 

spring 1 

offset 0.0 

spring 

id 0.6100 

spring 

od 0.7200 

spring 

length 0.9000 

spring2 

offset 3.7750 

bearing 

id 0.3750 

bearing 

od 0.6250 

bearing 

len 0.8750 

bearing 1 

offset 0.9000 

bearing2 

offset 2.6500 

housing 


radii 

0.4750 

0.3125 

0.1975 

lens 

2.1500 

2.6250 

0.2500 

rf 

offset 

-1.2500 

0.0 

0.0 

angles 

0.0 

0.0 

0.0 

cap 

thickness 

od 

0.2500 

0.7500 



cap rf 

offset 

0.0 

0.0 

0.0 

angles 

0.0 

0.0 

0.0 

lvdt cap rf 

offset 

4.6750 

0.0 

0.0 

angles 

0.0 

180.0 

0.0 


0.7250 


Table 1. Design Possibility 3. 


rod 

length 4.2250 

rod 

diameter 0.3750 

rod 

offset 0.0 

spring 1 

offset 0.0 

spring 

id 0.6100 

spring 

od 0.7200 

spring 

length 0.6750 

spring2 

offset 3.5500 

bearing 

id 0.3750 

bearing 

od 0.6250 

bearing 

len 0.8750 

bearing 1 

offset 0.6750 

bearing2 

offset 2.4250 

housing 


radii 

0.4750 

0.3125 

0.1975 

lens 

1.9250 

2.6250 

0.2500 

rf 

offset 

-1.2500 

0.0 

0.0 

angles 

0.0 

0.0 

0.0 

cap 

thickness 

od 

0.2500 

0.7500 



cap rf 

offset 

0.0 

0.0 

0.0 

angles 

0.0 

0.0 

0.0 

Ivdt cap rf 

offset 

4.2250 

0.0 

0.0 

angles 

0.0 

180.0 

0.0 


0.7250 


B-10 


Table 1. Design Possibility 4 


rod 

length 4.2250 

rod 

diameter 0.3750 

rod 

offset 0.0 

spring 1 

offset 0.0 

spring 

id 0.5900 

spring 

od 0.7200 

spring 

length 0.6750 

spring2 

offset 3.5500 

bearing 

id 0.3750 

bearing 

od 0.6250 

bearing 

len 0.8750 

bearing 1 

offset 0.6750 

bearing2 

offset 2.4250 

housing 


radii 

0.4750 

0.3125 

0.1975 

lens 

1.9250 

2.6250 

0.2500 

rf 

offset 

-1.2500 

0.0 

0.0 

angles 

0.0 

0.0 

0.0 

cap 

thickness 

od 

0.2500 

0.7500 



cap rf 

offset 

0.0 

0.0 

0.0 

angles 

0.0 

0.0 

0.0 

lvdt cap rf 

offset 

4.2250 

0.0 

0.0 

angles 

0.0 

180.0 

0.0 


B-ll 









































B-13 





SPRING PISTON EXAMPLE 



B-15 


SPRING PISTON EXAMPLE 
Redesigned Spring Piston Definition 


/* 


*/ 


DESIGN SPECIFICATIONS 


/* At least this Travel */ 

spec(travel(1.0». 

spec (load max(30 . 0)) . 

spec(load min( 10.0)). 

spec(rf(offset(0.0,0.0,0.0),angles(0.0,0.0,0.0))). 

spec(thickness(0 . 25)) . 

spec(identity( 

rf(offset(0.0,0.0,0.0),angles(0.0,0.0,0.0)) 

)). 

spec( rod,diameter(0.375)). 
spec( rod,offset(0.0)). 


/* 


*/ 


DESIGN CONSTRAINTS 


constraint load , Load at solid height, Max load, Min load ) 

Load at solid height < Max load, 

Load at solid height > Min load. 

constraint travel, Travel , Free length , Solid height ) 

Travel < Free length - Solid height. 

constraint rod and spring , Spring ID, Rod diameter ) 

Spring ID > Rod diameter. 


design( piston , data( 

piston , elements(rod,bearingl,bearing2, 

internal cap,lvdt cap ,housing, springl, spring2) )) 

i 


/* 


*/ 


PISTON DESIGN PREDICATE 




piston( [ 

rod( length(Rod length)), 

rod( diameter( Rod diameter)), 

rod( offset( Rod offset)), 

spring 1( offset( S X)), 

spring( id( Spring_JD)), 

spring( od( Spring OD)), 

spring( length( Compressed length)), 

spring2( offset( S X2)), 

bearing( id( Bearing ID)), 

bearing( od( Bearing OD)), 

bearing! len( Bearing len)), 

bearing 1( offset! B oxl)), 

bearing2( offset! B ox2)), 

housing! 

radii( 

H spring radius, H bearing radius, 

H rodclear radius, H outside radius), 

lens( H springtravel , H bearings, H rod ), 

rf( offset(H offset,!),!)) , angles(0,0,0)) 

), 

cap! thickness! Cap thickness), od( Cap OD) ), 

cap rf( offset! 0,0,0), angles!0,0,0)), 

lvdt cap rf( offset(LVDT offset, 0,0) , angles(0, 180,0) ), 

cap spotface(Cap_spotface) 

] ) 

spec! load max( Load maximum)), 

spec! load min( Load minimum)), 

spec! travel! Travel)), 
spec( thickness! Thick)), 

spec! rod,diameter(Rod diameter)), 

spec! rod,offset!Rod offset)), 

spring(Spring name, od!Spring OD) ,hd(Spring hd) , 

wd!Spring wiredia),load sh(Load at solid height), 

fKFree length), k(Spring K), sh(Solid height) ), 

/* Find a valid spring */ 

constraint! load. Load at solid height , Load maximum 

, Load minimum ), 

constraint! travel. Travel , Free length , Solid length ), 

ball bushing(Type ,bore(Rod diameter), od(Bearing OD), 

len(Bearing len)), 

/* Rod must fit inside the spring */ 


B-17 


Spring ID is Spring_OD - 2 * Spring_wiredia, 

constraint^ rod and spring , Spring ID, Rod diameter ), 


/* 


*/ 


DEFINE PART ASSOCIATIVITY 


Compressed length is Free length * 0.45 , 

Distance between bearings is 3 * Bearing — len, 

spotface depth ( Cap spotface , Rod diameter ), 

S X is Rod offset + Cap spotface, 


S X2 is S X + Compressed length + 

Distance between bearings 


+ Thick, 


Rod length is 

Distance between bearings 

+ (Compressed length *2.0) 4- Thick + 

2 * Cap_spotface , 

Cap thickness is Thick, 

Cap thickness OFFSET is 0 , /* Prolog quirk */ 

Cap OD is Spring hd. 

Bearing ID is Rod diameter, 

B oxl is Compressed length + S X, 

B ox2 is B oxl 4- 2.0 * Bearing len, 

H spring radius is ( Cap OD * 0.5 ) +0.1, 

H bearing radius is Bearing OD * 0.5, 

H rodclear radius is Rod diameter * 0.5 + 0.010, 

H springtravel is Cap thickness + Compressed length 

+ Travel, 

H bearings is Distance between bearings , 

H rod is Thick, 

H outside radius is H spring radius + Thick, 

H .offset is - (H springtravel) + Compressed length 

+ Cap spotface , 

LVDT offset is Rod length. 


/* 


*1 


LINEAR BEARING DATA BASE 
THOMPSON LINEAR BEARING CO 


ball bushing(’XA-61014’,bore(0.375),od(0.6250),len(0.875)). 


B-18 




/* 


*/ 


STOCK SPRING DATA BASE 
LEE SPRING COMPANY 


spring(’LC-055J-6’ , od(0.720),hd(0.75),wd(0.055), 

load sh( 1 3 .0) ,fl( 1 .75) ,k(9) ,sh(0.4) ). 

spring(’LC-055J-7’, od(0.720),hd(0.75),wd(0.055), 

load sh(13.0),fl(2.0),k(8.5),sh(0.421) ). 

spring(’LC-055J-5 ’ , od(0.720),hd(0.75),wd(0.055), 

load sh(13.0),fl(1.50),k(11.5),sh(0.331) ). 

spdng(’LC-065J-5’ , od(0.720),hd(0.75),wd(0.065), 

load sh(19.0),fl(1.50),k(19.0),sh(0.465) ). 

spring(’LC-063h-5 ’ , od(0.600),hd(0.625),wd(0.063), 

load — sh(23.0),fl(1.250),k(30.0),sh(0.457) ). 

/* Spot face definition */ 

spotface_depth ( SF , RD ) 

SF1 is RD / 4.0, 

/* Make it a fraction of eights. */ 

make integral fraction ( SF1 , 8.0, SF ), 

SF> 0, !. 

spotface depth ( 0.125 , ) :-!. 


Make integral_fraction( R , FRAC, IF ) 

IF is float ( round(R * FRAC)) / float(FRAC), !. 


SOLID GEOMETRY DEFINITIONS 


part(rod,[color(green)],P,data( 

Identity, 

elements(cylinder) , 

[ 

radius(RAD), 
center([0.0,0.0,0.0]), 
length(LEN), 
axis( X unit ) 

] 

)) 

spec(identity(Identity )) , 


B-19 



param( rod(diameter(D)),P), 
param( rod(length(LEN)), P ), 

x unit(X unit), 

RAD is D / 2 , !. 

part(springl,[],P, 

data( 

rf(offset(X,0,0),angles(0,90,0)), 

elements(spring), 

[] 

)) 

param(spring 1 (offset(X)), P) , 


she(spring,[color(red)],P, 

data( 

length(Spring length) , mean radius(Mean radius) , 

pitch(Pitch), 

rf( offset(0,0,0), angles(0,0,0) ), /* was 
offset(X,0,0) */ 

curve( arc( s(Wire start, 0),c(Wire center.O). 

e(Wire start, 0))) 


)) 

param(spring(length(LEN)) ,P) , 
param(spring(id(ID)) ,P) , 
param(spring(od(OD)) ,P) , 

Mean_radius is ( ID + OD) / 4, 

Spring length is LEN, 

Wire dia is ( OD - ID)/2, 

Wire start is Wire dia / 2, 

Wire center is 0.0, 

Pitch is 4.0, 

I 

part(spring2 , [color(blue)] ,P, 
data( 

rf(offset(X,0,0),angles(0,90,0)), 

elements(spring), 

[] 

)) > 

param( spring2( offset(X) ),P), 


part(bearing,[],P, 

data) 

rf( offset(0,0,0), angles(0,0,0) ), 
elements(tube), 

t tube) id(ID), od(OD), len(LEN), 

center([ X, 0.0, 0.0]), axis(Xaxis)) ] 

)) 

x unit) Xaxis), 


B-20 



param(bearing(len(LEN)) , P) , 
param(bearing(id(ID)) , P) , 
param(bearing(od(OD)) , P) , 
param(center x(X) ,P) , 


part(bearing2 , [color(yellow)] ,P, 
data( 

rf(RFO,RFA), 

elements(bearing), 

[ center x(X) ] 

)) 

spec(rf(RFO,RFA)) , 

param( bearing2( offset(X) ),P), 

I 

part (bearing 1 ,[color(yellow)] ,P, 
data( 

rf(RFO,RFA), 
elements(bearing) , 

[ center x(X) ] 

)) 

spec(rf(RFO , RF A)) , 

param( bearingl( offset(X) ),P), 


rev closed( housing , 

[ color(blue), 

comment(‘ The piston housing enclosing the mechanism’)], 

Parameters, 

data( 

angle( 180 ), 

rf(OFFSET ,angles(0, 0,180)), 
curve( 

v(Xl,Y4), v(X4,Y4), v(X4,Yl), 
v(X3,Yl), v(X3,Y2), v(X2,Y2), 
v(X2,Y3), v(Xl,Y3), v(Xl,Y4)) 

)) 

param( 

housing( 

radii( 

H spring radius, H bearing radius, 

H rodclear radius, H outside radius), 

lens( H springtravel , H bearings, H_rod ), 

rf( OFFSET, ANGLES )), 

Parameters ), 

XI is 0.0, 

X2 is H springtravel, 

X3 is X2 + H bearings, 

X4 is X3 + H rod, 


B-21 


Y1 is H rodclear__radius, 

Y2 is H_bearing__radius, 

Y3 is H_spring radius, 

Y4 is H outside radius, !. 

sle(junk, , , ) !. 

part(lvdt cap,[color(cyan)],P,data( 

rf( Offset , Angles ), 
elements! cap ),[] )) 

param( lvdt cap rf( Offset, Angles ) , P),!. 

part(intemal cap,[color(yellow)],P,data( 

rf( Offset , Angles ), 

elements! cap ),[] )) 

param( cap rf( Offset, Angles ) , P),!. 

rev open( cap, [] , Params , data( 

angle (360.0), 

rf( OFF ,ANG), 

curve( v( Xl.Yl), v(Xl,Y2), v(X3,Y2), v(X3,Y4), 
v(X5,Y4), v(X5,Yl) 

) 

)) 

spec (identity (rf (OFF, ANG))), 

param( cap( th i ckn ess (Cap thi ckn ess) , 

od( Cap OD) ), Params), 

param( cap spotface(SP), Params), 

param( rod(diameter( Rod_dia)) , Params), 

XI is 0.0, YlisO.O, 

X3 is SP , Y2 is Rod_dia * 0.5, 

X5 is SP - Cap_thickness , Y4 is Cap_OD * 0.5, 


B-22 


SPRING PISTON EXAMPLE 

Table 2. Redesign Possibility 1. 

rod 

length 4. 7000 

rod 

diameter 0.3750 

rod 

offset 0.0 

spring 1 

offset 0, 1250 

spring 

id 0.6100 

spring 

od 0.7200 

spring 

length 0.7875 

spring 2 

offset 3. 7875 

bearing 

id 0.3750 

bearing 

od 0.6250 

bearing 

len 0.8750 

bearing 1 

offset 0.9125 

bearing2 

offset 2.6625 

housing 


radii 

0.4750 

0.3125 

0.1975 

lens 

2.375 

2.6250 

0.2500 

rf 

offset 

-1.2500 

0.0 

0.0 

angles 

0.0 

0.0 

0.0 

cap 

thickness 

od 

0.2500 

0.7500 



cap rf 

offset 

0.0 

0.0 

0.0 

angles 

0.0 

0.0 

0.0 

Ivdt cap rf 

offset 

4.7000 

0.0 

0.0 

angles 

cap spotface 

0.0 

0.1250 

180.0 

0.0 


0.7250 


B-23 


Table 2. Redesign Possibility 2. 


rod 

length 4 ' 9250 

rod 

diameter 0.3750 

rod 

offset 0.0 

springl 

offset 0.1250 

spring 

id 0.6100 

spring 

od 0.7200 

spring 

length 0.9000 

spring2 

offset 3.9000 

bearing 

id 0.3750 

bearing 

od 0.6250 

bearing 

len 0.8750 

bearing 1 

offset 1.250 

bearing2 

offset 2. 7750 

housing 


radii 

0.4750 

0.3125 

0.1975 

0.7250 

lens 

2.1500 

2.6250 

0.2500 


rf 

offset 

-1.2500 

0.0 

0.0 


angles 

0.0 

0.0 

0.0 


cap 

thickness 

od 

0.2500 

0.7500 




cap rf 

offset 

0.0 

0.0 

0.0 


angles 

0.0 

0.0 

0.0 


Ivdt cap rf 

offset 

4.9250 

0.0 

0.0 


angles 

cap_spotface 

0.0 

0.1250 

180.0 

0.0 



B-24 


Table 2. Redesign Possibility 3, 


rod 

length 4.4750 

rod 

diameter 0.3750 

rod 

offset 0.0 

springl 

offset 0.1250 

spring 

id 0.6100 

spring 

od 0.7200 

spring 

length 0.6750 

spring2 

offset 3.6750 

bearing 

id 0.3750 

bearing 

od 0.6250 

bearing 

len 0.8750 

bearing 1 

offset 0.8000 

bearing2 

offset 2.5500 

housing 


radii 

0.4750 

0.3125 

0.1975 

lens 

1.9250 

2.6250 

0.2500 

rf 

offset 

-1.2500 

0.0 

0.0 

angles 

0.0 

0.0 

0.0 

cap 

thickness 

od 

0.2500 

0.7500 



cap rf 

offset 

0.0 

0.0 

0.0 

angles 

0.0 

0.0 

0.0 

lvdt_cap rf 

offset 

4.4750 

0.0 

0.0 

angles 

cap spotface 

0.0 

0.1250 

180.0 

0.0 


B-25 


Table 2. Redesign Possibility 4 , 


rod 

length 4.4750 

rod 

diameter 0.3750 

rod 

offset 0.0 

springl 

offset 0. 1250 

spring 

id 0.5900 

spring 

od 0.7200 

spring 

length 0.6750 

spring2 

offset 3 . 6750 

bearing 

id 0.3750 

bearing 

od 0.6250 

bearing 

len 0.8750 

bearingl 

offset 0. 8000 

bearing2 

offset 2.5500 

housing 


radii 

0.4750 

0.3125 

0.1975 

0.7250 

lens 

1.9250 

2.6250 

0.2500 


rf 

offset 

-1.2500 

0.0 

0.0 


angles 

0.0 

0.0 

0.0 


cap \ 

thickness 

od 

0.2500 

0.7500 




cap rf 

offset 

0.0 

0.0 

0.0 


angles 

0.0 

0.0 

0.0 


lvdt_cap~_rf 

offset 

4.4750 

0.0 

0.0 


angles 

cap spotface 

0.0 

0.1250 

180.0 

0.0 

i 


Table 2 REDESIGN POSSIBILITY 


B-26 


SPRING PISTON EXAMPLE 



Figure 10. Redesigned Spring Piston — Side View. 


B-27 



B-28 


SPRING PISTON EXAMPLE 



Figure 12. Redesigned Spring Piston — Isometric View. 


B-29 


APPENDIX C 


PROLOG CAD SYSTEM CODE 


dl machine code(31,[], ). 

erase dl machine code(32,[], ). 

init set(vtl25), set(show(vertex)), set(width(40.0)). 
cad 

consult( ’ [ntp . cad . prolog] mth ’ ) , 
mth init, 

consult^ [ntp.cad.prologjlib’), 
op(200,fx,set), 

assert(sys cvue(0.0,0.0,0.0)), 

assert(sys rvue(0. 0,0.0, 0.0)), 

asseit(sys width(100.0)), 

assert(sy s resolution(8)) , 

assert(display verify ( )) , 

f # 

/* 


*/ 

/* The following arguments are valid for SET 
Terminals 

vtl25 Graphic output formatted for a VT125. 

lexidata Graphic output formatted for a Lexidata Solid View. 

Display 

resolution(N) N is the number of line segments that approximate a curved surface. 

show(vertex) Graphic output will display the brep as lines. 

show(patch) Graphic output will display the brep as faces. 

clip(depth) Turn on depth clipping 
clip(nodepth) Turn off depth clipping ( just x and y ). 

cvue(X,Y,Z) Set the center of the screen to X,Y,Z. 
rvue(R,P,Y) Set the rotation of the screen by R,P,Y in degrees. 
width(W) Set the width of the screen W units. 

[no] verify Enable/Disable printing of design paramters used in a design. 

*1 

set(vtl25) not(sys terminal(vtl25)), 

retractall(sy s terminal( )) , 

assert(sys terminal(vtl25)), 

( 

( sys terminalinit(vtl25), 

machine code(15,[], ) ) 

> 



C-l 




( assert(sys terminalinit(vtl25)) , 

machine code(10,[], ) ) 


), 


view window,!. 


set(vt!25) 

set(lexidata) not(sys terminal(lexidata)), 

retractall(sys terminal ( )), 

assert(sy s terminal(lexidata)) , 

set(show(patch)), 

( 

( sys terminalinit(lexidata), 

machine code(7,[], ) ) 

( assert(sys terminalinit(lexidata)) , 

machine code(l,[], ) ) ), 

view window, !. 

set(lexidata) 

set(lalOO) not(sys terminal (la 100)), 

retractall(sy s terminal ( )) , 

assert(sy s terminal(la 1 00)) , 

machine code(42 , [] , ) , 

( 

( sys terminalinit(lalOO) ) 

( assert(sys terminalinit(lalOO)) , 

machine code(40,[], ) ) ), 

view window, !. 


set(lalOO) !. 

set(resolution(N)) N > 2, retract(sys - resolution( )), 

assert(sys resolution(N)), !. 

set(resolution(N)) nl, write(’ Illegal resolution ’), 
write(N), nl, break, abort. 

set(show(vertex)) 

not(sys show(vertex)) , 

retractall(sys show( )), 

assert(sy s show(vertex)) . 

set(show(patch)) 

not(sys show(patch)), 

retractall(sy s show( )) , 

assert(sy s show(patch)) . 

set(cvue(A,B,C)) 

X is float(A), Y is float(B), Z is float(C), 

retract(sys_cvue( , , )), 

assert(sy s c vue(X , ' Y , Z)) , 

view window, !. 


C-2 


set(rvue(A,B,C)) 

X is float(A), Y is float(B), Z is float(C), 

retract(sy s rvue( , , )) , 

assert(sys rvue(X,Y,Z)), 

view window, L 

set(width(A)) 

X is float(A), 

retract(sy s width( )) , 

assert(sy s width(X)) , 

view window, !. 

set( verify) 

retractall (display verify ( )) , 

assert( 

(display verify (R) 

nl, display verify 1(R), !)),!. 

set(no verify) 

retractall(display verify( .)), 

assert( display verify ( ) ), !. 

set(clip(depth)) machine code(31,[0.0], ), !. 

set(clip(nodepth)) machine code(31,[1.0], ), !. 

view window 

sy s width(WIDTH) , 

sy s cvue(X , ' Y , Z) , 

sys rvue(Z ANGLE, Y ANGLE, X ANGLE), 

machine code(30, [WIDTH, X,Y,Z,Z ANGLE, Y ANGLE, X ANGLE] ,_), !. 

alphamode sys terminal(vtl25), machine code(12,[], ), !. 

alphamode sys terminal(lexidata), !. 

alphamode sys terminal(lalOO), !. 

erase sys terminal vt 125), machine code(ll,[], ). 

erase sys terminal(lexidata), machine code(6,[], ). 

erase sys__terminal(lalOO), machine code(43,[], .). 

plot sys terminal(lalOO), machine code(41,[], ),!. 

plot. 

edit(A) machine code(20,[A], ), !. 

/♦ 


VIEW 

*/ 

view sys view(Name), view(Name), !. 

view( Name ) retractall( sys view( )), 

assert( sys view(Name)), 

view( Name , [] , 0), alphamode, !. 


C-3 




view( [First name| Rest of_names] , Params , Indent ) 

view( First name, Params, Indent), 

view( Rest of names, Params , Indent ), !. 

view( [] , — , — ) > !. 

view( Name , Params , Indent ) 

view design( Name , Params , Indent ), 

alphamode, !. 

view( Name , Params , Indent ) 

view part( Name , Params , Indent ), 

alphamode, !. 

view( Name , Params , Indent ) 

view sle( Name , Params , Indent ), 

alphamode, !. 

view( Name , Params , Indent ) 

view rev open( Name , Params , Indent ), 

alphamode, !. 

view( Name , Params , Indent ) 

view rev closed( Name , Params , Indent ), 

alphamode, !. 

view( Name , Params , Indent ) 

view she( Name , Params , Indent ), 

alphamode, !. 

view( Name , Params , Indent ), 

nl, writef Definition not found: ’ ) , write(Name), 
nl, restart, !. 


DESIGN 


view design( Name , , Ident ) 

design( Name , data( Design function , Elements ) ), 

display name( design, Ident, Name), 

Elements =.. [elements] Names], 

view all designs( Names , Design function , Ident ), !. 

view all designs( Names , Design function , Ident ) 

DF = .. [Design function, Params], 

call(DF), 

display verify (Params) , 

Ident 1 is Ident + 2, 

view( Names , Params, Ident 1 ), 

nl, 

break, 
fail, !. 

view all designs( , , ) :- 

nl, write( ’ Design options exhausted ’ ),nl, restart, !. 


C-4 



PART 


view part( Name , Parameters , Indent ) 

part( Name , Attribute list , Parameters , Data), 

parse attributes( Attribute list ) , 

display name( part. Indent, Name), 

Data =.. [data, rf(Offset, Angles), Elements, E params ], 

Elements = [ elements] Element list ], 

append(E params, Parameters , P3), 

/* Append the new transformation matrix */ 

mth tmsmat( Offset, Angles, Matrix), 

sys transformation Sys matrix), 

mth append tmsfrm( Matrix, Sys matrix. 

New matrix), 

asserta( sys transformation New matrix)), 

!, trimcore, 

/* Now view each element */ 

Indentl is Indent + 2, 

view( Element list , P3 , Indentl ), 

/* Now remove the rf. and retract it. */ 

retract(sys transformation(New matrix)), ! . 


SLE 


view sle( Name , Parameters , Indent ) 

sle( Name , Attribute list , Parameters , 

data(Delta,rf(Offset, Angles) , Curve)) , 

display name( sle, Indent , Name), 

parse attributes( Attribute list ) , 

Delta =.. [delta | Delta vector], 

mth tmsmat(Offset , Angles , Matrix) , 

sys transformation(Sy s matrix) , 

mth append tmsfrm(Matrix , Sys matrix , New matrix) , 


C-5 



gmtr curve to vertex( Curve , Verticies 2d), 

New matrix = [New matrix R, ], 

mth mul mat vec (New matrix R , Delta vector, 

Delta vector tm), 

display make sle(Verticies 2d , New matrix, 

Delta vector tm ),!. 

display make sle(Vertex , Matrix , Delta vector tm ) 

gmtr verts2d 3d z(Vertex , Verts3d), 

mth tmsfrm(Matrix , Verts3d , Vtl ), 

mth add cl(Delta vector tm,Vtl,Vt2), 

display make slel(Vtl,Vt2), !. 

/* Display Verticies */ 

display make slel( Bottom verts , Top verts ) 

sy s show(vertex) , 

display make sle vertex(Bottom verts , Top verts), !. 

display make sle vertex([F 1 , V 1 1 R 1 ] , [F2 , V2 1 R2] ) 

display verticies([Fl ,V 1 , V2,F2]), 

display make sle vertex([Vl|Rl] , [V2|R2] ), !. 

display make sle vertex( [ ], [ ] ) !. 

/* Display Patches *1 

display make slel( Bottom verts , Top verts ) 

sys show(patch), 

display make sle patch(Bottom verts , Top verts), !. 

display make sle patch( Bottom verts , Top verts ) 

display patch(Bottom verts) , 

/* Save the first vertex */ 

display make sle patch 1 (Bottom verts , Top verts ), 

reverse(Top verts , Top), 

display patch(Top),! . 

display make sle patch 1 ([F 1 , V 1 1 R 1 ] , [F2 , V2 1 R2] ) 

display patch([F 1,F2,V2,V1]), 

display make sle patchl([Vl|Rl] , [V2|R2] ), !. 

display make sle patch 1 ( [ ], [ ] ) !. 


C-6 



REV CLOSED 


view rev closed( Name , Parameters , Indent ) 

rev closed( Name , Attribute list , Parameters , 

data(angle( Angle) , rf(Offset, Angles) , Curve)), 

display name( rev closed, Indent , Name ), 

parse attributes( Attribute list ) , 

Angle rad is Angle * 0.01745329252, 

mth tmsmat(Offset,Angles,Matrix), 

sy s transformation^ s matrix) , 

mth append trnsfrm(Matrix,Sys matrix,New matrix), 

gmtr curve to vertex( Curve , Verticies 2d), 

display make revclosed( Verticies 2d , New - matrix. 

Angle rad ), 

display make revclosed angles( Angle , Verticies 2d, 

New matrix), 


I 

display make revclosed( [[Xvert,Yvert]|Rvert] , Matrix , Angle ) 


sy s resolution(Res) , 

Count is Res + 1, 

Angle increment is Angle / Res, 

gmtr arcvertsl( 

Yvert, /* The radius */ 

0.0 , /* X center */ 

0.0 , /* Y Center */ 

0.0 , /* Start angle */ 

Angle increment , 

Count , /* Count for loop*/ 

Verts ), 

gmtr verts2d 3d zyx(Xvert, Verts, Verts 1), 

mth tmsfrm( Matrix , Verts 1 , Verts world ), 

display make revclosed 1( Verts world , Rvert , Matrix , 

Angle increment , Count ). 

display make revclosed 1( VI , [[Xvert, Yvert] | Rvert] , Matrix 

, Angle increment , Count ) 


C-7 



gmtr arc verts 1( 

Yvert, /* The radius */ 

0.0 , /* X center */ 

0.0 , /* Y Center */ 

0.0 , /* Start angle */ 

Angle increment , 

Count , /* Count for loop*/ 

Verts ), 

gmtr verts2d 3d zy x(X vert , V erts , ' Verts 1 ) , 

mth tmsfrm( Matrix , Vertsl , V2 ), 

display make genrev quad( VI , V2 ), 

display make revclosed 1( V2 , Rvert , Matrix , 

Angle increment , Count ), !. 

display make revclosed 1( ,[], , , ) !. 

display make revclosed angles( Angle , , ) 

0.1 E-8 > abs( Angle - 360.0) , !. 

display make revclosed angles( Angle , Verticies 2d, Matrix ) 

sy s show(vertex) , 

dmrvat( Angle, Matrix , [Verticies 2d] ), !. 

display make revclosed angles( Angle , Verticies 2d, Matrix ) 

reverse( Verticies 2d, RV2D ), 

gmtr make curve convex( RV2D, RV2D , TRIANGLES ), 

dmrvat( Angle, Matrix , TRIANGLES ), !. 

dmrvat( 

dmrvat( Angle, Matrix , [Verticies 2d|RV2D] ) 

gmtr verts2d 3d z( Verticies 2d, V3d), 

mth tmsfrm( Matrix , V3d , V3d a ), 

display ngon( V3d a), 

mth tmsmat(offset (0 ,0,0), angles(0 ,0 , Angle) , Matrix 1 ) , 

mth append tmsfrm(Matrixl , Matrix, New matrix), 

mth tmsfrm( New matrix, V3d , V3d b ), 

reverse( V3d b, V3DB ), 

display ngon( V3DB ), 

dmrvat( Angle, Matrix, RV2D ), 


*/ 

view she( Name , Parameters 

she( Name , Attribute list , Parameters , 

data( 

length(Length), 

mean radius(Mean_radius) , 

pitch(Pitch), 
rf(Offset , Angles) , 

Curve) 


SOLID OF HELICAL EXTRUSION 


, Indent ) 


C-8 



display name( she, Indent , Name), 

parse attributes( Attribute list ) , 

mth tmsmat( Offset , Angles , Matrix ), 

sy s transformation^ s matrix) , 

mth append tmsfrm( Matrix, Sys matrix. Global mat- rix), 

sy s resolution(Resolution) , 

mth pi(Pi), 

/* Pitch is [tums/inch] */ 

/* Number of radians */ 

No of turns is Pitch * Length * Pi * 2.0, 

Count is round( Pitch * Length * Resolution), 

Angle increment is No of turns / Count, 

Z inc is 1.0 / ( 2 * Pi * Pitch ), 

X is Mean radius * cos( Angle increment), 

Y is Mean radius * sin(Angle increment), 

Z is Z inc * Angle increment, 

Angle_inc degree is Angle increment * 180.0 / Pi, 

X delta is X - Mean radius, 

VNR = [ X delta, Y , Z ], 

mth tmsmat( offset( 0 , 0, Z), 

angles( Angle inc degree ,0,0) , Spin matrix ), 

/* The angles needed to rotate the curve */ 

/* perpendicular to the helix direction */ 

mth axis angles z( VNR, Helix angles ), 

/* Convert bounding curve to verticies */ 

gmtr curve to vertex( Curve , Bounding verticies ), !, 

/* Set the z value to be 0.0 */ 

gmtr verts2d 3d z( Bounding verticies , 

Bounding verticies 3D ), !, 

/*move the curve over to the helix*/ 

Ang =.. [angles | Helix angles ], 

mth tmsmat( offset( Mean radius , 0, 0), 

Ang , Helix matrix ), 

mth tmsfrm( Helix matrix. Bounding vertici-des 3D , 

Bverts normal ), !, 

mth tmsfrm( Global matrix, Bverts normal, BVF ), 

display ngon( BVF ), !, 

display make she( Count, BVF, Bverts normal , 

Spin matrix , Global matrix), 


C-9 


display make she( 0,V, , , ) reverse( V,VR), 

display ngon( VR ), !. 

display make she( Cur , V OLD, V , M ,GM ) 

Curl is Cur-1, 

mth tmsfrm( M , V , VP), !, 

mth tmsfrm( GM , VP, VG), !, 

display make genrev quad( V OLD, VG ), 

display make she( Curl, VG, VP , M,GM ), !. 


REV OPEN 


view rev open( Name , Parameters , Indent ) 

rev open( Name , Attribute list , Parameters , 

data( angle(Angle) , rf(Offset, Angles) , Curve) ), 

display name( rev open, Indent , Name), 

parse attributes( Attribute list ) , 


Angle rad is Angle * 0.01745329252, 

mth tmsmat(Offset , Angles , Matrix) , 

sy s transformation^ s matrix) , 

mth append tmsfrm(Matrix , Sy s matri x , New matrix) , 

gmtr curve to vertex( Curve , Verticies 2d), 

display make_revopen( Verticies 2d , New matrix, 

Angle rad ),!. 

display make revopen( [ [X,Y] , [Xvert,Yvert] | Rvert ] , 

Matrix , Angle ) 

sy s resolution(Res) , 

Count is Res + 1, 

Angle_increment is Angle / Res, 

mth tmsfrm( Matrix , [X,Y,0.0] , Vcenter ), 

gmtr arcverts 1 ( 

Yvert, /* The radius */ 

0.0 , /* X center */ 

0.0 , /* Y Center */ 

0.0 , /* Start angle */ 

Angle increment , 

Count , /* Count for loop*/ 

Verts ), 

gmtr verts2d 3d zyx(X vert, Verts, Verts 1), 

mth tmsfrm( Matrix , Verts 1 , VI), 

display make revopen start( Vcenter, VI ), 

display make revopenl( VI , Rvert , Matrix , 

Angle increment , Count ) 

! 


C-10 




display make revopenl( V2 , [[X,Y]], Matrix , , ) :- 

mth tmsfrm( Matrix , [X,Y,0.0] , VI world ), 

display make revopen end( V2 , VI world ), !. 

display_make revopenl( VI , [[Xvert,Yvert]|Rvert] , Matrix 

, Angle increment , Count ) 


gmtr arcvertsl( 

Yvert, /* The tadius */ 

0.0 , /* X center */ 

0.0 , /* Y Center */ 

0.0 , /* Start angle */ 

Angle increment , 

Count , /* Count for loop*/ 

Verts ), 

gmtr verts2d 3d zy x(X veit , Verts , Verts 1 ) , 

mth tmsfrm( Matrix , Verts 1 , V2 ), 

display _make genrev_quad( VI , V2 ), 

display make revopenl( V2 , Rvert , Matrix , 

Angle increment , Count ), !. 

/* Display the triangular end patches */ 

display make revopen end( VS , VC ) :- 

sys show(patch), 

display make revopen patchm( VS, VC), !. 

display make revopen end( VS , VC ) 

sys show(vertex), 

display make revopen vertexm( VS, VC), !. 

display make revopen_patchm( [V1,V2|RV] , VC ) :- 

display patch([V 1 , V2, VC]), 

display make revopen patchm([V2|RV] , VC ), !. 

display make revopen_patchm( [ ] , ) !, trimcore. 

display make revopen vertexm( [V1,V2|RV] , VC ) 

display verticies([Vl,V2,VC]),D display make_revopen vertexm([V2|RV] , VC ), !. 

display make revopen vertexm( [ ] , ) !, trimcore. 

/* Display the triangular Start patches */ 

display_make revopen start( VC , VS ) :- 

sys show(patch), 

display make revopen_patch( VC , VS ) , !. 

display make revopen start( VC , VS ) :- 

sys show(vertex), 

display make revopen vertex( VC , VS ) , !. 

display make_revopen_patch( V center , [Vl,V2)Rv] ) 

display patch([V center , VI, V2]), 

display make revopen_patch( V center , [V2|Rv] ), !. 

display make revopen patch) , [ ] ) !. 


C-ll 


display make revopen vertex( V center , [Vl,V2|Rv] ) 

display verticies([V center , VI, V2]), 

display make revopen vertex( V center , [V2|Rv] ), !. 

display make revopen vertex( , [ ] ) 


/* 


Misc Definitions 


/* 

sys transformation^ 

[ 1 . 0 , 0 . 0 , 0 . 0 , 
0 . 0 , 1 . 0 , 0 . 0 , 
0 . 0 , 0 . 0 , 1 . 0 ], 
[0.0, 0.0, 0.0]]). 


Define the initial transformation matrix 


/* 3 x 3 rotation */ 
/* Offset */ 


CM2 




BIBLIOGRAPHIC DATA SHEET 


1. Report No. 2. Government Accession No. 

NASA TM-86241 


4. Title and Subtitle 

A RULE BASED COMPUTER AIDED DESIGN SYSTEM 


3. Recipient's Catalog No. 


5. Report Date 
October 1986 


6. Performing Organization Code 


7. Author{$) 

Timothy Premack 


9. Performing Organization Name and Address 

Mechanical Engineering Branch (Code 731) 
NASA Goddard Space Flight Center 
Greenbelt, MD 20771 


12. Sponsoring Agency Name and Address 

National Aeronautics and Space Administration 
Washington, DC 20546 


8. Performing Organization Report No. 
86B0078 


10. Work Unit No. 


1 1 . Contract or Grant No. 


13. Type of Report and Period Covered 
Technical Memorandum 


14. Sponsoring Agency Code 


1 5. Supplementary Notes 

Originally submitted to the Johns Hopkins University as a masters essay. 


16. Abstract 

A Computer Aided Design (CAD) system is presented which supports the iterative process of design, the 
dimensional continuity between mating parts, and the hierarchical structure of the parts in their assembled 
configuration. Prolog, an interactive logic programming language, is used to represent and interpret the 
data base. The solid geometry representing the parts is defined in parameterized form using the swept volume 
method. The system is demonstrated with a design of a spring piston. 


17. Key Words (Selected by Author(s)) 
Computer Aided Design, Design, 
Logic Programming, Prolog 


1 8. Distribution Statement 
Unclassified-Unlimited 


Subject Category - 61 


19. Security Classif. (of this report) 

20. Security Classif. (of this page) 

21 . No. of Pages 

Unclassified 

Unclassified 

62 



*For sale by the National Technical Information Service, Springfield, Virginia 22161 


NASA-Langley, 1986 


















