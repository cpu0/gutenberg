REPORT DOCUMENTATION 

reocrtsng burd** *0 t th*4 collection of ^nfo/matJCn >> estimated *o average ' ?»oi 
^atbe^uig and m*intaimii9 fhe data needed, and corppieun^ an<j rew-ewm^ me cQiiect; 
collection of information, including iugseilioni f c* tedwonq m.s Garden »o A‘a*ftipqr< 
Oavii Hjghway. Suite > 204, Arlington, v A 222Q2-*30i and »o tne Of*»<* o# 

1. AGENCY USE ONLY (Leave blank) I 2. REPORT DATE 


February 


4. TITLE AND SUBTITLE 


NetStat: A Probabilistic Network 

Connectivity Analysis Tool 


6. AUTHOR(S) 

G. S. Marzot 


form Approved 

SJ'JQ 4-0tf 


AD-A262 838 

iffllllii 


*. st data sovrce^. 

■ vt*e< a^pei't of tn.i 
>,rn f i *S ie^ervon 


5. FUNDING NUMBERS 


7. PERFORMING ORGANIZATION NAME{S) AND ADDRESS(ES) 

The MITRE Corporation 
202 Burlington Road 
Bedford, MA 01730 


8 PERFORMING ORGANIZATION 
REPORT NUMBER 

M 9 3B0U0003A 



APR 0 9 7993] 


10. SPONSORING' MONITORING 
AGENCY REPORT NUMBER 


M 9 3 BOOOOO -1 4 



11. SUPPLEMENTARY NOTES 


, 12a. DISTRIBUTION/AVAILABILITY STATEMENT 


Approved for public release; 
distribution unlimited 


| 13. ABSTRACT (Maximum 200 words) """ .* " 1 1 

This paper describes a computer program, NetStat, that is designed to 
analyze the connectivity of prohaba1istic networks. The program, which 
offers a full graphic user interface (GUI), allows the user to visually 
layout a network topology and specify the destruction probability, Pd, 
for each network element. A Monte-Carlo simulation is utilized to 
obtain estimates of various connectivity netrics. Some details of the 
implementation are discussed and an example application is illustrated. 

A user manual is provided. Source code is also provided, written in 
Symantec s Think Pascal for the Macintosh personal computer. 


14. SUBJECT TERMS 


15. NUMBER OF PAGES 


16. PRICE COOE 

?7 OF C ReTo V RT LASS 1FICATION I 18 OF C yHIS Y pAGl SSIFICAT '° N I’ 9 oVSsTRAC*20- LIMITATION OF ABSTRACT - 


j Unclassified 

MSN 7540-01-280-5500 


IJnc lass i. f i.ed 


Unc lass j f y?d 


Standard ►or-’i «y}8 :s ev 
t>y a .NS i '.(d z VJ-8 

i'!H 'll 









NetStat: A Probabilistic Network 
Connectivity Analysis Tool 

G. S. Marzot 


M l )3bOOO(K>Vt 

February 1993 




93-07413 



Bedford, Massachusetts 






NetStat: A Probabilistic Network 
Connectivity Analysis Tool 


m mtumoou 
February 1993 


G. S. Marzot 


Contract Sponsor N/A 
Contract No. N/A 
Project No. D50B 
Dept. D0s8 

Approved for public release, 
distribution unlimited. 




Bedford, Massachusetts 





Ill 


Abstract 


This paper describes a computer program, NetStat, that is designed to 
analyze the connectivity of probabalistic networks. The program, which offers a 
full graphic user interface (GUI), allows the user to visually layout a network 
topology and specify the destruction probability, Pd, for each network element. A 
Monte-Carlo simulation is utilized to obtain estimates of various connectivity 
metrics. Some details of the implementation are discussed and an example 
application is illustrated. A user manual is provided. Source code is also provided, 
’vrirten in Symantec’s Think Pascal for the Macintosh personal computer. 





IV 


AgkngMcdgrocms: 

I would like to acknowledge the contribution of Dr. B. D. Metcalf under 
whose direction the initial work on this simulation was performed. I would also 
like to acknowledge Dr. V. C. Georgopoulos who also participated in the previous 
study and whose insights l found valuable. 1 would like to thank Dr. N. P. Shein 
who provided me with the "Graph Theory" perspective on the problem as well as 
many fine reference texts. 1 would also like to express my appreciation to Prof C. 
H. Chang and the Tuft's University Electrical Engineering Department for their 
support and supervision of this work. A special thanks to Hilary Marzot. 







TABLE OF CONTENTS 


SECTION PACE 

1.0 Introduction.1 

2.0 Theory of Operation.2 

3.0 Implementation.7 

4.0 Example Application.13 

5.0 Verification of Results.24 

6.0 Summary.27 

References and Bibliography.28 


APPENDIX A - User's Manual 


APPENDIX B - Source Code 













VI 


LIST OF FIGURES 

FIGURE PAGE 

la An Unsegmented Network.3 

lb A Segmented Network.3 

2 Record Structure for Nodes and Links.9 

3 Pascal Data Structure Representing Network of Nodes and Links.10 

4 Flow Chart for Monte-Carlo Analysis of Network Topology.11 

5a Star Topology.14 

5b Ring Topology.14 

6 Probability of Segmentation for a 12 Node Ring with 0 Crosslinks.15 

7 Probability of Segmentation for a 12 Node Star and Hardened Hub.HPd=0.0...16 

8 Probability of Segmentation for a 12 Node Star and Hardened Hub,HPd=0.1...17 

9 Comparison of 12 Node Star to 12 Node Ring with 0 to 6 Crosslinks.19 

10 Probability of Segmentation for a 12 Node Ring with 1 Crosslink.20 

11 Probability of Segmentation for a 12 Node Ring with 2 Crosslink.21 

12 Probability of Segmentation for a 12 Node Ring with 3 Crosslink.22 

13 Probability of Segmentation for a 12 Node Ring with 6 Crosslink.23 

14a Comparison of Closed Form Solution for 12 Node Simplex Ring .25 

14b Comparison of Closed Form Solution for 12 Node Duplex Ring .25 

15 Convergence of Monte-Carlo Simulation with Number of Trials.26 























1.0 .Imroduttign; 


The study of networks has found application in many diverse areas. These range 
from air-traffic routing, to power and commodity distribution, telecommunication and 
computer networks as well as epidemiology and circuit analysis. One quality which 
network designers/analysts art often concerned about is the degree to which the network 
elements or nodes are connected. In the case of supply networks or communication 
networks the system designer may want to provide reliable connection between two given 
nodes or a uniform level of reliable connection to all nodes. A network architect may also 
be faced with certain performance constraints such as delay and throughput which limit his 
ability to meet the other requirements. As is often the case, the cost and availability of 
components and technology further constrain the designer. In this demanding environment 
of tradeoffs it is desirable to be able to quantify the performance of a given network, 
including its connectivity, to determine when the design goals have been adequately met 
and to enable resources to be allocated in the most intelligent way. 

Historically a great deal of work has been done on analyzing the reliability of 
networks under a deterministic threat environment; that is, assuming an attacker has 
complete fore-knowledge of the network topology! 1][7][15J. The goal of this previous 
work often centered on minimizing the number of steps required to partially or completely 
segment a network, and a number of closed-form solutions have been derived[2][7J. This 
approach is reasonable given the assumption of a deterministic threat. The closed-form 
result is also practical in light of the fact that computer simulated solutions were not viable 
until only a relatively short rime ago. 

However, networks are often subject to random factors such as weather, 
component life rime, and collateral damage, either due to benign (construcrion/car accident) 
or hostile (military attack on adjacent target) sources. In this environment it is natural for 







2 


network component reliability to be described in a probabalistic fashion, yielding 
probabalistic networks. Analysis of this type of network has been characterized as an "NP- 
hard problem" and closed form solutions become intractable for all but the most constrained 
problems! 13]. 

It is the aim of the computer application described in this paper to provide the 
network designer/analyst with a tool to asses various aspects of connectivity for these 
probabalistic networks. It is also the goal of the tool to be easy to use and generally 
applicable to a wide array of real world problems. Therefore a number different types of 
network components are provided for problem setup. And several connectivity metrics can 
be computed allowing the analyst to answer several types of questions including: What 
topology is more reliable? Where is the best location for an additional link to enhance 
connectivity? How often should a given resource be replicated in a distributed computing 
environment? And more. 

2.0 Theory,gf Operation; 

To understand the operation of the tool, let’s first define some vocabulary. The 
terms described here are defined primarily in the context of the tool but arc also generally 
used in other contexts ( see texts on Graph Theory for rigorous definition of terms[2][3]). 
A network is a collection of any number of nodes and links where N nodes can be joined 
by M links. A link must always be terminated by a node at each end (does not have to be a 
different node for a self-loop although self-loops are not considered here). 

A link is represented as an edge or line which joins two nodes. There are two types 
of links considered here: simplex and duplex. Simplex links are directed edges which 
allow connection between nodes only in one direction. Duplex links are undirected edges 
which allow bidirectional connection between nodes. No distinction is made between half¬ 
duplex and full-duplex here 

Nodes are represented as points either located at the end of one or more links or 
separately as unconnected elements. Three types of nodes are considered here. The term 
node can be used generally to describe all types or specifically referring to the "Node" 
element in the computer application. The other node types in the application are "Hubs” and 
"Bypass Switches". "Hubs" only differ from the generic "Node” in a conceptual way and 
are treated by the application identically to "Nodes". "Hubs" are generally considered the 
central connecting elements in star type networks. They are included here as a separate type 
of element so that type specific parameters can be set for all hubs in a given network. The 







3 


"Bypass Switch" is another specialized node. It differs from the other nodes in that it is not 
considered when computing segment length or when assessing segmentation. 

A segment is defined as a subset of the original network, consisting of nodes and 
links, within which each non-"Bypass Switch" node has a round trip path to every other 
non-"Bypass Switch" node. A network is considered segmented if it is made up of more 
than one segment. In other words, a network is segmented if at least one operational node 
is unable to establish a round trip path to at least one other operational node. Figure la and 
figure lb illustrate this definition. 



Figure la - An Unsegmented Network, the number of segments=l 



Figure lb - A Segmented Network, the number of segments=3 
Note: segments consisting of only Bypass Switches are not counted. 










4 


In a probabalistic network each network component is given a probability of failure 
or destruction, Pd. The element is considered to be either operative or inoperative based on 
a distribution described by Pd. This probability can also be thought of as the reliability of 
the component within an interval of time. Because each element in the network can assume 
a binary state it is apparent that in a network consisting of N nodes and M links that the 
total number of system states is given by: 

Nstates = #of possible system stales = 2 N+M (]) 

It should be noticed that this number can be quite large, even for small to medium sized 
networks. 

Each system state, consisting of some combination of operative and inoperative 
network components, has a certain probability of occurrence given by the following: 

let Xj « the event that a particular sytem state, j, occurs; where 1 <j£Nstates 
p, = the probability the the i th element is inoperative; q, = 1 - p, 

£i = q, if the i th element in a particular system, j, is operative 
* p, if the i ,h element in a particular system, j, is inoperative 
P(= the probability x, occuring 

•of elements 
in system j 

p<*j) - n £ i 

( 2 ) 

Given that the network is in one of these system states, with some nodes and links 
inoperative, the resultant topology can be analyzed for qualities like segmentation and 
segment size. 

Now it is useful to describe the connectivity metrics investigated by NetStat. The 
primary measure of connectivity looked at by this tool is the probability of segmentation, 
Pscg. This metric is very simply the probability that the network will consist of more than 
one segment. Stated more rigorously, Pseg is the probability that at least one operational 
node cannot establish bidirectional connection with at least one other operational node. 
This is seen as a good measure of how well the network is performing its function of 
connecting all nodes and it is desirable that Pseg be minimized in most cases. This metric 





is an accepted reliability measure in the current literature (11). As a note, a network 
consistinc of one or zero nodes is not considered segmented by definition. Pscg can be 
calculates as follows: 


let p,« 1 if the j ,h system state contains > 1 segment 
= 0 if the j 1h system state contains 1 or 0 segments 

Nstates 

Pseg= X Pj p ( x i> 

H 


(3) 


Another well accepted measure of connectivity which is investigated by NetStat is 
the expected value of the number of connected pairs, Ecp [4]. For a given network, the 
number of connected pairs is defined by: 

let K, = # of segments in the j th system state 

N* = # of nodes in the k ,h segment of the j ,h system state 

Kj 

#of connected pairs in a particular system,], = Ncp, = Y ^ 

k-i 2 (4) 

It is the number of ways to choose 2 nodes from a set of N nodes summed for each 
segment in the network. The expected value of connected pairs is given by: 


Nstates 

Ecp = X Nc Pi p ( x i) 
i-i 


(5) 


Two other metrics are, the average or expected value of the segment length, Esl, 
and tnc expected value of the maximum segment length, Emsl. All possible segments and 
their probability of occurrence are used to compute the average segment size; whereas only 
the maximum segment length for each system state and it probability of occurrence is used 
to compute the expected maximum segment length. These measures give an idea of how 
well the network is held together even if segmentation does occur. They also give an 
indication of the most likely segment size which is useful when designing distributed 
systems on a probabalistic network. Their definition is stated mathematically as follows: 


lei U * the length of the k ,h segment 


M, = the length of the max mum segment in the j ,h system state 


Nstates 

ESL X 
H 


/ K, \ 

X 

k-1 


K 


•t / 


P (*,) 


Nstates 

Ems! = X M J P (*|) 
J-i 


(6)(7) 






For generality, when we look at Ecp it is normalized to the maximum number of 
connected pairs in the fully functional network. Similarly, Esl and Emsl are normalized to 
the total number of nodes in the whole system w hen all nodes are functional. 

All of the metrics here can be computed exactly based on their definitions. One 
could examine every possible state of the network along with its probability of occurrence 
and keep track of segmentation , number of connected pairs, segment size etc However, 
as stated before, the number of system states grows exponentially with the number of 
nodes and links and this method would be intractable for all but the most trivial networks. 

Another approach, which works in some cases, takes advantage of system 
constraints and network symmetries to simplify the computation. Two of these analytical, 
closed-form expressions are shown here without proof for later comparison. The first is an 
expression for Pscg for an N node ring with duplex linking elements The parameters are 
p, the node probability of failure, and q, the duplex link probability of failure: 

N-1 

Pseg = 1 - p N + (N - 1 )(1 - p) N (l - pf - N £ p<i - p) u V - 

i-° (8){8) 

The second is an expression for Pseg for an N node simplex nng. where q is the simplex 
link probability of failure: 

Pseg = 1 - p N - N p N1 (1 - p)-(l - qf\*\ - p) N (9)112] 

However, when the system under consideration has a fair sized number of nodes 
and a fairly complex topology, our only recourse is computer simulation The technique 
used in NetStat is a Monte-Carlo simulation. The basic principal of the Monte-Carlo 
technique in this application is to randomly generate an ensemble of the system states so 
that estimates of the connectivity metrics can be computed over this ensemble. It is an 
essential requirement that the randomly generated system states in the Monte-Carlo 
simulation be statistically independent. This can be achieved if a random number, Rn, 
uniformly distributed between 0 and 1, is generated for each network component and 
compared to that components Pd in the manner of a Bernoulli experiment, as follows: 

if Rn < Pd„ the state of the i 1h element is inoperative 
else if Rn > Pd„ the state of the i ,h element is operative 




This also assumes that the uniform random numbers are statistically independent. This 
process is repeated for every element in the network thus generating one random state of 
the network. 

The randomly generated system state can then be analyzed as before for 
segmentation, number of connected-pairs, segment size, etc. This process of generating a 
state and analyzing it is repeated as many times as is dictated by the simulation. The idea is 
that the statistics observed in this randomly generated ensemble will reflect the true ones 
and a good estimate of our metrics will be obtained if enough samples are used. 

The benefit of the Monte-Carlo technique is that the number of states or trials that 
must be investigated can be significantly less than the total number of system states and is 
only dictated by the required accuracy. There is ar. expression which relates the number of 
Monte-Carlo trials required to the desired accuracy as follows. Without going into detail 
this expression relates the estimated result produced by the simulation to the exact result it 
reflects with the number of trials, N, as a parameter. It can be applied to general precision 
if the exact probability, p, is assumed to be the least significant digit in the desired 
accuracy: 

p * the exact probability being estimated 
p * the estimated probability 

p - 2Vp7N < p < p + 2Vp/N (10){6] 

This expression is valid with a 95% confidence level due to certain approximabons 
in its derivadon. An example of its applicabon follow s. 

let p m the desired accuracy in Pseg « 10' 3 
N * #of Monte-Carlo trials = 10 4 

0.00036 <p< 0.00163 

From this we can expect to see fluctuation in the third decimal place and occasional 
fluctuarion in the second decimal place when 10,000 Monte-Carlo trials are used. 

,3.0 Irn picmgoiaflan: 

The computer application, NetStat, was implemented on a Macintosh personal 
computer using Symantec’s Think Pascal. The Macintosh platform was desirable due to its 





inherent support for a graphical user interface as well as being an adequately powered 
computing engine. This support comes primarily through the, roughly, 700 ROM-based 
Pascal routines which are bundled with the Macintosh computer. These routines handle a 
wide array of low level tasks, including the creation of a windowing environment, pull¬ 
down menus, file I/O, basic drawing, etc. Although the description of the program which 
follows is focused primarily on the simulation related data structures and algorithms, it 
should be noted that more than 70% of the source code is devoted to creating the GUI and 
platform specific interaction. This is a typical percentage for applications with a full GUI. 

The application was geared to the high end Macintosh 11 series computer (SE/30 
also) which incorporates a separate math coprocessor to enhance the efficiency of floating¬ 
point operations. The source code may be recompiled to run on Macintoshes without a 
math coprocessor making minor adjustments. However this will result in a noticeable 
degradation in performance. 

The choice of a Pascal-based development environment* was natural due to its 
compatibility with the operating system interface and the language's straightforward 
readability. Pascal also offers a number of language constructs which facilitate the 
implementation of this model. These include; abstract data structures such as "records" and 
"sets", the ability to link structures with pointers (e.g.. linked list), and support for 
recursive procedure calling. In the description of the program implementation that follows 
it will be show n how these features were utilized to construct a model of the network and 
facilitate its analysis. 

A typical user session on NetStat consists of three phases ( see NetStat User's 
Manual for complete description of program environment and user interface ). The three 
phases are; topology construction, parameter specification, and simulation run. During the 
topology construction phase, while the user visually lays out the network to be analyzed, 
an analogous data structure is constructed and held in the program's global data space. The 
data structure is basically a linked list consisting of two types of elements, node records 
and link records. Figure 2 shows the basic makeup of these two records (see NetStat 
Source Code, ConsVars Unit for exact record structure). 


‘Authors Note: The Think Pascal environment is an excellent full featured professional 
programming environment. It offers an integrated editing, debugging, linking and 
compiling shell with an intuitive and easy to use interface. I highly recommend it. 



1 Link Record Structure 

LOCATION 

ARROWS 

Pd 

KIND 

ALIVE/DEAD 

End Point Node Polntere 




Node Record Structure 

LOCATION 

ID 

Pd 

KIND 

ALIVE/DEAD 

Array oi Link Pointers 


mum 


Figure 2 - Record Structure for Nodes and Links 

The network element records contain graphical information such as the "location", 
which specifies, relative to the application drawing pad.where the element should be 
drawn. In the case of the link, additional information is stored showing where the "arrows" 
should be drawn. All elements have a "Pd" field which is its probability of failure and a 
"kind" field which specifies "Node'V'Hub", or "Bypass" in the case of the node element 
and "Simplex" or "Duplex" in the case of the link. All elements also have a state field 
which specifies whether the element is operational or not. Most significantly, all element 
records have holders which can contain the address of, or pointers to, the other records in 
the network data structure. In the case of the nodes, an array of pointers to link records is 
used to keep track of which links emanate from a node. It should be noted that a pointer to 
a bidirectional link would be stored in the array of both its endpoint nodes whereas a 
simplex link pointer would only be stored in the node from which it emanates as indicated 
by its arrow. In the case of links, two fields are provided to keep track of the addresses for 
the two node records at each endpoint. 

Figure 3 illustrates the resultant data structure when a 4 node ring with one 
diametric crosslink is constructed. All links are bidirectional. 

After the topology is constructed the user may specify the Pd's for the network 
components. This may be done uniformly by type; that is for instance, all “Hubs" have a 
Pd = 0.1. It may also be done individually by visually navigating the network (clicking on 
components) and setting each components Pd accordingly. Additionally, parameters such 
as the number of Monte-Carlo trials can be set. 

When parameters such as these are set up, a simulation "run" can commence. A 
flow chan of the simulation operations is shown in figure 4. The state of each network 
component is determined for all the components in the network to produce a new topology 
or system state. This resultant topology is analyzed for the metrics described above and 
counters are maintained as to whether segmentation occurred, the number of segments 



























































Flow Chart for Monte*Carlo Analysis of 
Network Topology 


Figure 4 








produced and their sizes. This process is repeated N times where N is the number of 
Monte-Carlo trials. Then the counters are examined to determine Pscg. Ecp, Esl and Emsl. 

The operations in block 3 of figure 4 are central to the working of the simulation 
and it is very important that this step be computationally efficient. Basically, this operation 
is implemented as a depth-first tree search which proceeds until all operational nodes are 
accounted for. The searching portion of code is called recursively while keeping track of 
"set" type variables which indicate which nodes are in the current segment and those that 
are accounted for in other segments (see NetStat Source Code. MultiEngine Unit, 
procedure inspectseg ). The "set" language constructs included in Think Pascal are 
instrumental in these operations, providing a means to compute rapidly the union and 
intersection of various sets. The tree search must treat simplex links in a special way. The 
nodes encountered when traversing a simplex link are not added to the set of nodes in the 
current segment until a roundrrip path is established. 

Another critical portion of the implementation is the nature of the random numbers 
generated when determining the state of each network component. These numbers must be 
statistically independent and a unique series of numbers must be generated each time a 
simulation is run. The random number generator used in this simulation is the native one 
found in the Macintosh ROM w hich has been well studied and determined to generate high 
quality output* . Steps were taken to re-seed the random number generator between runs. 

Source code for NetStat is included at the end of this paper. The code is broken 
into three units; ConsVars, Main, and Multi-engine. ConsVars contains global constants 
and global variables as well as application specific data types and structures. The "Main" 
unit contains many routines to implement the user interface and construct the network data 
structure as well as the main-line of the program. The "MultiEngine" unit contains two 
versions of the code that analyzes a given topology, one which is optimized for Pseg and 
another which is more general in scope. 


* Minimal Standard RNG - Park. Miller; Communications of the Association for 
Computing Machinery. Oct. 1988 





4.0 Example Application: 


To illustrate how NetStai can be used an example problem is posed. The example 
problem, which might be faced by a local area network designer, is the choice between two 
given topologies. Specifically, the tool will be used to evaluate the benefits of a star 
topology versus a ring topology for a twelve node network. For one of the given 
topologies the tool will also be used to determine the best way to enhance its reliability. 

Some assumptions about the problem follow. The role that the network is designed 
to fulfill is the bidirectional communication between all nodes, and the network is 
considered failed if all nodes cannot communicate. The link medium is assumed to be 
bidirectional (duplex) such as ethernet coaxial cable. For the most part, equivalent 
resources are available in each case. That is, twelve nodes and twelve links are available to 
construct the network. In the case of the star however, an extra component is assumed for 
the central connecting node, or hub. (In the actual simulation a "bypass switch" is used 
because we do not want the central node counted for Pseg or segment length - see Users' 
Manual). In general we know very little about the actual destruction probabilities for the 
various components. We have made the assumption that all components of one type have 
the same destruction probability. Additionally in certain design environments the nodes are 
more likely to fail than the links. This assumption has been made for one of the 
comparisons described here. 

Figure 5a and 5b show the two architectures as they were set up in the simulation 
environment. The probability of segmentation was chosen as the criterion of optimization 
because of its stringent nature and because of the previously stated goal of the network to 
provide communication to all nodes. As a reminder, our aim is to choose the topology 
which minimizes Pseg. Since we have very little information about the probabilities of 
failure, we must analyze the behavior of the network over a range of values for each 
component, thus generating a family of curves for each topology which paint a broad 
picture of their respective levels of connectivity. The main parameters to be varied are the 
probability of destruction for the nodes ( NPd) and for the links (LPd). In the case of the 
star the central nodes destruction probability (HPd) may also be varied. Figure 6 and 7 
show families of curves of Pseg versus LPd for different values of NPd, for the ring and 
the star architectures respectively. It turns out that the Pseg for the star is fairly sensitive to 
the value of HPd (see Figure 8). For the purpose of comparison we 
















































Probabllty of Segmentation, Pseg 


Probability of Segmentation for 
a 12 Node Ring with 0 Crosslinks 


1 5 



Probability of Destruction for Duplex Link Elements, LPd 


Figure 6 







Probability of segmentation, Pseg 


1 6 

Probability of Segmentation for 
a 12 Node Star and Hardened Hub,HPd=0 

1.0 

0.9 

0.8 

0.7 

06 

0.5 

0.4 

0.3 

0.2 

0.1 

0.0 

0.0 0.1 0.2 0.3 0.4 0.5 0.6 

Probability of Destruction for Duplex Link Elements, LPd 

Figure 7 



























Probability of Segmantlon, Paag 


Probability of Segmentation 
for a 12 Node Star and HPd=0.1 


1 7 



Probability of Daatructlon for Duplax Link Elamanta, LPd 


Figure 8 


















only examine two cases, HPd=0 and HPd=0.1, assuming a highly reliable hub can be 
used. 

From the figures we can see that the stars reliability is more sensitive to LPd than to 
NPd, whereas the rings reliabilr is more equally sensitive to NPd and LPd. Because we 
know that nodes are more likely to fail than links, we would like to make a comparison 
with this constraint. We can (somewhat arbitrarily) let LPd = 0.5 NPd and let NPd be 
varied. Figure 9 shows this for the star and ring. Also shown in this figure is the affect of 
adding crosslinks to the ring which will be discussed later. For all of the curves presented, 
failure probabilities beyond 0.5 were not investigated since the state of the network is less 
interesting when more than half of the components are removed (we assume that the 
network will almost assuredly be unusable in this state). Additionally, the value of Pseg 
approaches 0 as NPd approaches 1, by definition. This is somewhat counter intuitive and 
is not constructive in the comparison. 

In the last comparison only failure probabilities less than 0.1 were examined. This 
assumption of low levels of component failure can be reasonable in many cases, excepting 
possibly the military environment where high levels of damage can occur. The comparison 
in Figure 9 favors the ring over the star even with the generous assumption of HPd = 0. 

Given that a ring has been chosen, one may be interested in ways to enhance its 
reliability. There are two ways to approach this. The first is to try to minimize the failure 
probabilities of the components and the other is to add resources, namely links, to provide 
redundant connection. Assuming that all has been done to minimize failure probabilities we 
must turn to the addition of links. This begs the question; where should this link be placed 
to minimize the probability of segmentation. In the case of the twelve node ring an 
additional link was added between all possible pairs of nodes and it was determined that the 
diametric crosslink provides the most additional reliability. Data was generated for the ring 
with increasing number of diametric crosslinks. The results are shown in figure 9 through 
13. From these figures we can see the significant benefit to reliability realized by adding 
redundant links. 

It is also important to note that this has a greater impact on reliability than increasing 
the reliability of the hub in the star network. This is a significant result because it is often 
cheaper to add more links than to increase the reliability of certain components. 








Comparison of 12 Node Star with Hardened Hub 
to 12 Node Ring with 0 to 6 Crosslinks 



Ring 0 Crosslinks 
Ring 1 Crosslink 
Ring 3 Crosslinks 
Ring 6 Crosslinks 
Star HPd«0 


Probability of Destruction fro Node E laments, NPd 































Probability of Segmentation for 
a 12 Node Ring with 2 Crosslinks 



Probability of Destruction for Duplex Link Elements, LPd 





Probability of Segmentation for 
a 12 Node Ring with 3 Crosslinks 



Probability of Daatructlon for Duplax Link Elamants, LPd 


Figure 12 






Probability of Segmentation, Pseg 


23 


Probability of Segmentation for 
a 12 Node Ring with 6 Crosslinks 



Probability of Destruction for Duplex Link Elements, LPd 


Figure 13 








5.0 Verification of Results; 


One of the inherent problems with a simulated result obtained in the absence of a 
closed form solution, is the difficulty in verifying the output. Even when the principal of 
operation is sound, algorithmic errors can corrupt the results . Therefor it is necessarily to 
take extra steps to validate a simulation . In the case of the simulation described her , 
several techniques were used to gain confidence and corroborate the results. 

One technique that is useful is to look at limiting cases. Specifically, we can look at 
the probability of segmentation as the Pd of the components approaches aero or one. Pseg 
should approach zero as component failure probabilities approach zero(provided the 
network was unsegmented to begin with). Pseg should also approach zero as the Pd of all 
the components approaches one, as stated before. This method can be applied to all 
components or selected ones. Another verification scenario using this technique is a star 
network where all the satellite nodes and links arc given a Pd of 0 and the HPd is allowed 
to vary. As HPd approaches 0, Pseg approaches 0. In fact, Pseg should be exaedy equal 
to HPd at all values. 

Another technique is to examine simple cases with a few number of nodes and 
links. These can be worked out by hand and compared to the simulated result Taking this 
a step further, closed form solutions that have been derived for certain types of networks 
(see Theory of Operation ) can be compared to the simulated result. To add further 
confidence the comparison should be made for varying number of nodes and probabilities 
of destruction. This type of comparison was performed for die two closed form solutions 
provided earlier(equ. (8) and (9)) with positive outcome. Figure 14a and I4b show the 
results of the comparison. 

Another aspect of the simulation that can be verified is the convergence of the 
Monte-Carlo results with increasing number of trials. This technique was applied to a 
sample network by examining the spread of the computed result for Pseg over a set of 10 
runs with the number of Monte-Carlo trials varying from 10 to 100000. The results of this 
test are shown in figure 15. The performance is in agreement with that predicted by the 
expression for Monte-Carlo confidence intervals (equ. (10)). 






Comparison of Closed Form Solution to 
Simulated Results for 12 Node Duplex Ring 




Ctoaad-Fbrm 


o NatStat Paag 

* of Monte-Carlo 
Triala-10.000 


Figure 14b 


Nod# Probability of Fallura, NPd, whara LPdcNPd/2 

Comparison of Closed Form Solution to 
Simulated Results for 12 Node Simplex Ring 



Ctoaad-Form Paag 
NatStat Paag 

• of Monte-Cario 
Triala-10.000 


Figure 14a 


Noda Probability of Fallura, NPd, whara LPdaNPd/2 









26 


Graph Showing Convergence of Monte-Carlo 
Simulation with Number of Trials 



10 x Trials In Simulation 


Figure 15 



































6.0 Summary; 


NctStat has been demonstrated to be a useful tool in assessing the reliability and 
connectivity of networks. It is able to solve, through the use of Monte-Carlo simulation, a 
wide array of problems which are otherwise intractable when approached in a closed-form 
manner. The problem space addressed by NetStat is currently of great importance as infra¬ 
structures and information systems become more complex and new ones are designed. 

Problems such as those addressed by NetStat have been treated in current literature 
to the extent that closed form solutions could be derived in certain constrained problems. 
The metrics addressed by NetStat are generally accepted by the "networking" community as 
valid measures of reliability. It is in the area where closed form expressions cannot be 
derived that NetStat finds its utility. Additionally NetStat can be used to cross-validate 
closed form expressions where a higher level of confidence is required. 

It is the goal of the application to be generally applicable. To this end, NetStat 
provides a number of network elements for topology construction so that real world 
situations can be modeled as accurately as possible. These elements include specialized 
nodes such as hubs and bypass switches as well as bidirectional and unidirectional links. 
Failure probabilities for individual elements can be specified as the problem dictates. Once 
it is understood how NetStat treats the various components m the simulation, specialized 
scenarios can be constructed. 

NetStat also provides an easy to use graphic user interface. In this way visual feed 
back is available during problem setup. It is the aim of the application to be intuitive to 
operate so that more time can be spent on interpreting results than on problem set up. 
NetStat is implemented on the well known Macintosh platform increasing its ease of use 
and accessibility. Finally, ranges of output data can be generated in an easily graphable 
form so that a broad view of the problem can be mapped out. 






References and Bibliography: 


[1] Frank, H., et. al.. Communication, Transmission, and Transportation Networks. 
Reading,MA: Addison-Wesley Co., 1971 

[2] Harary, F., Graph Theory. Reading.MA: Addison-Wesley Co., Second Ed., 1971 

13] Deo, N., Graph Theory with Application to Engineering and Computer Science., 
Englewood Cliffs , NJ: Prentice-Hall Inc., 1974 

14] Tanenbaum, A., Computer Networks. Englewood Cliffs , NJ: Prentice-Hall Inc., 
1981 

[5] Ed. Dallas, I.,et. al.. Ring Technology Local Area Networks. Amsterdam,The 
Netherlands: Elsevier Science Pub. B.V., 1984 

[6] "On the Sample Sizes of Monte-Carlo Simulations - a Set of Useful Guidelines", The 
MITRE Corp., Bedford, MA. 

[7] "Network Survivability Through Connectivity Optimization”, The MITRE Corp., 
Bedford, MA. 

18] "A Survivable Network for Base Recovery After Attack", The MITRE Corp., 
Bedford, MA. 

19] Jeruchim, M., Techniques for Estimating the Bit Error Rate in the Simulation of 
Digital Communication Systems . IEEE J. of Selected Areas in Comm. Jan 1984 

[10] Cobb, R., Use Statistics to Test Communications Systems Efficiently . EDNJan 
1987 

[ 11] Lin, N.,et. al.. Ring Network Reliability - The Probability that All Operative Nodes 
Can Communicate . IEEE Proc. 8th Symp. on Reliable Distributed Systems,Oct 1989 

[12] Lin, N.,et. al., A Reliability Comparison of Single and Double Rings . IEEE Proc. 
of InfoComJun 1990 

[13] Boesch, F.,et. al.. On Graphs of Invulnerable Communication Nets . IEEE Trans, 
on Circuit Theory .May 1970 

[14] Ed. Boesch, F.,et. al., Networks, An International Journal. New York: Wiley 
Journals, Vol. 15, Num. 2, Summer 1985 

[15] Ed. Boesch, F., Large Scale Networks, Theory and Design. New York: IEEE Press, 
1976 








NetStat, Version 1.2 


User’s Manual 


G.S.Marzot 







INTRODUCTION 

The Network Survivable Topology Analytic Tool (NetStat) is a Macintosh 
applicatio' designed to aid a network architect or administrator in assessing the 
survivability/reliability of a given network topology. NetStat enables the user to 
graphically and interactively describe a network topology. The user is provided with 
several types of network elements(nodes,hubs,bypass* 
switches,unidirectional/bidirectional links) so that real-world topologies can be 
realized. After specifying destruction probabilities for each network 
element(individually or by type) the user can then run a Monte-Carlo simulation on 
the network to estimate certain connectivity metrics - the metrics available in this 
application are explained below. Tools are provided to edit, save and rearrange 
the topology so that a series of tradeoff scenarios may be investigated. In this way 
the user can allocate network resources in an intelligent way to maximize 
connectivity under a variety of conditions. 

ABOUT BOX 



Network Suruiuoble Topology Analytic Tool (NetStot) 

Uersion 1.2b by G. Marzot emoll:gmarzot<s>linus.mitre.org 

This Freeware application is an extension of the suruiuability 
analysis described in the MITRE document, MTR-10665 

Rknowledgement to U.C.Georgopoulos and B.D.Metcalf 

This application is also presented in partial fulfillment of 
my Tufts University MSEE project - Prof.Chong, Advisor 

Rll Rights Reserved - 1990,1991 

Portions of the Source Copyright© by the Symantec Corp. 


OK 







USER INTERFACE 
toolpalette: 


r 6 File Edit Analyze 



The network architectures are constructed in the application’s drawing pad 
in the main part of the application window. In the left hand side of the application 
window a toolpalette is provided to assist in this operation. Each icon in the 
palette, when selected, corresponds to a mode that determines what will be 
drawn(or erased) in the drawing pad. A tool is selected by clicking on its icon in the 
palette. The icon remains selected (greyed) until the task associated with it is 
performed once then the tool becomes unselected and the cursor returns to an 
arrow. A tool may be indefinitely selected (locked/black) by double-clicking in the 
desired icon. The user may now perform the selected task a number of times. The 
user may change the tool by clicking in another icon or return to the default arrow 
tool by clicking in the blank area at the bottom of the palette. The tasks performed 
when each tool is selected are listed: 





























Node Tool - 


Add node to architecture by clicking in drawing pad, 
cursor is a square 
Hub Tool - Add hub to architecture by clicking in drawing pad, 

cursor is a square 

Bypass Tool - Add a bypass switch to architecture by clicking in 

drawing pad,cursor is a square 

Simplex Link Tool - Join any two nodes(nodes,hubs or bypasses) by clicking 

in the source node then in the destination node(order 
determines direction), the cursor is a line with one arrow 
Duplex Link Tool - Join any two nodes by clicking in the source node then in 

the destination node(order does not matter), the cursor 
is a line with two arrows 

Hammer Tool - Remove any node by clicking in it, all links incident on 

the node are also removed, cursor is a hammer 
Scissor Tool - Remove a link by clicking first in one terminal node then 

in the other(order does not matter), the most recently 
added link will be removed, cursor is a pair of scissors 
Arrow Tool - Default tool, Inspect the state of any network element 

(node or link) by clicking in(on) it and set the failure 
probability provided that option has been checked in the 
Simulation Parameters dialog box(see below), cursor is 


an arrow 






menus: 



Edit Analyze 


N«U> v.'N 

Open #1) 

— . = 1 ~ ~=i 

3§lt 

5 

Close wC 



Load XL 


1 

Saue X$ 


ili 

Print #P 


|: :• 
ij 

Quit XQ 


l?Hi= 

111 


Wii 


The File menu allows a preexistent architecture to be loaded from a file 
using the Load menu item. The architecture is usually stored in a file with the 
name "fname.arch". The Saue menu item will allow a recently constructed topology 
to be saved to a file along with all present application settings. The Quit menu 
item quits the application, (note: clicking in the application close box also quits the 
application.) All other greyed items are unimplemented. 


r * File 



Analyze 


Undo 

Cut |:|{ 


a 

Copy #C 


□ 

Paste #11 


u 

ClearAII 


! 



||S 

In 


The Edit menu allows the user to remove all nodes and links in the drawing 
pad by selecting the Clea^AII menu item. All other greyed Herns are 
unimplemented. 
























r * File Edit 


Analyze 




The Analyze menu allows the user to set parameters related to the 
simulation and the output format. By selecting the Simulation... menu item the 
Simulation Parameters and Settings dialog box is displayed(ser below). By 
selecting the Output... menu item a dialog box displaying output specifications is 
displayed (see below). The Run menu item initiates a simulation in accordance 
with the present application settings. 

dialogs: 


Simulation Parameters and Settings 


<§) Monte Carlo #of Monte Carlo States 1000 

O liHlitiuttiue #of total system states 2* 0 

O Indiuidualiy Defined Destruction Probabilities 
<§) Destruction Probabilities Set by Type (see below) 


Node 


from to step size 
Pd- 1 0.250 | <§) or 1 0.000 | 1 0.500 | [o.lQQ ] O 

Pd- 10.250 I <§> or 10.000 I 10.500 | 10.100 I O 


Bypass Pd- ! 0.250 <§> or 0.000 0.500 0.100 O 

SimpleK Link Pd- 10.125 | <g) or 0 000 | [o.5QQ | 0.100 | Q 

OtlpleM Link Pd- |0.125 (•) or 0.000 0.500 0.100 O 

OK [ Cancel ] 

i - - 3 






















The Simulation Parameters and Settings dialog box allows the user to 
specify the number of Monte-Carlo trials that will be generated in the simulation. 
As a reference the total number of system states, based on a binary state for each 
network element, is shown in a static text field. The exhaustive simulation is 
unimplemented. This would generate every realizable state for the system and 
would be unrealistic for most networks. A radio button is provided to choose 
between individually definable failure probabilities for the network elements or 
failure probabilities which are set by element type (i.e., node, hub, simplex link, 
etc.) . When the individually settable option is selected each element can be 
assigned a different Pd (see ToolPalette for details). When the "by type* option is 
selected all elements of the given type will have the same Pd. When the 
destruction probabilities are set by type there is a further option to make them 
constant or generate data over a range of destruction probabilities, (note: the 
choice of a ranges produces nested loops and will greatly increase simulation time, 
Best to run once with constant probabilities and then determine how many 
iterations are reasonable) 


Probality of 
segmentation 

PI Expected value of 

maximum segment length 

□ Ruerage segment length 

PI Expected value of 
connected polrs 

output filename: 

(untitled 1 


OK ] [ Cancel } 


The output settings dialog box determines which metrics will be 
generated and put out to a file when the Run menu item is selected. A check mark 








next to the metric indicates that it will be calculated and dumped to the specified file 
in the output filenotne text field. A special feature is enabled when no metric 
is checked. The probability of segmentation will still be calculated when Run is 
selected but no file I/O will take place and the result will still be printed to the 
screen. The simulation will run up to twice as fast in this mode. 


Element Record 

ID#: 1 

TYPE: NODE 

Status: RUDE 

Link Record 

ID#: 1 

TYPE: DPLH 

Status: RUDE 

Pd: 0.250 

Pd: 0.125 




CRNCEL OK 1 

i _ i 



These dialog boxes are displayed when the user dicks in or on any network 
element(node or link respectively) while the cursor is the default arrow. The Pd field 
may be edited to a probability between 0.0 and 1.0 inclusive provided the 
"individual setting” option has been checked in the Simulation Parameters dialog 
box. 


CONNECTIVITY METRICS 

When the Monte Carlo simulation is run an ensemble of the network states 
are generated and the connectivity metrics are computed over that ensemble. 
That means, that for one Monte-Carlo trial each network element may operational 
or non-operationai.based on its Pd, resulting in a new network which is a subset of 
the original one. This resultant network can be analyzed in terms of its connectivity 
metrics (segmentation, segment size, connected pairs, etc.) and the result can be 














stored. This process is repeated n times,where n is the number of Monte-Carlo 

trials, and the results are averaged over n producing estimates of the metrics. 

Probabitity 

of Segmentation - In graph theory jargon, this is the probability that a given 

graph will contain more than one component. Stated 
again, it is the probability that at least one surviving 
node will not have duplex connection with at least one 
other surviving node. 

Average 

Segment Length - Average segment length (normali 2 ed to the undamaged 

segment length) 

Expected Value 

of Connected Pairs - Connected pairs are defined as the number of pairs of 

surviving nodes that can communicate in a given graph. 
For each segment the number of connected pairs 
equals N choose 2, or N*(N-1)/2 where N is the 
number of nodes in that segment. (Normalized to 
undamaged number of connected pairs) 

Expected Value of 

Max. Segment Length • In each Monte-Carlo trial the size of the maximum 

segment is recorded and averaged over the ensemble 
of states. This is useful for investigating need for 
resource replication in distributed processing 
applications. ( Normalized to undamaged segment 
length or total number of nodes) 






FILE I/O 


Output over ranges of input parameters can be computed and dumped to a 
file which is readable by CricketGraph™. The file is in tab delimited ASCII form 
and can be read by most graphing and plotting software. 

Architectures can be saved to a file (Filename.arch) and reloaded later. 

GRAPHING RESULTS W/ CrlcketGraph™ 

This is accomplished by selecting both the output file and Cricket Graph and 
then double-clicking on Cricket Graph. You may also read in the output file from 
CricketGraph by selecting the show text file option from within CricketGraphs 
Open... menu item dialog box. Appropriate column labels will be displayed. 

LIMITATIONS/BUGS 

The application is limited to 256 nodes with 256 links per node. 

There is a limit of A links between any two nodes. 

It is important to note that a 12 node system with 12 links simulating 10.000 Monte- 
Carlo states on a Mac Ilex takes approximately 10-15 seconds and that run time 
increases with the number of states and the number of total elements. Some 
simulations can run prohibitively long. Start with a small number of trials. 

The application is designed to run on a Macintosh equipped with an 881/882 FPU. 
it will crash if one is not present. 


The application will crash if you try to load an improper file - this bug will be fixed 





GLOSSARY 


Pd * the probability that a given network element wiii fail. 

Nodes - Nodes represent network components such as terminals, modems, 
communication equipment or any similar items where users might 
reside or locations where messages are relayed. The term node is 
sometimes used to mean hubs and bypass switches as well. 

Hubs - Hubs are the center nodes for star networks. Hubs are very similar to 
Nodes. The only difference is a conceptual one. The separate 
representation allows the individual setting of the hubs Pd as in a 
hardened hub star network where the hub has a Pd«=0 and the nodes 
may have a non-zero Pd. 

BypassSwitches - Bypass switches are usually three terminal components which 
can sense the loss of one connection and switch to the other. This 
allows nodes to be remoted from a network so that their loss has less 
of an impact on its connectivity. Bypasses are not counted in 
segment length .connected pairs, nor is a segment consisting solely 
of switches considered valid for the probability of segmentation. 
Nodes and Hubs are. 

SimplexUnks - Simplex links are unidirectional communication links. This allows 
each path of a duplex link to be represented separately. Connection 
with simplex links is deemed valid only if a round trip path exists 
between the elements being considered. 

Duplex Links -Duplex links provide bidirectional communication between the two 
nodes connected. Any two elements linked with an operational 
duplex link are considered connected. 















ConsVars Unit 


f 

| 

t 

I 


i 

i 





04 / 22/91 21:17 


ConaVara.u 


Pag* 1 


unit ConsVars; 
lnt*rfae* 
cc-»t 

{low m*mory nasties} 

KSFSaveDisk ■ $214; { Negative of current volume refnum (WORD) } 

kCurOirStor* ■ $398; { DirlD of current directory {LONG] } 

DEF STATES ■ 1000; {default values for Simulation dialog box) 

DEF_NOOE_PD - 0.25; 

DEF LINK_PD • 0.125; 

DEF_FRM_PD - 0; 

DEFJTO_PD • 0.5; 

DEF_STP_SZ - 0.1; 

BASE_RES_ID » 400; (base resource ID for most res} 

NIL_POINTER ■ 0; {Parameters for various tool box calls} 

MOVE_TO_FRONT . -1; 

REMOVE_ALL_E VENT S - 0; 

SUSP_RES_MESS-1; 

RES_MASK a 1; 

NO.EVENT . 0; 

ADD_CHECK_MARK a TRUE; {menu check parameters} 

REMOVE_CHECK_MARK - FALSE; 

DRAG_THRESHOLD ■ 10; {window parameters} 

SBarWidth « 15; 

TOOL SIZE « 32; 

PADJJMIT - 1024; 

MAX_NEG a -32768; {integer range} 

MAX_POS . 32767 - 1; 

MIN_SLEEP a 0; {parameters for waitnextevent call/verify} 

NIL MOUSEJ^EGION . 0; 

WNE_TRAP_NUM - $60; 

UNIMPL_TRAP_NUM . $9F; 

SIM DLOG - BASE RES ID + 1; {dialog box res ID} 

OUT.DLOG « BASE_RES_ID ♦ 2; 

ELEM DLOG - BASE_RES_ID ♦ 3; 

UNK_DLOG - BASE_RES_ID ♦ 4; 

NEW ITEM a 1 ; (file menu Items} 

OPEN ITEM - 2; 

CLOSEJTEM.3; 

LOAD ITEM • 4; 

SAVEJTEM « 5; 

PRINT JTEM • 6; 

QUIT ITEM - 7; 


UNDO JTEM . 1; 


(edit menu items} 





04/22/91 21:17 


ConaVara.u 


Pag* 2 


CUTJTEM . 2; 

COPY JTEM . 3; 

PASTEJTEM - 4; 

CLEARJTEM - 5; 

SIM_fTEM ■ 1; {analyze menu items} 

OUT.ITEM - 2; 

RUN JTEM - 4; 

ABOUTJTEM « 1; {apple menu item] 

APPLEJ4ENUJD-BASE_RESJD; {manures IDs) 

FILE.MENU ID - BASE.RES ID* 1; 

EDIT_MENUJD - BASE_RESJD ♦ 2; 

ANAL_MENUJD - BASE_RESJD ♦ 3; 

NODE ICON - BASE_RES_ID; {tool/element icon res IDs] 

HUBJCON - BASE_RES_ID * 1; 

BYPICON . BASE_RESJD * 2; 

SPLXJCON - BASE.RESJD + 3; 

DPLXJCON « BASE_RES_ID * 4; 

CUTN ICON « BASE_RESJD ♦ 5; 

CUTLJCON - BASE_RES_ID * 6; 

NULLJCON - BASE_RES_ID ♦ 7; 

ABOUT_ALERT - BASE_RESJD. {alert res ID} 

ELEM_CURS * BASE_RESJD; {cursor res IDs} 

CUT_NODE_CURS « BASE_RESJD * 1; 

ADD_SLNK_CURS - BASE_RES_ID * 2; 

ADD_DLNK_CURS - BASE.RESJD ♦ 3; 

CUT_LINK_CURS « BASE_RESJD ♦ 4; 

Dl.TOP * $0050; (location for error alert for bad disk routine) 

DIJ.EFT . $0070; 

MAXJTEMS - 127; {maximum nodes+bypass+hubs/links from one node} 

ALINK m TRUE; {parameter for cutelem} 

NOT_ALINK « FALSE; 

PI . 3 141502654; {%) 

type 

PtrToLong » Nongint; 

PtrToWord • A integer; 

(node/bypaas/hub variables for set operations and bookeeping} 

NodelDType . 0 .255; 

Nod*Set ■ aet of NodelDType; 

SetArrayType » erray{0..127) of NodeSet; 

SArrayPtr « A SetArrayType; 








04/22/91 21:17 


C onsVars.u 


Peg* 3 


{too) related typos} 

ToolStateType * (off, on, lockod); 

ComType - (Ada Node. AddHub, AddByp, AddSplx, AddDplx, CutNode. CutLink, NuliCom); 

LinkComs * sot of AddSplx..CutLink; 

MapType « arroy[AddNode..NullCom} of Reel; 

(network olomont types} 

ElomType « (Node, Hub, Bypass, Optx, Splx); 

UnkEtems - set of Dplx..Splx; 

{Node like element record structure} 

LinkPtr • “Link; 

ElomentPtr • ^Element; 

NodeArray « errey{0..127) of ElementPtr; 

LinkArray - array(0..127] of LinkPtr; 

Element - record 
10; NodelDType; 

Kind; ElomType; 

Pd: Real; 

Loc: Reel; 

Alive: Boolean; 

LList: LinkArray 
end; 

FEIement - record 
Kind; ElomType; 

Pd; Real; 

Loc: Rect; 
end; 

{link element record structure} 

Link » record 
Kind: ElomType; 

End 11D, End2ID: integer; 

Endl, End2: ElementPtr; 

HookPtl, Alptl, A2pt1. HookPt2, Alpt2, A2pt2, Aptl, Apt2: Point; 

Alive; Boolean; 

Pd: real 
end; 

FUnk » record 
Kind: ElomType; 

Endl ID, End2ID: integer; 

Pd: real 
end; 

(Dialog element types and record} 

DIoghemType - (Npd, Hpd, Bpd, Spd, Dpd, Nfr, Nto, Nat, Hfr, Hto, Hst, Bfr, Bto, Bat, 8fr, Sto, SaL Dfr, 
Dto.0 

Dat, Mat Tat, Mon, Exh, Nc. He, Be, Sc, Dc, Nr, Hr, Br, Sr, Dr, Ind, Typ, Paeg, Aval. Ecp, Emal); 

DialogRec « record 

SimStrArr: array[Npd..Tat] of Str2S5; {Npd-3.Sst.24} 

SimRadArr: array (Mon..Typ] of boolean; (Mon-48,Dr-59.lnd-25, 




04/22/91 21:17 


ContVars.u 


Pag* 4 


Typ«26.ffom/to/step«33-35) 

OutChkArr: array(Pseg. Emsl] of boolean; {Pseg«5,Emsl«8} 

OutFileStr; Slr255 { } 

•nd; 

TFiloPtr . A text; 

ArchRec - record 

NodeArr; array(0..127] of FElement; 

LlnkArr: «rray[0..127) of FLink; 

NumNodes: longint; 

NumLinks: longint; 

OtogRoc; DialogRec 
•nd; 

ArctiFile - fit* of ArchRec; 

AFiJoPlr m “ArchFile; 

var 

gLinkSet: LinkElems; {set of link elements to destinguish from nodes} 

gLComSet: LinkComs; {set of link related commands to destringuish from node corns) 

gTState: TootStateType; {present state of the tool panel) 

gPadWindow: WindowPtr; {global window storage) 

gSimOiogPtr, gOutDlogPtr, gElemDIogPtr, gLinkDIogPtr: DialogPtr; 

{Dialog Pointers to bne loaded in initially and dereferenced 

later] 

gDiogRec; DialogRec; {record of dlog box item states) 

gDone. {TRUE when time to leave app) 

gWNEImplemented. {TRUE when WaitNextEvent trap is implemented} 

gFirstClick, {TRUE for first clik in content } 

glnBackground: Boolean; {TRUE when application is in background used for activate event) 

gTheEvent: EventRecond; {the event) 

gAppleMenu, gAnalMenu: MenuHandie; {menuhandels) 

gDragRect; Reel; {window drag limits) 

gVScroll, gHScroll; ControlHandle; {scroll bar handies) 

gNumSegs, gTotalSegs, gNumStates, gSegCount, gCurrentTime, gOldTime, gFirstID, gNumNodes, 
gNumLinks: longint; 
gFileName: Str255; 
gOrigin: Point; 

gPseg, gAvsl, gEcp, gEmsI, gPInch: extended; 

gllpdateRgn: RgnHandle; 

gMode: ComType; 

gTMap; MapType; 

gNodeArr: NodeArray; 

gNilLinkArr, gLinkArr: LinkArray; 

gMaxSegArr, gSegLnthArr; array[O..MAXJTEMS] of longint; 

gWhenFirstClick: longint; 

gBypSet, gNodeSet: NodeSet; 

gWorld. SysEnvRec; 

gSFSaveDisk; PtrToWord, 

gCurDirStore; PtrToLong; 

Implementation 






Main 








03/30/91 10:40 


Maln.p 


Pag* 1 


<*»♦> 

program Stat {input, output); 

HIM 

ConsVars, Engine; 

procedure Grow (w; WindowPtr; p; Point); 
lorwerd; 

r PathNameFromDirlD 


C) 

{(* Given a DirlD and real vRefnum, this routine will create and return the) 
{(* full pathname that corresponds to it. It does this by calling PBGetCatlnfo) 

{(* for the given directory, and finding out its name and the DirlD of its) 

i(* parent. It the performs the same operation on the parent, sticking US) 

{(* name onto the beginning of the first directory. This whole process is} 

{(• carried out until we have processed the root directory (identified with} 

{(• a DirlD of 2.} 

in 

function PathNameFromDirlD (DirlD: longint; vRefnum: integer); str255; 

ear 

Block: ClnfoPBRec; 

directoryName, FullPathName: str255; 
err; OSerr; 

begin 

FuMPathName > "; 
with block do 

begin 

ioNamePtr ;« ©directoryName; 
ioDrParlD ;» Dirld; 

end; 

repeat 

with block do 

begin 

ioVRefNum > vRefNum; 
ioFDirlndex :» *1; 
ioDrDirlD :• block.ioDrParlD; 

end; 

err :« PBGetCatlnfof© Block, PAUSE); 


) 


directoryName concat(directoryName, 
fullPathName :■ concat(directoryName, fullPathName); 

until (block.ioDrDirlD - 2); 

PathNameFromDirlD ;« fullPathName; 

end; 

(*• PathNamofromWD 

.) 





03/30/91 10:40 


Maln.p 


Pag* 2 


(*) 

{(* Given an HFS working directory, this routine returns the full pathname) 

{(* that corresponds to it H does this by catting PBGetWDInfo to get the) 

{(* VRefNum and DirlD of the real directory It then calls PathNameFromDirlD,} 
{(* and returns its result.) 

{<*} 

{ (..*.*. 

.) 

function PathNameFromWD (vRefNum: longint): «tr255; 

ve r 

myBlock. WDPBRec; 

err: OSerr; 

begin 

with myBlock do 

begin 

ioNamePtr :« nil; 
ioVRefNum :* vRefNum; 
ioWOlndex ;■ 0; 
ioWDProcID :« 0; 
end; 


{ Change the Working Directory number in vRefnum into a real vRefnum ) 
{ and DirlD. The real vRefnum is returned in ioVRefnum, and the real } 

{ DirlD is returned in ioWDDirlD. } 

err :« PBGetWDlnfo(@myBlock, FALSE); 

with myBlock do 

PathNameFromWD > PathNameFromDirlD(ioWDDirlD, ioWDVRefnum) 

end; 


{/*... Binomial ..***/} 

function Binomial (num: integer); integer; 
ve r 

i, p: integer; 

begin 

P > i; 

If num > 1 then 
p :• (((num - 1) * num) div 2) 

else 

p :• 0; 

Binomial > p 

end; 

{/*•*•. Doubleclick .*.*./} 

function Doubleclick; boolean; 
begin 

If TickCount > (gWhenFirstClick + GetDblTime) then 












03/30/91 10:40 


Maln.p 


begin 

gWhenFirstClick :• TickCount; 
Doubleclick :» FALSE 

end 

• lee 
begin 

Doubleclick TRUE; 
gWhenFirstCltck ;« 0 
end 
end; 


{/*••••*.*****RNumToString**.*.**/} 

procedure RNumToString (num: real; var theString: Str255); 

va r 

myStringl, myString2, myString3: Str255; 
j; integer; 
begin 

NumToString(trunc(num). myString3); 
num ;■ Abs(num - trunc(num)); 
i :» round(num * 1000); 
myString2 :« 

NumToString(i, myStringl); 

II ({i < 100) end (i >• 10)) then 
myStringl :■ eoncatfO', myStringl) 

•lee If i < 10 then 
myStrngl :» eoncatCOO', myStringl); 
theString :» concat(mySthng3. myString2, myStringl) 
end; 


j/.... StringToRNum ••••••••• 

procedure StringToRnum (theString: Str255; var num: real); 

var 

myStringl. myString2: Str255; 
i. j, k; integer; 
n: longint; 

begin 

i :■ pos(*.', theString); 

If i • 0 then 
begin 

StringToNum(theString, n); 
num :• n; 

Exit(StringToRNum) 

end; 

k ;■ po*(’-’, theString); 

If k m 0 then 
begin 

myStringl :« eopy(theString, 1. i - 1); 

String!oNum( myString 1. n); 
j > 1 







03/30/91 10:40 


Maln.p 


else 
bag In 

my Siring 1 :■ cop>y(theSlring, k «■ 1, i - 1 - k); 
StringToNum(myString1. n); 

j - 1 

and; 

num :« n; 

myStringl :» copy(thaString. i 1, 1); 
StringToNum(mySlring1. n); 
num :• num (n / 10); 
myStringl :» copy(thaSlring, i ♦ 2. 1); 
StringToNum(myString1, n); 
num :■ num ♦ (n / 100); 
myStringl copy(theString, i ♦ 3. 1); 
StringToNum(myString1, n); 
num :> num •*- (n / 1000); 
num :■ num * j; 
and; 

{/. IsDAWindow . 

function IsDAWindow (w: WindowPtr): Boolean; 

bagin 

If w m nil than 
IsDAWindow :* FALSE 

alaa 

IsDAWindow :■ (WindowPeek(w)\windowkind < 0) 

and; 

{/*.. IsAppWindow .. 

function IsAppWindow (w: WindowPtr): Boolean; 

begin 

If w * nil than 
IsAppWindow :« FALSE 

alsa 

IsAppWindow (WindowPeek{w)\windowkind ■ userkind) 

and; 

jy........... SetScreen*******/} 

procedure SatScraan; 
var 

thaRect: Rect; 

begin 

the Reel > gPadWindow\porlRect; 
thaRect.right :■ thaRect.right - SBarWidth; 
thaRect.bottom :■ thaRact.botton - SBarWidth; 
thaRect.la ft > thaRact.laft ♦ TOOL_SlZE ♦ 2; 
OffsatRact(thaRact. gOrigin.h, gOrigin.v); 
ClipRact(thaRact); 

SetOrigin(gOrigin.h, gOrigin.v) 
and; 

[/. RasatScraan.****/) 

procedure RasatScraan; 

















03/30/91 10:40 


Maln.p 


Pig* t 


begin 

SetOrigin(0, 0); 

CbpRect(screenBits. bounds) 
and; 

{/***.. DrawArrows .*••*••/) 

procedure DrawArrows (thaLink: LinkPtr); 

var 

riaa, run: inlagar, 
ptl, pt2: Point; 
ap. apl, ap2: point; 

begin 

with thaUnk* do 

Pag In 

PenSize(2, 2); 

MovaTo(A1pt1.h, Alptl.v); 

LineTo(Ap11.h, Aptl.v); 

MovaTo(A2pt1.h, A2pt1.v); 

LinaTo(Apt1.h, Aptl.v); 

If kind - Dplx than 
bag In 

MoveTo(A1pt2.h. A1pt2.v); 

LinaTo(Apt2.h, Apt2.v); 

MoveTo(A2pt2.h, A2pt2.v); 

LineTo(Apt2.h, Apt2.v); 

and 

and; 

PenSize(T, t) 

and; 

{/ * ............. ...... DrawCont.^ 

procadura DrawCont; 
va r 

theRect: Ract; 
myTimeString: Str255; 
ih: Handle; 
ph: PicHandla; 

I, j: intagar; 
bag In 

far i ^ 1 to gNumNodes do 
bogln 

j :« 1; 

Ih :» Gat Icon (NOD EJCON + ord(gNodeArr[i]\kind) - ord(Node)); 

Plotlcon(gNodeArr{i]\Loc, Ih); 
whlla gNodeArrp]\LList[j] «> nil do 

bogln 

MoveTo(gNodeArr[i)\Llist[j]\HookPt1 .h, gNodaArr(i) A .LLiat[j) A .Hook Ptl .v); 
LlneTo(gNodeArr[i]\LUtt[j) A .HookPt2.h, gNodaArr(i]\LList[j) A .HookPt2.v); 
DrawArrows(gNodeArr[i]\LList[j]); 
j j ♦ 1 

and 










03/30/91 10:40 


Meln.p 


Pag* • 


•nd 

end; 


{/**. Gray Icon . /} 

procedure Graylcon (com: ComType); 

ver 

Ih: Handle; 
begin 

Hi :• Getlcon(NODEJCON ♦ ord(com) - ord(AddNode)); 
Ptotlcon(gTMapfcom), ih); 

PenMode(PatOr); 

PenPat(ltGray); 

PaintRect(gTMap[com]); 

PenPat(black); 

PenMode(patCopy) 

end; 


{/*'***•** .. * DrawTools...• /) 

procedure DrawTools; 
ver 

ih: Handle. 
tRect: Rect; 
com: ComType; 
prevBottom: integer; 
begin 

PenSize(1, 1); 

prevBottom :« gPadWindowVportRect.top; 
for com :■ AddNode to CutLink do 

begin 

gTMap{com] :* gPadWindow\portRect; 

gTMap(com).top :• prevBottom; 

gTMapfcom).right :« gTMapfcomj.left ♦ TOOL_SIZE; 

gTMapfcomJ.bottom :» gTMapfcom].top ♦ TOOL_SIZE; 

prevBottom :■ gTMap(com].bottom; 

ih > Getlcon(NOOEJCON ♦ ord(com) - ord(AddNode)); 

Plotlcon(gTMap[com], ih); 

FrameRoct(gTMap{com]) 

•nd; 

SetRoct(gTMap(NullCom], 0, 0, 0, 0); 

MoveTo(gTMap(Cutlink). left, gTMap[CutLink].bottom); 
LineTo(gTMap[CutUnk].right ♦ 1. gTMap(CutLinkJ.bottom); 

If gMode o NullCom then 
ease gTState of 
on: 

begin 

Graylcon(gMode) 

•nd; 

locked: 

b«gin 

Invert Rect(gTMap[gMode]); 










03/30/91 10:40 


Maln.p 


Pig* 7 


•nd; 

off: 

•nd; 

PanSiza(2. 1); 

tRact :« gPadWindow\portRaci; 
tRact.right :■ tRact.laft «• TOOL_SI2E; 

MovaTo(tRact.right. tRact.top); 

LinaTo(tRact.nght, tRact.bottom - SBarWidth); 

PanSizaft, 1) 

•nd; 

J / • * * *.DrawWindow.* * /} 

pro cad ura DrawWindow (theWindow: WindowPtr); 

va r 

thaRact. Ract; 
tnyTimaString: Str255; 
b*gln 
SatScreen; 

DrawCont; 

RasatScraan; 

DrawTools 

•nd; 

{/*.UpdataWindow * * * *. ****/} 

procadura UpdataWindow (thaWindow: WindowPtr); 

va r 

aavaPort: QrafPtr; 

bag In 

GatPort(aavaPort); 

SatPort(thaWindow); 

BaginUpdata(thaWindow); 

If not Empty Rgn(thaWmdow\visRgn) than 

bagln 

ErasaRact(thaWindow A .portRact); 

DrawWindowf thaWindow); 

DrawControlaftha Window); 

OrawGrowlcon(thaWindow) 

•nd; 

EndUpdata(tha Window); 

SatPort(aavaPort) 

•nd; 


{ /..Grow.*./} 

proc*dura Grow (w: WindowPtr; p; Point); 
var 

aavaPort: GrafPlr; 
thaRaault: iongint; 
oScroll: intagar; 












03/30/91 10:40 


Maln.p 


Page • 


r, oView, viewRect: Rect; 

begin 

GetPort(savePort); 

SetPort(w); 

SetRect(r. TOOL_SIZE * 18, 7 * TOOl_SIZE 4 18, screenBits.bounds right, screenBits.bounds.bottom); 
theResult > GrowWmdow(w, p, r); 

If (theResult <> 0) then 
begin 

viewRect w A .portRect; 

lnvalRect(gVScroll*\contrlRect); 

lnvalRect(gHScroll AA .contrlRect); 

EraseRect(gVScroll AA .contr1Rect); 

EraseRect(gHScroll AA .contrlRect); 
viewRect.left :• viewRect.right • SBarWidth; 
viewRect.top > viewRect.bottom • SBarWidth; 

InvalRect(viewRect); 

EraseRect (viewRect); 

SizeWindow(w, LoWord(theResult), HiWord(theResult), TRUE); 

HidePen; 

MoveControl(gVScroll, w\portRect.righi • SBarWidth, w\portRect.tcp * 1); 

SizeControl(gVScroll. SBarWidth 4 1, w\portRect.bottom • w*.portRect.top • (SBarWidth - 2)); 
MoveControl(gHScroll, w A .portRect.left - 1, w\portRect.bottom • SBarWidth); 
SizeControl(gHScroll, w A .portRect.right - w A .portRect.left * (SBarWidth - 2), SBarWidth ♦ 1), 
ShowPen; 

UpdateWindow(w); 

SetPort(savePort) 

•nd 

end; 


1 /.*.HandleNull./} 

(/•••’*•.. SaveSettings ........*..../j 

procedure SaveSettings (theDlog; DiaiogPtr); 

va r 

HemType; integer; 
i: DIogltemType; 
itemHandle; Handle; 

HemRect: rect; 

begin 

with gCMogRec do 
begin 

H theDlog - gSrmD/ogPtr then 

begin 

for i :■ Npd to Mat do 
begin 

GetDltem(gSimDlogPtr, (ord(i) • ord(Npd) ♦ 3), itemType, itemHandle. HemRect); 
GetlText(itemHandle, SimStrArrfiJ); 

end; 

♦or i :« Mon to Typ do 
begin 

If i < Ind then 

begin 









03/30/91 10:40 


Maln.p 


Pag* 9 


GalDltam(gSimDlogPtr, (ord(i) • ord(Mon) * 48), itamTypa, ItamHandia, itamRacI); 
SimRadArr(i) :■ Boolean(GetCtlValua(ControlHandle(itemHandle))) 

and 

•la* 

begin 

GatDltam(gSimDlogPtr, (ord(i) - ord(lnd) ♦ 25), ilamTypa, itamHandia, ItamRact); 
SimRadArr(i) > Boolean(G*tCtlValue(ControlHandla(it*mHandl*))) 

•nd; 

•nd 

•nd 

•la* 

begin 

tor i:» P»*g to Emsl do 
b«gln 

GatDltem(gOutDlogPtr, (ord(i) • ord(Psag) ♦ 5), itemTypa, itamHandia, itamRact); 
OutChkArrtf] :• Boolaan(GatCtlValue(ControlHandle(itemHandle))) 

•nd; 

GatDltem(gOutDlogPtr. 3. ilamTypa. itamHandia, itemRect); 

Gat!Taxt(itamHandie, OutFileStr) 

•nd 

•nd 

•nd; 

{/••••••*.. Rastora Settings .. /} 

procedure Restore Settings (thaOlog: DialogPtr); 

• • r 

i: DJogllamType; 
ilamTypa. integer; 

ItamHandia: Handle, 

ItemRect: rect; 

begin 

with gDiogRec do 

begin 

BringT oFront(th*Dlog); 

If IhaDlog « gSimOlogPtr than 

begin 

GatDlt«m(gSimOiogPtr, 25, ItamTypa, itamHandia, itemRect); 
SetCtlValua(ControlHandla(itemHandla), lnteger(SimR*dArr(lnd])); 
QatDltem(gSimOlogPtr, 26, itemType, itamHandia, itemRect); 
SatCt!Valua(ControlHandle(itamHandle), lntager(SimRadArr[Typ))); 
far i > Npd to Mat do 
begin 

GatDltem(gSimDlogPtr, (ord(i) • ord(Npd) * 3), itamTypa, itamHandia, ItamRact); 

Sat ITaxt(itamHandia, SimStrArrji]); 

and, 

for i > Hon to Or do 
begin 

QatOltam(gSimDk>gPtr, (ord(i) - ord(Mon) ♦ 48), itamTypa, itamHandia, ItamRact); 
SatCtlValua(ControlHandla{itemHandla), lntagar(SimRadArr{i))); 

•nd; 

•nd 







03/30/91 10:40 


Maln.p 


Pag* 10 


•laa 

bag In 

for i:« Paag to Ernst do 
bagln 

GetDHem(gOutDiogPtr. (ord(l) • ord(Psag) + 5), ilemType, itemHandla, itamRact); 
SatCtlVaiua(ControlHandta(itamHandla). lntager(OutChKArr(i])); 

and; 

GatDltam(gOutOlogPtr, 3, itemType, itamHandle. itamRact); 

SatlTaxt(itamHandle, OutFiiaStr) 

and 

and 

and; 

j/.* * * HandlaApplaChoica . ./} 

procadura HandlaApplaChoica (thaltem: integer); 

var 

accNama; Str255; 
n, accNumber: integer; 
itenNumber; Byle; 

AboutOialog: OialogPlr; 
begin 

ease (theltem) of 
ABOUT_ITEM: 

n NoteAlert(ABOUT_ALERT, nil); 
otherwise 
begin 

Getltem(gAppfaMenu, theltem, accName); 
accNumber :* OpenOeskAcc(accName) 
end 
end 
and; 

{/. HiliTool ./} 

procadura HiliTool (com: ComType); 
var 

thaRact: Ract; 
ih: Handle; 
dbl: boolean; 
bagln 

dbl ;« Doubleclick; 

If (gMode - com) than 
bagln 

If not dbl than 
bagln 

If gTStata « on than 
bagln 

gMode :• NullCom; 
gTStata :« off; 
gFiretClick :» TRUE; 
gFirstID :« 0; 

Ih :■ Gatlcon(NODEJCON ♦ ord(com) - ord(AddNode)); 

Plottcon(gTMap[com], ih) 










03/30/91 10:40 


Main.p 


Fig* 11 


•nd 

•Is* 

begin 

If com <> NullCom then 
begin 

gTState :« on; 

Graylcon(com) 

•nd 

•nd 

•nd 

•(•• 

begin 

if com o NullCom than 
begin 

gTStale :» locked; 

ih :■ Getlcon(NOD£_ICON ♦ ord(com) • ord(AddNode)); 
Plotlcon(gTMap(com], ih); 
lnvertRect(gTMap[com]) 

•nd 

•nd 

•nd 

else 

begin 

If com » NullCom then 
begin 

gTState :• on; 

ih :• Getlcon(NODE_ICON v ord(gMode) * ord(AddNode)); 
Plotlcon(gTMap[gMode], ih); 
gMode :■ com; 

Graylcon(com) 

•nd 

•!•• 

begin 

ih :• Getlcon(NODE_ICON + ord(gMode) • ord(AddNode)); 
Plotlcon(gTMap[gMode], ih); 
gMode :» com; 
gTState :■ off 
•nd 
•nd 
•nd; 

{/. FindElem .*./} 

function FindElem (pt; point): integer; 
ear 
p; point; 
done : boolean ; 

Elem: integer; 
begin 

p.h :• pth + gOrigin.h; 
p.v > pt.v ♦ gOrigin.v; 

Etem :* 0; 
done :« FALSE; 

If gNumNodes > 0 then 









03/30/91 10:40 


Meln.p 


Peg* 12 


repeat 

Elem :« Elem ♦ 1; 

done :» PtlnRect(p. gNodeArr{Eiem) A .Loc); 
until (done or (Elem - gNumNodes)); 

If not done then 
Elem :■ 0; 

FinJElem Elem 
end; 


(/.*. GetLinkNum 

function GetLinkNum (pt: point): integer; 
ver 
p: point; 

hori 2 , vert, done: boolean; 

risel, rise2, runl, run2, link: integer; 

begin 

p.h :. pt.h 4 gOrigin.h; 
p.v :■ pt.v 4 gOrigin.v; 
link :- 0; 
done :* FALSE; 

If gNumLinks > 0 then 
ropeet 
link :« link 4 1; 
with gLinkArrflink]* do 
begin 

vert :« (HookPtl.h « HookPt2.h); 
horiz :• (HookPtl.v ■ HookPt2.v); 

If ((p.h «• HookPtl.h) end (p.h >■ HookPt2.h)) or ((p.h <* HookPt2.h) end (p.h >» HookPtl.h)) then 
If ((p.v <« HookPtl.v) and (p.v >« HookPt2.v)) or ((p.v <» HookPt2.v) and (p.v >« HookPtl.v)) 
then 
begin 

run 1 :• HookPtl.h * HookPt2.h; 
risel :• HookPtl.v * HookPt2.v; 
run2 :- HookPtl.h • p.h; 
rise2 :■ HookPtl.v • p.v; 

It (horiz end (abs(p.v - HookPtl.v) ■ 0)) then 
done > TRUE 

olee If (vert and (abs(p.h • HookPtl.h) « 0)) then 
done > TRUE 

•la* If (abs(round((ris*1 / runl) * run2) * ris*2) <• 1) then 
done:. TRUE 

•lee If (ab$(round((run1 / risel) * rise2) • run2) <• 1) then 
done :■ TRUE; 


end; 


•nd; 

until (done or (link . gNumLinks)); 
If not done then 






03/30/91 10:40 


Iflaln.p 


Pag* 13 


Jink :« 0; 

GatLinkNum > link 

and; 

{/. PopElemDLOG . /} 

procadur* PopElemDLOG (thaElem: integer); 

ear 

dun; boolean; 

IDStr: Str255; 

TypaStr: Str255; 

StatusStr: Str2S5; 

PdStr: Str255; 
theNewPd: real; 
itamType; integer; 

ItemHandle: Handle; 
itemRect: reel; 

Item; integer; 
result: integer; 
begin 

BringToFront(gElemDlogPtr); 

NumToString(theElem, IDStr); 

GetDltem{gElemDlogPtr. 4, ItemType, ItemHandle, ItemRect); 
S*tlText(itemHandle, IDStr); 

caaa gNodeArr|tbeElem]\Kind of 
Hub: 

TypeStr :« ‘HUB’; 

Node: 

TypeStr ’NODE'; 

Bypass: 

TypaStr •BYPASS'; 

otherwlae 

end; 

GetDltem(gElemDlogPtr, 6, ItemType, HemHandle, ItemRect); 
SetlText(itemHandle, TypeStr); 

If gNodeArrftheElem]*.Alive then 
StatusStr 'ALIVE' 

else 

StatusStr :» DEAD'; 

G*tDttem(gEI*mDlogPtr. 8. ItemType, ItamHandl*, ItemRect); 
SetlText(itemHandla, StatusStr); 

RNumToString(gNodeArr|theElem]\Pd, PdStr); 
GetDltem(gElamDlogPtr, 10, ItemType. ItemHandle, ItemRect); 
SetlText(itemHandle, PdStr); 

ShowWindow(gElemDlogPtr); 
while not dun do 
begin 

ModalDialogfnll, Item); 

case Item of 







03 /) 0/»1 10:40 


ftlaln.p 


P«gt 14 


begin 

GetDliem(gElemDlogPu, 10, ItemType ItemHsndie. llemRect). 
GetlText(itemHandle. PdStr), 

StringToRNum{PdStr, theNewPd), 

If (theNewPd <• 1.0) end (theNewPd >« 0) then 

begin 

If (theNewPd <> gNodeArrftheEiem]\Pd) Ihen 

begin 

If (gDtogRec StmRadArr{lnd)) then 
begin 

gNodeAnr(theElem]\Pd theNewPd, 

Hidewindow(gElemDle>gPtr); 

dun TRUE; 

•nd 

• It* 

result ;» NoteAI«n(402. nil), 

end 

elee 

begin 

Hidewindow(gElemDlogPtr); 
dun :• TRUE, 

end. 

end 

elee 

begin 

RN um ToSlnng (g N ode Arr(theE tern ] *. Pd, Pd St r). 
GetDhem(gEtemDlogPtr. 10. ItemType, ItemHandle, ItemRect); 
SetlTexi(rtemHandle, PdStr); 
result :■ NoteAlert(401, nil); 

end. 

end. 

2 : 

begin 

HideWindow(gElemDlogPtr), 
dun:« TRUE 
end; 
end; 
end, 
end; 

f/... PopLinkDLOG ./} 

procedure PopLinkDLOG (theLink integer); 

ver 

dun; boolean; 

IDStr: Str255; 

TypeStr. Str255; 

StetusStr; Str255; 

PdStr: Str255; 
theNewPd: reel; 

ItemType; integer; 
itemHandte Hardie; 

HemRect: rect; 






03/90/91 10:40 


Haln.p 


Pag* IS 


Item: integer; 
result. integer; 
b*gtn 

BringToFront(gLinkDlogPtr); 

NumToStringfthelink, IDStr); 

G*tDltem(glinkDlogPtr. 4, ItamType, hemHandle, ttemRect); 
S*tlText(it*mHandle, IDStr); 

cae* gLinkArr(th*Link] A .Kind of 
Dplx: 

TypeStr > -DPLX'; 

Splx; 

TypeStr ‘SPLX*; 
otherwise 
end; 

GetDItemfgLinkDIogPtr, 6, Item Type, ItemHandle, ItemRect); 
SetlText(itemHandle. TypeStr); 

If glinkArr[th*Linkj A . Alive then 
StatusStr ‘ALIVE* 

el** 

StatusStr :• *DEAD'; 

G*tDlt*m(gLinkDlogPtr, 8, ItamType, ItemHandle, ItemRect); 
SetlText(itemHandi*. StatusStr); 

RNumToString(gL»nkArrfth*Link]*.Pd. PdStr); 
G*tDlt*m(gLinkDlogPlr. 10. ttemType, ItemHandle. ItemRect); 
S*tfT*xt(it*mHandle. PdStr); 

ShowWindow(glinkDlogPtr); 
while not dun do 

begin 

ModalDialog(nll. Item); 

eae* Item of 

1 : 

begin 

GetDltem(gLinkDlogPtr, 10. ItamType. ItemHandle, ItemRect); 
G*tlT*xt(itemHandle, PdStr); 

StringToRNum(PdStr, theNewPd); 

If (theNewPd <« 1.0) and (theNewPd >■ 0) than 
begin 

H (theNewPd o glinkArrflh*Linkj\Pd) then 
begin 

if (gDlogRec.SimRadArr[lnd]) then 

begin 

gLinkArr{th*Linkl A .Pd :■ theNewPd; 
Hidewindow(gLinkDlogPtr); 
dun :• TRUE; 
end 

els* 

result :« NoteAI*rt(402. nil); 

end 



03 / 30/91 10:40 


Msln.p 


Peg* io 


•Is* 

bsgln 

Hidewindow(glinkDlogPtr); 
dun :« TRUE; 

•nd; 

•nd 

•Is* 

bsgln 

RNumToString{gLinkArr(thelink]*.Pd, PdStr); 
G*tDll*m(gLinkDlogPtr, 10. ItemType, itsmHandls, ItsmRsct); 
S«tlTsxt(itsmHandl«, PdStr); 
result :« Not*Alert(401, nil); 

•nd; 

•nd; 

2 ; 

begin 

HideWmdow(gLinkDIogPtr); 
dun ;• TRUE 

•nd; 

•nd; 

•nd; 

•nd; 


.......... NumLinks .****/) 

function NumLinks (indl, ind2: integer); integer; 

• •r 

i. j. k: integer; 

begin 

j 1; 

k 0; 

while gNod*Arrfind1] A .LList[j] <> nil do 

begin 

If gNodeArr[ind1]\LList[)]\End2 • gNodeArrlind2] then 
k :■ k ♦ 1; 
j j 4 1 

•nd; 

1 1; 

whll* gNodeArr[ind2] A .LList[j] <> nil do 

begin 

If gNodeArr(ind2]\LList(j)\End2 » gNodeArr(ind1] then 
k :« k 4 1; 

j :• j 4 1 

•nd; 

NumLinks :• k 

end; 

{/*•••*.. AssignHooks 

procedure AssignHooks (IDt, ID2: integer; ver ql. hi, q2, h2: integer); 

ve r 

recti, r«ct2; Rect; 
rise, run: Real; 








09/30/01 10:40 


Meln.p 


Pig* 17 


linkNum, slope: integer; 

begin 

recti :» gNodeArr[IDl}*.Loc; 
rect2 > gNodeArr[ID2]\Loc; 
rise :• rect2.top - recti.top; 
run :• rect2.lefl - recti.left; 

M abs(run) > sbe(rise) then 
begin 

II run > 0 then 
begin 
ql :* 1; 
q2 2 

end 

else 

begin 
ql 2; 
q2 1 
end 
end 
else 
begin 

It rise > 0 then 
begin 
ql :« 4; 
q2 :■ 3 
end 
else 
begin 
ql > 3; 
q2 :• 4 
end 
end; 

hi :» NumLinksflDl. ID2) + 1; 
h2 hi; 

If hi > 4 then 
ql > 0 

end; 

.. GetHookPt .. /} 

function HookPi (tRect: Reel; q, h; integer): Point; 
ver 
p: Point; 
mutt: integer; 
begin 

If odd(h) then 
mutt ;« -1 

else 

mutt >1; 

ceseq of 
1 : 

begin 

p.h :■ tRect.right - 1; 





03/30/91 10:40 


Main.p 


Plgi 1» 


p.v :» tOect.top 4 (mult * (h 01 v 2) * 1) * 5 

end; 

2 : 

begin 

p.h :» tRect.ieft; 

p.v :■ tRecltop ♦ (mult * (h dlv 2) ♦ 1) * 5 

•nd; 

3: 

begin 

p.v :• tRect.top; 

p.h :» tRect.ieft 4 (mult * (h dlv 2) 4 1) * 5 

•nd; 

4: 

bag In 

p.v tRect. bottom - 1; 

p.h tR«ct.l«ft 4 (mult * (h dlv 2) 4 1) * 5 

•nd; 

otherwise 

•nd; 

HookPl :* p 
•nd; 

{/•*•**•.. GetAPoints ... /) 

procedure GetAPoints (ptl, pt2: Point; ver el, *2, sp: Point); 
va r 

rise. run. slope, theta, deltas, deltac, ax, sy. *x1. eyl, ax2, ey2: real; 

begin 

run > pC2.h - prt.h; 
rise :■ pt2.v • ptl.v; 

If run <> 0 then 
begin 

slope > rise / run; 
theta -arctan(slope) 

•nd 

•ls» If rise < 0 than 
theta > PI / 2 

•la* 

theta 3 • PI / 2; 

sx :« ptl.h 4 2 * run / 3; 

•p.h -jm round(sx); 

ay :« ptl.v 4 2 * rise / 3; 

sp.v > round(sy); 

deltac :» 3.8 * cos(PI / 4.7 * theta); 

deltas :* 3.8 * ain(Pl / 4.7 - theta); 

If run >» 0 then 
begin 

•xl > ax • deltac; 

•yl :• ay • deltas; 
ex2 > ax • deltas; 
ey2 > ay 4 deltac 

•nd 

•lae 








03/30/91 10:40 


Maln.p 


Pag* 19 


begin 

axl :■ ax ♦ daltac 
eyl > ay ♦ daltas 
*x2 > ax ♦ daltas 
ay2 :» ay - daltac 
end; 

al.h :» round(axt); 
al.v :» round (eyl); 
a2.h :■ round(ax2); 
a2.v :■ round(ey2); 
and; 


{/. AddElam ./) 

procadura AddElam (tkind: ElemType; thePoint: Point); 

var 

thaElement: ElementPtr; 
thaLEIamant: LinkPtr; 
theRect; ract; 
ph; PicHandle; 
ih: Handle; 
arro: boolean; 

result, i, j, id, Qt. HI, 02, H2: integer; 
ptl, pt2: Point; 
begin 

i :« 0; 
j 0; 

arro :« FALSE; 

H tkind In gLinkSet than 
begin 

If gFirstClick than 
begin 

gFirstID :■ FindElem(thePoint); 

If gFirstID o 0 than 
gFirstClick :« Falsa 
and 

alaa 

begin 

01 :« 0 ; 

Id :• FindElem(thePoint); 

H ((id <> 0) and (id o gFirstID)} than 
begin 

gFirstClick TRUE; 

New(theLEIement); 
with thaLEIamant* do 

begin 

kind > bund; 

Alive TRUE; 

EndllD :» gFirstID; 

End2ID id; 

Endl ;• gNodaArr(gFirstlD]; 

End2 :» gNodeArrfid] 

and; 







83/30/91 10:40 


Maln.p 


Pig* 20 


rapaat 

i :• i 4 1 

until (gNodaArr[gFirstlD]*.LUst[i] » nit) or (i « MAX ITEMS); 

If i « MAX ITEMS than 
arro :« TRUE; 

If ikind • Splx than 

StringToRNum(gOlogRac.SlmStrArr[Spd], thaLElamani A .Pd) 

alaa 

StringToRNum(gDlogRec.SimStrArrIDpd], thaLEIamant A .Pd), 

rapaat 

j J ♦ 1 

until (gNodaArr[id] A .LListQ] - nil) or (j . MAX ITEMS); 

If j >« MAXJTEMS than 
arro :« TRUE; 

AasignHook*(gFir»tlD, id, Ol, HI, Q2, H2) 

and; 

If Q 1 * 0 than 
arro ;■ TRUE; 
if not arro than 
bagln 

with thaLEiamant* do 
bagln 

HookPtl :« HookPt(gNodaArr[gFinstlD] A .Loe, Q 1 , Hi); 
HookPt2 ;■ HookPt(gNodaArr(id) A .Loc, Q2, H2); 
GatAPoint«(HookPt 1 , HookPt2. Alptl, A2pl1, Aptl); 
GatAPoints(HookPt2, HookPtl. A1pt2, A2pt2, Apt2); 
SatScraan; 

MovaTo(HookPtl .h, HookPtl .v); 

LinaTo(HookPt2,h, HookPt2.v); 

If kind ■ Oplx than 
gNodaArr[id]\LList{j] ;• thaLEiamant; 
and; 

DrawArrows(thaLElament); 

RasatScraan; 

gNodaArr[gFirstlD)\LListfi] :• thaLEiamant; 
gNumLinks > gNumLinks ♦ 1 ; 
glinkArr[gNumlinks] ;« thaLEiamant 
and 
and 
and 
alaa 
bagln 

Naw(thaElamant); 

thaElamant\Loc.lafl :■ thaPointh ♦ gOrigin.h - 8 ; 
tha£lamant A .Loc.top :» thaPointv ♦ gOrigin.v - 6 ; 
thaElamant A .Loc.right :• thaPointh 4 gOrigin.h 4 8 ; 
tha£lamant A .Loc.bottom :•» thaPoint.v 4 gOrigin.v 4 8 ; 
thaElamantVKind tkind; 
eaaa tkind of 
Noda: 
bagln 

8 tringToRNum(gDlogRac.SimStrArr[Npd], thaElamant A .Pd); 





09/30/fit 10:40 


Maln.p 


Pag* 21 


ihG*tlcon(NOOE_ICON) 

and; 

Hub: 
bag In 

StringToRNum(gDlogR#c.SimStr ArrJHpdJ. th*El#ment\Pd); 
m Getlcon(HUBJCON) 

and; 

Bypass: 

bagln 

StringToRNutn{gDlogRac.S«mStfArr[Bpd]. th*Element A .Pd); 
ih > Getlcon{BYPJCON) 

and 

and: 

theElamentMD :» gNumNodas ♦ 1; 
th*Etemant\A!iva :• TRUE; 
for i :• 0 to MAXJTEMS do 
theElament A .LList(i] :» nil; 
thaPoint > theElementMoctopleft; 
th*Point.h :» thaPoint.h - gOrigin.h; 
thaPoint. v :» thaPoint.v • gOrigin.v; 
it findEiam(thaPoint) <> 0 than 
arro TRUE; 

thaPoint :« thaElemant\Loc.botRight; 
thaPoint.h > thaPoint.h * gOrigin.h; 
thaPoint.v thaPoint.v • gOrigin.v; 

If findElam(thaPoint) <> 0 than 
arro TRUE; 

thaPoint.h :« thaElamant A .Loc.right - gOrigin.h; 
thaPoint.v > thmElem»nt A .Loe.top - gOrigin.v; 

If FindElam(thePoint) o 0 than 
arro ;« TRUE; 

thaPoint.h > th*Elamant A .Loc.Laft - gOrigin.h; 
thaPoint.v :» thaEiamentMoc.Bottom - gOrigin.v; 

If FindElam(thaPoint) <» 0 than 
arro :* TRUE; 

H th*Point.h < (gPadWindow A .poftRact.left ♦ TOOL_SI2E) than 
arro :■ TRUE; 

If thaEiamentM.oc.top < (gPadWindow A .portR*ct.top) than 
arro ;» TRUE; 

If (gNumNodas < MAX_FTEMS) and (not arro) than 

bagln 

gNumNodas :» gNumNodas ♦ 1; 
gNodaArr(gNumNodas] :• thaElamant; 

SatScraan; 

Plotlcon(theElement A .Loc, ih); 

RasatScraan 

and 

alaa 

dispose(theElement) 

and 

and; 


I' 


/) 


FindLink 







03/30/01 10:40 


Maln.p 


Pig* 22 


function findLink (thisNode, thalNode: ElementPtr): LinkPtr, 

vo r 

i: integer; 

begin 

i 1: 

findLink :* nil; 

while thisNode*. LList[i3 o nil do 

begin 

If thisNode*.LList(i) A .End2 • thotNode then 
findLink thisNode*.LList(i]; 
i :■ i ♦ 1 

end 

end; 


.***•*/} 

procedure ElimLink (thsLink; LinkPtr); 

va r 

i: integer; 

Flag; boolean; 
thisLink: LinkPtr; 

begin 

i :* 1*. 

Flag FALSE; 
while i <• gNumLinks do 
begin 

If {(not Flag) and (gLinkArr[i] ■ theLink)) then 
begin 

thisLink :<■ gLinkArr(i); 

Flag :• TRUE 
end; 

If Flag then 

gLinkArrJi] gLinkArr(i + 1); 

1 i ♦ 1 

end; 

If flag then 

Dispose(theLink); 
gNumLinks :> gNumLinks * 1 
end; 

{/**.. DetachLink 

procedure DetachLink (theLink; LinkPtr; theNode: ElementPtr); 
ver 

i: integer; 
flag; boolean; 

begin 

I 1; 

flag > FALSE; 

while theNode*. LList[i] <> nil do 

begin 

M theNode*.LList{i] - theLink then 
Flag ;- TRUE; 

If flag then 










01/30/91 10:40 


tflaln.p 


Page 23 


theNode\LListli] theNode A .LList(i * 1 ]; 
i :• I 4 1 

•nd 

•nd; 

{/.* EraseLink .****•/} 

procedure EraseLink (thaLink: LinkPtr; thisNode, thatNode: EiemantPtr); 

var 

Hi: Handle; 
begin 
SatScraan; 

PanPat(white); 

DrawArrows(theLink); 

MoveTo(theLink A .HookPt 1 .h, thaLink A .HookPl 1 .v); 
LinaTo(thaLink A .HookPt2.h. thaLink A .HookPt2.v); 

Hi > Getlcon(NODE_ICON ♦ ord(thisNoda A .kind) • ord(Node)); 
Plotlcon(thisNode\Loc, ih); 

Hi ;■ Gatlcon(NODEJCON ♦ ord(thatNode\kind) * ord(Node)); 
Plotlcon(thatNode A .Loc, ih); 

RasetScraen; 

PanNormal 

•nd; 

(/•••.. CutElam . /} 

proeadura CutElam (link: boolean; ID1, ID2: integer); 
var 

ptl, pt2; Point; 
i, j, k: integer; 
anLink: LinkPtr; 

begin 

it link than 
begin 

anLink > nil; 

anLink findLink(gNodeArr[IDl], gNodeArr[ID2]); 

If anLink ■ nil than 

anLink :■ findLink(gNodeArr[ID2], gNodaArr[IDl]); 

If anLink o nil than 
begin 

OatachLink(anLink, gNodaArr(IDt]); 

DatachLink(anLink, gNodaArr[ID2]); 

ErasaLink(anLink, gNodaArrfIDI), gNodeArr(ID2]); 

ElimLink(anLink) 

•nd 

•nd 

•laa 
bag In 

If lOt o 0 then 
begin 

far i:» 1 to gNumNodas do 
begin 
i > 0 ; 

H i o ID1 than 








03/30/91 10:40 


tfaln.p 


Pag* 24 


j :• NumLinks(i, IDl); 

for k :« 1 to j d o 

CutElem(ALINK. IDl. i) 

ond; 

S*tScr**n; 

E raseRect(gNode Arr[ID 1 ] A . Loc); 

RosetScreon; 

Dispose(gNod*Arr|IDl]); 

for iIDl to gNumNodes * 1 do 

bogln 

gNodeArrfi] :• gNodeArr[i ♦ 1); 

If gNodeArrfi] <> nil than 
gNodeArr[i]\ID i 

•nd; 

gNumNodes :■ gNumNodes • 1 
ond 
ond 
ond; 

...... HandleFiloChoic* ../) 

proeodur* HandleFileChoice (theltem: integer); 

vo r 

reply; SFReply; { used in all SF samples } 

fptr; AFilePtr; 
f; ArchFile; 
r. ArchRec; 
n; ElementPtr; 

I; LinkPtr; 
k: ElemType; 
p; Point; 

typeList: SFTypeList; { typelist for all SF samples } 

nl, nn: longint; 
i: integer; 

bogln 

case (theltem) of 
LOADJTEM: 

begin 

SFGetFita(Pomt($00400040), 'Space for Rent 1 , nil, -1, typelist, nit. raply); 
(location) 

(vestigial string) 

(file Filter) 

(numtypes; -1 moans all) 

(array to types to show) 

(dig Hook) 

(record for returned values) 

If reply.good then 
bogln 

Reset(f, concat(PathnamoFromWD(r*ply.vRefNum), reply,fNam*)); 
r f A ; 

(g*t(f);) 

Closo(f); 

nn :• gNumNodes; 







03/30/01 10:40 


Maln.p 


Pag* 25 


for » :« nn down to 1 do 

CutElem(NOT_ALINK, i, 0); {destroy old arch} 
gOrigin.h :* 0; 
gOrigin.v :« 0; 

SetCt!Value(gHScroll, 0); 

S*tCtlValu*(gVScroll, 0); 

nn > r.NumNodes; 
nl :» r.NumLinks; 
gDlogRec :• r.DlogRec; 

RestoreSettings(gSimDlogPtr); 

Restore Settings(gOu tDlogPtr); 

for i:* 1 to nn do 

begin 

p :« r.NodeArr[i].Loc.topLeft; 
p.h :« p.h * 8; 
p.v > p.v + 8; 

AddElem(r.NodeArr(i].Kind, p); 
gNodeArr[i)\Pd :■ r.NodeArr(i].Pd; 

end; 

for i :« 1 to nl do 
begin 

k :■ r.LinkArr{i].kind; 

p :■ gNodeArr[r.LinkArr{i].End1 ID] A .Loc.topLeit; 

AddElem(k, p); 

p :» gNodeArr[r.LinkArr{i].End2ID] A .Loc.topleft; 

AddElemfk, p); 

gUnkArr[i)*.Pd :■ r.LinkArr{i}.Pd; 

end; 

UpdateWindow(gPadWindow) 

and 

elae 

SysBeep(l) 

end; 

SAVEJTEM: 
bog In 

SFPutFile(Point($00400040), 'Save Topology as:', 'untitled.arch', nil, rapiy); 
{prompt string) 

(original name) 

(dlgHook) 

{record lor returned values) 

If reply.good then 

begin 

for I > 1 to gNumNodes do 

bogln 

r.NodeArr(i].Kind gNodeArr[i)\Kind; 
r.NodeArrjij.Loc :• gNodeArr(i) A .Loc; 
r.NodaArrfiJ.Pd :■ gNod*Arr(i] A .Pd 

end; 


{location} 






03/90/91 10:40 


tlaln.p 


Ptg* 26 


for i > 1 to gNumLinks do 

begin 

r.LinkArr(i].Kind :» gLinkArr[i] A .Kind; 
r.LinkArrfiJ.EndUD :■ gLinkArr[i] A .EndliD; 
r.LinkArr[ij.End2ID gLinkArr[ij\End2ID; 
r.LinkArriiJ.Pd :• gLinkArrli]\Pd; 

ond; 

r.NumNodos :• gNumNodes; 
r.Numlinks > gNumLinks; 
r.DtogRec :» gDlogRec; 
f* r; 

rowrilo((, concat(PathnameFromWD(reply.vRefNum), reply.fName)); 

put(f); 

closo(f) 

ond 

olao 

SysBoop{1) 

ond; 

OUrTJTEM: 
gOona ;■ TRUE; 
ond 
ond; 

UpdateArch .*.*. /} 

procodura UpdateArch; 
var 

i: integer; 

Wgin 

tf gDlogRec SimRadArr[Typ] than 

begin 

for i:« 1 to gNumNodes do 
ceae gNodeArr(i]\kind of 
Node: 

StringToRNum(gDlogRec.SimStrArr[Npd], gNodeArr[i]\Pd); 

Hub: 

StringToRNum(gDlogRec.SimStrArr[Hpd], gNodeArr[i]\Pd); 

Bypass: 

St...igToRNum(gDlogRec.SimStrArr[Bpd]. gNodeArr[i] A .Pd) 

ond; 

for i:» 1 to gNumLinks do 
eoao gLinkArrti]\kind of 

Dpbt: 

StringToRNum(gDlogRec.SimStrArr{Dpd], gUnkArr[i]*.Pd); 

Splx: 

StringToRNum(gDlogRec.SimStrArr[Spd], gLinkArrfi)\Pd) 

ond 

ond 

ond; 

{/**.... BypassSat . /} 

function BypassSat (var nset: NodeSet): NodaSat; 

var 

i: integer; 









03/30/91 10:40 


Msln.p 


Pag* 27 


thaSat: Node Set, 

bag In 

thaSat > Q: 
nsat :« Q; 

lor i:« 1 to gNumNodes do 
If gNodaArr{i] A .kind - Bypass than 
t ha Sal :■ thaSat ♦ lgNodaArr[i]\ID] 

•Isa 

nsat :« nsat ♦ [gNodaArr[i]\ID]; 

BypassSat :» thaSat 
and; 

{/.. Start . /} 

function Start (Frllam, Rngltem: DIogltemType): intagar; 

vs r 
r: raal; 

bagln 

with gDlogRec do 

bagln 

M SimRadArrlRngltem] than 
bagln 

StringToRNum(SimStrArr[Frltem], r); 

If r * 0 than 
Start :« 0 

alsa 

Start 1 

and 

•laa 

Start :« 1 

and 

and; 

{/. Fin ./} 

function Fin (Frlterii, Rngltem: DIogltamTypa): intagar; 

va r 

I: intagar; 
r: raal; 
bagln 

with gDlogRac do 

bagln 

H SimRadArr[Rngltam] than 
bagln 

StringToRNum(SimStrArr[succ(Frltam)], r); 

I :■ round<r * 1000); 

StringToRNurn(SimStrArr[Frltam], r); 

I :• i * round(r * 1000); 

StringToRNum(SimStrArr[succ(succ{Frltam))]. r); 

If r « 0 than 
I :« I dlv (round(r * 1000)) 

alsa 

I 0 

and 

alsa 









03/30/01 10:40 


Ifaln.p 


Pag# 2t 


i 1; 

Fin ;« » 

and 

and; 

{/. StapSiza .*./) 

function StapSiza (Frltam, Rngltam, Pdltam: DlogltamTypa): raaf; 

va r 
r: raal; 
bagln 

with gDlogRac do 
bagln 

ff SimRadArrfRngltem] than 
StringToRNum(SimStrArr(succ(»ucc(Fritem))j, r) 

alaa 

StringToRNum(SimS!rArf(Pdltam), r); 

StapSiza > r 

and 

and; 

{/.... WritaHaadar . /} 

proeadura WritaHaadar (f: TFilaPtr); 

bagln 

with gOiogRac do 
bagln 

rawrita(f A , concat(PathnamaFromDirlD(gCurDirStore\ -igSFSaveDisk*}). OutFilaStr)); 
writaln(f A . **'); 

writu(f*. "WWV. 

If SimRadArrfHrJ than 
writa(f\ chr(9), *HPd); 

If SimRadArrfBr] than 
writa(f A , ehr(9), ’BPd’); 

If SimRadArrtSr] than 
writa(f A , chr(9), 'SPri*); 

If SimRadArrJDrl than 
writa(f A . chr(9), *DPc ); 

It OutChkArr(Psag] than 
writa(f A , chr(9). *P»ag'); 

It OutChkArr(Avsl) than 
writa(f A , chr(9), "AvsC); 

H OutChkArrfEcp] than 
wrlta(f A , chr(9), ’Ecp’); 

If OutChkArrtEmsI] than 
writa(f A , chr(9), ’EmsP); 
writaln{f A ) 

•nd 

and; 

j/**.. AdjuatDtogRac .*.*. /} 

proeadura AdjustOlogRac (Np. Hp. Bp, Sp, Op: raal); 
bagln 

with gDlogRac do 










03/30/91 10:40 


Waln.p 


Page 29 


begin 

RNumToString(Np, SimStrArriNpd)). 

RNumToString(Hp, SimStrArr[Hpdj); 

RNumToString(8p. SimStrAff(Bpdj); 

RNumToString{Sp, SimStrArrJSpd}); 

RNumToString(Dp, SimStrArr[Dpdj); 

•nd 

•nd; 

! • • . ..HandleAnalChoice./} 

procedure HandleAnalChoice (thehem. integer); 
va r 
f: text; 

n, h. b. a. d, I, max, j, k, Hem: integer; 
dltem; DlogttemType; 
i, Norm: longint; 

ItemType: integer; 

HemHandle Handle; 
theRect, itemRect: rect; 
dun. Turbo. Boolean; 
myStringl. myString2: Str255; 

Ns. Hs. Bs, Ss. Ds. Psg: real; 
begin 

dun :» FALSE; 
case theltem of 
SIMJTEM: 

begin 

BringT oF ront(gSimDlogPtr); 

NumToString(gNumNodes ♦ gNumLinks. myStringl); 

GetOltem(gSimDiogPtr, 24. ItemType, ItemHandle, ItemRect); 
SetlText(itemHandle, myStringl); 

SbowWindow(gSimDlogPtr); 
while not dun do 
begin 

ModalDialog(nll. Item); 
caee Item of 
1 : 

begin 

Hide Window(g Si mD logPtr); 

SaveSettmgs(gSimDlogPtr); 

Update Arch; 
dun:-TRUE 
ond; 

2 : 

begin 

HideWindow(gSimDlogPtr); 

ReatoreSettings(gSimDlogPtr); 

dun .-TRUE 

ond; 

25: 

begin 

GetDltem(gSimDlogPtr. Item, itemType, ItemHandle, itemRect); 








03/30/91 10:40 


Maln.p 


9*9* 30 


If GetCtlValue(ControlHandle(ttemHandle}) <> 1 than 
bagln 

SatCtlValue(ControlHandia(itemHandie), 1). 

GetDItemfgSimDlogPtr. flam ♦ t, ilamType. ilemHandte, itemRect), 
SetCtlValue(ControlHandle(itemHandle), 0), 

and 

and; 

26: 

bagln 

GetDltem(gSimDlogPtr. Item, itamType. itamHandle, itemRect); 

If GetCtlValue(ControlHandle(ilemHandle}) <> 1 than 
bagln 

SatCtlValua(ControlHandla(itemHandla). 1); 

GetDltem(gSimDlogPtr, Item • 1. ilamType, ilamHandla, itamRacl); 
SatCtlValua(ControlHandla(itamHandia), 0); 

and 

and; 

48.49. 

bagln 

GatDltem(gSimDlogPtr, Itam, itamType, itamHandle, itamRact); 

If GetCtlVaiue(ControlHandie(itemHandle)) <> 1 than 
bagln 

SetCtlValue(ControlHandle(itemHandle), 1); 

GatOltem(gSimDlogPtr. Itam 4 (+1 • (Itam mod 48) * 2). itamType. itamHandle, itamRact); 
SetCtlValue(ControlHandle(itemHandle}, 0) 

and 

and; 

50.54: 
bagln 

GetDltem(gSimDlogPtr, Item, itamType, itamHandle, itamRact); 

If GetCt!Value(ControlHandle(itemHand!e)) <> 1 than 
bagln 

SetCtlValua(ControlHand)e(i!emHandie). 1); 

GatDltem(gSimDlogPlr, Itam 4 5. ItamTypa, itamHandla, ItamRact): 
SetCtlValue(ControlHandle(itemHandle), 0) 

and 

and; 

55..59: 
bagln 

GatDltam(gSimDlogPtr, Itam, itamTypa, itamHandla, itamRact); 

If GatCt!Value(Contro!Handia(itamHandie)) <> 1 than 
bagln 

SetCllValue(ControlHandle(itemHandle), 1); 

GatDltam(gSimDlogPtr, Itam • 5, ItamTypa, itamHandla, itamRact); 

Se!CllVaJua( ControlHandle( ita mHandia), 0) 

and 

and; 

otharwlaa 

and 

and 

and; 





03/30/01 10:40 


Main.p 


Papa 31 


OUTJTEM: 

bagln 

BringToFront(gOutDiogPtr); 

ShowWindow(gOutDiogPtr), 
whlta not dun do 

bogln 

ModalDialog(nll, Ham); 

caaa flam of 

1 : 

bogln 

Hida Window(gOutDfogPtr); 

SavaSattings(gOutDlogPtr); 
dunTRUE 
and; 

2 : 

bagln 

HidaWmdow(gOutDlogPtr); 

RastoraSettings(gOutDiogPtr); 
dun:« TRUE 
and; 

5.8: 

bagln 

GatOHam(gOutOlogPlr. Item, itamTypa, itamHandle, itamRact); 

SatCtlValua(ControlHandla(itamHandt«}. Bitxor(GatCt!Valua(ControlHandla(itamHandla)), 1)); 

and; 

otharwlaa 

and 

and 

and; 

RUN_ITEM: 

bagln 

with gOiogRac do 
bagln 

SatCursor(GatCuraor(watchCursor)* A ); 
gBypSat :• BypassSat(gNodaSat); 

StringToNum(SimStrArr[Mst], gNumStatas); 

Turbo ;• not (OutChkArr(Psag) or OutChkArr(Aval] or OutChkArr{Ecp] or OutChkArr[Emsl]); 

and; 

H Turbo than 
bagln 

gSagCount > 0; 
randSaad ;■ Tick Count, 

TurboLoop; 

Pag :» gSagCount / gNumStatas; 

SatRact(thaRact, 35, 3, 123, 20); 

ErasaRact(thaRact); 

FramaRact(thaRact); 

MovaTo(37, 15); 

RNumTo$tring(Psg. myStringl); 

OrawString(concat(*Paag-’. myStringl)); 

ShowCursor 

and 

•Isa 






03/30/91 10:40 


Matn.p 


Pag* 32 


bag In 

WriteHeader(@f); 

Ns :■ SlapSiz«(Nfr. Nr, Npd); 

Hs > StepSize(Hfr, Hr. Hpd); 

Bs StepSize(Bfr, Br, Bpd); 

Ss :» StepSize(Sfr, Sr, Spd); 

Ds :• StapSiza(0ir, Dr, Dpd); 
for n :» Start(Nfr, Nr) to Fin(Nlr, Nr) do 
lor h :• Start(Hfr, Hr) to Fin(Hfr, Hr) do 
for b Start{Bfr, Br) to Fin(Bfr, Br) do 
for a :• Start(Sfr, Sr) to Fin(Sfr, Sr) do 
lor d :» Surt(Dfr, Dr) to Fin(Dfr, Dr) do 
bog In 

AdjustDlogRec(n * Ns. h * Hs, b * Bs, s * Ss, d * Ds); 

UpdatoArch; 

gSogCouni ;• 0; 

gAvsl 0; 

gEcp ;• 0; 

gEmsI :* 0; 

gTotalSogs :» 0; 

max :■ 0; 

rand Seed :« TicKCount, 
lor i:« 1 to gNumNodes do 
bogln 

gSeglnthArr[i] :« 0; 
gMaxSegArr[i] 0 

ond; {for i to gNumNodes) 

lor i :« 1 to gNumStates do 

bogln 

GotMonteState; 

Analyze; 

H gNumSegs > 1 then 
gSegCount:« gSegCount * 1; 
max :■ 0; 

lor j :■ 1 to gNumSegs do 
bogln 

I :■ SelSize(gSegArr[j)), 
gSegLnlhArr{l] gSegLnthAiT{l) ♦ 1; 

III > max then 
max > I 

ond; {for j) 

gTotalSogs > gTotalSegs + gNumSegs; 
gMaxSegArr(max] :■ gMaxSagArr[max] ♦ 1 

•nd; {for i to gNumStates) 


Pag > gSegCount / gNumStates; 
for i :• 1 to gNumNodes do 

bogln 

gAvsl :• gAvsl ♦ I * gSegLnthArr[i]; 








03/30/91 10:40 


tlaln.p 


Pag* 33 


gEcp :• gEcp 4 Binomial(i) * gSaglnthArr(i); 
gEmsI :» gEmsI 4 i * gMaxSagArr[i] 
and; (for) 

Norm :« (gTotalSegs * SetSize(gNodeSet)); 

If Norm <> 0 than 
gAvst :■ gAvsl / Norm 

•Isa 

gAvst :» 0; 

Norm :• (gTotalSags * Binomial(SatSiza(gNodaSat))); 
M Norm o 0 than 
gEcp :> gEcp / Norm 

alaa 

gEcp :• 0; 

Norm :« (gNumStatas * SatSiza(gNodaSat)); 

If Norm o 0 than 
gEmsI :« gEmsI / Norm 

alaa 

gEmsI :« 0; 

with gDlogRac do 
bagln 

writa(f, n * Ns); 

If SimRadArr[Hr] than 
wrila(f. chr(9), (h * Hs) ; 6 : 3); 

If SimRadArr(Br] than 
wrilo(f, chr(9), (b * Bs) : 6 : 3); 

If SimRadArrJSr] than 
writa(f. chr<9). (s * Ss) ; 6 : 3); 

If SimRadArrfDr] than 
wrila(f, chr(9), (d * Ds) : 6 : 3); 

If OutChkArr(Paag) than 
wrila(f, chr(9), (Psg) : 6 ; 3); 

If OutChkArr[Avsi] than 
wrila(f. chr(9), (gAvsl) : 6 : 3); 

If OutChfcArrfEcpj than 
writa(f. ehr(9), (gEcp) : 6 : 3); 

If OutChkArr{Emsl] than 
writa(f, chr(9), (gEmsI) : 6 : 3); 
writaln(f) 

and; (with) 

SalRact(thaRact, 35. 3, 123, 20); 
ErasaRact(thaRact); 

FramaRacf(thaRact); 

MovaTo(37, 15); 

RNumT oString(Psg, my String 1); 
Dr«wString(concat(*Psag-'. myStringl)); 
ShowCursor; 

and; {multi for loop) 

closa(f) 

and; (alM) 

SatCursor(arrow) 







03/30/91 10:40 


Maln.p 


Page 34 


•ntf 

•nd 

•nd; 


{RUN) 

(case) 

(procedure) 


{/ ••••••••••••• ••••••••• HendleMenuChotce ../) 

procedure HendleMenuChotce (menuChotcr: longint); 

ver 

i, nn, theMenu, thettem: integer; 

begin 

If (menuChoice o 0) then 
begin 

theMenu :• HiWord(menuChoice); 
theltem :« LoWord(menuChoice); 
caee (theMenu) of 
APPLE_MENU_ID 
Handle AppleChoice(the!tem); 

Flt£_MENUJD: 

HandleFileChoice(theltem); 

EDITJdENUJD: 

begin 

caee theltem ot 
CLEARJTEM: 

begin 

nn :» gNumNodes; 
for t > nn downto 1 tie 
CutElem(NOT_ALINK. i. 0); (destroy old arch) 
gOrigin.h :■ 0; 
gOrigin.v > 0; 

SetCtlValue(gHScroll, 0); 

SetCtlValue(gVScroll, 0); 
end; 
end 
end; 

ANAL_MENU_ID 
Handle AnalChoice(theltem); 

end; 

HiliteMenu(O) 

end 

end; 

{/ •••••• ••••••• Scroll. *•••••/} 

procedure Scroll; 
ver 

oldOrigin: Point; 
dh, dv; integer; 
tRect: Red; 
begin 









03/30/91 10:40 


Maln.p 


Pig* 3$ 


old Origin > pOrigin; 

gOrigin.h 1 * GatCtlValua(gHScroll); 

gOrigin.v :• 1 * GatCtlValua(gVScroll); 

dh > otdOrigin.h - gOrigin.h; 

dv :• oldOrigin.v * gOrigin.v; 

gUpdataRgn :* Nawftgn; 

tRaci > gPadWindow\porlRact; 

tRact.right :• tRact. right * SBarWtdth; 

tRact.bottom tRact.bottom - SBarWidth; 

tRactlaft :• tRactlaft ♦ TOOL_S12E ♦ 2; 

ScrollRact(tRact, dh, dv, gUpdataRgn); 

{/ * Hava acrollad in junk .. . naad lo radraw * /) 

SatOrigin(gOrjgin.h. gOrigin.v); 
OffaatRact(gUpdataRgn**.rgnBBox, gOrigin.h, gOrigin.v); 
ClipRact(gUpdataRgn A \ rgnBBox); 

OrawCont; 

DisposaRgn(gUpdataRgn); 

SetOrigin(0, 0); 

ClipRact(scraanBrts.bounds) 
and; 


</*** .* * * * acrollbarproc ../} 

procadura ScrollProc (thaControl: ControlHandia; IhaCoda: inlagar); 
var 

pagaSiza; intagar; 
acrollAmt; intagar; 

bagln 

H (thaCoda o 0) than 
bag in 

H (thaControl « gVScroll) than 

pagaSiza (gPadWmdowVportRact.bottom - gPadWindow\portRact.top) dlv 4 

alaa 

pagaSiza > (gPadWindow*.portRact.right - gPadWindow*.portRact.laft) dlv 4; 


caaa (thaCoda) of 
inUpButton: 
acrollAmt > -3; 
mDownButton 
acrollAmt 3; 
inPagaUp: 

acrollAmt :■ -pagaSiza; 
inPagaDown; 
acrollAmt pagaSiza 
ard; 

SatCtlVa(ua(thaControl, GatCtlValua(thaControl) ♦ acrollAmt), 
Scroll 

and 

and; 






03/30/01 10:40 


Main.p 


Pag* 30 


{/ * *********** HandleControl. ***/} 

procedure HandleControl (cntrl: ControlHandle; part: integer, pnt: Point); 

begin 


H ((cntrl - gVScroll) or (cntrl * gHScrolt}} than 
H (pan » InThumb) than 
begin 

pan :• TrackControl(cntrl. pnt, nil); 

Scroll 

end 

ela* 

pan :« TrackControl(cntr), pnt, @Scrol1Proc) 

end; 


{/•*•*•* .HandieScraan ******* ./) 

procedure HandieScraan (w: WindowPtr; p; Point); 

var 

thePoint: Point; 
theRect; Rect; 

thaPart, ElemID1, ElemlD2: integer; 
theControl: ControlHandle; 
savePort: GrafPtr; 
theElement: ElemantPtr; 
begin 

GetPon(savaPon); 

SetPort(w); 
thePoint p; 

Globa IT oLocal(thaPoint); 

thePan :» FindControl(thePoint. w, theControl); 

EiemIDI > 0; 

ElemlD2 :• 0: 

thaRact ;» gPadWindow\portRect; 
theRect right :■ thaRact .left ♦ TOOL_SIZE, 

M (thaPart • 0) then 

begin 

If (PtlnRect(thePoint, gTMaplCutNod*])) than 

begin 

HiliTool(CutNode) 

end 

alee If (Pt!nRect(thePoint, gTMap[CutLink])) then 

begin 

HIBTool(CutLink) 

end 

elae If (PtinR*ct(th*Point. gTMapJAddDplx])) than 
begin 










03/30/91 10:40 


Mcin.p 


Pag* 37 


HiI7Tool( AddDpI x) 

•nd 

•Is* H (PtlnR*ct(th«Point. gTMap[AddSplx])) than 

begin 

HiliTool(AddSplx) 

•nd 

•Is* If (Pt»nR«ct(tb*Point, gTMapfAddByp])) than 

bagln 

HiliToot(AddByp) 

•nd 

•Im If (PtlnR*cl(lh*Point, gTMap(AddHub])) than 

begin 

HiliTooi(AddHub) 

•nd 

•Is* If (PtlnR*ct(th«Point, gTMap[AddNod«])) lh*n 

begin 

HiliTool(AddNod«) 

•nd 

•Is* If PtlnRect(lh*Point, the Reel) than 
bagln 

HiliTool(NullCom); 
gFirstClk* :■ True; 
gFiretlD 0 
•nd 
•ls« 
begin 

gWhanFirstCiick :• 0; 
css* gMod* of 
NuOCom: 

bag In 

EtamlDl FindEI*m(th*Poinl); 

II ElemIDl o 0 than 
PopEismOLOG(EI*mlDl) 

•Is* 

begin 

ElsmlDl :■ GatUnkNum(thsPoint); 

H EJemlDl o 0 then 
PapUnkOLOG(EbmlDI) 

•nd 

•nd; 

AddNods: 

b*gln 

AddEi*fn(Nod*. th*Point): 

If gTStsts o locked th*n 
HiliTooHAddNod*); 

Mid; 

AddHub: 

begin 

AddElem(Hub. thsPoint); 

If gTStsts o locked then 
HiliTool(AddHub); 

•nd; 

AddByp: 








03/30/91 10:40 


Maln.p 


Page 39 


begin 

Add Elam (Bypass, thePoint); 
if gTState <> locked then 
HiliTool(AddByp); 

end; 

AddSpix: 

begin 

AddElem(Splx, thePoint); 

If ((gTState o locked) and gFirstClick) then 
HiliTool(AddSplx); 
end; 

AddOplx: 

begin 

AddElem(Dplx. thePoint), 

If ((gTState o locked) and gFirstClick) then 
HiliTool(AddDplx); 
end; 

CutNode: 

begin 

ElemIDI FindElem(thePoint); 

If ElemIDI o 0 then 
CutElem(NOT_ALINK, ElemIDI, ElemlD2); 

If gTState o locked then 
HiiiTool(CutNode) 
end; 

CutLink: 

begln 

If gFirstClick then 
begin 

gFirstID :• FindElem(thePoint); 

If gFirstID <> 0 then 
gFirstClick ;• FALSE 

end 

eloe 

begin 

Eiem!D2 :• FindElem(thePoint); 

If ElemlD2 o 0 then 
begin 

If EiemlD2 - gFirstID then 

begin 

gFirstID 0; 
gFirstClick » True 

end 

else 

begin 

CutElem(AUNK, gFirstID, ElemlD2); 
gFirstClick ;» True 

end 

end; 

end; 

If ((gTState o locked) and gFirstClick) then 
HiliTool(CutLink); 

end 




03/30/91 10:40 


Maln.p 


Pa9* 39 


and (ease) 

•nd 

•nd 

•la* 

HandlaControl(thaControl. thaPart, thaPoim); 
SatPort(savaPort) 

•nd; 


j/ ••••*•• *•••••••••*•••••••••• HandiaMousaDown * * * /} 

procadura HandtaMousaDown; 
v a r 

whichWindow: WindowPtr; 
thaPart: Integer; 
manuChoica, windSisa: longint; 
thaPoinl; Point; 

bagln 

thaPart ;« FindWindow(gThaEvant.whare, which Window); 
casa (thaPart) of 
MDask; 

SyaBoep(l); 

InMenuBar: 

bagln 

manuChoica :» ManuSalact(gThaEvant.whara); 

HandlaMenuChoica(menuChoica) 

•nd; 

inSys Window: 

SysiemClick(gThoEvant, arhichWindow); 

inDrag: 

DragWindow{whichWindow, gThaEvant.whara, gDragRact); 
inGoAway; 

If (TrackGoAway(whichWindow, gThaEvant.whara)) than 
gDona :• TRUE; 

inGrow: 

Grow(whichWindow, gThaEvant.whara); 
inCorrtant: 

If whichWindow <> frontwindow than 
Sal#ctWindow(whichW. dow) 

•laa 

Handle Screen(whichWindow. gThaEvant.whara) 

and 

•nd; 






03/90/91 10:40 


Main.p 


Pag* 40 


{/**••***.HandleActiv***./} 

procedure HandieActivate (w: WindowPtr, going Active: Boolean); 

begin 

If w • gPadWindow then 
begin 
SetPort(w); 

DrawGrowlcon(w); 

•nd; 

If going Active then 

begin 

ShowControt(gHScroll); 

ShowControl(gVScroll) 

•nd 

•lee 

begin 

HideControl(gHSeroll); 

HideControl(gVScroli) 

•nd 

•nd; 


{/***•** •••••• 'HandleEvent**.**/) 

procedure HandleEvent; 

var 

•Point: Point; 

•rr: integer; 
begin 

cats (gTheEvent.what) of 
nullEvent: 

(* HandleNull ;*) 

mouse Down: 

begin 

HandleMouseDown 

•nd; 

autoKoy: 

t 

hey Down: 

btgln 

gTheEvent.Message BttAnd(gTheEvent. Message, charCodeMasA); 

If BitAnd(gTheEvenLModirter6, CmdKey) « CmdKey then 
begin 

H«ndleMenuChoice{MenuKey(ChrtgTheEvent.Message))) 

•nd 

•nd; 

update Evt: 

If (WindowPtr(gTheEvent.message) » gPadWindow) then 
Update Wind ow(gPadWindow) 

•lee 

begin 










03/30/91 10:40 


Maln.p 


9*0* 41 


BeginUpdate(WindowPtr(gTheEvent.Message)); 

End Update(WindowPtr(gTheE vent. Message)) 
end; 

activateEvt: 

begin 

Handle Act ivatetgPadWindow, BAND(gTheE vent. Modifiers, activeFlag) • 1) 
end; 
diskEvt: 
begin 

if HiWrdftjTheEvent.message) <> noErr then 

begin 

SotPliaPomt. DI_LEFT, DI_TOP); 

err :« DlBadMount(aPoint, gTheEvent.Message) 

end 

end; 

app4Evt: 

begin 

case BAND(BROTL(gTheEvent.message, 8), $FF) of 
SUSP_RES_MESS: 

begin 

glnBackground :« BAND(gTheE vent.Message, RES_MASK) « 0; 

Handle Ac tivate(gPadWmdow, not glnBackground) 

end; 

etherwiae 

end 

end; 

etherwiae 

end 

end; 

{/••••*•••*•• GetGlobMowse . 

procedure GetGlobMowse (var pt: point); 
var 

event; EventRecord; 
begin 

(if OSEventAvail(0, event) then} 

{pt :• event.where) 

{else} 

{pt > event.where) 

GetMouae(pt); 

LocalToGlobal(pt) 

end; 

{/••... AdjuatCurs*** ... /} 

procedure AdjuatCurs (pt: point; var ergn: RgnHandle); 
ver 

window; WindowRtr; 
arrowRgn, actrveRgn: RgnHandle; 
pRect; Rect; 

CursID: integer; 

begin 

window :■ FrontWindow; 







03/30/91 10:40 


Maln.p 


Pig* 42 


H (not glnBackground) and (not IsDAWmdow(window)) than 

toagln 

arrowRgn ;« Nowftgn; 
activaRgn NawRgn; 

SatRectRgn(arrowRgn, MAX_NEG, MAX_NEG. MAX_POS, MAX_POS); 

If ((gModa <> NullCom)) than 
bagln 

if laAppWindow(window) than 

bagln 

SatPort(window); 

SatOrigin(-window\portBits.bounds.lafl. -window*.portBils.bounds.lop); 

pRact > window*.portRact; 

pRact.lolt > pRacUaft ♦ TOOL.SSZE; 

pRact.right :« pRactright • SBarWidth; 

pRact.bottom :■ pRact.bottom - SBarWidth; 

RactRgn(activaRgn. pRact); 

SactRgn(activaRgn, window*.vitRgn, activaRgn); 
caaa gModa of 
AddNodo AddByp: 

CurslO:« ELEM_CURS; 

CutNodo. 

CurslO CUT_NODE_CURS; 

AddSptx; 

CurslO :« ADD_SLNK_CURS; 

AddOpix; 

CurslO > ADD_DLNK_CURS; 

CutLink: 

CursID ClfT_LINK_CURS; 

otharwiaa 

and; 

SatOrigin(0. 0) 

and 

and; 

DiffRgn(arrowRgn, activaRgn. arrowRgn); 

If PtlnRgn(pt, activaRgn) than 
bagln 

SatCursor(GatCursor(CurslD) AA ); 

CopyRgn(activnRgn, crgn) 
and 

alaa 

bagln 

BatCursor(arrow); 

CopyRgn(arrowRgn, crgn) 
and; 

DisposaRg n(atrowRgn); 

D«posaRgn(activaRgn) 

and 

and; 

{/*» .*.MainLoop.*. ****/} 

procadura MainLoop; 
var 






03/90/91 10:40 


Maln.p 


Papa 43 


gotEvant boolean; 
curaRgn: RgnHandla, 
mows*: point; 
bog In 

mowsa.h :» 0; 
mowM V ;■ 0; 
curaRgn :• NawRgn, 

FlushEvanta(avaryEvant, 0); 

gWNEImplamanlad > {NGaiTrapAddrass{WNE_TflAP_NUM, Too ITrap) <> 
NGatTfapAddfa**{UNIMPL_TRAP_NUM, ToolTrmp)); 

«hli (gOona ■ FALSE) do 
bagln 

If (gWNEhnplamanlad) than 
bag In 

GatGlobMowsa(mowaa); 

AdjustCurs(mowsa. curaRgn); 

gotEvant ;• WailNaxtEvant(avaryEvant, gThaEvant, MAXLONGINT, curaRgn) 

and 

•Isa 

bagln 

SystamTaak; 

gotEvant ;• GctNairtEvant(avaryEvant. gThaEvant) 

and; 

If gotEvant than 
bagln 

AdjustCurs(gThaEvant.whara. curaRgn); 

HandiaEvant 

and 

and 

and; 

(/.. Misclnit .. /} 

pracadura Misclnit; 
oar 

i: Intagar; 

bagln 

gOona > FALSE; 
gWhonFirstCItck ;» 0; 
gtnBacfcground :> FALSE; 
gModa > NullCom; 
for i 0 to MAXJTEMS do 
bagln 

gNodaArrp] > nil; 
gLinkArr[i] :■ nil; 
gNilLinkArrfi] > nil 

and; 

gTStats > off; 
gFiratCKck > TRUE; 
gFirstlD > 0; 
gNumNodas > 0; 

GNumUnks :• 0; 

SatCursor(arrow); 






03/30/91 10:40 


Maln.p 


Pig* 44 


gUnfcSat :■ (Splx. Dplxj; 

gLComSot :« {AddDpi*. AddSplx, Cut Link]; 

randSoad TickCount, 

gSagCounl :■ 0; 

i :■ SyaEnvironsfl, gWortd); 

gSFSavaDtsk :« PtrToWord(kSFSaveDiak). 

gCurOirStor* :• PtrToLong(kCurOirStore) 

•nd; 

f/*****************’*Dialoglml . /} 

procedure Dialog Init; 

war 

i: OlogftamTypa; 
itamTypa: intagar; 
ttamRact: ract; 

KamHandta Handia; 

bag In 

with gOogRac do 
bag In 

gSimDlogPtr > GatNawDiaiog(SIM DLOG. nil, POlNTER(MOVE_TC_FRONT)); 
gOutDIogPtr:« GatNawDiak>g(OUT_DLOG, nil. POINTER<MOVEJfO_FRONT)). 
gElamDIogPtrGatNawDialog(ELEM_DLOG, nil. POINTER(MOVE_TO_FRONT)); 
gUnkDIogPtrGatNawDialog(LINK_DLOG, nil, POINTER(MO VE_TO_FRONT)), 

for i :• Npd to Emal do 
eaaa i of 

Mon: 

SimRadArrfi] TRUE; 

Exh: 

SimRadArrfi] > FALSE; 

Nc..Dc: 

SimRadArr[i] ;« TRUE; 

Nr.. Dr 

SimRadArrfi] FALSE; 

Ind; 

SimRadArrfi] FALSE; 

Typ: 

SimRadArrfi] TRUE; 

Npd..Bpd: 

RNumToString(DEF_NOOE_PD, SimStrArrfi]); 

Spd, Dpd: 

RNumToString(DEF LINK PD. SimStrArrfi)); 

Nfr..Dat: 

eaaa ((ord(i) • ord(Npd)) mod 3) of 
0 : 

RNumToString{DEF_TO_PD, SimStrArrfi)); 

1 : 

RNumToString(DEF_STP_SZ, SimStrArrfi]); 

2 : 

RNumToStringfDEF JFRM_PD, SimStrArrfi]) 

ond; 

Mat: 

NumToString(DEF_STATES. SimStrArrfi)); 

Tat: 









03/30/91 10:40 


Maln.p 


Plfi <1 


NumToString((gNumLinks ♦ gNumNodes). SimStrArr(tJ); 

Pseg..EmeJ: 

If i ■ Pi«g then 
OutChkArrli) TRUE 

•lae 

OutChkArrfij FALSE; 

•therwlee 

•nd; 

OutFilaStr :« 'untitled V; 

•nd; 

RaatoreSetting*(gSimDlogPt r); 

R«toraSatting*(gOutDlogPtr); 

<5etDltam(gSimDlogPtr, 49, itamType, itemHandle, ItemRact); 
HiliteControl(ControlHar>d!e(itemHindle), 2SS); 

•nd; 

^ windowing. ***•*/} 

procedure Windowlnit; 
v«r 

p«dR«ct, vScrollR*ct. hScrollRed. viewRact: Reel; 
eRgn; RgnHandle; 

begin 

gOrigin.h :» 0; 
gOrigin.v ;» 0; 

gPadWindow :« GatNewWindow(BASE_RESJD, nil. POINTER(MOVE_TO_FRONT)); 

SetPort(gPadWindow); 

vScrollR*ct :■ gPadWindow\portRect; 

vScrollRect.tefl :■ vScrollRect. right • IS; 

vScrollRect.right vScrollRecl.right ♦ 1; 

vScrollR*ct.bottom > vScro!IR*ct.bottom - 14; 

vScrollRect.top :• vScrollRect.top • 1; 

gVScroll ;« N*wControl(gPadWindow, vScrollRect, *hi‘, TRUE, 0, 0, PAD_LIMIT, acrollBarProc, 0); 

hScrol!R«ct gPadWindow\porlRect; 

hScrollRact. right :■ hScrollRact.right - 14; 

hScrollRect.Mft hScrollRect.lafl • 1; 

hScrollRact.bottom :• hScrollRact.bottom + 1; 

hScrollRact.top hScrollRact.bottom - 16; 

gHScroll N#wControl(gPadWindow, hScrollRact, 'HO', TRUE. 0. 0, PAD_LIMIT. acrollBarProc. 0}; 

gOragRact :« acreenBitt.bounds; 

gDragRect.left ;• gDrmgRact.latt ♦ DRAG_THRESHOLD; 

gDragRact.right :» gDragRacl.right - DRAG_TH RES HOLD; 

gDragRact.bottom > gDragRacl.bottom - DRAG_THRESHOLD; 

•nd; 

{/•*•• M» nu Barlnit ../} 

procedure ManuBarlnit; 
va r 

myManuBar Handle; 
begin 

myManuBar :* OetNawMBar(BASE_RESJD); 










03/30/91 10:40 


Maln.p 


Pag* 4t 


SatManuBar(myManuBar); 
gApplaMonu > GatMHandln<APPLE JyENUJD); 
AddR*»M*nu(flAppJ*Maou, *DRVR*); 
DrawManuBar 
•nd; 

bag In 

Misclnit; 

Windowlnit: 

ManuBarlnit; 

Dialog I nit; 

MainLoop 

•nd. 







MultiEngine Unit 




04/01/91 21:14 


MultlEnglne.u 


unit Engine; 

Interface 

ueea 

Cons Vers; 

ear 

gSegArr: array(O..MAXJTEMS] of NodeSet; 

pro ced ure GetMonteStste; 
procedure Analyze; 
procedure TurboAnalyze; 
function SatSiza (nset: NodeSet): integer; 
procedure TurboLoop; 

Implementation 

procedure TurboLoop; 

va r 

i; longint; 

begin 

for i :■ 1 to gNumStates do 

begin 

GetMonteState; 

TurboAnalyze; 

end; 

end; 


function SetSize (nset: NodeSet): integer; 

va r 

i, j: integer; 

begin 

I 0. 

for i :» 1 to gNumNodes do 
If ((i In nset) and (i In gNodeSet)) than 

i > i ♦ i; 

SetSize :» j 
end; 


procedure GetMonteState; 

tar 

md: real; 

I: integer; 

begin 

•or I > 1 to gNumNodes do 

begin 

md :■ random; 

md > abe(md); 

md > rnd / 32767.001; 

If rod « gNodeArr[i]\Pd then 
gNodoArrIi] A .AIive :• FALSE 





04/01/91 21:14 


MultlEnglna.u 


Pag* 2 


•I** 

gNode Anrft]*.Alive TRUE 

•nd; 

for i1 lo gNumLinks do 
bogln 

md :■ Abs(Random) / 32767.001; 

If md < gUnkAnti)*.Pd than 
gLinkAnr(i]\Aliv* :« FALSE 

gUnkA/itiJ*.AIw» TRUE 
•nd 
•nd; 

procedure Analyze; 
va r 

ParentSet, Do'esal, S*gS*t: NodaSet; 

Ind, SegNum: integer; 

ParontArr: SetArrayType; 
flag; boolean. 

procedure inspectseg (var psat, loot: NodaSat; thisNoda: ElamantPtr); 
va r 

i; imager; 
loopset: Node Set. 

NaxtNode: ElementPtr, 
begin 

ParentArr[thisNoda\lD] :■ pset; 
paat :« peat ♦ [thisNodeMD]. 
iaat > Isat ♦ (thiaNodeMD); 

i ;» 1; 

while (tti«Nodo*.LList[i] o nil) do 
begin 

If (thisNode A JJJstIi]' > .Alive) then 
begin 

If IhisNode « thisNode*.LUst[i]*.encl1 then 
NaxtNode :■ thisNoda\LListli)*.and2 

•lee 

NaxtNode :» 1hi*NodeMliet(i]\and1; 

If NextNode*.AIiva then 
begin 

If NextNodaMD In peat then 
loot > Isat ♦ (past • ParentArrfNextNodaMD]) 

•fee 

begin 

If ((thisNode*.LUst{i]Mtind - Splx)) then 
begin 

loopset :• Q; 

inepect*eg(peat, loopset, NaxtNodo); 

If last * loopset • Q than 
begin 

If (((loopset • gBypSat) o 0) and ((loopMt * DonsSat) ■ Q)) then 

begin 

gNumSegs gNumSeg* ♦ 1; 
gSegArrtgNumSegs] > loopset 





04/01/91 21:14 


MultlEnglne.u 


Paga S 


•nd; 

peel :« pset - loopsat; 

DoneSet ;« Done Set * loope«1 

•nd 

• lee 

teat :« tMt 4 loopeet 

•nd 

•lee 

begin 

lnspectseg(pset, test, NextNode) 

•nd 

•nd 

•nd 

•nd; 

\ :m i ♦ 1 

•nd 

•nd; 

begin 

Donesel > Q; 
ind :» 1; 
gNumSegs ;« 0; 
for ind > 1 to gNumNodes do 
begin 

If (gNodeArrfind] A .A!ive and not (gNodeArrfind]\ID In Don«S*i) «nd (gNodaArrtind]\kind <» Bypaw)) 
fhon {substitute done set for segsat) 
begin 

Par*ntS*t ;« Q; 

SegSet D; 

S*gNum :• gNumSegs 4 1; 
gNumSegs :• SegNum; 

inspectS*g{Par*ntS«t, SegSet, gNod«Arr[indJ); 
gSegArrfSagNum] > SegSet; 

Done Set > DoneSet 4 SegSet 
•nd 
•nd 
•nd; 

procedur* Turbo Analyze: 
label 
1 ; 
ver 

Parents#t, SegSat: NodeSat; 
ind; integer; 

ParantArr: SetArreyType; 
flag; boolean; 

procedure Tinspectseg (ver poet, tael: NodeSat; thisNode: ElamentPtr); 
ver 

I; integer; 
loopeet: Node Set; 

NextNode: ElementPtr; 

begin 

ParentArrfthisNode 4 . ID] :» peat; 
poet > peat 4 (thisNodeMD]; 



04/01/91 21:14 MultlEnglne.u P*9* 4 

iMt > Iso! ♦ [thisNodeMD]; 
i 1; 

while (thisNode\LList[fj o nil) do 

bogln 

If (thisNode\Llist[i] A .Alive) thori 

bogln 

If thisNode - thisNode\Llist(i]\endi then 
NoxtNodo :■ th«Node\LList[i] A .end2 

•loo 

NoxtNodo > thiaNode\LList[i]\endl; 

H NoxtNodo A .AIivo then 
bogln 

If NoxtNodo A .IO In poet then 
loot > loot + (poet ■ ParentArrfNextNodeMDJ) 

•loo 

begin 

If ((thisNodo\LList[i)\kind » Splx}} ti.on 

bogln 

loopsot > Q; 

Tinspectseg{pset, loopsot, NoxtNodo); 

If loot * loopsot • Q then 
bogln 

If (loopsot • gBypSet) o Q then 
bogln 
goto 1 
end; 

poet :■ poet - loopsot 
end 

•loo 

loot :* Iset ♦ loopsot 
end 

•Iso 

bogln 

Tinspoctsog(psot. Isot, NoxtNodo); 

•nd 

•nd 

•nd 

•nd; 

I :• i ♦ 1 
•nd 
•nd; 
bogln 

SogSot :• Q; 
flag FALSE; 

for ind > 1 to gNumNodos do 

bogln 

If ((gNodoArrJind] A .AI«vo) end not (gNodoArrfind]\ID In SogSot) and (gNodoArr(ind] A .klnd o 
Bypass)) than 
bogln 

If Flag than 
goto 1; 

ParontSot :» Q; 

TinapoctSog(ParontSot, SogSot, gNodoArr|ind)); 




04/01/91 21:14 


MuttlEngln«.u 


P»g» f 


Flag :» Tru#; 

•nd 

•nd; 

Exlt(TurboAn»lyz*); 

1 : 

gS*gCoun1 > gS«gCount ♦ 1 
•nd; 

•nd. 



