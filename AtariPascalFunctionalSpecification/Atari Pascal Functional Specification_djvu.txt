Atari Pascal 


Software Functional Specification 


Prepared bv» 

Michael G„ Lehman 
Win t h ro p L. Savi11e 


MT MicroSYSTEMS 
1562 Kings Cross Drive 
’ Cardiff—bv-the—sea> California 
(714) 753-4856 92007 







cn iji cn ^5. -pa & 4^ co co co co to to to to to to t o t o to t o t o to 


Table Q£ Contents 


1.0 Introduction 

1.1 Purpose 

1.2 Deliverable Items 

1.3 Development Schedule 

Sy stem Overview 
Compi1er 

Intermediate Code Generator 
6502 Machine Code Generator 
Emu 1 at or 
Linker 



. 0 
. 1 
1 . 1 

1. t. 
1 . 1 . 
1» zl 

1.3 

2 

2 . 1 

2.2 


Atari Pascal Language 

Extensions to Standard Pascal 

Statement Level Extensions 

1 Data Type Extensions 

2 Control Structure Extensions 


Modular Compi1 ation 
Propramer Aids 
Atari Specific Extensions 
User Level Facilities 
System Level Facilities 


. 0 Compiler Operation 
„1 Phase I - Initialization 

.2 Phase II - Syntax Scan / Symbol Table Build 

.3 Phase III - Code Generation 

.4 Phase IV - Epilogue 


. 0 Linker Operation 
. 1 Operational Overview 

.2 Linker Data Formats 


6-0 Emulator Operation 

6.1 Operational Overview 

6.2 Instruction Se t 

7.0 Operating* System Requirements 

7.1 Compiler Requirements 

7.2 User Program Requirements 





1-Q 


Introduction 


This document is a specification of the software to be 
developed which will provide a Pascal compiler, linker and 
emulator for the Atari system 800.. 

This document covers a general overview of the software 
to be developed along with specific information regarding the 
Pascal language enhancements, compiler and linker operation, 
and the instruction set to be used for the emulator mode of 
operation. In addition a discussion of the operating* system 
requirements for both the compiler and the user programs is 
included for informational purposes. 



1-1 


EunEjasa 


The purpose of this document is to present* in writing* 
all the details regarding the Atari Pascal development 
project which are known at the besining of the project. As 
further information is developed this document will be 
enhanced to provide a reference document for the entire Atari 
Pascal SYstem as it evolves. This is not a final* cast-in¬ 
concrete* specification as not all parameters* requirements* 
etc. can be known at the beginning of such a project. 
Comments and suggestions from Atari personnel will be 
considered until the specification is finalized. After the 
specificaion is finalized additional modifications of the 
work statement will require possible adjustment of the 
contractual agreements between Atari and MT Mi c r o SYSTEMS'.. 


4 



1-2 


Deliverable Items 


The Atari Pascal development project wi11 result in the 
fol1 owing list of software and documentation being provided 
to Atari bv MT Micr©SYSTEMS: 

I„ Atari Pascal Compiler 

Ini Intermediate code generator 

I„2 Native Code generator 

II Pascal system linker 

III Intermediate Code Emulator for the 6502 

IV Pascal support library* in source and object form 

V User level documentation for Atari Pascal 

VI Program Logic documentation for the 
Compiler? Linker and Emulator 



1^3 DeveloEment Schedule 


The development of Atari Pascal ujill follow the 
schedule listed be 1 ow: 


March 1st 
June 1st 


De1iver y of this specifcation 

Deliverv of the first version of 
the Emulator along with a preliminary 
version of the compiler » 

This preliminary version of the compiler- 
will not in c1u de s 

Modular Compilations 

Support for- the run-time 1 ibrar-v: 

This means that the following 
routines? to be included in the 
library? will not be available: 


August 1st 


September 1st 


GET/PUT level disk I/O 
User Level Error Handling 
I/O other than to the console 

Delivery of the second version of the 
Emulator along with the second version 
of the compiler. 

While this version of the compiler u)il 1 
support modular compilations and the 
run—time library? the linker will not be 
completed at this time 

Delivery of the Linker along with 
the preliminary run-time library 


October 1st Delivery of the final compiler including 

6502 Native Code generator and the 
final run-time library and documentation 


6 





7 




2-1 


CatDEilen 


The Atari Pascal compiler is a program which will 
execute on an Atari svstem 300 with at least one disk unit, 
40K of RAM memory, and the Pascal Emulator cartridge. Source 
programs are prepared using a text editor (as vet not 
defined) and are stored on the disk. 

The compiler will read the source programs from the 
disk and translate the program into either intermediate code 
to be executed using the Pascal Emulator or into 6502 machine 
language code. 


2-1-1 Intermediate Code Genecatoc 


The Atari Pascal compiler can translate Pascal programs 
into an intermediate code suitable for use with the Pascal 
Emulator cartridge. This intermediate code is very space 
efficient and optimal for executing Pascal programs. It is-, 
however, also significant!v slower than machine code. This 
intermediate code is emulated bv the Pascal Emulator 
cartridge one intermediate instruction at a time. In this 
environment the emulator can provide debugging information, 
range checking and dynamic memory control. 


2-1-2 65Q2 Machine Code Genecatnc 


The Atari Pascal compiler can also translate Pascal 
programs into 6502 machine code. This machine code wil1 be 
tvpicallY 5 to 7 times larger than the corresponding 
intermediate code but should execute in the range of 3 to 10 
times faster than the same code in emulation. The user will 
be able to select, when compiling a program and/or module 
that all of the procedures in the program and/or module 
should be translated into 6502 machine code. Programs 
translated into machine code entirely will not require the 
Pascal Emulator but will require a significant ammount of 
run—time support. In addition if a program is translated 
entirely into 6502 machine code the user must link the 
program with the 6502 machine code run-time 1ibrarv which 
will be significantly larger than the intermediate code 
library. Included in the library are such functions as 
console formatted input/output and disk input/output. In 
addition, absent fr om this lib ra ry w i ll be run-t ime error 
recovery. 


2—2 


Emulator 


The Atari Pascal compiler can generate an intermediate 
code which is executed us ins the Pascal Emulator cartridge. 
This Pascal Emulator is a 6502 assembly language program 
which operates in an analogous fashion to microcode on a 
microprogrammed machine- The emulator will "fetch" each 
instruction and "execute" the instruction. 

Typically the Pascal Emulator will reside in a 
cartridge for user programs- There may be a special* mini- 
emulator* used by the compiler which would allow the use of 
the additional RAM present in a 48K system when a cartridge 
is not inserted. 

The emulator will be written* initially* using the UCSD 
Pascal 6502 assembler and linked via the UCSD Pascal linker. 
In the future* if Atari develops a linking assembler* this 
assembly can be done on other systems. The UCSD assembler 
has macro capabilities which are very simple and which are 
easlily translated to the format needed for other assemblers. 

When running a user program the user will (somehow) 
load the Pascal program produced by the compiler/1 inker and 
begin execution. User programs must have the Pascal Emulator 
cartridge. 



2^3 


Linken 


The Atari Pascal compiler supports modular compilation 
and also includes run-time support routines* as needed* from 
a svstem support 1ibrarv. In order to handle inclusion of 
the object code from external sources a linker is be ins 
written- This linker will be able to support both programs 
produced bv the Atari Pascal compiler as well as future needs 
including assemblers* other compilers* etc. The linker will 
take as input a number of object modules and produce as 
output an absolute memory image for subesuent execution* 
p1 ac ins in ROMs * etc. The linker will be written in Pascal 
and wi11 execute us ins the Pascal Emulator. 


10 




3-Q 


A-tani Eascal Lanauaaa 


The lansua.se which will he compiled bv the Atari Pascal 
compiler will be a superset of the Standard Pascal lansuase 
as defined in the “Pascal User's Manual and Report" bv Jensen 
and Wirth (2nd* Edition). There are two classes of 
extensions which will be added to the Pascal lansuase. 
Firsti a number of fundamental lansuase extensions including 
modular compilation strinss? untyped numeric data types? 
and random file access ins primitives will be added to the 
standard system. Second? a number of Atari specific 
facilities including access to Atari built-in software and 
Atari hardware will be added. 

Sections 3.1 and 3.2 will address these extensions in 
de tai 1 . 


11 



3-1 


Extensions to Standard Easnal 


The extensions to Pascal fall into two major 
First? extensions to the Pascal language syntax will 
to support modular compilations? hadlv needed 
structure improvements and data type extensions, 
extensions will be made in the form of additional 
procedures and functions to support easy access to 
facilities and direct memory accessing. 


areas 
be made 
c o n t r o 1 
Se c on d ? 
b ui1t-i n 
mac hine 


. 1-1 


Statement Level Extensions 


There are two groups of statement level extensions to 
be implemented: data type additions and control structure 
enhancements. 


3-1-1-1 


Data Ixse Extensions 


Atari Pascal will include three new data types beyond 
those defined in the Pascal standard. 

The use of Pascal in non-educational environments? in 
particular in 8-bit microprocessors? often requires the 
programmer? in other systems? to resort to machine language 
coding to perform byte and/or word arithmetic in an unsigned 
manner. To provide this feature Atari Pascal will provide 
BYTE and WORD data types. Variables of type BYTE can be used 
in any integer? character or boolean expression and is stored 
as an 8—bit unsigned quantity. Variables of type WORD can be 
used in any integer expression and when used with -*? DIV? MOD 
and comparison operations? will be treated as unsigned 
guantities. BYTE is defined as being stored in 8-bits and 
WORD is defined as being stored in 16-bits. 

The use of Pascal in many environments often suggests 
the implementation of dynamic length strings. Atari Pascal 
will implement such a STRING data type. The user will be 
able to select the maximum length of the string (up to 255 
bytes) at compile time by following the word string with the 
number of characters inside square brackets (e.g. 
STRINGC101). The compiler will allow strings of different 
lengths to be passed as parameters? compared? assigned? etc. 
In addition there will be built-in COPY and POS statements 
for accessing substrings and string scanning. Also? the ■+• 
operator will be defined as a concatenation operator between 
strings (e.g. STR : = ABCD "* + x EFGH) » 


12 





3^1-1^2 


Contciol Stciuctuce E^teasians 


It is generally agreed^ bv nori-purists? that the 
addition of a facilitv to handle non—matchins cases in 
CASE statements is needed. Atari Pascal case statments mav 
have an ELSE clause following all of the cases in a case 
statment. This ELSE clause will be executed if the case 
expression does not match any of the cases in the selectors 
provided. An example is shown be lows 


READ(CH); 

CASE CH OF 

'A', "'a*'' s WRITELN<'YOU TYPED AN A')? 
'Q '7 'g' : WRITELN('YOU TYPED A Q')? 
ELSE 

WRITELN('YOU DID NOT TYPE A OR Q') 

END? 


3~.1*.2 Modular: Comeilation 


It is widely accepted that some level of modular- 
compilation is a badly needed feature of Pascal. Pascal? as 
it is defined by the standard? tends to lead to very large 
"monolithic" programs. While encouraging smal1 easy-to-read 
procedures Pascal tends to also encourage large very hard-to- 
read programs. 

Atari Pascal will include a facility which will allow 
the development of groups of procedures and/or functions in a 
form called a MODULE. MODULES are compiled separately and 
are implicitly referenced by the declaration of an EXTERNAL 
procedure. Within MODULES and PROGRAMS procedures and 
functions may be declared as PRIVATE or PUBLIC. The default 
within a PROGRAM is that all procedures are PRIVATE unless 
declared as PUBLIC. The default within a MODULE is that all 
procedures are PUBLIC unless explicitly declared as PRIVATE. 

MODULES and PROGRAMS may also communicate via the main 
program's GLOBAL variable area. To accomplish this the 
addition of a GLOBAL declaration section in MODULES and in 
PROGRAMS has been made. 



i 


It is somewhat difficult to describe this entire 
process without an example. The two sections of Pascal code 
listed below are a MODULE containing some PUBLIC and PRIVATE 
procedures and functions and a PROGRAM containing some PUBLIC 
and PRIVATE and EXTERNAL procedures and a small main program. 


MODULE demo 1? 

TYPE 

data-base—recor d = RECORD 

phone-number s string? 
initial s char" 
last-name s string 
END? 


GLOBAL 

dbindex s array CO ..9991 of ^data-base-record? 

(* this variable really exists in the main program # > 


VAR 

i : integer? 

(#• this variable is private 
statically allocated and 
of the program *) 


EXTERNAL PROCEDURE xvz? (■* in 


to this module and is 
exists for the lifetime 


main program #) 


PRIVATE PROCEDURE abed? 

BEGIN 

tdoes someth ins) 

END? 

FUNCTION getrecord(VAR r:data-base-record> s BOOLEAN? 
(# defaulted to PUBLIC because in a MODULE *•) 

BEGIN 

Cget record from data base) 

END? 

... (•* additional procedures and functions here #) 


MODEND. 


(end of 


modu 1 e 


*) 



14 



PROGRAM mainl 


TYPE 

data-base-record = RECORD 

phone-number : string? 
initial : char" 
last-name : string 
END? 

GLOBAL 

dbindex 2 array CO .,9991 of A data„base-record? 

<■* this variable exists in the main program #) 
but is available to external references *•) 

(•* VAR declarations for the main program's global s which #> 

<■* are not available to external modules are declared here •*) 

VAR 

F : file? (* global to the main program but not available 
to other modules #) 


PUBLIC PROCEDURE xvz? (*■ accessable bv modules #) 
BEGIN 

{something} 

END? 

PROCEDURE abed? <* default to PRIVATE *) 

BEGIN 

{again something> 

END? 


EXTERNAL FUNCTION getrecord(VAR r:data-base-record):BOOLEAN? 


BEGIN (# main program *) 


END. <* of main program *) 


15 







3 - 1-3 


Enjaanammec: Aids 


Atari Pascal will include a number of built-in 
procedures which will be implemented as instructions in the 
emulator. These built-in facilities will allow bit and bvte 
manipulation as well as random access file input/output and 
premature procedure/function exitins. 

For bit manipulation the followins facilities will be 

addeds 

PROCEDURE SETSIT(VAR DATA:WORD; BITNUM:INTEGER); 


PROCEDURE CLRBIT(VAR DATA:WORD? BITNUM 2 INTEGER)* 

PROCEDURE FLIPBIT(VAR DATA: WORD* BITNUM:INTEGER)? 

FUNCTION TSTBIT(DATA:WORD? BITNUM:INTEGER):BOOLEAN? 
(* TRUE IF BIT IS ON •*) 

FUNCTION SHL( DATA : WORD ; NUMBI TS :INTEGER ): WORD ; 

<■* SHIFT LEFT *> 

FUNCTION SHR(DATA:WORD? NUMBITS:INTEGER):WORD; 

<* SHIFT RIGHT *) 


For bvte 

added: 

FUNCTION 

FUNCTION 


manipulation 

LO(DATA:WORD) 
HI(DATA:WORD) 


the fol1owins 

: BYTE; 

: BYTE; 


faci1ities will be 


FUNCTION SWAP(DATA:WORD) s WORD; 

FUNCTION DIGIT(DATA:WORD; DIGITNUM:0..3):WORD; 

(*• O is the least significant? 3 is most sisnificant ■*) 
(* disit is 4-bits BCD or HEX *) 


16 



To handle the problem of accessing external files 
the Atari Pascal compiler will support the addition of an 
optional file name parameter on the RESET and REWRITE 
statements and the addition of a CLOSE statement. The syntax 
i s • 

RESET ( f i 1 e ~.var-name t , tit 1 e_st ring C* APPEND }})' 

The APPEND is a reserved word signalling that writing 
should begin after the last record currently in the file. 

REWRITE(f i 1e~var-name i? tit1e_string) )" 

CLOSE ( f i 1 e-.var-.name ^ ■> LOCK} ) " 

The LOCK parameter is a reserved word signalling that 
the system should retain the file permanently. If LOCK is 
not specified the file will be deleted upon execution of the 
CLOSE statement. 

SEEK < f i 1 e~varename? recor d—.number—express i on ) ; 


This will allow random access to files bv positioning 
the file window such that the next GET or PUT will access the 
record specified bv the record—number—expression. 

The compiler will also support the built-in procedure 
EXIT. This will return from the current environment to the 
previous environment. This means that if executed internal 
to a procedure and/or function this will be the equivalent of 
a RETURN statement in BASIC or FORTRAN. If EXIT is executed 
at the NAIN program level this will be equivalent to a STOP 
statement in BASIC or FORTRAN. 


I c/n i-.v ci> • 


17 





Software related extensions fall into two categories. 
First those extensions which will be used bv the normal user 
including sound 7 graphics? padd 1 e/Joystick accessing and 
second those used typical 1 y bv Atari personnel including 
access to the ROM operating system-, etc. 

The following built-in procedures will access existing 
software drivers 2 

PROCEDURE GRMODE(modes integer)? 


This will set the graphics to “mode". This implies the 
possible shuffling of memory to make room for the display 
buffer and the display list- See 3.2.3 for the CRUNCH 
procedure which will reclaim the memory when fewer bytes are 
required for a new graphics mode. 



PROCEDURE COLOR(parms to be defined)? 

PROCEDURE PLOT(x,ysinteger)? 

PROCEDURE SOUND(parms to be defined)? 

FUNCTION TIME(parms to be defined); 

FUNCTION PADDLE(PNUMsINTEGER) 2 INTEGER? 

FUNCTION STICK(SNUM:INTEGER) : INTEGER? 

FUNCTION PTRIG(PNUMsINTEGER) : BOOLEAN? 

FUNCTION STRIG < SNUM:INTEGER) : BOOLEAN ? 

<* PTRIG AND STRIG ARE TRUE IF BUTTON DEPRESSED •*) 


f 


IS 



System Level Eacilltles 


In the Atari environment the systems programmer mar 
wish to perform a number of special purpose tasks. These 
range from memory management to special I/O facilities. 

Atari Pascal supports the reclaiming of memorv when 
graphics modes are changed* via the CRUNCH procedure. Memory 
in the Atari environment is managed such that the stack grows 
downward from the top of memory. The top being defined as 
Just under the display list. When the user executes a GRMODE 
call the system will dynamically move the entire stack down 
and leave room for the additional display buffer and display 
list. When the graphic mode is changed* resulting in less 
memory being required to implement the graphics mode the 
system will NOT automatically reclaim the memory. This is to 
avoid “thrashing" for simple programs. The CRUNCH procedure 
will move the stack back up to the highest point in available 
memory defined by the graphics mode at the time of execution 
of the CRUNCH. 

Dynamic memory allocation via the NEW procedure will be 
managed such that the user may perform some level of “garbage 
col 1ection“. This is not a s yet to ta lly define d. Current 
thoughts are that the DISPOSE function will chain together- 
available blocks of memory which the user may then combine if 
possible into larger b1ocks. The built-in procedure MENA W AIL 
will return the size of the largest block of avai1ab1e 
memory. The user may then attempt garbage collection and 
retry the MEMAVAIL before executing the NEW call. 


19 




4^Q 


CamEilen QEecatian 


The implementation of a Pascal compiler in the limited 
memory environment available in most microcomputers typically 
demands a multi-pass type of compiler. This technique can 
result in 1 arse arnmounts of disk I/O which is not always 
desireable particularly on systems which have very slow 
disks. In order to solve some of these problems the Atari 
Pascal compiler will attempt to “optimize 11 memory usage and 
limit disk access. 

The Atari Pascal compiler will be implemented as a four- 
phase compiler. Each phase is loaded from the disk and 
performs a specific task. The next four subsections 
describes each phase and its operation. 


4^1 Ehase I = Initialization 


Phase I is relatively small and is a separate phase 
only because it is executed once. Phase I verifies that the 
user’s source file exists•> prepares the symbol table by 
entering the pre—defined procedure and function names and the 
pre—defined types. 


4^.2 Ehase II = Syntax ScanZSymhol Table Build 


Phase II will process the user's input source program 
and build the symbol table. In addition it will syntax scan 
the program and produce a tokenized form of the user's 
program with the comments? etc. removed. In the case of 
small programs and small modules all of this will be done in 
memory. If memory space is unavailable the tokenized form of 
the program will be spooled to the disk as necessary. If 
there is not enought room for the symbol table it also will 
be spooled to the disk? significantly degrading the 
compilation speed. This management of memory will provide 
very fast compilation of small programs and modules and 
encourage use of manaeable program modules. 


20 



4-3 


Ehase Ill = Coda G^nanafian 


Phase III u>i 1 1 process the output from Phase II? the 
symbol table and the tokenized form the the program and 
produce a raw object module- There are really two Phase III 
programs- One which generates intermediate code for use with 
the emulator and one which produces 6502 machine code- The 
user must decide which is to be used on a module bv module 
basis- This means that all procedures and functions of a 
particular compilation must be compiled to the same object 
code- Phase III will attempt to buffer all of the object 
code for the module in memory and spool to the disk only when 
necessary. 


4-4 Ehase IV = EEilosue 


Phase IV will process the raw object code file from 
Phase III and convert this into a linker format object 
module suitable for subsequent linking and execution. This 
involves building linker records? global entry point and 
external reference tables. Phase IV will be complete when 
the user's program is stored on the disk. The reader will 
note that the compiler attempts to use available memory 
before using disk for temporary storage- However? the final 
rresult of a compilation must be stored on the disk and Phase 
IV will perform this operation if it has not already been 
done - 



5~Q 


Linked Qeenatinn 


5^1 Qeenational Ovenview 


The Linker is a Pascal program which will combine 
object modules produced bv the Atari Pascal compiler (or 
other suitable source) into an absolute executable program. 
The user will execute the linker (somehow) and suppIy the 
name of the object modules to be linked together. For non- 
Pascal programs the user must also suppIy the name of the 
module which is to be considered the "main" program. 

The linker expects all of the input files to be on the 
disk(s) and will place the resulting program on the disk. 

The following section describes the format of records 
which will be accepted bv the linker. 


22 




5-2 


Linker: Data Ennmats 


The linker format is a record oriented format. The upper- 
four bits of the first byte indicate the "type" of record and 
defines the remaining fields. 


TYPE BITS 4.,7 


0 = IDENTIFICATION RECORD. 

1 = STORE THE NEXT 0..15 BYTES OFF BASE 0 

2 = STORE THE NEXT O..15 BYTES OFF BASE 1 

3 = STORE THE NEXT 0..15 BYTES OFF BASE N 

4 = STORE MULTIPLE BYTES OFF BASE 0 

5 = STORE MULTIPLE BYTES OFF BASE 1 

6 = STORE MULTIPLE BYTES OFF BASE N 

7 = RELOCATE OFF BASE 0 

8 = RELOCATE OFF BASE 1 

9 = RELOCATE OFF BASE N 

10 = UNDEFINED RESERVED FOR LATTER EXPANSION 

11 = UNDEFINED RESERVED FOR LATTER EXPANSION 

12 = UNDEFINED RESERVED FOR LATTER EXPANSION 

13 = END OF MODULE RECORD WITH NO STARTING ADDRESS 

14 = END OF MODULE RECORD WITH STARTING ADDRESS 

15 = ESCAPE TYPE, THE BYTE FOLLOWING = TYPE OF RECORD 


= IDENTIFICATION RECORD 


THE LOWER 4 BITS OF THE TYPE BYTE, BITS 0..3, IDENTIFY 
THE TYPE OF ID RECORD. 

BITS 0..3 OF TYPE BYTE 

0 = MODULE IDENTIFIER 


OFFSET FROM TYPE BYTE 

1. . 4 LENGTH OF THIS LINKER MODULE 

IN BYTES 

5 LENGTH OF NAME (LNAME) 

6 ..5+LNAME-l NAME 

1 = PROCEDURE ENTRY POINT 

BYTE 

BASE NUMBER OF PROCEDURE 
NUMBER OF PARAMETERS (255 = UNKNOWN) 
OFFSET IN BASE OF THE PREOCEDURE 
LENGTH OF NAME (LNAME) 

NAME 


OFFSET FROM TYPE 
1,2 
3 

4. . 7 

8 

9..9+LNAME-l 










FUNCTION ENTRY POINT 


OFFSET FROM TYPE BYTE 
1,2 BASE 


NUMBER OF PROCEDURE 


3 NUMBER OF PARAMETERS (255 = UNKNOWN) 

4 SIZE OF RETURNED DATA ELEMENT IN BY! 

5.. 5 OFFSET IN BASE OF THE PREOCEDURE 

9 LENGTH OF NAME (LNAME) 

10.. 10+LNAME-l NAME 


DATA ENTRY POINT 

OFFSET FROM TYPE BYTE 

1,2 BASE NUMBER OF DATA 

3.. 6 SIZE OF DATA ELEMENT 

7.. 10 OFFSET IN BASE TO THE DATA ELEMENT 

11 LENGTH OF NAME (LNAME) 

12.. 12+LNAME—1 NAME 

PROCEDURE EXTERNAL REFERENCE 


OFFSET FROM TYPE 
1,2 


4 

5..5+LNAME—1 


BYTE 

BASE NUMBER OF PROCEDURE 
THIS BASE NUMBER IS THE INTERNAL 
BASE NUMBER FOR THIS MODULE. EACH 
EXTERNAL ELEMENT (PROCEDURE, FUNCTIC 
OR DATA) HAS A UNIQUE BASE NUMBER At' 
IS LINKED WITH AN ENTRY POINT TOa 
DETERMINE ITS ACTUAL BASE NUMBERW 
NUMBER OF PARAMETERS (255 = UNKNOWN) 
LENGTH OF NAME (LNAME) 

NAME 


FUNCTION EXTERNAL REFERENCE 


OFFSET FROM TYPE 
1,2 

3 

4 

5 

6..6+LNAME-1 


BYTE 

SAME AS EXTERNAL PROCEDURE 
NUMBER OF PARAMETERS (255 = UNKNOWN) 
SIZE OF RETURNED DATA ELEMENT IN BY1 
(255 = UNKNOWN) 

LENGTH OF NAME (LNAME) 

NAME 


DATA EXTERNAL REFERENCE 


OFFSET FROM TYPE BYTE 


1,2 
3 

4..4+LNAME-l 


SAME AS EXTERNAL PROCEDURE 


LENGTH OF NAME 
NAME 


(LNAME) 



24 



•> 



7 


RELOCATION BASE RECORD 

OFFSET FROM TYPE BYTE 

1,2 BASE NUMBER 

3.. 6 VALUE OF BASE 

7.. 10 SIZE OF BASE IN BYTES 


3 = SYMBOL TABLE ENTRY 

OFFSET FROM TYPE BYTE 

1,2 BASE NUMBER 

3.. 6 OFFSET OF THIS SYMBOL 

7 LENGTH OF NAME (LNAME) 

8.. 8+LNAME—1 NAME 


9..15 = UNDEFINED 


1 = STORE THE NEXT O..15 BYTES OFF BASE 0 

BITS 0..3 OF TYPE BYTE = NUMBER OF BYTES 

OFFSET FROM TYPE BYTE 

1..1+NUMBYTES-l BYTES TO STORE 



2 = STORE THE NEXT 0..15 BYTES OFF BASE 1 

BITS 0..3 OF TYPE BYTE = NUMBER OF BYTES 

OFFSET FROM TYPE BYTE 

1.. 1+NUMBYTES-l BYTES TO STORE 

3 = STORE THE NEXT 0..15 BYTES OFF BASE N 

BITS 0..3 OF TYPE BYTE = NUMBER OF BYTES 

OFFSET FROM TYPE BYTE 

1,2 BASE NUMBER TO USE 

3.. 3+NUMBYTES-l BYTES TO STORE 

4 = STORE MULTIPLE BYTES OFF BASE O 


BITS 0..3 OF TYPE BYTE = UNDEFINED 


OFFSET FROM TYPE BYTE 

1,2 NUMBER OF BYTES TO STORE 

3..3+NUMBYTES-l BYTES TO STORE 


25 



STORE MULTIPLE BYTES OFF BASE 1 


BITS 0..3 OF TYPE BYTE = UNDEFINED 

OFFSET FROM TYPE BYTE 

1 *2 NUMBER OF BYTES TO STORE 

3.. 3+NUMBYTES—1 BYTES TO STORE 

STORE MULTIPLE BYTES OFF BASE N 

BITS 0..3 OF TYPE BYTE = UNDEFINED 

OFFSET FROM TYPE BYTE 

1*2 NUMBER OF BYTES TO STORE 

3,4 BASE NUMBER TO USE 

5.. 5+NUMBYTES—1 BYTES TO STORE 

RELOCATE OFF BASE 0 

BIT 3 OF TYPE BYTE = OFFSET SIZE 

0=2 BYTE OFFSET 
1=4 BYTE OFFSET 


BITS 0..2 OF TYPE BYTE = 

SIZE AND POSITION OF THE RESULTANT SUM OF 
THE OFFSET AND BASE 


0 = LOW BYTE OF SUM 

1 = HI BYTE OF SUM 

2 = LOW 2 BYTES OF SUM 

3 = HI 2 BYTES OF SUM 
4=4 BYTES OF SUM 

5 = UNDEFINED 

6 = UNDEFINED 

7 = UNDEFINED 


OFFSET FROM TYPE BYTE 

IF BIT 3 OF TYPE BYTE = 0 THEN 

1.. 2 = OFFSET 
ELSE 

1.. 4 = OFFSET 



26 



RELOCATE 


OFF BASE 1 


ft ~ 


BIT 3 OF TYPE BYTE = OFFSET SIZE 


SAME AS 6 


BITS 0..2 OF TYPE BYTE = 

SIZE AND POSITION OF THE RESULTANT SUM OF THE 
OFFSET AND THE BASE VALUE 

SAME AS 6 


9 = RELOCATE OFF BASE N 

BIT 3 OF TYPE BYTE = OFFSET SIZE 
SAME AS 6 


BITS 0..2 OF TYPE BYTE = 

SIZE AND POSITION OF THE RESULTANT SUM OF THE 
OFFSET AND THE BASE VALUE 


SAME AS & 


OFFSET FROM TYPE BYTE 

1,2 = BASE NUMBER 

IF BIT 3 OF TYPE BYTE = 0 THEN 

3.. 4 - OFFSET 
ELSE 

3.. 6 = OFFSET 


10 = UNDEFINED RESERVED FOR LATTER EXPANSION 


11 = UNDEFINED RESERVED FOR LATTER EXPANSION 


12 = UNDEFINED RESERVED FOR LATTER EXPANSION 


13 = END OF MODULE RECORD WITH NO STARTING ADDRESS 


27 



END OF MODULE RECORD WITH STARTING ADDRESS 


OFFSET FROM TYPE BYTE 

1,2 

3 . . 6 


BASE NUMBER 

OFFSET FROM THE BASE 


ESCAPE TYPE 

OFFSET FROM TYPE BYTE 
1 


NO TYPES DEFINED 



6^Q 


Emulator: Operation 


£*_± Oefiratianal Overview 


The emulator is a 6502 machine language program which 
will execute the intermediate code procduced bv Phase III of 
the compiler. It will "fetch" and “execute" each instruction 
in a manner analogous to micro—code in a microprogrammed 
machine. 

When an error occurs the emulator will trap to pre¬ 
defined procedures in the intermediate code program. If 
these procedures have been supp! ied bv the user the emulator 
will call them* if not the compiler will generate default 
procedures which will return control to the emulator in the 
case of an error. In anv event* if a fatal error occurs the 
emulator will give a diagnostic message indicating where 
within the running program the error occured and a traceback 
of the procedure/function entry stack. 


The 

fo11 owing 

section 

describe s 

the 

emu 1 ator 

instruction 

set. 









Instruction Set 


THE Pascal Emulator IS DESIGNED TO EXECUTE THE PASCAL 

LANGUAGE. THIS EMULATOR IS ALSO DESIGNED TO BE CONSTRUCTED 

EITHER IN A SOFTWARE INTERPRETIVE MANNER OR BY FIRMWARE 
SUPPORTED HARDWARE PROCESSORS. 

THE INSTRUCTIONS FOR THE Pascal Emulator ARE DEFINED TO 

HAVE THE UPPER FOUR BITS BE SUFFICIENT TO DECODE THE BASE 

INSTRUCTION TYPE: 

0 - LOAD LOCAL GROUP 

1 - LOAD INTERMEDIATE/GLOBAL GROUP 

2 - STORE LOCAL GROUP 

3 - STORE INTERMEDIATE/GLOBAL GROUP 

4 - ADD,SUBTRACT,MULTIPLY 

5 - DIVIDE, MOD (REMAINDER) 

6 - SET OPERATIONS 

7 - COMPARE OPERATIONS 

8 - PROCEDURE CALL/RETURN 

9 - LOAD CONSTANT 

A - BIT OPERATIONS 

B - JUMPS 

C - MOVES 

D - ARRAY INDEX, BOUNDS CHECKING 

E - MISC. OPERATIONS #1 

F - MISC. OPERATIONS #2 

THE FOLLOWING SECTIONS DESCRIBE EACH OPCODE 
IN DETAIL: 


30 




0 


LOAD LOCAL 


OPCODE CLASS: 


FORMAT: 


! 0 ! 0 !0!Q!L!L!W!W! 


LL = OPERAND LENGTH 

00 = 1 BYTE 
01 = 2 BYTES 
10 = 4 BYTES 

1.1 = N BYTES OR LOAD LOCAL ADDRESS 


WW = ADDRESS WIDTH 

00 = 1 BYTE 
01 = 2 BYTES 
10 = 3 BYTES 
11=4 BYTES 


(SEE BELOW) 


THE DEFAULT BASE REGISTER FOR THIS TYPE OF 
INSTRUCTION IS THE CURRENT LOCAL BASE REGISTER. 


THIS CLASS OF INSTRUCTION IS A MINIMUM OF TWO 
BYTES IN LENGTH AND CAM BE UPTG 6 BYTES LONG. 


FORM #1: (OPERAND LENGTH = 1,2 OR 4 BYTES) 


BYTE 

is 

OX 

(X^ 

=LLWW) 







BYTE 

2s 

AA 

( 1 

ST 

ADDRESS 

BYTE 

WW=00) 




BYTE 

3 s 

BB 

(2 

ND 

ADDRESS 

BYTE 

ONLY 

IF 

WW = 

01 7 

10, 11 ) 

BYTE 

4: 

cc 

(3 

RD 

ADDRESS 

BYTE 

ONLY 

IF 

WW = 

10 7 

11) 

BYTE 

cr • 

DD 

(4 

TH 

ADDRESS 

BYTE 

ONLY 

IF 

WW = 

1 1 ) 



AA,BB,CC,DD ARE THE ADDRESS BYTES WITH 

AA ALWAYS BEING THE MOST SIGNIFICANT ADDRESS BYE 

AND THE LAST (BB,CC OR DD) BEING THE LEAST SIGNIFICANT BYTE 


31 






FORM #2= (OPERAND LENGTH = N BYTES) 


BYTE 

1 S 

OX 

BYTE 

25 

FN 

BYTE 

3 - 

AA 

BYTE 

4: 

BB 

BYTE 

Ft s 

cc 

BYTE 

65 

DD 


( X=11WW) 

(F=FLAG 0/$80 AND N=# OF OPRND BYTES -1) 
(SAME AS ABOVE) 


THE FLAG FIELD IS USED TO SELECT WHETHER 

THE VALUE OF THE SPECIFIED LOCAL VARIABLE WILL BE 

LOADED OR THE ADDRESS. IF FLAG = 0 THEN THE VALUE IS LOADED 

ELSE THE ADDRESS IS LOADED. IN THE CASE WHERE THE 

FLAG IS $80 THEN THE N FIELD IS ALWAYS SET TO THE NUMBER 

OF BYTES IN AN ADDRESS FOR THE CURRENT IMPLEMENTATION 

OF THE FLASH PROCESSOR. 


EXAMPLES: 

A) LOAD CONTENTS OF LOCAL VARIABLE WITH OFFSET 
OF 15 AND LENGTH OF 2 BYTES: 

04 (* LOAD, OPRND LEN=2 BYTE, ADDR WIDTH = 1 BYTE *) 
OF (* OFFSET OF 15 *) 


B) LOAD ADDRESS OF LOCAL VARIABLE WITH OFFSET 
OF 512 BYTES AND LENGTH OF 1 BYTE (CHAR/BOOL) 

OD <* LOAD, OPRND LEN=N BYTES, ADDR WIDTH = 2 BYTES *) 

82 (* FLAG SET MEANING LOAD ADDRESS, LENGTH OF ADDR IS 2 BYTES 
02 00 <■* OFFSET OF 512 •*> 




1 


LOAD INTERMEDIATE/GLOBAL 



OPCODE 


CLASS: 


FORMAT: 


• O ! 0 ! 0 ! 1 ! L ! L ! W ! W ! 


LL = OPERAND LENGTH 

00 = (UNUSED) 

01 = (UNUSED) 

10 = N BYTES INDIRECT TO ADDRESS ON STACK 

11 = N BYTES OR LOAD INTERMEDIATE/GLOBAL ADDRESS (SEE BELOW) 

IF THE LL FIELD = 10 THEN THE ADDRESS WIDTH SPECIFIES 
-THE WIDTH OF THE ADDRESS ON THE STACK. 


WW = ADDRESS WIDTH 


00 
01 
10 
11 



1 BYTE 

2 BYTES 

3 BYTES 

4 BYTES 


THE BASE (DISPLAY) REGISTER FOR THIS TYPE OF 

INSTRUCTION IS SPECIFIED IN THE SECOND BYTE OF THE INSTRUCTION. 


THIS CLASS OF INSTRUCTION IS A MINIMUM OF THREE 
BYTES IN LENGTH AND CAN BE UPTO 6 BYTES LONG. 


AA,BB,CC,DD ARE THE ADDRESS BYTES WITH 

AA ALWAYS BEING THE MOST SIGNIFICANT ADDRESS BYE 

AND THE LAST (BB,CC OR DD) BEING THE LEAST SIGNIFICANT BYTE 


(OPERAND LENGTH = N BYTES) 


BYTE 

1 : 

OX 

(X=11WW) 

BYTE 

2: 

FN 

(F=FLAG/LEX LEVEL 0 

BYTE 

3s 

AA 

(SAME AS ABOVE) 

BYTE 

4: 

BB 


BYTE 

5s 

CC 


BYTE 

6: 

DD 



.7 •+• FLAG AND N=# OF OPRND BYTES -1 ) 





IN THIS INSTRUCTION THE LOWER 3 BITS OF THE FLAG FIELD 
ARE USED AS AN INDICATOR OF WHICH DISPLAY REGISTER TO USE 
A BASE WHEN CALCULATING THE OPERAND ADDRESS. 


AS 



THE FLAG FIELD IS USED TO SELECT WHETHER 

THE VALUE OF THE SPECIFIED INTERNED!ATE/GLOBAL VARIABLE WILL BE 
LOADED OR THE ADDRESS. IF FLAG = 0 THEN THE VALUE IS LOADED 
ELSE THE ADDRESS IS LOADED. IN THE CASE WHERE THE 
FLAG IS 1 THEN THE N FIELD IS ALWAYS SET TO THE NUMBER 
OF BYTES IN AN ADDRESS FOR THE CURRENT IMPLEMENTATION 
OF THE FLASH PROCESSOR. 


EXAMPLES: 

A) LOAD GLOBAL VARIABLE WITH AN OFFSET OF 128 BYTES 
AND A LENGTH OF 16 BYTES (A SET) 

1C (* LOAD GBL, OPRND LEN=N BYTES, ADDR = 1 BYTE *) 

OF (* VAL (NOT ADDR), USE DISP REG 0, LENGTH = 16 (15+1) *> 
80 (* OFFSET OF 128 *) 


B) LOAD ADDR OF VARIABLE FROM LEX LEVEL 2 
OFFSET OF 1024 


WITH AN 


ID (* LOAD INTERMEDIATE, OPRND LEN=N BYTES, ADDR 
A2 (* ADDR, LEX LEVEL=2, ADDR LEM = 2 BYTES *) 

04 

00 (* OFFSET 1024 •#■> 


2 BYTES 


*) 



34 



STORE LOCAL 


OPCODE CLASS: 


FORMAT: 


! c; 

> 1 

0 ! 1 ! 

0 ! L 

LL 

= 

OPERAND 

LENGTH 

DO 


1 BYTE 


01 

= 

2 BYTES 


10 

= 

3 BYTES 


11 

= 

N BYTES 


WW 


ADDRESS 

WIDTH 

00 

sr 

1 BYTE 


01 

=s 

2 BYTES 


10 

= 

3 BYTES 


11 

= 

4 BYTES 



THE BASE (DISPLAY) REGISTER FOR THIS TYPE OF 

INSTRUCTION IS DEFAULTED TO THE CURRENT LOCAL BASE REGISTER. 


THIS CLASS OF INSTRUCTION IS A MINIMUM OF TWO 
BYTES IN LENGTH AND CAN BE UPTO 6 BYTES LONG. 


FORM #1: (OPERAND LENGTH 


1,2 OR 4 BYTES) 


BYTE 

12 

OX 

<X = 

=LLWW) 





BYTE 

22 

AA 

( 1 

ST 

ADDRESS 

BYTE 

WW=00) 


BYTE 

3: 

BB 

(2 

ND 

ADDRESS 

BYTE 

ONLY 

IF 

WW = 01,10, 

BYTE 

42 

CC 

(3 

RD 

ADDRESS- 

BYTE 

ONLY 

IF 

WW = 10,11) 

BYTE 

52 

DD 

(4 

TH 

ADDRESS 

BYTE 

ONLY 

IW 

WW ~ 11) 


AA,BB,CC,DD ARE THE ADDRESS BYTES WITH 

AA ALWAYS BEING THE MOST SIGNIFICANT ADDRESS BYE 

AND THE LAST (BB,CC OR DD) BEING THE LEAST SIGNIFICANT BYTE 





FORM 

#2 

: (OPERAND LENGTH = M BYTES) 

BYTE 

1: 

OX 

(X=11WW) 

BYTE 

■ 

LN 

(L=LEX LEVEL 0..7 AND 

BYTE 

3 s 

AA 

(SANE AS ABOVE) 

BYTE 

4: 

BB 


BYTE 

5 s 

CC 


BYTE 

6: 

DD 




N=# OF OPRND BYTES -1 ) 


EXAMPLES: 

A) STORE CONTENTS OF STACK INTO LOCAL VARIABLE WITH OFFSET 
OF 15 AND LENGTH OF 2 BYTES: 


14 <* STORE 7 OPRND LEN=2 BYTE* ADDR WIDTH 
OF (* OFFSET OF 15 *) 


BYTE •*) 



36 



STORE INTERMEDIATE/GLOBAL 


OPCODE CLASS 


3 


FORMAT: 


! 0 ! 0 ! 1 ! 1 ! L ! L ! W ! U) ! 


LL = OPERAND LENGTH 


00 = (UNUSED) 

01 = (UNUSED) 

10 = N BYTES INDIRECT TO ADORES 

11 = N BYTES 


UNDERNEATH DATA 


IF LL = 10 THEN THE WW FIELD SPECIFIES THE WIDTH OF 
THE ADDRESS ON THE STACK. 


WW = ADDRESS WIDTH 

00 = 1 BYTE 
01 =2 BYTES 

10 = 3 BYTES 

11 = 4 BYTES 


THE BASE (DISPLAY) REGISTER FOR THIS TYPE OF 

INSTRUCTION IS SPECIFIED IN THE SECOND BYTE OF THE INSTRUCTION. 


THIS CLASS OF INSTRUCTION IS A MINIMUM OF THREE 
BYTES IN LENGTH AND CAN BE UPTO 6 BYTES LONG. 


AA,BB,CC,DD ARE THE ADDRESS BYTES WITH 

AA ALWAYS BEING THE MOST SIGNIFICANT ADDRESS BYE 

AND THE LAST (BB.CC OR DD) BEING THE LEAST SIGNIFICANT BYTE 


(OPERAND LENGTH 

BYTE 1: OX 
BYTE 2: LN 
BYTE 3: AA 
BYTE 4: BB 
BYTE 5: CC 
BYTE 6: DD 



= N BYTES) 

(X=11WW> 

(L=LEX LEVEL 0..7 AND 
(SAME AS ABOVE) 


N=# OF OPRND BYTES -1 ) 


37 






IN THIS INSTRUCTION THE LOWER 3 BITS OF THE LEX LEVEL 
ARE USED AS AN INDICATOR OF WHICH DISPLAY REGISTER TO USE 
A BASE WHEN CALCULATING THE OPERAND ADDRESS. 


AS 



EXAMPLES: 

A) STORE GLOBAL VARIABLE WITH AN OFFSET OF 128 BYTES 
AND A LENGTH OF 16 BYTES (A SET) 

3C (* STORE GBL, OPRND LEN=N BYTES, ADDR = 1 BYTE *) 

OF (* VAL (NOT ADDR), USE DISP REG 0, LENGTH = 16 (15+1) *) 
SO <•* OFFSET OF 128 •*> 


B) STORE ADDR OF VARIABLE FROM LEX LEVEL 2 WITH AN 
OFFSET OF 1024 

3D (* LOAD INTERMEDIATE, OPRND LEN=N BYTES, ADDR = 2 BYTES *) 
A2 (* ADDR, LEX LEVEL=2, ADDR LEM = 2 BYTES *) 

04 

00 (* OFFSET 1024 *) 


C) STORE 2 BYTE VARIABLE INDIRECT TO ADDRESS 

UNDERNEATH VARIABLE (ADDRESS IS TWO BYTES LONG) 
AT LEX LEVEL 2 


3A (* STORE, INDIRECT, ADDR WIDTH = 2 BYTES *) 
22 (* LEX LEVEL = 2, OPERAND WIDTH = 2 BYTES *) 


-;0 

I 



OPCODE CLASS: 


4 


ADD, SUBTRACT, MULTIPLY 


FORMAT: 


! 0 ! 1 ! 0 ! 0 ! T ! T ! F ! F ! 


THE TWO OPERANDS FOR THIS OPERATION ARE ASSUMED TO 
BE THE TOP TWO ITEMS ON THE STACK. 

TT = VARIABLE TYPE 

00 = 2 BYTE INTEGER 
01 = 4 BYTE INTEGER 

10 = (RESERVED) 

11 = REAL 


FF = FUNCTION 

00 = ADD 
01 = SUBTRACT 

10 = MULTIPLY (SIGNED TWO'S COMPLEMENT) 

11 = MULTIPLY (UNSIGNED) 


EXAMPLES: 

A) MULTIPLY (SIGNED) INTEGER 
42 


B) SUBTRACT REAL 
4D 


C > ADD 4 BYTE INTEGERS 
44 


39 





OPCODE CLASS: 


DIVIDE AND MOD 


FORMAT: 


!0!1!0!1!T!T!F!F! 


THE TWO OPERANDS FOR THIS OPERATION ARE ASSUMED TO 
BE THE TOP TWO ITEMS ON THE STACK. 

TT = VARIABLE TYPE 

00 = 2 BYTE INTEGER 
01 = 4 BYTE INTEGER 

10 = (RESERVED) 

11 = REAL 


FF = FUNCTION 

00 = DIVIDE (SIGNED) 

01 = DIVIDE (UNSIGNED) 

10 = MOD (SIGNED) (INTEGER ONLY) 

11 = MOD (UNSIGNED) (INTEGER ONLY) 


EXAMPLES: 


A) SIGNED DIVIDE 2 BYTE INTEGER 
50 


B) UNSIGNED MOD 4 BYTE INTEGER 
55 


40 





I 


OPCODE CLASS: 6 


SET OPERATIONS 


FORMAT: 


!0!1!1!0! F!F!F!F! 


THE TWO OPERANDS FOR THIS OPERATION ARE ASSUMED TO 
BE THE TOP TWO ITEMS ON THE STACK. 


FFFF = FUNCTION TO BE PERFORMED 

OOOO = SET UNION (OR) 

0001 = SET INTERSECTION (AND) 

0010 = SET DIFFERENCE (XOR) 

0011 = (RESERVED) 

0100 = SET INCLUSION (TOS = INTEGER, NOS = SET, AT END 
RESULT IS BOOLEAN ON STACK) 

0101 


1111 


(RESERVED) 


41 







OPCODE CLASS 


7 


COMPARE OPERATIONS 


FORMAT: 


! 0 ! 1 ! 1 ! 0 ! C ! C ! C ! C ! 


THE TWO OPERANDS FOR THIS OPERATION ARE ASSUMED 
BE THE TOP TWO ITEMS ON THE STACK. 

CCCC = COMPARE TYPE 

OOOO = EQUAL 

0001 = NOT EQUAL 

0010 = GREATER THAN 

0011 = LESS THAN 

0100 = GREATER THAN OR EQUAL 

0101 = LESS THAN OR EQUAL 


THE SECOND BYTE OF A COMPARE INSTRUCTION 
SPECIFIES THE TYPE OF COMPARISON AND THE 
LENGTH OF THE OPERANDS 


!T!T!T!T!L!L!L!L! 



TTTT = TYPE OF COMPARISON 

0000 = INTEGER COMPARE 

0001 = PACKED CHAR ARRAY COMPARE 

0010 = STRING COMPARE (USE STRING LENGTHS) 

0011= BOOLEAN COMPARE 

0100 = REAL COMPARE 

0101 = MULTI WORD COMPARE 

0110 


1111 = (RESERVED) 


NOTE IF TTTT=0001 OR 0101 THEN 
A THIRD AND FOURTH BYTES ARE USED 
TO SPECIFY THE LENGTH OF THE AGGREGATE 
DATA ITEM (TYPICALLY A CHAR ARRAY OR 
A RECORD. ALSO IN THIS CASE ONLY THE 
EQUAL AND NOT EQUAL OPERATIONS ARE GENERATED 
BY THE COMPILER. 


LLLL 


LENGTH OF ITEM IN BYTES (MINUS 


1 ) 



42 










TTTT = TYPE OF CALL/RETURN DESIRED 

OOOO = RETURN, PROCEDURE TYPE, NO VALUE 

0001 = RETURN, VALUE ON TOS IS 2 BYTES 

0010 = RETURN, VALUE ON TOS IS 4 BYTES 

0011 = RETURN, VALUE ON TOS IS A REAL 

0100 = CALL, TWO BYTE ADDRESS FOLLOWS 
0101 = CALL, THREE BYTE ADDRESS FOLLOWS 
0110 = CALL, FOUR BYTE ADDRESS FOLLOWS 
0111 = (RESERVED) 

1000 = CALL, DATA SIZE, 2 BYTES, FOLLOWS 2 BYTE ADDR 

1001 = CALL, DATA SIZE, 2 BYTES, FOLLOWS 3 BYTE ADDR 

1010 = CALL, DATA SIZE, 3 BYTES, FOLLOWS 3 BYTE ADDR 

1011 = CALL, DATA SIZE, 4 BYTES, FOLLOWS 4 BYTE ADDR 

1100 


1110 = (RESERVED) 

1111 = CALL, ALTERNATE INSTRUCTION SET 

4 BYTE ADDRESS FOLLOWS 

FOR 0100..0111 THE PROCEDURE IS ASSUMED TO HAVE 
NO PARAMETERS AND NO LOCAL VARIABLES. 



43 





* 


OPCODE CLASS: 9 


LOAD CONSTANT 


FORMAT: 


! 1 ! 0 ! 0 ! 1 ! T ! T ! T ! T 


TTTT = TYPE OF CONSTANT 
OOOO 


0001 
0010 
0011 
0100 
Old 

0110 
0111 


1 BYTE CONSTANT FOLLOWS INST 
PUSH ON STACK WITH HI BYTE<S) 00 

2 BYTE CONSTANT FOLLOWS INST 

3 BYTE CONSTANT FOLLOWS INST 

4 BYTE CONSTANT FOLLOWS INST 
REAL CONSTANT FOLLOWS INST 

STRING CONSTANT FOLLOWS LENGTH WHICH 
FOLLOWS INSTRUCTION 

SET CONSTANT (16-BYTES) FOLLOWS INSTRUCTION 


1000 


(RESERVED) 


44 





OPCODE CLASS: A - BIT OPERATIONS 


FORMAT: 


! 1 ! 0 ! 1 ! O ! T ! T ! T ! T ! 


TTTT 

= 

TYPE 

: OF 

OPERATION 



0000 


AND 

TOS&NOS 7 2 BYTES 



0001 

= 

AND 

TOS& 

NOS, 4 BYTES 



0010 

= 

OR 

TOS! 

NOS, 2 BYTES 



0011 

= 

OR 

TOS ! 

NOS, 4 BYTES 



0100 

= 

NOT 

TOS 7 

2 BYTES 



0101 

= 

NOT 

TOS 7 

4 BYTES 



0110 

=s 

XOR 

TOS@NOS, 2 BYTES 



0111 

= 

XOR 

TOS 7 

NOS, 4 BYTES 



1000 

= 

TST 

BIT 7 

TOS=BIT#, N0S=2 

BYTE 

OPERAND 

1001 

= 

TST 

BIT 7 

TOS=BIT#, NOS=4 

BYTE 

OPERAND 

1010 

== 

SET 

BIT, 

TOS=BIT#, NOE**=2 

BYTE 

OPERAND 

1011 

= 

SET 

BIT, 

TOS=BIT#, NOS=2 

BYTE 

OPERAND 

1100 

= 

CLR 

BIT, 

TOS—BIT#, N0S=2 

BYTE 

OPERAND 

1101 

= 

CLR 

BIT, 

TOS=BIT#, NOS-4 

BYTE 

OPERAND 

1110 

== 

EXTENDED 

1 OPERATION (SEE ' 

BELOW) 


1111 


(REE 

SERVED) 




IF TTTT = 1110 THEN THE SECOND BYTE 
OF THE INSTRUCTION MUST BE EXAMINED 
TO DETERMINE THE APPROPRIATE ACTION 


!A!A!A!A!A!A!A!A! 


AAAAAAAA = ACTION 


00000000 
00000001 
00000010 
00000011 
00000100 
00000101 
0000011o 
00000111 

00001000 

00001001 


= CHANGE BIT, TOS=BIT#, N0S=2 BYTE OPERAND 
= CHANGE BIT, TOS=BIT#, NGS=4 BYTE OPERAND 
= SHIFT RIGHT, TOS=#BITS, N0S=2 BYTE OPERAND 
= SHIFT RIGHT, TOS=#BITS, N0S=4 BYTE OPERAND 
= SHIFT LEFT, TOS=#BITS, N0S=2 BYTE OPERAND 
= SHIFT LEFT, TOS=#BITS, N0S=4 BYTE OPERAND 
= CLEAR ALL BUT LOW ORDER 3 BITS OF TOS 
= MOVE HIGH ORDER 3 BITS OF TOS TO LOW ORDER 
AND CLEAR HIGH ORDER 3 BITS 
= SWAP HIGH ORDER 3 BITS AND LOW ORDER S BITS 
OF TOS 


11111111 


< RESERVED) 


BIT 


45 









* 


OPCODE CLASS: B 


JUMPS 



FORMAT: 


! 1 ! 0 ! 1 ! 1 ! T ! T ! T ! T ! 


TTTT = TYPE OF OPERATION 


OOOO = 
0001 = 
0010 = 
0100 = 
0101 = 
0110 = 
0111 = 
1000 = 

1001 = 

1010 = 

1011 


UNCONDITIONAL JUMP, 2 BYTE 
UNCONDITIONAL JUMP, 3 BYTE 
UNCONDITIONAL JUMP, 4 BYTE 
FALSE JUMP, 2 BYTE ADDRESS 
FALSE JUMP, 3 BYTE ADDRESS 
FALSE JUMP, 4 BYTE ADDRESS 
(RESERVED) 


ADDRESS FOLLOWS 
ADDRESS FOLLOWS 
ADDRESS FOLLOWS 
FOLLOWS 
FOLLOWS 
FOLLOWS 


CASE JUMP, 2 BYTE ADDR OF CASE TABLE FOLLOWS 


TOS IS INDEX 


CASE JUMP, 3 BYTE ADDR OF CASE TABLE FOLLOWS 
TOS IS INDEX 


CASE JUMP, 4 BYTE ADDR OF CASE TABLE FOLLOWS 
TOS IS INDEX 


1111 = (RESERVED) 


46 





OPCODE CLASS: 


MOVES 


FORMAT: 


* 1 ! 1 ! 0 ! 0 ! D • I • T ! T ! 


D = DIRECTION 

0 = LEFT TO RIGHT 
1 = RIGHT TO LEFT 


I = INDIRECTION TYPE 

0 = TOS, NOS = ADDRESSES 
1 = JOS = ADDRESS AND 4 BYTE ADDRESS 
FOLLOWS INST BYTE 


TT 

rs 

TYPE 

OF MOVE 

DO 

= 

MOVE 

BYTES 

01 


MOVE 

2-BYTE WORDS 

10 

= 

MOVE 

4-BYTE WORDS 

11 

rr 

(RES! 

ERVED) 



47 





OPCODE CLASS: D 


Array Index, Bounds Checking 


FORMAT: 


!1!1!0!1!W!W! F!F! 


INDEX ARRAY, FF = DO 


WW = address width 

00 = (reserved) 

01 =2 bytes 
10 = 3 bytes 
11=4 bvtes 

Following the opcode is the size of an element of the array 
in bvtes. On the stack is the value of the current subscript 
on top of the base address of the array. 


CHECK BOUNDS, FF = 01 

WU1 = operand size (see above) 

Following the opcode is the lower bound followed bv the upper 
b o u n d. 


48 








E 


mi si: 




FORMAT: 



49 







50 






Pascal Emulator- OPCODE SUMMARY 


OPCODE 


MEANING 


LOAD LOCAL 
LL=OPERAND LENGTH 
WW=ADDR WIDTH 



LLWW 

00 

LDL.0,0 

01 

LDL,0,1 

02 

LDL.0,^ 

03 

LDL,0,3 

04 

LDL,1,0 

05 

LDL,1, 1 

06 

LDL,1,2 

07 

LDL,1,3 

08 

LDL,2,0 

09 

LDL,2,1 

OA 

LDL,2,2 

OB 

LDL,2,3 

oc 

LDL, N BYTES,0 

OD 

LDL,N BYTES,! 

OE 

LDL,N BYTES,2 

OF 

LDL,N BYTES,3 


LOAD INTERMEDIATE/GLOBAL 

LL= 10 LOAD N BYTES INDIRECT TO ADDR ON STACK 
LL= 11 LOAD N BYTES (OR ADDRESS) 

WW= OPERAND LENGTH 


10 

UNUSED 

11 

UNUSED 

12 

UNUSED 

13 

UNUSED 

14 

UNUSED 

15 

UNUSED 

16 

UNUSED 

17 

UNUSED 

18 

LIND, 0 

19 

LIND,1 

1A 

LIND,2 

IB 

LIND,3 

1C 

LINT,0 

ID 

LINT,1 

IE 

LINT,2 

IF 

LINT,3 


51 





STORE LOCAL 

LL= OPERAND LENGTH 

WW= ADDRESS WIDTH 



LLWW 

20 

STL,0,0 

21 

STL,0,1 

22 

STL,0,2 

2;”; 

STL,0,3 

24 

STL,1,0 

25 

STL,1,1 

26 

STL,1,2 

27 

STL,1,3 

2l-i 

STL,2,0 

29 

STL,2,1 

2 A 

STL,2,2 

2B 

STL,2,3 

2C 

STL, N BYTES,0 

2D 

STL, N BYTES, 1 

2E 

STL,N BYTES,2 

2F 

STL,N BYTES,3 


STORE INTERNEDIATE/GLOBAL 

LL= 10 STORE N BYTES INDIRECT TO ADDR ON STACK 
LL= 11 STORE N BYTES 

WW= OPERAND LENGTH 


30 

UNUSED 

31 

UNUSED 

32 

UNUSED 

;~;0 

UNUSED 

34 

UNUSED 

35 

UNUSED 

36 

UNUSED 

37 

UNUSED 

38 

SIND , 0 

39 

SIND,1 

3 A 

SIND,2 

3B 

SIND,3 

3C 

SINT , 0 

3D 

SINT,1 

3E 

SINT,2 

3F 

SINT,3 



i n cn «n »n cn cn cn cn cn cn cn cn cn cn ui cn a ^ •£> •£» •£> •£■ -&> •£■ -£» -t* •£■ 

"Ti m o o td d *o co »> cn co ro o >-» ti m n o co id *-o co «> cn •£« co fo 


ADD SUBTRACT,MULT IPLY 


40 

41 


VIDE AND MOD 


2 

BYTE 

DIV 

SIGNED 

2 

BYTE 

DIV 

UNSIGNED 


BYTE 

MOD 

SIGNED 

•-» 

BYTE 

MOD 

UNSIGNED 

4 

BYTE 

DIV 

SIGNED 

4 

BYTE 

DIV 

UNSIGNED 

4 

BYTE 

MOD 

SIGNED 

4 

BYTE 

MOD 

UNSIGNED 


UNUSED 

UNUSED 

UNUSED 

UNUSED 

REAL DIVIDE 

UNUSED 

UNUSED 

UNUSED 


2 BYTE ADD 

2 BYTE SUBTRACT 

2 BYTE SIGNED MULTIPLY 

2 BYTE UNSIGNED MULTIPLY 

4 BYTE ADD 

4 BYTE SUBTRACT 

4 BYTE SIGNED MULTIPLY 

4 BYTE UNSIGNED MULTIPLY 

UNUSED 

UNUSED 

UNUSED 

UNUSED 

REAL ADD 

REAL SUBTRACT 

REAL MULTIPLY (SIGNED) 

UNUSED 




SET OPERATIONS 


60 

SET UNION 

61 

SET INTERSECTION 

62 

SET DIFFERENCE 

63 

UNUSED 

64 

SET INCLUSION 

65 

UNUSED 

66 

UNUSED 

67 

UNUSED 

63 

UNUSED 

69 

UNUSED 

6 A 

UNUSED 

6B 

UNUSED 

6C 

UNUSED 

6D 

UNUSED 

6E 

UNUSED 

6F 

UNUSED 

COMPARE 

OPERATIONS 

70 

EQUAL 

71 

NOT EQUAL 

72 

GREATER THAN 

73 

LESS THAN 

74 

GREATER THAN OR EQUAL 

75 

LESS THAN OR EQUAL 

76 

UNUSED 

77 

UNUSED 

78 

UNUSED 

79 

UNUSED 

7A 

UNUSED 

7B 

UNUSED 

7C 

UNUSED 

7D 

UNUSED 

7E 

UNUSED 

7F 

UNUSED 




PROCEDURE CALL/RETURN 


SO 

RET FROM PROC 



81 

RET FUNC,SIZE=2 



09 

RET FUNC,SIZE=4 



ft 3 

RET FUNC,SIZE=REAL 



84 

CALL, NO FARMS, NO LOCALS, 

ADDR = 2 

BYTE 

85 

CALL, NO FARMS, NO LOCALS, 

ADDR « 3 

BYTE 

86 

CALL, NO FARMS, NO LOCALS, 

ADDR = 4 

BYTE 

87 

CALL, SIZE=2 BYTES, ADDR = 

2 BYTES 


yy 

CALL, SIZE=2 BYTES, ADDR = 

3 BYTES 


89 

CALL, SIZE=3 BYTES, ADDR = 

3 BYTES 


8 A 

CALL, SIZE=4 BYTES, ADDR = 

4 BYTES 


8 B 

UNUSED 



sc 

UNUSED 



8 D 

UNUSED 



8 E 

UNUSED 



8 F 

CALL, ALT INST. SET, ADRR= 

4 BYTES 



LOAD CONSTANT 


90 

1 BYTE 

91 

2 BYTE 

92 

3 BYTE 

93 

4 BYTE 

94 

REAL 

95 

STRING 

96 

SET CONTSTANT (16 BYTES) 

97 

UNUSED 

98 

UNUSED 

99 

UNUSED 

9 A 

UNUSED 

9B 

UNUSED 

9C 

UNUSED 

9D 

UNUSED 

9E 

UNUSED 

9F 

UNUSED 






®O3TOOTC0®tDrEroTOro03tDt0®ffi •- 3>1>3>I>3>3>3>I>I>X>1>I>1>3>3>3> 

-r-i m i — t , t-rs -w ,v. ^ i .• n i* *i k \ i — -n m r—i . —i m ts •.."i .Vi vi i'll N. k •« ^ 


BIT OPERATIONS 


2 

BYTE 

AND 

4 

BYTE 

AND 

2 

BYTE 

OR 

4 

BYTE 

OR 

2 

BYTE 

NOT 

4 

BYTE 

NOT 

2 

BYTE 

XOR 

4 

BYTE 

XOR 

2 

BYTE 

TSTBIT 

4 

BYTE 

TSTBIT 

2 

BYTE 

SETSIT 

4 

BYTE 

SETBIT 

9 

BYTE 

CLRBIT 

4 

BYTE 

CLRBIT 


EXTENDED OPERATIONS (SEE DOCUMENT) 
UNUSED 


MP INSTRUCTIONS 


UNCONDITIONAL JMP, 2 BYTE ADDR 
UNCONDITIONAL JMP, 3 BYTE ADDR 
UNCONDITIONAL JMP, 4 BYTE ADDR 
UNUSED 

FALSE «JMP 7 2 BYTE ADDR 
FALSE JMP 7 3 BYTE ADDR 
FALSE JMP 7 4 BYTE ADDR 
UNUSED 

CASE JMP 7 2 BYTE ADDR 

CASE JMP 7 3 BYTE ADDR 

CASE JMP 7 4 BYTE ADDR 

UNUSED 

UNUSED 

UNUSED 

UNUSED 

UNUSED 


56 




MOVE INSTRUCTIONS 


CO 

Cl 

C2 

C3 

C4 

C5 

C6 

C7 

CS 

C9 

CA 

CB 

CC 

CD 

CE 

CF 


MOVE LEFT,TOS,NOS,BYTES 
MOVE LEFT , TOS, NOS, 2 BYTE WORDS 
MOVE LEFT,TOS,NOS,4 BYTE WORDS 
UNUSED 

MOVE LEFT,TOS,INST,BYTES 
MOVE LEFT,TOS,INST,2 BYTE WORDS 
MOVE LEFT,TOS,INST,4 BYTE WORDS 
UNUSED 

MOVE RIGHT,TOS,NOS,BYTES 
MOVE RIGHT,TOS,NOS,2 BYTE WORDS 
MOVE RIGHT,TOS,NOS,4 BYTE WORDS 
UNUSED 

MOVE RIGHT,TOS,INST,BYTES 
MOVE RIGHT,TOS,INST,2 BYTE WORD 
MOVE RIGHT,TOS,INST,4 BYTE WORD 
UNUSED 


GROUP D ~ Ar rav I ridex, Check Bounds 


DO 


D1 

I ndex 

D2 

I ndex 

D3 

Index 

D4 


D5 

Range 

D6 

Range 

D7 

Range 

D8 


D9 


DA 


DB 


DC 


DD 


DE 


DF 



Offset 2 bvtes 
Offset 3 bvtes 
Offset 4 bvtes 

check. Offset 2 bvtes 
check. Offset 3 bv t e s 
check. Offset 4 bvtes 


57 


CO CO 



o 1 -* cj oi ^ iii >Li r^- co o- <r P3 o q ui u. cc o *-< in eo ^ in <> n oj o- <i oq o ui lu ll 

Ll! ixi LU UJ LU LU UJ Lti LU LU LU UJ UJ Lx.) Ixi UJ O LlU-IlU-LlLlL-U-LlLlU.0-IjlIJ-Ii.Ijl 


* 


GROUP E 


□UP F 


& 


- MISC#1 (UNASSIGNED) 


- MISC#2 (UNASSIGNED) 



58 





Z-Q 


Operating System Seguirements 


This section of this specification is designed to 
indicate the minimum operating system facilities necessary to 
compile a Pascal program* link a Pascal program* and to 
execute a Pascal program. 


Z-l Cameilen Besuinemenits 


The Atari Pascal compiler must he able to perform both 
forward and backward sequential disk I/O. Random accessing 
of files not required for compiler operation. Files being 
processed bv the compiler must be in the same character set 
which was used to compile the compiler. A minimum of 32K 
bytes of contiguous RAM memory is required for compiler 
operation (this is the current estimate 2/28/80). Additional 
memory will be used for buffering of the symbol table* 
tokenized text and object code (see section 4). 


59 



Linked Beauinements 


The Linker must be able to perform both forward and 
backward sequential disk I/O. In addition the linker mar 
need to perform random access disk I/O. Operation of the 
linker mill require a keyboard and display device- 


60 



to 




User: Eroanam Be3uieeiiien.ts 


requirements for a user program will vary widelv 
upon the features of Pascal used within the user**‘s 
If the user does not use disk I/O then the program 
will be able to run entirely without a disk. The operating 
system must be able to support sequential forward* sequential 
backward and random access disk I/O in order for GET* PUT and 
SEEK to be implemented. In addition the operating system 
must be able to support opening of named files to support the 
file name parameter on the RESET and REWRITE statements. 


2—3 

The 

dependins 
program. 


61 




* 


V % 







