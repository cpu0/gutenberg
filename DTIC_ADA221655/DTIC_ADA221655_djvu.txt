
ID 

LD 

CO 



Ada COMPILER 

VALIDATION SUMMARY REPORT: 
Certificate Number: S8ii21Al.iOOOj 
Alsys 

AlsyCOM?_003, Version 4.1 
Zenith 2-243 


Completion of On-Site Testing: 
21 November 1988 


Prepared By: 

AFNOR 

Tour Europe 
Cedex 7 

F-92030 Pans la Defense 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 



.■I 


A '"I 

Jiffrorrtd for public rahoMfl j 
Dlctr1ba4on UoHirlt*d 

. . ■ .i n . . ,11 


90 05 11 011 








DISClilMEt NOnCE 



THIS DOCUMENT IS BEST 
QUALITY AVAILABLE. THE COPY 
FURNISHED TO DTIC CONTAINED 
A SIGNfflCANT NUMBER OF 
PAGES WHICH DO NOT 
REPRODUCE LEGIBLY. 








MP', 


1 5 


1 1 : 


I I T RESEARCH I H 3 T 


p. ei 


, UNCLASSIFIED 


ci*S5iftc*Tio>i or This Mtt fm»>n o«n 


REPORT DOCUMENTATION PAGE 

stAfi sttrarmoss 
*tro»i coer.rtrri'; lOKv 

1. AtPOAl AUHStA It. WVT ACCtSSlM AO. 

i. AECIAUNT'S catalog NI/MSEA 

4. title (»>^iubvrir) 

Ada Compiler Validation Summary Report: ^isys 

MsyCOMP 003, Version 4.1, Zenith Z-248 (Host & Target), 
831121A1.10003 

5. type of tEPOAT 4 PEAIOO COVERED 

21 Nov. 1988 to 21 Nov. 1989 

4. PCRFOMING'QAC. report eoMBER 

7. authoa<i; 

AFNOR, Paris, France. 

1. contract or grant NumsERu; 

f . AtAfOtAIHG OAftAHlZATtON AAO AOCXESS 

AFNOR, Paris, France. 

10. program element, project, task 

ARLA 4 eUKN UNil ■i/"bEAS 

f 

n. COATKOLLIAG OFFICE SAME AND ApOAESS 

Ada Joint Program Office 

United States Department of Defense 

Washington, DC 20301-3081 

12. report date 

ig. ~ilwticR’'0T PAiti 

i4. AQAlTOAlbC ASEACT SAME « from Controlling Otfict) 

AFHOR, Paris, France. 

IS. security C'-ASS foFt/>(i^port) 
UNCLASSIFIED 

ISA. g^C^AS^^FICATION/OONKGRASING 

N/A 

te. OISTAISUTIOA STATEAENT (ofthofttpOft) 

Approved for public release; distribution unlimited. 

17. OISTRlIjTlOS STATEHthT (ofxhotbfitoct<tnttt*eiinBlo<k20 ifOiffrrtnt(romOtport) 

UKCLASSIFIED 

11. SUPP,EMEiiTARV notes 

18. IEyNOAOS (Continutonrt¥trftPOtiff>tt»Utfy»rH(i^rtlifybrblo<knumbor) 

Ada Programming language, Ada Compiler Validation Summary Report, Ada 
Compiler Validation Capability, ACVC, Validation Testing, Ada 

Validation Office, AVO, Ada Validation Facility, AVF, ANSI/MIL-STO' 

1815A, Ada Joint Program Office, AJPO 

to . AISTAAC T (Contmut on rtnorto Unntaorg on^i^ni'ft by biott nymoor) 

Alsys, AlsyCdMP 003, Version 4.1, Paris La Defense, Ze^ish Z-248 under MS/DOS, Version 

3-2 (Host & Target), ACVC I.IO. 


00 1473 loiTioM 0* 1 MOV •» IS otsoLiii 

14MII s/ll ow*-u»-*i4-Moi _UNCLASSIFIED 


IICUKITy CLASS! ric at ton Of this MCI 


—» • / 


' ’90 11:34 


PAGE.001 



















Ada Compiler Validation Summary Report: 

Compiler Name: AlsyCOMP_003, Version 4.1 
Certificate Number; 881121A1.10003 

Host: Zenith Z-248 under MS/DOS, Version 3.2 

Target: Zenith Z-248 under MS/DOS, Version 3.2 


Testing Completed 21 November 1988 Using ACVC 1.10 


This report has been reviewed and is approved. 


AFNOR 

Dr Jacqueline Sidi 
Tour Europe 
Cedex 7 

F-92080 Paris la Defense 





Ada Validation Organization 
Dr. John F. J(ramer 
Institute for Defense Analyses 
Alexandria VA 22311 



Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 


Accession For 


NTIS GRA&I 
DTIC TAB □ 

Unannounced □ 

Justification_ 


By—- 

DlUtrlbut1on/ 


Availability Codes 



{Avail and/or 
Spoolal 


2 












OFFICE OF THE DIRECTOR OF 
DEFENSE RESEARCH AND ENGINEERING 


WASHINGTON, DC 20301 


i r> npp 


MEMORANDUM FOR Director# Directorate of^atabase Services, 

Defense Logistics Agency 


\ 

\ 

: 2 — 


SUBJECT; Technology Screening of Unclassified/Unlimited Reports 

Your letter of *2 February 1990 to the Commander, Air Force' 
Systems Command, Air Force Aeronautical Laboratory, 
Wright-Patterson Air Force Base stated that the Ada Validation 
Summary report for Meridian Software Systems, Inc. contained 
technical data that should be denied public disclosure according to 
DoD Directive 5230.25 


We do not agree with this opinion that the contents of this 
particular Ada Validation Summary Report or the contents of the 
several hundred of such reports produced each year to document the 
conformity testing results of Ada compilers. Ada is not used 
exclusively for military applications. The language is an ANSI 
Military Standard, a Federal Information Processing Standard, and 
an International Standards Organization standard. Compilers are 
tested for conformity to the standard as the basis for obtaining an 
Ada Joint Program Office certificate of conformity. The results of 
this testing are documented in a standard form in all Ada 
Validation Summary Reports which the compiler vendor agrees to make 
^^ublic as part of his contract with the testing facility. 


On 18 December 1985, the Commerce Department issued Part / 
379 Technical Data of the Export Administration specifically 
listing Ada Programming Support Environments (including compilers) 
as items controlled by the Commerce Department, The AJPO complies 
with Department of Commerce export control' regulations. when 
Defense Technical Information Center receives an Ada Validation 
Summary Report, which may be produced by.-any of the five U.S. and 
European Ada Validation Facilities# the content should be made 
available to the public. 


If you have any further questions# please feel free to contact 
the undersigned at (202) 694-0209, 




John P. Solomond 
Director 

Ada Joint Program Office 










TABLE OF COi/TENTS 


CHAPTER i INTRODUCTION 


l.i PURPOSE OF THIS VALIDATION SUriEARY REPORT.5 

l.C USE OF THIS VALIDATION SUFHARY REPORT.5 

;.3 REFERENCES.6 

1.4 DEFINITION OF TERMS.6 

1.5 ACVC TEST CLASSES.7 


CHAPTER 2 CONFIGURATION INFORMATION 


2.1 CONFIGURATION TESTED. 9 

2.2 IMPLE.MENTATION CHARACTERISTICS.10 

CHAPTER 3 TEST INFORMATIOiN 

3.1 TEST RESULTS.15 

3.2 SUM.MARY OF TEST RESULTS BY CLASS.15 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.16 

3.4 WITHDRAWN TESTS.16 

3.5 INAPPLICABLE TESTS.16 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS.19 

3.7 ADDITIONAL TESTING INFORMATION.20 

3.7.1 Pravalidation . . ; . :.20 

3.7.2 Test Method.20 

3.7.3 Test Sice.21 


APPENDIX A DECLARATION OF CONFORMANCE 

APPENDIX B TEST PARAMETERS 

APPENDIX C WITHDRAWN TESTS 

APPENDIX D APPENDIX F OF THE Ada STANDARD 


3 




























INTRODUCTIOiT 


CHAPTER 1 
inTRODUCTIOM 


This Valication Su;amary Report (VSR) descnO'rs the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL- 
STD-18i5A. This report explains all technical terms used within it 
and thoroughly reports the results of testing this compiler using the 
Ada Compiler Validation Capability (ACVC). An Ada compiler must be 
implemented according to the Ada Standard, and any i-mplementation- 
dependent features must conform to the requirements of the Ada 
Standard. The Ada Standard must be implemented in its entirety, and 
nothing can be impleme.ated that is not in the Standard. 

Even though ail validated Ada compilers conform to the Ada Standard, 
It must be understood that some differences do exist between 
implementations. The Ada Standard permits some implementation 
dependencies — for example, the maximum length of identifiers or the 
maximum values of integer types. Other differences between compilers 
result from the characteristics of particular operating systems, 
hardware, or implementation strategies. All the dependencies observed 
during the process of testing this compiler are given in this report. 

The inforiiation in tnis report is derived from the test results 
produced during validation testing. The validation process includes 
submitting a suite of standardized tests, the ACVC, as inputs to an 
da compiler and evaluating the results. The purpose of validating is 
o ensure conformity of the compiler to the Ada Standard by testing 
that the compiler properly implements legal language constructs and 
that It identifies and rejects illegal language constructs. The 
testing also identifies behavior that is implementation-dependent but 
permitted by the Ada Standard. Six classes of tests are used. These 
tests are designed to perforin chec.ks at compile ti.me, at link time, 
and during execution. 


/ 



I 









IMTRODLICTION 


PURPOSi OF THIS VALIDATION SUXXARY REPORT 


7'iiis VSR docu-.-;nT.s r.ic- res’'l:3 of the validation t^rsting perforT.ed on 
an Ada compiler. Testing ^-fas carried out for the following purposes: 

To atteir.pt to identify any language constructs supported by 
the compiler that do not conform to the Ada Standard 

To attempt to identify any language constructs not supported 
by the compiler but reguired oy tne Ada Standard 

To determine that the implementation-dependent behavior is 
allowed by the Ada Standard 

Testing of this compiler was conducted by under the direction of the 
AVF according to procedures established oy the Ada Joint Program 
Office and administered by the Ada Validation Organization iAVO). 
On-site testing was completed 21 Movernber 1D33 at Alsys Inc. in 
waltham, USA. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO 
may maxe full and free public disclosure of this report. In the 
Un.tid States, this is provided in accordance with the "Freedom of 
Information Act"(5 U.S.C.#552). The results of this validation apply 
only to the computers, operating systems, and compiler versions 
identified in this report. 

The organizations represented on the signature page cif this report do 
not represent or warrant that all statements set forth in this report 
are accurate and complete, or that the subject compiler has no 
nonconformities to the Ada Standard other than those presented. 
Copies of this report are available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 

or from: 

AFNOR 

Tour Europe 
cedex 7 

F-92080 Pans la Defense 


5 








DITRODUCTION 


Questions regarding this report or the validation test results should 
be directed to the AVF listed above or to: 


Ada Validation Organization 
Institute for Defense Analyses 
1101 North Beauregard Street 
Ale.xandria VA 22311 


1.3 REFERENCES 


1. Reference Xan ual for the Ada Rr ogrartmin q Languag e,_,AM_S^';NILp 
STD-1815A, Feb ruary 1 983, a nd I S O 3 6 52 gl 987^. 

2. Ada C onpiler Va lid ation Pr ocedures an d Guidelines , Ada .J oint 
Rrocram Offic e, 1 January 19 87. 

3 . Ada Co.T.piler Val idation Caoa oi^ity I~pie xent e rs' Guide, 

SofTech, Inc., Decsr-ber 1986. 


1.4 DEFINITION OF TERMS 

ACVC The Ada Compiler Validation Capability. The set of 

Ada programs that tests the conf or;T.i cy of an Ada 
compiler to the Ada prograr..?.ing language. 

Ada Commentary An Ada Commentary contains all information relevant 
to the point addressed by a comment on the Ada 
Standard. These co-mments are given a unique 
identification number havinc the for.:. Al-ddddd. 


Ada Standard 


Aoolicant 


Compiler 


ANSI/MIL-STh-i815A, February 1933 and ISO 3652-1987. 
The agency requesting validation. 

The Ada Validation Facility. The AVF is responsible 
for conducting compiler validations according to 
procedures contained in the Ada Compiler Validation 
Procedures and Guidelines. 

The Ada Validation Organization. The AVO has 
oversight authority over all AVF practices for the 
purpose of maintaining a uniform process for 
validation of Ada compilers. The AVO provides 
administrative and technical support for Ada 
validations to ensure consistent practices. 

A processor for the Ada language. In the context of 
this report, a compiler is any language processor. 


6 














:n?RODUC7;ori 


;es: 


Hosr 


incluriing cross-co-.pi 1 r .'s . ■^asla cors, and 

interpreterj. 

An ACVC test for whicn 
result chat cieT.ons crates 
Standard. 

The corciputer on which the compiler resides. 


the co.-.piler generates a 
nonconf orcii ty to tne Ada 


Inapplicable 


test An ACVC test Chat uses features of the language 
that a co;r.piler is not required to support or may 
legitimately support in a way other than the one 
expected by the test. 


.^assed test 


An ACVC rest for which a cc.tpiler generates the 
expected result. 


Target 


The computer for which a compiler generates code. 


. S t- 


Withdrawn test 


A progra.m that chec.ts a compiler's con.for'.tity 
regarding a particular fe.at'.;rc or a co.7.bination of 
features to the Ada Standard. In the context of this 
report, the term is used to designate a single test, 
which may co.r.priSc one or more files. 

An ACVC test found to be incorrect and not used to 
check conformity to the Ada Standard. A test may be 
incorrect because it has an invalid test objective, 
fails to meet its test objective, or contains illegal, 
or erroneous use of the language. 


1.5 ACVC TEST CLASSES 

Confor.mity to the Ada Standard is measured using *he ACVC. The ACVC 
contains both legal and illegal Ada programs structured into six test 
classes; A, B, C, D, S, and L. The first letter of a test name 
Identifies the class to which it belongs. Class A, C, D, and E tests 
are executable, and special program units are used to report their 
results during execution. Class 3 tests are expected to produce 
compilation errors. Class L tests are expected to produce compilation 
or link errors. 

Class A tests check that legal Aca programs can be successfully 
compiled and executed. There are no explicit program components in a 
Class A test to check semantics. For example, a Class A test checks 
that reserved words of another language (other than those already 
reserved in the Ada language) are not treated as reserved words by an 
Ada compiler. A Class A test is passed if no errors are detected at 
compile time and the program executes to produce a .MASSED me’sage. 


7 




iriTRODL'CTION 


jS 3 rests rha: a .:o;r.prl'r 

*?.ss 3 'ests art no: e;\ = i''.',:iol-.. 3: 
and the -csulring ■: enr. 1 ar ion Its 
cc r y ” ic c__ j-‘_' z.r. 

:c:3: rs passed if ev-ry illegal 
Ccleered sy me coinpiiei. 


d-r_':'3 il_-.-c;:il language usage. 
.1 ■--s" in :l;is class is coupilad 
ng 15 exa.-.in'rd ro verify rhar 
. 1 - -S - ueiectcd. A e_ass 3 
construe: 'nar i" conrains is 


Class C rests caeca that l^gal Ada prograr.s can be correctly coroiled 
and executed. Each Class 1 t^sr is sel f-c.iccxir.g and produces a 
PASSED, EAIIED, or fiOT APPLICABLE rcrssauc indicating the result when 
It is executed. 


Class 3 tests check the compilation and execution capacities of a 
compiler. Since there are no capacity requirements placed on a 
:o~.piler by the Ada Standard for some param.eter3--for exa.mple, the 
nu.r,oer of identifiers permitted in a compilation or the number of 
units in a library---a compiler .may refuse to compile a Class j test 
and srill.be a confor.ming compiler. Therefore, if a Class D test 
fills to compile because tne capacity of the compiler is exceeded, 
the test IS classified as inapplicable. 1: a Class T test compiles 
successfully, it is self-checking and produces a PASSED or FAILED 
message during execution. 

Each Class E test is self-checking and produces a ”0T APPLICABLE, 
PASSED, or FAILED message when it is co.mpil.ac. and e.xccuted. However, 
the Ada Standard perm.its an imple.mentat ion to reject programs 
containing some features addressed by Class E tests during 
compilation. Therefore, a Class E test is pas3=c by a compiler if it 
13 oo.mpiled successfully and executes to produce a PASSED message, or 
i: i: 13 rejected by the compiler for an a.lowable reason. 

Class 1 tests check that inco.~;plete or illegal Ada programs involving 
multiple, S'-parately compiled uni's are detected and not allowed to 
execute. Class ^ tests are compiled separately and execution is 
attempted. A Class L test passes if it is rejected at lin.< time — that 
IS, an atte.mpt to execute the main program must generate an error 
message before any declarations in the main program or any units 
referenced by the main program are elaborated. 

Two library units, the package REPORT and the procedure CHECK_FILE, 
support the self-checking features of the executable tests. The 
package REPORT provides the mechanism by which executable tests 
report PASSED, FAILED, or NOT APPLICABLE results. It also provides a 
set of identity functions used to defeat some compiler optimizations 
allowed by the Ada Standard that would circumvent a test objective. 
The procedure CHECK_FILE is used to check the contents of text files 
written by some of the Class C tests for cnapter 14 of the Ada 
Standard. The operation of REPORT and CHECX_FILE is checked by a set 
of executable tests. These tests produce messages that are examined 


3 











:ri7RGot;c'::o:i 


"0 ''•■TCii'i that 
not jo^rattng 


the; units are operacinG ccrrectly, 
orr-rctly. then the validation is no 


f these units are 
at ter.pted. 


I'he teXt of the tests in the AC’tc follcv; oonventions mat are 
intended to ensure that the tests -are reasons ily portaole without 
aodif-cation. Tor exar.plc:, tne tests r.aee use of only the basic set 
of 55 cnaracters, contain lin-es wim ?. r.axir.uT. length of 72 
characters, use scall nurr.eric values, anc place features that r.ay not 
be supported by all inplenentations in separate tests. However, so.r.e 
tests contain values that require the test to be customized according 
"o implementation-specif 1 C values—for example, an illegal file name. 
.A list of the values used for this validation is provided in Appendix 


A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or oy showing that the test is 
inapplicable to the implementation. The applicability of a test to an 
i.'nple.me.ntation is considered each time the imple.mentation is 
validated. A test that is inapplicable for one validation is not 
necessarily inapplicable for a subsequent validation. Any test that 
was determined to contain an illegal language construct or an 
erroneous language construct is withdrawn from the ACVC and, 
therefore, is not used in testing a co.mpiler. The tests withdrawn at 
the time of this validation are given in Appendix D. 


9 







CONFIGURATION INFORMATION 


CHAPTER 


CONFIGURATION INFORMATION 


2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested unde: 
the following configuration: 

Compiler: AlsyCON?_003, Version 4.1 

ACVc'version: 1.10 

Certificate Number: 381121A1..0003 

Host Computer: • 

Machine: Zenith Z-243 

Operating System: MS/DOS 

Version 3.2 


Memory Size: 


640 K of main memory 
plus 5 Mb of extend memory 


Configuration information : 

30237 floating point co-processor 

40 Mb hard disk 

EGA color display and adapter 


Target Computer: 
Machine: 


Operating System: 

Memory Size: 


Zenith Z-248 

MS/DOS 
Version 3.2 

640 K of mam memory 
plus 5 .Mb of extend .memory 


Configuration information : 

80287 floating point co-processor 

40 Mb hard disk 

EGA color display and adapter 


Communicctions Network: 


none 


10 










CONr IGURATIOII 


INFORMATION 


2.2 INPLEM-NTATIOn CHARACTZRI3TICS 

One of the purposes of vaiidatinc compilers is to detarrr.ine the 
oehayior of a cortpiler in those areas of the Ada Standard that pertiit 
Implementations to differ. Class D and Z tests specifically check for 
such ir.plementation differences. However, tests in other classes also 
characterize an i-mplementation. The tests demonstrate the following 
characteristics; 

Capacities. 

The co-tipiler correctly processes a compilation containing 
723 variables in the same declarative part. (See test 
D29002K.) 

The corr.piler correctly processe a test containing loop 
statements nested to 65 levels. sSee tests D55A03A..H (8 
tests) .) 

The compiler correctly processes tests containing block 
statements nested to 65 levels. (See test D560013.) 

The compiler correctly processes tests containing recursive 
procedures- separately compiled as subunits nested to 17 
levels. (See tests D6‘;005E..G (3 tests).) 


Predefined types. 

This i.r.plementat ion supports the additional predefined 
types SKORT__iITEGSR, uONG^iN'TiGiR, .OiIG_FIjOAT in the 
package STANDARD. (See tests 8860017..Z (7 tests).) 


Based literals. 

An implementation is allowed raise NUNSRIC_ERROR or 
CONSTRAINT_ERROR when a value exceeds SYSTEM.MAX_INT . This 
implementation raises CONSTRAINT_ERROR during execution. 
(See test E24201A.) 


Expression evaluation. 

Apparently no default initialization expressions for rc..ord 
components are evaluated before any value is checked to 
belong to a component's subtype. (See test C32117A.) 

Assignments for subtypes are performed with the same 
precision as the base typ-'. (Si.e test C35712B.) 


11 









':oi;F:GURA'::or; infor>ia?ioI'I 


This isplemenration uses ao extra oits for extra precision. 
This ir.ple.Tienration uses aii -^xrra bits for extra range. 
iSee test C3 d9C3A.^ 

Apparently NUMERIC_ZRROR is raised wnen an integer literal 
operand in a comparison or .te-tbership tcSt is outside the 
range of the base type. (See test Ce5232A./ 

Apparently NU^!ZRIC_SRROH is raised i.'hen a literal operand 
in a fixed-point co.r.pari5on or ie.r.oership test is outside 
the range of the base type. (See test Ce5252A.) 

Apparently underflow is gradual. (See tests C4552AA..Z.) 


Rounding. 

The .method used for rounding to integer is apparently round 
to even. (See tests C46012A..Z.) 

The T.ethod used for rouncing to longest integer is 
apparently round to even. (See tests C460i2A..Z.) 

The method used for rounding to integer in static universal 
real expressions is apparently round to even. (See test 
C4A014A.) 


Array types. 

An inplementation is allowed to raise M'jy.ERIC_SRROR or 
COr’STRAINT_SRROR for an array having a ’LENGTH that exceeds 
STANDARD. INTEGER‘LAST and/or SYSTEM.HA:‘:_:NT. For this 
implementation: 

Declaration of an array type or subtype declaration with 
more than SYSTEM.MAX_INT components raises NUMER:C_ERR0R 
sometimes, CONSTRAIKT_SRROR sometimes. (See test C36003A.) 

CONSTRAINT_SRROR IS raised when 'LENGTH is applied to an 


array type with INTEGER'LAST + 2 

C36202A.) 

components. 

(See 

test 

CONSTRAINT_SRROR is raised when 

an array 

type 

with 

SYSTEM.MAX_INT + 2 components is 

C36202B.) 

declared. 

(See 

test 

A packed BOOLEAN array having 

a 'LENGTH 

exceeding 


INTEGER'LAST raises no exception. (See test C52103X.) 


12 









COi'J; :GURAT:0i7 :N?OR.‘''ATIOfr 


A packed two-dimensional BOOLSAW array wi:n ...ore than 
iriTZGSR 'lAST components raises COWSTRAI7T_2RROR when the 
l.ength of a dimension is caiculatec: and exceeds 
IMTSGER’LAST, array objects are sliced. (See test C52104Y.) 

A null array with one dimension of length greater than 
INTEGER'LAST may raise HUIiERIC_SRROR or CONSTRAINT _ERROR 
either when declared or assign-ed. A1 ternatimely, an 
implementation may accept the declaration. However, lengths 
must match in array slice assignments. This implementation 
raises no exception. (See test E52103Y.) 

In assigning one-di.mensional array types, the expression 
appears to be evaluated in its entirety before 
CONSTRAINT_ERROP. is raised' when checking whether the 
expression's subtype is co.mpatible with the target's 
subtype. (See test C52013A.) 

In assigning two-dimensional array types, the expression 
does not appear to be evaluated in its entirety before 
CONSTRAINT_ERROR is raised when checking whether the 
expression's suotype is co.T.?atiblc with the target's 
subtype. (See test C52013A.) 


Discriminated types. 

In assigning record types with discriminants, the 
expression appears to be evaluated in its entirety before 
CONSTRAINT_SRROR is raised when checking whether the 
expression's subtype is compatible with the target's 
subtype. (See test C520i3A.) 


Aggregates. 

In the evaluation of a .multi-di.mensional aggregate, all 
choices appear to be evaluated before checking against the 
index type. (See tests C43207A and C43207B.) 

In the evaluation of an aggregate containing subaggregates, 
not all choices are evaluated before being checked for 
identical bounds. (See test S43212B.) 

All choices are evaluated before CONST.RAINT_IRROR is raised 
if a bound in a non-null range of a non-null aggregate does 
not belong to an index subtype. (See test E43211B.) 


13 










cor.'FiGURATior/ ::tfor:-:at:on 



as. 


The prag:r.a INLINE is sujporicC for funcricns or procedures, 
ou* not functions called inside a package specification. 
(Sec tests _Aj00hA..3, iA3004u..D, and CA3004E..r-l 


Generics. 

Generic specifications and bodies can be compiled in 
separate compilations. (See tests CA1012A, CA2009C, 

CA2009?, BC3204C, and BC3205D.) 

Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3CI1A.) 

Generic subprogram declarations and bodies can be compiled 
in separate compilations. (See tests CA1012A and CA2009F.) 

Generic library subprogram specifications and bodies can be 
compiled in separate compilations. (See test CA1012A.) 

Generic non-library subprogram bodies can be compiled in 
separate compilations from tneir stubs. (See test CA2009F.) 

Generic package declarations and bodies can be compiled in 
separate compilations. (See tests CA2009C, 3C3204C, and 

BC3205D.) 

Generic library package specifications and bodies can be 
co.mpiled in separate compilations. (See tests 3C3204C and 
BC3205D.) 

Generic non-library package bodies as subunits can be 
compiled in separate compilations. (See test CA2009C.) 

Generic unit bodies and their subunits can be compiled in 
separate compilations. (See test CA3011A.) 


Input and output. 


The package 
unconstrained 
discri.minants 
EE2201D, and ZE 


SEQUENTIAL_IO can 
array types and 
without defaults. 

2 2 01S.) 


be instantiated with 
record types with 
(See tests Ar,210iC, 


The package DIRECT_IO can 
• unconstrained array types 


not be instantiated 
and record types 


with 

with 


14 







CONFIGURATIOr; INFORMATION 


discri.T.inants v/irhout defaulrs. (See tests AF2101H, 
r,ii240iD, and jiZ-±CxG.) 

Modes IN_FILF and OUT_FIIiZ are supported for SEQUZNTIAL_IO, 
but not CREATE in mode IN_FILE. (See tests CE2102D..E, 

CE2102N, and CS2102?.) 

Modes IN_FIIiE, OUT_FILE, and IIIOuT_FILE are supported for 
DIRSCT_IO, but not CREATE in T^ode IN_FIIjS. (See tests 
C32102F, CE2102I..J, CE2102R, CE2102T, and CE 2102 V.) 

Modes IM__FILE and 0UT_FI1.E are supported for text flies, 
bur not CREATE in mode IN_FILE. (See tests CE3102E and 

CE3102I..K.) 

RESET from OUT_FILS to IN_?ILE only and DELETE op^erations 
are supported for SEQUSNTIAL_IO. (See tests CE2102G and 

CE2102X.) 

RESET except from IN_FILE to INOUT_FILS or to OUT_FILS and 
DELETE operations are supported for DIRECT_IO. (See tests 
CE2102K and CE2102Y.) 

RESET and DELETE operations are supported for text files. 
(See tests CE3102F..G, CS3104C, CE3110A, and CE3114A.) 

Overwriting to a sequential file truncates to the last 
element written. (See test CE22083.) 

Temporary sequential files are given names and deleted 
when closed. (See test CS2108A.) 

Temporary direct files are given names and deleted when 
closed. (See test CE2108C.) 

Temporary text files are given names and deleted when 

closed. (See test CS3112A.} 

More than one internal file can be associated with each 

external file for sequential files when reading only (See 
tests CE2107A..E, CE2102L, CS2110S, and CE2111D.) 

More than one internal file can be associated with each 

external file for direct files when reading only (See tests 
CE2107F..I, CE2110D and CE2111K.) 

More than one internal file can be associated with each 

external file for text files when reading only. (See tests 
CS3111A..E, CE3114B, and CE3115A.) 


15 








::;?or:-!atioh 


CHAPTER 


rEST IHFORHATIO:? 


3.1 TEST RESULTS 

Version 1.10 of the ACVC coscprises 3717 tests. When this corr.piisr was 
tested, 36 tests had been withdrawn because of test errors. The AV7 
deternined that 376 tests were inapplicable to this iCiple-Tientation. 
All inapplicable tests were processed during validation testing 
except for 201 executable tests that use floating-point precision 
exceeding that supported by the insple.o.entation. .''locifications to the 
code, processing, or grading for 32 tests v?ere required to 
successfully demonstrate the test ob3ecti78. (See section 3.6.J 

The AV7 conduces that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 



T 

‘OTAL 


A B 

C D 

£ 

Li 


.Massed 

129 1132 

1?49 17 

32 

46 

3305 

Inapplicable 

0 6 

368 0 

a 

0 

376 

Withdrawn 

1 2 

33 0 

0 

0 

36 

TOTAL 

130 1140 

2350 17 

34 

46 

3717 


16 











TEST in?o?;’:ation 


3.3 SUMMARY 0? TEST RESULTS 3Y CHAPTER 


RESULT CHAPTER TOTA 




_3,. 


_5_ 

_6_ 

_7_ 

_,3_ 


_ 10 _ 

.11. 

_12. 

_13. 

_14_ 


Passed 

193 

577 

555 

248 

172 

99 

161 

3 32 

137 

36 

252 

257 

280 

3305 

Inappl 

14 

72 

125 

0 

0 

0 

5 

1 

0 

0 

0 

xlS 

41 

376 

Wdrn 

0 

- 

0 

0 

0 

0 

0 

- 

0 

0 

T. 

29 

4 

36 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 


The fol 
time of 

lowing 36 tests were 
this validation: 

withdrawn 

from ACVC 

Version 1 

.10 at the 

A39005G 

B97102E 

3C3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A . 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A33G 

CD2A84N 

CD2A84M 

CD50110 

CD2B15C 

CD7205C 

CD50073 

CD7105A 

CS34113 

CD72033 

CD72043 

CD7205D 

CS2107I 

CE3111C 

CS3301A 

See Appendix D for 

the reason 

that each 

of these 

tests was 

withdrawn. 


3.5 INAPPLICABLE TESTS 

Some rests do nor apply to all compilers because they make use of 
features that a compiler is not required by the Ada Standard to 
support. Others may depend on the result of another test that is 
either inapplicable or withdrawn. The applicability of a test to an 
implementation is considered each time a validation is attempted. A 
test that is inapplicable for one validation attempt is not 
necessarily inapplicable for a subsequent attempt. For this 
validation attempt, 376 tests were inapplicable for the reasons 
indicated; 

The following 201 tests are not applicable because they have 
floating-point type declarations requiring more digits than 
System.Max_Digits: 

C24113L..Y C35705L..Y C35706L..Y C35707L..Y C35708L..Y 
C35802L..Z C45241L..Y C45321L..Y C45421L..Y C45521L..Z 
C45524L..Z C45621L..Z C45641L..Y C46G12L..Z 


17 








INFORMATIOr 


C3 5702A --.nd 3860017 are no: applicable because 'his 
ir.pieffientation supports no predefined type Sl.or t_Floa:. 

C455 31"..? i4 tests) and C45'532M..? i,t= tests) are not app.icable 
oecause the value of SysteT..Max_)';antissa is less than 32. 

C36001F, IS not applicable because recompilation of Package 
SYS7E1! is not aiiovred. 

B86001.X, C45231D. ana CD7101G are not applicable because this 
implementation does not support any predefined integer type with 
a name other than Integer, Long_Integer, or Short_Integer. 

B86001Y is not applicable because this i-mplementation supports 
no predefined fixed-point type other than Duration. 

B8600iZ IS not applicable because this imple.mentation supports 
no predefined floating-point type with a name other than Float, 
Long_Float, or Short_Float. 

B91001H IS not applicable because address clause for entries is 
not supported by this implementation. 

CD1009C, CD2A41A..B, CD2A41E, CD2A-i2A..3, CD2A42E..F, CD2A42:..J 
are not applicable because size clause on float is not supported 
by this impleitentation. 

CD1C043, CD1C04S, CD4051A..D are not applicable because 
representation clause on derived records or derived tasits is not 
supported by this imple.ment--tion. 

CD1C03C, CD2A33A..C, CD2A33E, CD2A843..I, CD2A84X..1,, CDDBllB 
are not applicable because storage size clause on collection of 
unconstrained ob:ect is not supported. 

CD1C04A, CD2A21C..D, CD2A22C..D, CD2A22G..H, CD2A31C..D, 
CD2A32C..D, CD2A32G..H, CD2A41C..D, CD2A42C..D, CD2A42G..H, 
CD2A51C..D, CD2A52C..D, CD2A52G..H, CD2A53D, CD2A54D, 
CD2A54H are not applicable because size clause for derived 
private type is not supported by this implementation. 

CD2A61A..D,F,H,I,J,K,L, CD2A62A..C, CD2A71A..D, CD2A72A..D, 
CD2A74A..D, CD2A75A..D are not applicable because of the way 
this implementation allocates storage space for one component, 
size specification clause for an array type or for a record type 
requires compression of the storage space needed for all the 
components (without gaps). 

CD4041A is not applicable because alignment "at mod 8" is not 
supported by this implementation. 


18 







7SS7 


'ORXA7:ori 


'-D5003S IS not applicable because address clause for integer 
variable is not supported by this litpleinentation. 

BD5006D is not applicable because address clause for packages is 
not supported by this implementation. 

CD5011B,D,?,H,L,N,R, CD5012C , D, G, H, L,, CD50133, D, ?, H , L, M, R , 

CD5014LI,W are not applicable because address clause for a 
constant is not supported by this i.T.ple~entation. 

CD5013K IS not applicable because address clause for variables 
of a record type is not supported by this implementation. 

CD5012J, CD5013S, CD5014S are not applicable because address 

clause for a task is not supported by this implementation. 


CZ21023 13 

inapplicable 

because this i.mplementation 

supports 

create with 

out_file mode 

for SSQUEN7IA1_I0. 


CE2102? IS 

inapplicable 

because this i.mpler.entation 

supports 

create with 

inout_file mode for DIREC7_I0. 


CS2102J IS 

inapplicable 

because this implementation 

supports 

create with 

out_file mode 

for d:rsc7_:o. 


CE2102H is 

inapplicable 

because this implementation 

supports 

open with i 

n_file mode for 

SEQUEN7IAL_:0. 


Ci21020 IS 

inapplicable 

because this implementation 

supports 

RESE7 with 

in_file mode for SEQUSKTIAL_IO. 


CS2102P IS 

inapplicable 

because this implementation 

supports 

open with out_fiie mode for SEQ'JENTIAL_ro. 


CE2102Q IS 

inapplicable 

because this implementation 

supports 

RSSE7 with 

out_file mode for SSQUEN7IAL_I0. 


CS2102R IS 

inapplicable 

because this implementation 

supports 

open with inout_file mode 

for DIREC7_I0. 


CS2102S IS 

inapplicable 

because this implementation 

supports 

RESE7 with 

inout_file mode 

for DIREC7_I0. 


CE2102T IS 

inapplicable 

because this implementation 

supports 

open with in_file mode for 

DIREC7_:0. 


CE2102U IS 

inapplicable 

because this implementation 

supports 

RESET with 

in file mode fo 

■r DIREC7 10. 



19 










'SST ;m?or;;at:om 


CZ2-02’/ IS inaiDplica:>l<; because this i:.''.plc:T.entation supports 

open witn ou:_file rriode for DIRSCT_IO. 

CZ21C2'- rs liiapplicabla. because rhas implarienaarion supports 

RZ3ZT •■'.'itn ouc_file ;r.odc for DIRSCT_IO. 

CZ2105A IS not applicable because create with .rode in_file is 
not supported by this i.T.plemencation for 3ZQL’ZiITIAL_I0. 

CZ2105B IS inapplicable because CRZA7Z with IN_FILZ mode is not 
supported for direct access files. 

CZ21073..Z (4 tests), CZ2107L,, and CZ21103 are not applicable 

because multiple internal files cannot be associated with the 

same external file when one or sore files is writing for 
sequential files. The proper exception is raised when multiple 
access is attempted. 

CZ2107G..H (2 tests), CZ2110D, and CZ2111K are not applicable 

because multiple internal files cannot be associated with the 

same external file when one or sore files is writing for direct 
files. The proper exception is raised when .multiple access is 

attempted. 

CZ2111C,D are not applicable becaus 
out_file .mode for sequential files 
implementation. 

ZZ2401D and ZZ2401G are not appiicaile because 
raised when the create of an insta- 1 . • tt: i of 

with unconsti air,-4 is ca3)e4. 

CZ2401K is not applicable because create with inout_file mode 
for unconstrained records with default discriminants is not 
supported by this implementation. . 

CZ3i02F is inapplicable because this implementation supports 

reset for text files, for out_file, in_file and from out_file to 
in_file mode. 

CZ3102G is inapplicable because this implementation supports 

deletion of an external file for text files. 

CZ3102I IS inapplicable because this implementation supports 

create with out_file mode for text files. 

CZ3102J is inapplicable because this implementation supports 

open with in_file mode for text files. 


USZ.ZRROR IS 
DIRECT 20 


e rescting from in_file to 
IS .mot supported by this 


20 








TEST inrORMA^IOU 


-r^3i02K IS inapplicable because rbis irnple.Tenraiioa supporis 
open wi:a oiit_tile rsode for texr files. 

CE3109A is inapplicable oecause lex* file creaie with in_file 
;T!od6 IS not supported and raises U3E_ERR0R. 

CE31113, CZ31113..E (2 tests), CZ31143, and CE3115A are not 
applicable because multiple internal files cannot be associated 
with the same external file when one or .tore files is 'writing 
for text files. The proper exception is raised when multiple 
access is attempted. 

3.fi TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

It is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
.implementation oehavior. Modifications are made by the AV? in cases 
where legitimate implementation behavior prevents the successful 
completion of an (otherwise) applicable test. Examples of such 
.modifications include: adding a length clause to alter the default 
size of a collection; splitting a Class 3 test into subtests so that 
all errors are detected; and confirming that messages produced by an 
executable test demonstrate conforming behavior that wasn't 
anticipated by the test {such as raising one exception instead of 
another) . 

Modifications were required for tests. 

The test EA3004D when run as it is, the implementation fails to 
detect an error on line 27 of test fil= EA3004D6.'.’ (line 113 of "cat 
-n eaiOOld*"). This is because the pragma INLINE has no effect when 
Its object IS within a package specification. However, the results of 
running the test as it is does .not confirm that the prag.ma had no 
effect, only that the package was not .made obsolete. By re-ordering 
the compilations so that the two subprograms are compiled after file 
D5 (the re-compiiation of the "with"ed package that makes the various 
earlier units obsolete), we create a test that shows that indeed 

pragma INLINE has no effect when applied to a subprogram that is 

called within a package specification: the test then executes and 

produces the expected NOT_AP?LICABLS result (as though INLINE were 
.not supported at all) . The re-ordering of SA3004D test files is 

0-1-4-5-2-3-6. 


The following 30 tests were split because syntax errors at one point 
resulted in the compiler not detecting other errors in the test: 


323004A 

B24007A 

324009A 

B25002A 

B26005A 

B27005A 

328003A 

B32202A 

B32202B 

B32202C 

B33001A 

B36307A 

B37004A 

B49003A 

349005A 

B6i012A 

B62001B 

B74304B 

374304C 

374401F 

B74401R 

B91004A 

B95032A 

B95069A 

B95069B 

BA1101B2 

5A1101B4 

BC2001D 


2 








3C3009A 


3C3009C 3350053 


Th'r follo'winc 21 ^csts s;;!;.' m order to show that the cornoiler 

was al-il: to frr.c the represenratoon clause indicated by the comment 
--h'.'A =■■ ERROR ; 


cd:a6ia 

CDZAblB 

CD2A61F 

CD2A61I 

CD2A6iJ 

CD2A62A 

CD2A623 

CD2A71A 

CD2A713 

CD2A72A 

CD2A723 

CD2A73A 

CD2A753 

CD2A.S43 

L D n. O -T L 

CD2A84D 

CD2A84S 

CD2A84F 

CD2A3-G 

CD2A34H 

CD2AS4: 


3.7 ADDITIONAL TESTING INFOPMATION 
3.7.1 Rrcvaliuation 

Prior to validation, a set of test results for ACVC Version 1.10 
produced by the AlsyCOM?_003 was sunr.itCed to the AV7 by the 
applicant for review. Analysis of tnese results demonstrated that t.ne 
compiler successfully passed all applicable tests, and the co.T;piler 
e.KhiJited the e.xpected behavior on all inapplicaole tests. 


3.7.2 Test Method 

Testing of tite AisyCO;i?_OC3 using ACVC Version 1.10 was conducted 
tn-site by a validation team from the AVF. The conf igur a*‘ion 
consisted of 5 Zenith Z-24o operating under .IS/DOS, Version 3.2. 

A tape containing all tests was taken on-site by the validation team 
for processing. Tests that mase use of imple.mentaticn-specific values 
were customized by Alsys after loading of the tape. 

The contents of the tape were not loaded directly onto the host 
computer. They were loaded on a VAX/VMS machine and transferred via a 
network to the Zenith Z-243. This is the reason why prevalidation 
tests were used for the the validation. Those tests were loaded by 
Alsys from a magnetic tape containing ail tests provided by the AVF. 
Customiza: ion was done by Alsys. All the tests were checked at 
prevalidation time. 

Integrity of the validation tests was made by checking chat no 
modification of the test occured after the ti.me tne prevalidation 
results were transferred on disquetces for submission to tne AVF. 
This check was performed by verifying that the date of creation (or 
last modification) of the test files was earlier than the 
prevalidation date. After validation was performed, 30 source tests 
were selected by the AVF and checked for integrity. 


22 








The :.l 11 set: of ttrS's -es oo.epi, linetcc, eod 
ror. ein :ac Zenirfr Z-24S. Sesalts priiK 

acs: computer. 

The i:o;:.piler vas cescec I’.simg ce^r.r.aiid screprs p 
reVie»fed by "he validation tea.:;. The oo.TOiler : 
default option settinqs except for the following: 

OPTIOiJ / SWITCH EFFECT 

GEHERIC=ST"BS Code of generic instantiation 
units 

CAliIjS = IiWLIffE The pragma INLIi'-E are taken :nt 

Tests v^ere compiled, linked, and executed ms 
compi; ters. Test output, compilation listings, 
captured on ciscuettes and archived at the A’’?. 
on-site by the validation tea;?, were also arcni'V;C 


a.7,3 .cSt Site 

Testing was conducted a' Alsys, Inc. lu Waltham., 
or. 21 h'ovem.ber 1983. 


.1_r XvT'? U d aJD j. cf “trSiS 

ec fre.t the fro;, the 


rovid'^c ,ay Alsys .and 
MS tested using all 


IS placed in separate 


o account 

appropriate) using 2 
and job logs were 
■The listings exa.mined 


T3A and was completed 


3 






.CLARATIOI/ OF COr/FOR:''ArJC£ 


;IX 


OFOlARA'TIOri OF COilFORMAl.’C} 


Alsys has suhmi 
Conformancii 


tcci Che fo 
conc;:i ning 


lov/iag Oe-'.'.aracion of 
ch^ a:syco;;?_oo3 . 


24 







DECLARATION OF CONFORMANCE 


DECLARATION OF CONFORMANCE 
Compiler Implementor: Alsys 

Ada Validation Facility: AFNOR, Tour Europe Cedex 7, 

F-92080 Paris la Defense 

Ada Compiler Validation Capability (ACVC) Version: 1.10 

Base Configuration 


Base Compiler Name: 

AlsyCOMP_003 Version 

Host Architecture ISA: Zenith 

Z-248 


OS&VER It: 

MS/DOS, Version 

3.2 

Target Architecture ISA: 

Zenith Z-248 


OS&VER #: 

MS/DOS, Version 

3.2 


Implementor's Declaration 

I, the undersigned, representing Alsys, have implemented no deliberate 
extensions to the Ada Language Standard ANSI/MIL-STD-1815A in the 
compiler (s) listed in this declaration. I declare that Alsys is the 
owner of record of the Ada language compiler(s) listed above and, as 
such, is responsible for maintaining said compiler(s) in conformance 
to ANSI/MIL-STD-1815A. All certificates and registrations for Ada 
language compiler(s) listed in this declaration shall be made only in 
the owner's corporate name. 


‘ _ Date 

Alsys 

Mike Blanchette 

Vice President and Director of Engineering 








DECLARATION OF CONFORMANCE 


Owner's Declaration 

1, the undersigned, representing Alsys, take full responsibility for 
implementation and maintenance of the Ada compiler(s) listed above, 
and agree to the public disclosure of the final Validation Summary 
Report. I further agree to continue to comply with the Ada trademark 
policy, as defined by the Ada Joint Program Office. I declare that all 
of the Ada language compilers listed, and their host/target 
performance, are in compliance with the Ada Language Standard 
ANSI/MIL-STD-1815A. 


' ' • ■ _ Date 

Alsys 

Mike Blanchette 

Vice President and Director of Engineering 


P 








TEST PnRAEETZPS 


APPENDIX 3 
TEST PARAEET^ERS 


Ccrca.n tes:s in the ACVC nia;<c use of liT'.piei^.entation-dependent values, 
sucn as the .taximun .ength of an input line and invalid file nases. A 
test tnar ~!axes use of such values is identified by the extension -TST 
in Its file na:ie. Actual values to be substituted are represented by 
nar.es that bc.-gin with a dollar sign. A value rt.ust be substituted for 
each of these naiaes before the test is run. The values used for this 
validation are given below. 


ffarr,e and leaning Value 


3ACC_SIZE 32 

An integer literal whose value 
IS the number of bits sufficient 
to hold any value of an access 
type. 

3BIG_ID1 (25- * ’A’) i 

Identifier the size of the 
maximum input line length 
with varying last character. 

3a:G_ID2 (254 * 'Al i '2' 

Identifier t.ie size of the 
maximurr. input line length 
with varying last character. 

33IG_Ij 3 (126 " 'A') i '3' & (128 * 'A') 

Identifier the size of the 
maximum input line length 
with varying middle character. 

3BIG_ID4 (126 * 'A') & '4' & (12S * 'A') 

Identifier the size of the 
maximum input line length 
with varying middle character. 


27 









TEST ?AFA 


and lieaning Value 


33IG_Ii:T_'u:T (252 * ’C) & '293' 

An integer literal of value 
298 wirh enough leading zeroes 
so that It IS the size of the 
xaxi;-ug line length. 

3B:G_RE.AL_L:T (250 * 'O') & '690.0' 

A universal real literal of 
•’alue 690.0 with enough 
leading zeroes to be the size 
of the maxi.T.uni line length. 

33IG_STP.IIIG1 "" k (127 * 'A') & "" 

A string literal which when ^ 
catenated with BIG_STRIWG2 
yields the ixage of BIG_ID1. 

33:G_STR:NG2 & (127 * 'A') & "1"' 

A string literal which when 
catenated to the end of 
3IG_STRING1 yields the i.iiage 
of 3IG_ID1. 

33LANK3 (235 * ' ') 

A sequence of blanks twenty 
characters less than the size 
of the maximum line length. 

3C0UnT_LAST 214733647 

A universal integer literal whose 
value IS TEXT_I0.COUNT'LAST. 

SDEFAULT_XSH_SIZS 655360 

An integer literal whose value 
IS SYSTEM.MEMORY_SIZE. 

$DEFA'JLT_STOR_UNIT 8 • 

An integer literal whose value 
IS SYSTEM.STORAGE_UNIT. 

SDEFAULT_SYSJJAME I_80XS6 

The value of the constant 
SYSTEM.SYSTEMJIAME. 

SDELTA_DOC 2n.O#E-31 

A real literal whose value is 
SYSTEM.FINE DELTA. 


28 







PARA 


Uan.i and Meaning 


Valua 


$r xiijD ijrt^ . 05 

A universal integer literal whose 
va.ue IS ;i-aT _lO.jIiiuD unST. 

SFIXED_NAMZ ' H0_SUCH_F:XED_TY?S 

The nane of a predefined 
fixed-point type other tnan 
DURATION. 


3 FLOAT_NAHi MO _S UC H _TYP S 

The narie of a predefined 
floacing-point type other than 
FLOAT, SHORT_FLOAT, or 
LOMG_FLOAT. 

3GREATER_TKAN_DURATION 2_097 _151.999 _02 3_4 3 7 _51 

A universal real literal that 
lies between DURATION'BASE’LAS? 
and DURATION'LAST or any value 
in the range of DURATION. 

$GREATSR_THAN_DURATI0N_3ASE_LAST 3_000_000.0 
A universal real literal that is 
greater than DURATION'BASE’LAST. 


3h:gh_?riority lo 

An integer literal whose value 
is the upper bound of the range 
for the subtype SYSTEM.PRIORITY. 


sil:.egal_sxtsrnal_file_namei illegalx : $% ■ 4* V) / _+ 

An external file name which 
contains invalid characters. 


SILLEGAL_SXTERNAL_FILE_NAME2 !$%■&*()?/)(*&\!S% 

An external file name which 
is too long. 

SINTSGER_FIRST -32768 

A universal integer literal 
whose value is INTEGER'FIRST. 


$INTEGER_LAST 32767 

A universal integer literal 
whose value is INTEGER'LAST. 


29 










TEST PARAMETERS 


iJare and Meaning 


$:r/TEC.E?_LA3 
A universal 
whose value 

$LS3S_THA.'!_D:jRATIOr- 
A universal real literal that 
lies between DURATION'BASE’FIRST 
and DURATION'FIRST or any value 
in the range of DURATION. 

$LESS_THAN_DURATION_BASS_FIRST 
A universal real literal that is 
less than DURATION’BASE’FIRST. 



$LOW_?RIORITY 

An integer literal whose value 
is the lower bound of the range 
for the subtype SYSTEM.PRIORITY. 

Smamt:ssa_doc 

An integer literal whose value 
is SYSTEM.MAXJ-IANTISSA. 

$hax_dig:ts 

."a:<i.nu;n digits supported for 
floating-point types. 

$MAX_Iir_LEiN 

Maximum input line length 
per.aitted by the implementation. 

SMAX_IWT , 

A universal integer literal 
whose value is SYSTEM.MAX_IKT. 

SMAX_IIfT_?LUS_l 
A universal integer literal 
whose value is SYSTEM.MAX_:NT+1. 

$MAX_LEN_INT_BASED_LITERAL 
A universal integer based 
literal whose value is 2#11# 
with enough leading zeroes in 
the mantissa to be i'IAX_IN_LEN 
long. 


Value 


3276a 


-2 097 152.5 


-3000 000.0 


31 


255 


2147483647 


2147483648 


'42:’ & (250 * 'O') & 'll:' 


30 










TEST ?ARA:'ETE?.3 


’!a~c and Meaning 


SMAX _MTN_RZAL_3ASED_L.ITERAL 
A universal real based literal 
whose value is 16: F.E: with 
enough leading zeroes in the 
rr.antissa to be MAX_IN_LEN long. 

$XAX_STRr:;G_hITSRAL 
A string literal of size 
XAX_i;J_LZN, including the quote 
characters. 

3m:n_int 

A universal integer literal 
whose value is SYSTEM.Miri_inT. 

3XIN_TASK_SIZE 

An integer literal whose value 
is the nu.nber of bits required 
to hold a task ob]ect which has 
no entries, no declarations, and 
NULL;" as the only statement in 
Its body. 

S.NA.'.'E iTO_SUCH_TY?S 

A na;T.e of a predefined numeric 
type other than FLOAT, INTEGER, 

SHORT_FLOAT, SHORT_INTEGER, 

LONG_FLOAT, or LOWG_INTEGSR. 

$NAMS_LIST I_S0X36 

A list of enu.Tieration literals 
in the type SYSTEM.NAME, 
separated by co.minas. 

$NSG_BASED_INT 16#FFFFFFFE# 

A based integer literal whose 
highest order nonzero bit falls 
in the sign bit position of the 
representation for SYSTEM.MAX_INT. 

3NEW_MEM_SIZS 655360 

An integer literal whose value 
IS a permitted argument for 
pragma memory_size, other than 
DEFAULT_ME.M_SIZE. If there is 
no other value, then use 
DEFAULT MEM SIZE. 


Value 


■16:■ i (24d * 'O’ ) i 'F.E:' 


•i ',253 * ■ A' I (i 


-2147433613 


32 


31 














Value 


:sT ?ARAi: 


Har.e and 


'leaninc 


3i:iW_3TOR_’JNIT 

An integer literal whose value 
IS a permitted argument for 
pragma storage_unit, other than 
DS?AULT_3T0R_UNIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGE UNIT 


SNEW_SYS_NAMS I_80XS6 

A value of the type SYSTEM.MAME, 
other than SDE?AULT_SYS_NAME. If 
there is only one value of that 
type, then use that value. 

$TASK_S:ZE 32 

An integer literal whose value 
IS the numher of bits required 
to hold a task object which has 
a single entry with one inout 
parameter. 

STICK 1.0/18.2 

A real literal whose value is 
SYSTEM.TICK. 


TERS 


32 









Some r-is 
the Aaa 
rir^e ot 
the fom 

AJ9005G 

B97102E 


BC30093 


CD2A62D 


L -/ ** n C J rt . « 


CD2A31G, 


CD2B15C 


yiTKDRAVn TESTS 


VITHDRAWn 


:s are withdrawn froa the ACVC because they do not conform to 
Standera. The foiiowinc 36 tests had been withdrawn at the 
;alidation testing for the reasons indicated. A reference of 
Al-ddddd is to an Ada Coxaientary. 

This test unreasonably expects a component clause to 
pack an array component into a minimum size (line 30). 

This test contains an unitended illegality: a select 
statement contains a null statement at the place of a 
selective wait alternative (line 31). 

This test wrongly expects that circular instantiations 
will be detected in several compilation units even 
though none of the units is illegal with respect to the 
units It depends on; by AI-G0256, the illegality need 
not be< detected until execution is atte;r>?ted (line ?5). 

This test wrongly requires that an array object's size 
me no greater than 10 il'hough its subtype's size was 
specified to be 40 (line 137). 


D, •cJ4A66A..D. cD*.A 73A..D/ CD2A/6A..D .*6 testsj These tests 
wrongly attc:::pt to check the size of objects of a 
derivec. ;ype (for wnich a 'SIZE length clause is given) 
by passing them to a derived subprogram (which 
implicitly converts them to the parent type (Ada 
standard 3.4:14)). Additionally, they use the 'SIZE 
length clause and attribute, whose interpretation is 
considered problematic by the WG9 ARG. 


CD2A83G, CD2A84N & .w, & CD5011O These 
dependent tasks will terminate while 
executes a loop that simply tests for 
this IS not the case, and the main 
indefinitely (lines 74, 35, 86 4 96, 
resp .). 


tests assume that 
the main program 
task termination; 
program may loop 
36 & 96, and 58, 


& CD7205C These tests expect that a 'STORAGE_SIZE length 
clause provides precise control over the number of 
designated objects in a collection; the Ada standard 
13.2:15 allows that such control must not be expected. 


33 






WITHDRAWN TESTS 


CD50073 This test wrongly .ixpecis an ir.plici'ly declared 

subprocrar. to he at th~ address taat is sp^c.f.^d for an 
uniclated suoprogra.i ilip.e .' 03 ). 

CD7105A This test recv.ires that svurcessi •;= calls to 

CAhEIIDAR.CLOCK change by at least SYSTEM.TICK; nowever, 
by Coit.'r.entary AI-00201, it is only the e.xpected 
frequency of change that .tust be at least SYSTEM.TICK— 
particular instances of chance rr.ay oe less (line 20). 


CD72033, 


4c CD720^B These tests use the 'SIZE length clause and 
attribute, whose interpretation is considered 

proble;r.atic by the WG9 ARC. 


CD7105D 


This test checks an iir/alid test ob^aczive: it treats 
the specification of storage to be reserved for a task's 
activation as though it were like the specification of 
storage for a collection. 



This test requires that objects of two sicdlar scalar 
types be distinguished vrhen read fror. a file—DATA_ERR0?. 
13 e.xpected to be raised by an atte-tipt to read one 
object as of the other type. However, it is not clear 
exactly how the Ada standard 14.2.4:4 is to be 
interpreted; thus, this test objective is not considered 
valid. (line 90). 


CE3111C "his test requires certain behavior, wnen two files are 

associated with the sacte external file, that is not 
required by the Ada standard. 



This test contains several calls to EMj_0?_LI"E & 
END_0F_.=AGE that have no parameter: these calls were 

intended to specify a file, not ;o refer to 
STANDARD_INPUT (lines 103, 107, 118, 132, & 136). 


CS3411B This test requires that a text file's column number be 

set to COUNT'LAST in order to check that LAYOUT_ERROR is 
raised by a subsequent PUT operation. But the former 
operation will generally raise an exception due to a 
lack of available disk space, and the test would thus 
encumber validation testing. 


34 







A‘?I'D:X ? 0? THZ Ada STANDARD 


APPENDIX D 


AP-'SNDIX ? OF THZ Ada STANDARD 


The only allowed i-pl.-.-inenraricn dependencies correspond to 
i.~pieaenration-dependent pragmas, to certain ;'.achine-dependent 
conventions as mentioned in chapter 13 of the Ada Standard, and to 
certain allowed restrictions on representation clauses. The 
i.T,ple:tentation-dependenc characteristics of the AlsyCOX?_003, Version 
4.1, are described in the following sections, which discuss topics in 
Appendix F of the Ada Standard. Iiiplementation-specific portions of 
the package STANDARD are also included in this appendix. 


pac.tage STANDARD is 


type INTZGZR is range -j2_7C'3 .. j2_767 ; 
type SK0RT_INTZGZR is range -128 .. 127; 

type 10NG_INTZGZR is range -2_147_483_643 .. 2_147_433_647; 

type FLOAT is digits 6 range 
-2;#l.lll_lill_iill_iill_llll_lill#Z-127 

2#:.ii:_iiii_iii:_ii:i_iiii_iiii#!:-i27; 

type LCNG_FLOAT is digits 15 range 

- 2 n.iiiiliiii_iiii_iiii_iiii_iiii_iiii_i3:i_ii-i_iiii_ii-i_iiii_iiii#si023 

li_llll_ll'll_lill_llll#Z1023 ; 
. +’oq7i52.0; 

end STANDARD; 


type DURATION is delta 0.001 range -20'^"':52.0 . 


35 










Copyright 1988 by Alsys 


All rights reserved. No part of this document may be reproduced in 
any form or by any means without permission in writing from Alsys. 


Printed: November 1988 

Alsys reserves the right to make changes in specifications and other information 
contained in this publication without prior notice. Consult Alsys to determine whether 
such changes have been made. 


Ai«y«, AdsWorld Ad^rob*, Ad&Xraf, AdaRcformat, and AdaMaka an ncutend trademarka of Alayi. 
Microaoft, MS*DOS and MS an nciitarad trademarka of Microaoft Corporation. 

IBM, PC AT and PC-DOS are nciitarad trademarka of International Buainaaa Machinei Corporation. 
INTEL ia a ngiatarad trademark of Intel Corporation. 








TABLE OF CONTENTS 


APPENDIX F 


1 Implementation-Dependent Pragmas 

1.1 INLINE 

1.2 INTERFACE 

1.3 INTERFACE_NAME 

1.4 INDENT 

1.5 Other Pragmas 


2 Implementation-Dependent Attributes 

3 Specification of the package SYSTEM 

4 Restrictions on Representation Clauses 

4.1 Enumeration Types 

4.2 Integer Types 

4.3 Floating Point Types 

4.4 Fixed Point Types 

4.5 Access Types 

4.6 Task Types 

4.7 Array Types 

4.8 Record Types 

4.8.1 RECORD_SIZE 

4.8.2 VARIANT_INDEX 

4.8.3 ARRAY_DESCRIPTOR 

4.8.4 RECORD DESCRIPTOR 


5 Conventions for Implementation-Generated Names 

6 Address Clauses 

6.1 Address Clauses for Objects 

6.2 Address Clauses for Program Units 

6.3 Address Clauses for Entries 


Table of Contents 





7 Restrictions on Unchecked Conversions 30 


8 Input-Output Packages 30 

8.1 Correspondence between External Files and 286 DOS Files 30 

8.2 Error Handling 31 

8.3 The FORM Parameter 31 

8.4 Sequential Files 32 

8.5 Direct Files 32 

8.6 Text Files 32 

8.7 Access Protection of External Files 33 

8.8 The Need to Close a File Explicitly 33 

8.9 Limitation on the procedure RESET 33 

8.10 Sharing of External Files and Tasking Issues 34 


9 Characteristics of Numeric Types 34 

9.1 Integer Types 34 

9.2 Floating Point Type Attributes 34 

9.3 Attributes of Type DURATION 35 


10 Other Implementation-Dependent Characteristics 35 

10.1 Use of the Floating-Point Coprocessor (80287) 35 

10.2 Characteristics of the Heap 36 

10.3 Characteristics of Tasks 36 

10.4 Definition of a Main Subprogram 37 

10.5 Ordering of Compilation Units 37 


11 Limitations 37 

11.1 Compiler Limitations 37 

11.2 Hardware Related Limitations 37 


INDEX 39 


It 


Alsys 286 DOS Ada Compiler. Appendix F. Version 4.2 






APPENDIX F 


Implementation - Dependent Characteristics 


This appendix summarizes the implementation-dependent characteristics of the Alsys 286 
DOS Ada Compiler. This appendix is a required part of the Reference Manual for the 
Ada Programming Language (called the RM in this appendix). 

The sections of this appendix-are as follows: 

1. The form, allowed places, and effect of every implementation-dependent 
pragma. 

2. The name and the type of every implementation-dependent attribute. 

3. The specification of the package SYSTEM. 

4. The list of all restrictions on representation clauses. 

5. The conventions used for any implementation-generated name denoting im¬ 
plementation-dependent components. 

6. The interpretation of expressions that appear in address clauses, including 
those for interrupts. 

7. Any restrictions on unchecked conversions. 

8. Any implementation-dependent characteristics of the input-output packages. 

9. Characteristics of numeric types. 

10. Other implementation-dependent characteristics. 

11. Compiler limitations. 

The name Alsys Runtime Executive Programs or simply Runtime Executive refers to the 
runtime library routines provided for all Ada programs. These routines implement the 
Ada heap, exceptions, tasking control, and other utility functions. 

General systems programming notes are given in another document, the Application De¬ 
veloper's Guide (for example, pt'-ameter passing conventions needed for interface with 
assembly routines). 


Appendix F. Implementation-Dependent Characteristics 


I 








1 


Implementation-Dependent Pragmas 


l.I INLINE 


Pragma INLINE is fully supported; however, it is not possible to inline INLINE a 
subprogram in a declarative part. 

1.2 INTERFACE 

Ada programs can interface with subprograms written in Assembler and other languages 
through the use of the predefined pragma INTERFACE and the implementation-defined 
pragma INTERFACE_NAME. 

Pragma INTERFACE specifies the name of an interfaced subprogram and the name of 
the programming language for which parameter passing conventions will be generated. 
Pragma INTERFACE takes the form specified in the RM: 

pragma INTERFACE {language__name, subprogram_name)\ 

where, 

■ language_name is ASSEMBLER, ADA, or C. 

a sub program _name is the name used within the Ada program to refer to the 
interfaced subprogram. 

The only language names accepted by pragma INTERFACE are ASSEMBLER, ADA and 
C. The full implementation requirements for writing pragma INTERFACE subprograms 
are described in the Application Developer’s Guide. 

The language name used in the pragma INTERFACE does not have to have any re¬ 
lationship to the language actually used to write the interfaced subprogram. It is used 
only to tell the Compiler how to generate subprogram calls; that is, what kind of 
parameter passing techniques to use. The programmer can interface Ada programs with 
subroutines written in any other (compiled) language by understanding the mechanisms 
used for parameter passing by the Alsys 286 DOS Ada Compiler and the corresponding 
mechanisms of the chosen external language. 


1.3 INTERFACE_NAME 

Pragma INTERFACE_NAME associates the name of the interfaced subprogram with 
the external name of the interfaced subprogram. If pragma INTERFACE_NAME is not 
used, then the two names are assumed to be identical. This pragma takes the form: 

pragma INTERFACE_NAME {subprogram_name, siring_literal)'. 


2 


Alsys 286 DOS Ada Compiler. Appendix F. Version 4.2 




where, 

■ sub program _name is the name used within the Ada program to refer to the 
interfaced subprogram. 

■ string_Uteral is the name by which the interfaced subprogram is referred to 
at link time. 

The pragma INTERFACE_NAME is used to identify routines in other languages that 
are not named with legal Ada identifiers. Ada identifiers can only contain letters, dig¬ 
its, or underscores, whereas the DOS Linker allows external names to contain other 
characters, for example, the dollar sign ($) or commercial at sign {@). These characters 
can be specified in the string_Uteral argument of the pragma INTERFACE_NAME. 

The pragma INTERFACE_NAME is allowed at the same places of an Ada program as 
the pragma INTERFACE. (Location restrictions can be found in section 13.9 of the 
RA/.) However, the pragma INTERFaCE_NAME must always occur after the pragma 
INTERFACE declaration for the interfaced subprogram. 

The string_literal of the pragma lNTERi^ACE_NAME is passed through unchanged to 
the 286 DOS object file. The maximum length of the string_literal is 40 characters. 
This limit is not checked by the Compiler, but the string is truncated by the Binder to 
meet the Intel object module format standard. (For example, the IBM Macro 
Assembler limits external identifiers to 31 characters.) 

The Runtime Executive contains several external identifiers. All such identifiers begin 
with either the string "ADA<®" or the string "ADAS<S)". Accordingly, names prefixed by 
"ADA(®" or "ADAS<®* should be avoided by the user. 

Example 

package SAHPLE.DATA is 

function SAKPLE_DeviCE (X; IMTEGER) return IMTEGER; 
function PROCESS_SAMPLE (X: IMTEGER) return INTEGER; 
private 

pragma INTERFACE (ASSEMBLER, SAMPLE.OEVICE); 
pragma INTERFACE (AOA, PROCESS_SAMPLE); 
pragma IMTERFACE_MAME <SAMPLE_0EVICE, "OEVIO$CET_SAMPLE''); 
end SAMPLE_DATA; 

1.4 INDENT 

Pragma INDENT is only used with .iJuR?format. AdaReformat is the Alsys reformatter 
which offers the functionalities of a pretty-printer in an Ada environment. 

The pragma is placed in the source file and interpreted by the Reformatter. 

pragma INDENT(OFF); 

causes AdaReformat not to modify the source lines after this pragma. 


Appendix F. Implementation-Dependent Characteristics 


3 







pragma INDENT(ON); 


causes AdaReformat to resume its action after this pragma. 


1.5 Other Pragmas 

Pragmas IMPROVE and PACK are discussed in detail in the section on representation 
clauses and records (Chapter 5). 

Pragma PRIORITY is accepted with the range of priorities running from 1 to 10 (see the 
definition of the predefined package SYSTEM in Section 3). Undefined priority (no 
pragma PRIORITY) is treated as though it were less than any defined priority value. 

In addition to pragma SUPPRESS, it is possible to suppress all checks in a given compi¬ 
lation by the use of the Compiler option CHECKS. 

2 Implementation-Dependent Attributes 

P’IS_ARRAY For a prefix P that denotes any type or subtype, this at¬ 

tribute yields the value TRUE if P in an array type or 
an array subtype; otherwise, it yields the value FALSE. 

P’RECORD_DESCRIPTOR These attributes are used to control the representa 
P’ARRAY_DESCRIPTOR tion of implicit components of a record, see section 

4.8 


3 Specification of the package SYSTEM 

Th^_im^ementation dos not allow the recompilation of package 


package SYSTEM is 

♦ (1) Required Definitions. • 


type NAME is (1^80x86); 

SYSTEM_HAME : constant NAME I_80x86; 

STORAGE_UMIT ; constant :» 8; 
MEMC«Y_SIZE : constant :» 640 • 1024; 

-- System-Dependent Named Nuikjers: 

MIN_INT : constant :» -(2 ••31); 

MAX_INT : constant 2^^31 - 1; 


A/sys 286 DOS Ada Compiler, Appendix F. Version 4.2 








HAX_0IG1TS 
HAX_HANT1SSA 
FINE DELTA 


constant :■ IS; 
constant 31; 
constant :» 2#1.0#E-31; 


Appendix F, Implementcaion-Dependent Characteristics 


5 






-- For the high-resolution timer, the clock resolution is 
-- 1.0 / 1024.0. 

TICK : constant :■ 1.0 / 18.2; 

-- Other System-Dependent Declarations: 

subtype PHlORlTy is INTEG6* range 1 .. 10; 

-- The type ADDRESS is, in fact, irtplemented as a 
-- segment:offset pair. 

type ADDRESS is private; 

NULL_ADORESS: constant ADDRESS null; 


***«**«**«****«*««*«*••**•*•**** 

• (2) MACHINE TYPE CONVERSIONS * 

•«»*«*•«*•***«•*•«•*«**»******** 


-- If the tMrd / double-word operations below are used on 
-- ADDRESS, then HSU yields the segment and LSU yields the 
-- offset. 

-• In the operations below, a BYT£_TYPE is any sinple type 
-- impleeiented on 8-bits (for exanple, SHORT_INTEGER), a U0RD_TYPE is 
-- any simple type impleeiented on 16-bits (for exanple, INTEGER), and 
-• a OOU8LE_UORO_TYPE is any simple type implemented on 
-• 32-bits (for example. LONGJNTEGER, FLOAT, ADDRESS). 

-- Byte <»=> Word conversions; 

-• Get the most significant byte: 
generic 

type BTTE_TTPE is private; 
type U0R0_TYPE is private; 
function MSB (U; W0R0_TYPE) return BYTEJYPE; 

-- Get the least significant byte: 
generic 

type BYTE_TYPE is private; 
type W0«D_TYPE is private; 
function LSB (U; W0R0_TYPE) return BYTE_TYPE; 

-- Compose a word from two bytes: 
generic 

type BYTE_TYPE is private; 
type U0R0_TYPE is private; 

function WORD (MSB, LSB: BYTE_yyPE) return WOR0_TYPE; 


6 


Alsys 286 DOS Ada Compiler, Appendix F, Version 4.2 









-- Word <»=> Double-Uord conversions: 

-- Get the most significant %K>rd: 
generic 

type U0«0_TYPE is private; 
type 00UBLE_U0lt0_TYPE is private; 

^'tvtion MSW <W: 00U8LE_U0R0_TYPE) return WORO_TYPE; 

-- Get the least significant word: 
generic 

type W0S0_TYPE is private; 
type OOU8LE_WORO_TYPE is private; 
function LSW<W; OOUBLE_UORD_TYPE) return WORD_TYPE; 

-- Compose a DATA double word from two words, 
generic 

type UQitO_TYPE is private; 

" The following type must be a data type 
<for example. LONG_I«TEGER): 
type 0ATA_0aiBLE_uai0 is private; 
function 0OUBLE_U0«0 (MSW, LSW; WORO_TYPE) 
return OATA_OOUBLE_UOfiO; 

■■ Compose a REFERENCE double word from two words, 
generic 

type U0R0_TYPE is private; 

•• The following type must be a reference type 
•• (for exasple, access or ADDRESS): 
type REF_OOUBLE_WORD is private; 
function REFERENCE (SEGNENT, OFFSET: UOROJYPE) 
return REF_OOUBLE_UORD; 


• (3) OPERATIONS OH ADDRESS * 

-■ You can get an address via 'ADDRESS attribute or by 
-- instantiating the function REFERENCE, above, with 
" appropriate types. 

-• Some addresses are used by the Compiler. For example, 

-- the display is located at the low end of the DS segment, 
-- and addresses SS:0 through SS:128 hold the task control 
-- block and other information. Writing into these areas 
*■ will have vipredictable results. 

-- Note that no operations are defined to get the values of 
-- the segment registers, but if it is necessary an 
-- interfaced function can be written. 


Appendix F, Implementation-Dependent Characteristics 


7 












generic 

type OBJECT is private; 

function FETCH_FROM_AODRESS (FROM: ADDRESS) return OBJECT; 
generic 

type OBJECT is private; 

procedure ASSIGN_TO_ADORESS (OBJ: OBJECT; TO: ADDRESS); 
private 


end SYSTEM; 

4 Restrictions on Representation Clauses 

This section explains how objects are represented and allocated by the Alsys 286 DOS 
Ada compiler and how it is possible to control this using representation clauses. 

The representation of an object is closely connected with its type. For this reason this 
section addresses successively the representation of enumeration, integer, floating point, 
fixed point, access, task, array and record types. For each class of type the 
representation of the corresponding objects is described. 

Except in the case of array and record types, the description for each class of type is 
independent of the others. To understand the representation of an array type it is 
necessary to understand first the representation of its components. The same rule applies 
to record types. 

Apart from implementation defined pragmas, Ada provides three means to control the 
size of objects: 

■ a (predefined) pragma PACK, applicable to array types 

■ a record representation clause 

■ a size specification 

For each class of types the effect of a size specification is described. Interference 
between size specifications, packing and record representation clauses is described under 
array and record types. 

Representation clauses on derived record, or derived tasks are not supported. 

Size representation clauses on types derived from private types are not supported when 
the derived type is declared outside the private part of the (iefining package. 




Alsys 286 DOS Ada Compiler, Appendix F. Version 4.2 











4.1 Enumeration Types 

Internal codes of enumeration literals 

When no enumeration representation clause applies to an enumeration type, the internal 
code associated with an enumeration literal is the position number of the enumeration 
literal. Then, for an enumeration type with n elements, the internal codes are the 
integers 0, 1, 2, , n-1. 

An enumeration representation clause can be provided to specify the value of each 
internal code as described in RM 13.3. The Alsys compiler fully implements enumeration 
representation clauses. 

As internal codes must be machine integers the internal codes provided by an 
enumeration representation clause must be in the range -2^^ .. 2^*-l. 


Encoding of enumeration values 

An enumeration value is always represented by its internal code in the program 
generated by the compiler. 


Minimum size of an enumeration subtype 

The minimum size of an enumeration subtype is the minimum number of bits that is 
necessary for representing the internal codes of the subtype values in normal binary 
form. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M 
are the values of the internal codes associated with the first and last enumeration values 
of the subtype, then its minimum size L is determined as follows. For m >* 0, L is the 
smallest positive integer such that M <* 2^-1. For m < 0, L is the smallest positive 
integer such that -2^'^ <=» m and M <» 2^*^-l. 

type COLOR is (GREEN. BLACK, WHITE, RED, BLUE, YELLOW); 

-- The minimum size of COLOR is 3 bits. 

subtype BLACK_AND_WHITE is COLOR range BLACK .. WHITE; 

-- The minimum size of BLACK_AND_WHITE is 2 bits. 

subtype BLACK_OR_WHITE Is BLACK_AND_WHITE range X .. X; 

-- Assuming that X is not static, the minimum size of BLACK_OR_WHITE is 
— 2 bits (the same as the minimum size of its type mark 
BLACK_AND_WHITE). 


Size of an enumeration subtype 

When no size specification is applied to an enumeration type or first named subtype, the 
objects of that type or first named subtype are represented as signed machine integers. 


Appendix F, Implementation-Dependent Characteristics 


9 




The machine provides 8, 16 and 32 bit integers, and the compiler selects automatically 
the smallest signed machine integer which can hold each of the internal codes of the 
enumeration type (or subtype). The size of the enumeration type and of any of its 
subtypes is thus 8, 16 or 32 bits. 

When a size specification is applied to an enumeration type, this enumeration type and 
each of its subtypes has the size specified by the length clause. The same rule applies to 
a first named subtype. The size specification must of course specify a value greater than 
or equal to the minimum size of the type or subtype to which it applies: 

type EXTENDED is 

( — The usual ASCII characters. 


NUL, 

SOH, 

STX, 

ETX, 

EOT, 

ENQ, 

ACK, 

BEL, 

BS, 

HT, 

LF, 

VT, 

FF, 

CR, 

SO, 

SI. 

DLE, 

DCl, 

DC2, 

DC3, 

DC4, 

NAK, 

SYN, 

ETB, 

CAN, 

EM, 

SUB, 

ESC, 

FS, 

GS, 

RS, 

US, 

1 1 

« 

• % 

in* 



’%’, 


y 

T. 


y 

•v. 

« * 

y y 

y y 
“ * 

y y 

• ♦ 


•O’, 

’T, 

'2\ 

’3’, 

’4’. 

’5’, 

’6’, 

’7’, 


’9', 

• » 

♦ y 


t y 
= . 


• y 


•A’, 


’C, 

’D’, 

’E\ 

’P, 

’G\ 

’H’, 

’r. 

T, 

•K’, 

’L\ 

’M\ 

’N’, 

’O’. 

•F, 

■Q’, 

•R*, 

•S’, 

’T, 

•U’, 

’V’, 

’W’. 

X’, 

•r. 

'T, 

T. 



♦ 

y y 

* 

y 

’a’. 

’b’. 

V, 

’d’. 

’e’. 

’f. 

’g’. 

’h’, 

•i’, 

’j*. 

’«C’, 

’1’, 

’m’. 

’n’, 

’o’, 

’P’, 

’q’, 

’r’. 

’s’. 

’t’, 

’u’. 

’v’. 

’w’. 



•a’. 




♦ 



-- Exte 

LEFT_ARROW, 

RIGHT_ARROW, 

UPPER_ARROW, 

LOWER_ARROW, 

UPPER_LEFT_CORNER, 

UPPER_RIGHT_CORNER, 

LOWER_RIGHT_CORNER, 

LOWER_LEFT_CORNER 

); 

for EXTENDED’SIZE use 8; 

-- The size of type EXTENDED will be one byte. Its objects will be represented 
-- as unsigned 8 bit integers. 

The Alsys compiler fully implements size specifications. Nevertheless, as enumeration 
values are coded using integers, the specified length cannot be greater than 32 bits. 


Size of the objects of an enumeration subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of an enumeration subtype has the same size as its subtype. 


10 


Alsys 286 DOS Ada Compiler. Appendix F. Version 4.2 





4.2 Integer Types 

Predefined integer types 

There are three predefined integer types in the Alsys implementation for 180x86 
machines; 

type SHORT_INTEGER is range -2**01 .. 2**01-\\ 

type INTEGER is range -2**15 .. 2** 15-1; 

type LONG_INTEGER is range -2**31 .. 2**31-1; 


Selection of the parent of an integer type 
An integer type declared by a declaration of the form: 
type T is range L .. R; 

is implicitly derived from a predefined integer type. The compiler automatically selects 
the predefined integer type whose range is the smallest that contains the values L to R 
inclusive. 


Encoding of integer values 

Binary code is used to represent integer values. Negative numbers are represented using 
two’s complement. 


Minimum size of an integer subtype 


The minimum size of an integer subtype is the minimum number of bits that is 
necessary for representing the internal codes of the subtype values in normal binary 
form. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, if m and M 
are the lower and upper bounds of the subtype, then its minimum size L is determined 
as follows. For m >« 0, L is the smallest positive integer such that M <= 2^-1. For 
m < 0, L is the smallest positive integer that -2^'^ <= m and M <= 2^*^-l. 


subtype S is INTEGER range 0 .. 7; 

-- The minimum size of S is 3 bits. 

subtype D is S range X .. Y; 

— Assuming that X and Y are not static, the minimum size of 
-- D is 3 bits (the same as the minimum size of its type mark S). 


Appendix F, Implementation-Dependent Characteristics 


ll 





Size of an integer subtype 

The sizes of the predefined integer types SHORT_INTBGER, INTEGER and 
LONG_INTEGER are respectively 8, 16 and 32 bits. 

When no size specification is applied to an integer type or to its first named subtype (if 
any), its size and the size of any of its subtypes is the size of the predefined type from 
which it derives, directly or indirectly. For example: 

type S is range 80 .. 100; 

— S is derived from SHORT_INTEGER, its size is 8 bits, 
type J is range 0 .. 255; 

-- J is derived from INTEGER, its size is 16 bits, 
type N is new J range 80 .. 100; 

-- N is indirectly derived from INTEGER, its size is 16 bits. 

When a size specification is applied to an integer type, this integer type and each of its 
subtypes has the size specified by the length clause. The same rule applies to a first 
named subtype. The size specification must of course specify a value greater than or 
equal to the minimum size of the type or subtype to which it applies: 

type S is range 80 .. 100; 
for S’SIZE use 32; 

-- S is derived from SHORT_lNTEGER, but its size is 32 bits 
-- because of the size specification. 

type J Is range 0 .. 255; 
for J’SIZE use 8; 

— J is derived from INTEGER, but its size is 8 bits because 
-- of the size specification. 

type N is new J range 80 .. 100; 

-- N is indirectly derived from INTEGER, but its size is 8 bits 
— because N inherits the size specification of J. 


Size of the objects of an integer subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of an integer subtype has the same size as its subtype. 

4.3 Floating Point Types 

Predefined floating point types 

There are two predefined floating point types in the Alsys implementation for 180x86 
machines: 


12 


Alsys 286 DOS Ada Compiler. Appendix F. Version 4.2 








type FLOAT is 

digits 6 range -(2.0 - 2.0**(-23))*2.0**127 .. (2.0 - 2.0**(-23))*2.0**l27; 
type LONG_FLOAT is 

digits 15 range -(2.0 - 2.0**(-51))*2.0**id23 .. (2.0 - 2.0**(-51))*2.0**1023; 


Selection of the parent of a floating point type 
A floating point type declared by a declaration of the form; 
type T is digits D [range L .. R]; 

is implicitly derived from a predefined floating point type. The compiler automatically 
selects the smallest predefined floating point type whose number of digits is greater than 
or equal to D and which contains the values L to R inclusive. 


Encoding of floating point values 

In the program generated by the compiler, floating point values are represented using 
the IEEE standard formats for single and double floats. 

The values of the predefined type FLOAT are represented using the single float format. 
The values of the predefined type LONG_FLOAT are represented using the double 
float format. The values of any other floating point type are represented in the same 
way as the values of the predefined type from which it derives, directly or indirectly. 


Minimum size of a floating point subtype 

The minimum size of a floating point subtype is 32 bits if its base type is FLOAT or a 
type derived from FLOAT; it is 64 bits if its base type is LONG_FLOAT or a type 
derived from LONG FLOAT.. 


Size of a floating point subtype 

The sizes of the predefined floating point types FLOAT and LONG_FLOAT are 
respectively 32 and 64 bits. 

The size of a floating point type and the size of any of its subtypes is the size of the 
predefined type from which it derives directly or indirectly. 

The only size that can be specified for a floating point type or first named subtype 
using a size specification is its usual size (32 or 64 bits). 


Size of the objects of a floating point subtype 

An object of a floating point subtype has the same size as its subtype. 


Appendix F. Implementation-Dependent Characteristics 


13 











4.4 Fixed Point Types 

Small of a fixed point type 

If no specification of small applies to a fixed point type, then the value of small is 
determined by the value of delta as defined by RM 3.5.9. 

A specification of small can be used to impose a value of small. The value of small is 
required to be a power of two. 


Predefined fixed point types 

To implement fixed point types, the Alsys compiler for 180x86 machines uses a set of 
anonymous predefined types of the form: 

type SHORT_FIXED is delta D range (-2.0**07-l)*S .. 2.0**07*S; 
for SHORT_FIXED'lU\LL use S; 

type FIXED is delta D range (-2.0**I5-1)*S .. 2.0**15*S; 

for f/A'£D’SMALL use S; 

type LONG_FIXED is delta D range (-2.0**31-1)*S .. 2.0**31*S; 
for LONG_FIXED'SMP<LL use S; 

where D is any real value and S any power of two less than or equal to D. 


Selection of the parent of a fixed point type 
A fixed point type declared by a declaration of the form: 

type T is delta D range L .. R; 
possibly with a small specification: 
for TSMALL use S; 

is implicitly derived from a predefined fixed point type. The compiler automatically 
selects the predefined fixed point type whose small and delta are the same as the small 
and delta of T and whose range is the shortest that includes the values L to R inclusive. 


Encoding of fixed point values 

In the program generated by the compiler, a safe value V of a fixed point subtype F is 
represented as the integer 

V / FBASE’SMALL 


14 


Alsys 286 DOS Ada Compiler. Appendix F, Version 4.2 






Minimum size of a fixed point subtype 

The minimum size of a fixed point subtype is the minimum number of binary digits that 
is necessary for representing the values of the range of the subtype using the small of 
the base type. 

For a static subtype, if it has a null range its minimum size is 1. Otherwise, s and S 
being the bounds of the subtype, if i and I are the integer representations of m and M, 
the smallest and the greatest model numbers of the base type such that s < m and M < S, 
then the minimum size L is determined as follows. For i >= 0, L is the smallest positive 
integer such that I <■ 2^-1. For i < 0, L is the smallest positive integer such that 
-2^'^ <- i and I <- 2^‘^-l. 


type F is delta 2.0 range 0.0 .. 500.0; 

-- The minimum size of F is 8 bits. 

subtype S is F delta 16.0 range 0.0 .. 250.0; 

— The minimum size of S is 7 bits. 

subtype D is S range X .. Y; 

-- Assuming that X and Y are not static, the minimum size of D is 7 bits 
-- (the same as the minimum size of its type mark S). 


Size of a fixed point subtype 

The sizes of the predefined fixed point types SHORT_FIXED, FIXED and 
LONC_FIXED are respectively 8, 16 and 32 bits. 

When no size specification is applied to a fixed point type or to its first named subtype, 
its size and the size of any of its subtypes is the size of the predefined type from which 
it derives directly or indirectly. For example: 

type S is delta 0.01 range 0.8 .. 1.0; 

— S is derived from an 8 bit predefined fixed type, its size is 8 bits, 
type F is delta 0.01 range 0.0 .. 2.0; 

— F is derived from a 16 bit predefined fixed type, its size is 16 bits, 
type N is new F range 0.8 .. 1.0; 

-- N is indirectly derived from a 16 bit predefined fixed type, its size is 16 bits. 

When a size specification is applied to a fixed point type, this fixed point type and each 
of its subtypes has the size specified by the length clause. The same rule applies to a 
first named subtype. The size specification must of course specify a value greater than 
or equal to the minimum size of the type or subtype to which it applies: 

type S is delta 0 01 range 0.8 .. 1.0; 
for S'SIZE use 32; 

-- S is derived from an 8 bit predefined fixed type, but its size is 32 bits 


Appendix F, Implementation-Dependent Characteristics 


15 









-- because of the size specification. 


type F is delta 0.01 range 0.0 .. 2.0; 
for FSIZE use 8; 

-- F is derived from a 16 bit predefined fixed type, but its size is 8 bits 
— because of the size specification. 

type N is new F range 0.8 .. 1.0; 

— N is indirectly derived from a 16 bit predefined fixed type, but its size is 
-- 8 bits because N inherits the size specification of F. 

The Alsys compiler fully implements size specifications. Nevertheless, as fixed point 
objects are represented using machine integers, the specified length cannot be greater 
than 32 bits. 


Size of the objects of a fixed point subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of a fixed point type has the same size as its subtype. 


4.5 Access Types 

Collection Size 

As described in RM 13.2, a specification of collection size can be provided in order to 
reserve storage space for the collection of an access type. 

When no STORAGE_SIZE specification applies to an access type, no storage space is 
reserved for its collection, and the value of the attribute STORAGE_SIZE is then 0. 

ST0RAGE_SIZE clause on collections of unconstrained objects is not supported by the 
implementation. 

The maximum size allowed for a collection is 64Xbytes. 


Encoding of access values. 

Access values are machine addresses. 


Minimum size of an access subtype 

The minimum size of an access subtype is 32 bits. 


Size of an access subtype 

The size of an access subtype is 32 bits, the same as its minimum size. 


16 


Alsys 286 DOS Ada Compiler, Appendix F. Version 4.2 









The only size that can be specified for an access type using a size specification is its 
usual size (32 bits). 


Size of an object of an access subtype 

An object of an access subtype has the same size as its subtype, thus an object of an 
access subtype is always 32 bits long. 

4.6 Task Types 

Storage for a task activation 

When no length clause is used to specify the storage space to be reserved for a task 
activation, the storage space indicated at bind time is used for this activation. 

As described in RM 13.2, a length clause can be used to specify the storage space for 
the activation of each of the tasks of a given type. In this case the value indicated at 
bind time is ignored for this task type, and the length clause is obeyed. 

It is not allowed to apply such a length clause to a derived type. The same storage space 
is reserved for the activation of a task of a derived type as for the activation of a task 
of the parent type. 


Encoding of task values 

Encoding of a task value is not described here. 


Minimum size of a task subtype 

The minimum size of a task subtype is 32 bits. 


Size of a task subtype 

The size of a task subtype is 32 bits, the same as its minimum size. 

A size specification has no effect on a task type. The only size that can be specified 
using such a length clause is its minimum size. 


Size of the objects of a task subtype 

An object of a task subtype has the same size as its subtype. Thus an object of a task 
subtype is always 32 bits long. 


Appendix F, Implementation-Dependent Characteristics 


17 







4.7 Array Types 

Layout of an array 

Each array is allocated in a contiguous area of storage units. All the components have 
the same size. A gap may exist between two consecutive components (and after the last 
one). All the gaps have the same size. 



■SSS^iSSifStiii 





Component 

Gap 

Component 

Gap 

Component 

Gap 


Components 

If the array is not packed, the size of the components is the size of the subtype of the 
components: 

type A is array (1 ..8) of BOOLEAN; 

-- The size of the components of A is the size of the type BOOLEAN: 8 bits. 

type DECIMAL_DIGIT is range 0 .. 9; 
for DECIMAL_DIGITSIZE use 4; 
type BINARY_CODED_DECIMAL is 

array (INTEGER range <>) of DECIMAL_D1GIT; 

-- The size of the type DECIMAL_DIGIT is 4 bits. Thus in an array of 
-- type BINARY_C0DED_DECIMAL each component will be represented on 

— 4 bits as in the usual BCD representation. 

If the array is packed and its components are neither records nor arrays, the size of the 
components is the minimum size of the subtype of the components: 

type A is array (1 ..8) of BOOLEAN; 
pragma PACK(A); 

— The size of the components of A is the minimum size of the type BOOLEAN; 

— 1 bit. 

type DECIMAL_DIGIT is range 0 .. 9; 
for DECIMAL_DIGITSIZE use 32; 
type BINARY_CODED_DECIMAL is 

array (INTEGER range <>) of DECIMAL_DIGIT; 
pragma PACK(BINARY_CODED_DECIMAL); 

— The size of the type DECIMAL_DIGIT is 32 bits, but, as 
-- BINARY_C0DED_DECIMAL is packed, each component of an array of this 

— type will be represented on 4 bits as in the usual BCD representation. 

Packing the array has no effect on the size of the components when the components are 
records or arrays. 


18 


Alsys 286 DOS Ada Compiler, Appendix F. Version 4.2 











Gaps 

If the components are records or arrays, no size specification applies to the subtype of 
the components and the array is not packed, then the compiler may choose a 
representation with a gap after each component; the aim of the insertion of such gaps is 
to optimize access to the array components and to their subcomponents. The size of the 
gap is chosen so that the relative displacement of consecutive components is a multiple 
of the alignment of the subtype of the components. This strategy allows each component 
and subcomponent to have an address consistent with the alignment of its subtype: 

type R is 
record 

K : INTEGER; — INTEGER is even byte aligned. 

B : BOOLEAN; — BOOLEAN is byte aligned, 
end record; 

-- Record type R is even byte aligned. Its size is 24 bits, 
type A is array (1 .. 10) of R; 

-- A gap of one byte is inserted after each component in order to respect the 
— alignment of type R. The size of an array of type A will be 320 bits. 



R55K51 







B 


K 

a 


m 

i 

■ 










Conponent Gap Conponent Gap Conponent Gap 

Array of type A: each subcomponent K has an even offset. 


If a size specification applies to the subtype of the components or if the array is packed, 
no gaps are inserted: 

type R is 
record 

K : INTEGER; 

B : BOOLEAN; 
end record; 

type A is array (1 .. 10) of R; 
pragma PACK(A); 

-- There is no gap in an array of type A because 
-- A is packed. 

-- The size of an object of type A will be 240 bits. 

type NR is new R; 
for NR’SIZE use 24; 

type B is array (1 .. 10) of NR; 

-- There is no gap in an array of type B because 


Appendix F, fmpiementation-Dependent Characteristics 


19 
















— NR has a size specification. 

— The size of an object of type B will be 240 bits. 



Component Component 


Array of type A or B: a subcomponent K can have an odd offset. 


Size of an array subtype 

The size of an array subtype is obtained by multiplying the number of its components 
by the sum of the size of the components and the size of the gaps (if any). If the 
subtype is unconstrained, the maximum number of components is considered. 

The size of an array subtype cannot be computed at compile time 

■ if it has non-static constraints or is an unconstrained array type with non¬ 
static index subtypes (because the number of components can then only be 
determined at run time). 

• if the components are records or arrays and their constraints or the 
constraints of their subcomponents (if any) are not static (because the size of 
the components and the size of the gaps can then only be determined at run 
time). 

As has been indicated above, the effect of a pragma PACK on an array type is to 
suppress the gaps and to reduce the size of the components. The consequence of packing 
an array type is thus to reduce its size. 

If the components of an array are records or arrays and their constraints or the 
constraints of their subcomponents (if any) are not static, the compiler ignores any 
pragma PACK applied to the array type but issues a warning message. Apart from this 
limitation, array packing is fully implemented by the Alsys compiler. 

A size specification applied to an array type or first named subtype has no effect. The 
only size that can be specified using such a length clause is its usual size. Nevertheless, 
such a length clause can be useful to verify that the layout of an array is as expected by 
the application. 


Size of the objects of an array subtype 

The size of an object of an array subtype is always equal to the size of the subtype of 
the object. 


20 


Alsys 286 DOS Ada Compiler, Appendix F. Version 4.2 











4.8 Record Types 

Layout of a record 


Each record is allocated in a contiguous area of storage units. The size of a record 
component depends on its type. Gaps may exist between some components. 

The positions and the sizes of the components of a record type object can be controlled 
using a record representation clause as described in RM 13.4. In the Alsys 
implementation for 180x86 machines there is no restriction on the position that can be 
specified for a component of a record. If a component is not a record or an array, its 
size can be any size from the minimum size to the size of its subtype. If a component is 
a record or an array, its size must be the size of its subtype: 

type INTERRUPT_MASK is array (0 .. 2) of BOOLEAN; 

pragma PACK(INTERRUPT_MASK); 

— The size of INTERRUPT_MASK is 3 bits. 

type CONDITION_CODE is 0 .. 1; 

— The size of CONDITION_CODE is 8 bits, its minimum size is 1 bit. 

type STATUS_BIT is new BOOLEAN; 

for STATUS_BITSIZE use 1; 

— The size and the minimum size of STATUS_BIT are 1 bit. 

SYSTEM : constant := 0; 

USER : constant 1; 


type STATUS_REGISTER is 
record 


T 

; status BIT; 


— 

S : 

STATUS BIT; 


— 

I: 

INTERRUPT 

MASK; 

— 

X 

CONDITION 

CODE; 

— 

N 

condition' 

CODE; 

— 

Z 

condition' 

CODE; 

-- 

V 

condition' 

CODE; 


c 

condition' 

CODE; 

— 

end record; 



for STATUS 

REGISTER use 



record at mod 2; 



T 

at SYSTEM 

range 0 

.. 0; 

S 

at SYSTEM 

range 2 

.. 2 

I 

at SYSTEM 

range 5 

.. 7 

X 

at USER 

range 3 

.. 3 

N 

at USER 

range 4 

.. 4 

Z 

at USER 

range 5 

.. 5 

V 

at USER 

range 6 

.. 6 

c 

at USER 

range 7 

.. 7; 

end record; 




Zero 


— Carry 


Appendix F. Implementation-Dependent Characteristics 


21 









A record representation clause need not specify the position and the size for every 
component. 

Pragma PACK has no effect on records. 

If no component clause applies to a component of a record, its size is the size of its 
subtype. Its position is chosen by the compiler so as to optimize access to the 
components of the record; the offset of the component is chosen as a multiple of 8 bits 
if the objects of the component subtype are usually byte aligned, but a multiple of 16 
bits if these objects are usually even byte aligned. Moreover, the compiler chooses the 
position of the component so as to reduce the number of gaps and thus the size of the 
record objects. 

Because of these optimizations, there is no connection between the order of the 
components in a record type declaration and the positions chosen by the compiler for 
the components in a record object. 


Indirect components 

If the offset of a component cannot be computed at compile time, this offset is stored in 
the record objects at run time and used to access the component. Such a component is 
said to be indirect while other components are said to be direct 



Beginning of the record 
Conpile time offset 

Compile time offset 

Run time offset 


A direct and an indirect component 

If a record component is a record or an array, the size of its subtype may be evaluated 
at run time and may even depend on the discriminants of the record. We will call these 
components dynamic components; 


type DEVICE Is (SCREEN, PRINTER); 


22 


Alsys 286 DOS Ada Compiler. Appendix F. Version 4.2 





type COLOR is (GREEN, RED, BLUE); 

type SERIES is array (POSITIVE range <>) of INTEGER; 

type GRAPH (L : NATURAL) is 
record 

X : SERIES(i .. L); -- The size of X depends on L 
Y : SERIES(i .. L); — The size of Y depends on L 

end record; 

Q : POSITIVE; 

type PICTURE (N : NATURAL; D ; DEVICE) is 
record 

F : GRAPH(N); -- The size of F depends on N 
S : GRAPH(Q); -- The size of S depends on Q 
case D is 

when SCREEN -> 

C ; COLOR; 
when PRINTER -> 
null; 

end case; 
end record; 

Any component placed after a dynamic component has an offset which cannot be 
evaluated at compile time and is thus indirect. In order to minimize the number-of 
indirect components, the compiler groups the dynamic components together and places 
them at the end of the recor± 


D « SCREEN 0 S printer 

N » 2 N » 1 



Appendix F. Implementation-Dependent Characteristics 


23 











The record type PICTURE: F and S are placed at the end of the record 


Because of this approach, the only indirect components are dynamic components. But 
not all dynamic components are necessarily indirect: if there are dynamic components in 
a component list which is not followed by a variant part, then exactly one dynamic 
component of this list is a direct component because its offset can be computed at 
compilation time (the only dynamic components that are direct components are in this 
Ssituation): 


24 


Alsys 286 DOS Ada Compiler. Appendix F. Version 4.2 








Beginning of the record 
Coopile time offset 






L 




X 


Y 


■ Compile time offset 
Size dependent on discriminant L 
Run time offset 

Size dependent on discriminant L 


The record type GRAPH: the dynamic component X is a direct component. 


The offset of an indirect component is always expressed in storage urdts. 

The space reserved for the offset of an indirect component must be large enough to 
store the size of any value of the record type (the maximum potential offset). The 
compiler evaluates an upper bound MS of this size and treats an offset as a component 
having an anonymous integer type whose range is 0 .. MS. 

If C is the name of an indirect component, then the offset of this component can be 
denoted in a component clause by the implementation generated name COFFSET. 


Implicit components 

In some circumstances, access to an object of a record type or to its components involves 
computing information which only depends on the discriminant values. To avoid useless 
recomputation the compiler stores this information in the record objects, updates it 
when the values of the discriminants are modified and uses it when the objects or its 
components are accessed. This information is stored in special components called implicit 
components. 

An implicit component may contain information which is used when the record object 
or several of its components are accessed. In this case the component will be included in 
any record object (the implicit component is considered to be declared before any 
variant part in the record type declaration). There can be two components of this kind; 
one is called RECORD_SIZE and the other VARIANT_INDEX. 

On the other hand an implicit component may be used to access a given record 
component. In that case the implicit component exists whenever the record component 
exists (the implicit component is considered to be declared at the same place as the 
record component). Components of this kind are called ARRAY_DESCRIPTORs or 
RECORD DESCRIPTORS. 


Appendix F, Implementation-Dependent Characteristics 


25 









4.8.1 RECORD SIZE 


This implicit component is created by the compiler when the record type has a variant 
part and its discriminants are defaulted. It contains the size of the storage space 
necessary to store the current value of the record object (note that the storage 
effectively allocated for the record object may be more than this). 

The value of a RECORD_SIZE component may denote a number of bits or a number of 
storage units. In general it denotes a number of storage units, but if any component 
clause specifies that a component of the record type has an offset or a size which cannot 
be expressed using storage units, then the value designates a number of bits. 

The implicit component RECORD_SIZE must be large enough to store the maximum 
size of any value of the record type. The compiler evaluates an upper bound MS of this 
size and then considers the implicit component as having an anonymous integer type 
whose range is 0 .. MS. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R’RECORD_SIZE. 


4.8.2 VARIANT_INDEX 

This implicit component is created by the compiler when the record type has a variant 
part. It indicates the set of components that are present in a record value. It is used 
when a discriminant check is to be done. 

Component lists that do not contain a variant part are numbered. These numbers are the 
possible values of the implicit component VARIANT^INDEX. 

type VEHICLE is (AIRCRAFT, ROCKET, BOAT, CAR); 

type DESCRIPTION (KIND : VEHICLE := CAR) is 

record 

SPEED ; INTEGER; 
case KIND is 

when AIRCRAFT 1 CAR => 

WHEELS : INTEGER; 
case KIND is 

when AIRCRAFT => — 1 

WINGSPAN : INTEGER; 
when others => -- 2 

null; 

end case; 

when BOAT »> — 3 

STEAM : BOOLEAN; 
when ROCKET »> — 4 

STAGES : INTEGER; 

end case; 
end record; 


26 


Alsys 286 DOS Ada Compiler. Appendix F. Version- 4.2 









The value of the variant index indicates the set of components that are present in a 
record value: 


Variant Index 

Set 

1 

(KINO, SPEED, WHEELS, WINGSPAN) 

2 

(KINO, SPEED, WHEELS) 

3 

(KINO, SPEED, STEAM) 

4 

(KIND, SPEED, STAGES) 


A comparison between the variant index of a record value and the bounds of an interval 
is enough to check that a given component is present in the value: 


Cooponent 

Interval 

KINO 

.. 

SPEED 

-- 

WHEELS 

1 .. 2 

WINGSPAN 

1 .. 1 

STEAM 

3 .. 3 

STAGES 

4 .. 4 


The implicit component VARIANT_INDEX must be large enough to store the number 
V of component lists that don’t contain variant parts. The compiler treats this implicit 
component as having an anonymous integer type whose range is 1 .. V. 

If R is the name of the record type, this implicit component can be denoted in a 
component clause by the implementation generated name R’VARIANT_INDEX. 


4.8.3 ARRAYDESCRIPTOR 

An implicit component of this kind is associated by the compiler with each record 
component whose subtype is an anonymous array subtype that depends on a discriminant 
of the record. It contains information about the component subtype. 

The structure of an implicit component of kind ARRAY_DESCRIPTOR is not 

described in this documentation. Nevertheless, if a programmer is interested in 

specifying the location of a component of this kind using a component clause, he can 

obtain the size of the component using the ASSEMBLY parameter in the COMPILE 
command. 

The compiler treats an implicit component of the kind ARRAY_DESCRIPTOR as 
having an anonymous array type. If C is the name of the record component whose 
subtype is described by the array descriptor, then this implicit component can be 
denoted in a component clause by the implementation generated name 

C’ARRAY DESCRIPTOR. 


Appendix F. Implementation-Dependent Characteristics 


27 













4.8.4 RECORD DESCRIPTOR 


An implicit component of this kind is associated by the compiler with each record 
component whose subtype is an anonymous record subtype that depends on a 
discriminant of the record. It contains information about the component subtype. 

The structure of an implicit component of kind RECORD_DESCRIPTOR is not 
described in this documentation. Nevertheless, if a programmer is interested in 
specifying the location of a component of this kind using a component clause, he can 
obtain the size of the component using the ASSEMBLY parameter in the COMPILE 
command. 

The compiler treats an implicit component of the kind RECORD_DESCRIPTOR as 
having an anonymous array type. If C is the name of the record component whose 
subtype is described by the record descriptor, then this implicit component can be 
denoted in a component clause by the implementation generated name 
CRECORD DESCRIPTOR. 


Suppression of implicit components 

The Alsys implementation provides the capability of suppressing the implicit components 
RECORD_SIZE and/or VARIANT_INDEX from a record type. This can be done using 
an implementation defined pragma called IMPROVE. The syntax of this pragma is as 
follows: 

pragma IMPROVE ( TIME | SPACE , (ON =>] simple_name ); 

The first argument specifies whether TIME or SPACE is the primary criterion for the 
choice of the representation of the record type that is denoted by the second argument. 

If TIME is specified, the compiler inserts implicit components as described above. If on 
the other hand SPACE is specified, the compiler only inserts a VARIANT_INDEX or a 
RECORD_SIZE. 

component if this component appears i.n a record representation clause that applies to the 
record type. A record representation clause can thus be used to keep one implicit 
component while suppressing the other. 

A pragma IMPROVE that applies to a given record type can occur anywhere that a 
representation clause is allowed for this type. 


Size of a record subtype 

Unless a component clause specifies that a component of a record type has an offset or a 
size which cannot be expressed using storage units, the size of a record subtype is 
rounded up to a whole number of storage units. 

The size of a constrained record subtype is obtained by adding the sizes of its 
components and the sizes of its gaps (if any). This size is not computed at compile time 


28 


Alsys 286 DOS Ada Compiler. Appendix F. Version 4.2 








■ when the record subtype has non-static constraints, 

■ when a component is an array or a record and its size is not computed at 
compile time. 

The size of an unconstrained record subtype is obtained by adding the sizes of the 
components and the sizes of the gaps (if any) of its largest variant. If the size of a 
component or of a gap cannot be evaluated exactly at compile time an upper bound of 
this size is used by the compiler to compute the subtype size. 

A size specification applied to a record type or first named subtype has no effect. The 
only size that can be specified using such a length clause is its usual size. Nevertheless, 
such a length clause can be useful to verify that the layout of a record is as expected by 
the application. 


Size of an object of a record subtype 

An object of a constrained record subtype has the same size as its subtype. 

An object of an unconstrained record subtype has the same size as its subtype if this 
size is less than or equal to 8 kb. If the size of the subtype is greater than this, the 
object has the size necessary to store its current value; storage space is allocated and 
released as the discriminants of the record change. 


5 Conventions for Implementation-Generated Names 

The Alsys 286 DOS Ada Compiler may add fields to record objects and have descriptors 
in memory for record or array objects. These fields are not accessible to the user 
through any implementation-generated name or attribute. 

The following predefined packages are reserved to Alsys and cannot be recompiled in 
Version 4.2; 

ALSYS_«)A_RUNTlMe 
ALSTS_BASIC_IO 
ALSYS_BASIC_0IRECT_I0 
ALSYS_8AS I C_SEajeHT I AL_10 

6 Address Clauses 

6.1 Address Clauses for Objects 

An address clause can be used to specify an address for an object as described in RM 
13.5. When such a clause applies to an object no storage is allocated for it in the 
program gererated by the compiler. The program accesses the object using the address 
specified in the clause. 


Appendix F. Implementation-Dependent Characteristics 


29 



An address clause is not allowed for task objects, for unconstrained records whose size is 
greater than 8 kb., or for a constant. 


6.2 Address Clauses for Program Units 

Address clauses for program units are not implemented in the current version of the 
compiler. 

6.3 Address Clauses for Entries 

Address clauses for entries are not implemented in the current version of the compiler. 

7 Restrictions on Unchecked Conversions 

Unchecked conversions are allowed between any types. It is the programmer’s re¬ 
sponsibility to determine if the desired effect is achieved. 


8 Input-Output Packages 

The RM defines the predefined input-output packages SEQUENTlAL_IO, 
DIRECT_IO, and TEXT_IO, and describes how to use the facilities available within 
these packages. The RM also defines the package 10_EXCEPTI0NS, which specifies 
the exceptions that can be raised by the predefined input-output packages. 

In addition the RM outlines the package LOW_LEVEL_IO, which is concerned with 
low-level machine-dependent input-output, such as would possibly be used to write de¬ 
vice drivers or access device registers. LOW_LEVEL_IO has not been implemented. 
The use of interfaced subprograms is recommended as an alternative. 


8.1 Correspondence between External Files and 286 DOS Files 

Ada input-output is defined in terms of external files. Data is read from and written to 
external files. Each external file is implemented as a standard 286 DOS file, including 
the use of STANDARD_INPUT and STANDaRD_OUTPUT. 

The name of an external file can be either 

■ the null string 

■ an 286 DOS filename 

■ an 286 DOS special file or device name (for example, CON and PRN) 

If the name is a null string, the associated external file is a temporary file and will cease 
to exist when the program is terminated. The file will be placed in the current dir¬ 
ectory and its name will be chosen by 286 DOS. 


SO 


Alsys 286 DOS Ada Compiler, Appendix F, Version 4.2 





If the name is an 286 DOS filename, the filename will be interpreted according to stan¬ 
dard 286 DOS conventions (that is, relative to the current directory). The exception 
NAME_ERROR is raised if the name part of the filename has more than 8 characters 
or if the extension part has more than 3 characters. 

If an existing 286 DOS file is specified to the CREATE procedure, the contents of the 
file will be deleted before writing to the file. 

If a non-existing directory is specified in a file path name to CREATE, the directory 
will not be created, and the exception NAME ERROR is raised. 


8.2 Error Handling 

286 DOS errors are translated into Ada exceptions, as defined in che RM by package 
IO_EXCEPTIONS. In particular, DEVICE_ERROR is raised in cases of drive not 
ready, unknown media, disk full or hardware errors on the disk (such as read or write 
fault). 


8.3 The FORM Parameter 

The form parameter is a string, formed from a list of attributes, with attributes sep¬ 
arated by commas. The string is not case sensitive. The attributes specify; 

■ Buffering 

BUFFER_SIZE => size__in_byies 

■ Appending 

APPEND -> YES I NQ 

■ Truncation of the name by 286 DOS 

TRUNCATE => YES ) NO 


where: 

BUFFER_SIZE: Controls the size of the internal buffer. This option is not sup¬ 
ported for DIRECT_IO. The default value is 1024. This option has no effect 
when used by TEXT_IO with an external file that is a character device, in which 
case the size of the buffer will be 0. 

APPEND; If YES output is appended to the end of the existing file. If NO out¬ 
put overwrites the existing file. This option is not supported for DIRECT_IO. 
The default is NO. 

TRUNCATE: If YES the file name will be automatically truncated if it is bigger 
than 8 characters. The default value is NO, meaning that the exception 
NAME_ERROR will be raised if the name is too long. 


Appendix F, Implementation-Dependent Characteristics 


31 







The exception USE_ERROR is raised if the form STRING in not correct or if a non 
supported attribute for a given package is used. 

Example: 

FORM "TRUNCATE -> YES. APPEND YES. BUFFER_SIZE ».> 20480" 

8.4 Sequential Files 

For sequential access the file is viewed as a sequence of values that are transferred in 
the order of their appearance (as produced by the program or run-time environment). 
This is sometimes called a stream file in other operating systems. Each object in a se¬ 
quential file has the same binary representation as the Ada object in the executable pro¬ 
gram. 

8.5 Direct Files 

For direct access the file is viewed as a set of elements occupying consecutive positions 
in a linear order. The position of an element in a direct file is specified by its index, 
which is an integer of subtype POSITIVE_COUNT. 

DIRECT_IO only allows input-output for constrained types. If DIRECT_IO is in¬ 
stantiated for an unconstrained type, all calls to CREATE or OPEN will raise 
USE_ERROR. Each object in a direct file will have the same binary representation as 
the Ada object in the executable program. All elements within the file will have the 
same length. 


8.6 Text Files 

Text files are used for the input and output of information in ASCII character form. 
Each text file is a sequence of characters grouped into lines, and lines are grouped into 
a sequence of pages. 

All text file column numbers, line numbers, and page numbers are values of the subtype 
POSITIVE_COUNT. 

Note that due to the definitions of line terminator, page terminator, and file terminator 
in the RM, and the method used to mark the end of file under 286 EX)S, some ASCII 
files do not represent well-formed TEXT 10 files. 

A text file is buffered by the Runtime Executive unless 

■ it names a device (for example, CON or PRN). 

■ it is STANDARD_INPUT or STANDARD_OUTPUT and has not been 
redirected. 


32 


Alsys 286 DOS Ada Compiler. Appendix F. Version 4.2 






If not redirected, prompts written to STANDARD_OUTPUT with the procedure PUT 
will appear before (or when) a GET (or GET_LINE) occurs. 

The functions END_OF_PAGE and END_OF_FILE always return FALSE when the 
file is a device, which includes the use of the file CON, and STANDARD_INPUT 
when it is not redirected. Programs which would like to check for end of file when the 
file may be a device should handle the exception END_ERROR instead, as in the fol¬ 
lowing example: 


Example 

begin 

loop 

— Display the prompt: 

TEXT_IO.PUT ("—> -); 

— Read the next line: 

TEXT_IO.GET_LINE (COMMAND, LAST); 

— Now do something with COMMAND (1 .. LAST) 
end loop; 
exception 

when TEXT_IO.END_ERROR =» 
null; 


END_ERROR is raised for STANDARD_INPUT when (ASCII.SUB) is entered at 
the keyboard. 


8.7 Access Protection of External Files 

All 286 DOS access protections exist when using files under 286 DOS. If a file is open 
for read only access by one process it can not be opened by another process for 
read/write access. 


8.8 The Need to Close a File Explicitly 

The Runtime Executive will flush all buffers and close all open files when the program is 
terminated, either normally or through some exception. 

However, the RM does not define what happens when a program terminates without 
closing all the opened files. Thus a program which depends on this feature of the 
Runtime Executive might have problems when ported to another system. 


8.9 Limitation on the procedure RESET 

An internal file opened for input cannot be RESET for output. However, an internal 
file opened for output can be RESET for input, and can subsequently be RESET back 
to output. 


Appendix F, Implementation-Dependent Characteristics 


33 







8.10 Sharing of External Files and Tasking Issues 

Several internal files can be associated with the same external file only if all the internal 
files are opened with mode IN_MODE. However, if a file is opened with mode 
OUT_MODE and then changed to lN_MODE with the RESET procedure, it cannot be 
shared. 

Care should be taken when performing multiple input-output operations on an external 
file during tasking because the order of calls to the I/O primitives is unpredictable. For 
example, two strings output by TEXT^IO.PUT_LINE in two different tasks may ap¬ 
pear in the output file with interleaved characters. Synchronization of I/O in cases such 
as this is the user’s responsibility. 

The TEXT_IO files .i.STANDARD_INPUT;STANDARD_INPUT and 

^ .i.STANDARD_OUTPUT;STANDARD_OUTPUT are shared by all tasks of an Ada 
program. 

If TEXT_I0.STANDARD_INPUT is not redirected, it will not block a program on in¬ 
put. All tasks not waiting for input will continue running. 


9 Characteristics of Numeric Types 

9.1 Integer Types 

The ranges of values for integer types declared in package STANDARD are as follows; 
SHOUTJMTEGER -128 .. 127 •• 2**7 - 1 

INTEGER -32768 .. 32767 -- 2**15 - 1 

L0t(G_IHTEGER -2147483648 .. 2147483647 -- 2**31 - 1 

For the packages DIRECT_IO and TEXT_IO, the range of values for types COUNT 
and POSITIVE_COUNT are as follows: 

COUNT 0 .. 2147483647 -- 2**31 - 1 

POSITIVE_CCXJNT 1 .. 2147483647 -- 2**31 • 1 

For the package TEXT_10, the range rf values for the type FIELD is as follows: 

FIELD 0 .. 255 - 2**8 - 1 

9.2 Floating Point Type Attributes 

FLOAT LONG_FLOAT 

DIGITS 6 15 


34 


Alsys 286 DOS Ada Compiler. Appendix F, Version 4.2 







MANTISSA 


21 


51 


EMAX 

S4 

204 

EPSILON 

9.53674E-07 

8.88178E-16 

LARGE 

1.93428E+25 

2.57110E*61 

SAFE.EMAX 

125 

1021 

SAFE.SNALL 

1.17549£-3a 

2.22507E-308 

SAFE_LARGE 

4.25353E*57 

2.24712E*307 

FIRST 

-3.40282E+38 

-1.79769E+308 

LAST 

3.40282E+38 

1.79769E+308 

MACHINE_RADIX 

2 

2 

HACHINE_EHAX 

128 

1024 

NACHINE_EHIN 

-125 

•1021 

MACHINE_R0UN0S 

true 

true 

MACHIME.OVERFLOWS 

false 

false 

SIZE 

32 

64 

Attributes of Type DURATION 


DURATION'DELTA 

0.001 


DURATION'SMALL 

0.0009765625 (» 

2»*(-10)) 

DURATION'FIRST 

-2097152.0 


DURATION'LAST 

2097151.999 



DURATION'LARGE same as DURATION'LAST 

10 Other lmplenientation>Dependent Characteristics 
10.1 Use of the Floating-Point Coprocessor (80287) 


Appendix F. Implementation-Dependent Characteristics 


35 





The Alsys 286 DOS Ada Compiler generates instructions to use the floating point copro¬ 
cessor for all floating point operations (but, of course, not for operations involving only 
universal _real). 

A floating point coprocessor, 80287, is required for the execution of programs that use 
arithmetic on floating point values. The coprocessor is needed if the FLOAT_IO or 
FIXED_lO packages of TEXT_10 are used. 

The Runtime Executive will detect the absence of the floating point coprocessor if it is 
required by a program and will raise NUMERIC ERROR. 


10.2 Characteristics of the Heap 

UNCHECKED_DEALL0CATI0N is implemented for all Ada access objects except 
access objects to tasks. Use of UNCHECKED_DEALLOCATICN on a task object will 
lead to unpredictable results. 

All objects whose visibility is linked to a subprogram, task body, or block have their 
storage reclaimed at exit. 

The maximum size of the heap is limited only by available memory. This includes the 
amount of physical memory (RAM) and the amount of virtual memory (hard disk swap 
space). 

All objects created by allocators go into the heap. Also, portions of the Runtime Execu¬ 
tive representation of task objects, including the task stacks, are allocated in the heap. 

10.3 Characteristics of Tasks 

The default task stack size is IK bytes (32K bytes for the environment task), but by 
using the Binder option STACK.TASK the size for all task stacks in a program may be 
set to a size from IK bytes to 64K bytes. 

Normal priority rules are followed for preemption, where PRIORITY values are in the 
range 1 .. 10. A task with undefined priority (no pragma PRIORITY) is considered to 
be lower than priority 1. 

The maximum number of active tasks is restricted only by memory usage. 

The accepter of a rendezvous executes the accept body code in its own stack. Ren¬ 
dezvous with an empty accept body (for synchronization) does not cause a context 
switch. 

The main program waits for completion of all tasks dependent upon library packages 
before terminating. 

Abnormal completion of an aborted task takes place immediately, except when the ab¬ 
normal task is the caller of an entry that is engaged in a rendezvous, or if it is in the 


36 


Alsys 286 DOS Ada Compiler, Appendix F, Version 4.2 





process of activating some tasks. Any such task becomes abnormally completed as soon 
as the state in question is exited. 

The message 

GLOBAL BLOCKING SITUATION DETECTED 

is printed to STANDARD_OUTPUT when theRuntime Execuiivedetects that no further 
progress is possible for any task in the program. The execution of the program is then 
abandoned. 

10.4 Definition of a Main Subprogram 

A library unit can be used as a main subprogram if and only if it is a procedure that is 
not generic and that has no formal parameters. 


10.5 Ordering of Compilation Units 

The Alsys 286 DOS Ada Compiler imposes no additional ordering constraints on com¬ 
pilations beyond those required By the language. 

11 Limitations 

11.1 Compiler Limitations 

■ The maximum identifier length is 255 characters. 

■ The maximum line length is 255 characters. 

■ The maximum number of unique identifiers per compilation unit is 2500. 

11.2 Hardware Related Limitations 

■ The maximum size of the generated code for a single compilation unit is 
65535 bytes. 

■ The maximum size of a single array or record object is 65522 bytes. The 

maximum size of a static record is 4096 bytes. * 

■ The maximum size of a single stack frame is 32766 bytes, including the data 
for inner package subunits unnested to the parent frame. 

■ The maximum amount of data in the global data area is 65535 bytes, in¬ 
cluding compiler generated data that goes into the GDA (about 8 bytes per 
compilation unit plus 4 bytes per externally visible subprogram). 


Appendix F. Implementation-Dependent Characteristics 


37 





The maximum amount of data in the heap is limited only by available mem¬ 
ory, real and virtual. 


Alsys 286 DOS Ada Compiler, Appendix F. Version 4.2 



INDEX 


286 DOS conventions 31 
286 DOS errors 31 
286 DOS files 30 
286 DOS special file 30 
80287 36 

Abnormal completion 36 
Aborted task 36 
Access protection 33 
Allocators 36 
APPEND 31 

Application Developer’s Guide 2 
Array objects 29 
Array subtype 4 
Array type 4 

ASSIGN_TO_ADDRESS 8 
Attributes of type DURATION 35 

Binder 36 
BUFFER_SIZE 31 
Buffered files 32 
Buffers 

flushing 33 

Characteristics of tasks 36 
Column numbers 32 
Compiler limitations 37 

maximum identifier length 37 
maximum line length 37 
maximum number of compilation 
units 37 

maximum number of unique 
identifiers 37 
Constrained types 
I/O on 32 
Control Z 33 
COUNT 34 
CREATE 31, 32 

Device name 30 
DEVICE_ERROR 31 
DIGITS 34 
Direct files 32 
DIRECT_IO 30, 32, 34 
Disk full 31 
DOS Linker 3 


Drive not ready 31 
DURATION’DELTA 35 
DURATION’FIRST 35 
DURATION’LARGE 35 
DURATION’LAST 35 
DURATION’SMALL 35 

EMAX 35 

Empty accept body 36 
END_ERROR 33 
END_QF_FILE 33 
END_OF_PAGE 33 
EPSILON 35 
Errors 

disk full 31 
drive not ready 31 
hardware 31 
unknown media 31 

FETCH_FROM_ADDRESS 8 
FIELD 34 
File closing 
explicit 33 
File names 30 
File terminator 32 
FIRST 35 
FIXED_IO 36 
FLOAT_IO 36 
Floating point coprocessor 36 
Floating point operations 36 
Floating point type attributes 34 
FORM parameter 31 

GET 33 
GET_LINE 33 

GLOBAL BLOCKING SITUATION 
DETECTED 37 

Hardware errors 31 
Hardware limitations 

maximum amount of data in the 
global data area 37 
maximum data in the heap 38 
maximum size of a single array or 
record object 37 


Index 


39 




maximum size of a single stack frame 
37 

maximum size of the generated code 
37 

Hardware related limitations 37 
Heap 36 

I/O synchronization 34 
IBM Macro Assembler 3 
Implementation generated names 29 
IN_MODE 34 
Integer types 34 
Intel object module format 3 
INTERFACE 2, 3 
INTERFACE_NAME 2, 3 
Interfaced subprograms 30 
Interleaved characters 34 
IO_EXCEPTIONS 30, 31 

LARGE 35 
LAST 35 

Legal file names 30 
Library unit 37 
Limitations 37 
Line numbers 32 
Line terminator 32 
LONG_INTEGER 34 
LOW_LEVEL_IO 30 

MACHINE_EMAX 35 
MACHINE_EMIN 35 
MACHINE_MANTISSA 35 
MACHINE_OVERFLOWS 35 
MACHINE_RADIX 35 
MACHINE_ROUNDS 35 
Main program 36 
Main subprogram 37 
MANTISSA 35 

Maximum amount of data in the global 
data area 37 

Maximum data in the heap 38 
Maximum identifier length 37 
Maximum line length 37 
Maximum number of compilation units 
37 

Maximum number of unique identifiers 
37 

Maximum size of a single array or 
record object 37 

Maximum size of a single stack frame 
37 


Maximum size of the generated code 37 

NAME_ERROR 31 
Non-blocking I/O 34 
Number of active tasks 36 
NUMERIC_ERROR 36 

OPEN 32 

Ordering of compilation units 37 
OUT_MODE 34 

PTS_ARRAY 4 
Page numbers 32 
Page terminator 32 
Parameter passing 1 
POSITIVE_COUNT 32, 34 
Pragma IMPROVE 4 
Pragma INDENT 3 
Pragma INTERFACE 2, 3 
Pragma INTERFACE_NAME 2, 3 
Pragma PACK 4 
Pragma PRIORITY 4, 36 
Pragma SUPPRESS 4 
Predefined packages 29 
PRIORITY 4, 36 
PUT 33 
PUT_LINE 34 

Record objects 29 
Rendezvous 36 
RESET 33, 34 

Runtime Executive 1, 3, 32, 33, 36, 37 

SAFE_EMAX 35 
SAFE_LARGE 35 
SAFE_SMALL 35 
Sequential files 32 
SEQUENTIAL_IO 30 
Sharing of external files 34 
SHORT_INTEGER 34 
SIZE 35 

STANDARD_INPUT 30, 32, 33 
STANDARD_OUTPUT 30, 32, 33, 37 
Storage reclamation at exit 36 
Stream file 32 
SUPPRESS 4 
Synchronization of I/O 34 
SYSTEM 4 

Task stack size 36 
Task stacks 36 


40 


Alsys 286 DOS Ada Compiler, Appendix F, Version 4.2 




Tasking issues 34 
Tasks 

characteristics of 36 
Text file 

buffered 32 
Text files 32 
TEXT_IO 30, 34 
TRUNCATE 31 

Unchecked conversions 30 
UNCHECKED_DEALLOCATION 36 
Universal_real 36 
Unknown media 31 
USE ERROR 32 


Index 


41 




