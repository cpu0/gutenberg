NAVAL POSTGRADUATE SCHOOL 
Monterey, California 



THESIS 


Building Reusable Software Components 
for Automated Retrieval 

by 

Jennie Marie Sealander 
September 1992 

Thesis Advisor: Yuh-jeng Lee 


CD 

N) 


Approved for public release; distribution is unlimited. 










UNCLASSIFIED 
SECunrrY classification of this page 


i : 13 : I :{»4 II: 11 u [•f 11 I 


REPORT DOCUMENTATION PAGE 


UNCLASSIFIED 





Approved for public release; 
distribution is unlimited 





computer Science Dept 
Navid Postgraduate School 


6c. ADDRESS (at/. Stata, and ZIP Coda) 

Monterey, CA 93943-5000 


I M TJ ai k’’I il! : I kVe 





Naval Postgraduate School 


7b. ADDRESS (City, Stale, and ZIP Coda) 

Monterey, CA 93943-5000 




ORGANIZATION 

(if applicable) 

8a ADDRESS (City, Slate, and ZIP Code) 




i[«lK>l«J; W=f]aaijL^i»ik7eiJLii7,i-.]q;{.i 


ELEMENT NO. NO. 





ACCESSION NO, 


It. TITLE (IncludeSeeunty Classification) 

BUILDING REUSEABLE SOFTWARE COMPONENTS FOR AUTOMATED RETRIEVAL 



14. DATE OF REPORT (Year. Mondt, Day) 

Septeml^r 1992 




The views expressed in this thesis are those of the author and do not reflect the official 
policy or position of the Department of Defense or the United States Government. 


18, SUBJECT TERMS (Continue on reverse if necessary and identify by block number) 

Reusable Software Components, Automated Retrieval, CAPS 


C06ATI CODES 


GROUP SUB-GROUP 


19. ABSTRACT (Continue on reverse if necessary and identify by block number) 

The Computer Aided Prototyping System (CAPS) is designed to rapidly build prototypes of real-time sytems through 
the automated retrieval of reusable software components. A critical element in achieving this goal is a mechanism for 
automated retrieval of reusable software components from a software base. There were two major objectives of this 
thesis: (1) to select and prepare software components for inclusion in the CAPS software base; (2) to design and im¬ 
plement a translation tool which takes an Ada specification as input and generates the prototype system description 
language (PSDL) interface required for storage and retrieval in the CAPS software base -this is necessary since for a 
component to be usable in the CAPS software base, it must be specified in PSDL. We described the abstraction and 
implementation of the selected components, introduced the translator, and demonstrated the behaviors of the transla¬ 
tor via examples. 


£ 






UNCLASSIFIEDAJNLIMITED QBAMEASRPT. □OTIC USERS] UNCLASSIFIED 


22b^TELEPHONEi//7c/u(te Area Code) 






OOFORy 1473,84MAR 




83 APR edition may be used until exhausted 
All other editions are obsolete 


SECURITY CLASSIFICATION OF THIS PAGE 

UNCLASSIFIED 


1 



































Approved for public release; distribution is unlimited 


BUILDING REUSABLE SOFTWARE COMPONENTS 
FOR AUTOMATED RETRIEVAL 


by 

Jennie Marie Sealander 
Lieutenant, United States Naval Reserve 
B.A., Goucher College, 1983 

Submitted in partial fulfillment of the 
requirements for the degree of 

MASTER OF COMPUTER SCIENCE 


from the 

NAVAL POSTGRADUATE SCHOOL 
September 1992 




11 






ABSTRACT 


The Computer Aided Prototyping System (CAPS) is designed to rapidly build 
prototypes of real-time systems. A cridcal element in achieving this goal is a mechanism 
for automated retrieval of reusable software components from a software base. There were 
two major objectives of this thesis: (1) to select and prepare software components for 
inclusion in the CAPS software base; (2) to design and implement a translation tool which 
takes an Ada specification as input and generates the prototype system description 
language (PSDL) interface required for storage and retrieval in the CAPS software base - 
this is necessary since for a component to be usable in the CAPS software base, it must be 
specified in PSDL. We described the abstraction and implementation of the selected 
components, introduced the translator, and demonstrated the behaviors of the translator via 
examples. 




111 


Accession For 


NTIS GRA4I 
DTIC T/i.B 
Unannciijjced 




Distribution/ 
AvallfabiJlty Cocl^.»a 
uud/or 

Dlat i fSi-t'clai 


■ 


□ □ 







TABLE OF CONTENTS 


l. INTRODUCnON.1 

A. RAPID PROTOTYPING.1 

B. CAPS OVERVIEW.2 

1. User Interface.3 

2. Software Database.3 

3. Execution Support System.4 

C OBJECTIVES.4 

D. ORGANIZATION OF THESIS.4 

n. SOFTWARE REUSE.5 

A. APPROACHS TO SOFTWARE REUSE.5 

B. RETRIEVING REUSABALE COMPONENTS.6 

1. Retrieval Methods.6 

2. Review of Current Systems.7 

C PROTOTYPE SYSTEM DESCRIPTION LANGUAGE (PSDL).9 

D. CAPS SOFTWARE BASE AND COMPONENT RETRIEVAL.10 

m. REUSABLE SOFTWARE COMPONENTS.14 

A. ENGINEERING SOFTWARE COMPONENTS TO FACILITATE 

REUSE.14 

B. WHY ADA?.15 

C ADA COMPONENTS SELECTED FOR SOFTWARE BASE.16 

1. Unbounded_Set.16 

2. Bounded_Multiset.17 

3. Bounded_Graph.18 

4. Unbounded_Graph.19 

5. Unbounded_Map.20 

6. Real_Numbers.21 

7. Boundedjnteger.22 

8. Vectors.22 

9. Matrix.23 

IV. PSDL INTERFACE GENERATOR.24 

A. KODIAK.24 

1. Lexical Scanner.25 

2. Attribute Declarations.26 

3. The Attribute Grammar and Equations.27 

B. MAPPING ADA TO PSDL.29 

C EXPLANATION OF ATTRIBUTES.31 

1. psdl_interface_specification.31 

2. file_name.31 

3. generic_type_declarations.31 

4. number_of_operators.31 

5. operator_specification.31 


IV 















































6. type_declarations.32 

7. input_parameters.32 

8. output_parameters.32 

9. exceptions.32 

10. variable_type.32 

11. variable_name.32 

12. mode.33 

13. mode_check.33 

14. cunent_mode.33 

15. composite_types.33 

16. new_composite_types.33 

17. generic_types.33 

18. new_generic_types.33 

19. comma.34 

D. SAMPLE INPUT AND OUTPUT.34 

1. Operator Example.34 

2. Type Example.36 

E. LIMITATIONS.37 

V. CONCLUSIONS.38 

A. ACCOMPLISHMENTS.33 

B. FUTURE WORK.38 

APPENDIX A. ADA SPECIHCATIONS FOR REUSABLE COMPONENTS.40 

A. UNBOUNDED_SET.40 

B. BOUNDED_MULTrSET.42 

C. BOUNDED.GRAPH.44 

D. UNBOUNDED.GRAPH.48 

E. UNBOUNDED.MAP.52 

F. REAL_NUMBERS.54 

G. BOUNDEDJNTEGERS.56 

H. VECTORS.58 

I. MATRIX.60 

APPENDIX B. KODIAK PROGRAM LISTING.61 

LIST OF REFERENCES.91 

INITIAL DISTRIBUTION LIST .93 


V 









































LIST OF FIGURES 


Figure 1.1: Software Life Cycle for a Prototype.2 

Figure 1.2: Tools in the Computer-Aided Prototyping System.3 

Figure 2.1: A PSDL Specification for a Set.11 

Figure 2.2: Component Storage.12 

Figure 2.3: Component Retrieval.12 

Figure 4.1: Kodiak Program Strucmre.25 

Figure 4.2: Examples of Token declarations.26 

Figure 4.3: Example of Attribute Declarations.27 

Figure 4.4: Example of Attribute grammar and equations.28 

Figure 4.5: Operator Template.29 

Figure 4.6: Type Template.29 

Figure 4.7: Example of a generic_parameter_declarations Template.30 

Figure 4.8: Ada Specification for generic bubble sort package.34 

Figure 4.9: PSDL output for Ada generic bubble sort package .35 

Figure 4.10: Ada Specifiation for generic set.35 

Figure 4.11: PSDL output for Ada generic set package.36 


VI 























L INTRODUCTION 


A. RAPID PROTOTYPING 

Developing software systems which are efficient, reliable, maintainable, and 
understandable is a difficult task, especially for reliable real-time systems consisting of 
million lines of code. The development of software tools and methods has emerged in an 
attempt to manage the complexity. One method designed to aid development of reliable 
large sytems is that of rapid prototyping. A prototype is an executable model of an intended 
system whose purpose is to help the system designer and customer to evaluate and validate 
the feasibility of the proposed system. Rapid prototyping is the process of rapidly building 
a prototype of a system. This allows the user to provide feedback to the designer in the 
development phase, reducing wasted effort in building a system which does not meet the 
customers needs. Thus the developement of the system follows an iterative process. The 
designer constructs a prototype based on the requirements, examines the execution of the 
prototype together with the customer, then adjusts the requirements based on feedback 
from the customer. The prototype is modified accordingly until both the customer and the 
designer agree on the requirements [10]. 

The key to rapid prototyping is computer-aided tools and reusable components. An 
efficient way to rapidly build a prototype is to construct the system out of existing software. 
For this to happen, rapid prototyping tools should include a library of high quality reusable 
components in conjunction with an automated retrieval system. A specification language is 
needed to specify the requirements of a system and to locate components which meet the 
specifications. To achieve automated retrieval, components in the library must be stored 
with an interface written in the specification language identifying their functionality. 

The typical software life cycle for such a sytem is illustrated in Figure 1.1. The 
designer takes a set of requirements provided by the customer and generates specifications 
for the system. The prototype is realized by replacing as much of the specification as 
possible with reusable components. The remaining code is written manually. The goal is to 


1 





build the prototype fiom as many existing compoments as possible, minimizing the amount 
of code which needs to be written manually. 



Figure 1.1: Software Life Cycle for a Prototype 
B. CAPS OVERVIEW 

The Computer Aided Prototyping System (CAPS) is an integrated set of computer- 
aided software tools being developed at the Naval Postgraduate School. The system is 
designed to rapidly prototype hard real-time systems [9]. The main subsystems of CAPS 
are illustrated in Figure 1.2. The software tools communicate by means of a specification 
language, the prototype system description language (PSDL). The specification language 
allows the designer to formally translate the customer’s requirements into a high level 
description of the system. The specifications are used to retrieve reusable ada components 
from a large software base. An automated transformation scheme then binds the retrieved 
components together based on the PSDL description. The prototype is then compiled and 
executed. The following sections describe each of the three major subsystems of CAPS. 


2 














Figure 1.2: Tools in the Computer-Aided Prototyping System 

1. User Interface 

The user interface consists of a syntax directed editor, a graphic editor, and a tool 
interface. The graphic editor is used to create a graphic representation of the system in the 
form of a data flow diagram, plus timing and control constraints. Graphical objects used to 
represent the sytem include operators, inputs, outputs, data flows, and operator loops [13]. 
The syntax directed editor provides a convenient way of entering additional annotations to 
the graphics in the form of PSDL descriptions while preventing syntax errors. The tool 
interface hides the details of the interfaces of the CAPS tools from the designer [7]. 

2. Software Database 

The software database system consists of an engineering design database system 
and a software database system [16]. The design database contains PSDL descriptions for 
all software projects developed using CAPS. The software base provides reusable software 
components for realizing given PSDL specifications [9]. The key to component storage and 
retrieval is the component’s PSDL specification [18]. 


3 
















3. Execution Support System 

The execution support system consists of four tools: translator, static scheduler, 
dynamic scheduler, and a debugger [7,16]. The translator generates codes that binds 
together the reusable components extracted from the software base. The static scheduler 
designates time slots for operators with real-time constraints before execution begins. The 
dynamic scheduler allocates time slots for operators that are not time critical. The debugger 
monitors timing constraints and design integrity as the prototype runs and reports failures. 

C. OBJECTIVES 

For a component to be added to the CAPS software base it must be specified in the 
prototyping system description language (PSDL). Writing these specfications is a time 
consuming process. One goal of this thesis is to design and implement a translation tool 
which takes an Ada specification as input and generates the PSDL interface required for 
storage in the CAPS software base. Another goal is to prepare and test Ada components for 
inclusion in the software base. These components must meet certain criteria to be usable in 
a larger system. 

D. ORGANIZATION OF THESIS 

An overview of the design of the CAPS software base and necessary requirements for 
the storage of components in the software base is provided in Chapter n. Chapter in 
discusses general characteri'Jtics required for component reuse, why Ada was chosen as the 
implementation language for the components, and the purpose of these components. A 
description of the design and implementation of the specification interface generator is 
provided in Chapter IV. Chapter V contains conclusions and recommendations for future 
research. 


4 






n. SOFTWARE REUSE 


A. APPROACHS TO SOFTWARE REUSE 

One of the major purposes of software reuse is to reduce the cost of software 
development and maintenance. Software reuse comes in many forms and occurs whenever 
artifacts or knowledge about the development of one system is reapplied in tlie 
development of another [6]. Examples include the reuse of code, designs, application 
generators, formal specifications, and off the shelf commerical packages. Collectively 
these examples are referred to as reusable software components. 

A report in 1984 stated that “of all the code written in 1983, probably less than 15% 
is unique, novel, and specific to individual applications. The remaining 85% appears to be 
common, generic and concerned with putting applications onto computers” [5]. Thus, 
common generic software is an essential target of opportunity. There is almost no cost 
involved in copying a piece of software. Software reuse also provides a natural way to 
improve the quality of software. Frequent reuse of a software component can lead to 
frequent evaluation and revision, thus resulting in the construction of a high quality piece 
of software. Using high quality, well understood components as building blocks to 
construct large complex sytems should increase the quality of the final product and at the 
same time accelerate software production. 

Technologies applicable to software reuse can be classified into two categories: reuse- 
in-the-small and reuse-in-the-large [6]. Reuse-in-the-small is concerned with the reuse of 
small pieces of source code such as classes, subroutines, Ada packages, and so on, and is 
the focus of this thesis. Reuse-in-the-large is concerned both with the reuse of large-grain 
components such as subsystems and the reuse of elements beyond source code such as 
design structures and decisions, domain knowledge, analysis information, and so forth. 

Technologies applied to reuse-in-the-small are basically concerned with component 
representation and component management. Component representation deals with the form 


5 




and content of software components. There are some important characteristics specific to 
reusable components which will be discussed in Chapter HI. Component management is 
concerned with classification, storage and reuieval of software components which will be 
reviewed in the following sections of this chapter. 

B. RETRIEVING REUSABALE COMPONENTS 

There are two costs associated with reuse-in-the-small. The first cost is associated 
with building and maintaing a component for reuse. The second is the cost associated with 
storing and retrieving components. The latter has resulted in an increasing demand for tools 
that aid in classifying, storing, and retrieving components. This section discusses some of 
these methods and the systems which use them [16]. 

1. Retrieval Methods 

Most of the tools developed to assist in the retrieval of software components use 
one or more of three different approaches; browsers, informal specifications, or formal 
specifications. A brief description of each follows: 

a. Browsers 

A browser is a tool, usually window based, for looking through a collection 
of software components. The purpose of a browser is to allow the user to direct a search 
through the available components. This can be useful for a user who is familiar with the 
content and structure of a software collection. However, this method of retrieval is not 
suited for a very large software base. The user can easily miss semantically similiar 
components stored in separate areas of the software base. Also a user will not know when 
to stop looking for a component unless the component is found or the entire software base 
has been viewed. 

b. Informal Specifications 

Retrieval methods based on informal specifications require the user to list 
some attributes of the component sought. These attributes are used to direct the user to the 


6 



approriate components. Examples of this method include keyword search, mulit-attribute 
search, and natural language interface. 

To perform a keyword search, a user specifies a list of words relevant to the 
component being sought. For example, a user looking for a component which implements 
a mathematical set, would list the keyword set A major disadvantage to keyword search is 
that the choice of words listed is crucial to success. One keyword may lead to the retrieval 
of many inappropriate components that the user must review. On the other hand, the use of 
too many keywords may result in missing appropriate components. 

A multi-attribute search is an extension of the keyword search. Attributes 
such as component class (procedure, function, package, etc.) or the number and types of 
parameters are used in the search. This type of search is generally more selective but 
requires the user to be familiar with the classification and storage techniques of the system. 

A natural language search is based on a natural language query formed by the 
user. Although a user may find it easy to formulate a query using a natural language, this 
type of technique is very difficult to implement. Mechanisms built based on this method 
have been limited to certain domains or the use of a restricted language. 

c. Formal Specifications 

Retrieval using formal specification provides for a higher degree of 
automation. The user formulates a query using a high level language to specify the 
functionality of the desired component. Each component in the software base is stored with 
an interface using the same specification language. The system looks for components in the 
software base whose specification matches that of the user’s query. However, writing 
formal specifications for components is difficult and requires substantial training. 

2. Review of Current Systems 

This section describes current retrieval systems that have been built and the 
methods used by each system. 


7 






a. Draco 

The Draco project was developed at the University of California, Irvine and 
was one of the first systems to reuse components fiom all phases of the software lifecycle, 
including designs and analysis information. The system organizes software components by 
problem areas or domains. The retrieval scheme is based on a mulit-attribute search. A 
classification scheme, called faceted classification, is used to aid in organizing and 
retrieving components. Each component is described by using a set of attributes. The set of 
attributes is defined by the problem domain. The values associated with attributes are 
selected firom a controlled vocabulary. 

The system is conceptually simple to use and relatively easy to implement. 
However, classification is generally not suitable for unconstrained domains. Also, 
semantically similar components may be missed, especially if stored in different domains. 

b. RAPID 

RAPID (Reusable Ada Packages for Information System Development) is an 
ongoing project sponsored by the U.S. Army Information Systems Software Development 
Center in Washington. The system is designed to classify, store, and retrieve reusable Ada 
packages in the information systems domain. RAPID uses a faceted classification scheme 
similiar to Draco. 

c. Operation Support System 

The Operation Support System (OSS) is an ongoing project being developed 
by the Naval Ocean Systems Onter. One goal of the project is to establish a Navy software 
library. Currently the components stored in the library are large command, control, and 
communications software subsytems. The system supports component retrieval using 
faceted classification, keywords, and a textual browser. 


8 



d. Common Ada Missile Packages (CAMP) 

The Common Ada Ivlissile Packages is an ongoing project sponsored by the 
Department of Defense to develope a software engineering system supported by a software 
library of reusable Ada components. The system is directed to software for missile sytems. 
One of the main components of the system is the Parts Engineering System (PES) Catalog. 
The catalog system provides a menu driven interface for storing, modifying, and retrieving 
components. Each component has an attribute list associated with it which is used as the 
basis for retrieval. The method of retrieval is based on muli-attribute search since one or 
more attributes may be used to drive a search. 

e. CAPS 

The method used in the Computer Aided Prototyping System is to retrieve 
components from a software base using a formal specification.The System also supports 
keyword searches and component browsing. The aim of CAPS is automated retrieval and 
integration of a component into a prototype based on formal specification. A description of 
the specification language PSDL is in section C and the basics of the retrieval sytsem will 
be discussed in section D of this chapter. 

C. PROTOTYPE SYSTEM DESCRIPTION LANGUAGE (PSDL) 

The prototype system description language (PSDL) and a large software base of 
reusable components form the basis of the CAPS system. PSDL is a specification language 
that was designed to support rapid prototyping of large real-time sytems [8,10]. PSDL 
contains a small set of powerful constructs which make it simple and easy to understarid. 
The language was also designed for specifying retrieval of reusable modules from a 
software base. 

PSDL is based on a computational model consisting of operators and data streams. A 
system is designed as a network of operators connected by data streams augmented with 
timing and control constraints. Operators can be either atomic or composite. A composite 
operator may be decomposed into a set of lower level operators and streams. An atomic 


9 








operator cannot be further decomposed. The network can be graphically represented as a 
set of data flow diagrams. The prototype as a whole is viewed as an operator which is the 
top level of the data flow diagram. The top level operator is decomposed into a set of more 
refined operators, and these are decomposed iteratively until all operators are atomic. 

Operators can be either functions or state machines. The data streams can carry 
exception conditions or values of abstract data types [9]. A data stream which carries an 
instance of an abstract data type is defined as a PSDL type. This definition includes all of 
the operators that can operate on that data type. PSDL operators and types are the basic 
building blocks of a prototype. 

A PSDL implementation of a prototype has two parts: a network consisting of the 
operators in the sytem and their interconnections, and a set of reusable components 
containing implementations of the atomic components in Ada. The Ada components are 
retrieved from the software base based on a PSDL description provided by the designer for 
each atomic component The specification part of a PSDL component contains several 
attributes that describe the interface and behavior of that component Hgure 2.1 shows an 
example of a PSDL specification for an abstr^t data type for a set 

D. CAPS SOFTWARE BASE AND COMPONENT RETRIEVAL 

The CAPS software base is an object-oriented database which contains PSDL 
descriptions and code for all available reusable software components. The database 
management system supports automatic retrieval and provides graphical tools for browsing 
and doing keyword searches [14]. Graphical tools provide a means for storing components 
in the software base as well. 


10 






type SET specificatioii 

operator EMPTY specificatioii 
output SI: set end 

operator ADD specification 
input ELEMEOT: integer. SI; set 
output S2: set end 

operator D>i specification 
input ELEMH^ : integer, SI : set 
output RESULT : boolean end 

operator SUBSET specification 
input SI, S2: set 
output RESULT : boolean end 

operator EQUAL specification 
input SI, S2 : set 
output RESULT : boolean end 

keywords SET, INTEGER 

description (Implements a set of integers) 

axioms 

(obj SET is sort Set 
protecting INT. 
op empty : -> Set 
op add: Int Set •> SeL 
op in: Int Set •> Bool, 
op subset: Set Set •> Bool, 
op equal: Set Set •> Bool, 
vars si s2: Set. 
vars el e2: Int. 
eq in (el,empty) = false. 

eq in (el,add(e2,sl)) = or (= =(el,e2), in(el,sl)). 
eq subset(empty,sl) = true. 

eq subset(add(el,sl),s2) = and(in(el 32 ),subset(sl,s 2 )). 
eq equal(sl,s2) =: and (subset(sl,s2},subset(s2,sl)). 

endo) 

end 


Figure 2.1: A PSDL Specification for a Set 
To store a component in the software base requires three files. A PSDL specification, 
and the interface and body for the implementation code [17]. The PSDL specification gives 
a means to uniformly specify the functionality of the component as described in the 
interface code. The PSDL specification is passed through syntactic and semantic 
normalization before being stored in the software base (see Figure 2.2). The normalization 
process modifies the specification to improve the efficiency of the search. A query for a 


11 







library component is formed by constructing the PSDL specification for the desired 
component The query specification is normalized then matched against the stored 
specifications (see Figure 2.3). 


PSDL 
Spec . 


Syntactic 


Semantic 

PSDL Spec 

Software 

Normalization 


Normalization 


Base 


Figure 2.2: Component Storage 



Figure 2.3: Component Retrieval 

The retrieval process is two phased [11,17]. Syntactic matching takes place first and 
partitions the software base quickly in order to narrow the list of possible candidates that 
will be considered during semantic matching. The syntactic phase uses the number and 
types of parameters associated with each component to narrow down the search. The 
semantic matching phase uses the axioms in the latter half of a PSDL specification (see 
Figure 2.1) to narrow the set of candidates further. This phase detennines which 
components are behaviorally close to the query. 

The ability to accurately specify reusable components with PSDL is critical to the 
success of automated retrieval. The CAPS software base was designed to store components 
implemented in various programming languages. Because of the differences in the 
capabilities of different programming languages, the software base is separated into 
language domains. PSDL is not geared toward any particular programming language and 
therefore must be refined to specify a particular programming language. The software base 


12 






is designed to recognize the enumeration of PSDL for any language in the following areas: 
generic parameters, abstract data types, type inheritance, and array abstract data type [14]. 
For a particular language library the definitions of the special identifiers are contained in a 
rule file for each library. The rule file established for the Ada library guided the translation 
of Ada specs into a PSDL interface (see Chapter IV). 


13 








in. REUSABLE SOFTWARE COMPONENTS 


A. ENGINEERING SOFTWARE COMPONENTS TO FACILITATE REUSE 

To fully derive the benefits of reusable software components, we must engineer our 
software with reuse in mind and begin to accumulate a rich set of components for the 
designer [1]. There are three factors which make it practical to formalize reuse-in-the- 
small; the emergence of a widely accepted body of knowledge about data structures and 
algorithms, development of software engineering principles, and the development of 
programming languages, such as Ada, which support reuse. Components built for reuse 
should exhibit the characteristcs of any good piece of software. For example, a component 
should be maintainable, efficient, reliable, understandable, and, of course, correct. 

A reusable component should be cohesive and loosely coupled. Cohesive means the 
component should denote a single abstraction. Loosely coupled means the component 
should be defined independendy of other abstractions. For example, a component which 
denotes an abstraction for real numbers should not include an abstraction for a set. 
Secondly, the abstraction should not be dependent on other abstractions. 

There are other desirable characteristics of reusable components. They should be 
sufficient, complete, and primitive [1]. These characteristics of a component have to do 
with the outside view of the component. A sufficient component captures enough 
characteristics of the abstraction to permit meaningful interaction with the object For 
example, if a component represents real numbers but provides no means for adding two real 
numbers together, then the component is useless. The interface of a complete component 
captures all characteristics of the component Sufficiency implies a minimal collection of 
operations, whereas a complete set of operations is one that covers all aspects of the 
imderlying abstraction. 

Primitive operations are those that can be efficiently implemented with only access 
to the underlying representation. For example, the addition of two real numbers. Those 
operations which are not primitive but may be useful to the component can be easily 


14 





extended by the user of the component by building new composite operations. For example, 
the abstraction of real numbers includes the notion of comparing two numbers. To make 
the component sufficient it should include “<”and operations. To enhance the 
completness of the abstraction, we might add a “>” operation. However, a “>” can be built 
as a composite operation of the “<” and operations. The designer of a reusable 
component cannot know exactly how a particular component is going to be used. 

B. WHY ADA? 

Ada is a language that embodies and enforces modem software engineering 
principles. Ada was also designed with the explicit requirement to support reuse. Features 
of Ada which support reuse include [1,2]: 

1. Separation of interface from the body, 

2. Generic program units, 

3. Strong typing, and 

4. Variety of program units including packages and subprograms 

Separation of the interface tom the body supports information hiding and abstraction. 

An ada specification (interface) identities the functionality of a component and is the 
information visable to the user of that program unit. The body contains the unit 
implementation which is hidden from the user. Unimportant details are hidden from the 
user. Separation of the interface from the body is also important for storing and classifying 
a component. 

The Ada generic unit is the main mechanism for building reusable components. A 
generic unit provides the template for the algorithm or data structure. Upon instantiation of 
a generic unit the client provides the set of allowable values for a data structure. 

Ada is a strongly typed language. This means objects declared of a given type may 
only take on those values which are legal for that type. In addition, the only operations that 
may be carried out on an object are those which are detined for its type. Strong typing can 
be instrumental in improving the reliability of a program unit by guaranteeing that the 


15 






properties of an object are not violated. The requirement for explicit declaration of objects 
with their types improves the readability of a program. This guarantees the programmer 
must say something about the property of an object. 

Packages permit the encapsulation of a group of logically related entities which 
directly supports data abstraction and information hiding. Well structured Ada systems are 
decomposed into levels of abstractions, structured as collections of logically related 
packages that form a model of reality. 

C. ADA COMPONENTS SELECTED FOR SOFTWARE BASE 

The components selected and tested as a part of this study for inclusion in the CAPS 
software base all represent an abstract data type. They include an unbounded map, an 
unbounded set, a bounded multiset, a bounded graph, an unbounded graph, a matrix, vector, 
real numbers, and bounded integer types. All components were developed by students at 
the Naval Postgraduate School. The author of this thesis tested and in most cases modified 
the components. Operations were added to components which did not sufficiently define 
the abstraction. Other changes corrected errors and improved efficiency and readability. 
Appendix A contains the specification for each component. The following is a brief 
description of the abstraction, implementation, and major changes made to the components. 

1. Unboiinded_Set 
a. The abstraction 

The mathematical abstraction set is widely used in computer science 
applications. Many interesting data structures can be thought of as just implementations of 
sets. Thus it makes sense to build a reuseable set component. Given a “universe” of 
permissable values, a set is an unordered collection of objects belonging to that universe. 
Two sets are said to be equal if they have the same members. A set is said to be empty if it 
has no members. What are the important operators associated with sets? Certainly adding 
and removing an element from a set are essential as well as being able to determine the size 


16 








of the set Other important operations include the dyadic operations union, intersection, 
difference, and equality. 

b. Implementation 

The Unbounded_Set was implemented with a linked list structure. The 
number of elements that can be added to the set are only limited by available memory. The 
unit contains one generic type parameter which defines the type of elements which may be 
added to the set. A hashing function could be used to simplify searching for a given 
element, however, it would complicate the algorithms for the dyadic operations. 

c. Major changes 

A remove procedure and a set difference procedure were added to the original 
version to make the component sufficient. An error in the original add procedure which 
allowed duplicate copies of an element was corrected. 

2. Bounded^Multiset 

a. The abstraction 

A multiset is the same as a set except that items contained within a mulitiset 
need not be unique. The size of a mulitset refers to the number of items contained within 
the set A multiset which contains no items is said to be empty. Operations important for a 
multiset include an empty set constant a count operation that returns the number of 
instances of a given element in a given multiset add and remove operation, an operation to 
test equality, and a size operation which returns the number of distinct elements in a 
multiset 

b. Implementation 

The bounded.multiset is implemented with an array. The unit has two generic 
parameters. Element is a generic type parameter which provides the type of items which 
can be added to the set Max_Size is a generic value parameter which determines the size 
of the array (the number of unique elements that may be added to the set). 


17 







c. Major Changes 

The original data structure kept multiple copies of any repeating elements in 
the array. The data structure was changed to keep a count of each element rather than 
keeping mulitple copies of the element. This representation is more efficient for any 
application which contains many copies of an element, for example an inventory record. 
Two procedures, Last_Element and First_Element, were removed from the package 
specification and are now local to the body. They were used in the implementation of the 
data type, but are not part of the definition of the data type, hence should not be visable to 
the user. An overflow exception was added to the add procedure. The function empty_set 
was changed from a predicate function to an empty set constant. Get and put operations 
were removed from the test package and added to the generic package. 

3. Bounded_Graph 

a. The abstraction 

Graphs are an important mathematical structure and are used widely in 
computing problems. A graph is made up of a set of vertices or nodes and a set of arcs or 
edges, which represent connections between the vertices. Our abstraction represents a 
directed graph or a graph in which the edges have direction. Important operations include 
initializing a graph to empty, adding a node, adding an edge, checking whether there is an 
edge between a given pair of nodes, finding the set of nodes connected to a given node via 
an outgoing or incoming edge, removing the edge between a given pair of nodes, and 
removing a node and all of the edges connected to that node. 

b. Implementation 

The bounded_graph is implemented using an adjacency matrix. An adjacency 
matrix is a n x n boolean matrix where n represents the maximum number of nodes allowed 
in the graph. If the [//j element in the matrix is true then there is an edge from vertix i to 
vertix J and false if there is not. A one dimensional array of size n is used to store the values 


18 







values of each node. The unit has two generic parameters. One is a type parameter which 
allows the user to define the allowable values for the nodes. The other is a value parameter 
of type positive and determines the maximum size of the graph. 

c. Major Changes 

The original version was a machine with a state variable representing the 
graph declared in the specification. The state variable was removed and a parameter 
representing a graph type was added to all functions and procedures. An operator which 
returns an empty graph was added and overflow exception was added to a local procedure 
which is called by the add operation. 

4. Unbounded_Graph 

a. The abstraction 

The abstraction for the unbounded graph is the same as the bounded graph, 
but allows an arbitrary number of nodes to be added to the graph. 

b. Implementation 

The unbounded graph permits an arbitrary number of nodes in the graph. The 
implementation uses an adjacency list. The basic idea of an adjacency list is to list each 
vertex followed by the vertices adjacent to it. This provides the basic infonnation about a 
graph: the vertices and edges. Two linked lists are used. One list links all the nodes in the 
graph. Each node in the graph has an adjacency list, which lists all adjacent nodes. The unit 
has one generic type parameter which imports the allowed values for each node. 

c. Major Changes 

The original data structure was modified to improve readability. An 
adjacency node in the original structure used a pointer to a graph node to identify an 
adjacent vertix. This pointer was removed and replaced with the node element. Type 
declarations used to build the graph data type were moved from the public to the private 


19 





section of the specification. This hides unnecessary implementation details from the user. 
An unnecessary type declaration was removed to improve readability. 

5. Unbounded_Map 

a. The abstraction 

A map permits one to define arbitrary relationships among otherwise 
unrelated objects. A map is a mathematical function on objects of one type, called the 
domain, yeilding objects of another type called the range [1]. Thus a map consists of a 
dynamic collection of bindings from the domain to the range. Bindings may be added, 
removed, and modified over the lifetime of a map. The extent of a map represents how 
many bindings are in the map and if a map contains no bindings the map is said to be empty. 

Operations include initializing a map to empty, adding a binding to a map, 
finding the range value associated with a given domain value, checking whether a given 
domain value has a binding in the table, finding the number of bindings in the table, and 
removing the binding associated with a value of the domain type. 

b. Implementation 

An unbounded abstraction should permit a map .vith an arbitrary number of 
domain and range pairs. This can be easily done using a linked list structure whose nodes 
are records containing these pairs. However, to mitigate the time for searching a gigantic 
list for a given pair, the map is represented as a collection of several smaller lists. The 
unbounded map is represented as a set of blocks of lists. Each block is an array where each 
array component acts as a bucket which holds a list of ordered pairs. A set of blocks is 
represented using a linked list. A hashing function is used to determine in which list or 
bucket a map pair will be located. If the hash function returns an index outside the available 
map blocks, a new block is added. 

The generic unit has eight generic parameters. Two type parameters are used 
to import the domain and range types. A value parameter allows the user to determine the 
number of buckets per block. The remaining parameters are generic subprogram 


20 






parameters. One is a hashing function, the others are get and put procedures for the domain 
and range. 

c. Major Changes 

In the original version, two state variables, NUM_BINDINGS and 
NUM_BLOCKS, were declared in the package body. These variables will reflect 
inaccurate data if more than one instance of the map type is declared. Thus they were 
removed from the body and made part of the data structure of the map type. 

6. Real_Numbers 

a. The abstraction 

The real abstraction is a high precision real number type representing the 
standard mathematical domain of real numbers. Real literals are decimals, with at least one 
digit on each side of the decimal. Operations include conversions from Ada float to real, 
addition, subtraction, multiplication, division, and the comparison operators and “<”. 

b. Implementation 

The real number data type is implemented as a record type. The record 
contains three fields: the sign of the number, a digit array containing the digits of the real 
number, and an exponent array. The unit has two generic value parameters, digits and 
max_exponent Digits represents the minimum required precision and determines the size 
of the digit array. Max_exponent determines the largest number which can be represented. 

The representation will handle numbers ranging up to 10^ where e is the max_exponent. 

c. Major Changes 

The original version used separate arrays to hold the whole and decimal parts 
of a real number. The whole array was declared as a non-generic static type. This version 
was simplifled by removing the static array and normalizing the position of the decimal. 
This allowed the elimination of five local subprograms and the simplification of others. 


21 





Type declarations used to build the real data type were moved from the public to the private 
section of the specification. This eliminates unnecessary implementation details from the 
user. 

7. Bounded_Integer 

a. The abstraction 

The bounded integer abstraction represents signed whole numbers of 
standard mathematics. The range of the integers is bounded. Operations include conversion 
from Ada integers to a bounded_integer, addition, subtraction, multiplication, division, 
mod, and the comparison operators “=” and “<”. 

b. Implementation 

The boundedjnteger type is implemented using an anay. The unit has one 
generic value parameter which specities the number of decimal digits the representation 
must support 

c. Megor Changes 

Type declarations used to build integer type were moved from the public to 
private section of specification. Many algorithms were rewritten to improve readability. 
This mainly involved the removal of unnecessary local variables. 

8. Vectors 

a. The abstraction 

A mathematical vector is a set of elements which is ordered in the sense that 
each component is assigned a specific position in the set The dimension of a vector 
designates the number of elements for a given vector. Operations include conversion from 
an array of elements to a vector, vector addition and subtraction, multiplication by a scalar 
(value of the element type), dot product of two vectors, and the mathematical length of a 
vector. 


22 




h. Implementation 


The vector is implemented using a one dimensional array. The generic unit 
has a generic type parameter which determines the element type. A generic value parameter 
is used to import the dimension of the vector. Generic subprogram parameters are needed 
to define arithmetic operations on the element type. 

c. Major Changes 

An operation to convert an array of objects to a vector was added. 

9. Matrix 

a. The abstraction 

A mathematical matrix can be viewed as a rectangular array of elements, 
having R rows and C columns. Any particular element in the matrix may be referred to 
using to subscripts, the row and column position. Operations on matrices include 
conversion from an array of elements to a matrix, matrix addition and subtraction, 
multiplication by a scalar ( value of the element type), matrix multiplication, and 
transposition. 

b. Implementation 

The matrix type is implemented using a dimensional array. Two generic value 
parameters are used to define row and column length. A generic type parameter defines the 
element type. 

c. Major Changes 

None. 


23 




IV. PSDL INTERFACE GENERATOR 


The PSDL interface specification generator is a tool which automates the process of 
producing the necessary PSDL interface for the storage of an Ada component in the CAPS 
software base. This chapter describes the design and implementation of the translator. 
Section A provides information, extracted from [4], that is necessary to understand the code 
listed in Appendix B. 

A. KODIAK 

Kodiak is the tool we used to build the translator. It is a fourth generation language 
developed at the University of Minnesota and designed for the purpose of producing 
language translators. The language is based on Knuth’s description of attribute grammars 
[4]. Attribute grammars are a scheme for describing syntax-directed translation, in which a 
context-free grammar’s rules are augmented with equations defining these attributes. The 
string is parsed into a syntax tree by applying a set of grammar rules. The root of the tree 
represents the start symbol, the leaf nodes represent the terminal symbols, and the internal 
nodes represent the non-terminal symbols of the grammar. Attributes can be assigned to the 
nodes of the syntax tree. To translate the input string into an output string, values are 
assigned to the attributes of each node. The root of the tree is given an attribute whose value 
is based on the collective value of all the nodes in the tree, producing the output string. 

The values of a particular node’s attributes can be determined in one of two ways. The 
values of the attributes are either inherited or synthesized. Synthesized attributes are 
evaluated from the bottom up, meaning the value of an attribute at a given node is derived 
from that node’s descendants. Inherited attributes are evaluated from top down, meaning 
the value of an attribute at a given node is derived from the node’s parent. 

Every Kodiak program consists of three sections, as shown in Figure 4.1. The first 
section describes the features of the lexical scanner which is used to translate the source 
text into tokens and associativities for those tokens. The second section declares the 
attributes and their type associated with each grammar symbol. The third section describes 


24 




the grammar and attribute equations which define the semantics of the translation. Each 
section must be separated by a double per-cent symbol (%%) on a line by itself . The 
symbol “!” introduces a comment and everything written after it on a line it will be 
interpreted as a comment. The following is a brief description of each section. 

! Lexical Scanner Section 

%% 

! Attribute Declaration Section 

%% 

! Grammar rules and attribute equations 

Figure 4.1: Kodiak Program Structure 

1. Lexical Scanner 

The lexical scanner section of a program defines the terminal symbols (leaf nodes 
of the syntax tree) of the source language and how these symbols are to be transformed into 
tokens. The source language in this case is Ada and the terminal symbols correspond to 
Ada’s lexical units. Ada’s lexical units consist of identifiers, numeric literals, character 
literals, and comments. Ada’s reserved words, a subset of identifiers, must be defined in 
this section as they are required in defining the grammar. The basic form of a token 
definition is: 

TERMINAL_NAME: REGULAR.EXPRESSION 

Terminal name is the name given to the token and appears in the definition of the grammar 
in section three of the program. The regular_expression provides the definition of the token. 
Code fragments from the lexical scanner section of the PSDL interface generator are given 
in Figure 4.2. These declarations indicate that an occurence of the regular expression to the 
left of a colon is to be replaced by the atomic terminal symbol on the right. For example, 
an occurence of the string “package” or “PACKAGE” in the input text is to be replaced by 









the symbol PACKAGE. The keyword %define introduces a definition. Square brackets 
enclosing a set of characters indicates that any character of the set may be used to match 
the text. Curiy braces arc used to invoke a substitution. The ‘+’ operator indicates that one 
or more of the previous class may be used to match the text. The operator indicates that 
zero or more of the previous class may be used to match the text. 


Idefinition of lexical classes 

%def!ne Digit: [0-9] 

%define Int: {Digit}+ 

Idefinition of compound symbols and keywords 

PACKAGE : package I PACKAGE 
REAL_LITERAL: {Int}”.”{Int} 


Figure 4.2: Examples of Token declarations 

2. Attribute Declarations 

The attribute declarations section consists of attribute declarations for all non¬ 
terminals and terminals named in the program. Kodiak supports two primitive types for 
attributes: strings and integers. Kodiak also supports higher order map types. For example 
in Figure 4.3, generic_type_definitions has two attributes. The attribute variable_type is 
declared to be of type string. The attribute generic_types is declared to be a map type whose 
domain and range are both of type string. Basic.declaration has one attribute, 
number_of_operators, which is declared to be of type integer. 

Terminal symbols may also have attributes. These symbols are permitted two 
predefined attributes called %text and %line in addition to user defined attributes. In Figure 
4.3, the terminal IDENTIFIER has the attribute %text which will be initialized to the text 
the terminal symbol IDENTIFIER matched in the input text. 


26 








! Attribute declarations for non-teiminal symbols 

start { psdlJnterface_specification: string;); 

generic _type_definition { variable_type: string; 

generic_t^s: string->string; }; 

basic_declaiation { number_of_operators: int;}; 

! Attribute declarations for terminal symbols 
IDENTIFIER {%text: string; }; 


Figure 4.3: Example of Attribute Declarations 
3. The Attribute Grammar and Equations 

The attribute grammar section consists of a set of BNF rules defining the grammar 
of the source language. Each rule is associated with a set of equations which define how the 
input text is to be translated. A firagment of the PSDL interface generator is given in Figure 
4.4. The fragment defines the grammar rule for the non-terminal package_specification. 
The symbol “I” is used to separate two definitions for the grammar symbol. Curly braces 
surround any attribute equations. Null productions are permitted, meaning the curly braces 
may be left empty. 

An attribute is referred to using dot notation. The grammar symbol associated 
with the attribute proceeds the dot and the name of the attribute follows. If more than one 
occurence of a grammar symbol appears in a grammar rule, the leftmost symbol is taken to 
be the one referred to by an attribute. To refer to a later symbol, the attribute may be 
followed by a number in brackets referring to the symbols position of occurence in the rule. 

Kodiak supports traditional arithmetic and relational operators for integers and 
strings. An addition operator for map types is provided using the symbol “+1”. A 
conditional clause is also supported and is exemplified in Figure 4.4. The then portion of 
the clause follows the anow,“->”, and the else portion follows a “#” sign. 


27 









One attribute equation is defined between the first set of curly braces in Figure 
4.4. The equation evaluates the value for the attribute psdl.interface.specification. This 
equation contains a conditional. If the attribute number_of_operators equals one, then the 
value following the arrow is assigned to the psdl_interface_ specification, otherwise the 
value following the # sign is used. Literal strings appear between quotes. The other 
attributes which appear in the equation are evaluated to strings. All literals and attributes 
between the brackets are catenated to produce the psdl_interface_specification. A further 
explantion of the attributes in provided in section C. 


package_q)eciflcation 

: PACKAGE IDENTIFIER IS basic.declarativejtems END IDENTIFIER 
(package_specifk:ation.psdl_interface_specification = 
basic_declarative_itefiis.number_of_operators »i 
-> [ “OPERATOR”. IDENTIFIER.%text, “ViSPECIFICATIONVn”. 
package_specification.generic_type_declarations, ‘Ni”, 
basic_(leclarative_iteins.input_paiaineters, 
basic_deciarative_iteins.outpat_paiameters, 
basic.declarative iieins.excepiions, 

“ENDNn”] 

# (‘TYPE ", IDENTIFIER.%text. ‘NjSPECIHCATION'n”, 

package_specification.gaieric_type_declaiations. ‘^n”, 
basic_declarativeJlems.Qrpc_dTOlaraiions, 
basic.deciarative ileins.operator specifications, 

•TNDVnl; 

I PACKAGE IDENTIFIER IS basic.declarativejieins PRIVATE 

basic.declarativejtems END IDENTIFIER 
(package_specification.psdl_interface_specification s 
basic_dKlatativeJtemsjiumber_of_(^}erators — 1 
-> [ “OPERATOR ”, IDENTIFIER.%tcxt, “VoSPECinCATIONNn”, 
package_specification.generic_types_declarations, ‘Ni”, 
basic_declarative_iteinsjnput_paiaineters, 
basic_declarativeJteins.output_parameters, 
basic declarative items.exceptions, 

“ENDNn”]; 

# [ “TYPE ”, IDENTIFIER.%lext, ‘•^nSPECIFICATIONVn". 

package_specification.generic_type_declarations, “Sn”, 

basic_declarative_items.type_dKlarations, 

basic_declarative_itenis.o{»ratcr_specificauons, 

“ENDyn"];} 


Figure 4.4; Example of Attribute grammar and equations 


28 









B. MAPPING ADA TO PSDL 


An Ada specification will be translated into either a PSDL operator or PSDL type 
depending on the number of procedures and functions declared in the specification. If only 
one procedure ot function is declared, the specification is translated as a PSDL operator 
using the template in Figure 4.5. The operator will be given the name of the procedure or 
function name in the Ada specification. If the specification contains 0 or 2 or more 
procedures or functions, the specification is mapped to a PSDL type using the template in 
Figure 4.6. The type will be given the name of the Ada package. 


OPERATOR 

SPECIFICATION 

GENERIC 

generic_parameter_declarations 

input input_parameters 
output output_parameters 
exception.declarations 
END 


Figure 4.5: Operator Template 


TYPE 

SPECmCATION 

GENERIC 

generic_parameter_declarations 

type.declarations 

operator_spedfications 

END 


Figure 4.6: Type Template 










vaiiable.names 

• 

• 

GENERIC VALUE 





Rgure 4.7: Example of a generic_parameter_declarations Template 
Each generic declaration in the Ada specification is translated into a single PSDL 
generic type or built into a composite generic type. Generic value and object parameters 
declared in the Ada specification are translated into a single PSDL generic type. The 
parameter name is the same as the parameter in the Ada specification and the type is 
translated as GENERIC_VALUE. Generic type parameters declared in the Ada 
specification are also translated into a single PSDL generic type if they are not part of a 
generic array type definition. The parameter name is the same as the parameter in the Ada 
specification and the type is translated as GENERIC.TYPE. If the index and element part 
of an array type parameter ar-'- generic parameters, they are incorporated into the definition 
of the array type of P ciDL. For example given the following Ada declaration: 
generic 

type ELEMENT is (o); 

type LIST is array (INTEGER range o) of ELEMENT; 

only one PSDL generic type will be translated from the two generic Ada parameters as 
follows: 

UST: GENERIC.TYPE [ BASE.TYPE: ARRAY [ 

ELEMENT: DISCRETE, INDEX : INTEGER ]] 

Generic subprogram parameters declare<^ in the Ada specification are translated into a 
single generic PSDL type . The parameter name is the same as the name given in the Ada 
specification, with the exception of overloaded functions named with symbols. Operator 
symbols are translated into strings. For example, a generic subprogram named wid be 
renamed to “add”. The type is translated as GENERIC_PROCEDURE. 


30 








C. EXPLANATION OF ATTRIBUTES 


The following is a brief description of the attributes used to build the PSDL interface 
specification generator. 

1. psdl_interface_spedfication 

The attribute psdl_interface_specification is the highest attribute and stores the 
result of the translation. The translation is written to a file named with the Ada package 
name concatenated with the suffix “.psdl”. 

2. file_name 

The attribute file_name is a synthesized attribute which provides the name of the 
file the translation is written to. 

3. generic_type_declarations 

The attribute generic_type_declarations is a synthesized string which builds the 
generic portion of the PSDL specification. 

4. nuinber_of_operators 

The attribute number_of_operators is a synthesized integer used to determine if 
the PSDL specification is that of an operator or a type. This attribute counts the number of 
procedures and functions declared in the Ada specification. If only one procedure or 
function is declared, the operator template. Figure 4.5, is used to build the specification, 
otherwise the type template. Figure 4.6, is used to build the specification. 

5. operator_specification 

The attribute operator_specification is a synthesized string which builds the 
operator specifications for a type declaration. 


31 





6. type_declanitions 

The attribute type_declarations is used to build the non-generic type declarations 
of the PSDL specification. In this implementation only private type declarations are 
translated. They are translated to the type ADT. 

7. input_parameters 

The input_parameters attribute is used to build the input parameters for each 
operator in the PSDL specification. Ada in and in out variables of procedures and functions 
become the input parameters for a PSDL operator. The name and the type name of a PSDL 
input will be that of the coiiesponding Ada parameter. 

8. outputjparameters 

The output_parameters attribute is used to build the output parameters for each 
operator in the PSDL specification. The name and the type name of a PSDL output will be 
that of the corresponding Ada parameter. 

9. exceptions 

The attribute exceptions provides the exception declarations for a PSDL operator 
interface. Type interfaces do not have exceptions declarations included with the operators 
in this implementation. 

10. variable_type 

The attribute variable_type is a synthesized string which provides the type name 
for variables declared in the generic portion and type declaration of the PSDL specirication. 

11. variable_nanie 

The attribute variable_name is a synthesized string which provides the name for 
each input/output parameter of an operator. 


32 







12. mode 


The attribute mode is a synthesized map used to determine if there are any input 
or output parameters to an operator specification. It is used to modify the template in 
Figures 4.5 and 4.6. If there are no input parameters, the fixed input portion of the template 
is to be eliminated. If there are no output parameters, the output portion is eliminated. 

13. mode_check 

The attribute mode_check is an inherited map which is used to initialize the 
attribute mode to a default value of empty string. 

14. current_mode 

The attribute current_mode is a synthesized string used to determine if a comma 
is required between two parameters. 

15. composite_types 

The attribute composite_types is an inherited map which is used to determine if a 
generic type declaration in the ada specification is the index or element type of an array 
declaration. This information is used to build an array declaration in the PSDL. 

16. new_composite_types 

The attribute new_composite_types is a synthesized map which is built to provide 
the value of the map composite_types. 

17. generic_types 

The attribute generic_types is an inherited map which provides the type name for 
the index and element part of an array declartion. 

18. new_generic_types 

The attribute new_generic_types is a synthesized r.iap which is built to provide 
the values of the map generic_types. 


33 





19. comma 

The attribute comma is a synthesized string used to determine if a comma is 
needed between two generic parameters. 

D. SAMPLE INPUT AND OUTPUT 

Two samples of Ada specifications used as input and the respective PSDL interface 
specifications generated are shown below. The rirst example is translated into a PSDL 
operator, the second into a PSDL type. 

1. Operator Example 

The first example in Figure 4.8 shows an Ada specification for a generic package 
which contains one subprogram and four generic parameters. The generated PSDL 
specification is shown in Figure 4.9. The PSDL specification is an operator and contains 
two generic parameters. The operator specification was a result of only one subprogram 
being declared in the Ada package. The three generic parameters in the Ada generated one 
type derinition in the PSDL. This is because the types ITEM and INDEX are used to define 
the array ITEMS. 


generic 

type ITEM is private; 
type INDEX is (<>); 

type ITEMS is array (INDEX range o) of ITEM; 

with function “<“ (Left: in ITEM; Right: in ITEM) return BCX)LEAN; 

package Bubble.Soit is 

procedure Sort (The_Icems: in out ITEMS); 
end Bubble.Sort; 


Figure 4.8: Ada Specification for generic bubble sort package 


34 







OPERATOR Bubble_Sort 
SPECDFICATION 
GENERIC 

ITEMS : GENERIC_TYPE [ BASE_TYre: ARRAY[ARRAY_ELEMENT; PRIVATE. 

ARRAY.INDEX: DISCRETE ] ], 
less_than: GENERIC.PROCEDURE 

input The.Items: ITEMS 
output Thejtems: ITEMS 
END 


Figure 4.9: PSDL output for Ada generic bubble sort package 


with text_io; use text_io; 
generic 

type t is private; 

block.size: in natural := 128; 

with procedure eq (x,y: in t; v: boolean); 

package sb_set_pkg is 
type set is private; 

type index.airay is array (natural range o) of natural; 
pnxedure empty (s: out set); 
procedure add (x: in u si: in set; so: out set): 
procedure remove (x: in out t; s: in out set); 
procedure monber (x: in t; s: in set; b; boolean); 
procedure union (sl.s2: in s^ s3 : out set); 
procedure difference (sl.s2; in set; s3 : out set); 
precedure intersection (sl.s2: in set; s3; out set); 
procedure size (s: in set; v; out natural); 
procedure equal (sl,s2: in set; v; out boolean); 
procedure subset (sl.s2: in set; v. out boolean); 

private 

type link is access set; 

type elements_type is array (l..block_size) of t; 
type set is 
ream! 

size: natural0; -The size of the set 
elements: elements_type; -The actual elements of the set 
next: link := null; -Tlie next node in the list 
end record; 

-Elements (l..min(size,block_size)) contains data 
end sb_set_pkg; 


Figure 4.10: Ada Specifiation for generic set 


35 








2. Type Example 

The second example in figure 4.10 shows an ada specification for an abstract data 
type the “set”. The generated PSDL specification is shown in Figure 4.11. Because there is 
more than one subprogram declared in the Ada, the resulting PSDL specifcation is for a 
type. The example shows the translation of generic type, value, and subprogam parameters. 
The private type declaration, set, translated K) ADT in PSDL. All subprograms were 
translated to operators. 


TYPEsb set_pkg 

OPERATOR intersection 

SPECmCATION 

SPECIFICATION 

GENERIC 

input si, s2: set 

C GENERIC TYPE, 

output s3: set 

block size: GENERIC VALUE, 
eq: GENERIC_PROCEDURE 

END 

OPERATOR size 

set: ADT 

SPECfflCATION 


input s: set 

OPERATOR empty 

output v: natural 

SPECfflCATION 

END 

ouq)ut s: set 

END 

OPERATOR equal 

SPECmCATION 

OPERATOR add 

input si, s2: set 

SPECmCATION 

output v: boolean 

input x: t, si: set 
output so: set 

END 

END 

OPERATOR subset 
SPECmCATION 

OPERATOR remove 

input si, s2: set 

SPECfflCATION 

output v: boolean 

input x: t, s: set 

END 

ouqjut x: t, s: set 

END 

END 

OPERATOR member 

SPECIFICATION 


input x: t, s: set, b: 


OPERATOR union 

SPECIFICATION 


input si, s2: set 
ottq>ut s3: set 


END 


OPERATOR difference 

SPECIFICATION 


input si, s2: set 
output s3: set 


END 



Figure 4.11: PSDL output for Ada generic set package 


36 





E. LIMITATIONS 


Ada is not case sensitive whereas Kodiak is. This presents a problem in parsing legal 
expressions in Ada. For example, the terminal symbol PACKAGE was defined to match 
any occurence of “package” or “PACKAGE” in the input string. However, it is legal in Ada 
to use a mixture of upper and lower case. This will not be selected as a match in this 
implementation. The way around this is to run all Ada specifications through a pretty 
printer first. 

This implementation does not include the grammar for the entire Ada language. The 
grammar selected includes Ada package specifications and generic specifications. This 
implemention does not include keywords, descriptions, exceptions for type declarations, 
and OBJ3 axioms. Keywords and descriptions are not used for query by specification, but 
are required for keyword search and browser, respectively. 


37 










V. CONCLUSIONS 


The use of reusable software components will be crucial to the successful 
development of large software systems. One of the major problems in code reuse is the lack 
of a large library of reusable software components. This problem is aggravated by the fact 
that more effort is required to build a generalized component for reuse then to build one for 
a specific application. A reusable component must be sufficiendy powerful to accomodate 
a wide range of applications. A second problem with code reuse is concerned with the 
storage and retrieval of reusable components. Specifically, to automate component 
retrieval, it is necessary to accurately specify the component’s functionality. The CAPS 
system is designed to exploit code reuse for rapid prototyping of hard-real time systems. 
The prototype is built in part by the automated retrieval of reusable Ada components. 

A. ACCOMPLISHMENTS 

As a part of this thesis, reusable Ada components were selected and prepared for 
inclusion in the CAPS software base. However, these components represent a small subset 
of the thousands of components which will be required. Another way to build up the 
number of components in the CAPS software base is to adopt components which are 
already being used in other software libraries. To store these components in the CAPS 
software base they will need to be specified in PSDL. It is important to accurately specify 
a component’s functionality in PSDL since the key to successful retrieval is this 
specification. We have developed a translation tool that is able to generate in part the PSDL 
specification for Ada components. 

B. FUTURE WORK 

There is still a tremendous amount of work which needs to be done in this very labor 
intensive area of building reusable components. Depasquale [3] addresses the issue of 
automating the production of test programs based on a component’s formal specification. 
More work could be done in this area to aid in component testing. If a component is built 


38 





based on a foimal specification then it should be easier to test the component and at least 
part of the Ada code may be automatically generated (see Reference 15). 

The translator should be expanded to include at least some of the limitations addressed 
in Chapter FV. 

The opportunity and benefits for reuse are real. Building systems from reusable 
components should result in higher quality and more reliable systems. CAPS is one 
example of a system realizing these benefits. 


39 




APPENDIX A. ADA SPECfflCATIONS FOR REUSABLE COMPONENTS 


A. UNBOUNDED_SET 


-• Title: CS^530 PROJECT l“UNBOUNDEDSET“ 

Author: Erhan SARIDOGAN 

Mbdificadons: Procedure add modidsd March 92 by J.M. Sealander to prevent replicate 
-^elements being added to a set, procedure remove and function difference added to pkg. 

Date: November,8.1991 
-• Course: CS - 4530 
System: Unix 
Com^nler: Verdixada 

-* Description: This generic package provides to create and manipulate 
unbounded matheinatical set of a given type. 

It has two generic parameters,£lement_Type and function 
-• EquaLThe I/O procedures need to use generic procedures. 

Type Unbounded.Set is declared as private ty^. 

-* AJd the required operations are available in the package 
Link list stmcoire is used to provide unlimited entry. 


with TEXT 10; 
useTEXTJO; 

generic 

type ELEMENT_TYPE is private; 

with function EQUAL( X. Y: ELEMENT.TYPE) return BOOLEAN is 
package UNBOUNDED.SET.PKG is 
type UNBOUNDED.SET is private; 

- This array is needed to initialize a set variable with given values 

type SET_ARRAY is array (NATURAL range o) of ELEMENT.TYPE; 

INVALID_SET_ENTRY. 

REPEAIED.ELEMENT; exception; — used in I/O 

- Operations on sets ( The requited ones) 
function EMPTY return UNBOUNDED.SET 

procedure ADD( X : in ELEMENT.TYPE; S: in out UNBOUNDED.SET); 
procedure REMOVE( X; in ELEMENT.TYPE; S : in out UNBOUNDED.SET); 
function MEMBER( X: ELEMENT.TYPE; S: UNBOUNDED.SET) return BOOLEAN; 
function UNION( SI. S2: UNBOUNDED.SET) return UNBOUNDED.SET, 
function INTERSECTION( Si. S2; UNBOUNDED.SET) return UNBOUNDED.SET. 
function DIFFERENCE( S1. S2: UNBOUNDED.SET) return UNBOUNDED.SET; 
function SUBSET( SI, S2: UNBOUNDED.SET) return BOOLEAN; 
function EQUAL( SI, S2; UNBOUNDED.SET) return BOOLEAN; 


40 







fun-.uv.. S1Z£( S : UNBOUNDED_SET) retum NATURAL; 
function INrnALIZE( A: SET_ARRAY ) retum UNBOUNDED_SET; 

- Input/output routines 

~ These routines must be instantiated by using diffemt parameter 

- ptocedises for each different Element.Type. 
generic 

with procedure G PUT( X: in ELEMENTJTYPE) is o; 
procedure GEN_PUT( S : in UNBOUNDED.SET); 

generic 

with procedure G_GET( X: out ELEMENT_TYPE) is o; 
procedure GEN_GET( S : out UNBOUNDED_SET); 

generic 

with procedure G PUT FILE( FILE: in FILE TYPE; 

X:inELEMENT TYre)iso; 

procedure GEN_FILE_PUT( FILE: in FILE_TYPE; S : in UNBOUNDED.SET); 
generic 

with procedure G_GET_FILE( FILE : in FILE_TYPE; 

X : out ELEMENT TYPE) is o; 

procedure GEN_FILE_GET( FILE: in FILE.TYPE; S ; out UNBOUNDED.SET); 


private 

type ELEMENT; 

type UNBOUNDED.SET is access ELEMENT; 

type ELEMENT is 

record 

NODE: ELEMENT.TYPE; - contains the element 
NEXT: UNBOUNDED_SCT:» null; - used in link list 
end record; 

end UNBOUNDED.SET.PKG; 


41 





B. BOUNDED MULTISET 


-Title: Generic specification for bounded.muitisets 
"Author: WilUam D. Reese 

-Modificatioa: Modified by JAl. Seaiander Apr 92. The original data structure kept muiitple copies 
-of any repealing elements. The data structure was changed to keep a count of each element rather than 
-keeping multipre copies. Get and put operations were removed from the test package and added 
-to specification. Last_Element and The_Element were removed from the package specificadons 
-and ate now local to the body. They reflect the implementauon method, not the data type. 

-Overflow excepdon added to proc^ure Add Funcdon empty_set removed 
- and replaced with empty.set constant. 

-Date: October 12,1991 
-Course: CS-4530 (Prof. Luqi) 

-System: UNDC 
-Compiler: VERDIX 


• BOUNDED.MULTISETS 


generic 

type ELEMENT TYPE is private; 

MAX.SIZE; POSITIVE; 

with procedure PUT(X: ELEMENT_TYPE); 
with procedure GET(X; out ELEMENT_TYPE); 


SPEC 


package BOUNDED.MULTISETS is 
-Purpose 

-This package provides facilities for implementing bounded multisets 
-as atetract data types (AOT). Operadons provide include an empty 
-set constant, funcdons for adding, removing, and counting elements, 
-as well as comparison for equality between two bounded multisets. 


type BOUNDED.MULTISET is private; 


Count 


SPEC 


function Count (THE BOUNDED MULTISET; in BOUNDED.MULTISET 

ELEMENT.OF.INTEREST; in ELEMENT.TYPE) return NATURAL; 


Add 


SPEC 


procedure Add (ELEMENT TO BE ADDED; in ELEMENTJTYPE; 

THE.MULTISET: in out BOUNDED.MULTISET); 


Remove 


SPEC 


42 




















Dfocedure Remove (ELEMENT_TO_BE_REMOVED: in ELEMENT_TYPE; 

THE_MULTISET: in out BOUNDED_MULTISET); 


Equals 


SPEC 


function Equals (SET_1, SET_2: in BOUNDED_MULTISET) return BOOLEAN; 


Size 


SPEC 


function Size (THE_MULTISET; in BOUNDED_MULTISET) return NATURAL; 


. PutMultiset 


SPEC 


procedure Put_Multiset (MULTISET: in BOUNDED_MULTISET); 


. Get_Multiset 


SPEC 


function Get.Multiset (NUMBER_OF_ELEMENTS: in NATURAL) 

return BOUNDED_MULTISET; 


NOT_FOUND: excqttion; 

OVTOFLOW: exception; 

private 

type ELEMENT_RECORD is 
record 

ELEMENT: ELEMENT_TYPE; 

COUNT: NATURAL:» 0; 
endrectnd; 

^pe LIST is array (INTEGER range o) of ELEMENT_RECORD; 

type BOUNDED_MULTISET is 
record 

THE.ELEMENTS: UST(L.MAX SEE); 

HOW_FULL: NATURAL := 0; 
e nd rec ord; 

EMPTY SET: constant NATURAL :=0; 

end BOUNDED.MULTISETS; 


43 

















C. BOUNDED GRAPH 


with TCXTJO; 
use lEXT_IO; 


« m 

* Bounded.Gn^h * 

* * 


SPEC 


generic 

type NODE_TYPE is private; 
max_size: integer; 

package Bounded_Graph is 

-Purpose 

~ The routines in this package deal with a directed graphs with a number of 

- nodes <= max.size, which is established at instantiation. The package 

- specification contaions the followings functions and procedures. 

~ add_a_node 

- add_an_edge 

- icmove_an_edge 

- rcmove_a_node 

- nodes_coimected_in 

- nodes_connected_out 

- nodes.connected 

- gr^h.empty 

-Notes 

- max_size should be only a positive integer number 

- NODE_TYPE is a user defined type 

-Exceptions 

- DUPLICATE.NODE - Raised if a duplicate node is added to the graph. 

- NODE_NOT_FOUND - Raised if a node passed in is not in the graph. 

- GRAPH_IS_FULL - Raised if a node is a^ed to a full gr^h. 

- GRAPH_IS_EMPTY - Raised if any operation except add_a_node and graph_empty 

- is attempted on an empty graph. 

- Modifications 

- 11/13/91 Michael D. O’Loughlin Initial version of specification. 

- UNIX version Verdix Ada, Naval Postgraduate School 

- 02/92 JM. Sealander Original vosion was a machine with state variable graph declared in 
-specification. State variable removed and parameter of type Graph.iyp.F^ added to all functions 
-and [HDcedures. An operator which returns an empty graph was added and overflow exception 
—was added to a local procedure which is called by the add operation. 

type Graph_Typ_Ptr is private; 

DUPUCATE NODE, 

NODE NOT.FOUND, 

GRAPHJS.FULL, 

GRAPH_IS_EMPTT: exception; 


44 







SPEC 


. Graph_Empty . 


function Graph_Empty(GRAPH: in Graph_'IVp_Ptr) retum boolean; 
-Pu^se 

~ This function will check if the graph matiix is empty (no nodes on the graph) 


NodesConnected 


SPEC 


procedure Nodes_Connected(graph: in out Graph_’iyp_Ptr, 

a_node, b_node: in NODE_TYPE; 
conn: out CONNECTION); 

“Purpose 

- This function will check if two two nodes are connected. 


! Add_A_Node ! SPEC 


procedure Add_A_Node(graph: in out Graph_'IVp_Ptr, node: in NODE_TYPE); 
“Purpose 

~ This procedure will add a node to the graph (adjacency matiix). 


. Add_An_Edge . SreC 


procedure Add_An_Edge(Graph; in out Graph_'I^_Pir, 

a_node, b_node; m NODE_TYPE); 

“Purpose 

~ This procedure will add an edge between the two node passed in. 


. Nodes_Connected_Out . SPEC 


procedure Nodes_Connected_Out(graph: in out Graph_’IVp_Ptr, 

node: in NODE_TYPE; 
out_nodes: out NODE_COU NT; 
node.connected: out CONNECTED_NODES); 


45 



















--Purpose 

— This procedure will pass out all nodes and the number of nodes connected, 
~ to the node passed in, by an out edge. 


. Nodes_Connected_In 


SPEC 


procedure Nodes_Connected_In(Graph: in out Gr^h_TVp_Ptr; 

node: in NODE_TYPE; 
in_nodes: out NODE_COUN T, 
node.connected: out CONNECTED_NODES); 


-Purpose 

- This procedure will pass out all nodes and the number of nodes connected, 

- to the node passed in, by an in edge. 


. Remove_Edge 


SPEC 


procedure Remove_Edge(graph: in out GraphJIVp.Ptr; 

a_node, b_node: in NODE_TYPE); 


-Purpose 

- This procedure will remove an edge between the two nodes passed in. 


Rcmove_Node 


SPEC 


procedure Reniove_Node(graph: in out Graph_'iyp_Ptr, 

node: in NODE_TYPE); 


-Purpose 

- This procedure will remove the node passed in from the gr^h and remove all its 

- relatra edges. 

private 

subtype NODE COUNT is integer range 0..max_size; 

type CONNECTED.NODES is array (NODE.COUNT) of NODE.TYPE; 

type CONNECTION is (in_edge, out_edge, in_out_edge, not_connected); 

type NODE_STATUS_TYP is 
record 

empty: boolean true; - Empty node if true, 
nodejd: NODE_TYPE; - User defined data structure. 
endreccMnd; 

type NODE INDEX ARRAY TYP is - One dimensional array containing all nodes, 
array (NODE.COUNT) of NODE_STATUS_TYP; 
type GRAPH MATRIX_TYP is - Graph adjacency matrix, 
array (NODE.COUNT, NODE_COUNT) of boolean; 


46 

















type Graph_'IVp is 
reoxd 

Number_of_nodes: NODE_COUNT := 0; 

Nodes: NODE_INDEX_ARRAY_TYP; 

Graph.matrix; GRAPH_MATRIX_TYP;= (others =>(oihers =>tnie)): 
end record; 

type Graph_Typ_Ptr is access GRAPH_TYP; 

einpty_£raph: NODE_COlJNT := 0; - Node € 00010 * for graph. 


end Bounded_Grrg)h; 


47 






D. UNBOUNDED GRAPH 


* 4t 

* Unbounded_Graph * SPEC 

* » 


generic 

type ELEMENT_TYP is 
[Hivate; 

package Unbounded.Graph is 

- PURPOSE: This generic package implements an unbounded directed 

- graph type. 

- INITIALIZATION EXCEPTIONS: none 

" NOTES: The graph is represented by a set of distinct nodes, 

- with each node having an edge list composed of a set of 

- distinct nodes. A directed edge exists between a node in the 

- graph and aU nodes in it’s respective edge list 

- MODinCAnONS: 

» 11/lS^l J.L. Budnick Initial build. 

- OS^ modified by J.M. Sealander. An adjacency node in the original structure pointed to a graph 

-node to identify an adja^nt vertex. This pointer was removed and replaced with the node element. Type 
-declarations to build the data type were moved to the private section. 

type GRAPH_TYP is 
private; 

INPUT_NODE_DOES_NOT_EXIST: excepUon; 


Is_Empty SPEC 


function Is_Empty(Graph: GRAPH_TYP) return BOOLEAN; 


- PURPOSE: 

- Returns TRUE if the input Graph is empty, FALSE if it is not 

- EXCEPTIONS: none 

- NOTES: ncmc 

- MODIFICATIONS: 

- 11/1 S/91 JX. Budnick Initial build 


Add_Node 


SPEC 


procedure Add_Node(New_Node : in ELEMENT_TYP; Graph; in out GRAPH_TYP); 

- PURPOSE: 

- Ad ds a N ew_Node of type ELEMENT_TYP to the input Graph. 

- EXCEPTIONS: none 

- NOTES: 

- If a node is found in the Graph which is a duplicate of 


48 








~ the New_Node, the Graph will remain unaltered. 

- MODMCATIONS; 

- ll/lS/91 JJ.. Budnick Initial build 


Remove_node . 


SPEC 


procedure Remove_node(Node; in ELEMENT_TYP; Graph: in out GRAPH_TYP); 

-- PURPOSE: Removes Node from Graph. 

~ EXCEPTIONS’ 

- INPUT_NODE_DOES_NOT_EXIST is raised if Node is not found in 
“ Graph. 

“ NOTES: All lefoences to Node are removed from Graph, even 
" references in other Node’s edge lists. 

- MODMCATIONS: 

- 11/15/91 Ji. Budnick Initial budd 


Add.Edge ! SPEC 


procedure Add_Edge(From Node; in ELEMENT_TYP; 

To.Node: in ELEMENT_TYP; 

Grtg)h: in out GRAPH_TYP); 

-- PURPOSE: Adds a directed edge between From_Node and To_Node 

- within Graph. 

-- EXCEPTIONS: 

INPUT_NODE_DOES_NOT_EXIST is raised if From_Node or To.Node 
" is not found in Grtq)h. 

- NOTES: If To_No^ is already an element of From_Node’s edge 
" list, the gn^h rmains unaltered. 

- MODMCATIONS: 

- 11/15/91 JI.. Budnick Initial buUd 


. Remove_Edge . SPEC 


procedure Remove_edge (From_Node: in ELEMENT_TYP; 

To_Node: in ELEMENT_TYP; 

Graph: in out GRAPH_TYP); 

- PURPOSE: Removes an edge between From_Node and To_Node in the 

- given Graph. 

- EXCEPTIONS' 

- INPUT_NODE_DOES_NOT_EXIST is raised if From.Node is not 
-- found in Graph <x if To_Node is not found in From_Node’s edge 

- list 

- NOTES: none 

- MODMCATIONS: 

--11/15/91 JL. Budnick Inidal build 


49 













Has_An_Edge . 


SPEC 


function Has_An_Edge (From_Node: ELEMENT_TYP; 

To.Node: ELEMENT.TYP; 

Graph: GRAPH.TYP) 

leoim BOOLEAN; 

~ PURPOSE: Determines if an edge exists between the two input 
~ nodes of the given Graph. 

-EXCEPTIONS: 

- INPUT_NODE_DOES_NOT_EXIST is raised if From_Node or To_Node 

- is not found in Graph. 

- NOTES: ntme 

- MODinCATIONS: 

- ll/lS/91 Jl.. Budnkk Initial build 


Set_Of_Outgoing_Edges 


SPEC 


function Set_Of_Outgoing_Edges (From_Node: ELEMENT_TYP; 

Graph: GRAPH.TYP) return NODE_SET_PTR; 

- PURPOSE: Reuims the set edges outgoing firom the given 
"From Node in Graph. 

-EXCEPTIONS: 

- INPUT_NODE_DOES_NOT_EXIST is raised if From.Node 

- is not found in Graph. 

- NOTES: An outgomg edge set is composed of the set of all 

- nodes which have dirot^ edges coming from the From_Node to 

- those in the set 

- MODIFICATIONS: 

- llAS/91 JI.. Budnick Initial build 


Set_Of_Incoming_Edges 


SPEC 


function Set Of Incoming_Edges (To Node: ELEMENT_TYP; 

Graph: GRAPH.TYP) return NODE_SET_PTR; 

- PURPOSE: Returns the set of edges incoming to the given To.Node 

- in Graph. 

- EXCEPTIONS* 

- INPUT_NODeLdOES_NOT_EXIST is raised if To.Node 

- is not found in Graph. 

- NOTES: An incoming edge set is composed of the set of all 

- nodes which have dir^ted edges fiom themselves to the 

- To_Node. 

- MODfflCATIONS: 

- 11/15/91 JJL. Budnick Initial build 


50 










Set_Of_All_Nodes 


SPEC 


function Set_Of_AU_Nodes (Graph; GRAPH.TYP) return NODE_SET_PTR; 

~ PURPOSE: Returns the set of all nodes in the input Gr^h. 

-- EXCEPTIONS: none 

~ NOTES: The returned node set is simply the complete set of 
~ nodes in Graph, and contains no interreiationship data. 

- MODMCAnONS: 

~ ll/lS/91 JI^. Budnick Initial build 

private 

typeGRAPH.NODE; 
type GRAPH_TYP is 
access GRAPH_NODE; 

type EDGE:_ 

type EDGE_PTR is 
access EDGE; 

type EDGE is 
record 

Edge_node: ELEMENT.TYP; 

Next_Edge: EDGE_PTR := mill; 
endreoHd; 

typeGRAPH.NODEis 

record 

Element: ELEMENT TYP; 

Next_Node: GRAPH.TYPnull; 

Edges: EDGE.PTR := null; 
end record; 

EMPTY_GRAPH: constant GRAPH.TYP := nuU; 
end Unbounded.Graph; 


51 








E. UNBOUNDED_MAP 

~ Name: Capt Robert M. Dixon 
-- Date: 15 Nov 91 

~ Modifications: Modified by J. M. Sealander Feb 92. In the orignial version 

- NUM.BH^INGS and Nl^I_BLOCKS were state variables dtelared 

- in the p^kage body. Erroneous dam resulted if more than 

-• one vviable of MAP_TYPE was declared. They are now part 
~ of the MAP_TYPE data structure. 

-- Course: CS4530 

- Compiler Vndix Ada 6.0 
~ System: Solboume 

~ Title: Mig)_Package 

~ Remarks: M^.Package implements an unbounded map using a generic Ada package. 

- The package is instantiated with a hash function, which reuims an index 
-• into the hash table, based on the domain value. If the index lies outside 

- the range of the map, it links in new map blocks until the index falls 
-• on a block in the map. 

-• The domaip^ange value is added to the head of a linked list whose head 
~ pointer is stored in the map block, at the index pointed to by the hash 
-ninction. 

~ Generic Parameters: DOMAIN.TYPE is the desired type of the domain. 

- RANGE_'nTE is the desired tj^ of the range. 

- Hash is the user’s hashing function. 

~ Domain_Put is a put prockhire f(»^ the domain type. 

- Range_^t is a put procedure for the range tj^. 

>• Doinain.Get is a get procedure for the domain type. 

- RangejGet is a get procedure (or the ran^e type. 

•• Granularity mecifies how many values will be stored in 

- each block of the hash table. 

generic 

type DOMAIN_TYPE is private; 
type RANGE_TYre is private; 

with function Hash(Doinain_Value: in DOMAIN_TYPE) return NATURAL; 
with procedure Domain_Put(Domain_Value: in DOMAIN.TYPE); 
with procedure Range_Put(Range_Value: in RANGE_TYPE); 
with procedure Dornain_Get(Domain_Value: out DOMAIN_TYPE); 
with procedure Range_Get(Elange_Vsdue: out RANGE_TYPE); 

Granularity: in INTEGER :3 100; 
package Map.Package is 

~ MAPJTYFE is the Qme that the package user will use to declare a map. 

~ MAP_BINDINGS_TVPE is the type used to store the number of bindmgs in the map. 
~ Add adds a new domaitiAange pair to the map. 

- Rar^.Value returns the range value associated with the domain.value parameter. 

- Is.Bound returns true if the domain_value is in the table. 

~ Number_Of_Bindings renims the number of bindings in the map. 

~ Remove.Binding removes a domainAange pair from the map. 

~ Put prints out the attire map. 

~ Get gets the entire map. 

•• Empty.Map is an empty map constant. 

- Domain.Exists is raised if a dimlicate domain is insoted into the map. 

~ Dotnain_Not_Fbund is raised if a domain is not found in the map. 


52 





type MAP TYre is private; 

type MAP_BIND1NGS_TYPE is new NATURAL; 

pfocedure Add(Map: in out MAP_TYPE; Domain_Value; in DOMAB^_TYPE; 

Range_Value: in RANGE_TYPE); 

function Range_Value(Mq): MAP_TYPE; Domain.Value: DOMAIN_TYPE) 

return RANGE_TYPE; 

function Is_Bound(Map: MAP_TYPE; Domain.Value: DOMAIN_TYPE) return BOOLEAN; 
function Nuinber_Of_Bindings(Map: MAP_TYPE) return MAP_BINDINGS_TYPE; 
procedure Reinove_BindingO(<^: in MAPJTYPE; Domain.Value: DOMAIN_TYPE); 
procedure Put(Map: in MAP_T^E); 
procedure Get(Map: in out MAP_TYPE); 

Empty.Map: constant MAP_TYre; 

Domain.E^ts: exception; 

Domain_Not_Found: exception; 

private 

type MAP_RECORD_TYPE is 
recffld 

Domain.Value: DOMAIN_TYPE; 

Range_Value: RANGE_TYPE; 
end record; 

type MAP RECORD NODE TYPE; 

type MAP RECORD NODE.PTR TYPE is access MAP_RECORD_NODE_TYPE; 
type MAP_RECORD_NODE_TYPE is 
record 

MapJlecord: MAP.RECORD TYPE; 

Next_Node: MAP_RECORD_NODE_PTR_TYPE; 
end record; 

type MAP.ARRAY.TYPE is artay(0.. Granularity -1) of MAP RECORD_NODE PTR.TYPE; 
type MAP BLOCK TYPE; 

type MAP_BLOCK_PTR_TYPE is access MAP BLOCK TYPE; 
type MAP.BLOCK.TYPE is 
recod 

Map_Anay: MAP ARRAY TYPE; 

Next_Block: MAP_BLOCK_PTR_TYPE; 
end record; 

type MAP_HEAD_TYPE; 

typcMAP_TYPE PTR is access MAP HEAD_TYPE; 
type MAP_HEAD_TYPE is 
record 

NUM_BINDINGS: MAP_BINDINGS_TYre := 0; 

NUM_BLOCKS: NATURAL :*0; 

HEAD: MAP_BLOCK_PTR_TYPE; 
end record; 

type MAP.TYPE is new MAP_TYPE_PTR; 

Empty.Map: constant MAP_TYPE := new MAP_HEAD_TYPE; 
end Mt^.Package; 


53 




REAL NUMBERS 


~ Auihor origi^ verskHi: Dogan Ozdemir 
-Author moMed version: Sealander 

-Original version used separate arrays to hold the whole and decimal part 
-of a real number. Nfodified version uses one array to hold all the digits 
-and the oiuput is normalized so that the decimal point appears after the 
-first digit 

-Local procedures elimiiuited from (uiginal version: ADD WHOLE, SUBTRACT_WHOLE, 
-M_SHIFT_LEFT. SHIFT.LEFT. SIMPLIFY, 
widi TEXTJO; 

generic 

DIGIT: INTEGER := 10; 

MAX.EXP: INTEGER := 3; 

package REAL.PKG is 

type REAL is private; 

INPUT_ERRC5r : EXCEPTION; 

-functions— 

function ADDITION (NUM1,NUM2: REAL) return REAL; 
function (NUMl J^UM2: REAL) return ^AL renames ADDITION; 


function SUBTRACTION (NMl J^M2: REAL) return REAL; 
function (NMl : REAL) return REAL renames SUBTRACTION; 


function MULTIPUCAnON (NMl : REAL) return REAL; 
function (NMl JIM2: REAL) return REAL renames MULTIPLICATION; 


function DIVISION (NMl J'4M2: REAL) return REAL; 
fuiKdon *7” (NM1,NM2: REAL) return REAL renames DIVISION; 


function EQUAL(N1 :REAL) return BOOLEAN; 


function GREATER (N1JI2 :REAL) return BOOLEAN; 
function (N1:REAL) return BOOLEAN renames GREATER; 


- This procedure gets a float and converts it to the respective 

- real number. 


function CONV_REAL (FL: FLOAT) return REAL; 
-piocedures- 


- This procedure reads the Real Number from the screen and 

- decompose it into the sign, digits and exponent 

- arrays. 

procedure GET (NUM: in out REAL); 


- This procedure puts the teal number to the screen 
procediue PUT (R : in REAL); 


54 













private 


type SIGN is (V.’-’); 

subtype DECIMALS is INTEGER range 0.. 9; 

type MANTISSA ARRAY is array (1.. DIGIT) of DECIMALS; 

type EX ^NENT.ARRAY is array (1.. MAX_EXP) of DECIMALS; 

type REAL is 
record 

SIGN.WHOLE: SIGN := *+’; 

MANTISSA; MANTISSA.ARRAY ;= (others => 0); 

SIGN EXP: SIGN :=V; 

EXPONENT: EXPONENT.ARRAY := (others => 0); 
endtecod; 

EMPTY EXP: constant EXPONENT.ARRAY := (others => 0); 
endREAL.PKG; 


55 








G. BOUNDED INTEGERS 


-• TITLE: IMPLEMENTATION OF BOUNDED INTEGERS 
-* COURSE :CS 4530 
—* AUTHOR: Medn Bald 
-• DATE: OCT^,91 

MODIFICATIONS : Modified by J. M. Sealanda Apr 92. Sub(m)grain algorithms simplified. 
-* SYSTIEM: UNIX 
-* COMPILER: VERDKADA 
-• FILE: balci/ qir5/cs453Q/big_int_spec.a 

DESCRIPTION: This generic pack^e contains the specifications 
for implementing the type bounded integenThe 
type is implemented as generic big integers with 
array iepiesentations.The generic parameter is 
-* DIGIT and it ^)ecifies the number of decimal digits 
the repiesantauon sunrartThe generic paranrieter 
is used as value generic parameter and intialized 
to 20 as default value. You can change the generic 
value in your implementation(or test)program. 

By using “lenames*’ features of ADA, the opoations 
are ovenoaded for the ntnmal operators. 

-* For equality check although a function “equals” is 
suirpoited, user can use operator for this aim. 

Tms feature is implemented in the test program. 


withTEXTJO; 

useTEXTJO*. 

generic 

DIGIT: in INTEGER > 20; 

package BOUNDED_INTEGER_ARRAY_PACKAGE is 


type BOUNDED_INTEGER is private; 


- for a given integer it returns a bounded integer,by calling this 

- function we may have operations with both types 

procedure CONVERT (NUM.VAL: in INTEGER; B_NUM: out BOUNDED_INTEGER); 

~ converts the string to a bounded integer type.User is supposed to 

- enter the big integer as a string 

procedure STRING TO_BOUNDED_INTEGER (STR :in STRING ; LNG:in INTEGER; 

B_INT :out BOUNDED.INTEGER); 


~ the addition of two bounded integers 

function ADDITION (B_INT1 :in BOUNDED_INTEGER; 

B_1NT2 ;in BOUNDED.INTEGER) return BOUNDED_INTEGER; 

function “+” (B_INT1 :in BOUNDED_INTEGER; B_INT2 ;in BOUNDED_INTEGER) 
return BOUNDED_INTEGER renames ADDITION; 


-subtraction 

function SUBTRACTION (LEFT :in BOUNDED_INTEGER; RIGHTin BOUNDED.INTEGER) 

return BOUNDED_INTEGER; 

function (LEFT :in BOUNDED.INTEGER; RIGHT:in BOUNDED.INTEGER) 
return BOUNDED_INTEGER renames SUBTRACTION; 


56 





~ muldi^catioa 

function MULTIPUCAnON (L;in BOUNDED_INTEGER; R:in BOUNDED.INTEGER) 

return BOUNDED_INTEGER; 

function (L:in BOUNDED.INTEGER; R:in BOUNDED_INTEGER) 

return BOUNDED_INTEGER renames MULTIPLICATION; 


division 

function DIVISION (DIVIDENT :in BOUNDED_INTEGER; 

DIVISOR :in BOUNDED INTEGER) return BOUNDED.INTEGER; 
function “r (DIVIDENT rin BOUNDED_INTEGER; DIVISOR :in BOUNDED.INTEGER) 
return BOUNDED_INTEGER renames DIVISION; 


- modulo operation 

function MODULO (FIRST :in BOUNDED.INTEGER; SECOND :in BOUNDED_INTEGER) 
return BOUNDED_INTEGER; 


function “mod” (FIRST rin BOUNDED_INTEGER: SECOND rin BOUNDED_INTEGER) return 
BOUNDED_INTEGffi renames MODULO; 

- returns if two bounded inte ger is equal or not 

function EQUALS (LEFTJIIGHT r in BOUNDED_INTEGER )ietum BOOLEAN; 


- returns if the first entry greater than the second oitry 

function GREATER.THAN ( X.Y r in BOUNDED.INTEGER) return BOOLEAN; 


' function “>” (X.Y r in BOUNDED.INTEGER) return BOOLEAN renames GREATER.TOAN; 


- this is the get function which is implemented for test purposes 

procedure GET (STR_TO_BOUNDED r out BOUND^_INTEGER); 


-• this is the put fimetion which is implemented for test purposes 

procedure PUT (BOUNDED_TO_STR r in BOUNDED_INTEGER); 


private 

subtype NUM_OF CHAR is INTEGER range 0..9; 
type SIGN DIGITIs 

type B INT.ARRAY TYPE is array (NATURAL RANGE 0.. DIGIT) of NUM_OF_CHAR; 
type BOUNDED.INTTCER is 
record 

SIGN;SIGN_DIGIT; 

B_INT_ARRAY; B_INT_ARRAY_TYPE; 
en^recc^ 

end BOUNDED_INTEGER_ARRAY_PACKAGE; 


57 





H. VECTORS 


“Title: Vector ADT 
"Author: Jennie M. Sealanda 
"Date: 14 November 1991 
"Course: CS-4530 
"Compiler: Veidix Ada 

"Description: Generic package fw Abstract Data IVpe VecUH: 


• VECTORS * SPEC 

I************************ 

with TEXTJO; use TEXTJO; 
generic 

type ELEMENT_TYPE is private; -vector component type, must be a 
-numeric type 

DIMENSION: in POSITIVE; --dimension of vector type 
with function “+” (X.Y: ELEMENT_TYPE) return ELEMENT.TYPE; 
-Purpose 

"This function defines addition for the numeric ELEMENT_TYPE 

with function (X.Y: ELEMENT.TYPE) retim ELEMENT.TYPE; 
"Purpose 

"This function defines subtraction fw the numeric ELEMENT.TYPE 

with function (X.Y: ELEMENT.TYPE) return ELEMENT.TYPE; 
"Purpose 

"This function defines multiplication for the numerk: ELEMENT.TYPE 

with function ZERO return ELEMENT.TYPE; 

"Purpose 

"This function defines zero fw the numeric ELEMENT.TYPE 

with function SQRT(X: ELEMENT.TYPE) return ELEMENT.TYPE; 
-Purpose 

-This function defines the square toot for ELEMENT.TYPE 

with procedure PUT(X: ELEMENT.TYPE); 

-Purpose 

-This procedure defines PUT fw the numeric ELEMENT.TYPE 

with procedure GET(X: out ELEMENT.TYPE); 

"Purpose 

—This jHOcedure defines GET for the numeric ELEMENT.TYPE 
package VECTORS is 

type VECTOR is arTay(LJ)IMENSION) of ELEMENT.TYPE; 

function (V1,V2: in VECTOR) return VECTOR; 

"Purpose 
-Vectn’ addition 


58 








function (V1,V2 : in VECTOR) return VECTOR; 

“Purpose 

-VectcM’ Subtraction 

function (VI: in VECTOR; S: in ELEMENT.TYPE) return VECTOR; 
“Purpose 

“Multiplication of a vector by a scalar 

function (V1,V2: in VECTOR) return ELEMENT.TYPE; 

“Purpose 

“Vector Dot Product, multiplication of two vectors 

funcdmi LENGTH (V; in VECTOR) return ELEMENT_TYPE; 

“Purpose 

“Returns magnitude of vector 

procedure PUT.VECTOR (V: VECTOR); 

“Purpose 

“Outputs an object of type VECTOR 

procedure GET_VECTOR (V; out VECTOR); 

“Purpose 

“Gets an object of type VECTOR 


INPUT_ERROR: exception; 

“Purpose 

“Rai^ if error in input of type VECTOR 
end VECTORS; 


59 




L MATRIX 


-Tide: Generic Matrix Package 
-Author: William C. Hoppe 
-Date: 7 November 1991 
-Revised: 

-Course: CS4530 

-System: SUN-3UNDC 

-Compiler: Vetdix Ada, VADS, Ver 6.0 

-Descripdon: Generic I^kage to implement the Abstract Data Type (ADT) 

- Matrix, and operations: convosion from an array to a 

- matrix, matrix addition and subtraction, multiplication 

- by a scalar (value of the element.type), matrix 

- multiplication, and transpose. 


generic 

type ROW.LENGTH is (o); 
type COLUMN_LENGTH is (o); 
type ITEM is private; 

with function *‘+" (X, Y: in ITEM) return ITEM is o; 
with fimction Y: in ITEM) return ITEM is o; 

with function “*** (X, Y: in ITEM) return ITEM is <>; 
package Matrix is 


type ARRAY_TYPS is array(ROW_LENGTH range o, COLUMN_LENGTH range o) of ITEM; 

type MATRIX_TYPE is anay(ROW_LENGTH range o, COLUMN_LENGTH range o) of ITEM; 

type TRANSPOSF.MATRDC TYPE is anay(COLUMN_LJENGTH range o. 

ROW.LENGTH range o) of ITEM; 


NON CONFORMABLE FOR ADDITTON.ERROR: exception; 
NON_CONFORMABLEIfOR_MULTIPUCATION_ERROR : exception; 

function Coovcrt_to_Matrix (Numerical_Array: ARRAYJTYPE) return MATRDC.TYPE; 

fiinctitm Matrix_Add (Matrix 1, Matrix2: in MATRIX_TYPE) re'oim MATRIX_TYPE; 

function Matrix.Subtiact (Matrixl, Matrix2: in MATRIX_TYPE) return MATRIX_TYPE; 

function Matrix_Multiply (Scalar: in ITEM; Matrix: in MATRIX_TYPE) return MATRIX_TYPE: 

function Matrix.Multiply (Matrixl, Matrix2: in MATRDC.TYPE; 

Initial_Value: in ITEM ) return MArRIX_TYPE; 

fimction Transpose (Matrix : in MATRIX_TYPE) return TRANSPOSE_MATRIX_TYPE; 
end Matrix; 


60 







APPENDIX B. KODIAK PROGRAM LISTING 


'.definition of lexical classes 


%define Digit 
%definelnt 
%define Lower 
%defineUppCT 
%define Letter 
%define Alpha 
%define Undoscore 
%define Blank 
%define Quote 
%define Backslash 
%define Char 


[0-9] 

{Digit)+ 

[a-z] 

[A-Z] 

({Lower} I (Upper)) 
({Letter}l{Digit}) 

r_T 

[Nf«] 

n 


"W” 

(Backslash) (Quote}l{Backslash) (Backslash)) 


Idefinition of white space comments 


:{Blank)+ 


idefinitions of compound symbols and keywords 

PACKAGE 

packagetPACKAGE 

IS 

islIS 

PRIVATE 

privatelPRIVATE 

END 

oidEND 

USE 

useiUSE 

TYPE 

typelTYPE 

PROCEDURE 

procedurelPROCEDURE 

FUNCTION 

fimctionIFUNCTION 

RETURN 

retumIRETURN 

IN 

inllN 

OUT 

outlOUT 

TASK 

taskITASK 

ENTRY 

entrylENTRY 

EXCEPTION 

exceptionEXCEPTION 

RENAMES 

lenamesIRENAMES 

CONSTANT 

constantICONSTANTI”” 

SUBTYPE 

subtypelSUBTYPE 

NEW 

newllfeW 

RANGE 

langelRANGE 

GENERIC 

genericlGENERIC 

WITH 

withlWITH 

DIGITS 

digitsIDIGITS 

DELTA 

deltalDELTA 

LIMITED 

limitedlLIMITED 

FOR 

forlFOR 

AT 

atlAT 

ALL 

alllALL 

CASE 

caseiCASE 

WHEN 

whenlWHEN 

OTHERS 

otherslOTHERS 

ACCESS 

accesslACCESS 

AND 

”&”rand”rAND” 

THEN 

thenlTHEN 

OR 

Tror”rOR’’ 

ELSE 

elselELSE 

NOT 

notlNOT 


61 













XOR 

ABS 

NULL 

EQUAL 

NEQ 

LT 

LTE 

GTE 

GT 

PLUS 

MINUS 

TIMES 

DIVIDE 

EXPONENT 

MOD 

REM 

ARRAY 

OF 

RECORD 

DISCRETE 

ARROW 

TO 

TIC 

CHARACTER.LITERAL 

STRING.LITERAL 

INTEGER_LITERAL 

REA L_LITE RAL 

IDENTIFIER 


xorIXOR 

abslABS 

nulllNULL 





>** ** 


****** 

modlMOD 

remIREM 

arraylARRAY 

oflOF 

recordIRECORD 

"o” 




(Quote) (Char)* (Quote) 

(Int) 

(Int)””(Int) 

{Letter)+(((Underscore) I Alpha)* (Alpha) )• 


%% 

lExplanations of attributes 

!psdlJnterface_specification : synthesized string, the result of the 
! translation 

loperator.specification : synthesized string, builds the operator specification 
! for psdl types 

!number_of_opcrators: ^thesized integer, counts the number of operators 
! in ada ^tecification to determine if psdl interface 

! is a type or single opmtor 

!new_composite_types: synthesized map, used to build the inherited map, 

! composite_types 

icomposite.types: inherited map, used to determine if a generic declaration 
! is part of a composite type declaration, i.e. an array type 

!new_generic_types: synthesized map, used to build the inherited map, 

! generic_types 

!generic_types: inherited map, provides the type names of the 
! index and element types for a generic array type 

!generic_type_declarations: synthesized string, builds dte generic type 
! declaration portion of psdl then inherited 

! by package_specification 

!typc_declarations: synthesized string, builds the non-generic type 
! declaration portion of p^ 


62 








!input_paraineta^ : synthesized siring, builds the input attribute of a psdl 
! operator 

!output_paraineters: synthesized string, builds the output attribute of a psdl 
! operatCH’ 

!mode: synthesized map, used to determine if tha« are any input out output 
! parameters to an opoator specification 

!mode_check: inhmted map, initializes attribute mode to default of empty 
! string 

!current_mode: synthesized string, used to determine if a comma is required 
! between two parameters 

{exceptions: synthesized string, provides exceptions declared in a single 
! operator package 

! variable_name: synthesized string, provides the name of an input or output 
! parameter 

!variable_type: synthesized string, provides the type name for variables 
! dk;lar^ in the generic portion and type declaration of the 

! PSDL specification 

{attribute declarations for nonterminal symbols 

start {psdl_interface_specification:string;); 

ada_interface( psdlJnterface_specification:string; 
file_name:string;}; 

generic.specificadon {psdl_interface_specification:string; 
generic_type_declarations:string; 
file_name:siring;}; 

generic_formal_part{ generic_type_declarations:string;); 

generic_paiameter_declarations (generic_type_deciarations;string; 
new_composite_types:string->string; 
composite_types:string->string; 
new_generic_typ«;string->string; 
genenc_types:string->string; 
commaistring; ]; 

generic_parameter_decIaration {generic_type_declarations:string; 
new_compositc_typM:string->string; 
composite_types:string->strin^ 
new_generic_types:string->string; 
generic_types;string->string; 
comma:string;}; 

generic_type_definition {variable_type:string; 

generic_types:string->string; 
new_composile_typcs:string->string;); 

private_type_declaration {generic_type_declarations;string; 
type_declarations:stnng;}; 

package.specification {psdl_intaface_specification:string: 


63 








niimber_of_operators:int; 
generic_type_decIatations:string; 
file.naine:string;); 

basic_declarative_iteins{ type_declarations:s(ring; 
q)erator_specification:string; 
number_of_operators:mt; 
input_paiainetBrs:string; 
output^j)araineters:string; 
exceptions:soing;}; 

basic_declarativejtein{ type_declarations:string; 
operalor_specification:string; 
input_paraineters:string; 
outputj)araineters:string; 
exceptk>ns:string: 
nuinoer_of_operators:int;); 

basic_declaration{ type_declaiations:string; 
opefaU>r_specification:string; 
input_paraineters:string; 
outputj>aranieters:string; 
exceptk)ns:stiing; 
number_of_operators:int;}; 

subprogram_declaration( operatar_q)ecification:string; 
iiiput_parameters:s^g: 
output_paraineters:string; 
nufnber_of_operators:inq 
exceptions:string;); 

subpn)gram_specification( operator.specijfication.-siring; 
input_paranieters:string; 
output_paiaineters:string; 
number_of.(mrat(»s:int; 
nameistiing;}; 

fonnal_part{ iiiput_parameters:string; 
outiw_paraineteis:string;}; 

designator (name:string; 

(q)aator_symbois:string->string;); 

operator_syinbol{ name:string;); 

parainetBr_specifications( input_parainetBrs:string; 
output_i»iameters:string; 
ino^:string>>string; 
mode_check:string->string; 
cunent_mode:string; ]; 

paranieter_specification( input_paranieters:string: 
output_paraineteis:string; 
inode:string->string; 
mode_che^:string->string; 
curTent_mode:string;); 

type_declarations( type_decIarations:string;); 

type_declaiation( type_declaiations:string;}; 


64 





full_type_decIaration{ type.declarationsrstring;}; 

exception_dec]aration{ exceptions:string;}; 

subtype_declaration{ type_declarations:string;); 

generic_declaration( type_declarations:string;); 

subtype_indication( vanable_type:string; 

genenc_types:string->string; 
new_composite_types:string->string; 
eleinem_type:strin^,}; 

type_definitioii( variable_type:string;); 

real_type_definition{ variable_type:string;}; 

anay_type_definition{ variable_type:slring; 

generic_types:string->string; 
iiew_composite_types:string->string;); 

unconstrained_array_definition( variable_type:string; 

generic_types:string->string; 
new_coinposite_types;string->string;}; 

constrained_array_defipition{ variable_type:string; 

generic_types:string->string; 
new_composite_types;string->string;); 

subtype_definitions( geneiic_types:string->string; 

new_coinposite_tyi)es:stiing->string; 
index.typerstring; J; 

index_subtype_definition {gencric_types:string->string; 
index.typeistring; 

new_composite_types:string->string;); 

iclentifier_list{ variable_names:string; 
excepdons:string;); 

typc_iiiaik{ variable_type:string;); 

name (variable_type:string; 
variable_naine:string; 
gencric_types;string->string; 
new_composite_types:string->siring; 
index_type:string; 
eleinent_type:string;); 


iattribute declarations for terminal symbols 

IDENTIFIER { %tcxt:siring;}; 

SrRING_LITERAL{ %text;string;); 

%% 

IProductions of the grammar 
start 

: ada.interface 

{ %output(ada_interface.psdl_inteiface_specihcation); 


65 





%outfile(ada_inteiface.file_naine, 

ada_interface.psdlJnteiface_specification);} 


ada_interface 

: context.clause generic.specification 

( ada_interface.psdl_interface_specification s 

genenc_specification.psdl_interface_specification; 
a(&_intBiface.file_naine = 
geiieric_specification^Ie_name:) 

I context_clause package.specification 

( ada_inteiface.psdl_inteiface_specification = 

|)ackage_specification.psdl_int^ace_specificauon; 
a(te_inteiface.filB_iianie = 
package_specification.file_naine;) 


c(xitext_clause 

: with clauses use_clauses 
{}" 

1 

{) 


with_clauses 

: with clauses with_clause 
()■ 

I with_clause 

0 


use.clauses 

: use clauses use.clause 

{) 

I 

{) 

t 

with_clause 

: WITH package.names 


use_clause 

: USE package names 

{} 


package.names 

; package.names name 

{) 

I name 

{) 


generic_specification 

: generic_formaI_pait subprogram_spccification 

() 

I generic_f(»rmal_j^ l^kage.specincadon 

(package_specification.generic_type_declarations s 
gencric_formal_part.generic_type_dcclarations; 


66 



generic_specification.p^_inteiface_specification = 
pack^e_specification.psdl_tnierface_specification; 
genetic_specification^le_naine = 
package_specificatk)n.file_name:) 


generic.fMinal Dan 

: GENERIC geiieric_paraineter_declarations 

(generic fomuil_pan.generic_type declarations = 

[“ GENERIOn”, 

generic_paiametBr declarations.generic_type_declarations, 

generic_parameter_declaiations.generic_types = 
generic_paiameiBr declaiationsjiew_generic_types 
+1 {(?:string:”INDEX_TYPE”)); 
generic_parameter_declarations.composite_types = 
generic_parameter_declarations.new_composite_types 
+1 {(?:string:’*no”)};} 

I 

{) 


generic_parmeter_declarations 

: generic_paiaineter_declarations generic_par^eter_declaTation 
{generic_paranieter_(telarations[l].generic_type_declarations = 
generic_parameter_do:larations(21.c(Hnina = “yes” 
->[generic_parameter_declarations[2] .gen^c_type declarations, 
“\n” 

generic.j>arafneier_declaration.generic_type_declarations] 

# [gene^_parameter_declarations[2].s^neric_type_declarations, 
generic_parainetBr_declaration.gaieric_type_dKlarations]; 
generic.^parameter_^larations[l].new_genaic_types = 
[generic_j)arameter_declarations[2]jnew_jeneric_types +1 
generic_i»rameier_declaration.new_generic_types]; 
geneTic_parameter_dKlaration.generic_types = 
geneiic_paraineter_declarations.genaic_types; 
generic_parameter_declarations[2].generic_types » 
generic_paranieter_declaralions[ 1 ] .generic.typ^; 
generic_paraineter_declarations[l].new_composite_types = 
generic_parameter_declaratk)ns[2] jiew_comp(^te_types 
-t-l generic_paraineter_declaration.new_composite_ty^s; 
generic_paianieter_declaration.coinposite_types = 
generic_parameter_declarations.composite_types; 
generic_paraineter_decIarations[2].composite_types = 
gaieric_parameter_declarations[ll.co(nposite_types; 
generic_parameter_declarations[l].coinma = 
generic_parameter_declaratk)n.comina:} 

I generic_parameter_declaiation 

{geneiic_paraineter_declarations.generic_type_declarations = 
geneiic_paraineter_decIaration.generic_type_declaiations; 
generic_parameter_declaration.generic_types = 
generic_parameter_declarations.generic_types; 
generic_paraineter_declaration.composite_types = 
generic_paraineter_declarations.composite_types; 
generic_panimeter_declarations.new_coniposite_types = 
generic_parameter_decIaratk)n.new_composite_types; 
generic_parameter_declarations.new_generic_types = 
generic_parameter_declaration.new_generic_t)^; 
generic_paraineter_declarations.comma = 
generic_parameter_declaration.comma;) 


67 




generic_pai^eter_declaration 
: idendfier.list typc_mark 

{generic_paraineier_declaralion.geneiic_type_declarauons = 

[“ ‘*4dentifier_lisLvariable_naines,”: GB*^RIC_VALUE”]: 
generic_paraineter_declaration.new_composite_types s 
generic j)araineter_declaration.new_generic_types = 
geaaic_ptawneter_deciaiatkm.conuna = “yes";) 

Iktentifier.list IN type_maric 

{generic_i)arainelBrjdeclaration.generic_type_declarauons = 
r "4dentifier_UsLvariable_naines,”: GENERIC_VALUE”]; 
generic_paraineter_declaratk)n.new_composite_types = 
generic_i)arameter_declaiarionjiew_generic_types = 
generic_paraineter_declaration.coinina = “yes"; ) 

I idratifier_list IN OUT type.maik 

(generic_paraineter decUradon.generic_type_declarations = 

[“ “jdenufier_lisLvariable_naines GENERIC. VALUE”]; 
generic_paniineter_decIararion.new_composite_types = 
generic j)anuneter_deciararionjiew.generic_types = 
generic j;)araineter_declararion.comtna = “yes";) 

I idmtifier.list *:* type.maiic EQUAL exi^skm 

(genericjnranieter_(]eclaration.generic_type_declarauons = 

[“ “,idcntifier_UsLvari^le_names GENERIC.VALUE”]; 

genericj)anifneter_declaration.new_composite_types = 
generic.parameter_dec]aration Jiew.generic_types = 
genericjKuameter.declararionxonuna = “yes":) 

I idratifier.list IN type.mark EQUAL expression 

(genericjnraineter decbKation.generic type declarations = 
r‘ “^tificr.IisLvariable.names GENERIC.VALUE”]; 

genoicjniameter.declaiarionjiew.composite.types s ““; 
generic_paiameier_declaratk)n.new.generic_^^ * 
generic j»rameter_dec]aialion.conuna = "yK ,} 

I idtnrifio'.iist IN OUT type.mark EQUAL expression 
(generic_paranieter_decl^tion.generic_type.declarations = 

(“ “jdenrifier.iisLvaiiable.names"; GENERIC. VALUE”]; 
generic jMuameter.deciarationjiew.composite.types = 
generic.parameier_dec]araL>/fl.new.generic.types = *“*; 
generic jMrameter declaration.comnia s “yes”;} 

I TYPE IDENTIFIER IS PRIVATE 

(genericj;>aranieter_declarati(m.generic_Qi}e_declaiations = 
genericjMoameter decIaiation.composite types(IDENTIFIER.%text) 
= “yes" 

#(“ “JDENTIFIER.%text.”:GENERIC_TYPE”]; 
generic j>arame ter.declaiation.new.genqic_types s 
((IDENTIFIER.%text:TRIVArE”)); 
genericjMuameter.declaratitxiJiew.composite.types * 
genericj)aranieier.declaration.comnia - 

genericj»ianieier_decIaration.composite_types(IDENTIFI£R.%text) 
= “yes” 

->“no" 

I TYPE IDEN TIFIER IS discriminantj>art PRIVATE 

(genericj)aranieter_declaration.generic_type_declarations = 
generic i)aianieter.declaration.composite_typesGDEN llhibR.%text) 

#r “JDENTIFIER.%text,”: GENERIC.TYPE"]; 
generic i)arameter.decIaration.newzeneric_types = 
((IDe!lTIFIER.%text;”PRIVATE’^; 
genericj)arameter.declaration.new_composite_types = 
genericjMirameter.<teclaration.comnia => 


68 







generic_paraineter_declaration.composite_types(IDEN'l'lhl£R.%text) 
ss “yes” 

->“no” 

# “yes”;) 

I TYPE IDEmiFIER IS LIMITED PRIVATE 

(geiieric_paraineter_declaration.geneiic_type_(leclarauons = 
generic_parameter_declaration.composite_lypes(IDENriFlER.%text) 
as “yes” 

#r “4DENTIFIER.%«cxt,”; GENERIC.TYPE”]; 
generic_ parame ter_declaration.new_generic_types = 
{(IDENTIFlER.%text:”PRIVArE”)}; 
generic_paraiiieter_declafation j)ew_coniposite_types = 
generic _parameter_declararion.comina = 

genaic_paianieter_deciaration.composite_types(IDENTIFIER.%text) 
= “yes” 

-> W 
#“yes”;)_ 

I TYPE IDENTIFIER (liscriininant_pait IS LIMITED PRIVATE 
{generic_paranietBr_declaration.generic_type_declarauons = 
generic_parameter_declaration.composite_typesGDENilFlER.%text) 
= “yes” 

->*“* 

#r “JDENTIFIER.%text,”: GENERIC.TYPE”]; 
generic _ parame ter_declararion.new_generic_types = 

{(IDENTIFIER.%text:”PRIVArE5); 

generic_parameter_declaiation.new_composite_types = 
generic_paranieter_declaiarion.comnia = 

generic_paixinieteT_declaiation.coniposite_types(IDENriFlER.%text) 
as “yes” 

->“no” 

#“yes”;J_ 

I TYPE IDENTIFIER IS gcneric^type.definition 

(gaieric_parameter_dMlaraiion.generic_type_declarations - 
generic_paranieter_declaration.composite_types(IDENrihlER.%text) 
as “yes” 

#r “4DENnFIER.%texi,”: “, 
generic_type_(iefinition.variable_type]; 
genm_type_definition.generic_typ^ = 
generic_paranieter_d6claration.^neric_types; 
generic_ paramete r_declaration. new_g eneric_types = 
{(IDENTIFIER.%text:”DISCREIE”)); 
generic_parameter_decIararion.new_composite_types = 
generic_type_<kfinitionjiew_composite_types; 
generic_par^eter_decIaraticxi.comma = 

generic_paranieter_declaration.composite types(IDENTIFIER.%text) 
— “yes” 

->“no^ 

# “yes”;) 

I WITH subpn>grain_specificatk)n 

(generic_paranieter_declaration.generic_type_declarations = 

[“ “;subprogram_specification.namc,”: GENERIC_PROCEDURE”]; 
generic_paranieter_dMlara(ion.new_composite_types = 
generic_parameter_declararion.new_generic_ty^ = 
generic_pafanieter_declaration.conima = “yes”;} 

I WITH subprogram.specification IS name 

{generic_parameter_dec]araUon.generic_type_declarations = 
r “^bprogram_specification.namc,”; GENERIC_PROCEDURE”]; 
generic_par^eter_declaration.new_composite_types = 
generic_parameter_declaration.new_generic_typ» = 


69 










gencric_paraincter_declarauon.coinma = “yes”;} 

I WITH subiKogiain_q;)ecification IS DISCRETE 

{gcneric_parainetcr_declaration.generic_typc_declarations = 

[“ “^bprograin_specification.naine,”: GENERIC_PROCEDURE”]; 
geiieric_paramcter_declaraiion.new_comp«itc_types = 
gciieric_parameter_declaraiion.iiew_generic_typ^ = 
generic_paiainctcr_declaranon.coinina = “yes”;} 


package_specification _ 

; PACKAGE IDENTIPIER IS basic_declarsuive_items END IDENTIFIER 
( pnrtagt‘ _!qvicification.psdl_interfaice specification = 
bask d^larative_iteins Jiumber_of_c^ratOfs = 1 
-> [“OraRATOR “.IDENTIFIER.%text,”SnSPEanCA'nON\n”, 
package_specificatk)n.generic_type_declaratioiis,”\n”, 
basic_dMi^tive_iteins.input_iKiiameters. 
basicIdeclarative_items.outputj)arameters,”'n”, 
basic~declaradve_iteins.exceptions. 

“END^i”] 

# [TYPE “JDENTIFIER.gfctext.’NiSPECIFICATIONVn”, 

package_^)ecificatioageneric_type_declarations,”Sn”, 

basic_dec]arative_iteins.type_dMlaiations, 

basic declarative items.opmtor_specificauon, 

“ENDSn”]; ~ _ 

package_speci fication .file_naine = [IDENTIFIER.%text,“.psdl”];) 

I PACKAGE IDENTIFIER IS basic_declarativ e_items PRIVATE 
basicjdeclarative.items O'lD IDENTIFIER 
( paclfagft _spccificatinn.psdl interface q)ecification = 
bask dKlaradve items jtumber_of_c^ratcffs — 1 
-> rOreRATOR “jroENTIFIER.%text,”VnSPECMCATIONNn”, 
packagc_specificatk)n.gcncik_typc_dcclaraiioiis,’>n”, 
basic.declarative_itenis.input_paraineters. 
basicIdeclarative_itenis.output_paiameters, 
bask~dKlaralive items.exceptions, 

“END*«”] _ 

# [TYre “ JDENTIFIER.%texl,’NiSPECIFICATIONSn”, 

package.specification.geiieric_type_declarations,”\n”, 
basic_declarativeJtems.type_dwlarations, 
basic'dKlaiative items.tq^tcx'.specification, 

“ENI>n”]; _ 

package_specification.file_name s [IDENTIFIER.%text, “.psdl”]>) 


bask_declarative_items 

: basic_declarative_items bask_declaiative_item 
{bask_decIarative_items[I].type_decIarationss 
[ bf^c_deciarative_items[2].type_declarations, 
ba^c_declarative_item.type_declarations]; 
basicjdeclt^veJienis[I].operaior_specification = 

[ bask_decIarativeJtems[2].operator_qpecification, 
"Vn”,bask_declarativcJtem.operator_specification]; 
baskjdeclarative_ilems[I].input_parameters = 

[ basic_declaradve_items[2] jnput_parameters, 
bask_declarativejtem.iiq>ut_parameters]; 
basic_decIarative_items[I].ou^t_parameters ^ 

[ bi5ic_declaraBveJteins[2].output_parameters, 
baiic_declarative_item.output_parameters]; 
basic_dec]araiive_items[lj.exceptions » 

[ basic_decIarativeJtem$[2].excepUons, 
baBc_declarative_item.excepuons]; 


70 




basic_declarative_items[l].number_of_opeTators = 
basic_(tecIarative_itcms[2].number_of_operators + 
basic_declarative_itefn.nuinber_of_operators;) 

{basic_declarative_iteins.type_declarations = 
l»sic_declarative_items.opeiator_specification = 
basic_declarative_items.nuinber_of_opaators = 0; 
basic_declatative_itenis.input_paraineters = 
basic_declarative_items.ouq>ut.j)araineteis = 
basic_declarative_items.exceptions = } 


basic_declarative_itein 
: basic.declaradon 

{basic_declaiative_itein.type_declarations = 
basic_declaration.type_deciaratioiis; 
basic_declaradve_item.operatQr_specification = 
basic_declaradon.operator_specification; 
basic_declarative_itein.input.parameters = 
basic_decUvadon.input_parameters; 
basic_declarative_itBm.outputj)arameters = 
basic_decl 2 ffation.outputj)ar^eters: 
basic_declarative_item.exceptions = 
basic_declaration.excq)tions; 
basic_declarative_iiem.number_of_opaators = 
basic_declaration.number_of_opetators;) 

I representadon.clause 

{) 

I use clause 

{} 


basic.declaratioa 

: object.declaration 

(basic_declaration.number_of_operators = 0; 
basic_decIaradon.type_declarations = 
basic_deciaradon.operator_specificadon = *“*;} 

I type.declaradon 

(basic_decIaradon.type_declaradons = 
type_declaradon.t^_declaradons; 
b^c_declaradon.operator_specificadon = 
basic_declaradon.number_of_operatoTs = 0;} 

I sulq}rqgram_declaradon 
(basic_declaration.type_declaradons = 
basic_declaradon.(q)erator_specificadon = 
subpfOgram_decUuadon.(q)aator_specificadon; 
basic_d^laiadon.inputj)ai^eters = 
subprogram_declaradon.input_paramet^; 
basic_dKlafadoiLou^t.parameters = 
subpn)gram_decIaiadon.outputj)arameters; 
basic_dMlaradon.excepdons s “**; 
basic_declaradon.number_of_operators = 
sub^gram_declaradon.number_of_operators + 1;) 

I task_decla^on 

{} 

I excq>don_decIaradon 

{basic_dKlaradon.excepdons s excepdon_declaradon.excepdons; 
basic_deciaradon.type_declaradons = 
basic.declaradoninputjMiranieters = *"*; 
basic_declaradon.ouq)utjtarameters = 
basic_decIaradon.operator_specificadon = 


71 






basic_declaraUonjiumber_of_operators = 0;) 

I renaininK_declaration 
{basic_declaration.type_declarations = 
basic_declaration.operator_specification 
basic_declaration.number_of_operators = 0;} 

I subtype.declaration 

{b^_declaration.type_(kclarations = 
subtype_declaration.type_declarations; 
basic.declaration.opa^UM'.specification = 
basic_declaration.nuniber_of_operators = 0;} 
I generic_declaiation 
{basic_declaration.type_(leclarations = 
basic_declaration.operator_specification = 
basic_declaration.nufnber_of_operators = 0;) 


repFesentation.clause 

; type re{nesentation_clause 

{} 

I address.clause 

{} 


type_rqnesentation_clause 

: enumaadon iepresentation_clause 

{} 

I length.clause 

{} 

I reconl_iepresentadon_clause 

{} 


address_clause 

: FOR IDENTIFIER USE AT simple.expression 


enuineradon_rep resenta don_clause 
: FOR ff)EN l lF‘IER USE aggregate 
(1 


length_claiise 

; FOR attribute USE simple expression 

(} 


record_represent adon_cla use 

; FOR IDENTIFIER USE RECORD alignmrat.clauses component.clauses 

END RETORD 


{) 


alignment_clauses 

: aU^nment.clauses alignment.clause 


I 


{} 


alignment.clause 


72 







: AT MOD simple expression 

{) 


component.clauses 

: component_clauses component.clause 

{} 

I 

{) 

* 

component_c]ause 

: name AT simple_expression RANGE range *;* 

{) 


object.declaiation 

: identifier_list subtypejndication 

I identifier list constrained_array_definition 

{} 

I idratifier list 03NSTANT subtype_indication 

{) 

I identifier.list CONSTANT constrained_aiTay_definition 

I identifier list *:* subtype indication EQUAL expression 

I ideaitifier.list CONSTANT subtype_mdication EQUAL expression 

I identifier.list constrained_aiiay_definition EQUAL expression 

I identifier list *:* constrained_array_definition EQUAL expression 

{} 

I IDENTIFIER subtype_indication 

I IDENTIFIER constrained_array_definition 

I IDENTIFIER CONSTANT subtype.indication 

I IDENTIFIER CONSTANT constrained.array definition 

{) 

I IDENTIFIER subtype.indication EQUAL expression 

I IDENTIFIER CONSTANT subtypejndication EQUAL expression 

I IDENTIFIER constrained_array_definition EQUAL expression 

I IDENTIFIER constrained_array_definition EQUAL expression 

{} 


type.declaratkm 

: full_type_declaration 
(type_diKlaiation.type_declarations = ) 

I incompIete_type_declaration 
{type_declaiation.type_deciarations = } 

I private_type_declaration 
(type_diKlaration.type_declarations = 
privatc_type_declaration.type_declaradons;} 


73 







subprogram.declaratioii 

: subprogram.specification 
{subprograin.declaiation.operata'.specification = 
subpiogiam_specification.operat(v_specification; 
sub|nop^_^laration.input_parameters = 
subprograni_specification.input_parameters; 
subpiDgrain_<leclaration.output.parameters « 
subprogram_q)ecification.output_parameters; 
sub|TOgiam_(leclaration.niunbCT_of_<^rators = 0;} 


task_dec]aratkHi 

: task_specification 

{) 


exception_declaradon 

; IDENTIFIER EXCEPTION 
(excq)tion_declaration. exceptio ns = 

[" exception: “,IDENTEFIER.%text, “Sn”];) 

I identifier_list EXCEPTION 
{exception_declaration.exceptions = 

[“ exception: “adentifier.lisLexceptions, ‘^n”];} 


rcnaming_ declarat ion 

: IDENTIFIER type_mark RENAMES name 

{} _ P 

I IDENTIFIER EXCEPTION RENAMES name 

{} 

I PACKAGE IDENTIFIER RENAMES name 

{] 

I subfHOgram.qpecification RENAMES name 

(} 


subtype_declaration _ 

: SUBTYPE IDENTIFIER IS subtype_indi«ttion 
{ subtype_declaration.type_decla^ons = "•*;) 


generic.deciaradon 

: ge^c_specification 


full_type_declarat ion 

: TYI% IDENTIFIER discriminantjxirt IS type_definition 


incomplete_type_ declaratio n 

: TYre IDENTIFIER di5criminant_part 

{} 


discriminant_pait 

: *(* discriminant.specifications *)’ 


I 


{) 

(} 


74 







discriminant.specifications 

: discriininant_specificationsdiscriminant.specification 

{) 

I discriininant_specification 

{) 


(liscriininant_^)ecification 

: identifier_list type_maA 

I identifier list type_mark EQUAL expression 

{) 

type_definition 

: enuniCTation_type_definition 

{} 

I real_type_definition 

I record_type_definition 

{} 

I derived_type_definition 

(1 

I integer_type_definition 

I array type_definition 
{} ~ 

laccess_type definition 

{} 


subprograni_specification 

: PRCXrEDURE IDENTIFIER formal_part 

{sub{»ograin specificati on.opeta tor_specification = 

[“ OPERATOR‘MDENTIFIER.%text,”Sn SPEdFICATIOMNn”, 
f(Hinal_parunput_parameters, 
fOTinaI_parLoutput_paBameters ” ENDNn” ]; 
subptDgram_specification.input_paramet^ = 
[formal_partinput_paranietersl; 
sut^togram_specincation.output_parameters = 
[f(xinal3att-output_paraineters]; 
su bi wDgtam_specification.name = IDENTIFIER.%text;) 

I FUNCTION designa^ fonnaI_patt RETURN type_maiic 
(subprogram specification.operator_specification = 

[“ OreRATOR “,designator.naine,”Vn SreCIFICATIONNn”, 
fonnal_partinput_parameters, 

“ output “,designator.name,”: 

type_mark.variable_type,”Vn ENDNn”]; 
su bpro g r am_specification.name = designator.nam?: 
subiHOgram_specification.input_parameters = 
[fonnai_partinput_parametersl; 
sub|^gram_specincation.output_parameters = 

[“ output “4esignator.name ”: 
type_niaiit.variable_type];) 


designator_ 

: IDENTIFIER _ 

{ designatorjiame = IDENTlFIER.%text;} 
I STRING LITERAL 


75 




{designator.operator_symboIs = {(‘V’+\””;”add”) 
CV-V”:”subtracn (‘\”*\””:”multiply”) (‘VA””:”divide”) 
(‘V=\””:”equal") (‘V<A"”;”less_than”) (‘V>\””:"greater_ihan”) 
(‘V<=\””:”LTE”) (‘V>=\””:”GTC”) 
(?:string;”overlo^ed_operator”)}; 
designatorname a 

designator.operaior_symbols(STRING_LniERAL.%text); ) 


specifications *)’ 

{paraineter_specifications.inode_check= {(?:string:’”’)); 
fonnal_part.input_par^eters = 

parameter_spwificationsjnode(“input_paraineter”) = “yes” 
-> [“ input “,paranieter_specifications.input_parameters, 
‘^n”] 

# 

foiinal_paTtoutput_parameters = 

parameter_specifications.mode(“output_paran(»eter”) == “yes” 
-> [“ output “,parameter_specifications.output_parameters, 
‘^n’^ 

# ) 

{ fonnal_partinput_paranieters = 
fonnal_partoutput_parameters = } 


fonnalDart 

: T parainetCT_ 


paiameter_specifications 

: parameta.specifications par^eter.specification 
(parameter_specifications[l].input_paiameters = 
((parameta'_specification.cunent_nio(te = “in”) II 
(paianieter_specification.current_mode = “inout”)) && 
((parameter_spw:ifications[2].currcnt_mode “in^ II 
(parameter_spiecifications[2].current_tno(fc = “inout”)) 
->[parameter_specifications[2].input_parameters, 
“,parameter_specification.input_parameters] 

# [parameter_specifications[2].in^t_paranieters, 

parameter_specification.input_paiameters]; 
paranieter_specifications[l].output_parameters = 
((paiameter_specification.curtent_niode = “out”) II 
(paianieter_specification.current_mode = “inout”)) && 
((iarametcr_specifications[2].curreni_mode = “out”) II 
(paraineter_specifications[2].cunent_mode = “inout”)) 
•>[paraineter_specifications[2] .output_parameters, 

“, “,parameter_specification.ou^ut_parameters] 

# [parameter_specifications[2].ouq)ut_parameters, 

parameter_specification.output_paranieters]; 
paranieter_specifications[l].mode = 
parameter_specifications[2] .mode 
4l parameter_specification.mode; 
parameter_specifications[2].mode_check = 
parameter_specifications[ 1 ] .mode_check; 
parameter_specification jnode.check = 
parameter_specifications[ 1 ] .mode.check; 
parameier_specifications[l].current_mode = 
paranieter_specifications[2].cuiFent_mode;) 

I parameter.specification 
(parameter_specifications.input_parameters = 
parameter_specification.input_parameters; 
{Mirameter_specifications.output_parameters = 
parameter_specificaUon.ou^ut_parameters; 


76 





paraineter_specifications.mode = parameter_specification.niode; 
parameter_specificadon.mode_check = 
I)araineter_specificauons.mode_check; 
parameier_sp^ifications.current_mode = 
parameter_specification.cuirent_mode:} 


parameter_specification 

: identifier.Iist type_mark 

(paraineter_^pecification.input_parameters = 
[identifier_lisLvariabie_iiames, “,type_mark.variable_type]; 
paraineter_specificatk)n.output_panimeters = 
paraineter_specification.mo^ = {(“input_parametcr”:”ycs”)} 

+1 panpeter_specification.mode_check: 
paraineter_specification.cuiTent_mode = “in”;} 

I identifierjist IN type_mark 

{p«uameta’_q)ecification.input_paraineters = 

[identifierjist variable_namcs, “,type_mark.variable_type]; 
parameter_specificauon.output_parametas = 
parameter_specification.inode = {(“input_parameter”;”yes”)) 

+1 parameter_specification.mode_check; 
parameter_specification.cunent_mode = “in";) 

I identifierjist IN OUT type_mark 

{pKarameter_specification.input_parameters = 
[idaitifierjistvariable_names, “: “,type_mark.variable_type]; 
parameter_specificatk)n.output_parameters = 
[identifier_listvariable_names, “: “,type_mark.variable_type]; 
paraineter_specification.mode = {(“input_parameter”:”yes”), 
(“output_par^eter”:”yes”)) 

+1 parmeter_specification.inode_check; 
parameter_specification.ciinent_mode = “inout”;} 

I identifier.list OUT t 3 ^_mark 
(paranietCT_specification.input_parameters s *“*; 
parameter_specification.ou^t_paraineters s 
[identifierjist variable.names, “: type_mark. variablejype]; 
paranieter_specification.inode = ((“ouq)utjjarameter”:”yes”)) 
+1 parameter_specification.mode_check; 
parameter_specincation.cuiTent_mode = “out”;} 

I idradfierjist type_mark EQUAL expression 
([»rameter_specificadon.input_parameters = 
[idmtifierjistvariable.names, “,type_mark.vaiiablejype];} 
I identifierjist IN type_maik EQUAL expression 
(paranieta'_q)ecification.input_parameters = 
[idratifierjistvariable.names, “: “,type_mark.variable_type];} 
I identifierjist IN OUT type_ni^ EQUAL expression 
{paranieta'„s^ification.input_paramet^ = 
[identifier_listvariable_names, “: “,type_mark. variablejype]; 
pwameter_specification.output_parametas = 
[idoitifierjistvariable.names, “: “.type_mark.variable_type];) 
I identifierjist OUT t 3 ^_maric EQUAL expression 
{parameto'.specification.output.parameters = 

[identifierjist variable.names, “: “,type_mark.variable_iype];) 


task specification 

: TASK IDENTIFIER 

{) 

I TASK TYPE IDENTIFIER 

{) 

I TASK IDENTIFIER IS entry_declarations representation_clauses 


77 




END IDENTIFIER 


I TASK TVra IDENTIFIER IS entry_declaradons rcpresentation_clauses 
END IDENTIFIER 


{) 


entiy_declarations 

: entry_(tec]arations entiy_decIaration 

{) 

I 

{) 


representation.clauses 

: re^sentation_clauses iepresentation_clause 


I 


{} 


entry declaration 

: ENTRY IDENTIFIER formal nart 

(1 _ 

I ENTRY identifier ‘(‘ discrete_range *)’ fonnal_part 


subtype.indication 
: name 

{subtype_indication.variable_type = name.variable_type; 
subt^.iiKlication.elenient_ty{K - name.elema)t_ty]>e; 
name.generic_types = subt^_indication.generic_types; 
subtypc_indicalion.new_composite_types = 
nanieJiew_composite_types;) 

I name constraint 

(subtype_iiKiication.variable_type = name.variable_type; 
subt^Jndication.element_t)ije = name.element_t>T>e; 
name.gei^c_types » subtype_indication.generic_types; 
subtype_indication.new_composite_types * 
namcJiew_compositc_types;) 


type_maik 
: name 

{typc_™atl^-vanable_type = name.variable_type;) 


constraint 

; range constraint 

{) 

I fixed_point_constraint 

(} 

I floating tx)int constraint 

{) 

I discriminant constraint 

{} 

I index constraint 

(} 


78 








derived_type_definition 

: I^W subtypejndication 

{) 


range.constraint 
: RANGE range 
0 


range 

: attribute 

{} 

I simple.expression TO snnple_expression 

{} 


discriminant_constraint 

: ‘(‘ dis^minant_associations *)* 

{) 


discriminant_associations 

: discriminant.associations (liscriminant_association 

{} 

I discriminant_associabon 

(} 


discriminant.association 



I discriminanLclioices ARROW expression 

{} 


discriminant.choices _ 

: discriminant choices ‘i’ IDENTIFIER 

0 

! IDENTIFIER 

(} 


generic_type_definition 
■ *(* DISCRETE *)* 

{gcneric_type_definition.variable_type = “DISCRETE” 
generic definition.new_composite_types = } 

I RANGE DISCRETE 

{generic_type_dcfinition.variable_type = “DISCRETE” 
generic 'type3efinition.new_composite_types = } 

I DIGITS DISCRETE 

{) 

I DELTA DISCRETE 

(} 

I array_typc_definition 

{gOTeric_type_definition.variable_type = 
anay_^T)e_definition.variaWe_ly^; 
array_type_definition.generic_types = 
genenc_QT)c_definition.gcneric_types; 
gcncric_type_definition.new_composite_types = 
anay_type_definition.ncw_composite_typ»;) 


79 




I acc^_type_definition 


generic.instantiation _ 

: PACKAGE IDENTIFIER IS NEW name generic_actual_part 

{) 

I n(OCEDURE IDENTIFIER IS NEW name generic_actual oart 

{} 

I FUNCTION designator IS NEW name generic_actual_part 


generic_actual_part 

: ‘(‘ generic.associations *)’ 

{} 

I 

{} 


generic_associations 

: genaic_associations 

(1 

I geneiic_association 

{} 


' generic_association 


generic.association 

: generic_fonnal_parameter ARROW genehc_actual_parameter 
I generic_actiial_parametBr 


generic for mal_pa rameter 
: IDENTIFIER 
{} 

I STRING LITERAL !operator_symbol 

{} 


generic_actual_parameter 
: expression 


I name 

0 


privaie_type_(lecl aration 

: TVre IDENTIFIER discriminant^pait IS PRIVATE 
( private_type (teclaration.gcneric type declarations = 
[IDENTIFIER.%tcxt,”: GENERIC_TYPP«”]; 
private type declaration.type.declarations = 

[“ •'JD ENflF IER.%text.": ADTNn”];) 

I TYPE IDENTIFIER discriminant nart IS LIMITED PRIVATE 

{) 


incomplete_type_ declara tion 

: TYre IDENTIFIER discriminant_part 

{) 


80 






defened_constant_declaration 

: identifier_listCONSTANT name 

{) 


attribute 

: prefix TIC attribute designator 

0 


attribute_d esignato r 
: IDENTIFIER 
0 

I IDENTIFIER ‘(‘ expression *)’ 

{) 


expression 

: relation 

0 

I relation and.relations 

{) 

I relation or_relations 

0 

I relation xor_relations 

0 

I relation and_then relations 

0 

I relation or else_relations 

{) 


I 


{) 


and.relations 

: and relations AND relation 

(f 

I 

{) 


or.relations 

: or.relations OR relation 

{) 


{) 


xor_relations 

: xot relations XOR relation 

{)■ 

I 

0 


and_then_ielations 

; and.then.relations OR relation 


I 


{) 


81 





or_else_relaiions 

: w_else_ielations OR relation 


{) 

I 

{) 


relation 

: simplejexpiession 

... 

I simple expression relational.operator sunpie_expression 

{) 

I simple_expression IN range 

I simple expression NOT IN range 

{) 

I simple expression IN name 

{) 

I sim|)le_expression NOT IN name 


simple.expression 

: tem !Not really required because 3rd choice can break down to term 

0 

I unary_adding_operator term 

{) 

I term binary adding_operator binary_terms 

(} 

■ unary adding_operator binary.terms 

{) 


binary_terms 

: binary terms binary tom 

{) 

■ binary term 
{) ■ 


binary_tcrm 
: term 
{} 

■ term binary adding_operator 

{) 


term 

: factor multiplying_operator_factor 

{} 

» 

multiplying_opeiator_factor 

: multipl^g_operator factor multiplying_operator factor 

{) 

■ 

0 


82 




inultiplying_opeiator 

:TIMES 

0 

I DIVIDE 

{} 

I MOD 

{} 

IREM 

{) 


factor 


: iHimary 

{} 

I hi|hest_precedence_operator primary 

I primary highest_piecedence_operator primary 

(} 


highest_precedence_operaior 

:EXPONENT 

{} 

I ABS 

{} 

I NOT 

{) 


ivimary 

: numeric_literal 

{) 

INULL 

(} 

lag^gate 

I ST^G LITERAL 

{} 

■ name 

{) 

I allocator 

{} 

I function call 

(} 

I type_convwsion 

I qudified_expression 

{) 

I ‘(‘ expression *)’ 

{] 


numeric literal 

: INTEGER LITERAL 

{) 

IREAL LITERAL 

{} 


aggregate 


83 






: ‘(‘ component.associations *)’ 

{) 


component.associations 

: component.associadons component_association 

{} 

■ component association 

{) 


component.association 



I choices ARROW expression 

{) 


choices 

: choices *1’ choice 

{) 

■ choice 

{) 


allocate 

: NEW qiialified_expression 

■ NEW subtype indication 

{) 


fiinction.call 

zname 

{} 

■ name actual_parametBr_part 


actual_parameter_part 

: ‘(‘ jorameter.associations')’ 


parameter.associations 

: parameter.associations parameter.association 

■ poameter association 

0 


paraincter_ associa iion 

: IDENTIFIER ARROW actual_parameter 

{) 

■ acuial_parameter 

0 


actual jparameter 
: ex^iression 


84 








I name *(* name *)’ 

{} 

I name 

{) 


type_conversion 

: name ‘(‘ expression *)’ 

{) 


qualified_expression 

: name TIC ‘(* expression *)’ 

{) 

I name TIC aggregate 

{) 


relational_opaator 
:EQUAL 
{} 

INEQ 

{) 

ILT 

(} 

ILTE 

{) 

IGT 

{) 

I GTE 

{) 


binary adding_operator 
:PLUS 
{} 

■ MINUS 

{) 

■ AND !&, string concatenation 

{} 


unary_adding_operator 

:PLUS 

{} 

■ MINUS 

{) 


muldplying^opeiator 

:TIMES 

{) 

■ DIVIDE 

{} 

■ MOD 

{} 

■ REM 

(} 


enumeration_type_definition 




: ‘(‘ enumeration literal.specifications *)’ 
{} " • 


enumeration_literal_q)ecifications 

: enumeration literal specifications enummtion.literal 

{} 

I enumeration literal 

{) 


enumeration.Uteral 

:IDENTIFffiR 

{) 

I CHARACTER.LITERAL 

{) 


integer_type_definition 
: lin^.constraint 
{) 


real_type_definition 

: floating point constraint 

I fixed_point_constraint 

{} 


floating point constraint 

: flaating_accuracy_definition 

{) 

I floatinjLaccuracy_dcfimuon range.constramt 


floating_accuracy_definition 
: DIGITS simple expressirai 
0 


fixed_point_constraint 

: fixed accuracy_definition 

{} 

I fixed accuracy.definitkm range constraint 
{)■ 


fixed_accuracy_(tefinition 

: DELTA simple ex{ffession 

{} 


airay_type_definition 

: unconstrained_array_definition 

(array_type_definition.variable_type « 
unconsbained_array_definition.variable_type; 
unconsbtained_^y_definiti(Mi.generic_types = 
array_typc_definition.generic_types; 
anay_type_definition.new_composite_types = 


86 





unconstrained_array_definition.new_composite_types;) 

I constrained.aiiay.defiiutim 

{aiiay_t^_definition.variable_type = 
constrained_anay_definition.variable_type; 
constrained_array_definition.generic_types = 
array_type_definition.generic_types; 
array_type_definition.iiew_composite_types = 
constrained_aiTay_definition.iiew_composite_types;) 


unconstrained.anay.definition 

: ARRAY ‘(‘ subtype_definitions *)’ OF subtype_indication 
(unconstrained_array_defiiiition.variable type s 
rGENERIC_TYPE[BASE_TYPE: ARRAY[ARRAY_ELEMENT:”, 
subtype_indication.element_type”>nW4ARRAY_INDEX:”, 
subt^_definitions.index_ty^,”]r]: 

subtype_definitions.generic_types = 
iinconstrained_array_definition.generic_types; 
subtype_indication.geiieric_types = 
unconstrained_array_definition.generic_types; 
iinconstiained_artay_definition.new_composite_types = 
subtype_definitions Jiew_composite_types +1 
subty^_iiidication.new_coinposite_types;} 


subtype.definitions 

: subtype.definidons index_subtype_definition 
{index_subtype_definition.^eneric_types = 
subtype_de^tions.genetK_types; 
subtype.definitions ji^x.ty^ = 
index_subtype_definition.index_type; 
subtype_de^tioas[l].new_com^ite_types = 
subt)pe_definitions[2].new_composite_types +1 
index_subtype_definition.new_composite_types:) 

I index.sub^pe.ctefinition 

{index_siib^pe_definition.geneiic_types = 
subt)^_definitions.generic_types; 
subtype_defiiutions.index_type = 
index_subtype_definitionjndex_type; 
siibtype_de^tions.iiew_coinposite_types = 
index_subtype_defiiutionjicw_composite_types;) 


coiistraiiied_aiTay_definition 

: ARRAY index_coiistraint OF subtyiw.indicadon 
{constrained.array definidon.variabIe_type = 
[“GENERIC_TYPE[BASE_TYPE: ARRAY{ARRAY_ELEMENT:”, 
subtype iiidicadon.eiement_type, 
‘\j>tNMARRAY_INDEX;DISCRETE]]”]; 
subtype_indicadon.geneiic_types = 
canstrained_aiTay_definidon.generic_types; 
constrained_anay_definidon.new_compo5ite_types = 
subtype_iiidicadon.new_composite_types;} 


index_subtype_definidon _ 

: name RANGE DISCRETE 

{name.gBneric_types = index_subtype_definidon.generic_types: 
indcx_subtype_definidon.index_t^ = “DISCRETE”; 
index_sublype_definidon.new_composite_types = 
name.pew_composite_types;) 


87 







indexjconstraint 

: ‘(‘ discrete ranges ')’ 

{] 


aiscreie_ranges 

: discrete ranges ‘,’discrete_iange 
n 


0 

(discrete range 
{) 


discrete.range 

: subtype.indicadon 

Iran^e 


record_type_definition 

: RECORD component list END RECORD 

{) 


component_list 

: component_declaradons 

(} 

I component declarations variant_part 

{} 

I variant_part 

{) 

I NULL 

0 


component.declaradons 

: component declarations component.declaration 

{} 

(component declaration 

{) 


comp(^nt_declaration 

: iden&er_Iistsubtype indication 

{) 

(identifier_list subtype_indication EQUAL expression * 


discrinunantjm 

: *(* disciinunant.specifications *)’ 

{} 


discriminant_specifications 

: discriminant specifications discriminant specification 

(1 

(discriminant specification 

{) 


88 






discriminant.specification 
: identifier list name 
{) 

I identifier list name EQUAL expression 

{) 


variant_pait 

: CASE IDENTIFIER IS variants END CASE 

{) 


variants 

: variants variant 

(1 

I variant 

{} 


variant 

; WHEN choices ARROW component_list 

{} 


choice 

: simple_expression 
I discrete.range 

Ji 

I OTHERS 

0 

I IDENTIFIER 

{) 


access_type_definition 

: ACCESS subtype_indication 

{) 


name 

: IDENTIFIER _ 

{name.variable_type = IDENTIFIER.%text; 
name.variable_name = IDENTIFIER. %text; 
name.element_type = name.generic_types(IDENTffIER.%text); 
name.iii^x_type * name.gcneric_typ es(IDEN l iFIER. %text); 
name.new_composite types = {(IDENilFltR.%text: “yes”));) 

I CHARACTER.LITERAL 

I STRING_LITERAL !opcrator_symbol 

{) 

I indexed component 

{) 

I slice 

{) 

(selected component 

{} 

I attribute 

{) 


89 














































prefix 

: name 

{) 

I function_call 

{) 


indexed_component 

: prefix ‘(‘ expressions ')’ 

{} 


expressions 

: expressions expression 

I expression 

{} 


slice 

: prefix ‘(‘ discrete_range *)’ 

{} 


selected_component 
: prefix selector 
{} 


selector 

: ALL 

{) 

I CHARACTER.LITERAL 

{} 

I STRING LITERAL !operator_symbol 

{) 

I IDENTIFIER !simple_name 

{} 


identifierjist _ 

: identifier_Iist IDENTIFIER 

{identifiCT_Iist[I].variabIe_names = _ 

[i dentifie r_list[2].variable_names,”, “IDENTIFIER.%text];} 
I IDENTIFIER 

{identifier_list.variable_names = IDEN l'lFlER.%text;) 


90 





LIST OF REFERENCES 


[1] Booch, G., “Software Components with Ada, Structures, Tools, and Subsystems’', 
The Benjamin/Cummings Publishing Company, 1987. 

[2] Booch, G., “Software Engineering with Ada", 2nd ed.. The Benjamin/Cummings 
Publishing Company, 1987. 

[3] DePasquale, G., “Design and Implementation of Module Driver and Output 
Analyzer Generator”, Master’s Thesis, Naval Postgraduate School, Monterey, 
CA, June 1990. 

[4] Herndon, R., '“The Incomplete AG User's Guide and Reference Manual', 
University of Minnesota Computer Science Technical Report 85-37, October 
1985. 

[5] Jones, C., “Reusability in Programming: A Survey of the State of the Art”, IEEE 
Transactions on Software Engineering, September 1984, Vol. SE-10 (5). 

[6] Li, H., van Katwijk, J., “Issues Concerning Software Reuse-in-the-Large”, in 
Proceedings of the Second International Conference on Systems Integration, 
Morristown, NJ, June 1992, pp. 66-75. 

[7] Luqi, “Computer-Aided Prototyping for a Command-And-Control System Using 
CAPS”, IEEE Software, January 1992, pp. 56-67. 

[8] Luqi, “Real-Hme Constraints in a Rapid Prototyping Language”, Journal of 
Computer Languages, Spring 1991, Vol. 18, No. 2, pp. 77-103. 

[9] Luqi, “Software Evolution Through Rapid Prototyping”, IEEE Computer, May 
1989, pp. 13-25. 

[10] Luqi, Berzins, V., Yeh, R., “A Prototyping Language for Real-Time-Software”, 
IEEE Transactions on Software Engineering, October 1988, Vol. 14, No. 10, pp. 
1409-1423. 

[11] Luqi, Lee, Y., “Towards Automated Retrieval of Reusable Software 
Components”, in Workshop Notes of the AAAI Workshop on Artificial 
Intelligence and Automated Program Understanding, San Jose, CA, July 13, 
1992, pp. 85-88. 

[12] Luqi, McDowell, J., “Software Reuse in Specification-Based Prototyping”, in 
Proceedings of the 14th Annual Software Reuse Workshop, Herndon, VA, 
November 18-22,1991, pp. 1-7. 


A 


91 





[13] Luqi, Steigerwald, R., Hughes, G., Naveda, R, Berzins, V., “CAPS as a 
Requirements Engineering Tool”, in Proceedings of Requirements Engineering 
and Analysis Workshop, Software Engineering Institute, Carnegie Mellon 
University, March 12-14,1991, Pittsburgh, PA, pp. 1-8. 

[14] McDowell, J., “A Reusable Component Retrieval System for Prototyping", 
Master’s Thesis, Naval Postgraduate School, Monterey, CA, September 1991. 

[15] Rachal, Randy J., “Design and Implementation of a Concrete Interface 
Generation System", Master’s Thesis, Naval Postgraduate School, Monterey, 
CA, December 1990. 

[16] Steigerwald, R., “Reusable Software Component Retrieval via Normalized 
Algebraic Specifications", Ph.D. Dissertation, Naval Posgraduate School, 
Monterey, CA, December 1991. 

[17] Steigerwald, R., Luqi, Berzins, V., “A Tool for Reusable Software Component 
Retrieval via Normalized Specifications”, in Proceedings of the Hawaii 
Conference on System Sciences, Koloa, Hawaii, January 7-10,1992, pp. 18-26. 

[18] Steigerwald, R., Luqi, McDowell, J., “CASE Tool for Reusable Software 
Component Storage and Retrieval in Rapid Prototyping”, Information and 
Software Technology, England, November 1991, Vol. 38, No. 11. 


92 







INITIAL DISTRIBUTION LIST 


1. Defense Technical Information Center 2 

Cameron Station 

Alexandria, VA 22304-6145 

2. Dudley Knox Library 2 

Code 52 

Naval Postgraduate School 
Monterey, CA 93943-5002 

3. Chairman 1 

Code CS, Department of Computer Science 

Naval Postgraduate School 
Monterey, CA 93943-5100 

4. Dr. Yuh-jeng Lee 8 

Code CS/LE, Department of Computer Science 

Naval Postgi^uate School 
Monterey, CA 93943-5100 

5. Dr. Luqi 1 

Code CS/LQ, Department of Computer Science 

Naval Postgnuluate School 
Monterey, CA 93943-5100 

6. Lieutenant Jennie M. Sealander 1 

COMFAIRMED (N8) 

PSC810, Box 2 
FPOAE 09619-2000 


4 


% 


93 






