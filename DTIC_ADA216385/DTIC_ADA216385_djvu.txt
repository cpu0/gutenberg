UNCLASSIFIED 


enDtte Entered! 


fITif. tut 


it t AH nir r EtAD INSTRUCTIONS X 

An-AOIA QQK ° P -- G --1- 

AL/ Afc IO OOD |2. C OV7 ACCESSION NO. Id RECIPIENTS CATALOG NUMBER 


5 . t m of report i period covered 


Ada Compiler Validation Summary Report: Alsys, D March 89 - 1 Dec 90 

Al sv COMP_00 2, Version 4.3, HP 9000 S 350 (host & target), - REPORT number 

8903.4A1.10038 


7. AUTHOR(i) 


AFNOR, Paris, France. 


9. PERfORMlNG OR&ANIZATION AND ADDRESS 


AFNOR, Paris, France. 


11. CONTROLLING OPT ICE NAME AND ADDRESS 

Adi. Joint P-ogrem Office 

United States'Department of Defense 

Washington, DC 2U301-3081 


14. MONITORING AGtNC* NAME I ADDRESSEE different from Controlling Office) 
AFNOR, Paris, France. 


16. 1/IST.Ub. ION STATEMENT (of this Report) 


6. CONTRACT OR 6RANT NUMEER(i) 


ic. program element, project. tasa 

AREA I WORK UNIT NUMBERS 


12. REPORT DATE 


15. SECURE T* CLASS (of this report) 

UNCLASSIFIED 


15a. DECL*SSJ f 1CAT10N/DOWNGRADING 

N/A 


Approved for public release; distribution unlimited. 


18. SUPPLEMENTARY notes 



18. KEYWORDS (Continue on reverse side if necessery end identify by block number) 

Ada-Programir,ing language', Ada Compiler-YValidation Summary Report, ... 
Compiler'^Validation Capability^ ACVty Validation Testing,/Ada 
Validation Office, AVO, Ada Validation Facility, AVF, ANSI/MIL-STD- 
1815A, Ada Joint Program Office, AJPO 


20. ABSTRAC T (Continue on reverie tide tfnecttitry end identify by block number) 

Alsys, AlsyCOMP_002, Version 4.3; AFNOR, France’, HP 9000 S 350 under HP-UX, Version 6.2, 
(host & target)', ACVC 1.10 ■ ... 


90 01 03 013 


1473 EDITION Of 1 NOV 65 IS OBSOLETE 
7) S/N 0102*Lf-014-6601 


UNCLASSIFIED _ 

SECURITY CLASSinCATlON or THIS PAGE (tvnen Data Entered) 





















I 


AVF Control Number: AVF-VSR-AFNOR-8S-03 


Ada COMPILE!: 

VALIDATION SUMMARY REPORT: 
Certificate Number: 890314A1.10038 
Alsys 

AlsyCOMP_002, Version 4.3 
HP 9000 S 350 



Completion of On-Site Testing: 
14 March 1989 


Prepared By: 

AFNOR 

Tour Europe 
Cedex 7 

F-92J80 Pans la Defense 


Prepared For: 

Ada Joint Program Office 
United States Department of Defense 
Washington DC 20301-3081 


Accesion For ' 


NTIS CRA&I \j 

one TAB L 

U’.annO’.'Ci-d U 

.. 


By ... 


OlSt 'tKlt'O': / 


Av.jildtiii ty Codes 


Avail j-‘'J, ; or 
Dist boecial 

tl-l 






Ada Compiler Validation Summary Report: 


Compiler Name: AlsyCOMP_002, Version 4.3 
Certificate Number: 890314A1.10038 

Host: HP 9000 S 350 under HP-UX, Version 6.2 
Target: HP 9000 S 350 under HP-UX, Version 6.2 

Testing Completed 14 March 1989 Using ACVC 1.10 

This report has been reviewed and is approved. 


_____ — 

Fabrice Gamier de Labareyre 
Tour Europe 
Cede* 7 

F-92080 Paris la Defense 


ion Organization 
Dr. John F. Kramer 
Institute for Defense Analyses 
Alexandria VA 22311 


Ada Joint Program Office 
Dr. John Solomond 
Director 

Department of Defense 
Washington DC 20301 










TABLE OF CONTENTS 


CHAPTER 1 INTRODUCTION 

1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT.5 

1.2 USE OF THIS VALIDATION SUMMARY REPORT.5 

1.3 REFERENCES.7 

1.4 DEFINITION OF TERMS.7 

1.5 ACVC TEST CLASSES.8 

CHAPTER 2 CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED.10 

2.2 IMPLEMENTATION CHARACTERISTICS.11 

CHAPTER 3 TEST INFORMATION 

3.1 TEST RESULTS.16 

3.2 SUMMARY OF TEST RESULTS BY CLASS.16 

3.3 SUMMARY OF TEST RESULTS BY CHAPTER.17 

3.4 WITHDRAWN TESTS.17 

3.5 INAPPLICABLE TESTS.17 

3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS.21 

3.7 ADDITIONAL TESTING INFORMATION.23 

3.7.1 Prevalidation.23 

3.7.2 Test Metnod.23 

3.7.3 Test Site . 24 

APPENDIX A DECLARATION OF CONFORMANCE 

APPENDIX B TEST PARAMETERS 

APPENDIX C WITHDRAWN TESTS 


APPENDIX D APPENDIX F OF THE Ada STANDARD 




























INTRODUCTION 


CHAPTER 1 
INTRODUCTION 


X 

This Validation Summary Report (VSR) describes the extent to which a 
specific Ada compiler conforms to the Ada Standard, ANSI/MIL-STD-1815A. This 
report explains all technical terms used within it and thoroughly reports 
the results of testing this compiler using the Ada Compiler Validation 
Capability (ACVC). An Ada compiler must be implemented according to the Ada 
Standard, and any implementation-dependent features must conform to the 
requirements of the Ada Standard. The Ada Standard must be implemented in 
its entirety, and nothing can be implemented that is not m the Standard. — 

Even though all validated Ada compilers conform to the Ada Standard, it must 
be understood that some differences do exist between implementations. The 
Ada Standard permits some implementation dependencies—for example, the 
maximum length of identifiers or the maximum values of integer types. Other 
differences between compilers result from the characteristics of particular 
operating systems, hardware, or implementation strategies. All the 
dependencies observed during the process of testing this compiler are given 
in this report. 

The information in this report is derived from the test results produced 
during validation testing. The validation process includes submitting a 
suite of standardized tests, the ACVC, as inputs to an Ada compiler and 
evaluating the results. The purpose of validating is to ensure conformity of 
the compiler to the Ada Standard by testing that the compiler properly 
implements legal language constructs and that it identifies and rejects 
illegal language constructs. The testing also identifies behavior that is 
implementation-dependent but permitted by the Ada Standard. Six classes of 
tests are used. These tests are designed to perform checks at compile time, 
at link time, and during execution. • 


i 

/ 






INTRODUCTION 


1.1 PURPOSE OF THIS VALIDATION SUMMARY REPORT 

This VSR documents the results of the.validation testing performed on an Ada 
compiler. Testing was carried out for the following purposes: 

To attempt to identify any language constructs supported by the 
compiler that do not conform to the Ada Standard 

To attempt to identify any language constructs not supported by the 
compiler but required by the Ada Standard 

To determine that the implementation-dependent behavior is allowed 
by the Ada Standard 


Testing of this compiler was conducted by under the direction of the AVF 
according to procedures established by the Ada Joint Program Office and 
administered by the Ada Validation Organization (AVO). On-site testing was 
completed 14 March 1989 at Alsys SA. m La Celle Saint Cloud, FRANCE. 


1.2 USE OF THIS VALIDATION SUMMARY REPORT 

Consistent with the national laws of the originating country, the AVO may 
make full and free public disclosure of this report. In the United States, 
this is provided m accordance with the "Freedom of Information Act"(5 
U.S.C.#552). The results of this validation apply only to the computers, 
operating systems, and compiler versions identified in this report. 

The organizations represented on the signature page of this report do not 
represent or warrant that all statements set forth in this report are 
accurate and complete, or that the subject compiler has no nonconformities 
to the Ada Standard other than those presented. Copies of this report are 
available to the public from: 

Ada Information Clearinghouse 
Ada Joint Program Office 
OUSDRE 

The Pentagon, Rm 3D-139 (Fern Street) 

Washington DC 20301-3081 


or from: 

AFNOR 

Tour Europe 
cedex 7 

F-92080 Paris la Defense 






INTRODUCTION 


Questions regarding this report or the validation test results should 
be directed to the AVF listed above or to: 

Ada Validation Organization 
Institute for Defense Analyses 
1801 North Beauregard Street 
Alexandria VA 22311 









INTRODUCTION 


1.3 REFERENCES 

1. Reference Manual for the Ada Programming Language , ANSI/KIL-STD- 
1815A, February 1933, and ISO 8652-1987. 

2. Ada Compiler Validation Procedures and Guidelines , Ada Joint Program 
Office, 1 January 1987. 

3. Ada Compiler Validation Capability Irr.plementers' Guide . SofTech, 
Inc., December 1986. 

4. Ada Compiler Validation Capability User's Guide , December 1986 


1.4 DEFINITION OF TERMS 


ACVC The Ada Compiler Validation Capability. The set of Ada 

programs that tests the conformity of an Ada compiler to the 
Ada programming language. 


Ada Commentary An Ada Commentary contains all information relevant to the 
point addressed by a" comment on the Ada Standard. These 
comments are given a unique identification number having the 
form Al-addda. 


Ada Standard ANSI/MIL-STD-1815A, February 1983 and ISO 8652-1987. 
Applicant The agency requesting validation. 


AVF The Ada Validation Facility. The AVF is responsible for 

conducting compiler validations according to procedures 
contained in the Ada Compiler Validation Procedures and 
Guidelines. 


AVO 


Compiler 


Failed test 


The Ada Validation Organization. The AVO has oversight 
authority over all AVF practices for the purpose of 
maintaining a uniform process for validation of Ada 
compilers. The AVO provides administrative and technical 
support for Ada validations to ensure consistent practices. 

A processor for the Ada language. In the context of this 
report, a compiler is any language processor, including 
cross-compilers, translators, and interpreters. 

An ACVC test for which the compiler generates a result that 
demonstrates nonconformity to the Ada Standard. 


Host 


The computer on which the compiler resides. 








INTRODUCTION 


Inapplicable test An ACVC test that uses features of the language that 

a compiler is not required to support or may legitimately 
support in a way other than the one expected by the test. 

Passed test An ACVC test for which a compiler generates the expected 

result. 

Target The computer for which a compiler generates code. 

Test A program that checks a compiler’s conformity regarding a 

particular feature or a combination of features to the Ada 
Standard. In the context of this report, the term is used to 
designate a single test, which may comprise one or more 
files. 

Withdrawn test An ACVC test found to be incorrect and not used to check 
conformity to the Ada Standard. A test may be incorrect 
because it has an invalid test objective, fails to meet its 
test objective, or contains illegal or erroneous use of the 
language. 


1.5 ACVC TEST CLASSES 

Conformity to the Ada Standard is measured using the ACVC. The ACVC contains 
both legal and illegal Ada programs structured into six test classes: A, B, 
C, D, E, and L. The first letter of a test name identifies the class to 
which it belongs. Class A, C, D, and E tests are executable, and special 
program units are used to report 'their results during execution. Class B 
tests are expected to produce compilation errors. Class L tests are expected 
to produce compilation or link errors. 

Class A tests check that legal Ada programs can be successfully compiled and 
executed. There are no explicit program components m a Class A test to 
check semantics. For example, a Class A test checks that reserved words of 
another language (other than those already reserved in the Ada language) are 
not treated as reserved words by an Ada compiler. A Class A test is passed 
if no errors are detected at compile time and the program executes to 
produce a PASSED message. 

Class B tests check that a compiler detects illegal language usage. Class B 
tests are not executable. Each test in this class is compiled and the 
resulting compilation listing is examined to verify that every syntax or 
semantic error in the test is detected. A Class B test is passed if every 
illegal construct that it contains is detected by the compiler. 


Class C tests check that legal Ada programs can be correctly compiled and 
executed. Each Class C test is self-checking and produces a PASSED, FAILED, 
or NOT APPLICABLE message indicating the result when it is executed. ■ 









INTRODu." ' 0.7 


Class D tests check the compilation and execution capacities of a compiler. 
Since th<-re are no capacity requirements placed on a compiler by the Ada 
Standard for some parameters—for example, the number of identifiers 
permitted in a compilation or the number of units in a library—a compiler 
may refuse to compile a Class D test and still be a conforming compiler. 
Therefore, if a Class D test fails to compile because the capacity of the 
, compiler is exceeded, the test is classified as inapplicable. If a Class D 

i test compiles successfully, it is self-checking and produces a PASSED or 

j FAILED message during execution. 

Each Class E test is self-checking and produces a NOT APPLICABLE, PASSED, or 
FAILED message when it is compiled and executed. However, the Ada Standard 
permits an implementation to reject programs containing some features 
addressed by Class E tests during compilation. Therefore, a Class E test is 
passed by a compiler if it is compiled successfully and executes to produce 
a PASSED message, or if it is rejected by the compiler for an allowable 
reason. 

Class L tests check that incomplete or illegal Ada programs involving 
multiple, separately compiled units are detected and not allowed to execute. 
Class L tests are compiled separately and execution is attempted. A Class L 
test passes if it is rejected at link time—that is, an attempt to execute 
the main program must generate an error message before any declarations in 
the mam program or any units referenced by the main program are elaborated. 

Two library units, the package REPORT and the procedure CHECK_FILE, support 
the self-checking features of the executable tests. The package REPORT 
provides the mechanism by which executable tests report PASSED, FAILED, or 
NOT APPLICABLE results. It also provides a set of identity functions used to 
defeat some compiler optimizations allowed by the Ada Standard that would 
circumvent a test objective. The procedure CHECK_FILE is used to check the 
contents of text files written by some of the Class C tests for chapter 14 
of the Ada Standard. The operation of REPORT and CHECK_FILE is checked by a 
set of executable tests. These tests produce messages that are examined to 
verify that the units are operating correctly. If these units are not 
operating correctly, then the validation is not attempted. 

The text of the tests in the ACVC follow conventions that are intended to 
ensure that the tests are reasonably portable without modification. For 
example, the tests make use of only the basic set of 55 characters, contain 
lines with a maximum length of 72 characters, use small numeric values, and 
place features that may not be supported by all implementations m separate 
tests. However, some tests contain values that require the test to be 
customized according to implementation-specific values—for example, an 
illegal file name. A list of the values used for this validation is provided 
in Appendix C. 

A compiler must correctly process each of the tests in the suite and 
demonstrate conformity to the Ada Standard by either meeting the pass 
criteria given for the test or by showing that the test is inapplicable to 
the implementation. The applicability of a test to an implementation is 
considered each time the implementation is validated. A test that is 
inapplicable for one validation is not necessarily inapplicable for a 
subsequent validation. Any test that was determined to contain an illegal 
language construct or an erroneous language construct is withdrawn from the 
ACVC and, therefore, is not used in testing a compiler. The tests withdrawn 
at the time of this validation are given in Appendix D. 






CONFIGURATION INFORMATION 


CHAPTER 2 

CONFIGURATION INFORMATION 

2.1 CONFIGURATION TESTED 

The candidate compilation system for this validation was tested under the 
following configuration: 

Compiler: AlsyCOMP_002, Version 4.3 
ACVC Version: 1.10 
Certificate Number: 890314A1.10038 
Host Computer: 

Machine: HP 9000 S 350 

Operating System: HP-UX, Version 6.2 

Memory Size: 8 Mb 

Configuration Information : MC68020 processor 

MC 68881 floating-point coprocessor 

Target Computer: 

Machine: HP 9000 S 350 

Operating System: HP-UX, Version 6.2 

Memory Size: 8 Mb 

Configuration Information : MC68020 processor 

MC 68881 floating-point coprocessor 

Communications Network: none 








CONFIGURATION INFORMATION 


2.2 IMPLEMENTATION CHARACTERISTICS 

One of the purposes of validating compilers is to determine the behavior of 
a compiler in those areas of the Ada Standard that permit implementations to 
differ. Class D and E tests specifically check for such implementation 
differences. However. tests in other classes also characterize an 
implementation. The tests demonstrate the following characteristics: 


a. Capacities. 

(1) The compiler correctly processes a compilation containing 723 
variables in the same declarative part. (See test D29002K.) 

(2) The compiler correctly processes tests containing loop statements 
nested to 65 levels. (See tests D55AC3A..H (8 tests).) 

(3) The compiler correctly processes a test containing block statements 
nested to 6o levels. (See test D56001B.) 

(4) The compiler correctly processes tests containing recursive 
procedures separately compiled as subunits nested to 17 levels. 
(See tests D64005E..G (3 tests}.) 


b. Predefined types. 

(1) This implementation supports the additional predefined types, 
SHORT_INTEGER, LONG_INTEGER, L0NG_FL0AT in the package STANDARD. 
(See tests B86001T..Z (7 tests}.) 


c. Based literals. 

(1) An implementation is allowed raise NUMERIC_ERROR or 

CONSTRAINT_ERROR when a value exceeds SYSTEM.MAX_INT . This 
implementation raises NUMERIC_ERROR during execution. (See test 
E24201A.) 


d. Expression evaluation. 

The order in which expressions are evaluated and the time at which 
constraints are checked are not defined by the language. While the 
ACVC tests do not specifically attempt to determine the order of 
evaluation of expressions, test results indicate the following: 


(1) Apparently no default initialization expressions for record 
components are evaluated before any value is checked to belong to a 
component's subtype. (See test C32117A.) 

(2) Assignments for subtypes are performed with the same precision as 
the base type. (See test C35712B.) 

(3) This implementation uses no extra bits for extra precision. This 
implementation uses all extra bits for extra range. (See test 
C35903A.) 







CONFIGURATION INFORMATION 


(4) Apparently NUMERIC_ERROR is raised when an integer literal operand 
in a comparison or membership test is outside the range of the base 
type. (See test C45232A.) 

(5) Apparently NUMERIC_ERROR is raised when a literal operand in a 
fixed-point comparison or membership test is outside the range of 
the base type. (See test C45252A.) 

(6) Apparently underflow is gradual. (See tests C45524A..Z.) (26 tests) 


e. Rounding. 

The method by which values are rounded in type conversions is not 
defined by the language. While the ACVC tests do not specifically 
attempt to determine the method of rounding, the test results indicate 
the following: 


(1) The method used for rounding to integer is apparently round to 
even. (See tests C46012A..Z.) (26 tests) 

(2) The method used for rounding to longest integer is apparently round 
to even. (See tests C46012A..Z.) (26 tests) 

(3) The method used for rounding to integer in static universal real 
expressions is apparently round to even. (See test C4A014A.) 


f. Array types. 

An implementation is allowed to raise NUMERIC_ERROR or CONSTRAINT_ERROR 

for an array having a 'LENGTH that exceeds STANDARD.INTEGER'LAST and/or 

SYSTEM.MAX_INT. For this implementation: 

(1) Declaration of an array type or subtype declaration with more than 
SYSTEM.MAX_INT components raises NUMERIC_ERROR . (See test 
C36003A.) 

(2) NUMERIC_ERROR is raised when 'LENGTH is applied to an array type 
with INTEGER'LAST + 2 components. (See test 36202A.) 

(3) NUMERIC_ERROR is raised when an array type with SYSTEM.MAX_INT + 2 
components is declared. (See test C36202B.) 

(4) A packed BOOLEAN array having a 'LENGTH exceeding INTEGER’LAST 
raises no exception. (See test C52103X.)- 

(5) A packed two-dimensional BOOLEAN array with more than INTEGER'LAST 
components raises CONSTRAINT_ERROR when the length of a dimension 
is calculated and exceeds INTEGER'LAST. array objects are sliced. 
(See test C52104Y.) 

(6) In assigning one-dimensional array types, the expression appears to 
be evaluated in its entirety before CONSTRAINT_ERROR is raised when 
checking whether the expression’s subtype is compatible with the 
target's subtype. (See test C52013A.) 








CONFIGURATION IN.* CAUTION 


(7) In assigning two-dimensional array types, the expression does not 
appear to be evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is compatible 
with the target's subtype. (See test C52013A.) 


g. A null array with one dimension of length greater than INTEGER'LAST may 
raise NUMERIC_ERROR or CONSTRAINT_ERROR either when declared or 

assigned. Alternatively, an implementation may accept the declaration. 
However, lengths must match in array slice assignments. This 

implementation raises no exception. (See test E52103Y.) 


h. Discriminated types. 

(1) In assigning record types with discriminants, the expression 
appears to be evaluated in its entirety before CONSTRAINT_ERROR is 
raised when checking whether the expression's subtype is compatible 
with the target's subtype. (See test C52013A.) 


i. Aggregates. 

(1) In the evaluation of a multi-dimensional aggregate, all choices 
appear to be evaluated before checking against the index type. (See 
tests C43207A and C43207B.) 

(2) In the evaluation of an aggregate containing subaggregates, not all 
choices are evaluated before being checked for identical bounds. 
(See test E43212B.) 

(3) All choices are evaluated before CONSTRAINT_ERROR is raised if a 
bound in a non-null range of a non-null aggregate does not belong 
to an index subtype. (See test E43211B.) 


j. Pragmas. 

(1) The pragma INLINE is supported for functions or procedures, but not 
functions called inside a package specification. (See tests 
LA3004A..B, EA3004C..D, and CA3004E..F.) 


k. Generics. 

(1) Generic specifications and bodies can be compiled in separate 

compilations. (See tests CA1012A, CA2009C, CA2009F, BC3204C, and 

BC3205D.) 

(2) Generic subprogram declarations and bodies can be compiled in 
separate compilations. (See tests CA1012A and CA2009F.) 

(3) Generic library subprogram specifications and bodies can be 
compiled in separate compilations. (See test CA1012A.) 

(4) Generic non-library package bodies as subunits can be compiled in 
separate compilations. (See test CA2009C.) 






CONFIGURATION INFORMATION 


(?' Giiicr:c non-library subprogram jodies can comp:lee :n separate 

compilations frorr. their stubs. .Set test CA2009F.) 

(C) Generic unit bodies and their subunits can be compiled m separate- 
compilations. (See test CA3011A., 

(7) Generic package declarations anc oodles can be compiled in separate 
compilations. (See tests CA2009C, BC3204C, and BC3205D.) 

(8) Generic -ibrary package specifications and bodies can be compiled 
in separate compilations. (See tests BC3204C and BC3205D.) 

(9) Generic unit bodies and their subunits can be compiled in separate 
compilations. (See test CA3011A.J 


Input and output. 

(1) The package SEQUENTIAL_IO can be instantiated with unconstrained 
array types and record types with discriminants without defaults. 
(See tests AE2101C, EE2201D, and EE2201E.) 

(2) The package DIRECTJTO can be instantiated with unconstrained array 
types and record types with discriminants but CREATE will raise 
USEJERROR. (See tests AE2101H, EE2401D, and EE2401G.) 

(4) Modes IN_FILE and OUT_FILE are supported for SEQUENTIAL_IO. (See 
tests CE2102D..E, CE2102N, and CE2102P.) 

(5) Modes IN_FILE, OUT_FILE, and INOUT_FILE are supported for 

DIRECT_IO. (See tests CE2102F, CE2102I..J, CE2102R, CE2102T, and 

CE2102V.) 

(6) Modes IN_FIIjE and OUT_FILE are supported for text files. (See tests 
CE3102E and CE3102I..K.) 

(7) RESET and DELETE operations are supported for SEQUENTIAL_IO. (See 
tests CE2102G and CE2102X.) 

(8) RESET and DELETE operations are supported for DIRECT_IO. (See 
tests CE2102K and CE2102Y.) 

(9) RESET and DELETE operations are supported for text files. (See 
tests CE3102F..G, CE3104C, CE3110A, and CE3114A.) 

(10) Overwriting to a sequential file truncates to the last element 
written. (See test CE2208B.) 

(11) Temporary sequential files are given names and deleted when closed. 
(See test CE2108A.) 

(12) Temporary direct files are given names and deleted when closed. 
(See test CE2108C.) 









CONFIGURATION INFORMATION 


(13) Temporary text files are given names and deleted when closed. (See 
test CE3112A.) 

(14) More than one internal file can be associated with each external 

fij.e for sequential files when reading or writing (See tests 

CE2107A..E, CE2102L, CE2110B, and CE2111D.) 

(15) More than one internal file can be associated with each external 

file for direct files when reading or writing (See tests 

CE2107F..I, CE2110D and CE2111H.) 

(16) More than one internal file can be associated with each external 
file for text files when reading or writing. (See tests CE3111A..E, 
CE3114B, and CEJ115A.) 










TEST INFORMATION 


CHAPTER 3 

TEST INFORMATION 


3.1 TEST RESULTS 

Version 1.10 of the ACVC comprises 3717 tests. When this compiler was 
tested, 43 tests had been withdrawn because of test errors. The AVF 
determined that 352 tests were inapplicable to this implementation. 

All inapplicable tests were processed during validation testing 
except for 201 executable tests that use floating-point precision 
exceeding that supported by the implementation. Modifications to the 
code, processing, or grading for 51 tests were required. (See section 3.6.) 

The AVF concludes that the testing results demonstrate acceptable 
conformity to the Ada Standard. 


3.2 SUMMARY OF TEST RESULTS BY CLASS 


RESULT 


Passed 


Inapplicable 


Withdrawn 


TEST CLASS TOTAL 


A 

B 

C 

D 


L 


129 

1132 

1972 

17 

26 

46 

3322 

0 

6 

344 

0 

2 

0 

352 


2 

34 

c 

6 

0 

43 

130 

1140 

2350 

17 

34 

46 

3717 


TOTAL 








TEST INrU;.NATION 


j.? 5'jy.y, o r 


"re 


RESULTS PY 


RESULT CHAPTER TOTAL 



o 

3 

4 

6 

6 

7 

8 

9 

10 

11 

' O 

13 

14 


Passed 

198 

577 

555 

248 

172 

99 

161 

332 

137 

36 

252 

257 

296 

3322 

Inappl 

14 

72 

125 

0 

0 

0 

5 

1 

0 

0 

0 

118 

25 

352 

Warn 

X 

1 

0 

0 

0 

0 

0 

1 

0 

c 

J. 

35 

4 

43 

TOTAL 

213 

650 

680 

248 

172 

99 

166 

334 

137 

36 

253 

404 

325 

3717 


3.4 WITHDRAWN TESTS 

The following 43 tests were withdrawn from ACVC Version 1.10 at the time of 
this validation: 


A39005G 

B97102E 

BC3009B 

CD2A62D 

CD2A63A 

CD2A63B 

CD2A63C 

CD2A63D 

CD2A66A 

CD2A66B 

CD2A66C 

CD2A66D 

CD2A73A 

CD2A73B 

CD2A73C 

CD2A73D 

CD2A76A 

CD2A76B 

CD2A76C 

CD2A76D 

CD2A81G 

CD2A83G 

CD2A84M 

CD2A84N 

CD2D11B 

CD2B15C 

CD5007B 

CD50110 

CD7105A 

CD7203B 

CD7204B 

CD7205C 

CD7205D 

CE2107I 

CE3111C 

CE3301A 

CE341IB 

E28005C 

ED7004B 

ED7005C 


ED7005D ED7006C ED7006D 


See Appendix D for the reason that each of these tests was withdrawn. 


3.5 INAPPLICABLE TESTS 

Some tests do not apply to all compilers because they make use of features 
that a compiler is not required by the Ada Standard to support. Others may 
depend on the result of another test that is either inapplicable or 
withdrawn. The applicability of a test to an implementation is considered 
each time a validation is attempted. A test that is inapplicable for one 
validation attempt is not necessarily inapplicable for a subsequent attempt. 
For this validation attempt, 352 tests were inapplicable for the reasons 
indicated: 


The following 201 tests are not applicable because they have floating¬ 
point type declarations requiring more digits than System.Kax_Digits: 


C24113L..Y 
C35706L..Y 
C35708L..Y 
C45241L..Y 
C45421L..Y 
C45524L..Z 
C45641L..Y 


(14 tests) 
(14 tests) 
(14 tests) 
(14 tests) 
(14 tests) 
(15 tests) 
(1* tests) 


C35705L..Y 
C35707L..Y 
C35802L..Z 
C45321L..Y 
C45521L..2 
C45621L..Z 
C-6012L..Z 


(14 tests) 
(14 tests) 
(15 tests) 
(14 tests) 
(15 tests) 
(15 tests) 
(15 tests) 












TEST INFORMATION 


C35702A anc. ESSOO! 1 ! are no: applicable oecause this implementation 
supports nr predefined type Snort_Fioat. 

C45531K..? i4 tests: anc C45532X..? i4 tests) are not applicable because 
the value of System.Max_Kantissa is less tnan 32. 

C86001F, is not applicable because recompilation of Package SYSTEM is 
not allowed. 


B86001X, C45231D, and CD7102G are not applicable because this 
implementation does not support any predefined integer type with a name 
other than Integer, Long_Integer, or Short_Integer. 

B86001Y is not applicable because this implementation supports no 
predefined fixed-point type other than Duration. 

B860012 is not applicable because this implementation supports no 
predefined floating-point type with a name other than Float, Long_Float, 
or Short_Float. 

B91001H is not applicable because address clause for entries is not 
supported by this implementation. 

CD1009C, CD2A41A..B, CD2A41E, CD2A42A..B, CD2A42E..F, CD2A42I..J are not 
applicable because size clause on float is not supported by this 
implementation. 

CD1C04B, CD1C04E, CD4051A..D are not applicable because representation 
clause on derived records or derived tasks is not supported by this 
implementation. 


CD2A84B..I, CD2A84K..L are not applicable because size clause on access 
type is not supported by this implementation. 


CD1C04A, CD2A21C..D, CD2A22C..D, CD2A22G..H, 
CD2A32C..D, CD2A32G..K, CD2A41C..D, CD2A42C..D, 
CD2A51C..D, CD2A52C..D, CD2A52G..H, CD2A53D, CD2A54D, 
not applicable because size clause for derived private 
supported by this implementation. 


CD2A31C..D, 
CD2A42G..H, 
CD2A54H are 
type is not 


CD2A61A..D,F,H,I,J,K,L, CD2A62A..C, CD2A71A..D, CD2A72A..D, CD2A74A..D, 
CD2A75A..D are not applicable because of the way this implementation 
allocates storage space for one component, size specification clause for 
an array type or for a record type requires compression of the storage 
space needed for all the components (without gaps). 


CD4041A is not applicable because alignment "at mod 8" is not supported 
by this implementation. 

BD5006D is not applicable because address clause for packages is not 
supported by this implementation. 


CD5011B,D,F,H,L,N,R, CD5012C,D,G,H,L, CD5013B,D,F,H,L,N,R, CD5014U,V are 
not applicable because address clause for a constant is not supported by 
this implementation. 









TEST INFORMATION 


CH5012J, CD5013S, CD5014S are not applicable oecause address clause for 
a tass .s r.c: supported oy this implementation. 

CE21023 is mappli “able because this implement at ion supports create w.th 
.n_filfe rode for SEQUSi'7IAL_I0. 

CE2102E is inapplicable because this implementation supports create vith 
out_file mode for SEQUENTIAL_IO. 

CE2102F is inapplicable because this implementation supports create with 
mout_file mode for LIRECT_IO. 

CE2102I is inapplicable because this implementation supports create with 
m_file mode for DIRECT_IO. 

CE2102J is inapplicable because this implementation supports create with 
out_file mode for DIRECT_IO. 

CE2102N is inapplicable because this implementation supports open with 
in_fiie mode for SEQUENTIAL_IO. 

CE21020 is inapplicable because this implementation supports RESET with 
in_file mode for SEQUENTIAL_IO. 

CE2I02P is inapplicable because this implementation supports open with 
outjEile mode for SEQUENTIAL.IO. 

CE2102Q is inapplicable because this implementation supports RESET with 
outjEile mode for SEQUENTIAL_IO. 

CE2102R is inapplicable because this implementation supports open with 
inout_file mode for DIRECT_IO. 

CE2102S is inapplicable because this implementation supports RESET with 
mout_file mode for DIRECT_IO. 

CE2102T is inapplicable because this implementation supports open with 
m_file mode for DIRECT_IO. 

CE2102U is inapplicable because this implementation supports RESET with 
in_file mode for DIRECT_IO. 

CE2102V is inapplicable because this implementation supports open with 
out_file mode for DIRECT_IO. 

CE2102V is inapplicable because this implementation supports RESET with 
out_file mode for DIRECT_IO. 

EE2401D and EE2401G are not applicable because USE_ERROR is raised when 
the CREATE of an instantiation of DIRECT_IO with unconstrained type is 
called. 

CE2401H is not applicable because create with inout_fiie mode for 
unconstrained records with default discriminants is not supported by 
this implementation. 

CE3102E is inapplicable because this implementation supports create with 
in file mode for text files.___ 






TEST INFORMATION 


CZ31C2F is inapplicable because This implementation supports rest: fo: 
text files, for o - .t_£ile, in_file and from ou:_file *o ir._flie node. 

CZ31C1G is inapplicable because this implementation supports deletion of 
a:, external tile : :;r text fi.es. 

CE3102I is inapplicable because this implementation supports create with 
out_fiie mode for text files. 

CE3102J is inapplicable because this implementation supports open with 
in_file mode for text files. 

CE3102K is inapplicable because this implementation supports open with 
out_file mode for text files. 

CE3202A requires the association of a name with the standard input and 
output files. This is not supported by the implementation and USE_ERROR 
is raised at execution. This behavior is accepted by the AVO pending a 
ruling by the langage maintenance body. 









TEST INFORMATION 


3.6 TEST, PROCESSING, AND EVALUATION MODIFICATIONS 

I; is expected that some tests will require modifications of code, 
processing, or evaluation in order to compensate for legitimate 
implementation behavior. Modifications are made by the AVF in cases where 
legitimate implementation behavior prevents the successful completion of an 
(otherwise) applicable test. Examples of such modifications include: adding 
a length clause to alter the default size of a collection; splitting a Class 
B test into subtests so that all errors are detected; and confirming that 
messages produced by an executable test demonstrate conforming behavior that 
wasn't anticipated by the test (such as raising one exception instead of 
another) . 

Modifications were required for 51 tests. 

The test EA3004D when run as it is, the implementation fails to detect an 
error on line 27 of test file EA3004D6M (line 115 of "cat -n ea3004d*"). 
This is because the pragma INLINE has no effect when its object is within a 
package specification. However, the results of running the test as it is 
does not confirm that the pragma had no effect, only that the package was 
not made obsolete. By re-ordering the compilations so that the two 
subprograms are compiled after file D5 (the re-compilation of the "with"ed 
package that makes the various earlier units obsolete), we create a test 
that shows that indeed pragma INLINE has no effect when applied to a 
subprogram that is called within a package specification: the test then 
executes and produces the expected NOT_APPLICABLE result (as though INLINE 
were not supported at all). The re-ordering of EA3004D test files is 
O-i-4-5-2-3-6. 

The following 27 tests were split because syntax errors at one point 
resulted in the compiler not detecting other errors in the test: 
B23004A B24007A B24009A B28003A B32202A B32202B B32202C B33001A B36307A 

B37004A B49003A B49005A B61012A B62001B B74304B B74304C B74401F B74401R 

B91004A B95032A B95069A B95069B BA1101B2 BA1101B4 BC2001D BC3009A BC3009C 

BD5005B 

The following 21 tests were split in order to show that the compiler was 
able to find the representation clause indicated by the comment 
—N/A =)ERROR : 

CD2A61A CD2A61B CD2A61F CD2A61I CD2A61J CD2A62A CD2A62B CD2A71A CD2A72B 
CD2A72A CD2A72B CD2A75A CD2A75B CD2A84B CD2A84C CD2A84D CD2A84E CD2A84F 
CD2A84G CD2A84H CD2A84I 

Modified versions were produced for the following 2 tests, in order to have 
the test run to completion and fully exhibit the test behavior: 

In test C87B62B, an explicit STORAGE_SIZE clause was added for the 
access type declared at line 68. This allows the test to execute 
without raising STORAGE_ERROR and to meet its objective (test 
overloading resolution in expression within length clause). The test 
then produces the expected PASSED result. 










TEST INFORMATION 


In test CE3202A, the NAME (STANDARD_INPUT) and NAME (STANDARD_OUTPUT) 
calls at lines 25 and 29 were encapsulated m blocks with explicit 
• exception handlers that produce a NOT_APPLICABLE result in the 
USE_ERROR case, and a FAILED result m the OTHERS case. The test then 
produces the expected NOT_AP?LICABLE result. 

CE3202A requires the association of a name with the standard input and 
output files. This is not supported by the implementation and USE_ERROR 
is raised at execution. This behavior is accepted by the AVO pending a 
ruling by the langage maintenance body. 


BA2001E requires that duplicate names of subunits with a common ancestor be 
detected and rejected at compile time. This implementation detects the error 
at link time, and the AVO ruled that this behavior is acceptable. 



EST INFORMATION 


3.7 ADDITIONAL TESTING INFORMATION 
3.7.1 Prevalidation 

Prior to validation, a set of test results for ACVC Version 1.10 produced by 
the AlsyCOMP_002 was submitted to the AVF by the applicant for review. 
Analysis of these results demonstrated that the compiler successfully passed 
all applicable tests, and the compiler exhibited the expected behavior on 
all inapplicable tests. 


3.7.2 Test Method 

Testing of the AlsyCOMP_002 using ACVC Version 1.10 was conducted on-site by 
a validation team from the AVF. The configuration consisted of a HP 9000 S 
350 operating under HP-UX, Version 6.2. 

A tape containing all tests was taken on-site by the validation team for 
processing. Tests that make use of implementation-specific values were 
customized by Alsys after loading of the tape. 

The contents of the tape were not loaded directly onto the host computer. 
They were loaded on a VAX/VMS machine and transferred via a network to the 
HP 9000 S 350. This is the reason why prevalidation tests were used for the 
the validation. Those tests were loaded by Alsys from a magnetic tape 
containing all tests provided by the AVF. Customization was done by Alsys. 
All the tests were checked at prevalidation time. 

Integrity of the validation tests was made by checking that no modification 
of the test occured after the time the prevalidation results were 
transferred on cartridge tape for submission to the AVF. This check was 
performed by verifying that the date of creation (or last modification) of 
the test files was earlier than the prevalidation date. After validation was 
performed, 80 source tests were selected by the AVF and checked for 
integrity. 

The full set of tests was compiled, linked, and all executable tests were 
run on the HP 9000 S 350. Results were printed from the host computer. 

The compiler was tested using command scripts provided by Alsys and reviewed 
by the validation team. The compiler was tested using all default option 
settings except for the following: 

OPTION / SWITCH EFFECT 

FLOAT=MC68881 Floating point operations use the MC68881 arithmetic 

coprocessor 

CALLS*INLINED Allow inline insertion of code for subprograms and take 

pragma INLINE into account 


REDUCTION=PARTIAL 


Perform some high level optimizations on checks and 
loops 







TEST INFORMATION 


EXPRESSION=PARTIAL Perform some low level optimizations on common 

subexpressions and register allocation 


Tests were compiled, linked, and executed (as appropriate) using a single 
computer. Test output, compilation listings, and job logs were captured on 
cartridge tape and archived at the AVF. The listings examined on-site by the 
validation team were also archived. 


3.7.3 Test Site 

Testing was conducted at Aisys, SA. in La Celle Saint Cloud, FRANCE and was 
completed on 14 March 19£9. 





DECLARATION t 


APPENDIX A 

DECLARATION OF CONFORMANCE 


' CONFORMANCE 


Alsys has submitted the following 
Declaration of Conformance concerning the AlsyCOMP_002. 











DECLARATION OF CONFORMANCE 


DECLARATION OF CONFORMANCE 
Compiler Implementor: Alsys 

Ada Validation Facility: AFNOR, Tour Europe Cedex 7, 

F-92080 Paris la Defense 

Ada Compiler Validation Capability (ACVC) Version: 1.10 


Base Configuration 


Base Compiler Name: 

Host Architecture: 

HOST OS and Version: 

Target Architecture: 
Target OS and Version: 


AlsyCOMP_002 Version 4.3 

HP 9000 S 350 
HP-UX, Version 6.2 

HP 9000 S 350 
HP-UX, Version 6.2 


Implementor's Declaration 

I, the undersigned, representing Alsys, have implemented no deliberate 
extensions to the Ada Language Standard ANSI/MIL-STD-1815A in the 
compiler(s) listed in this declaration. I declare that Alsys is the owner of 
record of the Ada language compiler(s) listed above and, as such, is 
responsible for maintaining said compiler(s) in conformance to ANSI/MIL-STD- 
1815A. All certificates and registrations for Ada language compiler(s) 
listed in this declaration shall be made only in the owner's corporate name. 


rX_ 

- - • - _ Date: 

Alsys 

Etienne Morel, Managing Director 



3D MA11989 










DECLARATION OF CONFORMANCE 


Owner's Declaration 

I, the undersigned, representing Alsys, take full responsibility for 
implementation and maintenance of the Ada compiler(s) listed above, and 
agree to the public disclosure of the final Validation Summary Report. I 
further agree to continue to comply with the Ada trademark policy, as 
defined by the Ada Joint Program Office. I declare that all of the Ada 
language compilers listed, and their host/target performance, are in 
compliance with the Ada Language Standard ANSI/MIL-STD-1815A. 



Alsys 

Etienne Morel, Managing Director 





TEST PARAMETERS 


APPENDIX B 
TEST PARAMETERS 


Certain tests in the ACVC make use of implementation-dependent values, such 
as the maximum length of an input line and invalid file names. A test that 
makes use of such values is identified by the extension .TST m its file 
name. Actual values to be substituted are represented by names that begin 
with a dollar sign. A value must be substituted for each of these names 
before the test is run. The values used for this validation are given below. 


Name and Meaning Value 


$ACC_SIZE 32 

An integer literal whose value 
is the number of bits sufficient 
to hold any value of an access 
type. 

$BIG_ID1 'X234567890'4(24*'1234567890')4’12341’ 

Identifier the size of the 
maximum input line length 
with varying last character. 

$BIG_ID2 ’X234567890’&(24*'1234567890*)&'12342' 

Identifier the size of the 
maximum input line length 
with varying last character. 

$BIG_ID3 

Identifier the size of the 
maximum input line length 
with varying middle character. 

$BIG_ID4 'X234567890'4(11*'1234567890') 

&' 12345XX4XX12345'&(12*'1234567890')' 

Identifier the size of the 
maximum input line length 
with varying middle character. 


'X234567890'& 111*'1234567890') 
&’12345XX3XX12345’4(12*'1234567890') ' 










'■SST PARAMETERS 


Name and Meaning 


$BIG_INT_LIT 

An integer literal of value 
298 with enough leading zeroes 
so that it is the size of the 
maximum line length. 

$BIG_R£AL_LIT 

A universal real literal of 
value 690.0 with enough 
leading zeroes to be the size 
of the maximum line length. 

$BIG_STRING1 

A string literal which when 
catenated with BIG_STRING2 
yields the image of BIG_ID1. 

$BIG_STRING2 

A string literal which when 
catenated to the end of 
BIG_STRING1 yields the image 
of BIG_ID1. 

SBLANKS 

? sequence of blanks twenty 
characters less than the size 
of the maximum line length. 

$COUNT_LAST 

A universal integer literal whose 
value is TEXT_I0.COUNT'LAST. 

$DEFAULT_MEM_SIZE 
An integer literal whose value 
is SYSTEM.MEMORY_SIZE. 

$DEFAULT_STOR_UNIT 
An integer literal whose value 
is SYSTEM.STORAGEJJNIT. 

$DEFAULT_SYS_NAME 
The value of the constant 
SYSTEM.SYSTEM_NAME. 

$DELTA_D0C 

A real literal whose value is 
SYSTEM.FINE DELTA. 


Value 

(252 * * 0 *) 4 '298' 

(250 * '0') 4 '690.O’ 

""4'X234567890'4 (11*’1234567890') 4"" 

""4(13* ' 1234567890' )&' 12341 

(235 * ’ ’) 

2_147_483_647 

2**32 

8 

UNIX 

2#1.0#E-31 






TEST PARAMETERS 


Name and Meaning Value 


$FIELD_LAS? 255 

A universal integer literal whose 
value is TEXT_IC.FIELD'LAST. 

$FIX£D_NAME NO_SUCH_TYPE 

The name of a predefined 
fixed-point type other than 
DURATION. 

$FLOAT_NA>:E NO_SUCH_TYPE 

The name of a predefined 
floating-point type other than 
FLOAT, SHORTJTLGVT, or 
LONG_FLOAT. 

$GREATER_THAN_DURATION 100_000.0 

A universal real literal that 
lies between DURATION'BASE'LAST 
and DURATION'LAST or any value 
m the range of DURATION. 

$GREATER_THAN_DURATION_BASE_LAST 100_000_000.0 
A universal real literal that is 
greater than DURATION'BASE'LAST. 

$HIGE_?RIORITY 127 

An integer literal whose value 
is the upper bound of the range 
for the subtype SYSTEM.PRIORITY. 

$ILLEGAL_EXTERNAL_FILE_NAMEi /*/* It 1 

An external file name specifying 
a non existent directory 

$ILLEGAL_EXTERNAL_FILE_NAME2 /'/*/f 2 

An external file name different 

from SILLEGAL_EXTERNAL_FILE_NAMEI 

$INTEGER_FIRST -32768 

A universal integer literal # 
whose value is INTEGER'FIRST. 

$INTEGEP._LAST 32767 

A universal integer literal 
whose value is INTEGER’LAST. 

$INTEGER_LAST_PLUS_1 
A universal integer literal 
whose value is INTEGER'LAST + 1. 


32768 










TEST PARAMETERS 


Name and Meaning 


Value 


$LESS_THAN_DURATION 
A universal real literal that 
lies between DURATION'BASE'FIRST 
and DURATION'FIRST or any value 
in the range of DURATION. 

$LESS_THAN_DURATION_BAS£_FIRST 
A universal real literal that is 
less than DURATION'BASE'FIRST. 

$LOV_PRIORITY 

An integer literal whose value 
is the lower bound of the range 
for the subtype SYSTEM.PRIORITY. 

S MANTIS SA_DOC 

An integer literal whose value 
IS SYSTEM.MAX_MANTISSA. 

$MAX_DIGITS 

Maximum digits supported for 
floating-point types. 

$MAX_IN_LEN 

Maximum input line length 
permitted by the implementation. 

$MAX_INT 

A universal integer literal 
whose value is SYSTEM.MAX_INT. 

$MAX_INT_PLUS_1 
A universal integer literal 
whose value is SYSTEM.MAX_INT+1. 

$MAX_LEN_INT_BASED_LITERAL 
A universal integer based 
literal whose value is 2:11: 
with enough leading zeroes in 
the mantissa to be MAX_IN_LEN 
long. 

$MAXJuEN_REAL_BASED_LITERAL 
A universal real based literal 
whose value is 16: F.E: with 
enough leading zeroes in the 
mantissa to be MAX_IN_L£N long. 


- 100 _ 000.0 

- 100 _ 000 _ 000.0 

1 

31 

15 

255 

2_147_483_647 

2_147_4S3_648 

'2:' & (250 * '0') & 'll:' 

'16:' & (248 * ’O’) & ’F.E:’ 









TEST PARAMETERS 


Name and Meaning Value 


$MAX_STRING_LITERAL *"’&(25* 1 1234567890 *)&*123* 

A string literal of size 
MAX_IN_LEN, including the quote 
characters. 

$MIN_INT -2147483648 

A universal integer literal 
whose value is SYSTEM.MIN_INT. 

$MIN_TASK_SIZE 32 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
no entries, no declarations, and 
NULL;" as the only statement in 
its body. 

SNAME NO_SUCH_TYPE 

A name of a predefined numeric 
type other than FLOAT, INTEGER, 

SHORT_FLOAT, SHORT_INTEGER, 

LONG_FLOAT, or LONG_INTEGER. 

$NAME_LIST UNIX 

A list of enumeration literals 
in the type SYSTEM.NAME, 
separated by commas. 

$NEG_BASED_INT 16#FFFFFFFE# 

A based integer literal whose 
highest order nonzero bit falls 
in the sign bit position of the 
representation for SYSTEM.MAX_INT. 

$NEV_MEM_SIZE 2**32 

An integer literal whose value 
is a permitted argument for 
pragma memory_size, other than 
DEFAULT_MEM_SIZE; If there is 
no other value, then use 
DEFAULT_MEM_SIZE. 

$NEV_STOR_UNIT 8 

An integer literal whose value 
is a permitted argument for 
pragma storage_unit, other than 
DEFAULT_STOR_UNIT. If there is 
no other permitted value, then 
use value of SYSTEM.STORAGE UNIT. 






TEST PARAMETER 


Name and Meaning Value 


SNEV_SYS_NAME UNIX 

A value~of the type SYSTEM.NAME, 
other than $DEFAULT_SYS_NAME. If 
there is only one value of that 
type, then use that value. 

$TASK_SIZE 32 

An integer literal whose value 
is the number of bits required 
to hold a task object which has 
a single entry with one inout 
parameter. 

STICK 1.0 

A real literal whose value is 
SYSTEM.TICK. 








WITHDRAWN TESTS 


APPENDIX C 
WITHDRAWN TESTS 


Some tests are withdrawn from the ACVC because they do not conform to the 
Ada Standard. The following 43 tests had been withdrawn at the time of 
validation testing for the reasons indicated. A reference of the form AI- 
ddddd is to an Ada Commentary. 

E28005C 

This test expects that the string "— TOP OF PAGE. —63" of line 204 will 
appear at the top of the listing page due to a pragma PAGE in line 2C3; but 
line 203 contains text that follows the pragma, and it is this that must 
appear at the top of the page. 

A39005G 

This test unreasonably expects a component clause to pack an array component 
into a minimum size (line 30} . 

B97102E 

This test contains an unitended illegality: a select statement contains a 
null statement at the place of a selective wait alternative (line 31). 

BC3009B 

This test wrongly expects that circular instantiations will be detected in 
several compilation units even though none of the units is illegal with re¬ 
spect to the units it depends on; by AI-00256, the illegality need not be 
detected until execution is attempted (line 95}. 

CD2A62D 

This test wrongly requires that an array object's size be no greater than 10 
although its subtype's size was specified to be 40 (line 137). 

CD2A63A..D, CD2A66A..D, CD2A73A..D, CD2A76A..D [16 tests] 

These tests' wrongly attempt to check the size of objects of a derived type 
(for which a ’SIZE length clause is given) by passing them to a derived sub¬ 
program (which implicitly converts them to the parent type (Ada standard 
3.4:14}). Additionally, they use the ’SIZE length clause and attribute, 
whose interpretation is considered problematic by the WG9 ARC. 

CD2A81G, CD2A83G, CD2A84N & H, & CD50110 [5 tests] 

These tests assume that dependent tasks will terminate while the main pro¬ 
gram executes a loop that simply tests for task termination; this is not 
the case, and the main program may loop indefinitely (lines 74, 85, 86 & 96, 
86 A 96, and 58, resp.). 






WITHDRAWN TESTS 


CD2B15C & CD7205C 

These tests expect that a 'STORAGE_SIZE length clause provides precise con¬ 
trol over the number of designated objects in a collection; the Ada standard 
13.2:15 allows that such control must not be expected. 

CD2D11B 

This test gives a SMALL representation clause for a derived fixed-point type 
(at line 30) that defines a set of model numbers that are not necessarily 
represented in the parent type; by Commentary AI-00099, all model numbers of 
a derived fixed-point type must be representable values of the parent type. 

CD5007B 

This test wrongly expects an implicitly declared subprogram to be at the 
the address that is specified for an unrelated subprogram (line 303). 

/ 

ED7004B, ED7005C & D, ED7006C & D [5 tests] 

These tests check various aspects of the use of the three SYSTEM pragmas; 
the AVO withdraws these tests as being inappropriate for validation. 

CD7105A 

This test requires that successive calls to CALENDAR.CLOCK change by at 
least SYSTEM.TICK; however, by Commentary AI-00201, it is only the expected 
frequency of change that must be at least SYSTEM.TICK—particular instances 
of change may be less (line 29). 

CD7203B, & CD7204B 

These tests use the 'SIZE length clause and attribute, whose interpretation 
is considered problematic by the WG9 ARG. 

CD7205D 

This test checks an invalid test objective: it treats the specification of 
storage to be reserved for a task's activation as though it were like the 
specification of storage for a collection. 

CE2107I 

This test requires that objects of two similar scalar types be distinguished 
when read from a file—DATA_ERROR is expected to be raised by an attempt to 
read one object as of the other type. However, it is not clear exactly how 
the Ada standard 14.2.4:4 is to be interpreted; thus, this test objective is 
not considered valid, (line 90) 

CE3111C 

This test requires certain behavior, when two files are associated with the 
same external file, that is not required by the Ada standard. 

CE3301A 

This test contains several calls to END_OF_LINE & END_OF_PAGE that have no 
parameter: these calls were intended to specify a file, not to refer to 
STANDARD_INPUT (lines 103, 107, 118, 132, & 136). 

CE3411B 

This test requires that a text file's column number be set to COUNT'LAST in 
order to check that LAYOUT_ERROR is raised by a subsequent PUT operation. 

But the former operation will generally raise an exception due to a lack of 
available disk space, and the test would thus encumber validation testing. 



APPE..JIX F OF THE Ada STANDARD 


APPENDIX D 

APPENDIX F OF THE Ada STANDARD 


The only allowed implementation dependencies correspond to implementation- 
dependent pragmas, to certain machine-dependent conventions as mentioned in 
chapter 13 of the Ada Standard, and to certain allowed restrictions on 
representation clauses. The implementation-dependent characteristics of the 
AlsyCOMP_002, Version 4.3, are described in the following sections, which 
discuss topics in Appendix F of the Ada Standard. Implementation-specific 
portions of the package STANDARD are also included in this appendix. 

package STANDARD is 


type INTEGER is range -32_768 .. 32_767; 
type SHORT_INTEGER is range -128 .. 127; 

type LONG_INTEGER is range -2_147_483_648 .. 2_147_483_647; 

type FLOAT is digits 6 range 
-2fl.lll_llll_llll_llll_llll_llll#E+127 

2#l.lll_nil_llll_mi_llll_llll#E+127; 

type LONG_FLOAT is digits 15 range 

-2#1.llll_llll_llll_llll_llll_illl_lill_llll_llll_llll_llll_llll_llll#E1023 
21 1.1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111_1111#E1023; 
type DURATION is delta 2#0.000_000_000_000_01# range —86_400.0 ..86_400.0; 


end STANDARD; 







APPENDIX F 


1 INTERFACING THE LANGUAGE ADA WITH OTHER 
LANGUAGES 

Programs written in Ada can interface with external subprograms written in another 
language, by use of the INTERFACE pragma. The format of the pragma is: 

pragma INTERFACE ( language_name , Ada_subprogram_name ) ; 

where the language_name can be any of 

■ Assembler 

■ C 

■ Fortran 

■ Pascal 

It should be emphasized that in the discussion which follows the standard HP products 
are being considered. Compiler products other than those provided by HP or Alsys may 
not conform to the conventions given below. 

The .ida_subprogram_name is the name by which the subprogram is known in Ada. For 
example, to call a subprogram known as FAST_FOURIER in Ada, written in C, the 
INTERFACE pragma is: 

pragma INTERFACE ( C, FAST_FOURIER); 

To relate the name used in Ada with the name used in the original language, the Alsys 
Ada compiler converts the latter name to lower case and truncates it to 32 significant 
characters. 

To avoid naming conflict with routines of the Alsys Ada Executive, external routine 
names should not begin with the letters alsy (whether in lower or upper case or a 
combination of both). 

To allow the use of non-Ada naming conventions, such as special characters, or case 
sensitivity, an implementation-dependent pragma INTERFACE_NAME has been 
introduced: 

pragma INTERFACE_NAME ( Ada_subprogram_name. name_siring ) ; 
so that, for example, 

pragma INTERFACE_NAME (FAST_FOURIER, "fft" ); 


AlsyCOMP Appendix F Version 4.1 


1 


will associate the FAST_FOURIER subprogram in Ada with the C subprogram fft. 

In order to conform to the naming conventions of the UNIX Linker, an underscore is 
prepended to the name given by name_string, the result is then truncated to 255 
characters. 

The pragma INTERFACE_NAME may be used anywhere in an Ada program where 
INTERFACE is allowed (see [13.9]). INTERFACE_NAME must occur after the 
corresponding pragma INTERFACE and within the same declarative part. 


2 IMPLEMENTATION-DEPENDENT PRAGMAS 

Pragma INTERFACE 

This pragma has been described in the previous section. 

Pragma IMPROVE and Pragma PACK 

These pragmas are discussed in sections 5.7 and 5.8 on representation clauses for arrays 
and records. 

Note that packing of record types is done systematically by the compiler. The pragma 
pack will affect the mapping of each component onto storage. Each component will be 
allocated on the logical size of the subtype. 

Example: 

type R is 

record 

Cl : BOOLEAN; C2 : INTEGER range 1 .. 10; 
end record; 
pragma PACK(R); 

— the attribute R’SIZE returns 5 

Pragma INDENT 

This pragma is only used with the Alsys Re/ormauer; this tool offers the functionalities 
of a pretty-printer in an Ada environment. 

The pragma is placed in the source file and interpreted by the Reformatter, 
pragma INDENT(OFF) 

causes the Reformatter not to modify the source lines after this pragma. 

. pragma INDENT(ON) 

causes the Reformatter to resume its action after this pragma. 

Pragmas not implemented 


AlsyCOMP Appendix F Version 4.1 


2 








The following pragmas are not implemented: 


CONTROLLED 
MEMORY_SIZE 
OPTIMIZE 
STORAGE_UNIT 
SYSTEM NAME 


3 IMPLEMENTATION-DEPENDENT ATTRIBUTES 

In addition to the Representation Attributes of [13.7.2] and [13.7.3], there are four 
attributes which are listed under F.5 below, for use in record representation clauses. 


Limitations on the use of the attribute ADDRESS 

The attribute ADDRESS is implemented for all prefixes that have meaningful addresses. 
The following entities do not have meaningful addresses and will therefore cause a 
compilation error if used as prefix to ADDRESS: 

■ A constant that is implemented as an immediate value i.e., aoes not have any 
space allocated for it. 

• A package specification that is not a library unit. 

■ A package body that is not a library unit or a subunit. 

4 PACKAGES SYSTEM AND STANDARD 

This section contains information on two predefined library packages'. 

■ a complete listing of the specification of the package SYSTEM 

■ a list of the implementation-dependent declarations in the package 
STANDARD. 

package SYSTEM is 

-- Standard Ada definitions 


type NAME is (UNIX) 



SYSTEM NAME 

constant NAME UNIX: 

STORAGE UNIT 

constant > 

8; 

MEMORY SIZE 

constant :■ 

2**32 ; 

MIN INT 

constant :» 

-(2**31); 

MAX INT 

constant > 

2**31 -1 ; 

MAX DIGITS 

constant :« 

15 ; 

MAX MANTISSA 

constant :» 

31 ; 

FINE DELTA 

constant > 

2#I.0#e-31 ; 

TICK 

constant :■ 

1.0; 


AlsyCOMP Appendix F Version 4.1 


3 




type ADDRESS is private; 

NULL_ADDRESS : constant ADDRESS; 

subtype PRIORITY is INTEGER range 1 ..127; 

— Address arithmetic 

function TO_LONG_INTEGER (LEFT : ADDRESS) 
return LONG__INTEGER; 

function TO_ADDRESS (LEFT : LONG_INTEGER) 
return ADDRESS; 

function (LEFT : LONG_INTEGER; RIGHT : ADDRESS) 
return ADDRESS; 

function V* (LEFT : ADDRESS; RIGHT : LONG_INTEGER) 
return ADDRESS; 

function (LEFT : ADDRESS; RIGHT : ADDRESS) 
return LONG_INTEGER; 

function (LEFT : ADDRESS; RIGHT : I.ONG_INTEGER) 
return ADDRESS; 

function "mod" (LEFT : ADDRESS; RIGHT : POSITIVE) 
return NATURAL; 

function "<" (LEFT : ADDRESS; RIGHT : ADDRESS) 
return BOOLEAN; 

function "<«" (LEFT : ADDRESS; RIGHT : ADDRESS) 
return BOOLEAN; 

function ">" (LEFT : ADDRESS; RIGHT : ADDRESS) 
return BOOLEAN; 

function ">«" (LEFT : ADDRESS; RIGHT : ADDRESS) 
return BOOLEAN; 

function IS_NULL (LEFT : ADDRESS) 
return BOOLEAN; 

function WORD_ALIGNED (LEFT : ADDRESS) 
return BOOLEAN; 

function ROUND (LEFT : ADDRESS) 
return ADDRESS; 

— Return the given address rounded to the next lower even value 

procedure COPY (FROM: ADDRESS; TO : ADDRESS; SIZE : NATURAL); 

— Copy SIZE storage units. The result is undefined if the two areas 

— overlap. 




AlsyCOMP Appendix F Version 4.1 


4 






-- Direct memory access 


generic 

type ELEMENT_TYPE is private; 
function FETCH (FROM : ADDRESS) return ELEMENT_TYPE; 

-- Return the bit pattern stored at address FROM, as a value of the 
-- specified ELEMENT_TYPE. This function is not implemented 
-- for unconstrained array types. 

generic 

type ELEMENT_TYPE is private; 
procedure STORE (INTO : ADDRESS; OBJECT : ELEMENT_TYPE); 
— Store the bit pattern representing the value of OBJECT, at the 
-- address INTO. This function is not implemented for 
-- unconstrained array types. 

private 

-- private part of the system 
end SYSTEM; 


The package STANDARD 

The following are the implementation-dependent parts of the package STANDARD: 

type SHORT_INTEGER is range -(2**7) .. (2**7 -1); 
type INTEGER is range -(2** 15) .. (2**15 -1); 
type LONG_INTEGER is range -(2**31) .. (2**31 -1); 

type FLOAT is digits 6 range 

-(2.0 - 2.0**(-23)) * 2.0**127 .. 

+(2.0 - 2.0**(-23)) * 2.0**127; 

type LONG_FLOAT is digits 15 range 
-(2.0 - 2.0**(-51)) * 2.0**1023 .. 

+(2.0 - 2.0**( -51)) * 2.0**1023; 

type DURATION is delta 2.0**(-14) range -86_400.0 .. 86_400.0; 


5 TYPE REPRESENTATION CLAUSES 


The representation of an object is closely connected with its type. For this reason this 
section addresses successively the representation of enumeration, integer, floating point, 
fixed point, access, task, array and record types. For each class of type the 
representation of the corresponding objects is described. 


AlsyCOMP Appendix F Version 4.1 


5 



Except in the case of array and record types, the description for each class of type is 
independent of the others. To understand the representation of an array type it is 
necessary to understand first the representation of its components. The same rule applies 
to record types. 

Apart from implementation defined pragmas, Ada provides three means to control the 
size of objects: 

■ a (predefined) pragma PACK, when the object is an array, an array 
component, a record or a record component 

• a record representation clause, when the object is a record or a t ord 
component 

• a size specification, in any case. 

For each class of types the effect of a size specification alone is described. Interference 
between size specifications, packing and record representation clauses is described under 
array and record types. 


5.1 Enumeration Types 

Size of the objects of an enumeration subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of an enumeration subtype has the same size as its subtype. 


Alignment of an enumeration subtype 

An enumeration subtype is byte aligned if the size of the subtype is less than or equal to 
8 bits, it is otherwise even byte aligned. 


Address of an object of an enumeration subtype 

Provided its alignment is not constrained by a record representation clause or a pragma 
PACK, the address of an object of an enumeration subtype is even when its subtype is 
even byte aligned. 


5.2 Integer Types 

Size of the objects of an integer subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of an integer subtype has the same size as its subtype. 


AlsyCOMP Appendix F Version 4.1 


6 





Alignment of an integer subtype 

An integer subtype is byte aligned if the size of the subtype is less than or equal to 8 
bits, it is otherwise even byte aligned. 


Address of an object of an integer subtype 

Provided its alignment is not constrained by a record representation clause or a pragma 
PACK, the address of an object of an integer subtype is even when its subtype is even 
byte aligned. 

5.3 Floating Point Types 

Size of the objects of a floating point subtype 

An object of a floating point subtype has the same size as its subtype. 


Alignment of a floating point subtype 
A floating point subtype is always even byte aligned. 


Address of an object of a floating point subtype 

Provided its alignment is not constrained by a record representation clause or a pragma 
PACK, the address of an object of a floating point subtype is always even, since its 
subtype is even byte aligned. 


5.4 Fixed Point Types 

Size of the objects of a fixed point subtype 

Provided its size is not constrained by a record component clause or a pragma PACK, an 
object of a fixed point type has the same size as its subtype. 


Alignment of a fixed point subtype 

A fixed point subtype is byte aligned if its size is less than or equal to 8 bits, and is 
otherwise even byte aligned. 

Address of an object of a fixed point subtype 

Provided its alignment is not constrained by a record representation clause or a pragma 
PACK, the address of an object of a fixed point subtype is even when its subtype is 
even byte aligned. 


AlsyCOMP Appendix F Version 4.1 


7 







5.5 Access Types 

Size of an object of an access subtype 

An object of an access subtype has the same size as its subtype, thus an object of an 
access subtype is always 32 bits long. 


Alignment of an access subtype. 

An access subtype is always even byte aligned. 


Address of an object of an access subtype 

Provided its alignment is not constrained by a record representation clause or a pragma 
PACK, the address of an object of an access subtype is always even, since its subtype is 
even byte aligned. 


5.6 Task Types 

Size of the objects of a task subtype 

An object of a task subtype has the same size as its subtype. Thus an object of a task 
subtype is always 32 bits long. 


Alignment of a task subtype 
A task subtype is always even byte aligned. 


Address of an object of a task subtype 

Provided its alignment is not constrained by a record representation clause, the address 
of an object of a task subtype is always even, since its subtype is even byte aligned. 


5.7 Array Types 

Size of the objects of an array subtype 

The size of an object of an array subtype is always equal to the size of the subtype of 
the object. 


Alignment of an array subtype 

If no pragma PACK applies to an array subtype and no size specification applies to its 
components, the array subtype is even byte aligned if the subtype of its components is 
even byte aligned. Otherwise it is byte aligned. 


AlsyCOMP Appendix F Version 4.1 


8 





If a pragma PACK applies to an array subtype or if a size specification applies to its 
components (so that there are no gaps), the alignment of the array subtype is as given in 
the following table: 



relative displacement of components 

even nunber 
of bytes 

odd number 
of bytes 

not a whole 
nunber of bytes 

Component 

subtype 

alignment 

even byte 

even byte 

byte 

bit 

byte 

byte 

byte 

bit 

bit 

bit 

bit 

bit 


Address of an object of an array subtype 

Provided its alignment is not constrained by a record representation clause, the address 
of an object of an array subtype is even when its subtype is even byte aligned. 


5.8 Record Types 

Size of an object of a record subtype 

An object of a constrained record subtype has the same size as its subtype. 

An object of an unconstrained record subtype has the same size as its subtype if this size 
is less than or equal to 8 kb. If the size of the subtype is greater than this, the object has 
the size necessary to store its current value; storage space is allocated and released as the 
discriminants of the record change. 


Alignment of a record subtype 

When no record representation clause applies to its base type, a record subtype is even 
byte aligned if it contains a component whose subtype is even byte aligned. Otherwise 
the record subtype is byte aligned. 

When a record representation clause that does not contain an alignment clause applies to 
its base type, a record subtype is even byte aligned if it contains a component whose 
subtype is even byte aligned and whose offset is a multiple of 16 bits. Otherwise the 
record subtype is byte aligned. 

When a record representation clause that contains an alignment clause applies to its base 
type, a record subtype has an alignment that obeys the alignment clause An alignment 
clause can specify that a record type is byte aligned or even byte aligned. 


AlsyCOMP Appendix F Version 4.1 


9 





Address of an object of a record subtype 

Provided its alignment is not constrained by a representation clause, the address of an 
object of a record subtype is even when its subtype is even byte aligned. 


6 ADDRESS CLAUSES 


6.1 Address Clauses for Objects 

An address clause can be used to specify an address for an object as described in RM 
13.5. When such a clause applies to an object no storage is allocated for it in the 
program generated by the compiler. The program accesses the object using the address 
specified in the clause. 

An address clause is not allowed for task objects, nor for unconstrained records whose 
size is greater than 8 kb. 


6.2 Address Clauses for Program Units 

Address clauses for program units are not implemented in the current version of the 
compiler. 

6.3 Address Clauses for Entries 

Address clauses for entries are not implemented in the current version of the compiler. 


6.4 Address Clauses for Constants 

Address clauses for constants are not implemented in the current version of the 
compiler. 


7 UNCHECKED CONVERSIONS 

Unconstrained arrays are not allowed as target types. Unconstrained record types without 
defaulted discriminants are not allowed as target types. Access to unconstrained arrays 
are not allowed as target or source types. 

If the source and the target types are each scalar or access types, the sizes of the objects 
of the source and target types must be equal. 

If a composite type is used either as source type or as target type this restriction on the 
size does not apply. 

If the source and the target types are each of scalar or access type or if they are both of 
composite type, the effect of the function is to return the operand. 


AlsyCOMP Appendix F Version 4.1 


10 



In other cases the effect of unchecked conversion can be considered as a copy: 

■ if an unchecked conversion is achieved of a scalar or access source type to a 
composite target type, the result of the function is a copy of the source 
operand: the result has the size of the source. 

■ if an unchecked conversion is achieved of a composite source type to a scalar 
or access target t>pe, the result of the function is a copy of the source 
operand: the result has the size of the target. 

8 INPUT-OUTPUT CHARACTERISTICS 

In this part of the Appendix the implementation-specific aspects of the input-output 
system are described. 

8.1 introduction 

In Ada, input-output operations (10) are considered to be performed on objects of a 
certain file type rather than being performed directly on external files. An external file 
is anything external to the program that can produce a value to be read or receive a 
value to be written. Values transferred for a given file must be all of one type. 

Generally, in Ada documentation, the term file refers to an object of a certain file type, 
whereas a physical manifestation is known as an external file. An external file is 
characterized by 

■ Its NAME, which is a string defining a legal path name under the current 
version of the operating system. 

■ Its FORM, which gives implementation-dependent information on file 
characteristics. 

Both the NAME and THE FORM appear explicitly as parameters of the Ada CREATE 
and OPEN procedures. Though a file is an object of a certain file type, ultimately the 
object has to correspond to an external file. Both CREATE and OPEN associate a 
NAME of an external file (of a certain FORM) with a program file object. 

Ada IO operations are provided by means of standard packages [14]. 

SEQUENTIAL_IO A generic package for sequential files of a single element 
type. 

DIRECT_IO A generic package for direct (random) access files. 

TEXT_IO A generic package for human readable (text, ASCII) files. 

IO_EXCEPTIONS A package which defines the exceptions needed by the 
above three packages. 


AlsyCOMP Appendix F Version 4.1 


11 








The generic package LOW_LEVEL_IO is not implemented in this version. 

The upper bound for index values in DIRECT_IO and for line, column and page 
numbers in TEXT_I0 is given by 

COUNTS AST - 2**31 -1 

The upper bound for field widths in TEXT_IO is given by 
FIELD’LAST = 255 


8.2 The FORM Parameter 

The FORM parameter of both the CREATE and OPEN procedures in Ada specifies the 
characteristics of the external file involved. 

The CREATE procedure establishes a new external file, of a given NAME and FORM, 
and associates it with a specified program file object. The external file is created (and 
the file object set) with a specified (or default) file mode. If the external file already 
exists, the file will be erased. The exception USE_ERROR is raised if the file mode is 
IN_FILE. 

Example: 

CREATE(F, OUT_FILE, "MY_FILE\ 

FORM -> 

"WORLD «> READ, OWNER -> READ_WRITE"); 

The OPEN procedure associates an existing external file, of a given NAME and FORM, 
with a specified program file object. The procedure also sets the current file mode. If 
there is an inadmissible change of mode, then the Ada exception USE_ERROR is 
raised. 

% 

The FORM parameter is a string, formed from a list of attributes, with attributes 
separated by commas (,). The string is not case sensitive (so that, for example, HERE 
and here are treated alike). (FORM attributes are distinct from Ada attributes.) The 
attributes specify: 

■ File protection 

■ File sharing 

■ File structure 

■ Buffering 

■ Appending 

■ Blocking 

■ Terminal input 


AisyCOMP Appendix F Version 4.1 


12 







The general form of each attribute is a keyword followed by ■> and then a qualifier. 
The arrow and qualifier may sometimes be omitted. The format for an attribute specifier 
is thus either of 


KEYWORD 

KEYWORD QUALIFIER 


AlsyCOMP Appendix F Version 4.1 


13 






