UAH RESEARCH REPORT NO. 752 


LANGUAGES FOR ARTIFICIAL INTELLIGENCE: 
IMPLEMENTING A SCHEDULER 
IN LISP AND IN ADA 


Prepared by: 


Dan Hays 

Psychology Department 
The University of Alabama in Huntsville 
Huntsville, AL 35805 


Prepared for: 

John Wolfsberger 
System Software Branch 
Information and Electronics Systems Lab 
George C. Marshall Space Flight Center 
National Aeronautics and Space Administration 
Marshall Space Flight Center, AL 35812 


October 1988 



LANGUAGES FOR ARTIFICIAL INTELLIGENCE: 
Implementing a Scheduler in LISP and in Ada 

Abstract 


A Drototype scheduler for space experiments originally 

^ of i iqp Lisina some of the more traditions 

EH—" 

'raised ™ sue ™s^uMhe !i^fluence°of programming 

rx?emar.o P C!an'guages themselves such as system embeddedness, 
hardware context, and programmer practice. 


D. Hays, et al 
Johnson Research Center, U. 


. - Languages for Al - Abstract 

Alabama in Huntsville 35899 - October 1988, 


i 



Table of Contents 


PAGE 

1 


I. introduction 

II. The Al Language Problem 
HI Versions of the Scheduler 

A. The Original Version 

B. The Common LISP/Flavors Version 

c. The Ada Version 
IV. Issues and Conclusions 
Appendices 


5 

1 0 
1 0 
1 7 
28 
50 


D Hays -Languages for Al - Johnson Research Center, 

1988, ii 


UAH - October 



LANGUAGES FOR ARTIFICIAL INTELLIGENCE: 
Implementing a Scheduler in LISP and in Ada 


I. Introduction 


This report documents research to explore implementation of an 
artificial intelligence application, a scheduler for space-resident 
activities, in various computer languages. This task is one from a 
larger research effort supported by Grant No. NAG8-641 from NASA s 
Marshall Space Flight Center to the Johnson Research Center at the 
University of Alabama in Huntsville. Donnie Ford is Principal 
Investigator on this grant. John Wolfsberger at Marshall Space 
Flight Center, is the Contract Monitor. Dan Hays is Task Leader for 
the research described in this document and the author of this 
report. 1 The report covers the project year. 

Project Overview. A scheduler for experiments and other 
resource-consuming activities in a Space setting, originally 
developed by Floyd and Ford, was reprogrammed in two computer 
languages. 2 The original was written in ZetaLISP, using classical 
techniques of LISP programming. The other two languages used were 
Common LISP with Flavors, an object oriented language, and Ada. 

The suitability of yet other languages was also examined briefly. 


1 Comments on this report or questions about the research may be addressed 
to Dr. Hays at 135 Morton Hall, The University of Alabama in Huntsville, 
Huntsville, Alabama 35899, or to Dr. Ford at Johnson Research Center, 
Research Institute Building, The University of Alabama in Huntsville, 

Huntsville, Alabama 35899. 

2 An earlier report from this project was delivered as a paper: D. Hays, S. 
Davis, and J. Wolfsberger, “An Object-Oriented Implementation of a Scheduler 
in LISP and in Ada", to the 1988 Conference on Automation for Military and 
Space Activities, Huntsville, AL. 


D. Hays -Languages for A! - Johnson Research Center, UAH - October 1988 - p. 

1 



The scheduler incorporated various features of “artificial 
intelligence” programs, such as extended and variable searches and 
flexible input. Since it had been shown to work with data drawn 
from space missions, it qualified as a practical application of Al 
programming techniques. Thus, the scheduler provided a sense of 
realism that a more schematic or ad hoc program might not be able 

to. 


As it turned out, the reprogramming became much more a matter 
of reconceptualization, in going from one computer language to 
another, than of simple translation (if there is such a thing, even in 
the world of digital devices). In particular, the recasting of the 
scheduler from LISP to Ada provided a number of lessons of 
implementation. 

Research Staff. Persons at UAH specifically involved in the 
investigation reported here have included the following. 

Dan Hays, PhD. Research Scientist at the Johnson Research 
Center, and Associate Professor of Psychology. Dr. Hays served 
as Team Leader for this investigation. 

Stephen W. Davis. Research Associate, Johnson Research 
Center 3 . Mr. Davis was responsible for the programming 
reported, as well as for aspects of the conceptual development. 

Professors Donnie Ford and Stephen Floyd of the Johnson Center 
and the Management Science/Management Information Systems 
Department of the School of Administrative Science, provided an 
essential ingredient of this task by supplying the original scheduling 
program (see below). They also assisted this project by commenting 

3 Now at Advanced Technology Inc., in Huntsville, AL. 


D. Hays -Languages for Al - Johnson Research Center, UAH - October 1988 - p. 

2 


program (see below). They also assisted this project by commenting 
on the structure of their scheduler and their intentions in its design. 
Discussion of various points was also provided by other personnel of 
the Cognitive Systems Laboratory of the Johnson Center. In 
addition, Mr. Davis was able to talk with several programmers in 
other organizations who were familiar with Ada implementations, 

during that part of the project. 

Summary Conclusions. Though the discussion on which they rest 
is contained subsequently in this report, several conclusions from 
this project seem worth calling attention to here. 

1. The difference is considerable between brief "benchmarks 
and programs meant for use in situations. 

2. “Translation” of practical programs will probably not be 
straightforward if you are trying to make a program that works 

well. 

3. “Object-oriented” techniques may offer advantages to 
conceptualizing computations such as those involved in the 
scheduler investigated here. They can also result in 
improvements in performance. 

4. What an “artificial intelligence technique" is, becomes less 
clear after being examined. 

5. Viewed as a case study, the adaptation of the scheduler to 
Ada involved a number of problems that were in a sense external 
to the language itself as an abstract structure. These ranged 
from differences in implementation of memory allocation, to 


D. Hays - Languages 


for Al - Johnson Research Center, UAH - October 1988 - p. 3 


“mundane” but sometimes frustrating problems of program 
editors, hardware, and system features. 

6. Finally, possibly because the project investigated a 
program meant for real use, attention was called to contextual 
factors, including the role of the programmer. 


D. Hays - Languages for A! - Johnson Research Center, UAH - October 1988 - p. 4 



II. The Al Language Problem 


From a machine-centered point of view, the reasons to worry 
about the choice of a programming language would seem to be few: 
whether or not one can symbolize a problem for processing by 
machine, and the efficiency of the resulting machine-level code, 
thus performance of the program. 

But even for fairly standard programming problems, such as 
straightforward numerical computation, or retrieval of specific 
information from fully specified locations in an electronically 
stored corpus, possibility and efficiency are not enough, so that 
individual preference and social factors influence choice of 
computer languages. The relation of the programmer to the language 
used is not just one of simple preference. For example, habitual 
usage is certainly a major source of preference for a language, but it 
also contributes to expertise in using the language.. Some language 
features— and features of the facilities that are associated with a 
language, such as editors, compilers, libraries of code, and so on- 
may make a programming system harder or easier to use, more or 
less prone to some kinds of oversight, easier or problematic when 
other programs must be coordinated, and easier to read or more 
opaque. Such features, which might collectively be called human 
suitability factors, are now much more widely recognized than they 
were in earlier decades. For example, features intended to protect 
writers of programs from certain kinds of errors of reference were 
important in the design of Ada. Other languages have constrained 
unconditional branching commands, a source of problems in many 
programs. Again, to take a simple example, the difficulty that most 
persons have in counting nested parentheses without putting a finger 
or a pencil on them has lead to graphic aids for pairing parentheses 


D. Hays - Languages for A! - Johnson Research Center, UAH - October 1 988 - p. 5 


in LISP editors. 


These five kinds of factors — possibility of expression, efficiency 
of realization, individual preference, human suitability, and social 
motives and constraints — apply to languages in which one may write 
an “artificial intelligence” program, as well as to other 
applications. Each will be discussed to some extent in this report. 

The matter of languages for heuristic or otherwise “smart” 
programs evokes more particular issues at this point in time, 
however. 

The question of which computer language to use for an Al program 
is sometimes confounded in current thinking with the issue of the 
acceptability of Al programs in the first place. Thus, some may 
feel that a program written in a language familiar to their 
applications, such as C or Fortran (depending), lends acceptability to 
a program incorporating heuristic strategies, whereas a program to 
accomplish the same results but written in a language that is not 
well known to them, such as LISP or Prolog, adds unfamiliarity to 
uncertainty. The acceptability of one or another kind of Al 
programming concept is a serious question in some quarters. Lack of 
understanding of what is involved in an Al program of one or another 
sort may underlie reluctance to adopt Al techniques. Understanding 
has not been helped in some instances by broad claims made for Al 
programs by proponents or entrepreneurs. A better defined issue is 
program validation. Many managers have raised questions about 
program reliability. Since even programs which seem to promise 
determinate or simple mathematical results have been known to 
fail, incorporating programs which offer heuristic, or complexly 
reasoned, solutions, seems to overextend program validation 
procedures which are already expensive and error-prone enough, even 


D. Hays - Languages forAl - Johnson Research Center, UAH - October 1 988 - p. 6 


using the apparently simpler programs. If it can be said that, ’’After 
all, this program is written in C,” some reassurance may be felt . 4 

It is probably no accident that many people today are considering 
the incorporation of programs involving Al techniques at the same 
time that they are contemplating much more extensively linked 
software-hardware systems than they have previously had to 
develop. A group might of course consider using isolated expert 
systems in parts of their operations, running on small computers not 
connected to one another; or adding more logical capability to a 
decision-making program running on an isolated mainframe or 
minicomputer. But it frequently seems to be the case that questions 
about informationally interdependent computer systems seem to be 
of concern to the groups that are also worried about how best to 
incorporate heuristic programs. 

We think that this connection is not at all accidental. We 
believe that distributed computing that has to be flexible, and that 
is fairly complex, will probably have to use some of the techniques 
of “intelligent” programs in order to accommodate its own 
complexity. 

That programs might be part of larger systems, or might have to 
run on different hardware at different times or in different 
settings, is a major external motivation for entertaining the idea 
of using of one language rather than another. For these reasons and 
some others, pressure has been spreading, at least in the U. S. and 
Britain, to adopt Ada as a standard computer language, since part of 
its design intention was portability among devices. During the past 
year and even during the past several months, the Ada question has 

4 At least by those who are reassured by the use of C. 


D. Hays - Languages for A! - Johnson Research Center, UAH - October 1 988 - p. 7 



become a real one for many organizations that had previously only 
had incidental opinions on the matter. 

Because of the timeliness of the issue, we chose to examine Ada 
ahead of some other languages that might have been looked at. 

If, as noted above, the use of Al programs is unfamiliar to 
managers and programmers in many settings, it is conversely true 
that persons who have been involved in the development of 
artificial intelligence methods have not often had to have their 
programs work in the operational settings of government and 
business. At this point, limited expert advisory systems do work in 
probably hundreds of settings, but many other heuristic programs 
are still in the laboratory stage, or demonstrate certain techniques 
without incorporating them into rugged, responsive systems. 

The step from demonstration to operation may be a large one, and 
it is related to the language issue in certain ways. To take a simple 
example, if one is using a language whose implementation requires 
that the computer stop now and then for “garbage collection” of 
released storage allocations, what may be a mild nuisance in the 
computer lab can become a faulty interface feature in an operational 
setting . 5 

Other issues relating language choice to operational status of a 
program are likely to be more subtle. For example, even if use of a 
certain language produces more efficient code for a run-time 
system — one thinks of some cases where Al programs originally 
worked out in LISP were redone in carefully optimized C — it may or 
may not be easy to update or correct bugs in these programs in the 

5 Stopping for garbage collection is not a problem with computing machines 
such as the Symbolics which are designed especially to run list-processing 
languages. 


D. Hays - Languages lor A! - Johnson Research Center, UAH - October 1 988 - p. 8 



apparently leaner language. 


These issues, implicated in the choice of languages for Al 
programs, are large and in some cases difficult ones. This 
investigation will not resolve them, but may add to their 
understanding in a selected context. 


D. Hays - Languages lor A! - Johnson Research Center, UAH - October 1 988 - p. 9 



III. Versions of the Scheduler 
A. The Original Version 


The goal of the project was to explore the usefulness of one or 
another computer language in programming a moderately complex 
problem involving some of the organizing techniques of machine 
intelligence applications. To accomplish this, a prototype scheduler 
for space module activities developed by Donnie R. Ford and Stephen 
A. Floyd 6 was chosen for reprogramming . This scheduler had 
several things to recommend it to this project. 

It addressed a problem of practical importance: scheduling 
resource-consuming activities in the constrained setting of an 
orbital Space facility. By extension, it could apply to formally 
similar situations of scheduling. 


The program was large enough to be interesting: it actually did 
something useful. At the same time, it was small enough to be 
manageable for this exercise. (The moderate size and 
complexity did have implications for issues discussed below. 
Briefly, a more complex version would have had the chance to 
be more flexible and more “intelligent" in certain senses; but 
would have involved much more reimplementation time.) 


• The scheduler worked. It had been demonstrated on a number of 
occasions, and was known to be rugged. In particular, it had 
been checked with realistic data from Space missions (see the 
listing in Table 1, taken from of Floyd & Ford, 1986). 


Stephen Floyd and Donnie Ford, "A Knowledge-based Decision Support 
J y . S . tem . f ° r p ay' oad Scheduling", Proceedings of the 1986 Conference on 
Appendix " tS 9enC8 f ° r Space ’ PP- 69 ‘ 78 - T h's paper is reprinted as 


D. Hays - Languages for Al - Johnson Research Center, UAH - October 1 988 - p. 1 o 



• It was written in the same lab we were in, though by different 
persons. Thus, the original developers were close at hand to 
resolve questions about how it was constructed. 

Making comparisons among similar programs is not easy. If any 
changes at all are made, it may be questioned whether the program 
is really the same. Even in the area of limited-scope benchmarks, 
reimplementing essentially the same procedure in another dialect of 
a language, or preparing it to run on another machine, may raise 
questions about the detailed correspondence of parts. If the program 
has any complexity, and the languages, compilers, or machines are at 
variance in any way, then exact correspondence is not possible, not 
for that matter desirable, unless for some reason direct emulation 
at issue. 

In the versions prepared here, we were concerned to maintain the 
major functioning of the original program, so that the various 
versions would do about the same thing, though perhaps not in just 
the same way. Such a task requires that judgements be made. It 
should be clear that different approaches to the reprogramming 
might have been undertaken. An attempt was made, though, to 
preserve the major behavior of the original program. In addition, 
both the original and subsequent programs were structured so as to 
be open to further development. Thus, the coding might have been 
simpler or more optimized if intentions for future development.had 
not been kept in mind. 

The prototype scheduler, in its 1986 version, was dubbed Dypas, 
for Dynamic Payload Scheduler. It was written in ZetaLisp for the 
Symbolics™ computing machine. It was programmed using what 
might be called traditional LISP techniques. Property lists (a kind 


D. Hays - Languages for At - Johnson Research Center, UAH - October 1 988 - p. 1 1 


O, structure available in most traditional LISP implement*, ons) 
were used fairly heavily for information structures and for 
specifying rules and evaluating them. Generation of possible 
solutions involved a fair amount of concatenation of lists, and 
searching over such structures. 

Many varieties of scheduling programs exist, varying m scope of 
constraints, in how they are tailored to likely process mixes m 
reliance on tightly algorithmic as contrasted with diver, - and 
heuristic bases, and so on. This scheduler was designed * r 
tasks and thus emphasized power requirements. Also, t P 

be scheduled were mostly one of a kind, as — to some^ 
kinds of job-shop scheduling where the same kind o as 9 
repeated. Because of the way space experiments are prepared 
more or less self-contained, they did not rely on a variety o 
resources. Various schedule planners for space activities have been 
described. One that appears to be something like this one in genera 
scope is the MAESTRO system 7 . Another is the scheduler o 
Bahrami and his colleagues 8 . 

Floyd and Ford (1986) describe their routine in part as follows: 

During the preparation phase the individual experiment 
information is provided to the system from [a] data base an 
appropriately stored, also the working memoq, is organized a " d 
then prioritized for the scheduling phase. This is accomp i 
using a priority scheme developed from user input. In the 

. . Rritt E |, en A Bailey, and John Gohring, “Power 

Applications-, Proceedings AIM. ^98 PP -space IPower 

^ ,em-. American Chemica, Socielv 

Proceedings, 1986, pp. 1813-1818. 

D. Hays - Languages for Al- Johnson Research Center, UAH - October 1 988 - p. 1 


scheduling phase, the experiments are scheduled under [a] 
heuristic procedure [see next quote] and the schedule is created. 
The schedule itself is part of the knowledge base and is 
represented as frames. As experiments are scheduled, the 
subintervals required by the heuristic procedure are defined by 
start and stop times of the experiments. For each interval the 
power available, crew available and the experiments that are 
currently on-going are determined and stored. This information 
is required for the remaining two phases, namely operation and 
rescheduling (1986, p. 73). 

After setting the schedule, the 1986 Dypas displayed the 
progression of the scheduled tasks, which included both routine 
operations and experiments, using a graphical representation. This 
“operation” phase was not part of the reimplementation of this 
paper, which stops with a somewhat simpler display of information. 
It may be noted that the information presentation of the original 
scheduler, which used familiar Gantt chart formatting, was one of 
its interesting and useful features. 

The “heuristic procedure” referred to above that was central to 
the scheduling was described by Floyd and Ford as follows: 

The inference engine performs only forward chaining. This 
was determined from the structure of the problem. There is an 
abundance of related facts and information at the beginning of the 
problem solving process which in turn accommodates the forward 
chaining process. The conflict resolution problem is solved by 
allowing the first rule that is satisfied to be implemented. This 
necessitates an ordering of the rules. This resolution method 
was chosen because of the short time frame for delivering a 
[prototype] system. This also facilitates the search through the 


D. Hays - Languages for Al - Johnson Research Center, UAH - October 1988 - p. 13 



working memory.” (1986, p. 72) 


They defined a procedure whereby an experiment (or other power- 
consuming task) is “placed on the chart", with its beginning and 
ending points tagging times for the possible start of other 
processes. “By updating as each experiment is scheduled, one can 
maintain for each subinterval of time the information necessary in 
determining the time slot for the next experiment to be scheduled. 
The determination of which experiment is to be scheduled next is 
based on the user predefined priority structure in effect at the time 
of the scheduling or rescheduling procedure.” (1986, p. 72) 

In practice this meant that long tasks, which usually also had 
high priority, were scheduled early in the procedure, based on the 
“first process to be satisfied” arrangement. Then, others were fit 
in, as various priorities might be satisfied without exceeding power 
capabilities. This kind of procedure seems reasonable for the mix of 
tasks that would be present in space work, where frequently the 
long-term uses of resources would be those that were important to 
environmental stability and overall mission success. 


Thus, the scheduler took into account important features of 
space-resident tasks, and proceeded in a fairly direct way to 
obtaining a feasible schedule that satisfied various constraints. 
After system setup, the program calculated a schedule for the tasks 
submitted to it as input databases, then displayed them graphically 
as a Gantt chart on the screen of the Symbolics monitor. 

The version of the scheduler essentially described above was 
demonstrated on a number of occasions, both locally and in agency 
settings, and at the 1986 American Association for Artificial 


D. Hays - Languages 


for Al - Johnson Research Center, UAH - October 1 988 - p. 14 


Intelligence meeting in Philadelphia. 


D. Hays - 


Languages for Al - Johnson 


Research Center. UAH - October 1988 - 


LABORATORY MODULE - SPACE STATION 


DYNAMIC PAYLOAD SCHEDULER 


SUBSYSTEMS: 


POVERPRIORITY 


NAME WATTS 

CLASS 

AGENCY 

DURATION CREW 

ECLSS 

6200 

I 

NASA 

CONTINUOUS W/20 
MIN* LAPSES OKAY 
EVERY 4 HRS. 

0 

COMMUNICATIONS 

1480 

I 

NASA 

CONTINUOUS 

0 

THERMAL CONTROL 

600 

I 

NASA 

CONTINUOUS-REDUCES 
LINEARLY TO 400W FOR 
10 KW POWER LEVELS 

0 

HOUSEKEEPINC(MISC) 6000 
PAYLOAD/EXPERIMENTS I 

I 

NASA 

CONTINUOUS 

1 

DOD/ PAYLOAD l 

890 

II 

DOD 

48 HRS 

1 

ESA PAYLOAD 1 

1845 

II 

ESA 

214 HRS 

l 

IPS 

165 

II 

ESA 

240 HRS 

l 

ELECT DIAC STA 

435 

II 

NASA 

10 MIN OF EVERY HR 

l 

IECM 

480 

III 

NASA 

200 HRS 

0 

CRNE 

930 

IV 

U.K* 

240 HRS 

0 

GEN PURPOSE COMP 

383 

III 

NASA 

CONTINUOUS 1 

(5 MIN/HR) 

SOLID POLYMER ELECT 

415 

IV 

3M 

36 HRS 1-5 MIN* 

EVERY 3 HRS 

IEP 

125 

IV 

NASA 

6 HRS 

0 

MLR 

350 

IV 

U/IOUQ 

20 HRS 

0 

FES-VCCS 

600 

III 

NASA 

15 HRS 

0 

ROT I 

36 

IV 

UAH 

43 HRS 

0 

SEM 

2648 

IV 

NASA 

6 HRS 

0 

RTC 

94 

IV 

NASA 

12 HRS 

0 

TAPE RECORDER l 

85 

II 

NASA 

CONTINUOUS 

0 

TIME CODE GEN 

32 

II 

NASA 

CONTINUOUS 

0 

MASS SPECTROMETER 

215 

IV 

JAPAN 

2 HRS 

0 

TOOL CHARGER 

50 

u 

NASA 

CONTINUOUS 

0 

FILM PROCESSOR 

163 

II 

NASA 

l HR/DAY 

1 

SUPER FURNANCE 

7840 

II 

G.E. 

32 HRS 

0 

SILICON WAFER PROD 

4760 

III 

INTEL 

14 HRS 

0 

TAPE RECORDER 2 

85 

III 

NASA 

CONTINUOUS 

0 

TCA 

612 

IV 

ESA 

8 HRS 

0 

MEA 

1800 

IV 

NASA 

14 HRS 

0 

WELDING EXP 

1610 

IV 

NASA 

4 HRS 

0 

CFES 

890 

III 

NASA 

36 HRS 

0 

3-AAL 

500 

IV 

NASA 

10 HRS 

0 

EML 

420 

IV 

NASA 

2 HRS 

0 

GFFC 

375 

IV 

NASA 

6 HRS 

0 

ADSF 

480 

IV 

NASA 

48 HRS 

l 

ARC 

215 

IV 

NASA 

8 HRS 

0 

SAFE 

400 

III 

NASA 

15 HRS 

1 

SOLAR OBS 

375 

II 

NASA 

ORBIT/DAYTIME ONLY 
FOR 36 ORBITS 

0 

LICHTNINC DET 

125 

IV 

NASA 

ORBIT NIGHTTIME ONLY 
FOR 12 ORBITS 

0 

CRYSTAL GROWTH 

1200 

II 

NASA 

1 HR 

0 

COMET SEARCH 

650 

III 

JAPAN 

ORBIT NIGHTTIME ONLY 
FOR 40 ORBITS 

0 

LIFE SCI 1 

135 

III 

A6M 

36 HRS 

0 

LIFE SCI 2 

1145 

III 

UAB 

22 HRS 

0 

LIFE SCI 3 

842 

III 

UAB 

66 HRS 

0 

CLASSIFIED L 

1300 

II 

DOD 

8 HRS 

0 

CLASSIFIED 2 

645 

II 

DOD 

18 HRS 

0 

MAPPING (WEATHER) 

300 

III 

USWS 

CONTINUOUS (CAN BE 
INTERRUPTED ANYTIME) 

0 

MAPPING (GEO) 

690 

III 

uses 

60 HRS 

0 

ORB ITER DOCKING 

6500 

** 

NASA 

24-72 HRS, WILL BE 
GIVEN 6 HRS NOTICE 

0 

ORB ITER SERVICER 

2400 

* ** 

NASA 

4-10 HRS, WILL BE 
GIVEN 2 HRS NOTICE 

0 


** WILL BE CIVEN TOP PAYLOAD PRIORITY WHEN NEEDED 


Table 1. 

Space-Resident Tasks Used to Check Dypas Scheduling 
Programs (from Floyd and Ford, ] 936 ) 


B. The Common LISP with Flavors Version 


What was taken to be the main functioning of the 1986 Dypas 
scheduler was reprogrammed into object-oriented LISP. The base 
dialect for this reprogramming effort was Common LISP, the 
standard dialect of LISP that has gained wide acceptance over the 
past several years. More important to the language issue than the 
base dialect was the use of the object-oriented programming 
facilities of Flavors, an extension of LISP. As in the case of the 
earlier scheduler, this version was developed for the Symbolics 
computer 9 . The Flavors/Common LISP program was developed 
under Release 7 of the Symbolics operating system. S. Davis was the 
programmer. 

The processes, that is, the activities to be scheduled, were 
treated as major objects in the program. They were generated, 
evaluated, sent messages and in effect queried. The scheduler 
itself, called a “Dypas”, was also treated as an object. 

(In fact, the scheduler objects were constructed to run under a 
multitasking operating system, so that there could be as many as 
four Dypases working in virtual concurrency, communicating via 
several state variables. This fact may help explain some of the 
internal program details, since this version was set up also to 
explore one kind of (quasi) concurrent organization that we are 
interested in looking at for future versions of the scheduler.) 

A list of names of the main methods, the computations to be 
made, actions to be taken, invoked upon receipt of a message by a 
computational obje ct may suggest something of the approach taken. 

9 Variously, Symbolics Model 3640 and 3670 machines were used. 


-p. 17 


D. Hays - Languages for At- Johnson Research Center, UAH - October 1988 



The following methods were defined for dypas-processes: 

- make-instance 

- describe-process (to provide a consistent format for noting 
information about the process’s priority, current status, 
‘geometry’, next neighbors, and so on) 

- remove-process 

- create-node 

- initlz-node 

- collect-time 

The following methods were among those written for scheduler 
(dypas) objects: 

- initlz 

- find-root (a major method; see below) 

- find-children (a major method, also discussed below) 

- find-max-power-in-interval 

- power-at (more particular) 

- graphical representation 

- presentation-print 

- print-power(g) 

- print-name 

- draw-tree (last several for communicating results to user) 

- initlz-hash 

- build-hash (to set information up for quick access) 

The labeling of the methods suggests what the program is mainly 
about, namely, setting up computational entities, manipulating them 
in familiar kinds of structures such as trees, displaying them, and 
so on. 


D. Hays - Languages for A! - Johnson Research Center, UAH - October 1 988 - p. 18 



They also indicate that this program, as an example of object- 
oriented realization, is structured more as what one of us (Hays) 
refers to as "standard computational modularization" or even 
“standard proceduralization” rather than “radical objectification”, 
where the objects are treated in more metaphorical terms. Traces 
of the latter can be found in this program, in references such as 
“schedule-me” and “schedule-us”. 

One of the central methods for a dypas, find-root, is shown as 
Figure 1. Even without a tracing out of all of the details included, it 
may suggest some of the approach taken. The method sorts currently 
schedulable processes to identify those that need to be attached 
first, then sets them in place. 

A lengthier dypas method, find-children, is listed in Figure 2. It 
looks ahead, so to speak, to try out places for subsequently 
scheduled processes. In doing so, it consults information on 
resource needs, priority, and timing. The problematical part of the 
scheduling for this application is handled by find-children. 

These two methods roughly reflect the general strategy of the 
original scheduler of assigning high priority processes first, 
considering constraints of resource usage (mostly power 
requirements), then fitting in activities of less importance to the 
mission, less power drain, and so on. A listing of the Common 
LISP/Flavors version of the scheduler is given in Appendix B. 
Instructions for running it on a Symbolics computer are given in 
Appendix A. 

It is interesting that in the mix of space tasks on which these 
schedulers were tested, the high priority processes tended to be of 


D. Hays - Languages for At - Johnson Research Center, UAH - October 1 988 - p. 19 



long duration and generally required substantial power. Less 
critical processes were frequently shorter and less demanding of 
resources, though there was some variation. These real-world 
correlations are not essential to the performance of either 
scheduler, but it might be noted that in actual scheduling 
applications the processes being worked with might very well have 
particular features such as these. 

Rethinking the Scheduler. Though broadly similar in the way 
scheduling proceeded, the original LISP version and the Common 
LISP/Flavors version differed in various ways, as one might expect. 

The Flavors version of the Dypas scheduler is clearly a recasting 
and not just a translation to another programming system. 

Both versions have in common the input of a record-like 
description of the tasks to be scheduled, though these were formed 
somewhat differently. The original version used property lists. The 
Common LISP version used a somewhat leaner record format. 

“Rules” for weighting the assignment of tasks to time periods, 
given constraints of resource availability, were incorporated into 
the original program as list structures. Neither program as 
developed contained the overhead needed to ask for and immediately 
take in arbitrary new rules, or to modify old ones short of entering 
the appropriate part of the code. (Writing a more or less arbitrary 
rule processor that impacted scheduling computation would have 
involved a much greater programming and debugging effort than 
either project could manage — and was not necessary either to 
illustrate the principles involved, or to obtain programs that 
worked. Indeed, to write such a “shell”would have involved 
somewhat different programming considerations overall.) Even so, 


D. Hays - Languages for Al - Johnson Research Center, UAH - October 1 988 - p. 20 



- VerSi ° n “ u V a l Colo US^lavo, version 

00nCe C'tl" T Earner version into program logic, 
r: the invariant high priority ruies of the original program that 

essentially gave great weigh, to power regui— and 

he seen as for-loops in the central dypas methods of the recast 

■nn Thus the approach of the second program was to em 

, T semantics in the procedural logic, rather than to include 
some of the semantic annroach probably 

i, in LISP structures which were referenced. This approac 

— ■ r: :r:. 

of weighting certain kinds of facto 

" that would meet constraints, was about the same 

hi cheduters Even the original scheduler, though much more 

nt sttloles that could be construed as "rules", seemed to 

opt for computational efficiency in its search-and-fit strategies. 

One might not expect, jus, on the face of it, for an object- 

problem easier, the overhead mvo , 0 be especia „y 

claritv for bookkeeping overload, mis wou.u 
true if the “objects” were generated in the P r0,u ' l0n r6q 
searching and testing the fit of a schedule, or some other 
problematical pattern of the kind likely to be found in 

applications.. 

It turned out that the Flavors version of the scheduler was 
decidedly more efficient than the original ^ 

rrrr: Z Z£Z « - mam record-consu,t*ion and 

. . fTho Hicniav of items in a Gantt 


scheduling part of the program. 


D. Hays 


Languages for Al - Johnson Research Center. 


UAH - October 1988 - p. 


21 



chart was not implemented in the Common LISP version; nor was 
this included in the timing figures.) 

Thus, reliance on “objects" hardly swamped time or space 
resources. It is not clear, on the other hand, that t e use 
oriented facilities speeded up the scheduler since - 

several other reasons that the second scheduler would run 
than the original version. Because of these additional factors, we 
cannot say that the Flavors realization of objects was definite y^a 
factor in speed, but we can at least say that we we 
strong impression, after going through traces of some of the 
computation, that the implementation of objects m the Symbol,^ 
version of Flavors seemed to work fairly leanly so may we 
contributed to the speedier performance. 10 

Other factors 1 1 contributing to the faster performance of the 
Common LISP/Flavors version would probably include. 

- use of efficient hash addressing schemes for the 
records consulted by the program in working with tasks to be 

'^incorporation of high priority factors into program logic; 

- miscellaneous program features. 

Relative to the last point, it should be noted that although both 
versions of the program were intended to work wtth practical da a 
in realistic situations, the second version was written with 
efficiency definitely in mind. 

r ,Tr 9 m ~ between tbe two - 

r““co™ruSe":s ba^ dialect o, the second vers, on. 


0 . Hays ■ Languages tor At - Johnson Research Center. UAH - October 1 988 - p. 


22 


It might be noted also that some classical LISP programming 
techniques may result in time-consuming operation. The use of 
property lists is a conceptual aid, but is not always recommended, 
for this and other reasons. Again, because of search 
implementation, the original scheduler did a very large amount of 
‘cons-ing’ or list concatenation — a familiar kind of behavior of 
traditional LISP programs . 12 

We were concerned with broadening the facility of the Common 
LISP scheduler to handle rules in a more direct fashion. Some time 
was spent in discussing ways to recast the scheduler into yet 
another version that maintained the DYPAS objectification, but that 
allowed rule substitution and more of a rule logic. Davis was able to 
implement a version of the well-known RETE rule-examination 
algorithm. It is given in Appendix C. The rule-based object-oriented 
program variant was still in the design stage by the project’s end, 
however. 

On the subject of rules, and inference patterns that work with 
logical structures, it may be remarked that, although one often 
thinks of “intelligent" programs as being ones which process logic 
statements (e.g., standard advisory expert systems, or theorem- 
proving programs), rule-processing is by no means coextensive with 
the kinds of heuristic, flexible computation we include as examples 
of “machine intelligence”. The case of scheduling of one or another 
sort, where computations of resource usage are important, suggest 
that some mix of propositional processing and numeric computation, 
even numeric modeling, could be useful. Several strategies of 

12 It is often something of an eye-opener for a person who is familiar only 
with algorithmic programming, to monitor a trace of computation which uses 
list-processing techniques. 


D. Hays - Languages for A! - Johnson Research Center, UAH - October 1 988 - p. 23 



construction are possible in engineering this mix. 

Summary: the Common LISP/Flavors Object Version. The original 
scheduler for space-resident tasks, constructed using more 
traditional techniques of list-processing, was redone, using the 
object-oriented facilities of Common LISP with Flavors. Both the 
original and the object version ran on the Symbolics computer. The 
Flavors version incorporated what was taken to be the main thrust 
of design of the original scheduler, including a basically forward- 
chaining logic, search for an acceptable fit of tasks satisfying 
resource requirements, input of records describing the tasks, and so 
on. The Flavors version, however, set up computational “objects", 
and was organized as object-associated"methods” which did the 
main work of computation based on information or messages passed 
to the objects, in the usual object-oriented fashion. This program 
also involved several features, such as hash-addressing of 
representations of the tasks to be scheduled, aimed at enhancing 
efficiency. The result was a program that did about the same thing 
as the original but was much speedier. 


UAH - October 1 988 - p. 


D. Hays - Languages for Al - Johnson Research Center, 


24 


(def method (Find-root dypas) 0 
(loop with processes-sorted - 
(map 'list Tear 

(sort (loop for object in PRESENTATIONS 

collect (dypas-process-other object)) 

#'> :key #'cdr)) 

with available-power - *tnaximutn- wattage* 
with pane - (get-pane 'messages) 

for object in processes-sorted MAIN LOOP 

for runpower = (dypas-process-max-power object) 

when (>=■ available-power runpower) 
do (setf available-power (- available-power runpower)) 
and do (push object ROOT) 

and do (push object SCHEDULED) 

and do (build-hash SELF runpower 0 

(dypas-process-runtime object)) 
and do (create-node object T 'Ignore) 
and do (setf (dypas-process-begin object) 0) 

and do (setf (dypas-process-end object) 

(dypas-process-runtime object)) 
and do (newpush (dypas-process-runtime object) START-TIMES) 
and do (setf (dypas-process-condition object) 'scheduled) 
and do (let ((pro (dypas-process-name object))) 

(dw : with-output-as-presentat ion ( : stream pane 

:type 'dypas-process 
: object pro) 

(format pane S scheduled with ~D left.~%" 
pro available-power))))) 


Figure 1. 

The find_root method from the scheduler, 
Common LISP/Flavors version. 



(defmethod (Find-children dypas) (&key (stream ‘standard-output*) 

(verbose nii^ 


(let ((clock-begin (get-universal-tine)) 

(schedule-us (insp list csr 

(sort (loop for object in PRESENTATIONS 

when (not (nenber object ROOT)) 
collect (dypas-process-other object)) 

#'> :key #'cdr)))) 

(loop for schedule-me in schedule-us MAIN LOOP 
do (if verbose 

(format stream bScheduling S^ 

(dypas-process-name schedule-ne) ) ) 

(let* ((those-scheduled (map 'list rear 

(sort (loop for object in SCHEDULED 
collect (cons object 

(collect-time object))) 




1 IX' 


(fresh- line stream) 

(loop for process-before in those-scheduled SUB Lwr 
do 

(if verbose 

(format stream Behind “S" 

(dypas-process-name process-before) ) ) 

(let* ((begin-time (collect-time process-before)) 

(required-power (dypas-process-nax-power schedule-me)) 
(available-power (- *maxinun-wattage* 

( find-maxinun-power- in- i nterval 

CKf.F schedule-ne begin-time)))) 


(if verbose 

(format stream "~ 7 .Available-Power - “D~ 

~7. Required-Power - ~D~ 

~7. Begin-Tine - ~D" 
Available-Power Required-Power Begin-Tine)) 


Figure 2. 

The find_children method 
(begins) 



(cond ((>- available-power required- power) 

(setf (dypas-process-begin schedule-me) begin-time) 

(setf (dvpas-process-end schedule-ne) 

(+ begin-time (dypas-process-runtime schedule-me))) 
(create-node schedule-me process-before 'ignore) 
(build-hash SELF required-power begin-time 
(+ begin-time 

(dypas-process-runtime schedule-me) 

(push schedule-me SCHEDULED) 

(newpush begin-time START-TIMES) ctart-TIMES) 

(newpush (dypas-process-end schedule-me) START TIME 
(setf (dypas-process-condition schedule-me) 

'scheduled) 

(return 
(if verbose 

(presentation-print ‘program* 

(dypas-process-name schedule-ne) stream))) 

(verbose (format stream "~7. Look-beyond S 

(dypas-process-name process-before) ))>>))) 

(format stream "~i~XScheduling took ~\\tine-interval\\- 

(time-difference (get-universal-time) clock-begm) ) ) 

(let* ((sum-usage-area (loop for object in PRESENTATIONS 
1 summing <* (dypas-process-max-power object 

(dypas-process-runtime object) ) ) ) 

(lonaest- runtime (eval '(max ,@START-TIMES))) * 

U sum-usaqe-area (* longest- runtime ‘maximum-wattage 


(format stream "“^Longest process runtime “Wtine-mterval 
longest-runtime) 

(format stream TPower to time ratio “2.5F" validation) 


Figure 2. 

The find children method 
(cont * d) 


C. The Ada Version 


The Flavors version of the scheduler was chosen for 
implementation using Ada, the language and programming system of 
the U. S. Department of Defense. 

This came at a time, early 1988, when many groups in work 
organizations were very much concerned with questions of adopting 
Ada for some of their own programming activities. At the time, the 
drive to adopt Ada, or at least to evaluate it for adoption, had 
extended well beyond those groups who were writing programs 
directly for Department of Defense projects. 

Given a choice of programming languages to explore for an Al 
problem, Ada was most interesting to us, and it seemed probably 
most interesting in general, for several reasons. 

One reason was, of course, timeliness. The push to use Ada, or to 
say why you weren’t going to, was underway. 

It seemed also especially important to include in the evaluation 
of Ada some of the programming techniques of machine intelligence. 
When the design of Ada was worked out, several years earlier, Al 
programs were probably not so much considered in its design 13 
Since that time, a few people in the field have been concerned with 
just this issue. Some of their work has been reported in the annual 

13 This is a conjecture. Among the many persons who were concerned with 
Ada in its stage of design and initial negotiation, some must have been aware 
of the sorts of requirements of programs that were heavy on search and 
dynamically generated, evanescent structures. But since Al applications were 
much more in exploratory stages at that earlier time, it seems unlikely that 
they would have been considered in the same arena as control programs, 
database programs, and other more standard applications. 


D. Hays - Languages for A! - Johnson Research Center, UAH - October 1988 - p. 28 


Al and Ada conferences (or AIDA, to use the more memorable 
abbreviation) which were held the past two years. But in the 
mainstream of developmental work in artificial intelligence, judging 
from the publications and major conferences of the American 
Association for Artificial Intelligence, Ada has not been a language 
that has been used, and the question of its adoption was not one that 
people who were primarily concerned with the development of Al 
methodology were concerned with. This would be quite proper, since 
implementation details operate at a somewhat different level than 
problems of program logic or concept . 14 Since Ada was rapidly 
being adopted, it seemed especially important to see how well it 
suited the needs of Al programming. There was even a note of 
urgency. A programming system not specifically designed for 
heuristic programming gave indications of being adopted, largely 
because of external pressures 15 . At the time, Al programs were 
just gaining a foothold in many organizations, but the foothold was 
tenuous in some cases. If Ada turned out to be widely adopted, but 
unsuitable for the kinds of procedures useful to machine intelligence 
applications, their benefits could not be realized. 

Even if the adoption of Ada had not been an externally important 
issue, Ada would have been interesting to explore. It is a very rich 
programming system. And, it differs considerably from list- 
processing languages. 

Ada and LISP: a Note on their Locale. LISP is today a highly 
evolved family of programming languages, with direct lineage to the 
language formulated by John McCarthy over two decades ago. Ada, as 

14 Tha issues are not entirely separate, since a programming system can 
both set constraints on the realization of techniques and also make it easier to 
use certain kinds. 

15 Which might be merited in the main. The overall suitability of Ada was a 
larger question than we were prepared to address. 


D. Hays - Languages for Al - Johnson Research Center, UAH - October 1 988 - p. 29 



a living language, so to speak, is in its early stages 16 . As an 
evolutionary product, most of its variation and selection has been on 
the conceptual level, though there are indications of evolutionary 
variation in its implementations over the past couple of years. 
Conceptually, Ada might be said to have drawn on the forms of 
previously existing computer languages, especially those which 
carefully controlled the definitions of variables and the transfer and 
binding of information. With its concern for portability and 
communication among routines, and its intentions of comprehensive 
usefulness (the evolutionary equivalent of territorial dominance, one 
is tempted to theorize), Ada seems to emerge as something of a 
super-species, or at least as a candidate for such an ecological 
position. By contrast, LISP dialects, despite a certain level of 
general capability, if not a certain aggrandizement of form and 
posture over the past decade, have remained ecologically fairly 
specialized. They are very much “niche” languages, though the size 
of the niches has increased lately with the rapid growth of interest 
in artificial intelligence and other symbolic processing. 1 7 

Ada and LISP: some Language Features. The details of each 
language are voluminous. There are some immediately contrastive 
features, though. 

Figure 3 lists instructions for a simple kind of computation, first 
in generic LISP, then in Ada. The Ada code is realized as an Ada 
function; the LISP code is a LISP function. Each version assumes 
that certain terms have been defined and given values, and that 
niceties to insure program acceptance have been observed. 


16 Persons who have been involved in the lengthy history of formulating, 
revising, and supervising early implementations of Ada might disagree. 

17 There are signs that the expanded arena of supercomputing with tightly 
interconnected processors will be another somewhat specialized niche for LISP 
variants. 


D. Hays - Languages for At- Johnson Research Center, UAH - October 1988 - p. 30 


Both examples use recursion. 


Perhaps the most obvious difference between the two is that the 
LISP version looks like LISP, and the Ada version looks something 
like Pascal or various other languages that trace certain amounts of 
their syntax and notation to Algol. Neither are exactly “natural" 
ways to tell a computer to do something — no one talks like this — but 
each can be figured out. At a superficial level, the LISP function 
seems replete with parentheses. We are left wondering, in each 
case, about how recursion and other features are handled during 
actual computation. 

Apart from these impressions, a more substantial difference in 
the languages is indicated by this example, that is, the emphasis on 
control of keywords and variables in Ada. There are reserved terms 
in LISP, even if they are not conventionally given in boldface, but it 
is a much more easily extensible language. Ada is more the cousin 
of Pascal or Modula-2 in being “strongly typed”, that is in specifying 
or carefully restricting the definition of kinds and conventions of 
elementary data units. Interestingly, in the treatment of typing, 
numbers receive more attention than other conceivable data units, 
belying the traditional, math-procedural concerns of these 
languages. Along with the typing, Ada constrains very carefully, if 
not severely, what can be passed as information to a routine. Some 
of the limitations of reference and binding are likely to be 
experienced as frustrations by persons used to programming in list- 
processing languages. They are used to handling problems that arise 
in working with the dynamically generated structures of symbolic 
computation by layering or nesting references to whatever 
structures may have come about. Such references are a bit tighter 
in Ada, but also probably less prone to unexpected errors. 


D. Hays - Languages for A! - Johnson Research Center, UAH - October 1988 - p. 31 



Figure 4 shows Ada code for pushing an item onto a stack and 
popping it up. This kind of action is familiar in many kinds of 
programming, including assembly language routines. Pushing down 
and popping up are frequently used list-processing operations. 

In this example, the two stack-manipulation operations are 
contained in an Ada “package” along with some definitional 
material. The package concept is not limited to Ada, but is one of 
its distinctive facilities. In a package, one can gather together, or 
“wrap”, related computational entities such as constants, types, or 
procedures. The package is a convenient place to place the code. It 
can be found there if it needs to be revised or expanded. A subtler, 
related benefit is that within the package, referencing is simpler, so 
that less overhead of cross-referencing is involved in using the 
items wrapped within. 

This push/pop package works on data items of type "integer". 
Some kind of floating point numeric representation, or character 
representations, would need additional code. However, Ada does 
allow terms for such operations to be “loaded” so that they could be 
applicable to more than one type, assuming that the proper code 
were available and had been suitably referenced within the system. 

Davis chose to program the integer push/pop routines as taking 
place in a vector array. An alternative, rather more bulky approach 
would have been to try to reimplement LISP-like data units in Ada. 
The latter course would have provided needless overhead for most 
situations. However, using the built-in array addressing of Ada (or 
Pascal, or Modula-2, or whatever) does mean that the array must be 
large enough to hold the data items that will be needed, and not so 
large that too much memory relative will be taken relative to other 


D. Hays - Languages for Al - Johnson Research Center, UAH - October 1988 - p. 32 


needs of the program. 


This choice brings up another matter involved in doing list- 
processing in languages that provide handier facilities for other 
kinds of operations or memory allocation. Frequently, it is the best 
course of action to adapt facilities of the language one is working 
with, rather than to try to rewrite or comprehensively simulate the 
source language in the target language. Choices of just how to use 
the facilities of the resident language may have to be made after 
surveying just what is needed to program the problem at hand. 

Finally, in connection with Figure 4, note the code, here 
unamplified, to raise error conditions when an attempt is made to 
exceed stack depth or to pop an item from an empty stack. Though it 
is not apparent from the example, Ada’s error handling facilities are 
generally thought to be very convenient in comparison to those of 
other contemporary languages. 

The extensive features of Ada are discussed in a number of 
publications. Sources that we have found especially accessible are 
the texts by G. Booch; various works written by N. Gehani; and I. 
Sommerville’s book on Software Engineering with Ada, to name just 
a few. Though some of the material was written fairly early in the 
short life history of Ada, comments in various articles contained in 
Comparing and Assessing Programming Languages: Ada, C, Pascal, 
edited by A. Feuer and N. Gehani (Prentice-Hall, 1984), are clear and 
still relevant. 

So far as discussions of LISP, the features of the language are 
described clearly for programmers in a number of textbooks, often 
containing “Al” in the title (texts by Winston, Brooks, Anderson et 


D. Hays - Languages for Al- Johnson Research Center, UAH - October 1988 - p. 33 



al., and Tanimoto com© to mind). More technical discussions of 
strategies of implementation, and issues of how variables are 
accessed and transferred are contained in comments in G. Steele’s 
basic reference on Common LISP, and in Abelson and Sussman's 
Structure and Interpretation of Computer Programs. 

Direct comparisons of LISP, or other list-processing languages, 
with Ada, or for that matter other languages such as Pascal or 
Modula-2, are not so easy to come by, though the discussions in the 
last AIDA conferences are relevant. 

Another example of Ada code for a list-processing job is given in 
Figure 5. The two parts of Figure 5 show how the LISP function, 
maplist, could be implemented in Ada. This example is taken from 
Gehani’s 1983 book on advanced programming in Ada. 18 

Maplist applies an operation (function) to each of the members 
of a list that is specified. This is the kind of thing that one 
frequently needs to do in symbolic programming. It is convenient 
not to have to specify anything about the list, such as its number of 
members, or the kind of members that are in the list. 

The Ada code is presented for a “generic” routine, one that has 
meaning in broad contexts. Gehani only sketches the actual Ada 
program for this function. In practice a number of details would 
have to be taken care of. Note that the definitional part of the 
routine is much lengthier than the “action code or function body. A 
suggestion is given of some of the matters that would have to be 
accounted for to handle the kinds of lists (sequentially linked, with 
expandable items, etc.) that are the basis of LISP data structures. 


18 Also from Prentice-Hall. 


D. Hays - Languages for A! - Johnson Research Center, UAH - October 1988 - p. 34 


When working with a dialect of LISP, what one takes as basic 
functions such as maplist or other “map” variants, or ones to 
traverse lists and match items, pair items, reverse lists, and so on, 
come to be relied on and thought of as simple operations, though 
their actual coding may be non-trivial and in some cases may be 
fairly subtle. This is true of the list manipulating part of Prolog 
dialects. 

When faced with handling list processing in languages with 
Algol-like statement syntax and different kinds of management of 
information items, the usefulness of such functions becomes felt 
very definitely. One impulse is to reimplement them, necessarily 
together with a basic list representation, in the new language. 
Another approach is to implement just some of the more important 
ones. In either case, some accommodation will have been made to 
the facilities of the target language. Yet another approach is to try 
to rethink the problem as one whose solution has to take place in the 
second language, without reference to the way it would have been 
solved in a list processing programming system. If the target 
language is one in which it is difficult to do some things, such as 
run-time storage allocation and deallocation, problems at the 
conceptual level may result. 

Recasting the Scheduler into Ada. It would have been a much 
tougher job to reprogram the Ford-Floyd Dypas scheduler more or 
less directly into Ada, than to work with the Davis Common 
LISP/Flavors version. 

The original scheduler relied heavily on traditional LISP 
programming techniques and facilities. Though it is not unorderly in 
overall structure, it looks much less modular than the Flavors 
version, and at least to a programmer unfamiliar with its underlying 


D. Hays - Languages for A! - Johnson Research Center, UAH - October 1 988 - p. 35 


conceptualization, would seem to be far from the intense 
modularization demanded by Ada programming. 

Thus, the fairly “procedularized” recasting, using certain of the 
object oriented facilities of Flavors, lent itself to translation into 
Ada, at least at the level of major program modularization. It was 
not difficult to sketch a fairly direct correspondence between the 
methods defined for the Flavors objects, and Ada procedures or 
generic functions. 

It did appear, though, that problems might be encountered in 
storage allocation overhead, and possibly also in straining bounds of 
readily available memory. These are matters where language 
facility and system convention and coordination interact, so that 
knowledge just of Ada language specifications could not tell us 
exactly what would come about in doing large-scale searches in a 
program implemented for various systems running Ada. 1 ** 

Figure 6 shows Ada code for setting up the major objects of the 
conceptualization of the scheduler used in the Flavors version. The 
Dypas_process was taken as the main object. (Treating individual 
schedulers as objects, as in the Flavors version, was not considered 
to be a good idea here. Instead, in a possible version that would use 
concurrent processing we would intend it to be handled more 
directly by the concurrent facilities built into Ada.) 

Figure 7 lists the central procedure, FIND_CHILDREN, in Ada. In 
comparison with the LISP/Flavors version, shown in Figure 2, the 
Ada version is leaner. Its logic is revealed almost skeletally. The 

19 It is interesting that relative to a programming system and language that 
is meant to be machine independent to a large extent, we so quickly 
encountered a system problem in our planning. 


D. Hays - Languages for A! - Johnson Research Center, UAH - October 1988 - p. 36 



work of computation is mostly handled by calls to routines. Some 
of the routines are unique to the scheduler, such as SCHEDULE_ME. 
Others reflect more basic functions such as CREATE_NODE or PUSH. 

The modularization and readability of Ada is seen very nicely 
here. By comparison, the parallel Common LISP procedure, even in 
the organizing context of some kind of object-oriented structuring, 
seems to have more little details to take care of. 

Not visible in this central procedure are the complexities of 
specification and reference of the related declarations and routines. 

About Ada Objects. Ada is sometimes referred to as a language 
that is based on computational “objects”. Booch, for example, in 
both editions of his text, emphasizes the importance of Ada objects. 

This terminology may be confusing to someone not familiar with 
the exact facilities of the language, since the term “object-oriented 
programming" or “object-oriented programming system" (OOPS, for 
short) is probably more frequently used today to refer to facilities 
such as those in Smalltalk-80^®, or Flavors extensions for LISP, 
and several more recent languages. 

The usage is closer to the terminology of “first-class objects" or 
“second-class objects” in discussions of symbolic programming 
languages, which have to do with matters of reference within a 
program. 


Both Ada objects and OOPS objects involve “information-hiding", 
as do the procedures of Modula-2 and other languages when internal 

20 The language and programming system developed by Xerox Palo Alto 
Research Center, and now available for various machines. 


D. Hays - Languages for A! - Johnson Research Center, UAH - October 1 988 - p. 37 


terminology is not meaningful outside of procedural boundaries. 

The inheritance of properties by instantiated objects is not easy 
to manage in Ada, though it is a common and useful feature of 
languages such as Smalltalk. The Generic definition facilities for 
Types in Ada do not allow such referencing. Thus, hierarchies of 
objects are not possible (unless simulated somehow), much less 
multiple inheritance, where an object can draw characteristics from 

more than one branch. 

For this reason, translation from Flavors into Ada may run into 
constraints fairly quickly, if many features of object-oriented 
programming were included in the original. 

Problems of Implementation. In redoing the Flavors version of 
the scheduler using Ada, we had two kinds of problems. The first 
were basically matters of language differences, such as different 
ways of handling objects. The second, actually more serious 
difficulties were experienced in areas peripheral to the language 
itself. Of these, systems-related problems were very important. 
These often interacted with what might be termed mundane 
problems of working with specific language systems and hardware. 

Some of these problems may have been unique to this particular 
project, though we suspect that the sorts of problems that we 
encountered were not. 

Our situation in starting to work with the Ada scheduler may also 
have been not exactly unique. The person doing the bulk of the 
programming was not experienced in using Ada for any kind of 
application. He had a sort of textbook familiarity with it, and 
shared programmer lore, but had not programmed anything more than 

O. Hays - Languages lor At- Johnson Research Center, UAH*Oclober1988-p. 38 


a few exercises using the language. However, he would qualify both 
as “an experienced programmer” and as “an experienced Al 
programmer”. Besides LISP dialects, he had programmed in Pascal 
and in C, so was familiar with the sorts of syntax and referencing in 
those languages. Besides these, he was familiar with several Al 
programming “shells”. In other words, he was both experienced in 
programming, and used to some variety of programming systems . 21 

Thus, the experience of recasting the scheduler into Ada could be 
taken as a kind of case study in language adoption. 


Relative to learning to use Ada as a language the following 
comments can be made from this particular case. 

• Textbook material was easily available, and generally clear, 
though some of the more available and better known texts talked 
about the language somewhat more than getting down to 
examples that were worked out in thorough detail . 22 Such a 
level of discussion was not a particular problem for someone 
experienced in programming and knowledgeable about computer 
systems, but might be puzzling to persons less experienced. (The 
level of discussion may have been a function of the relative 
novelty of the language, and possibly also was traceable to the 
scarce availability of validated compilers for Ada at the time 
some of the textbooks were written. Since that time, we have 
noticed somewhat more detailed and less discursive material 

available.) 

. We expected Ada not to be so restricted in its referencing as 
it was. Possibly because the problem being worked with needed 
somewhat flexible referencing, we found that it was easy to 

21 By contrast, other accomplished programmers specialize in just one 
language. 

22 It will not surprise persons used to such material that some of the 
examples in the texts did not work. 


D. Hays - Languages for Al - Johnson Research Center, UAH - October 1 988 - p. 39 


assume that such was available. ... 

. As the conventions of the language became more fami , 
the value of Ada's modularity for clear communication and 
structuring of program logic was very pleasant to discover. 

. The facilities of the language for error handling were goo 

to have in an explicit form. 

. Though primarily used in planning developments of the Ada 
version, the facilities for concurrency seemed adequate. 

. Generally, relative to ease of learning, Ada had extensive 
facilities, each replete with particular conventions and 
restrictions, so the information load was fairly heavy. 

So far as learning Ada, features of the language itself were not 
nearly so important as the computational facilities associated w, 
one or another implementation of the language. Ironically, Ada is a 
language whose realization in compiler form has been a matter 
explicit early discussion and subsequent attention by t e 
Department of Defense, its genitor. Compilers mus be validate^ , 

check that the numerous specifications are me . 
concern for validation is the well-known insistence on multiple- 
machine usage. When taken together with the care in cross 
referencing routines and information items, and 

internal consistency that is also part of the language design a large 
amount of compilation time seems to be taken up with checking 
code for such matters. Thus, to compile even short procedures 
frequently involved substantial turn-around. 

Turnaround time is turnaround time, and can be adjusted ta When 
taken together with sparse documentation and diagnostics, though, 

L° ause fle o. .ha compilers had no, been well luned. 


D. Hays 


Languages for A! - Johnson Research Center, 


UAH - October 1988 - p. 


40 


the delays for compilation seemed especially frustrating. In some 
cases, no information was given regarding the reasons for an 
unsuccessful compilation, and a search of the documentation did not 

readily provide clues. We were left wondering 

- if the cause of the problem were an error or faulty 

assumption in the program (likely), 

- if so, what the error or inconsistency was, 

- if in fact the problem might have resulted from not doing 
what the editor or compilation front-end expected rather than 
being a language error (more likely that we would have thought at 

the outset), 

- if the problem were in the procedure itself or in the linkage 
checking, 

- if we had run into a compiler flaw (not as likely as we 
thought at times, but with some of the earlier versions of 
compilers which we worked with, a possibility that could not be 

dismissed). 

Problems with compilers, editors, linkage checkers, and so on 
were encountered both with the Symbolics (which in general has a 
superior user interface and system facilities) and with IBM Personal 
Computers and their clones (which are not known for either). Ada on 
the Symbolics would of course be written on top of the basic list- 
processing structure of the machine and its system software. We 
felt that this made it not the ideal machine to benchmark Ada on 
because of this indirectness of implementation. Even so, because of 
the Symbolics’ system facilities, we had thought that its Ada would 
be easier to use. The main problem that we had with it (which may 
also have been to some extent a function of our place on the learning 
curve) was inadequate diagnostics. We are curious, however, as to 
the future of an Ada implementation on this machine, since the 
Symbolics systems software has already developed smooth-running 


D. Hays - Languages 


for At - Johnson Research Center, UAH - October 1 988 - p. 41 


multi-tasking, and has a number of other excellent software and 
interface features to recommend it. 

Generally speaking, Vaxes are not as convenient to use in 
preparing and editing programs (though they have been steps ahead 
of other minicomputers and various mainframes). We certainly had 
no quarrel with Vax Ada itself, which must be something of a 
landmark. Unfortunately, because of mundane reasons, such as 
chronic hardware problems on one machine, and uneven access then 
memory inadequacy on the other Vax, for much of the time we were 
unable to use one of these machines. 

Thus, our early plan of developing the Ada version both for the 
Symbolics and for the Vax was frustrated, given the time for this 

part of the project. 

Even though there was no chance of programming the complete 
scheduler for a PC, some time was spent in working with smaller 
routines using two kinds of Ada on IBM and similar personal 
computers. Both of the Adas were in -early” versions**. Both were 
fairly frustrating to use. (We have since used a revised version of 
one of the PC Adas, and do not believe we would have had the same 

problems with it.) 

Status of the Implementation. The complete scheduler had not 
been implemented into fully functioning Ada by the close of the 
project period. We felt that we had learned a considerable amount, 
but also felt a sense of frustration that so many “peripheral” 
matters, such as hardware access, capability of editing software, 
and especially Ada-related system software (either compilers or 

24 A relative term. It appeared that an "early- version ol an Ada 
implementation was one that did not work very well. 


D. Hays - Languages for Al - Johnson 


Research Center, UAH - October 1988 - p. 42 


closely related system 


features), had been sources of problems. 


These are some interim conclusions regarding the Ada 
programming experience that we felt could be offered at the end of 

the project period: 

• Ada is a large and capable language, 

. partly because of language complexity, and partly because of 
system and compiler problems, using Ada for a reasonably complex 

program involved various frustrations and delays. 

• It seems to take somewhat longer to implement and Integra e a 
program of moderate complexity than would be the case with a 
language of more traditional scope of integration. 

• Ada routines are easy to read, in general. 

. The transition to using Ada confidently, when other languages 
have been used, may take longer and use more resources than one 

^^Tral^ting Al applications such as this scheduler into Ada are 

easier if they are “proceduralized . 

. We remained suspicious of the ability of computer systems 

operating with Ada as their language/programming systems to 
efficiently use memory in the voluminous and dynamic ways a 
often seem necessary for Al problems. 


D. Hays - 


Languages for Al- Johnson Research Center, UAH - October 1988 - p. 



the collect-time function in LISP 


(defun collect-time (process) 

(if (eq T (process -before process)) ; if this is true 
(process-runtime process) ; then do this 

(+ (process -runtime process) ; else do this 
(collect-time (process-before process))))) 


the collect time function in Ada (recursive version) 

function COLLECT_TIME(P: in out PROCESS) is 

begin 

if T = PROCESS . BEFORE 

then return PROCESS.RUNTIME; 
elseif return PROCESS.RUNTIME + 

COLLECT_TIME(PROCESS. BEFORE) ; 

end COLLECT TIME; 


Figure 3 . 

Illustration of a function programmed in generic 
LISP, and in Ada. 




IA 

s? 

w 

a 

w 



(A 

£ 

a 

i 



w 
o 9 

gs 

Mh 3 

« C3 

42 V 


Figure 4. 

Ada Package for Push and Pop Operations (Implemented 
for an Array of Integers) 


MAPLIST 


PO 

oo 

(T> 


~ 3 
> u 

z ®- 

a 


Cfl 


CO 


5 W 

M h-J 

« J W 


* ' ' *o 
*s « 

^ T 3 

W c 
J 2 

W g 

3 oo 

= .5 

i <u 

a > X ) 
C 

— V C 

5 - 

^ c j 

W c 
J <2 

w 

- u 

s xs 


• « r /5 

W •- 

P.2 

- X 

§*- 

o 1 

3 

3 


u 

<u 

s 

0) 

M 


a> <u 

& Q. 

>> >> 


e 

o 

00 Cd 

3 X 

E c 

C CO 

w 

GO 

c 


H 

oo 


c 

J <0 .2 
u f o 
a 


r? o 


e 

3 


O « O 

x : x x : 

t3 a> w 


&o 


**■< E 
o o - 
o .5 
co ■a 

a> a) c 

3 -C 4) 

i— H M W 

3 X 

> C « 

• T— * 

u, 

O <U O 

« 4-4 

X 

CO 3 ^ 

Odd 
*S > 50 

2 w S 
§•■2 1 


A 

V 

c « 

• mm 

£ 

w 

j 

w 

3 

3 •— I 

•W 

a> w 

U GO 

j* 

J 

<4-4 

e o 


j’ 5 

a § 

< a ? 
W 

Dh CO 


A 

V 

Cfi 

S i* 

m /\ 

j v 

w 

^ CO 

3 — 

•" H 
* 2 


H 


hJ 

X 

00 

3 

CO 

3 

M 

u 

dJ 

hJ 

3 


E 


a> 

0) 

<u 

3 

O 

lm 

E 

3 

f—H 

(U 


H 

oo 

CO 

<U 

■m 

CO 

. # 


X 


j 

hj 

+-* 


P 

3 

CO 

<D 

X 

oo 

< 

1 

• • 
j 

3 

X 

CO 


Q 

Q 

< 


d - .s 
< .2 £ 

H " . . 

<u 


g 

or 

re 

c C 

3 

s £ 

3 cd 

*> -a 

> d^ >, 

.2 : 
'M 

5J 

# o 

CJ 

O 1 
Q 

O ^ ^ 

3 

c 

3 

X cu X 

3 

3 

3 

£ §■ “ 
S p 


X 

X 

X 

<u o 




£ d .£ 
H X) 53 

Z 

• iHf 



3 

-O 

I 


A 

V 

V 

2 

< 

W 

J 

O 

O :* 

« A 

= V 

fa 50 

— * 

d 

P 3 

£ c 
j u 

c 5 

— 3J w 
l - co 


J 

H 

cl 

S 


c 

# o 

CJ 

c 

3 


W 

< 

W 

C * 


W 5 J 


3 

O 


>% 

E 

£ 

aj 

c 

a 


H 

co 

J 

s 

u 

3 

a 

u 


H 

co 

J 

3 


J 

H 

CO 

N— H 

h 4 

0- 

< 


.o 

■M 

CJ 

3 


a 

o 


4-1 


f 0 

< 


4J 

CO 


CG 


U 

0 

4-1 

0 

X? 

o 

o 

Mh 

o 


■J1 


o 

u 

a 


u* 


function MAPLIST(L: in LIST) return LIST is 


T3 

C 

c3 

GO 

Wh 

<D 

OJ 


O 

w 

GO 




T3 

c3 

e 

C3 

C/3 

C 


C/3 

• ?“4 

>s 
*— < 

a. 

£ 

D 

<U 

x: 


< 

Q 
< 
_ W 

E 

PU 


o 

o 


lii'S 
H > 

< H 

w C 


00 

W 

Pi 


C*S P H o 

5 ^ 00 J 

u w < d 

h 2 q 1h 

..rf c 5 J'. 

T’r'l 


H 

J 

P / - 

• *> C/3 E“* 
o. m c/3 

§ s ~ 


II 


W 

Pi 


£ 


■o 

s 

<u 


B 
u 

3 ^ 

<U 


J 

Ph 

< 


4> 

u 


-a 

c 

<u 


<u 

X) 

>> 

ctf 

s 

H 

00 

J 

P* 

< 

£ 

c 

o 

O 

c 

3 


co 

3 

w 

Pi 

< 

p 

O' 

oo 


W c 
C o 
<o *s 
C o 

<U c 

toO 3 

<*- 

<U 

H 3 


\ 

W 

Pi 

< 

P 

o 

oo 

Pi 

W 

a 

w 

H 

Z 


H 

oo 


Cfl 

• um 

H 

oo 


l 

Pi 

W 

a 

w 

H 

z 


Pi 

w _ 
O H 
W oo 
H ^ 

5 s: 

i < 
w *5 
Pi t 

P a> 

P S 

O 

00 

B 

o 


0> 

s 

3 


Figure 5 (contd) - Sketch of Code for LISP Maplist in Ada (from Gehani, ]983) 



declaring access type DYPAS_PROCESS 
tvpe PROCESS; 


o 

o 


u 

v 

F—l 

<D 

13 

c q 


V 

to 

<V 


4 


on 

on 

W 

U 

o 

OS 

o- 

Vi 

Vi 

a> 

o 

(« 

on 

C /2 

W 

u 

o 

on 

< 

Oh 

> 

Q 

<u 

o. 

>» 


cn 

on 

on 

W 

u 

o 

od 

Oh 

a. 


ft! ft 

w S 
O o 
g w 
b h 
S z 

>— 1 h-h 
•: . . 
os z 

m ft 

> a 
n w 
2 « 


O ft < < 

£££& 

Z 00 Q Q 


oq 8 

jgl 

0-, &«, 




Q 

Z 

PJ 


T 3 X 

u < 

SS 

u 


2 

2o 

H U- 
55 W 
Q cQ 

z 

o 

u 


e 

£ 

< 


0) 


-a 

B 

a> 


CO 

£ 

o 


C/5 

co 


CO 

o 

S' 

O 

<u 

JS 


W) 

c 

u< 

o 

<u 

-o 

c 

<u 

•B 


s 

B 


a> 

CO 

CO 

w 

O 


<u 

co 

Q 

Z 

W 


CO 


a »*, 

.32, c /2 

■S < 


Q -g 
Z ~ 

w 8 

u- 

00 O 

S ^ 

o S 

C 2 

o 
0) 

o 


£ 

H 


cn 

u 

a 

> 

fO 

TS 

< 

c 


cn 

o 

CO 

CQ 


2 

°*i 

CQ 

< 

P- 

>< 

G 


G 

C 

ra 


AJ 

4 J 

a 

CQ 


a> 

Vh 

D 



procedure FIND_CHILDREN is 
CLOCK.BEGIN: INTEGER; 

SCHEDULE.ME, PROCESS_BEFORE: DYPAS.PROCESS; 

-The global variables SCHEDULED and SCHEDULERS 
-are declare in DYPAS package specification. 


PP 


PP 

S 

5 

< 

CO 

U 

PP 

> 

i 

Z 

D 

i 

ta 

o 

o 

cd 

s 

p 


o 

pp 


Q. 

O 

O 


CO 

D 

I 

pp 

Q 

cd 

ac 

u 

CO 

s 

cd 

S 

i 


<D 

C 


£ 

<u 

c 


UP 

§K 

a x 


s 

u 

co 


UP 

H 


03 

1 

ft o 

o ^ 

CU 


o 

CJ 

1 — 1 

1 

s 

C O 

1 


Mg 

<U w 

< 

ffl l 

JD 

S 

00 


§■£ 

IS 



OC 


i'll 

!S^ 


I ( 1 ] Oh [ 

•j w s < >j B p 


Q 

PP 


|g§P i |2 l 




PP 

DOC'S 

W UJ ^ p 

“|i£ 

^1 
- pc 33 
DD 

CQ Cu d. 



Cl 

d;o 
o o 

Sz 1 

1 5 

g< 

cu a 
o © 

— — 

•o -a 
c c 
<y a 


a 

< 


u, 


pd 


fd 

L) 

pJ 


a 


&< 


z 

CD 

OC 

O 

J 

55 

u 

i 

Q 

Z 

E 

"O 

c 

o 



IV. Issues and Conclusions 


What was Learned. Probably the most interesting finding to 
emerge from the various attempts to recast the original LISP 
scheduler into other programming contexts, was the efficiency and 
speed of the object-oriented version. The improvement in 
performance was substantial, and though it seemed to result from 
several factors (program organization, speedy addressing schemes, 
and so on), the programs were comparable in some important ways. 
Apart from the difficulties of comparing any two complex programs, 
the original scheduler and the Flavors version ran on the same 
computing machine, and both were within the LISP programming 
milieu. Thus, questions of recasting list-processing programs to an 
essentially non-list-processing environment, as in the later 
exploration of Ada, were irrelevant here. 

The improvement in performance was especially interesting since 
object-oriented techniques are commonly offered as aids to clearer 
and more communicable conceptualization of a problem, but are not 
usually suggested as leading to markedly improved efficiency. We 
found here that at least in this case, the “objectification” at the 
very least did not detract from performance and may well have 
contributed to the improvement. 

In relation to the above, we also learned more clearly the relation 
between ordinary object-oriented techniques, which in the 
literature are often discussed as just radical cases of “information 
hiding” in procedures, and the tradition of very modular procedural 
organization of programs — which of course is a strong cultural 

feature found in the design of Ada 25 . 

25 And other current languages in that tradition such as Pascal, Modula-2, 
and others. 


D. Hays - Languages 


for A! - Johnson Research Center, UAH - October 1988 - p. 50 



It should be noted, though, that very tight modularization is not 
necessarily a programming ideal for Al programs, especially when 
it implies, as it often does, extensive constraints on symbolic 
reference, ability to pass on information among procedures, and 
kinds of data structures that are convenient to use within a 
particular system. We ran into these constraints almost 
immediately in setting up the recasting of the scheduler into Ada, in 
the restrictions on generic types. (We think we would have had even 
more problems with a more narrowly conceived language such as 
Modula-2, despite its conceptual neatness.) 

This is not to say that we have anything against clarity of 
organization of programs 2 ®. Both clarity and effectiveness can 
come from other organizational principles, and other 
language/system bases. For example, the kind of organization into 
inference routines and modifiable knowledge corpora that has 
emerged in some machine intelligence work, is relatively clear and 
certainly useful, but is different in approach from what would be 
recommended by the dogmas of the Wirth school of thought. 

Intelligence in Machines. A curious phenomenon of work in Al is 
the disappearance of intelligence when a process is examined 
closely, or comes to be understood. 27 The case of now you see it, 
now you don’t ‘intelligence’ in the routines was something that we 
experienced in regard to each of the programs that we worked with. 


26 Regretably often taken to be the sole property of “structured" 
algorithmic languages such as Pascal. 

27 Though this has often been pointed out for the case of machines, it also 
seems to apply at times when human intelligence is carefully scrutinized, and 
what seems to have been whim or wisdom seems to be more determined by 
simple causes than not. 


D. Hays - Languages for Al - Johnson Research Center, UAH - October 1988 - p. 51 


What seemed to be more significant was the embeddedness of 
intelligence into the routines. Even in the original scheduler, much 
is arranged and specified rather than left for inference. The Flavors 
version of the scheduler in some ways went a little farther in 
incorporating actual heuristics about the situation of scheduling 
space tasks into code. 

What this implies is that the critical issue is not whether a 
program is intelligent because it does some reasoning or not, or is 
smarter or less smart in an absolute situational sense, but the 
modifiability of the program to meet new situations together with 
the situational adequately of response. This makes the matter of 
program “smartness” much more a matter of both interface and 
external connectedness to a world of events and meanings, than 
necessary features of internal procedure. So flexibility and 
aptness become important more than particular formal features 
that may have been seized upon as indicators of program virtue. 

The now you see it phenomenon also is related to issues of 
programming language features and capabilities. Assume for the 
moment that only one computer arrangement was being used. 

Various high level languages, in which programmers would express 
what needs to be done to solve real problems through computation, 
must be transformed into machine instructions. The machine will do 
what it can do. But, it turns out that it is much easier to do some 
things using some higher-level languages. It is virtually impossible 
to do some things with some languages. For example, it used to be 
next to impossible to do any substantial amount of list processing 
with Fortran, and it is still difficult to do so without special 
routines in more specific languages. 

So the reality of the programming language, with its domain of 


D. Hays - Languages for A! - Johnson Research Center, UAH - October 1988 - p. 52 



meanings and operational possibilities, is very real indeed. 

If machines are different from one another in certain ways, the 
discussion becomes more complex. For example, in this project the 
difference between the underlying structure of the Symbolics, whic 
has special hardware facilities to help list-processing addressing 
and even some higher order operations, is different enough from the 
underlying structure of a Vax, or a PC, that one would want to 
examine not just language differences when exploring how programs 
should best be written for these systems. 

From the point of view of the humans who use the computers, 
either the possibilities and constraints of the software, or the 
possibilities and constraints of the hardware, could be the source of 
easy problem solution, or of frustration in trying to solve a 
computational problem. In this project, for example, the major 
problem was what software would allow or facilitate. It turned out 
that even on the same machine, it was relatively easy to solve 
certain problems with some software, and a real challenge to do so 
with another programming language, even one that is advertised as 

being diverse and capable. 

Possible Future Investigation. Further exploration of Ada would 

seem to be of considerable interest. Both the more limited approach 
to the scheduling problem, and ones that were only mentioned in 
passing here, such as multitasking versions, would be interesting to 

gain more experience with. 

Of languages that are in concept more limited than Ada, Modula-2 
and C seem especially interesting. C is widely used and has a good 
reputation for implementing efficient programming solutions. 
Modula-2 is becoming increasingly appreciated by people who write 


D. Hays - Languages for Al - Johnson 


Research Center, UAH - October 1 988 - p. 53 


serious software, including applications .or machine control and 
coordination. Both have certain restrictions of conceptualization, 

'^Because of the results for the object-oriented version, it might 
also be worthwhile to pursue that kind of techmque ,n future 

^addition, various projects have been underway to provide either 
somewhat general list-processing facilities, or more 
"expert system" systems written in some of the more class, ca y 
structured languages. These could be evaluated using problems such 

as this scheduler. 

Summary. A realistic application involving the concepts and 
certain programming techniques of artificial intelligence^ was 
examined in several versions. The original, in classic , 
contrasted with an object-oriented version. Work on a recasting 
into Ada, at base a differently structured language, involved a 
number of both practical and conceptual problems. 


D. Hays - Languages for Al - Johnson 


Research Center. UAH - October 1 988 - p. 54 


APPENDICES 


Appendix 

A. Instructions for Common LISP/Flavors DYPAS Scheduler 

B. Common LISP/Flavors Scheduler: Listing 

C. Rule-Search (RETE) Algorithm Adaptation 

D. Routines from Ada Version of the Scheduler 

E Floyd and Ford’s Description of their Scheduler 


D. Hays et al. -Languages for At- Johnson Research Center, UAH - October 1988 


Appendix A. 

Instructions for Common LISP/Flavors DYPAS Scheduler 


These are the instructions supplied by 
S. Davis for running the Common LISP/Flavors 
Version of the Scheduler 
on the Symbolics computing machine. 


D. Hays et al. -Languages forAI- Johnson Research Center, UAH - October 1988 


To Set Up the Common LISP/Flavors Version of DYPAS - 


- » , as s ~ - 


Edit File SYS .-SITE; DYPAS. TRANSLATIONS 
and typing the form 


( f s : set-logical-pathname-host "DYPAS" 

•translations ' ( ("** ">dypas>**>" ) ) ) 

and save this f ila ^then °|o ^ack to ^heTistener^* 1 ' N °"' evaluate 
the cSVffi 

To load DYPAS into working memory do? 

Load System DYPAS 
then type <SELECT>-Square. 


A-l 



Running DYPAS is equally simple. Six of the eight commands 
displayed are mouse sensitive. The two that are not are Describe 
Process and Remove Process. They are available from the Keyboard. 
Describe Process is also available by mousing on a process name 
after selecting Show Schedule. The top four commands should be 
selected in sequence initially, and then used logically 
afterwards. A short introduction of these commands follow. 


INITIALIZE sets-up program definitions and clears the Frame 
Base. It is always correct to select this command first. 
Initialize prepares DYPAS working memory for new processes. 

PROCESSES allows the user to individually select the 
processes he wants to schedule. When selected it brings up other 
windows that can be logically followed. 

scHFntiT.F begins the scheduling process, but does it in the 
background. You can then actively Describe Processes, Create 
Processes or Show Schedule to give a dynamic view of what is being 
scheduled. 

SHOW schfdht.k does its best description after the scheduling 
is done. You can Describe Processes by mousing on the tree 
structure for any process name that is sensitive. 


Try removing a few processes after scheduling and then select 
Schedule again. See what kind of schedule differences exist. When 
you want to begin again select Initialize and start fresh. 


NOTE: To allow DYPAS to run quickly, keep the mouse pointer out of 
the Message window. Some of the processes are mouse sensitive and 
it will slow down the scheduling when mouse and process conflict. 


A- 2 



Appendix B. 

Common LISP/Flavors Scheduler: Listing 


Hays et al. -Languages for A!- Johnson Research Center, UAH - October 1988 



Syntax: Common-lisp; Package: USER; Base: 10; Mode: LISP; Default-character-style: (:FIX : ROMAN : LARGE ) 


i 

* 



r- 

A 


m 

co 


CM 

CO 


VO 

w 


1 

o 


m 

o 


as 

Pi 


00 

Cu 


m 

CO 


o 

< 


CM 

04 



>H 


u 

Q 


<13 



P 

9 


G 

0 


03 

C 


U 

<g 



4 J 

CO 

jC 

a 


O 

A 

> 

U 

H 

03 

m 

1 

a 

<13 

<9 


CO 

M 

• 

03 

JS 

3 

£* 

s 




G 

G 


0 ) 

O 

TJ 

.C 

co 

0 

a 

C 

x: 

(V 

sz 

p 

p 

0 

a) 

co 

•p 

H 



>1 





p 





p 





0 





<33 

• 




P 

g 



*0 


03 



CD 

Xi 

M 



<0 


CT 



3 

•a 

O 




0) 

u 


* 

<0 

P 

a 


£ 

H 

p 



<3 


03 

p 


P 

P 

0 

0 

>: 

O' 

OS 


a) 


0 

-G 

P 

P 


p 

P 

03 

P 

<13 

a 


> 

0 

6 

* 

S 

03 

0 

as 


to 

c 


G 

<0 



c 


1 

G 


O 


<0 

■H 


CO 

0 


•H 


P 



CO 

•H 

a 

P 



> 


03 

4J 


G 


03 

tJ 


0 

as 


P 

^•0. 

0 

as 


0 

p 

CO 

G 

A 

G 

03 


^ P 

G 

03 

03 

H * 

co 

P 


>5 a 

03 

O' 

CO 

CO W 

P 

rH 


1 * i 

CO 

rfl 

03 

co S 

to 

03 


CO 

03 

CO 

P 

03 3 

G 



m as 

P 

CO 

a 

0 2 

P 

CO 


v a 

a 

0) 

i 

0 

1 

-H 


g >i 

i 

€ 

CO 

P : 

0) 



e -o 

CO 


m 

a < 


CO 

P 

as ^ 

as 


i 

t i 


<0 

CO 

r-H 

a 

0) 

P Ci 

3 CO S 

5 

03 

■H 


> 

G 

P 2 



0 

rH 

* 

"0 

03 

a * 

2 a h 






— H 


p 



y 



«n, 



p 






0 ) 


xz 



y 

■K 

CO 


O' 

2 



e 

o 


•H 




fO 



03 

P 


2 

p 

P 



0 



O' 

03 



0 ) 


z 

0 

> 


4 „ 

-n 


• 

p 




jQ 


CO 

a 




0 


CO 

■« 

>i 



«• 


0 ) 


03 




P 

0 

00 



A 

CO 


o 

G 




CO 

CO 

p 

— 0 



cc 

0 ) 

p 

04 

-K -r-l 

a) 


pj 

0 

0 


S P 

c 

* 

3 

0 

-H 

A3 

fTj <0 

03 

£ 

O 

p 

P 


P P 

a 

03 

04 

a 

03 

CO 

O' G 


U 

1 

C 3 

4H 

n3 

0 03 


cn 

X 

0 co 

C 


P co 


0 


-H 

-H 

T5 

a oj 

co 

p 

3 

P Ci 

1 

0 ) 

* p 

CO 

a 


fTj > 

03 

V 

a 

0 ) 

* 

y 

P T3 

> 

TJ 

CO 1 

0 


2 

G v 

-*H 

<0 

G CO 

0 


a 2 p 2 

i o 3 
P H O P 
<3J E-* I O 

tr> < *c a) 

^ Eh p T"i 
2 *H .0 
e W 5 O 
(Q CO *• •• 


U 2 > 1 -H 
3 TJ c 
OP* 

I O P 
-C 0 ) 0 ) 03 
4J o a e 
•H A > p 
5 O 4J O 
P 


~ P + 
Pm C ~ 
i-3 a) 

W CO Pm 
CO (1) i-4 
P U 
* a co 


O P 3 P 

o w a 4 J 


« ^ >i 

co nj V 

0 ) jj — 

o a 

0 CU 4-1 

P CO H 

a a) o) 

1 P co 

p a 

O 1 <33 


o) pa 

5 ~ 

w OJ 

93 

►0 

2 

G 

p 2 

n 

rH 

CT 3 

pa 

H 


P 04 

' 

•H 

•H 

w 

o 


CO 

■ — 4 H 


'* 

* 

x: 

4 H 

T) 

P 


P 

p 

CO 

p 

C 

a) 


0 ) 

0 ) 

3 

03 

0 

P co 


CO 

CO 

a 

co 

0 

a) 

rH 


W 

W 





i i i 

01 P o"P df> 

lilt 
Q CO Q Q 

i i i i 


P P 3 0 ) 

■H O O £ 
m o) a-H 



P 

CO • 

. 4 J 

o 

CO 

> 

0 

0 

G 

1 

p 

a> 

3 


CO 

p 

ns 

O 

0 

**H 

O 

>: 

G 

G 

0 

g 


«k 

a 

g 

M 

P 

a 

rfl 

3 

•H 

1 

aj 

P 


> 

03 

04 

04 

CO 

s 

as 

rH 

X 

03 

<n 

y 

T3 

P 

l 

ch o 




1 

p 

P 

6 

5 

— ' 

— - 

9 

? 




J3 

-H 

P 

P 




A 





(0 


CO 

0 

2 

P 


*H 





0 ) 

•• 

• • 

P 


P 


P 

r 




p 

3 

' — 


cr 

03 


0 





4H 

T3 



03 

CO 


Q 






“W* 



' ' 



(9 

a) 











Q 

c 





B-l 


PRIORITY SPONSOR MAX-POWER RUNTIME) 


CO 

D 

O 

D 

£ 

H 

Eh 

z 

o 

o 


l 

CO 

© 

i 

O 

c 


to 

3 

o 

3 

G 

■H 

P 

C 

o 

CJ 

* 


a» 

c 

03 

a 

P 

OJ 

g 

P 

O 

P 


* 

(*> 

* 

* 

CO 


© 

g 

03 

p 

Cu 

a> 

g 

-H 


i * 

g¥» o*° 
f i 

T? < : 

CO CO oV> oV3 
< * i ? 

— — co co 

i i t i 


c 

o 

•H 

p a) 

■H Jh 
TJ O 
G 4-i 


P Eh 
© co 
p 


£ 

O 


Q H — 
£ -H — >* 
O C 4J 
CJ 

w w 
co os os 
D O O 
Eh Du Du 
W U 
OQ (!) 


<t cr 



Eh CO 

O CQ < 2 

w 


o ffi 




i 

2 

P 


= 

Du 

0 



1 



© 

u 


© 

C 

2 

P 

CO 

03 

H 

■H 

o 

a 

Eh 


XI 




p 

p 



© 

03 



> 

g 




p 



G 

0 



© 

p 



X5 

— 




w 

a 

o 

Du 

w 


p 

o 

© 

■n 

X> 

0 

a) 

g 

03 

G 

1 

CO 

CO 

a) 


cq oS o 

w o 

© Eh 
Cu 
< 


dl J TJ 
0 0 — 

0 a) 

P -n 4J 

a xj o 

1 o © 

CO P 
03 P H 

a. o o 

>1 4-1 o 

X) 

— a 
o 
o 


<#» oV° 

l l 


03 03 
> > 
p p 
© © 


© © 
g g 

*H -H 
P P 


P 

03 

p 
CO © 

c 

•H co 
cn tj 

© G 

ra w 


© 

c 

03 

a 

p 

© 

g 

p 

o 

4-1 


CO P 

© cn 


a * c 


CO CO 

03 c 

a o 

>i H 

V P 
oi 
P 
C 
© 


g 

~ o 

^ p 
^ 4-1 
CO 

© V 
© O' © 
> 


<0 
w 

® . 

0 co 


CO 03 
© CO 
P CO 

a © 

I g 

CO 
03 

a © 

>t G ov 5 
V 03 l 

a <-» 

i * 


0 
g 
© 
p 

CO 

1 



04 

a Du 

P 

• 

p 

t 

i 

p 

© 


£ 

9 

00 

w 

cn 

6 

w 

> 

03 

co 


© 


0 

a 



© 

£ 

i 


© 

g 

u 

H 


*0 

> 


p 

O 

a 


0 

© 

CO 

DO 

— 


g 

p 


OQ 


p 

© 

p 

p 


T3 

p 

Jh 

CO 

© 


0 

© 





-C 

CO 


' — 



P 

— 



0 


© 



p 

p 


g 



© 

•W 


P 






© 



— 



— © 
p © 
© p 

p p 
p 

03 © 


I 

CO P 
CO 

© © 

O CO 

O P 


P 

a 


© 


0 


z 

P P 


o 

G 


cffi 

0 


p 

cn 

* 

t 

P P 


© 

p 

g 

© 

© G 


X) 


© 

CO 

J3 © 


1 

p 

u 

© 

1 ^ 

, 

CO 

CO 

cn 

CQ 

w 

CO 

CO 

© 

0 


© o 

CO 

© 

M 

p 

© 

© *5 

© 

0 

>-a 

a 

g 

0 

0 

0 


* 

© 

0 P 

0 

P 

M 


u 

P 0 

p 

a 

g 

CO 

Du 

a 

a 



3 

0 


§ 

*§ 


co 
co 
© 
o 

0 
p 
a *0 

1 © 
CO P 
03 P 

a os 

>i o 

a 

© 
-Q 


P 

© _ 
p p 
p o 

03 P 
I © 
V) £ 


p 


~ c 


V 

o 

-c 

p 

© 

g 

p 

© 

T3 


X P ^ 


CO 
© 

U 
0 
P 

a 

. i 
Cn co 
•H 03 

co a h 

>1 03 
T3 > 
— © 
Eh — ’ 

Cn 
U X 

os w 
O co 


w 

OS 

o 

Du 
JC W 
co CQ 
3 

a p 

3 P 
© © 
c co 


© 

p 

o 

a 

cn 


p 

© 

p 

p 

03 

I 

03 

CO 

© 

U 

O 

p 

a 

cn 

© - 


© p p 
g © © 
P co CO 
© — — 
*o 


B-2 


(setf (dypas -process -before process-after) SELF) 
(newpush (eval process-after) AFTER) ) ) 


(defmethod (Collect-time dypas -process ) () 

(if (eq T BEFORE) 

RUNTIME 

(+ RUNTIME (collect-time BEFORE) ) ) ) 


X X 

X 

X 


X 


X 

» 

X 

CO 

X 

73 

* 

0 

X 

jC 

X 

X 

X 

CD 

X 

£ 

X 


-X 

Ml 

-X 

0 

-X 

> 

■X 

ft 

•X 

' — t 

* 

4M 

X 


X 

V 

X 

CD 

X 

G 

X 

•H 

X 

4-1 

X 

0) 

X 

73 

X 


X 

M 

X 

u 

X 

0 

X 

3 

X 

OJ 

X 

£ 

X 

ra 

X 

Ml 

X 

Cm 

X 


X 


X X 

X 


v 

o 

0) 

■n 

X 

o 


ft i— I 
' H 
G 

01 E-» 
O 
O 

w X 


a 

id 

x 

D 

Q 

W 

X 

O 

CO 


X 

OJ 

CO 


£ 

ft 

c 

I 

CO 

CO 

0) 

V U 


C 

P 

0 

X 

G 

3 

m 


£ 2. 
g - 
o 

-H 4-1 

X 0 

m o 
o *H 
o — 


X 


4-4 


4-1 



U 

X 

CO 

4-1 


X 




0 

X 

ft 

OJ 


a) 

o 


0) 

X 

a 

CO 


CO 

— 


TO 

X 

>1 


u 




jQ 

X 

73 


X 

CO 



0 

X 



CQ 

co 

CO 



X 

N 

— . . 

< 

OJ 

CJ 


Mi 

X 

H 

+ 

Eh 

o 

2 


0 

X 

X 

— 

1 

0 

M 


4-1 

X 

■H 


X 

Ml 

Eh 



X 

c 


CO 

a 

l 


a 

X 

H 

w 

< 

1 

Eh 


0 

X 

■ 

H 

X 

4-J 

X 

1 — 1 

0 

X 


< 


0 

< 

rH 

f—i 

X 

73 

Eh 

XI 

0 

Eh 

ft 

— 

X 

0 

CO 

CO 

Ml 

CO 



X 

2 


ft 

1 




X 

x 

4-1 

X 

0) 

4-1 

73 


X 

01 

X 

Ml 

M 

4-1 

C 


X 

£ 

CD 

r—i 

ft 

OJ 

0 



4-4 

CO 

0 

2 

CO 

0 



CD 





— ' 



Eh 
< ~ 
Eh - 
2 

U «H 
CO <TJ 
> 
01 
CM 

C G 
H Cn 
O 

Ml 


§ 


■H 

c 

CO 

2 

o 

H 

Eh 

< 

Eh 

2 

CxJ 

CO 

U 

PC 

04 

4-1 

X 

0) 

CO 


73 ' 0 


H Eh 

o u 


D D ~ 


*0 

C 

0) 


cn 

CD 

XI 

Cn 

rO 

£ 


co 

at w 

>1 C Eh 


73 OJ 


*0 

I 

X 

cn w 
c — 

H r 
Ml 
X 
to 

I 

£ 

0 

Mi 
4-1 

1 

73 


a £h 

a co 

ft 


<t 4H 
0) — 
Ml 


p 

PQ U 

^ Eh 


73 
O 
jG 
X 
0) 

£ 

4M 
CD — ' 
73 


73 

G 

ai 

c 

*H 

cn 

<D 

X 

01 

ft 

£ 


H G 

I 

N X 


a 

w 

Eh 

w 

XI 

PM 

2 

O 

u 


I— | 

H *H 
■H G 
G • 

— X 
X O 
0 <D 
d) r~i 
-n J3 

X o 


— CO 
co 2 
aj O 

a H 

>1 Eh 

73 < 


•H 
H G 
•H 

G — 
4J 
O 
CD 
•n 
X 
O 


X 4-1 
4-1 CD 
ft X) 
I I 
CO CO 
CO CO 
CD 01 
O O 


a a 

i i 
CO CO 
ft It 

a a 

>i >i 

73 73 


X 

o 

0) 

*o 

X 

0 

73 

G 

0) 

1 

CO 

CO 

a) 

o 

0 

Ml 

a 

1 

co 

ft 


X 

o 

0) 

■n 

X 

o 

G 

o 


cn 
a v 
X 

i 

co 

CO 
CD 
O 

0 

Ml 

a 

1 

CO 
ft 

a a 

>i >i 

73 73 


X 

G 

O 

0 

1 

co 

CO 

o> 

o 

0 
u 
a 

1 

co 

ft 

a 

73 


4-1 4-4 4-1 4-1 4-1 

X X X X X 

0> CJ CD CL) CL) 

CO CO CO CO CO 


Ml 

too 

O M t 


X 

X 

a) 

£ 


CD w 
73 


B-3 



— It 
XJ 

— 0) 
cn o 
OJ P 

a o 

> cn 

-0 


P 

O 

a) 

•n 

X 

O 

P 

to a) 
z x 

O P 

0 

1 

cn 
cn 
0) 

O 
O 
p 

bd a 

fa t 
cn 

G <0 
*H Q 4 
>1 

P *0 ■ 

o w 
0) 

•n p 

X O 
O 0) 

rH 
P rH 
O O 
CM O 


< 

H 

Z 

u 

CO 

fa 


0) 

O' 

al 

P 

p 

03 

3 

I 

6 

G 

g 

-H 


m e 

T3 * 

0 


03 cn 
<33 
g 


cn 
a) 
cn 
cn 
0 
o 

o h 

p H 

a - 

fa 

~ x a 

p 03 

•o -h e 

0 3'“' 
X 

p a 
0) o 
6 o 

CM -H 

at w 
XJ 


m a 
m o 
o o 


p P 
cn P 
•h O 
H CO 


<33 

P G 
>1 a) 03 
<d 3 a 

0 1 

Q« P 

1 03 
A <13 O' 


*■ X 

03 


It 


fa 

O 

O 

X 


XJ 

03 

P 

P 

0 
cn 

1 

cn 

a) 

co 

cn 

0) 

O 

o 

P 

a 


^ c 


•H <33 
03 C 
> 03 
ol Q* 

J G X 
4-) 4J 
■H *H 
3 3 


P 

O 

<13 

•0 

X 

O 

p 

o 


p 

0 

a) 

■n 

X 

O 

P 

03 

3 

0 

a 

1 

* 

03 

g 

1 

cn 

cn 

<U 

o 

0 
u 
a 

1 

cn 

03 

a 

> 

XJ 


M 

03 

3 

O 

a 

G 

g 

M 

P 

o 


M 

0) 

3 

O 

a 
c 
G 
U 

p 

0) 

3 
o 
a 
\ 

03 

rH 

X 
03 
1 — I 
•H 
^ 03 
M > 

0) 03 

3 

O » 

a ~ 

G 

3 M 
M 03 
3 

p 2 
o> a 
? t P 

0 o) 0 

Qi H 

1 XI 

0) 03 


CO 

^ XJ 
H 03 
Eh *H 
I G 
H *0 
fa 03 

< -c 

H 0 
CO cn 




p 

0 

p 

^ ^ cn 
P P •• 

p 

0 — 

a) 

00 ^ 

0 

p 

TH 

03 03 

<13 

r-. O 

X 

m n 

TH 

p a> 

0 

X X G 

X 

O — *n 


OOO 

0 

03 P X 

03 

•H 


cn 

cn 

03 

O 

0 
P 

a 

1 

03 cn 
G 03 
01 a 
a > 

T3 

£ - 
nl 

03 a) 
p a 
> 
p 


O -H 


X --J 

n3 03 

rH > 

•H 03 


03 

> 

ol 


P 

03 

— 3 

a o 
w a 

►4 G 
P =3 
— G H 

H W 

O X fa 
O O X 
fa cn fa 
CO 
p 

, O X 
a) a) cn 
-rn *n 03 
XXX 
O O 1 
TJ 

X X H 

cn cn -h 
G G G 

a a x 


03 a> 

6 8 
P G 
G Cn 
G H 
P - 


O O 
X 03 
O -n 0) 
X 6 


1 

cn 
cn 

o> P 

0 o 

0 03 
P T*l 

a x 

1 0 

cn 

03 0) 

a x> 

> O 
V G 
I 


c o 

-H 

O' T3 
0) G 
X 03 
Eh I I 


0) 

0 

0 

p 

a 

1 

cn 


P 
03 
At cn 


c o 

<33 TJ 

X 

3 


OOO 
X) *0 T3 

TJ X? "0 
C C C 
03 03 03 


cn <n cn 
cn cn cn 
0) 03 

0 o 

0 o 

p p 

a a 

1 1 
„ cn cn 
01 m os 
a a a 
> > > 

. v v tj 

03 w w ~ 
p 

03 P P 
P 03 03 
O co cn 


■H O 
P H 
G P 
G -H 
P *0 
I G 
cn O 
cn O 
03 I 
0 cn 

0 cn 

P 03 ■ 

a 0 cn 

1 O 03 
« P _ 
03 a > 

a i v 

>1 cn ^ 
-o 03 
^ a o 
>1 p 
x x> a 
cn w w 
G 

a 'm 
3 p p 

0) 03 03 
C 51 H 


6 A* 
03 p 
C G 
t 03 
cn cn 
cn 0) 
0) P 

0 a 

0 1 
p cn 

a 03 

1 I 

p 

_ G 

a a 

p 

G 

0 

1 

X 
p 
•H 

3 

3 

T3 


OOO 
G G G 


OOO 
T> TJ T> 


V V V V V V 

G G G S S S 

aj (T3 03 03 03 03 


O 0 Y 3 
P 3 

a * 

P 

P 
P 0) 

0 H 
03 

■m Q 
X i 
o 

•• X 
p ~ 


v — 

03 P 
rH 03 
G 3 
T3 O 

03 a 

X 1 

0 a) 

cn rH 
X 
c n 01 

1 rH 

<-8 *P 
3 03 

= > 

03 

0) 

G O 
nj P 

a a 

p 

03 

g 

p 

o 


p 

G 

a 

p 

G 

0 

1 

V = 

p 

03 -— ■> >i 

V > P 

G rH P 
03 H 0) 
P G P 
cn Oh 

■K 0) 

cn 0) 

e o x 
5 x 
0) p o 

P 03 P 
P > 

co — 

— ' G 


>1 

0) 

X 


cn 

03 

a 

>1 

X) 

a 

<9 

p 

XJ 

rH 

•»H 

X 

0 

l 

X) 

G 

•H 

fa 


X) 

O 

X 

p 

03 

g 

MH 

03 

XJ 


O 

O' 

P 

O 

G 


cn 

•«H 

X 

P 


X 

p 

03 

03 

P 

X 

P 

G 

O 

> 


o 

X 


M 

o 


0) 

g 

-H 

P 

I 


P 

o 

03 
■r~i 
X 

0 

^ p 
Eh 03 
O X 
GO O P 

z o 

1 

4 J cn 
o cn 
0) 0) 
o 
o 

p 

a 


z 

0 

H 
H 
< 

EH 

Z X 
W O 
C4 

CJ P i 

01 03 cn 

ou x <5 

g 

G 03 


04 

o 

o 

X 


o P P 2 

<u o o P 
■n G 03 X3 
X ^ H O - 


P 
o X 
P 3 


G O 

0) o 


p 
03 
O 
03 - 
tn 
p 
03 
> 


a 

o 

o 

rH 


P 
cn 

-H 
C H 
G - 

I 

p a 
a) 03 
O' g 


G cn 
-H G 
O' 1 
03 0) 

X rH 
I G 
M XJ 
0 0) 
O X 

rH O 

o cn 


p 

03 


>1 cn 

a) g 

1 

.. a> 

rH 

A G 

~ r> 

** 03 

x 

0 

cn 

G 

•H 


C/3 

l 


O' 

c 


G 

XJ 

03 

X 

0 

cn 

U 

X 

3 

CAP 

C 

H5 

3 


g 

03 

03 

P 

P 


B-4 


(loop for schedule-me 


<P 









i 



T“\ 









d) 



.Q 




0 




<15 

H 



0 




£ 

H 

A 


£ 

3 








d 



H 

X) 

^ — » 


CP 




a> 

> 

0) 


4-» 

<y 

CP 


£ 




H 

54 

£ 


1 

xz 

54 


H 

0 j 



3 

<P 

H 


G 

0 

0 


4-5 

o 



*0 

4-5 

4-5 

a> 

-H 

co 

G 


1 

o 



0 

c 

1 

£ 

O' 


O' 


4-5 

A 



A 

*H 

c 

•H 

a) 

a) 

*H 

a) 

0 




0 

1 

■H 

H 

xs 

£ 

- 

£ 

0 

aa 



co 

C 

O' 

1 


H 


•H 

f—H 

D 




H 

0 

C 

— » 

4-5 

a) 

4-> 

H 

CO 


a» 

54 

1 

X) 

4 f = -H 

a> 

G 

54 

1 

0 


0) 

j-t 

0 

54 


Q Q Q O' 

E 

— 3 

0 

G 

0 — 

•> 

X 

0 

3 

a> 

<p 

^ i <P 

i 

0) 54 

44 

H 




0 

CO 




a) 

X) 

1 



<p 

G 

>4 

V 


X) 

i 

X 



m 

0 

V 

CP 


i 

CO 

d 

a> 


XI 

0 

0 

H 


CO 

CO 

£ 

£ 


0 



3 


(0 

CP 

l 

i 




** 

V 


0) 

0 

CO 

a> 

54 

54 

4-5 


<P 


0 

0 

CO 

H 

d 

0 

0 

>1 

J3 

s 

0 

54 

05 

3 

0 

44 

CP 

CP 

0 

CO 

54 

a 

0 

T3 



H 


CO 

i 

a 


0 

a) 


a 

H 

• • 

1 



<p 

54 

Xi 


0 

0 


CP 


0 

£ 

a 

0 

4J 

o 

0 

V 

(0 

X) 

£ 

-H 

1 

CO 

(0 

H 



o 

C 

d 

4-5 

CO 


■H 

— - 


** 

xz 

H 

c 

1 

d 

<p 

H 




4J 

-C 

i 

4-5 

a 

£ 


4-5 




0 

CO 

0 

> 

d 





G 

m 

co 

CP 

XJ 

G 

a 

0 



■H 


CP 

H 

' — ■ 

1 

d 

CO 





0 

H 



0 ) g — 

00 

0) 

U V 

0 Q) 

X r— | 

a 3 

1 v 
a) a> 
d -c 
a o 
> w 
T3 i 
— a> 

CO 

o 

x: 

x 


<p 

x 

o 

X 

0) 

— J3 
E I 
d 00 

a) <0 
x <p 
x o 

CO O 

X 

<p a 

c 

H x 

H OO 
I 4-1 V 

«C 

co a 
a) o 
x o 

4-1 H 


O 4-1 O * 5 £ 

x <p a a> o i 

0 X) i tji a a) 

A I X d I H 

1 co m x g 3 

CO CO g ^ 3 T3 

co <p i ra g a) 

a) o co s -h x; 

u o co i x o 

o M <u 6 d co 

x a o 3 £ 

a o £ i u* 

<P X *H *0 >4 

a) e a >j c w 

6 h i d -h co 

m X co g 4-* 


o o X 

M U A) 


oq a? g i a> a> 

— HI CO XJ 0) 

x p a) to i xj 

x a> v h a> co 
a) 3 a) 3 o co x 

3 o xs tj o a) a) 

O a O <P M 0 3 

at i co x: a o o 

iv o i x a 

tj qi c w to a i 

<U X H rd T3 

i x h o> T3 a O <P 

•H D <P G >i E X 

3 O’ J3 A) *0 I H 

cr <p i i ^ a> 3 

a) x co a) HO 1 
cc co co a) 3 o 

X 0) <P E T3 X 

X <p O O H <D 

<p 3 o o x x: &m 

3 O X X I O h4 

0 a a a c « w 

CXi I I I H CO 

1 CP °0 CO O' <u 


a> w 
o x 
Q) o o 


W H a) O 

X CO A) I 

O O CO 

co a) o <o 
E x a) 

CP -H a o ~ 

£ X I O T 3 

i i co x a) 

<u g d a h 

h h a I 3 






4J 

. — . 

<p 




0 


£ 


CP 


CP 

4J 


r 

54 


-n 

0 

a) 

CO 

0 


XJ 

0) 

H 

l 

44 


o 

-n 

3 


<P 



X! 

V 

V 

XZ 


54 

0 

CP 

G 

\ 


<P 


XZ 

0 

CO 

- — . 

3 

CP 

0 

> 

CO 

> — 

0 

£ 

CO 

CP 

a> 

G 

a 

H 


X 3 

0 

•H 

i 

4-> 


X C 
CO (15 3 


£ 


CO 

x; 


O' 

d 

0 

a / 

XJ 

2 

E 

X 

H 



0 

c 

0 

c 

0 

H 

1 

O 

i 

1 

4.5 


2 

CO 

0 

U 

1 

XJ 

a) d 

xc 

5*4 

co 

CO 

G 



H 


■H 

a 

CO 


£ > 

0 

H 

CO 

CO 

3 

Q 

E-* 

X) 

4-5 

* 

co 


d x 

0 

< 

CP 

0) 

54 

W 

I 

c 

■H 


0) 

cV= ■ 

G 0) 

H 

H 

0 

0 


XI 

t-t 

0) 

XI 

4-> 

0 

f 

1 X 

0 

2 

0 

0 

CO 

D 

X 


G 

C 

0 

: 

co G 


W 

X 

X 

CO 

Q 

< 

CO 

0 

-H 

54 


CO H 

— * * 

CO 

a 

a 


£ a> i o 

d O 0) £ 

a> o £ h 

X X H X 

x a x i 

CO I / H 

co ^ m 


. 

a, w 

3 

0 


d 

CP 


d 

d 

<P 

-o 

sz 

sz 

— v 

CP 

V d <p 


0 

CO 

0 


i 

0 

a 


0 

H 

Si 

a 

a Si 

0 

CO 


CP 

XI 

— a a 


XJ 

Q) 

X 

g 

co a> 

a 

i 


X 

X) 

d 

> 

>i 


G 

d 

4* 

XZ 


> 0 


X 

X 


d 

d £ 

i 

CP 


X 

d 


V 

V 

+ 

1 

xz 


0 

A 

A *0 co 


CP 

a 


CP 

a h 

V 

H 


CO 

H 

-X 


' — ' 

-w 

a) 

1 


CO 

co 

co ^ ^ 

c 

> 


CP 

X 

>i X 

(P 

XJ 



•H 

d 




X 

V 



3 

3 

X 



CO 

x 

T3 I 

X 

d 

<p 

X 

d 

> 

X 

X 


d 

H 


-G 

a 

a 44 

3 

X 


0 

CO 

C 

H 

H 

co 

d 

> 

d 

X 

X 


0) 

■«H 


(0 

3 

3 x 

X 

■H 


XJ 


•H 

3 

H 

0 

£ 

< 


<p 

<p 


X 

3 


3 

<P 

cp <p 

CP 



X 

X 

O' 

cr 

d 

XJ 

X 


Al 

CO 

CO 


0 

XJ 


a 

G 

C co 

X 



0) 

d 

a) 

CP 

> 

X 

0 



' 



— 

■ — ' 


’ — ■ 


■ ■ — ' 




> 

£ 

jQ 

X 

d 

0) 

X 

















^ m 

l CO Jj 

X o 

^ <u a) ■ 

O > r-\ 

O -H X) 

X C O 

3 

O' t X 

G X O 

h a> 4-» 
H O' 

3 w a 

"O o 
a> a> o 

x o h 

U G — 
CO a) 

o»° M (A 

j a) o 

^ 'H M 

? 4-4 ra 

= H I 

T3 0) 

£ I cn 

td a) 

a) £ co 

5-4 -H 3 

H X I 

CO — £ 


O * 
4-1 4-5 

— CP 


B-5 


* 

01 

O' 

<T3 

4-> 

4-> 

03 

3 

I 

£ 

P = 
6 / 
■w / 

03 OJ 
£ > 
* M 
0) 

a> 4J 

g c 

*H *H 
— V I 
--'CO 

« 2^ 

h m / 
E-» 0 i 
\ O' 

6-j C O 
« O g 
rtj »H *H 
H 4J 
CO * C 
® w P 
* M 
P 

X O 

m u 
g oj 


0 ) 
cn 
<D 
O 

-00 

o* u 

«H - 03 Q« 
03 CO 
> P 4J 
0 I CO 

'-'go 
P O' 

0 CO c 

g O 

•H\ hi 
4J <#» 

G * 

PCs 
*-» O 
* -H £ 
4-> 4J Ol 

CO 01 o 

01 *0 M 

D> *H 4J 

c <— i <o i 

o 01 

-» > 4J 

w w 01 

g 

Jhi 

O 

4-i 


c 

0 
-*-♦ 
4-> 

01 
*0 


01 

> 


1*1 

to 


eg 

i 


X> 

01 

u 


o 

6 

•r-l 

4-> 


4-> 

c 

p 
M 
I 

4J 

w g 
O ol 
O' O 
C ^ 
O x> 
H CO 


4-> 

01 

6 

W 

o 

>4-1 


0 

£ 

4J 

c 

p 

u 

u 

CO 

o 

O' 

c 

o 


CO 

ol 

a 

>1 — . 
V ~ 

c c" 

0 o 

•H H 
4-> 4-> 

01 a 
x> -H 
C M 

o o 

CO CO 

0 o 


Jj 

jC 

O' 


6 ^ 

-H CO 

X o 
01 O' 


a - 

0 
u 

1 


*o +J — 


0 
c 
01 
o a 

O I 

•H 4 J 
XI 0 

a O' 

03 

M 

O' 01 
w c 
01 

t> a 

0 — 

jc — 

4J 

01 4-> 

£ ai 
H-» H 
ai ~ 
T3 


. 01 

c x: 

4J jc 
x> 
>i v 
M -H 

0 3 
+J 
(0 

•H T 3 
JC C 

1 -H 
U X I 
01 I 
0) 01 
«H p 

0 r-l 

«• 03 

> 

01 I 

c a» 

03 rH 

a a 

■H 
T3 4-> 
C H 
01 P 
co g 


C 

o 

H 
4-> 

JC -C 
O' 4-> 
•H *0 
01 H 
JC 5 


U 

o 


u 
o 

4-» 

0 4J 

01 O 

0-1 (13 

1 

M I 

a> ai 

2 £ 

O *H 

a 4J 


CO 

a> 

£ 




— >S 

CO 



— 

1-1 



CO 




01 

— ' 4-1 



£ 


— * 




0J 


4-1 

^ 4-1 

N 



CO (— | 

•r-i 


1-1 

0) Ql 

CO 

r-" 

V 

£ CO 

** 

— 

0 



—X -—Si 


4J 4J 

01 

1-t 01 


03 

G 

0) 6 


T3 U 

03 

3 *H 

V 

G OJ 

a 

O 4-1 

s. 

O 3 


a c 

* 

0 0 

TJ 

c 

i p 
£ u 

CO 

ai a 

CO •*-' 

01 

p i 

u 



Eh 

I 

Eh 

a$ 

< 

Eh 

CO 

4J 

0 

CO 

1 

01 
r— I 

A 

<n 

4J 

CO 


u 

u o 

0 xi 
4J O 
a oi 

01 m 

4-1 i 

I M 
01 0 ) 
£ 5 


01 — 
rH C ~ 
>1 03 — 
a 4 -> 

rH 

X £ V 

03 01 

O 0) rH 
>1 M rH 
X> H 
O CO 4-i 
X •• *. 


— 01 


*H 

4 -> 


cr) 

01 

g 


CO ^ 4-1 

ai o ^ 

g 

•H rH O 
U >, X 


4-1 

jc jc 

4 -> O' 
T 3 H 
-H <31 

5 jc 

i i 


x >, 


o 

v 


rH 

O' 


c 

— s 

03 

CO 

4-1 

01 

O 

£ 

01 


u 

4 J 

1 


3 

JC 

03 

4 J 

Ij 

O' tJ 

c 

• • 

01 

co 

H 

0 

' — ' 

■l-l 


JC 


a 


m 




O' 


g 

03 

01 

u 

x» 

CO 

ai 

g 

03 

G 


CO 

03 

a 

>1 G 
V 0 
•H 
X> Jj 
G rd 
■H 4-1 
^ C 

a oj 

I CO 

g ai 
o u 

■H CU 
4 J I 
03 CO 
(d 


C 

01 

co 

01 


4-1 0 ) 

P u 

- a 4 -i 

M 4-1 CO 

04 P 

— o e 


i 


T 3 JC 
O 4-1 M 
JC -H 4 J 
x> 5 co 
0 ) •• •* 
g 5 — 

4-i T3 
0 ) — 

T3 


<0 

C0 

01 

o 

0 
u 
a 

1 

co ai 

S 6 
a oi 
> c 
tj 

" 4-1 

o 

01 01 
a -n 
>1 J 3 
4 -> O 


0 ) 

g 

01 

G 


n 

? 

TJ 

0) 

— . »— I 
H P 
■H Tl 
G <1> 
JC 
co o 
M co 

0 

•H « 

01 

m U 
c x> 

H ^ 

I t 
a> vb 
> t 
H = 

4J 

■H g 
CO OJ 
G 01 
0) M 
CO 4J 


01 

Vj 

0 
G 
O' 
•H 

X> 

<0 

01 

>-0 


CO 

03 

a 

> 

T> 

n 

<o 

0 

0 

0 CO 
CO 

01 0 ) 
I o 

43 O 


0 

0 
PC 

1 

M 

2 


co 

T3 oj 

0 a 

JC >i 
4-1 T5 

01 4-4 

g 01 

4-i a 
Q) ^ 

V 


O' 

c 

•H 

CO 

CO 

01 

<J 

o 

U 

CLt 


O' 

01 

£) 


a) o 

g rH 

03 

G >, 
I 4-1 

X) U 
4-1 O 
0) -H 

u u 

a a 


i-i 

0) 

4J 

c 

0) 

CJ 

JC 
0 
u 

03 
01 
CO 
0) 

PC g 
p 

c g 
O -H 
CO X 
G 03 
JC g 
0 * 
t) 


1-1 o 

0) 

3 01 

O g 


l-l 
0 

n a -h 

G I 4-1 

O X G 

a 03 p 

co g M 


* 

01 

g 

03 

^ = 
4-1 co 
I t4 

g > 
03 03 
u a 


U 4-1 
O' 

O 4-1 
M -H 

a 03 


co 
c 
o 

O 03 


01 4-4 

g o 


1-1 

4-1 C0 


3 

ai 

M 

o u 


<0 

co 

0) 

o 

o 

u 

a 


ai ai x> xj 


c x; g 

O 4J -H 

O 4J CO o 


OJ 

4J 


B-6 


-wattage* 



O' 




a) 



05 

X) 



z 




o 

a) 

— V 


M 

£ 

' «« 


Eh 

i 

0) * 


< 

a) 

£ 


Eh 

H 

1 05 

HH. 

Z -H 

3 

a> y 

A 

^ &J 

TJ 

Hi S 


£h 05 H 

ai 

3 w 


O Cd H 

x; 

TJ Eh 


o c 

0 

Q) 1 

4-> 

ec & 

CO 

X: Eh 

0 ofi 

CO 

•H 

^ 


CO < 

H 

J 

^ CO co 


Eh 


CO CO co 

CO 

^ — 05 CO 

co 

co CD <D 

03 

U £ 

<1) 

0) 0 O 

a 

CO -H TJ 

£ 


o co O o o 

0 0) O u M 

m u u a cl 

a o a i i 

1 U I 4-> 4-> 

jj a. 4 -> o o 

o i o o o 

O 4-> o u M 

U O M ' - 


h as m 

(TJ ra > > 

> H > <» <d 

<D nj a) ~ w 

a) 0)0) 
c ~ u > u 

•H 0 ) O O 

0»T3 4J E 'W 

0) c 'W 0) 0) 

1) « ID M i3 

III'-") 

CO CO CO CD 

(/) CO CD C/5 CD 

0) 0) 0) 2 0) 

o a o o o 

0 o o H o 

M M M H ^ 

a a a < a 

1 I I h i 

co co co 2 co 

nj oj oj £*J 03 

CL CL CL W O- 

>,>,>, W > 

^ ^ 2 £ 2 

<4-1 4-| 4-t 4-1 4-1 

4J jj 4J 4~> -U 

a) a) o; a) o) 

co to co co co 


> -H 4J 3 
V H C 0) 

I 3 ~ 

H co M 0 ) 4 -> 

id <d i > co 

> i CO O *H 

U H CO £ H 

5 4J 0) 0) I 

jj I O M co 

3 4J O * g 

• r| M u Q> e 

i m a c h 

c u i w -u 

H co co l 

| | <Tj4J4-)4- 

u x a co u u 

o O >1 -H flj f 

* M T> H 4J r- 

0 03 ' — " I CO I 

CL 0 ) 0 ) l Cl 

1 CO 0) 0) .C C 

g e e p e 

3 TJ H H V 4 -r 

g c 4 J 4 J <TJ 4 

3 a) i i o) i 

M 3 4-> CO 4, 

<d H H M » 

g nj on ctj oj < 

| -H 0 ) j 

T 3 O XJ CD -H I 

3 0 ) I -U 

•h a + x: I j 

CM CO u 3 1 

— — ' M *H 

"D OJ CT 

T> 0) 3 a> 0) 

o M CD CO XJ 

x: 

u h ty (T-c 

<u o 4 -> 4 -» co 

g 0 ) 0 ) 0 ) 3 

^ co co CL 

a) — — — — 

*0 


a) co 4 -i 
£ 0) H 

■rl O' 0) 
4J ra CO 
— ' CO 

CO JU) 

^ a) m 
co g u 
aj - 0) 

CL 3 

>t 0) O 

TJ C CL 
rO ^ 
<33 a 
U \ 0) 

® 4-> £ 

* <D H 

0 O' 4J 
04 ^ 

1 

+J 4J 

3 aj 
•H £ 

w G 

04 O 


55 td 

l 4-> fi 

4 J o a) 

A a) co 
•h -n Q) 
H X! L 
cl o a 

u 

v o o 

O 4-4 TJ 

x: 

jj a 
a> o 
£ o 


M 




03 — 



CD 

TJ H 



£ 

C H 



03 

m C 

— 


C 

4J 

CO 


l 

CO CD 

CO 


CO 

4C X5 

0) 


CO 

H 

0 


a) 

£ L4 

o 


0 

03 O 

u 


0 

a) co 

a 


u 

j-4 a) 



a 

4J TJ 

H 


i 

co 

3 


CO 


> 


3 


a) 

-o 

a 

> 

0) 

-w ’ 

i 

> 

TJ 

M 

M 

n) 


L9 

<D 

H 



4J 

' ’ 


CO 

4-4 

- 


CO 

— 3 

** 



B-7 


[ * 


CO 

H 0) 

h © 
c o 
o 

© >h ~ 

a a ~ 

o i — 
X <n E 
m m fo 
oj a a) 
> > m 
•• 73 4-> 


o £ x 

a <ts a 

E © © 

o M -H 

O 4-> U 

* CO O 

=* •• •• 


M M C 73 
<U <U -H I 
73 73 X X 
M M X C 
O O -H O 
i) il J *0 


o 

3 

rH 

03 

> 

t 

<d 

CO 
i— i 

a 

a 








LO 



rH 

(0 

£ 



rH 


CM 

— * 


03 

CO 

03 



03 



X 


> 

<13 

a) 



X 


O' 



l 

0 

M 

CO 


c 


c 

<0 


C 

0 

X 

© 


0 


-H 

© 


u 

U 

CO 

CO 


N 


0 

X 


3 

a 

• • 

CO 


-H 


03 

03 


X 



a) 


M 


a 

0 


© 

x 


0 


0 


CO 

-rH 


X 

c 


o 


X 


1 

rH 

— » 


© 


u 

£ 



C 

a 

© 

+ 

CO 


a 

03 


rH 

£ 

3 

S3 


© 


• i 

a) 

a 

03 


73 

rH 


u 


X 

H 

0 

> 

rH 

} 

03 

rH 

Cu 


c 

X 

•H 

0 

rn o 

5 

> 

03 



0) 

CO 

4-> 

«■ 

O 

03 

I 

> 



c 


03 


i 

1-1 

0) 

1 


X 

o 


CO 

03 

a 

>i 

73 

4* 

cd 

M 

(9 

» 

O 

04 


3 X 

a o 

© © 

e £ 

H H 
X X 


cr 

X 
© 

~ VI to 

— ft3 ' — ' ^ — — 
O 73 

x <w 

rH £ -H 
(U v 
> H 

c - 

U ** 

3 

x a 

© CO 

m m 

X 

— a 

nj 

X 6 
CL) **-' 


a 

> 

v 

A 

(0 

«J 

X 

I 

N 

H 

X 

•H 

C 


73 

O 

x 

X 

a) 

£ 

4H 

0 

73 


C/l CQ 

<C < 
X H 

I 

a x 

i </) 

a> < 

rH sc 

X 

rd X 
X CO 
I <TJ 

x x 

C0 M 
03 rH 
X o 


4-1 

•H 


O' 

03 

S 

0) 

D 







rH 







03 




X 



> 

--S. 



CO 

73 

x-s 


O' 



© 

C 

w 

H- 

03 



X 

© 

PI 

1 ' 

£ 





OQ 






c 

< 

. — . 




© 

•H 

H 

w 

w 



rH 

cn 

1 

pi 

X 



X 

© 

X 

QQ 

PQ 



03 

X 

0) 

< 

< 



4J 


< 

Eh 

Eh 



1 

O' 

X 

1 

1 



XI 

03 


X 

X 



CO 

s 

c 

cn 

cn 



oj 


■H 

< 

< 

M 


X 


O' 

X 

X 

PI 


1 



© 



OQ 


© 

CO 

XI 

c 

c 

< 


M 

03 


-H 

•H 

£h 


© 

a 

A 

O' 

O' 


pa 

£ 

> 

CO 

© 

© 

X 

pi 


73 

03 

X 

X 


X 

X 73 X 
to C 0) 

<d -h O' 

X X ~ 

i i 

TJ <U r. 

H 3 73 
■H rH C 
3 03 3 

03 > O 73 
— I H-t CC 
© 3 

73 H ® O 

o a 3 4h 

£ H H 
X X 03 4H 
© rH > H 

£ 2 ~ ~ 

X £ 

a) ^ 

73 


w 

X 

03 

< 

Eh 

I 

X 

CO 

< 

X 

73 

C 

a) 

x 

CO 

03 

X 

X 

0) 

O' 


O' O' 3 


~ ~ a 


X 03 4H 
rH > *H 
D "" 

£ 


B-8 


(setf (gethash end HASH-TABLE) (- value mag)) 
(setf (gethash end HASH-TABLE) (- 0 mag))))) 


Appendix C. 


Rule-Search (RETE) Algorithm Adaptation 


This is an adaptation by S. Davis of the 
RETE algorithm of Charles Forgy 
for a future version 

of the Common LISP/Flavors scheduler 


D. Hays ct al. -Languages for Al - Johnson Research Center, UAH - October 

1988 



. ret£ . Base: !0 . ; Def ault-characte r- sty le : CFIX : ROMAN 

;; Mode: LISP; Syntax: Common-Lisp; Pac age. 

LARGE) ; 

; ? Stephen W. Davis 095-6257 

;; Johnson Research Center 205-895 625/ 

(defun rule- interpreter nil 

a *do"(uid-ilsC database (cdr ddd-lls«) add-liat)) conflict-set))) 

(conflict-set nil UPP-nd ‘database. 

((end (null add-llst) (null conflict set) I 

^ U ,“tiSo"lci a 'confll=t-r.sol»tion conflict-set), 

(perform-action choice) 

::;r, ~ choic '”” 

>))) 

. (Urt-opf) (first conflict-set)) 

(defun conflict-resolution (confli 


(defun perform-action (action) 

(let ((rule (first action)) 

(pred (first (second action) ) ) 

(actor (second (second action) ) 

(lesser (third (second action)))) [ Q f -A-]." rule actor lesser 

(format t "~%Flring rule -A - > ~A is 

P ”t.trd!t!b,.e (cons (second ectlonl d.t.b...)) 

(values) ) ) 

(defun remove-repeats (conflict-set action) 

(do < s^irSi^cl2^ , S^ act it»»r ult> 

(result nix ^ (con3 (ca r temp) result))))) 

( (null temp) result) ) ) 

(defun enter-clause (clause) 

(let* ( (pred (car clause) ) 

(nubpS’p™™” si" < 3 .f — 1 

Ul (mapcan #' (lambda (prod) (enter-first args prod)^) ) ^ge^pred 'second)) 

(mapcan V £££ 1^'- third args prod), (get pred 'third,)),) 

. _ oo „ d , (clauses Pfod -if d, „ , 

id r"b‘^ see: 

(list nil) ) ) 

(defun cross-product (lisl lia2 lis3) 

(mapCAN #' (lambda (x) , , s 

(m ,p CM . f Uambda^v^ (llst * y <) ) 11=3). 

Iis2) ) 

lisl)) 

(defun match-and-execute (args prod) 

(cond ((apply (get prod 'condition) arg 


(check-for-dups prod (apply (get prod 'action) args) ) ) 
(t nil) ) ) 

(defun check- for-dups (prod action) 

(cond ((member* action database) nil) 

(t (list (list prod action) ) ) ) ) 


(defun member* (target lis) 
(do ( (temp lis (cdr temp) ) 
((null temp) nil) 

(cond ( (equal (car temp) 


target) (return temp) ) ) ) ) 


(defun enter-second (args prod) 

<maPCan args) (clauses prod 


' third) ) ) ) 


(defun enter-third (args prod) 


- second) (list args) ) 




C-2 


; Default -character- style : {:FIX : ROMAN 


... Mode: LISP; Syntax: Common-Lisp; Package: RETE; Base: 10 

: LARGE); 

;;; Stephen W. Davis home: 205-533-7308 
;;; Johnson Research Center 205-895-6257 

(defun ancode-productlons nil (setq initlist ' ()) (mapcar 'encode-a-production product 
ions) ) 

{defun encode-a-production (production) 

(let ((name (first production)) 

(condition (second production)) 

(action (fourth production))) 

(let ( (predl (first (first condition) ) ) 

(pred2 (first (second condition) ) ) 

(pred3 (first (third condition) ) ) 

(predact (first action) ) ) 

(when (notmember predact initlist) 

(setf (symbol-plist predact) nil) 

(push predact initlist) ) 

(setf (symbol-plist name) nil) 

(cond ((and predl (notmember predl initlist)) 

(setf (symbol-plist predl) nil) 

(push predl initlist) 

(cond ( (and pred2 (notmember pred2 initlist) ) 

(setf (symbol-plist pred2) nil) 

(push pred2 initlist) 

(cond ( (and pred3 (notmember pred3 initlist) ) 

(setf (symbol-plist pred3) nil) 

(push pred3 initlist) ) ) 


) ) ) ) ) 

(encode-condition condition name) 

(putprop name (build-action (mapcar ' cdr condition) action) 'action))) 

(defun encode— condition (conditions prodname) 

(let (first second third) 

(setq first (first conditions)) 

(update prodname (first first) ' first) 

(cond ((cdr conditions) 

(setq second (second conditions)) 

(update prodname (first second) 'second))) 

(cond ({cddr conditions) 

(setq third (third conditions)) 

(update prodname (first third) 7 third) ) ) 

(putprop prodname (build-condition (cdr first) (cdr second) (cdr third) ) 
' condition) ) ) 

(defun update (prodname pred relation) 

(putprop prodname pred relation) 

(putprop pred (cons prodname (get pred relation) ) relation) ) 

(defun build-condition (varsl vars2 vars3) 

'(lambda (first second third) , (build-test varsl vars2 vars3))) 

(defun build-test (varsl vars2 vars3) 

(let ((test (append (encode-pair varsl vars2 'first 'second) 

(encode-pair varsl vars3 'first 'third) 

(encode— pair vars2 vars3 ' second ' third) ) ) ) 

(cond ((null test) t) 

((null (cdr test)) (first test)) 

(t (cons 'and test))))) 


C-3 


) 


;; ; ENCODE-PAIR ( — X «Y ) (—7 n T T,« m 

;;; encode-pair ( (vn /ptdo^ first second 

Q (FIRST FIRST) (SECOND SECOND)) 

(defun encode-pair (vara] v aT -=o 
(and varal „« s2 coj 

' 7 ' lrst varsl) (first vars2)) 

((and q / ( H lrSt ' nan * e D (first ,name2)))) 

((and (cdr vars2) (eq (first vaT .„ 1w 

* ( (ea if< rot irzrst varsl) (second vars 2 ))) 

<<lr>H ,11 'namel) (second ,name2)))> )}) 

((ana (cdr varsl) (cdr 

i) (cdr vars2) (eq (second varsl, (second vars2) 


1 ((eq (second , namel) (second , name2) ) ) ) ) , ) 


(defun build-action (condition action) 

ambda (first second third) (list (quote , (first action,, 

' @ (descr±be -args condition (cdr action) ) ) , ) 
(defun describe-args (condition action) 

(let ( (argsl (first condition), 

(args2 (second condition)) 

(args3 (third condition) ) ) 

<».P=« *' (lambda ,x, . (Cit , rgsl „ . (flr „ fl „ t „ 

rst >> <(and (Cdr ar ^l) (equal x (second argsl,), 

( (equal x (first args2) ) ' (f-\ 

cond >> <(and (Cdr ari ?s2) (equal x (second args2) )\ 

* (tlr " thlrd 

lrdl "I 1 ‘ Cdr “Ss3> (equal x (second argsl t ) ) 

action) ) ) 

(defun traceon nil 

describe -arcs bull 

update encode-condition ld_tMt ^^—ditxon 

coae a production encode-productions) ) 


(second fj 


(second ss 


(second tl 


C-4 



;;; Syntax: Common-Lisp; Package: RETE; Base: 10; Mode: LISP; Default-character-st 

yle: (:FIX : ROMAN : LARGE) 

(cp : def ine-command (com-production-system : command-table "User") 

((trace 'sclrboolean 

: prompt "Trace forms-’ 1 
: default nil 
: display-default t 

documentation ’’Trace all encoding and firing forms.")) 

(if trace (progn (traceon) (traceon2 ) ) 

(untrace) ) 

(production-system) ) 

(cp : def ine-command (com-encode-productions : command- table "User") 

((trace 'scl: boolean 

: prompt "Trace forms" 
default nil 
display-default t 

documentation "Trace all encoding and firing forms.")) 

(if trace (traceon) 

(untrace) ) 

(encode-productions ) ) 

(cp def ine-command (com- rule-interpreter : command-table "User") 

((trace 'scl: boolean 

: prompt "Trace forms" 
default nil 
display-default t 

documentation "Trace all encoding and firing forms.")) 

(if trace (traceon2) 

(untrace) ) 

(rule-interpreter) ) 


05 


... Mode : LISP ; Syntax: Common-Lisp ; Package : RETE; Base: 10.; Default-character-s 

tyle: ( :FIX : ROMAN : LARGE); 

;;; Stephen W. Davis home: 205-533-7308 
;;; Johnson Research Center 205-895-6257 


(defun Production-System nil (in-package ' rete) (initvars) (encode-productions ) (rule 
-interpreter) ) 

(proclaim ' (special productions database initlist) ) 

(defun putprop (predicate value slot) (setf (get predicate slot) value) ) 


(defun initvars () 
(setq productions 


( (pi ( (father »x -y) (wife -z -x) ) implies (mother =z =y) ) 

(p2 ( (mother -x -y) (husband -z -x) ) implies (father =z =«y) ) 

(p3 ( (wife -x -y) ) implies (husband -y -x) ) 

(p4 ( (husband -x -y) ) implies (wife «y -x) ) 

(p5 ( (father -x -z) (mother -y -z) ) implies (husband -x =y) ) 

(p€ ( (father ~x «z) (mother -y -z) ) implies (wife =y =-x) ) 

(p7 ( (husband -x -y) ) implies (male -x) ) 

(p8 ((wife -x -y) ) implies (female -x) ) 

) ) 


(setq database ' ( (father Alan Alta) (wife Alice Alan) 

(mother Bertha Bet) (husband Bob Bertha) 

(wife Caitlin Carter) 

(husband David Dianne) 

(father Earnest Earnie) (mother Evelyn Earnie) 
(father Frank Fred) (mother Felicia Fred) 
(husband George Georgia) 

(wife Helen Herbert) ) ) ) 


(Defvar *hook-level* 0) 

(defun hook (x) 

(let ( (*evalhook* ' eval-hook-f unction) ) 

(eval x) ) ) 

(defun eval-hook- function (form ^optional env) 

(let ( (*hook-level* (incf *hook-level* ) ) ) 

(format ♦trace-output^ "~%~v0TForm: ~S" 

(* *hook-level* 2) form) 

(let ( (values (multiple-value-list 
(evalhook form 

#' eval-hook-function 
nil 

env) ) ) ) 

(format *trace-output* "~%~v@TValue : 

(* *hook-level* 2) values) 
(values-list values)))) 


C-6 


Appendix D. 

Routines from Ada Version of the Scheduler 


These routines were programmed 
by S. Davis 

as part of the Ada adaptation 
of the scheduler. 


Hays et al. -Languages for At- Johnson Research Center. UAH - October 1988 


C/3 

• mm 

z 

tO 

DC 

a 

j 

55 

u 

i 

Q 

Z 

E 

0> 

u 

3 

■3 

a> 

u 

o 


00 

O 

l 

tO 

J 

D 

Q 

to 

..PC 

oo O 
T3 

* s 

BSq 

3 S 


UM 

8 


>« 

Q 


a 

tO 

.. a 

to u 

E 00 

2 

w 

CQ 


C/3 

JD 

3 

.2 

*c 

cd 

> 

*0 

o 


e 

# o 

c3 

o 

G 

*o 

<D 

Pu, 

C/3 

OJ 

SJQ 

cd 

o 

cd 

Oh 

CO 

< 

cu 

>- 

Q 


<D 

J-h 

cd 


o 
0) 
OX) H3 


to 23 

o g 

rrl X 

lZ O 

s£ 

| Ml I 

O ,l ; ; 

WW ' ' 

CQ J 
I D 
X Q 
U to 

o a 

j u 

U oo 


to 

M 

< 

00 

DC 

to 

> 

M 

z 

a 

i 

Eo 

o 

o 

M 

I 

CO 

H 

II 

s 

a 

to 


CL 

Q 

OO 

D 

I 

to 

j 

D 

Q 

to 

a 

u 

00 


to 


ID 

c 


£ 

© 

C 


3 2 

gn 1 

to x 


a 

u 

00 


to 

H 



w- © 
O **“ 

E 

u 

o 

o 

u 

nJ 

1 

O 

c o 
*M>U 

O) 

z 

< 


JO 

2 

CO 



cu 

eo 
o 
o 

pj 


o 

J 


z 

< 


OQ 

a 

00 


Qm 3. 
O o 
O O 


Z 

to 

DC 

Q 

J 


U 

I 


■3 *3 
C C 

a a 


Q 

Z 

E 

3 

C 

© 


D-l 


declaring access type DYPAS_PROCESS 



D-2 


IEFF: DYPAS_PROCESS (END => 100); 

- object IEFF created with slot END set to integer 100. 


Appendix E. 

Floyd and Ford’s Description of their Scheduler 


from the 1986 Proceedings of the Conference 
on Applications of Artificial Intelligence to Space 


D. Hays et al. -Languages for A! - Johnson Research Center, UAH - October 1988 



A Knowledge-baaed Decision Support System for Payload Scheduling 

Stephen Floyd* 
and 

Donnie Ford** 

*Department of Management Information Systems and Management Science 
School of Administrative Sciences, University of Alabama in Huntsville 

♦♦Cognitive Systems Laboratory - Johnson Research Center 
University of Alabama in Huntsville 


ABSTRACT 

The purpose of this paper is to Illustrate the role that artificial 
intelligence/expert systems technologies can play in the development and 
Implementation of effective decision support systems. A recently developed 

prototype system for supporting the scheduling of subsystems and 
pay loads /experiments for NASA's space station program is presented and serves 
to highlight various concepts. The potential integration of knowledge based systems 
and decision support systems which has been proposed in several recent articles and 
presentations is illustrated. 


1 . INTRODUCTION 

At the Sixth International DSS Conference (DSS-86) Peter Keen in the closing 
plenary address entitled "DSS: The Next Decade" discussed what he perceived as the 

important roles of current and future AI/ES technology in extending the field of 
decision support systems. Among his perceptions was the fact that the field of AI 
could play a major role in the development of systems to support the tougher, 
ill-structured types of problems. He also viewed current AI/ES hardware and 
software technology as "power tools" for DSS development. A few months earlier John 
Little in an article entitled "Research Opportunities in the Decision and Management 
Sciences" promoted similar observations while discussing research priorities of 
NSF's Decision and Management Science program [9]. Major among these priorities was 
the role that expert systems technology could play in advancing the Decision 
Sciences. Similar ideas have been expressed over the past few year by other 
reseachers in articles and at major conferences such as ORSA/TIMS, DSS-86, IDS and 
AAA * ^8], 1 13], [16], [17], This paper supports these observations by 

describing knowledge-based DSS for scheduling payloads for NASA's space station 
program. The payload scheduling system serves to illustrate the potential 
Integration of DSS and ES as it Involves the addition of a knowledge based component 
to a system which currently provides decision support via extensive interaction 
between scheduling personnel and more traditional scheduling techniques. It is the 
authors' hope that the following discussion of the scheduling system will help other 
researchers in establishing the applicability of the new "power tools" in DSS 
development . 


This paper concerns the development of a solution procedure and interactive 
system for scheduling subsystems and pay loads /experiments for the National 
Aeronautics and Space Administration space station program. Traditionally 
scheduling problems have been viewed as static in nature (i.e., a schedule is 
developed for a particular planning horizon and adhered to) and were cast as havine 
one or more clearly defined objectives (e.g., minimize overall completion time? 



.“f’’ AS SUCh - the8e » t0bl8 “ «« ■»« commonly 
analysis [1] "f [6] “]' n|? f S °5“ h ?f- heuristic. ot simulation 

taptasantatlva J i Ili. ? J 

themselves °Zy Aange'SsT '“2^111*1^ m t“r h”!' '1“’ bU,; Ch<! “hjecclves 

this Class of problems U tach 

based expert systems [2] [3] (5] [11] [18] [19]. 7 Aved by knowledge 

- 

that^Cas^e thitA 6eCtl °* discusses the initial dynamic scheduler solution strategy 
that was developed for the prototype system. The details of tM<* n * 87 

system and its development are provided in the fourth section.^ ?hl EST ‘T* 
discusses future enhancements that have been identified for the system Th 
section of the paper provides some concluding remarks on the resear^'to St. 

•erne suggestions for future research In the area of dy„a^c 'ched,!n„g. ' ^ 

2. PROBLEM DESCRIPTION 

the scheduli ng^f ^subsystem^and" pay ! oads'" "a b TarT "thel^a Je^^ta t ion" TT *** 
ln r cluS 8t s e u” 5l°fe 8U s PP ° rt V* 

varloue "housekeeping'' systems. Abollta' "pacH^d™ ^Tir^ls^b" 8 T**"*' ‘" d 

and experiments. These will be sponsored not only by NASA tat Ssl*h ‘°“ 8 ■ >a ’ ,l ° ad3 
and foreign government agendas, universities and Jdvd. lldrles ° U ’ S - 

requlSSnts 0 ' w^V^sT'S cL^Sd 8 ,^ t “J*? 1 " * eC ° f characteristics and 
•hould be scheduled! 1.^2, ^ d,ri ' ! tht -sslon it 

payload/experiments will draw operatine'naw^r fr u 9ysCe “ and „ most of the 

supply. Additionally, certain of them will r^n i 0 SpaCe Station 's limited power 
a continuous basis for the duration of i-h«» f 6 astronaut intervention either on 

of time. Some subsystems and exnfri ! ® Xperlment or for specified subi nterva Is 
uninterupted throughout the entir^ a^rsio 31 ^ 6 c ° nbA ” uou8 in nature and run 

continuously or intermittently for nn i . Stl11 others operate either 

window. The nature of TjZ f °? 7 3 Specified ^ubinterval of the mission time 

during certain phases of the mission re^ 8 that the y be conducted only 

during certain orlanr.tlon' stadin ^ ^ ° CbU ' 

pay load /expe ri me nt s S Ire ^placed "in priority^la^ 1 ' 6 * hiT 1 ^ ^ ^"^c^^hat 

schedule , form the basic c^terLIorL^^ls'^^rLsIJ^e^^od^lI:: 1 "'" “ ^ 

«ve„tr"whTch Pl d 1 n ta «c« 8 rSng U d 11 uSnrt 0 h 61 * B ) l8 . C0 " ,0 “" d * d Eubth - * th e fact that 
indirectly to upset *"«= alther directly or 

any time during the mission „ ^1^” *™ PU ’ “ 

reason t a scheduled experiment may be wirhHr * u e ^bortedfor some 

entire class of experiments^! ta^a^ef the » c he d ule, an experiment or 

scheduler must be designed to handle such dvnamf*- Priorities changed. The 

various mission personnel, including astronauts missi^ 3 i < interacClon w iCh 
principal investigators of affected experiments! S8l ° n P lannin « specialists and 


E-2 



Aa mentioned previously, each subsystem and payload/experiment will consume 
various resources# Major among these will be energy from the Space Station's power 
supply and manpower provided by the astronauts on board# Such limited resources 
place constraints on what systems and experiments can be concurrently ongoing. 
Additionally, and this is another of the dynamic aspects of the problem, the power 
and manpower allotments themselves may change at various times throughout the 
mission# In some instances the change notification will provide lead time for 
scheduling adjustments, whereas in others no lead time will be provided. Changes 

will occur, for example, when vehicles dock, with Space Station# Such changes result 

from the fact that the docking will usually draw on such resources as the power and 
manpower supply# In light of the above mentioned characteristics, the scheduler 
must have capabilities beyond the generation of traditional static feasible 

schedules# The dynamic scheduler must have the capacity to respond interactively 

to such changes and, when required, maintain feasibility via a rescheduling 
procedure# 

A final characteristic of the payload scheduling problem Is that the scheduling 
objectives are variable. During the course of a Space Station mission, mission 
specialists may re-structure the scheduling objectives# For example, it might be 
that early in a mission a resource leveling strategy is adopted which will maintain 
a fairly constant and conservative power consumption rate. Such an objective 
would naturally "stretch out" the scheduling of experiments over some designated 
planning horizon# Later in the mission cycle, however, factors may change this 
objective to one of scheduling as many payloads/experiments as possible (subject to 
the maximum power availability and other constraints) in a given time frame# These 
characteristics then establish the need to develop a system which is capable of not 
only establishing static schedules but also of dynamically maintaining feasible 
payload/experiment schedules which reflect the varying parameters of the problem. 

3. SOLUTION STRATEGY 

Sample data around which the prototype system could be constructed was provided 
by NASA s Power Branch# The data as considered by NASA to be representative of 
actual scheduling data. As 9een from Table 1, four subsystems and forty-five (45) 
payloads/experiments were included. Provided in the table are the experiment name, 
the associated power consumption requirements in kilowatts, the sponsoring agency, 
the time duration (including other specifications such as continuous/intermittent , 
day orbit/night orbit, etc#) and crew involvlement required# In addition to the 
data in the table, other problem specifications were also provided* Most pertinent 
among these were (1) the specification of a normal lab module power level of 25 
kilowatts, (2) a priority structure based on the sponsoring agency and the nature of 
the payloads /experiment 8 , and (3) a two-week scheduling horizon. Additionally, 
several system requirements pertaining to the actual operation of the scheduler were 
specified# These provided a framework for the user interface and system output as 
detailed later in the system description section of the paper. 

To prototype an initial system for user evaluation and feedback, a 
means of generating feasible schedules in the absence of a complete corporate 
knowledge base had to be developed. This was accomplished via the modification of 
a scheduling strategy presently used by NASA scheduling personnel which involves 
conceptualizing schedules using a Gantt chart type format. This heuristic procedure 
is representative of those that when augumented by various scheduling rules will 
comprise the scheduling knowledge base of the final system# An example schedule 
for a simple four experiment problem is given in figure 1. As can be seen, 
experiments one, two and three are continuous, and experiment four is intermittent. 


E-3 


rln^ ins *' de th ® bars, which represent the experiment durations, is the Dower 
are a'“«d ° '‘P”*™'*- , F ° r the3e P«“” requirements 

ii ^ t £“ 

SuTS^CS^ “- 0 - ~ .mS 

scheduling procedure conct^™"' aVallabUU > r (1 ‘ a - P«« a " d "acpower) and the 

SH^SHZSHr^ 


4. SYSTEM DESCRIPTION 

pertinent to the example problem. The system utilize*"? f" 163 ^ knowled S e 

scheme which allows for utilization and P » n iL f n utilizes a frame representation 

This fearure lccrea.ee “he aJeed and P ef “enc,°if ?h“ Ud8e ° theC than ™ les ' 

the inferencing process. efficiency of the system; in particular, 

The inference engine performs only forward chaining n,^ j 
the structure of the problem. There is an at, a & ' ^ 3 deCermined fr cm» 

information at the beginnine of thl abundance of related facts and 

accomodates the forward chaining process The confli* P rocess wh ich in turn 

by allowing Che flr.c rule that la ,ac”nef toT , ^ ra3 ° 1 “ tl °" P>-»ble„ 1. .olved 
an ordering of the rules. This resolution methrvl “ plem ® nteda Th i s necessitates 

time frame for delivering a "demo" system. This ala^f c J*°® en because of the short 
the working memory* acilitates the search through 


The working memory consists of a list of experiment names. 


Associated with 


E-4 



these names are certain facts that are placed into the knowledge base. These 
Include the power requirements, identification number, priority class, sponsoring 
agency, duration of the experiment, and the required crew involvement. Using this 
information, a prioritized list of experiments is generated for utilization during 
the scheduling phase. 

The system has been designed and developed in an open-ended fashion to allow 
system to be extended with only minor adjustments. It contains, in addition to the 
knowledge-base system structure, an output interface which is at present for 
demonstration purposes only. This interface will be detailed later. he system 
itself is dynamic in that it moves through or between different phases of the 
problem solution. The phases include preparation, scheduling, operation, and 

rescheduling. 

During the preparation phase the individual experiment information is provided 
to the system from an external data base source and appropriately stored, also the 
working memory is organized and then prioritized for the scheduling phase. This is 
accomplished using a priority scheme developed from user input. In the scheduling 
phase, the experiments are scheduled under the previously explained heuristic 
procedure and the schedule is created. The schedule itself is part of the knowledge 
base and is represented as frames. As experiments are scheduled, the subintervals 
required by the heuristic procedure are defined by start and stop times of the 
experiments. For each interval the power available, crew available, and the 
experiments that are currently on—going are determined and stored. This information 
is required for the remaining two phases, namely operation and rescheduling. The 
initial schedule is provided to the user for evaluation in a Gantt chart format with 
appropriate labels (i.e., experiment identification, start and end times, resource 
loadings, etc.). The user is then afforded an apportunity to make several types of 
scheduling changes including changing the planning horizon, manually scheduling 
experiments, reprioritizing experiments, changing rfesource parameters, etc. Based 
on nthe changes specified, the system determines whether any rule/const rai nt 
conflicts exi9t and if so performs a rescheduling operation as described below to 
resolve the conflicts. In cases where the specified changes do not allow for 
conflict resolution, the user is so informed. 

The output interface during the operation and rescheduling phases is graphical 
in nature and menu driven. During the operation and rescheduling phases, the system 
simulates control of the power source for the experiments, i.e., it turns them off 
or on at the appropriate times indicated by the schedule and updates all the 
necessary interface information accordingly. The operation phase has two modes: 
(1) static and (2) dynamic. In the static mode, the system is capable of displaying 
a power utilization graph for a two week, one week, one day or six hour period of 
time. Also, the vital information for each experiment (start time, end time, etc.) 
can be requested by the user simply by using the mouse and a selection menu. In the 
dynamic mode, the system uses the output interface (see figure 2) to interact with 
the user through four basic windows — a current status window, a schedule window, a 
power curve window and a message window. The current status window shows the 
current status of all the experiments of a payload at a particular point in time. 
This is accomplished, as Illustrated in the window at the top of the screen in 
figure 2, by representing each experiment as a numbered box. Reverse video is 
then used to differentiate the on state. Labels placed within the boxes indicate 
such statuses as aborted, removed, completed, etc. The schedule window (bottom left 
of screen in figure 2) displays the names of the experiments on separate lines and 
uses a Gantt chart format similar to that shown in figure 1 to display the 
scheduling of each experiment. This window simulates movement through time, i.e. as 


E-5 


time passes the bars that represent the experiment move to the left and disappear as 
the experiment is completed. When the experiment is completed the word "completed" 
appears next to the experiment name. In the schedule window the experiments are also 
numbered to provide a cross-reference to the numbered experiment boxes in the 
current status window. The power curve window (middle right of display screen) plots 
percent power utilization as it scrolls through time. The remaining window is the 
message Window. This is used for interaction and control purposes. 

One of the important capabilities built into this system is its ability to 

reschedule the experiments when deemed necessary. This is one of the main 
differentiators of this system when compared to others developed for such scheduling 
applications. The system is capable of determining when it is necessary to 

reschedule. When such a determination is made, the experiments affected are 

Identified and removed from the active schedule. A rescheduling is conducted and 
the new schedule is implemented (i.e., made active). There are, based on the 
initial problem description, a limited number of occurences that would warrant a 
reschedule. These Include an experiment failure, an experiment abort, a power 

allotment increase or decrease, or the announced arrival of orbital docking and/or 
servicing vehicles. The first two occurrences require an automatic rescheduling 
while the others require the system to check working memory and the knowledge base 
to determine if rescheduling is in fact necessary. Thus we see the system is 
capable of moving between the different phases, capable of recognizing where it Is 
and what knowledge is applicable, and dynamic in its ability to genenrate and 
maintain a schedule that will accomplish the objective or objectives of the mission 
as specified by mission 
planning specialists. 


5. FUTURE ENHANCEMENTS 


While the system demonstrates the potential of using a knowledge base system 
approach in the area of scheduling, there are several enhancements that have 
been identified and are currently being implemented to improve the 

performance and capabilities of the system. First and foremost is that more 

experiential knowledge needs to be added to the knowledge base. Sessions have been 
scheduled with the appropriate NASA personnel to begin the task of knowledge 
engineering [2] [3] (11] [18]. Also, knowledge concerning the determination of 

alternatives to the schedule instead of just developing a single initial schedule 
will be added. This will provide the system with the capability of helping NASA 
personnel in satisfying the dynamic objectives experienced during a mission and 
will also facilitate the rescheduling process. An example of such an objective is 
when power allotment reduction forces the schedule to run past the end-of-missi on 
time. Having "knowledge" of alternatives, the system will have a better 

understanding of which experiments to schedule. Should it continue with the normal 
rescheduling rules or does some special set of priorities apply? Not only will more 
objectives be handled in the enhanced system, but the system will be able to handle 
more constraints, (e.g., fluctuating power requirements of experiments, orientation 
the experiments, etc.). Another area of knowledge enhancement concerns 

the rescheduling function. It has been determined that the system should be 
capable of performing a quick-fix reschedule when necessary. This will provide 
the necessary time to perform a more detailed and thorough reschedule in the event 
of an emergency situation where a temporary "quick fix" is necessary. 


The second area of improvement and enhancement to the system is efficiency. 
Not only is the efficiency of the code being considered, but a more efficient and 
effective method for searching the schedule and determining experiment slots is 


E-6 



under development. This search process, as was mentioned previously, Is complicated 
by the scheduling of intermittent experiments early in the scheduling process. In 
particular, one experiment in the sample data is required to be scheduled ten 
minutes out of every hour that the mission is operating. Under the present system 
this creates 336 additional time intervals that might have to be checked for power 
and crew availability in determining a feasible interval for a later experiment. 

The present system takes 15 minutes to schedule the 47 test experiments. The 

majority of this time is due to the early scheduling of intermittent experiments. 
Another efficiency enhancement is for the system itself to determine the mission 
time horizon. This will reduce any excess time that is added in order to accomodate 

all the experiments. At present, the time horizon is driven by the number of 

experiments requireing crew involvement and the number of crew available to work 
with the experiments. A critical path algorithm is being investigated for 
application in this area. 6 


The final area of enhancements is in the user interface, both input and output 
nterfaces . On the input side, a query/answer system will be added to allow for 
easy input of experiment data and knowledge base maintenance. This interface will 

have a limited, natural language parser [10] [12] and will exploit the use of 
graphics. On the output side several enhancements will be made. First, the system 
will have an explanation capability for how and why it chose the schedule it is 
recommending. This capability will soon be provided since the system is currently 
being redone using an expert system shell which provides how and why facilities 
Also, a hardcopy capability for printing out the schedule in "readable" form will be 
added. Currently the schedule is only stored in symbiolic form. These output 

enhancements will facilitate the evaluation of system performance. This should 

^ yS , Cem 1 in CUCn t0 gain U8er acce Ptance more quickly and will also help 
facilitate the implementation phase. ^ 


6. CONCLUSIONS 

ofaM ThlS papa * has detailed a knowledge-based system for solving the NASA space 
station payload/experiment scheduling problem. The problem is representative of a 
larger class of dynamic scheduling problems which, for the most part, have been 
ineffectively handled using more traditional numeric techniques. An expert systems 
approach aliows one to effectively deal with the dynamics and incorap leteinf ormati on 
c characterize this class of problem. Still in prototype form the system is 
meeting with wide acceptance and interest not only from the sponsoring agency but 
also from other independent sources. * 

The interest this project has received indicates that there is potential for 

schId e Hn reSearC l l a ln thlS area I ThC Wlde problen domain encompassed by dynamic 
scheduling provides many areas for future applications (e.g., project scheduling 

production scheduling, manpower scheduling,, etc.). Additionally, as systems afe 
implemented and knowledge engineering continues, there is a good likelihood that 
cmmon.lt ties will bo established across cartons scheduling sppuLtton" 
inis would allow devlopment of an expert system shell for such problems. Such 
a shell would allow scheduling systems to be readily developed and implemented. 

REFERENCES 

1 ; Baker, K. R. , Introduction to Sequencing and Scheduling. New York: John 

wxiey and Sons, Inc. 1974. 

2. Barr, A. and Flegenbaum, E., The Handbook of Artificial Intel l i aanna 
Volumes I and II, William KaufmaUHJ TRc. , 19827 - ■ 8 1 


E-7 



3. Davis, Randall, and Douglas B. Lenat , Knowledge - Baaed Systems i£ 

Artificial Intelligence, New York: McGraw - Hill, Inc., 1982. 

4. French, S. , Sequencing and Sche duling: An Introduction to the Mathematics 
of the Job Shop , New York: John Wiley and Sons, Inc., 1982. 

37 HarmonT Paul, and David King, Expert Systems , New York: John Wiley and 
Sons, Inc., 1985. 

6. Johnson, L. A. and D. C. Montgomery, Operations Research in Production 

Planning, Scheduling^ and Inventory Control, New York: John Wiley and Sons, 

Inc., l$M. 

7. Lawler, E. L., J. K. Lenstra and A. H. G. Rinnooy Kan, "Recent Developments 

in Deterministic Sequencing and Scheduling: A Survey," in M. A. H. Dempster 

et. al. (Eds.), Deterministic and Stochastic Scheduling, Reidel, Dordrecht, 

1982, 35-73. 

8. Lehner, P. E. and Donnel, M. L. "Building Decision Aids: Exploiting the 

Synergy Between Decision Analysis and Artificial Intelligence," Paper at 
ORSA/TIMS, San Francisco, May 1984. 

9. Little, John D. C., "Research Opportunities in the Decision and Management 
Sciences", Management Science, Vol. 32, No. 1, January 1986. 

10. Rauch-Hindin, Wendy, "Natural Language: An Easy Way to Talk to Computers," 
Systems & Software, January, 1984, pp. 187—230. 

11. Riesbeck, C. K. and Roger Schank, "Comprehension by Computer: Expectation- 
based Analysis of Sentences in Context," in W. J. M. Levelt and G. B. Hores 
d'Arcais (Eds .) . Studies in the Perception of Language . Chichester, England: 

John Wiley and Sons, 1976, pp. 247-294. 

12. Rich, E., Artificial Intelligence , New York: McGraw-Hill, Inc., 1983. 

13. Sprague, R. , "The Role of Expert Systems in DSS," Paper at ORSA/TIMS, 
Dallas, Nov. 1984. 

14. Symbolics software. Report, Symbolics, Inc., 21150 Califa Street, 

Woodland Hills, California, 1981. 

15. Tersine, Richard J., Production/Operations Management : Concepts , 

Structure, and Analysis, (2nd ed.), New York: North— Holland Press, T985. 

IFI TurbanTT. , and King, David, "Building Expert Systems For Decision 
Support," DSS-86 Transactions, Jane Fedorowicz, Editor, 1986. 

17. Turban, E., and Watkins, P., "Integrating Expert Systems and Decision 
Support Systems," MIS Quarterly , June 1986. 

18. Waterman, Donald A., A Guide to Expert Systems , Reading, Massachusetts: 
Addison-Wesley Publishing Company, 

19. Winston, Patrick H. , Artlcial Intelligence , (2nd ed.), Reading, 

Massachusetts: Addison— Wesley Publishing Company, 1984. 

20. Winston, P. H. , and Horn, B. K. P. USP , Reading, Massachusetts: Addison-. 

Wesley Publishing Company. 


E-3 


LABORATORY MODULE - SPACE STATION 
DYNAMIC PAYLOAD SCHEDULER 


SUBSYSTEMS: 


POWERPRIORITT 

NAME WATTS CLASS AGENCY DURATION CR£W 


ECLSS 

6200 

I 

NASA 

CONTINUOUS W/20 
MIN. LAPSES OKAY 
EVERY 4 HRS. 

0 

COMMUNICATIONS 

uao 

I 

NASA 

CONTINUOUS 

0 

THERMAL CONTROL 

600 

I 

NASA 

CO NT INUOUS-REDUCES 
LINEARLY TO 400W FOR 
10 KW POWER LEVELS 

0 

HOUSEKEEPING(MISC) 

6000 

I 

NASA 

CONTINUOUS 

L 


PAYLOAD/EXPERIMENTS I 
000/ PAYLOAD l 

890 

II 

DOD 

48 HRS 


1 

ESA PAYLOAD l 

1845 

II 

ESA 

214 HRS 


1 

IPS 

165 

II 

ESA 

240 HRS 


1 

ELECT DIAC STA 

435 

II 

NASA 

10 MIN OF 

EVERY HR 

l 

IECM 

480 

III 

NASA 

200 HRS 


0 

CRNE 

930 

IV 

U.K. 

240 HRS 


0 

GEN PURPOSE COMP 

383 

III 

NASA 

CONTINUOUS 


1 

SOLID POLYMER ELECT 

415 

IV 

3M 

36 HRS 

(5 MIN/HR) 
1-5 MIN. 

IEF 

125 

IV 

NASA 

6 HRS 

EVERY 3 

HRS 

0 

MLR 

350 

IV 

U/IOWQ 

20 HRS 


0 

FES-VCCS 

600 

III 

NASA 

15 HRS 


0 

ROT I 

36 

IV 

UAH 

43 HRS 


0 

SEM 

2648 

IV 

NASA 

6 HRS 


0 

RTG 

94 

IV 

NASA 

12 HRS 


0 

TAPE RECORDER 1 

85 

II 

NASA 

CONTINUOUS 


0 

TIME CODE GEN 

32 

II 

NASA 

CONTINUOUS 


0 

MASS SPECTROMETER 

215 

tv 

JAPAN 

2 HRS 


0 

TOOL CHARGER 

50 

tl 

NASA 

CONTINUOUS 


0 

FILM PROCESSOR 

163 

II 

NASA 

1 HR/DAY* 


1 

SUPER FURNANCE 

7840 

II 

G.E. 

32 HRS 


0 

SILICON WAFER PROD 

4760 

III 

INTEL 

14 HRS 


0 

TAPE RECORDER 2 

85 

III 

NASA 

CONTINUOUS 


0 

TCA 

612 

IV 

ESA 

8 HRS 


0 

MEA 

1800 

IV 

NASA 

14 HRS 


0 

WELDING EXP 

1610 

IV 

NASA 

4 HRS 


0 

CFES 

890 

III 

NASA 

36 HRS 


0 

3-AAL 

500 

IV 

NASA 

10 HRS 


0 

EML 

420 

IV 

NASA 

2 HRS 


0 

CFFC 

375 

IV 

NASA 

6 HRS 


0 

ADSF 

480 

IV 

NASA 

48 HRS 


1 

ARC 

215 

IV 

NASA 

8 HRS 


0 

SAFE 

400 

in 

NASA 

15 HRS 


1 

SOLAR OBS 

375 

II 

NASA 

ORBIT/ DAYTIME ONLY 

◦ 

LIGHTNING DET 

125 

IV 

NASA 

FOR 36 ORBITS 
ORBIT NIGHTTIME ONLY 

0 

CRYSTAL GROWTH 

1200 

II 

NASA 

FOR 12 ORBITS 
1 HR 

0 

COMET SEARCH 

650 

III 

JAPAN 

ORBIT NIGHTTIME ONLY 

0 

LIFE SCI 1 

135 

III 

A6M 

FOR 40 ORBITS 
36 HRS 

0 

LIFE SCI 2 

1145 

III 

UAB 

22 HRS 


0 

LIFE SCI 3 

842 

HI 

UAB 

66 HRS 


0 

CLASSIFIED L 

1300 

II 

DOD 

8 HRS 


0 

CLASSIFIED 2 

645 

II 

DOD 

18 HRS 


0 

MAPPING (WEATHER) 

300 

III 

USWS 

CONTINUOUS 

(CAN BE 

0 

MAPPING (GEO) 

690 

III 

uses 

INTERRUPTED ANYTIME) 
60 HRS 

0 

ORB ITER DOCKING 

6500 

** 

NASA 

24-72 HRS. 

WILL BE 

0 

ORBITER SERVICER 

2400 

' ** 

NASA 

GIVEN 6 HRS NOTICE 
4-10 HRS. WILL BE 

0 





GIVEN 2 HRS NOTICE 



** WILL BE GIVEN TOP PAYLOAD PRIORITY WHEN NEEDED 


Table 1. Experiment Data 


E-9 


Experiment 



OKKJJNAL PAGE IS 
OF POOR QUALITY 


Available (KV) | 5 | 3 | 5 | 3 | 1 | 3 | 11 } 13 


Figure 1. Example Schedule 


pa a □ □ □ r i r i r i c i t i r i r: i r; i t 1 1\ 

Id fh ri n r~i f r n f* r r I |n I | Mi I Iti | Mi | if/-i | | 

ph b> i u g-j u ki ig...i * l«j kj k I*# 4 m ^ | i* | u* 

^ ' Sutu •Isplev > 

n □□□□□□□ Cl a □ c | [:: ! !•: ' ri r. 


TO* 

Dynamic 

Scheduler 

I l.y.1 

•mat 

Ihaeaaaif I m al 
l.'W.I IfC, i«*,/ 



E- 10 





